;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-LITERALS-STELLA-BOOLEAN NULL)
(CL:DEFVAR KWD-LITERALS-NULL-WRAPPER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-FALSE-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-INTEGER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-FLOAT NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-FLOAT-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-STRING NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-STRING-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-MUTABLE-STRING NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-MUTABLE-STRING-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-CHARACTER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-CHARACTER-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-FUNCTION-CODE NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-FUNCTION-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-METHOD-CODE NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-METHOD-CODE-WRAPPER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-TRUE NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-TRUE-WRAPPER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-FALSE NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-BOOLEAN NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-INLINE-WRAP-BOOLEAN NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-INLINE-WRAP-BOOLEAN-EXPANDER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-INLINE-UNWRAP-BOOLEAN NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-INLINE-UNWRAP-BOOLEAN-EXPANDER NULL)
(CL:DEFVAR KWD-LITERALS-WRAP-FUNCTION NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-INTEGER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-FLOAT NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-STRING NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-CHARACTER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-FUNCTION-CODE NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-METHOD-CODE NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NIL NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-CONS NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-LITERAL NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-GET-KWD NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-TYPED-SYS NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-SYMBOL NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-GET-SGT NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-INTERN-COMMON-LISP-SYMBOL NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-GET-SYM NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-CONS NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-LIST* NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-& NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-&& NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-CONCATENATE NULL)
(CL:DEFVAR KWD-LITERALS-OTHER NULL)
(CL:DEFVAR KWD-LITERALS-DIGIT NULL)
(CL:DEFVAR KWD-LITERALS-LETTER NULL)
(CL:DEFVAR KWD-LITERALS-SYMBOL-CONSTITUENT NULL)
(CL:DEFVAR KWD-LITERALS-SYMBOL-QUALIFIER NULL)
(CL:DEFVAR KWD-LITERALS-ESCAPE NULL)
(CL:DEFVAR KWD-LITERALS-DELIMITER NULL)
(CL:DEFVAR KWD-LITERALS-WHITE-SPACE NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* SYMBOL-SYM STANDARD-OUTPUT EOL))

;;; (DEFGLOBAL ZERO-WRAPPER ...)

(CL:DEFVAR ZERO-WRAPPER NULL)

;;; (DEFGLOBAL ONE-WRAPPER ...)

(CL:DEFVAR ONE-WRAPPER NULL)

;;; (DEFGLOBAL FALSE-WRAPPER ...)

(CL:DEFVAR FALSE-WRAPPER NULL)

;;; (DEFGLOBAL TRUE-WRAPPER ...)

(CL:DEFVAR TRUE-WRAPPER NULL)

;;; (DEFGLOBAL NULL-INTEGER-WRAPPER ...)

(CL:DEFVAR NULL-INTEGER-WRAPPER NULL)

;;; (DEFGLOBAL NULL-FLOAT-WRAPPER ...)

(CL:DEFVAR NULL-FLOAT-WRAPPER NULL)

;;; (DEFGLOBAL NULL-STRING-WRAPPER ...)

(CL:DEFVAR NULL-STRING-WRAPPER NULL)

;;; (DEFGLOBAL NULL-MUTABLE-STRING-WRAPPER ...)

(CL:DEFVAR NULL-MUTABLE-STRING-WRAPPER NULL)

;;; (DEFGLOBAL NULL-CHARACTER-WRAPPER ...)

(CL:DEFVAR NULL-CHARACTER-WRAPPER NULL)

;;; (DEFGLOBAL NULL-FUNCTION-CODE-WRAPPER ...)

(CL:DEFVAR NULL-FUNCTION-CODE-WRAPPER NULL)

;;; (DEFGLOBAL NULL-METHOD-CODE-WRAPPER ...)

(CL:DEFVAR NULL-METHOD-CODE-WRAPPER NULL)

;;; (DEFMETHOD (TERMINATE-WRAPPER? BOOLEAN) ...)

(CL:DEFMETHOD TERMINATE-WRAPPER? ((SELF WRAPPER))
  (CL:IF
   (CL:OR (CL:EQ SELF NULL-FLOAT-WRAPPER) (CL:EQ SELF NULL-STRING-WRAPPER)
    (CL:EQ SELF NULL-MUTABLE-STRING-WRAPPER)
    (CL:EQ SELF NULL-CHARACTER-WRAPPER)
    (CL:EQ SELF NULL-FUNCTION-CODE-WRAPPER)
    (CL:EQ SELF NULL-METHOD-CODE-WRAPPER))
   (CL:RETURN-FROM TERMINATE-WRAPPER? FALSE)
   (CL:RETURN-FROM TERMINATE-WRAPPER? TRUE))
  (CL:ERROR
   "Returned from `|M|WRAPPER.TERMINATE-WRAPPER?' without a `return'."))

;;; (DEFMETHOD (TERMINATE-WRAPPER? BOOLEAN) ...)

(CL:DEFMETHOD TERMINATE-WRAPPER? ((SELF INTEGER-WRAPPER))
  (CL:IF
   (CL:OR (CL:EQ SELF ZERO-WRAPPER) (CL:EQ SELF ONE-WRAPPER)
    (CL:EQ SELF NULL-INTEGER-WRAPPER))
   (CL:RETURN-FROM TERMINATE-WRAPPER? FALSE)
   (CL:RETURN-FROM TERMINATE-WRAPPER? TRUE))
  (CL:ERROR
   "Returned from `|M|INTEGER-WRAPPER.TERMINATE-WRAPPER?' without a `return'."))

;;; (DEFGLOBAL *LITERAL-TYPE-INFO-TABLE* ...)

(CL:DEFVAR *LITERAL-TYPE-INFO-TABLE* NULL
  "Table that holds a variety of information about literal
types, e.g., the name of their null-wrapper, wrap-function, etc.")

;;; (DEFGLOBAL *LITERAL-TYPES* ...)

(CL:DEFVAR *LITERAL-TYPES* NULL
  "List of literal types stored in '*literal-type-info-table*'.
Maintained for iteration purposes.")

;;; (DEFUN (LOOKUP-LITERAL-TYPE-INFO OBJECT) ...)

(CL:DEFUN LOOKUP-LITERAL-TYPE-INFO (TYPE KEY)
  (CL:LET* ((ENTRY (LOOKUP *LITERAL-TYPE-INFO-TABLE* TYPE)))
   (CL:IF (CL:NOT (CL:EQ ENTRY NULL))
    (CL:RETURN-FROM LOOKUP-LITERAL-TYPE-INFO (LOOKUP ENTRY KEY))
    (CL:RETURN-FROM LOOKUP-LITERAL-TYPE-INFO NULL)))
  (CL:ERROR "Returned from `|F|LOOKUP-LITERAL-TYPE-INFO' without a `return'."))

;;; (DEFUN SET-LITERAL-TYPE-INFO ...)

(CL:DEFUN SET-LITERAL-TYPE-INFO (TYPE KEY VALUE)
  (CL:LET* ((ENTRY (LOOKUP *LITERAL-TYPE-INFO-TABLE* TYPE)))
   (CL:WHEN (CL:EQ ENTRY NULL) (CL:SETQ ENTRY (NEW-KEY-VALUE-LIST))
    (INSERT-AT *LITERAL-TYPE-INFO-TABLE* TYPE ENTRY)
    (INSERT-LAST *LITERAL-TYPES* TYPE))
   (INSERT-AT ENTRY KEY VALUE))
  :VOID)

;;; (DEFUN (WRAP-INTEGER INTEGER-WRAPPER) ...)

(CL:DEFUN WRAP-INTEGER (VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM VALUE))
  (CL:IF (NULL? VALUE) (CL:RETURN-FROM WRAP-INTEGER NULL-INTEGER-WRAPPER)
   (CL:CASE VALUE (0 (CL:RETURN-FROM WRAP-INTEGER ZERO-WRAPPER))
    (1 (CL:RETURN-FROM WRAP-INTEGER ONE-WRAPPER))
    (CL:OTHERWISE (CL:RETURN-FROM WRAP-INTEGER (NEW-INTEGER-WRAPPER VALUE)))))
  (CL:ERROR "Returned from `|F|WRAP-INTEGER' without a `return'."))

;;; (DEFUN (WRAP-FLOAT FLOAT-WRAPPER) ...)

(CL:DEFUN WRAP-FLOAT (VALUE)
  (CL:IF (CL:EQ VALUE NULL-FLOAT)
   (CL:RETURN-FROM WRAP-FLOAT NULL-FLOAT-WRAPPER)
   (CL:RETURN-FROM WRAP-FLOAT (NEW-FLOAT-WRAPPER VALUE)))
  (CL:ERROR "Returned from `|F|WRAP-FLOAT' without a `return'."))

;;; (DEFUN (WRAP-STRING STRING-WRAPPER) ...)

(CL:DEFUN WRAP-STRING (VALUE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
  (CL:IF (CL:EQ VALUE NULL) (CL:RETURN-FROM WRAP-STRING NULL-STRING-WRAPPER)
   (CL:RETURN-FROM WRAP-STRING (NEW-STRING-WRAPPER VALUE)))
  (CL:ERROR "Returned from `|F|WRAP-STRING' without a `return'."))

;;; (DEFUN (WRAP-MUTABLE-STRING MUTABLE-STRING-WRAPPER) ...)

(CL:DEFUN WRAP-MUTABLE-STRING (VALUE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
  (CL:IF (NULL? VALUE)
   (CL:RETURN-FROM WRAP-MUTABLE-STRING NULL-MUTABLE-STRING-WRAPPER)
   (CL:RETURN-FROM WRAP-MUTABLE-STRING (NEW-MUTABLE-STRING-WRAPPER VALUE)))
  (CL:ERROR "Returned from `|F|WRAP-MUTABLE-STRING' without a `return'."))

;;; (DEFUN (WRAP-CHARACTER CHARACTER-WRAPPER) ...)

(CL:DEFUN WRAP-CHARACTER (VALUE)
  (CL:IF (NULL? VALUE) (CL:RETURN-FROM WRAP-CHARACTER NULL-CHARACTER-WRAPPER)
   (CL:RETURN-FROM WRAP-CHARACTER (NEW-CHARACTER-WRAPPER VALUE)))
  (CL:ERROR "Returned from `|F|WRAP-CHARACTER' without a `return'."))

;;; (DEFUN (WRAP-FUNCTION-CODE FUNCTION-CODE-WRAPPER) ...)

(CL:DEFUN WRAP-FUNCTION-CODE (VALUE)
  (CL:IF (CL:EQ VALUE NULL)
   (CL:RETURN-FROM WRAP-FUNCTION-CODE NULL-FUNCTION-CODE-WRAPPER)
   (CL:RETURN-FROM WRAP-FUNCTION-CODE (NEW-FUNCTION-CODE-WRAPPER VALUE)))
  (CL:ERROR "Returned from `|F|WRAP-FUNCTION-CODE' without a `return'."))

;;; (DEFUN (WRAP-METHOD-CODE METHOD-CODE-WRAPPER) ...)

(CL:DEFUN WRAP-METHOD-CODE (VALUE)
  (CL:IF (CL:EQ VALUE NULL)
   (CL:RETURN-FROM WRAP-METHOD-CODE NULL-METHOD-CODE-WRAPPER)
   (CL:RETURN-FROM WRAP-METHOD-CODE (NEW-METHOD-CODE-WRAPPER VALUE)))
  (CL:ERROR "Returned from `|F|WRAP-METHOD-CODE' without a `return'."))

;;; (DEFUN (WRAP-BOOLEAN BOOLEAN-WRAPPER) ...)

(CL:DEFUN WRAP-BOOLEAN (VALUE)
  (CL:RETURN-FROM WRAP-BOOLEAN (CL:IF VALUE TRUE-WRAPPER FALSE-WRAPPER)))

;;; (DEFUN (UNWRAP-BOOLEAN BOOLEAN) ...)

(CL:DEFUN UNWRAP-BOOLEAN (WRAPPER)
  (CL:RETURN-FROM UNWRAP-BOOLEAN (EQ? WRAPPER TRUE-WRAPPER)))

;;; (DEFUN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN BOOLEAN) ...)

(CL:DEFUN COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (WRAPPER)
  (CL:WHEN (CL:EQ WRAPPER NULL)
   (CL:WARN
    "Coercing an undefined BOOLEAN-WRAPPER to FALSE.  Explicitly guard~% with `defined?' or use `unwrap-boolean' to avoid this warning."))
  (CL:RETURN-FROM COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (EQ? WRAPPER TRUE-WRAPPER)))

;;; (DEFMACRO INLINE-WRAP-BOOLEAN ...)

(CL:DEFUN INLINE-WRAP-BOOLEAN-EXPANDER (EXPRESSION)
  (CL:COND
   ((CL:EQ EXPRESSION SYM-LITERALS-STELLA-TRUE)
    (CL:RETURN-FROM INLINE-WRAP-BOOLEAN-EXPANDER
     SYM-LITERALS-STELLA-TRUE-WRAPPER))
   ((CL:EQ EXPRESSION SYM-LITERALS-STELLA-FALSE)
    (CL:RETURN-FROM INLINE-WRAP-BOOLEAN-EXPANDER
     SYM-LITERALS-STELLA-FALSE-WRAPPER))
   (CL:T
    (CL:RETURN-FROM INLINE-WRAP-BOOLEAN-EXPANDER
     (LIST* SYM-LITERALS-STELLA-WRAP-BOOLEAN EXPRESSION NIL))))
  (CL:ERROR
   "Returned from `|F|INLINE-WRAP-BOOLEAN-EXPANDER' without a `return'."))

;;; (DEFMACRO INLINE-UNWRAP-BOOLEAN ...)

(CL:DEFUN INLINE-UNWRAP-BOOLEAN-EXPANDER (EXPRESSION)
  (CL:COND
   ((CL:EQ EXPRESSION SYM-LITERALS-STELLA-TRUE-WRAPPER)
    (CL:RETURN-FROM INLINE-UNWRAP-BOOLEAN-EXPANDER SYM-LITERALS-STELLA-TRUE))
   ((CL:EQ EXPRESSION SYM-LITERALS-STELLA-FALSE-WRAPPER)
    (CL:RETURN-FROM INLINE-UNWRAP-BOOLEAN-EXPANDER SYM-LITERALS-STELLA-FALSE))
   (CL:T
    (CL:RETURN-FROM INLINE-UNWRAP-BOOLEAN-EXPANDER
     (LIST* SYM-LITERALS-STELLA-COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN EXPRESSION
      NIL))))
  (CL:ERROR
   "Returned from `|F|INLINE-UNWRAP-BOOLEAN-EXPANDER' without a `return'."))

;;; (DEFMETHOD (WRAP-LITERAL INTEGER-WRAPPER) ...)

(CL:DEFMETHOD WRAP-LITERAL ((VALUE CL:INTEGER))
  (CL:DECLARE (CL:TYPE CL:FIXNUM VALUE))
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-INTEGER VALUE)))

;;; (DEFMETHOD (WRAP-LITERAL FLOAT-WRAPPER) ...)

(CL:DEFMETHOD WRAP-LITERAL ((VALUE CL:FLOAT))
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-FLOAT VALUE)))

;;; (DEFMETHOD (WRAP-LITERAL MUTABLE-STRING-WRAPPER) ...)

(CL:DEFMETHOD WRAP-LITERAL ((VALUE CL:STRING))
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-MUTABLE-STRING VALUE)))

;;; (DEFMETHOD (WRAP-LITERAL STRING-WRAPPER) ...)

(CL:DEFMETHOD WRAP-LITERAL ((VALUE CL:STRING))
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-STRING VALUE)))

;;; (DEFMETHOD (WRAP-LITERAL CHARACTER-WRAPPER) ...)

(CL:DEFMETHOD WRAP-LITERAL ((VALUE CL:CHARACTER))
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-CHARACTER VALUE)))

;;; (DEFMETHOD (WRAP-LITERAL FUNCTION-CODE-WRAPPER) ...)

(CL:DEFMETHOD WRAP-LITERAL ((VALUE CL:FUNCTION))
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-FUNCTION-CODE VALUE)))

;;; (DEFMETHOD (WRAP-LITERAL METHOD-CODE-WRAPPER) ...)

(CL:DEFMETHOD WRAP-LITERAL ((VALUE CL:STANDARD-GENERIC-FUNCTION))
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-METHOD-CODE VALUE)))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(%%DEFCONSMETHOD COPY-WRAPPED-LITERAL ((SELF STANDARD-OBJECT))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL SELF))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF LITERAL-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL SELF))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF INTEGER-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL (WRAP-INTEGER (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF FLOAT-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL (WRAP-FLOAT (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF STRING-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL (WRAP-STRING (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF MUTABLE-STRING-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL
   (WRAP-MUTABLE-STRING (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF CHARACTER-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL (WRAP-CHARACTER (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF FUNCTION-CODE-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL
   (WRAP-FUNCTION-CODE (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF METHOD-CODE-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL
   (WRAP-METHOD-CODE (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X OBJECT) Y)
  (CL:ERROR "object-eql?: Don't know how to compare `~A' with `~A'" X Y)
  (CL:ERROR "Returned from `|M|OBJECT.OBJECT-EQL?' without a `return'."))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(%%DEFCONSMETHOD OBJECT-EQL? ((X STANDARD-OBJECT) Y)
  (CL:RETURN-FROM OBJECT-EQL? (EQ? X Y)))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X INTEGER-WRAPPER) Y)
  (CL:RETURN-FROM OBJECT-EQL?
   (CL:AND (INTEGER? Y) (CL:= (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X FLOAT-WRAPPER) Y)
  (CL:RETURN-FROM OBJECT-EQL?
   (CL:AND (FLOAT? Y) (CL:= (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X BOOLEAN-WRAPPER) Y)
  (CL:RETURN-FROM OBJECT-EQL? (EQ? X Y)))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X STRING-WRAPPER) Y)
  (CL:RETURN-FROM OBJECT-EQL?
   (CL:AND (STRING? Y) (STRING-EQL? (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X MUTABLE-STRING-WRAPPER) Y)
  (CL:RETURN-FROM OBJECT-EQL? (EQ? X Y)))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X CHARACTER-WRAPPER) Y)
  (CL:RETURN-FROM OBJECT-EQL?
   (CL:AND (CHARACTER? Y) (CL:EQL (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))

;;; (DEFUN (EQL? BOOLEAN) ...)

(CL:DEFUN EQL? (X Y)
  "'eql?' translates into the C++ '==' except that 
   (1) it tests for string equivalence when its first argument is a string,
   and (2) it understands wrapped literals."
  (CL:RETURN-FROM EQL? (CL:IF (CL:EQ X NULL) (NULL? Y) (OBJECT-EQL? X Y))))

;;; (DEFUN (EQL-TO-BOOLEAN? BOOLEAN) ...)

(CL:DEFUN EQL-TO-BOOLEAN? (Y X)
  (CL:RETURN-FROM EQL-TO-BOOLEAN?
   (CL:AND (BOOLEAN? Y) (CL:EQ (%WRAPPER-VALUE Y) X))))

;;; (DEFUN (EQL-TO-INTEGER? BOOLEAN) ...)

(CL:DEFUN EQL-TO-INTEGER? (Y X)
  (CL:DECLARE (CL:TYPE CL:FIXNUM X))
  (CL:RETURN-FROM EQL-TO-INTEGER?
   (CL:AND (INTEGER? Y) (CL:= (%WRAPPER-VALUE Y) X))))

;;; (DEFUN (EQL-TO-FLOAT? BOOLEAN) ...)

(CL:DEFUN EQL-TO-FLOAT? (Y X)
  (CL:RETURN-FROM EQL-TO-FLOAT?
   (CL:AND (FLOAT? Y) (CL:= (%WRAPPER-VALUE Y) X))))

;;; (DEFUN (EQL-TO-STRING? BOOLEAN) ...)

(CL:DEFUN EQL-TO-STRING? (Y X)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X))
  (CL:RETURN-FROM EQL-TO-STRING?
   (CL:AND (STRING? Y) (STRING-EQL? (%WRAPPER-VALUE Y) X))))

;;; (DEFUN (EQL-TO-CHARACTER? BOOLEAN) ...)

(CL:DEFUN EQL-TO-CHARACTER? (Y X)
  (CL:RETURN-FROM EQL-TO-CHARACTER?
   (CL:AND (CHARACTER? Y) (CL:EQL (%WRAPPER-VALUE Y) X))))

;;; (DEFUN (HELP-BQUOTIFY OBJECT) ...)

(CL:DEFUN HELP-BQUOTIFY (TREE)
  (CL:WHEN (CL:EQ TREE NULL)
   (CL:RETURN-FROM HELP-BQUOTIFY SYM-LITERALS-STELLA-NULL))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-LITERALS-STELLA-CONS)
     (CL:PROGN
      (CL:IF (CL:EQ TREE NIL)
       (CL:RETURN-FROM HELP-BQUOTIFY SYM-LITERALS-STELLA-NIL)
       (CL:RETURN-FROM HELP-BQUOTIFY
        (CONS-LIST SYM-LITERALS-STELLA-CONS (HELP-BQUOTIFY (%%VALUE TREE))
         (HELP-BQUOTIFY (%%REST TREE)))))))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM HELP-BQUOTIFY
       (CONS-LIST SYM-LITERALS-STELLA-WRAP-LITERAL TREE))))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM HELP-BQUOTIFY
       (CONS-LIST SYM-LITERALS-STELLA-WRAP-LITERAL TREE))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM HELP-BQUOTIFY
       (CONS-LIST SYM-LITERALS-STELLA-WRAP-LITERAL TREE))))
    ((SUBTYPE-OF-CHARACTER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM HELP-BQUOTIFY
       (CONS-LIST SYM-LITERALS-STELLA-WRAP-LITERAL TREE))))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (USE-HARDCODED-SYMBOLS?)
       (CL:RETURN-FROM HELP-BQUOTIFY
        (CONS-LIST SYM-LITERALS-STELLA-GET-KWD
         (WRAP-INTEGER (%SYMBOL-ID TREE))))
       (CL:RETURN-FROM HELP-BQUOTIFY
        (CONS-LIST SYM-LITERALS-STELLA-TYPED-SYS (REGISTER-SYMBOL TREE)
         SGT-LITERALS-STELLA-SYMBOL)))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (USE-HARDCODED-SYMBOLS?)
       (CL:RETURN-FROM HELP-BQUOTIFY
        (CONS-LIST SYM-LITERALS-STELLA-GET-SGT
         (WRAP-INTEGER (%SYMBOL-ID TREE))))
       (CL:RETURN-FROM HELP-BQUOTIFY
        (CONS-LIST SYM-LITERALS-STELLA-TYPED-SYS (REGISTER-SYMBOL TREE)
         SGT-LITERALS-STELLA-SYMBOL)))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (SYMBOL-COMMON-LISP? TREE)
       (CL:RETURN-FROM HELP-BQUOTIFY
        (CONS-LIST SYM-LITERALS-STELLA-INTERN-COMMON-LISP-SYMBOL
         (WRAP-STRING (%SYMBOL-NAME TREE))))
       (CL:IF (USE-HARDCODED-SYMBOLS?)
        (CL:RETURN-FROM HELP-BQUOTIFY
         (CONS-LIST SYM-LITERALS-STELLA-GET-SYM
          (WRAP-INTEGER (%SYMBOL-ID (PERMANENTIFY TREE)))))
        (CL:RETURN-FROM HELP-BQUOTIFY
         (CONS-LIST SYM-LITERALS-STELLA-TYPED-SYS (REGISTER-SYMBOL TREE)
          SGT-LITERALS-STELLA-SYMBOL))))))
    (CL:T
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*)) (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
        " Illegal argument to quote: `" (DE-UGLIFY-PARSE-TREE TREE) "'."
        EOL)))
     (CL:RETURN-FROM HELP-BQUOTIFY NULL))))
  (CL:ERROR "Returned from `|F|HELP-BQUOTIFY' without a `return'."))

;;; (DEFUN (BQUOTIFY OBJECT) ...)

(CL:DEFUN BQUOTIFY (TREE)
  (CL:RETURN-FROM BQUOTIFY (HELP-BQUOTIFY TREE)))

;;; (DEFUN (EXPAND-BQUOTE-TREE OBJECT) ...)

(CL:DEFUN EXPAND-BQUOTE-TREE (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-LITERALS-STELLA-CONS)
    (CL:PROGN
     (CL:LET*
      ((EXPANDEDTREE (CONS SYM-LITERALS-STELLA-LIST* NIL)) (CURSOR TREE)
       (TERM (%%VALUE CURSOR)))
      (CL:LOOP WHILE
       (CL:AND (CL:NOT (CL:EQ CURSOR NIL))
        (CL:NOT
         (CL:OR (CL:EQ TERM SYM-LITERALS-STELLA-&)
          (CL:EQ TERM SYM-LITERALS-STELLA-&&))))
       DO (CL:SETQ EXPANDEDTREE (CONS (EXPAND-BQUOTE-TREE TERM) EXPANDEDTREE))
       (CL:SETQ CURSOR (%%REST CURSOR)) (CL:SETQ TERM (%%VALUE CURSOR)))
      (CL:COND
       ((CL:EQ CURSOR NIL)
        (CL:RETURN-FROM EXPAND-BQUOTE-TREE
         (REVERSE (CONS SYM-LITERALS-STELLA-NIL EXPANDEDTREE))))
       ((CL:EQ TERM SYM-LITERALS-STELLA-&) (CL:SETQ CURSOR (%%REST CURSOR))
        (CL:WHEN (CL:EQ CURSOR NIL)
         (CL:LET* ((*PRINTREADABLY?* TRUE))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
            " Illegal bquote tree -- missing term after '&'.." EOL))))
        (CL:RETURN-FROM EXPAND-BQUOTE-TREE
         (REVERSE
          (CONS (EXPAND-BQUOTE-TREE (%%REST CURSOR))
           (CONS (%%VALUE CURSOR) EXPANDEDTREE)))))
       (CL:T (CL:SETQ CURSOR (%%REST CURSOR))
        (CL:WHEN (CL:EQ CURSOR NIL)
         (CL:LET* ((*PRINTREADABLY?* TRUE))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
            " Illegal bquote tree -- missing term after '&&'." EOL))))
        (CL:RETURN-FROM EXPAND-BQUOTE-TREE
         (REVERSE
          (CONS
           (CONS-LIST SYM-LITERALS-STELLA-CONCATENATE (%%VALUE CURSOR)
            (EXPAND-BQUOTE-TREE (%%REST CURSOR)))
           EXPANDEDTREE))))))))
   (CL:T (CL:RETURN-FROM EXPAND-BQUOTE-TREE (BQUOTIFY TREE))))
  (CL:ERROR "Returned from `|F|EXPAND-BQUOTE-TREE' without a `return'."))

;;; (DEFUN (SIMPLIFY-BQUOTE-TREE OBJECT) ...)

(CL:DEFUN SIMPLIFY-BQUOTE-TREE (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-LITERALS-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((CURSOR (%%REST TREE)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
       (CL:SETF (%%VALUE CURSOR) (SIMPLIFY-BQUOTE-TREE (%%VALUE CURSOR)))
       (CL:SETQ CURSOR (%%REST CURSOR)))
      (CL:WHEN (CL:NOT (CL:EQ (%%VALUE TREE) SYM-LITERALS-STELLA-LIST*))
       (CL:RETURN-FROM SIMPLIFY-BQUOTE-TREE TREE))
      (CL:CASE (LENGTH (%%REST TREE))
       (1 (CL:RETURN-FROM SIMPLIFY-BQUOTE-TREE (%%VALUE (%%REST TREE))))
       (2 (CL:SETF (%%VALUE TREE) SYM-LITERALS-STELLA-CONS)
        (CL:RETURN-FROM SIMPLIFY-BQUOTE-TREE TREE))
       (CL:OTHERWISE (CL:RETURN-FROM SIMPLIFY-BQUOTE-TREE TREE))))))
   (CL:T (CL:RETURN-FROM SIMPLIFY-BQUOTE-TREE TREE)))
  (CL:ERROR "Returned from `|F|SIMPLIFY-BQUOTE-TREE' without a `return'."))

;;; (DEFMETHOD (PERMANENTIFY OBJECT) ...)

(%%DEFCONSMETHOD PERMANENTIFY ((SELF OBJECT))
  (CL:RETURN-FROM PERMANENTIFY SELF))

;;; (DEFMETHOD (PERMANENTIFY SYMBOL) ...)

(CL:DEFMETHOD PERMANENTIFY ((SELF SYMBOL))
  (CL:RETURN-FROM PERMANENTIFY SELF))

;;; (DEFMETHOD (PERMANENTIFY SYMBOL) ...)

(CL:DEFMETHOD PERMANENTIFY ((SELF TRANSIENT-SYMBOL))
  (CL:RETURN-FROM PERMANENTIFY (INTERN-PERMANENT-SYMBOL (%SYMBOL-NAME SELF))))

;;; (DEFMETHOD (PERMANENTIFY LITERAL-WRAPPER) ...)

(CL:DEFMETHOD PERMANENTIFY ((SELF LITERAL-WRAPPER))
  (CL:RETURN-FROM PERMANENTIFY (COPY-WRAPPED-LITERAL SELF)))

;;; (DEFUN (PERMANENT-COPY OBJECT) ...)

(CL:DEFUN PERMANENT-COPY (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-LITERALS-STELLA-CONS)
    (CL:PROGN
     (CL:IF (CL:EQ TREE NIL) (CL:RETURN-FROM PERMANENT-COPY TREE)
      (CL:RETURN-FROM PERMANENT-COPY
       (CONS (PERMANENT-COPY (%%VALUE TREE))
        (PERMANENT-COPY (%%REST TREE)))))))
   (CL:T (CL:RETURN-FROM PERMANENT-COPY (PERMANENTIFY TREE))))
  (CL:ERROR "Returned from `|F|PERMANENT-COPY' without a `return'."))

;;; (DEFMETHOD (SOFT-PERMANENTIFY SYMBOL) ...)

(CL:DEFMETHOD SOFT-PERMANENTIFY ((SYMBOL SYMBOL))
  (CL:RETURN-FROM SOFT-PERMANENTIFY SYMBOL))

;;; (DEFMETHOD (SOFT-PERMANENTIFY SYMBOL) ...)

(CL:DEFMETHOD SOFT-PERMANENTIFY ((SYMBOL TRANSIENT-SYMBOL))
  (CL:LET*
   ((PERMANENTSYMBOL
     (LOOKUP-RIGID-SYMBOL-WRT-MODULE (%SYMBOL-NAME SYMBOL)
      (CL:IF (CL:NOT (CL:EQ (%HOME-CONTEXT SYMBOL) NULL))
       (%HOME-CONTEXT SYMBOL) *MODULE*)
      SYMBOL-SYM)))
   (CL:IF (CL:NOT (CL:EQ PERMANENTSYMBOL NULL))
    (CL:RETURN-FROM SOFT-PERMANENTIFY PERMANENTSYMBOL)
    (CL:RETURN-FROM SOFT-PERMANENTIFY SYMBOL)))
  (CL:ERROR
   "Returned from `|M|TRANSIENT-SYMBOL.SOFT-PERMANENTIFY' without a `return'."))

;;; (DEFUN PRINT-CHARACTER ...)

(CL:DEFUN PRINT-CHARACTER (CHAR STREAM)
  (%%PRINT-STREAM STREAM "#\\")
  (CL:CASE CHAR (#\Linefeed (%%PRINT-STREAM STREAM "Linefeed"))
   (#\Backspace (%%PRINT-STREAM STREAM "Backspace"))
   (#\Tab (%%PRINT-STREAM STREAM "Tab"))
   (#\Return (%%PRINT-STREAM STREAM "Return"))
   (#\Page (%%PRINT-STREAM STREAM "Page"))
   (CL:OTHERWISE (%%PRINT-STREAM STREAM CHAR)))
  :VOID)

;;; (DEFUN (CREATE-CHARACTER-TYPE-TABLE (VECTOR OF KEYWORD)) ...)

(CL:DEFUN CREATE-CHARACTER-TYPE-TABLE ()
  (CL:LET* ((TABLE (NEW-VECTOR 256)))
   (CL:LET* ((CODE NULL) (ITER-000 0) (UPPER-BOUND-000 255))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 CODE))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ CODE ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:LET
      ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-OTHER) (POSITION CODE))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:LET*
    ((CODE NULL) (ITER-001 (CL:THE CL:FIXNUM (CL:CHAR-CODE #\0)))
     (UPPER-BOUND-001 (CL:THE CL:FIXNUM (CL:CHAR-CODE #\9)))
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-001)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 UPPER-BOUND-001 CODE))
    (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-001)) DO
     (CL:PROGN (CL:SETQ CODE ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:LET
      ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-DIGIT) (POSITION CODE))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:LET*
    ((CODE NULL) (ITER-002 (CL:THE CL:FIXNUM (CL:CHAR-CODE #\A)))
     (UPPER-BOUND-002 (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Z)))
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-002)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-002 UPPER-BOUND-002 CODE))
    (CL:LOOP WHILE (CL:OR UNBOUNDED?-001 (CL:<= ITER-002 UPPER-BOUND-002)) DO
     (CL:PROGN (CL:SETQ CODE ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
     (CL:LET
      ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-LETTER) (POSITION CODE))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:LET*
    ((CODE NULL) (ITER-003 (CL:THE CL:FIXNUM (CL:CHAR-CODE #\a)))
     (UPPER-BOUND-003 (CL:THE CL:FIXNUM (CL:CHAR-CODE #\z)))
     (UNBOUNDED?-002 (NULL? UPPER-BOUND-003)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-003 UPPER-BOUND-003 CODE))
    (CL:LOOP WHILE (CL:OR UNBOUNDED?-002 (CL:<= ITER-003 UPPER-BOUND-003)) DO
     (CL:PROGN (CL:SETQ CODE ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
     (CL:LET
      ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-LETTER) (POSITION CODE))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\!))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\$))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\%))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\<))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\>))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\=))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\?))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\[))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\]))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\^))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\_))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\{))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\}))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\~))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\*))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\.))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\+))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-CONSTITUENT)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\-))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-QUALIFIER)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\:))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-QUALIFIER)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\/))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-SYMBOL-QUALIFIER)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\@))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-ESCAPE)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\\))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-DELIMITER)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\())))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-DELIMITER)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\)))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-DELIMITER)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\"))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-DELIMITER)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\|))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-DELIMITER)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\'))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-DELIMITER)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\`))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-DELIMITER)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\,))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-WHITE-SPACE)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\ ))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-WHITE-SPACE)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Tab))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-WHITE-SPACE)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Linefeed))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-WHITE-SPACE)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Return))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-WHITE-SPACE)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Linefeed))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY TABLE)) (VALUE KWD-LITERALS-WHITE-SPACE)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Page))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:RETURN-FROM CREATE-CHARACTER-TYPE-TABLE TABLE))
  (CL:ERROR
   "Returned from `|F|CREATE-CHARACTER-TYPE-TABLE' without a `return'."))

;;; (DEFGLOBAL *CHARACTER-TYPE-TABLE* ...)

(CL:DEFVAR *CHARACTER-TYPE-TABLE* NULL
  "Table of character types.  Entry 'i' represents the type
of the character whose 'char-code' equals 'i'.  Each character is classified 
by one of the following keywords: :DIGIT, :LETTER, :SYMBOL-CONSTITUENT, 
:SYMBOL-QUALIFIER, :ESCAPE, :DELIMITER, :WHITE-SPACE, or :OTHER.")

;;; (DEFUN (DIGIT-CHARACTER? BOOLEAN) ...)

(CL:DEFUN DIGIT-CHARACTER? (CH)
  "Return TRUE if `ch' represents a digit."
  (CL:RETURN-FROM DIGIT-CHARACTER?
   (EQ?
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY *CHARACTER-TYPE-TABLE*))
     (CL:THE CL:FIXNUM (CL:CHAR-CODE CH)))
    KWD-LITERALS-DIGIT)))

;;; (DEFUN (LETTER-CHARACTER? BOOLEAN) ...)

(CL:DEFUN LETTER-CHARACTER? (CH)
  "Return TRUE if `ch' represents a letter."
  (CL:RETURN-FROM LETTER-CHARACTER?
   (EQ?
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY *CHARACTER-TYPE-TABLE*))
     (CL:THE CL:FIXNUM (CL:CHAR-CODE CH)))
    KWD-LITERALS-LETTER)))

;;; (DEFUN (UPPER-CASE-CHARACTER? BOOLEAN) ...)

(CL:DEFUN UPPER-CASE-CHARACTER? (CH)
  "Return TRUE if `ch' represents an upper-case character."
  (CL:LET* ((CHARCODE (CL:THE CL:FIXNUM (CL:CHAR-CODE CH))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CHARCODE))
   (CL:RETURN-FROM UPPER-CASE-CHARACTER?
    (CL:AND (CL:>= CHARCODE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\A)))
     (CL:<= CHARCODE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Z))))))
  (CL:ERROR "Returned from `|F|UPPER-CASE-CHARACTER?' without a `return'."))

;;; (DEFUN (LOWER-CASE-CHARACTER? BOOLEAN) ...)

(CL:DEFUN LOWER-CASE-CHARACTER? (CH)
  "Return TRUE if `ch' represents a lower-case character."
  (CL:LET* ((CHARCODE (CL:THE CL:FIXNUM (CL:CHAR-CODE CH))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CHARCODE))
   (CL:RETURN-FROM LOWER-CASE-CHARACTER?
    (CL:AND (CL:>= CHARCODE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\a)))
     (CL:<= CHARCODE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\z))))))
  (CL:ERROR "Returned from `|F|LOWER-CASE-CHARACTER?' without a `return'."))

;;; (DEFUN (WHITE-SPACE-CHARACTER? BOOLEAN) ...)

(CL:DEFUN WHITE-SPACE-CHARACTER? (CH)
  "Return TRUE if `ch' is a white space character."
  (CL:RETURN-FROM WHITE-SPACE-CHARACTER?
   (EQ?
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY *CHARACTER-TYPE-TABLE*))
     (CL:THE CL:FIXNUM (CL:CHAR-CODE CH)))
    KWD-LITERALS-WHITE-SPACE)))

;;; (DEFGLOBAL *CHARACTER-UPCASE-TABLE* ...)

(CL:PROGN (CL:DEFVAR *CHARACTER-UPCASE-TABLE* NULL) (CL:DECLAIM
                                                     (CL:TYPE
                                                      CL:SIMPLE-STRING
                                                      *CHARACTER-UPCASE-TABLE*)))

;;; (DEFUN (INITIALIZE-CHARACTER-UPCASE-TABLE STRING) ...)

(CL:DEFUN INITIALIZE-CHARACTER-UPCASE-TABLE ()
  (CL:LET*
   ((BUFFER
     (CL:LET ((SIZE 256) (INITCHAR NULL-CHARACTER))
      (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
      (CL:THE CL:SIMPLE-STRING
       (CL:make-string size :initial-element initchar)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING BUFFER))
   (CL:LET* ((I NULL) (ITER-000 0) (UPPER-BOUND-000 255))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:LET ((SELF BUFFER) (CH (CL:CODE-CHAR I)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (SETF
       (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))
       (CL:THE CL:CHARACTER CH)))
     (CL:WHEN
      (CL:AND (CL:>= I (CL:THE CL:FIXNUM (CL:CHAR-CODE #\a)))
       (CL:<= I (CL:THE CL:FIXNUM (CL:CHAR-CODE #\z))))
      (CL:LET
       ((SELF BUFFER)
        (CH
         (CL:CODE-CHAR
          (CL:THE CL:FIXNUM
           (CL:+ (CL:THE CL:FIXNUM (CL:CHAR-CODE #\A))
            (CL:- I (CL:THE CL:FIXNUM (CL:CHAR-CODE #\a)))))))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (SETF
        (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))
        (CL:THE CL:CHARACTER CH))))))
   (CL:RETURN-FROM INITIALIZE-CHARACTER-UPCASE-TABLE
    (CL:LET ((S BUFFER)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
     (CL:THE CL:SIMPLE-STRING S))))
  (CL:ERROR
   "Returned from `|F|INITIALIZE-CHARACTER-UPCASE-TABLE' without a `return'."))

;;; (DEFGLOBAL *CHARACTER-DOWNCASE-TABLE* ...)

(CL:PROGN (CL:DEFVAR *CHARACTER-DOWNCASE-TABLE* NULL) (CL:DECLAIM
                                                       (CL:TYPE
                                                        CL:SIMPLE-STRING
                                                        *CHARACTER-DOWNCASE-TABLE*)))

;;; (DEFUN (INITIALIZE-CHARACTER-DOWNCASE-TABLE STRING) ...)

(CL:DEFUN INITIALIZE-CHARACTER-DOWNCASE-TABLE ()
  (CL:LET*
   ((BUFFER
     (CL:LET ((SIZE 256) (INITCHAR NULL-CHARACTER))
      (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
      (CL:THE CL:SIMPLE-STRING
       (CL:make-string size :initial-element initchar)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING BUFFER))
   (CL:LET* ((I NULL) (ITER-000 0) (UPPER-BOUND-000 255))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:LET ((SELF BUFFER) (CH (CL:CODE-CHAR I)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (SETF
       (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))
       (CL:THE CL:CHARACTER CH)))
     (CL:WHEN
      (CL:AND (CL:>= I (CL:THE CL:FIXNUM (CL:CHAR-CODE #\A)))
       (CL:<= I (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Z))))
      (CL:LET
       ((SELF BUFFER)
        (CH
         (CL:CODE-CHAR
          (CL:THE CL:FIXNUM
           (CL:+ (CL:THE CL:FIXNUM (CL:CHAR-CODE #\a))
            (CL:- I (CL:THE CL:FIXNUM (CL:CHAR-CODE #\A)))))))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (SETF
        (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))
        (CL:THE CL:CHARACTER CH))))))
   (CL:RETURN-FROM INITIALIZE-CHARACTER-DOWNCASE-TABLE
    (CL:LET ((S BUFFER)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
     (CL:THE CL:SIMPLE-STRING S))))
  (CL:ERROR
   "Returned from `|F|INITIALIZE-CHARACTER-DOWNCASE-TABLE' without a `return'."))

;;; (DEFUN (UPCASE-CHARACTER CHARACTER) ...)

(CL:DEFUN UPCASE-CHARACTER (CHAR)
  "If `char' is lowercase, return its uppercase version,
otherwise, return 'char' unmodified."
  (CL:RETURN-FROM UPCASE-CHARACTER
   (CL:LET
    ((SELF *CHARACTER-UPCASE-TABLE*)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE CHAR))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)))))

;;; (DEFUN (DOWNCASE-CHARACTER CHARACTER) ...)

(CL:DEFUN DOWNCASE-CHARACTER (CHAR)
  "If `char' is uppercase, return its lowercase version,
otherwise, return 'char' unmodified."
  (CL:RETURN-FROM DOWNCASE-CHARACTER
   (CL:LET
    ((SELF *CHARACTER-DOWNCASE-TABLE*)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE CHAR))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)))))

;;; (DEFUN PRINT-STRING-READABLY ...)

(CL:DEFUN PRINT-STRING-READABLY (STRING STREAM)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  (CL:PROGN (CL:PRIN1 STRING STREAM) (CL:RETURN-FROM PRINT-STRING-READABLY))
  (%%PRINT-STREAM STREAM "\"")
  (CL:LET*
   ((I NULL) (ITER-000 0)
    (UPPER-BOUND-000 (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH STRING)))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
   (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
    (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
    (CL:LET*
     ((CHAR
       (CL:LET ((SELF STRING) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION)))))
     (CL:IF (CL:OR (CL:EQL CHAR #\") (CL:EQL CHAR #\\))
      (%%PRINT-STREAM STREAM "\\" CHAR) (%%PRINT-STREAM STREAM CHAR)))))
  (%%PRINT-STREAM STREAM "\"")
  :VOID)

;;; (DEFUN (STRING-TO-MUTABLE-STRING MUTABLE-STRING) ...)

(CL:DEFUN STRING-TO-MUTABLE-STRING (S)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
  (CL:RETURN-FROM STRING-TO-MUTABLE-STRING (CL:COPY-SEQ S)))

;;; (DEFUN (MUTABLE-STRING-TO-STRING STRING) ...)

(CL:DEFUN MUTABLE-STRING-TO-STRING (S)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
  (CL:RETURN-FROM MUTABLE-STRING-TO-STRING S))

;;; (DEFUN (CHARACTER-TO-STRING STRING) ...)

(CL:DEFUN CHARACTER-TO-STRING (C)
  (CL:RETURN-FROM CHARACTER-TO-STRING (MAKE-STRING 1 C)))

;;; (DEFMETHOD (NUMBER-WRAPPER-TO-FLOAT FLOAT) ...)

(CL:DEFMETHOD NUMBER-WRAPPER-TO-FLOAT ((SELF NUMBER-WRAPPER))
  (CL:RETURN-FROM NUMBER-WRAPPER-TO-FLOAT NULL-FLOAT))

;;; (DEFMETHOD (NUMBER-WRAPPER-TO-FLOAT FLOAT) ...)

(CL:DEFMETHOD NUMBER-WRAPPER-TO-FLOAT ((SELF INTEGER-WRAPPER))
  (CL:RETURN-FROM NUMBER-WRAPPER-TO-FLOAT (CL:* (%WRAPPER-VALUE SELF) 1.0)))

;;; (DEFMETHOD (NUMBER-WRAPPER-TO-FLOAT FLOAT) ...)

(CL:DEFMETHOD NUMBER-WRAPPER-TO-FLOAT ((SELF FLOAT-WRAPPER))
  (CL:RETURN-FROM NUMBER-WRAPPER-TO-FLOAT (%WRAPPER-VALUE SELF)))

(CL:DEFUN HELP-STARTUP-LITERALS1 ()
  (CL:PROGN
   (CL:SETQ SGT-LITERALS-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
   (CL:SETQ KWD-LITERALS-NULL-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-WRAPPER" NULL 2))
   (CL:SETQ SYM-LITERALS-STELLA-FALSE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE-WRAPPER" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-INTEGER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-INTEGER-WRAPPER" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-FLOAT-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-FLOAT-WRAPPER" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-STRING-WRAPPER" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-MUTABLE-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTABLE-STRING" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-MUTABLE-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-MUTABLE-STRING-WRAPPER" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-CHARACTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-CHARACTER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-CHARACTER-WRAPPER" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-FUNCTION-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-FUNCTION-CODE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-FUNCTION-CODE-WRAPPER" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-METHOD-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-METHOD-CODE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-METHOD-CODE-WRAPPER" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-TRUE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE-WRAPPER" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-BOOLEAN" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-INLINE-WRAP-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE-WRAP-BOOLEAN" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-INLINE-WRAP-BOOLEAN-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE-WRAP-BOOLEAN-EXPANDER" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN" NULL
     0))
   (CL:SETQ SYM-LITERALS-STELLA-INLINE-UNWRAP-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE-UNWRAP-BOOLEAN" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-INLINE-UNWRAP-BOOLEAN-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE-UNWRAP-BOOLEAN-EXPANDER" NULL 0))
   (CL:SETQ KWD-LITERALS-WRAP-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-FUNCTION" NULL 2))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-INTEGER" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-FLOAT" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-STRING" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-CHARACTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-CHARACTER" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-FUNCTION-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-FUNCTION-CODE" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-METHOD-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-METHOD-CODE" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-NIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NIL" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-LITERAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-LITERAL" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-GET-KWD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-KWD" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-TYPED-SYS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPED-SYS" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-GET-SGT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-SGT" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-INTERN-COMMON-LISP-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERN-COMMON-LISP-SYMBOL" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-GET-SYM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-SYM" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-LIST*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST*" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-& (INTERN-RIGID-SYMBOL-WRT-MODULE "&" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-&&
    (INTERN-RIGID-SYMBOL-WRT-MODULE "&&" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-CONCATENATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCATENATE" NULL 0))
   (CL:SETQ KWD-LITERALS-OTHER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHER" NULL 2))
   (CL:SETQ KWD-LITERALS-DIGIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIGIT" NULL 2))
   (CL:SETQ KWD-LITERALS-LETTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LETTER" NULL 2))
   (CL:SETQ KWD-LITERALS-SYMBOL-CONSTITUENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-CONSTITUENT" NULL 2))
   (CL:SETQ KWD-LITERALS-SYMBOL-QUALIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-QUALIFIER" NULL 2))
   (CL:SETQ KWD-LITERALS-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPE" NULL 2))
   (CL:SETQ KWD-LITERALS-DELIMITER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DELIMITER" NULL 2))
   (CL:SETQ KWD-LITERALS-WHITE-SPACE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHITE-SPACE" NULL 2)))
  :VOID)

(CL:DEFUN HELP-STARTUP-LITERALS2 ()
  (CL:PROGN (CL:SETQ ZERO-WRAPPER (NEW-INTEGER-WRAPPER 0))
   (CL:SETQ ONE-WRAPPER (NEW-INTEGER-WRAPPER 1))
   (CL:SETQ FALSE-WRAPPER (NEW-BOOLEAN-WRAPPER FALSE))
   (CL:SETQ TRUE-WRAPPER (NEW-BOOLEAN-WRAPPER TRUE))
   (CL:SETQ NULL-INTEGER-WRAPPER (NEW-INTEGER-WRAPPER NULL-INTEGER))
   (CL:SETQ NULL-FLOAT-WRAPPER (NEW-FLOAT-WRAPPER NULL-FLOAT))
   (CL:SETQ NULL-STRING-WRAPPER (NEW-STRING-WRAPPER NULL))
   (CL:SETQ NULL-MUTABLE-STRING-WRAPPER (NEW-MUTABLE-STRING-WRAPPER NULL))
   (CL:SETQ NULL-CHARACTER-WRAPPER (NEW-CHARACTER-WRAPPER NULL-CHARACTER))
   (CL:SETQ NULL-FUNCTION-CODE-WRAPPER (NEW-FUNCTION-CODE-WRAPPER NULL))
   (CL:SETQ NULL-METHOD-CODE-WRAPPER (NEW-METHOD-CODE-WRAPPER NULL))
   (CL:SETQ *LITERAL-TYPE-INFO-TABLE* (NEW-HASH-TABLE))
   (CL:SETQ *LITERAL-TYPES* (NEW-LIST))
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-BOOLEAN
    KWD-LITERALS-NULL-WRAPPER SYM-LITERALS-STELLA-FALSE-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-INTEGER
    KWD-LITERALS-NULL-WRAPPER SYM-LITERALS-STELLA-NULL-INTEGER-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-FLOAT KWD-LITERALS-NULL-WRAPPER
    SYM-LITERALS-STELLA-NULL-FLOAT-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-STRING KWD-LITERALS-NULL-WRAPPER
    SYM-LITERALS-STELLA-NULL-STRING-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-MUTABLE-STRING
    KWD-LITERALS-NULL-WRAPPER SYM-LITERALS-STELLA-NULL-MUTABLE-STRING-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-CHARACTER
    KWD-LITERALS-NULL-WRAPPER SYM-LITERALS-STELLA-NULL-CHARACTER-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-FUNCTION-CODE
    KWD-LITERALS-NULL-WRAPPER SYM-LITERALS-STELLA-NULL-FUNCTION-CODE-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-METHOD-CODE
    KWD-LITERALS-NULL-WRAPPER SYM-LITERALS-STELLA-NULL-METHOD-CODE-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-BOOLEAN
    KWD-LITERALS-WRAP-FUNCTION SYM-LITERALS-STELLA-WRAP-BOOLEAN)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-INTEGER
    KWD-LITERALS-WRAP-FUNCTION SYM-LITERALS-STELLA-WRAP-INTEGER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-FLOAT KWD-LITERALS-WRAP-FUNCTION
    SYM-LITERALS-STELLA-WRAP-FLOAT)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-STRING
    KWD-LITERALS-WRAP-FUNCTION SYM-LITERALS-STELLA-WRAP-STRING)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-CHARACTER
    KWD-LITERALS-WRAP-FUNCTION SYM-LITERALS-STELLA-WRAP-CHARACTER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-FUNCTION-CODE
    KWD-LITERALS-WRAP-FUNCTION SYM-LITERALS-STELLA-WRAP-FUNCTION-CODE)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-METHOD-CODE
    KWD-LITERALS-WRAP-FUNCTION SYM-LITERALS-STELLA-WRAP-METHOD-CODE)
   (CL:SETQ *CHARACTER-TYPE-TABLE* (CREATE-CHARACTER-TYPE-TABLE))
   (CL:SETQ *CHARACTER-UPCASE-TABLE* (INITIALIZE-CHARACTER-UPCASE-TABLE))
   (CL:SETQ *CHARACTER-DOWNCASE-TABLE* (INITIALIZE-CHARACTER-DOWNCASE-TABLE)))
  :VOID)

(CL:DEFUN HELP-STARTUP-LITERALS3 ()
  (CL:PROGN
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (TERMINATE-WRAPPER? BOOLEAN) ((SELF WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION TERMINATE-WRAPPER?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (TERMINATE-WRAPPER? BOOLEAN) ((SELF INTEGER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION TERMINATE-WRAPPER?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-LITERAL-TYPE-INFO"
    "(DEFUN (LOOKUP-LITERAL-TYPE-INFO OBJECT) ((TYPE TYPE) (KEY KEYWORD)))"
    (CL:FUNCTION LOOKUP-LITERAL-TYPE-INFO) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-LITERAL-TYPE-INFO"
    "(DEFUN SET-LITERAL-TYPE-INFO ((TYPE TYPE) (KEY KEYWORD) (VALUE OBJECT)))"
    (CL:FUNCTION SET-LITERAL-TYPE-INFO) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-INTEGER"
    "(DEFUN (WRAP-INTEGER INTEGER-WRAPPER) ((VALUE INTEGER)) :PUBLIC? TRUE)"
    (CL:FUNCTION WRAP-INTEGER) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-FLOAT"
    "(DEFUN (WRAP-FLOAT FLOAT-WRAPPER) ((VALUE FLOAT)) :PUBLIC? TRUE)"
    (CL:FUNCTION WRAP-FLOAT) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-STRING"
    "(DEFUN (WRAP-STRING STRING-WRAPPER) ((VALUE STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION WRAP-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-MUTABLE-STRING"
    "(DEFUN (WRAP-MUTABLE-STRING MUTABLE-STRING-WRAPPER) ((VALUE MUTABLE-STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION WRAP-MUTABLE-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-CHARACTER"
    "(DEFUN (WRAP-CHARACTER CHARACTER-WRAPPER) ((VALUE CHARACTER)) :PUBLIC? TRUE)"
    (CL:FUNCTION WRAP-CHARACTER) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-FUNCTION-CODE"
    "(DEFUN (WRAP-FUNCTION-CODE FUNCTION-CODE-WRAPPER) ((VALUE FUNCTION-CODE)) :PUBLIC? TRUE)"
    (CL:FUNCTION WRAP-FUNCTION-CODE) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-METHOD-CODE"
    "(DEFUN (WRAP-METHOD-CODE METHOD-CODE-WRAPPER) ((VALUE METHOD-CODE)) :PUBLIC? TRUE)"
    (CL:FUNCTION WRAP-METHOD-CODE) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-BOOLEAN"
    "(DEFUN (WRAP-BOOLEAN BOOLEAN-WRAPPER) ((VALUE BOOLEAN)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (CHOOSE VALUE TRUE-WRAPPER FALSE-WRAPPER)))"
    (CL:FUNCTION WRAP-BOOLEAN) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWRAP-BOOLEAN"
    "(DEFUN (UNWRAP-BOOLEAN BOOLEAN) ((WRAPPER BOOLEAN-WRAPPER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQ? WRAPPER TRUE-WRAPPER)))"
    (CL:FUNCTION UNWRAP-BOOLEAN) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN"
    "(DEFUN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN BOOLEAN) ((WRAPPER BOOLEAN-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN) NULL)
   (DEFINE-FUNCTION-OBJECT "INLINE-WRAP-BOOLEAN-EXPANDER"
    "(DEFUN (INLINE-WRAP-BOOLEAN-EXPANDER OBJECT) ((EXPRESSION OBJECT)))"
    (CL:FUNCTION INLINE-WRAP-BOOLEAN-EXPANDER) NULL)
   (DEFINE-FUNCTION-OBJECT "INLINE-UNWRAP-BOOLEAN-EXPANDER"
    "(DEFUN (INLINE-UNWRAP-BOOLEAN-EXPANDER OBJECT) ((EXPRESSION OBJECT)))"
    (CL:FUNCTION INLINE-UNWRAP-BOOLEAN-EXPANDER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL INTEGER-WRAPPER) ((VALUE INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-INTEGER VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL FLOAT-WRAPPER) ((VALUE FLOAT)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-FLOAT VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL MUTABLE-STRING-WRAPPER) ((VALUE MUTABLE-STRING)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-MUTABLE-STRING VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL STRING-WRAPPER) ((VALUE STRING)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-STRING VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL CHARACTER-WRAPPER) ((VALUE CHARACTER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-CHARACTER VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL FUNCTION-CODE-WRAPPER) ((VALUE FUNCTION-CODE)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-FUNCTION-CODE VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL METHOD-CODE-WRAPPER) ((VALUE METHOD-CODE)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-METHOD-CODE VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF STANDARD-OBJECT)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF LITERAL-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF INTEGER-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF FLOAT-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF STRING-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF MUTABLE-STRING-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF CHARACTER-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF FUNCTION-CODE-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF METHOD-CODE-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X OBJECT) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X STANDARD-OBJECT) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X INTEGER-WRAPPER) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X FLOAT-WRAPPER) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X BOOLEAN-WRAPPER) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X STRING-WRAPPER) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X MUTABLE-STRING-WRAPPER) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X CHARACTER-WRAPPER) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQL?"
    "(DEFUN (EQL? BOOLEAN) ((X OBJECT) (Y OBJECT)) :DOCUMENTATION \"'eql?' translates into the C++ '==' except that 
   (1) it tests for string equivalence when its first argument is a string,
   and (2) it understands wrapped literals.\" :PUBLIC? TRUE)"
    (CL:FUNCTION EQL?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQL-TO-BOOLEAN?"
    "(DEFUN (EQL-TO-BOOLEAN? BOOLEAN) ((Y OBJECT) (X BOOLEAN)))"
    (CL:FUNCTION EQL-TO-BOOLEAN?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQL-TO-INTEGER?"
    "(DEFUN (EQL-TO-INTEGER? BOOLEAN) ((Y OBJECT) (X INTEGER)))"
    (CL:FUNCTION EQL-TO-INTEGER?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQL-TO-FLOAT?"
    "(DEFUN (EQL-TO-FLOAT? BOOLEAN) ((Y OBJECT) (X FLOAT)))"
    (CL:FUNCTION EQL-TO-FLOAT?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQL-TO-STRING?"
    "(DEFUN (EQL-TO-STRING? BOOLEAN) ((Y OBJECT) (X STRING)))"
    (CL:FUNCTION EQL-TO-STRING?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQL-TO-CHARACTER?"
    "(DEFUN (EQL-TO-CHARACTER? BOOLEAN) ((Y OBJECT) (X CHARACTER)))"
    (CL:FUNCTION EQL-TO-CHARACTER?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-BQUOTIFY"
    "(DEFUN (HELP-BQUOTIFY OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION HELP-BQUOTIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "BQUOTIFY"
    "(DEFUN (BQUOTIFY OBJECT) ((TREE OBJECT)))" (CL:FUNCTION BQUOTIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPAND-BQUOTE-TREE"
    "(DEFUN (EXPAND-BQUOTE-TREE OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION EXPAND-BQUOTE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "SIMPLIFY-BQUOTE-TREE"
    "(DEFUN (SIMPLIFY-BQUOTE-TREE OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION SIMPLIFY-BQUOTE-TREE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PERMANENTIFY OBJECT) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION PERMANENTIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PERMANENTIFY SYMBOL) ((SELF SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION PERMANENTIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PERMANENTIFY SYMBOL) ((SELF TRANSIENT-SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION PERMANENTIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PERMANENTIFY LITERAL-WRAPPER) ((SELF LITERAL-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION PERMANENTIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "PERMANENT-COPY"
    "(DEFUN (PERMANENT-COPY OBJECT) ((TREE OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION PERMANENT-COPY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SOFT-PERMANENTIFY SYMBOL) ((SYMBOL SYMBOL)))"
    (CL:FUNCTION SOFT-PERMANENTIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SOFT-PERMANENTIFY SYMBOL) ((SYMBOL TRANSIENT-SYMBOL)))"
    (CL:FUNCTION SOFT-PERMANENTIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-CHARACTER"
    "(DEFUN PRINT-CHARACTER ((CHAR CHARACTER) (STREAM NATIVE-OUTPUT-STREAM)) :PUBLIC? TRUE)"
    (CL:FUNCTION PRINT-CHARACTER) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-CHARACTER-TYPE-TABLE"
    "(DEFUN (CREATE-CHARACTER-TYPE-TABLE (VECTOR OF KEYWORD)) ())"
    (CL:FUNCTION CREATE-CHARACTER-TYPE-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "DIGIT-CHARACTER?"
    "(DEFUN (DIGIT-CHARACTER? BOOLEAN) ((CH CHARACTER)) :DOCUMENTATION \"Return TRUE if `ch' represents a digit.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQL? (NTH *CHARACTER-TYPE-TABLE* (CHARACTER-CODE CH)) :DIGIT)))"
    (CL:FUNCTION DIGIT-CHARACTER?) NULL))
  :VOID)

(CL:DEFUN STARTUP-LITERALS ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-LITERALS1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4) (HELP-STARTUP-LITERALS2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-LITERALS3)
    (DEFINE-FUNCTION-OBJECT "LETTER-CHARACTER?"
     "(DEFUN (LETTER-CHARACTER? BOOLEAN) ((CH CHARACTER)) :DOCUMENTATION \"Return TRUE if `ch' represents a letter.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQL? (NTH *CHARACTER-TYPE-TABLE* (CHARACTER-CODE CH)) :LETTER)))"
     (CL:FUNCTION LETTER-CHARACTER?) NULL)
    (DEFINE-FUNCTION-OBJECT "UPPER-CASE-CHARACTER?"
     "(DEFUN (UPPER-CASE-CHARACTER? BOOLEAN) ((CH CHARACTER)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if `ch' represents an upper-case character.\")"
     (CL:FUNCTION UPPER-CASE-CHARACTER?) NULL)
    (DEFINE-FUNCTION-OBJECT "LOWER-CASE-CHARACTER?"
     "(DEFUN (LOWER-CASE-CHARACTER? BOOLEAN) ((CH CHARACTER)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if `ch' represents a lower-case character.\")"
     (CL:FUNCTION LOWER-CASE-CHARACTER?) NULL)
    (DEFINE-FUNCTION-OBJECT "WHITE-SPACE-CHARACTER?"
     "(DEFUN (WHITE-SPACE-CHARACTER? BOOLEAN) ((CH CHARACTER)) :DOCUMENTATION \"Return TRUE if `ch' is a white space character.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQL? (NTH *CHARACTER-TYPE-TABLE* (CHARACTER-CODE CH)) :WHITE-SPACE)))"
     (CL:FUNCTION WHITE-SPACE-CHARACTER?) NULL)
    (DEFINE-FUNCTION-OBJECT "INITIALIZE-CHARACTER-UPCASE-TABLE"
     "(DEFUN (INITIALIZE-CHARACTER-UPCASE-TABLE STRING) ())"
     (CL:FUNCTION INITIALIZE-CHARACTER-UPCASE-TABLE) NULL)
    (DEFINE-FUNCTION-OBJECT "INITIALIZE-CHARACTER-DOWNCASE-TABLE"
     "(DEFUN (INITIALIZE-CHARACTER-DOWNCASE-TABLE STRING) ())"
     (CL:FUNCTION INITIALIZE-CHARACTER-DOWNCASE-TABLE) NULL)
    (DEFINE-FUNCTION-OBJECT "UPCASE-CHARACTER"
     "(DEFUN (UPCASE-CHARACTER CHARACTER) ((CHAR CHARACTER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"If `char' is lowercase, return its uppercase version,
otherwise, return 'char' unmodified.\" (RETURN (NTH *CHARACTER-UPCASE-TABLE* (CHARACTER-CODE CHAR))))"
     (CL:FUNCTION UPCASE-CHARACTER) NULL)
    (DEFINE-FUNCTION-OBJECT "DOWNCASE-CHARACTER"
     "(DEFUN (DOWNCASE-CHARACTER CHARACTER) ((CHAR CHARACTER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"If `char' is uppercase, return its lowercase version,
otherwise, return 'char' unmodified.\" (RETURN (NTH *CHARACTER-DOWNCASE-TABLE* (CHARACTER-CODE CHAR))))"
     (CL:FUNCTION DOWNCASE-CHARACTER) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-STRING-READABLY"
     "(DEFUN PRINT-STRING-READABLY ((STRING STRING) (STREAM NATIVE-OUTPUT-STREAM)))"
     (CL:FUNCTION PRINT-STRING-READABLY) NULL)
    (DEFINE-FUNCTION-OBJECT "STRING-TO-MUTABLE-STRING"
     "(DEFUN (STRING-TO-MUTABLE-STRING MUTABLE-STRING) ((S STRING)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:COPY-SEQ S) :CPP \"strcpy(new (GC) char[strlen(s)+1], s)\" :JAVA \"new StringBuffer(s)\")))"
     (CL:FUNCTION STRING-TO-MUTABLE-STRING) NULL)
    (DEFINE-FUNCTION-OBJECT "MUTABLE-STRING-TO-STRING"
     "(DEFUN (MUTABLE-STRING-TO-STRING STRING) ((S MUTABLE-STRING)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP S :CPP \"s\" :JAVA \"s.toString()\")))"
     (CL:FUNCTION MUTABLE-STRING-TO-STRING) NULL)
    (DEFINE-FUNCTION-OBJECT "CHARACTER-TO-STRING"
     "(DEFUN (CHARACTER-TO-STRING STRING) ((C CHARACTER)) :PUBLIC? TRUE)"
     (CL:FUNCTION CHARACTER-TO-STRING) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NUMBER-WRAPPER-TO-FLOAT FLOAT) ((SELF NUMBER-WRAPPER)) :PUBLIC? TRUE)"
     (CL:FUNCTION NUMBER-WRAPPER-TO-FLOAT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NUMBER-WRAPPER-TO-FLOAT FLOAT) ((SELF INTEGER-WRAPPER)) :PUBLIC? TRUE)"
     (CL:FUNCTION NUMBER-WRAPPER-TO-FLOAT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NUMBER-WRAPPER-TO-FLOAT FLOAT) ((SELF FLOAT-WRAPPER)) :PUBLIC? TRUE)"
     (CL:FUNCTION NUMBER-WRAPPER-TO-FLOAT) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-LITERALS"
     "(DEFUN STARTUP-LITERALS () :PUBLIC? TRUE)" NULL NULL))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL ZERO-WRAPPER INTEGER-WRAPPER (NEW INTEGER-WRAPPER :WRAPPER-VALUE 0) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL ONE-WRAPPER INTEGER-WRAPPER (NEW INTEGER-WRAPPER :WRAPPER-VALUE 1) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL FALSE-WRAPPER BOOLEAN-WRAPPER (NEW BOOLEAN-WRAPPER :WRAPPER-VALUE FALSE) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL TRUE-WRAPPER BOOLEAN-WRAPPER (NEW BOOLEAN-WRAPPER :WRAPPER-VALUE TRUE) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-INTEGER-WRAPPER INTEGER-WRAPPER (NEW INTEGER-WRAPPER :WRAPPER-VALUE NULL) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-FLOAT-WRAPPER FLOAT-WRAPPER (NEW FLOAT-WRAPPER :WRAPPER-VALUE NULL) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-STRING-WRAPPER STRING-WRAPPER (NEW STRING-WRAPPER :WRAPPER-VALUE NULL) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-MUTABLE-STRING-WRAPPER MUTABLE-STRING-WRAPPER (NEW MUTABLE-STRING-WRAPPER :WRAPPER-VALUE NULL) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-CHARACTER-WRAPPER CHARACTER-WRAPPER (NEW CHARACTER-WRAPPER :WRAPPER-VALUE NULL) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-FUNCTION-CODE-WRAPPER FUNCTION-CODE-WRAPPER (NEW FUNCTION-CODE-WRAPPER :WRAPPER-VALUE NULL) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-METHOD-CODE-WRAPPER METHOD-CODE-WRAPPER (NEW METHOD-CODE-WRAPPER :WRAPPER-VALUE NULL) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LITERAL-TYPE-INFO-TABLE* (HASH-TABLE OF TYPE (KEY-VALUE-LIST OF KEYWORD OBJECT)) (NEW HASH-TABLE) :DOCUMENTATION \"Table that holds a variety of information about literal
types, e.g., the name of their null-wrapper, wrap-function, etc.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LITERAL-TYPES* (LIST OF TYPE) (NEW LIST) :DOCUMENTATION \"List of literal types stored in '*literal-type-info-table*'.
Maintained for iteration purposes.\")")
    (STORE-MACRO SYM-LITERALS-STELLA-INLINE-WRAP-BOOLEAN
     SYM-LITERALS-STELLA-INLINE-WRAP-BOOLEAN-EXPANDER
     (CL:FUNCTION INLINE-WRAP-BOOLEAN-EXPANDER))
    (STORE-MACRO SYM-LITERALS-STELLA-INLINE-UNWRAP-BOOLEAN
     SYM-LITERALS-STELLA-INLINE-UNWRAP-BOOLEAN-EXPANDER
     (CL:FUNCTION INLINE-UNWRAP-BOOLEAN-EXPANDER))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CHARACTER-TYPE-TABLE* (VECTOR OF KEYWORD) (CREATE-CHARACTER-TYPE-TABLE) :DOCUMENTATION \"Table of character types.  Entry 'i' represents the type
of the character whose 'char-code' equals 'i'.  Each character is classified 
by one of the following keywords: :DIGIT, :LETTER, :SYMBOL-CONSTITUENT, 
:SYMBOL-QUALIFIER, :ESCAPE, :DELIMITER, :WHITE-SPACE, or :OTHER.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CHARACTER-UPCASE-TABLE* STRING (INITIALIZE-CHARACTER-UPCASE-TABLE))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CHARACTER-DOWNCASE-TABLE* STRING (INITIALIZE-CHARACTER-DOWNCASE-TABLE))")))
  :VOID)
