;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-PRIMAL-PUBLIC? NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-FLOOR NULL)
(CL:DEFVAR KWD-PRIMAL-CPP NULL)
(CL:DEFVAR KWD-PRIMAL-FUNCTION NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-RANDOM NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-SQRT NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-COS NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-SIN NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-TAN NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-LOG NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-MIN NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-MAX NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-*TRANSIENTOBJECTS?* NULL)

;;; Forward declarations:

(CL:DECLAIM (CL:SPECIAL *STELLA-MODULE* *MODULE*))

;;; (DEFCONSTANT TRUE ...)

(CL:DEFVAR TRUE CL:T)

;;; (DEFCONSTANT FALSE ...)

(CL:DEFVAR FALSE CL:NIL)

;;; (DEFCONSTANT NULL-INTEGER ...)

(CL:PROGN (CL:DEFVAR NULL-INTEGER CL:MOST-NEGATIVE-FIXNUM) (CL:DECLAIM
                                                            (CL:TYPE
                                                             CL:FIXNUM
                                                             NULL-INTEGER)))

;;; (DEFCONSTANT NULL-SHORT-INTEGER ...)

(CL:PROGN (CL:DEFVAR NULL-SHORT-INTEGER CL:MOST-NEGATIVE-FIXNUM) (CL:DECLAIM
                                                                  (CL:TYPE
                                                                   CL:FIXNUM
                                                                   NULL-SHORT-INTEGER)))

;;; (DEFCONSTANT NULL-LONG-INTEGER ...)

(CL:DEFVAR NULL-LONG-INTEGER CL:MOST-NEGATIVE-FIXNUM)

;;; (DEFCONSTANT NULL-UNSIGNED-SHORT-INTEGER ...)

(CL:DEFVAR NULL-UNSIGNED-SHORT-INTEGER CL:MOST-NEGATIVE-FIXNUM)

;;; (DEFCONSTANT NULL-UNSIGNED-LONG-INTEGER ...)

(CL:DEFVAR NULL-UNSIGNED-LONG-INTEGER CL:MOST-NEGATIVE-FIXNUM)

;;; (DEFCONSTANT NULL-FLOAT ...)

(CL:DEFVAR NULL-FLOAT CL:MOST-NEGATIVE-DOUBLE-FLOAT)

;;; (DEFCONSTANT NULL-SINGLE-FLOAT ...)

(CL:DEFVAR NULL-SINGLE-FLOAT CL:MOST-NEGATIVE-SINGLE-FLOAT)

;;; (DEFCONSTANT NULL-DOUBLE-FLOAT ...)

(CL:DEFVAR NULL-DOUBLE-FLOAT CL:MOST-NEGATIVE-DOUBLE-FLOAT)

;;; (DEFCONSTANT NULL-CHARACTER ...)

(CL:DEFVAR NULL-CHARACTER (CL:CODE-CHAR 0))

;;; (DEFCONSTANT NULL-BYTE ...)

(CL:DEFVAR NULL-BYTE 255)

;;; (DEFCONSTANT NULL-OCTET ...)

(CL:DEFVAR NULL-OCTET 255)

;;; (DEFUN (RANDOM INTEGER) ...)

(CL:DEFUN RANDOM (N)
  "Generate a random integer in the interval [0..n-1].
'n' must be <= 2^15."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  (CL:WHEN (CL:> N 32768)
   (CL:ERROR
    "random: Can only generate random numbers between 0 and (2^15)-1."))
  (CL:LET* ((RNUM (CL:RANDOM N))) (CL:DECLARE (CL:TYPE CL:FIXNUM RNUM))
   (CL:RETURN-FROM RANDOM RNUM))
  (CL:ERROR "Returned from `|F|RANDOM' without a `return'."))

;;; (DEFUN SEED-RANDOM-NUMBER-GENERATOR ...)

(CL:DEFUN SEED-RANDOM-NUMBER-GENERATOR ()
  "Seeds the random number generator with the current time"
  NULL
  :VOID)

;;; (DEFUN (SQRT FLOAT) ...)

(CL:DEFUN SQRT (N)
  "Return the square root of `n'."
  (CL:RETURN-FROM SQRT (CL:SQRT N)))

;;; (DEFUN (COS FLOAT) ...)

(CL:DEFUN COS (N)
  "Return the cosine of `n'."
  (CL:RETURN-FROM COS (CL:COS N)))

;;; (DEFUN (SIN FLOAT) ...)

(CL:DEFUN SIN (N)
  "Return the sine of `n'."
  (CL:RETURN-FROM SIN (CL:SIN N)))

;;; (DEFUN (TAN FLOAT) ...)

(CL:DEFUN TAN (N)
  "Return the tangent of `n'."
  (CL:RETURN-FROM TAN (CL:TAN N)))

;;; (DEFUN (LOG FLOAT) ...)

(CL:DEFUN LOG (N)
  "Return the logarithm (base 10) of `n'."
  (CL:RETURN-FROM LOG (CL:LOG N)))

;;; (DEFUN (MIN INTEGER) ...)

(CL:DEFUN MIN (X Y)
  "Return the minimum of `x' and `y'.  If either is NULL, return the other."
  (CL:DECLARE (CL:TYPE CL:FIXNUM X Y))
  (CL:WHEN (NULL? X) (CL:RETURN-FROM MIN Y))
  (CL:WHEN (NULL? Y) (CL:RETURN-FROM MIN X))
  (CL:RETURN-FROM MIN (CL:IF (CL:< X Y) X Y)))

;;; (DEFUN (MAX INTEGER) ...)

(CL:DEFUN MAX (X Y)
  "Return the maximum of `x' and `y'.  If either is NULL, return the other."
  (CL:DECLARE (CL:TYPE CL:FIXNUM X Y))
  (CL:WHEN (NULL? X) (CL:RETURN-FROM MAX Y))
  (CL:WHEN (NULL? Y) (CL:RETURN-FROM MAX X))
  (CL:RETURN-FROM MAX (CL:IF (CL:> X Y) X Y)))

;;; (DEFMETHOD (ABS INTEGER) ...)

(CL:DEFMETHOD ABS ((X CL:INTEGER))
  "Return the absolute value of `x'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM X))
  (CL:RETURN-FROM ABS (CL:IF (CL:< X 0) (CL:- 0 X) X))
  KWD-PRIMAL-PUBLIC?
  TRUE)

;;; (DEFMETHOD (ABS FLOAT) ...)

(CL:DEFMETHOD ABS ((X CL:FLOAT))
  "Return the absolute value of `x'."
  (CL:RETURN-FROM ABS (CL:IF (CL:< X 0.0) (CL:- 0.0 X) X)))

;;; (DEFUN (CHARACTER-CODE INTEGER) ...)

(CL:DEFUN CHARACTER-CODE (CHARACTER)
  "Return the 8-bit ASCII code of 'character' as an integer."
  (CL:RETURN-FROM CHARACTER-CODE (CL:CHAR-CODE CHARACTER)))

;;; (DEFUN (CODE-CHARACTER CHARACTER) ...)

(CL:DEFUN CODE-CHARACTER (CODE)
  "Return the character encoded by 'code' (0 <= 'code' <= 255)."
  (CL:DECLARE (CL:TYPE CL:FIXNUM CODE))
  (CL:RETURN-FROM CODE-CHARACTER (CL:CODE-CHAR CODE)))

;;; (DEFSPECIAL *TRANSIENTOBJECTS?* ...)

(CL:DEFVAR *TRANSIENTOBJECTS?* FALSE)

(CL:DEFUN READ-*TRANSIENTOBJECTS?* ()
  (CL:RETURN-FROM READ-*TRANSIENTOBJECTS?* *TRANSIENTOBJECTS?*))

(CL:DEFUN WRITE-*TRANSIENTOBJECTS?* (VALUE)
  (CL:SETQ *TRANSIENTOBJECTS?* VALUE)
  (CL:RETURN-FROM WRITE-*TRANSIENTOBJECTS?* VALUE))

;;; (DEFUN (STRING-COMPARE INTEGER) ...)

(CL:DEFUN STRING-COMPARE (X Y)
  "Compare 'x' and 'y' lexicographically, and return -1, 0, 
or 1, depending on whether 'x' is less than, equal, or greater than 'y'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:LET* ((TEMP1 NULL-INTEGER) (TEMP2 NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM TEMP1 TEMP2))
   (CL:LET*
    ((C2 NULL) (C1 NULL) (VECTOR-000 X) (INDEX-000 0)
     (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))) (VECTOR-001 Y)
     (INDEX-001 0) (LENGTH-001 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-001))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000 VECTOR-001)
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
     (CL:PROGN
      (CL:SETQ C1
       (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:PROGN
      (CL:SETQ C2
       (CL:LET ((SELF VECTOR-001) (POSITION INDEX-001))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:SETQ TEMP1 (CL:THE CL:FIXNUM (CL:CHAR-CODE C1)))
     (CL:SETQ TEMP2 (CL:THE CL:FIXNUM (CL:CHAR-CODE C2)))
     (CL:WHEN (CL:< TEMP1 TEMP2) (CL:RETURN-FROM STRING-COMPARE -1))
     (CL:WHEN (CL:> TEMP1 TEMP2) (CL:RETURN-FROM STRING-COMPARE 1))))
   (CL:SETQ TEMP1 (CL:THE CL:FIXNUM (CL:LENGTH X)))
   (CL:SETQ TEMP2 (CL:THE CL:FIXNUM (CL:LENGTH Y)))
   (CL:IF (CL:= TEMP1 TEMP2) (CL:RETURN-FROM STRING-COMPARE 0)
    (CL:IF (CL:< TEMP1 TEMP2) (CL:RETURN-FROM STRING-COMPARE -1)
     (CL:RETURN-FROM STRING-COMPARE 1))))
  (CL:ERROR "Returned from `|F|STRING-COMPARE' without a `return'."))

;;; (DEFUN (STRING< BOOLEAN) ...)

(CL:DEFUN STRING< (X Y)
  "Return TRUE if 'x' is lexicographically < 'y'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:RETURN-FROM STRING< (EQ? (STRING-COMPARE X Y) -1)))

;;; (DEFUN (STRING<= BOOLEAN) ...)

(CL:DEFUN STRING<= (X Y)
  "Return TRUE if 'x' is lexicographically <= 'y'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:RETURN-FROM STRING<= (<= (STRING-COMPARE X Y) 0)))

;;; (DEFUN (STRING>= BOOLEAN) ...)

(CL:DEFUN STRING>= (X Y)
  "Return TRUE if 'x' is lexicographically >= 'y'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:RETURN-FROM STRING>= (>= (STRING-COMPARE X Y) 0)))

;;; (DEFUN (STRING> BOOLEAN) ...)

(CL:DEFUN STRING> (X Y)
  "Return TRUE if 'x' is lexicographically > 'y'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:RETURN-FROM STRING> (EQ? (STRING-COMPARE X Y) 1)))

;;; (DEFUN (MAKE-MUTABLE-STRING MUTABLE-STRING) ...)

(CL:DEFUN MAKE-MUTABLE-STRING (SIZE INITCHAR)
  "Return a new mutable string filled with 'size' 'initchar's."
  (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
  (CL:RETURN-FROM MAKE-MUTABLE-STRING
   (CL:make-string size :initial-element initchar)))

;;; (DEFUN (MAKE-RAW-MUTABLE-STRING MUTABLE-STRING) ...)

(CL:DEFUN MAKE-RAW-MUTABLE-STRING (SIZE)
  "Return a new uninitialized mutable string of `size'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
  (CL:LET* ((S NULL)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
   (setq s (CL:make-string size)) (CL:RETURN-FROM MAKE-RAW-MUTABLE-STRING S))
  (CL:ERROR "Returned from `|F|MAKE-RAW-MUTABLE-STRING' without a `return'."))

;;; (DEFMETHOD (CONCATENATE STRING) ...)

(CL:DEFMETHOD CONCATENATE ((STRING1 CL:STRING) STRING2 CL:&REST OTHERSTRINGS)
  "Return a new string representing the concatenation
of `string1', `string2', and `otherStrings'.  The two mandatory parameters
allow us to optimize the common binary case by not relying on the somewhat
less efficient variable arguments mechanism."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING1 STRING2))
  (CL:WHEN (CL:= (CL:LENGTH OTHERSTRINGS) 0)
   (CL:RETURN-FROM CONCATENATE (STRING-CONCATENATE STRING1 STRING2)))
  (CL:LET*
   ((RESULT NULL)
    (LENGTH
     (CL:+ (CL:THE CL:FIXNUM (CL:LENGTH STRING1))
      (CL:THE CL:FIXNUM (CL:LENGTH STRING2))))
    (INDEX 0))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT)
    (CL:TYPE CL:FIXNUM LENGTH INDEX))
   (CL:LET* ((STRING NULL) (ITER-000 OTHERSTRINGS))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ STRING (CL:POP ITER-000))
     (CL:SETQ LENGTH (CL:+ LENGTH (CL:THE CL:FIXNUM (CL:LENGTH STRING))))))
   (CL:SETQ RESULT
    (CL:LET ((SIZE LENGTH) (INITCHAR NULL-CHARACTER))
     (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
     (CL:THE CL:SIMPLE-STRING
      (CL:make-string size :initial-element initchar))))
   (CL:LET*
    ((CH NULL) (VECTOR-000 STRING1) (INDEX-000 0)
     (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ CH
       (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:LET ((SELF RESULT) (CH CH) (POSITION INDEX))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (SETF
       (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))
       (CL:THE CL:CHARACTER CH)))
     (CL:SETQ INDEX (CL:1+ INDEX))))
   (CL:LET*
    ((CH NULL) (VECTOR-001 STRING2) (INDEX-001 0)
     (LENGTH-001 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-001))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-001)
     (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
    (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
     (CL:PROGN
      (CL:SETQ CH
       (CL:LET ((SELF VECTOR-001) (POSITION INDEX-001))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:LET ((SELF RESULT) (CH CH) (POSITION INDEX))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (SETF
       (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))
       (CL:THE CL:CHARACTER CH)))
     (CL:SETQ INDEX (CL:1+ INDEX))))
   (CL:LET* ((STRING NULL) (ITER-001 OTHERSTRINGS))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
    (CL:LOOP WHILE ITER-001 DO (CL:SETQ STRING (CL:POP ITER-001))
     (CL:LET*
      ((CH NULL) (VECTOR-002 STRING) (INDEX-002 0)
       (LENGTH-002 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-002))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-002)
       (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
      (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
       (CL:PROGN
        (CL:SETQ CH
         (CL:LET ((SELF VECTOR-002) (POSITION INDEX-002))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
       (CL:LET ((SELF RESULT) (CH CH) (POSITION INDEX))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (SETF
         (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))
         (CL:THE CL:CHARACTER CH)))
       (CL:SETQ INDEX (CL:1+ INDEX))))))
   (CL:RETURN-FROM CONCATENATE
    (CL:LET ((S RESULT)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
     (CL:THE CL:SIMPLE-STRING S))))
  (CL:ERROR "Returned from `|M|STRING.CONCATENATE' without a `return'."))

;;; (DEFMETHOD (NTH CHARACTER) ...)

(CL:DEFMETHOD NTH ((SELF CL:STRING) POSITION)
  "Return the character in `self' at `position'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF) (CL:TYPE CL:FIXNUM POSITION))
  (CL:RETURN-FROM NTH
   (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))))

;;; (DEFMETHOD (NTH CHARACTER) ...)

(CL:DEFMETHOD NTH ((SELF CL:STRING) POSITION)
  "Return the character in `self' at `position'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF) (CL:TYPE CL:FIXNUM POSITION))
  (CL:RETURN-FROM NTH
   (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))))

;;; (DEFMETHOD (NTH-SETTER CHARACTER) ...)

(CL:DEFMETHOD NTH-SETTER ((SELF CL:STRING) CH POSITION)
  "Set the character in `self' at `position' to `ch'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF) (CL:TYPE CL:FIXNUM POSITION))
  (CL:RETURN-FROM NTH-SETTER
   (SETF (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))
    (CL:THE CL:CHARACTER CH))))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF CL:STRING))
  "Return the length of the string `self'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  (CL:RETURN-FROM LENGTH (CL:LENGTH SELF)))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF CL:STRING))
  "Return the length of the string `self'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  (CL:RETURN-FROM LENGTH (CL:LENGTH SELF)))

;;; (DEFUN (UNSTRINGIFY OBJECT) ...)

(CL:DEFUN UNSTRINGIFY (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  (CL:RETURN-FROM UNSTRINGIFY (READ-S-EXPRESSION-FROM-STRING STRING)))

;;; (DEFMETHOD FREE-HASH-TABLE-VALUES ...)

(CL:DEFMETHOD FREE-HASH-TABLE-VALUES ((SELF ABSTRACT-HASH-TABLE))
  "Call free on each value in the hash table 'self'."
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:maphash #'(CL:lambda (key value)
				     (CL:declare (CL:ignore key))
				     (free value))
				 native-table))
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF ABSTRACT-HASH-TABLE))
  "Insert a newly-created native hash table into 'self'."
  (CL:SETF (%THE-HASH-TABLE SELF) (CL:make-hash-table :test #'CL:eql))
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF HASH-TABLE) KEY)
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:RETURN-FROM LOOKUP (CL:OR (CL:GETHASH KEY NATIVE-TABLE) NULL)))
  (CL:ERROR "Returned from `|M|HASH-TABLE.LOOKUP' without a `return'."))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF HASH-TABLE) KEY VALUE)
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:SETF (CL:GETHASH KEY NATIVE-TABLE) VALUE))
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF HASH-TABLE) KEY)
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:REMHASH KEY NATIVE-TABLE))
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF INTEGER-HASH-TABLE))
  "Insert a newly-created native hash table into 'self'."
  (CL:SETF (%THE-HASH-TABLE SELF) (CL:make-hash-table :test #'CL:eql))
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF INTEGER-HASH-TABLE) KEY)
  (CL:DECLARE (CL:TYPE CL:FIXNUM KEY))
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:RETURN-FROM LOOKUP (CL:OR (CL:GETHASH KEY NATIVE-TABLE) NULL)))
  (CL:ERROR "Returned from `|M|INTEGER-HASH-TABLE.LOOKUP' without a `return'."))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF INTEGER-HASH-TABLE) KEY VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM KEY))
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:DECLARE (CL:FIXNUM KEY)) (CL:SETF (CL:GETHASH KEY NATIVE-TABLE) VALUE))
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF INTEGER-HASH-TABLE) KEY)
  (CL:DECLARE (CL:TYPE CL:FIXNUM KEY))
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:REMHASH KEY NATIVE-TABLE))
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF FLOAT-HASH-TABLE))
  "Insert a newly-created native hash table into 'self'."
  (CL:SETF (%THE-HASH-TABLE SELF) (CL:make-hash-table :test #'CL:eql))
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF FLOAT-HASH-TABLE) KEY)
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:RETURN-FROM LOOKUP (CL:OR (CL:GETHASH KEY NATIVE-TABLE) NULL)))
  (CL:ERROR "Returned from `|M|FLOAT-HASH-TABLE.LOOKUP' without a `return'."))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF FLOAT-HASH-TABLE) KEY VALUE)
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:SETF (CL:GETHASH KEY NATIVE-TABLE) VALUE))
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF FLOAT-HASH-TABLE) KEY)
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:REMHASH KEY NATIVE-TABLE))
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-HASH-TABLE))
  "Insert a newly-created native hash table into 'self'."
  (CL:SETF (%THE-HASH-TABLE SELF) (CL:make-hash-table :test #'CL:equal))
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF STRING-HASH-TABLE) KEY)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:RETURN-FROM LOOKUP (CL:OR (CL:GETHASH KEY NATIVE-TABLE) NULL)))
  (CL:ERROR "Returned from `|M|STRING-HASH-TABLE.LOOKUP' without a `return'."))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF STRING-HASH-TABLE) KEY VALUE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:SETF (CL:GETHASH KEY NATIVE-TABLE) VALUE))
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF STRING-HASH-TABLE) KEY)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:REMHASH KEY NATIVE-TABLE))
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-TO-INTEGER-HASH-TABLE))
  "Insert a newly-created native hash table into 'self'."
  (CL:SETF (%THE-HASH-TABLE SELF) (CL:make-hash-table :test #'CL:equal))
  :VOID)

;;; (DEFMETHOD (LOOKUP INTEGER) ...)

(CL:DEFMETHOD LOOKUP ((SELF STRING-TO-INTEGER-HASH-TABLE) KEY)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF))) NULL
   (CL:RETURN-FROM LOOKUP (CL:OR (CL:GETHASH KEY NATIVE-TABLE) NULL-INTEGER)))
  (CL:ERROR
   "Returned from `|M|STRING-TO-INTEGER-HASH-TABLE.LOOKUP' without a `return'."))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) KEY VALUE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY) (CL:TYPE CL:FIXNUM VALUE))
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:SETF (CL:GETHASH KEY NATIVE-TABLE) VALUE))
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) KEY)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
  (CL:LET* ((NATIVE-TABLE (%THE-HASH-TABLE SELF)))
   (CL:REMHASH KEY NATIVE-TABLE))
  :VOID)

;;; (DEFUN (HASH-STRING INTEGER) ...)

(CL:DEFUN HASH-STRING (STRING SEEDCODE)
  "Generate a hash-code for `string' and return it.
Two strings that are equal but not eq will generate the same code.
The hash-code is based on `seedCode' which usually will be 0.  However,
`seedCode' can also be used to supply the result of a previous hash
operation to achieve hashing on sequences of strings without actually
having to concatenate them."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING) (CL:TYPE CL:FIXNUM SEEDCODE))
  (CL:RETURN-FROM HASH-STRING (HASH-SUBSTRING STRING SEEDCODE 0 NULL-INTEGER)))

;;; (DEFUN (HASH-SUBSTRING INTEGER) ...)

(CL:DEFUN HASH-SUBSTRING (STRING CODE START END)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING)
   (CL:TYPE CL:FIXNUM CODE START END))
  (CL:WHEN (CL:= START NULL-INTEGER) (CL:SETQ START 0))
  (CL:WHEN (CL:= END NULL-INTEGER)
   (CL:SETQ END (CL:THE CL:FIXNUM (CL:LENGTH STRING))))
  (CL:SETQ CODE (CL:THE CL:FIXNUM (CL:LOGXOR CODE 2700379)))
  (CL:LET*
   ((OFFSET
     (CL:LET ((ARG CODE) (COUNT 9)) (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
      (CL:THE CL:FIXNUM (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT)))))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
   (CL:LET* ((I NULL) (ITER-000 START) (UPPER-BOUND-000 (CL:1- END)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:SETQ OFFSET (CL:1+ OFFSET))
     (CL:SETQ CODE
      (CL:THE CL:FIXNUM
       (CL:LOGXOR CODE
        (CL:THE CL:FIXNUM
         (CL:ASH
          (CL:THE CL:FIXNUM
           (CL:CHAR-CODE
            (CL:LET ((SELF STRING) (POSITION I))
             (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
              (CL:TYPE CL:FIXNUM POSITION))
             (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
              (CL:THE CL:FIXNUM POSITION)))))
          (CL:THE CL:FIXNUM (CL:LOGAND OFFSET 15)))))))))
   (CL:RETURN-FROM HASH-SUBSTRING CODE))
  (CL:ERROR "Returned from `|F|HASH-SUBSTRING' without a `return'."))

;;; (DEFMETHOD INITIALIZE-VECTOR ...)

(CL:DEFMETHOD INITIALIZE-VECTOR ((SELF VECTOR))
  (SETF (CLSYS-SVAL 2 VECTOR THE-ARRAY SELF)
   (CL:MAKE-ARRAY (CLSYS-SVAL 1 VECTOR ARRAY-SIZE SELF) :INITIAL-ELEMENT NULL))
  :VOID)

;;; (DEFUN RESIZE-VECTOR ...)

(CL:DEFUN RESIZE-VECTOR (SELF SIZE)
  "Change the size of 'self' to 'size'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
  (CL:LET
   ((TOOSMALLARRAY (CLSYS-SVAL 2 VECTOR THE-ARRAY SELF))
    (BIGGERARRAY (CL:MAKE-ARRAY SIZE :INITIAL-ELEMENT NULL)))
   (CL:DOTIMES (I (CLSYS-SVAL 1 VECTOR ARRAY-SIZE SELF))
    (CL:SETF (CL:AREF BIGGERARRAY I) (CL:AREF TOOSMALLARRAY I)))
   (CL:SETF (CLSYS-SVAL 2 VECTOR THE-ARRAY SELF) BIGGERARRAY)
   (CL:SETF (CLSYS-SVAL 1 VECTOR ARRAY-SIZE SELF) SIZE))
  :VOID)

;;; (DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH ((SELF CL:VECTOR) POSITION)
  "Return the element in `self' at `position'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
  (CL:RETURN-FROM NTH
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR SELF) (CL:THE CL:FIXNUM POSITION))))

;;; (DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH-SETTER ((SELF CL:VECTOR) VALUE POSITION)
  "Set the element in `self' at `position' to `value'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
  (CL:RETURN-FROM NTH-SETTER
   (CL:SETF
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR SELF) (CL:THE CL:FIXNUM POSITION))
    VALUE)))

;;; (DEFUN UNMAKE ...)

(CL:DEFUN UNMAKE (SELF)
  NULL
  :VOID)

;;; (DEFUN (LOGNOT INTEGER) ...)

(CL:DEFUN LOGNOT (ARG)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARG))
  (CL:RETURN-FROM LOGNOT (CL:LOGNOT ARG)))

;;; (DEFUN (LOGAND INTEGER) ...)

(CL:DEFUN LOGAND (ARG1 ARG2)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARG1 ARG2))
  (CL:RETURN-FROM LOGAND (CL:LOGAND ARG1 ARG2)))

;;; (DEFUN (LOGOR INTEGER) ...)

(CL:DEFUN LOGOR (ARG1 ARG2)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARG1 ARG2))
  (CL:RETURN-FROM LOGOR (CL:LOGIOR ARG1 ARG2)))

;;; (DEFUN (LOGXOR INTEGER) ...)

(CL:DEFUN LOGXOR (ARG1 ARG2)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARG1 ARG2))
  (CL:RETURN-FROM LOGXOR (CL:LOGXOR ARG1 ARG2)))

;;; (DEFUN (SHIFT-LEFT INTEGER) ...)

(CL:DEFUN SHIFT-LEFT (ARG COUNT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
  (CL:RETURN-FROM SHIFT-LEFT (CL:ASH ARG COUNT)))

;;; (DEFUN (SHIFT-RIGHT INTEGER) ...)

(CL:DEFUN SHIFT-RIGHT (ARG COUNT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
  (CL:RETURN-FROM SHIFT-RIGHT (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT)))))

;;; (DEFUN (STELLIFY OBJECT) ...)

(CL:DEFUN STELLIFY (SELF)
  "Convert a Lisp object into a STELLA object."
  (CL:LET* ((RESULT SELF)) (CL:typecase self
        (CL:NULL (cl:setq result STELLA::NIL))
        (CL:CONS (cl:setq result (stella::cons (stellify (CL:car self))
                                               (stellify (CL:cdr self)))))
        (CL:KEYWORD (cl:setq result (intern-keyword (CL:symbol-name self))))
        (CL:SYMBOL
         (CL:if (cl:eq self CL:t)
           (cl:setq result TRUE-WRAPPER)
           (cl:setq result (intern-symbol (CL:symbol-name self)))))
        ((CL:or CL:NUMBER CL:STRING) (cl:setq result (wrap-literal self)))
        (STELLA::OBJECT (cl:setq result self))
        (CL:t (CL:error "Can't stellify: " self)))
   (CL:RETURN-FROM STELLIFY RESULT))
  (CL:ERROR "Returned from `|F|STELLIFY' without a `return'."))

;;; (DEFUN (STELLA-OBJECT? BOOLEAN) ...)

(CL:DEFUN STELLA-OBJECT? (SELF)
  "Return TRUE if 'self' is a member of the STELLA class 'OBJECT'."
  (CL:LET* ((RESULT? TRUE)) (CL:setq result? (cl:typep self 'STELLA::OBJECT))
   (CL:RETURN-FROM STELLA-OBJECT? RESULT?))
  (CL:ERROR "Returned from `|F|STELLA-OBJECT?' without a `return'."))

;;; (DEFUN (RUNNING-AS-LISP? BOOLEAN) ...)

(CL:DEFUN RUNNING-AS-LISP? ()
  "Return TRUE if the executable code is a Common Lisp application."
  (CL:LET* ((RESULT? FALSE)) (cl:setq result? TRUE)
   (CL:RETURN-FROM RUNNING-AS-LISP? RESULT?))
  (CL:ERROR "Returned from `|F|RUNNING-AS-LISP?' without a `return'."))

(CL:DEFUN HELP-STARTUP-PRIMAL1 ()
  (CL:PROGN
   (CL:SETQ KWD-PRIMAL-PUBLIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC?" NULL 2))
   (CL:SETQ SYM-PRIMAL-STELLA-FLOOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOOR" NULL 0))
   (CL:SETQ KWD-PRIMAL-CPP (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
   (CL:SETQ KWD-PRIMAL-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-PRIMAL-STELLA-RANDOM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RANDOM" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-SQRT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SQRT" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-COS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COS" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-SIN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIN" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-TAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TAN" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-LOG
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOG" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-MIN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MIN" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-MAX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAX" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-*TRANSIENTOBJECTS?*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*TRANSIENTOBJECTS?*" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-PRIMAL2 ()
  (CL:PROGN
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST UNKNOWN)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST OBJECT)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST STRING)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST MUTABLE-STRING)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST CHARACTER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST CODE)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST INTEGER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST FLOAT)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST UNKNOWN)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST OBJECT)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST STRING)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST MUTABLE-STRING)) :NATIVE? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST CHARACTER)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST CODE)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST INTEGER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST FLOAT)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT ">"
    "(DEFUN (> BOOLEAN) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT ">="
    "(DEFUN (>= BOOLEAN) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "<"
    "(DEFUN (< BOOLEAN) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "<="
    "(DEFUN (<= BOOLEAN) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "+"
    "(DEFUN (+ NUMBER) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "-"
    "(DEFUN (- NUMBER) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "*"
    "(DEFUN (* NUMBER) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "/"
    "(DEFUN (/ NUMBER) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "ZERO?"
    "(DEFUN (ZERO? BOOLEAN) ((X INTEGER)) :NATIVE? TRUE :PUBLIC? TRUE)" NULL
    NULL)
   (DEFINE-FUNCTION-OBJECT "PLUS?"
    "(DEFUN (PLUS? BOOLEAN) ((X INTEGER)) :NATIVE? TRUE :PUBLIC? TRUE)" NULL
    NULL)
   (DEFINE-FUNCTION-OBJECT "EVEN?"
    "(DEFUN (EVEN? BOOLEAN) ((X INTEGER)) :NATIVE? TRUE :PUBLIC? TRUE)" NULL
    NULL)
   (DEFINE-FUNCTION-OBJECT "ODD?"
    "(DEFUN (ODD? BOOLEAN) ((X INTEGER)) :NATIVE? TRUE :PUBLIC? TRUE)" NULL
    NULL)
   (DEFINE-FUNCTION-OBJECT "MOD"
    "(DEFUN (MOD INTEGER) ((X INTEGER) (MODULO INTEGER)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "CEILING"
    "(DEFUN (CEILING INTEGER) ((N NUMBER)) :NATIVE? TRUE :PUBLIC? TRUE)" NULL
    NULL)
   (DEFINE-FUNCTION-OBJECT "FLOOR"
    "(DEFUN (FLOOR INTEGER) ((N NUMBER)) :NATIVE? TRUE :PUBLIC? TRUE)" NULL
    NULL)
   (DEFINE-FUNCTION-OBJECT "EXP"
    "(DEFUN (EXP FLOAT) ((X FLOAT)) :PUBLIC? TRUE :NATIVE? TRUE :DOCUMENTATION \"The natural exponentiation function e^x.\")"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "RANDOM"
    "(DEFUN (RANDOM INTEGER) ((N INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Generate a random integer in the interval [0..n-1].
'n' must be <= 2^15.\")" (CL:FUNCTION RANDOM) NULL)
   (DEFINE-FUNCTION-OBJECT "SEED-RANDOM-NUMBER-GENERATOR"
    "(DEFUN SEED-RANDOM-NUMBER-GENERATOR () :PUBLIC? TRUE :DOCUMENTATION \"Seeds the random number generator with the current time\")"
    (CL:FUNCTION SEED-RANDOM-NUMBER-GENERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "SQRT"
    "(DEFUN (SQRT FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the square root of `n'.\" (RETURN (VERBATIM :COMMON-LISP (CL:SQRT N) :CPP \"sqrt(n)\" :JAVA \"Math.sqrt(n)\")))"
    (CL:FUNCTION SQRT) NULL)
   (DEFINE-FUNCTION-OBJECT "COS"
    "(DEFUN (COS FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the cosine of `n'.\" (RETURN (VERBATIM :COMMON-LISP (CL:COS N) :CPP \"cos(n)\" :JAVA \"Math.cos(n)\")))"
    (CL:FUNCTION COS) NULL)
   (DEFINE-FUNCTION-OBJECT "SIN"
    "(DEFUN (SIN FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the sine of `n'.\" (RETURN (VERBATIM :COMMON-LISP (CL:SIN N) :CPP \"sin(n)\" :JAVA \"Math.sin(n)\")))"
    (CL:FUNCTION SIN) NULL)
   (DEFINE-FUNCTION-OBJECT "TAN"
    "(DEFUN (TAN FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the tangent of `n'.\" (RETURN (VERBATIM :COMMON-LISP (CL:TAN N) :CPP \"tan(n)\" :JAVA \"Math.tan(n)\")))"
    (CL:FUNCTION TAN) NULL)
   (DEFINE-FUNCTION-OBJECT "LOG"
    "(DEFUN (LOG FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the logarithm (base 10) of `n'.\" (RETURN (VERBATIM :COMMON-LISP (CL:LOG N) :CPP \"log(n)\" :JAVA \"Math.log(n)\")))"
    (CL:FUNCTION LOG) NULL)
   (DEFINE-FUNCTION-OBJECT "MIN"
    "(DEFUN (MIN INTEGER) ((X INTEGER) (Y INTEGER)) :DOCUMENTATION \"Return the minimum of `x' and `y'.  If either is NULL, return the other.\" :PUBLIC? TRUE)"
    (CL:FUNCTION MIN) NULL)
   (DEFINE-FUNCTION-OBJECT "MAX"
    "(DEFUN (MAX INTEGER) ((X INTEGER) (Y INTEGER)) :DOCUMENTATION \"Return the maximum of `x' and `y'.  If either is NULL, return the other.\" :PUBLIC? TRUE)"
    (CL:FUNCTION MAX) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ABS INTEGER) ((X INTEGER)) :DOCUMENTATION \"Return the absolute value of `x'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (CHOOSE (< X 0) (- 0 X) X)) :PUBLIC? TRUE)"
    (CL:FUNCTION ABS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ABS FLOAT) ((X FLOAT)) :DOCUMENTATION \"Return the absolute value of `x'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (CHOOSE (< X 0.0) (- 0.0 X) X)))"
    (CL:FUNCTION ABS) NULL)
   (DEFINE-FUNCTION-OBJECT "CHARACTER-CODE"
    "(DEFUN (CHARACTER-CODE INTEGER) ((CHARACTER CHARACTER)) :DOCUMENTATION \"Return the 8-bit ASCII code of 'character' as an integer.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:CHAR-CODE CHARACTER) :CPP \"(int)(unsigned char) character\" :JAVA \"(int) character\")))"
    (CL:FUNCTION CHARACTER-CODE) NULL)
   (DEFINE-FUNCTION-OBJECT "CODE-CHARACTER"
    "(DEFUN (CODE-CHARACTER CHARACTER) ((CODE INTEGER)) :DOCUMENTATION \"Return the character encoded by 'code' (0 <= 'code' <= 255).\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:CODE-CHAR CODE) :CPP \"(char) code\" :JAVA \"(char) code\")))"
    (CL:FUNCTION CODE-CHARACTER) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-EQL?"
    "(DEFUN (STRING-EQL? BOOLEAN) ((X STRING) (Y STRING)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-COMPARE"
    "(DEFUN (STRING-COMPARE INTEGER) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Compare 'x' and 'y' lexicographically, and return -1, 0, 
or 1, depending on whether 'x' is less than, equal, or greater than 'y'.\")"
    (CL:FUNCTION STRING-COMPARE) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING<"
    "(DEFUN (STRING< BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically < 'y'.\")"
    (CL:FUNCTION STRING<) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING<="
    "(DEFUN (STRING<= BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically <= 'y'.\")"
    (CL:FUNCTION STRING<=) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING>="
    "(DEFUN (STRING>= BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically >= 'y'.\")"
    (CL:FUNCTION STRING>=) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING>"
    "(DEFUN (STRING> BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically > 'y'.\")"
    (CL:FUNCTION STRING>) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-STRING"
    "(DEFUN (MAKE-STRING STRING) ((SIZE INTEGER) (INITCHAR CHARACTER)) :DOCUMENTATION \"Return a new string filled with 'size' 'initchar's.\" :PUBLIC? TRUE :NATIVE? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-MUTABLE-STRING"
    "(DEFUN (MAKE-MUTABLE-STRING MUTABLE-STRING) ((SIZE INTEGER) (INITCHAR CHARACTER)) :DOCUMENTATION \"Return a new mutable string filled with 'size' 'initchar's.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP \"(CL:make-string size :initial-element initchar)\" :CPP \"make_string(size, initchar)\" :JAVA \"stella.javalib.Native.make_mutable_string(size, initchar)\")))"
    (CL:FUNCTION MAKE-MUTABLE-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-RAW-MUTABLE-STRING"
    "(DEFUN (MAKE-RAW-MUTABLE-STRING MUTABLE-STRING) ((SIZE INTEGER)) :DOCUMENTATION \"Return a new uninitialized mutable string of `size'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (LET ((S MUTABLE-STRING NULL)) (VERBATIM :COMMON-LISP \"(setq s (CL:make-string size))\" :CPP \"s = new (GC) char[size]\" :JAVA \"s = new StringBuffer(size); s.setLength(size)\") (RETURN S)))"
    (CL:FUNCTION MAKE-RAW-MUTABLE-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-CONCATENATE"
    "(DEFUN (STRING-CONCATENATE STRING) ((STRING1 STRING) (STRING2 STRING)) :DOCUMENTATION \"Return a new string representing the concatenation of
'string1' and 'string2'.\" :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONCATENATE STRING) ((STRING1 STRING) (STRING2 STRING) |&REST| (OTHERSTRINGS STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return a new string representing the concatenation
of `string1', `string2', and `otherStrings'.  The two mandatory parameters
allow us to optimize the common binary case by not relying on the somewhat
less efficient variable arguments mechanism.\")" (CL:FUNCTION CONCATENATE)
    NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-UPCASE"
    "(DEFUN (STRING-UPCASE STRING) ((STRING STRING)) :DOCUMENTATION \"Return an upper-case copy of 'string'.\" :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-DOWNCASE"
    "(DEFUN (STRING-DOWNCASE STRING) ((STRING STRING)) :DOCUMENTATION \"Return a lower-case copy of 'string'.\" :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-CAPITALIZE"
    "(DEFUN (STRING-CAPITALIZE STRING) ((STRING STRING)) :DOCUMENTATION \"Return a capitalized version of 'string'.\" :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY STRING) ((STRING STRING)) :DOCUMENTATION \"Return a copy of 'string'.\" :NATIVE? TRUE)"
    NULL NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-PRIMAL3 ()
  (CL:PROGN
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBSTITUTE MUTABLE-STRING) ((SELF MUTABLE-STRING) (NEWCHAR CHARACTER) (OLDCHAR CHARACTER)) :DOCUMENTATION \"Substitute all occurences of 'oldChar' with 'newChar'
in the string 'self'.\" :NATIVE? TRUE :PUBLIC? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBSTITUTE STRING) ((SELF STRING) (NEWCHAR CHARACTER) (OLDCHAR CHARACTER)) :DOCUMENTATION \"Substitute all occurences of 'oldChar' with 'newChar'
in the string 'self'.\" :NATIVE? TRUE :PUBLIC? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "INTEGER-TO-STRING"
    "(DEFUN (INTEGER-TO-STRING STRING) ((I INTEGER)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "FLOAT-TO-STRING"
    "(DEFUN (FLOAT-TO-STRING STRING) ((F FLOAT)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "FORMAT-FLOAT"
    "(DEFUN (FORMAT-FLOAT STRING) ((F FLOAT) (NDECIMALS INTEGER)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-INTEGER"
    "(DEFUN (STRING-TO-INTEGER INTEGER) ((STRING STRING)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-FLOAT"
    "(DEFUN (STRING-TO-FLOAT FLOAT) ((STRING STRING)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF STRING) (CHAR CHARACTER)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH CHARACTER) ((SELF STRING) (POSITION INTEGER)) :DOCUMENTATION \"Return the character in `self' at `position'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)) :CPP \"self[position]\" :JAVA \"self.charAt(position)\")))"
    (CL:FUNCTION NTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH CHARACTER) ((SELF MUTABLE-STRING) (POSITION INTEGER)) :DOCUMENTATION \"Return the character in `self' at `position'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)) :CPP \"self[position]\" :JAVA \"self.charAt(position)\")))"
    (CL:FUNCTION NTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH-SETTER CHARACTER) ((SELF MUTABLE-STRING) (CH CHARACTER) (POSITION INTEGER)) :DOCUMENTATION \"Set the character in `self' at `position' to `ch'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (SETF (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)) (CL:THE CL:CHARACTER CH)) :CPP \"self[position] = ch\" :JAVA \"stella.javalib.Native.mutable_string_nth_setter(self, ch, position)\")))"
    (CL:FUNCTION NTH-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REST STRING) ((SELF STRING)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF STRING)) :DOCUMENTATION \"Return the length of the string `self'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LENGTH SELF) :CPP \"strlen(self)\" :JAVA \"self.length()\")))"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF MUTABLE-STRING)) :DOCUMENTATION \"Return the length of the string `self'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LENGTH SELF) :CPP \"strlen(self)\" :JAVA \"self.length()\")))"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (POSITION INTEGER) ((STRING STRING) (CHARACTER CHARACTER) (START INTEGER)) :DOCUMENTATION \"Return the position of 'character' within 'string' (counting
from zero); or return NULL if 'character' does not occur within 'string'.
If 'start' was supplied as non-NULL, only consider the substring starting
at 'start', however, the returned position will always be relative to the
entire string.\" :NATIVE? TRUE :PUBLIC? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-SEARCH"
    "(DEFUN (STRING-SEARCH INTEGER) ((STRING STRING) (SUBSTRING STRING) (START INTEGER)) :DOCUMENTATION \"Return start position of the left-most occurrence of
'substring' in 'string', beginning from 'start'.  Return NULL if it is not
a substring.\" :NATIVE? TRUE :PUBLIC? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBSEQUENCE STRING) ((STRING STRING) (START INTEGER) (END INTEGER)) :DOCUMENTATION \"Return a substring of 'string' beginning at position 'start'
and ending up to but not including position 'end', counting from zero.  An
'end' value of NULL stands for the rest of the string.\" :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STRINGIFY"
    "(DEFUN (STRINGIFY STRING) ((EXPRESSION OBJECT)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "UNSTRINGIFY"
    "(DEFUN (UNSTRINGIFY OBJECT) ((STRING STRING)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (READ-S-EXPRESSION-FROM-STRING STRING)))"
    (CL:FUNCTION UNSTRINGIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD FREE-HASH-TABLE-VALUES ((SELF ABSTRACT-HASH-TABLE)) :DOCUMENTATION \"Call free on each value in the hash table 'self'.\")"
    (CL:FUNCTION FREE-HASH-TABLE-VALUES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF ABSTRACT-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into 'self'.\")"
    (CL:FUNCTION INITIALIZE-HASH-TABLE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REMOVE-AT ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION REMOVE-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF INTEGER-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into 'self'.\")"
    (CL:FUNCTION INITIALIZE-HASH-TABLE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF INTEGER-HASH-TABLE) (KEY INTEGER)) :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF INTEGER-HASH-TABLE) (KEY INTEGER) (VALUE OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REMOVE-AT ((SELF INTEGER-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))))"
    (CL:FUNCTION REMOVE-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF FLOAT-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into 'self'.\")"
    (CL:FUNCTION INITIALIZE-HASH-TABLE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF FLOAT-HASH-TABLE) (KEY FLOAT)) :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF FLOAT-HASH-TABLE) (KEY FLOAT) (VALUE OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REMOVE-AT ((SELF FLOAT-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))))"
    (CL:FUNCTION REMOVE-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into 'self'.\")"
    (CL:FUNCTION INITIALIZE-HASH-TABLE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF STRING-HASH-TABLE) (KEY STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF STRING-HASH-TABLE) (KEY STRING) (VALUE OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REMOVE-AT ((SELF STRING-HASH-TABLE) (KEY STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION REMOVE-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-TO-INTEGER-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into 'self'.\")"
    (CL:FUNCTION INITIALIZE-HASH-TABLE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP INTEGER) ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING) (VALUE INTEGER)) :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REMOVE-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION REMOVE-AT) NULL)
   (DEFINE-FUNCTION-OBJECT "HASH-STRING"
    "(DEFUN (HASH-STRING INTEGER) ((STRING STRING) (SEEDCODE INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Generate a hash-code for `string' and return it.
Two strings that are equal but not eq will generate the same code.
The hash-code is based on `seedCode' which usually will be 0.  However,
`seedCode' can also be used to supply the result of a previous hash
operation to achieve hashing on sequences of strings without actually
having to concatenate them.\" (RETURN (HASH-SUBSTRING STRING SEEDCODE 0 NULL)))"
    (CL:FUNCTION HASH-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "HASH-SUBSTRING"
    "(DEFUN (HASH-SUBSTRING INTEGER) ((STRING STRING) (CODE INTEGER) (START INTEGER) (END INTEGER)))"
    (CL:FUNCTION HASH-SUBSTRING) NULL)
   (DEFINE-METHOD-OBJECT "(DEFMETHOD INITIALIZE-VECTOR ((SELF VECTOR)))"
    (CL:FUNCTION INITIALIZE-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "RESIZE-VECTOR"
    "(DEFUN RESIZE-VECTOR ((SELF VECTOR) (SIZE INTEGER)) :DOCUMENTATION \"Change the size of 'self' to 'size'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION RESIZE-VECTOR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ((SELF NATIVE-VECTOR) (POSITION INTEGER)) :DOCUMENTATION \"Return the element in `self' at `position'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:AREF (CL:THE CL:SIMPLE-VECTOR SELF) (CL:THE CL:FIXNUM POSITION)) :CPP \"self[position]\" :JAVA \"(Stella_Object)self.elementAt(position)\")))"
    (CL:FUNCTION NTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF NATIVE-VECTOR) (VALUE (LIKE (ANY-VALUE SELF))) (POSITION INTEGER)) :DOCUMENTATION \"Set the element in `self' at `position' to `value'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:SETF (CL:AREF (CL:THE CL:SIMPLE-VECTOR SELF) (CL:THE CL:FIXNUM POSITION)) VALUE) :CPP \"self[position] = value\" :JAVA \"stella.javalib.Native.native_vector_nth_setter(self, value, position)\")))"
    (CL:FUNCTION NTH-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "UNMAKE" "(DEFUN UNMAKE ((SELF OBJECT)))"
    (CL:FUNCTION UNMAKE) NULL)
   (DEFINE-FUNCTION-OBJECT "PROBE-FILE?"
    "(DEFUN (PROBE-FILE? BOOLEAN) ((FILENAME FILE-NAME)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-WRITE-DATE"
    "(DEFUN (FILE-WRITE-DATE INTEGER) ((FILENAME FILE-NAME)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-LENGTH"
    "(DEFUN (FILE-LENGTH INTEGER) ((FILENAME FILE-NAME)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "DELETE-FILE"
    "(DEFUN DELETE-FILE ((FILENAME FILE-NAME)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "LOGNOT"
    "(DEFUN (LOGNOT INTEGER) ((ARG INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGNOT ARG) :CPP \"(~ arg)\" :JAVA \"(~ arg)\")))"
    (CL:FUNCTION LOGNOT) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGAND"
    "(DEFUN (LOGAND INTEGER) ((ARG1 INTEGER) (ARG2 INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGAND ARG1 ARG2) :CPP \"(arg1 & arg2)\" :JAVA \"(arg1 & arg2)\")))"
    (CL:FUNCTION LOGAND) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGOR"
    "(DEFUN (LOGOR INTEGER) ((ARG1 INTEGER) (ARG2 INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGIOR ARG1 ARG2) :CPP \"(arg1 | arg2)\" :JAVA \"(arg1 | arg2)\")))"
    (CL:FUNCTION LOGOR) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGXOR"
    "(DEFUN (LOGXOR INTEGER) ((ARG1 INTEGER) (ARG2 INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGXOR ARG1 ARG2) :CPP \"(arg1 ^ arg2)\" :JAVA \"(arg1 ^ arg2)\")))"
    (CL:FUNCTION LOGXOR) NULL)
   (DEFINE-FUNCTION-OBJECT "INTEGER-LENGTH"
    "(DEFUN (INTEGER-LENGTH INTEGER) ((ARG INTEGER)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "SHIFT-LEFT"
    "(DEFUN (SHIFT-LEFT INTEGER) ((ARG INTEGER) (COUNT INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:ASH ARG COUNT) :CPP \"(arg << count)\" :JAVA \"(arg << count)\")))"
    (CL:FUNCTION SHIFT-LEFT) NULL)
   (DEFINE-FUNCTION-OBJECT "SHIFT-RIGHT"
    "(DEFUN (SHIFT-RIGHT INTEGER) ((ARG INTEGER) (COUNT INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))) :CPP \"(arg >> count)\" :JAVA \"(arg >> count)\")))"
    (CL:FUNCTION SHIFT-RIGHT) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLIFY"
    "(DEFUN (STELLIFY OBJECT) ((SELF OBJECT)) :DOCUMENTATION \"Convert a Lisp object into a STELLA object.\" :PUBLIC? TRUE)"
    (CL:FUNCTION STELLIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-OBJECT?"
    "(DEFUN (STELLA-OBJECT? BOOLEAN) ((SELF OBJECT)) :DOCUMENTATION \"Return TRUE if 'self' is a member of the STELLA class 'OBJECT'.\")"
    (CL:FUNCTION STELLA-OBJECT?) NULL))
  :VOID)

(CL:DEFUN STARTUP-PRIMAL ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-PRIMAL1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-PRIMAL2)
    (HELP-STARTUP-PRIMAL3)
    (DEFINE-FUNCTION-OBJECT "RUNNING-AS-LISP?"
     "(DEFUN (RUNNING-AS-LISP? BOOLEAN) () :DOCUMENTATION \"Return TRUE if the executable code is a Common Lisp application.\")"
     (CL:FUNCTION RUNNING-AS-LISP?) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-TICKTOCK"
     "(DEFUN (GET-TICKTOCK TICKTOCK) () :PUBLIC? TRUE :NATIVE? TRUE)" NULL
     NULL)
    (DEFINE-FUNCTION-OBJECT "TICKTOCK-DIFFERENCE"
     "(DEFUN (TICKTOCK-DIFFERENCE FLOAT) ((T1 TICKTOCK) (T2 TICKTOCK)) :DOCUMENTATION \"The difference in two TICKTOCK time values in seconds where
`t1' is the earlier time.  The resolution is implementation dependent but will
normally be some fractional value of a second.\" :PUBLIC? TRUE :NATIVE? TRUE)"
     NULL NULL)
    (DEFINE-FUNCTION-OBJECT "TICKTOCK-RESOLUTION"
     "(DEFUN (TICKTOCK-RESOLUTION FLOAT) () :DOCUMENTATION \"The minimum theoretically detectable resolution of the
difference in two TICKTOCK time values in seconds.  This
resolution is implementation dependent.  It may also not
be realizable in practice, since the timing grain size may
be larger than this resolution.\" :PUBLIC? TRUE :NATIVE? TRUE)" NULL NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-PRIMAL"
     "(DEFUN STARTUP-PRIMAL () :PUBLIC? TRUE)" NULL NULL))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT TRUE BOOLEAN (VERBATIM :COMMON-LISP CL:T :CPP \"1\" :JAVA \"true\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT FALSE BOOLEAN (VERBATIM :COMMON-LISP CL:NIL :CPP \"0\" :JAVA \"false\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(defconstant NULL UNKNOWN NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-INTEGER INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"1 << (sizeof (int) / sizeof (char) * 8 - 1)\" :JAVA \"Integer.MIN_VALUE\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-SHORT-INTEGER SHORT-INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"1 << (sizeof (short int) / sizeof (char) * 8 - 1)\" :JAVA \"Short.MIN_VALUE\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-LONG-INTEGER LONG-INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"1 << (sizeof (long int) / sizeof (char) * 8 - 1)\" :JAVA \"Long.MIN_VALUE\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-UNSIGNED-SHORT-INTEGER UNSIGNED-SHORT-INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"(unsigned short int) -1\" :JAVA \"Short.MIN_VALUE\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-UNSIGNED-LONG-INTEGER UNSIGNED-LONG-INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"(unsigned long int) -1\" :JAVA \"Long.MIN_VALUE\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-FLOAT FLOAT (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-DOUBLE-FLOAT :CPP \"-HUGE_VAL /* IEEE infinity, defined in <math.h> */\" :JAVA \"Double.NEGATIVE_INFINITY; /* IEEE Infinity */\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-SINGLE-FLOAT SINGLE-FLOAT (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-SINGLE-FLOAT :CPP \"-HUGE_VAL /* IEEE infinity, defined in <math.h> */\" :JAVA \"Float.NEGATIVE_INFINITY; /* IEEE Infinity */\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-DOUBLE-FLOAT DOUBLE-FLOAT (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-DOUBLE-FLOAT :CPP \"-HUGE_VAL /* IEEE infinity, defined in <math.h> */\" :JAVA \"Double.NEGATIVE_INFINITY; /* IEEE Infinity */\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-CHARACTER CHARACTER (VERBATIM :COMMON-LISP (CL:CODE-CHAR 0) :CPP \"'\\\\0'\" :JAVA \"Character.MIN_VALUE\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-BYTE BYTE (VERBATIM :COMMON-LISP \"255\" :CPP \"255\" :JAVA \"-128\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-OCTET OCTET (VERBATIM :COMMON-LISP \"255\" :CPP \"255\" :JAVA \"-128\") :PUBLIC? TRUE)")
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-FLOOR KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-RANDOM KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-SQRT KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-COS KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-SIN KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-TAN KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-LOG KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-MIN KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-MAX KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TRANSIENTOBJECTS?* BOOLEAN FALSE :PUBLIC? TRUE)")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-PRIMAL-STELLA-*TRANSIENTOBJECTS?*)))
     (CL:SETF (%VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*TRANSIENTOBJECTS?*))
     (CL:SETF (%VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*TRANSIENTOBJECTS?*)))))
  :VOID)
