;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; collections.lisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2006      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-COLLECTIONS-STELLA-COLLECTION NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-SET NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-VECTOR NULL)
(CL:DEFVAR KWD-COLLECTIONS-CPP NULL)
(CL:DEFVAR KWD-COLLECTIONS-FUNCTION NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-VECTOR NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-STELLA-HASH-TABLE NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-SIZE NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-INITIAL-SIZE NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-FREE-ELEMENTS NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-EQUAL-TEST? NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-STELLA-HASH-TABLE-ITERATOR NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-BUCKET-INDEX NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-BUCKET-CURSOR NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-KEY-VALUE-MAP NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-THE-MAP NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-CROSSOVER-POINT NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-HASH-SET NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-STARTUP-COLLECTIONS NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* TRUE-WRAPPER FALSE-WRAPPER
  *INTEGER-MSB-MASK* NULL-INTEGER NIL))

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF COLLECTION) OBJECT)
  "Return true iff `object' is a member of the collection `self'."
  (CL:LET* ((I NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ I (%VALUE ITER-000))
    (CL:WHEN (EQL? I OBJECT) (CL:RETURN-FROM MEMBER? CL:T))))
  (CL:RETURN-FROM MEMBER? CL:NIL))

;;; (DEFUN (STELLA-COLLECTION? BOOLEAN) ...)

(CL:DEFUN STELLA-COLLECTION? (SELF)
  "Return `true' if `self' is a native collection."
  (CL:RETURN-FROM STELLA-COLLECTION?
   (ISA? SELF SGT-COLLECTIONS-STELLA-COLLECTION)))

;;; (DEFMETHOD (NO-DUPLICATES? BOOLEAN) ...)

(CL:DEFMETHOD NO-DUPLICATES? ((SELF COLLECTION))
  "Return `true' if the collection `self' forbids duplicate values."
  (CL:RETURN-FROM NO-DUPLICATES? CL:NIL))

;;; (DEFMETHOD (NO-DUPLICATES? BOOLEAN) ...)

(CL:DEFMETHOD NO-DUPLICATES? ((SELF SET))
  (CL:RETURN-FROM NO-DUPLICATES? CL:T))

;;; (DEFMETHOD (ORDERED? BOOLEAN) ...)

(CL:DEFMETHOD ORDERED? ((SELF COLLECTION))
  "Return `true' if the collection `self' is ordered."
  (CL:RETURN-FROM ORDERED? CL:NIL))

;;; (DEFMETHOD (ORDERED? BOOLEAN) ...)

(CL:DEFMETHOD ORDERED? ((SELF SEQUENCE))
  (CL:RETURN-FROM ORDERED? CL:T))

;;; (DEFMETHOD (ORDERED? BOOLEAN) ...)

(CL:DEFMETHOD ORDERED? ((SELF SET))
  (CL:RETURN-FROM ORDERED? CL:NIL))

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF SET) VALUE)
  "Add `value' to the set `self' unless it is already a member."
  (CL:WHEN (CL:NOT (MEMBER? SELF VALUE))
   (CL:SETF (%THE-CONS-LIST SELF) (CONS VALUE (%THE-CONS-LIST SELF))))
  :VOID)

;;; (DEFMETHOD PUSH ...)

(CL:DEFMETHOD PUSH ((SELF SET) VALUE)
  "Add `value' to the front of set `self' unless it is already a member."
  (CL:WHEN (CL:NOT (MEMBER? SELF VALUE))
   (CL:SETF (%THE-CONS-LIST SELF) (CONS VALUE (%THE-CONS-LIST SELF))))
  :VOID)

;;; (DEFMETHOD INSERT-LAST ...)

(CL:DEFMETHOD INSERT-LAST ((SELF SET) VALUE)
  "Add `value' to the end of set `self' unless it is already a member."
  (CL:WHEN (CL:NOT (MEMBER? SELF VALUE))
   (CL:LET* ((CURSOR (%THE-CONS-LIST SELF)) (LASTCONS (CONS VALUE NIL)))
    (CL:IF (CL:EQ CURSOR NIL) (CL:SETF (%THE-CONS-LIST SELF) LASTCONS)
     (ADD-CONS-TO-END-OF-CONS-LIST CURSOR LASTCONS))))
  :VOID)

;;; (DEFMETHOD (REMOVE-DUPLICATES (LIKE SELF)) ...)

(CL:DEFMETHOD REMOVE-DUPLICATES ((SELF SET))
  (CL:RETURN-FROM REMOVE-DUPLICATES SELF))

;;; (DEFMETHOD (SUBSTITUTE (LIKE SELF)) ...)

(CL:DEFMETHOD SUBSTITUTE ((SELF SET) NEW OLD)
  "Destructively replace `old' with `new' in the set `self'
unless `new' is already a member."
  (CL:WHEN (CL:NOT (MEMBER? SELF NEW))
   (CL:SETF (%THE-CONS-LIST SELF) (SUBSTITUTE (%THE-CONS-LIST SELF) NEW OLD)))
  (CL:RETURN-FROM SUBSTITUTE SELF))

;;; (DEFMETHOD (CONCATENATE SET) ...)

(CL:DEFMETHOD CONCATENATE ((SET1 SET) SET2 CL:&REST OTHERSETS)
  "Union `set2' and all `otherSets' onto the end of `set1'.
The operation is destructive wrt `set1', but leaves all other sets intact.
The two mandatory parameters allow us to optimize the common binary case by
not relying on the somewhat less efficient variable arguments mechanism."
  (CL:LET* ((RESULTSET (%THE-CONS-LIST SET1)))
   (CL:LET* ((ELT NULL) (ITER-000 (%THE-CONS-LIST SET2)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ELT (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (MEMBER? RESULTSET ELT))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS ELT NIL))
        (CL:IF (CL:EQ RESULTSET NIL) (CL:SETQ RESULTSET COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST RESULTSET COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ELT NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:> (CL:LENGTH OTHERSETS) 0)
    (CL:LET* ((OSET NULL) (ITER-001 OTHERSETS))
     (CL:LOOP WHILE ITER-001 DO (CL:SETQ OSET (CL:POP ITER-001))
      (CL:LET*
       ((ELT NULL) (ITER-002 (%THE-CONS-LIST OSET)) (COLLECT-001 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:SETQ ELT (%%VALUE ITER-002))
        (CL:WHEN (CL:NOT (MEMBER? RESULTSET ELT))
         (CL:IF (CL:EQ COLLECT-001 NULL)
          (CL:PROGN (CL:SETQ COLLECT-001 (CONS ELT NIL))
           (CL:IF (CL:EQ RESULTSET NIL) (CL:SETQ RESULTSET COLLECT-001)
            (ADD-CONS-TO-END-OF-CONS-LIST RESULTSET COLLECT-001)))
          (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS ELT NIL))
           (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))
        (CL:SETQ ITER-002 (%%REST ITER-002)))))))
   (CL:SETF (%THE-CONS-LIST SET1) RESULTSET) (CL:RETURN-FROM CONCATENATE SET1)))

;;; (DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQUAL? ((X SET) Y)
  "Return TRUE iff `x' and `y' are SET's with equivalent members.
Uses `equal?' to test equality of elements.  This is more general than
`equivalent-sets?', since that only uses an `eql?' test."
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE Y) SGT-COLLECTIONS-STELLA-SET)
    (CL:PROGN
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:SETQ TEST-VALUE-000 (CL:= (LENGTH X) (LENGTH Y)))
      (CL:WHEN TEST-VALUE-000
       (CL:LET* ((ALWAYS?-000 CL:T))
        (CL:LET* ((ELTX NULL) (ITER-000 (ALLOCATE-ITERATOR X)))
         (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ ELTX (%VALUE ITER-000))
          (CL:LET* ((TEST-VALUE-001 CL:NIL))
           (CL:LET* ((FOUND?-000 CL:NIL))
            (CL:LET* ((ELTY NULL) (ITER-001 (ALLOCATE-ITERATOR Y)))
             (CL:LOOP WHILE (NEXT? ITER-001) DO
              (CL:SETQ ELTY (%VALUE ITER-001))
              (CL:WHEN (EQUAL? ELTX ELTY) (CL:SETQ FOUND?-000 CL:T)
               (CL:RETURN))))
            (CL:SETQ TEST-VALUE-001 FOUND?-000))
           (CL:SETQ TEST-VALUE-001 (CL:NOT TEST-VALUE-001))
           (CL:WHEN TEST-VALUE-001 (CL:SETQ ALWAYS?-000 CL:NIL)
            (CL:RETURN)))))
        (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
      (CL:LET* ((VALUE-000 TEST-VALUE-000))
       (CL:RETURN-FROM OBJECT-EQUAL? VALUE-000)))))
   (CL:T))
  (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))

;;; (DEFMETHOD (EQUAL-HASH-CODE INTEGER) ...)

(CL:DEFMETHOD EQUAL-HASH-CODE ((SELF SET))
  "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of elements of `self'."
  (CL:LET* ((CURSOR (%THE-CONS-LIST SELF)) (CODE 95880665))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CODE))
   (CL:LOOP (CL:WHEN (CL:EQ CURSOR NIL) (CL:RETURN))
    (CL:SETQ CODE
     (CL:THE CL:FIXNUM
      (CL:LOGXOR CODE
       (CL:THE CL:FIXNUM (SAFE-EQUAL-HASH-CODE (%%VALUE CURSOR))))))
    (CL:SETQ CURSOR (%%REST CURSOR)))
   (CL:RETURN-FROM EQUAL-HASH-CODE CODE)))

;;; (DEFUN (SET SET) ...)

(CL:DEFUN SET (CL:&REST VALUES)
  "Return a set containing `values', in order."
  (CL:LET* ((SET (NEW-SET)))
   (CL:LET* ((V NULL) (ITER-000 VALUES) (COLLECT-000 NULL))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ V (CL:POP ITER-000))
     (CL:WHEN (CL:NOT (MEMBER? SET V))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS V NIL))
        (CL:IF (CL:EQ (%THE-CONS-LIST SET) NIL)
         (CL:SETF (%THE-CONS-LIST SET) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST SET) COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS V NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:RETURN-FROM SET SET)))

;;; (DEFMETHOD PRINT-VECTOR ...)

(CL:DEFMETHOD PRINT-VECTOR ((SELF VECTOR) STREAM)
  (CL:IF (CL:= (LENGTH SELF) 0) (%%PRINT-STREAM STREAM "|i|[]")
   (CL:LET* ((I 0) (LIMIT 9)) (CL:DECLARE (CL:TYPE CL:FIXNUM I LIMIT))
    (%%PRINT-STREAM STREAM "|i|[")
    (CL:LET*
     ((ELEMENT NULL) (VECTOR-000 SELF) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:SETQ ELEMENT
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
      (%%PRINT-STREAM STREAM ELEMENT) (CL:SETQ I (CL:1+ I))
      (CL:WHEN (CL:> I LIMIT) (CL:RETURN))
      (CL:WHEN (CL:< I (LENGTH SELF)) (%%PRINT-STREAM STREAM " "))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
    (CL:IF (CL:OR (CL:<= I LIMIT) (CL:= I (LENGTH SELF)))
     (%%PRINT-STREAM STREAM "]") (%%PRINT-STREAM STREAM " ...]"))))
  :VOID)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF VECTOR))
  "Return `true' if `self' has length 0."
  (CL:RETURN-FROM EMPTY? (CL:= (%ARRAY-SIZE SELF) 0)))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF VECTOR))
  "Return `true' if `self' has length > 0."
  (CL:RETURN-FROM NON-EMPTY? (> (%ARRAY-SIZE SELF) 0)))

;;; (DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIRST ((SELF VECTOR))
  (CL:RETURN-FROM FIRST
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) 0)))

;;; (DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD SECOND ((SELF VECTOR))
  (CL:RETURN-FROM SECOND
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) 1)))

;;; (DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD THIRD ((SELF VECTOR))
  (CL:RETURN-FROM THIRD
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) 2)))

;;; (DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FOURTH ((SELF VECTOR))
  (CL:RETURN-FROM FOURTH
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) 3)))

;;; (DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIFTH ((SELF VECTOR))
  (CL:RETURN-FROM FIFTH
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) 4)))

;;; (DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH ((SELF VECTOR) POSITION)
  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
  #+MCL
  (CL:CHECK-TYPE POSITION CL:FIXNUM)
  (CL:RETURN-FROM NTH
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) POSITION)))

;;; (DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LAST ((SELF VECTOR))
  "Return the last item in the vector `self'."
  (CL:RETURN-FROM LAST
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF))
    (CL:THE CL:FIXNUM (CL:1- (%ARRAY-SIZE SELF))))))

;;; (DEFMETHOD (FIRST-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIRST-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM FIRST-SETTER
   (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (SECOND-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD SECOND-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM SECOND-SETTER
   (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (THIRD-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD THIRD-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM THIRD-SETTER
   (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION 2))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (FOURTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FOURTH-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM FOURTH-SETTER
   (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION 3))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (FIFTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIFTH-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM FIFTH-SETTER
   (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION 4))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH-SETTER ((SELF VECTOR) VALUE POSITION)
  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
  #+MCL
  (CL:CHECK-TYPE POSITION CL:FIXNUM)
  (CL:RETURN-FROM NTH-SETTER
   (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION POSITION))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (LAST-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LAST-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM LAST-SETTER
   (CL:LET
    ((SELF (%THE-ARRAY SELF)) (VALUE VALUE)
     (POSITION (CL:1- (%ARRAY-SIZE SELF))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF VECTOR))
  (CL:RETURN-FROM LENGTH (%ARRAY-SIZE SELF)))

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF VECTOR) OBJECT)
  (CL:LET* ((ARRAY (%THE-ARRAY SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR ARRAY))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- (LENGTH SELF))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:WHEN (EQL? (CL:AREF ARRAY I) OBJECT) (CL:RETURN-FROM MEMBER? CL:T))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:RETURN-FROM MEMBER? CL:NIL)))

;;; (DEFMETHOD (POSITION INTEGER) ...)

(CL:DEFMETHOD POSITION ((SELF VECTOR) OBJECT START)
  "Return the position of `object' within the vector
`self' (counting from zero); or return `null' if `object' does not occur within 
`self' (uses an `eql?' test).  If `start' was supplied as non-`null', only 
consider the portion starting at `start', however, the returned position 
will always be relative to the entire vector."
  (CL:DECLARE (CL:TYPE CL:FIXNUM START))
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  (CL:WHEN (NULL? START) (CL:SETQ START 0))
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 START) (UPPER-BOUND-000 (CL:1- (LENGTH SELF))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
   (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
    (CL:WHEN
     (EQL? (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) I) OBJECT)
     (CL:RETURN-FROM POSITION I))
    (CL:SETQ ITER-000 (CL:1+ ITER-000))))
  (CL:RETURN-FROM POSITION NULL-INTEGER))

;;; (DEFMETHOD (LAST-POSITION INTEGER) ...)

(CL:DEFMETHOD LAST-POSITION ((SELF VECTOR) OBJECT END)
  "Return the position of `object' within the vector
`self' (counting from zero); or return `null' if `object' does not occur within 
`self' (uses an `eql?' test).  If `end' was supplied as non-`null', only 
consider the portion ending at index `end', however, the returned position 
will always be relative to the entire vector."
  (CL:DECLARE (CL:TYPE CL:FIXNUM END))
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (CL:WHEN (NULL? END) (CL:SETQ END (CL:1- (LENGTH SELF))))
  (CL:LET* ((I NULL-INTEGER) (ITER-000 (REVERSE (INTERVAL 0 END))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ I (%VALUE ITER-000))
    (CL:WHEN
     (EQL? (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) I) OBJECT)
     (CL:RETURN-FROM LAST-POSITION I))))
  (CL:RETURN-FROM LAST-POSITION NULL-INTEGER))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF VECTOR) OFFSET VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:WHEN (CL:>= OFFSET (%ARRAY-SIZE SELF))
   (CL:ERROR (NEW-STELLA-EXCEPTION "Out-of-bounds array access")))
  (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION OFFSET))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
   (CL:SETF (CL:AREF SELF POSITION) VALUE))
  :VOID)

;;; (DEFMETHOD (COPY (VECTOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD COPY ((SELF VECTOR))
  "Return a copy of the vector `self'."
  (CL:LET*
   ((SIZE (%ARRAY-SIZE SELF)) (SOURCEARRAY (%THE-ARRAY SELF))
    (COPY (NEW-VECTOR SIZE)) (COPYARRAY (%THE-ARRAY COPY)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE)
    (CL:TYPE CL:SIMPLE-VECTOR SOURCEARRAY COPYARRAY))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- SIZE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:LET ((SELF COPYARRAY) (VALUE (CL:AREF SOURCEARRAY I)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:RETURN-FROM COPY COPY)))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF VECTOR))
  (CL:LET* ((SIZE (%ARRAY-SIZE SELF)) (ARRAY (%THE-ARRAY SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE) (CL:TYPE CL:SIMPLE-VECTOR ARRAY))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- SIZE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:LET ((SELF ARRAY) (VALUE NULL) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
  :VOID)

;;; (DEFUN (VECTOR VECTOR) ...)

(CL:DEFUN VECTOR (CL:&REST VALUES)
  "Return a vector containing `values', in order."
  (CL:LET* ((VECTOR (NEW-VECTOR (CL:LENGTH VALUES))))
   (CL:LET* ((V NULL) (ITER-000 VALUES) (I NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ V (CL:POP ITER-000))
     (CL:SETQ I ITER-001)
     (CL:LET ((SELF (%THE-ARRAY VECTOR)) (VALUE V) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:RETURN-FROM VECTOR VECTOR)))

;;; (DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQUAL? ((X VECTOR) Y)
  "Return TRUE iff the vectors `x' and `y' are structurally
equivalent.  Uses `equal?' to test equality of elements."
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE Y) SGT-COLLECTIONS-STELLA-VECTOR)
    (CL:PROGN
     (CL:WHEN (CL:= (%ARRAY-SIZE X) (%ARRAY-SIZE Y))
      (CL:LET*
       ((ELTX NULL) (VECTOR-000 X) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)) (ELTY NULL) (VECTOR-001 Y)
        (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
        (CL:SETQ ELTX
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ ELTY
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:WHEN (CL:NOT (EQUAL? ELTX ELTY))
         (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      (CL:RETURN-FROM OBJECT-EQUAL? CL:T))))
   (CL:T))
  (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))

;;; (DEFMETHOD (EQUAL-HASH-CODE INTEGER) ...)

(CL:DEFMETHOD EQUAL-HASH-CODE ((SELF VECTOR))
  "Return an `equal?' hash code for `self'."
  (CL:LET* ((CURSOR (LENGTH SELF)) (CODE 66435053))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR CODE))
   (CL:LOOP
    (CL:IF (CL:= CURSOR 0) (CL:RETURN) (CL:SETQ CURSOR (CL:1- CURSOR)))
    (CL:SETQ CODE
     (CL:THE CL:FIXNUM
      (CL:LOGXOR CODE
       (CL:THE CL:FIXNUM
        (SAFE-EQUAL-HASH-CODE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) CURSOR))))))
    (CL:SETQ CODE
     (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND CODE 1)) 0)
      (CL:LET ((ARG CODE)) (CL:DECLARE (CL:TYPE CL:FIXNUM ARG))
       (CL:THE CL:FIXNUM
        (CL:LOGAND (CL:THE CL:FIXNUM (CL:ASH ARG -1))
         *INTEGER-UNSIGNED-BITS-MASK*)))
      (CL:THE CL:FIXNUM
       (CL:LOGIOR
        (CL:THE CL:FIXNUM
         (CL:LET ((ARG CODE) (COUNT 1))
          (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
          (CL:THE CL:FIXNUM (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))
        *INTEGER-MSB-MASK*)))))
   (CL:RETURN-FROM EQUAL-HASH-CODE CODE)))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-VECTOR) OFFSET VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:WHEN (CL:>= OFFSET (%ARRAY-SIZE SELF))
   (CL:LET* ((SIZE (%ARRAY-SIZE SELF))) (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
    (CL:LOOP WHILE (CL:>= OFFSET SIZE) DO (CL:SETQ SIZE (CL:* 2 SIZE)))
    (RESIZE-VECTOR SELF SIZE)))
  (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION OFFSET))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
   (CL:SETF (CL:AREF SELF POSITION) VALUE))
  :VOID)

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-SYMBOL-ARRAY) OFFSET VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:WHEN (CL:>= OFFSET (%ARRAY-SIZE SELF))
   (CL:LET* ((SIZE (%ARRAY-SIZE SELF))) (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
    (CL:LOOP WHILE (CL:>= OFFSET SIZE) DO (CL:SETQ SIZE (CL:* 2 SIZE)))
    (RESIZE-VECTOR SELF SIZE)))
  (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION OFFSET))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
   (CL:SETF (CL:AREF SELF POSITION) VALUE))
  (CL:WHEN (CL:> OFFSET (%TOP-SYMBOL-OFFSET SELF))
   (CL:SETF (%TOP-SYMBOL-OFFSET SELF) OFFSET))
  :VOID)

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF VECTOR-SEQUENCE) VALUE)
  "Append `value' to the END of the sequence `self'.  
Resize the array if necessary."
  (CL:LET* ((OLDLENGTH (%SEQUENCE-LENGTH SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OLDLENGTH))
   (CL:WHEN (CL:= OLDLENGTH (%ARRAY-SIZE SELF))
    (RESIZE-VECTOR SELF (CL:+ (%ARRAY-SIZE SELF) (RESIZE-INCREMENT SELF))))
   (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION OLDLENGTH))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%SEQUENCE-LENGTH SELF) (CL:1+ OLDLENGTH)))
  :VOID)

;;; (DEFMETHOD (REMOVE VECTOR-SEQUENCE) ...)

(CL:DEFMETHOD REMOVE ((SELF VECTOR-SEQUENCE) VALUE)
  "Remove `value' from the sequence `self', and left shift
the values after it to close the gap."
  (CL:LET*
   ((ARRAY (%THE-ARRAY SELF)) (FIRSTSHIFTOFFSET -1)
    (LASTSHIFTOFFSET (CL:1- (%SEQUENCE-LENGTH SELF))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR ARRAY)
    (CL:TYPE CL:FIXNUM FIRSTSHIFTOFFSET LASTSHIFTOFFSET))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 LASTSHIFTOFFSET)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000)
     (CL:WHEN (EQL? (CL:AREF ARRAY I) VALUE)
      (CL:SETQ FIRSTSHIFTOFFSET (CL:1+ I)) (CL:RETURN))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:WHEN (CL:= FIRSTSHIFTOFFSET -1) (CL:RETURN-FROM REMOVE SELF))
   (CL:WHEN (CL:<= FIRSTSHIFTOFFSET LASTSHIFTOFFSET)
    (CL:LET*
     ((J NULL-INTEGER) (ITER-001 FIRSTSHIFTOFFSET)
      (UPPER-BOUND-001 LASTSHIFTOFFSET)
      (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM J ITER-001 UPPER-BOUND-001))
     (CL:LOOP WHILE (CL:OR UNBOUNDED?-001 (CL:<= ITER-001 UPPER-BOUND-001)) DO
      (CL:SETQ J ITER-001)
      (CL:LET ((SELF ARRAY) (VALUE (CL:AREF ARRAY J)) (POSITION (CL:1- J)))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ ITER-001 (CL:1+ ITER-001)))))
   (CL:LET ((SELF ARRAY) (VALUE NULL) (POSITION LASTSHIFTOFFSET))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%SEQUENCE-LENGTH SELF) LASTSHIFTOFFSET)
   (CL:RETURN-FROM REMOVE SELF)))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF VECTOR-SEQUENCE))
  (CL:RETURN-FROM LENGTH (%SEQUENCE-LENGTH SELF)))

;;; (DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF VECTOR))
  (CL:LET* ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ITERATOR-OBJECT ITERATOR) SELF)
   (CL:SETF (%ITERATOR-INTEGER ITERATOR) 0)
   (CL:SETF (%ITERATOR-SECOND-INTEGER ITERATOR) (%ARRAY-SIZE SELF))
   (CL:SETF (%ITERATOR-NEXT-CODE ITERATOR) (CL:FUNCTION VECTOR-NEXT?))
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR)))

;;; (DEFUN (VECTOR-NEXT? BOOLEAN) ...)

(CL:DEFUN VECTOR-NEXT? (SELF)
  (CL:LET* ((CURSOR (%ITERATOR-INTEGER SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR))
   (CL:WHEN (CL:< CURSOR (%ITERATOR-SECOND-INTEGER SELF))
    (CL:SETF (%VALUE SELF)
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ITERATOR-OBJECT SELF)))
      CURSOR))
    (CL:SETF (%ITERATOR-INTEGER SELF) (CL:1+ CURSOR))
    (CL:RETURN-FROM VECTOR-NEXT? CL:T))
   (CL:RETURN-FROM VECTOR-NEXT? CL:NIL)))

;;; (DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD BUT-LAST ((SELF VECTOR))
  "Generate all but the last element of the vector `self'."
  (CL:LET* ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ITERATOR-OBJECT ITERATOR) SELF)
   (CL:SETF (%ITERATOR-INTEGER ITERATOR) 0)
   (CL:SETF (%ITERATOR-SECOND-INTEGER ITERATOR) (CL:1- (%ARRAY-SIZE SELF)))
   (CL:SETF (%ITERATOR-NEXT-CODE ITERATOR) (CL:FUNCTION VECTOR-NEXT?))
   (CL:RETURN-FROM BUT-LAST ITERATOR)))

;;; (DEFGLOBAL *USE-STELLA-HASH-TABLES?* ...)

(CL:DEFVAR *USE-STELLA-HASH-TABLES?* CL-USER::*use-stella-hash-tables?*)

;;; (DEFCLASS STELLA-HASH-TABLE ...)

(CL:DEFCLASS STELLA-HASH-TABLE (ABSTRACT-HASH-TABLE)
  ((THE-TABLE :ALLOCATION :INSTANCE :ACCESSOR %THE-TABLE)
   (SIZE :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %SIZE)
   (INITIAL-SIZE :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :DOCUMENTATION
    "If supplied, the initial hash table
will be sized to hold at least that many elements." :ALLOCATION :INSTANCE
    :ACCESSOR %INITIAL-SIZE)
   (FREE-ELEMENTS :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %FREE-ELEMENTS)
   (EQUAL-TEST? :DOCUMENTATION "If true use `equal?' as the
equality test and `equal-hash-code' as the hash function, otherwise,
use `eql?' and `hash-code' (the default)." :ALLOCATION :INSTANCE :ACCESSOR
    %EQUAL-TEST?)))

(CL:DEFUN NEW-STELLA-HASH-TABLE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STELLA-HASH-TABLE)))
   (CL:SETF (%THE-STELLA-HASH-TABLE SELF) NULL)
   (CL:SETF (%THE-HASH-TABLE SELF) NULL) (CL:SETF (%EQUAL-TEST? SELF) CL:NIL)
   (CL:SETF (%FREE-ELEMENTS SELF) NULL-INTEGER)
   (CL:SETF (%INITIAL-SIZE SELF) 50) (CL:SETF (%SIZE SELF) NULL-INTEGER)
   (CL:SETF (%THE-TABLE SELF) STELLA::NULL-1D-ARRAY)
   (INITIALIZE-HASH-TABLE SELF) (CL:RETURN-FROM NEW-STELLA-HASH-TABLE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STELLA-HASH-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-COLLECTIONS-STELLA-STELLA-HASH-TABLE))

(CL:DEFUN ACCESS-STELLA-HASH-TABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-SIZE)
    (CL:IF SETVALUE? (CL:SETF (%SIZE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%SIZE SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-INITIAL-SIZE)
    (CL:IF SETVALUE? (CL:SETF (%INITIAL-SIZE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%INITIAL-SIZE SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-FREE-ELEMENTS)
    (CL:IF SETVALUE? (CL:SETF (%FREE-ELEMENTS SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%FREE-ELEMENTS SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-EQUAL-TEST?)
    (CL:IF SETVALUE?
     (CL:SETF (%EQUAL-TEST? SELF) (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE (CL:IF (%EQUAL-TEST? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-STELLA-HASH-TABLE-SLOT-VALUE VALUE))

;;; (DEFGLOBAL *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH* ...)

(CL:DEFVAR *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH* 1.0d0)
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH*))

;;; (DEFUN INITIALIZE-STELLA-HASH-TABLE ...)

(CL:DEFUN INITIALIZE-STELLA-HASH-TABLE (SELF)
  (CL:LET*
   ((SIZE
     (PICK-HASH-TABLE-SIZE-PRIME
      (FLOOR
       (CL:/ (%INITIAL-SIZE SELF) *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH*))))
    (TABLE (CL:MAKE-ARRAY SIZE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE) (CL:TYPE CL:SIMPLE-VECTOR TABLE))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- SIZE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:SETF (CL:AREF TABLE I) NULL) (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETF (%THE-TABLE SELF) TABLE) (CL:SETF (%SIZE SELF) SIZE)
   (CL:SETF (%FREE-ELEMENTS SELF)
    (FLOOR (CL:* SIZE *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH*))))
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STELLA-HASH-TABLE))
  "Initialize the STELLA hash table `self'.  This is a
no-op and primarily exists to shadow the standard initializer inherited
from ABSTRACT-HASH-TABLE.  STELLA hash tables are initialized at the
first insertion operation."
  :VOID)

;;; (DEFUN REHASH-STELLA-HASH-TABLE ...)

(CL:DEFUN REHASH-STELLA-HASH-TABLE (SELF NEWSIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NEWSIZE))
  #+MCL
  (CL:CHECK-TYPE NEWSIZE CL:FIXNUM)
  (CL:WHEN (NULL-ARRAY? (%THE-TABLE SELF)) (INITIALIZE-STELLA-HASH-TABLE SELF)
   (CL:RETURN-FROM REHASH-STELLA-HASH-TABLE))
  (CL:LET*
   ((SIZE (%SIZE SELF)) (TABLE (%THE-TABLE SELF))
    (NEWTABLE (CL:MAKE-ARRAY NEWSIZE)) (NEWBUCKETINDEX 0) (NEWBUCKET NULL)
    (CURSOR NULL) (CURRENT NULL) (EQUALTEST? (%EQUAL-TEST? SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE NEWBUCKETINDEX)
    (CL:TYPE CL:SIMPLE-VECTOR TABLE NEWTABLE))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- NEWSIZE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:SETF (CL:AREF NEWTABLE I) NULL) (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET* ((I NULL-INTEGER) (ITER-001 0) (UPPER-BOUND-001 (CL:1- SIZE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO (CL:SETQ I ITER-001)
     (CL:SETQ CURSOR (CL:AREF TABLE I))
     (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
      (CL:IF EQUALTEST?
       (CL:SETQ NEWBUCKETINDEX
        (CL:LET ((CODE (EQUAL-HASH-CODE (%KEY CURSOR))) (SIZE NEWSIZE))
         (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
         (CL:THE CL:FIXNUM
          (CL:REM
           (CL:THE CL:FIXNUM (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
           SIZE))))
       (CL:SETQ NEWBUCKETINDEX
        (CL:LET ((CODE (HASH-CODE (%KEY CURSOR))) (SIZE NEWSIZE))
         (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
         (CL:THE CL:FIXNUM
          (CL:REM
           (CL:THE CL:FIXNUM (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
           SIZE)))))
      (CL:SETQ NEWBUCKET (CL:AREF NEWTABLE NEWBUCKETINDEX))
      (CL:SETQ CURRENT CURSOR) (CL:SETQ CURSOR (%REST CURSOR))
      (CL:COND
       ((CL:NOT (CL:EQ NEWBUCKET NULL))
        (CL:SETF (%REST CURRENT) (%REST NEWBUCKET))
        (CL:SETF (%REST NEWBUCKET) CURRENT))
       (CL:T (CL:SETF (CL:AREF NEWTABLE NEWBUCKETINDEX) CURRENT)
        (CL:SETF (%REST CURRENT) NULL))))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:SETF (%THE-TABLE SELF) NEWTABLE) (CL:SETF (%SIZE SELF) NEWSIZE)
   (CL:SETF (%FREE-ELEMENTS SELF)
    (MAX
     (CL:+ (%FREE-ELEMENTS SELF)
      (FLOOR
       (CL:* (CL:- NEWSIZE SIZE) *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH*)))
     0)))
  :VOID)

;;; (DEFUN STELLA-HASH-TABLE-INSERT-AT ...)

(CL:DEFUN STELLA-HASH-TABLE-INSERT-AT (SELF KEY VALUE)
  (CL:LET*
   ((TABLE (%THE-TABLE SELF)) (FREE (%FREE-ELEMENTS SELF)) (BUCKETINDEX 0)
    (BUCKET NULL) (EQUALTEST? (%EQUAL-TEST? SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE)
    (CL:TYPE CL:FIXNUM FREE BUCKETINDEX))
   (CL:WHEN (NULL-ARRAY? TABLE) (INITIALIZE-STELLA-HASH-TABLE SELF)
    (CL:SETQ TABLE (%THE-TABLE SELF)) (CL:SETQ FREE (%FREE-ELEMENTS SELF)))
   (CL:WHEN (CL:= FREE 0)
    (REHASH-STELLA-HASH-TABLE SELF
     (PICK-HASH-TABLE-SIZE-PRIME (CL:1+ (%SIZE SELF))))
    (CL:SETQ TABLE (%THE-TABLE SELF)) (CL:SETQ FREE (%FREE-ELEMENTS SELF)))
   (CL:IF EQUALTEST?
    (CL:SETQ BUCKETINDEX
     (CL:LET ((CODE (EQUAL-HASH-CODE KEY)) (SIZE (%SIZE SELF)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
      (CL:THE CL:FIXNUM
       (CL:REM
        (CL:THE CL:FIXNUM (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
        SIZE))))
    (CL:SETQ BUCKETINDEX
     (CL:LET ((CODE (HASH-CODE KEY)) (SIZE (%SIZE SELF)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
      (CL:THE CL:FIXNUM
       (CL:REM
        (CL:THE CL:FIXNUM (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
        SIZE)))))
   (CL:SETQ BUCKET (CL:AREF TABLE BUCKETINDEX))
   (CL:COND
    ((CL:EQ BUCKET NULL)
     (CL:LET* ((SELF-000 (NEW-KV-CONS))) (CL:SETF (%KEY SELF-000) KEY)
      (CL:SETF (%VALUE SELF-000) VALUE)
      (CL:SETF (CL:AREF TABLE BUCKETINDEX) SELF-000))
     (CL:SETF (%FREE-ELEMENTS SELF) (CL:1- FREE)))
    (CL:T
     (CL:LET* ((CURSOR BUCKET))
      (CL:COND
       (EQUALTEST?
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ CURSOR NULL))
          (CL:NOT (EQUAL? (%KEY CURSOR) KEY)))
         DO (CL:SETQ CURSOR (%REST CURSOR))))
       (CL:T
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ CURSOR NULL))
          (CL:NOT (EQL? (%KEY CURSOR) KEY)))
         DO (CL:SETQ CURSOR (%REST CURSOR)))))
      (CL:COND ((CL:NOT (CL:EQ CURSOR NULL)) (CL:SETF (%VALUE CURSOR) VALUE))
       (CL:T
        (CL:LET* ((SELF-001 (NEW-KV-CONS))) (CL:SETF (%KEY SELF-001) KEY)
         (CL:SETF (%VALUE SELF-001) VALUE)
         (CL:SETF (%REST SELF-001) (%REST BUCKET))
         (CL:SETF (%REST BUCKET) SELF-001))
        (CL:SETF (%FREE-ELEMENTS SELF) (CL:1- FREE))))))))
  :VOID)

;;; (DEFUN STELLA-HASH-TABLE-REMOVE-AT ...)

(CL:DEFUN STELLA-HASH-TABLE-REMOVE-AT (SELF KEY)
  (CL:LET*
   ((TABLE (%THE-TABLE SELF)) (BUCKETINDEX 0) (BUCKET NULL)
    (EQUALTEST? (%EQUAL-TEST? SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE)
    (CL:TYPE CL:FIXNUM BUCKETINDEX))
   (CL:WHEN (NULL-ARRAY? TABLE) (CL:RETURN-FROM STELLA-HASH-TABLE-REMOVE-AT))
   (CL:IF EQUALTEST?
    (CL:SETQ BUCKETINDEX
     (CL:LET ((CODE (EQUAL-HASH-CODE KEY)) (SIZE (%SIZE SELF)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
      (CL:THE CL:FIXNUM
       (CL:REM
        (CL:THE CL:FIXNUM (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
        SIZE))))
    (CL:SETQ BUCKETINDEX
     (CL:LET ((CODE (HASH-CODE KEY)) (SIZE (%SIZE SELF)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
      (CL:THE CL:FIXNUM
       (CL:REM
        (CL:THE CL:FIXNUM (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
        SIZE)))))
   (CL:SETQ BUCKET (CL:AREF TABLE BUCKETINDEX))
   (CL:COND ((CL:EQ BUCKET NULL) (CL:RETURN-FROM STELLA-HASH-TABLE-REMOVE-AT))
    ((CL:AND (CL:NOT EQUALTEST?) (EQL? (%KEY BUCKET) KEY))
     (CL:SETF (CL:AREF TABLE BUCKETINDEX) (%REST BUCKET))
     (CL:SETF (%FREE-ELEMENTS SELF) (CL:1+ (%FREE-ELEMENTS SELF)))
     (CL:RETURN-FROM STELLA-HASH-TABLE-REMOVE-AT))
    ((CL:AND EQUALTEST? (EQUAL? (%KEY BUCKET) KEY))
     (CL:SETF (CL:AREF TABLE BUCKETINDEX) (%REST BUCKET))
     (CL:SETF (%FREE-ELEMENTS SELF) (CL:1+ (%FREE-ELEMENTS SELF)))
     (CL:RETURN-FROM STELLA-HASH-TABLE-REMOVE-AT))
    (CL:T
     (CL:LET* ((TRAILER BUCKET)) (CL:SETQ BUCKET (%REST BUCKET))
      (CL:LOOP WHILE (CL:NOT (CL:EQ BUCKET NULL)) DO
       (CL:COND
        ((CL:AND (CL:NOT EQUALTEST?) (EQL? (%KEY BUCKET) KEY))
         (CL:SETF (%REST TRAILER) (%REST BUCKET))
         (CL:SETF (%FREE-ELEMENTS SELF) (CL:1+ (%FREE-ELEMENTS SELF)))
         (CL:RETURN-FROM STELLA-HASH-TABLE-REMOVE-AT))
        ((CL:AND EQUALTEST? (EQUAL? (%KEY BUCKET) KEY))
         (CL:SETF (%REST TRAILER) (%REST BUCKET))
         (CL:SETF (%FREE-ELEMENTS SELF) (CL:1+ (%FREE-ELEMENTS SELF)))
         (CL:RETURN-FROM STELLA-HASH-TABLE-REMOVE-AT))
        (CL:T (CL:SETQ TRAILER BUCKET) (CL:SETQ BUCKET (%REST BUCKET)))))))))
  :VOID)

;;; (DEFUN (STELLA-HASH-TABLE-LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFUN STELLA-HASH-TABLE-LOOKUP (SELF KEY)
  (CL:LET* ((TABLE (%THE-TABLE SELF)) (BUCKET NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE))
   (CL:WHEN (NULL-ARRAY? TABLE)
    (CL:RETURN-FROM STELLA-HASH-TABLE-LOOKUP NULL))
   (CL:COND
    ((%EQUAL-TEST? SELF)
     (CL:SETQ BUCKET
      (CL:AREF TABLE
       (CL:THE CL:FIXNUM
        (CL:LET ((CODE (EQUAL-HASH-CODE KEY)) (SIZE (%SIZE SELF)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
         (CL:THE CL:FIXNUM
          (CL:REM
           (CL:THE CL:FIXNUM (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
           SIZE))))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ BUCKET NULL)) DO
      (CL:IF (EQUAL? (%KEY BUCKET) KEY)
       (CL:RETURN-FROM STELLA-HASH-TABLE-LOOKUP (%VALUE BUCKET))
       (CL:SETQ BUCKET (%REST BUCKET)))))
    (CL:T
     (CL:SETQ BUCKET
      (CL:AREF TABLE
       (CL:THE CL:FIXNUM
        (CL:LET ((CODE (HASH-CODE KEY)) (SIZE (%SIZE SELF)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
         (CL:THE CL:FIXNUM
          (CL:REM
           (CL:THE CL:FIXNUM (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
           SIZE))))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ BUCKET NULL)) DO
      (CL:IF (EQL? (%KEY BUCKET) KEY)
       (CL:RETURN-FROM STELLA-HASH-TABLE-LOOKUP (%VALUE BUCKET))
       (CL:SETQ BUCKET (%REST BUCKET))))))
   (CL:RETURN-FROM STELLA-HASH-TABLE-LOOKUP NULL)))

;;; (DEFUN (STELLA-STRING-HASH-TABLE-LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFUN STELLA-STRING-HASH-TABLE-LOOKUP (SELF KEY)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
  #+MCL
  (CL:CHECK-TYPE KEY CL:SIMPLE-STRING)
  (CL:LET* ((TABLE (%THE-TABLE SELF)) (BUCKET NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE))
   (CL:WHEN (NULL-ARRAY? TABLE)
    (CL:RETURN-FROM STELLA-STRING-HASH-TABLE-LOOKUP NULL))
   (CL:SETQ BUCKET
    (CL:AREF TABLE
     (CL:THE CL:FIXNUM
      (CL:LET ((CODE (CL:THE CL:FIXNUM (CL:SXHASH KEY))) (SIZE (%SIZE SELF)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
       (CL:THE CL:FIXNUM
        (CL:REM
         (CL:THE CL:FIXNUM (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
         SIZE))))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ BUCKET NULL)) DO
    (CL:IF (STRING-EQL? (%WRAPPER-VALUE (%KEY BUCKET)) KEY)
     (CL:RETURN-FROM STELLA-STRING-HASH-TABLE-LOOKUP (%VALUE BUCKET))
     (CL:SETQ BUCKET (%REST BUCKET))))
   (CL:RETURN-FROM STELLA-STRING-HASH-TABLE-LOOKUP NULL)))

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF STELLA-HASH-TABLE) KEY)
  "Lookup the entry identified by `key' in `self' and
return its value, or NULL if no such entry exists.    Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:RETURN-FROM LOOKUP (STELLA-HASH-TABLE-LOOKUP SELF KEY)))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF STELLA-HASH-TABLE) KEY VALUE)
  "Set the value of the entry identified by `key' in `self'
to `value' or add a new entry if no entry with `key' exists yet.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (STELLA-HASH-TABLE-INSERT-AT SELF KEY VALUE)
  (CL:RETURN-FROM INSERT-AT)
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF STELLA-HASH-TABLE) KEY)
  "Remove the entry identified by `key' from `self'.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (STELLA-HASH-TABLE-REMOVE-AT SELF KEY)
  (CL:RETURN-FROM REMOVE-AT)
  :VOID)

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF STELLA-HASH-TABLE))
  "Return the number of entries in `self'."
  (CL:IF (NULL-ARRAY? (%THE-TABLE SELF)) (CL:RETURN-FROM LENGTH 0)
   (CL:RETURN-FROM LENGTH (CL:- (%SIZE SELF) (%FREE-ELEMENTS SELF)))))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF STELLA-HASH-TABLE))
  "Return TRUE if `self' has zero entries."
  (CL:RETURN-FROM EMPTY? (CL:= (LENGTH SELF) 0)))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF STELLA-HASH-TABLE))
  "Return TRUE if `self' has at least 1 entry."
  (CL:RETURN-FROM NON-EMPTY? (> (LENGTH SELF) 0)))

;;; (DEFMETHOD (COPY (LIKE SELF)) ...)

(CL:DEFMETHOD COPY ((SELF STELLA-HASH-TABLE))
  "Return a copy of the hash table `self'.  The bucket table
and buckets are freshly allocated, however, the keys and values of entries
are not copied themselves (similar to what we do for lists, etc.)."
  (CL:LET* ((SIZE (%SIZE SELF))) (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
   (CL:LET* ((SELF-000 (NEW-STELLA-HASH-TABLE)))
    (CL:SETF (%SIZE SELF-000) SIZE)
    (CL:SETF (%INITIAL-SIZE SELF-000) (%INITIAL-SIZE SELF))
    (CL:SETF (%FREE-ELEMENTS SELF-000) (%FREE-ELEMENTS SELF))
    (CL:SETF (%EQUAL-TEST? SELF-000) (%EQUAL-TEST? SELF))
    (CL:LET*
     ((COPY SELF-000) (TABLE (%THE-TABLE SELF)) (TABLECOPY TABLE)
      (BUCKET NULL))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE TABLECOPY))
     (CL:WHEN (CL:NOT (NULL-ARRAY? TABLE))
      (CL:SETQ TABLECOPY (CL:MAKE-ARRAY SIZE))
      (CL:SETF (%THE-TABLE COPY) TABLECOPY)
      (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- SIZE)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
       (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
        (CL:SETQ BUCKET (CL:AREF TABLE I))
        (CL:IF (CL:NOT (CL:EQ BUCKET NULL))
         (CL:SETF (CL:AREF TABLECOPY I) (COPY-KV-CONS-LIST BUCKET))
         (CL:SETF (CL:AREF TABLECOPY I) NULL))
        (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
     (CL:RETURN-FROM COPY COPY)))))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF STELLA-HASH-TABLE))
  "Remove all entries from `self'.  This will result in a
re-initialization of the table upon the first insertion into `self'."
  (CL:SETF (%THE-TABLE SELF) STELLA::NULL-1D-ARRAY)
  (CL:SETF (%SIZE SELF) NULL-INTEGER)
  (CL:SETF (%FREE-ELEMENTS SELF) NULL-INTEGER)
  :VOID)

;;; (DEFMETHOD (CONSIFY (CONS OF CONS)) ...)

(CL:DEFMETHOD CONSIFY ((SELF STELLA-HASH-TABLE))
  "Collect all entries of `self' into a cons list of
`(<key> <value>)' pairs and return the result."
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR SELF))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ KEY (%KEY ITER-000))
     (CL:SETQ VALUE (%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (CONS KEY (CONS VALUE NIL)) NIL))
       (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000) (CONS (CONS KEY (CONS VALUE NIL)) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:RETURN-FROM CONSIFY RESULT)))

;;; (DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQUAL? ((X STELLA-HASH-TABLE) Y)
  "Return TRUE if `x' and `y' represent the same set of key/value pairs."
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE Y)
     SGT-COLLECTIONS-STELLA-STELLA-HASH-TABLE)
    (CL:PROGN
     (CL:WHEN (CL:= (LENGTH X) (LENGTH Y))
      (CL:LET* ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR X)))
       (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ KEY (%KEY ITER-000))
        (CL:SETQ VALUE (%VALUE ITER-000))
        (CL:WHEN (CL:NOT (EQUAL? VALUE (LOOKUP Y KEY)))
         (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))))
      (CL:RETURN-FROM OBJECT-EQUAL? CL:T))))
   (CL:T))
  (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))

;;; (DEFMETHOD (EQUAL-HASH-CODE INTEGER) ...)

(CL:DEFMETHOD EQUAL-HASH-CODE ((SELF STELLA-HASH-TABLE))
  "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of entries of `self'."
  (CL:LET* ((CODE 36273463)) (CL:DECLARE (CL:TYPE CL:FIXNUM CODE))
   (CL:LET* ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ KEY (%KEY ITER-000))
     (CL:SETQ VALUE (%VALUE ITER-000))
     (CL:SETQ CODE
      (CL:THE CL:FIXNUM
       (CL:LOGXOR CODE (CL:THE CL:FIXNUM (EQUAL-HASH-CODE KEY)))))
     (CL:SETQ CODE
      (CL:THE CL:FIXNUM
       (CL:LOGXOR CODE (CL:THE CL:FIXNUM (EQUAL-HASH-CODE VALUE)))))))
   (CL:RETURN-FROM EQUAL-HASH-CODE CODE)))

;;; (DEFCLASS STELLA-HASH-TABLE-ITERATOR ...)

(CL:DEFCLASS STELLA-HASH-TABLE-ITERATOR (DICTIONARY-ITERATOR)
  ((SIZE :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %SIZE)
   (BUCKET-TABLE :ALLOCATION :INSTANCE :ACCESSOR %BUCKET-TABLE)
   (BUCKET-INDEX :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %BUCKET-INDEX)
   (BUCKET-CURSOR :ALLOCATION :INSTANCE :ACCESSOR %BUCKET-CURSOR))
  (:DOCUMENTATION "Iterator class for STELLA-HASH-TABLE's.  The only modifying
operations allowed during iteration are removal of the current element or
changing its value.  All other removal or insertion operations might lead
to corruption or undefined results."))

(CL:DEFUN NEW-STELLA-HASH-TABLE-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STELLA-HASH-TABLE-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%KEY SELF) NULL) (CL:SETF (%BUCKET-CURSOR SELF) NULL)
   (CL:SETF (%BUCKET-INDEX SELF) 0)
   (CL:SETF (%BUCKET-TABLE SELF) STELLA::NULL-1D-ARRAY)
   (CL:SETF (%SIZE SELF) NULL-INTEGER)
   (CL:RETURN-FROM NEW-STELLA-HASH-TABLE-ITERATOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STELLA-HASH-TABLE-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-COLLECTIONS-STELLA-STELLA-HASH-TABLE-ITERATOR))

(CL:DEFUN ACCESS-STELLA-HASH-TABLE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-SIZE)
    (CL:IF SETVALUE? (CL:SETF (%SIZE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%SIZE SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-BUCKET-INDEX)
    (CL:IF SETVALUE? (CL:SETF (%BUCKET-INDEX SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%BUCKET-INDEX SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-BUCKET-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%BUCKET-CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%BUCKET-CURSOR SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-STELLA-HASH-TABLE-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFMETHOD (ALLOCATE-ITERATOR (STELLA-HASH-TABLE-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF STELLA-HASH-TABLE))
  "Allocate an iterator for `self'."
  (CL:LET* ((SELF-000 (NEW-STELLA-HASH-TABLE-ITERATOR)))
   (CL:SETF (%SIZE SELF-000) (%SIZE SELF))
   (CL:SETF (%BUCKET-TABLE SELF-000) (%THE-TABLE SELF))
   (CL:SETF (%BUCKET-INDEX SELF-000) 0)
   (CL:SETF (%BUCKET-CURSOR SELF-000) NULL)
   (CL:LET* ((VALUE-000 SELF-000))
    (CL:RETURN-FROM ALLOCATE-ITERATOR VALUE-000))))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF STELLA-HASH-TABLE-ITERATOR))
  (CL:LET* ((CURSOR (%BUCKET-CURSOR SELF)))
   (CL:COND
    ((%FIRST-ITERATION? SELF) (CL:SETF (%FIRST-ITERATION? SELF) CL:NIL))
    ((CL:NOT (CL:EQ CURSOR NULL)) (CL:SETQ CURSOR (%REST CURSOR))))
   (CL:WHEN (CL:EQ CURSOR NULL)
    (CL:LET*
     ((TABLE (%BUCKET-TABLE SELF)) (INDEX (%BUCKET-INDEX SELF))
      (SIZE (%SIZE SELF)))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE)
      (CL:TYPE CL:FIXNUM INDEX SIZE))
     (CL:WHEN (NULL-ARRAY? TABLE) (CL:RETURN-FROM NEXT? CL:NIL))
     (CL:LOOP WHILE (CL:AND (CL:EQ CURSOR NULL) (CL:< INDEX SIZE)) DO
      (CL:SETQ CURSOR (CL:AREF TABLE INDEX)) (CL:SETQ INDEX (CL:1+ INDEX)))
     (CL:SETF (%BUCKET-INDEX SELF) INDEX)
     (CL:SETF (%BUCKET-CURSOR SELF) CURSOR)))
   (CL:COND
    ((CL:NOT (CL:EQ CURSOR NULL)) (CL:SETF (%KEY SELF) (%KEY CURSOR))
     (CL:SETF (%VALUE SELF) (%VALUE CURSOR))
     (CL:SETF (%BUCKET-CURSOR SELF) CURSOR) (CL:RETURN-FROM NEXT? CL:T))
    (CL:T (CL:RETURN-FROM NEXT? CL:NIL)))))

;;; (DEFMETHOD (VALUE-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD VALUE-SETTER ((SELF STELLA-HASH-TABLE-ITERATOR) VALUE)
  (CL:LET* ((CURSOR (%BUCKET-CURSOR SELF)))
   (CL:WHEN (CL:NOT (CL:EQ CURSOR NULL)) (CL:SETF (%VALUE CURSOR) VALUE))
   (CL:SETF (%VALUE SELF) VALUE) (CL:RETURN-FROM VALUE-SETTER VALUE)))

;;; (DEFMETHOD (KEY-SETTER (LIKE (ANY-KEY SELF))) ...)

(CL:DEFMETHOD KEY-SETTER ((SELF STELLA-HASH-TABLE-ITERATOR) KEY)
  (CL:ERROR
   (NEW-STELLA-EXCEPTION "Cannot change the key of a STELLA-HASH-TABLE item")))

;;; (DEFGLOBAL *KEY-VALUE-MAP-CROSSOVER-POINT* ...)

(CL:DEFVAR *KEY-VALUE-MAP-CROSSOVER-POINT* NULL-INTEGER
  "Point where we switch from using a KV-CONS table
representation to a STELLA hash table to preserve O(1) access.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *KEY-VALUE-MAP-CROSSOVER-POINT*))

;;; (DEFCLASS KEY-VALUE-MAP ...)

(CL:DEFCLASS KEY-VALUE-MAP (DICTIONARY)
  ((THE-MAP :ALLOCATION :INSTANCE :ACCESSOR %THE-MAP)
   (EQUAL-TEST? :DOCUMENTATION "If true use `equal?' as the
equality test (and `equal-hash-code' as the hash function), otherwise,
use `eql?' (and `hash-code') (the default)." :ALLOCATION :INSTANCE :ACCESSOR
    %EQUAL-TEST?)
   (INITIAL-SIZE :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :DOCUMENTATION
    "If supplied, the initial table
will be sized to hold at least that many elements." :ALLOCATION :INSTANCE
    :ACCESSOR %INITIAL-SIZE)
   (CROSSOVER-POINT :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %CROSSOVER-POINT))
  (:DOCUMENTATION "Full-featured dictionary class that supports `eql?' or
`equal?' equality tests, O(1) access operations even for large numbers
of entries by using a hash table, light-weight KV-CONS representation for
small tables and iteration even if the dictionary is represented by a
hash table."))

(CL:DEFUN NEW-KEY-VALUE-MAP ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE KEY-VALUE-MAP)))
   (CL:SETF (%CROSSOVER-POINT SELF) *KEY-VALUE-MAP-CROSSOVER-POINT*)
   (CL:SETF (%INITIAL-SIZE SELF) *KEY-VALUE-MAP-CROSSOVER-POINT*)
   (CL:SETF (%EQUAL-TEST? SELF) CL:NIL) (CL:SETF (%THE-MAP SELF) NULL)
   (CL:RETURN-FROM NEW-KEY-VALUE-MAP SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF KEY-VALUE-MAP))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-COLLECTIONS-STELLA-KEY-VALUE-MAP))

(CL:DEFUN ACCESS-KEY-VALUE-MAP-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-THE-MAP)
    (CL:IF SETVALUE? (CL:SETF (%THE-MAP SELF) VALUE)
     (CL:SETQ VALUE (%THE-MAP SELF))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-EQUAL-TEST?)
    (CL:IF SETVALUE?
     (CL:SETF (%EQUAL-TEST? SELF) (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE (CL:IF (%EQUAL-TEST? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-INITIAL-SIZE)
    (CL:IF SETVALUE? (CL:SETF (%INITIAL-SIZE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%INITIAL-SIZE SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-CROSSOVER-POINT)
    (CL:IF SETVALUE? (CL:SETF (%CROSSOVER-POINT SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%CROSSOVER-POINT SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-KEY-VALUE-MAP-SLOT-VALUE VALUE))

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF KEY-VALUE-MAP) KEY)
  "Lookup the entry identified by `key' in `self' and
return its value, or NULL if no such entry exists.    Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((MAP (%THE-MAP SELF)) (CROSSOVER (%CROSSOVER-POINT SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CROSSOVER))
   (CL:COND
    ((CL:= CROSSOVER 0)
     (CL:RETURN-FROM LOOKUP (STELLA-HASH-TABLE-LOOKUP MAP KEY)))
    (CL:T
     (CL:LET* ((CURSOR MAP))
      (CL:IF (%EQUAL-TEST? SELF)
       (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
        (CL:WHEN (EQUAL? (%KEY CURSOR) KEY)
         (CL:RETURN-FROM LOOKUP (%VALUE CURSOR)))
        (CL:SETQ CURSOR (%REST CURSOR)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
        (CL:WHEN (EQL? (%KEY CURSOR) KEY)
         (CL:RETURN-FROM LOOKUP (%VALUE CURSOR)))
        (CL:SETQ CURSOR (%REST CURSOR))))
      (CL:RETURN-FROM LOOKUP NULL))))))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF KEY-VALUE-MAP) KEY VALUE)
  "Set the value of the entry identified by `key' in `self'
to `value' or add a new entry if no entry with `key' exists yet.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((MAP (%THE-MAP SELF)) (CROSSOVER (%CROSSOVER-POINT SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CROSSOVER))
   (CL:WHEN (CL:EQ MAP NULL)
    (CL:COND
     ((CL:> (%INITIAL-SIZE SELF) *KEY-VALUE-MAP-CROSSOVER-POINT*)
      (CL:LET* ((SELF-000 (NEW-STELLA-HASH-TABLE)))
       (CL:SETF (%INITIAL-SIZE SELF-000) (%INITIAL-SIZE SELF))
       (CL:SETF (%EQUAL-TEST? SELF-000) (%EQUAL-TEST? SELF))
       (CL:SETQ MAP SELF-000))
      (CL:SETF (%THE-MAP SELF) MAP) (CL:SETQ CROSSOVER 0))
     (CL:T (CL:SETQ CROSSOVER *KEY-VALUE-MAP-CROSSOVER-POINT*)))
    (CL:SETF (%CROSSOVER-POINT SELF) CROSSOVER))
   (CL:COND ((CL:= CROSSOVER 0) (STELLA-HASH-TABLE-INSERT-AT MAP KEY VALUE))
    (CL:T
     (CL:LET* ((CURSOR MAP))
      (CL:IF (%EQUAL-TEST? SELF)
       (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
        (CL:WHEN (EQUAL? (%KEY CURSOR) KEY) (CL:SETF (%VALUE CURSOR) VALUE)
         (CL:RETURN-FROM INSERT-AT))
        (CL:SETQ CURSOR (%REST CURSOR)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
        (CL:WHEN (EQL? (%KEY CURSOR) KEY) (CL:SETF (%VALUE CURSOR) VALUE)
         (CL:RETURN-FROM INSERT-AT))
        (CL:SETQ CURSOR (%REST CURSOR))))
      (CL:SETQ CURSOR (KV-CONS KEY VALUE MAP))
      (CL:SETF (%THE-MAP SELF) CURSOR) (CL:SETQ CROSSOVER (CL:1- CROSSOVER))
      (CL:SETF (%CROSSOVER-POINT SELF) CROSSOVER)
      (CL:WHEN (CL:= CROSSOVER 0)
       (CL:LET* ((SELF-001 (NEW-STELLA-HASH-TABLE)))
        (CL:SETF (%EQUAL-TEST? SELF-001) (%EQUAL-TEST? SELF))
        (CL:SETQ MAP SELF-001))
       (CL:SETF (%THE-MAP SELF) MAP)
       (CL:LET* ((KEY NULL) (VALUE NULL) (ITER-000 CURSOR))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
         (CL:SETQ KEY (%KEY ITER-000)) (CL:SETQ VALUE (%VALUE ITER-000))
         (STELLA-HASH-TABLE-INSERT-AT MAP KEY VALUE)
         (CL:SETQ ITER-000 (%REST ITER-000)))))))))
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF KEY-VALUE-MAP) KEY)
  "Remove the entry identified by `key' from `self'.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((MAP (%THE-MAP SELF)) (CROSSOVER (%CROSSOVER-POINT SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CROSSOVER))
   (CL:COND ((CL:= CROSSOVER 0) (STELLA-HASH-TABLE-REMOVE-AT MAP KEY))
    (CL:T
     (CL:LET* ((CURSOR MAP) (TRAILER MAP))
      (CL:IF (%EQUAL-TEST? SELF)
       (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
        (CL:WHEN (EQUAL? (%KEY CURSOR) KEY) (CL:RETURN))
        (CL:SETQ TRAILER CURSOR) (CL:SETQ CURSOR (%REST CURSOR)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
        (CL:WHEN (EQL? (%KEY CURSOR) KEY) (CL:RETURN))
        (CL:SETQ TRAILER CURSOR) (CL:SETQ CURSOR (%REST CURSOR))))
      (CL:COND ((CL:EQ CURSOR NULL) (CL:RETURN-FROM REMOVE-AT))
       ((CL:EQ CURSOR TRAILER) (CL:SETF (%THE-MAP SELF) (%REST CURSOR)))
       (CL:T (CL:SETF (%REST TRAILER) (%REST CURSOR))))
      (CL:SETF (%CROSSOVER-POINT SELF) (CL:1+ CROSSOVER))))))
  :VOID)

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF KEY-VALUE-MAP))
  "Return the number of entries in `self'."
  (CL:LET* ((MAP (%THE-MAP SELF)))
   (CL:COND ((CL:EQ MAP NULL) (CL:RETURN-FROM LENGTH 0))
    ((CL:= (%CROSSOVER-POINT SELF) 0) (CL:RETURN-FROM LENGTH (LENGTH MAP)))
    (CL:T (CL:RETURN-FROM LENGTH (LENGTH MAP))))))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF KEY-VALUE-MAP))
  "Return TRUE if `self' has zero entries."
  (CL:LET* ((MAP (%THE-MAP SELF)))
   (CL:COND ((CL:EQ MAP NULL) (CL:RETURN-FROM EMPTY? CL:T))
    ((CL:= (%CROSSOVER-POINT SELF) 0)
     (CL:RETURN-FROM EMPTY? (CL:= (LENGTH MAP) 0)))
    (CL:T (CL:RETURN-FROM EMPTY? CL:NIL)))))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF KEY-VALUE-MAP))
  "Return TRUE if `self' has at least 1 entry."
  (CL:LET* ((MAP (%THE-MAP SELF)))
   (CL:COND ((CL:EQ MAP NULL) (CL:RETURN-FROM NON-EMPTY? CL:NIL))
    ((CL:= (%CROSSOVER-POINT SELF) 0)
     (CL:RETURN-FROM NON-EMPTY? (> (LENGTH MAP) 0)))
    (CL:T (CL:RETURN-FROM NON-EMPTY? CL:T)))))

;;; (DEFMETHOD (COPY (LIKE SELF)) ...)

(CL:DEFMETHOD COPY ((SELF KEY-VALUE-MAP))
  "Return a copy of the map `self'.  All entries are freshly
allocated, however, the keys and values of entries are not copied themselves
 (similar to what we do for lists, etc.)."
  (CL:LET* ((SELF-000 (NEW-KEY-VALUE-MAP)))
   (CL:SETF (%EQUAL-TEST? SELF-000) (%EQUAL-TEST? SELF))
   (CL:SETF (%INITIAL-SIZE SELF-000) (%INITIAL-SIZE SELF))
   (CL:SETF (%CROSSOVER-POINT SELF-000) (%CROSSOVER-POINT SELF))
   (CL:LET* ((COPY SELF-000) (MAP (%THE-MAP SELF)))
    (CL:IF (CL:= (%CROSSOVER-POINT SELF) 0)
     (CL:SETF (%THE-MAP COPY) (COPY MAP))
     (CL:SETF (%THE-MAP COPY) (COPY-KV-CONS-LIST MAP)))
    (CL:RETURN-FROM COPY COPY))))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF KEY-VALUE-MAP))
  "Reset `self' to have zero entries."
  (CL:SETF (%THE-MAP SELF) NULL)
  (CL:SETF (%CROSSOVER-POINT SELF) *KEY-VALUE-MAP-CROSSOVER-POINT*)
  :VOID)

;;; (DEFMETHOD (ALLOCATE-ITERATOR (DICTIONARY-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF KEY-VALUE-MAP))
  "Allocate an iterator for `self'.  The only modifying
operations allowed during iteration are removal of the current element or
changing its value.  All other removal or insertion operations might lead
to corruption or undefined results."
  (CL:LET* ((MAP (%THE-MAP SELF)))
   (CL:COND
    ((CL:= (%CROSSOVER-POINT SELF) 0)
     (CL:RETURN-FROM ALLOCATE-ITERATOR (ALLOCATE-ITERATOR MAP)))
    (CL:T
     (CL:LET* ((SELF-000 (NEW-KEY-VALUE-LIST)))
      (CL:SETF (%THE-KV-LIST SELF-000) MAP)
      (CL:LET* ((VALUE-000 (ALLOCATE-ITERATOR SELF-000)))
       (CL:RETURN-FROM ALLOCATE-ITERATOR VALUE-000)))))))

;;; (DEFMETHOD (CONSIFY CONS) ...)

(CL:DEFMETHOD CONSIFY ((SELF KEY-VALUE-MAP))
  "Collect all entries of `self' into a cons list of
`(<key> <value>)' pairs and return the result."
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR SELF))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ KEY (%KEY ITER-000))
     (CL:SETQ VALUE (%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (CONS KEY (CONS VALUE NIL)) NIL))
       (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000) (CONS (CONS KEY (CONS VALUE NIL)) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:RETURN-FROM CONSIFY RESULT)))

;;; (DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQUAL? ((X KEY-VALUE-MAP) Y)
  "Return TRUE if `x' and `y' represent the same set of key/value pairs."
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE Y) SGT-COLLECTIONS-STELLA-KEY-VALUE-MAP)
    (CL:PROGN
     (CL:WHEN (CL:= (LENGTH X) (LENGTH Y))
      (CL:LET* ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR X)))
       (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ KEY (%KEY ITER-000))
        (CL:SETQ VALUE (%VALUE ITER-000))
        (CL:WHEN (CL:NOT (EQUAL? VALUE (LOOKUP Y KEY)))
         (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))))
      (CL:RETURN-FROM OBJECT-EQUAL? CL:T))))
   (CL:T))
  (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))

;;; (DEFMETHOD (EQUAL-HASH-CODE INTEGER) ...)

(CL:DEFMETHOD EQUAL-HASH-CODE ((SELF KEY-VALUE-MAP))
  "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of entries of `self'."
  (CL:LET* ((CODE 2137005)) (CL:DECLARE (CL:TYPE CL:FIXNUM CODE))
   (CL:LET* ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ KEY (%KEY ITER-000))
     (CL:SETQ VALUE (%VALUE ITER-000))
     (CL:SETQ CODE
      (CL:THE CL:FIXNUM
       (CL:LOGXOR CODE (CL:THE CL:FIXNUM (EQUAL-HASH-CODE KEY)))))
     (CL:SETQ CODE
      (CL:THE CL:FIXNUM
       (CL:LOGXOR CODE (CL:THE CL:FIXNUM (EQUAL-HASH-CODE VALUE)))))))
   (CL:RETURN-FROM EQUAL-HASH-CODE CODE)))

;;; (DEFCLASS HASH-SET ...)

(CL:DEFCLASS HASH-SET (KEY-VALUE-MAP)
  ()
  (:DOCUMENTATION "Full-featured set class that supports `eql?' or `equal?'
equality tests, O(1) insert and `member?' operations & O(N) `intersection'
etc. operations even for large numbers of entries by using a hash table,
light-weight KV-CONS representation for small sets and iteration even if the
set is represented by a hash table.  The only minor drawback right now is that
this wastes a value slot per entry, since we piggy-back off KEY-VALUE-MAP's,
however, that wastes at most 25% space."))

(CL:DEFUN NEW-HASH-SET ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE HASH-SET)))
   (CL:SETF (%CROSSOVER-POINT SELF) *KEY-VALUE-MAP-CROSSOVER-POINT*)
   (CL:SETF (%INITIAL-SIZE SELF) *KEY-VALUE-MAP-CROSSOVER-POINT*)
   (CL:SETF (%EQUAL-TEST? SELF) CL:NIL) (CL:SETF (%THE-MAP SELF) NULL)
   (CL:RETURN-FROM NEW-HASH-SET SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF HASH-SET))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-COLLECTIONS-STELLA-HASH-SET))

;;; (DEFUN (HASH-SET HASH-SET) ...)

(CL:DEFUN HASH-SET (CL:&REST VALUES)
  "Return an `eql?' HASH-SET containing `values'."
  (CL:LET* ((SET (NEW-HASH-SET)))
   (CL:LET* ((V NULL) (ITER-000 VALUES))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ V (CL:POP ITER-000))
     (INSERT-AT SET V V)))
   (CL:RETURN-FROM HASH-SET SET)))

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF HASH-SET) OBJECT)
  "Return TRUE iff `object' is a member of the set `self'.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:RETURN-FROM MEMBER? (CL:NOT (CL:EQ (LOOKUP SELF OBJECT) NULL))))

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF HASH-SET) VALUE)
  "Add `value' to the set `self' unless it is already a member.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (INSERT-AT SELF VALUE VALUE)
  :VOID)

;;; (DEFMETHOD (REMOVE (LIKE SELF)) ...)

(CL:DEFMETHOD REMOVE ((SELF HASH-SET) VALUE)
  "Destructively remove `value' from the set `self' if it is a member and
return `self'.  Uses an `eql?' test by default or `equal?' if `equal-test?' of
`self' is TRUE."
  (REMOVE-AT SELF VALUE)
  (CL:RETURN-FROM REMOVE SELF))

;;; (DEFMETHOD (REMOVE-IF (LIKE SELF)) ...)

(CL:DEFMETHOD REMOVE-IF ((SELF HASH-SET) TEST?)
  "Destructively remove all elements of the set `self' for which
'test?' evaluates to TRUE.  `test?' takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns `self'."
  (CL:LET* ((ELEMENT NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ ELEMENT (%VALUE ITER-000))
    (CL:WHEN (CL:FUNCALL TEST? ELEMENT) (REMOVE-AT SELF ELEMENT))))
  (CL:RETURN-FROM REMOVE-IF SELF))

;;; (DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD POP ((SELF HASH-SET))
  "Remove and return an arbitrary element of the set `self'.
Return NULL if the set is empty.  Performance note: for large sets implemented
via hash tables it takes O(N) to empty out the set with repeated calls to `pop',
since the emptier the table gets, the longer it takes to find an element.
Therefore, it is usually better to use iteration with embedded removals for
such cases."
  (CL:LET* ((ELEMENT NULL) (SETMAP (%THE-MAP SELF)))
   (CL:WHEN (CL:NOT (CL:EQ SETMAP NULL))
    (CL:COND
     ((CL:= (%CROSSOVER-POINT SELF) 0)
      (CL:LET* ((MAP SETMAP) (TABLE (%THE-TABLE MAP)) (BUCKET NULL))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE))
       (CL:WHEN (CL:NOT (NULL-ARRAY? TABLE))
        (CL:LET*
         ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- (%SIZE MAP))))
         (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
         (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
          (CL:SETQ I ITER-000) (CL:SETQ BUCKET (CL:AREF TABLE I))
          (CL:WHEN (CL:NOT (CL:EQ BUCKET NULL))
           (CL:SETQ ELEMENT (%KEY BUCKET)) (CL:RETURN))
          (CL:SETQ ITER-000 (CL:1+ ITER-000)))))))
     (CL:T
      (CL:LET* ((MAP (%THE-MAP SELF)))
       (CL:WHEN (CL:NOT (CL:EQ MAP NULL)) (CL:SETQ ELEMENT (%KEY MAP)))))))
   (CL:WHEN (CL:NOT (CL:EQ ELEMENT NULL)) (REMOVE-AT SELF ELEMENT))
   (CL:RETURN-FROM POP ELEMENT)))

;;; (DEFMETHOD (SUBSTITUTE (LIKE SELF)) ...)

(CL:DEFMETHOD SUBSTITUTE ((SELF HASH-SET) NEW OLD)
  "Destructively replace `old' with `new' in the set `self'
unless `new' is already a member.  Uses an `eql?' test by default or `equal?'
if `equal-test?' of `self' is TRUE."
  (CL:WHEN (CL:NOT (MEMBER? SELF NEW)) (REMOVE-AT SELF OLD)
   (INSERT-AT SELF NEW NEW))
  (CL:RETURN-FROM SUBSTITUTE SELF))

;;; (DEFMETHOD (COPY (LIKE SELF)) ...)

(CL:DEFMETHOD COPY ((SELF HASH-SET))
  "Return a copy of the set `self'.  All entries are freshly
allocated, however, the values are not copied themselves (similar to what we
do for lists, etc.)."
  (CL:LET* ((SELF-000 (NEW-HASH-SET)))
   (CL:SETF (%EQUAL-TEST? SELF-000) (%EQUAL-TEST? SELF))
   (CL:SETF (%INITIAL-SIZE SELF-000) (%INITIAL-SIZE SELF))
   (CL:SETF (%CROSSOVER-POINT SELF-000) (%CROSSOVER-POINT SELF))
   (CL:LET* ((COPY SELF-000) (MAP (%THE-MAP SELF)))
    (CL:IF (CL:= (%CROSSOVER-POINT SELF) 0)
     (CL:SETF (%THE-MAP COPY) (COPY MAP))
     (CL:SETF (%THE-MAP COPY) (COPY-KV-CONS-LIST MAP)))
    (CL:RETURN-FROM COPY COPY))))

;;; (DEFMETHOD (CONSIFY (CONS OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD CONSIFY ((SELF HASH-SET))
  "Collect all entries of `self' into a cons list and return the result."
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ VALUE (%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS VALUE NIL))
       (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VALUE NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:RETURN-FROM CONSIFY RESULT)))

;;; (DEFMETHOD (SUBSET? BOOLEAN) ...)

(CL:DEFMETHOD SUBSET? ((SELF HASH-SET) OTHERSET)
  "Return true if every element of `self' also occurs in `otherSet'.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000 (<= (LENGTH SELF) (LENGTH OTHERSET)))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((ALWAYS?-000 CL:T))
     (CL:LET* ((ELT NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ ELT (%VALUE ITER-000))
       (CL:WHEN (CL:EQ (LOOKUP OTHERSET ELT) NULL)
        (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))))
     (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) (CL:RETURN-FROM SUBSET? VALUE-000))))

;;; (DEFMETHOD (EQUIVALENT-SETS? BOOLEAN) ...)

(CL:DEFMETHOD EQUIVALENT-SETS? ((SELF HASH-SET) OTHERSET)
  "Return true if every element of `self' occurs in `otherSet' and vice versa.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000 (CL:= (LENGTH SELF) (LENGTH OTHERSET)))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((ALWAYS?-000 CL:T))
     (CL:LET* ((ELT NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ ELT (%VALUE ITER-000))
       (CL:WHEN (CL:EQ (LOOKUP OTHERSET ELT) NULL)
        (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))))
     (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM EQUIVALENT-SETS? VALUE-000))))

;;; (DEFMETHOD (INTERSECTION HASH-SET) ...)

(CL:DEFMETHOD INTERSECTION ((SELF HASH-SET) OTHERSET)
  "Return the set intersection of `self' and `otherSet' as a new set.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((SELF-000 (NEW-HASH-SET)))
   (CL:SETF (%EQUAL-TEST? SELF-000) (%EQUAL-TEST? SELF))
   (CL:LET* ((RESULT SELF-000) (AUX SELF))
    (CL:WHEN (CL:> (LENGTH SELF) (LENGTH OTHERSET)) (CL:SETQ SELF OTHERSET)
     (CL:SETQ OTHERSET AUX))
    (CL:LET* ((ELT NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ ELT (%VALUE ITER-000))
      (CL:WHEN (CL:NOT (CL:EQ (LOOKUP OTHERSET ELT) NULL))
       (INSERT-AT RESULT ELT ELT))))
    (CL:RETURN-FROM INTERSECTION RESULT))))

;;; (DEFMETHOD (UNION HASH-SET) ...)

(CL:DEFMETHOD UNION ((SELF HASH-SET) OTHERSET)
  "Return the set union of `self' and `otherSet' as a new set.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((RESULT NULL) (AUX SELF))
   (CL:WHEN (CL:< (LENGTH SELF) (LENGTH OTHERSET)) (CL:SETQ SELF OTHERSET)
    (CL:SETQ OTHERSET AUX))
   (CL:SETQ RESULT (COPY SELF))
   (CL:LET* ((ELT NULL) (ITER-000 (ALLOCATE-ITERATOR OTHERSET)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ ELT (%VALUE ITER-000))
     (INSERT-AT RESULT ELT ELT)))
   (CL:RETURN-FROM UNION RESULT)))

;;; (DEFMETHOD (DIFFERENCE HASH-SET) ...)

(CL:DEFMETHOD DIFFERENCE ((SELF HASH-SET) OTHERSET)
  "Return the set difference of `self' and `otherSet' as a new set (i.e.,
all elements that are in `self' but not in `otherSet').  Uses an `eql?' test
by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((RESULT NULL))
   (CL:COND
    ((CL:> (LENGTH SELF) (CL:* (LENGTH OTHERSET) 2))
     (CL:SETQ RESULT (COPY SELF))
     (CL:LET* ((ELT NULL) (ITER-000 (ALLOCATE-ITERATOR OTHERSET)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ ELT (%VALUE ITER-000))
       (CL:WHEN (CL:NOT (CL:EQ (LOOKUP RESULT ELT) NULL))
        (REMOVE-AT RESULT ELT)))))
    (CL:T
     (CL:LET* ((SELF-000 (NEW-HASH-SET)))
      (CL:SETF (%EQUAL-TEST? SELF-000) (%EQUAL-TEST? SELF))
      (CL:SETQ RESULT SELF-000))
     (CL:LET* ((ELT NULL) (ITER-001 (ALLOCATE-ITERATOR SELF)))
      (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ ELT (%VALUE ITER-001))
       (CL:WHEN (CL:EQ (LOOKUP OTHERSET ELT) NULL)
        (INSERT-AT RESULT ELT ELT))))))
   (CL:RETURN-FROM DIFFERENCE RESULT)))

;;; (DEFMETHOD (SUBTRACT HASH-SET) ...)

(CL:DEFMETHOD SUBTRACT ((SELF HASH-SET) OTHERSET)
  "Return the set difference of `self' and `otherSet' by destructively
removing elements from `self' that also occur in `otherSet'.  Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((ELT NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ ELT (%VALUE ITER-000))
    (CL:WHEN (CL:NOT (CL:EQ (LOOKUP OTHERSET ELT) NULL))
     (REMOVE-AT SELF ELT))))
  (CL:RETURN-FROM SUBTRACT SELF))

;;; (DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQUAL? ((X HASH-SET) Y)
  "Return TRUE iff sets `x' and `y' are HASH-SET's with equivalent members.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.
This is equivalent to calling `equivalent-sets?'."
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE Y) SGT-COLLECTIONS-STELLA-HASH-SET)
    (CL:PROGN (CL:RETURN-FROM OBJECT-EQUAL? (EQUIVALENT-SETS? X Y))))
   (CL:T))
  (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))

;;; (DEFMETHOD (EQUAL-HASH-CODE INTEGER) ...)

(CL:DEFMETHOD EQUAL-HASH-CODE ((SELF HASH-SET))
  "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of elements of `self'."
  (CL:LET* ((CODE 7971569)) (CL:DECLARE (CL:TYPE CL:FIXNUM CODE))
   (CL:LET* ((ELT NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ ELT (%VALUE ITER-000))
     (CL:SETQ CODE
      (CL:THE CL:FIXNUM
       (CL:LOGXOR CODE (CL:THE CL:FIXNUM (EQUAL-HASH-CODE ELT)))))))
   (CL:RETURN-FROM EQUAL-HASH-CODE CODE)))

(CL:DEFUN HELP-STARTUP-COLLECTIONS1 ()
  (CL:PROGN
   (CL:SETQ SGT-COLLECTIONS-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION" NULL 1))
   (CL:SETQ SGT-COLLECTIONS-STELLA-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET" NULL 1))
   (CL:SETQ SYM-COLLECTIONS-STELLA-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" NULL 0))
   (CL:SETQ KWD-COLLECTIONS-CPP (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
   (CL:SETQ KWD-COLLECTIONS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SGT-COLLECTIONS-STELLA-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" NULL 1))
   (CL:SETQ SGT-COLLECTIONS-STELLA-STELLA-HASH-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA-HASH-TABLE" NULL 1))
   (CL:SETQ SYM-COLLECTIONS-STELLA-SIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIZE" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-INITIAL-SIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIAL-SIZE" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-FREE-ELEMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FREE-ELEMENTS" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-EQUAL-TEST?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUAL-TEST?" NULL 0))
   (CL:SETQ SGT-COLLECTIONS-STELLA-STELLA-HASH-TABLE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA-HASH-TABLE-ITERATOR" NULL 1))
   (CL:SETQ SYM-COLLECTIONS-STELLA-BUCKET-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BUCKET-INDEX" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-BUCKET-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BUCKET-CURSOR" NULL 0))
   (CL:SETQ SGT-COLLECTIONS-STELLA-KEY-VALUE-MAP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-VALUE-MAP" NULL 1))
   (CL:SETQ SYM-COLLECTIONS-STELLA-THE-MAP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-MAP" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-CROSSOVER-POINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CROSSOVER-POINT" NULL 0))
   (CL:SETQ SGT-COLLECTIONS-STELLA-HASH-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HASH-SET" NULL 1))
   (CL:SETQ SYM-COLLECTIONS-STELLA-STARTUP-COLLECTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-COLLECTIONS" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-COLLECTIONS2 ()
  (CL:PROGN
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF COLLECTION) (OBJECT OBJECT)) :DOCUMENTATION \"Return true iff `object' is a member of the collection `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION MEMBER?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE-DUPLICATES (LIKE SELF)) ((SELF COLLECTION)) :DOCUMENTATION \"Return `self' with duplicates removed.  Preserves the
original order of the remaining members.\" :PUBLIC? TRUE :ABSTRACT? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-COLLECTION?"
    "(DEFUN (STELLA-COLLECTION? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if `self' is a native collection.\")"
    (CL:FUNCTION STELLA-COLLECTION?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NO-DUPLICATES? BOOLEAN) ((SELF COLLECTION)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if the collection `self' forbids duplicate values.\")"
    (CL:FUNCTION NO-DUPLICATES?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NO-DUPLICATES? BOOLEAN) ((SELF SET)) :PUBLIC? TRUE)"
    (CL:FUNCTION NO-DUPLICATES?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ORDERED? BOOLEAN) ((SELF COLLECTION)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if the collection `self' is ordered.\")"
    (CL:FUNCTION ORDERED?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ORDERED? BOOLEAN) ((SELF SEQUENCE)) :PUBLIC? TRUE)"
    (CL:FUNCTION ORDERED?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ORDERED? BOOLEAN) ((SELF SET)) :PUBLIC? TRUE)"
    (CL:FUNCTION ORDERED?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT ((SELF SET) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Add `value' to the set `self' unless it is already a member.\")"
    (CL:FUNCTION INSERT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PUSH ((SELF SET) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Add `value' to the front of set `self' unless it is already a member.\")"
    (CL:FUNCTION PUSH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-LAST ((SELF SET) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Add `value' to the end of set `self' unless it is already a member.\" :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-LAST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE-DUPLICATES (LIKE SELF)) ((SELF SET)))"
    (CL:FUNCTION REMOVE-DUPLICATES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBSTITUTE (LIKE SELF)) ((SELF SET) (NEW OBJECT) (OLD OBJECT)) :DOCUMENTATION \"Destructively replace `old' with `new' in the set `self'
unless `new' is already a member.\" :PUBLIC? TRUE)" (CL:FUNCTION SUBSTITUTE)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONCATENATE SET) ((SET1 SET) (SET2 LIST) |&REST| (OTHERSETS LIST)) :DOCUMENTATION \"Union `set2' and all `otherSets' onto the end of `set1'.
The operation is destructive wrt `set1', but leaves all other sets intact.
The two mandatory parameters allow us to optimize the common binary case by
not relying on the somewhat less efficient variable arguments mechanism.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CONCATENATE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X SET) (Y OBJECT)) :DOCUMENTATION \"Return TRUE iff `x' and `y' are SET's with equivalent members.
Uses `equal?' to test equality of elements.  This is more general than
`equivalent-sets?', since that only uses an `eql?' test.\" :PUBLIC? TRUE)"
    (CL:FUNCTION OBJECT-EQUAL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF SET)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of elements of `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION EQUAL-HASH-CODE) NULL)
   (DEFINE-FUNCTION-OBJECT "SET"
    "(DEFUN (SET SET) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a set containing `values', in order.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SET) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PRINT-VECTOR ((SELF VECTOR) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-VECTOR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF VECTOR)) :DOCUMENTATION \"Return `true' if `self' has length 0.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQL? (ARRAY-SIZE SELF) 0)))"
    (CL:FUNCTION EMPTY?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF VECTOR)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if `self' has length > 0.\" :GLOBALLY-INLINE? TRUE (RETURN (> (ARRAY-SIZE SELF) 0)))"
    (CL:FUNCTION NON-EMPTY?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 0)))"
    (CL:FUNCTION FIRST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 1)))"
    (CL:FUNCTION SECOND) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 2)))"
    (CL:FUNCTION THIRD) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 3)))"
    (CL:FUNCTION FOURTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 4)))"
    (CL:FUNCTION FIFTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (POSITION INTEGER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH (THE-ARRAY SELF) POSITION)))"
    (CL:FUNCTION NTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :DOCUMENTATION \"Return the last item in the vector `self'.\")"
    (CL:FUNCTION LAST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIRST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 0) VALUE)))"
    (CL:FUNCTION FIRST-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SECOND-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 1) VALUE)))"
    (CL:FUNCTION SECOND-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (THIRD-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 2) VALUE)))"
    (CL:FUNCTION THIRD-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FOURTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 3) VALUE)))"
    (CL:FUNCTION FOURTH-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIFTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 4) VALUE)))"
    (CL:FUNCTION FIFTH-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF))) (POSITION INTEGER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH (THE-ARRAY SELF) POSITION) VALUE)))"
    (CL:FUNCTION NTH-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LAST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION LAST-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF VECTOR)) :PUBLIC? TRUE)"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF VECTOR) (OBJECT OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION MEMBER?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (POSITION INTEGER) ((SELF VECTOR) (OBJECT OBJECT) (START INTEGER)) :DOCUMENTATION \"Return the position of `object' within the vector
`self' (counting from zero); or return `null' if `object' does not occur within 
`self' (uses an `eql?' test).  If `start' was supplied as non-`null', only 
consider the portion starting at `start', however, the returned position 
will always be relative to the entire vector.\" :PUBLIC? TRUE)"
    (CL:FUNCTION POSITION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LAST-POSITION INTEGER) ((SELF VECTOR) (OBJECT OBJECT) (END INTEGER)) :DOCUMENTATION \"Return the position of `object' within the vector
`self' (counting from zero); or return `null' if `object' does not occur within 
`self' (uses an `eql?' test).  If `end' was supplied as non-`null', only 
consider the portion ending at index `end', however, the returned position 
will always be relative to the entire vector.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LAST-POSITION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF VECTOR) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))))"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY (VECTOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)) :DOCUMENTATION \"Return a copy of the vector `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COPY) NULL)
   (DEFINE-METHOD-OBJECT "(DEFMETHOD CLEAR ((SELF VECTOR)) :PUBLIC? TRUE)"
    (CL:FUNCTION CLEAR) NULL)
   (DEFINE-FUNCTION-OBJECT "VECTOR"
    "(DEFUN (VECTOR VECTOR) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a vector containing `values', in order.\" :PUBLIC? TRUE)"
    (CL:FUNCTION VECTOR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X VECTOR) (Y OBJECT)) :DOCUMENTATION \"Return TRUE iff the vectors `x' and `y' are structurally
equivalent.  Uses `equal?' to test equality of elements.\" :PUBLIC? TRUE)"
    (CL:FUNCTION OBJECT-EQUAL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF VECTOR)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION EQUAL-HASH-CODE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-VECTOR) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-SYMBOL-ARRAY) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT ((SELF VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Append `value' to the END of the sequence `self'.  
Resize the array if necessary.\" :PUBLIC? TRUE)" (CL:FUNCTION INSERT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE VECTOR-SEQUENCE) ((SELF VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Remove `value' from the sequence `self', and left shift
the values after it to close the gap.\" :PUBLIC? TRUE)" (CL:FUNCTION REMOVE)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF VECTOR-SEQUENCE)) :PUBLIC? TRUE)"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)))"
    (CL:FUNCTION ALLOCATE-ITERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "VECTOR-NEXT?"
    "(DEFUN (VECTOR-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION VECTOR-NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)) :DOCUMENTATION \"Generate all but the last element of the vector `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION BUT-LAST) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-STELLA-HASH-TABLE"
    "(DEFUN INITIALIZE-STELLA-HASH-TABLE ((SELF STELLA-HASH-TABLE)))"
    (CL:FUNCTION INITIALIZE-STELLA-HASH-TABLE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Initialize the STELLA hash table `self'.  This is a
no-op and primarily exists to shadow the standard initializer inherited
from ABSTRACT-HASH-TABLE.  STELLA hash tables are initialized at the
first insertion operation.\")" (CL:FUNCTION INITIALIZE-HASH-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "REHASH-STELLA-HASH-TABLE"
    "(DEFUN REHASH-STELLA-HASH-TABLE ((SELF STELLA-HASH-TABLE) (NEWSIZE INTEGER)))"
    (CL:FUNCTION REHASH-STELLA-HASH-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-HASH-TABLE-INSERT-AT"
    "(DEFUN STELLA-HASH-TABLE-INSERT-AT ((SELF STELLA-HASH-TABLE) (KEY OBJECT) (VALUE OBJECT)))"
    (CL:FUNCTION STELLA-HASH-TABLE-INSERT-AT) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-HASH-TABLE-REMOVE-AT"
    "(DEFUN STELLA-HASH-TABLE-REMOVE-AT ((SELF STELLA-HASH-TABLE) (KEY OBJECT)))"
    (CL:FUNCTION STELLA-HASH-TABLE-REMOVE-AT) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-HASH-TABLE-LOOKUP"
    "(DEFUN (STELLA-HASH-TABLE-LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF STELLA-HASH-TABLE) (KEY OBJECT)))"
    (CL:FUNCTION STELLA-HASH-TABLE-LOOKUP) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-STRING-HASH-TABLE-LOOKUP"
    "(DEFUN (STELLA-STRING-HASH-TABLE-LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF STELLA-HASH-TABLE) (KEY STRING)))"
    (CL:FUNCTION STELLA-STRING-HASH-TABLE-LOOKUP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF STELLA-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Lookup the entry identified by `key' in `self' and
return its value, or NULL if no such entry exists.    Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP) NULL))
  :VOID)

(CL:DEFUN STARTUP-COLLECTIONS ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-COLLECTIONS1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *KEY-VALUE-MAP-CROSSOVER-POINT*
     *REMOVE-DUPLICATES-CROSSOVER-POINT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STELLA-HASH-TABLE"
        "(DEFCLASS STELLA-HASH-TABLE (ABSTRACT-HASH-TABLE) :PARAMETERS ((ANY-KEY :TYPE OBJECT) (ANY-VALUE :TYPE OBJECT)) :SLOTS ((THE-TABLE :TYPE (ARRAY () OF KV-CONS)) (SIZE :TYPE INTEGER) (INITIAL-SIZE :TYPE INTEGER :INITIALLY 50 :PUBLIC? TRUE :DOCUMENTATION \"If supplied, the initial hash table
will be sized to hold at least that many elements.\") (FREE-ELEMENTS :TYPE INTEGER) (EQUAL-TEST? :TYPE BOOLEAN :INITIALLY FALSE :PUBLIC? TRUE :DOCUMENTATION \"If true use `equal?' as the
equality test and `equal-hash-code' as the hash function, otherwise,
use `eql?' and `hash-code' (the default).\")))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-STELLA-HASH-TABLE))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-STELLA-HASH-TABLE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STELLA-HASH-TABLE-ITERATOR"
        "(DEFCLASS STELLA-HASH-TABLE-ITERATOR (DICTIONARY-ITERATOR) :DOCUMENTATION \"Iterator class for STELLA-HASH-TABLE's.  The only modifying
operations allowed during iteration are removal of the current element or
changing its value.  All other removal or insertion operations might lead
to corruption or undefined results.\" :SLOTS ((SIZE :TYPE INTEGER) (BUCKET-TABLE :TYPE (ARRAY () OF KV-CONS)) (BUCKET-INDEX :TYPE INTEGER :INITIALLY 0) (BUCKET-CURSOR :TYPE KV-CONS)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-STELLA-HASH-TABLE-ITERATOR))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-STELLA-HASH-TABLE-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "KEY-VALUE-MAP"
        "(DEFCLASS KEY-VALUE-MAP (DICTIONARY) :DOCUMENTATION \"Full-featured dictionary class that supports `eql?' or
`equal?' equality tests, O(1) access operations even for large numbers
of entries by using a hash table, light-weight KV-CONS representation for
small tables and iteration even if the dictionary is represented by a
hash table.\" :PUBLIC? TRUE :SLOTS ((THE-MAP :TYPE OBJECT) (EQUAL-TEST? :TYPE BOOLEAN :INITIALLY FALSE :PUBLIC? TRUE :DOCUMENTATION \"If true use `equal?' as the
equality test (and `equal-hash-code' as the hash function), otherwise,
use `eql?' (and `hash-code') (the default).\") (INITIAL-SIZE :TYPE INTEGER :INITIALLY *KEY-VALUE-MAP-CROSSOVER-POINT* :PUBLIC? TRUE :DOCUMENTATION \"If supplied, the initial table
will be sized to hold at least that many elements.\") (CROSSOVER-POINT :TYPE INTEGER :INITIALLY *KEY-VALUE-MAP-CROSSOVER-POINT*)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-KEY-VALUE-MAP))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-KEY-VALUE-MAP-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "HASH-SET"
        "(DEFCLASS HASH-SET (KEY-VALUE-MAP SET-MIXIN) :DOCUMENTATION \"Full-featured set class that supports `eql?' or `equal?'
equality tests, O(1) insert and `member?' operations & O(N) `intersection'
etc. operations even for large numbers of entries by using a hash table,
light-weight KV-CONS representation for small sets and iteration even if the
set is represented by a hash table.  The only minor drawback right now is that
this wastes a value slot per entry, since we piggy-back off KEY-VALUE-MAP's,
however, that wastes at most 25% space.\" :PUBLIC? TRUE)")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-HASH-SET))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-COLLECTIONS2)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD INSERT-AT ((SELF STELLA-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Set the value of the entry identified by `key' in `self'
to `value' or add a new entry if no entry with `key' exists yet.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
     (CL:FUNCTION INSERT-AT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD REMOVE-AT ((SELF STELLA-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Remove the entry identified by `key' from `self'.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
     (CL:FUNCTION REMOVE-AT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LENGTH INTEGER) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return the number of entries in `self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LENGTH) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return TRUE if `self' has zero entries.\" :PUBLIC? TRUE)"
     (CL:FUNCTION EMPTY?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return TRUE if `self' has at least 1 entry.\" :PUBLIC? TRUE)"
     (CL:FUNCTION NON-EMPTY?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (COPY (LIKE SELF)) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return a copy of the hash table `self'.  The bucket table
and buckets are freshly allocated, however, the keys and values of entries
are not copied themselves (similar to what we do for lists, etc.).\" :PUBLIC? TRUE)"
     (CL:FUNCTION COPY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD CLEAR ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Remove all entries from `self'.  This will result in a
re-initialization of the table upon the first insertion into `self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CLEAR) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (CONSIFY (CONS OF CONS)) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Collect all entries of `self' into a cons list of
`(<key> <value>)' pairs and return the result.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CONSIFY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X STELLA-HASH-TABLE) (Y OBJECT)) :DOCUMENTATION \"Return TRUE if `x' and `y' represent the same set of key/value pairs.\" :PUBLIC? TRUE)"
     (CL:FUNCTION OBJECT-EQUAL?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of entries of `self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION EQUAL-HASH-CODE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (ALLOCATE-ITERATOR (STELLA-HASH-TABLE-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Allocate an iterator for `self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION ALLOCATE-ITERATOR) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF STELLA-HASH-TABLE-ITERATOR)))"
     (CL:FUNCTION NEXT?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (VALUE-SETTER (LIKE (ANY-VALUE SELF))) ((SELF STELLA-HASH-TABLE-ITERATOR) (VALUE (LIKE (ANY-VALUE SELF)))))"
     (CL:FUNCTION VALUE-SETTER) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (KEY-SETTER (LIKE (ANY-KEY SELF))) ((SELF STELLA-HASH-TABLE-ITERATOR) (KEY (LIKE (ANY-KEY SELF)))))"
     (CL:FUNCTION KEY-SETTER) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF KEY-VALUE-MAP) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Lookup the entry identified by `key' in `self' and
return its value, or NULL if no such entry exists.    Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD INSERT-AT ((SELF KEY-VALUE-MAP) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Set the value of the entry identified by `key' in `self'
to `value' or add a new entry if no entry with `key' exists yet.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
     (CL:FUNCTION INSERT-AT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD REMOVE-AT ((SELF KEY-VALUE-MAP) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Remove the entry identified by `key' from `self'.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
     (CL:FUNCTION REMOVE-AT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LENGTH INTEGER) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return the number of entries in `self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LENGTH) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return TRUE if `self' has zero entries.\" :PUBLIC? TRUE)"
     (CL:FUNCTION EMPTY?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return TRUE if `self' has at least 1 entry.\" :PUBLIC? TRUE)"
     (CL:FUNCTION NON-EMPTY?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (COPY (LIKE SELF)) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return a copy of the map `self'.  All entries are freshly
allocated, however, the keys and values of entries are not copied themselves
 (similar to what we do for lists, etc.).\" :PUBLIC? TRUE)" (CL:FUNCTION COPY)
     NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD CLEAR ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Reset `self' to have zero entries.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CLEAR) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (ALLOCATE-ITERATOR (DICTIONARY-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Allocate an iterator for `self'.  The only modifying
operations allowed during iteration are removal of the current element or
changing its value.  All other removal or insertion operations might lead
to corruption or undefined results.\" :PUBLIC? TRUE)"
     (CL:FUNCTION ALLOCATE-ITERATOR) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (CONSIFY CONS) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Collect all entries of `self' into a cons list of
`(<key> <value>)' pairs and return the result.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CONSIFY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X KEY-VALUE-MAP) (Y OBJECT)) :DOCUMENTATION \"Return TRUE if `x' and `y' represent the same set of key/value pairs.\" :PUBLIC? TRUE)"
     (CL:FUNCTION OBJECT-EQUAL?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of entries of `self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION EQUAL-HASH-CODE) NULL)
    (DEFINE-FUNCTION-OBJECT "HASH-SET"
     "(DEFUN (HASH-SET HASH-SET) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return an `eql?' HASH-SET containing `values'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION HASH-SET) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF HASH-SET) (OBJECT OBJECT)) :DOCUMENTATION \"Return TRUE iff `object' is a member of the set `self'.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
     (CL:FUNCTION MEMBER?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD INSERT ((SELF HASH-SET) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Add `value' to the set `self' unless it is already a member.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
     (CL:FUNCTION INSERT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (REMOVE (LIKE SELF)) ((SELF HASH-SET) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Destructively remove `value' from the set `self' if it is a member and
return `self'.  Uses an `eql?' test by default or `equal?' if `equal-test?' of
`self' is TRUE.\" :PUBLIC? TRUE)" (CL:FUNCTION REMOVE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (REMOVE-IF (LIKE SELF)) ((SELF HASH-SET) (TEST? FUNCTION-CODE)) :DOCUMENTATION \"Destructively remove all elements of the set `self' for which
'test?' evaluates to TRUE.  `test?' takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns `self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION REMOVE-IF) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ((SELF HASH-SET)) :DOCUMENTATION \"Remove and return an arbitrary element of the set `self'.
Return NULL if the set is empty.  Performance note: for large sets implemented
via hash tables it takes O(N) to empty out the set with repeated calls to `pop',
since the emptier the table gets, the longer it takes to find an element.
Therefore, it is usually better to use iteration with embedded removals for
such cases.\" :PUBLIC? TRUE)" (CL:FUNCTION POP) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (SUBSTITUTE (LIKE SELF)) ((SELF HASH-SET) (NEW OBJECT) (OLD OBJECT)) :DOCUMENTATION \"Destructively replace `old' with `new' in the set `self'
unless `new' is already a member.  Uses an `eql?' test by default or `equal?'
if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)" (CL:FUNCTION SUBSTITUTE)
     NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (COPY (LIKE SELF)) ((SELF HASH-SET)) :DOCUMENTATION \"Return a copy of the set `self'.  All entries are freshly
allocated, however, the values are not copied themselves (similar to what we
do for lists, etc.).\" :PUBLIC? TRUE)" (CL:FUNCTION COPY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (CONSIFY (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF HASH-SET)) :DOCUMENTATION \"Collect all entries of `self' into a cons list and return the result.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CONSIFY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (SUBSET? BOOLEAN) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return true if every element of `self' also occurs in `otherSet'.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
     (CL:FUNCTION SUBSET?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (EQUIVALENT-SETS? BOOLEAN) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return true if every element of `self' occurs in `otherSet' and vice versa.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
     (CL:FUNCTION EQUIVALENT-SETS?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (INTERSECTION HASH-SET) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return the set intersection of `self' and `otherSet' as a new set.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
     (CL:FUNCTION INTERSECTION) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (UNION HASH-SET) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return the set union of `self' and `otherSet' as a new set.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
     (CL:FUNCTION UNION) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (DIFFERENCE HASH-SET) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return the set difference of `self' and `otherSet' as a new set (i.e.,
all elements that are in `self' but not in `otherSet').  Uses an `eql?' test
by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
     (CL:FUNCTION DIFFERENCE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (SUBTRACT HASH-SET) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return the set difference of `self' and `otherSet' by destructively
removing elements from `self' that also occur in `otherSet'.  Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
     (CL:FUNCTION SUBTRACT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X HASH-SET) (Y OBJECT)) :DOCUMENTATION \"Return TRUE iff sets `x' and `y' are HASH-SET's with equivalent members.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.
This is equivalent to calling `equivalent-sets?'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION OBJECT-EQUAL?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF HASH-SET)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of elements of `self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION EQUAL-HASH-CODE) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-COLLECTIONS"
     "(DEFUN STARTUP-COLLECTIONS () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-COLLECTIONS) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-COLLECTIONS-STELLA-STARTUP-COLLECTIONS)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-COLLECTIONS-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupCollections") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (REGISTER-NATIVE-NAME SYM-COLLECTIONS-STELLA-VECTOR KWD-COLLECTIONS-CPP
     KWD-COLLECTIONS-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *USE-STELLA-HASH-TABLES?* BOOLEAN (VERBATIM :COMMON-LISP \"CL-USER::*use-stella-hash-tables?*\" :CPP \"
#ifndef HAVE_SGI_HASH_MAPS
  TRUE
#else
  FALSE
#endif
\" :OTHERWISE FALSE))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH* FLOAT 1.0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *KEY-VALUE-MAP-CROSSOVER-POINT* INTEGER *REMOVE-DUPLICATES-CROSSOVER-POINT* :DOCUMENTATION \"Point where we switch from using a KV-CONS table
representation to a STELLA hash table to preserve O(1) access.\")")))
  :VOID)
