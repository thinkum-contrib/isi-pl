;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996-2000              | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-COLLECTIONS-STELLA-COLLECTION NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-VECTOR NULL)
(CL:DEFVAR KWD-COLLECTIONS-CPP NULL)
(CL:DEFVAR KWD-COLLECTIONS-FUNCTION NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-STARTUP-COLLECTIONS NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM (CL:SPECIAL *STELLA-MODULE* *MODULE*))

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF COLLECTION) OBJECT)
  "Return TRUE iff 'object' is a member of the collection 'self'."
  (CL:LET* ((I NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ I (%VALUE ITER-000))
    (CL:WHEN (EQL? I OBJECT) (CL:RETURN-FROM MEMBER? TRUE))))
  (CL:RETURN-FROM MEMBER? FALSE))

;;; (DEFUN (STELLA-COLLECTION? BOOLEAN) ...)

(CL:DEFUN STELLA-COLLECTION? (SELF)
  "Return TRUE if 'self' is a native collection."
  (CL:RETURN-FROM STELLA-COLLECTION?
   (ISA? SELF SGT-COLLECTIONS-STELLA-COLLECTION)))

;;; (DEFMETHOD (NO-DUPLICATES? BOOLEAN) ...)

(CL:DEFMETHOD NO-DUPLICATES? ((SELF COLLECTION))
  "Return TRUE if the collection 'self' forbids duplicate values."
  (CL:RETURN-FROM NO-DUPLICATES? FALSE))

;;; (DEFMETHOD (NO-DUPLICATES? BOOLEAN) ...)

(CL:DEFMETHOD NO-DUPLICATES? ((SELF SET))
  (CL:RETURN-FROM NO-DUPLICATES? TRUE))

;;; (DEFMETHOD (ORDERED? BOOLEAN) ...)

(CL:DEFMETHOD ORDERED? ((SELF COLLECTION))
  "Return TRUE if the collection 'self' is ordered."
  (CL:RETURN-FROM ORDERED? FALSE))

;;; (DEFMETHOD (ORDERED? BOOLEAN) ...)

(CL:DEFMETHOD ORDERED? ((SELF SEQUENCE))
  (CL:RETURN-FROM ORDERED? TRUE))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF SET))
  "Return TRUE if the set 'self' has no members."
  (CL:RETURN-FROM EMPTY? (CL:EQ (%THE-CONS-LIST SELF) NIL)))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF SET))
  "Return TRUE if the set 'self' has at least one member."
  (CL:RETURN-FROM NON-EMPTY? (CL:NOT (CL:EQ (%THE-CONS-LIST SELF) NIL))))

;;; (DEFUN (TERMINATE-SET? BOOLEAN) ...)

(CL:DEFUN TERMINATE-SET? (SELF)
  (CL:LET* ((CONS (%THE-CONS-LIST SELF)) (REST NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CONS NIL)) DO
    (CL:SETQ REST (%%REST CONS)) (FREE CONS) (CL:SETQ CONS REST))
   (CL:SETF (%THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM TERMINATE-SET? TRUE)))

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF SET) OBJECT)
  "Return TRUE iff 'object' is a member of the set 'self'.
Uses an 'eql?' test."
  (CL:LET* ((I NULL) (ITER-000 (%THE-CONS-LIST SELF)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ I (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (EQL? I OBJECT) (CL:RETURN-FROM MEMBER? TRUE))))
  (CL:RETURN-FROM MEMBER? FALSE))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF SET))
  (CL:RETURN-FROM LENGTH (LENGTH (%THE-CONS-LIST SELF))))

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF SET) VALUE)
  "Add 'value' to the set 'self'.  First checks for duplicate."
  (CL:WHEN (CL:NOT (MEMBER? SELF VALUE))
   (CL:SETF (%THE-CONS-LIST SELF) (CONS VALUE (%THE-CONS-LIST SELF))))
  :VOID)

;;; (DEFMETHOD (REMOVE SET) ...)

(CL:DEFMETHOD REMOVE ((SELF SET) VALUE)
  "Remove all entries in 'self' that match 'value'."
  (CL:SETF (%THE-CONS-LIST SELF) (REMOVE (%THE-CONS-LIST SELF) VALUE))
  (CL:RETURN-FROM REMOVE SELF))

;;; (DEFMETHOD (REVERSE SET) ...)

(CL:DEFMETHOD REVERSE ((SELF SET))
  (CL:SETF (%THE-CONS-LIST SELF) (REVERSE (%THE-CONS-LIST SELF)))
  (CL:RETURN-FROM REVERSE SELF))

;;; (DEFMETHOD (COPY (SET OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD COPY ((SELF SET))
  "Return a copy of the set 'self'.  The conses in the copy are
freshly allocated."
  (CL:LET* ((COPY (CREATE-OBJECT (PRIMARY-TYPE SELF))))
   (CL:SETF (%THE-CONS-LIST COPY) (COPY-CONS-LIST (%THE-CONS-LIST SELF)))
   (CL:RETURN-FROM COPY COPY)))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF SET))
  "Make 'self' an empty set."
  (CL:SETF (%THE-CONS-LIST SELF) NIL)
  :VOID)

;;; (DEFMETHOD (ALLOCATE-ITERATOR (SET-ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF SET))
  (CL:LET* ((ITERATOR (NEW-SET-ITERATOR)))
   (CL:SETF (%SET-ITERATOR-CURSOR ITERATOR) (%THE-CONS-LIST SELF))
   (CL:SETF (%SET-ITERATOR-COLLECTION ITERATOR) SELF)
   (CL:SETF (%FIRST-ITERATION? ITERATOR) TRUE)
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR)))

;;; (DEFUN (TERMINATE-SET-ITERATOR? BOOLEAN) ...)

(CL:DEFUN TERMINATE-SET-ITERATOR? (SELF)
  (CL:SETF (%SET-ITERATOR-CURSOR SELF) NIL)
  (CL:SETF (%SET-ITERATOR-COLLECTION SELF) NULL)
  (CL:RETURN-FROM TERMINATE-SET-ITERATOR? TRUE))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF SET-ITERATOR))
  (CL:IF (%FIRST-ITERATION? SELF)
   (CL:PROGN (CL:SETF (%FIRST-ITERATION? SELF) FALSE)
    (CL:SETF (%SET-ITERATOR-CURSOR SELF)
     (%THE-CONS-LIST (%SET-ITERATOR-COLLECTION SELF))))
   (CL:SETF (%SET-ITERATOR-CURSOR SELF)
    (%%REST (%SET-ITERATOR-CURSOR SELF))))
  (CL:SETF (%VALUE SELF) (%%VALUE (%SET-ITERATOR-CURSOR SELF)))
  (CL:RETURN-FROM NEXT? (CL:NOT (CL:EQ (%SET-ITERATOR-CURSOR SELF) NIL))))

;;; (DEFMETHOD (VALUE-SETTER OBJECT) ...)

(CL:DEFMETHOD VALUE-SETTER ((SELF SET-ITERATOR) VALUE)
  (CL:SETF (%%VALUE (%SET-ITERATOR-CURSOR SELF)) VALUE)
  (CL:SETF (%VALUE SELF) VALUE)
  (CL:RETURN-FROM VALUE-SETTER VALUE))

;;; (DEFMETHOD PRINT-VECTOR ...)

(CL:DEFMETHOD PRINT-VECTOR ((SELF VECTOR) STREAM)
  (CL:IF (CL:= (LENGTH SELF) 0) (%%PRINT-STREAM STREAM "|i|[]")
   (CL:LET* ((I 0) (LIMIT 9)) (CL:DECLARE (CL:TYPE CL:FIXNUM I LIMIT))
    (%%PRINT-STREAM STREAM "|i|[")
    (CL:LET*
     ((ELEMENT NULL) (VECTOR-000 SELF) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:PROGN
       (CL:SETQ ELEMENT
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
      (%%PRINT-STREAM STREAM ELEMENT) (CL:SETQ I (CL:1+ I))
      (CL:WHEN (CL:> I LIMIT) (CL:RETURN))
      (CL:WHEN (CL:< I (LENGTH SELF)) (%%PRINT-STREAM STREAM " "))))
    (CL:IF (CL:OR (CL:<= I LIMIT) (CL:= I (LENGTH SELF)))
     (%%PRINT-STREAM STREAM "]") (%%PRINT-STREAM STREAM " ...]"))))
  :VOID)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF VECTOR))
  "Return TRUE if 'self' has length 0."
  (CL:RETURN-FROM EMPTY? (CL:= (%ARRAY-SIZE SELF) 0)))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF VECTOR))
  "Return TRUE if 'self' has length > 0."
  (CL:RETURN-FROM NON-EMPTY? (> (%ARRAY-SIZE SELF) 0)))

;;; (DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIRST ((SELF VECTOR))
  (CL:RETURN-FROM FIRST
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) 0)))

;;; (DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD SECOND ((SELF VECTOR))
  (CL:RETURN-FROM SECOND
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) 1)))

;;; (DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD THIRD ((SELF VECTOR))
  (CL:RETURN-FROM THIRD
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) 2)))

;;; (DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FOURTH ((SELF VECTOR))
  (CL:RETURN-FROM FOURTH
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) 3)))

;;; (DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIFTH ((SELF VECTOR))
  (CL:RETURN-FROM FIFTH
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) 4)))

;;; (DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH ((SELF VECTOR) POSITION)
  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
  (CL:RETURN-FROM NTH
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) POSITION)))

;;; (DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LAST ((SELF VECTOR))
  "Return the last item in the vector 'self'."
  (CL:RETURN-FROM LAST
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF))
    (CL:THE CL:FIXNUM (CL:1- (%ARRAY-SIZE SELF))))))

;;; (DEFMETHOD (FIRST-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIRST-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM FIRST-SETTER
   (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (SECOND-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD SECOND-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM SECOND-SETTER
   (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (THIRD-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD THIRD-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM THIRD-SETTER
   (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION 2))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (FOURTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FOURTH-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM FOURTH-SETTER
   (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION 3))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (FIFTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIFTH-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM FIFTH-SETTER
   (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION 4))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH-SETTER ((SELF VECTOR) VALUE POSITION)
  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
  (CL:RETURN-FROM NTH-SETTER
   (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION POSITION))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (LAST-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LAST-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM LAST-SETTER
   (CL:LET
    ((SELF (%THE-ARRAY SELF)) (VALUE VALUE)
     (POSITION (CL:1- (%ARRAY-SIZE SELF))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF VECTOR))
  (CL:RETURN-FROM LENGTH (%ARRAY-SIZE SELF)))

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF VECTOR) OBJECT)
  (CL:LET* ((ARRAY (%THE-ARRAY SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR ARRAY))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH SELF))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:WHEN (EQL? (CL:AREF ARRAY I) OBJECT)
      (CL:RETURN-FROM MEMBER? TRUE))))
   (CL:RETURN-FROM MEMBER? FALSE)))

;;; (DEFMETHOD (POSITION INTEGER) ...)

(CL:DEFMETHOD POSITION ((SELF VECTOR) OBJECT START)
  "Return the position of 'object' within the vector
'self' (counting from zero); or return NULL if 'object' does not occur within 
'self' (uses an 'eql?' test).  If 'start' was supplied as non-NULL, only 
consider the portion starting at 'start', however, the returned position 
will always be relative to the entire vector."
  (CL:DECLARE (CL:TYPE CL:FIXNUM START))
  (CL:WHEN (NULL? START) (CL:SETQ START 0))
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 START)
    (UPPER-BOUND-000 (CL:1- (LENGTH SELF))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
   (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
    (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
    (CL:WHEN
     (EQL? (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) I) OBJECT)
     (CL:RETURN-FROM POSITION I))))
  (CL:RETURN-FROM POSITION NULL-INTEGER))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF VECTOR) OFFSET VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  (CL:WHEN (CL:>= OFFSET (%ARRAY-SIZE SELF))
   (CL:ERROR (NEW-STELLA-EXCEPTION "Out-of-bounds array access")))
  (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION OFFSET))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
    (CL:TYPE CL:FIXNUM POSITION))
   (CL:SETF (CL:AREF SELF POSITION) VALUE))
  :VOID)

;;; (DEFMETHOD (COPY (VECTOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD COPY ((SELF VECTOR))
  "Return a copy of the vector 'self'."
  (CL:LET*
   ((SIZE (%ARRAY-SIZE SELF)) (SOURCEARRAY (%THE-ARRAY SELF))
    (COPY (NEW-VECTOR SIZE)) (COPYARRAY (%THE-ARRAY COPY)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE)
    (CL:TYPE CL:SIMPLE-VECTOR SOURCEARRAY COPYARRAY))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- SIZE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:LET
      ((SELF COPYARRAY) (VALUE (CL:AREF SOURCEARRAY I)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:RETURN-FROM COPY COPY)))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF VECTOR))
  (CL:LET* ((SIZE (%ARRAY-SIZE SELF)) (ARRAY (%THE-ARRAY SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE) (CL:TYPE CL:SIMPLE-VECTOR ARRAY))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- SIZE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:LET ((SELF ARRAY) (VALUE NULL) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE)))))
  :VOID)

;;; (DEFUN (VECTOR VECTOR) ...)

(CL:DEFUN VECTOR (CL:&REST VALUES)
  "Return a vector containing 'values', in order."
  (CL:LET* ((VECTOR (NEW-VECTOR (CL:LENGTH VALUES))))
   (CL:LET* ((I NULL-INTEGER) (V NULL) (ITER-000 VALUES) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ V (CL:POP ITER-000))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:LET ((SELF (%THE-ARRAY VECTOR)) (VALUE V) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:RETURN-FROM VECTOR VECTOR)))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-VECTOR) OFFSET VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  (CL:WHEN (CL:>= OFFSET (%ARRAY-SIZE SELF))
   (CL:LET* ((SIZE (%ARRAY-SIZE SELF)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
    (CL:LOOP WHILE (CL:>= OFFSET SIZE) DO (CL:SETQ SIZE (CL:* 2 SIZE)))
    (RESIZE-VECTOR SELF SIZE)))
  (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION OFFSET))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
    (CL:TYPE CL:FIXNUM POSITION))
   (CL:SETF (CL:AREF SELF POSITION) VALUE))
  :VOID)

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-SYMBOL-ARRAY) OFFSET VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  (CL:WHEN (CL:>= OFFSET (%ARRAY-SIZE SELF))
   (CL:LET* ((SIZE (%ARRAY-SIZE SELF)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
    (CL:LOOP WHILE (CL:>= OFFSET SIZE) DO (CL:SETQ SIZE (CL:* 2 SIZE)))
    (RESIZE-VECTOR SELF SIZE)))
  (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION OFFSET))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
    (CL:TYPE CL:FIXNUM POSITION))
   (CL:SETF (CL:AREF SELF POSITION) VALUE))
  (CL:WHEN (CL:> OFFSET (%TOP-SYMBOL-OFFSET SELF))
   (CL:SETF (%TOP-SYMBOL-OFFSET SELF) OFFSET))
  :VOID)

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF VECTOR-SEQUENCE) VALUE)
  "Append 'value' to the END of the sequence 'self'.  
Resize the array if necessary."
  (CL:LET* ((OLDLENGTH (%SEQUENCE-LENGTH SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OLDLENGTH))
   (CL:WHEN (CL:= OLDLENGTH (%ARRAY-SIZE SELF))
    (RESIZE-VECTOR SELF
     (CL:+ (%ARRAY-SIZE SELF) (RESIZE-INCREMENT SELF))))
   (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE VALUE) (POSITION OLDLENGTH))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%SEQUENCE-LENGTH SELF) (CL:1+ OLDLENGTH)))
  :VOID)

;;; (DEFMETHOD (REMOVE VECTOR-SEQUENCE) ...)

(CL:DEFMETHOD REMOVE ((SELF VECTOR-SEQUENCE) VALUE)
  "Remove 'value' from the sequence 'self', and left shift
the values after it to close the gap."
  (CL:LET*
   ((ARRAY (%THE-ARRAY SELF)) (FIRSTSHIFTOFFSET -1)
    (LASTSHIFTOFFSET (CL:1- (%SEQUENCE-LENGTH SELF))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR ARRAY)
    (CL:TYPE CL:FIXNUM FIRSTSHIFTOFFSET LASTSHIFTOFFSET))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 LASTSHIFTOFFSET)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000))
     DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:WHEN (EQL? (CL:AREF ARRAY I) VALUE)
      (CL:SETQ FIRSTSHIFTOFFSET (CL:1+ I)) (CL:RETURN))))
   (CL:WHEN (CL:= FIRSTSHIFTOFFSET -1) (CL:RETURN-FROM REMOVE SELF))
   (CL:WHEN (CL:<= FIRSTSHIFTOFFSET LASTSHIFTOFFSET)
    (CL:LET*
     ((J NULL-INTEGER) (ITER-001 FIRSTSHIFTOFFSET)
      (UPPER-BOUND-001 LASTSHIFTOFFSET)
      (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 UPPER-BOUND-001 J))
     (CL:LOOP WHILE
      (CL:OR UNBOUNDED?-001 (CL:<= ITER-001 UPPER-BOUND-001)) DO
      (CL:PROGN (CL:SETQ J ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
      (CL:LET
       ((SELF ARRAY) (VALUE (CL:AREF ARRAY J)) (POSITION (CL:1- J)))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE)))))
   (CL:LET ((SELF ARRAY) (VALUE NULL) (POSITION LASTSHIFTOFFSET))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%SEQUENCE-LENGTH SELF) LASTSHIFTOFFSET)
   (CL:RETURN-FROM REMOVE SELF)))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF VECTOR-SEQUENCE))
  (CL:RETURN-FROM LENGTH (%SEQUENCE-LENGTH SELF)))

;;; (DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF VECTOR))
  (CL:LET* ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ITERATOR-OBJECT ITERATOR) SELF)
   (CL:SETF (%ITERATOR-INTEGER ITERATOR) 0)
   (CL:SETF (%ITERATOR-SECOND-INTEGER ITERATOR) (%ARRAY-SIZE SELF))
   (CL:SETF (%ITERATOR-NEXT-CODE ITERATOR) (CL:FUNCTION VECTOR-NEXT?))
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR)))

;;; (DEFUN (VECTOR-NEXT? BOOLEAN) ...)

(CL:DEFUN VECTOR-NEXT? (SELF)
  (CL:LET* ((CURSOR (%ITERATOR-INTEGER SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR))
   (CL:WHEN (CL:< CURSOR (%ITERATOR-SECOND-INTEGER SELF))
    (CL:SETF (%VALUE SELF)
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ITERATOR-OBJECT SELF)))
      CURSOR))
    (CL:SETF (%ITERATOR-INTEGER SELF) (CL:1+ CURSOR))
    (CL:RETURN-FROM VECTOR-NEXT? TRUE))
   (CL:RETURN-FROM VECTOR-NEXT? FALSE)))

;;; (DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD BUT-LAST ((SELF VECTOR))
  "Generate all but the last element of the vector 'self'."
  (CL:LET* ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ITERATOR-OBJECT ITERATOR) SELF)
   (CL:SETF (%ITERATOR-INTEGER ITERATOR) 0)
   (CL:SETF (%ITERATOR-SECOND-INTEGER ITERATOR)
    (CL:1- (%ARRAY-SIZE SELF)))
   (CL:SETF (%ITERATOR-NEXT-CODE ITERATOR) (CL:FUNCTION VECTOR-NEXT?))
   (CL:RETURN-FROM BUT-LAST ITERATOR)))

(CL:DEFUN HELP-STARTUP-COLLECTIONS1 ()
  (CL:PROGN
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF COLLECTION) (OBJECT (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE iff 'object' is a member of the collection 'self'.\")"
    (CL:FUNCTION MEMBER?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE-DUPLICATES (LIKE SELF)) ((SELF COLLECTION)) :DOCUMENTATION \"Return 'self' with duplicates removed.  Preserves the
original order of the remaining members.\" :PUBLIC? TRUE :ABSTRACT? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-COLLECTION?"
    "(DEFUN (STELLA-COLLECTION? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'self' is a native collection.\")"
    (CL:FUNCTION STELLA-COLLECTION?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NO-DUPLICATES? BOOLEAN) ((SELF COLLECTION)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the collection 'self' forbids duplicate values.\")"
    (CL:FUNCTION NO-DUPLICATES?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NO-DUPLICATES? BOOLEAN) ((SELF SET)) :PUBLIC? TRUE)"
    (CL:FUNCTION NO-DUPLICATES?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ORDERED? BOOLEAN) ((SELF COLLECTION)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the collection 'self' is ordered.\")"
    (CL:FUNCTION ORDERED?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ORDERED? BOOLEAN) ((SELF SEQUENCE)) :PUBLIC? TRUE)"
    (CL:FUNCTION ORDERED?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF SET)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the set 'self' has no members.\")"
    (CL:FUNCTION EMPTY?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF SET)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the set 'self' has at least one member.\")"
    (CL:FUNCTION NON-EMPTY?) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMINATE-SET?"
    "(DEFUN (TERMINATE-SET? BOOLEAN) ((SELF SET)))"
    (CL:FUNCTION TERMINATE-SET?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF SET) (OBJECT (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Return TRUE iff 'object' is a member of the set 'self'.
Uses an 'eql?' test.\" :PUBLIC? TRUE)" (CL:FUNCTION MEMBER?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF SET)) :PUBLIC? TRUE)"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT ((SELF SET) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Add 'value' to the set 'self'.  First checks for duplicate.\")"
    (CL:FUNCTION INSERT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE SET) ((SELF SET) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Remove all entries in 'self' that match 'value'.\")"
    (CL:FUNCTION REMOVE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REVERSE SET) ((SELF SET)) :PUBLIC? TRUE)"
    (CL:FUNCTION REVERSE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY (SET OF (LIKE (ANY-VALUE SELF)))) ((SELF SET)) :PUBLIC? TRUE :DOCUMENTATION \"Return a copy of the set 'self'.  The conses in the copy are
freshly allocated.\")" (CL:FUNCTION COPY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR ((SELF SET)) :PUBLIC? TRUE :DOCUMENTATION \"Make 'self' an empty set.\")"
    (CL:FUNCTION CLEAR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ALLOCATE-ITERATOR (SET-ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF SET)))"
    (CL:FUNCTION ALLOCATE-ITERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMINATE-SET-ITERATOR?"
    "(DEFUN (TERMINATE-SET-ITERATOR? BOOLEAN) ((SELF SET-ITERATOR)))"
    (CL:FUNCTION TERMINATE-SET-ITERATOR?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF SET-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (VALUE-SETTER OBJECT) ((SELF SET-ITERATOR) (VALUE (LIKE (ANY-VALUE SELF)))))"
    (CL:FUNCTION VALUE-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PRINT-VECTOR ((SELF VECTOR) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-VECTOR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF VECTOR)) :DOCUMENTATION \"Return TRUE if 'self' has length 0.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQL? (ARRAY-SIZE SELF) 0)))"
    (CL:FUNCTION EMPTY?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF VECTOR)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'self' has length > 0.\" :GLOBALLY-INLINE? TRUE (RETURN (> (ARRAY-SIZE SELF) 0)))"
    (CL:FUNCTION NON-EMPTY?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 0)))"
    (CL:FUNCTION FIRST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 1)))"
    (CL:FUNCTION SECOND) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 2)))"
    (CL:FUNCTION THIRD) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 3)))"
    (CL:FUNCTION FOURTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 4)))"
    (CL:FUNCTION FIFTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (POSITION INTEGER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH (THE-ARRAY SELF) POSITION)))"
    (CL:FUNCTION NTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :DOCUMENTATION \"Return the last item in the vector 'self'.\")"
    (CL:FUNCTION LAST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIRST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 0) VALUE)))"
    (CL:FUNCTION FIRST-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SECOND-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 1) VALUE)))"
    (CL:FUNCTION SECOND-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (THIRD-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 2) VALUE)))"
    (CL:FUNCTION THIRD-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FOURTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 3) VALUE)))"
    (CL:FUNCTION FOURTH-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIFTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 4) VALUE)))"
    (CL:FUNCTION FIFTH-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF))) (POSITION INTEGER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH (THE-ARRAY SELF) POSITION) VALUE)))"
    (CL:FUNCTION NTH-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LAST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION LAST-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF VECTOR)) :PUBLIC? TRUE)"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF VECTOR) (OBJECT OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION MEMBER?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (POSITION INTEGER) ((SELF VECTOR) (OBJECT OBJECT) (START INTEGER)) :DOCUMENTATION \"Return the position of 'object' within the vector
'self' (counting from zero); or return NULL if 'object' does not occur within 
'self' (uses an 'eql?' test).  If 'start' was supplied as non-NULL, only 
consider the portion starting at 'start', however, the returned position 
will always be relative to the entire vector.\" :PUBLIC? TRUE)"
    (CL:FUNCTION POSITION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF VECTOR) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))))"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY (VECTOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)) :DOCUMENTATION \"Return a copy of the vector 'self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COPY) NULL)
   (DEFINE-METHOD-OBJECT "(DEFMETHOD CLEAR ((SELF VECTOR)) :PUBLIC? TRUE)"
    (CL:FUNCTION CLEAR) NULL)
   (DEFINE-FUNCTION-OBJECT "VECTOR"
    "(DEFUN (VECTOR VECTOR) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a vector containing 'values', in order.\" :PUBLIC? TRUE)"
    (CL:FUNCTION VECTOR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-VECTOR) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-SYMBOL-ARRAY) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT ((SELF VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Append 'value' to the END of the sequence 'self'.  
Resize the array if necessary.\" :PUBLIC? TRUE)" (CL:FUNCTION INSERT)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE VECTOR-SEQUENCE) ((SELF VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Remove 'value' from the sequence 'self', and left shift
the values after it to close the gap.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REMOVE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF VECTOR-SEQUENCE)) :PUBLIC? TRUE)"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)))"
    (CL:FUNCTION ALLOCATE-ITERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "VECTOR-NEXT?"
    "(DEFUN (VECTOR-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION VECTOR-NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)) :DOCUMENTATION \"Generate all but the last element of the vector 'self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION BUT-LAST) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-COLLECTIONS"
    "(DEFUN STARTUP-COLLECTIONS () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-COLLECTIONS) NULL)
   (CL:LET*
    ((FUNCTION
      (LOOKUP-FUNCTION SYM-COLLECTIONS-STELLA-STARTUP-COLLECTIONS)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
     SYM-COLLECTIONS-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "Startup-Collections") NULL-STRING-WRAPPER)))
  :VOID)

(CL:DEFUN STARTUP-COLLECTIONS ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (CL:SETQ SGT-COLLECTIONS-STELLA-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION" NULL 1))
    (CL:SETQ SYM-COLLECTIONS-STELLA-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" NULL 0))
    (CL:SETQ KWD-COLLECTIONS-CPP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
    (CL:SETQ KWD-COLLECTIONS-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ SYM-COLLECTIONS-STELLA-STARTUP-COLLECTIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-COLLECTIONS" NULL 0))
    (CL:SETQ SYM-COLLECTIONS-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-COLLECTIONS1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (REGISTER-NATIVE-NAME SYM-COLLECTIONS-STELLA-VECTOR
     KWD-COLLECTIONS-CPP KWD-COLLECTIONS-FUNCTION)))
  :VOID)
