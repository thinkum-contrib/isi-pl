;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; translate-file.lisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2006      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-TRANSLATE-FILE-TRANSLATE NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-JAVA NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-COMMON-LISP NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-CPP NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-CPP-STANDALONE NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-IDL NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-DEFINE NULL)
(CL:DEFVAR SGT-TRANSLATE-FILE-STELLA-CONS NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-FINALIZE NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-WALK NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-TRANSLATE-WITH-COPYRIGHT-HEADER NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-WINDOWS NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-UNIX NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-MAC NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-ROOT-DIRECTORY NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-LISP-TRANSLATIONS NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-STELLA NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-KB NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-CPP-CODE NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-CPP-HEADER NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-C-CODE NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-C-HEADER NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-NONE NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-LISP-BINARY NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-USE-COMMON-LISP-STRUCTS NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-USE-COMMON-LISP-VECTOR-STRUCTS NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-LISP NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-DIRECTORY NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-OTHER NULL)
(CL:DEFVAR SYM-TRANSLATE-FILE-STELLA-SYSTEM-UNITS-ALIST NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-TWO-PASS? NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-FORCE-TRANSLATION? NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-PRODUCTION-SETTINGS? NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-DEVELOPMENT-SETTINGS? NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-WARN-ABOUT-MISSING-METHODS NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-WARN-ABOUT-UNDEFINED-METHODS NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-USE-HARDCODED-SYMBOLS NULL)
(CL:DEFVAR SYM-TRANSLATE-FILE-STELLA-STARTUP-TRANSLATE-FILE NULL)
(CL:DEFVAR SYM-TRANSLATE-FILE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *SAFETY* *GENSYM-COUNTER* TRUE-WRAPPER
  FALSE-WRAPPER NULL-INTEGER LOGICAL-HOST-SEPARATOR
  LOGICAL-DIRECTORY-SEPARATOR *CURRENT-STELLA-FEATURES* NIL *CONTEXT*
  *TRANSLATIONUNITS* *TRANSLATIONPHASE* *TRANSLATOROUTPUTLANGUAGE*
  *TRANSLATIONVERBOSITYLEVEL* STANDARD-OUTPUT *MODULE* STANDARD-WARNING EOL))

;;; (DEFGLOBAL *RECORD-SIGNATURES?* ...)

(CL:DEFVAR *RECORD-SIGNATURES?* CL:NIL
  "If `true', record object signatures into a persistent table.")

;;; (DEFGLOBAL *WALK-WITH-RECORDED-SIGNATURES?* ...)

(CL:DEFVAR *WALK-WITH-RECORDED-SIGNATURES?* CL:NIL
  "If `true', the walker will try to find previously recorded
signatures for referenced but undefined functions, methods, etc.")

;;; (DEFSPECIAL *USERECORDEDSIGNATURES?* ...)

(CL:DEFVAR *USERECORDEDSIGNATURES?* CL:NIL
  "If `true', `safe-lookup-slot' and `lookup-function' will
try to retrieve a previously recorded signature if normal lookup fails.")

;;; (DEFSPECIAL *ROOTSOURCEDIRECTORY* ...)

(CL:DEFVAR *ROOTSOURCEDIRECTORY* "PL:sources;")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *ROOTSOURCEDIRECTORY*))

;;; (DEFSPECIAL *ROOTNATIVEDIRECTORY* ...)

(CL:DEFVAR *ROOTNATIVEDIRECTORY* "PL:native;")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *ROOTNATIVEDIRECTORY*))

;;; (DEFSPECIAL *ROOTBINARYDIRECTORY* ...)

(CL:DEFVAR *ROOTBINARYDIRECTORY* "PL:bin;")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *ROOTBINARYDIRECTORY*))

;;; (DEFSPECIAL *SYSTEMDEFINITIONSDIRECTORY* ...)

(CL:DEFVAR *SYSTEMDEFINITIONSDIRECTORY* STELLA::NULL-STRING
  "Points to the directory containing the SYSTEMS file.")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *SYSTEMDEFINITIONSDIRECTORY*))

;;; (DEFUN (ROOT-SOURCE-DIRECTORY FILE-NAME) ...)

(CL:DEFUN ROOT-SOURCE-DIRECTORY ()
  (CL:RETURN-FROM ROOT-SOURCE-DIRECTORY
   (TRANSLATE-LOGICAL-PATHNAME *ROOTSOURCEDIRECTORY*)))

;;; (DEFUN (ROOT-NATIVE-DIRECTORY FILE-NAME) ...)

(CL:DEFUN ROOT-NATIVE-DIRECTORY ()
  (CL:RETURN-FROM ROOT-NATIVE-DIRECTORY
   (TRANSLATE-LOGICAL-PATHNAME *ROOTNATIVEDIRECTORY*)))

;;; (DEFUN (ROOT-BINARY-DIRECTORY FILE-NAME) ...)

(CL:DEFUN ROOT-BINARY-DIRECTORY ()
  (CL:RETURN-FROM ROOT-BINARY-DIRECTORY
   (TRANSLATE-LOGICAL-PATHNAME *ROOTBINARYDIRECTORY*)))

;;; (DEFUN (SYSTEM-DEFINITIONS-DIRECTORY FILE-NAME) ...)

(CL:DEFUN SYSTEM-DEFINITIONS-DIRECTORY ()
  (CL:IF (CL:NOT (CL:EQ *SYSTEMDEFINITIONSDIRECTORY* STELLA::NULL-STRING))
   (CL:RETURN-FROM SYSTEM-DEFINITIONS-DIRECTORY
    (TRANSLATE-LOGICAL-PATHNAME *SYSTEMDEFINITIONSDIRECTORY*))
   (CL:RETURN-FROM SYSTEM-DEFINITIONS-DIRECTORY
    (CONCATENATE (ROOT-SOURCE-DIRECTORY) "systems"))))

;;; (DEFSPECIAL *CURRENTSYSTEMDEFINITION* ...)

(CL:DEFVAR *CURRENTSYSTEMDEFINITION* NULL
  "Points to the current system.")

;;; (DEFSPECIAL *CURRENTSYSTEMDEFINITIONSUBDIRECTORY* ...)

(CL:DEFVAR *CURRENTSYSTEMDEFINITIONSUBDIRECTORY* ""
  "Points to a path from the root directory down
to a local directory containing sources, natives, or binaries.")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))

;;; (DEFUN (HANDLE-IN-MODULE-TREE BOOLEAN BOOLEAN) ...)

(CL:DEFUN HANDLE-IN-MODULE-TREE (TREE SEENINMODULE?)
  (CL:LET* ((OPERATOR (%%VALUE TREE)) (FIRSTARG NULL))
   (CL:COND
    ((SUBTYPE-OF-SYMBOL? (SAFE-PRIMARY-TYPE OPERATOR))
     (CL:PROGN
      (CL:LET*
       ((TEST-VALUE-000
         (CL:IF (%CASE-SENSITIVE? *MODULE*)
          (STRING-UPCASE (%SYMBOL-NAME OPERATOR)) (%SYMBOL-NAME OPERATOR))))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEST-VALUE-000))
       (CL:COND
        ((STRING-EQL? TEST-VALUE-000 "IN-PACKAGE")
         (CL:RETURN-FROM HANDLE-IN-MODULE-TREE
          (CL:VALUES CL:T SEENINMODULE?)))
        ((STRING-EQL? TEST-VALUE-000 "IN-MODULE")
         (CL:WHEN SEENINMODULE?
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-WARNING)
           (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
            (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
            (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING) EOL
             " Ignoring duplicate IN-MODULE declaration: `"
             (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
          (CL:RETURN-FROM HANDLE-IN-MODULE-TREE
           (CL:VALUES CL:T SEENINMODULE?)))
         (CL:SETQ FIRSTARG (%%VALUE (%%REST TREE)))
         (CL:COND
          ((SUBTYPE-OF-STRING? (SAFE-PRIMARY-TYPE FIRSTARG))
           (CL:PROGN (CHANGE-MODULE (%WRAPPER-VALUE FIRSTARG))
            (CL:SETQ SEENINMODULE? CL:T)))
          (CL:T
           (CL:LET* ((*PRINTREADABLY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-WARNING)
            (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
             (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
             (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING) EOL
              " Ignoring illegal IN-MODULE declaration: `"
              (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))))
         (CL:RETURN-FROM HANDLE-IN-MODULE-TREE
          (CL:VALUES CL:T SEENINMODULE?)))
        ((CL:OR (STRING-EQL? TEST-VALUE-000 "DEFMODULE")
          (STRING-EQL? TEST-VALUE-000 "VERBATIM")))
        (CL:T
         (CL:WHEN (CL:NOT SEENINMODULE?)
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-WARNING)
           (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
            (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
            (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING) EOL
             " Missing IN-MODULE declaration, translating into module STELLA."
             EOL)))
          (CHANGE-MODULE "STELLA") (CL:SETQ SEENINMODULE? CL:T)))))))
    (CL:T))
   (CL:RETURN-FROM HANDLE-IN-MODULE-TREE (CL:VALUES CL:NIL SEENINMODULE?))))

;;; (DEFUN TRANSLATE-AND-OUTPUT-UNITS-TO-FILE ...)

(CL:DEFUN TRANSLATE-AND-OUTPUT-UNITS-TO-FILE (FILE TARGETLANGUAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TARGETLANGUAGE))
  #+MCL
  (CL:CHECK-TYPE TARGETLANGUAGE CL:SIMPLE-STRING)
  (CL:SETQ *TRANSLATIONPHASE* KWD-TRANSLATE-FILE-TRANSLATE)
  (CL:COND ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA))
   (CL:T
    (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 1)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Translating `" FILE
      "' to `" TARGETLANGUAGE "'..." EOL))
    (TRANSLATE-ALL-UNITS)))
  (OUTPUT-ALL-UNITS-TO-FILE FILE)
  :VOID)

;;; (DEFUN OPERATE-ON-FILE ...)

(CL:DEFUN OPERATE-ON-FILE (FILE OPERATION)
  (CL:LET*
   ((TARGETLANGUAGE (%SYMBOL-NAME *TRANSLATOROUTPUTLANGUAGE*))
    (CURRENTMODULE *MODULE*) (CURRENTCONTEXT *CONTEXT*) (SEENINMODULE? CL:NIL)
    (SKIP? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TARGETLANGUAGE))
   (CL:SETQ FILE (TRANSLATE-LOGICAL-PATHNAME FILE))
   (CL:WHEN (CL:EQ OPERATION NULL)
    (CL:SETQ OPERATION KWD-TRANSLATE-FILE-TRANSLATE))
   (CL:LET*
    ((*TRANSLATIONPHASE* NULL) (*TRANSLATIONERRORS* 0)
     (*TRANSLATIONWARNINGS* 0) (*CURRENTFILE* (FILE-BASE-NAME FILE))
     (*MODULE* CURRENTMODULE) (*CONTEXT* CURRENTCONTEXT))
    (CL:DECLARE
     (CL:SPECIAL *TRANSLATIONPHASE* *TRANSLATIONERRORS* *TRANSLATIONWARNINGS*
      *CURRENTFILE* *MODULE* *CONTEXT*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *TRANSLATIONERRORS* *TRANSLATIONWARNINGS*)
     (CL:TYPE CL:SIMPLE-STRING *CURRENTFILE*))
    (CL:COND
     ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-COMMON-LISP)
      (CL:SETQ TARGETLANGUAGE "Common Lisp"))
     ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-CPP)
       (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-CPP-STANDALONE))
      (CL:SETQ TARGETLANGUAGE "C++"))
     ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-IDL)
      (CL:SETQ TARGETLANGUAGE "IDL"))
     ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)
      (CL:SETQ TARGETLANGUAGE "Java"))
     (CL:T))
    (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 1)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Processing `" FILE "':"
      EOL)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "*** Pass 1, generating objects..." EOL))
    (CL:LET* ((*TRANSIENTOBJECTS?* CL:T))
     (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
     (CL:LET*
      ((TREE NULL) (ITER-000 (S-EXPRESSIONS (NEW-INPUT-FILE-STREAM FILE))))
      (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ TREE (%VALUE ITER-000))
       (CL:LET* ((*TRANSIENTOBJECTS?* CL:NIL))
        (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
        (CL:COND
         ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-TRANSLATE-FILE-STELLA-CONS)
          (CL:PROGN
           (CL:MULTIPLE-VALUE-SETQ (SKIP? SEENINMODULE?)
            (HANDLE-IN-MODULE-TREE TREE SEENINMODULE?))
           (CL:WHEN (CL:NOT SKIP?)
            (CL:LET* ((*TRANSLATIONPHASE* KWD-TRANSLATE-FILE-DEFINE))
             (CL:DECLARE (CL:SPECIAL *TRANSLATIONPHASE*))
             (WALK-TOP-LEVEL-TREE TREE CL:T)))))
         (CL:T))))))
    (REVERSE *TRANSLATIONUNITS*)
    (CL:WHEN (CL:NOT (CL:EQ OPERATION KWD-TRANSLATE-FILE-DEFINE))
     (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 1)
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "*** Pass 2, finalizing objects..." EOL))
     (CL:SETQ *TRANSLATIONPHASE* KWD-TRANSLATE-FILE-FINALIZE)
     (FINALIZE-CLASSES-AND-SLOTS)
     (CL:WHEN (CL:NOT (CL:EQ OPERATION KWD-TRANSLATE-FILE-FINALIZE))
      (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 1)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
        "*** Pass 3, walking objects..." EOL))
      (CL:SETQ *TRANSLATIONPHASE* KWD-TRANSLATE-FILE-WALK)
      (CL:WHEN
       (CL:NOT
        (CL:OR (USE-HARDCODED-SYMBOLS?)
         (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)))
       (CLEAR-SYMBOL-REGISTRY))
      (CL:LET* ((*USERECORDEDSIGNATURES?* *WALK-WITH-RECORDED-SIGNATURES?*))
       (CL:DECLARE (CL:SPECIAL *USERECORDEDSIGNATURES?*))
       (WALK-ALL-PHASE-ONE-UNITS))
      (CL:WHEN (CL:NOT (CL:EQ OPERATION KWD-TRANSLATE-FILE-WALK))
       (TRANSLATE-AND-OUTPUT-UNITS-TO-FILE FILE TARGETLANGUAGE))
      (CL:WHEN *RECORD-SIGNATURES?*
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
        "Recording object signatures..." EOL)
       (RECORD-SIGNATURES-OF-ALL-UNITS FILE))))
    (SUMMARIZE-TRANSLATION-ERRORS)))
  :VOID)

;;; (DEFUN CLEAN-UP-TRANSLATION-UNITS-SPECIAL ...)

(CL:DEFUN CLEAN-UP-TRANSLATION-UNITS-SPECIAL ()
  (CL:LET* ((UNIT NULL) (ITER-000 (%THE-CONS-LIST *TRANSLATIONUNITS*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ UNIT (%%VALUE ITER-000)) (FREE UNIT)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CLEAR *TRANSLATIONUNITS*)
  (SWEEP-TRANSIENTS)
  :VOID)

;;; (DEFUN TRANSLATE-FILE ...)

(CL:DEFUN TRANSLATE-FILE (FILE OUTPUTLANGUAGE ASPARTOFSYSTEM?)
  (CL:LET* ((MODE KWD-TRANSLATE-FILE-TRANSLATE))
   (CL:LET*
    ((*JAVA-INDENT-CHARS* 0) (*IDL-INDENT-CHARS* 0) (*CPP-INDENT-CHARS* 0))
    (CL:DECLARE
     (CL:SPECIAL *JAVA-INDENT-CHARS* *IDL-INDENT-CHARS* *CPP-INDENT-CHARS*))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM *JAVA-INDENT-CHARS* *IDL-INDENT-CHARS*
      *CPP-INDENT-CHARS*))
    (CL:COND
     ((CL:EQ OUTPUTLANGUAGE KWD-TRANSLATE-FILE-JAVA)
      (CL:WHEN ASPARTOFSYSTEM? (CL:SETQ MODE KWD-TRANSLATE-FILE-WALK)))
     (CL:T))
    (CL:IF ASPARTOFSYSTEM? (OPERATE-ON-FILE FILE MODE)
     (CL:LET*
      ((*TRANSLATOROUTPUTLANGUAGE* *TRANSLATOROUTPUTLANGUAGE*)
       (*TRANSLATIONUNITS* (NEW-LIST)))
      (CL:DECLARE (CL:SPECIAL *TRANSLATOROUTPUTLANGUAGE* *TRANSLATIONUNITS*))
      (%SET-TRANSLATOR-OUTPUT-LANGUAGE OUTPUTLANGUAGE)
      (OPERATE-ON-FILE FILE MODE)
      (CL:COND ((CL:EQ OUTPUTLANGUAGE KWD-TRANSLATE-FILE-CPP-STANDALONE))
       (CL:T (CLEAN-UP-TRANSLATION-UNITS-SPECIAL)))))))
  :VOID)

;;; (DEFUN OUTPUT-ALL-UNITS-TO-FILE ...)

(CL:DEFUN OUTPUT-ALL-UNITS-TO-FILE (SOURCEFILE)
  (CL:COND
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-COMMON-LISP)
    (CL-OUTPUT-ALL-UNITS-TO-FILE SOURCEFILE))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)
    (CL:LET* ((*JAVA-INDENT-CHARS* 0))
     (CL:DECLARE (CL:SPECIAL *JAVA-INDENT-CHARS*))
     (CL:DECLARE (CL:TYPE CL:FIXNUM *JAVA-INDENT-CHARS*))
     (JAVA-OUTPUT-ALL-UNITS-TO-FILE)))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-IDL)
    (CL:LET* ((*IDL-INDENT-CHARS* 0))
     (CL:DECLARE (CL:SPECIAL *IDL-INDENT-CHARS*))
     (CL:DECLARE (CL:TYPE CL:FIXNUM *IDL-INDENT-CHARS*))
     (IDL-OUTPUT-ALL-UNITS-TO-FILE SOURCEFILE)))
   ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-CPP)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-CPP-STANDALONE))
    (CL:LET* ((*CPP-INDENT-CHARS* 0))
     (CL:DECLARE (CL:SPECIAL *CPP-INDENT-CHARS*))
     (CL:DECLARE (CL:TYPE CL:FIXNUM *CPP-INDENT-CHARS*))
     (CPP-OUTPUT-ALL-UNITS-TO-FILE SOURCEFILE)))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
      *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  :VOID)

;;; (DEFUN RECORD-SIGNATURES-OF-ALL-UNITS ...)

(CL:DEFUN RECORD-SIGNATURES-OF-ALL-UNITS (SOURCEFILE)
  (CL:SETQ SOURCEFILE SOURCEFILE)
  :VOID)

;;; (DEFUN (TRANSLATE-WITH-COPYRIGHT-HEADER? BOOLEAN) ...)

(CL:DEFUN TRANSLATE-WITH-COPYRIGHT-HEADER? ()
  (CL:RETURN-FROM TRANSLATE-WITH-COPYRIGHT-HEADER?
   (MEMB? *CURRENT-STELLA-FEATURES*
    KWD-TRANSLATE-FILE-TRANSLATE-WITH-COPYRIGHT-HEADER)))

;;; (DEFUN OUTPUT-COPYRIGHT-HEADER ...)

(CL:DEFUN OUTPUT-COPYRIGHT-HEADER (STREAM)
  (CL:WHEN
   (CL:OR (CL:NOT (TRANSLATE-WITH-COPYRIGHT-HEADER?))
    (CL:EQ *CURRENTSYSTEMDEFINITION* NULL)
    (CL:EQ (%BANNER *CURRENTSYSTEMDEFINITION*) STELLA::NULL-STRING))
   (CL:RETURN-FROM OUTPUT-COPYRIGHT-HEADER))
  (CL:COND
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-COMMON-LISP)
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "#|" EOL))
   ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-CPP)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-CPP-STANDALONE))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "/*" EOL))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
      *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:LET*
   ((SUBSTITUTION-LIST (NEW-KEY-VALUE-LIST))
    (BSTREAM
     (MAKE-TOKENIZER-STRING-STREAM (%BANNER *CURRENTSYSTEMDEFINITION*))))
   (FILL-IN-DATE-SUBSTITUTION SUBSTITUTION-LIST)
   (SUBSTITUTE-TEMPLATE-VARIABLES-TO-STREAM BSTREAM STREAM SUBSTITUTION-LIST))
  (CL:COND
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-COMMON-LISP)
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "|#"))
   ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-CPP)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-CPP-STANDALONE))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "*/"))
   (CL:T
    (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
      *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))
  (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL EOL)
  :VOID)

;;; (DEFUN OUTPUT-FILE-HEADER ...)

(CL:DEFUN OUTPUT-FILE-HEADER (STREAM FILE)
  (CL:COND
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-COMMON-LISP)
    (CL-OUTPUT-FILE-HEADER STREAM FILE CL:T))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)
    (JAVA-OUTPUT-FILE-HEADER STREAM FILE))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-CPP)
    (CPP-OUTPUT-FILE-HEADER STREAM FILE))
   (CL:T (CL-OUTPUT-FILE-HEADER STREAM FILE CL:NIL)))
  :VOID)

;;; (DEFGLOBAL *OS* ...)

(CL:DEFVAR *OS* NULL
  "The operating system we are running on.  Currently,
either :UNIX, :WINDOWS, or :MAC.  Note that on the Mac OS X, the
OS can be either :UNIX or :MAC, depending on which file naming 
conventions are being observed by the software.")

;;; (DEFUN (OPERATING-SYSTEM KEYWORD) ...)

(CL:DEFUN OPERATING-SYSTEM ()
  (CL:COND
   ((CL:OR (PROBE-FILE? "C:\\AUTOEXEC.BAT") (PROBE-FILE? "C:\\IO.SYS")
     (PROBE-FILE? "C:\\BOOT.INI"))
    (CL:RETURN-FROM OPERATING-SYSTEM KWD-TRANSLATE-FILE-WINDOWS))
   ((CL:MEMBER :UNIX CL:*FEATURES*)
    (CL:RETURN-FROM OPERATING-SYSTEM KWD-TRANSLATE-FILE-UNIX))
   (CL:T (CL:RETURN-FROM OPERATING-SYSTEM KWD-TRANSLATE-FILE-MAC))))

;;; (DEFUN (DIRECTORY-SEPARATOR CHARACTER) ...)

(CL:DEFUN DIRECTORY-SEPARATOR ()
  (CL:LET* ((SEPARATOR #\?))
   (CL:LET ((NAME (CL:NAMESTRING (CL:MAKE-PATHNAME :DIRECTORY '(:ABSOLUTE "foo")))))
                        (CL:SETQ SEPARATOR (CL:CHAR NAME (CL:1- (CL:LENGTH NAME)))))
   (CL:RETURN-FROM DIRECTORY-SEPARATOR SEPARATOR)))

;;; (DEFUN (DIRECTORY-SEPARATOR-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION () CL:SIMPLE-STRING) DIRECTORY-SEPARATOR-STRING))
(CL:DEFUN DIRECTORY-SEPARATOR-STRING ()
  (CL:RETURN-FROM DIRECTORY-SEPARATOR-STRING
   (MAKE-STRING 1 (DIRECTORY-SEPARATOR))))

;;; (DEFUN (DIRECTORY-SEPARATOR-FOR-FILE CHARACTER) ...)

(CL:DEFUN DIRECTORY-SEPARATOR-FOR-FILE (FILE)
  (CL:IF (LOGICAL-PATHNAME? FILE)
   (CL:RETURN-FROM DIRECTORY-SEPARATOR-FOR-FILE LOGICAL-DIRECTORY-SEPARATOR)
   (CL:RETURN-FROM DIRECTORY-SEPARATOR-FOR-FILE (DIRECTORY-SEPARATOR))))

;;; (DEFCONSTANT TYPE-SEPARATOR ...)

(CL:DEFVAR TYPE-SEPARATOR #\.)

;;; (DEFUN (FILE-NAME-DIRECTORY FILE-NAME) ...)

(CL:DEFUN FILE-NAME-DIRECTORY (FILE)
  "Return the directory component of `file' including the final
directory separator or the empty string if `file' does not include a directory.
Note that for purposes of this function, a logical host is considered part of
the directory portion of `file'"
  (CL:LET*
   ((START 0) (LENGTH (CL:THE CL:FIXNUM (CL:LENGTH FILE)))
    (SEPARATOR (DIRECTORY-SEPARATOR-FOR-FILE FILE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM START LENGTH))
   (CL:WHEN (LOGICAL-PATHNAME? FILE)
    (CL:SETQ START (CL:1+ (POSITION FILE LOGICAL-HOST-SEPARATOR 0))))
   (CL:LOOP WHILE
    (CL:AND (CL:< START LENGTH) (DEFINED? (POSITION FILE SEPARATOR START))) DO
    (CL:SETQ START (CL:1+ (POSITION FILE SEPARATOR START))))
   (CL:RETURN-FROM FILE-NAME-DIRECTORY (SUBSEQUENCE FILE 0 START))))

;;; (DEFUN (DIRECTORY-FILE-NAME FILE-NAME) ...)

(CL:DEFUN DIRECTORY-FILE-NAME (DIRECTORY)
  "Return `directory' as a file name, i.e., without a terminating
directory separator."
  (CL:LET*
   ((SEPARATOR (DIRECTORY-SEPARATOR-FOR-FILE DIRECTORY))
    (LAST (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH DIRECTORY)))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LAST))
   (CL:IF
    (CL:AND (CL:>= LAST 0)
     (CL:EQL
      (CL:LET ((SELF DIRECTORY) (POSITION LAST))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)))
      SEPARATOR))
    (CL:RETURN-FROM DIRECTORY-FILE-NAME (SUBSEQUENCE DIRECTORY 0 LAST))
    (CL:RETURN-FROM DIRECTORY-FILE-NAME DIRECTORY))))

;;; (DEFUN (FILE-NAME-AS-DIRECTORY FILE-NAME) ...)

(CL:DEFUN FILE-NAME-AS-DIRECTORY (FILE)
  "Return `file' interpreted as a directory, i.e., with a
terminating directory separator.  If `file' is the empty string simply
return the empty string, i.e., interpret it as the current directory instead
of the root directory."
  (CL:LET*
   ((SEPARATOR (DIRECTORY-SEPARATOR-FOR-FILE FILE))
    (LAST (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH FILE)))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LAST))
   (CL:IF
    (CL:OR (CL:< LAST 0)
     (CL:EQL
      (CL:LET ((SELF FILE) (POSITION LAST))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)))
      SEPARATOR))
    (CL:RETURN-FROM FILE-NAME-AS-DIRECTORY FILE)
    (CL:RETURN-FROM FILE-NAME-AS-DIRECTORY
     (CONCATENATE FILE (MAKE-STRING 1 SEPARATOR))))))

;;; (DEFUN (DIRECTORY-PARENT-DIRECTORY FILE-NAME) ...)

(CL:DEFUN DIRECTORY-PARENT-DIRECTORY (DIRECTORY LEVEL)
  "Return the `level'-th parent directory component of `directory'
including the final directory separator, or the empty string if `directory' does
not have that many parents."
  (CL:DECLARE (CL:TYPE CL:FIXNUM LEVEL))
  #+MCL
  (CL:CHECK-TYPE LEVEL CL:FIXNUM)
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 LEVEL)
    (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
   (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
    (CL:SETQ I ITER-000) (CL:SETQ I I)
    (CL:SETQ DIRECTORY (FILE-NAME-DIRECTORY (DIRECTORY-FILE-NAME DIRECTORY)))
    (CL:SETQ ITER-000 (CL:1+ ITER-000))))
  (CL:RETURN-FROM DIRECTORY-PARENT-DIRECTORY DIRECTORY))

;;; (DEFUN (FILE-NAME-WITHOUT-DIRECTORY FILE-NAME) ...)

(CL:DEFUN FILE-NAME-WITHOUT-DIRECTORY (FILE)
  "Return the file name portion of `file' by removing any
directory and logical host components."
  (CL:LET* ((START 0) (SEPARATOR (DIRECTORY-SEPARATOR-FOR-FILE FILE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM START))
   (CL:SETQ FILE (LOGICAL-PATHNAME-WITHOUT-HOST FILE))
   (CL:LOOP WHILE (DEFINED? (POSITION FILE SEPARATOR START)) DO
    (CL:SETQ START (CL:1+ (POSITION FILE SEPARATOR START))))
   (CL:RETURN-FROM FILE-NAME-WITHOUT-DIRECTORY
    (SUBSEQUENCE FILE START NULL-INTEGER))))

;;; (DEFUN (FILE-NAME-WITHOUT-EXTENSION FILE-NAME) ...)

(CL:DEFUN FILE-NAME-WITHOUT-EXTENSION (FILE)
  "Remove `file's extension (or type) if there is any and
return the result."
  (CL:LET* ((START 0) (END NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM START END))
   (CL:LOOP WHILE (DEFINED? (POSITION FILE TYPE-SEPARATOR START)) DO
    (CL:SETQ END (POSITION FILE TYPE-SEPARATOR START))
    (CL:SETQ START (CL:1+ END)))
   (CL:RETURN-FROM FILE-NAME-WITHOUT-EXTENSION (SUBSEQUENCE FILE 0 END))))

;;; (DEFUN (FILE-EXTENSION STRING) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) FILE-EXTENSION))
(CL:DEFUN FILE-EXTENSION (FILE)
  "Return `file's extension (or type) if it has any including
the separator character."
  (CL:LET* ((START 0) (END NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM START END))
   (CL:LOOP WHILE (DEFINED? (POSITION FILE TYPE-SEPARATOR START)) DO
    (CL:SETQ END (POSITION FILE TYPE-SEPARATOR START))
    (CL:SETQ START (CL:1+ END)))
   (CL:IF (NULL? END) (CL:RETURN-FROM FILE-EXTENSION STELLA::NULL-STRING)
    (CL:RETURN-FROM FILE-EXTENSION (SUBSEQUENCE FILE END NULL-INTEGER)))))

;;; (DEFUN (FILE-BASE-NAME FILE-NAME) ...)

(CL:DEFUN FILE-BASE-NAME (FILE)
  "Remove `file's directory (including logical host) and
extension components and return the result."
  (CL:RETURN-FROM FILE-BASE-NAME
   (FILE-NAME-WITHOUT-EXTENSION (FILE-NAME-WITHOUT-DIRECTORY FILE))))

;;; (DEFCONSTANT LOGICAL-DIRECTORY-SEPARATOR ...)

(CL:DEFVAR LOGICAL-DIRECTORY-SEPARATOR #\;)

;;; (DEFCONSTANT LOGICAL-HOST-SEPARATOR ...)

(CL:DEFVAR LOGICAL-HOST-SEPARATOR #\:)

;;; (DEFGLOBAL *LOGICAL-HOST-TABLE* ...)

(CL:DEFVAR *LOGICAL-HOST-TABLE* NULL)

;;; (DEFUN DEFINE-LOGICAL-HOST-PROPERTY ...)

(CL:DEFUN DEFINE-LOGICAL-HOST-PROPERTY (HOST PROPERTY VALUE)
  "Define `property' with `value' for the logical host `host'.
As a side-effect, this also defines `host' as a logical host (both
`property' and `value' can be supplied as NULL).  If :ROOT-DIRECTORY
is specified, all pathnames with `host' are assumed to be relative to
that directory (even if they are absolute) and will be rerooted upon
translation.  :ROOT-DIRECTORY can be a logical or physical pathname.
If :LISP-TRANSLATIONS is specified, those will be used verbatimely as
the value of `(CL:logical-pathname-translations host)' if we are
running in Lisp, which allows us to depend on the native
`CL:translate-logical-pathname' for more complex translation operations."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  (CL:SETQ HOST (STRING-UPCASE HOST))
  (CL:LET* ((PROPERTIES (LOOKUP *LOGICAL-HOST-TABLE* HOST)))
   (CL:WHEN (CL:EQ PROPERTIES NULL) (CL:SETQ PROPERTIES (NEW-KEY-VALUE-LIST))
    (INSERT-AT *LOGICAL-HOST-TABLE* HOST PROPERTIES))
   (CL:WHEN (CL:NOT (CL:EQ PROPERTY NULL))
    (CL:COND
     ((CL:EQ PROPERTY KWD-TRANSLATE-FILE-ROOT-DIRECTORY)
      (INSERT-AT PROPERTIES PROPERTY NULL)
      (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
       (INSERT-AT PROPERTIES PROPERTY
        (WRAP-STRING
         (TRANSLATE-LOGICAL-PATHNAME
          (FILE-NAME-AS-DIRECTORY (%WRAPPER-VALUE VALUE)))))))
     ((CL:EQ PROPERTY KWD-TRANSLATE-FILE-LISP-TRANSLATIONS)
      (INSERT-AT PROPERTIES PROPERTY VALUE))
     (CL:T (CL:WARN "Illegal host property: `~A'" PROPERTY)))))
  :VOID)

;;; (DEFUN (LOOKUP-LOGICAL-HOST-PROPERTY OBJECT) ...)

(CL:DEFUN LOOKUP-LOGICAL-HOST-PROPERTY (HOST PROPERTY)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  (CL:SETQ HOST (STRING-UPCASE HOST))
  (CL:LET* ((PROPERTIES (LOOKUP *LOGICAL-HOST-TABLE* HOST)))
   (CL:IF (CL:EQ PROPERTIES NULL)
    (CL:RETURN-FROM LOOKUP-LOGICAL-HOST-PROPERTY NULL)
    (CL:RETURN-FROM LOOKUP-LOGICAL-HOST-PROPERTY
     (LOOKUP PROPERTIES PROPERTY)))))

;;; (DEFUN (LOGICAL-HOST? BOOLEAN) ...)

(CL:DEFUN LOGICAL-HOST? (HOST)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  (CL:RETURN-FROM LOGICAL-HOST?
   (CL:NOT (CL:EQ (LOOKUP *LOGICAL-HOST-TABLE* (STRING-UPCASE HOST)) NULL))))

;;; (DEFUN (LOGICAL-PATHNAME? BOOLEAN) ...)

(CL:DEFUN LOGICAL-PATHNAME? (PATHNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:LET* ((HOST (GET-LOGICAL-HOST-NAME PATHNAME)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST))
   (CL:RETURN-FROM LOGICAL-PATHNAME?
    (CL:AND (CL:NOT (CL:EQ HOST STELLA::NULL-STRING)) (LOGICAL-HOST? HOST)))))

;;; (DEFUN (ABSOLUTE-PATHNAME? BOOLEAN) ...)

(CL:DEFUN ABSOLUTE-PATHNAME? (PATHNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:LET* ((SEPARATOR (DIRECTORY-SEPARATOR)))
   (CL:WHEN (LOGICAL-PATHNAME? PATHNAME)
    (CL:SETQ SEPARATOR LOGICAL-DIRECTORY-SEPARATOR))
   (CL:SETQ PATHNAME (LOGICAL-PATHNAME-WITHOUT-HOST PATHNAME))
   (CL:RETURN-FROM ABSOLUTE-PATHNAME?
    (CL:AND (CL:> (CL:THE CL:FIXNUM (CL:LENGTH PATHNAME)) 0)
     (CL:EQL
      (CL:LET ((SELF PATHNAME) (POSITION 0))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)))
      SEPARATOR)))))

;;; (DEFUN (GET-LOGICAL-HOST-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  GET-LOGICAL-HOST-NAME))
(CL:DEFUN GET-LOGICAL-HOST-NAME (PATHNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:LET* ((SEPARATORPOS (POSITION PATHNAME LOGICAL-HOST-SEPARATOR 0)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SEPARATORPOS))
   (CL:IF (CL:AND (DEFINED? SEPARATORPOS) (CL:>= SEPARATORPOS 1))
    (CL:RETURN-FROM GET-LOGICAL-HOST-NAME
     (SUBSEQUENCE PATHNAME 0 SEPARATORPOS))
    (CL:RETURN-FROM GET-LOGICAL-HOST-NAME STELLA::NULL-STRING))))

;;; (DEFUN (LOGICAL-PATHNAME-WITHOUT-HOST STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  LOGICAL-PATHNAME-WITHOUT-HOST))
(CL:DEFUN LOGICAL-PATHNAME-WITHOUT-HOST (PATHNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:LET* ((HOSTNAME (GET-LOGICAL-HOST-NAME PATHNAME)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOSTNAME))
   (CL:IF (CL:EQ HOSTNAME STELLA::NULL-STRING)
    (CL:RETURN-FROM LOGICAL-PATHNAME-WITHOUT-HOST PATHNAME)
    (CL:RETURN-FROM LOGICAL-PATHNAME-WITHOUT-HOST
     (SUBSEQUENCE PATHNAME (CL:1+ (CL:THE CL:FIXNUM (CL:LENGTH HOSTNAME)))
      NULL-INTEGER)))))

;;; (DEFUN (TRANSLATE-LOGICAL-PATHNAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  TRANSLATE-LOGICAL-PATHNAME))
(CL:DEFUN TRANSLATE-LOGICAL-PATHNAME (PATHNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:NOT (LOGICAL-PATHNAME? PATHNAME))
   (CL:RETURN-FROM TRANSLATE-LOGICAL-PATHNAME PATHNAME))
  (CL:LET*
   ((HOST (GET-LOGICAL-HOST-NAME PATHNAME)) (TRANSLATEDPATHNAME PATHNAME))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST TRANSLATEDPATHNAME))
   (CL:LET*
    ((TRANSLATIONS
      (LOOKUP-LOGICAL-HOST-PROPERTY HOST
       KWD-TRANSLATE-FILE-LISP-TRANSLATIONS))
     (LTRANSLATIONS
      (CL:IGNORE-ERRORS (CL:LOGICAL-PATHNAME-TRANSLATIONS HOST))))
    (CL:WHEN
     (CL:OR (CL:NOT (CL:EQ TRANSLATIONS NULL))
      (CL:NOT (CL:EQ LTRANSLATIONS NIL)))
     (CL:progn
              (CL:unless ltranslations
                (CL:setf (CL:logical-pathname-translations host)
                  (lispify translations)))
              (setq translatedPathname
                (CL:namestring (%%translate-logical-pathname pathName))))
     (CL:RETURN-FROM TRANSLATE-LOGICAL-PATHNAME TRANSLATEDPATHNAME)))
   (CL:SETQ TRANSLATEDPATHNAME
    (SUBSTITUTE (LOGICAL-PATHNAME-WITHOUT-HOST PATHNAME) (DIRECTORY-SEPARATOR)
     LOGICAL-DIRECTORY-SEPARATOR))
   (CL:LET*
    ((ROOTDIRECTORY
      (LOOKUP-LOGICAL-HOST-PROPERTY HOST KWD-TRANSLATE-FILE-ROOT-DIRECTORY)))
    (CL:WHEN (CL:NOT (CL:EQ ROOTDIRECTORY NULL))
     (CL:WHEN (ABSOLUTE-PATHNAME? TRANSLATEDPATHNAME)
      (CL:SETQ TRANSLATEDPATHNAME
       (SUBSEQUENCE TRANSLATEDPATHNAME 1 NULL-INTEGER)))
     (CL:SETQ TRANSLATEDPATHNAME
      (CONCATENATE (%WRAPPER-VALUE ROOTDIRECTORY) TRANSLATEDPATHNAME))))
   (CL:RETURN-FROM TRANSLATE-LOGICAL-PATHNAME TRANSLATEDPATHNAME)))

;;; (DEFUN (UNLOGICALIZE-PATHNAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  UNLOGICALIZE-PATHNAME))
(CL:DEFUN UNLOGICALIZE-PATHNAME (PATHNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM UNLOGICALIZE-PATHNAME (TRANSLATE-LOGICAL-PATHNAME PATHNAME)))

;;; (DEFUN (MERGE-FILE-NAMES FILE-NAME) ...)

(CL:DEFUN MERGE-FILE-NAMES (BASEFILE DEFAULTS)
  "Parse `baseFile', supply any missing components from
`defaults' if supplied and return the result."
  (CL:LET*
   ((BASESEPARATOR (DIRECTORY-SEPARATOR-FOR-FILE BASEFILE))
    (BASEHOST (GET-LOGICAL-HOST-NAME BASEFILE))
    (BASEDIRECTORY
     (LOGICAL-PATHNAME-WITHOUT-HOST (FILE-NAME-DIRECTORY BASEFILE)))
    (BASENAME (FILE-BASE-NAME BASEFILE))
    (BASEEXTENSION (FILE-EXTENSION BASEFILE))
    (DEFAULTSSEPARATOR (DIRECTORY-SEPARATOR-FOR-FILE DEFAULTS))
    (MERGED? CL:NIL) (RESULT NULL))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING BASEHOST BASEDIRECTORY BASEEXTENSION))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQL BASESEPARATOR DEFAULTSSEPARATOR))
     (MEMBER? BASEFILE BASESEPARATOR) (MEMBER? DEFAULTS DEFAULTSSEPARATOR))
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "merge-file-names: base file and defaults use different syntax")))
   (CL:WHEN (CL:EQ BASEHOST STELLA::NULL-STRING)
    (CL:SETQ BASEHOST (GET-LOGICAL-HOST-NAME DEFAULTS))
    (CL:SETQ MERGED?
     (CL:OR MERGED? (CL:NOT (CL:EQ BASEHOST STELLA::NULL-STRING)))))
   (CL:WHEN (STRING-EQL? BASEDIRECTORY "")
    (CL:SETQ BASEDIRECTORY
     (LOGICAL-PATHNAME-WITHOUT-HOST (FILE-NAME-DIRECTORY DEFAULTS)))
    (CL:SETQ MERGED? (CL:OR MERGED? (CL:NOT (STRING-EQL? BASEDIRECTORY "")))))
   (CL:WHEN (CL:EQ BASENAME STELLA::NULL-STRING)
    (CL:SETQ BASENAME (FILE-BASE-NAME DEFAULTS))
    (CL:SETQ MERGED?
     (CL:OR MERGED? (CL:NOT (CL:EQ BASENAME STELLA::NULL-STRING)))))
   (CL:WHEN (CL:EQ BASEEXTENSION STELLA::NULL-STRING)
    (CL:SETQ BASEEXTENSION (FILE-EXTENSION DEFAULTS))
    (CL:SETQ MERGED?
     (CL:OR MERGED? (CL:NOT (CL:EQ BASEEXTENSION STELLA::NULL-STRING)))))
   (CL:WHEN (CL:NOT MERGED?) (CL:RETURN-FROM MERGE-FILE-NAMES BASEFILE))
   (CL:SETQ RESULT (NEW-OUTPUT-STRING-STREAM))
   (CL:WHEN (CL:NOT (CL:EQ BASEHOST STELLA::NULL-STRING))
    (%%PRINT-STREAM (%NATIVE-STREAM RESULT) BASEHOST LOGICAL-HOST-SEPARATOR))
   (%%PRINT-STREAM (%NATIVE-STREAM RESULT) BASEDIRECTORY)
   (CL:WHEN (CL:NOT (CL:EQ BASENAME STELLA::NULL-STRING))
    (%%PRINT-STREAM (%NATIVE-STREAM RESULT) BASENAME))
   (CL:WHEN (CL:NOT (CL:EQ BASEEXTENSION STELLA::NULL-STRING))
    (%%PRINT-STREAM (%NATIVE-STREAM RESULT) BASEEXTENSION))
   (CL:RETURN-FROM MERGE-FILE-NAMES (THE-STRING-READER RESULT))))

;;; (DEFGLOBAL *TYPE-TO-FILE-EXTENSION-TABLE* ...)

(CL:DEFVAR *TYPE-TO-FILE-EXTENSION-TABLE* NULL
  "Used by `select-file-extension'.")

;;; (DEFUN (COMPUTE-COMMON-LISP-FILE-EXTENSION STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  COMPUTE-COMMON-LISP-FILE-EXTENSION))
(CL:DEFUN COMPUTE-COMMON-LISP-FILE-EXTENSION (TYPE)
  (CL:WHEN (CL:NOT (RUNNING-AS-LISP?))
   (CL:ERROR
    (NEW-STELLA-EXCEPTION
     "Shouldn't call COMPUTE-COMMON-LISP-FILE-EXTENSION unless running in Lisp")))
  (CL:LET* ((SUFFIX STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SUFFIX))
   (CL:COND
    ((CL:EQ TYPE KWD-TRANSLATE-FILE-LISP-BINARY)
     (CL:SETQ SUFFIX (cl:pathname-type (cl:compile-file-pathname "foo.lisp")))
     (CL:COND
      ((MEMB? *CURRENT-STELLA-FEATURES*
        KWD-TRANSLATE-FILE-USE-COMMON-LISP-STRUCTS)
       (CL:SETQ SUFFIX (CONCATENATE "s" SUFFIX)))
      ((MEMB? *CURRENT-STELLA-FEATURES*
        KWD-TRANSLATE-FILE-USE-COMMON-LISP-VECTOR-STRUCTS)
       (CL:SETQ SUFFIX (CONCATENATE "vs" SUFFIX)))
      (CL:T)))
    ((CL:EQ TYPE KWD-TRANSLATE-FILE-LISP)
     (CL:COND
      ((MEMB? *CURRENT-STELLA-FEATURES*
        KWD-TRANSLATE-FILE-USE-COMMON-LISP-STRUCTS)
       (CL:SETQ SUFFIX ".slisp"))
      ((MEMB? *CURRENT-STELLA-FEATURES*
        KWD-TRANSLATE-FILE-USE-COMMON-LISP-VECTOR-STRUCTS)
       (CL:SETQ SUFFIX ".vslisp"))
      (CL:T (CL:SETQ SUFFIX ".lisp")))
     (cl:let* ((lispType 
                  (CL:pathname-type (CL:concatenate 'CL:string "dummy" suffix)))
                 (dummyPath
                  (CL:make-pathname :name "f" :type lispType)))
         (cl:setq suffix (CL:SUBSEQ (CL:namestring dummyPath) 2))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TYPE
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:RETURN-FROM COMPUTE-COMMON-LISP-FILE-EXTENSION
    (CONCATENATE "." SUFFIX))))

;;; (DEFUN (DEFAULT-COMMON-LISP-FILE-EXTENSION STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  DEFAULT-COMMON-LISP-FILE-EXTENSION))
(CL:DEFUN DEFAULT-COMMON-LISP-FILE-EXTENSION (TYPE)
  (CL:COND
   ((CL:EQ TYPE KWD-TRANSLATE-FILE-LISP)
    (CL:COND
     ((CL:EQ *OS* KWD-TRANSLATE-FILE-WINDOWS)
      (CL:RETURN-FROM DEFAULT-COMMON-LISP-FILE-EXTENSION ".lsp"))
     (CL:T (CL:RETURN-FROM DEFAULT-COMMON-LISP-FILE-EXTENSION ".lisp"))))
   ((CL:EQ TYPE KWD-TRANSLATE-FILE-LISP-BINARY)
    (CL:COND
     ((CL:EQ *OS* KWD-TRANSLATE-FILE-MAC)
      (CL:RETURN-FROM DEFAULT-COMMON-LISP-FILE-EXTENSION ".cfsl"))
     ((CL:EQ *OS* KWD-TRANSLATE-FILE-WINDOWS)
      (CL:RETURN-FROM DEFAULT-COMMON-LISP-FILE-EXTENSION ".fas"))
     (CL:T (CL:RETURN-FROM DEFAULT-COMMON-LISP-FILE-EXTENSION ".fasl"))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TYPE
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (SELECT-FILE-EXTENSION STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) SELECT-FILE-EXTENSION))
(CL:DEFUN SELECT-FILE-EXTENSION (TYPE)
  (CL:LET* ((EXTENSION STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING EXTENSION))
   (CL:LET* ((ENTRY NULL) (ITER-000 *TYPE-TO-FILE-EXTENSION-TABLE*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ENTRY (%%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%%VALUE ENTRY) TYPE)
      (CL:SETQ EXTENSION (%WRAPPER-VALUE (%%VALUE (%%REST ENTRY)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:COND
    ((CL:EQ TYPE KWD-TRANSLATE-FILE-DIRECTORY)
     (CL:RETURN-FROM SELECT-FILE-EXTENSION (DIRECTORY-SEPARATOR-STRING)))
    ((CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-LISP)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-LISP-BINARY))
     (CL:IF (RUNNING-AS-LISP?)
      (CL:RETURN-FROM SELECT-FILE-EXTENSION
       (COMPUTE-COMMON-LISP-FILE-EXTENSION TYPE))
      (CL:RETURN-FROM SELECT-FILE-EXTENSION
       (DEFAULT-COMMON-LISP-FILE-EXTENSION TYPE))))
    (CL:T))
   (CL:RETURN-FROM SELECT-FILE-EXTENSION EXTENSION)))

;;; (DEFUN (CLASSIFY-FILE-EXTENSION KEYWORD) ...)

(CL:DEFUN CLASSIFY-FILE-EXTENSION (FILE)
  (CL:LET* ((EXTENSION (FILE-EXTENSION FILE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING EXTENSION))
   (CL:WHEN (CL:EQ EXTENSION STELLA::NULL-STRING)
    (CL:RETURN-FROM CLASSIFY-FILE-EXTENSION KWD-TRANSLATE-FILE-NONE))
   (CL:LET* ((ENTRY NULL) (ITER-000 *TYPE-TO-FILE-EXTENSION-TABLE*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ENTRY (%%VALUE ITER-000))
     (CL:WHEN (EQL-TO-STRING? (%%VALUE (%%REST ENTRY)) EXTENSION)
      (CL:RETURN-FROM CLASSIFY-FILE-EXTENSION (%%VALUE ENTRY)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (RUNNING-AS-LISP?)
    (CL:WHEN
     (STRING-EQL? (COMPUTE-COMMON-LISP-FILE-EXTENSION KWD-TRANSLATE-FILE-LISP)
      EXTENSION)
     (CL:RETURN-FROM CLASSIFY-FILE-EXTENSION KWD-TRANSLATE-FILE-LISP))
    (CL:WHEN
     (STRING-EQL?
      (COMPUTE-COMMON-LISP-FILE-EXTENSION KWD-TRANSLATE-FILE-LISP-BINARY)
      EXTENSION)
     (CL:RETURN-FROM CLASSIFY-FILE-EXTENSION KWD-TRANSLATE-FILE-LISP-BINARY)))
   (CL:WHEN
    (STRING-EQL? (DEFAULT-COMMON-LISP-FILE-EXTENSION KWD-TRANSLATE-FILE-LISP)
     EXTENSION)
    (CL:RETURN-FROM CLASSIFY-FILE-EXTENSION KWD-TRANSLATE-FILE-LISP))
   (CL:WHEN
    (STRING-EQL?
     (DEFAULT-COMMON-LISP-FILE-EXTENSION KWD-TRANSLATE-FILE-LISP-BINARY)
     EXTENSION)
    (CL:RETURN-FROM CLASSIFY-FILE-EXTENSION KWD-TRANSLATE-FILE-LISP-BINARY))
   (CL:RETURN-FROM CLASSIFY-FILE-EXTENSION KWD-TRANSLATE-FILE-OTHER)))

;;; (DEFUN (SELECT-ROOT-DIRECTORY STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) SELECT-ROOT-DIRECTORY))
(CL:DEFUN SELECT-ROOT-DIRECTORY (TYPE)
  (CL:LET* ((ROOT STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING ROOT))
   (CL:COND
    ((CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-STELLA)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-KB))
     (CL:SETQ ROOT (ROOT-SOURCE-DIRECTORY)))
    ((CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-LISP-BINARY)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-DIRECTORY))
     (CL:SETQ ROOT (ROOT-BINARY-DIRECTORY)))
    (CL:T (CL:SETQ ROOT (ROOT-NATIVE-DIRECTORY))))
   (CL:RETURN-FROM SELECT-ROOT-DIRECTORY ROOT)))

;;; (DEFGLOBAL *LISP-SPLITTER-PATH* ...)

(CL:DEFVAR *LISP-SPLITTER-PATH* "lisp")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *LISP-SPLITTER-PATH*))

;;; (DEFGLOBAL *JAVA-SPLITTER-PATH* ...)

(CL:DEFVAR *JAVA-SPLITTER-PATH* "java")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *JAVA-SPLITTER-PATH*))

;;; (DEFGLOBAL *CPP-SPLITTER-PATH* ...)

(CL:DEFVAR *CPP-SPLITTER-PATH* "cpp")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *CPP-SPLITTER-PATH*))

;;; (DEFUN (SELECT-SPLITTER-PATH STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) SELECT-SPLITTER-PATH))
(CL:DEFUN SELECT-SPLITTER-PATH (TYPE)
  (CL:LET* ((SPLITTERPATH ""))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SPLITTERPATH))
   (CL:COND
    ((CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-LISP)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-COMMON-LISP))
     (CL:SETQ SPLITTERPATH *LISP-SPLITTER-PATH*))
    ((CL:EQ TYPE KWD-TRANSLATE-FILE-JAVA)
     (CL:SETQ SPLITTERPATH *JAVA-SPLITTER-PATH*))
    ((CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-CPP)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-CPP-HEADER)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-CPP-CODE)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-C-HEADER)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-C-CODE))
     (CL:SETQ SPLITTERPATH *CPP-SPLITTER-PATH*))
    ((CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-NONE)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-OTHER))
     (CL:RETURN-FROM SELECT-SPLITTER-PATH
      (SELECT-SPLITTER-PATH *TRANSLATOROUTPUTLANGUAGE*)))
    (CL:T))
   (CL:WHEN (CL:NOT (STRING-EQL? SPLITTERPATH ""))
    (CL:SETQ SPLITTERPATH
     (CONCATENATE SPLITTERPATH (DIRECTORY-SEPARATOR-STRING))))
   (CL:RETURN-FROM SELECT-SPLITTER-PATH SPLITTERPATH)))

;;; (DEFUN (MAKE-FILE-NAME-FROM-RELATIVE-PATH FILE-NAME) ...)

(CL:DEFUN MAKE-FILE-NAME-FROM-RELATIVE-PATH (FILEPATH TYPE)
  (CL:RETURN-FROM MAKE-FILE-NAME-FROM-RELATIVE-PATH
   (MAKE-FILE-NAME (IMPLODE-PATHNAME FILEPATH) TYPE CL:T)))

;;; (DEFUN (ROOT-DIRECTORY-PREFIX FILE-NAME) ...)

(CL:DEFUN ROOT-DIRECTORY-PREFIX (FILE)
  (CL:LET* ((EXTENSION (FILE-EXTENSION FILE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING EXTENSION))
   (CL:COND
    ((STRING-EQL? EXTENSION ".ste")
     (CL:RETURN-FROM ROOT-DIRECTORY-PREFIX (ROOT-SOURCE-DIRECTORY)))
    ((CL:OR (STRING-EQL? EXTENSION ".lisp") (STRING-EQL? EXTENSION ".java")
      (STRING-EQL? EXTENSION ".cc") (STRING-EQL? EXTENSION ".hh"))
     (CL:RETURN-FROM ROOT-DIRECTORY-PREFIX (ROOT-NATIVE-DIRECTORY)))
    (CL:T (CL:RETURN-FROM ROOT-DIRECTORY-PREFIX (ROOT-NATIVE-DIRECTORY))))))

;;; (DEFUN (MAKE-FILE-NAME FILE-NAME) ...)

(CL:DEFUN MAKE-FILE-NAME (FILEPATH TYPE RELATIVE?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILEPATH))
  #+MCL
  (CL:CHECK-TYPE FILEPATH CL:SIMPLE-STRING)
  (CL:LET*
   ((EXTENSION (SELECT-FILE-EXTENSION TYPE)) (ROOTPATH "") (SPLITTERPATH "")
    (SUBDIRECTORY ""))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING EXTENSION ROOTPATH SPLITTERPATH SUBDIRECTORY))
   (CL:COND
    (RELATIVE? (CL:SETQ ROOTPATH (SELECT-ROOT-DIRECTORY TYPE))
     (CL:SETQ SPLITTERPATH (SELECT-SPLITTER-PATH TYPE))
     (CL:WHEN (CL:NOT (CL:EQ TYPE KWD-TRANSLATE-FILE-OTHER))
      (CL:SETQ FILEPATH (FILE-NAME-WITHOUT-EXTENSION FILEPATH)))
     (CL:IF
      (CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-JAVA)
       (CL:AND (CL:EQ TYPE KWD-TRANSLATE-FILE-OTHER)
        (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)))
      (CL:SETQ SUBDIRECTORY
       (JAVA-PACKAGE-PREFIX *MODULE* (DIRECTORY-SEPARATOR-STRING)))
      (CL:WHEN (CL:NOT (STRING-EQL? *CURRENTSYSTEMDEFINITIONSUBDIRECTORY* ""))
       (CL:SETQ SUBDIRECTORY
        (CONCATENATE *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
         (DIRECTORY-SEPARATOR-STRING))))))
    (CL:T
     (CL:LET* ((ROOTPREFIX (ROOT-DIRECTORY-PREFIX FILEPATH)))
      (CL:WHEN (CL:NOT (CL:EQ TYPE KWD-TRANSLATE-FILE-OTHER))
       (CL:SETQ FILEPATH (FILE-NAME-WITHOUT-EXTENSION FILEPATH)))
      (CL:WHEN
       (CL:NOT
        (MEMBER? (GET-QUOTED-TREE "((:STELLA :KB) \"/STELLA\")" "/STELLA")
         TYPE))
       (CL:LET* ((RELATIVEPATH (RELATIVIZE-FILE-NAME FILEPATH ROOTPREFIX)))
        (CL:WHEN (CL:NOT (STRING-EQL? FILEPATH RELATIVEPATH))
         (CL:SETQ ROOTPATH (SELECT-ROOT-DIRECTORY TYPE))
         (CL:SETQ SPLITTERPATH (SELECT-SPLITTER-PATH TYPE))
         (CL:SETQ FILEPATH RELATIVEPATH)))))))
   (CL:RETURN-FROM MAKE-FILE-NAME
    (CONCATENATE ROOTPATH SPLITTERPATH SUBDIRECTORY FILEPATH EXTENSION))))

;;; (DEFUN (RELATIVIZE-FILE-NAME FILE-NAME) ...)

(CL:DEFUN RELATIVIZE-FILE-NAME (FILE ROOTPATH)
  (CL:LET* ((ABSOLUTE? (CL:= (STRING-SEARCH FILE ROOTPATH 0) 0)))
   (CL:IF ABSOLUTE?
    (CL:RETURN-FROM RELATIVIZE-FILE-NAME
     (SUBSEQUENCE FILE (CL:THE CL:FIXNUM (CL:LENGTH ROOTPATH)) NULL-INTEGER))
    (CL:RETURN-FROM RELATIVIZE-FILE-NAME FILE))))

;;; (DEFUN (HELP-IMPLODE-PATHNAME FILE-NAME) ...)

(CL:DEFUN HELP-IMPLODE-PATHNAME (FILENAME)
  (CL:LET* ((EXTENSION (FILE-EXTENSION FILENAME)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING EXTENSION))
   (CL:IF (CL:EQ EXTENSION STELLA::NULL-STRING)
    (CL:RETURN-FROM HELP-IMPLODE-PATHNAME (MAYBE-TRUNCATE-FILENAME FILENAME))
    (CL:RETURN-FROM HELP-IMPLODE-PATHNAME
     (CONCATENATE (MAYBE-TRUNCATE-FILENAME (FILE-BASE-NAME FILENAME))
      EXTENSION)))))

;;; (DEFUN (IMPLODE-PATHNAME FILE-NAME) ...)

(CL:DEFUN IMPLODE-PATHNAME (FILEPATH)
  (CL:LET* ((FILE STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE FILEPATH) SGT-TRANSLATE-FILE-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((PATH-LENGTH (LENGTH FILEPATH)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM PATH-LENGTH)) (CL:SETQ FILE "")
       (CL:LET*
        ((NAME NULL) (ITER-000 FILEPATH) (N NULL-INTEGER) (ITER-001 1)
         (UPPER-BOUND-000 PATH-LENGTH)
         (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM N ITER-001 UPPER-BOUND-000))
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
          (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)))
         DO (CL:SETQ NAME (%%VALUE ITER-000)) (CL:SETQ N ITER-001)
         (CL:IF (CL:= N PATH-LENGTH)
          (CL:SETQ FILE
           (CONCATENATE FILE (HELP-IMPLODE-PATHNAME (%WRAPPER-VALUE NAME))))
          (CL:SETQ FILE
           (CONCATENATE FILE (%WRAPPER-VALUE NAME)
            (DIRECTORY-SEPARATOR-STRING))))
         (CL:SETQ ITER-000 (%%REST ITER-000))
         (CL:SETQ ITER-001 (CL:1+ ITER-001)))))))
    (CL:T (CL:SETQ FILE (HELP-IMPLODE-PATHNAME (%WRAPPER-VALUE FILEPATH)))))
   (CL:RETURN-FROM IMPLODE-PATHNAME FILE)))

;;; (DEFSPECIAL *DONTTRUNCATEFILENAMES?* ...)

(CL:DEFVAR *DONTTRUNCATEFILENAMES?* CL:NIL
  "When TRUE, overrides normal truncation of file names.")

;;; (DEFUN (MAYBE-TRUNCATE-FILENAME FILE-NAME) ...)

(CL:DEFUN MAYBE-TRUNCATE-FILENAME (BAREFILENAME)
  (CL:WHEN *DONTTRUNCATEFILENAMES?*
   (CL:RETURN-FROM MAYBE-TRUNCATE-FILENAME BAREFILENAME))
  (CL:LET* ((MAXIMUMLENGTH 999))
   (CL:DECLARE (CL:TYPE CL:FIXNUM MAXIMUMLENGTH))
   (CL:COND
    ((CL:EQ *OS* KWD-TRANSLATE-FILE-MAC) (CL:SETQ MAXIMUMLENGTH (CL:- 31 5)))
    (CL:T))
   (CL:WHEN (CL:> (CL:THE CL:FIXNUM (CL:LENGTH BAREFILENAME)) MAXIMUMLENGTH)
    (CL:LET* ((ORIGINALFILENAME BAREFILENAME))
     (CL:SETQ BAREFILENAME (SUBSEQUENCE BAREFILENAME 0 (CL:1- MAXIMUMLENGTH)))
     (CL:WARN
      "Truncating name of file.~%   Original: `~A'    Truncated: `~A'~%"
      ORIGINALFILENAME BAREFILENAME)))
   (CL:RETURN-FROM MAYBE-TRUNCATE-FILENAME BAREFILENAME)))

;;; (DEFUN (LANGUAGE-TO-FILE-TYPE KEYWORD) ...)

(CL:DEFUN LANGUAGE-TO-FILE-TYPE (LANGUAGE)
  (CL:COND
   ((CL:EQ LANGUAGE KWD-TRANSLATE-FILE-COMMON-LISP)
    (CL:RETURN-FROM LANGUAGE-TO-FILE-TYPE KWD-TRANSLATE-FILE-LISP))
   ((CL:EQ LANGUAGE KWD-TRANSLATE-FILE-CPP)
    (CL:RETURN-FROM LANGUAGE-TO-FILE-TYPE KWD-TRANSLATE-FILE-CPP-CODE))
   (CL:T (CL:RETURN-FROM LANGUAGE-TO-FILE-TYPE LANGUAGE))))

;;; (DEFUN (REROOT-FILE-NAME FILE-NAME) ...)

(CL:DEFUN REROOT-FILE-NAME (FILE FROMROOT TOROOT)
  (CL:LET* ((ABSOLUTE? (CL:= (STRING-SEARCH FILE FROMROOT 0) 0)))
   (CL:IF ABSOLUTE?
    (CL:IF (STRING-EQL? FROMROOT TOROOT)
     (CL:RETURN-FROM REROOT-FILE-NAME FILE)
     (CL:RETURN-FROM REROOT-FILE-NAME
      (CONCATENATE TOROOT
       (SUBSEQUENCE FILE (CL:THE CL:FIXNUM (CL:LENGTH FROMROOT))
        NULL-INTEGER))))
    (CL:RETURN-FROM REROOT-FILE-NAME (CONCATENATE TOROOT FILE)))))

;;; (DEFUN (FILE-YOUNGER-THAN? THREE-VALUED-BOOLEAN) ...)

(CL:DEFUN FILE-YOUNGER-THAN? (FILE1 FILE2)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE1 FILE2))
  #+MCL
  (CL:CHECK-TYPE FILE1 CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE FILE2 CL:SIMPLE-STRING)
  (CL:IF (CL:OR (CL:NOT (PROBE-FILE? FILE1)) (CL:NOT (PROBE-FILE? FILE2)))
   (CL:RETURN-FROM FILE-YOUNGER-THAN? NULL)
   (CL:LET*
    ((FILE1-DATE (FILE-WRITE-DATE FILE1))
     (FILE2-DATE (FILE-WRITE-DATE FILE2)))
    (CL:IF (CL:OR (CL:EQ FILE1-DATE NULL) (CL:EQ FILE2-DATE NULL))
     (CL:RETURN-FROM FILE-YOUNGER-THAN? NULL)
     (CL:RETURN-FROM FILE-YOUNGER-THAN?
      (CL:IF (GREATER-EQUAL? FILE1-DATE FILE2-DATE) TRUE-WRAPPER
       FALSE-WRAPPER))))))

;;; (DEFUN (STELLA-NEED-TO-TRANSLATE? BOOLEAN) ...)

(CL:DEFUN STELLA-NEED-TO-TRANSLATE? (FILE LANGUAGE)
  (CL:WHEN (CL:EQ LANGUAGE KWD-TRANSLATE-FILE-JAVA)
   (CL:RETURN-FROM STELLA-NEED-TO-TRANSLATE? CL:T))
  (CL:LET*
   ((SOURCEFILE
     (MAKE-FILE-NAME (%WRAPPER-VALUE FILE) KWD-TRANSLATE-FILE-STELLA CL:T))
    (TRANSLATEDFILE
     (MAKE-FILE-NAME (%WRAPPER-VALUE FILE) (LANGUAGE-TO-FILE-TYPE LANGUAGE)
      CL:T)))
   (CL:RETURN-FROM STELLA-NEED-TO-TRANSLATE?
    (CL:AND (PROBE-FILE? SOURCEFILE)
     (CL:NOT
      (CL:EQ (FILE-YOUNGER-THAN? TRANSLATEDFILE SOURCEFILE) TRUE-WRAPPER))))))

;;; (DEFUN (STELLA-NEED-TO-COMPILE? BOOLEAN) ...)

(CL:DEFUN STELLA-NEED-TO-COMPILE? (FILE)
  (CL:LET*
   ((SOURCEFILE
     (MAKE-FILE-NAME (%WRAPPER-VALUE FILE) KWD-TRANSLATE-FILE-LISP CL:T))
    (COMPILEDFILE
     (MAKE-FILE-NAME (%WRAPPER-VALUE FILE) KWD-TRANSLATE-FILE-LISP-BINARY
      CL:T)))
   (CL:RETURN-FROM STELLA-NEED-TO-COMPILE?
    (CL:NOT
     (CL:EQ (FILE-YOUNGER-THAN? COMPILEDFILE SOURCEFILE) TRUE-WRAPPER)))))

;;; (DEFUN (SYSTEM-NEEDS-TRANSLATION? BOOLEAN) ...)

(CL:DEFUN SYSTEM-NEEDS-TRANSLATION? (SYSTEMNAME LANGUAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((*CURRENTSYSTEMDEFINITION* (GET-SYSTEM-DEFINITION SYSTEMNAME))
    (*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
     (CL:IF (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
      (%DIRECTORY *CURRENTSYSTEMDEFINITION*) STELLA::NULL-STRING)))
   (CL:DECLARE
    (CL:SPECIAL *CURRENTSYSTEMDEFINITION*
     *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
   (CL:IF (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
    (CL:PROGN
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET*
       ((FILE NULL)
        (ITER-000
         (FILES-PLUS-SYSTEM-STARTUP
          (SYSTEM-DEFINITION-SOURCE-FILES *CURRENTSYSTEMDEFINITION*))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ FILE (%%VALUE ITER-000))
        (CL:WHEN (STELLA-NEED-TO-TRANSLATE? FILE LANGUAGE)
         (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:LET* ((VALUE-000 FOUND?-000))
       (CL:RETURN-FROM SYSTEM-NEEDS-TRANSLATION? VALUE-000))))
    (CL:WARN "Can't find a system named `~A'~%" SYSTEMNAME)))
  (CL:RETURN-FROM SYSTEM-NEEDS-TRANSLATION? CL:NIL))

;;; (DEFUN (COMPUTE-FILE-UNITS-MODULE MODULE) ...)

(CL:DEFUN COMPUTE-FILE-UNITS-MODULE (FILEUNITS)
  (CL:LET* ((UNIT NULL) (ITER-000 (%THE-CONS-LIST FILEUNITS)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ UNIT (%%VALUE ITER-000))
    (CL:WHEN (CL:NOT (CL:EQ (%TU-HOME-MODULE UNIT) NULL))
     (CL:RETURN-FROM COMPUTE-FILE-UNITS-MODULE (%TU-HOME-MODULE UNIT)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:RETURN-FROM COMPUTE-FILE-UNITS-MODULE *MODULE*))

;;; (DEFUN (CONCATENATE-SYSTEM-UNITS (LIST OF TRANSLATION-UNIT)) ...)

(CL:DEFUN CONCATENATE-SYSTEM-UNITS (SYSTEMUNITS)
  (CL:LET* ((HEAD (CONS NULL NIL)) (CURSOR HEAD))
   (CL:LET* ((FILE NULL) (UNITS NULL) (ITER-000 (%THE-KV-LIST SYSTEMUNITS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
     (CL:SETQ FILE (%KEY ITER-000)) (CL:SETQ UNITS (%VALUE ITER-000))
     (CL:SETQ FILE FILE)
     (CL:WHEN (NON-EMPTY? UNITS) (CONCATENATE CURSOR (%THE-CONS-LIST UNITS))
      (CL:SETQ CURSOR (%THE-CONS-LIST UNITS)))
     (CL:SETQ ITER-000 (%REST ITER-000))))
   (CL:LET* ((SELF-000 (NEW-LIST)))
    (CL:SETF (%THE-CONS-LIST SELF-000) (%%REST HEAD))
    (CL:LET* ((VALUE-000 SELF-000))
     (CL:RETURN-FROM CONCATENATE-SYSTEM-UNITS VALUE-000)))))

;;; (DEFUN (TRANSLATE-SYSTEM BOOLEAN) ...)

(CL:DEFUN TRANSLATE-SYSTEM (SYSTEMNAME OUTPUTLANGUAGE CL:&REST OPTIONS)
  "Translate all of the STELLA source files in system `systemName' into
`outputLanguage'.  The following keyword/value `options' are recognized:

`:two-pass?' (default false): if true, all files will be scanned twice, once
to load the signatures of objects defined in them, and once to actually
translate the definitions.

`:force-translation?' (default false): if true, files will be translated
whether or not their translations are up-to-date.

`:development-settings?' (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of `:development-settings' on the system definition).  If false, efficiency
will be favored instead (according to the value of `:production-settings'
on the system definition).

`:production-settings?' (default true): inverse to `:development-settings?'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
   (CL:LET* ((ARGLIST-000 NIL))
    (CL:LET* ((ARG-000 NULL) (ITER-000 OPTIONS) (COLLECT-000 NULL))
     (CL:LOOP WHILE ITER-000 DO (CL:SETQ ARG-000 (CL:POP ITER-000))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG-000 NIL))
        (CL:IF (CL:EQ ARGLIST-000 NIL) (CL:SETQ ARGLIST-000 COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST ARGLIST-000 COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG-000 NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
    (CL:SETF (%THE-PLIST SELF-000) ARGLIST-000))
   (CL:LET*
    ((PLIST SELF-000) (TWOPASS? CL:NIL) (FORCETRANSLATION? CL:NIL)
     (PRODUCTIONMODE? CL:T))
    (CL:SETQ OUTPUTLANGUAGE (STELLIFY OUTPUTLANGUAGE))
    (VET-OPTIONS PLIST
     (GET-QUOTED-TREE
      "((:TWO-PASS? :FORCE-TRANSLATION? :PRODUCTION-SETTINGS? :DEVELOPMENT-SETTINGS?) \"/STELLA\")"
      "/STELLA"))
    (CL:LET* ((KEY NULL) (VALUE NULL) (ITER-001 (%THE-PLIST PLIST)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ KEY (%%VALUE ITER-001))
      (CL:SETQ VALUE (%%VALUE (%%REST ITER-001)))
      (CL:LET* ((TEST-VALUE-000 KEY))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 KWD-TRANSLATE-FILE-TWO-PASS?)
         (CL:SETQ TWOPASS? (EQL? VALUE TRUE-WRAPPER)))
        ((CL:EQ TEST-VALUE-000 KWD-TRANSLATE-FILE-FORCE-TRANSLATION?)
         (CL:SETQ FORCETRANSLATION? (EQL? VALUE TRUE-WRAPPER)))
        ((CL:EQ TEST-VALUE-000 KWD-TRANSLATE-FILE-PRODUCTION-SETTINGS?)
         (CL:SETQ PRODUCTIONMODE? (EQL? VALUE TRUE-WRAPPER)))
        ((CL:EQ TEST-VALUE-000 KWD-TRANSLATE-FILE-DEVELOPMENT-SETTINGS?)
         (CL:SETQ PRODUCTIONMODE? (CL:NOT (EQL? VALUE TRUE-WRAPPER))))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
           "' is not a valid case option")
          (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
      (CL:SETQ ITER-001 (%%REST (%%REST ITER-001)))))
    (CL:WHEN
     (CL:EQ
      (LOOKUP-FUNCTION
       (SYSTEM-STARTUP-FUNCTION-SYMBOL (GET-SYSTEM-DEFINITION SYSTEMNAME)))
      NULL)
     (CL:SETQ TWOPASS? CL:T))
    (CL:LET*
     ((*TRANSLATOROUTPUTLANGUAGE* *TRANSLATOROUTPUTLANGUAGE*)
      (*TRANSLATIONPHASE* NULL) (*SAFETY* *SAFETY*)
      (*RECYCLING-ENABLED?*
       (CL:NOT (CL:EQ OUTPUTLANGUAGE KWD-TRANSLATE-FILE-JAVA)))
      (*CURRENT-STELLA-FEATURES* (COPY *CURRENT-STELLA-FEATURES*)))
     (CL:DECLARE
      (CL:SPECIAL *TRANSLATOROUTPUTLANGUAGE* *TRANSLATIONPHASE* *SAFETY*
       *RECYCLING-ENABLED?* *CURRENT-STELLA-FEATURES*))
     (CL:DECLARE (CL:TYPE CL:FIXNUM *SAFETY*)) (CL:SETQ *GENSYM-COUNTER* -1)
     (%SET-STELLA-FEATURE
      (CONS-LIST KWD-TRANSLATE-FILE-TRANSLATE-WITH-COPYRIGHT-HEADER
       KWD-TRANSLATE-FILE-WARN-ABOUT-MISSING-METHODS
       KWD-TRANSLATE-FILE-WARN-ABOUT-UNDEFINED-METHODS))
     (%UNSET-STELLA-FEATURE
      (CONS-LIST KWD-TRANSLATE-FILE-USE-HARDCODED-SYMBOLS))
     (%SET-TRANSLATOR-OUTPUT-LANGUAGE OUTPUTLANGUAGE)
     (CL:LET*
      ((*CURRENTSYSTEMDEFINITION* (GET-SYSTEM-DEFINITION SYSTEMNAME))
       (*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
        (CL:IF (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
         (%DIRECTORY *CURRENTSYSTEMDEFINITION*) STELLA::NULL-STRING)))
      (CL:DECLARE
       (CL:SPECIAL *CURRENTSYSTEMDEFINITION*
        *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
      (CL:DECLARE
       (CL:TYPE CL:SIMPLE-STRING *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
      (CL:IF (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
       (CL:PROGN
        (COMPUTE-OPTIMIZATION-LEVELS *CURRENTSYSTEMDEFINITION*
         PRODUCTIONMODE?)
        (CL:LET*
         ((FILES
           (FILES-PLUS-SYSTEM-STARTUP
            (SYSTEM-DEFINITION-SOURCE-FILES *CURRENTSYSTEMDEFINITION*)))
          (TRANSLATEDSOMETHING? CL:NIL))
         (CL:WHEN
          (CL:OR FORCETRANSLATION?
           (SYSTEM-NEEDS-TRANSLATION? SYSTEMNAME OUTPUTLANGUAGE))
          (CREATE-SYSTEM-STARTUP-FILE *CURRENTSYSTEMDEFINITION*)
          (CL:SETQ TRANSLATEDSOMETHING?
           (HELP-TRANSLATE-SYSTEM FILES TWOPASS? FORCETRANSLATION?)))
         (TRANSFER-NATIVE-SYSTEM-FILES OUTPUTLANGUAGE)
         (CL:RETURN-FROM TRANSLATE-SYSTEM TRANSLATEDSOMETHING?)))
       (CL:WARN "Can't find a system named `~A'~%" SYSTEMNAME)))
     (CL:RETURN-FROM TRANSLATE-SYSTEM CL:NIL)))))

;;; (DEFUN (HELP-TRANSLATE-SYSTEM BOOLEAN) ...)

(CL:DEFUN HELP-TRANSLATE-SYSTEM (FILES TWOPASS? FORCETRANSLATION?)
  (CL:LET* ((*TRANSLATIONUNITS* (NEW-LIST)))
   (CL:DECLARE (CL:SPECIAL *TRANSLATIONUNITS*))
   (CL:LET*
    ((OUTPUTLANGUAGE *TRANSLATOROUTPUTLANGUAGE*)
     (FILENAME STELLA::NULL-STRING) (TRANSLATEDFILE? CL:NIL)
     (WALKEDUNITS (NEW-KEY-VALUE-LIST)))
    (CLEAR-SYMBOL-REGISTRY)
    (CL:WHEN TWOPASS?
     (CL:LET* ((FILE NULL) (ITER-000 FILES))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ FILE (%%VALUE ITER-000))
       (CL:TAGBODY
        (CL:WHEN
         (CL:OR FORCETRANSLATION?
          (STELLA-NEED-TO-TRANSLATE? FILE OUTPUTLANGUAGE)
          (CL:NOT (%LOADED? *CURRENTSYSTEMDEFINITION*)))
         (CL:SETQ FILENAME
          (MAKE-FILE-NAME (%WRAPPER-VALUE FILE) KWD-TRANSLATE-FILE-STELLA
           CL:T))
         (CL:WHEN (CL:NOT (PROBE-FILE? FILENAME))
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Warning: File `"
           FILENAME "' does not exist." EOL)
          (CL:GO :CONTINUE))
         (OPERATE-ON-FILE FILENAME KWD-TRANSLATE-FILE-DEFINE)
         (CLEAN-UP-TRANSLATION-UNITS-SPECIAL) (CL:SETQ TRANSLATEDFILE? CL:T))
        :CONTINUE)
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:WHEN TRANSLATEDFILE?
      (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 1)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
        "*** Pass 2, finalizing objects..." EOL))
      (FINALIZE-CLASSES-AND-SLOTS)))
    (CL:LET* ((FILE NULL) (ITER-001 FILES))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ FILE (%%VALUE ITER-001))
      (CL:TAGBODY
       (CL:WHEN
        (CL:OR FORCETRANSLATION?
         (STELLA-NEED-TO-TRANSLATE? FILE OUTPUTLANGUAGE))
        (CL:SETQ FILENAME
         (MAKE-FILE-NAME (%WRAPPER-VALUE FILE) KWD-TRANSLATE-FILE-STELLA
          CL:T))
        (CL:WHEN (CL:NOT (PROBE-FILE? FILENAME))
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Warning: File `"
          FILENAME "' does not exist." EOL)
         (CL:GO :CONTINUE))
        (OPERATE-ON-FILE FILENAME KWD-TRANSLATE-FILE-WALK)
        (INSERT-AT WALKEDUNITS (WRAP-STRING FILENAME) *TRANSLATIONUNITS*)
        (CL:SETQ *TRANSLATIONUNITS* (NEW-LIST)))
       :CONTINUE)
      (CL:SETQ ITER-001 (%%REST ITER-001))))
    (REVERSE WALKEDUNITS)
    (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 1)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "    ==============================" EOL))
    (CL:COND
     ((CL:EQ OUTPUTLANGUAGE KWD-TRANSLATE-FILE-COMMON-LISP)
      (CL-TRANSLATE-WALKED-SYSTEM-UNITS WALKEDUNITS))
     ((CL:EQ OUTPUTLANGUAGE KWD-TRANSLATE-FILE-CPP)
      (CPP-TRANSLATE-WALKED-SYSTEM-UNITS WALKEDUNITS))
     ((CL:EQ OUTPUTLANGUAGE KWD-TRANSLATE-FILE-JAVA)
      (JAVA-TRANSLATE-WALKED-SYSTEM-UNITS WALKEDUNITS))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" OUTPUTLANGUAGE
        "' is not a valid case option")
       (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
    (CLEAR-SYMBOL-REGISTRY)
    (CL:RETURN-FROM HELP-TRANSLATE-SYSTEM TRANSLATEDFILE?))))

;;; (DEFUN TRANSFER-NATIVE-SYSTEM-FILES ...)

(CL:DEFUN TRANSFER-NATIVE-SYSTEM-FILES (OUTPUTLANGUAGE)
  (CL:LET*
   ((NATIVEFILES NULL)
    (SYSTEMSUBDIRECTORY
     (CL:IF (STRING-EQL? *CURRENTSYSTEMDEFINITIONSUBDIRECTORY* "") ""
      (CONCATENATE *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
       (DIRECTORY-SEPARATOR-STRING))))
    (FLOTSAMFILENAME ""))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMSUBDIRECTORY FLOTSAMFILENAME))
   (CL:COND
    ((CL:EQ OUTPUTLANGUAGE KWD-TRANSLATE-FILE-COMMON-LISP)
     (CL:SETQ NATIVEFILES (%LISP-ONLY-FILES *CURRENTSYSTEMDEFINITION*)))
    ((CL:EQ OUTPUTLANGUAGE KWD-TRANSLATE-FILE-JAVA)
     (CL:SETQ NATIVEFILES (%JAVA-ONLY-FILES *CURRENTSYSTEMDEFINITION*))
     (CL:SETQ FLOTSAMFILENAME
      (JAVA-YIELD-FLOTSAM-CLASS-NAME
       (GET-CARDINAL-MODULE *CURRENTSYSTEMDEFINITION*))))
    ((CL:EQ OUTPUTLANGUAGE KWD-TRANSLATE-FILE-CPP)
     (CL:SETQ NATIVEFILES (%CPP-ONLY-FILES *CURRENTSYSTEMDEFINITION*)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" OUTPUTLANGUAGE
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:WHEN (CL:EQ NATIVEFILES NULL)
    (CL:RETURN-FROM TRANSFER-NATIVE-SYSTEM-FILES))
   (CL:WHEN (STRING-EQL? (ROOT-SOURCE-DIRECTORY) (ROOT-NATIVE-DIRECTORY))
    (CL:RETURN-FROM TRANSFER-NATIVE-SYSTEM-FILES))
   (CL:SETQ NATIVEFILES
    (DIFFERENCE NATIVEFILES
     (SYSTEM-DEFINITION-SOURCE-FILES *CURRENTSYSTEMDEFINITION*)))
   (CL:LET*
    ((*MODULE* (GET-CARDINAL-MODULE *CURRENTSYSTEMDEFINITION*))
     (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:LET* ((F NULL) (ITER-000 NATIVEFILES))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ F (%%VALUE ITER-000))
      (CL:LET*
       ((FILENAME (%WRAPPER-VALUE F))
        (TYPE (CLASSIFY-FILE-EXTENSION FILENAME))
        (RELATIVEFILENAME
         (RELATIVIZE-FILE-NAME FILENAME (ROOT-SOURCE-DIRECTORY)))
        (FROMFILENAME STELLA::NULL-STRING) (TOFILENAME STELLA::NULL-STRING))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME))
       (CL:COND
        ((CL:EQ TYPE KWD-TRANSLATE-FILE-JAVA)
         (CL:WHEN (STRING-EQL? (FILE-BASE-NAME FILENAME) FLOTSAMFILENAME)
          (CL:WARN
           "Native Java filename `~A'~% conflicts with the Java catchall class' filename"
           FLOTSAMFILENAME)))
        (CL:T))
       (CL:SETQ FROMFILENAME
        (CONCATENATE (ROOT-SOURCE-DIRECTORY) SYSTEMSUBDIRECTORY FILENAME))
       (CL:SETQ TOFILENAME (MAKE-FILE-NAME RELATIVEFILENAME TYPE CL:T))
       (CL:WHEN
        (CL:NOT
         (CL:EQ (FILE-YOUNGER-THAN? TOFILENAME FROMFILENAME) TRUE-WRAPPER))
        (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 1)
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Copying `"
          FROMFILENAME "'" EOL " to `" TOFILENAME "' ..." EOL))
        (COPY-FILE FROMFILENAME TOFILENAME)))
      (CL:SETQ ITER-000 (%%REST ITER-000))))))
  :VOID)

(CL:DEFUN HELP-STARTUP-TRANSLATE-FILE1 ()
  (CL:PROGN
   (CL:SETQ KWD-TRANSLATE-FILE-TRANSLATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSLATE" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-JAVA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-CPP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-CPP-STANDALONE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-STANDALONE" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-IDL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IDL" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-DEFINE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE" NULL 2))
   (CL:SETQ SGT-TRANSLATE-FILE-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ KWD-TRANSLATE-FILE-FINALIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-WALK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WALK" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-TRANSLATE-WITH-COPYRIGHT-HEADER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSLATE-WITH-COPYRIGHT-HEADER" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-WINDOWS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WINDOWS" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-UNIX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNIX" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-MAC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAC" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-ROOT-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-DIRECTORY" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-LISP-TRANSLATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-TRANSLATIONS" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-STELLA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-KB
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KB" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-CPP-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-CODE" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-CPP-HEADER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-HEADER" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-C-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "C-CODE" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-C-HEADER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "C-HEADER" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-NONE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NONE" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-LISP-BINARY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-BINARY" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-USE-COMMON-LISP-STRUCTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-STRUCTS" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-USE-COMMON-LISP-VECTOR-STRUCTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-VECTOR-STRUCTS" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTORY" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-OTHER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHER" NULL 2))
   (CL:SETQ SYM-TRANSLATE-FILE-STELLA-SYSTEM-UNITS-ALIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYSTEM-UNITS-ALIST" NULL 0))
   (CL:SETQ KWD-TRANSLATE-FILE-TWO-PASS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TWO-PASS?" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-FORCE-TRANSLATION?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORCE-TRANSLATION?" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-PRODUCTION-SETTINGS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRODUCTION-SETTINGS?" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-DEVELOPMENT-SETTINGS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEVELOPMENT-SETTINGS?" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-WARN-ABOUT-MISSING-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN-ABOUT-MISSING-METHODS" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-WARN-ABOUT-UNDEFINED-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN-ABOUT-UNDEFINED-METHODS" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-USE-HARDCODED-SYMBOLS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-HARDCODED-SYMBOLS" NULL 2))
   (CL:SETQ SYM-TRANSLATE-FILE-STELLA-STARTUP-TRANSLATE-FILE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-TRANSLATE-FILE" NULL 0))
   (CL:SETQ SYM-TRANSLATE-FILE-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-TRANSLATE-FILE2 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "ROOT-SOURCE-DIRECTORY"
    "(DEFUN (ROOT-SOURCE-DIRECTORY FILE-NAME) ())"
    (CL:FUNCTION ROOT-SOURCE-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "ROOT-NATIVE-DIRECTORY"
    "(DEFUN (ROOT-NATIVE-DIRECTORY FILE-NAME) ())"
    (CL:FUNCTION ROOT-NATIVE-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "ROOT-BINARY-DIRECTORY"
    "(DEFUN (ROOT-BINARY-DIRECTORY FILE-NAME) ())"
    (CL:FUNCTION ROOT-BINARY-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-DEFINITIONS-DIRECTORY"
    "(DEFUN (SYSTEM-DEFINITIONS-DIRECTORY FILE-NAME) ())"
    (CL:FUNCTION SYSTEM-DEFINITIONS-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "HANDLE-IN-MODULE-TREE"
    "(DEFUN (HANDLE-IN-MODULE-TREE BOOLEAN BOOLEAN) ((TREE CONS) (SEENINMODULE? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION HANDLE-IN-MODULE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-AND-OUTPUT-UNITS-TO-FILE"
    "(DEFUN TRANSLATE-AND-OUTPUT-UNITS-TO-FILE ((FILE FILE-NAME) (TARGETLANGUAGE STRING)))"
    (CL:FUNCTION TRANSLATE-AND-OUTPUT-UNITS-TO-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "OPERATE-ON-FILE"
    "(DEFUN OPERATE-ON-FILE ((FILE FILE-NAME) (OPERATION KEYWORD)))"
    (CL:FUNCTION OPERATE-ON-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAN-UP-TRANSLATION-UNITS-SPECIAL"
    "(DEFUN CLEAN-UP-TRANSLATION-UNITS-SPECIAL ())"
    (CL:FUNCTION CLEAN-UP-TRANSLATION-UNITS-SPECIAL) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-FILE"
    "(DEFUN TRANSLATE-FILE ((FILE FILE-NAME) (OUTPUTLANGUAGE KEYWORD) (ASPARTOFSYSTEM? BOOLEAN)))"
    (CL:FUNCTION TRANSLATE-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "OUTPUT-ALL-UNITS-TO-FILE"
    "(DEFUN OUTPUT-ALL-UNITS-TO-FILE ((SOURCEFILE FILE-NAME)))"
    (CL:FUNCTION OUTPUT-ALL-UNITS-TO-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-SIGNATURES-OF-ALL-UNITS"
    "(DEFUN RECORD-SIGNATURES-OF-ALL-UNITS ((SOURCEFILE FILE-NAME)))"
    (CL:FUNCTION RECORD-SIGNATURES-OF-ALL-UNITS) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-WITH-COPYRIGHT-HEADER?"
    "(DEFUN (TRANSLATE-WITH-COPYRIGHT-HEADER? BOOLEAN) ())"
    (CL:FUNCTION TRANSLATE-WITH-COPYRIGHT-HEADER?) NULL)
   (DEFINE-FUNCTION-OBJECT "OUTPUT-COPYRIGHT-HEADER"
    "(DEFUN OUTPUT-COPYRIGHT-HEADER ((STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION OUTPUT-COPYRIGHT-HEADER) NULL)
   (DEFINE-FUNCTION-OBJECT "OUTPUT-FILE-HEADER"
    "(DEFUN OUTPUT-FILE-HEADER ((STREAM OUTPUT-STREAM) (FILE FILE-NAME)))"
    (CL:FUNCTION OUTPUT-FILE-HEADER) NULL)
   (DEFINE-FUNCTION-OBJECT "OPERATING-SYSTEM"
    "(DEFUN (OPERATING-SYSTEM KEYWORD) ())" (CL:FUNCTION OPERATING-SYSTEM)
    NULL)
   (DEFINE-FUNCTION-OBJECT "DIRECTORY-SEPARATOR"
    "(DEFUN (DIRECTORY-SEPARATOR CHARACTER) ())"
    (CL:FUNCTION DIRECTORY-SEPARATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "DIRECTORY-SEPARATOR-STRING"
    "(DEFUN (DIRECTORY-SEPARATOR-STRING STRING) ())"
    (CL:FUNCTION DIRECTORY-SEPARATOR-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "DIRECTORY-SEPARATOR-FOR-FILE"
    "(DEFUN (DIRECTORY-SEPARATOR-FOR-FILE CHARACTER) ((FILE FILE-NAME)))"
    (CL:FUNCTION DIRECTORY-SEPARATOR-FOR-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-NAME-DIRECTORY"
    "(DEFUN (FILE-NAME-DIRECTORY FILE-NAME) ((FILE FILE-NAME)) :DOCUMENTATION \"Return the directory component of `file' including the final
directory separator or the empty string if `file' does not include a directory.
Note that for purposes of this function, a logical host is considered part of
the directory portion of `file'\" :PUBLIC? TRUE)"
    (CL:FUNCTION FILE-NAME-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "DIRECTORY-FILE-NAME"
    "(DEFUN (DIRECTORY-FILE-NAME FILE-NAME) ((DIRECTORY FILE-NAME)) :DOCUMENTATION \"Return `directory' as a file name, i.e., without a terminating
directory separator.\" :PUBLIC? TRUE)" (CL:FUNCTION DIRECTORY-FILE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-NAME-AS-DIRECTORY"
    "(DEFUN (FILE-NAME-AS-DIRECTORY FILE-NAME) ((FILE FILE-NAME)) :DOCUMENTATION \"Return `file' interpreted as a directory, i.e., with a
terminating directory separator.  If `file' is the empty string simply
return the empty string, i.e., interpret it as the current directory instead
of the root directory.\" :PUBLIC? TRUE)" (CL:FUNCTION FILE-NAME-AS-DIRECTORY)
    NULL)
   (DEFINE-FUNCTION-OBJECT "DIRECTORY-PARENT-DIRECTORY"
    "(DEFUN (DIRECTORY-PARENT-DIRECTORY FILE-NAME) ((DIRECTORY FILE-NAME) (LEVEL INTEGER)) :DOCUMENTATION \"Return the `level'-th parent directory component of `directory'
including the final directory separator, or the empty string if `directory' does
not have that many parents.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DIRECTORY-PARENT-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-NAME-WITHOUT-DIRECTORY"
    "(DEFUN (FILE-NAME-WITHOUT-DIRECTORY FILE-NAME) ((FILE FILE-NAME)) :DOCUMENTATION \"Return the file name portion of `file' by removing any
directory and logical host components.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FILE-NAME-WITHOUT-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-NAME-WITHOUT-EXTENSION"
    "(DEFUN (FILE-NAME-WITHOUT-EXTENSION FILE-NAME) ((FILE FILE-NAME)) :DOCUMENTATION \"Remove `file's extension (or type) if there is any and
return the result.\" :PUBLIC? TRUE)" (CL:FUNCTION FILE-NAME-WITHOUT-EXTENSION)
    NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-EXTENSION"
    "(DEFUN (FILE-EXTENSION STRING) ((FILE FILE-NAME)) :DOCUMENTATION \"Return `file's extension (or type) if it has any including
the separator character.\" :PUBLIC? TRUE)" (CL:FUNCTION FILE-EXTENSION) NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-BASE-NAME"
    "(DEFUN (FILE-BASE-NAME FILE-NAME) ((FILE FILE-NAME)) :DOCUMENTATION \"Remove `file's directory (including logical host) and
extension components and return the result.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FILE-BASE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-LOGICAL-HOST-PROPERTY"
    "(DEFUN DEFINE-LOGICAL-HOST-PROPERTY ((HOST STRING) (PROPERTY KEYWORD) (VALUE OBJECT)) :DOCUMENTATION \"Define `property' with `value' for the logical host `host'.
As a side-effect, this also defines `host' as a logical host (both
`property' and `value' can be supplied as NULL).  If :ROOT-DIRECTORY
is specified, all pathnames with `host' are assumed to be relative to
that directory (even if they are absolute) and will be rerooted upon
translation.  :ROOT-DIRECTORY can be a logical or physical pathname.
If :LISP-TRANSLATIONS is specified, those will be used verbatimely as
the value of `(CL:logical-pathname-translations host)' if we are
running in Lisp, which allows us to depend on the native
`CL:translate-logical-pathname' for more complex translation operations.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DEFINE-LOGICAL-HOST-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-LOGICAL-HOST-PROPERTY"
    "(DEFUN (LOOKUP-LOGICAL-HOST-PROPERTY OBJECT) ((HOST STRING) (PROPERTY KEYWORD)))"
    (CL:FUNCTION LOOKUP-LOGICAL-HOST-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGICAL-HOST?"
    "(DEFUN (LOGICAL-HOST? BOOLEAN) ((HOST STRING)))"
    (CL:FUNCTION LOGICAL-HOST?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGICAL-PATHNAME?"
    "(DEFUN (LOGICAL-PATHNAME? BOOLEAN) ((PATHNAME STRING)))"
    (CL:FUNCTION LOGICAL-PATHNAME?) NULL)
   (DEFINE-FUNCTION-OBJECT "ABSOLUTE-PATHNAME?"
    "(DEFUN (ABSOLUTE-PATHNAME? BOOLEAN) ((PATHNAME STRING)))"
    (CL:FUNCTION ABSOLUTE-PATHNAME?) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-LOGICAL-HOST-NAME"
    "(DEFUN (GET-LOGICAL-HOST-NAME STRING) ((PATHNAME STRING)))"
    (CL:FUNCTION GET-LOGICAL-HOST-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGICAL-PATHNAME-WITHOUT-HOST"
    "(DEFUN (LOGICAL-PATHNAME-WITHOUT-HOST STRING) ((PATHNAME STRING)))"
    (CL:FUNCTION LOGICAL-PATHNAME-WITHOUT-HOST) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOGICAL-PATHNAME"
    "(DEFUN (TRANSLATE-LOGICAL-PATHNAME STRING) ((PATHNAME STRING)))"
    (CL:FUNCTION TRANSLATE-LOGICAL-PATHNAME) NULL)
   (DEFINE-FUNCTION-OBJECT "UNLOGICALIZE-PATHNAME"
    "(DEFUN (UNLOGICALIZE-PATHNAME STRING) ((PATHNAME STRING)) :GLOBALLY-INLINE? TRUE (RETURN (TRANSLATE-LOGICAL-PATHNAME PATHNAME)))"
    (CL:FUNCTION UNLOGICALIZE-PATHNAME) NULL)
   (DEFINE-FUNCTION-OBJECT "MERGE-FILE-NAMES"
    "(DEFUN (MERGE-FILE-NAMES FILE-NAME) ((BASEFILE FILE-NAME) (DEFAULTS FILE-NAME)) :DOCUMENTATION \"Parse `baseFile', supply any missing components from
`defaults' if supplied and return the result.\" :PUBLIC? TRUE)"
    (CL:FUNCTION MERGE-FILE-NAMES) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-COMMON-LISP-FILE-EXTENSION"
    "(DEFUN (COMPUTE-COMMON-LISP-FILE-EXTENSION STRING) ((TYPE KEYWORD)))"
    (CL:FUNCTION COMPUTE-COMMON-LISP-FILE-EXTENSION) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFAULT-COMMON-LISP-FILE-EXTENSION"
    "(DEFUN (DEFAULT-COMMON-LISP-FILE-EXTENSION STRING) ((TYPE KEYWORD)))"
    (CL:FUNCTION DEFAULT-COMMON-LISP-FILE-EXTENSION) NULL)
   (DEFINE-FUNCTION-OBJECT "SELECT-FILE-EXTENSION"
    "(DEFUN (SELECT-FILE-EXTENSION STRING) ((TYPE KEYWORD)))"
    (CL:FUNCTION SELECT-FILE-EXTENSION) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASSIFY-FILE-EXTENSION"
    "(DEFUN (CLASSIFY-FILE-EXTENSION KEYWORD) ((FILE FILE-NAME)))"
    (CL:FUNCTION CLASSIFY-FILE-EXTENSION) NULL)
   (DEFINE-FUNCTION-OBJECT "SELECT-ROOT-DIRECTORY"
    "(DEFUN (SELECT-ROOT-DIRECTORY STRING) ((TYPE KEYWORD)))"
    (CL:FUNCTION SELECT-ROOT-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "SELECT-SPLITTER-PATH"
    "(DEFUN (SELECT-SPLITTER-PATH STRING) ((TYPE KEYWORD)))"
    (CL:FUNCTION SELECT-SPLITTER-PATH) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-FILE-NAME-FROM-RELATIVE-PATH"
    "(DEFUN (MAKE-FILE-NAME-FROM-RELATIVE-PATH FILE-NAME) ((FILEPATH OBJECT) (TYPE KEYWORD)))"
    (CL:FUNCTION MAKE-FILE-NAME-FROM-RELATIVE-PATH) NULL)
   (DEFINE-FUNCTION-OBJECT "ROOT-DIRECTORY-PREFIX"
    "(DEFUN (ROOT-DIRECTORY-PREFIX FILE-NAME) ((FILE FILE-NAME)))"
    (CL:FUNCTION ROOT-DIRECTORY-PREFIX) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-FILE-NAME"
    "(DEFUN (MAKE-FILE-NAME FILE-NAME) ((FILEPATH STRING) (TYPE KEYWORD) (RELATIVE? BOOLEAN)))"
    (CL:FUNCTION MAKE-FILE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATIVIZE-FILE-NAME"
    "(DEFUN (RELATIVIZE-FILE-NAME FILE-NAME) ((FILE FILE-NAME) (ROOTPATH FILE-NAME)))"
    (CL:FUNCTION RELATIVIZE-FILE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-IMPLODE-PATHNAME"
    "(DEFUN (HELP-IMPLODE-PATHNAME FILE-NAME) ((FILENAME FILE-NAME)))"
    (CL:FUNCTION HELP-IMPLODE-PATHNAME) NULL)
   (DEFINE-FUNCTION-OBJECT "IMPLODE-PATHNAME"
    "(DEFUN (IMPLODE-PATHNAME FILE-NAME) ((FILEPATH OBJECT)))"
    (CL:FUNCTION IMPLODE-PATHNAME) NULL)
   (DEFINE-FUNCTION-OBJECT "MAYBE-TRUNCATE-FILENAME"
    "(DEFUN (MAYBE-TRUNCATE-FILENAME FILE-NAME) ((BAREFILENAME FILE-NAME)))"
    (CL:FUNCTION MAYBE-TRUNCATE-FILENAME) NULL)
   (DEFINE-FUNCTION-OBJECT "LANGUAGE-TO-FILE-TYPE"
    "(DEFUN (LANGUAGE-TO-FILE-TYPE KEYWORD) ((LANGUAGE KEYWORD)))"
    (CL:FUNCTION LANGUAGE-TO-FILE-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "REROOT-FILE-NAME"
    "(DEFUN (REROOT-FILE-NAME FILE-NAME) ((FILE FILE-NAME) (FROMROOT FILE-NAME) (TOROOT FILE-NAME)))"
    (CL:FUNCTION REROOT-FILE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-YOUNGER-THAN?"
    "(DEFUN (FILE-YOUNGER-THAN? THREE-VALUED-BOOLEAN) ((FILE1 STRING) (FILE2 STRING)))"
    (CL:FUNCTION FILE-YOUNGER-THAN?) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-NEED-TO-TRANSLATE?"
    "(DEFUN (STELLA-NEED-TO-TRANSLATE? BOOLEAN) ((FILE OBJECT) (LANGUAGE KEYWORD)))"
    (CL:FUNCTION STELLA-NEED-TO-TRANSLATE?) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-NEED-TO-COMPILE?"
    "(DEFUN (STELLA-NEED-TO-COMPILE? BOOLEAN) ((FILE OBJECT)))"
    (CL:FUNCTION STELLA-NEED-TO-COMPILE?) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-NEEDS-TRANSLATION?"
    "(DEFUN (SYSTEM-NEEDS-TRANSLATION? BOOLEAN) ((SYSTEMNAME STRING) (LANGUAGE KEYWORD)))"
    (CL:FUNCTION SYSTEM-NEEDS-TRANSLATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-FILE-UNITS-MODULE"
    "(DEFUN (COMPUTE-FILE-UNITS-MODULE MODULE) ((FILEUNITS (LIST OF TRANSLATION-UNIT))))"
    (CL:FUNCTION COMPUTE-FILE-UNITS-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "CONCATENATE-SYSTEM-UNITS"
    "(DEFUN (CONCATENATE-SYSTEM-UNITS (LIST OF TRANSLATION-UNIT)) ((SYSTEMUNITS SYSTEM-UNITS-ALIST)))"
    (CL:FUNCTION CONCATENATE-SYSTEM-UNITS) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-SYSTEM"
    "(DEFUN (TRANSLATE-SYSTEM BOOLEAN) ((SYSTEMNAME STRING) (OUTPUTLANGUAGE KEYWORD) |&REST| (OPTIONS OBJECT)) :DOCUMENTATION \"Translate all of the STELLA source files in system `systemName' into
`outputLanguage'.  The following keyword/value `options' are recognized:

`:two-pass?' (default false): if true, all files will be scanned twice, once
to load the signatures of objects defined in them, and once to actually
translate the definitions.

`:force-translation?' (default false): if true, files will be translated
whether or not their translations are up-to-date.

`:development-settings?' (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of `:development-settings' on the system definition).  If false, efficiency
will be favored instead (according to the value of `:production-settings'
on the system definition).

`:production-settings?' (default true): inverse to `:development-settings?'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION TRANSLATE-SYSTEM) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-TRANSLATE-SYSTEM"
    "(DEFUN (HELP-TRANSLATE-SYSTEM BOOLEAN) ((FILES (CONS OF STRING-WRAPPER)) (TWOPASS? BOOLEAN) (FORCETRANSLATION? BOOLEAN)))"
    (CL:FUNCTION HELP-TRANSLATE-SYSTEM) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSFER-NATIVE-SYSTEM-FILES"
    "(DEFUN TRANSFER-NATIVE-SYSTEM-FILES ((OUTPUTLANGUAGE KEYWORD)))"
    (CL:FUNCTION TRANSFER-NATIVE-SYSTEM-FILES) NULL))
  :VOID)

(CL:DEFUN STARTUP-TRANSLATE-FILE ()
  (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 0)
   (CL:SETQ *LOGICAL-HOST-TABLE* (NEW-STRING-HASH-TABLE))
   (DEFINE-LOGICAL-HOST-PROPERTY "PL" NULL NULL))
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-TRANSLATE-FILE1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4) (CL:SETQ *OS* (OPERATING-SYSTEM))
    (CL:SETQ *TYPE-TO-FILE-EXTENSION-TABLE*
     (LIST* (LIST* KWD-TRANSLATE-FILE-STELLA (WRAP-STRING ".ste") NIL)
      (LIST* KWD-TRANSLATE-FILE-KB (WRAP-STRING ".kb") NIL)
      (LIST* KWD-TRANSLATE-FILE-CPP (WRAP-STRING ".cc") NIL)
      (LIST* KWD-TRANSLATE-FILE-CPP-CODE (WRAP-STRING ".cc") NIL)
      (LIST* KWD-TRANSLATE-FILE-CPP-HEADER (WRAP-STRING ".hh") NIL)
      (LIST* KWD-TRANSLATE-FILE-C-CODE (WRAP-STRING ".c") NIL)
      (LIST* KWD-TRANSLATE-FILE-C-HEADER (WRAP-STRING ".h") NIL)
      (LIST* KWD-TRANSLATE-FILE-JAVA (WRAP-STRING ".java") NIL)
      (LIST* KWD-TRANSLATE-FILE-IDL (WRAP-STRING ".idl") NIL)
      (LIST* KWD-TRANSLATE-FILE-NONE (WRAP-STRING "") NIL) NIL)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE SYSTEM-UNITS-ALIST (KEY-VALUE-LIST OF STRING-WRAPPER (LIST OF TRANSLATION-UNIT)))"))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-TRANSLATE-FILE2)
    (DEFINE-FUNCTION-OBJECT "STARTUP-TRANSLATE-FILE"
     "(DEFUN STARTUP-TRANSLATE-FILE () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-TRANSLATE-FILE) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-TRANSLATE-FILE-STELLA-STARTUP-TRANSLATE-FILE)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-TRANSLATE-FILE-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupTranslateFile") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *RECORD-SIGNATURES?* BOOLEAN FALSE :DOCUMENTATION \"If `true', record object signatures into a persistent table.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *WALK-WITH-RECORDED-SIGNATURES?* BOOLEAN FALSE :DOCUMENTATION \"If `true', the walker will try to find previously recorded
signatures for referenced but undefined functions, methods, etc.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *USERECORDEDSIGNATURES?* BOOLEAN FALSE :DOCUMENTATION \"If `true', `safe-lookup-slot' and `lookup-function' will
try to retrieve a previously recorded signature if normal lookup fails.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *ROOTSOURCEDIRECTORY* STRING \"PL:sources;\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *ROOTNATIVEDIRECTORY* STRING \"PL:native;\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *ROOTBINARYDIRECTORY* STRING \"PL:bin;\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *SYSTEMDEFINITIONSDIRECTORY* STRING NULL :DOCUMENTATION \"Points to the directory containing the SYSTEMS file.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CURRENTSYSTEMDEFINITION* SYSTEM-DEFINITION NULL :DOCUMENTATION \"Points to the current system.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CURRENTSYSTEMDEFINITIONSUBDIRECTORY* STRING \"\" :DOCUMENTATION \"Points to a path from the root directory down
to a local directory containing sources, natives, or binaries.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *OS* KEYWORD (OPERATING-SYSTEM) :DOCUMENTATION \"The operating system we are running on.  Currently,
either :UNIX, :WINDOWS, or :MAC.  Note that on the Mac OS X, the
OS can be either :UNIX or :MAC, depending on which file naming 
conventions are being observed by the software.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT TYPE-SEPARATOR CHARACTER #\\.)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT LOGICAL-DIRECTORY-SEPARATOR CHARACTER #\\;)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT LOGICAL-HOST-SEPARATOR CHARACTER #\\:)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOGICAL-HOST-TABLE* (STRING-HASH-TABLE OF STRING KEY-VALUE-LIST) NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TYPE-TO-FILE-EXTENSION-TABLE* (CONS OF CONS) (BQUOTE ((:STELLA \".ste\") (:KB \".kb\") (:CPP \".cc\") (:CPP-CODE \".cc\") (:CPP-HEADER \".hh\") (:C-CODE \".c\") (:C-HEADER \".h\") (:JAVA \".java\") (:IDL \".idl\") (:NONE \"\"))) :DOCUMENTATION \"Used by `select-file-extension'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LISP-SPLITTER-PATH* STRING \"lisp\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *JAVA-SPLITTER-PATH* STRING \"java\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CPP-SPLITTER-PATH* STRING \"cpp\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DONTTRUNCATEFILENAMES?* BOOLEAN FALSE :DOCUMENTATION \"When TRUE, overrides normal truncation of file names.\")")))
  :VOID)
