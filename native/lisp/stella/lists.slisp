;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996-2000              | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-LISTS-STELLA-LIST NULL)
(CL:DEFVAR SGT-LISTS-STELLA-HASH-TABLE NULL)
(CL:DEFVAR SGT-LISTS-STELLA-KEY-VALUE-LIST NULL)
(CL:DEFVAR SGT-LISTS-STELLA-PROPERTY-LIST NULL)
(CL:DEFVAR SYM-LISTS-STELLA-STARTUP-LISTS NULL)
(CL:DEFVAR SYM-LISTS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM (CL:SPECIAL *STELLA-MODULE* *MODULE*))

;;; (DEFGLOBAL NIL-LIST ...)

(CL:DEFVAR NIL-LIST NULL)

;;; (DEFUN (DEFINED-LIST? BOOLEAN) ...)

(CL:DEFUN DEFINED-LIST? (SELF)
  "Return TRUE unless 'self' is NULL or the 'NIL-LIST'."
  (CL:RETURN-FROM DEFINED-LIST?
   (CL:AND (CL:NOT (CL:EQ SELF NIL-LIST)) (CL:NOT (CL:EQ SELF NULL)))))

;;; (DEFUN (NULL-LIST? BOOLEAN) ...)

(CL:DEFUN NULL-LIST? (SELF)
  "Return TRUE iff 'self' is NULL or the 'NIL-LIST'."
  (CL:RETURN-FROM NULL-LIST?
   (CL:OR (CL:EQ SELF NIL-LIST) (CL:EQ SELF NULL))))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF LIST))
  "Return TRUE if the list 'self' has no members."
  (CL:RETURN-FROM EMPTY? (CL:EQ (%LIST.THE-CONS-LIST SELF) NIL)))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF LIST))
  "Return TRUE if the list 'self' has at least one member."
  (CL:RETURN-FROM NON-EMPTY?
   (CL:NOT (CL:EQ (%LIST.THE-CONS-LIST SELF) NIL))))

;;; (DEFUN (TERMINATE-LIST? BOOLEAN) ...)

(CL:DEFUN TERMINATE-LIST? (SELF)
  (CL:WHEN (CL:EQ SELF NIL-LIST)
   (CL:WHEN (CL:EQ SELF NIL-LIST)
    (CL:ERROR "Safety violation: Attempt to free NIL-LIST."))
   (CL:RETURN-FROM TERMINATE-LIST? FALSE))
  (CL:LET* ((CONS (%LIST.THE-CONS-LIST SELF)) (REST NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CONS NIL)) DO
    (CL:SETQ REST (%%REST CONS)) (FREE CONS) (CL:SETQ CONS REST))
   (CL:SETF (%LIST.THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM TERMINATE-LIST? TRUE)))

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF LIST) OBJECT)
  "Return TRUE iff 'object' is a member of the list
'self' (uses an 'eql?' test)."
  (CL:LET* ((I NULL) (ITER-000 (%LIST.THE-CONS-LIST SELF)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ I (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (EQL? I OBJECT) (CL:RETURN-FROM MEMBER? TRUE))))
  (CL:RETURN-FROM MEMBER? FALSE))

;;; (DEFMETHOD (MEMB? BOOLEAN) ...)

(CL:DEFMETHOD MEMB? ((SELF LIST) OBJECT)
  "Return TRUE iff 'object' is a member of the cons list
'self' (uses an 'eq?' test)."
  (CL:LET* ((I NULL) (ITER-000 (%LIST.THE-CONS-LIST SELF)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ I (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (CL:EQ I OBJECT) (CL:RETURN-FROM MEMB? TRUE))))
  (CL:RETURN-FROM MEMB? FALSE))

;;; (DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIRST ((SELF LIST))
  "Return the first item in the list 'self', or NULL if empty."
  (CL:LET* ((CONS (%LIST.THE-CONS-LIST SELF)))
   (CL:RETURN-FROM FIRST
    (CL:IF (CL:NOT (CL:EQ CONS NIL)) (%%VALUE CONS) NULL))))

;;; (DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD SECOND ((SELF LIST))
  "Return the second item in the list 'self', or NULL if empty."
  (CL:RETURN-FROM SECOND (%%VALUE (%%REST (%LIST.THE-CONS-LIST SELF)))))

;;; (DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD THIRD ((SELF LIST))
  "Return the third item in the list 'self', or NULL if empty."
  (CL:RETURN-FROM THIRD
   (%%VALUE (%%REST (%%REST (%LIST.THE-CONS-LIST SELF))))))

;;; (DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FOURTH ((SELF LIST))
  "Return the fourth item in the list 'self', or NULL if empty."
  (CL:RETURN-FROM FOURTH (FOURTH (%LIST.THE-CONS-LIST SELF))))

;;; (DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIFTH ((SELF LIST))
  "Return the fifth item in the list 'self', or NULL if empty."
  (CL:RETURN-FROM FIFTH (FIFTH (%LIST.THE-CONS-LIST SELF))))

;;; (DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH ((SELF LIST) POSITION)
  "Return the nth item in the list 'self', or NULL if empty."
  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
  (CL:RETURN-FROM NTH (NTH (%LIST.THE-CONS-LIST SELF) POSITION)))

;;; (DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LAST ((SELF LIST))
  "Return the last element of 'self'."
  (CL:RETURN-FROM LAST (LAST (%LIST.THE-CONS-LIST SELF))))

;;; (DEFMETHOD (REST (CONS OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD REST ((SELF LIST))
  "Return a cons list of all but the first item in the list 'self'."
  (CL:RETURN-FROM REST (%%REST (%LIST.THE-CONS-LIST SELF))))

;;; (DEFMETHOD (FIRST-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIRST-SETTER ((SELF LIST) VALUE)
  (CL:RETURN-FROM FIRST-SETTER
   (FIRST-SETTER (%LIST.THE-CONS-LIST SELF) VALUE)))

;;; (DEFMETHOD (SECOND-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD SECOND-SETTER ((SELF LIST) VALUE)
  (CL:RETURN-FROM SECOND-SETTER
   (SECOND-SETTER (%LIST.THE-CONS-LIST SELF) VALUE)))

;;; (DEFMETHOD (THIRD-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD THIRD-SETTER ((SELF LIST) VALUE)
  (CL:RETURN-FROM THIRD-SETTER
   (THIRD-SETTER (%LIST.THE-CONS-LIST SELF) VALUE)))

;;; (DEFMETHOD (FOURTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FOURTH-SETTER ((SELF LIST) VALUE)
  (CL:RETURN-FROM FOURTH-SETTER
   (FOURTH-SETTER (%LIST.THE-CONS-LIST SELF) VALUE)))

;;; (DEFMETHOD (FIFTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIFTH-SETTER ((SELF LIST) VALUE)
  (CL:RETURN-FROM FIFTH-SETTER
   (FIFTH-SETTER (%LIST.THE-CONS-LIST SELF) VALUE)))

;;; (DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH-SETTER ((SELF LIST) VALUE POSITION)
  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
  (CL:RETURN-FROM NTH-SETTER
   (NTH-SETTER (%LIST.THE-CONS-LIST SELF) VALUE POSITION)))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF LIST))
  (CL:DECLARE (CL:INLINE LENGTH))
  (CL:RETURN-FROM LENGTH (LENGTH (%LIST.THE-CONS-LIST SELF))))

;;; (DEFMETHOD (POSITION INTEGER) ...)

(CL:DEFMETHOD POSITION ((SELF LIST) OBJECT START)
  "Return the position of 'object' within the list
'self' (counting from zero); or return NULL if 'object' does not occur within 
'self' (uses an 'eql?' test).  If 'start' was supplied as non-NULL, only 
consider the sublist starting at 'start', however, the returned position 
will always be relative to the entire list."
  (CL:DECLARE (CL:TYPE CL:FIXNUM START))
  (CL:RETURN-FROM POSITION
   (POSITION (%LIST.THE-CONS-LIST SELF) OBJECT START)))

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF LIST) VALUE)
  "Add 'value' to the front of the list 'self'."
  (CL:WHEN (CL:EQ SELF NIL-LIST)
   (CL:ERROR "Safety violation: Attempt to insert into NIL-LIST."))
  (CL:SETF (%LIST.THE-CONS-LIST SELF)
   (CONS VALUE (%LIST.THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFMETHOD PUSH ...)

(CL:DEFMETHOD PUSH ((SELF LIST) VALUE)
  "Add 'value' to the front of the list 'self'."
  (CL:WHEN (CL:EQ SELF NIL-LIST)
   (CL:ERROR "Safety violation: Attempt to insert into NIL-LIST."))
  (CL:SETF (%LIST.THE-CONS-LIST SELF)
   (CONS VALUE (%LIST.THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFMETHOD INSERT-NEW ...)

(CL:DEFMETHOD INSERT-NEW ((SELF LIST) VALUE)
  "Add 'value' to the front of the list 'self' unless its 
already a member."
  (CL:WHEN (CL:EQ SELF NIL-LIST)
   (CL:ERROR "Safety violation: Attempt to insert into NIL-LIST."))
  (CL:WHEN (CL:NOT (MEMBER? (%LIST.THE-CONS-LIST SELF) VALUE))
   (CL:SETF (%LIST.THE-CONS-LIST SELF)
    (CONS VALUE (%LIST.THE-CONS-LIST SELF))))
  :VOID)

;;; (DEFMETHOD INSERT-LAST ...)

(CL:DEFMETHOD INSERT-LAST ((SELF LIST) VALUE)
  "Insert 'value' as the last entry in the list 'self'."
  (CL:WHEN (CL:EQ SELF NIL-LIST)
   (CL:ERROR "Safety violation: Attempt to insert into NIL-LIST."))
  (CL:LET*
   ((CURSOR (%LIST.THE-CONS-LIST SELF)) (LASTCONS (CONS VALUE NIL)))
   (CL:IF (CL:EQ CURSOR NIL) (CL:SETF (%LIST.THE-CONS-LIST SELF) LASTCONS)
    (CL:PROGN
     (CL:LOOP WHILE (CL:NOT (CL:EQ (%%REST CURSOR) NIL)) DO
      (CL:SETQ CURSOR (%%REST CURSOR)))
     (CL:SETF (%%REST CURSOR) LASTCONS))))
  :VOID)

;;; (DEFMETHOD (REMOVE (LIKE SELF)) ...)

(CL:DEFMETHOD REMOVE ((SELF LIST) VALUE)
  "Destructively remove all entries in 'self' that match 'value'."
  (CL:SETF (%LIST.THE-CONS-LIST SELF)
   (REMOVE (%LIST.THE-CONS-LIST SELF) VALUE))
  (CL:RETURN-FROM REMOVE SELF))

;;; (DEFMETHOD (REMOVE-IF (LIKE SELF)) ...)

(CL:DEFMETHOD REMOVE-IF ((SELF LIST) TEST?)
  "Destructively remove all members of the list 'self' for which
'test?' evaluates to TRUE.  'test' takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns 'self'."
  (CL:SETF (%LIST.THE-CONS-LIST SELF)
   (REMOVE-IF (%LIST.THE-CONS-LIST SELF) TEST?))
  (CL:RETURN-FROM REMOVE-IF SELF))

;;; (DEFMETHOD (REMOVE-DUPLICATES (LIKE SELF)) ...)

(CL:DEFMETHOD REMOVE-DUPLICATES ((SELF LIST))
  "Destructively remove duplicates from `self' and return the result.
Preserves the original order of the remaining members."
  (CL:WHEN (CL:NOT (CL:EQ (%LIST.THE-CONS-LIST SELF) NIL))
   (CL:SETF (%LIST.THE-CONS-LIST SELF)
    (REMOVE-DUPLICATES (%LIST.THE-CONS-LIST SELF))))
  (CL:RETURN-FROM REMOVE-DUPLICATES SELF))

;;; (DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD POP ((SELF LIST))
  "Remove and return the first element in the list 'self'.
Return NULL if the list is empty."
  (CL:LET* ((CONS (%LIST.THE-CONS-LIST SELF)) (VALUE NULL))
   (CL:WHEN (CL:EQ CONS NIL) (CL:RETURN-FROM POP NULL))
   (CL:SETQ VALUE (%%VALUE CONS))
   (CL:SETF (%LIST.THE-CONS-LIST SELF) (%%REST CONS))
   (CL:RETURN-FROM POP VALUE)))

;;; (DEFMETHOD (REVERSE (LIKE SELF)) ...)

(CL:DEFMETHOD REVERSE ((SELF LIST))
  "Reverse the members of 'self' (in place)."
  (CL:SETF (%LIST.THE-CONS-LIST SELF) (REVERSE (%LIST.THE-CONS-LIST SELF)))
  (CL:RETURN-FROM REVERSE SELF))

;;; (DEFMETHOD (SUBSTITUTE (LIKE SELF)) ...)

(CL:DEFMETHOD SUBSTITUTE ((SELF LIST) INVALUE OUTVALUE)
  "Destructively replace each appearance of 'outValue' by
'inValue' in the list 'self'."
  (CL:SETF (%LIST.THE-CONS-LIST SELF)
   (SUBSTITUTE (%LIST.THE-CONS-LIST SELF) INVALUE OUTVALUE))
  (CL:RETURN-FROM SUBSTITUTE SELF))

;;; (DEFMETHOD (CONCATENATE LIST) ...)

(CL:DEFMETHOD CONCATENATE ((LIST1 LIST) LIST2 CL:&REST OTHERLISTS)
  "Copy `list2' and all `otherLists' onto the end of `list1'.
The operation is destructive wrt `list1', but leaves all other lists intact.
The two mandatory parameters allow us to optimize the common binary case by
not relying on the somewhat less efficient variable arguments mechanism."
  (CL:LET*
   ((FIRSTLIST (%LIST.THE-CONS-LIST LIST1))
    (LASTLIST (%LIST.THE-CONS-LIST LIST2)) (COPY NIL))
   (CL:COND
    ((CL:EQ FIRSTLIST NIL) (CL:SETQ FIRSTLIST (COPY-CONS-LIST LASTLIST))
     (CL:SETQ LASTLIST FIRSTLIST))
    ((CL:EQ LASTLIST NIL) (CL:SETQ LASTLIST FIRSTLIST))
    (CL:T (CL:SETQ LASTLIST (COPY-CONS-LIST LASTLIST))
     (CL:SETF (%%REST (LAST-CONS FIRSTLIST)) LASTLIST)))
   (CL:WHEN (CL:> (CL:LENGTH OTHERLISTS) 0)
    (CL:LET* ((LIST NULL) (ITER-000 OTHERLISTS))
     (CL:LOOP WHILE ITER-000 DO (CL:SETQ LIST (CL:POP ITER-000))
      (CL:WHEN (NON-EMPTY? LIST)
       (CL:SETQ COPY (COPY-CONS-LIST (%LIST.THE-CONS-LIST LIST)))
       (CL:IF (CL:NOT (CL:EQ LASTLIST NIL))
        (CL:SETF (%%REST (LAST-CONS LASTLIST)) COPY)
        (CL:SETQ FIRSTLIST COPY))
       (CL:SETQ LASTLIST COPY)))))
   (CL:SETF (%LIST.THE-CONS-LIST LIST1) FIRSTLIST)
   (CL:RETURN-FROM CONCATENATE LIST1)))

;;; (DEFMETHOD (PREPEND (LIKE SELF)) ...)

(CL:DEFMETHOD PREPEND ((SELF LIST) LIST2)
  "Copy 'list2' onto the front of the list 'self'.
The operation is destructive wrt 'self', but leaves 'list2' intact."
  (CL:WHEN (EMPTY? LIST2) (CL:RETURN-FROM PREPEND SELF))
  (CL:SETF (%LIST.THE-CONS-LIST SELF)
   (CONCATENATE (COPY-CONS-LIST (%LIST.THE-CONS-LIST LIST2))
    (%LIST.THE-CONS-LIST SELF)))
  (CL:RETURN-FROM PREPEND SELF))

;;; (DEFMETHOD (COPY (LIST OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD COPY ((SELF LIST))
  "Return a copy of the list 'self'.  The conses in the copy are
freshly allocated."
  (CL:LET* ((COPY (CREATE-OBJECT (PRIMARY-TYPE SELF))))
   (CL:SETF (%LIST.THE-CONS-LIST COPY)
    (COPY-CONS-LIST (%LIST.THE-CONS-LIST SELF)))
   (CL:RETURN-FROM COPY COPY)))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF LIST))
  "Make 'self' an empty list."
  (CL:SETF (%LIST.THE-CONS-LIST SELF) NIL)
  :VOID)

;;; (DEFMETHOD (SORT (LIST OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD SORT ((SELF LIST) PREDICATE)
  "Perform a stable, destructive sort of 'self' according to
'predicate', and return the result.  If 'predicate' has a '<' semantics, the
result will be in ascending order.  If 'predicate' is NULL, a suitable
'<' predicate is chosen depending on the first element of 'self', and it 
is assumed that all elements of 'self' have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT)."
  (CL:SETF (%LIST.THE-CONS-LIST SELF)
   (SORT (%LIST.THE-CONS-LIST SELF) PREDICATE))
  (CL:RETURN-FROM SORT SELF))

;;; (DEFUN (MAP-NULL-TO-NIL-LIST LIST) ...)

(CL:DEFUN MAP-NULL-TO-NIL-LIST (SELF)
  "Return NIL-LIST iff 'self' is NULL or `self' otherwise."
  (CL:RETURN-FROM MAP-NULL-TO-NIL-LIST
   (CL:IF (CL:EQ SELF NULL) NIL-LIST SELF)))

;;; (DEFMETHOD (ALLOCATE-ITERATOR (LIST-ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF LIST))
  (CL:LET* ((ITERATOR (NEW-LIST-ITERATOR)))
   (CL:SETF (%LIST-ITERATOR.LIST-ITERATOR-CURSOR ITERATOR)
    (%LIST.THE-CONS-LIST SELF))
   (CL:SETF (%LIST-ITERATOR.LIST-ITERATOR-COLLECTION ITERATOR) SELF)
   (CL:SETF (%LIST-ITERATOR.FIRST-ITERATION? ITERATOR) TRUE)
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR)))

;;; (DEFUN (TERMINATE-LIST-ITERATOR? BOOLEAN) ...)

(CL:DEFUN TERMINATE-LIST-ITERATOR? (SELF)
  (CL:SETF (%LIST-ITERATOR.LIST-ITERATOR-CURSOR SELF) NIL)
  (CL:SETF (%LIST-ITERATOR.LIST-ITERATOR-COLLECTION SELF) NULL)
  (CL:RETURN-FROM TERMINATE-LIST-ITERATOR? TRUE))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF LIST-ITERATOR))
  (CL:IF (%LIST-ITERATOR.FIRST-ITERATION? SELF)
   (CL:PROGN (CL:SETF (%LIST-ITERATOR.FIRST-ITERATION? SELF) FALSE)
    (CL:SETF (%LIST-ITERATOR.LIST-ITERATOR-CURSOR SELF)
     (%LIST.THE-CONS-LIST
      (%LIST-ITERATOR.LIST-ITERATOR-COLLECTION SELF))))
   (CL:SETF (%LIST-ITERATOR.LIST-ITERATOR-CURSOR SELF)
    (%%REST (%LIST-ITERATOR.LIST-ITERATOR-CURSOR SELF))))
  (CL:SETF (%LIST-ITERATOR.VALUE SELF)
   (%%VALUE (%LIST-ITERATOR.LIST-ITERATOR-CURSOR SELF)))
  (CL:RETURN-FROM NEXT?
   (CL:NOT (CL:EQ (%LIST-ITERATOR.LIST-ITERATOR-CURSOR SELF) NIL))))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF LIST-ITERATOR))
  (CL:RETURN-FROM EMPTY?
   (CL:IF (%LIST-ITERATOR.FIRST-ITERATION? SELF)
    (CL:EQ
     (%LIST.THE-CONS-LIST (%LIST-ITERATOR.LIST-ITERATOR-COLLECTION SELF))
     NIL)
    (CL:EQ (%%REST (%LIST-ITERATOR.LIST-ITERATOR-CURSOR SELF)) NIL))))

;;; (DEFMETHOD (VALUE-SETTER OBJECT) ...)

(CL:DEFMETHOD VALUE-SETTER ((SELF LIST-ITERATOR) VALUE)
  (CL:SETF (%%VALUE (%LIST-ITERATOR.LIST-ITERATOR-CURSOR SELF)) VALUE)
  (CL:SETF (%LIST-ITERATOR.VALUE SELF) VALUE)
  (CL:RETURN-FROM VALUE-SETTER VALUE))

;;; (DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD BUT-LAST ((SELF LIST))
  "Generate all but the last element of the list 'self'."
  (CL:RETURN-FROM BUT-LAST (BUT-LAST (%LIST.THE-CONS-LIST SELF))))

;;; (DEFMETHOD (REMOVE-DELETED-MEMBERS (LIKE SELF)) ...)

(CL:DEFMETHOD REMOVE-DELETED-MEMBERS ((SELF LIST))
  (CL:SETF (%LIST.THE-CONS-LIST SELF)
   (REMOVE-DELETED-MEMBERS (%LIST.THE-CONS-LIST SELF)))
  (CL:RETURN-FROM REMOVE-DELETED-MEMBERS SELF))

;;; (DEFMETHOD INITIALIZE-OBJECT ...)

(CL:DEFMETHOD INITIALIZE-OBJECT ((SELF PROPERTY-LIST))
  (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF) NIL)
  :VOID)

;;; (DEFUN (SEARCH-PLIST OBJECT) ...)

(CL:DEFUN SEARCH-PLIST (PLIST KEY)
  (CL:LOOP WHILE (CL:NOT (CL:EQ PLIST NIL)) DO
   (CL:WHEN (EQL? (%%VALUE PLIST) KEY)
    (CL:RETURN-FROM SEARCH-PLIST (%%VALUE (%%REST PLIST))))
   (CL:SETQ PLIST (%%REST (%%REST PLIST))))
  (CL:RETURN-FROM SEARCH-PLIST NULL))

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF PROPERTY-LIST) KEY)
  (CL:DECLARE (CL:INLINE SEARCH-PLIST))
  (CL:RETURN-FROM LOOKUP
   (SEARCH-PLIST (%PROPERTY-LIST.THE-PLIST SELF) KEY)))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF PROPERTY-LIST))
  (CL:LET* ((CURSOR (%PROPERTY-LIST.THE-PLIST SELF)) (LENGTH 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:SETQ LENGTH (CL:1+ LENGTH))
    (CL:SETQ CURSOR (%%REST (%%REST CURSOR))))
   (CL:RETURN-FROM LENGTH LENGTH)))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF PROPERTY-LIST) KEY VALUE)
  "Insert the entry <`key', `value'> into the property list `self'.
If a previous entry existed with key `key', that entry is replaced."
  (CL:LET* ((CURSOR (%PROPERTY-LIST.THE-PLIST SELF)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:WHEN (EQL? (%%VALUE CURSOR) KEY) (CL:SETQ CURSOR (%%REST CURSOR))
     (CL:SETF (%%VALUE CURSOR) VALUE) (CL:RETURN-FROM INSERT-AT))
    (CL:SETQ CURSOR (%%REST (%%REST CURSOR))))
   (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF)
    (CONS KEY (CONS VALUE (%PROPERTY-LIST.THE-PLIST SELF)))))
  :VOID)

;;; (DEFMETHOD (REMOVE-AT OBJECT) ...)

(CL:DEFMETHOD REMOVE-AT ((SELF PROPERTY-LIST) KEY)
  "Remove the entry that matches the key `key'.  Return the
value of the matching entry, or NULL if there is no matching entry.  Assumes that at
most one entry matches `key'."
  (CL:LET*
   ((CURSOR (%PROPERTY-LIST.THE-PLIST SELF)) (PREVIOUSCONS NULL)
    (VALUE NULL))
   (CL:WHEN (CL:NOT (CL:EQ CURSOR NIL))
    (CL:WHEN (EQL? (%%VALUE CURSOR) KEY)
     (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF) (%%REST (%%REST CURSOR)))
     (CL:SETQ VALUE (%%VALUE (%%REST CURSOR)))
     (CL:RETURN-FROM REMOVE-AT VALUE))
    (CL:SETQ PREVIOUSCONS (%%REST CURSOR))
    (CL:SETQ CURSOR (%%REST PREVIOUSCONS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
     (CL:WHEN (EQL? (%%VALUE CURSOR) KEY)
      (CL:SETF (%%REST PREVIOUSCONS) (%%REST (%%REST CURSOR)))
      (CL:SETQ VALUE (%%VALUE (%%REST CURSOR)))
      (CL:RETURN-FROM REMOVE-AT VALUE))
     (CL:SETQ PREVIOUSCONS (%%REST CURSOR))
     (CL:SETQ CURSOR (%%REST PREVIOUSCONS))))
   (CL:RETURN-FROM REMOVE-AT NULL)))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF PROPERTY-LIST))
  (CL:RETURN-FROM EMPTY? (CL:EQ (%PROPERTY-LIST.THE-PLIST SELF) NIL)))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF PROPERTY-LIST))
  (CL:RETURN-FROM NON-EMPTY?
   (CL:NOT (CL:EQ (%PROPERTY-LIST.THE-PLIST SELF) NIL))))

;;; (DEFMETHOD (COPY (LIKE SELF)) ...)

(CL:DEFMETHOD COPY ((SELF PROPERTY-LIST))
  "Return a copy of the list `self'.  The conses in the copy are
freshly allocated."
  (CL:LET* ((COPY (CREATE-OBJECT (PRIMARY-TYPE SELF))))
   (CL:SETF (%PROPERTY-LIST.THE-PLIST COPY)
    (COPY-CONS-LIST (%PROPERTY-LIST.THE-PLIST SELF)))
   (CL:RETURN-FROM COPY COPY)))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF PROPERTY-LIST))
  "Make `self' an empty property list."
  (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF) NIL)
  :VOID)

;;; (DEFMETHOD (EQUIVALENT-SETS? BOOLEAN) ...)

(CL:DEFMETHOD EQUIVALENT-SETS? ((SELF LIST) OTHERLIST)
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:LET* ((ALWAYS?-000 TRUE))
    (CL:LET* ((ITEM NULL) (ITER-000 (%LIST.THE-CONS-LIST SELF)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:PROGN (CL:SETQ ITEM (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (CL:WHEN (CL:NOT (MEMBER? OTHERLIST ITEM))
       (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
    (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000 (CL:= (LENGTH SELF) (LENGTH OTHERLIST))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM EQUIVALENT-SETS? VALUE-000))))

;;; (DEFMETHOD (INTERSECTION LIST) ...)

(CL:DEFMETHOD INTERSECTION ((SELF LIST) OTHERLIST)
  (CL:LET* ((LIST (NEW-LIST)))
   (CL:LET*
    ((I NULL) (ITER-000 (%LIST.THE-CONS-LIST SELF)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ I (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (MEMBER? OTHERLIST I)
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS I NIL))
        (CL:IF (CL:EQ (%LIST.THE-CONS-LIST LIST) NIL)
         (CL:SETF (%LIST.THE-CONS-LIST LIST) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST LIST)
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS I NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:RETURN-FROM INTERSECTION LIST)))

;;; (DEFMETHOD (UNION LIST) ...)

(CL:DEFMETHOD UNION ((SELF LIST) OTHERLIST)
  (CL:LET* ((LIST (COPY SELF)) (OTHERSURVIVORS (NEW-LIST)))
   (CL:LET*
    ((I NULL) (ITER-000 (%LIST.THE-CONS-LIST OTHERLIST))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ I (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (CL:NOT (MEMBER? LIST I))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS I NIL))
        (CL:IF (CL:EQ (%LIST.THE-CONS-LIST OTHERSURVIVORS) NIL)
         (CL:SETF (%LIST.THE-CONS-LIST OTHERSURVIVORS) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST
          (%LIST.THE-CONS-LIST OTHERSURVIVORS) COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS I NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:RETURN-FROM UNION (CONCATENATE LIST OTHERSURVIVORS))))

;;; (DEFMETHOD (DIFFERENCE LIST) ...)

(CL:DEFMETHOD DIFFERENCE ((SELF LIST) OTHERLIST)
  (CL:LET* ((LIST (COPY SELF)))
   (CL:WHEN (CL:EQ OTHERLIST NULL) (CL:RETURN-FROM DIFFERENCE LIST))
   (CL:LET* ((I NULL) (ITER-000 (%LIST.THE-CONS-LIST OTHERLIST)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ I (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (MEMBER? LIST I) (REMOVE LIST I))))
   (CL:RETURN-FROM DIFFERENCE LIST)))

;;; (DEFMETHOD (SUBTRACT LIST) ...)

(CL:DEFMETHOD SUBTRACT ((SELF LIST) OTHERLIST)
  (CL:WHEN (CL:EQ OTHERLIST NULL) (CL:RETURN-FROM SUBTRACT SELF))
  (CL:LET* ((I NULL) (ITER-000 (%LIST.THE-CONS-LIST OTHERLIST)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ I (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (MEMBER? SELF I) (REMOVE SELF I))))
  (CL:RETURN-FROM SUBTRACT SELF))

;;; (DEFMETHOD (ALLOCATE-ITERATOR (PROPERTY-LIST-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF PROPERTY-LIST))
  (CL:LET* ((ITERATOR (NEW-PROPERTY-LIST-ITERATOR)))
   (CL:SETF (%PROPERTY-LIST-ITERATOR.PLIST-ITERATOR-CURSOR ITERATOR)
    (%PROPERTY-LIST.THE-PLIST SELF))
   (CL:SETF (%PROPERTY-LIST-ITERATOR.PLIST-ITERATOR-COLLECTION ITERATOR)
    SELF)
   (CL:SETF (%PROPERTY-LIST-ITERATOR.FIRST-ITERATION? ITERATOR) TRUE)
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR)))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF PROPERTY-LIST-ITERATOR))
  (CL:IF (%PROPERTY-LIST-ITERATOR.FIRST-ITERATION? SELF)
   (CL:SETF (%PROPERTY-LIST-ITERATOR.FIRST-ITERATION? SELF) FALSE)
   (CL:SETF (%PROPERTY-LIST-ITERATOR.PLIST-ITERATOR-CURSOR SELF)
    (%%REST
     (%%REST (%PROPERTY-LIST-ITERATOR.PLIST-ITERATOR-CURSOR SELF)))))
  (CL:LET*
   ((REMAININGPLIST (%PROPERTY-LIST-ITERATOR.PLIST-ITERATOR-CURSOR SELF)))
   (CL:WHEN (CL:NOT (CL:EQ REMAININGPLIST NIL))
    (CL:SETF (%PROPERTY-LIST-ITERATOR.KEY SELF) (%%VALUE REMAININGPLIST))
    (CL:SETF (%PROPERTY-LIST-ITERATOR.VALUE SELF)
     (%%VALUE (%%REST REMAININGPLIST)))
    (CL:RETURN-FROM NEXT? TRUE))
   (CL:RETURN-FROM NEXT? FALSE)))

;;; (DEFMETHOD (VALUE-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD VALUE-SETTER ((SELF PROPERTY-LIST-ITERATOR) VALUE)
  (CL:SETF
   (%%VALUE (%%REST (%PROPERTY-LIST-ITERATOR.PLIST-ITERATOR-CURSOR SELF)))
   VALUE)
  (CL:SETF (%PROPERTY-LIST-ITERATOR.VALUE SELF) VALUE)
  (CL:RETURN-FROM VALUE-SETTER VALUE))

;;; (DEFMETHOD (KEY-SETTER (LIKE (ANY-KEY SELF))) ...)

(CL:DEFMETHOD KEY-SETTER ((SELF PROPERTY-LIST-ITERATOR) KEY)
  (CL:SETF (%%VALUE (%PROPERTY-LIST-ITERATOR.PLIST-ITERATOR-CURSOR SELF))
   KEY)
  (CL:SETF (%PROPERTY-LIST-ITERATOR.KEY SELF) KEY)
  (CL:RETURN-FROM KEY-SETTER KEY))

;;; (DEFUN (KV-CONS KV-CONS) ...)

(CL:DEFUN KV-CONS (KEY VALUE REST)
  "Create, fill-in, and return a new KV-CONS."
  (CL:LET* ((NEWKVC (NEW-KV-CONS))) (CL:SETF (%KV-CONS.KEY NEWKVC) KEY)
   (CL:SETF (%KV-CONS.VALUE NEWKVC) VALUE)
   (CL:SETF (%KV-CONS.REST NEWKVC) REST) (CL:RETURN-FROM KV-CONS NEWKVC)))

;;; (DEFUN FREE-KV-CONS ...)

(CL:DEFUN FREE-KV-CONS (KVCONS)
  (FREE KVCONS)
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF KEY-VALUE-LIST) KEY)
  (CL:LET* ((CURSOR (%KEY-VALUE-LIST.THE-KV-LIST SELF)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
    (CL:WHEN (EQL? (%KV-CONS.KEY CURSOR) KEY)
     (CL:RETURN-FROM LOOKUP (%KV-CONS.VALUE CURSOR)))
    (CL:SETQ CURSOR (%KV-CONS.REST CURSOR)))
   (CL:RETURN-FROM LOOKUP NULL)))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF KEY-VALUE-LIST))
  (CL:LET* ((LENGTH 0) (CURSOR (%KEY-VALUE-LIST.THE-KV-LIST SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
    (CL:SETQ LENGTH (CL:1+ LENGTH))
    (CL:SETQ CURSOR (%KV-CONS.REST CURSOR)))
   (CL:RETURN-FROM LENGTH LENGTH)))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF KEY-VALUE-LIST) KEY VALUE)
  "Insert the entry <'key', 'value'> into the association
'self'. If a previous entry existed with key 'key', that entry is replaced."
  (CL:LET* ((CURSOR (%KEY-VALUE-LIST.THE-KV-LIST SELF)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
    (CL:WHEN (EQL? (%KV-CONS.KEY CURSOR) KEY)
     (CL:SETF (%KV-CONS.VALUE CURSOR) VALUE) (CL:RETURN-FROM INSERT-AT))
    (CL:SETQ CURSOR (%KV-CONS.REST CURSOR)))
   (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST SELF)
    (KV-CONS KEY VALUE (%KEY-VALUE-LIST.THE-KV-LIST SELF))))
  :VOID)

;;; (DEFMETHOD (REMOVE-AT OBJECT) ...)

(CL:DEFMETHOD REMOVE-AT ((SELF KEY-VALUE-LIST) KEY)
  "Remove the entry that matches the key 'key'.
Return the value of the matching entry, or NULL if there is no matching entry.
Assumes that at most one entry matches 'key'."
  (CL:LET*
   ((CURSOR (%KEY-VALUE-LIST.THE-KV-LIST SELF)) (PREVIOUSCURSOR NULL)
    (VALUE NULL))
   (CL:WHEN (CL:NOT (CL:EQ CURSOR NULL))
    (CL:WHEN (EQL? (%KV-CONS.KEY CURSOR) KEY)
     (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST SELF) (%KV-CONS.REST CURSOR))
     (CL:SETQ VALUE (%KV-CONS.VALUE CURSOR)) (FREE-KV-CONS CURSOR)
     (CL:RETURN-FROM REMOVE-AT VALUE))
    (CL:LOOP WHILE (CL:NOT (CL:EQ (%KV-CONS.REST CURSOR) NULL)) DO
     (CL:SETQ PREVIOUSCURSOR CURSOR)
     (CL:SETQ CURSOR (%KV-CONS.REST CURSOR))
     (CL:WHEN (EQL? (%KV-CONS.KEY CURSOR) KEY)
      (CL:SETF (%KV-CONS.REST PREVIOUSCURSOR) (%KV-CONS.REST CURSOR))
      (CL:SETQ VALUE (%KV-CONS.VALUE CURSOR)) (FREE-KV-CONS CURSOR)
      (CL:RETURN-FROM REMOVE-AT VALUE))))
   (CL:RETURN-FROM REMOVE-AT NULL)))

;;; (DEFMETHOD INSERT-ENTRY ...)

(CL:DEFMETHOD INSERT-ENTRY ((SELF KEY-VALUE-LIST) KEY VALUE)
  "Insert an entry <'key','value'> to 'self' unless an identical
entry already exists.  This can generate duplicate entries for 'key'."
  (CL:LET* ((FOUND?-000 FALSE))
   (CL:LET*
    ((V NULL) (K NULL) (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST SELF)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
     (CL:SETQ K (%KV-CONS.KEY ITER-000))
     (CL:PROGN (CL:SETQ V (%KV-CONS.VALUE ITER-000))
      (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000)))
     (CL:WHEN (CL:AND (CL:EQ K KEY) (CL:EQ V VALUE))
      (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
   (CL:WHEN (CL:NOT FOUND?-000)
    (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST SELF)
     (KV-CONS KEY VALUE (%KEY-VALUE-LIST.THE-KV-LIST SELF)))))
  :VOID)

;;; (DEFMETHOD REMOVE-ENTRY ...)

(CL:DEFMETHOD REMOVE-ENTRY ((SELF KEY-VALUE-LIST) KEY VALUE)
  "Remove the entry that matches <'key','value'>.
Assumes that more than one entry can match 'key'."
  (CL:LET*
   ((CURSOR (%KEY-VALUE-LIST.THE-KV-LIST SELF)) (PREVIOUSCURSOR NULL))
   (CL:WHEN (CL:NOT (CL:EQ CURSOR NULL))
    (CL:WHEN
     (CL:AND (EQL? (%KV-CONS.KEY CURSOR) KEY)
      (EQL? (%KV-CONS.VALUE CURSOR) VALUE))
     (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST SELF) (%KV-CONS.REST CURSOR))
     (FREE-KV-CONS CURSOR) (CL:RETURN-FROM REMOVE-ENTRY))
    (CL:LOOP WHILE (CL:NOT (CL:EQ (%KV-CONS.REST CURSOR) NULL)) DO
     (CL:SETQ PREVIOUSCURSOR CURSOR)
     (CL:SETQ CURSOR (%KV-CONS.REST CURSOR))
     (CL:WHEN
      (CL:AND (EQL? (%KV-CONS.KEY CURSOR) KEY)
       (EQL? (%KV-CONS.VALUE CURSOR) VALUE))
      (CL:SETF (%KV-CONS.REST PREVIOUSCURSOR) (%KV-CONS.REST CURSOR))
      (FREE-KV-CONS CURSOR) (CL:RETURN-FROM REMOVE-ENTRY)))))
  :VOID)

;;; (DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD POP ((SELF KEY-VALUE-LIST))
  "Remove and return the first element of the kv-list 'self'.
Return NULL if the list is empty."
  (CL:WHEN (EMPTY? SELF) (CL:RETURN-FROM POP NULL))
  (CL:LET* ((CONS (%KEY-VALUE-LIST.THE-KV-LIST SELF)) (VALUE NULL))
   (CL:SETQ VALUE (%KV-CONS.VALUE CONS))
   (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST SELF) (%KV-CONS.REST CONS))
   (FREE-KV-CONS CONS) (CL:RETURN-FROM POP VALUE)))

;;; (DEFMETHOD (REVERSE (LIKE SELF)) ...)

(CL:DEFMETHOD REVERSE ((SELF KEY-VALUE-LIST))
  "Destructively reverse the members of the list 'self'."
  (CL:LET*
   ((REVERSEDLIST (%KEY-VALUE-LIST.THE-KV-LIST SELF)) (REMAININGLIST NULL)
    (TEMP NULL))
   (CL:WHEN (CL:EQ REVERSEDLIST NULL) (CL:RETURN-FROM REVERSE SELF))
   (CL:SETQ REMAININGLIST (%KV-CONS.REST REVERSEDLIST))
   (CL:WHEN (CL:EQ REMAININGLIST NULL) (CL:RETURN-FROM REVERSE SELF))
   (CL:SETF (%KV-CONS.REST REVERSEDLIST) NULL)
   (CL:LOOP WHILE (CL:NOT (CL:EQ REMAININGLIST NULL)) DO
    (CL:SETQ TEMP REMAININGLIST)
    (CL:SETQ REMAININGLIST (%KV-CONS.REST REMAININGLIST))
    (CL:SETF (%KV-CONS.REST TEMP) REVERSEDLIST)
    (CL:SETQ REVERSEDLIST TEMP))
   (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST SELF) REVERSEDLIST)
   (CL:RETURN-FROM REVERSE SELF)))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF KEY-VALUE-LIST))
  (CL:RETURN-FROM EMPTY? (CL:EQ (%KEY-VALUE-LIST.THE-KV-LIST SELF) NULL)))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF KEY-VALUE-LIST))
  (CL:RETURN-FROM NON-EMPTY?
   (CL:NOT (CL:EQ (%KEY-VALUE-LIST.THE-KV-LIST SELF) NULL))))

;;; (DEFUN (COPY-KV-CONS-LIST KV-CONS) ...)

(CL:DEFUN COPY-KV-CONS-LIST (KVCONSLIST)
  "Return a copy of the cons list 'consList'."
  (CL:WHEN (CL:EQ KVCONSLIST NULL) (CL:RETURN-FROM COPY-KV-CONS-LIST NULL))
  (CL:LET*
   ((NEWKVCONSLIST (NEW-KV-CONS)) (NEXTKVCONS NEWKVCONSLIST)
    (COPYFROMKVCONS NULL) (PREVIOUSKVCONS NULL))
   (CL:SETF (%KV-CONS.KEY NEXTKVCONS) (%KV-CONS.KEY KVCONSLIST))
   (CL:SETF (%KV-CONS.VALUE NEXTKVCONS) (%KV-CONS.VALUE KVCONSLIST))
   (CL:SETQ COPYFROMKVCONS (%KV-CONS.REST KVCONSLIST))
   (CL:LOOP WHILE (CL:NOT (CL:EQ COPYFROMKVCONS NULL)) DO
    (CL:SETQ PREVIOUSKVCONS NEXTKVCONS) (CL:SETQ NEXTKVCONS (NEW-KV-CONS))
    (CL:SETF (%KV-CONS.REST PREVIOUSKVCONS) NEXTKVCONS)
    (CL:SETF (%KV-CONS.KEY NEXTKVCONS) (%KV-CONS.KEY COPYFROMKVCONS))
    (CL:SETF (%KV-CONS.VALUE NEXTKVCONS) (%KV-CONS.VALUE COPYFROMKVCONS))
    (CL:SETQ COPYFROMKVCONS (%KV-CONS.REST COPYFROMKVCONS)))
   (CL:SETF (%KV-CONS.REST NEXTKVCONS) NULL)
   (CL:RETURN-FROM COPY-KV-CONS-LIST NEWKVCONSLIST)))

;;; (DEFMETHOD (COPY (LIKE SELF)) ...)

(CL:DEFMETHOD COPY ((SELF KEY-VALUE-LIST))
  "Return a copy of the kv-list 'self'.  The kv-conses in
the copy are freshly allocated."
  (CL:LET* ((COPY (NEW-KEY-VALUE-LIST)))
   (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST COPY)
    (COPY-KV-CONS-LIST (%KEY-VALUE-LIST.THE-KV-LIST SELF)))
   (CL:RETURN-FROM COPY COPY)))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF KEY-VALUE-LIST))
  "Make 'self' an empty dictionary."
  (CL:LET* ((NEXT (%KEY-VALUE-LIST.THE-KV-LIST SELF)) (CURRENT NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ NEXT NULL)) DO (CL:SETQ CURRENT NEXT)
    (CL:SETQ NEXT (%KV-CONS.REST NEXT)) (FREE-KV-CONS CURRENT))
   (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST SELF) NULL))
  :VOID)

;;; (DEFMETHOD (ALLOCATE-ITERATOR (KV-LIST-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF KEY-VALUE-LIST))
  (CL:LET* ((ITERATOR (NEW-KV-LIST-ITERATOR)))
   (CL:SETF (%KV-LIST-ITERATOR.THE-KV-LIST ITERATOR) SELF)
   (CL:SETF (%KV-LIST-ITERATOR.KV-LIST-ITERATOR-CURSOR ITERATOR)
    (%KEY-VALUE-LIST.THE-KV-LIST SELF))
   (CL:SETF (%KV-LIST-ITERATOR.FIRST-ITERATION? ITERATOR) TRUE)
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR)))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF KV-LIST-ITERATOR))
  (CL:IF (%KV-LIST-ITERATOR.FIRST-ITERATION? SELF)
   (CL:SETF (%KV-LIST-ITERATOR.FIRST-ITERATION? SELF) FALSE)
   (CL:SETF (%KV-LIST-ITERATOR.KV-LIST-ITERATOR-CURSOR SELF)
    (%KV-CONS.REST (%KV-LIST-ITERATOR.KV-LIST-ITERATOR-CURSOR SELF))))
  (CL:WHEN (CL:EQ (%KV-LIST-ITERATOR.KV-LIST-ITERATOR-CURSOR SELF) NULL)
   (CL:RETURN-FROM NEXT? FALSE))
  (CL:SETF (%KV-LIST-ITERATOR.KEY SELF)
   (%KV-CONS.KEY (%KV-LIST-ITERATOR.KV-LIST-ITERATOR-CURSOR SELF)))
  (CL:SETF (%KV-LIST-ITERATOR.VALUE SELF)
   (%KV-CONS.VALUE (%KV-LIST-ITERATOR.KV-LIST-ITERATOR-CURSOR SELF)))
  (CL:RETURN-FROM NEXT? TRUE))

;;; (DEFMETHOD (VALUE-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD VALUE-SETTER ((SELF KV-LIST-ITERATOR) VALUE)
  (CL:SETF
   (%KV-CONS.VALUE (%KV-LIST-ITERATOR.KV-LIST-ITERATOR-CURSOR SELF)) VALUE)
  (CL:SETF (%KV-LIST-ITERATOR.VALUE SELF) VALUE)
  (CL:RETURN-FROM VALUE-SETTER VALUE))

;;; (DEFMETHOD (KEY-SETTER OBJECT) ...)

(CL:DEFMETHOD KEY-SETTER ((SELF KV-LIST-ITERATOR) KEY)
  (CL:SETF (%KV-CONS.KEY (%KV-LIST-ITERATOR.KV-LIST-ITERATOR-CURSOR SELF))
   KEY)
  (CL:SETF (%KV-LIST-ITERATOR.KEY SELF) KEY)
  (CL:RETURN-FROM KEY-SETTER KEY))

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF SEQUENCE) VALUE)
  "Return TRUE if 'value' is a member of the sequence 'self'."
  (CL:LET* ((M NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ M (%ITERATOR.VALUE ITER-000))
    (CL:WHEN (EQL? M VALUE) (CL:RETURN-FROM MEMBER? TRUE))))
  (CL:RETURN-FROM MEMBER? FALSE))

;;; (DEFUN (LIST LIST) ...)

(CL:DEFUN LIST (CL:&REST VALUES)
  "Return a list containing 'values', in order."
  (CL:LET* ((LIST (NEW-LIST)))
   (CL:LET* ((V NULL) (ITER-000 VALUES) (COLLECT-000 NULL))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ V (CL:POP ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS V NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST LIST) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST LIST) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST LIST)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS V NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:RETURN-FROM LIST LIST)))

;;; (DEFUN (SEQUENCE (SEQUENCE OF OBJECT)) ...)

(CL:DEFUN SEQUENCE (COLLECTIONTYPE CL:&REST VALUES)
  "Return a sequence containing 'values', in order."
  (CL:LET* ((SEQUENCE (CREATE-OBJECT COLLECTIONTYPE)))
   (CL:LET* ((I NULL) (ITER-000 VALUES))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ I (CL:POP ITER-000))
     (CL:COND
      ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SEQUENCE) SGT-LISTS-STELLA-LIST)
       (CL:PROGN (INSERT-LAST SEQUENCE I)))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "sequence: Don't know how to 'insert-last' into a `"
         COLLECTIONTYPE "'")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
   (CL:RETURN-FROM SEQUENCE SEQUENCE)))

;;; (DEFUN (DICTIONARY (ABSTRACT-DICTIONARY OF OBJECT OBJECT)) ...)

(CL:DEFUN DICTIONARY (COLLECTIONTYPE CL:&REST ALTERNATINGKEYSANDVALUES)
  "Return a dictionary containing 'values', in order."
  (CL:LET*
   ((DICTIONARY (CREATE-OBJECT COLLECTIONTYPE)) (KEY NULL) (VALUE NULL)
    (COPY NIL) (CURSOR NULL))
   (CL:LET*
    ((ITEM NULL) (ITER-000 ALTERNATINGKEYSANDVALUES) (COLLECT-000 NULL))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ ITEM (CL:POP ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS ITEM NIL))
       (CL:IF (CL:EQ COPY NIL) (CL:SETQ COPY COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST COPY COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ITEM NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:SETQ CURSOR COPY)
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:SETQ KEY (%%VALUE CURSOR))
    (CL:SETQ VALUE (%%VALUE (%%REST CURSOR)))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE DICTIONARY)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LISTS-STELLA-HASH-TABLE)
       (CL:PROGN (INSERT-AT DICTIONARY KEY VALUE)))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LISTS-STELLA-KEY-VALUE-LIST)
       (CL:PROGN (INSERT-AT DICTIONARY KEY VALUE)))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LISTS-STELLA-PROPERTY-LIST)
       (CL:PROGN (INSERT-AT DICTIONARY KEY VALUE)))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "dictionary: Can't create dictionaries of type `" COLLECTIONTYPE
         "'")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (CL:SETQ CURSOR (%%REST (%%REST CURSOR))))
   (CL:RETURN-FROM DICTIONARY DICTIONARY)))

;;; (DEFMETHOD (LISTIFY (LIST OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD LISTIFY ((SELF LIST))
  "Return 'self'."
  (CL:RETURN-FROM LISTIFY SELF))

;;; (DEFMETHOD (LISTIFY (LIST OF (LIKE (ANY-VALUE SELF)))) ...)

(%%DEFCONSMETHOD LISTIFY ((SELF CL:CONS))
  "Return a list of elements in 'self'."
  (CL:LET* ((SELF-000 (NEW-LIST)))
   (CL:SETF (%LIST.THE-CONS-LIST SELF-000) SELF)
   (CL:LET* ((VALUE-000 SELF-000)) (CL:RETURN-FROM LISTIFY VALUE-000))))

;;; (DEFMETHOD (LISTIFY (LIST OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD LISTIFY ((SELF KEY-VALUE-LIST))
  "Return a list of key-value pairs in 'self'."
  (CL:LET* ((RESULT (NEW-LIST)))
   (CL:LET*
    ((V NULL) (K NULL) (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST SELF))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
     (CL:SETQ K (%KV-CONS.KEY ITER-000))
     (CL:PROGN (CL:SETQ V (%KV-CONS.VALUE ITER-000))
      (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (CONS K (CONS V NIL)) NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST RESULT) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST RESULT) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST RESULT)
         COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000) (CONS (CONS K (CONS V NIL)) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:RETURN-FROM LISTIFY RESULT)))

;;; (DEFMETHOD (LISTIFY (LIST OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD LISTIFY ((SELF VECTOR))
  "Return a list of elements in 'self'."
  (CL:LET* ((RESULT (NEW-LIST)))
   (CL:LET*
    ((V NULL) (VECTOR-000 SELF) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ V
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS V NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST RESULT) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST RESULT) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST RESULT)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS V NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:RETURN-FROM LISTIFY RESULT)))

;;; (DEFMETHOD (LISTIFY (LIST OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD LISTIFY ((SELF ITERATOR))
  "Return a list of elements generated by 'self'."
  (CL:LET* ((LIST (NEW-LIST)))
   (CL:LET* ((VALUE NULL) (ITER-000 SELF))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ VALUE (%ITERATOR.VALUE ITER-000)) (PUSH LIST VALUE)))
   (CL:RETURN-FROM LISTIFY (REVERSE LIST))))

;;; (DEFUN PRINT-KEY-VALUE-LIST ...)

(CL:DEFUN PRINT-KEY-VALUE-LIST (SELF STREAM)
  (%%PRINT-STREAM STREAM "(")
  (CL:LET* ((CURSOR (%KEY-VALUE-LIST.THE-KV-LIST SELF)) (POSITION 1))
   (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
    (CL:WHEN (CL:> POSITION 5) (%%PRINT-STREAM STREAM " ...") (CL:RETURN))
    (%%PRINT-STREAM STREAM CURSOR) (CL:SETQ CURSOR (%KV-CONS.REST CURSOR))
    (CL:SETQ POSITION (CL:1+ POSITION)))
   (%%PRINT-STREAM STREAM ")"))
  :VOID)

;;; (DEFUN PRINT-CONS-LIST ...)

(CL:DEFUN PRINT-CONS-LIST (LIST STREAM)
  (CL:WHEN (CL:NOT FALSE) (%%PRINT-STREAM STREAM "|i|"))
  (CL:IF (CL:EQ LIST NIL) (%%PRINT-STREAM STREAM "()")
   (CL:LET* ((I 0) (LIMIT 9)) (CL:DECLARE (CL:TYPE CL:FIXNUM I LIMIT))
    (%%PRINT-STREAM STREAM "(") (%%PRINT-STREAM STREAM (%%VALUE LIST))
    (CL:LET* ((ITEM NULL) (ITER-000 (%%REST LIST)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:PROGN (CL:SETQ ITEM (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (%%PRINT-STREAM STREAM " ") (%%PRINT-STREAM STREAM ITEM)
      (CL:SETQ I (CL:1+ I)) (CL:WHEN (CL:> I LIMIT) (CL:RETURN))))
    (CL:IF (CL:<= I LIMIT) (%%PRINT-STREAM STREAM ")")
     (%%PRINT-STREAM STREAM " ...)"))))
  :VOID)

(CL:DEFUN HELP-STARTUP-LISTS1 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "DEFINED-LIST?"
    "(DEFUN (DEFINED-LIST? BOOLEAN) ((SELF LIST)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE unless 'self' is NULL or the 'NIL-LIST'.\")"
    (CL:FUNCTION DEFINED-LIST?) NULL)
   (DEFINE-FUNCTION-OBJECT "NULL-LIST?"
    "(DEFUN (NULL-LIST? BOOLEAN) ((SELF LIST)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE iff 'self' is NULL or the 'NIL-LIST'.\")"
    (CL:FUNCTION NULL-LIST?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF LIST)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the list 'self' has no members.\")"
    (CL:FUNCTION EMPTY?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF LIST)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the list 'self' has at least one member.\")"
    (CL:FUNCTION NON-EMPTY?) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMINATE-LIST?"
    "(DEFUN (TERMINATE-LIST? BOOLEAN) ((SELF LIST)))"
    (CL:FUNCTION TERMINATE-LIST?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF LIST) (OBJECT (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Return TRUE iff 'object' is a member of the list
'self' (uses an 'eql?' test).\" :PUBLIC? TRUE)" (CL:FUNCTION MEMBER?)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MEMB? BOOLEAN) ((SELF LIST) (OBJECT (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Return TRUE iff 'object' is a member of the cons list
'self' (uses an 'eq?' test).\" :PUBLIC? TRUE)" (CL:FUNCTION MEMB?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Return the first item in the list 'self', or NULL if empty.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FIRST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Return the second item in the list 'self', or NULL if empty.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SECOND) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Return the third item in the list 'self', or NULL if empty.\" :PUBLIC? TRUE)"
    (CL:FUNCTION THIRD) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Return the fourth item in the list 'self', or NULL if empty.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FOURTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Return the fifth item in the list 'self', or NULL if empty.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FIFTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ((SELF LIST) (POSITION INTEGER)) :DOCUMENTATION \"Return the nth item in the list 'self', or NULL if empty.\" :PUBLIC? TRUE)"
    (CL:FUNCTION NTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Return the last element of 'self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LAST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REST (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST)) :DOCUMENTATION \"Return a cons list of all but the first item in the list 'self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIRST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION FIRST-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SECOND-SETTER (LIKE (ANY-VALUE SELF))) ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION SECOND-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (THIRD-SETTER (LIKE (ANY-VALUE SELF))) ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION THIRD-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FOURTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION FOURTH-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIFTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION FIFTH-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF))) (POSITION INTEGER)) :PUBLIC? TRUE)"
    (CL:FUNCTION NTH-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF LIST)) :PUBLIC? TRUE)"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (POSITION INTEGER) ((SELF LIST) (OBJECT OBJECT) (START INTEGER)) :DOCUMENTATION \"Return the position of 'object' within the list
'self' (counting from zero); or return NULL if 'object' does not occur within 
'self' (uses an 'eql?' test).  If 'start' was supplied as non-NULL, only 
consider the sublist starting at 'start', however, the returned position 
will always be relative to the entire list.\" :PUBLIC? TRUE)"
    (CL:FUNCTION POSITION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Add 'value' to the front of the list 'self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PUSH ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Add 'value' to the front of the list 'self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION PUSH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-NEW ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Add 'value' to the front of the list 'self' unless its 
already a member.\" :PUBLIC? TRUE)" (CL:FUNCTION INSERT-NEW) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-LAST ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Insert 'value' as the last entry in the list 'self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-LAST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE (LIKE SELF)) ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Destructively remove all entries in 'self' that match 'value'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REMOVE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE-IF (LIKE SELF)) ((SELF LIST) (TEST? FUNCTION-CODE)) :DOCUMENTATION \"Destructively remove all members of the list 'self' for which
'test?' evaluates to TRUE.  'test' takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns 'self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REMOVE-IF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE-DUPLICATES (LIKE SELF)) ((SELF LIST)) :DOCUMENTATION \"Destructively remove duplicates from `self' and return the result.
Preserves the original order of the remaining members.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REMOVE-DUPLICATES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Remove and return the first element in the list 'self'.
Return NULL if the list is empty.\" :PUBLIC? TRUE)" (CL:FUNCTION POP)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REVERSE (LIKE SELF)) ((SELF LIST)) :DOCUMENTATION \"Reverse the members of 'self' (in place).\" :PUBLIC? TRUE)"
    (CL:FUNCTION REVERSE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBSTITUTE (LIKE SELF)) ((SELF LIST) (INVALUE OBJECT) (OUTVALUE OBJECT)) :DOCUMENTATION \"Destructively replace each appearance of 'outValue' by
'inValue' in the list 'self'.\")" (CL:FUNCTION SUBSTITUTE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONCATENATE LIST) ((LIST1 LIST) (LIST2 LIST) |&REST| (OTHERLISTS LIST)) :DOCUMENTATION \"Copy `list2' and all `otherLists' onto the end of `list1'.
The operation is destructive wrt `list1', but leaves all other lists intact.
The two mandatory parameters allow us to optimize the common binary case by
not relying on the somewhat less efficient variable arguments mechanism.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CONCATENATE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PREPEND (LIKE SELF)) ((SELF LIST) (LIST2 LIST)) :DOCUMENTATION \"Copy 'list2' onto the front of the list 'self'.
The operation is destructive wrt 'self', but leaves 'list2' intact.\" :PUBLIC? TRUE)"
    (CL:FUNCTION PREPEND) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY (LIST OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST)) :DOCUMENTATION \"Return a copy of the list 'self'.  The conses in the copy are
freshly allocated.\" :PUBLIC? TRUE)" (CL:FUNCTION COPY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR ((SELF LIST)) :DOCUMENTATION \"Make 'self' an empty list.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CLEAR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SORT (LIST OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST) (PREDICATE FUNCTION-CODE)) :PUBLIC? TRUE :DOCUMENTATION \"Perform a stable, destructive sort of 'self' according to
'predicate', and return the result.  If 'predicate' has a '<' semantics, the
result will be in ascending order.  If 'predicate' is NULL, a suitable
'<' predicate is chosen depending on the first element of 'self', and it 
is assumed that all elements of 'self' have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT).\")"
    (CL:FUNCTION SORT) NULL)
   (DEFINE-FUNCTION-OBJECT "MAP-NULL-TO-NIL-LIST"
    "(DEFUN (MAP-NULL-TO-NIL-LIST LIST) ((SELF LIST)) :DOCUMENTATION \"Return NIL-LIST iff 'self' is NULL or `self' otherwise.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (CHOOSE (NULL? SELF) NIL-LIST SELF)))"
    (CL:FUNCTION MAP-NULL-TO-NIL-LIST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ALLOCATE-ITERATOR (LIST-ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST)))"
    (CL:FUNCTION ALLOCATE-ITERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMINATE-LIST-ITERATOR?"
    "(DEFUN (TERMINATE-LIST-ITERATOR? BOOLEAN) ((SELF LIST-ITERATOR)))"
    (CL:FUNCTION TERMINATE-LIST-ITERATOR?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF LIST-ITERATOR)) :PUBLIC? TRUE)"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF LIST-ITERATOR)) :PUBLIC? TRUE)"
    (CL:FUNCTION EMPTY?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (VALUE-SETTER OBJECT) ((SELF LIST-ITERATOR) (VALUE (LIKE (ANY-VALUE SELF)))))"
    (CL:FUNCTION VALUE-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST)) :DOCUMENTATION \"Generate all but the last element of the list 'self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION BUT-LAST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE-DELETED-MEMBERS (LIKE SELF)) ((SELF LIST)) :PUBLIC? TRUE)"
    (CL:FUNCTION REMOVE-DELETED-MEMBERS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-OBJECT ((SELF PROPERTY-LIST)))"
    (CL:FUNCTION INITIALIZE-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "SEARCH-PLIST"
    "(DEFUN (SEARCH-PLIST OBJECT) ((PLIST CONS) (KEY OBJECT)))"
    (CL:FUNCTION SEARCH-PLIST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF PROPERTY-LIST) (KEY (LIKE (ANY-KEY SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF PROPERTY-LIST)) :PUBLIC? TRUE)"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF PROPERTY-LIST) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Insert the entry <`key', `value'> into the property list `self'.
If a previous entry existed with key `key', that entry is replaced.\" :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE-AT OBJECT) ((SELF PROPERTY-LIST) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Remove the entry that matches the key `key'.  Return the
value of the matching entry, or NULL if there is no matching entry.  Assumes that at
most one entry matches `key'.\" :PUBLIC? TRUE)" (CL:FUNCTION REMOVE-AT)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF PROPERTY-LIST)) :PUBLIC? TRUE)"
    (CL:FUNCTION EMPTY?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF PROPERTY-LIST)) :PUBLIC? TRUE)"
    (CL:FUNCTION NON-EMPTY?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY (LIKE SELF)) ((SELF PROPERTY-LIST)) :DOCUMENTATION \"Return a copy of the list `self'.  The conses in the copy are
freshly allocated.\" :PUBLIC? TRUE)" (CL:FUNCTION COPY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR ((SELF PROPERTY-LIST)) :DOCUMENTATION \"Make `self' an empty property list.\")"
    (CL:FUNCTION CLEAR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EQUIVALENT-SETS? BOOLEAN) ((SELF LIST) (OTHERLIST LIST)))"
    (CL:FUNCTION EQUIVALENT-SETS?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (INTERSECTION LIST) ((SELF LIST) (OTHERLIST LIST)))"
    (CL:FUNCTION INTERSECTION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (UNION LIST) ((SELF LIST) (OTHERLIST LIST)))"
    (CL:FUNCTION UNION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DIFFERENCE LIST) ((SELF LIST) (OTHERLIST LIST)))"
    (CL:FUNCTION DIFFERENCE) NULL))
  :VOID)

(CL:DEFUN STARTUP-LISTS ()
  (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 0)
   (CL:WHEN (CL:EQ NIL-LIST NULL) (CL:SETQ NIL-LIST (%MAKE-LIST)))
   (CL:SETF (%LIST.THE-CONS-LIST NIL-LIST) NIL))
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (CL:SETQ SGT-LISTS-STELLA-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" NULL 1))
    (CL:SETQ SGT-LISTS-STELLA-HASH-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "HASH-TABLE" NULL 1))
    (CL:SETQ SGT-LISTS-STELLA-KEY-VALUE-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-VALUE-LIST" NULL 1))
    (CL:SETQ SGT-LISTS-STELLA-PROPERTY-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTY-LIST" NULL 1))
    (CL:SETQ SYM-LISTS-STELLA-STARTUP-LISTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-LISTS" NULL 0))
    (CL:SETQ SYM-LISTS-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-LISTS1)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (SUBTRACT LIST) ((SELF LIST) (OTHERLIST LIST)))"
     (CL:FUNCTION SUBTRACT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (ALLOCATE-ITERATOR (PROPERTY-LIST-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))) ((SELF PROPERTY-LIST)))"
     (CL:FUNCTION ALLOCATE-ITERATOR) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF PROPERTY-LIST-ITERATOR)) :PUBLIC? TRUE)"
     (CL:FUNCTION NEXT?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (VALUE-SETTER (LIKE (ANY-VALUE SELF))) ((SELF PROPERTY-LIST-ITERATOR) (VALUE (LIKE (ANY-VALUE SELF)))))"
     (CL:FUNCTION VALUE-SETTER) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (KEY-SETTER (LIKE (ANY-KEY SELF))) ((SELF PROPERTY-LIST-ITERATOR) (KEY (LIKE (ANY-KEY SELF)))))"
     (CL:FUNCTION KEY-SETTER) NULL)
    (DEFINE-FUNCTION-OBJECT "KV-CONS"
     "(DEFUN (KV-CONS KV-CONS) ((KEY OBJECT) (VALUE OBJECT) (REST KV-CONS)) :DOCUMENTATION \"Create, fill-in, and return a new KV-CONS.\")"
     (CL:FUNCTION KV-CONS) NULL)
    (DEFINE-FUNCTION-OBJECT "FREE-KV-CONS"
     "(DEFUN FREE-KV-CONS ((KVCONS KV-CONS)))" (CL:FUNCTION FREE-KV-CONS)
     NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF KEY-VALUE-LIST) (KEY (LIKE (ANY-KEY SELF)))) :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LENGTH INTEGER) ((SELF KEY-VALUE-LIST)) :PUBLIC? TRUE)"
     (CL:FUNCTION LENGTH) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD INSERT-AT ((SELF KEY-VALUE-LIST) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Insert the entry <'key', 'value'> into the association
'self'. If a previous entry existed with key 'key', that entry is replaced.\")"
     (CL:FUNCTION INSERT-AT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (REMOVE-AT OBJECT) ((SELF KEY-VALUE-LIST) (KEY (LIKE (ANY-KEY SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Remove the entry that matches the key 'key'.
Return the value of the matching entry, or NULL if there is no matching entry.
Assumes that at most one entry matches 'key'.\")" (CL:FUNCTION REMOVE-AT)
     NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD INSERT-ENTRY ((SELF KEY-VALUE-LIST) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Insert an entry <'key','value'> to 'self' unless an identical
entry already exists.  This can generate duplicate entries for 'key'.\")"
     (CL:FUNCTION INSERT-ENTRY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD REMOVE-ENTRY ((SELF KEY-VALUE-LIST) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Remove the entry that matches <'key','value'>.
Assumes that more than one entry can match 'key'.\")"
     (CL:FUNCTION REMOVE-ENTRY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ((SELF KEY-VALUE-LIST)) :DOCUMENTATION \"Remove and return the first element of the kv-list 'self'.
Return NULL if the list is empty.\" :PUBLIC? TRUE)" (CL:FUNCTION POP)
     NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (REVERSE (LIKE SELF)) ((SELF KEY-VALUE-LIST)) :DOCUMENTATION \"Destructively reverse the members of the list 'self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION REVERSE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF KEY-VALUE-LIST)) :PUBLIC? TRUE)"
     (CL:FUNCTION EMPTY?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF KEY-VALUE-LIST)) :PUBLIC? TRUE)"
     (CL:FUNCTION NON-EMPTY?) NULL)
    (DEFINE-FUNCTION-OBJECT "COPY-KV-CONS-LIST"
     "(DEFUN (COPY-KV-CONS-LIST KV-CONS) ((KVCONSLIST KV-CONS)) :DOCUMENTATION \"Return a copy of the cons list 'consList'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION COPY-KV-CONS-LIST) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (COPY (LIKE SELF)) ((SELF KEY-VALUE-LIST)) :DOCUMENTATION \"Return a copy of the kv-list 'self'.  The kv-conses in
the copy are freshly allocated.\" :PUBLIC? TRUE)" (CL:FUNCTION COPY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD CLEAR ((SELF KEY-VALUE-LIST)) :DOCUMENTATION \"Make 'self' an empty dictionary.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CLEAR) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (ALLOCATE-ITERATOR (KV-LIST-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))) ((SELF KEY-VALUE-LIST)) :PUBLIC? TRUE)"
     (CL:FUNCTION ALLOCATE-ITERATOR) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF KV-LIST-ITERATOR)) :PUBLIC? TRUE)"
     (CL:FUNCTION NEXT?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (VALUE-SETTER (LIKE (ANY-VALUE SELF))) ((SELF KV-LIST-ITERATOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
     (CL:FUNCTION VALUE-SETTER) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (KEY-SETTER OBJECT) ((SELF KV-LIST-ITERATOR) (KEY OBJECT)) :PUBLIC? TRUE)"
     (CL:FUNCTION KEY-SETTER) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF SEQUENCE) (VALUE OBJECT)) :DOCUMENTATION \"Return TRUE if 'value' is a member of the sequence 'self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION MEMBER?) NULL)
    (DEFINE-FUNCTION-OBJECT "LIST"
     "(DEFUN (LIST LIST) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a list containing 'values', in order.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LIST) NULL)
    (DEFINE-FUNCTION-OBJECT "SEQUENCE"
     "(DEFUN (SEQUENCE (SEQUENCE OF OBJECT)) ((COLLECTIONTYPE TYPE) |&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a sequence containing 'values', in order.\" :PUBLIC? TRUE)"
     (CL:FUNCTION SEQUENCE) NULL)
    (DEFINE-FUNCTION-OBJECT "DICTIONARY"
     "(DEFUN (DICTIONARY (ABSTRACT-DICTIONARY OF OBJECT OBJECT)) ((COLLECTIONTYPE TYPE) |&REST| (ALTERNATINGKEYSANDVALUES OBJECT)) :DOCUMENTATION \"Return a dictionary containing 'values', in order.\" :PUBLIC? TRUE)"
     (CL:FUNCTION DICTIONARY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LISTIFY (LIST OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST)) :DOCUMENTATION \"Return 'self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LISTIFY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LISTIFY (LIST OF (LIKE (ANY-VALUE SELF)))) ((SELF CONS)) :DOCUMENTATION \"Return a list of elements in 'self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LISTIFY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LISTIFY (LIST OF (LIKE (ANY-VALUE SELF)))) ((SELF KEY-VALUE-LIST)) :DOCUMENTATION \"Return a list of key-value pairs in 'self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LISTIFY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LISTIFY (LIST OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)) :DOCUMENTATION \"Return a list of elements in 'self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LISTIFY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LISTIFY (LIST OF (LIKE (ANY-VALUE SELF)))) ((SELF ITERATOR)) :DOCUMENTATION \"Return a list of elements generated by 'self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LISTIFY) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-KEY-VALUE-LIST"
     "(DEFUN PRINT-KEY-VALUE-LIST ((SELF KEY-VALUE-LIST) (STREAM NATIVE-OUTPUT-STREAM)))"
     (CL:FUNCTION PRINT-KEY-VALUE-LIST) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-CONS-LIST"
     "(DEFUN PRINT-CONS-LIST ((LIST CONS) (STREAM NATIVE-OUTPUT-STREAM)))"
     (CL:FUNCTION PRINT-CONS-LIST) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-LISTS"
     "(DEFUN STARTUP-LISTS () :PUBLIC? TRUE)" (CL:FUNCTION STARTUP-LISTS)
     NULL)
    (CL:LET* ((FUNCTION (LOOKUP-FUNCTION SYM-LISTS-STELLA-STARTUP-LISTS)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-LISTS-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "Startup-Lists") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NIL-LIST LIST NULL :PUBLIC? TRUE)")))
  :VOID)
