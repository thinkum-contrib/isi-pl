;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996-2000              | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-MACROS-STELLA-SETQ NULL)
(CL:DEFVAR SYM-MACROS-STELLA-CONS NULL)
(CL:DEFVAR SYM-MACROS-STELLA-PUSHQ NULL)
(CL:DEFVAR SYM-MACROS-STELLA-PUSHQ-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-VRLET NULL)
(CL:DEFVAR SYM-MACROS-STELLA-VALUE NULL)
(CL:DEFVAR SYM-MACROS-STELLA-REST NULL)
(CL:DEFVAR SYM-MACROS-STELLA-POPQ NULL)
(CL:DEFVAR SYM-MACROS-STELLA-POPQ-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-SETF NULL)
(CL:DEFVAR SYM-MACROS-STELLA-PUSHF NULL)
(CL:DEFVAR SYM-MACROS-STELLA-PUSHF-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WHEN NULL)
(CL:DEFVAR SYM-MACROS-STELLA-NOT NULL)
(CL:DEFVAR SYM-MACROS-STELLA-MEMBER? NULL)
(CL:DEFVAR SYM-MACROS-STELLA-VARIABLE NULL)
(CL:DEFVAR SYM-MACROS-STELLA-PUSHQ-NEW NULL)
(CL:DEFVAR SYM-MACROS-STELLA-PUSHQ-NEW-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-UNSTRINGIFY NULL)
(CL:DEFVAR SYM-MACROS-STELLA-STRING-QUOTE NULL)
(CL:DEFVAR SYM-MACROS-STELLA-STRING-QUOTE-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-+ NULL)
(CL:DEFVAR SYM-MACROS-STELLA-++ NULL)
(CL:DEFVAR SYM-MACROS-STELLA-++-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-- NULL)
(CL:DEFVAR SYM-MACROS-STELLA--- NULL)
(CL:DEFVAR SYM-MACROS-STELLA----EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-1+ NULL)
(CL:DEFVAR SYM-MACROS-STELLA-1+-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-1- NULL)
(CL:DEFVAR SYM-MACROS-STELLA-1--EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-DEFINED? NULL)
(CL:DEFVAR SYM-MACROS-STELLA-SETQ? NULL)
(CL:DEFVAR SYM-MACROS-STELLA-SETQ?-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-NULL? NULL)
(CL:DEFVAR SYM-MACROS-STELLA-EITHER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-EITHER-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-NIL NULL)
(CL:DEFVAR SYM-MACROS-STELLA-FOREACH NULL)
(CL:DEFVAR SYM-MACROS-STELLA-COLLECT NULL)
(CL:DEFVAR SYM-MACROS-STELLA-INTO NULL)
(CL:DEFVAR SYM-MACROS-STELLA-COLLECT-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-SPECIAL NULL)
(CL:DEFVAR SYM-MACROS-STELLA-*TRANSIENTOBJECTS?* NULL)
(CL:DEFVAR SYM-MACROS-STELLA-FALSE NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WITH-PERMANENT-OBJECTS NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WITH-PERMANENT-OBJECTS-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-TRUE NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WITH-TRANSIENT-OBJECTS NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WITH-TRANSIENT-OBJECTS-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-IGNORE NULL)
(CL:DEFVAR SYM-MACROS-STELLA-IGNORE-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-CHOOSE NULL)
(CL:DEFVAR SYM-MACROS-STELLA-NULL NULL)
(CL:DEFVAR SYM-MACROS-STELLA-ONLY-IF NULL)
(CL:DEFVAR SYM-MACROS-STELLA-ONLY-IF-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-PHASE-TO-INTEGER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-PHASE-TO-INTEGER-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-IF-OUTPUT-LANGUAGE NULL)
(CL:DEFVAR SYM-MACROS-STELLA-IF-OUTPUT-LANGUAGE-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-IF-STELLA-FEATURE NULL)
(CL:DEFVAR SYM-MACROS-STELLA-IF-STELLA-FEATURE-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-*CONTEXT* NULL)
(CL:DEFVAR SYM-MACROS-STELLA-SAFETY NULL)
(CL:DEFVAR SYM-MACROS-STELLA-EQL? NULL)
(CL:DEFVAR SYM-MACROS-STELLA-BASE-MODULE NULL)
(CL:DEFVAR SYM-MACROS-STELLA-CAST NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WORLD NULL)
(CL:DEFVAR SYM-MACROS-STELLA-*MODULE* NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WITHIN-WORLD NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WITHIN-WORLD-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WITHIN-CONTEXT NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WITHIN-CONTEXT-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WITHIN-MODULE NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WITHIN-MODULE-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-IN NULL)
(CL:DEFVAR SYM-MACROS-STELLA-COERCE-&REST-TO-CONS NULL)
(CL:DEFVAR SYM-MACROS-STELLA-COERCE-&REST-TO-CONS-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-*CURRENTSYSTEMDEFINITION* NULL)
(CL:DEFVAR SYM-MACROS-STELLA-GET-SYSTEM-DEFINITION NULL)
(CL:DEFVAR SYM-MACROS-STELLA-*CURRENTSYSTEMDEFINITIONSUBDIRECTORY* NULL)
(CL:DEFVAR SYM-MACROS-STELLA-DIRECTORY NULL)
(CL:DEFVAR SYM-MACROS-STELLA-IF NULL)
(CL:DEFVAR SYM-MACROS-STELLA-PROGN NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WARN NULL)
(CL:DEFVAR SYM-MACROS-STELLA-EOL NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WITH-SYSTEM-DEFINITION NULL)
(CL:DEFVAR SYM-MACROS-STELLA-WITH-SYSTEM-DEFINITION-EXPANDER NULL)
(CL:DEFVAR KWD-MACROS-STARTUP-SYSTEM? NULL)
(CL:DEFVAR KWD-MACROS-PUBLIC? NULL)
(CL:DEFVAR KWD-MACROS-COMMON-LISP NULL)
(CL:DEFVAR SYM-MACROS-STELLA-DEFUN NULL)
(CL:DEFVAR SYM-MACROS-STELLA-MAIN NULL)
(CL:DEFVAR KWD-MACROS-CPP NULL)
(CL:DEFVAR KWD-MACROS-CPP-STANDALONE NULL)
(CL:DEFVAR KWD-MACROS-IDL NULL)
(CL:DEFVAR SYM-MACROS-STELLA-INTEGER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-RETURN NULL)
(CL:DEFVAR KWD-MACROS-JAVA NULL)
(CL:DEFVAR SYM-MACROS-STELLA-ARRAY NULL)
(CL:DEFVAR SYM-MACROS-STELLA-OF NULL)
(CL:DEFVAR SYM-MACROS-STELLA-STRING NULL)
(CL:DEFVAR SYM-MACROS-STELLA-&REST NULL)
(CL:DEFVAR SYM-MACROS-STELLA-%%ARGS NULL)
(CL:DEFVAR SYM-MACROS-STELLA-LET NULL)
(CL:DEFVAR SYM-MACROS-STELLA-VERBATIM NULL)
(CL:DEFVAR KWD-MACROS-INITIAL-CONTENTS NULL)
(CL:DEFVAR SYM-MACROS-STELLA-DEFMAIN NULL)
(CL:DEFVAR SYM-MACROS-STELLA-DEFMAIN-EXPANDER NULL)
(CL:DEFVAR SYM-MACROS-STELLA-STARTUP-MACROS NULL)
(CL:DEFVAR SYM-MACROS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* *CURRENTSYSTEMDEFINITION*
  *METHODBEINGWALKED* *CURRENT-ENVIRONMENT-FEATURES*
  *TRANSLATOROUTPUTLANGUAGE* STANDARD-ERROR EOL ONE-WRAPPER))

;;; (DEFMACRO PUSHQ ...)

(CL:DEFUN PUSHQ-EXPANDER (VARIABLE VALUE)
  "Push 'value' onto the cons list 'variable'."
  (CL:RETURN-FROM PUSHQ-EXPANDER
   (LIST* SYM-MACROS-STELLA-SETQ VARIABLE
    (CONS (LIST* SYM-MACROS-STELLA-CONS VALUE (CONS VARIABLE NIL)) NIL))))

;;; (DEFMACRO POPQ ...)

(CL:DEFUN POPQ-EXPANDER (VARIABLE)
  "Pops a value from the cons list 'variable'."
  (CL:LET* ((VALUEVAR (LOCAL-GENSYM "HEAD")))
   (CL:RETURN-FROM POPQ-EXPANDER
    (LIST* SYM-MACROS-STELLA-VRLET
     (CONS
      (CONS VALUEVAR
       (CONS (LIST* SYM-MACROS-STELLA-VALUE VARIABLE NIL) NIL))
      NIL)
     (LIST* SYM-MACROS-STELLA-SETQ VARIABLE
      (CONS (LIST* SYM-MACROS-STELLA-REST VARIABLE NIL) NIL))
     VALUEVAR NIL))))

;;; (DEFMACRO PUSHF ...)

(CL:DEFUN PUSHF-EXPANDER (PLACE VALUE)
  "Push 'value' onto the cons list 'place'."
  (CL:LET* ((PLACECOPY (COPY-CONS-TREE PLACE)))
   (CL:RETURN-FROM PUSHF-EXPANDER
    (LIST* SYM-MACROS-STELLA-SETF PLACE
     (CONS (LIST* SYM-MACROS-STELLA-CONS VALUE (CONS PLACECOPY NIL))
      NIL)))))

;;; (DEFMACRO PUSHQ-NEW ...)

(CL:DEFUN PUSHQ-NEW-EXPANDER (VARIABLE VALUE)
  "Push 'value' onto the cons list 'variable', if its
not there already."
  (CL:RETURN-FROM PUSHQ-NEW-EXPANDER
   (LIST* SYM-MACROS-STELLA-WHEN
    (LIST* SYM-MACROS-STELLA-NOT
     (LIST* SYM-MACROS-STELLA-MEMBER? SYM-MACROS-STELLA-VARIABLE
      SYM-MACROS-STELLA-VALUE NIL)
     NIL)
    (LIST* SYM-MACROS-STELLA-SETQ VARIABLE
     (CONS (LIST* SYM-MACROS-STELLA-CONS VALUE (CONS VARIABLE NIL)) NIL))
    NIL)))

;;; (DEFMACRO STRING-QUOTE ...)

(CL:DEFUN STRING-QUOTE-EXPANDER (TREE)
  "Return a parse tree that evaluates to 'tree' at
run-time.  'tree' is encoded as a string within the parse tree."
  (CL:RETURN-FROM STRING-QUOTE-EXPANDER
   (LIST* SYM-MACROS-STELLA-UNSTRINGIFY (WRAP-STRING (STRINGIFY TREE))
    NIL)))

;;; (DEFMACRO ++ ...)

(CL:DEFUN ++-EXPANDER (PLACE INCREMENT)
  "Increment the value of `place' and return the result.
`place' can be either a variable name or a slot reference.  Increment by
the optional `increment' (which can be a float) or 1 otherwise."
  (CL:LET* ((INCR (%%VALUE INCREMENT)))
   (CL:WHEN (CL:NOT (CL:OR (SYMBOL? PLACE) (CONS? PLACE)))
    (CL:IF (CL:EQ PLACE NULL)
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
        " Missing place in `++' expression" EOL ".")))
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
        " Illegal place in `++' expression: `"
        (DE-UGLIFY-PARSE-TREE PLACE) "'" EOL "."))))
    (CL:RETURN-FROM ++-EXPANDER NIL))
   (CL:WHEN (CL:EQ INCR NULL) (CL:SETQ INCR ONE-WRAPPER))
   (CL:RETURN-FROM ++-EXPANDER
    (CL:IF (SYMBOL? PLACE)
     (LIST* SYM-MACROS-STELLA-SETQ PLACE
      (CONS (LIST* SYM-MACROS-STELLA-+ PLACE (CONS INCR NIL)) NIL))
     (LIST* SYM-MACROS-STELLA-SETF PLACE
      (CONS
       (LIST* SYM-MACROS-STELLA-+ (COPY-CONS-TREE PLACE) (CONS INCR NIL))
       NIL))))))

;;; (DEFMACRO -- ...)

(CL:DEFUN ---EXPANDER (PLACE DECREMENT)
  "Decrement the value of `place' and return the result.
`place' can be either a variable name or a slot reference.  Decrement by
the optional `decrement' (which can be a float) or 1 otherwise."
  (CL:LET* ((DECR (%%VALUE DECREMENT)))
   (CL:WHEN (CL:NOT (CL:OR (SYMBOL? PLACE) (CONS? PLACE)))
    (CL:IF (CL:EQ PLACE NULL)
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
        " Missing place in `--' expression" EOL ".")))
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
        " Illegal place in `--' expression: `"
        (DE-UGLIFY-PARSE-TREE PLACE) "'" EOL "."))))
    (CL:RETURN-FROM ---EXPANDER NIL))
   (CL:WHEN (CL:EQ DECR NULL) (CL:SETQ DECR ONE-WRAPPER))
   (CL:RETURN-FROM ---EXPANDER
    (CL:IF (SYMBOL? PLACE)
     (LIST* SYM-MACROS-STELLA-SETQ PLACE
      (CONS (LIST* SYM-MACROS-STELLA-- PLACE (CONS DECR NIL)) NIL))
     (LIST* SYM-MACROS-STELLA-SETF PLACE
      (CONS
       (LIST* SYM-MACROS-STELLA-- (COPY-CONS-TREE PLACE) (CONS DECR NIL))
       NIL))))))

;;; (DEFMACRO 1+ ...)

(CL:DEFUN 1+-EXPANDER (EXPRESSION)
  "Add 1 to 'expression' and return the result."
  (CL:RETURN-FROM 1+-EXPANDER
   (LIST* SYM-MACROS-STELLA-+ EXPRESSION (CONS (WRAP-INTEGER 1) NIL))))

;;; (DEFMACRO 1- ...)

(CL:DEFUN 1--EXPANDER (EXPRESSION)
  "Subtract 1 from 'expression' and return the result."
  (CL:RETURN-FROM 1--EXPANDER
   (LIST* SYM-MACROS-STELLA-- EXPRESSION (CONS (WRAP-INTEGER 1) NIL))))

;;; (DEFMACRO SETQ? ...)

(CL:DEFUN SETQ?-EXPANDER (VARIABLE EXPRESSION)
  "Assign 'variable' the result of evaluating 'expression', 
and return TRUE if 'expression' is not NULL else return FALSE."
  (CL:RETURN-FROM SETQ?-EXPANDER
   (LIST* SYM-MACROS-STELLA-VRLET NIL
    (LIST* SYM-MACROS-STELLA-SETQ VARIABLE (CONS EXPRESSION NIL))
    (LIST* SYM-MACROS-STELLA-DEFINED? VARIABLE NIL) NIL)))

;;; (DEFMACRO EITHER ...)

(CL:DEFUN EITHER-EXPANDER (VALUE1 VALUE2)
  "If 'value1' is defined, return that, else return 'value2'."
  (CL:LET* ((LETVARIABLE (GENSYM "V")))
   (CL:RETURN-FROM EITHER-EXPANDER
    (LIST* SYM-MACROS-STELLA-VRLET
     (CONS (CONS LETVARIABLE (CONS VALUE1 NIL)) NIL)
     (LIST* SYM-MACROS-STELLA-WHEN
      (LIST* SYM-MACROS-STELLA-NULL? LETVARIABLE NIL)
      (LIST* SYM-MACROS-STELLA-SETQ LETVARIABLE (CONS VALUE2 NIL)) NIL)
     LETVARIABLE NIL))))

;;; (DEFMACRO COLLECT ...)

(CL:DEFUN COLLECT-EXPANDER (COLLECTVARIABLE BODY)
  "Use a VRLET to collect values.  Input has the form
'(collect <x> in <expression> where (<test> <x>))'."
  (CL:LET* ((COLLECTION (GENSYM "V")))
   (CL:RETURN-FROM COLLECT-EXPANDER
    (LIST* SYM-MACROS-STELLA-VRLET
     (CONS (CONS COLLECTION (CONS SYM-MACROS-STELLA-NIL NIL)) NIL)
     (LIST* SYM-MACROS-STELLA-FOREACH COLLECTVARIABLE
      (CONCATENATE BODY
       (LIST* SYM-MACROS-STELLA-COLLECT COLLECTVARIABLE
        (LIST* SYM-MACROS-STELLA-INTO COLLECTION NIL))))
     COLLECTION NIL))))

;;; (DEFMACRO WITH-PERMANENT-OBJECTS ...)

(CL:DEFUN WITH-PERMANENT-OBJECTS-EXPANDER (BODY)
  "Allocate 'permanent' (as opposed to 'transient')
objects within the scope of this declaration."
  (CL:RETURN-FROM WITH-PERMANENT-OBJECTS-EXPANDER
   (LIST* SYM-MACROS-STELLA-SPECIAL
    (CONS
     (LIST* SYM-MACROS-STELLA-*TRANSIENTOBJECTS?* SYM-MACROS-STELLA-FALSE
      NIL)
     NIL)
    (CONCATENATE BODY NIL))))

;;; (DEFMACRO WITH-TRANSIENT-OBJECTS ...)

(CL:DEFUN WITH-TRANSIENT-OBJECTS-EXPANDER (BODY)
  "Allocate 'transient' (as opposed to 'permanent')
objects within the scope of this declaration.
CAUTION: The default assumption is the allocation of permanent objects.
The scope of `with-transient-objects' should be as small as possible, and
the user has to make sure that code that wasn't explicitly written to
account for transient objects will continue to work correctly."
  (CL:RETURN-FROM WITH-TRANSIENT-OBJECTS-EXPANDER
   (LIST* SYM-MACROS-STELLA-SPECIAL
    (CONS
     (LIST* SYM-MACROS-STELLA-*TRANSIENTOBJECTS?* SYM-MACROS-STELLA-TRUE
      NIL)
     NIL)
    (CONCATENATE BODY NIL))))

;;; (DEFMACRO IGNORE ...)

(CL:DEFUN IGNORE-EXPANDER (VARIABLES)
  "Ignore unused 'variables' with NoOp 'setq' statements."
  (CL:LET* ((IGNORETREES NIL))
   (CL:LET* ((VARIABLE NULL) (ITER-000 VARIABLES) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ VARIABLE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS (LIST* SYM-MACROS-STELLA-SETQ VARIABLE (CONS VARIABLE NIL))
         NIL))
       (CL:IF (CL:EQ IGNORETREES NIL) (CL:SETQ IGNORETREES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST IGNORETREES COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (LIST* SYM-MACROS-STELLA-SETQ VARIABLE (CONS VARIABLE NIL))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:RETURN-FROM IGNORE-EXPANDER (PROGNIFY IGNORETREES))))

;;; (DEFMACRO ONLY-IF ...)

(CL:DEFUN ONLY-IF-EXPANDER (TEST EXPRESSION)
  "If 'test' is TRUE, return the result of evaluating 
'expression'."
  (CL:RETURN-FROM ONLY-IF-EXPANDER
   (LIST* SYM-MACROS-STELLA-CHOOSE TEST
    (CONS EXPRESSION (CONS SYM-MACROS-STELLA-NULL NIL)))))

;;; (DEFMACRO PHASE-TO-INTEGER ...)

(CL:DEFUN PHASE-TO-INTEGER-EXPANDER (STARTUPTIMEPHASE)
  "Expands into the integer representing 'startupTimePhase'."
  (CL:RETURN-FROM PHASE-TO-INTEGER-EXPANDER
   (WRAP-INTEGER (ENCODE-STARTUP-TIME-PHASE STARTUPTIMEPHASE))))

;;; (DEFMACRO IF-OUTPUT-LANGUAGE ...)

(CL:DEFUN IF-OUTPUT-LANGUAGE-EXPANDER (LANGUAGE THENFORM ELSEFORM)
  "Expand to 'thenForm' if the current translator output
language equals 'language'.  Otherwise, expand to 'elseForm'.  This can
be used to conditionally translate Stella code."
  (CL:IF (CL:EQ LANGUAGE *TRANSLATOROUTPUTLANGUAGE*)
   (CL:RETURN-FROM IF-OUTPUT-LANGUAGE-EXPANDER
    (CL:IF (CL:EQ THENFORM SYM-MACROS-STELLA-NULL) NULL THENFORM))
   (CL:RETURN-FROM IF-OUTPUT-LANGUAGE-EXPANDER
    (CL:IF (CL:EQ ELSEFORM SYM-MACROS-STELLA-NULL) NULL ELSEFORM))))

;;; (DEFMACRO IF-STELLA-FEATURE ...)

(CL:DEFUN IF-STELLA-FEATURE-EXPANDER (FEATURE THENFORM ELSEFORM)
  "Expand to 'thenForm' if 'feature' is a currently enabled
STELLA environment feature.  Otherwise, expand to 'elseForm'.  This can
be used to conditionally translate Stella code."
  (CL:IF (MEMBER? *CURRENT-ENVIRONMENT-FEATURES* FEATURE)
   (CL:RETURN-FROM IF-STELLA-FEATURE-EXPANDER
    (CL:IF (CL:EQ THENFORM SYM-MACROS-STELLA-NULL) NULL THENFORM))
   (CL:RETURN-FROM IF-STELLA-FEATURE-EXPANDER
    (CL:IF (CL:EQ ELSEFORM SYM-MACROS-STELLA-NULL) NULL ELSEFORM))))

;;; (DEFMACRO WITHIN-WORLD ...)

(CL:DEFUN WITHIN-WORLD-EXPANDER (WORLDFORM BODY)
  "Execute `body' within the world resulting from `worldForm'."
  (CL:RETURN-FROM WITHIN-WORLD-EXPANDER
   (LIST* SYM-MACROS-STELLA-SPECIAL
    (CONS (LIST* SYM-MACROS-STELLA-*CONTEXT* WORLDFORM NIL) NIL)
    (LIST* SYM-MACROS-STELLA-SAFETY (WRAP-INTEGER 3)
     (LIST* SYM-MACROS-STELLA-EQL?
      (LIST* SYM-MACROS-STELLA-BASE-MODULE
       (LIST* SYM-MACROS-STELLA-CAST SYM-MACROS-STELLA-*CONTEXT*
        SYM-MACROS-STELLA-WORLD NIL)
       NIL)
      SYM-MACROS-STELLA-*MODULE* NIL)
     (WRAP-STRING "within-world: The base module of world ")
     SYM-MACROS-STELLA-*CONTEXT*
     (WRAP-STRING " does not match the current module.") NIL)
    (CONCATENATE BODY NIL))))

;;; (DEFMACRO WITHIN-CONTEXT ...)

(CL:DEFUN WITHIN-CONTEXT-EXPANDER (CONTEXTFORM BODY)
  "Execute `body' within the context resulting from `contextForm'."
  (CL:RETURN-FROM WITHIN-CONTEXT-EXPANDER
   (LIST* SYM-MACROS-STELLA-SPECIAL
    (LIST* (LIST* SYM-MACROS-STELLA-*CONTEXT* CONTEXTFORM NIL)
     (LIST* SYM-MACROS-STELLA-*MODULE*
      (LIST* SYM-MACROS-STELLA-BASE-MODULE SYM-MACROS-STELLA-*CONTEXT*
       NIL)
      NIL)
     NIL)
    (CONCATENATE BODY NIL))))

;;; (DEFMACRO WITHIN-MODULE ...)

(CL:DEFUN WITHIN-MODULE-EXPANDER (MODULEFORM BODY)
  "Execute `body' within the module resulting from `moduleForm'.
`*module*' is an acceptable `moduleForm'.  It will locally rebind 
`*module*' and `*context*' and shield the outer bindings from changes."
  (CL:RETURN-FROM WITHIN-MODULE-EXPANDER
   (LIST* SYM-MACROS-STELLA-SPECIAL
    (LIST* (LIST* SYM-MACROS-STELLA-*MODULE* MODULEFORM NIL)
     (LIST* SYM-MACROS-STELLA-*CONTEXT* SYM-MACROS-STELLA-*MODULE* NIL)
     NIL)
    (CONCATENATE BODY NIL))))

;;; (DEFMACRO |COERCE-&REST-TO-CONS| ...)

(CL:DEFUN COERCE-&REST-TO-CONS-EXPANDER (RESTVARIABLE)
  "Coerce the argument list variable `restVariable' into a CONS
list containing all its elements (uses argument list iteration to do so).  If
`restVariable' already is a CONS due to argument listification, this is a no-op."
  (CL:IF (PASS-VARIABLE-ARGUMENTS-AS-LIST? *METHODBEINGWALKED*)
   (CL:RETURN-FROM COERCE-&REST-TO-CONS-EXPANDER
    (SYS-TREE (WALK-WITHOUT-TYPE-TREE RESTVARIABLE)
     (YIELD-LISTIFIED-VARIABLE-ARGUMENTS-TYPE *METHODBEINGWALKED*)))
   (CL:LET*
    ((ARGVAR (LOCAL-GENSYM "ARG")) (LISTVAR (LOCAL-GENSYM "ARGLIST")))
    (CL:RETURN-FROM COERCE-&REST-TO-CONS-EXPANDER
     (LIST* SYM-MACROS-STELLA-VRLET
      (CONS
       (CONS LISTVAR
        (CONS
         (YIELD-LISTIFIED-VARIABLE-ARGUMENTS-TYPE *METHODBEINGWALKED*)
         (CONS SYM-MACROS-STELLA-NIL NIL)))
       NIL)
      (LIST* SYM-MACROS-STELLA-FOREACH ARGVAR
       (LIST* SYM-MACROS-STELLA-IN RESTVARIABLE
        (LIST* SYM-MACROS-STELLA-COLLECT ARGVAR
         (LIST* SYM-MACROS-STELLA-INTO LISTVAR NIL))))
      LISTVAR NIL)))))

;;; (DEFMACRO WITH-SYSTEM-DEFINITION ...)

(CL:DEFUN WITH-SYSTEM-DEFINITION-EXPANDER (SYSTEMNAMEEXPRESSION BODY)
  "Set *currentSystemDefinition* to the system definition named 'system'.
Set *currentSystemDefinitionSubdirectory* to match. Execute 'body' within
that scope."
  (CL:RETURN-FROM WITH-SYSTEM-DEFINITION-EXPANDER
   (LIST* SYM-MACROS-STELLA-SPECIAL
    (LIST*
     (LIST* SYM-MACROS-STELLA-*CURRENTSYSTEMDEFINITION*
      (LIST* SYM-MACROS-STELLA-GET-SYSTEM-DEFINITION SYSTEMNAMEEXPRESSION
       NIL)
      NIL)
     (LIST* SYM-MACROS-STELLA-*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
      (LIST* SYM-MACROS-STELLA-ONLY-IF
       (LIST* SYM-MACROS-STELLA-DEFINED?
        SYM-MACROS-STELLA-*CURRENTSYSTEMDEFINITION* NIL)
       (LIST* SYM-MACROS-STELLA-DIRECTORY
        SYM-MACROS-STELLA-*CURRENTSYSTEMDEFINITION* NIL)
       NIL)
      NIL)
     NIL)
    (LIST* SYM-MACROS-STELLA-IF
     (LIST* SYM-MACROS-STELLA-DEFINED?
      SYM-MACROS-STELLA-*CURRENTSYSTEMDEFINITION* NIL)
     (CONS SYM-MACROS-STELLA-PROGN (CONCATENATE BODY NIL))
     (LIST* SYM-MACROS-STELLA-WARN
      (WRAP-STRING "Can't find a system named ") SYSTEMNAMEEXPRESSION
      (CONS SYM-MACROS-STELLA-EOL NIL))
     NIL)
    NIL)))

;;; (DEFMACRO DEFMAIN ...)

(CL:DEFUN DEFMAIN-EXPANDER (VARLIST BODY)
  "Defines a function called MAIN which will have the appropriate
signature for the target translation language.  The signature will be:
  C++:   public static int main (int v1, char** v2) {<body>}
  Java:  public static void main (String [] v1) {<body>}
  Lisp:  (defun main (&rest args) <body>)
The argument `varList' must have two symbols, which will be the names for the
INTEGER argument count and an array of STRINGs with the argument values.  It
can also be empty to indicate that no command line arguments will be handled.
The startup function for the containing system will automatically be called
before `body' is executed unless the option :STARTUP-SYSTEM? was supplied as
FALSE.  There can only be one DEFMAIN per module."
  (CL:LET*
   ((PROCESSCMDLINEARGS? (CL:NOT (CL:EQ VARLIST NIL)))
    (V1NAME (%%VALUE VARLIST)) (V2NAME (%%VALUE (%%REST VARLIST)))
    (BODYWITHHEADER (CONS NULL BODY)))
   (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
    (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000)
     (EXTRACT-OPTIONS BODYWITHHEADER NULL))
    (CL:LET*
     ((OPTIONS SELF-000)
      (STARTUPFUNCTIONCALL
       (CL:IF
        (CL:AND (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
         (CL:NOT
          (CL:EQ (LOOKUP OPTIONS KWD-MACROS-STARTUP-SYSTEM?)
           SYM-MACROS-STELLA-FALSE)))
        (CONS
         (CONS (SYSTEM-STARTUP-FUNCTION-SYMBOL *CURRENTSYSTEMDEFINITION*)
          NIL)
         NIL)
        NIL)))
     (REMOVE-AT OPTIONS KWD-MACROS-STARTUP-SYSTEM?)
     (REMOVE-AT OPTIONS KWD-MACROS-PUBLIC?)
     (CL:SETQ BODY
      (CONCATENATE (%PROPERTY-LIST.THE-PLIST OPTIONS)
       (%%REST BODYWITHHEADER)))
     (CL:COND
      ((CL:NOT PROCESSCMDLINEARGS?)
       (CL:COND
        ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-MACROS-COMMON-LISP)
         (CL:RETURN-FROM DEFMAIN-EXPANDER
          (LIST* SYM-MACROS-STELLA-DEFUN SYM-MACROS-STELLA-MAIN NIL
           KWD-MACROS-PUBLIC? SYM-MACROS-STELLA-TRUE
           (CONCATENATE STARTUPFUNCTIONCALL (CONCATENATE BODY NIL)))))
        ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-MACROS-CPP)
          (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-MACROS-CPP-STANDALONE)
          (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-MACROS-IDL))
         (CL:RETURN-FROM DEFMAIN-EXPANDER
          (LIST* SYM-MACROS-STELLA-DEFUN
           (LIST* SYM-MACROS-STELLA-MAIN SYM-MACROS-STELLA-INTEGER NIL)
           NIL KWD-MACROS-PUBLIC? SYM-MACROS-STELLA-TRUE
           (CONCATENATE STARTUPFUNCTIONCALL
            (CONCATENATE BODY
             (CONS (LIST* SYM-MACROS-STELLA-RETURN (WRAP-INTEGER 1) NIL)
              NIL))))))
        ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-MACROS-JAVA)
         (CL:RETURN-FROM DEFMAIN-EXPANDER
          (LIST* SYM-MACROS-STELLA-DEFUN SYM-MACROS-STELLA-MAIN
           (CONS
            (CONS (LOCAL-GENSYM "ARGV")
             (CONS
              (LIST* SYM-MACROS-STELLA-ARRAY NIL SYM-MACROS-STELLA-OF
               SYM-MACROS-STELLA-STRING NIL)
              NIL))
            NIL)
           KWD-MACROS-PUBLIC? SYM-MACROS-STELLA-TRUE
           (CONCATENATE STARTUPFUNCTIONCALL (CONCATENATE BODY NIL)))))
        (CL:T)))
      (CL:T
       (CL:COND
        ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-MACROS-COMMON-LISP)
         (CL:RETURN-FROM DEFMAIN-EXPANDER
          (LIST* SYM-MACROS-STELLA-DEFUN SYM-MACROS-STELLA-MAIN
           (LIST* SYM-MACROS-STELLA-&REST
            (LIST* SYM-MACROS-STELLA-%%ARGS SYM-MACROS-STELLA-STRING NIL)
            NIL)
           KWD-MACROS-PUBLIC? SYM-MACROS-STELLA-TRUE
           (LIST* SYM-MACROS-STELLA-LET
            (LIST*
             (CONS V1NAME
              (LIST* SYM-MACROS-STELLA-INTEGER
               (LIST* SYM-MACROS-STELLA-VERBATIM KWD-MACROS-COMMON-LISP
                (LIST* (INTERN-COMMON-LISP-SYMBOL "LENGTH")
                 SYM-MACROS-STELLA-%%ARGS NIL)
                NIL)
               NIL))
             (CONS V2NAME
              (LIST*
               (LIST* SYM-MACROS-STELLA-ARRAY NIL SYM-MACROS-STELLA-OF
                SYM-MACROS-STELLA-STRING NIL)
               (LIST* SYM-MACROS-STELLA-VERBATIM KWD-MACROS-COMMON-LISP
                (LIST* (INTERN-COMMON-LISP-SYMBOL "MAKE-ARRAY")
                 (LIST* (INTERN-COMMON-LISP-SYMBOL "LENGTH")
                  SYM-MACROS-STELLA-%%ARGS NIL)
                 KWD-MACROS-INITIAL-CONTENTS SYM-MACROS-STELLA-%%ARGS NIL)
                NIL)
               NIL))
             NIL)
            (CONCATENATE STARTUPFUNCTIONCALL (CONCATENATE BODY NIL)))
           NIL)))
        ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-MACROS-JAVA)
         (CL:RETURN-FROM DEFMAIN-EXPANDER
          (LIST* SYM-MACROS-STELLA-DEFUN SYM-MACROS-STELLA-MAIN
           (CONS
            (CONS V2NAME
             (CONS
              (LIST* SYM-MACROS-STELLA-ARRAY NIL SYM-MACROS-STELLA-OF
               SYM-MACROS-STELLA-STRING NIL)
              NIL))
            NIL)
           KWD-MACROS-PUBLIC? SYM-MACROS-STELLA-TRUE
           (LIST* SYM-MACROS-STELLA-LET
            (CONS
             (CONS V1NAME
              (LIST* SYM-MACROS-STELLA-INTEGER
               (LIST* SYM-MACROS-STELLA-VERBATIM KWD-MACROS-JAVA
                (WRAP-STRING
                 (CONCATENATE
                  (%STRING-WRAPPER.WRAPPER-VALUE
                   (JAVA-TRANSLATE-NAME V2NAME))
                  ".length"))
                NIL)
               NIL))
             NIL)
            (CONCATENATE STARTUPFUNCTIONCALL (CONCATENATE BODY NIL)))
           NIL)))
        ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-MACROS-CPP)
          (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-MACROS-CPP-STANDALONE)
          (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-MACROS-IDL))
         (CL:RETURN-FROM DEFMAIN-EXPANDER
          (LIST* SYM-MACROS-STELLA-DEFUN
           (LIST* SYM-MACROS-STELLA-MAIN SYM-MACROS-STELLA-INTEGER NIL)
           (LIST* (CONS V1NAME (CONS SYM-MACROS-STELLA-INTEGER NIL))
            (CONS V2NAME
             (CONS
              (LIST* SYM-MACROS-STELLA-ARRAY NIL SYM-MACROS-STELLA-OF
               SYM-MACROS-STELLA-STRING NIL)
              NIL))
            NIL)
           KWD-MACROS-PUBLIC? SYM-MACROS-STELLA-TRUE
           (CONCATENATE STARTUPFUNCTIONCALL
            (CONCATENATE BODY
             (CONS (LIST* SYM-MACROS-STELLA-RETURN (WRAP-INTEGER 1) NIL)
              NIL))))))
        (CL:T))))
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
        " `defmain' is not supported for `" *TRANSLATOROUTPUTLANGUAGE* "'"
        EOL ".")))
     (CL:RETURN-FROM DEFMAIN-EXPANDER NULL)))))

(CL:DEFUN HELP-STARTUP-MACROS1 ()
  (CL:PROGN
   (CL:SETQ SYM-MACROS-STELLA-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-PUSHQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUSHQ" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-PUSHQ-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUSHQ-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-VRLET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VRLET" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-REST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REST" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-POPQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POPQ" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-POPQ-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POPQ-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-SETF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETF" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-PUSHF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUSHF" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-PUSHF-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUSHF-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WHEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-MEMBER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER?" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-PUSHQ-NEW
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUSHQ-NEW" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-PUSHQ-NEW-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUSHQ-NEW-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-UNSTRINGIFY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNSTRINGIFY" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-STRING-QUOTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-QUOTE" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-STRING-QUOTE-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-QUOTE-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-+
    (INTERN-RIGID-SYMBOL-WRT-MODULE "+" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-++
    (INTERN-RIGID-SYMBOL-WRT-MODULE "++" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-++-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "++-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA--
    (INTERN-RIGID-SYMBOL-WRT-MODULE "-" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA---
    (INTERN-RIGID-SYMBOL-WRT-MODULE "--" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA----EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "---EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-1+
    (INTERN-RIGID-SYMBOL-WRT-MODULE "1+" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-1+-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "1+-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-1-
    (INTERN-RIGID-SYMBOL-WRT-MODULE "1-" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-1--EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "1--EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-DEFINED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-SETQ?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ?" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-SETQ?-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ?-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-NULL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL?" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-EITHER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EITHER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-EITHER-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EITHER-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-NIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NIL" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-FOREACH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FOREACH" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-COLLECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-INTO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTO" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-COLLECT-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-SPECIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIAL" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-*TRANSIENTOBJECTS?*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*TRANSIENTOBJECTS?*" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WITH-PERMANENT-OBJECTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITH-PERMANENT-OBJECTS" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WITH-PERMANENT-OBJECTS-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITH-PERMANENT-OBJECTS-EXPANDER" NULL
     0))
   (CL:SETQ SYM-MACROS-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WITH-TRANSIENT-OBJECTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITH-TRANSIENT-OBJECTS" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WITH-TRANSIENT-OBJECTS-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITH-TRANSIENT-OBJECTS-EXPANDER" NULL
     0))
   (CL:SETQ SYM-MACROS-STELLA-IGNORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IGNORE" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-IGNORE-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IGNORE-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-CHOOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHOOSE" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-ONLY-IF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ONLY-IF" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-ONLY-IF-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ONLY-IF-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-PHASE-TO-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PHASE-TO-INTEGER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-PHASE-TO-INTEGER-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PHASE-TO-INTEGER-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-IF-OUTPUT-LANGUAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF-OUTPUT-LANGUAGE" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-IF-OUTPUT-LANGUAGE-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF-OUTPUT-LANGUAGE-EXPANDER" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-MACROS2 ()
  (CL:PROGN
   (CL:SETQ SYM-MACROS-STELLA-IF-STELLA-FEATURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF-STELLA-FEATURE" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-IF-STELLA-FEATURE-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF-STELLA-FEATURE-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-*CONTEXT*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*CONTEXT*" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-SAFETY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAFETY" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-EQL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQL?" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-BASE-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BASE-MODULE" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-CAST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CAST" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WORLD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-*MODULE*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*MODULE*" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WITHIN-WORLD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITHIN-WORLD" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WITHIN-WORLD-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITHIN-WORLD-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WITHIN-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITHIN-CONTEXT" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WITHIN-CONTEXT-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITHIN-CONTEXT-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WITHIN-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITHIN-MODULE" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WITHIN-MODULE-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITHIN-MODULE-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-IN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-COERCE-&REST-TO-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COERCE-&REST-TO-CONS" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-COERCE-&REST-TO-CONS-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COERCE-&REST-TO-CONS-EXPANDER" NULL
     0))
   (CL:SETQ SYM-MACROS-STELLA-*CURRENTSYSTEMDEFINITION*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*CURRENTSYSTEMDEFINITION*" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-GET-SYSTEM-DEFINITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-SYSTEM-DEFINITION" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTORY" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-IF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-PROGN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROGN" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WARN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-EOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EOL" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WITH-SYSTEM-DEFINITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITH-SYSTEM-DEFINITION" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-WITH-SYSTEM-DEFINITION-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITH-SYSTEM-DEFINITION-EXPANDER" NULL
     0))
   (CL:SETQ KWD-MACROS-STARTUP-SYSTEM?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-SYSTEM?" NULL 2))
   (CL:SETQ KWD-MACROS-PUBLIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC?" NULL 2))
   (CL:SETQ KWD-MACROS-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-MACROS-STELLA-DEFUN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFUN" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-MAIN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAIN" NULL 0))
   (CL:SETQ KWD-MACROS-CPP (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
   (CL:SETQ KWD-MACROS-CPP-STANDALONE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-STANDALONE" NULL 2))
   (CL:SETQ KWD-MACROS-IDL (INTERN-RIGID-SYMBOL-WRT-MODULE "IDL" NULL 2))
   (CL:SETQ SYM-MACROS-STELLA-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-RETURN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN" NULL 0))
   (CL:SETQ KWD-MACROS-JAVA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA" NULL 2))
   (CL:SETQ SYM-MACROS-STELLA-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARRAY" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OF" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-&REST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "&REST" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-%%ARGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "%%ARGS" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-LET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LET" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-VERBATIM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBATIM" NULL 0))
   (CL:SETQ KWD-MACROS-INITIAL-CONTENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIAL-CONTENTS" NULL 2))
   (CL:SETQ SYM-MACROS-STELLA-DEFMAIN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMAIN" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-DEFMAIN-EXPANDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMAIN-EXPANDER" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-STARTUP-MACROS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-MACROS" NULL 0))
   (CL:SETQ SYM-MACROS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN STARTUP-MACROS ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-MACROS1)
    (HELP-STARTUP-MACROS2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "PUSHQ-EXPANDER"
     "(DEFUN (PUSHQ-EXPANDER OBJECT) ((VARIABLE SYMBOL) (VALUE OBJECT)) :DOCUMENTATION \"Push 'value' onto the cons list 'variable'.\")"
     (CL:FUNCTION PUSHQ-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "POPQ-EXPANDER"
     "(DEFUN (POPQ-EXPANDER OBJECT) ((VARIABLE SYMBOL)) :DOCUMENTATION \"Pops a value from the cons list 'variable'.\")"
     (CL:FUNCTION POPQ-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "PUSHF-EXPANDER"
     "(DEFUN (PUSHF-EXPANDER OBJECT) ((PLACE CONS) (VALUE OBJECT)) :DOCUMENTATION \"Push 'value' onto the cons list 'place'.\")"
     (CL:FUNCTION PUSHF-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "PUSHQ-NEW-EXPANDER"
     "(DEFUN (PUSHQ-NEW-EXPANDER OBJECT) ((VARIABLE SYMBOL) (VALUE OBJECT)) :DOCUMENTATION \"Push 'value' onto the cons list 'variable', if its
not there already.\")" (CL:FUNCTION PUSHQ-NEW-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "STRING-QUOTE-EXPANDER"
     "(DEFUN (STRING-QUOTE-EXPANDER OBJECT) ((TREE OBJECT)) :DOCUMENTATION \"Return a parse tree that evaluates to 'tree' at
run-time.  'tree' is encoded as a string within the parse tree.\")"
     (CL:FUNCTION STRING-QUOTE-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "++-EXPANDER"
     "(DEFUN (++-EXPANDER OBJECT) ((PLACE OBJECT) |&BODY| (INCREMENT CONS)) :DOCUMENTATION \"Increment the value of `place' and return the result.
`place' can be either a variable name or a slot reference.  Increment by
the optional `increment' (which can be a float) or 1 otherwise.\")"
     (CL:FUNCTION ++-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "---EXPANDER"
     "(DEFUN (---EXPANDER OBJECT) ((PLACE OBJECT) |&BODY| (DECREMENT CONS)) :DOCUMENTATION \"Decrement the value of `place' and return the result.
`place' can be either a variable name or a slot reference.  Decrement by
the optional `decrement' (which can be a float) or 1 otherwise.\")"
     (CL:FUNCTION ---EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "1+-EXPANDER"
     "(DEFUN (1+-EXPANDER OBJECT) ((EXPRESSION OBJECT)) :DOCUMENTATION \"Add 1 to 'expression' and return the result.\")"
     (CL:FUNCTION 1+-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "1--EXPANDER"
     "(DEFUN (1--EXPANDER OBJECT) ((EXPRESSION OBJECT)) :DOCUMENTATION \"Subtract 1 from 'expression' and return the result.\")"
     (CL:FUNCTION 1--EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "SETQ?-EXPANDER"
     "(DEFUN (SETQ?-EXPANDER OBJECT) ((VARIABLE SYMBOL) (EXPRESSION CONS)) :DOCUMENTATION \"Assign 'variable' the result of evaluating 'expression', 
and return TRUE if 'expression' is not NULL else return FALSE.\")"
     (CL:FUNCTION SETQ?-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "EITHER-EXPANDER"
     "(DEFUN (EITHER-EXPANDER OBJECT) ((VALUE1 OBJECT) (VALUE2 OBJECT)) :DOCUMENTATION \"If 'value1' is defined, return that, else return 'value2'.\")"
     (CL:FUNCTION EITHER-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-EXPANDER"
     "(DEFUN (COLLECT-EXPANDER OBJECT) ((COLLECTVARIABLE SYMBOL) |&BODY| (BODY CONS)) :DOCUMENTATION \"Use a VRLET to collect values.  Input has the form
'(collect <x> in <expression> where (<test> <x>))'.\")"
     (CL:FUNCTION COLLECT-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "WITH-PERMANENT-OBJECTS-EXPANDER"
     "(DEFUN (WITH-PERMANENT-OBJECTS-EXPANDER OBJECT) (|&BODY| (BODY CONS)) :DOCUMENTATION \"Allocate 'permanent' (as opposed to 'transient')
objects within the scope of this declaration.\" :PUBLIC? TRUE)"
     (CL:FUNCTION WITH-PERMANENT-OBJECTS-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "WITH-TRANSIENT-OBJECTS-EXPANDER"
     "(DEFUN (WITH-TRANSIENT-OBJECTS-EXPANDER OBJECT) (|&BODY| (BODY CONS)) :DOCUMENTATION \"Allocate 'transient' (as opposed to 'permanent')
objects within the scope of this declaration.
CAUTION: The default assumption is the allocation of permanent objects.
The scope of `with-transient-objects' should be as small as possible, and
the user has to make sure that code that wasn't explicitly written to
account for transient objects will continue to work correctly.\" :PUBLIC? TRUE)"
     (CL:FUNCTION WITH-TRANSIENT-OBJECTS-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "IGNORE-EXPANDER"
     "(DEFUN (IGNORE-EXPANDER OBJECT) (|&BODY| (VARIABLES CONS)) :DOCUMENTATION \"Ignore unused 'variables' with NoOp 'setq' statements.\")"
     (CL:FUNCTION IGNORE-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "ONLY-IF-EXPANDER"
     "(DEFUN (ONLY-IF-EXPANDER OBJECT) ((TEST OBJECT) (EXPRESSION OBJECT)) :DOCUMENTATION \"If 'test' is TRUE, return the result of evaluating 
'expression'.\")" (CL:FUNCTION ONLY-IF-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "PHASE-TO-INTEGER-EXPANDER"
     "(DEFUN (PHASE-TO-INTEGER-EXPANDER OBJECT) ((STARTUPTIMEPHASE KEYWORD)) :DOCUMENTATION \"Expands into the integer representing 'startupTimePhase'.\")"
     (CL:FUNCTION PHASE-TO-INTEGER-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "IF-OUTPUT-LANGUAGE-EXPANDER"
     "(DEFUN (IF-OUTPUT-LANGUAGE-EXPANDER OBJECT) ((LANGUAGE KEYWORD) (THENFORM OBJECT) (ELSEFORM OBJECT)) :DOCUMENTATION \"Expand to 'thenForm' if the current translator output
language equals 'language'.  Otherwise, expand to 'elseForm'.  This can
be used to conditionally translate Stella code.\")"
     (CL:FUNCTION IF-OUTPUT-LANGUAGE-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "IF-STELLA-FEATURE-EXPANDER"
     "(DEFUN (IF-STELLA-FEATURE-EXPANDER OBJECT) ((FEATURE KEYWORD) (THENFORM OBJECT) (ELSEFORM OBJECT)) :DOCUMENTATION \"Expand to 'thenForm' if 'feature' is a currently enabled
STELLA environment feature.  Otherwise, expand to 'elseForm'.  This can
be used to conditionally translate Stella code.\")"
     (CL:FUNCTION IF-STELLA-FEATURE-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "WITHIN-WORLD-EXPANDER"
     "(DEFUN (WITHIN-WORLD-EXPANDER OBJECT) ((WORLDFORM OBJECT) |&BODY| (BODY CONS)) :DOCUMENTATION \"Execute `body' within the world resulting from `worldForm'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION WITHIN-WORLD-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "WITHIN-CONTEXT-EXPANDER"
     "(DEFUN (WITHIN-CONTEXT-EXPANDER OBJECT) ((CONTEXTFORM OBJECT) |&BODY| (BODY CONS)) :DOCUMENTATION \"Execute `body' within the context resulting from `contextForm'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION WITHIN-CONTEXT-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "WITHIN-MODULE-EXPANDER"
     "(DEFUN (WITHIN-MODULE-EXPANDER OBJECT) ((MODULEFORM OBJECT) |&BODY| (BODY CONS)) :DOCUMENTATION \"Execute `body' within the module resulting from `moduleForm'.
`*module*' is an acceptable `moduleForm'.  It will locally rebind 
`*module*' and `*context*' and shield the outer bindings from changes.\" :PUBLIC? TRUE)"
     (CL:FUNCTION WITHIN-MODULE-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT " |COERCE-&REST-TO-CONS-EXPANDER|"
     "(DEFUN (|COERCE-&REST-TO-CONS-EXPANDER| OBJECT) ((RESTVARIABLE SYMBOL)) :DOCUMENTATION \"Coerce the argument list variable `restVariable' into a CONS
list containing all its elements (uses argument list iteration to do so).  If
`restVariable' already is a CONS due to argument listification, this is a no-op.\" :PUBLIC? TRUE)"
     (CL:FUNCTION COERCE-&REST-TO-CONS-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "WITH-SYSTEM-DEFINITION-EXPANDER"
     "(DEFUN (WITH-SYSTEM-DEFINITION-EXPANDER OBJECT) ((SYSTEMNAMEEXPRESSION OBJECT) |&BODY| (BODY CONS)) :DOCUMENTATION \"Set *currentSystemDefinition* to the system definition named 'system'.
Set *currentSystemDefinitionSubdirectory* to match. Execute 'body' within
that scope.\" :PUBLIC? TRUE)"
     (CL:FUNCTION WITH-SYSTEM-DEFINITION-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFMAIN-EXPANDER"
     "(DEFUN (DEFMAIN-EXPANDER OBJECT) ((VARLIST CONS) |&BODY| (BODY CONS)) :PUBLIC? TRUE :DOCUMENTATION \"Defines a function called MAIN which will have the appropriate
signature for the target translation language.  The signature will be:
  C++:   public static int main (int v1, char** v2) {<body>}
  Java:  public static void main (String [] v1) {<body>}
  Lisp:  (defun main (&rest args) <body>)
The argument `varList' must have two symbols, which will be the names for the
INTEGER argument count and an array of STRINGs with the argument values.  It
can also be empty to indicate that no command line arguments will be handled.
The startup function for the containing system will automatically be called
before `body' is executed unless the option :STARTUP-SYSTEM? was supplied as
FALSE.  There can only be one DEFMAIN per module.\")"
     (CL:FUNCTION DEFMAIN-EXPANDER) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-MACROS"
     "(DEFUN STARTUP-MACROS () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-MACROS) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-MACROS-STELLA-STARTUP-MACROS)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-MACROS-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "Startup-Macros") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (STORE-MACRO SYM-MACROS-STELLA-PUSHQ SYM-MACROS-STELLA-PUSHQ-EXPANDER
     (CL:FUNCTION PUSHQ-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-POPQ SYM-MACROS-STELLA-POPQ-EXPANDER
     (CL:FUNCTION POPQ-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-PUSHF SYM-MACROS-STELLA-PUSHF-EXPANDER
     (CL:FUNCTION PUSHF-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-PUSHQ-NEW
     SYM-MACROS-STELLA-PUSHQ-NEW-EXPANDER
     (CL:FUNCTION PUSHQ-NEW-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-STRING-QUOTE
     SYM-MACROS-STELLA-STRING-QUOTE-EXPANDER
     (CL:FUNCTION STRING-QUOTE-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-++ SYM-MACROS-STELLA-++-EXPANDER
     (CL:FUNCTION ++-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA--- SYM-MACROS-STELLA----EXPANDER
     (CL:FUNCTION ---EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-1+ SYM-MACROS-STELLA-1+-EXPANDER
     (CL:FUNCTION 1+-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-1- SYM-MACROS-STELLA-1--EXPANDER
     (CL:FUNCTION 1--EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-SETQ? SYM-MACROS-STELLA-SETQ?-EXPANDER
     (CL:FUNCTION SETQ?-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-EITHER
     SYM-MACROS-STELLA-EITHER-EXPANDER (CL:FUNCTION EITHER-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-COLLECT
     SYM-MACROS-STELLA-COLLECT-EXPANDER (CL:FUNCTION COLLECT-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-WITH-PERMANENT-OBJECTS
     SYM-MACROS-STELLA-WITH-PERMANENT-OBJECTS-EXPANDER
     (CL:FUNCTION WITH-PERMANENT-OBJECTS-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-WITH-TRANSIENT-OBJECTS
     SYM-MACROS-STELLA-WITH-TRANSIENT-OBJECTS-EXPANDER
     (CL:FUNCTION WITH-TRANSIENT-OBJECTS-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-IGNORE
     SYM-MACROS-STELLA-IGNORE-EXPANDER (CL:FUNCTION IGNORE-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-ONLY-IF
     SYM-MACROS-STELLA-ONLY-IF-EXPANDER (CL:FUNCTION ONLY-IF-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-PHASE-TO-INTEGER
     SYM-MACROS-STELLA-PHASE-TO-INTEGER-EXPANDER
     (CL:FUNCTION PHASE-TO-INTEGER-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-IF-OUTPUT-LANGUAGE
     SYM-MACROS-STELLA-IF-OUTPUT-LANGUAGE-EXPANDER
     (CL:FUNCTION IF-OUTPUT-LANGUAGE-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-IF-STELLA-FEATURE
     SYM-MACROS-STELLA-IF-STELLA-FEATURE-EXPANDER
     (CL:FUNCTION IF-STELLA-FEATURE-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-WITHIN-WORLD
     SYM-MACROS-STELLA-WITHIN-WORLD-EXPANDER
     (CL:FUNCTION WITHIN-WORLD-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-WITHIN-CONTEXT
     SYM-MACROS-STELLA-WITHIN-CONTEXT-EXPANDER
     (CL:FUNCTION WITHIN-CONTEXT-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-WITHIN-MODULE
     SYM-MACROS-STELLA-WITHIN-MODULE-EXPANDER
     (CL:FUNCTION WITHIN-MODULE-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-COERCE-&REST-TO-CONS
     SYM-MACROS-STELLA-COERCE-&REST-TO-CONS-EXPANDER
     (CL:FUNCTION COERCE-&REST-TO-CONS-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-WITH-SYSTEM-DEFINITION
     SYM-MACROS-STELLA-WITH-SYSTEM-DEFINITION-EXPANDER
     (CL:FUNCTION WITH-SYSTEM-DEFINITION-EXPANDER))
    (STORE-MACRO SYM-MACROS-STELLA-DEFMAIN
     SYM-MACROS-STELLA-DEFMAIN-EXPANDER (CL:FUNCTION DEFMAIN-EXPANDER))))
  :VOID)
