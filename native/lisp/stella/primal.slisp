;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996-2000              | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-PRIMAL-PUBLIC? NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-FLOOR NULL)
(CL:DEFVAR KWD-PRIMAL-CPP NULL)
(CL:DEFVAR KWD-PRIMAL-FUNCTION NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-RANDOM NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-SQRT NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-COS NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-SIN NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-TAN NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-LOG NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-MIN NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-MAX NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-STARTUP-PRIMAL NULL)
(CL:DEFVAR SYM-PRIMAL-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM (CL:SPECIAL *STELLA-MODULE* *MODULE*))

;;; (DEFCONSTANT TRUE ...)

(CL:DEFVAR TRUE CL:T)

;;; (DEFCONSTANT FALSE ...)

(CL:DEFVAR FALSE CL:NIL)

;;; (DEFCONSTANT PI ...)

(CL:PROGN (CL:DEFVAR PI (cl:float CL:PI 0.0d0)) (CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT PI)))

;;; (DEFCONSTANT NULL-INTEGER ...)

(CL:PROGN (CL:DEFVAR NULL-INTEGER CL:MOST-NEGATIVE-FIXNUM) (CL:DECLAIM (CL:TYPE CL:FIXNUM NULL-INTEGER)))

;;; (DEFCONSTANT NULL-SHORT-INTEGER ...)

(CL:PROGN (CL:DEFVAR NULL-SHORT-INTEGER CL:MOST-NEGATIVE-FIXNUM) (CL:DECLAIM (CL:TYPE CL:FIXNUM NULL-SHORT-INTEGER)))

;;; (DEFCONSTANT NULL-LONG-INTEGER ...)

(CL:DEFVAR NULL-LONG-INTEGER CL:MOST-NEGATIVE-FIXNUM)

;;; (DEFCONSTANT NULL-UNSIGNED-SHORT-INTEGER ...)

(CL:DEFVAR NULL-UNSIGNED-SHORT-INTEGER CL:MOST-NEGATIVE-FIXNUM)

;;; (DEFCONSTANT NULL-UNSIGNED-LONG-INTEGER ...)

(CL:DEFVAR NULL-UNSIGNED-LONG-INTEGER CL:MOST-NEGATIVE-FIXNUM)

;;; (DEFCONSTANT NULL-FLOAT ...)

(CL:PROGN (CL:DEFVAR NULL-FLOAT CL:MOST-NEGATIVE-DOUBLE-FLOAT) (CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT NULL-FLOAT)))

;;; (DEFCONSTANT NULL-SINGLE-FLOAT ...)

(CL:DEFVAR NULL-SINGLE-FLOAT CL:MOST-NEGATIVE-SINGLE-FLOAT)

;;; (DEFCONSTANT NULL-DOUBLE-FLOAT ...)

(CL:DEFVAR NULL-DOUBLE-FLOAT CL:MOST-NEGATIVE-DOUBLE-FLOAT)

;;; (DEFCONSTANT NULL-CHARACTER ...)

(CL:DEFVAR NULL-CHARACTER (CL:CODE-CHAR 0))

;;; (DEFCONSTANT NULL-BYTE ...)

(CL:DEFVAR NULL-BYTE 255)

;;; (DEFCONSTANT NULL-OCTET ...)

(CL:DEFVAR NULL-OCTET 255)

;;; (DEFUN (ZERO? BOOLEAN) ...)

(CL:DEFUN ZERO? (X)
  "Return true if `x' is 0."
  (CL:DECLARE (CL:TYPE CL:FIXNUM X))
  (CL:RETURN-FROM ZERO? (CL:= X 0)))

;;; (DEFUN (PLUS? BOOLEAN) ...)

(CL:DEFUN PLUS? (X)
  "Return true if `x' is greater than 0."
  (CL:DECLARE (CL:TYPE CL:FIXNUM X))
  (CL:RETURN-FROM PLUS? (CL:> X 0)))

;;; (DEFUN (EVEN? BOOLEAN) ...)

(CL:DEFUN EVEN? (X)
  "Return true if `x' is an even number."
  (CL:DECLARE (CL:TYPE CL:FIXNUM X))
  (CL:RETURN-FROM EVEN? (CL:NOT (CL:LOGBITP 0 X))))

;;; (DEFUN (ODD? BOOLEAN) ...)

(CL:DEFUN ODD? (X)
  "Return true if `x' is an odd number."
  (CL:DECLARE (CL:TYPE CL:FIXNUM X))
  (CL:RETURN-FROM ODD? (CL:LOGBITP 0 X)))

;;; (DEFUN (MOD INTEGER) ...)

(CL:DEFUN MOD (X MODULO)
  "Return the result of `x' mod `modulo'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM X MODULO))
  (CL:RETURN-FROM MOD (CL:MOD X MODULO)))

;;; (DEFUN (RANDOM INTEGER) ...)

(CL:DEFUN RANDOM (N)
  "Generate a random integer in the interval [0..n-1].
'n' must be <= 2^15."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  (CL:WHEN (CL:> N 32768)
   (CL:ERROR
    (NEW-STELLA-EXCEPTION
     "random: Can only generate random numbers between 0 and (2^15)-1.")))
  (CL:LET* ((RNUM (CL:RANDOM N))) (CL:DECLARE (CL:TYPE CL:FIXNUM RNUM))
   (CL:RETURN-FROM RANDOM RNUM)))

;;; (DEFUN SEED-RANDOM-NUMBER-GENERATOR ...)

(CL:DEFUN SEED-RANDOM-NUMBER-GENERATOR ()
  "Seeds the random number generator with the current time"
  :VOID)

;;; (DEFUN (SQRT FLOAT) ...)

(CL:DEFUN SQRT (N)
  "Return the square root of `n'."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT N))
  (CL:RETURN-FROM SQRT (CL:SQRT N)))

;;; (DEFUN (COS FLOAT) ...)

(CL:DEFUN COS (N)
  "Return the cosine of `n'."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT N))
  (CL:RETURN-FROM COS (CL:COS N)))

;;; (DEFUN (SIN FLOAT) ...)

(CL:DEFUN SIN (N)
  "Return the sine of `n'."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT N))
  (CL:RETURN-FROM SIN (CL:SIN N)))

;;; (DEFUN (TAN FLOAT) ...)

(CL:DEFUN TAN (N)
  "Return the tangent of `n'."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT N))
  (CL:RETURN-FROM TAN (CL:TAN N)))

;;; (DEFUN (LOG FLOAT) ...)

(CL:DEFUN LOG (N)
  "Return the natural logarithm (base e) of `n'."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT N))
  (CL:RETURN-FROM LOG (CL:LOG N)))

;;; (DEFUN (MIN INTEGER) ...)

(CL:DEFUN MIN (X Y)
  "Return the minimum of `x' and `y'.  If either is NULL, return the other."
  (CL:DECLARE (CL:TYPE CL:FIXNUM X Y))
  (CL:WHEN (NULL? X) (CL:RETURN-FROM MIN Y))
  (CL:WHEN (NULL? Y) (CL:RETURN-FROM MIN X))
  (CL:RETURN-FROM MIN (CL:IF (CL:< X Y) X Y)))

;;; (DEFUN (MAX INTEGER) ...)

(CL:DEFUN MAX (X Y)
  "Return the maximum of `x' and `y'.  If either is NULL, return the other."
  (CL:DECLARE (CL:TYPE CL:FIXNUM X Y))
  (CL:WHEN (NULL? X) (CL:RETURN-FROM MAX Y))
  (CL:WHEN (NULL? Y) (CL:RETURN-FROM MAX X))
  (CL:RETURN-FROM MAX (CL:IF (CL:> X Y) X Y)))

;;; (DEFMETHOD (ABS INTEGER) ...)

(CL:DEFMETHOD ABS ((X CL:INTEGER))
  "Return the absolute value of `x'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM X))
  (CL:RETURN-FROM ABS (CL:IF (CL:< X 0) (CL:- 0 X) X)))

;;; (DEFMETHOD (ABS FLOAT) ...)

(CL:DEFMETHOD ABS ((X CL:FLOAT))
  "Return the absolute value of `x'."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT X))
  (CL:RETURN-FROM ABS (CL:IF (CL:< X 0.0d0) (CL:- 0.0d0 X) X)))

;;; (DEFUN (CHARACTER-CODE INTEGER) ...)

(CL:DEFUN CHARACTER-CODE (CHARACTER)
  "Return the 8-bit ASCII code of 'character' as an integer."
  (CL:RETURN-FROM CHARACTER-CODE (CL:CHAR-CODE CHARACTER)))

;;; (DEFUN (CODE-CHARACTER CHARACTER) ...)

(CL:DEFUN CODE-CHARACTER (CODE)
  "Return the character encoded by 'code' (0 <= 'code' <= 255)."
  (CL:DECLARE (CL:TYPE CL:FIXNUM CODE))
  (CL:RETURN-FROM CODE-CHARACTER (CL:CODE-CHAR CODE)))

;;; (DEFUN (CHARACTER-DOWNCASE CHARACTER) ...)

(CL:DEFUN CHARACTER-DOWNCASE (C)
  "Return the lowercase character for 'c'."
  (CL:RETURN-FROM CHARACTER-DOWNCASE (CL:CHAR-DOWNCASE C)))

;;; (DEFUN (CHARACTER-UPCASE CHARACTER) ...)

(CL:DEFUN CHARACTER-UPCASE (C)
  "Return the uppercase character for 'c'.  If only the first character of
a sequence of characters is to be capitalized, character-capitalize should be used."
  (CL:RETURN-FROM CHARACTER-UPCASE (CL:CHAR-UPCASE C)))

;;; (DEFUN (CHARACTER-CAPITALIZE CHARACTER) ...)

(CL:DEFUN CHARACTER-CAPITALIZE (C)
  "Return the capitalized character for 'c'.  This is generally the same
as the uppercase character, except for obscure non-English characters in Java.  It should
be used if only the first character of a sequence of characters is to be capitalized."
  (CL:RETURN-FROM CHARACTER-CAPITALIZE (CL:CHAR-UPCASE C)))

;;; (DEFSPECIAL *TRANSIENTOBJECTS?* ...)

(CL:DEFVAR *TRANSIENTOBJECTS?* FALSE)

;;; (DEFUN (STRING-EQL? BOOLEAN) ...)

(CL:DEFUN STRING-EQL? (X Y)
  "Return true if `x' and `y' are equal strings including case or both null."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:IF (CL:EQ X STELLA::NULL-STRING)
   (CL:RETURN-FROM STRING-EQL? (CL:EQ Y STELLA::NULL-STRING))
   (CL:RETURN-FROM STRING-EQL?
    (CL:AND (CL:NOT (CL:EQ Y STELLA::NULL-STRING)) (CL:string= x y)))))

;;; (DEFUN (STRING-EQUAL? BOOLEAN) ...)

(CL:DEFUN STRING-EQUAL? (X Y)
  "Return true if `x' and `y' are equal strings ignoring case or both null."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:IF (CL:EQ X STELLA::NULL-STRING)
   (CL:RETURN-FROM STRING-EQUAL? (CL:EQ Y STELLA::NULL-STRING))
   (CL:RETURN-FROM STRING-EQUAL?
    (CL:AND (CL:NOT (CL:EQ Y STELLA::NULL-STRING)) (CL:string-equal x y)))))

;;; (DEFUN (STRING-COMPARE INTEGER) ...)

(CL:DEFUN STRING-COMPARE (X Y CASE-SENSITIVE?)
  "Compare 'x' and 'y' lexicographically, and return -1, 0, 
or 1, depending on whether 'x' is less than, equal, or greater than 'y'.
If 'case-sensitive?' is TRUE, then case does not matter for the comparison."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:IF CASE-SENSITIVE?
   (CL:RETURN-FROM STRING-COMPARE
    (CL:COND ((CL:STRING< X Y) -1) ((CL:STRING> X Y) 1) (CL:T 0)))
   (CL:RETURN-FROM STRING-COMPARE
    (CL:COND ((CL:STRING-LESSP X Y) -1) ((CL:STRING-GREATERP X Y) 1)
     (CL:T 0)))))

;;; (DEFUN (STRING< BOOLEAN) ...)

(CL:DEFUN STRING< (X Y)
  "Return TRUE if 'x' is lexicographically < 'y'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:RETURN-FROM STRING< (CL:NULL (CL:STRING>= X Y))))

;;; (DEFUN (STRING<= BOOLEAN) ...)

(CL:DEFUN STRING<= (X Y)
  "Return TRUE if 'x' is lexicographically <= 'y'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:RETURN-FROM STRING<= (CL:NULL (CL:STRING> X Y))))

;;; (DEFUN (STRING>= BOOLEAN) ...)

(CL:DEFUN STRING>= (X Y)
  "Return TRUE if 'x' is lexicographically >= 'y'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:RETURN-FROM STRING>= (CL:NULL (CL:STRING< X Y))))

;;; (DEFUN (STRING> BOOLEAN) ...)

(CL:DEFUN STRING> (X Y)
  "Return TRUE if 'x' is lexicographically > 'y'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:RETURN-FROM STRING> (CL:NULL (CL:STRING<= X Y))))

;;; (DEFUN (STRING-LESS? BOOLEAN) ...)

(CL:DEFUN STRING-LESS? (X Y)
  "Return TRUE if 'x' is lexicographically < 'y', ignoring case."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:RETURN-FROM STRING-LESS? (CL:NULL (CL:STRING-NOT-LESSP X Y))))

;;; (DEFUN (STRING-LESS-EQUAL? BOOLEAN) ...)

(CL:DEFUN STRING-LESS-EQUAL? (X Y)
  "Return TRUE if 'x' is lexicographically <= 'y', ignoring case."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:RETURN-FROM STRING-LESS-EQUAL? (CL:NULL (CL:STRING-GREATERP X Y))))

;;; (DEFUN (STRING-GREATER-EQUAL? BOOLEAN) ...)

(CL:DEFUN STRING-GREATER-EQUAL? (X Y)
  "Return TRUE if 'x' is lexicographically >= 'y', ignoring case."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:RETURN-FROM STRING-GREATER-EQUAL? (CL:NULL (CL:STRING-LESSP X Y))))

;;; (DEFUN (STRING-GREATER? BOOLEAN) ...)

(CL:DEFUN STRING-GREATER? (X Y)
  "Return TRUE if 'x' is lexicographically > 'y', ignoring case."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X Y))
  (CL:RETURN-FROM STRING-GREATER? (CL:NULL (CL:STRING-NOT-GREATERP X Y))))

;;; (DEFUN (MAKE-MUTABLE-STRING MUTABLE-STRING) ...)

(CL:DEFUN MAKE-MUTABLE-STRING (SIZE INITCHAR)
  "Return a new mutable string filled with 'size' 'initchar's."
  (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
  (CL:RETURN-FROM MAKE-MUTABLE-STRING
   (CL:MAKE-STRING SIZE :INITIAL-ELEMENT INITCHAR)))

;;; (DEFUN (MAKE-RAW-MUTABLE-STRING MUTABLE-STRING) ...)

(CL:DEFUN MAKE-RAW-MUTABLE-STRING (SIZE)
  "Return a new uninitialized mutable string of `size'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
  (CL:LET* ((S STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
   (SETQ S (CL:MAKE-STRING SIZE))
   (CL:RETURN-FROM MAKE-RAW-MUTABLE-STRING S)))

;;; (DEFMETHOD (CONCATENATE STRING) ...)

(CL:DEFMETHOD CONCATENATE ((STRING1 CL:STRING) STRING2 CL:&REST OTHERSTRINGS)
  "Return a new string representing the concatenation
of `string1', `string2', and `otherStrings'.  The two mandatory parameters
allow us to optimize the common binary case by not relying on the somewhat
less efficient variable arguments mechanism."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING1 STRING2))
  (CL:WHEN (CL:= (CL:LENGTH OTHERSTRINGS) 0)
   (CL:RETURN-FROM CONCATENATE (STRING-CONCATENATE STRING1 STRING2)))
  (CL:LET*
   ((RESULT STELLA::NULL-STRING)
    (LENGTH
     (CL:+ (CL:THE CL:FIXNUM (CL:LENGTH STRING1))
      (CL:THE CL:FIXNUM (CL:LENGTH STRING2))))
    (INDEX 0))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT)
    (CL:TYPE CL:FIXNUM LENGTH INDEX))
   (CL:LET* ((STRING STELLA::NULL-STRING) (ITER-000 OTHERSTRINGS))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ STRING (CL:POP ITER-000))
     (CL:SETQ LENGTH
      (CL:+ LENGTH (CL:THE CL:FIXNUM (CL:LENGTH STRING))))))
   (CL:SETQ RESULT
    (CL:THE CL:SIMPLE-STRING
     (CL:MAKE-STRING LENGTH :INITIAL-ELEMENT NULL-CHARACTER)))
   (CL:LET*
    ((CH NULL-CHARACTER) (VECTOR-000 STRING1) (INDEX-000 0)
     (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ CH
       (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION))))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:LET ((SELF RESULT) (CH CH) (POSITION INDEX))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (SETF
       (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))
       (CL:THE CL:CHARACTER CH)))
     (CL:SETQ INDEX (CL:1+ INDEX))))
   (CL:LET*
    ((CH NULL-CHARACTER) (VECTOR-001 STRING2) (INDEX-001 0)
     (LENGTH-001 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-001))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-001)
     (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
    (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
     (CL:PROGN
      (CL:SETQ CH
       (CL:LET ((SELF VECTOR-001) (POSITION INDEX-001))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION))))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:LET ((SELF RESULT) (CH CH) (POSITION INDEX))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (SETF
       (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))
       (CL:THE CL:CHARACTER CH)))
     (CL:SETQ INDEX (CL:1+ INDEX))))
   (CL:LET* ((STRING STELLA::NULL-STRING) (ITER-001 OTHERSTRINGS))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
    (CL:LOOP WHILE ITER-001 DO (CL:SETQ STRING (CL:POP ITER-001))
     (CL:LET*
      ((CH NULL-CHARACTER) (VECTOR-002 STRING) (INDEX-002 0)
       (LENGTH-002 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-002))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-002)
       (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
      (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
       (CL:PROGN
        (CL:SETQ CH
         (CL:LET ((SELF VECTOR-002) (POSITION INDEX-002))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
       (CL:LET ((SELF RESULT) (CH CH) (POSITION INDEX))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (SETF
         (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))
         (CL:THE CL:CHARACTER CH)))
       (CL:SETQ INDEX (CL:1+ INDEX))))))
   (CL:RETURN-FROM CONCATENATE
    (CL:LET ((S RESULT)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
     (CL:THE CL:SIMPLE-STRING S)))))

;;; (DEFUN (REPLACE-SUBSTRINGS STRING) ...)

(CL:DEFUN REPLACE-SUBSTRINGS (STRING NEW OLD)
  "Replace all occurrences of `old' in `string' with `new'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING NEW OLD))
  (CL:LET*
   ((STRINGLENGTH (CL:THE CL:FIXNUM (CL:LENGTH STRING)))
    (OLDLENGTH (CL:THE CL:FIXNUM (CL:LENGTH OLD)))
    (NEWLENGTH (CL:THE CL:FIXNUM (CL:LENGTH NEW))) (NOFOCCURRENCES 0)
    (OLDSTART 0) (CURSOR 0) (RESULTCURSOR 0) (RESULT STELLA::NULL-STRING))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM STRINGLENGTH OLDLENGTH NEWLENGTH NOFOCCURRENCES
     OLDSTART CURSOR RESULTCURSOR)
    (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:LOOP WHILE
    (DEFINED? (CL:SETQ OLDSTART (STRING-SEARCH STRING OLD CURSOR))) DO
    (CL:SETQ NOFOCCURRENCES (CL:1+ NOFOCCURRENCES))
    (CL:SETQ CURSOR (CL:+ OLDSTART OLDLENGTH)))
   (CL:WHEN (CL:= NOFOCCURRENCES 0)
    (CL:RETURN-FROM REPLACE-SUBSTRINGS STRING))
   (CL:SETQ RESULT
    (MAKE-RAW-MUTABLE-STRING
     (CL:+ STRINGLENGTH
      (CL:* NOFOCCURRENCES (CL:- NEWLENGTH OLDLENGTH)))))
   (CL:SETQ CURSOR 0)
   (CL:LOOP WHILE
    (DEFINED? (CL:SETQ OLDSTART (STRING-SEARCH STRING OLD CURSOR))) DO
    (CL:LET*
     ((I NULL-INTEGER) (ITER-000 CURSOR)
      (UPPER-BOUND-000 (CL:1- OLDSTART)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
     (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
      (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
      (CL:LET
       ((SELF RESULT)
        (CH
         (CL:LET ((SELF STRING) (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))
        (POSITION RESULTCURSOR))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (SETF
        (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION))
        (CL:THE CL:CHARACTER CH)))
      (CL:SETQ RESULTCURSOR (CL:1+ RESULTCURSOR))))
    (CL:LET*
     ((CHAR NULL-CHARACTER) (VECTOR-000 NEW) (INDEX-000 0)
      (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:PROGN
       (CL:SETQ CHAR
        (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
      (CL:LET ((SELF RESULT) (CH CHAR) (POSITION RESULTCURSOR))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (SETF
        (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION))
        (CL:THE CL:CHARACTER CH)))
      (CL:SETQ RESULTCURSOR (CL:1+ RESULTCURSOR))))
    (CL:SETQ CURSOR (CL:+ OLDSTART OLDLENGTH)))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-001 CURSOR)
     (UPPER-BOUND-001 (CL:1- STRINGLENGTH)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 UPPER-BOUND-001 I))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:LET
      ((SELF RESULT)
       (CH
        (CL:LET ((SELF STRING) (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))))
       (POSITION RESULTCURSOR))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (SETF
       (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))
       (CL:THE CL:CHARACTER CH)))
     (CL:SETQ RESULTCURSOR (CL:1+ RESULTCURSOR))))
   (CL:RETURN-FROM REPLACE-SUBSTRINGS
    (CL:LET ((S RESULT)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
     (CL:THE CL:SIMPLE-STRING S)))))

;;; (DEFUN (CHARACTER-TO-STRING STRING) ...)

(CL:DEFUN CHARACTER-TO-STRING (C)
  (CL:RETURN-FROM CHARACTER-TO-STRING (MAKE-STRING 1 C)))

;;; (DEFMETHOD (NTH CHARACTER) ...)

(CL:DEFMETHOD NTH ((SELF CL:STRING) POSITION)
  "Return the character in `self' at `position'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF) (CL:TYPE CL:FIXNUM POSITION))
  (CL:RETURN-FROM NTH
   (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))))

;;; (DEFMETHOD (NTH CHARACTER) ...)

(CL:DEFMETHOD NTH ((SELF CL:STRING) POSITION)
  "Return the character in `self' at `position'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF) (CL:TYPE CL:FIXNUM POSITION))
  (CL:RETURN-FROM NTH
   (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))))

;;; (DEFMETHOD (NTH-SETTER CHARACTER) ...)

(CL:DEFMETHOD NTH-SETTER ((SELF CL:STRING) CH POSITION)
  "Set the character in `self' at `position' to `ch'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF) (CL:TYPE CL:FIXNUM POSITION))
  (CL:RETURN-FROM NTH-SETTER
   (SETF
    (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))
    (CL:THE CL:CHARACTER CH))))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF CL:STRING))
  "Return the length of the string `self'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  (CL:RETURN-FROM LENGTH (CL:LENGTH SELF)))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF CL:STRING))
  "Return the length of the string `self'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  (CL:RETURN-FROM LENGTH (CL:LENGTH SELF)))

;;; (DEFUN (UNSTRINGIFY OBJECT) ...)

(CL:DEFUN UNSTRINGIFY (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  (CL:RETURN-FROM UNSTRINGIFY (READ-S-EXPRESSION-FROM-STRING STRING)))

;;; (DEFMETHOD FREE-HASH-TABLE-VALUES ...)

(CL:DEFMETHOD FREE-HASH-TABLE-VALUES ((SELF ABSTRACT-HASH-TABLE))
  "Call free on each value in the hash table 'self'."
  (CL:LET* ((NATIVE-TABLE (%ABSTRACT-HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:maphash #'(CL:lambda (key value)
				     (CL:declare (CL:ignore key))
				     (free value))
				 native-table))
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF ABSTRACT-HASH-TABLE))
  "Insert a newly-created native hash table into 'self'."
  (CL:SETF (%ABSTRACT-HASH-TABLE.THE-HASH-TABLE SELF)
   (CL:make-hash-table :test #'CL:eql))
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF HASH-TABLE) KEY)
  (CL:LET* ((NATIVE-TABLE (%HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:RETURN-FROM LOOKUP (CL:OR (CL:GETHASH KEY NATIVE-TABLE) NULL))))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF HASH-TABLE) KEY VALUE)
  (CL:LET* ((NATIVE-TABLE (%HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:SETF (CL:GETHASH KEY NATIVE-TABLE) VALUE))
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF HASH-TABLE) KEY)
  (CL:LET* ((NATIVE-TABLE (%HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:REMHASH KEY NATIVE-TABLE))
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF INTEGER-HASH-TABLE))
  "Insert a newly-created native hash table into 'self'."
  (CL:SETF (%INTEGER-HASH-TABLE.THE-HASH-TABLE SELF)
   (CL:make-hash-table :test #'CL:eql))
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF INTEGER-HASH-TABLE) KEY)
  (CL:DECLARE (CL:TYPE CL:FIXNUM KEY))
  (CL:LET* ((NATIVE-TABLE (%INTEGER-HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:RETURN-FROM LOOKUP (CL:OR (CL:GETHASH KEY NATIVE-TABLE) NULL))))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF INTEGER-HASH-TABLE) KEY VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM KEY))
  (CL:LET* ((NATIVE-TABLE (%INTEGER-HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:DECLARE (CL:FIXNUM KEY))
   (CL:SETF (CL:GETHASH KEY NATIVE-TABLE) VALUE))
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF INTEGER-HASH-TABLE) KEY)
  (CL:DECLARE (CL:TYPE CL:FIXNUM KEY))
  (CL:LET* ((NATIVE-TABLE (%INTEGER-HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:REMHASH KEY NATIVE-TABLE))
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF FLOAT-HASH-TABLE))
  "Insert a newly-created native hash table into 'self'."
  (CL:SETF (%FLOAT-HASH-TABLE.THE-HASH-TABLE SELF)
   (CL:make-hash-table :test #'CL:eql))
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF FLOAT-HASH-TABLE) KEY)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT KEY))
  (CL:LET* ((NATIVE-TABLE (%FLOAT-HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:RETURN-FROM LOOKUP (CL:OR (CL:GETHASH KEY NATIVE-TABLE) NULL))))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF FLOAT-HASH-TABLE) KEY VALUE)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT KEY))
  (CL:LET* ((NATIVE-TABLE (%FLOAT-HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:SETF (CL:GETHASH KEY NATIVE-TABLE) VALUE))
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF FLOAT-HASH-TABLE) KEY)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT KEY))
  (CL:LET* ((NATIVE-TABLE (%FLOAT-HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:REMHASH KEY NATIVE-TABLE))
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-HASH-TABLE))
  "Insert a newly-created native hash table into 'self'."
  (CL:SETF (%STRING-HASH-TABLE.THE-HASH-TABLE SELF)
   (CL:make-hash-table :test #'CL:equal))
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF STRING-HASH-TABLE) KEY)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
  (CL:LET* ((NATIVE-TABLE (%STRING-HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:RETURN-FROM LOOKUP (CL:OR (CL:GETHASH KEY NATIVE-TABLE) NULL))))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF STRING-HASH-TABLE) KEY VALUE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
  (CL:LET* ((NATIVE-TABLE (%STRING-HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:SETF (CL:GETHASH KEY NATIVE-TABLE) VALUE))
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF STRING-HASH-TABLE) KEY)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
  (CL:LET* ((NATIVE-TABLE (%STRING-HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:REMHASH KEY NATIVE-TABLE))
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-TO-INTEGER-HASH-TABLE))
  "Insert a newly-created native hash table into 'self'."
  (CL:SETF (%STRING-TO-INTEGER-HASH-TABLE.THE-HASH-TABLE SELF)
   (CL:make-hash-table :test #'CL:equal))
  :VOID)

;;; (DEFMETHOD (LOOKUP INTEGER) ...)

(CL:DEFMETHOD LOOKUP ((SELF STRING-TO-INTEGER-HASH-TABLE) KEY)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
  (CL:LET*
   ((NATIVE-TABLE (%STRING-TO-INTEGER-HASH-TABLE.THE-HASH-TABLE SELF))
    (RESULT NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM RESULT))
   (CL:SETQ RESULT (CL:OR (CL:GETHASH KEY NATIVE-TABLE) NULL-INTEGER))
   (CL:RETURN-FROM LOOKUP RESULT)))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) KEY VALUE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY) (CL:TYPE CL:FIXNUM VALUE))
  (CL:LET*
   ((NATIVE-TABLE (%STRING-TO-INTEGER-HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:SETF (CL:GETHASH KEY NATIVE-TABLE) VALUE))
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) KEY)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
  (CL:LET*
   ((NATIVE-TABLE (%STRING-TO-INTEGER-HASH-TABLE.THE-HASH-TABLE SELF)))
   (CL:REMHASH KEY NATIVE-TABLE))
  :VOID)

;;; (DEFUN (OBJECT-HASH-CODE INTEGER) ...)

(CL:DEFUN OBJECT-HASH-CODE (SELF)
  "Return a hash code for `self'.  Two objects that are `eq?'
are guaranteed to generate the same hash code.  Two objects that are not `eq?'
do not necessarily generate different hash codes.  Similar to `hash-code' but
always hashes on the address of `self' even if it is a wrapper."
  (CL:RETURN-FROM OBJECT-HASH-CODE (STELLA::%%OBJECT-HASH-CODE SELF)))

;;; (DEFMETHOD (HASH-CODE INTEGER) ...)

(CL:DEFMETHOD HASH-CODE ((SELF OBJECT))
  "Return a hash code for `self'.  Two objects that are `eql?'
are guaranteed to generate the same hash code.  Two objects that are not `eql?'
do not necessarily generate different hash codes."
  (CL:RETURN-FROM HASH-CODE
   (CL:LET ((SELF SELF))
    (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF)))))

;;; (DEFMETHOD (HASH-CODE INTEGER) ...)

(%%DEFCONSMETHOD HASH-CODE ((SELF STANDARD-OBJECT))
  (CL:RETURN-FROM HASH-CODE
   (CL:LET ((SELF SELF))
    (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF)))))

;;; (DEFMETHOD (HASH-CODE INTEGER) ...)

(CL:DEFMETHOD HASH-CODE ((SELF WRAPPER))
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "WRAPPER.hash-code: Don't know how to hash on `" SELF "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD (HASH-CODE INTEGER) ...)

(CL:DEFMETHOD HASH-CODE ((SELF STRING-WRAPPER))
  (CL:RETURN-FROM HASH-CODE
   (CL:THE CL:FIXNUM
    (CL:SXHASH
     (CL:THE CL:SIMPLE-STRING (%STRING-WRAPPER.WRAPPER-VALUE SELF))))))

;;; (DEFMETHOD (HASH-CODE INTEGER) ...)

(CL:DEFMETHOD HASH-CODE ((SELF INTEGER-WRAPPER))
  (CL:RETURN-FROM HASH-CODE (%INTEGER-WRAPPER.WRAPPER-VALUE SELF)))

;;; (DEFMETHOD (HASH-CODE INTEGER) ...)

(CL:DEFMETHOD HASH-CODE ((SELF FLOAT-WRAPPER))
  (CL:RETURN-FROM HASH-CODE
   (CL:THE CL:FIXNUM
    (CL:SXHASH
     (CL:THE CL:DOUBLE-FLOAT (%FLOAT-WRAPPER.WRAPPER-VALUE SELF))))))

;;; (DEFMETHOD (HASH-CODE INTEGER) ...)

(CL:DEFMETHOD HASH-CODE ((SELF CHARACTER-WRAPPER))
  (CL:RETURN-FROM HASH-CODE
   (CL:THE CL:FIXNUM
    (CL:CHAR-CODE (%CHARACTER-WRAPPER.WRAPPER-VALUE SELF)))))

;;; (DEFMETHOD (HASH-CODE INTEGER) ...)

(CL:DEFMETHOD HASH-CODE ((SELF BOOLEAN-WRAPPER))
  (CL:RETURN-FROM HASH-CODE
   (CL:IF (%BOOLEAN-WRAPPER.WRAPPER-VALUE SELF) 7936 7680)))

;;; (DEFMETHOD (HASH-CODE INTEGER) ...)

(CL:DEFMETHOD HASH-CODE ((SELF CL:STRING))
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  (CL:RETURN-FROM HASH-CODE (CL:SXHASH SELF)))

;;; (DEFMETHOD (HASH-CODE INTEGER) ...)

(CL:DEFMETHOD HASH-CODE ((SELF CL:INTEGER))
  (CL:DECLARE (CL:TYPE CL:FIXNUM SELF))
  (CL:RETURN-FROM HASH-CODE SELF))

;;; (DEFMETHOD (HASH-CODE INTEGER) ...)

(CL:DEFMETHOD HASH-CODE ((SELF CL:FLOAT))
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SELF))
  (CL:RETURN-FROM HASH-CODE (CL:SXHASH SELF)))

;;; (DEFMETHOD (HASH-CODE INTEGER) ...)

(CL:DEFMETHOD HASH-CODE ((SELF CL:CHARACTER))
  (CL:RETURN-FROM HASH-CODE (CL:THE CL:FIXNUM (CL:CHAR-CODE SELF))))

;;; (DEFUN (HASH-STRING INTEGER) ...)

(CL:DEFUN HASH-STRING (STRING SEEDCODE)
  "Generate a hash-code for `string' and return it.
Two strings that are equal but not eq will generate the same code.
The hash-code is based on `seedCode' which usually will be 0.  However,
`seedCode' can also be used to supply the result of a previous hash
operation to achieve hashing on sequences of strings without actually
having to concatenate them."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING)
   (CL:TYPE CL:FIXNUM SEEDCODE))
  (CL:RETURN-FROM HASH-STRING
   (HASH-SUBSTRING STRING SEEDCODE 0 NULL-INTEGER)))

;;; (DEFUN (HASH-SUBSTRING INTEGER) ...)

(CL:DEFUN HASH-SUBSTRING (STRING CODE START END)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING)
   (CL:TYPE CL:FIXNUM CODE START END))
  (CL:WHEN (CL:= START NULL-INTEGER) (CL:SETQ START 0))
  (CL:WHEN (CL:= END NULL-INTEGER)
   (CL:SETQ END (CL:THE CL:FIXNUM (CL:LENGTH STRING))))
  (CL:SETQ CODE (CL:THE CL:FIXNUM (CL:LOGXOR CODE 2700379)))
  (CL:LET*
   ((OFFSET
     (CL:LET ((ARG CODE) (COUNT 9))
      (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
      (CL:THE CL:FIXNUM (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT)))))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 START) (UPPER-BOUND-000 (CL:1- END)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:SETQ OFFSET (CL:1+ OFFSET))
     (CL:SETQ CODE
      (CL:THE CL:FIXNUM
       (CL:LOGXOR CODE
        (CL:THE CL:FIXNUM
         (CL:ASH
          (CL:THE CL:FIXNUM
           (CL:CHAR-CODE
            (CL:LET ((SELF STRING) (POSITION I))
             (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
              (CL:TYPE CL:FIXNUM POSITION))
             (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
              (CL:THE CL:FIXNUM POSITION)))))
          (CL:THE CL:FIXNUM (CL:LOGAND OFFSET 15)))))))))
   (CL:RETURN-FROM HASH-SUBSTRING CODE)))

;;; (DEFGLOBAL *HASHTABLE-SIZE-PRIMES* ...)

(CL:DEFVAR *HASHTABLE-SIZE-PRIMES* NULL
  "List of prime numbers approximately growing by a factor of 2
that are suitable to be used as hashtable sizes.")

;;; (DEFUN (PICK-HASHTABLE-SIZE-PRIME INTEGER) ...)

(CL:DEFUN PICK-HASHTABLE-SIZE-PRIME (MINSIZE)
  "Return a hashtable prime of at least `minSize'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM MINSIZE))
  (CL:LET*
   ((PRIME NULL) (ITER-000 (%LIST.THE-CONS-LIST *HASHTABLE-SIZE-PRIMES*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ PRIME (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (CL:>= (%INTEGER-WRAPPER.WRAPPER-VALUE PRIME) MINSIZE)
     (CL:RETURN-FROM PICK-HASHTABLE-SIZE-PRIME
      (%INTEGER-WRAPPER.WRAPPER-VALUE PRIME)))))
  (CL:ERROR
   (NEW-STELLA-EXCEPTION
    "pick-hashtable-size-prime: minimum size is too large")))

;;; (DEFMETHOD INITIALIZE-VECTOR ...)

(CL:DEFMETHOD INITIALIZE-VECTOR ((SELF VECTOR))
  (CL:LET* ((SIZE (%VECTOR.ARRAY-SIZE SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
   (CL:SETF (%VECTOR.THE-ARRAY SELF)
    (CL:MAKE-ARRAY SIZE :INITIAL-ELEMENT NULL))
   (setq size size))
  :VOID)

;;; (DEFUN RESIZE-VECTOR ...)

(CL:DEFUN RESIZE-VECTOR (SELF SIZE)
  "Change the size of `self' to `size'.  If `size' is smaller
than the current size of `self' the vector will be truncated.  Otherwise, 
the internal array of `self' will be grown to `size' and unused elements
will be initialized to NULL."
  (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
  (CL:LET*
   ((OLD_SIZE (%VECTOR.ARRAY-SIZE SELF)) (I OLD_SIZE)
    (OLD_ARRAY (%VECTOR.THE-ARRAY SELF)) (NEW_ARRAY OLD_ARRAY))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OLD_SIZE I)
    (CL:TYPE CL:SIMPLE-VECTOR OLD_ARRAY NEW_ARRAY))
   (CL:WHEN (CL:= SIZE OLD_SIZE) (CL:RETURN-FROM RESIZE-VECTOR))
   (CL:SETQ NEW_ARRAY (CL:MAKE-ARRAY SIZE :INITIAL-ELEMENT NULL))
   (CL:WHEN (CL:< SIZE OLD_SIZE) (CL:SETQ OLD_SIZE SIZE)
    (CL:SETQ I OLD_SIZE))
   (CL:LOOP WHILE (CL:>= (CL:SETQ I (CL:1- I)) 0) DO
    (CL:LET ((SELF NEW_ARRAY) (VALUE (CL:AREF OLD_ARRAY I)) (POSITION I))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE)))
   (setq i i) (CL:SETF (%VECTOR.THE-ARRAY SELF) NEW_ARRAY)
   (CL:SETF (%VECTOR.ARRAY-SIZE SELF) SIZE))
  :VOID)

;;; (DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH ((SELF CL:VECTOR) POSITION)
  "Return the element in `self' at `position'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
  (CL:RETURN-FROM NTH (CL:AREF SELF POSITION)))

;;; (DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH-SETTER ((SELF CL:VECTOR) VALUE POSITION)
  "Set the element in `self' at `position' to `value'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
  (CL:RETURN-FROM NTH-SETTER (CL:SETF (CL:AREF SELF POSITION) VALUE)))

;;; (DEFUN UNMAKE ...)

(CL:DEFUN UNMAKE (SELF)
  :VOID)

;;; (DEFUN (LOGNOT INTEGER) ...)

(CL:DEFUN LOGNOT (ARG)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARG))
  (CL:RETURN-FROM LOGNOT (CL:LOGNOT ARG)))

;;; (DEFUN (LOGAND INTEGER) ...)

(CL:DEFUN LOGAND (ARG1 ARG2)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARG1 ARG2))
  (CL:RETURN-FROM LOGAND (CL:LOGAND ARG1 ARG2)))

;;; (DEFUN (LOGOR INTEGER) ...)

(CL:DEFUN LOGOR (ARG1 ARG2)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARG1 ARG2))
  (CL:RETURN-FROM LOGOR (CL:LOGIOR ARG1 ARG2)))

;;; (DEFUN (LOGXOR INTEGER) ...)

(CL:DEFUN LOGXOR (ARG1 ARG2)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARG1 ARG2))
  (CL:RETURN-FROM LOGXOR (CL:LOGXOR ARG1 ARG2)))

;;; (DEFUN (SHIFT-LEFT INTEGER) ...)

(CL:DEFUN SHIFT-LEFT (ARG COUNT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
  (CL:RETURN-FROM SHIFT-LEFT (CL:ASH ARG COUNT)))

;;; (DEFUN (SHIFT-RIGHT INTEGER) ...)

(CL:DEFUN SHIFT-RIGHT (ARG COUNT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
  (CL:RETURN-FROM SHIFT-RIGHT (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT)))))

;;; (DEFUN (STELLIFY OBJECT) ...)

(CL:DEFUN STELLIFY (SELF)
  "Convert a Lisp object into a STELLA object."
  (CL:LET* ((RESULT SELF)) (CL:typecase self
        (CL:NULL (cl:setq result STELLA::NIL))
        (CL:CONS (cl:setq result (stella::cons (stellify (CL:car self))
                                               (stellify (CL:cdr self)))))
        (CL:KEYWORD (cl:setq result (intern-keyword (CL:symbol-name self))))
        (CL:SYMBOL
         (CL:if (cl:eq self CL:t)
           (cl:setq result TRUE-WRAPPER)
           (cl:setq result (intern-symbol (CL:symbol-name self)))))
        ((CL:or CL:NUMBER CL:STRING) (cl:setq result (wrap-literal self)))
        (STELLA::OBJECT (cl:setq result self))
        (CL:t (CL:error "Can't stellify: " self)))
   (CL:RETURN-FROM STELLIFY RESULT)))

;;; (DEFUN (STELLA-OBJECT? BOOLEAN) ...)

(CL:DEFUN STELLA-OBJECT? (SELF)
  "Return TRUE if 'self' is a member of the STELLA class 'OBJECT'."
  (CL:LET* ((RESULT? TRUE))
   (CL:setq result? (cl:typep self 'STELLA::OBJECT))
   (CL:RETURN-FROM STELLA-OBJECT? RESULT?)))

;;; (DEFUN (RUNNING-AS-LISP? BOOLEAN) ...)

(CL:DEFUN RUNNING-AS-LISP? ()
  "Return TRUE if the executable code is a Common Lisp application."
  (CL:LET* ((RESULT? FALSE)) (cl:setq result? TRUE)
   (CL:RETURN-FROM RUNNING-AS-LISP? RESULT?)))

;;; (DEFUN (EXCEPTION-MESSAGE STRING) ...)

(CL:DEFUN EXCEPTION-MESSAGE (E)
  "Accesses the error message from the Exception"
  (CL:RETURN-FROM EXCEPTION-MESSAGE (%%GET-EXCEPTION-MESSAGE E)))

;;; (DEFUN PRINT-EXCEPTION-CONTEXT ...)

(CL:DEFUN PRINT-EXCEPTION-CONTEXT (E STREAM)
  "Prints a system dependent information about the context of the specified
exception.  For example, in Java it prints a stack trace.  In Lisp, it is vendor dependent."
  (CL:LET* ((S (%OUTPUT-STREAM.NATIVE-STREAM STREAM)))
   (%%PRINT-EXCEPTION-CONTEXT E S))
  :VOID)

(CL:DEFUN HELP-STARTUP-PRIMAL1 ()
  (CL:PROGN
   (CL:SETQ KWD-PRIMAL-PUBLIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC?" NULL 2))
   (CL:SETQ SYM-PRIMAL-STELLA-FLOOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOOR" NULL 0))
   (CL:SETQ KWD-PRIMAL-CPP (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
   (CL:SETQ KWD-PRIMAL-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-PRIMAL-STELLA-RANDOM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RANDOM" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-SQRT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SQRT" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-COS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COS" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-SIN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIN" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-TAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TAN" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-LOG
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOG" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-MIN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MIN" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-MAX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAX" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-STARTUP-PRIMAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-PRIMAL" NULL 0))
   (CL:SETQ SYM-PRIMAL-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-PRIMAL2 ()
  (CL:PROGN
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST UNKNOWN)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST OBJECT)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST SECOND-CLASS-OBJECT)) :NATIVE? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST NATIVE-VECTOR)) :NATIVE? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST STRING)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST MUTABLE-STRING)) :NATIVE? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST CHARACTER)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST CODE)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST INTEGER)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NULL? BOOLEAN) ((TEST FLOAT)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST UNKNOWN)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST OBJECT)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST SECOND-CLASS-OBJECT)) :NATIVE? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST NATIVE-VECTOR)) :NATIVE? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST STRING)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST MUTABLE-STRING)) :NATIVE? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST CHARACTER)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST CODE)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST INTEGER)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST FLOAT)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-FUNCTION-OBJECT ">"
    "(DEFUN (> BOOLEAN) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT ">="
    "(DEFUN (>= BOOLEAN) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-FUNCTION-OBJECT "<"
    "(DEFUN (< BOOLEAN) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "<="
    "(DEFUN (<= BOOLEAN) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL
    NULL)
   (DEFINE-FUNCTION-OBJECT "+"
    "(DEFUN (+ NUMBER) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "-"
    "(DEFUN (- NUMBER) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "*"
    "(DEFUN (* NUMBER) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "/"
    "(DEFUN (/ NUMBER) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "ZERO?"
    "(DEFUN (ZERO? BOOLEAN) ((X INTEGER)) :DOCUMENTATION \"Return true if `x' is 0.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:= X 0) :CPP \"(!x)\" :JAVA \"(x == 0)\")))"
    (CL:FUNCTION ZERO?) NULL)
   (DEFINE-FUNCTION-OBJECT "PLUS?"
    "(DEFUN (PLUS? BOOLEAN) ((X INTEGER)) :DOCUMENTATION \"Return true if `x' is greater than 0.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:> X 0) :CPP \"(x > 0)\" :JAVA \"(x > 0)\")))"
    (CL:FUNCTION PLUS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EVEN?"
    "(DEFUN (EVEN? BOOLEAN) ((X INTEGER)) :DOCUMENTATION \"Return true if `x' is an even number.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:NOT (CL:LOGBITP 0 X)) :CPP \"!(x % 2)\" :JAVA \"((x % 2) == 0)\")))"
    (CL:FUNCTION EVEN?) NULL)
   (DEFINE-FUNCTION-OBJECT "ODD?"
    "(DEFUN (ODD? BOOLEAN) ((X INTEGER)) :DOCUMENTATION \"Return true if `x' is an odd number.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGBITP 0 X) :CPP \"(x % 2)\" :JAVA \"((x % 2) == 1)\")))"
    (CL:FUNCTION ODD?) NULL)
   (DEFINE-FUNCTION-OBJECT "MOD"
    "(DEFUN (MOD INTEGER) ((X INTEGER) (MODULO INTEGER)) :DOCUMENTATION \"Return the result of `x' mod `modulo'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:MOD X MODULO) :CPP \"(x % modulo)\" :JAVA \"(x % modulo)\")))"
    (CL:FUNCTION MOD) NULL)
   (DEFINE-FUNCTION-OBJECT "CEILING"
    "(DEFUN (CEILING INTEGER) ((N NUMBER)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "FLOOR"
    "(DEFUN (FLOOR INTEGER) ((N NUMBER)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "EXP"
    "(DEFUN (EXP FLOAT) ((X FLOAT)) :PUBLIC? TRUE :NATIVE? TRUE :DOCUMENTATION \"The natural exponentiation function e^x.\")"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "RANDOM"
    "(DEFUN (RANDOM INTEGER) ((N INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Generate a random integer in the interval [0..n-1].
'n' must be <= 2^15.\")" (CL:FUNCTION RANDOM) NULL)
   (DEFINE-FUNCTION-OBJECT "SEED-RANDOM-NUMBER-GENERATOR"
    "(DEFUN SEED-RANDOM-NUMBER-GENERATOR () :PUBLIC? TRUE :DOCUMENTATION \"Seeds the random number generator with the current time\")"
    (CL:FUNCTION SEED-RANDOM-NUMBER-GENERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "SQRT"
    "(DEFUN (SQRT FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the square root of `n'.\" (RETURN (VERBATIM :COMMON-LISP (CL:SQRT N) :CPP \"sqrt(n)\" :JAVA \"Math.sqrt(n)\")))"
    (CL:FUNCTION SQRT) NULL)
   (DEFINE-FUNCTION-OBJECT "COS"
    "(DEFUN (COS FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the cosine of `n'.\" (RETURN (VERBATIM :COMMON-LISP (CL:COS N) :CPP \"cos(n)\" :JAVA \"Math.cos(n)\")))"
    (CL:FUNCTION COS) NULL)
   (DEFINE-FUNCTION-OBJECT "SIN"
    "(DEFUN (SIN FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the sine of `n'.\" (RETURN (VERBATIM :COMMON-LISP (CL:SIN N) :CPP \"sin(n)\" :JAVA \"Math.sin(n)\")))"
    (CL:FUNCTION SIN) NULL)
   (DEFINE-FUNCTION-OBJECT "TAN"
    "(DEFUN (TAN FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the tangent of `n'.\" (RETURN (VERBATIM :COMMON-LISP (CL:TAN N) :CPP \"tan(n)\" :JAVA \"Math.tan(n)\")))"
    (CL:FUNCTION TAN) NULL)
   (DEFINE-FUNCTION-OBJECT "LOG"
    "(DEFUN (LOG FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the natural logarithm (base e) of `n'.\" (RETURN (VERBATIM :COMMON-LISP (CL:LOG N) :CPP \"log(n)\" :JAVA \"Math.log(n)\")))"
    (CL:FUNCTION LOG) NULL)
   (DEFINE-FUNCTION-OBJECT "MIN"
    "(DEFUN (MIN INTEGER) ((X INTEGER) (Y INTEGER)) :DOCUMENTATION \"Return the minimum of `x' and `y'.  If either is NULL, return the other.\" :PUBLIC? TRUE)"
    (CL:FUNCTION MIN) NULL)
   (DEFINE-FUNCTION-OBJECT "MAX"
    "(DEFUN (MAX INTEGER) ((X INTEGER) (Y INTEGER)) :DOCUMENTATION \"Return the maximum of `x' and `y'.  If either is NULL, return the other.\" :PUBLIC? TRUE)"
    (CL:FUNCTION MAX) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ABS INTEGER) ((X INTEGER)) :DOCUMENTATION \"Return the absolute value of `x'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (CHOOSE (< X 0) (- 0 X) X)) :PUBLIC? TRUE)"
    (CL:FUNCTION ABS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ABS FLOAT) ((X FLOAT)) :DOCUMENTATION \"Return the absolute value of `x'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (CHOOSE (< X 0.0) (- 0.0 X) X)))"
    (CL:FUNCTION ABS) NULL)
   (DEFINE-FUNCTION-OBJECT "CHARACTER-CODE"
    "(DEFUN (CHARACTER-CODE INTEGER) ((CHARACTER CHARACTER)) :DOCUMENTATION \"Return the 8-bit ASCII code of 'character' as an integer.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:CHAR-CODE CHARACTER) :CPP \"(int)(unsigned char) character\" :JAVA \"(int) character\")))"
    (CL:FUNCTION CHARACTER-CODE) NULL)
   (DEFINE-FUNCTION-OBJECT "CODE-CHARACTER"
    "(DEFUN (CODE-CHARACTER CHARACTER) ((CODE INTEGER)) :DOCUMENTATION \"Return the character encoded by 'code' (0 <= 'code' <= 255).\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:CODE-CHAR CODE) :CPP \"(char) code\" :JAVA \"(char) code\")))"
    (CL:FUNCTION CODE-CHARACTER) NULL)
   (DEFINE-FUNCTION-OBJECT "CHARACTER-DOWNCASE"
    "(DEFUN (CHARACTER-DOWNCASE CHARACTER) ((C CHARACTER)) :DOCUMENTATION \"Return the lowercase character for 'c'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:CHAR-DOWNCASE C) :CPP \"(isupper(c) ? c + 'a' - 'A' : c)\" :JAVA \"Character.toLowerCase(c)\")))"
    (CL:FUNCTION CHARACTER-DOWNCASE) NULL)
   (DEFINE-FUNCTION-OBJECT "CHARACTER-UPCASE"
    "(DEFUN (CHARACTER-UPCASE CHARACTER) ((C CHARACTER)) :DOCUMENTATION \"Return the uppercase character for 'c'.  If only the first character of
a sequence of characters is to be capitalized, character-capitalize should be used.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:CHAR-UPCASE C) :CPP \"(islower(c) ? c + 'A' - 'a' : c)\" :JAVA \"Character.toUpperCase(c)\")))"
    (CL:FUNCTION CHARACTER-UPCASE) NULL)
   (DEFINE-FUNCTION-OBJECT "CHARACTER-CAPITALIZE"
    "(DEFUN (CHARACTER-CAPITALIZE CHARACTER) ((C CHARACTER)) :DOCUMENTATION \"Return the capitalized character for 'c'.  This is generally the same
as the uppercase character, except for obscure non-English characters in Java.  It should
be used if only the first character of a sequence of characters is to be capitalized.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:CHAR-UPCASE C) :CPP \"(islower(c) ? c + 'A' - 'a' : c)\" :JAVA \"Character.toTitleCase(c)\")))"
    (CL:FUNCTION CHARACTER-CAPITALIZE) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-EQL?"
    "(DEFUN (STRING-EQL? BOOLEAN) ((X STRING) (Y STRING)) :DOCUMENTATION \"Return true if `x' and `y' are equal strings including case or both null.\" :PUBLIC? TRUE)"
    (CL:FUNCTION STRING-EQL?) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-EQUAL?"
    "(DEFUN (STRING-EQUAL? BOOLEAN) ((X STRING) (Y STRING)) :DOCUMENTATION \"Return true if `x' and `y' are equal strings ignoring case or both null.\" :PUBLIC? TRUE)"
    (CL:FUNCTION STRING-EQUAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-COMPARE"
    "(DEFUN (STRING-COMPARE INTEGER) ((X STRING) (Y STRING) (CASE-SENSITIVE? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Compare 'x' and 'y' lexicographically, and return -1, 0, 
or 1, depending on whether 'x' is less than, equal, or greater than 'y'.
If 'case-sensitive?' is TRUE, then case does not matter for the comparison.\")"
    (CL:FUNCTION STRING-COMPARE) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING<"
    "(DEFUN (STRING< BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically < 'y'.\")"
    (CL:FUNCTION STRING<) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING<="
    "(DEFUN (STRING<= BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically <= 'y'.\")"
    (CL:FUNCTION STRING<=) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING>="
    "(DEFUN (STRING>= BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically >= 'y'.\")"
    (CL:FUNCTION STRING>=) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING>"
    "(DEFUN (STRING> BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically > 'y'.\")"
    (CL:FUNCTION STRING>) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-LESS?"
    "(DEFUN (STRING-LESS? BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically < 'y', ignoring case.\")"
    (CL:FUNCTION STRING-LESS?) NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-PRIMAL3 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "STRING-LESS-EQUAL?"
    "(DEFUN (STRING-LESS-EQUAL? BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically <= 'y', ignoring case.\")"
    (CL:FUNCTION STRING-LESS-EQUAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-GREATER-EQUAL?"
    "(DEFUN (STRING-GREATER-EQUAL? BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically >= 'y', ignoring case.\")"
    (CL:FUNCTION STRING-GREATER-EQUAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-GREATER?"
    "(DEFUN (STRING-GREATER? BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically > 'y', ignoring case.\")"
    (CL:FUNCTION STRING-GREATER?) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-STRING"
    "(DEFUN (MAKE-STRING STRING) ((SIZE INTEGER) (INITCHAR CHARACTER)) :DOCUMENTATION \"Return a new string filled with 'size' 'initchar's.\" :PUBLIC? TRUE :NATIVE? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-MUTABLE-STRING"
    "(DEFUN (MAKE-MUTABLE-STRING MUTABLE-STRING) ((SIZE INTEGER) (INITCHAR CHARACTER)) :DOCUMENTATION \"Return a new mutable string filled with 'size' 'initchar's.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:MAKE-STRING SIZE :INITIAL-ELEMENT INITCHAR) :CPP \"make_string(size, initchar)\" :JAVA \"#$(STELLAROOT).javalib.Native.make_mutable_string(size, initchar)\")))"
    (CL:FUNCTION MAKE-MUTABLE-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-RAW-MUTABLE-STRING"
    "(DEFUN (MAKE-RAW-MUTABLE-STRING MUTABLE-STRING) ((SIZE INTEGER)) :DOCUMENTATION \"Return a new uninitialized mutable string of `size'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (LET ((S MUTABLE-STRING NULL)) (VERBATIM :COMMON-LISP (SETQ S (CL:MAKE-STRING SIZE)) :CPP \"s = new (GC) char[size]\" :JAVA \"s = new StringBuffer(size); s.setLength(size)\") (RETURN S)))"
    (CL:FUNCTION MAKE-RAW-MUTABLE-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-CONCATENATE"
    "(DEFUN (STRING-CONCATENATE STRING) ((STRING1 STRING) (STRING2 STRING)) :DOCUMENTATION \"Return a new string representing the concatenation of
'string1' and 'string2'.\" :NATIVE? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONCATENATE STRING) ((STRING1 STRING) (STRING2 STRING) |&REST| (OTHERSTRINGS STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return a new string representing the concatenation
of `string1', `string2', and `otherStrings'.  The two mandatory parameters
allow us to optimize the common binary case by not relying on the somewhat
less efficient variable arguments mechanism.\")" (CL:FUNCTION CONCATENATE)
    NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-UPCASE"
    "(DEFUN (STRING-UPCASE STRING) ((STRING STRING)) :DOCUMENTATION \"Return an upper-case copy of 'string'.\" :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-DOWNCASE"
    "(DEFUN (STRING-DOWNCASE STRING) ((STRING STRING)) :DOCUMENTATION \"Return a lower-case copy of 'string'.\" :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-CAPITALIZE"
    "(DEFUN (STRING-CAPITALIZE STRING) ((STRING STRING)) :DOCUMENTATION \"Return a capitalized version of 'string'.\" :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY STRING) ((STRING STRING)) :DOCUMENTATION \"Return a copy of 'string'.\" :NATIVE? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBSTITUTE MUTABLE-STRING) ((SELF MUTABLE-STRING) (NEWCHAR CHARACTER) (OLDCHAR CHARACTER)) :DOCUMENTATION \"Substitute all occurences of 'oldChar' with 'newChar'
in the string 'self'.\" :NATIVE? TRUE :PUBLIC? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBSTITUTE STRING) ((SELF STRING) (NEWCHAR CHARACTER) (OLDCHAR CHARACTER)) :DOCUMENTATION \"Substitute all occurences of 'oldChar' with 'newChar'
in the string 'self'.\" :NATIVE? TRUE :PUBLIC? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "REPLACE-SUBSTRINGS"
    "(DEFUN (REPLACE-SUBSTRINGS STRING) ((STRING STRING) (NEW STRING) (OLD STRING)) :DOCUMENTATION \"Replace all occurrences of `old' in `string' with `new'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REPLACE-SUBSTRINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "INTEGER-TO-STRING"
    "(DEFUN (INTEGER-TO-STRING STRING) ((I INTEGER)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "FLOAT-TO-STRING"
    "(DEFUN (FLOAT-TO-STRING STRING) ((F FLOAT)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "CHARACTER-TO-STRING"
    "(DEFUN (CHARACTER-TO-STRING STRING) ((C CHARACTER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (MAKE-STRING 1 C)))"
    (CL:FUNCTION CHARACTER-TO-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "FORMAT-FLOAT"
    "(DEFUN (FORMAT-FLOAT STRING) ((F FLOAT) (NDECIMALS INTEGER)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-INTEGER"
    "(DEFUN (STRING-TO-INTEGER INTEGER) ((STRING STRING)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-FLOAT"
    "(DEFUN (STRING-TO-FLOAT FLOAT) ((STRING STRING)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF STRING) (CHAR CHARACTER)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH CHARACTER) ((SELF STRING) (POSITION INTEGER)) :DOCUMENTATION \"Return the character in `self' at `position'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)) :CPP \"self[position]\" :JAVA \"self.charAt(position)\")))"
    (CL:FUNCTION NTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH CHARACTER) ((SELF MUTABLE-STRING) (POSITION INTEGER)) :DOCUMENTATION \"Return the character in `self' at `position'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)) :CPP \"self[position]\" :JAVA \"self.charAt(position)\")))"
    (CL:FUNCTION NTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH-SETTER CHARACTER) ((SELF MUTABLE-STRING) (CH CHARACTER) (POSITION INTEGER)) :DOCUMENTATION \"Set the character in `self' at `position' to `ch'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (SETF (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)) (CL:THE CL:CHARACTER CH)) :CPP \"self[position] = ch\" :JAVA \"#$(STELLAROOT).javalib.Native.mutable_string_nth_setter(self, ch, position)\")))"
    (CL:FUNCTION NTH-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REST STRING) ((SELF STRING)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF STRING)) :DOCUMENTATION \"Return the length of the string `self'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LENGTH SELF) :CPP \"strlen(self)\" :JAVA \"self.length()\")))"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF MUTABLE-STRING)) :DOCUMENTATION \"Return the length of the string `self'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LENGTH SELF) :CPP \"strlen(self)\" :JAVA \"self.length()\")))"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (POSITION INTEGER) ((STRING STRING) (CHARACTER CHARACTER) (START INTEGER)) :DOCUMENTATION \"Return the position of 'character' within 'string' (counting
from zero); or return NULL if 'character' does not occur within 'string'.
If 'start' was supplied as non-NULL, only consider the substring starting
at 'start', however, the returned position will always be relative to the
entire string.\" :NATIVE? TRUE :PUBLIC? TRUE)" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-SEARCH"
    "(DEFUN (STRING-SEARCH INTEGER) ((STRING STRING) (SUBSTRING STRING) (START INTEGER)) :DOCUMENTATION \"Return start position of the left-most occurrence of
'substring' in 'string', beginning from 'start'.  Return NULL if it is not
a substring.\" :NATIVE? TRUE :PUBLIC? TRUE)" NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBSEQUENCE STRING) ((STRING STRING) (START INTEGER) (END INTEGER)) :DOCUMENTATION \"Return a substring of 'string' beginning at position 'start'
and ending up to but not including position 'end', counting from zero.  An
'end' value of NULL stands for the rest of the string.\" :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STRINGIFY"
    "(DEFUN (STRINGIFY STRING) ((EXPRESSION OBJECT)) :NATIVE? TRUE :PUBLIC? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "UNSTRINGIFY"
    "(DEFUN (UNSTRINGIFY OBJECT) ((STRING STRING)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (READ-S-EXPRESSION-FROM-STRING STRING)))"
    (CL:FUNCTION UNSTRINGIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD FREE-HASH-TABLE-VALUES ((SELF ABSTRACT-HASH-TABLE)) :DOCUMENTATION \"Call free on each value in the hash table 'self'.\")"
    (CL:FUNCTION FREE-HASH-TABLE-VALUES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF ABSTRACT-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into 'self'.\")"
    (CL:FUNCTION INITIALIZE-HASH-TABLE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REMOVE-AT ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :PUBLIC? TRUE)"
    (CL:FUNCTION REMOVE-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF INTEGER-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into 'self'.\")"
    (CL:FUNCTION INITIALIZE-HASH-TABLE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF INTEGER-HASH-TABLE) (KEY INTEGER)) :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF INTEGER-HASH-TABLE) (KEY INTEGER) (VALUE OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REMOVE-AT ((SELF INTEGER-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))))"
    (CL:FUNCTION REMOVE-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF FLOAT-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into 'self'.\")"
    (CL:FUNCTION INITIALIZE-HASH-TABLE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF FLOAT-HASH-TABLE) (KEY FLOAT)) :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF FLOAT-HASH-TABLE) (KEY FLOAT) (VALUE OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REMOVE-AT ((SELF FLOAT-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))))"
    (CL:FUNCTION REMOVE-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into 'self'.\")"
    (CL:FUNCTION INITIALIZE-HASH-TABLE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF STRING-HASH-TABLE) (KEY STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF STRING-HASH-TABLE) (KEY STRING) (VALUE OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REMOVE-AT ((SELF STRING-HASH-TABLE) (KEY STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION REMOVE-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-TO-INTEGER-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into 'self'.\")"
    (CL:FUNCTION INITIALIZE-HASH-TABLE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP INTEGER) ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING) (VALUE INTEGER)) :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REMOVE-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION REMOVE-AT) NULL)
   (DEFINE-FUNCTION-OBJECT "OBJECT-HASH-CODE"
    "(DEFUN (OBJECT-HASH-CODE INTEGER) ((SELF OBJECT)) :DOCUMENTATION \"Return a hash code for `self'.  Two objects that are `eq?'
are guaranteed to generate the same hash code.  Two objects that are not `eq?'
do not necessarily generate different hash codes.  Similar to `hash-code' but
always hashes on the address of `self' even if it is a wrapper.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP \"(STELLA::%%OBJECT-HASH-CODE SELF)\" :CPP \"(size_t)self\" :JAVA \"self.hashCode()\")))"
    (CL:FUNCTION OBJECT-HASH-CODE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (HASH-CODE INTEGER) ((SELF OBJECT)) :DOCUMENTATION \"Return a hash code for `self'.  Two objects that are `eql?'
are guaranteed to generate the same hash code.  Two objects that are not `eql?'
do not necessarily generate different hash codes.\" :PUBLIC? TRUE)"
    (CL:FUNCTION HASH-CODE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (HASH-CODE INTEGER) ((SELF STANDARD-OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (OBJECT-HASH-CODE SELF)))"
    (CL:FUNCTION HASH-CODE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (HASH-CODE INTEGER) ((SELF WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION HASH-CODE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (HASH-CODE INTEGER) ((SELF STRING-WRAPPER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (HASH-CODE (WRAPPER-VALUE SELF))))"
    (CL:FUNCTION HASH-CODE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (HASH-CODE INTEGER) ((SELF INTEGER-WRAPPER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (HASH-CODE (WRAPPER-VALUE SELF))))"
    (CL:FUNCTION HASH-CODE) NULL))
  :VOID)

(CL:DEFUN STARTUP-PRIMAL ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-PRIMAL1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *HASHTABLE-SIZE-PRIMES*
     (LIST (WRAP-INTEGER 29) (WRAP-INTEGER 53) (WRAP-INTEGER 97)
      (WRAP-INTEGER 193) (WRAP-INTEGER 389) (WRAP-INTEGER 769)
      (WRAP-INTEGER 1543) (WRAP-INTEGER 3079) (WRAP-INTEGER 6151)
      (WRAP-INTEGER 12289) (WRAP-INTEGER 24593) (WRAP-INTEGER 49157)
      (WRAP-INTEGER 98317) (WRAP-INTEGER 196613) (WRAP-INTEGER 393241)
      (WRAP-INTEGER 786433) (WRAP-INTEGER 1572869) (WRAP-INTEGER 3145739)
      (WRAP-INTEGER 6291469) (WRAP-INTEGER 12582917)
      (WRAP-INTEGER 25165843) (WRAP-INTEGER 50331653)
      (WRAP-INTEGER 100663319) (WRAP-INTEGER 201326611)
      (WRAP-INTEGER 402653189))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-PRIMAL2)
    (HELP-STARTUP-PRIMAL3)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (HASH-CODE INTEGER) ((SELF FLOAT-WRAPPER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (HASH-CODE (WRAPPER-VALUE SELF))))"
     (CL:FUNCTION HASH-CODE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (HASH-CODE INTEGER) ((SELF CHARACTER-WRAPPER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (HASH-CODE (WRAPPER-VALUE SELF))))"
     (CL:FUNCTION HASH-CODE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (HASH-CODE INTEGER) ((SELF BOOLEAN-WRAPPER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (CHOOSE (WRAPPER-VALUE SELF) 7936 7680)))"
     (CL:FUNCTION HASH-CODE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (HASH-CODE INTEGER) ((SELF STRING)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:SXHASH SELF) :CPP \"hashpjw(self)\" :JAVA \"self.hashCode()\")))"
     (CL:FUNCTION HASH-CODE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (HASH-CODE INTEGER) ((SELF INTEGER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN SELF))"
     (CL:FUNCTION HASH-CODE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (HASH-CODE INTEGER) ((SELF FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:SXHASH SELF) :CPP \"(size_t)self\" :JAVA \"new Float(self).hashCode()\")))"
     (CL:FUNCTION HASH-CODE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (HASH-CODE INTEGER) ((SELF CHARACTER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (CHARACTER-CODE SELF)))"
     (CL:FUNCTION HASH-CODE) NULL)
    (DEFINE-FUNCTION-OBJECT "HASH-STRING"
     "(DEFUN (HASH-STRING INTEGER) ((STRING STRING) (SEEDCODE INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Generate a hash-code for `string' and return it.
Two strings that are equal but not eq will generate the same code.
The hash-code is based on `seedCode' which usually will be 0.  However,
`seedCode' can also be used to supply the result of a previous hash
operation to achieve hashing on sequences of strings without actually
having to concatenate them.\" (RETURN (HASH-SUBSTRING STRING SEEDCODE 0 NULL)))"
     (CL:FUNCTION HASH-STRING) NULL)
    (DEFINE-FUNCTION-OBJECT "HASH-SUBSTRING"
     "(DEFUN (HASH-SUBSTRING INTEGER) ((STRING STRING) (CODE INTEGER) (START INTEGER) (END INTEGER)))"
     (CL:FUNCTION HASH-SUBSTRING) NULL)
    (DEFINE-FUNCTION-OBJECT "PICK-HASHTABLE-SIZE-PRIME"
     "(DEFUN (PICK-HASHTABLE-SIZE-PRIME INTEGER) ((MINSIZE INTEGER)) :DOCUMENTATION \"Return a hashtable prime of at least `minSize'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION PICK-HASHTABLE-SIZE-PRIME) NULL)
    (DEFINE-METHOD-OBJECT "(DEFMETHOD INITIALIZE-VECTOR ((SELF VECTOR)))"
     (CL:FUNCTION INITIALIZE-VECTOR) NULL)
    (DEFINE-FUNCTION-OBJECT "RESIZE-VECTOR"
     "(DEFUN RESIZE-VECTOR ((SELF VECTOR) (SIZE INTEGER)) :DOCUMENTATION \"Change the size of `self' to `size'.  If `size' is smaller
than the current size of `self' the vector will be truncated.  Otherwise, 
the internal array of `self' will be grown to `size' and unused elements
will be initialized to NULL.\" :PUBLIC? TRUE)" (CL:FUNCTION RESIZE-VECTOR)
     NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ((SELF NATIVE-VECTOR) (POSITION INTEGER)) :DOCUMENTATION \"Return the element in `self' at `position'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:AREF SELF POSITION) :CPP \"self[position]\" :JAVA \"self[position]\")))"
     (CL:FUNCTION NTH) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF NATIVE-VECTOR) (VALUE (LIKE (ANY-VALUE SELF))) (POSITION INTEGER)) :DOCUMENTATION \"Set the element in `self' at `position' to `value'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:SETF (CL:AREF SELF POSITION) VALUE) :CPP \"self[position] = value\" :JAVA \"self[position] = value\")))"
     (CL:FUNCTION NTH-SETTER) NULL)
    (DEFINE-FUNCTION-OBJECT "UNMAKE" "(DEFUN UNMAKE ((SELF OBJECT)))"
     (CL:FUNCTION UNMAKE) NULL)
    (DEFINE-FUNCTION-OBJECT "PROBE-FILE?"
     "(DEFUN (PROBE-FILE? BOOLEAN) ((FILENAME FILE-NAME)) :NATIVE? TRUE :PUBLIC? TRUE)"
     NULL NULL)
    (DEFINE-FUNCTION-OBJECT "FILE-WRITE-DATE"
     "(DEFUN (FILE-WRITE-DATE INTEGER) ((FILENAME FILE-NAME)) :NATIVE? TRUE :PUBLIC? TRUE)"
     NULL NULL)
    (DEFINE-FUNCTION-OBJECT "FILE-LENGTH"
     "(DEFUN (FILE-LENGTH INTEGER) ((FILENAME FILE-NAME)) :NATIVE? TRUE :PUBLIC? TRUE)"
     NULL NULL)
    (DEFINE-FUNCTION-OBJECT "DELETE-FILE"
     "(DEFUN DELETE-FILE ((FILENAME FILE-NAME)) :NATIVE? TRUE :PUBLIC? TRUE)"
     NULL NULL)
    (DEFINE-FUNCTION-OBJECT "LOGNOT"
     "(DEFUN (LOGNOT INTEGER) ((ARG INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGNOT ARG) :CPP \"(~ arg)\" :JAVA \"(~ arg)\")))"
     (CL:FUNCTION LOGNOT) NULL)
    (DEFINE-FUNCTION-OBJECT "LOGAND"
     "(DEFUN (LOGAND INTEGER) ((ARG1 INTEGER) (ARG2 INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGAND ARG1 ARG2) :CPP \"(arg1 & arg2)\" :JAVA \"(arg1 & arg2)\")))"
     (CL:FUNCTION LOGAND) NULL)
    (DEFINE-FUNCTION-OBJECT "LOGOR"
     "(DEFUN (LOGOR INTEGER) ((ARG1 INTEGER) (ARG2 INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGIOR ARG1 ARG2) :CPP \"(arg1 | arg2)\" :JAVA \"(arg1 | arg2)\")))"
     (CL:FUNCTION LOGOR) NULL)
    (DEFINE-FUNCTION-OBJECT "LOGXOR"
     "(DEFUN (LOGXOR INTEGER) ((ARG1 INTEGER) (ARG2 INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGXOR ARG1 ARG2) :CPP \"(arg1 ^ arg2)\" :JAVA \"(arg1 ^ arg2)\")))"
     (CL:FUNCTION LOGXOR) NULL)
    (DEFINE-FUNCTION-OBJECT "INTEGER-LENGTH"
     "(DEFUN (INTEGER-LENGTH INTEGER) ((ARG INTEGER)) :NATIVE? TRUE :PUBLIC? TRUE)"
     NULL NULL)
    (DEFINE-FUNCTION-OBJECT "SHIFT-LEFT"
     "(DEFUN (SHIFT-LEFT INTEGER) ((ARG INTEGER) (COUNT INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:ASH ARG COUNT) :CPP \"(arg << count)\" :JAVA \"(arg << count)\")))"
     (CL:FUNCTION SHIFT-LEFT) NULL)
    (DEFINE-FUNCTION-OBJECT "SHIFT-RIGHT"
     "(DEFUN (SHIFT-RIGHT INTEGER) ((ARG INTEGER) (COUNT INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))) :CPP \"(arg >> count)\" :JAVA \"(arg >> count)\")))"
     (CL:FUNCTION SHIFT-RIGHT) NULL)
    (DEFINE-FUNCTION-OBJECT "STELLIFY"
     "(DEFUN (STELLIFY OBJECT) ((SELF OBJECT)) :DOCUMENTATION \"Convert a Lisp object into a STELLA object.\" :PUBLIC? TRUE)"
     (CL:FUNCTION STELLIFY) NULL)
    (DEFINE-FUNCTION-OBJECT "STELLA-OBJECT?"
     "(DEFUN (STELLA-OBJECT? BOOLEAN) ((SELF OBJECT)) :DOCUMENTATION \"Return TRUE if 'self' is a member of the STELLA class 'OBJECT'.\")"
     (CL:FUNCTION STELLA-OBJECT?) NULL)
    (DEFINE-FUNCTION-OBJECT "RUNNING-AS-LISP?"
     "(DEFUN (RUNNING-AS-LISP? BOOLEAN) () :DOCUMENTATION \"Return TRUE if the executable code is a Common Lisp application.\")"
     (CL:FUNCTION RUNNING-AS-LISP?) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-TICKTOCK"
     "(DEFUN (GET-TICKTOCK TICKTOCK) () :PUBLIC? TRUE :NATIVE? TRUE)" NULL
     NULL)
    (DEFINE-FUNCTION-OBJECT "TICKTOCK-DIFFERENCE"
     "(DEFUN (TICKTOCK-DIFFERENCE FLOAT) ((T1 TICKTOCK) (T2 TICKTOCK)) :DOCUMENTATION \"The difference in two TICKTOCK time values in seconds where
`t1' is the earlier time.  The resolution is implementation dependent but will
normally be some fractional value of a second.\" :PUBLIC? TRUE :NATIVE? TRUE)"
     NULL NULL)
    (DEFINE-FUNCTION-OBJECT "TICKTOCK-RESOLUTION"
     "(DEFUN (TICKTOCK-RESOLUTION FLOAT) () :DOCUMENTATION \"The minimum theoretically detectable resolution of the
difference in two TICKTOCK time values in seconds.  This
resolution is implementation dependent.  It may also not
be realizable in practice, since the timing grain size may
be larger than this resolution.\" :PUBLIC? TRUE :NATIVE? TRUE)" NULL NULL)
    (DEFINE-FUNCTION-OBJECT "EXCEPTION-MESSAGE"
     "(DEFUN (EXCEPTION-MESSAGE STRING) ((E STELLA-ROOT-EXCEPTION)) :PUBLIC? TRUE :DOCUMENTATION \"Accesses the error message from the Exception\")"
     (CL:FUNCTION EXCEPTION-MESSAGE) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-EXCEPTION-CONTEXT"
     "(DEFUN PRINT-EXCEPTION-CONTEXT ((E NATIVE-EXCEPTION) (STREAM OUTPUT-STREAM)) :PUBLIC? TRUE :DOCUMENTATION \"Prints a system dependent information about the context of the specified
exception.  For example, in Java it prints a stack trace.  In Lisp, it is vendor dependent.\")"
     (CL:FUNCTION PRINT-EXCEPTION-CONTEXT) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-PRIMAL"
     "(DEFUN STARTUP-PRIMAL () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-PRIMAL) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-PRIMAL-STELLA-STARTUP-PRIMAL)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-PRIMAL-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "Startup-Primal") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT TRUE BOOLEAN (VERBATIM :COMMON-LISP CL:T :CPP \"1\" :JAVA \"true\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT FALSE BOOLEAN (VERBATIM :COMMON-LISP CL:NIL :CPP \"0\" :JAVA \"false\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT PI FLOAT (VERBATIM :COMMON-LISP \"(cl:float CL:PI 0.0d0)\" :CPP \"3.141592653589793\" :JAVA \"java.lang.Math.PI\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(defconstant NULL UNKNOWN NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-INTEGER INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"1 << (sizeof (int) / sizeof (char) * 8 - 1)\" :JAVA \"Integer.MIN_VALUE\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-SHORT-INTEGER SHORT-INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"1 << (sizeof (short int) / sizeof (char) * 8 - 1)\" :JAVA \"Short.MIN_VALUE\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-LONG-INTEGER LONG-INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"1 << (sizeof (long int) / sizeof (char) * 8 - 1)\" :JAVA \"Long.MIN_VALUE\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-UNSIGNED-SHORT-INTEGER UNSIGNED-SHORT-INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"(unsigned short int) -1\" :JAVA \"Short.MIN_VALUE\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-UNSIGNED-LONG-INTEGER UNSIGNED-LONG-INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"(unsigned long int) -1\" :JAVA \"Long.MIN_VALUE\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-FLOAT FLOAT (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-DOUBLE-FLOAT :CPP \"-HUGE_VAL /* IEEE infinity, defined in <math.h> */\" :JAVA \"Double.NEGATIVE_INFINITY; /* IEEE Infinity */\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-SINGLE-FLOAT SINGLE-FLOAT (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-SINGLE-FLOAT :CPP \"-HUGE_VAL /* IEEE infinity, defined in <math.h> */\" :JAVA \"Float.NEGATIVE_INFINITY; /* IEEE Infinity */\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-DOUBLE-FLOAT DOUBLE-FLOAT (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-DOUBLE-FLOAT :CPP \"-HUGE_VAL /* IEEE infinity, defined in <math.h> */\" :JAVA \"Double.NEGATIVE_INFINITY; /* IEEE Infinity */\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-CHARACTER CHARACTER (VERBATIM :COMMON-LISP (CL:CODE-CHAR 0) :CPP \"'\\\\0'\" :JAVA \"Character.MIN_VALUE\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-BYTE BYTE (VERBATIM :COMMON-LISP \"255\" :CPP \"255\" :JAVA \"-128\") :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-OCTET OCTET (VERBATIM :COMMON-LISP \"255\" :CPP \"255\" :JAVA \"-128\") :PUBLIC? TRUE)")
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-FLOOR KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-RANDOM KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-SQRT KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-COS KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-SIN KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-TAN KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-LOG KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-MIN KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PRIMAL-STELLA-MAX KWD-PRIMAL-CPP
     KWD-PRIMAL-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TRANSIENTOBJECTS?* BOOLEAN FALSE :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *HASHTABLE-SIZE-PRIMES* (LIST OF INTEGER-WRAPPER) (LIST 29 53 97 193 389 769 1543 3079 6151 12289 24593 49157 98317 196613 393241 786433 1572869 3145739 6291469 12582917 25165843 50331653 100663319 201326611 402653189) :DOCUMENTATION \"List of prime numbers approximately growing by a factor of 2
that are suitable to be used as hashtable sizes.\" :PUBLIC? TRUE)")))
  :VOID)
