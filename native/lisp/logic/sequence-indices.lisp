;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997-2000              | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-SEQUENCE-INDICES-LOGIC-THE-SEQUENCE NULL)
(CL:DEFVAR SGT-SEQUENCE-INDICES-LOGIC-NON-PAGING-INDEX NULL)
(CL:DEFVAR SGT-SEQUENCE-INDICES-LOGIC-PAGING-INDEX NULL)
(CL:DEFVAR SYM-SEQUENCE-INDICES-LOGIC-THE-REGENERABLE-SEQUENCE NULL)
(CL:DEFVAR SYM-SEQUENCE-INDICES-STELLA-NEXT NULL)
(CL:DEFVAR SYM-SEQUENCE-INDICES-LOGIC-PREVIOUS NULL)
(CL:DEFVAR SYM-SEQUENCE-INDICES-STELLA-SEQUENCE-LENGTH NULL)
(CL:DEFVAR SYM-SEQUENCE-INDICES-LOGIC-REGENERATION-SCHEME NULL)
(CL:DEFVAR SGT-SEQUENCE-INDICES-STELLA-MODULE NULL)
(CL:DEFVAR KWD-SEQUENCE-INDICES-PAGING NULL)
(CL:DEFVAR KWD-SEQUENCE-INDICES-NON-PAGING NULL)
(CL:DEFVAR SYM-SEQUENCE-INDICES-LOGIC-USE-NON-PAGING-INDICES? NULL)
(CL:DEFVAR SGT-SEQUENCE-INDICES-LOGIC-SEQUENCE-INDEX-ITERATOR NULL)
(CL:DEFVAR SYM-SEQUENCE-INDICES-STELLA-LIST-ITERATOR-CURSOR NULL)
(CL:DEFVAR KWD-SEQUENCE-INDICES-CABOOSE NULL)
(CL:DEFVAR SGT-SEQUENCE-INDICES-LOGIC-PAGING-INDEX-ITERATOR NULL)
(CL:DEFVAR SYM-SEQUENCE-INDICES-LOGIC-THE-PAGING-INDEX NULL)
(CL:DEFVAR SYM-SEQUENCE-INDICES-LOGIC-SWITCHED-TO-REGENERABLE-SEQUENCE? NULL)
(CL:DEFVAR SGT-SEQUENCE-INDICES-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SYM-SEQUENCE-INDICES-LOGIC-?? NULL)
(CL:DEFVAR SYM-SEQUENCE-INDICES-LOGIC-REGENERABLE-FROM-SECONDARY-STORAGE? NULL)
(CL:DEFVAR SYM-SEQUENCE-INDICES-LOGIC-STARTUP-SEQUENCE-INDICES NULL)
(CL:DEFVAR SYM-SEQUENCE-INDICES-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* EOL TRUE-WRAPPER FALSE-WRAPPER
  STANDARD-OUTPUT))

;;; (DEFCLASS SEQUENCE-INDEX ...)

(CL:DEFCLASS SEQUENCE-INDEX (STANDARD-OBJECT)
  ((THE-SEQUENCE :ALLOCATION :INSTANCE :ACCESSOR %THE-SEQUENCE))
  (:DOCUMENTATION "Abstract class for managing a sequence of objects."))

(CL:DEFUN ACCESS-SEQUENCE-INDEX-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SEQUENCE-INDICES-LOGIC-THE-SEQUENCE)
    (CL:IF SETVALUE? (CL:SETF (%THE-SEQUENCE SELF) VALUE)
     (CL:SETQ VALUE (%THE-SEQUENCE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF SEQUENCE-INDEX) STREAM)
  (PRINT-SEQUENCE-INDEX SELF STREAM))

;;; (DEFCLASS NON-PAGING-INDEX ...)

(CL:DEFCLASS NON-PAGING-INDEX (SEQUENCE-INDEX)
  ()
  (:DOCUMENTATION "Index that manages an always-in-memory data
strucure containing a sequence of objects."))

(CL:DEFUN NEW-NON-PAGING-INDEX ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE NON-PAGING-INDEX)))
   (CL:SETF (%THE-SEQUENCE SELF) NIL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF NON-PAGING-INDEX))
  SGT-SEQUENCE-INDICES-LOGIC-NON-PAGING-INDEX)

;;; (DEFCLASS PAGING-INDEX ...)

(CL:DEFCLASS PAGING-INDEX (SEQUENCE-INDEX)
  ((THE-REGENERABLE-SEQUENCE :ALLOCATION :INSTANCE :ACCESSOR
    %THE-REGENERABLE-SEQUENCE)
   (NEXT :ALLOCATION :INSTANCE :ACCESSOR %NEXT)
   (PREVIOUS :ALLOCATION :INSTANCE :ACCESSOR %PREVIOUS)
   (SEQUENCE-LENGTH :ALLOCATION :INSTANCE :ACCESSOR %SEQUENCE-LENGTH)
   (REGENERATION-SCHEME :ALLOCATION :INSTANCE :ACCESSOR
    %REGENERATION-SCHEME))
  (:DOCUMENTATION "Index that manages a sequence of objects
retrievable from persistent storage."))

(CL:DEFUN NEW-PAGING-INDEX ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PAGING-INDEX)))
   (CL:SETF (%THE-SEQUENCE SELF) NIL)
   (CL:SETF (%REGENERATION-SCHEME SELF) NULL)
   (CL:SETF (%SEQUENCE-LENGTH SELF) 0) (CL:SETF (%PREVIOUS SELF) NULL)
   (CL:SETF (%NEXT SELF) NULL)
   (CL:SETF (%THE-REGENERABLE-SEQUENCE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PAGING-INDEX))
  SGT-SEQUENCE-INDICES-LOGIC-PAGING-INDEX)

(CL:DEFUN ACCESS-PAGING-INDEX-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SEQUENCE-INDICES-LOGIC-THE-REGENERABLE-SEQUENCE)
    (CL:IF SETVALUE? (CL:SETF (%THE-REGENERABLE-SEQUENCE SELF) VALUE)
     (CL:SETQ VALUE (%THE-REGENERABLE-SEQUENCE SELF))))
   ((CL:EQ SLOTNAME SYM-SEQUENCE-INDICES-STELLA-NEXT)
    (CL:IF SETVALUE? (CL:SETF (%NEXT SELF) VALUE)
     (CL:SETQ VALUE (%NEXT SELF))))
   ((CL:EQ SLOTNAME SYM-SEQUENCE-INDICES-LOGIC-PREVIOUS)
    (CL:IF SETVALUE? (CL:SETF (%PREVIOUS SELF) VALUE)
     (CL:SETQ VALUE (%PREVIOUS SELF))))
   ((CL:EQ SLOTNAME SYM-SEQUENCE-INDICES-STELLA-SEQUENCE-LENGTH)
    (CL:IF SETVALUE?
     (CL:SETF (%SEQUENCE-LENGTH SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%SEQUENCE-LENGTH SELF)))))
   ((CL:EQ SLOTNAME SYM-SEQUENCE-INDICES-LOGIC-REGENERATION-SCHEME)
    (CL:IF SETVALUE? (CL:SETF (%REGENERATION-SCHEME SELF) VALUE)
     (CL:SETQ VALUE (%REGENERATION-SCHEME SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFCONSTANT NIL-NON-PAGING-INDEX ...)

(CL:DEFVAR NIL-NON-PAGING-INDEX NULL
  "Returns a non-writable empty sequence.")

;;; (DEFCONSTANT NIL-PAGING-INDEX ...)

(CL:DEFVAR NIL-PAGING-INDEX NULL
  "Returns a non-writable empty sequence.")

;;; (DEFSPECIAL *LOADINGREGENERABLEOBJECTS?* ...)

(CL:DEFVAR *LOADINGREGENERABLEOBJECTS?* FALSE
  "If TRUE, objects being created are regenerable,
and should not be indexed using the backlinks procedures.")

;;; (DEFUN (CREATE-SEQUENCE-INDEX SEQUENCE-INDEX) ...)

(CL:DEFUN CREATE-SEQUENCE-INDEX (SELF REGENERATIONSCHEME)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN (KEYWORD.CREATE-SEQUENCE-INDEX SELF REGENERATIONSCHEME)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SEQUENCE-INDICES-STELLA-MODULE)
     (CL:PROGN (MODULE.CREATE-SEQUENCE-INDEX SELF REGENERATIONSCHEME)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (KEYWORD.CREATE-SEQUENCE-INDEX SEQUENCE-INDEX) ...)

(CL:DEFUN KEYWORD.CREATE-SEQUENCE-INDEX (KIND REGENERATIONSCHEME)
  (CL:COND
   ((CL:EQ KIND KWD-SEQUENCE-INDICES-PAGING)
    (CL:LET* ((INDEX (NEW-PAGING-INDEX)))
     (CL:SETF (%REGENERATION-SCHEME INDEX) REGENERATIONSCHEME)
     (CL:WHEN (CL:EQ (%%VALUE (%%REST REGENERATIONSCHEME)) NULL)
      (CL:ERROR
       "Safety violation: Null argument passed into paging index regeneration scheme"))
     (CL:WHEN (TRACE-KEYWORD? KWD-SEQUENCE-INDICES-PAGING)
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "CREATE-SEQ-INDEX  kind: " KIND " ")
      (PRINT-PAGING-INDEX INDEX))
     INDEX))
   ((CL:EQ KIND KWD-SEQUENCE-INDICES-NON-PAGING) (NEW-NON-PAGING-INDEX))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KIND
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (MODULE.CREATE-SEQUENCE-INDEX SEQUENCE-INDEX) ...)

(CL:DEFUN MODULE.CREATE-SEQUENCE-INDEX (MODULE REGENERATIONSCHEME)
  (CREATE-SEQUENCE-INDEX
   (CL:IF
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS MODULE)
      SYM-SEQUENCE-INDICES-LOGIC-USE-NON-PAGING-INDICES? FALSE-WRAPPER))
    KWD-SEQUENCE-INDICES-NON-PAGING KWD-SEQUENCE-INDICES-PAGING)
   REGENERATIONSCHEME))

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF SEQUENCE-INDEX) VALUE)
  (CL:WHEN (CL:EQ SELF NIL-NON-PAGING-INDEX)
   (CL:ERROR
    "Safety violation: Attempt to insert into NIL-NON-PAGING-INDEX"))
  (CL:SETF (%THE-SEQUENCE SELF) (CONS VALUE (%THE-SEQUENCE SELF))))

;;; (DEFMETHOD PUSH ...)

(CL:DEFMETHOD PUSH ((SELF SEQUENCE-INDEX) VALUE)
  (INSERT SELF VALUE))

;;; (DEFMETHOD (FIRST OBJECT) ...)

(CL:DEFMETHOD FIRST ((SELF SEQUENCE-INDEX))
  (CL:LET* ((ITEM NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ ITEM (%VALUE ITER-000))
    (CL:RETURN-FROM FIRST ITEM)))
  NULL)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF SEQUENCE-INDEX))
  (CL:LET* ((ITEM NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ ITEM (%VALUE ITER-000))
    (CL:RETURN-FROM EMPTY? FALSE)))
  TRUE)

;;; (DEFMETHOD (ESTIMATED-LENGTH INTEGER) ...)

(CL:DEFMETHOD ESTIMATED-LENGTH ((SELF SEQUENCE-INDEX))
  (LENGTH (%THE-SEQUENCE SELF)))

;;; (DEFMETHOD (REMOVE-DELETED-MEMBERS (LIKE SELF)) ...)

(CL:DEFMETHOD REMOVE-DELETED-MEMBERS ((SELF SEQUENCE-INDEX))
  (CL:SETF (%THE-SEQUENCE SELF)
   (REMOVE-DELETED-MEMBERS (%THE-SEQUENCE SELF)))
  SELF)

;;; (DEFMETHOD (CONSIFY (CONS OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD CONSIFY ((SELF SEQUENCE-INDEX))
  (CL:LET* ((V-002 NIL))
   (CL:LET*
    ((I NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ I (%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS I NIL))
       (CL:IF (CL:EQ V-002 NIL) (CL:SETQ V-002 COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST V-002 COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS I NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:LET* ((VALUE-000 V-002)) VALUE-000)))

;;; (DEFCLASS SEQUENCE-INDEX-ITERATOR ...)

(CL:DEFCLASS SEQUENCE-INDEX-ITERATOR (ITERATOR)
  ((LIST-ITERATOR-CURSOR :ALLOCATION :INSTANCE :ACCESSOR
    %LIST-ITERATOR-CURSOR))
  (:DOCUMENTATION
   "An iterator that generates successive members of a sequence index."))

(CL:DEFUN NEW-SEQUENCE-INDEX-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SEQUENCE-INDEX-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) TRUE) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%LIST-ITERATOR-CURSOR SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SEQUENCE-INDEX-ITERATOR))
  SGT-SEQUENCE-INDICES-LOGIC-SEQUENCE-INDEX-ITERATOR)

(CL:DEFUN ACCESS-SEQUENCE-INDEX-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SEQUENCE-INDICES-STELLA-LIST-ITERATOR-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%LIST-ITERATOR-CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%LIST-ITERATOR-CURSOR SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF SEQUENCE-INDEX))
  (CL:LET* ((ITERATOR (NEW-SEQUENCE-INDEX-ITERATOR)))
   (CL:SETF (%LIST-ITERATOR-CURSOR ITERATOR) (%THE-SEQUENCE SELF))
   ITERATOR))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF SEQUENCE-INDEX-ITERATOR))
  (CL:LET* ((CURSOR (%LIST-ITERATOR-CURSOR SELF)) (VALUE NULL))
   (CL:LOOP (CL:WHEN (CL:EQ CURSOR NIL) (CL:RETURN-FROM NEXT? FALSE))
    (CL:SETQ VALUE (%%VALUE CURSOR))
    (CL:WHEN (CL:NOT (DELETED? VALUE)) (CL:SETF (%VALUE SELF) VALUE)
     (CL:SETF (%LIST-ITERATOR-CURSOR SELF) (%%REST CURSOR))
     (CL:RETURN-FROM NEXT? TRUE))
    (CL:SETQ CURSOR (%%REST CURSOR)))))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF SEQUENCE-INDEX-ITERATOR))
  (CL:EQ (%LIST-ITERATOR-CURSOR SELF) NIL))

;;; (DEFUN PRINT-SEQUENCE-INDEX ...)

(CL:DEFUN PRINT-SEQUENCE-INDEX (SELF STREAM)
  (CL:LET*
   ((PREFIX
     (CL:IF (ISA? SELF SGT-SEQUENCE-INDICES-LOGIC-PAGING-INDEX)
      "|PAGING-IDX|" "|SEQ-IDX|"))
    (LIMIT
     (CL:IF (ISA? SELF SGT-SEQUENCE-INDICES-LOGIC-PAGING-INDEX) 3 9))
    (PAGEDOUT?
     (CL:AND (ISA? SELF SGT-SEQUENCE-INDICES-LOGIC-PAGING-INDEX)
      (CL:EQ (%THE-REGENERABLE-SEQUENCE SELF) NULL))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PREFIX)
    (CL:TYPE CL:FIXNUM LIMIT))
   (CL:COND
    (PAGEDOUT?
     (%%PRINT-STREAM STREAM "|PAGED-OUT-IDX|"
      (%REGENERATION-SCHEME SELF)))
    ((ISA? SELF SGT-SEQUENCE-INDICES-LOGIC-PAGING-INDEX)
     (%%PRINT-STREAM STREAM "|PAGING-IDX|" (%REGENERATION-SCHEME SELF)))
    (CL:T
     (CL:LET* ((ITERATOR (ALLOCATE-ITERATOR SELF)))
      (CL:IF (NEXT? ITERATOR)
       (%%PRINT-STREAM STREAM PREFIX "(" (%VALUE ITERATOR))
       (CL:PROGN (%%PRINT-STREAM STREAM PREFIX "()")
        (CL:RETURN-FROM PRINT-SEQUENCE-INDEX)))
      (CL:LET*
       ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 LIMIT)
        (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
       (CL:LOOP WHILE
        (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
        (CL:PROGN (CL:SETQ I ITER-000)
         (CL:SETQ ITER-000 (CL:1+ ITER-000)))
        (CL:COND ((CL:NOT (NEXT? ITERATOR)) (CL:RETURN))
         ((CL:>= I LIMIT) (%%PRINT-STREAM STREAM "...") (CL:RETURN))
         (CL:T (%%PRINT-STREAM STREAM " " (%VALUE ITERATOR))))))
      (%%PRINT-STREAM STREAM ")"))))))

;;; (DEFMETHOD (COPY NON-PAGING-INDEX) ...)

(CL:DEFMETHOD COPY ((SELF NON-PAGING-INDEX))
  (CL:LET* ((SELF-000 (NEW-NON-PAGING-INDEX)))
   (CL:SETF (%THE-SEQUENCE SELF-000)
    (COPY-CONS-LIST (%THE-SEQUENCE SELF)))
   (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF NON-PAGING-INDEX))
  (CL:SETF (%THE-SEQUENCE SELF) NIL))

;;; (DEFMETHOD (REMOVE NON-PAGING-INDEX) ...)

(CL:DEFMETHOD REMOVE ((SELF NON-PAGING-INDEX) VALUE)
  (CL:SETF (%THE-SEQUENCE SELF) (REMOVE (%THE-SEQUENCE SELF) VALUE))
  SELF)

;;; (DEFCONSTANT CABOOSE-INDEX ...)

(CL:DEFVAR CABOOSE-INDEX NULL
  "The caboose index is always the last one on the
list.  It exists so we don't need to check for a null list
during relinking, i.e., the code is a tiny bit faster.")

;;; (DEFGLOBAL *FRONT-OF-PAGING-INDEX-LRU-LIST* ...)

(CL:DEFVAR *FRONT-OF-PAGING-INDEX-LRU-LIST* NULL
  "Points to first index in doubly-linked list of in-memory
paging indices. The most recently used are at the front of the list.")

;;; (DEFUN UNLINK-PAGING-INDEX ...)

(CL:DEFUN UNLINK-PAGING-INDEX (INDEX)
  (CL:LET* ((PREVIOUSINDEX (%PREVIOUS INDEX)) (NEXTINDEX (%NEXT INDEX)))
   (CL:IF (CL:NOT (CL:EQ PREVIOUSINDEX NULL))
    (CL:SETF (%NEXT PREVIOUSINDEX) NEXTINDEX)
    (CL:SETQ *FRONT-OF-PAGING-INDEX-LRU-LIST* NEXTINDEX))
   (CL:SETF (%PREVIOUS NEXTINDEX) PREVIOUSINDEX)
   (CL:SETF (%NEXT INDEX) NULL)))

;;; (DEFUN LINK-PAGING-INDEX-TO-FRONT ...)

(CL:DEFUN LINK-PAGING-INDEX-TO-FRONT (INDEX)
  (CL:LET* ((OLDFIRSTINDEX *FRONT-OF-PAGING-INDEX-LRU-LIST*))
   (CL:SETF (%NEXT INDEX) OLDFIRSTINDEX)
   (CL:SETF (%PREVIOUS OLDFIRSTINDEX) INDEX)
   (CL:SETF (%PREVIOUS INDEX) NULL)
   (CL:SETQ *FRONT-OF-PAGING-INDEX-LRU-LIST* INDEX)))

;;; (DEFGLOBAL *DISABLELRUINDEXING?* ...)

(CL:DEFVAR *DISABLELRUINDEXING?* FALSE
  "Don't mess with the order of paging indices.
Used for debugging, and also to test whether the overhead
of relinking is noticable when we time things.")

;;; (DEFUN MOVE-PAGING-INDEX-TO-FRONT ...)

(CL:DEFUN MOVE-PAGING-INDEX-TO-FRONT (INDEX)
  (CL:WHEN *DISABLELRUINDEXING?*
   (CL:RETURN-FROM MOVE-PAGING-INDEX-TO-FRONT))
  (CL:WHEN (CL:NOT (CL:EQ (%NEXT INDEX) NULL)) (UNLINK-PAGING-INDEX INDEX))
  (LINK-PAGING-INDEX-TO-FRONT INDEX))

;;; (DEFCLASS PAGING-INDEX-ITERATOR ...)

(CL:DEFCLASS PAGING-INDEX-ITERATOR (ITERATOR)
  ((THE-PAGING-INDEX :ALLOCATION :INSTANCE :ACCESSOR %THE-PAGING-INDEX)
   (LIST-ITERATOR-CURSOR :ALLOCATION :INSTANCE :ACCESSOR
    %LIST-ITERATOR-CURSOR)
   (SWITCHED-TO-REGENERABLE-SEQUENCE? :ALLOCATION :INSTANCE :ACCESSOR
    %SWITCHED-TO-REGENERABLE-SEQUENCE?))
  (:DOCUMENTATION
   "An iterator that generates successive members of a sequence index."))

(CL:DEFUN NEW-PAGING-INDEX-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PAGING-INDEX-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) TRUE) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%SWITCHED-TO-REGENERABLE-SEQUENCE? SELF) FALSE)
   (CL:SETF (%LIST-ITERATOR-CURSOR SELF) NULL)
   (CL:SETF (%THE-PAGING-INDEX SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PAGING-INDEX-ITERATOR))
  SGT-SEQUENCE-INDICES-LOGIC-PAGING-INDEX-ITERATOR)

(CL:DEFUN ACCESS-PAGING-INDEX-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SEQUENCE-INDICES-LOGIC-THE-PAGING-INDEX)
    (CL:IF SETVALUE? (CL:SETF (%THE-PAGING-INDEX SELF) VALUE)
     (CL:SETQ VALUE (%THE-PAGING-INDEX SELF))))
   ((CL:EQ SLOTNAME SYM-SEQUENCE-INDICES-STELLA-LIST-ITERATOR-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%LIST-ITERATOR-CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%LIST-ITERATOR-CURSOR SELF))))
   ((CL:EQ SLOTNAME
     SYM-SEQUENCE-INDICES-LOGIC-SWITCHED-TO-REGENERABLE-SEQUENCE?)
    (CL:IF SETVALUE?
     (CL:SETF (%SWITCHED-TO-REGENERABLE-SEQUENCE? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%SWITCHED-TO-REGENERABLE-SEQUENCE? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF PAGING-INDEX))
  (CL:LET* ((ITERATOR (NEW-PAGING-INDEX-ITERATOR)))
   (CL:SETF (%THE-PAGING-INDEX ITERATOR) SELF)
   (CL:SETF (%LIST-ITERATOR-CURSOR ITERATOR) (%THE-SEQUENCE SELF))
   ITERATOR))

;;; (DEFGLOBAL *REGENERABLE-MODULE-LOADING-IS-COMPLETED?* ...)

(CL:DEFVAR *REGENERABLE-MODULE-LOADING-IS-COMPLETED?* FALSE
  "Setting this to TRUE is a contract that no more
regenerable modules will be loaded.  In that case, the system can
optimize NIL indices, avoiding recomputing them after their first
evaluation.  If the contract is broken, inferences may be missed.")

;;; (DEFUN PRINT-PAGING-INDEX ...)

(CL:DEFUN PRINT-PAGING-INDEX (SELF)
  (CL:WHEN (CL:EQ SELF NULL)
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "NULL")
   (CL:RETURN-FROM PRINT-PAGING-INDEX))
  (CL:LET*
   ((RS (%REGENERATION-SCHEME SELF)) (KEYWORD (%%VALUE RS))
    (ARGUMENT (%%VALUE (%%REST RS))))
   (CL:WHEN (CL:NOT (CL:EQ ARGUMENT NULL))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "PRIMARY-TYPE: "
     (PRIMARY-TYPE ARGUMENT) EOL))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) KEYWORD)
   (CL:WHEN (CL:NOT (CL:EQ ARGUMENT NULL))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) " "
     (CL:IF (ISA? ARGUMENT SGT-SEQUENCE-INDICES-LOGIC-LOGIC-OBJECT)
      (%SURROGATE-VALUE-INVERSE ARGUMENT) SYM-SEQUENCE-INDICES-LOGIC-??)))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL)))

;;; (DEFSPECIAL *FAKINGREGENERABLESEQUENCES?* ...)

(CL:DEFVAR *FAKINGREGENERABLESEQUENCES?* FALSE
  "True if we are testing out regeneration using a scheme
that doesn't have all propositions loaded in advance.")

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF PAGING-INDEX-ITERATOR))
  (CL:LET* ((CURSOR (%LIST-ITERATOR-CURSOR SELF)) (VALUE NULL))
   (CL:LOOP
    (CL:WHEN (CL:EQ CURSOR NIL)
     (CL:WHEN (%SWITCHED-TO-REGENERABLE-SEQUENCE? SELF)
      (CL:RETURN-FROM NEXT? FALSE))
     (CL:LET* ((PAGINGINDEX (%THE-PAGING-INDEX SELF)))
      (CL:SETQ CURSOR (%THE-REGENERABLE-SEQUENCE PAGINGINDEX))
      (CL:WHEN (CL:EQ CURSOR NULL)
       (CL:WHEN *LOADINGREGENERABLEOBJECTS?*
        (CL:WHEN (TRACE-KEYWORD? KWD-SEQUENCE-INDICES-PAGING)
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
          "NESTED REGENERATION OF INDEX: ")
         (PRINT-PAGING-INDEX (%THE-PAGING-INDEX SELF))))
       (CL:PROGN
        (CL:LET* ((*LOADINGREGENERABLEOBJECTS?* TRUE))
         (CL:DECLARE (CL:SPECIAL *LOADINGREGENERABLEOBJECTS?*))
         (REGENERATE-PAGING-INDEX PAGINGINDEX))
        (CL:SETQ CURSOR (%THE-REGENERABLE-SEQUENCE PAGINGINDEX))
        (CL:WHEN *FAKINGREGENERABLESEQUENCES?*
         (CL:SETF (%THE-REGENERABLE-SEQUENCE PAGINGINDEX) NULL)
         (CL:WHEN (CL:NOT (CL:EQ (%NEXT PAGINGINDEX) NULL))
          (UNLINK-PAGING-INDEX PAGINGINDEX)))
        (CL:WHEN
         (CL:AND (CL:EQ CURSOR NIL) (CL:EQ (%NEXT PAGINGINDEX) NULL)
          (CL:NOT *REGENERABLE-MODULE-LOADING-IS-COMPLETED?*))
         (LINK-PAGING-INDEX-TO-FRONT PAGINGINDEX))))
      (CL:WHEN (CL:EQ CURSOR NIL) (CL:RETURN-FROM NEXT? FALSE))
      (MOVE-PAGING-INDEX-TO-FRONT PAGINGINDEX)
      (CL:SETF (%LIST-ITERATOR-CURSOR SELF) CURSOR)
      (CL:SETF (%SWITCHED-TO-REGENERABLE-SEQUENCE? SELF) TRUE)))
    (CL:SETQ VALUE (%%VALUE CURSOR))
    (CL:WHEN (CL:NOT (DELETED? VALUE)) (CL:SETF (%VALUE SELF) VALUE)
     (CL:SETF (%LIST-ITERATOR-CURSOR SELF) (%%REST CURSOR))
     (CL:RETURN-FROM NEXT? TRUE))
    (CL:SETQ CURSOR (%%REST CURSOR)))))

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF PAGING-INDEX) VALUE)
  (CL:SETF (%THE-SEQUENCE SELF) (CONS VALUE (%THE-SEQUENCE SELF)))
  (CL:SETF (%SEQUENCE-LENGTH SELF) (CL:1+ (%SEQUENCE-LENGTH SELF))))

;;; (DEFMETHOD PUSH ...)

(CL:DEFMETHOD PUSH ((SELF PAGING-INDEX) VALUE)
  (CL:SETF (%THE-SEQUENCE SELF) (CONS VALUE (%THE-SEQUENCE SELF)))
  (CL:SETF (%SEQUENCE-LENGTH SELF) (CL:1+ (%SEQUENCE-LENGTH SELF))))

;;; (DEFMETHOD (ESTIMATED-LENGTH INTEGER) ...)

(CL:DEFMETHOD ESTIMATED-LENGTH ((SELF PAGING-INDEX))
  (%SEQUENCE-LENGTH SELF))

;;; (DEFMETHOD (REMOVE-DELETED-MEMBERS (LIKE SELF)) ...)

(CL:DEFMETHOD REMOVE-DELETED-MEMBERS ((SELF PAGING-INDEX))
  (CL:LET* ((OLDLENGTH (LENGTH (%THE-SEQUENCE SELF))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OLDLENGTH))
   (CL:SETF (%THE-SEQUENCE SELF)
    (REMOVE-DELETED-MEMBERS (%THE-SEQUENCE SELF)))
   (CL:SETF (%SEQUENCE-LENGTH SELF)
    (CL:- (%SEQUENCE-LENGTH SELF)
     (CL:- OLDLENGTH (LENGTH (%THE-SEQUENCE SELF)))))
   SELF))

;;; (DEFUN REMOVE-OBSOLETE-PAGING-INDICES ...)

(CL:DEFUN REMOVE-OBSOLETE-PAGING-INDICES (CLEAREDMODULE)
  (CL:LET* ((NEXT *FRONT-OF-PAGING-INDEX-LRU-LIST*) (INDEX NULL))
   (CL:LOOP
    (CL:WHEN (CL:EQ NEXT CABOOSE-INDEX)
     (CL:RETURN-FROM REMOVE-OBSOLETE-PAGING-INDICES))
    (CL:SETQ INDEX NEXT) (CL:SETQ NEXT (%NEXT NEXT))
    (CL:LET* ((INSTANCE (%%VALUE (%%REST (%REGENERATION-SCHEME INDEX)))))
     (CL:COND
      ((SUBTYPE-OF-SURROGATE? (SAFE-PRIMARY-TYPE INSTANCE))
       (CL:PROGN
        (CL:LET* ((VALUE (%SURROGATE-VALUE INSTANCE)))
         (CL:WHEN
          (CL:OR (CL:EQ VALUE NULL) (DELETED? VALUE)
           (CL:AND (CL:NOT (CL:EQ (%HOME-CONTEXT INSTANCE) NULL))
            (CL:EQ (%HOME-CONTEXT INSTANCE) CLEAREDMODULE)))
          (UNLINK-PAGING-INDEX INDEX)))))
      (CL:T
       (CL:WHEN
        (CL:OR (DELETED? INSTANCE)
         (CL:AND (CL:NOT (CL:EQ (HOME-MODULE INSTANCE) NULL))
          (CL:EQ (HOME-MODULE INSTANCE) CLEAREDMODULE)))
        (UNLINK-PAGING-INDEX INDEX))))))))

;;; (DEFUN (ALL-REGENERABLE-MODULES (ITERATOR OF MODULE)) ...)

(CL:DEFUN ALL-REGENERABLE-MODULES ()
  (CL:LET* ((V-004 NIL))
   (CL:LET* ((M NULL) (ITER-000 (ALL-MODULES)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ M (%VALUE ITER-000))
     (CL:WHEN
      (%WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS M)
        SYM-SEQUENCE-INDICES-LOGIC-REGENERABLE-FROM-SECONDARY-STORAGE?
        FALSE-WRAPPER))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS M NIL))
        (CL:IF (CL:EQ V-004 NIL) (CL:SETQ V-004 COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST V-004 COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS M NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:LET* ((VALUE-000 (ALLOCATE-ITERATOR V-004))) VALUE-000)))

;;; (DEFUN (TRIM-PAGING-INDICES INTEGER) ...)

(CL:DEFUN TRIM-PAGING-INDICES (LIMIT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM LIMIT))
  (CLEAN-UP-PAGING-STORAGE NULL)
  (CL:LET* ((INDEX (%PREVIOUS CABOOSE-INDEX)))
   (CL:LOOP
    (CL:WHEN (CL:OR (CL:<= LIMIT 0) (CL:EQ INDEX NULL)) (CL:RETURN))
    (CL:SETQ LIMIT (CL:- LIMIT (%SEQUENCE-LENGTH INDEX)))
    (CL:SETF (%THE-REGENERABLE-SEQUENCE INDEX) NULL)
    (CL:SETF (%NEXT INDEX) NULL) (CL:SETQ INDEX (%PREVIOUS INDEX)))
   (CL:SETF (%PREVIOUS CABOOSE-INDEX) INDEX)
   (CL:IF (CL:NOT (CL:EQ INDEX NULL))
    (CL:SETF (%NEXT INDEX) CABOOSE-INDEX)
    (CL:SETQ *FRONT-OF-PAGING-INDEX-LRU-LIST* CABOOSE-INDEX))
   (SUM-PAGING-INDICES)))

;;; (DEFUN (COUNT-PAGING-INDICES INTEGER) ...)

(CL:DEFUN COUNT-PAGING-INDICES ()
  (CL:LET* ((COUNT -1) (NEXT *FRONT-OF-PAGING-INDEX-LRU-LIST*))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT))
   (CL:LOOP
    (CL:WHEN (CL:EQ NEXT NULL)
     (CL:RETURN-FROM COUNT-PAGING-INDICES COUNT))
    (CL:SETQ COUNT (CL:1+ COUNT)) (CL:SETQ NEXT (%NEXT NEXT)))))

;;; (DEFUN (SUM-PAGING-INDICES INTEGER) ...)

(CL:DEFUN SUM-PAGING-INDICES ()
  (CL:LET* ((SUM 0) (NEXT *FRONT-OF-PAGING-INDEX-LRU-LIST*))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SUM))
   (CL:LOOP
    (CL:WHEN (CL:EQ NEXT NULL) (CL:RETURN-FROM SUM-PAGING-INDICES SUM))
    (CL:SETQ SUM (CL:+ SUM (%SEQUENCE-LENGTH NEXT)))
    (CL:SETQ NEXT (%NEXT NEXT)))))

;;; (DEFUN (DISPLAY-PAGING-INDICES INTEGER) ...)

(CL:DEFUN DISPLAY-PAGING-INDICES ()
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL)
  (CL:LET*
   ((INDEX NULL) (ITER-000 (%THE-CONS-LIST (LIST-OF-PAGING-INDICES))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ INDEX (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     (%REGENERATION-SCHEME INDEX) EOL)))
  (COUNT-PAGING-INDICES))

;;; (DEFUN (LIST-OF-PAGING-INDICES (LIST OF PAGING-INDEX)) ...)

(CL:DEFUN LIST-OF-PAGING-INDICES ()
  (CL:LET* ((NEXT *FRONT-OF-PAGING-INDEX-LRU-LIST*) (LIST (NEW-LIST)))
   (CL:LOOP
    (CL:WHEN (CL:EQ NEXT NULL)
     (CL:RETURN-FROM LIST-OF-PAGING-INDICES (REVERSE LIST)))
    (PUSH LIST NEXT) (CL:SETQ NEXT (%NEXT NEXT)))))

(CL:DEFUN HELP-STARTUP-SEQUENCE-INDICES1 ()
  (CL:PROGN
   (CL:SETQ SYM-SEQUENCE-INDICES-LOGIC-THE-SEQUENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-SEQUENCE" NULL 0))
   (CL:SETQ SGT-SEQUENCE-INDICES-LOGIC-NON-PAGING-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NON-PAGING-INDEX" NULL 1))
   (CL:SETQ SGT-SEQUENCE-INDICES-LOGIC-PAGING-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PAGING-INDEX" NULL 1))
   (CL:SETQ SYM-SEQUENCE-INDICES-LOGIC-THE-REGENERABLE-SEQUENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-REGENERABLE-SEQUENCE" NULL 0))
   (CL:SETQ SYM-SEQUENCE-INDICES-STELLA-NEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEXT"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-SEQUENCE-INDICES-LOGIC-PREVIOUS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREVIOUS" NULL 0))
   (CL:SETQ SYM-SEQUENCE-INDICES-STELLA-SEQUENCE-LENGTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SEQUENCE-LENGTH"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-SEQUENCE-INDICES-LOGIC-REGENERATION-SCHEME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REGENERATION-SCHEME" NULL 0))
   (CL:SETQ SGT-SEQUENCE-INDICES-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ KWD-SEQUENCE-INDICES-PAGING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PAGING" NULL 2))
   (CL:SETQ KWD-SEQUENCE-INDICES-NON-PAGING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NON-PAGING" NULL 2))
   (CL:SETQ SYM-SEQUENCE-INDICES-LOGIC-USE-NON-PAGING-INDICES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-NON-PAGING-INDICES?" NULL 0))
   (CL:SETQ SGT-SEQUENCE-INDICES-LOGIC-SEQUENCE-INDEX-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SEQUENCE-INDEX-ITERATOR" NULL 1))
   (CL:SETQ SYM-SEQUENCE-INDICES-STELLA-LIST-ITERATOR-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-ITERATOR-CURSOR"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ KWD-SEQUENCE-INDICES-CABOOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CABOOSE" NULL 2))
   (CL:SETQ SGT-SEQUENCE-INDICES-LOGIC-PAGING-INDEX-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PAGING-INDEX-ITERATOR" NULL 1))
   (CL:SETQ SYM-SEQUENCE-INDICES-LOGIC-THE-PAGING-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-PAGING-INDEX" NULL 0))
   (CL:SETQ SYM-SEQUENCE-INDICES-LOGIC-SWITCHED-TO-REGENERABLE-SEQUENCE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SWITCHED-TO-REGENERABLE-SEQUENCE?"
     NULL 0))
   (CL:SETQ SGT-SEQUENCE-INDICES-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SYM-SEQUENCE-INDICES-LOGIC-??
    (INTERN-RIGID-SYMBOL-WRT-MODULE "??" NULL 0))
   (CL:SETQ SYM-SEQUENCE-INDICES-LOGIC-REGENERABLE-FROM-SECONDARY-STORAGE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REGENERABLE-FROM-SECONDARY-STORAGE?"
     NULL 0))
   (CL:SETQ SYM-SEQUENCE-INDICES-LOGIC-STARTUP-SEQUENCE-INDICES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-SEQUENCE-INDICES" NULL 0))
   (CL:SETQ SYM-SEQUENCE-INDICES-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))))

(CL:DEFUN STARTUP-SEQUENCE-INDICES ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-SEQUENCE-INDICES1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ NIL-NON-PAGING-INDEX (NEW-NON-PAGING-INDEX))
    (CL:LET* ((SELF-001 (NEW-PAGING-INDEX)))
     (CL:SETF (%THE-REGENERABLE-SEQUENCE SELF-001) NIL)
     (CL:SETF (%REGENERATION-SCHEME SELF-001)
      (GET-QUOTED-TREE "((:NIL-SEQUENCE) \"/LOGIC\")" "/LOGIC"))
     (CL:SETQ NIL-PAGING-INDEX SELF-001))
    (CL:SETQ CABOOSE-INDEX (NEW-PAGING-INDEX))
    (CL:SETQ *FRONT-OF-PAGING-INDEX-LRU-LIST* CABOOSE-INDEX))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SEQUENCE-INDEX"
        "(DEFCLASS SEQUENCE-INDEX (STANDARD-OBJECT) :DOCUMENTATION \"Abstract class for managing a sequence of objects.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :ABSTRACT? TRUE :SLOTS ((THE-SEQUENCE :TYPE CONS :INITIALLY NIL)) :PRINT-FORM (PRINT-SEQUENCE-INDEX SELF STREAM))")))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SEQUENCE-INDEX-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NON-PAGING-INDEX"
        "(DEFCLASS NON-PAGING-INDEX (SEQUENCE-INDEX) :DOCUMENTATION \"Index that manages an always-in-memory data
strucure containing a sequence of objects.\")")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-NON-PAGING-INDEX)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PAGING-INDEX"
        "(DEFCLASS PAGING-INDEX (SEQUENCE-INDEX) :DOCUMENTATION \"Index that manages a sequence of objects
retrievable from persistent storage.\" :SLOTS ((THE-REGENERABLE-SEQUENCE :TYPE CONS :INITIALLY NULL) (NEXT :TYPE PAGING-INDEX) (PREVIOUS :TYPE PAGING-INDEX) (SEQUENCE-LENGTH :TYPE INTEGER :INITIALLY 0) (REGENERATION-SCHEME :TYPE CONS)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-PAGING-INDEX))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-PAGING-INDEX-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SEQUENCE-INDEX-ITERATOR"
        "(DEFCLASS SEQUENCE-INDEX-ITERATOR (ITERATOR) :DOCUMENTATION \"An iterator that generates successive members of a sequence index.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((LIST-ITERATOR-CURSOR :TYPE CONS)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SEQUENCE-INDEX-ITERATOR))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SEQUENCE-INDEX-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PAGING-INDEX-ITERATOR"
        "(DEFCLASS PAGING-INDEX-ITERATOR (ITERATOR) :DOCUMENTATION \"An iterator that generates successive members of a sequence index.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((THE-PAGING-INDEX :TYPE PAGING-INDEX) (LIST-ITERATOR-CURSOR :TYPE CONS) (SWITCHED-TO-REGENERABLE-SEQUENCE? :TYPE BOOLEAN)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-PAGING-INDEX-ITERATOR))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-PAGING-INDEX-ITERATOR-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "CREATE-SEQUENCE-INDEX"
     "(DEFUN (CREATE-SEQUENCE-INDEX SEQUENCE-INDEX) ((SELF OBJECT) (REGENERATIONSCHEME CONS)))"
     (CL:FUNCTION CREATE-SEQUENCE-INDEX) NULL)
    (DEFINE-FUNCTION-OBJECT "KEYWORD.CREATE-SEQUENCE-INDEX"
     "(DEFUN (KEYWORD.CREATE-SEQUENCE-INDEX SEQUENCE-INDEX) ((KIND KEYWORD) (REGENERATIONSCHEME CONS)))"
     (CL:FUNCTION KEYWORD.CREATE-SEQUENCE-INDEX) NULL)
    (DEFINE-FUNCTION-OBJECT "MODULE.CREATE-SEQUENCE-INDEX"
     "(DEFUN (MODULE.CREATE-SEQUENCE-INDEX SEQUENCE-INDEX) ((MODULE MODULE) (REGENERATIONSCHEME CONS)))"
     (CL:FUNCTION MODULE.CREATE-SEQUENCE-INDEX) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD INSERT ((SELF SEQUENCE-INDEX) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
     (CL:FUNCTION INSERT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD PUSH ((SELF SEQUENCE-INDEX) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
     (CL:FUNCTION PUSH) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (FIRST OBJECT) ((SELF SEQUENCE-INDEX)) :PUBLIC? TRUE)"
     (CL:FUNCTION FIRST) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF SEQUENCE-INDEX)) :PUBLIC? TRUE)"
     (CL:FUNCTION EMPTY?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (ESTIMATED-LENGTH INTEGER) ((SELF SEQUENCE-INDEX)))"
     (CL:FUNCTION ESTIMATED-LENGTH) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (REMOVE-DELETED-MEMBERS (LIKE SELF)) ((SELF SEQUENCE-INDEX)) :PUBLIC? TRUE)"
     (CL:FUNCTION REMOVE-DELETED-MEMBERS) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (CONSIFY (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF SEQUENCE-INDEX)))"
     (CL:FUNCTION CONSIFY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF SEQUENCE-INDEX)))"
     (CL:FUNCTION ALLOCATE-ITERATOR) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF SEQUENCE-INDEX-ITERATOR)))"
     (CL:FUNCTION NEXT?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF SEQUENCE-INDEX-ITERATOR)))"
     (CL:FUNCTION EMPTY?) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-SEQUENCE-INDEX"
     "(DEFUN PRINT-SEQUENCE-INDEX ((SELF SEQUENCE-INDEX) (STREAM NATIVE-OUTPUT-STREAM)))"
     (CL:FUNCTION PRINT-SEQUENCE-INDEX) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (COPY NON-PAGING-INDEX) ((SELF NON-PAGING-INDEX)))"
     (CL:FUNCTION COPY) NULL)
    (DEFINE-METHOD-OBJECT "(DEFMETHOD CLEAR ((SELF NON-PAGING-INDEX)))"
     (CL:FUNCTION CLEAR) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (REMOVE NON-PAGING-INDEX) ((SELF NON-PAGING-INDEX) (VALUE OBJECT)))"
     (CL:FUNCTION REMOVE) NULL)
    (DEFINE-FUNCTION-OBJECT "UNLINK-PAGING-INDEX"
     "(DEFUN UNLINK-PAGING-INDEX ((INDEX PAGING-INDEX)))"
     (CL:FUNCTION UNLINK-PAGING-INDEX) NULL)
    (DEFINE-FUNCTION-OBJECT "LINK-PAGING-INDEX-TO-FRONT"
     "(DEFUN LINK-PAGING-INDEX-TO-FRONT ((INDEX PAGING-INDEX)))"
     (CL:FUNCTION LINK-PAGING-INDEX-TO-FRONT) NULL)
    (DEFINE-FUNCTION-OBJECT "MOVE-PAGING-INDEX-TO-FRONT"
     "(DEFUN MOVE-PAGING-INDEX-TO-FRONT ((INDEX PAGING-INDEX)))"
     (CL:FUNCTION MOVE-PAGING-INDEX-TO-FRONT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF PAGING-INDEX)))"
     (CL:FUNCTION ALLOCATE-ITERATOR) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-PAGING-INDEX"
     "(DEFUN PRINT-PAGING-INDEX ((SELF PAGING-INDEX)))"
     (CL:FUNCTION PRINT-PAGING-INDEX) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF PAGING-INDEX-ITERATOR)) :PUBLIC? TRUE)"
     (CL:FUNCTION NEXT?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD INSERT ((SELF PAGING-INDEX) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
     (CL:FUNCTION INSERT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD PUSH ((SELF PAGING-INDEX) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
     (CL:FUNCTION PUSH) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (ESTIMATED-LENGTH INTEGER) ((SELF PAGING-INDEX)) :PUBLIC? TRUE)"
     (CL:FUNCTION ESTIMATED-LENGTH) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (REMOVE-DELETED-MEMBERS (LIKE SELF)) ((SELF PAGING-INDEX)) :PUBLIC? TRUE)"
     (CL:FUNCTION REMOVE-DELETED-MEMBERS) NULL)
    (DEFINE-FUNCTION-OBJECT "REMOVE-OBSOLETE-PAGING-INDICES"
     "(DEFUN REMOVE-OBSOLETE-PAGING-INDICES ((CLEAREDMODULE MODULE)))"
     (CL:FUNCTION REMOVE-OBSOLETE-PAGING-INDICES) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-REGENERABLE-MODULES"
     "(DEFUN (ALL-REGENERABLE-MODULES (ITERATOR OF MODULE)) ())"
     (CL:FUNCTION ALL-REGENERABLE-MODULES) NULL)
    (DEFINE-FUNCTION-OBJECT "TRIM-PAGING-INDICES"
     "(DEFUN (TRIM-PAGING-INDICES INTEGER) ((LIMIT INTEGER)))"
     (CL:FUNCTION TRIM-PAGING-INDICES) NULL)
    (DEFINE-FUNCTION-OBJECT "COUNT-PAGING-INDICES"
     "(DEFUN (COUNT-PAGING-INDICES INTEGER) ())"
     (CL:FUNCTION COUNT-PAGING-INDICES) NULL)
    (DEFINE-FUNCTION-OBJECT "SUM-PAGING-INDICES"
     "(DEFUN (SUM-PAGING-INDICES INTEGER) ())"
     (CL:FUNCTION SUM-PAGING-INDICES) NULL)
    (DEFINE-FUNCTION-OBJECT "DISPLAY-PAGING-INDICES"
     "(DEFUN (DISPLAY-PAGING-INDICES INTEGER) ())"
     (CL:FUNCTION DISPLAY-PAGING-INDICES) NULL)
    (DEFINE-FUNCTION-OBJECT "LIST-OF-PAGING-INDICES"
     "(DEFUN (LIST-OF-PAGING-INDICES (LIST OF PAGING-INDEX)) ())"
     (CL:FUNCTION LIST-OF-PAGING-INDICES) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-SEQUENCE-INDICES"
     "(DEFUN STARTUP-SEQUENCE-INDICES () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-SEQUENCE-INDICES) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION
        SYM-SEQUENCE-INDICES-LOGIC-STARTUP-SEQUENCE-INDICES)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-SEQUENCE-INDICES-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "Startup-Sequence-Indices") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NIL-NON-PAGING-INDEX NON-PAGING-INDEX (NEW NON-PAGING-INDEX) :DOCUMENTATION \"Returns a non-writable empty sequence.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NIL-PAGING-INDEX PAGING-INDEX (NEW PAGING-INDEX :THE-REGENERABLE-SEQUENCE NIL :REGENERATION-SCHEME (QUOTE (:NIL-SEQUENCE))) :DOCUMENTATION \"Returns a non-writable empty sequence.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *LOADINGREGENERABLEOBJECTS?* BOOLEAN FALSE :DOCUMENTATION \"If TRUE, objects being created are regenerable,
and should not be indexed using the backlinks procedures.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT CABOOSE-INDEX PAGING-INDEX (NEW PAGING-INDEX) :DOCUMENTATION \"The caboose index is always the last one on the
list.  It exists so we don't need to check for a null list
during relinking, i.e., the code is a tiny bit faster.\")")
    (CL:SETF (%REGENERATION-SCHEME CABOOSE-INDEX)
     (CONS KWD-SEQUENCE-INDICES-CABOOSE NIL))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *FRONT-OF-PAGING-INDEX-LRU-LIST* PAGING-INDEX CABOOSE-INDEX :DOCUMENTATION \"Points to first index in doubly-linked list of in-memory
paging indices. The most recently used are at the front of the list.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DISABLELRUINDEXING?* BOOLEAN FALSE :DOCUMENTATION \"Don't mess with the order of paging indices.
Used for debugging, and also to test whether the overhead
of relinking is noticable when we time things.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *REGENERABLE-MODULE-LOADING-IS-COMPLETED?* BOOLEAN FALSE :DOCUMENTATION \"Setting this to TRUE is a contract that no more
regenerable modules will be loaded.  In that case, the system can
optimize NIL indices, avoiding recomputing them after their first
evaluation.  If the contract is broken, inferences may be missed.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *FAKINGREGENERABLESEQUENCES?* BOOLEAN FALSE :DOCUMENTATION \"True if we are testing out regeneration using a scheme
that doesn't have all propositions loaded in advance.\")"))))
