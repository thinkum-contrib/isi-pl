;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; normalize.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-CUT NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-BOUND-VARIABLES NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-FORK NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-QUERY NULL)
(CL:DEFVAR KWD-NORMALIZE-AND NULL)
(CL:DEFVAR KWD-NORMALIZE-CONSTANT NULL)
(CL:DEFVAR SGT-NORMALIZE-STELLA-TRUE NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-CONSTANT NULL)
(CL:DEFVAR SGT-NORMALIZE-STELLA-CS-VALUE NULL)
(CL:DEFVAR SYM-NORMALIZE-STELLA-AND NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-DESCRIPTIVE? NULL)
(CL:DEFVAR KWD-NORMALIZE-OR NULL)
(CL:DEFVAR SYM-NORMALIZE-STELLA-OR NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-WEIGHT NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-NEURAL-NETWORK NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-VARIABLE-TYPE? NULL)
(CL:DEFVAR KWD-NORMALIZE-DESCRIPTION NULL)
(CL:DEFVAR KWD-NORMALIZE-EXISTS NULL)
(CL:DEFVAR KWD-NORMALIZE-NOT NULL)
(CL:DEFVAR KWD-NORMALIZE-ERROR NULL)
(CL:DEFVAR SGT-NORMALIZE-STELLA-FALSE NULL)
(CL:DEFVAR KWD-NORMALIZE-FORALL NULL)
(CL:DEFVAR KWD-NORMALIZE-EQUIVALENT NULL)
(CL:DEFVAR KWD-NORMALIZE-ISA NULL)
(CL:DEFVAR KWD-NORMALIZE-PREDICATE NULL)
(CL:DEFVAR KWD-NORMALIZE-FUNCTION NULL)
(CL:DEFVAR SYM-NORMALIZE-STELLA-EXISTS NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SGT-NORMALIZE-STELLA-THING NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-VARIABLE-ARITY NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-ARITY NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-CLASS NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-FUNCTION NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-VALUE NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-SKOLEM NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SYM-NORMALIZE-STELLA-FUNCTION NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-DONT-OPTIMIZE? NULL)
(CL:DEFVAR KWD-NORMALIZE-IMPLIES NULL)
(CL:DEFVAR KWD-NORMALIZE-FAIL NULL)
(CL:DEFVAR KWD-NORMALIZE-COLLECT-INTO NULL)
(CL:DEFVAR SYM-NORMALIZE-STELLA-NOT NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-NOT NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-FORALL NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-EXISTS NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-OR NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-AND NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-STARTUP-NORMALIZE NULL)
(CL:DEFVAR SYM-NORMALIZE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* STANDARD-ERROR NULL-INTEGER EOL
  NULL-FLOAT NULL-FLOAT-WRAPPER *MODULE* FALSE-PROPOSITION
  TRUE-PROPOSITION FALSE-WRAPPER TRUE-WRAPPER NIL))

;;; (DEFUN (SEARCH-CONTROL-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN SEARCH-CONTROL-PROPOSITION? (SELF)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.OPERATOR SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 SGT-NORMALIZE-PL-KERNEL-KB-CUT)
      (CL:EQ TEST-VALUE-000 SGT-NORMALIZE-PL-KERNEL-KB-BOUND-VARIABLES)
      (CL:EQ TEST-VALUE-000 SGT-NORMALIZE-PL-KERNEL-KB-FORK)
      (CL:EQ TEST-VALUE-000 SGT-NORMALIZE-PL-KERNEL-KB-QUERY))
     CL:T)
    (CL:T CL:NIL))))

;;; (DEFUN (DUPLICATE-AND-OR-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN DUPLICATE-AND-OR-ARGUMENTS? (PROP1 PROP2)
  (CL:AND (EQUIVALENT-PROPOSITIONS? PROP1 PROP2 NULL)
   (CL:NOT
    (CL:OR (SEARCH-CONTROL-PROPOSITION? PROP1)
     (SEARCH-CONTROL-PROPOSITION? PROP2)))))

;;; (DEFUN COLLECT-FLAT-CONJUNCTS ...)

(CL:DEFUN COLLECT-FLAT-CONJUNCTS (SELF FLATCONJUNCTS)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-AND)
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (COLLECT-FLAT-CONJUNCTS ARG FLATCONJUNCTS)
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (CL:RETURN-FROM COLLECT-FLAT-CONJUNCTS))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-CONSTANT)
     (CL:WHEN
      (CL:EQ (%PROPOSITION.OPERATOR SELF) SGT-NORMALIZE-STELLA-TRUE)
      (CL:RETURN-FROM COLLECT-FLAT-CONJUNCTS)))
    (CL:T (CLEAR (%PROPOSITION.DEPENDENT-PROPOSITIONS SELF)))))
  (CL:LET* ((FOUND?-000 CL:NIL))
   (CL:LET*
    ((PROP NULL) (ITER-000 (%LIST.THE-CONS-LIST FLATCONJUNCTS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PROP (%%VALUE ITER-000))
     (CL:WHEN (DUPLICATE-AND-OR-ARGUMENTS? PROP SELF)
      (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:NOT FOUND?-000) (PUSH FLATCONJUNCTS SELF))))

;;; (DEFUN OVERLAY-WITH-CONSTANT-PROPOSITION ...)

(CL:DEFUN OVERLAY-WITH-CONSTANT-PROPOSITION (SELF CONSTANTPROPOSITION)
  (CL:LET*
   ((OVERLAY (CREATE-PROPOSITION SYM-NORMALIZE-LOGIC-CONSTANT 0)))
   (CL:SETF (%PROPOSITION.OPERATOR OVERLAY)
    (%PROPOSITION.OPERATOR CONSTANTPROPOSITION))
   (CL:LET*
    ((OBJECT-000 OVERLAY)
     (VALUE-000
      (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE CONSTANTPROPOSITION)
       (%PROPOSITION.HOME-CONTEXT CONSTANTPROPOSITION) CL:NIL))
     (OLD-VALUE-001 (%PROPOSITION.TRUTH-VALUE OBJECT-000))
     (NEW-VALUE-000
      (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-000
       (%PROPOSITION.HOME-CONTEXT OBJECT-000) CL:NIL)))
    (CL:WHEN
     (CL:NOT
      (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
       (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
        SGT-NORMALIZE-STELLA-CS-VALUE)))
     (CL:SETF (%PROPOSITION.TRUTH-VALUE OBJECT-000) NEW-VALUE-000)))
   (OVERLAY-PROPOSITION SELF OVERLAY)))

;;; (DEFUN (CONJOIN-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN CONJOIN-PROPOSITIONS (CONJUNCTS)
  (CL:LET* ((FLATCONJUNCTS (NEW-LIST)) (RESULT NULL))
   (CL:LET* ((C NULL) (ITER-000 CONJUNCTS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ C (%%VALUE ITER-000))
     (COLLECT-FLAT-CONJUNCTS C FLATCONJUNCTS)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (REVERSE FLATCONJUNCTS)
   (CL:CASE (LENGTH FLATCONJUNCTS)
    (0
     (CL:LET*
      ((PROPOSITION
        (CREATE-PROPOSITION SYM-NORMALIZE-LOGIC-CONSTANT 0)))
      (OVERLAY-WITH-CONSTANT-PROPOSITION PROPOSITION TRUE-PROPOSITION)
      (CL:RETURN-FROM CONJOIN-PROPOSITIONS PROPOSITION)))
    (1 (CL:RETURN-FROM CONJOIN-PROPOSITIONS (FIRST FLATCONJUNCTS)))
    (CL:OTHERWISE))
   (CL:SETQ RESULT
    (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-AND
     (LENGTH FLATCONJUNCTS)))
   (CL:SETF (%PROPOSITION.ARGUMENTS RESULT)
    (COPY-LIST-TO-ARGUMENTS-VECTOR FLATCONJUNCTS))
   (CL:WHEN
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE
      (%PROPOSITION.DYNAMIC-SLOTS (FIRST FLATCONJUNCTS))
      SYM-NORMALIZE-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS RESULT)
     SYM-NORMALIZE-LOGIC-DESCRIPTIVE?
     (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
   RESULT))

;;; (DEFUN (CONJOIN-TWO-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN CONJOIN-TWO-PROPOSITIONS (PROP1 PROP2)
  (CL:COND ((CL:EQ PROP1 NULL) PROP2) ((CL:EQ PROP2 NULL) PROP1)
   ((DUPLICATE-AND-OR-ARGUMENTS? PROP1 PROP2) PROP1)
   (CL:T
    (CL:LET*
     ((ANDPROPOSITION (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-AND 2)))
     (CL:LET
      ((SELF
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS ANDPROPOSITION)))
       (VALUE PROP1) (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET
      ((SELF
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS ANDPROPOSITION)))
       (VALUE PROP2) (POSITION 1))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:WHEN
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP1)
        SYM-NORMALIZE-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
      (SET-DYNAMIC-SLOT-VALUE
       (%PROPOSITION.DYNAMIC-SLOTS ANDPROPOSITION)
       SYM-NORMALIZE-LOGIC-DESCRIPTIVE?
       (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
     ANDPROPOSITION))))

;;; (DEFUN COLLECT-FLAT-DISJUNCTS ...)

(CL:DEFUN COLLECT-FLAT-DISJUNCTS (SELF FLATDISJUNCTS)
  (CL:COND
   ((CL:EQ (%PROPOSITION.KIND SELF) KWD-NORMALIZE-OR)
    (CL:LET*
     ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:SETQ ARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (COLLECT-FLAT-DISJUNCTS ARG FLATDISJUNCTS)
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
    (FREE SELF))
   (CL:T
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((PROP NULL) (ITER-000 (%LIST.THE-CONS-LIST FLATDISJUNCTS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ PROP (%%VALUE ITER-000))
       (CL:WHEN (DUPLICATE-AND-OR-ARGUMENTS? PROP SELF)
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:WHEN (CL:NOT FOUND?-000) (PUSH FLATDISJUNCTS SELF)
      (CLEAR (%PROPOSITION.DEPENDENT-PROPOSITIONS SELF)))))))

;;; (DEFUN (DISJOIN-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN DISJOIN-PROPOSITIONS (DISJUNCTS)
  (CL:WHEN (CL:EQ DISJUNCTS NIL)
   (CL:RETURN-FROM DISJOIN-PROPOSITIONS FALSE-PROPOSITION))
  (CL:LET* ((FLATDISJUNCTS (NEW-LIST)) (RESULT NULL))
   (CL:LET* ((C NULL) (ITER-000 DISJUNCTS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ C (%%VALUE ITER-000))
     (COLLECT-FLAT-DISJUNCTS C FLATDISJUNCTS)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (REVERSE FLATDISJUNCTS)
   (CL:CASE (LENGTH FLATDISJUNCTS)
    (0
     (CL:LET*
      ((PROPOSITION
        (CREATE-PROPOSITION SYM-NORMALIZE-LOGIC-CONSTANT 0)))
      (OVERLAY-WITH-CONSTANT-PROPOSITION PROPOSITION FALSE-PROPOSITION)
      (CL:RETURN-FROM DISJOIN-PROPOSITIONS PROPOSITION)))
    (1 (CL:RETURN-FROM DISJOIN-PROPOSITIONS (FIRST FLATDISJUNCTS)))
    (CL:OTHERWISE))
   (CL:SETQ RESULT
    (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-OR
     (LENGTH FLATDISJUNCTS)))
   (CL:SETF (%PROPOSITION.ARGUMENTS RESULT)
    (COPY-LIST-TO-ARGUMENTS-VECTOR FLATDISJUNCTS))
   (CL:WHEN
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE
      (%PROPOSITION.DYNAMIC-SLOTS (FIRST FLATDISJUNCTS))
      SYM-NORMALIZE-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS RESULT)
     SYM-NORMALIZE-LOGIC-DESCRIPTIVE?
     (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
   RESULT))

;;; (DEFUN (RENAME-LOGIC-VARIABLE-APART PATTERN-VARIABLE) ...)

(CL:DEFUN RENAME-LOGIC-VARIABLE-APART (VARIABLE DESTRUCTIVE?)
  (CL:LET* ((*MODULE* (HOME-MODULE VARIABLE)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:LET*
    ((NEWNAME
      (LOCAL-GENSYM
       (%SYMBOL.SYMBOL-NAME
        (%PATTERN-VARIABLE.SKOLEM-NAME VARIABLE)))))
    (CL:WHEN (CL:NOT DESTRUCTIVE?)
     (CL:SETQ VARIABLE (COPY-VARIABLE VARIABLE (NEW-KEY-VALUE-LIST))))
    (CL:SETF (%PATTERN-VARIABLE.SKOLEM-NAME VARIABLE) NEWNAME)
    VARIABLE)))

;;; (DEFUN OVERLAY-PROPOSITION ...)

(CL:DEFUN OVERLAY-PROPOSITION (SELF OVERLAYINGPROP)
  (CL:SETF (%PROPOSITION.KIND SELF) (%PROPOSITION.KIND OVERLAYINGPROP))
  (CL:SETF (%PROPOSITION.OPERATOR SELF)
   (%PROPOSITION.OPERATOR OVERLAYINGPROP))
  (CL:LET*
   ((OBJECT-000 SELF)
    (VALUE-000
     (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE OVERLAYINGPROP)
      (%PROPOSITION.HOME-CONTEXT OVERLAYINGPROP) CL:NIL))
    (OLD-VALUE-001 (%PROPOSITION.TRUTH-VALUE OBJECT-000))
    (NEW-VALUE-000
     (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-000
      (%PROPOSITION.HOME-CONTEXT OBJECT-000) CL:NIL)))
   (CL:WHEN
    (CL:NOT
     (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
      (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
       SGT-NORMALIZE-STELLA-CS-VALUE)))
    (CL:SETF (%PROPOSITION.TRUTH-VALUE OBJECT-000) NEW-VALUE-000)))
  (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
   SYM-NORMALIZE-LOGIC-WEIGHT
   (WRAP-FLOAT
    (%FLOAT-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS OVERLAYINGPROP)
      SYM-NORMALIZE-LOGIC-WEIGHT NULL-FLOAT-WRAPPER)))
   NULL-FLOAT-WRAPPER)
  (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
   SYM-NORMALIZE-LOGIC-NEURAL-NETWORK
   (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS OVERLAYINGPROP)
    SYM-NORMALIZE-LOGIC-NEURAL-NETWORK NULL)
   NULL)
  (CL:SETF (%PROPOSITION.ARGUMENTS SELF)
   (COPY (%PROPOSITION.ARGUMENTS OVERLAYINGPROP)))
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS OVERLAYINGPROP)
      SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL)
     NULL))
   (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
    SYM-NORMALIZE-LOGIC-IO-VARIABLES
    (COPY
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS OVERLAYINGPROP)
      SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
    NULL))
  (CL:WHEN
   (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? OVERLAYINGPROP))
   (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
    SYM-NORMALIZE-LOGIC-VARIABLE-TYPE? TRUE-WRAPPER NULL))
  (CL:WHEN
   (%BOOLEAN-WRAPPER.WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS OVERLAYINGPROP)
     SYM-NORMALIZE-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
   (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
    SYM-NORMALIZE-LOGIC-DESCRIPTIVE?
    (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)))

;;; (DEFUN NORMALIZE-EXISTS-PROPOSITION ...)

(CL:DEFUN NORMALIZE-EXISTS-PROPOSITION (SELF)
  (CL:LET*
   ((WHEREPROPOSITION
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      0)))
   (CL:LET* ((*EVALUATIONMODE* KWD-NORMALIZE-DESCRIPTION))
    (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
    (NORMALIZE-PROPOSITION WHEREPROPOSITION))
   (CL:WHEN
    (CL:EQ (%PROPOSITION.KIND WHEREPROPOSITION) KWD-NORMALIZE-EXISTS)
    (CL:LET* ((COMBINEDARGS NIL))
     (CL:LET*
      ((VBL NULL)
       (VECTOR-000
        (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
         SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
       (COLLECT-000 NULL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ VBL
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS VBL NIL))
         (CL:IF (CL:EQ COMBINEDARGS NIL)
          (CL:SETQ COMBINEDARGS COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST COMBINEDARGS COLLECT-000)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VBL NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (CL:LET*
      ((VBL NULL)
       (VECTOR-001
        (DYNAMIC-SLOT-VALUE
         (%PROPOSITION.DYNAMIC-SLOTS WHEREPROPOSITION)
         SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
       (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001))
       (COLLECT-001 NULL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:SETQ VBL
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:IF (CL:EQ COLLECT-001 NULL)
        (CL:PROGN (CL:SETQ COLLECT-001 (CONS VBL NIL))
         (CL:IF (CL:EQ COMBINEDARGS NIL)
          (CL:SETQ COMBINEDARGS COLLECT-001)
          (ADD-CONS-TO-END-OF-CONS-LIST COMBINEDARGS COLLECT-001)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS VBL NIL))
         (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
     (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
      SYM-NORMALIZE-LOGIC-IO-VARIABLES
      (COPY-CONS-LIST-TO-VARIABLES-VECTOR COMBINEDARGS) NULL)
     (CL:SETF (%PROPOSITION.ARGUMENTS SELF)
      (%PROPOSITION.ARGUMENTS WHEREPROPOSITION))
     (DELETED?-SETTER WHEREPROPOSITION CL:T)))
   (CL:WHEN
    (CL:OR
     (CL:=
      (%VECTOR.ARRAY-SIZE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
        SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
      0)
     (CL:EQ (%PROPOSITION.KIND WHEREPROPOSITION)
      KWD-NORMALIZE-CONSTANT))
    (OVERLAY-PROPOSITION SELF WHEREPROPOSITION))))

;;; (DEFUN (MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT? BOOLEAN) ...)

(CL:DEFUN MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT? (SELF)
  (CL:LET*
   ((ANTECEDENT NULL)
    (CONSEQUENT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      1))
    (POSITIVEGOALS NIL) (NEGATEDGOALS NIL))
   (CL:WHEN
    (CL:NOT (CL:EQ (%PROPOSITION.KIND CONSEQUENT) KWD-NORMALIZE-OR))
    (CL:RETURN-FROM MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT? CL:NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS CONSEQUENT))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:LET* ((DISJUNCT ARG))
      (CL:IF (CL:EQ (%PROPOSITION.KIND DISJUNCT) KWD-NORMALIZE-NOT)
       (CL:SETQ NEGATEDGOALS
        (CONS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS DISJUNCT)))
          0)
         NEGATEDGOALS))
       (CL:SETQ POSITIVEGOALS (CONS DISJUNCT POSITIVEGOALS))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ POSITIVEGOALS NIL))
     (CL:NOT (CL:EQ NEGATEDGOALS NIL)))
    (CL:SETQ ANTECEDENT (CONJOIN-PROPOSITIONS (REVERSE NEGATEDGOALS)))
    (CL:SETQ CONSEQUENT (DISJOIN-PROPOSITIONS (REVERSE POSITIVEGOALS)))
    (NORMALIZE-PROPOSITION ANTECEDENT)
    (NORMALIZE-PROPOSITION CONSEQUENT)
    (CL:LET
     ((SELF (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      (VALUE ANTECEDENT) (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET
     ((SELF (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      (VALUE CONSEQUENT) (POSITION 1))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:RETURN-FROM MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT? CL:T))
   CL:NIL))

;;; (DEFUN FLATTEN-NESTED-FORALL-PROPOSITION ...)

(CL:DEFUN FLATTEN-NESTED-FORALL-PROPOSITION (SELF)
  (CL:LET*
   ((IOVARIABLES NIL)
    (OUTERANTECEDENT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      0))
    (NESTEDFORALL
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      1))
    (INNERANTECEDENT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS NESTEDFORALL)))
      0))
    (INNERCONSEQUENT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS NESTEDFORALL)))
      1)))
   (CL:LET*
    ((V NULL)
     (VECTOR-000
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
       SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ V
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ IOVARIABLES (CONS V IOVARIABLES))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET*
    ((V NULL)
     (VECTOR-001
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS NESTEDFORALL)
       SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
     (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
    (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
     (CL:SETQ V
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
       INDEX-001))
     (CL:SETQ IOVARIABLES (CONS V IOVARIABLES))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
   (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
    SYM-NORMALIZE-LOGIC-IO-VARIABLES
    (COPY-CONS-LIST-TO-VARIABLES-VECTOR (REVERSE IOVARIABLES)) NULL)
   (CL:LET
    ((SELF (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
     (VALUE (CONJOIN-TWO-PROPOSITIONS OUTERANTECEDENT INNERANTECEDENT))
     (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
     (VALUE INNERCONSEQUENT) (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (NORMALIZE-PROPOSITION
    (CL:AREF
     (CL:THE CL:SIMPLE-VECTOR
      (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
     0))))

;;; (DEFUN NORMALIZE-FORALL-PROPOSITION ...)

(CL:DEFUN NORMALIZE-FORALL-PROPOSITION (SELF)
  (CL:LET*
   ((ANTARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      0))
    (CQARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      1))
    (ANTECEDENT NULL) (CONSEQUENT NULL))
   (CL:WHEN (CL:OR (VARIABLE? ANTARG) (VARIABLE? CQARG))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "ERROR: Can't yet handle propositional variables within FORALL."
       EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-NORMALIZE-ERROR))
     (CL:ERROR
      (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   (CL:SETQ ANTECEDENT ANTARG) (CL:SETQ CONSEQUENT CQARG)
   (CL:LET* ((*EVALUATIONMODE* KWD-NORMALIZE-DESCRIPTION))
    (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
    (NORMALIZE-PROPOSITION ANTECEDENT)
    (NORMALIZE-PROPOSITION CONSEQUENT))
   (CL:WHEN
    (CL:EQ (%PROPOSITION.KIND ANTECEDENT) KWD-NORMALIZE-CONSTANT)
    (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.OPERATOR ANTECEDENT)))
     (CL:COND
      ((CL:EQ TEST-VALUE-000 SGT-NORMALIZE-STELLA-TRUE)
       (CL:WHEN (MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT? SELF)
        (CL:RETURN-FROM NORMALIZE-FORALL-PROPOSITION)))
      ((CL:EQ TEST-VALUE-000 SGT-NORMALIZE-STELLA-FALSE)
       (OVERLAY-WITH-CONSTANT-PROPOSITION SELF TRUE-PROPOSITION)
       (CL:RETURN-FROM NORMALIZE-FORALL-PROPOSITION))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
         TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))
   (CL:LET* ((TEST-VALUE-001 (%PROPOSITION.KIND CONSEQUENT)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-NORMALIZE-FORALL)
      (CL:WHEN (CL:NOT (NATURAL-DEDUCTION-MODE?))
       (FLATTEN-NESTED-FORALL-PROPOSITION SELF)))
     ((CL:EQ TEST-VALUE-001 KWD-NORMALIZE-CONSTANT)
      (CL:LET* ((TEST-VALUE-002 (%PROPOSITION.OPERATOR CONSEQUENT)))
       (CL:COND
        ((CL:EQ TEST-VALUE-002 SGT-NORMALIZE-STELLA-FALSE)
         (OVERLAY-PROPOSITION SELF ANTECEDENT)
         (INVERT-PROPOSITION SELF)
         (CL:RETURN-FROM NORMALIZE-FORALL-PROPOSITION))
        ((CL:EQ TEST-VALUE-002 SGT-NORMALIZE-STELLA-TRUE)
         (OVERLAY-WITH-CONSTANT-PROPOSITION SELF TRUE-PROPOSITION)
         (CL:RETURN-FROM NORMALIZE-FORALL-PROPOSITION))
        (CL:T
         (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002) "`"
           TEST-VALUE-002 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002))))))))
     (CL:T)))
   (CL:WHEN
    (CL:=
     (%VECTOR.ARRAY-SIZE
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
       SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
     0)
    (CL:SETQ ANTECEDENT (INVERT-PROPOSITION ANTECEDENT))
    (OVERLAY-PROPOSITION SELF
     (DISJOIN-PROPOSITIONS (CONS-LIST ANTECEDENT CONSEQUENT)))
    (NORMALIZE-PROPOSITION SELF)
    (CL:RETURN-FROM NORMALIZE-FORALL-PROPOSITION))
   (CL:LET* ((IMPLIESPROPOSITION (DERIVE-IMPLIES-FROM-FORALL SELF)))
    (CL:WHEN (CL:NOT (CL:EQ IMPLIESPROPOSITION NULL))
     (OVERLAY-PROPOSITION SELF IMPLIESPROPOSITION)))))

;;; (DEFUN NORMALIZE-NOT-PROPOSITION ...)

(CL:DEFUN NORMALIZE-NOT-PROPOSITION (SELF)
  (CL:LET*
   ((ARGUMENT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      0))
    (PROPOSITION NULL))
   (CL:WHEN (VARIABLE? ARGUMENT)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "ERROR: Can't yet handle propositional variables within negations."
       EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-NORMALIZE-ERROR))
     (CL:ERROR
      (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   (CL:SETQ PROPOSITION ARGUMENT)
   (CL:WHEN
    (CL:EQ (%PROPOSITION.KIND PROPOSITION) KWD-NORMALIZE-EQUIVALENT)
    (NORMALIZE-PROPOSITION PROPOSITION))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-ISA)
       (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-FUNCTION))
      (CL:IF
       (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? PROPOSITION))
       (OVERLAY-WITH-CONSTANT-PROPOSITION SELF FALSE-PROPOSITION)
       (NORMALIZE-PROPOSITION PROPOSITION)))
     ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-CONSTANT)
      (CL:LET* ((TEST-VALUE-001 (%PROPOSITION.OPERATOR PROPOSITION)))
       (CL:COND
        ((CL:EQ TEST-VALUE-001 SGT-NORMALIZE-STELLA-TRUE)
         (OVERLAY-WITH-CONSTANT-PROPOSITION SELF FALSE-PROPOSITION))
        ((CL:EQ TEST-VALUE-001 SGT-NORMALIZE-STELLA-FALSE)
         (OVERLAY-WITH-CONSTANT-PROPOSITION SELF TRUE-PROPOSITION))
        (CL:T))))
     (CL:T (INVERT-PROPOSITION PROPOSITION)
      (OVERLAY-PROPOSITION SELF PROPOSITION))))))

;;; (DEFUN NORMALIZE-AND-PROPOSITION ...)

(CL:DEFUN NORMALIZE-AND-PROPOSITION (SELF)
  (CL:LET* ((OTHERPROPS NIL) (CONJOIN? CL:NIL) (EXISTSVARIABLES NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:WHEN (VARIABLE? ARG)
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "ERROR: Can't yet handle propositional variables within conjunctions."
         EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-NORMALIZE-ERROR))
       (CL:ERROR
        (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
     (CL:LET* ((CONJUNCT ARG)) (NORMALIZE-PROPOSITION CONJUNCT)
      (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND CONJUNCT)))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-EXISTS)
         (CL:LET*
          ((V NULL)
           (VECTOR-001
            (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS CONJUNCT)
             SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
           (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001))
           (COLLECT-000 NULL))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
          (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
           (CL:SETQ V
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
             INDEX-001))
           (CL:LET* ((FOUND?-000 CL:NIL))
            (CL:LET* ((VAR NULL) (ITER-000 EXISTSVARIABLES))
             (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
              (CL:SETQ VAR (%%VALUE ITER-000))
              (CL:WHEN
               (VARIABLE-EQL? (%PATTERN-VARIABLE.SKOLEM-NAME VAR)
                (%PATTERN-VARIABLE.SKOLEM-NAME V))
               (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
              (CL:SETQ ITER-000 (%%REST ITER-000))))
            (CL:WHEN FOUND?-000 (RENAME-LOGIC-VARIABLE-APART V CL:T)))
           (CL:IF (CL:EQ COLLECT-000 NULL)
            (CL:PROGN (CL:SETQ COLLECT-000 (CONS V NIL))
             (CL:IF (CL:EQ EXISTSVARIABLES NIL)
              (CL:SETQ EXISTSVARIABLES COLLECT-000)
              (ADD-CONS-TO-END-OF-CONS-LIST EXISTSVARIABLES
               COLLECT-000)))
            (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS V NIL))
             (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
           (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
         (CL:SETQ OTHERPROPS
          (CONS
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS CONJUNCT)))
            0)
           OTHERPROPS))
         (CL:SETQ CONJOIN? CL:T))
        ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-AND)
         (CL:SETQ OTHERPROPS (CONS CONJUNCT OTHERPROPS))
         (CL:SETQ CONJOIN? CL:T))
        ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-CONSTANT)
         (CL:COND
          ((CL:EQ (%PROPOSITION.OPERATOR CONJUNCT)
            SGT-NORMALIZE-STELLA-TRUE)
           (CL:SETQ CONJOIN? CL:T)
           (CL:SETQ OTHERPROPS (CONS CONJUNCT OTHERPROPS)))
          ((CL:EQ (%PROPOSITION.OPERATOR CONJUNCT)
            SGT-NORMALIZE-STELLA-FALSE)
           (OVERLAY-WITH-CONSTANT-PROPOSITION SELF FALSE-PROPOSITION)
           (CL:RETURN-FROM NORMALIZE-AND-PROPOSITION))))
        (CL:T
         (CL:LET* ((TEST-VALUE-001 CL:NIL))
          (CL:SETQ TEST-VALUE-001 (CL:NOT CONJOIN?))
          (CL:WHEN TEST-VALUE-001
           (CL:LET* ((FOUND?-001 CL:NIL))
            (CL:LET* ((PROP NULL) (ITER-001 OTHERPROPS))
             (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
              (CL:SETQ PROP (%%VALUE ITER-001))
              (CL:WHEN (DUPLICATE-AND-OR-ARGUMENTS? PROP CONJUNCT)
               (CL:SETQ FOUND?-001 CL:T) (CL:RETURN))
              (CL:SETQ ITER-001 (%%REST ITER-001))))
            (CL:SETQ TEST-VALUE-001 FOUND?-001)))
          (CL:IF TEST-VALUE-001 (CL:SETQ CONJOIN? CL:T)
           (CL:SETQ OTHERPROPS (CONS CONJUNCT OTHERPROPS))))))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:SETQ OTHERPROPS (REVERSE OTHERPROPS))
   (CL:WHEN (CL:NOT (CL:EQ EXISTSVARIABLES NIL))
    (CL:LET*
     ((EXISTSPROPOSITION
       (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-EXISTS 1)))
     (SET-DYNAMIC-SLOT-VALUE
      (%PROPOSITION.DYNAMIC-SLOTS EXISTSPROPOSITION)
      SYM-NORMALIZE-LOGIC-IO-VARIABLES
      (COPY-CONS-LIST-TO-VARIABLES-VECTOR EXISTSVARIABLES) NULL)
     (CL:LET
      ((SELF
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS EXISTSPROPOSITION)))
       (VALUE (CONJOIN-PROPOSITIONS OTHERPROPS)) (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (OVERLAY-PROPOSITION SELF EXISTSPROPOSITION))
    (CL:RETURN-FROM NORMALIZE-AND-PROPOSITION))
   (CL:WHEN (CL:OR CONJOIN? (CL:<= (LENGTH OTHERPROPS) 1))
    (OVERLAY-PROPOSITION SELF (CONJOIN-PROPOSITIONS OTHERPROPS)))))

;;; (DEFUN NORMALIZE-OR-PROPOSITION ...)

(CL:DEFUN NORMALIZE-OR-PROPOSITION (SELF)
  (CL:LET* ((PROPOSITIONS NIL) (DISJOIN? CL:NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:WHEN (VARIABLE? ARG)
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "ERROR: Can't yet handle propositional variables within disjunctions."
         EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-NORMALIZE-ERROR))
       (CL:ERROR
        (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
     (CL:LET* ((DISJUNCT ARG)) (NORMALIZE-PROPOSITION DISJUNCT)
      (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND DISJUNCT)))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-OR)
         (CL:SETQ PROPOSITIONS (CONS DISJUNCT PROPOSITIONS))
         (CL:SETQ DISJOIN? CL:T))
        ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-CONSTANT)
         (CL:COND
          ((CL:EQ (%PROPOSITION.OPERATOR DISJUNCT)
            SGT-NORMALIZE-STELLA-FALSE)
           (CL:SETQ DISJOIN? CL:T))
          ((CL:EQ (%PROPOSITION.OPERATOR DISJUNCT)
            SGT-NORMALIZE-STELLA-TRUE)
           (OVERLAY-WITH-CONSTANT-PROPOSITION SELF TRUE-PROPOSITION)
           (CL:RETURN-FROM NORMALIZE-OR-PROPOSITION))
          (CL:T
           (CL:IF (MEMBER? PROPOSITIONS DISJUNCT)
            (CL:SETQ DISJOIN? CL:T)
            (CL:SETQ PROPOSITIONS (CONS DISJUNCT PROPOSITIONS))))))
        (CL:T
         (CL:LET* ((TEST-VALUE-001 CL:NIL))
          (CL:SETQ TEST-VALUE-001 (CL:NOT DISJOIN?))
          (CL:WHEN TEST-VALUE-001
           (CL:LET* ((FOUND?-000 CL:NIL))
            (CL:LET* ((PROP NULL) (ITER-000 PROPOSITIONS))
             (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
              (CL:SETQ PROP (%%VALUE ITER-000))
              (CL:WHEN (DUPLICATE-AND-OR-ARGUMENTS? PROP DISJUNCT)
               (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
              (CL:SETQ ITER-000 (%%REST ITER-000))))
            (CL:SETQ TEST-VALUE-001 FOUND?-000)))
          (CL:IF TEST-VALUE-001 (CL:SETQ DISJOIN? CL:T)
           (CL:SETQ PROPOSITIONS (CONS DISJUNCT PROPOSITIONS))))))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:WHEN (CL:OR DISJOIN? (CL:<= (LENGTH PROPOSITIONS) 1))
    (OVERLAY-PROPOSITION SELF (DISJOIN-PROPOSITIONS PROPOSITIONS)))))

;;; (DEFUN HELP-NORMALIZE-PREDICATE-PROPOSITION ...)

(CL:DEFUN HELP-NORMALIZE-PREDICATE-PROPOSITION (SELF RELATIONREF PREDICATEARGUMENTS)
  (CL:LET*
   ((OUTPUTARGUMENT (LAST PREDICATEARGUMENTS)) (INPUTARGUMENTS NIL)
    (FUNCTIONPROP NULL) (EQUIVALENCEPROP NULL))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:- (LENGTH PREDICATEARGUMENTS) 2))
     (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY PREDICATEARGUMENTS))
          I)
         NIL))
       (CL:IF (CL:EQ INPUTARGUMENTS NIL)
        (CL:SETQ INPUTARGUMENTS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST INPUTARGUMENTS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY PREDICATEARGUMENTS))
          I)
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETQ FUNCTIONPROP
    (FIND-OR-CREATE-FUNCTION-PROPOSITION RELATIONREF INPUTARGUMENTS))
   (CL:SETQ EQUIVALENCEPROP
    (CREATE-EQUIVALENCE-PROPOSITION
     (LAST (%PROPOSITION.ARGUMENTS FUNCTIONPROP)) OUTPUTARGUMENT))
   (OVERLAY-PROPOSITION SELF EQUIVALENCEPROP)
   (NORMALIZE-PROPOSITION SELF)))

;;; (DEFUN NORMALIZE-HOLDS-PROPOSITION ...)

(CL:DEFUN NORMALIZE-HOLDS-PROPOSITION (SELF)
  (CL:LET*
   ((HOLDSARGUMENTS (%PROPOSITION.ARGUMENTS SELF))
    (RELATIONTERM
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY HOLDSARGUMENTS)) 0))
    (NOFARGUMENTS (CL:1- (LENGTH HOLDSARGUMENTS)))
    (SURROGATE (EVALUATE-RELATION-TERM RELATIONTERM SELF))
    (PREDICATEARGUMENTS (NEW-VECTOR NOFARGUMENTS)) (DESCRIPTION NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFARGUMENTS))
   (CL:WHEN
    (CL:AND (CL:EQ SURROGATE NULL)
     (CL:NOT (ISA? RELATIONTERM SGT-NORMALIZE-LOGIC-DESCRIPTION)))
    (CL:RETURN-FROM NORMALIZE-HOLDS-PROPOSITION))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 NOFARGUMENTS)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY PREDICATEARGUMENTS))
       (VALUE
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY HOLDSARGUMENTS))
         I))
       (POSITION (CL:1- I)))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:COND
    ((CL:NOT (CL:EQ SURROGATE NULL))
     (CL:SETQ DESCRIPTION
      (EVALUATE-PREDICATE SURROGATE
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY HOLDSARGUMENTS))
        1)))
     (CL:COND
      ((CLASS? DESCRIPTION)
       (CL:SETF (%PROPOSITION.KIND SELF) KWD-NORMALIZE-ISA))
      ((FUNCTION? DESCRIPTION)
       (HELP-NORMALIZE-PREDICATE-PROPOSITION SELF
        (%DESCRIPTION.SURROGATE-VALUE-INVERSE DESCRIPTION)
        PREDICATEARGUMENTS)
       (CL:RETURN-FROM NORMALIZE-HOLDS-PROPOSITION)))
     (CL:SETF (%PROPOSITION.OPERATOR SELF)
      (%DESCRIPTION.SURROGATE-VALUE-INVERSE DESCRIPTION))
     (CL:SETF (%PROPOSITION.ARGUMENTS SELF) PREDICATEARGUMENTS)
     (NORMALIZE-PROPOSITION SELF) NULL)
    (CL:T (CL:SETQ DESCRIPTION RELATIONTERM)
     (CL:WHEN (CL:NOT (CL:= (ARITY DESCRIPTION) NOFARGUMENTS))
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "ERROR: Arity violation in HOLDS proposition: `" SELF "'."
         EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-NORMALIZE-ERROR))
       (CL:ERROR
        (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
     (OVERLAY-PROPOSITION SELF
      (CONJOIN-PROPOSITIONS
       (INHERIT-DESCRIPTION-PROPOSITIONS PREDICATEARGUMENTS
        DESCRIPTION)))
     (NORMALIZE-PROPOSITION SELF)))))

;;; (DEFUN NORMALIZE-PREDICATE-PROPOSITION ...)

(CL:DEFUN NORMALIZE-PREDICATE-PROPOSITION (SELF)
  (CL:WHEN
   (CL:EQ (%PROPOSITION.OPERATOR SELF)
    SGT-NORMALIZE-PL-KERNEL-KB-HOLDS)
   (NORMALIZE-HOLDS-PROPOSITION SELF)
   (CL:WHEN
    (CL:NOT
     (CL:EQ (%PROPOSITION.OPERATOR SELF)
      SGT-NORMALIZE-PL-KERNEL-KB-HOLDS))
    (CL:RETURN-FROM NORMALIZE-PREDICATE-PROPOSITION)))
  (CL:WHEN
   (CL:EQ (%PROPOSITION.OPERATOR SELF) SGT-NORMALIZE-STELLA-THING)
   (OVERLAY-PROPOSITION SELF TRUE-PROPOSITION)
   (CL:RETURN-FROM NORMALIZE-PREDICATE-PROPOSITION))
  (CL:LET*
   ((CLAUSE NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
    (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ CLAUSE
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
      INDEX-000))
    (CL:WHEN (ISA? CLAUSE SGT-NORMALIZE-LOGIC-PROPOSITION)
     (NORMALIZE-PROPOSITION CLAUSE))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))

;;; (DEFUN (COMPUTE-RELATION-TERM-SURROGATE SURROGATE) ...)

(CL:DEFUN COMPUTE-RELATION-TERM-SURROGATE (SKOLEM PROPOSITION)
  (CL:LET*
   ((FUNCTIONPROP (%SKOLEM.DEFINING-PROPOSITION SKOLEM))
    (STRING (STRINGIFY (GENERATE-FUNCTION-AS-TERM FUNCTIONPROP)))
    (SURROGATE NULL) (ARITY 0) (ARGUMENTNAMES NULL)
    (ARGUMENTTYPES NULL) (DESCRIPTION NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING)
    (CL:TYPE CL:FIXNUM ARITY))
   (CL:SETQ SURROGATE
    (INTERN-DERIVED-SURROGATE (%PROPOSITION.OPERATOR FUNCTIONPROP)
     STRING))
   (CL:WHEN
    (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SURROGATE) NULL))
    (CL:RETURN-FROM COMPUTE-RELATION-TERM-SURROGATE SURROGATE))
   (CL:COND
    ((TEST-PROPERTY? SKOLEM SGT-NORMALIZE-PL-KERNEL-KB-VARIABLE-ARITY)
     (CL:SETQ ARITY -1))
    ((CL:NOT
      (CL:EQ
       (ACCESS-BINARY-VALUE SKOLEM SGT-NORMALIZE-PL-KERNEL-KB-ARITY)
       NULL))
     (CL:SETQ ARITY
      (%INTEGER-WRAPPER.WRAPPER-VALUE
       (ACCESS-BINARY-VALUE SKOLEM SGT-NORMALIZE-PL-KERNEL-KB-ARITY))))
    (CL:T
     (CL:SETQ ARITY
      (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION))))))
   (CL:COND
    ((CL:= ARITY -1)
     (CL:SETQ ARGUMENTNAMES
      (LIST (YIELD-SYSTEM-DEFINED-PARAMETER-NAME 1 SKOLEM)))
     (CL:SETQ ARGUMENTTYPES (LIST SGT-NORMALIZE-STELLA-THING)))
    (CL:T (CL:SETQ ARGUMENTNAMES (NEW-LIST))
     (CL:SETQ ARGUMENTTYPES (NEW-LIST))
     (CL:LET*
      ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- ARITY)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
      (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
       (CL:SETQ I ITER-000)
       (INSERT ARGUMENTNAMES
        (YIELD-SYSTEM-DEFINED-PARAMETER-NAME I SKOLEM))
       (INSERT ARGUMENTTYPES SGT-NORMALIZE-STELLA-THING)
       (CL:SETQ ITER-000 (CL:1+ ITER-000))))
     (REVERSE ARGUMENTNAMES) (REVERSE ARGUMENTTYPES)))
   (CL:SETQ DESCRIPTION
    (CREATE-PRIMITIVE-DESCRIPTION ARGUMENTNAMES ARGUMENTTYPES
     (< ARITY 0)
     (CL:OR
      (CL:EQ (LOGICAL-TYPE SKOLEM) SGT-NORMALIZE-PL-KERNEL-KB-CLASS)
      (CLASS? SKOLEM))
     (CL:OR
      (CL:EQ (LOGICAL-TYPE SKOLEM) SGT-NORMALIZE-PL-KERNEL-KB-FUNCTION)
      (CL:EQ (%PROPOSITION.OPERATOR PROPOSITION)
       SGT-NORMALIZE-PL-KERNEL-KB-VALUE)
      (FUNCTION? SKOLEM))
     (%SURROGATE.HOME-CONTEXT SURROGATE)))
   (CL:SETF (%SURROGATE.SURROGATE-VALUE SURROGATE) DESCRIPTION)
   (CL:SETF (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE DESCRIPTION)
    SURROGATE)
   (ENSURE-DESCRIPTION-BODY DESCRIPTION) SURROGATE))

;;; (DEFUN (EVALUATE-RELATION-TERM SURROGATE) ...)

(CL:DEFUN EVALUATE-RELATION-TERM (RELATIONTERM PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE RELATIONTERM)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000) (CL:PROGN RELATIONTERM))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-NORMALIZE-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN NULL))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-NORMALIZE-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:WHEN (CL:NOT (FUNCTION-OUTPUT-SKOLEM? RELATIONTERM))
       (CL:RETURN-FROM EVALUATE-RELATION-TERM NULL))
      (CL:LET*
       ((ARGUMENTS
         (%PROPOSITION.ARGUMENTS
          (%SKOLEM.DEFINING-PROPOSITION RELATIONTERM)))
        (RELATIONTERMSURROGATE NULL)
        (RELATIONTERMVALUE (VALUE-OF RELATIONTERM)))
       (CL:LET* ((FOUND?-000 CL:NIL))
        (CL:LET*
         ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
          (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:SETQ ARG
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:WHEN (ISA? ARG SGT-NORMALIZE-LOGIC-PATTERN-VARIABLE)
           (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
        (CL:WHEN FOUND?-000
         (CL:RETURN-FROM EVALUATE-RELATION-TERM NULL)))
       (CL:WHEN (CL:NOT (CL:EQ RELATIONTERMVALUE RELATIONTERM))
        (CL:RETURN-FROM EVALUATE-RELATION-TERM
         (EVALUATE-RELATION-TERM RELATIONTERMVALUE PROPOSITION)))
       (CL:SETQ RELATIONTERMSURROGATE
        (COMPUTE-RELATION-TERM-SURROGATE RELATIONTERM PROPOSITION))
       (TRANSFER-PROPOSITIONS-AND-BACKLINKS RELATIONTERM
        (VALUE-OF RELATIONTERMSURROGATE))
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY ARGUMENTS))
         (VALUE RELATIONTERMSURROGATE)
         (POSITION (CL:1- (LENGTH ARGUMENTS))))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       RELATIONTERMSURROGATE)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-NORMALIZE-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE RELATIONTERM)))
    (CL:T NULL))))

;;; (DEFUN (NORMALIZE-VALUE-FUNCTION PROPOSITION) ...)

(CL:DEFUN NORMALIZE-VALUE-FUNCTION (SELF)
  (CL:LET*
   ((FUNCTIONSURROGATE
     (EVALUATE-RELATION-TERM
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
       0)
      SELF))
    (NEWARGUMENTCOUNT (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS SELF))))
    (NEWPROPOSITION NULL) (DUPLICATE NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NEWARGUMENTCOUNT))
   (CL:WHEN (CL:EQ FUNCTIONSURROGATE NULL)
    (CL:RETURN-FROM NORMALIZE-VALUE-FUNCTION SELF))
   (CL:SETQ NEWPROPOSITION
    (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-FUNCTION
     NEWARGUMENTCOUNT))
   (CL:SETF (%PROPOSITION.OPERATOR NEWPROPOSITION) FUNCTIONSURROGATE)
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 NEWARGUMENTCOUNT)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS NEWPROPOSITION)))
       (VALUE
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
         I))
       (POSITION (CL:1- I)))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:WHEN
    (SKOLEM?
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      (CL:THE CL:FIXNUM
       (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS SELF))))))
    (CL:SETF
     (%SKOLEM.DEFINING-PROPOSITION
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
       (CL:THE CL:FIXNUM
        (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS SELF))))))
     NEWPROPOSITION))
   (CL:WHEN (CL:NOT (DESCRIPTION-MODE?))
    (CL:SETQ DUPLICATE
     (FIND-DUPLICATE-FUNCTION-PROPOSITION NEWPROPOSITION))
    (CL:WHEN (CL:NOT (CL:EQ DUPLICATE NULL))
     (CL:SETQ NEWPROPOSITION DUPLICATE)))
   NEWPROPOSITION))

;;; (DEFUN NORMALIZE-EQUIVALENT-PROPOSITION ...)

(CL:DEFUN NORMALIZE-EQUIVALENT-PROPOSITION (SELF)
  (CL:LET*
   ((FIRSTARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      0))
    (SECONDARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      1)))
   (CL:COND
    ((EQL? FIRSTARG SECONDARG)
     (OVERLAY-WITH-CONSTANT-PROPOSITION SELF TRUE-PROPOSITION))
    ((CL:OR (SKOLEM? FIRSTARG) (SKOLEM? SECONDARG)
      (COLLECTION? FIRSTARG) (COLLECTION? SECONDARG)))
    (CL:T (OVERLAY-WITH-CONSTANT-PROPOSITION SELF FALSE-PROPOSITION)))))

;;; (DEFUN (SHALLOW-COPY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN SHALLOW-COPY-PROPOSITION (SELF)
  (CL:LET* ((COPY (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-AND 0)))
   (CL:WHEN
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
      SYM-NORMALIZE-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS COPY)
     SYM-NORMALIZE-LOGIC-DESCRIPTIVE?
     (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
   (CL:WHEN
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
      SYM-NORMALIZE-LOGIC-DONT-OPTIMIZE? FALSE-WRAPPER))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS COPY)
     SYM-NORMALIZE-LOGIC-DONT-OPTIMIZE?
     (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
   (OVERLAY-PROPOSITION COPY SELF) COPY))

;;; (DEFUN NORMALIZE-PROPOSITION ...)

(CL:DEFUN NORMALIZE-PROPOSITION (SELF)
  (CL:WHEN
   (CL:NOT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (UNFASTENED? SELF)))
   (CL:RETURN-FROM NORMALIZE-PROPOSITION))
  (CL:WHEN (CONTAINS-NESTED-ARGUMENT? SELF)
   (CL:LET* ((PROPOSITION (SHALLOW-COPY-PROPOSITION SELF)))
    (CL:SETQ PROPOSITION
     (FLATTEN-NESTED-FUNCTION-ARGUMENTS PROPOSITION))
    (OVERLAY-PROPOSITION SELF PROPOSITION)))
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-AND)
     (NORMALIZE-AND-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-OR)
     (NORMALIZE-OR-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-NOT)
     (NORMALIZE-NOT-PROPOSITION SELF))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-ISA)
      (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-PREDICATE))
     (NORMALIZE-PREDICATE-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-FUNCTION)
     (CL:LET*
      ((CLAUSE NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ CLAUSE
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:WHEN (ISA? CLAUSE SGT-NORMALIZE-LOGIC-PROPOSITION)
        (NORMALIZE-PROPOSITION CLAUSE))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-EXISTS)
     (NORMALIZE-EXISTS-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-FORALL)
     (NORMALIZE-FORALL-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-EQUIVALENT)
     (NORMALIZE-EQUIVALENT-PROPOSITION SELF))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-IMPLIES)
      (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-FAIL)
      (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-COLLECT-INTO)
      (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-CONSTANT)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN NORMALIZE-TOP-LEVEL-PROPOSITION ...)

(CL:DEFUN NORMALIZE-TOP-LEVEL-PROPOSITION (SELF IOVARIABLES)
  (NORMALIZE-PROPOSITION SELF)
  (CL:WHEN
   (CL:OR (CL:EQ (%PROPOSITION.KIND SELF) KWD-NORMALIZE-FORALL)
    (CL:NOT (CL:EQ IOVARIABLES NULL)))
   (NORMALIZE-TOP-LEVEL-DESCRIPTIVE-PROPOSITION SELF IOVARIABLES)))

;;; (DEFUN NORMALIZE-TOP-LEVEL-DESCRIPTIVE-PROPOSITION ...)

(CL:DEFUN NORMALIZE-TOP-LEVEL-DESCRIPTIVE-PROPOSITION (SELF IOVARIABLES)
  (CL:COND
   ((CL:AND (CL:EQ IOVARIABLES NULL)
     (CL:EQ (%PROPOSITION.KIND SELF) KWD-NORMALIZE-FORALL))
    (CL:LET* ((*EVALUATIONMODE* KWD-NORMALIZE-DESCRIPTION))
     (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
     (CL:LET* ((PROPOSITION NULL))
      (CL:SETQ IOVARIABLES
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
        SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
      (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 1))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
       (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
        (CL:SETQ I ITER-000)
        (CL:SETQ PROPOSITION
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
          I))
        (CL:HANDLER-CASE (EQUATE-TOP-LEVEL-EQUIVALENCES PROPOSITION)
         (CLASH (E)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
           (EXCEPTION-MESSAGE E) EOL)))
        (TIGHTEN-ARGUMENT-BINDINGS PROPOSITION IOVARIABLES)
        (SIMPLIFY-PROPOSITION PROPOSITION)
        (CL:SETQ ITER-000 (CL:1+ ITER-000))))))
    (COLLAPSE-VALUE-OF-CHAINS-FOR-IO-VARIABLES IOVARIABLES))
   ((CL:NOT (CL:EQ IOVARIABLES NULL))
    (CL:LET* ((*EVALUATIONMODE* KWD-NORMALIZE-DESCRIPTION))
     (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
     (CL:HANDLER-CASE (EQUATE-TOP-LEVEL-EQUIVALENCES SELF)
      (CLASH (E)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        (EXCEPTION-MESSAGE E) EOL)))
     (TIGHTEN-ARGUMENT-BINDINGS SELF IOVARIABLES)
     (SIMPLIFY-PROPOSITION SELF)
     (COLLAPSE-VALUE-OF-CHAINS-FOR-IO-VARIABLES IOVARIABLES)))))

;;; (DEFUN INVERT-ATOMIC-PROPOSITION ...)

(CL:DEFUN INVERT-ATOMIC-PROPOSITION (SELF)
  (CL:LET*
   ((NEWATOMICPROPOSITION
     (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-NOT 1))
    (NEWNOTARGUMENTS (%PROPOSITION.ARGUMENTS NEWATOMICPROPOSITION))
    (NEWNOTPROPOSITION SELF))
   (CL:LET
    ((SELF (%VECTOR.THE-ARRAY NEWNOTARGUMENTS))
     (VALUE NEWATOMICPROPOSITION) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%PROPOSITION.KIND NEWATOMICPROPOSITION)
    (%PROPOSITION.KIND SELF))
   (CL:SETF (%PROPOSITION.OPERATOR NEWATOMICPROPOSITION)
    (%PROPOSITION.OPERATOR SELF))
   (CL:SETF (%PROPOSITION.ARGUMENTS NEWATOMICPROPOSITION)
    (%PROPOSITION.ARGUMENTS SELF))
   (CL:WHEN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? SELF))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
     SYM-NORMALIZE-LOGIC-VARIABLE-TYPE? NULL NULL)
    (SET-DYNAMIC-SLOT-VALUE
     (%PROPOSITION.DYNAMIC-SLOTS NEWATOMICPROPOSITION)
     SYM-NORMALIZE-LOGIC-VARIABLE-TYPE? TRUE-WRAPPER NULL))
   (CL:WHEN
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
      SYM-NORMALIZE-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
    (SET-DYNAMIC-SLOT-VALUE
     (%PROPOSITION.DYNAMIC-SLOTS NEWATOMICPROPOSITION)
     SYM-NORMALIZE-LOGIC-DESCRIPTIVE?
     (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
   (CL:SETF (%PROPOSITION.KIND NEWNOTPROPOSITION) KWD-NORMALIZE-NOT)
   (CL:SETF (%PROPOSITION.OPERATOR NEWNOTPROPOSITION)
    SGT-NORMALIZE-LOGIC-NOT)
   (CL:SETF (%PROPOSITION.ARGUMENTS NEWNOTPROPOSITION) NEWNOTARGUMENTS)))

;;; (DEFUN INVERT-EXISTS-PROPOSITION ...)

(CL:DEFUN INVERT-EXISTS-PROPOSITION (SELF)
  (CL:LET*
   ((WHEREPROPOSITION
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      0))
    (NEWARGUMENTS (NEW-VECTOR 2)))
   (FREE (%PROPOSITION.ARGUMENTS SELF))
   (NORMALIZE-PROPOSITION WHEREPROPOSITION)
   (CL:SETQ WHEREPROPOSITION
    (SAFELY-INVERT-PROPOSITION WHEREPROPOSITION))
   (CL:SETF (%PROPOSITION.KIND SELF) KWD-NORMALIZE-FORALL)
   (CL:SETF (%PROPOSITION.OPERATOR SELF) SGT-NORMALIZE-LOGIC-FORALL)
   (CL:LET
    ((SELF (%VECTOR.THE-ARRAY NEWARGUMENTS)) (VALUE TRUE-PROPOSITION)
     (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%VECTOR.THE-ARRAY NEWARGUMENTS)) (VALUE WHEREPROPOSITION)
     (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%PROPOSITION.ARGUMENTS SELF) NEWARGUMENTS)
   (NORMALIZE-PROPOSITION SELF)))

;;; (DEFUN INVERT-FORALL-PROPOSITION ...)

(CL:DEFUN INVERT-FORALL-PROPOSITION (SELF)
  (CL:LET*
   ((ANTECEDENT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      0))
    (CONSEQUENT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      1))
    (NEWARGUMENTS (NEW-VECTOR 1)))
   (FREE (%PROPOSITION.ARGUMENTS SELF))
   (NORMALIZE-PROPOSITION ANTECEDENT)
   (NORMALIZE-PROPOSITION CONSEQUENT)
   (CL:SETQ CONSEQUENT (SAFELY-INVERT-PROPOSITION CONSEQUENT))
   (CL:SETF (%PROPOSITION.KIND SELF) KWD-NORMALIZE-EXISTS)
   (CL:SETF (%PROPOSITION.OPERATOR SELF) SGT-NORMALIZE-LOGIC-EXISTS)
   (CL:LET
    ((SELF (%VECTOR.THE-ARRAY NEWARGUMENTS))
     (VALUE (CONJOIN-TWO-PROPOSITIONS ANTECEDENT CONSEQUENT))
     (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%PROPOSITION.ARGUMENTS SELF) NEWARGUMENTS)
   (NORMALIZE-PROPOSITION SELF)))

;;; (DEFUN (EXTRACT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN EXTRACT-PROPOSITION (SELF MAPPING)
  (CL:LET*
   ((PROPOSITION (%DESCRIPTION.PROPOSITION SELF))
    (EXISTENTIALS
     (CL:IF
      (CL:> (%VECTOR.ARRAY-SIZE (%DESCRIPTION.INTERNAL-VARIABLES SELF))
       0)
      (TOP-LEVEL-EXISTENTIAL-VARIABLES SELF) NIL))
    (EXISTSPROPOSITION
     (CL:IF (CL:NOT (CL:EQ EXISTENTIALS NIL))
      (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-EXISTS 1) NULL)))
   (CL:WHEN (CL:NOT (CL:EQ EXISTSPROPOSITION NULL))
    (SET-DYNAMIC-SLOT-VALUE
     (%PROPOSITION.DYNAMIC-SLOTS EXISTSPROPOSITION)
     SYM-NORMALIZE-LOGIC-IO-VARIABLES
     (COPY-VARIABLES-VECTOR
      (COPY-CONS-LIST-TO-VARIABLES-VECTOR EXISTENTIALS) MAPPING)
     NULL))
   (CL:SETQ PROPOSITION (COPY-PROPOSITION PROPOSITION MAPPING))
   (REMOVE-AT MAPPING (%DESCRIPTION.PROPOSITION SELF))
   (CL:WHEN (CL:NOT (CL:EQ EXISTSPROPOSITION NULL))
    (CL:LET
     ((SELF
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS EXISTSPROPOSITION)))
      (VALUE PROPOSITION) (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:SETQ PROPOSITION EXISTSPROPOSITION))
   PROPOSITION))

;;; (DEFUN INVERT-IMPLIES-PROPOSITION ...)

(CL:DEFUN INVERT-IMPLIES-PROPOSITION (SELF)
  (CL:LET*
   ((ARGUMENTS (%PROPOSITION.ARGUMENTS SELF))
    (ARG1VALUE
     (CL:IF
      (SURROGATE?
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
        0))
      (GET-DESCRIPTION
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
        0))
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
       0)))
    (ARG2VALUE
     (CL:IF
      (SURROGATE?
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
        1))
      (GET-DESCRIPTION
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
        1))
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
       1))))
   (CL:WHEN
    (CL:NOT
     (CL:AND (ISA? ARG1VALUE SGT-NORMALIZE-LOGIC-DESCRIPTION)
      (ISA? ARG2VALUE SGT-NORMALIZE-LOGIC-DESCRIPTION)))
    (INVERT-ATOMIC-PROPOSITION SELF)
    (CL:RETURN-FROM INVERT-IMPLIES-PROPOSITION))
   (CL:LET*
    ((SUBSET ARG1VALUE) (SUPERSET ARG2VALUE) (SUBSETPROP NULL)
     (SUPERSETPROP NULL) (MAPPING (NEW-KEY-VALUE-LIST))
     (NEWARGUMENTS (NEW-VECTOR 1)))
    (CL:SETF (%PROPOSITION.KIND SELF) KWD-NORMALIZE-EXISTS)
    (CL:SETF (%PROPOSITION.OPERATOR SELF) SGT-NORMALIZE-LOGIC-EXISTS)
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
     SYM-NORMALIZE-LOGIC-IO-VARIABLES
     (COPY-VARIABLES-VECTOR (%DESCRIPTION.IO-VARIABLES SUBSET) MAPPING)
     NULL)
    (CL:LET*
     ((IOVAR NULL)
      (VECTOR-000
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
        SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (SUPVAR NULL)
      (VECTOR-001 (%DESCRIPTION.IO-VARIABLES SUPERSET)) (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
      DO
      (CL:SETQ IOVAR
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ SUPVAR
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
        INDEX-001))
      (INSERT-AT MAPPING SUPVAR IOVAR)
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
    (CL:SETQ SUBSETPROP (EXTRACT-PROPOSITION SUBSET MAPPING))
    (CL:SETQ SUPERSETPROP (EXTRACT-PROPOSITION SUPERSET MAPPING))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SUPERSETPROP)
     SYM-NORMALIZE-LOGIC-VARIABLE-TYPE? NULL NULL)
    (INVERT-PROPOSITION SUPERSETPROP)
    (CL:LET
     ((SELF (%VECTOR.THE-ARRAY NEWARGUMENTS))
      (VALUE (CONJOIN-TWO-PROPOSITIONS SUBSETPROP SUPERSETPROP))
      (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:SETF (%PROPOSITION.ARGUMENTS SELF) NEWARGUMENTS)
    (NORMALIZE-PROPOSITION SELF))))

;;; (DEFUN (INVERT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN INVERT-PROPOSITION (SELF)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-ISA)
      (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-EQUIVALENT))
     (INVERT-ATOMIC-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-AND)
     (CL:LET* ((ARGUMENTCOUNT (LENGTH (%PROPOSITION.ARGUMENTS SELF))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM ARGUMENTCOUNT))
      (SIMPLIFY-PROPOSITION SELF)
      (CL:WHEN
       (CL:< (LENGTH (%PROPOSITION.ARGUMENTS SELF)) ARGUMENTCOUNT)
       (CL:RETURN-FROM INVERT-PROPOSITION (INVERT-PROPOSITION SELF))))
     (CL:SETF (%PROPOSITION.KIND SELF) KWD-NORMALIZE-OR)
     (CL:SETF (%PROPOSITION.OPERATOR SELF) SGT-NORMALIZE-LOGIC-OR)
     (CL:LET*
      ((I NULL-INTEGER) (ITER-000 0)
       (UPPER-BOUND-000
        (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS SELF)))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
      (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
       (CL:SETQ I ITER-000)
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
         (VALUE
          (SAFELY-INVERT-PROPOSITION
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
            I)))
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-OR)
     (CL:SETF (%PROPOSITION.KIND SELF) KWD-NORMALIZE-AND)
     (CL:SETF (%PROPOSITION.OPERATOR SELF) SGT-NORMALIZE-LOGIC-AND)
     (CL:LET*
      ((I NULL-INTEGER) (ITER-001 0)
       (UPPER-BOUND-001
        (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS SELF)))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
      (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO
       (CL:SETQ I ITER-001)
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
         (VALUE
          (SAFELY-INVERT-PROPOSITION
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
            I)))
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-001 (CL:1+ ITER-001)))))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-NOT)
     (OVERLAY-PROPOSITION SELF
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
       0))
     (NORMALIZE-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-EXISTS)
     (CL:IF (FUNCTION-INDUCED-EXISTS? SELF)
      (EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS SELF)
      (INVERT-EXISTS-PROPOSITION SELF)))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-FORALL)
     (INVERT-FORALL-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-IMPLIES)
     (INVERT-IMPLIES-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-CONSTANT)
     (CL:LET* ((TEST-VALUE-001 (%PROPOSITION.OPERATOR SELF)))
      (CL:COND
       ((CL:EQ TEST-VALUE-001 SGT-NORMALIZE-STELLA-TRUE)
        (CL:RETURN-FROM INVERT-PROPOSITION FALSE-PROPOSITION))
       ((CL:EQ TEST-VALUE-001 SGT-NORMALIZE-STELLA-FALSE)
        (CL:RETURN-FROM INVERT-PROPOSITION TRUE-PROPOSITION))
       (CL:T
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
          TEST-VALUE-001 "' is not a valid case option")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-FAIL)
     (INVERT-ATOMIC-PROPOSITION SELF))
    (CL:T
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
  SELF)

;;; (DEFUN (SAFELY-INVERT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN SAFELY-INVERT-PROPOSITION (SELF)
  (CL:LET* ((COPY (SHALLOW-COPY-PROPOSITION SELF)))
   (INVERT-PROPOSITION COPY) COPY))

(CL:DEFUN HELP-STARTUP-NORMALIZE1 ()
  (CL:PROGN
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-CUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CUT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-BOUND-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOUND-VARIABLES"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-FORK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORK"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-NORMALIZE-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-NORMALIZE-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 2))
   (CL:SETQ SGT-NORMALIZE-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-NORMALIZE-LOGIC-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 0))
   (CL:SETQ SGT-NORMALIZE-STELLA-CS-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CS-VALUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-NORMALIZE-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-NORMALIZE-LOGIC-DESCRIPTIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTIVE?" NULL 0))
   (CL:SETQ KWD-NORMALIZE-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ SYM-NORMALIZE-STELLA-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-NORMALIZE-LOGIC-WEIGHT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WEIGHT" NULL 0))
   (CL:SETQ SYM-NORMALIZE-LOGIC-NEURAL-NETWORK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEURAL-NETWORK" NULL 0))
   (CL:SETQ SYM-NORMALIZE-LOGIC-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
   (CL:SETQ SYM-NORMALIZE-LOGIC-VARIABLE-TYPE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE?" NULL 0))
   (CL:SETQ KWD-NORMALIZE-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ KWD-NORMALIZE-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ KWD-NORMALIZE-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-NORMALIZE-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ SGT-NORMALIZE-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-NORMALIZE-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ KWD-NORMALIZE-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ KWD-NORMALIZE-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ KWD-NORMALIZE-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-NORMALIZE-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-NORMALIZE-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-NORMALIZE-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-VARIABLE-ARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-ARITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-ARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SYM-NORMALIZE-STELLA-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-NORMALIZE-LOGIC-DONT-OPTIMIZE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-OPTIMIZE?" NULL 0))
   (CL:SETQ KWD-NORMALIZE-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ KWD-NORMALIZE-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ KWD-NORMALIZE-COLLECT-INTO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-INTO" NULL 2))
   (CL:SETQ SYM-NORMALIZE-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-NORMALIZE-LOGIC-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 1))
   (CL:SETQ SYM-NORMALIZE-LOGIC-STARTUP-NORMALIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-NORMALIZE" NULL 0))
   (CL:SETQ SYM-NORMALIZE-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN STARTUP-NORMALIZE ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-NORMALIZE1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "SEARCH-CONTROL-PROPOSITION?"
     "(DEFUN (SEARCH-CONTROL-PROPOSITION? BOOLEAN) ((SELF PROPOSITION)))"
     (CL:FUNCTION SEARCH-CONTROL-PROPOSITION?) NULL)
    (DEFINE-FUNCTION-OBJECT "DUPLICATE-AND-OR-ARGUMENTS?"
     "(DEFUN (DUPLICATE-AND-OR-ARGUMENTS? BOOLEAN) ((PROP1 PROPOSITION) (PROP2 PROPOSITION)))"
     (CL:FUNCTION DUPLICATE-AND-OR-ARGUMENTS?) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-FLAT-CONJUNCTS"
     "(DEFUN COLLECT-FLAT-CONJUNCTS ((SELF PROPOSITION) (FLATCONJUNCTS (LIST OF PROPOSITION))))"
     (CL:FUNCTION COLLECT-FLAT-CONJUNCTS) NULL)
    (DEFINE-FUNCTION-OBJECT "OVERLAY-WITH-CONSTANT-PROPOSITION"
     "(DEFUN OVERLAY-WITH-CONSTANT-PROPOSITION ((SELF PROPOSITION) (CONSTANTPROPOSITION PROPOSITION)))"
     (CL:FUNCTION OVERLAY-WITH-CONSTANT-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "CONJOIN-PROPOSITIONS"
     "(DEFUN (CONJOIN-PROPOSITIONS PROPOSITION) ((CONJUNCTS (CONS OF PROPOSITION))))"
     (CL:FUNCTION CONJOIN-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "CONJOIN-TWO-PROPOSITIONS"
     "(DEFUN (CONJOIN-TWO-PROPOSITIONS PROPOSITION) ((PROP1 PROPOSITION) (PROP2 PROPOSITION)))"
     (CL:FUNCTION CONJOIN-TWO-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-FLAT-DISJUNCTS"
     "(DEFUN COLLECT-FLAT-DISJUNCTS ((SELF PROPOSITION) (FLATDISJUNCTS (LIST OF PROPOSITION))))"
     (CL:FUNCTION COLLECT-FLAT-DISJUNCTS) NULL)
    (DEFINE-FUNCTION-OBJECT "DISJOIN-PROPOSITIONS"
     "(DEFUN (DISJOIN-PROPOSITIONS PROPOSITION) ((DISJUNCTS (CONS OF PROPOSITION))))"
     (CL:FUNCTION DISJOIN-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "RENAME-LOGIC-VARIABLE-APART"
     "(DEFUN (RENAME-LOGIC-VARIABLE-APART PATTERN-VARIABLE) ((VARIABLE PATTERN-VARIABLE) (DESTRUCTIVE? BOOLEAN)))"
     (CL:FUNCTION RENAME-LOGIC-VARIABLE-APART) NULL)
    (DEFINE-FUNCTION-OBJECT "OVERLAY-PROPOSITION"
     "(DEFUN OVERLAY-PROPOSITION ((SELF PROPOSITION) (OVERLAYINGPROP PROPOSITION)))"
     (CL:FUNCTION OVERLAY-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-EXISTS-PROPOSITION"
     "(DEFUN NORMALIZE-EXISTS-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-EXISTS-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT?"
     "(DEFUN (MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT? BOOLEAN) ((SELF PROPOSITION)))"
     (CL:FUNCTION MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT?) NULL)
    (DEFINE-FUNCTION-OBJECT "FLATTEN-NESTED-FORALL-PROPOSITION"
     "(DEFUN FLATTEN-NESTED-FORALL-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION FLATTEN-NESTED-FORALL-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-FORALL-PROPOSITION"
     "(DEFUN NORMALIZE-FORALL-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-FORALL-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-NOT-PROPOSITION"
     "(DEFUN NORMALIZE-NOT-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-NOT-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-AND-PROPOSITION"
     "(DEFUN NORMALIZE-AND-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-AND-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-OR-PROPOSITION"
     "(DEFUN NORMALIZE-OR-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-OR-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-NORMALIZE-PREDICATE-PROPOSITION"
     "(DEFUN HELP-NORMALIZE-PREDICATE-PROPOSITION ((SELF PROPOSITION) (RELATIONREF SURROGATE) (PREDICATEARGUMENTS VECTOR)))"
     (CL:FUNCTION HELP-NORMALIZE-PREDICATE-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-HOLDS-PROPOSITION"
     "(DEFUN NORMALIZE-HOLDS-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-HOLDS-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-PREDICATE-PROPOSITION"
     "(DEFUN NORMALIZE-PREDICATE-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-PREDICATE-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "COMPUTE-RELATION-TERM-SURROGATE"
     "(DEFUN (COMPUTE-RELATION-TERM-SURROGATE SURROGATE) ((SKOLEM SKOLEM) (PROPOSITION PROPOSITION)))"
     (CL:FUNCTION COMPUTE-RELATION-TERM-SURROGATE) NULL)
    (DEFINE-FUNCTION-OBJECT "EVALUATE-RELATION-TERM"
     "(DEFUN (EVALUATE-RELATION-TERM SURROGATE) ((RELATIONTERM OBJECT) (PROPOSITION PROPOSITION)))"
     (CL:FUNCTION EVALUATE-RELATION-TERM) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-VALUE-FUNCTION"
     "(DEFUN (NORMALIZE-VALUE-FUNCTION PROPOSITION) ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-VALUE-FUNCTION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-EQUIVALENT-PROPOSITION"
     "(DEFUN NORMALIZE-EQUIVALENT-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-EQUIVALENT-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "SHALLOW-COPY-PROPOSITION"
     "(DEFUN (SHALLOW-COPY-PROPOSITION PROPOSITION) ((SELF PROPOSITION)))"
     (CL:FUNCTION SHALLOW-COPY-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-PROPOSITION"
     "(DEFUN NORMALIZE-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-TOP-LEVEL-PROPOSITION"
     "(DEFUN NORMALIZE-TOP-LEVEL-PROPOSITION ((SELF PROPOSITION) (IOVARIABLES VARIABLES-VECTOR)))"
     (CL:FUNCTION NORMALIZE-TOP-LEVEL-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT
     "NORMALIZE-TOP-LEVEL-DESCRIPTIVE-PROPOSITION"
     "(DEFUN NORMALIZE-TOP-LEVEL-DESCRIPTIVE-PROPOSITION ((SELF PROPOSITION) (IOVARIABLES VARIABLES-VECTOR)))"
     (CL:FUNCTION NORMALIZE-TOP-LEVEL-DESCRIPTIVE-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "INVERT-ATOMIC-PROPOSITION"
     "(DEFUN INVERT-ATOMIC-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION INVERT-ATOMIC-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "INVERT-EXISTS-PROPOSITION"
     "(DEFUN INVERT-EXISTS-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION INVERT-EXISTS-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "INVERT-FORALL-PROPOSITION"
     "(DEFUN INVERT-FORALL-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION INVERT-FORALL-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "EXTRACT-PROPOSITION"
     "(DEFUN (EXTRACT-PROPOSITION PROPOSITION) ((SELF DESCRIPTION) (MAPPING ENTITY-MAPPING)))"
     (CL:FUNCTION EXTRACT-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "INVERT-IMPLIES-PROPOSITION"
     "(DEFUN INVERT-IMPLIES-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION INVERT-IMPLIES-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "INVERT-PROPOSITION"
     "(DEFUN (INVERT-PROPOSITION PROPOSITION) ((SELF PROPOSITION)))"
     (CL:FUNCTION INVERT-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "SAFELY-INVERT-PROPOSITION"
     "(DEFUN (SAFELY-INVERT-PROPOSITION PROPOSITION) ((SELF PROPOSITION)))"
     (CL:FUNCTION SAFELY-INVERT-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-NORMALIZE"
     "(DEFUN STARTUP-NORMALIZE () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-NORMALIZE) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-NORMALIZE-LOGIC-STARTUP-NORMALIZE)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-NORMALIZE-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupNormalize") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))))
