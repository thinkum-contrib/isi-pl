;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; rules.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-RULES-HEAD NULL)
(CL:DEFVAR SYM-RULES-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR KWD-RULES-TAIL NULL)
(CL:DEFVAR KWD-RULES-AND NULL)
(CL:DEFVAR KWD-RULES-EXISTS NULL)
(CL:DEFVAR KWD-RULES-OR NULL)
(CL:DEFVAR KWD-RULES-FORALL NULL)
(CL:DEFVAR KWD-RULES-ISA NULL)
(CL:DEFVAR KWD-RULES-PREDICATE NULL)
(CL:DEFVAR KWD-RULES-FUNCTION NULL)
(CL:DEFVAR KWD-RULES-NOT NULL)
(CL:DEFVAR KWD-RULES-IMPLIES NULL)
(CL:DEFVAR SGT-RULES-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SGT-RULES-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SYM-RULES-LOGIC-COMPLEMENT-DESCRIPTION NULL)
(CL:DEFVAR SGT-RULES-STELLA-SURROGATE NULL)
(CL:DEFVAR KWD-RULES-ERROR NULL)
(CL:DEFVAR SGT-RULES-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-RULES-STELLA-FALSE NULL)
(CL:DEFVAR SGT-RULES-STELLA-TRUE NULL)
(CL:DEFVAR SYM-RULES-STELLA-FORALL NULL)
(CL:DEFVAR KWD-RULES-DESCRIPTION NULL)
(CL:DEFVAR SYM-RULES-LOGIC-FORWARD-ONLY? NULL)
(CL:DEFVAR KWD-RULES-EXTENSIONAL-ASSERTION NULL)
(CL:DEFVAR SYM-RULES-LOGIC-SATELLITE-PROPOSITIONS NULL)
(CL:DEFVAR SYM-RULES-LOGIC-MASTER-PROPOSITION NULL)
(CL:DEFVAR SYM-RULES-LOGIC-BACKWARD-ONLY? NULL)
(CL:DEFVAR SYM-RULES-LOGIC-DONT-OPTIMIZE? NULL)
(CL:DEFVAR KWD-RULES-POSITIVE NULL)
(CL:DEFVAR KWD-RULES-CONTRAPOSITIVE NULL)
(CL:DEFVAR SYM-RULES-LOGIC-RULES-WITH-DEFERRED-SATELLITES NULL)
(CL:DEFVAR KWD-RULES-NON-PAGING NULL)
(CL:DEFVAR SYM-RULES-LOGIC-DEFERRED-CONTRAPOSITIVES? NULL)
(CL:DEFVAR KWD-RULES-POSITIVE-AND-CONTRAPOSITIVE NULL)
(CL:DEFVAR SYM-RULES-STELLA-TRUE NULL)
(CL:DEFVAR SYM-RULES-LOGIC-KAPPA NULL)
(CL:DEFVAR SYM-RULES-STELLA-EXISTS NULL)
(CL:DEFVAR SYM-RULES-LOGIC-FORWARD-CHAINING-INDICES NULL)
(CL:DEFVAR KWD-RULES-FORWARD NULL)
(CL:DEFVAR KWD-RULES-BACKWARD NULL)
(CL:DEFVAR SGT-RULES-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SYM-RULES-STELLA-GET-RULES NULL)
(CL:DEFVAR KWD-RULES-COMMON-LISP NULL)
(CL:DEFVAR SYM-RULES-LOGIC-DELETE-RULES NULL)
(CL:DEFVAR SYM-RULES-STELLA-PRINT-RULES NULL)
(CL:DEFVAR SYM-RULES-LOGIC-GET-RULE NULL)
(CL:DEFVAR SYM-RULES-LOGIC-FIND-RULE NULL)
(CL:DEFVAR KWD-RULES-ASSERT-TRUE NULL)
(CL:DEFVAR SYM-RULES-LOGIC-ASSERT-RULE NULL)
(CL:DEFVAR KWD-RULES-RETRACT-TRUE NULL)
(CL:DEFVAR SYM-RULES-LOGIC-RETRACT-RULE NULL)
(CL:DEFVAR SYM-RULES-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SYM-RULES-LOGIC-STARTUP-RULES NULL)
(CL:DEFVAR SYM-RULES-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* *REVERSEPOLARITY?* NIL-LIST
  *CYC-KLUDGES-ENABLED?* *CONTEXT* TRUE-WRAPPER FALSE-WRAPPER
  STANDARD-OUTPUT FALSE-PROPOSITION TRUE-PROPOSITION NULL-INTEGER EOL
  NIL))

;;; (DEFUN (FIND-MATCHABLE-GOALS (LIST OF PROPOSITION)) ...)

(CL:DEFUN FIND-MATCHABLE-GOALS (FORALLPROP HEADORTAIL)
  (CL:LET*
   ((INDEX (CL:IF (CL:EQ HEADORTAIL KWD-RULES-HEAD) 1 0))
    (PROPOSITION
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORALLPROP)))
      INDEX))
    (VARIABLES NIL) (RESULTLIST (NEW-LIST)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX))
   (CL:LET*
    ((V NULL)
     (VECTOR-000
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS FORALLPROP)
       SYM-RULES-LOGIC-IO-VARIABLES NULL))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ V
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ VARIABLES (CONS V VARIABLES))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:WHEN (CL:> (LENGTH VARIABLES) 1)
    (CL:COND
     ((CL:EQ HEADORTAIL KWD-RULES-TAIL)
      (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 KWD-RULES-AND)
         (CL:LET*
          ((G NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS PROPOSITION))
           (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
          (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
           (CL:SETQ G
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
             INDEX-001))
           (COLLECT-MATCHING-RULE-GOALS G VARIABLES KWD-RULES-TAIL
            RESULTLIST)
           (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
         (CL:RETURN-FROM FIND-MATCHABLE-GOALS RESULTLIST))
        ((CL:EQ TEST-VALUE-000 KWD-RULES-EXISTS)
         (CL:LET*
          ((EXISTSBODY
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
             0)))
          (CL:WHEN (CL:EQ (%PROPOSITION.KIND EXISTSBODY) KWD-RULES-AND)
           (CL:LET*
            ((G NULL) (VECTOR-002 (%PROPOSITION.ARGUMENTS EXISTSBODY))
             (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)))
            (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
            (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
             (CL:SETQ G
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
               INDEX-002))
             (COLLECT-MATCHING-RULE-GOALS G VARIABLES KWD-RULES-TAIL
              RESULTLIST)
             (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))))
         (CL:RETURN-FROM FIND-MATCHABLE-GOALS RESULTLIST))
        (CL:T))))
     (CL:T)))
   (COLLECT-MATCHING-RULE-GOALS PROPOSITION VARIABLES HEADORTAIL
    RESULTLIST)
   RESULTLIST))

;;; (DEFUN COLLECT-MATCHING-RULE-GOALS ...)

(CL:DEFUN COLLECT-MATCHING-RULE-GOALS (PROPOSITION TOPLEVELVARS HEADORTAIL COLLECTION)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-RULES-AND)
      (CL:EQ TEST-VALUE-000 KWD-RULES-OR))
     (CL:COND
      ((CL:EQ HEADORTAIL KWD-RULES-HEAD)
       (CL:LET*
        ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
         (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ ARG
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
           INDEX-000))
         (COLLECT-MATCHING-RULE-GOALS ARG TOPLEVELVARS HEADORTAIL
          COLLECTION)
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
      ((CL:EQ HEADORTAIL KWD-RULES-TAIL)
       (CL:LET* ((GOALCOUNT (LENGTH COLLECTION)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM GOALCOUNT))
        (CL:LET*
         ((ARG NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS PROPOSITION))
          (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
         (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
          (CL:SETQ ARG
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
            INDEX-001))
          (COLLECT-MATCHING-RULE-GOALS ARG TOPLEVELVARS HEADORTAIL
           COLLECTION)
          (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
        (CL:WHEN (CL:= GOALCOUNT (LENGTH COLLECTION))
         (CL:LET*
          ((ARG NULL) (VECTOR-002 (%PROPOSITION.ARGUMENTS PROPOSITION))
           (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
          (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
           (CL:SETQ ARG
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
             INDEX-002))
           (COLLECT-MATCHING-RULE-GOALS ARG TOPLEVELVARS HEADORTAIL
            COLLECTION)
           (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))))))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
         HEADORTAIL "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    ((CL:EQ TEST-VALUE-000 KWD-RULES-EXISTS)
     (CL:COND
      ((CL:EQ HEADORTAIL KWD-RULES-HEAD)
       (COLLECT-MATCHING-RULE-GOALS
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
         0)
        TOPLEVELVARS HEADORTAIL COLLECTION))
      ((CL:EQ HEADORTAIL KWD-RULES-TAIL)
       (CL:LET*
        ((V NULL)
         (VECTOR-003
          (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
           SYM-RULES-LOGIC-IO-VARIABLES NULL))
         (INDEX-003 0) (LENGTH-003 (LENGTH VECTOR-003)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-003 LENGTH-003))
        (CL:LOOP WHILE (CL:< INDEX-003 LENGTH-003) DO
         (CL:SETQ V
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-003))
           INDEX-003))
         (CL:SETQ TOPLEVELVARS (CONS V TOPLEVELVARS))
         (CL:SETQ INDEX-003 (CL:1+ INDEX-003))))
       (COLLECT-MATCHING-RULE-GOALS
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
         0)
        TOPLEVELVARS HEADORTAIL COLLECTION))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
         HEADORTAIL "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
    ((CL:EQ TEST-VALUE-000 KWD-RULES-FORALL)
     (CL:COND
      ((CL:EQ HEADORTAIL KWD-RULES-HEAD)
       (CL:LET*
        ((V NULL)
         (VECTOR-004
          (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
           SYM-RULES-LOGIC-IO-VARIABLES NULL))
         (INDEX-004 0) (LENGTH-004 (LENGTH VECTOR-004)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-004 LENGTH-004))
        (CL:LOOP WHILE (CL:< INDEX-004 LENGTH-004) DO
         (CL:SETQ V
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-004))
           INDEX-004))
         (CL:SETQ TOPLEVELVARS (CONS V TOPLEVELVARS))
         (CL:SETQ INDEX-004 (CL:1+ INDEX-004))))
       (COLLECT-MATCHING-RULE-GOALS
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
         1)
        TOPLEVELVARS HEADORTAIL COLLECTION))
      ((CL:EQ HEADORTAIL KWD-RULES-TAIL))
      (CL:T
       (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002) "`"
         HEADORTAIL "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-RULES-ISA)
      (CL:EQ TEST-VALUE-000 KWD-RULES-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-RULES-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-RULES-NOT)
      (CL:EQ TEST-VALUE-000 KWD-RULES-IMPLIES))
     (CL:LET* ((TEST-VALUE-001 CL:NIL))
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET*
        ((A NULL) (ITER-000 (EXTRACT-GOAL-ARGUMENTS PROPOSITION)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ A (%%VALUE ITER-000))
         (CL:WHEN
          (CL:NOT
           (CL:OR (MEMBER? TOPLEVELVARS A)
            (CL:NOT (ISA? A SGT-RULES-LOGIC-PATTERN-VARIABLE))))
          (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:SETQ TEST-VALUE-001 ALWAYS?-000))
      (CL:WHEN TEST-VALUE-001
       (CL:SETQ TEST-VALUE-001
        (CL:AND
         (CL:NOT
          (CL:EQ (EXTRACT-GOAL-DESCRIPTION PROPOSITION HEADORTAIL)
           NULL))
         (CL:NOT
          (CL:EQ (%PROPOSITION.OPERATOR PROPOSITION)
           SGT-RULES-PL-KERNEL-KB-HOLDS)))))
      (CL:WHEN TEST-VALUE-001 (INSERT COLLECTION PROPOSITION))))
    (CL:T))))

;;; (DEFUN (ATOMIC-FORALL-ARGUMENT? BOOLEAN) ...)

(CL:DEFUN ATOMIC-FORALL-ARGUMENT? (FORALLPROP HEADORTAIL)
  (ATOMIC-GOAL-PROPOSITION?
   (CL:IF (CL:EQ HEADORTAIL KWD-RULES-HEAD)
    (CL:AREF
     (CL:THE CL:SIMPLE-VECTOR
      (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORALLPROP)))
     1)
    (CL:AREF
     (CL:THE CL:SIMPLE-VECTOR
      (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORALLPROP)))
     0))))

;;; (DEFUN (ATOMIC-GOAL-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN ATOMIC-GOAL-PROPOSITION? (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-RULES-ISA)
      (CL:EQ TEST-VALUE-000 KWD-RULES-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-RULES-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-RULES-IMPLIES))
     (CL:NOT (CL:EQ (EXTRACT-GOAL-DESCRIPTION PROPOSITION NULL) NULL)))
    ((CL:EQ TEST-VALUE-000 KWD-RULES-NOT)
     (CL:NOT
      (CL:EQ
       (EXTRACT-GOAL-DESCRIPTION
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
         0)
        NULL)
       NULL)))
    ((CL:EQ TEST-VALUE-000 KWD-RULES-AND)
     (CL:LET* ((COUNT 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT))
      (CL:LET*
       ((CONJUNCT NULL)
        (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION)) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ CONJUNCT
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:IF
         (CL:AND
          (CL:NOT (CL:EQ (%PROPOSITION.KIND CONJUNCT) KWD-RULES-AND))
          (ATOMIC-GOAL-PROPOSITION? CONJUNCT))
         (CL:SETQ COUNT (CL:1+ COUNT))
         (CL:RETURN-FROM ATOMIC-GOAL-PROPOSITION? CL:NIL))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:= COUNT 1)))
    (CL:T CL:NIL))))

;;; (DEFUN (ATOMIC-GOAL-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN ATOMIC-GOAL-DESCRIPTION? (DESCRIPTION)
  (CL:WHEN (NAMED-DESCRIPTION? DESCRIPTION)
   (CL:RETURN-FROM ATOMIC-GOAL-DESCRIPTION? CL:T))
  (CL:LET*
   ((COMPLEMENT
     (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
      SYM-RULES-LOGIC-COMPLEMENT-DESCRIPTION NULL)))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ COMPLEMENT NULL))
     (NAMED-DESCRIPTION? COMPLEMENT))
    CL:T
    (ATOMIC-GOAL-PROPOSITION? (%DESCRIPTION.PROPOSITION DESCRIPTION)))))

;;; (DEFUN (VARIABLE-ARITY-GOAL-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN VARIABLE-ARITY-GOAL-PROPOSITION? (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-RULES-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-RULES-FUNCTION))
     (CL:LET*
      ((DESCRIPTION (EXTRACT-GOAL-DESCRIPTION PROPOSITION NULL)))
      (CL:RETURN-FROM VARIABLE-ARITY-GOAL-PROPOSITION?
       (CL:AND (CL:NOT (CL:EQ DESCRIPTION NULL))
        (VARIABLE-ARITY? DESCRIPTION)))))
    (CL:T)))
  CL:NIL)

;;; (DEFUN (CHAINABLE-RELATION? BOOLEAN) ...)

(CL:DEFUN CHAINABLE-RELATION? (DESCRIPTION HEADORTAIL)
  (CL:WHEN (CL:EQ HEADORTAIL NULL)
   (CL:RETURN-FROM CHAINABLE-RELATION? CL:T))
  (CL:LET* ((NONPERMITTEDPREDICATES NULL))
   (CL:COND
    ((CL:EQ HEADORTAIL KWD-RULES-TAIL)
     (CL:SETQ NONPERMITTEDPREDICATES
      (GET-QUOTED-TREE
       "((/PL-KERNEL-KB/@HOLDS /PL-KERNEL-KB/@MEMBER-OF /PL-KERNEL-KB/@INSTANCE-OF /PL-KERNEL-KB/@SUBSET-OF @NUMBER-WRAPPER.PLUS @NUMBER-WRAPPER.MINUS @NUMBER-WRAPPER.TIMES @NUMBER-WRAPPER.DIVIDE) \"/LOGIC\")"
       "/LOGIC")))
    ((CL:EQ HEADORTAIL KWD-RULES-HEAD)
     (CL:SETQ NONPERMITTEDPREDICATES
      (GET-QUOTED-TREE
       "((@NUMBER-WRAPPER.PLUS @NUMBER-WRAPPER.MINUS @NUMBER-WRAPPER.TIMES @NUMBER-WRAPPER.DIVIDE) \"/LOGIC\")"
       "/LOGIC")))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" HEADORTAIL "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:NOT
    (MEMBER? NONPERMITTEDPREDICATES
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE DESCRIPTION)))))

;;; (DEFUN (EXTRACT-GOAL-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN EXTRACT-GOAL-DESCRIPTION (GOAL HEADORTAIL)
  (CL:LET* ((ARGUMENTS (%PROPOSITION.ARGUMENTS GOAL)))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND GOAL)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-RULES-ISA)
       (CL:EQ TEST-VALUE-000 KWD-RULES-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-RULES-FUNCTION)
       (CL:EQ TEST-VALUE-000 KWD-RULES-IMPLIES))
      (CL:WHEN
       (ISA? (%PROPOSITION.OPERATOR GOAL) SGT-RULES-STELLA-SURROGATE)
       (CL:LET*
        ((DESCRIPTION (GET-DESCRIPTION (%PROPOSITION.OPERATOR GOAL))))
        (CL:WHEN (CL:EQ DESCRIPTION NULL)
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
            "ERROR: Can't finalize relations because relation `"
            (%SURROGATE.SYMBOL-NAME (%PROPOSITION.OPERATOR GOAL))
            "' is undefined.." EOL)
           (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-RULES-ERROR))
          (CL:ERROR
           (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
        (CL:WHEN (CHAINABLE-RELATION? DESCRIPTION HEADORTAIL)
         (CL:RETURN-FROM EXTRACT-GOAL-DESCRIPTION DESCRIPTION)))))
     ((CL:EQ TEST-VALUE-000 KWD-RULES-NOT)
      (CL:LET*
       ((ARGUMENTDESCRIPTION
         (EXTRACT-GOAL-DESCRIPTION
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) 0)
          HEADORTAIL)))
       (CL:WHEN (CL:NOT (CL:EQ ARGUMENTDESCRIPTION NULL))
        (CL:RETURN-FROM EXTRACT-GOAL-DESCRIPTION
         (GET-COMPLEMENT-OF-GOAL-DESCRIPTION ARGUMENTDESCRIPTION)))))
     (CL:T)))
   NULL))

;;; (DEFUN (EXTRACT-GOAL-ARGUMENTS CONS) ...)

(CL:DEFUN EXTRACT-GOAL-ARGUMENTS (GOAL)
  (CL:LET* ((ARGUMENTS (%PROPOSITION.ARGUMENTS GOAL)))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND GOAL)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-RULES-ISA)
       (CL:EQ TEST-VALUE-000 KWD-RULES-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-RULES-FUNCTION)
       (CL:EQ TEST-VALUE-000 KWD-RULES-IMPLIES))
      (CL:LET* ((RESULT NIL))
       (CL:LET*
        ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ ARG
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG NIL))
           (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
          (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
       RESULT))
     ((CL:EQ TEST-VALUE-000 KWD-RULES-NOT)
      (EXTRACT-GOAL-ARGUMENTS
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
        0)))
     (CL:T NIL)))))

;;; (DEFUN (SUBSTITUTE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN SUBSTITUTE-PROPOSITION (PROPOSITION OUTPROP INPROP)
  (CL:WHEN (CL:EQ PROPOSITION OUTPROP)
   (CL:RETURN-FROM SUBSTITUTE-PROPOSITION INPROP))
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
    (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER)
    (ITER-000 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ ARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
      INDEX-000))
    (CL:SETQ I ITER-000)
    (CL:COND
     ((CL:EQ ARG OUTPROP)
      (CL:LET
       ((SELF (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
        (VALUE INPROP) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE)))
     ((ISA? ARG SGT-RULES-LOGIC-PROPOSITION)
      (SUBSTITUTE-PROPOSITION ARG OUTPROP INPROP)))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
    (CL:SETQ ITER-000 (CL:1+ ITER-000))))
  PROPOSITION)

;;; (DEFUN (EXTRACT-INVERTED-GOAL PROPOSITION) ...)

(CL:DEFUN EXTRACT-INVERTED-GOAL (PROPOSITION GOAL)
  (CL:WHEN (CL:EQ (%PROPOSITION.KIND GOAL) KWD-RULES-NOT)
   (CL:RETURN-FROM EXTRACT-INVERTED-GOAL
    (EXTRACT-INVERTED-GOAL PROPOSITION
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
      0))))
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-RULES-NOT)
     (CL:IF
      (EQUIVALENT-PROPOSITIONS?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
        0)
       GOAL NULL)
      (CL:RETURN-FROM EXTRACT-INVERTED-GOAL PROPOSITION)
      (CL:RETURN-FROM EXTRACT-INVERTED-GOAL
       (EXTRACT-INVERTED-GOAL
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
         0)
        GOAL))))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-RULES-AND)
      (CL:EQ TEST-VALUE-000 KWD-RULES-OR))
     (CL:LET* ((RESULT NULL))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ RESULT (EXTRACT-INVERTED-GOAL ARG GOAL))
        (CL:WHEN (CL:NOT (CL:EQ RESULT NULL))
         (CL:RETURN-FROM EXTRACT-INVERTED-GOAL RESULT))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))))
    (CL:T
     (CL:WHEN (EQUIVALENT-PROPOSITIONS? PROPOSITION GOAL NULL)
      (CL:RETURN-FROM EXTRACT-INVERTED-GOAL PROPOSITION)))))
  NULL)

;;; (DEFUN (INVERT-FORALL-AROUND-GOAL PROPOSITION) ...)

(CL:DEFUN INVERT-FORALL-AROUND-GOAL (FORALLPROP GOAL HEADORTAIL CONTRAPOSITIVE?)
  (CL:LET*
   ((MAPPING (NEW-KEY-VALUE-LIST))
    (INVERTEDFORALL (COPY-PROPOSITION FORALLPROP MAPPING))
    (OLDHEAD
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
      1))
    (OLDTAIL
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
      0))
    (NEWGOAL (LOOKUP MAPPING GOAL))
    (NEWGOALARGUMENTS (EXTRACT-GOAL-ARGUMENTS NEWGOAL))
    (HEADPRIME NULL) (TAILPRIME NULL) (NEWHEAD NULL) (NEWTAIL NULL))
   (CL:WHEN CONTRAPOSITIVE?
    (CL:SETQ OLDHEAD (INVERT-PROPOSITION OLDHEAD))
    (CL:SETQ OLDTAIL (INVERT-PROPOSITION OLDTAIL))
    (CL:SETQ NEWGOAL
     (EXTRACT-INVERTED-GOAL
      (CL:IF (CL:EQ HEADORTAIL KWD-RULES-HEAD) OLDHEAD OLDTAIL)
      NEWGOAL))
    (CL:WHEN (CL:EQ NEWGOAL NULL)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Unable to generate contrapositive rule for goal `" GOAL "'" EOL
      "in `" FORALLPROP "'" EOL)
     (CL:RETURN-FROM INVERT-FORALL-AROUND-GOAL NULL))
    (CL:LET
     ((SELF
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
      (VALUE OLDHEAD) (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET
     ((SELF
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
      (VALUE OLDTAIL) (POSITION 1))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:SETQ OLDHEAD OLDTAIL)
    (CL:SETQ OLDTAIL
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
      0))
    (CL:SETQ HEADORTAIL
     (CL:IF (CL:EQ HEADORTAIL KWD-RULES-HEAD) KWD-RULES-TAIL
      KWD-RULES-HEAD)))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:SETQ TEST-VALUE-000
     (CL:EQ NEWGOAL
      (CL:IF (CL:EQ HEADORTAIL KWD-RULES-HEAD) OLDHEAD OLDTAIL)))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((ALWAYS?-000 CL:T))
      (CL:LET*
       ((ARG NULL) (ITER-000 NEWGOALARGUMENTS) (V NULL)
        (VECTOR-000
         (DYNAMIC-SLOT-VALUE
          (%PROPOSITION.DYNAMIC-SLOTS INVERTEDFORALL)
          SYM-RULES-LOGIC-IO-VARIABLES NULL))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
         (CL:< INDEX-000 LENGTH-000))
        DO (CL:SETQ ARG (%%VALUE ITER-000))
        (CL:SETQ V
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:WHEN (CL:NOT (CL:EQ ARG V)) (CL:SETQ ALWAYS?-000 CL:NIL)
         (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
     (CL:WHEN TEST-VALUE-000
      (CL:SETQ TEST-VALUE-000
       (CL:= (LENGTH NEWGOALARGUMENTS)
        (LENGTH
         (DYNAMIC-SLOT-VALUE
          (%PROPOSITION.DYNAMIC-SLOTS INVERTEDFORALL)
          SYM-RULES-LOGIC-IO-VARIABLES NULL))))))
    (CL:WHEN TEST-VALUE-000
     (CL:RETURN-FROM INVERT-FORALL-AROUND-GOAL INVERTEDFORALL)))
   (CL:COND
    ((CL:EQ HEADORTAIL KWD-RULES-HEAD)
     (CL:SETQ HEADPRIME
      (SUBSTITUTE-PROPOSITION OLDHEAD NEWGOAL FALSE-PROPOSITION))
     (NORMALIZE-PROPOSITION HEADPRIME)
     (CL:IF
      (CL:EQ (%PROPOSITION.OPERATOR HEADPRIME) SGT-RULES-STELLA-FALSE)
      (CL:SETQ NEWTAIL OLDTAIL)
      (CL:PROGN (CL:SETQ OLDTAIL (INVERT-PROPOSITION OLDTAIL))
       (CL:SETQ NEWTAIL
        (DISJOIN-PROPOSITIONS (CONS-LIST OLDTAIL HEADPRIME)))
       (CL:SETQ NEWTAIL (INVERT-PROPOSITION NEWTAIL))
       (NORMALIZE-PROPOSITION NEWTAIL)))
     (CL:LET
      ((SELF
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
       (VALUE NEWTAIL) (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET
      ((SELF
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
       (VALUE NEWGOAL) (POSITION 1))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE)))
    ((CL:EQ HEADORTAIL KWD-RULES-TAIL)
     (CL:SETQ TAILPRIME
      (SUBSTITUTE-PROPOSITION OLDTAIL NEWGOAL TRUE-PROPOSITION))
     (NORMALIZE-PROPOSITION TAILPRIME)
     (CL:IF
      (CL:EQ (%PROPOSITION.OPERATOR TAILPRIME) SGT-RULES-STELLA-TRUE)
      (CL:SETQ NEWHEAD OLDHEAD)
      (CL:LET* ((RESIDUEVARIABLES NIL))
       (CL:SETQ TAILPRIME (INVERT-PROPOSITION TAILPRIME))
       (CL:SETQ NEWHEAD
        (DISJOIN-PROPOSITIONS (CONS-LIST TAILPRIME OLDHEAD)))
       (CL:LET*
        ((VBL NULL)
         (VECTOR-001
          (DYNAMIC-SLOT-VALUE
           (%PROPOSITION.DYNAMIC-SLOTS INVERTEDFORALL)
           SYM-RULES-LOGIC-IO-VARIABLES NULL))
         (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001))
         (COLLECT-000 NULL))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
        (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
         (CL:SETQ VBL
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
           INDEX-001))
         (CL:WHEN (CL:NOT (MEMBER? NEWGOALARGUMENTS VBL))
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS VBL NIL))
            (CL:IF (CL:EQ RESIDUEVARIABLES NIL)
             (CL:SETQ RESIDUEVARIABLES COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST RESIDUEVARIABLES
              COLLECT-000)))
           (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VBL NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
       (CL:WHEN (CL:NOT (CL:EQ RESIDUEVARIABLES NIL))
        (CL:LET*
         ((NESTEDFORALL
           (CREATE-PROPOSITION SYM-RULES-STELLA-FORALL 2)))
         (SET-DYNAMIC-SLOT-VALUE
          (%PROPOSITION.DYNAMIC-SLOTS NESTEDFORALL)
          SYM-RULES-LOGIC-IO-VARIABLES
          (COPY-CONS-LIST-TO-VARIABLES-VECTOR RESIDUEVARIABLES) NULL)
         (CL:LET
          ((SELF
            (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS NESTEDFORALL)))
           (VALUE TRUE-PROPOSITION) (POSITION 0))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:LET
          ((SELF
            (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS NESTEDFORALL)))
           (VALUE NEWHEAD) (POSITION 1))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:SETQ NEWHEAD NESTEDFORALL)))
       (NORMALIZE-PROPOSITION NEWHEAD)))
     (CL:LET
      ((SELF
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
       (VALUE NEWGOAL) (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET
      ((SELF
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
       (VALUE NEWHEAD) (POSITION 1))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" HEADORTAIL "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:LET* ((NEWVARIABLES (EXTRACT-GOAL-ARGUMENTS NEWGOAL)))
    (CL:LET*
     ((V NULL) (ITER-001 NEWVARIABLES) (I NULL-INTEGER) (ITER-002 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ V (%%VALUE ITER-001)) (CL:SETQ I ITER-002)
      (CL:WHEN (CL:NOT (ISA? V SGT-RULES-LOGIC-PATTERN-VARIABLE))
       (CL:LET* ((CONSTANTVBL (CREATE-VARIABLE NULL NULL CL:NIL)))
        (UPDATE-SKOLEM-TYPE CONSTANTVBL (LOGICAL-TYPE V))
        (NTH-SETTER NEWVARIABLES CONSTANTVBL I)
        (CL:COND
         ((CL:EQ HEADORTAIL KWD-RULES-HEAD)
          (CL:LET
           ((SELF
             (%VECTOR.THE-ARRAY
              (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
            (VALUE
             (CONJOIN-TWO-PROPOSITIONS
              (CREATE-EQUIVALENCE-PROPOSITION CONSTANTVBL V)
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (%VECTOR.THE-ARRAY
                 (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
               0)))
            (POSITION 0))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SETF (CL:AREF SELF POSITION) VALUE)))
         ((CL:EQ HEADORTAIL KWD-RULES-TAIL)
          (CL:LET*
           ((NEGATEDEQUIVALENCE
             (CREATE-EQUIVALENCE-PROPOSITION CONSTANTVBL V)))
           (INVERT-PROPOSITION NEGATEDEQUIVALENCE)
           (CL:LET
            ((SELF
              (%VECTOR.THE-ARRAY
               (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
             (VALUE
              (DISJOIN-PROPOSITIONS
               (CONS-LIST NEGATEDEQUIVALENCE
                (CL:AREF
                 (CL:THE CL:SIMPLE-VECTOR
                  (%VECTOR.THE-ARRAY
                   (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
                 1))))
             (POSITION 1))
            (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
             (CL:TYPE CL:FIXNUM POSITION))
            (CL:SETF (CL:AREF SELF POSITION) VALUE))))
         (CL:T
          (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
            HEADORTAIL "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))
        (NORMALIZE-PROPOSITION
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
          0))))
      (CL:SETQ ITER-001 (%%REST ITER-001))
      (CL:SETQ ITER-002 (CL:1+ ITER-002))))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS INVERTEDFORALL)
     SYM-RULES-LOGIC-IO-VARIABLES
     (COPY-CONS-LIST-TO-VARIABLES-VECTOR NEWVARIABLES) NULL))
   (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS INVERTEDFORALL CL:NIL)
   INVERTEDFORALL))

;;; (DEFUN (CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION OBJECT) ...)

(CL:DEFUN CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION (FORALLPROP HEADORTAIL)
  (CL:LET* ((DESCRIPTION (NEW-DESCRIPTION)))
   (CL:SETF (%DESCRIPTION.PROPOSITION DESCRIPTION)
    (CL:AREF
     (CL:THE CL:SIMPLE-VECTOR
      (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORALLPROP)))
     (CL:THE CL:FIXNUM (CL:IF (CL:EQ HEADORTAIL KWD-RULES-HEAD) 1 0))))
   (CL:SETF (%DESCRIPTION.IO-VARIABLES DESCRIPTION)
    (COPY
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS FORALLPROP)
      SYM-RULES-LOGIC-IO-VARIABLES NULL)))
   (CL:LET* ((*EVALUATIONMODE* KWD-RULES-DESCRIPTION))
    (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
    (FINISH-BUILDING-DESCRIPTION DESCRIPTION CL:T))))

;;; (DEFUN MARK-AS-FORWARD-RULE ...)

(CL:DEFUN MARK-AS-FORWARD-RULE (IMPLIESPROP)
  (CL:LET*
   ((HEAD
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS IMPLIESPROP)))
      1)))
   (CL:WHEN
    (CL:AND (CL:NOT (NAMED-DESCRIPTION? HEAD))
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS HEAD)
       SYM-RULES-LOGIC-COMPLEMENT-DESCRIPTION NULL)
      NULL))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS IMPLIESPROP)
     SYM-RULES-LOGIC-FORWARD-ONLY?
     (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))))

;;; (DEFUN DERIVE-ONE-SATELLITE-RULE ...)

(CL:DEFUN DERIVE-ONE-SATELLITE-RULE (MASTERFORALL GOAL HEADORTAIL CONTRAPOSITIVE?)
  (CL:LET*
   ((INVERTEDFORALL NULL) (HEAD NULL) (TAIL NULL)
    (OVERRIDEFORWARDONLY? CL:NIL))
   (CL:WHEN
    (CL:AND (CL:EQ HEADORTAIL KWD-RULES-TAIL)
     (CL:OR
      (CL:NOT
       (ATOMIC-GOAL-PROPOSITION?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS MASTERFORALL)))
         0)))
      (VARIABLE-ARITY-GOAL-PROPOSITION?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS MASTERFORALL)))
        0)))
     (CL:NOT CONTRAPOSITIVE?))
    (DERIVE-COMPLEX-FORWARD-RULE GOAL MASTERFORALL)
    (CL:RETURN-FROM DERIVE-ONE-SATELLITE-RULE))
   (CL:LET* ((*EVALUATIONMODE* KWD-RULES-DESCRIPTION))
    (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
    (CL:SETQ INVERTEDFORALL
     (INVERT-FORALL-AROUND-GOAL MASTERFORALL GOAL HEADORTAIL
      CONTRAPOSITIVE?)))
   (CL:WHEN (CL:EQ INVERTEDFORALL NULL)
    (CL:RETURN-FROM DERIVE-ONE-SATELLITE-RULE))
   (CL:WHEN CONTRAPOSITIVE?
    (CL:COND
     ((CL:EQ HEADORTAIL KWD-RULES-HEAD)
      (CL:SETQ HEADORTAIL KWD-RULES-TAIL))
     ((CL:EQ HEADORTAIL KWD-RULES-TAIL)
      (CL:SETQ HEADORTAIL KWD-RULES-HEAD))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" HEADORTAIL "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:COND
    ((CL:EQ HEADORTAIL KWD-RULES-HEAD)
     (CL:SETQ HEAD
      (EXTRACT-GOAL-DESCRIPTION
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
        1)
       NULL))
     (CL:SETQ TAIL
      (CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION INVERTEDFORALL
       KWD-RULES-TAIL)))
    ((CL:EQ HEADORTAIL KWD-RULES-TAIL)
     (CL:SETQ TAIL
      (EXTRACT-GOAL-DESCRIPTION
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS INVERTEDFORALL)))
        0)
       NULL))
     (CL:SETQ HEAD
      (CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION INVERTEDFORALL
       KWD-RULES-HEAD)))
    (CL:T
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
       "`" HEADORTAIL "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))
   (CL:WHEN
    (CL:AND
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS MASTERFORALL)
       SYM-RULES-LOGIC-FORWARD-ONLY? FALSE-WRAPPER))
     (CL:EQ HEADORTAIL KWD-RULES-HEAD))
    (CL:SETQ OVERRIDEFORWARDONLY?
     (CL:AND (NAMED-DESCRIPTION? HEAD) (NAMED-DESCRIPTION? TAIL)
      (CL:= (ARITY HEAD) (ARITY TAIL))))
    (CL:WHEN (CL:NOT OVERRIDEFORWARDONLY?)
     (CL:RETURN-FROM DERIVE-ONE-SATELLITE-RULE)))
   (CL:LET* ((IMPLIESPROP (CREATE-IMPLIES-PROPOSITION TAIL HEAD)))
    (CL:LET* ((*EVALUATIONMODE* KWD-RULES-EXTENSIONAL-ASSERTION))
     (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
     (CL:LET*
      ((DUPLICATE
        (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS IMPLIESPROP CL:NIL)))
      (CL:COND
       ((CL:NOT (CL:EQ DUPLICATE IMPLIESPROP))
        (CL:SETQ IMPLIESPROP DUPLICATE))
       ((CL:EQ HEADORTAIL KWD-RULES-TAIL)
        (MARK-AS-FORWARD-RULE IMPLIESPROP)))))
    (CL:WHEN (EMPTY? (SATELLITE-PROPOSITIONS MASTERFORALL))
     (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS MASTERFORALL)
      SYM-RULES-LOGIC-SATELLITE-PROPOSITIONS (NEW-LIST) NULL))
    (INSERT-NEW (SATELLITE-PROPOSITIONS MASTERFORALL) IMPLIESPROP)
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS IMPLIESPROP)
     SYM-RULES-LOGIC-MASTER-PROPOSITION MASTERFORALL NULL)
    (CL:WHEN
     (CL:AND
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS MASTERFORALL)
        SYM-RULES-LOGIC-FORWARD-ONLY? FALSE-WRAPPER))
      (CL:NOT OVERRIDEFORWARDONLY?))
     (CL:IF CONTRAPOSITIVE?
      (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS IMPLIESPROP)
       SYM-RULES-LOGIC-BACKWARD-ONLY?
       (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
      (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS IMPLIESPROP)
       SYM-RULES-LOGIC-FORWARD-ONLY?
       (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)))
    (CL:WHEN
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS MASTERFORALL)
       SYM-RULES-LOGIC-BACKWARD-ONLY? FALSE-WRAPPER))
     (CL:IF CONTRAPOSITIVE?
      (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS IMPLIESPROP)
       SYM-RULES-LOGIC-FORWARD-ONLY?
       (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
      (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS IMPLIESPROP)
       SYM-RULES-LOGIC-BACKWARD-ONLY?
       (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)))
    (CL:WHEN
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS MASTERFORALL)
       SYM-RULES-LOGIC-DONT-OPTIMIZE? FALSE-WRAPPER))
     (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS IMPLIESPROP)
      SYM-RULES-LOGIC-DONT-OPTIMIZE?
      (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
     (CL:SETQ TAIL
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS IMPLIESPROP)))
       0))
     (CL:WHEN (CL:EQ (NATIVE-RELATION TAIL) NULL)
      (SET-DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS TAIL)
       SYM-RULES-LOGIC-DONT-OPTIMIZE?
       (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
     (CL:SETQ HEAD
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS IMPLIESPROP)))
       1))
     (CL:WHEN (CL:EQ (NATIVE-RELATION HEAD) NULL)
      (SET-DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS HEAD)
       SYM-RULES-LOGIC-DONT-OPTIMIZE?
       (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))))))

;;; (DEFGLOBAL *LAZY-SATELLITE-RULES?* ...)

(CL:DEFVAR *LAZY-SATELLITE-RULES?* CL:NIL
  "If true, inversion of forall propositions happens lazily.
I.e., satellite rules are generated on-demand during inference only if they
are actually needed.")

;;; (DEFUN (DERIVE-SATELLITE-RULES-FOR-GOAL? BOOLEAN) ...)

(CL:DEFUN DERIVE-SATELLITE-RULES-FOR-GOAL? (FORALLPROP GOALDESCRIPTION DIRECTION LAZYSATELLITES?)
  (FINALIZE-OBJECTS)
  (CL:LET*
   ((CREATEDSATELLITES? CL:NIL) (GOALDESC NULL)
    (POSITIVEONLY? (CL:EQ DIRECTION KWD-RULES-POSITIVE))
    (CONTRAPOSITIVEONLY? (CL:EQ DIRECTION KWD-RULES-CONTRAPOSITIVE)))
   (CL:LET*
    ((*CONTEXT* (%PROPOSITION.HOME-CONTEXT FORALLPROP))
     (*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)))
    (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
    (CL:LET*
     ((GOAL NULL)
      (ITER-000
       (%LIST.THE-CONS-LIST
        (FIND-MATCHABLE-GOALS FORALLPROP KWD-RULES-HEAD))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ GOAL (%%VALUE ITER-000))
      (CL:WHEN
       (CL:OR (CL:EQ GOALDESCRIPTION NULL)
        (CL:EQ GOALDESCRIPTION
         (EXTRACT-GOAL-DESCRIPTION GOAL KWD-RULES-HEAD)))
       (CL:SETQ CREATEDSATELLITES? CL:T)
       (CL:COND
        (LAZYSATELLITES?
         (CL:IF (CL:EQ GOALDESCRIPTION NULL)
          (CL:SETQ GOALDESC
           (EXTRACT-GOAL-DESCRIPTION GOAL KWD-RULES-HEAD))
          (CL:SETQ GOALDESC GOALDESCRIPTION))
         (CL:WHEN
          (CL:EQ
           (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS GOALDESC)
            SYM-RULES-LOGIC-RULES-WITH-DEFERRED-SATELLITES NULL)
           NULL)
          (SET-DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS GOALDESC)
           SYM-RULES-LOGIC-RULES-WITH-DEFERRED-SATELLITES
           (CREATE-SEQUENCE-INDEX KWD-RULES-NON-PAGING NIL) NULL))
         (INSERT
          (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS GOALDESC)
           SYM-RULES-LOGIC-RULES-WITH-DEFERRED-SATELLITES NULL)
          FORALLPROP))
        ((CL:NOT CONTRAPOSITIVEONLY?)
         (DERIVE-ONE-SATELLITE-RULE FORALLPROP GOAL KWD-RULES-HEAD
          CL:NIL)))
       (CL:WHEN
        (CL:AND (CL:NOT POSITIVEONLY?)
         (CL:NOT
          (%BOOLEAN-WRAPPER.WRAPPER-VALUE
           (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS FORALLPROP)
            SYM-RULES-LOGIC-BACKWARD-ONLY? FALSE-WRAPPER)))
         (CL:NOT (ATOMIC-FORALL-ARGUMENT? FORALLPROP KWD-RULES-TAIL)))
        (CL:COND
         (LAZYSATELLITES?
          (SET-DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS GOALDESC)
           SYM-RULES-LOGIC-DEFERRED-CONTRAPOSITIVES? TRUE-WRAPPER
           NULL))
         (CL:T
          (DERIVE-ONE-SATELLITE-RULE FORALLPROP GOAL KWD-RULES-HEAD
           CL:T)))))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:WHEN
     (CL:AND
      (CL:NOT
       (%BOOLEAN-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS FORALLPROP)
         SYM-RULES-LOGIC-BACKWARD-ONLY? FALSE-WRAPPER)))
      (CL:OR (ATOMIC-FORALL-ARGUMENT? FORALLPROP KWD-RULES-TAIL)
       (CL:NOT (ATOMIC-FORALL-ARGUMENT? FORALLPROP KWD-RULES-HEAD))
       (%BOOLEAN-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS FORALLPROP)
         SYM-RULES-LOGIC-FORWARD-ONLY? FALSE-WRAPPER))))
     (CL:LET*
      ((GOAL NULL)
       (ITER-001
        (%LIST.THE-CONS-LIST
         (FIND-MATCHABLE-GOALS FORALLPROP KWD-RULES-TAIL))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ GOAL (%%VALUE ITER-001))
       (CL:WHEN
        (CL:OR (CL:EQ GOALDESCRIPTION NULL)
         (CL:EQ GOALDESCRIPTION
          (EXTRACT-GOAL-DESCRIPTION GOAL KWD-RULES-TAIL)))
        (CL:SETQ CREATEDSATELLITES? CL:T)
        (CL:COND
         (LAZYSATELLITES?
          (CL:IF (CL:EQ GOALDESCRIPTION NULL)
           (CL:SETQ GOALDESC
            (EXTRACT-GOAL-DESCRIPTION GOAL KWD-RULES-TAIL))
           (CL:SETQ GOALDESC GOALDESCRIPTION))
          (CL:WHEN
           (CL:EQ
            (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS GOALDESC)
             SYM-RULES-LOGIC-RULES-WITH-DEFERRED-SATELLITES NULL)
            NULL)
           (SET-DYNAMIC-SLOT-VALUE
            (%DESCRIPTION.DYNAMIC-SLOTS GOALDESC)
            SYM-RULES-LOGIC-RULES-WITH-DEFERRED-SATELLITES
            (CREATE-SEQUENCE-INDEX KWD-RULES-NON-PAGING NIL) NULL))
          (INSERT
           (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS GOALDESC)
            SYM-RULES-LOGIC-RULES-WITH-DEFERRED-SATELLITES NULL)
           FORALLPROP))
         ((CL:NOT CONTRAPOSITIVEONLY?)
          (DERIVE-ONE-SATELLITE-RULE FORALLPROP GOAL KWD-RULES-TAIL
           CL:NIL)))
        (CL:WHEN
         (CL:AND (CL:NOT POSITIVEONLY?)
          (CL:NOT
           (%BOOLEAN-WRAPPER.WRAPPER-VALUE
            (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS FORALLPROP)
             SYM-RULES-LOGIC-FORWARD-ONLY? FALSE-WRAPPER)))
          (CL:NOT (ATOMIC-FORALL-ARGUMENT? FORALLPROP KWD-RULES-HEAD)))
         (CL:COND
          (LAZYSATELLITES?
           (SET-DYNAMIC-SLOT-VALUE
            (%DESCRIPTION.DYNAMIC-SLOTS GOALDESC)
            SYM-RULES-LOGIC-DEFERRED-CONTRAPOSITIVES? TRUE-WRAPPER
            NULL))
          (CL:T
           (DERIVE-ONE-SATELLITE-RULE FORALLPROP GOAL KWD-RULES-TAIL
            CL:T)))))
       (CL:SETQ ITER-001 (%%REST ITER-001)))))
    (CL:WHEN
     (CL:AND CREATEDSATELLITES?
      (CL:NOT
       (CL:EQ
        (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE FORALLPROP)
         (%PROPOSITION.HOME-CONTEXT FORALLPROP) CL:NIL)
        NULL)))
     (CL:LET*
      ((*CONTEXT* (%PROPOSITION.HOME-CONTEXT FORALLPROP))
       (*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)))
      (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
      (CL:LET* ((*INVISIBLEASSERTION?* CL:T))
       (CL:DECLARE (CL:SPECIAL *INVISIBLEASSERTION?*))
       (CL:LET*
        ((SATELLITE NULL)
         (ITER-002
          (%LIST.THE-CONS-LIST (SATELLITE-PROPOSITIONS FORALLPROP))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
         (CL:SETQ SATELLITE (%%VALUE ITER-002))
         (ASSIGN-TRUTH-VALUE SATELLITE
          (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE FORALLPROP)
           (%PROPOSITION.HOME-CONTEXT FORALLPROP) CL:NIL))
         (CL:SETQ ITER-002 (%%REST ITER-002)))))))
    CREATEDSATELLITES?)))

;;; (DEFUN DERIVE-SATELLITE-RULES ...)

(CL:DEFUN DERIVE-SATELLITE-RULES (FORALLPROP)
  (CL:WHEN
   (CL:NOT
    (DERIVE-SATELLITE-RULES-FOR-GOAL? FORALLPROP NULL
     (CL:IF (NATURAL-DEDUCTION-MODE?) KWD-RULES-POSITIVE
      KWD-RULES-POSITIVE-AND-CONTRAPOSITIVE)
     *LAZY-SATELLITE-RULES?*))
   (CL:WHEN *CYC-KLUDGES-ENABLED?*
    (CL:WHEN
     (CL:AND
      (ISA?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORALLPROP)))
        1)
       SGT-RULES-LOGIC-PROPOSITION)
      (CL:EQ
       (%PROPOSITION.KIND
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORALLPROP)))
         1))
       KWD-RULES-EXISTS))
     (CL:RETURN-FROM DERIVE-SATELLITE-RULES)))
   (CL:WARN "PowerLoom can't index the rule:~%   `~A'~%" FORALLPROP)))

;;; (DEFSPECIAL *DERIVE-DEFERRED-SATELLITE-RULES-INVOCATIONS* ...)

(CL:DEFVAR *DERIVE-DEFERRED-SATELLITE-RULES-INVOCATIONS* NULL)

;;; (DEFUN DERIVE-DEFERRED-SATELLITE-RULES ...)

(CL:DEFUN DERIVE-DEFERRED-SATELLITE-RULES (SELF)
  (CL:WHEN *LAZY-SATELLITE-RULES?*
   (CL:LET*
    ((*DERIVE-DEFERRED-SATELLITE-RULES-INVOCATIONS*
      (CL:IF (CL:EQ *DERIVE-DEFERRED-SATELLITE-RULES-INVOCATIONS* NULL)
       (NEW-LIST) *DERIVE-DEFERRED-SATELLITE-RULES-INVOCATIONS*)))
    (CL:DECLARE
     (CL:SPECIAL *DERIVE-DEFERRED-SATELLITE-RULES-INVOCATIONS*))
    (CL:WHEN (MEMB? *DERIVE-DEFERRED-SATELLITE-RULES-INVOCATIONS* SELF)
     (CL:RETURN-FROM DERIVE-DEFERRED-SATELLITE-RULES))
    (INSERT *DERIVE-DEFERRED-SATELLITE-RULES-INVOCATIONS* SELF)
    (CL:WHEN
     (CL:AND
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-RULES-LOGIC-RULES-WITH-DEFERRED-SATELLITES NULL)
       NULL)
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-RULES-LOGIC-COMPLEMENT-DESCRIPTION NULL)
       NULL))
     (CL:RETURN-FROM DERIVE-DEFERRED-SATELLITE-RULES))
    (CL:LET*
     ((QUEUEDRULES
       (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-RULES-LOGIC-RULES-WITH-DEFERRED-SATELLITES NULL))
      (COMPLEMENT
       (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-RULES-LOGIC-COMPLEMENT-DESCRIPTION NULL)))
     (CL:WHEN (CL:NOT (CL:EQ QUEUEDRULES NULL))
      (CL:LET*
       ((FORALLPROP NULL) (ITER-000 (ALLOCATE-ITERATOR QUEUEDRULES)))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ FORALLPROP (%ITERATOR.VALUE ITER-000))
        (DERIVE-SATELLITE-RULES-FOR-GOAL? FORALLPROP SELF
         (CL:IF (CL:EQ COMPLEMENT NULL) KWD-RULES-POSITIVE
          KWD-RULES-POSITIVE-AND-CONTRAPOSITIVE)
         CL:NIL)))
      (CL:WHEN (CL:NOT (CL:EQ COMPLEMENT NULL))
       (SET-DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-RULES-LOGIC-DEFERRED-CONTRAPOSITIVES? NULL NULL))
      (SET-DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
       SYM-RULES-LOGIC-RULES-WITH-DEFERRED-SATELLITES NULL NULL))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ COMPLEMENT NULL))
       (CL:NOT
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS COMPLEMENT)
          SYM-RULES-LOGIC-RULES-WITH-DEFERRED-SATELLITES NULL)
         NULL)))
      (DERIVE-DEFERRED-SATELLITE-RULES COMPLEMENT))))))

;;; (DEFUN DERIVE-DEFERRED-CONTRAPOSITIVE-SATELLITE-RULES ...)

(CL:DEFUN DERIVE-DEFERRED-CONTRAPOSITIVE-SATELLITE-RULES (SELF)
  (CL:WHEN *LAZY-SATELLITE-RULES?*
   (CL:WHEN
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
     (DEFERRED-CONTRAPOSITIVES? SELF))
    (CL:LET* ((MASTERPROPOSITION NULL) (QUEUEDRULES (NEW-LIST)))
     (CL:LET*
      ((PROP NULL)
       (ITER-000
        (ALLOCATE-ITERATOR
         (UNFILTERED-DEPENDENT-IMPLIES-PROPOSITIONS SELF))))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ PROP (%ITERATOR.VALUE ITER-000))
       (CL:WHEN (CL:EQ (%PROPOSITION.KIND PROP) KWD-RULES-IMPLIES)
        (CL:SETQ MASTERPROPOSITION
         (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
          SYM-RULES-LOGIC-MASTER-PROPOSITION NULL))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ MASTERPROPOSITION NULL))
          (CL:NOT (DELETED? MASTERPROPOSITION)))
         (INSERT-NEW QUEUEDRULES MASTERPROPOSITION)))))
     (CL:LET*
      ((FORALLPROP NULL) (ITER-001 (%LIST.THE-CONS-LIST QUEUEDRULES)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ FORALLPROP (%%VALUE ITER-001))
       (DERIVE-SATELLITE-RULES-FOR-GOAL? FORALLPROP SELF
        KWD-RULES-CONTRAPOSITIVE CL:NIL)
       (CL:SETQ ITER-001 (%%REST ITER-001))))))))

;;; (DEFUN (GET-INFERABLE-COMPLEMENT-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN GET-INFERABLE-COMPLEMENT-DESCRIPTION (SELF)
  (CL:LET*
   ((COMPLEMENT
     (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
      SYM-RULES-LOGIC-COMPLEMENT-DESCRIPTION NULL)))
   (CL:WHEN *LAZY-SATELLITE-RULES?*
    (CL:WHEN
     (CL:AND (CL:EQ COMPLEMENT NULL)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (DEFERRED-CONTRAPOSITIVES? SELF)))
     (CL:SETQ COMPLEMENT (GET-COMPLEMENT-OF-GOAL-DESCRIPTION SELF)))
    (CL:WHEN
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
      (DEFERRED-CONTRAPOSITIVES? SELF))
     (DERIVE-DEFERRED-SATELLITE-RULES SELF)
     (SET-DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
      SYM-RULES-LOGIC-DEFERRED-CONTRAPOSITIVES? NULL NULL)))
   COMPLEMENT))

;;; (DEFUN (DERIVE-IMPLIES-FROM-FORALL PROPOSITION) ...)

(CL:DEFUN DERIVE-IMPLIES-FROM-FORALL (FORALLPROP)
  (CL:LET*
   ((HEADS (FIND-MATCHABLE-GOALS FORALLPROP KWD-RULES-HEAD))
    (TAILS (FIND-MATCHABLE-GOALS FORALLPROP KWD-RULES-TAIL))
    (HEADGOAL (FIRST HEADS)) (TAILGOAL (FIRST TAILS))
    (HEADPROPOSITION
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORALLPROP)))
      1))
    (TAILPROPOSITION
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORALLPROP)))
      0)))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:SETQ TEST-VALUE-000 (CL:= (LENGTH HEADS) 1))
    (CL:WHEN TEST-VALUE-000
     (CL:SETQ TEST-VALUE-000 (CL:= (LENGTH TAILS) 1))
     (CL:WHEN TEST-VALUE-000
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET*
        ((HV NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS HEADGOAL))
         (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (TV NULL)
         (VECTOR-001 (%PROPOSITION.ARGUMENTS TAILGOAL)) (INDEX-001 0)
         (LENGTH-001 (LENGTH VECTOR-001)))
        (CL:DECLARE
         (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
        (CL:LOOP WHILE
         (CL:AND (CL:< INDEX-000 LENGTH-000)
          (CL:< INDEX-001 LENGTH-001))
         DO
         (CL:SETQ HV
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ TV
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
           INDEX-001))
         (CL:WHEN
          (CL:NOT
           (CL:AND (EQL? HV TV)
            (ISA? HV SGT-RULES-LOGIC-PATTERN-VARIABLE)))
          (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
       (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
      (CL:WHEN TEST-VALUE-000
       (CL:SETQ TEST-VALUE-000
        (CL:= (LENGTH (%PROPOSITION.ARGUMENTS HEADGOAL))
         (LENGTH (%PROPOSITION.ARGUMENTS TAILGOAL))))
       (CL:WHEN TEST-VALUE-000
        (CL:SETQ TEST-VALUE-000 (CL:EQ (FIRST HEADS) HEADPROPOSITION))
        (CL:WHEN TEST-VALUE-000
         (CL:IF (CL:EQ (FIRST TAILS) TAILPROPOSITION)
          (CL:SETQ TEST-VALUE-000 CL:T)
          (CL:PROGN
           (CL:SETQ TEST-VALUE-000
            (CL:EQ (%PROPOSITION.KIND TAILPROPOSITION) KWD-RULES-AND))
           (CL:WHEN TEST-VALUE-000
            (CL:LET* ((ALWAYS?-001 CL:T))
             (CL:LET*
              ((ARG NULL)
               (VECTOR-002 (%PROPOSITION.ARGUMENTS TAILPROPOSITION))
               (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)))
              (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
              (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
               (CL:SETQ ARG
                (CL:AREF
                 (CL:THE CL:SIMPLE-VECTOR
                  (%VECTOR.THE-ARRAY VECTOR-002))
                 INDEX-002))
               (CL:WHEN (CL:NOT (CL:EQ ARG TAILGOAL))
                (CL:SETQ ALWAYS?-001 CL:NIL) (CL:RETURN))
               (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
             (CL:SETQ TEST-VALUE-000 ALWAYS?-001))))))))))
    (CL:IF TEST-VALUE-000
     (CREATE-IMPLIES-PROPOSITION
      (EXTRACT-GOAL-DESCRIPTION TAILGOAL NULL)
      (EXTRACT-GOAL-DESCRIPTION HEADGOAL NULL))
     NULL))))

;;; (DEFUN (DECONSTRUCT-FORALL-TREE CONS OBJECT CONS) ...)

(CL:DEFUN DECONSTRUCT-FORALL-TREE (FORALLTREE)
  (CL:LET*
   ((ANTECEDENT (%%VALUE (%%REST (%%REST FORALLTREE))))
    (IFCLAUSE (%%VALUE (%%REST ANTECEDENT))))
   (CL:WHEN (CL:EQ IFCLAUSE SYM-RULES-STELLA-TRUE)
    (CL:SETQ IFCLAUSE (GET-QUOTED-TREE "((AND) \"/LOGIC\")" "/LOGIC")))
   (CL:VALUES (%%VALUE (%%REST FORALLTREE)) IFCLAUSE
    (%%VALUE (%%REST (%%REST ANTECEDENT))))))

;;; (DEFUN (CREATE-FORWARD-CHAINING-INDEX FORWARD-CHAINING-INDEX) ...)

(CL:DEFUN CREATE-FORWARD-CHAINING-INDEX (GOAL MASTERFORALL)
  (CL:LET*
   ((INDEX (NEW-FORWARD-CHAINING-INDEX)) (MAPPING (NEW-KEY-VALUE-LIST))
    (FORALLCOPY (COPY-PROPOSITION MASTERFORALL MAPPING))
    (GOALCOPY (LOOKUP MAPPING GOAL)))
   (CL:SETQ FORALLCOPY
    (SUBSTITUTE-PROPOSITION FORALLCOPY GOALCOPY TRUE-PROPOSITION))
   (CL:LET*
    ((IOVARIABLENAMES NULL) (GOALVARIABLELIST (LIST))
     (GOALVARIABLENAMES NIL) (EXISTVARIABLENAMES NIL) (QUERYBODY NULL)
     (CONSEQUENTTREE NULL))
    (CL:LET* ((VALUE-000 NULL) (VALUE-001 NULL) (VALUE-002 NULL))
     (CL:MULTIPLE-VALUE-SETQ (VALUE-000 VALUE-001 VALUE-002)
      (DECONSTRUCT-FORALL-TREE (GENERATE-PROPOSITION FORALLCOPY)))
     (CL:PROGN (CL:SETQ IOVARIABLENAMES VALUE-000)
      (CL:SETQ QUERYBODY VALUE-001)
      (CL:SETQ CONSEQUENTTREE VALUE-002)))
    (COLLECT-FREE-VARIABLES GOAL GOALVARIABLELIST (LIST) (LIST))
    (CL:LET* ((VALUE-003 NIL))
     (CL:LET*
      ((ARG NULL) (ITER-000 (%LIST.THE-CONS-LIST GOALVARIABLELIST))
       (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ ARG (%%VALUE ITER-000))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-000
          (CONS (%PATTERN-VARIABLE.SKOLEM-NAME ARG) NIL))
         (CL:IF (CL:EQ VALUE-003 NIL) (CL:SETQ VALUE-003 COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST VALUE-003 COLLECT-000)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-000)
          (CONS (%PATTERN-VARIABLE.SKOLEM-NAME ARG) NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:SETQ GOALVARIABLENAMES VALUE-003))
    (CL:LET* ((V NULL) (ITER-001 IOVARIABLENAMES) (COLLECT-001 NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ V (%%VALUE ITER-001))
      (CL:WHEN (CL:NOT (SEARCH-CONS-TREE? CONSEQUENTTREE V))
       (CL:IF (CL:EQ COLLECT-001 NULL)
        (CL:PROGN (CL:SETQ COLLECT-001 (CONS V NIL))
         (CL:IF (CL:EQ EXISTVARIABLENAMES NIL)
          (CL:SETQ EXISTVARIABLENAMES COLLECT-001)
          (ADD-CONS-TO-END-OF-CONS-LIST EXISTVARIABLENAMES
           COLLECT-001)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS V NIL))
         (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))
      (CL:SETQ ITER-001 (%%REST ITER-001))))
    (CL:SETQ IOVARIABLENAMES
     (SUBTRACT IOVARIABLENAMES EXISTVARIABLENAMES))
    (CL:SETF (%FORWARD-CHAINING-INDEX.CONSEQUENT INDEX)
     (VALUE-OF
      (CONCEIVE-TERM
       (LIST* SYM-RULES-LOGIC-KAPPA (COPY-CONS-TREE IOVARIABLENAMES)
        (CONS CONSEQUENTTREE NIL)))))
    (CL:SETQ EXISTVARIABLENAMES
     (SUBTRACT EXISTVARIABLENAMES GOALVARIABLENAMES))
    (CL:WHEN (CL:NOT (CL:EQ EXISTVARIABLENAMES NIL))
     (CL:SETQ QUERYBODY
      (LIST* SYM-RULES-STELLA-EXISTS EXISTVARIABLENAMES
       (CONS QUERYBODY NIL))))
    (CL:SETQ IOVARIABLENAMES
     (CONCATENATE GOALVARIABLENAMES IOVARIABLENAMES))
    (CL:SETF (%FORWARD-CHAINING-INDEX.IO-VARIABLES INDEX)
     IOVARIABLENAMES)
    (CL:SETF (%FORWARD-CHAINING-INDEX.QUERY-BODY INDEX) QUERYBODY)
    (CL:LET* ((VALUE-004 NIL))
     (CL:LET* ((V NULL) (ITER-002 IOVARIABLENAMES) (COLLECT-002 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ V (%%VALUE ITER-002))
       (CL:WHEN (CL:NOT (CL:EQ V NULL))
        (CL:IF (CL:EQ COLLECT-002 NULL)
         (CL:PROGN (CL:SETQ COLLECT-002 (CONS NULL NIL))
          (CL:IF (CL:EQ VALUE-004 NIL) (CL:SETQ VALUE-004 COLLECT-002)
           (ADD-CONS-TO-END-OF-CONS-LIST VALUE-004 COLLECT-002)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-002) (CONS NULL NIL))
          (CL:SETQ COLLECT-002 (%%REST COLLECT-002)))))
       (CL:SETQ ITER-002 (%%REST ITER-002))))
     (CL:SETF (%FORWARD-CHAINING-INDEX.INPUT-BINDINGS INDEX)
      VALUE-004)))
   (CL:SETF (%FORWARD-CHAINING-INDEX.FORWARD-GOAL INDEX) GOAL)
   (CL:SETF (%FORWARD-CHAINING-INDEX.MASTER-RULE INDEX) MASTERFORALL)
   (CL:SETF (%FORWARD-CHAINING-INDEX.CACHE-ID INDEX)
    (GENSYM "FWD-QUERY"))
   INDEX))

;;; (DEFUN DERIVE-COMPLEX-FORWARD-RULE ...)

(CL:DEFUN DERIVE-COMPLEX-FORWARD-RULE (GOAL MASTERFORALL)
  (CL:LET*
   ((GOALDESCRIPTION
     (CL:IF (CL:EQ (%PROPOSITION.KIND GOAL) KWD-RULES-NOT)
      (GET-COMPLEMENT-OF-GOAL-DESCRIPTION
       (SURROGATE-TO-DESCRIPTION
        (%PROPOSITION.OPERATOR
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
          0))))
      (SURROGATE-TO-DESCRIPTION (%PROPOSITION.OPERATOR GOAL))))
    (DUPLICATE NULL))
   (CL:LET*
    ((IDX NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST
       (FORWARD-CHAINING-INDICES GOALDESCRIPTION))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ IDX (%%VALUE ITER-000))
     (CL:WHEN (CL:EQ GOAL (%FORWARD-CHAINING-INDEX.FORWARD-GOAL IDX))
      (CL:SETQ DUPLICATE IDX))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:NOT (CL:EQ DUPLICATE NULL))
    (REMOVE (FORWARD-CHAINING-INDICES GOALDESCRIPTION) DUPLICATE))
   (CL:WHEN (CL:EQ (FORWARD-CHAINING-INDICES GOALDESCRIPTION) NIL-LIST)
    (SET-DYNAMIC-SLOT-VALUE
     (%DESCRIPTION.DYNAMIC-SLOTS GOALDESCRIPTION)
     SYM-RULES-LOGIC-FORWARD-CHAINING-INDICES (LIST) NULL))
   (INSERT (FORWARD-CHAINING-INDICES GOALDESCRIPTION)
    (CREATE-FORWARD-CHAINING-INDEX GOAL MASTERFORALL))))

;;; (DEFUN (HELP-GET-FORWARD-CHAINING-RULES (CONS OF PROPOSITION)) ...)

(CL:DEFUN HELP-GET-FORWARD-CHAINING-RULES (DESCRIPTION)
  (CL:LET* ((RULES NIL))
   (CL:LET*
    ((IDX NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (FORWARD-CHAINING-INDICES DESCRIPTION)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ IDX (%%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT (DELETED? (%FORWARD-CHAINING-INDEX.MASTER-RULE IDX)))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000
         (CONS (%FORWARD-CHAINING-INDEX.MASTER-RULE IDX) NIL))
        (CL:IF (CL:EQ RULES NIL) (CL:SETQ RULES COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST RULES COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS (%FORWARD-CHAINING-INDEX.MASTER-RULE IDX) NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   RULES))

;;; (DEFUN (CALL-GET-RULES (CONS OF PROPOSITION)) ...)

(CL:DEFUN CALL-GET-RULES (RELATIONREF)
  (CL:LET* ((DESCRIPTION (GET-DESCRIPTION RELATIONREF)) (RULES NIL))
   (CL:WHEN (CL:EQ DESCRIPTION NULL)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Can't find a relation named `" RELATIONREF "'")
     (CL:ERROR
      (NEW-NO-SUCH-OBJECT-EXCEPTION (THE-STRING-READER STREAM-000)))))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE DESCRIPTION)
      SGT-RULES-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:SETQ RULES
       (CONCATENATE
        (APPLICABLE-RULES-OF-DESCRIPTION DESCRIPTION KWD-RULES-FORWARD
         CL:NIL)
        (APPLICABLE-RULES-OF-DESCRIPTION DESCRIPTION KWD-RULES-BACKWARD
         CL:NIL)
        (HELP-GET-FORWARD-CHAINING-RULES DESCRIPTION)))
      (CL:LET*
       ((COMPLEMENT
         (DYNAMIC-SLOT-VALUE
          (%NAMED-DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
          SYM-RULES-LOGIC-COMPLEMENT-DESCRIPTION NULL)))
       (CL:WHEN (CL:NOT (CL:EQ COMPLEMENT NULL))
        (CL:SETQ RULES
         (CONCATENATE RULES
          (APPLICABLE-RULES-OF-DESCRIPTION COMPLEMENT KWD-RULES-FORWARD
           CL:NIL)
          (APPLICABLE-RULES-OF-DESCRIPTION COMPLEMENT
           KWD-RULES-BACKWARD CL:NIL)
          (HELP-GET-FORWARD-CHAINING-RULES COMPLEMENT)))))))
    (CL:T))
   RULES))

;;; (DEFUN (GET-RULES (CONS OF PROPOSITION)) ...)

(CL:DEFUN %GET-RULES (RELATION)
  "Return the list of rules associated with `relation'."
  (CALL-GET-RULES RELATION))

(CL:DEFMACRO GET-RULES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Return the list of rules associated with `relation'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/GET-RULES|)) (CL:MACRO-FUNCTION (CL:QUOTE GET-RULES)))

;;; (DEFUN DELETE-RULES ...)

(CL:DEFUN %DELETE-RULES (RELATION)
  "Delete the list of rules associated with `relation'.
This function is included mainly for debugging purposes, when
a user wants to verify the behavior of different sets of rules."
  (CL:LET* ((R NULL) (ITER-000 (CALL-GET-RULES RELATION)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ R (%%VALUE ITER-000)) (DESTROY-PROPOSITION R)
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

(CL:DEFMACRO DELETE-RULES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Delete the list of rules associated with `relation'.
This function is included mainly for debugging purposes, when
a user wants to verify the behavior of different sets of rules."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/DELETE-RULES|)) (CL:MACRO-FUNCTION (CL:QUOTE DELETE-RULES)))

;;; (DEFUN PRINT-RULES ...)

(CL:DEFUN %PRINT-RULES (RELATION)
  "Print the list of true rules associated with `relation'."
  (CL:LET*
   ((*CONTEXT* (GET-QUERY-CONTEXT))
    (*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)))
   (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
   (CL:LET* ((RULE NULL) (ITER-000 (CALL-GET-RULES RELATION)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ RULE (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:NOT (DELETED? RULE))
       (CL:IF *REVERSEPOLARITY?* (FALSE? RULE)
        (CL:OR (TRUE? RULE) (FUNCTION-WITH-DEFINED-VALUE? RULE))))
      (PRETTY-PRINT-LOGICAL-FORM RULE STANDARD-OUTPUT)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       EOL EOL))
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

(CL:DEFMACRO PRINT-RULES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Print the list of true rules associated with `relation'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/PRINT-RULES|)) (CL:MACRO-FUNCTION (CL:QUOTE PRINT-RULES)))

;;; (DEFUN PRINT-SATELLITES ...)

(CL:DEFUN PRINT-SATELLITES (FORALLPROP)
  (CL:LET*
   ((RULE NULL)
    (ITER-000
     (%LIST.THE-CONS-LIST (SATELLITE-PROPOSITIONS FORALLPROP))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ RULE (%%VALUE ITER-000))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) RULE
     EOL)
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN (GET-RULE PROPOSITION) ...)

(CL:DEFUN %GET-RULE (RULENAME)
  (CL:LET* ((OBJECT (GET-INSTANCE RULENAME)))
   (CL:WHEN
    (CL:OR (CL:EQ OBJECT NULL)
     (CL:NOT (ISA? OBJECT SGT-RULES-LOGIC-PROPOSITION)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "Can't find a rule named `" RULENAME "'" EOL EOL)
    (CL:RETURN-FROM %GET-RULE NULL))
   OBJECT))

(CL:DEFMACRO GET-RULE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/GET-RULE|)) (CL:MACRO-FUNCTION (CL:QUOTE GET-RULE)))

;;; (DEFUN (FIND-RULE PROPOSITION) ...)

(CL:DEFUN %FIND-RULE (RULENAME)
  "Search for a rule named 'ruleName'.  Like 'get-rule',
but 'find-rule' implicity quotes its input argument."
  (%GET-RULE RULENAME))

(CL:DEFMACRO FIND-RULE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Search for a rule named 'ruleName'.  Like 'get-rule',
but 'find-rule' implicity quotes its input argument."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/FIND-RULE|)) (CL:MACRO-FUNCTION (CL:QUOTE FIND-RULE)))

;;; (DEFUN (ASSERT-RULE PROPOSITION) ...)

(CL:DEFUN %ASSERT-RULE (RULENAME)
  "Set the truth value of the rule named 'ruleName' to 
TRUE.  The proposition having the name 'ruleName' may be
any arbitrary proposition, although we expect that it is probably
a material implication.  (See `retract-rule')."
  (CL:LET* ((PROPOSITION (%GET-RULE RULENAME)))
   (CL:WHEN (CL:EQ PROPOSITION NULL)
    (CL:RETURN-FROM %ASSERT-RULE NULL))
   (UPDATE-PROPOSITION-TRUTH-VALUE PROPOSITION KWD-RULES-ASSERT-TRUE)
   PROPOSITION))

(CL:DEFMACRO ASSERT-RULE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Set the truth value of the rule named 'ruleName' to 
TRUE.  The proposition having the name 'ruleName' may be
any arbitrary proposition, although we expect that it is probably
a material implication.  (See `retract-rule')."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/ASSERT-RULE|)) (CL:MACRO-FUNCTION (CL:QUOTE ASSERT-RULE)))

;;; (DEFUN (RETRACT-RULE PROPOSITION) ...)

(CL:DEFUN %RETRACT-RULE (RULENAME)
  "If it is currently TRUE, set the truth value 
of the rule named 'ruleName' to UNKNOWN  This
command may be used alternately with `assert-rule' to
observe the effects of querying with or without a particular (named) rule
being asserted within the current context. The proposition having the name
'ruleName' may be any arbitrary proposition, although we expect that it is
probably a material implication."
  (CL:LET* ((PROPOSITION (%GET-RULE RULENAME)))
   (CL:WHEN (CL:EQ PROPOSITION NULL)
    (CL:RETURN-FROM %RETRACT-RULE NULL))
   (UPDATE-PROPOSITION-TRUTH-VALUE PROPOSITION KWD-RULES-RETRACT-TRUE)
   PROPOSITION))

(CL:DEFMACRO RETRACT-RULE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "If it is currently TRUE, set the truth value 
of the rule named 'ruleName' to UNKNOWN  This
command may be used alternately with `assert-rule' to
observe the effects of querying with or without a particular (named) rule
being asserted within the current context. The proposition having the name
'ruleName' may be any arbitrary proposition, although we expect that it is
probably a material implication."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/RETRACT-RULE|)) (CL:MACRO-FUNCTION (CL:QUOTE RETRACT-RULE)))

;;; (DEFUN DELETE-RULE-CACHES-ON-RELATION ...)

(CL:DEFUN DELETE-RULE-CACHES-ON-RELATION (RELATION)
  (CL:LET* ((RULE NULL) (ITER-000 (CALL-GET-RULES RELATION)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ RULE (%%VALUE ITER-000))
    (CL:LET*
     ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS RULE))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:SETQ ARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:WHEN (CL:NOT (CL:EQ (%DESCRIPTION.QUERY-PATTERNS ARG) NULL))
       (CL:LET*
        ((IT (ALLOCATE-ITERATOR (%DESCRIPTION.QUERY-PATTERNS ARG))))
        (CL:LOOP WHILE (NEXT? IT) DO (VALUE-SETTER IT NULL))))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN RESET-QUERY-CACHES ...)

(CL:DEFUN RESET-QUERY-CACHES ()
  "Zero out all caches managed by the query optimizer,
so that it will reoptimize subgoal queries upon next invocation."
  (CL:LET* ((SLOT NULL) (ITER-000 (ALL-SLOTS NULL CL:T)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ SLOT (%ITERATOR.VALUE ITER-000))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SLOT)
        SYM-RULES-LOGIC-DESCRIPTION NULL)
       NULL))
     (DELETE-RULE-CACHES-ON-RELATION SLOT))))
  (CL:LET*
   ((DESCRIPTION NULL) (ITER-001 (ALL-NAMED-DESCRIPTIONS NULL CL:T)))
   (CL:LOOP WHILE (NEXT? ITER-001) DO
    (CL:SETQ DESCRIPTION (%ITERATOR.VALUE ITER-001))
    (CL:WHEN
     (CL:NOT
      (CL:EQ (%NAMED-DESCRIPTION.QUERY-PATTERNS DESCRIPTION) NULL))
     (CL:LET*
      ((IT
        (ALLOCATE-ITERATOR
         (%NAMED-DESCRIPTION.QUERY-PATTERNS DESCRIPTION))))
      (CL:LOOP WHILE (NEXT? IT) DO (VALUE-SETTER IT NULL)))))))

(CL:DEFUN HELP-STARTUP-RULES1 ()
  (CL:PROGN
   (CL:SETQ KWD-RULES-HEAD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HEAD" NULL 2))
   (CL:SETQ SYM-RULES-LOGIC-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
   (CL:SETQ KWD-RULES-TAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TAIL" NULL 2))
   (CL:SETQ KWD-RULES-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-RULES-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ KWD-RULES-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-RULES-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ KWD-RULES-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ KWD-RULES-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-RULES-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-RULES-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-RULES-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ SGT-RULES-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-RULES-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SYM-RULES-LOGIC-COMPLEMENT-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT-DESCRIPTION" NULL 0))
   (CL:SETQ SGT-RULES-STELLA-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-RULES-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ SGT-RULES-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SGT-RULES-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-RULES-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-RULES-STELLA-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-RULES-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ SYM-RULES-LOGIC-FORWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-ONLY?" NULL 0))
   (CL:SETQ KWD-RULES-EXTENSIONAL-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIONAL-ASSERTION" NULL 2))
   (CL:SETQ SYM-RULES-LOGIC-SATELLITE-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SATELLITE-PROPOSITIONS" NULL 0))
   (CL:SETQ SYM-RULES-LOGIC-MASTER-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
   (CL:SETQ SYM-RULES-LOGIC-BACKWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD-ONLY?" NULL 0))
   (CL:SETQ SYM-RULES-LOGIC-DONT-OPTIMIZE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-OPTIMIZE?" NULL 0))
   (CL:SETQ KWD-RULES-POSITIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITIVE" NULL 2))
   (CL:SETQ KWD-RULES-CONTRAPOSITIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTRAPOSITIVE" NULL 2))
   (CL:SETQ SYM-RULES-LOGIC-RULES-WITH-DEFERRED-SATELLITES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RULES-WITH-DEFERRED-SATELLITES"
     NULL 0))
   (CL:SETQ KWD-RULES-NON-PAGING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NON-PAGING" NULL 2))
   (CL:SETQ SYM-RULES-LOGIC-DEFERRED-CONTRAPOSITIVES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFERRED-CONTRAPOSITIVES?" NULL
     0))
   (CL:SETQ KWD-RULES-POSITIVE-AND-CONTRAPOSITIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITIVE-AND-CONTRAPOSITIVE" NULL
     2))
   (CL:SETQ SYM-RULES-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-RULES-LOGIC-KAPPA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
   (CL:SETQ SYM-RULES-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-RULES-LOGIC-FORWARD-CHAINING-INDICES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-CHAINING-INDICES" NULL 0))
   (CL:SETQ KWD-RULES-FORWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD" NULL 2))
   (CL:SETQ KWD-RULES-BACKWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD" NULL 2))
   (CL:SETQ SGT-RULES-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SYM-RULES-STELLA-GET-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-RULES"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-RULES-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-RULES-LOGIC-DELETE-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DELETE-RULES" NULL 0))
   (CL:SETQ SYM-RULES-STELLA-PRINT-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-RULES"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-RULES-LOGIC-GET-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-RULE" NULL 0))
   (CL:SETQ SYM-RULES-LOGIC-FIND-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FIND-RULE" NULL 0))
   (CL:SETQ KWD-RULES-ASSERT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
   (CL:SETQ SYM-RULES-LOGIC-ASSERT-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-RULE" NULL 0))
   (CL:SETQ KWD-RULES-RETRACT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-TRUE" NULL 2))
   (CL:SETQ SYM-RULES-LOGIC-RETRACT-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-RULE" NULL 0))
   (CL:SETQ SYM-RULES-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ SYM-RULES-LOGIC-STARTUP-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-RULES" NULL 0))
   (CL:SETQ SYM-RULES-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN STARTUP-RULES ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-RULES1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "FIND-MATCHABLE-GOALS"
     "(DEFUN (FIND-MATCHABLE-GOALS (LIST OF PROPOSITION)) ((FORALLPROP PROPOSITION) (HEADORTAIL KEYWORD)))"
     (CL:FUNCTION FIND-MATCHABLE-GOALS) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-MATCHING-RULE-GOALS"
     "(DEFUN COLLECT-MATCHING-RULE-GOALS ((PROPOSITION PROPOSITION) (TOPLEVELVARS CONS) (HEADORTAIL KEYWORD) (COLLECTION (LIST OF PROPOSITION))))"
     (CL:FUNCTION COLLECT-MATCHING-RULE-GOALS) NULL)
    (DEFINE-FUNCTION-OBJECT "ATOMIC-FORALL-ARGUMENT?"
     "(DEFUN (ATOMIC-FORALL-ARGUMENT? BOOLEAN) ((FORALLPROP PROPOSITION) (HEADORTAIL KEYWORD)))"
     (CL:FUNCTION ATOMIC-FORALL-ARGUMENT?) NULL)
    (DEFINE-FUNCTION-OBJECT "ATOMIC-GOAL-PROPOSITION?"
     "(DEFUN (ATOMIC-GOAL-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)))"
     (CL:FUNCTION ATOMIC-GOAL-PROPOSITION?) NULL)
    (DEFINE-FUNCTION-OBJECT "ATOMIC-GOAL-DESCRIPTION?"
     "(DEFUN (ATOMIC-GOAL-DESCRIPTION? BOOLEAN) ((DESCRIPTION DESCRIPTION)))"
     (CL:FUNCTION ATOMIC-GOAL-DESCRIPTION?) NULL)
    (DEFINE-FUNCTION-OBJECT "VARIABLE-ARITY-GOAL-PROPOSITION?"
     "(DEFUN (VARIABLE-ARITY-GOAL-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)))"
     (CL:FUNCTION VARIABLE-ARITY-GOAL-PROPOSITION?) NULL)
    (DEFINE-FUNCTION-OBJECT "CHAINABLE-RELATION?"
     "(DEFUN (CHAINABLE-RELATION? BOOLEAN) ((DESCRIPTION NAMED-DESCRIPTION) (HEADORTAIL KEYWORD)))"
     (CL:FUNCTION CHAINABLE-RELATION?) NULL)
    (DEFINE-FUNCTION-OBJECT "EXTRACT-GOAL-DESCRIPTION"
     "(DEFUN (EXTRACT-GOAL-DESCRIPTION DESCRIPTION) ((GOAL PROPOSITION) (HEADORTAIL KEYWORD)))"
     (CL:FUNCTION EXTRACT-GOAL-DESCRIPTION) NULL)
    (DEFINE-FUNCTION-OBJECT "EXTRACT-GOAL-ARGUMENTS"
     "(DEFUN (EXTRACT-GOAL-ARGUMENTS CONS) ((GOAL PROPOSITION)))"
     (CL:FUNCTION EXTRACT-GOAL-ARGUMENTS) NULL)
    (DEFINE-FUNCTION-OBJECT "SUBSTITUTE-PROPOSITION"
     "(DEFUN (SUBSTITUTE-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION) (OUTPROP PROPOSITION) (INPROP PROPOSITION)))"
     (CL:FUNCTION SUBSTITUTE-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "EXTRACT-INVERTED-GOAL"
     "(DEFUN (EXTRACT-INVERTED-GOAL PROPOSITION) ((PROPOSITION PROPOSITION) (GOAL PROPOSITION)))"
     (CL:FUNCTION EXTRACT-INVERTED-GOAL) NULL)
    (DEFINE-FUNCTION-OBJECT "INVERT-FORALL-AROUND-GOAL"
     "(DEFUN (INVERT-FORALL-AROUND-GOAL PROPOSITION) ((FORALLPROP PROPOSITION) (GOAL PROPOSITION) (HEADORTAIL KEYWORD) (CONTRAPOSITIVE? BOOLEAN)))"
     (CL:FUNCTION INVERT-FORALL-AROUND-GOAL) NULL)
    (DEFINE-FUNCTION-OBJECT
     "CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION"
     "(DEFUN (CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION OBJECT) ((FORALLPROP PROPOSITION) (HEADORTAIL KEYWORD)))"
     (CL:FUNCTION CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "MARK-AS-FORWARD-RULE"
     "(DEFUN MARK-AS-FORWARD-RULE ((IMPLIESPROP PROPOSITION)))"
     (CL:FUNCTION MARK-AS-FORWARD-RULE) NULL)
    (DEFINE-FUNCTION-OBJECT "DERIVE-ONE-SATELLITE-RULE"
     "(DEFUN DERIVE-ONE-SATELLITE-RULE ((MASTERFORALL PROPOSITION) (GOAL PROPOSITION) (HEADORTAIL KEYWORD) (CONTRAPOSITIVE? BOOLEAN)))"
     (CL:FUNCTION DERIVE-ONE-SATELLITE-RULE) NULL)
    (DEFINE-FUNCTION-OBJECT "DERIVE-SATELLITE-RULES-FOR-GOAL?"
     "(DEFUN (DERIVE-SATELLITE-RULES-FOR-GOAL? BOOLEAN) ((FORALLPROP PROPOSITION) (GOALDESCRIPTION DESCRIPTION) (DIRECTION KEYWORD) (LAZYSATELLITES? BOOLEAN)))"
     (CL:FUNCTION DERIVE-SATELLITE-RULES-FOR-GOAL?) NULL)
    (DEFINE-FUNCTION-OBJECT "DERIVE-SATELLITE-RULES"
     "(DEFUN DERIVE-SATELLITE-RULES ((FORALLPROP PROPOSITION)))"
     (CL:FUNCTION DERIVE-SATELLITE-RULES) NULL)
    (DEFINE-FUNCTION-OBJECT "DERIVE-DEFERRED-SATELLITE-RULES"
     "(DEFUN DERIVE-DEFERRED-SATELLITE-RULES ((SELF DESCRIPTION)))"
     (CL:FUNCTION DERIVE-DEFERRED-SATELLITE-RULES) NULL)
    (DEFINE-FUNCTION-OBJECT
     "DERIVE-DEFERRED-CONTRAPOSITIVE-SATELLITE-RULES"
     "(DEFUN DERIVE-DEFERRED-CONTRAPOSITIVE-SATELLITE-RULES ((SELF DESCRIPTION)))"
     (CL:FUNCTION DERIVE-DEFERRED-CONTRAPOSITIVE-SATELLITE-RULES) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-INFERABLE-COMPLEMENT-DESCRIPTION"
     "(DEFUN (GET-INFERABLE-COMPLEMENT-DESCRIPTION DESCRIPTION) ((SELF DESCRIPTION)))"
     (CL:FUNCTION GET-INFERABLE-COMPLEMENT-DESCRIPTION) NULL)
    (DEFINE-FUNCTION-OBJECT "DERIVE-IMPLIES-FROM-FORALL"
     "(DEFUN (DERIVE-IMPLIES-FROM-FORALL PROPOSITION) ((FORALLPROP PROPOSITION)))"
     (CL:FUNCTION DERIVE-IMPLIES-FROM-FORALL) NULL)
    (DEFINE-FUNCTION-OBJECT "DECONSTRUCT-FORALL-TREE"
     "(DEFUN (DECONSTRUCT-FORALL-TREE CONS OBJECT CONS) ((FORALLTREE CONS)))"
     (CL:FUNCTION DECONSTRUCT-FORALL-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "CREATE-FORWARD-CHAINING-INDEX"
     "(DEFUN (CREATE-FORWARD-CHAINING-INDEX FORWARD-CHAINING-INDEX) ((GOAL PROPOSITION) (MASTERFORALL PROPOSITION)))"
     (CL:FUNCTION CREATE-FORWARD-CHAINING-INDEX) NULL)
    (DEFINE-FUNCTION-OBJECT "DERIVE-COMPLEX-FORWARD-RULE"
     "(DEFUN DERIVE-COMPLEX-FORWARD-RULE ((GOAL PROPOSITION) (MASTERFORALL PROPOSITION)))"
     (CL:FUNCTION DERIVE-COMPLEX-FORWARD-RULE) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-GET-FORWARD-CHAINING-RULES"
     "(DEFUN (HELP-GET-FORWARD-CHAINING-RULES (CONS OF PROPOSITION)) ((DESCRIPTION DESCRIPTION)))"
     (CL:FUNCTION HELP-GET-FORWARD-CHAINING-RULES) NULL)
    (DEFINE-FUNCTION-OBJECT "CALL-GET-RULES"
     "(DEFUN (CALL-GET-RULES (CONS OF PROPOSITION)) ((RELATIONREF OBJECT)))"
     (CL:FUNCTION CALL-GET-RULES) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-RULES"
     "(DEFUN (GET-RULES (CONS OF PROPOSITION)) ((RELATION NAME)) :DOCUMENTATION \"Return the list of rules associated with `relation'.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
     (CL:FUNCTION %GET-RULES) NULL)
    (DEFINE-FUNCTION-OBJECT "DELETE-RULES"
     "(DEFUN DELETE-RULES ((RELATION NAME)) :DOCUMENTATION \"Delete the list of rules associated with `relation'.
This function is included mainly for debugging purposes, when
a user wants to verify the behavior of different sets of rules.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
     (CL:FUNCTION %DELETE-RULES) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-RULES"
     "(DEFUN PRINT-RULES ((RELATION OBJECT)) :DOCUMENTATION \"Print the list of true rules associated with `relation'.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
     (CL:FUNCTION %PRINT-RULES) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-SATELLITES"
     "(DEFUN PRINT-SATELLITES ((FORALLPROP PROPOSITION)))"
     (CL:FUNCTION PRINT-SATELLITES) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-RULE"
     "(DEFUN (GET-RULE PROPOSITION) ((RULENAME NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? TRUE)"
     (CL:FUNCTION %GET-RULE) NULL)
    (DEFINE-FUNCTION-OBJECT "FIND-RULE"
     "(DEFUN (FIND-RULE PROPOSITION) ((RULENAME NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Search for a rule named 'ruleName'.  Like 'get-rule',
but 'find-rule' implicity quotes its input argument.\")"
     (CL:FUNCTION %FIND-RULE) NULL)
    (DEFINE-FUNCTION-OBJECT "ASSERT-RULE"
     "(DEFUN (ASSERT-RULE PROPOSITION) ((RULENAME NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Set the truth value of the rule named 'ruleName' to 
TRUE.  The proposition having the name 'ruleName' may be
any arbitrary proposition, although we expect that it is probably
a material implication.  (See `retract-rule').\")"
     (CL:FUNCTION %ASSERT-RULE) NULL)
    (DEFINE-FUNCTION-OBJECT "RETRACT-RULE"
     "(DEFUN (RETRACT-RULE PROPOSITION) ((RULENAME NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"If it is currently TRUE, set the truth value 
of the rule named 'ruleName' to UNKNOWN  This
command may be used alternately with `assert-rule' to
observe the effects of querying with or without a particular (named) rule
being asserted within the current context. The proposition having the name
'ruleName' may be any arbitrary proposition, although we expect that it is
probably a material implication.\")" (CL:FUNCTION %RETRACT-RULE) NULL)
    (DEFINE-FUNCTION-OBJECT "DELETE-RULE-CACHES-ON-RELATION"
     "(DEFUN DELETE-RULE-CACHES-ON-RELATION ((RELATION RELATION)))"
     (CL:FUNCTION DELETE-RULE-CACHES-ON-RELATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RESET-QUERY-CACHES"
     "(DEFUN RESET-QUERY-CACHES () :DOCUMENTATION \"Zero out all caches managed by the query optimizer,
so that it will reoptimize subgoal queries upon next invocation.\")"
     (CL:FUNCTION RESET-QUERY-CACHES) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-RULES"
     "(DEFUN STARTUP-RULES () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-RULES) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-RULES-LOGIC-STARTUP-RULES)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-RULES-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupRules") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LAZY-SATELLITE-RULES?* BOOLEAN FALSE :DOCUMENTATION \"If true, inversion of forall propositions happens lazily.
I.e., satellite rules are generated on-demand during inference only if they
are actually needed.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DERIVE-DEFERRED-SATELLITE-RULES-INVOCATIONS* (LIST OF DESCRIPTION) NULL)")
    (REGISTER-NATIVE-NAME SYM-RULES-STELLA-GET-RULES
     KWD-RULES-COMMON-LISP KWD-RULES-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-RULES-LOGIC-DELETE-RULES
     KWD-RULES-COMMON-LISP KWD-RULES-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-RULES-STELLA-PRINT-RULES
     KWD-RULES-COMMON-LISP KWD-RULES-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-RULES-LOGIC-GET-RULE
     KWD-RULES-COMMON-LISP KWD-RULES-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-RULES-LOGIC-FIND-RULE
     KWD-RULES-COMMON-LISP KWD-RULES-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-RULES-LOGIC-ASSERT-RULE
     KWD-RULES-COMMON-LISP KWD-RULES-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-RULES-LOGIC-RETRACT-RULE
     KWD-RULES-COMMON-LISP KWD-RULES-FUNCTION))))
