;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997-2000              | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-SPECIALIZE-LOGIC-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-PROPOSITION-CURSOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-KIND-OF-PROPOSITION NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-RELATION-OF-PROPOSITION NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-SPECIALIZING-RELATIONS NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-VARIABLE-VALUE-INVERSE-STACK NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-TRUE-DEPENDENT-PROPOSITIONS-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-SUBSUMPTION-TEST-FILTER? NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-RETURN-ARGUMENT-INDEX NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-REFERENCE-PROPOSITION NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-ITERATOR-VALUE-HOLDS-BY-DEFAULT? NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-DESCRIPTION-EXTENSION-ITERATOR NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SYM-SPECIALIZE-STELLA-PREDICATE NULL)
(CL:DEFVAR KWD-SPECIALIZE-FUNCTION NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-TEST-PROPERTY?-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-TEST-ISA?-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-ACCESS-BINARY-VALUE-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-COLLECTION-OF NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-TRANSITIVE-CLOSURE-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-ALLOCATE-ADJACENCY-ITERATOR-FUNCTION NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-FILTER? NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-ADJACENCY-ITERATOR-STACK NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-BEEN-THERE-LIST NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-DIRECTLY-LINKED-OBJECTS-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-INVERSE? NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-REFERENCE-INSTANCE NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR KWD-SPECIALIZE-IMPLIES NULL)
(CL:DEFVAR KWD-SPECIALIZE-ISA NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-MEMBER-OF NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-SKOLEM NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SYM-SPECIALIZE-STELLA-TAXONOMY-NODE NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-STARTUP-SPECIALIZE NULL)
(CL:DEFVAR SYM-SPECIALIZE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* STANDARD-OUTPUT EOL *CONTEXT*
  *MEMOIZATION-ENABLED?* MEMOIZED-NULL-VALUE NIL-PAGING-INDEX
  NIL-NON-PAGING-INDEX *QUERYITERATOR* *DONTUSEDEFAULTKNOWLEDGE?*
  *REVERSEPOLARITY?* TRUE-WRAPPER FALSE-WRAPPER))

;;; (DEFCLASS ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR ...)

(CL:DEFCLASS ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR (ITERATOR)
  ((PROPOSITION-CURSOR :ALLOCATION :INSTANCE :ACCESSOR
    %PROPOSITION-CURSOR)
   (KIND-OF-PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR
    %KIND-OF-PROPOSITION)
   (RELATION-OF-PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR
    %RELATION-OF-PROPOSITION)
   (SPECIALIZING-RELATIONS :DOCUMENTATION
    "If non-NULL a list of relations specializing `relation-of-proposition'."
    :ALLOCATION :INSTANCE :ACCESSOR %SPECIALIZING-RELATIONS)
   (VARIABLE-VALUE-INVERSE-STACK :ALLOCATION :INSTANCE :ACCESSOR
    %VARIABLE-VALUE-INVERSE-STACK)))

(CL:DEFUN NEW-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE
     (CL:QUOTE ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) TRUE) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE-STACK SELF) NIL)
   (CL:SETF (%SPECIALIZING-RELATIONS SELF) NULL)
   (CL:SETF (%RELATION-OF-PROPOSITION SELF) NULL)
   (CL:SETF (%KIND-OF-PROPOSITION SELF) NULL)
   (CL:SETF (%PROPOSITION-CURSOR SELF) NIL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR))
  SGT-SPECIALIZE-LOGIC-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR)

(CL:DEFUN ACCESS-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-PROPOSITION-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%PROPOSITION-CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%PROPOSITION-CURSOR SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-KIND-OF-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%KIND-OF-PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%KIND-OF-PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-RELATION-OF-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%RELATION-OF-PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%RELATION-OF-PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-SPECIALIZING-RELATIONS)
    (CL:IF SETVALUE? (CL:SETF (%SPECIALIZING-RELATIONS SELF) VALUE)
     (CL:SETQ VALUE (%SPECIALIZING-RELATIONS SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-VARIABLE-VALUE-INVERSE-STACK)
    (CL:IF SETVALUE? (CL:SETF (%VARIABLE-VALUE-INVERSE-STACK SELF) VALUE)
     (CL:SETQ VALUE (%VARIABLE-VALUE-INVERSE-STACK SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFCLASS TRUE-DEPENDENT-PROPOSITIONS-ITERATOR ...)

(CL:DEFCLASS TRUE-DEPENDENT-PROPOSITIONS-ITERATOR (ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR)
  ((SUBSUMPTION-TEST-FILTER? :ALLOCATION :INSTANCE :ACCESSOR
    %SUBSUMPTION-TEST-FILTER?)
   (RETURN-ARGUMENT-INDEX :ALLOCATION :INSTANCE :ACCESSOR
    %RETURN-ARGUMENT-INDEX)
   (REFERENCE-PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR
    %REFERENCE-PROPOSITION)
   (ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? :DOCUMENTATION
    "If TRUE, an iterator initialization operations such
as geneating all subrelations might have touched a default." :ALLOCATION
    :INSTANCE :ACCESSOR %ITERATOR-INITIALIZATION-TOUCHED-DEFAULT?)
   (ITERATOR-VALUE-HOLDS-BY-DEFAULT? :DOCUMENTATION
    "If TRUE, the generation of the most recent value
might have involved some default knowledge." :ALLOCATION :INSTANCE
    :ACCESSOR %ITERATOR-VALUE-HOLDS-BY-DEFAULT?)))

(CL:DEFUN NEW-TRUE-DEPENDENT-PROPOSITIONS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE TRUE-DEPENDENT-PROPOSITIONS-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) TRUE) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE-STACK SELF) NIL)
   (CL:SETF (%SPECIALIZING-RELATIONS SELF) NULL)
   (CL:SETF (%RELATION-OF-PROPOSITION SELF) NULL)
   (CL:SETF (%KIND-OF-PROPOSITION SELF) NULL)
   (CL:SETF (%PROPOSITION-CURSOR SELF) NIL)
   (CL:SETF (%ITERATOR-VALUE-HOLDS-BY-DEFAULT? SELF) FALSE)
   (CL:SETF (%ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? SELF) FALSE)
   (CL:SETF (%REFERENCE-PROPOSITION SELF) NULL)
   (CL:SETF (%RETURN-ARGUMENT-INDEX SELF) NULL-INTEGER)
   (CL:SETF (%SUBSUMPTION-TEST-FILTER? SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRUE-DEPENDENT-PROPOSITIONS-ITERATOR))
  SGT-SPECIALIZE-LOGIC-TRUE-DEPENDENT-PROPOSITIONS-ITERATOR)

(CL:DEFUN ACCESS-TRUE-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-SUBSUMPTION-TEST-FILTER?)
    (CL:IF SETVALUE?
     (CL:SETF (%SUBSUMPTION-TEST-FILTER? SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FUNCTION-CODE (%SUBSUMPTION-TEST-FILTER? SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-RETURN-ARGUMENT-INDEX)
    (CL:IF SETVALUE?
     (CL:SETF (%RETURN-ARGUMENT-INDEX SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%RETURN-ARGUMENT-INDEX SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-REFERENCE-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%REFERENCE-PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%REFERENCE-PROPOSITION SELF))))
   ((CL:EQ SLOTNAME
     SYM-SPECIALIZE-LOGIC-ITERATOR-INITIALIZATION-TOUCHED-DEFAULT?)
    (CL:IF SETVALUE?
     (CL:SETF (%ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-ITERATOR-VALUE-HOLDS-BY-DEFAULT?)
    (CL:IF SETVALUE?
     (CL:SETF (%ITERATOR-VALUE-HOLDS-BY-DEFAULT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%ITERATOR-VALUE-HOLDS-BY-DEFAULT? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (VALUE-HOLDS-BY-DEFAULT? BOOLEAN) ...)

(CL:DEFUN VALUE-HOLDS-BY-DEFAULT? (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-SPECIALIZE-LOGIC-TRUE-DEPENDENT-PROPOSITIONS-ITERATOR)
     (CL:PROGN (%ITERATOR-VALUE-HOLDS-BY-DEFAULT? SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-SPECIALIZE-LOGIC-DESCRIPTION-EXTENSION-ITERATOR)
     (CL:PROGN (%ITERATOR-VALUE-HOLDS-BY-DEFAULT? SELF)))
    (CL:T FALSE))))

;;; (DEFUN (VALUE-HOLDS-BY-DEFAULT?-SETTER BOOLEAN) ...)

(CL:DEFUN VALUE-HOLDS-BY-DEFAULT?-SETTER (SELF VALUE)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-SPECIALIZE-LOGIC-TRUE-DEPENDENT-PROPOSITIONS-ITERATOR)
     (CL:PROGN (CL:SETF (%ITERATOR-VALUE-HOLDS-BY-DEFAULT? SELF) VALUE)
      VALUE))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-SPECIALIZE-LOGIC-DESCRIPTION-EXTENSION-ITERATOR)
     (CL:PROGN (CL:SETF (%ITERATOR-VALUE-HOLDS-BY-DEFAULT? SELF) VALUE)
      VALUE))
    (CL:T FALSE))))

;;; (DEFUN (FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM (CONS OF PROPOSITION)) ...)

(CL:DEFUN FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM (SELF)
  (CL:LET*
   ((TOPSKOLEMSLIST (%%VALUE (%VARIABLE-VALUE-INVERSE-STACK SELF)))
    (NEXTSKOLEM (%%VALUE TOPSKOLEMSLIST))
    (CURSOR
     (CONSIFY
      (UNFILTERED-DEPENDENT-PROPOSITIONS NEXTSKOLEM
       (CL:IF (CL:NOT (CL:EQ (%SPECIALIZING-RELATIONS SELF) NULL)) NULL
        (%RELATION-OF-PROPOSITION SELF))))))
   (FIRST-SETTER (%VARIABLE-VALUE-INVERSE-STACK SELF)
    (%%REST TOPSKOLEMSLIST))
   (CL:WHEN (CL:EQ (%%REST TOPSKOLEMSLIST) NIL)
    (CL:SETF (%VARIABLE-VALUE-INVERSE-STACK SELF)
     (%%REST (%VARIABLE-VALUE-INVERSE-STACK SELF))))
   (CL:WHEN (CL:NOT (CL:EQ (VARIABLE-VALUE-INVERSE NEXTSKOLEM) NIL))
    (CL:SETF (%VARIABLE-VALUE-INVERSE-STACK SELF)
     (CONS (VARIABLE-VALUE-INVERSE NEXTSKOLEM)
      (%VARIABLE-VALUE-INVERSE-STACK SELF))))
   CURSOR))

;;; (DEFUN (TRUE-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN TRUE-PROPOSITION? (PROPOSITION)
  (CL:WHEN (DELETED? PROPOSITION) (CL:RETURN-FROM TRUE-PROPOSITION? FALSE))
  (CL:IF *REVERSEPOLARITY?* (FALSE? PROPOSITION)
   (CL:OR (TRUE? PROPOSITION) (FUNCTION-WITH-DEFINED-VALUE? PROPOSITION))))

;;; (DEFUN (APPLY-TRUE-DEPENDENT-PROPOSITIONS-FILTER? BOOLEAN) ...)

(CL:DEFUN APPLY-TRUE-DEPENDENT-PROPOSITIONS-FILTER? (PROPOSITION SELF)
  (CL:LET*
   ((REFERENCERELATION (%RELATION-OF-PROPOSITION SELF))
    (SPECIALIZINGRELATIONS (%SPECIALIZING-RELATIONS SELF))
    (PROPOSITIONRELATION (%OPERATOR PROPOSITION)))
   (CL:IF (CL:NOT (CL:EQ SPECIALIZINGRELATIONS NULL))
    (CL:WHEN (CL:NOT (MEMB? SPECIALIZINGRELATIONS PROPOSITIONRELATION))
     (CL:RETURN-FROM APPLY-TRUE-DEPENDENT-PROPOSITIONS-FILTER? FALSE))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ REFERENCERELATION NULL))
      (CL:NOT (CL:EQ REFERENCERELATION PROPOSITIONRELATION)))
     (CL:RETURN-FROM APPLY-TRUE-DEPENDENT-PROPOSITIONS-FILTER? FALSE)))
   (CL:IF (CL:NOT (CL:EQ (%SUBSUMPTION-TEST-FILTER? SELF) NULL))
    (CL:FUNCALL (%SUBSUMPTION-TEST-FILTER? SELF) PROPOSITION
     (%REFERENCE-PROPOSITION SELF))
    TRUE)))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF TRUE-DEPENDENT-PROPOSITIONS-ITERATOR))
  (CL:LET*
   ((CURSOR (%PROPOSITION-CURSOR SELF)) (PROPOSITION NULL)
    (DETERMINEDEFAULTTRUTH?
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)))
    (LATESTTOUCHEDDEFAULT? FALSE) (SUCCESS? FALSE))
   (CL:WHEN DETERMINEDEFAULTTRUTH?
    (CL:SETQ LATESTTOUCHEDDEFAULT?
     (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*))
    (CL:SETF (%ITERATOR-VALUE-HOLDS-BY-DEFAULT? SELF) FALSE))
   (CL:LOOP
    (CL:LOOP WHILE (CL:EQ CURSOR NIL) DO
     (CL:WHEN (CL:EQ (%VARIABLE-VALUE-INVERSE-STACK SELF) NIL)
      (CL:SETF (%PROPOSITION-CURSOR SELF) NIL)
      (CL:SETF (%VALUE SELF) NULL) (CL:RETURN))
     (CL:WHEN DETERMINEDEFAULTTRUTH?
      (CL:SETF (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*) FALSE))
     (CL:SETQ CURSOR (FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM SELF))
     (CL:WHEN
      (CL:AND DETERMINEDEFAULTTRUTH?
       (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*))
      (CL:SETF (%ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? SELF) TRUE)))
    (CL:WHEN (CL:EQ CURSOR NIL) (CL:RETURN))
    (CL:SETQ PROPOSITION (%%VALUE CURSOR))
    (CL:SETQ CURSOR (%%REST CURSOR))
    (CL:WHEN DETERMINEDEFAULTTRUTH?
     (CL:SETF (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*) FALSE))
    (CL:WHEN
     (CL:AND (TRUE-PROPOSITION? PROPOSITION)
      (APPLY-TRUE-DEPENDENT-PROPOSITIONS-FILTER? PROPOSITION SELF))
     (CL:IF (DEFINED? (%RETURN-ARGUMENT-INDEX SELF))
      (CL:SETF (%VALUE SELF)
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        (CL:THE CL:FIXNUM (%RETURN-ARGUMENT-INDEX SELF))))
      (CL:SETF (%VALUE SELF) PROPOSITION))
     (CL:SETF (%PROPOSITION-CURSOR SELF) CURSOR)
     (CL:WHEN
      (CL:AND DETERMINEDEFAULTTRUTH?
       (CL:OR (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*)
        (CL:AND (%ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? SELF)
         (CL:OR (CL:NOT (CL:EQ (%SUBSUMPTION-TEST-FILTER? SELF) NULL))
          (CL:NOT
           (CL:EQ (%OPERATOR PROPOSITION)
            (%RELATION-OF-PROPOSITION SELF)))))))
      (CL:SETF (%ITERATOR-VALUE-HOLDS-BY-DEFAULT? SELF) TRUE))
     (CL:SETQ SUCCESS? TRUE) (CL:RETURN)))
   (CL:WHEN DETERMINEDEFAULTTRUTH?
    (CL:SETF (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*)
     LATESTTOUCHEDDEFAULT?))
   SUCCESS?))

;;; (DEFCONSTANT EMPTY-ALL-PROPOSITIONS-ITERATOR ...)

(CL:DEFVAR EMPTY-ALL-PROPOSITIONS-ITERATOR NULL
  "This iterator returns no values whenever its called.")

;;; (DEFUN (ALL-TRUE-DEPENDENT-PROPOSITIONS (TRUE-DEPENDENT-PROPOSITIONS-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-TRUE-DEPENDENT-PROPOSITIONS (SELF RELATION SPECIALIZE?)
  (CL:LET*
   ((UNFILTEREDDEPENDENTS NULL) (ITERATOR NULL)
    (DETERMINEDEFAULTTRUTH?
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)))
    (LATESTTOUCHEDDEFAULT? FALSE))
   (CL:WHEN DETERMINEDEFAULTTRUTH?
    (CL:SETQ LATESTTOUCHEDDEFAULT?
     (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*))
    (CL:SETF (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*) FALSE))
   (CL:SETQ UNFILTEREDDEPENDENTS
    (UNFILTERED-DEPENDENT-PROPOSITIONS SELF
     (CL:IF SPECIALIZE? NULL RELATION)))
   (CL:WHEN
    (CL:OR (CL:EQ UNFILTEREDDEPENDENTS NIL-PAGING-INDEX)
     (CL:EQ UNFILTEREDDEPENDENTS NIL-NON-PAGING-INDEX))
    (CL:RETURN-FROM ALL-TRUE-DEPENDENT-PROPOSITIONS
     EMPTY-ALL-PROPOSITIONS-ITERATOR))
   (CL:SETQ ITERATOR (NEW-TRUE-DEPENDENT-PROPOSITIONS-ITERATOR))
   (CL:SETF (%PROPOSITION-CURSOR ITERATOR) (CONSIFY UNFILTEREDDEPENDENTS))
   (CL:SETF (%RELATION-OF-PROPOSITION ITERATOR) RELATION)
   (CL:WHEN SPECIALIZE?
    (CL:LET*
     ((SUBRELATIONS (ALL-SUBRELATIONS (GET-DESCRIPTION RELATION) FALSE))
      (SUBRELATIONNAMES NIL))
     (CL:WHEN (CL:NOT (CL:EQ SUBRELATIONS NIL))
      (CL:LET* ((SUBREL NULL) (ITER-000 SUBRELATIONS) (COLLECT-000 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:PROGN (CL:SETQ SUBREL (%%VALUE ITER-000))
         (CL:SETQ ITER-000 (%%REST ITER-000)))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-000
           (CONS (%SURROGATE-VALUE-INVERSE SUBREL) NIL))
          (CL:IF (CL:EQ SUBRELATIONNAMES NIL)
           (CL:SETQ SUBRELATIONNAMES COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST SUBRELATIONNAMES COLLECT-000)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-000)
           (CONS (%SURROGATE-VALUE-INVERSE SUBREL) NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
      (CL:SETF (%SPECIALIZING-RELATIONS ITERATOR)
       (CONS RELATION SUBRELATIONNAMES)))))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
      SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:WHEN (CL:NOT (CL:EQ (VARIABLE-VALUE-INVERSE SELF) NIL))
       (CL:SETF (%VARIABLE-VALUE-INVERSE-STACK ITERATOR)
        (CONS (VARIABLE-VALUE-INVERSE SELF) NIL)))))
    (CL:T))
   (CL:WHEN DETERMINEDEFAULTTRUTH?
    (CL:WHEN (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*)
     (CL:SETF (%ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? ITERATOR) TRUE))
    (CL:SETF (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*)
     LATESTTOUCHEDDEFAULT?))
   ITERATOR))

;;; (DEFUN (ARGUMENTS-UNIFY-WITH-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN ARGUMENTS-UNIFY-WITH-ARGUMENTS? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:LET*
   ((PATTERNRECORD (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))
    (UBSTACKOFFSET (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))
    (SUCCESS? FALSE))
   (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
   (CL:LET* ((TEST-VALUE-000 FALSE))
    (CL:LET* ((ALWAYS?-000 TRUE))
     (CL:LET*
      ((SUBARG NULL) (SUPERARG NULL)
       (VECTOR-000 (%ARGUMENTS REFERENCEPROPOSITION)) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000))
       (VECTOR-001 (%ARGUMENTS SUBPROPOSITION)) (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:DECLARE
       (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
      (CL:LOOP WHILE
       (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
       (CL:PROGN
        (CL:SETQ SUPERARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
       (CL:PROGN
        (CL:SETQ SUBARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (CL:WHEN
        (CL:NOT
         (BIND-ARGUMENT-TO-VALUE? SUPERARG (VALUE-OF SUBARG) FALSE))
        (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
     (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
    (CL:WHEN TEST-VALUE-000
     (CL:SETQ TEST-VALUE-000
      (CL:= (LENGTH (%ARGUMENTS REFERENCEPROPOSITION))
       (LENGTH (%ARGUMENTS SUBPROPOSITION)))))
    (CL:SETQ SUCCESS? TEST-VALUE-000))
   (CL:WHEN (CL:NOT SUCCESS?)
    (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD (CL:1+ UBSTACKOFFSET)))
   SUCCESS?))

;;; (DEFUN (ARGUMENTS-EQUAL-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN ARGUMENTS-EQUAL-ARGUMENTS? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:LET* ((ALWAYS?-000 TRUE))
    (CL:LET*
     ((SUBARG NULL) (SUPERARG NULL)
      (VECTOR-000 (%ARGUMENTS REFERENCEPROPOSITION)) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000))
      (VECTOR-001 (%ARGUMENTS SUBPROPOSITION)) (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
      (CL:PROGN
       (CL:SETQ SUPERARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
      (CL:PROGN
       (CL:SETQ SUBARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (CL:WHEN (CL:NOT (EQL? (VALUE-OF SUPERARG) (VALUE-OF SUBARG)))
       (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
    (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000
     (CL:= (LENGTH (%ARGUMENTS REFERENCEPROPOSITION))
      (LENGTH (%ARGUMENTS SUBPROPOSITION)))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (ARGUMENTS-MATCH-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN ARGUMENTS-MATCH-ARGUMENTS? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:IF (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
   (ARGUMENTS-UNIFY-WITH-ARGUMENTS? SUBPROPOSITION REFERENCEPROPOSITION)
   (ARGUMENTS-EQUAL-ARGUMENTS? SUBPROPOSITION REFERENCEPROPOSITION)))

;;; (DEFUN (PREFIX-ARGUMENTS-EQUAL-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN PREFIX-ARGUMENTS-EQUAL-ARGUMENTS? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:LET* ((ALWAYS?-000 TRUE))
    (CL:LET*
     ((SUBARG NULL) (SUPERARG NULL)
      (VECTOR-000 (%ARGUMENTS REFERENCEPROPOSITION)) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000))
      (VECTOR-001 (%ARGUMENTS SUBPROPOSITION)) (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
      (CL:PROGN
       (CL:SETQ SUPERARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
      (CL:PROGN
       (CL:SETQ SUBARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (CL:WHEN (CL:NOT (EQL? (VALUE-OF SUPERARG) (VALUE-OF SUBARG)))
       (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
    (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (ALL-MATCHING-PROPOSITIONS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-MATCHING-PROPOSITIONS (SELF)
  (CL:LET* ((BACKLINKEDARGUMENT NULL) (NOMATCHINGPROPOSITIONS? FALSE))
   (CL:MULTIPLE-VALUE-SETQ (BACKLINKEDARGUMENT NOMATCHINGPROPOSITIONS?)
    (SELECT-ARGUMENT-WITH-BACKLINKS SELF))
   (CL:WHEN NOMATCHINGPROPOSITIONS?
    (CL:RETURN-FROM ALL-MATCHING-PROPOSITIONS
     EMPTY-ALL-PROPOSITIONS-ITERATOR))
   (CL:WHEN (CL:EQ BACKLINKEDARGUMENT NULL)
    (CL:RETURN-FROM ALL-MATCHING-PROPOSITIONS
     (ALL-MATCHING-EXTENSION-MEMBERS SELF TRUE)))
   (ALL-TRUE-DEPENDENT-PROPOSITIONS BACKLINKEDARGUMENT (%OPERATOR SELF)
    TRUE)))

;;; (DEFUN (ALL-PROPOSITIONS-MATCHING-ARGUMENTS (CONS OF PROPOSITION)) ...)

(CL:DEFUN ALL-PROPOSITIONS-MATCHING-ARGUMENTS (ARGUMENTS RELATION SPECIALIZE?)
  (CL:LET*
   ((BACKLINKEDINSTANCE
     (SELECT-INSTANCE-WITH-BACKLINKS ARGUMENTS RELATION)))
   (CL:WHEN (CL:EQ BACKLINKEDINSTANCE NULL)
    (CL:RETURN-FROM ALL-PROPOSITIONS-MATCHING-ARGUMENTS NIL))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE BACKLINKEDINSTANCE)
      SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:WHEN
       (CL:NOT (CL:EQ (VARIABLE-VALUE-INVERSE BACKLINKEDINSTANCE) NIL))
       (CL:LET*
        ((REFERENCEPROPOSITION
          (CREATE-PROPOSITION SYM-SPECIALIZE-STELLA-PREDICATE
           (LENGTH ARGUMENTS))))
        (CL:SETF (%OPERATOR REFERENCEPROPOSITION) RELATION)
        (CL:LET*
         ((I NULL-INTEGER) (ARG NULL) (ITER-000 ARGUMENTS) (ITER-001 0))
         (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-000))
           (CL:SETQ ITER-000 (%%REST ITER-000)))
          (CL:PROGN (CL:SETQ I ITER-001)
           (CL:SETQ ITER-001 (CL:1+ ITER-001)))
          (CL:LET
           ((SELF (%THE-ARRAY (%ARGUMENTS REFERENCEPROPOSITION)))
            (VALUE ARG) (POSITION I))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SETF (CL:AREF SELF POSITION) VALUE))))
        (CL:LET*
         ((ITERATOR
           (ALL-TRUE-DEPENDENT-PROPOSITIONS BACKLINKEDINSTANCE RELATION
            SPECIALIZE?)))
         (CL:WHEN (CL:EQ ITERATOR EMPTY-ALL-PROPOSITIONS-ITERATOR)
          (CL:RETURN-FROM ALL-PROPOSITIONS-MATCHING-ARGUMENTS NIL))
         (CL:SETF (%REFERENCE-PROPOSITION ITERATOR) REFERENCEPROPOSITION)
         (CL:SETF (%SUBSUMPTION-TEST-FILTER? ITERATOR)
          (CL:FUNCTION PREFIX-ARGUMENTS-EQUAL-ARGUMENTS?))
         (CL:RETURN-FROM ALL-PROPOSITIONS-MATCHING-ARGUMENTS
          (CONSIFY ITERATOR)))))))
    (CL:T))
   (CL:LET*
    ((UNFILTEREDPROPOSITIONS
      (CL:IF SPECIALIZE?
       (CONSIFY
        (ALL-SPECIALIZING-DEPENDENT-PROPOSITIONS BACKLINKEDINSTANCE
         RELATION))
       (CONSIFY
        (UNFILTERED-DEPENDENT-PROPOSITIONS BACKLINKEDINSTANCE RELATION))))
     (FILTEREDPROPOSITIONS NIL))
    (CL:LET*
     ((P NULL) (ITER-002 UNFILTEREDPROPOSITIONS) (COLLECT-000 NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:PROGN (CL:SETQ P (%%VALUE ITER-002))
       (CL:SETQ ITER-002 (%%REST ITER-002)))
      (CL:LET* ((TEST-VALUE-000 FALSE))
       (CL:SETQ TEST-VALUE-000 (CL:EQ (%OPERATOR P) RELATION))
       (CL:WHEN TEST-VALUE-000
        (CL:SETQ TEST-VALUE-000 (TRUE-PROPOSITION? P))
        (CL:WHEN TEST-VALUE-000
         (CL:LET* ((ALWAYS?-000 TRUE))
          (CL:LET*
           ((I NULL-INTEGER) (A1 NULL) (ITER-003 ARGUMENTS) (ITER-004 0))
           (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-004 I))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
            (CL:PROGN (CL:SETQ A1 (%%VALUE ITER-003))
             (CL:SETQ ITER-003 (%%REST ITER-003)))
            (CL:PROGN (CL:SETQ I ITER-004)
             (CL:SETQ ITER-004 (CL:1+ ITER-004)))
            (CL:WHEN
             (CL:NOT
              (EQL? (VALUE-OF A1)
               (VALUE-OF
                (CL:AREF
                 (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
                 I))))
             (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
          (CL:SETQ TEST-VALUE-000 ALWAYS?-000))))
       (CL:WHEN TEST-VALUE-000
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS P NIL))
          (CL:IF (CL:EQ FILTEREDPROPOSITIONS NIL)
           (CL:SETQ FILTEREDPROPOSITIONS COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST FILTEREDPROPOSITIONS
            COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS P NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))))
    FILTEREDPROPOSITIONS)))

;;; (DEFUN (ALL-DEFINING-PROPOSITIONS (CONS OF PROPOSITION)) ...)

(CL:DEFUN ALL-DEFINING-PROPOSITIONS (OUTPUTARGUMENT RELATION SPECIALIZE?)
  (CL:LET* ((RESULT NIL) (OUTPUTARGUMENTVALUE (VALUE-OF OUTPUTARGUMENT)))
   (CL:LET*
    ((PROP NULL)
     (ITER-000
      (ALL-TRUE-DEPENDENT-PROPOSITIONS OUTPUTARGUMENTVALUE RELATION
       SPECIALIZE?))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PROP (%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:EQ (%KIND PROP) KWD-SPECIALIZE-FUNCTION)
       (EQL?
        (VALUE-OF
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP)))
          (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS PROP))))))
        OUTPUTARGUMENTVALUE))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS PROP NIL))
        (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS PROP NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   RESULT))

;;; (DEFUN (HELP-MEMOIZE-TEST-PROPERTY? BOOLEAN) ...)

(CL:DEFUN HELP-MEMOIZE-TEST-PROPERTY? (SELF RELATION)
  (CL:LET*
   ((*REVERSEPOLARITY?* FALSE) (*CONTEXT* (GET-PROPERTY-TEST-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?* *CONTEXT*))
   (CL:IF
    (CL:AND (ISA? SELF SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT)
     (CL:EQ (VARIABLE-VALUE-INVERSE SELF) NIL))
    (CL:LET* ((FOUND?-000 FALSE))
     (CL:LET*
      ((P NULL)
       (ITER-000
        (ALLOCATE-ITERATOR
         (UNFILTERED-DEPENDENT-PROPOSITIONS SELF RELATION))))
      (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
       (CL:WHEN
        (CL:AND (CL:EQ (%OPERATOR P) RELATION) (TRUE-PROPOSITION? P))
        (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
     (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000))
    (NEXT? (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF RELATION FALSE)))))

;;; (DEFUN (TEST-PROPERTY? BOOLEAN) ...)

(CL:DEFUN TEST-PROPERTY? (SELF RELATION)
  (CL:LET*
   ((MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-SPECIALIZE-LOGIC-TEST-PROPERTY?-MEMO-TABLE-000))
    (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
    (INITIALIZE-MEMOIZATION-TABLE
     SGT-SPECIALIZE-LOGIC-TEST-PROPERTY?-MEMO-TABLE-000
     "(:MAX-VALUES 500 :TIMESTAMPS (:KB-UPDATE))")
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-SPECIALIZE-LOGIC-TEST-PROPERTY?-MEMO-TABLE-000)))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF RELATION *CONTEXT*
      MEMOIZED-NULL-VALUE 6))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (CL:IF (HELP-MEMOIZE-TEST-PROPERTY? SELF RELATION) TRUE-WRAPPER
       FALSE-WRAPPER))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE-000))))

;;; (DEFUN (HELP-MEMOIZE-TEST-ISA? BOOLEAN) ...)

(CL:DEFUN HELP-MEMOIZE-TEST-ISA? (MEMBER TYPE)
  (CL:LET*
   ((*REVERSEPOLARITY?* FALSE) (*CONTEXT* (GET-PROPERTY-TEST-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?* *CONTEXT*))
   (CL:IF
    (CL:AND (ISA? MEMBER SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT)
     (CL:EQ (VARIABLE-VALUE-INVERSE MEMBER) NIL))
    (CL:LET* ((FOUND?-000 FALSE))
     (CL:LET*
      ((P NULL)
       (ITER-000
        (ALLOCATE-ITERATOR
         (UNFILTERED-DEPENDENT-ISA-PROPOSITIONS MEMBER))))
      (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
       (CL:WHEN
        (CL:AND (RELATIONREF-SPECIALIZES-RELATIONREF? (%OPERATOR P) TYPE)
         (TRUE-PROPOSITION? P))
        (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
     (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000))
    (NEXT? (ALL-TRUE-DEPENDENT-PROPOSITIONS MEMBER TYPE TRUE)))))

;;; (DEFUN (TEST-ISA? BOOLEAN) ...)

(CL:DEFUN TEST-ISA? (MEMBER TYPE)
  (CL:LET*
   ((MEMO-TABLE-000
     (%SURROGATE-VALUE SGT-SPECIALIZE-LOGIC-TEST-ISA?-MEMO-TABLE-000))
    (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
    (INITIALIZE-MEMOIZATION-TABLE
     SGT-SPECIALIZE-LOGIC-TEST-ISA?-MEMO-TABLE-000
     "(:MAX-VALUES 1000 :TIMESTAMPS (:KB-UPDATE))")
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE SGT-SPECIALIZE-LOGIC-TEST-ISA?-MEMO-TABLE-000)))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 MEMBER TYPE *CONTEXT*
      MEMOIZED-NULL-VALUE 6))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (CL:IF (HELP-MEMOIZE-TEST-ISA? MEMBER TYPE) TRUE-WRAPPER
       FALSE-WRAPPER))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE-000))))

;;; (DEFUN (HELP-MEMOIZE-ACCESS-BINARY-VALUE OBJECT) ...)

(CL:DEFUN HELP-MEMOIZE-ACCESS-BINARY-VALUE (SELF RELATION)
  (CL:LET*
   ((*REVERSEPOLARITY?* FALSE) (*CONTEXT* (GET-PROPERTY-TEST-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?* *CONTEXT*))
   (CL:LET*
    ((RESULT NULL)
     (ITERATOR (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF RELATION FALSE))
     (PROPOSITION NULL))
    (CL:LOOP WHILE (NEXT? ITERATOR) DO
     (CL:SETQ PROPOSITION (%VALUE ITERATOR))
     (CL:WHEN
      (EQL?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 0)
       SELF)
      (CL:SETQ RESULT
       (VALUE-OF
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         1)))
      (CL:RETURN-FROM HELP-MEMOIZE-ACCESS-BINARY-VALUE RESULT)))
    NULL)))

;;; (DEFUN (ACCESS-BINARY-VALUE OBJECT) ...)

(CL:DEFUN ACCESS-BINARY-VALUE (SELF RELATION)
  (CL:LET*
   ((MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-SPECIALIZE-LOGIC-ACCESS-BINARY-VALUE-MEMO-TABLE-000))
    (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
    (INITIALIZE-MEMOIZATION-TABLE
     SGT-SPECIALIZE-LOGIC-ACCESS-BINARY-VALUE-MEMO-TABLE-000
     "(:MAX-VALUES 1000 :TIMESTAMPS (:KB-UPDATE))")
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-SPECIALIZE-LOGIC-ACCESS-BINARY-VALUE-MEMO-TABLE-000)))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF RELATION *CONTEXT*
      MEMOIZED-NULL-VALUE 6))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (HELP-MEMOIZE-ACCESS-BINARY-VALUE SELF RELATION))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000)) VALUE-000)))

;;; (DEFUN (TEST-COLLECTIONOF-MEMBER-OF? BOOLEAN) ...)

(CL:DEFUN TEST-COLLECTIONOF-MEMBER-OF? (MEMBER TYPE)
  (CL:LET*
   ((*REVERSEPOLARITY?* FALSE) (*CONTEXT* (GET-PROPERTY-TEST-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?* *CONTEXT*))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALL-SPECIALIZING-DEPENDENT-PROPOSITIONS MEMBER
       SGT-SPECIALIZE-LOGIC-COLLECTION-OF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:WHEN (TRUE-PROPOSITION? P)
      (CL:LET* ((COLLECTION (LAST (%ARGUMENTS P))))
       (CL:WHEN
        (CL:AND (CL:NOT (EQL? MEMBER COLLECTION))
         (COLLECTION-IMPLIES-COLLECTION? COLLECTION
          (SURROGATE-TO-DESCRIPTION TYPE)))
        (CL:RETURN-FROM TEST-COLLECTIONOF-MEMBER-OF? TRUE))))))
   FALSE))

;;; (DEFCLASS TRANSITIVE-CLOSURE-ITERATOR ...)

(CL:DEFCLASS TRANSITIVE-CLOSURE-ITERATOR (ITERATOR)
  ((ALLOCATE-ADJACENCY-ITERATOR-FUNCTION :ALLOCATION :INSTANCE :ACCESSOR
    %ALLOCATE-ADJACENCY-ITERATOR-FUNCTION)
   (FILTER? :ALLOCATION :INSTANCE :ACCESSOR %FILTER?)
   (ADJACENCY-ITERATOR-STACK :ALLOCATION :INSTANCE :ACCESSOR
    %ADJACENCY-ITERATOR-STACK)
   (BEEN-THERE-LIST :ALLOCATION :INSTANCE :ACCESSOR %BEEN-THERE-LIST))
  (:DOCUMENTATION "Iterator that visits all nodes reachable using an
embedded adjacency function."))

(CL:DEFUN NEW-TRANSITIVE-CLOSURE-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE TRANSITIVE-CLOSURE-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) TRUE) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%BEEN-THERE-LIST SELF) NULL)
   (CL:SETF (%ADJACENCY-ITERATOR-STACK SELF) NIL)
   (CL:SETF (%FILTER? SELF) NULL)
   (CL:SETF (%ALLOCATE-ADJACENCY-ITERATOR-FUNCTION SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSITIVE-CLOSURE-ITERATOR))
  SGT-SPECIALIZE-LOGIC-TRANSITIVE-CLOSURE-ITERATOR)

(CL:DEFUN ACCESS-TRANSITIVE-CLOSURE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME
     SYM-SPECIALIZE-LOGIC-ALLOCATE-ADJACENCY-ITERATOR-FUNCTION)
    (CL:IF SETVALUE?
     (CL:SETF (%ALLOCATE-ADJACENCY-ITERATOR-FUNCTION SELF)
      (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FUNCTION-CODE (%ALLOCATE-ADJACENCY-ITERATOR-FUNCTION SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-FILTER?)
    (CL:IF SETVALUE? (CL:SETF (%FILTER? SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FUNCTION-CODE (%FILTER? SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-ADJACENCY-ITERATOR-STACK)
    (CL:IF SETVALUE? (CL:SETF (%ADJACENCY-ITERATOR-STACK SELF) VALUE)
     (CL:SETQ VALUE (%ADJACENCY-ITERATOR-STACK SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-BEEN-THERE-LIST)
    (CL:IF SETVALUE? (CL:SETF (%BEEN-THERE-LIST SELF) VALUE)
     (CL:SETQ VALUE (%BEEN-THERE-LIST SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD FREE ...)

(CL:DEFMETHOD FREE ((SELF TRANSITIVE-CLOSURE-ITERATOR))
  (UNMAKE SELF))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF TRANSITIVE-CLOSURE-ITERATOR))
  (CL:LET*
   ((NODE (%VALUE SELF))
    (ADJACENCYITERATOR
     (CL:FUNCALL (%ALLOCATE-ADJACENCY-ITERATOR-FUNCTION SELF) NODE)))
   (CL:IF (CL:NOT (CL:EQ ADJACENCYITERATOR NULL))
    (CL:SETF (%ADJACENCY-ITERATOR-STACK SELF)
     (CONS ADJACENCYITERATOR (%ADJACENCY-ITERATOR-STACK SELF)))
    (CL:PROGN
     (CL:SETQ ADJACENCYITERATOR
      (%%VALUE (%ADJACENCY-ITERATOR-STACK SELF)))
     (CL:WHEN (CL:EQ ADJACENCYITERATOR NULL)
      (CL:RETURN-FROM NEXT? FALSE))))
   (CL:LOOP
    (CL:LOOP WHILE (CL:NOT (NEXT? ADJACENCYITERATOR)) DO
     (CL:SETF (%ADJACENCY-ITERATOR-STACK SELF)
      (%%REST (%ADJACENCY-ITERATOR-STACK SELF)))
     (CL:SETQ ADJACENCYITERATOR
      (%%VALUE (%ADJACENCY-ITERATOR-STACK SELF)))
     (CL:WHEN (CL:EQ ADJACENCYITERATOR NULL)
      (CL:RETURN-FROM NEXT? FALSE)))
    (CL:SETQ NODE (%VALUE ADJACENCYITERATOR))
    (CL:WHEN
     (CL:AND
      (CL:NOT
       (MEMBER? (%BEEN-THERE-LIST SELF) (%VALUE ADJACENCYITERATOR)))
      (CL:OR (CL:EQ (%FILTER? SELF) NULL)
       (CL:FUNCALL (%FILTER? SELF) NODE)))
     (CL:SETF (%BEEN-THERE-LIST SELF) (CONS NODE (%BEEN-THERE-LIST SELF)))
     (CL:SETF (%VALUE SELF) NODE) (CL:RETURN-FROM NEXT? TRUE)))))

;;; (DEFUN (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR ITERATOR) ...)

(CL:DEFUN ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR (STARTNODE ALLOCATEADJACENCYITERATOR FILTERFUNCTION)
  "Return an iterator that generates the transitive
closure of applying iterators generated by 'allocateAdjacencyIterator'
to 'startNode'.  If 'filterFunction' is non-null, that function is applied
as a filter to each node generated (nodes filtered out still generate
descendants, but they don't get returned)."
  (CL:LET* ((ITERATOR (NEW-TRANSITIVE-CLOSURE-ITERATOR)))
   (CL:SETF (%VALUE ITERATOR) STARTNODE)
   (CL:SETF (%BEEN-THERE-LIST ITERATOR) NIL)
   (CL:SETF (%ALLOCATE-ADJACENCY-ITERATOR-FUNCTION ITERATOR)
    ALLOCATEADJACENCYITERATOR)
   (CL:SETF (%FILTER? ITERATOR) FILTERFUNCTION) ITERATOR))

;;; (DEFCLASS DIRECTLY-LINKED-OBJECTS-ITERATOR ...)

(CL:DEFCLASS DIRECTLY-LINKED-OBJECTS-ITERATOR (ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR)
  ((INVERSE? :ALLOCATION :INSTANCE :ACCESSOR %INVERSE?)
   (REFERENCE-INSTANCE :ALLOCATION :INSTANCE :ACCESSOR
    %REFERENCE-INSTANCE)))

(CL:DEFUN NEW-DIRECTLY-LINKED-OBJECTS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE DIRECTLY-LINKED-OBJECTS-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) TRUE) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE-STACK SELF) NIL)
   (CL:SETF (%SPECIALIZING-RELATIONS SELF) NULL)
   (CL:SETF (%RELATION-OF-PROPOSITION SELF) NULL)
   (CL:SETF (%KIND-OF-PROPOSITION SELF) NULL)
   (CL:SETF (%PROPOSITION-CURSOR SELF) NIL)
   (CL:SETF (%REFERENCE-INSTANCE SELF) NULL)
   (CL:SETF (%INVERSE? SELF) FALSE) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DIRECTLY-LINKED-OBJECTS-ITERATOR))
  SGT-SPECIALIZE-LOGIC-DIRECTLY-LINKED-OBJECTS-ITERATOR)

(CL:DEFUN ACCESS-DIRECTLY-LINKED-OBJECTS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-INVERSE?)
    (CL:IF SETVALUE?
     (CL:SETF (%INVERSE? SELF) (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE (CL:IF (%INVERSE? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-REFERENCE-INSTANCE)
    (CL:IF SETVALUE? (CL:SETF (%REFERENCE-INSTANCE SELF) VALUE)
     (CL:SETQ VALUE (%REFERENCE-INSTANCE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF DIRECTLY-LINKED-OBJECTS-ITERATOR))
  (CL:LET*
   ((CURSOR NULL) (PROPOSITION NULL)
    (REFERENCEINSTANCE (%REFERENCE-INSTANCE SELF))
    (INVERSE? (%INVERSE? SELF)))
   (CL:IF (%FIRST-ITERATION? SELF)
    (CL:PROGN (CL:SETF (%FIRST-ITERATION? SELF) FALSE)
     (CL:SETQ CURSOR (%PROPOSITION-CURSOR SELF)))
    (CL:SETQ CURSOR (%%REST (%PROPOSITION-CURSOR SELF))))
   (CL:LOOP
    (CL:LOOP WHILE (CL:EQ CURSOR NIL) DO
     (CL:WHEN (CL:EQ (%VARIABLE-VALUE-INVERSE-STACK SELF) NIL)
      (CL:RETURN-FROM NEXT? FALSE))
     (CL:SETQ CURSOR (FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM SELF)))
    (CL:SETQ PROPOSITION (%%VALUE CURSOR))
    (CL:WHEN
     (CL:AND (CL:= (LENGTH (%ARGUMENTS PROPOSITION)) 2)
      (CL:EQ (%KIND PROPOSITION) (%KIND-OF-PROPOSITION SELF))
      (EQL? REFERENCEINSTANCE
       (VALUE-OF
        (CL:IF INVERSE?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          1)
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          0))))
      (TRUE-PROPOSITION? PROPOSITION))
     (CL:SETF (%VALUE SELF)
      (VALUE-OF
       (CL:IF INVERSE?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         0)
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         1))))
     (CL:SETF (%PROPOSITION-CURSOR SELF) CURSOR)
     (CL:RETURN-FROM NEXT? TRUE))
    (CL:SETQ CURSOR (%%REST CURSOR)))))

;;; (DEFUN (ALL-DIRECTLY-LINKED-OBJECTS ITERATOR) ...)

(CL:DEFUN ALL-DIRECTLY-LINKED-OBJECTS (SELF KIND INVERSE?)
  (CL:LET* ((ITERATOR (NEW-DIRECTLY-LINKED-OBJECTS-ITERATOR)))
   (CL:SETF (%KIND-OF-PROPOSITION ITERATOR) KIND)
   (CL:SETF (%INVERSE? ITERATOR) INVERSE?)
   (CL:SETF (%REFERENCE-INSTANCE ITERATOR) SELF)
   (CL:LET* ((V-077 NIL))
    (CL:LET*
     ((P NULL)
      (ITER-000
       (ALLOCATE-ITERATOR (UNFILTERED-DEPENDENT-PROPOSITIONS SELF NULL)))
      (COLLECT-000 NULL))
     (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
      (CL:WHEN (CL:EQ (%KIND P) KIND)
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS P NIL))
         (CL:IF (CL:EQ V-077 NIL) (CL:SETQ V-077 COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST V-077 COLLECT-000)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS P NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
    (CL:SETF (%PROPOSITION-CURSOR ITERATOR) V-077))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
      SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:WHEN (CL:NOT (CL:EQ (VARIABLE-VALUE-INVERSE SELF) NIL))
       (CL:SETF (%VARIABLE-VALUE-INVERSE-STACK ITERATOR)
        (CONS-LIST (VARIABLE-VALUE-INVERSE SELF))))))
    (CL:T))
   ITERATOR))

;;; (DEFUN (ALL-DIRECT-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-SUPERCOLLECTIONS (SELF PERFORMFILTERING?)
  (CL:WHEN (ISA? SELF SGT-SPECIALIZE-LOGIC-DESCRIPTION)
   (DERIVE-DEFERRED-SATELLITE-RULES SELF))
  (CL:LET*
   ((DIRECTLYLINKEDOBJECTS
     (ALL-DIRECTLY-LINKED-OBJECTS SELF KWD-SPECIALIZE-IMPLIES
      *REVERSEPOLARITY?*)))
   (CL:WHEN (CL:NOT PERFORMFILTERING?)
    (CL:RETURN-FROM ALL-DIRECT-SUPERCOLLECTIONS DIRECTLYLINKEDOBJECTS))
   (CL:LET*
    ((DIRECTSUPERS NIL)
     (EQUIVALENTS (ALL-EQUIVALENT-COLLECTIONS SELF TRUE)))
    (CL:IF (CL:NOT (CL:EQ (%%REST EQUIVALENTS) NIL))
     (CL:LET* ((E NULL) (ITER-000 EQUIVALENTS))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ E (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:LET*
        ((PARENT NULL) (ITER-001 (ALL-DIRECT-SUPERCOLLECTIONS E FALSE)))
        (CL:LOOP WHILE (NEXT? ITER-001) DO
         (CL:SETQ PARENT (%VALUE ITER-001))
         (CL:WHEN
          (CL:AND (CL:NOT (MEMBER? EQUIVALENTS PARENT))
           (CL:NOT (MEMBER? DIRECTSUPERS PARENT)))
          (CL:SETQ DIRECTSUPERS (CONS PARENT DIRECTSUPERS)))))))
     (CL:SETQ DIRECTSUPERS (CONSIFY DIRECTLYLINKEDOBJECTS)))
    (ALLOCATE-ITERATOR (MOST-SPECIFIC-COLLECTIONS DIRECTSUPERS)))))

;;; (DEFUN (ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS (SELF)
  (ALL-DIRECT-SUPERCOLLECTIONS SELF FALSE))

;;; (DEFUN (ALL-DIRECT-SUBCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-SUBCOLLECTIONS (SELF PERFORMFILTERING?)
  (CL:WHEN (ISA? SELF SGT-SPECIALIZE-LOGIC-DESCRIPTION)
   (DERIVE-DEFERRED-SATELLITE-RULES SELF))
  (CL:LET*
   ((DIRECTLYLINKEDOBJECTS
     (ALL-DIRECTLY-LINKED-OBJECTS SELF KWD-SPECIALIZE-IMPLIES
      (CL:NOT *REVERSEPOLARITY?*))))
   (CL:WHEN (CL:NOT PERFORMFILTERING?)
    (CL:RETURN-FROM ALL-DIRECT-SUBCOLLECTIONS DIRECTLYLINKEDOBJECTS))
   (CL:LET*
    ((DIRECTSUBS NIL)
     (EQUIVALENTS (ALL-EQUIVALENT-COLLECTIONS SELF TRUE)))
    (CL:IF (CL:NOT (CL:EQ (%%REST EQUIVALENTS) NIL))
     (CL:LET* ((E NULL) (ITER-000 EQUIVALENTS))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ E (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:LET*
        ((CHILD NULL) (ITER-001 (ALL-DIRECT-SUBCOLLECTIONS E FALSE)))
        (CL:LOOP WHILE (NEXT? ITER-001) DO
         (CL:SETQ CHILD (%VALUE ITER-001))
         (CL:WHEN
          (CL:AND (CL:NOT (MEMBER? EQUIVALENTS CHILD))
           (CL:NOT (MEMBER? DIRECTSUBS CHILD)))
          (CL:SETQ DIRECTSUBS (CONS CHILD DIRECTSUBS)))))))
     (CL:SETQ DIRECTSUBS (CONSIFY DIRECTLYLINKEDOBJECTS)))
    (ALLOCATE-ITERATOR (MOST-GENERAL-COLLECTIONS DIRECTSUBS)))))

;;; (DEFUN (ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS (SELF)
  (ALL-DIRECT-SUBCOLLECTIONS SELF FALSE))

;;; (DEFUN (ALL-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-SUPERCOLLECTIONS (SELF)
  (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR SELF
   (CL:FUNCTION ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS) NULL))

;;; (DEFUN (ALL-SUBCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-SUBCOLLECTIONS (SELF)
  (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR SELF
   (CL:FUNCTION ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS) NULL))

;;; (DEFUN (ALL-ISA-COLLECTIONS (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-ISA-COLLECTIONS (SELF)
  (CL:LET* ((COLLECTIONS NIL))
   (CL:LET*
    ((P NULL)
     (ITER-000 (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF NULL FALSE)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%KIND P) KWD-SPECIALIZE-ISA)
      (CL:SETQ COLLECTIONS
       (CONS (GET-DESCRIPTION (%OPERATOR P)) COLLECTIONS)))))
   (CL:LET*
    ((P NULL)
     (ITER-001
      (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF
       SGT-SPECIALIZE-PL-KERNEL-KB-MEMBER-OF FALSE)))
    (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ P (%VALUE ITER-001))
     (CL:SETQ COLLECTIONS
      (CONS
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P))) 1)
       COLLECTIONS))))
   COLLECTIONS))

;;; (DEFUN (CLASHES-WITH-FUNCTION-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN CLASHES-WITH-FUNCTION-PROPOSITION? (NEXTPROPOSITION REFERENCEPROPOSITION)
  (CL:LET* ((ALWAYS?-000 TRUE))
   (CL:LET*
    ((SUBARG NULL) (SUPERARG NULL)
     (ITER-000 (BUT-LAST (%ARGUMENTS REFERENCEPROPOSITION)))
     (ITER-001 (BUT-LAST (%ARGUMENTS NEXTPROPOSITION))))
    (CL:LOOP WHILE (CL:AND (NEXT? ITER-000) (NEXT? ITER-001)) DO
     (CL:SETQ SUPERARG (%VALUE ITER-000))
     (CL:SETQ SUBARG (%VALUE ITER-001))
     (CL:WHEN
      (CL:NOT (EQL? (ARGUMENT-BOUND-TO SUPERARG) (VALUE-OF SUBARG)))
      (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
   (CL:WHEN ALWAYS?-000
    (CL:LET*
     ((LASTSUPERVALUE
       (ARGUMENT-BOUND-TO (LAST (%ARGUMENTS REFERENCEPROPOSITION))))
      (LASTSUBVALUE (VALUE-OF (LAST (%ARGUMENTS NEXTPROPOSITION)))))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ LASTSUPERVALUE NULL))
       (CL:NOT (CL:EQ LASTSUBVALUE NULL))
       (CL:NOT (EQL? LASTSUPERVALUE LASTSUBVALUE))
       (CL:NOT (ISA? LASTSUBVALUE SGT-SPECIALIZE-LOGIC-SKOLEM))
       (CL:NOT (ISA? LASTSUPERVALUE SGT-SPECIALIZE-LOGIC-SKOLEM)))
      (CL:RETURN-FROM CLASHES-WITH-FUNCTION-PROPOSITION? TRUE)))))
  FALSE)

;;; (DEFUN (ALL-CLASHING-PROPOSITIONS TRUE-DEPENDENT-PROPOSITIONS-ITERATOR) ...)

(CL:DEFUN ALL-CLASHING-PROPOSITIONS (SELF)
  (CL:LET*
   ((BACKLINKEDARGUMENT (SELECT-ARGUMENT-WITH-BACKLINKS SELF))
    (ITERATOR NULL))
   (CL:WHEN (CL:EQ BACKLINKEDARGUMENT NULL)
    (CL:RETURN-FROM ALL-CLASHING-PROPOSITIONS
     EMPTY-ALL-PROPOSITIONS-ITERATOR))
   (CL:SETQ ITERATOR
    (ALL-TRUE-DEPENDENT-PROPOSITIONS BACKLINKEDARGUMENT (%OPERATOR SELF)
     FALSE))
   (CL:SETF (%REFERENCE-PROPOSITION ITERATOR) SELF)
   (CL:COND
    ((CL:EQ (%KIND SELF) KWD-SPECIALIZE-FUNCTION)
     (CL:SETF (%SUBSUMPTION-TEST-FILTER? ITERATOR)
      (CL:FUNCTION CLASHES-WITH-FUNCTION-PROPOSITION?)))
    (CL:T))
   ITERATOR))

;;; (DEFGLOBAL *IMPLICATION-SUBSUMPTION-GRAPH* ...)

(CL:DEFVAR *IMPLICATION-SUBSUMPTION-GRAPH* NULL)

;;; (DEFUN (RELATIONS-WITH-DESCRIPTIONS (LIST OF RELATION)) ...)

(CL:DEFUN RELATIONS-WITH-DESCRIPTIONS ()
  (CL:LET* ((RESULT (NEW-LIST)))
   (CL:LET*
    ((CLASS NULL) (ITER-000 (ALL-CLASSES NULL FALSE)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ CLASS (%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CLASS)
         SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL)
        NULL))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS CLASS NIL))
        (CL:IF (CL:EQ (%THE-CONS-LIST RESULT) NIL)
         (CL:SETF (%THE-CONS-LIST RESULT) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST RESULT)
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS CLASS NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:LET*
    ((SLOT NULL) (ITER-001 (ALL-SLOTS NULL FALSE)) (COLLECT-001 NULL))
    (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ SLOT (%VALUE ITER-001))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SLOT)
         SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL)
        NULL))
      (CL:IF (CL:EQ COLLECT-001 NULL)
       (CL:PROGN (CL:SETQ COLLECT-001 (CONS SLOT NIL))
        (CL:IF (CL:EQ (%THE-CONS-LIST RESULT) NIL)
         (CL:SETF (%THE-CONS-LIST RESULT) COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST RESULT)
          COLLECT-001)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS SLOT NIL))
        (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))))
   RESULT))

;;; (DEFUN BUILD-SUBSUMPTION-TAXONOMY-GRAPH ...)

(CL:DEFUN BUILD-SUBSUMPTION-TAXONOMY-GRAPH ()
  (CL:LET* ((RELATIONSWITHDESCRIPTIONS (RELATIONS-WITH-DESCRIPTIONS)))
   (CL:LET*
    ((R NULL) (ITER-000 (%THE-CONS-LIST RELATIONSWITHDESCRIPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ R (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS R)
       SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL)
      NULL)))
   (CL:LET*
    ((R NULL) (ITER-001 (%THE-CONS-LIST RELATIONSWITHDESCRIPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ R (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:LET* ((SUPER NULL) (ITER-002 (DIRECT-SUPERRELATIONS R)))
      (CL:LOOP WHILE (NEXT? ITER-002) DO (CL:SETQ SUPER (%VALUE ITER-002))
       (CL:WHEN (MEMBER? RELATIONSWITHDESCRIPTIONS SUPER)
        (CREATE-TAXONOMY-LINK *IMPLICATION-SUBSUMPTION-GRAPH*
         (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SUPER)
           SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL))
         (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS R)
           SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL))))))))))

;;; (DEFUN CLEAR-IMPLICATION-SUBSUMPTION-GRAPH ...)

(CL:DEFUN CLEAR-IMPLICATION-SUBSUMPTION-GRAPH ()
  (CL:LET*
   ((R NULL) (ITER-000 (%THE-CONS-LIST (RELATIONS-WITH-DESCRIPTIONS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ R (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (SET-DYNAMIC-SLOT-VALUE
     (%DYNAMIC-SLOTS
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS R)
       SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL))
     SYM-SPECIALIZE-STELLA-TAXONOMY-NODE NULL NULL))))

;;; (DEFUN INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH ...)

(CL:DEFUN INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH ()
  (CLEAR-IMPLICATION-SUBSUMPTION-GRAPH)
  (CL:SETQ *IMPLICATION-SUBSUMPTION-GRAPH* (NEW-TAXONOMY-GRAPH))
  (FINALIZE-TAXONOMY-GRAPH *IMPLICATION-SUBSUMPTION-GRAPH*))

;;; (DEFUN (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ...)

(CL:DEFUN FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE (DESCRIPTION)
  (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS DESCRIPTION)
   SYM-SPECIALIZE-STELLA-TAXONOMY-NODE NULL))

;;; (DEFUN (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ...)

(CL:DEFUN CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE (DESCRIPTION PARENTNODE)
  (CL:LET*
   ((NODE
     (CREATE-TAXONOMY-NODE *IMPLICATION-SUBSUMPTION-GRAPH* PARENTNODE
      DESCRIPTION (CL:EQ PARENTNODE NULL))))
   (LINK-TAXONOMY-NODES *IMPLICATION-SUBSUMPTION-GRAPH* PARENTNODE NODE)
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS DESCRIPTION)
    SYM-SPECIALIZE-STELLA-TAXONOMY-NODE NODE NULL)
   NODE))

;;; (DEFUN (FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ...)

(CL:DEFUN FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE (DESCRIPTION)
  (CL:LET*
   ((RESULT (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE DESCRIPTION)))
   (CL:WHEN (CL:NOT (CL:EQ RESULT NULL))
    (CL:RETURN-FROM
     FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE RESULT))
   (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE DESCRIPTION NULL)))

;;; (DEFUN (CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS DESCRIPTION) ...)

(CL:DEFUN CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS (SELF)
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:RETURN-FROM CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS
    NULL))
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION SELF))
    (TAXONOMYNODE
     (FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
      DESCRIPTION)))
   (CL:LET* ((SUPER NULL) (ITER-000 (DIRECT-SUPERRELATIONS SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ SUPER (%VALUE ITER-000))
     (CL:LET*
      ((SUPERDESCRIPTION
        (CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS SUPER))
       (SUPERTAXONOMYNODE
        (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE SUPERDESCRIPTION)))
      (CREATE-TAXONOMY-LINK *IMPLICATION-SUBSUMPTION-GRAPH*
       SUPERTAXONOMYNODE TAXONOMYNODE))))
   DESCRIPTION))

;;; (DEFUN ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK ...)

(CL:DEFUN ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK (TAILDESCRIPTION HEADDESCRIPTION)
  NULL)

;;; (DEFUN DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK ...)

(CL:DEFUN DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK (TAILDESCRIPTION HEADDESCRIPTION)
  (CL:PROGN (CL:SETQ HEADDESCRIPTION HEADDESCRIPTION)
   (CL:SETQ TAILDESCRIPTION TAILDESCRIPTION))
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
   "'drop-taxonomy-implies-subsumes-link':  Write me, I am a dummy!" EOL)
  NULL)

;;; (DEFUN (TAXONOMY-IMPLIES-OR-IS-SUBSUMED? BOOLEAN) ...)

(CL:DEFUN TAXONOMY-IMPLIES-OR-IS-SUBSUMED? (PREMISE CONCLUSION)
  (CL:LET*
   ((PREMISEDESCRIPTION
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PREMISE)
      SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL))
    (CONCLUSIONDESCRIPTION NULL))
   (CL:WHEN
    (CL:OR (CL:EQ PREMISEDESCRIPTION NULL)
     (CL:EQ
      (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE PREMISEDESCRIPTION)
      NULL))
    (CL:SETQ PREMISEDESCRIPTION
     (CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS PREMISE)))
   (CL:SETQ CONCLUSIONDESCRIPTION
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONCLUSION)
     SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL))
   (CL:WHEN (CL:EQ CONCLUSIONDESCRIPTION NULL)
    (CL:RETURN-FROM TAXONOMY-IMPLIES-OR-IS-SUBSUMED? FALSE))
   (CL:WHEN
    (CL:EQ
     (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE CONCLUSIONDESCRIPTION)
     NULL)
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "'taxonomy-implies-or-is-subsumed?' conclusionDescription should have taxonomy-node")))
   (TAXONOMY-SUBNODE-OF?
    (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE PREMISEDESCRIPTION)
    (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE CONCLUSIONDESCRIPTION))))

(CL:DEFUN HELP-STARTUP-SPECIALIZE1 ()
  (CL:PROGN
   (CL:SETQ SGT-SPECIALIZE-LOGIC-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR" NULL 1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-PROPOSITION-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION-CURSOR" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-KIND-OF-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KIND-OF-PROPOSITION" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-RELATION-OF-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-OF-PROPOSITION" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-SPECIALIZING-RELATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIALIZING-RELATIONS" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-VARIABLE-VALUE-INVERSE-STACK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-VALUE-INVERSE-STACK" NULL
     0))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-TRUE-DEPENDENT-PROPOSITIONS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE-DEPENDENT-PROPOSITIONS-ITERATOR"
     NULL 1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-SUBSUMPTION-TEST-FILTER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-TEST-FILTER?" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-RETURN-ARGUMENT-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN-ARGUMENT-INDEX" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-REFERENCE-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFERENCE-PROPOSITION" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-ITERATOR-INITIALIZATION-TOUCHED-DEFAULT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "ITERATOR-INITIALIZATION-TOUCHED-DEFAULT?" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-ITERATOR-VALUE-HOLDS-BY-DEFAULT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-VALUE-HOLDS-BY-DEFAULT?"
     NULL 0))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-DESCRIPTION-EXTENSION-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION-EXTENSION-ITERATOR" NULL
     1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SYM-SPECIALIZE-STELLA-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ KWD-SPECIALIZE-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-TEST-PROPERTY?-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TEST-PROPERTY?-MEMO-TABLE-000" NULL
     1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-TEST-ISA?-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TEST-ISA?-MEMO-TABLE-000" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-ACCESS-BINARY-VALUE-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACCESS-BINARY-VALUE-MEMO-TABLE-000"
     NULL 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-COLLECTION-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION-OF" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-TRANSITIVE-CLOSURE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSITIVE-CLOSURE-ITERATOR" NULL 1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOCATE-ADJACENCY-ITERATOR-FUNCTION"
     NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-FILTER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILTER?" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-ADJACENCY-ITERATOR-STACK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADJACENCY-ITERATOR-STACK" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-BEEN-THERE-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BEEN-THERE-LIST" NULL 0))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-DIRECTLY-LINKED-OBJECTS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTLY-LINKED-OBJECTS-ITERATOR"
     NULL 1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-INVERSE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INVERSE?" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-REFERENCE-INSTANCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFERENCE-INSTANCE" NULL 0))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ KWD-SPECIALIZE-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ KWD-SPECIALIZE-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-STELLA-TAXONOMY-NODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TAXONOMY-NODE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-STARTUP-SPECIALIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-SPECIALIZE" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))))

(CL:DEFUN STARTUP-SPECIALIZE ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-SPECIALIZE1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ EMPTY-ALL-PROPOSITIONS-ITERATOR
     (NEW-TRUE-DEPENDENT-PROPOSITIONS-ITERATOR)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR"
        "(DEFCLASS ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR (ITERATOR) :SLOTS ((PROPOSITION-CURSOR :TYPE (CONS OF PROPOSITION) :INITIALLY NIL) (KIND-OF-PROPOSITION :TYPE KEYWORD) (RELATION-OF-PROPOSITION :TYPE SURROGATE) (SPECIALIZING-RELATIONS :TYPE (CONS OF SURROGATE) :DOCUMENTATION \"If non-NULL a list of relations specializing `relation-of-proposition'.\") (VARIABLE-VALUE-INVERSE-STACK :TYPE (CONS OF CONS) :INITIALLY NIL)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION
       ACCESS-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRUE-DEPENDENT-PROPOSITIONS-ITERATOR"
        "(DEFCLASS TRUE-DEPENDENT-PROPOSITIONS-ITERATOR (ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR) :PARAMETERS ((ANY-VALUE :TYPE PROPOSITION)) :SLOTS ((SUBSUMPTION-TEST-FILTER? :TYPE FUNCTION-CODE) (RETURN-ARGUMENT-INDEX :TYPE INTEGER) (REFERENCE-PROPOSITION :TYPE PROPOSITION) (ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? :TYPE BOOLEAN :INITIALLY FALSE :DOCUMENTATION \"If TRUE, an iterator initialization operations such
as geneating all subrelations might have touched a default.\") (ITERATOR-VALUE-HOLDS-BY-DEFAULT? :TYPE BOOLEAN :INITIALLY FALSE :DOCUMENTATION \"If TRUE, the generation of the most recent value
might have involved some default knowledge.\")))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRUE-DEPENDENT-PROPOSITIONS-ITERATOR))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION
       ACCESS-TRUE-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TRANSITIVE-CLOSURE-ITERATOR"
        "(DEFCLASS TRANSITIVE-CLOSURE-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator that visits all nodes reachable using an
embedded adjacency function.\" :SLOTS ((ALLOCATE-ADJACENCY-ITERATOR-FUNCTION :TYPE FUNCTION-CODE) (FILTER? :TYPE FUNCTION-CODE) (ADJACENCY-ITERATOR-STACK :TYPE (CONS OF ITERATOR) :INITIALLY NIL) (BEEN-THERE-LIST :TYPE CONS)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRANSITIVE-CLOSURE-ITERATOR))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TRANSITIVE-CLOSURE-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "DIRECTLY-LINKED-OBJECTS-ITERATOR"
        "(DEFCLASS DIRECTLY-LINKED-OBJECTS-ITERATOR (ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((INVERSE? :TYPE BOOLEAN) (REFERENCE-INSTANCE :TYPE OBJECT)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-DIRECTLY-LINKED-OBJECTS-ITERATOR))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-DIRECTLY-LINKED-OBJECTS-ITERATOR-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "VALUE-HOLDS-BY-DEFAULT?"
     "(DEFUN (VALUE-HOLDS-BY-DEFAULT? BOOLEAN) ((SELF (ITERATOR OF PROPOSITION))))"
     (CL:FUNCTION VALUE-HOLDS-BY-DEFAULT?) NULL)
    (DEFINE-FUNCTION-OBJECT "VALUE-HOLDS-BY-DEFAULT?-SETTER"
     "(DEFUN (VALUE-HOLDS-BY-DEFAULT?-SETTER BOOLEAN) ((SELF (ITERATOR OF PROPOSITION)) (VALUE BOOLEAN)))"
     (CL:FUNCTION VALUE-HOLDS-BY-DEFAULT?-SETTER) NULL)
    (DEFINE-FUNCTION-OBJECT "FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM"
     "(DEFUN (FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM (CONS OF PROPOSITION)) ((SELF ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR)))"
     (CL:FUNCTION FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM) NULL)
    (DEFINE-FUNCTION-OBJECT "TRUE-PROPOSITION?"
     "(DEFUN (TRUE-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (WHEN (DELETED? PROPOSITION) (RETURN FALSE)) (RETURN (CHOOSE *REVERSEPOLARITY?* (FALSE? PROPOSITION) (OR (TRUE? PROPOSITION) (FUNCTION-WITH-DEFINED-VALUE? PROPOSITION)))))"
     (CL:FUNCTION TRUE-PROPOSITION?) NULL)
    (DEFINE-FUNCTION-OBJECT "APPLY-TRUE-DEPENDENT-PROPOSITIONS-FILTER?"
     "(DEFUN (APPLY-TRUE-DEPENDENT-PROPOSITIONS-FILTER? BOOLEAN) ((PROPOSITION PROPOSITION) (SELF TRUE-DEPENDENT-PROPOSITIONS-ITERATOR)))"
     (CL:FUNCTION APPLY-TRUE-DEPENDENT-PROPOSITIONS-FILTER?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF TRUE-DEPENDENT-PROPOSITIONS-ITERATOR)) :PUBLIC? TRUE)"
     (CL:FUNCTION NEXT?) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-TRUE-DEPENDENT-PROPOSITIONS"
     "(DEFUN (ALL-TRUE-DEPENDENT-PROPOSITIONS (TRUE-DEPENDENT-PROPOSITIONS-ITERATOR OF PROPOSITION)) ((SELF OBJECT) (RELATION SURROGATE) (SPECIALIZE? BOOLEAN)))"
     (CL:FUNCTION ALL-TRUE-DEPENDENT-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "ARGUMENTS-UNIFY-WITH-ARGUMENTS?"
     "(DEFUN (ARGUMENTS-UNIFY-WITH-ARGUMENTS? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
     (CL:FUNCTION ARGUMENTS-UNIFY-WITH-ARGUMENTS?) NULL)
    (DEFINE-FUNCTION-OBJECT "ARGUMENTS-EQUAL-ARGUMENTS?"
     "(DEFUN (ARGUMENTS-EQUAL-ARGUMENTS? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
     (CL:FUNCTION ARGUMENTS-EQUAL-ARGUMENTS?) NULL)
    (DEFINE-FUNCTION-OBJECT "ARGUMENTS-MATCH-ARGUMENTS?"
     "(DEFUN (ARGUMENTS-MATCH-ARGUMENTS? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
     (CL:FUNCTION ARGUMENTS-MATCH-ARGUMENTS?) NULL)
    (DEFINE-FUNCTION-OBJECT "PREFIX-ARGUMENTS-EQUAL-ARGUMENTS?"
     "(DEFUN (PREFIX-ARGUMENTS-EQUAL-ARGUMENTS? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
     (CL:FUNCTION PREFIX-ARGUMENTS-EQUAL-ARGUMENTS?) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-MATCHING-PROPOSITIONS"
     "(DEFUN (ALL-MATCHING-PROPOSITIONS (ITERATOR OF PROPOSITION)) ((SELF PROPOSITION)))"
     (CL:FUNCTION ALL-MATCHING-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-PROPOSITIONS-MATCHING-ARGUMENTS"
     "(DEFUN (ALL-PROPOSITIONS-MATCHING-ARGUMENTS (CONS OF PROPOSITION)) ((ARGUMENTS CONS) (RELATION SURROGATE) (SPECIALIZE? BOOLEAN)))"
     (CL:FUNCTION ALL-PROPOSITIONS-MATCHING-ARGUMENTS) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-DEFINING-PROPOSITIONS"
     "(DEFUN (ALL-DEFINING-PROPOSITIONS (CONS OF PROPOSITION)) ((OUTPUTARGUMENT OBJECT) (RELATION SURROGATE) (SPECIALIZE? BOOLEAN)))"
     (CL:FUNCTION ALL-DEFINING-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-MEMOIZE-TEST-PROPERTY?"
     "(DEFUN (HELP-MEMOIZE-TEST-PROPERTY? BOOLEAN) ((SELF OBJECT) (RELATION SURROGATE)))"
     (CL:FUNCTION HELP-MEMOIZE-TEST-PROPERTY?) NULL)
    (DEFINE-FUNCTION-OBJECT "TEST-PROPERTY?"
     "(DEFUN (TEST-PROPERTY? BOOLEAN) ((SELF OBJECT) (RELATION SURROGATE)) :PUBLIC? TRUE)"
     (CL:FUNCTION TEST-PROPERTY?) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-MEMOIZE-TEST-ISA?"
     "(DEFUN (HELP-MEMOIZE-TEST-ISA? BOOLEAN) ((MEMBER OBJECT) (TYPE SURROGATE)))"
     (CL:FUNCTION HELP-MEMOIZE-TEST-ISA?) NULL)
    (DEFINE-FUNCTION-OBJECT "TEST-ISA?"
     "(DEFUN (TEST-ISA? BOOLEAN) ((MEMBER OBJECT) (TYPE SURROGATE)) :PUBLIC? TRUE)"
     (CL:FUNCTION TEST-ISA?) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-MEMOIZE-ACCESS-BINARY-VALUE"
     "(DEFUN (HELP-MEMOIZE-ACCESS-BINARY-VALUE OBJECT) ((SELF OBJECT) (RELATION SURROGATE)))"
     (CL:FUNCTION HELP-MEMOIZE-ACCESS-BINARY-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "ACCESS-BINARY-VALUE"
     "(DEFUN (ACCESS-BINARY-VALUE OBJECT) ((SELF OBJECT) (RELATION SURROGATE)) :PUBLIC? TRUE)"
     (CL:FUNCTION ACCESS-BINARY-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "TEST-COLLECTIONOF-MEMBER-OF?"
     "(DEFUN (TEST-COLLECTIONOF-MEMBER-OF? BOOLEAN) ((MEMBER OBJECT) (TYPE SURROGATE)))"
     (CL:FUNCTION TEST-COLLECTIONOF-MEMBER-OF?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD FREE ((SELF TRANSITIVE-CLOSURE-ITERATOR)))"
     (CL:FUNCTION FREE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF TRANSITIVE-CLOSURE-ITERATOR)))"
     (CL:FUNCTION NEXT?) NULL)
    (DEFINE-FUNCTION-OBJECT "ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR"
     "(DEFUN (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR ITERATOR) ((STARTNODE OBJECT) (ALLOCATEADJACENCYITERATOR FUNCTION-CODE) (FILTERFUNCTION FUNCTION-CODE)) :DOCUMENTATION \"Return an iterator that generates the transitive
closure of applying iterators generated by 'allocateAdjacencyIterator'
to 'startNode'.  If 'filterFunction' is non-null, that function is applied
as a filter to each node generated (nodes filtered out still generate
descendants, but they don't get returned).\")"
     (CL:FUNCTION ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF DIRECTLY-LINKED-OBJECTS-ITERATOR)))"
     (CL:FUNCTION NEXT?) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-DIRECTLY-LINKED-OBJECTS"
     "(DEFUN (ALL-DIRECTLY-LINKED-OBJECTS ITERATOR) ((SELF OBJECT) (KIND KEYWORD) (INVERSE? BOOLEAN)))"
     (CL:FUNCTION ALL-DIRECTLY-LINKED-OBJECTS) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-DIRECT-SUPERCOLLECTIONS"
     "(DEFUN (ALL-DIRECT-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT) (PERFORMFILTERING? BOOLEAN)))"
     (CL:FUNCTION ALL-DIRECT-SUPERCOLLECTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS"
     "(DEFUN (ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))"
     (CL:FUNCTION ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-DIRECT-SUBCOLLECTIONS"
     "(DEFUN (ALL-DIRECT-SUBCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT) (PERFORMFILTERING? BOOLEAN)))"
     (CL:FUNCTION ALL-DIRECT-SUBCOLLECTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS"
     "(DEFUN (ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))"
     (CL:FUNCTION ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-SUPERCOLLECTIONS"
     "(DEFUN (ALL-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))"
     (CL:FUNCTION ALL-SUPERCOLLECTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-SUBCOLLECTIONS"
     "(DEFUN (ALL-SUBCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))"
     (CL:FUNCTION ALL-SUBCOLLECTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-ISA-COLLECTIONS"
     "(DEFUN (ALL-ISA-COLLECTIONS (CONS OF LOGIC-OBJECT)) ((SELF OBJECT)))"
     (CL:FUNCTION ALL-ISA-COLLECTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "CLASHES-WITH-FUNCTION-PROPOSITION?"
     "(DEFUN (CLASHES-WITH-FUNCTION-PROPOSITION? BOOLEAN) ((NEXTPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
     (CL:FUNCTION CLASHES-WITH-FUNCTION-PROPOSITION?) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-CLASHING-PROPOSITIONS"
     "(DEFUN (ALL-CLASHING-PROPOSITIONS TRUE-DEPENDENT-PROPOSITIONS-ITERATOR) ((SELF PROPOSITION)))"
     (CL:FUNCTION ALL-CLASHING-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "RELATIONS-WITH-DESCRIPTIONS"
     "(DEFUN (RELATIONS-WITH-DESCRIPTIONS (LIST OF RELATION)) ())"
     (CL:FUNCTION RELATIONS-WITH-DESCRIPTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "BUILD-SUBSUMPTION-TAXONOMY-GRAPH"
     "(DEFUN BUILD-SUBSUMPTION-TAXONOMY-GRAPH ())"
     (CL:FUNCTION BUILD-SUBSUMPTION-TAXONOMY-GRAPH) NULL)
    (DEFINE-FUNCTION-OBJECT "CLEAR-IMPLICATION-SUBSUMPTION-GRAPH"
     "(DEFUN CLEAR-IMPLICATION-SUBSUMPTION-GRAPH ())"
     (CL:FUNCTION CLEAR-IMPLICATION-SUBSUMPTION-GRAPH) NULL)
    (DEFINE-FUNCTION-OBJECT "INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH"
     "(DEFUN INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH ())"
     (CL:FUNCTION INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH) NULL)
    (DEFINE-FUNCTION-OBJECT
     "FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE"
     "(DEFUN (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ((DESCRIPTION DESCRIPTION)))"
     (CL:FUNCTION FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE) NULL)
    (DEFINE-FUNCTION-OBJECT
     "CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE"
     "(DEFUN (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ((DESCRIPTION DESCRIPTION) (PARENTNODE TAXONOMY-NODE)))"
     (CL:FUNCTION CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE) NULL)
    (DEFINE-FUNCTION-OBJECT
     "FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE"
     "(DEFUN (FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ((DESCRIPTION DESCRIPTION)))"
     (CL:FUNCTION FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE)
     NULL)
    (DEFINE-FUNCTION-OBJECT
     "CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS"
     "(DEFUN (CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS DESCRIPTION) ((SELF RELATION)))"
     (CL:FUNCTION CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS)
     NULL)
    (DEFINE-FUNCTION-OBJECT "ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK"
     "(DEFUN ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK ((TAILDESCRIPTION DESCRIPTION) (HEADDESCRIPTION DESCRIPTION)))"
     (CL:FUNCTION ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK) NULL)
    (DEFINE-FUNCTION-OBJECT "DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK"
     "(DEFUN DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK ((TAILDESCRIPTION DESCRIPTION) (HEADDESCRIPTION DESCRIPTION)))"
     (CL:FUNCTION DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK) NULL)
    (DEFINE-FUNCTION-OBJECT "TAXONOMY-IMPLIES-OR-IS-SUBSUMED?"
     "(DEFUN (TAXONOMY-IMPLIES-OR-IS-SUBSUMED? BOOLEAN) ((PREMISE RELATION) (CONCLUSION RELATION)))"
     (CL:FUNCTION TAXONOMY-IMPLIES-OR-IS-SUBSUMED?) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-SPECIALIZE"
     "(DEFUN STARTUP-SPECIALIZE () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-SPECIALIZE) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-SPECIALIZE-LOGIC-STARTUP-SPECIALIZE)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-SPECIALIZE-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "Startup-Specialize") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT EMPTY-ALL-PROPOSITIONS-ITERATOR (TRUE-DEPENDENT-PROPOSITIONS-ITERATOR OF PROPOSITION) (NEW TRUE-DEPENDENT-PROPOSITIONS-ITERATOR) :DOCUMENTATION \"This iterator returns no values whenever its called.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *IMPLICATION-SUBSUMPTION-GRAPH* TAXONOMY-GRAPH NULL)")
    (INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH))))
