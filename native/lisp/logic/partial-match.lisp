;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997-2000              | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-PARTIAL-MATCH-BASIC NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-SET-PARTIAL-MATCH-MODE NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-COMMON-LISP NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-FUNCTION NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-MAX NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-KIND NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-POSITIVE-SCORE NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-NEGATIVE-SCORE NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-SUCCESS? NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-PARENT NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-CHILD NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-SCORES NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-WEIGHTS NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-STELLA-ARITY NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-DYNAMIC-CUTOFF NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-UNBOUND-VARS NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-FRAME-PTR NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-SET-RULE-COMBINATION NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-SET-GREEDY-NETWORK-PRUNING NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-SET-MAXIMUM-SCORE-CUTOFF NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-SET-MINIMUM-SCORE-CUTOFF NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-TRUE NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-FAIL NULL)
(CL:DEFVAR SGT-PARTIAL-MATCH-LOGIC-INCREMENTAL-PARTIAL-MATCH NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-TOTAL-WEIGHT NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-SCORE NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-WEIGHT NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-MAXIMUM-SCORE NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-AND NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-ITERATIVE-FORALL NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-OR NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-NOT NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-ATOMIC-GOAL NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-NOISY-OR NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-GOAL-TREE NULL)
(CL:DEFVAR SGT-PARTIAL-MATCH-LOGIC-NN-PARTIAL-MATCH NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-RULES NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-NEURAL-NETWORK NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-FULL-SUBQUERY NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-STELLA-ITERATOR NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-INCREMENTAL NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-NN NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-NEURAL-NETWORK NULL)
(CL:DEFVAR SGT-PARTIAL-MATCH-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-RETRIEVE-PARTIAL NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-BEST NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-ALL NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-ASK-PARTIAL NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-ASK-FIRST-PARTIAL NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-SUPPORT NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-STARTUP-PARTIAL-MATCH NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* *ACTIVATED-NETWORKS*
  *MOST-RECENT-QUERY* STANDARD-ERROR NULL-FLOAT-WRAPPER STANDARD-OUTPUT
  *QUERYITERATOR* EOL TRUE-WRAPPER FALSE-WRAPPER))

;;; (DEFGLOBAL *PARTIAL-MATCH-MODE* ...)

(CL:DEFVAR *PARTIAL-MATCH-MODE* NULL)

;;; (DEFGLOBAL *GREEDY-NETWORK-PRUNING* ...)

(CL:DEFVAR *GREEDY-NETWORK-PRUNING* TRUE)

;;; (DEFUN SET-PARTIAL-MATCH-MODE ...)

(CL:DEFUN %SET-PARTIAL-MATCH-MODE (K)
  (CL:SETQ *PARTIAL-MATCH-MODE* K))

(CL:DEFMACRO SET-PARTIAL-MATCH-MODE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/SET-PARTIAL-MATCH-MODE)) (CL:MACRO-FUNCTION (CL:QUOTE SET-PARTIAL-MATCH-MODE)))

;;; (DEFGLOBAL *RULE-COMBINATION* ...)

(CL:DEFVAR *RULE-COMBINATION* NULL)

;;; (DEFGLOBAL *PLANNING-MODE* ...)

(CL:DEFVAR *PLANNING-MODE* FALSE)

;;; (DEFGLOBAL *PLANABLE-PREDICATES* ...)

(CL:DEFVAR *PLANABLE-PREDICATES* NIL)

;;; (DEFCLASS PARTIAL-MATCH-FRAME ...)

(CL:DEFCLASS PARTIAL-MATCH-FRAME (STANDARD-OBJECT)
  ((KIND :ALLOCATION :INSTANCE :ACCESSOR %KIND)
   (POSITIVE-SCORE :ALLOCATION :INSTANCE :ACCESSOR %POSITIVE-SCORE)
   (NEGATIVE-SCORE :ALLOCATION :INSTANCE :ACCESSOR %NEGATIVE-SCORE)
   (SUCCESS? :ALLOCATION :INSTANCE :ACCESSOR %SUCCESS?)
   (PARENT :ALLOCATION :INSTANCE :ACCESSOR %PARENT)
   (CHILD :ALLOCATION :INSTANCE :ACCESSOR %CHILD)
   (ARGUMENT-SCORES :ALLOCATION :INSTANCE :ACCESSOR %ARGUMENT-SCORES)
   (ARGUMENT-WEIGHTS :ALLOCATION :INSTANCE :ACCESSOR %ARGUMENT-WEIGHTS)
   (PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR %PROPOSITION)
   (ARITY :ALLOCATION :INSTANCE :ACCESSOR %ARITY)
   (DYNAMIC-CUTOFF :ALLOCATION :INSTANCE :ACCESSOR %DYNAMIC-CUTOFF)
   (UNBOUND-VARS :ALLOCATION :INSTANCE :ACCESSOR %UNBOUND-VARS)
   (FRAME-PTR :ALLOCATION :INSTANCE :ACCESSOR %FRAME-PTR))
  (:DOCUMENTATION "Abstract class acting as placeholder for system and
user-defined partial match implementations."))

(CL:DEFUN ACCESS-PARTIAL-MATCH-FRAME-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-KIND)
    (CL:IF SETVALUE? (CL:SETF (%KIND SELF) VALUE)
     (CL:SETQ VALUE (%KIND SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-POSITIVE-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%POSITIVE-SCORE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%POSITIVE-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-NEGATIVE-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%NEGATIVE-SCORE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%NEGATIVE-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-SUCCESS?)
    (CL:IF SETVALUE?
     (CL:SETF (%SUCCESS? SELF) (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE (CL:IF (%SUCCESS? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-PARENT)
    (CL:IF SETVALUE? (CL:SETF (%PARENT SELF) VALUE)
     (CL:SETQ VALUE (%PARENT SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-CHILD)
    (CL:IF SETVALUE? (CL:SETF (%CHILD SELF) VALUE)
     (CL:SETQ VALUE (%CHILD SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-SCORES)
    (CL:IF SETVALUE? (CL:SETF (%ARGUMENT-SCORES SELF) VALUE)
     (CL:SETQ VALUE (%ARGUMENT-SCORES SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-WEIGHTS)
    (CL:IF SETVALUE? (CL:SETF (%ARGUMENT-WEIGHTS SELF) VALUE)
     (CL:SETQ VALUE (%ARGUMENT-WEIGHTS SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-STELLA-ARITY)
    (CL:IF SETVALUE? (CL:SETF (%ARITY SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%ARITY SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-DYNAMIC-CUTOFF)
    (CL:IF SETVALUE?
     (CL:SETF (%DYNAMIC-CUTOFF SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%DYNAMIC-CUTOFF SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-UNBOUND-VARS)
    (CL:IF SETVALUE? (CL:SETF (%UNBOUND-VARS SELF) VALUE)
     (CL:SETQ VALUE (%UNBOUND-VARS SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-FRAME-PTR)
    (CL:IF SETVALUE? (CL:SETF (%FRAME-PTR SELF) VALUE)
     (CL:SETQ VALUE (%FRAME-PTR SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFGLOBAL *FAIL-UNBOUND-CLAUSES* ...)

(CL:DEFVAR *FAIL-UNBOUND-CLAUSES* FALSE)

;;; (DEFGLOBAL *MINIMUM-SCORE-CUTOFF* ...)

(CL:PROGN (CL:DEFVAR *MINIMUM-SCORE-CUTOFF* 0.0d0 "Positive scores below *minimum-score-cutoff* get trimmed
to 0.0 during partial match operations.") (CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *MINIMUM-SCORE-CUTOFF*)))

;;; (DEFGLOBAL *MAXIMUM-SCORE-CUTOFF* ...)

(CL:PROGN (CL:DEFVAR *MAXIMUM-SCORE-CUTOFF* 0.0d0 "Positive scores above *maximum-score-cutoff* get trimmed
to 1.0 during partial match operations.") (CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *MAXIMUM-SCORE-CUTOFF*)))

;;; (DEFUN SET-RULE-COMBINATION ...)

(CL:DEFUN %SET-RULE-COMBINATION (K)
  (CL:SETQ *RULE-COMBINATION* K))

(CL:DEFMACRO SET-RULE-COMBINATION (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/SET-RULE-COMBINATION)) (CL:MACRO-FUNCTION (CL:QUOTE SET-RULE-COMBINATION)))

;;; (DEFUN SET-GREEDY-NETWORK-PRUNING ...)

(CL:DEFUN %SET-GREEDY-NETWORK-PRUNING (B)
  (CL:SETQ *GREEDY-NETWORK-PRUNING* B))

(CL:DEFUN SET-GREEDY-NETWORK-PRUNING-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-GREEDY-NETWORK-PRUNING (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-GREEDY-NETWORK-PRUNING (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/SET-GREEDY-NETWORK-PRUNING)) (CL:MACRO-FUNCTION (CL:QUOTE SET-GREEDY-NETWORK-PRUNING)))

;;; (DEFUN SET-MAXIMUM-SCORE-CUTOFF ...)

(CL:DEFUN %SET-MAXIMUM-SCORE-CUTOFF (C)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT C))
  (CL:SETQ *MAXIMUM-SCORE-CUTOFF* C))

(CL:DEFUN SET-MAXIMUM-SCORE-CUTOFF-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-MAXIMUM-SCORE-CUTOFF (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-MAXIMUM-SCORE-CUTOFF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/SET-MAXIMUM-SCORE-CUTOFF)) (CL:MACRO-FUNCTION (CL:QUOTE SET-MAXIMUM-SCORE-CUTOFF)))

;;; (DEFUN SET-MINIMUM-SCORE-CUTOFF ...)

(CL:DEFUN %SET-MINIMUM-SCORE-CUTOFF (C)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT C))
  (CL:SETQ *MAXIMUM-SCORE-CUTOFF* C))

(CL:DEFUN SET-MINIMUM-SCORE-CUTOFF-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-MINIMUM-SCORE-CUTOFF (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-MINIMUM-SCORE-CUTOFF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/SET-MINIMUM-SCORE-CUTOFF)) (CL:MACRO-FUNCTION (CL:QUOTE SET-MINIMUM-SCORE-CUTOFF)))

;;; (DEFGLOBAL *AND-MISSED-A-BINDING* ...)

(CL:DEFVAR *AND-MISSED-A-BINDING* FALSE)

;;; (DEFUN (PROPOSITION-WEIGHT FLOAT) ...)

(CL:DEFUN PROPOSITION-WEIGHT (PROP)
  (CL:WHEN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? PROP))
   (CL:SETF (%WEIGHT PROP) 0.0d0))
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE PROP) (%HOME-CONTEXT PROP) FALSE)
     NULL))
   (CL:SETF (%WEIGHT PROP)
    (%POSITIVE-SCORE
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE PROP) (%HOME-CONTEXT PROP) FALSE))))
  (CL:WHEN (CL:= (%WEIGHT PROP) NULL-FLOAT) (CL:SETF (%WEIGHT PROP) 1.0d0))
  (%WEIGHT PROP))

;;; (DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME PARTIAL-MATCH-FRAME) ...)

(CL:DEFMETHOD CREATE-PARTIAL-MATCH-FRAME ((SELF PARTIAL-MATCH-FRAME) FRAME KIND)
  (CL:PROGN (CL:SETQ FRAME FRAME) (CL:SETQ KIND KIND))
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
    "Missing concrete method named 'create-partial-match-frame' on the"
    EOL "   class `" (PRIMARY-TYPE SELF) "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD SET-DYNAMIC-CUTOFF ...)

(CL:DEFMETHOD SET-DYNAMIC-CUTOFF ((SELF PARTIAL-MATCH-FRAME) MY-WEIGHT)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT MY-WEIGHT)))

;;; (DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ...)

(CL:DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ((SELF PARTIAL-MATCH-FRAME) PROP TRUTH)
  (CL:COND
   ((CL:EQ TRUTH KWD-PARTIAL-MATCH-TRUE)
    (CL:SETF (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) 1.0d0))
   ((CL:EQ TRUTH KWD-PARTIAL-MATCH-FAIL)
    (CL:SETF (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) 0.0d0))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TRUTH
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ...)

(CL:DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ((SELF PARTIAL-MATCH-FRAME) SCORE WEIGHT)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE WEIGHT))
  (CL:PROGN (CL:SETQ SCORE SCORE) (CL:SETQ WEIGHT WEIGHT)))

;;; (DEFMETHOD POP-PARTIAL-MATCH-SCORE ...)

(CL:DEFMETHOD POP-PARTIAL-MATCH-SCORE ((SELF PARTIAL-MATCH-FRAME)))

;;; (DEFMETHOD (COMPUTE-AND-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-AND-SCORE ((SELF PARTIAL-MATCH-FRAME))
  NULL-FLOAT)

;;; (DEFMETHOD (COMPUTE-OR-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-OR-SCORE ((SELF PARTIAL-MATCH-FRAME))
  NULL-FLOAT)

;;; (DEFMETHOD (COMPUTE-NOT-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-NOT-SCORE ((SELF PARTIAL-MATCH-FRAME))
  NULL-FLOAT)

;;; (DEFMETHOD (COMPUTE-GOAL-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-GOAL-SCORE ((SELF PARTIAL-MATCH-FRAME))
  NULL-FLOAT)

;;; (DEFMETHOD (EARLY-PARTIAL-MATCH-AND-FAILURE? BOOLEAN) ...)

(CL:DEFMETHOD EARLY-PARTIAL-MATCH-AND-FAILURE? ((SELF PARTIAL-MATCH-FRAME))
  FALSE)

;;; (DEFMETHOD (EARLY-PARTIAL-MATCH-OR-SUCCESS? BOOLEAN) ...)

(CL:DEFMETHOD EARLY-PARTIAL-MATCH-OR-SUCCESS? ((SELF PARTIAL-MATCH-FRAME))
  FALSE)

;;; (DEFCLASS INCREMENTAL-PARTIAL-MATCH ...)

(CL:DEFCLASS INCREMENTAL-PARTIAL-MATCH (PARTIAL-MATCH-FRAME)
  ((TOTAL-WEIGHT :ALLOCATION :INSTANCE :ACCESSOR %TOTAL-WEIGHT)
   (ACCUMULATED-SCORE :ALLOCATION :INSTANCE :ACCESSOR %ACCUMULATED-SCORE)
   (ACCUMULATED-WEIGHT :ALLOCATION :INSTANCE :ACCESSOR
    %ACCUMULATED-WEIGHT)
   (MAXIMUM-SCORE :ALLOCATION :INSTANCE :ACCESSOR %MAXIMUM-SCORE)))

(CL:DEFUN NEW-INCREMENTAL-PARTIAL-MATCH ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INCREMENTAL-PARTIAL-MATCH)))
   (CL:SETF (%FRAME-PTR SELF) NULL) (CL:SETF (%UNBOUND-VARS SELF) NIL)
   (CL:SETF (%DYNAMIC-CUTOFF SELF) NULL-FLOAT)
   (CL:SETF (%ARITY SELF) NULL-INTEGER) (CL:SETF (%PROPOSITION SELF) NIL)
   (CL:SETF (%CHILD SELF) NULL) (CL:SETF (%PARENT SELF) NULL)
   (CL:SETF (%SUCCESS? SELF) FALSE)
   (CL:SETF (%NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%POSITIVE-SCORE SELF) NULL-FLOAT) (CL:SETF (%KIND SELF) NULL)
   (CL:SETF (%MAXIMUM-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%ARGUMENT-WEIGHTS SELF) NULL)
   (CL:SETF (%ARGUMENT-SCORES SELF) NULL)
   (CL:SETF (%ACCUMULATED-WEIGHT SELF) NULL-FLOAT)
   (CL:SETF (%ACCUMULATED-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%TOTAL-WEIGHT SELF) NULL-FLOAT) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INCREMENTAL-PARTIAL-MATCH))
  SGT-PARTIAL-MATCH-LOGIC-INCREMENTAL-PARTIAL-MATCH)

(CL:DEFUN ACCESS-INCREMENTAL-PARTIAL-MATCH-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-TOTAL-WEIGHT)
    (CL:IF SETVALUE? (CL:SETF (%TOTAL-WEIGHT SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%TOTAL-WEIGHT SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%ACCUMULATED-SCORE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%ACCUMULATED-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-WEIGHT)
    (CL:IF SETVALUE?
     (CL:SETF (%ACCUMULATED-WEIGHT SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%ACCUMULATED-WEIGHT SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-SCORES)
    (CL:IF SETVALUE? (CL:SETF (%ARGUMENT-SCORES SELF) VALUE)
     (CL:SETQ VALUE (%ARGUMENT-SCORES SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-WEIGHTS)
    (CL:IF SETVALUE? (CL:SETF (%ARGUMENT-WEIGHTS SELF) VALUE)
     (CL:SETQ VALUE (%ARGUMENT-WEIGHTS SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-MAXIMUM-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%MAXIMUM-SCORE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%MAXIMUM-SCORE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME PARTIAL-MATCH-FRAME) ...)

(CL:DEFMETHOD CREATE-PARTIAL-MATCH-FRAME ((SELF INCREMENTAL-PARTIAL-MATCH) FRAME KIND)
  (CL:LET* ((PARTIALMATCHFRAME (NEW-INCREMENTAL-PARTIAL-MATCH)))
   (CL:SETF (%FRAME-PTR PARTIALMATCHFRAME) FRAME)
   (CL:LET* ((TEMP-FRAME (%UP FRAME)))
    (CL:LOOP WHILE (CL:EQ (%PARTIAL-MATCH-FRAME TEMP-FRAME) NULL) DO
     (CL:SETQ TEMP-FRAME (%UP TEMP-FRAME)))
    (CL:SETF (%PARENT PARTIALMATCHFRAME)
     (%PARTIAL-MATCH-FRAME TEMP-FRAME))
    (CL:SETF (%CHILD (%PARTIAL-MATCH-FRAME TEMP-FRAME))
     PARTIALMATCHFRAME))
   (CL:SETF (%MAXIMUM-SCORE PARTIALMATCHFRAME) 0.0d0)
   (CL:SETF (%ARGUMENT-SCORES PARTIALMATCHFRAME) NIL)
   (CL:SETF (%ARGUMENT-WEIGHTS PARTIALMATCHFRAME) NIL)
   (CL:SETF (%POSITIVE-SCORE PARTIALMATCHFRAME) 0.0d0)
   (CL:SETF (%UNBOUND-VARS PARTIALMATCHFRAME) NIL)
   (CL:IF
    (CL:NOT
     (CL:EQ
      (ACCESS-IN-CONTEXT (%TRUTH-VALUE (%PROPOSITION FRAME))
       (%HOME-CONTEXT (%PROPOSITION FRAME)) FALSE)
      NULL))
    (CL:SETF (%WEIGHT (%PROPOSITION FRAME))
     (%POSITIVE-SCORE
      (ACCESS-IN-CONTEXT (%TRUTH-VALUE (%PROPOSITION FRAME))
       (%HOME-CONTEXT (%PROPOSITION FRAME)) FALSE)))
    (CL:SETF (%WEIGHT (%PROPOSITION FRAME)) 1.0d0))
   (CL:COND
    ((CL:EQ KIND KWD-PARTIAL-MATCH-AND)
     (CL:SETF (%ACCUMULATED-SCORE PARTIALMATCHFRAME) 0.0d0)
     (CL:SETF (%ACCUMULATED-WEIGHT PARTIALMATCHFRAME) 0.0d0)
     (CL:LET*
      ((ARGUMENTWEIGHT NULL-FLOAT) (TOTALWEIGHT 0.0d0)
       (NOFWEIGHTEDARGS 0))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT ARGUMENTWEIGHT TOTALWEIGHT)
       (CL:TYPE CL:FIXNUM NOFWEIGHTEDARGS))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%ARGUMENTS (%PROPOSITION FRAME)))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:PROGN
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
        (CL:COND
         ((CL:AND (CL:EQ (%KIND ARG) KWD-PARTIAL-MATCH-AND)
           (CL:= (%WEIGHT ARG) NULL-FLOAT))
          (CL:SETQ NOFWEIGHTEDARGS 0)
          (CL:LET*
           ((SUBARG NULL) (VECTOR-001 (%ARGUMENTS ARG)) (INDEX-001 0)
            (LENGTH-001 (LENGTH VECTOR-001)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
           (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
            (CL:PROGN
             (CL:SETQ SUBARG
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
               INDEX-001))
             (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
            (CL:WHEN
             (CL:OR (CL:= (PROPOSITION-WEIGHT SUBARG) NULL-FLOAT)
              (CL:> (PROPOSITION-WEIGHT SUBARG) 0.0d0))
             (CL:SETQ NOFWEIGHTEDARGS (CL:1+ NOFWEIGHTEDARGS)))))
          (CL:SETQ ARGUMENTWEIGHT (CL:* 1.0d0 NOFWEIGHTEDARGS))
          (CL:SETF (%WEIGHT ARG) ARGUMENTWEIGHT))
         (CL:T (CL:SETQ ARGUMENTWEIGHT 1.0d0)))
        (CL:SETQ TOTALWEIGHT (CL:+ TOTALWEIGHT ARGUMENTWEIGHT))))
      (CL:IF (CL:> TOTALWEIGHT 0.0d0)
       (CL:SETF (%TOTAL-WEIGHT PARTIALMATCHFRAME) TOTALWEIGHT)
       (CL:SETF (%TOTAL-WEIGHT PARTIALMATCHFRAME)
        (CL:FLOAT (LENGTH (%ARGUMENTS (%PROPOSITION FRAME))) 0.0d0)))))
    (CL:T))
   (SET-DYNAMIC-CUTOFF PARTIALMATCHFRAME
    (PROPOSITION-WEIGHT (%PROPOSITION FRAME)))
   PARTIALMATCHFRAME))

;;; (DEFMETHOD SET-DYNAMIC-CUTOFF ...)

(CL:DEFMETHOD SET-DYNAMIC-CUTOFF ((SELF INCREMENTAL-PARTIAL-MATCH) MY-WEIGHT)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT MY-WEIGHT))
  (CL:LET*
   ((PARENT (%PARENT SELF)) (FRAME-PARENT (%UP (%FRAME-PTR SELF)))
    (SCORE (%ACCUMULATED-SCORE PARENT))
    (WEIGHT (%ACCUMULATED-WEIGHT PARENT))
    (TOTAL-WEIGHT (%TOTAL-WEIGHT PARENT)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE WEIGHT TOTAL-WEIGHT))
   (CL:IF (CL:NOT (CL:= TOTAL-WEIGHT NULL-FLOAT))
    (CL:SETF (%DYNAMIC-CUTOFF SELF)
     (CL:- (CL:- (CL:* (%DYNAMIC-CUTOFF PARENT) TOTAL-WEIGHT) SCORE)
      (CL:- (CL:- TOTAL-WEIGHT WEIGHT) MY-WEIGHT)))
    (CL:SETF (%DYNAMIC-CUTOFF SELF) (%DYNAMIC-CUTOFF PARENT)))))

;;; (DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ...)

(CL:DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ((SELF INCREMENTAL-PARTIAL-MATCH) PROP TRUTH)
  (CL:COND
   ((CL:EQ TRUTH KWD-PARTIAL-MATCH-TRUE)
    (CL:SETF (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) 1.0d0))
   ((CL:EQ TRUTH KWD-PARTIAL-MATCH-FAIL)
    (CL:SETF (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) 0.0d0))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TRUTH
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ...)

(CL:DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH) SCORE WEIGHT)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE WEIGHT))
  (CL:WHEN (CL:= WEIGHT NULL-FLOAT) (CL:SETQ WEIGHT 1.0d0))
  (CL:LET* ((LISTOFSCORES (%ARGUMENT-SCORES SELF)))
   (CL:IF (CL:EQ LISTOFSCORES NIL)
    (CL:SETF (%ARGUMENT-SCORES SELF) (CONS (WRAP-FLOAT SCORE) NIL))
    (CL:SETF (%ARGUMENT-SCORES SELF)
     (CONS (WRAP-FLOAT SCORE) LISTOFSCORES))))
  (CL:LET* ((LISTOFWEIGHTS (%ARGUMENT-WEIGHTS SELF)))
   (CL:IF (CL:EQ LISTOFWEIGHTS NIL)
    (CL:SETF (%ARGUMENT-WEIGHTS SELF) (CONS (WRAP-FLOAT WEIGHT) NIL))
    (CL:SETF (%ARGUMENT-WEIGHTS SELF)
     (CONS (WRAP-FLOAT WEIGHT) LISTOFWEIGHTS))))
  (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-AND)
      (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-ITERATIVE-FORALL))
     (CL:SETF (%ACCUMULATED-SCORE SELF)
      (CL:+ (%ACCUMULATED-SCORE SELF) (CL:* SCORE WEIGHT)))
     (CL:SETF (%ACCUMULATED-WEIGHT SELF)
      (CL:+ (%ACCUMULATED-WEIGHT SELF) WEIGHT)))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-OR)
      (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-NOT)
      (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-ATOMIC-GOAL))
     (CL:WHEN (CL:> SCORE (%MAXIMUM-SCORE SELF))
      (CL:SETF (%MAXIMUM-SCORE SELF) SCORE)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFMETHOD POP-PARTIAL-MATCH-SCORE ...)

(CL:DEFMETHOD POP-PARTIAL-MATCH-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH))
  (CL:SETF (%ACCUMULATED-SCORE SELF)
   (CL:- (%ACCUMULATED-SCORE SELF)
    (CL:* (%WRAPPER-VALUE (%%VALUE (%ARGUMENT-SCORES SELF)))
     (%WRAPPER-VALUE (%%VALUE (%ARGUMENT-WEIGHTS SELF))))))
  (CL:SETF (%ACCUMULATED-WEIGHT SELF)
   (CL:- (%ACCUMULATED-WEIGHT SELF)
    (%WRAPPER-VALUE (%%VALUE (%ARGUMENT-WEIGHTS SELF)))))
  (CL:SETF (%ARGUMENT-SCORES SELF) (%%REST (%ARGUMENT-SCORES SELF)))
  (CL:SETF (%ARGUMENT-WEIGHTS SELF) (%%REST (%ARGUMENT-WEIGHTS SELF))))

;;; (DEFMETHOD (COMPUTE-AND-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-AND-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH))
  (CL:/ (%ACCUMULATED-SCORE SELF) (%TOTAL-WEIGHT SELF)))

;;; (DEFMETHOD (COMPUTE-OR-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-OR-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH))
  (%MAXIMUM-SCORE SELF))

;;; (DEFMETHOD (COMPUTE-GOAL-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-GOAL-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH))
  (CL:LET* ((SCORE 0.0d0)) (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE))
   (CL:COND
    ((CL:EQ *RULE-COMBINATION* KWD-PARTIAL-MATCH-MAX)
     (CL:SETQ SCORE (%MAXIMUM-SCORE SELF)))
    ((CL:EQ *RULE-COMBINATION* KWD-PARTIAL-MATCH-NOISY-OR)
     (CL:SETQ SCORE (PROBABILISTIC-SUM-N (%ARGUMENT-SCORES SELF))))
    (CL:T))
   SCORE))

;;; (DEFMETHOD (COMPUTE-NOT-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-NOT-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH))
  (CL:- 1.0d0 (CL:/ (%ACCUMULATED-SCORE SELF) (%TOTAL-WEIGHT SELF))))

;;; (DEFMETHOD (EARLY-PARTIAL-MATCH-AND-FAILURE? BOOLEAN) ...)

(CL:DEFMETHOD EARLY-PARTIAL-MATCH-AND-FAILURE? ((SELF INCREMENTAL-PARTIAL-MATCH))
  (CL:WHEN *AND-MISSED-A-BINDING* (CL:SETQ *AND-MISSED-A-BINDING* FALSE)
   (CL:SETF (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) 0.0d0)
   (CL:RETURN-FROM EARLY-PARTIAL-MATCH-AND-FAILURE? TRUE))
  (CL:LET*
   ((MAXPOSSIBLESCORE
     (CL:/
      (CL:+ (%ACCUMULATED-SCORE SELF)
       (CL:- (%TOTAL-WEIGHT SELF) (%ACCUMULATED-WEIGHT SELF)))
      (%TOTAL-WEIGHT SELF))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT MAXPOSSIBLESCORE))
   (CL:WHEN
    (CL:OR (CL:< MAXPOSSIBLESCORE *MINIMUM-SCORE-CUTOFF*)
     (CL:< MAXPOSSIBLESCORE (%DYNAMIC-CUTOFF SELF)))
    (CL:WHEN (TRACE-KEYWORD? KWD-PARTIAL-MATCH-GOAL-TREE)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "  **** Cutting off search, cutoff: " (%DYNAMIC-CUTOFF SELF)
      " Max possible score: " MAXPOSSIBLESCORE EOL))
    (CL:RETURN-FROM EARLY-PARTIAL-MATCH-AND-FAILURE? TRUE))
   FALSE))

;;; (DEFMETHOD (EARLY-PARTIAL-MATCH-OR-SUCCESS? BOOLEAN) ...)

(CL:DEFMETHOD EARLY-PARTIAL-MATCH-OR-SUCCESS? ((SELF INCREMENTAL-PARTIAL-MATCH))
  FALSE)

;;; (DEFCLASS NN-PARTIAL-MATCH ...)

(CL:DEFCLASS NN-PARTIAL-MATCH (PARTIAL-MATCH-FRAME)
  ((TOTAL-WEIGHT :ALLOCATION :INSTANCE :ACCESSOR %TOTAL-WEIGHT)
   (ACCUMULATED-SCORE :ALLOCATION :INSTANCE :ACCESSOR %ACCUMULATED-SCORE)
   (ACCUMULATED-WEIGHT :ALLOCATION :INSTANCE :ACCESSOR
    %ACCUMULATED-WEIGHT)
   (MAXIMUM-SCORE :ALLOCATION :INSTANCE :ACCESSOR %MAXIMUM-SCORE)
   (RULES :ALLOCATION :INSTANCE :ACCESSOR %RULES)))

(CL:DEFUN NEW-NN-PARTIAL-MATCH ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE NN-PARTIAL-MATCH)))
   (CL:SETF (%FRAME-PTR SELF) NULL) (CL:SETF (%UNBOUND-VARS SELF) NIL)
   (CL:SETF (%DYNAMIC-CUTOFF SELF) NULL-FLOAT)
   (CL:SETF (%ARITY SELF) NULL-INTEGER) (CL:SETF (%PROPOSITION SELF) NIL)
   (CL:SETF (%CHILD SELF) NULL) (CL:SETF (%PARENT SELF) NULL)
   (CL:SETF (%SUCCESS? SELF) FALSE)
   (CL:SETF (%NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%POSITIVE-SCORE SELF) NULL-FLOAT) (CL:SETF (%KIND SELF) NULL)
   (CL:SETF (%RULES SELF) NULL) (CL:SETF (%MAXIMUM-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%ARGUMENT-WEIGHTS SELF) NULL)
   (CL:SETF (%ARGUMENT-SCORES SELF) NULL)
   (CL:SETF (%ACCUMULATED-WEIGHT SELF) NULL-FLOAT)
   (CL:SETF (%ACCUMULATED-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%TOTAL-WEIGHT SELF) NULL-FLOAT) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF NN-PARTIAL-MATCH))
  SGT-PARTIAL-MATCH-LOGIC-NN-PARTIAL-MATCH)

(CL:DEFUN ACCESS-NN-PARTIAL-MATCH-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-TOTAL-WEIGHT)
    (CL:IF SETVALUE? (CL:SETF (%TOTAL-WEIGHT SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%TOTAL-WEIGHT SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%ACCUMULATED-SCORE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%ACCUMULATED-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-WEIGHT)
    (CL:IF SETVALUE?
     (CL:SETF (%ACCUMULATED-WEIGHT SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%ACCUMULATED-WEIGHT SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-SCORES)
    (CL:IF SETVALUE? (CL:SETF (%ARGUMENT-SCORES SELF) VALUE)
     (CL:SETQ VALUE (%ARGUMENT-SCORES SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-WEIGHTS)
    (CL:IF SETVALUE? (CL:SETF (%ARGUMENT-WEIGHTS SELF) VALUE)
     (CL:SETQ VALUE (%ARGUMENT-WEIGHTS SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-MAXIMUM-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%MAXIMUM-SCORE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%MAXIMUM-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-RULES)
    (CL:IF SETVALUE? (CL:SETF (%RULES SELF) VALUE)
     (CL:SETQ VALUE (%RULES SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME PARTIAL-MATCH-FRAME) ...)

(CL:DEFMETHOD CREATE-PARTIAL-MATCH-FRAME ((SELF NN-PARTIAL-MATCH) FRAME KIND)
  (CL:LET* ((PMF (NEW-NN-PARTIAL-MATCH)) (PROP (%PROPOSITION FRAME)))
   (CL:SETF (%FRAME-PTR PMF) FRAME)
   (CL:LET* ((TEMP-FRAME (%UP FRAME)))
    (CL:LOOP WHILE (CL:EQ (%PARTIAL-MATCH-FRAME TEMP-FRAME) NULL) DO
     (CL:SETQ TEMP-FRAME (%UP TEMP-FRAME)))
    (CL:SETF (%PARENT PMF) (%PARTIAL-MATCH-FRAME TEMP-FRAME))
    (CL:SETF (%CHILD (%PARTIAL-MATCH-FRAME TEMP-FRAME)) PMF))
   (CL:SETF (%MAXIMUM-SCORE PMF) 0.0d0)
   (CL:SETF (%ARITY PMF) (LENGTH (%ARGUMENTS PROP)))
   (CL:SETF (%ARGUMENT-SCORES PMF) NIL)
   (CL:SETF (%ARGUMENT-WEIGHTS PMF) NIL)
   (CL:SETF (%ACCUMULATED-SCORE PMF) 0.0d0)
   (CL:SETF (%ACCUMULATED-WEIGHT PMF) 0.0d0)
   (CL:SETF (%POSITIVE-SCORE PMF) 0.0d0) (CL:SETF (%UNBOUND-VARS PMF) NIL)
   (CL:SETF (%RULES PMF) NIL) (CL:SETF (%DYNAMIC-CUTOFF PMF) 0.0d0)
   (CL:COND
    ((CL:OR (CL:EQ KIND KWD-PARTIAL-MATCH-AND)
      (CL:EQ KIND KWD-PARTIAL-MATCH-OR))
     (CL:WHEN
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
        SYM-PARTIAL-MATCH-LOGIC-NEURAL-NETWORK NULL)
       NULL)
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
       SYM-PARTIAL-MATCH-LOGIC-NEURAL-NETWORK (CREATE-NEURAL-NETWORK PROP)
       NULL))
     (CL:SETF (%ACCUMULATED-WEIGHT PMF) 0.0d0))
    (CL:T))
   (SET-DYNAMIC-CUTOFF PMF (PROPOSITION-WEIGHT PROP)) PMF))

;;; (DEFMETHOD SET-DYNAMIC-CUTOFF ...)

(CL:DEFMETHOD SET-DYNAMIC-CUTOFF ((SELF NN-PARTIAL-MATCH) WEIGHT)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT WEIGHT))
  (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-ATOMIC-GOAL)
     (CL:SETF (%DYNAMIC-CUTOFF SELF) (%DYNAMIC-CUTOFF (%PARENT SELF))))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-AND)
      (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-OR))
     (CL:LET*
      ((PARENT (%PARENT SELF))
       (NET
        (DYNAMIC-SLOT-VALUE
         (%DYNAMIC-SLOTS (%PROPOSITION (%FRAME-PTR SELF)))
         SYM-PARTIAL-MATCH-LOGIC-NEURAL-NETWORK NULL))
       (ACTIVE -1.0d0))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT ACTIVE))
      (CL:WHEN (CL:> (%DYNAMIC-CUTOFF PARENT) 0.1d0)
       (CL:LET*
        ((INPUT NULL) (VECTOR-000 (%INPUT NET)) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:PROGN
          (CL:SETQ INPUT
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
         (CL:SETQ ACTIVE (CL:+ ACTIVE (%WRAPPER-VALUE INPUT)))))
       (CL:SETF (%DYNAMIC-CUTOFF SELF) ACTIVE))))
    (CL:T))))

;;; (DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ...)

(CL:DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ((SELF NN-PARTIAL-MATCH) PROP TRUTH)
  (CL:COND
   ((CL:EQ TRUTH KWD-PARTIAL-MATCH-TRUE)
    (CL:IF (CL:NOT (CL:EQ PROP NULL))
     (CL:PROGN
      (CL:IF (CL:NOT (CL:= (%WEIGHT PROP) NULL-FLOAT))
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
        SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE (WRAP-FLOAT (%WEIGHT PROP))
        NULL-FLOAT-WRAPPER)
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
        SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE (WRAP-FLOAT 1.0d0)
        NULL-FLOAT-WRAPPER))
      (CL:SETF (%LATEST-POSITIVE-SCORE *QUERYITERATOR*)
       (%WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
         SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER))))
     (CL:SETF (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) 1.0d0)))
   ((CL:EQ TRUTH KWD-PARTIAL-MATCH-FAIL)
    (CL:WHEN (CL:NOT (CL:EQ PROP NULL))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
      SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE (WRAP-FLOAT 0.0d0)
      NULL-FLOAT-WRAPPER))
    (CL:SETF (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) 0.0d0))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TRUTH
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ...)

(CL:DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ((SELF NN-PARTIAL-MATCH) SCORE WEIGHT)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE WEIGHT))
  (CL:WHEN (CL:= WEIGHT NULL-FLOAT) (CL:SETQ WEIGHT 1.0d0))
  (CL:SETF (%ARGUMENT-SCORES SELF)
   (CONS (WRAP-FLOAT SCORE) (%ARGUMENT-SCORES SELF)))
  (CL:SETF (%ARGUMENT-WEIGHTS SELF)
   (CONS (WRAP-FLOAT WEIGHT) (%ARGUMENT-WEIGHTS SELF)))
  (CL:SETF (%ACCUMULATED-SCORE SELF)
   (CL:+ (%ACCUMULATED-SCORE SELF) (CL:* SCORE WEIGHT)))
  (CL:SETF (%ACCUMULATED-WEIGHT SELF)
   (CL:+ (%ACCUMULATED-WEIGHT SELF) WEIGHT))
  (CL:WHEN (CL:> SCORE (%MAXIMUM-SCORE SELF))
   (CL:SETF (%MAXIMUM-SCORE SELF) SCORE))
  (CL:LET* ((FRAME (%FRAME-PTR SELF)))
   (CL:WHEN
    (CL:AND (CL:EQ (%KIND SELF) KWD-PARTIAL-MATCH-ATOMIC-GOAL)
     (CL:EQ (%CURRENT-STRATEGY FRAME) KWD-PARTIAL-MATCH-FULL-SUBQUERY))
    (CL:LET*
     ((R
       (%VALUE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
         SYM-PARTIAL-MATCH-STELLA-ITERATOR NULL)))
      (ANTE
       (%PROPOSITION
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS R)))
         0))))
     (CL:SETF (%RULES SELF) (CONS R (%RULES SELF)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ANTE)
      SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE (WRAP-FLOAT SCORE)
      NULL-FLOAT-WRAPPER)))))

;;; (DEFMETHOD POP-PARTIAL-MATCH-SCORE ...)

(CL:DEFMETHOD POP-PARTIAL-MATCH-SCORE ((SELF NN-PARTIAL-MATCH))
  (CL:SETF (%ACCUMULATED-SCORE SELF)
   (CL:- (%ACCUMULATED-SCORE SELF)
    (CL:* (%WRAPPER-VALUE (%%VALUE (%ARGUMENT-SCORES SELF)))
     (%WRAPPER-VALUE (%%VALUE (%ARGUMENT-WEIGHTS SELF))))))
  (CL:SETF (%ACCUMULATED-WEIGHT SELF)
   (CL:- (%ACCUMULATED-WEIGHT SELF)
    (%WRAPPER-VALUE (%%VALUE (%ARGUMENT-WEIGHTS SELF)))))
  (CL:SETF (%ARGUMENT-SCORES SELF) (%%REST (%ARGUMENT-SCORES SELF)))
  (CL:SETF (%ARGUMENT-WEIGHTS SELF) (%%REST (%ARGUMENT-WEIGHTS SELF))))

;;; (DEFMETHOD (COMPUTE-AND-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-AND-SCORE ((SELF NN-PARTIAL-MATCH))
  (CL:LET*
   ((NET
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%PROPOSITION (%FRAME-PTR SELF)))
      SYM-PARTIAL-MATCH-LOGIC-NEURAL-NETWORK NULL)))
   (CL:LET*
    ((ARG NULL) (SCORE NULL)
     (ITER-000 (REVERSE (COPY-CONS-LIST (%ARGUMENT-SCORES SELF))))
     (VECTOR-000 (%ARGUMENTS (%PROPOSITION (%FRAME-PTR SELF))))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:< INDEX-000 LENGTH-000)) DO
     (CL:PROGN (CL:SETQ SCORE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ARG)
      SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE
      (WRAP-FLOAT (%WRAPPER-VALUE SCORE)) NULL-FLOAT-WRAPPER)))
   (CL:WHEN (CL:NOT (CL:EQ NET NULL))
    (CL:RETURN-FROM COMPUTE-AND-SCORE
     (ACTIVATE-PROPOSITIONAL-NEURAL-NETWORK NET)))
   0.0d0))

;;; (DEFMETHOD (COMPUTE-OR-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-OR-SCORE ((SELF NN-PARTIAL-MATCH))
  (CL:LET*
   ((NET
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%PROPOSITION (%FRAME-PTR SELF)))
      SYM-PARTIAL-MATCH-LOGIC-NEURAL-NETWORK NULL)))
   (CL:LET*
    ((ARG NULL) (SCORE NULL)
     (ITER-000 (REVERSE (COPY-CONS-LIST (%ARGUMENT-SCORES SELF))))
     (VECTOR-000 (%ARGUMENTS (%PROPOSITION (%FRAME-PTR SELF))))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:< INDEX-000 LENGTH-000)) DO
     (CL:PROGN (CL:SETQ SCORE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ARG)
      SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE
      (WRAP-FLOAT (%WRAPPER-VALUE SCORE)) NULL-FLOAT-WRAPPER)))
   (CL:WHEN (CL:NOT (CL:EQ NET NULL))
    (CL:RETURN-FROM COMPUTE-OR-SCORE
     (ACTIVATE-PROPOSITIONAL-NEURAL-NETWORK NET)))
   0.0d0))

;;; (DEFMETHOD (COMPUTE-NOT-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-NOT-SCORE ((SELF NN-PARTIAL-MATCH))
  0.0d0)

;;; (DEFMETHOD (COMPUTE-GOAL-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-GOAL-SCORE ((SELF NN-PARTIAL-MATCH))
  (CL:LET* ((SCORE 0.0d0)) (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE))
   (CL:COND
    ((CL:EQ *RULE-COMBINATION* KWD-PARTIAL-MATCH-MAX)
     (CL:SETQ SCORE (%MAXIMUM-SCORE SELF)))
    ((CL:EQ *RULE-COMBINATION* KWD-PARTIAL-MATCH-NOISY-OR)
     (CL:SETQ SCORE (PROBABILISTIC-SUM-N (%ARGUMENT-SCORES SELF))))
    (CL:T))
   SCORE))

;;; (DEFUN (PROBABILISTIC-SUM-N FLOAT) ...)

(CL:DEFUN PROBABILISTIC-SUM-N (FORM)
  (CL:CASE (LENGTH FORM) (0 0.0d0) (1 (%WRAPPER-VALUE (%%VALUE FORM)))
   (CL:OTHERWISE
    (CL:LET* ((SUM (PROBABILISTIC-SUM-N (%%REST FORM))))
     (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SUM))
     (CL:+ (%WRAPPER-VALUE (%%VALUE FORM)) SUM
      (CL:- 0 (CL:* (%WRAPPER-VALUE (%%VALUE FORM)) SUM)))))))

;;; (DEFUN (PROBABILISTIC-SUM FLOAT) ...)

(CL:DEFUN PROBABILISTIC-SUM (X Y)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT X Y))
  (CL:+ X Y (CL:- 0 (CL:* X Y))))

;;; (DEFMETHOD (EARLY-PARTIAL-MATCH-AND-FAILURE? BOOLEAN) ...)

(CL:DEFMETHOD EARLY-PARTIAL-MATCH-AND-FAILURE? ((SELF NN-PARTIAL-MATCH))
  (PRUNE-NN-SEARCH? SELF))

;;; (DEFMETHOD (EARLY-PARTIAL-MATCH-OR-SUCCESS? BOOLEAN) ...)

(CL:DEFMETHOD EARLY-PARTIAL-MATCH-OR-SUCCESS? ((SELF NN-PARTIAL-MATCH))
  (PRUNE-NN-SEARCH? SELF))

;;; (DEFUN (PRUNE-NN-SEARCH? BOOLEAN) ...)

(CL:DEFUN PRUNE-NN-SEARCH? (SELF)
  (CL:LET*
   ((MAX-POSSIBLE-ACTIVE
     (CL:+ (%ACCUMULATED-SCORE SELF)
      (CL:- (%ARITY SELF) (LENGTH (%ARGUMENT-SCORES SELF))))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT MAX-POSSIBLE-ACTIVE))
   (CL:IF
    (CL:AND *GREEDY-NETWORK-PRUNING*
     (CL:NOT (CL:EQ *RULE-COMBINATION* KWD-PARTIAL-MATCH-NOISY-OR))
     (CL:< MAX-POSSIBLE-ACTIVE (%DYNAMIC-CUTOFF SELF)))
    (CL:PROGN
     (CL:WHEN (TRACE-KEYWORD? KWD-PARTIAL-MATCH-GOAL-TREE)
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "  **** Cutting off search, cutoff: " (%DYNAMIC-CUTOFF SELF)
       "+, Max possible score: " MAX-POSSIBLE-ACTIVE EOL))
     TRUE)
    FALSE)))

;;; (DEFUN (MAKE-PMF PARTIAL-MATCH-FRAME) ...)

(CL:DEFUN MAKE-PMF ()
  (CL:COND
   ((CL:OR (CL:EQ *PARTIAL-MATCH-MODE* KWD-PARTIAL-MATCH-BASIC)
     (CL:EQ *PARTIAL-MATCH-MODE* KWD-PARTIAL-MATCH-INCREMENTAL))
    (NEW-INCREMENTAL-PARTIAL-MATCH))
   ((CL:OR (CL:EQ *PARTIAL-MATCH-MODE* KWD-PARTIAL-MATCH-NN)
     (CL:EQ *PARTIAL-MATCH-MODE* KWD-PARTIAL-MATCH-NEURAL-NETWORK))
    (NEW-NN-PARTIAL-MATCH))
   (CL:T
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Warning -- "
     *PARTIAL-MATCH-MODE*
     " partial match strategy is not implemented.  Using :BASIC")
    (NEW-INCREMENTAL-PARTIAL-MATCH))))

;;; (DEFUN CREATE-AND-LINK-PARTIAL-MATCH-FRAME ...)

(CL:DEFUN CREATE-AND-LINK-PARTIAL-MATCH-FRAME (FRAME KIND)
  (CL:LET*
   ((STRATEGY (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*))
    (PARTIALMATCHFRAME (CREATE-PARTIAL-MATCH-FRAME STRATEGY FRAME KIND)))
   (CL:SETF (%KIND PARTIALMATCHFRAME) KIND)
   (CL:SETF (%PARTIAL-MATCH-FRAME FRAME) PARTIALMATCHFRAME)
   (CL:SETF (%FRAME-PTR PARTIALMATCHFRAME) FRAME)))

;;; (DEFUN (GET-UNBOUND-VARIABLES CONS) ...)

(CL:DEFUN GET-UNBOUND-VARIABLES (PROP)
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROP)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:LET* ((BIND (ARGUMENT-BOUND-TO ARG)))
      (CL:WHEN (CL:EQ BIND NULL) (CL:SETQ RESULT (CONS ARG RESULT))))))
   RESULT))

;;; (DEFUN RECORD-LATEST-PARTIAL-MATCH-SCORE ...)

(CL:DEFUN RECORD-LATEST-PARTIAL-MATCH-SCORE (FRAME)
  (CL:LET*
   ((PROP NULL) (SCORE (%LATEST-POSITIVE-SCORE *QUERYITERATOR*))
    (PFRAME (%PARTIAL-MATCH-FRAME FRAME)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE))
   (CL:LET* ((TEST-VALUE-000 (%STATE FRAME)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-AND)
       (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-OR))
      (CL:SETQ PROP
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%THE-ARRAY (%ARGUMENTS (%PROPOSITION FRAME))))
        (CL:THE CL:FIXNUM (%ARGUMENT-CURSOR FRAME)))))
     (CL:T (CL:SETQ PROP (%PROPOSITION FRAME)))))
   (CL:WHEN
    (CL:AND (CL:EQ (%KIND PFRAME) KWD-PARTIAL-MATCH-AND)
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? PROP))
     (CL:EQ (%SUCCESS? PFRAME) FALSE))
    (CL:SETQ *AND-MISSED-A-BINDING* TRUE))
   (CL:WHEN
    (CL:AND (CL:EQ (%KIND PFRAME) KWD-PARTIAL-MATCH-AND)
     (CL:= SCORE 0.0d0) (CL:EQ (%KIND PROP) KWD-PARTIAL-MATCH-FUNCTION)
     (CL:AND
      (ISA? (LAST (%ARGUMENTS PROP))
       SGT-PARTIAL-MATCH-LOGIC-PATTERN-VARIABLE)
      (CL:EQ (ARGUMENT-BOUND-TO (LAST (%ARGUMENTS PROP))) NULL)))
    (CL:SETF (%UNBOUND-VARS PFRAME)
     (CONS (LAST (%ARGUMENTS PROP)) (%UNBOUND-VARS PFRAME))))
   (RECORD-PARTIAL-MATCH-SCORE PFRAME
    (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) (PROPOSITION-WEIGHT PROP))))

;;; (DEFUN (ALL-VARIABLES-UNBOUND? BOOLEAN) ...)

(CL:DEFUN ALL-VARIABLES-UNBOUND? (PROP)
  (CL:LET* ((FOUND?-000 FALSE))
   (CL:LET*
    ((VAR NULL) (VECTOR-000 (%ARGUMENTS PROP)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ VAR
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:WHEN (CL:NOT (CL:EQ (ARGUMENT-BOUND-TO VAR) NULL))
      (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
   (CL:IF FOUND?-000 FALSE TRUE)))

;;; (DEFUN (COMPUTE-PARTIAL-MATCH-AND-FAILURE? BOOLEAN) ...)

(CL:DEFUN COMPUTE-PARTIAL-MATCH-AND-FAILURE? (FRAME)
  (EARLY-PARTIAL-MATCH-AND-FAILURE? (%PARTIAL-MATCH-FRAME FRAME)))

;;; (DEFUN (COMPUTE-PARTIAL-MATCH-OR-SUCCESS? BOOLEAN) ...)

(CL:DEFUN COMPUTE-PARTIAL-MATCH-OR-SUCCESS? (FRAME)
  (EARLY-PARTIAL-MATCH-OR-SUCCESS? (%PARTIAL-MATCH-FRAME FRAME)))

;;; (DEFUN (COMPUTE-PARTIAL-MATCH-SCORE? BOOLEAN) ...)

(CL:DEFUN COMPUTE-PARTIAL-MATCH-SCORE? (FRAME)
  (CL:LET*
   ((PARTIALMATCHFRAME (%PARTIAL-MATCH-FRAME FRAME)) (SCORE NULL-FLOAT))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE))
   (CL:LET* ((TEST-VALUE-000 (%KIND PARTIALMATCHFRAME)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-AND)
      (CL:SETQ SCORE (COMPUTE-AND-SCORE PARTIALMATCHFRAME)))
     ((CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-OR)
      (CL:SETQ SCORE (COMPUTE-OR-SCORE PARTIALMATCHFRAME)))
     ((CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-ATOMIC-GOAL)
      (CL:SETQ SCORE (COMPUTE-GOAL-SCORE PARTIALMATCHFRAME)))
     (CL:T)))
   (CL:SETF (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) SCORE)
   (CL:SETF (%POSITIVE-SCORE PARTIALMATCHFRAME) SCORE)
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%PROPOSITION FRAME))
    SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE (WRAP-FLOAT SCORE)
    NULL-FLOAT-WRAPPER)
   (CL:WHEN (UNBOUND-VARIABLES-IN-FRAME? FRAME)
    (CL:RETURN-FROM COMPUTE-PARTIAL-MATCH-SCORE? FALSE))
   (CL:IF (CL:<= SCORE *MINIMUM-SCORE-CUTOFF*) FALSE TRUE)))

;;; (DEFUN (RETRIEVE-PARTIAL QUERY-ITERATOR) ...)

(CL:DEFUN %RETRIEVE-PARTIAL (TREE)
  (RETURN-PARTIAL-QUERY TREE))

(CL:DEFUN RETRIEVE-PARTIAL-EVALUATOR-WRAPPER (ARGUMENTS)
  (%RETRIEVE-PARTIAL ARGUMENTS))

(CL:DEFMACRO RETRIEVE-PARTIAL (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/RETRIEVE-PARTIAL)) (CL:MACRO-FUNCTION (CL:QUOTE RETRIEVE-PARTIAL)))

;;; (DEFUN (RETURN-PARTIAL-QUERY QUERY-ITERATOR) ...)

(CL:DEFUN RETURN-PARTIAL-QUERY (TREE)
  (CL:LET* ((QUERY NIL) (NOFBINDINGS 1) (PARTIAL-MATCH-FRAME (MAKE-PMF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFBINDINGS))
   (CL:SETF (%DYNAMIC-CUTOFF PARTIAL-MATCH-FRAME) 0.0d0)
   (CL:LET* ((ARG NULL) (ITER-000 TREE))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
      (CL:COND
       ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
        (CL:PROGN (CL:SETQ NOFBINDINGS (%WRAPPER-VALUE ARG))))
       ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
        (CL:PROGN
         (CL:SETF (%DYNAMIC-CUTOFF PARTIAL-MATCH-FRAME)
          (%WRAPPER-VALUE ARG))))
       ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
        (CL:PROGN
         (CL:WHEN (STRING-EQL? (%SYMBOL-NAME ARG) "ALL")
          (CL:SETQ NOFBINDINGS NULL-INTEGER))
         (CL:WHEN (STRING-EQL? (%SYMBOL-NAME ARG) "BEST")
          (CL:RETURN-FROM RETURN-PARTIAL-QUERY
           (RETRIEVE-PARTIAL-BEST TREE)))))
       ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
        (CL:PROGN
         (CL:WHEN (STRING-EQL? (%SYMBOL-NAME ARG) "ALL")
          (CL:SETQ NOFBINDINGS NULL-INTEGER))
         (CL:WHEN (STRING-EQL? (%SYMBOL-NAME ARG) "BEST")
          (CL:RETURN-FROM RETURN-PARTIAL-QUERY
           (RETRIEVE-PARTIAL-BEST TREE)))))
       (CL:T)))))
   (CL:LET* ((ARG NULL) (ITER-001 TREE) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:WHEN (CONS? ARG)
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG NIL))
        (CL:IF (CL:EQ QUERY NIL) (CL:SETQ QUERY COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST QUERY COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:HANDLER-CASE
    (CL:IF
     (CL:AND (CL:EQ QUERY NIL) (CL:NOT (CL:EQ *MOST-RECENT-QUERY* NULL)))
     (CL:RETURN-FROM RETURN-PARTIAL-QUERY
      (RETRIEVE-BINDINGS *MOST-RECENT-QUERY* NOFBINDINGS))
     (CL:PROGN (FINALIZE-RELATIONS)
      (CL:WHEN (CL:AND (CL:= (LENGTH QUERY) 1) (STRING? (%%VALUE QUERY)))
       (CL:SETQ QUERY (COERCE-TO-TREE (%%VALUE QUERY))))
      (CL:LET*
       ((NEW-QUERY
         (MAKE-QUERY (%%VALUE QUERY) (%%VALUE (%%REST QUERY)) NIL NIL)))
       (CL:SETF (%PARTIAL-MATCH-STRATEGY NEW-QUERY) PARTIAL-MATCH-FRAME)
       (CL:SETF (%LATEST-POSITIVE-SCORE NEW-QUERY) 0.0d0)
       (CL:RETURN-FROM RETURN-PARTIAL-QUERY
        (CL:SETQ *MOST-RECENT-QUERY*
         (RETRIEVE-BINDINGS NEW-QUERY NOFBINDINGS))))))
    (LOGIC-EXCEPTION (E)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
      (EXCEPTION-MESSAGE E))
     (CL:SETQ *MOST-RECENT-QUERY* NULL)))))

;;; (DEFUN (RETRIEVE-PARTIAL-BEST QUERY-ITERATOR) ...)

(CL:DEFUN RETRIEVE-PARTIAL-BEST (TREE)
  (CL:LET* ((ARGLIST-000 NIL))
   (CL:LET* ((ARG-000 NULL) (ITER-000 TREE) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ ARG-000 (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG-000 NIL))
       (CL:IF (CL:EQ ARGLIST-000 NIL) (CL:SETQ ARGLIST-000 COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST ARGLIST-000 COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG-000 NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:LET* ((THEQUERY (REMOVE ARGLIST-000 SYM-PARTIAL-MATCH-LOGIC-BEST)))
    (%EVALUATE
     (CONS SYM-PARTIAL-MATCH-LOGIC-RETRIEVE-PARTIAL
      (CONS SYM-PARTIAL-MATCH-LOGIC-ALL THEQUERY)))))
  (CL:LET* ((SOLUTIONS (NEW-LIST)) (QUERY-IT *MOST-RECENT-QUERY*))
   (CL:LET*
    ((SCORE NULL) (BINDING NULL)
     (ITER-001 (%THE-CONS-LIST (%SOLUTIONS QUERY-IT)))
     (ITER-002 (%THE-CONS-LIST (%MATCH-SCORES QUERY-IT)))
     (COLLECT-001 NULL))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL)))
     DO
     (CL:PROGN (CL:SETQ BINDING (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:PROGN (CL:SETQ SCORE (%%VALUE ITER-002))
      (CL:SETQ ITER-002 (%%REST ITER-002)))
     (CL:IF (CL:EQ COLLECT-001 NULL)
      (CL:PROGN (CL:SETQ COLLECT-001 (CONS (CONS-LIST SCORE BINDING) NIL))
       (CL:IF (CL:EQ (%THE-CONS-LIST SOLUTIONS) NIL)
        (CL:SETF (%THE-CONS-LIST SOLUTIONS) COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST SOLUTIONS)
         COLLECT-001)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-001) (CONS (CONS-LIST SCORE BINDING) NIL))
       (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))))
   (SORT SOLUTIONS (CL:FUNCTION COMPARE-SOLUTION-MATCH>))
   (CL:SETF (%SOLUTIONS QUERY-IT) (NEW-LIST))
   (CL:LET*
    ((BINDING NULL) (ITER-003 (%THE-CONS-LIST SOLUTIONS))
     (INTO-000 (%SOLUTIONS QUERY-IT)) (COLLECT-002 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
     (CL:PROGN (CL:SETQ BINDING (%%VALUE ITER-003))
      (CL:SETQ ITER-003 (%%REST ITER-003)))
     (CL:IF (CL:EQ COLLECT-002 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-002 (CONS (%%VALUE (%%REST BINDING)) NIL))
       (CL:IF (CL:EQ (%THE-CONS-LIST INTO-000) NIL)
        (CL:SETF (%THE-CONS-LIST INTO-000) COLLECT-002)
        (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST INTO-000)
         COLLECT-002)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-002)
        (CONS (%%VALUE (%%REST BINDING)) NIL))
       (CL:SETQ COLLECT-002 (%%REST COLLECT-002))))))
   (REVERSE (SORT (%MATCH-SCORES QUERY-IT) NULL)) QUERY-IT))

;;; (DEFUN (COMPARE-SOLUTION-MATCH> BOOLEAN) ...)

(CL:DEFUN COMPARE-SOLUTION-MATCH> (S1 S2)
  (> (%WRAPPER-VALUE (%%VALUE S1)) (%WRAPPER-VALUE (%%VALUE S2))))

;;; (DEFUN (ASK-PARTIAL FLOAT) ...)

(CL:DEFUN %ASK-PARTIAL (PROPOSITION)
  (CL:SETQ *MOST-RECENT-QUERY* NULL)
  (RETURN-PARTIAL-TRUTH
   (MAKE-QUERY NIL (COERCE-TO-TREE PROPOSITION) NIL NIL) TRUE))

(CL:DEFUN ASK-PARTIAL-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET* ((RESULT (%ASK-PARTIAL (%%VALUE ARGUMENTS))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CL:IF (CL:NOT (CL:= RESULT NULL-FLOAT)) (WRAP-FLOAT RESULT) NULL)))

(CL:DEFMACRO ASK-PARTIAL (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/ASK-PARTIAL)) (CL:MACRO-FUNCTION (CL:QUOTE ASK-PARTIAL)))

;;; (DEFUN (ASK-FIRST-PARTIAL FLOAT) ...)

(CL:DEFUN %ASK-FIRST-PARTIAL (PROPOSITION)
  (CL:SETQ *MOST-RECENT-QUERY* NULL)
  (RETURN-PARTIAL-TRUTH
   (MAKE-QUERY NIL (COERCE-TO-TREE PROPOSITION) NIL NIL) FALSE))

(CL:DEFUN ASK-FIRST-PARTIAL-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET* ((RESULT (%ASK-FIRST-PARTIAL (%%VALUE ARGUMENTS))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CL:IF (CL:NOT (CL:= RESULT NULL-FLOAT)) (WRAP-FLOAT RESULT) NULL)))

(CL:DEFMACRO ASK-FIRST-PARTIAL (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/ASK-FIRST-PARTIAL)) (CL:MACRO-FUNCTION (CL:QUOTE ASK-FIRST-PARTIAL)))

;;; (DEFUN (RETURN-PARTIAL-TRUTH FLOAT) ...)

(CL:DEFUN RETURN-PARTIAL-TRUTH (QUERY TOP?)
  (CL:LET*
   ((SCORE 0.0d0) (PARTIAL-MATCH-FRAME (MAKE-PMF)) (NET-LIST (NEW-LIST))
    (ACTIVATION-LIST (NEW-LIST)) (SCORE-LIST (NEW-LIST)) (SUPPORT NULL)
    (I 0) (HIGH-SCORE 0.0d0) (BESTJUSTIFICATION NULL))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE HIGH-SCORE)
    (CL:TYPE CL:FIXNUM I))
   (CL:SETF (%PARTIAL-MATCH-STRATEGY QUERY) PARTIAL-MATCH-FRAME)
   (CL:WHEN (CL:EQ *PARTIAL-MATCH-MODE* KWD-PARTIAL-MATCH-NN)
    (CL:SETQ *ACTIVATED-NETWORKS* (NEW-LIST)))
   (CL:WHEN (CL:EQ *MOST-RECENT-QUERY* NULL)
    (CL:SETQ *MOST-RECENT-QUERY* QUERY))
   (CL:LOOP (CL:SETQ I (CL:1+ I))
    (CL:SETF (%DYNAMIC-CUTOFF PARTIAL-MATCH-FRAME) (CL:+ SCORE 0.001d0))
    (CL:SETF (%LATEST-POSITIVE-SCORE QUERY) 0.0d0)
    (CL:LET* ((*QUERYITERATOR* QUERY))
     (CL:DECLARE (CL:SPECIAL *QUERYITERATOR*)) (NEXT? QUERY)
     (CL:LET* ((LATEST (%LATEST-POSITIVE-SCORE QUERY)))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT LATEST))
      (CL:WHEN (CL:> LATEST (CL:+ SCORE 0.001d0))
       (CL:SETQ BESTJUSTIFICATION
        (%JUSTIFICATION (%BASE-CONTROL-FRAME QUERY))))
      (CL:WHEN
       (CL:OR (CL:= LATEST 0.0d0)
        (CL:AND (CL:< LATEST (CL:+ SCORE 0.001d0))
         (CL:EQ *PARTIAL-MATCH-MODE* KWD-PARTIAL-MATCH-BASIC))
        (MEMBER? SCORE-LIST (WRAP-FLOAT (%LATEST-POSITIVE-SCORE QUERY))))
       (CL:RETURN))
      (CL:WHEN
       (CL:AND (CL:EQ *PARTIAL-MATCH-MODE* KWD-PARTIAL-MATCH-NN)
        (CL:> LATEST HIGH-SCORE))
       (CL:SETQ SUPPORT
        (SUPPORT (%PROPOSITION (%BASE-CONTROL-FRAME QUERY))))
       (CL:SETQ ACTIVATION-LIST (NEW-LIST))
       (CL:SETQ NET-LIST *ACTIVATED-NETWORKS*)
       (CL:LET*
        ((NET NULL) (ITER-000 (%THE-CONS-LIST *ACTIVATED-NETWORKS*)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:PROGN (CL:SETQ NET (%%VALUE ITER-000))
          (CL:SETQ ITER-000 (%%REST ITER-000)))
         (CL:LET* ((PROP-SCORES (NEW-LIST)))
          (CL:LET*
           ((PROP NULL) (VECTOR-000 (%ARGUMENTS (%PROPOSITION NET)))
            (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
            (COLLECT-000 NULL))
           (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
           (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
            (CL:PROGN
             (CL:SETQ PROP
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
               INDEX-000))
             (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
            (CL:IF (CL:EQ COLLECT-000 NULL)
             (CL:PROGN
              (CL:SETQ COLLECT-000
               (CONS
                (WRAP-FLOAT
                 (%WRAPPER-VALUE
                  (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
                   SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE
                   NULL-FLOAT-WRAPPER)))
                NIL))
              (CL:IF (CL:EQ (%THE-CONS-LIST PROP-SCORES) NIL)
               (CL:SETF (%THE-CONS-LIST PROP-SCORES) COLLECT-000)
               (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST PROP-SCORES)
                COLLECT-000)))
             (CL:PROGN
              (CL:SETF (%%REST COLLECT-000)
               (CONS
                (WRAP-FLOAT
                 (%WRAPPER-VALUE
                  (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
                   SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE
                   NULL-FLOAT-WRAPPER)))
                NIL))
              (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
          (PUSH ACTIVATION-LIST PROP-SCORES)))))
      (CL:SETQ ACTIVATION-LIST (REVERSE ACTIVATION-LIST))
      (CL:LET*
       ((WEIGHT (%WEIGHT (%PROPOSITION (%BASE-CONTROL-FRAME QUERY)))))
       (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT WEIGHT))
       (CL:WHEN (CL:NOT (CL:= WEIGHT NULL-FLOAT))
        (CL:SETQ LATEST (CL:* LATEST WEIGHT))))
      (CL:SETQ SCORE LATEST)
      (CL:WHEN (CL:OR (CL:NOT TOP?) (CL:= SCORE 1.0d0)) (CL:RETURN))
      (PUSH SCORE-LIST (WRAP-FLOAT SCORE)))))
   (CL:WHEN (CL:EQ *PARTIAL-MATCH-MODE* KWD-PARTIAL-MATCH-NN)
    (SET-DYNAMIC-SLOT-VALUE
     (%DYNAMIC-SLOTS (%PROPOSITION (%BASE-CONTROL-FRAME QUERY)))
     SYM-PARTIAL-MATCH-LOGIC-SUPPORT SUPPORT NULL)
    (CL:LET*
     ((SCORE-LIST NULL) (NET NULL)
      (ITER-001 (%THE-CONS-LIST (REVERSE NET-LIST)))
      (ITER-002 (%THE-CONS-LIST (REVERSE ACTIVATION-LIST))))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL)))
      DO
      (CL:PROGN (CL:SETQ NET (%%VALUE ITER-001))
       (CL:SETQ ITER-001 (%%REST ITER-001)))
      (CL:PROGN (CL:SETQ SCORE-LIST (%%VALUE ITER-002))
       (CL:SETQ ITER-002 (%%REST ITER-002)))
      (CL:LET*
       ((K NULL) (PROP NULL) (VECTOR-001 (%ARGUMENTS (%PROPOSITION NET)))
        (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001))
        (ITER-003 (%THE-CONS-LIST SCORE-LIST)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:NOT (CL:EQ ITER-003 NIL)))
        DO
        (CL:PROGN
         (CL:SETQ PROP
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
           INDEX-001))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
        (CL:PROGN (CL:SETQ K (%%VALUE ITER-003))
         (CL:SETQ ITER-003 (%%REST ITER-003)))
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
         SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE
         (WRAP-FLOAT (%WRAPPER-VALUE K)) NULL-FLOAT-WRAPPER))))))
   (CL:WHEN (CL:NOT (CL:EQ BESTJUSTIFICATION NULL))
    (CL:SETF (%JUSTIFICATION (%BASE-CONTROL-FRAME QUERY))
     BESTJUSTIFICATION))
   SCORE))

;;; (DEFGLOBAL *STATUS-CHARS* ...)

(CL:PROGN (CL:DEFVAR *STATUS-CHARS* 0) (CL:DECLAIM (CL:TYPE CL:FIXNUM *STATUS-CHARS*)))

;;; (DEFUN PRINT-STATUS-CHAR ...)

(CL:DEFUN PRINT-STATUS-CHAR (STATUS)
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) STATUS)
  (CL:SETQ *STATUS-CHARS* (CL:1+ *STATUS-CHARS*))
  (CL:WHEN (CL:= 0 (CL:THE CL:FIXNUM (CL:MOD *STATUS-CHARS* 70)))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL)))

(CL:DEFUN HELP-STARTUP-PARTIAL-MATCH1 ()
  (CL:PROGN
   (CL:SETQ KWD-PARTIAL-MATCH-BASIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BASIC" NULL 2))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-SET-PARTIAL-MATCH-MODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-PARTIAL-MATCH-MODE" NULL 0))
   (CL:SETQ KWD-PARTIAL-MATCH-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-MAX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAX" NULL 2))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-KIND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KIND" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-POSITIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITIVE-SCORE" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-NEGATIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEGATIVE-SCORE" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-SUCCESS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUCCESS?" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-PARENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-CHILD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHILD" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-SCORES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-SCORES" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-WEIGHTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-WEIGHTS" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-STELLA-ARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARITY"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-DYNAMIC-CUTOFF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC-CUTOFF" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-UNBOUND-VARS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBOUND-VARS" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-FRAME-PTR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FRAME-PTR" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-SET-RULE-COMBINATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-RULE-COMBINATION" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-SET-GREEDY-NETWORK-PRUNING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-GREEDY-NETWORK-PRUNING" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-SET-MAXIMUM-SCORE-CUTOFF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-MAXIMUM-SCORE-CUTOFF" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-SET-MINIMUM-SCORE-CUTOFF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-MINIMUM-SCORE-CUTOFF" NULL 0))
   (CL:SETQ KWD-PARTIAL-MATCH-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ SGT-PARTIAL-MATCH-LOGIC-INCREMENTAL-PARTIAL-MATCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INCREMENTAL-PARTIAL-MATCH" NULL 1))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-TOTAL-WEIGHT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOTAL-WEIGHT" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACCUMULATED-SCORE" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-WEIGHT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACCUMULATED-WEIGHT" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-MAXIMUM-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAXIMUM-SCORE" NULL 0))
   (CL:SETQ KWD-PARTIAL-MATCH-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-ITERATIVE-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATIVE-FORALL" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-ATOMIC-GOAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ATOMIC-GOAL" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-NOISY-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOISY-OR" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-GOAL-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-TREE" NULL 2))
   (CL:SETQ SGT-PARTIAL-MATCH-LOGIC-NN-PARTIAL-MATCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NN-PARTIAL-MATCH" NULL 1))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RULES" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-NEURAL-NETWORK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEURAL-NETWORK" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MATCH-SCORE" NULL 0))
   (CL:SETQ KWD-PARTIAL-MATCH-FULL-SUBQUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULL-SUBQUERY" NULL 2))
   (CL:SETQ SYM-PARTIAL-MATCH-STELLA-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ KWD-PARTIAL-MATCH-INCREMENTAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INCREMENTAL" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-NN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NN" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-NEURAL-NETWORK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEURAL-NETWORK" NULL 2))
   (CL:SETQ SGT-PARTIAL-MATCH-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-RETRIEVE-PARTIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRIEVE-PARTIAL" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-BEST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BEST" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-ALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-ASK-PARTIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASK-PARTIAL" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-ASK-FIRST-PARTIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASK-FIRST-PARTIAL" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-SUPPORT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPPORT" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-STARTUP-PARTIAL-MATCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-PARTIAL-MATCH" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))))

(CL:DEFUN HELP-STARTUP-PARTIAL-MATCH2 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "SET-PARTIAL-MATCH-MODE"
    "(DEFUN SET-PARTIAL-MATCH-MODE ((K KEYWORD)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-PARTIAL-MATCH-MODE) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-RULE-COMBINATION"
    "(DEFUN SET-RULE-COMBINATION ((K KEYWORD)) :COMMAND? TRUE)"
    (CL:FUNCTION %SET-RULE-COMBINATION) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-GREEDY-NETWORK-PRUNING"
    "(DEFUN SET-GREEDY-NETWORK-PRUNING ((B BOOLEAN)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-GREEDY-NETWORK-PRUNING)
    (CL:FUNCTION SET-GREEDY-NETWORK-PRUNING-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-MAXIMUM-SCORE-CUTOFF"
    "(DEFUN SET-MAXIMUM-SCORE-CUTOFF ((C FLOAT)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-MAXIMUM-SCORE-CUTOFF)
    (CL:FUNCTION SET-MAXIMUM-SCORE-CUTOFF-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-MINIMUM-SCORE-CUTOFF"
    "(DEFUN SET-MINIMUM-SCORE-CUTOFF ((C FLOAT)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-MINIMUM-SCORE-CUTOFF)
    (CL:FUNCTION SET-MINIMUM-SCORE-CUTOFF-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "PROPOSITION-WEIGHT"
    "(DEFUN (PROPOSITION-WEIGHT FLOAT) ((PROP PROPOSITION)))"
    (CL:FUNCTION PROPOSITION-WEIGHT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME PARTIAL-MATCH-FRAME) ((SELF PARTIAL-MATCH-FRAME) (FRAME CONTROL-FRAME) (KIND KEYWORD)))"
    (CL:FUNCTION CREATE-PARTIAL-MATCH-FRAME) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-DYNAMIC-CUTOFF ((SELF PARTIAL-MATCH-FRAME) (MY-WEIGHT FLOAT)))"
    (CL:FUNCTION SET-DYNAMIC-CUTOFF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ((SELF PARTIAL-MATCH-FRAME) (PROP PROPOSITION) (TRUTH KEYWORD)))"
    (CL:FUNCTION SET-BASE-PARTIAL-MATCH-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ((SELF PARTIAL-MATCH-FRAME) (SCORE PARTIAL-MATCH-SCORE) (WEIGHT FLOAT)))"
    (CL:FUNCTION RECORD-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD POP-PARTIAL-MATCH-SCORE ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION POP-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-AND-SCORE PARTIAL-MATCH-SCORE) ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION COMPUTE-AND-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-OR-SCORE PARTIAL-MATCH-SCORE) ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION COMPUTE-OR-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-NOT-SCORE PARTIAL-MATCH-SCORE) ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION COMPUTE-NOT-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-GOAL-SCORE PARTIAL-MATCH-SCORE) ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION COMPUTE-GOAL-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EARLY-PARTIAL-MATCH-AND-FAILURE? BOOLEAN) ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION EARLY-PARTIAL-MATCH-AND-FAILURE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EARLY-PARTIAL-MATCH-OR-SUCCESS? BOOLEAN) ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION EARLY-PARTIAL-MATCH-OR-SUCCESS?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME PARTIAL-MATCH-FRAME) ((SELF INCREMENTAL-PARTIAL-MATCH) (FRAME CONTROL-FRAME) (KIND KEYWORD)))"
    (CL:FUNCTION CREATE-PARTIAL-MATCH-FRAME) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-DYNAMIC-CUTOFF ((SELF INCREMENTAL-PARTIAL-MATCH) (MY-WEIGHT FLOAT)))"
    (CL:FUNCTION SET-DYNAMIC-CUTOFF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ((SELF INCREMENTAL-PARTIAL-MATCH) (PROP PROPOSITION) (TRUTH KEYWORD)))"
    (CL:FUNCTION SET-BASE-PARTIAL-MATCH-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH) (SCORE PARTIAL-MATCH-SCORE) (WEIGHT FLOAT)))"
    (CL:FUNCTION RECORD-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD POP-PARTIAL-MATCH-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION POP-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-AND-SCORE PARTIAL-MATCH-SCORE) ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-AND-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-OR-SCORE PARTIAL-MATCH-SCORE) ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-OR-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-GOAL-SCORE PARTIAL-MATCH-SCORE) ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-GOAL-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-NOT-SCORE PARTIAL-MATCH-SCORE) ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-NOT-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EARLY-PARTIAL-MATCH-AND-FAILURE? BOOLEAN) ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION EARLY-PARTIAL-MATCH-AND-FAILURE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EARLY-PARTIAL-MATCH-OR-SUCCESS? BOOLEAN) ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION EARLY-PARTIAL-MATCH-OR-SUCCESS?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME PARTIAL-MATCH-FRAME) ((SELF NN-PARTIAL-MATCH) (FRAME CONTROL-FRAME) (KIND KEYWORD)))"
    (CL:FUNCTION CREATE-PARTIAL-MATCH-FRAME) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-DYNAMIC-CUTOFF ((SELF NN-PARTIAL-MATCH) (WEIGHT FLOAT)))"
    (CL:FUNCTION SET-DYNAMIC-CUTOFF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ((SELF NN-PARTIAL-MATCH) (PROP PROPOSITION) (TRUTH KEYWORD)))"
    (CL:FUNCTION SET-BASE-PARTIAL-MATCH-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ((SELF NN-PARTIAL-MATCH) (SCORE PARTIAL-MATCH-SCORE) (WEIGHT FLOAT)))"
    (CL:FUNCTION RECORD-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD POP-PARTIAL-MATCH-SCORE ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION POP-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-AND-SCORE PARTIAL-MATCH-SCORE) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-AND-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-OR-SCORE PARTIAL-MATCH-SCORE) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-OR-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-NOT-SCORE PARTIAL-MATCH-SCORE) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-NOT-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-GOAL-SCORE PARTIAL-MATCH-SCORE) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-GOAL-SCORE) NULL)
   (DEFINE-FUNCTION-OBJECT "PROBABILISTIC-SUM-N"
    "(DEFUN (PROBABILISTIC-SUM-N FLOAT) ((FORM (CONS OF FLOAT-WRAPPER))))"
    (CL:FUNCTION PROBABILISTIC-SUM-N) NULL)
   (DEFINE-FUNCTION-OBJECT "PROBABILISTIC-SUM"
    "(DEFUN (PROBABILISTIC-SUM FLOAT) ((X FLOAT) (Y FLOAT)))"
    (CL:FUNCTION PROBABILISTIC-SUM) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EARLY-PARTIAL-MATCH-AND-FAILURE? BOOLEAN) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION EARLY-PARTIAL-MATCH-AND-FAILURE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EARLY-PARTIAL-MATCH-OR-SUCCESS? BOOLEAN) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION EARLY-PARTIAL-MATCH-OR-SUCCESS?) NULL)
   (DEFINE-FUNCTION-OBJECT "PRUNE-NN-SEARCH?"
    "(DEFUN (PRUNE-NN-SEARCH? BOOLEAN) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION PRUNE-NN-SEARCH?) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-PMF"
    "(DEFUN (MAKE-PMF PARTIAL-MATCH-FRAME) ())" (CL:FUNCTION MAKE-PMF)
    NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-AND-LINK-PARTIAL-MATCH-FRAME"
    "(DEFUN CREATE-AND-LINK-PARTIAL-MATCH-FRAME ((FRAME CONTROL-FRAME) (KIND KEYWORD)))"
    (CL:FUNCTION CREATE-AND-LINK-PARTIAL-MATCH-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-UNBOUND-VARIABLES"
    "(DEFUN (GET-UNBOUND-VARIABLES CONS) ((PROP PROPOSITION)))"
    (CL:FUNCTION GET-UNBOUND-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-LATEST-PARTIAL-MATCH-SCORE"
    "(DEFUN RECORD-LATEST-PARTIAL-MATCH-SCORE ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION RECORD-LATEST-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-VARIABLES-UNBOUND?"
    "(DEFUN (ALL-VARIABLES-UNBOUND? BOOLEAN) ((PROP PROPOSITION)))"
    (CL:FUNCTION ALL-VARIABLES-UNBOUND?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-PARTIAL-MATCH-AND-FAILURE?"
    "(DEFUN (COMPUTE-PARTIAL-MATCH-AND-FAILURE? BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION COMPUTE-PARTIAL-MATCH-AND-FAILURE?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-PARTIAL-MATCH-OR-SUCCESS?"
    "(DEFUN (COMPUTE-PARTIAL-MATCH-OR-SUCCESS? BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION COMPUTE-PARTIAL-MATCH-OR-SUCCESS?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-PARTIAL-MATCH-SCORE?"
    "(DEFUN (COMPUTE-PARTIAL-MATCH-SCORE? BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION COMPUTE-PARTIAL-MATCH-SCORE?) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRIEVE-PARTIAL"
    "(DEFUN (RETRIEVE-PARTIAL QUERY-ITERATOR) (|&REST| (TREE PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %RETRIEVE-PARTIAL)
    (CL:FUNCTION RETRIEVE-PARTIAL-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "RETURN-PARTIAL-QUERY"
    "(DEFUN (RETURN-PARTIAL-QUERY QUERY-ITERATOR) ((TREE CONS)))"
    (CL:FUNCTION RETURN-PARTIAL-QUERY) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRIEVE-PARTIAL-BEST"
    "(DEFUN (RETRIEVE-PARTIAL-BEST QUERY-ITERATOR) ((TREE CONS)))"
    (CL:FUNCTION RETRIEVE-PARTIAL-BEST) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPARE-SOLUTION-MATCH>"
    "(DEFUN (COMPARE-SOLUTION-MATCH> BOOLEAN) ((S1 CONS) (S2 CONS)))"
    (CL:FUNCTION COMPARE-SOLUTION-MATCH>) NULL)
   (DEFINE-FUNCTION-OBJECT "ASK-PARTIAL"
    "(DEFUN (ASK-PARTIAL FLOAT) ((PROPOSITION PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %ASK-PARTIAL)
    (CL:FUNCTION ASK-PARTIAL-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "ASK-FIRST-PARTIAL"
    "(DEFUN (ASK-FIRST-PARTIAL FLOAT) ((PROPOSITION PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %ASK-FIRST-PARTIAL)
    (CL:FUNCTION ASK-FIRST-PARTIAL-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "RETURN-PARTIAL-TRUTH"
    "(DEFUN (RETURN-PARTIAL-TRUTH FLOAT) ((QUERY QUERY-ITERATOR) (TOP? BOOLEAN)))"
    (CL:FUNCTION RETURN-PARTIAL-TRUTH) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-STATUS-CHAR"
    "(DEFUN PRINT-STATUS-CHAR ((STATUS CHARACTER)))"
    (CL:FUNCTION PRINT-STATUS-CHAR) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-PARTIAL-MATCH"
    "(DEFUN STARTUP-PARTIAL-MATCH () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-PARTIAL-MATCH) NULL)
   (CL:LET*
    ((FUNCTION
      (LOOKUP-FUNCTION SYM-PARTIAL-MATCH-LOGIC-STARTUP-PARTIAL-MATCH)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
     SYM-PARTIAL-MATCH-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "Startup-Partial-Match") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-PARTIAL-MATCH ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-PARTIAL-MATCH1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *PARTIAL-MATCH-MODE* KWD-PARTIAL-MATCH-BASIC)
    (CL:SETQ *RULE-COMBINATION* KWD-PARTIAL-MATCH-MAX))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PARTIAL-MATCH-FRAME"
        "(DEFCLASS PARTIAL-MATCH-FRAME (STANDARD-OBJECT) :DOCUMENTATION \"Abstract class acting as placeholder for system and
user-defined partial match implementations.\" :ABSTRACT? TRUE :SLOTS ((KIND :TYPE KEYWORD) (POSITIVE-SCORE :TYPE PARTIAL-MATCH-SCORE) (NEGATIVE-SCORE :TYPE PARTIAL-MATCH-SCORE) (SUCCESS? :TYPE BOOLEAN) (PARENT :TYPE PARTIAL-MATCH-FRAME) (CHILD :TYPE PARTIAL-MATCH-FRAME) (ARGUMENT-SCORES :TYPE (CONS OF FLOAT-WRAPPER)) (ARGUMENT-WEIGHTS :TYPE (CONS OF FLOAT-WRAPPER)) (PROPOSITION :TYPE CONS :INITIALLY NIL) (ARITY :TYPE INTEGER) (DYNAMIC-CUTOFF :TYPE FLOAT) (UNBOUND-VARS :TYPE CONS :INITIALLY NIL) (FRAME-PTR :TYPE CONTROL-FRAME)))")))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-PARTIAL-MATCH-FRAME-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INCREMENTAL-PARTIAL-MATCH"
        "(DEFCLASS INCREMENTAL-PARTIAL-MATCH (PARTIAL-MATCH-FRAME) :SLOTS ((TOTAL-WEIGHT :TYPE FLOAT) (ACCUMULATED-SCORE :TYPE PARTIAL-MATCH-SCORE) (ACCUMULATED-WEIGHT :TYPE FLOAT) (ARGUMENT-SCORES :TYPE (CONS OF FLOAT-WRAPPER)) (ARGUMENT-WEIGHTS :TYPE (CONS OF FLOAT-WRAPPER)) (MAXIMUM-SCORE :TYPE PARTIAL-MATCH-SCORE)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INCREMENTAL-PARTIAL-MATCH))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-INCREMENTAL-PARTIAL-MATCH-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NN-PARTIAL-MATCH"
        "(DEFCLASS NN-PARTIAL-MATCH (PARTIAL-MATCH-FRAME) :SLOTS ((TOTAL-WEIGHT :TYPE FLOAT) (ACCUMULATED-SCORE :TYPE PARTIAL-MATCH-SCORE) (ACCUMULATED-WEIGHT :TYPE FLOAT) (ARGUMENT-SCORES :TYPE (CONS OF FLOAT-WRAPPER)) (ARGUMENT-WEIGHTS :TYPE (CONS OF FLOAT-WRAPPER)) (MAXIMUM-SCORE :TYPE PARTIAL-MATCH-SCORE) (RULES :TYPE (CONS OF PROPOSITION))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-NN-PARTIAL-MATCH))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-NN-PARTIAL-MATCH-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-PARTIAL-MATCH2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PARTIAL-MATCH-MODE* KEYWORD :BASIC)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *GREEDY-NETWORK-PRUNING* BOOLEAN TRUE)")
    (REGISTER-NATIVE-NAME SYM-PARTIAL-MATCH-LOGIC-SET-PARTIAL-MATCH-MODE
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *RULE-COMBINATION* KEYWORD :MAX)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PLANNING-MODE* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PLANABLE-PREDICATES* CONS NIL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *FAIL-UNBOUND-CLAUSES* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MINIMUM-SCORE-CUTOFF* PARTIAL-MATCH-SCORE 0.0 :DOCUMENTATION \"Positive scores below *minimum-score-cutoff* get trimmed
to 0.0 during partial match operations.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAXIMUM-SCORE-CUTOFF* PARTIAL-MATCH-SCORE 0.0 :DOCUMENTATION \"Positive scores above *maximum-score-cutoff* get trimmed
to 1.0 during partial match operations.\")")
    (REGISTER-NATIVE-NAME SYM-PARTIAL-MATCH-LOGIC-SET-RULE-COMBINATION
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-PARTIAL-MATCH-LOGIC-SET-GREEDY-NETWORK-PRUNING
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PARTIAL-MATCH-LOGIC-SET-MAXIMUM-SCORE-CUTOFF
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PARTIAL-MATCH-LOGIC-SET-MINIMUM-SCORE-CUTOFF
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *AND-MISSED-A-BINDING* BOOLEAN FALSE)")
    (REGISTER-NATIVE-NAME SYM-PARTIAL-MATCH-LOGIC-RETRIEVE-PARTIAL
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PARTIAL-MATCH-LOGIC-ASK-PARTIAL
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PARTIAL-MATCH-LOGIC-ASK-FIRST-PARTIAL
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *STATUS-CHARS* INTEGER 0)"))))
