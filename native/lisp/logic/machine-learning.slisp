;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; machine-learning.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-MACHINE-LEARNING-LOGIC-TRAINING-EXAMPLE NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-QUERY NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-CONCEPT NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-STELLA-NAME NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-SCORE NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-STELLA-MODULE NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-INPUT-FEATURES NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-INPUT NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-FACTS NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-NN-HIDDEN NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-OUTPUT NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-TEMP NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-CACHED-SOLUTION NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-TIMESTAMP NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-SET-CLOSED-WORLD-TRAINING-EXAMPLES NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-COMMON-LISP NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-FUNCTION NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-ADD-TRAINING-EXAMPLE NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-ADD-TRAINING-EXAMPLE-IN-MODULE NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-ADD-TESTING-EXAMPLE NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-MATCH-MODE NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-BASIC NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-MAXIMIZE-SCORE? NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-RETRACT-TRUE NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-ASSERT-TRUE NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-RETRACT-FALSE NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-ASSERT-FALSE NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-DEFRELATION NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-?P NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-STELLA-THING NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-DEFRULE NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-STELLA-FORALL NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-STELLA-=> NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-STELLA-AND NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-?Y NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-DONT-OPTIMIZE? NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-STELLA-TRUE NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-STELLA-NOT NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-TEST-DOMAIN-THEORY NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-APPROXIMATE NULL)
(CL:DEFVAR SGT-MACHINE-LEARNING-STELLA-FLOAT NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-SET-STRUCTURE-DEPTH NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-ADD-TABOO-OPERATORS NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-ISA NULL)
(CL:DEFVAR SGT-MACHINE-LEARNING-STELLA-NUMBER-WRAPPER NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-STELLA->= NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-STELLA-=< NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-STELLA-= NULL)
(CL:DEFVAR SGT-MACHINE-LEARNING-STELLA-SYMBOL NULL)
(CL:DEFVAR SGT-MACHINE-LEARNING-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-MACHINE-LEARNING-LOGIC-SKOLEM NULL)
(CL:DEFVAR SGT-MACHINE-LEARNING-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-MACHINE-LEARNING-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-MACHINE-LEARNING-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-MACHINE-LEARNING-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-IN NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-PREDICATE NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-EQUIVALENT NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-FORALL NULL)
(CL:DEFVAR KWD-MACHINE-LEARNING-EXISTS NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-STELLA-OR NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR SGT-MACHINE-LEARNING-STELLA-THING NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-PRINT-FACTS NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-LOGIC-STARTUP-MACHINE-LEARNING NULL)
(CL:DEFVAR SYM-MACHINE-LEARNING-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *QUERYITERATOR*
  *VISITED-PROPOSITIONS* *VISITED-INSTANCES* STANDARD-ERROR
  UNKNOWN-TRUTH-VALUE TRUE-TRUTH-VALUE DEFAULT-TRUE-TRUTH-VALUE
  FALSE-WRAPPER *CASE-ANTECEDENT-TABLE* *CASE-TYPES-TABLE*
  *LOG-MATCH-RULES* *DROP-FUNCTION-VALUES?* *FAIL-UNBOUND-CLAUSES?*
  TRUE-WRAPPER *MODULE* NIL STANDARD-OUTPUT EOL NULL-INTEGER
  NULL-FLOAT))

(CL:DEFUN NEW-TRAINING-EXAMPLE ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-TRAINING-EXAMPLE))
   (CL:SETF (%TRAINING-EXAMPLE.TIMESTAMP SELF) NULL-INTEGER)
   (CL:SETF (%TRAINING-EXAMPLE.CACHED-SOLUTION SELF) NULL)
   (CL:SETF (%TRAINING-EXAMPLE.TEMP SELF) NULL-FLOAT)
   (CL:SETF (%TRAINING-EXAMPLE.OUTPUT SELF) NULL)
   (CL:SETF (%TRAINING-EXAMPLE.NN-HIDDEN SELF) NULL)
   (CL:SETF (%TRAINING-EXAMPLE.FACTS SELF) NULL)
   (CL:SETF (%TRAINING-EXAMPLE.INPUT SELF) NULL)
   (CL:SETF (%TRAINING-EXAMPLE.INPUT-FEATURES SELF) NULL)
   (CL:SETF (%TRAINING-EXAMPLE.MODULE SELF) NULL)
   (CL:SETF (%TRAINING-EXAMPLE.SCORE SELF) NULL-FLOAT)
   (CL:SETF (%TRAINING-EXAMPLE.NAME SELF) NULL)
   (CL:SETF (%TRAINING-EXAMPLE.CONCEPT SELF) NULL)
   (CL:SETF (%TRAINING-EXAMPLE.QUERY SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRAINING-EXAMPLE))
  SGT-MACHINE-LEARNING-LOGIC-TRAINING-EXAMPLE)

(CL:DEFUN ACCESS-TRAINING-EXAMPLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-MACHINE-LEARNING-LOGIC-QUERY)
    (CL:IF SETVALUE? (CL:SETF (%TRAINING-EXAMPLE.QUERY SELF) VALUE)
     (CL:SETQ VALUE (%TRAINING-EXAMPLE.QUERY SELF))))
   ((CL:EQ SLOTNAME SYM-MACHINE-LEARNING-LOGIC-CONCEPT)
    (CL:IF SETVALUE? (CL:SETF (%TRAINING-EXAMPLE.CONCEPT SELF) VALUE)
     (CL:SETQ VALUE (%TRAINING-EXAMPLE.CONCEPT SELF))))
   ((CL:EQ SLOTNAME SYM-MACHINE-LEARNING-STELLA-NAME)
    (CL:IF SETVALUE? (CL:SETF (%TRAINING-EXAMPLE.NAME SELF) VALUE)
     (CL:SETQ VALUE (%TRAINING-EXAMPLE.NAME SELF))))
   ((CL:EQ SLOTNAME SYM-MACHINE-LEARNING-LOGIC-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%TRAINING-EXAMPLE.SCORE SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%TRAINING-EXAMPLE.SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-MACHINE-LEARNING-STELLA-MODULE)
    (CL:IF SETVALUE? (CL:SETF (%TRAINING-EXAMPLE.MODULE SELF) VALUE)
     (CL:SETQ VALUE (%TRAINING-EXAMPLE.MODULE SELF))))
   ((CL:EQ SLOTNAME SYM-MACHINE-LEARNING-LOGIC-INPUT-FEATURES)
    (CL:IF SETVALUE?
     (CL:SETF (%TRAINING-EXAMPLE.INPUT-FEATURES SELF) VALUE)
     (CL:SETQ VALUE (%TRAINING-EXAMPLE.INPUT-FEATURES SELF))))
   ((CL:EQ SLOTNAME SYM-MACHINE-LEARNING-LOGIC-INPUT)
    (CL:IF SETVALUE? (CL:SETF (%TRAINING-EXAMPLE.INPUT SELF) VALUE)
     (CL:SETQ VALUE (%TRAINING-EXAMPLE.INPUT SELF))))
   ((CL:EQ SLOTNAME SYM-MACHINE-LEARNING-LOGIC-FACTS)
    (CL:IF SETVALUE? (CL:SETF (%TRAINING-EXAMPLE.FACTS SELF) VALUE)
     (CL:SETQ VALUE (%TRAINING-EXAMPLE.FACTS SELF))))
   ((CL:EQ SLOTNAME SYM-MACHINE-LEARNING-LOGIC-NN-HIDDEN)
    (CL:IF SETVALUE? (CL:SETF (%TRAINING-EXAMPLE.NN-HIDDEN SELF) VALUE)
     (CL:SETQ VALUE (%TRAINING-EXAMPLE.NN-HIDDEN SELF))))
   ((CL:EQ SLOTNAME SYM-MACHINE-LEARNING-LOGIC-OUTPUT)
    (CL:IF SETVALUE? (CL:SETF (%TRAINING-EXAMPLE.OUTPUT SELF) VALUE)
     (CL:SETQ VALUE (%TRAINING-EXAMPLE.OUTPUT SELF))))
   ((CL:EQ SLOTNAME SYM-MACHINE-LEARNING-LOGIC-TEMP)
    (CL:IF SETVALUE?
     (CL:SETF (%TRAINING-EXAMPLE.TEMP SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%TRAINING-EXAMPLE.TEMP SELF)))))
   ((CL:EQ SLOTNAME SYM-MACHINE-LEARNING-LOGIC-CACHED-SOLUTION)
    (CL:IF SETVALUE?
     (CL:SETF (%TRAINING-EXAMPLE.CACHED-SOLUTION SELF) VALUE)
     (CL:SETQ VALUE (%TRAINING-EXAMPLE.CACHED-SOLUTION SELF))))
   ((CL:EQ SLOTNAME SYM-MACHINE-LEARNING-LOGIC-TIMESTAMP)
    (CL:IF SETVALUE?
     (CL:SETF (%TRAINING-EXAMPLE.TIMESTAMP SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%TRAINING-EXAMPLE.TIMESTAMP SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFGLOBAL *TRAINING-EXAMPLES* ...)

(CL:DEFVAR *TRAINING-EXAMPLES* NULL)

;;; (DEFGLOBAL *TESTING-EXAMPLES* ...)

(CL:DEFVAR *TESTING-EXAMPLES* NULL)

;;; (DEFGLOBAL *CLOSED-WORLD-TRAINING-EXAMPLES* ...)

(CL:DEFVAR *CLOSED-WORLD-TRAINING-EXAMPLES* CL:T)

;;; (DEFUN SET-CLOSED-WORLD-TRAINING-EXAMPLES ...)

(CL:DEFUN %SET-CLOSED-WORLD-TRAINING-EXAMPLES (B)
  (CL:SETQ *CLOSED-WORLD-TRAINING-EXAMPLES* B))

(CL:DEFUN SET-CLOSED-WORLD-TRAINING-EXAMPLES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-CLOSED-WORLD-TRAINING-EXAMPLES
   (%BOOLEAN-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-CLOSED-WORLD-TRAINING-EXAMPLES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-CLOSED-WORLD-TRAINING-EXAMPLES|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-CLOSED-WORLD-TRAINING-EXAMPLES)))

;;; (DEFUN PRINT-TRAINING-EXAMPLE ...)

(CL:DEFUN PRINT-TRAINING-EXAMPLE (EXAMPLE)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   (%TRAINING-EXAMPLE.QUERY EXAMPLE) " in "
   (%TRAINING-EXAMPLE.MODULE EXAMPLE) EOL))

;;; (DEFUN ADD-TRAINING-EXAMPLE ...)

(CL:DEFUN %ADD-TRAINING-EXAMPLE (FORM SCORE)
  "Add a query and score pair to the master list of 
  training examples"
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE))
  #+MCL
  (CL:CHECK-TYPE SCORE CL:DOUBLE-FLOAT)
  (CL:LET* ((EXAMPLE (NEW-TRAINING-EXAMPLE)))
   (CL:SETF (%TRAINING-EXAMPLE.QUERY EXAMPLE) (COPY-CONS-LIST FORM))
   (CL:SETF (%TRAINING-EXAMPLE.SCORE EXAMPLE) SCORE)
   (PUSH *TRAINING-EXAMPLES* EXAMPLE)))

(CL:DEFUN ADD-TRAINING-EXAMPLE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%ADD-TRAINING-EXAMPLE (%%VALUE ARGUMENTS)
   (%FLOAT-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO ADD-TRAINING-EXAMPLE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Add a query and score pair to the master list of 
  training examples"
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/ADD-TRAINING-EXAMPLE|)) (CL:MACRO-FUNCTION (CL:QUOTE ADD-TRAINING-EXAMPLE)))

;;; (DEFUN ADD-TRAINING-EXAMPLE-IN-MODULE ...)

(CL:DEFUN %ADD-TRAINING-EXAMPLE-IN-MODULE (FORM SCORE MODULE)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE))
  #+MCL
  (CL:CHECK-TYPE SCORE CL:DOUBLE-FLOAT)
  (CL:SETQ MODULE (PERMANENTIFY MODULE))
  (CL:LET* ((EXAMPLE (NEW-TRAINING-EXAMPLE)))
   (CL:SETF (%TRAINING-EXAMPLE.QUERY EXAMPLE) (COPY-CONS-LIST FORM))
   (CL:SETF (%TRAINING-EXAMPLE.SCORE EXAMPLE) SCORE)
   (CL:SETF (%TRAINING-EXAMPLE.MODULE EXAMPLE) (GET-MODULE MODULE))
   (PUSH *TRAINING-EXAMPLES* EXAMPLE)))

(CL:DEFUN ADD-TRAINING-EXAMPLE-IN-MODULE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%ADD-TRAINING-EXAMPLE-IN-MODULE (%%VALUE ARGUMENTS)
   (%FLOAT-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))
   (%%VALUE (%%REST (%%REST ARGUMENTS)))))

(CL:DEFMACRO ADD-TRAINING-EXAMPLE-IN-MODULE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/ADD-TRAINING-EXAMPLE-IN-MODULE|)) (CL:MACRO-FUNCTION (CL:QUOTE ADD-TRAINING-EXAMPLE-IN-MODULE)))

;;; (DEFUN ADD-TESTING-EXAMPLE ...)

(CL:DEFUN %ADD-TESTING-EXAMPLE (FORM SCORE)
  "Add a query and score pair to the master list of 
  testing examples"
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE))
  #+MCL
  (CL:CHECK-TYPE SCORE CL:DOUBLE-FLOAT)
  (CL:LET* ((EXAMPLE (NEW-TRAINING-EXAMPLE)))
   (CL:SETF (%TRAINING-EXAMPLE.QUERY EXAMPLE) (COPY-CONS-LIST FORM))
   (CL:SETF (%TRAINING-EXAMPLE.SCORE EXAMPLE) SCORE)
   (PUSH *TESTING-EXAMPLES* EXAMPLE)))

(CL:DEFUN ADD-TESTING-EXAMPLE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%ADD-TESTING-EXAMPLE (%%VALUE ARGUMENTS)
   (%FLOAT-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO ADD-TESTING-EXAMPLE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Add a query and score pair to the master list of 
  testing examples"
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/ADD-TESTING-EXAMPLE|)) (CL:MACRO-FUNCTION (CL:QUOTE ADD-TESTING-EXAMPLE)))

;;; (DEFUN CLEAR-TRAINING-EXAMPLES ...)

(CL:DEFUN CLEAR-TRAINING-EXAMPLES ()
  (CL:SETQ *TRAINING-EXAMPLES* (NEW-LIST)))

;;; (DEFUN SHUFFLE-LIST ...)

(CL:DEFUN SHUFFLE-LIST (CARDS)
  (CL:LET*
   ((NUM (LENGTH CARDS)) (STOP (CL:/ NUM 2.0d0)) (TEMP NULL) (I 0)
    (ONE 0) (TWO 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM I ONE TWO)
    (CL:TYPE CL:DOUBLE-FLOAT STOP))
   (CL:LOOP WHILE (CL:< I STOP) DO (CL:SETQ I (CL:1+ I))
    (CL:SETQ ONE (RANDOM NUM)) (CL:SETQ TWO (RANDOM NUM))
    (CL:SETQ TEMP (NTH CARDS ONE))
    (NTH-SETTER CARDS (NTH CARDS TWO) ONE) (NTH-SETTER CARDS TEMP TWO))))

;;; (DEFUN SHUFFLE-VECTOR ...)

(CL:DEFUN SHUFFLE-VECTOR (CARDS)
  (CL:LET*
   ((NUM (LENGTH CARDS)) (STOP (CL:/ NUM 2.0d0)) (TEMP NULL) (I 0)
    (ONE 0) (TWO 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM I ONE TWO)
    (CL:TYPE CL:DOUBLE-FLOAT STOP))
   (CL:LOOP WHILE (CL:< I STOP) DO (CL:SETQ I (CL:1+ I))
    (CL:SETQ ONE (RANDOM NUM)) (CL:SETQ TWO (RANDOM NUM))
    (CL:SETQ TEMP
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY CARDS)) ONE))
    (CL:LET
     ((SELF (%VECTOR.THE-ARRAY CARDS))
      (VALUE
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY CARDS))
        TWO))
      (POSITION ONE))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET
     ((SELF (%VECTOR.THE-ARRAY CARDS)) (VALUE TEMP) (POSITION TWO))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE)))))

;;; (DEFUN SAVE-TRAINING-EXAMPLES ...)

(CL:DEFUN SAVE-TRAINING-EXAMPLES ()
  (CL:LET*
   ((NAME-FILE (NEW-OUTPUT-FILE-STREAM "training.names"))
    (DATA-FILE (NEW-OUTPUT-FILE-STREAM "training.data")))
   (CREATE-PROPOSITIONAL-TRAINING-EXAMPLES *TRAINING-EXAMPLES*
    NAME-FILE DATA-FILE)
   (FREE NAME-FILE) (FREE DATA-FILE)))

;;; (DEFUN (CREATE-PROPOSITIONAL-TRAINING-EXAMPLES INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:T) CL:FIXNUM)
  CREATE-PROPOSITIONAL-TRAINING-EXAMPLES))
(CL:DEFUN CREATE-PROPOSITIONAL-TRAINING-EXAMPLES (EXAMPLES NAME-FILE DATA-FILE)
  (CL:LET* ((NUM-INPUTS 0) (HOME *MODULE*) (TEMP 0) (INPUT NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-INPUTS TEMP))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (CL:EQ (%TRAINING-EXAMPLE.MODULE EXAMPLE) NULL))
      (CHANGE-MODULE (%TRAINING-EXAMPLE.MODULE EXAMPLE)))
     (CL:SETQ INPUT
      (CREATE-INPUT-SIGNATURE (%TRAINING-EXAMPLE.QUERY EXAMPLE)))
     (CL:SETF (%TRAINING-EXAMPLE.INPUT EXAMPLE) INPUT)
     (CHANGE-MODULE HOME)
     (CL:LET*
      ((ELE NULL) (VECTOR-000 INPUT) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ELE
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ TEMP (%INTEGER-WRAPPER.WRAPPER-VALUE ELE))
       (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM DATA-FILE)
        TEMP ",")
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM DATA-FILE)
      (%TRAINING-EXAMPLE.OUTPUT EXAMPLE) EOL)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ NUM-INPUTS (LENGTH INPUT))
   (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM NAME-FILE)
    "true,false" EOL)
   (CL:LET*
    ((I NULL-INTEGER) (ITER-001 0)
     (UPPER-BOUND-000 (CL:1- NUM-INPUTS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-001)
     (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM NAME-FILE) "A"
      (STRINGIFY (WRAP-INTEGER I)) ":  1,0" EOL)
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   NUM-INPUTS))

;;; (DEFUN FILL-IN-EXAMPLE-OUTPUTS ...)

(CL:DEFUN FILL-IN-EXAMPLE-OUTPUTS (EXAMPLES SLOT-NAME)
  (CL:LET*
   ((SLOT
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION SLOT-NAME)))
    (SLOT-VALUE NULL) (INSTANCE NULL))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (CL:EQ (%TRAINING-EXAMPLE.MODULE EXAMPLE) NULL))
      (CHANGE-MODULE (%TRAINING-EXAMPLE.MODULE EXAMPLE)))
     (CL:SETQ INSTANCE
      (GET-INSTANCE
       (%%VALUE (%%REST (%TRAINING-EXAMPLE.QUERY EXAMPLE)))))
     (CL:SETQ SLOT-VALUE (GET-SLOT-VALUE INSTANCE SLOT))
     (CL:SETF (%TRAINING-EXAMPLE.OUTPUT EXAMPLE) SLOT-VALUE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

;;; (DEFUN DETECT-NOISE-IN-TRAINING-EXAMPLES ...)

(CL:DEFUN DETECT-NOISE-IN-TRAINING-EXAMPLES (EXAMPLES)
  (CL:LET* ((HOME *MODULE*) (SIG-LENGTH 0) (SAME CL:T))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIG-LENGTH))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%TRAINING-EXAMPLE.INPUT EXAMPLE) NULL)
      (CL:WHEN (CL:NOT (CL:EQ (%TRAINING-EXAMPLE.MODULE EXAMPLE) NULL))
       (CHANGE-MODULE (%TRAINING-EXAMPLE.MODULE EXAMPLE)))
      (CL:SETF (%TRAINING-EXAMPLE.INPUT EXAMPLE)
       (CREATE-INPUT-SIGNATURE (%TRAINING-EXAMPLE.QUERY EXAMPLE)))
      (CHANGE-MODULE HOME))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ SIG-LENGTH
    (LENGTH (%TRAINING-EXAMPLE.INPUT (FIRST EXAMPLES))))
   (CL:LET* ((EXAMPLE1 NULL) (ITER-001 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ EXAMPLE1 (%%VALUE ITER-001))
     (CL:LET*
      ((EXAMPLE2 NULL) (ITER-002 (%LIST.THE-CONS-LIST EXAMPLES)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ EXAMPLE2 (%%VALUE ITER-002)) (CL:SETQ SAME CL:T)
       (CL:LET*
        ((K NULL-INTEGER) (ITER-003 0)
         (UPPER-BOUND-000 (CL:1- SIG-LENGTH)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM K ITER-003 UPPER-BOUND-000))
        (CL:LOOP WHILE (CL:<= ITER-003 UPPER-BOUND-000) DO
         (CL:SETQ K ITER-003)
         (CL:WHEN
          (CL:NOT
           (EQL?
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%VECTOR.THE-ARRAY (%TRAINING-EXAMPLE.INPUT EXAMPLE1)))
             K)
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%VECTOR.THE-ARRAY (%TRAINING-EXAMPLE.INPUT EXAMPLE2)))
             K)))
          (CL:SETQ SAME CL:NIL) (CL:RETURN))
         (CL:SETQ ITER-003 (CL:1+ ITER-003))))
       (CL:WHEN
        (CL:AND SAME
         (CL:NOT
          (EQL? (%TRAINING-EXAMPLE.OUTPUT EXAMPLE1)
           (%TRAINING-EXAMPLE.OUTPUT EXAMPLE2))))
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         (LAST (%TRAINING-EXAMPLE.QUERY EXAMPLE1)) " and "
         (LAST (%TRAINING-EXAMPLE.QUERY EXAMPLE2))
         " have the same input but different output" EOL))
       (CL:SETQ ITER-002 (%%REST ITER-002))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))))

;;; (DEFUN (GET-CLASSIFICATION-RELATIONS (LIST OF PROPOSITION)) ...)

(CL:DEFUN GET-CLASSIFICATION-RELATIONS (CONS-QUERY)
  (CL:LET*
   ((QUERY (MAKE-QUERY NIL (COPY-CONS-TREE CONS-QUERY) NIL NIL))
    (RESULT (NEW-LIST)) (PMF NULL))
   (INSERT-AT (%QUERY-ITERATOR.OPTIONS QUERY)
    KWD-MACHINE-LEARNING-MATCH-MODE KWD-MACHINE-LEARNING-BASIC)
   (INSERT-AT (%QUERY-ITERATOR.OPTIONS QUERY)
    KWD-MACHINE-LEARNING-MAXIMIZE-SCORE? TRUE-WRAPPER)
   (CALL-ASK-PARTIAL QUERY)
   (CL:SETQ PMF
    (%PARTIAL-MATCH-FRAME.CHILD
     (%PARTIAL-MATCH-FRAME.CHILD
      (%CONTROL-FRAME.PARTIAL-MATCH-FRAME
       (%QUERY-ITERATOR.BASE-CONTROL-FRAME QUERY)))))
   (CL:LET*
    ((PROP NULL)
     (VECTOR-000
      (%PROPOSITION.ARGUMENTS
       (%CONTROL-FRAME.PROPOSITION
        (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME PMF))))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ PROP
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS PROP NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST RESULT) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST RESULT) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST RESULT)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS PROP NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   RESULT))

;;; (DEFUN (CREATE-INPUT-SIGNATURE (VECTOR OF INTEGER-WRAPPER)) ...)

(CL:DEFUN CREATE-INPUT-SIGNATURE (CONS-QUERY)
  (CL:LET*
   ((QUERY (MAKE-QUERY NIL (COPY-CONS-TREE CONS-QUERY) NIL NIL))
    (PMF NULL) (ARG-SCORES NIL) (SIGNATURE NULL))
   (CL:SETQ *FAIL-UNBOUND-CLAUSES?* CL:T)
   (INSERT-AT (%QUERY-ITERATOR.OPTIONS QUERY)
    KWD-MACHINE-LEARNING-MATCH-MODE KWD-MACHINE-LEARNING-BASIC)
   (INSERT-AT (%QUERY-ITERATOR.OPTIONS QUERY)
    KWD-MACHINE-LEARNING-MAXIMIZE-SCORE? TRUE-WRAPPER)
   (CALL-ASK-PARTIAL QUERY)
   (CL:SETQ PMF
    (%PARTIAL-MATCH-FRAME.CHILD
     (%PARTIAL-MATCH-FRAME.CHILD
      (%CONTROL-FRAME.PARTIAL-MATCH-FRAME
       (%QUERY-ITERATOR.BASE-CONTROL-FRAME QUERY)))))
   (CL:SETQ ARG-SCORES
    (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-SCORES PMF))
   (CL:SETQ SIGNATURE (NEW-VECTOR (LENGTH ARG-SCORES)))
   (CL:LET*
    ((SCORE NULL) (ITER-000 (REVERSE ARG-SCORES)) (I NULL-INTEGER)
     (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SCORE (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:IF (EQL? SCORE (WRAP-FLOAT 1.0d0))
      (CL:LET
       ((SELF (%VECTOR.THE-ARRAY SIGNATURE)) (VALUE (WRAP-INTEGER 1))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:LET
       ((SELF (%VECTOR.THE-ARRAY SIGNATURE)) (VALUE (WRAP-INTEGER 0))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE)))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   SIGNATURE))

;;; (DEFUN GENERATE-CLASSIFICATION-RULE ...)

(CL:DEFUN GENERATE-CLASSIFICATION-RULE (INSTANCES CONCEPT-NAME CLASS-NAME BUILD-RULE?)
  (CL:LET*
   ((NUM-INSTANCES (LENGTH INSTANCES))
    (KIND
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION CLASS-NAME)))
    (NAME NULL) (PROP NULL) (FUNCTION-VALUES? *DROP-FUNCTION-VALUES?*))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-INSTANCES))
   (CL:SETQ *DROP-FUNCTION-VALUES?* CL:NIL)
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- NUM-INSTANCES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:SETQ NAME
      (OBJECT-NAME
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES))
        I)))
     (CL:SETQ PROP (CONCEIVE-FORMULA (CONS-LIST CONCEPT-NAME NAME)))
     (CL:WHEN (TRUE? PROP)
      (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
       KWD-MACHINE-LEARNING-RETRACT-TRUE)
      (BUILD-CASE-FROM-INSTANCE
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES))
        I)
       KIND)
      (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
       KWD-MACHINE-LEARNING-ASSERT-TRUE))
     (CL:WHEN (FALSE? PROP)
      (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
       KWD-MACHINE-LEARNING-RETRACT-FALSE)
      (BUILD-CASE-FROM-INSTANCE
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES))
        I)
       KIND)
      (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
       KWD-MACHINE-LEARNING-ASSERT-FALSE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETQ *DROP-FUNCTION-VALUES?* FUNCTION-VALUES?)
   (CL:WHEN BUILD-RULE?
    (BUILD-CLASSIFICATION-RULE CONCEPT-NAME CLASS-NAME))))

;;; (DEFUN BUILD-CLASSIFICATION-RULE ...)

(CL:DEFUN BUILD-CLASSIFICATION-RULE (KIND CLASS-NAME)
  (CL:LET*
   ((RULE-NAME
     (INTERN-SYMBOL
      (CONCATENATE (%SYMBOL.SYMBOL-NAME KIND) "-Classification-Rule")))
    (RELATION-NAME
     (INTERN-SYMBOL
      (CONCATENATE (%SYMBOL.SYMBOL-NAME KIND) "-Classification")))
    (INDEX (CONCATENATE (%SYMBOL.SYMBOL-NAME CLASS-NAME) "-match"))
    (RULE-ANTECEDENT (LOOKUP *CASE-ANTECEDENT-TABLE* INDEX))
    (CONVERTED-ANTECEDENT NIL)
    (RULE-TYPES (LOOKUP *CASE-TYPES-TABLE* INDEX))
    (CONVERTED-TYPES NIL)
    (RELATION
     (LIST* SYM-MACHINE-LEARNING-LOGIC-DEFRELATION RELATION-NAME
      (CONS
       (CONS
        (LIST* SYM-MACHINE-LEARNING-LOGIC-?P
         SYM-MACHINE-LEARNING-STELLA-THING NIL)
        NIL)
       NIL)))
    (RULE NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING INDEX))
   (CL:LET*
    ((CLAUSE NULL) (ITER-000 (%LIST.THE-CONS-LIST RULE-ANTECEDENT))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CLAUSE (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS CLAUSE NIL))
       (CL:IF (CL:EQ CONVERTED-ANTECEDENT NIL)
        (CL:SETQ CONVERTED-ANTECEDENT COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST CONVERTED-ANTECEDENT
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS CLAUSE NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((TYPE NULL) (ITER-001 (%LIST.THE-CONS-LIST RULE-TYPES))
     (COLLECT-001 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ TYPE (%%VALUE ITER-001))
     (CL:IF (CL:EQ COLLECT-001 NULL)
      (CL:PROGN (CL:SETQ COLLECT-001 (CONS TYPE NIL))
       (CL:IF (CL:EQ CONVERTED-TYPES NIL)
        (CL:SETQ CONVERTED-TYPES COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST CONVERTED-TYPES COLLECT-001)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS TYPE NIL))
       (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:SETQ RULE
    (LIST* SYM-MACHINE-LEARNING-LOGIC-DEFRULE RULE-NAME
     (LIST*
      (LIST* SYM-MACHINE-LEARNING-STELLA-FORALL CONVERTED-TYPES
       (CONS
        (LIST* SYM-MACHINE-LEARNING-STELLA-=>
         (CONS SYM-MACHINE-LEARNING-STELLA-AND
          (CONCATENATE CONVERTED-ANTECEDENT NIL))
         (CONS RELATION-NAME (CONS SYM-MACHINE-LEARNING-LOGIC-?Y NIL))
         NIL)
        NIL))
      KWD-MACHINE-LEARNING-DONT-OPTIMIZE?
      SYM-MACHINE-LEARNING-STELLA-TRUE NIL)))
   (CL:WHEN *LOG-MATCH-RULES*
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) RULE
     EOL))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Building classification rule with " (LENGTH CONVERTED-ANTECEDENT)
    " clauses and " (LENGTH CONVERTED-TYPES) " variables" EOL)
   (CL:WHEN (CL:NOT (EMPTY? RULE-ANTECEDENT))
    (EVALUATE-LOGIC-COMMAND RELATION CL:NIL)
    (EVALUATE-LOGIC-COMMAND RULE CL:NIL))))

;;; (DEFUN (OLD-GENERATE-CLASSIFICATION-TRAINING-EXAMPLES INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM)
  OLD-GENERATE-CLASSIFICATION-TRAINING-EXAMPLES))
(CL:DEFUN OLD-GENERATE-CLASSIFICATION-TRAINING-EXAMPLES (INSTANCES CONCEPT)
  (CL:LET*
   ((NUM-INSTANCES (LENGTH INSTANCES)) (CONS-QUERY NIL) (TARGET CL:NIL)
    (CONCEPT-NAME (INTERN-SYMBOL (%SURROGATE.SYMBOL-NAME CONCEPT))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-INSTANCES))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- NUM-INSTANCES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:LET* ((EXAMPLE (NEW-TRAINING-EXAMPLE)))
      (CL:SETQ TARGET
       (TRUE-TRUTH-VALUE?
        (CALL-ASK
         (MAKE-QUERY NIL
          (CONS-LIST CONCEPT-NAME
           (OBJECT-NAME
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES))
             I)))
          NIL NIL))))
      (CL:SETQ CONS-QUERY
       (CONS-LIST
        (INTERN-SYMBOL
         (CONCATENATE (%SYMBOL.SYMBOL-NAME CONCEPT-NAME)
          "-Classification"))
        (OBJECT-NAME
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES)) I))))
      (CL:SETF (%TRAINING-EXAMPLE.QUERY EXAMPLE) CONS-QUERY)
      (CL:SETF (%TRAINING-EXAMPLE.OUTPUT EXAMPLE)
       (CL:IF TARGET TRUE-WRAPPER FALSE-WRAPPER))
      (CL:SETF (%TRAINING-EXAMPLE.CONCEPT EXAMPLE) CONCEPT-NAME)
      (CL:SETF (%TRAINING-EXAMPLE.NAME EXAMPLE)
       (OBJECT-NAME
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES)) I)))
      (CL:SETF (%TRAINING-EXAMPLE.MODULE EXAMPLE) *MODULE*)
      (CL:SETF (%TRAINING-EXAMPLE.INPUT EXAMPLE)
       (CREATE-INPUT-SIGNATURE CONS-QUERY))
      (CL:SETF (%TRAINING-EXAMPLE.TIMESTAMP EXAMPLE) -1)
      (PUSH *TRAINING-EXAMPLES* EXAMPLE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   NUM-INSTANCES))

;;; (DEFUN TEST-DOMAIN-THEORY ...)

(CL:DEFUN %TEST-DOMAIN-THEORY (RELATION-NAME CLASS-NAME)
  (CL:LET*
   ((CLASS
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION CLASS-NAME)))
    (PROP NULL) (CONS-QUERY NIL) (QUERY NULL)
    (INSTANCES (LISTIFY (ALL-CLASS-INSTANCES CLASS))) (CORRECT? CL:T)
    (NUM-CORRECT 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-CORRECT))
   (CL:LET*
    ((INSTANCE NULL) (ITER-000 (%LIST.THE-CONS-LIST INSTANCES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ INSTANCE (%%VALUE ITER-000))
     (CL:SETQ CONS-QUERY
      (CONS-LIST RELATION-NAME (OBJECT-NAME INSTANCE)))
     (CL:SETQ PROP (CONCEIVE-FORMULA (COPY-CONS-TREE CONS-QUERY)))
     (CL:SETQ CORRECT? CL:T)
     (CL:WHEN (TRUE? PROP)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       CONS-QUERY " is true" EOL)
      (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
       KWD-MACHINE-LEARNING-RETRACT-TRUE)
      (CL:SETQ QUERY
       (MAKE-QUERY NIL
        (COPY-CONS-TREE
         (LIST* SYM-MACHINE-LEARNING-STELLA-NOT CONS-QUERY NIL))
        NIL NIL))
      (CL:WHEN (TRUE-TRUTH-VALUE? (CALL-ASK QUERY))
       (CL:SETQ CORRECT? CL:NIL)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "  **Theory disproves " CONS-QUERY " true" EOL))
      (CL:SETQ QUERY
       (MAKE-QUERY NIL (COPY-CONS-TREE CONS-QUERY) NIL NIL))
      (CL:WHEN (UNKNOWN-TRUTH-VALUE? (CALL-ASK QUERY))
       (CL:SETQ CORRECT? CL:NIL)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "  **Theory cannot prove " CONS-QUERY EOL))
      (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
       KWD-MACHINE-LEARNING-ASSERT-TRUE))
     (CL:WHEN (FALSE? PROP)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       CONS-QUERY " is false" EOL)
      (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
       KWD-MACHINE-LEARNING-RETRACT-FALSE)
      (CL:SETQ QUERY
       (MAKE-QUERY NIL (COPY-CONS-TREE CONS-QUERY) NIL NIL))
      (CL:WHEN (TRUE-TRUTH-VALUE? (CALL-ASK QUERY))
       (CL:SETQ CORRECT? CL:NIL)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "  **Theory proves " CONS-QUERY "true" EOL))
      (CL:SETQ QUERY
       (MAKE-QUERY NIL
        (COPY-CONS-TREE
         (LIST* SYM-MACHINE-LEARNING-STELLA-NOT CONS-QUERY NIL))
        NIL NIL))
      (CL:WHEN (UNKNOWN-TRUTH-VALUE? (CALL-ASK QUERY))
       (CL:SETQ CORRECT? CL:NIL)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "  **Theory cannot disprove " CONS-QUERY EOL))
      (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
       KWD-MACHINE-LEARNING-ASSERT-FALSE))
     (CL:WHEN CORRECT? (CL:SETQ NUM-CORRECT (CL:1+ NUM-CORRECT)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
    "Theory got " NUM-CORRECT " out of " (LENGTH INSTANCES) EOL)))

(CL:DEFMACRO TEST-DOMAIN-THEORY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/TEST-DOMAIN-THEORY|)) (CL:MACRO-FUNCTION (CL:QUOTE TEST-DOMAIN-THEORY)))

;;; (DEFUN (TEST-THEORY-OVER-EXAMPLES FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT)
  TEST-THEORY-OVER-EXAMPLES))
(CL:DEFUN TEST-THEORY-OVER-EXAMPLES (EXAMPLES)
  (CL:LET* ((CORRECT 0.0d0) (QUERY NULL) (CONS-QUERY NIL) (PROP NULL))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT CORRECT))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:SETQ CONS-QUERY
      (COPY-CONS-TREE (%TRAINING-EXAMPLE.QUERY EXAMPLE)))
     (CL:SETQ PROP (CONCEIVE-FORMULA (COPY-CONS-TREE CONS-QUERY)))
     (CL:SETQ QUERY
      (MAKE-QUERY NIL
       (COPY-CONS-TREE (%TRAINING-EXAMPLE.QUERY EXAMPLE)) NIL NIL))
     (CL:COND
      ((SUBTYPE-OF-BOOLEAN?
        (SAFE-PRIMARY-TYPE (%TRAINING-EXAMPLE.OUTPUT EXAMPLE)))
       (CL:IF
        (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
         (%TRAINING-EXAMPLE.OUTPUT EXAMPLE))
        (CL:PROGN
         (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
          KWD-MACHINE-LEARNING-RETRACT-TRUE)
         (CL:WHEN (TRUE-TRUTH-VALUE? (CALL-ASK QUERY))
          (CL:SETQ CORRECT (CL:1+ CORRECT)))
         (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
          KWD-MACHINE-LEARNING-ASSERT-TRUE))
        (CL:PROGN
         (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
          KWD-MACHINE-LEARNING-RETRACT-FALSE)
         (CL:WHEN (UNKNOWN-TRUTH-VALUE? (CALL-ASK QUERY))
          (CL:SETQ CORRECT (CL:1+ CORRECT)))
         (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
          KWD-MACHINE-LEARNING-ASSERT-FALSE))))
      (CL:T))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:/ CORRECT (LENGTH EXAMPLES))))

;;; (DEFUN (GENERATE-TRAINING-EXAMPLES INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM)
  GENERATE-TRAINING-EXAMPLES))
(CL:DEFUN GENERATE-TRAINING-EXAMPLES (INSTANCES CONCEPT)
  (CL:LET*
   ((NUM-INSTANCES (LENGTH INSTANCES)) (CONS-QUERY NIL)
    (NUM-EXAMPLES 0) (EXAMPLE NULL) (PROP NULL) (QUERY NULL)
    (CONCEPT-NAME (INTERN-SYMBOL (%SURROGATE.SYMBOL-NAME CONCEPT))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-INSTANCES NUM-EXAMPLES))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- NUM-INSTANCES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:SETQ CONS-QUERY
      (CONS-LIST CONCEPT-NAME
       (OBJECT-NAME
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES)) I))))
     (CL:SETQ PROP (CONCEIVE-FORMULA (COPY-CONS-TREE CONS-QUERY)))
     (CL:SETQ EXAMPLE NULL)
     (CL:IF (TRUE? PROP)
      (CL:PROGN
       (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
        KWD-MACHINE-LEARNING-RETRACT-TRUE)
       (CL:SETQ QUERY
        (MAKE-QUERY NIL (COPY-CONS-TREE CONS-QUERY) NIL NIL))
       (CL:WHEN (UNKNOWN-TRUTH-VALUE? (CALL-ASK QUERY))
        (CL:SETQ EXAMPLE (NEW-TRAINING-EXAMPLE))
        (CL:SETF (%TRAINING-EXAMPLE.QUERY EXAMPLE) CONS-QUERY)
        (CL:SETF (%TRAINING-EXAMPLE.OUTPUT EXAMPLE) TRUE-WRAPPER)
        (CL:SETF (%TRAINING-EXAMPLE.CONCEPT EXAMPLE) CONCEPT-NAME)
        (CL:SETF (%TRAINING-EXAMPLE.NAME EXAMPLE)
         (OBJECT-NAME
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES)) I)))
        (CL:SETF (%TRAINING-EXAMPLE.SCORE EXAMPLE) 1.0d0))
       (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
        KWD-MACHINE-LEARNING-ASSERT-TRUE))
      (CL:WHEN (CL:OR (FALSE? PROP) *CLOSED-WORLD-TRAINING-EXAMPLES*)
       (CL:PROGN (CL:SETQ EXAMPLE (NEW-TRAINING-EXAMPLE))
        (CL:SETF (%TRAINING-EXAMPLE.QUERY EXAMPLE) CONS-QUERY)
        (CL:SETF (%TRAINING-EXAMPLE.OUTPUT EXAMPLE) FALSE-WRAPPER)
        (CL:SETF (%TRAINING-EXAMPLE.CONCEPT EXAMPLE) CONCEPT-NAME)
        (CL:SETF (%TRAINING-EXAMPLE.NAME EXAMPLE)
         (OBJECT-NAME
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES)) I)))
        (CL:SETF (%TRAINING-EXAMPLE.SCORE EXAMPLE) 0.0d0))))
     (CL:WHEN (CL:NOT (CL:EQ EXAMPLE NULL))
      (CL:SETF (%TRAINING-EXAMPLE.MODULE EXAMPLE) *MODULE*)
      (CL:SETF (%TRAINING-EXAMPLE.TIMESTAMP EXAMPLE) -1)
      (CL:SETQ NUM-EXAMPLES (CL:1+ NUM-EXAMPLES))
      (PUSH *TRAINING-EXAMPLES* EXAMPLE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   NUM-EXAMPLES))

;;; (DEFUN (GENERATE-CLASSIFICATION-TRAINING-EXAMPLES INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:T) CL:FIXNUM)
  GENERATE-CLASSIFICATION-TRAINING-EXAMPLES))
(CL:DEFUN GENERATE-CLASSIFICATION-TRAINING-EXAMPLES (INSTANCES CONCEPT CREATE-SIGNATURE?)
  (CL:LET*
   ((NUM-INSTANCES (LENGTH INSTANCES)) (CONS-QUERY NIL)
    (NUM-EXAMPLES 0) (EXAMPLE NULL) (PROP NULL)
    (CLASSIFICATION-QUERY NIL) (QUERY NULL)
    (CONCEPT-NAME (INTERN-SYMBOL (%SURROGATE.SYMBOL-NAME CONCEPT))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-INSTANCES NUM-EXAMPLES))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- NUM-INSTANCES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:SETQ CONS-QUERY
      (CONS-LIST CONCEPT-NAME
       (OBJECT-NAME
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES)) I))))
     (CL:SETQ CLASSIFICATION-QUERY
      (CONS-LIST
       (INTERN-SYMBOL
        (CONCATENATE (%SYMBOL.SYMBOL-NAME CONCEPT-NAME)
         "-Classification"))
       (OBJECT-NAME
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES)) I))))
     (CL:SETQ PROP (CONCEIVE-FORMULA (COPY-CONS-TREE CONS-QUERY)))
     (CL:SETQ EXAMPLE NULL)
     (CL:IF (TRUE? PROP)
      (CL:PROGN
       (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
        KWD-MACHINE-LEARNING-RETRACT-TRUE)
       (CL:SETQ QUERY
        (MAKE-QUERY NIL (COPY-CONS-TREE CONS-QUERY) NIL NIL))
       (CL:WHEN (UNKNOWN-TRUTH-VALUE? (CALL-ASK QUERY))
        (CL:SETQ EXAMPLE (NEW-TRAINING-EXAMPLE))
        (CL:SETF (%TRAINING-EXAMPLE.QUERY EXAMPLE)
         CLASSIFICATION-QUERY)
        (CL:SETF (%TRAINING-EXAMPLE.OUTPUT EXAMPLE) TRUE-WRAPPER)
        (CL:SETF (%TRAINING-EXAMPLE.CONCEPT EXAMPLE) CONCEPT-NAME)
        (CL:SETF (%TRAINING-EXAMPLE.NAME EXAMPLE)
         (OBJECT-NAME
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES)) I)))
        (CL:SETF (%TRAINING-EXAMPLE.SCORE EXAMPLE) 1.0d0))
       (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
        KWD-MACHINE-LEARNING-ASSERT-TRUE))
      (CL:WHEN (CL:OR (FALSE? PROP) *CLOSED-WORLD-TRAINING-EXAMPLES*)
       (CL:PROGN (CL:SETQ EXAMPLE (NEW-TRAINING-EXAMPLE))
        (CL:SETF (%TRAINING-EXAMPLE.QUERY EXAMPLE)
         CLASSIFICATION-QUERY)
        (CL:SETF (%TRAINING-EXAMPLE.OUTPUT EXAMPLE) FALSE-WRAPPER)
        (CL:SETF (%TRAINING-EXAMPLE.CONCEPT EXAMPLE) CONCEPT-NAME)
        (CL:SETF (%TRAINING-EXAMPLE.NAME EXAMPLE)
         (OBJECT-NAME
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES)) I)))
        (CL:SETF (%TRAINING-EXAMPLE.SCORE EXAMPLE) 0.0d0))))
     (CL:WHEN (CL:NOT (CL:EQ EXAMPLE NULL))
      (CL:WHEN CREATE-SIGNATURE?
       (CL:SETF (%TRAINING-EXAMPLE.INPUT EXAMPLE)
        (CREATE-INPUT-SIGNATURE CLASSIFICATION-QUERY)))
      (CL:SETF (%TRAINING-EXAMPLE.MODULE EXAMPLE) *MODULE*)
      (CL:SETF (%TRAINING-EXAMPLE.TIMESTAMP EXAMPLE) -1)
      (CL:SETQ NUM-EXAMPLES (CL:1+ NUM-EXAMPLES))
      (PUSH *TRAINING-EXAMPLES* EXAMPLE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   NUM-EXAMPLES))

;;; (DEFUN GENERATE-REGRESSION-RULE-WO-SLOT ...)

(CL:DEFUN GENERATE-REGRESSION-RULE-WO-SLOT (CASES SLOT-NAME CLASS-NAME REALLY-BUILD-RULE)
  (CL:LET*
   ((NUM-CASES (LENGTH CASES))
    (KIND
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION CLASS-NAME)))
    (CASE-NAMES (NEW-LIST))
    (SLOT
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION SLOT-NAME)))
    (SLOT-VALUES (NEW-VECTOR NUM-CASES))
    (FUNCTION-VALUES? *DROP-FUNCTION-VALUES?*))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-CASES))
   (CL:SETQ *DROP-FUNCTION-VALUES?* CL:NIL)
   (CL:LET*
    ((CASE NULL) (VECTOR-000 CASES) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ CASE
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (OBJECT-NAME CASE) NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST CASE-NAMES) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST CASE-NAMES) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST CASE-NAMES)
         COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000) (CONS (OBJECT-NAME CASE) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET*
    ((CASE NULL) (VECTOR-001 CASES) (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)) (CASE-NAME NULL)
     (ITER-000 (%LIST.THE-CONS-LIST CASE-NAMES)) (I NULL-INTEGER)
     (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 I ITER-001))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:NOT (CL:EQ ITER-000 NIL)))
     DO
     (CL:SETQ CASE
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
       INDEX-001))
     (CL:SETQ CASE-NAME (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:LET* ((VAL (GET-SLOT-VALUE CASE SLOT)))
      (CL:LET
       ((SELF (%VECTOR.THE-ARRAY SLOT-VALUES)) (VALUE VAL)
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:WHEN (CL:NOT (CL:EQ VAL NULL))
       (SMART-UPDATE-PROPOSITION
        (CONS SLOT-NAME (CONS CASE-NAME (CONS VAL NIL)))
        KWD-MACHINE-LEARNING-RETRACT-TRUE)))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-000 (CL:1- NUM-CASES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-002)
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOT-VALUES)) I)
        NULL))
      (BUILD-CASE-FROM-INSTANCE
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY CASES)) I)
       KIND))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))))
   (CL:WHEN REALLY-BUILD-RULE
    (BUILD-CLASSIFICATION-RULE SLOT-NAME CLASS-NAME))
   (CL:SETQ *DROP-FUNCTION-VALUES?* FUNCTION-VALUES?)
   (CL:LET*
    ((VAL NULL) (VECTOR-002 SLOT-VALUES) (INDEX-002 0)
     (LENGTH-002 (LENGTH VECTOR-002)) (CASE-NAME NULL)
     (ITER-003 (%LIST.THE-CONS-LIST CASE-NAMES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-002 LENGTH-002) (CL:NOT (CL:EQ ITER-003 NIL)))
     DO
     (CL:SETQ VAL
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
       INDEX-002))
     (CL:SETQ CASE-NAME (%%VALUE ITER-003))
     (CL:WHEN (CL:NOT (CL:EQ VAL NULL))
      (SMART-UPDATE-PROPOSITION
       (CONS SLOT-NAME (CONS CASE-NAME (CONS VAL NIL)))
       KWD-MACHINE-LEARNING-ASSERT-TRUE))
     (CL:SETQ INDEX-002 (CL:1+ INDEX-002))
     (CL:SETQ ITER-003 (%%REST ITER-003))))))

;;; (DEFUN (GENERATE-REGRESSION-TRAINING-EXAMPLES INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM)
  GENERATE-REGRESSION-TRAINING-EXAMPLES))
(CL:DEFUN GENERATE-REGRESSION-TRAINING-EXAMPLES (INSTANCES SLOT)
  (CL:LET*
   ((NUM-INSTANCES (LENGTH INSTANCES))
    (PRED-NAME
     (INTERN-SYMBOL
      (CONCATENATE (%SURROGATE.SYMBOL-NAME SLOT) "-Classification")))
    (SLOT-VALUES (NEW-VECTOR NUM-INSTANCES)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-INSTANCES))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- NUM-INSTANCES)) (INST NULL)
     (VECTOR-000 INSTANCES) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000 INDEX-000
      LENGTH-000))
    (CL:LOOP WHILE
     (CL:AND (CL:<= ITER-000 UPPER-BOUND-000)
      (CL:< INDEX-000 LENGTH-000))
     DO (CL:SETQ I ITER-000)
     (CL:SETQ INST
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY SLOT-VALUES))
       (VALUE (GET-SLOT-VALUE INST SLOT)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (NORMALIZE-NUMBERS SLOT-VALUES)
   (CL:LET*
    ((I NULL-INTEGER) (ITER-001 0)
     (UPPER-BOUND-001 (CL:1- NUM-INSTANCES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO
     (CL:SETQ I ITER-001)
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOT-VALUES)) I)
        NULL))
      (CL:LET* ((EXAMPLE (NEW-TRAINING-EXAMPLE)))
       (CL:SETF (%TRAINING-EXAMPLE.QUERY EXAMPLE)
        (CONS PRED-NAME
         (CONS
          (LOGIC-SYMBOL
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES)) I))
          NIL)))
       (CL:SETF (%TRAINING-EXAMPLE.CONCEPT EXAMPLE)
        (INTERN-SYMBOL (%SURROGATE.SYMBOL-NAME SLOT)))
       (CL:SETF (%TRAINING-EXAMPLE.NAME EXAMPLE)
        (OBJECT-NAME
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES)) I)))
       (CL:SETF (%TRAINING-EXAMPLE.SCORE EXAMPLE)
        (%FLOAT-WRAPPER.WRAPPER-VALUE
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOT-VALUES))
          I)))
       (CL:SETF (%TRAINING-EXAMPLE.TIMESTAMP EXAMPLE) -1)
       (PUSH *TRAINING-EXAMPLES* EXAMPLE)))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   NUM-INSTANCES))

;;; (DEFUN (APPROXIMATE FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:DOUBLE-FLOAT) %APPROXIMATE))
(CL:DEFUN %APPROXIMATE (INST-NAME SLOT-NAME)
  (CL:SETQ INST-NAME (PERMANENTIFY INST-NAME))
  (CL:SETQ SLOT-NAME (PERMANENTIFY SLOT-NAME))
  (CL:LET*
   ((SLOT
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION SLOT-NAME))))
   (CL:IF (FLOAT-FUNCTION? SLOT)
    (GENERATE-SLOT-APPROXIMATION INST-NAME SLOT)
    (CL:PROGN
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
      "ERROR " SLOT-NAME " is not a function of type float or integer"
      EOL)
     0.0d0))))

(CL:DEFUN APPROXIMATE-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (%APPROXIMATE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS)))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CL:IF (CL:NOT (CL:= RESULT NULL-FLOAT)) (WRAP-FLOAT RESULT) NULL)))

(CL:DEFMACRO APPROXIMATE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/APPROXIMATE|)) (CL:MACRO-FUNCTION (CL:QUOTE APPROXIMATE)))

;;; (DEFUN (GENERATE-SLOT-APPROXIMATION FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:DOUBLE-FLOAT)
  GENERATE-SLOT-APPROXIMATION))
(CL:DEFUN GENERATE-SLOT-APPROXIMATION (INST-NAME SLOT)
  (CL:LET*
   ((PROBE (GET-INSTANCE INST-NAME))
    (CLASS
     (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE
      (LAST (GET-MOST-SPECIFIC-CLASSES PROBE))))
    (RULE-NAME
     (INTERN-SYMBOL
      (CONCATENATE (%SURROGATE.SYMBOL-NAME SLOT) "-Classification")))
    (INSTANCES (LISTIFY (ALL-CLASS-INSTANCES CLASS))) (MAX 0.0d0)
    (SCORE 0.0d0) (MIN 999999.0d0) (RANGE 0.0d0)
    (PROP (CONS RULE-NAME (CONS INST-NAME NIL))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT MAX SCORE MIN RANGE))
   (CL:LET*
    ((INSTANCE NULL) (ITER-000 (%LIST.THE-CONS-LIST INSTANCES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ INSTANCE (%%VALUE ITER-000))
     (CL:LET* ((VALUE (GET-SLOT-VALUE INSTANCE SLOT)))
      (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
       (CL:LET* ((FL-VALUE (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE)))
        (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT FL-VALUE))
        (CL:WHEN (CL:> FL-VALUE MAX)
         (CL:SETQ MAX (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE)))
        (CL:WHEN (CL:< FL-VALUE MIN) (CL:SETQ MIN FL-VALUE)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ RANGE (CL:- MAX MIN))
   (CL:SETQ SCORE
    (RETURN-PARTIAL-TRUTH
     (MAKE-QUERY NIL (COERCE-TO-TREE PROP) NIL NIL) CL:T))
   (CL:+ (CL:* SCORE RANGE) MIN)))

;;; (DEFUN (FLOAT-FUNCTION? BOOLEAN) ...)

(CL:DEFUN FLOAT-FUNCTION? (RELATION)
  (CL:LET* ((DES (%SURROGATE.SURROGATE-VALUE RELATION)))
   (CL:IF
    (CL:AND (FUNCTION-DESCRIPTION? DES)
     (CL:EQ (LAST (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES DES))
      SGT-MACHINE-LEARNING-STELLA-FLOAT))
    CL:T CL:NIL)))

;;; (DEFGLOBAL *MAX-STRUCTURE-DEPTH* ...)

(CL:DEFVAR *MAX-STRUCTURE-DEPTH* 3)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *MAX-STRUCTURE-DEPTH*))

;;; (DEFGLOBAL *DROP-FUNCTION-VALUES?* ...)

(CL:DEFVAR *DROP-FUNCTION-VALUES?* CL:T)

;;; (DEFUN SET-STRUCTURE-DEPTH ...)

(CL:DEFUN %SET-STRUCTURE-DEPTH (D)
  (CL:DECLARE (CL:TYPE CL:FIXNUM D))
  #+MCL
  (CL:CHECK-TYPE D CL:FIXNUM)
  (CL:SETQ *MAX-STRUCTURE-DEPTH* D))

(CL:DEFUN SET-STRUCTURE-DEPTH-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-STRUCTURE-DEPTH
   (%INTEGER-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-STRUCTURE-DEPTH (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-STRUCTURE-DEPTH|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-STRUCTURE-DEPTH)))

;;; (DEFGLOBAL *TABOO-OPERATORS* ...)

(CL:DEFVAR *TABOO-OPERATORS* NULL)

;;; (DEFUN ADD-TABOO-OPERATORS ...)

(CL:DEFUN %ADD-TABOO-OPERATORS (S)
  (INSERT-NEW *TABOO-OPERATORS* (SURROGATIFY S)))

(CL:DEFMACRO ADD-TABOO-OPERATORS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/ADD-TABOO-OPERATORS|)) (CL:MACRO-FUNCTION (CL:QUOTE ADD-TABOO-OPERATORS)))

;;; (DEFUN (GET-ASSERTION-STRUCTURE (LIST OF CONS)) ...)

(CL:DEFUN GET-ASSERTION-STRUCTURE (INST DEPTH)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
  #+MCL
  (CL:CHECK-TYPE DEPTH CL:FIXNUM)
  (CL:SETQ *VISITED-PROPOSITIONS* (NEW-LIST))
  (CL:SETQ *VISITED-INSTANCES* (NEW-LIST))
  (HELP-GET-ASSERTION-STRUCTURE INST DEPTH))

;;; (DEFUN (HELP-GET-ASSERTION-STRUCTURE (LIST OF CONS)) ...)

(CL:DEFUN HELP-GET-ASSERTION-STRUCTURE (INST DEPTH)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
  #+MCL
  (CL:CHECK-TYPE DEPTH CL:FIXNUM)
  (PUSH *VISITED-INSTANCES* INST)
  (CL:LET*
   ((HOME (%SYMBOL.HOME-CONTEXT INST)) (FACTS (NEW-LIST))
    (ANTECEDENT (NEW-LIST)) (CHILDREN NULL))
   (CL:LET* ((*MODULE* HOME) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:SETQ FACTS
     (ALL-FACTS-OF-INSTANCE (GET-INSTANCE INST) CL:NIL CL:NIL)))
   (CL:LET* ((FACT NULL) (ITER-000 (%LIST.THE-CONS-LIST FACTS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ FACT (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:NOT (MEMBER? *VISITED-PROPOSITIONS* FACT))
       (CL:OR (CL:EQ *TABOO-OPERATORS* NULL)
        (CL:NOT
         (MEMBER? *TABOO-OPERATORS* (%PROPOSITION.OPERATOR FACT)))))
      (PUSH *VISITED-PROPOSITIONS* FACT)
      (CL:LET*
       ((CONS-PROP (PROPOSITION-TO-CONS FACT)) (CONS-PROPS NIL))
       (CL:COND
        ((CL:EQ (%PROPOSITION.KIND FACT) KWD-MACHINE-LEARNING-ISA)
         (CL:SETQ CONS-PROPS (CONS CONS-PROP CONS-PROPS)))
        ((CL:< DEPTH *MAX-STRUCTURE-DEPTH*)
         (CL:COND
          ((CL:EQ (%PROPOSITION.KIND FACT)
            KWD-MACHINE-LEARNING-FUNCTION)
           (CL:SETQ CONS-PROPS (CONS CONS-PROP CONS-PROPS))
           (CL:WHEN
            (ISA? (LAST CONS-PROP)
             SGT-MACHINE-LEARNING-STELLA-NUMBER-WRAPPER)
            (CL:LET*
             ((SKOLEM-NAME
               (REVERSE (%%REST (REVERSE (COPY-CONS-TREE CONS-PROP)))))
              (SKOLEM-VALUE (LAST CONS-PROP)))
             (CL:SETQ CONS-PROPS
              (CONS
               (LIST* SYM-MACHINE-LEARNING-STELLA->=
                (COPY-CONS-TREE SKOLEM-NAME) (CONS SKOLEM-VALUE NIL))
               CONS-PROPS))
             (CL:SETQ CONS-PROPS
              (CONS
               (LIST* SYM-MACHINE-LEARNING-STELLA-=<
                (COPY-CONS-TREE SKOLEM-NAME) (CONS SKOLEM-VALUE NIL))
               CONS-PROPS)))))
          (CL:T
           (CL:WHEN
            (CL:NOT
             (CL:AND
              (CL:EQ (%%VALUE CONS-PROP) SYM-MACHINE-LEARNING-STELLA-=)
              (EQL? (%%VALUE (%%REST CONS-PROP))
               (%%VALUE (%%REST (%%REST CONS-PROP))))))
            (CL:SETQ CONS-PROPS (CONS CONS-PROP CONS-PROPS))))))
        (CL:T))
       (CL:WHEN (CL:NOT (CL:EQ CONS-PROPS NIL))
        (CL:LET* ((PROP NULL) (ITER-001 CONS-PROPS))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ PROP (%%VALUE ITER-001)) (PUSH ANTECEDENT PROP)
          (CL:SETQ ITER-001 (%%REST ITER-001))))
        (CL:LET* ((ELE NULL) (ITER-002 (%%REST CONS-PROP)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
          (CL:SETQ ELE (%%VALUE ITER-002))
          (CL:WHEN
           (CL:AND (ISA? ELE SGT-MACHINE-LEARNING-STELLA-SYMBOL)
            (CL:NOT (MEMBER? *VISITED-INSTANCES* ELE))
            (CL:< DEPTH *MAX-STRUCTURE-DEPTH*))
           (CL:IF (CL:EQ CHILDREN NULL)
            (CL:SETQ CHILDREN
             (HELP-GET-ASSERTION-STRUCTURE ELE (CL:1+ DEPTH)))
            (CL:SETQ CHILDREN
             (CONCATENATE
              (HELP-GET-ASSERTION-STRUCTURE ELE (CL:1+ DEPTH))
              CHILDREN))))
          (CL:SETQ ITER-002 (%%REST ITER-002)))))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:IF (CL:EQ CHILDREN NULL) ANTECEDENT
    (CONCATENATE ANTECEDENT CHILDREN))))

;;; (DEFUN COLLECT-FACTS-IN-EXAMPLES ...)

(CL:DEFUN COLLECT-FACTS-IN-EXAMPLES (EXAMPLES)
  (CL:LET* ((PROP NULL))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (CL:EQ (%TRAINING-EXAMPLE.MODULE EXAMPLE) NULL))
      (CHANGE-MODULE (%TRAINING-EXAMPLE.MODULE EXAMPLE)))
     (CL:SETQ PROP
      (CONCEIVE-FORMULA (%TRAINING-EXAMPLE.QUERY EXAMPLE)))
     (CL:WHEN (TRUE? PROP)
      (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
       KWD-MACHINE-LEARNING-RETRACT-TRUE)
      (CL:SETF (%TRAINING-EXAMPLE.FACTS EXAMPLE)
       (CONSIFY
        (GET-ASSERTION-STRUCTURE (%TRAINING-EXAMPLE.NAME EXAMPLE) 1)))
      (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
       KWD-MACHINE-LEARNING-ASSERT-TRUE))
     (CL:WHEN (FALSE? PROP)
      (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
       KWD-MACHINE-LEARNING-RETRACT-FALSE)
      (CL:SETF (%TRAINING-EXAMPLE.FACTS EXAMPLE)
       (CONSIFY
        (GET-ASSERTION-STRUCTURE (%TRAINING-EXAMPLE.NAME EXAMPLE) 1)))
      (HELP-UPDATE-TOP-LEVEL-PROPOSITION PROP
       KWD-MACHINE-LEARNING-ASSERT-FALSE))
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

;;; (DEFUN (OLD-RECURSIVE-BUILD-ANTECEDENT CONS) ...)

(CL:DEFUN OLD-RECURSIVE-BUILD-ANTECEDENT (INST DEPTH)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
  #+MCL
  (CL:CHECK-TYPE DEPTH CL:FIXNUM)
  (PUSH *VISITED-INSTANCES* INST)
  (CL:LET*
   ((HOME (%SYMBOL.HOME-CONTEXT INST)) (FACTS (NEW-LIST))
    (ANTECEDENT NIL) (CHILDREN NIL))
   (CL:LET* ((*MODULE* HOME) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:SETQ FACTS
     (ALL-FACTS-OF-INSTANCE (GET-INSTANCE INST) CL:NIL CL:NIL)))
   (CL:LET* ((FACT NULL) (ITER-000 (%LIST.THE-CONS-LIST FACTS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ FACT (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:NOT (MEMBER? *VISITED-PROPOSITIONS* FACT))
       (CL:NOT
        (MEMBER? *TABOO-OPERATORS* (%PROPOSITION.OPERATOR FACT))))
      (PUSH *VISITED-PROPOSITIONS* FACT)
      (CL:LET* ((CONS-PROP (PROPOSITION-TO-CONS FACT)))
       (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND FACT)))
        (CL:COND
         ((CL:EQ TEST-VALUE-000 KWD-MACHINE-LEARNING-FUNCTION)
          (CL:IF *DROP-FUNCTION-VALUES?*
           (CL:SETQ CONS-PROP
            (LIST* SYM-MACHINE-LEARNING-STELLA-=
             (REVERSE (%%REST (REVERSE CONS-PROP))) NIL))
           (CL:SETQ CONS-PROP
            (LIST* SYM-MACHINE-LEARNING-STELLA-AND CONS-PROP NIL))))
         ((CL:EQ TEST-VALUE-000 KWD-MACHINE-LEARNING-ISA)
          (CL:SETQ CONS-PROP
           (LIST* SYM-MACHINE-LEARNING-STELLA-AND CONS-PROP NIL)))
         (CL:T
          (CL:IF (CL:< DEPTH *MAX-STRUCTURE-DEPTH*)
           (CL:SETQ CONS-PROP
            (LIST* SYM-MACHINE-LEARNING-STELLA-AND CONS-PROP NIL))
           (CL:SETQ CONS-PROP NIL)))))
       (CL:WHEN (CL:NOT (CL:EQ CONS-PROP NIL))
        (CL:SETQ ANTECEDENT (CONS CONS-PROP ANTECEDENT))
        (CL:LET*
         ((ELE NULL) (ITER-001 (%%REST (%%VALUE (%%REST CONS-PROP)))))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ ELE (%%VALUE ITER-001))
          (CL:WHEN
           (CL:AND (ISA? ELE SGT-MACHINE-LEARNING-STELLA-SYMBOL)
            (CL:NOT (MEMBER? *VISITED-INSTANCES* ELE))
            (CL:< DEPTH *MAX-STRUCTURE-DEPTH*))
           (CL:SETQ CHILDREN
            (CONCATENATE
             (OLD-RECURSIVE-BUILD-ANTECEDENT ELE (CL:1+ DEPTH))
             CHILDREN)))
          (CL:SETQ ITER-001 (%%REST ITER-001)))))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:IF (CL:EQ CHILDREN NIL) ANTECEDENT
    (CONCATENATE ANTECEDENT CHILDREN))))

;;; (DEFUN (GET-ARGUMENT-BINDING OBJECT) ...)

(CL:DEFUN GET-ARGUMENT-BINDING (ARG)
  (CL:LET* ((BIND (ARGUMENT-BOUND-TO ARG)))
   (CL:IF (CL:EQ BIND NULL) (INTERN-SYMBOL (GET-SKOLEM-PRINT-NAME ARG))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE BIND)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000
        SGT-MACHINE-LEARNING-LOGIC-DESCRIPTION)
       (CL:PROGN (NATIVE-RELATION BIND)))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-MACHINE-LEARNING-LOGIC-SKOLEM)
       (CL:PROGN
        (CL:COND
         ((CL:NOT (CL:EQ (%SKOLEM.DEFINING-PROPOSITION BIND) NULL))
          (PROPOSITION-TO-CONS (%SKOLEM.DEFINING-PROPOSITION BIND)))
         ((STRING-EQL? (GET-SKOLEM-PRINT-NAME BIND) "ANONYMOUS")
          (INTERN-SYMBOL (GET-SKOLEM-PRINT-NAME ARG)))
         (CL:T BIND))))
      ((SUBTYPE-OF? TEST-VALUE-000
        SGT-MACHINE-LEARNING-LOGIC-LOGIC-OBJECT)
       (CL:PROGN
        (INTERN-SYMBOL
         (%SURROGATE.SYMBOL-NAME
          (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE BIND)))))
      (CL:T BIND))))))

;;; (DEFUN (CONSIFY-ARGUMENT OBJECT) ...)

(CL:DEFUN CONSIFY-ARGUMENT (ARG)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-MACHINE-LEARNING-LOGIC-PROPOSITION)
     (CL:PROGN (PROPOSITION-TO-CONS ARG)))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-MACHINE-LEARNING-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN
      (CL:IF (CL:EQ *QUERYITERATOR* NULL)
       (INTERN-SYMBOL (GET-SKOLEM-PRINT-NAME ARG))
       (GET-ARGUMENT-BINDING ARG))))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-MACHINE-LEARNING-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (INTERN-SYMBOL
       (%SURROGATE.SYMBOL-NAME
        (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE ARG)))))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-MACHINE-LEARNING-LOGIC-DESCRIPTION)
     (CL:PROGN (CL:ERROR (NEW-LOGIC-EXCEPTION "Can't consify"))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (INTERN-SYMBOL (%SURROGATE.SYMBOL-NAME ARG))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-MACHINE-LEARNING-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:IF
       (CL:NOT
        (CL:EQ
         (ACCESS-IN-CONTEXT (%SKOLEM.VARIABLE-VALUE ARG)
          (%SKOLEM.HOME-CONTEXT ARG) CL:NIL)
         NULL))
       (CONSIFY-ARGUMENT
        (ACCESS-IN-CONTEXT (%SKOLEM.VARIABLE-VALUE ARG)
         (%SKOLEM.HOME-CONTEXT ARG) CL:NIL))
       (CL:IF (CL:NOT (CL:EQ (%SKOLEM.DEFINING-PROPOSITION ARG) NULL))
        (CL:LET*
         ((PROP (%SKOLEM.DEFINING-PROPOSITION ARG))
          (SK-ARGS (%PROPOSITION.ARGUMENTS PROP)) (CONS-ARGS NIL))
         (CL:LET*
          ((I NULL-INTEGER) (ITER-000 0)
           (UPPER-BOUND-000 (CL:- (LENGTH SK-ARGS) 2))
           (COLLECT-000 NULL))
          (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
          (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
           (CL:SETQ I ITER-000)
           (CL:IF (CL:EQ COLLECT-000 NULL)
            (CL:PROGN
             (CL:SETQ COLLECT-000
              (CONS
               (CONSIFY-ARGUMENT
                (CL:AREF
                 (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SK-ARGS))
                 I))
               NIL))
             (CL:IF (CL:EQ CONS-ARGS NIL)
              (CL:SETQ CONS-ARGS COLLECT-000)
              (ADD-CONS-TO-END-OF-CONS-LIST CONS-ARGS COLLECT-000)))
            (CL:PROGN
             (CL:SETF (%%REST COLLECT-000)
              (CONS
               (CONSIFY-ARGUMENT
                (CL:AREF
                 (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SK-ARGS))
                 I))
               NIL))
             (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
           (CL:SETQ ITER-000 (CL:1+ ITER-000))))
         (CONS (INTERN-SYMBOL (STRINGIFIED-KIF-OPERATOR PROP))
          CONS-ARGS))
        ARG))))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-MACHINE-LEARNING-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (INTERN-SYMBOL
       (%SURROGATE.SYMBOL-NAME
        (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE ARG)))))
    (CL:T ARG))))

;;; (DEFUN (PROPOSITION-TO-CONS CONS) ...)

(CL:DEFUN PROPOSITION-TO-CONS (PROP)
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROP))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ RESULT (CONS (CONSIFY-ARGUMENT ARG) RESULT))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROP)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-MACHINE-LEARNING-IN)
      (CL:RETURN-FROM PROPOSITION-TO-CONS RESULT))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-MACHINE-LEARNING-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-MACHINE-LEARNING-FUNCTION))
      (CL:SETQ RESULT
       (CONS (SURROGATE-TO-SYMBOL (%PROPOSITION.OPERATOR PROP))
        (REVERSE RESULT))))
     ((CL:EQ TEST-VALUE-000 KWD-MACHINE-LEARNING-EQUIVALENT)
      (CL:SETQ RESULT
       (CONS SYM-MACHINE-LEARNING-STELLA-= (REVERSE RESULT))))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-MACHINE-LEARNING-FORALL)
       (CL:EQ TEST-VALUE-000 KWD-MACHINE-LEARNING-EXISTS))
      (CL:IF (CL:NOT (CL:EQ (%%REST RESULT) NIL))
       (CL:SETQ RESULT
        (CONS-LIST SYM-MACHINE-LEARNING-STELLA-OR
         (CONS-LIST SYM-MACHINE-LEARNING-STELLA-NOT
          (%%VALUE (%%REST RESULT)))
         (%%VALUE RESULT)))
       (CL:SETQ RESULT (%%VALUE RESULT)))
      (CL:LET* ((BINDINGS NIL))
       (CL:LET*
        ((IO NULL)
         (VECTOR-001
          (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
           SYM-MACHINE-LEARNING-LOGIC-IO-VARIABLES NULL))
         (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
        (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
         (CL:SETQ IO
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
           INDEX-001))
         (CL:WHEN (CL:EQ (ARGUMENT-BOUND-TO IO) NULL)
          (CL:SETQ BINDINGS
           (CONS
            (CONS-LIST (INTERN-SYMBOL (GET-SKOLEM-PRINT-NAME IO))
             (INTERN-SYMBOL
              (%SURROGATE.SYMBOL-NAME (LOGICAL-TYPE IO))))
            BINDINGS)))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
       (CL:WHEN (CL:NOT (CL:EQ BINDINGS NIL))
        (CL:SETQ RESULT
         (CONS-LIST
          (INTERN-SYMBOL
           (%KEYWORD.SYMBOL-NAME (%PROPOSITION.KIND PROP)))
          BINDINGS RESULT)))))
     (CL:T
      (CL:SETQ RESULT
       (CONS
        (INTERN-SYMBOL
         (%SURROGATE.SYMBOL-NAME (%PROPOSITION.OPERATOR PROP)))
        (REVERSE RESULT))))))
   (CL:IF (FALSE? PROP)
    (LIST* SYM-MACHINE-LEARNING-STELLA-NOT RESULT NIL) RESULT)))

;;; (DEFUN THINGIFY-UNTYPED-INSTANCES ...)

(CL:DEFUN THINGIFY-UNTYPED-INSTANCES ()
  (CL:LET* ((ITEM NULL) (ITER-000 (ALL-NAMED-INSTANCES *MODULE* CL:T)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ ITEM (%ITERATOR.VALUE ITER-000))
    (CL:WHEN (CL:EQ (ALL-ASSERTED-TYPES ITEM) NIL)
     (ASSERT-ISA-PROPOSITION ITEM SGT-MACHINE-LEARNING-STELLA-THING)))))

;;; (DEFUN PRINT-FACTS ...)

(CL:DEFUN %PRINT-FACTS (INSTANCEREF)
  (CL:LET* ((INSTANCE (COERCE-TO-INSTANCE INSTANCEREF NULL)))
   (CL:LET*
    ((FACT NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST
       (ALL-FACTS-OF-INSTANCE INSTANCE CL:NIL CL:NIL))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ FACT (%%VALUE ITER-000))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      FACT EOL)
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

(CL:DEFMACRO PRINT-FACTS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/PRINT-FACTS|)) (CL:MACRO-FUNCTION (CL:QUOTE PRINT-FACTS)))

(CL:DEFUN HELP-STARTUP-MACHINE-LEARNING1 ()
  (CL:PROGN
   (CL:SETQ SGT-MACHINE-LEARNING-LOGIC-TRAINING-EXAMPLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRAINING-EXAMPLE" NULL 1))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-CONCEPT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEPT" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-STELLA-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCORE" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-INPUT-FEATURES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-FEATURES" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-INPUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-FACTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FACTS" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-NN-HIDDEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NN-HIDDEN" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-OUTPUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-TEMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TEMP" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-CACHED-SOLUTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHED-SOLUTION" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMESTAMP" NULL 0))
   (CL:SETQ
    SYM-MACHINE-LEARNING-LOGIC-SET-CLOSED-WORLD-TRAINING-EXAMPLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "SET-CLOSED-WORLD-TRAINING-EXAMPLES" NULL 0))
   (CL:SETQ KWD-MACHINE-LEARNING-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-MACHINE-LEARNING-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-ADD-TRAINING-EXAMPLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD-TRAINING-EXAMPLE" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-ADD-TRAINING-EXAMPLE-IN-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD-TRAINING-EXAMPLE-IN-MODULE"
     NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-ADD-TESTING-EXAMPLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD-TESTING-EXAMPLE" NULL 0))
   (CL:SETQ KWD-MACHINE-LEARNING-MATCH-MODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MATCH-MODE" NULL 2))
   (CL:SETQ KWD-MACHINE-LEARNING-BASIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BASIC" NULL 2))
   (CL:SETQ KWD-MACHINE-LEARNING-MAXIMIZE-SCORE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAXIMIZE-SCORE?" NULL 2))
   (CL:SETQ KWD-MACHINE-LEARNING-RETRACT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-TRUE" NULL 2))
   (CL:SETQ KWD-MACHINE-LEARNING-ASSERT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
   (CL:SETQ KWD-MACHINE-LEARNING-RETRACT-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-FALSE" NULL 2))
   (CL:SETQ KWD-MACHINE-LEARNING-ASSERT-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-FALSE" NULL 2))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-DEFRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFRELATION" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-?P
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?P" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-DEFRULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFRULE" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-STELLA-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-MACHINE-LEARNING-STELLA-=>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=>"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-MACHINE-LEARNING-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-?Y
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?Y" NULL 0))
   (CL:SETQ KWD-MACHINE-LEARNING-DONT-OPTIMIZE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-OPTIMIZE?" NULL 2))
   (CL:SETQ SYM-MACHINE-LEARNING-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-MACHINE-LEARNING-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-TEST-DOMAIN-THEORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TEST-DOMAIN-THEORY" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-APPROXIMATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "APPROXIMATE" NULL 0))
   (CL:SETQ SGT-MACHINE-LEARNING-STELLA-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-SET-STRUCTURE-DEPTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-STRUCTURE-DEPTH" NULL 0))
   (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-ADD-TABOO-OPERATORS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD-TABOO-OPERATORS" NULL 0))
   (CL:SETQ KWD-MACHINE-LEARNING-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ SGT-MACHINE-LEARNING-STELLA-NUMBER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-MACHINE-LEARNING-STELLA->=
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">="
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-MACHINE-LEARNING-STELLA-=<
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=<"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-MACHINE-LEARNING-STELLA-=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "="
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-MACHINE-LEARNING-STELLA-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-MACHINE-LEARNING-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SGT-MACHINE-LEARNING-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SGT-MACHINE-LEARNING-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SGT-MACHINE-LEARNING-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SGT-MACHINE-LEARNING-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-MACHINE-LEARNING-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ KWD-MACHINE-LEARNING-IN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 2))
   (CL:SETQ KWD-MACHINE-LEARNING-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-MACHINE-LEARNING-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ KWD-MACHINE-LEARNING-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ KWD-MACHINE-LEARNING-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))))

(CL:DEFUN HELP-STARTUP-MACHINE-LEARNING2 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "SET-CLOSED-WORLD-TRAINING-EXAMPLES"
    "(DEFUN SET-CLOSED-WORLD-TRAINING-EXAMPLES ((B BOOLEAN)) :COMMAND? TRUE)"
    (CL:FUNCTION %SET-CLOSED-WORLD-TRAINING-EXAMPLES)
    (CL:FUNCTION SET-CLOSED-WORLD-TRAINING-EXAMPLES-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "PRINT-TRAINING-EXAMPLE"
    "(DEFUN PRINT-TRAINING-EXAMPLE ((EXAMPLE TRAINING-EXAMPLE)))"
    (CL:FUNCTION PRINT-TRAINING-EXAMPLE) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-TRAINING-EXAMPLE"
    "(DEFUN ADD-TRAINING-EXAMPLE ((FORM CONS) (SCORE PARTIAL-MATCH-SCORE)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE :DOCUMENTATION \"Add a query and score pair to the master list of 
  training examples\")" (CL:FUNCTION %ADD-TRAINING-EXAMPLE)
    (CL:FUNCTION ADD-TRAINING-EXAMPLE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "ADD-TRAINING-EXAMPLE-IN-MODULE"
    "(DEFUN ADD-TRAINING-EXAMPLE-IN-MODULE ((FORM CONS) (SCORE PARTIAL-MATCH-SCORE) (MODULE SYMBOL)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE)"
    (CL:FUNCTION %ADD-TRAINING-EXAMPLE-IN-MODULE)
    (CL:FUNCTION ADD-TRAINING-EXAMPLE-IN-MODULE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "ADD-TESTING-EXAMPLE"
    "(DEFUN ADD-TESTING-EXAMPLE ((FORM CONS) (SCORE PARTIAL-MATCH-SCORE)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE :DOCUMENTATION \"Add a query and score pair to the master list of 
  testing examples\")" (CL:FUNCTION %ADD-TESTING-EXAMPLE)
    (CL:FUNCTION ADD-TESTING-EXAMPLE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "CLEAR-TRAINING-EXAMPLES"
    "(DEFUN CLEAR-TRAINING-EXAMPLES () :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION CLEAR-TRAINING-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "SHUFFLE-LIST"
    "(DEFUN SHUFFLE-LIST ((CARDS LIST)))" (CL:FUNCTION SHUFFLE-LIST)
    NULL)
   (DEFINE-FUNCTION-OBJECT "SHUFFLE-VECTOR"
    "(DEFUN SHUFFLE-VECTOR ((CARDS VECTOR)))"
    (CL:FUNCTION SHUFFLE-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "SAVE-TRAINING-EXAMPLES"
    "(DEFUN SAVE-TRAINING-EXAMPLES () :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION SAVE-TRAINING-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-PROPOSITIONAL-TRAINING-EXAMPLES"
    "(DEFUN (CREATE-PROPOSITIONAL-TRAINING-EXAMPLES INTEGER) ((EXAMPLES (LIST OF TRAINING-EXAMPLE)) (NAME-FILE OUTPUT-FILE-STREAM) (DATA-FILE OUTPUT-FILE-STREAM)))"
    (CL:FUNCTION CREATE-PROPOSITIONAL-TRAINING-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "FILL-IN-EXAMPLE-OUTPUTS"
    "(DEFUN FILL-IN-EXAMPLE-OUTPUTS ((EXAMPLES (LIST OF TRAINING-EXAMPLE)) (SLOT-NAME SYMBOL)))"
    (CL:FUNCTION FILL-IN-EXAMPLE-OUTPUTS) NULL)
   (DEFINE-FUNCTION-OBJECT "DETECT-NOISE-IN-TRAINING-EXAMPLES"
    "(DEFUN DETECT-NOISE-IN-TRAINING-EXAMPLES ((EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION DETECT-NOISE-IN-TRAINING-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-CLASSIFICATION-RELATIONS"
    "(DEFUN (GET-CLASSIFICATION-RELATIONS (LIST OF PROPOSITION)) ((CONS-QUERY CONS)))"
    (CL:FUNCTION GET-CLASSIFICATION-RELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-INPUT-SIGNATURE"
    "(DEFUN (CREATE-INPUT-SIGNATURE (VECTOR OF INTEGER-WRAPPER)) ((CONS-QUERY CONS)))"
    (CL:FUNCTION CREATE-INPUT-SIGNATURE) NULL)
   (DEFINE-FUNCTION-OBJECT "GENERATE-CLASSIFICATION-RULE"
    "(DEFUN GENERATE-CLASSIFICATION-RULE ((INSTANCES (VECTOR OF LOGIC-OBJECT)) (CONCEPT-NAME SYMBOL) (CLASS-NAME SYMBOL) (BUILD-RULE? BOOLEAN)))"
    (CL:FUNCTION GENERATE-CLASSIFICATION-RULE) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-CLASSIFICATION-RULE"
    "(DEFUN BUILD-CLASSIFICATION-RULE ((KIND SYMBOL) (CLASS-NAME SYMBOL)))"
    (CL:FUNCTION BUILD-CLASSIFICATION-RULE) NULL)
   (DEFINE-FUNCTION-OBJECT
    "OLD-GENERATE-CLASSIFICATION-TRAINING-EXAMPLES"
    "(DEFUN (OLD-GENERATE-CLASSIFICATION-TRAINING-EXAMPLES INTEGER) ((INSTANCES (VECTOR OF LOGIC-OBJECT)) (CONCEPT SURROGATE)))"
    (CL:FUNCTION OLD-GENERATE-CLASSIFICATION-TRAINING-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-DOMAIN-THEORY"
    "(DEFUN TEST-DOMAIN-THEORY ((RELATION-NAME SYMBOL) (CLASS-NAME SYMBOL)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE)"
    (CL:FUNCTION %TEST-DOMAIN-THEORY) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-THEORY-OVER-EXAMPLES"
    "(DEFUN (TEST-THEORY-OVER-EXAMPLES FLOAT) ((EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION TEST-THEORY-OVER-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "GENERATE-TRAINING-EXAMPLES"
    "(DEFUN (GENERATE-TRAINING-EXAMPLES INTEGER) ((INSTANCES (VECTOR OF LOGIC-OBJECT)) (CONCEPT SURROGATE)))"
    (CL:FUNCTION GENERATE-TRAINING-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "GENERATE-CLASSIFICATION-TRAINING-EXAMPLES"
    "(DEFUN (GENERATE-CLASSIFICATION-TRAINING-EXAMPLES INTEGER) ((INSTANCES (VECTOR OF LOGIC-OBJECT)) (CONCEPT SURROGATE) (CREATE-SIGNATURE? BOOLEAN)))"
    (CL:FUNCTION GENERATE-CLASSIFICATION-TRAINING-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "GENERATE-REGRESSION-RULE-WO-SLOT"
    "(DEFUN GENERATE-REGRESSION-RULE-WO-SLOT ((CASES (VECTOR OF LOGIC-OBJECT)) (SLOT-NAME SYMBOL) (CLASS-NAME SYMBOL) (REALLY-BUILD-RULE BOOLEAN)))"
    (CL:FUNCTION GENERATE-REGRESSION-RULE-WO-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "GENERATE-REGRESSION-TRAINING-EXAMPLES"
    "(DEFUN (GENERATE-REGRESSION-TRAINING-EXAMPLES INTEGER) ((INSTANCES (VECTOR OF LOGIC-OBJECT)) (SLOT SURROGATE)))"
    (CL:FUNCTION GENERATE-REGRESSION-TRAINING-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "APPROXIMATE"
    "(DEFUN (APPROXIMATE FLOAT) ((INST-NAME SYMBOL) (SLOT-NAME SYMBOL)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE)"
    (CL:FUNCTION %APPROXIMATE)
    (CL:FUNCTION APPROXIMATE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "GENERATE-SLOT-APPROXIMATION"
    "(DEFUN (GENERATE-SLOT-APPROXIMATION FLOAT) ((INST-NAME SYMBOL) (SLOT SURROGATE)))"
    (CL:FUNCTION GENERATE-SLOT-APPROXIMATION) NULL)
   (DEFINE-FUNCTION-OBJECT "FLOAT-FUNCTION?"
    "(DEFUN (FLOAT-FUNCTION? BOOLEAN) ((RELATION SURROGATE)))"
    (CL:FUNCTION FLOAT-FUNCTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-STRUCTURE-DEPTH"
    "(DEFUN SET-STRUCTURE-DEPTH ((D INTEGER)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-STRUCTURE-DEPTH)
    (CL:FUNCTION SET-STRUCTURE-DEPTH-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "ADD-TABOO-OPERATORS"
    "(DEFUN ADD-TABOO-OPERATORS ((S SYMBOL)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %ADD-TABOO-OPERATORS) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-ASSERTION-STRUCTURE"
    "(DEFUN (GET-ASSERTION-STRUCTURE (LIST OF CONS)) ((INST SYMBOL) (DEPTH INTEGER)))"
    (CL:FUNCTION GET-ASSERTION-STRUCTURE) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-GET-ASSERTION-STRUCTURE"
    "(DEFUN (HELP-GET-ASSERTION-STRUCTURE (LIST OF CONS)) ((INST SYMBOL) (DEPTH INTEGER)))"
    (CL:FUNCTION HELP-GET-ASSERTION-STRUCTURE) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-FACTS-IN-EXAMPLES"
    "(DEFUN COLLECT-FACTS-IN-EXAMPLES ((EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION COLLECT-FACTS-IN-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "OLD-RECURSIVE-BUILD-ANTECEDENT"
    "(DEFUN (OLD-RECURSIVE-BUILD-ANTECEDENT CONS) ((INST SYMBOL) (DEPTH INTEGER)))"
    (CL:FUNCTION OLD-RECURSIVE-BUILD-ANTECEDENT) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-ARGUMENT-BINDING"
    "(DEFUN (GET-ARGUMENT-BINDING OBJECT) ((ARG OBJECT)))"
    (CL:FUNCTION GET-ARGUMENT-BINDING) NULL)
   (DEFINE-FUNCTION-OBJECT "CONSIFY-ARGUMENT"
    "(DEFUN (CONSIFY-ARGUMENT OBJECT) ((ARG OBJECT)))"
    (CL:FUNCTION CONSIFY-ARGUMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "PROPOSITION-TO-CONS"
    "(DEFUN (PROPOSITION-TO-CONS CONS) ((PROP PROPOSITION)))"
    (CL:FUNCTION PROPOSITION-TO-CONS) NULL)
   (DEFINE-FUNCTION-OBJECT "THINGIFY-UNTYPED-INSTANCES"
    "(DEFUN THINGIFY-UNTYPED-INSTANCES () :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION THINGIFY-UNTYPED-INSTANCES) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-FACTS"
    "(DEFUN PRINT-FACTS ((INSTANCEREF OBJECT)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %PRINT-FACTS) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-MACHINE-LEARNING"
    "(DEFUN STARTUP-MACHINE-LEARNING () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-MACHINE-LEARNING) NULL)
   (CL:LET*
    ((FUNCTION
      (LOOKUP-FUNCTION
       SYM-MACHINE-LEARNING-LOGIC-STARTUP-MACHINE-LEARNING)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-MACHINE-LEARNING-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupMachineLearning") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-MACHINE-LEARNING ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-MACHINE-LEARNING1)
    (CL:SETQ SYM-MACHINE-LEARNING-STELLA-OR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OR"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0))
    (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-IO-VARIABLES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
    (CL:SETQ SGT-MACHINE-LEARNING-STELLA-THING
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
      (GET-STELLA-MODULE "/STELLA" CL:T) 1))
    (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-PRINT-FACTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-FACTS" NULL 0))
    (CL:SETQ SYM-MACHINE-LEARNING-LOGIC-STARTUP-MACHINE-LEARNING
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-MACHINE-LEARNING" NULL
      0))
    (CL:SETQ SYM-MACHINE-LEARNING-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *TRAINING-EXAMPLES* (NEW-LIST))
    (CL:SETQ *TESTING-EXAMPLES* (NEW-LIST))
    (CL:SETQ *TABOO-OPERATORS* (NEW-LIST)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TRAINING-EXAMPLE"
        "(DEFCLASS TRAINING-EXAMPLE (STANDARD-OBJECT) :DOCUMENTATION \"A single example of a proposition paired with the score
  that should be returned and the module it should be evaluated in.\" :SLOTS ((QUERY :TYPE CONS) (CONCEPT :TYPE SYMBOL) (NAME :TYPE SYMBOL) (SCORE :TYPE PARTIAL-MATCH-SCORE) (MODULE :TYPE MODULE) (INPUT-FEATURES :TYPE LIST) (INPUT :TYPE VECTOR) (FACTS :TYPE (CONS OF CONS)) (NN-HIDDEN :TYPE (VECTOR OF FLOAT-WRAPPER)) (OUTPUT :TYPE OBJECT) (TEMP :TYPE FLOAT) (CACHED-SOLUTION :TYPE OBJECT) (TIMESTAMP :TYPE TIMESTAMP)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRAINING-EXAMPLE))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TRAINING-EXAMPLE-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (HELP-STARTUP-MACHINE-LEARNING2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TRAINING-EXAMPLES* (LIST OF TRAINING-EXAMPLE) (NEW LIST))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TESTING-EXAMPLES* (LIST OF TRAINING-EXAMPLE) (NEW LIST))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CLOSED-WORLD-TRAINING-EXAMPLES* BOOLEAN TRUE)")
    (REGISTER-NATIVE-NAME
     SYM-MACHINE-LEARNING-LOGIC-SET-CLOSED-WORLD-TRAINING-EXAMPLES
     KWD-MACHINE-LEARNING-COMMON-LISP KWD-MACHINE-LEARNING-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-MACHINE-LEARNING-LOGIC-ADD-TRAINING-EXAMPLE
     KWD-MACHINE-LEARNING-COMMON-LISP KWD-MACHINE-LEARNING-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-MACHINE-LEARNING-LOGIC-ADD-TRAINING-EXAMPLE-IN-MODULE
     KWD-MACHINE-LEARNING-COMMON-LISP KWD-MACHINE-LEARNING-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-MACHINE-LEARNING-LOGIC-ADD-TESTING-EXAMPLE
     KWD-MACHINE-LEARNING-COMMON-LISP KWD-MACHINE-LEARNING-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-MACHINE-LEARNING-LOGIC-TEST-DOMAIN-THEORY
     KWD-MACHINE-LEARNING-COMMON-LISP KWD-MACHINE-LEARNING-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-MACHINE-LEARNING-LOGIC-APPROXIMATE
     KWD-MACHINE-LEARNING-COMMON-LISP KWD-MACHINE-LEARNING-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAX-STRUCTURE-DEPTH* INTEGER 3)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DROP-FUNCTION-VALUES?* BOOLEAN TRUE)")
    (REGISTER-NATIVE-NAME
     SYM-MACHINE-LEARNING-LOGIC-SET-STRUCTURE-DEPTH
     KWD-MACHINE-LEARNING-COMMON-LISP KWD-MACHINE-LEARNING-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TABOO-OPERATORS* (LIST OF SURROGATE) (NEW (LIST OF SURROGATE)))")
    (REGISTER-NATIVE-NAME
     SYM-MACHINE-LEARNING-LOGIC-ADD-TABOO-OPERATORS
     KWD-MACHINE-LEARNING-COMMON-LISP KWD-MACHINE-LEARNING-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-MACHINE-LEARNING-LOGIC-PRINT-FACTS
     KWD-MACHINE-LEARNING-COMMON-LISP KWD-MACHINE-LEARNING-FUNCTION))))
