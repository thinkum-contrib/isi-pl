;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; whynot.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-WHYNOT-LOGIC-WHYNOT-PARTIAL-MATCH NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-UNKNOWN-GOAL-CUTOFF NULL)
(CL:DEFVAR SGT-WHYNOT-LOGIC-WHYNOT-DEEP-PARTIAL-MATCH NULL)
(CL:DEFVAR KWD-WHYNOT-AND NULL)
(CL:DEFVAR SYM-WHYNOT-STELLA-ARGUMENTS NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-JUSTIFICATION NULL)
(CL:DEFVAR SGT-WHYNOT-LOGIC-M-WHYNOT-PARTIAL-MATCH.NUMBER-OF-FAILED-SUBGOALS-MEMO-TABLE-000 NULL)
(CL:DEFVAR KWD-WHYNOT-EQUIVALENT NULL)
(CL:DEFVAR KWD-WHYNOT-ISA NULL)
(CL:DEFVAR KWD-WHYNOT-NOT NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-WEIGHT NULL)
(CL:DEFVAR KWD-WHYNOT-DOWN NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-REAL-ALLOTTED-CLOCK-TICKS NULL)
(CL:DEFVAR KWD-WHYNOT-UP-TRUE NULL)
(CL:DEFVAR KWD-WHYNOT-UP-FAIL NULL)
(CL:DEFVAR KWD-WHYNOT-GOAL-TREE NULL)
(CL:DEFVAR KWD-WHYNOT-MOVE-DOWN NULL)
(CL:DEFVAR KWD-WHYNOT-FAILURE NULL)
(CL:DEFVAR SGT-WHYNOT-STELLA-CONS-ITERATOR NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-ANTECEDENTS-RULE NULL)
(CL:DEFVAR SYM-WHYNOT-STELLA-ITERATOR NULL)
(CL:DEFVAR KWD-WHYNOT-SKIPPED-CONJUNCT NULL)
(CL:DEFVAR KWD-WHYNOT-POPPED NULL)
(CL:DEFVAR KWD-WHYNOT-MINIMUM-SCORE NULL)
(CL:DEFVAR KWD-WHYNOT-MAXIMUM-UNKNOWNS NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-LATEST-POSITIVE-SCORE NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-ALL-JUSTIFICATIONS NULL)
(CL:DEFVAR KWD-WHYNOT-MAXIMIZE-SCORE? NULL)
(CL:DEFVAR KWD-WHYNOT-PATTERN NULL)
(CL:DEFVAR SGT-WHYNOT-LOGIC-WHYNOT-PROOF-CLASS NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-REPRESENTATIVE NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-DEVIATING-PATTERN NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-DEVIATING-VARIABLE NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-DEVIATING-INSTANCES NULL)
(CL:DEFVAR SGT-WHYNOT-LOGIC-ALTERNATIVE-BINDINGS-SET NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-THE-VARIABLE NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-BINDINGS NULL)
(CL:DEFVAR SYM-WHYNOT-STELLA-SURROGATE-VALUE-INVERSE NULL)
(CL:DEFVAR KWD-WHYNOT-REALISTIC NULL)
(CL:DEFVAR KWD-WHYNOT-AND-INTRODUCTION NULL)
(CL:DEFVAR KWD-WHYNOT-MATCH-MODE NULL)
(CL:DEFVAR KWD-WHYNOT-WHYNOT NULL)
(CL:DEFVAR KWD-WHYNOT-JUSTIFICATIONS NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-WHYNOT NULL)
(CL:DEFVAR KWD-WHYNOT-COMMON-LISP NULL)
(CL:DEFVAR KWD-WHYNOT-FUNCTION NULL)
(CL:DEFVAR KWD-WHYNOT-BRIEF NULL)
(CL:DEFVAR KWD-WHYNOT-NOT-ASSERTED NULL)
(CL:DEFVAR KWD-WHYNOT-NO-RULES NULL)
(CL:DEFVAR SYM-WHYNOT-LOGIC-STARTUP-WHYNOT NULL)
(CL:DEFVAR SYM-WHYNOT-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* *EXPLANATION-AUDIENCE*
  *MOST-RECENT-EXPLANATION-MAPPING* *MOST-RECENT-QUERY*
  *RECORD-JUSTIFICATIONS?* FALSE-WRAPPER *INFERENCELEVEL*
  *SIMILAR-WHYNOT-PROOF-CUTOFF* NIL-LIST UNKNOWN-TRUTH-VALUE
  *TRACED-KEYWORDS* NULL-INTEGER-WRAPPER FALSE-TRUTH-VALUE
  DEFAULT-FALSE-TRUTH-VALUE TRUE-TRUTH-VALUE *MINIMUM-SCORE-CUTOFF*
  NULL-FLOAT-WRAPPER STANDARD-OUTPUT EOL *MEMOIZATION-ENABLED?*
  MEMOIZED-NULL-VALUE *QUERYITERATOR* NIL NULL-FLOAT NULL-INTEGER))

;;; (DEFCLASS WHYNOT-PARTIAL-MATCH ...)

(CL:DEFCLASS WHYNOT-PARTIAL-MATCH (INCREMENTAL-PARTIAL-MATCH)
  ((UNKNOWN-GOAL-CUTOFF :TYPE CL:FIXNUM :INITFORM NULL-INTEGER
    :ALLOCATION :INSTANCE :ACCESSOR %UNKNOWN-GOAL-CUTOFF))
  (:DOCUMENTATION
   "Variant of :BASIC partial match strategy to support WHYNOT queries."))

(CL:DEFUN NEW-WHYNOT-PARTIAL-MATCH (KIND CONTROL-FRAME)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE WHYNOT-PARTIAL-MATCH)))
   (CL:SETF (%KIND SELF) KIND)
   (CL:SETF (%CONTROL-FRAME SELF) CONTROL-FRAME)
   (CL:SETF (%SUCCESS? SELF) CL:NIL) (CL:SETF (%UNBOUND-VARS SELF) NIL)
   (CL:SETF (%ARGUMENT-WEIGHTS SELF) NIL)
   (CL:SETF (%ARGUMENT-SCORES SELF) NIL)
   (CL:SETF (%DYNAMIC-CUTOFF SELF) NULL-FLOAT)
   (CL:SETF (%NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%POSITIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%MAXIMUM-SCORE SELF) 0.0d0)
   (CL:SETF (%TOTAL-WEIGHT SELF) NULL-FLOAT)
   (CL:SETF (%ACCUMULATED-WEIGHT SELF) 0.0d0)
   (CL:SETF (%ACCUMULATED-SCORE SELF) 0.0d0)
   (CL:SETF (%CHILD SELF) NULL) (CL:SETF (%PARENT SELF) NULL)
   (CL:SETF (%UNKNOWN-GOAL-CUTOFF SELF) NULL-INTEGER)
   (INITIALIZE-INCREMENTAL-PARTIAL-MATCH SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF WHYNOT-PARTIAL-MATCH))
  SGT-WHYNOT-LOGIC-WHYNOT-PARTIAL-MATCH)

(CL:DEFUN ACCESS-WHYNOT-PARTIAL-MATCH-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-WHYNOT-LOGIC-UNKNOWN-GOAL-CUTOFF)
    (CL:IF SETVALUE?
     (CL:SETF (%UNKNOWN-GOAL-CUTOFF SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%UNKNOWN-GOAL-CUTOFF SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFCLASS WHYNOT-DEEP-PARTIAL-MATCH ...)

(CL:DEFCLASS WHYNOT-DEEP-PARTIAL-MATCH (WHYNOT-PARTIAL-MATCH)
  ()
  (:DOCUMENTATION
   "Variant of WhyNot partial match geared towards deep proofs."))

(CL:DEFUN NEW-WHYNOT-DEEP-PARTIAL-MATCH (KIND CONTROL-FRAME)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE WHYNOT-DEEP-PARTIAL-MATCH)))
   (CL:SETF (%KIND SELF) KIND)
   (CL:SETF (%CONTROL-FRAME SELF) CONTROL-FRAME)
   (CL:SETF (%SUCCESS? SELF) CL:NIL) (CL:SETF (%UNBOUND-VARS SELF) NIL)
   (CL:SETF (%ARGUMENT-WEIGHTS SELF) NIL)
   (CL:SETF (%ARGUMENT-SCORES SELF) NIL)
   (CL:SETF (%DYNAMIC-CUTOFF SELF) NULL-FLOAT)
   (CL:SETF (%NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%POSITIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%MAXIMUM-SCORE SELF) 0.0d0)
   (CL:SETF (%TOTAL-WEIGHT SELF) NULL-FLOAT)
   (CL:SETF (%ACCUMULATED-WEIGHT SELF) 0.0d0)
   (CL:SETF (%ACCUMULATED-SCORE SELF) 0.0d0)
   (CL:SETF (%CHILD SELF) NULL) (CL:SETF (%PARENT SELF) NULL)
   (CL:SETF (%UNKNOWN-GOAL-CUTOFF SELF) NULL-INTEGER)
   (INITIALIZE-INCREMENTAL-PARTIAL-MATCH SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF WHYNOT-DEEP-PARTIAL-MATCH))
  SGT-WHYNOT-LOGIC-WHYNOT-DEEP-PARTIAL-MATCH)

;;; (DEFUN (WHYNOT-PARTIAL-MATCH-MODE? BOOLEAN) ...)

(CL:DEFUN WHYNOT-PARTIAL-MATCH-MODE? ()
  (CL:AND
   (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
    (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
   (ISA? (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
    SGT-WHYNOT-LOGIC-WHYNOT-PARTIAL-MATCH)))

;;; (DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME WHYNOT-PARTIAL-MATCH) ...)

(CL:DEFMETHOD CREATE-PARTIAL-MATCH-FRAME ((SELF WHYNOT-PARTIAL-MATCH) FRAME KIND)
  (NEW-WHYNOT-PARTIAL-MATCH KIND FRAME))

;;; (DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME WHYNOT-DEEP-PARTIAL-MATCH) ...)

(CL:DEFMETHOD CREATE-PARTIAL-MATCH-FRAME ((SELF WHYNOT-DEEP-PARTIAL-MATCH) FRAME KIND)
  (NEW-WHYNOT-DEEP-PARTIAL-MATCH KIND FRAME))

;;; (DEFMETHOD SET-DYNAMIC-CUTOFF ...)

(CL:DEFMETHOD SET-DYNAMIC-CUTOFF ((SELF WHYNOT-PARTIAL-MATCH))
  (CL:LET* ((CUTOFF (COMPUTE-DYNAMIC-CUTOFF SELF)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT CUTOFF))
   (CL:WHEN (CL:NOT (CL:= CUTOFF NULL-FLOAT))
    (CL:WHEN (CL:OR (CL:< CUTOFF -100) (CL:> CUTOFF 100))
     (CL:WARN
      "*** fishy dynamic cutoff=`~A' computed, resetting to 0.0"
      CUTOFF)
     (CL:SETQ CUTOFF 0.0d0))
    (CL:SETF (%DYNAMIC-CUTOFF SELF) CUTOFF))
   (CL:SETF (%UNKNOWN-GOAL-CUTOFF SELF)
    (COMPUTE-UNKNOWN-GOAL-CUTOFF SELF))))

;;; (DEFMETHOD (COMPUTE-UNKNOWN-GOAL-CUTOFF INTEGER) ...)

(CL:DEFMETHOD COMPUTE-UNKNOWN-GOAL-CUTOFF ((SELF WHYNOT-PARTIAL-MATCH))
  (CL:LET*
   ((PARENT (%PARENT SELF)) (PARENTCUTOFF NULL-INTEGER)
    (CUTOFF NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM PARENTCUTOFF CUTOFF))
   (CL:WHEN (CL:NOT (CL:EQ PARENT NULL))
    (CL:SETQ PARENTCUTOFF (%UNKNOWN-GOAL-CUTOFF PARENT))
    (CL:WHEN (NULL? PARENTCUTOFF)
     (CL:RETURN-FROM COMPUTE-UNKNOWN-GOAL-CUTOFF NULL-INTEGER))
    (CL:COND
     ((CL:EQ (%KIND PARENT) KWD-WHYNOT-AND)
      (CL:LET*
       ((PARENTFRAME (%CONTROL-FRAME PARENT)) (SIBLINGUNKNOWNS 0))
       (CL:DECLARE (CL:TYPE CL:FIXNUM SIBLINGUNKNOWNS))
       (CL:LET*
        ((I NULL-INTEGER) (ITER-000 0)
         (UPPER-BOUND-000 (CL:1- (%ARGUMENT-CURSOR PARENTFRAME))))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
        (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
         (CL:SETQ I ITER-000)
         (CL:SETQ SIBLINGUNKNOWNS
          (CL:+ SIBLINGUNKNOWNS
           (NUMBER-OF-FAILED-SUBGOALS
            (%PARTIAL-MATCH-FRAME
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%THE-ARRAY
                (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PARENTFRAME)
                 SYM-WHYNOT-STELLA-ARGUMENTS NULL)))
              I)))))
         (CL:SETQ ITER-000 (CL:1+ ITER-000))))
       (CL:SETQ CUTOFF (MAX (CL:- PARENTCUTOFF SIBLINGUNKNOWNS) 0))))
     (CL:T (CL:SETQ CUTOFF PARENTCUTOFF))))
   CUTOFF))

;;; (DEFMETHOD (NUMBER-OF-FAILED-SUBGOALS INTEGER) ...)

(CL:DEFMETHOD NUMBER-OF-FAILED-SUBGOALS ((SELF WHYNOT-PARTIAL-MATCH))
  (CL:LET*
   ((PROOF
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%CONTROL-FRAME SELF))
      SYM-WHYNOT-LOGIC-JUSTIFICATION NULL)))
   (CL:LET*
    ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
     (MEMOIZED-VALUE-000 NULL))
    (CL:WHEN *MEMOIZATION-ENABLED?*
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE-VALUE
       SGT-WHYNOT-LOGIC-M-WHYNOT-PARTIAL-MATCH.NUMBER-OF-FAILED-SUBGOALS-MEMO-TABLE-000))
     (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
      (INITIALIZE-MEMOIZATION-TABLE
       SGT-WHYNOT-LOGIC-M-WHYNOT-PARTIAL-MATCH.NUMBER-OF-FAILED-SUBGOALS-MEMO-TABLE-000
       "(:MAX-VALUES 500)")
      (CL:SETQ MEMO-TABLE-000
       (%SURROGATE-VALUE
        SGT-WHYNOT-LOGIC-M-WHYNOT-PARTIAL-MATCH.NUMBER-OF-FAILED-SUBGOALS-MEMO-TABLE-000)))
     (CL:SETQ MEMOIZED-ENTRY-000
      (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 PROOF
       MEMOIZED-NULL-VALUE NULL NULL -1))
     (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
    (CL:COND
     ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
      (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
       (CL:SETQ MEMOIZED-VALUE-000 NULL)))
     (CL:T
      (CL:SETQ MEMOIZED-VALUE-000
       (WRAP-INTEGER (COMPUTE-NUMBER-OF-FAILED-SUBGOALS PROOF)))
      (CL:WHEN *MEMOIZATION-ENABLED?*
       (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
        (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
         MEMOIZED-VALUE-000)))))
    (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
     (%WRAPPER-VALUE VALUE-000)))))

;;; (DEFUN (COMPUTE-NUMBER-OF-FAILED-SUBGOALS INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM)
  COMPUTE-NUMBER-OF-FAILED-SUBGOALS))
(CL:DEFUN COMPUTE-NUMBER-OF-FAILED-SUBGOALS (PROOF)
  (CL:LET* ((LIST NULL))
   (CL:WHEN (CL:NOT (CL:EQ PROOF NULL)) (CL:SETQ LIST (NEW-LIST))
    (COLLECT-FAILED-GOALS PROOF LIST)
    (CL:RETURN-FROM COMPUTE-NUMBER-OF-FAILED-SUBGOALS (LENGTH LIST)))
   0))

;;; (DEFMETHOD (CUTOFF-PARTIAL-MATCH? BOOLEAN) ...)

(CL:DEFMETHOD CUTOFF-PARTIAL-MATCH? ((SELF WHYNOT-PARTIAL-MATCH) TRACE?)
  (CL:LET*
   ((SCORE (%POSITIVE-SCORE SELF)) (SCORECUTOFF (%DYNAMIC-CUTOFF SELF))
    (UNKNOWNGOALCUTOFF (%UNKNOWN-GOAL-CUTOFF SELF)) (CUTOFF? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE SCORECUTOFF)
    (CL:TYPE CL:FIXNUM UNKNOWNGOALCUTOFF))
   (CL:COND
    ((CL:OR (CL:= SCORE NULL-FLOAT) (CL:= SCORECUTOFF NULL-FLOAT)
      (CL:= SCORECUTOFF 0.0d0))
     (CL:SETQ CUTOFF? CL:NIL))
    ((CL:< SCORECUTOFF 0.0d0) (CL:SETQ CUTOFF? (> SCORE SCORECUTOFF)))
    (CL:T (CL:SETQ CUTOFF? (< SCORE SCORECUTOFF))))
   (CL:WHEN (CL:AND (CL:NOT CUTOFF?) (DEFINED? UNKNOWNGOALCUTOFF))
    (CL:SETQ CUTOFF?
     (> (NUMBER-OF-FAILED-SUBGOALS SELF) UNKNOWNGOALCUTOFF))
    (CL:WHEN (CL:AND CUTOFF? TRACE?)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "*** Cutting off search, more than " UNKNOWNGOALCUTOFF
      " failed subgoal(s)" EOL)))
   CUTOFF?))

;;; (DEFUN (AUXILIARY-EQUIVALENCE-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN AUXILIARY-EQUIVALENCE-PROPOSITION? (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000
    (CL:EQ (%KIND PROPOSITION) KWD-WHYNOT-EQUIVALENT))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:WHEN
        (CL:AND (VARIABLE? ARG)
         (CL:NOT
          (CL:EQ
           (ACCESS-IN-CONTEXT (%VARIABLE-VALUE ARG) (%HOME-CONTEXT ARG)
            CL:NIL)
           NULL)))
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (CL:SETQ TEST-VALUE-000 FOUND?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFMETHOD (PROPOSITION-WEIGHT FLOAT) ...)

(CL:DEFMETHOD PROPOSITION-WEIGHT ((SELF WHYNOT-PARTIAL-MATCH) PROPOSITION)
  (CL:COND ((CL:EQ PROPOSITION NULL) 1.0d0)
   ((CL:EQ (%KIND PROPOSITION) KWD-WHYNOT-ISA) 0.25d0)
   ((CL:AND (CL:EQ (%KIND PROPOSITION) KWD-WHYNOT-NOT)
     (CL:EQ
      (%KIND
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        0))
      KWD-WHYNOT-EQUIVALENT))
    0.1d0)
   ((AUXILIARY-EQUIVALENCE-PROPOSITION? PROPOSITION) 0.0d0)
   ((CL:NOT
     (CL:=
      (%WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
        SYM-WHYNOT-LOGIC-WEIGHT NULL-FLOAT-WRAPPER))
      NULL-FLOAT))
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-WHYNOT-LOGIC-WEIGHT NULL-FLOAT-WRAPPER)))
   ((CL:NOT
     (CL:EQ
      (ACCESS-IN-CONTEXT (%TRUTH-VALUE PROPOSITION)
       (%HOME-CONTEXT PROPOSITION) CL:NIL)
      NULL))
    (%POSITIVE-SCORE
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE PROPOSITION)
      (%HOME-CONTEXT PROPOSITION) CL:NIL)))
   (CL:T 1.0d0)))

;;; (DEFGLOBAL *MIN-CLOCK-TICKS-PER-WHYNOT-ANTECEDENT* ...)

(CL:DEFVAR *MIN-CLOCK-TICKS-PER-WHYNOT-ANTECEDENT* 5)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *MIN-CLOCK-TICKS-PER-WHYNOT-ANTECEDENT*))

;;; (DEFMETHOD (CONTINUE-PARTIAL-AND-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-AND-PROOF ((SELF WHYNOT-PARTIAL-MATCH) FRAME LASTMOVE)
  (CL:LET* ((FORBIDDENVARS NIL))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-WHYNOT-DOWN) (SET-DYNAMIC-CUTOFF SELF)
     (CL:WHEN (DEFINED? (%ALLOTTED-CLOCK-TICKS FRAME))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
       SYM-WHYNOT-LOGIC-REAL-ALLOTTED-CLOCK-TICKS
       (WRAP-INTEGER (%ALLOTTED-CLOCK-TICKS FRAME))
       NULL-INTEGER-WRAPPER)))
    ((CL:OR (CL:EQ LASTMOVE KWD-WHYNOT-UP-TRUE)
      (CL:EQ LASTMOVE KWD-WHYNOT-UP-FAIL))
     (CL:LET*
      ((SUCCESS? (CL:EQ LASTMOVE KWD-WHYNOT-UP-TRUE))
       (ANDPROPOSITION (%PROPOSITION FRAME))
       (CONJUNCTFRAME (%RESULT FRAME))
       (CONJUNCT (%PROPOSITION CONJUNCTFRAME))
       (SCORE (%POSITIVE-SCORE (%PARTIAL-MATCH-FRAME CONJUNCTFRAME)))
       (WEIGHT (PROPOSITION-WEIGHT SELF CONJUNCT)))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE WEIGHT))
      (CL:SETQ LASTMOVE KWD-WHYNOT-UP-TRUE)
      (PUSH-AND-PARTIAL-MATCH-SCORE SELF SCORE WEIGHT)
      (CL:COND
       ((CUTOFF-PARTIAL-MATCH? (%PARTIAL-MATCH-FRAME CONJUNCTFRAME)
         (TRACE-KEYWORD? KWD-WHYNOT-GOAL-TREE))
        (CL:SETQ LASTMOVE KWD-WHYNOT-UP-FAIL))
       ((CL:AND
         (CL:OR (CL:EQ (%TRUTH-VALUE CONJUNCTFRAME) FALSE-TRUTH-VALUE)
          (CL:EQ (%TRUTH-VALUE CONJUNCTFRAME)
           DEFAULT-FALSE-TRUTH-VALUE))
         (CL:OR (CL:EQ (%TRUTH-VALUE CONJUNCTFRAME) TRUE-TRUTH-VALUE)
          (CL:EQ (%TRUTH-VALUE CONJUNCTFRAME) FALSE-TRUTH-VALUE)))
        (CL:SETQ LASTMOVE KWD-WHYNOT-UP-FAIL))
       ((CL:AND
         (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? CONJUNCT))
         (CL:NOT SUCCESS?))
        (CL:SETQ LASTMOVE KWD-WHYNOT-UP-FAIL))
       (CL:T
        (CL:WHEN
         (CL:= (%ARGUMENT-CURSOR FRAME)
          (CL:1- (LENGTH (%ARGUMENTS ANDPROPOSITION))))
         (CL:SETQ SCORE (COMPUTE-AND-SCORE SELF))
         (CL:IF
          (CL:OR (CL:<= SCORE *MINIMUM-SCORE-CUTOFF*)
           (CL:AND (CL:NOT (ALL-ARGUMENTS-BOUND? ANDPROPOSITION))
            (CL:NOT (ALLOW-UNBOUND-VARIABLES? SELF))))
          (CL:SETQ LASTMOVE KWD-WHYNOT-UP-FAIL)
          (SET-FRAME-PARTIAL-TRUTH SELF NULL SCORE NULL-FLOAT
           CL:NIL)))))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:WHEN (CL:EQ LASTMOVE KWD-WHYNOT-UP-FAIL)
    (CL:SETF (%DOWN FRAME) NULL))
   (CL:LET* ((RESULT (CONTINUE-AND-PROOF FRAME LASTMOVE)))
    (CL:COND
     ((CL:EQ RESULT KWD-WHYNOT-MOVE-DOWN)
      (CL:LET*
       ((I NULL-INTEGER) (ITER-000 (%ARGUMENT-CURSOR FRAME))
        (UPPER-BOUND-000 (CL:1- (LENGTH (%ARGUMENT-SCORES SELF)))))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
       (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
        (CL:SETQ I ITER-000) (CL:SETQ I I)
        (POP-AND-PARTIAL-MATCH-SCORE SELF)
        (CL:SETQ ITER-000 (CL:1+ ITER-000))))
      (CL:WHEN (SKIP-AND-CLAUSE? SELF FRAME FORBIDDENVARS)
       (CL:SETQ RESULT
        (CONTINUE-PARTIAL-AND-PROOF SELF FRAME KWD-WHYNOT-UP-FAIL)))
      (CL:WHEN
       (CL:AND (DEFINED? (%ALLOTTED-CLOCK-TICKS FRAME))
        (CL:EQ RESULT KWD-WHYNOT-MOVE-DOWN))
       (CL:SETF (%ALLOTTED-CLOCK-TICKS FRAME)
        (CL:TRUNCATE
         (CL:/
          (CL:FLOAT
           (CL:-
            (%WRAPPER-VALUE
             (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
              SYM-WHYNOT-LOGIC-REAL-ALLOTTED-CLOCK-TICKS
              NULL-INTEGER-WRAPPER))
            (CL:- (%CURRENT-CLOCK-TICKS *QUERYITERATOR*)
             (%STARTING-CLOCK-TICKS FRAME)))
           0.0d0)
          (LENGTH
           (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
            SYM-WHYNOT-STELLA-ARGUMENTS NULL)))))))
     ((CL:EQ RESULT KWD-WHYNOT-FAILURE)
      (SET-FRAME-PARTIAL-TRUTH SELF (%TRUTH-VALUE FRAME) NULL-FLOAT
       NULL-FLOAT CL:NIL))
     (CL:T))
    RESULT)))

;;; (DEFUN (NUMBER-OF-REMAINING-ANTECEDENTS INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM)
  NUMBER-OF-REMAINING-ANTECEDENTS))
(CL:DEFUN NUMBER-OF-REMAINING-ANTECEDENTS (ITERATOR)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ITERATOR)
     SGT-WHYNOT-STELLA-CONS-ITERATOR)
    (CL:PROGN
     (CL:IF (%FIRST-ITERATION? ITERATOR)
      (LENGTH (%CONS-ITERATOR-CURSOR ITERATOR))
      (CL:1- (LENGTH (%CONS-ITERATOR-CURSOR ITERATOR))))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "Don't know how to handle antecedents iterator of type `"
      (PRIMARY-TYPE ITERATOR) "'")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFMETHOD (CHAINING-DEPTH-DEGRADATION FLOAT) ...)

(CL:DEFMETHOD CHAINING-DEPTH-DEGRADATION ((SELF WHYNOT-PARTIAL-MATCH))
  (CL:LET*
   ((FRAME (%CONTROL-FRAME SELF)) (DEGRADATIONFACTOR 0.75d0)
    (DEGRADATION 1.0d0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT DEGRADATIONFACTOR DEGRADATION))
   (CL:SETQ FRAME (%UP FRAME))
   (CL:LOOP WHILE (CL:NOT (CL:EQ FRAME NULL)) DO
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
        SYM-WHYNOT-LOGIC-ANTECEDENTS-RULE NULL)
       NULL))
     (CL:SETQ DEGRADATION (CL:* DEGRADATION DEGRADATIONFACTOR)))
    (CL:SETQ FRAME (%UP FRAME)))
   DEGRADATION))

;;; (DEFMETHOD (CHAINING-DEPTH-DEGRADATION FLOAT) ...)

(CL:DEFMETHOD CHAINING-DEPTH-DEGRADATION ((SELF WHYNOT-DEEP-PARTIAL-MATCH))
  1.0d0)

;;; (DEFMETHOD (CONTINUE-PARTIAL-ANTECEDENTS-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-ANTECEDENTS-PROOF ((SELF WHYNOT-PARTIAL-MATCH) LASTMOVE)
  (CL:LET*
   ((FRAME (%CONTROL-FRAME SELF))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-WHYNOT-STELLA-ITERATOR NULL))
    (GOAL (EXTRACT-SUBGOAL-OF-FRAME FRAME)) (SCORE NULL-FLOAT)
    (RESULT NULL) (ALLOTTEDCLOCKTICKS (%ALLOTTED-CLOCK-TICKS FRAME))
    (CURRENTCLOCKTICKS (%CURRENT-CLOCK-TICKS *QUERYITERATOR*)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE)
    (CL:TYPE CL:FIXNUM ALLOTTEDCLOCKTICKS CURRENTCLOCKTICKS))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-WHYNOT-DOWN) (SET-DYNAMIC-CUTOFF SELF)
     (CL:WHEN (CL:EQ ITERATOR NULL)
      (CL:SETQ ITERATOR
       (ALLOCATE-ANTECEDENTS-ITERATOR
        (EXTRACT-SUBGOAL-DESCRIPTION-OF-FRAME FRAME)
        (FIND-EXTERNAL-ARGUMENTS-FOR-SUBGOAL FRAME)
        (%REVERSE-POLARITY? FRAME)))
      (CL:WHEN (CL:EQ ITERATOR NULL)
       (CL:SETQ ITERATOR (ALLOCATE-ITERATOR NIL)))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
       SYM-WHYNOT-STELLA-ITERATOR ITERATOR NULL))
     (CL:WHEN (DEFINED? ALLOTTEDCLOCKTICKS)
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
       SYM-WHYNOT-LOGIC-REAL-ALLOTTED-CLOCK-TICKS
       (WRAP-INTEGER ALLOTTEDCLOCKTICKS) NULL-INTEGER-WRAPPER)))
    ((CL:OR (CL:EQ LASTMOVE KWD-WHYNOT-UP-TRUE)
      (CL:EQ LASTMOVE KWD-WHYNOT-UP-FAIL))
     (CL:SETQ SCORE
      (%POSITIVE-SCORE (%PARTIAL-MATCH-FRAME (%RESULT FRAME))))
     (CL:WHEN
      (CL:OR (CL:AND (%REVERSE-POLARITY? FRAME) (CL:> SCORE 0.0d0))
       (CL:AND (CL:NOT (%REVERSE-POLARITY? FRAME)) (CL:< SCORE 0.0d0)))
      (CL:SETQ SCORE 0.0d0) (CL:SETQ LASTMOVE KWD-WHYNOT-UP-FAIL))
     (CL:WHEN
      (CL:< (CL:IF (CL:< SCORE 0.0d0) (CL:- 0.0d0 SCORE) SCORE) 1.0d0)
      (CL:SETQ SCORE (CL:* SCORE (CHAINING-DEPTH-DEGRADATION SELF))))
     (CL:SETQ SCORE
      (CL:* SCORE
       (PROPOSITION-WEIGHT SELF
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
         SYM-WHYNOT-LOGIC-ANTECEDENTS-RULE NULL))))
     (SET-FRAME-PARTIAL-TRUTH SELF NULL SCORE NULL-FLOAT CL:NIL)
     (CL:WHEN
      (CL:OR (CL:EQ LASTMOVE KWD-WHYNOT-UP-FAIL)
       (CL:AND (CL:NOT (ALL-ARGUMENTS-BOUND? GOAL))
        (CL:NOT (ALLOW-UNBOUND-VARIABLES? SELF)))
       (CUTOFF-PARTIAL-MATCH? SELF
        (TRACE-KEYWORD? KWD-WHYNOT-GOAL-TREE)))
      (SET-FRAME-PARTIAL-TRUTH SELF UNKNOWN-TRUTH-VALUE 0.0d0
       NULL-FLOAT CL:T)
      (CL:SETQ LASTMOVE KWD-WHYNOT-UP-FAIL)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:WHEN
    (CL:AND (CL:EQ LASTMOVE KWD-WHYNOT-UP-FAIL)
     (CL:NOT (CL:EQ (%DOWN FRAME) NULL)))
    (CL:SETF (%DOWN FRAME) NULL))
   (CL:WHEN
    (CL:NOT
     (CL:OR (CL:EQ LASTMOVE KWD-WHYNOT-UP-TRUE)
      (NULL? ALLOTTEDCLOCKTICKS)))
    (CL:SETF (%ALLOTTED-CLOCK-TICKS FRAME)
     (CL:TRUNCATE
      (CL:/
       (CL:FLOAT
        (CL:-
         (%WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
           SYM-WHYNOT-LOGIC-REAL-ALLOTTED-CLOCK-TICKS
           NULL-INTEGER-WRAPPER))
         (CL:- CURRENTCLOCKTICKS (%STARTING-CLOCK-TICKS FRAME)))
        0.0d0)
       (MAX (NUMBER-OF-REMAINING-ANTECEDENTS ITERATOR) 1))))
    (CL:WHEN
     (CL:AND
      (CL:< (%ALLOTTED-CLOCK-TICKS FRAME)
       *MIN-CLOCK-TICKS-PER-WHYNOT-ANTECEDENT*)
      (CL:> (NUMBER-OF-REMAINING-ANTECEDENTS ITERATOR) 0))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
       (MEMB? *TRACED-KEYWORDS* KWD-WHYNOT-GOAL-TREE))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "*** Timeout - not enough time to subgoal" EOL))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-WHYNOT-STELLA-ITERATOR (ALLOCATE-ITERATOR NIL) NULL)))
   (CL:SETQ RESULT (CONTINUE-ANTECEDENTS-PROOF FRAME LASTMOVE))
   (CL:WHEN
    (CL:AND (CL:EQ LASTMOVE KWD-WHYNOT-UP-TRUE)
     (CL:EQ (%TRUTH-VALUE FRAME) NULL))
    (CL:SETF (%TRUTH-VALUE FRAME) UNKNOWN-TRUTH-VALUE))
   RESULT))

;;; (DEFMETHOD (MAX-UNCONSTRAINED-FANOUT FLOAT) ...)

(CL:DEFMETHOD MAX-UNCONSTRAINED-FANOUT ((SELF WHYNOT-PARTIAL-MATCH))
  25.0d0)

;;; (DEFMETHOD (MAX-UNCONSTRAINED-FANOUT FLOAT) ...)

(CL:DEFMETHOD MAX-UNCONSTRAINED-FANOUT ((SELF WHYNOT-DEEP-PARTIAL-MATCH))
  1000000.0d0)

;;; (DEFMETHOD (SKIP-AND-CLAUSE? BOOLEAN) ...)

(CL:DEFMETHOD SKIP-AND-CLAUSE? ((SELF WHYNOT-PARTIAL-MATCH) FRAME FORBIDDENVARS)
  (CL:LET*
   ((FORBIDDENVARS? (CL:NOT (CL:EQ FORBIDDENVARS NIL)))
    (CONJUNCT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%THE-ARRAY (%ARGUMENTS (%PROPOSITION FRAME))))
      (CL:THE CL:FIXNUM (%ARGUMENT-CURSOR FRAME)))))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:SETQ TEST-VALUE-000 FORBIDDENVARS?)
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET* ((VAR NULL) (ITER-000 (GET-UNBOUND-VARIABLES CONJUNCT)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ VAR (%%VALUE ITER-000))
        (CL:WHEN (MEMBER? FORBIDDENVARS VAR) (CL:SETQ FOUND?-000 CL:T)
         (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:SETQ TEST-VALUE-000 FOUND?-000)))
    (CL:WHEN (CL:NOT TEST-VALUE-000)
     (CL:SETQ TEST-VALUE-000
      (> (DYNAMICALLY-ESTIMATE-GOAL-FANOUT CONJUNCT)
       (MAX-UNCONSTRAINED-FANOUT SELF))))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((RESULT (CREATE-DOWN-FRAME FRAME CONJUNCT)))
      (SET-FRAME-TRUTH-VALUE RESULT UNKNOWN-TRUTH-VALUE)
      (CL:WHEN (CL:EQ (%PARTIAL-MATCH-FRAME RESULT) NULL)
       (CREATE-AND-LINK-PARTIAL-MATCH-FRAME RESULT NULL))
      (SET-FRAME-PARTIAL-TRUTH (%PARTIAL-MATCH-FRAME RESULT)
       UNKNOWN-TRUTH-VALUE 0.0d0 NULL-FLOAT CL:T)
      (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY)))
       (CL:SETF (%INFERENCE-RULE SELF-000) KWD-WHYNOT-SKIPPED-CONJUNCT)
       (CL:SETF (%STRATEGY SELF-000) KWD-WHYNOT-FAILURE)
       (RECORD-GOAL-JUSTIFICATION RESULT SELF-000))
      (CL:SETF (%STATE RESULT) KWD-WHYNOT-POPPED)
      (CL:LET
       ((SELF
         (%THE-ARRAY
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
           SYM-WHYNOT-STELLA-ARGUMENTS NULL)))
        (VALUE RESULT) (POSITION (%ARGUMENT-CURSOR FRAME)))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETF (%RESULT FRAME) RESULT)
      (CL:WHEN (TRACE-KEYWORD? KWD-WHYNOT-GOAL-TREE)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
        "*** Skipping clause " CONJUNCT EOL))
      (CL:RETURN-FROM SKIP-AND-CLAUSE? CL:T))))
   CL:NIL))

;;; (DEFMETHOD INITIALIZE-PARTIAL-MATCH-STRATEGY ...)

(CL:DEFMETHOD INITIALIZE-PARTIAL-MATCH-STRATEGY ((SELF WHYNOT-PARTIAL-MATCH) QUERY)
  (CL:LET*
   ((MINIMUMSCORE (LOOKUP (%OPTIONS QUERY) KWD-WHYNOT-MINIMUM-SCORE))
    (MAXUNKNOWNS (LOOKUP (%OPTIONS QUERY) KWD-WHYNOT-MAXIMUM-UNKNOWNS))
    (EPSILON 0.001d0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT EPSILON))
   (CL:SETF (%PARTIAL-MATCH-STRATEGY QUERY) SELF)
   (CL:SETF (%DYNAMIC-CUTOFF SELF)
    (CL:IF (CL:NOT (CL:EQ MINIMUMSCORE NULL))
     (%WRAPPER-VALUE MINIMUMSCORE) EPSILON))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS QUERY)
    SYM-WHYNOT-LOGIC-LATEST-POSITIVE-SCORE (WRAP-FLOAT 0.0d0)
    NULL-FLOAT-WRAPPER)
   (CL:WHEN (CL:NOT (CL:EQ MAXUNKNOWNS NULL))
    (CL:SETF (%UNKNOWN-GOAL-CUTOFF SELF) (%WRAPPER-VALUE MAXUNKNOWNS)))))

(CL:DEFMETHOD ALL-JUSTIFICATIONS ((SELF CONTROL-FRAME))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-WHYNOT-LOGIC-ALL-JUSTIFICATIONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

;;; (DEFMETHOD (COMPUTE-PARTIAL-TRUTH FLOAT) ...)

(CL:DEFMETHOD COMPUTE-PARTIAL-TRUTH ((SELF WHYNOT-PARTIAL-MATCH) QUERY)
  (CL:LET*
   ((BASEFRAME (%BASE-CONTROL-FRAME QUERY))
    (PARTIALMATCHFRAME (%PARTIAL-MATCH-STRATEGY QUERY))
    (MINIMUMSCORE (LOOKUP (%OPTIONS QUERY) KWD-WHYNOT-MINIMUM-SCORE))
    (MAXIMIZESCORE?
     (CL:NOT
      (EQL? (LOOKUP (%OPTIONS QUERY) KWD-WHYNOT-MAXIMIZE-SCORE?)
       FALSE-WRAPPER)))
    (TOPNPROOFS 10) (PROOFCLASSES (NEW-LIST))
    (INITIALINFERENCELEVEL (CURRENT-INFERENCE-LEVEL)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM TOPNPROOFS))
   (CL:WHEN (CL:EQ PARTIALMATCHFRAME NULL)
    (CL:SETQ PARTIALMATCHFRAME SELF)
    (CL:SETF (%PARTIAL-MATCH-STRATEGY QUERY) SELF))
   (CL:SETF (%DYNAMIC-CUTOFF PARTIALMATCHFRAME)
    (CL:IF (CL:NOT (CL:EQ MINIMUMSCORE NULL))
     (%WRAPPER-VALUE MINIMUMSCORE) 0.3d0))
   (CL:LET*
    ((*QUERYITERATOR* QUERY) (*GENERATE-ALL-PROOFS?* CL:T)
     (*RECORD-JUSTIFICATIONS?* CL:T)
     (*INFERENCELEVEL* INITIALINFERENCELEVEL)
     (*REVERSEPOLARITY?* CL:NIL))
    (CL:DECLARE
     (CL:SPECIAL *QUERYITERATOR* *GENERATE-ALL-PROOFS?*
      *RECORD-JUSTIFICATIONS?* *INFERENCELEVEL* *REVERSEPOLARITY?*))
    (CL:LOOP (CL:WHEN (CL:NOT (NEXT? QUERY)) (CL:RETURN))
     (CL:SETQ *INFERENCELEVEL* INITIALINFERENCELEVEL)
     (CL:WHEN (CUTOFF-PARTIAL-MATCH? PARTIALMATCHFRAME CL:NIL)
      (CL:RETURN))
     (CL:WHEN
      (CL:=
       (LENGTH
        (INSERT-WHYNOT-PROOF PROOFCLASSES
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS BASEFRAME)
          SYM-WHYNOT-LOGIC-JUSTIFICATION NULL)))
       *SIMILAR-WHYNOT-PROOF-CUTOFF*)
      (CUTOFF-SIMILAR-WHYNOT-PROOFS QUERY))
     (CL:WHEN (CL:>= (LENGTH PROOFCLASSES) TOPNPROOFS)
      (SORT PROOFCLASSES (CL:FUNCTION BETTER-WHYNOT-PROOF-CLASS?))
      (CL:SETF (%DYNAMIC-CUTOFF PARTIALMATCHFRAME)
       (CL:+
        (%POSITIVE-SCORE
         (%REPRESENTATIVE (NTH PROOFCLASSES (CL:1- TOPNPROOFS))))
        0.01d0)))
     (CL:WHEN
      (CL:OR (CL:NOT MAXIMIZESCORE?)
       (CL:NOT
        (CL:OR (CL:EQ (%TRUTH-VALUE BASEFRAME) UNKNOWN-TRUTH-VALUE)
         (CL:EQ (%TRUTH-VALUE BASEFRAME) NULL))))
      (CL:RETURN))))
   (POST-PROCESS-WHYNOT-PROOF-CLASSES PROOFCLASSES)
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS BASEFRAME)
    SYM-WHYNOT-LOGIC-ALL-JUSTIFICATIONS (NEW-LIST) NULL)
   (CL:LET*
    ((CLASS NULL) (ITER-000 (%THE-CONS-LIST PROOFCLASSES))
     (INTO-000 (ALL-JUSTIFICATIONS BASEFRAME)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CLASS (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000 (CONS (%REPRESENTATIVE CLASS) NIL))
       (CL:IF (CL:EQ (%THE-CONS-LIST INTO-000) NIL)
        (CL:SETF (%THE-CONS-LIST INTO-000) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST INTO-000)
         COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (%REPRESENTATIVE CLASS) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS BASEFRAME)
    SYM-WHYNOT-LOGIC-JUSTIFICATION
    (FIRST (ALL-JUSTIFICATIONS BASEFRAME)) NULL)
   (CL:IF
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS BASEFRAME)
       SYM-WHYNOT-LOGIC-JUSTIFICATION NULL)
      NULL))
    (%POSITIVE-SCORE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS BASEFRAME)
      SYM-WHYNOT-LOGIC-JUSTIFICATION NULL))
    0.0d0)))

;;; (DEFUN (BETTER-WHYNOT-PROOF? BOOLEAN) ...)

(CL:DEFUN BETTER-WHYNOT-PROOF? (PROOF1 PROOF2)
  (> (%POSITIVE-SCORE PROOF1) (%POSITIVE-SCORE PROOF2)))

;;; (DEFUN (COMPUTE-PROOF-DEVIATION INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:FIXNUM CL:T) CL:FIXNUM)
  COMPUTE-PROOF-DEVIATION))
(CL:DEFUN COMPUTE-PROOF-DEVIATION (PROOF1 PROOF2 MAXDEVIATIONS DEVIATIONS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM MAXDEVIATIONS))
  #+MCL
  (CL:CHECK-TYPE MAXDEVIATIONS CL:FIXNUM)
  (CL:WHEN (CL:EQ DEVIATIONS NULL)
   (CL:SETQ DEVIATIONS (NEW-KEY-VALUE-LIST)))
  (CL:LET* ((FOUNDDEVIATIONS 0) (SUBDEVIATIONS 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM FOUNDDEVIATIONS SUBDEVIATIONS))
   (CL:WHEN
    (CL:AND (CL:EQ (%INFERENCE-RULE PROOF1) (%INFERENCE-RULE PROOF2))
     (CL:EQ (INFERENCE-STRATEGY PROOF1) (INFERENCE-STRATEGY PROOF2))
     (CL:EQ (%TRUTH-VALUE PROOF1) (%TRUTH-VALUE PROOF2))
     (CL:EQ (%REVERSE-POLARITY? PROOF1) (%REVERSE-POLARITY? PROOF2))
     (CL:= (%POSITIVE-SCORE PROOF1) (%POSITIVE-SCORE PROOF2))
     (CL:= (%NEGATIVE-SCORE PROOF1) (%NEGATIVE-SCORE PROOF2))
     (EQUIVALENT-PROPOSITIONS? (%PROPOSITION PROOF1)
      (%PROPOSITION PROOF2) NULL))
    (CL:WHEN (CL:EQ (%INFERENCE-RULE PROOF1) KWD-WHYNOT-PATTERN)
     (CL:LET*
      ((VAR1 NULL) (VALUE1 NULL)
       (ITER-000 (%THE-KV-LIST (%SUBSTITUTION PROOF1))) (VAR2 NULL)
       (VALUE2 NULL) (ITER-001 (%THE-KV-LIST (%SUBSTITUTION PROOF2))))
      (CL:LOOP WHILE
       (CL:AND (CL:NOT (CL:EQ ITER-000 NULL))
        (CL:NOT (CL:EQ ITER-001 NULL)))
       DO (CL:SETQ VAR1 (%KEY ITER-000))
       (CL:SETQ VALUE1 (%VALUE ITER-000))
       (CL:SETQ VAR2 (%KEY ITER-001))
       (CL:SETQ VALUE2 (%VALUE ITER-001))
       (CL:WHEN (CL:NOT (CL:EQ VAR1 VAR2)) (CLEAR DEVIATIONS)
        (CL:RETURN-FROM COMPUTE-PROOF-DEVIATION NULL-INTEGER))
       (CL:WHEN (CL:NOT (EQL? VALUE1 VALUE2))
        (CL:SETQ FOUNDDEVIATIONS (CL:1+ FOUNDDEVIATIONS)))
       (CL:WHEN (CL:> FOUNDDEVIATIONS MAXDEVIATIONS) (CLEAR DEVIATIONS)
        (CL:RETURN-FROM COMPUTE-PROOF-DEVIATION NULL-INTEGER))
       (CL:SETQ ITER-000 (%REST ITER-000))
       (CL:SETQ ITER-001 (%REST ITER-001))))
     (CL:WHEN (CL:> FOUNDDEVIATIONS 0)
      (INSERT-AT DEVIATIONS PROOF1 PROOF2)))
    (CL:LET*
     ((ANT1 NULL) (ITER-002 (%ANTECEDENTS PROOF1)) (ANT2 NULL)
      (ITER-003 (%ANTECEDENTS PROOF2)))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-002 NIL))
       (CL:NOT (CL:EQ ITER-003 NIL)))
      DO (CL:SETQ ANT1 (%%VALUE ITER-002))
      (CL:SETQ ANT2 (%%VALUE ITER-003))
      (CL:SETQ SUBDEVIATIONS
       (COMPUTE-PROOF-DEVIATION ANT1 ANT2
        (CL:- MAXDEVIATIONS FOUNDDEVIATIONS) DEVIATIONS))
      (CL:WHEN (NULL? SUBDEVIATIONS) (CLEAR DEVIATIONS)
       (CL:RETURN-FROM COMPUTE-PROOF-DEVIATION NULL-INTEGER))
      (CL:SETQ FOUNDDEVIATIONS (CL:+ FOUNDDEVIATIONS SUBDEVIATIONS))
      (CL:SETQ ITER-002 (%%REST ITER-002))
      (CL:SETQ ITER-003 (%%REST ITER-003))))
    (CL:RETURN-FROM COMPUTE-PROOF-DEVIATION FOUNDDEVIATIONS))
   NULL-INTEGER))

;;; (DEFCLASS WHYNOT-PROOF-CLASS ...)

(CL:DEFCLASS WHYNOT-PROOF-CLASS (SET)
  ((REPRESENTATIVE :ALLOCATION :INSTANCE :ACCESSOR %REPRESENTATIVE)
   (DEVIATING-PATTERN :ALLOCATION :INSTANCE :ACCESSOR
    %DEVIATING-PATTERN)
   (DEVIATING-VARIABLE :ALLOCATION :INSTANCE :ACCESSOR
    %DEVIATING-VARIABLE)
   (DEVIATING-INSTANCES :ALLOCATION :INSTANCE :ACCESSOR
    %DEVIATING-INSTANCES))
  (:DOCUMENTATION
   "Set of equivalent WhyNot proofs that differ in at most one
variable binding all on the same `deviating-variable'."))

(CL:DEFUN NEW-WHYNOT-PROOF-CLASS ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE WHYNOT-PROOF-CLASS)))
   (CL:SETF (%THE-CONS-LIST SELF) NIL)
   (CL:SETF (%DEVIATING-INSTANCES SELF) (NEW-LIST))
   (CL:SETF (%DEVIATING-VARIABLE SELF) NULL)
   (CL:SETF (%DEVIATING-PATTERN SELF) NULL)
   (CL:SETF (%REPRESENTATIVE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF WHYNOT-PROOF-CLASS))
  SGT-WHYNOT-LOGIC-WHYNOT-PROOF-CLASS)

(CL:DEFUN ACCESS-WHYNOT-PROOF-CLASS-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-WHYNOT-LOGIC-REPRESENTATIVE)
    (CL:IF SETVALUE? (CL:SETF (%REPRESENTATIVE SELF) VALUE)
     (CL:SETQ VALUE (%REPRESENTATIVE SELF))))
   ((CL:EQ SLOTNAME SYM-WHYNOT-LOGIC-DEVIATING-PATTERN)
    (CL:IF SETVALUE? (CL:SETF (%DEVIATING-PATTERN SELF) VALUE)
     (CL:SETQ VALUE (%DEVIATING-PATTERN SELF))))
   ((CL:EQ SLOTNAME SYM-WHYNOT-LOGIC-DEVIATING-VARIABLE)
    (CL:IF SETVALUE? (CL:SETF (%DEVIATING-VARIABLE SELF) VALUE)
     (CL:SETQ VALUE (%DEVIATING-VARIABLE SELF))))
   ((CL:EQ SLOTNAME SYM-WHYNOT-LOGIC-DEVIATING-INSTANCES)
    (CL:IF SETVALUE? (CL:SETF (%DEVIATING-INSTANCES SELF) VALUE)
     (CL:SETQ VALUE (%DEVIATING-INSTANCES SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFSPECIAL *MAX-WHYNOT-PROOF-CLASS-DEVIATIONS* ...)

(CL:DEFVAR *MAX-WHYNOT-PROOF-CLASS-DEVIATIONS* 1)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *MAX-WHYNOT-PROOF-CLASS-DEVIATIONS*))

;;; (DEFUN (INSERT-WHYNOT-PROOF-TO-CLASS? BOOLEAN) ...)

(CL:DEFUN INSERT-WHYNOT-PROOF-TO-CLASS? (CLASS PROOF)
  (CL:WHEN (EMPTY? CLASS)
   (CL:SETF (%THE-CONS-LIST CLASS) (CONS PROOF (%THE-CONS-LIST CLASS)))
   (CL:SETF (%REPRESENTATIVE CLASS) PROOF)
   (CL:RETURN-FROM INSERT-WHYNOT-PROOF-TO-CLASS? CL:T))
  (CL:LET*
   ((DEVIATIONS (NEW-KEY-VALUE-LIST))
    (FOUNDDEVIATIONS
     (COMPUTE-PROOF-DEVIATION PROOF (%REPRESENTATIVE CLASS)
      *MAX-WHYNOT-PROOF-CLASS-DEVIATIONS* DEVIATIONS)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM FOUNDDEVIATIONS))
   (CL:WHEN (DEFINED? FOUNDDEVIATIONS)
    (CL:LET*
     ((NEWDEV NULL) (REPDEV NULL) (ITER-000 (%THE-KV-LIST DEVIATIONS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
      (CL:SETQ NEWDEV (%KEY ITER-000))
      (CL:SETQ REPDEV (%VALUE ITER-000))
      (CL:WHEN (CL:= FOUNDDEVIATIONS 0)
       (CL:RETURN-FROM INSERT-WHYNOT-PROOF-TO-CLASS? CL:T))
      (CL:WHEN (CL:EQ (%DEVIATING-PATTERN CLASS) NULL)
       (CL:SETF (%DEVIATING-PATTERN CLASS) REPDEV))
      (CL:LET*
       ((NEWVAR NULL) (NEWVALUE NULL)
        (ITER-001 (%THE-KV-LIST (%SUBSTITUTION NEWDEV))) (REPVAR NULL)
        (REPVALUE NULL)
        (ITER-002
         (%THE-KV-LIST (%SUBSTITUTION (%DEVIATING-PATTERN CLASS)))))
       (CL:LOOP WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-001 NULL))
         (CL:NOT (CL:EQ ITER-002 NULL)))
        DO (CL:SETQ NEWVAR (%KEY ITER-001))
        (CL:SETQ NEWVALUE (%VALUE ITER-001))
        (CL:SETQ REPVAR (%KEY ITER-002))
        (CL:SETQ REPVALUE (%VALUE ITER-002))
        (CL:WHEN (CL:NOT (EQL? NEWVALUE REPVALUE))
         (CL:SETQ REPVAR REPVAR)
         (CL:COND
          ((CL:EQ (%DEVIATING-VARIABLE CLASS) NULL)
           (CL:SETF (%DEVIATING-VARIABLE CLASS) NEWVAR)
           (INSERT (%DEVIATING-INSTANCES CLASS) REPVALUE))
          ((CL:NOT (CL:EQ NEWVAR (%DEVIATING-VARIABLE CLASS)))
           (CL:RETURN-FROM INSERT-WHYNOT-PROOF-TO-CLASS? CL:NIL))
          ((MEMBER? (%DEVIATING-INSTANCES CLASS) NEWVALUE)
           (CL:RETURN-FROM INSERT-WHYNOT-PROOF-TO-CLASS? CL:T)))
         (INSERT (%DEVIATING-INSTANCES CLASS) NEWVALUE))
        (CL:SETQ ITER-001 (%REST ITER-001))
        (CL:SETQ ITER-002 (%REST ITER-002))))
      (CL:SETF (%THE-CONS-LIST CLASS)
       (CONS PROOF (%THE-CONS-LIST CLASS)))
      (CL:RETURN-FROM INSERT-WHYNOT-PROOF-TO-CLASS? CL:T)
      (CL:SETQ ITER-000 (%REST ITER-000)))))
   CL:NIL))

;;; (DEFUN (INSERT-WHYNOT-PROOF WHYNOT-PROOF-CLASS) ...)

(CL:DEFUN INSERT-WHYNOT-PROOF (CLASSES PROOF)
  (CL:LET* ((CLASS NULL) (ITER-000 (%THE-CONS-LIST CLASSES)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ CLASS (%%VALUE ITER-000))
    (CL:WHEN (INSERT-WHYNOT-PROOF-TO-CLASS? CLASS PROOF)
     (CL:RETURN-FROM INSERT-WHYNOT-PROOF CLASS))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (PUSH CLASSES (NEW-WHYNOT-PROOF-CLASS))
  (INSERT-WHYNOT-PROOF-TO-CLASS? (FIRST CLASSES) PROOF)
  (FIRST CLASSES))

;;; (DEFUN (BETTER-WHYNOT-PROOF-CLASS? BOOLEAN) ...)

(CL:DEFUN BETTER-WHYNOT-PROOF-CLASS? (CLASS1 CLASS2)
  (BETTER-WHYNOT-PROOF? (%REPRESENTATIVE CLASS1)
   (%REPRESENTATIVE CLASS2)))

;;; (DEFCLASS ALTERNATIVE-BINDINGS-SET ...)

(CL:DEFCLASS ALTERNATIVE-BINDINGS-SET (THING)
  ((THE-VARIABLE :ALLOCATION :INSTANCE :ACCESSOR %THE-VARIABLE)
   (BINDINGS :ALLOCATION :INSTANCE :ACCESSOR %BINDINGS))
  (:DOCUMENTATION
   "Represents a set of alternative bindings collected for the pattern
variable `(the-variable self)'."))

(CL:DEFUN NEW-ALTERNATIVE-BINDINGS-SET ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE ALTERNATIVE-BINDINGS-SET)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF)
    SGT-WHYNOT-LOGIC-ALTERNATIVE-BINDINGS-SET)
   (CL:SETF (%BINDINGS SELF) (NEW-SET))
   (CL:SETF (%THE-VARIABLE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ALTERNATIVE-BINDINGS-SET))
  SGT-WHYNOT-LOGIC-ALTERNATIVE-BINDINGS-SET)

(CL:DEFUN ACCESS-ALTERNATIVE-BINDINGS-SET-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-WHYNOT-LOGIC-THE-VARIABLE)
    (CL:IF SETVALUE? (CL:SETF (%THE-VARIABLE SELF) VALUE)
     (CL:SETQ VALUE (%THE-VARIABLE SELF))))
   ((CL:EQ SLOTNAME SYM-WHYNOT-LOGIC-BINDINGS)
    (CL:IF SETVALUE? (CL:SETF (%BINDINGS SELF) VALUE)
     (CL:SETQ VALUE (%BINDINGS SELF))))
   ((CL:EQ SLOTNAME SYM-WHYNOT-STELLA-SURROGATE-VALUE-INVERSE)
    (CL:IF SETVALUE? (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) VALUE)
     (CL:SETQ VALUE (%SURROGATE-VALUE-INVERSE SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF ALTERNATIVE-BINDINGS-SET) STREAM)
  (%%PRINT-STREAM STREAM
   (STRING-DOWNCASE (GET-SKOLEM-PRINT-NAME (%THE-VARIABLE SELF)))))

;;; (DEFUN (ALTERNATIVE-BINDINGS-SET? BOOLEAN) ...)

(CL:DEFUN ALTERNATIVE-BINDINGS-SET? (THING)
  (CL:AND (CL:NOT (CL:EQ THING NULL))
   (ISA? THING SGT-WHYNOT-LOGIC-ALTERNATIVE-BINDINGS-SET)))

;;; (DEFUN (ALTERNATIVE-BINDINGS SET) ...)

(CL:DEFUN ALTERNATIVE-BINDINGS (BINDINGSSET)
  (%BINDINGS BINDINGSSET))

;;; (DEFUN POST-PROCESS-WHYNOT-PROOF-CLASSES ...)

(CL:DEFUN POST-PROCESS-WHYNOT-PROOF-CLASSES (CLASSES)
  (SORT CLASSES (CL:FUNCTION BETTER-WHYNOT-PROOF-CLASS?))
  (CL:LET* ((CLASS NULL) (ITER-000 (%THE-CONS-LIST CLASSES)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ CLASS (%%VALUE ITER-000))
    (CL:WHEN (CL:> (LENGTH CLASS) 1)
     (CL:LET*
      ((SUBSTITUTION (%SUBSTITUTION (%DEVIATING-PATTERN CLASS)))
       (VARIABLE (%DEVIATING-VARIABLE CLASS)))
      (CL:LET* ((SELF-000 (NEW-ALTERNATIVE-BINDINGS-SET)))
       (CL:SETF (%THE-VARIABLE SELF-000) VARIABLE)
       (CL:LET* ((BINDINGS SELF-000))
        (CL:LET*
         ((INSTANCE NULL)
          (ITER-001 (%THE-CONS-LIST (%DEVIATING-INSTANCES CLASS))))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ INSTANCE (%%VALUE ITER-001))
          (INSERT (%BINDINGS BINDINGS) INSTANCE)
          (CL:SETQ ITER-001 (%%REST ITER-001))))
        (INSERT-AT SUBSTITUTION VARIABLE BINDINGS)))))
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFGLOBAL *SIMILAR-WHYNOT-PROOF-CUTOFF* ...)

(CL:DEFVAR *SIMILAR-WHYNOT-PROOF-CUTOFF* 3)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *SIMILAR-WHYNOT-PROOF-CUTOFF*))

;;; (DEFUN CUTOFF-SIMILAR-WHYNOT-PROOFS ...)

(CL:DEFUN CUTOFF-SIMILAR-WHYNOT-PROOFS (QUERY)
  (CL:LET* ((CONTINUATIONFRAME (%BASE-CONTROL-FRAME QUERY)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ (%DOWN CONTINUATIONFRAME) NULL)) DO
    (CL:SETQ CONTINUATIONFRAME (%DOWN CONTINUATIONFRAME)))
   (CL:WHEN
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTINUATIONFRAME)
       SYM-WHYNOT-STELLA-ITERATOR NULL)
      NULL))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTINUATIONFRAME)
     SYM-WHYNOT-STELLA-ITERATOR (ALLOCATE-ITERATOR NIL) NULL)
    (CL:WHEN (TRACE-KEYWORD? KWD-WHYNOT-GOAL-TREE)
     (CL:LET*
      ((*PRINTINFRAME* CONTINUATIONFRAME)
       (*PRINTMODE* KWD-WHYNOT-REALISTIC)
       (*PRINTLOGICALFORMSTREAM* STANDARD-OUTPUT)
       (*QUERYITERATOR* QUERY))
      (CL:DECLARE
       (CL:SPECIAL *PRINTINFRAME* *PRINTMODE* *PRINTLOGICALFORMSTREAM*
        *QUERYITERATOR*))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "*** cutting off similar WhyNot proofs at goal=")
      (PRINT-UNFORMATTED-LOGICAL-FORM (%PROPOSITION CONTINUATIONFRAME)
       STANDARD-OUTPUT)
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL))))))

;;; (DEFMETHOD (RETRIEVE-PARTIAL-SOLUTIONS QUERY-ITERATOR) ...)

(CL:DEFMETHOD RETRIEVE-PARTIAL-SOLUTIONS ((SELF WHYNOT-PARTIAL-MATCH) QUERY)
  (CL:LET*
   ((BASEFRAME (%BASE-CONTROL-FRAME QUERY))
    (PARTIALMATCHFRAME (%PARTIAL-MATCH-STRATEGY QUERY))
    (MINIMUMSCORE (LOOKUP-QUERY-OPTION QUERY KWD-WHYNOT-MINIMUM-SCORE))
    (MAXIMIZESCORE?
     (CL:NOT
      (EQL? (LOOKUP-QUERY-OPTION QUERY KWD-WHYNOT-MAXIMIZE-SCORE?)
       FALSE-WRAPPER)))
    (HOWMANY (LOOKUP-HOW-MANY-SOLUTIONS QUERY)) (TOPN 10)
    (TOPNPARTIALPROOFS TOPN) (HAVEENOUGHPARTIALPROOFS? CL:NIL)
    (CURRENTSOLUTION NIL) (CURRENTPROOF NULL) (STRICTPROOFS (NEW-LIST))
    (PARTIALPROOFCLASSES (NEW-LIST))
    (INITIALINFERENCELEVEL (CURRENT-INFERENCE-LEVEL)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM HOWMANY TOPN TOPNPARTIALPROOFS))
   (CL:WHEN (CL:EQ PARTIALMATCHFRAME NULL)
    (CL:SETQ PARTIALMATCHFRAME SELF)
    (CL:SETF (%PARTIAL-MATCH-STRATEGY QUERY) SELF))
   (CL:SETF (%DYNAMIC-CUTOFF PARTIALMATCHFRAME)
    (CL:IF (CL:NOT (CL:EQ MINIMUMSCORE NULL))
     (%WRAPPER-VALUE MINIMUMSCORE) 0.3d0))
   (CL:LET*
    ((*QUERYITERATOR* QUERY) (*GENERATE-ALL-PROOFS?* CL:T)
     (*RECORD-JUSTIFICATIONS?* CL:T)
     (*INFERENCELEVEL* INITIALINFERENCELEVEL)
     (*REVERSEPOLARITY?* CL:NIL))
    (CL:DECLARE
     (CL:SPECIAL *QUERYITERATOR* *GENERATE-ALL-PROOFS?*
      *RECORD-JUSTIFICATIONS?* *INFERENCELEVEL* *REVERSEPOLARITY?*))
    (CL:LOOP
     (CL:TAGBODY (CLEAR (%SOLUTIONS QUERY))
      (CL:WHEN
       (CL:OR (CL:= (LENGTH STRICTPROOFS) HOWMANY)
        (CL:NOT (NEXT? QUERY)))
       (CL:RETURN))
      (CL:SETQ *INFERENCELEVEL* INITIALINFERENCELEVEL)
      (CL:WHEN (CUTOFF-PARTIAL-MATCH? PARTIALMATCHFRAME CL:NIL)
       (CL:RETURN))
      (CL:SETQ CURRENTSOLUTION (CONSIFY (%VALUE QUERY)))
      (CL:SETQ CURRENTPROOF
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS BASEFRAME)
        SYM-WHYNOT-LOGIC-JUSTIFICATION NULL))
      (CL:LET* ((TEST-VALUE-000 CL:NIL))
       (CL:LET* ((FOUND?-000 CL:NIL))
        (CL:LET*
         ((PROOF NULL) (ITER-000 (%THE-CONS-LIST STRICTPROOFS)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ PROOF (%%VALUE ITER-000))
          (CL:WHEN
           (EQUAL? (RETRIEVAL-PROOF-SOLUTION PROOF QUERY)
            CURRENTSOLUTION)
           (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
          (CL:SETQ ITER-000 (%%REST ITER-000))))
        (CL:SETQ TEST-VALUE-000 FOUND?-000))
       (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
       (CL:IF TEST-VALUE-000
        (CL:PROGN
         (CL:WHEN
          (CL:NOT
           (CL:OR (CL:EQ (%TRUTH-VALUE BASEFRAME) UNKNOWN-TRUTH-VALUE)
            (CL:EQ (%TRUTH-VALUE BASEFRAME) NULL)))
          (PUSH STRICTPROOFS CURRENTPROOF) (CL:GO :CONTINUE)))
        (CL:PROGN (CL:GO :CONTINUE))))
      (CL:WHEN
       (CL:=
        (LENGTH (INSERT-WHYNOT-PROOF PARTIALPROOFCLASSES CURRENTPROOF))
        *SIMILAR-WHYNOT-PROOF-CUTOFF*)
       (CUTOFF-SIMILAR-WHYNOT-PROOFS QUERY))
      (CL:SETQ TOPNPARTIALPROOFS
       (CL:IF (NULL? HOWMANY) TOPN
        (MAX TOPN (CL:- HOWMANY (LENGTH STRICTPROOFS)))))
      (CL:WHEN
       (CL:OR HAVEENOUGHPARTIALPROOFS?
        (CL:>= (LENGTH PARTIALPROOFCLASSES) TOPNPARTIALPROOFS))
       (CL:SETQ HAVEENOUGHPARTIALPROOFS? CL:T)
       (SORT PARTIALPROOFCLASSES
        (CL:FUNCTION BETTER-WHYNOT-PROOF-CLASS?))
       (CL:SETF (%DYNAMIC-CUTOFF PARTIALMATCHFRAME)
        (CL:+
         (%POSITIVE-SCORE
          (%REPRESENTATIVE
           (NTH PARTIALPROOFCLASSES (CL:1- TOPNPARTIALPROOFS))))
         0.01d0)))
      (CL:WHEN (CL:NOT MAXIMIZESCORE?) (CL:RETURN)) :CONTINUE)))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS BASEFRAME)
    SYM-WHYNOT-LOGIC-ALL-JUSTIFICATIONS (REVERSE STRICTPROOFS) NULL)
   (CL:WHEN (CL:NOT (CL:= (LENGTH STRICTPROOFS) HOWMANY))
    (POST-PROCESS-WHYNOT-PROOF-CLASSES PARTIALPROOFCLASSES)
    (CL:LET*
     ((CLASS NULL) (ITER-001 (%THE-CONS-LIST PARTIALPROOFCLASSES))
      (I NULL-INTEGER) (ITER-002 1) (UPPER-BOUND-000 TOPNPARTIALPROOFS)
      (UNBOUNDED?-000 (NULL? UPPER-BOUND-000))
      (INTO-000 (ALL-JUSTIFICATIONS BASEFRAME)) (COLLECT-000 NULL))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-001 NIL))
       (CL:OR UNBOUNDED?-000 (CL:<= ITER-002 UPPER-BOUND-000)))
      DO (CL:SETQ CLASS (%%VALUE ITER-001)) (CL:SETQ I ITER-002)
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000 (CONS (%REPRESENTATIVE CLASS) NIL))
        (CL:IF (CL:EQ (%THE-CONS-LIST INTO-000) NIL)
         (CL:SETF (%THE-CONS-LIST INTO-000) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST INTO-000)
          COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS (%REPRESENTATIVE CLASS) NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      (CL:SETQ ITER-001 (%%REST ITER-001))
      (CL:SETQ ITER-002 (CL:1+ ITER-002)))))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS BASEFRAME)
    SYM-WHYNOT-LOGIC-JUSTIFICATION
    (FIRST (ALL-JUSTIFICATIONS BASEFRAME)) NULL)
   (CLEAR (%SOLUTIONS QUERY))
   (CL:LET*
    ((PROOF NULL)
     (ITER-003 (%THE-CONS-LIST (ALL-JUSTIFICATIONS BASEFRAME))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
     (CL:SETQ PROOF (%%VALUE ITER-003))
     (CL:LET* ((SELF-002 (NEW-QUERY-SOLUTION)))
      (CL:SETF (%BINDINGS SELF-002)
       (COERCE-TO-VECTOR (RETRIEVAL-PROOF-SOLUTION PROOF QUERY)))
      (CL:SETF (%MATCH-SCORE SELF-002) (%POSITIVE-SCORE PROOF))
      (CL:SETF (%JUSTIFICATION SELF-002) PROOF)
      (CL:LET* ((SOLUTION SELF-002))
       (INSERT-AT (%SOLUTIONS QUERY) (%BINDINGS SOLUTION) SOLUTION)))
     (CL:SETQ ITER-003 (%%REST ITER-003))))
   QUERY))

;;; (DEFUN (RETRIEVAL-PROOF-SOLUTION CONS) ...)

(CL:DEFUN RETRIEVAL-PROOF-SOLUTION (PROOF QUERY)
  (CL:LET* ((SOLUTION NIL) (SUBSTITUTION (%SUBSTITUTION PROOF)))
   (CL:LET*
    ((EXTVAR NULL) (VECTOR-000 (%EXTERNAL-VARIABLES QUERY))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ EXTVAR
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:LET*
      ((VAR NULL) (VALUE NULL) (ITER-000 (%THE-KV-LIST SUBSTITUTION)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
       (CL:SETQ VAR (%KEY ITER-000)) (CL:SETQ VALUE (%VALUE ITER-000))
       (CL:WHEN (CL:EQ (%SKOLEM-NAME VAR) (%SKOLEM-NAME EXTVAR))
        (CL:SETQ SOLUTION (CONS VALUE SOLUTION)) (CL:RETURN))
       (CL:SETQ ITER-000 (%REST ITER-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (REVERSE SOLUTION)))

;;; (DEFUN COLLECT-FAILED-GOALS ...)

(CL:DEFUN COLLECT-FAILED-GOALS (PROOF FAILURES)
  (CL:WHEN (CL:EQ (%INFERENCE-RULE PROOF) KWD-WHYNOT-AND-INTRODUCTION)
   (CL:LET* ((VARIABLES (NEW-LIST)))
    (CL:LET* ((ANTECEDENT NULL) (ITER-000 (%ANTECEDENTS PROOF)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ ANTECEDENT (%%VALUE ITER-000))
      (CL:WHEN (FAILED-GOAL-JUSTIFICATION? ANTECEDENT)
       (CL:LET*
        ((ARG NULL) (VECTOR-000 (%ARGUMENTS (%PROPOSITION ANTECEDENT)))
         (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:WHEN
          (ALTERNATIVE-BINDINGS-SET?
           (JUSTIFICATION-ARGUMENT-BOUND-TO ARG ANTECEDENT))
          (INSERT-NEW VARIABLES ARG))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:WHEN (NON-EMPTY? VARIABLES)
     (CL:LET* ((ANTECEDENT NULL) (ITER-001 (%ANTECEDENTS PROOF)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ ANTECEDENT (%%VALUE ITER-001))
       (CL:LET* ((TEST-VALUE-000 CL:NIL))
        (CL:IF (FAILED-GOAL-JUSTIFICATION? ANTECEDENT)
         (CL:SETQ TEST-VALUE-000 CL:T)
         (CL:LET* ((FOUND?-000 CL:NIL))
          (CL:LET*
           ((ARG NULL)
            (VECTOR-001 (%ARGUMENTS (%PROPOSITION ANTECEDENT)))
            (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
           (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
            (CL:SETQ ARG
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
              INDEX-001))
            (CL:WHEN (MEMBER? VARIABLES ARG) (CL:SETQ FOUND?-000 CL:T)
             (CL:RETURN))
            (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
          (CL:SETQ TEST-VALUE-000 FOUND?-000)))
        (CL:IF TEST-VALUE-000 (INSERT FAILURES ANTECEDENT)
         (COLLECT-FAILED-GOALS ANTECEDENT FAILURES)))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:RETURN-FROM COLLECT-FAILED-GOALS))))
  (CL:IF (FAILED-GOAL-JUSTIFICATION? PROOF) (INSERT-NEW FAILURES PROOF)
   (CL:LET* ((ANTECEDENT NULL) (ITER-002 (%ANTECEDENTS PROOF)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ ANTECEDENT (%%VALUE ITER-002))
     (COLLECT-FAILED-GOALS ANTECEDENT FAILURES)
     (CL:SETQ ITER-002 (%%REST ITER-002))))))

;;; (DEFUN (DERIVE-JUSTIFIED-PARTIAL-QUERY QUERY-ITERATOR) ...)

(CL:DEFUN DERIVE-JUSTIFIED-PARTIAL-QUERY (QUERY)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY QUERY) NULL))
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%BASE-CONTROL-FRAME QUERY))
       SYM-WHYNOT-LOGIC-JUSTIFICATION NULL)
      NULL)))
   (CL:RETURN-FROM DERIVE-JUSTIFIED-PARTIAL-QUERY QUERY))
  (CL:LET*
   ((PARTIALQUERY
     (CREATE-QUERY-ITERATOR
      (%DESCRIPTION (%PATTERN-RECORD (%BASE-CONTROL-FRAME QUERY)))
      (%BINDINGS (%VALUE QUERY))))
    (RECORDJUSTIFICATIONS? *RECORD-JUSTIFICATIONS?*))
   (INSERT-AT (%OPTIONS PARTIALQUERY) KWD-WHYNOT-MATCH-MODE
    KWD-WHYNOT-WHYNOT)
   (SET-POWERLOOM-FEATURE KWD-WHYNOT-JUSTIFICATIONS)
   (CALL-ASK-PARTIAL PARTIALQUERY)
   (CL:WHEN (CL:NOT RECORDJUSTIFICATIONS?)
    (UNSET-POWERLOOM-FEATURE KWD-WHYNOT-JUSTIFICATIONS))
   PARTIALQUERY))

;;; (DEFUN WHYNOT ...)

(CL:DEFUN %WHYNOT (ARGS)
  (CL:LET*
   ((LABEL STELLA::NULL-STRING) (STYLE NULL) (MAXDEPTH NULL-INTEGER)
    (SUMMARY? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL)
    (CL:TYPE CL:FIXNUM MAXDEPTH))
   (CL:MULTIPLE-VALUE-SETQ (LABEL STYLE MAXDEPTH SUMMARY?)
    (PARSE-WHY-ARGUMENTS ARGS))
   (EXPLAIN-WHYNOT LABEL STYLE MAXDEPTH SUMMARY? STANDARD-OUTPUT)))

(CL:DEFUN WHYNOT-EVALUATOR-WRAPPER (ARGUMENTS)
  (%WHYNOT ARGUMENTS))

(CL:DEFMACRO WHYNOT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/WHYNOT|)) (CL:MACRO-FUNCTION (CL:QUOTE WHYNOT)))

;;; (DEFUN EXPLAIN-WHYNOT ...)

(CL:DEFUN EXPLAIN-WHYNOT (LABEL STYLE MAXDEPTH SUMMARY? STREAM)
  "Programmer's interface to the WHYNOT function."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL)
   (CL:TYPE CL:FIXNUM MAXDEPTH))
  #+MCL
  (CL:CHECK-TYPE LABEL CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MAXDEPTH CL:FIXNUM)
  (CL:WHEN (CL:EQ LABEL STELLA::NULL-STRING)
   (CL:SETQ *MOST-RECENT-EXPLANATION-MAPPING* (NEW-KEY-VALUE-LIST)))
  (CL:HANDLER-CASE
   (CL:LET* ((MAPPINGS NIL))
    (CL:LET*
     ((JUSTIFICATION NULL)
      (ITER-000
       (%THE-CONS-LIST
        (GET-WHYNOT-JUSTIFICATIONS *MOST-RECENT-QUERY* LABEL
         *MOST-RECENT-EXPLANATION-MAPPING*)))
      (I NULL-INTEGER) (ITER-001 1))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ JUSTIFICATION (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
      (CL:WHEN (CL:EQ LABEL STELLA::NULL-STRING)
       (CL:LET*
        ((INFO
          (REGISTER-JUSTIFICATION (VISIBLE-JUSTIFICATION JUSTIFICATION)
           *MOST-RECENT-EXPLANATION-MAPPING*)))
        (CL:SETF (%LABEL INFO) (INTEGER-TO-STRING I))
        (CL:SETF (%DEPTH INFO) 1)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL "Explanation #" I
       " score=" (%POSITIVE-SCORE JUSTIFICATION) ":" EOL EOL)
      (PRINT-WHYNOT-JUSTIFICATION JUSTIFICATION STREAM MAXDEPTH STYLE
       SUMMARY?)
      (CL:WHEN (CL:EQ LABEL STELLA::NULL-STRING)
       (CL:SETQ MAPPINGS
        (CONS *MOST-RECENT-EXPLANATION-MAPPING* MAPPINGS))
       (CL:SETQ *MOST-RECENT-EXPLANATION-MAPPING*
        (NEW-KEY-VALUE-LIST)))
      (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (CL:1+ ITER-001))))
    (CL:WHEN (CL:NOT (CL:EQ MAPPINGS NIL))
     (CL:SETQ *MOST-RECENT-EXPLANATION-MAPPING* (NEW-KEY-VALUE-LIST))
     (CL:LET* ((MAPPING NULL) (ITER-002 MAPPINGS))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ MAPPING (%%VALUE ITER-002))
       (CL:LET* ((K NULL) (V NULL) (ITER-003 (%THE-KV-LIST MAPPING)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NULL)) DO
         (CL:SETQ K (%KEY ITER-003)) (CL:SETQ V (%VALUE ITER-003))
         (INSERT-AT *MOST-RECENT-EXPLANATION-MAPPING* K V)
         (CL:SETQ ITER-003 (%REST ITER-003))))
       (CL:SETQ ITER-002 (%%REST ITER-002))))))
   (EXPLAIN-EXCEPTION (EE)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     (EXCEPTION-MESSAGE EE)))))

;;; (DEFUN PRINT-WHYNOT-JUSTIFICATION ...)

(CL:DEFUN PRINT-WHYNOT-JUSTIFICATION (JUSTIFICATION STREAM MAXDEPTH STYLE SUMMARY?)
  "Print a WHYNOT `justification' to `stream' according to
`maxDepth' and `style'.  Print a summary only if `summary?' is TRUE."
  (CL:DECLARE (CL:TYPE CL:FIXNUM MAXDEPTH))
  #+MCL
  (CL:CHECK-TYPE MAXDEPTH CL:FIXNUM)
  (CL:LET*
   ((*EXPLANATION-STYLE*
     (CL:IF (CL:NOT (CL:EQ STYLE NULL)) STYLE KWD-WHYNOT-BRIEF)))
   (CL:DECLARE (CL:SPECIAL *EXPLANATION-STYLE*))
   (CL:COND
    ((CL:EQ JUSTIFICATION NULL)
     (CL:WHEN (CL:NOT (CL:EQ *MOST-RECENT-QUERY* NULL))
      (PRETTY-PRINT-LOGICAL-FORM
       (%PROPOSITION
        (%DESCRIPTION (%CURRENT-PATTERN-RECORD *MOST-RECENT-QUERY*)))
       STREAM)
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL "  "
       (LOOKUP-EXPLANATION-PHRASE KWD-WHYNOT-NOT-ASSERTED NIL NULL)
       " and " EOL "  "
       (LOOKUP-EXPLANATION-PHRASE KWD-WHYNOT-NO-RULES NIL NULL) "."
       EOL)))
    (SUMMARY?
     (CL:LET* ((FAILURES (NEW-LIST)))
      (COLLECT-FAILED-GOALS JUSTIFICATION FAILURES)
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM)
       "The query failed, because" EOL)
      (CL:LET*
       ((FAILURE NULL) (ITER-000 (%THE-CONS-LIST FAILURES))
        (I NULL-INTEGER) (ITER-001 1))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ FAILURE (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
        (CL:IF (CL:= I 1)
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "    ")
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "and "))
        (PRINT-JUSTIFICATION-PROPOSITION FAILURE STREAM 4)
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL)
        (CL:SETQ ITER-000 (%%REST ITER-000))
        (CL:SETQ ITER-001 (CL:1+ ITER-001))))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "failed." EOL EOL)))
    (CL:T
     (PRINT-EXPLANATION JUSTIFICATION STREAM
      *MOST-RECENT-EXPLANATION-MAPPING* MAXDEPTH
      *EXPLANATION-AUDIENCE*)))))

;;; (DEFUN (GET-WHYNOT-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ...)

(CL:DEFUN GET-WHYNOT-JUSTIFICATIONS (QUERY LABEL MAPPING)
  "Programmer's interface to WHYNOT function.  Derive
justifications why `query' failed, or, if `label' was supplied as non-NULL,
lookup its justification relative to `mapping' and return the result."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL))
  #+MCL
  (CL:CHECK-TYPE LABEL CL:SIMPLE-STRING)
  (CL:LET* ((JUSTIFICATIONS NULL))
   (CL:WHEN (CL:EQ QUERY NULL) (CL:SETQ QUERY *MOST-RECENT-QUERY*))
   (CL:WHEN (CL:EQ MAPPING NULL)
    (CL:SETQ MAPPING *MOST-RECENT-EXPLANATION-MAPPING*))
   (CL:WHEN (CL:EQ QUERY NULL)
    (CL:ERROR
     (NEW-EXPLAIN-NO-QUERY-EXCEPTION "There is nothing to explain.")))
   (CL:WHEN
    (CL:AND (CL:EQ (%PARTIAL-MATCH-STRATEGY QUERY) NULL)
     (CL:NOT (%EXHAUSTED? QUERY)))
    (CL:ERROR
     (NEW-EXPLAIN-QUERY-TRUE-EXCEPTION "The query did not fail.")))
   (CL:SETQ QUERY (DERIVE-JUSTIFIED-PARTIAL-QUERY QUERY))
   (CL:SETQ JUSTIFICATIONS
    (ALL-JUSTIFICATIONS (%BASE-CONTROL-FRAME QUERY)))
   (CL:WHEN (CL:NOT (CL:EQ LABEL STELLA::NULL-STRING))
    (CL:WHEN (CL:NOT (CL:EQ MAPPING NULL))
     (CL:SETQ JUSTIFICATIONS
      (LIST (LOOKUP-JUSTIFICATION MAPPING LABEL))))
    (CL:WHEN (CL:EQ (FIRST JUSTIFICATIONS) NULL)
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Label `" LABEL
       "' does not exists in the current explanation")
      (CL:ERROR
       (NEW-EXPLAIN-NO-SUCH-LABEL-EXCEPTION
        (THE-STRING-READER STREAM-000))))))
   JUSTIFICATIONS))

(CL:DEFUN HELP-STARTUP-WHYNOT1 ()
  (CL:PROGN
   (CL:SETQ SGT-WHYNOT-LOGIC-WHYNOT-PARTIAL-MATCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHYNOT-PARTIAL-MATCH" NULL 1))
   (CL:SETQ SYM-WHYNOT-LOGIC-UNKNOWN-GOAL-CUTOFF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN-GOAL-CUTOFF" NULL 0))
   (CL:SETQ SGT-WHYNOT-LOGIC-WHYNOT-DEEP-PARTIAL-MATCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHYNOT-DEEP-PARTIAL-MATCH" NULL
     1))
   (CL:SETQ KWD-WHYNOT-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ SYM-WHYNOT-STELLA-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-WHYNOT-LOGIC-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATION" NULL 0))
   (CL:SETQ
    SGT-WHYNOT-LOGIC-M-WHYNOT-PARTIAL-MATCH.NUMBER-OF-FAILED-SUBGOALS-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "M-WHYNOT-PARTIAL-MATCH.NUMBER-OF-FAILED-SUBGOALS-MEMO-TABLE-000"
     NULL 1))
   (CL:SETQ KWD-WHYNOT-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ KWD-WHYNOT-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ KWD-WHYNOT-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ SYM-WHYNOT-LOGIC-WEIGHT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WEIGHT" NULL 0))
   (CL:SETQ KWD-WHYNOT-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWN" NULL 2))
   (CL:SETQ SYM-WHYNOT-LOGIC-REAL-ALLOTTED-CLOCK-TICKS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REAL-ALLOTTED-CLOCK-TICKS" NULL
     0))
   (CL:SETQ KWD-WHYNOT-UP-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TRUE" NULL 2))
   (CL:SETQ KWD-WHYNOT-UP-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-FAIL" NULL 2))
   (CL:SETQ KWD-WHYNOT-GOAL-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-TREE" NULL 2))
   (CL:SETQ KWD-WHYNOT-MOVE-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MOVE-DOWN" NULL 2))
   (CL:SETQ KWD-WHYNOT-FAILURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILURE" NULL 2))
   (CL:SETQ SGT-WHYNOT-STELLA-CONS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS-ITERATOR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-WHYNOT-LOGIC-ANTECEDENTS-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS-RULE" NULL 0))
   (CL:SETQ SYM-WHYNOT-STELLA-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-WHYNOT-SKIPPED-CONJUNCT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKIPPED-CONJUNCT" NULL 2))
   (CL:SETQ KWD-WHYNOT-POPPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POPPED" NULL 2))
   (CL:SETQ KWD-WHYNOT-MINIMUM-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MINIMUM-SCORE" NULL 2))
   (CL:SETQ KWD-WHYNOT-MAXIMUM-UNKNOWNS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAXIMUM-UNKNOWNS" NULL 2))
   (CL:SETQ SYM-WHYNOT-LOGIC-LATEST-POSITIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LATEST-POSITIVE-SCORE" NULL 0))
   (CL:SETQ SYM-WHYNOT-LOGIC-ALL-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-JUSTIFICATIONS" NULL 0))
   (CL:SETQ KWD-WHYNOT-MAXIMIZE-SCORE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAXIMIZE-SCORE?" NULL 2))
   (CL:SETQ KWD-WHYNOT-PATTERN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN" NULL 2))
   (CL:SETQ SGT-WHYNOT-LOGIC-WHYNOT-PROOF-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHYNOT-PROOF-CLASS" NULL 1))
   (CL:SETQ SYM-WHYNOT-LOGIC-REPRESENTATIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REPRESENTATIVE" NULL 0))
   (CL:SETQ SYM-WHYNOT-LOGIC-DEVIATING-PATTERN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEVIATING-PATTERN" NULL 0))
   (CL:SETQ SYM-WHYNOT-LOGIC-DEVIATING-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEVIATING-VARIABLE" NULL 0))
   (CL:SETQ SYM-WHYNOT-LOGIC-DEVIATING-INSTANCES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEVIATING-INSTANCES" NULL 0))
   (CL:SETQ SGT-WHYNOT-LOGIC-ALTERNATIVE-BINDINGS-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALTERNATIVE-BINDINGS-SET" NULL 1))
   (CL:SETQ SYM-WHYNOT-LOGIC-THE-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-VARIABLE" NULL 0))
   (CL:SETQ SYM-WHYNOT-LOGIC-BINDINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BINDINGS" NULL 0))
   (CL:SETQ SYM-WHYNOT-STELLA-SURROGATE-VALUE-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE-INVERSE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-WHYNOT-REALISTIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REALISTIC" NULL 2))
   (CL:SETQ KWD-WHYNOT-AND-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-WHYNOT-MATCH-MODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MATCH-MODE" NULL 2))
   (CL:SETQ KWD-WHYNOT-WHYNOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHYNOT" NULL 2))
   (CL:SETQ KWD-WHYNOT-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATIONS" NULL 2))
   (CL:SETQ SYM-WHYNOT-LOGIC-WHYNOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHYNOT" NULL 0))
   (CL:SETQ KWD-WHYNOT-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-WHYNOT-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-WHYNOT-BRIEF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BRIEF" NULL 2))
   (CL:SETQ KWD-WHYNOT-NOT-ASSERTED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT-ASSERTED" NULL 2))
   (CL:SETQ KWD-WHYNOT-NO-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NO-RULES" NULL 2))
   (CL:SETQ SYM-WHYNOT-LOGIC-STARTUP-WHYNOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-WHYNOT" NULL 0))
   (CL:SETQ SYM-WHYNOT-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN STARTUP-WHYNOT ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-WHYNOT1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "WHYNOT-PARTIAL-MATCH"
        "(DEFCLASS WHYNOT-PARTIAL-MATCH (INCREMENTAL-PARTIAL-MATCH) :DOCUMENTATION \"Variant of :BASIC partial match strategy to support WHYNOT queries.\" :SLOTS ((UNKNOWN-GOAL-CUTOFF :TYPE INTEGER :INITIALLY NULL)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-WHYNOT-PARTIAL-MATCH))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-WHYNOT-PARTIAL-MATCH-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "WHYNOT-DEEP-PARTIAL-MATCH"
        "(DEFCLASS WHYNOT-DEEP-PARTIAL-MATCH (WHYNOT-PARTIAL-MATCH) :DOCUMENTATION \"Variant of WhyNot partial match geared towards deep proofs.\")")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-WHYNOT-DEEP-PARTIAL-MATCH)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "WHYNOT-PROOF-CLASS"
        "(DEFCLASS WHYNOT-PROOF-CLASS (SET) :DOCUMENTATION \"Set of equivalent WhyNot proofs that differ in at most one
variable binding all on the same `deviating-variable'.\" :PARAMETERS ((ANY-VALUE :TYPE JUSTIFICATION)) :SLOTS ((REPRESENTATIVE :TYPE JUSTIFICATION) (DEVIATING-PATTERN :TYPE JUSTIFICATION) (DEVIATING-VARIABLE :TYPE PATTERN-VARIABLE) (DEVIATING-INSTANCES :TYPE LIST :INITIALLY (NEW LIST))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-WHYNOT-PROOF-CLASS))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-WHYNOT-PROOF-CLASS-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ALTERNATIVE-BINDINGS-SET"
        "(DEFCLASS ALTERNATIVE-BINDINGS-SET (THING) :DOCUMENTATION \"Represents a set of alternative bindings collected for the pattern
variable `(the-variable self)'.\" :SLOTS ((THE-VARIABLE :TYPE PATTERN-VARIABLE) (BINDINGS :TYPE SET :INITIALLY (NEW SET)) (SURROGATE-VALUE-INVERSE :INITIALLY @ALTERNATIVE-BINDINGS-SET)) :PRINT-FORM (PRINT-STREAM STREAM (STRING-DOWNCASE (GET-SKOLEM-PRINT-NAME (THE-VARIABLE SELF)))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-ALTERNATIVE-BINDINGS-SET))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-ALTERNATIVE-BINDINGS-SET-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "WHYNOT-PARTIAL-MATCH-MODE?"
     "(DEFUN (WHYNOT-PARTIAL-MATCH-MODE? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (AND (PARTIAL-MATCH-MODE?) (ISA? (PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) @WHYNOT-PARTIAL-MATCH))))"
     (CL:FUNCTION WHYNOT-PARTIAL-MATCH-MODE?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME WHYNOT-PARTIAL-MATCH) ((SELF WHYNOT-PARTIAL-MATCH) (FRAME CONTROL-FRAME) (KIND KEYWORD)))"
     (CL:FUNCTION CREATE-PARTIAL-MATCH-FRAME) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME WHYNOT-DEEP-PARTIAL-MATCH) ((SELF WHYNOT-DEEP-PARTIAL-MATCH) (FRAME CONTROL-FRAME) (KIND KEYWORD)))"
     (CL:FUNCTION CREATE-PARTIAL-MATCH-FRAME) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD SET-DYNAMIC-CUTOFF ((SELF WHYNOT-PARTIAL-MATCH)))"
     (CL:FUNCTION SET-DYNAMIC-CUTOFF) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (COMPUTE-UNKNOWN-GOAL-CUTOFF INTEGER) ((SELF WHYNOT-PARTIAL-MATCH)))"
     (CL:FUNCTION COMPUTE-UNKNOWN-GOAL-CUTOFF) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NUMBER-OF-FAILED-SUBGOALS INTEGER) ((SELF WHYNOT-PARTIAL-MATCH)))"
     (CL:FUNCTION NUMBER-OF-FAILED-SUBGOALS) NULL)
    (DEFINE-FUNCTION-OBJECT "COMPUTE-NUMBER-OF-FAILED-SUBGOALS"
     "(DEFUN (COMPUTE-NUMBER-OF-FAILED-SUBGOALS INTEGER) ((PROOF JUSTIFICATION)))"
     (CL:FUNCTION COMPUTE-NUMBER-OF-FAILED-SUBGOALS) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (CUTOFF-PARTIAL-MATCH? BOOLEAN) ((SELF WHYNOT-PARTIAL-MATCH) (TRACE? BOOLEAN)))"
     (CL:FUNCTION CUTOFF-PARTIAL-MATCH?) NULL)
    (DEFINE-FUNCTION-OBJECT "AUXILIARY-EQUIVALENCE-PROPOSITION?"
     "(DEFUN (AUXILIARY-EQUIVALENCE-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)))"
     (CL:FUNCTION AUXILIARY-EQUIVALENCE-PROPOSITION?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (PROPOSITION-WEIGHT FLOAT) ((SELF WHYNOT-PARTIAL-MATCH) (PROPOSITION PROPOSITION)))"
     (CL:FUNCTION PROPOSITION-WEIGHT) NULL)
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT CONTROL-FRAME REAL-ALLOTTED-CLOCK-TICKS :TYPE INTEGER :ALLOCATION :DYNAMIC)")
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (CONTINUE-PARTIAL-AND-PROOF KEYWORD) ((SELF WHYNOT-PARTIAL-MATCH) (FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION CONTINUE-PARTIAL-AND-PROOF) NULL)
    (DEFINE-FUNCTION-OBJECT "NUMBER-OF-REMAINING-ANTECEDENTS"
     "(DEFUN (NUMBER-OF-REMAINING-ANTECEDENTS INTEGER) ((ITERATOR ITERATOR)))"
     (CL:FUNCTION NUMBER-OF-REMAINING-ANTECEDENTS) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (CHAINING-DEPTH-DEGRADATION FLOAT) ((SELF WHYNOT-PARTIAL-MATCH)))"
     (CL:FUNCTION CHAINING-DEPTH-DEGRADATION) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (CHAINING-DEPTH-DEGRADATION FLOAT) ((SELF WHYNOT-DEEP-PARTIAL-MATCH)))"
     (CL:FUNCTION CHAINING-DEPTH-DEGRADATION) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (CONTINUE-PARTIAL-ANTECEDENTS-PROOF KEYWORD) ((SELF WHYNOT-PARTIAL-MATCH) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION CONTINUE-PARTIAL-ANTECEDENTS-PROOF) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (MAX-UNCONSTRAINED-FANOUT FLOAT) ((SELF WHYNOT-PARTIAL-MATCH)))"
     (CL:FUNCTION MAX-UNCONSTRAINED-FANOUT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (MAX-UNCONSTRAINED-FANOUT FLOAT) ((SELF WHYNOT-DEEP-PARTIAL-MATCH)))"
     (CL:FUNCTION MAX-UNCONSTRAINED-FANOUT) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (SKIP-AND-CLAUSE? BOOLEAN) ((SELF WHYNOT-PARTIAL-MATCH) (FRAME CONTROL-FRAME) (FORBIDDENVARS (CONS OF PATTERN-VARIABLE))))"
     (CL:FUNCTION SKIP-AND-CLAUSE?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD INITIALIZE-PARTIAL-MATCH-STRATEGY ((SELF WHYNOT-PARTIAL-MATCH) (QUERY QUERY-ITERATOR)))"
     (CL:FUNCTION INITIALIZE-PARTIAL-MATCH-STRATEGY) NULL)
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT CONTROL-FRAME ALL-JUSTIFICATIONS :TYPE (LIST OF JUSTIFICATION) :ALLOCATION :DYNAMIC)")
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (COMPUTE-PARTIAL-TRUTH FLOAT) ((SELF WHYNOT-PARTIAL-MATCH) (QUERY QUERY-ITERATOR)))"
     (CL:FUNCTION COMPUTE-PARTIAL-TRUTH) NULL)
    (DEFINE-FUNCTION-OBJECT "BETTER-WHYNOT-PROOF?"
     "(DEFUN (BETTER-WHYNOT-PROOF? BOOLEAN) ((PROOF1 JUSTIFICATION) (PROOF2 JUSTIFICATION)))"
     (CL:FUNCTION BETTER-WHYNOT-PROOF?) NULL)
    (DEFINE-FUNCTION-OBJECT "COMPUTE-PROOF-DEVIATION"
     "(DEFUN (COMPUTE-PROOF-DEVIATION INTEGER) ((PROOF1 JUSTIFICATION) (PROOF2 JUSTIFICATION) (MAXDEVIATIONS INTEGER) (DEVIATIONS (KEY-VALUE-LIST OF JUSTIFICATION JUSTIFICATION))))"
     (CL:FUNCTION COMPUTE-PROOF-DEVIATION) NULL)
    (DEFINE-FUNCTION-OBJECT "INSERT-WHYNOT-PROOF-TO-CLASS?"
     "(DEFUN (INSERT-WHYNOT-PROOF-TO-CLASS? BOOLEAN) ((CLASS WHYNOT-PROOF-CLASS) (PROOF JUSTIFICATION)))"
     (CL:FUNCTION INSERT-WHYNOT-PROOF-TO-CLASS?) NULL)
    (DEFINE-FUNCTION-OBJECT "INSERT-WHYNOT-PROOF"
     "(DEFUN (INSERT-WHYNOT-PROOF WHYNOT-PROOF-CLASS) ((CLASSES (LIST OF WHYNOT-PROOF-CLASS)) (PROOF JUSTIFICATION)))"
     (CL:FUNCTION INSERT-WHYNOT-PROOF) NULL)
    (DEFINE-FUNCTION-OBJECT "BETTER-WHYNOT-PROOF-CLASS?"
     "(DEFUN (BETTER-WHYNOT-PROOF-CLASS? BOOLEAN) ((CLASS1 WHYNOT-PROOF-CLASS) (CLASS2 WHYNOT-PROOF-CLASS)))"
     (CL:FUNCTION BETTER-WHYNOT-PROOF-CLASS?) NULL)
    (DEFINE-FUNCTION-OBJECT "ALTERNATIVE-BINDINGS-SET?"
     "(DEFUN (ALTERNATIVE-BINDINGS-SET? BOOLEAN) ((THING OBJECT)) :GLOBALLY-INLINE? TRUE (RETURN (AND (DEFINED? THING) (ISA? THING @ALTERNATIVE-BINDINGS-SET))))"
     (CL:FUNCTION ALTERNATIVE-BINDINGS-SET?) NULL)
    (DEFINE-FUNCTION-OBJECT "ALTERNATIVE-BINDINGS"
     "(DEFUN (ALTERNATIVE-BINDINGS SET) ((BINDINGSSET ALTERNATIVE-BINDINGS-SET)) :GLOBALLY-INLINE? TRUE (RETURN (BINDINGS BINDINGSSET)))"
     (CL:FUNCTION ALTERNATIVE-BINDINGS) NULL)
    (DEFINE-FUNCTION-OBJECT "POST-PROCESS-WHYNOT-PROOF-CLASSES"
     "(DEFUN POST-PROCESS-WHYNOT-PROOF-CLASSES ((CLASSES (LIST OF WHYNOT-PROOF-CLASS))))"
     (CL:FUNCTION POST-PROCESS-WHYNOT-PROOF-CLASSES) NULL)
    (DEFINE-FUNCTION-OBJECT "CUTOFF-SIMILAR-WHYNOT-PROOFS"
     "(DEFUN CUTOFF-SIMILAR-WHYNOT-PROOFS ((QUERY QUERY-ITERATOR)))"
     (CL:FUNCTION CUTOFF-SIMILAR-WHYNOT-PROOFS) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (RETRIEVE-PARTIAL-SOLUTIONS QUERY-ITERATOR) ((SELF WHYNOT-PARTIAL-MATCH) (QUERY QUERY-ITERATOR)))"
     (CL:FUNCTION RETRIEVE-PARTIAL-SOLUTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "RETRIEVAL-PROOF-SOLUTION"
     "(DEFUN (RETRIEVAL-PROOF-SOLUTION CONS) ((PROOF JUSTIFICATION) (QUERY QUERY-ITERATOR)))"
     (CL:FUNCTION RETRIEVAL-PROOF-SOLUTION) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-FAILED-GOALS"
     "(DEFUN COLLECT-FAILED-GOALS ((PROOF JUSTIFICATION) (FAILURES (LIST OF JUSTIFICATION))))"
     (CL:FUNCTION COLLECT-FAILED-GOALS) NULL)
    (DEFINE-FUNCTION-OBJECT "DERIVE-JUSTIFIED-PARTIAL-QUERY"
     "(DEFUN (DERIVE-JUSTIFIED-PARTIAL-QUERY QUERY-ITERATOR) ((QUERY QUERY-ITERATOR)))"
     (CL:FUNCTION DERIVE-JUSTIFIED-PARTIAL-QUERY) NULL)
    (DEFINE-FUNCTION-OBJECT "WHYNOT"
     "(DEFUN WHYNOT (|&REST| (ARGS OBJECT)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
     (CL:FUNCTION %WHYNOT) (CL:FUNCTION WHYNOT-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "EXPLAIN-WHYNOT"
     "(DEFUN EXPLAIN-WHYNOT ((LABEL STRING) (STYLE KEYWORD) (MAXDEPTH INTEGER) (SUMMARY? BOOLEAN) (STREAM OUTPUT-STREAM)) :DOCUMENTATION \"Programmer's interface to the WHYNOT function.\" :PUBLIC? TRUE)"
     (CL:FUNCTION EXPLAIN-WHYNOT) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-WHYNOT-JUSTIFICATION"
     "(DEFUN PRINT-WHYNOT-JUSTIFICATION ((JUSTIFICATION JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAXDEPTH INTEGER) (STYLE KEYWORD) (SUMMARY? BOOLEAN)) :DOCUMENTATION \"Print a WHYNOT `justification' to `stream' according to
`maxDepth' and `style'.  Print a summary only if `summary?' is TRUE.\" :PUBLIC? TRUE)"
     (CL:FUNCTION PRINT-WHYNOT-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-WHYNOT-JUSTIFICATIONS"
     "(DEFUN (GET-WHYNOT-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ((QUERY QUERY-ITERATOR) (LABEL STRING) (MAPPING EXPLANATION-MAPPING)) :DOCUMENTATION \"Programmer's interface to WHYNOT function.  Derive
justifications why `query' failed, or, if `label' was supplied as non-NULL,
lookup its justification relative to `mapping' and return the result.\")"
     (CL:FUNCTION GET-WHYNOT-JUSTIFICATIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-WHYNOT"
     "(DEFUN STARTUP-WHYNOT () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-WHYNOT) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-WHYNOT-LOGIC-STARTUP-WHYNOT)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-WHYNOT-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupWhynot") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MIN-CLOCK-TICKS-PER-WHYNOT-ANTECEDENT* INTEGER 5)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *MAX-WHYNOT-PROOF-CLASS-DEVIATIONS* INTEGER 1)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SIMILAR-WHYNOT-PROOF-CUTOFF* INTEGER 3)")
    (REGISTER-NATIVE-NAME SYM-WHYNOT-LOGIC-WHYNOT
     KWD-WHYNOT-COMMON-LISP KWD-WHYNOT-FUNCTION))))
