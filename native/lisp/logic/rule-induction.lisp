;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997-2000              | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-RULE-INDUCTION-TOP-DOWN NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-SET-SIGNATURE-STRATEGY NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-COMMON-LISP NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-FUNCTION NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-SET-SIGNATURE-RULES NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-SET-RULE-INDUCTION-STRATEGY NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-SET-RECURSIVE-DECISION-NODES NULL)
(CL:DEFVAR SGT-RULE-INDUCTION-LOGIC-DECISION-TREE NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-FEATURE NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-FEATURE-INDEX NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-TRUTH-VALUE NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-CONCEPT NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-TRUE-BRANCH NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-FALSE-BRANCH NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-BOTTOM-UP NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-INDUCE-INFERENCE-RULES NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-?Y NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-=> NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-AND NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-BOTTOM-UP-RULE-INDUCTION NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-NOT NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-> NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-< NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA->= NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-=< NULL)
(CL:DEFVAR SGT-RULE-INDUCTION-STELLA-NUMBER-WRAPPER NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-FAIL NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-DECISION-TREE NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-TOP-DOWN-RULE-INDUCTION NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-USER-THING NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-EXISTS NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-TIMEOUT NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-DONT-OPTIMIZE? NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-TRUE NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-EVALUATE-RULE-INDUCTION NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-INDUCE-DECISION-RULES NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-INDUCE-DECISION-TREE NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-DEFRULE NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-FORALL NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-OR NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-NOT NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-AND NULL)
(CL:DEFVAR SGT-RULE-INDUCTION-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-RULE-INDUCTION-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-RULE-INDUCTION-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-RULE-INDUCTION-STELLA-CONS NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-STARTUP-RULE-INDUCTION NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *CONTEXT* ONE-WRAPPER ZERO-WRAPPER
  *MODULE* *FAIL-UNBOUND-CLAUSES* *TABOO-OPERATORS*
  *CASE-ANTECEDENT-TABLE* STANDARD-OUTPUT EOL *TRAINING-EXAMPLES*
  TRUE-WRAPPER FALSE-WRAPPER))

;;; (DEFGLOBAL *RULE-INDUCTION-STRATEGY* ...)

(CL:DEFVAR *RULE-INDUCTION-STRATEGY* NULL)

;;; (DEFGLOBAL *SIGNATURE-STRATEGY* ...)

(CL:DEFVAR *SIGNATURE-STRATEGY* NULL)

;;; (DEFUN SET-SIGNATURE-STRATEGY ...)

(CL:DEFUN %SET-SIGNATURE-STRATEGY (K)
  (CL:SETQ *SIGNATURE-STRATEGY* K))

(CL:DEFMACRO SET-SIGNATURE-STRATEGY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/SET-SIGNATURE-STRATEGY)) (CL:MACRO-FUNCTION (CL:QUOTE SET-SIGNATURE-STRATEGY)))

;;; (DEFGLOBAL *ENABLE-USER-THING* ...)

(CL:DEFVAR *ENABLE-USER-THING* TRUE)

;;; (DEFGLOBAL *OPTIMIZE-INDUCED-QUERIES* ...)

(CL:DEFVAR *OPTIMIZE-INDUCED-QUERIES* TRUE)

;;; (DEFGLOBAL *TRACE-ID3* ...)

(CL:DEFVAR *TRACE-ID3* FALSE)

;;; (DEFGLOBAL *TRACE-FOIL* ...)

(CL:DEFVAR *TRACE-FOIL* FALSE)

;;; (DEFGLOBAL *INDUCE-RULES-FROM-SIGNATURES* ...)

(CL:DEFVAR *INDUCE-RULES-FROM-SIGNATURES* TRUE)

;;; (DEFUN SET-SIGNATURE-RULES ...)

(CL:DEFUN %SET-SIGNATURE-RULES (B)
  (CL:SETQ *INDUCE-RULES-FROM-SIGNATURES* B))

(CL:DEFUN SET-SIGNATURE-RULES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-SIGNATURE-RULES (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-SIGNATURE-RULES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/SET-SIGNATURE-RULES)) (CL:MACRO-FUNCTION (CL:QUOTE SET-SIGNATURE-RULES)))

;;; (DEFGLOBAL *NUM-LGGS* ...)

(CL:PROGN (CL:DEFVAR *NUM-LGGS* 2000) (CL:DECLAIM (CL:TYPE CL:FIXNUM *NUM-LGGS*)))

;;; (DEFGLOBAL *ENFORCE-LINKED-VARIABLES* ...)

(CL:DEFVAR *ENFORCE-LINKED-VARIABLES* FALSE)

;;; (DEFGLOBAL *LOG-INDUCED-RULES* ...)

(CL:DEFVAR *LOG-INDUCED-RULES* FALSE)

;;; (DEFGLOBAL *ALLOW-RECURSIVE-DECISION-NODES* ...)

(CL:DEFVAR *ALLOW-RECURSIVE-DECISION-NODES* TRUE)

;;; (DEFGLOBAL *LOG-DECISION-RULE-CONSTRUCTION* ...)

(CL:DEFVAR *LOG-DECISION-RULE-CONSTRUCTION* FALSE)

;;; (DEFGLOBAL LOG_2 ...)

(CL:PROGN (CL:DEFVAR LOG_2 0.6931472d0) (CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT LOG_2)))

;;; (DEFUN SET-RULE-INDUCTION-STRATEGY ...)

(CL:DEFUN %SET-RULE-INDUCTION-STRATEGY (K)
  (CL:SETQ *RULE-INDUCTION-STRATEGY* K))

(CL:DEFMACRO SET-RULE-INDUCTION-STRATEGY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/SET-RULE-INDUCTION-STRATEGY)) (CL:MACRO-FUNCTION (CL:QUOTE SET-RULE-INDUCTION-STRATEGY)))

;;; (DEFUN SET-RECURSIVE-DECISION-NODES ...)

(CL:DEFUN %SET-RECURSIVE-DECISION-NODES (B)
  (CL:SETQ *ALLOW-RECURSIVE-DECISION-NODES* B))

(CL:DEFUN SET-RECURSIVE-DECISION-NODES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-RECURSIVE-DECISION-NODES (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-RECURSIVE-DECISION-NODES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/SET-RECURSIVE-DECISION-NODES)) (CL:MACRO-FUNCTION (CL:QUOTE SET-RECURSIVE-DECISION-NODES)))

;;; (DEFCLASS DECISION-TREE ...)

(CL:DEFCLASS DECISION-TREE (STANDARD-OBJECT)
  ((FEATURE :ALLOCATION :INSTANCE :ACCESSOR %FEATURE)
   (FEATURE-INDEX :ALLOCATION :INSTANCE :ACCESSOR %FEATURE-INDEX)
   (PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR %PROPOSITION)
   (TRUTH-VALUE :ALLOCATION :INSTANCE :ACCESSOR %TRUTH-VALUE)
   (CONCEPT :ALLOCATION :INSTANCE :ACCESSOR %CONCEPT)
   (TRUE-BRANCH :ALLOCATION :INSTANCE :ACCESSOR %TRUE-BRANCH)
   (FALSE-BRANCH :ALLOCATION :INSTANCE :ACCESSOR %FALSE-BRANCH)))

(CL:DEFUN NEW-DECISION-TREE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE DECISION-TREE)))
   (CL:SETF (%FALSE-BRANCH SELF) NULL) (CL:SETF (%TRUE-BRANCH SELF) NULL)
   (CL:SETF (%CONCEPT SELF) NULL) (CL:SETF (%TRUTH-VALUE SELF) FALSE)
   (CL:SETF (%PROPOSITION SELF) NULL)
   (CL:SETF (%FEATURE-INDEX SELF) NULL-INTEGER)
   (CL:SETF (%FEATURE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DECISION-TREE))
  SGT-RULE-INDUCTION-LOGIC-DECISION-TREE)

(CL:DEFUN ACCESS-DECISION-TREE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-RULE-INDUCTION-LOGIC-FEATURE)
    (CL:IF SETVALUE? (CL:SETF (%FEATURE SELF) VALUE)
     (CL:SETQ VALUE (%FEATURE SELF))))
   ((CL:EQ SLOTNAME SYM-RULE-INDUCTION-LOGIC-FEATURE-INDEX)
    (CL:IF SETVALUE?
     (CL:SETF (%FEATURE-INDEX SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%FEATURE-INDEX SELF)))))
   ((CL:EQ SLOTNAME SYM-RULE-INDUCTION-LOGIC-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-RULE-INDUCTION-LOGIC-TRUTH-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%TRUTH-VALUE SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%TRUTH-VALUE SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-RULE-INDUCTION-LOGIC-CONCEPT)
    (CL:IF SETVALUE? (CL:SETF (%CONCEPT SELF) VALUE)
     (CL:SETQ VALUE (%CONCEPT SELF))))
   ((CL:EQ SLOTNAME SYM-RULE-INDUCTION-LOGIC-TRUE-BRANCH)
    (CL:IF SETVALUE? (CL:SETF (%TRUE-BRANCH SELF) VALUE)
     (CL:SETQ VALUE (%TRUE-BRANCH SELF))))
   ((CL:EQ SLOTNAME SYM-RULE-INDUCTION-LOGIC-FALSE-BRANCH)
    (CL:IF SETVALUE? (CL:SETF (%FALSE-BRANCH SELF) VALUE)
     (CL:SETQ VALUE (%FALSE-BRANCH SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF DECISION-TREE) STREAM)
  (PRINT-DECISION-TREE SELF))

;;; (DEFGLOBAL *INDUCED-DECISION-RULES* ...)

(CL:DEFVAR *INDUCED-DECISION-RULES* NULL)

;;; (DEFGLOBAL *INDUCED-RULE-COUNTER* ...)

(CL:PROGN (CL:DEFVAR *INDUCED-RULE-COUNTER* 0) (CL:DECLAIM (CL:TYPE CL:FIXNUM *INDUCED-RULE-COUNTER*)))

;;; (DEFGLOBAL *CANDIDATE-CLAUSES* ...)

(CL:DEFVAR *CANDIDATE-CLAUSES* NULL)

;;; (DEFUN INDUCE-INFERENCE-RULES ...)

(CL:DEFUN %INDUCE-INFERENCE-RULES (RELATION-NAME CLASS-NAME)
  (CL:SETQ RELATION-NAME (PERMANENTIFY RELATION-NAME))
  (CLEAR-CASES)
  (CLEAR-TRAINING-EXAMPLES)
  (CL:SETQ *INDUCED-DECISION-RULES* (NEW-LIST))
  (CL:SETQ CLASS-NAME (PERMANENTIFY CLASS-NAME))
  (CL:LET*
   ((CLASS (%SURROGATE-VALUE-INVERSE (GET-DESCRIPTION CLASS-NAME)))
    (RELATION (%SURROGATE-VALUE-INVERSE (GET-DESCRIPTION RELATION-NAME)))
    (ILIST (LISTIFY (ALL-CLASS-INSTANCES CLASS))) (NUM (LENGTH ILIST))
    (START-TIME (GET-TICKTOCK)) (INSTANCES (NEW-VECTOR NUM)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM))
   (CL:LET*
    ((I NULL-INTEGER) (INSTANCE NULL) (ITER-000 (%THE-CONS-LIST ILIST))
     (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ INSTANCE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:LET ((SELF (%THE-ARRAY INSTANCES)) (VALUE INSTANCE) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:COND
    ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-TOP-DOWN)
     (CL:SETQ *ENABLE-USER-THING* TRUE)
     (CL:WHEN (CL:NOT *ALLOW-RECURSIVE-DECISION-NODES*)
      (INSERT-NEW *TABOO-OPERATORS* RELATION))
     (GENERATE-CLASSIFICATION-RULE INSTANCES RELATION-NAME CLASS-NAME
      TRUE)
     (CL:LET*
      ((CLAUSES
        (LOOKUP *CASE-ANTECEDENT-TABLE*
         (CONCATENATE (%SYMBOL-NAME CLASS-NAME) "-match"))))
      (CL:SETQ *CANDIDATE-CLAUSES* (NEW-VECTOR (LENGTH CLAUSES)))
      (CL:LET*
       ((I NULL-INTEGER) (CLAUSE NULL) (ITER-002 (%THE-CONS-LIST CLAUSES))
        (ITER-003 0))
       (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-003 I))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:PROGN (CL:SETQ CLAUSE (%%VALUE ITER-002))
         (CL:SETQ ITER-002 (%%REST ITER-002)))
        (CL:PROGN (CL:SETQ I ITER-003)
         (CL:SETQ ITER-003 (CL:1+ ITER-003)))
        (CL:LET
         ((SELF (%THE-ARRAY *CANDIDATE-CLAUSES*)) (VALUE CLAUSE)
          (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE)))))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "Generating Training Examples" EOL)
     (GENERATE-CLASSIFICATION-TRAINING-EXAMPLES INSTANCES RELATION
      *INDUCE-RULES-FROM-SIGNATURES*)
     (CL:SETQ *OPTIMIZE-INDUCED-QUERIES* TRUE)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "Generating Decision Rules" EOL)
     (%TOP-DOWN-RULE-INDUCTION *TRAINING-EXAMPLES*))
    ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-BOTTOM-UP)
     (CL:SETQ *ENABLE-USER-THING* FALSE)
     (GENERATE-TRAINING-EXAMPLES INSTANCES RELATION)
     (CL:SETQ *OPTIMIZE-INDUCED-QUERIES* TRUE)
     (%BOTTOM-UP-RULE-INDUCTION *TRAINING-EXAMPLES*))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
       *RULE-INDUCTION-STRATEGY* "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

(CL:DEFMACRO INDUCE-INFERENCE-RULES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/INDUCE-INFERENCE-RULES)) (CL:MACRO-FUNCTION (CL:QUOTE INDUCE-INFERENCE-RULES)))

;;; (DEFUN MODULAR-INDUCE-INFERENCE-RULES ...)

(CL:DEFUN MODULAR-INDUCE-INFERENCE-RULES (RELATION-NAME CLASS-NAME MODULES)
  (CLEAR-TRAINING-EXAMPLES)
  (CLEAR-CASES)
  (CL:LET*
   ((CLASS (%SURROGATE-VALUE-INVERSE (GET-DESCRIPTION CLASS-NAME)))
    (RELATION (%SURROGATE-VALUE-INVERSE (GET-DESCRIPTION RELATION-NAME)))
    (ILIST (NEW-LIST)) (HOME *MODULE*)
    (FAIL-UNBOUND *FAIL-UNBOUND-CLAUSES*) (NUM (LENGTH ILIST))
    (INSTANCE-VEC (NEW-VECTOR (LENGTH MODULES))) (INSTANCES NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM))
   (CL:SETQ *FAIL-UNBOUND-CLAUSES* TRUE)
   (CL:WHEN (CL:NOT *ALLOW-RECURSIVE-DECISION-NODES*)
    (INSERT-NEW *TABOO-OPERATORS* RELATION))
   (CL:COND
    ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-TOP-DOWN)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "Building Classification Rule" EOL)
     (CL:SETQ *ENABLE-USER-THING* TRUE)
     (CL:LET*
      ((J NULL-INTEGER) (MODULE NULL) (ITER-000 (%THE-CONS-LIST MODULES))
       (ITER-001 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 J))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ MODULE (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:PROGN (CL:SETQ J ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
       (CHANGE-MODULE MODULE)
       (CL:SETQ ILIST (LISTIFY (ALL-CLASS-INSTANCES CLASS)))
       (CL:SETQ NUM (LENGTH ILIST)) (CL:SETQ INSTANCES (NEW-VECTOR NUM))
       (CL:LET*
        ((I NULL-INTEGER) (INSTANCE NULL)
         (ITER-002 (%THE-CONS-LIST ILIST)) (ITER-003 0))
        (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-003 I))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
         (CL:PROGN (CL:SETQ INSTANCE (%%VALUE ITER-002))
          (CL:SETQ ITER-002 (%%REST ITER-002)))
         (CL:PROGN (CL:SETQ I ITER-003)
          (CL:SETQ ITER-003 (CL:1+ ITER-003)))
         (CL:LET
          ((SELF (%THE-ARRAY INSTANCES)) (VALUE INSTANCE) (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))))
       (CL:LET
        ((SELF (%THE-ARRAY INSTANCE-VEC)) (VALUE INSTANCES) (POSITION J))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (GENERATE-CLASSIFICATION-RULE INSTANCES RELATION-NAME CLASS-NAME
        FALSE)))
     (CHANGE-MODULE HOME)
     (BUILD-CLASSIFICATION-RULE RELATION-NAME CLASS-NAME)
     (CL:LET*
      ((CLAUSES
        (LOOKUP *CASE-ANTECEDENT-TABLE*
         (CONCATENATE (%SYMBOL-NAME CLASS-NAME) "-match"))))
      (CL:SETQ *CANDIDATE-CLAUSES* (NEW-VECTOR (LENGTH CLAUSES)))
      (CL:LET*
       ((I NULL-INTEGER) (CLAUSE NULL) (ITER-004 (%THE-CONS-LIST CLAUSES))
        (ITER-005 0))
       (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-005 I))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
        (CL:PROGN (CL:SETQ CLAUSE (%%VALUE ITER-004))
         (CL:SETQ ITER-004 (%%REST ITER-004)))
        (CL:PROGN (CL:SETQ I ITER-005)
         (CL:SETQ ITER-005 (CL:1+ ITER-005)))
        (CL:LET
         ((SELF (%THE-ARRAY *CANDIDATE-CLAUSES*)) (VALUE CLAUSE)
          (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE)))))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "Generating Training Examples" EOL)
     (CL:LET*
      ((VEC NULL) (MODULE NULL) (ITER-006 (%THE-CONS-LIST MODULES))
       (VECTOR-000 INSTANCE-VEC) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE
       (CL:AND (CL:NOT (CL:EQ ITER-006 NIL)) (CL:< INDEX-000 LENGTH-000))
       DO
       (CL:PROGN (CL:SETQ MODULE (%%VALUE ITER-006))
        (CL:SETQ ITER-006 (%%REST ITER-006)))
       (CL:PROGN
        (CL:SETQ VEC
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
       (CHANGE-MODULE MODULE)
       (GENERATE-CLASSIFICATION-TRAINING-EXAMPLES VEC RELATION TRUE)))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "Generating Inference Rules" EOL)
     (%TOP-DOWN-RULE-INDUCTION *TRAINING-EXAMPLES*)
     (CL:SETQ *FAIL-UNBOUND-CLAUSES* FAIL-UNBOUND))
    ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-BOTTOM-UP)
     (CL:SETQ *ENABLE-USER-THING* FALSE)
     (CL:LET*
      ((VEC NULL) (MODULE NULL) (ITER-007 (%THE-CONS-LIST MODULES))
       (VECTOR-001 INSTANCE-VEC) (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
      (CL:LOOP WHILE
       (CL:AND (CL:NOT (CL:EQ ITER-007 NIL)) (CL:< INDEX-001 LENGTH-001))
       DO
       (CL:PROGN (CL:SETQ MODULE (%%VALUE ITER-007))
        (CL:SETQ ITER-007 (%%REST ITER-007)))
       (CL:PROGN
        (CL:SETQ VEC
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (CHANGE-MODULE MODULE)
       (GENERATE-TRAINING-EXAMPLES INSTANCES RELATION)))
     (CL:SETQ *OPTIMIZE-INDUCED-QUERIES* TRUE)
     (%BOTTOM-UP-RULE-INDUCTION *TRAINING-EXAMPLES*))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
       *RULE-INDUCTION-STRATEGY* "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN BOTTOM-UP-RULE-INDUCTION ...)

(CL:DEFUN %BOTTOM-UP-RULE-INDUCTION (EXAMPLES)
  (CL:LET*
   ((POSITIVE (NEW-LIST)) (NEGATIVE (NEW-LIST)) (RULES (NEW-LIST))
    (CONCEPT (%CONCEPT (FIRST EXAMPLES))) (RULE NIL))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:IF (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (%OUTPUT EXAMPLE))
      (PUSH POSITIVE EXAMPLE) (PUSH NEGATIVE EXAMPLE))))
   (COLLECT-FACTS-IN-EXAMPLES POSITIVE)
   (CL:LET* ((EXAMPLE NULL) (ITER-001 (%THE-CONS-LIST POSITIVE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:SETF (%FACTS EXAMPLE)
      (SUBSTITUTE-CONS-TREE (%FACTS EXAMPLE) SYM-RULE-INDUCTION-LOGIC-?Y
       (%NAME EXAMPLE)))))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "Starting rule induction with " (LENGTH POSITIVE) " positive and "
    (LENGTH NEGATIVE) " negative examples" EOL)
   (CL:LOOP WHILE (CL:NOT (EMPTY? POSITIVE)) DO
    (CL:SETQ RULE (LEARN-ONE-RULE-BOTTOM-UP POSITIVE NEGATIVE))
    (CL:IF (CL:EQ RULE NIL)
     (CL:PROGN
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Quiting with "
       (LENGTH POSITIVE) " examples uncovered" EOL)
      (CL:RETURN))
     (PUSH RULES
      (LIST* SYM-RULE-INDUCTION-STELLA-=>
       (CONS SYM-RULE-INDUCTION-STELLA-AND
        (CONCATENATE (COPY-CONS-TREE RULE) NIL))
       (CONS CONCEPT (CONS SYM-RULE-INDUCTION-LOGIC-?Y NIL)) NIL))))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
    "PowerLoom has induced the following rules" EOL EOL)
   (CL:WHEN (CL:NOT (CL:EQ RULES NULL))
    (CL:LET* ((RULE NULL) (ITER-002 (%THE-CONS-LIST RULES)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:PROGN (CL:SETQ RULE (%%VALUE ITER-002))
       (CL:SETQ ITER-002 (%%REST ITER-002)))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) RULE EOL)))
    (CL:SETQ *INDUCED-DECISION-RULES* RULES))))

(CL:DEFMACRO BOTTOM-UP-RULE-INDUCTION (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/BOTTOM-UP-RULE-INDUCTION)) (CL:MACRO-FUNCTION (CL:QUOTE BOTTOM-UP-RULE-INDUCTION)))

;;; (DEFUN (LEARN-ONE-RULE-BOTTOM-UP (CONS OF CONS)) ...)

(CL:DEFUN LEARN-ONE-RULE-BOTTOM-UP (POSITIVE NEGATIVE)
  (CL:LET*
   ((LGG NIL) (RULE NIL) (SCORE 0) (NUM-POSITIVE (LENGTH POSITIVE))
    (INDEX1 0) (INDEX2 0) (FACTS1 NIL) (FACTS2 NIL) (MAX 0) (COVER 0)
    (NUM-LGGS (CL:* (LENGTH POSITIVE) 5)) (BEST-LGG NIL))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM SCORE NUM-POSITIVE INDEX1 INDEX2 MAX COVER
     NUM-LGGS))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "Learning rule bottom up over " (LENGTH POSITIVE) " positives" EOL)
   (CL:SETQ MAX 0) (CL:SETQ BEST-LGG NIL)
   (CL:WHEN (CL:= (LENGTH POSITIVE) 1)
    (CL:SETQ RULE (%FACTS (FIRST POSITIVE))) (POP POSITIVE)
    (CL:RETURN-FROM LEARN-ONE-RULE-BOTTOM-UP RULE))
   (CL:LOOP WHILE (CL:OR (CL:> MAX 0) (CL:EQ RULE NIL)) DO
    (CL:SETQ COVER (CL:+ MAX COVER))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "   Current rule covers " COVER " positive examples" EOL)
    (CL:WHEN (CL:NOT (CL:EQ RULE NIL))
     (REMOVE-COVERED-EXAMPLES RULE POSITIVE))
    (CL:SETQ NUM-LGGS (CL:* (LENGTH POSITIVE) 5))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 NUM-LGGS)
      (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
     (CL:LOOP WHILE
      (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
      (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
      (CL:SETQ INDEX1 (RANDOM (LENGTH POSITIVE)))
      (CL:SETQ FACTS1 (%FACTS (NTH POSITIVE INDEX1)))
      (CL:IF (CL:EQ RULE NIL)
       (CL:PROGN (CL:SETQ INDEX2 (RANDOM (LENGTH POSITIVE)))
        (CL:LOOP WHILE (CL:= INDEX1 INDEX2) DO
         (CL:SETQ INDEX2 (RANDOM (LENGTH POSITIVE))))
        (CL:SETQ FACTS2 (%FACTS (NTH POSITIVE INDEX2))))
       (CL:SETQ FACTS2 RULE))
      (CL:SETQ LGG (LEAST-GENERAL-GENERALIZATION FACTS1 FACTS2))
      (CL:WHEN (CL:NOT (RULE-COVERS-ANY-EXAMPLE? LGG NEGATIVE))
       (CL:SETQ SCORE (NUM-EXAMPLES-COVERED LGG POSITIVE))
       (CL:WHEN (CL:> SCORE MAX)
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   Best covers "
         SCORE " positives" EOL)
        (CL:SETQ BEST-LGG LGG)
        (CL:WHEN (CL:= (CL:+ COVER SCORE) NUM-POSITIVE)
         (REMOVE-COVERED-EXAMPLES LGG POSITIVE)
         (CL:RETURN-FROM LEARN-ONE-RULE-BOTTOM-UP LGG))
        (CL:SETQ MAX SCORE)))))
    (CL:SETQ RULE BEST-LGG))
   RULE))

;;; (DEFGLOBAL *BOTTOM-UP-VARIABLE-COUNTER* ...)

(CL:PROGN (CL:DEFVAR *BOTTOM-UP-VARIABLE-COUNTER* 0) (CL:DECLAIM (CL:TYPE CL:FIXNUM *BOTTOM-UP-VARIABLE-COUNTER*)))

;;; (DEFUN (LEAST-GENERAL-GENERALIZATION CONS) ...)

(CL:DEFUN LEAST-GENERAL-GENERALIZATION (CLAUSE1 CLAUSE2)
  (CL:LET*
   ((MATCHES (NEW-LIST)) (PROBE NIL) (OPERATOR NULL) (BINDINGS (NEW-LIST))
    (NEW-CLAUSE NIL)
    (VARS1 (GET-VARIABLES-FROM-CONS-PROPOSITIONS (CONS-LIST CLAUSE1)))
    (VARS2 (GET-VARIABLES-FROM-CONS-PROPOSITIONS (CONS-LIST CLAUSE2)))
    (NOT? FALSE) (VAR NULL) (RESULT NIL))
   (CL:LET*
    ((I NULL-INTEGER) (VAR NULL) (ITER-000 (%THE-CONS-LIST VARS1))
     (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ VAR (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:WHEN (CL:NOT (CL:EQ VAR SYM-RULE-INDUCTION-LOGIC-?Y))
      (CL:SETQ CLAUSE1
       (SUBSTITUTE-CONS-TREE CLAUSE1 VAR
        (INTERN-SYMBOL
         (CONCATENATE "?A" (STRINGIFY (WRAP-INTEGER I)))))))))
   (CL:LET*
    ((I NULL-INTEGER) (VAR NULL) (ITER-002 (%THE-CONS-LIST VARS2))
     (ITER-003 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-003 I))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:PROGN (CL:SETQ VAR (%%VALUE ITER-002))
      (CL:SETQ ITER-002 (%%REST ITER-002)))
     (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
     (CL:WHEN (CL:NOT (CL:EQ VAR SYM-RULE-INDUCTION-LOGIC-?Y))
      (CL:SETQ CLAUSE2
       (SUBSTITUTE-CONS-TREE CLAUSE1 VAR
        (INTERN-SYMBOL
         (CONCATENATE "?B" (STRINGIFY (WRAP-INTEGER I)))))))))
   (CL:SETQ *BOTTOM-UP-VARIABLE-COUNTER* 0)
   (CL:LET* ((CLAUSE NULL) (ITER-004 (COPY-CONS-TREE CLAUSE1)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
     (CL:PROGN (CL:SETQ CLAUSE (%%VALUE ITER-004))
      (CL:SETQ ITER-004 (%%REST ITER-004)))
     (CL:IF (CL:EQ (%%VALUE CLAUSE) SYM-RULE-INDUCTION-STELLA-NOT)
      (CL:PROGN (CL:SETQ NOT? TRUE)
       (CL:SETQ PROBE (%%VALUE (%%REST CLAUSE))))
      (CL:PROGN (CL:SETQ NOT? FALSE) (CL:SETQ PROBE CLAUSE)))
     (CL:SETQ OPERATOR (%%VALUE PROBE)) (CL:SETQ MATCHES (NEW-LIST))
     (CL:LET* ((POTENTIAL-MATCH NULL) (ITER-005 (COPY-CONS-TREE CLAUSE2)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
       (CL:PROGN (CL:SETQ POTENTIAL-MATCH (%%VALUE ITER-005))
        (CL:SETQ ITER-005 (%%REST ITER-005)))
       (CL:WHEN
        (CL:AND NOT?
         (CL:EQ (%%VALUE POTENTIAL-MATCH) SYM-RULE-INDUCTION-STELLA-NOT)
         (CL:EQ (%%VALUE (%%VALUE (%%REST POTENTIAL-MATCH))) OPERATOR))
        (PUSH MATCHES (%%VALUE (%%REST POTENTIAL-MATCH))))
       (CL:WHEN
        (CL:AND (CL:NOT NOT?) (CL:EQ (%%VALUE POTENTIAL-MATCH) OPERATOR))
        (PUSH MATCHES POTENTIAL-MATCH))))
     (CL:WHEN (CL:NOT (EMPTY? MATCHES))
      (CL:LET* ((MATCH NULL) (ITER-006 (%THE-CONS-LIST MATCHES)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
        (CL:PROGN (CL:SETQ MATCH (%%VALUE ITER-006))
         (CL:SETQ ITER-006 (%%REST ITER-006)))
        (CL:COND
         ((CL:OR (CL:EQ OPERATOR SYM-RULE-INDUCTION-STELLA->)
           (CL:EQ OPERATOR SYM-RULE-INDUCTION-STELLA-<)
           (CL:EQ OPERATOR SYM-RULE-INDUCTION-STELLA->=)
           (CL:EQ OPERATOR SYM-RULE-INDUCTION-STELLA-=<))
          (CL:SETQ NEW-CLAUSE
           (GENERALIZE-INEQUALITY PROBE MATCH BINDINGS)))
         (CL:T (CL:SETQ NEW-CLAUSE (CONS OPERATOR NIL))
          (CL:LET*
           ((ARG2 NULL) (ARG1 NULL) (ITER-007 (%%REST PROBE))
            (ITER-008 (%%REST MATCH)))
           (CL:LOOP WHILE
            (CL:AND (CL:NOT (CL:EQ ITER-007 NIL))
             (CL:NOT (CL:EQ ITER-008 NIL)))
            DO
            (CL:PROGN (CL:SETQ ARG1 (%%VALUE ITER-007))
             (CL:SETQ ITER-007 (%%REST ITER-007)))
            (CL:PROGN (CL:SETQ ARG2 (%%VALUE ITER-008))
             (CL:SETQ ITER-008 (%%REST ITER-008)))
            (CL:IF (CL:NOT (EQUAL-CONS-TREES? ARG1 ARG2))
             (CL:PROGN
              (CL:SETQ VAR
               (LOOKUP-VARIABLE-IN-BINDINGS ARG1 ARG2 BINDINGS))
              (CL:WHEN (CL:EQ VAR NULL)
               (CL:SETQ VAR
                (INTERN-SYMBOL
                 (CONCATENATE "?X"
                  (STRINGIFY
                   (WRAP-INTEGER *BOTTOM-UP-VARIABLE-COUNTER*)))))
               (CL:WHEN (CL:NOT (EITHER-NUMBERS? ARG1 ARG2))
                (PUSH BINDINGS (CONS-LIST ARG1 ARG2 VAR)))
               (CL:SETQ *BOTTOM-UP-VARIABLE-COUNTER*
                (CL:1+ *BOTTOM-UP-VARIABLE-COUNTER*)))
              (CL:SETQ NEW-CLAUSE (CONS VAR NEW-CLAUSE)))
             (CL:SETQ NEW-CLAUSE (CONS ARG1 NEW-CLAUSE)))))
          (CL:SETQ NEW-CLAUSE (REVERSE NEW-CLAUSE))))
        (CL:WHEN NOT?
         (CL:SETQ NEW-CLAUSE
          (LIST* SYM-RULE-INDUCTION-STELLA-NOT NEW-CLAUSE NIL)))
        (CL:SETQ RESULT (CONS NEW-CLAUSE RESULT)))))))
   (REMOVE-REDUNDANT-CLAUSES (REVERSE RESULT))))

;;; (DEFUN (GENERALIZE-INEQUALITY CONS) ...)

(CL:DEFUN GENERALIZE-INEQUALITY (PROBE MATCH BINDINGS)
  (CL:LET*
   ((OPERATOR (%%VALUE PROBE)) (NEW-CLAUSE (CONS-LIST OPERATOR))
    (VAR NULL))
   (CL:LET*
    ((ARG2 NULL) (ARG1 NULL) (ITER-000 (%%REST PROBE))
     (ITER-001 (%%REST MATCH)))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:NOT (CL:EQ ITER-001 NIL)))
     DO
     (CL:PROGN (CL:SETQ ARG1 (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ ARG2 (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:IF (CL:NOT (EQUAL-CONS-TREES? ARG1 ARG2))
      (CL:IF (BOTH-NUMBERS? ARG1 ARG2)
       (CL:LET* ((TEST-VALUE-000 OPERATOR))
        (CL:COND
         ((CL:OR (CL:EQ TEST-VALUE-000 SYM-RULE-INDUCTION-STELLA->)
           (CL:EQ TEST-VALUE-000 SYM-RULE-INDUCTION-STELLA->=))
          (CL:SETQ NEW-CLAUSE
           (CONS
            (WRAP-INTEGER
             (MIN (%WRAPPER-VALUE ARG1) (%WRAPPER-VALUE ARG2)))
            NEW-CLAUSE)))
         ((CL:OR (CL:EQ TEST-VALUE-000 SYM-RULE-INDUCTION-STELLA-<)
           (CL:EQ TEST-VALUE-000 SYM-RULE-INDUCTION-STELLA-=<))
          (CL:SETQ NEW-CLAUSE
           (CONS
            (WRAP-INTEGER
             (MAX (%WRAPPER-VALUE ARG1) (%WRAPPER-VALUE ARG2)))
            NEW-CLAUSE)))
         (CL:T
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
           "Bug in generalize-inequality." EOL))))
       (CL:PROGN
        (CL:SETQ VAR (LOOKUP-VARIABLE-IN-BINDINGS ARG1 ARG2 BINDINGS))
        (CL:WHEN (CL:EQ VAR NULL)
         (CL:SETQ VAR
          (INTERN-SYMBOL
           (CONCATENATE "?X"
            (STRINGIFY (WRAP-INTEGER *BOTTOM-UP-VARIABLE-COUNTER*)))))
         (CL:WHEN (CL:NOT (EITHER-NUMBERS? ARG1 ARG2))
          (PUSH BINDINGS (CONS-LIST ARG1 ARG2 VAR)))
         (CL:SETQ *BOTTOM-UP-VARIABLE-COUNTER*
          (CL:1+ *BOTTOM-UP-VARIABLE-COUNTER*)))
        (CL:SETQ NEW-CLAUSE (CONS VAR NEW-CLAUSE))))
      (CL:SETQ NEW-CLAUSE (CONS ARG1 NEW-CLAUSE)))))
   (REVERSE NEW-CLAUSE)))

;;; (DEFUN (BOTH-NUMBERS? BOOLEAN) ...)

(CL:DEFUN BOTH-NUMBERS? (T1 T2)
  (CL:IF
   (CL:AND (ISA? T1 SGT-RULE-INDUCTION-STELLA-NUMBER-WRAPPER)
    (ISA? T2 SGT-RULE-INDUCTION-STELLA-NUMBER-WRAPPER))
   TRUE FALSE))

;;; (DEFUN (EITHER-NUMBERS? BOOLEAN) ...)

(CL:DEFUN EITHER-NUMBERS? (T1 T2)
  (CL:IF
   (CL:OR (ISA? T1 SGT-RULE-INDUCTION-STELLA-NUMBER-WRAPPER)
    (ISA? T2 SGT-RULE-INDUCTION-STELLA-NUMBER-WRAPPER))
   TRUE FALSE))

;;; (DEFUN (REMOVE-REDUNDANT-CLAUSES (CONS OF CONS)) ...)

(CL:DEFUN REMOVE-REDUNDANT-CLAUSES (CLAUSES)
  (CL:LET*
   ((RESULT NIL) (TRUE-TABLE (NEW-HASH-TABLE))
    (NOT-TABLE (NEW-HASH-TABLE)) (ENTRIES NULL)
    (SHARED-VARIABLES (NEW-LIST)) (KNOWN-VARIABLES (NEW-LIST))
    (OPERATOR NULL) (SUBSUMED? FALSE) (OPERATORS (NEW-LIST)))
   (CL:LET* ((CLAUSE NULL) (ITER-000 (COPY-CONS-TREE CLAUSES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ CLAUSE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:IF (CL:EQ (%%VALUE CLAUSE) SYM-RULE-INDUCTION-STELLA-NOT)
      (CL:PROGN (CL:SETQ OPERATOR (%%VALUE (%%VALUE (%%REST CLAUSE))))
       (INSERT-NEW OPERATORS OPERATOR)
       (CL:SETQ ENTRIES (LOOKUP NOT-TABLE OPERATOR))
       (CL:WHEN (CL:EQ ENTRIES NULL) (CL:SETQ ENTRIES (NEW-LIST)))
       (PUSH ENTRIES (%%VALUE (%%REST CLAUSE)))
       (INSERT-AT NOT-TABLE OPERATOR ENTRIES))
      (CL:PROGN (CL:SETQ OPERATOR (%%VALUE CLAUSE))
       (INSERT-NEW OPERATORS OPERATOR)
       (CL:SETQ ENTRIES (LOOKUP TRUE-TABLE OPERATOR))
       (CL:WHEN (CL:EQ ENTRIES NULL) (CL:SETQ ENTRIES (NEW-LIST)))
       (PUSH ENTRIES CLAUSE) (INSERT-AT TRUE-TABLE OPERATOR ENTRIES)))
     (CL:LET*
      ((V NULL)
       (ITER-001
        (%THE-CONS-LIST
         (GET-VARIABLES-FROM-CONS-PROPOSITIONS (CONS-LIST CLAUSE)))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:PROGN (CL:SETQ V (%%VALUE ITER-001))
        (CL:SETQ ITER-001 (%%REST ITER-001)))
       (CL:IF (MEMBER? KNOWN-VARIABLES V) (INSERT-NEW SHARED-VARIABLES V)
        (PUSH KNOWN-VARIABLES V))))))
   (CL:LET* ((OPERATOR NULL) (ITER-002 (%THE-CONS-LIST OPERATORS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:PROGN (CL:SETQ OPERATOR (%%VALUE ITER-002))
      (CL:SETQ ITER-002 (%%REST ITER-002)))
     (CL:SETQ ENTRIES (LOOKUP TRUE-TABLE OPERATOR))
     (CL:WHEN (CL:NOT (CL:EQ ENTRIES NULL))
      (CL:LET* ((CLAUSE1 NULL) (ITER-003 (%THE-CONS-LIST ENTRIES)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
        (CL:PROGN (CL:SETQ CLAUSE1 (%%VALUE ITER-003))
         (CL:SETQ ITER-003 (%%REST ITER-003)))
        (CL:SETQ SUBSUMED? FALSE)
        (CL:LET* ((CLAUSE2 NULL) (ITER-004 (%THE-CONS-LIST ENTRIES)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
          (CL:PROGN (CL:SETQ CLAUSE2 (%%VALUE ITER-004))
           (CL:SETQ ITER-004 (%%REST ITER-004)))
          (CL:WHEN (CL:NOT (CL:EQ CLAUSE1 CLAUSE2))
           (CL:SETQ SUBSUMED? TRUE)
           (CL:LET*
            ((ARG2 NULL) (ARG1 NULL) (ITER-005 (%%REST CLAUSE1))
             (ITER-006 (%%REST CLAUSE2)))
            (CL:LOOP WHILE
             (CL:AND (CL:NOT (CL:EQ ITER-005 NIL))
              (CL:NOT (CL:EQ ITER-006 NIL)))
             DO
             (CL:PROGN (CL:SETQ ARG1 (%%VALUE ITER-005))
              (CL:SETQ ITER-005 (%%REST ITER-005)))
             (CL:PROGN (CL:SETQ ARG2 (%%VALUE ITER-006))
              (CL:SETQ ITER-006 (%%REST ITER-006)))
             (CL:WHEN
              (CL:AND (CL:NOT (EQUAL-CONS-TREES? ARG1 ARG2))
               (CL:OR
                (CL:AND (SYMBOL? ARG1) (MEMBER? SHARED-VARIABLES ARG1))
                (CONS? ARG1)))
              (CL:SETQ SUBSUMED? FALSE) (CL:RETURN))))
           (CL:WHEN SUBSUMED? (CL:RETURN)))))
        (CL:WHEN (CL:NOT SUBSUMED?)
         (CL:SETQ RESULT (CONS CLAUSE1 RESULT))))))
     (CL:SETQ ENTRIES (LOOKUP NOT-TABLE OPERATOR))
     (CL:WHEN (CL:NOT (CL:EQ ENTRIES NULL))
      (CL:LET* ((CLAUSE1 NULL) (ITER-007 (%THE-CONS-LIST ENTRIES)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-007 NIL)) DO
        (CL:PROGN (CL:SETQ CLAUSE1 (%%VALUE ITER-007))
         (CL:SETQ ITER-007 (%%REST ITER-007)))
        (CL:SETQ SUBSUMED? FALSE)
        (CL:LET* ((CLAUSE2 NULL) (ITER-008 (%THE-CONS-LIST ENTRIES)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-008 NIL)) DO
          (CL:PROGN (CL:SETQ CLAUSE2 (%%VALUE ITER-008))
           (CL:SETQ ITER-008 (%%REST ITER-008)))
          (CL:WHEN (CL:NOT (CL:EQ CLAUSE1 CLAUSE2))
           (CL:SETQ SUBSUMED? TRUE)
           (CL:LET*
            ((ARG2 NULL) (ARG1 NULL) (ITER-009 (%%REST CLAUSE1))
             (ITER-010 (%%REST CLAUSE2)))
            (CL:LOOP WHILE
             (CL:AND (CL:NOT (CL:EQ ITER-009 NIL))
              (CL:NOT (CL:EQ ITER-010 NIL)))
             DO
             (CL:PROGN (CL:SETQ ARG1 (%%VALUE ITER-009))
              (CL:SETQ ITER-009 (%%REST ITER-009)))
             (CL:PROGN (CL:SETQ ARG2 (%%VALUE ITER-010))
              (CL:SETQ ITER-010 (%%REST ITER-010)))
             (CL:WHEN
              (CL:AND (CL:NOT (EQUAL-CONS-TREES? ARG1 ARG2))
               (CL:OR
                (CL:AND (SYMBOL? ARG1) (MEMBER? SHARED-VARIABLES ARG1))
                (CONS? ARG1)))
              (CL:SETQ SUBSUMED? FALSE) (CL:RETURN))))
           (CL:WHEN SUBSUMED? (CL:RETURN)))))
        (CL:WHEN (CL:NOT SUBSUMED?)
         (CL:SETQ RESULT
          (CONS (LIST* SYM-RULE-INDUCTION-STELLA-NOT CLAUSE1 NIL)
           RESULT))))))))
   RESULT))

;;; (DEFUN (LOOKUP-VARIABLE-IN-BINDINGS OBJECT) ...)

(CL:DEFUN LOOKUP-VARIABLE-IN-BINDINGS (OBJ1 OBJ2 BINDINGS)
  (CL:LET* ((BIND NULL) (ITER-000 (%THE-CONS-LIST BINDINGS)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ BIND (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN
     (CL:AND (EQUAL-CONS-TREES? (%%VALUE BIND) OBJ1)
      (EQUAL-CONS-TREES? (%%VALUE (%%REST BIND)) OBJ2))
     (CL:RETURN-FROM LOOKUP-VARIABLE-IN-BINDINGS
      (%%VALUE (%%REST (%%REST BIND)))))))
  (CL:WHEN (CL:AND (CONS? OBJ1) (CONS? OBJ2))
   (CL:LET* ((ANSWER NIL) (BIND NULL))
    (CL:LET* ((ARG2 NULL) (ARG1 NULL) (ITER-001 OBJ1) (ITER-002 OBJ2))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL)))
      DO
      (CL:PROGN (CL:SETQ ARG1 (%%VALUE ITER-001))
       (CL:SETQ ITER-001 (%%REST ITER-001)))
      (CL:PROGN (CL:SETQ ARG2 (%%VALUE ITER-002))
       (CL:SETQ ITER-002 (%%REST ITER-002)))
      (CL:IF (EQL? ARG1 ARG2) (CL:SETQ ANSWER (CONS ARG1 ANSWER))
       (CL:PROGN
        (CL:SETQ BIND (LOOKUP-VARIABLE-IN-BINDINGS ARG1 ARG2 BINDINGS))
        (CL:WHEN (CL:EQ BIND NULL)
         (CL:RETURN-FROM LOOKUP-VARIABLE-IN-BINDINGS NULL))
        (CL:SETQ ANSWER (CONS BIND ANSWER))))))
    (CL:RETURN-FROM LOOKUP-VARIABLE-IN-BINDINGS (REVERSE ANSWER))))
  NULL)

;;; (DEFUN (LEARN-ONE-RULE-BOTTOM-UP-FROM-SIGNATURES (CONS OF CONS)) ...)

(CL:DEFUN LEARN-ONE-RULE-BOTTOM-UP-FROM-SIGNATURES (POSITIVE NEGATIVE COVERED CONS-PROPS)
  (CL:LET*
   ((TEMP-POSITIVE (COPY POSITIVE)) (MAX 0) (COVER 0) (INDEX1 0)
    (INDEX2 0) (VEC-SIZE (LENGTH (%INPUT (FIRST NEGATIVE))))
    (INDICES NULL) (BEST-INDICES (NEW-LIST)) (LGG NULL) (SIG1 NULL)
    (SIG2 NULL) (STOP FALSE) (RESULT NIL) (SCORE 0) (NUM-LGGS 0))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM MAX COVER INDEX1 INDEX2 VEC-SIZE SCORE NUM-LGGS))
   (CL:LOOP WHILE (CL:OR (CL:> MAX 0) (CL:EQ LGG NULL)) DO
    (CL:SETQ COVER (CL:+ COVER MAX))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "   Current rule covers " COVER " positive examples" EOL)
    (CL:WHEN (CL:NOT (CL:EQ LGG NULL))
     (CL:LET*
      ((EXAMPLE NULL)
       (ITER-000
        (%THE-CONS-LIST
         (REMOVE-SIGNATURE-COVERED-EXAMPLES BEST-INDICES TEMP-POSITIVE))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (PUSH COVERED EXAMPLE))))
    (CL:SETQ NUM-LGGS (CL:* (LENGTH TEMP-POSITIVE) 1)) (CL:SETQ MAX 0)
    (CL:LET*
     ((I NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-000 NUM-LGGS)
      (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 UPPER-BOUND-000 I))
     (CL:LOOP WHILE
      (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)) DO
      (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
      (CL:SETQ INDEX1 (RANDOM (LENGTH TEMP-POSITIVE)))
      (CL:SETQ SIG1 (%INPUT (NTH TEMP-POSITIVE INDEX1)))
      (CL:IF (CL:EQ LGG NULL)
       (CL:PROGN (CL:SETQ INDEX2 (RANDOM (LENGTH TEMP-POSITIVE)))
        (CL:LOOP WHILE (CL:= INDEX1 INDEX2) DO
         (CL:SETQ INDEX2 (RANDOM (LENGTH TEMP-POSITIVE))))
        (CL:SETQ SIG2 (%INPUT (NTH TEMP-POSITIVE INDEX2))))
       (CL:SETQ SIG2 LGG))
      (CL:SETQ INDICES (INTERSECT-SIGNATURES SIG1 SIG2))
      (CL:WHEN
       (CL:NOT (SIGNATURE-INDICES-COVER-ANY-EXAMPLE? INDICES NEGATIVE))
       (CL:SETQ SCORE
        (NUM-SIGNATURE-INDICES-COVERED INDICES TEMP-POSITIVE))
       (CL:WHEN (CL:> SCORE MAX)
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "    New best: "
         SCORE " examples" EOL)
        (CL:SETQ BEST-INDICES INDICES) (CL:SETQ MAX SCORE)))))
    (CL:SETQ LGG (NEW-VECTOR VEC-SIZE))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-001 (CL:1- VEC-SIZE)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-002 UPPER-BOUND-001 I))
     (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-001) DO
      (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
      (CL:LET
       ((SELF (%THE-ARRAY LGG)) (VALUE (WRAP-INTEGER 2)) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))))
    (CL:LET* ((INDEX NULL) (ITER-003 (%THE-CONS-LIST BEST-INDICES)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
      (CL:PROGN (CL:SETQ INDEX (%%VALUE ITER-003))
       (CL:SETQ ITER-003 (%%REST ITER-003)))
      (CL:IF (CL:> (%WRAPPER-VALUE INDEX) 0)
       (CL:LET
        ((SELF (%THE-ARRAY LGG)) (VALUE (WRAP-INTEGER 1))
         (POSITION (CL:1- (%WRAPPER-VALUE INDEX))))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:LET
        ((SELF (%THE-ARRAY LGG)) (VALUE (WRAP-INTEGER 0))
         (POSITION (CL:1- (CL:- 0 (%WRAPPER-VALUE INDEX)))))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))))))
   (CL:LOOP WHILE STOP DO (CL:SETQ STOP TRUE)
    (CL:LET*
     ((INDEX NULL) (ITER-004 (%THE-CONS-LIST (COPY BEST-INDICES))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
      (CL:PROGN (CL:SETQ INDEX (%%VALUE ITER-004))
       (CL:SETQ ITER-004 (%%REST ITER-004)))
      (CL:WHEN
       (CL:NOT
        (SIGNATURE-INDICES-COVER-ANY-EXAMPLE?
         (REMOVE (COPY BEST-INDICES) INDEX) NEGATIVE))
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
        "     Removing clause" EOL)
       (CL:SETQ BEST-INDICES (REMOVE BEST-INDICES INDEX))
       (CL:SETQ STOP FALSE) (CL:RETURN)))))
   (CL:LET* ((INDEX NULL) (ITER-005 (%THE-CONS-LIST BEST-INDICES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
     (CL:PROGN (CL:SETQ INDEX (%%VALUE ITER-005))
      (CL:SETQ ITER-005 (%%REST ITER-005)))
     (CL:IF (CL:> (%WRAPPER-VALUE INDEX) 0)
      (CL:SETQ RESULT
       (CONS
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY CONS-PROPS))
         (CL:THE CL:FIXNUM (CL:1- (%WRAPPER-VALUE INDEX))))
        RESULT))
      (CL:SETQ RESULT
       (CONS
        (LIST* SYM-RULE-INDUCTION-LOGIC-FAIL
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY CONS-PROPS))
          (CL:THE CL:FIXNUM (CL:1- (CL:- 0 (%WRAPPER-VALUE INDEX)))))
         NIL)
        RESULT)))))
   RESULT))

;;; (DEFUN (INTERSECT-SIGNATURES (LIST OF INTEGER-WRAPPER)) ...)

(CL:DEFUN INTERSECT-SIGNATURES (SIG1 SIG2)
  (CL:LET* ((RESULT (NEW-LIST)))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH SIG1))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:WHEN
      (CL:AND
       (EQL? (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SIG1)) I)
        ONE-WRAPPER)
       (EQL? (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SIG2)) I)
        ONE-WRAPPER))
      (PUSH RESULT (WRAP-INTEGER (CL:1+ I))))
     (CL:WHEN
      (CL:AND
       (EQL? (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SIG1)) I)
        ZERO-WRAPPER)
       (EQL? (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SIG2)) I)
        ZERO-WRAPPER))
      (PUSH RESULT (WRAP-INTEGER (CL:- 0 (CL:1+ I)))))))
   RESULT))

;;; (DEFUN (REMOVE-SIGNATURE-COVERED-EXAMPLES (LIST OF TRAINING-EXAMPLE)) ...)

(CL:DEFUN REMOVE-SIGNATURE-COVERED-EXAMPLES (INDICES EXAMPLES)
  (CL:LET* ((REMOVED (NEW-LIST)))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST (COPY EXAMPLES))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (SIGNATURE-INDICES-COVER-EXAMPLE? INDICES EXAMPLE)
      (PUSH REMOVED EXAMPLE)
      (CL:SETQ EXAMPLES (REMOVE EXAMPLES EXAMPLE)))))
   REMOVED))

;;; (DEFUN (NUM-SIGNATURE-INDICES-COVERED INTEGER) ...)

(CL:DEFUN NUM-SIGNATURE-INDICES-COVERED (INDICES EXAMPLES)
  (CL:LET* ((COUNT 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (SIGNATURE-INDICES-COVER-EXAMPLE? INDICES EXAMPLE)
      (CL:SETQ COUNT (CL:1+ COUNT)))))
   COUNT))

;;; (DEFUN (SIGNATURE-INDICES-COVER-ANY-EXAMPLE? BOOLEAN) ...)

(CL:DEFUN SIGNATURE-INDICES-COVER-ANY-EXAMPLE? (INDICES EXAMPLES)
  (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST EXAMPLES)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (SIGNATURE-INDICES-COVER-EXAMPLE? INDICES EXAMPLE)
     (CL:RETURN-FROM SIGNATURE-INDICES-COVER-ANY-EXAMPLE? TRUE))))
  FALSE)

;;; (DEFUN (SIGNATURE-INDICES-COVER-EXAMPLE? BOOLEAN) ...)

(CL:DEFUN SIGNATURE-INDICES-COVER-EXAMPLE? (INDICES EXAMPLE)
  (CL:LET* ((ACTUAL 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM ACTUAL))
   (CL:LET* ((INDEX NULL) (ITER-000 (%THE-CONS-LIST INDICES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ INDEX (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:SETQ ACTUAL (CL:1- (ABS (%WRAPPER-VALUE INDEX))))
     (CL:IF (CL:> (%WRAPPER-VALUE INDEX) 0)
      (CL:WHEN
       (EQL?
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE)))
         ACTUAL)
        ZERO-WRAPPER)
       (CL:RETURN-FROM SIGNATURE-INDICES-COVER-EXAMPLE? FALSE))
      (CL:WHEN
       (EQL?
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE)))
         ACTUAL)
        ONE-WRAPPER)
       (CL:RETURN-FROM SIGNATURE-INDICES-COVER-EXAMPLE? FALSE))))))
  TRUE)

;;; (DEFUN TOP-DOWN-RULE-INDUCTION ...)

(CL:DEFUN %TOP-DOWN-RULE-INDUCTION (EXAMPLES)
  (CL:LET*
   ((POSITIVE (NEW-LIST)) (ALL-POSITIVES (NEW-LIST)) (NEGATIVE (NEW-LIST))
    (UNCOVERED NULL) (COVERED (NEW-LIST)) (ANTECEDENT NIL)
    (LINKED-ANTECEDENTS NULL) (CONCEPT (%CONCEPT (FIRST EXAMPLES)))
    (NUM-RULES 0) (LOOP-CHECK 0)
    (SIGNATURES? *INDUCE-RULES-FROM-SIGNATURES*) (CONS-PROPS NULL)
    (PROPS (NEW-LIST)) (PROPOSITION-VECTOR NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-RULES LOOP-CHECK))
   (CL:SETQ *INDUCED-DECISION-RULES* (NEW-LIST))
   (CL:WHEN (CL:NOT (CL:EQ (%MODULE (FIRST *TRAINING-EXAMPLES*)) NULL))
    (CHANGE-MODULE (%MODULE (FIRST *TRAINING-EXAMPLES*))))
   (CL:SETQ PROPS
    (GET-CLASSIFICATION-RELATIONS (%QUERY (FIRST *TRAINING-EXAMPLES*))))
   (CL:SETQ CONS-PROPS (NEW-VECTOR (LENGTH PROPS)))
   (CL:SETQ PROPOSITION-VECTOR (NEW-VECTOR (LENGTH PROPS)))
   (CL:LET*
    ((PROP NULL) (I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH PROPS)))
     (ITER-001 (%THE-CONS-LIST PROPS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE
     (CL:AND (CL:<= ITER-000 UPPER-BOUND-000)
      (CL:NOT (CL:EQ ITER-001 NIL)))
     DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:PROGN (CL:SETQ PROP (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:LET
      ((SELF (%THE-ARRAY PROPOSITION-VECTOR)) (VALUE PROP) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET
      ((SELF (%THE-ARRAY CONS-PROPS)) (VALUE (PROPOSITION-TO-CONS PROP))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:LET* ((EXAMPLE NULL) (ITER-002 (%THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-002))
      (CL:SETQ ITER-002 (%%REST ITER-002)))
     (CL:IF (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (%OUTPUT EXAMPLE))
      (CL:PROGN (PUSH POSITIVE EXAMPLE) (PUSH ALL-POSITIVES EXAMPLE))
      (PUSH NEGATIVE EXAMPLE))))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "Starting rule induction with " (LENGTH POSITIVE) " positive and "
    (LENGTH NEGATIVE) " negative examples" EOL)
   (CL:LOOP WHILE (CL:NOT (EMPTY? POSITIVE)) DO
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL (LENGTH POSITIVE)
     " positive examples left to be covered" EOL)
    (CL:SETQ COVERED (NEW-LIST)) (CL:SETQ LINKED-ANTECEDENTS (LIST NIL))
    (CL:WHEN *INDUCE-RULES-FROM-SIGNATURES*
     (CL:COND
      ((CL:EQ *SIGNATURE-STRATEGY* KWD-RULE-INDUCTION-BOTTOM-UP)
       (CL:SETQ ANTECEDENT
        (LEARN-ONE-RULE-BOTTOM-UP-FROM-SIGNATURES POSITIVE NEGATIVE
         COVERED CONS-PROPS))
       (CL:SETQ LINKED-ANTECEDENTS
        (LINK-VARIABLES-IN-INDUCED-RULE ANTECEDENT COVERED CONS-PROPS)))
      ((CL:EQ *SIGNATURE-STRATEGY* KWD-RULE-INDUCTION-DECISION-TREE)
       (CL:SETQ UNCOVERED (NEW-LIST))
       (CL:LET* ((EXAMPLE NULL) (ITER-003 (%THE-CONS-LIST POSITIVE)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
         (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-003))
          (CL:SETQ ITER-003 (%%REST ITER-003)))
         (PUSH UNCOVERED EXAMPLE)))
       (CL:LET* ((EXAMPLE NULL) (ITER-004 (%THE-CONS-LIST NEGATIVE)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
         (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-004))
          (CL:SETQ ITER-004 (%%REST ITER-004)))
         (PUSH UNCOVERED EXAMPLE)))
       (CL:LET*
        ((TREE-RULE NULL)
         (ITER-005
          (%THE-CONS-LIST
           (GET-RULES-FROM-TREE (%QUERY (FIRST UNCOVERED))
            (%INDUCE-DECISION-TREE UNCOVERED))))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
         (CL:PROGN (CL:SETQ TREE-RULE (%%VALUE ITER-005))
          (CL:SETQ ITER-005 (%%REST ITER-005)))
         (CL:WHEN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (%%VALUE TREE-RULE))
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS (%%REST TREE-RULE) NIL))
            (CL:IF (CL:EQ (%THE-CONS-LIST LINKED-ANTECEDENTS) NIL)
             (CL:SETF (%THE-CONS-LIST LINKED-ANTECEDENTS) COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST
              (%THE-CONS-LIST LINKED-ANTECEDENTS) COLLECT-000)))
           (CL:PROGN
            (CL:SETF (%%REST COLLECT-000) (CONS (%%REST TREE-RULE) NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
       (CL:SETQ LINKED-ANTECEDENTS (REMOVE LINKED-ANTECEDENTS NIL)))
      ((CL:EQ *SIGNATURE-STRATEGY* KWD-RULE-INDUCTION-TOP-DOWN)
       (CL:SETQ ANTECEDENT
        (LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES POSITIVE NEGATIVE COVERED
         CONS-PROPS))
       (CL:SETQ LINKED-ANTECEDENTS
        (LINK-VARIABLES-IN-INDUCED-RULE ANTECEDENT COVERED CONS-PROPS)))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
         *SIGNATURE-STRATEGY* "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (CL:LET* ((ANT NULL) (ITER-006 (%THE-CONS-LIST LINKED-ANTECEDENTS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
      (CL:PROGN (CL:SETQ ANT (%%VALUE ITER-006))
       (CL:SETQ ITER-006 (%%REST ITER-006)))
      (CL:SETQ COVERED (GET-COVERED-EXAMPLES ANT NEGATIVE))
      (CL:WHEN
       (CL:OR (CL:< (LENGTH COVERED) 10)
        (CL:< (LENGTH COVERED) (LENGTH POSITIVE)) (CL:EQ ANT NIL))
       (CL:WHEN (CL:> (LENGTH COVERED) 0)
        (CL:SETQ ANT
         (SPECIALIZE-RULE ANT *CANDIDATE-CLAUSES* POSITIVE COVERED))
        (CL:SETQ LOOP-CHECK 0)
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ ANT NIL))
          (RULE-COVERS-ANY-EXAMPLE? ANT NEGATIVE))
         DO (CL:SETQ LOOP-CHECK (CL:1+ LOOP-CHECK))
         (CL:WHEN (CL:= LOOP-CHECK 4) (CL:SETQ ANT NIL)
          (CL:SETQ COVERED NEGATIVE) (CL:RETURN))
         (CL:SETQ ANT
          (SPECIALIZE-RULE ANT *CANDIDATE-CLAUSES* POSITIVE COVERED)))
        (CL:WHEN (CL:NOT (CL:EQ ANT NIL)) (CL:SETQ COVERED NULL)))
       (CL:WHEN (CL:OR (CL:EQ COVERED NULL) (EMPTY? COVERED))
        (CL:SETQ COVERED (GET-COVERED-EXAMPLES ANT POSITIVE))
        (CL:LET* ((EXAMPLE NULL) (ITER-007 (%THE-CONS-LIST COVERED)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-007 NIL)) DO
          (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-007))
           (CL:SETQ ITER-007 (%%REST ITER-007)))
          (CL:SETQ POSITIVE (REMOVE POSITIVE EXAMPLE))))
        (CL:WHEN (CL:= (LENGTH COVERED) 0)
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
          "No Positives Covered by" ANT EOL))
        (CL:WHEN (CL:> (LENGTH COVERED) 0)
         (PUSH *INDUCED-DECISION-RULES*
          (LIST* SYM-RULE-INDUCTION-STELLA-=>
           (CONS SYM-RULE-INDUCTION-STELLA-AND
            (CONCATENATE (REVERSE (COPY-CONS-TREE ANT)) NIL))
           (CONS CONCEPT (CONS SYM-RULE-INDUCTION-LOGIC-?Y NIL)) NIL))
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
          "Adding rule to cover " (LENGTH COVERED) " examples" EOL))))))
    (CL:IF (CL:= (LENGTH *INDUCED-DECISION-RULES*) NUM-RULES)
     (CL:PROGN
      (CL:WHEN (CL:NOT *INDUCE-RULES-FROM-SIGNATURES*)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Stopping with "
        (LENGTH POSITIVE) " examples uncovered" EOL)
       (CL:RETURN))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) (LENGTH POSITIVE)
       " examples uncovered, switching to full query-based induction" EOL)
      (CL:SETQ *INDUCE-RULES-FROM-SIGNATURES* FALSE))
     (CL:SETQ *INDUCE-RULES-FROM-SIGNATURES* SIGNATURES?))
    (CL:SETQ NUM-RULES (LENGTH *INDUCED-DECISION-RULES*)))
   (CL:SETQ *INDUCE-RULES-FROM-SIGNATURES* SIGNATURES?)
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
    "PowerLoom has induced the following rules" EOL EOL)
   (CL:LET*
    ((RULE NULL) (ITER-008 (%THE-CONS-LIST *INDUCED-DECISION-RULES*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-008 NIL)) DO
     (CL:PROGN (CL:SETQ RULE (%%VALUE ITER-008))
      (CL:SETQ ITER-008 (%%REST ITER-008)))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) RULE EOL)))))

(CL:DEFMACRO TOP-DOWN-RULE-INDUCTION (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/TOP-DOWN-RULE-INDUCTION)) (CL:MACRO-FUNCTION (CL:QUOTE TOP-DOWN-RULE-INDUCTION)))

;;; (DEFUN (BUILD-ANTECEDENT-FROM-RULE-INDEX (CONS OF CONS)) ...)

(CL:DEFUN BUILD-ANTECEDENT-FROM-RULE-INDEX (PROPS RULE-INDEX)
  (CL:LET* ((ANTECEDENT NIL) (CONS-PROP NIL))
   (CL:LET* ((INDEX NULL) (ITER-000 (%THE-CONS-LIST RULE-INDEX)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ INDEX (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:IF (CL:< (%WRAPPER-VALUE INDEX) 0)
      (CL:SETQ CONS-PROP
       (LIST* SYM-RULE-INDUCTION-LOGIC-FAIL
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY PROPS))
         (CL:THE CL:FIXNUM (CL:1- (ABS (%WRAPPER-VALUE INDEX)))))
        NIL))
      (CL:SETQ CONS-PROP
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY PROPS))
        (CL:THE CL:FIXNUM (CL:1- (ABS (%WRAPPER-VALUE INDEX)))))))
     (CL:SETQ ANTECEDENT (CONS CONS-PROP ANTECEDENT))))
   ANTECEDENT))

;;; (DEFUN (LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES (CONS OF CONS)) ...)

(CL:DEFUN LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES (POSITIVE NEGATIVE COVERED_POS CONS-PROPS)
  (CL:LET*
   ((CURRENT_UTILITY 0.0d0) (RULE (NEW-LIST)) (GAIN 0.0d0)
    (MAX_GAIN 0.0d0) (USED_FEATURES (NEW-LIST)) (NUM_FEATURES 0)
    (VARS (NEW-LIST)) (VARIABLE-TABLE NULL) (FEATURE_INDEX 0)
    (COVERED_NEG (NEW-LIST)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT CURRENT_UTILITY GAIN MAX_GAIN)
    (CL:TYPE CL:FIXNUM NUM_FEATURES FEATURE_INDEX))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "Learning rule top down from signatures over " (LENGTH POSITIVE)
    " positives" EOL)
   (CL:WHEN (EMPTY? POSITIVE)
    (CL:RETURN-FROM LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES NIL))
   (CL:SETQ NUM_FEATURES (LENGTH (%INPUT (FIRST POSITIVE))))
   (CL:SETQ VARIABLE-TABLE (NEW-VECTOR (CL:1+ NUM_FEATURES)))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 NUM_FEATURES)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000))
     DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:LET
      ((SELF (%THE-ARRAY VARIABLE-TABLE))
       (VALUE
        (GET-VARIABLES-FROM-CONS-PROPOSITIONS
         (CONS-LIST
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY CONS-PROPS))
           (CL:THE CL:FIXNUM (CL:1- I))))))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (PUSH VARS SYM-RULE-INDUCTION-LOGIC-?Y)
   (CL:LET*
    ((EXAMPLE NULL) (ITER-001 (%THE-CONS-LIST NEGATIVE))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS EXAMPLE NIL))
       (CL:IF (CL:EQ (%THE-CONS-LIST COVERED_NEG) NIL)
        (CL:SETF (%THE-CONS-LIST COVERED_NEG) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST COVERED_NEG)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS EXAMPLE NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:LET*
    ((EXAMPLE NULL) (ITER-002 (%THE-CONS-LIST POSITIVE))
     (COLLECT-001 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-002))
      (CL:SETQ ITER-002 (%%REST ITER-002)))
     (CL:IF (CL:EQ COLLECT-001 NULL)
      (CL:PROGN (CL:SETQ COLLECT-001 (CONS EXAMPLE NIL))
       (CL:IF (CL:EQ (%THE-CONS-LIST COVERED_POS) NIL)
        (CL:SETF (%THE-CONS-LIST COVERED_POS) COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST COVERED_POS)
         COLLECT-001)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS EXAMPLE NIL))
       (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))))
   (CL:LOOP WHILE (CL:NOT (EMPTY? COVERED_NEG)) DO
    (CL:SETQ CURRENT_UTILITY
     (FOIL-UTILITY (LENGTH COVERED_POS) (LENGTH COVERED_NEG)))
    (CL:SETQ MAX_GAIN 0.0d0)
    (CL:LET*
     ((I NULL-INTEGER) (ITER-003 1) (UPPER-BOUND-001 NUM_FEATURES)
      (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-003 UPPER-BOUND-001 I))
     (CL:LOOP WHILE
      (CL:OR UNBOUNDED?-001 (CL:<= ITER-003 UPPER-BOUND-001)) DO
      (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
      (CL:WHEN (CL:NOT (MEMBER? USED_FEATURES (WRAP-INTEGER I)))
       (CL:LET* ((TEST-VALUE-000 FALSE))
        (CL:SETQ TEST-VALUE-000 *ENFORCE-LINKED-VARIABLES*)
        (CL:WHEN TEST-VALUE-000
         (CL:LET* ((FOUND?-000 FALSE))
          (CL:LET*
           ((ELE NULL)
            (ITER-004
             (%THE-CONS-LIST
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VARIABLE-TABLE)) I))))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
            (CL:PROGN (CL:SETQ ELE (%%VALUE ITER-004))
             (CL:SETQ ITER-004 (%%REST ITER-004)))
            (CL:WHEN (MEMBER? VARS ELE) (CL:SETQ FOUND?-000 TRUE)
             (CL:RETURN))))
          (CL:SETQ TEST-VALUE-000 FOUND?-000))
         (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000)))
        (CL:IF TEST-VALUE-000 (CL:SETQ GAIN -9999.0d0)
         (CL:SETQ GAIN
          (FOIL-GAIN I CURRENT_UTILITY COVERED_POS COVERED_NEG))))
       (CL:WHEN *TRACE-FOIL*
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
         "Foil gain on feature " I ": " GAIN EOL))
       (CL:WHEN (CL:> GAIN MAX_GAIN) (CL:SETQ FEATURE_INDEX I)
        (CL:SETQ MAX_GAIN GAIN))
       (CL:LET* ((TEST-VALUE-001 FALSE))
        (CL:SETQ TEST-VALUE-001 *ENFORCE-LINKED-VARIABLES*)
        (CL:WHEN TEST-VALUE-001
         (CL:LET* ((FOUND?-001 FALSE))
          (CL:LET*
           ((ELE NULL)
            (ITER-005
             (%THE-CONS-LIST
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VARIABLE-TABLE)) I))))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
            (CL:PROGN (CL:SETQ ELE (%%VALUE ITER-005))
             (CL:SETQ ITER-005 (%%REST ITER-005)))
            (CL:WHEN (MEMBER? VARS ELE) (CL:SETQ FOUND?-001 TRUE)
             (CL:RETURN))))
          (CL:SETQ TEST-VALUE-001 FOUND?-001))
         (CL:SETQ TEST-VALUE-001 (CL:NOT TEST-VALUE-001)))
        (CL:IF TEST-VALUE-001 (CL:SETQ GAIN -9999.0d0)
         (CL:SETQ GAIN
          (FOIL-GAIN (CL:- 0 I) CURRENT_UTILITY COVERED_POS
           COVERED_NEG))))
       (CL:WHEN *TRACE-FOIL*
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
         "Foil gain on feature " I ": " GAIN EOL))
       (CL:WHEN (CL:> GAIN MAX_GAIN) (CL:SETQ FEATURE_INDEX (CL:- 0 I))
        (CL:SETQ MAX_GAIN GAIN)))))
    (CL:WHEN (CL:= MAX_GAIN 0.0d0) (CL:SETQ COVERED_POS (NEW-LIST))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "   Darn, nothing we can do here, returning nil." EOL)
     (CL:RETURN-FROM LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES NIL))
    (CL:WHEN *TRACE-FOIL*
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "** Choosing feature "
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY CONS-PROPS))
       (CL:THE CL:FIXNUM (ABS (CL:1- FEATURE_INDEX))))
      EOL))
    (CL:WHEN *ENFORCE-LINKED-VARIABLES*
     (CL:LET*
      ((VAR NULL)
       (ITER-006
        (%THE-CONS-LIST
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VARIABLE-TABLE))
          (CL:THE CL:FIXNUM (ABS FEATURE_INDEX))))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
       (CL:PROGN (CL:SETQ VAR (%%VALUE ITER-006))
        (CL:SETQ ITER-006 (%%REST ITER-006)))
       (CL:WHEN (CL:NOT (MEMBER? VARS VAR)) (PUSH VARS VAR)))))
    (UPDATE-COVERED-EXAMPLES FEATURE_INDEX COVERED_POS COVERED_NEG)
    (PUSH USED_FEATURES (WRAP-INTEGER (ABS FEATURE_INDEX)))
    (PUSH RULE (WRAP-INTEGER FEATURE_INDEX)))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   Returning with "
    (LENGTH COVERED_POS) " positives and " (LENGTH COVERED_NEG)
    " negatives covered" EOL)
   (BUILD-ANTECEDENT-FROM-RULE-INDEX CONS-PROPS RULE)))

;;; (DEFUN UPDATE-COVERED-EXAMPLES ...)

(CL:DEFUN UPDATE-COVERED-EXAMPLES (FEATURE_INDEX COVERED_POS COVERED_NEG)
  (CL:DECLARE (CL:TYPE CL:FIXNUM FEATURE_INDEX))
  (CL:LET* ((TEMP (NEW-LIST)) (INDEX (CL:1- (ABS FEATURE_INDEX))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX))
   (CL:WHEN (CL:> FEATURE_INDEX 0)
    (CL:LET*
     ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST COVERED_POS))
      (COLLECT-000 NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (CL:WHEN
       (EQL?
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE)))
         INDEX)
        ZERO-WRAPPER)
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS EXAMPLE NIL))
         (CL:IF (CL:EQ (%THE-CONS-LIST TEMP) NIL)
          (CL:SETF (%THE-CONS-LIST TEMP) COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST TEMP)
           COLLECT-000)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS EXAMPLE NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
    (CL:LET* ((EXAMPLE NULL) (ITER-001 (%THE-CONS-LIST TEMP)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-001))
       (CL:SETQ ITER-001 (%%REST ITER-001)))
      (CL:SETQ COVERED_POS (REMOVE COVERED_POS EXAMPLE))))
    (CL:SETQ TEMP (NEW-LIST))
    (CL:LET*
     ((EXAMPLE NULL) (ITER-002 (%THE-CONS-LIST COVERED_NEG))
      (COLLECT-001 NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-002))
       (CL:SETQ ITER-002 (%%REST ITER-002)))
      (CL:WHEN
       (EQL?
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE)))
         INDEX)
        ZERO-WRAPPER)
       (CL:IF (CL:EQ COLLECT-001 NULL)
        (CL:PROGN (CL:SETQ COLLECT-001 (CONS EXAMPLE NIL))
         (CL:IF (CL:EQ (%THE-CONS-LIST TEMP) NIL)
          (CL:SETF (%THE-CONS-LIST TEMP) COLLECT-001)
          (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST TEMP)
           COLLECT-001)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS EXAMPLE NIL))
         (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))))
    (CL:LET* ((EXAMPLE NULL) (ITER-003 (%THE-CONS-LIST TEMP)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
      (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-003))
       (CL:SETQ ITER-003 (%%REST ITER-003)))
      (CL:SETQ COVERED_POS (REMOVE COVERED_NEG EXAMPLE))))
    (CL:RETURN-FROM UPDATE-COVERED-EXAMPLES))
   (CL:LET*
    ((EXAMPLE NULL) (ITER-004 (%THE-CONS-LIST COVERED_POS))
     (COLLECT-002 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-004))
      (CL:SETQ ITER-004 (%%REST ITER-004)))
     (CL:WHEN
      (EQL?
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE)))
        INDEX)
       ONE-WRAPPER)
      (CL:IF (CL:EQ COLLECT-002 NULL)
       (CL:PROGN (CL:SETQ COLLECT-002 (CONS EXAMPLE NIL))
        (CL:IF (CL:EQ (%THE-CONS-LIST TEMP) NIL)
         (CL:SETF (%THE-CONS-LIST TEMP) COLLECT-002)
         (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST TEMP)
          COLLECT-002)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-002) (CONS EXAMPLE NIL))
        (CL:SETQ COLLECT-002 (%%REST COLLECT-002)))))))
   (CL:LET* ((EXAMPLE NULL) (ITER-005 (%THE-CONS-LIST TEMP)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-005))
      (CL:SETQ ITER-005 (%%REST ITER-005)))
     (CL:SETQ COVERED_POS (REMOVE COVERED_POS EXAMPLE))))
   (CL:SETQ TEMP (NEW-LIST))
   (CL:LET*
    ((EXAMPLE NULL) (ITER-006 (%THE-CONS-LIST COVERED_NEG))
     (COLLECT-003 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-006))
      (CL:SETQ ITER-006 (%%REST ITER-006)))
     (CL:WHEN
      (EQL?
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE)))
        INDEX)
       ONE-WRAPPER)
      (CL:IF (CL:EQ COLLECT-003 NULL)
       (CL:PROGN (CL:SETQ COLLECT-003 (CONS EXAMPLE NIL))
        (CL:IF (CL:EQ (%THE-CONS-LIST TEMP) NIL)
         (CL:SETF (%THE-CONS-LIST TEMP) COLLECT-003)
         (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST TEMP)
          COLLECT-003)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-003) (CONS EXAMPLE NIL))
        (CL:SETQ COLLECT-003 (%%REST COLLECT-003)))))))
   (CL:LET* ((EXAMPLE NULL) (ITER-007 (%THE-CONS-LIST TEMP)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-007 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-007))
      (CL:SETQ ITER-007 (%%REST ITER-007)))
     (CL:SETQ COVERED_POS (REMOVE COVERED_NEG EXAMPLE))))))

;;; (DEFUN (FOIL-GAIN FLOAT) ...)

(CL:DEFUN FOIL-GAIN (FEATURE-INDEX UTILITY COVERED-POS COVERED-NEG)
  (CL:DECLARE (CL:TYPE CL:FIXNUM FEATURE-INDEX)
   (CL:TYPE CL:DOUBLE-FLOAT UTILITY))
  (CL:LET* ((P 0) (N 0) (INDEX (CL:1- (ABS FEATURE-INDEX))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM P N INDEX))
   (CL:WHEN (CL:< FEATURE-INDEX 0)
    (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST COVERED-POS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (CL:WHEN
       (EQL?
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE)))
         INDEX)
        ZERO-WRAPPER)
       (CL:SETQ P (CL:1+ P)))))
    (CL:LET* ((EXAMPLE NULL) (ITER-001 (%THE-CONS-LIST COVERED-NEG)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-001))
       (CL:SETQ ITER-001 (%%REST ITER-001)))
      (CL:WHEN
       (EQL?
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE)))
         INDEX)
        ZERO-WRAPPER)
       (CL:SETQ N (CL:1+ N)))))
    (CL:RETURN-FROM FOIL-GAIN (CL:* P (CL:- (FOIL-UTILITY P N) UTILITY))))
   (CL:LET* ((EXAMPLE NULL) (ITER-002 (%THE-CONS-LIST COVERED-POS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-002))
      (CL:SETQ ITER-002 (%%REST ITER-002)))
     (CL:WHEN
      (EQL?
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE)))
        INDEX)
       ONE-WRAPPER)
      (CL:SETQ P (CL:1+ P)))))
   (CL:LET* ((EXAMPLE NULL) (ITER-003 (%THE-CONS-LIST COVERED-NEG)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-003))
      (CL:SETQ ITER-003 (%%REST ITER-003)))
     (CL:WHEN
      (EQL?
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE)))
        INDEX)
       ONE-WRAPPER)
      (CL:SETQ N (CL:1+ N)))))
   (CL:* P (CL:- (FOIL-UTILITY P N) UTILITY))))

;;; (DEFUN (FOIL-UTILITY FLOAT) ...)

(CL:DEFUN FOIL-UTILITY (P N)
  (CL:DECLARE (CL:TYPE CL:FIXNUM P N))
  (CL:WHEN (CL:= P 0) (CL:RETURN-FROM FOIL-UTILITY (CL:FLOAT 0 0.0d0)))
  (CL:/
   (CL:THE CL:DOUBLE-FLOAT
    (CL:LOG
     (CL:THE CL:DOUBLE-FLOAT (CL:/ (CL:FLOAT P 0.0d0) (CL:+ P N)))))
   LOG_2))

;;; (DEFUN (LEARN-ONE-RULE-TOP-DOWN (CONS OF CONS)) ...)

(CL:DEFUN LEARN-ONE-RULE-TOP-DOWN (PROPOSITIONS POSITIVE NEGATIVE)
  (SPECIALIZE-RULE NIL PROPOSITIONS POSITIVE NEGATIVE))

;;; (DEFUN (SPECIALIZE-RULE (CONS OF CONS)) ...)

(CL:DEFUN SPECIALIZE-RULE (RULE PROPOSITIONS POSITIVE NEGATIVE)
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Specializing " EOL)
  (CL:LET*
   ((CANDIDATES (NEW-LIST)) (COVERED-NEGS (NEW-LIST))
    (COVERED-POS (NEW-LIST)) (CURRENT_UTILITY 0.0d0) (FEATURE-INDEX 0)
    (NEW-CLAUSE NIL) (VARS (GET-VARIABLES-FROM-CONS-PROPOSITIONS RULE))
    (VARIABLE-TABLE NULL) (GAIN 0.0d0) (MAX 0.0d0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT CURRENT_UTILITY GAIN MAX)
    (CL:TYPE CL:FIXNUM FEATURE-INDEX))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST NEGATIVE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
      (PUSH COVERED-NEGS EXAMPLE))))
   (CL:LET* ((EXAMPLE NULL) (ITER-001 (%THE-CONS-LIST POSITIVE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
      (PUSH COVERED-POS EXAMPLE))))
   (CL:WHEN (EMPTY? COVERED-NEGS)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     " No covered negatives" EOL)
    (CL:RETURN-FROM SPECIALIZE-RULE RULE))
   (CL:WHEN (CL:NOT (MEMBER? VARS SYM-RULE-INDUCTION-LOGIC-?Y))
    (PUSH VARS SYM-RULE-INDUCTION-LOGIC-?Y))
   (CL:SETQ VARIABLE-TABLE (NEW-VECTOR (CL:1+ (LENGTH PROPOSITIONS))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-002 1)
     (UPPER-BOUND-000 (LENGTH PROPOSITIONS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-002 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
     (CL:LET
      ((SELF (%THE-ARRAY VARIABLE-TABLE))
       (VALUE
        (GET-VARIABLES-FROM-CONS-PROPOSITIONS
         (CONS-LIST
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY PROPOSITIONS))
           (CL:THE CL:FIXNUM (CL:1- I))))))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-003 1)
     (UPPER-BOUND-001 (LENGTH PROPOSITIONS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-003 UPPER-BOUND-001 I))
    (CL:LOOP WHILE (CL:<= ITER-003 UPPER-BOUND-001) DO
     (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
     (PUSH CANDIDATES (WRAP-INTEGER I))
     (PUSH CANDIDATES (WRAP-INTEGER (CL:- 0 I)))))
   (CL:LET* ((CLAUSE NULL) (ITER-004 RULE))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
     (CL:PROGN (CL:SETQ CLAUSE (%%VALUE ITER-004))
      (CL:SETQ ITER-004 (%%REST ITER-004)))
     (CL:LET*
      ((I NULL-INTEGER) (PROP NULL) (VECTOR-000 PROPOSITIONS)
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (ITER-005 1))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-005 I))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:PROGN
        (CL:SETQ PROP
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
       (CL:PROGN (CL:SETQ I ITER-005) (CL:SETQ ITER-005 (CL:1+ ITER-005)))
       (CL:WHEN (EQUAL-CONS-TREES? PROP CLAUSE)
        (CL:SETQ CANDIDATES (REMOVE CANDIDATES (WRAP-INTEGER I)))
        (CL:RETURN))
       (CL:WHEN
        (EQUAL-CONS-TREES? (LIST* SYM-RULE-INDUCTION-LOGIC-FAIL PROP NIL)
         CLAUSE)
        (CL:SETQ CANDIDATES (REMOVE CANDIDATES (WRAP-INTEGER (CL:- 0 I))))
        (CL:RETURN))))))
   (CL:LOOP WHILE (CL:NOT (EMPTY? COVERED-NEGS)) DO
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   Covers "
     (LENGTH COVERED-NEGS) " negs, and " (LENGTH COVERED-POS) " pos" EOL)
    (CL:SETQ CURRENT_UTILITY
     (FOIL-UTILITY (LENGTH COVERED-POS) (LENGTH COVERED-NEGS)))
    (CL:SETQ MAX 0.0d0)
    (CL:LET* ((I NULL) (ITER-006 (%THE-CONS-LIST (COPY CANDIDATES))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
      (CL:PROGN (CL:SETQ I (%%VALUE ITER-006))
       (CL:SETQ ITER-006 (%%REST ITER-006)))
      (CL:LET* ((FOUND?-000 FALSE))
       (CL:LET*
        ((ELE NULL)
         (ITER-007
          (%THE-CONS-LIST
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VARIABLE-TABLE))
            (CL:THE CL:FIXNUM (ABS (%WRAPPER-VALUE I)))))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-007 NIL)) DO
         (CL:PROGN (CL:SETQ ELE (%%VALUE ITER-007))
          (CL:SETQ ITER-007 (%%REST ITER-007)))
         (CL:WHEN (MEMBER? VARS ELE) (CL:SETQ FOUND?-000 TRUE)
          (CL:RETURN))))
       (CL:WHEN FOUND?-000
        (CL:IF (CL:> (%WRAPPER-VALUE I) 0)
         (CL:SETQ GAIN
          (QUERY-FOIL-GAIN
           (CONS
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY PROPOSITIONS))
             (CL:THE CL:FIXNUM (CL:1- (%WRAPPER-VALUE I))))
            RULE)
           CURRENT_UTILITY COVERED-POS COVERED-NEGS))
         (CL:SETQ GAIN
          (QUERY-FOIL-GAIN
           (CONS
            (LIST* SYM-RULE-INDUCTION-LOGIC-FAIL
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY PROPOSITIONS))
              (CL:THE CL:FIXNUM (CL:1- (CL:- 0 (%WRAPPER-VALUE I)))))
             NIL)
            RULE)
           CURRENT_UTILITY COVERED-POS COVERED-NEGS)))
        (CL:WHEN (CL:> GAIN MAX)
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "    Current: "
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY PROPOSITIONS))
           (CL:THE CL:FIXNUM (CL:1- (ABS (%WRAPPER-VALUE I)))))
          ": " GAIN)
         (CL:IF (CL:< (%WRAPPER-VALUE I) 0)
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) " Negated" EOL)
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL))
         (CL:SETQ FEATURE-INDEX (%WRAPPER-VALUE I))
         (CL:SETQ MAX GAIN))))))
    (CL:WHEN (CL:= MAX 0.0d0)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "   No features provide any gain" EOL)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   Can't separate "
      EOL)
     (CL:LET* ((POS NULL) (ITER-008 (%THE-CONS-LIST COVERED-POS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-008 NIL)) DO
       (CL:PROGN (CL:SETQ POS (%%VALUE ITER-008))
        (CL:SETQ ITER-008 (%%REST ITER-008)))
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "     "
        (%NAME POS) EOL)))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   From " EOL)
     (CL:LET* ((NEG NULL) (ITER-009 (%THE-CONS-LIST COVERED-NEGS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-009 NIL)) DO
       (CL:PROGN (CL:SETQ NEG (%%VALUE ITER-009))
        (CL:SETQ ITER-009 (%%REST ITER-009)))
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "     "
        (%NAME NEG) EOL)))
     (CL:RETURN-FROM SPECIALIZE-RULE NIL))
    (CL:LET*
     ((VAR NULL)
      (ITER-010
       (%THE-CONS-LIST
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VARIABLE-TABLE))
         (CL:THE CL:FIXNUM (ABS FEATURE-INDEX))))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-010 NIL)) DO
      (CL:PROGN (CL:SETQ VAR (%%VALUE ITER-010))
       (CL:SETQ ITER-010 (%%REST ITER-010)))
      (CL:WHEN (CL:NOT (MEMBER? VARS VAR)) (PUSH VARS VAR))))
    (CL:SETQ CANDIDATES (REMOVE CANDIDATES (WRAP-INTEGER FEATURE-INDEX)))
    (CL:SETQ NEW-CLAUSE
     (COPY-CONS-TREE
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY PROPOSITIONS))
       (CL:THE CL:FIXNUM (CL:1- (ABS FEATURE-INDEX))))))
    (CL:WHEN (CL:< FEATURE-INDEX 0)
     (CL:SETQ NEW-CLAUSE
      (LIST* SYM-RULE-INDUCTION-LOGIC-FAIL NEW-CLAUSE NIL)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   Adding clause "
     NEW-CLAUSE EOL)
    (CL:SETQ RULE (CONS NEW-CLAUSE RULE))
    (REMOVE-EXCLUDED-EXAMPLES RULE COVERED-POS COVERED-NEGS))
   RULE))

;;; (DEFUN REMOVE-EXCLUDED-EXAMPLES ...)

(CL:DEFUN REMOVE-EXCLUDED-EXAMPLES (RULE COVERED-POS COVERED-NEG)
  (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST (COPY COVERED-NEG))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (CL:NOT (RULE-COVERS-EXAMPLE? RULE EXAMPLE))
     (CL:SETQ COVERED-NEG (REMOVE COVERED-NEG EXAMPLE)))))
  (CL:LET* ((EXAMPLE NULL) (ITER-001 (%THE-CONS-LIST (COPY COVERED-POS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-001))
     (CL:SETQ ITER-001 (%%REST ITER-001)))
    (CL:WHEN (CL:NOT (RULE-COVERS-EXAMPLE? RULE EXAMPLE))
     (CL:SETQ COVERED-POS (REMOVE COVERED-POS EXAMPLE))))))

;;; (DEFUN (QUERY-FOIL-GAIN FLOAT) ...)

(CL:DEFUN QUERY-FOIL-GAIN (RULE UTILITY COVERED-POS COVERED-NEG)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT UTILITY))
  (CL:LET* ((P 0) (N 0) (RESULT 0.0d0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM P N) (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST COVERED-NEG)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE) (CL:SETQ N (CL:1+ N)))))
   (CL:LET* ((EXAMPLE NULL) (ITER-001 (%THE-CONS-LIST COVERED-POS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE) (CL:SETQ P (CL:1+ P)))))
   (CL:WHEN (CL:AND (CL:= P 0) (CL:= N 0))
    (CL:RETURN-FROM QUERY-FOIL-GAIN 0.0d0))
   (CL:SETQ RESULT (CL:* P (CL:- (FOIL-UTILITY P N) UTILITY)))
   (CL:WHEN (CL:< RESULT 9.999999999999999d-7) (CL:SETQ RESULT 0.0d0))
   RESULT))

;;; (DEFUN QUERY-AND-UPDATE-COVERED-EXAMPLES ...)

(CL:DEFUN QUERY-AND-UPDATE-COVERED-EXAMPLES (RULE UNCOVERED COVERED)
  (CL:LET*
   ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST (COPY UNCOVERED)))
    (COLLECT-000 NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS EXAMPLE NIL))
       (CL:IF (CL:EQ (%THE-CONS-LIST COVERED) NIL)
        (CL:SETF (%THE-CONS-LIST COVERED) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST COVERED)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS EXAMPLE NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))))

;;; (DEFUN REMOVE-COVERED-EXAMPLES ...)

(CL:DEFUN REMOVE-COVERED-EXAMPLES (RULE UNCOVERED)
  (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST (COPY UNCOVERED))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
     (CL:SETQ UNCOVERED (REMOVE UNCOVERED EXAMPLE))))))

;;; (DEFUN (NUM-EXAMPLES-COVERED INTEGER) ...)

(CL:DEFUN NUM-EXAMPLES-COVERED (RULE EXAMPLES)
  (CL:LET* ((COUNT 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
      (CL:SETQ COUNT (CL:1+ COUNT)))))
   COUNT))

;;; (DEFUN (GET-COVERED-EXAMPLES (LIST OF TRAINING-EXAMPLE)) ...)

(CL:DEFUN GET-COVERED-EXAMPLES (RULE UNCOVERED)
  (CL:LET* ((COVERED (NEW-LIST)))
   (CL:LET*
    ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST UNCOVERED))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS EXAMPLE NIL))
        (CL:IF (CL:EQ (%THE-CONS-LIST COVERED) NIL)
         (CL:SETF (%THE-CONS-LIST COVERED) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST COVERED)
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS EXAMPLE NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   COVERED))

;;; (DEFUN (RULE-COVERS-ANY-EXAMPLE? BOOLEAN) ...)

(CL:DEFUN RULE-COVERS-ANY-EXAMPLE? (RULE EXAMPLES)
  (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST EXAMPLES)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
     (CL:RETURN-FROM RULE-COVERS-ANY-EXAMPLE? TRUE))))
  FALSE)

;;; (DEFUN (RULE-COVERS-EXAMPLE? BOOLEAN) ...)

(CL:DEFUN RULE-COVERS-EXAMPLE? (REVERSE-RULE EXAMPLE)
  (CL:WHEN (CL:EQ REVERSE-RULE NIL)
   (CL:RETURN-FROM RULE-COVERS-EXAMPLE? TRUE))
  (CL:LET*
   ((QUERY NULL) (RULE (REVERSE (COPY-CONS-TREE REVERSE-RULE)))
    (VARS
     (REMOVE (GET-VARIABLES-FROM-CONS-PROPOSITIONS RULE)
      SYM-RULE-INDUCTION-LOGIC-?Y))
    (EXTRA-CLAUSES NIL) (CONS-QUERY NIL) (TYPES NIL))
   (CL:WHEN (CL:NOT (CL:EQ (%MODULE EXAMPLE) NULL))
    (CHANGE-MODULE (%MODULE EXAMPLE)))
   (CL:SETQ CONS-QUERY
    (CONS SYM-RULE-INDUCTION-STELLA-AND
     (SUBSTITUTE-CONS-TREE RULE (%NAME EXAMPLE)
      SYM-RULE-INDUCTION-LOGIC-?Y)))
   (CL:WHEN (CL:NOT (EMPTY? VARS))
    (CL:LET* ((VAR NULL) (ITER-000 (%THE-CONS-LIST VARS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:PROGN (CL:SETQ VAR (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (CL:IF
       (CL:AND *ENABLE-USER-THING*
        (CL:EQL
         (CL:LET ((SELF (%SYMBOL-NAME VAR)) (POSITION 1))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION)))
         #\X))
       (CL:SETQ TYPES
        (CONS (CONS VAR (CONS SYM-RULE-INDUCTION-LOGIC-USER-THING NIL))
         TYPES))
       (CL:SETQ TYPES (CONS VAR TYPES)))))
    (CL:SETQ CONS-QUERY
     (LIST* SYM-RULE-INDUCTION-STELLA-EXISTS TYPES
      (CONS CONS-QUERY NIL))))
   (CL:IF *OPTIMIZE-INDUCED-QUERIES*
    (CL:SETQ QUERY
     (MAKE-QUERY NIL CONS-QUERY NIL
      (LIST* KWD-RULE-INDUCTION-TIMEOUT (WRAP-INTEGER 300) NIL)))
    (CL:SETQ QUERY
     (MAKE-QUERY NIL CONS-QUERY NIL
      (LIST* KWD-RULE-INDUCTION-TIMEOUT (WRAP-INTEGER 300)
       KWD-RULE-INDUCTION-DONT-OPTIMIZE? SYM-RULE-INDUCTION-STELLA-TRUE
       NIL))))
   (CL:IF (CL:NOT (CL:EQ (RUN-YES-OR-NO-QUERY? QUERY) NULL)) TRUE FALSE)))

;;; (DEFUN (LINK-VARIABLES-IN-INDUCED-RULE (LIST OF (CONS OF CONS))) ...)

(CL:DEFUN LINK-VARIABLES-IN-INDUCED-RULE (RULE EXAMPLES CONS-PROPS)
  (CL:LET*
   ((VARS NULL) (TEMP-RULE NIL) (VAR NULL) (UNLINKED NULL) (LINKED NULL)
    (NEW-RULES (NEW-LIST))
    (CONCEPT (%CONCEPT (FIRST *TRAINING-EXAMPLES*))))
   (CL:SETQ VARS (GET-VARIABLES-FROM-CONS-PROPOSITIONS RULE))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (CL:EQ (%INPUT EXAMPLE) NULL)
      (CL:SETF (%INPUT EXAMPLE)
       (CREATE-INPUT-SIGNATURE (%QUERY EXAMPLE))))
     (CL:SETQ TEMP-RULE (COPY-CONS-TREE RULE))
     (CL:SETQ UNLINKED (NEW-LIST)) (CL:SETQ LINKED (NEW-LIST))
     (CL:LET*
      ((VAR NULL) (ITER-001 (%THE-CONS-LIST VARS)) (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:PROGN (CL:SETQ VAR (%%VALUE ITER-001))
        (CL:SETQ ITER-001 (%%REST ITER-001)))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS VAR NIL))
         (CL:IF (CL:EQ (%THE-CONS-LIST UNLINKED) NIL)
          (CL:SETF (%THE-CONS-LIST UNLINKED) COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST UNLINKED)
           COLLECT-000)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VAR NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
     (CL:SETQ UNLINKED (REMOVE UNLINKED SYM-RULE-INDUCTION-LOGIC-?Y))
     (PUSH LINKED SYM-RULE-INDUCTION-LOGIC-?Y)
     (CL:LOOP WHILE (CL:NOT (EMPTY? UNLINKED)) DO
      (CL:SETQ VAR (POP UNLINKED))
      (CL:LET*
       ((I NULL-INTEGER) (PROP NULL) (VECTOR-000 CONS-PROPS) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)) (ITER-002 0))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-002 I))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:PROGN
         (CL:SETQ PROP
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
        (CL:PROGN (CL:SETQ I ITER-002)
         (CL:SETQ ITER-002 (CL:1+ ITER-002)))
        (CL:WHEN (MEMBER? PROP VAR)
         (CL:LET* ((FOUND?-000 FALSE))
          (CL:LET* ((ELE NULL) (ITER-003 TEMP-RULE))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
            (CL:PROGN (CL:SETQ ELE (%%VALUE ITER-003))
             (CL:SETQ ITER-003 (%%REST ITER-003)))
            (CL:WHEN (EQUAL-CONS-TREES? ELE PROP)
             (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
          (CL:WHEN FOUND?-000 (PUSH LINKED VAR) (CL:RETURN)))
         (CL:WHEN
          (EQL?
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE))) I)
           ONE-WRAPPER)
          (CL:SETQ TEMP-RULE
           (CONCATENATE TEMP-RULE (CONS-LIST (COPY-CONS-TREE PROP))))
          (CL:LET* ((NEW-VAR NULL) (ITER-004 (%%REST PROP)))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
            (CL:PROGN (CL:SETQ NEW-VAR (%%VALUE ITER-004))
             (CL:SETQ ITER-004 (%%REST ITER-004)))
            (CL:WHEN
             (CL:AND (CL:NOT (CL:EQ NEW-VAR VAR)) (SYMBOL? NEW-VAR)
              (CL:NOT (MEMBER? LINKED NEW-VAR)))
             (PUSH UNLINKED NEW-VAR))))
          (PUSH LINKED VAR) (CL:RETURN))))))
     (CL:LET* ((TEST-VALUE-000 FALSE))
      (CL:LET* ((FOUND?-001 FALSE))
       (CL:LET* ((ELE NULL) (ITER-005 (%THE-CONS-LIST NEW-RULES)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
         (CL:PROGN (CL:SETQ ELE (%%VALUE ITER-005))
          (CL:SETQ ITER-005 (%%REST ITER-005)))
         (CL:WHEN (EQUAL-CONS-TREES? ELE TEMP-RULE)
          (CL:SETQ FOUND?-001 TRUE) (CL:RETURN))))
       (CL:SETQ TEST-VALUE-000 FOUND?-001))
      (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
      (CL:WHEN TEST-VALUE-000 (PUSH NEW-RULES TEMP-RULE)))))
   (CL:LET* ((IT (ALLOCATE-ITERATOR NEW-RULES)))
    (CL:LOOP WHILE (NEXT? IT) DO (VALUE-SETTER IT (REVERSE (%VALUE IT)))))
   NEW-RULES))

;;; (DEFUN (EVALUATE-RULE-INDUCTION (VECTOR OF FLOAT-WRAPPER)) ...)

(CL:DEFUN %EVALUATE-RULE-INDUCTION (RELATION-NAME CLASS-NAME NUM-TRIALS CURVE-SPLITS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-TRIALS CURVE-SPLITS))
  (CL:LET*
   ((CLASS (%SURROGATE-VALUE-INVERSE (GET-DESCRIPTION CLASS-NAME)))
    (RELATION (%SURROGATE-VALUE-INVERSE (GET-DESCRIPTION RELATION-NAME)))
    (ILIST (LISTIFY (ALL-CLASS-INSTANCES CLASS))) (NUM (LENGTH ILIST))
    (NUM-TRAIN (CL:/ (CL:* 1 NUM) 2.0d0)) (NUM-TEST (CL:- NUM NUM-TRAIN))
    (CURRENT-SPLIT NUM-TRAIN) (TRAINING-INSTANCES NULL)
    (INSTANCES (NEW-VECTOR NUM)) (RESULT 0.0d0)
    (RESULTS (NEW-VECTOR CURVE-SPLITS)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM)
    (CL:TYPE CL:DOUBLE-FLOAT NUM-TRAIN NUM-TEST CURRENT-SPLIT RESULT))
   (CL:LET*
    ((I NULL-INTEGER) (INSTANCE NULL) (ITER-000 (%THE-CONS-LIST ILIST))
     (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ INSTANCE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:LET ((SELF (%THE-ARRAY INSTANCES)) (VALUE INSTANCE) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-000 (CL:1- CURVE-SPLITS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-002 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
     (CL:LET
      ((SELF (%THE-ARRAY RESULTS)) (VALUE (WRAP-FLOAT 0.0d0))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:LET*
    ((SPLIT NULL-INTEGER) (ITER-003 0)
     (UPPER-BOUND-001 (CL:1- CURVE-SPLITS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-003 UPPER-BOUND-001 SPLIT))
    (CL:LOOP WHILE (CL:<= ITER-003 UPPER-BOUND-001) DO
     (CL:PROGN (CL:SETQ SPLIT ITER-003)
      (CL:SETQ ITER-003 (CL:1+ ITER-003)))
     (CL:SETQ CURRENT-SPLIT
      (CL:* NUM-TRAIN (CL:/ (CL:FLOAT (CL:1+ SPLIT) 0.0d0) CURVE-SPLITS)))
     (CL:LET*
      ((I NULL-INTEGER) (ITER-004 0) (UPPER-BOUND-002 (CL:1- NUM-TRIALS)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-004 UPPER-BOUND-002 I))
      (CL:LOOP WHILE (CL:<= ITER-004 UPPER-BOUND-002) DO
       (CL:PROGN (CL:SETQ I ITER-004) (CL:SETQ ITER-004 (CL:1+ ITER-004)))
       (SHUFFLE-VECTOR INSTANCES)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Starting Trial "
        (CL:1+ I) " of split " (CL:1+ SPLIT) " with " CURRENT-SPLIT
        " examples" EOL)
       (CLEAR-TRAINING-EXAMPLES) (CLEAR-CASES)
       (CL:SETQ TRAINING-INSTANCES
        (NEW-VECTOR (CL:TRUNCATE CURRENT-SPLIT)))
       (CL:LET*
        ((J NULL-INTEGER) (ITER-005 0)
         (UPPER-BOUND-003 (CL:TRUNCATE (CL:1- CURRENT-SPLIT))))
        (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-005 UPPER-BOUND-003 J))
        (CL:LOOP WHILE (CL:<= ITER-005 UPPER-BOUND-003) DO
         (CL:PROGN (CL:SETQ J ITER-005)
          (CL:SETQ ITER-005 (CL:1+ ITER-005)))
         (CL:LET
          ((SELF (%THE-ARRAY TRAINING-INSTANCES))
           (VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INSTANCES)) J))
           (POSITION J))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))))
       (CL:COND
        ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-TOP-DOWN)
         (CL:SETQ *ENABLE-USER-THING* TRUE)
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
          "  Creating Match Criteria" EOL)
         (GENERATE-CLASSIFICATION-RULE TRAINING-INSTANCES RELATION-NAME
          CLASS-NAME TRUE)
         (SET-CANDIDATE-CLAUSES CLASS-NAME)
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
          "  Generating Training Examples" EOL)
         (GENERATE-CLASSIFICATION-TRAINING-EXAMPLES INSTANCES RELATION
          TRUE)
         (CL:SETQ *OPTIMIZE-INDUCED-QUERIES* TRUE))
        ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-BOTTOM-UP)
         (CL:SETQ *ENABLE-USER-THING* FALSE)
         (GENERATE-TRAINING-EXAMPLES INSTANCES RELATION)
         (CL:SETQ *OPTIMIZE-INDUCED-QUERIES* TRUE))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
           *RULE-INDUCTION-STRATEGY* "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
       (CL:SETQ *TRAINING-EXAMPLES* (REVERSE *TRAINING-EXAMPLES*))
       (CL:LET* ((TRAIN-SET (NEW-LIST)) (TEST-SET (NEW-LIST)))
        (CL:LET*
         ((J NULL-INTEGER) (EXAMPLE NULL)
          (ITER-006 (%THE-CONS-LIST *TRAINING-EXAMPLES*)) (ITER-007 0))
         (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-007 J))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
          (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-006))
           (CL:SETQ ITER-006 (%%REST ITER-006)))
          (CL:PROGN (CL:SETQ J ITER-007)
           (CL:SETQ ITER-007 (CL:1+ ITER-007)))
          (CL:WHEN (CL:< J CURRENT-SPLIT) (PUSH TRAIN-SET EXAMPLE))
          (CL:WHEN (CL:>= J NUM-TRAIN) (PUSH TEST-SET EXAMPLE))))
        (CL:SETQ RESULT
         (TRAIN-AND-TEST-RULE-INDUCTION TRAIN-SET TEST-SET))
        (CL:LET
         ((SELF (%THE-ARRAY RESULTS))
          (VALUE
           (WRAP-FLOAT
            (CL:+
             (%WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY RESULTS))
               SPLIT))
             RESULT)))
          (POSITION SPLIT))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL "  Result: "
         RESULT EOL))))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-008 0) (UPPER-BOUND-004 (CL:1- CURVE-SPLITS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-008 UPPER-BOUND-004 I))
    (CL:LOOP WHILE (CL:<= ITER-008 UPPER-BOUND-004) DO
     (CL:PROGN (CL:SETQ I ITER-008) (CL:SETQ ITER-008 (CL:1+ ITER-008)))
     (CL:LET
      ((SELF (%THE-ARRAY RESULTS))
       (VALUE
        (WRAP-FLOAT
         (CL:/
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY RESULTS)) I))
          NUM-TRIALS)))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   RESULTS))

(CL:DEFUN EVALUATE-RULE-INDUCTION-EVALUATOR-WRAPPER (ARGUMENTS)
  (%EVALUATE-RULE-INDUCTION (%%VALUE ARGUMENTS)
   (%%VALUE (%%REST ARGUMENTS))
   (%WRAPPER-VALUE (%%VALUE (%%REST (%%REST ARGUMENTS))))
   (%WRAPPER-VALUE (%%VALUE (%%REST (%%REST (%%REST ARGUMENTS)))))))

(CL:DEFMACRO EVALUATE-RULE-INDUCTION (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/EVALUATE-RULE-INDUCTION)) (CL:MACRO-FUNCTION (CL:QUOTE EVALUATE-RULE-INDUCTION)))

;;; (DEFUN (TRAIN-AND-TEST-RULE-INDUCTION FLOAT) ...)

(CL:DEFUN TRAIN-AND-TEST-RULE-INDUCTION (TRAIN-SET TEST-SET)
  (CL:LET*
   ((HOME-MODULE *CONTEXT*)
    (TEST-MODULE
     (FIND-OR-CREATE-MODULE
      (CONCATENATE (%MODULE-FULL-NAME *CONTEXT*) "INDUCED-RULES")))
    (RESULT 0.0d0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CHANGE-MODULE TEST-MODULE) (CLEAR-CONTEXT TEST-MODULE)
   (CL:COND
    ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-TOP-DOWN)
     (%TOP-DOWN-RULE-INDUCTION TRAIN-SET))
    ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-BOTTOM-UP)
     (%BOTTOM-UP-RULE-INDUCTION TRAIN-SET))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
       *RULE-INDUCTION-STRATEGY* "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (ASSERT-INDUCED-RULES)
   (CL:SETQ RESULT (TEST-THEORY-OVER-EXAMPLES TEST-SET))
   (CHANGE-MODULE HOME-MODULE) RESULT))

;;; (DEFUN INDUCE-DECISION-RULES ...)

(CL:DEFUN %INDUCE-DECISION-RULES (RELATION-NAME CLASS-NAME)
  (CL:SETQ RELATION-NAME (PERMANENTIFY RELATION-NAME))
  (CLEAR-CASES)
  (CLEAR-TRAINING-EXAMPLES)
  (CL:SETQ *INDUCED-DECISION-RULES* (NEW-LIST))
  (CL:SETQ CLASS-NAME (PERMANENTIFY CLASS-NAME))
  (CL:LET*
   ((CLASS (%SURROGATE-VALUE-INVERSE (GET-DESCRIPTION CLASS-NAME)))
    (RELATION (%SURROGATE-VALUE-INVERSE (GET-DESCRIPTION RELATION-NAME)))
    (ILIST (LISTIFY (ALL-CLASS-INSTANCES CLASS))) (NUM (LENGTH ILIST))
    (TREE NULL) (INSTANCES (NEW-VECTOR NUM)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM))
   (CL:LET*
    ((I NULL-INTEGER) (INSTANCE NULL) (ITER-000 (%THE-CONS-LIST ILIST))
     (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ INSTANCE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:LET ((SELF (%THE-ARRAY INSTANCES)) (VALUE INSTANCE) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:WHEN (CL:NOT *ALLOW-RECURSIVE-DECISION-NODES*)
    (INSERT-NEW *TABOO-OPERATORS* RELATION))
   (GENERATE-CLASSIFICATION-RULE INSTANCES RELATION-NAME CLASS-NAME TRUE)
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "Generating Training Examples" EOL)
   (GENERATE-CLASSIFICATION-TRAINING-EXAMPLES INSTANCES RELATION TRUE)
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "Generating Decision Rules" EOL)
   (CL:SETQ TREE (%INDUCE-DECISION-TREE *TRAINING-EXAMPLES*))
   (CL:SETF (%CONCEPT TREE) RELATION-NAME)
   (GET-RULES-FROM-TREE (%QUERY (FIRST *TRAINING-EXAMPLES*)) TREE)))

(CL:DEFMACRO INDUCE-DECISION-RULES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/INDUCE-DECISION-RULES)) (CL:MACRO-FUNCTION (CL:QUOTE INDUCE-DECISION-RULES)))

;;; (DEFUN MODULAR-INDUCE-DECISION-RULES ...)

(CL:DEFUN MODULAR-INDUCE-DECISION-RULES (RELATION-NAME CLASS-NAME MODULES)
  (CL:SETQ RELATION-NAME (PERMANENTIFY RELATION-NAME))
  (CL:SETQ CLASS-NAME (PERMANENTIFY CLASS-NAME))
  (CLEAR-TRAINING-EXAMPLES)
  (CLEAR-CASES)
  (CL:LET*
   ((CLASS (%SURROGATE-VALUE-INVERSE (GET-DESCRIPTION CLASS-NAME)))
    (RELATION (%SURROGATE-VALUE-INVERSE (GET-DESCRIPTION RELATION-NAME)))
    (ILIST (NEW-LIST)) (TREE NULL) (HOME *MODULE*)
    (FILE-PREFIX (%SYMBOL-NAME RELATION-NAME)) (NUM (LENGTH ILIST))
    (INSTANCE-VEC (NEW-VECTOR (LENGTH MODULES))) (INSTANCES NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE-PREFIX)
    (CL:TYPE CL:FIXNUM NUM))
   (CL:WHEN (CL:NOT *ALLOW-RECURSIVE-DECISION-NODES*)
    (INSERT-NEW *TABOO-OPERATORS* RELATION))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "Building Classification Rule" EOL)
   (CL:LET*
    ((J NULL-INTEGER) (MODULE NULL) (ITER-000 (%THE-CONS-LIST MODULES))
     (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 J))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ MODULE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ J ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CHANGE-MODULE MODULE)
     (CL:SETQ ILIST (LISTIFY (ALL-CLASS-INSTANCES CLASS)))
     (CL:SETQ NUM (LENGTH ILIST)) (CL:SETQ INSTANCES (NEW-VECTOR NUM))
     (CL:LET*
      ((I NULL-INTEGER) (INSTANCE NULL) (ITER-002 (%THE-CONS-LIST ILIST))
       (ITER-003 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-003 I))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:PROGN (CL:SETQ INSTANCE (%%VALUE ITER-002))
        (CL:SETQ ITER-002 (%%REST ITER-002)))
       (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
       (CL:LET
        ((SELF (%THE-ARRAY INSTANCES)) (VALUE INSTANCE) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))))
     (CL:LET
      ((SELF (%THE-ARRAY INSTANCE-VEC)) (VALUE INSTANCES) (POSITION J))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (GENERATE-CLASSIFICATION-RULE INSTANCES RELATION-NAME CLASS-NAME
      FALSE)))
   (CHANGE-MODULE HOME)
   (BUILD-CLASSIFICATION-RULE RELATION-NAME CLASS-NAME)
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "Generating Training Examples" EOL)
   (CL:LET*
    ((VEC NULL) (MODULE NULL) (ITER-004 (%THE-CONS-LIST MODULES))
     (VECTOR-000 INSTANCE-VEC) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-004 NIL)) (CL:< INDEX-000 LENGTH-000)) DO
     (CL:PROGN (CL:SETQ MODULE (%%VALUE ITER-004))
      (CL:SETQ ITER-004 (%%REST ITER-004)))
     (CL:PROGN
      (CL:SETQ VEC
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CHANGE-MODULE MODULE)
     (GENERATE-CLASSIFICATION-TRAINING-EXAMPLES VEC RELATION TRUE)))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "Inducing Decision Tree" EOL)
   (CL:SETQ TREE (%INDUCE-DECISION-TREE *TRAINING-EXAMPLES*))
   (CL:SETF (%CONCEPT TREE) RELATION-NAME)
   (CL:WHEN (CL:NOT (CL:EQ (%MODULE (FIRST *TRAINING-EXAMPLES*)) NULL))
    (CHANGE-MODULE (%MODULE (FIRST *TRAINING-EXAMPLES*))))))

;;; (DEFUN (ASK-DECISION-TREE BOOLEAN) ...)

(CL:DEFUN ASK-DECISION-TREE (TREE QUERY)
  (CL:LET* ((SIGNATURE (CREATE-INPUT-SIGNATURE QUERY)))
   (TRAVERSE-DECISION-TREE TREE SIGNATURE)))

;;; (DEFUN (TRAVERSE-DECISION-TREE BOOLEAN) ...)

(CL:DEFUN TRAVERSE-DECISION-TREE (TREE FEATURES)
  (CL:WHEN (CL:EQ (%FEATURE TREE) NULL)
   (CL:RETURN-FROM TRAVERSE-DECISION-TREE (%TRUTH-VALUE TREE)))
  (CL:IF
   (EQL?
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY FEATURES))
     (CL:THE CL:FIXNUM (%FEATURE-INDEX TREE)))
    ONE-WRAPPER)
   (TRAVERSE-DECISION-TREE (%TRUE-BRANCH TREE) FEATURES)
   (TRAVERSE-DECISION-TREE (%FALSE-BRANCH TREE) FEATURES)))

;;; (DEFUN (INDUCE-DECISION-TREE DECISION-TREE) ...)

(CL:DEFUN %INDUCE-DECISION-TREE (EXAMPLES)
  (CL:LET*
   ((FEATURES (NEW-LIST)) (FEATURE NULL) (TREE NULL) (PROPS (NEW-LIST))
    (HOME *MODULE*) (PROPOSITION-TABLE (NEW-HASH-TABLE)))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "  Inducing decision tree" EOL)
   (CL:WHEN (CL:NOT (CL:EQ (%MODULE (FIRST EXAMPLES)) NULL))
    (CHANGE-MODULE (%MODULE (FIRST EXAMPLES))))
   (CL:SETQ PROPS
    (GET-CLASSIFICATION-RELATIONS (%QUERY (FIRST EXAMPLES))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH PROPS))) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:SETQ FEATURE
      (INTERN-SYMBOL (CONCATENATE "A" (STRINGIFY (WRAP-INTEGER I)))))
     (INSERT-AT PROPOSITION-TABLE FEATURE (NTH PROPS I))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS FEATURE NIL))
       (CL:IF (CL:EQ (%THE-CONS-LIST FEATURES) NIL)
        (CL:SETF (%THE-CONS-LIST FEATURES) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST FEATURES)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS FEATURE NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:SETQ TREE (BUILD-DECISION-TREE EXAMPLES FEATURES NIL))
   (ADD-PROPOSITIONS-TO-DECISION-TREE TREE PROPOSITION-TABLE) TREE))

(CL:DEFMACRO INDUCE-DECISION-TREE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/INDUCE-DECISION-TREE)) (CL:MACRO-FUNCTION (CL:QUOTE INDUCE-DECISION-TREE)))

;;; (DEFUN ADD-PROPOSITIONS-TO-DECISION-TREE ...)

(CL:DEFUN ADD-PROPOSITIONS-TO-DECISION-TREE (TREE TABLE)
  (CL:WHEN (CL:EQ (%FEATURE TREE) NULL)
   (CL:RETURN-FROM ADD-PROPOSITIONS-TO-DECISION-TREE))
  (CL:SETF (%PROPOSITION TREE) (LOOKUP TABLE (%FEATURE TREE)))
  (ADD-PROPOSITIONS-TO-DECISION-TREE (%TRUE-BRANCH TREE) TABLE)
  (ADD-PROPOSITIONS-TO-DECISION-TREE (%FALSE-BRANCH TREE) TABLE))

;;; (DEFUN (BUILD-DECISION-TREE OBJECT) ...)

(CL:DEFUN BUILD-DECISION-TREE (EXAMPLES FEATURES FEATURE-STACK)
  (CL:LET*
   ((P 0) (N 0) (CURRENT-ENTROPY 0.0d0) (NEW-ENTROPY 0.0d0)
    (TREE (NEW-DECISION-TREE)) (MIN-NEW-ENTROPY 1.0d0) (FEATURE-INDEX 0)
    (SPLIT-FEATURE NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM P N FEATURE-INDEX)
    (CL:TYPE CL:DOUBLE-FLOAT CURRENT-ENTROPY NEW-ENTROPY MIN-NEW-ENTROPY))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:IF (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (%OUTPUT EXAMPLE))
      (CL:SETQ P (CL:1+ P)) (CL:SETQ N (CL:1+ N)))))
   (CL:IF (CL:> P N) (CL:SETF (%TRUTH-VALUE TREE) TRUE)
    (CL:SETF (%TRUTH-VALUE TREE) FALSE))
   (CL:WHEN (CL:OR (CL:= P 0) (CL:= N 0))
    (CL:RETURN-FROM BUILD-DECISION-TREE TREE))
   (CL:SETQ CURRENT-ENTROPY (ENTROPY P N))
   (CL:LET*
    ((I NULL-INTEGER) (FEATURE NULL) (ITER-001 (%THE-CONS-LIST FEATURES))
     (ITER-002 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-002 I))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ FEATURE (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
     (CL:WHEN (CL:NOT (MEMBER? FEATURE-STACK FEATURE))
      (CL:SETQ NEW-ENTROPY (EXPECTED-ENTROPY I EXAMPLES))
      (CL:WHEN (CL:< NEW-ENTROPY MIN-NEW-ENTROPY)
       (CL:WHEN *TRACE-ID3*
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
         "Info gain for feature " FEATURE ": "
         (CL:- CURRENT-ENTROPY NEW-ENTROPY) EOL))
       (CL:SETQ MIN-NEW-ENTROPY NEW-ENTROPY) (CL:SETQ FEATURE-INDEX I)
       (CL:SETQ SPLIT-FEATURE FEATURE)))))
   (CL:WHEN *TRACE-ID3*
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "Splitting on feature " SPLIT-FEATURE EOL))
   (CL:WHEN (CL:EQ SPLIT-FEATURE NULL)
    (CL:RETURN-FROM BUILD-DECISION-TREE TREE))
   (CL:LET* ((LEFT-EXAMPLES (NEW-LIST)) (RIGHT-EXAMPLES (NEW-LIST)))
    (CL:LET* ((EXAMPLE NULL) (ITER-003 (%THE-CONS-LIST EXAMPLES)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
      (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-003))
       (CL:SETQ ITER-003 (%%REST ITER-003)))
      (CL:IF
       (EQL?
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE)))
         FEATURE-INDEX)
        ONE-WRAPPER)
       (PUSH LEFT-EXAMPLES EXAMPLE) (PUSH RIGHT-EXAMPLES EXAMPLE))))
    (CL:SETF (%FEATURE TREE) SPLIT-FEATURE)
    (CL:SETF (%FEATURE-INDEX TREE) FEATURE-INDEX)
    (CL:SETF (%TRUE-BRANCH TREE)
     (BUILD-DECISION-TREE LEFT-EXAMPLES FEATURES
      (CONS SPLIT-FEATURE FEATURE-STACK)))
    (CL:SETF (%FALSE-BRANCH TREE)
     (BUILD-DECISION-TREE RIGHT-EXAMPLES FEATURES
      (CONS SPLIT-FEATURE FEATURE-STACK))))
   TREE))

;;; (DEFUN (EXPECTED-ENTROPY FLOAT) ...)

(CL:DEFUN EXPECTED-ENTROPY (FEATURE-INDEX EXAMPLES)
  (CL:DECLARE (CL:TYPE CL:FIXNUM FEATURE-INDEX))
  (CL:LET* ((E 0.0d0) (NUM-EXAMPLES (LENGTH EXAMPLES)) (P 0) (N 0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT E)
    (CL:TYPE CL:FIXNUM NUM-EXAMPLES P N))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN
      (EQL?
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE)))
        FEATURE-INDEX)
       ONE-WRAPPER)
      (CL:IF (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (%OUTPUT EXAMPLE))
       (CL:SETQ P (CL:1+ P)) (CL:SETQ N (CL:1+ N))))))
   (CL:SETQ E
    (CL:* (CL:/ (CL:FLOAT (CL:+ P N) 0.0d0) NUM-EXAMPLES) (ENTROPY P N)))
   (CL:SETQ P 0) (CL:SETQ N 0)
   (CL:LET* ((EXAMPLE NULL) (ITER-001 (%THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:WHEN
      (EQL?
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE)))
        FEATURE-INDEX)
       ZERO-WRAPPER)
      (CL:IF (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (%OUTPUT EXAMPLE))
       (CL:SETQ P (CL:1+ P)) (CL:SETQ N (CL:1+ N))))))
   (CL:SETQ E
    (CL:+ E
     (CL:* (CL:/ (CL:FLOAT (CL:+ P N) 0.0d0) NUM-EXAMPLES)
      (ENTROPY P N))))
   E))

;;; (DEFUN (ENTROPY FLOAT) ...)

(CL:DEFUN ENTROPY (P N)
  (CL:DECLARE (CL:TYPE CL:FIXNUM P N))
  (CL:WHEN (CL:AND (CL:= P 0) (CL:= N 0)) (CL:RETURN-FROM ENTROPY 0.0d0))
  (CL:LET*
   ((SUM (CL:+ P N)) (POS-IMPURITY 0.0d0)
    (POS-PERC (CL:/ (CL:FLOAT P 0.0d0) SUM)) (NEG-IMPURITY 0.0d0)
    (NEG-PERC (CL:/ (CL:FLOAT N 0.0d0) SUM)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SUM)
    (CL:TYPE CL:DOUBLE-FLOAT POS-IMPURITY POS-PERC NEG-IMPURITY NEG-PERC))
   (CL:IF (CL:= P 0) (CL:SETQ POS-IMPURITY (CL:FLOAT 0 0.0d0))
    (CL:SETQ POS-IMPURITY
     (CL:- 0
      (CL:* POS-PERC
       (CL:/ (CL:THE CL:DOUBLE-FLOAT (CL:LOG POS-PERC))
        (CL:THE CL:DOUBLE-FLOAT
         (CL:LOG (CL:THE CL:DOUBLE-FLOAT (CL:FLOAT 2 0.0d0)))))))))
   (CL:IF (CL:= N 0) (CL:SETQ NEG-IMPURITY (CL:FLOAT 0 0.0d0))
    (CL:SETQ NEG-IMPURITY
     (CL:- 0
      (CL:* NEG-PERC
       (CL:/ (CL:THE CL:DOUBLE-FLOAT (CL:LOG NEG-PERC))
        (CL:THE CL:DOUBLE-FLOAT
         (CL:LOG (CL:THE CL:DOUBLE-FLOAT (CL:FLOAT 2 0.0d0)))))))))
   (CL:+ POS-IMPURITY NEG-IMPURITY)))

;;; (DEFUN PRINT-DECISION-TREE ...)

(CL:DEFUN PRINT-DECISION-TREE (TREE)
  (HELP-PRINT-DECISION-TREE TREE 0))

;;; (DEFUN HELP-PRINT-DECISION-TREE ...)

(CL:DEFUN HELP-PRINT-DECISION-TREE (TREE LEVEL)
  (CL:DECLARE (CL:TYPE CL:FIXNUM LEVEL))
  (CL:WHEN (CL:EQ (%FEATURE TREE) NULL)
   (CL:IF (%TRUTH-VALUE TREE)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "True" EOL)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "False" EOL))
   (CL:RETURN-FROM HELP-PRINT-DECISION-TREE))
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL)
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 LEVEL)
    (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
   (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000))
    DO (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "|   ")))
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) (%PROPOSITION TREE)
   " = 1: ")
  (HELP-PRINT-DECISION-TREE (%TRUE-BRANCH TREE) (CL:1+ LEVEL))
  (CL:LET*
   ((I NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-001 LEVEL)
    (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 UPPER-BOUND-001 I))
   (CL:LOOP WHILE (CL:OR UNBOUNDED?-001 (CL:<= ITER-001 UPPER-BOUND-001))
    DO (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "|   ")))
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) (%PROPOSITION TREE)
   " = 0: ")
  (HELP-PRINT-DECISION-TREE (%FALSE-BRANCH TREE) (CL:1+ LEVEL)))

;;; (DEFUN (GET-RULES-FROM-TREE (LIST OF CONS)) ...)

(CL:DEFUN GET-RULES-FROM-TREE (QUERY TREE)
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
   "  Extracting rules from decision tree" EOL)
  (BUILD-RULES-FROM-TREE TREE (GET-CLASSIFICATION-RELATIONS QUERY)))

;;; (DEFUN (BUILD-RULES-FROM-TREE (LIST OF CONS)) ...)

(CL:DEFUN BUILD-RULES-FROM-TREE (TREE PROPS)
  (CL:LET*
   ((RULES (NEW-LIST)) (VARS NULL) (TEMP-RULE NIL) (NEW-RULES (NEW-LIST))
    (RELATION (%%VALUE (%QUERY (FIRST *TRAINING-EXAMPLES*))))
    (SORTED-EXAMPLES (NEW-LIST)) (CONS-PROPS NIL))
   (CL:LET*
    ((PROP NULL) (ITER-000 (%THE-CONS-LIST PROPS)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ PROP (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000 (CONS (PROPOSITION-TO-CONS PROP) NIL))
       (CL:IF (CL:EQ CONS-PROPS NIL) (CL:SETQ CONS-PROPS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST CONS-PROPS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (PROPOSITION-TO-CONS PROP) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:SETQ *INDUCED-DECISION-RULES* (NEW-LIST))
   (EXTRACT-PATHS-FROM-TREE TREE NIL RULES) RULES))

;;; (DEFUN EXTRACT-PATHS-FROM-TREE ...)

(CL:DEFUN EXTRACT-PATHS-FROM-TREE (TREE ANTECEDENT-STACK ANTECEDENT)
  (CL:WHEN (CL:EQ (%FEATURE TREE) NULL)
   (PUSH ANTECEDENT
    (CONS (CL:IF (%TRUTH-VALUE TREE) TRUE-WRAPPER FALSE-WRAPPER)
     ANTECEDENT-STACK))
   (CL:RETURN-FROM EXTRACT-PATHS-FROM-TREE))
  (CL:LET* ((PROP (PROPOSITION-TO-CONS (%PROPOSITION TREE))))
   (EXTRACT-PATHS-FROM-TREE (%TRUE-BRANCH TREE)
    (CONS PROP ANTECEDENT-STACK) ANTECEDENT)
   (EXTRACT-PATHS-FROM-TREE (%FALSE-BRANCH TREE)
    (CONS (LIST* SYM-RULE-INDUCTION-LOGIC-FAIL PROP NIL) ANTECEDENT-STACK)
    ANTECEDENT)))

;;; (DEFUN SORT-EXAMPLES-BY-TREE ...)

(CL:DEFUN SORT-EXAMPLES-BY-TREE (TREE EXAMPLES SORTED-EXAMPLES)
  (CL:WHEN (CL:EQ (%FEATURE TREE) NULL) (PUSH SORTED-EXAMPLES EXAMPLES)
   (CL:RETURN-FROM SORT-EXAMPLES-BY-TREE))
  (CL:LET* ((TRUE-EXAMPLES (NEW-LIST)) (FALSE-EXAMPLES (NEW-LIST)))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ EXAMPLE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:IF
      (EQL?
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT EXAMPLE)))
        (CL:THE CL:FIXNUM (%FEATURE-INDEX TREE)))
       ONE-WRAPPER)
      (PUSH TRUE-EXAMPLES EXAMPLE) (PUSH FALSE-EXAMPLES EXAMPLE))))
   (SORT-EXAMPLES-BY-TREE (%TRUE-BRANCH TREE) TRUE-EXAMPLES
    SORTED-EXAMPLES)
   (SORT-EXAMPLES-BY-TREE (%FALSE-BRANCH TREE) FALSE-EXAMPLES
    SORTED-EXAMPLES)))

;;; (DEFUN ASSERT-INDUCED-RULES ...)

(CL:DEFUN ASSERT-INDUCED-RULES ()
  (CL:LET* ((COMMAND NIL) (NAME NULL) (VARS NULL) (TYPES NIL))
   (CL:LET*
    ((RULE NULL) (ITER-000 (%THE-CONS-LIST *INDUCED-DECISION-RULES*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ RULE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:SETQ NAME
      (INTERN-SYMBOL
       (CONCATENATE "Induced-Rule-"
        (STRINGIFY (WRAP-INTEGER *INDUCED-RULE-COUNTER*)))))
     (CL:SETQ VARS (GET-VARIABLES-FROM-CONS-PROPOSITIONS RULE))
     (CL:SETQ TYPES NIL)
     (CL:IF *ENABLE-USER-THING*
      (CL:LET*
       ((VAR NULL) (ITER-001 (%THE-CONS-LIST VARS)) (COLLECT-000 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:PROGN (CL:SETQ VAR (%%VALUE ITER-001))
         (CL:SETQ ITER-001 (%%REST ITER-001)))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-000
           (CONS (CONS VAR (CONS SYM-RULE-INDUCTION-LOGIC-USER-THING NIL))
            NIL))
          (CL:IF (CL:EQ TYPES NIL) (CL:SETQ TYPES COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST TYPES COLLECT-000)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-000)
           (CONS (CONS VAR (CONS SYM-RULE-INDUCTION-LOGIC-USER-THING NIL))
            NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
      (CL:LET*
       ((VAR NULL) (ITER-002 (%THE-CONS-LIST VARS)) (COLLECT-001 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:PROGN (CL:SETQ VAR (%%VALUE ITER-002))
         (CL:SETQ ITER-002 (%%REST ITER-002)))
        (CL:IF (CL:EQ COLLECT-001 NULL)
         (CL:PROGN (CL:SETQ COLLECT-001 (CONS VAR NIL))
          (CL:IF (CL:EQ TYPES NIL) (CL:SETQ TYPES COLLECT-001)
           (ADD-CONS-TO-END-OF-CONS-LIST TYPES COLLECT-001)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS VAR NIL))
          (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))))
     (CL:SETQ *INDUCED-RULE-COUNTER* (CL:1+ *INDUCED-RULE-COUNTER*))
     (CL:SETQ COMMAND
      (LIST* SYM-RULE-INDUCTION-LOGIC-DEFRULE NAME
       (CONS
        (LIST* SYM-RULE-INDUCTION-STELLA-FORALL TYPES
         (CONS (COPY-CONS-TREE RULE) NIL))
        NIL)))
     (CL:IF *LOG-INDUCED-RULES*
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) COMMAND EOL EOL)
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Asserting " NAME
       EOL))
     (EVALUATE-LOGIC-COMMAND COMMAND FALSE)))))

;;; (DEFUN SET-CANDIDATE-CLAUSES ...)

(CL:DEFUN SET-CANDIDATE-CLAUSES (CLASS-NAME)
  (CL:LET*
   ((CLAUSES
     (LOOKUP *CASE-ANTECEDENT-TABLE*
      (CONCATENATE (%SYMBOL-NAME CLASS-NAME) "-match"))))
   (CL:SETQ *CANDIDATE-CLAUSES* (NEW-VECTOR (LENGTH CLAUSES)))
   (CL:LET*
    ((K NULL-INTEGER) (CLAUSE NULL) (ITER-000 (%THE-CONS-LIST CLAUSES))
     (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 K))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ CLAUSE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ K ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:LET
      ((SELF (%THE-ARRAY *CANDIDATE-CLAUSES*)) (VALUE CLAUSE)
       (POSITION K))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))))

;;; (DEFUN (GET-VARIABLES-FROM-PROPOSITION-LIST (LIST OF SYMBOL)) ...)

(CL:DEFUN GET-VARIABLES-FROM-PROPOSITION-LIST (PROPS)
  (CL:LET* ((THE-LIST (NEW-LIST)) (VARIABLE NULL))
   (CL:LET* ((PROP NULL) (ITER-000 (%THE-CONS-LIST PROPS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ PROP (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:LET* ((TEST-VALUE-000 (%KIND PROP)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-000 KWD-RULE-INDUCTION-OR)
         (CL:EQ TEST-VALUE-000 KWD-RULE-INDUCTION-NOT)
         (CL:EQ TEST-VALUE-000 KWD-RULE-INDUCTION-AND))
        (CL:LET*
         ((VAR NULL)
          (ITER-001
           (%THE-CONS-LIST
            (GET-VARIABLES-FROM-PROPOSITION-LIST
             (LISTIFY (%ARGUMENTS PROP))))))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:PROGN (CL:SETQ VAR (%%VALUE ITER-001))
           (CL:SETQ ITER-001 (%%REST ITER-001)))
          (INSERT-NEW THE-LIST VAR))))
       (CL:T
        (CL:LET*
         ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROP)) (INDEX-000 0)
          (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:PROGN
           (CL:SETQ ARG
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
             INDEX-000))
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
          (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE ARG)))
           (CL:COND
            ((SUBTYPE-OF? TEST-VALUE-001
              SGT-RULE-INDUCTION-LOGIC-PATTERN-VARIABLE)
             (CL:PROGN (CL:SETQ VARIABLE (%SKOLEM-NAME ARG))))
            ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
             (CL:PROGN (CL:SETQ VARIABLE ARG)))
            ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
             (CL:PROGN
              (CL:SETQ VARIABLE (INTERN-SYMBOL (%SYMBOL-NAME ARG)))))
            ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
             (CL:PROGN (CL:SETQ VARIABLE NULL)))
            ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
             (CL:PROGN (CL:SETQ VARIABLE NULL)))
            ((SUBTYPE-OF-STRING? TEST-VALUE-001)
             (CL:PROGN (CL:SETQ VARIABLE NULL)))
            ((SUBTYPE-OF? TEST-VALUE-001
              SGT-RULE-INDUCTION-LOGIC-PROPOSITION)
             (CL:PROGN
              (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
               "Dave, you've got a proposition" EOL)))
            ((SUBTYPE-OF? TEST-VALUE-001
              SGT-RULE-INDUCTION-LOGIC-LOGIC-OBJECT)
             (CL:PROGN (CL:SETQ VARIABLE (OBJECT-NAME ARG))))
            (CL:T
             (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
              (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
               TEST-VALUE-001 "' is not a valid case option")
              (CL:ERROR
               (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
          (CL:WHEN (CL:NOT (CL:EQ VARIABLE NULL))
           (INSERT-NEW THE-LIST VARIABLE)))))))))
   THE-LIST))

;;; (DEFUN (GET-VARIABLES-FROM-CONS-PROPOSITIONS (LIST OF SYMBOL)) ...)

(CL:DEFUN GET-VARIABLES-FROM-CONS-PROPOSITIONS (PROPS)
  (HELP-GET-VARIABLES-FROM-CONS-PROPOSITIONS PROPS (NEW-LIST)))

;;; (DEFUN (HELP-GET-VARIABLES-FROM-CONS-PROPOSITIONS (LIST OF SYMBOL)) ...)

(CL:DEFUN HELP-GET-VARIABLES-FROM-CONS-PROPOSITIONS (ELE THE-LIST)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ELE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-RULE-INDUCTION-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((ARG NULL) (ITER-000 ELE))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-000))
         (CL:SETQ ITER-000 (%%REST ITER-000)))
        (HELP-GET-VARIABLES-FROM-CONS-PROPOSITIONS ARG THE-LIST)))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN
       (CL:EQL
        (CL:LET ((SELF (%SYMBOL-NAME ELE)) (POSITION 0))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION)))
        #\?)
       (INSERT-NEW THE-LIST ELE))))
    (CL:T)))
  THE-LIST)

;;; (DEFUN (GET-PROPOSITIONS-FROM-DECISION-TREE (LIST OF PROPOSITION)) ...)

(CL:DEFUN GET-PROPOSITIONS-FROM-DECISION-TREE (TREE)
  (CL:WHEN (CL:EQ (%FEATURE TREE) NULL)
   (CL:RETURN-FROM GET-PROPOSITIONS-FROM-DECISION-TREE (NEW-LIST)))
  (CL:LET*
   ((THE-LIST
     (CONCATENATE
      (GET-PROPOSITIONS-FROM-DECISION-TREE (%TRUE-BRANCH TREE))
      (GET-PROPOSITIONS-FROM-DECISION-TREE (%FALSE-BRANCH TREE)))))
   (PUSH THE-LIST (%PROPOSITION TREE)) THE-LIST))

(CL:DEFUN HELP-STARTUP-RULE-INDUCTION1 ()
  (CL:PROGN
   (CL:SETQ KWD-RULE-INDUCTION-TOP-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOP-DOWN" NULL 2))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-SET-SIGNATURE-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-SIGNATURE-STRATEGY" NULL 0))
   (CL:SETQ KWD-RULE-INDUCTION-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-RULE-INDUCTION-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-SET-SIGNATURE-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-SIGNATURE-RULES" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-SET-RULE-INDUCTION-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-RULE-INDUCTION-STRATEGY" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-SET-RECURSIVE-DECISION-NODES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-RECURSIVE-DECISION-NODES" NULL
     0))
   (CL:SETQ SGT-RULE-INDUCTION-LOGIC-DECISION-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DECISION-TREE" NULL 1))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-FEATURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FEATURE" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-FEATURE-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FEATURE-INDEX" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-CONCEPT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEPT" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-TRUE-BRANCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE-BRANCH" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-FALSE-BRANCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE-BRANCH" NULL 0))
   (CL:SETQ KWD-RULE-INDUCTION-BOTTOM-UP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOTTOM-UP" NULL 2))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-INDUCE-INFERENCE-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INDUCE-INFERENCE-RULES" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-?Y
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?Y" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-=>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=>"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-BOTTOM-UP-RULE-INDUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOTTOM-UP-RULE-INDUCTION" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA->
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">" (GET-STELLA-MODULE "/STELLA" TRUE)
     0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-<
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<" (GET-STELLA-MODULE "/STELLA" TRUE)
     0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA->=
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">="
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-=<
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=<"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SGT-RULE-INDUCTION-STELLA-NUMBER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 0))
   (CL:SETQ KWD-RULE-INDUCTION-DECISION-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DECISION-TREE" NULL 2))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-TOP-DOWN-RULE-INDUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOP-DOWN-RULE-INDUCTION" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-USER-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USER-THING" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ KWD-RULE-INDUCTION-TIMEOUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMEOUT" NULL 2))
   (CL:SETQ KWD-RULE-INDUCTION-DONT-OPTIMIZE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-OPTIMIZE?" NULL 2))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-EVALUATE-RULE-INDUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATE-RULE-INDUCTION" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-INDUCE-DECISION-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INDUCE-DECISION-RULES" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-INDUCE-DECISION-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INDUCE-DECISION-TREE" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-DEFRULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFRULE" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ KWD-RULE-INDUCTION-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-RULE-INDUCTION-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-RULE-INDUCTION-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ SGT-RULE-INDUCTION-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-RULE-INDUCTION-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SGT-RULE-INDUCTION-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SGT-RULE-INDUCTION-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-STARTUP-RULE-INDUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-RULE-INDUCTION" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))))

(CL:DEFUN HELP-STARTUP-RULE-INDUCTION2 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "SET-SIGNATURE-STRATEGY"
    "(DEFUN SET-SIGNATURE-STRATEGY ((K KEYWORD)) :COMMAND? TRUE)"
    (CL:FUNCTION %SET-SIGNATURE-STRATEGY) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-SIGNATURE-RULES"
    "(DEFUN SET-SIGNATURE-RULES ((B BOOLEAN)) :COMMAND? TRUE)"
    (CL:FUNCTION %SET-SIGNATURE-RULES)
    (CL:FUNCTION SET-SIGNATURE-RULES-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-RULE-INDUCTION-STRATEGY"
    "(DEFUN SET-RULE-INDUCTION-STRATEGY ((K KEYWORD)) :COMMAND? TRUE)"
    (CL:FUNCTION %SET-RULE-INDUCTION-STRATEGY) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-RECURSIVE-DECISION-NODES"
    "(DEFUN SET-RECURSIVE-DECISION-NODES ((B BOOLEAN)) :COMMAND? TRUE)"
    (CL:FUNCTION %SET-RECURSIVE-DECISION-NODES)
    (CL:FUNCTION SET-RECURSIVE-DECISION-NODES-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "INDUCE-INFERENCE-RULES"
    "(DEFUN INDUCE-INFERENCE-RULES ((RELATION-NAME SYMBOL) (CLASS-NAME SYMBOL)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %INDUCE-INFERENCE-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "MODULAR-INDUCE-INFERENCE-RULES"
    "(DEFUN MODULAR-INDUCE-INFERENCE-RULES ((RELATION-NAME SYMBOL) (CLASS-NAME SYMBOL) (MODULES (LIST OF MODULE))))"
    (CL:FUNCTION MODULAR-INDUCE-INFERENCE-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "BOTTOM-UP-RULE-INDUCTION"
    "(DEFUN BOTTOM-UP-RULE-INDUCTION ((EXAMPLES (LIST OF TRAINING-EXAMPLE))) :COMMAND? TRUE)"
    (CL:FUNCTION %BOTTOM-UP-RULE-INDUCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "LEARN-ONE-RULE-BOTTOM-UP"
    "(DEFUN (LEARN-ONE-RULE-BOTTOM-UP (CONS OF CONS)) ((POSITIVE (LIST OF TRAINING-EXAMPLE)) (NEGATIVE (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION LEARN-ONE-RULE-BOTTOM-UP) NULL)
   (DEFINE-FUNCTION-OBJECT "LEAST-GENERAL-GENERALIZATION"
    "(DEFUN (LEAST-GENERAL-GENERALIZATION CONS) ((CLAUSE1 (CONS OF CONS)) (CLAUSE2 (CONS OF CONS))))"
    (CL:FUNCTION LEAST-GENERAL-GENERALIZATION) NULL)
   (DEFINE-FUNCTION-OBJECT "GENERALIZE-INEQUALITY"
    "(DEFUN (GENERALIZE-INEQUALITY CONS) ((PROBE CONS) (MATCH CONS) (BINDINGS (LIST OF CONS))))"
    (CL:FUNCTION GENERALIZE-INEQUALITY) NULL)
   (DEFINE-FUNCTION-OBJECT "BOTH-NUMBERS?"
    "(DEFUN (BOTH-NUMBERS? BOOLEAN) ((T1 OBJECT) (T2 OBJECT)))"
    (CL:FUNCTION BOTH-NUMBERS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EITHER-NUMBERS?"
    "(DEFUN (EITHER-NUMBERS? BOOLEAN) ((T1 OBJECT) (T2 OBJECT)))"
    (CL:FUNCTION EITHER-NUMBERS?) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-REDUNDANT-CLAUSES"
    "(DEFUN (REMOVE-REDUNDANT-CLAUSES (CONS OF CONS)) ((CLAUSES (CONS OF CONS))))"
    (CL:FUNCTION REMOVE-REDUNDANT-CLAUSES) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-VARIABLE-IN-BINDINGS"
    "(DEFUN (LOOKUP-VARIABLE-IN-BINDINGS OBJECT) ((OBJ1 OBJECT) (OBJ2 OBJECT) (BINDINGS (LIST OF CONS))))"
    (CL:FUNCTION LOOKUP-VARIABLE-IN-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "LEARN-ONE-RULE-BOTTOM-UP-FROM-SIGNATURES"
    "(DEFUN (LEARN-ONE-RULE-BOTTOM-UP-FROM-SIGNATURES (CONS OF CONS)) ((POSITIVE (LIST OF TRAINING-EXAMPLE)) (NEGATIVE (LIST OF TRAINING-EXAMPLE)) (COVERED (LIST OF TRAINING-EXAMPLE)) (CONS-PROPS (VECTOR OF CONS))))"
    (CL:FUNCTION LEARN-ONE-RULE-BOTTOM-UP-FROM-SIGNATURES) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERSECT-SIGNATURES"
    "(DEFUN (INTERSECT-SIGNATURES (LIST OF INTEGER-WRAPPER)) ((SIG1 VECTOR) (SIG2 VECTOR)))"
    (CL:FUNCTION INTERSECT-SIGNATURES) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-SIGNATURE-COVERED-EXAMPLES"
    "(DEFUN (REMOVE-SIGNATURE-COVERED-EXAMPLES (LIST OF TRAINING-EXAMPLE)) ((INDICES (LIST OF INTEGER-WRAPPER)) (EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION REMOVE-SIGNATURE-COVERED-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "NUM-SIGNATURE-INDICES-COVERED"
    "(DEFUN (NUM-SIGNATURE-INDICES-COVERED INTEGER) ((INDICES (LIST OF INTEGER-WRAPPER)) (EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION NUM-SIGNATURE-INDICES-COVERED) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNATURE-INDICES-COVER-ANY-EXAMPLE?"
    "(DEFUN (SIGNATURE-INDICES-COVER-ANY-EXAMPLE? BOOLEAN) ((INDICES (LIST OF INTEGER-WRAPPER)) (EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION SIGNATURE-INDICES-COVER-ANY-EXAMPLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNATURE-INDICES-COVER-EXAMPLE?"
    "(DEFUN (SIGNATURE-INDICES-COVER-EXAMPLE? BOOLEAN) ((INDICES (LIST OF INTEGER-WRAPPER)) (EXAMPLE TRAINING-EXAMPLE)))"
    (CL:FUNCTION SIGNATURE-INDICES-COVER-EXAMPLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "TOP-DOWN-RULE-INDUCTION"
    "(DEFUN TOP-DOWN-RULE-INDUCTION ((EXAMPLES (LIST OF TRAINING-EXAMPLE))) :COMMAND? TRUE)"
    (CL:FUNCTION %TOP-DOWN-RULE-INDUCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-ANTECEDENT-FROM-RULE-INDEX"
    "(DEFUN (BUILD-ANTECEDENT-FROM-RULE-INDEX (CONS OF CONS)) ((PROPS (VECTOR OF CONS)) (RULE-INDEX (LIST OF INTEGER-WRAPPER))))"
    (CL:FUNCTION BUILD-ANTECEDENT-FROM-RULE-INDEX) NULL)
   (DEFINE-FUNCTION-OBJECT "LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES"
    "(DEFUN (LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES (CONS OF CONS)) ((POSITIVE (LIST OF TRAINING-EXAMPLE)) (NEGATIVE (LIST OF TRAINING-EXAMPLE)) (COVERED_POS (LIST OF TRAINING-EXAMPLE)) (CONS-PROPS (VECTOR OF CONS))))"
    (CL:FUNCTION LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-COVERED-EXAMPLES"
    "(DEFUN UPDATE-COVERED-EXAMPLES ((FEATURE_INDEX INTEGER) (COVERED_POS (LIST OF TRAINING-EXAMPLE)) (COVERED_NEG (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION UPDATE-COVERED-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "FOIL-GAIN"
    "(DEFUN (FOIL-GAIN FLOAT) ((FEATURE-INDEX INTEGER) (UTILITY FLOAT) (COVERED-POS (LIST OF TRAINING-EXAMPLE)) (COVERED-NEG (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION FOIL-GAIN) NULL)
   (DEFINE-FUNCTION-OBJECT "FOIL-UTILITY"
    "(DEFUN (FOIL-UTILITY FLOAT) ((P INTEGER) (N INTEGER)))"
    (CL:FUNCTION FOIL-UTILITY) NULL)
   (DEFINE-FUNCTION-OBJECT "LEARN-ONE-RULE-TOP-DOWN"
    "(DEFUN (LEARN-ONE-RULE-TOP-DOWN (CONS OF CONS)) ((PROPOSITIONS (VECTOR OF CONS)) (POSITIVE (LIST OF TRAINING-EXAMPLE)) (NEGATIVE (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION LEARN-ONE-RULE-TOP-DOWN) NULL)
   (DEFINE-FUNCTION-OBJECT "SPECIALIZE-RULE"
    "(DEFUN (SPECIALIZE-RULE (CONS OF CONS)) ((RULE (CONS OF CONS)) (PROPOSITIONS (VECTOR OF CONS)) (POSITIVE (LIST OF TRAINING-EXAMPLE)) (NEGATIVE (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION SPECIALIZE-RULE) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-EXCLUDED-EXAMPLES"
    "(DEFUN REMOVE-EXCLUDED-EXAMPLES ((RULE (CONS OF CONS)) (COVERED-POS (LIST OF TRAINING-EXAMPLE)) (COVERED-NEG (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION REMOVE-EXCLUDED-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "QUERY-FOIL-GAIN"
    "(DEFUN (QUERY-FOIL-GAIN FLOAT) ((RULE (CONS OF CONS)) (UTILITY FLOAT) (COVERED-POS (LIST OF TRAINING-EXAMPLE)) (COVERED-NEG (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION QUERY-FOIL-GAIN) NULL)
   (DEFINE-FUNCTION-OBJECT "QUERY-AND-UPDATE-COVERED-EXAMPLES"
    "(DEFUN QUERY-AND-UPDATE-COVERED-EXAMPLES ((RULE (CONS OF CONS)) (UNCOVERED (LIST OF TRAINING-EXAMPLE)) (COVERED (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION QUERY-AND-UPDATE-COVERED-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-COVERED-EXAMPLES"
    "(DEFUN REMOVE-COVERED-EXAMPLES ((RULE (CONS OF CONS)) (UNCOVERED (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION REMOVE-COVERED-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "NUM-EXAMPLES-COVERED"
    "(DEFUN (NUM-EXAMPLES-COVERED INTEGER) ((RULE (CONS OF CONS)) (EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION NUM-EXAMPLES-COVERED) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-COVERED-EXAMPLES"
    "(DEFUN (GET-COVERED-EXAMPLES (LIST OF TRAINING-EXAMPLE)) ((RULE (CONS OF CONS)) (UNCOVERED (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION GET-COVERED-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "RULE-COVERS-ANY-EXAMPLE?"
    "(DEFUN (RULE-COVERS-ANY-EXAMPLE? BOOLEAN) ((RULE (CONS OF CONS)) (EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION RULE-COVERS-ANY-EXAMPLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "RULE-COVERS-EXAMPLE?"
    "(DEFUN (RULE-COVERS-EXAMPLE? BOOLEAN) ((REVERSE-RULE (CONS OF CONS)) (EXAMPLE TRAINING-EXAMPLE)))"
    (CL:FUNCTION RULE-COVERS-EXAMPLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "LINK-VARIABLES-IN-INDUCED-RULE"
    "(DEFUN (LINK-VARIABLES-IN-INDUCED-RULE (LIST OF (CONS OF CONS))) ((RULE (CONS OF CONS)) (EXAMPLES (LIST OF TRAINING-EXAMPLE)) (CONS-PROPS (VECTOR OF CONS))))"
    (CL:FUNCTION LINK-VARIABLES-IN-INDUCED-RULE) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-RULE-INDUCTION"
    "(DEFUN (EVALUATE-RULE-INDUCTION (VECTOR OF FLOAT-WRAPPER)) ((RELATION-NAME SYMBOL) (CLASS-NAME SYMBOL) (NUM-TRIALS INTEGER) (CURVE-SPLITS INTEGER)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %EVALUATE-RULE-INDUCTION)
    (CL:FUNCTION EVALUATE-RULE-INDUCTION-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "TRAIN-AND-TEST-RULE-INDUCTION"
    "(DEFUN (TRAIN-AND-TEST-RULE-INDUCTION FLOAT) ((TRAIN-SET (LIST OF TRAINING-EXAMPLE)) (TEST-SET (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION TRAIN-AND-TEST-RULE-INDUCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "INDUCE-DECISION-RULES"
    "(DEFUN INDUCE-DECISION-RULES ((RELATION-NAME SYMBOL) (CLASS-NAME SYMBOL)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %INDUCE-DECISION-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "MODULAR-INDUCE-DECISION-RULES"
    "(DEFUN MODULAR-INDUCE-DECISION-RULES ((RELATION-NAME SYMBOL) (CLASS-NAME SYMBOL) (MODULES (LIST OF MODULE))))"
    (CL:FUNCTION MODULAR-INDUCE-DECISION-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "ASK-DECISION-TREE"
    "(DEFUN (ASK-DECISION-TREE BOOLEAN) ((TREE DECISION-TREE) (QUERY CONS)))"
    (CL:FUNCTION ASK-DECISION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "TRAVERSE-DECISION-TREE"
    "(DEFUN (TRAVERSE-DECISION-TREE BOOLEAN) ((TREE DECISION-TREE) (FEATURES (VECTOR OF INTEGER-WRAPPER))))"
    (CL:FUNCTION TRAVERSE-DECISION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "INDUCE-DECISION-TREE"
    "(DEFUN (INDUCE-DECISION-TREE DECISION-TREE) ((EXAMPLES (LIST OF TRAINING-EXAMPLE))) :COMMAND? TRUE)"
    (CL:FUNCTION %INDUCE-DECISION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-PROPOSITIONS-TO-DECISION-TREE"
    "(DEFUN ADD-PROPOSITIONS-TO-DECISION-TREE ((TREE DECISION-TREE) (TABLE (HASH-TABLE OF SYMBOL PROPOSITION))))"
    (CL:FUNCTION ADD-PROPOSITIONS-TO-DECISION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-DECISION-TREE"
    "(DEFUN (BUILD-DECISION-TREE OBJECT) ((EXAMPLES (LIST OF TRAINING-EXAMPLE)) (FEATURES (LIST OF SYMBOL)) (FEATURE-STACK (CONS OF SYMBOL))))"
    (CL:FUNCTION BUILD-DECISION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPECTED-ENTROPY"
    "(DEFUN (EXPECTED-ENTROPY FLOAT) ((FEATURE-INDEX INTEGER) (EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION EXPECTED-ENTROPY) NULL)
   (DEFINE-FUNCTION-OBJECT "ENTROPY"
    "(DEFUN (ENTROPY FLOAT) ((P INTEGER) (N INTEGER)))"
    (CL:FUNCTION ENTROPY) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-DECISION-TREE"
    "(DEFUN PRINT-DECISION-TREE ((TREE DECISION-TREE)))"
    (CL:FUNCTION PRINT-DECISION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-PRINT-DECISION-TREE"
    "(DEFUN HELP-PRINT-DECISION-TREE ((TREE DECISION-TREE) (LEVEL INTEGER)))"
    (CL:FUNCTION HELP-PRINT-DECISION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-RULES-FROM-TREE"
    "(DEFUN (GET-RULES-FROM-TREE (LIST OF CONS)) ((QUERY CONS) (TREE DECISION-TREE)))"
    (CL:FUNCTION GET-RULES-FROM-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-RULES-FROM-TREE"
    "(DEFUN (BUILD-RULES-FROM-TREE (LIST OF CONS)) ((TREE DECISION-TREE) (PROPS (LIST OF PROPOSITION))))"
    (CL:FUNCTION BUILD-RULES-FROM-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "EXTRACT-PATHS-FROM-TREE"
    "(DEFUN EXTRACT-PATHS-FROM-TREE ((TREE DECISION-TREE) (ANTECEDENT-STACK (CONS OF CONS)) (ANTECEDENT (LIST OF CONS))))"
    (CL:FUNCTION EXTRACT-PATHS-FROM-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "SORT-EXAMPLES-BY-TREE"
    "(DEFUN SORT-EXAMPLES-BY-TREE ((TREE DECISION-TREE) (EXAMPLES (LIST OF TRAINING-EXAMPLE)) (SORTED-EXAMPLES (LIST OF (LIST OF TRAINING-EXAMPLE)))))"
    (CL:FUNCTION SORT-EXAMPLES-BY-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-INDUCED-RULES"
    "(DEFUN ASSERT-INDUCED-RULES () :COMMAND? TRUE)"
    (CL:FUNCTION ASSERT-INDUCED-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-CANDIDATE-CLAUSES"
    "(DEFUN SET-CANDIDATE-CLAUSES ((CLASS-NAME SYMBOL)))"
    (CL:FUNCTION SET-CANDIDATE-CLAUSES) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-VARIABLES-FROM-PROPOSITION-LIST"
    "(DEFUN (GET-VARIABLES-FROM-PROPOSITION-LIST (LIST OF SYMBOL)) ((PROPS (LIST OF PROPOSITION))))"
    (CL:FUNCTION GET-VARIABLES-FROM-PROPOSITION-LIST) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-VARIABLES-FROM-CONS-PROPOSITIONS"
    "(DEFUN (GET-VARIABLES-FROM-CONS-PROPOSITIONS (LIST OF SYMBOL)) ((PROPS (CONS OF CONS))))"
    (CL:FUNCTION GET-VARIABLES-FROM-CONS-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-GET-VARIABLES-FROM-CONS-PROPOSITIONS"
    "(DEFUN (HELP-GET-VARIABLES-FROM-CONS-PROPOSITIONS (LIST OF SYMBOL)) ((ELE PARSE-TREE) (THE-LIST (LIST OF SYMBOL))))"
    (CL:FUNCTION HELP-GET-VARIABLES-FROM-CONS-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-PROPOSITIONS-FROM-DECISION-TREE"
    "(DEFUN (GET-PROPOSITIONS-FROM-DECISION-TREE (LIST OF PROPOSITION)) ((TREE DECISION-TREE)))"
    (CL:FUNCTION GET-PROPOSITIONS-FROM-DECISION-TREE) NULL)))

(CL:DEFUN STARTUP-RULE-INDUCTION ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-RULE-INDUCTION1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-TOP-DOWN)
    (CL:SETQ *SIGNATURE-STRATEGY* KWD-RULE-INDUCTION-TOP-DOWN))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "DECISION-TREE"
        "(DEFCLASS DECISION-TREE (STANDARD-OBJECT) :SLOTS ((FEATURE :TYPE SYMBOL) (FEATURE-INDEX :TYPE INTEGER) (PROPOSITION :TYPE PROPOSITION) (TRUTH-VALUE :TYPE BOOLEAN) (CONCEPT :TYPE SYMBOL) (TRUE-BRANCH :TYPE DECISION-TREE) (FALSE-BRANCH :TYPE DECISION-TREE)) :PRINT-FORM (PRINT-DECISION-TREE SELF))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-DECISION-TREE))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-DECISION-TREE-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-RULE-INDUCTION2)
    (DEFINE-FUNCTION-OBJECT "STARTUP-RULE-INDUCTION"
     "(DEFUN STARTUP-RULE-INDUCTION () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-RULE-INDUCTION) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-RULE-INDUCTION-LOGIC-STARTUP-RULE-INDUCTION)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-RULE-INDUCTION-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "Startup-Rule-Induction") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *RULE-INDUCTION-STRATEGY* KEYWORD :TOP-DOWN)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SIGNATURE-STRATEGY* KEYWORD :TOP-DOWN)")
    (REGISTER-NATIVE-NAME SYM-RULE-INDUCTION-LOGIC-SET-SIGNATURE-STRATEGY
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ENABLE-USER-THING* BOOLEAN TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *OPTIMIZE-INDUCED-QUERIES* BOOLEAN TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TRACE-ID3* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TRACE-FOIL* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INDUCE-RULES-FROM-SIGNATURES* BOOLEAN TRUE)")
    (REGISTER-NATIVE-NAME SYM-RULE-INDUCTION-LOGIC-SET-SIGNATURE-RULES
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *NUM-LGGS* INTEGER 2000)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ENFORCE-LINKED-VARIABLES* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOG-INDUCED-RULES* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ALLOW-RECURSIVE-DECISION-NODES* BOOLEAN TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOG-DECISION-RULE-CONSTRUCTION* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL LOG_2 FLOAT 0.6931472)")
    (REGISTER-NATIVE-NAME
     SYM-RULE-INDUCTION-LOGIC-SET-RULE-INDUCTION-STRATEGY
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-RULE-INDUCTION-LOGIC-SET-RECURSIVE-DECISION-NODES
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INDUCED-DECISION-RULES* (LIST OF CONS) NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INDUCED-RULE-COUNTER* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CANDIDATE-CLAUSES* (VECTOR OF CONS) NULL)")
    (REGISTER-NATIVE-NAME SYM-RULE-INDUCTION-LOGIC-INDUCE-INFERENCE-RULES
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-RULE-INDUCTION-LOGIC-BOTTOM-UP-RULE-INDUCTION
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *BOTTOM-UP-VARIABLE-COUNTER* INTEGER 0)")
    (REGISTER-NATIVE-NAME SYM-RULE-INDUCTION-LOGIC-TOP-DOWN-RULE-INDUCTION
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-RULE-INDUCTION-LOGIC-EVALUATE-RULE-INDUCTION
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-RULE-INDUCTION-LOGIC-INDUCE-DECISION-RULES
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-RULE-INDUCTION-LOGIC-INDUCE-DECISION-TREE
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION))))
