;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; justifications.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-PATTERN-JUSTIFICATION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-SUBSTITUTION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-REVERSE-POLARITY? NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-TRUTH-VALUE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-POSITIVE-SCORE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-NEGATIVE-SCORE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-STRATEGY NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-PATTERN NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-UP-TRUE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-UP-FAIL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FAILURE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SCAN-COLLECTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-TECHNICAL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-LAY NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SPECIALIST NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-COMPUTED-PREDICATE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-GOAL-COMPLEMENT NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-EQUIVALENCE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SUBSUMPTION-TEST NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-PATTERN-RECORD NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-STELLA-KEY-VALUE-LIST NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-MODUS-TOLLENS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-MODUS-PONENS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS-RULE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-NOT NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-AMPLIFICATION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-ARGUMENTS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-POPPED NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-AND-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-PARTIAL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-REVERSE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-OR-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-DISPROOF NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FAIL-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FAIL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-TIMEOUT NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-DEPTH-CUTOFF NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-RAW NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-INFERENCE-RULE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-STRATEGY NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-TRUTH-VALUE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-POSITIVE-SCORE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SUBSTITUTION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-NOT NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-HOW-MANY NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-NONE NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-FORWARD-GOAL-RECORD NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-GOAL NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-RULE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-PREDICATE NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-CONSEQUENT NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-STARTUP-JUSTIFICATIONS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *CONTEXT* *MODULE* *REVERSEPOLARITY?*
  NIL-LIST NULL-INTEGER UNKNOWN-TRUTH-VALUE *QUERYITERATOR*
  *CURRENTJUSTIFICATION* TRUE-WRAPPER FALSE-WRAPPER NULL-FLOAT NIL))

(CL:DEFUN NEW-JUSTIFICATION ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-JUSTIFICATION))
   (CL:SETF (%JUSTIFICATION.NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%JUSTIFICATION.POSITIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%JUSTIFICATION.TRUTH-VALUE SELF) NULL)
   (CL:SETF (%JUSTIFICATION.REVERSE-POLARITY? SELF) CL:NIL)
   (CL:SETF (%JUSTIFICATION.SUBSTITUTION SELF) NULL)
   (CL:SETF (%JUSTIFICATION.PATTERN-JUSTIFICATION SELF) NULL)
   (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF) NIL)
   (CL:SETF (%JUSTIFICATION.PROPOSITION SELF) NULL)
   (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF JUSTIFICATION))
  SGT-JUSTIFICATIONS-LOGIC-JUSTIFICATION)

(CL:DEFMETHOD INFERENCE-STRATEGY ((SELF JUSTIFICATION))
  NULL)

(CL:DEFUN ACCESS-JUSTIFICATION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE)
    (CL:IF SETVALUE?
     (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.INFERENCE-RULE SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.ANTECEDENTS SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-PATTERN-JUSTIFICATION)
    (CL:IF SETVALUE?
     (CL:SETF (%JUSTIFICATION.PATTERN-JUSTIFICATION SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.PATTERN-JUSTIFICATION SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-SUBSTITUTION)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.SUBSTITUTION SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.SUBSTITUTION SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-REVERSE-POLARITY?)
    (CL:IF SETVALUE?
     (CL:SETF (%JUSTIFICATION.REVERSE-POLARITY? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%JUSTIFICATION.REVERSE-POLARITY? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-TRUTH-VALUE)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.TRUTH-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.TRUTH-VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-POSITIVE-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%JUSTIFICATION.POSITIVE-SCORE SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FLOAT (%JUSTIFICATION.POSITIVE-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-NEGATIVE-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%JUSTIFICATION.NEGATIVE-SCORE SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FLOAT (%JUSTIFICATION.NEGATIVE-SCORE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFUN NEW-PRIMITIVE-STRATEGY ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-PRIMITIVE-STRATEGY))
   (CL:SETF (%PRIMITIVE-STRATEGY.NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%PRIMITIVE-STRATEGY.POSITIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%PRIMITIVE-STRATEGY.TRUTH-VALUE SELF) NULL)
   (CL:SETF (%PRIMITIVE-STRATEGY.REVERSE-POLARITY? SELF) CL:NIL)
   (CL:SETF (%PRIMITIVE-STRATEGY.SUBSTITUTION SELF) NULL)
   (CL:SETF (%PRIMITIVE-STRATEGY.PATTERN-JUSTIFICATION SELF) NULL)
   (CL:SETF (%PRIMITIVE-STRATEGY.ANTECEDENTS SELF) NIL)
   (CL:SETF (%PRIMITIVE-STRATEGY.PROPOSITION SELF) NULL)
   (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF) NULL)
   (CL:SETF (%PRIMITIVE-STRATEGY.INFERENCE-RULE SELF)
    KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PRIMITIVE-STRATEGY))
  SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY)

(CL:DEFMETHOD INFERENCE-STRATEGY ((SELF PRIMITIVE-STRATEGY))
  (%PRIMITIVE-STRATEGY.STRATEGY SELF))

(CL:DEFUN ACCESS-PRIMITIVE-STRATEGY-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE)
    (CL:IF SETVALUE?
     (CL:SETF (%PRIMITIVE-STRATEGY.INFERENCE-RULE SELF) VALUE)
     (CL:SETQ VALUE (%PRIMITIVE-STRATEGY.INFERENCE-RULE SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-STRATEGY)
    (CL:IF SETVALUE?
     (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF) VALUE)
     (CL:SETQ VALUE (%PRIMITIVE-STRATEGY.STRATEGY SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (JUSTIFICATION-ARGUMENT-BOUND-TO OBJECT) ...)

(CL:DEFUN JUSTIFICATION-ARGUMENT-BOUND-TO (ARGUMENT JUSTIFICATION)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARGUMENT)
     SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
    (CL:PROGN
     (CL:WHEN (CL:EQ JUSTIFICATION NULL)
      (CL:SETQ JUSTIFICATION *CURRENTJUSTIFICATION*))
     (CL:WHEN (CL:NOT (CL:EQ JUSTIFICATION NULL))
      (CL:LET*
       ((PATTERN
         (CL:IF
          (CL:EQ (%JUSTIFICATION.INFERENCE-RULE JUSTIFICATION)
           KWD-JUSTIFICATIONS-PATTERN)
          JUSTIFICATION
          (%JUSTIFICATION.PATTERN-JUSTIFICATION JUSTIFICATION)))
        (SUBSTITUTION
         (CL:IF (CL:NOT (CL:EQ PATTERN NULL))
          (%JUSTIFICATION.SUBSTITUTION PATTERN) NULL))
        (VALUE NULL))
       (CL:WHEN (CL:NOT (CL:EQ SUBSTITUTION NULL))
        (CL:SETQ VALUE (LOOKUP SUBSTITUTION ARGUMENT)))
       (CL:WHEN
        (CL:AND (CL:EQ VALUE NULL) (CL:NOT (CL:EQ PATTERN NULL)))
        (CL:SETQ PATTERN
         (%JUSTIFICATION.PATTERN-JUSTIFICATION PATTERN))
        (CL:WHEN (CL:NOT (CL:EQ PATTERN NULL))
         (CL:SETQ VALUE
          (JUSTIFICATION-ARGUMENT-BOUND-TO ARGUMENT PATTERN))))
       (CL:RETURN-FROM JUSTIFICATION-ARGUMENT-BOUND-TO VALUE)))))
   (CL:T (CL:RETURN-FROM JUSTIFICATION-ARGUMENT-BOUND-TO ARGUMENT)))
  NULL)

;;; (DEFUN (YIELD-JUSTIFICATION-SUBSTITUTION ENTITY-MAPPING) ...)

(CL:DEFUN YIELD-JUSTIFICATION-SUBSTITUTION (JUSTIFICATION SUBSTITUTION ARGUMENT)
  (CL:LET*
   ((TOP (%JUSTIFICATION.PROPOSITION JUSTIFICATION))
    (PROPOSITION (CL:IF (CL:EQ ARGUMENT NULL) TOP ARGUMENT)))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
        (CL:PROGN
         (CL:WHEN (FREE-VARIABLE? ARG TOP)
          (CL:WHEN (CL:EQ SUBSTITUTION NULL)
           (CL:SETQ SUBSTITUTION (NEW-KEY-VALUE-LIST)))
          (INSERT-AT SUBSTITUTION ARG
           (JUSTIFICATION-ARGUMENT-BOUND-TO ARG JUSTIFICATION)))))
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-JUSTIFICATIONS-LOGIC-PROPOSITION)
        (CL:PROGN
         (CL:SETQ SUBSTITUTION
          (YIELD-JUSTIFICATION-SUBSTITUTION JUSTIFICATION SUBSTITUTION
           ARG))))
       (CL:T)))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   SUBSTITUTION))

;;; (DEFUN (JUSTIFICATION-EQL? BOOLEAN) ...)

(CL:DEFUN JUSTIFICATION-EQL? (JUST1 JUST2)
  (CL:OR (CL:EQ JUST1 JUST2)
   (CL:AND
    (CL:EQ (%JUSTIFICATION.INFERENCE-RULE JUST1)
     (%JUSTIFICATION.INFERENCE-RULE JUST2))
    (CL:EQ (%JUSTIFICATION.REVERSE-POLARITY? JUST1)
     (%JUSTIFICATION.REVERSE-POLARITY? JUST2))
    (CL:OR
     (CL:AND
      (CL:NOT
       (CL:EQ (%JUSTIFICATION.INFERENCE-RULE JUST1)
        KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY))
      (CL:NOT
       (CL:EQ (%JUSTIFICATION.INFERENCE-RULE JUST2)
        KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY)))
     (CL:EQ (%PRIMITIVE-STRATEGY.STRATEGY JUST1)
      (%PRIMITIVE-STRATEGY.STRATEGY JUST2)))
    (JUSTIFICATION-PROPOSITIONS-EQL? (%JUSTIFICATION.PROPOSITION JUST1)
     JUST1 (%JUSTIFICATION.PROPOSITION JUST2) JUST2))))

;;; (DEFUN (JUSTIFICATION-PROPOSITIONS-EQL? BOOLEAN) ...)

(CL:DEFUN JUSTIFICATION-PROPOSITIONS-EQL? (PROPOSITION1 JUST1 PROPOSITION2 JUST2)
  (CL:WHEN
   (CL:AND
    (CL:EQ (%PROPOSITION.OPERATOR PROPOSITION1)
     (%PROPOSITION.OPERATOR PROPOSITION2))
    (CL:= (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION1))
     (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION2))))
   (CL:LET*
    ((ARG1 NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION1))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (ARG2 NULL)
     (VECTOR-001 (%PROPOSITION.ARGUMENTS PROPOSITION2)) (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
     DO
     (CL:SETQ ARG1
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ ARG2
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
       INDEX-001))
     (CL:WHEN (CL:OR (CL:NOT (EQL? ARG1 ARG2)) (VARIABLE? ARG1))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG1)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000
          SGT-JUSTIFICATIONS-LOGIC-PROPOSITION)
         (CL:PROGN
          (CL:WHEN
           (CL:NOT
            (CL:AND (ISA? ARG2 SGT-JUSTIFICATIONS-LOGIC-PROPOSITION)
             (JUSTIFICATION-PROPOSITIONS-EQL? ARG1 JUST1 ARG2 JUST2)))
           (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:NIL))))
        ((SUBTYPE-OF? TEST-VALUE-000
          SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
         (CL:PROGN
          (CL:COND
           ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARG2)
             SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
            (CL:PROGN
             (CL:LET*
              ((VALUE1 (JUSTIFICATION-ARGUMENT-BOUND-TO ARG1 JUST1))
               (VALUE2 (JUSTIFICATION-ARGUMENT-BOUND-TO ARG2 JUST2)))
              (CL:WHEN
               (CL:OR (CL:EQ VALUE1 NULL) (CL:EQ VALUE2 NULL)
                (CL:NOT (EQL? VALUE1 VALUE2)))
               (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL?
                CL:NIL)))))
           (CL:T
            (CL:WHEN
             (CL:NOT
              (EQL? (JUSTIFICATION-ARGUMENT-BOUND-TO ARG1 JUST1) ARG2))
             (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL?
              CL:NIL))))))
        (CL:T
         (CL:COND
          ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARG2)
            SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
           (CL:PROGN
            (CL:WHEN
             (CL:NOT
              (EQL? (JUSTIFICATION-ARGUMENT-BOUND-TO ARG2 JUST2) ARG1))
             (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:NIL))))
          (CL:T
           (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL?
            CL:NIL)))))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
   (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:T))
  CL:NIL)

;;; (DEFMETHOD (COPY (LIKE SELF)) ...)

(CL:DEFMETHOD COPY ((SELF JUSTIFICATION))
  "Return a copy of the proof starting at `self'.  Allocates
all new justification objects, but structure-shares other information such
as propositions and substitutions."
  (CL:LET* ((COPY NULL) (ANTECEDENTS NIL))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
      SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY)
     (CL:PROGN
      (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY)))
       (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-000)
        (%PRIMITIVE-STRATEGY.STRATEGY SELF))
       (CL:SETQ COPY SELF-000))))
    (CL:T (CL:SETQ COPY (NEW-JUSTIFICATION))))
   (CL:SETF (%JUSTIFICATION.INFERENCE-RULE COPY)
    (%JUSTIFICATION.INFERENCE-RULE SELF))
   (CL:SETF (%JUSTIFICATION.PROPOSITION COPY)
    (%JUSTIFICATION.PROPOSITION SELF))
   (CL:SETF (%JUSTIFICATION.SUBSTITUTION COPY)
    (%JUSTIFICATION.SUBSTITUTION SELF))
   (CL:SETF (%JUSTIFICATION.REVERSE-POLARITY? COPY)
    (%JUSTIFICATION.REVERSE-POLARITY? SELF))
   (CL:SETF (%JUSTIFICATION.TRUTH-VALUE COPY)
    (%JUSTIFICATION.TRUTH-VALUE SELF))
   (CL:SETF (%JUSTIFICATION.POSITIVE-SCORE COPY)
    (%JUSTIFICATION.POSITIVE-SCORE SELF))
   (CL:SETF (%JUSTIFICATION.NEGATIVE-SCORE COPY)
    (%JUSTIFICATION.NEGATIVE-SCORE SELF))
   (CL:LET*
    ((ANTECEDENT NULL) (ITER-000 (%JUSTIFICATION.ANTECEDENTS SELF))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ANTECEDENT (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (COPY ANTECEDENT) NIL))
       (CL:IF (CL:EQ ANTECEDENTS NIL) (CL:SETQ ANTECEDENTS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST ANTECEDENTS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000) (CONS (COPY ANTECEDENT) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETF (%JUSTIFICATION.ANTECEDENTS COPY) ANTECEDENTS)
   (CL:WHEN
    (CL:EQ (%JUSTIFICATION.INFERENCE-RULE SELF)
     KWD-JUSTIFICATIONS-PATTERN)
    (CL:LET*
     ((ANTECEDENT NULL) (ITER-001 (%JUSTIFICATION.ANTECEDENTS COPY)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ ANTECEDENT (%%VALUE ITER-001))
      (BACKLINK-TO-PATTERN-JUSTIFICATION ANTECEDENT COPY)
      (CL:SETQ ITER-001 (%%REST ITER-001)))))
   COPY))

;;; (DEFSPECIAL *RECORD-JUSTIFICATIONS?* ...)

(CL:DEFVAR *RECORD-JUSTIFICATIONS?* CL:NIL
  "If TRUE every query records justifications to enable
the explanation of concluded results.")

;;; (DEFUN (RECORD-JUSTIFICATIONS? BOOLEAN) ...)

(CL:DEFUN RECORD-JUSTIFICATIONS? ()
  "Return TRUE if every query records justifications to enable
the explanation of concluded results."
  *RECORD-JUSTIFICATIONS?*)

;;; (DEFUN RECORD-GOAL-JUSTIFICATION ...)

(CL:DEFUN RECORD-GOAL-JUSTIFICATION (GOAL JUSTIFICATION)
  (CL:WHEN (CL:EQ (%JUSTIFICATION.PROPOSITION JUSTIFICATION) NULL)
   (CL:SETF (%JUSTIFICATION.PROPOSITION JUSTIFICATION)
    (%CONTROL-FRAME.PROPOSITION GOAL)))
  (CL:SETF (%JUSTIFICATION.REVERSE-POLARITY? JUSTIFICATION)
   (%CONTROL-FRAME.REVERSE-POLARITY? GOAL))
  (CL:SETF (%JUSTIFICATION.TRUTH-VALUE JUSTIFICATION)
   (%CONTROL-FRAME.TRUTH-VALUE GOAL))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
    (CL:NOT
     (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
      NULL)))
   (SET-JUSTIFICATION-PARTIAL-TRUTH GOAL JUSTIFICATION))
  (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS GOAL)
   SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION JUSTIFICATION NULL))

;;; (DEFUN RECORD-PRIMITIVE-JUSTIFICATION ...)

(CL:DEFUN RECORD-PRIMITIVE-JUSTIFICATION (FRAME LASTMOVE)
  (CL:COND
   ((CL:OR (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL))
    (CL:LET*
     ((ANTECEDENTS
       (CL:IF
        (CL:AND (CL:NOT (CL:EQ (%CONTROL-FRAME.RESULT FRAME) NULL))
         (CL:NOT
          (CL:EQ
           (DYNAMIC-SLOT-VALUE
            (%CONTROL-FRAME.DYNAMIC-SLOTS
             (%CONTROL-FRAME.RESULT FRAME))
            SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
           NULL)))
        (CONS
         (DYNAMIC-SLOT-VALUE
          (%CONTROL-FRAME.DYNAMIC-SLOTS (%CONTROL-FRAME.RESULT FRAME))
          SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
         NIL)
        NIL)))
     (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY)))
      (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-000)
       (CL:IF (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL)
        KWD-JUSTIFICATIONS-FAILURE
        (%CONTROL-FRAME.CURRENT-STRATEGY FRAME)))
      (CL:SETF (%PRIMITIVE-STRATEGY.ANTECEDENTS SELF-000) ANTECEDENTS)
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000))))
   (CL:T)))

;;; (DEFUN RECORD-PATTERN-JUSTIFICATION ...)

(CL:DEFUN RECORD-PATTERN-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET* ((ARGUMENT (%CONTROL-FRAME.RESULT FRAME)))
   (CL:COND
    ((CL:OR (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
      (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL))
     (CL:WHEN
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS ARGUMENT)
        SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
       NULL)
      (CL:RETURN-FROM RECORD-PATTERN-JUSTIFICATION))
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000)
       KWD-JUSTIFICATIONS-PATTERN)
      (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-000)
       (CONS
        (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS ARGUMENT)
         SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
        NIL))
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000))
     (BACKLINK-TO-PATTERN-JUSTIFICATION
      (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS ARGUMENT)
       SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
      (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
       SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL))
     (CL:LET*
      ((SUBSTITUTION (NEW-KEY-VALUE-LIST))
       (PATTERNRECORD (%CONTROL-FRAME.PATTERN-RECORD FRAME))
       (DESCRIPTION NULL))
      (CL:WHEN (CL:NOT (CL:EQ PATTERNRECORD NULL))
       (CL:COND
        ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE PATTERNRECORD)
          SGT-JUSTIFICATIONS-LOGIC-PATTERN-RECORD)
         (CL:PROGN
          (CL:SETQ DESCRIPTION
           (%PATTERN-RECORD.OPTIMAL-PATTERN PATTERNRECORD))
          (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
           (CL:LET*
            ((VBL NULL)
             (VECTOR-000 (%DESCRIPTION.IO-VARIABLES DESCRIPTION))
             (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
            (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
            (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
             (CL:SETQ VBL
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
               INDEX-000))
             (INSERT-AT SUBSTITUTION VBL
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (%VECTOR.THE-ARRAY
                 (%PATTERN-RECORD.VARIABLE-BINDINGS
                  (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD
                   *QUERYITERATOR*))))
               (CL:THE CL:FIXNUM
                (%PATTERN-VARIABLE.BOUND-TO-OFFSET VBL))))
             (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
           (CL:LET*
            ((VBL NULL)
             (VECTOR-001 (%DESCRIPTION.INTERNAL-VARIABLES DESCRIPTION))
             (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
            (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
            (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
             (CL:SETQ VBL
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
               INDEX-001))
             (INSERT-AT SUBSTITUTION VBL
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (%VECTOR.THE-ARRAY
                 (%PATTERN-RECORD.VARIABLE-BINDINGS
                  (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD
                   *QUERYITERATOR*))))
               (CL:THE CL:FIXNUM
                (%PATTERN-VARIABLE.BOUND-TO-OFFSET VBL))))
             (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))))
        (CL:T)))
      (CL:WHEN
       (ISA? SUBSTITUTION SGT-JUSTIFICATIONS-STELLA-KEY-VALUE-LIST)
       (CL:SETQ SUBSTITUTION (REVERSE SUBSTITUTION)))
      (CL:SETF
       (%JUSTIFICATION.SUBSTITUTION
        (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
         SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL))
       SUBSTITUTION)))
    (CL:T))))

;;; (DEFUN BACKLINK-TO-PATTERN-JUSTIFICATION ...)

(CL:DEFUN BACKLINK-TO-PATTERN-JUSTIFICATION (JUSTIFICATION PATTERN)
  (CL:WHEN
   (CL:EQ (%JUSTIFICATION.PATTERN-JUSTIFICATION JUSTIFICATION) NULL)
   (CL:SETF (%JUSTIFICATION.PATTERN-JUSTIFICATION JUSTIFICATION)
    PATTERN)
   (CL:LET*
    ((ANTECEDENT NULL)
     (ITER-000 (%JUSTIFICATION.ANTECEDENTS JUSTIFICATION)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ANTECEDENT (%%VALUE ITER-000))
     (BACKLINK-TO-PATTERN-JUSTIFICATION ANTECEDENT PATTERN)
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

;;; (DEFUN RECORD-MODUS-PONENS-JUSTIFICATION ...)

(CL:DEFUN RECORD-MODUS-PONENS-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET* ((ANTECEDENT (%CONTROL-FRAME.RESULT FRAME)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:LET*
      ((GOAL (EXTRACT-SUBGOAL-OF-FRAME FRAME))
       (REVERSEPOLARITY? (%CONTROL-FRAME.REVERSE-POLARITY? FRAME))
       (INFERENCERULE
        (CL:IF REVERSEPOLARITY? KWD-JUSTIFICATIONS-MODUS-TOLLENS
         KWD-JUSTIFICATIONS-MODUS-PONENS))
       (RULE
        (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
         SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS-RULE NULL))
       (RULECONSEQUENT
        (%DESCRIPTION.PROPOSITION
         (CL:IF (CL:EQ INFERENCERULE KWD-JUSTIFICATIONS-MODUS-PONENS)
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS RULE)))
           1)
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS RULE)))
           0))))
       (INVERTED?
        (CL:EQ (%PROPOSITION.KIND RULECONSEQUENT)
         KWD-JUSTIFICATIONS-NOT)))
      (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
       (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000) INFERENCERULE)
       (CL:SETF (%JUSTIFICATION.PROPOSITION SELF-000) GOAL)
       (CL:LET* ((SELF-001 (NEW-PRIMITIVE-STRATEGY)))
        (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-001)
         KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS)
        (CL:SETF (%PRIMITIVE-STRATEGY.PROPOSITION SELF-001) RULE)
        (CL:SETF (%PRIMITIVE-STRATEGY.TRUTH-VALUE SELF-001)
         (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE RULE)
          (%PROPOSITION.HOME-CONTEXT RULE) CL:NIL))
        (CL:SETF (%PRIMITIVE-STRATEGY.POSITIVE-SCORE SELF-001)
         (%TRUTH-VALUE.POSITIVE-SCORE
          (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE RULE)
           (%PROPOSITION.HOME-CONTEXT RULE) CL:NIL)))
        (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-000)
         (CONS SELF-001
          (CONS
           (DYNAMIC-SLOT-VALUE
            (%CONTROL-FRAME.DYNAMIC-SLOTS ANTECEDENT)
            SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
           NIL))))
       (CL:LET* ((JUSTIFICATION SELF-000))
        (RECORD-GOAL-JUSTIFICATION FRAME JUSTIFICATION)
        (CL:SETF (%JUSTIFICATION.REVERSE-POLARITY? JUSTIFICATION)
         (CL:IF REVERSEPOLARITY? (CL:NOT INVERTED?) INVERTED?))))))
    (CL:T))))

;;; (DEFUN RECORD-AND-INTRODUCTION-JUSTIFICATION ...)

(CL:DEFUN RECORD-AND-INTRODUCTION-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET*
   ((CONJUNCTS
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-JUSTIFICATIONS-STELLA-ARGUMENTS NULL))
    (ANTECEDENTS NIL))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:LET*
      ((CONJUNCT NULL) (VECTOR-000 CONJUNCTS) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ CONJUNCT
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:PROGN)
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-000
          (CONS
           (CL:IF
            (CL:EQ (%CONTROL-FRAME.STATE CONJUNCT)
             KWD-JUSTIFICATIONS-POPPED)
            (COPY
             (DYNAMIC-SLOT-VALUE
              (%CONTROL-FRAME.DYNAMIC-SLOTS CONJUNCT)
              SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL))
            (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS CONJUNCT)
             SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL))
           NIL))
         (CL:IF (CL:EQ ANTECEDENTS NIL)
          (CL:SETQ ANTECEDENTS COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST ANTECEDENTS COLLECT-000)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-000)
          (CONS
           (CL:IF
            (CL:EQ (%CONTROL-FRAME.STATE CONJUNCT)
             KWD-JUSTIFICATIONS-POPPED)
            (COPY
             (DYNAMIC-SLOT-VALUE
              (%CONTROL-FRAME.DYNAMIC-SLOTS CONJUNCT)
              SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL))
            (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS CONJUNCT)
             SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL))
           NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000)
       KWD-JUSTIFICATIONS-AND-INTRODUCTION)
      (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-000) ANTECEDENTS)
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
    (CL:T))))

;;; (DEFUN RECORD-OR-INTRODUCTION-JUSTIFICATION ...)

(CL:DEFUN RECORD-OR-INTRODUCTION-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET* ((DISJUNCT (%CONTROL-FRAME.RESULT FRAME)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000)
       KWD-JUSTIFICATIONS-OR-INTRODUCTION)
      (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-000)
       (CONS
        (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS DISJUNCT)
         SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
        NIL))
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
    (CL:T))))

;;; (DEFUN RECORD-DISPROOF-JUSTIFICATION ...)

(CL:DEFUN RECORD-DISPROOF-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET* ((ARGUMENT (%CONTROL-FRAME.RESULT FRAME)))
   (CL:COND
    ((CL:OR (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
      (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL))
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000)
       KWD-JUSTIFICATIONS-DISPROOF)
      (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-000)
       (CONS
        (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS ARGUMENT)
         SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
        NIL))
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
    (CL:T))))

;;; (DEFUN RECORD-FAIL-JUSTIFICATION ...)

(CL:DEFUN RECORD-FAIL-JUSTIFICATION (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL)
    (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
     (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000)
      KWD-JUSTIFICATIONS-FAIL-INTRODUCTION)
     (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
   (CL:T)))

;;; (DEFUN RECORD-CLOSED-NOT-JUSTIFICATION ...)

(CL:DEFUN RECORD-CLOSED-NOT-JUSTIFICATION (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL)
    (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
     (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000)
      KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION)
     (CL:SETF (%JUSTIFICATION.PROPOSITION SELF-000)
      (CL:IF
       (CL:EQ (%PROPOSITION.KIND (%CONTROL-FRAME.PROPOSITION FRAME))
        KWD-JUSTIFICATIONS-FAIL)
       (%CONTROL-FRAME.PROPOSITION (%CONTROL-FRAME.UP FRAME))
       (%CONTROL-FRAME.PROPOSITION FRAME)))
     (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
   (CL:T)))

;;; (DEFUN RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION ...)

(CL:DEFUN RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET* ((ARGUMENT (%CONTROL-FRAME.RESULT FRAME)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000)
       KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION)
      (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-000)
       (CL:IF
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS ARGUMENT)
           SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
          NULL))
        (CONS
         (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS ARGUMENT)
          SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
         NIL)
        NIL))
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
    (CL:T))))

;;; (DEFUN (FAILED-GOAL-JUSTIFICATION? BOOLEAN) ...)

(CL:DEFUN FAILED-GOAL-JUSTIFICATION? (SELF)
  (CL:LET* ((TEST-VALUE-000 (%JUSTIFICATION.INFERENCE-RULE SELF)))
   (CL:COND
    ((CL:OR
      (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY)
      (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-TIMEOUT)
      (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-DEPTH-CUTOFF))
     (CL:COND
      ((CL:EQ (%PRIMITIVE-STRATEGY.STRATEGY SELF)
        KWD-JUSTIFICATIONS-FAILURE)
       (CL:RETURN-FROM FAILED-GOAL-JUSTIFICATION? CL:T))
      (CL:T)))
    (CL:T)))
  CL:NIL)

;;; (DEFUN (CUTOFF-GOAL-JUSTIFICATION? BOOLEAN) ...)

(CL:DEFUN CUTOFF-GOAL-JUSTIFICATION? (SELF)
  (CL:LET* ((TEST-VALUE-000 (%JUSTIFICATION.INFERENCE-RULE SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-TIMEOUT)
      (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-DEPTH-CUTOFF))
     (CL:RETURN-FROM CUTOFF-GOAL-JUSTIFICATION? CL:T))
    (CL:T)))
  CL:NIL)

;;; (DEFMETHOD (CONSIFY CONS) ...)

(CL:DEFMETHOD CONSIFY ((SELF JUSTIFICATION))
  "Return a CONS tree representation of the proof `self'.
Each proof step is represented as a CONS tree of the form
  (<proposition> (<key> <value>...) <antecedent>...)
where each <antecedent> is a CONS tree representing a subproof.  The
consification follows the original proof structure literally, i.e., no
uninteresting nodes such as patterns or AND-introductions are suppressed."
  (CONSIFY-JUSTIFICATION SELF KWD-JUSTIFICATIONS-RAW))

;;; (DEFUN (CONSIFY-JUSTIFICATION CONS) ...)

(CL:DEFUN CONSIFY-JUSTIFICATION (SELF STYLE)
  "Return a CONS tree representation of the proof `self'.
Each proof step is represented as a CONS tree of the form
  (<proposition> (<key> <value>...) <antecedent>...)
where each <antecedent> is a CONS tree representing a subproof.
`style' indicates what nodes in the proof tree should be suppressed.
:RAW preserves the original structure literally, :VERBOSE keeps AND-
introductions but suppresses all auxiliary (non-logical) nodes such as
pattern nodes, and :BRIEF additionally suppresses AND-introduction nodes."
  (CL:LET* ((*EXPLANATION-STYLE* STYLE))
   (CL:DECLARE (CL:SPECIAL *EXPLANATION-STYLE*))
   (CL:WHEN (CL:NOT (CL:EQ STYLE KWD-JUSTIFICATIONS-RAW))
    (CL:SETQ SELF (VISIBLE-JUSTIFICATION SELF)))
   (CL:LET*
    ((ANTECEDENTS
      (CL:IF (CL:EQ STYLE KWD-JUSTIFICATIONS-RAW)
       (%JUSTIFICATION.ANTECEDENTS SELF)
       (%LIST.THE-CONS-LIST (VISIBLE-ANTECEDENTS SELF))))
     (PROPOSITION NULL) (KEYS (NEW-PROPERTY-LIST)) (SUBSTITUTION NIL)
     (CONSIFIEDSELF NIL))
    (CL:WHEN (CL:NOT (CL:EQ (%JUSTIFICATION.INFERENCE-RULE SELF) NULL))
     (INSERT-AT KEYS KWD-JUSTIFICATIONS-INFERENCE-RULE
      (%JUSTIFICATION.INFERENCE-RULE SELF))
     (CL:WHEN (ISA? SELF SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY)
      (INSERT-AT KEYS KWD-JUSTIFICATIONS-STRATEGY
       (%PRIMITIVE-STRATEGY.STRATEGY SELF))))
    (CL:IF (CL:NOT (CL:EQ (%JUSTIFICATION.TRUTH-VALUE SELF) NULL))
     (INSERT-AT KEYS KWD-JUSTIFICATIONS-TRUTH-VALUE
      (%JUSTIFICATION.TRUTH-VALUE SELF))
     (INSERT-AT KEYS KWD-JUSTIFICATIONS-TRUTH-VALUE
      UNKNOWN-TRUTH-VALUE))
    (CL:WHEN
     (CL:NOT (CL:= (%JUSTIFICATION.POSITIVE-SCORE SELF) NULL-FLOAT))
     (INSERT-AT KEYS KWD-JUSTIFICATIONS-POSITIVE-SCORE
      (WRAP-FLOAT (%JUSTIFICATION.POSITIVE-SCORE SELF))))
    (CL:LET* ((THESUBSTITUTION (%JUSTIFICATION.SUBSTITUTION SELF)))
     (CL:WHEN (CL:EQ THESUBSTITUTION NULL)
      (CL:LET*
       ((ANT NULL) (ITER-000 (%JUSTIFICATION.ANTECEDENTS SELF)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ ANT (%%VALUE ITER-000))
        (CL:WHEN
         (CL:EQ (%JUSTIFICATION.INFERENCE-RULE ANT)
          KWD-JUSTIFICATIONS-PATTERN)
         (CL:SETQ THESUBSTITUTION (%JUSTIFICATION.SUBSTITUTION ANT))
         (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000)))))
     (CL:WHEN (CL:NOT (CL:EQ THESUBSTITUTION NULL))
      (CL:LET*
       ((VAR NULL) (BINDING NULL)
        (ITER-001 (%KEY-VALUE-LIST.THE-KV-LIST THESUBSTITUTION)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NULL)) DO
        (CL:SETQ VAR (%KV-CONS.KEY ITER-001))
        (CL:SETQ BINDING (%KV-CONS.VALUE ITER-001))
        (CL:SETQ SUBSTITUTION (CONS (GENERATE-TERM VAR) SUBSTITUTION))
        (CL:SETQ SUBSTITUTION
         (CONS (GENERATE-TERM BINDING) SUBSTITUTION))
        (CL:SETQ ITER-001 (%KV-CONS.REST ITER-001))))
      (INSERT-AT KEYS KWD-JUSTIFICATIONS-SUBSTITUTION
       (REVERSE SUBSTITUTION))))
    (CL:LET* ((*CURRENTJUSTIFICATION* SELF))
     (CL:DECLARE (CL:SPECIAL *CURRENTJUSTIFICATION*))
     (CL:SETQ PROPOSITION
      (GENERATE-PROPOSITION (%JUSTIFICATION.PROPOSITION SELF)))
     (CL:WHEN (%JUSTIFICATION.REVERSE-POLARITY? SELF)
      (CL:SETQ PROPOSITION
       (LIST* SYM-JUSTIFICATIONS-STELLA-NOT PROPOSITION NIL))))
    (CL:SETQ CONSIFIEDSELF
     (CONS-LIST PROPOSITION (%PROPERTY-LIST.THE-PLIST KEYS)))
    (CL:LET*
     ((ANTECEDENT NULL) (ITER-002 ANTECEDENTS) (COLLECT-000 NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:SETQ ANTECEDENT (%%VALUE ITER-002))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000
         (CONS (CONSIFY-JUSTIFICATION ANTECEDENT STYLE) NIL))
        (CL:IF (CL:EQ CONSIFIEDSELF NIL)
         (CL:SETQ CONSIFIEDSELF COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST CONSIFIEDSELF COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS (CONSIFY-JUSTIFICATION ANTECEDENT STYLE) NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      (CL:SETQ ITER-002 (%%REST ITER-002))))
    CONSIFIEDSELF)))

;;; (DEFUN (GET-QUERY-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ...)

(CL:DEFUN GET-QUERY-JUSTIFICATIONS (QUERY SOLUTIONINDEX MAXJUSTIFICATIONS CREATE?)
  (CL:DECLARE (CL:TYPE CL:FIXNUM SOLUTIONINDEX MAXJUSTIFICATIONS))
  #+MCL
  (CL:CHECK-TYPE SOLUTIONINDEX CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE MAXJUSTIFICATIONS CL:FIXNUM)
  (CL:LET*
   ((ASKQUERY? (QUERY-IS-TRUE-FALSE? QUERY))
    (SOLUTIONS (%QUERY-ITERATOR.SOLUTIONS QUERY)) (SOLUTION NULL)
    (NOFSOLUTIONS (LENGTH SOLUTIONS)) (JUSTIFICATIONS NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFSOLUTIONS))
   (CL:WHEN (EMPTY? SOLUTIONS)
    (CL:RETURN-FROM GET-QUERY-JUSTIFICATIONS NIL-LIST))
   (CL:WHEN
    (CL:OR ASKQUERY? (NULL? SOLUTIONINDEX) (CL:< SOLUTIONINDEX 0))
    (CL:SETQ SOLUTIONINDEX (CL:1- NOFSOLUTIONS)))
   (CL:WHEN (CL:>= SOLUTIONINDEX NOFSOLUTIONS)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "There were only `" NOFSOLUTIONS "' solutions")
     (CL:ERROR
      (NEW-EXPLAIN-EXCEPTION (THE-STRING-READER STREAM-000)))))
   (CL:SETQ SOLUTION (NTH SOLUTIONS SOLUTIONINDEX))
   (CL:COND
    ((CL:EQ (%QUERY-SOLUTION.JUSTIFICATION SOLUTION) NULL)
     (CL:COND
      (CREATE?
       (CL:SETQ JUSTIFICATIONS
        (DERIVE-QUERY-JUSTIFICATIONS QUERY NULL SOLUTIONINDEX
         MAXJUSTIFICATIONS))
       (CL:SETF (%QUERY-SOLUTION.JUSTIFICATION SOLUTION)
        (FIRST JUSTIFICATIONS))
       (CL:SETF (%QUERY-SOLUTION.ALL-JUSTIFICATIONS SOLUTION)
        JUSTIFICATIONS)
       JUSTIFICATIONS)
      (CL:T NIL-LIST)))
    (CL:T
     (CL:WHEN
      (CL:AND
       (CL:NOT
        (CL:EQ (%QUERY-SOLUTION.ALL-JUSTIFICATIONS SOLUTION) NULL))
       (NON-EMPTY? (%QUERY-SOLUTION.ALL-JUSTIFICATIONS SOLUTION)))
      (CL:SETQ JUSTIFICATIONS (LIST))
      (CL:LET*
       ((JUST NULL)
        (ITER-000
         (%LIST.THE-CONS-LIST
          (%QUERY-SOLUTION.ALL-JUSTIFICATIONS SOLUTION)))
        (I NULL-INTEGER) (ITER-001 1)
        (UPPER-BOUND-000 MAXJUSTIFICATIONS)
        (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)) (COLLECT-000 NULL))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
       (CL:LOOP WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
         (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)))
        DO (CL:SETQ JUST (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS JUST NIL))
          (CL:IF (CL:EQ (%LIST.THE-CONS-LIST JUSTIFICATIONS) NIL)
           (CL:SETF (%LIST.THE-CONS-LIST JUSTIFICATIONS) COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST
            (%LIST.THE-CONS-LIST JUSTIFICATIONS) COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS JUST NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
        (CL:SETQ ITER-000 (%%REST ITER-000))
        (CL:SETQ ITER-001 (CL:1+ ITER-001)))))
     (CL:IF (CL:NOT (CL:EQ JUSTIFICATIONS NULL)) JUSTIFICATIONS
      (LIST (%QUERY-SOLUTION.JUSTIFICATION SOLUTION)))))))

;;; (DEFUN (DERIVE-QUERY-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ...)

(CL:DEFUN DERIVE-QUERY-JUSTIFICATIONS (QUERY OPTIONS SOLUTIONINDEX MAXJUSTIFICATIONS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM SOLUTIONINDEX MAXJUSTIFICATIONS))
  #+MCL
  (CL:CHECK-TYPE SOLUTIONINDEX CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE MAXJUSTIFICATIONS CL:FIXNUM)
  (CL:LET*
   ((*QUERYITERATOR* QUERY)
    (*CONTEXT* (%QUERY-ITERATOR.QUERY-CONTEXT QUERY))
    (*INFERENCELEVEL* (CURRENT-INFERENCE-LEVEL))
    (*REVERSEPOLARITY?* CL:NIL) (*GENERATE-ALL-PROOFS?* CL:NIL)
    (*RECORD-JUSTIFICATIONS?* CL:T))
   (CL:DECLARE
    (CL:SPECIAL *QUERYITERATOR* *CONTEXT* *INFERENCELEVEL*
     *REVERSEPOLARITY?* *GENERATE-ALL-PROOFS?*
     *RECORD-JUSTIFICATIONS?*))
   (CL:LET*
    ((ASKQUERY (ALLOCATE-QUERY-ITERATOR))
     (QUERYOPTIONS (%QUERY-ITERATOR.OPTIONS QUERY)))
    (CL:WHEN (CL:EQ OPTIONS NULL)
     (CL:SETQ QUERYOPTIONS (COPY QUERYOPTIONS))
     (REMOVE-AT QUERYOPTIONS KWD-JUSTIFICATIONS-HOW-MANY)
     (CL:SETQ OPTIONS QUERYOPTIONS))
    (PROCESS-QUERY-OPTIONS ASKQUERY OPTIONS)
    (CL:LET* ((*TYPE-CHECK-STRATEGY* KWD-JUSTIFICATIONS-NONE))
     (CL:DECLARE (CL:SPECIAL *TYPE-CHECK-STRATEGY*))
     (INITIALIZE-QUERY-ITERATOR ASKQUERY (QUERY-DESCRIPTION QUERY)
      (%QUERY-SOLUTION.BINDINGS
       (NTH (%QUERY-ITERATOR.SOLUTIONS QUERY) SOLUTIONINDEX))))
    (CL:IF (QUERY-IS-PARTIAL? QUERY) (CALL-ASK-PARTIAL ASKQUERY)
     (CALL-ASK ASKQUERY))
    (GET-QUERY-JUSTIFICATIONS ASKQUERY NULL-INTEGER MAXJUSTIFICATIONS
     CL:NIL))))

(CL:DEFUN NEW-FORWARD-GOAL-RECORD ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-FORWARD-GOAL-RECORD))
   (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF) NULL)
   (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FORWARD-GOAL-RECORD))
  SGT-JUSTIFICATIONS-LOGIC-FORWARD-GOAL-RECORD)

(CL:DEFUN ACCESS-FORWARD-GOAL-RECORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-FORWARD-GOAL)
    (CL:IF SETVALUE?
     (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-FORWARD-RULE)
    (CL:IF SETVALUE?
     (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD FORWARD-CHAINING-GOALS ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
      SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

;;; (DEFMETHOD (DELETED? BOOLEAN) ...)

(CL:DEFMETHOD DELETED? ((SELF FORWARD-GOAL-RECORD))
  (CL:LET*
   ((GOAL (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF))
    (RULE (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF)))
   (CL:OR (CL:EQ GOAL NULL) (CL:EQ RULE NULL)
    (DELETED-PROPOSITION? GOAL) (DELETED-PROPOSITION? RULE))))

;;; (DEFMETHOD (DELETED?-SETTER BOOLEAN) ...)

(CL:DEFMETHOD DELETED?-SETTER ((SELF FORWARD-GOAL-RECORD) VALUE)
  (CL:WHEN VALUE
   (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF) NULL)
   (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF) NULL))
  VALUE)

;;; (DEFUN RECORD-FORWARD-GOAL ...)

(CL:DEFUN RECORD-FORWARD-GOAL (FORWARDRULE ARGUMENTS CONSEQUENTPROPOSITION)
  (CL:LET*
   ((FWDGOALREC NULL)
    (ITER-000
     (%LIST.THE-CONS-LIST
      (FORWARD-CHAINING-GOALS CONSEQUENTPROPOSITION))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ FWDGOALREC (%%VALUE ITER-000))
    (CL:WHEN (CL:NOT (DELETED? FWDGOALREC))
     (CL:LET*
      ((FWDGOAL (%FORWARD-GOAL-RECORD.FORWARD-GOAL FWDGOALREC)))
      (CL:LET* ((TEST-VALUE-000 CL:NIL))
       (CL:SETQ TEST-VALUE-000
        (CL:EQ (%FORWARD-GOAL-RECORD.FORWARD-RULE FWDGOALREC)
         FORWARDRULE))
       (CL:WHEN TEST-VALUE-000
        (CL:LET* ((ALWAYS?-000 CL:T))
         (CL:LET*
          ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
           (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER)
           (ITER-001 1))
          (CL:DECLARE
           (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-001))
          (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
           (CL:SETQ ARG
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
             INDEX-000))
           (CL:SETQ I ITER-001)
           (CL:WHEN
            (CL:NOT
             (EQL?
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FWDGOAL)))
               I)
              ARG))
            (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
           (CL:SETQ ITER-001 (CL:1+ ITER-001))))
         (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
       (CL:WHEN TEST-VALUE-000 (CL:RETURN-FROM RECORD-FORWARD-GOAL)))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:WHEN
   (ELABORATION-RULE? CONSEQUENTPROPOSITION FORWARDRULE ARGUMENTS)
   (CL:RETURN-FROM RECORD-FORWARD-GOAL))
  (CL:LET*
   ((FORWARDGOAL
     (CREATE-PROPOSITION SYM-JUSTIFICATIONS-STELLA-PREDICATE
      (CL:1+ (LENGTH ARGUMENTS)))))
   (CL:LET* ((SELF-000 (NEW-FORWARD-GOAL-RECORD)))
    (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF-000) FORWARDGOAL)
    (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF-000) FORWARDRULE)
    (CL:LET* ((FWDGOALREC SELF-000))
     (CL:SETF (%PROPOSITION.OPERATOR FORWARDGOAL)
      SGT-JUSTIFICATIONS-PL-KERNEL-KB-HOLDS)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORWARDGOAL)))
       (VALUE
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORWARDRULE)))
         0))
       (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET*
      ((ARG NULL) (VECTOR-001 ARGUMENTS) (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)) (I NULL-INTEGER) (ITER-002 1))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 I ITER-002))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:SETQ ARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:SETQ I ITER-002)
       (CL:LET
        ((SELF
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORWARDGOAL)))
         (VALUE ARG) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
       (CL:SETQ ITER-002 (CL:1+ ITER-002))))
     (CL:IF (EMPTY? (FORWARD-CHAINING-GOALS CONSEQUENTPROPOSITION))
      (SET-DYNAMIC-SLOT-VALUE
       (%PROPOSITION.DYNAMIC-SLOTS CONSEQUENTPROPOSITION)
       SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS
       (LIST FWDGOALREC) NULL)
      (INSERT-NEW (FORWARD-CHAINING-GOALS CONSEQUENTPROPOSITION)
       FWDGOALREC))))))

;;; (DEFUN (PREDICATION? BOOLEAN) ...)

(CL:DEFUN PREDICATION? (PROPOSITION)
  (MEMBER?
   (GET-QUOTED-TREE
    "((:PREDICATE :FUNCTION :ISA :EQUIVALENT) \"/LOGIC\")" "/LOGIC")
   (%PROPOSITION.KIND PROPOSITION)))

;;; (DEFUN (ASSERTED-AS-TRUE? BOOLEAN) ...)

(CL:DEFUN ASSERTED-AS-TRUE? (PROPOSITION)
  (CL:LET*
   ((*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:AND (CL:NOT (DELETED? PROPOSITION))
    (CL:IF *REVERSEPOLARITY?* (FALSE? PROPOSITION)
     (CL:OR (TRUE? PROPOSITION)
      (FUNCTION-WITH-DEFINED-VALUE? PROPOSITION))))))

;;; (DEFUN (ELABORATION-RULE? BOOLEAN) ...)

(CL:DEFUN ELABORATION-RULE? (CONSEQUENTPROPOSITION FORWARDRULE ARGUMENTS)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000 (PREDICATION? CONSEQUENTPROPOSITION))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000 (ASSERTED-AS-TRUE? FORWARDRULE))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((ALWAYS?-000 CL:T))
      (CL:LET*
       ((ARG NULL)
        (VECTOR-000 (%PROPOSITION.ARGUMENTS CONSEQUENTPROPOSITION))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:WHEN (CL:NOT (MEMBER? ARGUMENTS ARG))
         (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:SETQ TEST-VALUE-000 ALWAYS?-000))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (GET-FORWARD-GOALS (LIST OF FORWARD-GOAL-RECORD)) ...)

(CL:DEFUN GET-FORWARD-GOALS (PROPOSITION)
  (CL:LET*
   ((GOALS
     (REMOVE-DELETED-MEMBERS (FORWARD-CHAINING-GOALS PROPOSITION))))
   (CL:WHEN
    (CL:AND (EMPTY? GOALS)
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
        SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL)
       NULL)))
    (CL:SETQ GOALS
     (REMOVE-DELETED-MEMBERS
      (FORWARD-CHAINING-GOALS
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
        SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL)))))
   GOALS))

(CL:DEFUN NEW-FORWARD-JUSTIFICATION ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-FORWARD-JUSTIFICATION))
   (CL:SETF (%FORWARD-JUSTIFICATION.ANTECEDENTS SELF) NULL)
   (CL:SETF (%FORWARD-JUSTIFICATION.FORWARD-RULE SELF) NULL)
   (CL:SETF (%FORWARD-JUSTIFICATION.CONSEQUENT SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FORWARD-JUSTIFICATION))
  SGT-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATION)

(CL:DEFUN ACCESS-FORWARD-JUSTIFICATION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-CONSEQUENT)
    (CL:IF SETVALUE?
     (CL:SETF (%FORWARD-JUSTIFICATION.CONSEQUENT SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-JUSTIFICATION.CONSEQUENT SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-FORWARD-RULE)
    (CL:IF SETVALUE?
     (CL:SETF (%FORWARD-JUSTIFICATION.FORWARD-RULE SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-JUSTIFICATION.FORWARD-RULE SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS)
    (CL:IF SETVALUE?
     (CL:SETF (%FORWARD-JUSTIFICATION.ANTECEDENTS SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-JUSTIFICATION.ANTECEDENTS SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD FORWARD-JUSTIFICATIONS ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
      SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

;;; (DEFUN (CREATE-FORWARD-JUSTIFICATION FORWARD-JUSTIFICATION) ...)

(CL:DEFUN CREATE-FORWARD-JUSTIFICATION (CONSEQUENTPROPOSITION FORWARDRULE ANTECEDENTS)
  (CL:LET* ((FJ (NEW-FORWARD-JUSTIFICATION)))
   (CL:SETF (%FORWARD-JUSTIFICATION.CONSEQUENT FJ)
    CONSEQUENTPROPOSITION)
   (CL:SETF (%FORWARD-JUSTIFICATION.FORWARD-RULE FJ) FORWARDRULE)
   (CL:SETF (%FORWARD-JUSTIFICATION.ANTECEDENTS FJ) ANTECEDENTS) FJ))

;;; (DEFUN RECORD-FORWARD-JUSTIFICATION ...)

(CL:DEFUN RECORD-FORWARD-JUSTIFICATION (CONSEQUENTPROPOSITION FORWARDRULE ANTECEDENTS)
  (CL:WHEN (CL:NOT *RECORD-JUSTIFICATIONS?*)
   (CL:RETURN-FROM RECORD-FORWARD-JUSTIFICATION))
  (CL:LET*
   ((JUSTIFICATIONS (FORWARD-JUSTIFICATIONS CONSEQUENTPROPOSITION)))
   (CL:LET* ((FJ NULL) (ITER-000 (%LIST.THE-CONS-LIST JUSTIFICATIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ FJ (%%VALUE ITER-000))
     (CL:WHEN
      (CL:EQ (%FORWARD-JUSTIFICATION.FORWARD-RULE FJ) FORWARDRULE)
      (CL:SETF (%FORWARD-JUSTIFICATION.ANTECEDENTS FJ) ANTECEDENTS)
      (CL:RETURN-FROM RECORD-FORWARD-JUSTIFICATION))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:EQ JUSTIFICATIONS NIL-LIST)
    (CL:SETQ JUSTIFICATIONS (LIST))
    (SET-DYNAMIC-SLOT-VALUE
     (%PROPOSITION.DYNAMIC-SLOTS CONSEQUENTPROPOSITION)
     SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS JUSTIFICATIONS
     NULL))
   (CL:SETQ ANTECEDENTS (CONS FORWARDRULE ANTECEDENTS))
   (PUSH JUSTIFICATIONS
    (CREATE-FORWARD-JUSTIFICATION CONSEQUENTPROPOSITION FORWARDRULE
     ANTECEDENTS))))

(CL:DEFUN HELP-STARTUP-JUSTIFICATIONS1 ()
  (CL:PROGN
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATION" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-RULE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-PATTERN-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-JUSTIFICATION" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-SUBSTITUTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSTITUTION" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-REVERSE-POLARITY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REVERSE-POLARITY?" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-POSITIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITIVE-SCORE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-NEGATIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEGATIVE-SCORE" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMITIVE-STRATEGY" NULL 2))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMITIVE-STRATEGY" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRATEGY" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-PATTERN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN" NULL 2))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATION" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-UP-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TRUE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-UP-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-FAIL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-FAILURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILURE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SCAN-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-COLLECTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-TECHNICAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TECHNICAL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-PROPOSITIONS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP-ASSERTIONS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-LAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LAY" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SPECIALIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIALIST" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-COMPUTED-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPUTED-PREDICATE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-GOAL-COMPLEMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-COMPLEMENT" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-EQUIVALENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENCE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SUBSUMPTION-TEST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-TEST" NULL 2))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-PATTERN-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-RECORD" NULL 1))
   (CL:SETQ SGT-JUSTIFICATIONS-STELLA-KEY-VALUE-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-VALUE-LIST"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-JUSTIFICATIONS-MODUS-TOLLENS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODUS-TOLLENS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-MODUS-PONENS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODUS-PONENS" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS-RULE" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-AMPLIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AMPLIFICATION" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-JUSTIFICATIONS-POPPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POPPED" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-AND-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-PARTIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-REVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REVERSE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-OR-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-DISPROOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISPROOF" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-FAIL-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED-NOT-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTENTIAL-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-TIMEOUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMEOUT" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-DEPTH-CUTOFF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPTH-CUTOFF" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-RAW
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RAW" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-INFERENCE-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-RULE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRATEGY" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-POSITIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITIVE-SCORE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SUBSTITUTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSTITUTION" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-JUSTIFICATIONS-HOW-MANY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOW-MANY" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-NONE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NONE" NULL 2))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-FORWARD-GOAL-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-GOAL-RECORD" NULL 1))))

(CL:DEFUN HELP-STARTUP-JUSTIFICATIONS2 ()
  (CL:PROGN
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-GOAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-GOAL" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-RULE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-CHAINING-GOALS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-JUSTIFICATIONS-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-JUSTIFICATION" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-CONSEQUENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSEQUENT" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-JUSTIFICATIONS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-STARTUP-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-JUSTIFICATIONS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN STARTUP-JUSTIFICATIONS ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-JUSTIFICATIONS1) (HELP-STARTUP-JUSTIFICATIONS2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "JUSTIFICATION"
        "(DEFCLASS JUSTIFICATION (STANDARD-OBJECT) :SLOTS ((INFERENCE-RULE :TYPE KEYWORD :DOCUMENTATION \"Keyword describing the inference rule used to conclude the
proposition of this justification.\") (PROPOSITION :TYPE PROPOSITION :DOCUMENTATION \"The proposition supported by this justification.\") (ANTECEDENTS :TYPE (CONS OF JUSTIFICATION) :INITIALLY NIL :DOCUMENTATION \"Antecedents justifications of this justification.\") (PATTERN-JUSTIFICATION :TYPE JUSTIFICATION :DOCUMENTATION \"Backpointer to the closest parent :PATTERN justification containing
the variable substitutions from the associated pattern control frame.  If this
is a :PATTERN justification, the slot points to the parent pattern.\") (SUBSTITUTION :TYPE (ENTITY-MAPPING OF PATTERN-VARIABLE OBJECT) :DOCUMENTATION \"List of variable bindings recorded for :PATTERN justifications.\") (REVERSE-POLARITY? :TYPE BOOLEAN :DOCUMENTATION \"True if proposition was derived in reverse polarity.\") (TRUTH-VALUE :TYPE TRUTH-VALUE :DOCUMENTATION \"Truth value of the derived proposition.\") (POSITIVE-SCORE :TYPE PARTIAL-MATCH-SCORE :DOCUMENTATION \"Positive partial match score of the derived proposition.\") (NEGATIVE-SCORE :TYPE PARTIAL-MATCH-SCORE :DOCUMENTATION \"Negative partial match score of the derived proposition.\")) :METHODS ((INFERENCE-STRATEGY ((SELF JUSTIFICATION)) :TYPE KEYWORD (RETURN NULL))))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-JUSTIFICATION))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-JUSTIFICATION-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PRIMITIVE-STRATEGY"
        "(DEFCLASS PRIMITIVE-STRATEGY (JUSTIFICATION) :SLOTS ((INFERENCE-RULE :TYPE KEYWORD :INITIALLY :PRIMITIVE-STRATEGY) (STRATEGY :TYPE KEYWORD)) :METHODS ((INFERENCE-STRATEGY ((SELF PRIMITIVE-STRATEGY)) :TYPE KEYWORD (RETURN (STRATEGY SELF)))))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-PRIMITIVE-STRATEGY))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-PRIMITIVE-STRATEGY-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FORWARD-GOAL-RECORD"
        "(DEFCLASS FORWARD-GOAL-RECORD (STANDARD-OBJECT) :SLOTS ((FORWARD-GOAL :TYPE PROPOSITION) (FORWARD-RULE :TYPE PROPOSITION)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-FORWARD-GOAL-RECORD))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-FORWARD-GOAL-RECORD-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FORWARD-JUSTIFICATION"
        "(DEFCLASS FORWARD-JUSTIFICATION (STANDARD-OBJECT) :DOCUMENTATION \"Connects a proposition to other propositions
that collectively implied its truth.\" :SLOTS ((CONSEQUENT :TYPE PROPOSITION) (FORWARD-RULE :TYPE PROPOSITION) (ANTECEDENTS :TYPE (CONS OF PROPOSITION))))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-FORWARD-JUSTIFICATION))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-FORWARD-JUSTIFICATION-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "JUSTIFICATION-ARGUMENT-BOUND-TO"
     "(DEFUN (JUSTIFICATION-ARGUMENT-BOUND-TO OBJECT) ((ARGUMENT OBJECT) (JUSTIFICATION JUSTIFICATION)))"
     (CL:FUNCTION JUSTIFICATION-ARGUMENT-BOUND-TO) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-JUSTIFICATION-SUBSTITUTION"
     "(DEFUN (YIELD-JUSTIFICATION-SUBSTITUTION ENTITY-MAPPING) ((JUSTIFICATION JUSTIFICATION) (SUBSTITUTION ENTITY-MAPPING) (ARGUMENT PROPOSITION)))"
     (CL:FUNCTION YIELD-JUSTIFICATION-SUBSTITUTION) NULL)
    (DEFINE-FUNCTION-OBJECT "JUSTIFICATION-EQL?"
     "(DEFUN (JUSTIFICATION-EQL? BOOLEAN) ((JUST1 JUSTIFICATION) (JUST2 JUSTIFICATION)))"
     (CL:FUNCTION JUSTIFICATION-EQL?) NULL)
    (DEFINE-FUNCTION-OBJECT "JUSTIFICATION-PROPOSITIONS-EQL?"
     "(DEFUN (JUSTIFICATION-PROPOSITIONS-EQL? BOOLEAN) ((PROPOSITION1 PROPOSITION) (JUST1 JUSTIFICATION) (PROPOSITION2 PROPOSITION) (JUST2 JUSTIFICATION)))"
     (CL:FUNCTION JUSTIFICATION-PROPOSITIONS-EQL?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (COPY (LIKE SELF)) ((SELF JUSTIFICATION)) :DOCUMENTATION \"Return a copy of the proof starting at `self'.  Allocates
all new justification objects, but structure-shares other information such
as propositions and substitutions.\" :PUBLIC? TRUE)" (CL:FUNCTION COPY)
     NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-JUSTIFICATIONS?"
     "(DEFUN (RECORD-JUSTIFICATIONS? BOOLEAN) () :DOCUMENTATION \"Return TRUE if every query records justifications to enable
the explanation of concluded results.\" :GLOBALLY-INLINE? TRUE (RETURN *RECORD-JUSTIFICATIONS?*))"
     (CL:FUNCTION RECORD-JUSTIFICATIONS?) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-GOAL-JUSTIFICATION"
     "(DEFUN RECORD-GOAL-JUSTIFICATION ((GOAL CONTROL-FRAME) (JUSTIFICATION JUSTIFICATION)))"
     (CL:FUNCTION RECORD-GOAL-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-PRIMITIVE-JUSTIFICATION"
     "(DEFUN RECORD-PRIMITIVE-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-PRIMITIVE-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-PATTERN-JUSTIFICATION"
     "(DEFUN RECORD-PATTERN-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-PATTERN-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "BACKLINK-TO-PATTERN-JUSTIFICATION"
     "(DEFUN BACKLINK-TO-PATTERN-JUSTIFICATION ((JUSTIFICATION JUSTIFICATION) (PATTERN JUSTIFICATION)))"
     (CL:FUNCTION BACKLINK-TO-PATTERN-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-MODUS-PONENS-JUSTIFICATION"
     "(DEFUN RECORD-MODUS-PONENS-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-MODUS-PONENS-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-AND-INTRODUCTION-JUSTIFICATION"
     "(DEFUN RECORD-AND-INTRODUCTION-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-AND-INTRODUCTION-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-OR-INTRODUCTION-JUSTIFICATION"
     "(DEFUN RECORD-OR-INTRODUCTION-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-OR-INTRODUCTION-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-DISPROOF-JUSTIFICATION"
     "(DEFUN RECORD-DISPROOF-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-DISPROOF-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-FAIL-JUSTIFICATION"
     "(DEFUN RECORD-FAIL-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-FAIL-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-CLOSED-NOT-JUSTIFICATION"
     "(DEFUN RECORD-CLOSED-NOT-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-CLOSED-NOT-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT
     "RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION"
     "(DEFUN RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "FAILED-GOAL-JUSTIFICATION?"
     "(DEFUN (FAILED-GOAL-JUSTIFICATION? BOOLEAN) ((SELF JUSTIFICATION)))"
     (CL:FUNCTION FAILED-GOAL-JUSTIFICATION?) NULL)
    (DEFINE-FUNCTION-OBJECT "CUTOFF-GOAL-JUSTIFICATION?"
     "(DEFUN (CUTOFF-GOAL-JUSTIFICATION? BOOLEAN) ((SELF JUSTIFICATION)))"
     (CL:FUNCTION CUTOFF-GOAL-JUSTIFICATION?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (CONSIFY CONS) ((SELF JUSTIFICATION)) :DOCUMENTATION \"Return a CONS tree representation of the proof `self'.
Each proof step is represented as a CONS tree of the form
  (<proposition> (<key> <value>...) <antecedent>...)
where each <antecedent> is a CONS tree representing a subproof.  The
consification follows the original proof structure literally, i.e., no
uninteresting nodes such as patterns or AND-introductions are suppressed.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CONSIFY) NULL)
    (DEFINE-FUNCTION-OBJECT "CONSIFY-JUSTIFICATION"
     "(DEFUN (CONSIFY-JUSTIFICATION CONS) ((SELF JUSTIFICATION) (STYLE KEYWORD)) :DOCUMENTATION \"Return a CONS tree representation of the proof `self'.
Each proof step is represented as a CONS tree of the form
  (<proposition> (<key> <value>...) <antecedent>...)
where each <antecedent> is a CONS tree representing a subproof.
`style' indicates what nodes in the proof tree should be suppressed.
:RAW preserves the original structure literally, :VERBOSE keeps AND-
introductions but suppresses all auxiliary (non-logical) nodes such as
pattern nodes, and :BRIEF additionally suppresses AND-introduction nodes.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CONSIFY-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-QUERY-JUSTIFICATIONS"
     "(DEFUN (GET-QUERY-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ((QUERY QUERY-ITERATOR) (SOLUTIONINDEX INTEGER) (MAXJUSTIFICATIONS INTEGER) (CREATE? BOOLEAN)))"
     (CL:FUNCTION GET-QUERY-JUSTIFICATIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "DERIVE-QUERY-JUSTIFICATIONS"
     "(DEFUN (DERIVE-QUERY-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ((QUERY QUERY-ITERATOR) (OPTIONS OBJECT) (SOLUTIONINDEX INTEGER) (MAXJUSTIFICATIONS INTEGER)))"
     (CL:FUNCTION DERIVE-QUERY-JUSTIFICATIONS) NULL)
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT PROPOSITION FORWARD-CHAINING-GOALS :TYPE (LIST OF FORWARD-GOAL-RECORD) :ALLOCATION :DYNAMIC)")
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (DELETED? BOOLEAN) ((SELF FORWARD-GOAL-RECORD)))"
     (CL:FUNCTION DELETED?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (DELETED?-SETTER BOOLEAN) ((SELF FORWARD-GOAL-RECORD) (VALUE BOOLEAN)))"
     (CL:FUNCTION DELETED?-SETTER) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-FORWARD-GOAL"
     "(DEFUN RECORD-FORWARD-GOAL ((FORWARDRULE PROPOSITION) (ARGUMENTS ARGUMENTS-VECTOR) (CONSEQUENTPROPOSITION PROPOSITION)))"
     (CL:FUNCTION RECORD-FORWARD-GOAL) NULL)
    (DEFINE-FUNCTION-OBJECT "PREDICATION?"
     "(DEFUN (PREDICATION? BOOLEAN) ((PROPOSITION PROPOSITION)))"
     (CL:FUNCTION PREDICATION?) NULL)
    (DEFINE-FUNCTION-OBJECT "ASSERTED-AS-TRUE?"
     "(DEFUN (ASSERTED-AS-TRUE? BOOLEAN) ((PROPOSITION PROPOSITION)))"
     (CL:FUNCTION ASSERTED-AS-TRUE?) NULL)
    (DEFINE-FUNCTION-OBJECT "ELABORATION-RULE?"
     "(DEFUN (ELABORATION-RULE? BOOLEAN) ((CONSEQUENTPROPOSITION PROPOSITION) (FORWARDRULE PROPOSITION) (ARGUMENTS ARGUMENTS-VECTOR)))"
     (CL:FUNCTION ELABORATION-RULE?) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-FORWARD-GOALS"
     "(DEFUN (GET-FORWARD-GOALS (LIST OF FORWARD-GOAL-RECORD)) ((PROPOSITION PROPOSITION)))"
     (CL:FUNCTION GET-FORWARD-GOALS) NULL)
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT PROPOSITION FORWARD-JUSTIFICATIONS :TYPE (LIST OF FORWARD-JUSTIFICATION) :ALLOCATION :DYNAMIC)")
    (DEFINE-FUNCTION-OBJECT "CREATE-FORWARD-JUSTIFICATION"
     "(DEFUN (CREATE-FORWARD-JUSTIFICATION FORWARD-JUSTIFICATION) ((CONSEQUENTPROPOSITION PROPOSITION) (FORWARDRULE PROPOSITION) (ANTECEDENTS (CONS OF PROPOSITION))))"
     (CL:FUNCTION CREATE-FORWARD-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-FORWARD-JUSTIFICATION"
     "(DEFUN RECORD-FORWARD-JUSTIFICATION ((CONSEQUENTPROPOSITION PROPOSITION) (FORWARDRULE PROPOSITION) (ANTECEDENTS (CONS OF PROPOSITION))))"
     (CL:FUNCTION RECORD-FORWARD-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-JUSTIFICATIONS"
     "(DEFUN STARTUP-JUSTIFICATIONS () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-JUSTIFICATIONS) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION
        SYM-JUSTIFICATIONS-LOGIC-STARTUP-JUSTIFICATIONS)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-JUSTIFICATIONS-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupJustifications") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *RECORD-JUSTIFICATIONS?* BOOLEAN FALSE :DOCUMENTATION \"If TRUE every query records justifications to enable
the explanation of concluded results.\")")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SCAN-COLLECTION
     KWD-JUSTIFICATIONS-TECHNICAL "by explicit assertion")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS
     KWD-JUSTIFICATIONS-TECHNICAL "by explicit assertion")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS
     KWD-JUSTIFICATIONS-TECHNICAL "by explicit assertion")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SCAN-COLLECTION
     KWD-JUSTIFICATIONS-LAY "because the system was told this fact")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS
     KWD-JUSTIFICATIONS-LAY "because the system was told this fact")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS
     KWD-JUSTIFICATIONS-LAY "because the system was told this fact")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SPECIALIST
     KWD-JUSTIFICATIONS-TECHNICAL
     "because it was proven by an inference specialist")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SPECIALIST
     KWD-JUSTIFICATIONS-LAY
     "because of a specialized reasoning procedure")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-COMPUTED-PREDICATE
     KWD-JUSTIFICATIONS-TECHNICAL "because of a computation")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-COMPUTED-PREDICATE
     KWD-JUSTIFICATIONS-LAY "because of a computation")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-GOAL-COMPLEMENT
     KWD-JUSTIFICATIONS-TECHNICAL
     "because its argument was proven false")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-GOAL-COMPLEMENT
     KWD-JUSTIFICATIONS-LAY "because its argument is false")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-EQUIVALENCE
     KWD-JUSTIFICATIONS-TECHNICAL "from equivalence")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-EQUIVALENCE
     KWD-JUSTIFICATIONS-LAY "because its arguments are equivalent")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SUBSUMPTION-TEST
     KWD-JUSTIFICATIONS-TECHNICAL
     "because of a successful subsumption test")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SUBSUMPTION-TEST
     KWD-JUSTIFICATIONS-LAY "because of a successful subsumption test")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FAILURE
     KWD-JUSTIFICATIONS-TECHNICAL "could not be proven")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FAILURE
     KWD-JUSTIFICATIONS-LAY "could not be proven")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-PONENS
     KWD-JUSTIFICATIONS-TECHNICAL "by Modus Ponens")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-PONENS
     KWD-JUSTIFICATIONS-LAY "because an if-then rule applies")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-TOLLENS
     KWD-JUSTIFICATIONS-TECHNICAL "by Modus Tollens")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-TOLLENS
     KWD-JUSTIFICATIONS-TECHNICAL "(p => q, ~q |= ~p)"
     KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-TOLLENS
     KWD-JUSTIFICATIONS-LAY
     "because an if-then rule was used backwards")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-TOLLENS
     KWD-JUSTIFICATIONS-LAY
     "(if P then Q with Q false allows us to conclude P)"
     KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL "by And-Introduction")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY
     "because all parts of an AND expression were true")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY
     "because parts of an AND expression were true"
     KWD-JUSTIFICATIONS-PARTIAL)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL "by Not-Or-Introduction"
     KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY
     "because all parts of an OR expression were false"
     KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL "(~p, ~q |= ~(p v q))"
     KWD-JUSTIFICATIONS-REVERSE KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY "(therefore the OR is also false)"
     KWD-JUSTIFICATIONS-REVERSE KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL "by Or-Introduction")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY
     "because at least one part of an OR expression was true")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL "by Not-And-Introduction"
     KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY
     "because at least one part of an AND expression was false"
     KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL "(~p |= ~(p & q))"
     KWD-JUSTIFICATIONS-REVERSE KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY "(therefore the AND is also false)"
     KWD-JUSTIFICATIONS-REVERSE KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-DISPROOF
     KWD-JUSTIFICATIONS-TECHNICAL "by disproof")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-DISPROOF
     KWD-JUSTIFICATIONS-LAY "by proving the negation")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-DISPROOF
     KWD-JUSTIFICATIONS-TECHNICAL "by Double-Negation-Introduction"
     KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-DISPROOF
     KWD-JUSTIFICATIONS-LAY "by negating a negation"
     KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE
     KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL
     "because the argument proposition was not derivable and it uses closed-world semantics")
    (DEFINE-EXPLANATION-PHRASE
     KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION KWD-JUSTIFICATIONS-LAY
     "because the argument proposition could not be proven and it is a closed-world proposition")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FAIL-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL
     "because the argument proposition was not derivable")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FAIL-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY
     "because the argument proposition could not be proven")
    (DEFINE-EXPLANATION-PHRASE
     KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL "by Existential Introduction")
    (DEFINE-EXPLANATION-PHRASE
     KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION KWD-JUSTIFICATIONS-LAY
     "because it was true for at least one case"))))
