;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997-2000              | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-PROPOSITION-SPEC NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-PROPOSITION-RECORD NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-BINDINGS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-TRUTH-VALUE NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-REVERSE-POLARITY? NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-MATCH-SCORE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-STRATEGY NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-UP-TRUE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-ATOMIC-GOAL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FULL-SUBQUERY NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-ANTECEDENTS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-CLUSTERED-CONJUNCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-AND NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-OR NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-NOT NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-PATTERN NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-EXISTS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-UP-TRUE-PRIMITIVE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-UP-FALSE-PRIMITIVE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-UP-FAIL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FAIL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FAILURE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-MODUS-TOLLENS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-MODUS-PONENS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS-RULE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-BACK NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-AND-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-OR-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-DISPROOF NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FAIL-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-UNHANDLED NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-BRIEF NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-EXPLANATION-INFO NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-LABEL NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-DEPTH NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-EXPLAINED? NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-EXPLANATION-MAPPING NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-REALISTIC NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SCAN-COLLECTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-ISA-PROPOSITION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-COMPUTED-PREDICATE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-WHY NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-COMMON-LISP NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FUNCTION NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-DIGIT NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-VERBOSE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-DEPTH NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-GOAL-TREE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-TRACE-SUBGOALS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-JUSTIFICATIONS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-BASIC NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-WHYNOT NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-FORWARD-GOAL-RECORD NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-GOAL NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-RULE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-PREDICATE NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-CONSEQUENT NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-STARTUP-JUSTIFICATIONS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *CONTEXT* *MODULE* NIL-LIST
  *PARTIAL-MATCH-MODE* ONE-WRAPPER *CHARACTER-TYPE-TABLE*
  *MOST-RECENT-QUERY* STANDARD-OUTPUT *INDENTCOUNTER* EOL
  FALSE-TRUTH-VALUE TRUE-TRUTH-VALUE *QUERYITERATOR* TRUE-WRAPPER
  FALSE-WRAPPER))

(CL:DEFUN NEW-PROPOSITION-RECORD ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-PROPOSITION-RECORD))
   (CL:SETF (%PROPOSITION-RECORD.TRUTH-VALUE SELF) NULL)
   (CL:SETF (%PROPOSITION-RECORD.BINDINGS SELF) NULL)
   (CL:SETF (%PROPOSITION-RECORD.PROPOSITION SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PROPOSITION-RECORD))
  SGT-JUSTIFICATIONS-LOGIC-PROPOSITION-RECORD)

(CL:DEFUN ACCESS-PROPOSITION-RECORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-PROPOSITION)
    (CL:IF SETVALUE?
     (CL:SETF (%PROPOSITION-RECORD.PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%PROPOSITION-RECORD.PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-BINDINGS)
    (CL:IF SETVALUE? (CL:SETF (%PROPOSITION-RECORD.BINDINGS SELF) VALUE)
     (CL:SETQ VALUE (%PROPOSITION-RECORD.BINDINGS SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-TRUTH-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%PROPOSITION-RECORD.TRUTH-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%PROPOSITION-RECORD.TRUTH-VALUE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFUN NEW-JUSTIFICATION ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-JUSTIFICATION))
   (CL:SETF (%JUSTIFICATION.MATCH-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%JUSTIFICATION.TRUTH-VALUE SELF) NULL)
   (CL:SETF (%JUSTIFICATION.REVERSE-POLARITY? SELF) FALSE)
   (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF) NIL)
   (CL:SETF (%JUSTIFICATION.PROPOSITION SELF) NULL)
   (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF JUSTIFICATION))
  SGT-JUSTIFICATIONS-LOGIC-JUSTIFICATION)

(CL:DEFUN ACCESS-JUSTIFICATION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.INFERENCE-RULE SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.ANTECEDENTS SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-REVERSE-POLARITY?)
    (CL:IF SETVALUE?
     (CL:SETF (%JUSTIFICATION.REVERSE-POLARITY? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%JUSTIFICATION.REVERSE-POLARITY? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-TRUTH-VALUE)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.TRUTH-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.TRUTH-VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-MATCH-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%JUSTIFICATION.MATCH-SCORE SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%JUSTIFICATION.MATCH-SCORE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFUN NEW-PRIMITIVE-STRATEGY ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-PRIMITIVE-STRATEGY))
   (CL:SETF (%PRIMITIVE-STRATEGY.MATCH-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%PRIMITIVE-STRATEGY.TRUTH-VALUE SELF) NULL)
   (CL:SETF (%PRIMITIVE-STRATEGY.REVERSE-POLARITY? SELF) FALSE)
   (CL:SETF (%PRIMITIVE-STRATEGY.ANTECEDENTS SELF) NIL)
   (CL:SETF (%PRIMITIVE-STRATEGY.PROPOSITION SELF) NULL)
   (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF) NULL)
   (CL:SETF (%PRIMITIVE-STRATEGY.INFERENCE-RULE SELF)
    KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PRIMITIVE-STRATEGY))
  SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY)

(CL:DEFUN ACCESS-PRIMITIVE-STRATEGY-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE)
    (CL:IF SETVALUE?
     (CL:SETF (%PRIMITIVE-STRATEGY.INFERENCE-RULE SELF) VALUE)
     (CL:SETQ VALUE (%PRIMITIVE-STRATEGY.INFERENCE-RULE SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-STRATEGY)
    (CL:IF SETVALUE? (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF) VALUE)
     (CL:SETQ VALUE (%PRIMITIVE-STRATEGY.STRATEGY SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (GET-JUSTIFICATION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN GET-JUSTIFICATION-PROPOSITION (SELF)
  (CL:LET* ((PROPSPEC (%JUSTIFICATION.PROPOSITION SELF)))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE PROPSPEC)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-JUSTIFICATIONS-LOGIC-PROPOSITION)
      (CL:PROGN PROPSPEC))
     ((SUBTYPE-OF? TEST-VALUE-000
       SGT-JUSTIFICATIONS-LOGIC-PROPOSITION-RECORD)
      (CL:PROGN (%PROPOSITION-RECORD.PROPOSITION PROPSPEC)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN (GET-JUSTIFICATION-SUBSTITUTION ENTITY-MAPPING) ...)

(CL:DEFUN GET-JUSTIFICATION-SUBSTITUTION (SELF)
  (CL:LET* ((PROPSPEC (%JUSTIFICATION.PROPOSITION SELF)))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE PROPSPEC)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-JUSTIFICATIONS-LOGIC-PROPOSITION)
      (CL:PROGN NULL))
     ((SUBTYPE-OF? TEST-VALUE-000
       SGT-JUSTIFICATIONS-LOGIC-PROPOSITION-RECORD)
      (CL:PROGN (%PROPOSITION-RECORD.BINDINGS PROPSPEC)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN (JUSTIFICATION-EQL? BOOLEAN) ...)

(CL:DEFUN JUSTIFICATION-EQL? (JUST1 JUST2)
  (CL:OR (CL:EQ JUST1 JUST2)
   (CL:AND
    (CL:EQ (%JUSTIFICATION.INFERENCE-RULE JUST1)
     (%JUSTIFICATION.INFERENCE-RULE JUST2))
    (CL:EQ (%JUSTIFICATION.REVERSE-POLARITY? JUST1)
     (%JUSTIFICATION.REVERSE-POLARITY? JUST2))
    (CL:OR
     (CL:AND
      (CL:NOT
       (CL:EQ (%JUSTIFICATION.INFERENCE-RULE JUST1)
        KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY))
      (CL:NOT
       (CL:EQ (%JUSTIFICATION.INFERENCE-RULE JUST2)
        KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY)))
     (CL:EQ (%PRIMITIVE-STRATEGY.STRATEGY JUST1)
      (%PRIMITIVE-STRATEGY.STRATEGY JUST2)))
    (JUSTIFICATION-PROPOSITIONS-EQL? (GET-JUSTIFICATION-PROPOSITION JUST1)
     (GET-JUSTIFICATION-SUBSTITUTION JUST1)
     (GET-JUSTIFICATION-PROPOSITION JUST2)
     (GET-JUSTIFICATION-SUBSTITUTION JUST2)))))

;;; (DEFUN (JUSTIFICATION-PROPOSITIONS-EQL? BOOLEAN) ...)

(CL:DEFUN JUSTIFICATION-PROPOSITIONS-EQL? (PROPOSITION1 BINDINGS1 PROPOSITION2 BINDINGS2)
  (CL:WHEN
   (CL:AND
    (CL:EQ (%PROPOSITION.OPERATOR PROPOSITION1)
     (%PROPOSITION.OPERATOR PROPOSITION2))
    (CL:= (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION1))
     (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION2))))
   (CL:LET*
    ((ARG2 NULL) (ARG1 NULL)
     (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION1)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000))
     (VECTOR-001 (%PROPOSITION.ARGUMENTS PROPOSITION2)) (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
     (CL:PROGN
      (CL:SETQ ARG1
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:PROGN
      (CL:SETQ ARG2
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
        INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:WHEN (CL:NOT (EQL? ARG1 ARG2))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG1)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-JUSTIFICATIONS-LOGIC-PROPOSITION)
         (CL:PROGN
          (CL:WHEN
           (CL:NOT
            (CL:AND (ISA? ARG2 SGT-JUSTIFICATIONS-LOGIC-PROPOSITION)
             (JUSTIFICATION-PROPOSITIONS-EQL? ARG1 BINDINGS1 ARG2
              BINDINGS2)))
           (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? FALSE))))
        ((SUBTYPE-OF? TEST-VALUE-000
          SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
         (CL:PROGN
          (CL:COND
           ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARG2)
             SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
            (CL:PROGN
             (CL:WHEN
              (CL:OR (CL:EQ BINDINGS1 NULL) (CL:EQ BINDINGS2 NULL)
               (CL:EQ (LOOKUP BINDINGS1 ARG1) NULL)
               (CL:EQ (LOOKUP BINDINGS2 ARG2) NULL)
               (CL:NOT
                (EQL? (LOOKUP BINDINGS1 ARG1) (LOOKUP BINDINGS2 ARG2))))
              (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? FALSE))))
           (CL:T
            (CL:WHEN
             (CL:OR (CL:EQ BINDINGS1 NULL)
              (CL:NOT (EQL? (LOOKUP BINDINGS1 ARG1) ARG2)))
             (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? FALSE))))))
        (CL:T
         (CL:COND
          ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARG2)
            SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
           (CL:PROGN
            (CL:WHEN
             (CL:OR (CL:EQ BINDINGS2 NULL)
              (CL:NOT (EQL? ARG1 (LOOKUP BINDINGS2 ARG2))))
             (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? FALSE))))
          (CL:T
           (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? FALSE)))))))))
   (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? TRUE))
  FALSE)

;;; (DEFGLOBAL *RECORD-JUSTIFICATIONS?* ...)

(CL:DEFVAR *RECORD-JUSTIFICATIONS?* FALSE
  "If TRUE every query records justifications to enable
the explanation of concluded results.")

;;; (DEFUN (RECORD-JUSTIFICATIONS? BOOLEAN) ...)

(CL:DEFUN RECORD-JUSTIFICATIONS? ()
  "Return TRUE if every query records justifications to enable
the explanation of concluded results."
  *RECORD-JUSTIFICATIONS?*)

;;; (DEFGLOBAL *MOST-RECENT-FAILED-FRAME* ...)

(CL:DEFVAR *MOST-RECENT-FAILED-FRAME* NULL)

;;; (DEFUN RECORD-JUSTIFICATION ...)

(CL:DEFUN RECORD-JUSTIFICATION (FRAME LASTMOVE)
  (CL:SETQ *MOST-RECENT-FAILED-FRAME* NULL)
  (CL:LET* ((PARENT (%CONTROL-FRAME.UP FRAME)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:LET* ((TEST-VALUE-000 (%CONTROL-FRAME.STATE PARENT)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-ATOMIC-GOAL)
        (CL:LET*
         ((TEST-VALUE-001 (%CONTROL-FRAME.CURRENT-STRATEGY PARENT)))
         (CL:COND
          ((CL:OR (CL:EQ TEST-VALUE-001 KWD-JUSTIFICATIONS-FULL-SUBQUERY)
            (CL:EQ TEST-VALUE-001 KWD-JUSTIFICATIONS-ANTECEDENTS))
           (RECORD-MODUS-PONENS-JUSTIFICATION FRAME))
          ((CL:EQ TEST-VALUE-001 KWD-JUSTIFICATIONS-CLUSTERED-CONJUNCTION)
           (RECORD-AND-INTRODUCTION-JUSTIFICATION FRAME))
          (CL:T))))
       ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-AND)
        (RECORD-AND-INTRODUCTION-JUSTIFICATION FRAME))
       ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-OR)
        (RECORD-OR-INTRODUCTION-JUSTIFICATION FRAME))
       ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-NOT)
        (RECORD-DISPROOF-JUSTIFICATION FRAME))
       ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-PATTERN)
        (CL:SETF (%CONTROL-FRAME.JUSTIFICATION PARENT)
         (%CONTROL-FRAME.JUSTIFICATION FRAME)))
       ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-EXISTS)
        (RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION FRAME))
       (CL:T (RECORD-UNHANDLED-JUSTIFICATION FRAME)))))
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE-PRIMITIVE)
     (RECORD-PRIMITIVE-JUSTIFICATION FRAME))
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FALSE-PRIMITIVE)
     (CL:SETQ *MOST-RECENT-FAILED-FRAME* FRAME)
     (RECORD-PRIMITIVE-JUSTIFICATION FRAME))
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL)
     (CL:SETQ *MOST-RECENT-FAILED-FRAME* FRAME)
     (CL:LET* ((TEST-VALUE-002 (%CONTROL-FRAME.STATE PARENT)))
      (CL:COND
       ((CL:EQ TEST-VALUE-002 KWD-JUSTIFICATIONS-FAIL)
        (RECORD-FAIL-JUSTIFICATION FRAME))
       ((CL:EQ TEST-VALUE-002 KWD-JUSTIFICATIONS-PATTERN)
        (CL:SETF (%CONTROL-FRAME.JUSTIFICATION PARENT)
         (%CONTROL-FRAME.JUSTIFICATION FRAME)))
       (CL:T))))
    (CL:T))))

;;; (DEFUN (CREATE-JUSTIFICATION-PROPOSITION PROPOSITION-SPEC) ...)

(CL:DEFUN CREATE-JUSTIFICATION-PROPOSITION (FRAME)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (MAPPING
     (YIELD-PROPOSITION-RECORD-BINDINGS PROPOSITION PROPOSITION NULL)))
   (CL:IF (CL:EQ MAPPING NULL) PROPOSITION
    (CL:LET* ((SELF-000 (NEW-PROPOSITION-RECORD)))
     (CL:SETF (%PROPOSITION-RECORD.PROPOSITION SELF-000) PROPOSITION)
     (CL:SETF (%PROPOSITION-RECORD.BINDINGS SELF-000) MAPPING)
     (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))))

;;; (DEFUN (YIELD-PROPOSITION-RECORD-BINDINGS ENTITY-MAPPING) ...)

(CL:DEFUN YIELD-PROPOSITION-RECORD-BINDINGS (SELF TOP MAPPING)
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:PROGN
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000
        SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
       (CL:PROGN
        (CL:WHEN (FREE-VARIABLE? ARG TOP)
         (CL:WHEN (CL:EQ MAPPING NULL)
          (CL:SETQ MAPPING (NEW-KEY-VALUE-LIST)))
         (INSERT-AT MAPPING ARG
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY
             (%PATTERN-RECORD.VARIABLE-BINDINGS
              (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
           (CL:THE CL:FIXNUM (%PATTERN-VARIABLE.BOUND-TO-OFFSET ARG)))))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-JUSTIFICATIONS-LOGIC-PROPOSITION)
       (CL:PROGN
        (CL:SETQ MAPPING
         (YIELD-PROPOSITION-RECORD-BINDINGS ARG TOP MAPPING))))
      (CL:T)))))
  MAPPING)

;;; (DEFUN RECORD-GOAL-JUSTIFICATION ...)

(CL:DEFUN RECORD-GOAL-JUSTIFICATION (GOAL INFERENCERULE ANTECEDENTS)
  (CL:LET* ((JUSTIFICATION (%CONTROL-FRAME.JUSTIFICATION GOAL)))
   (CL:WHEN (CL:EQ JUSTIFICATION NULL)
    (CL:SETQ JUSTIFICATION (NEW-JUSTIFICATION)))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE JUSTIFICATION)
      SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY)
     (CL:PROGN
      (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY JUSTIFICATION)
       INFERENCERULE)))
    (CL:T
     (CL:SETF (%JUSTIFICATION.INFERENCE-RULE JUSTIFICATION)
      INFERENCERULE)))
   (CL:SETF (%JUSTIFICATION.PROPOSITION JUSTIFICATION)
    (CREATE-JUSTIFICATION-PROPOSITION GOAL))
   (CL:WHEN (CL:NOT (CL:EQ ANTECEDENTS NULL))
    (CL:SETF (%JUSTIFICATION.ANTECEDENTS JUSTIFICATION) ANTECEDENTS))
   (CL:SETF (%JUSTIFICATION.REVERSE-POLARITY? JUSTIFICATION)
    (%CONTROL-FRAME.REVERSE-POLARITY? GOAL))
   (CL:IF (%CONTROL-FRAME.REVERSE-POLARITY? GOAL)
    (CL:SETF (%JUSTIFICATION.TRUTH-VALUE JUSTIFICATION) FALSE-TRUTH-VALUE)
    (CL:SETF (%JUSTIFICATION.TRUTH-VALUE JUSTIFICATION) TRUE-TRUTH-VALUE))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
     (CL:NOT
      (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
       NULL)))
    (CL:SETF (%JUSTIFICATION.MATCH-SCORE JUSTIFICATION)
     (%QUERY-ITERATOR.LATEST-POSITIVE-SCORE *QUERYITERATOR*)))
   (CL:SETF (%CONTROL-FRAME.JUSTIFICATION GOAL) JUSTIFICATION)))

;;; (DEFUN RECORD-PRIMITIVE-JUSTIFICATION ...)

(CL:DEFUN RECORD-PRIMITIVE-JUSTIFICATION (FRAME)
  (CL:WHEN (CL:EQ (%CONTROL-FRAME.JUSTIFICATION FRAME) NULL)
   (CL:SETF (%CONTROL-FRAME.JUSTIFICATION FRAME) (NEW-PRIMITIVE-STRATEGY))
   (RECORD-GOAL-JUSTIFICATION FRAME
    (CL:IF (CL:NOT (CL:EQ (%CONTROL-FRAME.CURRENT-STRATEGY FRAME) NULL))
     (%CONTROL-FRAME.CURRENT-STRATEGY FRAME) KWD-JUSTIFICATIONS-FAILURE)
    NIL)))

;;; (DEFUN RECORD-MODUS-PONENS-JUSTIFICATION ...)

(CL:DEFUN RECORD-MODUS-PONENS-JUSTIFICATION (FRAME)
  (CL:LET*
   ((PARENT (%CONTROL-FRAME.UP FRAME))
    (OLDJUSTIFICATION (%CONTROL-FRAME.JUSTIFICATION PARENT)))
   (CL:SETF (%CONTROL-FRAME.JUSTIFICATION PARENT) NULL)
   (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY)))
    (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-000)
     KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS)
    (CL:SETF (%PRIMITIVE-STRATEGY.PROPOSITION SELF-000)
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS PARENT)
      SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS-RULE NULL))
    (CL:SETF (%PRIMITIVE-STRATEGY.TRUTH-VALUE SELF-000) TRUE-TRUTH-VALUE)
    (CL:SETF (%PRIMITIVE-STRATEGY.MATCH-SCORE SELF-000) 1.0d0)
    (RECORD-GOAL-JUSTIFICATION PARENT
     (CL:IF (%CONTROL-FRAME.REVERSE-POLARITY? PARENT)
      KWD-JUSTIFICATIONS-MODUS-TOLLENS KWD-JUSTIFICATIONS-MODUS-PONENS)
     (CONS SELF-000 (CONS (%CONTROL-FRAME.JUSTIFICATION FRAME) NIL))))
   (CL:WHEN
    (CL:AND
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT
       (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
        NULL)))
     (CL:NOT (CL:EQ OLDJUSTIFICATION NULL))
     (CL:<=
      (%JUSTIFICATION.MATCH-SCORE (%CONTROL-FRAME.JUSTIFICATION PARENT))
      (%JUSTIFICATION.MATCH-SCORE OLDJUSTIFICATION)))
    (CL:SETF (%CONTROL-FRAME.JUSTIFICATION PARENT) OLDJUSTIFICATION))))

;;; (DEFUN RECORD-AND-INTRODUCTION-JUSTIFICATION ...)

(CL:DEFUN RECORD-AND-INTRODUCTION-JUSTIFICATION (FRAME)
  (CL:LET*
   ((PARENT (%CONTROL-FRAME.UP FRAME)) (JUSTIFICATION NULL)
    (ANTECEDENTS NIL))
   (CL:SETQ JUSTIFICATION (%CONTROL-FRAME.JUSTIFICATION PARENT))
   (CL:WHEN (CL:EQ JUSTIFICATION NULL)
    (CL:IF
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS PARENT)
        SYM-JUSTIFICATIONS-LOGIC-BACK NULL)
       NULL))
     (CL:SETQ JUSTIFICATION
      (%CONTROL-FRAME.JUSTIFICATION
       (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS PARENT)
        SYM-JUSTIFICATIONS-LOGIC-BACK NULL)))
     (CL:SETQ JUSTIFICATION (NEW-JUSTIFICATION))))
   (CL:SETQ ANTECEDENTS (%JUSTIFICATION.ANTECEDENTS JUSTIFICATION))
   (CL:WHEN
    (CL:< (%CONTROL-FRAME.ARGUMENT-CURSOR PARENT) (LENGTH ANTECEDENTS))
    (CL:SETQ ANTECEDENTS
     (NTH-REST ANTECEDENTS
      (CL:- (LENGTH ANTECEDENTS)
       (%CONTROL-FRAME.ARGUMENT-CURSOR PARENT)))))
   (CL:SETQ ANTECEDENTS
    (CONS (%CONTROL-FRAME.JUSTIFICATION FRAME) ANTECEDENTS))
   (CL:SETF (%JUSTIFICATION.ANTECEDENTS JUSTIFICATION) ANTECEDENTS)
   (CL:SETF (%CONTROL-FRAME.JUSTIFICATION PARENT) JUSTIFICATION)
   (CL:WHEN
    (CL:= (%CONTROL-FRAME.ARGUMENT-CURSOR PARENT)
     (CL:1-
      (LENGTH
       (%PROPOSITION.ARGUMENTS (%CONTROL-FRAME.PROPOSITION PARENT)))))
    (RECORD-GOAL-JUSTIFICATION PARENT KWD-JUSTIFICATIONS-AND-INTRODUCTION
     (REVERSE ANTECEDENTS)))))

;;; (DEFUN RECORD-OR-INTRODUCTION-JUSTIFICATION ...)

(CL:DEFUN RECORD-OR-INTRODUCTION-JUSTIFICATION (FRAME)
  (RECORD-GOAL-JUSTIFICATION (%CONTROL-FRAME.UP FRAME)
   KWD-JUSTIFICATIONS-OR-INTRODUCTION
   (CONS (%CONTROL-FRAME.JUSTIFICATION FRAME) NIL)))

;;; (DEFUN RECORD-DISPROOF-JUSTIFICATION ...)

(CL:DEFUN RECORD-DISPROOF-JUSTIFICATION (FRAME)
  (RECORD-GOAL-JUSTIFICATION (%CONTROL-FRAME.UP FRAME)
   KWD-JUSTIFICATIONS-DISPROOF
   (CONS (%CONTROL-FRAME.JUSTIFICATION FRAME) NIL)))

;;; (DEFUN RECORD-FAIL-JUSTIFICATION ...)

(CL:DEFUN RECORD-FAIL-JUSTIFICATION (FRAME)
  (RECORD-GOAL-JUSTIFICATION (%CONTROL-FRAME.UP FRAME)
   KWD-JUSTIFICATIONS-FAIL-INTRODUCTION NIL))

;;; (DEFUN RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION ...)

(CL:DEFUN RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION (FRAME)
  (RECORD-GOAL-JUSTIFICATION (%CONTROL-FRAME.UP FRAME)
   KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION
   (CL:IF (CL:NOT (CL:EQ (%CONTROL-FRAME.JUSTIFICATION FRAME) NULL))
    (CONS (%CONTROL-FRAME.JUSTIFICATION FRAME) NIL) NIL)))

;;; (DEFUN RECORD-UNHANDLED-JUSTIFICATION ...)

(CL:DEFUN RECORD-UNHANDLED-JUSTIFICATION (FRAME)
  (RECORD-GOAL-JUSTIFICATION (%CONTROL-FRAME.UP FRAME)
   KWD-JUSTIFICATIONS-UNHANDLED
   (CL:IF (CL:NOT (CL:EQ (%CONTROL-FRAME.JUSTIFICATION FRAME) NULL))
    (CONS (%CONTROL-FRAME.JUSTIFICATION FRAME) NIL) NIL)))

;;; (DEFUN RECORD-FAILURE-JUSTIFICATION ...)

(CL:DEFUN RECORD-FAILURE-JUSTIFICATION (FRAME LASTMOVE)
  (CL:SETQ FRAME FRAME)
  (CL:WHEN
   (CL:AND *RECORD-JUSTIFICATIONS?*
    (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
     (CL:NOT
      (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
       NULL)))
    (CL:NOT (CL:EQ *MOST-RECENT-FAILED-FRAME* NULL)))
   (CL:COND (CL:T)) (CL:SETQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
   (RECORD-JUSTIFICATION *MOST-RECENT-FAILED-FRAME* LASTMOVE)))

;;; (DEFUN RECORD-PRIMITIVE-FAILURE-JUSTIFICATION ...)

(CL:DEFUN RECORD-PRIMITIVE-FAILURE-JUSTIFICATION (FRAME)
  (CL:WHEN (CL:EQ (%CONTROL-FRAME.JUSTIFICATION FRAME) NULL)
   (CL:SETF (%CONTROL-FRAME.JUSTIFICATION FRAME) (NEW-PRIMITIVE-STRATEGY))
   (RECORD-GOAL-JUSTIFICATION FRAME KWD-JUSTIFICATIONS-FAILURE NIL)))

;;; (DEFUN (FAILED-GOAL-JUSTIFICATION? BOOLEAN) ...)

(CL:DEFUN FAILED-GOAL-JUSTIFICATION? (SELF)
  (CL:COND
   ((CL:EQ (%JUSTIFICATION.INFERENCE-RULE SELF)
     KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY)
    (CL:COND
     ((CL:EQ (%PRIMITIVE-STRATEGY.STRATEGY SELF)
       KWD-JUSTIFICATIONS-FAILURE)
      (CL:RETURN-FROM FAILED-GOAL-JUSTIFICATION? TRUE))
     (CL:T)))
   (CL:T))
  FALSE)

;;; (DEFUN COLLECT-FAILED-GOALS ...)

(CL:DEFUN COLLECT-FAILED-GOALS (PROOF FAILURES)
  (CL:IF (FAILED-GOAL-JUSTIFICATION? PROOF) (INSERT-NEW FAILURES PROOF)
   (CL:LET*
    ((ANTECEDENT NULL) (ITER-000 (%JUSTIFICATION.ANTECEDENTS PROOF)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ ANTECEDENT (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (COLLECT-FAILED-GOALS ANTECEDENT FAILURES)))))

;;; (DEFGLOBAL *EXPLANATION-STYLE* ...)

(CL:DEFVAR *EXPLANATION-STYLE* NULL
  "Keywords that controls how detailed explanations will be.
Valid values are :VERBOSE and :BRIEF.")

;;; (DEFGLOBAL *DEFAULT-EXPLANATION-DEPTH* ...)

(CL:PROGN (CL:DEFVAR *DEFAULT-EXPLANATION-DEPTH* 3 "Maximal explanation depth used if not otherwise specified.") (CL:DECLAIM (CL:TYPE CL:FIXNUM *DEFAULT-EXPLANATION-DEPTH*)))

;;; (DEFGLOBAL *EXPLANATION-TAB-STRING* ...)

(CL:PROGN (CL:DEFVAR *EXPLANATION-TAB-STRING* "    ") (CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *EXPLANATION-TAB-STRING*)))

;;; (DEFGLOBAL *MAX-INLINE-LABEL-LENGTH* ...)

(CL:PROGN (CL:DEFVAR *MAX-INLINE-LABEL-LENGTH* 10 "Maximum length of a label string for which the following
proposition will be printed on the same line.") (CL:DECLAIM (CL:TYPE CL:FIXNUM *MAX-INLINE-LABEL-LENGTH*)))

;;; (DEFGLOBAL *EXPLANATION-ASSERTION-MARKER* ...)

(CL:PROGN (CL:DEFVAR *EXPLANATION-ASSERTION-MARKER* "!") (CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *EXPLANATION-ASSERTION-MARKER*)))

;;; (DEFGLOBAL *EXPLANATION-FAILURE-MARKER* ...)

(CL:PROGN (CL:DEFVAR *EXPLANATION-FAILURE-MARKER* "?") (CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *EXPLANATION-FAILURE-MARKER*)))

(CL:DEFUN NEW-EXPLANATION-INFO ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-EXPLANATION-INFO))
   (CL:SETF (%EXPLANATION-INFO.EXPLAINED? SELF) FALSE)
   (CL:SETF (%EXPLANATION-INFO.DEPTH SELF) NULL-INTEGER)
   (CL:SETF (%EXPLANATION-INFO.LABEL SELF) STELLA::NULL-STRING) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF EXPLANATION-INFO))
  SGT-JUSTIFICATIONS-LOGIC-EXPLANATION-INFO)

(CL:DEFUN ACCESS-EXPLANATION-INFO-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-STELLA-LABEL)
    (CL:IF SETVALUE?
     (CL:SETF (%EXPLANATION-INFO.LABEL SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%EXPLANATION-INFO.LABEL SELF)))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-DEPTH)
    (CL:IF SETVALUE?
     (CL:SETF (%EXPLANATION-INFO.DEPTH SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%EXPLANATION-INFO.DEPTH SELF)))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-EXPLAINED?)
    (CL:IF SETVALUE?
     (CL:SETF (%EXPLANATION-INFO.EXPLAINED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%EXPLANATION-INFO.EXPLAINED? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (REGISTER-JUSTIFICATION EXPLANATION-INFO) ...)

(CL:DEFUN REGISTER-JUSTIFICATION (SELF MAPPING)
  (GET-EXPLANATION-INFO SELF MAPPING TRUE))

;;; (DEFUN (GET-EXPLANATION-INFO EXPLANATION-INFO) ...)

(CL:DEFUN GET-EXPLANATION-INFO (SELF MAPPING CREATE?)
  (CL:LET* ((INFO (LOOKUP MAPPING SELF)))
   (CL:WHEN (CL:EQ INFO NULL)
    (CL:LET*
     ((INFO NULL) (JUST NULL)
      (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST MAPPING)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
      (CL:SETQ JUST (%KV-CONS.KEY ITER-000))
      (CL:PROGN (CL:SETQ INFO (%KV-CONS.VALUE ITER-000))
       (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000)))
      (CL:WHEN (JUSTIFICATION-EQL? JUST SELF)
       (INSERT-AT MAPPING SELF INFO)
       (CL:RETURN-FROM GET-EXPLANATION-INFO INFO))))
    (CL:WHEN CREATE? (CL:SETQ INFO (NEW-EXPLANATION-INFO))
     (INSERT-AT MAPPING SELF INFO)))
   INFO))

;;; (DEFUN (EXPLANATION-INFO EXPLANATION-INFO) ...)

(CL:DEFUN EXPLANATION-INFO (SELF MAPPING)
  (GET-EXPLANATION-INFO SELF MAPPING FALSE))

;;; (DEFUN (LOOKUP-JUSTIFICATION JUSTIFICATION) ...)

(CL:DEFUN LOOKUP-JUSTIFICATION (MAPPING LABEL)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL))
  (CL:LET*
   ((INFO NULL) (JUSTIFICATION NULL)
    (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST MAPPING)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
    (CL:SETQ JUSTIFICATION (%KV-CONS.KEY ITER-000))
    (CL:PROGN (CL:SETQ INFO (%KV-CONS.VALUE ITER-000))
     (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000)))
    (CL:WHEN (STRING-EQL? (%EXPLANATION-INFO.LABEL INFO) LABEL)
     (CL:RETURN-FROM LOOKUP-JUSTIFICATION JUSTIFICATION))))
  NULL)

;;; (DEFUN RESET-MAPPING-FOR-SUBEXPLANATION ...)

(CL:DEFUN RESET-MAPPING-FOR-SUBEXPLANATION (MAPPING)
  (CL:LET*
   ((INFO NULL) (JUSTIFICATION NULL)
    (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST MAPPING)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
    (CL:SETQ JUSTIFICATION (%KV-CONS.KEY ITER-000))
    (CL:PROGN (CL:SETQ INFO (%KV-CONS.VALUE ITER-000))
     (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000)))
    (CL:SETF (%EXPLANATION-INFO.EXPLAINED? INFO) FALSE))))

;;; (DEFUN (PRINT-EXPLANATION EXPLANATION-MAPPING) ...)

(CL:DEFUN PRINT-EXPLANATION (SELF STREAM MAPPING MAXDEPTH)
  (CL:DECLARE (CL:TYPE CL:FIXNUM MAXDEPTH))
  (CL:LET* ((UNEXPLAINED (NEW-LIST)) (INFO NULL))
   (CL:SETQ SELF (VISIBLE-JUSTIFICATION SELF))
   (CL:COND
    ((CL:EQ MAPPING NULL) (CL:SETQ MAPPING (NEW-KEY-VALUE-LIST))
     (CL:SETQ INFO (REGISTER-JUSTIFICATION SELF MAPPING))
     (CL:SETF (%EXPLANATION-INFO.LABEL INFO) "1")
     (CL:SETF (%EXPLANATION-INFO.DEPTH INFO) 1))
    (CL:T (CL:SETQ INFO (EXPLANATION-INFO SELF MAPPING))
     (CL:WHEN (CL:EQ INFO NULL)
      (CL:ERROR
       (NEW-STELLA-EXCEPTION
        "Justification not found in supplied explanation mapping.")))
     (RESET-MAPPING-FOR-SUBEXPLANATION MAPPING)
     (CL:SETQ MAXDEPTH
      (CL:1- (CL:+ (%EXPLANATION-INFO.DEPTH INFO) MAXDEPTH)))))
   (PUSH UNEXPLAINED SELF)
   (CL:LOOP WHILE (NON-EMPTY? UNEXPLAINED) DO
    (CL:SETQ SELF (POP UNEXPLAINED))
    (PRINT-ONE-EXPLANATION SELF STREAM MAPPING MAXDEPTH UNEXPLAINED))
   MAPPING))

;;; (DEFUN PRINT-ONE-EXPLANATION ...)

(CL:DEFUN PRINT-ONE-EXPLANATION (SELF STREAM MAPPING MAXDEPTH UNEXPLAINED)
  (CL:DECLARE (CL:TYPE CL:FIXNUM MAXDEPTH))
  (PRINT-EXPLANATION-HEADER SELF STREAM MAPPING)
  (PRINT-EXPLANATION-TEXT SELF STREAM MAPPING)
  (PRINT-EXPLANATION-SUBSTITUTION SELF STREAM MAPPING)
  (PRINT-EXPLANATION-ANTECEDENTS SELF STREAM MAPPING MAXDEPTH UNEXPLAINED)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL))

;;; (DEFSPECIAL *PROPOSITIONRECORDBINDINGS* ...)

(CL:DEFVAR *PROPOSITIONRECORDBINDINGS* NULL)

;;; (DEFUN (PRINTING-PROPOSITION-RECORD? BOOLEAN) ...)

(CL:DEFUN PRINTING-PROPOSITION-RECORD? ()
  (CL:NOT (CL:EQ *PROPOSITIONRECORDBINDINGS* NULL)))

;;; (DEFUN (PROPOSITION-RECORD-VALUE-OF OBJECT) ...)

(CL:DEFUN PROPOSITION-RECORD-VALUE-OF (SELF)
  (LOOKUP *PROPOSITIONRECORDBINDINGS* SELF))

;;; (DEFUN PRINT-JUSTIFICATION-PROPOSITION ...)

(CL:DEFUN PRINT-JUSTIFICATION-PROPOSITION (SELF STREAM INDENT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
  (CL:LET* ((PROPOSITIONSPEC (%JUSTIFICATION.PROPOSITION SELF)))
   (CL:LET*
    ((*INDENTCOUNTER* INDENT) (*PRINTMODE* KWD-JUSTIFICATIONS-REALISTIC))
    (CL:DECLARE (CL:SPECIAL *INDENTCOUNTER* *PRINTMODE*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
    (CL:WHEN (%JUSTIFICATION.REVERSE-POLARITY? SELF)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(not ")
     (CL:SETQ *INDENTCOUNTER* (CL:+ *INDENTCOUNTER* 5)))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE PROPOSITIONSPEC)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-JUSTIFICATIONS-LOGIC-PROPOSITION)
       (CL:PROGN (PRETTY-PRINT-LOGICAL-FORM PROPOSITIONSPEC STREAM)))
      ((SUBTYPE-OF? TEST-VALUE-000
        SGT-JUSTIFICATIONS-LOGIC-PROPOSITION-RECORD)
       (CL:PROGN
        (CL:LET*
         ((*PROPOSITIONRECORDBINDINGS*
           (%PROPOSITION-RECORD.BINDINGS PROPOSITIONSPEC)))
         (CL:DECLARE (CL:SPECIAL *PROPOSITIONRECORDBINDINGS*))
         (PRETTY-PRINT-LOGICAL-FORM
          (%PROPOSITION-RECORD.PROPOSITION PROPOSITIONSPEC) STREAM))))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "`" TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (CL:WHEN (%JUSTIFICATION.REVERSE-POLARITY? SELF)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))))

;;; (DEFUN PRINT-EXPLANATION-HEADER ...)

(CL:DEFUN PRINT-EXPLANATION-HEADER (SELF STREAM MAPPING)
  (CL:LET*
   ((INFO (EXPLANATION-INFO SELF MAPPING))
    (LABEL (%EXPLANATION-INFO.LABEL INFO))
    (INDENT (CL:1+ (CL:THE CL:FIXNUM (CL:LENGTH LABEL)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL)
    (CL:TYPE CL:FIXNUM INDENT))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) LABEL)
   (CL:COND
    ((CL:> (CL:THE CL:FIXNUM (CL:LENGTH LABEL)) *MAX-INLINE-LABEL-LENGTH*)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL
      *EXPLANATION-TAB-STRING*)
     (CL:SETQ INDENT
      (CL:THE CL:FIXNUM (CL:LENGTH *EXPLANATION-TAB-STRING*))))
    (CL:T (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")))
   (PRINT-JUSTIFICATION-PROPOSITION SELF STREAM INDENT)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
   (CL:SETF (%EXPLANATION-INFO.EXPLAINED? INFO) TRUE)))

;;; (DEFUN PRINT-EXPLANATION-TEXT ...)

(CL:DEFUN PRINT-EXPLANATION-TEXT (SELF STREAM MAPPING)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
   *EXPLANATION-TAB-STRING*)
  (CL:WHEN (PARTIALLY-FOLLOWS? SELF)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "partially "))
  (CL:LET* ((REVERSEPOLARITY? (%JUSTIFICATION.REVERSE-POLARITY? SELF)))
   (CL:LET* ((TEST-VALUE-000 (%JUSTIFICATION.INFERENCE-RULE SELF)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-MODUS-PONENS)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       "follows by Modus Ponens"))
     ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-MODUS-TOLLENS)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       "follows by Modus Tollens (p => q, ~q |= ~p)"))
     ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-AND-INTRODUCTION)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (CL:IF REVERSEPOLARITY?
        "follows by Not-Or-Introduction (~p, ~q |= ~(p v q))"
        "follows by And-Introduction")))
     ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-OR-INTRODUCTION)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (CL:IF REVERSEPOLARITY?
        "follows by Not-And-Introduction (~p |= ~(p & q))"
        "follows by Or-Introduction")))
     ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-DISPROOF)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (CL:IF REVERSEPOLARITY? "follows by Double-Negation-Introduction"
        "follows by disproof")))
     ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-FAIL-INTRODUCTION)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       "follows, since the argument proposition was not derivable"))
     ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY)
      (CL:LET* ((TEST-VALUE-001 (%PRIMITIVE-STRATEGY.STRATEGY SELF)))
       (CL:COND
        ((CL:OR (CL:EQ TEST-VALUE-001 KWD-JUSTIFICATIONS-SCAN-COLLECTION)
          (CL:EQ TEST-VALUE-001 KWD-JUSTIFICATIONS-ISA-PROPOSITION))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
          "holds by explicit assertion"))
        ((CL:EQ TEST-VALUE-001 KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS)
         (CL:IF
          (CL:NOT
           (CL:EQ
            (DYNAMIC-SLOT-VALUE
             (%PROPOSITION.DYNAMIC-SLOTS
              (GET-JUSTIFICATION-PROPOSITION SELF))
             SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL)
            NULL))
          (PRINT-SATELLITE-RULE-EXPLANATION SELF STREAM MAPPING)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
           "holds by explicit assertion")))
        ((CL:EQ TEST-VALUE-001 KWD-JUSTIFICATIONS-COMPUTED-PREDICATE)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
          "follows from computation"))
        ((CL:EQ TEST-VALUE-001 KWD-JUSTIFICATIONS-FAILURE)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
          "could not be derived"))
        (CL:T
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
          "follows via primitive "
          (%KEYWORD.SYMBOL-NAME (%PRIMITIVE-STRATEGY.STRATEGY SELF))
          " proof strategy")))))
     ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       "follows by Existential Introduction"))
     ((CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-UNHANDLED)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       "follows by some as yet unhandled inference rule"))
     (CL:T
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "follows")))))
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL))

;;; (DEFUN (MARK-AS-EXPLICIT-ASSERTION? BOOLEAN) ...)

(CL:DEFUN MARK-AS-EXPLICIT-ASSERTION? (SELF)
  (CL:WHEN (CL:EQ *EXPLANATION-STYLE* KWD-JUSTIFICATIONS-BRIEF)
   (CL:COND
    ((CL:EQ (%JUSTIFICATION.INFERENCE-RULE SELF)
      KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY)
     (CL:LET* ((TEST-VALUE-000 (%PRIMITIVE-STRATEGY.STRATEGY SELF)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-SCAN-COLLECTION)
         (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-ISA-PROPOSITION)
         (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS)
         (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS))
        (CL:RETURN-FROM MARK-AS-EXPLICIT-ASSERTION? TRUE))
       (CL:T))))
    (CL:T)))
  FALSE)

;;; (DEFUN (MARK-AS-FAILED-GOAL? BOOLEAN) ...)

(CL:DEFUN MARK-AS-FAILED-GOAL? (SELF)
  (CL:AND (CL:EQ *EXPLANATION-STYLE* KWD-JUSTIFICATIONS-BRIEF)
   (CL:EQ (%JUSTIFICATION.INFERENCE-RULE SELF)
    KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY)
   (FAILED-GOAL-JUSTIFICATION? SELF)))

;;; (DEFUN (PARTIALLY-FOLLOWS? BOOLEAN) ...)

(CL:DEFUN PARTIALLY-FOLLOWS? (SELF)
  (CL:LET* ((FOUND?-000 FALSE))
   (CL:LET* ((ANT NULL) (ITER-000 (%JUSTIFICATION.ANTECEDENTS SELF)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ ANT (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN
      (CL:OR (FAILED-GOAL-JUSTIFICATION? ANT)
       (CL:AND
        (CL:OR
         (CL:EQ (%JUSTIFICATION.INFERENCE-RULE ANT)
          KWD-JUSTIFICATIONS-AND-INTRODUCTION)
         (CL:EQ (%JUSTIFICATION.INFERENCE-RULE ANT)
          KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION))
        (PARTIALLY-FOLLOWS? ANT)))
      (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
   (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000)))

;;; (DEFUN PRINT-SATELLITE-RULE-EXPLANATION ...)

(CL:DEFUN PRINT-SATELLITE-RULE-EXPLANATION (SELF STREAM MAPPING)
  (CL:SETQ MAPPING MAPPING)
  (CL:LET*
   ((SATELLITE (GET-JUSTIFICATION-PROPOSITION SELF))
    (MASTER
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SATELLITE)
      SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL))
    (HEAD
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SATELLITE)))
      1))
    (TAIL
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SATELLITE)))
      0))
    (NAMEDSOURCE NULL) (SOURCE NULL))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 4))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:ECASE I (1 (CL:SETQ SOURCE HEAD))
      (2
       (CL:SETQ SOURCE
        (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS HEAD)
         SYM-JUSTIFICATIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL)))
      (3 (CL:SETQ SOURCE TAIL))
      (4
       (CL:SETQ SOURCE
        (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS TAIL)
         SYM-JUSTIFICATIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL))))
     (CL:WHEN (ISA? SOURCE SGT-JUSTIFICATIONS-LOGIC-NAMED-DESCRIPTION)
      (CL:SETQ NAMEDSOURCE SOURCE)
      (CL:WHEN
       (MEMBER? (DECLARATION-ORIGINATED-PROPOSITIONS NAMEDSOURCE) MASTER)
       (CL:RETURN)))))
   (CL:COND
    ((CL:NOT (CL:EQ NAMEDSOURCE NULL))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
      "holds by definition of " (NAME-DESCRIPTION-METACLASS NAMEDSOURCE)
      " " (DESCRIPTION-NAME NAMEDSOURCE)))
    (CL:T
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
      "holds by explicit assertion")))))

;;; (DEFUN PRINT-EXPLANATION-SUBSTITUTION ...)

(CL:DEFUN PRINT-EXPLANATION-SUBSTITUTION (SELF STREAM MAPPING)
  (CL:SETQ MAPPING MAPPING)
  (CL:WHEN
   (CL:OR
    (CL:EQ (%JUSTIFICATION.INFERENCE-RULE SELF)
     KWD-JUSTIFICATIONS-MODUS-PONENS)
    (CL:EQ (%JUSTIFICATION.INFERENCE-RULE SELF)
     KWD-JUSTIFICATIONS-MODUS-TOLLENS))
   (CL:LET*
    ((SUBSTITUTION
      (GET-JUSTIFICATION-SUBSTITUTION
       (%%VALUE (%%REST (%JUSTIFICATION.ANTECEDENTS SELF)))))
     (NOFVARS NULL-INTEGER))
    (CL:DECLARE (CL:TYPE CL:FIXNUM NOFVARS))
    (CL:WHEN (CL:NOT (CL:EQ SUBSTITUTION NULL))
     (CL:SETQ NOFVARS (LENGTH SUBSTITUTION))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
      *EXPLANATION-TAB-STRING* "and substitution {")
     (CL:LET*
      ((I NULL-INTEGER) (VALUE NULL) (VAR NULL)
       (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST SUBSTITUTION)) (ITER-001 1)
       (UPPER-BOUND-000 NOFVARS) (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 UPPER-BOUND-000 I))
      (CL:LOOP WHILE
       (CL:AND (CL:NOT (CL:EQ ITER-000 NULL))
        (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)))
       DO (CL:SETQ VAR (%KV-CONS.KEY ITER-000))
       (CL:PROGN (CL:SETQ VALUE (%KV-CONS.VALUE ITER-000))
        (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000)))
       (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
       (PRETTY-PRINT-LOGICAL-FORM VAR STREAM)
       (CL:WHEN (EQL? (VALUE-OF VAR) VAR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "/")
        (PRETTY-PRINT-LOGICAL-FORM VALUE STREAM))
       (CL:WHEN (CL:< I NOFVARS)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ", "))))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "}" EOL)))))

;;; (DEFUN PRINT-EXPLANATION-ANTECEDENTS ...)

(CL:DEFUN PRINT-EXPLANATION-ANTECEDENTS (SELF STREAM MAPPING MAXDEPTH UNEXPLAINED)
  (CL:DECLARE (CL:TYPE CL:FIXNUM MAXDEPTH))
  (CL:LET*
   ((INFO (EXPLANATION-INFO SELF MAPPING))
    (LABEL (%EXPLANATION-INFO.LABEL INFO))
    (DEPTH (%EXPLANATION-INFO.DEPTH INFO))
    (ANTECEDENTS (VISIBLE-ANTECEDENTS SELF)) (NEWANTECEDENTS NIL)
    (NEWANTECEDENTSINDEX 0) (MAXLABELLENGTH 0)
    (HAVEMARKEDANTECEDENT? FALSE)
    (LABELSTARTPOSITION
     (CL:+ (CL:THE CL:FIXNUM (CL:LENGTH *EXPLANATION-TAB-STRING*)) 6))
    (PROPOSITIONSTARTPOSITION 0) (INDENT 0))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL)
    (CL:TYPE CL:FIXNUM DEPTH NEWANTECEDENTSINDEX MAXLABELLENGTH
     LABELSTARTPOSITION PROPOSITIONSTARTPOSITION INDENT))
   (CL:LET*
    ((I NULL-INTEGER) (ANTECEDENT NULL)
     (ITER-000 (%LIST.THE-CONS-LIST ANTECEDENTS)) (ITER-001 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ ANTECEDENT (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETQ INFO (EXPLANATION-INFO ANTECEDENT MAPPING))
     (CL:WHEN (CL:EQ INFO NULL)
      (CL:SETQ INFO (REGISTER-JUSTIFICATION ANTECEDENT MAPPING))
      (CL:SETF (%EXPLANATION-INFO.LABEL INFO)
       (CONCATENATE LABEL "."
        (INTEGER-TO-STRING
         (CL:SETQ NEWANTECEDENTSINDEX (CL:1+ NEWANTECEDENTSINDEX)))))
      (CL:SETF (%EXPLANATION-INFO.DEPTH INFO) (CL:1+ DEPTH)))
     (CL:SETQ MAXLABELLENGTH
      (MAX MAXLABELLENGTH
       (CL:THE CL:FIXNUM
        (CL:LENGTH
         (CL:THE CL:SIMPLE-STRING (%EXPLANATION-INFO.LABEL INFO))))))
     (CL:WHEN (CL:NOT HAVEMARKEDANTECEDENT?)
      (CL:SETQ HAVEMARKEDANTECEDENT?
       (CL:OR (MARK-AS-EXPLICIT-ASSERTION? ANTECEDENT)
        (MARK-AS-FAILED-GOAL? ANTECEDENT))))))
   (CL:IF (CL:> MAXLABELLENGTH *MAX-INLINE-LABEL-LENGTH*)
    (CL:SETQ PROPOSITIONSTARTPOSITION LABELSTARTPOSITION)
    (CL:SETQ PROPOSITIONSTARTPOSITION
     (CL:+ LABELSTARTPOSITION MAXLABELLENGTH 1)))
   (CL:LET*
    ((I NULL-INTEGER) (ANTECEDENT NULL)
     (ITER-002 (%LIST.THE-CONS-LIST ANTECEDENTS)) (ITER-003 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-003 I))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:PROGN (CL:SETQ ANTECEDENT (%%VALUE ITER-002))
      (CL:SETQ ITER-002 (%%REST ITER-002)))
     (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
     (CL:SETQ INFO (EXPLANATION-INFO ANTECEDENT MAPPING))
     (CL:SETQ LABEL (%EXPLANATION-INFO.LABEL INFO))
     (CL:WHEN
      (CL:NOT
       (CL:OR (%EXPLANATION-INFO.EXPLAINED? INFO)
        (MARK-AS-EXPLICIT-ASSERTION? ANTECEDENT)
        (MARK-AS-FAILED-GOAL? ANTECEDENT)
        (CL:AND (DEFINED? MAXDEPTH)
         (CL:> (%EXPLANATION-INFO.DEPTH INFO) MAXDEPTH))))
      (CL:SETQ NEWANTECEDENTS (CONS ANTECEDENT NEWANTECEDENTS)))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
      *EXPLANATION-TAB-STRING* (CL:IF (CL:= I 1) "since " "and   ") LABEL
      " ")
     (CL:COND
      ((CL:> MAXLABELLENGTH *MAX-INLINE-LABEL-LENGTH*)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
       (CL:SETQ INDENT PROPOSITIONSTARTPOSITION))
      (CL:T
       (CL:SETQ INDENT
        (CL:- PROPOSITIONSTARTPOSITION
         (CL:+ LABELSTARTPOSITION (CL:THE CL:FIXNUM (CL:LENGTH LABEL)))
         1))))
     (CL:LET*
      ((I NULL-INTEGER) (ITER-004 1) (UPPER-BOUND-000 INDENT)
       (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-004 UPPER-BOUND-000 I))
      (CL:LOOP WHILE
       (CL:OR UNBOUNDED?-000 (CL:<= ITER-004 UPPER-BOUND-000)) DO
       (CL:PROGN (CL:SETQ I ITER-004) (CL:SETQ ITER-004 (CL:1+ ITER-004)))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")))
     (CL:WHEN HAVEMARKEDANTECEDENT?
      (CL:IF (MARK-AS-EXPLICIT-ASSERTION? ANTECEDENT)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        *EXPLANATION-ASSERTION-MARKER* " ")
       (CL:IF (MARK-AS-FAILED-GOAL? ANTECEDENT)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
         *EXPLANATION-FAILURE-MARKER* " ")
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "  "))))
     (PRINT-JUSTIFICATION-PROPOSITION ANTECEDENT STREAM
      (CL:IF HAVEMARKEDANTECEDENT?
       (CL:+ PROPOSITIONSTARTPOSITION
        (CL:1+
         (CL:THE CL:FIXNUM (CL:LENGTH *EXPLANATION-ASSERTION-MARKER*))))
       PROPOSITIONSTARTPOSITION))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)))
   (CL:LET* ((ANTECEDENT NULL) (ITER-005 NEWANTECEDENTS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
     (CL:PROGN (CL:SETQ ANTECEDENT (%%VALUE ITER-005))
      (CL:SETQ ITER-005 (%%REST ITER-005)))
     (PUSH UNEXPLAINED ANTECEDENT)))))

;;; (DEFUN (VISIBLE-JUSTIFICATION JUSTIFICATION) ...)

(CL:DEFUN VISIBLE-JUSTIFICATION (SELF)
  (CL:IF
   (CL:AND
    (CL:EQ (%JUSTIFICATION.INFERENCE-RULE SELF)
     KWD-JUSTIFICATIONS-DISPROOF)
    (CL:NOT (%JUSTIFICATION.REVERSE-POLARITY? SELF)))
   (%%VALUE (%JUSTIFICATION.ANTECEDENTS SELF)) SELF))

;;; (DEFUN (VISIBLE-ANTECEDENTS (LIST OF JUSTIFICATION)) ...)

(CL:DEFUN VISIBLE-ANTECEDENTS (SELF)
  (CL:LET* ((VISIBLEANTECEDENTS (NEW-LIST)))
   (COLLECT-VISIBLE-ANTECEDENTS SELF VISIBLEANTECEDENTS)
   (REVERSE VISIBLEANTECEDENTS)))

;;; (DEFUN COLLECT-VISIBLE-ANTECEDENTS ...)

(CL:DEFUN COLLECT-VISIBLE-ANTECEDENTS (SELF VISIBLEANTECEDENTS)
  (CL:LET* ((ANTECEDENTS (%JUSTIFICATION.ANTECEDENTS SELF)))
   (CL:LET* ((ANTECEDENT NULL) (ITER-000 ANTECEDENTS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ ANTECEDENT (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:SETQ ANTECEDENT (VISIBLE-JUSTIFICATION ANTECEDENT))
     (CL:COND
      ((CL:EQ (%JUSTIFICATION.INFERENCE-RULE ANTECEDENT)
        KWD-JUSTIFICATIONS-AND-INTRODUCTION)
       (CL:IF (CL:EQ *EXPLANATION-STYLE* KWD-JUSTIFICATIONS-BRIEF)
        (CL:LET*
         ((SUBANTECEDENT NULL)
          (ITER-001
           (%LIST.THE-CONS-LIST (VISIBLE-ANTECEDENTS ANTECEDENT))))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:PROGN (CL:SETQ SUBANTECEDENT (%%VALUE ITER-001))
           (CL:SETQ ITER-001 (%%REST ITER-001)))
          (PUSH VISIBLEANTECEDENTS SUBANTECEDENT)))
        (PUSH VISIBLEANTECEDENTS ANTECEDENT)))
      (CL:T (PUSH VISIBLEANTECEDENTS ANTECEDENT)))))))

;;; (DEFGLOBAL *MOST-RECENT-EXPLANATION-MAPPING* ...)

(CL:DEFVAR *MOST-RECENT-EXPLANATION-MAPPING* NULL)

;;; (DEFUN WHY ...)

(CL:DEFUN %WHY (ARGS)
  "Print an explanation for the result of the most recent query.
Without any arguments, `why' prints an explanation of the top level
query proposition down to a maximum depth of 3.  `(why all)' prints
an explanation to unlimited depth.  Alternatively, a particular depth
can be specified, for example, `(why 5)' explains down to a depth of 5.
A proof step that was not explained explicitly (e.g., due to a depth
cutoff) can be explained by supplying the label of the step as the
first argument to `why', for example, `(why 1.2.3 5)' prints an explanation
starting at 1.2.3 down to a depth of 5 (which is counted relative to the
depth of the starting point).  The keywords `brief' and `verbose' can be
used to select a particular explanation style.  In brief mode, explicitly
asserted propositions are not further explained and indicated with a
`!' assertion marker.  Additionally, relatively uninteresting proof steps
such as AND-introductions are skipped.  This explanation style option is
sticky and will affect future calls to `why' until it gets changed again.
The various options can be combined in any way, for example,
`(why 1.2.3 brief 3)' explains starting from step 1.2.3 down to a depth
of 3 in brief explanation mode."
  (CL:LET*
   ((QUERY *MOST-RECENT-QUERY*)
    (PARTIALQUERY?
     (CL:NOT
      (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *MOST-RECENT-QUERY*)
       NULL)))
    (JUSTIFICATION NULL))
   (CL:WHEN (CL:EQ QUERY NULL)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "There is nothing to explain." EOL)
    (CL:RETURN-FROM %WHY))
   (CL:SETQ JUSTIFICATION
    (%CONTROL-FRAME.JUSTIFICATION
     (%QUERY-ITERATOR.BASE-CONTROL-FRAME QUERY)))
   (CL:COND
    ((CL:EQ JUSTIFICATION NULL)
     (CL:COND
      ((NON-EMPTY? (%QUERY-ITERATOR.SOLUTIONS QUERY))
       (CL:IF (%QUERY-ITERATOR.EXHAUSTED? QUERY)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "There was either no more solution, or you used the `all' keyword."
         EOL
         "   The query must generate only a single answer for explanation"
         EOL
         "   to be possible, thus don't use the `all' keyword to `retrieve'."
         EOL)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "No justifications available.  You have to enable justifications"
         EOL
         "   with `(set-feature justifications)' and rerun the query in"
         EOL "   order to enable the explanation of results." EOL)))
      ((%QUERY-ITERATOR.EXHAUSTED? QUERY)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "There was no solution." EOL))
      (CL:T
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "There is no solution yet." EOL))))
    ((CL:AND (%QUERY-ITERATOR.EXHAUSTED? QUERY) (CL:NOT PARTIALQUERY?))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "There was no more solution." EOL))
    (CL:T
     (CL:LET* ((ARGLIST NIL))
      (CL:LET* ((ARG NULL) (ITER-000 ARGS) (COLLECT-000 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-000))
         (CL:SETQ ITER-000 (%%REST ITER-000)))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG NIL))
          (CL:IF (CL:EQ ARGLIST NIL) (CL:SETQ ARGLIST COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST ARGLIST COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
      (CL:LET*
       ((LABEL STELLA::NULL-STRING) (STYLE NULL) (MAXDEPTH NULL-INTEGER))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL)
        (CL:TYPE CL:FIXNUM MAXDEPTH))
       (CL:MULTIPLE-VALUE-SETQ (LABEL STYLE MAXDEPTH)
        (PARSE-WHY-ARGUMENTS ARGLIST))
       (CL:COND
        ((CL:NOT (CL:EQ LABEL STELLA::NULL-STRING))
         (CL:WHEN (CL:NOT (CL:EQ *MOST-RECENT-EXPLANATION-MAPPING* NULL))
          (CL:SETQ JUSTIFICATION
           (LOOKUP-JUSTIFICATION *MOST-RECENT-EXPLANATION-MAPPING*
            LABEL)))
         (CL:WHEN (CL:EQ JUSTIFICATION NULL)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
           "Label `" LABEL "' does not exists in the current explanation"
           EOL)
          (CL:RETURN-FROM %WHY)))
        (CL:T (CL:SETQ *MOST-RECENT-EXPLANATION-MAPPING* NULL)))
       (CL:WHEN (CL:NOT (CL:EQ STYLE NULL))
        (CL:SETQ *EXPLANATION-STYLE* STYLE))
       (CL:SETQ *MOST-RECENT-EXPLANATION-MAPPING*
        (PRINT-EXPLANATION JUSTIFICATION STANDARD-OUTPUT
         *MOST-RECENT-EXPLANATION-MAPPING* MAXDEPTH))))))))

(CL:DEFUN WHY-EVALUATOR-WRAPPER (ARGUMENTS)
  (%WHY ARGUMENTS))

(CL:DEFMACRO WHY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Print an explanation for the result of the most recent query.
Without any arguments, `why' prints an explanation of the top level
query proposition down to a maximum depth of 3.  `(why all)' prints
an explanation to unlimited depth.  Alternatively, a particular depth
can be specified, for example, `(why 5)' explains down to a depth of 5.
A proof step that was not explained explicitly (e.g., due to a depth
cutoff) can be explained by supplying the label of the step as the
first argument to `why', for example, `(why 1.2.3 5)' prints an explanation
starting at 1.2.3 down to a depth of 5 (which is counted relative to the
depth of the starting point).  The keywords `brief' and `verbose' can be
used to select a particular explanation style.  In brief mode, explicitly
asserted propositions are not further explained and indicated with a
`!' assertion marker.  Additionally, relatively uninteresting proof steps
such as AND-introductions are skipped.  This explanation style option is
sticky and will affect future calls to `why' until it gets changed again.
The various options can be combined in any way, for example,
`(why 1.2.3 brief 3)' explains starting from step 1.2.3 down to a depth
of 3 in brief explanation mode."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/WHY)) (CL:MACRO-FUNCTION (CL:QUOTE WHY)))

;;; (DEFUN (COMMAND-OPTION-EQL? BOOLEAN) ...)

(CL:DEFUN COMMAND-OPTION-EQL? (ARG OPTION)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OPTION))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-JUSTIFICATIONS-STELLA-GENERALIZED-SYMBOL)
     (CL:PROGN
      (STRING-EQL? (STRING-UPCASE (%GENERALIZED-SYMBOL.SYMBOL-NAME ARG))
       OPTION)))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (STRING-EQL? (STRING-UPCASE (%STRING-WRAPPER.WRAPPER-VALUE ARG))
       OPTION)))
    (CL:T FALSE))))

;;; (DEFUN (PARSE-WHY-ARGUMENTS STRING KEYWORD INTEGER) ...)

(CL:DEFUN PARSE-WHY-ARGUMENTS (ARGS)
  (CL:LET*
   ((LABEL STELLA::NULL-STRING) (DEPTH *DEFAULT-EXPLANATION-DEPTH*)
    (STYLE NULL) (FIRSTARG (%%VALUE ARGS)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL) (CL:TYPE CL:FIXNUM DEPTH))
   (CL:WHEN (CL:NOT (CL:EQ FIRSTARG NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE FIRSTARG)))
     (CL:COND
      ((SUBTYPE-OF-STRING? TEST-VALUE-000)
       (CL:PROGN (CL:SETQ LABEL (%STRING-WRAPPER.WRAPPER-VALUE FIRSTARG))
        (CL:SETQ ARGS (%%REST ARGS))))
      ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
       (CL:PROGN
        (CL:WHEN (EQL? FIRSTARG ONE-WRAPPER) (CL:SETQ LABEL "1")
         (CL:SETQ ARGS (%%REST ARGS)))))
      ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
       (CL:PROGN (CL:SETQ LABEL (STRINGIFY FIRSTARG))
        (CL:SETQ ARGS (%%REST ARGS))))
      ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
       (CL:PROGN
        (CL:WHEN
         (CL:EQ
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY *CHARACTER-TYPE-TABLE*))
           (CL:THE CL:FIXNUM
            (CL:CHAR-CODE
             (CL:LET ((SELF (%SYMBOL.SYMBOL-NAME FIRSTARG)) (POSITION 0))
              (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
               (CL:TYPE CL:FIXNUM POSITION))
              (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
               (CL:THE CL:FIXNUM POSITION))))))
          KWD-JUSTIFICATIONS-DIGIT)
         (CL:SETQ LABEL (%SYMBOL.SYMBOL-NAME FIRSTARG))
         (CL:SETQ ARGS (%%REST ARGS)))))
      (CL:T)))
    (CL:LET* ((I NULL-INTEGER) (ARG NULL) (ITER-000 ARGS) (ITER-001 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
      (CL:WHEN (COMMAND-OPTION-EQL? ARG "BRIEF")
       (CL:SETQ STYLE KWD-JUSTIFICATIONS-BRIEF))
      (CL:WHEN (COMMAND-OPTION-EQL? ARG "VERBOSE")
       (CL:SETQ STYLE KWD-JUSTIFICATIONS-VERBOSE))
      (CL:WHEN (INTEGER? ARG)
       (CL:SETQ DEPTH (%INTEGER-WRAPPER.WRAPPER-VALUE ARG)))
      (CL:WHEN (CL:EQ ARG KWD-JUSTIFICATIONS-DEPTH)
       (CL:WHEN (CL:EQ (NTH ARGS (CL:1+ I)) NULL)
        (CL:SETQ DEPTH NULL-INTEGER)))
      (CL:WHEN (COMMAND-OPTION-EQL? ARG "ALL")
       (CL:SETQ DEPTH NULL-INTEGER)))))
   (CL:VALUES LABEL STYLE DEPTH)))

;;; (DEFUN (DERIVE-JUSTIFIED-PARTIAL-QUERY QUERY-ITERATOR) ...)

(CL:DEFUN DERIVE-JUSTIFIED-PARTIAL-QUERY (QUERY)
  (CL:WHEN
   (CL:AND
    (CL:NOT (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY QUERY) NULL))
    (CL:NOT
     (CL:EQ
      (%CONTROL-FRAME.JUSTIFICATION
       (%QUERY-ITERATOR.BASE-CONTROL-FRAME QUERY))
      NULL)))
   (CL:RETURN-FROM DERIVE-JUSTIFIED-PARTIAL-QUERY QUERY))
  (CL:LET*
   ((PARTIALQUERY
     (CREATE-QUERY-ITERATOR
      (%PATTERN-RECORD.DESCRIPTION
       (%CONTROL-FRAME.PATTERN-RECORD
        (%QUERY-ITERATOR.BASE-CONTROL-FRAME QUERY)))
      (%QUERY-ITERATOR.VALUE QUERY)
      (%QUERY-ITERATOR.ATOMIC-SINGLETONS? QUERY)))
    (RECORDJUSTIFICATIONS? *RECORD-JUSTIFICATIONS?*)
    (TRACESUBGOALS? (TRACE-KEYWORD? KWD-JUSTIFICATIONS-GOAL-TREE))
    (PARTIALMATCHMODE *PARTIAL-MATCH-MODE*))
   (UNSET-POWERLOOM-FEATURE KWD-JUSTIFICATIONS-TRACE-SUBGOALS)
   (SET-POWERLOOM-FEATURE KWD-JUSTIFICATIONS-JUSTIFICATIONS)
   (%SET-PARTIAL-MATCH-MODE KWD-JUSTIFICATIONS-BASIC)
   (RETURN-PARTIAL-TRUTH PARTIALQUERY TRUE)
   (CL:WHEN TRACESUBGOALS?
    (SET-POWERLOOM-FEATURE KWD-JUSTIFICATIONS-TRACE-SUBGOALS))
   (CL:WHEN (CL:NOT RECORDJUSTIFICATIONS?)
    (UNSET-POWERLOOM-FEATURE KWD-JUSTIFICATIONS-JUSTIFICATIONS))
   (%SET-PARTIAL-MATCH-MODE PARTIALMATCHMODE) PARTIALQUERY))

;;; (DEFUN WHYNOT ...)

(CL:DEFUN %WHYNOT (ARGS)
  (CL:LET*
   ((QUERY *MOST-RECENT-QUERY*) (ARGLIST ARGS) (JUSTIFICATION NULL))
   (CL:WHEN (CL:EQ QUERY NULL)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "There is nothing to explain." EOL)
    (CL:RETURN-FROM %WHYNOT))
   (CL:WHEN
    (CL:AND (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY QUERY) NULL)
     (CL:NOT (%QUERY-ITERATOR.EXHAUSTED? QUERY)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "The query did not fail." EOL)
    (CL:RETURN-FROM %WHYNOT))
   (CL:SETQ QUERY (DERIVE-JUSTIFIED-PARTIAL-QUERY QUERY))
   (CL:SETQ JUSTIFICATION
    (%CONTROL-FRAME.JUSTIFICATION
     (%QUERY-ITERATOR.BASE-CONTROL-FRAME QUERY)))
   (CL:LET*
    ((LABEL STELLA::NULL-STRING) (STYLE NULL) (MAXDEPTH NULL-INTEGER))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL)
     (CL:TYPE CL:FIXNUM MAXDEPTH))
    (CL:MULTIPLE-VALUE-SETQ (LABEL STYLE MAXDEPTH)
     (PARSE-WHY-ARGUMENTS ARGLIST))
    (CL:COND
     ((CL:NOT (CL:EQ LABEL STELLA::NULL-STRING))
      (CL:WHEN (CL:NOT (CL:EQ *MOST-RECENT-EXPLANATION-MAPPING* NULL))
       (CL:SETQ JUSTIFICATION
        (LOOKUP-JUSTIFICATION *MOST-RECENT-EXPLANATION-MAPPING* LABEL)))
      (CL:WHEN (CL:EQ JUSTIFICATION NULL)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "Label `" LABEL "' does not exists in the current explanation"
        EOL)
       (CL:RETURN-FROM %WHYNOT)))
     (CL:T (CL:SETQ *MOST-RECENT-EXPLANATION-MAPPING* NULL)))
    (CL:WHEN (CL:NOT (CL:EQ STYLE NULL))
     (CL:SETQ *EXPLANATION-STYLE* STYLE))
    (CL:LET* ((FOUND?-000 FALSE))
     (CL:LET* ((ARG NULL) (ITER-000 ARGLIST))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:WHEN (COMMAND-OPTION-EQL? ARG "SUMMARY")
        (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
     (CL:IF FOUND?-000
      (CL:PROGN
       (CL:LET* ((FAILURES (NEW-LIST)))
        (COLLECT-FAILED-GOALS JUSTIFICATION FAILURES)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "The query failed, because" EOL)
        (CL:LET*
         ((I NULL-INTEGER) (FAILURE NULL)
          (ITER-001 (%LIST.THE-CONS-LIST FAILURES)) (ITER-002 1))
         (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-002 I))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:PROGN (CL:SETQ FAILURE (%%VALUE ITER-001))
           (CL:SETQ ITER-001 (%%REST ITER-001)))
          (CL:PROGN (CL:SETQ I ITER-002)
           (CL:SETQ ITER-002 (CL:1+ ITER-002)))
          (CL:IF (CL:= I 1)
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
            "    ")
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
            "and "))
          (PRINT-JUSTIFICATION-PROPOSITION FAILURE STANDARD-OUTPUT 4)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
           EOL)))
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "failed." EOL EOL)))
      (CL:PROGN
       (CL:SETQ *MOST-RECENT-EXPLANATION-MAPPING*
        (PRINT-EXPLANATION JUSTIFICATION STANDARD-OUTPUT
         *MOST-RECENT-EXPLANATION-MAPPING* MAXDEPTH))))))))

(CL:DEFUN WHYNOT-EVALUATOR-WRAPPER (ARGUMENTS)
  (%WHYNOT ARGUMENTS))

(CL:DEFMACRO WHYNOT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/WHYNOT)) (CL:MACRO-FUNCTION (CL:QUOTE WHYNOT)))

(CL:DEFUN NEW-FORWARD-GOAL-RECORD ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-FORWARD-GOAL-RECORD))
   (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF) NULL)
   (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FORWARD-GOAL-RECORD))
  SGT-JUSTIFICATIONS-LOGIC-FORWARD-GOAL-RECORD)

(CL:DEFUN ACCESS-FORWARD-GOAL-RECORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-FORWARD-GOAL)
    (CL:IF SETVALUE?
     (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-FORWARD-RULE)
    (CL:IF SETVALUE?
     (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD FORWARD-CHAINING-GOALS ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
      SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

;;; (DEFMETHOD (DELETED? BOOLEAN) ...)

(CL:DEFMETHOD DELETED? ((SELF FORWARD-GOAL-RECORD))
  (CL:LET*
   ((GOAL (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF))
    (RULE (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF)))
   (CL:OR (CL:EQ GOAL NULL) (CL:EQ RULE NULL) (DELETED-PROPOSITION? GOAL)
    (DELETED-PROPOSITION? RULE))))

;;; (DEFMETHOD (DELETED?-SETTER BOOLEAN) ...)

(CL:DEFMETHOD DELETED?-SETTER ((SELF FORWARD-GOAL-RECORD) VALUE)
  (CL:WHEN VALUE (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF) NULL)
   (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF) NULL))
  VALUE)

;;; (DEFUN RECORD-FORWARD-GOAL ...)

(CL:DEFUN RECORD-FORWARD-GOAL (FORWARDRULE ARGUMENTS CONSEQUENTPROPOSITION)
  (CL:LET*
   ((FWDGOALREC NULL)
    (ITER-000
     (%LIST.THE-CONS-LIST
      (FORWARD-CHAINING-GOALS CONSEQUENTPROPOSITION))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ FWDGOALREC (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (CL:NOT (DELETED? FWDGOALREC))
     (CL:LET* ((FWDGOAL (%FORWARD-GOAL-RECORD.FORWARD-GOAL FWDGOALREC)))
      (CL:LET* ((TEST-VALUE-000 FALSE))
       (CL:SETQ TEST-VALUE-000
        (CL:EQ (%FORWARD-GOAL-RECORD.FORWARD-RULE FWDGOALREC)
         FORWARDRULE))
       (CL:WHEN TEST-VALUE-000
        (CL:LET* ((ALWAYS?-000 TRUE))
         (CL:LET*
          ((I NULL-INTEGER) (ARG NULL) (VECTOR-000 ARGUMENTS)
           (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (ITER-001 1))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-001 I))
          (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
           (CL:PROGN
            (CL:SETQ ARG
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
              INDEX-000))
            (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
           (CL:PROGN (CL:SETQ I ITER-001)
            (CL:SETQ ITER-001 (CL:1+ ITER-001)))
           (CL:WHEN
            (CL:NOT
             (EQL?
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FWDGOAL)))
               I)
              ARG))
            (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
         (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
       (CL:WHEN TEST-VALUE-000 (CL:RETURN-FROM RECORD-FORWARD-GOAL)))))))
  (CL:WHEN (ELABORATION-RULE? CONSEQUENTPROPOSITION FORWARDRULE ARGUMENTS)
   (CL:RETURN-FROM RECORD-FORWARD-GOAL))
  (CL:LET*
   ((FORWARDGOAL
     (CREATE-PROPOSITION SYM-JUSTIFICATIONS-STELLA-PREDICATE
      (CL:1+ (LENGTH ARGUMENTS)))))
   (CL:LET* ((SELF-000 (NEW-FORWARD-GOAL-RECORD)))
    (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF-000) FORWARDGOAL)
    (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF-000) FORWARDRULE)
    (CL:LET* ((FWDGOALREC SELF-000))
     (CL:SETF (%PROPOSITION.OPERATOR FORWARDGOAL)
      SGT-JUSTIFICATIONS-PL-KERNEL-KB-HOLDS)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORWARDGOAL)))
       (VALUE
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORWARDRULE)))
         0))
       (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET*
      ((I NULL-INTEGER) (ARG NULL) (VECTOR-001 ARGUMENTS) (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)) (ITER-002 1))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 ITER-002 I))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:PROGN
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORWARDGOAL)))
         (VALUE ARG) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))))
     (CL:IF (EMPTY? (FORWARD-CHAINING-GOALS CONSEQUENTPROPOSITION))
      (SET-DYNAMIC-SLOT-VALUE
       (%PROPOSITION.DYNAMIC-SLOTS CONSEQUENTPROPOSITION)
       SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS (LIST FWDGOALREC)
       NULL)
      (INSERT-NEW (FORWARD-CHAINING-GOALS CONSEQUENTPROPOSITION)
       FWDGOALREC))))))

;;; (DEFUN (PREDICATION? BOOLEAN) ...)

(CL:DEFUN PREDICATION? (PROPOSITION)
  (MEMBER?
   (GET-QUOTED-TREE "((:PREDICATE :FUNCTION :ISA :EQUIVALENT) \"/LOGIC\")"
    "/LOGIC")
   (%PROPOSITION.KIND PROPOSITION)))

;;; (DEFUN (ASSERTED-AS-TRUE? BOOLEAN) ...)

(CL:DEFUN ASSERTED-AS-TRUE? (PROPOSITION)
  (CL:LET*
   ((*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (TRUE-PROPOSITION? PROPOSITION)))

;;; (DEFUN (ELABORATION-RULE? BOOLEAN) ...)

(CL:DEFUN ELABORATION-RULE? (CONSEQUENTPROPOSITION FORWARDRULE ARGUMENTS)
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:SETQ TEST-VALUE-000 (PREDICATION? CONSEQUENTPROPOSITION))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000 (ASSERTED-AS-TRUE? FORWARDRULE))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((ALWAYS?-000 TRUE))
      (CL:LET*
       ((ARG NULL)
        (VECTOR-000 (%PROPOSITION.ARGUMENTS CONSEQUENTPROPOSITION))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:PROGN
         (CL:SETQ ARG
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
        (CL:WHEN (CL:NOT (MEMBER? ARGUMENTS ARG))
         (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
      (CL:SETQ TEST-VALUE-000 ALWAYS?-000))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (GET-FORWARD-GOALS (LIST OF FORWARD-GOAL-RECORD)) ...)

(CL:DEFUN GET-FORWARD-GOALS (PROPOSITION)
  (CL:LET*
   ((GOALS (REMOVE-DELETED-MEMBERS (FORWARD-CHAINING-GOALS PROPOSITION))))
   (CL:WHEN
    (CL:AND (EMPTY? GOALS)
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
        SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL)
       NULL)))
    (CL:SETQ GOALS
     (REMOVE-DELETED-MEMBERS
      (FORWARD-CHAINING-GOALS
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
        SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL)))))
   GOALS))

(CL:DEFUN NEW-FORWARD-JUSTIFICATION ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-FORWARD-JUSTIFICATION))
   (CL:SETF (%FORWARD-JUSTIFICATION.ANTECEDENTS SELF) NULL)
   (CL:SETF (%FORWARD-JUSTIFICATION.FORWARD-RULE SELF) NULL)
   (CL:SETF (%FORWARD-JUSTIFICATION.CONSEQUENT SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FORWARD-JUSTIFICATION))
  SGT-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATION)

(CL:DEFUN ACCESS-FORWARD-JUSTIFICATION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-CONSEQUENT)
    (CL:IF SETVALUE?
     (CL:SETF (%FORWARD-JUSTIFICATION.CONSEQUENT SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-JUSTIFICATION.CONSEQUENT SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-FORWARD-RULE)
    (CL:IF SETVALUE?
     (CL:SETF (%FORWARD-JUSTIFICATION.FORWARD-RULE SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-JUSTIFICATION.FORWARD-RULE SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS)
    (CL:IF SETVALUE?
     (CL:SETF (%FORWARD-JUSTIFICATION.ANTECEDENTS SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-JUSTIFICATION.ANTECEDENTS SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD FORWARD-JUSTIFICATIONS ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
      SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

;;; (DEFUN (CREATE-FORWARD-JUSTIFICATION FORWARD-JUSTIFICATION) ...)

(CL:DEFUN CREATE-FORWARD-JUSTIFICATION (CONSEQUENTPROPOSITION FORWARDRULE ANTECEDENTS)
  (CL:LET* ((FJ (NEW-FORWARD-JUSTIFICATION)))
   (CL:SETF (%FORWARD-JUSTIFICATION.CONSEQUENT FJ) CONSEQUENTPROPOSITION)
   (CL:SETF (%FORWARD-JUSTIFICATION.FORWARD-RULE FJ) FORWARDRULE)
   (CL:SETF (%FORWARD-JUSTIFICATION.ANTECEDENTS FJ) ANTECEDENTS) FJ))

;;; (DEFUN RECORD-FORWARD-JUSTIFICATION ...)

(CL:DEFUN RECORD-FORWARD-JUSTIFICATION (CONSEQUENTPROPOSITION FORWARDRULE ANTECEDENTS)
  (CL:WHEN (CL:NOT *RECORD-JUSTIFICATIONS?*)
   (CL:RETURN-FROM RECORD-FORWARD-JUSTIFICATION))
  (CL:LET*
   ((JUSTIFICATIONS (FORWARD-JUSTIFICATIONS CONSEQUENTPROPOSITION)))
   (CL:LET* ((FJ NULL) (ITER-000 (%LIST.THE-CONS-LIST JUSTIFICATIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ FJ (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (CL:EQ (%FORWARD-JUSTIFICATION.FORWARD-RULE FJ) FORWARDRULE)
      (CL:SETF (%FORWARD-JUSTIFICATION.ANTECEDENTS FJ) ANTECEDENTS)
      (CL:RETURN-FROM RECORD-FORWARD-JUSTIFICATION))))
   (CL:WHEN (CL:EQ JUSTIFICATIONS NIL-LIST)
    (CL:SETQ JUSTIFICATIONS (LIST))
    (SET-DYNAMIC-SLOT-VALUE
     (%PROPOSITION.DYNAMIC-SLOTS CONSEQUENTPROPOSITION)
     SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS JUSTIFICATIONS NULL))
   (CL:SETQ ANTECEDENTS (CONS FORWARDRULE ANTECEDENTS))
   (PUSH JUSTIFICATIONS
    (CREATE-FORWARD-JUSTIFICATION CONSEQUENTPROPOSITION FORWARDRULE
     ANTECEDENTS))))

;;; (DEFUN RECORD-HOLDS-BY-DEFAULT ...)

(CL:DEFUN RECORD-HOLDS-BY-DEFAULT (FRAME LASTMOVE)
  (CL:LET* ((PARENT (%CONTROL-FRAME.UP FRAME)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:WHEN
      (CL:OR (%CONTROL-FRAME.HOLDS-BY-DEFAULT? FRAME)
       (%QUERY-ITERATOR.LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*))
      (CL:SETF (%CONTROL-FRAME.HOLDS-BY-DEFAULT? PARENT) TRUE)))
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
       LASTMOVE "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

(CL:DEFUN HELP-STARTUP-JUSTIFICATIONS1 ()
  (CL:PROGN
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-PROPOSITION-SPEC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION-SPEC" NULL 0))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-PROPOSITION-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION-RECORD" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-BINDINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BINDINGS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 0))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATION" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-RULE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-REVERSE-POLARITY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REVERSE-POLARITY?" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-MATCH-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MATCH-SCORE" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMITIVE-STRATEGY" NULL 2))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMITIVE-STRATEGY" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRATEGY" NULL 0))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ KWD-JUSTIFICATIONS-UP-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TRUE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-ATOMIC-GOAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ATOMIC-GOAL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-FULL-SUBQUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULL-SUBQUERY" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-ANTECEDENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-CLUSTERED-CONJUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLUSTERED-CONJUNCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-PATTERN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-UP-TRUE-PRIMITIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TRUE-PRIMITIVE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-UP-FALSE-PRIMITIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-FALSE-PRIMITIVE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-UP-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-FAIL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-FAILURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILURE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-MODUS-TOLLENS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODUS-TOLLENS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-MODUS-PONENS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODUS-PONENS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-PROPOSITIONS" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS-RULE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-BACK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACK" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-AND-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-OR-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-DISPROOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISPROOF" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-FAIL-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTENTIAL-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-UNHANDLED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNHANDLED" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-BRIEF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BRIEF" NULL 2))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-EXPLANATION-INFO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXPLANATION-INFO" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-LABEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LABEL"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-DEPTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPTH" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-EXPLAINED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXPLAINED?" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-EXPLANATION-MAPPING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXPLANATION-MAPPING" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-REALISTIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REALISTIC" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SCAN-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-COLLECTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-ISA-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA-PROPOSITION" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-COMPUTED-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPUTED-PREDICATE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP-ASSERTIONS" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-COMPLEMENT-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT-DESCRIPTION" NULL 0))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-WHY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHY" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SGT-JUSTIFICATIONS-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ KWD-JUSTIFICATIONS-DIGIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIGIT" NULL 2))))

(CL:DEFUN HELP-STARTUP-JUSTIFICATIONS2 ()
  (CL:PROGN
   (CL:SETQ KWD-JUSTIFICATIONS-VERBOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBOSE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-DEPTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPTH" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-GOAL-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-TREE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-TRACE-SUBGOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRACE-SUBGOALS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATIONS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-BASIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BASIC" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-WHYNOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHYNOT" NULL 0))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-FORWARD-GOAL-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-GOAL-RECORD" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-GOAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-GOAL" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-RULE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-CHAINING-GOALS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SGT-JUSTIFICATIONS-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-JUSTIFICATION" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-CONSEQUENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSEQUENT" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-JUSTIFICATIONS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-STARTUP-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-JUSTIFICATIONS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))))

(CL:DEFUN HELP-STARTUP-JUSTIFICATIONS3 ()
  (CL:PROGN
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE PROPOSITION-SPEC STANDARD-OBJECT)")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PROPOSITION-RECORD"
       "(DEFCLASS PROPOSITION-RECORD (STANDARD-OBJECT) :SLOTS ((PROPOSITION :TYPE PROPOSITION) (BINDINGS :TYPE ENTITY-MAPPING) (TRUTH-VALUE :TYPE TRUTH-VALUE)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PROPOSITION-RECORD))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PROPOSITION-RECORD-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "JUSTIFICATION"
       "(DEFCLASS JUSTIFICATION (STANDARD-OBJECT) :SLOTS ((INFERENCE-RULE :TYPE KEYWORD) (PROPOSITION :TYPE PROPOSITION-SPEC) (ANTECEDENTS :TYPE (CONS OF JUSTIFICATION) :INITIALLY NIL) (REVERSE-POLARITY? :TYPE BOOLEAN) (TRUTH-VALUE :TYPE TRUTH-VALUE) (MATCH-SCORE :TYPE PARTIAL-MATCH-SCORE)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-JUSTIFICATION))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-JUSTIFICATION-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PRIMITIVE-STRATEGY"
       "(DEFCLASS PRIMITIVE-STRATEGY (JUSTIFICATION) :SLOTS ((INFERENCE-RULE :TYPE KEYWORD :INITIALLY :PRIMITIVE-STRATEGY) (STRATEGY :TYPE KEYWORD)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PRIMITIVE-STRATEGY))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PRIMITIVE-STRATEGY-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "EXPLANATION-INFO"
       "(DEFCLASS EXPLANATION-INFO (STANDARD-OBJECT) :SLOTS ((LABEL :TYPE STRING) (DEPTH :TYPE INTEGER) (EXPLAINED? :TYPE BOOLEAN)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-EXPLANATION-INFO))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-EXPLANATION-INFO-SLOT-VALUE)))
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE EXPLANATION-MAPPING (KEY-VALUE-LIST OF JUSTIFICATION EXPLANATION-INFO))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FORWARD-GOAL-RECORD"
       "(DEFCLASS FORWARD-GOAL-RECORD (STANDARD-OBJECT) :SLOTS ((FORWARD-GOAL :TYPE PROPOSITION) (FORWARD-RULE :TYPE PROPOSITION)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-FORWARD-GOAL-RECORD))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-FORWARD-GOAL-RECORD-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FORWARD-JUSTIFICATION"
       "(DEFCLASS FORWARD-JUSTIFICATION (STANDARD-OBJECT) :DOCUMENTATION \"Connects a proposition to other propositions
that collectively implied its truth.\" :SLOTS ((CONSEQUENT :TYPE PROPOSITION) (FORWARD-RULE :TYPE PROPOSITION) (ANTECEDENTS :TYPE (CONS OF PROPOSITION))))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-FORWARD-JUSTIFICATION))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-FORWARD-JUSTIFICATION-SLOT-VALUE)))))

(CL:DEFUN HELP-STARTUP-JUSTIFICATIONS4 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "GET-JUSTIFICATION-PROPOSITION"
    "(DEFUN (GET-JUSTIFICATION-PROPOSITION PROPOSITION) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION GET-JUSTIFICATION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-JUSTIFICATION-SUBSTITUTION"
    "(DEFUN (GET-JUSTIFICATION-SUBSTITUTION ENTITY-MAPPING) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION GET-JUSTIFICATION-SUBSTITUTION) NULL)
   (DEFINE-FUNCTION-OBJECT "JUSTIFICATION-EQL?"
    "(DEFUN (JUSTIFICATION-EQL? BOOLEAN) ((JUST1 JUSTIFICATION) (JUST2 JUSTIFICATION)))"
    (CL:FUNCTION JUSTIFICATION-EQL?) NULL)
   (DEFINE-FUNCTION-OBJECT "JUSTIFICATION-PROPOSITIONS-EQL?"
    "(DEFUN (JUSTIFICATION-PROPOSITIONS-EQL? BOOLEAN) ((PROPOSITION1 PROPOSITION) (BINDINGS1 ENTITY-MAPPING) (PROPOSITION2 PROPOSITION) (BINDINGS2 ENTITY-MAPPING)))"
    (CL:FUNCTION JUSTIFICATION-PROPOSITIONS-EQL?) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-JUSTIFICATIONS?"
    "(DEFUN (RECORD-JUSTIFICATIONS? BOOLEAN) () :DOCUMENTATION \"Return TRUE if every query records justifications to enable
the explanation of concluded results.\" :GLOBALLY-INLINE? TRUE (RETURN *RECORD-JUSTIFICATIONS?*))"
    (CL:FUNCTION RECORD-JUSTIFICATIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-JUSTIFICATION"
    "(DEFUN RECORD-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION RECORD-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-JUSTIFICATION-PROPOSITION"
    "(DEFUN (CREATE-JUSTIFICATION-PROPOSITION PROPOSITION-SPEC) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION CREATE-JUSTIFICATION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-PROPOSITION-RECORD-BINDINGS"
    "(DEFUN (YIELD-PROPOSITION-RECORD-BINDINGS ENTITY-MAPPING) ((SELF PROPOSITION) (TOP PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION YIELD-PROPOSITION-RECORD-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-GOAL-JUSTIFICATION"
    "(DEFUN RECORD-GOAL-JUSTIFICATION ((GOAL CONTROL-FRAME) (INFERENCERULE KEYWORD) (ANTECEDENTS (CONS OF JUSTIFICATION))))"
    (CL:FUNCTION RECORD-GOAL-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-PRIMITIVE-JUSTIFICATION"
    "(DEFUN RECORD-PRIMITIVE-JUSTIFICATION ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION RECORD-PRIMITIVE-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-MODUS-PONENS-JUSTIFICATION"
    "(DEFUN RECORD-MODUS-PONENS-JUSTIFICATION ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION RECORD-MODUS-PONENS-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-AND-INTRODUCTION-JUSTIFICATION"
    "(DEFUN RECORD-AND-INTRODUCTION-JUSTIFICATION ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION RECORD-AND-INTRODUCTION-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-OR-INTRODUCTION-JUSTIFICATION"
    "(DEFUN RECORD-OR-INTRODUCTION-JUSTIFICATION ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION RECORD-OR-INTRODUCTION-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-DISPROOF-JUSTIFICATION"
    "(DEFUN RECORD-DISPROOF-JUSTIFICATION ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION RECORD-DISPROOF-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-FAIL-JUSTIFICATION"
    "(DEFUN RECORD-FAIL-JUSTIFICATION ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION RECORD-FAIL-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION"
    "(DEFUN RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-UNHANDLED-JUSTIFICATION"
    "(DEFUN RECORD-UNHANDLED-JUSTIFICATION ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION RECORD-UNHANDLED-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-FAILURE-JUSTIFICATION"
    "(DEFUN RECORD-FAILURE-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION RECORD-FAILURE-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-PRIMITIVE-FAILURE-JUSTIFICATION"
    "(DEFUN RECORD-PRIMITIVE-FAILURE-JUSTIFICATION ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION RECORD-PRIMITIVE-FAILURE-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "FAILED-GOAL-JUSTIFICATION?"
    "(DEFUN (FAILED-GOAL-JUSTIFICATION? BOOLEAN) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION FAILED-GOAL-JUSTIFICATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-FAILED-GOALS"
    "(DEFUN COLLECT-FAILED-GOALS ((PROOF JUSTIFICATION) (FAILURES (LIST OF JUSTIFICATION))))"
    (CL:FUNCTION COLLECT-FAILED-GOALS) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-JUSTIFICATION"
    "(DEFUN (REGISTER-JUSTIFICATION EXPLANATION-INFO) ((SELF JUSTIFICATION) (MAPPING EXPLANATION-MAPPING)))"
    (CL:FUNCTION REGISTER-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-EXPLANATION-INFO"
    "(DEFUN (GET-EXPLANATION-INFO EXPLANATION-INFO) ((SELF JUSTIFICATION) (MAPPING EXPLANATION-MAPPING) (CREATE? BOOLEAN)))"
    (CL:FUNCTION GET-EXPLANATION-INFO) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPLANATION-INFO"
    "(DEFUN (EXPLANATION-INFO EXPLANATION-INFO) ((SELF JUSTIFICATION) (MAPPING EXPLANATION-MAPPING)))"
    (CL:FUNCTION EXPLANATION-INFO) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-JUSTIFICATION"
    "(DEFUN (LOOKUP-JUSTIFICATION JUSTIFICATION) ((MAPPING EXPLANATION-MAPPING) (LABEL STRING)))"
    (CL:FUNCTION LOOKUP-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RESET-MAPPING-FOR-SUBEXPLANATION"
    "(DEFUN RESET-MAPPING-FOR-SUBEXPLANATION ((MAPPING EXPLANATION-MAPPING)))"
    (CL:FUNCTION RESET-MAPPING-FOR-SUBEXPLANATION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-EXPLANATION"
    "(DEFUN (PRINT-EXPLANATION EXPLANATION-MAPPING) ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAPPING EXPLANATION-MAPPING) (MAXDEPTH INTEGER)))"
    (CL:FUNCTION PRINT-EXPLANATION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-ONE-EXPLANATION"
    "(DEFUN PRINT-ONE-EXPLANATION ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAPPING EXPLANATION-MAPPING) (MAXDEPTH INTEGER) (UNEXPLAINED (LIST OF JUSTIFICATION))))"
    (CL:FUNCTION PRINT-ONE-EXPLANATION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINTING-PROPOSITION-RECORD?"
    "(DEFUN (PRINTING-PROPOSITION-RECORD? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (DEFINED? *PROPOSITIONRECORDBINDINGS*)))"
    (CL:FUNCTION PRINTING-PROPOSITION-RECORD?) NULL)
   (DEFINE-FUNCTION-OBJECT "PROPOSITION-RECORD-VALUE-OF"
    "(DEFUN (PROPOSITION-RECORD-VALUE-OF OBJECT) ((SELF PATTERN-VARIABLE)) :GLOBALLY-INLINE? TRUE (RETURN (LOOKUP *PROPOSITIONRECORDBINDINGS* SELF)))"
    (CL:FUNCTION PROPOSITION-RECORD-VALUE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-JUSTIFICATION-PROPOSITION"
    "(DEFUN PRINT-JUSTIFICATION-PROPOSITION ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (INDENT INTEGER)))"
    (CL:FUNCTION PRINT-JUSTIFICATION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-EXPLANATION-HEADER"
    "(DEFUN PRINT-EXPLANATION-HEADER ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAPPING EXPLANATION-MAPPING)))"
    (CL:FUNCTION PRINT-EXPLANATION-HEADER) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-EXPLANATION-TEXT"
    "(DEFUN PRINT-EXPLANATION-TEXT ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAPPING EXPLANATION-MAPPING)))"
    (CL:FUNCTION PRINT-EXPLANATION-TEXT) NULL)
   (DEFINE-FUNCTION-OBJECT "MARK-AS-EXPLICIT-ASSERTION?"
    "(DEFUN (MARK-AS-EXPLICIT-ASSERTION? BOOLEAN) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION MARK-AS-EXPLICIT-ASSERTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "MARK-AS-FAILED-GOAL?"
    "(DEFUN (MARK-AS-FAILED-GOAL? BOOLEAN) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION MARK-AS-FAILED-GOAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "PARTIALLY-FOLLOWS?"
    "(DEFUN (PARTIALLY-FOLLOWS? BOOLEAN) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION PARTIALLY-FOLLOWS?) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-SATELLITE-RULE-EXPLANATION"
    "(DEFUN PRINT-SATELLITE-RULE-EXPLANATION ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAPPING EXPLANATION-MAPPING)))"
    (CL:FUNCTION PRINT-SATELLITE-RULE-EXPLANATION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-EXPLANATION-SUBSTITUTION"
    "(DEFUN PRINT-EXPLANATION-SUBSTITUTION ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAPPING EXPLANATION-MAPPING)))"
    (CL:FUNCTION PRINT-EXPLANATION-SUBSTITUTION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-EXPLANATION-ANTECEDENTS"
    "(DEFUN PRINT-EXPLANATION-ANTECEDENTS ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAPPING EXPLANATION-MAPPING) (MAXDEPTH INTEGER) (UNEXPLAINED (LIST OF JUSTIFICATION))))"
    (CL:FUNCTION PRINT-EXPLANATION-ANTECEDENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "VISIBLE-JUSTIFICATION"
    "(DEFUN (VISIBLE-JUSTIFICATION JUSTIFICATION) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION VISIBLE-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "VISIBLE-ANTECEDENTS"
    "(DEFUN (VISIBLE-ANTECEDENTS (LIST OF JUSTIFICATION)) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION VISIBLE-ANTECEDENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-VISIBLE-ANTECEDENTS"
    "(DEFUN COLLECT-VISIBLE-ANTECEDENTS ((SELF JUSTIFICATION) (VISIBLEANTECEDENTS (LIST OF JUSTIFICATION))))"
    (CL:FUNCTION COLLECT-VISIBLE-ANTECEDENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "WHY"
    "(DEFUN WHY (|&REST| (ARGS OBJECT)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Print an explanation for the result of the most recent query.
Without any arguments, `why' prints an explanation of the top level
query proposition down to a maximum depth of 3.  `(why all)' prints
an explanation to unlimited depth.  Alternatively, a particular depth
can be specified, for example, `(why 5)' explains down to a depth of 5.
A proof step that was not explained explicitly (e.g., due to a depth
cutoff) can be explained by supplying the label of the step as the
first argument to `why', for example, `(why 1.2.3 5)' prints an explanation
starting at 1.2.3 down to a depth of 5 (which is counted relative to the
depth of the starting point).  The keywords `brief' and `verbose' can be
used to select a particular explanation style.  In brief mode, explicitly
asserted propositions are not further explained and indicated with a
`!' assertion marker.  Additionally, relatively uninteresting proof steps
such as AND-introductions are skipped.  This explanation style option is
sticky and will affect future calls to `why' until it gets changed again.
The various options can be combined in any way, for example,
`(why 1.2.3 brief 3)' explains starting from step 1.2.3 down to a depth
of 3 in brief explanation mode.\")" (CL:FUNCTION %WHY)
    (CL:FUNCTION WHY-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "COMMAND-OPTION-EQL?"
    "(DEFUN (COMMAND-OPTION-EQL? BOOLEAN) ((ARG OBJECT) (OPTION STRING)))"
    (CL:FUNCTION COMMAND-OPTION-EQL?) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-WHY-ARGUMENTS"
    "(DEFUN (PARSE-WHY-ARGUMENTS STRING KEYWORD INTEGER) ((ARGS (CONS OF OBJECT))))"
    (CL:FUNCTION PARSE-WHY-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "DERIVE-JUSTIFIED-PARTIAL-QUERY"
    "(DEFUN (DERIVE-JUSTIFIED-PARTIAL-QUERY QUERY-ITERATOR) ((QUERY QUERY-ITERATOR)))"
    (CL:FUNCTION DERIVE-JUSTIFIED-PARTIAL-QUERY) NULL)
   (DEFINE-FUNCTION-OBJECT "WHYNOT"
    "(DEFUN WHYNOT (|&REST| (ARGS OBJECT)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %WHYNOT) (CL:FUNCTION WHYNOT-EVALUATOR-WRAPPER))
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT PROPOSITION FORWARD-CHAINING-GOALS :TYPE (LIST OF FORWARD-GOAL-RECORD) :ALLOCATION :DYNAMIC)")
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DELETED? BOOLEAN) ((SELF FORWARD-GOAL-RECORD)))"
    (CL:FUNCTION DELETED?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DELETED?-SETTER BOOLEAN) ((SELF FORWARD-GOAL-RECORD) (VALUE BOOLEAN)))"
    (CL:FUNCTION DELETED?-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-FORWARD-GOAL"
    "(DEFUN RECORD-FORWARD-GOAL ((FORWARDRULE PROPOSITION) (ARGUMENTS ARGUMENTS-VECTOR) (CONSEQUENTPROPOSITION PROPOSITION)))"
    (CL:FUNCTION RECORD-FORWARD-GOAL) NULL)
   (DEFINE-FUNCTION-OBJECT "PREDICATION?"
    "(DEFUN (PREDICATION? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION PREDICATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERTED-AS-TRUE?"
    "(DEFUN (ASSERTED-AS-TRUE? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION ASSERTED-AS-TRUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "ELABORATION-RULE?"
    "(DEFUN (ELABORATION-RULE? BOOLEAN) ((CONSEQUENTPROPOSITION PROPOSITION) (FORWARDRULE PROPOSITION) (ARGUMENTS ARGUMENTS-VECTOR)))"
    (CL:FUNCTION ELABORATION-RULE?) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-FORWARD-GOALS"
    "(DEFUN (GET-FORWARD-GOALS (LIST OF FORWARD-GOAL-RECORD)) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION GET-FORWARD-GOALS) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT PROPOSITION FORWARD-JUSTIFICATIONS :TYPE (LIST OF FORWARD-JUSTIFICATION) :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "CREATE-FORWARD-JUSTIFICATION"
    "(DEFUN (CREATE-FORWARD-JUSTIFICATION FORWARD-JUSTIFICATION) ((CONSEQUENTPROPOSITION PROPOSITION) (FORWARDRULE PROPOSITION) (ANTECEDENTS (CONS OF PROPOSITION))))"
    (CL:FUNCTION CREATE-FORWARD-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-FORWARD-JUSTIFICATION"
    "(DEFUN RECORD-FORWARD-JUSTIFICATION ((CONSEQUENTPROPOSITION PROPOSITION) (FORWARDRULE PROPOSITION) (ANTECEDENTS (CONS OF PROPOSITION))))"
    (CL:FUNCTION RECORD-FORWARD-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-HOLDS-BY-DEFAULT"
    "(DEFUN RECORD-HOLDS-BY-DEFAULT ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION RECORD-HOLDS-BY-DEFAULT) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-JUSTIFICATIONS"
    "(DEFUN STARTUP-JUSTIFICATIONS () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-JUSTIFICATIONS) NULL)
   (CL:LET*
    ((FUNCTION
      (LOOKUP-FUNCTION SYM-JUSTIFICATIONS-LOGIC-STARTUP-JUSTIFICATIONS)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-JUSTIFICATIONS-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "Startup-Justifications") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-JUSTIFICATIONS ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-JUSTIFICATIONS1)
    (HELP-STARTUP-JUSTIFICATIONS2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *EXPLANATION-STYLE* KWD-JUSTIFICATIONS-BRIEF))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (HELP-STARTUP-JUSTIFICATIONS3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (HELP-STARTUP-JUSTIFICATIONS4))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *RECORD-JUSTIFICATIONS?* BOOLEAN FALSE :DOCUMENTATION \"If TRUE every query records justifications to enable
the explanation of concluded results.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MOST-RECENT-FAILED-FRAME* CONTROL-FRAME NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EXPLANATION-STYLE* KEYWORD :BRIEF :DOCUMENTATION \"Keywords that controls how detailed explanations will be.
Valid values are :VERBOSE and :BRIEF.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEFAULT-EXPLANATION-DEPTH* INTEGER 3 :DOCUMENTATION \"Maximal explanation depth used if not otherwise specified.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EXPLANATION-TAB-STRING* STRING \"    \")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAX-INLINE-LABEL-LENGTH* INTEGER 10 :DOCUMENTATION \"Maximum length of a label string for which the following
proposition will be printed on the same line.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EXPLANATION-ASSERTION-MARKER* STRING \"!\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EXPLANATION-FAILURE-MARKER* STRING \"?\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PROPOSITIONRECORDBINDINGS* ENTITY-MAPPING NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MOST-RECENT-EXPLANATION-MAPPING* EXPLANATION-MAPPING NULL)")
    (REGISTER-NATIVE-NAME SYM-JUSTIFICATIONS-LOGIC-WHY
     KWD-JUSTIFICATIONS-COMMON-LISP KWD-JUSTIFICATIONS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-JUSTIFICATIONS-LOGIC-WHYNOT
     KWD-JUSTIFICATIONS-COMMON-LISP KWD-JUSTIFICATIONS-FUNCTION))))
