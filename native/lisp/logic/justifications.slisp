;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; justifications.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2014      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-BACKWARD NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-SUBSTITUTION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-REVERSE-POLARITY? NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-TRUTH-VALUE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-POSITIVE-SCORE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-NEGATIVE-SCORE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-STRATEGY NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-UP-TRUE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-UP-FAIL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FAILURE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SCAN-COLLECTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-TECHNICAL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-LAY NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SPECIALIST NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-COMPUTED-PREDICATE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-GOAL-COMPLEMENT NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-EQUIVALENCE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SUBSUMPTION-TEST NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SUBSUMPTION-REASONING NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-PATTERN NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-STELLA-KEY-VALUE-LIST NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-AND-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-MODUS-TOLLENS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-MODUS-PONENS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS-RULE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-NOT NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-AMPLIFICATION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-ARGUMENTS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-PARTIAL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-REVERSE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-OR-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-DISPROOF NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FAIL-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-NEGATED-FAIL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FAIL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-TIMEOUT NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-DEPTH-CUTOFF NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-RAW NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-INFERENCE-RULE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-STRATEGY NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-TRUTH-VALUE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-POSITIVE-SCORE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SUBSTITUTION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-NOT NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-HOW-MANY NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-NONE NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-FORWARD-GOAL-RECORD NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-GOAL NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-RULE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-PREDICATE NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FORWARD NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FORWARD-INFERENCE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-IMPLIES NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-DESCRIPTION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-PL-KERNEL-KB-SUBSET-OF NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-CLASH-JUSTIFICATION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-DIRECTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-CLASH NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-STARTUP-JUSTIFICATIONS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* INCONSISTENT-TRUTH-VALUE TRUE-TRUTH-VALUE *CONTEXT* *MODULE* *REVERSEPOLARITY?*
  NIL-LIST NULL-INTEGER UNKNOWN-TRUTH-VALUE STANDARD-OUTPUT EOL *QUERYITERATOR* *CURRENTJUSTIFICATION* TRUE-WRAPPER
  FALSE-WRAPPER NULL-FLOAT NIL))

(CL:DEFUN NEW-JUSTIFICATION ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-JUSTIFICATION)) (CL:SETF (%JUSTIFICATION.NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%JUSTIFICATION.POSITIVE-SCORE SELF) NULL-FLOAT) (CL:SETF (%JUSTIFICATION.TRUTH-VALUE SELF) NULL)
   (CL:SETF (%JUSTIFICATION.REVERSE-POLARITY? SELF) CL:NIL) (CL:SETF (%JUSTIFICATION.SUBSTITUTION SELF) NULL)
   (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF) NIL) (CL:SETF (%JUSTIFICATION.PROPOSITION SELF) NULL)
   (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF JUSTIFICATION))
  SGT-JUSTIFICATIONS-LOGIC-JUSTIFICATION)

(CL:DEFMETHOD INFERENCE-STRATEGY ((SELF JUSTIFICATION))
  NULL)

(CL:DEFMETHOD INFERENCE-DIRECTION ((SELF JUSTIFICATION))
  KWD-JUSTIFICATIONS-BACKWARD)

(CL:DEFUN ACCESS-JUSTIFICATION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.INFERENCE-RULE SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.ANTECEDENTS SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-SUBSTITUTION)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.SUBSTITUTION SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.SUBSTITUTION SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-REVERSE-POLARITY?)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.REVERSE-POLARITY? SELF) (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE (CL:IF (%JUSTIFICATION.REVERSE-POLARITY? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-TRUTH-VALUE)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.TRUTH-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION.TRUTH-VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-POSITIVE-SCORE)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.POSITIVE-SCORE SELF) (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%JUSTIFICATION.POSITIVE-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-NEGATIVE-SCORE)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION.NEGATIVE-SCORE SELF) (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%JUSTIFICATION.NEGATIVE-SCORE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFUN NEW-PRIMITIVE-STRATEGY ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-PRIMITIVE-STRATEGY))
   (CL:SETF (%PRIMITIVE-STRATEGY.NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%PRIMITIVE-STRATEGY.POSITIVE-SCORE SELF) NULL-FLOAT) (CL:SETF (%PRIMITIVE-STRATEGY.TRUTH-VALUE SELF) NULL)
   (CL:SETF (%PRIMITIVE-STRATEGY.REVERSE-POLARITY? SELF) CL:NIL) (CL:SETF (%PRIMITIVE-STRATEGY.SUBSTITUTION SELF) NULL)
   (CL:SETF (%PRIMITIVE-STRATEGY.ANTECEDENTS SELF) NIL) (CL:SETF (%PRIMITIVE-STRATEGY.PROPOSITION SELF) NULL)
   (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF) NULL)
   (CL:SETF (%PRIMITIVE-STRATEGY.INFERENCE-RULE SELF) KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PRIMITIVE-STRATEGY))
  SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY)

(CL:DEFMETHOD INFERENCE-STRATEGY ((SELF PRIMITIVE-STRATEGY))
  (%PRIMITIVE-STRATEGY.STRATEGY SELF))

(CL:DEFUN ACCESS-PRIMITIVE-STRATEGY-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE)
    (CL:IF SETVALUE? (CL:SETF (%PRIMITIVE-STRATEGY.INFERENCE-RULE SELF) VALUE)
     (CL:SETQ VALUE (%PRIMITIVE-STRATEGY.INFERENCE-RULE SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-STRATEGY)
    (CL:IF SETVALUE? (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF) VALUE)
     (CL:SETQ VALUE (%PRIMITIVE-STRATEGY.STRATEGY SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (JUSTIFICATION-ARGUMENT-BOUND-TO OBJECT) ...)

(CL:DEFUN JUSTIFICATION-ARGUMENT-BOUND-TO (ARGUMENT JUSTIFICATION)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARGUMENT) SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
    (CL:PROGN (CL:WHEN (CL:EQ JUSTIFICATION NULL) (CL:SETQ JUSTIFICATION *CURRENTJUSTIFICATION*))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ JUSTIFICATION NULL)) (CL:NOT (CL:EQ (%JUSTIFICATION.SUBSTITUTION JUSTIFICATION) NULL)))
      (CL:RETURN-FROM JUSTIFICATION-ARGUMENT-BOUND-TO (LOOKUP (%JUSTIFICATION.SUBSTITUTION JUSTIFICATION) ARGUMENT)))))
   (CL:T (CL:RETURN-FROM JUSTIFICATION-ARGUMENT-BOUND-TO ARGUMENT)))
  NULL)

;;; (DEFUN (JUSTIFICATION-EQL? BOOLEAN) ...)

(CL:DEFUN JUSTIFICATION-EQL? (JUST1 JUST2)
  (CL:OR (CL:EQ JUST1 JUST2)
   (CL:AND (CL:EQ (%JUSTIFICATION.INFERENCE-RULE JUST1) (%JUSTIFICATION.INFERENCE-RULE JUST2))
    (CL:EQ (%JUSTIFICATION.REVERSE-POLARITY? JUST1) (%JUSTIFICATION.REVERSE-POLARITY? JUST2))
    (CL:OR
     (CL:AND (CL:NOT (CL:EQ (%JUSTIFICATION.INFERENCE-RULE JUST1) KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY))
      (CL:NOT (CL:EQ (%JUSTIFICATION.INFERENCE-RULE JUST2) KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY)))
     (CL:EQ (%PRIMITIVE-STRATEGY.STRATEGY JUST1) (%PRIMITIVE-STRATEGY.STRATEGY JUST2)))
    (JUSTIFICATION-PROPOSITIONS-EQL? (%JUSTIFICATION.PROPOSITION JUST1) JUST1 (%JUSTIFICATION.PROPOSITION JUST2)
     JUST2))))

;;; (DEFUN (JUSTIFICATION-PROPOSITIONS-EQL? BOOLEAN) ...)

(CL:DEFUN JUSTIFICATION-PROPOSITIONS-EQL? (PROPOSITION1 JUST1 PROPOSITION2 JUST2)
  (CL:WHEN
   (CL:AND (CL:EQ (%PROPOSITION.OPERATOR PROPOSITION1) (%PROPOSITION.OPERATOR PROPOSITION2))
    (CL:= (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION1)) (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION2))))
   (CL:LET*
    ((ARG1 NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION1)) (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
     (ARG2 NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS PROPOSITION2)) (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
    (CL:LOOP WHILE (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
     (CL:SETQ ARG1 (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000)) INDEX-000))
     (CL:SETQ ARG2 (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001)) INDEX-001))
     (CL:WHEN (CL:OR (CL:NOT (EQL? ARG1 ARG2)) (VARIABLE? ARG1))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG1)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-JUSTIFICATIONS-LOGIC-PROPOSITION)
         (CL:PROGN
          (CL:WHEN
           (CL:NOT
            (CL:AND (ISA? ARG2 SGT-JUSTIFICATIONS-LOGIC-PROPOSITION)
             (JUSTIFICATION-PROPOSITIONS-EQL? ARG1 JUST1 ARG2 JUST2)))
           (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:NIL))))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
         (CL:PROGN
          (CL:COND
           ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARG2) SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
            (CL:PROGN
             (CL:LET*
              ((VALUE1 (JUSTIFICATION-ARGUMENT-BOUND-TO ARG1 JUST1))
               (VALUE2 (JUSTIFICATION-ARGUMENT-BOUND-TO ARG2 JUST2)))
              (CL:WHEN (CL:OR (CL:EQ VALUE1 NULL) (CL:EQ VALUE2 NULL) (CL:NOT (EQL? VALUE1 VALUE2)))
               (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:NIL)))))
           (CL:T
            (CL:WHEN (CL:NOT (EQL? (JUSTIFICATION-ARGUMENT-BOUND-TO ARG1 JUST1) ARG2))
             (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:NIL))))))
        (CL:T
         (CL:COND
          ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARG2) SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
           (CL:PROGN
            (CL:WHEN (CL:NOT (EQL? (JUSTIFICATION-ARGUMENT-BOUND-TO ARG2 JUST2) ARG1))
             (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:NIL))))
          (CL:T (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:NIL)))))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000)) (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
   (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:T))
  CL:NIL)

;;; (DEFMETHOD (COPY (LIKE SELF)) ...)

(CL:DEFMETHOD COPY ((SELF JUSTIFICATION))
  "Return a copy of the proof starting at `self'.  Allocates
all new justification objects, but structure-shares other information such
as propositions and substitutions."
  (CL:LET* ((COPY NULL) (ANTECEDENTS NIL))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF) SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY)
     (CL:PROGN
      (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY)))
       (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-000) (%PRIMITIVE-STRATEGY.STRATEGY SELF)) (CL:SETQ COPY SELF-000))))
    (CL:T (CL:SETQ COPY (NEW-JUSTIFICATION))))
   (CL:SETF (%JUSTIFICATION.INFERENCE-RULE COPY) (%JUSTIFICATION.INFERENCE-RULE SELF))
   (CL:SETF (%JUSTIFICATION.PROPOSITION COPY) (%JUSTIFICATION.PROPOSITION SELF))
   (CL:SETF (%JUSTIFICATION.SUBSTITUTION COPY) (%JUSTIFICATION.SUBSTITUTION SELF))
   (CL:SETF (%JUSTIFICATION.REVERSE-POLARITY? COPY) (%JUSTIFICATION.REVERSE-POLARITY? SELF))
   (CL:SETF (%JUSTIFICATION.TRUTH-VALUE COPY) (%JUSTIFICATION.TRUTH-VALUE SELF))
   (CL:SETF (%JUSTIFICATION.POSITIVE-SCORE COPY) (%JUSTIFICATION.POSITIVE-SCORE SELF))
   (CL:SETF (%JUSTIFICATION.NEGATIVE-SCORE COPY) (%JUSTIFICATION.NEGATIVE-SCORE SELF))
   (CL:LET* ((ANTECEDENT NULL) (ITER-000 (%JUSTIFICATION.ANTECEDENTS SELF)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO (CL:SETQ ANTECEDENT (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (COPY ANTECEDENT) NIL))
       (CL:IF (CL:EQ ANTECEDENTS NIL) (CL:SETQ ANTECEDENTS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST ANTECEDENTS COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS (COPY ANTECEDENT) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETF (%JUSTIFICATION.ANTECEDENTS COPY) ANTECEDENTS) COPY))

;;; (DEFMETHOD (SHALLOW-COPY (LIKE SELF)) ...)

(CL:DEFMETHOD SHALLOW-COPY ((SELF JUSTIFICATION))
  "Similar to `copy' but does not copy antecedent justifications."
  (CL:LET* ((COPY NULL) (ANTECEDENTS NIL))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF) SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY)
     (CL:PROGN
      (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY)))
       (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-000) (%PRIMITIVE-STRATEGY.STRATEGY SELF)) (CL:SETQ COPY SELF-000))))
    (CL:T (CL:SETQ COPY (NEW-JUSTIFICATION))))
   (CL:SETF (%JUSTIFICATION.INFERENCE-RULE COPY) (%JUSTIFICATION.INFERENCE-RULE SELF))
   (CL:SETF (%JUSTIFICATION.PROPOSITION COPY) (%JUSTIFICATION.PROPOSITION SELF))
   (CL:SETF (%JUSTIFICATION.SUBSTITUTION COPY) (%JUSTIFICATION.SUBSTITUTION SELF))
   (CL:SETF (%JUSTIFICATION.REVERSE-POLARITY? COPY) (%JUSTIFICATION.REVERSE-POLARITY? SELF))
   (CL:SETF (%JUSTIFICATION.TRUTH-VALUE COPY) (%JUSTIFICATION.TRUTH-VALUE SELF))
   (CL:SETF (%JUSTIFICATION.POSITIVE-SCORE COPY) (%JUSTIFICATION.POSITIVE-SCORE SELF))
   (CL:SETF (%JUSTIFICATION.NEGATIVE-SCORE COPY) (%JUSTIFICATION.NEGATIVE-SCORE SELF))
   (CL:LET* ((ANTECEDENT NULL) (ITER-000 (%JUSTIFICATION.ANTECEDENTS SELF)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO (CL:SETQ ANTECEDENT (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS ANTECEDENT NIL))
       (CL:IF (CL:EQ ANTECEDENTS NIL) (CL:SETQ ANTECEDENTS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST ANTECEDENTS COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ANTECEDENT NIL)) (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETF (%JUSTIFICATION.ANTECEDENTS COPY) ANTECEDENTS) COPY))

;;; (DEFSPECIAL *RECORD-JUSTIFICATIONS?* ...)

(CL:DEFVAR *RECORD-JUSTIFICATIONS?* CL:NIL
  "If TRUE every query records justifications to enable
the explanation of concluded results.")

;;; (DEFUN (RECORD-JUSTIFICATIONS? BOOLEAN) ...)

(CL:DEFUN RECORD-JUSTIFICATIONS? ()
  "Return TRUE if every query records justifications to enable
the explanation of concluded results."
  *RECORD-JUSTIFICATIONS?*)

;;; (DEFUN RECORD-GOAL-JUSTIFICATION ...)

(CL:DEFUN RECORD-GOAL-JUSTIFICATION (GOAL JUSTIFICATION)
  (CL:WHEN (CL:EQ (%JUSTIFICATION.PROPOSITION JUSTIFICATION) NULL)
   (CL:SETF (%JUSTIFICATION.PROPOSITION JUSTIFICATION) (%CONTROL-FRAME.PROPOSITION GOAL)))
  (CL:SETF (%JUSTIFICATION.REVERSE-POLARITY? JUSTIFICATION) (%CONTROL-FRAME.REVERSE-POLARITY? GOAL))
  (CL:SETF (%JUSTIFICATION.TRUTH-VALUE JUSTIFICATION) (%CONTROL-FRAME.TRUTH-VALUE GOAL))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
    (CL:NOT (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
   (SET-JUSTIFICATION-PARTIAL-TRUTH GOAL JUSTIFICATION))
  (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS GOAL) SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION JUSTIFICATION NULL))

;;; (DEFUN RECORD-PRIMITIVE-JUSTIFICATION ...)

(CL:DEFUN RECORD-PRIMITIVE-JUSTIFICATION (FRAME LASTMOVE)
  (CL:COND
   ((CL:OR (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE) (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL))
    (CL:LET*
     ((STRATEGY
       (CL:IF (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL) KWD-JUSTIFICATIONS-FAILURE
        (%CONTROL-FRAME.CURRENT-STRATEGY FRAME)))
      (JUSTIFICATION NULL))
     (CL:COND
      ((CL:AND (CL:NOT (CL:EQ (%CONTROL-FRAME.JUSTIFICATIONS FRAME) NULL))
        (CL:NOT (EMPTY? (%CONTROL-FRAME.JUSTIFICATIONS FRAME))))
       (CL:SETQ JUSTIFICATION (FIRST (%CONTROL-FRAME.JUSTIFICATIONS FRAME))))
      ((CL:NOT (CL:EQ (%CONTROL-FRAME.RESULT FRAME) NULL))
       (CL:COND
        ((CL:NOT
          (CL:EQ
           (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS (%CONTROL-FRAME.RESULT FRAME))
            SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
           NULL))
         (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY))) (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-000) STRATEGY)
          (CL:SETF (%PRIMITIVE-STRATEGY.ANTECEDENTS SELF-000)
           (CONS
            (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS (%CONTROL-FRAME.RESULT FRAME))
             SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
            NIL))
          (CL:SETQ JUSTIFICATION SELF-000)))
        ((CL:AND (CL:NOT (CL:EQ (%CONTROL-FRAME.PROPOSITION (%CONTROL-FRAME.RESULT FRAME)) NULL))
          (NON-EMPTY? (FORWARD-JUSTIFICATIONS (%CONTROL-FRAME.PROPOSITION (%CONTROL-FRAME.RESULT FRAME)))))
         (CL:SETQ JUSTIFICATION
          (FIRST (FORWARD-JUSTIFICATIONS (%CONTROL-FRAME.PROPOSITION (%CONTROL-FRAME.RESULT FRAME))))))))
      ((CL:AND (CL:NOT (CL:EQ (%CONTROL-FRAME.PROPOSITION FRAME) NULL))
        (NON-EMPTY? (FORWARD-JUSTIFICATIONS (%CONTROL-FRAME.PROPOSITION FRAME))))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "RECORD-PRIMITIVE-JUSTIFICATION:  Test to see if clause needed." EOL)
       (CL:SETQ JUSTIFICATION (FIRST (FORWARD-JUSTIFICATIONS (%CONTROL-FRAME.PROPOSITION FRAME)))))
      (CL:T))
     (CL:WHEN (CL:EQ JUSTIFICATION NULL)
      (CL:LET* ((SELF-001 (NEW-PRIMITIVE-STRATEGY))) (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-001) STRATEGY)
       (CL:SETQ JUSTIFICATION SELF-001)))
     (RECORD-GOAL-JUSTIFICATION FRAME JUSTIFICATION)))
   (CL:T)))

;;; (DEFUN RECORD-PATTERN-JUSTIFICATION ...)

(CL:DEFUN RECORD-PATTERN-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET*
   ((ARGUMENT (%CONTROL-FRAME.RESULT FRAME))
    (JUSTIFICATION
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME) SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)))
   (CL:COND
    ((CL:OR (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE) (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL))
     (CL:WHEN
      (CL:EQ (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS ARGUMENT) SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
       NULL)
      (CL:RETURN-FROM RECORD-PATTERN-JUSTIFICATION))
     (CL:WHEN (CL:EQ JUSTIFICATION NULL)
      (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
       (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-PATTERN)
       (RECORD-GOAL-JUSTIFICATION FRAME SELF-000))
      (CL:SETQ JUSTIFICATION
       (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME) SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)))
     (CL:LET*
      ((SUBSTITUTION (NEW-KEY-VALUE-MAP)) (PATTERNRECORD (%CONTROL-FRAME.PATTERN-RECORD FRAME)) (DESCRIPTION NULL)
       (COLLECTIONFRAME? CL:NIL))
      (CL:WHEN (CL:NOT (CL:EQ PATTERNRECORD NULL))
       (CL:SETQ COLLECTIONFRAME? (CL:NOT (CL:EQ (%PATTERN-RECORD.COLLECTION-LIST PATTERNRECORD) NULL)))
       (CL:SETQ DESCRIPTION (%PATTERN-RECORD.OPTIMAL-PATTERN PATTERNRECORD))
       (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
        (CL:LET*
         ((VBL NULL) (VECTOR-000 (%DESCRIPTION.IO-VARIABLES DESCRIPTION)) (INDEX-000 0)
          (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:SETQ VBL (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000)) INDEX-000))
          (INSERT-AT SUBSTITUTION VBL
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY
              (%PATTERN-RECORD.VARIABLE-BINDINGS (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
            (CL:THE CL:FIXNUM (%PATTERN-VARIABLE.BOUND-TO-OFFSET VBL))))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
        (CL:LET*
         ((VBL NULL) (VECTOR-001 (%DESCRIPTION.INTERNAL-VARIABLES DESCRIPTION)) (INDEX-001 0)
          (LENGTH-001 (LENGTH VECTOR-001)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
         (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
          (CL:SETQ VBL (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001)) INDEX-001))
          (INSERT-AT SUBSTITUTION VBL
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY
              (%PATTERN-RECORD.VARIABLE-BINDINGS (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
            (CL:THE CL:FIXNUM (%PATTERN-VARIABLE.BOUND-TO-OFFSET VBL))))
          (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))))
      (CL:WHEN (ISA? SUBSTITUTION SGT-JUSTIFICATIONS-STELLA-KEY-VALUE-LIST)
       (CL:LET* ((OLDSUBSTITUTION SUBSTITUTION)) (CL:SETQ SUBSTITUTION (NEW-KEY-VALUE-MAP))
        (CL:LET* ((KEY NULL) (VAL NULL) (ITER-000 (ALLOCATE-ITERATOR OLDSUBSTITUTION)))
         (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ KEY (%DICTIONARY-ITERATOR.KEY ITER-000))
          (CL:SETQ VAL (%DICTIONARY-ITERATOR.VALUE ITER-000)) (INSERT-AT SUBSTITUTION KEY VAL)))))
      (CL:SETF (%JUSTIFICATION.SUBSTITUTION JUSTIFICATION) SUBSTITUTION)
      (CL:LET*
       ((ANTECEDENT
         (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS ARGUMENT) SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)))
       (CL:WHEN COLLECTIONFRAME?
        (CL:SETF (%JUSTIFICATION.INFERENCE-RULE JUSTIFICATION) KWD-JUSTIFICATIONS-AND-INTRODUCTION)
        (CL:LET* ((PATTERNCOPY NULL))
         (CL:LET* ((SELF-003 (NEW-JUSTIFICATION)))
          (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-003) KWD-JUSTIFICATIONS-PATTERN)
          (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-003) (CONS ANTECEDENT NIL))
          (RECORD-GOAL-JUSTIFICATION FRAME SELF-003))
         (CL:SETQ PATTERNCOPY
          (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME) SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL))
         (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME) SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION
          JUSTIFICATION NULL)
         (BACKLINK-TO-PATTERN-JUSTIFICATION ANTECEDENT PATTERNCOPY)
         (BACKLINK-TO-PATTERN-JUSTIFICATION PATTERNCOPY JUSTIFICATION)
         (CL:SETF (%JUSTIFICATION.SUBSTITUTION PATTERNCOPY) SUBSTITUTION)
         (CL:SETF (%JUSTIFICATION.SUBSTITUTION JUSTIFICATION) NULL) (CL:SETQ ANTECEDENT PATTERNCOPY)))
       (CL:SETF (%JUSTIFICATION.ANTECEDENTS JUSTIFICATION)
        (CONS ANTECEDENT (%JUSTIFICATION.ANTECEDENTS JUSTIFICATION)))
       (CL:WHEN (CL:NOT COLLECTIONFRAME?) (BACKLINK-TO-PATTERN-JUSTIFICATION ANTECEDENT JUSTIFICATION)))))
    (CL:T))))

;;; (DEFUN BACKLINK-TO-PATTERN-JUSTIFICATION ...)

(CL:DEFUN BACKLINK-TO-PATTERN-JUSTIFICATION (JUSTIFICATION PATTERN)
  (CL:WHEN (CL:EQ (%JUSTIFICATION.SUBSTITUTION JUSTIFICATION) NULL)
   (CL:SETF (%JUSTIFICATION.SUBSTITUTION JUSTIFICATION) (%JUSTIFICATION.SUBSTITUTION PATTERN))
   (CL:LET* ((ANTECEDENT NULL) (ITER-000 (%JUSTIFICATION.ANTECEDENTS JUSTIFICATION)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO (CL:SETQ ANTECEDENT (%%VALUE ITER-000))
     (BACKLINK-TO-PATTERN-JUSTIFICATION ANTECEDENT PATTERN) (CL:SETQ ITER-000 (%%REST ITER-000))))))

;;; (DEFUN RECORD-MODUS-PONENS-JUSTIFICATION ...)

(CL:DEFUN RECORD-MODUS-PONENS-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET* ((ANTECEDENT (%CONTROL-FRAME.RESULT FRAME)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:LET*
      ((GOAL (EXTRACT-SUBGOAL-OF-FRAME FRAME)) (REVERSEPOLARITY? (%CONTROL-FRAME.REVERSE-POLARITY? FRAME))
       (INFERENCERULE (CL:IF REVERSEPOLARITY? KWD-JUSTIFICATIONS-MODUS-TOLLENS KWD-JUSTIFICATIONS-MODUS-PONENS))
       (RULE (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME) SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS-RULE NULL))
       (RULECONSEQUENT
        (%DESCRIPTION.PROPOSITION
         (CL:IF (CL:EQ INFERENCERULE KWD-JUSTIFICATIONS-MODUS-PONENS)
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS RULE))) 1)
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS RULE))) 0))))
       (INVERTED? (CL:EQ (%PROPOSITION.KIND RULECONSEQUENT) KWD-JUSTIFICATIONS-NOT)))
      (CL:LET* ((SELF-000 (NEW-JUSTIFICATION))) (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000) INFERENCERULE)
       (CL:SETF (%JUSTIFICATION.PROPOSITION SELF-000) GOAL)
       (CL:LET* ((SELF-001 (NEW-PRIMITIVE-STRATEGY)))
        (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-001) KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS)
        (CL:SETF (%PRIMITIVE-STRATEGY.PROPOSITION SELF-001) RULE)
        (CL:SETF (%PRIMITIVE-STRATEGY.TRUTH-VALUE SELF-001)
         (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE RULE) (%PROPOSITION.HOME-CONTEXT RULE) CL:NIL))
        (CL:SETF (%PRIMITIVE-STRATEGY.POSITIVE-SCORE SELF-001)
         (%TRUTH-VALUE.POSITIVE-SCORE
          (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE RULE) (%PROPOSITION.HOME-CONTEXT RULE) CL:NIL)))
        (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-000)
         (CONS SELF-001
          (CONS
           (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS ANTECEDENT) SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
           NIL))))
       (CL:LET* ((JUSTIFICATION SELF-000)) (RECORD-GOAL-JUSTIFICATION FRAME JUSTIFICATION)
        (CL:SETF (%JUSTIFICATION.REVERSE-POLARITY? JUSTIFICATION)
         (CL:IF REVERSEPOLARITY? (CL:NOT INVERTED?) INVERTED?))))))
    (CL:T))))

;;; (DEFUN RECORD-AND-INTRODUCTION-JUSTIFICATION ...)

(CL:DEFUN RECORD-AND-INTRODUCTION-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET*
   ((CONJUNCTS (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME) SYM-JUSTIFICATIONS-STELLA-ARGUMENTS NULL))
    (ANTECEDENTS NIL))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:LET*
      ((CONJUNCT NULL) (VECTOR-000 CONJUNCTS) (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ CONJUNCT (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000)) INDEX-000)) (CL:PROGN)
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-000
          (CONS
           (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS CONJUNCT) SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
           NIL))
         (CL:IF (CL:EQ ANTECEDENTS NIL) (CL:SETQ ANTECEDENTS COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST ANTECEDENTS COLLECT-000)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-000)
          (CONS
           (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS CONJUNCT) SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
           NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-AND-INTRODUCTION)
      (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-000) ANTECEDENTS) (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
    (CL:T))))

;;; (DEFUN RECORD-OR-INTRODUCTION-JUSTIFICATION ...)

(CL:DEFUN RECORD-OR-INTRODUCTION-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET* ((DISJUNCT (%CONTROL-FRAME.RESULT FRAME)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-OR-INTRODUCTION)
      (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-000)
       (CONS (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS DISJUNCT) SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
        NIL))
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
    (CL:T))))

;;; (DEFUN RECORD-DISPROOF-JUSTIFICATION ...)

(CL:DEFUN RECORD-DISPROOF-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET* ((ARGUMENT (%CONTROL-FRAME.RESULT FRAME)))
   (CL:COND
    ((CL:OR (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE) (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL))
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-DISPROOF)
      (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-000)
       (CONS (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS ARGUMENT) SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
        NIL))
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
    (CL:T))))

;;; (DEFUN RECORD-FAIL-JUSTIFICATION ...)

(CL:DEFUN RECORD-FAIL-JUSTIFICATION (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL)
    (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
     (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-FAIL-INTRODUCTION)
     (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
   (CL:T)))

;;; (DEFUN RECORD-NEGATED-FAIL-JUSTIFICATION ...)

(CL:DEFUN RECORD-NEGATED-FAIL-JUSTIFICATION (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
    (CL:LET* ((ANTECEDENT NULL))
     (CL:WHEN (CL:NOT (CL:EQ (%CONTROL-FRAME.RESULT FRAME) NULL))
      (CL:SETQ ANTECEDENT
       (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS (%CONTROL-FRAME.RESULT FRAME))
        SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)))
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-NEGATED-FAIL)
      (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-000) (CONS ANTECEDENT NIL))
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000))))
   (CL:T)))

;;; (DEFUN RECORD-CLOSED-NOT-JUSTIFICATION ...)

(CL:DEFUN RECORD-CLOSED-NOT-JUSTIFICATION (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL)
    (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
     (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION)
     (CL:SETF (%JUSTIFICATION.PROPOSITION SELF-000)
      (CL:IF (CL:EQ (%PROPOSITION.KIND (%CONTROL-FRAME.PROPOSITION FRAME)) KWD-JUSTIFICATIONS-FAIL)
       (%CONTROL-FRAME.PROPOSITION (%CONTROL-FRAME.UP FRAME)) (%CONTROL-FRAME.PROPOSITION FRAME)))
     (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
   (CL:T)))

;;; (DEFUN RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION ...)

(CL:DEFUN RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET* ((ARGUMENT (%CONTROL-FRAME.RESULT FRAME)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION)
      (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-000)
       (CL:IF
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS ARGUMENT) SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
          NULL))
        (CONS (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS ARGUMENT) SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
         NIL)
        NIL))
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
    (CL:T))))

;;; (DEFUN (FAILED-GOAL-JUSTIFICATION? BOOLEAN) ...)

(CL:DEFUN FAILED-GOAL-JUSTIFICATION? (SELF)
  (CL:LET* ((TEST-VALUE-000 (%JUSTIFICATION.INFERENCE-RULE SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY)
      (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-TIMEOUT) (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-DEPTH-CUTOFF))
     (CL:COND
      ((CL:EQ (%PRIMITIVE-STRATEGY.STRATEGY SELF) KWD-JUSTIFICATIONS-FAILURE)
       (CL:RETURN-FROM FAILED-GOAL-JUSTIFICATION? CL:T))
      (CL:T)))
    (CL:T)))
  CL:NIL)

;;; (DEFUN (CUTOFF-GOAL-JUSTIFICATION? BOOLEAN) ...)

(CL:DEFUN CUTOFF-GOAL-JUSTIFICATION? (SELF)
  (CL:LET* ((TEST-VALUE-000 (%JUSTIFICATION.INFERENCE-RULE SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-TIMEOUT) (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-DEPTH-CUTOFF))
     (CL:RETURN-FROM CUTOFF-GOAL-JUSTIFICATION? CL:T))
    (CL:T)))
  CL:NIL)

;;; (DEFMETHOD (CONSIFY CONS) ...)

(CL:DEFMETHOD CONSIFY ((SELF JUSTIFICATION))
  "Return a CONS tree representation of the proof `self'.
Each proof step is represented as a CONS tree of the form
  (<proposition> (<key> <value>...) <antecedent>...)
where each <antecedent> is a CONS tree representing a subproof.  The
consification follows the original proof structure literally, i.e., no
uninteresting nodes such as patterns or AND-introductions are suppressed."
  (CONSIFY-JUSTIFICATION SELF KWD-JUSTIFICATIONS-RAW))

;;; (DEFUN (CONSIFY-JUSTIFICATION CONS) ...)

(CL:DEFUN CONSIFY-JUSTIFICATION (SELF STYLE)
  "Return a CONS tree representation of the proof `self'.
Each proof step is represented as a CONS tree of the form
  (<proposition> (<key> <value>...) <antecedent>...)
where each <antecedent> is a CONS tree representing a subproof.
`style' indicates what nodes in the proof tree should be suppressed.
:RAW preserves the original structure literally, :VERBOSE keeps AND-
introductions but suppresses all auxiliary (non-logical) nodes such as
pattern nodes, and :BRIEF additionally suppresses AND-introduction nodes."
  (CL:LET* ((*EXPLANATION-STYLE* STYLE)) (CL:DECLARE (CL:SPECIAL *EXPLANATION-STYLE*))
   (CL:WHEN (CL:NOT (CL:EQ STYLE KWD-JUSTIFICATIONS-RAW)) (CL:SETQ SELF (VISIBLE-JUSTIFICATION SELF)))
   (CL:LET*
    ((ANTECEDENTS
      (CL:IF (CL:EQ STYLE KWD-JUSTIFICATIONS-RAW) (%JUSTIFICATION.ANTECEDENTS SELF)
       (%LIST.THE-CONS-LIST (VISIBLE-ANTECEDENTS SELF))))
     (PROPOSITION NULL) (KEYS (NEW-PROPERTY-LIST)) (SUBSTITUTION NIL) (CONSIFIEDSELF NIL))
    (CL:WHEN (CL:NOT (CL:EQ (%JUSTIFICATION.INFERENCE-RULE SELF) NULL))
     (INSERT-AT KEYS KWD-JUSTIFICATIONS-INFERENCE-RULE (%JUSTIFICATION.INFERENCE-RULE SELF))
     (CL:WHEN (ISA? SELF SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY)
      (INSERT-AT KEYS KWD-JUSTIFICATIONS-STRATEGY (%PRIMITIVE-STRATEGY.STRATEGY SELF))))
    (CL:IF (CL:NOT (CL:EQ (%JUSTIFICATION.TRUTH-VALUE SELF) NULL))
     (INSERT-AT KEYS KWD-JUSTIFICATIONS-TRUTH-VALUE (%JUSTIFICATION.TRUTH-VALUE SELF))
     (INSERT-AT KEYS KWD-JUSTIFICATIONS-TRUTH-VALUE UNKNOWN-TRUTH-VALUE))
    (CL:WHEN (CL:NOT (CL:= (%JUSTIFICATION.POSITIVE-SCORE SELF) NULL-FLOAT))
     (INSERT-AT KEYS KWD-JUSTIFICATIONS-POSITIVE-SCORE (WRAP-FLOAT (%JUSTIFICATION.POSITIVE-SCORE SELF))))
    (CL:LET* ((THESUBSTITUTION (%JUSTIFICATION.SUBSTITUTION SELF)))
     (CL:WHEN (CL:EQ THESUBSTITUTION NULL)
      (CL:LET* ((ANT NULL) (ITER-000 (%JUSTIFICATION.ANTECEDENTS SELF)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO (CL:SETQ ANT (%%VALUE ITER-000))
        (CL:WHEN (CL:EQ (%JUSTIFICATION.INFERENCE-RULE ANT) KWD-JUSTIFICATIONS-PATTERN)
         (CL:SETQ THESUBSTITUTION (%JUSTIFICATION.SUBSTITUTION ANT)) (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000)))))
     (CL:WHEN (CL:NOT (CL:EQ THESUBSTITUTION NULL))
      (CL:LET* ((VAR NULL) (BINDING NULL) (ITER-001 (ALLOCATE-ITERATOR THESUBSTITUTION)))
       (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ VAR (%DICTIONARY-ITERATOR.KEY ITER-001))
        (CL:SETQ BINDING (%DICTIONARY-ITERATOR.VALUE ITER-001))
        (CL:SETQ SUBSTITUTION (CONS (GENERATE-TERM VAR) SUBSTITUTION))
        (CL:SETQ SUBSTITUTION (CONS (GENERATE-TERM BINDING) SUBSTITUTION))))
      (INSERT-AT KEYS KWD-JUSTIFICATIONS-SUBSTITUTION (REVERSE SUBSTITUTION))))
    (CL:LET* ((*CURRENTJUSTIFICATION* SELF)) (CL:DECLARE (CL:SPECIAL *CURRENTJUSTIFICATION*))
     (CL:SETQ PROPOSITION (GENERATE-PROPOSITION (%JUSTIFICATION.PROPOSITION SELF)))
     (CL:WHEN (%JUSTIFICATION.REVERSE-POLARITY? SELF)
      (CL:SETQ PROPOSITION (LIST* SYM-JUSTIFICATIONS-STELLA-NOT PROPOSITION NIL))))
    (CL:SETQ CONSIFIEDSELF (CONS-LIST PROPOSITION (%PROPERTY-LIST.THE-PLIST KEYS)))
    (CL:LET* ((ANTECEDENT NULL) (ITER-002 ANTECEDENTS) (COLLECT-000 NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO (CL:SETQ ANTECEDENT (%%VALUE ITER-002))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS (CONSIFY-JUSTIFICATION ANTECEDENT STYLE) NIL))
        (CL:IF (CL:EQ CONSIFIEDSELF NIL) (CL:SETQ CONSIFIEDSELF COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST CONSIFIEDSELF COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS (CONSIFY-JUSTIFICATION ANTECEDENT STYLE) NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      (CL:SETQ ITER-002 (%%REST ITER-002))))
    CONSIFIEDSELF)))

;;; (DEFUN (GET-QUERY-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ...)

(CL:DEFUN GET-QUERY-JUSTIFICATIONS (QUERY SOLUTIONINDEX MAXJUSTIFICATIONS CREATE?)
  (CL:DECLARE (CL:TYPE CL:FIXNUM SOLUTIONINDEX MAXJUSTIFICATIONS))
  #+MCL
  (CL:CHECK-TYPE SOLUTIONINDEX CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE MAXJUSTIFICATIONS CL:FIXNUM)
  (CL:LET*
   ((ASKQUERY? (QUERY-IS-TRUE-FALSE? QUERY)) (SOLUTIONS (%QUERY-ITERATOR.SOLUTIONS QUERY)) (SOLUTION NULL)
    (NOFSOLUTIONS (LENGTH SOLUTIONS)) (JUSTIFICATIONS NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFSOLUTIONS))
   (CL:WHEN (EMPTY? SOLUTIONS) (CL:RETURN-FROM GET-QUERY-JUSTIFICATIONS NIL-LIST))
   (CL:WHEN (CL:OR ASKQUERY? (CL:= SOLUTIONINDEX NULL-INTEGER) (CL:< SOLUTIONINDEX 0))
    (CL:SETQ SOLUTIONINDEX (CL:1- NOFSOLUTIONS)))
   (CL:WHEN (CL:>= SOLUTIONINDEX NOFSOLUTIONS)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "There were only `" NOFSOLUTIONS "' solutions")
     (CL:ERROR (NEW-EXPLAIN-EXCEPTION (THE-STRING-READER STREAM-000)))))
   (CL:SETQ SOLUTION (NTH SOLUTIONS SOLUTIONINDEX))
   (CL:COND
    ((CL:EQ (%QUERY-SOLUTION.JUSTIFICATION SOLUTION) NULL)
     (CL:COND
      (CREATE? (CL:SETQ JUSTIFICATIONS (DERIVE-QUERY-JUSTIFICATIONS QUERY NULL SOLUTIONINDEX MAXJUSTIFICATIONS))
       (CL:SETF (%QUERY-SOLUTION.JUSTIFICATION SOLUTION) (FIRST JUSTIFICATIONS))
       (CL:SETF (%QUERY-SOLUTION.ALL-JUSTIFICATIONS SOLUTION) JUSTIFICATIONS) JUSTIFICATIONS)
      (CL:T NIL-LIST)))
    (CL:T
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ (%QUERY-SOLUTION.ALL-JUSTIFICATIONS SOLUTION) NULL))
       (NON-EMPTY? (%QUERY-SOLUTION.ALL-JUSTIFICATIONS SOLUTION)))
      (CL:SETQ JUSTIFICATIONS (LIST))
      (CL:LET*
       ((JUST NULL) (ITER-000 (%LIST.THE-CONS-LIST (%QUERY-SOLUTION.ALL-JUSTIFICATIONS SOLUTION)))
        (IGNORE NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-000 MAXJUSTIFICATIONS)
        (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)) (COLLECT-000 NULL))
       (CL:DECLARE (CL:TYPE CL:FIXNUM IGNORE ITER-001 UPPER-BOUND-000))
       (CL:LOOP WHILE (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000))) DO
        (CL:SETQ JUST (%%VALUE ITER-000)) (CL:SETQ IGNORE ITER-001)
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS JUST NIL))
          (CL:IF (CL:EQ (%LIST.THE-CONS-LIST JUSTIFICATIONS) NIL)
           (CL:SETF (%LIST.THE-CONS-LIST JUSTIFICATIONS) COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST JUSTIFICATIONS) COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS JUST NIL)) (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
        (CL:SETQ ITER-000 (%%REST ITER-000)) (CL:SETQ ITER-001 (CL:1+ ITER-001)))))
     (CL:IF (CL:NOT (CL:EQ JUSTIFICATIONS NULL)) JUSTIFICATIONS (LIST (%QUERY-SOLUTION.JUSTIFICATION SOLUTION)))))))

;;; (DEFUN (DERIVE-QUERY-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ...)

(CL:DEFUN DERIVE-QUERY-JUSTIFICATIONS (QUERY OPTIONS SOLUTIONINDEX MAXJUSTIFICATIONS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM SOLUTIONINDEX MAXJUSTIFICATIONS))
  #+MCL
  (CL:CHECK-TYPE SOLUTIONINDEX CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE MAXJUSTIFICATIONS CL:FIXNUM)
  (CL:LET*
   ((*QUERYITERATOR* QUERY) (*CONTEXT* (%QUERY-ITERATOR.QUERY-CONTEXT QUERY))
    (*INFERENCELEVEL* (CURRENT-INFERENCE-LEVEL)) (*REVERSEPOLARITY?* CL:NIL) (*GENERATE-ALL-PROOFS?* CL:NIL)
    (*RECORD-JUSTIFICATIONS?* CL:T))
   (CL:DECLARE
    (CL:SPECIAL *QUERYITERATOR* *CONTEXT* *INFERENCELEVEL* *REVERSEPOLARITY?* *GENERATE-ALL-PROOFS?*
     *RECORD-JUSTIFICATIONS?*))
   (CL:LET* ((ASKQUERY (ALLOCATE-QUERY-ITERATOR)) (QUERYOPTIONS (%QUERY-ITERATOR.OPTIONS QUERY)))
    (CL:WHEN (CL:EQ OPTIONS NULL) (CL:SETQ QUERYOPTIONS (COPY QUERYOPTIONS))
     (REMOVE-AT QUERYOPTIONS KWD-JUSTIFICATIONS-HOW-MANY) (CL:SETQ OPTIONS QUERYOPTIONS))
    (PROCESS-QUERY-OPTIONS ASKQUERY OPTIONS)
    (CL:LET* ((*TYPE-CHECK-STRATEGY* KWD-JUSTIFICATIONS-NONE)) (CL:DECLARE (CL:SPECIAL *TYPE-CHECK-STRATEGY*))
     (INITIALIZE-QUERY-ITERATOR ASKQUERY (QUERY-DESCRIPTION QUERY)
      (%QUERY-SOLUTION.BINDINGS (NTH (%QUERY-ITERATOR.SOLUTIONS QUERY) SOLUTIONINDEX))))
    (CL:IF (QUERY-IS-PARTIAL? QUERY) (CALL-ASK-PARTIAL ASKQUERY) (CALL-ASK ASKQUERY))
    (GET-QUERY-JUSTIFICATIONS ASKQUERY NULL-INTEGER MAXJUSTIFICATIONS CL:NIL))))

(CL:DEFUN NEW-FORWARD-GOAL-RECORD ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-FORWARD-GOAL-RECORD))
   (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF) NULL) (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FORWARD-GOAL-RECORD))
  SGT-JUSTIFICATIONS-LOGIC-FORWARD-GOAL-RECORD)

(CL:DEFUN ACCESS-FORWARD-GOAL-RECORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-FORWARD-GOAL)
    (CL:IF SETVALUE? (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-FORWARD-RULE)
    (CL:IF SETVALUE? (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD FORWARD-CHAINING-GOALS ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF) SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

;;; (DEFMETHOD (DELETED? BOOLEAN) ...)

(CL:DEFMETHOD DELETED? ((SELF FORWARD-GOAL-RECORD))
  (CL:LET* ((GOAL (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF)) (RULE (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF)))
   (CL:OR (CL:EQ GOAL NULL) (CL:EQ RULE NULL) (DELETED-PROPOSITION? GOAL) (DELETED-PROPOSITION? RULE))))

;;; (DEFMETHOD (DELETED?-SETTER BOOLEAN) ...)

(CL:DEFMETHOD DELETED?-SETTER ((SELF FORWARD-GOAL-RECORD) VALUE)
  (CL:WHEN VALUE (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF) NULL)
   (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF) NULL))
  VALUE)

;;; (DEFUN RECORD-FORWARD-GOAL ...)

(CL:DEFUN RECORD-FORWARD-GOAL (FORWARDRULE ARGUMENTS CONSEQUENTPROPOSITION)
  (CL:LET* ((FWDGOALREC NULL) (ITER-000 (%LIST.THE-CONS-LIST (FORWARD-CHAINING-GOALS CONSEQUENTPROPOSITION))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO (CL:SETQ FWDGOALREC (%%VALUE ITER-000))
    (CL:WHEN (CL:NOT (DELETED? FWDGOALREC))
     (CL:LET* ((FWDGOAL (%FORWARD-GOAL-RECORD.FORWARD-GOAL FWDGOALREC)))
      (CL:LET* ((TEST-VALUE-000 CL:NIL))
       (CL:SETQ TEST-VALUE-000 (CL:EQ (%FORWARD-GOAL-RECORD.FORWARD-RULE FWDGOALREC) FORWARDRULE))
       (CL:WHEN TEST-VALUE-000
        (CL:LET* ((ALWAYS?-000 CL:T))
         (CL:LET*
          ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER)
           (ITER-001 1))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-001))
          (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
           (CL:SETQ ARG (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000)) INDEX-000))
           (CL:SETQ I ITER-001)
           (CL:WHEN
            (CL:NOT
             (EQL? (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FWDGOAL))) I) ARG))
            (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000)) (CL:SETQ ITER-001 (CL:1+ ITER-001))))
         (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
       (CL:WHEN TEST-VALUE-000 (CL:RETURN-FROM RECORD-FORWARD-GOAL)))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:WHEN (ELABORATION-RULE? CONSEQUENTPROPOSITION FORWARDRULE ARGUMENTS) (CL:RETURN-FROM RECORD-FORWARD-GOAL))
  (CL:LET* ((FORWARDGOAL (CREATE-PROPOSITION SYM-JUSTIFICATIONS-STELLA-PREDICATE (CL:1+ (LENGTH ARGUMENTS)))))
   (CL:LET* ((SELF-000 (NEW-FORWARD-GOAL-RECORD))) (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-GOAL SELF-000) FORWARDGOAL)
    (CL:SETF (%FORWARD-GOAL-RECORD.FORWARD-RULE SELF-000) FORWARDRULE)
    (CL:LET* ((FWDGOALREC SELF-000))
     (CL:SETF (%PROPOSITION.OPERATOR FORWARDGOAL) SGT-JUSTIFICATIONS-PL-KERNEL-KB-HOLDS)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORWARDGOAL)))
       (VALUE (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORWARDRULE))) 0))
       (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET*
      ((ARG NULL) (VECTOR-001 ARGUMENTS) (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)) (I NULL-INTEGER) (ITER-002 1))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 I ITER-002))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:SETQ ARG (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001)) INDEX-001)) (CL:SETQ I ITER-002)
       (CL:LET ((SELF (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FORWARDGOAL))) (VALUE ARG) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)) (CL:SETQ ITER-002 (CL:1+ ITER-002))))
     (CL:IF (EMPTY? (FORWARD-CHAINING-GOALS CONSEQUENTPROPOSITION))
      (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS CONSEQUENTPROPOSITION)
       SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS (LIST FWDGOALREC) NULL)
      (INSERT-NEW (FORWARD-CHAINING-GOALS CONSEQUENTPROPOSITION) FWDGOALREC))))))

;;; (DEFUN (PREDICATION? BOOLEAN) ...)

(CL:DEFUN PREDICATION? (PROPOSITION)
  (MEMBER? (GET-QUOTED-TREE "((:PREDICATE :FUNCTION :ISA :EQUIVALENT) \"/LOGIC\")" "/LOGIC")
   (%PROPOSITION.KIND PROPOSITION)))

;;; (DEFUN (ASSERTED-AS-TRUE? BOOLEAN) ...)

(CL:DEFUN ASSERTED-AS-TRUE? (PROPOSITION)
  (CL:LET* ((*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:AND (CL:NOT (DELETED? PROPOSITION))
    (CL:IF *REVERSEPOLARITY?* (FALSE? PROPOSITION)
     (CL:OR (TRUE? PROPOSITION) (FUNCTION-WITH-DEFINED-VALUE? PROPOSITION))))))

;;; (DEFUN (ELABORATION-RULE? BOOLEAN) ...)

(CL:DEFUN ELABORATION-RULE? (CONSEQUENTPROPOSITION FORWARDRULE ARGUMENTS)
  (CL:LET* ((TEST-VALUE-000 CL:NIL)) (CL:SETQ TEST-VALUE-000 (PREDICATION? CONSEQUENTPROPOSITION))
   (CL:WHEN TEST-VALUE-000 (CL:SETQ TEST-VALUE-000 (ASSERTED-AS-TRUE? FORWARDRULE))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((ALWAYS?-000 CL:T))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS CONSEQUENTPROPOSITION)) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000)) INDEX-000))
        (CL:WHEN (CL:NOT (MEMBER? ARGUMENTS ARG)) (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:SETQ TEST-VALUE-000 ALWAYS?-000))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (GET-FORWARD-GOALS (LIST OF FORWARD-GOAL-RECORD)) ...)

(CL:DEFUN GET-FORWARD-GOALS (PROPOSITION)
  (CL:LET* ((GOALS (REMOVE-DELETED-MEMBERS (FORWARD-CHAINING-GOALS PROPOSITION))))
   (CL:WHEN
    (CL:AND (EMPTY? GOALS)
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION) SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL)
       NULL)))
    (CL:SETQ GOALS
     (REMOVE-DELETED-MEMBERS
      (FORWARD-CHAINING-GOALS
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION) SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION
        NULL)))))
   GOALS))

(CL:DEFUN NEW-FORWARD-JUSTIFICATION ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-FORWARD-JUSTIFICATION))
   (CL:SETF (%FORWARD-JUSTIFICATION.NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%FORWARD-JUSTIFICATION.POSITIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%FORWARD-JUSTIFICATION.TRUTH-VALUE SELF) NULL)
   (CL:SETF (%FORWARD-JUSTIFICATION.REVERSE-POLARITY? SELF) CL:NIL)
   (CL:SETF (%FORWARD-JUSTIFICATION.SUBSTITUTION SELF) NULL) (CL:SETF (%FORWARD-JUSTIFICATION.ANTECEDENTS SELF) NIL)
   (CL:SETF (%FORWARD-JUSTIFICATION.PROPOSITION SELF) NULL) (CL:SETF (%FORWARD-JUSTIFICATION.INFERENCE-RULE SELF) NULL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FORWARD-JUSTIFICATION))
  SGT-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATION)

(CL:DEFMETHOD INFERENCE-DIRECTION ((SELF FORWARD-JUSTIFICATION))
  KWD-JUSTIFICATIONS-FORWARD)

(CL:DEFMETHOD FORWARD-JUSTIFICATIONS ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF) SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

;;; (DEFUN (HAS-FORWARD-JUSTIFICATIONS? BOOLEAN) ...)

(CL:DEFUN HAS-FORWARD-JUSTIFICATIONS? (PROPOSITION)
  "Return TRUE if `proposition' has any forward justifications."
  (NON-EMPTY? (FORWARD-JUSTIFICATIONS PROPOSITION)))

;;; (DEFUN (GET-FORWARD-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ...)

(CL:DEFUN GET-FORWARD-JUSTIFICATIONS (PROPOSITION)
  "Return `proposition's forward justifications."
  (FORWARD-JUSTIFICATIONS PROPOSITION))

;;; (DEFUN ADD-FORWARD-JUSTIFICATIONS ...)

(CL:DEFUN ADD-FORWARD-JUSTIFICATIONS (PROPOSITION JUSTIFICATION)
  (CL:LET* ((JUSTIFICATIONS (FORWARD-JUSTIFICATIONS PROPOSITION)))
   (CL:LET* ((FOUND?-000 CL:NIL))
    (CL:LET* ((JUST NULL) (ITER-000 (%LIST.THE-CONS-LIST JUSTIFICATIONS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO (CL:SETQ JUST (%%VALUE ITER-000))
      (CL:WHEN (JUSTIFICATION-EQL? JUST JUSTIFICATION) (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:WHEN FOUND?-000 (CL:RETURN-FROM ADD-FORWARD-JUSTIFICATIONS)))
   (CL:WHEN (CL:EQ JUSTIFICATIONS NIL-LIST) (CL:SETQ JUSTIFICATIONS (LIST))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION) SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS
     JUSTIFICATIONS NULL))
   (PUSH JUSTIFICATIONS JUSTIFICATION)))

;;; (DEFUN (GET-RULE-IO-VARIABLES VARIABLES-VECTOR) ...)

(CL:DEFUN GET-RULE-IO-VARIABLES (RULE)
  (CL:LET*
   ((VARS (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS RULE) SYM-JUSTIFICATIONS-LOGIC-IO-VARIABLES NULL))
    (MASTER NULL))
   (CL:WHEN (CL:NOT (CL:EQ VARS NULL)) (CL:RETURN-FROM GET-RULE-IO-VARIABLES VARS))
   (CL:SETQ MASTER
    (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS RULE) SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL))
   (CL:WHEN (CL:NOT (CL:EQ MASTER NULL))
    (CL:SETQ VARS (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS MASTER) SYM-JUSTIFICATIONS-LOGIC-IO-VARIABLES NULL))
    (CL:WHEN (CL:NOT (CL:EQ VARS NULL)) (CL:RETURN-FROM GET-RULE-IO-VARIABLES VARS)))
   (CL:WHEN (CL:EQ (%PROPOSITION.KIND RULE) KWD-JUSTIFICATIONS-IMPLIES)
    (CL:LET*
     ((ARGUMENTS (%PROPOSITION.ARGUMENTS RULE))
      (ANT (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) 0))
      (CQ (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) 1)))
     (CL:IF (NAMED-DESCRIPTION? ANT) (CL:RETURN-FROM GET-RULE-IO-VARIABLES (%DESCRIPTION.IO-VARIABLES CQ))
      (CL:RETURN-FROM GET-RULE-IO-VARIABLES (%DESCRIPTION.IO-VARIABLES ANT)))))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "get-rule-io-variables: don't know how to access IO-vars of rule: `" RULE "'")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))

;;; (DEFUN (CREATE-FORWARD-JUSTIFICATION FORWARD-JUSTIFICATION) ...)

(CL:DEFUN CREATE-FORWARD-JUSTIFICATION (ANTECEDENTS FORWARDRULE ARGUMENTS CONSEQUENTPROPOSITION BC-JUSTIFICATION)
  (CL:LET* ((SELF-000 (NEW-FORWARD-JUSTIFICATION)))
   (CL:SETF (%FORWARD-JUSTIFICATION.INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-MODUS-PONENS)
   (CL:LET*
    ((FJ SELF-000) (RULE-VARIABLES (GET-RULE-IO-VARIABLES FORWARDRULE)) (SUBSTITUTION NULL)
     (ANTECEDENT-JUSTIFICATIONS NIL))
    (CL:IF (CL:NOT (CL:EQ BC-JUSTIFICATION NULL))
     (CL:PROGN (CL:SETQ SUBSTITUTION (%JUSTIFICATION.SUBSTITUTION BC-JUSTIFICATION))
      (CL:SETQ ANTECEDENT-JUSTIFICATIONS (CONS BC-JUSTIFICATION ANTECEDENT-JUSTIFICATIONS)))
     (CL:PROGN (CL:SETQ SUBSTITUTION (NEW-KEY-VALUE-MAP))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (VAR NULL)
        (VECTOR-001 RULE-VARIABLES) (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
        (CL:SETQ ARG (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000)) INDEX-000))
        (CL:SETQ VAR (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001)) INDEX-001))
        (INSERT-AT SUBSTITUTION VAR ARG) (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))))
    (CL:LET* ((APROP NULL) (ITER-000 ANTECEDENTS))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO (CL:SETQ APROP (%%VALUE ITER-000))
      (CL:SETQ ANTECEDENT-JUSTIFICATIONS (CONS (GET-FORWARD-ANTECEDENT-JUSTIFICATION APROP) ANTECEDENT-JUSTIFICATIONS))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:SETQ ANTECEDENT-JUSTIFICATIONS
     (CONS (GET-FORWARD-ANTECEDENT-JUSTIFICATION FORWARDRULE) ANTECEDENT-JUSTIFICATIONS))
    (CL:SETF (%FORWARD-JUSTIFICATION.SUBSTITUTION FJ) SUBSTITUTION)
    (CL:SETF (%FORWARD-JUSTIFICATION.PROPOSITION FJ) CONSEQUENTPROPOSITION)
    (CL:SETF (%FORWARD-JUSTIFICATION.TRUTH-VALUE FJ)
     (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE CONSEQUENTPROPOSITION)
      (%PROPOSITION.HOME-CONTEXT CONSEQUENTPROPOSITION) CL:NIL))
    (CL:SETF (%FORWARD-JUSTIFICATION.ANTECEDENTS FJ) ANTECEDENT-JUSTIFICATIONS) FJ)))

;;; (DEFUN (GET-FORWARD-ANTECEDENT-JUSTIFICATION JUSTIFICATION) ...)

(CL:DEFUN GET-FORWARD-ANTECEDENT-JUSTIFICATION (ANTECEDENT)
  (CL:IF
   (CL:AND (CL:NOT (CL:EQ (FORWARD-JUSTIFICATIONS ANTECEDENT) NULL))
    (CL:NOT (EMPTY? (FORWARD-JUSTIFICATIONS ANTECEDENT))))
   (FIRST (FORWARD-JUSTIFICATIONS ANTECEDENT))
   (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY))) (CL:SETF (%PRIMITIVE-STRATEGY.PROPOSITION SELF-000) ANTECEDENT)
    (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-000) KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS)
    (CL:LET* ((VALUE-000 SELF-000)) VALUE-000))))

;;; (DEFUN RECORD-FORWARD-JUSTIFICATION ...)

(CL:DEFUN RECORD-FORWARD-JUSTIFICATION (ANTECEDENTS FORWARDRULE ARGUMENTS CONSEQUENTPROPOSITION BC-JUSTIFICATION)
  (CL:WHEN (CL:NOT *RECORD-JUSTIFICATIONS?*) (CL:RETURN-FROM RECORD-FORWARD-JUSTIFICATION))
  (CL:LET*
   ((JUSTIFICATIONS (FORWARD-JUSTIFICATIONS CONSEQUENTPROPOSITION))
    (NEW-FJ (CREATE-FORWARD-JUSTIFICATION ANTECEDENTS FORWARDRULE ARGUMENTS CONSEQUENTPROPOSITION BC-JUSTIFICATION)))
   (CL:LET* ((FJ NULL) (ITER-000 (%LIST.THE-CONS-LIST JUSTIFICATIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO (CL:SETQ FJ (%%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%JUSTIFICATION.PROPOSITION (%%VALUE (%JUSTIFICATION.ANTECEDENTS FJ))) FORWARDRULE)
      (CL:SETF (%JUSTIFICATION.SUBSTITUTION FJ) (%FORWARD-JUSTIFICATION.SUBSTITUTION NEW-FJ))
      (CL:SETF (%JUSTIFICATION.ANTECEDENTS FJ) (%FORWARD-JUSTIFICATION.ANTECEDENTS NEW-FJ))
      (CL:RETURN-FROM RECORD-FORWARD-JUSTIFICATION))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (ADD-FORWARD-JUSTIFICATIONS CONSEQUENTPROPOSITION NEW-FJ)))

;;; (DEFUN (CREATE-SUBSET-JUSTIFICATION JUSTIFICATION) ...)

(CL:DEFUN CREATE-SUBSET-JUSTIFICATION (MAIN-PROPOSITION MATCHING-PROPOSITION)
  (CL:LET*
   ((MAIN-OPERATOR (%PROPOSITION.OPERATOR MAIN-PROPOSITION))
    (MATCHING-OPERATOR (%PROPOSITION.OPERATOR MATCHING-PROPOSITION)))
   (CL:WHEN
    (CL:NOT (CL:OR (CL:EQ MAIN-OPERATOR NULL) (CL:EQ MATCHING-OPERATOR NULL) (CL:EQ MAIN-OPERATOR MATCHING-OPERATOR)))
    (CL:WHEN (RELATIONREF-SPECIALIZES-RELATIONREF? MATCHING-OPERATOR MAIN-OPERATOR)
     (CL:LET* ((SUBSET-PROPOSITION NULL) (SUBSET-JUSTIFICATIONS NIL))
      (CL:LET* ((*EVALUATIONMODE* KWD-JUSTIFICATIONS-DESCRIPTION)) (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
       (CL:SETQ SUBSET-PROPOSITION
        (CONCEIVE-FORMULA (CONS-LIST SYM-JUSTIFICATIONS-PL-KERNEL-KB-SUBSET-OF MATCHING-OPERATOR MAIN-OPERATOR))))
      (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY)))
       (CL:SETF (%PRIMITIVE-STRATEGY.PROPOSITION SELF-000) SUBSET-PROPOSITION)
       (CL:SETF (%PRIMITIVE-STRATEGY.TRUTH-VALUE SELF-000) TRUE-TRUTH-VALUE)
       (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-000) KWD-JUSTIFICATIONS-SPECIALIST)
       (CL:SETQ SUBSET-JUSTIFICATIONS (CONS SELF-000 SUBSET-JUSTIFICATIONS)))
      (CL:LET* ((SELF-001 (NEW-PRIMITIVE-STRATEGY)))
       (CL:SETF (%PRIMITIVE-STRATEGY.PROPOSITION SELF-001) MATCHING-PROPOSITION)
       (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-001) KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS)
       (CL:SETQ SUBSET-JUSTIFICATIONS (CONS SELF-001 SUBSET-JUSTIFICATIONS)))
      (CL:LET* ((SELF-002 (NEW-JUSTIFICATION)))
       (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-002) KWD-JUSTIFICATIONS-SUBSUMPTION-REASONING)
       (CL:SETF (%JUSTIFICATION.PROPOSITION SELF-002) MAIN-PROPOSITION)
       (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-002) SUBSET-JUSTIFICATIONS)
       (CL:LET* ((VALUE-000 SELF-002)) (CL:RETURN-FROM CREATE-SUBSET-JUSTIFICATION VALUE-000))))))
   NULL))

(CL:DEFUN NEW-CLASH-JUSTIFICATION ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-CLASH-JUSTIFICATION))
   (CL:SETF (%CLASH-JUSTIFICATION.NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%CLASH-JUSTIFICATION.POSITIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%CLASH-JUSTIFICATION.TRUTH-VALUE SELF) NULL)
   (CL:SETF (%CLASH-JUSTIFICATION.REVERSE-POLARITY? SELF) CL:NIL)
   (CL:SETF (%CLASH-JUSTIFICATION.SUBSTITUTION SELF) NULL) (CL:SETF (%CLASH-JUSTIFICATION.ANTECEDENTS SELF) NIL)
   (CL:SETF (%CLASH-JUSTIFICATION.PROPOSITION SELF) NULL) (CL:SETF (%CLASH-JUSTIFICATION.INFERENCE-RULE SELF) NULL)
   (CL:SETF (%CLASH-JUSTIFICATION.DIRECTION SELF) KWD-JUSTIFICATIONS-FORWARD) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CLASH-JUSTIFICATION))
  SGT-JUSTIFICATIONS-LOGIC-CLASH-JUSTIFICATION)

(CL:DEFMETHOD INFERENCE-DIRECTION ((SELF CLASH-JUSTIFICATION))
  (%CLASH-JUSTIFICATION.DIRECTION SELF))

(CL:DEFUN ACCESS-CLASH-JUSTIFICATION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-DIRECTION)
    (CL:IF SETVALUE? (CL:SETF (%CLASH-JUSTIFICATION.DIRECTION SELF) VALUE)
     (CL:SETQ VALUE (%CLASH-JUSTIFICATION.DIRECTION SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (CREATE-CLASH-JUSTIFICATION CLASH-JUSTIFICATION) ...)

(CL:DEFUN CREATE-CLASH-JUSTIFICATION (PROP ANTECEDENTS DIRECTION)
  (CL:LET* ((SELF-000 (NEW-CLASH-JUSTIFICATION)))
   (CL:SETF (%CLASH-JUSTIFICATION.INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-CLASH)
   (CL:SETF (%CLASH-JUSTIFICATION.DIRECTION SELF-000) DIRECTION)
   (CL:SETF (%CLASH-JUSTIFICATION.PROPOSITION SELF-000) PROP)
   (CL:SETF (%CLASH-JUSTIFICATION.TRUTH-VALUE SELF-000) INCONSISTENT-TRUTH-VALUE)
   (CL:SETF (%CLASH-JUSTIFICATION.ANTECEDENTS SELF-000) ANTECEDENTS) (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))

(CL:DEFUN HELP-STARTUP-JUSTIFICATIONS1 ()
  (CL:PROGN (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-JUSTIFICATION (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATION" NULL 1))
   (CL:SETQ KWD-JUSTIFICATIONS-BACKWARD (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-RULE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-PROPOSITION (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-SUBSTITUTION (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSTITUTION" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-REVERSE-POLARITY? (INTERN-RIGID-SYMBOL-WRT-MODULE "REVERSE-POLARITY?" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-TRUTH-VALUE (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-POSITIVE-SCORE (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITIVE-SCORE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-NEGATIVE-SCORE (INTERN-RIGID-SYMBOL-WRT-MODULE "NEGATIVE-SCORE" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMITIVE-STRATEGY" NULL 2))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMITIVE-STRATEGY" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-STRATEGY (INTERN-RIGID-SYMBOL-WRT-MODULE "STRATEGY" NULL 0))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-PROPOSITION (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATION" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-UP-TRUE (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TRUE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-UP-FAIL (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-FAIL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-FAILURE (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILURE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SCAN-COLLECTION (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-COLLECTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-TECHNICAL (INTERN-RIGID-SYMBOL-WRT-MODULE "TECHNICAL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-PROPOSITIONS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP-ASSERTIONS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-LAY (INTERN-RIGID-SYMBOL-WRT-MODULE "LAY" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SPECIALIST (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIALIST" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-COMPUTED-PREDICATE (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPUTED-PREDICATE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-GOAL-COMPLEMENT (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-COMPLEMENT" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-EQUIVALENCE (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENCE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SUBSUMPTION-TEST (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-TEST" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SUBSUMPTION-REASONING (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-REASONING" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-PATTERN (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN" NULL 2))
   (CL:SETQ SGT-JUSTIFICATIONS-STELLA-KEY-VALUE-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-VALUE-LIST" (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-JUSTIFICATIONS-AND-INTRODUCTION (INTERN-RIGID-SYMBOL-WRT-MODULE "AND-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-MODUS-TOLLENS (INTERN-RIGID-SYMBOL-WRT-MODULE "MODUS-TOLLENS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-MODUS-PONENS (INTERN-RIGID-SYMBOL-WRT-MODULE "MODUS-PONENS" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS-RULE (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS-RULE" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-NOT (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-AMPLIFICATION (INTERN-RIGID-SYMBOL-WRT-MODULE "AMPLIFICATION" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS" (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-JUSTIFICATIONS-PARTIAL (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-REVERSE (INTERN-RIGID-SYMBOL-WRT-MODULE "REVERSE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-OR-INTRODUCTION (INTERN-RIGID-SYMBOL-WRT-MODULE "OR-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-DISPROOF (INTERN-RIGID-SYMBOL-WRT-MODULE "DISPROOF" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-FAIL-INTRODUCTION (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-NEGATED-FAIL (INTERN-RIGID-SYMBOL-WRT-MODULE "NEGATED-FAIL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED-NOT-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-FAIL (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTENTIAL-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-TIMEOUT (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMEOUT" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-DEPTH-CUTOFF (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPTH-CUTOFF" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-RAW (INTERN-RIGID-SYMBOL-WRT-MODULE "RAW" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-INFERENCE-RULE (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-RULE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-STRATEGY (INTERN-RIGID-SYMBOL-WRT-MODULE "STRATEGY" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-TRUTH-VALUE (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-POSITIVE-SCORE (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITIVE-SCORE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SUBSTITUTION (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSTITUTION" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-NOT (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-JUSTIFICATIONS-HOW-MANY (INTERN-RIGID-SYMBOL-WRT-MODULE "HOW-MANY" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-NONE (INTERN-RIGID-SYMBOL-WRT-MODULE "NONE" NULL 2))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-FORWARD-GOAL-RECORD (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-GOAL-RECORD" NULL 1))))

(CL:DEFUN HELP-STARTUP-JUSTIFICATIONS2 ()
  (CL:PROGN (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-GOAL (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-GOAL" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-RULE (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-RULE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-CHAINING-GOALS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-JUSTIFICATIONS-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS" (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-JUSTIFICATION" NULL 1))
   (CL:SETQ KWD-JUSTIFICATIONS-FORWARD (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-JUSTIFICATIONS" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-FORWARD-INFERENCE (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-INFERENCE" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-IO-VARIABLES (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-IMPLIES (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-DESCRIPTION (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-PL-KERNEL-KB-SUBSET-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET-OF" (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-CLASH-JUSTIFICATION (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASH-JUSTIFICATION" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-DIRECTION (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTION" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-CLASH (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASH" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-STARTUP-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-JUSTIFICATIONS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-JUSTIFICATIONS3 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "JUSTIFICATION-ARGUMENT-BOUND-TO"
    "(DEFUN (JUSTIFICATION-ARGUMENT-BOUND-TO OBJECT) ((ARGUMENT OBJECT) (JUSTIFICATION JUSTIFICATION)))"
    (CL:FUNCTION JUSTIFICATION-ARGUMENT-BOUND-TO) NULL)
   (DEFINE-FUNCTION-OBJECT "JUSTIFICATION-EQL?"
    "(DEFUN (JUSTIFICATION-EQL? BOOLEAN) ((JUST1 JUSTIFICATION) (JUST2 JUSTIFICATION)))"
    (CL:FUNCTION JUSTIFICATION-EQL?) NULL)
   (DEFINE-FUNCTION-OBJECT "JUSTIFICATION-PROPOSITIONS-EQL?"
    "(DEFUN (JUSTIFICATION-PROPOSITIONS-EQL? BOOLEAN) ((PROPOSITION1 PROPOSITION) (JUST1 JUSTIFICATION) (PROPOSITION2 PROPOSITION) (JUST2 JUSTIFICATION)))"
    (CL:FUNCTION JUSTIFICATION-PROPOSITIONS-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY (LIKE SELF)) ((SELF JUSTIFICATION)) :DOCUMENTATION \"Return a copy of the proof starting at `self'.  Allocates
all new justification objects, but structure-shares other information such
as propositions and substitutions.\" :PUBLIC? TRUE)" (CL:FUNCTION COPY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SHALLOW-COPY (LIKE SELF)) ((SELF JUSTIFICATION)) :DOCUMENTATION \"Similar to `copy' but does not copy antecedent justifications.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SHALLOW-COPY) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-JUSTIFICATIONS?"
    "(DEFUN (RECORD-JUSTIFICATIONS? BOOLEAN) () :DOCUMENTATION \"Return TRUE if every query records justifications to enable
the explanation of concluded results.\" :GLOBALLY-INLINE? TRUE (RETURN *RECORD-JUSTIFICATIONS?*))"
    (CL:FUNCTION RECORD-JUSTIFICATIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-GOAL-JUSTIFICATION"
    "(DEFUN RECORD-GOAL-JUSTIFICATION ((GOAL CONTROL-FRAME) (JUSTIFICATION JUSTIFICATION)))"
    (CL:FUNCTION RECORD-GOAL-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-PRIMITIVE-JUSTIFICATION"
    "(DEFUN RECORD-PRIMITIVE-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION RECORD-PRIMITIVE-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-PATTERN-JUSTIFICATION"
    "(DEFUN RECORD-PATTERN-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION RECORD-PATTERN-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "BACKLINK-TO-PATTERN-JUSTIFICATION"
    "(DEFUN BACKLINK-TO-PATTERN-JUSTIFICATION ((JUSTIFICATION JUSTIFICATION) (PATTERN JUSTIFICATION)))"
    (CL:FUNCTION BACKLINK-TO-PATTERN-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-MODUS-PONENS-JUSTIFICATION"
    "(DEFUN RECORD-MODUS-PONENS-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION RECORD-MODUS-PONENS-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-AND-INTRODUCTION-JUSTIFICATION"
    "(DEFUN RECORD-AND-INTRODUCTION-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION RECORD-AND-INTRODUCTION-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-OR-INTRODUCTION-JUSTIFICATION"
    "(DEFUN RECORD-OR-INTRODUCTION-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION RECORD-OR-INTRODUCTION-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-DISPROOF-JUSTIFICATION"
    "(DEFUN RECORD-DISPROOF-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION RECORD-DISPROOF-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-FAIL-JUSTIFICATION"
    "(DEFUN RECORD-FAIL-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION RECORD-FAIL-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-NEGATED-FAIL-JUSTIFICATION"
    "(DEFUN RECORD-NEGATED-FAIL-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION RECORD-NEGATED-FAIL-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-CLOSED-NOT-JUSTIFICATION"
    "(DEFUN RECORD-CLOSED-NOT-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION RECORD-CLOSED-NOT-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION"
    "(DEFUN RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "FAILED-GOAL-JUSTIFICATION?"
    "(DEFUN (FAILED-GOAL-JUSTIFICATION? BOOLEAN) ((SELF JUSTIFICATION)))" (CL:FUNCTION FAILED-GOAL-JUSTIFICATION?)
    NULL)
   (DEFINE-FUNCTION-OBJECT "CUTOFF-GOAL-JUSTIFICATION?"
    "(DEFUN (CUTOFF-GOAL-JUSTIFICATION? BOOLEAN) ((SELF JUSTIFICATION)))" (CL:FUNCTION CUTOFF-GOAL-JUSTIFICATION?)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONSIFY CONS) ((SELF JUSTIFICATION)) :DOCUMENTATION \"Return a CONS tree representation of the proof `self'.
Each proof step is represented as a CONS tree of the form
  (<proposition> (<key> <value>...) <antecedent>...)
where each <antecedent> is a CONS tree representing a subproof.  The
consification follows the original proof structure literally, i.e., no
uninteresting nodes such as patterns or AND-introductions are suppressed.\" :PUBLIC? TRUE)" (CL:FUNCTION CONSIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "CONSIFY-JUSTIFICATION"
    "(DEFUN (CONSIFY-JUSTIFICATION CONS) ((SELF JUSTIFICATION) (STYLE KEYWORD)) :DOCUMENTATION \"Return a CONS tree representation of the proof `self'.
Each proof step is represented as a CONS tree of the form
  (<proposition> (<key> <value>...) <antecedent>...)
where each <antecedent> is a CONS tree representing a subproof.
`style' indicates what nodes in the proof tree should be suppressed.
:RAW preserves the original structure literally, :VERBOSE keeps AND-
introductions but suppresses all auxiliary (non-logical) nodes such as
pattern nodes, and :BRIEF additionally suppresses AND-introduction nodes.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CONSIFY-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-QUERY-JUSTIFICATIONS"
    "(DEFUN (GET-QUERY-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ((QUERY QUERY-ITERATOR) (SOLUTIONINDEX INTEGER) (MAXJUSTIFICATIONS INTEGER) (CREATE? BOOLEAN)))"
    (CL:FUNCTION GET-QUERY-JUSTIFICATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "DERIVE-QUERY-JUSTIFICATIONS"
    "(DEFUN (DERIVE-QUERY-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ((QUERY QUERY-ITERATOR) (OPTIONS OBJECT) (SOLUTIONINDEX INTEGER) (MAXJUSTIFICATIONS INTEGER)))"
    (CL:FUNCTION DERIVE-QUERY-JUSTIFICATIONS) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT PROPOSITION FORWARD-CHAINING-GOALS :TYPE (LIST OF FORWARD-GOAL-RECORD) :ALLOCATION :DYNAMIC)")
   (DEFINE-METHOD-OBJECT "(DEFMETHOD (DELETED? BOOLEAN) ((SELF FORWARD-GOAL-RECORD)))" (CL:FUNCTION DELETED?) NULL)
   (DEFINE-METHOD-OBJECT "(DEFMETHOD (DELETED?-SETTER BOOLEAN) ((SELF FORWARD-GOAL-RECORD) (VALUE BOOLEAN)))"
    (CL:FUNCTION DELETED?-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-FORWARD-GOAL"
    "(DEFUN RECORD-FORWARD-GOAL ((FORWARDRULE PROPOSITION) (ARGUMENTS ARGUMENTS-VECTOR) (CONSEQUENTPROPOSITION PROPOSITION)))"
    (CL:FUNCTION RECORD-FORWARD-GOAL) NULL)
   (DEFINE-FUNCTION-OBJECT "PREDICATION?" "(DEFUN (PREDICATION? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION PREDICATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERTED-AS-TRUE?" "(DEFUN (ASSERTED-AS-TRUE? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION ASSERTED-AS-TRUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "ELABORATION-RULE?"
    "(DEFUN (ELABORATION-RULE? BOOLEAN) ((CONSEQUENTPROPOSITION PROPOSITION) (FORWARDRULE PROPOSITION) (ARGUMENTS ARGUMENTS-VECTOR)))"
    (CL:FUNCTION ELABORATION-RULE?) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-FORWARD-GOALS"
    "(DEFUN (GET-FORWARD-GOALS (LIST OF FORWARD-GOAL-RECORD)) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION GET-FORWARD-GOALS) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT PROPOSITION FORWARD-JUSTIFICATIONS :TYPE (LIST OF JUSTIFICATION) :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "HAS-FORWARD-JUSTIFICATIONS?"
    "(DEFUN (HAS-FORWARD-JUSTIFICATIONS? BOOLEAN) ((PROPOSITION PROPOSITION)) :DOCUMENTATION \"Return TRUE if `proposition' has any forward justifications.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NON-EMPTY? (FORWARD-JUSTIFICATIONS PROPOSITION))))"
    (CL:FUNCTION HAS-FORWARD-JUSTIFICATIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-FORWARD-JUSTIFICATIONS"
    "(DEFUN (GET-FORWARD-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ((PROPOSITION PROPOSITION)) :DOCUMENTATION \"Return `proposition's forward justifications.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (FORWARD-JUSTIFICATIONS PROPOSITION)))"
    (CL:FUNCTION GET-FORWARD-JUSTIFICATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-FORWARD-JUSTIFICATIONS"
    "(DEFUN ADD-FORWARD-JUSTIFICATIONS ((PROPOSITION PROPOSITION) (JUSTIFICATION JUSTIFICATION)))"
    (CL:FUNCTION ADD-FORWARD-JUSTIFICATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-RULE-IO-VARIABLES"
    "(DEFUN (GET-RULE-IO-VARIABLES VARIABLES-VECTOR) ((RULE PROPOSITION)))" (CL:FUNCTION GET-RULE-IO-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-FORWARD-JUSTIFICATION"
    "(DEFUN (CREATE-FORWARD-JUSTIFICATION FORWARD-JUSTIFICATION) ((ANTECEDENTS (CONS OF PROPOSITION)) (FORWARDRULE PROPOSITION) (ARGUMENTS ARGUMENTS-VECTOR) (CONSEQUENTPROPOSITION PROPOSITION) (BC-JUSTIFICATION JUSTIFICATION)))"
    (CL:FUNCTION CREATE-FORWARD-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-FORWARD-ANTECEDENT-JUSTIFICATION"
    "(DEFUN (GET-FORWARD-ANTECEDENT-JUSTIFICATION JUSTIFICATION) ((ANTECEDENT PROPOSITION)))"
    (CL:FUNCTION GET-FORWARD-ANTECEDENT-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-FORWARD-JUSTIFICATION"
    "(DEFUN RECORD-FORWARD-JUSTIFICATION ((ANTECEDENTS (CONS OF PROPOSITION)) (FORWARDRULE PROPOSITION) (ARGUMENTS ARGUMENTS-VECTOR) (CONSEQUENTPROPOSITION PROPOSITION) (BC-JUSTIFICATION JUSTIFICATION)))"
    (CL:FUNCTION RECORD-FORWARD-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-SUBSET-JUSTIFICATION"
    "(DEFUN (CREATE-SUBSET-JUSTIFICATION JUSTIFICATION) ((MAIN-PROPOSITION PROPOSITION) (MATCHING-PROPOSITION PROPOSITION)))"
    (CL:FUNCTION CREATE-SUBSET-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-CLASH-JUSTIFICATION"
    "(DEFUN (CREATE-CLASH-JUSTIFICATION CLASH-JUSTIFICATION) ((PROP PROPOSITION) (ANTECEDENTS (CONS OF JUSTIFICATION)) (DIRECTION KEYWORD)))"
    (CL:FUNCTION CREATE-CLASH-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-JUSTIFICATIONS" "(DEFUN STARTUP-JUSTIFICATIONS () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-JUSTIFICATIONS) NULL)
   (CL:LET* ((FUNCTION (LOOKUP-FUNCTION SYM-JUSTIFICATIONS-LOGIC-STARTUP-JUSTIFICATIONS)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION) SYM-JUSTIFICATIONS-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupJustifications") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-JUSTIFICATIONS ()
  (CL:LET* ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1))) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-JUSTIFICATIONS1) (HELP-STARTUP-JUSTIFICATIONS2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "JUSTIFICATION"
        "(DEFCLASS JUSTIFICATION (STANDARD-OBJECT) :SLOTS ((INFERENCE-RULE :TYPE KEYWORD :DOCUMENTATION \"Keyword describing the inference rule used to conclude the
proposition of this justification.\") (PROPOSITION :TYPE PROPOSITION :DOCUMENTATION \"The proposition supported by this justification.\") (ANTECEDENTS :TYPE (CONS OF JUSTIFICATION) :INITIALLY NIL :DOCUMENTATION \"Antecedents justifications of this justification.\") (SUBSTITUTION :TYPE (ENTITY-MAPPING OF PATTERN-VARIABLE OBJECT) :DOCUMENTATION \"List of variable bindings recorded for this justification.\") (REVERSE-POLARITY? :TYPE BOOLEAN :DOCUMENTATION \"True if proposition was derived in reverse polarity.\") (TRUTH-VALUE :TYPE TRUTH-VALUE :DOCUMENTATION \"Truth value of the derived proposition.\") (POSITIVE-SCORE :TYPE PARTIAL-MATCH-SCORE :DOCUMENTATION \"Positive partial match score of the derived proposition.\") (NEGATIVE-SCORE :TYPE PARTIAL-MATCH-SCORE :DOCUMENTATION \"Negative partial match score of the derived proposition.\")) :METHODS ((INFERENCE-STRATEGY ((SELF JUSTIFICATION)) :TYPE KEYWORD (RETURN NULL)) (INFERENCE-DIRECTION ((SELF JUSTIFICATION)) :TYPE KEYWORD (RETURN :BACKWARD))))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-JUSTIFICATION))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS) (CL:FUNCTION ACCESS-JUSTIFICATION-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PRIMITIVE-STRATEGY"
        "(DEFCLASS PRIMITIVE-STRATEGY (JUSTIFICATION) :SLOTS ((INFERENCE-RULE :TYPE KEYWORD :INITIALLY :PRIMITIVE-STRATEGY) (STRATEGY :TYPE KEYWORD)) :METHODS ((INFERENCE-STRATEGY ((SELF PRIMITIVE-STRATEGY)) :TYPE KEYWORD (RETURN (STRATEGY SELF)))))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-PRIMITIVE-STRATEGY))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS) (CL:FUNCTION ACCESS-PRIMITIVE-STRATEGY-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FORWARD-GOAL-RECORD"
        "(DEFCLASS FORWARD-GOAL-RECORD (STANDARD-OBJECT) :SLOTS ((FORWARD-GOAL :TYPE PROPOSITION) (FORWARD-RULE :TYPE PROPOSITION)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-FORWARD-GOAL-RECORD))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS) (CL:FUNCTION ACCESS-FORWARD-GOAL-RECORD-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FORWARD-JUSTIFICATION"
        "(DEFCLASS FORWARD-JUSTIFICATION (JUSTIFICATION) :METHODS ((INFERENCE-DIRECTION ((SELF FORWARD-JUSTIFICATION)) :TYPE KEYWORD (RETURN :FORWARD))))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-FORWARD-JUSTIFICATION)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CLASH-JUSTIFICATION"
        "(DEFCLASS CLASH-JUSTIFICATION (JUSTIFICATION) :SLOTS ((DIRECTION :TYPE KEYWORD :INITIALLY :FORWARD :DOCUMENTATION \"The inference direction for this inference.\")) :METHODS ((INFERENCE-DIRECTION ((SELF CLASH-JUSTIFICATION)) :TYPE KEYWORD (RETURN (DIRECTION SELF)))))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-CLASH-JUSTIFICATION))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS) (CL:FUNCTION ACCESS-CLASH-JUSTIFICATION-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-JUSTIFICATIONS3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS) (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9) (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *RECORD-JUSTIFICATIONS?* BOOLEAN FALSE :DOCUMENTATION \"If TRUE every query records justifications to enable
the explanation of concluded results.\")")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SCAN-COLLECTION KWD-JUSTIFICATIONS-TECHNICAL "by explicit assertion")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS KWD-JUSTIFICATIONS-TECHNICAL
     "by explicit assertion")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS KWD-JUSTIFICATIONS-TECHNICAL
     "by explicit assertion")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SCAN-COLLECTION KWD-JUSTIFICATIONS-LAY
     "because the system was told this fact")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS KWD-JUSTIFICATIONS-LAY
     "because the system was told this fact")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS KWD-JUSTIFICATIONS-LAY
     "because the system was told this fact")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SPECIALIST KWD-JUSTIFICATIONS-TECHNICAL
     "because it was proven by an inference specialist")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SPECIALIST KWD-JUSTIFICATIONS-LAY
     "because of a specialized reasoning procedure")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-COMPUTED-PREDICATE KWD-JUSTIFICATIONS-TECHNICAL
     "because of a computation")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-COMPUTED-PREDICATE KWD-JUSTIFICATIONS-LAY "because of a computation")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-GOAL-COMPLEMENT KWD-JUSTIFICATIONS-TECHNICAL
     "because its argument was proven false")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-GOAL-COMPLEMENT KWD-JUSTIFICATIONS-LAY
     "because its argument is false")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-EQUIVALENCE KWD-JUSTIFICATIONS-TECHNICAL "from equivalence")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-EQUIVALENCE KWD-JUSTIFICATIONS-LAY
     "because its arguments are equivalent")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SUBSUMPTION-TEST KWD-JUSTIFICATIONS-TECHNICAL
     "because of a successful subsumption test")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SUBSUMPTION-TEST KWD-JUSTIFICATIONS-LAY
     "because of a successful subsumption test")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SUBSUMPTION-REASONING KWD-JUSTIFICATIONS-TECHNICAL
     "because a subsumed relation is true")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SUBSUMPTION-REASONING KWD-JUSTIFICATIONS-LAY
     "because of it is true of a relation that is a subset of the one we want")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FAILURE KWD-JUSTIFICATIONS-TECHNICAL "could not be proven")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FAILURE KWD-JUSTIFICATIONS-LAY "could not be proven")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-PONENS KWD-JUSTIFICATIONS-TECHNICAL "by Modus Ponens")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-PONENS KWD-JUSTIFICATIONS-LAY
     "because an if-then rule applies")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-TOLLENS KWD-JUSTIFICATIONS-TECHNICAL "by Modus Tollens")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-TOLLENS KWD-JUSTIFICATIONS-TECHNICAL "(p => q, ~q |= ~p)"
     KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-TOLLENS KWD-JUSTIFICATIONS-LAY
     "because an if-then rule was used backwards")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-TOLLENS KWD-JUSTIFICATIONS-LAY
     "(if P then Q with Q false allows us to conclude P)" KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION KWD-JUSTIFICATIONS-TECHNICAL "by And-Introduction")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION KWD-JUSTIFICATIONS-LAY
     "because all parts of an AND expression were true")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION KWD-JUSTIFICATIONS-LAY
     "because parts of an AND expression were true" KWD-JUSTIFICATIONS-PARTIAL)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION KWD-JUSTIFICATIONS-TECHNICAL
     "by Not-Or-Introduction" KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION KWD-JUSTIFICATIONS-LAY
     "because all parts of an OR expression were false" KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION KWD-JUSTIFICATIONS-TECHNICAL "(~p, ~q |= ~(p v q))"
     KWD-JUSTIFICATIONS-REVERSE KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION KWD-JUSTIFICATIONS-LAY
     "(therefore the OR is also false)" KWD-JUSTIFICATIONS-REVERSE KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION KWD-JUSTIFICATIONS-TECHNICAL "by Or-Introduction")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION KWD-JUSTIFICATIONS-LAY
     "because at least one part of an OR expression was true")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION KWD-JUSTIFICATIONS-TECHNICAL
     "by Not-And-Introduction" KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION KWD-JUSTIFICATIONS-LAY
     "because at least one part of an AND expression was false" KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION KWD-JUSTIFICATIONS-TECHNICAL "(~p |= ~(p & q))"
     KWD-JUSTIFICATIONS-REVERSE KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION KWD-JUSTIFICATIONS-LAY
     "(therefore the AND is also false)" KWD-JUSTIFICATIONS-REVERSE KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-DISPROOF KWD-JUSTIFICATIONS-TECHNICAL "by disproof")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-DISPROOF KWD-JUSTIFICATIONS-LAY "by proving the negation")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-DISPROOF KWD-JUSTIFICATIONS-TECHNICAL
     "by Double-Negation-Introduction" KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-DISPROOF KWD-JUSTIFICATIONS-LAY "by negating a negation"
     KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FAIL-INTRODUCTION KWD-JUSTIFICATIONS-TECHNICAL
     "because the argument proposition was not derivable")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FAIL-INTRODUCTION KWD-JUSTIFICATIONS-LAY
     "because the argument proposition could not be proven")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-NEGATED-FAIL KWD-JUSTIFICATIONS-TECHNICAL
     "because the argument proposition was derived and the fail is has negative polarity")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-NEGATED-FAIL KWD-JUSTIFICATIONS-LAY
     "because the argument proposition could be proven and we are trying to disprove the fail")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION KWD-JUSTIFICATIONS-TECHNICAL
     "because the argument proposition was not derivable and it uses closed-world semantics")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION KWD-JUSTIFICATIONS-LAY
     "because the argument proposition could not be proven and it is a closed-world proposition")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION KWD-JUSTIFICATIONS-TECHNICAL
     "by Existential Introduction")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION KWD-JUSTIFICATIONS-LAY
     "because it was true for at least one case")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FORWARD-INFERENCE KWD-JUSTIFICATIONS-TECHNICAL
     "by Forward Inference")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FORWARD-INFERENCE KWD-JUSTIFICATIONS-LAY
     "by forward rule reasoning"))))
