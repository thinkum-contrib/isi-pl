;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997-2000              | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-LOGIC-IN-TRACE-SUBGOALS NULL)
(CL:DEFVAR KWD-LOGIC-IN-TRACE-CLASSIFIER NULL)
(CL:DEFVAR KWD-LOGIC-IN-CLOSED-WORLD NULL)
(CL:DEFVAR KWD-LOGIC-IN-ITERATIVE-DEEPENING NULL)
(CL:DEFVAR KWD-LOGIC-IN-JUSTIFICATIONS NULL)
(CL:DEFVAR KWD-LOGIC-IN-JUST-IN-TIME-INFERENCE NULL)
(CL:DEFVAR KWD-LOGIC-IN-EMIT-THINKING-DOTS NULL)
(CL:DEFVAR KWD-LOGIC-IN-GOAL-TREE NULL)
(CL:DEFVAR KWD-LOGIC-IN-CLASSIFIER-INFERENCES NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-SET-FEATURE NULL)
(CL:DEFVAR KWD-LOGIC-IN-COMMON-LISP NULL)
(CL:DEFVAR KWD-LOGIC-IN-FUNCTION NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-UNSET-FEATURE NULL)
(CL:DEFVAR KWD-LOGIC-IN-REALISTIC NULL)
(CL:DEFVAR KWD-LOGIC-IN-BYE NULL)
(CL:DEFVAR KWD-LOGIC-IN-EXIT NULL)
(CL:DEFVAR KWD-LOGIC-IN-HALT NULL)
(CL:DEFVAR KWD-LOGIC-IN-QUIT NULL)
(CL:DEFVAR KWD-LOGIC-IN-STOP NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-BYE NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-EXIT NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-HALT NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-QUIT NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-STOP NULL)
(CL:DEFVAR KWD-LOGIC-IN-DEFINE NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-IN-MODULE NULL)
(CL:DEFVAR SGT-LOGIC-IN-STELLA-VOID NULL)
(CL:DEFVAR SGT-LOGIC-IN-STELLA-CONS NULL)
(CL:DEFVAR KWD-LOGIC-IN-FINALIZE NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-LOAD NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-DEFMODULE NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-CLEAR-MODULE NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-DEFCLASS NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-DEFSLOT NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-DEFUN NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-DEFMETHOD NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-DEFCONCEPT NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-DEFFUNCTION NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-DEFRELATION NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-DEFOBJECT NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-IN-DIALECT NULL)
(CL:DEFVAR KWD-LOGIC-IN-WHITE-SPACE NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-FALSE NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-DEMO NULL)
(CL:DEFVAR KWD-LOGIC-IN-ERROR NULL)
(CL:DEFVAR KWD-LOGIC-IN-WARNING NULL)
(CL:DEFVAR SGT-LOGIC-IN-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SGT-LOGIC-IN-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-LOGIC-IN-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-MODULE-LOGIC-DIALECT NULL)
(CL:DEFVAR KWD-LOGIC-IN-KIF NULL)
(CL:DEFVAR SGT-LOGIC-IN-STELLA-RELATION NULL)
(CL:DEFVAR SGT-LOGIC-IN-STELLA-MODULE NULL)
(CL:DEFVAR SGT-LOGIC-IN-STELLA-TABLE NULL)
(CL:DEFVAR SGT-LOGIC-IN-STELLA-THING NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-CLASS NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-FUNCTION NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-RELATION NULL)
(CL:DEFVAR SGT-LOGIC-IN-PL-KERNEL-KB-RELATION NULL)
(CL:DEFVAR SGT-LOGIC-IN-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-LOGIC-IN-PL-KERNEL-KB-SYNONYM NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-AND NULL)
(CL:DEFVAR KWD-LOGIC-IN-POLYMORPHIC? NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-TRUE NULL)
(CL:DEFVAR SGT-LOGIC-IN-STELLA-CLASS NULL)
(CL:DEFVAR KWD-LOGIC-IN--> NULL)
(CL:DEFVAR KWD-LOGIC-IN-RANGE NULL)
(CL:DEFVAR KWD-LOGIC-IN-=> NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-BAD? NULL)
(CL:DEFVAR KWD-LOGIC-IN-POLYMORPHIC NULL)
(CL:DEFVAR KWD-LOGIC-IN-DOCUMENTATION NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-DECLARATION-ORIGINATED-PROPOSITIONS NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-DEFINITION-STRING NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-SLOT-OPTION-KEYWORD NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-<=> NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-PRETEND-DEFINITION-STRING NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-KAPPA NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-= NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-AXIOMS-STRING NULL)
(CL:DEFVAR KWD-LOGIC-IN-<= NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-<= NULL)
(CL:DEFVAR KWD-LOGIC-IN-<<= NULL)
(CL:DEFVAR KWD-LOGIC-IN-BACKWARD NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-=> NULL)
(CL:DEFVAR KWD-LOGIC-IN-=>> NULL)
(CL:DEFVAR KWD-LOGIC-IN-FORWARD NULL)
(CL:DEFVAR KWD-LOGIC-IN-<=> NULL)
(CL:DEFVAR KWD-LOGIC-IN-<<=>> NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-FORWARD-AXIOMS-STRING NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-BACKWARD-AXIOMS-STRING NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-FORALL NULL)
(CL:DEFVAR KWD-LOGIC-IN-AND NULL)
(CL:DEFVAR KWD-LOGIC-IN-IMPLIES NULL)
(CL:DEFVAR KWD-LOGIC-IN-FORALL NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-BACKWARD-ONLY? NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-FORWARD-ONLY? NULL)
(CL:DEFVAR KWD-LOGIC-IN-CONSTANT NULL)
(CL:DEFVAR KWD-LOGIC-IN-ASSERT-TRUE NULL)
(CL:DEFVAR KWD-LOGIC-IN-CONCEIVE NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-SUBRELATION-LINK? NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-DEFINSTANCE NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-?SELF NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-CC NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-METHOD-COMMAND? NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-DOCUMENTATION NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-HELP NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOGIC-STARTUP-LOGIC-IN NULL)
(CL:DEFVAR SYM-LOGIC-IN-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *CONTEXT* FALSE-WRAPPER
  NULL-STRING-WRAPPER NIL-LIST TRUE-WRAPPER *WARNIFREDEFINE?*
  *STELLA-VERSION-STRING* *POWERLOOM-VERSION-STRING* *SKOLEM-ID-COUNTER*
  *CHARACTER-UPCASE-TABLE* NULL-CHARACTER *CHARACTER-TYPE-TABLE*
  *LOGIC-DIALECT* *CURRENTFILE* *TRANSLATIONUNITS* *TRANSLATIONPHASE*
  *MODULE* STANDARD-INPUT STANDARD-ERROR *ITERATIVE-DEEPENING-MODE?*
  *RECORD-JUSTIFICATIONS?* *JUST-IN-TIME-FORWARD-INFERENCE?*
  *EMIT-THINKING-DOTS?* STANDARD-OUTPUT EOL))

;;; (DEFGLOBAL *AVAILABLE-POWERLOOM-FEATURES* ...)

(CL:DEFVAR *AVAILABLE-POWERLOOM-FEATURES* NULL
  "List of PowerLoom environment features.")

;;; (DEFGLOBAL *CURRENT-POWERLOOM-FEATURES* ...)

(CL:DEFVAR *CURRENT-POWERLOOM-FEATURES* NULL
  "List of currently enabled PowerLoom environment features.")

;;; (DEFGLOBAL *DEFAULT-POWERLOOM-FEATURES* ...)

(CL:DEFVAR *DEFAULT-POWERLOOM-FEATURES* NULL
  "List of PowerLoom environment features enabled upon call to
'reset-features'.")

;;; (DEFUN PRINT-FEATURES ...)

(CL:DEFUN PRINT-FEATURES ()
  "Print the currently enabled and available PowerLoom environment features."
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "Currently enabled PowerLoom features:" EOL "   "
   *CURRENT-POWERLOOM-FEATURES* EOL EOL "Available PowerLoom features:"
   EOL "   " *AVAILABLE-POWERLOOM-FEATURES* EOL))

;;; (DEFUN (LIST-FEATURES LIST) ...)

(CL:DEFUN LIST-FEATURES ()
  "Return a list containing two lists, a list of currently enabled PowerLoom
features, and a list of all available PowerLoom features."
  (LIST *CURRENT-POWERLOOM-FEATURES* *AVAILABLE-POWERLOOM-FEATURES*))

;;; (DEFUN SET-POWERLOOM-FEATURE ...)

(CL:DEFUN SET-POWERLOOM-FEATURE (FEATURE)
  "Enable the PowerLoom environment feature `feature'."
  (CL:WHEN (CL:NOT (MEMBER? *CURRENT-POWERLOOM-FEATURES* FEATURE))
   (CL:COND
    ((CL:EQ FEATURE KWD-LOGIC-IN-TRACE-SUBGOALS)
     (%ADD-TRACE (CONS-LIST KWD-LOGIC-IN-GOAL-TREE)))
    ((CL:EQ FEATURE KWD-LOGIC-IN-TRACE-CLASSIFIER)
     (%ADD-TRACE (CONS-LIST KWD-LOGIC-IN-CLASSIFIER-INFERENCES)))
    ((CL:EQ FEATURE KWD-LOGIC-IN-CLOSED-WORLD))
    ((CL:EQ FEATURE KWD-LOGIC-IN-ITERATIVE-DEEPENING)
     (CL:SETQ *ITERATIVE-DEEPENING-MODE?* TRUE))
    ((CL:EQ FEATURE KWD-LOGIC-IN-JUSTIFICATIONS)
     (CL:SETQ *RECORD-JUSTIFICATIONS?* TRUE))
    ((CL:EQ FEATURE KWD-LOGIC-IN-JUST-IN-TIME-INFERENCE)
     (CL:SETQ *JUST-IN-TIME-FORWARD-INFERENCE?* TRUE))
    ((CL:EQ FEATURE KWD-LOGIC-IN-EMIT-THINKING-DOTS)
     (CL:SETQ *EMIT-THINKING-DOTS?* TRUE))
    (CL:T (CL:WARN "No such PowerLoom environment feature: `~A'" FEATURE)
     (PRINT-FEATURES) (CL:RETURN-FROM SET-POWERLOOM-FEATURE)))
   (INSERT *CURRENT-POWERLOOM-FEATURES* FEATURE)))

;;; (DEFUN (SET-FEATURE (LIST OF KEYWORD)) ...)

(CL:DEFUN %SET-FEATURE (FEATURES)
  "Enable the PowerLoom environment feature(s) named by `features'.
Return the list of enabled features.  Calling `set-feature' without any
arguments can be used to display the currently enabled features.
The following features are supported:

`just-in-time-inference': Enables interleaving of forward chaining inference
within backward chaining queries.

`iterative-deepening': Tells the query processor to use iterative deepening
instead of a depth-first search to find answers.  This is less efficient
but necessary for some kinds of highly recursive queries.

`trace-subgoals': Enables the generation of subgoaling trace information during
backchaining inference.

`trace-classifier': Tells the classifier to describe the inferences it draws.

`justifications': Enables the generation of justifications during inference
which is a prerequiste for the generation of explanations with `(why)'.

`emit-thinking-dots': Tells PowerLoom to annotate its inference progress by
outputting characters indicating the completion of individual reasoning steps.

`closed-world': Enables global closed-world reasoning.  NOT YET IMPLEMENTED!
"
  (CL:HANDLER-CASE
   (CL:LET* ((FEATURENAME NULL) (ITER-000 FEATURES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ FEATURENAME (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (SET-POWERLOOM-FEATURE (KEYWORDIFY (COERCE-TO-STRING FEATURENAME)))))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))))
  *CURRENT-POWERLOOM-FEATURES*)

(CL:DEFUN SET-FEATURE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-FEATURE ARGUMENTS))

(CL:DEFMACRO SET-FEATURE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Enable the PowerLoom environment feature(s) named by `features'.
Return the list of enabled features.  Calling `set-feature' without any
arguments can be used to display the currently enabled features.
The following features are supported:

`just-in-time-inference': Enables interleaving of forward chaining inference
within backward chaining queries.

`iterative-deepening': Tells the query processor to use iterative deepening
instead of a depth-first search to find answers.  This is less efficient
but necessary for some kinds of highly recursive queries.

`trace-subgoals': Enables the generation of subgoaling trace information during
backchaining inference.

`trace-classifier': Tells the classifier to describe the inferences it draws.

`justifications': Enables the generation of justifications during inference
which is a prerequiste for the generation of explanations with `(why)'.

`emit-thinking-dots': Tells PowerLoom to annotate its inference progress by
outputting characters indicating the completion of individual reasoning steps.

`closed-world': Enables global closed-world reasoning.  NOT YET IMPLEMENTED!
"
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/SET-FEATURE)) (CL:MACRO-FUNCTION (CL:QUOTE SET-FEATURE)))

;;; (DEFUN UNSET-POWERLOOM-FEATURE ...)

(CL:DEFUN UNSET-POWERLOOM-FEATURE (FEATURE)
  "Disable the PowerLoom environment feature `feature'."
  (CL:IF (MEMBER? *CURRENT-POWERLOOM-FEATURES* FEATURE)
   (CL:COND
    ((CL:EQ FEATURE KWD-LOGIC-IN-TRACE-SUBGOALS)
     (%DROP-TRACE (CONS-LIST KWD-LOGIC-IN-GOAL-TREE)))
    ((CL:EQ FEATURE KWD-LOGIC-IN-TRACE-CLASSIFIER)
     (%DROP-TRACE (CONS-LIST KWD-LOGIC-IN-CLASSIFIER-INFERENCES)))
    ((CL:EQ FEATURE KWD-LOGIC-IN-CLOSED-WORLD))
    ((CL:EQ FEATURE KWD-LOGIC-IN-ITERATIVE-DEEPENING)
     (CL:SETQ *ITERATIVE-DEEPENING-MODE?* FALSE))
    ((CL:EQ FEATURE KWD-LOGIC-IN-JUSTIFICATIONS)
     (CL:SETQ *RECORD-JUSTIFICATIONS?* FALSE))
    ((CL:EQ FEATURE KWD-LOGIC-IN-JUST-IN-TIME-INFERENCE)
     (CL:SETQ *JUST-IN-TIME-FORWARD-INFERENCE?* FALSE))
    ((CL:EQ FEATURE KWD-LOGIC-IN-EMIT-THINKING-DOTS)
     (CL:SETQ *EMIT-THINKING-DOTS?* FALSE))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
       FEATURE "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:WHEN (CL:NOT (MEMBER? *AVAILABLE-POWERLOOM-FEATURES* FEATURE))
    (CL:WARN "No such PowerLoom environment feature: `~A'" FEATURE)
    (PRINT-FEATURES)))
  (REMOVE *CURRENT-POWERLOOM-FEATURES* FEATURE))

;;; (DEFUN (UNSET-FEATURE (LIST OF KEYWORD)) ...)

(CL:DEFUN %UNSET-FEATURE (FEATURES)
  "Disable the PowerLoom environment feature(s) named by `features'.
Return the list of enabled features.  Calling `unset-feature' without any
arguments can be used to display the currently enabled features.
See `set-feature' for a description of supported features."
  (CL:HANDLER-CASE
   (CL:LET* ((FEATURENAME NULL) (ITER-000 FEATURES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ FEATURENAME (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (UNSET-POWERLOOM-FEATURE
      (KEYWORDIFY (COERCE-TO-STRING FEATURENAME)))))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))))
  *CURRENT-POWERLOOM-FEATURES*)

(CL:DEFUN UNSET-FEATURE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%UNSET-FEATURE ARGUMENTS))

(CL:DEFMACRO UNSET-FEATURE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Disable the PowerLoom environment feature(s) named by `features'.
Return the list of enabled features.  Calling `unset-feature' without any
arguments can be used to display the currently enabled features.
See `set-feature' for a description of supported features."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/UNSET-FEATURE)) (CL:MACRO-FUNCTION (CL:QUOTE UNSET-FEATURE)))

;;; (DEFUN (RESET-FEATURES (LIST OF KEYWORD)) ...)

(CL:DEFUN RESET-FEATURES ()
  "Reset the PowerLoom environment features to their default settings."
  (CL:LET*
   ((F NULL)
    (ITER-000 (%LIST.THE-CONS-LIST (COPY *CURRENT-POWERLOOM-FEATURES*))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ F (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (CL:NOT (MEMBER? *DEFAULT-POWERLOOM-FEATURES* F))
     (UNSET-POWERLOOM-FEATURE F))))
  (CL:LET*
   ((F NULL)
    (ITER-001 (%LIST.THE-CONS-LIST *DEFAULT-POWERLOOM-FEATURES*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:PROGN (CL:SETQ F (%%VALUE ITER-001))
     (CL:SETQ ITER-001 (%%REST ITER-001)))
    (CL:WHEN (CL:NOT (MEMBER? *CURRENT-POWERLOOM-FEATURES* F))
     (SET-POWERLOOM-FEATURE F))))
  *CURRENT-POWERLOOM-FEATURES*)

;;; (DEFGLOBAL *LOGIC-PROMPT* ...)

(CL:PROGN (CL:DEFVAR *LOGIC-PROMPT* "|= " "The prompt used by the PowerLoom listener.") (CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *LOGIC-PROMPT*)))

;;; (DEFUN PRINT-LOGIC-PROMPT ...)

(CL:DEFUN PRINT-LOGIC-PROMPT ()
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   *LOGIC-PROMPT*))

;;; (DEFGLOBAL *LOGIC-COMMAND-RESULT-INDENT* ...)

(CL:PROGN (CL:DEFVAR *LOGIC-COMMAND-RESULT-INDENT* "") (CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *LOGIC-COMMAND-RESULT-INDENT*)))

;;; (DEFUN PRINT-LOGIC-COMMAND-RESULT ...)

(CL:DEFUN PRINT-LOGIC-COMMAND-RESULT (RESULT RESULTTYPE)
  (CL:SETQ RESULTTYPE RESULTTYPE)
  (CL:LET*
   ((*PRINTMODE* KWD-LOGIC-IN-REALISTIC)
    (*PRETTYPRINTLOGICALFORMS?* TRUE))
   (CL:DECLARE (CL:SPECIAL *PRINTMODE* *PRETTYPRINTLOGICALFORMS?*))
   (CL:WHEN (CL:NOT (CL:EQ RESULT NULL))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     *LOGIC-COMMAND-RESULT-INDENT* RESULT EOL))))

;;; (DEFSPECIAL *CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? ...)

(CL:DEFVAR *CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? FALSE
  "If TRUE exiting from the logic-command loop (or PowerLoom
listener) will be protected by a confirmation dialog.  This is mainly useful
for C++ where exiting the listener will also exit the program.")

;;; (DEFUN (LOGIC-COMMAND-LOOP-EXIT? BOOLEAN BOOLEAN) ...)

(CL:DEFUN LOGIC-COMMAND-LOOP-EXIT? (COMMAND)
  (CL:LET* ((EXIT? FALSE))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE COMMAND)))
    (CL:COND
     ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
      (CL:PROGN
       (CL:COND
        ((CL:OR (CL:EQ COMMAND KWD-LOGIC-IN-BYE)
          (CL:EQ COMMAND KWD-LOGIC-IN-EXIT)
          (CL:EQ COMMAND KWD-LOGIC-IN-HALT)
          (CL:EQ COMMAND KWD-LOGIC-IN-QUIT)
          (CL:EQ COMMAND KWD-LOGIC-IN-STOP))
         (CL:SETQ EXIT? TRUE))
        (CL:T))))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN
       (CL:COND
        ((CL:OR (CL:EQ COMMAND SYM-LOGIC-IN-LOGIC-BYE)
          (CL:EQ COMMAND SYM-LOGIC-IN-LOGIC-EXIT)
          (CL:EQ COMMAND SYM-LOGIC-IN-LOGIC-HALT)
          (CL:EQ COMMAND SYM-LOGIC-IN-LOGIC-QUIT)
          (CL:EQ COMMAND SYM-LOGIC-IN-LOGIC-STOP))
         (CL:SETQ EXIT? TRUE))
        (CL:T))))
     (CL:T)))
   (CL:WHEN (CL:AND EXIT? *CAREFUL-LOGIC-COMMAND-LOOP-EXIT*?)
    (CL:SETQ EXIT? (YES-OR-NO? "Really exit? (yes or no) "))
    (CL:WHEN EXIT?
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL))
    (CL:RETURN-FROM LOGIC-COMMAND-LOOP-EXIT? (CL:VALUES EXIT? TRUE)))
   (CL:VALUES EXIT? EXIT?)))

;;; (DEFUN LOGIC-COMMAND-LOOP ...)

(CL:DEFUN LOGIC-COMMAND-LOOP ()
  (CL:LET*
   ((COMMAND NULL) (RESULT NULL) (RESULTTYPE NULL) (EXIT? FALSE)
    (EXITCOMMAND? FALSE) (ERROR? FALSE))
   (CL:LET* ((*MODULE* *MODULE*) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*)) (CHANGE-MODULE "PL-USER")
    (CL:LOOP
     (CL:TAGBODY
      (CL:HANDLER-CASE
       (CL:PROGN
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         EOL)
        (PRINT-LOGIC-PROMPT)
        (CL:SETQ COMMAND (READ-S-EXPRESSION STANDARD-INPUT))
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         EOL)
        (CL:MULTIPLE-VALUE-SETQ (EXIT? EXITCOMMAND?)
         (LOGIC-COMMAND-LOOP-EXIT? COMMAND))
        (CL:WHEN EXIT? (CL:RETURN))
        (CL:WHEN EXITCOMMAND? (CL:GO :CONTINUE))
        (CL:MULTIPLE-VALUE-SETQ (RESULT RESULTTYPE ERROR?)
         (EVALUATE-LOGIC-COMMAND COMMAND TRUE))
        (CL:WHEN (CL:NOT ERROR?)
         (PRINT-LOGIC-COMMAND-RESULT RESULT RESULTTYPE)))
       (STELLA-EXCEPTION (E)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         (EXCEPTION-MESSAGE E))))
      :CONTINUE)))))

;;; (DEFUN (EVALUATE-LOGIC-COMMAND OBJECT TYPE-SPEC BOOLEAN) ...)

(CL:DEFUN EVALUATE-LOGIC-COMMAND (COMMAND FINALIZE?)
  (CL:LET*
   ((*TRANSLATIONERRORS* 0) (*TRANSLATIONWARNINGS* 0)
    (*IGNORETRANSLATIONERRORS?* FALSE) (*TRANSLATIONUNITS* NULL)
    (*TRANSLATIONPHASE* KWD-LOGIC-IN-DEFINE) (*EVALUATIONTREE* NULL))
   (CL:DECLARE
    (CL:SPECIAL *TRANSLATIONERRORS* *TRANSLATIONWARNINGS*
     *IGNORETRANSLATIONERRORS?* *TRANSLATIONUNITS* *TRANSLATIONPHASE*
     *EVALUATIONTREE*))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM *TRANSLATIONERRORS* *TRANSLATIONWARNINGS*))
   (CL:LET*
    ((OPERATOR NULL) (RESULT NULL) (RESULTTYPE NULL) (ERROR? FALSE))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE COMMAND)))
     (CL:COND
      ((CL:EQ TEST-VALUE-000 SGT-LOGIC-IN-STELLA-CONS)
       (CL:PROGN (CL:SETQ OPERATOR (%%VALUE COMMAND))
        (CL:COND
         ((SUBTYPE-OF-SYMBOL? (SAFE-PRIMARY-TYPE OPERATOR))
          (CL:PROGN
           (CL:COND
            ((CL:EQ OPERATOR SYM-LOGIC-IN-STELLA-IN-MODULE)
             (HANDLE-IN-MODULE-TREE COMMAND FALSE))
            (CL:T
             (CL:COND
              ((DECLARATION-TREE? COMMAND)
               (CL:SETQ *TRANSLATIONUNITS* (LIST))
               (WALK-TOP-LEVEL-TREE COMMAND FALSE)
               (CL:CASE (LENGTH (REVERSE *TRANSLATIONUNITS*))
                (0 (CL:SETQ ERROR? TRUE))
                (1
                 (CL:SETQ RESULT
                  (%TRANSLATION-UNIT.THE-OBJECT
                   (FIRST *TRANSLATIONUNITS*)))
                 (CL:SETQ RESULTTYPE
                  (CL:IF (CL:NOT (CL:EQ RESULT NULL))
                   (PRIMARY-TYPE RESULT) SGT-LOGIC-IN-STELLA-VOID)))
                (CL:OTHERWISE
                 (CL:LET* ((RESULTS NIL))
                  (CL:LET*
                   ((UNIT NULL)
                    (ITER-000 (%LIST.THE-CONS-LIST *TRANSLATIONUNITS*))
                    (COLLECT-000 NULL))
                   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
                    (CL:PROGN (CL:SETQ UNIT (%%VALUE ITER-000))
                     (CL:SETQ ITER-000 (%%REST ITER-000)))
                    (CL:IF (CL:EQ COLLECT-000 NULL)
                     (CL:PROGN
                      (CL:SETQ COLLECT-000
                       (CONS (%TRANSLATION-UNIT.THE-OBJECT UNIT) NIL))
                      (CL:IF (CL:EQ RESULTS NIL)
                       (CL:SETQ RESULTS COLLECT-000)
                       (ADD-CONS-TO-END-OF-CONS-LIST RESULTS
                        COLLECT-000)))
                     (CL:PROGN
                      (CL:SETF (%%REST COLLECT-000)
                       (CONS (%TRANSLATION-UNIT.THE-OBJECT UNIT) NIL))
                      (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
                  (CL:SETQ RESULT RESULTS)
                  (CL:SETQ RESULTTYPE SGT-LOGIC-IN-STELLA-CONS)))))
              ((CL:OR
                (STRING-EQL? (%SYMBOL.SYMBOL-NAME OPERATOR) "IN-PACKAGE")
                (STRING-EQL? (%SYMBOL.SYMBOL-NAME OPERATOR)
                 "in-package")))
              (CL:T
               (CL:MULTIPLE-VALUE-SETQ (RESULT RESULTTYPE ERROR?)
                (%EVALUATE COMMAND))))))))
         (CL:T
          (CL:MULTIPLE-VALUE-SETQ (RESULT RESULTTYPE ERROR?)
           (%EVALUATE COMMAND))))))
      ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
       (CL:PROGN (CL:SETQ RESULT COMMAND)))
      ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
       (CL:PROGN (CL:SETQ RESULT COMMAND)))
      (CL:T
       (CL:MULTIPLE-VALUE-SETQ (RESULT RESULTTYPE ERROR?)
        (%EVALUATE COMMAND)))))
    (CL:SETQ ERROR? (CL:OR ERROR? (TRANSLATION-ERRORS?)))
    (CL:WHEN (CL:AND (CL:NOT ERROR?) FINALIZE?)
     (CL:SETQ *TRANSLATIONPHASE* KWD-LOGIC-IN-FINALIZE)
     (FINALIZE-RELATIONS))
    (CL:VALUES RESULT RESULTTYPE ERROR?))))

;;; (DEFUN LOAD ...)

(CL:DEFUN %LOAD (FILE)
  "Read logic commands from `file' and evaluate them."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
  (CL:WHEN (CL:NOT (PROBE-FILE? FILE))
   (CL:ERROR ">> ERROR: File '~A' does not exist.~%" FILE)
   (CL:RETURN-FROM %LOAD))
  (CL:LET*
   ((TOPLEVELINVOCATION? (CL:EQ *CURRENTFILE* STELLA::NULL-STRING)))
   (CL:LET* ((*CURRENTFILE* (FILE-BASE-NAME FILE)))
    (CL:DECLARE (CL:SPECIAL *CURRENTFILE*))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING *CURRENTFILE*))
    (LOAD-STREAM (NEW-INPUT-FILE-STREAM FILE))
    (CL:WHEN TOPLEVELINVOCATION? (SWEEP-TRANSIENTS)))))

(CL:DEFUN LOAD-EVALUATOR-WRAPPER (ARGUMENTS)
  (%LOAD (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO LOAD (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Read logic commands from `file' and evaluate them."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/LOAD)) (CL:MACRO-FUNCTION (CL:QUOTE LOAD)))

;;; (DEFUN LOAD-STREAM ...)

(CL:DEFUN LOAD-STREAM (STREAM)
  "Read logic commands from `stream' and evaluate them."
  (CL:LET*
   ((CURRENTDIALECT *LOGIC-DIALECT*) (SKIPCOMMAND? FALSE)
    (SEENINMODULE? FALSE) (COMMANDS NIL))
   (CL:LET* ((*LOGIC-DIALECT* CURRENTDIALECT))
    (CL:DECLARE (CL:SPECIAL *LOGIC-DIALECT*))
    (CL:LET* ((*MODULE* *MODULE*) (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CL:LET* ((TREE NULL) (ITER-000 (S-EXPRESSIONS STREAM)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ TREE (%S-EXPRESSION-ITERATOR.VALUE ITER-000))
       (CL:TAGBODY
        (CL:COND
         ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-LOGIC-IN-STELLA-CONS)
          (CL:PROGN
           (CL:MULTIPLE-VALUE-SETQ (SKIPCOMMAND? SEENINMODULE?)
            (HANDLE-IN-MODULE-TREE TREE SEENINMODULE?))
           (CL:WHEN SKIPCOMMAND? (CL:GO :CONTINUE))
           (CL:LET* ((OPERATOR (%%VALUE TREE)))
            (CL:COND
             ((SUBTYPE-OF-SYMBOL? (SAFE-PRIMARY-TYPE OPERATOR))
              (CL:PROGN
               (CL:COND
                ((CL:OR (CL:EQ OPERATOR SYM-LOGIC-IN-STELLA-DEFMODULE)
                  (CL:EQ OPERATOR SYM-LOGIC-IN-STELLA-CLEAR-MODULE)
                  (CL:EQ OPERATOR SYM-LOGIC-IN-STELLA-DEFCLASS)
                  (CL:EQ OPERATOR SYM-LOGIC-IN-STELLA-DEFSLOT)
                  (CL:EQ OPERATOR SYM-LOGIC-IN-STELLA-DEFUN)
                  (CL:EQ OPERATOR SYM-LOGIC-IN-STELLA-DEFMETHOD)
                  (CL:EQ OPERATOR SYM-LOGIC-IN-LOGIC-DEFCONCEPT)
                  (CL:EQ OPERATOR SYM-LOGIC-IN-LOGIC-DEFFUNCTION)
                  (CL:EQ OPERATOR SYM-LOGIC-IN-LOGIC-DEFRELATION)
                  (CL:EQ OPERATOR SYM-LOGIC-IN-LOGIC-DEFOBJECT))
                 (EVALUATE-LOGIC-COMMAND TREE FALSE))
                ((CL:EQ OPERATOR SYM-LOGIC-IN-LOGIC-IN-DIALECT)
                 (EVALUATE-LOGIC-COMMAND TREE FALSE)
                 (CL:SETQ COMMANDS (CONS TREE COMMANDS)))
                (CL:T
                 (CL:IF (CL:NOT (CL:EQ (LOOKUP-COMMAND OPERATOR) NULL))
                  (CL:SETQ COMMANDS (CONS TREE COMMANDS))
                  (EVALUATE-LOGIC-COMMAND TREE FALSE))))))
             (CL:T (EVALUATE-LOGIC-COMMAND TREE FALSE))))))
         (CL:T (EVALUATE-LOGIC-COMMAND TREE FALSE)))
        :CONTINUE)))
     (CL:LET* ((*TRANSLATIONPHASE* KWD-LOGIC-IN-FINALIZE))
      (CL:DECLARE (CL:SPECIAL *TRANSLATIONPHASE*)) (FINALIZE-RELATIONS))
     (CL:LET* ((TREE NULL) (ITER-001 (REVERSE COMMANDS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:PROGN (CL:SETQ TREE (%%VALUE ITER-001))
        (CL:SETQ ITER-001 (%%REST ITER-001)))
       (EVALUATE-LOGIC-COMMAND TREE TRUE)))))))

;;; (DEFSPECIAL *DEMO-LEVEL* ...)

(CL:PROGN (CL:DEFVAR *DEMO-LEVEL* 0) (CL:DECLAIM (CL:TYPE CL:FIXNUM *DEMO-LEVEL*)))

;;; (DEFUN PRINT-DEMO-PROMPT ...)

(CL:DEFUN PRINT-DEMO-PROMPT ()
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   *LOGIC-PROMPT*))

;;; (DEFUN (DEMO-SKIP-TO-COMMAND BOOLEAN) ...)

(CL:DEFUN DEMO-SKIP-TO-COMMAND (STREAM)
  (CL:LET*
   ((CH NULL-CHARACTER) (COMMENT STELLA::NULL-STRING) (EOF? FALSE)
    (ECHO? FALSE) (ECHOSTREAM (%INPUT-STREAM.ECHO-STREAM STREAM)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING COMMENT))
   (CL:LOOP (CL:SETF (%INPUT-STREAM.ECHO-STREAM STREAM) NULL)
    (CL:MULTIPLE-VALUE-SETQ (CH EOF?) (READ-CHARACTER STREAM))
    (CL:WHEN EOF? (CL:RETURN-FROM DEMO-SKIP-TO-COMMAND TRUE))
    (CL:WHEN ECHO?
     (CL:SETF (%INPUT-STREAM.ECHO-STREAM STREAM) ECHOSTREAM))
    (CL:COND
     ((CL:EQ
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY *CHARACTER-TYPE-TABLE*))
        (CL:THE CL:FIXNUM (CL:CHAR-CODE CH)))
       KWD-LOGIC-IN-WHITE-SPACE)
      (CL:WHEN ECHO?
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM ECHOSTREAM) CH)))
     ((CL:EQL CH #\;) (CL:SETQ ECHO? TRUE)
      (CL:SETF (%INPUT-STREAM.ECHO-STREAM STREAM) ECHOSTREAM)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM ECHOSTREAM) CH)
      (CL:MULTIPLE-VALUE-SETQ (COMMENT EOF?) (READ-LINE STREAM))
      (CL:WHEN EOF? (CL:RETURN-FROM DEMO-SKIP-TO-COMMAND TRUE)))
     (CL:T (CL:SETF (%INPUT-STREAM.ECHO-STREAM STREAM) ECHOSTREAM)
      (UNREAD-CHARACTER CH STREAM) (CL:RETURN))))
   FALSE))

;;; (DEFUN (DEMO-PAUSE? BOOLEAN BOOLEAN) ...)

(CL:DEFUN DEMO-PAUSE? (PAUSE?)
  (CL:LET* ((EXIT? FALSE) (INPUT STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING INPUT))
   (CL:COND
    (PAUSE?
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "------ pause ------")
     (CL:SETQ INPUT (READ-LINE STANDARD-INPUT))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL)
     (CL:WHEN (CL:> (CL:THE CL:FIXNUM (CL:LENGTH INPUT)) 0)
      (CL:CASE
       (CL:LET
        ((SELF *CHARACTER-UPCASE-TABLE*)
         (POSITION
          (CL:THE CL:FIXNUM
           (CL:CHAR-CODE
            (CL:LET ((SELF INPUT) (POSITION 0))
             (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
              (CL:TYPE CL:FIXNUM POSITION))
             (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
              (CL:THE CL:FIXNUM POSITION)))))))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION)))
       (#\C (CL:SETQ PAUSE? FALSE))
       (#\Q
        (CL:WHEN (Y-OR-N? "Really exit demo? (y or n) ")
         (CL:SETQ PAUSE? FALSE) (CL:SETQ EXIT? TRUE)))
       ((#\H #\?)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "Type `c' to continue without pausing," EOL
         "     `q' to quit from this demo," EOL
         "     `?' or `h' to get this message," EOL
         "     or any other key to continue." EOL)
        (CL:RETURN-FROM DEMO-PAUSE? (DEMO-PAUSE? PAUSE?)))
       (CL:OTHERWISE))))
    (CL:T
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL)))
   (CL:VALUES PAUSE? EXIT?)))

;;; (DEFUN DEMO-FILE ...)

(CL:DEFUN DEMO-FILE (FILE PAUSE?)
  (CL:WHEN (CL:NOT (PROBE-FILE? FILE))
   (CL:ERROR ">> ERROR: File `~A' does not exist.~%" FILE)
   (CL:RETURN-FROM DEMO-FILE))
  (CL:LET*
   ((CURRENTLEVEL *DEMO-LEVEL*) (COMMAND NULL) (RESULT NULL)
    (RESULTTYPE NULL) (EXIT? FALSE) (ERROR? FALSE)
    (INPUTSTREAM (NEW-INPUT-FILE-STREAM FILE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURRENTLEVEL))
   (CL:LET*
    ((*CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? FALSE)
     (*DEMO-LEVEL* (CL:1+ CURRENTLEVEL)))
    (CL:DECLARE
     (CL:SPECIAL *CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? *DEMO-LEVEL*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *DEMO-LEVEL*))
    (CL:SETF (%INPUT-STREAM.ECHO-STREAM INPUTSTREAM) STANDARD-OUTPUT)
    (CL:LET* ((*MODULE* *MODULE*) (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CL:WHEN PAUSE?
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Now reading from `" FILE "'." EOL
       "Type `?' at the pause prompt for a list of available commands."
       EOL))
     (CL:LOOP
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL)
      (CL:SETQ EXIT? (DEMO-SKIP-TO-COMMAND INPUTSTREAM))
      (PRINT-DEMO-PROMPT)
      (CL:WHEN (CL:NOT EXIT?)
       (CL:MULTIPLE-VALUE-SETQ (COMMAND EXIT?)
        (READ-S-EXPRESSION INPUTSTREAM)))
      (CL:WHEN (CL:OR EXIT? (LOGIC-COMMAND-LOOP-EXIT? COMMAND))
       (CL:RETURN))
      (CL:MULTIPLE-VALUE-SETQ (PAUSE? EXIT?) (DEMO-PAUSE? PAUSE?))
      (CL:WHEN EXIT? (CL:RETURN))
      (CL:MULTIPLE-VALUE-SETQ (RESULT RESULTTYPE ERROR?)
       (EVALUATE-LOGIC-COMMAND COMMAND FALSE))
      (CL:WHEN (CL:NOT ERROR?)
       (PRINT-LOGIC-COMMAND-RESULT RESULT RESULTTYPE)))
     (FREE INPUTSTREAM)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
      EOL *LOGIC-COMMAND-RESULT-INDENT* "Finished demo `" FILE "'." EOL)))))

;;; (DEFGLOBAL *DEMO-FILE-DIRECTORY* ...)

(CL:PROGN (CL:DEFVAR *DEMO-FILE-DIRECTORY* "PL:sources;logic;demos;") (CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *DEMO-FILE-DIRECTORY*)))

;;; (DEFGLOBAL *DEMO-FILE-SUFFIX* ...)

(CL:PROGN (CL:DEFVAR *DEMO-FILE-SUFFIX* ".ste") (CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *DEMO-FILE-SUFFIX*)))

;;; (DEFGLOBAL *DEMO-FILES* ...)

(CL:DEFVAR *DEMO-FILES* NULL
  "List of example demo files.
Each entry is a `(<file> <description>)' pair.")

;;; (DEFUN (DEMO-ENTRY-FILE STRING) ...)

(CL:DEFUN DEMO-ENTRY-FILE (DEMOENTRY)
  (CONCATENATE *DEMO-FILE-DIRECTORY*
   (CONCATENATE (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE DEMOENTRY))
    *DEMO-FILE-SUFFIX*)))

;;; (DEFUN (DEMO-ENTRY-DESCRIPTION STRING) ...)

(CL:DEFUN DEMO-ENTRY-DESCRIPTION (DEMOENTRY)
  (CL:IF (CL:NOT (CL:EQ (%%VALUE (%%REST DEMOENTRY)) NULL))
   (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST DEMOENTRY)))
   (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE DEMOENTRY))))

;;; (DEFUN (DEMO-ENTRY-TEST-SUITE? BOOLEAN) ...)

(CL:DEFUN DEMO-ENTRY-TEST-SUITE? (DEMOENTRY)
  (CL:AND (STRING? (%%VALUE (%%REST (%%REST DEMOENTRY))))
   (STRING-EQL?
    (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST (%%REST DEMOENTRY))))
    "test-suite")))

;;; (DEFUN (SELECT-EXAMPLE-DEMO STRING) ...)

(CL:DEFUN SELECT-EXAMPLE-DEMO (INDEX)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX))
  (CL:LET* ((ENTRY (NTH *DEMO-FILES* (CL:1- INDEX))))
   (CL:IF (CL:NOT (CL:EQ ENTRY NULL)) (DEMO-ENTRY-FILE ENTRY)
    STELLA::NULL-STRING)))

;;; (DEFUN (SELECT-EXAMPLE-DEMO-FROM-MENU STRING) ...)

(CL:DEFUN SELECT-EXAMPLE-DEMO-FROM-MENU ()
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "Choose a demo:" EOL)
  (CL:LET*
   ((I NULL-INTEGER) (ENTRY NULL) (ITER-000 *DEMO-FILES*) (ITER-001 1))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ ENTRY (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "       " I ".  ")
    (CL:WHEN (CL:< I 10)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) " "))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     (DEMO-ENTRY-DESCRIPTION ENTRY) EOL)))
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "       Q.   Quit demoing" EOL)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "Your choice: ")
  (CL:LET*
   ((SELECTION (READ-S-EXPRESSION STANDARD-INPUT))
    (FILE STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? (SAFE-PRIMARY-TYPE SELECTION))
     (CL:PROGN
      (CL:SETQ FILE
       (SELECT-EXAMPLE-DEMO (%INTEGER-WRAPPER.WRAPPER-VALUE SELECTION)))
      (CL:WHEN (CL:NOT (CL:EQ FILE STELLA::NULL-STRING))
       (CL:RETURN-FROM SELECT-EXAMPLE-DEMO-FROM-MENU FILE))))
    (CL:T
     (CL:WHEN (STRING-EQL? (STRINGIFY SELECTION) "Q")
      (CL:RETURN-FROM SELECT-EXAMPLE-DEMO-FROM-MENU
       STELLA::NULL-STRING))))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    ">> ERROR: Illegal choice `" SELECTION
    "'; enter a number between 1 and " (LENGTH *DEMO-FILES*) "!" EOL EOL)
   (SELECT-EXAMPLE-DEMO-FROM-MENU)))

;;; (DEFUN DEMO-EXAMPLE-DEMOS ...)

(CL:DEFUN DEMO-EXAMPLE-DEMOS ()
  (CL:LET* ((FILE STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
   (CL:LOOP
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL)
    (CL:SETQ FILE (SELECT-EXAMPLE-DEMO-FROM-MENU))
    (CL:WHEN (CL:EQ FILE STELLA::NULL-STRING)
     (CL:RETURN-FROM DEMO-EXAMPLE-DEMOS))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL)
    (DEMO-FILE FILE TRUE))))

;;; (DEFUN DEMO ...)

(CL:DEFUN %DEMO (FILEANDPAUSE)
  "Read logic commands from a file, echo them verbatimly to standard output,
and evaluate them just as if they had been typed in interactively.
When called with no arguments, present a menu of example demos, otherwise,
use the first argument as the name of the file to demo.
Pause for user confirmation after each expression has been read but
before it is evaluated.  Pausing can be turned off by suppling FALSE
as the optional second argument, or by typing `c' at the pause prompt.
Typing `?' at the pause prompt prints a list of available commands."
  (CL:LET*
   ((THEFILEANDPAUSE FILEANDPAUSE) (FILESPEC (%%VALUE THEFILEANDPAUSE))
    (PAUSE?
     (CL:NOT
      (CL:EQ (%%VALUE (%%REST THEFILEANDPAUSE))
       SYM-LOGIC-IN-STELLA-FALSE)))
    (FILE STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
   (CL:WHEN (INTEGER? FILESPEC)
    (CL:SETQ FILE
     (SELECT-EXAMPLE-DEMO (%INTEGER-WRAPPER.WRAPPER-VALUE FILESPEC)))
    (CL:IF (CL:NOT (CL:EQ FILE STELLA::NULL-STRING))
     (CL:SETQ FILESPEC (WRAP-STRING FILE)) (CL:SETQ FILESPEC NULL)))
   (CL:IF (CL:EQ FILESPEC NULL) (DEMO-EXAMPLE-DEMOS)
    (CL:COND
     ((SUBTYPE-OF-STRING? (SAFE-PRIMARY-TYPE FILESPEC))
      (CL:PROGN
       (DEMO-FILE (%STRING-WRAPPER.WRAPPER-VALUE FILESPEC) PAUSE?)))
     (CL:T
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       ">> ERROR: Illegal file specification: " FILESPEC))))))

(CL:DEFUN DEMO-EVALUATOR-WRAPPER (ARGUMENTS)
  (%DEMO ARGUMENTS))

(CL:DEFMACRO DEMO (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Read logic commands from a file, echo them verbatimly to standard output,
and evaluate them just as if they had been typed in interactively.
When called with no arguments, present a menu of example demos, otherwise,
use the first argument as the name of the file to demo.
Pause for user confirmation after each expression has been read but
before it is evaluated.  Pausing can be turned off by suppling FALSE
as the optional second argument, or by typing `c' at the pause prompt.
Typing `?' at the pause prompt prints a list of available commands."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/DEMO)) (CL:MACRO-FUNCTION (CL:QUOTE DEMO)))

;;; (DEFUN TEST-LOGIC-FILE ...)

(CL:DEFUN TEST-LOGIC-FILE (FILE)
  (CL:WHEN (CL:NOT (PROBE-FILE? FILE))
   (CL:ERROR ">> ERROR: File `~A' does not exist.~%" FILE)
   (CL:RETURN-FROM TEST-LOGIC-FILE))
  (CL:LET*
   ((CURRENTLEVEL *DEMO-LEVEL*) (COMMAND NULL) (RESULT NULL)
    (RESULTTYPE NULL) (EXIT? FALSE) (ERROR? FALSE)
    (INPUTSTREAM (NEW-INPUT-FILE-STREAM FILE))
    (FILEBASENAME
     (SUBSEQUENCE FILE
      (CL:THE CL:FIXNUM (CL:LENGTH *DEMO-FILE-DIRECTORY*)) NULL-INTEGER)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURRENTLEVEL)
    (CL:TYPE CL:SIMPLE-STRING FILEBASENAME))
   (CL:LET*
    ((*CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? FALSE)
     (*DEMO-LEVEL* (CL:1+ CURRENTLEVEL)) (*PRINTREADABLY?* TRUE)
     (*PRINTPRETTY?* FALSE))
    (CL:DECLARE
     (CL:SPECIAL *CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? *DEMO-LEVEL*
      *PRINTREADABLY?* *PRINTPRETTY?*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *DEMO-LEVEL*))
    (CL:LET* ((*MODULE* *MODULE*) (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
      "Now testing file `" FILEBASENAME "':" EOL)
     (CL:LOOP
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL)
      (PRINT-DEMO-PROMPT)
      (CL:WHEN (CL:NOT EXIT?)
       (CL:MULTIPLE-VALUE-SETQ (COMMAND EXIT?)
        (READ-S-EXPRESSION INPUTSTREAM)))
      (CL:WHEN (CL:OR EXIT? (LOGIC-COMMAND-LOOP-EXIT? COMMAND))
       (CL:RETURN))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       COMMAND EOL EOL)
      (CL:MULTIPLE-VALUE-SETQ (RESULT RESULTTYPE ERROR?)
       (EVALUATE-LOGIC-COMMAND COMMAND FALSE))
      (CL:WHEN (CL:NOT ERROR?)
       (PRINT-LOGIC-COMMAND-RESULT RESULT RESULTTYPE)))
     (FREE INPUTSTREAM)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
      EOL *LOGIC-COMMAND-RESULT-INDENT* "Finished testing file `"
      FILEBASENAME "'." EOL)))))

;;; (DEFUN RUN-POWERLOOM-TESTS ...)

(CL:DEFUN RUN-POWERLOOM-TESTS ()
  "Run the PowerLoom test suite.  Currently this simply runs all demos and
echos commands and their results to standard output.  The output can then
be diffed with previously validated runs to find deviations."
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "RUNNING POWERLOOM TEST SUITE" EOL "============================" EOL
   EOL)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "STELLA version:    " *STELLA-VERSION-STRING* EOL "PowerLoom version: "
   *POWERLOOM-VERSION-STRING* EOL "Current time:      "
   (CL:apply #'CL:format CL:nil "~d/~d/~d ~d:~d:~d"
                           (CL:nthcdr
                            3 (CL:reverse
                               (CL:multiple-value-list
                                   (CL:decode-universal-time
                                    (CL:get-universal-time)))))) EOL EOL)
  (CL:LET* ((PLUSER (GET-STELLA-MODULE "PL-USER" TRUE)))
   (CLEAR-CONTEXT PLUSER)
   (CL:LET*
    ((CHILD NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (COPY (%MODULE.CHILD-CONTEXTS PLUSER)))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ CHILD (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (DESTROY-CONTEXT CHILD)))
   (CL:SETQ *SKOLEM-ID-COUNTER* 0)
   (CL:LET* ((ENTRY NULL) (ITER-001 *DEMO-FILES*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ ENTRY (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:WHEN (DEMO-ENTRY-TEST-SUITE? ENTRY)
      (TEST-LOGIC-FILE (DEMO-ENTRY-FILE ENTRY))))))
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
   "FINISHED RUNNING POWERLOOM TEST SUITE" EOL
   "=====================================" EOL EOL))

;;; (DEFSPECIAL *TERMSOURCEBEINGPARSED* ...)

(CL:PROGN (CL:DEFVAR *TERMSOURCEBEINGPARSED* STELLA::NULL-STRING "Points to the source of the relation being parsed.") (CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *TERMSOURCEBEINGPARSED*)))

;;; (DEFSPECIAL *DESCRIPTIONUNDERCONSTRUCTION* ...)

(CL:DEFVAR *DESCRIPTIONUNDERCONSTRUCTION* NULL
  "Pofints to a description or its parse tree which
is the input to the description being constructed.")

;;; (DEFSPECIAL *TERMUNDERCONSTRUCTION* ...)

(CL:DEFVAR *TERMUNDERCONSTRUCTION* NULL
  "Points to the parse tree which is the input to the
proposition being constructed.")

;;; (DEFGLOBAL *EXPRESSION-SIZE-CUTOFF* ...)

(CL:PROGN (CL:DEFVAR *EXPRESSION-SIZE-CUTOFF* 300 "Limit on how big an s-expression we will print within
an error message.") (CL:DECLAIM (CL:TYPE CL:FIXNUM *EXPRESSION-SIZE-CUTOFF*)))

;;; (DEFUN PRINT-FORMULA-CONTAINING-ERROR ...)

(CL:DEFUN PRINT-FORMULA-CONTAINING-ERROR (SELF STREAM)
  (CL:LET*
   ((TEMP (NEW-OUTPUT-STRING-STREAM))
    (EXPRESSIONSTRING STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING EXPRESSIONSTRING))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM TEMP) SELF)
   (CL:SETQ EXPRESSIONSTRING (THE-STRING-READER TEMP))
   (CL:WHEN
    (CL:> (CL:THE CL:FIXNUM (CL:LENGTH EXPRESSIONSTRING))
     *EXPRESSION-SIZE-CUTOFF*)
    (CL:SETQ EXPRESSIONSTRING
     (CONCATENATE
      (SUBSEQUENCE EXPRESSIONSTRING 0 *EXPRESSION-SIZE-CUTOFF*)
      " ......)")))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EXPRESSIONSTRING)))

;;; (DEFUN HELP-SIGNAL-PROPOSITION-ERROR ...)

(CL:DEFUN HELP-SIGNAL-PROPOSITION-ERROR (STREAM WARNINGORERROR)
  (CL:LET*
   ((BESTOUTPUTOBJECT *TERMUNDERCONSTRUCTION*)
    (TYPENAME
     (CL:IF (CL:NOT (CL:EQ BESTOUTPUTOBJECT NULL)) "proposition"
      "relation")))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TYPENAME))
   (CL:WHEN (CL:EQ BESTOUTPUTOBJECT NULL)
    (CL:SETQ BESTOUTPUTOBJECT *DESCRIPTIONUNDERCONSTRUCTION*))
   (CL:WHEN
    (CL:AND (CL:EQ BESTOUTPUTOBJECT NULL)
     (CL:NOT (CL:EQ *TERMSOURCEBEINGPARSED* STELLA::NULL-STRING)))
    (CL:SETQ BESTOUTPUTOBJECT (WRAP-STRING *TERMSOURCEBEINGPARSED*)))
   (CL:WHEN (CL:NOT (CL:EQ BESTOUTPUTOBJECT NULL))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "   ")
    (CL:COND
     ((CL:EQ WARNINGORERROR KWD-LOGIC-IN-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "Error"))
     ((CL:EQ WARNINGORERROR KWD-LOGIC-IN-WARNING)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "Warning"))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" WARNINGORERROR "' is not a valid case option")
       (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
     " occurred while parsing the " TYPENAME ": ")
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE BESTOUTPUTOBJECT)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-LOGIC-NAMED-DESCRIPTION)
       (CL:PROGN
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
         (RELATION-NAME BESTOUTPUTOBJECT) EOL)
        (CL:RETURN-FROM HELP-SIGNAL-PROPOSITION-ERROR)))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-LOGIC-PROPOSITION)
       (CL:PROGN
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL "   ")
        (PRINT-FORMULA-CONTAINING-ERROR *TERMUNDERCONSTRUCTION* STREAM)))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-LOGIC-DESCRIPTION)
       (CL:PROGN
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL "   ")
        (PRINT-FORMULA-CONTAINING-ERROR *TERMUNDERCONSTRUCTION* STREAM)))
      ((CL:EQ TEST-VALUE-000 SGT-LOGIC-IN-STELLA-CONS)
       (CL:PROGN
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL "   ")
        (PRINT-FORMULA-CONTAINING-ERROR *TERMUNDERCONSTRUCTION* STREAM)))
      ((SUBTYPE-OF-STRING? TEST-VALUE-000)
       (CL:PROGN
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
        (CL:LET*
         ((SEXPRESSION
           (READ-S-EXPRESSION-FROM-STRING
            (%STRING-WRAPPER.WRAPPER-VALUE BESTOUTPUTOBJECT))))
         (PRINT-FORMULA-CONTAINING-ERROR SEXPRESSION STREAM))))
      (CL:T)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL))))

;;; (DEFUN (LOGIC-DIALECT KEYWORD) ...)

(CL:DEFUN LOGIC-DIALECT (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-STELLA-RELATION)
     (CL:PROGN (LOGIC-DIALECT (HOME-MODULE SELF))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-STELLA-MODULE)
     (CL:PROGN
      (CL:LET*
       ((DIALECT
         (DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS SELF)
          SYM-LOGIC-IN-LOGIC-MODULE-LOGIC-DIALECT NULL)))
       (CL:IF (CL:NOT (CL:EQ DIALECT NULL)) DIALECT KWD-LOGIC-IN-KIF))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
       TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (POLYMORPHIC-RELATION? BOOLEAN) ...)

(CL:DEFUN POLYMORPHIC-RELATION? (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND ((SUBTYPE-OF-STORAGE-SLOT? TEST-VALUE-000) (CL:PROGN TRUE))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-STELLA-TABLE)
     (CL:PROGN TRUE))
    (CL:T FALSE))))

;;; (DEFUN (DEFINE-TABLE-FOR-POLYMORPHIC-RELATION RELATION) ...)

(CL:DEFUN DEFINE-TABLE-FOR-POLYMORPHIC-RELATION (NAME PARAMETERTYPES)
  (CL:LET* ((OWNERTYPE (FIRST PARAMETERTYPES)))
   (CL:COND
    ((CL:EQ (%SURROGATE.SURROGATE-VALUE OWNERTYPE) NULL)
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "ERROR: Can't define polymorphic relation named `" NAME "'" EOL
        "   on non-existent class `" OWNERTYPE "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-LOGIC-IN-ERROR))
      (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
    ((CL:EQ OWNERTYPE SGT-LOGIC-IN-STELLA-THING)
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
        "ERROR: Can't define polymorphic relation named `" NAME "'" EOL
        "   on the class 'THING'.." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-LOGIC-IN-ERROR))
      (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001))))))
   (CL:LET* ((SELF-004 (NEW-TABLE)))
    (CL:SETF (%TABLE.SLOT-NAME SELF-004) NAME)
    (CL:SETF (%TABLE.SLOT-OWNER SELF-004) OWNERTYPE)
    (CL:SETF (%TABLE.SLOT-EXTERNAL? SELF-004) TRUE)
    (CL:LET* ((TABLE SELF-004)) (CL:SETF (%TABLE.ABSTRACT? TABLE) TRUE)
     (ATTACH-SLOT-TO-OWNER TABLE) TABLE))))

;;; (DEFUN (NAME-DESCRIPTION-METACLASS SYMBOL) ...)

(CL:DEFUN NAME-DESCRIPTION-METACLASS (DESCRIPTION)
  (CL:COND ((CLASS-DESCRIPTION? DESCRIPTION) SYM-LOGIC-IN-STELLA-CLASS)
   ((FUNCTION-DESCRIPTION? DESCRIPTION) SYM-LOGIC-IN-STELLA-FUNCTION)
   (CL:T SYM-LOGIC-IN-STELLA-RELATION)))

;;; (DEFUN (CLEAR-DECKS-FOR-BINDING-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN CLEAR-DECKS-FOR-BINDING-DESCRIPTION? (NAME)
  (CL:WHEN (CL:NOT (CLEARABLE? *MODULE*))
   (CL:WARN "Can't define relation `~A' in the unclearable module: `~A'~%"
    NAME *MODULE*)
   (CL:RETURN-FROM CLEAR-DECKS-FOR-BINDING-DESCRIPTION? FALSE))
  (CL:LET*
   ((OLDSURROGATE (LOOKUP-SURROGATE (%SYMBOL.SYMBOL-NAME NAME)))
    (OLDVALUE
     (CL:IF (CL:NOT (CL:EQ OLDSURROGATE NULL))
      (%SURROGATE.SURROGATE-VALUE OLDSURROGATE) NULL))
    (OLDMODULE
     (CL:IF (CL:NOT (CL:EQ OLDSURROGATE NULL))
      (%SURROGATE.HOME-CONTEXT OLDSURROGATE) NULL)))
   (CL:WHEN (CL:NOT (CL:EQ OLDVALUE NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OLDVALUE)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-LOGIC-DESCRIPTION)
       (CL:PROGN))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-LOGIC-LOGIC-OBJECT)
       (CL:PROGN
        (CL:WHEN (TEST-ISA? OLDVALUE SGT-LOGIC-IN-PL-KERNEL-KB-RELATION)
         (CL:SETQ OLDVALUE NULL))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-STELLA-RELATION)
       (CL:PROGN))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-STELLA-MODULE) (CL:PROGN))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-LOGIC-PROPOSITION)
       (CL:PROGN))
      ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000) (CL:PROGN))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "`" TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ OLDVALUE NULL))
     (CL:NOT (CL:EQ OLDMODULE *MODULE*)))
    (CL:WHEN *WARNIFREDEFINE?*
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Defining `" NAME "' would cause another term named `" NAME "'" EOL
      "   in module `" OLDMODULE "' to be shadowed." EOL)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "CAUTION: Automatic shadowing can be dangerous, because forward "
      EOL
      "   references to a shadowed object may be bound to the now-shadowed "
      EOL "   object.  Suggestion: Explicitly shadow the name using" EOL
      "   DEFMODULE's `:shadow' option." EOL)
     (CL:IF (YES-OR-NO? "Do it anyway? ")
      (CL:PROGN (SHADOW-SURROGATE (%SYMBOL.SYMBOL-NAME NAME))
       (CL:RETURN-FROM CLEAR-DECKS-FOR-BINDING-DESCRIPTION? TRUE))
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "Skipping definition of `" NAME "'" EOL EOL)
       (CL:RETURN-FROM CLEAR-DECKS-FOR-BINDING-DESCRIPTION? FALSE)))))
   TRUE))

;;; (DEFUN (BIND-DESCRIPTION-TO-SURROGATE? BOOLEAN) ...)

(CL:DEFUN BIND-DESCRIPTION-TO-SURROGATE? (NAME DESCRIPTION STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
  (CL:LET*
   ((OLDSURROGATE (LOOKUP-SURROGATE (%SYMBOL.SYMBOL-NAME NAME)))
    (OLDVALUE
     (CL:IF (CL:NOT (CL:EQ OLDSURROGATE NULL))
      (%SURROGATE.SURROGATE-VALUE OLDSURROGATE) NULL))
    (STANDIN NULL))
   (CL:WHEN (CL:NOT (CL:EQ OLDVALUE NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OLDVALUE)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-LOGIC-DESCRIPTION)
       (CL:PROGN))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-LOGIC-LOGIC-OBJECT)
       (CL:PROGN
        (CL:WHEN TRUE (CL:SETQ STANDIN OLDVALUE)
         (CL:SETF (%SURROGATE.SURROGATE-VALUE OLDSURROGATE) NULL))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-STELLA-RELATION)
       (CL:PROGN))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-STELLA-MODULE) (CL:PROGN))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-LOGIC-PROPOSITION)
       (CL:PROGN))
      ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000) (CL:PROGN))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "`" TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
   (CL:LET* ((SUCCESS? FALSE) (SURROGATEVALUE NULL) (SURROGATE NULL))
    (CL:MULTIPLE-VALUE-SETQ (SUCCESS? SURROGATEVALUE SURROGATE)
     (BIND-TO-SURROGATE? DESCRIPTION (%SYMBOL.SYMBOL-NAME NAME) TRUE
      FALSE))
    (CL:PROGN)
    (CL:COND
     (SUCCESS?
      (CL:SETF (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE DESCRIPTION)
       SURROGATE)
      (CL:SETF
       (%NAMED-DESCRIPTION.RELATION-STRINGIFIED-SOURCE DESCRIPTION)
       STRINGIFIEDSOURCE)
      (CL:COND
       ((CL:NOT (CL:EQ STANDIN NULL))
        (TRANSFER-PROPOSITIONS-AND-BACKLINKS STANDIN DESCRIPTION)
        (DELETED?-SETTER STANDIN TRUE))
       ((CL:AND (CL:NOT (CL:EQ OLDVALUE NULL))
         (ISA? OLDVALUE SGT-LOGIC-IN-LOGIC-NAMED-DESCRIPTION))
        (CL:LET*
         ((ORIGINATEDPROPS (DECLARATION-ORIGINATED-PROPOSITIONS OLDVALUE))
          (EXCEPTPROPS (COPY ORIGINATEDPROPS)))
         (CL:LET*
          ((PROP NULL) (ITER-000 (%LIST.THE-CONS-LIST ORIGINATEDPROPS)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
           (CL:PROGN (CL:SETQ PROP (%%VALUE ITER-000))
            (CL:SETQ ITER-000 (%%REST ITER-000)))
           (CL:LET*
            ((SATELLITE NULL)
             (ITER-001
              (%LIST.THE-CONS-LIST (SATELLITE-PROPOSITIONS PROP))))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
             (CL:PROGN (CL:SETQ SATELLITE (%%VALUE ITER-001))
              (CL:SETQ ITER-001 (%%REST ITER-001)))
             (INSERT-NEW EXCEPTPROPS SATELLITE)))))
         (TRANSFER-PROPOSITIONS-EXCEPT-FOR OLDVALUE DESCRIPTION
          EXCEPTPROPS)
         (TRANSFER-DESCRIPTION-EXTENSION OLDVALUE DESCRIPTION)
         (TRANSFER-SYNONYMS OLDVALUE DESCRIPTION)
         (CL:LET*
          ((PROP NULL) (ITER-002 (%LIST.THE-CONS-LIST ORIGINATEDPROPS)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
           (CL:PROGN (CL:SETQ PROP (%%VALUE ITER-002))
            (CL:SETQ ITER-002 (%%REST ITER-002)))
           (DESTROY-PROPOSITION PROP)))
         (DESTROY-TERM OLDVALUE))))
      (CL:RETURN-FROM BIND-DESCRIPTION-TO-SURROGATE? TRUE))
     (CL:T))
    (CL:WARN
     "Can't define a `~A' named `~A' in module `~A'~%   because that term is already defined."
     (NAME-DESCRIPTION-METACLASS DESCRIPTION) NAME *MODULE*)
    FALSE)))

;;; (DEFUN TRANSFER-SYNONYMS ...)

(CL:DEFUN TRANSFER-SYNONYMS (OLDDESCRIPTION NEWDESCRIPTION)
  (CL:LET*
   ((P NULL)
    (ITER-000
     (ALL-TRUE-DEPENDENT-PROPOSITIONS OLDDESCRIPTION
      SGT-LOGIC-IN-PL-KERNEL-KB-SYNONYM FALSE)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ P (%TRUE-DEPENDENT-PROPOSITIONS-ITERATOR.VALUE ITER-000))
    (CL:WHEN
     (CL:EQ
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
       0)
      OLDDESCRIPTION)
     (ASSERT-TUPLE SGT-LOGIC-IN-PL-KERNEL-KB-SYNONYM
      (CONS-LIST NEWDESCRIPTION
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
        1)))
     (CL:SETF
      (%SURROGATE.SURROGATE-VALUE
       (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
         1)))
      NEWDESCRIPTION)))))

;;; (DEFUN (COERCE-TO-BOUND-OR-LOCAL-SURROGATE SURROGATE) ...)

(CL:DEFUN COERCE-TO-BOUND-OR-LOCAL-SURROGATE (SELF)
  (CL:LET* ((SURROGATE NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ SURROGATE SELF)))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ SURROGATE
        (LOOKUP-SURROGATE-IN-MODULE (%SYMBOL.SYMBOL-NAME SELF) *MODULE*
         FALSE))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ SURROGATE NULL))
     (CL:OR (CL:EQ (%SURROGATE.HOME-CONTEXT SURROGATE) *MODULE*)
      (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SURROGATE) NULL))))
    (CL:RETURN-FROM COERCE-TO-BOUND-OR-LOCAL-SURROGATE SURROGATE))
   (SHADOW-SURROGATE (%GENERALIZED-SYMBOL.SYMBOL-NAME SELF))))

;;; (DEFUN HELP-ASSERT-KEYWORD-AXIOM ...)

(CL:DEFUN HELP-ASSERT-KEYWORD-AXIOM (RELATIONREF SELF VALUE)
  (CL:COND
   ((SUBTYPE-OF-STRING? (SAFE-PRIMARY-TYPE VALUE))
    (CL:PROGN (CL:SETQ VALUE (EVALUATE-TERM VALUE))))
   (CL:T (CL:SETQ VALUE (CONCEIVE-TERM VALUE))))
  (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
   (CL:LET* ((P (ASSERT-BINARY-VALUE RELATIONREF SELF VALUE)))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-LOGIC-NAMED-DESCRIPTION)
       (CL:PROGN (LINK-RELATION-ORIGINATED-PROPOSITION SELF P)))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-LOGIC-IN-LOGIC-LOGIC-OBJECT)
       (CL:PROGN))
      (CL:T))))))

;;; (DEFUN ASSERT-KEYWORD-AXIOM ...)

(CL:DEFUN ASSERT-KEYWORD-AXIOM (SELF KEY VALUE)
  (CL:LET*
   ((RELATIONREF (INTERN-SURROGATE (%KEYWORD.SYMBOL-NAME KEY)))
    (RELATION (%SURROGATE.SURROGATE-VALUE RELATIONREF)))
   (CL:IF (RELATION? RELATION)
    (CL:COND
     ((CL:EQ (SAFE-PRIMARY-TYPE VALUE) SGT-LOGIC-IN-STELLA-CONS)
      (CL:PROGN
       (CL:LET* ((V NULL) (ITER-000 VALUE))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:PROGN (CL:SETQ V (%%VALUE ITER-000))
          (CL:SETQ ITER-000 (%%REST ITER-000)))
         (HELP-ASSERT-KEYWORD-AXIOM RELATIONREF SELF V)))))
     (CL:T (HELP-ASSERT-KEYWORD-AXIOM RELATIONREF SELF VALUE)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "Skipping keyword option: `" (CONS KEY (CONS VALUE NIL)) "'" EOL
     "   No such relation." EOL EOL))))

;;; (DEFUN DECLARATION-KEYWORD-AXIOMS-HANDLER ...)

(CL:DEFUN DECLARATION-KEYWORD-AXIOMS-HANDLER (SELF KEY VALUE)
  (CL:LET* ((AXIOMS NIL))
   (CL:WHEN
    (CL:NOT
     (RELATION?
      (EVALUATE-TERM (INTERN-SURROGATE (%KEYWORD.SYMBOL-NAME KEY)))))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "Skipping keyword option: `" (CONS KEY (CONS VALUE NIL)) "'" EOL
     "   No such relation." EOL EOL)
    (CL:RETURN-FROM DECLARATION-KEYWORD-AXIOMS-HANDLER))
   (CL:LET*
    ((VAL NULL) (ITER-000 (CL:IF (CONS? VALUE) VALUE (CONS VALUE NIL)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ VAL (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CONS (INTERN-SYMBOL (%KEYWORD.SYMBOL-NAME KEY))
          (CONS (DESCRIPTION-NAME SELF) (CONS VAL NIL)))
         NIL))
       (CL:IF (CL:EQ AXIOMS NIL) (CL:SETQ AXIOMS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST AXIOMS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CONS (INTERN-SYMBOL (%KEYWORD.SYMBOL-NAME KEY))
          (CONS (DESCRIPTION-NAME SELF) (CONS VAL NIL)))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:CASE (LENGTH AXIOMS)
    (0 (CL:RETURN-FROM DECLARATION-KEYWORD-AXIOMS-HANDLER)) (1)
    (CL:OTHERWISE (CL:SETQ AXIOMS (CONS SYM-LOGIC-IN-STELLA-AND AXIOMS))))
   (DECLARATION-AXIOMS-HANDLER SELF NULL AXIOMS)))

;;; (DEFUN (HELP-DEFINE-RELATION-FROM-PARSE-TREE NAMED-DESCRIPTION) ...)

(CL:DEFUN HELP-DEFINE-RELATION-FROM-PARSE-TREE (TREE STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
  (CL:LET* ((NAME NULL) (RETURNVARIABLE NULL))
   (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
    (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000) (NTH-REST TREE 3))
    (CL:LET*
     ((OPTIONS SELF-000)
      (CLASS?
       (MEMBER?
        (GET-QUOTED-TREE "((DEFCLASS DEFCONCEPT) \"/LOGIC\")" "/LOGIC")
        (%%VALUE TREE)))
      (FUNCTION? (CL:EQ (%%VALUE TREE) SYM-LOGIC-IN-LOGIC-DEFFUNCTION))
      (POLYMORPHIC? FALSE) (DESCRIPTION NULL))
     (VET-OPTIONS OPTIONS NULL)
     (CL:COND
      ((CL:EQ (%%VALUE (%%REST TREE)) NULL)
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (CL:LET* ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
          "ERROR: Missing relation name: `" (%%VALUE (%%REST TREE)) "'."
          EOL)
         (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-LOGIC-IN-ERROR))
        (CL:ERROR
         (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
      ((CL:NOT (SYMBOL? (%%VALUE (%%REST TREE))))
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (CL:LET* ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
          "ERROR: Illegal relation name where symbol expected: `"
          (%%VALUE (%%REST TREE)) "'." EOL)
         (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-LOGIC-IN-ERROR))
        (CL:ERROR
         (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001)))))
      (CL:T (CL:SETQ NAME (PERMANENTIFY (%%VALUE (%%REST TREE))))))
     (CL:WHEN (CL:NOT (CONS? (%%VALUE (%%REST (%%REST TREE)))))
      (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
         "ERROR: Illegal relation parameter list: `"
         (%%VALUE (%%REST (%%REST TREE))) "'." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-002 KWD-LOGIC-IN-ERROR))
       (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-002)))))
     (CL:LET*
      ((PARAMETERNAMES NULL) (PARAMETERTYPES NULL) (VARIABLEARITY? FALSE))
      (CL:MULTIPLE-VALUE-SETQ
       (PARAMETERNAMES PARAMETERTYPES VARIABLEARITY?)
       (PARSE-RELATION-PARAMETERS-TREE (%%VALUE (%%REST (%%REST TREE)))))
      (CL:SETQ POLYMORPHIC?
       (CL:EQ (LOOKUP OPTIONS KWD-LOGIC-IN-POLYMORPHIC?)
        SYM-LOGIC-IN-STELLA-TRUE))
      (CL:WHEN (CL:AND POLYMORPHIC? CLASS?)
       (CL:WARN
        "Classes cannot be polymorphic.~%   Polymorphic setting in class `~A' ignored.~%"
        NAME)
       (CL:SETQ POLYMORPHIC? FALSE))
      (CL:WHEN
       (CL:AND POLYMORPHIC?
        (CL:NOT
         (CL:EQ (%SURROGATE.SURROGATE-VALUE (FIRST PARAMETERTYPES)) NULL))
        (CL:NOT
         (ISA? (%SURROGATE.SURROGATE-VALUE (FIRST PARAMETERTYPES))
          SGT-LOGIC-IN-STELLA-CLASS)))
       (CL:WARN
        "Can't define a polymorphic relation on a non-native class   Polymorphic setting in relation `~A' ignored.~%"
        NAME)
       (CL:SETQ POLYMORPHIC? FALSE))
      (CL:LET* ((V-081 (LOOKUP OPTIONS KWD-LOGIC-IN-->)))
       (CL:WHEN (CL:EQ V-081 NULL)
        (CL:SETQ V-081 (LOOKUP OPTIONS KWD-LOGIC-IN-RANGE)))
       (CL:SETQ RETURNVARIABLE V-081))
      (CL:IF FUNCTION?
       (CL:PROGN
        (CL:WHEN (CL:EQ RETURNVARIABLE NULL)
         (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
          (CL:LET* ((*PRINTREADABLY?* TRUE))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003)
            "ERROR: Missing return value (':->') clause for 'deffunction'."
            EOL)
           (HELP-SIGNAL-PROPOSITION-ERROR STREAM-003 KWD-LOGIC-IN-ERROR))
          (CL:ERROR
           (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-003)))))
        (CL:LET* ((NAMES NULL) (TYPES NULL) (DUMMY FALSE))
         (CL:MULTIPLE-VALUE-SETQ (NAMES TYPES DUMMY)
          (PARSE-RELATION-PARAMETERS-TREE (CONS RETURNVARIABLE NIL)))
         (INSERT-LAST PARAMETERNAMES (FIRST NAMES))
         (INSERT-LAST PARAMETERTYPES (FIRST TYPES))))
       (CL:WHEN (CL:NOT (CL:EQ RETURNVARIABLE NULL))
        (CL:LET* ((STREAM-004 (NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((*PRINTREADABLY?* TRUE))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-004)
           "ERROR: 'defrelation' does not allow a return value (':->') clause.."
           EOL)
          (HELP-SIGNAL-PROPOSITION-ERROR STREAM-004 KWD-LOGIC-IN-ERROR))
         (CL:ERROR
          (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-004))))))
      (CL:SETQ DESCRIPTION
       (GET-IDENTICAL-RELATION NAME (FIRST PARAMETERTYPES) POLYMORPHIC?
        STRINGIFIEDSOURCE))
      (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
       (CL:RETURN-FROM HELP-DEFINE-RELATION-FROM-PARSE-TREE DESCRIPTION))
      (CL:WHEN (CL:NOT (CLEAR-DECKS-FOR-BINDING-DESCRIPTION? NAME))
       (CL:RETURN-FROM HELP-DEFINE-RELATION-FROM-PARSE-TREE NULL))
      (CL:WHEN (CL:AND CLASS? (CL:NOT (CL:EQ PARAMETERTYPES NULL)))
       (CL:LET* ((SUPERTYPE (FIRST PARAMETERTYPES)))
        (CL:WHEN (CL:NOT (CL:EQ SUPERTYPE SGT-LOGIC-IN-STELLA-THING))
         (CL:LET* ((CONSTRAINTS (LOOKUP OPTIONS KWD-LOGIC-IN-=>)))
          (CL:SETQ CONSTRAINTS
           (CL:IF (CL:EQ CONSTRAINTS NULL)
            (CONS (SURROGATE-TO-SYMBOL SUPERTYPE)
             (CONS (FIRST PARAMETERNAMES) NIL))
            (LIST* SYM-LOGIC-IN-STELLA-AND
             (CONS (SURROGATE-TO-SYMBOL SUPERTYPE)
              (CONS (FIRST PARAMETERNAMES) NIL))
             CONSTRAINTS NIL)))
          (INSERT-AT OPTIONS KWD-LOGIC-IN-=> CONSTRAINTS))))
       (FIRST-SETTER PARAMETERTYPES
        (COERCE-TO-BOUND-OR-LOCAL-SURROGATE NAME)))
      (CL:SETQ DESCRIPTION
       (CREATE-PRIMITIVE-DESCRIPTION PARAMETERNAMES PARAMETERTYPES
        VARIABLEARITY? CLASS? FUNCTION? *MODULE*))
      (CL:SETQ *DESCRIPTIONUNDERCONSTRUCTION* DESCRIPTION)
      (SET-DYNAMIC-SLOT-VALUE
       (%NAMED-DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
       SYM-LOGIC-IN-STELLA-BAD? TRUE-WRAPPER NULL)
      (CL:IF POLYMORPHIC?
       (CL:LET* ((RELATION NULL))
        (CL:SETQ RELATION
         (DEFINE-TABLE-FOR-POLYMORPHIC-RELATION NAME PARAMETERTYPES))
        (LINK-STELLA-RELATION-AND-DESCRIPTION RELATION DESCRIPTION))
       (CL:WHEN
        (CL:NOT
         (BIND-DESCRIPTION-TO-SURROGATE? NAME DESCRIPTION
          STRINGIFIEDSOURCE))
        (CL:RETURN-FROM HELP-DEFINE-RELATION-FROM-PARSE-TREE NULL)))
      (ENSURE-DESCRIPTION-BODY DESCRIPTION)
      (CL:LET*
       ((VALUE NULL) (KEY NULL)
        (ITER-000 (%PROPERTY-LIST.THE-PLIST OPTIONS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ KEY (%%VALUE ITER-000))
        (CL:PROGN (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
         (CL:SETQ ITER-000 (%%REST (%%REST ITER-000))))
        (CL:LET* ((TEST-VALUE-000 KEY))
         (CL:COND
          ((CL:OR (CL:EQ TEST-VALUE-000 KWD-LOGIC-IN-POLYMORPHIC)
            (CL:EQ TEST-VALUE-000 KWD-LOGIC-IN-->)
            (CL:EQ TEST-VALUE-000 KWD-LOGIC-IN-RANGE)))
          ((CL:EQ TEST-VALUE-000 KWD-LOGIC-IN-DOCUMENTATION)
           (CL:WHEN (CL:NOT (STRING? VALUE))
            (CL:LET* ((STREAM-005 (NEW-OUTPUT-STRING-STREAM)))
             (CL:LET* ((*PRINTREADABLY?* TRUE))
              (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
              (%%PRINT-STREAM
               (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-005)
               "ERROR: Illegal :documentation argument: `" VALUE "'." EOL)
              (HELP-SIGNAL-PROPOSITION-ERROR STREAM-005
               KWD-LOGIC-IN-ERROR))
             (CL:ERROR
              (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-005)))))
           (CL:SETF (%NAMED-DESCRIPTION.DOCUMENTATION DESCRIPTION)
            (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
          (CL:T
           (CL:WHEN (CL:NOT (RUN-OPTION-HANDLER? DESCRIPTION KEY VALUE))
            (DECLARATION-KEYWORD-AXIOMS-HANDLER DESCRIPTION KEY
             VALUE)))))))
      (SET-DYNAMIC-SLOT-VALUE
       (%NAMED-DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
       SYM-LOGIC-IN-STELLA-BAD? NULL NULL)
      DESCRIPTION)))))

;;; (DEFUN (SEQUENCE-VARIABLE? BOOLEAN) ...)

(CL:DEFUN SEQUENCE-VARIABLE? (SELF)
  FALSE)

;;; (DEFUN (PARSE-RELATION-PARAMETERS-TREE (LIST OF SYMBOL) (LIST OF TYPE) BOOLEAN) ...)

(CL:DEFUN PARSE-RELATION-PARAMETERS-TREE (PARAMETERS)
  (CL:WHEN (CL:EQ PARAMETERS NULL)
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "ERROR: Missing concept or relation parameters." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-LOGIC-IN-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:LET*
   ((NAME NULL) (TYPE NULL) (PARAMETERNAMES (NEW-LIST))
    (PARAMETERTYPES (NEW-LIST)) (VARIABLEARITY? FALSE))
   (CL:LET* ((P NULL) (ITER-000 PARAMETERS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ P (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE P)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 SGT-LOGIC-IN-STELLA-CONS)
        (CL:PROGN
         (CL:WHEN
          (CL:NOT
           (CL:AND (CL:= (LENGTH P) 2) (SYMBOL? (%%VALUE P))
            (SYMBOL? (%%VALUE (%%REST P)))))
          (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
           (CL:LET* ((*PRINTREADABLY?* TRUE))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
             "ERROR: Illegal parameter: `" P "'." EOL)
            (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-LOGIC-IN-ERROR))
           (CL:ERROR
            (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001)))))
         (CL:SETQ NAME (%%VALUE P))
         (CL:WHEN (CL:NOT (QUESTION-MARK-SYMBOL? NAME))
          (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
           (CL:LET* ((*PRINTREADABLY?* TRUE))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
             "ERROR: Expected a question mark variable: `" NAME "'." EOL)
            (HELP-SIGNAL-PROPOSITION-ERROR STREAM-002 KWD-LOGIC-IN-ERROR))
           (CL:ERROR
            (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-002)))))
         (CL:SETQ TYPE (%%VALUE (%%REST P)))))
       ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
        (CL:PROGN (CL:SETQ NAME P)
         (CL:WHEN (CL:NOT (QUESTION-MARK-SYMBOL? NAME))
          (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
           (CL:LET* ((*PRINTREADABLY?* TRUE))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003)
             "ERROR: Expected a question mark variable: `" NAME "'." EOL)
            (HELP-SIGNAL-PROPOSITION-ERROR STREAM-003 KWD-LOGIC-IN-ERROR))
           (CL:ERROR
            (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-003)))))
         (CL:SETQ TYPE SGT-LOGIC-IN-STELLA-THING)))
       (CL:T
        (CL:LET* ((STREAM-004 (NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((*PRINTREADABLY?* TRUE))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-004)
           "ERROR: Illegal parameter: `" P "'." EOL)
          (HELP-SIGNAL-PROPOSITION-ERROR STREAM-004 KWD-LOGIC-IN-ERROR))
         (CL:ERROR
          (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-004)))))))
     (CL:WHEN (SEQUENCE-VARIABLE? NAME) (CL:SETQ VARIABLEARITY? TRUE))
     (CL:WHEN (MEMBER? PARAMETERNAMES NAME)
      (CL:LET* ((STREAM-005 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-005)
         "ERROR: Duplicate relation parameter name: `" NAME "'." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-005 KWD-LOGIC-IN-ERROR))
       (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-005)))))
     (PUSH PARAMETERNAMES NAME)
     (PUSH PARAMETERTYPES (COERCE-TO-BOUND-OR-LOCAL-SURROGATE TYPE))
     (CL:WHEN VARIABLEARITY? (CL:RETURN))))
   (CL:WHEN (CL:EQ PARAMETERTYPES NULL)
    (CL:LET* ((STREAM-006 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-006)
       "ERROR: Missing relation parameter list." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-006 KWD-LOGIC-IN-ERROR))
     (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-006)))))
   (CL:WHEN (EMPTY? PARAMETERTYPES)
    (CL:LET* ((STREAM-007 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-007)
       "ERROR: Empty relation parameter list." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-007 KWD-LOGIC-IN-ERROR))
     (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-007)))))
   (CL:VALUES (REVERSE PARAMETERNAMES) (REVERSE PARAMETERTYPES)
    VARIABLEARITY?)))

;;; (DEFUN (GET-IDENTICAL-RELATION NAMED-DESCRIPTION) ...)

(CL:DEFUN GET-IDENTICAL-RELATION (NAME OWNER POLYMORPHIC? STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
  (CL:IF (CL:NOT POLYMORPHIC?)
   (CL:LET*
    ((SURROGATE
      (LOOKUP-SURROGATE-IN-MODULE (%SYMBOL.SYMBOL-NAME NAME)
       (%SYMBOL.HOME-CONTEXT NAME) TRUE))
     (SURROGATEVALUE
      (CL:IF (CL:NOT (CL:EQ SURROGATE NULL))
       (%SURROGATE.SURROGATE-VALUE SURROGATE) NULL))
     (DESCRIPTION NULL))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ SURROGATEVALUE NULL))
      (ISA? SURROGATEVALUE SGT-LOGIC-IN-LOGIC-NAMED-DESCRIPTION))
     (CL:SETQ DESCRIPTION SURROGATEVALUE))
    (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
     (CL:WHEN
      (CL:AND
       (CL:NOT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (BAD? DESCRIPTION)))
       (STRING-EQL?
        (%NAMED-DESCRIPTION.RELATION-STRINGIFIED-SOURCE DESCRIPTION)
        STRINGIFIEDSOURCE))
      (CL:RETURN-FROM GET-IDENTICAL-RELATION DESCRIPTION))))
   (CL:LET*
    ((RELATION
      (SAFE-LOOKUP-SLOT (%SURROGATE.SURROGATE-VALUE OWNER) NAME)))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ RELATION NULL))
      (CL:EQ (%SLOT.SLOT-OWNER RELATION) OWNER)
      (STRING-EQL?
       (%NAMED-DESCRIPTION.RELATION-STRINGIFIED-SOURCE
        (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS RELATION)
         SYM-LOGIC-IN-LOGIC-DESCRIPTION NULL))
       STRINGIFIEDSOURCE))
     (CL:RETURN-FROM GET-IDENTICAL-RELATION
      (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS RELATION)
       SYM-LOGIC-IN-LOGIC-DESCRIPTION NULL)))))
  NULL)

(CL:DEFMETHOD DECLARATION-ORIGINATED-PROPOSITIONS ((SELF NAMED-DESCRIPTION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
      SYM-LOGIC-IN-LOGIC-DECLARATION-ORIGINATED-PROPOSITIONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

;;; (DEFUN RELATION-FULL-DEFINITION-HANDLER ...)

(CL:DEFUN RELATION-FULL-DEFINITION-HANDLER (SELF SLOT DEFINITION)
  (CL:SETQ SLOT SLOT)
  (CL:COND
   ((SUBTYPE-OF-STRING? (SAFE-PRIMARY-TYPE DEFINITION))
    (CL:PROGN
     (SET-DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
      SYM-LOGIC-IN-LOGIC-DEFINITION-STRING
      (WRAP-STRING (%STRING-WRAPPER.WRAPPER-VALUE DEFINITION))
      NULL-STRING-WRAPPER)))
   (CL:T
    (SET-DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
     SYM-LOGIC-IN-LOGIC-DEFINITION-STRING
     (WRAP-STRING (STRINGIFY-IN-MODULE DEFINITION (HOME-MODULE SELF)))
     NULL-STRING-WRAPPER))))

;;; (DEFUN RELATION-TERM-DEFINITION-HANDLER ...)

(CL:DEFUN RELATION-TERM-DEFINITION-HANDLER (SELF SLOT DEFINITION)
  (CL:WHEN (FUNCTION-DESCRIPTION? SELF)
   (CL:IF (STRING? DEFINITION)
    (CL:SETQ DEFINITION
     (UNSTRINGIFY-IN-MODULE (%STRING-WRAPPER.WRAPPER-VALUE DEFINITION)
      (HOME-MODULE SELF)))
    (CL:SETQ DEFINITION (PERMANENT-COPY DEFINITION)))
   (SET-DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
    SYM-LOGIC-IN-LOGIC-DEFINITION-STRING
    (WRAP-STRING
     (STRINGIFY-IN-MODULE (COMPLETE-TERM-DEFINITION SELF DEFINITION)
      (HOME-MODULE SELF)))
    NULL-STRING-WRAPPER)
   (CL:RETURN-FROM RELATION-TERM-DEFINITION-HANDLER))
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (CL:LET* ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "ERROR: Can't define `" SELF "' with the definition option `"
     (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
      SYM-LOGIC-IN-STELLA-SLOT-OPTION-KEYWORD NULL)
     "'," EOL "   since it is not a function." EOL)
    (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-LOGIC-IN-ERROR))
   (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))

;;; (DEFUN RELATION-IFF-HANDLER ...)

(CL:DEFUN RELATION-IFF-HANDLER (SELF SLOT DEFINITION)
  (CL:SETQ SLOT SLOT)
  (CL:IF (STRING? DEFINITION)
   (CL:SETQ DEFINITION
    (UNSTRINGIFY-IN-MODULE (%STRING-WRAPPER.WRAPPER-VALUE DEFINITION)
     (HOME-MODULE SELF)))
   (CL:SETQ DEFINITION (PERMANENT-COPY DEFINITION)))
  (SET-DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
   SYM-LOGIC-IN-LOGIC-PRETEND-DEFINITION-STRING
   (WRAP-STRING
    (STRINGIFY-IN-MODULE
     (COMPLETE-RULE-DEFINITION SELF DEFINITION SYM-LOGIC-IN-LOGIC-<=>)
     (HOME-MODULE SELF)))
   NULL-STRING-WRAPPER))

;;; (DEFUN (COMPLETE-TERM-DEFINITION OBJECT) ...)

(CL:DEFUN COMPLETE-TERM-DEFINITION (SELF DEFINITION)
  (CL:LET*
   ((RETURNVARIABLE (LAST (%NAMED-DESCRIPTION.IO-VARIABLE-NAMES SELF))))
   (LIST* SYM-LOGIC-IN-LOGIC-KAPPA
    (YIELD-RELATION-PARAMETERS-TREE SELF TRUE TRUE)
    (CONS
     (LIST* SYM-LOGIC-IN-STELLA-= DEFINITION (CONS RETURNVARIABLE NIL))
     NIL))))

;;; (DEFUN (YIELD-RELATION-PARAMETERS-TREE CONS) ...)

(CL:DEFUN YIELD-RELATION-PARAMETERS-TREE (SELF DROPFUNCTIONPARAMETER? TYPED?)
  (CL:LET* ((PARAMETERLIST NIL) (PARAMETER NULL))
   (CL:LET*
    ((PTYPE NULL) (PNAME NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (%NAMED-DESCRIPTION.IO-VARIABLE-NAMES SELF)))
     (ITER-001
      (%LIST.THE-CONS-LIST (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES SELF))))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:NOT (CL:EQ ITER-001 NIL)))
     DO
     (CL:PROGN (CL:SETQ PNAME (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ PTYPE (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:SETQ PARAMETER PNAME)
     (CL:WHEN
      (CL:AND TYPED? (CL:NOT (CL:EQ PTYPE SGT-LOGIC-IN-STELLA-THING)))
      (CL:SETQ PARAMETER
       (CONS PARAMETER (CONS (SURROGATE-TO-SYMBOL PTYPE) NIL))))
     (CL:SETQ PARAMETERLIST (CONS PARAMETER PARAMETERLIST))))
   (CL:WHEN (CL:AND DROPFUNCTIONPARAMETER? (FUNCTION-DESCRIPTION? SELF))
    (CL:SETQ PARAMETERLIST (%%REST PARAMETERLIST)))
   (REVERSE PARAMETERLIST)))

;;; (DEFUN (ADD-RELATION-AXIOMS OBJECT) ...)

(CL:DEFUN ADD-RELATION-AXIOMS (SELF OLDAXIOMS NEWAXIOMS)
  (CL:SETQ SELF SELF)
  (CL:LET* ((AXIOMS NIL))
   (CL:WHEN (CL:NOT (CL:EQ OLDAXIOMS NULL))
    (CL:COND
     ((CL:EQ (SAFE-PRIMARY-TYPE OLDAXIOMS) SGT-LOGIC-IN-STELLA-CONS)
      (CL:PROGN
       (CL:IF (CL:EQ (%%VALUE OLDAXIOMS) SYM-LOGIC-IN-STELLA-AND)
        (CL:SETQ AXIOMS OLDAXIOMS)
        (CL:SETQ AXIOMS (CONS OLDAXIOMS AXIOMS)))))
     (CL:T (CL:SETQ AXIOMS (CONS OLDAXIOMS AXIOMS)))))
   (CL:WHEN (CL:NOT (CL:EQ NEWAXIOMS NULL))
    (CL:COND
     ((CL:EQ (SAFE-PRIMARY-TYPE NEWAXIOMS) SGT-LOGIC-IN-STELLA-CONS)
      (CL:PROGN
       (CL:COND
        ((CONS? (%%VALUE NEWAXIOMS))
         (CL:SETQ AXIOMS
          (CONCATENATE AXIOMS (CONCATENATE NEWAXIOMS NIL))))
        ((CL:EQ (%%VALUE NEWAXIOMS) SYM-LOGIC-IN-STELLA-AND)
         (CL:IF (CL:EQ AXIOMS NIL) (CL:SETQ AXIOMS NEWAXIOMS)
          (CL:SETQ AXIOMS
           (CONCATENATE AXIOMS (CONCATENATE (%%REST NEWAXIOMS) NIL)))))
        (CL:T
         (CL:SETQ AXIOMS (CONCATENATE AXIOMS (CONS NEWAXIOMS NIL)))))))
     (CL:T (CL:SETQ AXIOMS (CONCATENATE AXIOMS (CONS NEWAXIOMS NIL))))))
   (CL:CASE (LENGTH AXIOMS) (1 (%%VALUE AXIOMS))
    (CL:OTHERWISE
     (CL:WHEN (CL:NOT (CL:EQ (%%VALUE AXIOMS) SYM-LOGIC-IN-STELLA-AND))
      (CL:SETQ AXIOMS (CONS SYM-LOGIC-IN-STELLA-AND AXIOMS)))
     AXIOMS))))

;;; (DEFUN DECLARATION-AXIOMS-HANDLER ...)

(CL:DEFUN DECLARATION-AXIOMS-HANDLER (SELF SLOT AXIOMS)
  (CL:SETQ SLOT SLOT)
  (CL:LET*
   ((OLDAXIOMS
     (%STRING-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
       SYM-LOGIC-IN-LOGIC-AXIOMS-STRING NULL-STRING-WRAPPER)))
    (NEWAXIOMS AXIOMS))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OLDAXIOMS))
   (CL:IF (STRING? AXIOMS)
    (CL:SETQ NEWAXIOMS
     (UNSTRINGIFY-IN-MODULE (%STRING-WRAPPER.WRAPPER-VALUE AXIOMS)
      (HOME-MODULE SELF)))
    (CL:SETQ NEWAXIOMS (PERMANENT-COPY NEWAXIOMS)))
   (SET-DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
    SYM-LOGIC-IN-LOGIC-AXIOMS-STRING
    (WRAP-STRING
     (STRINGIFY-IN-MODULE
      (ADD-RELATION-AXIOMS SELF
       (CL:IF (CL:NOT (CL:EQ OLDAXIOMS STELLA::NULL-STRING))
        (UNSTRINGIFY-IN-MODULE OLDAXIOMS (HOME-MODULE SELF)) NULL)
       NEWAXIOMS)
      (HOME-MODULE SELF)))
    NULL-STRING-WRAPPER)))

;;; (DEFUN DECLARATION-HALF-RULE-HANDLER ...)

(CL:DEFUN DECLARATION-HALF-RULE-HANDLER (SELF SLOT BODY)
  (CL:LET*
   ((KEYWORD
     (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
      SYM-LOGIC-IN-STELLA-SLOT-OPTION-KEYWORD NULL))
    (ARROW NULL) (DIRECTION NULL))
   (CL:COND
    ((CL:EQ KEYWORD KWD-LOGIC-IN-<=)
     (CL:SETQ ARROW SYM-LOGIC-IN-STELLA-<=))
    ((CL:EQ KEYWORD KWD-LOGIC-IN-<<=)
     (CL:SETQ ARROW SYM-LOGIC-IN-STELLA-<=)
     (CL:SETQ DIRECTION KWD-LOGIC-IN-BACKWARD))
    ((CL:EQ KEYWORD KWD-LOGIC-IN-=>)
     (CL:SETQ ARROW SYM-LOGIC-IN-STELLA-=>))
    ((CL:EQ KEYWORD KWD-LOGIC-IN-=>>)
     (CL:SETQ ARROW SYM-LOGIC-IN-STELLA-=>)
     (CL:SETQ DIRECTION KWD-LOGIC-IN-FORWARD))
    ((CL:EQ KEYWORD KWD-LOGIC-IN-<=>)
     (CL:SETQ ARROW SYM-LOGIC-IN-LOGIC-<=>))
    ((CL:EQ KEYWORD KWD-LOGIC-IN-<<=>>)
     (CL:SETQ ARROW SYM-LOGIC-IN-LOGIC-<=>)
     (FINISH-HALF-RULE-HANDLER SELF BODY SYM-LOGIC-IN-STELLA-<=
      KWD-LOGIC-IN-BACKWARD)
     (FINISH-HALF-RULE-HANDLER SELF BODY SYM-LOGIC-IN-STELLA-=>
      KWD-LOGIC-IN-FORWARD)
     (CL:RETURN-FROM DECLARATION-HALF-RULE-HANDLER))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
       KEYWORD "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (FINISH-HALF-RULE-HANDLER SELF BODY ARROW DIRECTION)))

;;; (DEFUN FINISH-HALF-RULE-HANDLER ...)

(CL:DEFUN FINISH-HALF-RULE-HANDLER (SELF BODY ARROW FORWARDORBACKWARD)
  (CL:LET*
   ((OLDSTRING
     (%STRING-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
       SYM-LOGIC-IN-LOGIC-AXIOMS-STRING NULL-STRING-WRAPPER)))
    (NEWRULE NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OLDSTRING))
   (CL:WHEN (CL:EQ BODY NULL)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "ERROR: Missing value for arrow keyword." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-LOGIC-IN-ERROR))
     (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   (CL:WHEN (CL:NOT (CL:EQ FORWARDORBACKWARD NULL))
    (CL:COND
     ((CL:EQ FORWARDORBACKWARD KWD-LOGIC-IN-FORWARD)
      (CL:SETQ OLDSTRING
       (%STRING-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
         SYM-LOGIC-IN-LOGIC-FORWARD-AXIOMS-STRING NULL-STRING-WRAPPER))))
     ((CL:EQ FORWARDORBACKWARD KWD-LOGIC-IN-BACKWARD)
      (CL:SETQ OLDSTRING
       (%STRING-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
         SYM-LOGIC-IN-LOGIC-BACKWARD-AXIOMS-STRING NULL-STRING-WRAPPER))))
     (CL:T
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
        "`" FORWARDORBACKWARD "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
   (CL:IF (STRING? BODY)
    (CL:SETQ BODY
     (UNSTRINGIFY-IN-MODULE (%STRING-WRAPPER.WRAPPER-VALUE BODY)
      (HOME-MODULE SELF)))
    (CL:SETQ BODY (PERMANENT-COPY BODY)))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE BODY) SGT-LOGIC-IN-STELLA-CONS)
     (CL:PROGN
      (CL:IF (CONS? (%%VALUE BODY))
       (CL:LET* ((IT (ALLOCATE-ITERATOR BODY)))
        (CL:LOOP WHILE (NEXT? IT) DO
         (VALUE-SETTER IT
          (COMPLETE-RULE-DEFINITION SELF (%CONS-ITERATOR.VALUE IT)
           ARROW))))
       (CL:SETQ BODY (COMPLETE-RULE-DEFINITION SELF BODY ARROW)))
      (CL:SETQ NEWRULE BODY)))
    (CL:T (CL:SETQ NEWRULE (COMPLETE-RULE-DEFINITION SELF BODY ARROW))))
   (CL:LET*
    ((STRING
      (STRINGIFY-IN-MODULE
       (ADD-RELATION-AXIOMS SELF
        (CL:IF (CL:NOT (CL:EQ OLDSTRING STELLA::NULL-STRING))
         (UNSTRINGIFY-IN-MODULE OLDSTRING (HOME-MODULE SELF)) NULL)
        NEWRULE)
       (HOME-MODULE SELF))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
    (CL:IF (CL:EQ FORWARDORBACKWARD NULL)
     (SET-DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
      SYM-LOGIC-IN-LOGIC-AXIOMS-STRING (WRAP-STRING STRING)
      NULL-STRING-WRAPPER)
     (CL:COND
      ((CL:EQ FORWARDORBACKWARD KWD-LOGIC-IN-FORWARD)
       (SET-DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-LOGIC-IN-LOGIC-FORWARD-AXIOMS-STRING (WRAP-STRING STRING)
        NULL-STRING-WRAPPER))
      ((CL:EQ FORWARDORBACKWARD KWD-LOGIC-IN-BACKWARD)
       (SET-DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-LOGIC-IN-LOGIC-BACKWARD-AXIOMS-STRING (WRAP-STRING STRING)
        NULL-STRING-WRAPPER))
      (CL:T
       (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
         "`" FORWARDORBACKWARD "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002))))))))))

;;; (DEFUN (COMPLETE-RULE-DEFINITION OBJECT) ...)

(CL:DEFUN COMPLETE-RULE-DEFINITION (SELF BODY ARROW)
  (CL:SETQ BODY
   (WRAP-KIF-WITH-FORALL BODY
    (YIELD-RELATION-PARAMETERS-TREE SELF FALSE FALSE)))
  (CL:LET*
   ((GOAL
     (CONS (DESCRIPTION-NAME SELF)
      (CONCATENATE (YIELD-RELATION-PARAMETERS-TREE SELF FALSE FALSE)
       NIL))))
   (LIST* SYM-LOGIC-IN-STELLA-FORALL
    (YIELD-RELATION-PARAMETERS-TREE SELF FALSE FALSE)
    (CONS (CONS ARROW (CONS GOAL (CONS BODY NIL))) NIL))))

;;; (DEFGLOBAL *UNFINALIZED-RELATIONS* ...)

(CL:DEFVAR *UNFINALIZED-RELATIONS* NULL
  "List of relations whose definitions and/or associated
axioms and constraints are not yet processed.")

;;; (DEFUN LINK-RELATION-ORIGINATED-PROPOSITION ...)

(CL:DEFUN LINK-RELATION-ORIGINATED-PROPOSITION (RELATION PROPOSITION)
  (CL:WHEN (NULL-LIST? (DECLARATION-ORIGINATED-PROPOSITIONS RELATION))
   (SET-DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS RELATION)
    SYM-LOGIC-IN-LOGIC-DECLARATION-ORIGINATED-PROPOSITIONS (NEW-LIST)
    NULL))
  (PUSH (DECLARATION-ORIGINATED-PROPOSITIONS RELATION) PROPOSITION))

;;; (DEFUN FINALIZE-META-ASSERTIONS ...)

(CL:DEFUN FINALIZE-META-ASSERTIONS (SELF)
  (CL:LET*
   ((*MODULE* (%NAMED-DESCRIPTION.HOME-CONTEXT SELF))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (ASSERT-ISA-PROPOSITION SELF SGT-LOGIC-IN-PL-KERNEL-KB-RELATION)))

;;; (DEFUN MARK-DIRECTION-OF-TOP-LEVEL-PROPOSITIONS ...)

(CL:DEFUN MARK-DIRECTION-OF-TOP-LEVEL-PROPOSITIONS (PROPOSITION FORWARDORBACKWARD)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-LOGIC-IN-AND)
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:PROGN
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
       (MARK-DIRECTION-OF-TOP-LEVEL-PROPOSITIONS ARG FORWARDORBACKWARD))))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-LOGIC-IN-IMPLIES)
      (CL:EQ TEST-VALUE-000 KWD-LOGIC-IN-FORALL))
     (CL:COND
      ((CL:EQ FORWARDORBACKWARD KWD-LOGIC-IN-BACKWARD)
       (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
        SYM-LOGIC-IN-LOGIC-BACKWARD-ONLY?
        (CL:IF TRUE TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
      ((CL:EQ FORWARDORBACKWARD KWD-LOGIC-IN-FORWARD)
       (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
        SYM-LOGIC-IN-LOGIC-FORWARD-ONLY?
        (CL:IF TRUE TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "`" FORWARDORBACKWARD "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    ((CL:EQ TEST-VALUE-000 KWD-LOGIC-IN-CONSTANT))
    (CL:T
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
       TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))

;;; (DEFUN (HELP-FINALIZE-AXIOMS? (CONS OF PROPOSITION)) ...)

(CL:DEFUN HELP-FINALIZE-AXIOMS? (AXIOMSSTRING SELF FORWARDORBACKWARD)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING AXIOMSSTRING))
  (CL:WHEN (CL:EQ AXIOMSSTRING STELLA::NULL-STRING)
   (CL:RETURN-FROM HELP-FINALIZE-AXIOMS? NULL))
  (CL:LET*
   ((AXIOMSPROPOSITIONS
     (UPDATE-PROPOSITION
      (UNSTRINGIFY-IN-MODULE AXIOMSSTRING (HOME-MODULE SELF))
      KWD-LOGIC-IN-ASSERT-TRUE)))
   (CL:WHEN (CL:EQ AXIOMSPROPOSITIONS NULL)
    (CL:RETURN-FROM HELP-FINALIZE-AXIOMS? NULL))
   (CL:WHEN (CL:NOT (CL:EQ FORWARDORBACKWARD NULL))
    (CL:LET* ((P NULL) (ITER-000 AXIOMSPROPOSITIONS))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:PROGN (CL:SETQ P (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (MARK-DIRECTION-OF-TOP-LEVEL-PROPOSITIONS P FORWARDORBACKWARD))))
   AXIOMSPROPOSITIONS))

;;; (DEFUN FINALIZE-RELATION-AXIOMS ...)

(CL:DEFUN FINALIZE-RELATION-AXIOMS (SELF)
  (CL:LET*
   ((*TERMSOURCEBEINGPARSED*
     (%NAMED-DESCRIPTION.RELATION-STRINGIFIED-SOURCE SELF))
    (*LOGIC-DIALECT* KWD-LOGIC-IN-KIF))
   (CL:DECLARE (CL:SPECIAL *TERMSOURCEBEINGPARSED* *LOGIC-DIALECT*))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING *TERMSOURCEBEINGPARSED*))
   (CL:LET* ((*MODULE* (HOME-MODULE SELF)) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:WHEN
     (CL:AND
      (CL:EQ
       (%STRING-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
         SYM-LOGIC-IN-LOGIC-AXIOMS-STRING NULL-STRING-WRAPPER))
       STELLA::NULL-STRING)
      (CL:EQ
       (%STRING-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
         SYM-LOGIC-IN-LOGIC-BACKWARD-AXIOMS-STRING NULL-STRING-WRAPPER))
       STELLA::NULL-STRING)
      (CL:EQ
       (%STRING-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
         SYM-LOGIC-IN-LOGIC-FORWARD-AXIOMS-STRING NULL-STRING-WRAPPER))
       STELLA::NULL-STRING))
     (CL:RETURN-FROM FINALIZE-RELATION-AXIOMS))
    (SET-DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
     SYM-LOGIC-IN-STELLA-BAD? TRUE-WRAPPER NULL)
    (CL:LET*
     ((AXIOMS
       (HELP-FINALIZE-AXIOMS?
        (%STRING-WRAPPER.WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
          SYM-LOGIC-IN-LOGIC-AXIOMS-STRING NULL-STRING-WRAPPER))
        SELF NULL))
      (BACKWARDAXIOMS
       (HELP-FINALIZE-AXIOMS?
        (%STRING-WRAPPER.WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
          SYM-LOGIC-IN-LOGIC-BACKWARD-AXIOMS-STRING NULL-STRING-WRAPPER))
        SELF KWD-LOGIC-IN-BACKWARD))
      (FORWARDAXIOMS
       (HELP-FINALIZE-AXIOMS?
        (%STRING-WRAPPER.WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
          SYM-LOGIC-IN-LOGIC-FORWARD-AXIOMS-STRING NULL-STRING-WRAPPER))
        SELF KWD-LOGIC-IN-FORWARD)))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (%STRING-WRAPPER.WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
          SYM-LOGIC-IN-LOGIC-PRETEND-DEFINITION-STRING
          NULL-STRING-WRAPPER))
        STELLA::NULL-STRING))
      (UPDATE-PROPOSITION
       (UNSTRINGIFY-IN-MODULE
        (%STRING-WRAPPER.WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
          SYM-LOGIC-IN-LOGIC-PRETEND-DEFINITION-STRING
          NULL-STRING-WRAPPER))
        (HOME-MODULE SELF))
       KWD-LOGIC-IN-CONCEIVE))
     (CL:WHEN
      (CL:AND (CL:EQ AXIOMS NULL) (CL:EQ BACKWARDAXIOMS NULL)
       (CL:EQ FORWARDAXIOMS NULL))
      (CL:RETURN-FROM FINALIZE-RELATION-AXIOMS))
     (CL:WHEN (CL:NOT (CL:EQ AXIOMS NULL))
      (CL:LET* ((P NULL) (ITER-000 AXIOMS))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:PROGN (CL:SETQ P (%%VALUE ITER-000))
         (CL:SETQ ITER-000 (%%REST ITER-000)))
        (LINK-RELATION-ORIGINATED-PROPOSITION SELF P))))
     (CL:WHEN (CL:NOT (CL:EQ BACKWARDAXIOMS NULL))
      (CL:LET* ((P NULL) (ITER-001 BACKWARDAXIOMS))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:PROGN (CL:SETQ P (%%VALUE ITER-001))
         (CL:SETQ ITER-001 (%%REST ITER-001)))
        (LINK-RELATION-ORIGINATED-PROPOSITION SELF P))))
     (CL:WHEN (CL:NOT (CL:EQ FORWARDAXIOMS NULL))
      (CL:LET* ((P NULL) (ITER-002 FORWARDAXIOMS))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:PROGN (CL:SETQ P (%%VALUE ITER-002))
         (CL:SETQ ITER-002 (%%REST ITER-002)))
        (LINK-RELATION-ORIGINATED-PROPOSITION SELF P)))))
    (SET-DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
     SYM-LOGIC-IN-STELLA-BAD? NULL NULL))))

;;; (DEFUN CHECK-DESCRIPTION-ARGUMENT-TYPES ...)

(CL:DEFUN CHECK-DESCRIPTION-ARGUMENT-TYPES (SELF)
  (CL:LET* ((*MODULE* (HOME-MODULE SELF)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:LET*
    ((TYPE NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES SELF))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ TYPE (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:LET* ((CLASS (GET-DESCRIPTION TYPE)))
      (CL:WHEN (CL:EQ CLASS NULL)
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (CL:LET* ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
          "ERROR: Undefined class `" (%SURROGATE.SYMBOL-NAME TYPE)
          "' appears as argument type" EOL
          "   in the definition of relation `" (DESCRIPTION-NAME SELF)
          "'." EOL "." EOL)
         (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-LOGIC-IN-ERROR))
        (CL:ERROR
         (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
      (CL:WHEN (CL:NOT (CLASS-DESCRIPTION? CLASS))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "Non-class `" (%SURROGATE.SYMBOL-NAME TYPE)
        "' appears as argument type" EOL "in the definition of relation `"
        (DESCRIPTION-NAME SELF) "'." EOL EOL)))))))

;;; (DEFUN (FINALIZED-RELATION? BOOLEAN) ...)

(CL:DEFUN FINALIZED-RELATION? (SELF)
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:IF
    (CL:AND
     (CL:EQ
      (%STRING-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-LOGIC-IN-LOGIC-AXIOMS-STRING NULL-STRING-WRAPPER))
      STELLA::NULL-STRING)
     (CL:EQ
      (%STRING-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-LOGIC-IN-LOGIC-BACKWARD-AXIOMS-STRING NULL-STRING-WRAPPER))
      STELLA::NULL-STRING)
     (CL:EQ
      (%STRING-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-LOGIC-IN-LOGIC-FORWARD-AXIOMS-STRING NULL-STRING-WRAPPER))
      STELLA::NULL-STRING))
    (CL:SETQ TEST-VALUE-000 TRUE)
    (CL:PROGN
     (CL:SETQ TEST-VALUE-000
      (CL:NOT (CL:EQ (DECLARATION-ORIGINATED-PROPOSITIONS SELF) NULL)))
     (CL:WHEN TEST-VALUE-000
      (CL:LET* ((FOUND?-000 FALSE))
       (CL:LET*
        ((P NULL)
         (ITER-000
          (%LIST.THE-CONS-LIST
           (DECLARATION-ORIGINATED-PROPOSITIONS SELF))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:PROGN (CL:SETQ P (%%VALUE ITER-000))
          (CL:SETQ ITER-000 (%%REST ITER-000)))
         (CL:WHEN
          (CL:NOT
           (%BOOLEAN-WRAPPER.WRAPPER-VALUE
            (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS P)
             SYM-LOGIC-IN-LOGIC-SUBRELATION-LINK? FALSE-WRAPPER)))
          (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
       (CL:SETQ TEST-VALUE-000 FOUND?-000)))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFSPECIAL *INHIBITRELATIONFINALIZATION?* ...)

(CL:DEFVAR *INHIBITRELATIONFINALIZATION?* FALSE
  "Used to prevent finalization from triggering in the
middle of 'delicate' computations.  Also used to prevent recursive
invocation of 'finalize-relations'.")

;;; (DEFGLOBAL *RELATIONSAREFINALIZED?* ...)

(CL:DEFVAR *RELATIONSAREFINALIZED?* FALSE
  "Set to false whenever a relation has been
posted for finalization.")

;;; (DEFUN (RELATIONS-ARE-FINALIZED? BOOLEAN) ...)

(CL:DEFUN RELATIONS-ARE-FINALIZED? ()
  (EMPTY? *UNFINALIZED-RELATIONS*))

;;; (DEFUN FINALIZE-RELATIONS ...)

(CL:DEFUN FINALIZE-RELATIONS ()
  "Finalize all currently unfinalized relations."
  (CL:WHEN
   (CL:OR *INHIBITRELATIONFINALIZATION?* (RELATIONS-ARE-FINALIZED?)
    (CL:NOT (WORLD-STATE? *CONTEXT*)))
   (CL:RETURN-FROM FINALIZE-RELATIONS))
  (CL:LET*
   ((*INHIBITRELATIONFINALIZATION?* TRUE)
    (*TERMSOURCEBEINGPARSED* STELLA::NULL-STRING)
    (*DESCRIPTIONUNDERCONSTRUCTION* NULL) (*TERMUNDERCONSTRUCTION* NULL))
   (CL:DECLARE
    (CL:SPECIAL *INHIBITRELATIONFINALIZATION?* *TERMSOURCEBEINGPARSED*
     *DESCRIPTIONUNDERCONSTRUCTION* *TERMUNDERCONSTRUCTION*))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING *TERMSOURCEBEINGPARSED*))
   (CL:LET* ((RELATION NULL)) (FINALIZE-CLASSES-AND-SLOTS)
    (REVERSE *UNFINALIZED-RELATIONS*)
    (CL:LOOP
     (CL:TAGBODY (CL:SETQ RELATION (POP *UNFINALIZED-RELATIONS*))
      (CL:WHEN (CL:EQ RELATION NULL) (CL:RETURN))
      (CL:LET* ((TEST-VALUE-000 FALSE))
       (CL:IF (DELETED? RELATION) (CL:SETQ TEST-VALUE-000 TRUE)
        (CL:IF (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (BAD? RELATION))
         (CL:SETQ TEST-VALUE-000 TRUE)
         (CL:LET* ((FOUND?-000 FALSE))
          (CL:LET*
           ((TYPE NULL)
            (ITER-000
             (%LIST.THE-CONS-LIST
              (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES RELATION))))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
            (CL:PROGN (CL:SETQ TYPE (%%VALUE ITER-000))
             (CL:SETQ ITER-000 (%%REST ITER-000)))
            (CL:WHEN (CL:= (%GENERALIZED-SYMBOL.SYMBOL-ID TYPE) -1)
             (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
          (CL:SETQ TEST-VALUE-000 FOUND?-000))))
       (CL:WHEN TEST-VALUE-000 (CL:GO :CONTINUE)))
      (CL:HANDLER-CASE
       (CL:PROGN (FINALIZE-META-ASSERTIONS RELATION)
        (FINALIZE-RELATION-AXIOMS RELATION)
        (CHECK-DESCRIPTION-ARGUMENT-TYPES RELATION))
       (LOGIC-EXCEPTION (E)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         (EXCEPTION-MESSAGE E))))
      :CONTINUE)))))

;;; (DEFUN (DEFINE-RELATION-FROM-PARSE-TREE NAMED-DESCRIPTION) ...)

(CL:DEFUN DEFINE-RELATION-FROM-PARSE-TREE (TREE)
  (CL:LET* ((STRINGIFIEDSOURCE (STRINGIFY TREE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
   (CL:LET*
    ((*TERMSOURCEBEINGPARSED* STRINGIFIEDSOURCE)
     (*DESCRIPTIONUNDERCONSTRUCTION* NULL))
    (CL:DECLARE
     (CL:SPECIAL *TERMSOURCEBEINGPARSED* *DESCRIPTIONUNDERCONSTRUCTION*))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING *TERMSOURCEBEINGPARSED*))
    (CL:HANDLER-CASE
     (CL:RETURN-FROM DEFINE-RELATION-FROM-PARSE-TREE
      (HELP-DEFINE-RELATION-FROM-PARSE-TREE TREE STRINGIFIEDSOURCE))
     (LOGIC-EXCEPTION (E)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
       (EXCEPTION-MESSAGE E))
      NULL)))))

;;; (DEFUN (DEFFUNCTION NAMED-DESCRIPTION) ...)

(CL:DEFUN %DEFFUNCTION (ARGS)
  "Define (or redefine) a logic function.  The accepted syntax is:
	 
  (deffunction {<function-name> |
                (<function-name> <value-type>)} (<var>+)
     [:documentation <docstring>]
     [:-> <value-variable>]
     [:type <value-type>]
     [[{:definition | :is} <relation-expression>] |
      [:<=> <sentence-with-argument-variables>] |
      [:= <term-expression-with-argument-variables>]]
     [:polymorphic? {TRUE | FALSE}]
     [:axioms {<sentence> | (<sentence>+)}]
     [:=> {<sentence-with-argument-variables> |
                    (<sentence-with-argument-variables>+)}]
     [:properties <list-of-properties>]
     [:meta-attributes <list-of-key-value-pairs>]
     [<other-options>*])
	
Function parameters can be typed or untyped.  A typed first parameter
combined with a `:polymorphic? TRUE' specification defines a polymorphic
function.  Otherwise, the function will be non-polymorphic. If a value
variable is specified, it must be specified before any definition options,
otherwise, the expansions of definitions might be incorrect.  The default
KIF value variable is `?value'."
  (DEFINE-RELATION-FROM-PARSE-TREE
   (CONS SYM-LOGIC-IN-LOGIC-DEFFUNCTION (CONCATENATE ARGS NIL))))

(CL:DEFUN DEFFUNCTION-EVALUATOR-WRAPPER (ARGUMENTS)
  (%DEFFUNCTION ARGUMENTS))

(CL:DEFMACRO DEFFUNCTION (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define (or redefine) a logic function.  The accepted syntax is:
	 
  (deffunction {<function-name> |
                (<function-name> <value-type>)} (<var>+)
     [:documentation <docstring>]
     [:-> <value-variable>]
     [:type <value-type>]
     [[{:definition | :is} <relation-expression>] |
      [:<=> <sentence-with-argument-variables>] |
      [:= <term-expression-with-argument-variables>]]
     [:polymorphic? {TRUE | FALSE}]
     [:axioms {<sentence> | (<sentence>+)}]
     [:=> {<sentence-with-argument-variables> |
                    (<sentence-with-argument-variables>+)}]
     [:properties <list-of-properties>]
     [:meta-attributes <list-of-key-value-pairs>]
     [<other-options>*])
	
Function parameters can be typed or untyped.  A typed first parameter
combined with a `:polymorphic? TRUE' specification defines a polymorphic
function.  Otherwise, the function will be non-polymorphic. If a value
variable is specified, it must be specified before any definition options,
otherwise, the expansions of definitions might be incorrect.  The default
KIF value variable is `?value'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/DEFFUNCTION)) (CL:MACRO-FUNCTION (CL:QUOTE DEFFUNCTION)))

;;; (DEFUN (DEFRELATION NAMED-DESCRIPTION) ...)

(CL:DEFUN %DEFRELATION (ARGS)
  "Define (or redefine) a logic relation.  The accepted syntax is:
	 
  (defrelation {<relation-name> | 
                (<relation-name> BOOLEAN)} (<var>+)
     [:documentation <docstring>]
     [:type BOOLEAN]
     [[{:definition | :is} <relation-expression>] |
      [:<=> <sentence-with-argument-variables>]]
     [:polymorphic? {TRUE | FALSE}]
     [:axioms {<sentence> | (<sentence>+)}]
     [:=> {<sentence-with-argument-variables> |
                    (<sentence-with-argument-variables>+)}]
     [:properties <list-of-properties>]
     [:meta-attributes <list-of-key-value-pairs>]
     [<other-options>*])
	
Relation parameters can be typed or untyped.  A typed first parameter
combined with a `:polymorphic? TRUE' specification defines a polymorphic
relation.  Otherwise, the relation will be non-polymorphic."
  (DEFINE-RELATION-FROM-PARSE-TREE
   (CONS SYM-LOGIC-IN-LOGIC-DEFRELATION (CONCATENATE ARGS NIL))))

(CL:DEFUN DEFRELATION-EVALUATOR-WRAPPER (ARGUMENTS)
  (%DEFRELATION ARGUMENTS))

(CL:DEFMACRO DEFRELATION (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define (or redefine) a logic relation.  The accepted syntax is:
	 
  (defrelation {<relation-name> | 
                (<relation-name> BOOLEAN)} (<var>+)
     [:documentation <docstring>]
     [:type BOOLEAN]
     [[{:definition | :is} <relation-expression>] |
      [:<=> <sentence-with-argument-variables>]]
     [:polymorphic? {TRUE | FALSE}]
     [:axioms {<sentence> | (<sentence>+)}]
     [:=> {<sentence-with-argument-variables> |
                    (<sentence-with-argument-variables>+)}]
     [:properties <list-of-properties>]
     [:meta-attributes <list-of-key-value-pairs>]
     [<other-options>*])
	
Relation parameters can be typed or untyped.  A typed first parameter
combined with a `:polymorphic? TRUE' specification defines a polymorphic
relation.  Otherwise, the relation will be non-polymorphic."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/DEFRELATION)) (CL:MACRO-FUNCTION (CL:QUOTE DEFRELATION)))

;;; (DEFUN (DEFINE-LOGIC-TERM OBJECT) ...)

(CL:DEFUN DEFINE-LOGIC-TERM (NAME)
  (CL:LET* ((SURROGATE (SYMBOL-TO-SURROGATE NAME)))
   (CL:IF (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SURROGATE) NULL))
    (%SURROGATE.SURROGATE-VALUE SURROGATE)
    (CREATE-LOGIC-INSTANCE SURROGATE NULL))))

;;; (DEFUN (DEFOBJECT LOGIC-OBJECT) ...)

(CL:DEFUN %DEFOBJECT (NAME ARGS)
  "Define (or redefine) a logic instance."
  (CL:LET* ((TERM (DEFINE-LOGIC-TERM NAME)))
   (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
    (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000) ARGS)
    (CL:LET* ((OPTIONS SELF-000))
     (CL:LET*
      ((VALUE NULL) (KEY NULL)
       (ITER-000 (%PROPERTY-LIST.THE-PLIST (VET-OPTIONS OPTIONS NULL))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ KEY (%%VALUE ITER-000))
       (CL:PROGN (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
        (CL:SETQ ITER-000 (%%REST (%%REST ITER-000))))
       (ASSERT-KEYWORD-AXIOM TERM KEY VALUE)))
     TERM))))

(CL:DEFUN DEFOBJECT-EVALUATOR-WRAPPER (ARGUMENTS)
  (%DEFOBJECT (%%VALUE ARGUMENTS) (%%REST ARGUMENTS)))

(CL:DEFMACRO DEFOBJECT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define (or redefine) a logic instance."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/DEFOBJECT)) (CL:MACRO-FUNCTION (CL:QUOTE DEFOBJECT)))

;;; (DEFUN (DEFINSTANCE LOGIC-OBJECT) ...)

(CL:DEFUN %DEFINSTANCE (NAME ARGS)
  "Define (or redefine) a logic instance."
  (CL:LET* ((TERM (DEFINE-LOGIC-TERM NAME)))
   (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
    (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000) ARGS)
    (CL:LET* ((OPTIONS SELF-000))
     (CL:LET*
      ((VALUE NULL) (KEY NULL)
       (ITER-000 (%PROPERTY-LIST.THE-PLIST (VET-OPTIONS OPTIONS NULL))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ KEY (%%VALUE ITER-000))
       (CL:PROGN (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
        (CL:SETQ ITER-000 (%%REST (%%REST ITER-000))))
       (ASSERT-KEYWORD-AXIOM TERM KEY VALUE)))
     TERM))))

(CL:DEFUN DEFINSTANCE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%DEFINSTANCE (%%VALUE ARGUMENTS) (%%REST ARGUMENTS)))

(CL:DEFMACRO DEFINSTANCE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define (or redefine) a logic instance."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/DEFINSTANCE)) (CL:MACRO-FUNCTION (CL:QUOTE DEFINSTANCE)))

;;; (DEFUN (DEFCONCEPT NAMED-DESCRIPTION) ...)

(CL:DEFUN %DEFCONCEPT (ARGS)
  "Define (or redefine) a class."
  (CL:LET*
   ((THEARGS ARGS) (CONCEPTVARIABLEDECLARATION NULL)
    (ADDITIONALSUPERS NIL) (SELFVARIABLE SYM-LOGIC-IN-LOGIC-?SELF))
   (CL:WHEN (CONS? (%%VALUE (%%REST THEARGS)))
    (CL:SETQ CONCEPTVARIABLEDECLARATION (%%VALUE (%%REST THEARGS))))
   (CL:COND
    ((CL:NOT (CL:EQ CONCEPTVARIABLEDECLARATION NULL))
     (CL:WHEN (CONS? (%%VALUE CONCEPTVARIABLEDECLARATION))
      (CL:SETQ CONCEPTVARIABLEDECLARATION
       (%%VALUE CONCEPTVARIABLEDECLARATION)))
     (CL:WHEN
      (CL:AND (SYMBOL? (%%VALUE CONCEPTVARIABLEDECLARATION))
       (CL:NOT
        (QUESTION-MARK-SYMBOL? (%%VALUE CONCEPTVARIABLEDECLARATION))))
      (CL:SETF (%%REST CONCEPTVARIABLEDECLARATION)
       (CONS (%%VALUE CONCEPTVARIABLEDECLARATION)
        (CONCATENATE (%%REST CONCEPTVARIABLEDECLARATION) NIL)))
      (FIRST-SETTER CONCEPTVARIABLEDECLARATION SELFVARIABLE))
     (CL:WHEN (CL:EQ CONCEPTVARIABLEDECLARATION NIL)
      (CL:SETQ CONCEPTVARIABLEDECLARATION (CONS SELFVARIABLE NIL)))
     (CL:LET*
      ((SUPER NULL)
       (ITER-000 (%%REST (%%REST CONCEPTVARIABLEDECLARATION))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ SUPER (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:WHEN (SYMBOL? SUPER)
        (CL:SETQ ADDITIONALSUPERS
         (CONCATENATE ADDITIONALSUPERS
          (LIST* KWD-LOGIC-IN-=>
           (CONS SUPER (CONS (%%VALUE CONCEPTVARIABLEDECLARATION) NIL))
           NIL))))))
     (CL:WHEN (CL:NOT (CL:EQ ADDITIONALSUPERS NIL))
      (CL:SETF (%%REST (%%REST CONCEPTVARIABLEDECLARATION)) NIL))
     (CL:IF
      (CL:NOT (CL:EQ (%%VALUE (%%REST CONCEPTVARIABLEDECLARATION)) NULL))
      (SECOND-SETTER THEARGS (CONS CONCEPTVARIABLEDECLARATION NIL))
      (SECOND-SETTER THEARGS CONCEPTVARIABLEDECLARATION)))
    ((CL:EQ (%%REST THEARGS) NIL)
     (CL:SETF (%%REST THEARGS) (CONS (CONS SELFVARIABLE NIL) NIL)))
    ((KEYWORD? (%%VALUE (%%REST THEARGS)))
     (CL:SETF (%%REST (%%REST THEARGS))
      (CONS (%%VALUE (%%REST THEARGS))
       (CONCATENATE (%%REST (%%REST THEARGS)) NIL)))
     (SECOND-SETTER THEARGS (CONS SELFVARIABLE NIL))))
   (DEFINE-RELATION-FROM-PARSE-TREE
    (CONS SYM-LOGIC-IN-LOGIC-DEFCONCEPT
     (CONCATENATE THEARGS (CONCATENATE ADDITIONALSUPERS NIL))))))

(CL:DEFUN DEFCONCEPT-EVALUATOR-WRAPPER (ARGUMENTS)
  (%DEFCONCEPT ARGUMENTS))

(CL:DEFMACRO DEFCONCEPT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define (or redefine) a class."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/DEFCONCEPT)) (CL:MACRO-FUNCTION (CL:QUOTE DEFCONCEPT)))

;;; (DEFGLOBAL *LOGIC-RELEVANT-STELLA-COMMANDS* ...)

(CL:DEFVAR *LOGIC-RELEVANT-STELLA-COMMANDS* NULL)

;;; (DEFUN (COMMAND< BOOLEAN) ...)

(CL:DEFUN COMMAND< (COMMAND1 COMMAND2)
  (STRING< (VISIBLE-NAME (%METHOD-SLOT.SLOT-NAME COMMAND1))
   (VISIBLE-NAME (%METHOD-SLOT.SLOT-NAME COMMAND2))))

;;; (DEFUN (LIST-LOGIC-COMMANDS (LIST OF METHOD-SLOT)) ...)

(CL:DEFUN LIST-LOGIC-COMMANDS ()
  (CL:LET* ((COMMANDS (NEW-LIST)))
   (CL:LET*
    ((FUNCTION NULL)
     (ITER-000 (ALL-FUNCTIONS (GET-STELLA-MODULE "/LOGIC" TRUE) TRUE))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ FUNCTION (%ITERATOR.VALUE ITER-000))
     (CL:WHEN
      (CL:AND
       (%BOOLEAN-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
         SYM-LOGIC-IN-STELLA-METHOD-COMMAND? FALSE-WRAPPER))
       (PUBLIC? FUNCTION))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS FUNCTION NIL))
        (CL:IF (CL:EQ (%LIST.THE-CONS-LIST COMMANDS) NIL)
         (CL:SETF (%LIST.THE-CONS-LIST COMMANDS) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST COMMANDS)
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS FUNCTION NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:LET*
    ((STELLACOMMAND NULL) (ITER-001 *LOGIC-RELEVANT-STELLA-COMMANDS*)
     (COLLECT-001 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ STELLACOMMAND (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:IF (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (CONS (LOOKUP-COMMAND STELLACOMMAND) NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST COMMANDS) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST COMMANDS) COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST COMMANDS)
         COLLECT-001)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-001)
        (CONS (LOOKUP-COMMAND STELLACOMMAND) NIL))
       (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))))
   (SORT COMMANDS (CL:FUNCTION COMMAND<))))

;;; (DEFUN HELP ...)

(CL:DEFUN %HELP (COMMANDS)
  "Describe specific commands, or print a list of available commands."
  (CL:LET* ((THECOMMANDS COMMANDS))
   (CL:COND
    ((CL:EQ THECOMMANDS NIL)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "The following commands are available (type `(help <command>+)'" EOL
      "to get command-specific documentation):" EOL EOL)
     (CL:LET* ((ALLCOMMANDS (LIST-LOGIC-COMMANDS)))
      (CL:LET*
       ((COMMAND NULL) (ITER-000 (%LIST.THE-CONS-LIST ALLCOMMANDS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:PROGN (CL:SETQ COMMAND (%%VALUE ITER-000))
         (CL:SETQ ITER-000 (%%REST ITER-000)))
        (CL:WHEN
         (CL:NOT
          (CL:EQ
           (%STRING-WRAPPER.WRAPPER-VALUE
            (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS COMMAND)
             SYM-LOGIC-IN-STELLA-DOCUMENTATION NULL-STRING-WRAPPER))
           STELLA::NULL-STRING))
         (PRINT-DOCUMENTATION COMMAND STANDARD-OUTPUT TRUE))))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
       "Undocumented Commands:" EOL EOL)
      (CL:LET*
       ((COMMAND NULL) (ITER-001 (%LIST.THE-CONS-LIST ALLCOMMANDS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:PROGN (CL:SETQ COMMAND (%%VALUE ITER-001))
         (CL:SETQ ITER-001 (%%REST ITER-001)))
        (CL:WHEN
         (CL:EQ
          (%STRING-WRAPPER.WRAPPER-VALUE
           (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS COMMAND)
            SYM-LOGIC-IN-STELLA-DOCUMENTATION NULL-STRING-WRAPPER))
          STELLA::NULL-STRING)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          (%METHOD-SLOT.SLOT-NAME COMMAND) ":" EOL))))))
    (CL:T
     (CL:LET* ((COMMANDNAME NULL) (ITER-002 THECOMMANDS))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:PROGN (CL:SETQ COMMANDNAME (%%VALUE ITER-002))
        (CL:SETQ ITER-002 (%%REST ITER-002)))
       (CL:LET* ((COMMAND (LOOKUP-COMMAND COMMANDNAME)))
        (CL:IF (CL:NOT (CL:EQ COMMAND NULL))
         (PRINT-DOCUMENTATION COMMAND STANDARD-OUTPUT FALSE)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "Undefined command: `" COMMANDNAME "'" EOL)))))))))

(CL:DEFUN HELP-EVALUATOR-WRAPPER (ARGUMENTS)
  (%HELP ARGUMENTS))

(CL:DEFMACRO HELP (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Describe specific commands, or print a list of available commands."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/HELP)) (CL:MACRO-FUNCTION (CL:QUOTE HELP)))

(CL:DEFUN HELP-STARTUP-LOGIC-IN1 ()
  (CL:PROGN
   (CL:SETQ KWD-LOGIC-IN-TRACE-SUBGOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRACE-SUBGOALS" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-TRACE-CLASSIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRACE-CLASSIFIER" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-CLOSED-WORLD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED-WORLD" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-ITERATIVE-DEEPENING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATIVE-DEEPENING" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATIONS" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-JUST-IN-TIME-INFERENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUST-IN-TIME-INFERENCE" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-EMIT-THINKING-DOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EMIT-THINKING-DOTS" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-GOAL-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-TREE" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-CLASSIFIER-INFERENCES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFIER-INFERENCES" NULL 2))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-SET-FEATURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-FEATURE" NULL 0))
   (CL:SETQ KWD-LOGIC-IN-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-UNSET-FEATURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNSET-FEATURE" NULL 0))
   (CL:SETQ KWD-LOGIC-IN-REALISTIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REALISTIC" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-BYE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BYE" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-EXIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXIT" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-HALT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HALT" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-QUIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUIT" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-STOP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STOP" NULL 2))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-BYE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BYE" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-EXIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXIT" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-HALT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HALT" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-QUIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUIT" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-STOP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STOP" NULL 0))
   (CL:SETQ KWD-LOGIC-IN-DEFINE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE" NULL 2))
   (CL:SETQ SYM-LOGIC-IN-STELLA-IN-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN-MODULE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SGT-LOGIC-IN-STELLA-VOID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-LOGIC-IN-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ KWD-LOGIC-IN-FINALIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE" NULL 2))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-LOAD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-DEFMODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMODULE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-CLEAR-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEAR-MODULE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-DEFCLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFCLASS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-DEFSLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFSLOT"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-DEFUN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFUN"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-DEFMETHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMETHOD"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-DEFCONCEPT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFCONCEPT" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-DEFFUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFFUNCTION" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-DEFRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFRELATION" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-DEFOBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFOBJECT" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-IN-DIALECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN-DIALECT" NULL 0))
   (CL:SETQ KWD-LOGIC-IN-WHITE-SPACE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHITE-SPACE" NULL 2))
   (CL:SETQ SYM-LOGIC-IN-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-DEMO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMO" NULL 0))
   (CL:SETQ KWD-LOGIC-IN-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-WARNING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARNING" NULL 2))
   (CL:SETQ SGT-LOGIC-IN-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SGT-LOGIC-IN-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SGT-LOGIC-IN-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-MODULE-LOGIC-DIALECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-LOGIC-DIALECT" NULL 0))
   (CL:SETQ KWD-LOGIC-IN-KIF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KIF" NULL 2))
   (CL:SETQ SGT-LOGIC-IN-STELLA-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-LOGIC-IN-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-LOGIC-IN-STELLA-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TABLE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-LOGIC-IN-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-LOGIC-IN-STELLA-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SGT-LOGIC-IN-PL-KERNEL-KB-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-LOGIC-IN-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))))

(CL:DEFUN HELP-STARTUP-LOGIC-IN2 ()
  (CL:PROGN
   (CL:SETQ SGT-LOGIC-IN-PL-KERNEL-KB-SYNONYM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYNONYM"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SYM-LOGIC-IN-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ KWD-LOGIC-IN-POLYMORPHIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POLYMORPHIC?" NULL 2))
   (CL:SETQ SYM-LOGIC-IN-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SGT-LOGIC-IN-STELLA-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ KWD-LOGIC-IN--> (INTERN-RIGID-SYMBOL-WRT-MODULE "->" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-RANGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RANGE" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-=> (INTERN-RIGID-SYMBOL-WRT-MODULE "=>" NULL 2))
   (CL:SETQ SYM-LOGIC-IN-STELLA-BAD?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BAD?"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ KWD-LOGIC-IN-POLYMORPHIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POLYMORPHIC" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-DECLARATION-ORIGINATED-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DECLARATION-ORIGINATED-PROPOSITIONS"
     NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-DEFINITION-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINITION-STRING" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-SLOT-OPTION-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-OPTION-KEYWORD"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-<=>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<=>" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-PRETEND-DEFINITION-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRETEND-DEFINITION-STRING" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-KAPPA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=" (GET-STELLA-MODULE "/STELLA" TRUE)
     0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-AXIOMS-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AXIOMS-STRING" NULL 0))
   (CL:SETQ KWD-LOGIC-IN-<= (INTERN-RIGID-SYMBOL-WRT-MODULE "<=" NULL 2))
   (CL:SETQ SYM-LOGIC-IN-STELLA-<=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<="
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ KWD-LOGIC-IN-<<=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<<=" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-BACKWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD" NULL 2))
   (CL:SETQ SYM-LOGIC-IN-STELLA-=>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=>"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ KWD-LOGIC-IN-=>>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=>>" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-FORWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-<=>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<=>" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-<<=>>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<<=>>" NULL 2))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-FORWARD-AXIOMS-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-AXIOMS-STRING" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-BACKWARD-AXIOMS-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD-AXIOMS-STRING" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ KWD-LOGIC-IN-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-BACKWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD-ONLY?" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-FORWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-ONLY?" NULL 0))
   (CL:SETQ KWD-LOGIC-IN-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-ASSERT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
   (CL:SETQ KWD-LOGIC-IN-CONCEIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEIVE" NULL 2))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-SUBRELATION-LINK?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBRELATION-LINK?" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-DEFINSTANCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINSTANCE" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-?SELF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?SELF" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-CC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CC"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-METHOD-COMMAND?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-COMMAND?"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-HELP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HELP" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-LOGIC-STARTUP-LOGIC-IN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-LOGIC-IN" NULL 0))
   (CL:SETQ SYM-LOGIC-IN-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))))

(CL:DEFUN HELP-STARTUP-LOGIC-IN3 ()
  (CL:PROGN
   (CL:SETQ *AVAILABLE-POWERLOOM-FEATURES*
    (LIST KWD-LOGIC-IN-TRACE-SUBGOALS KWD-LOGIC-IN-TRACE-CLASSIFIER
     KWD-LOGIC-IN-CLOSED-WORLD KWD-LOGIC-IN-ITERATIVE-DEEPENING
     KWD-LOGIC-IN-JUSTIFICATIONS KWD-LOGIC-IN-JUST-IN-TIME-INFERENCE
     KWD-LOGIC-IN-EMIT-THINKING-DOTS))
   (CL:SETQ *CURRENT-POWERLOOM-FEATURES* (LIST))
   (CL:SETQ *DEFAULT-POWERLOOM-FEATURES*
    (LIST KWD-LOGIC-IN-JUST-IN-TIME-INFERENCE
     KWD-LOGIC-IN-EMIT-THINKING-DOTS))
   (RESET-FEATURES)
   (CL:SETQ *DEMO-FILES*
    (LIST*
     (LIST* (WRAP-STRING "basics")
      (WRAP-STRING "Basic PowerLoom commands") (WRAP-STRING "test-suite")
      NIL)
     (LIST* (WRAP-STRING "classes")
      (WRAP-STRING "Primitive and defined classes")
      (WRAP-STRING "test-suite") NIL)
     (LIST* (WRAP-STRING "collections")
      (WRAP-STRING "Reasoning with collections")
      (WRAP-STRING "test-suite") NIL)
     (LIST* (WRAP-STRING "append") (WRAP-STRING "Prolog-style `append'")
      (WRAP-STRING "test-suite") NIL)
     (LIST* (WRAP-STRING "named-rules") (WRAP-STRING "Using named rules")
      (WRAP-STRING "test-suite") NIL)
     (LIST* (WRAP-STRING "recursion")
      (WRAP-STRING "Reasoning with recursive rules")
      (WRAP-STRING "test-suite") NIL)
     (LIST* (WRAP-STRING "negation")
      (WRAP-STRING "Reasoning with negation") (WRAP-STRING "test-suite")
      NIL)
     (LIST* (WRAP-STRING "constraints")
      (WRAP-STRING "Constraint propagation") (WRAP-STRING "test-suite")
      NIL)
     (LIST* (WRAP-STRING "subsumption")
      (WRAP-STRING "Simple subsumption reasoning")
      (WRAP-STRING "test-suite") NIL)
     (LIST* (WRAP-STRING "family")
      (WRAP-STRING "Subsumption reasoning within a family ontology")
      (WRAP-STRING "test-suite") NIL)
     (LIST* (WRAP-STRING "relation-hierarchy")
      (WRAP-STRING
       "Finding sub, super and equivalent concepts and relations")
      (WRAP-STRING "test-suite") NIL)
     (LIST* (WRAP-STRING "defaults")
      (WRAP-STRING "Default reasoning with Tweety and friends")
      (WRAP-STRING "test-suite") NIL)
     (LIST* (WRAP-STRING "defaults2")
      (WRAP-STRING "More default reasoning") (WRAP-STRING "test-suite")
      NIL)
     (LIST* (WRAP-STRING "definition-syntax")
      (WRAP-STRING
       "The whole scoop on relation definition, funny arrows, etc.")
      (WRAP-STRING "test-suite") NIL)
     (LIST* (WRAP-STRING "meta-relations")
      (WRAP-STRING "Using meta-properties and relations")
      (WRAP-STRING "test-suite") NIL)
     (LIST* (WRAP-STRING "partial-match")
      (WRAP-STRING "Reasoning with partial information")
      (WRAP-STRING "test-suite") NIL)
     (LIST* (WRAP-STRING "probability-learning")
      (WRAP-STRING "Learning to answer probabilistic queries")
      (WRAP-STRING "test-suite") NIL)
     (LIST* (WRAP-STRING "regression-demo")
      (WRAP-STRING "Learning to predict functions") NIL)
     (LIST* (WRAP-STRING "rule-induction-demo")
      (WRAP-STRING "Learning inference rules") NIL)
     (LIST* (WRAP-STRING "test-suite")
      (WRAP-STRING "PowerLoom test suite") (WRAP-STRING "test-suite") NIL)
     NIL))
   (CL:SETQ *UNFINALIZED-RELATIONS* (LIST))
   (CL:SETQ *LOGIC-RELEVANT-STELLA-COMMANDS*
    (LIST* SYM-LOGIC-IN-STELLA-CC SYM-LOGIC-IN-STELLA-CLEAR-MODULE
     SYM-LOGIC-IN-STELLA-DEFCLASS SYM-LOGIC-IN-STELLA-DEFMODULE
     SYM-LOGIC-IN-STELLA-IN-MODULE NIL))))

(CL:DEFUN HELP-STARTUP-LOGIC-IN4 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "PRINT-FEATURES"
    "(DEFUN PRINT-FEATURES () :COMMAND? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Print the currently enabled and available PowerLoom environment features.\")"
    (CL:FUNCTION PRINT-FEATURES) NULL)
   (DEFINE-FUNCTION-OBJECT "LIST-FEATURES"
    "(DEFUN (LIST-FEATURES LIST) () :COMMAND? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Return a list containing two lists, a list of currently enabled PowerLoom
features, and a list of all available PowerLoom features.\")"
    (CL:FUNCTION LIST-FEATURES) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-POWERLOOM-FEATURE"
    "(DEFUN SET-POWERLOOM-FEATURE ((FEATURE KEYWORD)) :DOCUMENTATION \"Enable the PowerLoom environment feature `feature'.\")"
    (CL:FUNCTION SET-POWERLOOM-FEATURE) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-FEATURE"
    "(DEFUN (SET-FEATURE (LIST OF KEYWORD)) (|&REST| (FEATURES NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Enable the PowerLoom environment feature(s) named by `features'.
Return the list of enabled features.  Calling `set-feature' without any
arguments can be used to display the currently enabled features.
The following features are supported:

`just-in-time-inference': Enables interleaving of forward chaining inference
within backward chaining queries.

`iterative-deepening': Tells the query processor to use iterative deepening
instead of a depth-first search to find answers.  This is less efficient
but necessary for some kinds of highly recursive queries.

`trace-subgoals': Enables the generation of subgoaling trace information during
backchaining inference.

`trace-classifier': Tells the classifier to describe the inferences it draws.

`justifications': Enables the generation of justifications during inference
which is a prerequiste for the generation of explanations with `(why)'.

`emit-thinking-dots': Tells PowerLoom to annotate its inference progress by
outputting characters indicating the completion of individual reasoning steps.

`closed-world': Enables global closed-world reasoning.  NOT YET IMPLEMENTED!
\")" (CL:FUNCTION %SET-FEATURE)
    (CL:FUNCTION SET-FEATURE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "UNSET-POWERLOOM-FEATURE"
    "(DEFUN UNSET-POWERLOOM-FEATURE ((FEATURE KEYWORD)) :DOCUMENTATION \"Disable the PowerLoom environment feature `feature'.\")"
    (CL:FUNCTION UNSET-POWERLOOM-FEATURE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNSET-FEATURE"
    "(DEFUN (UNSET-FEATURE (LIST OF KEYWORD)) (|&REST| (FEATURES NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Disable the PowerLoom environment feature(s) named by `features'.
Return the list of enabled features.  Calling `unset-feature' without any
arguments can be used to display the currently enabled features.
See `set-feature' for a description of supported features.\")"
    (CL:FUNCTION %UNSET-FEATURE)
    (CL:FUNCTION UNSET-FEATURE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "RESET-FEATURES"
    "(DEFUN (RESET-FEATURES (LIST OF KEYWORD)) () :COMMAND? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Reset the PowerLoom environment features to their default settings.\")"
    (CL:FUNCTION RESET-FEATURES) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-LOGIC-PROMPT"
    "(DEFUN PRINT-LOGIC-PROMPT ())" (CL:FUNCTION PRINT-LOGIC-PROMPT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-LOGIC-COMMAND-RESULT"
    "(DEFUN PRINT-LOGIC-COMMAND-RESULT ((RESULT OBJECT) (RESULTTYPE TYPE-SPEC)))"
    (CL:FUNCTION PRINT-LOGIC-COMMAND-RESULT) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGIC-COMMAND-LOOP-EXIT?"
    "(DEFUN (LOGIC-COMMAND-LOOP-EXIT? BOOLEAN BOOLEAN) ((COMMAND OBJECT)))"
    (CL:FUNCTION LOGIC-COMMAND-LOOP-EXIT?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGIC-COMMAND-LOOP"
    "(DEFUN LOGIC-COMMAND-LOOP ())" (CL:FUNCTION LOGIC-COMMAND-LOOP) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-LOGIC-COMMAND"
    "(DEFUN (EVALUATE-LOGIC-COMMAND OBJECT TYPE-SPEC BOOLEAN) ((COMMAND OBJECT) (FINALIZE? BOOLEAN)))"
    (CL:FUNCTION EVALUATE-LOGIC-COMMAND) NULL)
   (DEFINE-FUNCTION-OBJECT "LOAD"
    "(DEFUN LOAD ((FILE STRING)) :DOCUMENTATION \"Read logic commands from `file' and evaluate them.\" :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %LOAD) (CL:FUNCTION LOAD-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "LOAD-STREAM"
    "(DEFUN LOAD-STREAM ((STREAM INPUT-STREAM)) :DOCUMENTATION \"Read logic commands from `stream' and evaluate them.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOAD-STREAM) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-DEMO-PROMPT"
    "(DEFUN PRINT-DEMO-PROMPT ())" (CL:FUNCTION PRINT-DEMO-PROMPT) NULL)
   (DEFINE-FUNCTION-OBJECT "DEMO-SKIP-TO-COMMAND"
    "(DEFUN (DEMO-SKIP-TO-COMMAND BOOLEAN) ((STREAM INPUT-STREAM)))"
    (CL:FUNCTION DEMO-SKIP-TO-COMMAND) NULL)
   (DEFINE-FUNCTION-OBJECT "DEMO-PAUSE?"
    "(DEFUN (DEMO-PAUSE? BOOLEAN BOOLEAN) ((PAUSE? BOOLEAN)))"
    (CL:FUNCTION DEMO-PAUSE?) NULL)
   (DEFINE-FUNCTION-OBJECT "DEMO-FILE"
    "(DEFUN DEMO-FILE ((FILE FILE-NAME) (PAUSE? BOOLEAN)))"
    (CL:FUNCTION DEMO-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "DEMO-ENTRY-FILE"
    "(DEFUN (DEMO-ENTRY-FILE STRING) ((DEMOENTRY (CONS OF STRING-WRAPPER))))"
    (CL:FUNCTION DEMO-ENTRY-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "DEMO-ENTRY-DESCRIPTION"
    "(DEFUN (DEMO-ENTRY-DESCRIPTION STRING) ((DEMOENTRY (CONS OF STRING-WRAPPER))))"
    (CL:FUNCTION DEMO-ENTRY-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "DEMO-ENTRY-TEST-SUITE?"
    "(DEFUN (DEMO-ENTRY-TEST-SUITE? BOOLEAN) ((DEMOENTRY (CONS OF STRING-WRAPPER))))"
    (CL:FUNCTION DEMO-ENTRY-TEST-SUITE?) NULL)
   (DEFINE-FUNCTION-OBJECT "SELECT-EXAMPLE-DEMO"
    "(DEFUN (SELECT-EXAMPLE-DEMO STRING) ((INDEX INTEGER)))"
    (CL:FUNCTION SELECT-EXAMPLE-DEMO) NULL)
   (DEFINE-FUNCTION-OBJECT "SELECT-EXAMPLE-DEMO-FROM-MENU"
    "(DEFUN (SELECT-EXAMPLE-DEMO-FROM-MENU STRING) ())"
    (CL:FUNCTION SELECT-EXAMPLE-DEMO-FROM-MENU) NULL)
   (DEFINE-FUNCTION-OBJECT "DEMO-EXAMPLE-DEMOS"
    "(DEFUN DEMO-EXAMPLE-DEMOS ())" (CL:FUNCTION DEMO-EXAMPLE-DEMOS) NULL)
   (DEFINE-FUNCTION-OBJECT "DEMO"
    "(DEFUN DEMO (|&REST| (FILEANDPAUSE OBJECT)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Read logic commands from a file, echo them verbatimly to standard output,
and evaluate them just as if they had been typed in interactively.
When called with no arguments, present a menu of example demos, otherwise,
use the first argument as the name of the file to demo.
Pause for user confirmation after each expression has been read but
before it is evaluated.  Pausing can be turned off by suppling FALSE
as the optional second argument, or by typing `c' at the pause prompt.
Typing `?' at the pause prompt prints a list of available commands.\")"
    (CL:FUNCTION %DEMO) (CL:FUNCTION DEMO-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "TEST-LOGIC-FILE"
    "(DEFUN TEST-LOGIC-FILE ((FILE FILE-NAME)))"
    (CL:FUNCTION TEST-LOGIC-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-POWERLOOM-TESTS"
    "(DEFUN RUN-POWERLOOM-TESTS () :COMMAND? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Run the PowerLoom test suite.  Currently this simply runs all demos and
echos commands and their results to standard output.  The output can then
be diffed with previously validated runs to find deviations.\")"
    (CL:FUNCTION RUN-POWERLOOM-TESTS) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-FORMULA-CONTAINING-ERROR"
    "(DEFUN PRINT-FORMULA-CONTAINING-ERROR ((SELF OBJECT) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-FORMULA-CONTAINING-ERROR) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-SIGNAL-PROPOSITION-ERROR"
    "(DEFUN HELP-SIGNAL-PROPOSITION-ERROR ((STREAM OUTPUT-STREAM) (WARNINGORERROR KEYWORD)))"
    (CL:FUNCTION HELP-SIGNAL-PROPOSITION-ERROR) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT NAMED-DESCRIPTION INDEX-ON-VALUES? :TYPE BOOLEAN :OPTION-KEYWORD :INDEX-ON-VALUES? :DOCUMENTATION \"Tells PowerLoom to install a hash index on the slot
values, enabling retrieval of the slot argument given its value.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT NAMED-DESCRIPTION PERMUTATION-TABLE :TYPE (KEY-VALUE-LIST OF VECTOR SLOT) :OPTION-KEYWORD :PERMUTATION-TABLE :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT TABLE RELATION-PARAMETER-TYPE-SPECIFIERS :RENAMES TUPLE-DOMAINS)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT MODULE MODULE-LOGIC-DIALECT :TYPE KEYWORD :DEFAULT NULL :OPTION-KEYWORD :LOGIC-DIALECT :PUBLIC? TRUE :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "LOGIC-DIALECT"
    "(DEFUN (LOGIC-DIALECT KEYWORD) ((SELF OBJECT)))"
    (CL:FUNCTION LOGIC-DIALECT) NULL)
   (DEFINE-FUNCTION-OBJECT "POLYMORPHIC-RELATION?"
    "(DEFUN (POLYMORPHIC-RELATION? BOOLEAN) ((SELF RELATION)))"
    (CL:FUNCTION POLYMORPHIC-RELATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-TABLE-FOR-POLYMORPHIC-RELATION"
    "(DEFUN (DEFINE-TABLE-FOR-POLYMORPHIC-RELATION RELATION) ((NAME SYMBOL) (PARAMETERTYPES (LIST OF TYPE))))"
    (CL:FUNCTION DEFINE-TABLE-FOR-POLYMORPHIC-RELATION) NULL)
   (DEFINE-FUNCTION-OBJECT "NAME-DESCRIPTION-METACLASS"
    "(DEFUN (NAME-DESCRIPTION-METACLASS SYMBOL) ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION NAME-DESCRIPTION-METACLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-DECKS-FOR-BINDING-DESCRIPTION?"
    "(DEFUN (CLEAR-DECKS-FOR-BINDING-DESCRIPTION? BOOLEAN) ((NAME SYMBOL)))"
    (CL:FUNCTION CLEAR-DECKS-FOR-BINDING-DESCRIPTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "BIND-DESCRIPTION-TO-SURROGATE?"
    "(DEFUN (BIND-DESCRIPTION-TO-SURROGATE? BOOLEAN) ((NAME SYMBOL) (DESCRIPTION NAMED-DESCRIPTION) (STRINGIFIEDSOURCE STRING)))"
    (CL:FUNCTION BIND-DESCRIPTION-TO-SURROGATE?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSFER-SYNONYMS"
    "(DEFUN TRANSFER-SYNONYMS ((OLDDESCRIPTION DESCRIPTION) (NEWDESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION TRANSFER-SYNONYMS) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-BOUND-OR-LOCAL-SURROGATE"
    "(DEFUN (COERCE-TO-BOUND-OR-LOCAL-SURROGATE SURROGATE) ((SELF GENERALIZED-SYMBOL)))"
    (CL:FUNCTION COERCE-TO-BOUND-OR-LOCAL-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-ASSERT-KEYWORD-AXIOM"
    "(DEFUN HELP-ASSERT-KEYWORD-AXIOM ((RELATIONREF SURROGATE) (SELF OBJECT) (VALUE OBJECT)))"
    (CL:FUNCTION HELP-ASSERT-KEYWORD-AXIOM) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-KEYWORD-AXIOM"
    "(DEFUN ASSERT-KEYWORD-AXIOM ((SELF OBJECT) (KEY KEYWORD) (VALUE OBJECT)))"
    (CL:FUNCTION ASSERT-KEYWORD-AXIOM) NULL)
   (DEFINE-FUNCTION-OBJECT "DECLARATION-KEYWORD-AXIOMS-HANDLER"
    "(DEFUN DECLARATION-KEYWORD-AXIOMS-HANDLER ((SELF NAMED-DESCRIPTION) (KEY KEYWORD) (VALUE OBJECT)))"
    (CL:FUNCTION DECLARATION-KEYWORD-AXIOMS-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-DEFINE-RELATION-FROM-PARSE-TREE"
    "(DEFUN (HELP-DEFINE-RELATION-FROM-PARSE-TREE NAMED-DESCRIPTION) ((TREE CONS) (STRINGIFIEDSOURCE STRING)))"
    (CL:FUNCTION HELP-DEFINE-RELATION-FROM-PARSE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "SEQUENCE-VARIABLE?"
    "(DEFUN (SEQUENCE-VARIABLE? BOOLEAN) ((SELF SYMBOL)))"
    (CL:FUNCTION SEQUENCE-VARIABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-RELATION-PARAMETERS-TREE"
    "(DEFUN (PARSE-RELATION-PARAMETERS-TREE (LIST OF SYMBOL) (LIST OF TYPE) BOOLEAN) ((PARAMETERS CONS)))"
    (CL:FUNCTION PARSE-RELATION-PARAMETERS-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-IDENTICAL-RELATION"
    "(DEFUN (GET-IDENTICAL-RELATION NAMED-DESCRIPTION) ((NAME SYMBOL) (OWNER TYPE) (POLYMORPHIC? BOOLEAN) (STRINGIFIEDSOURCE STRING)))"
    (CL:FUNCTION GET-IDENTICAL-RELATION) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT NAMED-DESCRIPTION DEFINITION-STRING :TYPE STRING :OPTION-KEYWORD := :OPTION-HANDLER RELATION-TERM-DEFINITION-HANDLER :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT NAMED-DESCRIPTION AXIOMS-STRING :TYPE STRING :OPTION-KEYWORD :AXIOMS :OPTION-HANDLER DECLARATION-AXIOMS-HANDLER :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT NAMED-DESCRIPTION AXIOMS-STRING-ALIAS1 :RENAMES AXIOMS-STRING :OPTION-KEYWORD :<= :OPTION-HANDLER DECLARATION-HALF-RULE-HANDLER)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT NAMED-DESCRIPTION AXIOMS-STRING-ALIAS2 :RENAMES AXIOMS-STRING :OPTION-KEYWORD :=> :OPTION-HANDLER DECLARATION-HALF-RULE-HANDLER)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT NAMED-DESCRIPTION BACKWARD-AXIOMS-STRING :TYPE STRING :OPTION-KEYWORD :<<= :OPTION-HANDLER DECLARATION-HALF-RULE-HANDLER :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT NAMED-DESCRIPTION FORWARD-AXIOMS-STRING :TYPE STRING :OPTION-KEYWORD :=>> :OPTION-HANDLER DECLARATION-HALF-RULE-HANDLER :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT NAMED-DESCRIPTION AXIOMS-STRING-ALIAS3 :RENAMES AXIOMS-STRING :OPTION-KEYWORD :<=> :OPTION-HANDLER DECLARATION-HALF-RULE-HANDLER)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT NAMED-DESCRIPTION AXIOMS-STRING-ALIAS4 :RENAMES AXIOMS-STRING :OPTION-KEYWORD :<<=>> :OPTION-HANDLER DECLARATION-HALF-RULE-HANDLER)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT NAMED-DESCRIPTION PRETEND-DEFINITION-STRING :TYPE STRING :OPTION-KEYWORD :IFF :OPTION-HANDLER RELATION-IFF-HANDLER :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT NAMED-DESCRIPTION DECLARATION-ORIGINATED-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "RELATION-FULL-DEFINITION-HANDLER"
    "(DEFUN RELATION-FULL-DEFINITION-HANDLER ((SELF NAMED-DESCRIPTION) (SLOT STORAGE-SLOT) (DEFINITION OBJECT)))"
    (CL:FUNCTION RELATION-FULL-DEFINITION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATION-TERM-DEFINITION-HANDLER"
    "(DEFUN RELATION-TERM-DEFINITION-HANDLER ((SELF NAMED-DESCRIPTION) (SLOT STORAGE-SLOT) (DEFINITION OBJECT)))"
    (CL:FUNCTION RELATION-TERM-DEFINITION-HANDLER) NULL)))

(CL:DEFUN HELP-STARTUP-LOGIC-IN5 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "RELATION-IFF-HANDLER"
    "(DEFUN RELATION-IFF-HANDLER ((SELF NAMED-DESCRIPTION) (SLOT STORAGE-SLOT) (DEFINITION OBJECT)))"
    (CL:FUNCTION RELATION-IFF-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPLETE-TERM-DEFINITION"
    "(DEFUN (COMPLETE-TERM-DEFINITION OBJECT) ((SELF NAMED-DESCRIPTION) (DEFINITION OBJECT)))"
    (CL:FUNCTION COMPLETE-TERM-DEFINITION) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-RELATION-PARAMETERS-TREE"
    "(DEFUN (YIELD-RELATION-PARAMETERS-TREE CONS) ((SELF NAMED-DESCRIPTION) (DROPFUNCTIONPARAMETER? BOOLEAN) (TYPED? BOOLEAN)))"
    (CL:FUNCTION YIELD-RELATION-PARAMETERS-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-RELATION-AXIOMS"
    "(DEFUN (ADD-RELATION-AXIOMS OBJECT) ((SELF NAMED-DESCRIPTION) (OLDAXIOMS OBJECT) (NEWAXIOMS OBJECT)))"
    (CL:FUNCTION ADD-RELATION-AXIOMS) NULL)
   (DEFINE-FUNCTION-OBJECT "DECLARATION-AXIOMS-HANDLER"
    "(DEFUN DECLARATION-AXIOMS-HANDLER ((SELF NAMED-DESCRIPTION) (SLOT STORAGE-SLOT) (AXIOMS OBJECT)))"
    (CL:FUNCTION DECLARATION-AXIOMS-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "DECLARATION-HALF-RULE-HANDLER"
    "(DEFUN DECLARATION-HALF-RULE-HANDLER ((SELF NAMED-DESCRIPTION) (SLOT STORAGE-SLOT) (BODY OBJECT)))"
    (CL:FUNCTION DECLARATION-HALF-RULE-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "FINISH-HALF-RULE-HANDLER"
    "(DEFUN FINISH-HALF-RULE-HANDLER ((SELF NAMED-DESCRIPTION) (BODY OBJECT) (ARROW SYMBOL) (FORWARDORBACKWARD KEYWORD)))"
    (CL:FUNCTION FINISH-HALF-RULE-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPLETE-RULE-DEFINITION"
    "(DEFUN (COMPLETE-RULE-DEFINITION OBJECT) ((SELF NAMED-DESCRIPTION) (BODY OBJECT) (ARROW SYMBOL)))"
    (CL:FUNCTION COMPLETE-RULE-DEFINITION) NULL)
   (DEFINE-FUNCTION-OBJECT "LINK-RELATION-ORIGINATED-PROPOSITION"
    "(DEFUN LINK-RELATION-ORIGINATED-PROPOSITION ((RELATION NAMED-DESCRIPTION) (PROPOSITION PROPOSITION)))"
    (CL:FUNCTION LINK-RELATION-ORIGINATED-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-META-ASSERTIONS"
    "(DEFUN FINALIZE-META-ASSERTIONS ((SELF NAMED-DESCRIPTION)))"
    (CL:FUNCTION FINALIZE-META-ASSERTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "MARK-DIRECTION-OF-TOP-LEVEL-PROPOSITIONS"
    "(DEFUN MARK-DIRECTION-OF-TOP-LEVEL-PROPOSITIONS ((PROPOSITION PROPOSITION) (FORWARDORBACKWARD KEYWORD)))"
    (CL:FUNCTION MARK-DIRECTION-OF-TOP-LEVEL-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-FINALIZE-AXIOMS?"
    "(DEFUN (HELP-FINALIZE-AXIOMS? (CONS OF PROPOSITION)) ((AXIOMSSTRING STRING) (SELF NAMED-DESCRIPTION) (FORWARDORBACKWARD KEYWORD)))"
    (CL:FUNCTION HELP-FINALIZE-AXIOMS?) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-RELATION-AXIOMS"
    "(DEFUN FINALIZE-RELATION-AXIOMS ((SELF NAMED-DESCRIPTION)))"
    (CL:FUNCTION FINALIZE-RELATION-AXIOMS) NULL)
   (DEFINE-FUNCTION-OBJECT "CHECK-DESCRIPTION-ARGUMENT-TYPES"
    "(DEFUN CHECK-DESCRIPTION-ARGUMENT-TYPES ((SELF NAMED-DESCRIPTION)))"
    (CL:FUNCTION CHECK-DESCRIPTION-ARGUMENT-TYPES) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZED-RELATION?"
    "(DEFUN (FINALIZED-RELATION? BOOLEAN) ((SELF NAMED-DESCRIPTION)))"
    (CL:FUNCTION FINALIZED-RELATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATIONS-ARE-FINALIZED?"
    "(DEFUN (RELATIONS-ARE-FINALIZED? BOOLEAN) ())"
    (CL:FUNCTION RELATIONS-ARE-FINALIZED?) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-RELATIONS"
    "(DEFUN FINALIZE-RELATIONS () :DOCUMENTATION \"Finalize all currently unfinalized relations.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FINALIZE-RELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-RELATION-FROM-PARSE-TREE"
    "(DEFUN (DEFINE-RELATION-FROM-PARSE-TREE NAMED-DESCRIPTION) ((TREE CONS)))"
    (CL:FUNCTION DEFINE-RELATION-FROM-PARSE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFFUNCTION"
    "(DEFUN (DEFFUNCTION NAMED-DESCRIPTION) (|&REST| (ARGS PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Define (or redefine) a logic function.  The accepted syntax is:
	 
  (deffunction {<function-name> |
                (<function-name> <value-type>)} (<var>+)
     [:documentation <docstring>]
     [:-> <value-variable>]
     [:type <value-type>]
     [[{:definition | :is} <relation-expression>] |
      [:<=> <sentence-with-argument-variables>] |
      [:= <term-expression-with-argument-variables>]]
     [:polymorphic? {TRUE | FALSE}]
     [:axioms {<sentence> | (<sentence>+)}]
     [:=> {<sentence-with-argument-variables> |
                    (<sentence-with-argument-variables>+)}]
     [:properties <list-of-properties>]
     [:meta-attributes <list-of-key-value-pairs>]
     [<other-options>*])
	
Function parameters can be typed or untyped.  A typed first parameter
combined with a `:polymorphic? TRUE' specification defines a polymorphic
function.  Otherwise, the function will be non-polymorphic. If a value
variable is specified, it must be specified before any definition options,
otherwise, the expansions of definitions might be incorrect.  The default
KIF value variable is `?value'.\")" (CL:FUNCTION %DEFFUNCTION)
    (CL:FUNCTION DEFFUNCTION-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "DEFRELATION"
    "(DEFUN (DEFRELATION NAMED-DESCRIPTION) (|&REST| (ARGS PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Define (or redefine) a logic relation.  The accepted syntax is:
	 
  (defrelation {<relation-name> | 
                (<relation-name> BOOLEAN)} (<var>+)
     [:documentation <docstring>]
     [:type BOOLEAN]
     [[{:definition | :is} <relation-expression>] |
      [:<=> <sentence-with-argument-variables>]]
     [:polymorphic? {TRUE | FALSE}]
     [:axioms {<sentence> | (<sentence>+)}]
     [:=> {<sentence-with-argument-variables> |
                    (<sentence-with-argument-variables>+)}]
     [:properties <list-of-properties>]
     [:meta-attributes <list-of-key-value-pairs>]
     [<other-options>*])
	
Relation parameters can be typed or untyped.  A typed first parameter
combined with a `:polymorphic? TRUE' specification defines a polymorphic
relation.  Otherwise, the relation will be non-polymorphic.\")"
    (CL:FUNCTION %DEFRELATION)
    (CL:FUNCTION DEFRELATION-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "DEFINE-LOGIC-TERM"
    "(DEFUN (DEFINE-LOGIC-TERM OBJECT) ((NAME SYMBOL)))"
    (CL:FUNCTION DEFINE-LOGIC-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFOBJECT"
    "(DEFUN (DEFOBJECT LOGIC-OBJECT) ((NAME SYMBOL) |&REST| (ARGS PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Define (or redefine) a logic instance.\")"
    (CL:FUNCTION %DEFOBJECT) (CL:FUNCTION DEFOBJECT-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "DEFINSTANCE"
    "(DEFUN (DEFINSTANCE LOGIC-OBJECT) ((NAME SYMBOL) |&REST| (ARGS PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Define (or redefine) a logic instance.\")"
    (CL:FUNCTION %DEFINSTANCE)
    (CL:FUNCTION DEFINSTANCE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "DEFCLASS"
    "(DEFUN (DEFCLASS CLASS) (|&REST| (ARGS PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :NATIVE? TRUE :DOCUMENTATION \"Define (or redefine) a class.  The accepted syntax is:
	 
  (defclass <class-name> (<superclass-name>*)
     [:documentation <docstring>]
     [:self-variable <var>]
     [[{:definition | :is} <relation-expression>] |
      [:<=> <sentence-with-argument-variables>]]
     [:axioms {<sentence> | (<sentence>+)}]
     [:=> {<sentence-with-argument-variables> |
                    (<sentence-with-argument-variables>+)}]
     [:properties <list-of-properties>]
     [:meta-attributes <list-of-key-value-pairs>]
     [:slots ({(<slot-name> <slot-options>*)}*)]
     [<other-options>*])
	
<slot-options> is a list of keyword/value pairs.  The set of legal slot
options is the same as those accepted by `defrelation'.\")" NULL NULL)
   (DEFINE-FUNCTION-OBJECT "DEFCONCEPT"
    "(DEFUN (DEFCONCEPT NAMED-DESCRIPTION) (|&REST| (ARGS PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Define (or redefine) a class.\")"
    (CL:FUNCTION %DEFCONCEPT) (CL:FUNCTION DEFCONCEPT-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "COMMAND<"
    "(DEFUN (COMMAND< BOOLEAN) ((COMMAND1 METHOD-SLOT) (COMMAND2 METHOD-SLOT)))"
    (CL:FUNCTION COMMAND<) NULL)
   (DEFINE-FUNCTION-OBJECT "LIST-LOGIC-COMMANDS"
    "(DEFUN (LIST-LOGIC-COMMANDS (LIST OF METHOD-SLOT)) ())"
    (CL:FUNCTION LIST-LOGIC-COMMANDS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP"
    "(DEFUN HELP (|&REST| (COMMANDS SYMBOL)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Describe specific commands, or print a list of available commands.\")"
    (CL:FUNCTION %HELP) (CL:FUNCTION HELP-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "STARTUP-LOGIC-IN"
    "(DEFUN STARTUP-LOGIC-IN () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-LOGIC-IN) NULL)
   (CL:LET*
    ((FUNCTION (LOOKUP-FUNCTION SYM-LOGIC-IN-LOGIC-STARTUP-LOGIC-IN)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-LOGIC-IN-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "Startup-Logic-In") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-LOGIC-IN ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-LOGIC-IN1)
    (HELP-STARTUP-LOGIC-IN2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4) (HELP-STARTUP-LOGIC-IN3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-LOGIC-IN4)
    (HELP-STARTUP-LOGIC-IN5))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *AVAILABLE-POWERLOOM-FEATURES* (LIST OF KEYWORD) (LIST :TRACE-SUBGOALS :TRACE-CLASSIFIER :CLOSED-WORLD :ITERATIVE-DEEPENING :JUSTIFICATIONS :JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS) :DOCUMENTATION \"List of PowerLoom environment features.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CURRENT-POWERLOOM-FEATURES* (LIST OF KEYWORD) (LIST) :DOCUMENTATION \"List of currently enabled PowerLoom environment features.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEFAULT-POWERLOOM-FEATURES* (LIST OF KEYWORD) (LIST :JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS) :DOCUMENTATION \"List of PowerLoom environment features enabled upon call to
'reset-features'.\")")
    (REGISTER-NATIVE-NAME SYM-LOGIC-IN-LOGIC-SET-FEATURE
     KWD-LOGIC-IN-COMMON-LISP KWD-LOGIC-IN-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-LOGIC-IN-LOGIC-UNSET-FEATURE
     KWD-LOGIC-IN-COMMON-LISP KWD-LOGIC-IN-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOGIC-PROMPT* STRING \"|= \" :DOCUMENTATION \"The prompt used by the PowerLoom listener.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOGIC-COMMAND-RESULT-INDENT* STRING \"\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? BOOLEAN (VERBATIM :COMMON-LISP FALSE :OTHERWISE TRUE) :DOCUMENTATION \"If TRUE exiting from the logic-command loop (or PowerLoom
listener) will be protected by a confirmation dialog.  This is mainly useful
for C++ where exiting the listener will also exit the program.\" :PUBLIC? TRUE)")
    (REGISTER-NATIVE-NAME SYM-LOGIC-IN-LOGIC-LOAD KWD-LOGIC-IN-COMMON-LISP
     KWD-LOGIC-IN-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DEMO-LEVEL* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEMO-FILE-DIRECTORY* STRING \"PL:sources;logic;demos;\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEMO-FILE-SUFFIX* STRING \".ste\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEMO-FILES* (CONS OF (CONS OF STRING-WRAPPER)) (BQUOTE ((\"basics\" \"Basic PowerLoom commands\" \"test-suite\") (\"classes\" \"Primitive and defined classes\" \"test-suite\") (\"collections\" \"Reasoning with collections\" \"test-suite\") (\"append\" \"Prolog-style `append'\" \"test-suite\") (\"named-rules\" \"Using named rules\" \"test-suite\") (\"recursion\" \"Reasoning with recursive rules\" \"test-suite\") (\"negation\" \"Reasoning with negation\" \"test-suite\") (\"constraints\" \"Constraint propagation\" \"test-suite\") (\"subsumption\" \"Simple subsumption reasoning\" \"test-suite\") (\"family\" \"Subsumption reasoning within a family ontology\" \"test-suite\") (\"relation-hierarchy\" \"Finding sub, super and equivalent concepts and relations\" \"test-suite\") (\"defaults\" \"Default reasoning with Tweety and friends\" \"test-suite\") (\"defaults2\" \"More default reasoning\" \"test-suite\") (\"definition-syntax\" \"The whole scoop on relation definition, funny arrows, etc.\" \"test-suite\") (\"meta-relations\" \"Using meta-properties and relations\" \"test-suite\") (\"partial-match\" \"Reasoning with partial information\" \"test-suite\") (\"probability-learning\" \"Learning to answer probabilistic queries\" \"test-suite\") (\"regression-demo\" \"Learning to predict functions\") (\"rule-induction-demo\" \"Learning inference rules\") (\"test-suite\" \"PowerLoom test suite\" \"test-suite\"))) :DOCUMENTATION \"List of example demo files.
Each entry is a `(<file> <description>)' pair.\")")
    (REGISTER-NATIVE-NAME SYM-LOGIC-IN-LOGIC-DEMO KWD-LOGIC-IN-COMMON-LISP
     KWD-LOGIC-IN-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TERMSOURCEBEINGPARSED* STRING NULL :DOCUMENTATION \"Points to the source of the relation being parsed.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DESCRIPTIONUNDERCONSTRUCTION* OBJECT NULL :DOCUMENTATION \"Pofints to a description or its parse tree which
is the input to the description being constructed.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TERMUNDERCONSTRUCTION* OBJECT NULL :DOCUMENTATION \"Points to the parse tree which is the input to the
proposition being constructed.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EXPRESSION-SIZE-CUTOFF* INTEGER 300 :DOCUMENTATION \"Limit on how big an s-expression we will print within
an error message.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *UNFINALIZED-RELATIONS* (LIST OF NAMED-DESCRIPTION) (LIST) :DOCUMENTATION \"List of relations whose definitions and/or associated
axioms and constraints are not yet processed.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *INHIBITRELATIONFINALIZATION?* BOOLEAN FALSE :DOCUMENTATION \"Used to prevent finalization from triggering in the
middle of 'delicate' computations.  Also used to prevent recursive
invocation of 'finalize-relations'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *RELATIONSAREFINALIZED?* BOOLEAN FALSE :DOCUMENTATION \"Set to false whenever a relation has been
posted for finalization.\")")
    (REGISTER-NATIVE-NAME SYM-LOGIC-IN-LOGIC-DEFFUNCTION
     KWD-LOGIC-IN-COMMON-LISP KWD-LOGIC-IN-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-LOGIC-IN-LOGIC-DEFRELATION
     KWD-LOGIC-IN-COMMON-LISP KWD-LOGIC-IN-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-LOGIC-IN-LOGIC-DEFOBJECT
     KWD-LOGIC-IN-COMMON-LISP KWD-LOGIC-IN-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-LOGIC-IN-LOGIC-DEFINSTANCE
     KWD-LOGIC-IN-COMMON-LISP KWD-LOGIC-IN-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-LOGIC-IN-LOGIC-DEFCONCEPT
     KWD-LOGIC-IN-COMMON-LISP KWD-LOGIC-IN-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOGIC-RELEVANT-STELLA-COMMANDS* (CONS OF SYMBOL) (BQUOTE (CC CLEAR-MODULE DEFCLASS DEFMODULE IN-MODULE)))")
    (REGISTER-NATIVE-NAME SYM-LOGIC-IN-LOGIC-HELP KWD-LOGIC-IN-COMMON-LISP
     KWD-LOGIC-IN-FUNCTION))))
