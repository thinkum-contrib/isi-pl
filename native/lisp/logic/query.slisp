;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; query.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-QUERY-LOGIC-INFERENCE-LEVEL NULL)
(CL:DEFVAR SYM-QUERY-STELLA-KEYWORD NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-NORMAL-INFERENCE-LEVEL NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-BACKTRACKING-INFERENCE-LEVEL NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-SUBSUMPTION-INFERENCE-LEVEL NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-SHALLOW-INFERENCE-LEVEL NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-ASSERTION-INFERENCE-LEVEL NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-REFUTATION-INFERENCE-LEVEL NULL)
(CL:DEFVAR KWD-QUERY-NORMAL NULL)
(CL:DEFVAR KWD-QUERY-BACKTRACKING NULL)
(CL:DEFVAR KWD-QUERY-SUBSUMPTION NULL)
(CL:DEFVAR KWD-QUERY-SHALLOW NULL)
(CL:DEFVAR KWD-QUERY-ASSERTION NULL)
(CL:DEFVAR KWD-QUERY-REFUTATION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-INFERENCE-LEVEL NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-SET-INFERENCE-LEVEL NULL)
(CL:DEFVAR KWD-QUERY-COMMON-LISP NULL)
(CL:DEFVAR KWD-QUERY-FUNCTION NULL)
(CL:DEFVAR KWD-QUERY-LOOKUP NULL)
(CL:DEFVAR KWD-QUERY-DUPLICATE-GOALS NULL)
(CL:DEFVAR KWD-QUERY-TRACE-SUBGOALS NULL)
(CL:DEFVAR KWD-QUERY-PROPAGATE NULL)
(CL:DEFVAR KWD-QUERY-STRATEGIES NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-COST-ESTIMATE NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-QUERY-ITERATOR NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-RESIDUE-GOALS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-BEST-GOAL-SEQUENCE NULL)
(CL:DEFVAR SYM-QUERY-STELLA-BAD? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-EXTERNAL-VARIABLES NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-EXHAUSTED? NULL)
(CL:DEFVAR SYM-QUERY-STELLA-OPTIONS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-SOLUTIONS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-QUERY-CONTEXT NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-BASE-CONTROL-FRAME NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CURRENT-CONTROL-FRAME NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CURRENT-PATTERN-RECORD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CURRENT-PARALLEL-THREAD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CONTROL-FRAME-PRIORITY-QUEUE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-AUGMENTED-GOAL-CACHE? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ACTIVE-GOAL-CACHES NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-TRIGGERED-DEPTH-CUTOFF? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-FAILED-TO-FIND-DUPLICATE-SUBGOAL? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-FOUND-AT-LEAST-ONE-SOLUTION? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-TIMESTAMP NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-PARTIAL-MATCH-STRATEGY NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CURRENT-DEPTH-CUTOFF NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-MAXIMUM-DEPTH NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ALLOTTED-TIME NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ALLOTTED-CLOCK-TICKS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CURRENT-CLOCK-TICKS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-TIMEOUT? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-NEGATED-QUERY NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-LATEST-PARTIAL-SCORE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-AUXILIARY-QUERY NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE NULL)
(CL:DEFVAR SYM-QUERY-STELLA-DELETED-OBJECT? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-GOAL-BINDINGS NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-CONTROL-FRAME NULL)
(CL:DEFVAR SYM-QUERY-STELLA-STATE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-TRUTH-VALUE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-REVERSE-POLARITY? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-STARTING-CLOCK-TICKS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-UP NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-DOWN NULL)
(CL:DEFVAR SYM-QUERY-STELLA-RESULT NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ARGUMENT-CURSOR NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-PATTERN-RECORD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-INHERITED-PATTERN-RECORD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CHOICE-POINT-UNBINDING-OFFSET NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CURRENT-STRATEGY NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-NEXT-STRATEGIES NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-PARTIAL-MATCH-FRAME NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-JUSTIFICATIONS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CACHED-GOAL-RESULT? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-DONT-CACHE-GOAL-FAILURE? NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-PARALLEL-THREAD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-TOP-CONTROL-FRAME NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-HYPOTHETICAL-WORLD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-VARIABLE-BINDINGS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-UNBINDING-STACK NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-TOP-UNBINDING-STACK-OFFSET NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-PRIORITY NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-STATUS NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-PARALLEL-CONTROL-FRAME NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CHILD-THREADS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-UNBOUND-VARIABLES? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CURRENT-CHILD-THREAD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-SAVED-PARENT-CONTEXT NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-SAVED-PARENT-PARALLEL-THREAD NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-CONTROL-FRAME-PRIORITY-QUEUE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-QUEUE NULL)
(CL:DEFVAR KWD-QUERY-UPCLASSIFY NULL)
(CL:DEFVAR KWD-QUERY-DOWNCLASSIFY NULL)
(CL:DEFVAR KWD-QUERY-PARTIAL-MATCH NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-PROOF-ADJUNCT NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-PATTERN-RECORD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CONTROL-FRAME NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-EXTERNAL-ARGUMENTS NULL)
(CL:DEFVAR SYM-QUERY-STELLA-BOOLEAN-VECTOR NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-OPTIMAL-PATTERN NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-COLLECTION-LIST NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-BOOLEAN-VECTOR-INDEX-NODE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-TRUE-LINK NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-FALSE-LINK NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-THE-VECTOR NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR KWD-QUERY-PATTERN NULL)
(CL:DEFVAR KWD-QUERY-CONTAINED-BY NULL)
(CL:DEFVAR KWD-QUERY-PARENT NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CACHED-BINDINGS-ITERATOR NULL)
(CL:DEFVAR KWD-QUERY-POPPED NULL)
(CL:DEFVAR KWD-QUERY-LOCAL NULL)
(CL:DEFVAR KWD-QUERY-QUERY-STACKS NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-QUERY-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR KWD-QUERY-NONE NULL)
(CL:DEFVAR KWD-QUERY-SHALLOW-DISJOINT NULL)
(CL:DEFVAR KWD-QUERY-DISJOINT NULL)
(CL:DEFVAR KWD-QUERY-ISA NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR KWD-QUERY-PERFORMANCE-CLUES NULL)
(CL:DEFVAR KWD-QUERY-WARNING NULL)
(CL:DEFVAR SYM-QUERY-STELLA-NULL NULL)
(CL:DEFVAR SGT-QUERY-STELLA-LIST NULL)
(CL:DEFVAR SYM-QUERY-STELLA-SURROGATE-VALUE-INVERSE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-MASTER-PROPOSITION NULL)
(CL:DEFVAR KWD-QUERY-FLAT NULL)
(CL:DEFVAR KWD-QUERY-REALISTIC NULL)
(CL:DEFVAR KWD-QUERY-DOWN NULL)
(CL:DEFVAR KWD-QUERY-ITERATIVE-FORALL NULL)
(CL:DEFVAR KWD-QUERY-STATE-MACHINE NULL)
(CL:DEFVAR KWD-QUERY-PARALLEL-STRATEGIES NULL)
(CL:DEFVAR KWD-QUERY-STRATEGY NULL)
(CL:DEFVAR KWD-QUERY-SPECIALIST NULL)
(CL:DEFVAR KWD-QUERY-ATOMIC-GOAL NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ANTECEDENTS-RULE NULL)
(CL:DEFVAR KWD-QUERY-UP-TRUE NULL)
(CL:DEFVAR KWD-QUERY-UP-FAIL NULL)
(CL:DEFVAR KWD-QUERY-AND NULL)
(CL:DEFVAR KWD-QUERY-GOAL-TREE NULL)
(CL:DEFVAR KWD-QUERY-OR NULL)
(CL:DEFVAR KWD-QUERY-NOT NULL)
(CL:DEFVAR KWD-QUERY-FULL-SUBQUERY NULL)
(CL:DEFVAR KWD-QUERY-ANTECEDENTS NULL)
(CL:DEFVAR SYM-QUERY-STELLA-ITERATOR NULL)
(CL:DEFVAR KWD-QUERY-FAILURE NULL)
(CL:DEFVAR KWD-QUERY-FINAL-SUCCESS NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-NN-PARTIAL-MATCH NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-MATCH-SCORE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-SUPPORT NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-BACK NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-JUSTIFICATION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-GOAL-CACHE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-DEBUG-FRAME-ID-INTERNAL NULL)
(CL:DEFVAR KWD-QUERY-MOVE-DOWN NULL)
(CL:DEFVAR KWD-QUERY-CONTINUING-SUCCESS NULL)
(CL:DEFVAR KWD-QUERY-MOVE-IN-PLACE NULL)
(CL:DEFVAR KWD-QUERY-TIMEOUT NULL)
(CL:DEFVAR KWD-QUERY-PREDICATE NULL)
(CL:DEFVAR KWD-QUERY-EQUIVALENT NULL)
(CL:DEFVAR KWD-QUERY-IMPLIES NULL)
(CL:DEFVAR KWD-QUERY-SCAN-CACHED-BINDINGS NULL)
(CL:DEFVAR KWD-QUERY-FORALL NULL)
(CL:DEFVAR KWD-QUERY-EXISTS NULL)
(CL:DEFVAR KWD-QUERY-CONSTANT NULL)
(CL:DEFVAR KWD-QUERY-FAIL NULL)
(CL:DEFVAR KWD-QUERY-CLUSTERED-CONJUNCTION NULL)
(CL:DEFVAR SYM-QUERY-STELLA-ARGUMENTS NULL)
(CL:DEFVAR KWD-QUERY-DISJUNCTIVE-IMPLICATION-INTRODUCTION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-FAIL NULL)
(CL:DEFVAR KWD-QUERY-DUPLICATE-GOALS-WITH-CACHING NULL)
(CL:DEFVAR KWD-QUERY-MANUFACTURE-SKOLEM NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR KWD-QUERY-DESCRIPTION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CACHED-SINGLE-VALUED? NULL)
(CL:DEFVAR KWD-QUERY-FAILED-OVERLAY NULL)
(CL:DEFVAR SGT-QUERY-PL-KERNEL-KB-DISJOINT NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-?D1 NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-?D2 NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-DISJOINT NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-F-DISJOINT-TERMS?-QUERY-000 NULL)
(CL:DEFVAR SYM-QUERY-STELLA-OR NULL)
(CL:DEFVAR SYM-QUERY-STELLA-AND NULL)
(CL:DEFVAR SYM-QUERY-PL-KERNEL-KB-CLASS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-REFUTATION-DISJOINT NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-F-EXPENSIVE-DISJOINT-TERMS?-QUERY-000 NULL)
(CL:DEFVAR SGT-QUERY-PL-KERNEL-KB-COLLECTIONOF NULL)
(CL:DEFVAR SGT-QUERY-PL-KERNEL-KB-MEMBER-OF NULL)
(CL:DEFVAR SGT-QUERY-STELLA-COLLECTION NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-SKOLEM NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-DESCRIPTION-EXTENSION-ITERATOR NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ROOT-DESCRIPTION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-SUBCOLLECTIONS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-EXTENSION-ITERATOR NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-REFERENCE-PROPOSITION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ALREADY-GENERATED-LIST NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ALREADY-GENERATED-TABLE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-REMOVING-DUPLICATES? NULL)
(CL:DEFVAR KWD-QUERY-GOAL-CACHES NULL)
(CL:DEFVAR KWD-QUERY-DEPTH-VIOLATION NULL)
(CL:DEFVAR KWD-QUERY-DEPTH-CUTOFF NULL)
(CL:DEFVAR KWD-QUERY-TECHNICAL NULL)
(CL:DEFVAR KWD-QUERY-LAY NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-QUERY-SOLUTION-TABLE NULL)
(CL:DEFVAR SYM-QUERY-STELLA-THE-MAP NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-QUERY NULL)
(CL:DEFVAR SYM-QUERY-STELLA-FIRST NULL)
(CL:DEFVAR SYM-QUERY-STELLA-LAST NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-QUERY-SOLUTION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-BINDINGS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-BEST-JUSTIFICATION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ALL-JUSTIFICATIONS NULL)
(CL:DEFVAR SYM-QUERY-STELLA-NEXT NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-QUERY-SOLUTION-TABLE-ITERATOR NULL)
(CL:DEFVAR SYM-QUERY-STELLA-THE-TABLE NULL)
(CL:DEFVAR SYM-QUERY-STELLA-CURSOR NULL)
(CL:DEFVAR KWD-QUERY-TRACE-SOLUTIONS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ATOMIC-SINGLETONS? NULL)
(CL:DEFVAR KWD-QUERY-EXECUTE-QUERY NULL)
(CL:DEFVAR KWD-QUERY-DONT-OPTIMIZE? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-DONT-OPTIMIZE? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-INITIAL-BINDINGS NULL)
(CL:DEFVAR KWD-QUERY-ITERATIVE-DEEPENING? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ITERATIVE-DEEPENING? NULL)
(CL:DEFVAR KWD-QUERY-MATCH-MODE NULL)
(CL:DEFVAR KWD-QUERY-STRICT NULL)
(CL:DEFVAR KWD-QUERY-DEFERRED-OPTIONS NULL)
(CL:DEFVAR KWD-QUERY-ERROR NULL)
(CL:DEFVAR SYM-QUERY-STELLA-TRUE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-KAPPA NULL)
(CL:DEFVAR SYM-QUERY-STELLA-EXISTS NULL)
(CL:DEFVAR KWD-QUERY-HOW-MANY NULL)
(CL:DEFVAR KWD-QUERY-SORT-BY NULL)
(CL:DEFVAR KWD-QUERY-SCORE NULL)
(CL:DEFVAR KWD-QUERY-MOVEOUT NULL)
(CL:DEFVAR KWD-QUERY-MAXIMUM-DEPTH NULL)
(CL:DEFVAR KWD-QUERY-INFERENCE-LEVEL NULL)
(CL:DEFVAR SGT-QUERY-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR KWD-QUERY-THREE-VALUED? NULL)
(CL:DEFVAR KWD-QUERY-SINGLETONS? NULL)
(CL:DEFVAR KWD-QUERY-MINIMUM-SCORE NULL)
(CL:DEFVAR KWD-QUERY-MAXIMIZE-SCORE? NULL)
(CL:DEFVAR KWD-QUERY-MAXIMUM-UNKNOWNS NULL)
(CL:DEFVAR SGT-QUERY-STELLA-PROPERTY-LIST NULL)
(CL:DEFVAR SGT-QUERY-STELLA-CONS NULL)
(CL:DEFVAR SYM-QUERY-STELLA-ASK NULL)
(CL:DEFVAR SYM-QUERY-STELLA-RETRIEVE NULL)
(CL:DEFVAR KWD-QUERY-DYNAMIC NULL)
(CL:DEFVAR KWD-QUERY-DYNAMIC-WITH-CLUSTERING NULL)
(CL:DEFVAR SGT-QUERY-PL-KERNEL-KB-CONCEPT-PROTOTYPE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-?C NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-?P NULL)
(CL:DEFVAR SYM-QUERY-PL-KERNEL-KB-CONCEPT-PROTOTYPE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-F-GET-PROTOTYPE-QUERY-000 NULL)
(CL:DEFVAR KWD-QUERY-EXTENSIONAL-ASSERTION NULL)
(CL:DEFVAR KWD-QUERY-META NULL)
(CL:DEFVAR SGT-QUERY-STELLA-RELATION NULL)
(CL:DEFVAR SGT-QUERY-STELLA-VECTOR NULL)
(CL:DEFVAR KWD-QUERY-UPDATE-FROM-QUERY NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-DESCRIPTIVE? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-WEIGHT NULL)
(CL:DEFVAR KWD-QUERY-MODULE NULL)
(CL:DEFVAR SGT-QUERY-STELLA-MODULE NULL)
(CL:DEFVAR KWD-QUERY-RELATION NULL)
(CL:DEFVAR KWD-QUERY-ASSERT-TRUE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ASSERT-FROM-QUERY NULL)
(CL:DEFVAR KWD-QUERY-RETRACT-TRUE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-RETRACT-FROM-QUERY NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-STARTUP-QUERY NULL)
(CL:DEFVAR SYM-QUERY-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *LAZY-SATELLITE-RULES?*
  *CACHE-GOAL-QUANTUM* *CACHE-INFERABLE-SUBCOLLECTIONS?*
  *CLASSIFY-FROM-NON-INFERABLE-PARENTS-ONLY?*
  *QUERY-OPTIMIZATION-STRATEGY* STANDARD-ERROR *MOST-RECENT-QUERY*
  *PRINTLENGTH* *PRINTREADABLY?* *CYC-KLUDGES-ENABLED?* ZERO-WRAPPER
  *RECORD-JUSTIFICATIONS?* *CACHE-SUCCEEDED-GOALS?*
  *CACHE-FAILED-GOALS?* *CONTEXT* NULL-INTEGER-WRAPPER
  *PARTIAL-SUPPORT-COUNTER* NULL-FLOAT-WRAPPER *FAIL-UNBOUND-CLAUSES?*
  TRUE-TRUTH-VALUE FALSE-TRUTH-VALUE UNKNOWN-TRUTH-VALUE
  STANDARD-WARNING ONE-WRAPPER STANDARD-OUTPUT DEFAULT-TRUE-TRUTH-VALUE
  DEFAULT-FALSE-TRUTH-VALUE NIL TRUE-WRAPPER FALSE-WRAPPER NIL-LIST
  NULL-FLOAT *TRACED-KEYWORDS* *CURRENT-POWERLOOM-FEATURES*
  NULL-INTEGER EOL *QUERYITERATOR* *MODULE*))

(CL:DEFUN NEW-INFERENCE-LEVEL ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-INFERENCE-LEVEL))
   (CL:SETF (%INFERENCE-LEVEL.KEYWORD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INFERENCE-LEVEL))
  SGT-QUERY-LOGIC-INFERENCE-LEVEL)

(CL:DEFUN ACCESS-INFERENCE-LEVEL-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-STELLA-KEYWORD)
    (CL:IF SETVALUE? (CL:SETF (%INFERENCE-LEVEL.KEYWORD SELF) VALUE)
     (CL:SETQ VALUE (%INFERENCE-LEVEL.KEYWORD SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFUN NEW-NORMAL-INFERENCE-LEVEL ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-NORMAL-INFERENCE-LEVEL))
   (CL:SETF (%NORMAL-INFERENCE-LEVEL.KEYWORD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF NORMAL-INFERENCE-LEVEL))
  SGT-QUERY-LOGIC-NORMAL-INFERENCE-LEVEL)

(CL:DEFUN NEW-BACKTRACKING-INFERENCE-LEVEL ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-BACKTRACKING-INFERENCE-LEVEL))
   (CL:SETF (%BACKTRACKING-INFERENCE-LEVEL.KEYWORD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF BACKTRACKING-INFERENCE-LEVEL))
  SGT-QUERY-LOGIC-BACKTRACKING-INFERENCE-LEVEL)

(CL:DEFUN NEW-SUBSUMPTION-INFERENCE-LEVEL ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-SUBSUMPTION-INFERENCE-LEVEL))
   (CL:SETF (%SUBSUMPTION-INFERENCE-LEVEL.KEYWORD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SUBSUMPTION-INFERENCE-LEVEL))
  SGT-QUERY-LOGIC-SUBSUMPTION-INFERENCE-LEVEL)

(CL:DEFUN NEW-SHALLOW-INFERENCE-LEVEL ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-SHALLOW-INFERENCE-LEVEL))
   (CL:SETF (%SHALLOW-INFERENCE-LEVEL.KEYWORD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SHALLOW-INFERENCE-LEVEL))
  SGT-QUERY-LOGIC-SHALLOW-INFERENCE-LEVEL)

(CL:DEFUN NEW-ASSERTION-INFERENCE-LEVEL ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-ASSERTION-INFERENCE-LEVEL))
   (CL:SETF (%ASSERTION-INFERENCE-LEVEL.KEYWORD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ASSERTION-INFERENCE-LEVEL))
  SGT-QUERY-LOGIC-ASSERTION-INFERENCE-LEVEL)

(CL:DEFUN NEW-REFUTATION-INFERENCE-LEVEL ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-REFUTATION-INFERENCE-LEVEL))
   (CL:SETF (%REFUTATION-INFERENCE-LEVEL.KEYWORD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF REFUTATION-INFERENCE-LEVEL))
  SGT-QUERY-LOGIC-REFUTATION-INFERENCE-LEVEL)

;;; (DEFGLOBAL NORMAL-INFERENCE ...)

(CL:DEFVAR NORMAL-INFERENCE NULL)

;;; (DEFGLOBAL BACKTRACKING-INFERENCE ...)

(CL:DEFVAR BACKTRACKING-INFERENCE NULL)

;;; (DEFGLOBAL SUBSUMPTION-INFERENCE ...)

(CL:DEFVAR SUBSUMPTION-INFERENCE NULL)

;;; (DEFGLOBAL SHALLOW-INFERENCE ...)

(CL:DEFVAR SHALLOW-INFERENCE NULL)

;;; (DEFGLOBAL ASSERTION-INFERENCE ...)

(CL:DEFVAR ASSERTION-INFERENCE NULL)

;;; (DEFGLOBAL REFUTATION-INFERENCE ...)

(CL:DEFVAR REFUTATION-INFERENCE NULL)

;;; (DEFSPECIAL *INFERENCELEVEL* ...)

(CL:DEFVAR *INFERENCELEVEL* NULL
  "Specifies the level/depth of inference applied
during a query.  Possible values are:
  :ASSERTION -- database lookup with no inheritance;
  :SHALLOW -- includes database lookup, computed predicates and specialists;
  :SUBSUMPTION -- shallow plus cached subsumption links and equality reasoning;
  :BACKTRACKING -- all of the above plus backtracking over rules;
  :NORMAL -- all of the above plus universal introduction;
  :REFUTATION -- all of the above plus disjunctive implication introduction and refutation.")

;;; (DEFUN (CURRENT-INFERENCE-LEVEL NORMAL-INFERENCE-LEVEL) ...)

(CL:DEFUN CURRENT-INFERENCE-LEVEL ()
  "Return the current inference level that is active in the
current query, the current module, or, otherwise, globally."
  (CL:LET*
   ((LEVEL
     (CL:IF (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (%QUERY-ITERATOR.INFERENCE-LEVEL *QUERYITERATOR*)
      (DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS *MODULE*)
       SYM-QUERY-LOGIC-INFERENCE-LEVEL NULL))))
   (CL:IF (CL:NOT (CL:EQ LEVEL NULL)) LEVEL *INFERENCELEVEL*)))

;;; (DEFUN (GET-INFERENCE-LEVEL INFERENCE-LEVEL) ...)

(CL:DEFUN GET-INFERENCE-LEVEL (LEVELKEYWORD)
  (CL:COND
   ((CL:EQ LEVELKEYWORD KWD-QUERY-NORMAL)
    (CL:RETURN-FROM GET-INFERENCE-LEVEL NORMAL-INFERENCE))
   ((CL:EQ LEVELKEYWORD KWD-QUERY-SHALLOW)
    (CL:RETURN-FROM GET-INFERENCE-LEVEL SHALLOW-INFERENCE))
   ((CL:EQ LEVELKEYWORD KWD-QUERY-ASSERTION)
    (CL:RETURN-FROM GET-INFERENCE-LEVEL ASSERTION-INFERENCE))
   ((CL:EQ LEVELKEYWORD KWD-QUERY-SUBSUMPTION)
    (CL:RETURN-FROM GET-INFERENCE-LEVEL SUBSUMPTION-INFERENCE))
   ((CL:EQ LEVELKEYWORD KWD-QUERY-BACKTRACKING)
    (CL:RETURN-FROM GET-INFERENCE-LEVEL BACKTRACKING-INFERENCE))
   ((CL:EQ LEVELKEYWORD KWD-QUERY-REFUTATION)
    (CL:RETURN-FROM GET-INFERENCE-LEVEL REFUTATION-INFERENCE))
   (CL:T
    (CL:WARN
     "Illegal inference level: `~A'.~%   Legal values are :ASSERTION :SHALLOW :SUBSUMPTION :BACKTRACKING :NORMAL :REFUTATION.~%"
     LEVELKEYWORD)))
  *INFERENCELEVEL*)

;;; (DEFUN (SET-INFERENCE-LEVEL KEYWORD) ...)

(CL:DEFUN %SET-INFERENCE-LEVEL (LEVEL MODULE)
  "Set the inference level of `module' to the level specified
by 'levelKeyword'.  If `module' is NULL, set the level globally."
  (CL:LET*
   ((THEMODULE (COERCE-TO-MODULE MODULE CL:T))
    (THELEVEL (KEYWORDIFY (COERCE-TO-STRING LEVEL))))
   (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ THEMODULE NULL))
   (CALL-SET-INFERENCE-LEVEL THELEVEL THEMODULE)))

(CL:DEFMACRO SET-INFERENCE-LEVEL (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Set the inference level of `module' to the level specified
by 'levelKeyword'.  If `module' is NULL, set the level globally."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-INFERENCE-LEVEL|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-INFERENCE-LEVEL)))

;;; (DEFUN (CALL-SET-INFERENCE-LEVEL KEYWORD) ...)

(CL:DEFUN CALL-SET-INFERENCE-LEVEL (LEVELKEYWORD MODULE)
  "Set the inference level of `module' to the level specified
by 'levelKeyword'.  If `module' is NULL and we are inside a query, set the
level of the current query iterator.  Otherwise, set the level globally."
  (CL:LET* ((LEVEL (GET-INFERENCE-LEVEL LEVELKEYWORD)))
   (CL:COND
    ((CL:NOT (CL:EQ MODULE NULL))
     (SET-DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS MODULE)
      SYM-QUERY-LOGIC-INFERENCE-LEVEL LEVEL NULL))
    ((CL:NOT (CL:EQ *QUERYITERATOR* NULL))
     (CL:SETF (%QUERY-ITERATOR.INFERENCE-LEVEL *QUERYITERATOR*) LEVEL))
    (CL:T (CL:SETQ *INFERENCELEVEL* LEVEL)))
   (%INFERENCE-LEVEL.KEYWORD LEVEL)))

;;; (DEFSPECIAL *DONTUSEDEFAULTKNOWLEDGE?* ...)

(CL:DEFVAR *DONTUSEDEFAULTKNOWLEDGE?* CL:NIL
  "Controls whether queries use default knowledge or not.")

;;; (DEFUN (USING-DEFAULT-KNOWLEDGE? BOOLEAN) ...)

(CL:DEFUN USING-DEFAULT-KNOWLEDGE? ()
  (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*))

;;; (DEFGLOBAL *MAXIMUM-BACKTRACKING-DEPTH* ...)

(CL:DEFVAR *MAXIMUM-BACKTRACKING-DEPTH* NULL-INTEGER
  "Value for the maximum depth allowable during
backtrack search.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *MAXIMUM-BACKTRACKING-DEPTH*))

;;; (DEFSPECIAL *TYPE-CHECK-STRATEGY* ...)

(CL:DEFVAR *TYPE-CHECK-STRATEGY* NULL
  "Determines whether there is a slow but thorough type test
when variables are bound, a fast but very shallow one, or none.  Values
are :NONE, :LOOKUP, :DISJOINT.  The default is :LOOKUP.")

;;; (DEFGLOBAL *DUPLICATE-SUBGOAL-STRATEGY* ...)

(CL:DEFVAR *DUPLICATE-SUBGOAL-STRATEGY* NULL
  "Determines what kind of duplicate subgoal test to use.  Choices
are :DUPLICATE-RULES, :DUPLICATE-GOALS, and :DUPLICATE-GOALS-WITH-CACHING.")

;;; (DEFGLOBAL *DUPLICATE-GOAL-SEARCH-DEPTH* ...)

(CL:DEFVAR *DUPLICATE-GOAL-SEARCH-DEPTH* NULL-INTEGER
  "Sets the maximum number of frames search looking for
a duplicate subgoal.  Default value is infinite.  Possibly this should
be replaced by a function that increases with depth of search.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *DUPLICATE-GOAL-SEARCH-DEPTH*))

;;; (DEFGLOBAL *DUPLICATE-RULE-SEARCH-DEPTH* ...)

(CL:DEFVAR *DUPLICATE-RULE-SEARCH-DEPTH* NULL-INTEGER
  "Set limit on number of frames searched looking for
a duplicate rule.  Default value is infinite.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *DUPLICATE-RULE-SEARCH-DEPTH*))

;;; (DEFGLOBAL *GLOBALLY-CLOSED-COLLECTIONS?* ...)

(CL:DEFVAR *GLOBALLY-CLOSED-COLLECTIONS?* CL:NIL
  "If TRUE, all collections are assumed to be closed.")

;;; (DEFSPECIAL *GENERATE-ALL-PROOFS?* ...)

(CL:DEFVAR *GENERATE-ALL-PROOFS?* CL:NIL
  "If TRUE, the backchainer follows all lines of proof
for each goal, rather than switching to a new goal once the first proof
of a goal is achieved.  The partial matcher sets this variable to
TRUE to force generation of proofs having possibly different
weights.")

;;; (DEFUN TRACE-SUBGOALS ...)

(CL:DEFUN TRACE-SUBGOALS ()
  (%SET-FEATURE (CONS-LIST KWD-QUERY-TRACE-SUBGOALS)))

;;; (DEFUN UNTRACE-SUBGOALS ...)

(CL:DEFUN UNTRACE-SUBGOALS ()
  (%UNSET-FEATURE (CONS-LIST KWD-QUERY-TRACE-SUBGOALS)))

;;; (DEFUN TRACE-RULES ...)

(CL:DEFUN TRACE-RULES ()
  (%ADD-TRACE (CONS-LIST KWD-QUERY-PROPAGATE)))

;;; (DEFUN UNTRACE-RULES ...)

(CL:DEFUN UNTRACE-RULES ()
  (%DROP-TRACE (CONS-LIST KWD-QUERY-PROPAGATE)))

;;; (DEFUN (TOGGLE-TRACE-SUBGOALS STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION () CL:SIMPLE-STRING) TOGGLE-TRACE-SUBGOALS))
(CL:DEFUN TOGGLE-TRACE-SUBGOALS ()
  (CL:IF
   (MEMBER? *CURRENT-POWERLOOM-FEATURES* KWD-QUERY-TRACE-SUBGOALS)
   (CL:PROGN (%UNSET-FEATURE (CONS-LIST KWD-QUERY-TRACE-SUBGOALS))
    (%DROP-TRACE (CONS-LIST KWD-QUERY-STRATEGIES))
    "Subgoal tracing disabled.")
   (CL:PROGN (%SET-FEATURE (CONS-LIST KWD-QUERY-TRACE-SUBGOALS))
    (%ADD-TRACE (CONS-LIST KWD-QUERY-STRATEGIES))
    "Subgoal tracing enabled.")))

;;; (DEFUN (TOGGLE-TRACE-RULES STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION () CL:SIMPLE-STRING) TOGGLE-TRACE-RULES))
(CL:DEFUN TOGGLE-TRACE-RULES ()
  (CL:IF
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-PROPAGATE))
   (CL:PROGN (%DROP-TRACE (CONS-LIST KWD-QUERY-PROPAGATE))
    "Rule tracing disabled.")
   (CL:PROGN (%ADD-TRACE (CONS-LIST KWD-QUERY-PROPAGATE))
    "Rule tracing enabled.")))

(CL:DEFUN NEW-QUERY-ITERATOR ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-QUERY-ITERATOR))
   (CL:SETF (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%QUERY-ITERATOR.FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%QUERY-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%QUERY-ITERATOR.TIMEOUT? SELF) CL:NIL)
   (CL:SETF (%QUERY-ITERATOR.CURRENT-CLOCK-TICKS SELF) 0)
   (CL:SETF (%QUERY-ITERATOR.ALLOTTED-CLOCK-TICKS SELF) NULL-INTEGER)
   (CL:SETF (%QUERY-ITERATOR.ALLOTTED-TIME SELF) NULL-FLOAT)
   (CL:SETF (%QUERY-ITERATOR.MAXIMUM-DEPTH SELF) NULL-INTEGER)
   (CL:SETF (%QUERY-ITERATOR.CURRENT-DEPTH-CUTOFF SELF) NULL-INTEGER)
   (CL:SETF (%QUERY-ITERATOR.INFERENCE-LEVEL SELF) NULL)
   (CL:SETF (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY SELF) NULL)
   (CL:SETF (%QUERY-ITERATOR.TIMESTAMP SELF) NULL-INTEGER)
   (CL:SETF (%QUERY-ITERATOR.FOUND-AT-LEAST-ONE-SOLUTION? SELF) CL:NIL)
   (CL:SETF (%QUERY-ITERATOR.FAILED-TO-FIND-DUPLICATE-SUBGOAL? SELF)
    CL:NIL)
   (CL:SETF (%QUERY-ITERATOR.TRIGGERED-DEPTH-CUTOFF? SELF) CL:NIL)
   (CL:SETF (%QUERY-ITERATOR.ACTIVE-GOAL-CACHES SELF) (NEW-LIST))
   (CL:SETF (%QUERY-ITERATOR.AUGMENTED-GOAL-CACHE? SELF) CL:NIL)
   (CL:SETF (%QUERY-ITERATOR.CONTROL-FRAME-PRIORITY-QUEUE SELF) NULL)
   (CL:SETF (%QUERY-ITERATOR.CURRENT-PARALLEL-THREAD SELF) NULL)
   (CL:SETF (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD SELF) NULL)
   (CL:SETF (%QUERY-ITERATOR.CURRENT-CONTROL-FRAME SELF) NULL)
   (CL:SETF (%QUERY-ITERATOR.BASE-CONTROL-FRAME SELF) NULL)
   (CL:SETF (%QUERY-ITERATOR.QUERY-CONTEXT SELF) NULL)
   (CL:SETF (%QUERY-ITERATOR.SOLUTIONS SELF)
    (NEW-QUERY-SOLUTION-TABLE))
   (CL:SETF (%QUERY-ITERATOR.OPTIONS SELF) (NEW-PROPERTY-LIST))
   (CL:SETF (%QUERY-ITERATOR.EXHAUSTED? SELF) CL:NIL)
   (CL:SETF (%QUERY-ITERATOR.EXTERNAL-VARIABLES SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF QUERY-ITERATOR))
  SGT-QUERY-LOGIC-QUERY-ITERATOR)

(CL:DEFMETHOD RESIDUE-GOALS ((SELF QUERY-ITERATOR))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
      SYM-QUERY-LOGIC-RESIDUE-GOALS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

(CL:DEFMETHOD BEST-GOAL-SEQUENCE ((SELF QUERY-ITERATOR))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
      SYM-QUERY-LOGIC-BEST-GOAL-SEQUENCE NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

(CL:DEFMETHOD BAD? ((SELF QUERY-ITERATOR))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
      SYM-QUERY-STELLA-BAD? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:IF CL:NIL TRUE-WRAPPER FALSE-WRAPPER)
    ANSWER)))

(CL:DEFUN ACCESS-QUERY-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-EXTERNAL-VARIABLES)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.EXTERNAL-VARIABLES SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-ITERATOR.EXTERNAL-VARIABLES SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-EXHAUSTED?)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.EXHAUSTED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%QUERY-ITERATOR.EXHAUSTED? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-STELLA-OPTIONS)
    (CL:IF SETVALUE? (CL:SETF (%QUERY-ITERATOR.OPTIONS SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-ITERATOR.OPTIONS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-SOLUTIONS)
    (CL:IF SETVALUE? (CL:SETF (%QUERY-ITERATOR.SOLUTIONS SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-ITERATOR.SOLUTIONS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-QUERY-CONTEXT)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.QUERY-CONTEXT SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-ITERATOR.QUERY-CONTEXT SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-BASE-CONTROL-FRAME)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.BASE-CONTROL-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-ITERATOR.BASE-CONTROL-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CURRENT-CONTROL-FRAME)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.CURRENT-CONTROL-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-ITERATOR.CURRENT-CONTROL-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CURRENT-PATTERN-RECORD)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CURRENT-PARALLEL-THREAD)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.CURRENT-PARALLEL-THREAD SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-ITERATOR.CURRENT-PARALLEL-THREAD SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CONTROL-FRAME-PRIORITY-QUEUE)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.CONTROL-FRAME-PRIORITY-QUEUE SELF)
      VALUE)
     (CL:SETQ VALUE
      (%QUERY-ITERATOR.CONTROL-FRAME-PRIORITY-QUEUE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-AUGMENTED-GOAL-CACHE?)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.AUGMENTED-GOAL-CACHE? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%QUERY-ITERATOR.AUGMENTED-GOAL-CACHE? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ACTIVE-GOAL-CACHES)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.ACTIVE-GOAL-CACHES SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-ITERATOR.ACTIVE-GOAL-CACHES SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TRIGGERED-DEPTH-CUTOFF?)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.TRIGGERED-DEPTH-CUTOFF? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%QUERY-ITERATOR.TRIGGERED-DEPTH-CUTOFF? SELF)
       TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-FAILED-TO-FIND-DUPLICATE-SUBGOAL?)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.FAILED-TO-FIND-DUPLICATE-SUBGOAL? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%QUERY-ITERATOR.FAILED-TO-FIND-DUPLICATE-SUBGOAL? SELF)
       TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-FOUND-AT-LEAST-ONE-SOLUTION?)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.FOUND-AT-LEAST-ONE-SOLUTION? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%QUERY-ITERATOR.FOUND-AT-LEAST-ONE-SOLUTION? SELF)
       TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TIMESTAMP)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.TIMESTAMP SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%QUERY-ITERATOR.TIMESTAMP SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-PARTIAL-MATCH-STRATEGY)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-RESIDUE-GOALS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
      SYM-QUERY-LOGIC-RESIDUE-GOALS VALUE NULL)
     (CL:SETQ VALUE (RESIDUE-GOALS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-BEST-GOAL-SEQUENCE)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
      SYM-QUERY-LOGIC-BEST-GOAL-SEQUENCE VALUE NULL)
     (CL:SETQ VALUE (BEST-GOAL-SEQUENCE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-INFERENCE-LEVEL)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.INFERENCE-LEVEL SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-ITERATOR.INFERENCE-LEVEL SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CURRENT-DEPTH-CUTOFF)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.CURRENT-DEPTH-CUTOFF SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%QUERY-ITERATOR.CURRENT-DEPTH-CUTOFF SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-MAXIMUM-DEPTH)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.MAXIMUM-DEPTH SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%QUERY-ITERATOR.MAXIMUM-DEPTH SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ALLOTTED-TIME)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.ALLOTTED-TIME SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FLOAT (%QUERY-ITERATOR.ALLOTTED-TIME SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ALLOTTED-CLOCK-TICKS)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.ALLOTTED-CLOCK-TICKS SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%QUERY-ITERATOR.ALLOTTED-CLOCK-TICKS SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CURRENT-CLOCK-TICKS)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.CURRENT-CLOCK-TICKS SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%QUERY-ITERATOR.CURRENT-CLOCK-TICKS SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TIMEOUT?)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-ITERATOR.TIMEOUT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%QUERY-ITERATOR.TIMEOUT? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   (CL:T
    (CL:COND
     ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-NEGATED-QUERY)
      (CL:SETQ SLOTNAME SYM-QUERY-LOGIC-AUXILIARY-QUERY))
     ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-LATEST-PARTIAL-SCORE)
      (CL:SETQ SLOTNAME SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE))
     (CL:T))
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
      SLOTNAME VALUE NULL)
     (CL:SETQ VALUE
      (LOOKUP (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

(CL:DEFMETHOD DELETED? ((SELF QUERY-ITERATOR))
  (CL:LET*
   ((DELETED?
     (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
      SYM-QUERY-STELLA-DELETED-OBJECT? NULL)))
   (CL:IF (CL:NOT (CL:EQ DELETED? NULL))
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN DELETED?) CL:NIL)))

(CL:DEFMETHOD DELETED?-SETTER ((SELF QUERY-ITERATOR) VALUE)
  (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
   SYM-QUERY-STELLA-DELETED-OBJECT?
   (CL:IF VALUE TRUE-WRAPPER FALSE-WRAPPER) NULL)
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF QUERY-ITERATOR) STREAM)
  (PRINT-QUERY-ITERATOR SELF STREAM))

(CL:DEFUN NEW-CONTROL-FRAME ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-CONTROL-FRAME))
   (CL:SETF (%CONTROL-FRAME.DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%CONTROL-FRAME.DONT-CACHE-GOAL-FAILURE? SELF) CL:NIL)
   (CL:SETF (%CONTROL-FRAME.CACHED-GOAL-RESULT? SELF) CL:NIL)
   (CL:SETF (%CONTROL-FRAME.GOAL-BINDINGS SELF) NULL)
   (CL:SETF (%CONTROL-FRAME.JUSTIFICATIONS SELF) (NEW-LIST))
   (CL:SETF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF) NULL)
   (CL:SETF (%CONTROL-FRAME.NEXT-STRATEGIES SELF) NIL)
   (CL:SETF (%CONTROL-FRAME.CURRENT-STRATEGY SELF) NULL)
   (CL:SETF (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET SELF)
    NULL-INTEGER)
   (CL:SETF (%CONTROL-FRAME.INHERITED-PATTERN-RECORD SELF) NULL)
   (CL:SETF (%CONTROL-FRAME.PATTERN-RECORD SELF) NULL)
   (CL:SETF (%CONTROL-FRAME.ARGUMENT-CURSOR SELF) 0)
   (CL:SETF (%CONTROL-FRAME.RESULT SELF) NULL)
   (CL:SETF (%CONTROL-FRAME.DOWN SELF) NULL)
   (CL:SETF (%CONTROL-FRAME.UP SELF) NULL)
   (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS SELF) NULL-INTEGER)
   (CL:SETF (%CONTROL-FRAME.STARTING-CLOCK-TICKS SELF) NULL-INTEGER)
   (CL:SETF (%CONTROL-FRAME.REVERSE-POLARITY? SELF) CL:NIL)
   (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE SELF) NULL)
   (CL:SETF (%CONTROL-FRAME.PROPOSITION SELF) NULL)
   (CL:SETF (%CONTROL-FRAME.STATE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CONTROL-FRAME))
  SGT-QUERY-LOGIC-CONTROL-FRAME)

(CL:DEFMETHOD HOLDS-BY-DEFAULT? ((SELF CONTROL-FRAME))
  (CL:OR
   (CL:EQ (%CONTROL-FRAME.TRUTH-VALUE SELF) DEFAULT-TRUE-TRUTH-VALUE)
   (CL:EQ (%CONTROL-FRAME.TRUTH-VALUE SELF) DEFAULT-FALSE-TRUTH-VALUE)))

(CL:DEFMETHOD BAD? ((SELF CONTROL-FRAME))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS SELF)
      SYM-QUERY-STELLA-BAD? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:IF CL:NIL TRUE-WRAPPER FALSE-WRAPPER)
    ANSWER)))

(CL:DEFUN ACCESS-CONTROL-FRAME-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-STELLA-STATE)
    (CL:IF SETVALUE? (CL:SETF (%CONTROL-FRAME.STATE SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME.STATE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%CONTROL-FRAME.PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME.PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TRUTH-VALUE)
    (CL:IF SETVALUE? (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME.TRUTH-VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-REVERSE-POLARITY?)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME.REVERSE-POLARITY? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CONTROL-FRAME.REVERSE-POLARITY? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-STARTING-CLOCK-TICKS)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME.STARTING-CLOCK-TICKS SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%CONTROL-FRAME.STARTING-CLOCK-TICKS SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ALLOTTED-CLOCK-TICKS)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-UP)
    (CL:IF SETVALUE? (CL:SETF (%CONTROL-FRAME.UP SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME.UP SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-DOWN)
    (CL:IF SETVALUE? (CL:SETF (%CONTROL-FRAME.DOWN SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME.DOWN SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-STELLA-RESULT)
    (CL:IF SETVALUE? (CL:SETF (%CONTROL-FRAME.RESULT SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME.RESULT SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ARGUMENT-CURSOR)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME.ARGUMENT-CURSOR SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%CONTROL-FRAME.ARGUMENT-CURSOR SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-PATTERN-RECORD)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME.PATTERN-RECORD SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME.PATTERN-RECORD SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-INHERITED-PATTERN-RECORD)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME.INHERITED-PATTERN-RECORD SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME.INHERITED-PATTERN-RECORD SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CHOICE-POINT-UNBINDING-OFFSET)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER
       (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CURRENT-STRATEGY)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME.CURRENT-STRATEGY SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME.CURRENT-STRATEGY SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-NEXT-STRATEGIES)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME.NEXT-STRATEGIES SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME.NEXT-STRATEGIES SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-PARTIAL-MATCH-FRAME)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-JUSTIFICATIONS)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME.JUSTIFICATIONS SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME.JUSTIFICATIONS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-GOAL-BINDINGS)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME.GOAL-BINDINGS SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME.GOAL-BINDINGS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CACHED-GOAL-RESULT?)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME.CACHED-GOAL-RESULT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CONTROL-FRAME.CACHED-GOAL-RESULT? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-DONT-CACHE-GOAL-FAILURE?)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME.DONT-CACHE-GOAL-FAILURE? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CONTROL-FRAME.DONT-CACHE-GOAL-FAILURE? SELF)
       TRUE-WRAPPER FALSE-WRAPPER))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS SELF)
      SLOTNAME VALUE NULL)
     (CL:SETQ VALUE
      (LOOKUP (%CONTROL-FRAME.DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

(CL:DEFMETHOD DELETED? ((SELF CONTROL-FRAME))
  (CL:LET*
   ((DELETED?
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS SELF)
      SYM-QUERY-STELLA-DELETED-OBJECT? NULL)))
   (CL:IF (CL:NOT (CL:EQ DELETED? NULL))
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN DELETED?) CL:NIL)))

(CL:DEFMETHOD DELETED?-SETTER ((SELF CONTROL-FRAME) VALUE)
  (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS SELF)
   SYM-QUERY-STELLA-DELETED-OBJECT?
   (CL:IF VALUE TRUE-WRAPPER FALSE-WRAPPER) NULL)
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF CONTROL-FRAME) STREAM)
  (PRINT-CONTROL-FRAME SELF STREAM))

(CL:DEFUN NEW-PARALLEL-THREAD ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-PARALLEL-THREAD))
   (CL:SETF (%PARALLEL-THREAD.STATUS SELF) NULL)
   (CL:SETF (%PARALLEL-THREAD.PRIORITY SELF) NULL-INTEGER)
   (CL:SETF (%PARALLEL-THREAD.TOP-UNBINDING-STACK-OFFSET SELF)
    NULL-INTEGER)
   (CL:SETF (%PARALLEL-THREAD.UNBINDING-STACK SELF) NULL)
   (CL:SETF (%PARALLEL-THREAD.VARIABLE-BINDINGS SELF) NULL)
   (CL:SETF (%PARALLEL-THREAD.HYPOTHETICAL-WORLD SELF) NULL)
   (CL:SETF (%PARALLEL-THREAD.TOP-CONTROL-FRAME SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PARALLEL-THREAD))
  SGT-QUERY-LOGIC-PARALLEL-THREAD)

(CL:DEFUN ACCESS-PARALLEL-THREAD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TOP-CONTROL-FRAME)
    (CL:IF SETVALUE?
     (CL:SETF (%PARALLEL-THREAD.TOP-CONTROL-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%PARALLEL-THREAD.TOP-CONTROL-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-HYPOTHETICAL-WORLD)
    (CL:IF SETVALUE?
     (CL:SETF (%PARALLEL-THREAD.HYPOTHETICAL-WORLD SELF) VALUE)
     (CL:SETQ VALUE (%PARALLEL-THREAD.HYPOTHETICAL-WORLD SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-VARIABLE-BINDINGS)
    (CL:IF SETVALUE?
     (CL:SETF (%PARALLEL-THREAD.VARIABLE-BINDINGS SELF) VALUE)
     (CL:SETQ VALUE (%PARALLEL-THREAD.VARIABLE-BINDINGS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-UNBINDING-STACK)
    (CL:IF SETVALUE?
     (CL:SETF (%PARALLEL-THREAD.UNBINDING-STACK SELF) VALUE)
     (CL:SETQ VALUE (%PARALLEL-THREAD.UNBINDING-STACK SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TOP-UNBINDING-STACK-OFFSET)
    (CL:IF SETVALUE?
     (CL:SETF (%PARALLEL-THREAD.TOP-UNBINDING-STACK-OFFSET SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER
       (%PARALLEL-THREAD.TOP-UNBINDING-STACK-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-PRIORITY)
    (CL:IF SETVALUE?
     (CL:SETF (%PARALLEL-THREAD.PRIORITY SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%PARALLEL-THREAD.PRIORITY SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-STATUS)
    (CL:IF SETVALUE? (CL:SETF (%PARALLEL-THREAD.STATUS SELF) VALUE)
     (CL:SETQ VALUE (%PARALLEL-THREAD.STATUS SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFUN NEW-PARALLEL-CONTROL-FRAME ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-PARALLEL-CONTROL-FRAME))
   (CL:SETF (%PARALLEL-CONTROL-FRAME.DYNAMIC-SLOTS SELF)
    (NEW-KEY-VALUE-LIST))
   (CL:SETF (%PARALLEL-CONTROL-FRAME.DONT-CACHE-GOAL-FAILURE? SELF)
    CL:NIL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.CACHED-GOAL-RESULT? SELF) CL:NIL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.GOAL-BINDINGS SELF) NULL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.JUSTIFICATIONS SELF) (NEW-LIST))
   (CL:SETF (%PARALLEL-CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF) NULL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.NEXT-STRATEGIES SELF) NIL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.CURRENT-STRATEGY SELF) NULL)
   (CL:SETF
    (%PARALLEL-CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET SELF)
    NULL-INTEGER)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.INHERITED-PATTERN-RECORD SELF)
    NULL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.PATTERN-RECORD SELF) NULL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.ARGUMENT-CURSOR SELF) 0)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.RESULT SELF) NULL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.DOWN SELF) NULL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.UP SELF) NULL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.ALLOTTED-CLOCK-TICKS SELF)
    NULL-INTEGER)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.STARTING-CLOCK-TICKS SELF)
    NULL-INTEGER)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.REVERSE-POLARITY? SELF) CL:NIL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.TRUTH-VALUE SELF) NULL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.PROPOSITION SELF) NULL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.STATE SELF) NULL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.SAVED-PARENT-PARALLEL-THREAD SELF)
    NULL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.SAVED-PARENT-CONTEXT SELF) NULL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.CURRENT-CHILD-THREAD SELF) NULL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.UNBOUND-VARIABLES? SELF) CL:NIL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.CHILD-THREADS SELF) (NEW-LIST))
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PARALLEL-CONTROL-FRAME))
  SGT-QUERY-LOGIC-PARALLEL-CONTROL-FRAME)

(CL:DEFUN ACCESS-PARALLEL-CONTROL-FRAME-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CHILD-THREADS)
    (CL:IF SETVALUE?
     (CL:SETF (%PARALLEL-CONTROL-FRAME.CHILD-THREADS SELF) VALUE)
     (CL:SETQ VALUE (%PARALLEL-CONTROL-FRAME.CHILD-THREADS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-UNBOUND-VARIABLES?)
    (CL:IF SETVALUE?
     (CL:SETF (%PARALLEL-CONTROL-FRAME.UNBOUND-VARIABLES? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%PARALLEL-CONTROL-FRAME.UNBOUND-VARIABLES? SELF)
       TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CURRENT-CHILD-THREAD)
    (CL:IF SETVALUE?
     (CL:SETF (%PARALLEL-CONTROL-FRAME.CURRENT-CHILD-THREAD SELF)
      VALUE)
     (CL:SETQ VALUE
      (%PARALLEL-CONTROL-FRAME.CURRENT-CHILD-THREAD SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-SAVED-PARENT-CONTEXT)
    (CL:IF SETVALUE?
     (CL:SETF (%PARALLEL-CONTROL-FRAME.SAVED-PARENT-CONTEXT SELF)
      VALUE)
     (CL:SETQ VALUE
      (%PARALLEL-CONTROL-FRAME.SAVED-PARENT-CONTEXT SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-SAVED-PARENT-PARALLEL-THREAD)
    (CL:IF SETVALUE?
     (CL:SETF
      (%PARALLEL-CONTROL-FRAME.SAVED-PARENT-PARALLEL-THREAD SELF)
      VALUE)
     (CL:SETQ VALUE
      (%PARALLEL-CONTROL-FRAME.SAVED-PARENT-PARALLEL-THREAD SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE
      (%PARALLEL-CONTROL-FRAME.DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE
      (LOOKUP (%PARALLEL-CONTROL-FRAME.DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

(CL:DEFUN NEW-CONTROL-FRAME-PRIORITY-QUEUE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-CONTROL-FRAME-PRIORITY-QUEUE))
   (CL:SETF (%CONTROL-FRAME-PRIORITY-QUEUE.QUEUE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CONTROL-FRAME-PRIORITY-QUEUE))
  SGT-QUERY-LOGIC-CONTROL-FRAME-PRIORITY-QUEUE)

(CL:DEFUN ACCESS-CONTROL-FRAME-PRIORITY-QUEUE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-QUEUE)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTROL-FRAME-PRIORITY-QUEUE.QUEUE SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME-PRIORITY-QUEUE.QUEUE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFSPECIAL *QUERYITERATOR* ...)

(CL:DEFVAR *QUERYITERATOR* NULL
  "Points to the query iterator for the currently executing query.")

;;; (DEFGLOBAL *DEFAULT-MAXIMUM-DEPTH* ...)

(CL:DEFVAR *DEFAULT-MAXIMUM-DEPTH* 25
  "Possibly a good value for the maximum backtracking depth.
More testing is needed.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *DEFAULT-MAXIMUM-DEPTH*))

;;; (DEFGLOBAL *INITIAL-BACKTRACKING-DEPTH* ...)

(CL:DEFVAR *INITIAL-BACKTRACKING-DEPTH* 5
  "Value of the initial depth used during an interative
deepening search.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *INITIAL-BACKTRACKING-DEPTH*))

;;; (DEFGLOBAL *ITERATIVE-DEEPENING-MODE?* ...)

(CL:DEFVAR *ITERATIVE-DEEPENING-MODE?* CL:NIL
  "Default setting.  If TRUE, queries are evaluated
using iterative deepening from depth '*initial-backtracking-depth*'
to depth '*maximum-backtracking-depth*'.")

;;; (DEFGLOBAL *EMIT-THINKING-DOTS?* ...)

(CL:DEFVAR *EMIT-THINKING-DOTS?* CL:T
  "When TRUE, various kinds of characters are
emitted to STANDARD-OUTPUT while PowerLoom is 'thinking'.")

;;; (DEFGLOBAL *THINKING-DOT-COUNTER* ...)

(CL:DEFVAR *THINKING-DOT-COUNTER* 0
  "Used to determine when to generate linefeeds
after forty-or-so thinking dots.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *THINKING-DOT-COUNTER*))

;;; (DEFGLOBAL *THINKING-DOT-TABLE* ...)

(CL:DEFVAR *THINKING-DOT-TABLE* NULL
  "Maps kind of thinking keywords to characters.")

;;; (DEFUN EMIT-THINKING-DOT ...)

(CL:DEFUN EMIT-THINKING-DOT (KINDOFTHINKING)
  (CL:WHEN *EMIT-THINKING-DOTS?*
   (CL:LET* ((CHARACTER (LOOKUP *THINKING-DOT-TABLE* KINDOFTHINKING)))
    (CL:WHEN (CL:NOT (CL:EQ CHARACTER NULL))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      (%CHARACTER-WRAPPER.WRAPPER-VALUE CHARACTER))
     (CL:SETQ *THINKING-DOT-COUNTER* (CL:1+ *THINKING-DOT-COUNTER*))
     (CL:WHEN (CL:>= *THINKING-DOT-COUNTER* 70)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       EOL)
      (CL:SETQ *THINKING-DOT-COUNTER* 0))))))

(CL:DEFUN NEW-PROOF-ADJUNCT ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-PROOF-ADJUNCT)) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PROOF-ADJUNCT))
  SGT-QUERY-LOGIC-PROOF-ADJUNCT)

(CL:DEFUN NEW-PATTERN-RECORD ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-PATTERN-RECORD))
   (CL:SETF (%PATTERN-RECORD.COLLECTION-LIST SELF) NULL)
   (CL:SETF (%PATTERN-RECORD.OPTIMAL-PATTERN SELF) NULL)
   (CL:SETF (%PATTERN-RECORD.BOOLEAN-VECTOR SELF) NULL)
   (CL:SETF (%PATTERN-RECORD.EXTERNAL-ARGUMENTS SELF) NULL)
   (CL:SETF (%PATTERN-RECORD.DESCRIPTION SELF) NULL)
   (CL:SETF (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET SELF)
    NULL-INTEGER)
   (CL:SETF (%PATTERN-RECORD.UNBINDING-STACK SELF) NULL)
   (CL:SETF (%PATTERN-RECORD.VARIABLE-BINDINGS SELF) NULL)
   (CL:SETF (%PATTERN-RECORD.CONTROL-FRAME SELF) NULL) SELF))

(CL:DEFMETHOD FREE ((SELF PATTERN-RECORD))
  (CL:WHEN (TERMINATE-PATTERN-RECORD? SELF) (UNMAKE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PATTERN-RECORD))
  SGT-QUERY-LOGIC-PATTERN-RECORD)

(CL:DEFUN ACCESS-PATTERN-RECORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CONTROL-FRAME)
    (CL:IF SETVALUE?
     (CL:SETF (%PATTERN-RECORD.CONTROL-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%PATTERN-RECORD.CONTROL-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-VARIABLE-BINDINGS)
    (CL:IF SETVALUE?
     (CL:SETF (%PATTERN-RECORD.VARIABLE-BINDINGS SELF) VALUE)
     (CL:SETQ VALUE (%PATTERN-RECORD.VARIABLE-BINDINGS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-UNBINDING-STACK)
    (CL:IF SETVALUE?
     (CL:SETF (%PATTERN-RECORD.UNBINDING-STACK SELF) VALUE)
     (CL:SETQ VALUE (%PATTERN-RECORD.UNBINDING-STACK SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TOP-UNBINDING-STACK-OFFSET)
    (CL:IF SETVALUE?
     (CL:SETF (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER
       (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-DESCRIPTION)
    (CL:IF SETVALUE? (CL:SETF (%PATTERN-RECORD.DESCRIPTION SELF) VALUE)
     (CL:SETQ VALUE (%PATTERN-RECORD.DESCRIPTION SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-EXTERNAL-ARGUMENTS)
    (CL:IF SETVALUE?
     (CL:SETF (%PATTERN-RECORD.EXTERNAL-ARGUMENTS SELF) VALUE)
     (CL:SETQ VALUE (%PATTERN-RECORD.EXTERNAL-ARGUMENTS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-STELLA-BOOLEAN-VECTOR)
    (CL:IF SETVALUE?
     (CL:SETF (%PATTERN-RECORD.BOOLEAN-VECTOR SELF) VALUE)
     (CL:SETQ VALUE (%PATTERN-RECORD.BOOLEAN-VECTOR SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-OPTIMAL-PATTERN)
    (CL:IF SETVALUE?
     (CL:SETF (%PATTERN-RECORD.OPTIMAL-PATTERN SELF) VALUE)
     (CL:SETQ VALUE (%PATTERN-RECORD.OPTIMAL-PATTERN SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-COLLECTION-LIST)
    (CL:IF SETVALUE?
     (CL:SETF (%PATTERN-RECORD.COLLECTION-LIST SELF) VALUE)
     (CL:SETQ VALUE (%PATTERN-RECORD.COLLECTION-LIST SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFUN NEW-BOOLEAN-VECTOR-INDEX-NODE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-BOOLEAN-VECTOR-INDEX-NODE))
   (CL:SETF (%BOOLEAN-VECTOR-INDEX-NODE.THE-VECTOR SELF) NULL)
   (CL:SETF (%BOOLEAN-VECTOR-INDEX-NODE.FALSE-LINK SELF) NULL)
   (CL:SETF (%BOOLEAN-VECTOR-INDEX-NODE.TRUE-LINK SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF BOOLEAN-VECTOR-INDEX-NODE))
  SGT-QUERY-LOGIC-BOOLEAN-VECTOR-INDEX-NODE)

(CL:DEFUN ACCESS-BOOLEAN-VECTOR-INDEX-NODE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TRUE-LINK)
    (CL:IF SETVALUE?
     (CL:SETF (%BOOLEAN-VECTOR-INDEX-NODE.TRUE-LINK SELF) VALUE)
     (CL:SETQ VALUE (%BOOLEAN-VECTOR-INDEX-NODE.TRUE-LINK SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-FALSE-LINK)
    (CL:IF SETVALUE?
     (CL:SETF (%BOOLEAN-VECTOR-INDEX-NODE.FALSE-LINK SELF) VALUE)
     (CL:SETQ VALUE (%BOOLEAN-VECTOR-INDEX-NODE.FALSE-LINK SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-THE-VECTOR)
    (CL:IF SETVALUE?
     (CL:SETF (%BOOLEAN-VECTOR-INDEX-NODE.THE-VECTOR SELF) VALUE)
     (CL:SETQ VALUE (%BOOLEAN-VECTOR-INDEX-NODE.THE-VECTOR SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFGLOBAL *BOOLEAN-VECTOR-INDEX* ...)

(CL:DEFVAR *BOOLEAN-VECTOR-INDEX* NULL
  "Points to the head of a discrimination tree of containing
all boolean vectors.")

;;; (DEFUN (CREATE-BOOLEAN-VECTOR-INDEX-NODE BOOLEAN-VECTOR-INDEX-NODE) ...)

(CL:DEFUN CREATE-BOOLEAN-VECTOR-INDEX-NODE (PARENTNODE LASTVALUE)
  (CL:LET*
   ((NODE (NEW-BOOLEAN-VECTOR-INDEX-NODE))
    (VECTORLENGTH
     (CL:1+
      (LENGTH (%BOOLEAN-VECTOR-INDEX-NODE.THE-VECTOR PARENTNODE))))
    (VECTOR (NEW-BOOLEAN-VECTOR VECTORLENGTH)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM VECTORLENGTH))
   (CL:SETF (%BOOLEAN-VECTOR-INDEX-NODE.THE-VECTOR NODE) VECTOR)
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:- VECTORLENGTH 2)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY VECTOR))
       (VALUE
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY
           (%BOOLEAN-VECTOR-INDEX-NODE.THE-VECTOR PARENTNODE)))
         I))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET
    ((SELF (%VECTOR.THE-ARRAY VECTOR))
     (VALUE (CL:IF LASTVALUE TRUE-WRAPPER FALSE-WRAPPER))
     (POSITION (CL:1- VECTORLENGTH)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:IF LASTVALUE
    (CL:SETF (%BOOLEAN-VECTOR-INDEX-NODE.TRUE-LINK PARENTNODE) NODE)
    (CL:SETF (%BOOLEAN-VECTOR-INDEX-NODE.FALSE-LINK PARENTNODE) NODE))
   NODE))

;;; (DEFUN (ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR BOOLEAN-VECTOR) ...)

(CL:DEFUN ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR (ARGUMENTSVECTOR)
  (CL:LET*
   ((NODE *BOOLEAN-VECTOR-INDEX*) (NEXTNODE NULL) (BOUND? CL:NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTSVECTOR) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ BOUND? CL:T)
     (CL:COND
      ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARG)
        SGT-QUERY-LOGIC-PATTERN-VARIABLE)
       (CL:PROGN
        (CL:SETQ BOUND?
         (CL:NOT
          (CL:EQ
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY
              (%PATTERN-RECORD.VARIABLE-BINDINGS
               (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD
                *QUERYITERATOR*))))
            (CL:THE CL:FIXNUM (%PATTERN-VARIABLE.BOUND-TO-OFFSET ARG)))
           NULL)))))
      (CL:T))
     (CL:IF BOUND?
      (CL:PROGN
       (CL:SETQ NEXTNODE (%BOOLEAN-VECTOR-INDEX-NODE.TRUE-LINK NODE))
       (CL:WHEN (CL:EQ NEXTNODE NULL)
        (CL:SETQ NEXTNODE
         (CREATE-BOOLEAN-VECTOR-INDEX-NODE NODE CL:T))))
      (CL:PROGN
       (CL:SETQ NEXTNODE (%BOOLEAN-VECTOR-INDEX-NODE.FALSE-LINK NODE))
       (CL:WHEN (CL:EQ NEXTNODE NULL)
        (CL:SETQ NEXTNODE
         (CREATE-BOOLEAN-VECTOR-INDEX-NODE NODE CL:NIL)))))
     (CL:SETQ NODE NEXTNODE) (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (%BOOLEAN-VECTOR-INDEX-NODE.THE-VECTOR NODE)))

;;; (DEFUN (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR BOOLEAN-VECTOR) ...)

(CL:DEFUN ZERO-ONE-LIST-TO-BOOLEAN-VECTOR (ZEROONELIST)
  (CL:LET* ((NODE *BOOLEAN-VECTOR-INDEX*) (NEXTNODE NULL))
   (CL:LET* ((BIT NULL) (ITER-000 (%LIST.THE-CONS-LIST ZEROONELIST)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ BIT (%%VALUE ITER-000))
     (CL:IF (EQL? BIT ONE-WRAPPER)
      (CL:PROGN
       (CL:SETQ NEXTNODE (%BOOLEAN-VECTOR-INDEX-NODE.TRUE-LINK NODE))
       (CL:WHEN (CL:EQ NEXTNODE NULL)
        (CL:SETQ NEXTNODE
         (CREATE-BOOLEAN-VECTOR-INDEX-NODE NODE CL:T))))
      (CL:PROGN
       (CL:SETQ NEXTNODE (%BOOLEAN-VECTOR-INDEX-NODE.FALSE-LINK NODE))
       (CL:WHEN (CL:EQ NEXTNODE NULL)
        (CL:SETQ NEXTNODE
         (CREATE-BOOLEAN-VECTOR-INDEX-NODE NODE CL:NIL)))))
     (CL:SETQ NODE NEXTNODE) (CL:SETQ ITER-000 (%%REST ITER-000))))
   (%BOOLEAN-VECTOR-INDEX-NODE.THE-VECTOR NODE)))

;;; (DEFUN POP-CONTROL-FRAME ...)

(CL:DEFUN POP-CONTROL-FRAME (FRAME)
  (CL:WHEN
   (CL:OR (CL:EQ (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-PATTERN)
    (CL:EQ (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-CONTAINED-BY))
   (RESET-CURRENT-PATTERN-RECORD FRAME KWD-QUERY-PARENT))
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-QUERY-LOGIC-CACHED-BINDINGS-ITERATOR NULL)
     NULL))
   (FREE
    (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
     SYM-QUERY-LOGIC-CACHED-BINDINGS-ITERATOR NULL))
   (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
    SYM-QUERY-LOGIC-CACHED-BINDINGS-ITERATOR NULL NULL))
  (CL:SETF (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET FRAME)
   NULL-INTEGER)
  (FREE FRAME)
  (CL:SETF (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-POPPED))

;;; (DEFUN POP-FRAMES-UP-TO ...)

(CL:DEFUN POP-FRAMES-UP-TO (FRAME)
  (CL:WHEN (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
   (POP-FRAMES-UP-TO (%CONTROL-FRAME.DOWN FRAME)))
  (CL:WHEN (CL:NOT (CL:EQ (%CONTROL-FRAME.UP FRAME) NULL))
   (CL:SETF (%CONTROL-FRAME.DOWN (%CONTROL-FRAME.UP FRAME)) NULL))
  (POP-CONTROL-FRAME FRAME))

;;; (DEFUN POP-DOWN-FRAME ...)

(CL:DEFUN POP-DOWN-FRAME (FRAME)
  (POP-CONTROL-FRAME (%CONTROL-FRAME.DOWN FRAME))
  (CL:SETF (%CONTROL-FRAME.DOWN FRAME) NULL))

;;; (DEFUN ACTIVATE-PATTERN-RECORD ...)

(CL:DEFUN ACTIVATE-PATTERN-RECORD (PATTERNRECORD VARIABLECOUNT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM VARIABLECOUNT))
  #+MCL
  (CL:CHECK-TYPE VARIABLECOUNT CL:FIXNUM)
  (CL:LET*
   ((VECTOR (%PATTERN-RECORD.VARIABLE-BINDINGS PATTERNRECORD))
    (STACK (%PATTERN-RECORD.UNBINDING-STACK PATTERNRECORD)))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ VECTOR NULL))
     (CL:>= (%VECTOR.ARRAY-SIZE VECTOR) VARIABLECOUNT))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-000 0)
      (UPPER-BOUND-000 (CL:1- VARIABLECOUNT)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
     (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
      (CL:SETQ I ITER-000)
      (CL:LET
       ((SELF (%VECTOR.THE-ARRAY VECTOR)) (VALUE NULL) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:LET
       ((SELF (%VECTOR.THE-ARRAY STACK)) (VALUE NULL) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ ITER-000 (CL:1+ ITER-000))))
    (CL:PROGN
     (CL:SETF (%PATTERN-RECORD.VARIABLE-BINDINGS PATTERNRECORD)
      (NEW-VECTOR VARIABLECOUNT))
     (CL:SETF (%PATTERN-RECORD.UNBINDING-STACK PATTERNRECORD)
      (NEW-INTEGER-VECTOR VARIABLECOUNT))))
   (CL:SETF (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD)
    -1)
   (CL:SETF (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*)
    PATTERNRECORD)))

;;; (DEFUN RESET-CURRENT-PATTERN-RECORD ...)

(CL:DEFUN RESET-CURRENT-PATTERN-RECORD (FRAME LOCALORPARENT)
  (CL:COND
   ((CL:EQ LOCALORPARENT KWD-QUERY-LOCAL)
    (CL:SETF (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*)
     (%CONTROL-FRAME.PATTERN-RECORD FRAME)))
   ((CL:EQ LOCALORPARENT KWD-QUERY-PARENT)
    (CL:IF
     (CL:NOT
      (CL:EQ (%CONTROL-FRAME.INHERITED-PATTERN-RECORD FRAME) NULL))
     (CL:SETF (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*)
      (%CONTROL-FRAME.INHERITED-PATTERN-RECORD FRAME))
     (CL:SETF (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*)
      (%CONTROL-FRAME.PATTERN-RECORD
       (%QUERY-ITERATOR.BASE-CONTROL-FRAME *QUERYITERATOR*)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" LOCALORPARENT "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN PRINT-ENVIRONMENT-STACKS ...)

(CL:DEFUN PRINT-ENVIRONMENT-STACKS ()
  (CL:LET*
   ((FRAME (%QUERY-ITERATOR.CURRENT-CONTROL-FRAME *QUERYITERATOR*))
    (CURRENTPATTERNRECORD
     (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*)))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "-------------------------" EOL)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "current-control-frame " FRAME EOL)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "    ")
   (CL:LET*
    ((ARG NULL)
     (VECTOR-000
      (%PATTERN-RECORD.VARIABLE-BINDINGS CURRENTPATTERNRECORD))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:IF (CL:NOT (CL:EQ ARG NULL))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       ARG " ")
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "_ "))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "    " (%PATTERN-RECORD.UNBINDING-STACK CURRENTPATTERNRECORD) EOL)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "-------------------------" EOL)))

;;; (DEFUN SET-PATTERN-VARIABLE-BINDING ...)

(CL:DEFUN SET-PATTERN-VARIABLE-BINDING (VARIABLE VALUE)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "set-pattern-variable-binding: " VARIABLE " " VALUE "  F"
    (DEBUG-FRAME-ID
     (%PATTERN-RECORD.CONTROL-FRAME
      (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*)))
    EOL))
  (CL:LET*
   ((PATTERNRECORD
     (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))
    (VBOFFSET (%PATTERN-VARIABLE.BOUND-TO-OFFSET VARIABLE))
    (UBSTACKOFFSET
     (CL:1+
      (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM VBOFFSET UBSTACKOFFSET))
   (CL:LET
    ((SELF
      (%VECTOR.THE-ARRAY
       (%PATTERN-RECORD.VARIABLE-BINDINGS PATTERNRECORD)))
     (VALUE VALUE) (POSITION VBOFFSET))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD)
    UBSTACKOFFSET)
   (CL:LET
    ((SELF
      (%VECTOR.THE-ARRAY
       (%PATTERN-RECORD.UNBINDING-STACK PATTERNRECORD)))
     (VALUE (WRAP-INTEGER VBOFFSET)) (POSITION UBSTACKOFFSET))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFUN CHANGE-PATTERN-VARIABLE-BINDING ...)

(CL:DEFUN CHANGE-PATTERN-VARIABLE-BINDING (VARIABLE NEWVALUE)
  (CL:LET*
   ((PATTERNRECORD
     (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))
    (VBOFFSET (%PATTERN-VARIABLE.BOUND-TO-OFFSET VARIABLE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM VBOFFSET))
   (CL:LET
    ((SELF
      (%VECTOR.THE-ARRAY
       (%PATTERN-RECORD.VARIABLE-BINDINGS PATTERNRECORD)))
     (VALUE NEWVALUE) (POSITION VBOFFSET))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFUN UNBIND-VARIABLES-BEGINNING-AT ...)

(CL:DEFUN UNBIND-VARIABLES-BEGINNING-AT (PATTERNRECORD UBSTACKOFFSET)
  (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
  #+MCL
  (CL:CHECK-TYPE UBSTACKOFFSET CL:FIXNUM)
  (CL:LET*
   ((VARIABLEBINDINGSVECTOR
     (%PATTERN-RECORD.VARIABLE-BINDINGS PATTERNRECORD))
    (UNBINDINGSTACK (%PATTERN-RECORD.UNBINDING-STACK PATTERNRECORD)))
   (CL:WHEN
    (CL:< (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD)
     UBSTACKOFFSET)
    (CL:RETURN-FROM UNBIND-VARIABLES-BEGINNING-AT))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "unbind-variables-beginning-at: UBS= " UBSTACKOFFSET "  F"
     (DEBUG-FRAME-ID (%PATTERN-RECORD.CONTROL-FRAME PATTERNRECORD))
     "  #bindings= "
     (CL:1+
      (CL:- (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD)
       UBSTACKOFFSET))
     EOL))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 UBSTACKOFFSET)
     (UPPER-BOUND-000
      (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY VARIABLEBINDINGSVECTOR)) (VALUE NULL)
       (POSITION
        (%INTEGER-WRAPPER.WRAPPER-VALUE
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY UNBINDINGSTACK))
          I))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY UNBINDINGSTACK)) (VALUE NULL)
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETF (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD)
    (CL:1- UBSTACKOFFSET))))

;;; (DEFUN CREATE-CHOICE-POINT ...)

(CL:DEFUN CREATE-CHOICE-POINT (FRAME)
  (CL:LET*
   ((PATTERNRECORD (%CONTROL-FRAME.INHERITED-PATTERN-RECORD FRAME)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "create-choice-point: F " (DEBUG-FRAME-ID FRAME) " CP= "
     (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET FRAME) " NEWCP= "
     (CL:1+ (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))
     EOL))
   (CL:IF (NULL? (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET FRAME))
    (CL:SETF (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET FRAME)
     (CL:1+
      (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD)))
    (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD
     (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET FRAME)))))

;;; (DEFUN UNWIND-TO-CHOICE-POINT ...)

(CL:DEFUN UNWIND-TO-CHOICE-POINT (FRAME)
  (CL:LET*
   ((CHOICEPOINT (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET FRAME)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CHOICEPOINT))
   (CL:WHEN (DEFINED? CHOICEPOINT)
    (UNBIND-VARIABLES-BEGINNING-AT
     (%CONTROL-FRAME.INHERITED-PATTERN-RECORD FRAME) CHOICEPOINT))))

;;; (DEFUN (NEW-BINDINGS-SINCE-LAST-CHOICE-POINT? BOOLEAN) ...)

(CL:DEFUN NEW-BINDINGS-SINCE-LAST-CHOICE-POINT? (FRAME)
  (<= (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET FRAME)
   (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET
    (%CONTROL-FRAME.INHERITED-PATTERN-RECORD FRAME))))

;;; (DEFUN (BOUND-TO OBJECT) ...)

(CL:DEFUN BOUND-TO (SELF)
  (CL:AREF
   (CL:THE CL:SIMPLE-VECTOR
    (%VECTOR.THE-ARRAY
     (%PATTERN-RECORD.VARIABLE-BINDINGS
      (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
   (CL:THE CL:FIXNUM (%PATTERN-VARIABLE.BOUND-TO-OFFSET SELF))))

;;; (DEFUN (SAFE-BOUND-TO OBJECT) ...)

(CL:DEFUN SAFE-BOUND-TO (SELF)
  (CL:WHEN (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
   (CL:LET*
    ((BINDINGS
      (%PATTERN-RECORD.VARIABLE-BINDINGS
       (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*)))
     (OFFSET (%PATTERN-VARIABLE.BOUND-TO-OFFSET SELF)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ BINDINGS NULL)) (DEFINED? OFFSET)
      (CL:< OFFSET (LENGTH BINDINGS)))
     (CL:RETURN-FROM SAFE-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY BINDINGS))
       OFFSET)))))
  NULL)

;;; (DEFUN (BOUND-TO-IN-FRAME OBJECT) ...)

(CL:DEFUN BOUND-TO-IN-FRAME (SELF FRAME)
  (CL:LET*
   ((BINDINGS
     (%PATTERN-RECORD.VARIABLE-BINDINGS
      (OPERATIVE-PATTERN-RECORD FRAME)))
    (OFFSET (%PATTERN-VARIABLE.BOUND-TO-OFFSET SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ BINDINGS NULL)) (DEFINED? OFFSET)
     (CL:< OFFSET (LENGTH BINDINGS)))
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY BINDINGS))
     OFFSET)
    NULL)))

;;; (DEFUN (BOUND-TO-IN-RECORD OBJECT) ...)

(CL:DEFUN BOUND-TO-IN-RECORD (SELF RECORD)
  (CL:AREF
   (CL:THE CL:SIMPLE-VECTOR
    (%VECTOR.THE-ARRAY (%PATTERN-RECORD.VARIABLE-BINDINGS RECORD)))
   (CL:THE CL:FIXNUM (%PATTERN-VARIABLE.BOUND-TO-OFFSET SELF))))

;;; (DEFUN (CONTAINS-OPERATOR? BOOLEAN) ...)

(CL:DEFUN CONTAINS-OPERATOR? (PROPOSITION OPERATOR)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:IF (CL:EQ (%PROPOSITION.OPERATOR PROPOSITION) OPERATOR)
    (CL:SETQ TEST-VALUE-000 CL:T)
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:WHEN
        (CL:AND (ISA? ARG SGT-QUERY-LOGIC-PROPOSITION)
         (CONTAINS-OPERATOR? ARG OPERATOR))
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (CL:SETQ TEST-VALUE-000 FOUND?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (ARGUMENT-BOUND-TO OBJECT) ...)

(CL:DEFUN ARGUMENT-BOUND-TO (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN
      (CL:LET*
       ((VALUE
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY
            (%PATTERN-RECORD.VARIABLE-BINDINGS
             (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD
              *QUERYITERATOR*))))
          (CL:THE CL:FIXNUM
           (%PATTERN-VARIABLE.BOUND-TO-OFFSET SELF)))))
       (CL:WHEN
        (CL:AND (CL:EQ VALUE NULL)
         (CL:NOT
          (CL:EQ
           (ACCESS-IN-CONTEXT (%SKOLEM.VARIABLE-VALUE SELF)
            (%SKOLEM.HOME-CONTEXT SELF) CL:NIL)
           NULL)))
        (CL:SETQ VALUE (VALUE-OF SELF))
        (CL:WHEN (SKOLEM? VALUE)
         (CL:RETURN-FROM ARGUMENT-BOUND-TO NULL))
        (BIND-VARIABLE-TO-VALUE? SELF VALUE CL:T))
       VALUE)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000) (CL:PROGN (VALUE-OF SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:WHEN
       (CL:AND
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
           SYM-QUERY-LOGIC-EXTERNAL-VARIABLES NULL)
          NULL))
        (CONTAINS-OPERATOR? (%DESCRIPTION.PROPOSITION SELF)
         SGT-QUERY-PL-KERNEL-KB-HOLDS))
       (CL:LET* ((TEMP-000 (FIND-DUPLICATE-DESCRIPTION SELF)))
        (CL:LET*
         ((VALUE-000
           (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 SELF)))
         (CL:RETURN-FROM ARGUMENT-BOUND-TO VALUE-000))))
      (VALUE-OF SELF)))
    (CL:T (VALUE-OF SELF)))))

;;; (DEFUN (HELP-UNIFY-ATTRIBUTES? BOOLEAN) ...)

(CL:DEFUN HELP-UNIFY-ATTRIBUTES? (VALUE1 VALUE2)
  (CL:OR (EQL? VALUE1 VALUE2)
   (CL:AND (SKOLEM? VALUE1)
    (HELP-BIND-VARIABLE-TO-VALUE? VALUE1 VALUE2))))

;;; (DEFUN (FAILS-UNIFICATION-TYPE-CHECK? BOOLEAN) ...)

(CL:DEFUN FAILS-UNIFICATION-TYPE-CHECK? (V1 I2)
  (CL:COND ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-NONE) CL:NIL)
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-LOOKUP)
    (CL:LET*
     ((TYPE (%PATTERN-VARIABLE.SKOLEM-TYPE V1))
      (TYPEISOK?
       (CL:OR
        (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
         (CL:NOT
          (CL:EQ
           (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
           NULL)))
        (CHECK-STRICT-TYPE? I2 TYPE CL:T))))
     (CL:IF
      (CL:AND (CL:NOT TYPEISOK?)
       (NON-INFERABLE? (SURROGATE-TO-DESCRIPTION TYPE)))
      CL:T CL:NIL)))
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-SHALLOW-DISJOINT)
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ (%PATTERN-VARIABLE.SKOLEM-TYPE V1) NULL))
      (DISJOINT-CLASSES?
       (GET-DESCRIPTION (%PATTERN-VARIABLE.SKOLEM-TYPE V1))
       (GET-DESCRIPTION (LOGICAL-TYPE I2))))
     (CL:RETURN-FROM FAILS-UNIFICATION-TYPE-CHECK? CL:T))
    CL:NIL)
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-DISJOINT)
    (CL:LET* ((TYPE1 NULL) (TYPE2 NULL))
     (CL:LET*
      ((P NULL)
       (ITER-000
        (ALLOCATE-ITERATOR
         (UNFILTERED-DEPENDENT-ISA-PROPOSITIONS V1))))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ P (%ITERATOR.VALUE ITER-000))
       (CL:WHEN (CL:EQ (%PROPOSITION.KIND P) KWD-QUERY-ISA)
        (CL:SETQ TYPE1
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
          1))
        (CL:RETURN))))
     (CL:WHEN (CL:EQ TYPE1 NULL)
      (CL:RETURN-FROM FAILS-UNIFICATION-TYPE-CHECK? CL:NIL))
     (CL:COND
      ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE I2)
        SGT-QUERY-LOGIC-LOGIC-OBJECT)
       (CL:PROGN
        (CL:LET*
         ((P NULL)
          (ITER-001
           (ALLOCATE-ITERATOR
            (UNFILTERED-DEPENDENT-ISA-PROPOSITIONS I2))))
         (CL:LOOP WHILE (NEXT? ITER-001) DO
          (CL:SETQ P (%ITERATOR.VALUE ITER-001))
          (CL:WHEN (CL:EQ (%PROPOSITION.KIND P) KWD-QUERY-ISA)
           (CL:SETQ TYPE2
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
             1))
           (CL:RETURN))))))
      (CL:T (CL:SETQ TYPE2 (LOGICAL-TYPE I2))))
     (CL:WHEN (CL:EQ TYPE2 NULL)
      (CL:RETURN-FROM FAILS-UNIFICATION-TYPE-CHECK? CL:NIL))
     (DISJOINT-CLASSES? (GET-DESCRIPTION TYPE1)
      (GET-DESCRIPTION TYPE2))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" *TYPE-CHECK-STRATEGY* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (FAILS-ANTECEDENT-TYPE-CHECK? BOOLEAN) ...)

(CL:DEFUN FAILS-ANTECEDENT-TYPE-CHECK? (V1 I2)
  (CL:COND
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-LOOKUP)
    (CL:LET*
     ((TYPE (%PATTERN-VARIABLE.SKOLEM-TYPE V1))
      (TYPEISOK?
       (CL:OR
        (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
         (CL:NOT
          (CL:EQ
           (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
           NULL)))
        (CHECK-STRICT-TYPE? I2 TYPE CL:T))))
     (CL:IF
      (CL:AND (CL:NOT TYPEISOK?)
       (NON-INFERABLE? (SURROGATE-TO-DESCRIPTION TYPE)))
      CL:T CL:NIL)))
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-NONE) CL:NIL)
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" *TYPE-CHECK-STRATEGY* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (HELP-BIND-VARIABLE-TO-VALUE? BOOLEAN) ...)

(CL:DEFUN HELP-BIND-VARIABLE-TO-VALUE? (VARIABLE VALUE)
  (CL:COND
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-LOOKUP)
    (CL:LET* ((TYPEISOK? CL:NIL))
     (CL:MULTIPLE-VALUE-SETQ (TYPEISOK? VALUE)
      (CHECK-COERCED-TYPE? VALUE
       (%PATTERN-VARIABLE.SKOLEM-TYPE VARIABLE) CL:T))
     (CL:WHEN
      (CL:AND (CL:NOT TYPEISOK?)
       (NON-INFERABLE?
        (SURROGATE-TO-DESCRIPTION
         (%PATTERN-VARIABLE.SKOLEM-TYPE VARIABLE))))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
        (MEMB? *TRACED-KEYWORDS* KWD-QUERY-PERFORMANCE-CLUES))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "TYPE CHECK VIOLATION in 'bind-variable-to-value?'.  Type= "
        (%PATTERN-VARIABLE.SKOLEM-TYPE VARIABLE) " Value= " VALUE EOL))
      (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE? CL:NIL))))
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-NONE))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" *TYPE-CHECK-STRATEGY* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:LET*
   ((BOUNDTOVALUE
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY
        (%PATTERN-RECORD.VARIABLE-BINDINGS
         (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
      (CL:THE CL:FIXNUM (%PATTERN-VARIABLE.BOUND-TO-OFFSET VARIABLE))))
    (VARIABLEVALUE
     (ACCESS-IN-CONTEXT (%SKOLEM.VARIABLE-VALUE VARIABLE)
      (%SKOLEM.HOME-CONTEXT VARIABLE) CL:NIL)))
   (ELABORATE-INSTANCE VALUE)
   (CL:COND
    ((CL:AND (CL:NOT (CL:EQ VARIABLEVALUE NULL))
      (CL:EQ BOUNDTOVALUE NULL))
     (CL:SETQ VARIABLEVALUE (VALUE-OF VARIABLEVALUE))
     (SET-PATTERN-VARIABLE-BINDING VARIABLE VARIABLEVALUE)
     (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE?
      (EQL? VARIABLEVALUE VALUE)))
    ((CL:EQ BOUNDTOVALUE NULL)
     (SET-PATTERN-VARIABLE-BINDING VARIABLE VALUE))
    ((EQUAL? (VALUE-OF BOUNDTOVALUE) (VALUE-OF VALUE))
     (CL:WHEN (CL:NOT (EQL? BOUNDTOVALUE (VALUE-OF BOUNDTOVALUE)))
      (CHANGE-PATTERN-VARIABLE-BINDING VARIABLE
       (VALUE-OF BOUNDTOVALUE)))
     (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE? CL:T))
    (CL:T (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE? CL:NIL)))
   CL:T))

;;; (DEFUN (BIND-VARIABLE-TO-VALUE? BOOLEAN) ...)

(CL:DEFUN BIND-VARIABLE-TO-VALUE? (VARIABLE VALUE AUTOCLEANUP?)
  (CL:WHEN (CL:EQ VALUE NULL)
   (CL:WHEN
    (CL:AND
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT
       (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
        NULL)))
     (ALLOW-UNBOUND-VARIABLES?
      (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)))
    (CL:RETURN-FROM BIND-VARIABLE-TO-VALUE? CL:T))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
     "WARNING: Tried to bind " VARIABLE
     " to NULL value.  Potentially a PowerLoom bug" EOL)
    (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING KWD-QUERY-WARNING))
   (CL:RETURN-FROM BIND-VARIABLE-TO-VALUE? CL:NIL))
  (CL:IF AUTOCLEANUP?
   (CL:LET*
    ((PATTERNRECORD
      (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))
     (UBSTACKOFFSET
      (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))
     (SUCCESS? CL:NIL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
    (CL:SETQ SUCCESS? (HELP-BIND-VARIABLE-TO-VALUE? VARIABLE VALUE))
    (CL:WHEN (CL:NOT SUCCESS?)
     (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD
      (CL:1+ UBSTACKOFFSET)))
    SUCCESS?)
   (HELP-BIND-VARIABLE-TO-VALUE? VARIABLE VALUE)))

;;; (DEFUN (BIND-ARGUMENT-TO-VALUE? BOOLEAN) ...)

(CL:DEFUN BIND-ARGUMENT-TO-VALUE? (ARGUMENT VALUE AUTOCLEANUP?)
  (CL:WHEN (CL:EQ VALUE NULL)
   (CL:WHEN
    (CL:AND
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT
       (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
        NULL)))
     (ALLOW-UNBOUND-VARIABLES?
      (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)))
    (CL:RETURN-FROM BIND-ARGUMENT-TO-VALUE? CL:T))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
     "WARNING: Tried to bind " ARGUMENT
     " to NULL value.  Potentially a PowerLoom bug" EOL)
    (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING KWD-QUERY-WARNING))
   (CL:RETURN-FROM BIND-ARGUMENT-TO-VALUE? CL:NIL))
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE ARGUMENT)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-QUERY-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN (BIND-VARIABLE-TO-VALUE? ARGUMENT VALUE AUTOCLEANUP?)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
     (CL:PROGN (EQL? (VALUE-OF ARGUMENT) VALUE)))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-QUERY-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:WHEN (ISA? VALUE SGT-QUERY-LOGIC-PROPOSITION)
       (CL:LET* ((MAPPING (NEW-KEY-VALUE-LIST)))
        (CL:LET* ((TEST-VALUE-000 CL:NIL))
         (CL:SETQ TEST-VALUE-000
          (UNIFY-PROPOSITIONS? ARGUMENT VALUE MAPPING))
         (CL:WHEN TEST-VALUE-000
          (CL:LET* ((ALWAYS?-000 CL:T))
           (CL:LET*
            ((VAR NULL) (VAL NULL)
             (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST MAPPING)))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
             (CL:SETQ VAR (%KV-CONS.KEY ITER-000))
             (CL:SETQ VAL (%KV-CONS.VALUE ITER-000))
             (CL:WHEN
              (CL:NOT (BIND-VARIABLE-TO-VALUE? VAR VAL AUTOCLEANUP?))
              (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
             (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000))))
           (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
         (CL:WHEN TEST-VALUE-000
          (CL:RETURN-FROM BIND-ARGUMENT-TO-VALUE? CL:T)))))
      CL:NIL))
    (CL:T (EQL? ARGUMENT VALUE)))))

;;; (DEFUN (BIND-VECTOR-OF-ARGUMENTS-TO-VALUES? BOOLEAN) ...)

(CL:DEFUN BIND-VECTOR-OF-ARGUMENTS-TO-VALUES? (ARGUMENTS VALUES)
  (CL:LET*
   ((PATTERNRECORD
     (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))
    (UBSTACKOFFSET
     (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))
    (SUCCESS? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
   (CL:LET* ((ALWAYS?-000 CL:T))
    (CL:LET*
     ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)) (V NULL) (ITER-000 VALUES))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000)
       (CL:NOT (CL:EQ ITER-000 NIL)))
      DO
      (CL:SETQ ARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ V (%%VALUE ITER-000))
      (CL:WHEN (CL:NOT (BIND-ARGUMENT-TO-VALUE? ARG V CL:NIL))
       (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:SETQ SUCCESS? ALWAYS?-000))
   (CL:WHEN (CL:NOT SUCCESS?)
    (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD
     (CL:1+ UBSTACKOFFSET)))
   SUCCESS?))

;;; (DEFUN PRINT-CONTROL-FRAME-STACK ...)

(CL:DEFUN PRINT-CONTROL-FRAME-STACK (FRAME)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) FRAME
   EOL)
  (CL:WHEN (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
   (PRINT-CONTROL-FRAME-STACK (%CONTROL-FRAME.DOWN FRAME))))

;;; (DEFUN PCS ...)

(CL:DEFUN PCS ()
  (PRINT-CONTROL-FRAME-STACK
   (%QUERY-ITERATOR.BASE-CONTROL-FRAME *QUERYITERATOR*)))

;;; (DEFUN (VARIABLE-FROM-UNBINDING-OFFSET PATTERN-VARIABLE) ...)

(CL:DEFUN VARIABLE-FROM-UNBINDING-OFFSET (DESCRIPTION UBOFFSET)
  (CL:DECLARE (CL:TYPE CL:FIXNUM UBOFFSET))
  #+MCL
  (CL:CHECK-TYPE UBOFFSET CL:FIXNUM)
  (CL:LET*
   ((PATTERNRECORD
     (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))
    (OFFSET
     (%INTEGER-WRAPPER.WRAPPER-VALUE
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY
         (%PATTERN-RECORD.UNBINDING-STACK PATTERNRECORD)))
       UBOFFSET))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
   (CL:LET*
    ((VBL NULL) (VECTOR-000 (%DESCRIPTION.IO-VARIABLES DESCRIPTION))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ VBL
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:WHEN (CL:= (%PATTERN-VARIABLE.BOUND-TO-OFFSET VBL) OFFSET)
      (CL:RETURN-FROM VARIABLE-FROM-UNBINDING-OFFSET VBL))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET*
    ((VBL NULL)
     (VECTOR-001 (%DESCRIPTION.INTERNAL-VARIABLES DESCRIPTION))
     (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
    (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
     (CL:SETQ VBL
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
       INDEX-001))
     (CL:WHEN (CL:= (%PATTERN-VARIABLE.BOUND-TO-OFFSET VBL) OFFSET)
      (CL:RETURN-FROM VARIABLE-FROM-UNBINDING-OFFSET VBL))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
   NULL))

;;; (DEFSPECIAL *PRINTINFRAME* ...)

(CL:DEFVAR *PRINTINFRAME* NULL
  "If set, controls diagnostic printing by making
variable bindings appear relative to the frame '*printInFrame*'.")

;;; (DEFUN PRINT-ONE-VARIABLE-BINDING ...)

(CL:DEFUN PRINT-ONE-VARIABLE-BINDING (VARIABLE)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   (%PATTERN-VARIABLE.SKOLEM-NAME VARIABLE) "=")
  (CL:IF (DEFINED? (%PATTERN-VARIABLE.BOUND-TO-OFFSET VARIABLE))
   (CL:LET*
    ((VALUE
      (CL:IF (CL:NOT (CL:EQ *PRINTINFRAME* NULL))
       (BOUND-TO-IN-FRAME VARIABLE *PRINTINFRAME*)
       (SAFE-BOUND-TO VARIABLE))))
    (PRINT-UNFORMATTED-LOGICAL-FORM VALUE STANDARD-OUTPUT))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    SYM-QUERY-STELLA-NULL))
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) " "))

;;; (DEFUN PRINT-VARIABLE-BINDINGS ...)

(CL:DEFUN PRINT-VARIABLE-BINDINGS (FRAME)
  (CL:LET*
   ((PATTERNRECORD (OPERATIVE-PATTERN-RECORD FRAME))
    (DESCRIPTION NULL))
   (CL:WHEN (CL:NOT (CL:EQ PATTERNRECORD NULL))
    (CL:WHEN
     (CL:EQ (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-CONTAINED-BY)
     (CL:LET*
      ((MEMBERPROPOSITION
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY
           (%PROPOSITION.ARGUMENTS
            (%CONTROL-FRAME.PROPOSITION FRAME))))
         0))
       (MEMBER
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY
           (%PROPOSITION.ARGUMENTS MEMBERPROPOSITION)))
         0)))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE MEMBER)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-PATTERN-VARIABLE)
         (CL:PROGN (PRINT-ONE-VARIABLE-BINDING MEMBER)))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-LIST)
         (CL:PROGN
          (CL:LET* ((M NULL) (ITER-000 (%LIST.THE-CONS-LIST MEMBER)))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
            (CL:SETQ M (%%VALUE ITER-000))
            (PRINT-ONE-VARIABLE-BINDING M)
            (CL:SETQ ITER-000 (%%REST ITER-000))))))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
           TEST-VALUE-000 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
     (CL:RETURN-FROM PRINT-VARIABLE-BINDINGS))
    (CL:SETQ DESCRIPTION
     (%PATTERN-RECORD.OPTIMAL-PATTERN PATTERNRECORD))
    (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
     (CL:LET*
      ((VBL NULL) (VECTOR-000 (%DESCRIPTION.IO-VARIABLES DESCRIPTION))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ VBL
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:WHEN
        (CL:NOT
         (CL:EQ
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY
             (%PATTERN-RECORD.VARIABLE-BINDINGS PATTERNRECORD)))
           (CL:THE CL:FIXNUM (%PATTERN-VARIABLE.BOUND-TO-OFFSET VBL)))
          NULL))
        (PRINT-ONE-VARIABLE-BINDING VBL))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (CL:LET*
      ((VBL NULL)
       (VECTOR-001 (%DESCRIPTION.INTERNAL-VARIABLES DESCRIPTION))
       (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:SETQ VBL
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:WHEN
        (CL:NOT
         (CL:EQ
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY
             (%PATTERN-RECORD.VARIABLE-BINDINGS PATTERNRECORD)))
           (CL:THE CL:FIXNUM (%PATTERN-VARIABLE.BOUND-TO-OFFSET VBL)))
          NULL))
        (PRINT-ONE-VARIABLE-BINDING VBL))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))))))

;;; (DEFUN PRINT-RULE-IN-GOAL-TREE ...)

(CL:DEFUN PRINT-RULE-IN-GOAL-TREE (FRAME IMPLIESPROP DEPTH)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
  #+MCL
  (CL:CHECK-TYPE DEPTH CL:FIXNUM)
  (CL:LET*
   ((PATTERNRECORD (%CONTROL-FRAME.PATTERN-RECORD FRAME))
    (REVERSEPOLARITY? (%CONTROL-FRAME.REVERSE-POLARITY? FRAME)))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "RULE: ")
   (CL:LET*
    ((RULENAME
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS IMPLIESPROP)
       SYM-QUERY-STELLA-SURROGATE-VALUE-INVERSE NULL)))
    (CL:WHEN
     (CL:AND (CL:EQ RULENAME NULL)
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS IMPLIESPROP)
         SYM-QUERY-LOGIC-MASTER-PROPOSITION NULL)
        NULL)))
     (CL:SETQ RULENAME
      (DYNAMIC-SLOT-VALUE
       (%PROPOSITION.DYNAMIC-SLOTS
        (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS IMPLIESPROP)
         SYM-QUERY-LOGIC-MASTER-PROPOSITION NULL))
       SYM-QUERY-STELLA-SURROGATE-VALUE-INVERSE NULL)))
    (CL:WHEN (CL:NOT (CL:EQ RULENAME NULL))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      (%SURROGATE.SYMBOL-NAME RULENAME) EOL)
     (PRINT-INDENT STANDARD-OUTPUT (CL:+ (CL:* 2 DEPTH) 6))))
   (CL:LET*
    ((*PRINTMODE* KWD-QUERY-FLAT)
     (*PRINTLOGICALFORMSTREAM* STANDARD-OUTPUT)
     (*INDENTCOUNTER* (CL:+ (CL:* 2 DEPTH) 7)) (*QUERYITERATOR* NULL))
    (CL:DECLARE
     (CL:SPECIAL *PRINTMODE* *PRINTLOGICALFORMSTREAM* *INDENTCOUNTER*
      *QUERYITERATOR*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
    (CL:LET* ((CHOOSE-VALUE-000 NULL))
     (CL:IF REVERSEPOLARITY?
      (CL:LET*
       ((TEMP-000 (%PATTERN-RECORD.OPTIMAL-PATTERN PATTERNRECORD)))
       (CL:SETQ CHOOSE-VALUE-000
        (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000
         (%PATTERN-RECORD.DESCRIPTION PATTERNRECORD))))
      (CL:SETQ CHOOSE-VALUE-000
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS IMPLIESPROP)))
        1)))
     (CL:LET* ((CHOOSE-VALUE-001 NULL))
      (CL:IF REVERSEPOLARITY?
       (CL:SETQ CHOOSE-VALUE-001
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS IMPLIESPROP)))
         0))
       (CL:LET*
        ((TEMP-001 (%PATTERN-RECORD.OPTIMAL-PATTERN PATTERNRECORD)))
        (CL:SETQ CHOOSE-VALUE-001
         (CL:IF (CL:NOT (CL:EQ TEMP-001 NULL)) TEMP-001
          (%PATTERN-RECORD.DESCRIPTION PATTERNRECORD)))))
      (PRINT-DESCRIPTIONS-AS-KIF-RULE CHOOSE-VALUE-000 CHOOSE-VALUE-001
       IMPLIESPROP REVERSEPOLARITY?))))))

;;; (DEFUN PRINT-GOAL-IN-GOAL-TREE ...)

(CL:DEFUN PRINT-GOAL-IN-GOAL-TREE (FRAME DEPTH)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
  #+MCL
  (CL:CHECK-TYPE DEPTH CL:FIXNUM)
  (CL:IF (CL:NOT (CL:EQ (%CONTROL-FRAME.PROPOSITION FRAME) NULL))
   (CL:LET* ((INVERT? (%CONTROL-FRAME.REVERSE-POLARITY? FRAME)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "GOAL: ")
    (CL:WHEN INVERT?
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "~"))
    (CL:LET*
     ((*PRINTMODE* KWD-QUERY-REALISTIC)
      (*PRINTLOGICALFORMSTREAM* STANDARD-OUTPUT)
      (*INDENTCOUNTER* (CL:+ (CL:* 2 DEPTH) 7)))
     (CL:DECLARE
      (CL:SPECIAL *PRINTMODE* *PRINTLOGICALFORMSTREAM*
       *INDENTCOUNTER*))
     (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
     (PRINT-UNFORMATTED-LOGICAL-FORM (%CONTROL-FRAME.PROPOSITION FRAME)
      STANDARD-OUTPUT)
     (CL:WHEN (DEFINED? (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       " ticks=" (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME)))))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "STRATEGY: "
    (%CONTROL-FRAME.CURRENT-STRATEGY (%CONTROL-FRAME.UP FRAME)))))

;;; (DEFUN (COMPUTE-FRAME-DEPTH INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) COMPUTE-FRAME-DEPTH))
(CL:DEFUN COMPUTE-FRAME-DEPTH (FRAME)
  (CL:LET*
   ((DEPTH 0)
    (CURSOR
     (CL:IF (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (%QUERY-ITERATOR.BASE-CONTROL-FRAME *QUERYITERATOR*) NULL)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
    (CL:WHEN (CL:EQ CURSOR FRAME) (CL:RETURN))
    (CL:SETQ CURSOR (%CONTROL-FRAME.DOWN CURSOR))
    (CL:SETQ DEPTH (CL:1+ DEPTH)))
   (CL:IF (CL:EQ CURSOR FRAME) DEPTH NULL-INTEGER)))

;;; (DEFUN PRINT-VERTICAL-BARS ...)

(CL:DEFUN PRINT-VERTICAL-BARS (DEPTH)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
  #+MCL
  (CL:CHECK-TYPE DEPTH CL:FIXNUM)
  (CL:LET* ((I (INTERVAL 1 DEPTH)))
   (CL:LOOP WHILE (NEXT? I) DO
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "| "))))

;;; (DEFUN UNWIND-TO-CHOICE-POINTS-BELOW-FRAME ...)

(CL:DEFUN UNWIND-TO-CHOICE-POINTS-BELOW-FRAME (FRAME)
  (CL:WHEN (CL:NOT (CL:EQ FRAME NULL)) (UNWIND-TO-CHOICE-POINT FRAME)
   (UNWIND-TO-CHOICE-POINTS-BELOW-FRAME (%CONTROL-FRAME.DOWN FRAME))))

;;; (DEFUN TRACE-GOAL-TREE ...)

(CL:DEFUN TRACE-GOAL-TREE (FRAME DEPTH LASTMOVE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
  #+MCL
  (CL:CHECK-TYPE DEPTH CL:FIXNUM)
  (CL:WHEN (CL:EQ LASTMOVE KWD-QUERY-DOWN)
   (UNWIND-TO-CHOICE-POINTS-BELOW-FRAME FRAME))
  (CL:WHEN
   (CL:AND
    (CL:EQ (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-ITERATIVE-FORALL)
    (CL:EQ LASTMOVE KWD-QUERY-DOWN))
   (CL:RETURN-FROM TRACE-GOAL-TREE))
  (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-STATE-MACHINE)
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE FRAME)
      SGT-QUERY-LOGIC-PARALLEL-CONTROL-FRAME)
     (CL:PROGN
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "P" (DEBUG-FRAME-ID FRAME))))
    (CL:T
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "F"
      (DEBUG-FRAME-ID FRAME))))
   (CL:IF
    (DEFINED? (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET FRAME))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) ","
     (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET FRAME) " ")
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "   "))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    (CL:IF
     (CL:OR
      (CL:EQ (%CONTROL-FRAME.TRUTH-VALUE FRAME)
       DEFAULT-TRUE-TRUTH-VALUE)
      (CL:EQ (%CONTROL-FRAME.TRUTH-VALUE FRAME)
       DEFAULT-FALSE-TRUTH-VALUE))
     "D " "S ")))
  (CL:WHEN
   (CL:OR
    (CL:EQ (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-PARALLEL-STRATEGIES)
    (CL:AND (CL:EQ (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-STRATEGY)
     (CL:EQ (%CONTROL-FRAME.CURRENT-STRATEGY FRAME) NULL)))
   (CL:RETURN-FROM TRACE-GOAL-TREE))
  (CL:WHEN
   (CL:NOT
    (CL:AND (CL:EQ LASTMOVE KWD-QUERY-DOWN)
     (MEMBER?
      (GET-QUOTED-TREE "((:ATOMIC-GOAL :STRATEGY) \"/LOGIC\")"
       "/LOGIC")
      (%CONTROL-FRAME.STATE FRAME))
     (CL:EQ (%%VALUE (%CONTROL-FRAME.NEXT-STRATEGIES FRAME))
      KWD-QUERY-SPECIALIST)
     (CL:NOT (TRACE-KEYWORD? KWD-QUERY-STRATEGIES))))
   (PRINT-VERTICAL-BARS DEPTH))
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:LET* ((TEST-VALUE-000 (%CONTROL-FRAME.STATE FRAME)))
     (CL:COND
      ((CL:OR (CL:EQ TEST-VALUE-000 KWD-QUERY-ATOMIC-GOAL)
        (CL:EQ TEST-VALUE-000 KWD-QUERY-STRATEGY))
       (CL:IF
        (CL:EQ (%%VALUE (%CONTROL-FRAME.NEXT-STRATEGIES FRAME))
         KWD-QUERY-SPECIALIST)
        (CL:PROGN
         (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-STRATEGIES)
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
           "TRY STRATEGIES: "))
         (CL:RETURN-FROM TRACE-GOAL-TREE))
        (CL:PROGN (PRINT-GOAL-IN-GOAL-TREE FRAME DEPTH)
         (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-STRATEGIES)
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL)
          (PRINT-VERTICAL-BARS DEPTH)
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "STRATEGY: ")
          (CL:RETURN-FROM TRACE-GOAL-TREE)))))
      ((CL:EQ TEST-VALUE-000 KWD-QUERY-PATTERN)
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
         (MEMB? *TRACED-KEYWORDS* KWD-QUERY-STRATEGIES))
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         EOL))
       (CL:LET* ((UPFRAME (%CONTROL-FRAME.UP FRAME)))
        (CL:IF
         (CL:AND (CL:NOT (CL:EQ UPFRAME NULL))
          (CL:NOT
           (CL:EQ
            (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS UPFRAME)
             SYM-QUERY-LOGIC-ANTECEDENTS-RULE NULL)
            NULL)))
         (PRINT-RULE-IN-GOAL-TREE FRAME
          (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS UPFRAME)
           SYM-QUERY-LOGIC-ANTECEDENTS-RULE NULL)
          DEPTH)
         (CL:PROGN
          (CL:WHEN
           (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
            (CL:NOT
             (CL:EQ
              (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
              NULL)))
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL))
          (CL:IF
           (CL:NOT
            (CL:EQ
             (%PATTERN-RECORD.COLLECTION-LIST
              (%CONTROL-FRAME.PATTERN-RECORD FRAME))
             NULL))
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
            "COLLECTION: [")
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
            "PATTERN: ["))
          (CL:LET* ((FIRSTTIME? CL:T))
           (CL:LET*
            ((TV NULL)
             (VECTOR-000
              (%PATTERN-RECORD.BOOLEAN-VECTOR
               (%CONTROL-FRAME.PATTERN-RECORD FRAME)))
             (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
            (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
            (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
             (CL:SETQ TV
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
               INDEX-000))
             (CL:IF FIRSTTIME? (CL:SETQ FIRSTTIME? CL:NIL)
              (%%PRINT-STREAM
               (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) ","))
             (CL:IF (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN TV)
              (%%PRINT-STREAM
               (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "T")
              (%%PRINT-STREAM
               (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "F"))
             (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "]")))))
      (CL:T (PRINT-GOAL-IN-GOAL-TREE FRAME DEPTH)))))
   ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
    (CL:COND
     (CL:T
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "| SUCC: ")
      (CL:LET* ((*PRINTINFRAME* FRAME))
       (CL:DECLARE (CL:SPECIAL *PRINTINFRAME*))
       (PRINT-VARIABLE-BINDINGS FRAME))
      (CL:LET* ((TRUTHVALUE (%CONTROL-FRAME.TRUTH-VALUE FRAME)))
       (CL:WHEN (CL:NOT (CL:EQ TRUTHVALUE NULL))
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "truth=")
        (CL:COND
         ((CL:OR (CL:EQ TRUTHVALUE TRUE-TRUTH-VALUE)
           (CL:EQ TRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE))
          (CL:IF
           (CL:OR (CL:EQ TRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
            (CL:EQ TRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE))
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "t")
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "T")))
         ((CL:OR (CL:EQ TRUTHVALUE FALSE-TRUTH-VALUE)
           (CL:EQ TRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE))
          (CL:IF
           (CL:OR (CL:EQ TRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
            (CL:EQ TRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE))
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "f")
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "F")))
         ((CL:OR (CL:EQ TRUTHVALUE UNKNOWN-TRUTH-VALUE)
           (CL:EQ TRUTHVALUE NULL))
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "U"))
         (CL:T
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "?"))))))))
   ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "| FAIL")
    (CL:LET* ((TEST-VALUE-001 (%CONTROL-FRAME.STATE FRAME)))
     (CL:COND
      ((CL:OR (CL:EQ TEST-VALUE-001 KWD-QUERY-ATOMIC-GOAL)
        (CL:EQ TEST-VALUE-001 KWD-QUERY-STRATEGY))
       (CL:WHEN
        (CL:AND (TRACE-KEYWORD? KWD-QUERY-STRATEGIES)
         (CL:NOT (CL:EQ (%CONTROL-FRAME.NEXT-STRATEGIES FRAME) NIL)))
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         EOL)
        (PRINT-VERTICAL-BARS DEPTH)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "TRY STRATEGIES: ")
        (CL:RETURN-FROM TRACE-GOAL-TREE)))
      (CL:T)))
    (CL:LET* ((TRUTHVALUE (%CONTROL-FRAME.TRUTH-VALUE FRAME)))
     (CL:WHEN
      (CL:OR (CL:NOT (CL:EQ TRUTHVALUE NULL))
       (CL:NOT
        (CL:EQ (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME) NULL)))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       ":"))
     (CL:WHEN (CL:NOT (CL:EQ TRUTHVALUE NULL))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       " truth=")
      (CL:COND
       ((CL:OR (CL:EQ TRUTHVALUE TRUE-TRUTH-VALUE)
         (CL:EQ TRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE))
        (CL:IF
         (CL:OR (CL:EQ TRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
          (CL:EQ TRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "t")
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "T")))
       ((CL:OR (CL:EQ TRUTHVALUE FALSE-TRUTH-VALUE)
         (CL:EQ TRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE))
        (CL:IF
         (CL:OR (CL:EQ TRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
          (CL:EQ TRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "f")
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "F")))
       ((CL:OR (CL:EQ TRUTHVALUE UNKNOWN-TRUTH-VALUE)
         (CL:EQ TRUTHVALUE NULL))
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "U"))
       (CL:T
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "?"))))))
   (CL:T
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "????: ")))
  (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-STATE-MACHINE)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    " state= " (%CONTROL-FRAME.STATE FRAME) "  lastMove= " LASTMOVE
    " depth= " DEPTH " revPty?= "
    (%CONTROL-FRAME.REVERSE-POLARITY? FRAME)))
  (CL:COND
   ((CL:EQ (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME) NULL)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     EOL))
   (CL:T
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) " ")
    (CL:COND
     ((CL:OR (CL:EQ LASTMOVE KWD-QUERY-DOWN)
       (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
       (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
      (TRACE-FRAME-PARTIAL-TRUTH
       (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME) LASTMOVE
       STANDARD-OUTPUT)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       EOL))
     (CL:T)))))

;;; (DEFUN (OLD-INTERPRET-AND-SCORES KEYWORD) ...)

(CL:DEFUN OLD-INTERPRET-AND-SCORES (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:LET* ((PMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))
     (CL:IF (CL:EQ PMF NULL)
      (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME KWD-QUERY-AND)
      (CL:PROGN
       (CL:LOOP WHILE
        (CL:>
         (LENGTH
          (%PARTIAL-MATCH-FRAME.ARGUMENT-SCORES
           (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))
         (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME))
        DO
        (POP-PARTIAL-MATCH-SCORE
         (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))
       (SET-DYNAMIC-CUTOFF PMF)))))
   ((CL:OR (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
    (CL:LET*
     ((PMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME))
      (ARITY
       (LENGTH
        (%PROPOSITION.ARGUMENTS (%CONTROL-FRAME.PROPOSITION FRAME))))
      (I 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY I))
     (CL:SETF (%PARTIAL-MATCH-FRAME.SUCCESS? PMF)
      (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE))
     (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)
     (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       (%FLOAT-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
         SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE NULL-FLOAT-WRAPPER))
       ", "
       (COMPUTE-AND-SCORE (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME))
       EOL))
     (CL:WHEN
      (CL:NOT (CL:EQ (%PARTIAL-MATCH-FRAME.UNBOUND-VARS PMF) NIL))
      (SET-DYNAMIC-SLOT-VALUE
       (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
       SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE (WRAP-FLOAT 0.0d0)
       NULL-FLOAT-WRAPPER)
      (CL:LOOP
       (CL:LET* ((TEST-VALUE-000 CL:NIL))
        (CL:SETQ TEST-VALUE-000
         (< (CL:1+ (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)) ARITY))
        (CL:WHEN TEST-VALUE-000
         (CL:LET* ((FOUND?-000 CL:NIL))
          (CL:LET*
           ((VAR NULL)
            (ITER-000
             (GET-UNBOUND-VARIABLES
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (%VECTOR.THE-ARRAY
                 (%PROPOSITION.ARGUMENTS
                  (%CONTROL-FRAME.PROPOSITION FRAME))))
               (CL:THE CL:FIXNUM
                (CL:1+ (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)))))))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
            (CL:SETQ VAR (%%VALUE ITER-000))
            (CL:WHEN
             (SEARCH-CONS-TREE? (%PARTIAL-MATCH-FRAME.UNBOUND-VARS PMF)
              VAR)
             (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
            (CL:SETQ ITER-000 (%%REST ITER-000))))
          (CL:SETQ TEST-VALUE-000 FOUND?-000)))
        (CL:WHEN (CL:NOT TEST-VALUE-000) (CL:RETURN)))
       (CL:SETQ I (CL:1+ I))
       (CL:SETF (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)
        (CL:1+ (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)))
       (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME))
      (CL:SETF (%PARTIAL-MATCH-FRAME.UNBOUND-VARS PMF) NIL)
      (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "   *** Skipping " I " propositions . . ." EOL)))
     (CL:WHEN *FAIL-UNBOUND-CLAUSES?*
      (CL:LOOP WHILE
       (CL:AND
        (CL:< (CL:1+ (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)) ARITY)
        (ALL-VARIABLES-UNBOUND?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY
            (%PROPOSITION.ARGUMENTS
             (%CONTROL-FRAME.PROPOSITION FRAME))))
          (CL:THE CL:FIXNUM
           (CL:1+ (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME))))))
       DO (CL:SETQ I (CL:1+ I))
       (CL:SETF (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)
        (CL:1+ (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)))
       (SET-DYNAMIC-SLOT-VALUE
        (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
        SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE (WRAP-FLOAT 0.0d0)
        NULL-FLOAT-WRAPPER)
       (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME))
      (CL:WHEN (CL:AND (CL:> I 0) (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "   *** Skipping " I " propositions . . ." EOL)))
     (CL:COND
      ((COMPUTE-PARTIAL-MATCH-AND-FAILURE? FRAME)
       (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
      ((CL:AND
        (CL:= (CL:1+ (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)) ARITY)
        (CL:NOT (COMPUTE-PARTIAL-MATCH-SCORE? FRAME)))
       (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
      (CL:T (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" LASTMOVE "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:WHEN
   (CL:AND (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
    (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL)))
   (CL:SETF (%CONTROL-FRAME.DOWN FRAME) NULL))
  LASTMOVE)

;;; (DEFMETHOD (CONTINUE-PARTIAL-AND-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-AND-PROOF ((SELF CONTROL-FRAME) FRAME LASTMOVE)
  (CL:LET* ((PMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF)))
   (CL:WHEN (CL:EQ PMF NULL)
    (CREATE-AND-LINK-PARTIAL-MATCH-FRAME SELF KWD-QUERY-AND))
   (CONTINUE-PARTIAL-AND-PROOF
    (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF) FRAME LASTMOVE)))

;;; (DEFUN (INTERPRET-ITERATIVE-FORALL-SCORES KEYWORD) ...)

(CL:DEFUN INTERPRET-ITERATIVE-FORALL-SCORES (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:IF (CL:EQ (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME) NULL)
     (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME
      KWD-QUERY-ITERATIVE-FORALL)
     (CL:LOOP WHILE
      (CL:>
       (LENGTH
        (%PARTIAL-MATCH-FRAME.ARGUMENT-SCORES
         (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))
       (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME))
      DO
      (POP-PARTIAL-MATCH-SCORE
       (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))))
   ((CL:OR (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
    (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)
    (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "ITERATIVE-FORALL "
      (%FLOAT-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE
        (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
        SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE NULL-FLOAT-WRAPPER))
      EOL))
    (CL:WHEN
     (CL:<
      (%FLOAT-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE
        (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
        SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE NULL-FLOAT-WRAPPER))
      0.9d0)
     (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" LASTMOVE "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  LASTMOVE)

;;; (DEFUN (OLD-INTERPRET-OR-SCORES KEYWORD) ...)

(CL:DEFUN OLD-INTERPRET-OR-SCORES (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:LET* ((PMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))
     (CL:IF (CL:EQ PMF NULL)
      (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME KWD-QUERY-OR)
      (CL:PROGN
       (CL:LOOP WHILE
        (CL:>
         (LENGTH
          (%PARTIAL-MATCH-FRAME.ARGUMENT-SCORES
           (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))
         (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME))
        DO
        (POP-PARTIAL-MATCH-SCORE
         (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))
       (SET-DYNAMIC-CUTOFF PMF)))))
   ((CL:OR (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
    (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)
    (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      (%FLOAT-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE
        (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
        SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE NULL-FLOAT-WRAPPER))
      ", "
      (COMPUTE-OR-SCORE (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME))
      EOL))
    (CL:COND
     ((COMPUTE-PARTIAL-MATCH-OR-SUCCESS? FRAME)
      (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))
     ((CL:AND
       (CL:= (CL:1+ (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME))
        (LENGTH
         (%PROPOSITION.ARGUMENTS (%CONTROL-FRAME.PROPOSITION FRAME))))
       (COMPUTE-PARTIAL-MATCH-SCORE? FRAME))
      (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))
     (CL:T (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" LASTMOVE "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  LASTMOVE)

;;; (DEFMETHOD (CONTINUE-PARTIAL-OR-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-OR-PROOF ((SELF CONTROL-FRAME) LASTMOVE)
  (CL:LET* ((PMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF)))
   (CL:WHEN (CL:EQ PMF NULL)
    (CREATE-AND-LINK-PARTIAL-MATCH-FRAME SELF KWD-QUERY-OR))
   (CONTINUE-PARTIAL-OR-PROOF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF)
    LASTMOVE)))

;;; (DEFUN (OLD-INTERPRET-FAIL-SCORE KEYWORD) ...)

(CL:DEFUN OLD-INTERPRET-FAIL-SCORE (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (SET-DYNAMIC-SLOT-VALUE
     (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
     SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE (WRAP-FLOAT 0.0d0)
     NULL-FLOAT-WRAPPER)
    (CL:WHEN (CL:EQ (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME) NULL)
     (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME KWD-QUERY-NOT)))
   ((CL:OR (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
    (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)
    (CL:IF (COMPUTE-PARTIAL-MATCH-SCORE? FRAME)
     (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" LASTMOVE "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  LASTMOVE)

;;; (DEFMETHOD (CONTINUE-PARTIAL-NOT-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-NOT-PROOF ((SELF CONTROL-FRAME) LASTMOVE)
  (CL:LET* ((PMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF)))
   (CL:WHEN (CL:EQ PMF NULL)
    (CREATE-AND-LINK-PARTIAL-MATCH-FRAME SELF KWD-QUERY-NOT))
   (CONTINUE-PARTIAL-NOT-PROOF
    (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF) LASTMOVE)))

;;; (DEFUN (OLD-INTERPRET-GOAL-SCORES KEYWORD) ...)

(CL:DEFUN OLD-INTERPRET-GOAL-SCORES (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:LET* ((PMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))
     (CL:IF (CL:EQ PMF NULL)
      (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME KWD-QUERY-ATOMIC-GOAL)
      (SET-DYNAMIC-CUTOFF PMF))))
   ((CL:OR (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
    (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      (%FLOAT-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE
        (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
        SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE NULL-FLOAT-WRAPPER))
      EOL))
    (CL:WHEN
     (CL:OR
      (CL:EQ (%CONTROL-FRAME.CURRENT-STRATEGY FRAME)
       KWD-QUERY-FULL-SUBQUERY)
      (CL:EQ (%CONTROL-FRAME.CURRENT-STRATEGY FRAME)
       KWD-QUERY-ANTECEDENTS))
     (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)
     (CL:COND
      ((CL:AND (COMPUTE-PARTIAL-MATCH-OR-SUCCESS? FRAME)
        (CL:NOT (UNBOUND-VARIABLES-IN-FRAME? FRAME)))
       (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))
      ((CL:AND
        (EMPTY?
         (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
          SYM-QUERY-STELLA-ITERATOR NULL))
        (CL:NOT (UNBOUND-VARIABLES-IN-FRAME? FRAME))
        (COMPUTE-PARTIAL-MATCH-SCORE? FRAME))
       (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))
      (CL:T (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" LASTMOVE "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (ATTACH-SUPPORT FRAME LASTMOVE)
  (CL:WHEN
   (CL:AND (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
    (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL)))
   (CL:SETF (%CONTROL-FRAME.DOWN FRAME) NULL))
  (CL:LET* ((RESULT (CONTINUE-STRATEGIES-PROOFS FRAME LASTMOVE)))
   (CL:COND
    ((CL:AND (CL:EQ RESULT KWD-QUERY-FAILURE)
      (COMPUTE-PARTIAL-MATCH-SCORE? FRAME))
     (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE) KWD-QUERY-FINAL-SUCCESS)
    (CL:T RESULT))))

;;; (DEFUN ATTACH-SUPPORT ...)

(CL:DEFUN ATTACH-SUPPORT (FRAME LASTMOVE)
  (CL:IF
   (CL:AND (CL:NOT (CL:EQ LASTMOVE KWD-QUERY-DOWN))
    (CL:EQ (%CONTROL-FRAME.CURRENT-STRATEGY FRAME)
     KWD-QUERY-ANTECEDENTS)
    (ISA? (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)
     SGT-QUERY-LOGIC-NN-PARTIAL-MATCH)
    (CL:NOT
     (CL:EQ
      (%PARTIAL-MATCH-FRAME.CHILD
       (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME))
      NULL)))
   (CL:LET*
    ((PMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME))
     (SUPPORT (NEW-PARTIAL-SUPPORT)))
    (CL:SETF (%PARTIAL-SUPPORT.ID SUPPORT)
     (CL:SETQ *PARTIAL-SUPPORT-COUNTER*
      (CL:1+ *PARTIAL-SUPPORT-COUNTER*)))
    (CL:SETF (%PARTIAL-SUPPORT.AXIOM SUPPORT)
     (%%VALUE (%NN-PARTIAL-MATCH.RULES PMF)))
    (CL:SETF (%PARTIAL-SUPPORT.FACT SUPPORT)
     (%CONTROL-FRAME.PROPOSITION
      (%NN-PARTIAL-MATCH.CONTROL-FRAME (%NN-PARTIAL-MATCH.CHILD PMF))))
    (CL:SETF (%PARTIAL-SUPPORT.ARGUMENT-SCORES SUPPORT)
     (REVERSE
      (COPY-CONS-LIST
       (%NN-PARTIAL-MATCH.ARGUMENT-SCORES
        (%NN-PARTIAL-MATCH.CHILD PMF)))))
    (CL:SETF (%PARTIAL-SUPPORT.SCORE SUPPORT)
     (%FLOAT-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       (%PROPOSITION.DYNAMIC-SLOTS (%PARTIAL-SUPPORT.FACT SUPPORT))
       SYM-QUERY-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER)))
    (CL:IF
     (CL:NOT (CL:EQ (SUPPORT (%CONTROL-FRAME.PROPOSITION FRAME)) NULL))
     (SET-DYNAMIC-SLOT-VALUE
      (%PROPOSITION.DYNAMIC-SLOTS (%CONTROL-FRAME.PROPOSITION FRAME))
      SYM-QUERY-LOGIC-SUPPORT
      (CONS SUPPORT (SUPPORT (%CONTROL-FRAME.PROPOSITION FRAME))) NULL)
     (SET-DYNAMIC-SLOT-VALUE
      (%PROPOSITION.DYNAMIC-SLOTS (%CONTROL-FRAME.PROPOSITION FRAME))
      SYM-QUERY-LOGIC-SUPPORT (CONS-LIST SUPPORT) NULL)))
   (SET-DYNAMIC-SLOT-VALUE
    (%PROPOSITION.DYNAMIC-SLOTS (%CONTROL-FRAME.PROPOSITION FRAME))
    SYM-QUERY-LOGIC-SUPPORT NULL NULL)))

;;; (DEFMETHOD (CONTINUE-PARTIAL-STRATEGIES-PROOFS KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-STRATEGIES-PROOFS ((SELF CONTROL-FRAME) LASTMOVE)
  (CL:WHEN
   (CL:EQ (%CONTROL-FRAME.CURRENT-STRATEGY SELF)
    KWD-QUERY-FULL-SUBQUERY)
   (CL:RETURN-FROM CONTINUE-PARTIAL-STRATEGIES-PROOFS
    (CONTINUE-STRATEGIES-PROOFS SELF LASTMOVE)))
  (CL:LET* ((PMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF)))
   (CL:WHEN (CL:EQ PMF NULL)
    (CREATE-AND-LINK-PARTIAL-MATCH-FRAME SELF KWD-QUERY-ATOMIC-GOAL))
   (CONTINUE-PARTIAL-STRATEGIES-PROOFS
    (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF) LASTMOVE)))

;;; (DEFUN (OPERATIVE-PATTERN-RECORD PATTERN-RECORD) ...)

(CL:DEFUN OPERATIVE-PATTERN-RECORD (FRAME)
  (CL:IF (CL:NOT (CL:EQ (%CONTROL-FRAME.PATTERN-RECORD FRAME) NULL))
   (%CONTROL-FRAME.PATTERN-RECORD FRAME)
   (%CONTROL-FRAME.INHERITED-PATTERN-RECORD FRAME)))

;;; (DEFUN (CREATE-DOWN-FRAME CONTROL-FRAME) ...)

(CL:DEFUN CREATE-DOWN-FRAME (UPFRAME DOWNPROPOSITION)
  (CL:LET* ((DOWNFRAME (NEW-CONTROL-FRAME)))
   (CL:SETF (%CONTROL-FRAME.DOWN UPFRAME) DOWNFRAME)
   (CL:SETF (%CONTROL-FRAME.UP DOWNFRAME) UPFRAME)
   (CL:SETF (%CONTROL-FRAME.REVERSE-POLARITY? DOWNFRAME)
    (%CONTROL-FRAME.REVERSE-POLARITY? UPFRAME))
   (CL:SETF (%CONTROL-FRAME.PROPOSITION DOWNFRAME) DOWNPROPOSITION)
   (CL:SETF (%CONTROL-FRAME.DOWN DOWNFRAME) NULL)
   (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS DOWNFRAME)
    SYM-QUERY-LOGIC-BACK NULL NULL)
   (CL:SETF (%CONTROL-FRAME.PATTERN-RECORD DOWNFRAME) NULL)
   (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE DOWNFRAME) NULL)
   (CLEAR (%CONTROL-FRAME.JUSTIFICATIONS DOWNFRAME))
   (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS DOWNFRAME)
    SYM-QUERY-LOGIC-JUSTIFICATION NULL NULL)
   (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS DOWNFRAME)
    SYM-QUERY-LOGIC-GOAL-CACHE NULL NULL)
   (CL:SETF (%CONTROL-FRAME.GOAL-BINDINGS DOWNFRAME) NULL)
   (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS DOWNFRAME)
    SYM-QUERY-LOGIC-CACHED-BINDINGS-ITERATOR NULL NULL)
   (CL:WHEN (CL:NOT (CL:EQ DOWNPROPOSITION NULL))
    (CL:SETF (%CONTROL-FRAME.STATE DOWNFRAME)
     (%PROPOSITION.KIND DOWNPROPOSITION))
    (CL:WHEN (%CONTROL-FRAME.REVERSE-POLARITY? DOWNFRAME)
     (CL:LET* ((TEST-VALUE-000 (%CONTROL-FRAME.STATE DOWNFRAME)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-AND)
        (CL:SETF (%CONTROL-FRAME.STATE DOWNFRAME) KWD-QUERY-OR))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-OR)
        (CL:SETF (%CONTROL-FRAME.STATE DOWNFRAME) KWD-QUERY-AND))
       (CL:T))))
    (CL:SETF (%CONTROL-FRAME.ARGUMENT-CURSOR DOWNFRAME) 0))
   (CL:SETF (%CONTROL-FRAME.INHERITED-PATTERN-RECORD DOWNFRAME)
    (OPERATIVE-PATTERN-RECORD UPFRAME))
   DOWNFRAME))

;;; (DEFUN (SET-FRAME-TRUTH-VALUE TRUTH-VALUE) ...)

(CL:DEFUN SET-FRAME-TRUTH-VALUE (FRAME TRUTHVALUE)
  (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE FRAME)
   (CL:IF (%CONTROL-FRAME.REVERSE-POLARITY? FRAME)
    (INVERT-TRUTH-VALUE TRUTHVALUE) TRUTHVALUE)))

;;; (DEFUN (PROPAGATE-FRAME-TRUTH-VALUE TRUTH-VALUE) ...)

(CL:DEFUN PROPAGATE-FRAME-TRUTH-VALUE (SOURCE TARGET)
  (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE TARGET)
   (CL:IF
    (CL:NOT
     (CL:EQ (%CONTROL-FRAME.REVERSE-POLARITY? SOURCE)
      (%CONTROL-FRAME.REVERSE-POLARITY? TARGET)))
    (INVERT-TRUTH-VALUE (%CONTROL-FRAME.TRUTH-VALUE SOURCE))
    (%CONTROL-FRAME.TRUTH-VALUE SOURCE))))

;;; (DEFGLOBAL *CONTROL-FRAME-ID-COUNTER* ...)

(CL:DEFVAR *CONTROL-FRAME-ID-COUNTER* -1
  "Generates unique IDs for control frames.  Used only for debugging.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *CONTROL-FRAME-ID-COUNTER*))

;;; (DEFUN (DEBUG-FRAME-ID INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) DEBUG-FRAME-ID))
(CL:DEFUN DEBUG-FRAME-ID (FRAME)
  (CL:LET*
   ((ID
     (%INTEGER-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
       SYM-QUERY-LOGIC-DEBUG-FRAME-ID-INTERNAL NULL-INTEGER-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ID))
   (CL:WHEN (NULL? ID)
    (CL:SETQ *CONTROL-FRAME-ID-COUNTER*
     (CL:1+ *CONTROL-FRAME-ID-COUNTER*))
    (CL:SETQ ID *CONTROL-FRAME-ID-COUNTER*)
    (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
     SYM-QUERY-LOGIC-DEBUG-FRAME-ID-INTERNAL (WRAP-INTEGER ID)
     NULL-INTEGER-WRAPPER))
   ID))

;;; (DEFUN COPY-FRAME-STATE ...)

(CL:DEFUN COPY-FRAME-STATE (FROMFRAME TOFRAME)
  (CL:SETF (%CONTROL-FRAME.PROPOSITION TOFRAME)
   (%CONTROL-FRAME.PROPOSITION FROMFRAME))
  (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS TOFRAME)
   SYM-QUERY-LOGIC-DESCRIPTION
   (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FROMFRAME)
    SYM-QUERY-LOGIC-DESCRIPTION NULL)
   NULL)
  (CL:SETF (%CONTROL-FRAME.REVERSE-POLARITY? TOFRAME)
   (%CONTROL-FRAME.REVERSE-POLARITY? FROMFRAME))
  (CL:SETF (%CONTROL-FRAME.UP TOFRAME) (%CONTROL-FRAME.UP FROMFRAME))
  (CL:SETF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME TOFRAME)
   (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FROMFRAME))
  (CL:SETF (%CONTROL-FRAME.INHERITED-PATTERN-RECORD TOFRAME)
   (%CONTROL-FRAME.INHERITED-PATTERN-RECORD FROMFRAME))
  (CL:SETF (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET TOFRAME)
   (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET FROMFRAME))
  (CL:SETF (%CONTROL-FRAME.NEXT-STRATEGIES TOFRAME)
   (%CONTROL-FRAME.NEXT-STRATEGIES FROMFRAME))
  (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS TOFRAME)
   SYM-QUERY-LOGIC-CACHED-BINDINGS-ITERATOR
   (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FROMFRAME)
    SYM-QUERY-LOGIC-CACHED-BINDINGS-ITERATOR NULL)
   NULL)
  (CL:SETF (%CONTROL-FRAME.GOAL-BINDINGS TOFRAME)
   (%CONTROL-FRAME.GOAL-BINDINGS FROMFRAME))
  (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS TOFRAME)
   SYM-QUERY-LOGIC-GOAL-CACHE
   (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FROMFRAME)
    SYM-QUERY-LOGIC-GOAL-CACHE NULL)
   NULL))

;;; (DEFUN (PARALLELIZE-CONTROL-FRAME PARALLEL-CONTROL-FRAME) ...)

(CL:DEFUN PARALLELIZE-CONTROL-FRAME (FRAME)
  (CL:WHEN
   (CL:EQ (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-PARALLEL-STRATEGIES)
   (CL:RETURN-FROM PARALLELIZE-CONTROL-FRAME FRAME))
  (CL:LET* ((PARALLELPARENT (NEW-PARALLEL-CONTROL-FRAME)))
   (CL:SETF (%PARALLEL-CONTROL-FRAME.STATE PARALLELPARENT)
    KWD-QUERY-PARALLEL-STRATEGIES)
   (COPY-FRAME-STATE FRAME PARALLELPARENT)
   (CL:SETF (%CONTROL-FRAME.DOWN (%CONTROL-FRAME.UP FRAME))
    PARALLELPARENT)
   (CL:SETF (%CONTROL-FRAME.NEXT-STRATEGIES FRAME) NIL)
   (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
    SYM-QUERY-LOGIC-CACHED-BINDINGS-ITERATOR NULL NULL)
   (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
    SYM-QUERY-LOGIC-GOAL-CACHE NULL NULL)
   (CL:SETF (%PARALLEL-CONTROL-FRAME.UNBOUND-VARIABLES? PARALLELPARENT)
    (CL:NOT
     (ALL-ARGUMENTS-BOUND?
      (%PARALLEL-CONTROL-FRAME.PROPOSITION PARALLELPARENT))))
   (CL:WHEN
    (CL:OR (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
        SYM-QUERY-STELLA-ITERATOR NULL)
       NULL)))
    (CL:LET* ((CHILDTHREAD (NEW-PARALLEL-THREAD)))
     (CL:SETF (%CONTROL-FRAME.UP FRAME) PARALLELPARENT)
     (CL:SETF (%PARALLEL-THREAD.TOP-CONTROL-FRAME CHILDTHREAD) FRAME)
     (INSERT (%PARALLEL-CONTROL-FRAME.CHILD-THREADS PARALLELPARENT)
      CHILDTHREAD)
     (CL:WHEN
      (%PARALLEL-CONTROL-FRAME.UNBOUND-VARIABLES? PARALLELPARENT)
      (CL:LET*
       ((PATTERNRECORD
         (%CONTROL-FRAME.INHERITED-PATTERN-RECORD FRAME)))
       (CL:SETF (%PARALLEL-THREAD.VARIABLE-BINDINGS CHILDTHREAD)
        (COPY (%PATTERN-RECORD.VARIABLE-BINDINGS PATTERNRECORD)))
       (CL:SETF (%PARALLEL-THREAD.UNBINDING-STACK CHILDTHREAD)
        (COPY (%PATTERN-RECORD.UNBINDING-STACK PATTERNRECORD)))
       (CL:SETF
        (%PARALLEL-THREAD.TOP-UNBINDING-STACK-OFFSET CHILDTHREAD)
        (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))))))
   (CL:WHEN
    (CL:EQ (%QUERY-ITERATOR.CURRENT-CONTROL-FRAME *QUERYITERATOR*)
     FRAME)
    (CL:SETF (%QUERY-ITERATOR.CURRENT-CONTROL-FRAME *QUERYITERATOR*)
     PARALLELPARENT))
   PARALLELPARENT))

;;; (DEFUN ENTER-PARALLEL-THREAD ...)

(CL:DEFUN ENTER-PARALLEL-THREAD (PFRAME CHILDTHREAD)
  (CL:IF (CL:NOT (CL:EQ CHILDTHREAD NULL))
   (CL:PROGN
    (CL:SETF (%PARALLEL-CONTROL-FRAME.CURRENT-CHILD-THREAD PFRAME)
     CHILDTHREAD)
    (CL:SETF (%PARALLEL-CONTROL-FRAME.DOWN PFRAME)
     (%PARALLEL-THREAD.TOP-CONTROL-FRAME CHILDTHREAD)))
   (CL:SETQ CHILDTHREAD
    (%PARALLEL-CONTROL-FRAME.CURRENT-CHILD-THREAD PFRAME)))
  (CL:SETF
   (%PARALLEL-CONTROL-FRAME.SAVED-PARENT-PARALLEL-THREAD PFRAME)
   (%QUERY-ITERATOR.CURRENT-PARALLEL-THREAD *QUERYITERATOR*))
  (CL:SETF (%QUERY-ITERATOR.CURRENT-PARALLEL-THREAD *QUERYITERATOR*)
   CHILDTHREAD)
  (CL:SETF (%PARALLEL-CONTROL-FRAME.SAVED-PARENT-CONTEXT PFRAME)
   *CONTEXT*)
  (CL:WHEN
   (CL:NOT
    (CL:EQ (%PARALLEL-THREAD.HYPOTHETICAL-WORLD CHILDTHREAD) NULL))
   (CHANGE-CONTEXT (%PARALLEL-THREAD.HYPOTHETICAL-WORLD CHILDTHREAD))))

;;; (DEFUN EXIT-PARALLEL-THREAD ...)

(CL:DEFUN EXIT-PARALLEL-THREAD (PFRAME)
  (CL:SETF (%QUERY-ITERATOR.CURRENT-PARALLEL-THREAD *QUERYITERATOR*)
   (%PARALLEL-CONTROL-FRAME.SAVED-PARENT-PARALLEL-THREAD PFRAME))
  (CL:WHEN
   (CL:NOT
    (CL:EQ (%PARALLEL-CONTROL-FRAME.SAVED-PARENT-CONTEXT PFRAME) NULL))
   (CL:IF
    (CL:AND (CL:EQ (%PARALLEL-CONTROL-FRAME.DOWN PFRAME) NULL)
     (CL:NOT
      (CL:EQ
       (%PARALLEL-THREAD.HYPOTHETICAL-WORLD
        (%PARALLEL-CONTROL-FRAME.CURRENT-CHILD-THREAD PFRAME))
       NULL)))
    (CL:PROGN (POP-WORLD))
    (CHANGE-CONTEXT
     (%PARALLEL-CONTROL-FRAME.SAVED-PARENT-CONTEXT PFRAME)))
   (CL:SETF (%PARALLEL-CONTROL-FRAME.SAVED-PARENT-CONTEXT PFRAME) NULL))
  (CL:WHEN (CL:EQ (%PARALLEL-CONTROL-FRAME.DOWN PFRAME) NULL)
   (REMOVE (%PARALLEL-CONTROL-FRAME.CHILD-THREADS PFRAME)
    (%PARALLEL-CONTROL-FRAME.CURRENT-CHILD-THREAD PFRAME))
   (CL:SETF (%PARALLEL-CONTROL-FRAME.CURRENT-CHILD-THREAD PFRAME) NULL)))

;;; (DEFUN (ENTER-HYPOTHETICAL-WORLD WORLD) ...)

(CL:DEFUN ENTER-HYPOTHETICAL-WORLD (PFRAME)
  (CL:LET*
   ((CHILDTHREAD (%PARALLEL-CONTROL-FRAME.CURRENT-CHILD-THREAD PFRAME))
    (WORLD (%PARALLEL-THREAD.HYPOTHETICAL-WORLD CHILDTHREAD)))
   (CL:IF (CL:EQ WORLD NULL)
    (CL:PROGN
     (CL:SETF (%PARALLEL-THREAD.HYPOTHETICAL-WORLD CHILDTHREAD)
      (PUSH-MONOTONIC-WORLD))
     (INITIALIZE-INFERENCE-WORLD *CONTEXT*))
    NULL)
   WORLD))

;;; (DEFUN (PARTIAL-MATCH-MODE? BOOLEAN) ...)

(CL:DEFUN PARTIAL-MATCH-MODE? ()
  (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
   (CL:NOT
    (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
     NULL))))

;;; (DEFUN (EXECUTE-BACKWARD-CHAINING-PROOF? BOOLEAN) ...)

(CL:DEFUN EXECUTE-BACKWARD-CHAINING-PROOF? (QUERY)
  (CL:WHEN
   (CL:EQ
    (%CONTROL-FRAME.DOWN (%QUERY-ITERATOR.BASE-CONTROL-FRAME QUERY))
    NULL)
   (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? CL:NIL))
  (CL:LET* ((*QUERYITERATOR* QUERY))
   (CL:DECLARE (CL:SPECIAL *QUERYITERATOR*))
   (CL:LET*
    ((FRAME (%QUERY-ITERATOR.BASE-CONTROL-FRAME QUERY)) (DEPTH 0)
     (LASTMOVE KWD-QUERY-DOWN) (RESULTOFNEXTMOVE NULL)
     (CLOCKTICKS (%QUERY-ITERATOR.CURRENT-CLOCK-TICKS QUERY))
     (STARTTIME (GET-TICKTOCK)) (STARTTICKS CLOCKTICKS)
     (ALLOTTEDTIME (%QUERY-ITERATOR.ALLOTTED-TIME QUERY))
     (ALLOTTEDTICKS (%QUERY-ITERATOR.ALLOTTED-CLOCK-TICKS QUERY))
     (CHECKFORTIMEOUT? (CL:NOT (CL:= ALLOTTEDTIME NULL-FLOAT)))
     (CHECKFORMOVEOUT? (DEFINED? ALLOTTEDTICKS))
     (TRACESUBGOALS? (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE))
     (TIMEOUT? CL:NIL) (SUCCESS? CL:NIL))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM DEPTH CLOCKTICKS STARTTICKS ALLOTTEDTICKS)
     (CL:TYPE CL:DOUBLE-FLOAT ALLOTTEDTIME))
    (CL:SETF (%QUERY-ITERATOR.TIMEOUT? QUERY) CL:NIL)
    (CL:SETF (%CONTROL-FRAME.STARTING-CLOCK-TICKS FRAME) CLOCKTICKS)
    (CL:WHEN CHECKFORMOVEOUT?
     (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME)
      ALLOTTEDTICKS))
    (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE FRAME) NULL)
    (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
     SYM-QUERY-LOGIC-JUSTIFICATION NULL NULL)
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT
       (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
        NULL)))
     (CL:SETF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)
      (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY QUERY))
     (CLEAR-FRAME-PARTIAL-TRUTH
      (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))
    (CL:SETQ LASTMOVE KWD-QUERY-DOWN)
    (CL:LOOP
     (CL:SETF (%QUERY-ITERATOR.CURRENT-CONTROL-FRAME QUERY) FRAME)
     (CL:WHEN TRACESUBGOALS?
      (CL:COND
       ((CL:OR (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
         (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
        (TRACE-GOAL-TREE (%CONTROL-FRAME.RESULT FRAME) DEPTH LASTMOVE))
       (CL:T (TRACE-GOAL-TREE FRAME DEPTH LASTMOVE))))
     (CL:WHEN
      (CL:AND CHECKFORTIMEOUT?
       (CL:= (CL:THE CL:FIXNUM (CL:LOGAND CLOCKTICKS 15)) 0))
      (CL:LET*
       ((CURRENTTIME (GET-TICKTOCK))
        (DIFFERENCE (TICKTOCK-DIFFERENCE STARTTIME CURRENTTIME)))
       (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT DIFFERENCE))
       (CL:WHEN (CL:>= DIFFERENCE 0.02d0)
        (CL:SETQ ALLOTTEDTIME (CL:- ALLOTTEDTIME DIFFERENCE))
        (CL:SETQ STARTTIME CURRENTTIME))
       (CL:WHEN (CL:<= ALLOTTEDTIME 0.0d0) (CL:SETQ TIMEOUT? CL:T))))
     (CL:SETQ RESULTOFNEXTMOVE
      (EVALUATE-NEXT-MOVE FRAME LASTMOVE CLOCKTICKS))
     (CL:SETQ FRAME (%QUERY-ITERATOR.CURRENT-CONTROL-FRAME QUERY))
     (CL:COND
      ((CL:EQ RESULTOFNEXTMOVE KWD-QUERY-MOVE-DOWN)
       (CL:LET*
        ((UPFRAME FRAME) (DOWNFRAME (%CONTROL-FRAME.DOWN FRAME)))
        (CL:SETQ DEPTH (CL:1+ DEPTH))
        (CL:SETF (%QUERY-ITERATOR.CURRENT-CLOCK-TICKS QUERY)
         (CL:SETQ CLOCKTICKS (CL:1+ CLOCKTICKS)))
        (CL:COND
         ((CL:NOT (CL:EQ DOWNFRAME NULL)) (CL:SETQ FRAME DOWNFRAME)
          (CL:SETF (%CONTROL-FRAME.STARTING-CLOCK-TICKS FRAME)
           CLOCKTICKS)
          (CL:WHEN
           (CL:AND CHECKFORMOVEOUT?
            (NULL? (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME)))
           (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME)
            (CL:1- (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS UPFRAME))))
          (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE FRAME) NULL)
          (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
           SYM-QUERY-LOGIC-JUSTIFICATION NULL NULL)
          (CL:WHEN
           (CL:NOT
            (CL:EQ (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME) NULL))
           (CLEAR-FRAME-PARTIAL-TRUTH
            (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))
          (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
         (CL:T
          (CL:LET*
           ((PROPOSITION
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%VECTOR.THE-ARRAY
                (%PROPOSITION.ARGUMENTS
                 (%CONTROL-FRAME.PROPOSITION UPFRAME))))
              (CL:THE CL:FIXNUM
               (%CONTROL-FRAME.ARGUMENT-CURSOR UPFRAME)))))
           (CL:SETQ DOWNFRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
           (CL:SETQ FRAME DOWNFRAME)
           (CL:SETF (%CONTROL-FRAME.STARTING-CLOCK-TICKS FRAME)
            CLOCKTICKS)
           (CL:WHEN CHECKFORMOVEOUT?
            (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME)
             (CL:1- (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS UPFRAME))))
           (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))
        (CL:WHEN
         (CL:AND
          (CL:> DEPTH (%QUERY-ITERATOR.CURRENT-DEPTH-CUTOFF QUERY))
          (CL:EQ (%CONTROL-FRAME.STATE UPFRAME) KWD-QUERY-PATTERN))
         (POP-FRAMES-UP-TO FRAME)
         (CL:MULTIPLE-VALUE-SETQ (FRAME DEPTH)
          (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
         (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
        (CL:WHEN CHECKFORMOVEOUT?
         (CL:WHEN
          (CL:AND (CL:<= (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME) 0)
           (CL:NOT (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)))
          (POP-FRAMES-UP-TO FRAME)
          (CL:MULTIPLE-VALUE-SETQ (FRAME DEPTH)
           (HANDLE-TIMEOUT FRAME DEPTH))
          (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
         (CL:WHEN (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
          (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME)
           (CL:- (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME)
            (CL:1+
             (CL:- CLOCKTICKS
              (%CONTROL-FRAME.STARTING-CLOCK-TICKS DOWNFRAME))))))))
       (CL:WHEN (CL:AND TIMEOUT? (CL:EQ LASTMOVE KWD-QUERY-DOWN))
        (CL:SETQ SUCCESS? CL:NIL) (CL:RETURN)))
      ((CL:EQ RESULTOFNEXTMOVE KWD-QUERY-FINAL-SUCCESS)
       (CL:LET* ((PARENT (%CONTROL-FRAME.UP FRAME)))
        (CL:WHEN (CL:NOT (CL:EQ PARENT NULL))
         (CL:SETF (%CONTROL-FRAME.RESULT PARENT) FRAME)
         (CL:IF
          (CL:AND
           (CL:OR *CACHE-SUCCEEDED-GOALS?* *CACHE-FAILED-GOALS?*)
           (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY*
            KWD-QUERY-DUPLICATE-GOALS)
           (CL:NOT
            (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
             (CL:NOT
              (CL:EQ
               (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
               NULL)))))
          (CACHE-GOAL FRAME CL:T CL:NIL CLOCKTICKS)
          (UPDATE-GOAL-CACHE FRAME CL:T)))
        (CL:SETQ DEPTH (CL:1- DEPTH))
        (CL:WHEN CHECKFORMOVEOUT?
         (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME)
          NULL-INTEGER)
         (CL:WHEN (CL:NOT (CL:EQ PARENT NULL))
          (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS PARENT)
           (CL:- (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS PARENT)
            (CL:- CLOCKTICKS
             (%CONTROL-FRAME.STARTING-CLOCK-TICKS FRAME))
            1))))
        (CL:SETQ FRAME PARENT)
        (CL:WHEN (CL:EQ FRAME NULL) (CL:SETQ SUCCESS? CL:T)
         (CL:RETURN))
        (POP-DOWN-FRAME FRAME) (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))
      ((CL:EQ RESULTOFNEXTMOVE KWD-QUERY-CONTINUING-SUCCESS)
       (CL:LET* ((PARENT (%CONTROL-FRAME.UP FRAME)))
        (CL:WHEN (CL:NOT (CL:EQ PARENT NULL))
         (CL:SETF (%CONTROL-FRAME.RESULT PARENT) FRAME)
         (CL:IF
          (CL:AND
           (CL:OR *CACHE-SUCCEEDED-GOALS?* *CACHE-FAILED-GOALS?*)
           (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY*
            KWD-QUERY-DUPLICATE-GOALS)
           (CL:NOT
            (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
             (CL:NOT
              (CL:EQ
               (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
               NULL)))))
          (CACHE-GOAL FRAME CL:T CL:T CLOCKTICKS)
          (UPDATE-GOAL-CACHE FRAME CL:T)))
        (CL:SETQ DEPTH (CL:1- DEPTH))
        (CL:WHEN CHECKFORMOVEOUT?
         (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME)
          NULL-INTEGER)
         (CL:WHEN (CL:NOT (CL:EQ PARENT NULL))
          (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS PARENT)
           (CL:- (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS PARENT)
            (CL:- CLOCKTICKS
             (%CONTROL-FRAME.STARTING-CLOCK-TICKS FRAME))
            1))))
        (CL:SETQ FRAME PARENT)
        (CL:WHEN (CL:EQ FRAME NULL) (CL:SETQ SUCCESS? CL:T)
         (CL:RETURN))
        (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))
      ((CL:EQ RESULTOFNEXTMOVE KWD-QUERY-FAILURE)
       (CL:LET* ((PARENT (%CONTROL-FRAME.UP FRAME)))
        (CL:WHEN (CL:NOT (CL:EQ PARENT NULL))
         (CL:SETF (%CONTROL-FRAME.RESULT PARENT) FRAME)
         (CL:IF
          (CL:AND
           (CL:OR *CACHE-SUCCEEDED-GOALS?* *CACHE-FAILED-GOALS?*)
           (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY*
            KWD-QUERY-DUPLICATE-GOALS)
           (CL:NOT
            (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
             (CL:NOT
              (CL:EQ
               (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
               NULL)))))
          (CACHE-GOAL FRAME CL:NIL CL:NIL CLOCKTICKS)
          (UPDATE-GOAL-CACHE FRAME CL:NIL)))
        (CL:SETQ DEPTH (CL:1- DEPTH))
        (CL:WHEN CHECKFORMOVEOUT?
         (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME)
          NULL-INTEGER)
         (CL:WHEN (CL:NOT (CL:EQ PARENT NULL))
          (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS PARENT)
           (CL:- (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS PARENT)
            (CL:- CLOCKTICKS
             (%CONTROL-FRAME.STARTING-CLOCK-TICKS FRAME))
            1))))
        (CL:SETQ FRAME PARENT)
        (CL:WHEN (CL:EQ FRAME NULL) (CL:SETQ SUCCESS? CL:NIL)
         (CL:RETURN))
        (POP-DOWN-FRAME FRAME) (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
      ((CL:EQ RESULTOFNEXTMOVE KWD-QUERY-MOVE-IN-PLACE)
       (CL:PROGN (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE FRAME) NULL)
        (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
         SYM-QUERY-LOGIC-JUSTIFICATION NULL NULL)
        (CL:WHEN
         (CL:NOT
          (CL:EQ (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME) NULL))
         (CLEAR-FRAME-PARTIAL-TRUTH
          (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))
        (CL:SETQ LASTMOVE KWD-QUERY-DOWN)
        (CL:COND
         (CHECKFORMOVEOUT?
          (CL:LET*
           ((PARENT (%CONTROL-FRAME.UP FRAME))
            (STARTTICKS (%CONTROL-FRAME.STARTING-CLOCK-TICKS FRAME))
            (AVAILABLETICKS
             (CL:- (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS PARENT)
              (CL:- CLOCKTICKS STARTTICKS) 1)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM STARTTICKS AVAILABLETICKS))
           (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS PARENT)
            AVAILABLETICKS)
           (CL:SETQ AVAILABLETICKS (CL:1- AVAILABLETICKS))
           (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME)
            AVAILABLETICKS)
           (CL:SETF (%QUERY-ITERATOR.CURRENT-CLOCK-TICKS QUERY)
            (CL:SETQ CLOCKTICKS (CL:1+ CLOCKTICKS)))
           (CL:SETF (%CONTROL-FRAME.STARTING-CLOCK-TICKS FRAME)
            CLOCKTICKS)
           (CL:WHEN (CL:<= AVAILABLETICKS 0) (POP-FRAMES-UP-TO FRAME)
            (CL:MULTIPLE-VALUE-SETQ (FRAME DEPTH)
             (HANDLE-TIMEOUT FRAME DEPTH))
            (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)
            (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME)
             (CL:- (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME)
              (CL:1+ (CL:- CLOCKTICKS STARTTICKS)))))))
         (CL:T
          (CL:SETF (%QUERY-ITERATOR.CURRENT-CLOCK-TICKS QUERY)
           (CL:SETQ CLOCKTICKS (CL:1+ CLOCKTICKS)))
          (CL:SETF (%CONTROL-FRAME.STARTING-CLOCK-TICKS FRAME)
           CLOCKTICKS)))))
      ((CL:EQ RESULTOFNEXTMOVE KWD-QUERY-TIMEOUT)
       (CL:LET* ((PARENT (%CONTROL-FRAME.UP FRAME)))
        (CL:WHEN (CL:NOT (CL:EQ PARENT NULL))
         (CL:SETF (%CONTROL-FRAME.RESULT PARENT) FRAME)
         (CL:IF
          (CL:AND
           (CL:OR *CACHE-SUCCEEDED-GOALS?* *CACHE-FAILED-GOALS?*)
           (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY*
            KWD-QUERY-DUPLICATE-GOALS)
           (CL:NOT
            (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
             (CL:NOT
              (CL:EQ
               (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
               NULL)))))
          (CACHE-GOAL FRAME CL:NIL CL:T CLOCKTICKS)
          (UPDATE-GOAL-CACHE FRAME CL:NIL)))
        (CL:SETQ DEPTH (CL:1- DEPTH))
        (CL:WHEN CHECKFORMOVEOUT?
         (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS FRAME)
          NULL-INTEGER)
         (CL:WHEN (CL:NOT (CL:EQ PARENT NULL))
          (CL:SETF (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS PARENT)
           (CL:- (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS PARENT)
            (CL:- CLOCKTICKS
             (%CONTROL-FRAME.STARTING-CLOCK-TICKS FRAME))
            1))))
        (CL:SETQ FRAME PARENT)
        (CL:WHEN (CL:EQ FRAME NULL) (CL:SETQ SUCCESS? CL:NIL)
         (CL:RETURN))
        (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
         RESULTOFNEXTMOVE "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (CL:SETF (%QUERY-ITERATOR.ALLOTTED-TIME QUERY) ALLOTTEDTIME)
    (CL:SETF (%QUERY-ITERATOR.TIMEOUT? QUERY) TIMEOUT?)
    (CL:WHEN CHECKFORMOVEOUT?
     (CL:SETF (%QUERY-ITERATOR.ALLOTTED-CLOCK-TICKS QUERY)
      (MAX (CL:- ALLOTTEDTICKS (CL:- CLOCKTICKS STARTTICKS)) 0))
     (CL:WHEN (CL:NOT TIMEOUT?)
      (CL:SETF (%QUERY-ITERATOR.TIMEOUT? QUERY)
       (CL:= (%QUERY-ITERATOR.ALLOTTED-CLOCK-TICKS QUERY) 0))))
    SUCCESS?)))

;;; (DEFUN (EVALUATE-NEXT-MOVE KEYWORD) ...)

(CL:DEFUN EVALUATE-NEXT-MOVE (FRAME LASTMOVE CLOCKTICKS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM CLOCKTICKS))
  #+MCL
  (CL:CHECK-TYPE CLOCKTICKS CL:FIXNUM)
  (CL:LET* ((TEST-VALUE-000 (%CONTROL-FRAME.STATE FRAME)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-AND)
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT
        (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
         NULL)))
      (CONTINUE-PARTIAL-AND-PROOF FRAME FRAME LASTMOVE)
      (CONTINUE-AND-PROOF FRAME LASTMOVE)))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-OR)
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT
        (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
         NULL)))
      (CONTINUE-PARTIAL-OR-PROOF FRAME LASTMOVE)
      (CONTINUE-OR-PROOF FRAME LASTMOVE)))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-NOT)
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT
        (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
         NULL)))
      (CONTINUE-PARTIAL-NOT-PROOF FRAME LASTMOVE)
      (CONTINUE-NOT-PROOF FRAME LASTMOVE)))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-QUERY-ISA)
      (CL:EQ TEST-VALUE-000 KWD-QUERY-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-QUERY-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-QUERY-EQUIVALENT)
      (CL:EQ TEST-VALUE-000 KWD-QUERY-IMPLIES))
     (CREATE-CHOICE-POINT FRAME) (INITIATE-ATOMIC-GOAL-PROOFS FRAME))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-QUERY-ATOMIC-GOAL)
      (CL:EQ TEST-VALUE-000 KWD-QUERY-STRATEGY))
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT
        (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
         NULL)))
      (CONTINUE-PARTIAL-STRATEGIES-PROOFS FRAME LASTMOVE)
      (CONTINUE-STRATEGIES-PROOFS FRAME LASTMOVE)))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-SCAN-CACHED-BINDINGS)
     (CONTINUE-CACHED-BINDINGS-PROOF FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-PATTERN)
     (CONTINUE-PATTERN-PROOF FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-FORALL)
     (CONTINUE-FORALL-PROOF FRAME LASTMOVE))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-QUERY-CONTAINED-BY)
      (CL:EQ TEST-VALUE-000 KWD-QUERY-ITERATIVE-FORALL))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT
        (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
         NULL)))
      (CL:SETQ LASTMOVE
       (INTERPRET-ITERATIVE-FORALL-SCORES FRAME LASTMOVE)))
     (CONTINUE-CONTAINED-BY-PROOF FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-EXISTS)
     (CONTINUE-EXISTS-PROOF FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-CONSTANT)
     (CONTINUE-CONSTANT-PROOF FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-FAIL)
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT
        (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
         NULL)))
      (CONTINUE-PARTIAL-FAIL-PROOF FRAME LASTMOVE)
      (CONTINUE-FAIL-PROOF FRAME LASTMOVE)))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-PARALLEL-STRATEGIES)
     (CONTINUE-PARALLEL-STRATEGIES-PROOFS FRAME LASTMOVE))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "Error.  No query state implemented for operator `"
       (%CONTROL-FRAME.STATE FRAME) "'" EOL)
      (CL:ERROR (NEW-FAIL-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFMETHOD (CLUSTERED-CONJUNCTION? BOOLEAN) ...)

(CL:DEFMETHOD CLUSTERED-CONJUNCTION? ((SELF PROPOSITION))
  (CL:LET* ((FOUND?-000 CL:NIL))
   (CL:LET*
    ((CONJUNCT NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ CONJUNCT
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:WHEN (CL:EQ (%PROPOSITION.KIND CONJUNCT) KWD-QUERY-AND)
      (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000)))

;;; (DEFUN (CONTINUE-AND-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-AND-PROOF (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME)) (CONJUNCTS NULL))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
     (CL:COND
      ((CLUSTERED-CONJUNCTION? PROPOSITION)
       (OVERLAY-WITH-STRATEGY-FRAME FRAME
        KWD-QUERY-CLUSTERED-CONJUNCTION)
       KWD-QUERY-MOVE-IN-PLACE)
      ((CL:AND (%CONTROL-FRAME.REVERSE-POLARITY? FRAME)
        (CLOSED-PROPOSITION? PROPOSITION))
       (OVERLAY-WITH-FAIL-FRAME FRAME PROPOSITION))
      (CL:T
       (CL:SETQ CONJUNCTS
        (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
         SYM-QUERY-STELLA-ARGUMENTS NULL))
       (CL:WHEN (CL:EQ CONJUNCTS NULL)
        (CL:SETQ CONJUNCTS
         (NEW-VECTOR (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION))))
        (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
         SYM-QUERY-STELLA-ARGUMENTS CONJUNCTS NULL)
        (CL:WHEN (DYNAMICALLY-OPTIMIZE-PROPOSITION? PROPOSITION)
         (CL:SETQ PROPOSITION (SHALLOW-COPY-PROPOSITION PROPOSITION))
         (CL:SETF (%CONTROL-FRAME.PROPOSITION FRAME) PROPOSITION)))
       (CL:WHEN
        (CL:AND (DYNAMICALLY-OPTIMIZE-PROPOSITION? PROPOSITION)
         (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
        (DYNAMICALLY-REOPTIMIZE-ARGUMENTS
         (%PROPOSITION.ARGUMENTS PROPOSITION)
         (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)))
       KWD-QUERY-MOVE-DOWN)))
    ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:SETQ CONJUNCTS
      (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
       SYM-QUERY-STELLA-ARGUMENTS NULL))
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY CONJUNCTS))
       (VALUE (%CONTROL-FRAME.RESULT FRAME))
       (POSITION (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:COND
      ((CL:= (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)
        (CL:1- (LENGTH CONJUNCTS)))
       (CL:SETF (%CONTROL-FRAME.DOWN FRAME) NULL)
       (CL:LET*
        ((CONJUNCT NULL) (VECTOR-000 CONJUNCTS) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER)
         (ITER-000 0))
        (CL:DECLARE
         (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ CONJUNCT
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ I ITER-000)
         (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE FRAME)
          (CL:IF (CL:= I 0) (%CONTROL-FRAME.TRUTH-VALUE CONJUNCT)
           (CONJOIN-TRUTH-VALUES (%CONTROL-FRAME.TRUTH-VALUE FRAME)
            (%CONTROL-FRAME.TRUTH-VALUE CONJUNCT))))
         (CL:WHEN
          (CL:NOT
           (CL:EQ (%CONTROL-FRAME.STATE CONJUNCT) KWD-QUERY-POPPED))
          (CL:SETF (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME) I)
          (CL:SETF (%CONTROL-FRAME.DOWN FRAME) CONJUNCT))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
         (CL:SETQ ITER-000 (CL:1+ ITER-000))))
       (CL:WHEN *RECORD-JUSTIFICATIONS?*
        (RECORD-AND-INTRODUCTION-JUSTIFICATION FRAME LASTMOVE))
       (CL:IF (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
        KWD-QUERY-CONTINUING-SUCCESS KWD-QUERY-FINAL-SUCCESS))
      (CL:T (CL:SETF (%CONTROL-FRAME.DOWN FRAME) NULL)
       (CL:SETF (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)
        (CL:1+ (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)))
       (CL:WHEN (DYNAMICALLY-OPTIMIZE-PROPOSITION? PROPOSITION)
        (DYNAMICALLY-REOPTIMIZE-ARGUMENTS
         (%PROPOSITION.ARGUMENTS PROPOSITION)
         (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)))
       KWD-QUERY-MOVE-DOWN)))
    ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
     (CL:SETQ CONJUNCTS
      (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
       SYM-QUERY-STELLA-ARGUMENTS NULL))
     (CL:WHEN (CL:EQ CONJUNCTS NULL)
      (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE FRAME)
       (CONJOIN-TRUTH-VALUES UNKNOWN-TRUTH-VALUE
        (%CONTROL-FRAME.TRUTH-VALUE (%CONTROL-FRAME.RESULT FRAME))))
      (CL:RETURN-FROM CONTINUE-AND-PROOF KWD-QUERY-FAILURE))
     (CL:SETF (%CONTROL-FRAME.DOWN FRAME) NULL)
     (CL:LET*
      ((CONJUNCT NULL) (VECTOR-001 CONJUNCTS) (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)) (I NULL-INTEGER) (ITER-001 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 I ITER-001))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:SETQ CONJUNCT
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:SETQ I ITER-001) (CL:WHEN (CL:EQ CONJUNCT NULL) (CL:RETURN))
       (CL:WHEN
        (CL:NOT
         (CL:EQ (%CONTROL-FRAME.STATE CONJUNCT) KWD-QUERY-POPPED))
        (CL:SETF (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME) I)
        (CL:SETF (%CONTROL-FRAME.DOWN FRAME) CONJUNCT))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
       (CL:SETQ ITER-001 (CL:1+ ITER-001))))
     (CL:COND
      ((CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
       KWD-QUERY-MOVE-DOWN)
      (CL:T
       (PROPAGATE-FRAME-TRUTH-VALUE (%CONTROL-FRAME.RESULT FRAME)
        FRAME)
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY CONJUNCTS))
         (VALUE (%CONTROL-FRAME.RESULT FRAME))
         (POSITION (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:LET*
        ((CONJUNCT NULL) (VECTOR-002 CONJUNCTS) (INDEX-002 0)
         (LENGTH-002 (LENGTH VECTOR-002)) (I NULL-INTEGER) (ITER-002 0)
         (UPPER-BOUND-000 (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME))
         (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
        (CL:DECLARE
         (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002 I ITER-002
          UPPER-BOUND-000))
        (CL:LOOP WHILE
         (CL:AND (CL:< INDEX-002 LENGTH-002)
          (CL:OR UNBOUNDED?-000 (CL:<= ITER-002 UPPER-BOUND-000)))
         DO
         (CL:SETQ CONJUNCT
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
           INDEX-002))
         (CL:SETQ I ITER-002) (CL:SETQ I I)
         (CL:WHEN (CL:EQ CONJUNCT NULL) (CL:RETURN))
         (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE FRAME)
          (CONJOIN-TRUTH-VALUES (%CONTROL-FRAME.TRUTH-VALUE FRAME)
           (%CONTROL-FRAME.TRUTH-VALUE CONJUNCT)))
         (CL:SETQ INDEX-002 (CL:1+ INDEX-002))
         (CL:SETQ ITER-002 (CL:1+ ITER-002))))
       KWD-QUERY-FAILURE)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" LASTMOVE "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (CONTINUE-OR-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-OR-PROOF (FRAME LASTMOVE)
  (CL:LET* ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
     (CL:WHEN
      (CL:AND (%CONTROL-FRAME.REVERSE-POLARITY? FRAME)
       (CLOSED-PROPOSITION? PROPOSITION))
      (CL:RETURN-FROM CONTINUE-OR-PROOF
       (OVERLAY-WITH-FAIL-FRAME FRAME PROPOSITION)))
     (CREATE-CHOICE-POINT FRAME) KWD-QUERY-MOVE-DOWN)
    ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE FRAME)
      (%CONTROL-FRAME.TRUTH-VALUE (%CONTROL-FRAME.RESULT FRAME)))
     (CL:WHEN *RECORD-JUSTIFICATIONS?*
      (RECORD-OR-INTRODUCTION-JUSTIFICATION FRAME LASTMOVE))
     (CL:WHEN (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL)
      (CL:SETF (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)
       (CL:1+ (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME))))
     (CL:COND
      ((CL:OR
        (CL:>= (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)
         (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION)))
        (CL:AND (CL:NOT (NEW-BINDINGS-SINCE-LAST-CHOICE-POINT? FRAME))
         (CL:NOT *GENERATE-ALL-PROOFS?*)))
       (CL:WHEN (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
        (POP-FRAMES-UP-TO (%CONTROL-FRAME.DOWN FRAME)))
       KWD-QUERY-FINAL-SUCCESS)
      (CL:T KWD-QUERY-CONTINUING-SUCCESS)))
    ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
     (CL:LET* ((CHOOSE-VALUE-000 NULL))
      (CL:IF (CL:EQ (%CONTROL-FRAME.TRUTH-VALUE FRAME) NULL)
       (CL:LET*
        ((TEMP-000
          (%CONTROL-FRAME.TRUTH-VALUE (%CONTROL-FRAME.RESULT FRAME))))
        (CL:SETQ CHOOSE-VALUE-000
         (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000
          UNKNOWN-TRUTH-VALUE)))
       (CL:SETQ CHOOSE-VALUE-000
        (DISJOIN-TRUTH-VALUES (%CONTROL-FRAME.TRUTH-VALUE FRAME)
         (%CONTROL-FRAME.TRUTH-VALUE (%CONTROL-FRAME.RESULT FRAME)))))
      (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE FRAME) CHOOSE-VALUE-000))
     (CL:SETF (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)
      (CL:1+ (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)))
     (CL:IF
      (CL:< (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)
       (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION)))
      (CL:PROGN (CREATE-CHOICE-POINT FRAME) KWD-QUERY-MOVE-DOWN)
      (CL:COND
       ((CL:EQ
         (%NORMAL-INFERENCE-LEVEL.KEYWORD (CURRENT-INFERENCE-LEVEL))
         KWD-QUERY-REFUTATION)
        (OVERLAY-WITH-STRATEGY-FRAME FRAME
         KWD-QUERY-DISJUNCTIVE-IMPLICATION-INTRODUCTION)
        KWD-QUERY-MOVE-IN-PLACE)
       (CL:T KWD-QUERY-FAILURE))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" LASTMOVE "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (CONTINUE-NOT-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-NOT-PROOF (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:WHEN (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
     (CL:RETURN-FROM CONTINUE-NOT-PROOF KWD-QUERY-MOVE-DOWN))
    (CL:LET*
     ((ARGUMENT
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY
          (%PROPOSITION.ARGUMENTS (%CONTROL-FRAME.PROPOSITION FRAME))))
        0)))
     (CL:WHEN
      (CL:AND (CL:NOT (%CONTROL-FRAME.REVERSE-POLARITY? FRAME))
       (CLOSED-PROPOSITION? ARGUMENT))
      (CL:RETURN-FROM CONTINUE-NOT-PROOF
       (OVERLAY-WITH-FAIL-FRAME FRAME ARGUMENT)))
     (CREATE-DOWN-FRAME FRAME ARGUMENT)
     (CL:SETF
      (%CONTROL-FRAME.REVERSE-POLARITY? (%CONTROL-FRAME.DOWN FRAME))
      (CL:NOT (%CONTROL-FRAME.REVERSE-POLARITY? FRAME)))
     KWD-QUERY-MOVE-DOWN))
   ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
    (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE FRAME)
     (INVERT-TRUTH-VALUE
      (%CONTROL-FRAME.TRUTH-VALUE (%CONTROL-FRAME.RESULT FRAME))))
    (CL:WHEN *RECORD-JUSTIFICATIONS?*
     (RECORD-DISPROOF-JUSTIFICATION FRAME LASTMOVE))
    (CL:COND
     ((CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL) KWD-QUERY-FINAL-SUCCESS)
     (CL:T KWD-QUERY-CONTINUING-SUCCESS)))
   ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
    (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE FRAME)
     (INVERT-TRUTH-VALUE
      (%CONTROL-FRAME.TRUTH-VALUE (%CONTROL-FRAME.RESULT FRAME))))
    (CL:WHEN *RECORD-JUSTIFICATIONS?*
     (RECORD-DISPROOF-JUSTIFICATION FRAME LASTMOVE))
    KWD-QUERY-FAILURE)
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" LASTMOVE "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (OVERLAY-WITH-FAIL-FRAME KEYWORD) ...)

(CL:DEFUN OVERLAY-WITH-FAIL-FRAME (FRAME PROPOSITION)
  (CL:LET*
   ((FAILPROPOSITION (CREATE-PROPOSITION SYM-QUERY-LOGIC-FAIL 1)))
   (CL:LET
    ((SELF
      (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS FAILPROPOSITION)))
     (VALUE PROPOSITION) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%CONTROL-FRAME.PROPOSITION FRAME) FAILPROPOSITION)
   (CL:SETF (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-FAIL)
   (CL:SETF (%CONTROL-FRAME.REVERSE-POLARITY? FRAME) CL:NIL)
   KWD-QUERY-MOVE-IN-PLACE))

;;; (DEFSPECIAL *REVERSEPOLARITY?* ...)

(CL:DEFVAR *REVERSEPOLARITY?* CL:NIL
  "Signals atomic proposition provers that polarity is negative.")

;;; (DEFUN (OVERLAY-WITH-STRATEGY-FRAME KEYWORD) ...)

(CL:DEFUN OVERLAY-WITH-STRATEGY-FRAME (FRAME STRATEGY)
  (CL:SETF (%CONTROL-FRAME.NEXT-STRATEGIES FRAME) (CONS-LIST STRATEGY))
  (CL:SETF (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-STRATEGY)
  KWD-QUERY-MOVE-IN-PLACE)

;;; (DEFUN (CHECK-FOR-DUPLICATE-GOAL? BOOLEAN) ...)

(CL:DEFUN CHECK-FOR-DUPLICATE-GOAL? (FRAME)
  (CL:WHEN
   (CL:NOT
    (CL:OR
     (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
     (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY*
      KWD-QUERY-DUPLICATE-GOALS-WITH-CACHING)))
   (CL:RETURN-FROM CHECK-FOR-DUPLICATE-GOAL? CL:NIL))
  (CL:LET*
   ((OPERATOR
     (%PROPOSITION.OPERATOR (%CONTROL-FRAME.PROPOSITION FRAME)))
    (GOALBINDINGS (%CONTROL-FRAME.GOAL-BINDINGS FRAME))
    (PREVIOUSFRAME (%CONTROL-FRAME.UP FRAME)) (DUPLICATEFRAME NULL))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 1)
     (UPPER-BOUND-000 *DUPLICATE-GOAL-SEARCH-DEPTH*)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000) (CL:SETQ I I)
     (CL:WHEN (CL:EQ PREVIOUSFRAME NULL) (CL:RETURN))
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:SETQ TEST-VALUE-000
       (CL:NOT
        (CL:EQ (%CONTROL-FRAME.GOAL-BINDINGS PREVIOUSFRAME) NULL)))
      (CL:WHEN TEST-VALUE-000
       (CL:SETQ TEST-VALUE-000
        (CL:EQ OPERATOR
         (%PROPOSITION.OPERATOR
          (%CONTROL-FRAME.PROPOSITION PREVIOUSFRAME))))
       (CL:WHEN TEST-VALUE-000
        (CL:LET* ((ALWAYS?-000 CL:T))
         (CL:LET*
          ((B1 NULL) (ITER-001 GOALBINDINGS) (B2 NULL)
           (ITER-002 (%CONTROL-FRAME.GOAL-BINDINGS PREVIOUSFRAME)))
          (CL:LOOP WHILE
           (CL:AND (CL:NOT (CL:EQ ITER-001 NIL))
            (CL:NOT (CL:EQ ITER-002 NIL)))
           DO (CL:SETQ B1 (%%VALUE ITER-001))
           (CL:SETQ B2 (%%VALUE ITER-002))
           (CL:WHEN (CL:NOT (EQL? B1 B2)) (CL:SETQ ALWAYS?-000 CL:NIL)
            (CL:RETURN))
           (CL:SETQ ITER-001 (%%REST ITER-001))
           (CL:SETQ ITER-002 (%%REST ITER-002))))
         (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
        (CL:WHEN TEST-VALUE-000
         (CL:SETQ TEST-VALUE-000
          (CL:EQ (%CONTROL-FRAME.REVERSE-POLARITY? FRAME)
           (%CONTROL-FRAME.REVERSE-POLARITY? PREVIOUSFRAME))))))
      (CL:WHEN TEST-VALUE-000 (CL:SETQ DUPLICATEFRAME PREVIOUSFRAME)
       (CL:RETURN)))
     (CL:SETQ PREVIOUSFRAME (%CONTROL-FRAME.UP PREVIOUSFRAME))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:COND
    ((CL:NOT (CL:EQ DUPLICATEFRAME NULL))
     (TRACE-GOAL-CACHE "DUPLICATE GOAL:" FRAME)
     (CL:WHEN
      (CL:AND (CL:OR *CACHE-SUCCEEDED-GOALS?* *CACHE-FAILED-GOALS?*)
       (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
         (CL:NOT
          (CL:EQ
           (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
           NULL)))))
      (DONT-CACHE-GOAL-FAILURE-BETWEEN-FRAMES FRAME
       (%CONTROL-FRAME.DOWN DUPLICATEFRAME)))
     CL:T)
    (CL:T CL:NIL))))

;;; (DEFUN (INITIATE-ATOMIC-GOAL-PROOFS KEYWORD) ...)

(CL:DEFUN INITIATE-ATOMIC-GOAL-PROOFS (FRAME)
  (CL:LET*
   ((*REVERSEPOLARITY?* (%CONTROL-FRAME.REVERSE-POLARITY? FRAME)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (CL:LET*
    ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
     (INFERENCELEVEL
      (%NORMAL-INFERENCE-LEVEL.KEYWORD (CURRENT-INFERENCE-LEVEL)))
     (STRATEGIES NULL))
    (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
     (CL:COND
      ((CL:OR (CL:EQ TEST-VALUE-000 KWD-QUERY-PREDICATE)
        (CL:EQ TEST-VALUE-000 KWD-QUERY-ISA)
        (CL:EQ TEST-VALUE-000 KWD-QUERY-FUNCTION))
       (CL:SETF (%CONTROL-FRAME.GOAL-BINDINGS FRAME)
        (YIELD-GOAL-BINDINGS PROPOSITION))
       (CL:WHEN (CHECK-FOR-DUPLICATE-GOAL? FRAME)
        (CL:COND
         ((CL:EQ *DUPLICATE-SUBGOAL-STRATEGY*
           KWD-QUERY-DUPLICATE-GOALS)
          (CL:SETQ INFERENCELEVEL KWD-QUERY-SHALLOW))
         ((CL:EQ *DUPLICATE-SUBGOAL-STRATEGY*
           KWD-QUERY-DUPLICATE-GOALS-WITH-CACHING)
          (CL:SETF (%CONTROL-FRAME.STATE FRAME)
           KWD-QUERY-SCAN-CACHED-BINDINGS)
          (CL:RETURN-FROM INITIATE-ATOMIC-GOAL-PROOFS
           KWD-QUERY-MOVE-IN-PLACE))
         (CL:T
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
            *DUPLICATE-SUBGOAL-STRATEGY*
            "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
       (CL:COND
        ((CL:OR (CL:EQ INFERENCELEVEL KWD-QUERY-NORMAL)
          (CL:EQ INFERENCELEVEL KWD-QUERY-BACKTRACKING))
         (CL:SETQ STRATEGIES
          (GET-QUOTED-TREE
           "((:SPECIALIST :LOOKUP-GOAL-CACHES :LOOKUP-ASSERTIONS :SHALLOW-DISPROOF :ALL-SUBGOAL-STRATEGIES) \"/LOGIC\")"
           "/LOGIC")))
        ((CL:EQ INFERENCELEVEL KWD-QUERY-REFUTATION)
         (CL:SETQ STRATEGIES
          (GET-QUOTED-TREE
           "((:SPECIALIST :LOOKUP-GOAL-CACHES :LOOKUP-ASSERTIONS :SHALLOW-DISPROOF :ALL-SUBGOAL-STRATEGIES :REFUTATION) \"/LOGIC\")"
           "/LOGIC")))
        (CL:T
         (CL:SETQ STRATEGIES
          (GET-QUOTED-TREE
           "((:SPECIALIST :LOOKUP-ASSERTIONS :SHALLOW-DISPROOF) \"/LOGIC\")"
           "/LOGIC"))))
       (CL:WHEN
        (CL:AND
         (CL:EQ (%PROPOSITION.KIND PROPOSITION) KWD-QUERY-FUNCTION)
         (CL:NOT *REVERSEPOLARITY?*))
        (CL:SETQ STRATEGIES
         (CONCATENATE (COPY-CONS-LIST STRATEGIES)
          (CONS-LIST KWD-QUERY-MANUFACTURE-SKOLEM)))))
      ((CL:EQ TEST-VALUE-000 KWD-QUERY-EQUIVALENT)
       (CL:SETQ STRATEGIES
        (GET-QUOTED-TREE "((:EQUIVALENCE) \"/LOGIC\")" "/LOGIC")))
      ((CL:EQ TEST-VALUE-000 KWD-QUERY-IMPLIES)
       (CL:SETQ STRATEGIES
        (GET-QUOTED-TREE
         "((:SPECIALIST :ALL-SUBGOAL-STRATEGIES :IMPLIES) \"/LOGIC\")"
         "/LOGIC")))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
         TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
    (CL:SETF (%CONTROL-FRAME.NEXT-STRATEGIES FRAME) STRATEGIES)
    (CL:SETF (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-ATOMIC-GOAL)
    KWD-QUERY-MOVE-IN-PLACE)))

;;; (DEFUN (ALL-ARGUMENTS-BOUND? BOOLEAN) ...)

(CL:DEFUN ALL-ARGUMENTS-BOUND? (GOAL)
  (CL:IF
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS GOAL)
      SYM-QUERY-LOGIC-IO-VARIABLES NULL)
     NULL))
   (QUANTIFIED-ARGUMENT-BOUND? GOAL NULL) (ARGUMENT-BOUND? GOAL)))

;;; (DEFUN (ALL-KEY-ARGUMENTS-BOUND? BOOLEAN) ...)

(CL:DEFUN ALL-KEY-ARGUMENTS-BOUND? (GOAL)
  (CL:IF
   (CL:OR (CL:EQ (%PROPOSITION.KIND GOAL) KWD-QUERY-FUNCTION)
    (SINGLE-VALUED-PREDICATE? GOAL))
   (CL:IF
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS GOAL)
       SYM-QUERY-LOGIC-IO-VARIABLES NULL)
      NULL))
    (CL:LET* ((ALWAYS?-000 CL:T))
     (CL:LET*
      ((I NULL-INTEGER) (ITER-000 0)
       (UPPER-BOUND-000
        (CL:- (LENGTH (%PROPOSITION.ARGUMENTS GOAL)) 2)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
      (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
       (CL:SETQ I ITER-000)
       (CL:WHEN
        (CL:NOT
         (QUANTIFIED-ARGUMENT-BOUND?
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
           I)
          NULL))
        (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
       (CL:SETQ ITER-000 (CL:1+ ITER-000))))
     (CL:LET* ((VALUE-000 ALWAYS?-000)) VALUE-000))
    (CL:LET* ((ALWAYS?-001 CL:T))
     (CL:LET*
      ((I NULL-INTEGER) (ITER-001 0)
       (UPPER-BOUND-001
        (CL:- (LENGTH (%PROPOSITION.ARGUMENTS GOAL)) 2)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
      (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO
       (CL:SETQ I ITER-001)
       (CL:WHEN
        (CL:NOT
         (ARGUMENT-BOUND?
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
           I)))
        (CL:SETQ ALWAYS?-001 CL:NIL) (CL:RETURN))
       (CL:SETQ ITER-001 (CL:1+ ITER-001))))
     (CL:LET* ((VALUE-001 ALWAYS?-001)) VALUE-001)))
   CL:NIL))

;;; (DEFUN (CREATE-PATTERN-RECORD PATTERN-RECORD) ...)

(CL:DEFUN CREATE-PATTERN-RECORD (FRAME DESCRIPTION EXTERNALARGUMENTS)
  (CL:LET* ((PATTERNRECORD (NEW-PATTERN-RECORD)))
   (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:SETF (%PATTERN-RECORD.DESCRIPTION PATTERNRECORD) DESCRIPTION)
    (CL:IF (CL:NOT (CL:EQ EXTERNALARGUMENTS NULL))
     (CL:LET*
      ((EXTERNALARGUMENTSCOPY
        (COPY-PATTERN-ARGUMENTS EXTERNALARGUMENTS DESCRIPTION)))
      (CL:SETF (%PATTERN-RECORD.EXTERNAL-ARGUMENTS PATTERNRECORD)
       EXTERNALARGUMENTSCOPY)
      (CL:SETF (%PATTERN-RECORD.BOOLEAN-VECTOR PATTERNRECORD)
       (ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR EXTERNALARGUMENTSCOPY)))
     (CL:LET* ((ONESLIST (NEW-LIST)))
      (CL:LET*
       ((V (ALLOCATE-ITERATOR (%DESCRIPTION.IO-VARIABLES DESCRIPTION)))
        (COLLECT-000 NULL))
       (CL:LOOP WHILE (NEXT? V) DO
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS ZERO-WRAPPER NIL))
          (CL:IF (CL:EQ (%LIST.THE-CONS-LIST ONESLIST) NIL)
           (CL:SETF (%LIST.THE-CONS-LIST ONESLIST) COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST ONESLIST)
            COLLECT-000)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-000) (CONS ZERO-WRAPPER NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
      (CL:SETF (%PATTERN-RECORD.BOOLEAN-VECTOR PATTERNRECORD)
       (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR ONESLIST))
      (FREE ONESLIST))))
   (CL:SETF (%PATTERN-RECORD.COLLECTION-LIST PATTERNRECORD) NULL)
   (CL:SETF (%CONTROL-FRAME.PATTERN-RECORD FRAME) PATTERNRECORD)
   (CL:SETF (%PATTERN-RECORD.CONTROL-FRAME PATTERNRECORD) FRAME)
   PATTERNRECORD))

;;; (DEFUN (TERMINATE-PATTERN-RECORD? BOOLEAN) ...)

(CL:DEFUN TERMINATE-PATTERN-RECORD? (SELF)
  (CL:WHEN
   (CL:NOT (CL:EQ (%PATTERN-RECORD.EXTERNAL-ARGUMENTS SELF) NULL))
   (FREE (%PATTERN-RECORD.EXTERNAL-ARGUMENTS SELF)))
  (CL:SETF (%PATTERN-RECORD.OPTIMAL-PATTERN SELF) NULL)
  CL:T)

;;; (DEFUN (COPY-PATTERN-ARGUMENTS ARGUMENTS-VECTOR) ...)

(CL:DEFUN COPY-PATTERN-ARGUMENTS (ARGUMENTS DESCRIPTION)
  (CL:WHEN (CL:EQ ARGUMENTS NULL)
   (CL:RETURN-FROM COPY-PATTERN-ARGUMENTS NULL))
  (CL:LET*
   ((ARGUMENTCOUNT (ARITY DESCRIPTION))
    (COPIEDARGUMENTS (NEW-VECTOR ARGUMENTCOUNT)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARGUMENTCOUNT))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- ARGUMENTCOUNT)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY COPIEDARGUMENTS))
       (VALUE
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) I))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   COPIEDARGUMENTS))

;;; (DEFUN (COMPUTE-EXTERNAL-BINDINGS CONS) ...)

(CL:DEFUN COMPUTE-EXTERNAL-BINDINGS (EXTERNALARGUMENTS)
  (CL:LET* ((EXTERNALBINDINGS NIL))
   (CL:WHEN (CL:EQ EXTERNALARGUMENTS NULL)
    (CL:RETURN-FROM COMPUTE-EXTERNAL-BINDINGS NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 EXTERNALARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS (INSTANTIATE-EXTERNAL-BINDINGS (ARGUMENT-BOUND-TO ARG))
         NIL))
       (CL:IF (CL:EQ EXTERNALBINDINGS NIL)
        (CL:SETQ EXTERNALBINDINGS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST EXTERNALBINDINGS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (INSTANTIATE-EXTERNAL-BINDINGS (ARGUMENT-BOUND-TO ARG))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   EXTERNALBINDINGS))

;;; (DEFUN (INSTANTIATE-EXTERNAL-BINDINGS OBJECT) ...)

(CL:DEFUN INSTANTIATE-EXTERNAL-BINDINGS (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
          SYM-QUERY-LOGIC-EXTERNAL-VARIABLES NULL)
         NULL))
       (CL:LET* ((MAPPING (NEW-KEY-VALUE-LIST)))
        (CL:LET*
         ((VAR NULL)
          (VECTOR-000
           (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
            SYM-QUERY-LOGIC-EXTERNAL-VARIABLES NULL))
          (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:SETQ VAR
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:WHEN (ARGUMENT-BOUND? VAR)
           (INSERT-AT MAPPING VAR (ARGUMENT-BOUND-TO VAR)))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
        (CL:WHEN (CL:NOT (EMPTY? MAPPING))
         (CL:RETURN-FROM INSTANTIATE-EXTERNAL-BINDINGS
          (INSTANTIATE-EXTERNAL-VARIABLES SELF MAPPING)))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-PROPOSITION)
     (CL:PROGN))
    (CL:T)))
  SELF)

;;; (DEFUN (INSTANTIATE-EXTERNAL-VARIABLES DESCRIPTION) ...)

(CL:DEFUN INSTANTIATE-EXTERNAL-VARIABLES (SELF BINDINGS)
  (CL:WHEN (CL:NOT (EMPTY? BINDINGS))
   (CL:LET*
    ((*EVALUATIONMODE* KWD-QUERY-DESCRIPTION) (*QUERYITERATOR* NULL))
    (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE* *QUERYITERATOR*))
    (CL:LET* ((DESCRIPTION (NEW-DESCRIPTION)))
     (CL:LET*
      ((VAR NULL) (BINDING NULL)
       (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST BINDINGS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
       (CL:SETQ VAR (%KV-CONS.KEY ITER-000))
       (CL:SETQ BINDING (%KV-CONS.VALUE ITER-000))
       (INSERT-AT BINDINGS VAR (EVALUATE-TERM BINDING))
       (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000))))
     (CL:SETF (%DESCRIPTION.IO-VARIABLES DESCRIPTION)
      (COPY (%DESCRIPTION.IO-VARIABLES SELF)))
     (CL:LET*
      ((VAR NULL) (VECTOR-000 (%DESCRIPTION.IO-VARIABLES SELF))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ VAR
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (INSERT-AT BINDINGS VAR VAR)
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (CL:LET*
      ((VAR NULL)
       (VECTOR-001
        (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
         SYM-QUERY-LOGIC-EXTERNAL-VARIABLES NULL))
       (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:SETQ VAR
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:WHEN (CL:EQ (LOOKUP BINDINGS VAR) NULL)
        (INSERT-AT BINDINGS VAR VAR))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
     (CL:LET*
      ((VAR NULL) (VECTOR-002 (%DESCRIPTION.INTERNAL-VARIABLES SELF))
       (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
      (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
       (CL:SETQ VAR
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
         INDEX-002))
       (INSERT-AT BINDINGS VAR VAR)
       (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
     (CL:SETF (%DESCRIPTION.PROPOSITION DESCRIPTION)
      (INHERIT-PROPOSITION (%DESCRIPTION.PROPOSITION SELF) BINDINGS))
     (CL:RETURN-FROM INSTANTIATE-EXTERNAL-VARIABLES
      (FINISH-BUILDING-DESCRIPTION DESCRIPTION CL:T)))))
  SELF)

;;; (DEFUN (CHECK-FOR-SINGLE-VALUED-GOAL? BOOLEAN) ...)

(CL:DEFUN CHECK-FOR-SINGLE-VALUED-GOAL? (PATTERN IOBINDINGS)
  (CL:LET* ((IOVARIABLES NIL) (BOUNDVARIABLES NIL))
   (CL:LET*
    ((VBL NULL) (VECTOR-000 (%DESCRIPTION.IO-VARIABLES PATTERN))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ VBL
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS VBL NIL))
       (CL:IF (CL:EQ IOVARIABLES NIL) (CL:SETQ IOVARIABLES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST IOVARIABLES COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VBL NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET*
    ((V1 NULL) (ITER-000 IOVARIABLES) (V2 NULL) (ITER-001 IOBINDINGS))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
      (CL:NOT (CL:EQ ITER-001 NIL)))
     DO (CL:SETQ V1 (%%VALUE ITER-000)) (CL:SETQ V2 (%%VALUE ITER-001))
     (CL:WHEN (CL:NOT (CL:EQ V2 NULL))
      (CL:SETQ BOUNDVARIABLES (CONS V1 BOUNDVARIABLES)))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (SINGLE-VALUED-GOAL? (%DESCRIPTION.PROPOSITION PATTERN) IOVARIABLES
    BOUNDVARIABLES)))

;;; (DEFUN (OVERLAY-WITH-PATTERN-FRAME? BOOLEAN) ...)

(CL:DEFUN OVERLAY-WITH-PATTERN-FRAME? (FRAME DESCRIPTION IOARGUMENTS)
  (CL:LET*
   ((IOBINDINGS (COMPUTE-EXTERNAL-BINDINGS IOARGUMENTS))
    (EXTERNALBINDINGS
     (CL:IF
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
         SYM-QUERY-LOGIC-EXTERNAL-VARIABLES NULL)
        NULL))
      (COMPUTE-EXTERNAL-BINDINGS
       (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
        SYM-QUERY-LOGIC-EXTERNAL-VARIABLES NULL))
      NIL))
    (PATTERNRECORD
     (CREATE-PATTERN-RECORD FRAME DESCRIPTION IOARGUMENTS))
    (OPTIMALPATTERN NULL))
   (CL:WHEN (CL:EQ IOARGUMENTS NULL)
    (CL:LET*
     ((V (ALLOCATE-ITERATOR (%DESCRIPTION.IO-VARIABLES DESCRIPTION)))
      (COLLECT-000 NULL))
     (CL:LOOP WHILE (NEXT? V) DO
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS NULL NIL))
        (CL:IF (CL:EQ IOBINDINGS NIL) (CL:SETQ IOBINDINGS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST IOBINDINGS COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS NULL NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:SETF (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-PATTERN)
   (CL:SETQ OPTIMALPATTERN
    (SELECT-OPTIMAL-QUERY-PATTERN DESCRIPTION
     (%PATTERN-RECORD.BOOLEAN-VECTOR PATTERNRECORD) FRAME))
   (CL:SETF (%PATTERN-RECORD.OPTIMAL-PATTERN PATTERNRECORD)
    OPTIMALPATTERN)
   (CL:WHEN (CHECK-FOR-SINGLE-VALUED-GOAL? OPTIMALPATTERN IOBINDINGS)
    (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
     SYM-QUERY-LOGIC-CACHED-SINGLE-VALUED?
     (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
   (CL:SETF (%CONTROL-FRAME.PROPOSITION FRAME)
    (%DESCRIPTION.PROPOSITION OPTIMALPATTERN))
   (CL:LET*
    ((VARIABLESCOUNT
      (CL:+ (LENGTH IOBINDINGS)
       (LENGTH (%DESCRIPTION.INTERNAL-VARIABLES OPTIMALPATTERN))
       (LENGTH EXTERNALBINDINGS))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM VARIABLESCOUNT))
    (ACTIVATE-PATTERN-RECORD PATTERNRECORD VARIABLESCOUNT))
   (CL:LET*
    ((IOVAR NULL)
     (VECTOR-000 (%DESCRIPTION.IO-VARIABLES OPTIMALPATTERN))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (BINDING NULL)
     (ITER-000 IOBINDINGS))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:NOT (CL:EQ ITER-000 NIL)))
     DO
     (CL:SETQ IOVAR
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ BINDING (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ BINDING NULL))
       (CL:NOT (BIND-VARIABLE-TO-VALUE? IOVAR BINDING CL:NIL)))
      (CL:RETURN-FROM OVERLAY-WITH-PATTERN-FRAME? CL:NIL))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:NOT (CL:EQ EXTERNALBINDINGS NIL))
    (CL:LET*
     ((EXTERNALVAR NULL)
      (VECTOR-001
       (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS OPTIMALPATTERN)
        SYM-QUERY-LOGIC-EXTERNAL-VARIABLES NULL))
      (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)) (BINDING NULL)
      (ITER-001 EXTERNALBINDINGS))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-001 LENGTH-001)
       (CL:NOT (CL:EQ ITER-001 NIL)))
      DO
      (CL:SETQ EXTERNALVAR
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
        INDEX-001))
      (CL:SETQ BINDING (%%VALUE ITER-001))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ BINDING NULL))
        (CL:NOT (BIND-VARIABLE-TO-VALUE? EXTERNALVAR BINDING CL:NIL)))
       (CL:RETURN-FROM OVERLAY-WITH-PATTERN-FRAME? CL:NIL))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))))
   (CL:WHEN (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL)
    (CREATE-DOWN-FRAME FRAME
     (%DESCRIPTION.PROPOSITION OPTIMALPATTERN)))
   (ELABORATE-SURROGATES-IN-PROPOSITION
    (%DESCRIPTION.PROPOSITION OPTIMALPATTERN))
   CL:T))

;;; (DEFUN (TRANSFER-PATTERN-QUERY-BINDINGS? BOOLEAN) ...)

(CL:DEFUN TRANSFER-PATTERN-QUERY-BINDINGS? (FRAME FUTUREBINDINGS?)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "TRANSFER-pattern-query-bindings?: " EOL))
  (CL:LET*
   ((CHILDPATTERNRECORD (%CONTROL-FRAME.PATTERN-RECORD FRAME))
    (BOOLEANVECTOR (%PATTERN-RECORD.BOOLEAN-VECTOR CHILDPATTERNRECORD))
    (EXTERNALARGUMENTS
     (%PATTERN-RECORD.EXTERNAL-ARGUMENTS CHILDPATTERNRECORD))
    (IOVARIABLES
     (%DESCRIPTION.IO-VARIABLES
      (%PATTERN-RECORD.OPTIMAL-PATTERN CHILDPATTERNRECORD)))
    (LASTINDEX (CL:1- (LENGTH BOOLEANVECTOR))) (IOVARIABLEVALUES NIL)
    (TOPUNBINDINGOFFSET NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LASTINDEX TOPUNBINDINGOFFSET))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 LASTINDEX)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000)
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CL:IF
          (CL:NOT
           (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%VECTOR.THE-ARRAY BOOLEANVECTOR))
             I)))
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY
             (%PATTERN-RECORD.VARIABLE-BINDINGS
              (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD
               *QUERYITERATOR*))))
           (CL:THE CL:FIXNUM
            (%PATTERN-VARIABLE.BOUND-TO-OFFSET
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY IOVARIABLES))
              I))))
          NULL)
         NIL))
       (CL:IF (CL:EQ IOVARIABLEVALUES NIL)
        (CL:SETQ IOVARIABLEVALUES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST IOVARIABLEVALUES COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CL:IF
          (CL:NOT
           (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%VECTOR.THE-ARRAY BOOLEANVECTOR))
             I)))
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY
             (%PATTERN-RECORD.VARIABLE-BINDINGS
              (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD
               *QUERYITERATOR*))))
           (CL:THE CL:FIXNUM
            (%PATTERN-VARIABLE.BOUND-TO-OFFSET
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY IOVARIABLES))
              I))))
          NULL)
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (RESET-CURRENT-PATTERN-RECORD FRAME KWD-QUERY-PARENT)
   (CL:LET*
    ((PARENTPATTERNRECORD
      (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*)))
    (CL:SETQ TOPUNBINDINGOFFSET
     (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PARENTPATTERNRECORD))
    (CL:LET*
     ((VALUE NULL) (ITER-001 IOVARIABLEVALUES) (EXTERNALARG NULL)
      (VECTOR-000 EXTERNALARGUMENTS) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)) (INITIALLYBOUND? NULL)
      (VECTOR-001 BOOLEANVECTOR) (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:< INDEX-000 LENGTH-000)
       (CL:< INDEX-001 LENGTH-001))
      DO (CL:SETQ VALUE (%%VALUE ITER-001))
      (CL:SETQ EXTERNALARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INITIALLYBOUND?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
        INDEX-001))
      (CL:WHEN
       (CL:NOT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN INITIALLYBOUND?))
       (CL:WHEN
        (CL:NOT (BIND-ARGUMENT-TO-VALUE? EXTERNALARG VALUE CL:NIL))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
          (MEMB? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "TRANSFER FAILS! " EOL))
        (UNBIND-VARIABLES-BEGINNING-AT PARENTPATTERNRECORD
         (CL:1+ TOPUNBINDINGOFFSET))
        (CL:WHEN FUTUREBINDINGS?
         (RESET-CURRENT-PATTERN-RECORD FRAME KWD-QUERY-LOCAL))
        (CL:RETURN-FROM TRANSFER-PATTERN-QUERY-BINDINGS? CL:NIL)))
      (CL:SETQ ITER-001 (%%REST ITER-001))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
   CL:T))

;;; (DEFUN COLLECT-PATTERN-QUERY-BINDINGS ...)

(CL:DEFUN COLLECT-PATTERN-QUERY-BINDINGS (FRAME)
  (CL:LET*
   ((PATTERNRECORD (%CONTROL-FRAME.PATTERN-RECORD FRAME))
    (IOVARIABLES
     (%DESCRIPTION.IO-VARIABLES
      (%PATTERN-RECORD.OPTIMAL-PATTERN PATTERNRECORD)))
    (IOVARIABLEVALUES NIL))
   (CL:LET*
    ((V NULL) (VECTOR-000 IOVARIABLES) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ V
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY
            (%PATTERN-RECORD.VARIABLE-BINDINGS
             (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD
              *QUERYITERATOR*))))
          (CL:THE CL:FIXNUM (%PATTERN-VARIABLE.BOUND-TO-OFFSET V)))
         NIL))
       (CL:IF (CL:EQ IOVARIABLEVALUES NIL)
        (CL:SETQ IOVARIABLEVALUES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST IOVARIABLEVALUES COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY
            (%PATTERN-RECORD.VARIABLE-BINDINGS
             (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD
              *QUERYITERATOR*))))
          (CL:THE CL:FIXNUM (%PATTERN-VARIABLE.BOUND-TO-OFFSET V)))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:CASE (LENGTH IOVARIABLEVALUES)
    (1
     (CL:WHEN (CL:EQ (%%VALUE IOVARIABLEVALUES) NULL)
      (CL:WARN "Pushing NULL binding onto collection.  Variable= `~A'"
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY IOVARIABLES)) 0))
      (CL:RETURN-FROM COLLECT-PATTERN-QUERY-BINDINGS))
     (PUSH (%PATTERN-RECORD.COLLECTION-LIST PATTERNRECORD)
      (%%VALUE IOVARIABLEVALUES)))
    (CL:OTHERWISE
     (PUSH (%PATTERN-RECORD.COLLECTION-LIST PATTERNRECORD)
      IOVARIABLEVALUES)))))

;;; (DEFUN (GET-RULE-OF-ANTECEDENT-FRAME PROPOSITION) ...)

(CL:DEFUN GET-RULE-OF-ANTECEDENT-FRAME (FRAME)
  (CL:WHEN (CL:EQ (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-PATTERN)
   (CL:LET* ((PARENT (%CONTROL-FRAME.UP FRAME)))
    (CL:WHEN (CL:NOT (CL:EQ PARENT NULL))
     (CL:RETURN-FROM GET-RULE-OF-ANTECEDENT-FRAME
      (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS PARENT)
       SYM-QUERY-LOGIC-ANTECEDENTS-RULE NULL)))))
  NULL)

;;; (DEFUN (CONTINUE-PATTERN-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-PATTERN-PROOF (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (RESET-CURRENT-PATTERN-RECORD FRAME KWD-QUERY-LOCAL)
    KWD-QUERY-MOVE-DOWN)
   ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
    (CL:LET*
     ((FUTUREBINDINGS?
       (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL)))
      (RESULT (%CONTROL-FRAME.RESULT FRAME))
      (RULE (GET-RULE-OF-ANTECEDENT-FRAME FRAME)))
     (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE FRAME)
      (WEAKEN-TRUTH-VALUE (PROPAGATE-FRAME-TRUTH-VALUE RESULT FRAME)
       (CL:IF (CL:NOT (CL:EQ RULE NULL))
        (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE RULE)
         (%PROPOSITION.HOME-CONTEXT RULE) CL:NIL)
        TRUE-TRUTH-VALUE)))
     (CL:WHEN
      (CL:NOT (CL:EQ (%CONTROL-FRAME.PARTIAL-MATCH-FRAME RESULT) NULL))
      (PROPAGATE-FRAME-PARTIAL-TRUTH
       (%CONTROL-FRAME.PARTIAL-MATCH-FRAME RESULT) FRAME))
     (CL:WHEN *RECORD-JUSTIFICATIONS?*
      (RECORD-PATTERN-JUSTIFICATION FRAME LASTMOVE))
     (CL:COND
      ((CL:NOT
        (CL:EQ
         (%PATTERN-RECORD.COLLECTION-LIST
          (%CONTROL-FRAME.PATTERN-RECORD FRAME))
         NULL))
       (COLLECT-PATTERN-QUERY-BINDINGS FRAME)
       (CL:IF FUTUREBINDINGS? KWD-QUERY-MOVE-DOWN
        (CL:PROGN (RESET-CURRENT-PATTERN-RECORD FRAME KWD-QUERY-PARENT)
         KWD-QUERY-CONTINUING-SUCCESS)))
      ((TRANSFER-PATTERN-QUERY-BINDINGS? FRAME FUTUREBINDINGS?)
       (CL:IF FUTUREBINDINGS?
        (CL:PROGN
         (CL:WHEN
          (CL:AND
           (%BOOLEAN-WRAPPER.WRAPPER-VALUE
            (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
             SYM-QUERY-LOGIC-CACHED-SINGLE-VALUED? FALSE-WRAPPER))
           (CL:NOT *GENERATE-ALL-PROOFS?*))
          (POP-FRAMES-UP-TO (%CONTROL-FRAME.DOWN FRAME))
          (CL:RETURN-FROM CONTINUE-PATTERN-PROOF
           KWD-QUERY-FINAL-SUCCESS))
         KWD-QUERY-CONTINUING-SUCCESS)
        KWD-QUERY-FINAL-SUCCESS))
      (FUTUREBINDINGS? KWD-QUERY-MOVE-DOWN) (CL:T KWD-QUERY-FAILURE))))
   ((CL:OR (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
     (CL:EQ LASTMOVE KWD-QUERY-FAILED-OVERLAY))
    (CL:LET* ((RESULT (%CONTROL-FRAME.RESULT FRAME)))
     (PROPAGATE-FRAME-TRUTH-VALUE RESULT FRAME)
     (CL:WHEN
      (CL:NOT (CL:EQ (%CONTROL-FRAME.PARTIAL-MATCH-FRAME RESULT) NULL))
      (PROPAGATE-FRAME-PARTIAL-TRUTH
       (%CONTROL-FRAME.PARTIAL-MATCH-FRAME RESULT) FRAME))
     (CL:WHEN *RECORD-JUSTIFICATIONS?*
      (RECORD-PATTERN-JUSTIFICATION FRAME LASTMOVE))
     (CL:IF
      (CL:NOT
       (CL:EQ
        (%PATTERN-RECORD.COLLECTION-LIST
         (%CONTROL-FRAME.PATTERN-RECORD FRAME))
        NULL))
      (CL:PROGN (RESET-CURRENT-PATTERN-RECORD FRAME KWD-QUERY-PARENT)
       KWD-QUERY-CONTINUING-SUCCESS)
      KWD-QUERY-FAILURE)))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" LASTMOVE "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (DISJOINT-CLASSES? BOOLEAN) ...)

(CL:DEFUN DISJOINT-CLASSES? (DESC1 DESC2)
  (CL:AND (CL:NOT (CL:EQ DESC1 DESC2))
   (CL:NOT (COLLECTION-IMPLIES-COLLECTION? DESC1 DESC2))
   (CL:NOT (COLLECTION-IMPLIES-COLLECTION? DESC2 DESC1))))

;;; (DEFUN (DISJOINT-TERMS? BOOLEAN) ...)

(CL:DEFUN DISJOINT-TERMS? (D1 D2)
  "Return TRUE if 'd1' and 'd2' belong to disjoint partitions."
  (CL:WHEN *CYC-KLUDGES-ENABLED?*
   (CL:WHEN
    (CL:AND (ISA? D1 SGT-QUERY-LOGIC-NAMED-DESCRIPTION)
     (ISA? D2 SGT-QUERY-LOGIC-NAMED-DESCRIPTION))
    (CL:RETURN-FROM DISJOINT-TERMS?
     (TRUE-TRUTH-VALUE?
      (EVALUATE-SELECTION-PATTERN
       (MAKE-RELATION-PATTERN-2 SGT-QUERY-PL-KERNEL-KB-DISJOINT D1
        D2))))))
  (APPLY-CACHED-ASK (LIST* SYM-QUERY-LOGIC-?D1 SYM-QUERY-LOGIC-?D2 NIL)
   (LIST* SYM-QUERY-LOGIC-DISJOINT SYM-QUERY-LOGIC-?D1
    SYM-QUERY-LOGIC-?D2 NIL)
   (CONS-LIST D1 D2) (CONS-LIST)
   SYM-QUERY-LOGIC-F-DISJOINT-TERMS?-QUERY-000))

;;; (DEFUN (EXPENSIVE-DISJOINT-TERMS? BOOLEAN) ...)

(CL:DEFUN EXPENSIVE-DISJOINT-TERMS? (D1 D2)
  (APPLY-CACHED-ASK (LIST* SYM-QUERY-LOGIC-?D1 SYM-QUERY-LOGIC-?D2 NIL)
   (LIST* SYM-QUERY-STELLA-OR
    (LIST* SYM-QUERY-LOGIC-DISJOINT SYM-QUERY-LOGIC-?D1
     SYM-QUERY-LOGIC-?D2 NIL)
    (LIST* SYM-QUERY-STELLA-AND
     (LIST* SYM-QUERY-PL-KERNEL-KB-CLASS SYM-QUERY-LOGIC-?D1 NIL)
     (LIST* SYM-QUERY-PL-KERNEL-KB-CLASS SYM-QUERY-LOGIC-?D2 NIL)
     (LIST* SYM-QUERY-LOGIC-REFUTATION-DISJOINT SYM-QUERY-LOGIC-?D1
      SYM-QUERY-LOGIC-?D2 NIL)
     NIL)
    NIL)
   (CONS-LIST D1 D2) (CONS-LIST)
   SYM-QUERY-LOGIC-F-EXPENSIVE-DISJOINT-TERMS?-QUERY-000))

;;; (DEFUN (COLLECTIONOF-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN COLLECTIONOF-PROPOSITION? (DEFININGPROPOSITION)
  (LOGICAL-SUBTYPE-OF? (%PROPOSITION.OPERATOR DEFININGPROPOSITION)
   SGT-QUERY-PL-KERNEL-KB-COLLECTIONOF))

;;; (DEFUN (MEMBER-OF-COLLECTION? BOOLEAN) ...)

(CL:DEFUN MEMBER-OF-COLLECTION? (MEMBER COLLECTION)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE COLLECTION)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:RETURN-FROM MEMBER-OF-COLLECTION?
       (NEXT?
        (ALL-TRUE-DEPENDENT-PROPOSITIONS MEMBER
         (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE COLLECTION)
         CL:T)))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-COLLECTION)
     (CL:PROGN
      (CL:LET* ((FOUND?-000 CL:NIL))
       (CL:LET* ((M NULL) (ITER-000 (ALLOCATE-ITERATOR COLLECTION)))
        (CL:LOOP WHILE (NEXT? ITER-000) DO
         (CL:SETQ M (%ITERATOR.VALUE ITER-000))
         (CL:WHEN (EQL? (VALUE-OF M) MEMBER) (CL:SETQ FOUND?-000 CL:T)
          (CL:RETURN))))
       (CL:LET* ((MEMBER? FOUND?-000))
        (CL:IF *REVERSEPOLARITY?*
         (CL:RETURN-FROM MEMBER-OF-COLLECTION? (CL:NOT MEMBER?))
         (CL:RETURN-FROM MEMBER-OF-COLLECTION? MEMBER?))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET*
       ((SUCCESS? CL:NIL)
        (ENUMERATEDCOLLECTIONS
         (ALL-DEFINING-PROPOSITIONS COLLECTION
          SGT-QUERY-PL-KERNEL-KB-COLLECTIONOF CL:T)))
       (CL:COND
        ((CL:NOT (CL:EQ ENUMERATEDCOLLECTIONS NIL))
         (CL:LET* ((COL NULL) (ITER-001 ENUMERATEDCOLLECTIONS))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:SETQ COL (%%VALUE ITER-001))
           (CL:LET*
            ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS COL))
             (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
             (I NULL-INTEGER) (ITER-002 2)
             (UPPER-BOUND-000 (LENGTH (%PROPOSITION.ARGUMENTS COL))))
            (CL:DECLARE
             (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-002
              UPPER-BOUND-000))
            (CL:LOOP WHILE
             (CL:AND (CL:< INDEX-000 LENGTH-000)
              (CL:<= ITER-002 UPPER-BOUND-000))
             DO
             (CL:SETQ ARG
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
               INDEX-000))
             (CL:SETQ I ITER-002)
             (CL:WHEN (EQL? (VALUE-OF ARG) MEMBER) (CL:SETQ I I)
              (CL:SETQ SUCCESS? CL:T) (CL:RETURN))
             (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
             (CL:SETQ ITER-002 (CL:1+ ITER-002))))
           (CL:SETQ ITER-001 (%%REST ITER-001))))
         (CL:IF *REVERSEPOLARITY?*
          (CL:RETURN-FROM MEMBER-OF-COLLECTION? (CL:NOT SUCCESS?))
          (CL:RETURN-FROM MEMBER-OF-COLLECTION? SUCCESS?)))
        (CL:T
         (CL:LET*
          ((P NULL)
           (ITER-003
            (ALL-TRUE-DEPENDENT-PROPOSITIONS MEMBER
             SGT-QUERY-PL-KERNEL-KB-MEMBER-OF CL:NIL)))
          (CL:LOOP WHILE (NEXT? ITER-003) DO
           (CL:SETQ P (%ITERATOR.VALUE ITER-003))
           (CL:LET*
            ((SUBCOLLECTION
              (VALUE-OF
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR
                 (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
                1))))
            (CL:WHEN
             (CL:IF *REVERSEPOLARITY?*
              (COLLECTION-IMPLIES-COLLECTION? COLLECTION SUBCOLLECTION)
              (COLLECTION-IMPLIES-COLLECTION? SUBCOLLECTION
               COLLECTION))
             (CL:RETURN-FROM MEMBER-OF-COLLECTION? CL:T)))))
         (CL:RETURN-FROM MEMBER-OF-COLLECTION? CL:NIL))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:LET*
       ((EQUIVALENTSKOLEM
         (%%VALUE (VARIABLE-VALUE-INVERSE COLLECTION))))
       (CL:WHEN (CL:NOT (CL:EQ EQUIVALENTSKOLEM NULL))
        (CL:RETURN-FROM MEMBER-OF-COLLECTION?
         (MEMBER-OF-COLLECTION? MEMBER EQUIVALENTSKOLEM))))))
    (CL:T)))
  (CL:WARN
   "member-of-collection?: Illegal collection type: `~A'~%   member=`~A' collection=`~A'~%"
   (%SURROGATE.SYMBOL-NAME
    (WRAPPED-TYPE-TO-TYPE (PRIMARY-TYPE COLLECTION)))
   MEMBER COLLECTION)
  CL:NIL)

;;; (DEFUN (ASSERTED-COLLECTION-MEMBERS LIST) ...)

(CL:DEFUN ASSERTED-COLLECTION-MEMBERS (SELF DIRECT?)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-COLLECTION)
     (CL:PROGN
      (CL:LET* ((MEMBERS (NEW-LIST)))
       (CL:LET*
        ((M NULL) (ITER-000 (ALLOCATE-ITERATOR SELF))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (NEXT? ITER-000) DO
         (CL:SETQ M (%ITERATOR.VALUE ITER-000))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN (CL:SETQ COLLECT-000 (CONS M NIL))
           (CL:IF (CL:EQ (%LIST.THE-CONS-LIST MEMBERS) NIL)
            (CL:SETF (%LIST.THE-CONS-LIST MEMBERS) COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST MEMBERS)
             COLLECT-000)))
          (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS M NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
       MEMBERS)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:LET* ((MEMBERS (LIST)))
       (CL:LET*
        ((PROP NULL)
         (ITER-001 (ALL-TRUE-EXTENSION-MEMBERS SELF (CL:NOT DIRECT?)))
         (COLLECT-001 NULL))
        (CL:LOOP WHILE (NEXT? ITER-001) DO
         (CL:SETQ PROP
          (%DESCRIPTION-EXTENSION-ITERATOR.VALUE ITER-001))
         (CL:IF (CL:EQ COLLECT-001 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-001
            (CONS
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROP)))
              0)
             NIL))
           (CL:IF (CL:EQ (%LIST.THE-CONS-LIST MEMBERS) NIL)
            (CL:SETF (%LIST.THE-CONS-LIST MEMBERS) COLLECT-001)
            (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST MEMBERS)
             COLLECT-001)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-001)
            (CONS
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROP)))
              0)
             NIL))
           (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))))
       MEMBERS)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-DESCRIPTION)
     (CL:PROGN NULL))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET*
       ((MEMBERS (NEW-LIST))
        (ENUMERATEDCOLLECTIONS
         (ALL-DEFINING-PROPOSITIONS SELF
          SGT-QUERY-PL-KERNEL-KB-COLLECTIONOF CL:T)))
       (CL:IF (CL:NOT (CL:EQ ENUMERATEDCOLLECTIONS NIL))
        (CL:LET* ((COL NULL) (ITER-002 ENUMERATEDCOLLECTIONS))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
          (CL:SETQ COL (%%VALUE ITER-002))
          (CL:LET*
           ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS COL))
            (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
            (I NULL-INTEGER) (ITER-003 2)
            (UPPER-BOUND-000 (LENGTH (%PROPOSITION.ARGUMENTS COL)))
            (COLLECT-002 NULL))
           (CL:DECLARE
            (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-003
             UPPER-BOUND-000))
           (CL:LOOP WHILE
            (CL:AND (CL:< INDEX-000 LENGTH-000)
             (CL:<= ITER-003 UPPER-BOUND-000))
            DO
            (CL:SETQ ARG
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
              INDEX-000))
            (CL:SETQ I ITER-003)
            (CL:IF (CL:EQ COLLECT-002 NULL)
             (CL:PROGN (CL:SETQ COLLECT-002 (CONS (VALUE-OF ARG) NIL))
              (CL:IF (CL:EQ (%LIST.THE-CONS-LIST MEMBERS) NIL)
               (CL:SETF (%LIST.THE-CONS-LIST MEMBERS) COLLECT-002)
               (ADD-CONS-TO-END-OF-CONS-LIST
                (%LIST.THE-CONS-LIST MEMBERS) COLLECT-002)))
             (CL:PROGN
              (CL:SETF (%%REST COLLECT-002) (CONS (VALUE-OF ARG) NIL))
              (CL:SETQ COLLECT-002 (%%REST COLLECT-002))))
            (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
            (CL:SETQ ITER-003 (CL:1+ ITER-003))))
          (CL:SETQ ITER-002 (%%REST ITER-002))))
        (CL:LET*
         ((P NULL)
          (ITER-004
           (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF
            SGT-QUERY-PL-KERNEL-KB-MEMBER-OF CL:NIL))
          (COLLECT-003 NULL))
         (CL:LOOP WHILE (NEXT? ITER-004) DO
          (CL:SETQ P (%ITERATOR.VALUE ITER-004))
          (CL:WHEN
           (CL:OR
            (CL:AND DIRECT?
             (EQL?
              (VALUE-OF
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR
                 (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
                1))
              (VALUE-OF SELF)))
            (CL:AND (CL:NOT DIRECT?)
             (COLLECTION-IMPLIES-COLLECTION?
              (VALUE-OF
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR
                 (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
                1))
              (VALUE-OF SELF))))
           (CL:IF (CL:EQ COLLECT-003 NULL)
            (CL:PROGN
             (CL:SETQ COLLECT-003
              (CONS
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR
                 (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
                0)
               NIL))
             (CL:IF (CL:EQ (%LIST.THE-CONS-LIST MEMBERS) NIL)
              (CL:SETF (%LIST.THE-CONS-LIST MEMBERS) COLLECT-003)
              (ADD-CONS-TO-END-OF-CONS-LIST
               (%LIST.THE-CONS-LIST MEMBERS) COLLECT-003)))
            (CL:PROGN
             (CL:SETF (%%REST COLLECT-003)
              (CONS
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR
                 (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
                0)
               NIL))
             (CL:SETQ COLLECT-003 (%%REST COLLECT-003))))))))
       MEMBERS)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:LET*
       ((EQUIVALENTSKOLEM (%%VALUE (VARIABLE-VALUE-INVERSE SELF))))
       (CL:WHEN (CL:NOT (CL:EQ EQUIVALENTSKOLEM NULL))
        (CL:RETURN-FROM ASSERTED-COLLECTION-MEMBERS
         (ASSERTED-COLLECTION-MEMBERS EQUIVALENTSKOLEM DIRECT?))))
      (CL:WARN
       "Hmm. PowerLoom doesn't know how to interpret the LOGIC-OBJECT: `~A'~%   as a collection.~%"
       SELF)
      NIL-LIST))
    (CL:T NULL))))

(CL:DEFUN NEW-DESCRIPTION-EXTENSION-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-DESCRIPTION-EXTENSION-ITERATOR))
   (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.FIRST-ITERATION? SELF)
    CL:T)
   (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.TRUTH-VALUE SELF) NULL)
   (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.REMOVING-DUPLICATES? SELF)
    CL:NIL)
   (CL:SETF
    (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-TABLE SELF)
    NULL)
   (CL:SETF
    (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-LIST SELF)
    (NEW-LIST))
   (CL:SETF
    (%DESCRIPTION-EXTENSION-ITERATOR.REFERENCE-PROPOSITION SELF) NULL)
   (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.EXTENSION-ITERATOR SELF)
    NULL)
   (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.SUBCOLLECTIONS SELF) NULL)
   (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.ROOT-DESCRIPTION SELF)
    NULL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DESCRIPTION-EXTENSION-ITERATOR))
  SGT-QUERY-LOGIC-DESCRIPTION-EXTENSION-ITERATOR)

(CL:DEFUN ACCESS-DESCRIPTION-EXTENSION-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ROOT-DESCRIPTION)
    (CL:IF SETVALUE?
     (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.ROOT-DESCRIPTION SELF)
      VALUE)
     (CL:SETQ VALUE
      (%DESCRIPTION-EXTENSION-ITERATOR.ROOT-DESCRIPTION SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-SUBCOLLECTIONS)
    (CL:IF SETVALUE?
     (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.SUBCOLLECTIONS SELF)
      VALUE)
     (CL:SETQ VALUE
      (%DESCRIPTION-EXTENSION-ITERATOR.SUBCOLLECTIONS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-EXTENSION-ITERATOR)
    (CL:IF SETVALUE?
     (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.EXTENSION-ITERATOR SELF)
      VALUE)
     (CL:SETQ VALUE
      (%DESCRIPTION-EXTENSION-ITERATOR.EXTENSION-ITERATOR SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-REFERENCE-PROPOSITION)
    (CL:IF SETVALUE?
     (CL:SETF
      (%DESCRIPTION-EXTENSION-ITERATOR.REFERENCE-PROPOSITION SELF)
      VALUE)
     (CL:SETQ VALUE
      (%DESCRIPTION-EXTENSION-ITERATOR.REFERENCE-PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ALREADY-GENERATED-LIST)
    (CL:IF SETVALUE?
     (CL:SETF
      (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-LIST SELF)
      VALUE)
     (CL:SETQ VALUE
      (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-LIST SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ALREADY-GENERATED-TABLE)
    (CL:IF SETVALUE?
     (CL:SETF
      (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-TABLE SELF)
      VALUE)
     (CL:SETQ VALUE
      (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-REMOVING-DUPLICATES?)
    (CL:IF SETVALUE?
     (CL:SETF
      (%DESCRIPTION-EXTENSION-ITERATOR.REMOVING-DUPLICATES? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF
       (%DESCRIPTION-EXTENSION-ITERATOR.REMOVING-DUPLICATES? SELF)
       TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TRUTH-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.TRUTH-VALUE SELF) VALUE)
     (CL:SETQ VALUE
      (%DESCRIPTION-EXTENSION-ITERATOR.TRUTH-VALUE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (ALL-TRUE-EXTENSION-MEMBERS DESCRIPTION-EXTENSION-ITERATOR) ...)

(CL:DEFUN ALL-TRUE-EXTENSION-MEMBERS (SELF SPECIALIZE?)
  (CL:LET* ((ITERATOR (NEW-DESCRIPTION-EXTENSION-ITERATOR)))
   (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.ROOT-DESCRIPTION ITERATOR)
    SELF)
   (CL:SETF
    (%DESCRIPTION-EXTENSION-ITERATOR.EXTENSION-ITERATOR ITERATOR)
    (ALL-EXTENSION-MEMBERS SELF))
   (CL:IF SPECIALIZE?
    (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.SUBCOLLECTIONS ITERATOR)
     NULL)
    (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.SUBCOLLECTIONS ITERATOR)
     NIL))
   (CL:SETF
    (%DESCRIPTION-EXTENSION-ITERATOR.REMOVING-DUPLICATES? ITERATOR)
    (CL:AND SPECIALIZE? (CL:= (ARITY SELF) 1)))
   ITERATOR))

;;; (DEFUN (ALL-MATCHING-EXTENSION-MEMBERS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-MATCHING-EXTENSION-MEMBERS (SELF SPECIALIZE?)
  (CL:LET*
   ((ITERATOR
     (ALL-TRUE-EXTENSION-MEMBERS
      (SURROGATE-TO-DESCRIPTION (%PROPOSITION.OPERATOR SELF))
      SPECIALIZE?)))
   (CL:SETF
    (%DESCRIPTION-EXTENSION-ITERATOR.REFERENCE-PROPOSITION ITERATOR)
    SELF)
   ITERATOR))

;;; (DEFGLOBAL *DUPLICATEINSTANCESCACHECROSSOVERPOINT* ...)

(CL:DEFVAR *DUPLICATEINSTANCESCACHECROSSOVERPOINT* 20
  "Point where a cache of generated instances in a 
description extension iterator is switched from a list to a hash table")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *DUPLICATEINSTANCESCACHECROSSOVERPOINT*))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF DESCRIPTION-EXTENSION-ITERATOR))
  (CL:LET*
   ((WITHINQUERY? (CL:NOT (CL:EQ *QUERYITERATOR* NULL)))
    (PATTERNRECORD
     (CL:IF WITHINQUERY?
      (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*) NULL))
    (UBSTACKOFFSET
     (CL:IF WITHINQUERY?
      (CL:1+
       (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))
      NULL-INTEGER)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
   (CL:LOOP
    (CL:LOOP
     (CL:TAGBODY
      (CL:WHEN
       (CL:NOT
        (NEXT?
         (%DESCRIPTION-EXTENSION-ITERATOR.EXTENSION-ITERATOR SELF)))
       (CL:RETURN))
      (CL:LET*
       ((VALUE
         (%ITERATOR.VALUE
          (%DESCRIPTION-EXTENSION-ITERATOR.EXTENSION-ITERATOR SELF))))
       (CL:WHEN
        (CL:NOT
         (CL:AND
          (CL:AND (CL:NOT (DELETED? VALUE))
           (CL:IF *REVERSEPOLARITY?* (FALSE? VALUE)
            (CL:OR (TRUE? VALUE)
             (FUNCTION-WITH-DEFINED-VALUE? VALUE))))
          (CL:OR
           (CL:EQ
            (%DESCRIPTION-EXTENSION-ITERATOR.REFERENCE-PROPOSITION
             SELF)
            NULL)
           (ARGUMENTS-MATCH-ARGUMENTS? VALUE
            (%DESCRIPTION-EXTENSION-ITERATOR.REFERENCE-PROPOSITION
             SELF)))))
        (CL:GO :CONTINUE))
       (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.VALUE SELF) VALUE)
       (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.TRUTH-VALUE SELF)
        (PROPOSITION-TRUTH-VALUE VALUE))
       (CL:WHEN
        (CL:AND
         (CL:NOT
          (CL:EQ (%DESCRIPTION-EXTENSION-ITERATOR.SUBCOLLECTIONS SELF)
           NULL))
         (CL:NOT
          (CL:EQ (%DESCRIPTION-EXTENSION-ITERATOR.SUBCOLLECTIONS SELF)
           NIL)))
        (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.TRUTH-VALUE SELF)
         (CONJOIN-TRUTH-VALUES
          (%DESCRIPTION-EXTENSION-ITERATOR.TRUTH-VALUE SELF)
          (%%VALUE
           (%%REST
            (%%VALUE
             (%DESCRIPTION-EXTENSION-ITERATOR.SUBCOLLECTIONS
              SELF)))))))
       (CL:WHEN
        (CL:NOT
         (%DESCRIPTION-EXTENSION-ITERATOR.REMOVING-DUPLICATES? SELF))
        (CL:RETURN-FROM NEXT? CL:T))
       (CL:LET*
        ((INSTANCE
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS VALUE)))
           0)))
        (CL:WHEN
         (CL:AND
          (CL:EQ
           (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-TABLE
            SELF)
           NULL)
          (CL:>=
           (LENGTH
            (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-LIST
             SELF))
           *DUPLICATEINSTANCESCACHECROSSOVERPOINT*))
         (CL:LET* ((HASHTABLE (NEW-HASH-TABLE)))
          (CL:LET*
           ((M NULL)
            (ITER-000
             (%LIST.THE-CONS-LIST
              (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-LIST
               SELF))))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
            (CL:SETQ M (%%VALUE ITER-000)) (INSERT-AT HASHTABLE M M)
            (CL:SETQ ITER-000 (%%REST ITER-000))))
          (CL:SETF
           (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-TABLE
            SELF)
           HASHTABLE)))
        (CL:IF
         (CL:NOT
          (CL:EQ
           (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-TABLE
            SELF)
           NULL))
         (CL:WHEN
          (CL:EQ
           (LOOKUP
            (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-TABLE
             SELF)
            INSTANCE)
           NULL)
          (INSERT-AT
           (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-TABLE
            SELF)
           INSTANCE INSTANCE)
          (CL:RETURN-FROM NEXT? CL:T))
         (CL:WHEN
          (CL:NOT
           (MEMBER?
            (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-LIST
             SELF)
            INSTANCE))
          (PUSH
           (%DESCRIPTION-EXTENSION-ITERATOR.ALREADY-GENERATED-LIST
            SELF)
           INSTANCE)
          (CL:RETURN-FROM NEXT? CL:T)))
        (CL:WHEN WITHINQUERY?
         (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD UBSTACKOFFSET))))
      :CONTINUE))
    (CL:LET*
     ((SUBCOLLECTIONS
       (%DESCRIPTION-EXTENSION-ITERATOR.SUBCOLLECTIONS SELF))
      (SUBCOLLECTION NULL))
     (CL:IF (CL:EQ SUBCOLLECTIONS NULL)
      (CL:SETQ SUBCOLLECTIONS
       (ALL-SUPPORTED-NAMED-SUBCOLLECTIONS
        (%DESCRIPTION-EXTENSION-ITERATOR.ROOT-DESCRIPTION SELF)))
      (CL:SETQ SUBCOLLECTIONS (%%REST SUBCOLLECTIONS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ SUBCOLLECTIONS NIL)) DO
      (CL:SETQ SUBCOLLECTION (%%VALUE (%%VALUE SUBCOLLECTIONS)))
      (CL:IF
       (CL:NOT (EMPTY? (GET-DESCRIPTION-EXTENSION SUBCOLLECTION CL:T)))
       (CL:RETURN) (CL:SETQ SUBCOLLECTIONS (%%REST SUBCOLLECTIONS))))
     (CL:WHEN (CL:EQ SUBCOLLECTION NULL) (CL:RETURN))
     (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.EXTENSION-ITERATOR SELF)
      (ALL-EXTENSION-MEMBERS SUBCOLLECTION))
     (CL:SETF (%DESCRIPTION-EXTENSION-ITERATOR.SUBCOLLECTIONS SELF)
      SUBCOLLECTIONS)))
   CL:NIL))

;;; (DEFUN (HELP-FIND-DUPLICATED-GOAL CONTROL-FRAME CONTROL-FRAME INTEGER) ...)

(CL:DEFUN HELP-FIND-DUPLICATED-GOAL (GOALFRAME)
  (CL:LET*
   ((ATOMICGOAL (%CONTROL-FRAME.PROPOSITION GOALFRAME))
    (BINDINGS (%CONTROL-FRAME.GOAL-BINDINGS GOALFRAME)) (DEPTH 1)
    (FIRSTGOALFRAME NULL) (TESTGOAL NULL) (TESTFRAME NULL)
    (RESTARTFRAME NULL) (RESTARTDEPTH NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH RESTARTDEPTH))
   (CL:SETQ TESTFRAME
    (%CONTROL-FRAME.DOWN
     (%QUERY-ITERATOR.BASE-CONTROL-FRAME *QUERYITERATOR*)))
   (CL:LOOP (CL:SETQ TESTGOAL (%CONTROL-FRAME.PROPOSITION TESTFRAME))
    (CL:LET* ((TEST-VALUE-000 CL:NIL))
     (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ TESTGOAL NULL)))
     (CL:WHEN TEST-VALUE-000
      (CL:SETQ TEST-VALUE-000
       (CL:EQ (%PROPOSITION.OPERATOR TESTGOAL)
        (%PROPOSITION.OPERATOR ATOMICGOAL)))
      (CL:WHEN TEST-VALUE-000
       (CL:SETQ TEST-VALUE-000
        (CL:EQ (%CONTROL-FRAME.REVERSE-POLARITY? TESTFRAME)
         (%CONTROL-FRAME.REVERSE-POLARITY? GOALFRAME)))
       (CL:WHEN TEST-VALUE-000
        (CL:IF
         (CL:AND (CL:EQ BINDINGS NULL)
          (CL:EQ (%CONTROL-FRAME.GOAL-BINDINGS TESTFRAME) NULL))
         (CL:SETQ TEST-VALUE-000 CL:T)
         (CL:PROGN
          (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ BINDINGS NULL)))
          (CL:WHEN TEST-VALUE-000
           (CL:SETQ TEST-VALUE-000
            (CL:NOT
             (CL:EQ (%CONTROL-FRAME.GOAL-BINDINGS TESTFRAME) NULL)))
           (CL:WHEN TEST-VALUE-000
            (CL:LET* ((ALWAYS?-000 CL:T))
             (CL:LET*
              ((B1 NULL) (ITER-000 BINDINGS) (B2 NULL)
               (ITER-001 (%CONTROL-FRAME.GOAL-BINDINGS TESTFRAME)))
              (CL:LOOP WHILE
               (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
                (CL:NOT (CL:EQ ITER-001 NIL)))
               DO (CL:SETQ B1 (%%VALUE ITER-000))
               (CL:SETQ B2 (%%VALUE ITER-001))
               (CL:WHEN (CL:NOT (EQL? B1 B2))
                (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
               (CL:SETQ ITER-000 (%%REST ITER-000))
               (CL:SETQ ITER-001 (%%REST ITER-001))))
             (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))))))))
     (CL:WHEN TEST-VALUE-000
      (CL:IF (CL:EQ FIRSTGOALFRAME NULL)
       (CL:SETQ FIRSTGOALFRAME TESTFRAME)
       (CL:RETURN-FROM HELP-FIND-DUPLICATED-GOAL
        (CL:VALUES FIRSTGOALFRAME RESTARTFRAME RESTARTDEPTH)))))
    (CL:SETQ RESTARTFRAME TESTFRAME) (CL:SETQ RESTARTDEPTH DEPTH)
    (CL:SETQ TESTFRAME (%CONTROL-FRAME.DOWN TESTFRAME))
    (CL:SETQ DEPTH (CL:1+ DEPTH))
    (CL:WHEN (CL:EQ TESTFRAME NULL)
     (CL:RETURN-FROM HELP-FIND-DUPLICATED-GOAL
      (CL:VALUES NULL NULL NULL-INTEGER))))))

;;; (DEFUN (FIND-DUPLICATED-GOAL CONTROL-FRAME CONTROL-FRAME INTEGER) ...)

(CL:DEFUN FIND-DUPLICATED-GOAL (FRAME)
  (CL:LET*
   ((TRIALFRAME FRAME) (TRIALGOAL NULL)
    (FIRSTREALCONTROLFRAME
     (%CONTROL-FRAME.DOWN
      (%QUERY-ITERATOR.BASE-CONTROL-FRAME *QUERYITERATOR*))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ TRIALFRAME FIRSTREALCONTROLFRAME)) DO
    (CL:SETQ TRIALGOAL (%CONTROL-FRAME.PROPOSITION TRIALFRAME))
    (CL:WHEN (CL:NOT (CL:EQ TRIALGOAL NULL))
     (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND TRIALGOAL)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-000 KWD-QUERY-ISA)
         (CL:EQ TEST-VALUE-000 KWD-QUERY-PREDICATE)
         (CL:EQ TEST-VALUE-000 KWD-QUERY-FUNCTION))
        (CL:LET*
         ((GOALFRAME NULL) (RESTARTFRAME NULL)
          (RESTARTDEPTH NULL-INTEGER))
         (CL:DECLARE (CL:TYPE CL:FIXNUM RESTARTDEPTH))
         (CL:MULTIPLE-VALUE-SETQ (GOALFRAME RESTARTFRAME RESTARTDEPTH)
          (HELP-FIND-DUPLICATED-GOAL TRIALFRAME))
         (CL:WHEN (CL:NOT (CL:EQ GOALFRAME NULL))
          (TRACE-GOAL-CACHE "DUPLICATED GOAL: " TRIALFRAME)
          (CL:WHEN
           (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
            (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES))
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
            "   RESTART DEPTH " RESTARTDEPTH EOL))
          (CL:RETURN-FROM FIND-DUPLICATED-GOAL
           (CL:VALUES GOALFRAME RESTARTFRAME RESTARTDEPTH)))))
       (CL:T))))
    (CL:SETQ TRIALFRAME (%CONTROL-FRAME.UP TRIALFRAME)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "FAILED TO FIND DUPLICATE GOAL" EOL))
   (CL:SETF
    (%QUERY-ITERATOR.FAILED-TO-FIND-DUPLICATE-SUBGOAL? *QUERYITERATOR*)
    CL:T)
   (CL:VALUES NULL NULL NULL-INTEGER)))

;;; (DEFUN (HANDLE-DEPTH-VIOLATION CONTROL-FRAME INTEGER) ...)

(CL:DEFUN HANDLE-DEPTH-VIOLATION (FRAME DEPTH)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
  #+MCL
  (CL:CHECK-TYPE DEPTH CL:FIXNUM)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (CL:OR (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE)
     (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES)))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "*** Inference depth cutoff: depth=" DEPTH EOL))
  (CL:SETF (%QUERY-ITERATOR.TRIGGERED-DEPTH-CUTOFF? *QUERYITERATOR*)
   CL:T)
  (CL:WHEN
   (CL:AND (CL:OR *CACHE-SUCCEEDED-GOALS?* *CACHE-FAILED-GOALS?*)
    (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
    (CL:NOT
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT
       (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
        NULL)))))
   (DONT-CACHE-GOAL-FAILURE-BETWEEN-FRAMES FRAME
    (%QUERY-ITERATOR.BASE-CONTROL-FRAME *QUERYITERATOR*)))
  (REGISTER-INFERENCE-CUTOFF FRAME KWD-QUERY-DEPTH-VIOLATION)
  (CL:COND
   ((CL:OR
     (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
     (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY*
      KWD-QUERY-DUPLICATE-GOALS-WITH-CACHING))
    (SET-FRAME-TRUTH-VALUE FRAME UNKNOWN-TRUTH-VALUE)
    (CL:WHEN
     (CL:AND
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT
        (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
         NULL)))
      (CL:EQ (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME) NULL))
     (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME NULL)
     (SET-FRAME-PARTIAL-TRUTH
      (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME) NULL 0.0d0 NULL-FLOAT
      CL:T))
    (CL:WHEN *RECORD-JUSTIFICATIONS?*
     (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY)))
      (CL:SETF (%PRIMITIVE-STRATEGY.INFERENCE-RULE SELF-000)
       KWD-QUERY-DEPTH-CUTOFF)
      (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-000)
       KWD-QUERY-FAILURE)
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
    (CL:SETF (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-POPPED)
    (CL:SETF (%CONTROL-FRAME.RESULT (%CONTROL-FRAME.UP FRAME)) FRAME)
    (CL:SETQ FRAME (%CONTROL-FRAME.UP FRAME))
    (CL:SETQ DEPTH (CL:1- DEPTH)))
   (CL:T
    (CL:LET*
     ((GOALFRAME NULL) (RESTARTFRAME NULL) (RESTARTDEPTH NULL-INTEGER))
     (CL:DECLARE (CL:TYPE CL:FIXNUM RESTARTDEPTH))
     (CL:MULTIPLE-VALUE-SETQ (GOALFRAME RESTARTFRAME RESTARTDEPTH)
      (FIND-DUPLICATED-GOAL FRAME))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ GOALFRAME NULL))
       (CL:EQ (FIND-GOAL-CACHE GOALFRAME) NULL)
       (CREATE-GOAL-CACHE? GOALFRAME))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
        (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "*** Inference restart: restartDepth=" RESTARTDEPTH EOL))
      (CL:WHEN (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN RESTARTFRAME) NULL))
       (POP-FRAMES-UP-TO (%CONTROL-FRAME.DOWN RESTARTFRAME))
       (CL:SETF (%CONTROL-FRAME.DOWN RESTARTFRAME) NULL))
      (CL:SETQ FRAME RESTARTFRAME) (CL:SETQ DEPTH RESTARTDEPTH)))))
  (CL:VALUES FRAME DEPTH))

;;; (DEFUN (HANDLE-TIMEOUT CONTROL-FRAME INTEGER) ...)

(CL:DEFUN HANDLE-TIMEOUT (FRAME DEPTH)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
  #+MCL
  (CL:CHECK-TYPE DEPTH CL:FIXNUM)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "*** Timeout: start=" (%CONTROL-FRAME.STARTING-CLOCK-TICKS FRAME)
    " depth=" DEPTH EOL))
  (CL:WHEN
   (CL:AND (CL:OR *CACHE-SUCCEEDED-GOALS?* *CACHE-FAILED-GOALS?*)
    (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
    (CL:NOT
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT
       (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
        NULL)))))
   (DONT-CACHE-GOAL-FAILURE-BETWEEN-FRAMES FRAME
    (%QUERY-ITERATOR.BASE-CONTROL-FRAME *QUERYITERATOR*)))
  (REGISTER-INFERENCE-CUTOFF FRAME KWD-QUERY-TIMEOUT)
  (SET-FRAME-TRUTH-VALUE FRAME UNKNOWN-TRUTH-VALUE)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
    (CL:NOT
     (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
      NULL)))
   (CL:WHEN (CL:EQ (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME) NULL)
    (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME NULL))
   (SET-FRAME-PARTIAL-TRUTH (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)
    NULL 0.0d0 NULL-FLOAT CL:T))
  (CL:WHEN *RECORD-JUSTIFICATIONS?*
   (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY)))
    (CL:SETF (%PRIMITIVE-STRATEGY.INFERENCE-RULE SELF-000)
     KWD-QUERY-TIMEOUT)
    (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-000) KWD-QUERY-FAILURE)
    (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
  (CL:SETF (%CONTROL-FRAME.STATE FRAME) KWD-QUERY-POPPED)
  (CL:SETF (%CONTROL-FRAME.RESULT (%CONTROL-FRAME.UP FRAME)) FRAME)
  (CL:SETQ FRAME (%CONTROL-FRAME.UP FRAME))
  (CL:SETQ DEPTH (CL:1- DEPTH))
  (CL:VALUES FRAME DEPTH))

(CL:DEFUN NEW-QUERY-SOLUTION-TABLE ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-QUERY-SOLUTION-TABLE))
   (CL:SETF (%QUERY-SOLUTION-TABLE.LAST SELF) NULL)
   (CL:SETF (%QUERY-SOLUTION-TABLE.FIRST SELF) NULL)
   (CL:SETF (%QUERY-SOLUTION-TABLE.QUERY SELF) NULL)
   (CL:LET* ((SELF-000 (NEW-KEY-VALUE-MAP)))
    (CL:SETF (%KEY-VALUE-MAP.EQUAL-TEST? SELF-000) CL:T)
    (CL:SETF (%QUERY-SOLUTION-TABLE.THE-MAP SELF) SELF-000))
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF QUERY-SOLUTION-TABLE))
  SGT-QUERY-LOGIC-QUERY-SOLUTION-TABLE)

(CL:DEFUN ACCESS-QUERY-SOLUTION-TABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-STELLA-THE-MAP)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-SOLUTION-TABLE.THE-MAP SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-SOLUTION-TABLE.THE-MAP SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-QUERY)
    (CL:IF SETVALUE? (CL:SETF (%QUERY-SOLUTION-TABLE.QUERY SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-SOLUTION-TABLE.QUERY SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-STELLA-FIRST)
    (CL:IF SETVALUE? (CL:SETF (%QUERY-SOLUTION-TABLE.FIRST SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-SOLUTION-TABLE.FIRST SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-STELLA-LAST)
    (CL:IF SETVALUE? (CL:SETF (%QUERY-SOLUTION-TABLE.LAST SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-SOLUTION-TABLE.LAST SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFUN NEW-QUERY-SOLUTION ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-QUERY-SOLUTION))
   (CL:SETF (%QUERY-SOLUTION.NEXT SELF) NULL)
   (CL:SETF (%QUERY-SOLUTION.ALL-JUSTIFICATIONS SELF) NULL)
   (CL:SETF (%QUERY-SOLUTION.JUSTIFICATION SELF) NULL)
   (CL:SETF (%QUERY-SOLUTION.MATCH-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%QUERY-SOLUTION.TRUTH-VALUE SELF) NULL)
   (CL:SETF (%QUERY-SOLUTION.BINDINGS SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF QUERY-SOLUTION))
  SGT-QUERY-LOGIC-QUERY-SOLUTION)

(CL:DEFUN ACCESS-QUERY-SOLUTION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-BINDINGS)
    (CL:IF SETVALUE? (CL:SETF (%QUERY-SOLUTION.BINDINGS SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-SOLUTION.BINDINGS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TRUTH-VALUE)
    (CL:IF SETVALUE? (CL:SETF (%QUERY-SOLUTION.TRUTH-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-SOLUTION.TRUTH-VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-MATCH-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-SOLUTION.MATCH-SCORE SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%QUERY-SOLUTION.MATCH-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-JUSTIFICATION)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-SOLUTION.JUSTIFICATION SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-SOLUTION.JUSTIFICATION SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-BEST-JUSTIFICATION)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-SOLUTION.JUSTIFICATION SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-SOLUTION.JUSTIFICATION SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ALL-JUSTIFICATIONS)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-SOLUTION.ALL-JUSTIFICATIONS SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-SOLUTION.ALL-JUSTIFICATIONS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-STELLA-NEXT)
    (CL:IF SETVALUE? (CL:SETF (%QUERY-SOLUTION.NEXT SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-SOLUTION.NEXT SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF QUERY-SOLUTION-TABLE) KEY)
  "Lookup the solution identified by `key' in `self' and
return its value, or NULL if no such solution exists."
  (LOOKUP (%QUERY-SOLUTION-TABLE.THE-MAP SELF) KEY))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF QUERY-SOLUTION-TABLE) KEY VALUE)
  "Insert `value' identified by `key' into `self'.  If a solution
with that key already exists, destructively modify it with the slot values of
`value'.  This is necessary to preserve the order of solutions in `self'."
  (CL:LET*
   ((MAP (%QUERY-SOLUTION-TABLE.THE-MAP SELF))
    (DUPLICATE (LOOKUP MAP KEY)))
   (CL:COND
    ((CL:NOT (CL:EQ DUPLICATE NULL))
     (CL:SETF (%QUERY-SOLUTION.TRUTH-VALUE DUPLICATE)
      (%QUERY-SOLUTION.TRUTH-VALUE VALUE))
     (CL:SETF (%QUERY-SOLUTION.MATCH-SCORE DUPLICATE)
      (%QUERY-SOLUTION.MATCH-SCORE VALUE))
     (CL:SETF (%QUERY-SOLUTION.JUSTIFICATION DUPLICATE)
      (%QUERY-SOLUTION.JUSTIFICATION VALUE))
     (CL:SETF (%QUERY-SOLUTION.ALL-JUSTIFICATIONS DUPLICATE)
      (%QUERY-SOLUTION.ALL-JUSTIFICATIONS VALUE)))
    (CL:T (INSERT-AT MAP KEY VALUE)
     (CL:COND
      ((CL:EQ (%QUERY-SOLUTION-TABLE.FIRST SELF) NULL)
       (CL:SETF (%QUERY-SOLUTION-TABLE.FIRST SELF) VALUE)
       (CL:SETF (%QUERY-SOLUTION-TABLE.LAST SELF) VALUE))
      (CL:T
       (CL:SETF
        (%QUERY-SOLUTION.NEXT (%QUERY-SOLUTION-TABLE.LAST SELF)) VALUE)
       (CL:SETF (%QUERY-SOLUTION-TABLE.LAST SELF) VALUE)))))))

;;; (DEFMETHOD (DELETED? BOOLEAN) ...)

(CL:DEFMETHOD DELETED? ((SELF QUERY-SOLUTION))
  (CL:EQ (%QUERY-SOLUTION.BINDINGS SELF) NULL))

;;; (DEFMETHOD (DELETED?-SETTER BOOLEAN) ...)

(CL:DEFMETHOD DELETED?-SETTER ((SELF QUERY-SOLUTION) VALUE)
  (CL:IF VALUE (CL:SETF (%QUERY-SOLUTION.BINDINGS SELF) NULL)
   (CL:SETF (%QUERY-SOLUTION.BINDINGS SELF) (VECTOR)))
  VALUE)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF QUERY-SOLUTION-TABLE) KEY)
  "Remove the solution identified by `key' from `self'.
To preserve the solution ordering chain, the solution is marked as deleted
and will be completely removed upon the next iteration through `self'."
  (CL:LET*
   ((MAP (%QUERY-SOLUTION-TABLE.THE-MAP SELF))
    (SOLUTION (LOOKUP MAP KEY)))
   (CL:WHEN (CL:NOT (CL:EQ SOLUTION NULL)) (REMOVE-AT MAP KEY)
    (DELETED?-SETTER SOLUTION CL:T))))

;;; (DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD POP ((SELF QUERY-SOLUTION-TABLE))
  "Remove and return the first solution of `self' or NULL
if the table is empty."
  (CL:LET* ((FIRST (%QUERY-SOLUTION-TABLE.FIRST SELF)))
   (CL:WHEN (CL:NOT (CL:EQ FIRST NULL))
    (CL:SETF (%QUERY-SOLUTION-TABLE.FIRST SELF)
     (%QUERY-SOLUTION.NEXT FIRST))
    (CL:WHEN (CL:EQ FIRST (%QUERY-SOLUTION-TABLE.LAST SELF))
     (CL:SETF (%QUERY-SOLUTION-TABLE.LAST SELF) NULL))
    (REMOVE-AT (%QUERY-SOLUTION-TABLE.THE-MAP SELF)
     (%QUERY-SOLUTION.BINDINGS FIRST)))
   FIRST))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF QUERY-SOLUTION-TABLE))
  "Return the number of entries in `self'."
  (LENGTH (%QUERY-SOLUTION-TABLE.THE-MAP SELF)))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF QUERY-SOLUTION-TABLE))
  "Return TRUE if `self' has zero entries."
  (EMPTY? (%QUERY-SOLUTION-TABLE.THE-MAP SELF)))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF QUERY-SOLUTION-TABLE))
  "Return TRUE if `self' has at least 1 entry."
  (NON-EMPTY? (%QUERY-SOLUTION-TABLE.THE-MAP SELF)))

;;; (DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH ((SELF QUERY-SOLUTION-TABLE) POSITION)
  "Return the nth solution in `self', or NULL if it is empty."
  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
  #+MCL
  (CL:CHECK-TYPE POSITION CL:FIXNUM)
  (CL:LET* ((SOLUTION NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ SOLUTION (%DICTIONARY-ITERATOR.VALUE ITER-000))
    (CL:IF (CL:= POSITION 0) (CL:RETURN-FROM NTH SOLUTION)
     (CL:SETQ POSITION (CL:1- POSITION)))))
  NULL)

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF QUERY-SOLUTION-TABLE))
  (CLEAR (%QUERY-SOLUTION-TABLE.THE-MAP SELF))
  (CL:SETF (%QUERY-SOLUTION-TABLE.FIRST SELF) NULL)
  (CL:SETF (%QUERY-SOLUTION-TABLE.LAST SELF) NULL))

;;; (DEFMETHOD (CONSIFY CONS) ...)

(CL:DEFMETHOD CONSIFY ((SELF QUERY-SOLUTION-TABLE))
  "Collect all solutions of `self' into a cons list and return the result."
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((SOLUTION NULL) (ITER-000 (ALLOCATE-ITERATOR SELF))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ SOLUTION (%DICTIONARY-ITERATOR.VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS SOLUTION NIL))
       (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS SOLUTION NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   RESULT))

;;; (DEFMETHOD (SORT (LIKE SELF)) ...)

(CL:DEFMETHOD SORT ((SELF QUERY-SOLUTION-TABLE) PREDICATE)
  "Perform a stable, destructive sort of `self' according to
`predicate', and return the result.  If `predicate' has a '<' semantics, the
result will be in ascending order."
  (CL:LET*
   ((SOLUTIONS (SORT (CONSIFY SELF) PREDICATE)) (CURRENT NULL)
    (NEXT NULL))
   (CL:SETF (%QUERY-SOLUTION-TABLE.FIRST SELF) (%%VALUE SOLUTIONS))
   (CL:SETF (%QUERY-SOLUTION-TABLE.LAST SELF) (%%VALUE SOLUTIONS))
   (CL:LOOP (CL:SETQ CURRENT (%%VALUE SOLUTIONS))
    (CL:COND
     ((CL:NOT (CL:EQ CURRENT NULL))
      (CL:SETQ NEXT (%%VALUE (%%REST SOLUTIONS)))
      (CL:SETF (%QUERY-SOLUTION.NEXT CURRENT) NEXT)
      (CL:WHEN (CL:EQ NEXT NULL)
       (CL:SETF (%QUERY-SOLUTION-TABLE.LAST SELF) CURRENT))
      (CL:SETQ SOLUTIONS (%%REST SOLUTIONS)))
     (CL:T (CL:RETURN))))
   SELF))

(CL:DEFUN NEW-QUERY-SOLUTION-TABLE-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-QUERY-SOLUTION-TABLE-ITERATOR))
   (CL:SETF (%QUERY-SOLUTION-TABLE-ITERATOR.FIRST-ITERATION? SELF)
    CL:T)
   (CL:SETF (%QUERY-SOLUTION-TABLE-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%QUERY-SOLUTION-TABLE-ITERATOR.KEY SELF) NULL)
   (CL:SETF (%QUERY-SOLUTION-TABLE-ITERATOR.CURSOR SELF) NULL)
   (CL:SETF (%QUERY-SOLUTION-TABLE-ITERATOR.THE-TABLE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF QUERY-SOLUTION-TABLE-ITERATOR))
  SGT-QUERY-LOGIC-QUERY-SOLUTION-TABLE-ITERATOR)

(CL:DEFUN ACCESS-QUERY-SOLUTION-TABLE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-STELLA-THE-TABLE)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-SOLUTION-TABLE-ITERATOR.THE-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-SOLUTION-TABLE-ITERATOR.THE-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-STELLA-CURSOR)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-SOLUTION-TABLE-ITERATOR.CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-SOLUTION-TABLE-ITERATOR.CURSOR SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (ALLOCATE-ITERATOR DICTIONARY-ITERATOR) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF QUERY-SOLUTION-TABLE))
  (CL:LET* ((SELF-000 (NEW-QUERY-SOLUTION-TABLE-ITERATOR)))
   (CL:SETF (%QUERY-SOLUTION-TABLE-ITERATOR.THE-TABLE SELF-000) SELF)
   (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF QUERY-SOLUTION-TABLE-ITERATOR))
  (CL:LET*
   ((TABLE (%QUERY-SOLUTION-TABLE-ITERATOR.THE-TABLE SELF))
    (CURSOR (%QUERY-SOLUTION-TABLE-ITERATOR.CURSOR SELF))
    (PREVIOUS CURSOR))
   (CL:COND
    ((%QUERY-SOLUTION-TABLE-ITERATOR.FIRST-ITERATION? SELF)
     (CL:SETQ PREVIOUS NULL)
     (CL:SETQ CURSOR (%QUERY-SOLUTION-TABLE.FIRST TABLE))
     (CL:SETF (%QUERY-SOLUTION-TABLE-ITERATOR.FIRST-ITERATION? SELF)
      CL:NIL))
    (CL:T (CL:SETQ PREVIOUS CURSOR)
     (CL:SETQ CURSOR (%QUERY-SOLUTION.NEXT CURSOR))))
   (CL:LOOP WHILE
    (CL:AND (CL:NOT (CL:EQ CURSOR NULL)) (DELETED? CURSOR)) DO
    (CL:SETQ CURSOR (%QUERY-SOLUTION.NEXT CURSOR)))
   (CL:SETF (%QUERY-SOLUTION-TABLE-ITERATOR.CURSOR SELF) CURSOR)
   (CL:COND
    ((CL:NOT (CL:EQ CURSOR NULL))
     (CL:IF (CL:EQ PREVIOUS NULL)
      (CL:SETF (%QUERY-SOLUTION-TABLE.FIRST TABLE) CURSOR)
      (CL:SETF (%QUERY-SOLUTION.NEXT PREVIOUS) CURSOR))
     (CL:SETF (%QUERY-SOLUTION-TABLE-ITERATOR.KEY SELF)
      (%QUERY-SOLUTION.BINDINGS CURSOR))
     (CL:SETF (%QUERY-SOLUTION-TABLE-ITERATOR.VALUE SELF) CURSOR)
     (CL:RETURN-FROM NEXT? CL:T))
    ((CL:NOT (CL:EQ PREVIOUS NULL))
     (CL:SETF (%QUERY-SOLUTION.NEXT PREVIOUS) NULL)
     (CL:SETF (%QUERY-SOLUTION-TABLE.LAST TABLE) PREVIOUS)))
   CL:NIL))

;;; (DEFUN PRINT-CONTROL-FRAME ...)

(CL:DEFUN PRINT-CONTROL-FRAME (SELF STREAM)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-QUERY-LOGIC-PARALLEL-CONTROL-FRAME)
    (CL:PROGN
     (%%PRINT-STREAM STREAM "|PLL-CF|" (DEBUG-FRAME-ID SELF) "[")))
   (CL:T (%%PRINT-STREAM STREAM "|CF|" (DEBUG-FRAME-ID SELF) "[")))
  (CL:IF (DEFINED? (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET SELF))
   (%%PRINT-STREAM STREAM
    (%CONTROL-FRAME.CHOICE-POINT-UNBINDING-OFFSET SELF))
   (%%PRINT-STREAM STREAM "_"))
  (CL:LET* ((*PRINTINFRAME* SELF))
   (CL:DECLARE (CL:SPECIAL *PRINTINFRAME*))
   (CL:LET*
    ((PRINTTIMES?
      (DEFINED? (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS SELF))))
    (%%PRINT-STREAM STREAM " " (%CONTROL-FRAME.STATE SELF) " "
     (%CONTROL-FRAME.CURRENT-STRATEGY SELF))
    (CL:IF (CL:NOT (CL:EQ (%CONTROL-FRAME.UP SELF) NULL))
     (%%PRINT-STREAM STREAM "  UP: "
      (DEBUG-FRAME-ID (%CONTROL-FRAME.UP SELF)))
     (%%PRINT-STREAM STREAM "  UP: -"))
    (CL:IF (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN SELF) NULL))
     (%%PRINT-STREAM STREAM "  DOWN: "
      (DEBUG-FRAME-ID (%CONTROL-FRAME.DOWN SELF)))
     (%%PRINT-STREAM STREAM "  DOWN: -"))
    (%%PRINT-STREAM STREAM "  DEPTH: " (COMPUTE-FRAME-DEPTH SELF))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS SELF)
        SYM-QUERY-LOGIC-DESCRIPTION NULL)
       NULL))
     (%%PRINT-STREAM STREAM " DESC: "
      (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS SELF)
       SYM-QUERY-LOGIC-DESCRIPTION NULL)))
    (CL:WHEN PRINTTIMES?
     (%%PRINT-STREAM STREAM " CLOCK: "
      (%QUERY-ITERATOR.CURRENT-CLOCK-TICKS *QUERYITERATOR*) " START: "
      (%CONTROL-FRAME.STARTING-CLOCK-TICKS SELF) " TICKS: "
      (%CONTROL-FRAME.ALLOTTED-CLOCK-TICKS SELF)))
    (%%PRINT-STREAM STREAM " " (%CONTROL-FRAME.PROPOSITION SELF) "]"))))

;;; (DEFUN PRINT-GOAL-STACK ...)

(CL:DEFUN PRINT-GOAL-STACK (FRAME VERBOSE?)
  "Print stack of goals.  Assumes that query has been interrupted
with a full stack of control frames."
  (CL:WHEN (CL:NOT (CL:EQ (%CONTROL-FRAME.PROPOSITION FRAME) NULL))
   (CL:LET* ((*PRINTINFRAME* FRAME))
    (CL:DECLARE (CL:SPECIAL *PRINTINFRAME*))
    (CL:IF VERBOSE?
     (CL:PROGN
      (PRINT-CONTROL-FRAME FRAME
       (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       EOL))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      (%CONTROL-FRAME.PROPOSITION FRAME) EOL))))
  (CL:WHEN (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
   (PRINT-GOAL-STACK (%CONTROL-FRAME.DOWN FRAME) VERBOSE?)))

;;; (DEFUN PGS ...)

(CL:DEFUN PGS ()
  (PRINT-GOAL-STACK
   (%QUERY-ITERATOR.BASE-CONTROL-FRAME *QUERYITERATOR*) CL:NIL))

;;; (DEFUN VPGS ...)

(CL:DEFUN VPGS ()
  (PRINT-GOAL-STACK
   (%QUERY-ITERATOR.BASE-CONTROL-FRAME *QUERYITERATOR*) CL:T))

;;; (DEFUN PRINT-QUERY-ITERATOR ...)

(CL:DEFUN PRINT-QUERY-ITERATOR (SELF STREAM)
  (CL:IF *PRINTREADABLY?* (PRINT-QUERY-ITERATOR-READABLY SELF STREAM)
   (PRINT-QUERY-ITERATOR-ORNATELY SELF STREAM)))

;;; (DEFUN PRINT-QUERY-ITERATOR-ORNATELY ...)

(CL:DEFUN PRINT-QUERY-ITERATOR-ORNATELY (SELF STREAM)
  (CL:LET*
   ((SOLUTIONS (%QUERY-ITERATOR.SOLUTIONS SELF))
    (NOFSOLUTIONS (LENGTH SOLUTIONS))
    (EXHAUSTED? (%QUERY-ITERATOR.EXHAUSTED? SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFSOLUTIONS))
   (CL:CASE NOFSOLUTIONS (0 (%%PRINT-STREAM STREAM "No solutions"))
    (1 (%%PRINT-STREAM STREAM "There is 1 solution"))
    (CL:OTHERWISE
     (%%PRINT-STREAM STREAM "There are " NOFSOLUTIONS " solutions")))
   (CL:WHEN (CL:NOT EXHAUSTED?) (%%PRINT-STREAM STREAM " so far"))
   (CL:WHEN (%QUERY-ITERATOR.TIMEOUT? SELF)
    (%%PRINT-STREAM STREAM " (timeout)"))
   (CL:WHEN (CL:= NOFSOLUTIONS 0) (%%PRINT-STREAM STREAM "." EOL)
    (CL:RETURN-FROM PRINT-QUERY-ITERATOR-ORNATELY))
   (%%PRINT-STREAM STREAM ":" EOL)
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (CL:LET*
     ((SOLUTION NULL) (ITER-000 (ALLOCATE-ITERATOR SOLUTIONS))
      (I NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-000 *PRINTLENGTH*)
      (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:AND (NEXT? ITER-000)
       (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)))
      DO (CL:SETQ SOLUTION (%DICTIONARY-ITERATOR.VALUE ITER-000))
      (CL:SETQ I ITER-001)
      (PRINT-QUERY-ITERATOR-SOLUTION-ORNATELY SELF SOLUTION I STREAM)
      (CL:WHEN (CL:< I NOFSOLUTIONS) (%%PRINT-STREAM STREAM EOL))
      (CL:WHEN (CL:AND (CL:= I *PRINTLENGTH*) (CL:< I NOFSOLUTIONS))
       (%%PRINT-STREAM STREAM "  ......" EOL))
      (CL:SETQ ITER-001 (CL:1+ ITER-001)))))))

;;; (DEFUN PRINT-QUERY-ITERATOR-SOLUTION-ORNATELY ...)

(CL:DEFUN PRINT-QUERY-ITERATOR-SOLUTION-ORNATELY (SELF SOLUTION SOLUTIONNUMBER STREAM)
  (CL:DECLARE (CL:TYPE CL:FIXNUM SOLUTIONNUMBER))
  #+MCL
  (CL:CHECK-TYPE SOLUTIONNUMBER CL:FIXNUM)
  (CL:WHEN (NULL? SOLUTIONNUMBER) (CL:SETQ SOLUTIONNUMBER 0)
   (CL:LET*
    ((SOLUTION NULL)
     (ITER-000 (ALLOCATE-ITERATOR (%QUERY-ITERATOR.SOLUTIONS SELF))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ SOLUTION (%DICTIONARY-ITERATOR.VALUE ITER-000))
     (CL:WHEN
      (CL:NOT (EQUAL? (%QUERY-SOLUTION.BINDINGS SOLUTION) SOLUTION))
      (CL:SETQ SOLUTIONNUMBER (CL:1+ SOLUTIONNUMBER))))))
  (CL:LET* ((*PRINTREADABLY?* CL:T))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (%%PRINT-STREAM STREAM "  #" SOLUTIONNUMBER ": ")
   (CL:LET*
    ((VALUE NULL) (VECTOR-000 (%QUERY-SOLUTION.BINDINGS SOLUTION))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (VARIABLE NULL)
     (VECTOR-001 (%QUERY-ITERATOR.EXTERNAL-VARIABLES SELF))
     (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)) (VI NULL-INTEGER)
     (ITER-001 0))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001 VI
      ITER-001))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
     DO
     (CL:SETQ VALUE
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ VARIABLE
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
       INDEX-001))
     (CL:SETQ VI ITER-001)
     (%%PRINT-STREAM STREAM (CL:IF (CL:= VI 0) "" ", ")
      (%PATTERN-VARIABLE.SKOLEM-NAME VARIABLE) "=" VALUE)
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:WHEN
    (CL:AND
     (CL:NOT
      (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY SELF) NULL))
     (CL:NOT (CL:= (%QUERY-SOLUTION.MATCH-SCORE SOLUTION) NULL-FLOAT)))
    (%%PRINT-STREAM STREAM " " (%QUERY-SOLUTION.MATCH-SCORE SOLUTION)))))

;;; (DEFUN TRACE-SOLUTION ...)

(CL:DEFUN TRACE-SOLUTION (SELF SOLUTION SOLUTIONNUMBER)
  (CL:DECLARE (CL:TYPE CL:FIXNUM SOLUTIONNUMBER))
  #+MCL
  (CL:CHECK-TYPE SOLUTIONNUMBER CL:FIXNUM)
  (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-TRACE-SOLUTIONS)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "SOLUTION ")
   (PRINT-QUERY-ITERATOR-SOLUTION-ORNATELY *QUERYITERATOR* SOLUTION
    SOLUTIONNUMBER (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL)))

;;; (DEFUN PRINT-QUERY-ITERATOR-READABLY ...)

(CL:DEFUN PRINT-QUERY-ITERATOR-READABLY (SELF STREAM)
  (CL:LET*
   ((SOLUTIONS (%QUERY-ITERATOR.SOLUTIONS SELF)) (FIRST? CL:T)
    (ATOMICSINGLETONS?
     (CL:AND
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
        SYM-QUERY-LOGIC-ATOMIC-SINGLETONS? FALSE-WRAPPER))
      (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY SELF) NULL))))
   (%%PRINT-STREAM STREAM "(")
   (CL:LET*
    ((SOLUTION NULL) (ITER-000 (ALLOCATE-ITERATOR SOLUTIONS))
     (I NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-000 *PRINTLENGTH*)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (NEXT? ITER-000)
      (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)))
     DO (CL:SETQ SOLUTION (%DICTIONARY-ITERATOR.VALUE ITER-000))
     (CL:SETQ I ITER-001)
     (CL:WHEN (CL:NOT FIRST?)
      (CL:IF ATOMICSINGLETONS? (%%PRINT-STREAM STREAM " ")
       (%%PRINT-STREAM STREAM EOL " ")))
     (CL:SETQ FIRST? CL:NIL)
     (CL:WHEN (CL:NOT ATOMICSINGLETONS?) (%%PRINT-STREAM STREAM "("))
     (CL:LET*
      ((VALUE NULL) (VECTOR-000 (%QUERY-SOLUTION.BINDINGS SOLUTION))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (VI NULL-INTEGER)
       (ITER-002 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 VI ITER-002))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ VALUE
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ VI ITER-002)
       (%%PRINT-STREAM STREAM (CL:IF (CL:= VI 0) "" " ") VALUE)
       (CL:WHEN
        (CL:NOT
         (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY SELF) NULL))
        (%%PRINT-STREAM STREAM " "
         (%QUERY-SOLUTION.MATCH-SCORE SOLUTION)))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
       (CL:SETQ ITER-002 (CL:1+ ITER-002))))
     (CL:WHEN (CL:NOT ATOMICSINGLETONS?) (%%PRINT-STREAM STREAM ")"))
     (CL:WHEN
      (CL:AND (CL:= I *PRINTLENGTH*) (CL:< I (LENGTH SOLUTIONS)))
      (%%PRINT-STREAM STREAM " ..."))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (%%PRINT-STREAM STREAM ")" EOL)))

;;; (DEFUN (ALLOCATE-QUERY-ITERATOR QUERY-ITERATOR) ...)

(CL:DEFUN ALLOCATE-QUERY-ITERATOR ()
  (CL:LET* ((QUERYITERATOR (NEW-QUERY-ITERATOR)))
   (UPDATE-NOW-TIMESTAMP KWD-QUERY-EXECUTE-QUERY)
   (CL:SETF (%QUERY-ITERATOR.TIMESTAMP QUERYITERATOR)
    (GET-NOW-TIMESTAMP))
   QUERYITERATOR))

;;; (DEFMETHOD FREE ...)

(CL:DEFMETHOD FREE ((SELF QUERY-ITERATOR))
  (FREE-QUERY-ITERATOR SELF))

;;; (DEFUN FREE-QUERY-ITERATOR ...)

(CL:DEFUN FREE-QUERY-ITERATOR (SELF)
  (CL:WHEN (CL:EQ (%QUERY-ITERATOR.BASE-CONTROL-FRAME SELF) NULL)
   (CL:RETURN-FROM FREE-QUERY-ITERATOR))
  (FREE (%QUERY-ITERATOR.VALUE SELF))
  (CL:SETF (%QUERY-ITERATOR.BASE-CONTROL-FRAME SELF) NULL))

;;; (DEFUN (ALLOCATE-COLLECTION-VARIABLES VARIABLES-VECTOR) ...)

(CL:DEFUN ALLOCATE-COLLECTION-VARIABLES (FRAME DESCRIPTION)
  (CL:LET*
   ((VARIABLESCOUNT (LENGTH (%DESCRIPTION.IO-VARIABLES DESCRIPTION)))
    (EXTERNALVARIABLES (NEW-VECTOR VARIABLESCOUNT)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM VARIABLESCOUNT))
   (CL:LET*
    ((IOVAR NULL) (VECTOR-000 (%DESCRIPTION.IO-VARIABLES DESCRIPTION))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER)
     (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ IOVAR
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY EXTERNALVARIABLES))
       (VALUE
        (CREATE-VARIABLE (%PATTERN-VARIABLE.SKOLEM-TYPE IOVAR)
         (%PATTERN-VARIABLE.SKOLEM-NAME IOVAR) CL:NIL))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETF
      (%PATTERN-VARIABLE.BOUND-TO-OFFSET
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY EXTERNALVARIABLES))
        I))
      I)
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:WHEN (CL:EQ (%CONTROL-FRAME.PATTERN-RECORD FRAME) NULL)
    (CREATE-PATTERN-RECORD FRAME NULL NULL))
   (ACTIVATE-PATTERN-RECORD (%CONTROL-FRAME.PATTERN-RECORD FRAME)
    VARIABLESCOUNT)
   EXTERNALVARIABLES))

;;; (DEFUN (CREATE-QUERY-ITERATOR QUERY-ITERATOR) ...)

(CL:DEFUN CREATE-QUERY-ITERATOR (DESCRIPTION OUTSIDEBINDINGS)
  (INITIALIZE-QUERY-ITERATOR (ALLOCATE-QUERY-ITERATOR) DESCRIPTION
   OUTSIDEBINDINGS))

;;; (DEFUN (INITIALIZE-QUERY-ITERATOR QUERY-ITERATOR) ...)

(CL:DEFUN INITIALIZE-QUERY-ITERATOR (QUERYITERATOR DESCRIPTION OUTSIDEBINDINGS)
  (CL:LET*
   ((BASECONTROLFRAME (NEW-CONTROL-FRAME)) (EXTERNALVARIABLES NULL))
   (CL:LET*
    ((*QUERYITERATOR* QUERYITERATOR)
     (*EVALUATIONMODE* KWD-QUERY-DESCRIPTION))
    (CL:DECLARE (CL:SPECIAL *QUERYITERATOR* *EVALUATIONMODE*))
    (CL:WHEN
     (TEST-QUERY-OPTION? QUERYITERATOR KWD-QUERY-DONT-OPTIMIZE?)
     (SET-DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
      SYM-QUERY-LOGIC-DONT-OPTIMIZE?
      (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
     (SET-DYNAMIC-SLOT-VALUE
      (%PROPOSITION.DYNAMIC-SLOTS
       (%DESCRIPTION.PROPOSITION DESCRIPTION))
      SYM-QUERY-LOGIC-DONT-OPTIMIZE?
      (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
    (CL:SETF (%QUERY-ITERATOR.QUERY-CONTEXT QUERYITERATOR) *CONTEXT*)
    (CL:SETF (%QUERY-ITERATOR.BASE-CONTROL-FRAME QUERYITERATOR)
     BASECONTROLFRAME)
    (CL:SETF (%QUERY-ITERATOR.CURRENT-CONTROL-FRAME QUERYITERATOR)
     BASECONTROLFRAME)
    (CL:SETQ *CONTROL-FRAME-ID-COUNTER* 0)
    (CL:SETF (%CONTROL-FRAME.PROPOSITION BASECONTROLFRAME)
     (%DESCRIPTION.PROPOSITION DESCRIPTION))
    (CL:SETF (%CONTROL-FRAME.UP BASECONTROLFRAME) NULL)
    (SET-DYNAMIC-SLOT-VALUE
     (%CONTROL-FRAME.DYNAMIC-SLOTS BASECONTROLFRAME)
     SYM-QUERY-LOGIC-GOAL-CACHE NULL NULL)
    (CL:SETF (%CONTROL-FRAME.GOAL-BINDINGS BASECONTROLFRAME) NULL)
    (CL:SETQ EXTERNALVARIABLES
     (ALLOCATE-COLLECTION-VARIABLES BASECONTROLFRAME DESCRIPTION))
    (CL:LET*
     ((*CONTEXT* (GET-QUERY-CONTEXT))
      (*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)))
     (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
     (CL:WHEN (CL:NOT (CL:EQ OUTSIDEBINDINGS NULL))
      (SET-DYNAMIC-SLOT-VALUE
       (%QUERY-ITERATOR.DYNAMIC-SLOTS QUERYITERATOR)
       SYM-QUERY-LOGIC-INITIAL-BINDINGS OUTSIDEBINDINGS NULL)
      (CL:WHEN
       (CL:> (LENGTH OUTSIDEBINDINGS) (LENGTH EXTERNALVARIABLES))
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "Arity mismatch between bindings `" OUTSIDEBINDINGS
         "' and external variables `" EXTERNALVARIABLES "'.")
        (CL:ERROR
         (NEW-FAIL-EXCEPTION (THE-STRING-READER STREAM-000)))))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 EXTERNALVARIABLES) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)) (VALUE NULL)
        (VECTOR-001 OUTSIDEBINDINGS) (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-000 LENGTH-000)
         (CL:< INDEX-001 LENGTH-001))
        DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ VALUE
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ VALUE NULL))
          (CL:NOT (BIND-ARGUMENT-TO-VALUE? ARG VALUE CL:NIL)))
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
           "Binding of `" ARG "' to `" VALUE "' failed.")
          (CL:ERROR
           (NEW-FAIL-EXCEPTION (THE-STRING-READER STREAM-001)))))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
     (OVERLAY-WITH-PATTERN-FRAME? BASECONTROLFRAME DESCRIPTION
      EXTERNALVARIABLES))
    (CL:SETF
     (%QUERY-ITERATOR.CONTROL-FRAME-PRIORITY-QUEUE QUERYITERATOR)
     (NEW-CONTROL-FRAME-PRIORITY-QUEUE))
    (CL:WHEN (NULL? (%QUERY-ITERATOR.MAXIMUM-DEPTH QUERYITERATOR))
     (CL:SETF (%QUERY-ITERATOR.MAXIMUM-DEPTH QUERYITERATOR)
      *MAXIMUM-BACKTRACKING-DEPTH*))
    (CL:SETF (%QUERY-ITERATOR.AUGMENTED-GOAL-CACHE? QUERYITERATOR)
     CL:NIL)
    (CLEAR (%QUERY-ITERATOR.ACTIVE-GOAL-CACHES QUERYITERATOR))
    (CL:WHEN
     (CL:AND *ITERATIVE-DEEPENING-MODE?*
      (CL:NOT
       (TEST-QUERY-OPTION? QUERYITERATOR
        KWD-QUERY-ITERATIVE-DEEPENING?)))
     (SET-DYNAMIC-SLOT-VALUE
      (%QUERY-ITERATOR.DYNAMIC-SLOTS QUERYITERATOR)
      SYM-QUERY-LOGIC-ITERATIVE-DEEPENING?
      (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
    (CL:SETF (%QUERY-ITERATOR.CURRENT-DEPTH-CUTOFF QUERYITERATOR)
     (CL:IF
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE
        (%QUERY-ITERATOR.DYNAMIC-SLOTS QUERYITERATOR)
        SYM-QUERY-LOGIC-ITERATIVE-DEEPENING? FALSE-WRAPPER))
      (MIN *INITIAL-BACKTRACKING-DEPTH*
       (%QUERY-ITERATOR.MAXIMUM-DEPTH QUERYITERATOR))
      (%QUERY-ITERATOR.MAXIMUM-DEPTH QUERYITERATOR)))
    (CL:SETF (%QUERY-ITERATOR.TRIGGERED-DEPTH-CUTOFF? QUERYITERATOR)
     CL:NIL)
    (CL:SETF
     (%QUERY-ITERATOR.FAILED-TO-FIND-DUPLICATE-SUBGOAL? QUERYITERATOR)
     CL:NIL)
    (CL:SETF
     (%QUERY-ITERATOR.FOUND-AT-LEAST-ONE-SOLUTION? QUERYITERATOR)
     CL:NIL)
    (CL:SETF (%QUERY-ITERATOR.EXTERNAL-VARIABLES QUERYITERATOR)
     EXTERNALVARIABLES)
    QUERYITERATOR)))

;;; (DEFMETHOD (QUERY-PROPOSITION PROPOSITION) ...)

(CL:DEFMETHOD QUERY-PROPOSITION ((SELF QUERY-ITERATOR))
  (%CONTROL-FRAME.PROPOSITION (%QUERY-ITERATOR.BASE-CONTROL-FRAME SELF)))

;;; (DEFMETHOD (QUERY-DESCRIPTION DESCRIPTION) ...)

(CL:DEFMETHOD QUERY-DESCRIPTION ((SELF QUERY-ITERATOR))
  (%PATTERN-RECORD.DESCRIPTION
   (%CONTROL-FRAME.PATTERN-RECORD
    (%QUERY-ITERATOR.BASE-CONTROL-FRAME SELF))))

;;; (DEFMETHOD (QUERY-IS-TRUE-FALSE? BOOLEAN) ...)

(CL:DEFMETHOD QUERY-IS-TRUE-FALSE? ((SELF QUERY-ITERATOR))
  (CL:WHEN
   (CL:= (%VECTOR.ARRAY-SIZE (%QUERY-ITERATOR.EXTERNAL-VARIABLES SELF))
    0)
   (CL:RETURN-FROM QUERY-IS-TRUE-FALSE? CL:T))
  (CL:LET*
   ((PATTERNRECORD
     (%CONTROL-FRAME.PATTERN-RECORD
      (%QUERY-ITERATOR.BASE-CONTROL-FRAME SELF))))
   (CL:LET* ((ALWAYS?-000 CL:T))
    (CL:LET*
     ((IGNORED-ARG NULL)
      (VECTOR-000 (%PATTERN-RECORD.EXTERNAL-ARGUMENTS PATTERNRECORD))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (BOUND? NULL)
      (VECTOR-001 (%PATTERN-RECORD.BOOLEAN-VECTOR PATTERNRECORD))
      (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
      DO
      (CL:SETQ IGNORED-ARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ BOUND?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
        INDEX-001))
      (CL:WHEN (CL:NOT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN BOUND?))
       (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
    (CL:LET* ((VALUE-000 ALWAYS?-000)) VALUE-000))))

;;; (DEFMETHOD (QUERY-IS-PARTIAL? BOOLEAN) ...)

(CL:DEFMETHOD QUERY-IS-PARTIAL? ((SELF QUERY-ITERATOR))
  (CL:WHEN
   (CL:NOT (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY SELF) NULL))
   (CL:RETURN-FROM QUERY-IS-PARTIAL? CL:T))
  (CL:LET*
   ((MATCHMODE (LOOKUP-QUERY-OPTION SELF KWD-QUERY-MATCH-MODE)))
   (CL:AND (CL:NOT (CL:EQ MATCHMODE NULL))
    (CL:NOT (CL:EQ MATCHMODE KWD-QUERY-STRICT)))))

;;; (DEFMETHOD (QUERY-SUCCEEDED? BOOLEAN) ...)

(CL:DEFMETHOD QUERY-SUCCEEDED? ((SELF QUERY-ITERATOR))
  (NON-EMPTY? (%QUERY-ITERATOR.SOLUTIONS SELF)))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF QUERY-ITERATOR))
  (CL:WHEN (%QUERY-ITERATOR.EXHAUSTED? SELF)
   (CL:RETURN-FROM NEXT? CL:NIL))
  (CL:LET* ((BASEFRAME (%QUERY-ITERATOR.BASE-CONTROL-FRAME SELF)))
   (CL:LET* ((SELF-000 (NEW-QUERY-SOLUTION)))
    (CL:SETF (%QUERY-SOLUTION.BINDINGS SELF-000)
     (NEW-VECTOR (LENGTH (%QUERY-ITERATOR.EXTERNAL-VARIABLES SELF))))
    (CL:SETF (%QUERY-SOLUTION.TRUTH-VALUE SELF-000)
     UNKNOWN-TRUTH-VALUE)
    (CL:LET* ((SOLUTION SELF-000) (DUPLICATE NULL))
     (CL:SETF (%QUERY-ITERATOR.VALUE SELF) SOLUTION)
     (CL:WHEN (%QUERY-ITERATOR.FIRST-ITERATION? SELF)
      (CL:SETF (%QUERY-ITERATOR.FIRST-ITERATION? SELF) CL:NIL)
      (CL:LET*
       ((SKIPPEDOPTIONS
         (LOOKUP-QUERY-OPTION SELF KWD-QUERY-DEFERRED-OPTIONS)))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ SKIPPEDOPTIONS NULL))
         (NON-EMPTY? SKIPPEDOPTIONS))
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
           "PARSING ERROR: Illegal query option(s): `" SKIPPEDOPTIONS
           "'." EOL)
          (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-QUERY-ERROR))
         (CL:ERROR
          (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))))
     (CL:LOOP
      (CL:LET*
       ((*CONTEXT* (GET-QUERY-CONTEXT))
        (*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)))
       (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
       (CL:LOOP
        (CL:TAGBODY (CLEAR (%QUERY-SOLUTION.BINDINGS SOLUTION))
         (CL:SETF (%QUERY-SOLUTION.TRUTH-VALUE SOLUTION)
          UNKNOWN-TRUTH-VALUE)
         (CL:SETF (%QUERY-SOLUTION.JUSTIFICATION SOLUTION) NULL)
         (CL:SETF (%QUERY-SOLUTION.MATCH-SCORE SOLUTION) NULL-FLOAT)
         (CL:WHEN (CL:NOT (EXECUTE-BACKWARD-CHAINING-PROOF? SELF))
          (CL:RETURN))
         (CL:LET*
          ((EV NULL)
           (VECTOR-000 (%QUERY-ITERATOR.EXTERNAL-VARIABLES SELF))
           (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
           (I NULL-INTEGER) (ITER-000 0))
          (CL:DECLARE
           (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
          (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
           (CL:SETQ EV
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
             INDEX-000))
           (CL:SETQ I ITER-000)
           (CL:LET
            ((SELF
              (%VECTOR.THE-ARRAY (%QUERY-SOLUTION.BINDINGS SOLUTION)))
             (VALUE
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (%VECTOR.THE-ARRAY
                 (%PATTERN-RECORD.VARIABLE-BINDINGS
                  (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD
                   *QUERYITERATOR*))))
               (CL:THE CL:FIXNUM
                (%PATTERN-VARIABLE.BOUND-TO-OFFSET EV))))
             (POSITION I))
            (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
             (CL:TYPE CL:FIXNUM POSITION))
            (CL:SETF (CL:AREF SELF POSITION) VALUE))
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
           (CL:SETQ ITER-000 (CL:1+ ITER-000))))
         (CL:SETF (%QUERY-ITERATOR.FOUND-AT-LEAST-ONE-SOLUTION? SELF)
          CL:T)
         (CL:LET* ((TEMP-000 (%CONTROL-FRAME.TRUTH-VALUE BASEFRAME)))
          (CL:SETF (%QUERY-SOLUTION.TRUTH-VALUE SOLUTION)
           (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000
            UNKNOWN-TRUTH-VALUE)))
         (CL:SETF (%QUERY-SOLUTION.JUSTIFICATION SOLUTION)
          (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS BASEFRAME)
           SYM-QUERY-LOGIC-JUSTIFICATION NULL))
         (CL:WHEN
          (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
           (CL:NOT
            (CL:EQ
             (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
             NULL)))
          (CL:SETF (%QUERY-SOLUTION.MATCH-SCORE SOLUTION)
           (CL:IF
            (CL:AND
             (CL:NOT
              (CL:EQ (%CONTROL-FRAME.PARTIAL-MATCH-FRAME BASEFRAME)
               NULL))
             (CL:OR
              (CL:NOT
               (CL:=
                (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE
                 (%CONTROL-FRAME.PARTIAL-MATCH-FRAME BASEFRAME))
                NULL-FLOAT))
              (CL:NOT
               (CL:=
                (%PARTIAL-MATCH-FRAME.NEGATIVE-SCORE
                 (%CONTROL-FRAME.PARTIAL-MATCH-FRAME BASEFRAME))
                NULL-FLOAT))))
            (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE
             (%CONTROL-FRAME.PARTIAL-MATCH-FRAME BASEFRAME))
            (%FLOAT-WRAPPER.WRAPPER-VALUE
             (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
              SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE
              NULL-FLOAT-WRAPPER)))))
         (CL:SETQ DUPLICATE
          (LOOKUP (%QUERY-ITERATOR.SOLUTIONS SELF)
           (%QUERY-SOLUTION.BINDINGS SOLUTION)))
         (CL:WHEN
          (CL:AND (CL:NOT (CL:EQ DUPLICATE NULL))
           (CL:OR
            (CL:NOT
             (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
              (CL:NOT
               (CL:EQ
                (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY
                 *QUERYITERATOR*)
                NULL))))
            (CL:<= (%QUERY-SOLUTION.MATCH-SCORE SOLUTION)
             (%QUERY-SOLUTION.MATCH-SCORE DUPLICATE))))
          (CL:GO :CONTINUE))
         (CL:WHEN
          (CL:AND
           (CL:OR
            (CL:EQ (%CONTROL-FRAME.TRUTH-VALUE BASEFRAME)
             DEFAULT-TRUE-TRUTH-VALUE)
            (CL:EQ (%CONTROL-FRAME.TRUTH-VALUE BASEFRAME)
             DEFAULT-FALSE-TRUTH-VALUE))
           (TRY-TO-DEFEAT-LAST-ANSWER? SELF))
          (CL:GO :CONTINUE))
         (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE BASEFRAME)
          (%QUERY-SOLUTION.TRUTH-VALUE SOLUTION))
         (SET-DYNAMIC-SLOT-VALUE
          (%CONTROL-FRAME.DYNAMIC-SLOTS BASEFRAME)
          SYM-QUERY-LOGIC-JUSTIFICATION
          (%QUERY-SOLUTION.JUSTIFICATION SOLUTION) NULL)
         (INSERT-AT (%QUERY-ITERATOR.SOLUTIONS SELF)
          (%QUERY-SOLUTION.BINDINGS SOLUTION) SOLUTION)
         (CL:RETURN-FROM NEXT? CL:T) :CONTINUE)))
      (CL:COND
       ((%QUERY-ITERATOR.TIMEOUT? SELF) (CL:RETURN-FROM NEXT? CL:NIL))
       ((%QUERY-ITERATOR.AUGMENTED-GOAL-CACHE? SELF) (RESET SELF))
       ((CL:AND
         (%BOOLEAN-WRAPPER.WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
           SYM-QUERY-LOGIC-ITERATIVE-DEEPENING? FALSE-WRAPPER))
         (%QUERY-ITERATOR.TRIGGERED-DEPTH-CUTOFF? SELF)
         (CL:< (%QUERY-ITERATOR.CURRENT-DEPTH-CUTOFF SELF)
          (%QUERY-ITERATOR.MAXIMUM-DEPTH SELF)))
        (CL:SETF (%QUERY-ITERATOR.CURRENT-DEPTH-CUTOFF SELF)
         (CL:1+ (%QUERY-ITERATOR.CURRENT-DEPTH-CUTOFF SELF)))
        (RESET SELF))
       (CL:T
        (CL:WHEN
         (CL:AND
          (%QUERY-ITERATOR.FAILED-TO-FIND-DUPLICATE-SUBGOAL? SELF)
          (CL:NOT (%QUERY-ITERATOR.FOUND-AT-LEAST-ONE-SOLUTION? SELF)))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "Failed to find a duplicate subgoal on one or more occurrences when"
          EOL "   the depth cutoff "
          (%QUERY-ITERATOR.CURRENT-DEPTH-CUTOFF SELF)
          " was exceeded.  Consider increasing the cutoff" EOL
          "   (by setting the variable *maximum-backtracking-depth*)"
          EOL "   and trying again." EOL))
        (CL:SETF (%QUERY-ITERATOR.EXHAUSTED? SELF) CL:T)
        (CL:RETURN-FROM NEXT? CL:NIL))))))))

;;; (DEFUN (TRY-TO-DEFEAT-LAST-ANSWER? BOOLEAN) ...)

(CL:DEFUN TRY-TO-DEFEAT-LAST-ANSWER? (SELF)
  (CL:LET*
   ((NEGATEDQUERY
     (CL:IF (QUERY-IS-TRUE-FALSE? SELF) SELF
      (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
       SYM-QUERY-LOGIC-AUXILIARY-QUERY NULL)))
    (QUERYCONTEXT (%QUERY-ITERATOR.QUERY-CONTEXT SELF))
    (STRICTPOSITIVEANSWER? CL:NIL) (STRICTNEGATIVEANSWER? CL:NIL)
    (DEFEATED? CL:NIL))
   (CL:COND
    ((CL:EQ NEGATEDQUERY NULL)
     (CL:SETQ NEGATEDQUERY
      (CREATE-QUERY-ITERATOR (QUERY-DESCRIPTION SELF)
       (%QUERY-SOLUTION.BINDINGS (%QUERY-ITERATOR.VALUE SELF))))
     (CL:SETF (%QUERY-ITERATOR.QUERY-CONTEXT NEGATEDQUERY)
      QUERYCONTEXT))
    (CL:T
     (CL:WHEN
      (CL:EQ SELF
       (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS NEGATEDQUERY)
        SYM-QUERY-LOGIC-AUXILIARY-QUERY NULL))
      (CL:RETURN-FROM TRY-TO-DEFEAT-LAST-ANSWER? CL:NIL))
     (SET-DYNAMIC-SLOT-VALUE
      (%QUERY-ITERATOR.DYNAMIC-SLOTS NEGATEDQUERY)
      SYM-QUERY-LOGIC-INITIAL-BINDINGS
      (%QUERY-SOLUTION.BINDINGS (%QUERY-ITERATOR.VALUE SELF)) NULL)))
   (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
    SYM-QUERY-LOGIC-AUXILIARY-QUERY NEGATEDQUERY NULL)
   (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS NEGATEDQUERY)
    SYM-QUERY-LOGIC-AUXILIARY-QUERY SELF NULL)
   (CL:SETF
    (%CONTROL-FRAME.REVERSE-POLARITY?
     (%QUERY-ITERATOR.BASE-CONTROL-FRAME NEGATEDQUERY))
    CL:T)
   (RESET NEGATEDQUERY)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "Looking for conflicting default conclusion:" EOL))
   (CL:WHEN (NEXT? NEGATEDQUERY) (RESET NEGATEDQUERY)
    (CL:LET* ((*DONTUSEDEFAULTKNOWLEDGE?* CL:T))
     (CL:DECLARE (CL:SPECIAL *DONTUSEDEFAULTKNOWLEDGE?*))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
       (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Looking for conflicting strict conclusion:" EOL))
     (CL:SETQ STRICTNEGATIVEANSWER? (NEXT? NEGATEDQUERY)))
    (CL:SETF
     (%CONTROL-FRAME.REVERSE-POLARITY?
      (%QUERY-ITERATOR.BASE-CONTROL-FRAME NEGATEDQUERY))
     CL:NIL)
    (RESET NEGATEDQUERY)
    (CL:LET* ((*DONTUSEDEFAULTKNOWLEDGE?* CL:T))
     (CL:DECLARE (CL:SPECIAL *DONTUSEDEFAULTKNOWLEDGE?*))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
       (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Looking for strict conclusion:" EOL))
     (CL:SETQ STRICTPOSITIVEANSWER? (NEXT? NEGATEDQUERY)))
    (CL:IF STRICTPOSITIVEANSWER?
     (CL:COND
      (STRICTNEGATIVEANSWER?
       (CL:LET* ((*QUERYITERATOR* NEGATEDQUERY))
        (CL:DECLARE (CL:SPECIAL *QUERYITERATOR*))
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         EOL "CONTRADICTION: Discovered strict arguments for" EOL
         "    `"
         (%CONTROL-FRAME.PROPOSITION
          (%QUERY-ITERATOR.BASE-CONTROL-FRAME NEGATEDQUERY))
         "'" EOL "and its negation." EOL EOL))
       (CL:SETQ DEFEATED? CL:T))
      (CL:T (CL:SETQ DEFEATED? CL:NIL)))
     (CL:SETQ DEFEATED? CL:T)))
   (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS NEGATEDQUERY)
    SYM-QUERY-LOGIC-AUXILIARY-QUERY NULL NULL)
   DEFEATED?))

;;; (DEFMETHOD RESET ...)

(CL:DEFMETHOD RESET ((SELF QUERY-ITERATOR))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "------------- RESET -------------" EOL))
  (CL:LET* ((INITIALFRAME (%QUERY-ITERATOR.BASE-CONTROL-FRAME SELF)))
   (CL:WHEN (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN INITIALFRAME) NULL))
    (POP-FRAMES-UP-TO (%CONTROL-FRAME.DOWN INITIALFRAME)))
   (CL:LET*
    ((PATTERNRECORD (%CONTROL-FRAME.PATTERN-RECORD INITIALFRAME)))
    (CL:SETF (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD SELF)
     PATTERNRECORD)
    (CL:LET* ((*CONTEXT* (GET-QUERY-CONTEXT)) (*QUERYITERATOR* SELF))
     (CL:DECLARE (CL:SPECIAL *CONTEXT* *QUERYITERATOR*))
     (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD 0)
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
         SYM-QUERY-LOGIC-INITIAL-BINDINGS NULL)
        NULL))
      (CL:LET*
       ((ARG NULL)
        (VECTOR-000 (%QUERY-ITERATOR.EXTERNAL-VARIABLES SELF))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (VALUE NULL)
        (VECTOR-001
         (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
          SYM-QUERY-LOGIC-INITIAL-BINDINGS NULL))
        (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-000 LENGTH-000)
         (CL:< INDEX-001 LENGTH-001))
        DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ VALUE
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
         (CL:WHEN (CL:NOT (BIND-ARGUMENT-TO-VALUE? ARG VALUE CL:NIL))
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
            "reset: binding of `" ARG "' to `" VALUE "' failed.")
           (CL:ERROR
            (NEW-FAIL-EXCEPTION (THE-STRING-READER STREAM-000))))))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
     (OVERLAY-WITH-PATTERN-FRAME? INITIALFRAME
      (%PATTERN-RECORD.DESCRIPTION PATTERNRECORD)
      (%PATTERN-RECORD.EXTERNAL-ARGUMENTS PATTERNRECORD))))
   (CL:SETF (%QUERY-ITERATOR.EXHAUSTED? SELF) CL:NIL)
   (CL:SETF (%QUERY-ITERATOR.TIMEOUT? SELF) CL:NIL)
   (CLEAR (%QUERY-ITERATOR.SOLUTIONS SELF))
   (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE INITIALFRAME) NULL)
   (CL:SETF (%QUERY-ITERATOR.AUGMENTED-GOAL-CACHE? SELF) CL:NIL)
   (CL:SETF (%QUERY-ITERATOR.TRIGGERED-DEPTH-CUTOFF? SELF) CL:NIL)))

;;; (DEFUN (STANDARDIZE-QUERY-TREE CONS) ...)

(CL:DEFUN STANDARDIZE-QUERY-TREE (IOVARIABLES QUERYBODY EXTERNALVARIABLES)
  (CL:COND ((CL:EQ IOVARIABLES NULL) (CL:SETQ IOVARIABLES NIL))
   ((CL:NOT (CONS? IOVARIABLES))
    (CL:SETQ IOVARIABLES (CONS-LIST IOVARIABLES))))
  (CL:LET* ((STANDARDIZEDTREE NULL) (ALLVARIABLES IOVARIABLES))
   (CL:LET* ((V NULL) (ITER-000 (REVERSE EXTERNALVARIABLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ V (%%VALUE ITER-000))
     (CL:SETQ ALLVARIABLES (CONS V ALLVARIABLES))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:EQ QUERYBODY NULL)
    (CL:SETQ QUERYBODY SYM-QUERY-STELLA-TRUE))
   (CL:COND
    ((CL:EQ ALLVARIABLES NIL)
     (CL:SETQ STANDARDIZEDTREE
      (LIST* SYM-QUERY-LOGIC-KAPPA NIL QUERYBODY NIL)))
    (CL:T
     (CL:SETQ STANDARDIZEDTREE
      (LIST* SYM-QUERY-STELLA-EXISTS ALLVARIABLES
       (CONS QUERYBODY NIL)))))
   (CL:SETQ STANDARDIZEDTREE
    (STANDARDIZE-LOGICAL-PARSE-TREE STANDARDIZEDTREE))
   (FIRST-SETTER STANDARDIZEDTREE SYM-QUERY-LOGIC-KAPPA)
   STANDARDIZEDTREE))

;;; (DEFUN (MAKE-QUERY QUERY-ITERATOR) ...)

(CL:DEFUN MAKE-QUERY (IOVARIABLES QUERYTREE EXTERNALBINDINGS OPTIONS)
  (FINALIZE-OBJECTS)
  (PROCESS-CHECK-TYPES-AGENDA)
  (CL:LET*
   ((PREFIXQUERYTREE
     (STANDARDIZE-QUERY-TREE IOVARIABLES QUERYTREE NIL))
    (EXTERNALVECTOR
     (CL:IF (CL:NOT (CL:EQ EXTERNALBINDINGS NIL))
      (COPY-LIST-TO-ARGUMENTS-VECTOR (LISTIFY EXTERNALBINDINGS)) NULL))
    (DESCRIPTION NULL) (QUERY (ALLOCATE-QUERY-ITERATOR)))
   (CL:WHEN
    (CL:OR (CL:NOT (CONS? IOVARIABLES))
     (SURROGATE? (%%VALUE (%%REST IOVARIABLES))))
    (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS QUERY)
     SYM-QUERY-LOGIC-ATOMIC-SINGLETONS?
     (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
   (CL:LET*
    ((*EVALUATIONMODE* KWD-QUERY-DESCRIPTION)
     (*LOGICVARIABLETABLE* NIL)
     (*TERMUNDERCONSTRUCTION* PREFIXQUERYTREE))
    (CL:DECLARE
     (CL:SPECIAL *EVALUATIONMODE* *LOGICVARIABLETABLE*
      *TERMUNDERCONSTRUCTION*))
    (CL:LET* ((*MODULE* *MODULE*) (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CL:SETQ DESCRIPTION
      (EVALUATE-DESCRIPTION-TERM PREFIXQUERYTREE CL:NIL))))
   (PROCESS-CHECK-TYPES-AGENDA)
   (CL:WHEN (CL:NOT (CL:EQ OPTIONS NULL))
    (PROCESS-QUERY-OPTIONS QUERY OPTIONS))
   (INITIALIZE-QUERY-ITERATOR QUERY DESCRIPTION EXTERNALVECTOR)))

;;; (DEFUN (PARSE-QUERY-AND-OPTIONS OBJECT OBJECT PROPERTY-LIST) ...)

(CL:DEFUN PARSE-QUERY-AND-OPTIONS (|QUERY&OPTIONS|)
  (CL:WHEN
   (CL:OR (CL:EQ |QUERY&OPTIONS| NULL) (CL:EQ |QUERY&OPTIONS| NIL))
   (CL:RETURN-FROM PARSE-QUERY-AND-OPTIONS
    (CL:VALUES NULL NULL (NEW-PROPERTY-LIST))))
  (CL:LET*
   ((FIRSTARG (%%VALUE |QUERY&OPTIONS|)) (VARIABLES NULL)
    (PROPOSITION NULL) (OPTIONS (NEW-PROPERTY-LIST)))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE FIRSTARG)))
    (CL:COND
     ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
      (CL:PROGN (INSERT-AT OPTIONS KWD-QUERY-HOW-MANY FIRSTARG)
       (CL:SETQ |QUERY&OPTIONS| (%%REST |QUERY&OPTIONS|))))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN
       (CL:COND
        ((STRING-EQUAL? (%SYMBOL.SYMBOL-NAME FIRSTARG) "ALL")
         (INSERT-AT OPTIONS KWD-QUERY-HOW-MANY
          (WRAP-INTEGER NULL-INTEGER))
         (CL:SETQ |QUERY&OPTIONS| (%%REST |QUERY&OPTIONS|)))
        ((STRING-EQUAL? (%SYMBOL.SYMBOL-NAME FIRSTARG) "BEST")
         (INSERT-AT OPTIONS KWD-QUERY-HOW-MANY
          (WRAP-INTEGER NULL-INTEGER))
         (INSERT-AT OPTIONS KWD-QUERY-SORT-BY KWD-QUERY-SCORE)
         (CL:SETQ |QUERY&OPTIONS| (%%REST |QUERY&OPTIONS|))))))
     ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
      (CL:PROGN
       (CL:COND
        ((STRING-EQUAL? (%KEYWORD.SYMBOL-NAME FIRSTARG) "ALL")
         (INSERT-AT OPTIONS KWD-QUERY-HOW-MANY
          (WRAP-INTEGER NULL-INTEGER))
         (CL:SETQ |QUERY&OPTIONS| (%%REST |QUERY&OPTIONS|)))
        ((STRING-EQUAL? (%KEYWORD.SYMBOL-NAME FIRSTARG) "BEST")
         (INSERT-AT OPTIONS KWD-QUERY-HOW-MANY
          (WRAP-INTEGER NULL-INTEGER))
         (INSERT-AT OPTIONS KWD-QUERY-SORT-BY KWD-QUERY-SCORE)
         (CL:SETQ |QUERY&OPTIONS| (%%REST |QUERY&OPTIONS|))))))
     (CL:T)))
   (CL:WHEN (CL:NOT (KEYWORD? (%%VALUE |QUERY&OPTIONS|)))
    (CL:SETQ VARIABLES (%%VALUE |QUERY&OPTIONS|))
    (CL:SETQ |QUERY&OPTIONS| (%%REST |QUERY&OPTIONS|)))
   (CL:WHEN (CL:NOT (KEYWORD? (%%VALUE |QUERY&OPTIONS|)))
    (CL:SETQ PROPOSITION (%%VALUE |QUERY&OPTIONS|))
    (CL:SETQ |QUERY&OPTIONS| (%%REST |QUERY&OPTIONS|)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ VARIABLES NULL)) (CL:EQ PROPOSITION NULL)
     (CL:NOT (KIF-VARIABLE-DECLARATION? VARIABLES)))
    (CL:SETQ PROPOSITION VARIABLES) (CL:SETQ VARIABLES NULL))
   (CL:WHEN (CONS? PROPOSITION)
    (CL:LET* ((FREEVARIABLES (NEW-LIST)) (DECLAREDVARIABLES NULL))
     (CL:COND ((CL:EQ VARIABLES NULL) (CL:SETQ DECLAREDVARIABLES NIL))
      ((CL:NOT (CONS? VARIABLES))
       (CL:SETQ DECLAREDVARIABLES (CONS VARIABLES NIL)))
      (CL:T (CL:SETQ DECLAREDVARIABLES VARIABLES)))
     (CL:SETQ DECLAREDVARIABLES
      (EXTRACT-VARIABLES-FROM-DECLARATIONS DECLAREDVARIABLES))
     (COLLECT-UNDECLARED-VARIABLES PROPOSITION NIL FREEVARIABLES)
     (CL:COND
      ((CL:AND (CL:EQ DECLAREDVARIABLES NIL)
        (NON-EMPTY? FREEVARIABLES))
       (CL:IF (CL:= (LENGTH FREEVARIABLES) 1)
        (CL:SETQ VARIABLES (FIRST FREEVARIABLES))
        (CL:SETQ VARIABLES (%LIST.THE-CONS-LIST FREEVARIABLES))))
      ((CL:AND (CL:EQ DECLAREDVARIABLES NIL) (EMPTY? FREEVARIABLES)))
      ((CL:NOT
        (EQUIVALENT-SETS? (%LIST.THE-CONS-LIST FREEVARIABLES)
         DECLAREDVARIABLES))
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
          "PARSING ERROR: Declared query variables `" DECLAREDVARIABLES
          "' do not match" EOL "   the free variables `"
          (%LIST.THE-CONS-LIST FREEVARIABLES)
          "' referenced in the query body." EOL
          "   To simply use the free variables, omit the declaration."
          EOL)
         (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-QUERY-ERROR))
        (CL:ERROR
         (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000))))))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ |QUERY&OPTIONS| NIL)) DO
    (CL:WHEN (CL:NOT (KEYWORD? (%%VALUE |QUERY&OPTIONS|)))
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
        "PARSING ERROR: Illegal query option: `"
        (%%VALUE |QUERY&OPTIONS|) "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-QUERY-ERROR))
      (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-001)))))
    (CL:WHEN (CL:EQ (%%VALUE (%%REST |QUERY&OPTIONS|)) NULL)
     (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
        "PARSING ERROR: Missing value for option `"
        (%%VALUE |QUERY&OPTIONS|) "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-002 KWD-QUERY-ERROR))
      (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-002)))))
    (INSERT-AT OPTIONS (%%VALUE |QUERY&OPTIONS|)
     (%%VALUE (%%REST |QUERY&OPTIONS|)))
    (CL:SETQ |QUERY&OPTIONS| (%%REST (%%REST |QUERY&OPTIONS|))))
   (CL:VALUES VARIABLES PROPOSITION OPTIONS)))

;;; (DEFUN PROCESS-QUERY-OPTIONS ...)

(CL:DEFUN PROCESS-QUERY-OPTIONS (QUERY OPTIONS)
  (CL:LET*
   ((THEOPTIONS (VET-OPTIONS OPTIONS NULL)) (DEFERREDOPTIONS NULL))
   (CL:SETF (%QUERY-ITERATOR.OPTIONS QUERY) THEOPTIONS)
   (CL:LET*
    ((KEY NULL) (VALUE NULL)
     (ITER-000 (%PROPERTY-LIST.THE-PLIST THEOPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ KEY (%%VALUE ITER-000))
     (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
     (CL:LET* ((TEST-VALUE-000 KEY))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-TIMEOUT)
        (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE VALUE)))
         (CL:COND
          ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
           (CL:PROGN
            (CL:SETF (%QUERY-ITERATOR.ALLOTTED-TIME QUERY)
             (NUMBER-WRAPPER-TO-FLOAT VALUE))
            (INSERT-AT THEOPTIONS KEY
             (WRAP-FLOAT (%QUERY-ITERATOR.ALLOTTED-TIME QUERY)))))
          ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
           (CL:PROGN
            (CL:SETF (%QUERY-ITERATOR.ALLOTTED-TIME QUERY)
             (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
            (INSERT-AT THEOPTIONS KEY
             (WRAP-FLOAT (%QUERY-ITERATOR.ALLOTTED-TIME QUERY)))))
          (CL:T
           (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
              "PARSING ERROR: Illegal :TIMEOUT value: `" VALUE "'."
              EOL)
             (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
              KWD-QUERY-ERROR))
            (CL:ERROR
             (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))))
        (CL:SETF (%QUERY-ITERATOR.TIMEOUT? QUERY) CL:NIL))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-MOVEOUT)
        (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE VALUE)))
         (CL:COND
          ((SUBTYPE-OF-INTEGER? TEST-VALUE-002)
           (CL:PROGN
            (CL:SETF (%QUERY-ITERATOR.ALLOTTED-CLOCK-TICKS QUERY)
             (FLOOR (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE)))
            (INSERT-AT THEOPTIONS KEY
             (WRAP-INTEGER
              (FLOOR (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))))))
          ((SUBTYPE-OF-FLOAT? TEST-VALUE-002)
           (CL:PROGN
            (CL:SETF (%QUERY-ITERATOR.ALLOTTED-CLOCK-TICKS QUERY)
             (FLOOR (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE)))
            (INSERT-AT THEOPTIONS KEY
             (WRAP-INTEGER
              (FLOOR (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))))))
          (CL:T
           (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
              "PARSING ERROR: Illegal :MOVEOUT value: `" VALUE "'."
              EOL)
             (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001
              KWD-QUERY-ERROR))
            (CL:ERROR
             (NEW-PARSING-ERROR (THE-STRING-READER STREAM-001))))))))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-MAXIMUM-DEPTH)
        (CL:LET* ((TEST-VALUE-003 (SAFE-PRIMARY-TYPE VALUE)))
         (CL:COND
          ((SUBTYPE-OF-INTEGER? TEST-VALUE-003)
           (CL:PROGN
            (INSERT-AT THEOPTIONS KEY
             (WRAP-INTEGER
              (FLOOR (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))))
            (CL:SETF (%QUERY-ITERATOR.MAXIMUM-DEPTH QUERY)
             (%INTEGER-WRAPPER.WRAPPER-VALUE
              (LOOKUP-QUERY-OPTION QUERY KWD-QUERY-MAXIMUM-DEPTH)))))
          ((SUBTYPE-OF-FLOAT? TEST-VALUE-003)
           (CL:PROGN
            (INSERT-AT THEOPTIONS KEY
             (WRAP-INTEGER
              (FLOOR (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))))
            (CL:SETF (%QUERY-ITERATOR.MAXIMUM-DEPTH QUERY)
             (%INTEGER-WRAPPER.WRAPPER-VALUE
              (LOOKUP-QUERY-OPTION QUERY KWD-QUERY-MAXIMUM-DEPTH)))))
          (CL:T
           (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
              "PARSING ERROR: Illegal :MAXIMUM-DEPTH value: `" VALUE
              "'." EOL)
             (HELP-SIGNAL-PROPOSITION-ERROR STREAM-002
              KWD-QUERY-ERROR))
            (CL:ERROR
             (NEW-PARSING-ERROR (THE-STRING-READER STREAM-002))))))))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-INFERENCE-LEVEL)
        (CL:LET* ((TEST-VALUE-004 (SAFE-PRIMARY-TYPE VALUE)))
         (CL:COND
          ((SUBTYPE-OF? TEST-VALUE-004
            SGT-QUERY-STELLA-GENERALIZED-SYMBOL)
           (CL:PROGN
            (INSERT-AT THEOPTIONS KEY
             (KEYWORDIFY (COERCE-TO-STRING VALUE)))
            (CL:SETF (%QUERY-ITERATOR.INFERENCE-LEVEL QUERY)
             (GET-INFERENCE-LEVEL
              (LOOKUP-QUERY-OPTION QUERY KWD-QUERY-INFERENCE-LEVEL)))))
          ((SUBTYPE-OF-STRING? TEST-VALUE-004)
           (CL:PROGN
            (INSERT-AT THEOPTIONS KEY
             (KEYWORDIFY (COERCE-TO-STRING VALUE)))
            (CL:SETF (%QUERY-ITERATOR.INFERENCE-LEVEL QUERY)
             (GET-INFERENCE-LEVEL
              (LOOKUP-QUERY-OPTION QUERY KWD-QUERY-INFERENCE-LEVEL)))))
          (CL:T
           (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003)
              "PARSING ERROR: Illegal :INFERENCE-LEVEL value: `" VALUE
              "'." EOL)
             (HELP-SIGNAL-PROPOSITION-ERROR STREAM-003
              KWD-QUERY-ERROR))
            (CL:ERROR
             (NEW-PARSING-ERROR (THE-STRING-READER STREAM-003))))))))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-THREE-VALUED?)
        (CL:SETQ VALUE (COERCE-TO-BOOLEAN VALUE))
        (INSERT-AT THEOPTIONS KEY VALUE))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-ITERATIVE-DEEPENING?)
        (CL:SETQ VALUE (COERCE-TO-BOOLEAN VALUE))
        (INSERT-AT THEOPTIONS KEY VALUE)
        (CL:WHEN (EQL? VALUE TRUE-WRAPPER)
         (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS QUERY)
          SYM-QUERY-LOGIC-ITERATIVE-DEEPENING?
          (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-SINGLETONS?)
        (INSERT-AT THEOPTIONS KEY (COERCE-TO-BOOLEAN VALUE))
        (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS QUERY)
         SYM-QUERY-LOGIC-ATOMIC-SINGLETONS?
         (CL:IF (EQL? VALUE TRUE-WRAPPER) TRUE-WRAPPER FALSE-WRAPPER)
         FALSE-WRAPPER))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-DONT-OPTIMIZE?)
        (CL:SETQ VALUE (COERCE-TO-BOOLEAN VALUE))
        (INSERT-AT THEOPTIONS KEY VALUE))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-HOW-MANY)
        (CL:LET* ((TEST-VALUE-005 (SAFE-PRIMARY-TYPE VALUE)))
         (CL:COND ((SUBTYPE-OF-INTEGER? TEST-VALUE-005) (CL:PROGN))
          ((SUBTYPE-OF? TEST-VALUE-005
            SGT-QUERY-STELLA-GENERALIZED-SYMBOL)
           (CL:PROGN
            (CL:COND
             ((STRING-EQL? (%GENERALIZED-SYMBOL.SYMBOL-NAME VALUE)
               "ALL")
              (INSERT-AT THEOPTIONS KEY (WRAP-INTEGER NULL-INTEGER)))
             (CL:T
              (CL:LET* ((STREAM-004 (NEW-OUTPUT-STRING-STREAM)))
               (CL:LET* ((*PRINTREADABLY?* CL:T))
                (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
                (%%PRINT-STREAM
                 (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-004)
                 "PARSING ERROR: Illegal :HOW-MANY value: `" VALUE "'."
                 EOL)
                (HELP-SIGNAL-PROPOSITION-ERROR STREAM-004
                 KWD-QUERY-ERROR))
               (CL:ERROR
                (NEW-PARSING-ERROR
                 (THE-STRING-READER STREAM-004))))))))
          (CL:T
           (CL:LET* ((STREAM-005 (NEW-OUTPUT-STRING-STREAM)))
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-005)
              "PARSING ERROR: Illegal :HOW-MANY value: `" VALUE "'."
              EOL)
             (HELP-SIGNAL-PROPOSITION-ERROR STREAM-005
              KWD-QUERY-ERROR))
            (CL:ERROR
             (NEW-PARSING-ERROR (THE-STRING-READER STREAM-005))))))))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-SORT-BY)
        (CL:COND
         ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE VALUE)
           SGT-QUERY-STELLA-GENERALIZED-SYMBOL)
          (CL:PROGN
           (CL:COND
            ((STRING-EQL? (%GENERALIZED-SYMBOL.SYMBOL-NAME VALUE)
              "SCORE")
             (INSERT-AT THEOPTIONS KEY KWD-QUERY-SCORE))
            (CL:T
             (CL:LET* ((STREAM-006 (NEW-OUTPUT-STRING-STREAM)))
              (CL:LET* ((*PRINTREADABLY?* CL:T))
               (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
               (%%PRINT-STREAM
                (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-006)
                "PARSING ERROR: Illegal :SORT-BY value: `" VALUE "'."
                EOL)
               (HELP-SIGNAL-PROPOSITION-ERROR STREAM-006
                KWD-QUERY-ERROR))
              (CL:ERROR
               (NEW-PARSING-ERROR (THE-STRING-READER STREAM-006))))))))
         (CL:T
          (CL:LET* ((STREAM-007 (NEW-OUTPUT-STRING-STREAM)))
           (CL:LET* ((*PRINTREADABLY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-007)
             "PARSING ERROR: Illegal :SORT-BY value: `" VALUE "'." EOL)
            (HELP-SIGNAL-PROPOSITION-ERROR STREAM-007 KWD-QUERY-ERROR))
           (CL:ERROR
            (NEW-PARSING-ERROR (THE-STRING-READER STREAM-007)))))))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-MATCH-MODE)
        (CL:LET* ((TEST-VALUE-006 (SAFE-PRIMARY-TYPE VALUE)))
         (CL:COND
          ((SUBTYPE-OF? TEST-VALUE-006
            SGT-QUERY-STELLA-GENERALIZED-SYMBOL)
           (CL:PROGN
            (CL:IF (STRING? VALUE)
             (INSERT-AT THEOPTIONS KEY (KEYWORDIFY VALUE))
             (INSERT-AT THEOPTIONS KEY VALUE))))
          ((SUBTYPE-OF-STRING? TEST-VALUE-006)
           (CL:PROGN
            (CL:IF (STRING? VALUE)
             (INSERT-AT THEOPTIONS KEY (KEYWORDIFY VALUE))
             (INSERT-AT THEOPTIONS KEY VALUE))))
          (CL:T
           (CL:LET* ((STREAM-008 (NEW-OUTPUT-STRING-STREAM)))
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-008)
              "PARSING ERROR: Illegal :MATCH-MODE value: `" VALUE "'."
              EOL)
             (HELP-SIGNAL-PROPOSITION-ERROR STREAM-008
              KWD-QUERY-ERROR))
            (CL:ERROR
             (NEW-PARSING-ERROR (THE-STRING-READER STREAM-008))))))))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-MINIMUM-SCORE)
        (CL:LET* ((TEST-VALUE-007 (SAFE-PRIMARY-TYPE VALUE)))
         (CL:COND
          ((SUBTYPE-OF-INTEGER? TEST-VALUE-007)
           (CL:PROGN
            (INSERT-AT THEOPTIONS KEY
             (WRAP-FLOAT
              (CL:FLOAT (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE)
               0.0d0)))))
          ((SUBTYPE-OF-FLOAT? TEST-VALUE-007) (CL:PROGN))
          (CL:T
           (CL:LET* ((STREAM-009 (NEW-OUTPUT-STRING-STREAM)))
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-009)
              "PARSING ERROR: Illegal :MINIMUM-SCORE value: `" VALUE
              "'." EOL)
             (HELP-SIGNAL-PROPOSITION-ERROR STREAM-009
              KWD-QUERY-ERROR))
            (CL:ERROR
             (NEW-PARSING-ERROR (THE-STRING-READER STREAM-009))))))))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-MAXIMIZE-SCORE?)
        (INSERT-AT THEOPTIONS KEY (COERCE-TO-BOOLEAN VALUE)))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-MAXIMUM-UNKNOWNS)
        (CL:LET* ((TEST-VALUE-008 (SAFE-PRIMARY-TYPE VALUE)))
         (CL:COND ((SUBTYPE-OF-INTEGER? TEST-VALUE-008) (CL:PROGN))
          ((SUBTYPE-OF-FLOAT? TEST-VALUE-008)
           (CL:PROGN
            (INSERT-AT THEOPTIONS KEY
             (WRAP-INTEGER
              (CL:TRUNCATE (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))))))
          (CL:T
           (CL:LET* ((STREAM-010 (NEW-OUTPUT-STRING-STREAM)))
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-010)
              "PARSING ERROR: Illegal :MAXIMUM-UNKNOWNS value: `" VALUE
              "'." EOL)
             (HELP-SIGNAL-PROPOSITION-ERROR STREAM-010
              KWD-QUERY-ERROR))
            (CL:ERROR
             (NEW-PARSING-ERROR (THE-STRING-READER STREAM-010))))))))
       (CL:T
        (CL:WHEN (CL:EQ DEFERREDOPTIONS NULL)
         (CL:SETQ DEFERREDOPTIONS (NEW-PROPERTY-LIST)))
        (INSERT-AT DEFERREDOPTIONS KEY VALUE))))
     (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
   (CL:WHEN (CL:NOT (CL:EQ DEFERREDOPTIONS NULL))
    (INSERT-AT THEOPTIONS KWD-QUERY-DEFERRED-OPTIONS DEFERREDOPTIONS))))

;;; (DEFUN (LOOKUP-QUERY-OPTION OBJECT) ...)

(CL:DEFUN LOOKUP-QUERY-OPTION (QUERYOROPTIONS KEY)
  (CL:LET* ((OPTIONS NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE QUERYOROPTIONS)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-PROPERTY-LIST)
      (CL:PROGN (CL:SETQ OPTIONS QUERYOROPTIONS)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-QUERY-ITERATOR)
      (CL:PROGN
       (CL:SETQ OPTIONS (%QUERY-ITERATOR.OPTIONS QUERYOROPTIONS))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (LOOKUP OPTIONS KEY)))

;;; (DEFUN (TEST-QUERY-OPTION? BOOLEAN) ...)

(CL:DEFUN TEST-QUERY-OPTION? (QUERYOROPTIONS KEY)
  (EQL? (LOOKUP-QUERY-OPTION QUERYOROPTIONS KEY) TRUE-WRAPPER))

;;; (DEFUN (LOOKUP-DEFERRED-QUERY-OPTION OBJECT) ...)

(CL:DEFUN LOOKUP-DEFERRED-QUERY-OPTION (QUERYOROPTIONS KEY COERCETOTYPE)
  (CL:LET*
   ((OPTIONS NULL) (DEFERREDOPTIONS NULL) (VALUE NULL)
    (COERCEDVALUE NULL) (PROCESSEDDEFERREDOPTION? CL:NIL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE QUERYOROPTIONS)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-PROPERTY-LIST)
      (CL:PROGN (CL:SETQ OPTIONS QUERYOROPTIONS)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-QUERY-ITERATOR)
      (CL:PROGN
       (CL:SETQ OPTIONS (%QUERY-ITERATOR.OPTIONS QUERYOROPTIONS))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:SETQ DEFERREDOPTIONS
    (LOOKUP OPTIONS KWD-QUERY-DEFERRED-OPTIONS))
   (CL:WHEN (CL:NOT (CL:EQ DEFERREDOPTIONS NULL))
    (CL:SETQ VALUE (LOOKUP DEFERREDOPTIONS KEY))
    (CL:IF (CL:EQ VALUE NULL) (CL:SETQ VALUE (LOOKUP OPTIONS KEY))
     (CL:SETQ PROCESSEDDEFERREDOPTION? CL:T))
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:WHEN (CL:NOT (CL:EQ COERCETOTYPE NULL))
      (CL:SETQ COERCEDVALUE (COERCE-OPTION-VALUE VALUE COERCETOTYPE))
      (CL:IF (CL:EQ COERCEDVALUE NULL)
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
          "PARSING ERROR: Illegal `" KEY "' value: `" VALUE "'." EOL)
         (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-QUERY-ERROR))
        (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-001))))
       (CL:SETQ VALUE COERCEDVALUE)))
     (CL:WHEN PROCESSEDDEFERREDOPTION? (REMOVE-AT DEFERREDOPTIONS KEY)
      (INSERT-AT OPTIONS KEY VALUE))))
   VALUE))

;;; (DEFUN (LOOKUP-HOW-MANY-SOLUTIONS INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) LOOKUP-HOW-MANY-SOLUTIONS))
(CL:DEFUN LOOKUP-HOW-MANY-SOLUTIONS (QUERYOROPTIONS)
  (CL:LET*
   ((HOWMANY (LOOKUP-QUERY-OPTION QUERYOROPTIONS KWD-QUERY-HOW-MANY)))
   (CL:IF (CL:NOT (CL:EQ HOWMANY NULL))
    (%INTEGER-WRAPPER.WRAPPER-VALUE HOWMANY) 1)))

;;; (DEFUN (RUN-YES-OR-NO-QUERY? THREE-VALUED-BOOLEAN) ...)

(CL:DEFUN RUN-YES-OR-NO-QUERY? (QUERY)
  (CL:LET* ((TRUTHVALUE (CALL-ASK QUERY)))
   (CL:COND
    ((CL:OR (CL:EQ TRUTHVALUE TRUE-TRUTH-VALUE)
      (CL:EQ TRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE))
     (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER))
    ((CL:OR (CL:EQ TRUTHVALUE FALSE-TRUTH-VALUE)
      (CL:EQ TRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE))
     (CL:IF CL:NIL TRUE-WRAPPER FALSE-WRAPPER))
    (CL:T NULL))))

;;; (DEFUN (COERCE-TO-TREE OBJECT) ...)

(CL:DEFUN COERCE-TO-TREE (SELF)
  (CL:COND
   ((SUBTYPE-OF-STRING? (SAFE-PRIMARY-TYPE SELF))
    (CL:PROGN
     (READ-S-EXPRESSION-FROM-STRING
      (%STRING-WRAPPER.WRAPPER-VALUE SELF))))
   (CL:T SELF)))

;;; (DEFUN (COERCE-TO-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) COERCE-TO-STRING))
(CL:DEFUN COERCE-TO-STRING (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN (%STRING-WRAPPER.WRAPPER-VALUE SELF)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN (%SYMBOL.SYMBOL-NAME SELF)))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN (%KEYWORD.SYMBOL-NAME SELF)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (%SURROGATE.SYMBOL-NAME SELF)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "PARSING ERROR: Can't convert `" SELF "' into a string." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-QUERY-ERROR))
      (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (CREATE-ASK-QUERY QUERY-ITERATOR) ...)

(CL:DEFUN CREATE-ASK-QUERY (QUERY)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE QUERY)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-QUERY-ITERATOR)
     (CL:PROGN QUERY))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-PROPOSITION)
     (CL:PROGN (CREATE-ASK-QUERY (PROPOSITION-TO-CONS QUERY))))
    ((CL:EQ TEST-VALUE-000 SGT-QUERY-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((IOVARIABLES NULL) (PROPOSITION NULL) (OPTIONS NULL))
       (CL:MULTIPLE-VALUE-SETQ (IOVARIABLES PROPOSITION OPTIONS)
        (PARSE-QUERY-AND-OPTIONS QUERY))
       (CL:IF
        (CL:AND (CL:EQ IOVARIABLES NULL)
         (CL:NOT (CL:EQ PROPOSITION NULL)))
        (MAKE-QUERY NIL PROPOSITION NIL OPTIONS)
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
           "PARSING ERROR: Illegal ASK query: `" QUERY "'." EOL)
          (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-QUERY-ERROR))
         (CL:ERROR
          (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000))))))))
    (CL:T
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
        "PARSING ERROR: Illegal ASK query: `" QUERY "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-QUERY-ERROR))
      (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-001))))))))

;;; (DEFUN (CALL-ASK TRUTH-VALUE) ...)

(CL:DEFUN CALL-ASK (QUERY)
  "Callable version of `ask' (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to `ask'.  Raises LOGIC-EXCEPTIONs in case of illegal
queries and logical expressions."
  (CL:LET*
   ((*QUERYITERATOR* (CREATE-ASK-QUERY QUERY))
    (*REVERSEPOLARITY?* CL:NIL)
    (*INFERENCELEVEL* (CURRENT-INFERENCE-LEVEL))
    (*GENERATE-ALL-PROOFS?* CL:NIL))
   (CL:DECLARE
    (CL:SPECIAL *QUERYITERATOR* *REVERSEPOLARITY?* *INFERENCELEVEL*
     *GENERATE-ALL-PROOFS?*))
   (CL:LET*
    ((TRUTHVALUE NULL)
     (THREEVALUEDASK?
      (TEST-QUERY-OPTION? *QUERYITERATOR* KWD-QUERY-THREE-VALUED?)))
    (CL:WHEN (CL:EQ *MOST-RECENT-QUERY* NULL)
     (CL:SETQ *MOST-RECENT-QUERY* *QUERYITERATOR*))
    (NEXT? *QUERYITERATOR*)
    (CL:LET*
     ((TEMP-000
       (%CONTROL-FRAME.TRUTH-VALUE
        (%QUERY-ITERATOR.BASE-CONTROL-FRAME *QUERYITERATOR*))))
     (CL:SETQ TRUTHVALUE
      (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000
       UNKNOWN-TRUTH-VALUE)))
    (CL:WHEN
     (CL:AND THREEVALUEDASK?
      (CL:OR (CL:EQ TRUTHVALUE UNKNOWN-TRUTH-VALUE)
       (CL:EQ TRUTHVALUE NULL)))
     (CL:SETF
      (%CONTROL-FRAME.REVERSE-POLARITY?
       (%QUERY-ITERATOR.BASE-CONTROL-FRAME *QUERYITERATOR*))
      CL:T)
     (RESET *QUERYITERATOR*) (NEXT? *QUERYITERATOR*)
     (CL:LET*
      ((TEMP-001
        (%CONTROL-FRAME.TRUTH-VALUE
         (%QUERY-ITERATOR.BASE-CONTROL-FRAME *QUERYITERATOR*))))
      (CL:SETQ TRUTHVALUE
       (CL:IF (CL:NOT (CL:EQ TEMP-001 NULL)) TEMP-001
        UNKNOWN-TRUTH-VALUE))))
    TRUTHVALUE)))

;;; (DEFUN (ASK TRUTH-VALUE) ...)

(CL:DEFUN %ASK (|PROPOSITION&OPTIONS|)
  "Perform inference to determine whether the proposition specified in
`proposition&options' is true.  Return the truth-value found.  `ask'
will spend most of its effort to determine whether the proposition
is true and only a little effort via shallow inference strategies to
determine whether it is false.  To find out whether a proposition is
false with full inference effort `ask' its negation.

KIF example: `(ask (happy Fred))' will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic
constant `Fred' and the relation `happy' must already be defined (see
`assert').  Use `(set/unset-feature goal-trace)' to en/disable goal
tracing of the inference engine.

The `ask' command supports the following options: `:TIMEOUT' is an
integer or floating point time limit, specified in seconds.  For
example, the command `(ask (nervous Fred) :timeout 2.0)' will cease
inference after two seconds if a proof has not been found by then.
If the `:DONT-OPTIMIZE?' is given as TRUE, it tells PowerLoom to
not optimize the order of clauses in the query before evaluating it.
This is useful for cases where a specific evaluation order of the
clauses is required (or the optimizer doesn't do the right thing).
If `:THREE-VALUED?' is given as TRUE, PowerLoom will try to prove
the negation of the query with full effort in case the given query
returned UNKNOWN.  By default, PowerLoom uses full effort to prove
the query as stated and only a little opportunistic effort to see
whether it is actually false."
  (CL:SETQ *MOST-RECENT-QUERY* NULL)
  (CL:HANDLER-CASE
   (CL:RETURN-FROM %ASK (CALL-ASK |PROPOSITION&OPTIONS|))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))
    (CL:SETQ *MOST-RECENT-QUERY* NULL) NULL)))

(CL:DEFUN ASK-EVALUATOR-WRAPPER (ARGUMENTS)
  (%ASK ARGUMENTS))

(CL:DEFMACRO ASK (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Perform inference to determine whether the proposition specified in
`proposition&options' is true.  Return the truth-value found.  `ask'
will spend most of its effort to determine whether the proposition
is true and only a little effort via shallow inference strategies to
determine whether it is false.  To find out whether a proposition is
false with full inference effort `ask' its negation.

KIF example: `(ask (happy Fred))' will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic
constant `Fred' and the relation `happy' must already be defined (see
`assert').  Use `(set/unset-feature goal-trace)' to en/disable goal
tracing of the inference engine.

The `ask' command supports the following options: `:TIMEOUT' is an
integer or floating point time limit, specified in seconds.  For
example, the command `(ask (nervous Fred) :timeout 2.0)' will cease
inference after two seconds if a proof has not been found by then.
If the `:DONT-OPTIMIZE?' is given as TRUE, it tells PowerLoom to
not optimize the order of clauses in the query before evaluating it.
This is useful for cases where a specific evaluation order of the
clauses is required (or the optimizer doesn't do the right thing).
If `:THREE-VALUED?' is given as TRUE, PowerLoom will try to prove
the negation of the query with full effort in case the given query
returned UNKNOWN.  By default, PowerLoom uses full effort to prove
the query as stated and only a little opportunistic effort to see
whether it is actually false."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/ASK|)) (CL:MACRO-FUNCTION (CL:QUOTE ASK)))

;;; (DEFUN (RETRIEVE-BINDINGS QUERY-ITERATOR) ...)

(CL:DEFUN RETRIEVE-BINDINGS (QUERY NOFBINDINGS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NOFBINDINGS))
  #+MCL
  (CL:CHECK-TYPE NOFBINDINGS CL:FIXNUM)
  (CL:LET* ((THEQUERY NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE QUERY)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-QUERY-ITERATOR)
      (CL:PROGN (CL:SETQ THEQUERY QUERY)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-PROPOSITION)
      (CL:PROGN
       (CL:SETQ THEQUERY
        (MAKE-QUERY
         (CONSIFY
          (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS QUERY)
           SYM-QUERY-LOGIC-IO-VARIABLES NULL))
         (PROPOSITION-TO-CONS QUERY) NIL
         (LIST* KWD-QUERY-HOW-MANY (WRAP-INTEGER NOFBINDINGS) NIL)))))
     ((CL:EQ TEST-VALUE-000 SGT-QUERY-STELLA-CONS)
      (CL:PROGN
       (CL:SETQ THEQUERY
        (MAKE-QUERY (%%VALUE QUERY) (%%VALUE (%%REST QUERY)) NIL
         (%%REST (%%REST QUERY))))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (INSERT-AT (%QUERY-ITERATOR.OPTIONS THEQUERY) KWD-QUERY-HOW-MANY
    (WRAP-INTEGER NOFBINDINGS))
   (CALL-RETRIEVE THEQUERY)))

;;; (DEFUN (CREATE-RETRIEVE-QUERY QUERY-ITERATOR) ...)

(CL:DEFUN CREATE-RETRIEVE-QUERY (QUERY)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE QUERY)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-QUERY-ITERATOR)
     (CL:PROGN QUERY))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-PROPOSITION)
     (CL:PROGN (CREATE-RETRIEVE-QUERY (PROPOSITION-TO-CONS QUERY))))
    ((CL:EQ TEST-VALUE-000 SGT-QUERY-STELLA-CONS)
     (CL:PROGN
      (CL:LET*
       ((IOVARIABLES NULL) (QUERYPROPOSITION NULL) (OPTIONS NULL))
       (CL:MULTIPLE-VALUE-SETQ (IOVARIABLES QUERYPROPOSITION OPTIONS)
        (PARSE-QUERY-AND-OPTIONS QUERY))
       (CL:COND
        ((CL:AND (CL:EQ IOVARIABLES NULL)
          (CL:EQ QUERYPROPOSITION NULL))
         (CL:WHEN (CL:EQ *MOST-RECENT-QUERY* NULL)
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (CL:LET* ((*PRINTREADABLY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
             "PARSING ERROR: No preceding context for follow-up retrieval."
             EOL)
            (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-QUERY-ERROR))
           (CL:ERROR
            (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
         (PROCESS-QUERY-OPTIONS *MOST-RECENT-QUERY* OPTIONS)
         *MOST-RECENT-QUERY*)
        ((CL:EQ IOVARIABLES NULL)
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
            "PARSING ERROR: Missing IO-variable specification in retrieval query: `"
            QUERY "'." EOL)
           (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-QUERY-ERROR))
          (CL:ERROR
           (NEW-PARSING-ERROR (THE-STRING-READER STREAM-001)))))
        (CL:T
         (MAKE-QUERY IOVARIABLES QUERYPROPOSITION NIL OPTIONS))))))
    (CL:T
     (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
        "PARSING ERROR: Illegal retrieval query: `" QUERY "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-002 KWD-QUERY-ERROR))
      (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-002))))))))

;;; (DEFUN (CALL-RETRIEVE QUERY-ITERATOR) ...)

(CL:DEFUN CALL-RETRIEVE (QUERY)
  "Callable version of `retrieve' (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to `retrieve'.  Raises LOGIC-EXCEPTIONs in case of illegal
queries and logical expressions."
  (CL:LET*
   ((THEQUERY (CREATE-RETRIEVE-QUERY QUERY))
    (MATCHMODE (LOOKUP-QUERY-OPTION THEQUERY KWD-QUERY-MATCH-MODE)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ MATCHMODE NULL))
     (CL:NOT (STRING-EQUAL? (COERCE-TO-STRING MATCHMODE) "STRICT")))
    (CL:RETURN-FROM CALL-RETRIEVE (CALL-RETRIEVE-PARTIAL THEQUERY)))
   (CL:LET*
    ((*QUERYITERATOR* THEQUERY) (*REVERSEPOLARITY?* CL:NIL)
     (*INFERENCELEVEL* (CURRENT-INFERENCE-LEVEL))
     (*GENERATE-ALL-PROOFS?* CL:NIL))
    (CL:DECLARE
     (CL:SPECIAL *QUERYITERATOR* *REVERSEPOLARITY?* *INFERENCELEVEL*
      *GENERATE-ALL-PROOFS?*))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-000 1)
      (UPPER-BOUND-000 (LOOKUP-HOW-MANY-SOLUTIONS *QUERYITERATOR*))
      (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)) (SOLUTION NULL)
      (ITER-001 *QUERYITERATOR*))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:AND (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000))
       (NEXT? ITER-001))
      DO (CL:SETQ I ITER-000)
      (CL:SETQ SOLUTION (%QUERY-ITERATOR.VALUE ITER-001))
      (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-TRACE-SOLUTIONS)
       (TRACE-SOLUTION *QUERYITERATOR* SOLUTION I))
      (CL:SETQ ITER-000 (CL:1+ ITER-000))))
    *QUERYITERATOR*)))

;;; (DEFGLOBAL *MOST-RECENT-QUERY* ...)

(CL:DEFVAR *MOST-RECENT-QUERY* NULL)

;;; (DEFUN (RETRIEVE QUERY-ITERATOR) ...)

(CL:DEFUN %RETRIEVE (QUERY)
  "Retrieve elements of a relation (tuples) that satisfy a proposition.
The accepted syntax is:
	 
  (retrieve [<integer> | all]
            [[{<vardecl> | (<vardecl>+)}]
            <proposition>])
	
The variables and proposition are similar to an `exists' sentence or
`kappa' term without the explicit quantifier.  If variables are declared,
they must match the free variables referenced by <proposition>.  Otherwise,
the free variables referenced in <proposition> will be used as the query
variables.  If <proposition> is omitted, the most recently asked query
will be continued.

A solution is a set of bindings for the listed variables for which
<proposition> is true.  The optional first argument controls how many
solutions should be generated before control is returned.  The keyword
`all' indicates that all solutions should be generated.  By default,
`retrieve' returns after it has found one new solution or if it cannot
find any more solutions.

`retrieve' returns an iterator which saves all the necessary state of
a query and stores all generated solutions.  When used interactively,
the returned iterator will print out with the set of solutions collected
so far.  Calling `retrieve' without any arguments (or only with the first
argument) will generate one (or more) solutions to the most recently
asked query.

KIF examples:
	 
  (retrieve (happy ?x))
	
will try to find one happy entity and store it in the returned 
query iterator.
	 
  (retrieve 10 (happy ?x))
	
will try to find 10 happy entities.
	 
  (retrieve 10)
	
will try to find the next 10 happy entities..
	 
  (retrieve all (happy ?x))
	
will find all happy entities.
	 
  (retrieve all (?x Person) (happy ?x))
	
will to find all happy people.  Here we used the optional retrieve variable
syntax to restrict the acceptable solutions.  The above is equivalent to
the following query:
	 
  (retrieve all (and (Person ?x) (happy ?x)))
	
Similarly,
	 
  (retrieve all (?x Person))
  (retrieve all (Person ?x))
  (retrieve all ?x (Person ?x))
	
will find all people.  Note that in the first case we only specify a query
variable and its type but omit the logic sentence which defaults to TRUE.  This
somewhat impoverished looking query can be paraphrased as \"retrieve all ?x of
type Person such that TRUE.\"
	 
  (retrieve ?x (or (happy ?x) (parent-of Fred ?x)))
	
will try to find a person that is happy or has Fred as a parent.
	 
  (retrieve (?y ?x) (parent-of ?x ?y))
	
will try to find the one pair of parent/child and return it in the order
of child/parent.
	 
  (retrieve all (?x Person)
            (exists (?y Person) (parent-of ?x ?y)))
	
will generate the set of all parents.  Note, that for these queries to run,
the class `Person', the relations `happy' and `parent-of', and the logic
constant `Fred' must already be defined (see `assert').

Use `(set/unset-feature trace-subgoals)' to en/disable goal tracing of the
inference engine."
  (CL:HANDLER-CASE
   (CL:RETURN-FROM %RETRIEVE
    (CL:SETQ *MOST-RECENT-QUERY* (CALL-RETRIEVE QUERY)))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))
    (CL:SETQ *MOST-RECENT-QUERY* NULL))))

(CL:DEFUN RETRIEVE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%RETRIEVE ARGUMENTS))

(CL:DEFMACRO RETRIEVE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Retrieve elements of a relation (tuples) that satisfy a proposition.
The accepted syntax is:
	 
  (retrieve [<integer> | all]
            [[{<vardecl> | (<vardecl>+)}]
            <proposition>])
	
The variables and proposition are similar to an `exists' sentence or
`kappa' term without the explicit quantifier.  If variables are declared,
they must match the free variables referenced by <proposition>.  Otherwise,
the free variables referenced in <proposition> will be used as the query
variables.  If <proposition> is omitted, the most recently asked query
will be continued.

A solution is a set of bindings for the listed variables for which
<proposition> is true.  The optional first argument controls how many
solutions should be generated before control is returned.  The keyword
`all' indicates that all solutions should be generated.  By default,
`retrieve' returns after it has found one new solution or if it cannot
find any more solutions.

`retrieve' returns an iterator which saves all the necessary state of
a query and stores all generated solutions.  When used interactively,
the returned iterator will print out with the set of solutions collected
so far.  Calling `retrieve' without any arguments (or only with the first
argument) will generate one (or more) solutions to the most recently
asked query.

KIF examples:
	 
  (retrieve (happy ?x))
	
will try to find one happy entity and store it in the returned 
query iterator.
	 
  (retrieve 10 (happy ?x))
	
will try to find 10 happy entities.
	 
  (retrieve 10)
	
will try to find the next 10 happy entities..
	 
  (retrieve all (happy ?x))
	
will find all happy entities.
	 
  (retrieve all (?x Person) (happy ?x))
	
will to find all happy people.  Here we used the optional retrieve variable
syntax to restrict the acceptable solutions.  The above is equivalent to
the following query:
	 
  (retrieve all (and (Person ?x) (happy ?x)))
	
Similarly,
	 
  (retrieve all (?x Person))
  (retrieve all (Person ?x))
  (retrieve all ?x (Person ?x))
	
will find all people.  Note that in the first case we only specify a query
variable and its type but omit the logic sentence which defaults to TRUE.  This
somewhat impoverished looking query can be paraphrased as \"retrieve all ?x of
type Person such that TRUE.\"
	 
  (retrieve ?x (or (happy ?x) (parent-of Fred ?x)))
	
will try to find a person that is happy or has Fred as a parent.
	 
  (retrieve (?y ?x) (parent-of ?x ?y))
	
will try to find the one pair of parent/child and return it in the order
of child/parent.
	 
  (retrieve all (?x Person)
            (exists (?y Person) (parent-of ?x ?y)))
	
will generate the set of all parents.  Note, that for these queries to run,
the class `Person', the relations `happy' and `parent-of', and the logic
constant `Fred' must already be defined (see `assert').

Use `(set/unset-feature trace-subgoals)' to en/disable goal tracing of the
inference engine."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/RETRIEVE|)) (CL:MACRO-FUNCTION (CL:QUOTE RETRIEVE)))

;;; (DEFMETHOD (CONSIFY-CURRENT-SOLUTIONS CONS) ...)

(CL:DEFMETHOD CONSIFY-CURRENT-SOLUTIONS ((SELF QUERY-ITERATOR))
  "Collect the current solutions of `self' into a cons list
of result tuples.  If `:SINGLETONS? TRUE', collect a list of atoms rather than a
list of lists for tuples of arity=1."
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:RETURN-FROM CONSIFY-CURRENT-SOLUTIONS NIL))
  (CL:LET*
   ((SOLUTIONS (%QUERY-ITERATOR.SOLUTIONS SELF))
    (LISTIFIEDSOLUTIONS NIL) (ARITY (ARITY (QUERY-DESCRIPTION SELF)))
    (ATOMICSINGLETONS?
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS SELF)
       SYM-QUERY-LOGIC-ATOMIC-SINGLETONS? FALSE-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
   (CL:LET*
    ((SOLUTION NULL) (ITER-000 (ALLOCATE-ITERATOR SOLUTIONS))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ SOLUTION (%DICTIONARY-ITERATOR.VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CL:IF (CL:AND ATOMICSINGLETONS? (CL:= ARITY 1))
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY (%QUERY-SOLUTION.BINDINGS SOLUTION)))
           0)
          (CONSIFY (%QUERY-SOLUTION.BINDINGS SOLUTION)))
         NIL))
       (CL:IF (CL:EQ LISTIFIEDSOLUTIONS NIL)
        (CL:SETQ LISTIFIEDSOLUTIONS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST LISTIFIEDSOLUTIONS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CL:IF (CL:AND ATOMICSINGLETONS? (CL:= ARITY 1))
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY (%QUERY-SOLUTION.BINDINGS SOLUTION)))
           0)
          (CONSIFY (%QUERY-SOLUTION.BINDINGS SOLUTION)))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   LISTIFIEDSOLUTIONS))

;;; (DEFMETHOD (CONSIFY CONS) ...)

(CL:DEFMETHOD CONSIFY ((SELF QUERY-ITERATOR))
  "Generate all solutions for the query self, and collect them into a cons list
of result tuples.  If `:SINGLETONS? TRUE', collect a list of atoms rather than a
list of lists for tuples of arity=1."
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM CONSIFY NIL))
  (CL:LET* ((*QUERYITERATOR* SELF) (*REVERSEPOLARITY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *QUERYITERATOR* *REVERSEPOLARITY?*))
   (CL:LOOP WHILE (NEXT? SELF)))
  (CONSIFY-CURRENT-SOLUTIONS SELF))

;;; (DEFUN (CONSIFY-QUERY CONS) ...)

(CL:DEFUN CONSIFY-QUERY (SELF)
  (CONSIFY SELF))

;;; (DEFMETHOD (LISTIFY LIST) ...)

(CL:DEFMETHOD LISTIFY ((SELF QUERY-ITERATOR))
  "Just like `QUERY-ITERATOR.consify' but return a LIST instead."
  (CL:LET* ((SELF-000 (NEW-LIST)))
   (CL:SETF (%LIST.THE-CONS-LIST SELF-000) (CONSIFY SELF))
   (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))

;;; (DEFGLOBAL *QUERY-CACHE* ...)

(CL:DEFVAR *QUERY-CACHE* NULL
  "Caches in-line queries, so that they
don't have to be reparsed and reoptimized each time they
are invoked.")

;;; (DEFUN FLUSH-INLINE-QUERY-CACHES ...)

(CL:DEFUN FLUSH-INLINE-QUERY-CACHES ()
  (CL:SETQ *QUERY-CACHE* (NEW-HASH-TABLE)))

;;; (DEFUN (MAKE-CACHED-QUERY QUERY-ITERATOR) ...)

(CL:DEFUN MAKE-CACHED-QUERY (VARIABLES QUERYBODY INPUTBINDINGS OPTIONS CACHEID)
  (CL:LET*
   ((QUERYITERATOR (LOOKUP *QUERY-CACHE* CACHEID))
    (CURSOR INPUTBINDINGS))
   (CL:WHEN (CL:NOT (CL:= (LENGTH VARIABLES) (LENGTH INPUTBINDINGS)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "make-cached-query: number of variables does not equal number of input bindings."
     EOL)
    (CL:RETURN-FROM MAKE-CACHED-QUERY NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:WHEN (CL:NOT (CL:EQ (%%VALUE CURSOR) NULL))
     (CL:SETF (%%VALUE CURSOR) (VALUE-OF (%%VALUE CURSOR))))
    (CL:SETQ CURSOR (%%REST CURSOR)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ QUERYITERATOR NULL))
     (CL:AND
      (CL:NOT (CL:EQ *QUERY-OPTIMIZATION-STRATEGY* KWD-QUERY-NONE))
      (CL:NOT
       (CL:OR (CL:EQ *QUERY-OPTIMIZATION-STRATEGY* KWD-QUERY-DYNAMIC)
        (CL:EQ *QUERY-OPTIMIZATION-STRATEGY*
         KWD-QUERY-DYNAMIC-WITH-CLUSTERING)))))
    (CL:LET*
     ((OLDB NULL)
      (VECTOR-000
       (DYNAMIC-SLOT-VALUE
        (%QUERY-ITERATOR.DYNAMIC-SLOTS QUERYITERATOR)
        SYM-QUERY-LOGIC-INITIAL-BINDINGS NULL))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (NEWB NULL)
      (ITER-000 INPUTBINDINGS))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000)
       (CL:NOT (CL:EQ ITER-000 NIL)))
      DO
      (CL:SETQ OLDB
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ NEWB (%%VALUE ITER-000))
      (CL:WHEN (CL:NOT (CL:EQ (CL:EQ OLDB NULL) (CL:EQ NEWB NULL)))
       (CL:SETQ QUERYITERATOR NULL) (CL:RETURN))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))
   (CL:IF (CL:EQ QUERYITERATOR NULL)
    (CL:PROGN
     (CL:HANDLER-CASE
      (CL:SETQ QUERYITERATOR
       (MAKE-QUERY (COPY-CONS-LIST VARIABLES)
        (COPY-CONS-TREE QUERYBODY) INPUTBINDINGS OPTIONS))
      (LOGIC-EXCEPTION (E)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        (EXCEPTION-MESSAGE E))
       (CL:RETURN-FROM MAKE-CACHED-QUERY NULL)))
     (CL:WHEN (CL:NOT (CL:EQ CACHEID NULL))
      (INSERT-AT *QUERY-CACHE* CACHEID QUERYITERATOR)))
    (CL:PROGN
     (CL:LET*
      ((NEWB NULL) (ITER-001 INPUTBINDINGS) (I NULL-INTEGER)
       (ITER-002 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ NEWB (%%VALUE ITER-001)) (CL:SETQ I ITER-002)
       (CL:LET
        ((SELF
          (%VECTOR.THE-ARRAY
           (DYNAMIC-SLOT-VALUE
            (%QUERY-ITERATOR.DYNAMIC-SLOTS QUERYITERATOR)
            SYM-QUERY-LOGIC-INITIAL-BINDINGS NULL)))
         (VALUE NEWB) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-001 (%%REST ITER-001))
       (CL:SETQ ITER-002 (CL:1+ ITER-002))))
     (RESET QUERYITERATOR)))
   (CL:WHEN (CL:NOT (CL:EQ OPTIONS NULL))
    (PROCESS-QUERY-OPTIONS QUERYITERATOR OPTIONS))
   QUERYITERATOR))

;;; (DEFUN (APPLY-CACHED-RETRIEVE CONS CONS) ...)

(CL:DEFUN APPLY-CACHED-RETRIEVE (VARIABLES QUERYBODY INPUTBINDINGS OPTIONS CACHEID)
  (CL:LET*
   ((QUERYITERATOR NULL) (BINDINGSCOUNT 0) (OUTPUTBINDINGS NIL)
    (TRUTHVALUES NIL) (FORCESINGLETONS? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM BINDINGSCOUNT))
   (CL:LET* ((IT (ALLOCATE-ITERATOR INPUTBINDINGS)))
    (CL:LOOP WHILE (NEXT? IT) DO
     (CL:WHEN (CL:NOT (CL:EQ (%CONS-ITERATOR.VALUE IT) NULL))
      (CL:SETQ BINDINGSCOUNT (CL:1+ BINDINGSCOUNT)))))
   (CL:SETQ QUERYITERATOR
    (MAKE-CACHED-QUERY VARIABLES QUERYBODY INPUTBINDINGS OPTIONS
     CACHEID))
   (CL:WHEN (CL:EQ QUERYITERATOR NULL)
    (CL:RETURN-FROM APPLY-CACHED-RETRIEVE (CL:VALUES NIL NIL)))
   (CL:WHEN
    (EQL?
     (LOOKUP (%QUERY-ITERATOR.OPTIONS QUERYITERATOR)
      KWD-QUERY-SINGLETONS?)
     TRUE-WRAPPER)
    (CL:SETQ FORCESINGLETONS? CL:T))
   (CL:LET*
    ((*QUERYITERATOR* QUERYITERATOR) (*REVERSEPOLARITY?* CL:NIL))
    (CL:DECLARE (CL:SPECIAL *QUERYITERATOR* *REVERSEPOLARITY?*))
    (CL:LOOP WHILE (NEXT? QUERYITERATOR)))
   (CL:LET*
    ((TUPLE NULL)
     (ATOMICSINGLETONS?
      (CL:AND (CL:= (LENGTH INPUTBINDINGS) (CL:1+ BINDINGSCOUNT))
       (CL:NOT FORCESINGLETONS?))))
    (CL:LET*
     ((S NULL)
      (ITER-000
       (ALLOCATE-ITERATOR (%QUERY-ITERATOR.SOLUTIONS QUERYITERATOR))))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ S (%DICTIONARY-ITERATOR.VALUE ITER-000))
      (CL:IF ATOMICSINGLETONS?
       (CL:LET*
        ((V NULL) (VECTOR-000 (%QUERY-SOLUTION.BINDINGS S))
         (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (B NULL)
         (ITER-001 INPUTBINDINGS))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE
         (CL:AND (CL:< INDEX-000 LENGTH-000)
          (CL:NOT (CL:EQ ITER-001 NIL)))
         DO
         (CL:SETQ V
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ B (%%VALUE ITER-001))
         (CL:WHEN (CL:EQ B NULL) (CL:SETQ TUPLE V))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
         (CL:SETQ ITER-001 (%%REST ITER-001))))
       (CL:LET* ((VALUES NIL))
        (CL:LET*
         ((V NULL) (VECTOR-001 (%QUERY-SOLUTION.BINDINGS S))
          (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)) (B NULL)
          (ITER-002 INPUTBINDINGS) (COLLECT-000 NULL))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
         (CL:LOOP WHILE
          (CL:AND (CL:< INDEX-001 LENGTH-001)
           (CL:NOT (CL:EQ ITER-002 NIL)))
          DO
          (CL:SETQ V
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
            INDEX-001))
          (CL:SETQ B (%%VALUE ITER-002))
          (CL:WHEN (CL:EQ B NULL)
           (CL:IF (CL:EQ COLLECT-000 NULL)
            (CL:PROGN (CL:SETQ COLLECT-000 (CONS V NIL))
             (CL:IF (CL:EQ VALUES NIL) (CL:SETQ VALUES COLLECT-000)
              (ADD-CONS-TO-END-OF-CONS-LIST VALUES COLLECT-000)))
            (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS V NIL))
             (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
          (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
          (CL:SETQ ITER-002 (%%REST ITER-002))))
        (CL:SETQ TUPLE VALUES)))
      (CL:SETQ OUTPUTBINDINGS (CONS TUPLE OUTPUTBINDINGS))
      (CL:SETQ TRUTHVALUES
       (CONS (%QUERY-SOLUTION.TRUTH-VALUE S) TRUTHVALUES)))))
   (CL:VALUES (REVERSE OUTPUTBINDINGS) (REVERSE TRUTHVALUES))))

;;; (DEFUN (APPLY-CACHED-ASK BOOLEAN TRUTH-VALUE) ...)

(CL:DEFUN APPLY-CACHED-ASK (INPUTVARIABLES QUERYBODY INPUTBINDINGS OPTIONS CACHEID)
  (CL:LET*
   ((QUERYITERATOR
     (MAKE-CACHED-QUERY INPUTVARIABLES QUERYBODY INPUTBINDINGS OPTIONS
      CACHEID)))
   (CL:WHEN (CL:EQ QUERYITERATOR NULL)
    (CL:RETURN-FROM APPLY-CACHED-ASK (CL:VALUES CL:NIL NULL)))
   (CL:VALUES (TRUE-TRUTH-VALUE? (CALL-ASK QUERYITERATOR))
    (%QUERY-SOLUTION.TRUTH-VALUE
     (%QUERY-ITERATOR.VALUE QUERYITERATOR)))))

;;; (DEFUN (GET-PROTOTYPE LOGIC-OBJECT) ...)

(CL:DEFUN GET-PROTOTYPE (DESCRIPTION)
  (CL:WHEN (CL:EQ DESCRIPTION NULL) (CL:RETURN-FROM GET-PROTOTYPE NULL))
  (CL:LET*
   ((PROTOTYPE
     (ACCESS-BINARY-VALUE DESCRIPTION
      SGT-QUERY-PL-KERNEL-KB-CONCEPT-PROTOTYPE)))
   (CL:WHEN (CL:EQ PROTOTYPE NULL)
    (CL:SETQ PROTOTYPE
     (%%VALUE
      (APPLY-CACHED-RETRIEVE
       (LIST* SYM-QUERY-LOGIC-?C SYM-QUERY-LOGIC-?P NIL)
       (LIST* SYM-QUERY-PL-KERNEL-KB-CONCEPT-PROTOTYPE
        SYM-QUERY-LOGIC-?C SYM-QUERY-LOGIC-?P NIL)
       (CONS-LIST DESCRIPTION NULL) (CONS-LIST)
       SYM-QUERY-LOGIC-F-GET-PROTOTYPE-QUERY-000))))
   (CL:LET*
    ((*EVALUATIONMODE* KWD-QUERY-EXTENSIONAL-ASSERTION)
     (*QUERYITERATOR* NULL))
    (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE* *QUERYITERATOR*))
    (ELABORATE-META-INSTANCE PROTOTYPE) PROTOTYPE)))

;;; (DEFUN (UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION? TRUTH-VALUE) ...)

(CL:DEFUN UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION? (SUB SUPER)
  (CL:WHEN *REVERSEPOLARITY?*
   (CL:RETURN-FROM UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION?
    UNKNOWN-TRUTH-VALUE))
  (CL:WHEN (COLLECTION-IMPLIES-COLLECTION? SUB SUPER)
   (CL:RETURN-FROM UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION?
    TRUE-TRUTH-VALUE))
  (CL:LET* ((*PRINTREADABLY?* CL:T))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Prototype Subsumption Test:" EOL "   sub=" SUB EOL "   super="
     SUPER EOL)))
  (CL:LET* ((RESULT UNKNOWN-TRUTH-VALUE))
   (CL:HANDLER-CASE
    (CL:LET*
     ((*CONTEXT* (GET-INFERENCE-CACHE *MODULE* KWD-QUERY-META)))
     (CL:DECLARE (CL:SPECIAL *CONTEXT*))
     (CL:SETQ RESULT
      (CALL-ASK
       (CREATE-QUERY-ITERATOR SUPER (VECTOR (GET-PROTOTYPE SUB))))))
    (LOGIC-EXCEPTION (E)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
      (EXCEPTION-MESSAGE E))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     EOL))
   RESULT))

;;; (DEFUN (DESCRIPTION-SPECIALIZES-DESCRIPTION? TRUTH-VALUE) ...)

(CL:DEFUN DESCRIPTION-SPECIALIZES-DESCRIPTION? (SUB SUPER)
  (CL:WHEN (CL:NOT (CL:= (ARITY SUB) (ARITY SUPER)))
   (CL:IF *REVERSEPOLARITY?*
    (CL:RETURN-FROM DESCRIPTION-SPECIALIZES-DESCRIPTION?
     TRUE-TRUTH-VALUE)
    (CL:RETURN-FROM DESCRIPTION-SPECIALIZES-DESCRIPTION?
     FALSE-TRUTH-VALUE)))
  (CL:WHEN *REVERSEPOLARITY?*
   (CL:RETURN-FROM DESCRIPTION-SPECIALIZES-DESCRIPTION?
    UNKNOWN-TRUTH-VALUE))
  (CL:WHEN (COLLECTION-IMPLIES-COLLECTION? SUB SUPER)
   (CL:RETURN-FROM DESCRIPTION-SPECIALIZES-DESCRIPTION?
    TRUE-TRUTH-VALUE))
  (CL:WHEN (CL:= (ARITY SUPER) 1)
   (CL:RETURN-FROM DESCRIPTION-SPECIALIZES-DESCRIPTION?
    (UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION? SUB SUPER)))
  (CL:LET* ((*PRINTREADABLY?* CL:T))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Subsumption Test:" EOL "   sub=" SUB EOL "   super=" SUPER EOL)))
  (CL:LET*
   ((SKOLEMSVECTOR
     (NEW-VECTOR (LENGTH (%DESCRIPTION.IO-VARIABLES SUB))))
    (RESULT UNKNOWN-TRUTH-VALUE))
   (PUSH-MONOTONIC-WORLD) (INITIALIZE-INFERENCE-WORLD *CONTEXT*)
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH SKOLEMSVECTOR))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY SKOLEMSVECTOR))
       (VALUE (CREATE-HYPOTHESIZED-INSTANCE "anonymous")) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:HANDLER-CASE
    (CL:PROGN (INHERIT-DESCRIPTION SKOLEMSVECTOR SUB CL:NIL)
     (CL:SETQ RESULT
      (CALL-ASK (CREATE-QUERY-ITERATOR SUPER SKOLEMSVECTOR))))
    (LOGIC-EXCEPTION (E)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
      (EXCEPTION-MESSAGE E))))
   (POP-WORLD)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     EOL))
   RESULT))

;;; (DEFUN (VECTOR-SATISFIES-DESCRIPTION? TRUTH-VALUE) ...)

(CL:DEFUN VECTOR-SATISFIES-DESCRIPTION? (VECTOR DESCRIPTION)
  (CL:WHEN (CL:NOT (CL:= (LENGTH VECTOR) (ARITY DESCRIPTION)))
   (CL:IF *REVERSEPOLARITY?*
    (CL:RETURN-FROM VECTOR-SATISFIES-DESCRIPTION? TRUE-TRUTH-VALUE)
    (CL:RETURN-FROM VECTOR-SATISFIES-DESCRIPTION? FALSE-TRUTH-VALUE)))
  (CL:WHEN *REVERSEPOLARITY?*
   (CL:RETURN-FROM VECTOR-SATISFIES-DESCRIPTION? UNKNOWN-TRUTH-VALUE))
  (CL:HANDLER-CASE
   (CL:LET* ((ALWAYS?-000 CL:T))
    (CL:LET*
     ((VALUE NULL) (VECTOR-000 VECTOR) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:SETQ VALUE
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:WHEN (CL:EQ VALUE NULL) (CL:SETQ ALWAYS?-000 CL:NIL)
       (CL:RETURN))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
    (CL:WHEN ALWAYS?-000
     (CL:RETURN-FROM VECTOR-SATISFIES-DESCRIPTION?
      (CALL-ASK (CREATE-QUERY-ITERATOR DESCRIPTION VECTOR)))))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))))
  UNKNOWN-TRUTH-VALUE)

;;; (DEFUN (INSTANCE-SATISFIES-DESCRIPTION? TRUTH-VALUE) ...)

(CL:DEFUN INSTANCE-SATISFIES-DESCRIPTION? (INSTANCE DESCRIPTION)
  (VECTOR-SATISFIES-DESCRIPTION? (VECTOR INSTANCE) DESCRIPTION))

;;; (DEFUN (COERCE-TO-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN COERCE-TO-DESCRIPTION (SELF ORIGINAL)
  (CL:WHEN (CL:EQ ORIGINAL NULL) (CL:SETQ ORIGINAL SELF))
  (CL:WHEN (CL:EQ SELF NULL)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Can't find a description for the object `" ORIGINAL "'." EOL)
   (CL:RETURN-FROM COERCE-TO-DESCRIPTION NULL))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-DESCRIPTION)
     (CL:PROGN SELF))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-RELATION)
     (CL:PROGN (GET-DESCRIPTION SELF)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-DESCRIPTION (%SURROGATE.SURROGATE-VALUE SELF)
       ORIGINAL)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-DESCRIPTION
       (LOOKUP-SURROGATE-IN-MODULE (%SYMBOL.SYMBOL-NAME SELF)
        (%SYMBOL.HOME-CONTEXT SELF) CL:NIL)
       ORIGINAL)))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-DESCRIPTION
       (LOOKUP-SURROGATE (%KEYWORD.SYMBOL-NAME SELF)) ORIGINAL)))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-DESCRIPTION
       (LOOKUP-SURROGATE (%STRING-WRAPPER.WRAPPER-VALUE SELF))
       ORIGINAL)))
    (CL:T (COERCE-TO-DESCRIPTION NULL ORIGINAL)))))

;;; (DEFUN (SPECIALIZES? TRUTH-VALUE) ...)

(CL:DEFUN SPECIALIZES? (SUBOBJECT SUPEROBJECT)
  "Try to prove if the description associated with `subObject'
specializes the description for `superObject' and return the result truth
value of the query."
  (CL:LET*
   ((SUBDESCRIPTION (COERCE-TO-DESCRIPTION SUBOBJECT NULL))
    (SUPERDESCRIPTION (COERCE-TO-DESCRIPTION SUPEROBJECT NULL)))
   (FINALIZE-OBJECTS)
   (CL:LET* ((*CONTEXT* (GET-INFERENCE-CACHE *MODULE* KWD-QUERY-META)))
    (CL:DECLARE (CL:SPECIAL *CONTEXT*))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ SUBDESCRIPTION NULL))
      (CL:NOT (CL:EQ SUPERDESCRIPTION NULL)))
     (CL:RETURN-FROM SPECIALIZES?
      (DESCRIPTION-SPECIALIZES-DESCRIPTION? SUBDESCRIPTION
       SUPERDESCRIPTION))))
   UNKNOWN-TRUTH-VALUE))

;;; (DEFUN (COERCE-TO-INSTANCE LOGIC-OBJECT) ...)

(CL:DEFUN COERCE-TO-INSTANCE (SELF ORIGINAL)
  "Return the logic instance referred to by 'self'."
  (CL:WHEN (CL:EQ ORIGINAL NULL) (CL:SETQ ORIGINAL SELF))
  (CL:WHEN (CL:EQ SELF NULL)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Can't find a logic object `" ORIGINAL "'." EOL)
   (CL:RETURN-FROM COERCE-TO-INSTANCE NULL))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-LOGIC-OBJECT)
     (CL:PROGN SELF))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-RELATION)
     (CL:PROGN (GET-DESCRIPTION SELF)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((VALUE (%SURROGATE.SURROGATE-VALUE SELF)) (STORE NULL))
       (CL:WHEN (CL:EQ VALUE NULL)
        (CL:SETQ STORE (HOME-OBJECT-STORE SELF))
        (CL:WHEN (CL:NOT (CL:EQ STORE NULL))
         (CL:SETQ VALUE (FETCH-INSTANCE STORE SELF))))
       (COERCE-TO-INSTANCE VALUE ORIGINAL))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-INSTANCE (SYMBOL-TO-SURROGATE SELF) ORIGINAL)))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-INSTANCE
       (LOOKUP-SURROGATE (%KEYWORD.SYMBOL-NAME SELF)) ORIGINAL)))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-INSTANCE
       (LOOKUP-SURROGATE (%STRING-WRAPPER.WRAPPER-VALUE SELF))
       ORIGINAL)))
    (CL:T (COERCE-TO-INSTANCE NULL ORIGINAL)))))

;;; (DEFUN (COERCE-TO-INSTANCE-OR-LITERAL OBJECT) ...)

(CL:DEFUN COERCE-TO-INSTANCE-OR-LITERAL (SELF ORIGINAL)
  "Return the logic instance referred to by `self', or `self' if it is a
literal (e.g., string or number) that can't be coerced."
  (CL:WHEN (CL:EQ ORIGINAL NULL)
   (CL:IF (CL:NOT (CL:EQ SELF NULL)) (CL:SETQ ORIGINAL SELF)
    (CL:RETURN-FROM COERCE-TO-INSTANCE-OR-LITERAL NULL)))
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:COND
    ((WRAPPER? ORIGINAL)
     (CL:RETURN-FROM COERCE-TO-INSTANCE-OR-LITERAL ORIGINAL))
    (CL:T
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Can't find a logic object `" ORIGINAL "'." EOL)
     (CL:RETURN-FROM COERCE-TO-INSTANCE-OR-LITERAL NULL))))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-LOGIC-OBJECT)
     (CL:PROGN SELF))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-RELATION)
     (CL:PROGN (GET-DESCRIPTION SELF)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-INSTANCE-OR-LITERAL (%SURROGATE.SURROGATE-VALUE SELF)
       ORIGINAL)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-INSTANCE-OR-LITERAL (SYMBOL-TO-SURROGATE SELF)
       ORIGINAL)))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-INSTANCE-OR-LITERAL
       (LOOKUP-SURROGATE (%KEYWORD.SYMBOL-NAME SELF)) ORIGINAL)))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-INSTANCE-OR-LITERAL
       (LOOKUP-SURROGATE (%STRING-WRAPPER.WRAPPER-VALUE SELF))
       ORIGINAL)))
    (CL:T (COERCE-TO-INSTANCE-OR-LITERAL NULL ORIGINAL)))))

;;; (DEFUN (COERCE-TO-VECTOR VECTOR) ...)

(CL:DEFUN COERCE-TO-VECTOR (SELF)
  "Return a vector containing the elements in `self'.
Coerce each element of `self' to be a logic object or literal."
  (CL:LET* ((VECTOR NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-VECTOR)
      (CL:PROGN (CL:SETQ VECTOR SELF)
       (CL:LET*
        ((M NULL) (VECTOR-000 SELF) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER)
         (ITER-000 0))
        (CL:DECLARE
         (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ M
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ I ITER-000)
         (CL:LET
          ((SELF (%VECTOR.THE-ARRAY VECTOR))
           (VALUE (COERCE-TO-INSTANCE-OR-LITERAL M NULL)) (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
         (CL:SETQ ITER-000 (CL:1+ ITER-000))))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-LIST)
      (CL:PROGN (CL:SETQ VECTOR (NEW-VECTOR (LENGTH SELF)))
       (CL:LET*
        ((M NULL) (ITER-001 (%LIST.THE-CONS-LIST SELF))
         (I NULL-INTEGER) (ITER-002 0))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ M (%%VALUE ITER-001)) (CL:SETQ I ITER-002)
         (CL:LET
          ((SELF (%VECTOR.THE-ARRAY VECTOR))
           (VALUE (COERCE-TO-INSTANCE-OR-LITERAL M NULL)) (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:SETQ ITER-001 (%%REST ITER-001))
         (CL:SETQ ITER-002 (CL:1+ ITER-002))))))
     ((CL:EQ TEST-VALUE-000 SGT-QUERY-STELLA-CONS)
      (CL:PROGN (CL:SETQ VECTOR (NEW-VECTOR (LENGTH SELF)))
       (CL:LET*
        ((M NULL) (ITER-003 SELF) (I NULL-INTEGER) (ITER-004 0))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-004))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
         (CL:SETQ M (%%VALUE ITER-003)) (CL:SETQ I ITER-004)
         (CL:LET
          ((SELF (%VECTOR.THE-ARRAY VECTOR))
           (VALUE (COERCE-TO-INSTANCE-OR-LITERAL M NULL)) (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:SETQ ITER-003 (%%REST ITER-003))
         (CL:SETQ ITER-004 (CL:1+ ITER-004))))))
     (CL:T
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Don't know how to coerce `" SELF "' of type `"
       (PRIMARY-TYPE SELF) "'" EOL "   into a vector." EOL))))
   VECTOR))

;;; (DEFUN (SATISFIES? TRUTH-VALUE) ...)

(CL:DEFUN SATISFIES? (INSTANCEORTUPLE RELATIONREF)
  "Try to prove whether `instanceOrTuple' satisfies the
definition of the relation `relationRef' and return the result truth value
of the query.  `instanceOrTuple' can be a single object, the name or surrogate
of an object, or a collection (a list or vector) of objects.  `relationRef'
can be a relation, description, surrogate or relation name."
  (CL:LET* ((DESCRIPTION (COERCE-TO-DESCRIPTION RELATIONREF NULL)))
   (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL)) (FINALIZE-OBJECTS)
    (CL:LET*
     ((*CONTEXT* (GET-QUERY-CONTEXT))
      (*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)))
     (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
     (CL:IF
      (CL:OR (ISA? INSTANCEORTUPLE SGT-QUERY-STELLA-COLLECTION)
       (CONS? INSTANCEORTUPLE))
      (CL:LET* ((VECTOR (COERCE-TO-VECTOR INSTANCEORTUPLE)))
       (CL:WHEN (CL:NOT (CL:EQ VECTOR NULL))
        (CL:RETURN-FROM SATISFIES?
         (VECTOR-SATISFIES-DESCRIPTION? VECTOR DESCRIPTION))))
      (CL:LET* ((INSTANCE (COERCE-TO-INSTANCE INSTANCEORTUPLE NULL)))
       (CL:WHEN (CL:NOT (CL:EQ INSTANCE NULL))
        (CL:RETURN-FROM SATISFIES?
         (INSTANCE-SATISFIES-DESCRIPTION? INSTANCE DESCRIPTION)))))))
   UNKNOWN-TRUTH-VALUE))

;;; (DEFUN (APPLY-KAPPA? BOOLEAN) ...)

(CL:DEFUN APPLY-KAPPA? (DESCRIPTION VECTOR)
  "Apply (inherit) the description 'description'
to members of the vector 'vector'.  Return TRUE if no clash was detected.
Constraint propagation happens only if it is enabled prior to calling
'apply-kappa?'."
  (CL:HANDLER-CASE
   (INHERIT-UNNAMED-DESCRIPTION VECTOR DESCRIPTION CL:NIL)
   (CLASH (E)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E) EOL)
    (CL:RETURN-FROM APPLY-KAPPA? CL:NIL)))
  CL:T)

;;; (DEFUN (UPDATE-PROPOSITIONS-FROM-QUERY (CONS OF PROPOSITION)) ...)

(CL:DEFUN UPDATE-PROPOSITIONS-FROM-QUERY (QUERY DESCRIPTION MODULE UPDATEMODE)
  (CL:WHEN (QUERY-IS-TRUE-FALSE? QUERY)
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "ERROR: Can't yet assert/retract the result of a true/false query."
      EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-QUERY-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:LET*
   ((QUERYDESCRIPTION (QUERY-DESCRIPTION QUERY))
    (PARTIAL? (QUERY-IS-PARTIAL? QUERY))
    (SOLUTIONS (%QUERY-ITERATOR.SOLUTIONS QUERY))
    (MAPPING (NEW-KEY-VALUE-LIST)) (DONTCHECKDUPLICATES? CL:NIL)
    (PROPOSITION NULL) (PROPOSITIONS NIL) (TENTHOUSANDS 0)
    (TERMINATELINE? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM TENTHOUSANDS))
   (CL:COND
    ((CL:NOT (CL:EQ DESCRIPTION NULL))
     (CL:WHEN
      (CL:AND
       (CL:NOT (CL:= (ARITY DESCRIPTION) (ARITY QUERYDESCRIPTION)))
       (CL:OR (CL:NOT (VARIABLE-ARITY? DESCRIPTION))
        (CL:< (ARITY QUERYDESCRIPTION)
         (LENGTH (%DESCRIPTION.IO-VARIABLES DESCRIPTION)))))
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
         "ERROR: Arity mismatch between query proposition and `"
         DESCRIPTION "'." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-QUERY-ERROR))
       (CL:ERROR
        (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001))))))
    (CL:T (CL:SETQ DESCRIPTION QUERYDESCRIPTION)))
   (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE *MODULE*))
   (CL:SETQ PROPOSITION (%DESCRIPTION.PROPOSITION DESCRIPTION))
   (CL:WHEN
    (CL:AND (VARIABLE-ARITY? DESCRIPTION)
     (CL:> (ARITY QUERYDESCRIPTION)
      (LENGTH (%DESCRIPTION.IO-VARIABLES DESCRIPTION))))
    (CL:WHEN
     (CL:NOT
      (CL:OR (CL:EQ (%PROPOSITION.KIND PROPOSITION) KWD-QUERY-FUNCTION)
       (CL:EQ (%PROPOSITION.KIND PROPOSITION) KWD-QUERY-PREDICATE)))
     (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
        "ERROR: Illegal variable arity description.." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-002 KWD-QUERY-ERROR))
      (CL:ERROR
       (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-002)))))
    (CL:SETQ PROPOSITION (SHALLOW-COPY-PROPOSITION PROPOSITION))
    (CL:SETF (%PROPOSITION.ARGUMENTS PROPOSITION)
     (COPY (%DESCRIPTION.IO-VARIABLES QUERYDESCRIPTION)))
    (CL:SETQ DESCRIPTION QUERYDESCRIPTION))
   (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:SETQ DONTCHECKDUPLICATES?
     (CL:AND (NAMED-DESCRIPTION? DESCRIPTION)
      (EMPTY? (GET-DESCRIPTION-EXTENSION DESCRIPTION CL:NIL))))
    (CL:LET*
     ((SOLUTION NULL) (ITER-000 (ALLOCATE-ITERATOR SOLUTIONS))
      (I NULL-INTEGER) (ITER-001 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ SOLUTION (%DICTIONARY-ITERATOR.VALUE ITER-000))
      (CL:SETQ I ITER-001) (CLEAR MAPPING)
      (CL:COND
       ((CL:= (MOD I 10000) 9999)
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
          (MEMB? *TRACED-KEYWORDS* KWD-QUERY-UPDATE-FROM-QUERY))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          (CL:SETQ TENTHOUSANDS (CL:1+ TENTHOUSANDS))))
        (FLUSH-OUTPUT STANDARD-OUTPUT))
       ((CL:= (MOD I 1000) 999)
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
          (MEMB? *TRACED-KEYWORDS* KWD-QUERY-UPDATE-FROM-QUERY))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "."))
        (FLUSH-OUTPUT STANDARD-OUTPUT) (CL:SETQ TERMINATELINE? CL:T)))
      (CL:LET*
       ((VAR NULL) (VECTOR-000 (%DESCRIPTION.IO-VARIABLES DESCRIPTION))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (BINDING NULL)
        (VECTOR-001 (%QUERY-SOLUTION.BINDINGS SOLUTION)) (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-000 LENGTH-000)
         (CL:< INDEX-001 LENGTH-001))
        DO
        (CL:SETQ VAR
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ BINDING
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (INSERT-AT MAPPING VAR BINDING)
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      (CL:LET*
       ((PROP NULL)
        (ITER-002
         (INHERIT-AS-TOP-LEVEL-PROPOSITION PROPOSITION MAPPING)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:SETQ PROP (%%VALUE ITER-002))
        (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
         SYM-QUERY-LOGIC-DESCRIPTIVE?
         (CL:IF CL:NIL TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
        (CL:SETQ PROP
         (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS PROP
          DONTCHECKDUPLICATES?))
        (CL:LET*
         ((THISUPDATEMODE UPDATEMODE)
          (TRUTHVALUE (%QUERY-SOLUTION.TRUTH-VALUE SOLUTION))
          (EQUIVALENCE?
           (CL:EQ (%PROPOSITION.KIND PROP) KWD-QUERY-EQUIVALENT)))
         (CL:WHEN
          (CL:OR (CL:EQ TRUTHVALUE FALSE-TRUTH-VALUE)
           (CL:EQ TRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE))
          (CL:SETQ THISUPDATEMODE (INVERT-UPDATE-MODE THISUPDATEMODE)))
         (CL:WHEN
          (CL:OR (CL:EQ TRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
           (CL:EQ TRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE))
          (CL:SETQ THISUPDATEMODE
           (DEFAULTIFY-UPDATE-MODE THISUPDATEMODE)))
         (CL:IF EQUIVALENCE?
          (UPDATE-EQUIVALENCE-PROPOSITION PROP THISUPDATEMODE)
          (UPDATE-PROPOSITION-TRUTH-VALUE PROP THISUPDATEMODE))
         (CL:WHEN PARTIAL?
          (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
           SYM-QUERY-LOGIC-WEIGHT
           (WRAP-FLOAT (%QUERY-SOLUTION.MATCH-SCORE SOLUTION))
           NULL-FLOAT-WRAPPER))
         (CL:SETQ PROPOSITIONS (CONS PROP PROPOSITIONS)))
        (CL:SETQ ITER-002 (%%REST ITER-002))))
      (CL:SETQ ITER-001 (CL:1+ ITER-001)))))
   (CL:WHEN TERMINATELINE?
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
      (MEMB? *TRACED-KEYWORDS* KWD-QUERY-UPDATE-FROM-QUERY))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      EOL)))
   (REVERSE PROPOSITIONS)))

;;; (DEFUN (GET-QUERY-ITERATOR-FROM-COMMAND QUERY-ITERATOR) ...)

(CL:DEFUN GET-QUERY-ITERATOR-FROM-COMMAND (QUERY)
  (CL:LET* ((QUERYITERATOR (EVALUATE-LOGIC-COMMAND QUERY CL:T)))
   (CL:WHEN
    (CL:AND
     (CL:NOT (ISA? QUERYITERATOR SGT-QUERY-LOGIC-QUERY-ITERATOR))
     (SYMBOL? (%%VALUE QUERY))
     (STRING-EQUAL?
      (SUBSEQUENCE (%SYMBOL.SYMBOL-NAME (%%VALUE QUERY)) 0 3) "ASK"))
    (CL:SETQ QUERYITERATOR *MOST-RECENT-QUERY*))
   (CL:WHEN
    (CL:NOT (ISA? QUERYITERATOR SGT-QUERY-LOGIC-QUERY-ITERATOR))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "ERROR: Couldn't generate a query iterator result from `" QUERY
       "'." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-QUERY-ERROR))
     (CL:ERROR
      (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   QUERYITERATOR))

;;; (DEFUN (ASSERT-FROM-QUERY (CONS OF PROPOSITION)) ...)

(CL:DEFUN %ASSERT-FROM-QUERY (QUERY OPTIONS)
  "Evaluate `query', instantiate the query proposition for each generated
solution and assert the resulting propositions.  The accepted syntax
is as follows:
	 
 (assert-from-query <query-command>
                    [:relation <relation-name>]
                    [:pattern <description-term>]
                    [:module <module-name>])
	
<query-command> has to be a strict or partial retrieval command. If a
:relation option is supplied, <relation-name> is used as the relation
of the resulting propositions.  In this case the bindings of each
solution will become arguments to the specified relation in the order
of `query's output variables (the arities have to match).  The
:pattern option is a generalization of this mechanism that specifies
an arbitrary proposition pattern to be instantiated by the query's
solution.  In this case <description-term> has to be a SETOFALL or
KAPPA expression whose IO-variables will be bound in sequence to the
bindings of a query solution to generate the resulting proposition.
Finally, if a :module option is specified, the assertions will be
generated in that module.  Note that for this to work the relations
referenced in the query proposition or pattern have to be visible in
the module.  Also, instances will not be copied to the target module,
therefore, the resulting propositions might reference external
out-of-module objects in case they are not visible there.
Here are some examples:
	 
 (assert-from-query (retrieve all (foo ?x ?y)))
 (assert-from-query (retrieve all (?y ?x)
                             (exists ?z
                               (and (foo ?x ?z)
                                    (foo ?z ?y))))
                    :relation bar :module other)
 (assert-from-query
   (retrieve all (and (relation ?x) (symmetric ?x)))
   :pattern (kappa (?pred)
              (forall (?x ?y)
                (=> (holds ?pred ?x ?y)
                    (holds ?pred ?y ?x))))))
	
"
  (CL:HANDLER-CASE
   (CL:LET*
    ((THEOPTIONS
      (PARSE-LOGIC-COMMAND-OPTIONS OPTIONS
       (LIST* KWD-QUERY-MODULE SGT-QUERY-STELLA-MODULE
        KWD-QUERY-RELATION SGT-QUERY-LOGIC-NAMED-DESCRIPTION
        KWD-QUERY-PATTERN SGT-QUERY-STELLA-CONS NIL)
       CL:T CL:NIL))
     (QUERYITERATOR (GET-QUERY-ITERATOR-FROM-COMMAND QUERY))
     (PATTERN NULL))
    (CL:WHEN
     (CL:NOT (CL:EQ (LOOKUP THEOPTIONS KWD-QUERY-PATTERN) NULL))
     (CL:SETQ PATTERN
      (CONCEIVE-TERM (LOOKUP THEOPTIONS KWD-QUERY-PATTERN))))
    (CL:RETURN-FROM %ASSERT-FROM-QUERY
     (UPDATE-PROPOSITIONS-FROM-QUERY QUERYITERATOR
      (CL:IF (CL:NOT (CL:EQ PATTERN NULL)) PATTERN
       (LOOKUP THEOPTIONS KWD-QUERY-RELATION))
      (LOOKUP THEOPTIONS KWD-QUERY-MODULE) KWD-QUERY-ASSERT-TRUE)))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))))
  NULL)

(CL:DEFUN ASSERT-FROM-QUERY-EVALUATOR-WRAPPER (ARGUMENTS)
  (%ASSERT-FROM-QUERY (%%VALUE ARGUMENTS) (%%REST ARGUMENTS)))

(CL:DEFMACRO ASSERT-FROM-QUERY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Evaluate `query', instantiate the query proposition for each generated
solution and assert the resulting propositions.  The accepted syntax
is as follows:
	 
 (assert-from-query <query-command>
                    [:relation <relation-name>]
                    [:pattern <description-term>]
                    [:module <module-name>])
	
<query-command> has to be a strict or partial retrieval command. If a
:relation option is supplied, <relation-name> is used as the relation
of the resulting propositions.  In this case the bindings of each
solution will become arguments to the specified relation in the order
of `query's output variables (the arities have to match).  The
:pattern option is a generalization of this mechanism that specifies
an arbitrary proposition pattern to be instantiated by the query's
solution.  In this case <description-term> has to be a SETOFALL or
KAPPA expression whose IO-variables will be bound in sequence to the
bindings of a query solution to generate the resulting proposition.
Finally, if a :module option is specified, the assertions will be
generated in that module.  Note that for this to work the relations
referenced in the query proposition or pattern have to be visible in
the module.  Also, instances will not be copied to the target module,
therefore, the resulting propositions might reference external
out-of-module objects in case they are not visible there.
Here are some examples:
	 
 (assert-from-query (retrieve all (foo ?x ?y)))
 (assert-from-query (retrieve all (?y ?x)
                             (exists ?z
                               (and (foo ?x ?z)
                                    (foo ?z ?y))))
                    :relation bar :module other)
 (assert-from-query
   (retrieve all (and (relation ?x) (symmetric ?x)))
   :pattern (kappa (?pred)
              (forall (?x ?y)
                (=> (holds ?pred ?x ?y)
                    (holds ?pred ?y ?x))))))
	
"
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/ASSERT-FROM-QUERY|)) (CL:MACRO-FUNCTION (CL:QUOTE ASSERT-FROM-QUERY)))

;;; (DEFUN (RETRACT-FROM-QUERY (CONS OF PROPOSITION)) ...)

(CL:DEFUN %RETRACT-FROM-QUERY (QUERY OPTIONS)
  "Evaluate `query' which has to be a strict or partial retrieval
command, instantiate the query proposition for each generated solution
and retract the resulting propositions.  See `assert-from-query' for
available command options."
  (CL:HANDLER-CASE
   (CL:LET*
    ((THEOPTIONS
      (PARSE-LOGIC-COMMAND-OPTIONS OPTIONS
       (LIST* KWD-QUERY-MODULE SGT-QUERY-STELLA-MODULE
        KWD-QUERY-RELATION SGT-QUERY-LOGIC-NAMED-DESCRIPTION
        KWD-QUERY-PATTERN SGT-QUERY-STELLA-CONS NIL)
       CL:T CL:NIL))
     (QUERYITERATOR (GET-QUERY-ITERATOR-FROM-COMMAND QUERY))
     (PATTERN NULL))
    (CL:WHEN
     (CL:NOT (CL:EQ (LOOKUP THEOPTIONS KWD-QUERY-PATTERN) NULL))
     (CL:SETQ PATTERN
      (CONCEIVE-TERM (LOOKUP THEOPTIONS KWD-QUERY-PATTERN))))
    (CL:RETURN-FROM %RETRACT-FROM-QUERY
     (UPDATE-PROPOSITIONS-FROM-QUERY QUERYITERATOR
      (CL:IF (CL:NOT (CL:EQ PATTERN NULL)) PATTERN
       (LOOKUP THEOPTIONS KWD-QUERY-RELATION))
      (LOOKUP THEOPTIONS KWD-QUERY-MODULE) KWD-QUERY-RETRACT-TRUE)))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))))
  NULL)

(CL:DEFUN RETRACT-FROM-QUERY-EVALUATOR-WRAPPER (ARGUMENTS)
  (%RETRACT-FROM-QUERY (%%VALUE ARGUMENTS) (%%REST ARGUMENTS)))

(CL:DEFMACRO RETRACT-FROM-QUERY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Evaluate `query' which has to be a strict or partial retrieval
command, instantiate the query proposition for each generated solution
and retract the resulting propositions.  See `assert-from-query' for
available command options."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/RETRACT-FROM-QUERY|)) (CL:MACRO-FUNCTION (CL:QUOTE RETRACT-FROM-QUERY)))

;;; (DEFUN (DISPLAY-SETTINGS STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION () CL:SIMPLE-STRING) DISPLAY-SETTINGS))
(CL:DEFUN DISPLAY-SETTINGS ()
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
   "*LAZY-SATELLITE-RULES?* =  " *LAZY-SATELLITE-RULES?* EOL
   "*CACHE-SUCCEEDED-GOALS?* =  " *CACHE-SUCCEEDED-GOALS?* EOL
   "*CACHE-FAILED-GOALS?* =  " *CACHE-FAILED-GOALS?* EOL
   "*CACHE-GOAL-QUANTUM* =  " *CACHE-GOAL-QUANTUM* EOL
   "*CACHE-INFERABLE-SUBCOLLECTIONS?* =  "
   *CACHE-INFERABLE-SUBCOLLECTIONS?* EOL "*INFERENCELEVEL* =  "
   *INFERENCELEVEL* EOL "*MAXIMUM-BACKTRACKING-DEPTH* =  "
   *MAXIMUM-BACKTRACKING-DEPTH* EOL "*TYPE-CHECK-STRATEGY* =  "
   *TYPE-CHECK-STRATEGY* EOL "*DUPLICATE-SUBGOAL-STRATEGY* =  "
   *DUPLICATE-SUBGOAL-STRATEGY* EOL "*DUPLICATE-GOAL-SEARCH-DEPTH* =  "
   *DUPLICATE-GOAL-SEARCH-DEPTH* EOL
   "*DUPLICATE-RULE-SEARCH-DEPTH* =  " *DUPLICATE-RULE-SEARCH-DEPTH*
   EOL "*GLOBALLY-CLOSED-COLLECTIONS?* =  "
   *GLOBALLY-CLOSED-COLLECTIONS?* EOL "*DEFAULT-MAXIMUM-DEPTH* =  "
   *DEFAULT-MAXIMUM-DEPTH* EOL "*INITIAL-BACKTRACKING-DEPTH* =  "
   *INITIAL-BACKTRACKING-DEPTH* EOL "*ITERATIVE-DEEPENING-MODE?* =  "
   *ITERATIVE-DEEPENING-MODE?* EOL
   "*DUPLICATEINSTANCESCACHECROSSOVERPOINT* =  "
   *DUPLICATEINSTANCESCACHECROSSOVERPOINT* EOL
   "*CLASSIFY-FROM-NON-INFERABLE-PARENTS-ONLY?* =  "
   *CLASSIFY-FROM-NON-INFERABLE-PARENTS-ONLY?* EOL EOL)
  "")

(CL:DEFUN HELP-STARTUP-QUERY1 ()
  (CL:PROGN
   (CL:SETQ SGT-QUERY-LOGIC-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-LEVEL" NULL 1))
   (CL:SETQ SYM-QUERY-STELLA-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-QUERY-LOGIC-NORMAL-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NORMAL-INFERENCE-LEVEL" NULL 1))
   (CL:SETQ SGT-QUERY-LOGIC-BACKTRACKING-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKTRACKING-INFERENCE-LEVEL" NULL
     1))
   (CL:SETQ SGT-QUERY-LOGIC-SUBSUMPTION-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-INFERENCE-LEVEL" NULL
     1))
   (CL:SETQ SGT-QUERY-LOGIC-SHALLOW-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHALLOW-INFERENCE-LEVEL" NULL 1))
   (CL:SETQ SGT-QUERY-LOGIC-ASSERTION-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERTION-INFERENCE-LEVEL" NULL
     1))
   (CL:SETQ SGT-QUERY-LOGIC-REFUTATION-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFUTATION-INFERENCE-LEVEL" NULL
     1))
   (CL:SETQ KWD-QUERY-NORMAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NORMAL" NULL 2))
   (CL:SETQ KWD-QUERY-BACKTRACKING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKTRACKING" NULL 2))
   (CL:SETQ KWD-QUERY-SUBSUMPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION" NULL 2))
   (CL:SETQ KWD-QUERY-SHALLOW
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHALLOW" NULL 2))
   (CL:SETQ KWD-QUERY-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERTION" NULL 2))
   (CL:SETQ KWD-QUERY-REFUTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFUTATION" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-LEVEL" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-SET-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-INFERENCE-LEVEL" NULL 0))
   (CL:SETQ KWD-QUERY-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-QUERY-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-QUERY-LOOKUP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP" NULL 2))
   (CL:SETQ KWD-QUERY-DUPLICATE-GOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DUPLICATE-GOALS" NULL 2))
   (CL:SETQ KWD-QUERY-TRACE-SUBGOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRACE-SUBGOALS" NULL 2))
   (CL:SETQ KWD-QUERY-PROPAGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPAGATE" NULL 2))
   (CL:SETQ KWD-QUERY-STRATEGIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRATEGIES" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-COST-ESTIMATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COST-ESTIMATE" NULL 0))
   (CL:SETQ SGT-QUERY-LOGIC-QUERY-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-ITERATOR" NULL 1))
   (CL:SETQ SYM-QUERY-LOGIC-RESIDUE-GOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RESIDUE-GOALS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-BEST-GOAL-SEQUENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BEST-GOAL-SEQUENCE" NULL 0))
   (CL:SETQ SYM-QUERY-STELLA-BAD?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BAD?"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-QUERY-LOGIC-EXTERNAL-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTERNAL-VARIABLES" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-EXHAUSTED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXHAUSTED?" NULL 0))
   (CL:SETQ SYM-QUERY-STELLA-OPTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTIONS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-QUERY-LOGIC-SOLUTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SOLUTIONS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-QUERY-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-CONTEXT" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-BASE-CONTROL-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BASE-CONTROL-FRAME" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CURRENT-CONTROL-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-CONTROL-FRAME" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CURRENT-PATTERN-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-PATTERN-RECORD" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CURRENT-PARALLEL-THREAD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-PARALLEL-THREAD" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CONTROL-FRAME-PRIORITY-QUEUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTROL-FRAME-PRIORITY-QUEUE" NULL
     0))
   (CL:SETQ SYM-QUERY-LOGIC-AUGMENTED-GOAL-CACHE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AUGMENTED-GOAL-CACHE?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ACTIVE-GOAL-CACHES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-GOAL-CACHES" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-TRIGGERED-DEPTH-CUTOFF?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRIGGERED-DEPTH-CUTOFF?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-FAILED-TO-FIND-DUPLICATE-SUBGOAL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILED-TO-FIND-DUPLICATE-SUBGOAL?"
     NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-FOUND-AT-LEAST-ONE-SOLUTION?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FOUND-AT-LEAST-ONE-SOLUTION?" NULL
     0))
   (CL:SETQ SYM-QUERY-LOGIC-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMESTAMP" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-PARTIAL-MATCH-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL-MATCH-STRATEGY" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CURRENT-DEPTH-CUTOFF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-DEPTH-CUTOFF" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-MAXIMUM-DEPTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAXIMUM-DEPTH" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ALLOTTED-TIME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOTTED-TIME" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ALLOTTED-CLOCK-TICKS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOTTED-CLOCK-TICKS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CURRENT-CLOCK-TICKS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-CLOCK-TICKS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-TIMEOUT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMEOUT?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-NEGATED-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEGATED-QUERY" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-LATEST-PARTIAL-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LATEST-PARTIAL-SCORE" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-AUXILIARY-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AUXILIARY-QUERY" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LATEST-POSITIVE-SCORE" NULL 0))
   (CL:SETQ SYM-QUERY-STELLA-DELETED-OBJECT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DELETED-OBJECT?"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-QUERY-LOGIC-GOAL-BINDINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-BINDINGS" NULL 0))
   (CL:SETQ SGT-QUERY-LOGIC-CONTROL-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTROL-FRAME" NULL 1))
   (CL:SETQ SYM-QUERY-STELLA-STATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STATE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-QUERY-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 0))))

(CL:DEFUN HELP-STARTUP-QUERY2 ()
  (CL:PROGN
   (CL:SETQ SYM-QUERY-LOGIC-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-REVERSE-POLARITY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REVERSE-POLARITY?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-STARTING-CLOCK-TICKS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTING-CLOCK-TICKS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-UP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWN" NULL 0))
   (CL:SETQ SYM-QUERY-STELLA-RESULT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RESULT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-QUERY-LOGIC-ARGUMENT-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-CURSOR" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-PATTERN-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-RECORD" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-INHERITED-PATTERN-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INHERITED-PATTERN-RECORD" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CHOICE-POINT-UNBINDING-OFFSET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHOICE-POINT-UNBINDING-OFFSET"
     NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CURRENT-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-STRATEGY" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-NEXT-STRATEGIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEXT-STRATEGIES" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-PARTIAL-MATCH-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL-MATCH-FRAME" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATIONS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CACHED-GOAL-RESULT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHED-GOAL-RESULT?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-DONT-CACHE-GOAL-FAILURE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-CACHE-GOAL-FAILURE?" NULL 0))
   (CL:SETQ SGT-QUERY-LOGIC-PARALLEL-THREAD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARALLEL-THREAD" NULL 1))
   (CL:SETQ SYM-QUERY-LOGIC-TOP-CONTROL-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOP-CONTROL-FRAME" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-HYPOTHETICAL-WORLD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HYPOTHETICAL-WORLD" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-VARIABLE-BINDINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-BINDINGS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-UNBINDING-STACK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBINDING-STACK" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-TOP-UNBINDING-STACK-OFFSET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOP-UNBINDING-STACK-OFFSET" NULL
     0))
   (CL:SETQ SYM-QUERY-LOGIC-PRIORITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIORITY" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-STATUS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STATUS" NULL 0))
   (CL:SETQ SGT-QUERY-LOGIC-PARALLEL-CONTROL-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARALLEL-CONTROL-FRAME" NULL 1))
   (CL:SETQ SYM-QUERY-LOGIC-CHILD-THREADS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHILD-THREADS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-UNBOUND-VARIABLES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBOUND-VARIABLES?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CURRENT-CHILD-THREAD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-CHILD-THREAD" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-SAVED-PARENT-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVED-PARENT-CONTEXT" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-SAVED-PARENT-PARALLEL-THREAD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVED-PARENT-PARALLEL-THREAD" NULL
     0))
   (CL:SETQ SGT-QUERY-LOGIC-CONTROL-FRAME-PRIORITY-QUEUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTROL-FRAME-PRIORITY-QUEUE" NULL
     1))
   (CL:SETQ SYM-QUERY-LOGIC-QUEUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUEUE" NULL 0))
   (CL:SETQ KWD-QUERY-UPCLASSIFY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UPCLASSIFY" NULL 2))
   (CL:SETQ KWD-QUERY-DOWNCLASSIFY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWNCLASSIFY" NULL 2))
   (CL:SETQ KWD-QUERY-PARTIAL-MATCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL-MATCH" NULL 2))
   (CL:SETQ SGT-QUERY-LOGIC-PROOF-ADJUNCT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROOF-ADJUNCT" NULL 1))
   (CL:SETQ SGT-QUERY-LOGIC-PATTERN-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-RECORD" NULL 1))
   (CL:SETQ SYM-QUERY-LOGIC-CONTROL-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTROL-FRAME" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-EXTERNAL-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTERNAL-ARGUMENTS" NULL 0))
   (CL:SETQ SYM-QUERY-STELLA-BOOLEAN-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-VECTOR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-QUERY-LOGIC-OPTIMAL-PATTERN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTIMAL-PATTERN" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-COLLECTION-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION-LIST" NULL 0))
   (CL:SETQ SGT-QUERY-LOGIC-BOOLEAN-VECTOR-INDEX-NODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-VECTOR-INDEX-NODE" NULL
     1))
   (CL:SETQ SYM-QUERY-LOGIC-TRUE-LINK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE-LINK" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-FALSE-LINK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE-LINK" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-THE-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-VECTOR" NULL 0))
   (CL:SETQ SGT-QUERY-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ KWD-QUERY-PATTERN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN" NULL 2))
   (CL:SETQ KWD-QUERY-CONTAINED-BY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTAINED-BY" NULL 2))
   (CL:SETQ KWD-QUERY-PARENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-CACHED-BINDINGS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHED-BINDINGS-ITERATOR" NULL 0))
   (CL:SETQ KWD-QUERY-POPPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POPPED" NULL 2))
   (CL:SETQ KWD-QUERY-LOCAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOCAL" NULL 2))
   (CL:SETQ KWD-QUERY-QUERY-STACKS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-STACKS" NULL 2))
   (CL:SETQ SGT-QUERY-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SGT-QUERY-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-QUERY-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ KWD-QUERY-NONE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NONE" NULL 2))
   (CL:SETQ KWD-QUERY-SHALLOW-DISJOINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHALLOW-DISJOINT" NULL 2))))

(CL:DEFUN HELP-STARTUP-QUERY3 ()
  (CL:PROGN
   (CL:SETQ KWD-QUERY-DISJOINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISJOINT" NULL 2))
   (CL:SETQ KWD-QUERY-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ SGT-QUERY-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ KWD-QUERY-PERFORMANCE-CLUES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PERFORMANCE-CLUES" NULL 2))
   (CL:SETQ KWD-QUERY-WARNING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARNING" NULL 2))
   (CL:SETQ SYM-QUERY-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-QUERY-STELLA-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-QUERY-STELLA-SURROGATE-VALUE-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE-INVERSE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-QUERY-LOGIC-MASTER-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
   (CL:SETQ KWD-QUERY-FLAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLAT" NULL 2))
   (CL:SETQ KWD-QUERY-REALISTIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REALISTIC" NULL 2))
   (CL:SETQ KWD-QUERY-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWN" NULL 2))
   (CL:SETQ KWD-QUERY-ITERATIVE-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATIVE-FORALL" NULL 2))
   (CL:SETQ KWD-QUERY-STATE-MACHINE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STATE-MACHINE" NULL 2))
   (CL:SETQ KWD-QUERY-PARALLEL-STRATEGIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARALLEL-STRATEGIES" NULL 2))
   (CL:SETQ KWD-QUERY-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRATEGY" NULL 2))
   (CL:SETQ KWD-QUERY-SPECIALIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIALIST" NULL 2))
   (CL:SETQ KWD-QUERY-ATOMIC-GOAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ATOMIC-GOAL" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-ANTECEDENTS-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS-RULE" NULL 0))
   (CL:SETQ KWD-QUERY-UP-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TRUE" NULL 2))
   (CL:SETQ KWD-QUERY-UP-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-FAIL" NULL 2))
   (CL:SETQ KWD-QUERY-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-QUERY-GOAL-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-TREE" NULL 2))
   (CL:SETQ KWD-QUERY-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-QUERY-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-QUERY-FULL-SUBQUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULL-SUBQUERY" NULL 2))
   (CL:SETQ KWD-QUERY-ANTECEDENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS" NULL 2))
   (CL:SETQ SYM-QUERY-STELLA-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-QUERY-FAILURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILURE" NULL 2))
   (CL:SETQ KWD-QUERY-FINAL-SUCCESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINAL-SUCCESS" NULL 2))
   (CL:SETQ SGT-QUERY-LOGIC-NN-PARTIAL-MATCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NN-PARTIAL-MATCH" NULL 1))
   (CL:SETQ SYM-QUERY-LOGIC-MATCH-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MATCH-SCORE" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-SUPPORT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPPORT" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-BACK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACK" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATION" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-GOAL-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-CACHE" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-DEBUG-FRAME-ID-INTERNAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEBUG-FRAME-ID-INTERNAL" NULL 0))
   (CL:SETQ KWD-QUERY-MOVE-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MOVE-DOWN" NULL 2))
   (CL:SETQ KWD-QUERY-CONTINUING-SUCCESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUING-SUCCESS" NULL 2))
   (CL:SETQ KWD-QUERY-MOVE-IN-PLACE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MOVE-IN-PLACE" NULL 2))
   (CL:SETQ KWD-QUERY-TIMEOUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMEOUT" NULL 2))
   (CL:SETQ KWD-QUERY-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-QUERY-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ KWD-QUERY-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ KWD-QUERY-SCAN-CACHED-BINDINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-CACHED-BINDINGS" NULL 2))
   (CL:SETQ KWD-QUERY-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ KWD-QUERY-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ KWD-QUERY-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 2))
   (CL:SETQ KWD-QUERY-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ KWD-QUERY-CLUSTERED-CONJUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLUSTERED-CONJUNCTION" NULL 2))
   (CL:SETQ SYM-QUERY-STELLA-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-QUERY-DISJUNCTIVE-IMPLICATION-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "DISJUNCTIVE-IMPLICATION-INTRODUCTION" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 0))
   (CL:SETQ KWD-QUERY-DUPLICATE-GOALS-WITH-CACHING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DUPLICATE-GOALS-WITH-CACHING" NULL
     2))
   (CL:SETQ KWD-QUERY-MANUFACTURE-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MANUFACTURE-SKOLEM" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
   (CL:SETQ SGT-QUERY-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ KWD-QUERY-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-CACHED-SINGLE-VALUED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHED-SINGLE-VALUED?" NULL 0))
   (CL:SETQ KWD-QUERY-FAILED-OVERLAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILED-OVERLAY" NULL 2))))

(CL:DEFUN HELP-STARTUP-QUERY4 ()
  (CL:PROGN
   (CL:SETQ SGT-QUERY-PL-KERNEL-KB-DISJOINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISJOINT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-QUERY-LOGIC-?D1
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?D1" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-?D2
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?D2" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-DISJOINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISJOINT" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-F-DISJOINT-TERMS?-QUERY-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-DISJOINT-TERMS?-QUERY-000" NULL
     0))
   (CL:SETQ SYM-QUERY-STELLA-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-QUERY-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-QUERY-PL-KERNEL-KB-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-QUERY-LOGIC-REFUTATION-DISJOINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFUTATION-DISJOINT" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-F-EXPENSIVE-DISJOINT-TERMS?-QUERY-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-EXPENSIVE-DISJOINT-TERMS?-QUERY-000" NULL 0))
   (CL:SETQ SGT-QUERY-PL-KERNEL-KB-COLLECTIONOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTIONOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-QUERY-PL-KERNEL-KB-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-QUERY-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-QUERY-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SGT-QUERY-LOGIC-DESCRIPTION-EXTENSION-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION-EXTENSION-ITERATOR"
     NULL 1))
   (CL:SETQ SYM-QUERY-LOGIC-ROOT-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-DESCRIPTION" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-SUBCOLLECTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBCOLLECTIONS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-EXTENSION-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSION-ITERATOR" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-REFERENCE-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFERENCE-PROPOSITION" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ALREADY-GENERATED-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALREADY-GENERATED-LIST" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ALREADY-GENERATED-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALREADY-GENERATED-TABLE" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-REMOVING-DUPLICATES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REMOVING-DUPLICATES?" NULL 0))
   (CL:SETQ KWD-QUERY-GOAL-CACHES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-CACHES" NULL 2))
   (CL:SETQ KWD-QUERY-DEPTH-VIOLATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPTH-VIOLATION" NULL 2))
   (CL:SETQ KWD-QUERY-DEPTH-CUTOFF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPTH-CUTOFF" NULL 2))
   (CL:SETQ KWD-QUERY-TECHNICAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TECHNICAL" NULL 2))
   (CL:SETQ KWD-QUERY-LAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LAY" NULL 2))
   (CL:SETQ SGT-QUERY-LOGIC-QUERY-SOLUTION-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-SOLUTION-TABLE" NULL 1))
   (CL:SETQ SYM-QUERY-STELLA-THE-MAP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-MAP"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-QUERY-LOGIC-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY" NULL 0))
   (CL:SETQ SYM-QUERY-STELLA-FIRST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FIRST"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-QUERY-STELLA-LAST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LAST"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-QUERY-LOGIC-QUERY-SOLUTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-SOLUTION" NULL 1))
   (CL:SETQ SYM-QUERY-LOGIC-BINDINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BINDINGS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-BEST-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BEST-JUSTIFICATION" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ALL-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-JUSTIFICATIONS" NULL 0))
   (CL:SETQ SYM-QUERY-STELLA-NEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEXT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-QUERY-LOGIC-QUERY-SOLUTION-TABLE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-SOLUTION-TABLE-ITERATOR"
     NULL 1))
   (CL:SETQ SYM-QUERY-STELLA-THE-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-TABLE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-QUERY-STELLA-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURSOR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-QUERY-TRACE-SOLUTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRACE-SOLUTIONS" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-ATOMIC-SINGLETONS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ATOMIC-SINGLETONS?" NULL 0))
   (CL:SETQ KWD-QUERY-EXECUTE-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXECUTE-QUERY" NULL 2))
   (CL:SETQ KWD-QUERY-DONT-OPTIMIZE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-OPTIMIZE?" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-DONT-OPTIMIZE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-OPTIMIZE?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-INITIAL-BINDINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIAL-BINDINGS" NULL 0))
   (CL:SETQ KWD-QUERY-ITERATIVE-DEEPENING?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATIVE-DEEPENING?" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-ITERATIVE-DEEPENING?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATIVE-DEEPENING?" NULL 0))
   (CL:SETQ KWD-QUERY-MATCH-MODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MATCH-MODE" NULL 2))
   (CL:SETQ KWD-QUERY-STRICT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRICT" NULL 2))
   (CL:SETQ KWD-QUERY-DEFERRED-OPTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFERRED-OPTIONS" NULL 2))
   (CL:SETQ KWD-QUERY-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ SYM-QUERY-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-QUERY-LOGIC-KAPPA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
   (CL:SETQ SYM-QUERY-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-QUERY-HOW-MANY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOW-MANY" NULL 2))
   (CL:SETQ KWD-QUERY-SORT-BY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SORT-BY" NULL 2))
   (CL:SETQ KWD-QUERY-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCORE" NULL 2))
   (CL:SETQ KWD-QUERY-MOVEOUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MOVEOUT" NULL 2))
   (CL:SETQ KWD-QUERY-MAXIMUM-DEPTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAXIMUM-DEPTH" NULL 2))))

(CL:DEFUN HELP-STARTUP-QUERY5 ()
  (CL:PROGN
   (CL:SETQ KWD-QUERY-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-LEVEL" NULL 2))
   (CL:SETQ SGT-QUERY-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-QUERY-THREE-VALUED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THREE-VALUED?" NULL 2))
   (CL:SETQ KWD-QUERY-SINGLETONS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SINGLETONS?" NULL 2))
   (CL:SETQ KWD-QUERY-MINIMUM-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MINIMUM-SCORE" NULL 2))
   (CL:SETQ KWD-QUERY-MAXIMIZE-SCORE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAXIMIZE-SCORE?" NULL 2))
   (CL:SETQ KWD-QUERY-MAXIMUM-UNKNOWNS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAXIMUM-UNKNOWNS" NULL 2))
   (CL:SETQ SGT-QUERY-STELLA-PROPERTY-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTY-LIST"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-QUERY-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-QUERY-STELLA-ASK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASK"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-QUERY-STELLA-RETRIEVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRIEVE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-QUERY-DYNAMIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC" NULL 2))
   (CL:SETQ KWD-QUERY-DYNAMIC-WITH-CLUSTERING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC-WITH-CLUSTERING" NULL 2))
   (CL:SETQ SGT-QUERY-PL-KERNEL-KB-CONCEPT-PROTOTYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEPT-PROTOTYPE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-QUERY-LOGIC-?C
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?C" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-?P
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?P" NULL 0))
   (CL:SETQ SYM-QUERY-PL-KERNEL-KB-CONCEPT-PROTOTYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEPT-PROTOTYPE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-QUERY-LOGIC-F-GET-PROTOTYPE-QUERY-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-GET-PROTOTYPE-QUERY-000" NULL
     0))
   (CL:SETQ KWD-QUERY-EXTENSIONAL-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIONAL-ASSERTION" NULL 2))
   (CL:SETQ KWD-QUERY-META
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META" NULL 2))
   (CL:SETQ SGT-QUERY-STELLA-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-QUERY-STELLA-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-QUERY-UPDATE-FROM-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UPDATE-FROM-QUERY" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-DESCRIPTIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTIVE?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-WEIGHT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WEIGHT" NULL 0))
   (CL:SETQ KWD-QUERY-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" NULL 2))
   (CL:SETQ SGT-QUERY-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-QUERY-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION" NULL 2))
   (CL:SETQ KWD-QUERY-ASSERT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-ASSERT-FROM-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-FROM-QUERY" NULL 0))
   (CL:SETQ KWD-QUERY-RETRACT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-TRUE" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-RETRACT-FROM-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-FROM-QUERY" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-STARTUP-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-QUERY" NULL 0))
   (CL:SETQ SYM-QUERY-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-QUERY6 ()
  (CL:PROGN
   (CL:LET* ((SELF-029 (NEW-NORMAL-INFERENCE-LEVEL)))
    (CL:SETF (%NORMAL-INFERENCE-LEVEL.KEYWORD SELF-029)
     KWD-QUERY-NORMAL)
    (CL:SETQ NORMAL-INFERENCE SELF-029))
   (CL:LET* ((SELF-030 (NEW-BACKTRACKING-INFERENCE-LEVEL)))
    (CL:SETF (%BACKTRACKING-INFERENCE-LEVEL.KEYWORD SELF-030)
     KWD-QUERY-BACKTRACKING)
    (CL:SETQ BACKTRACKING-INFERENCE SELF-030))
   (CL:LET* ((SELF-031 (NEW-SUBSUMPTION-INFERENCE-LEVEL)))
    (CL:SETF (%SUBSUMPTION-INFERENCE-LEVEL.KEYWORD SELF-031)
     KWD-QUERY-SUBSUMPTION)
    (CL:SETQ SUBSUMPTION-INFERENCE SELF-031))
   (CL:LET* ((SELF-032 (NEW-SHALLOW-INFERENCE-LEVEL)))
    (CL:SETF (%SHALLOW-INFERENCE-LEVEL.KEYWORD SELF-032)
     KWD-QUERY-SHALLOW)
    (CL:SETQ SHALLOW-INFERENCE SELF-032))
   (CL:LET* ((SELF-033 (NEW-ASSERTION-INFERENCE-LEVEL)))
    (CL:SETF (%ASSERTION-INFERENCE-LEVEL.KEYWORD SELF-033)
     KWD-QUERY-ASSERTION)
    (CL:SETQ ASSERTION-INFERENCE SELF-033))
   (CL:LET* ((SELF-034 (NEW-REFUTATION-INFERENCE-LEVEL)))
    (CL:SETF (%REFUTATION-INFERENCE-LEVEL.KEYWORD SELF-034)
     KWD-QUERY-REFUTATION)
    (CL:SETQ REFUTATION-INFERENCE SELF-034))
   (CL:SETQ *INFERENCELEVEL* NORMAL-INFERENCE)
   (CL:SETQ *MAXIMUM-BACKTRACKING-DEPTH* *DEFAULT-MAXIMUM-DEPTH*)
   (CL:SETQ *TYPE-CHECK-STRATEGY* KWD-QUERY-LOOKUP)
   (CL:SETQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
   (CL:LET* ((SELF-035 (NEW-PROPERTY-LIST)))
    (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-035)
     (LIST* KWD-QUERY-UPCLASSIFY (WRAP-CHARACTER #\u)
      (LIST* KWD-QUERY-DOWNCLASSIFY (WRAP-CHARACTER #\d)
       (LIST* KWD-QUERY-PROPAGATE (WRAP-CHARACTER #\f)
        (LIST* KWD-QUERY-PARTIAL-MATCH (WRAP-CHARACTER #\p) NIL)))))
    (CL:SETQ *THINKING-DOT-TABLE* SELF-035))
   (CL:LET* ((SELF-036 (NEW-BOOLEAN-VECTOR-INDEX-NODE)))
    (CL:SETF (%BOOLEAN-VECTOR-INDEX-NODE.THE-VECTOR SELF-036)
     (NEW-BOOLEAN-VECTOR 0))
    (CL:SETQ *BOOLEAN-VECTOR-INDEX* SELF-036))
   (CL:SETQ *QUERY-CACHE* (NEW-HASH-TABLE))))

(CL:DEFUN HELP-STARTUP-QUERY7 ()
  (CL:PROGN
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INFERENCE-LEVEL"
       "(DEFCLASS INFERENCE-LEVEL (STANDARD-OBJECT) :SLOTS ((KEYWORD :TYPE KEYWORD)) :DOCUMENTATION \"This class hierarchy is used to choose the
level of inference applied when dispatching queries (canned
or ad hoc).\")")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-INFERENCE-LEVEL))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-INFERENCE-LEVEL-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NORMAL-INFERENCE-LEVEL"
       "(DEFCLASS NORMAL-INFERENCE-LEVEL (INFERENCE-LEVEL) :DOCUMENTATION \"The normal inference level employs all proof strategies
except disjunctive implication introduction and refutation.\")")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-NORMAL-INFERENCE-LEVEL)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "BACKTRACKING-INFERENCE-LEVEL"
       "(DEFCLASS BACKTRACKING-INFERENCE-LEVEL (NORMAL-INFERENCE-LEVEL) :DOCUMENTATION \"Specifies subsumption level inference plus backtracking.\")")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-BACKTRACKING-INFERENCE-LEVEL)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "SUBSUMPTION-INFERENCE-LEVEL"
       "(DEFCLASS SUBSUMPTION-INFERENCE-LEVEL (BACKTRACKING-INFERENCE-LEVEL) :DOCUMENTATION \"Specifies lookup augmented with cached
subsumption links and equality reasoning.\")")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-SUBSUMPTION-INFERENCE-LEVEL)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SHALLOW-INFERENCE-LEVEL"
       "(DEFCLASS SHALLOW-INFERENCE-LEVEL (SUBSUMPTION-INFERENCE-LEVEL) :DOCUMENTATION \"Specifies lookup of assertions plus simple frame computations.\")")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-SHALLOW-INFERENCE-LEVEL)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ASSERTION-INFERENCE-LEVEL"
       "(DEFCLASS ASSERTION-INFERENCE-LEVEL (SUBSUMPTION-INFERENCE-LEVEL) :DOCUMENTATION \"Specifies lookup of assertions only.\")")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-ASSERTION-INFERENCE-LEVEL)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "REFUTATION-INFERENCE-LEVEL"
       "(DEFCLASS REFUTATION-INFERENCE-LEVEL (NORMAL-INFERENCE-LEVEL) :DOCUMENTATION \"Normal inference augmented by refutation proof strategy.\")")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-REFUTATION-INFERENCE-LEVEL)))
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE COST-ESTIMATE FLOAT \"Type used by the query optimizer to compute estimates of the cost of
executing a query.\")")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "QUERY-ITERATOR"
       "(DEFCLASS QUERY-ITERATOR (ITERATOR DYNAMIC-SLOTS-MIXIN) :PUBLIC? TRUE :DOCUMENTATION \"A query iterator points to a query environment
representing the initial or intermediate state of a query.  The iterator's
'value' is a vector representing a satisfying set bindings of the query's
output variables.  Each call to the iterator writes a new set of bindings
into the vector.\" :PARAMETERS ((ANY-VALUE :TYPE QUERY-SOLUTION)) :PUBLIC-SLOTS ((EXTERNAL-VARIABLES :TYPE VARIABLES-VECTOR) (INITIAL-BINDINGS :TYPE ARGUMENTS-VECTOR :ALLOCATION :DYNAMIC :DOCUMENTATION \"Supports cached queries; conceivably, this could be static.\") (EXHAUSTED? :TYPE BOOLEAN) (AUXILIARY-QUERY :TYPE QUERY-ITERATOR :ALLOCATION :DYNAMIC) (NEGATED-QUERY :RENAMES AUXILIARY-QUERY) (OPTIONS :TYPE PROPERTY-LIST :INITIALLY (NEW PROPERTY-LIST)) (SOLUTIONS :TYPE QUERY-SOLUTION-TABLE :INITIALLY (NEW QUERY-SOLUTION-TABLE) :DOCUMENTATION \"Each element holds a solution record with a
vector of bindings of the free external variables of the query plus all
the appropriate truth-value and justification support.\") (ATOMIC-SINGLETONS? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DOCUMENTATION \"If TRUE, then singleton result tuples are
consified (and printed) as atoms instead of singleton lists.\") (QUERY-CONTEXT :TYPE CONTEXT) (BASE-CONTROL-FRAME :TYPE CONTROL-FRAME) (CURRENT-CONTROL-FRAME :TYPE CONTROL-FRAME) (CURRENT-PATTERN-RECORD :TYPE PATTERN-RECORD) (CURRENT-PARALLEL-THREAD :TYPE PARALLEL-THREAD) (CONTROL-FRAME-PRIORITY-QUEUE :TYPE CONTROL-FRAME-PRIORITY-QUEUE) (AUGMENTED-GOAL-CACHE? :TYPE BOOLEAN) (ACTIVE-GOAL-CACHES :TYPE (LIST OF GOAL-CACHE) :ALLOCATION :EMBEDDED) (TRIGGERED-DEPTH-CUTOFF? :TYPE BOOLEAN) (FAILED-TO-FIND-DUPLICATE-SUBGOAL? :TYPE BOOLEAN) (FOUND-AT-LEAST-ONE-SOLUTION? :TYPE BOOLEAN) (TIMESTAMP :TYPE TIMESTAMP) (PARTIAL-MATCH-STRATEGY :TYPE PARTIAL-MATCH-FRAME) (LATEST-POSITIVE-SCORE :TYPE PARTIAL-MATCH-SCORE :ALLOCATION :DYNAMIC) (LATEST-PARTIAL-SCORE :TYPE PARTIAL-MATCH-SCORE :RENAMES LATEST-POSITIVE-SCORE) (OPTIMIZER-GOAL-RECORDS :TYPE (EXTENSIBLE-VECTOR OF GOAL-RECORD) :ALLOCATION :DYNAMIC) (RESIDUE-GOALS :TYPE (LIST OF PROPOSITION) :ALLOCATION :DYNAMIC) (BEST-GOAL-SEQUENCE :TYPE (LIST OF PROPOSITION) :ALLOCATION :DYNAMIC) (BEST-COST :TYPE COST-ESTIMATE :ALLOCATION :DYNAMIC) (INFERENCE-LEVEL :TYPE INFERENCE-LEVEL) (ITERATIVE-DEEPENING? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (CURRENT-DEPTH-CUTOFF :TYPE INTEGER) (MAXIMUM-DEPTH :TYPE INTEGER) (ALLOTTED-TIME :TYPE FLOAT :DOCUMENTATION \"If defined, timeout after that many seconds.\") (ALLOTTED-CLOCK-TICKS :TYPE INTEGER :DOCUMENTATION \"If defined, timeout after that many :DOWN moves.\") (CURRENT-CLOCK-TICKS :TYPE INTEGER :INITIALLY 0) (TIMEOUT? :TYPE BOOLEAN :DOCUMENTATION \"Set to TRUE if query times out.\")) :PRINT-FORM (PRINT-QUERY-ITERATOR SELF STREAM))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-QUERY-ITERATOR))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-QUERY-ITERATOR-SLOT-VALUE)))
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE GOAL-BINDINGS (CONS OF OBJECT))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CONTROL-FRAME"
       "(DEFCLASS CONTROL-FRAME (STANDARD-OBJECT DYNAMIC-SLOTS-MIXIN) :PUBLIC? TRUE :PUBLIC-SLOTS ((STATE :TYPE KEYWORD) (PROPOSITION :TYPE PROPOSITION) (DESCRIPTION :TYPE DESCRIPTION :ALLOCATION :DYNAMIC) (TRUTH-VALUE :TYPE TRUTH-VALUE) (REVERSE-POLARITY? :TYPE BOOLEAN) (STARTING-CLOCK-TICKS :TYPE INTEGER :DOCUMENTATION \"Clock ticks at last :DOWN move.\") (ALLOTTED-CLOCK-TICKS :TYPE INTEGER :DOCUMENTATION \"Total clock ticks allotted to prove this goal.\") (UP :TYPE CONTROL-FRAME) (DOWN :TYPE CONTROL-FRAME) (BACK :TYPE CONTROL-FRAME :ALLOCATION :DYNAMIC) (RESULT :TYPE CONTROL-FRAME) (ARGUMENTS :TYPE (VECTOR OF CONTROL-FRAME) :ALLOCATION :DYNAMIC) (ARGUMENT-CURSOR :TYPE INTEGER :INITIALLY 0) (PATTERN-RECORD :TYPE PATTERN-RECORD) (INHERITED-PATTERN-RECORD :TYPE PATTERN-RECORD) (CHOICE-POINT-UNBINDING-OFFSET :TYPE INTEGER) (CURRENT-STRATEGY :TYPE KEYWORD) (NEXT-STRATEGIES :TYPE (CONS OF KEYWORD) :INITIALLY NIL) (ITERATOR :TYPE ITERATOR :ALLOCATION :DYNAMIC) (ANTECEDENTS-RULE :TYPE PROPOSITION :ALLOCATION :DYNAMIC) (PROOF-ADJUNCT :TYPE PROOF-ADJUNCT :ALLOCATION :DYNAMIC) (PARTIAL-MATCH-FRAME :TYPE PARTIAL-MATCH-FRAME) (JUSTIFICATIONS :TYPE LIST :ALLOCATION :EMBEDDED) (JUSTIFICATION :TYPE JUSTIFICATION :ALLOCATION :DYNAMIC) (CACHED-SINGLE-VALUED? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (GOAL-BINDINGS :TYPE GOAL-BINDINGS) (CACHED-GOAL-RESULT? :TYPE BOOLEAN) (DONT-CACHE-GOAL-FAILURE? :TYPE BOOLEAN) (GOAL-CACHE :TYPE GOAL-CACHE :ALLOCATION :DYNAMIC) (CACHED-BINDINGS-ITERATOR :TYPE (ITERATOR OF GOAL-BINDINGS) :ALLOCATION :DYNAMIC)) :PUBLIC-METHODS ((HOLDS-BY-DEFAULT? ((SELF CONTROL-FRAME)) :TYPE BOOLEAN :GLOBALLY-INLINE? TRUE (RETURN (DEFAULT-TRUTH-VALUE? (TRUTH-VALUE SELF))))) :PRINT-FORM (PRINT-CONTROL-FRAME SELF STREAM))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-CONTROL-FRAME))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-CONTROL-FRAME-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PARALLEL-THREAD"
       "(DEFCLASS PARALLEL-THREAD (STANDARD-OBJECT) :SLOTS ((TOP-CONTROL-FRAME :TYPE CONTROL-FRAME) (HYPOTHETICAL-WORLD :TYPE WORLD) (VARIABLE-BINDINGS :TYPE (VECTOR OF OBJECT)) (UNBINDING-STACK :TYPE INTEGER-VECTOR) (TOP-UNBINDING-STACK-OFFSET :TYPE INTEGER) (PRIORITY :TYPE INTEGER) (STATUS :TYPE KEYWORD)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PARALLEL-THREAD))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PARALLEL-THREAD-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PARALLEL-CONTROL-FRAME"
       "(DEFCLASS PARALLEL-CONTROL-FRAME (CONTROL-FRAME) :SLOTS ((CHILD-THREADS :TYPE (LIST OF PARALLEL-THREAD) :ALLOCATION :EMBEDDED) (UNBOUND-VARIABLES? :TYPE BOOLEAN) (CURRENT-CHILD-THREAD :TYPE PARALLEL-THREAD) (SAVED-PARENT-CONTEXT :TYPE CONTEXT) (SAVED-PARENT-PARALLEL-THREAD :TYPE PARALLEL-THREAD)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PARALLEL-CONTROL-FRAME))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PARALLEL-CONTROL-FRAME-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "CONTROL-FRAME-PRIORITY-QUEUE"
       "(DEFCLASS CONTROL-FRAME-PRIORITY-QUEUE (STANDARD-OBJECT) :SLOTS ((QUEUE :TYPE (LIST OF PARALLEL-CONTROL-FRAME))))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-CONTROL-FRAME-PRIORITY-QUEUE))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-CONTROL-FRAME-PRIORITY-QUEUE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PROOF-ADJUNCT"
       "(DEFCLASS PROOF-ADJUNCT (STANDARD-OBJECT) :DOCUMENTATION \"Subclasses of 'PROOF-ADJUNCT' provide for specialized
slots (specialized for a particular strategy) to hold a record of
an ongoing proof thread.\")")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PROOF-ADJUNCT)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PATTERN-RECORD"
       "(DEFCLASS PATTERN-RECORD (STANDARD-OBJECT) :DOCUMENTATION \"A pattern record records bookkeeping data used during
the processing of a description.\" :SLOTS ((CONTROL-FRAME :TYPE CONTROL-FRAME) (VARIABLE-BINDINGS :TYPE (VECTOR OF OBJECT)) (UNBINDING-STACK :TYPE INTEGER-VECTOR) (TOP-UNBINDING-STACK-OFFSET :TYPE INTEGER) (DESCRIPTION :TYPE DESCRIPTION) (EXTERNAL-ARGUMENTS :TYPE ARGUMENTS-VECTOR) (BOOLEAN-VECTOR :TYPE BOOLEAN-VECTOR) (OPTIMAL-PATTERN :TYPE DESCRIPTION) (COLLECTION-LIST :TYPE LIST)) :TERMINATOR TERMINATE-PATTERN-RECORD?)")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PATTERN-RECORD))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PATTERN-RECORD-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "BOOLEAN-VECTOR-INDEX-NODE"
       "(DEFCLASS BOOLEAN-VECTOR-INDEX-NODE (STANDARD-OBJECT) :SLOTS ((TRUE-LINK :TYPE BOOLEAN-VECTOR-INDEX-NODE) (FALSE-LINK :TYPE BOOLEAN-VECTOR-INDEX-NODE) (THE-VECTOR :TYPE BOOLEAN-VECTOR)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-BOOLEAN-VECTOR-INDEX-NODE))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-BOOLEAN-VECTOR-INDEX-NODE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "DESCRIPTION-EXTENSION-ITERATOR"
       "(DEFCLASS DESCRIPTION-EXTENSION-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterates over the extension of a description and
its subdescriptions, returning those propositions that are currently true.\" :PARAMETERS ((ANY-VALUE :TYPE PROPOSITION)) :SLOTS ((ROOT-DESCRIPTION :TYPE NAMED-DESCRIPTION) (SUBCOLLECTIONS :TYPE (CONS OF CONS) :INITIALLY NULL) (EXTENSION-ITERATOR :TYPE (ITERATOR OF PROPOSITION)) (REFERENCE-PROPOSITION :TYPE PROPOSITION) (ALREADY-GENERATED-LIST :TYPE LIST :INITIALLY (NEW LIST)) (ALREADY-GENERATED-TABLE :TYPE HASH-TABLE) (REMOVING-DUPLICATES? :TYPE BOOLEAN) (TRUTH-VALUE :TYPE TRUTH-VALUE)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-DESCRIPTION-EXTENSION-ITERATOR))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-DESCRIPTION-EXTENSION-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "QUERY-SOLUTION-TABLE"
       "(DEFCLASS QUERY-SOLUTION-TABLE (DICTIONARY) :DOCUMENTATION \"Special key/value map for query solutions indexed by output
variable binding vectors that also preserves the order of solution generation.\" :PARAMETERS ((ANY-KEY :TYPE ARGUMENTS-VECTOR) (ANY-VALUE :TYPE QUERY-SOLUTION)) :SLOTS ((THE-MAP :TYPE (KEY-VALUE-MAP OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF))) :INITIALLY (NEW KEY-VALUE-MAP :EQUAL-TEST? TRUE)) (QUERY :TYPE QUERY-ITERATOR) (FIRST :TYPE QUERY-SOLUTION) (LAST :TYPE QUERY-SOLUTION)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-QUERY-SOLUTION-TABLE))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-QUERY-SOLUTION-TABLE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "QUERY-SOLUTION"
       "(DEFCLASS QUERY-SOLUTION (STANDARD-OBJECT) :SLOTS ((BINDINGS :TYPE ARGUMENTS-VECTOR) (TRUTH-VALUE :TYPE TRUTH-VALUE) (MATCH-SCORE :TYPE PARTIAL-MATCH-SCORE) (JUSTIFICATION :TYPE JUSTIFICATION) (BEST-JUSTIFICATION :TYPE JUSTIFICATION :RENAMES JUSTIFICATION) (ALL-JUSTIFICATIONS :TYPE (LIST OF JUSTIFICATION) :DOCUMENTATION \"All recorded justifications for
this solution in case we have multiple ones from a partial match operation.\") (NEXT :TYPE QUERY-SOLUTION)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-QUERY-SOLUTION))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-QUERY-SOLUTION-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "QUERY-SOLUTION-TABLE-ITERATOR"
       "(DEFCLASS QUERY-SOLUTION-TABLE-ITERATOR (DICTIONARY-ITERATOR) :SLOTS ((THE-TABLE :TYPE QUERY-SOLUTION-TABLE) (CURSOR :TYPE QUERY-SOLUTION)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-QUERY-SOLUTION-TABLE-ITERATOR))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-QUERY-SOLUTION-TABLE-ITERATOR-SLOT-VALUE)))))

(CL:DEFUN HELP-STARTUP-QUERY8 ()
  (CL:PROGN
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT MODULE INFERENCE-LEVEL :TYPE INFERENCE-LEVEL :DOCUMENTATION \"The default inference level used for inferences in a module.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "CURRENT-INFERENCE-LEVEL"
    "(DEFUN (CURRENT-INFERENCE-LEVEL NORMAL-INFERENCE-LEVEL) () :DOCUMENTATION \"Return the current inference level that is active in the
current query, the current module, or, otherwise, globally.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION CURRENT-INFERENCE-LEVEL) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-INFERENCE-LEVEL"
    "(DEFUN (GET-INFERENCE-LEVEL INFERENCE-LEVEL) ((LEVELKEYWORD KEYWORD)))"
    (CL:FUNCTION GET-INFERENCE-LEVEL) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-INFERENCE-LEVEL"
    "(DEFUN (SET-INFERENCE-LEVEL KEYWORD) ((LEVEL NAME) (MODULE NAME)) :DOCUMENTATION \"Set the inference level of `module' to the level specified
by 'levelKeyword'.  If `module' is NULL, set the level globally.\" :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %SET-INFERENCE-LEVEL) NULL)
   (DEFINE-FUNCTION-OBJECT "CALL-SET-INFERENCE-LEVEL"
    "(DEFUN (CALL-SET-INFERENCE-LEVEL KEYWORD) ((LEVELKEYWORD KEYWORD) (MODULE MODULE)) :DOCUMENTATION \"Set the inference level of `module' to the level specified
by 'levelKeyword'.  If `module' is NULL and we are inside a query, set the
level of the current query iterator.  Otherwise, set the level globally.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CALL-SET-INFERENCE-LEVEL) NULL)
   (DEFINE-FUNCTION-OBJECT "USING-DEFAULT-KNOWLEDGE?"
    "(DEFUN (USING-DEFAULT-KNOWLEDGE? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (NOT *DONTUSEDEFAULTKNOWLEDGE?*)))"
    (CL:FUNCTION USING-DEFAULT-KNOWLEDGE?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRACE-SUBGOALS" "(DEFUN TRACE-SUBGOALS ())"
    (CL:FUNCTION TRACE-SUBGOALS) NULL)
   (DEFINE-FUNCTION-OBJECT "UNTRACE-SUBGOALS"
    "(DEFUN UNTRACE-SUBGOALS ())" (CL:FUNCTION UNTRACE-SUBGOALS) NULL)
   (DEFINE-FUNCTION-OBJECT "TRACE-RULES" "(DEFUN TRACE-RULES ())"
    (CL:FUNCTION TRACE-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "UNTRACE-RULES" "(DEFUN UNTRACE-RULES ())"
    (CL:FUNCTION UNTRACE-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "TOGGLE-TRACE-SUBGOALS"
    "(DEFUN (TOGGLE-TRACE-SUBGOALS STRING) ())"
    (CL:FUNCTION TOGGLE-TRACE-SUBGOALS) NULL)
   (DEFINE-FUNCTION-OBJECT "TOGGLE-TRACE-RULES"
    "(DEFUN (TOGGLE-TRACE-RULES STRING) ())"
    (CL:FUNCTION TOGGLE-TRACE-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "EMIT-THINKING-DOT"
    "(DEFUN EMIT-THINKING-DOT ((KINDOFTHINKING KEYWORD)))"
    (CL:FUNCTION EMIT-THINKING-DOT) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-BOOLEAN-VECTOR-INDEX-NODE"
    "(DEFUN (CREATE-BOOLEAN-VECTOR-INDEX-NODE BOOLEAN-VECTOR-INDEX-NODE) ((PARENTNODE BOOLEAN-VECTOR-INDEX-NODE) (LASTVALUE BOOLEAN)))"
    (CL:FUNCTION CREATE-BOOLEAN-VECTOR-INDEX-NODE) NULL)
   (DEFINE-FUNCTION-OBJECT "ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR"
    "(DEFUN (ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR BOOLEAN-VECTOR) ((ARGUMENTSVECTOR ARGUMENTS-VECTOR)))"
    (CL:FUNCTION ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "ZERO-ONE-LIST-TO-BOOLEAN-VECTOR"
    "(DEFUN (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR BOOLEAN-VECTOR) ((ZEROONELIST (LIST OF INTEGER-WRAPPER))))"
    (CL:FUNCTION ZERO-ONE-LIST-TO-BOOLEAN-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "POP-CONTROL-FRAME"
    "(DEFUN POP-CONTROL-FRAME ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION POP-CONTROL-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "POP-FRAMES-UP-TO"
    "(DEFUN POP-FRAMES-UP-TO ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION POP-FRAMES-UP-TO) NULL)
   (DEFINE-FUNCTION-OBJECT "POP-DOWN-FRAME"
    "(DEFUN POP-DOWN-FRAME ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION POP-DOWN-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "ACTIVATE-PATTERN-RECORD"
    "(DEFUN ACTIVATE-PATTERN-RECORD ((PATTERNRECORD PATTERN-RECORD) (VARIABLECOUNT INTEGER)))"
    (CL:FUNCTION ACTIVATE-PATTERN-RECORD) NULL)
   (DEFINE-FUNCTION-OBJECT "RESET-CURRENT-PATTERN-RECORD"
    "(DEFUN RESET-CURRENT-PATTERN-RECORD ((FRAME CONTROL-FRAME) (LOCALORPARENT KEYWORD)))"
    (CL:FUNCTION RESET-CURRENT-PATTERN-RECORD) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-ENVIRONMENT-STACKS"
    "(DEFUN PRINT-ENVIRONMENT-STACKS ())"
    (CL:FUNCTION PRINT-ENVIRONMENT-STACKS) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-PATTERN-VARIABLE-BINDING"
    "(DEFUN SET-PATTERN-VARIABLE-BINDING ((VARIABLE PATTERN-VARIABLE) (VALUE OBJECT)))"
    (CL:FUNCTION SET-PATTERN-VARIABLE-BINDING) NULL)
   (DEFINE-FUNCTION-OBJECT "CHANGE-PATTERN-VARIABLE-BINDING"
    "(DEFUN CHANGE-PATTERN-VARIABLE-BINDING ((VARIABLE PATTERN-VARIABLE) (NEWVALUE OBJECT)))"
    (CL:FUNCTION CHANGE-PATTERN-VARIABLE-BINDING) NULL)
   (DEFINE-FUNCTION-OBJECT "UNBIND-VARIABLES-BEGINNING-AT"
    "(DEFUN UNBIND-VARIABLES-BEGINNING-AT ((PATTERNRECORD PATTERN-RECORD) (UBSTACKOFFSET INTEGER)))"
    (CL:FUNCTION UNBIND-VARIABLES-BEGINNING-AT) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-CHOICE-POINT"
    "(DEFUN CREATE-CHOICE-POINT ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION CREATE-CHOICE-POINT) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWIND-TO-CHOICE-POINT"
    "(DEFUN UNWIND-TO-CHOICE-POINT ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION UNWIND-TO-CHOICE-POINT) NULL)
   (DEFINE-FUNCTION-OBJECT "NEW-BINDINGS-SINCE-LAST-CHOICE-POINT?"
    "(DEFUN (NEW-BINDINGS-SINCE-LAST-CHOICE-POINT? BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION NEW-BINDINGS-SINCE-LAST-CHOICE-POINT?) NULL)
   (DEFINE-FUNCTION-OBJECT "BOUND-TO"
    "(DEFUN (BOUND-TO OBJECT) ((SELF PATTERN-VARIABLE)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH (VARIABLE-BINDINGS (CURRENT-PATTERN-RECORD *QUERYITERATOR*)) (BOUND-TO-OFFSET SELF))))"
    (CL:FUNCTION BOUND-TO) NULL)
   (DEFINE-FUNCTION-OBJECT "SAFE-BOUND-TO"
    "(DEFUN (SAFE-BOUND-TO OBJECT) ((SELF PATTERN-VARIABLE)))"
    (CL:FUNCTION SAFE-BOUND-TO) NULL)
   (DEFINE-FUNCTION-OBJECT "BOUND-TO-IN-FRAME"
    "(DEFUN (BOUND-TO-IN-FRAME OBJECT) ((SELF PATTERN-VARIABLE) (FRAME CONTROL-FRAME)))"
    (CL:FUNCTION BOUND-TO-IN-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "BOUND-TO-IN-RECORD"
    "(DEFUN (BOUND-TO-IN-RECORD OBJECT) ((SELF PATTERN-VARIABLE) (RECORD PATTERN-RECORD)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH (VARIABLE-BINDINGS RECORD) (BOUND-TO-OFFSET SELF))))"
    (CL:FUNCTION BOUND-TO-IN-RECORD) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTAINS-OPERATOR?"
    "(DEFUN (CONTAINS-OPERATOR? BOOLEAN) ((PROPOSITION PROPOSITION) (OPERATOR SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION CONTAINS-OPERATOR?) NULL)
   (DEFINE-FUNCTION-OBJECT "ARGUMENT-BOUND-TO"
    "(DEFUN (ARGUMENT-BOUND-TO OBJECT) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION ARGUMENT-BOUND-TO) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-UNIFY-ATTRIBUTES?"
    "(DEFUN (HELP-UNIFY-ATTRIBUTES? BOOLEAN) ((VALUE1 OBJECT) (VALUE2 OBJECT)))"
    (CL:FUNCTION HELP-UNIFY-ATTRIBUTES?) NULL)
   (DEFINE-FUNCTION-OBJECT "FAILS-UNIFICATION-TYPE-CHECK?"
    "(DEFUN (FAILS-UNIFICATION-TYPE-CHECK? BOOLEAN) ((V1 PATTERN-VARIABLE) (I2 OBJECT)))"
    (CL:FUNCTION FAILS-UNIFICATION-TYPE-CHECK?) NULL)
   (DEFINE-FUNCTION-OBJECT "FAILS-ANTECEDENT-TYPE-CHECK?"
    "(DEFUN (FAILS-ANTECEDENT-TYPE-CHECK? BOOLEAN) ((V1 PATTERN-VARIABLE) (I2 OBJECT)))"
    (CL:FUNCTION FAILS-ANTECEDENT-TYPE-CHECK?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-BIND-VARIABLE-TO-VALUE?"
    "(DEFUN (HELP-BIND-VARIABLE-TO-VALUE? BOOLEAN) ((VARIABLE PATTERN-VARIABLE) (VALUE OBJECT)))"
    (CL:FUNCTION HELP-BIND-VARIABLE-TO-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "BIND-VARIABLE-TO-VALUE?"
    "(DEFUN (BIND-VARIABLE-TO-VALUE? BOOLEAN) ((VARIABLE PATTERN-VARIABLE) (VALUE OBJECT) (AUTOCLEANUP? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION BIND-VARIABLE-TO-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "BIND-ARGUMENT-TO-VALUE?"
    "(DEFUN (BIND-ARGUMENT-TO-VALUE? BOOLEAN) ((ARGUMENT OBJECT) (VALUE OBJECT) (AUTOCLEANUP? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION BIND-ARGUMENT-TO-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "BIND-VECTOR-OF-ARGUMENTS-TO-VALUES?"
    "(DEFUN (BIND-VECTOR-OF-ARGUMENTS-TO-VALUES? BOOLEAN) ((ARGUMENTS ARGUMENTS-VECTOR) (VALUES CONS)))"
    (CL:FUNCTION BIND-VECTOR-OF-ARGUMENTS-TO-VALUES?) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-CONTROL-FRAME-STACK"
    "(DEFUN PRINT-CONTROL-FRAME-STACK ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION PRINT-CONTROL-FRAME-STACK) NULL)
   (DEFINE-FUNCTION-OBJECT "PCS" "(DEFUN PCS ())" (CL:FUNCTION PCS)
    NULL)
   (DEFINE-FUNCTION-OBJECT "VARIABLE-FROM-UNBINDING-OFFSET"
    "(DEFUN (VARIABLE-FROM-UNBINDING-OFFSET PATTERN-VARIABLE) ((DESCRIPTION DESCRIPTION) (UBOFFSET INTEGER)))"
    (CL:FUNCTION VARIABLE-FROM-UNBINDING-OFFSET) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-ONE-VARIABLE-BINDING"
    "(DEFUN PRINT-ONE-VARIABLE-BINDING ((VARIABLE PATTERN-VARIABLE)))"
    (CL:FUNCTION PRINT-ONE-VARIABLE-BINDING) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-VARIABLE-BINDINGS"
    "(DEFUN PRINT-VARIABLE-BINDINGS ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION PRINT-VARIABLE-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-RULE-IN-GOAL-TREE"
    "(DEFUN PRINT-RULE-IN-GOAL-TREE ((FRAME CONTROL-FRAME) (IMPLIESPROP PROPOSITION) (DEPTH INTEGER)))"
    (CL:FUNCTION PRINT-RULE-IN-GOAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-GOAL-IN-GOAL-TREE"
    "(DEFUN PRINT-GOAL-IN-GOAL-TREE ((FRAME CONTROL-FRAME) (DEPTH INTEGER)))"
    (CL:FUNCTION PRINT-GOAL-IN-GOAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-FRAME-DEPTH"
    "(DEFUN (COMPUTE-FRAME-DEPTH INTEGER) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION COMPUTE-FRAME-DEPTH) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-VERTICAL-BARS"
    "(DEFUN PRINT-VERTICAL-BARS ((DEPTH INTEGER)))"
    (CL:FUNCTION PRINT-VERTICAL-BARS) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWIND-TO-CHOICE-POINTS-BELOW-FRAME"
    "(DEFUN UNWIND-TO-CHOICE-POINTS-BELOW-FRAME ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION UNWIND-TO-CHOICE-POINTS-BELOW-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "TRACE-GOAL-TREE"
    "(DEFUN TRACE-GOAL-TREE ((FRAME CONTROL-FRAME) (DEPTH INTEGER) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION TRACE-GOAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "OLD-INTERPRET-AND-SCORES"
    "(DEFUN (OLD-INTERPRET-AND-SCORES KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION OLD-INTERPRET-AND-SCORES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-AND-PROOF KEYWORD) ((SELF CONTROL-FRAME) (FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-AND-PROOF) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERPRET-ITERATIVE-FORALL-SCORES"
    "(DEFUN (INTERPRET-ITERATIVE-FORALL-SCORES KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION INTERPRET-ITERATIVE-FORALL-SCORES) NULL)
   (DEFINE-FUNCTION-OBJECT "OLD-INTERPRET-OR-SCORES"
    "(DEFUN (OLD-INTERPRET-OR-SCORES KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION OLD-INTERPRET-OR-SCORES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-OR-PROOF KEYWORD) ((SELF CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-OR-PROOF) NULL)
   (DEFINE-FUNCTION-OBJECT "OLD-INTERPRET-FAIL-SCORE"
    "(DEFUN (OLD-INTERPRET-FAIL-SCORE KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION OLD-INTERPRET-FAIL-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-NOT-PROOF KEYWORD) ((SELF CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-NOT-PROOF) NULL)
   (DEFINE-FUNCTION-OBJECT "OLD-INTERPRET-GOAL-SCORES"
    "(DEFUN (OLD-INTERPRET-GOAL-SCORES KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION OLD-INTERPRET-GOAL-SCORES) NULL)))

(CL:DEFUN HELP-STARTUP-QUERY9 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "ATTACH-SUPPORT"
    "(DEFUN ATTACH-SUPPORT ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION ATTACH-SUPPORT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-STRATEGIES-PROOFS KEYWORD) ((SELF CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-STRATEGIES-PROOFS) NULL)
   (DEFINE-FUNCTION-OBJECT "OPERATIVE-PATTERN-RECORD"
    "(DEFUN (OPERATIVE-PATTERN-RECORD PATTERN-RECORD) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION OPERATIVE-PATTERN-RECORD) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-DOWN-FRAME"
    "(DEFUN (CREATE-DOWN-FRAME CONTROL-FRAME) ((UPFRAME CONTROL-FRAME) (DOWNPROPOSITION PROPOSITION)))"
    (CL:FUNCTION CREATE-DOWN-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-FRAME-TRUTH-VALUE"
    "(DEFUN (SET-FRAME-TRUTH-VALUE TRUTH-VALUE) ((FRAME CONTROL-FRAME) (TRUTHVALUE TRUTH-VALUE)))"
    (CL:FUNCTION SET-FRAME-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "PROPAGATE-FRAME-TRUTH-VALUE"
    "(DEFUN (PROPAGATE-FRAME-TRUTH-VALUE TRUTH-VALUE) ((SOURCE CONTROL-FRAME) (TARGET CONTROL-FRAME)))"
    (CL:FUNCTION PROPAGATE-FRAME-TRUTH-VALUE) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT CONTROL-FRAME DEBUG-FRAME-ID-INTERNAL :TYPE INTEGER :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "DEBUG-FRAME-ID"
    "(DEFUN (DEBUG-FRAME-ID INTEGER) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION DEBUG-FRAME-ID) NULL)
   (DEFINE-FUNCTION-OBJECT "COPY-FRAME-STATE"
    "(DEFUN COPY-FRAME-STATE ((FROMFRAME CONTROL-FRAME) (TOFRAME CONTROL-FRAME)))"
    (CL:FUNCTION COPY-FRAME-STATE) NULL)
   (DEFINE-FUNCTION-OBJECT "PARALLELIZE-CONTROL-FRAME"
    "(DEFUN (PARALLELIZE-CONTROL-FRAME PARALLEL-CONTROL-FRAME) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION PARALLELIZE-CONTROL-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "ENTER-PARALLEL-THREAD"
    "(DEFUN ENTER-PARALLEL-THREAD ((PFRAME PARALLEL-CONTROL-FRAME) (CHILDTHREAD PARALLEL-THREAD)))"
    (CL:FUNCTION ENTER-PARALLEL-THREAD) NULL)
   (DEFINE-FUNCTION-OBJECT "EXIT-PARALLEL-THREAD"
    "(DEFUN EXIT-PARALLEL-THREAD ((PFRAME PARALLEL-CONTROL-FRAME)))"
    (CL:FUNCTION EXIT-PARALLEL-THREAD) NULL)
   (DEFINE-FUNCTION-OBJECT "ENTER-HYPOTHETICAL-WORLD"
    "(DEFUN (ENTER-HYPOTHETICAL-WORLD WORLD) ((PFRAME PARALLEL-CONTROL-FRAME)))"
    (CL:FUNCTION ENTER-HYPOTHETICAL-WORLD) NULL)
   (DEFINE-FUNCTION-OBJECT "PARTIAL-MATCH-MODE?"
    "(DEFUN (PARTIAL-MATCH-MODE? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (AND (DEFINED? *QUERYITERATOR*) (DEFINED? (PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)))))"
    (CL:FUNCTION PARTIAL-MATCH-MODE?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXECUTE-BACKWARD-CHAINING-PROOF?"
    "(DEFUN (EXECUTE-BACKWARD-CHAINING-PROOF? BOOLEAN) ((QUERY QUERY-ITERATOR)))"
    (CL:FUNCTION EXECUTE-BACKWARD-CHAINING-PROOF?) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-NEXT-MOVE"
    "(DEFUN (EVALUATE-NEXT-MOVE KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD) (CLOCKTICKS INTEGER)))"
    (CL:FUNCTION EVALUATE-NEXT-MOVE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CLUSTERED-CONJUNCTION? BOOLEAN) ((SELF PROPOSITION)))"
    (CL:FUNCTION CLUSTERED-CONJUNCTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTINUE-AND-PROOF"
    "(DEFUN (CONTINUE-AND-PROOF KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-AND-PROOF) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTINUE-OR-PROOF"
    "(DEFUN (CONTINUE-OR-PROOF KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-OR-PROOF) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTINUE-NOT-PROOF"
    "(DEFUN (CONTINUE-NOT-PROOF KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-NOT-PROOF) NULL)
   (DEFINE-FUNCTION-OBJECT "OVERLAY-WITH-FAIL-FRAME"
    "(DEFUN (OVERLAY-WITH-FAIL-FRAME KEYWORD) ((FRAME CONTROL-FRAME) (PROPOSITION PROPOSITION)))"
    (CL:FUNCTION OVERLAY-WITH-FAIL-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "OVERLAY-WITH-STRATEGY-FRAME"
    "(DEFUN (OVERLAY-WITH-STRATEGY-FRAME KEYWORD) ((FRAME CONTROL-FRAME) (STRATEGY KEYWORD)))"
    (CL:FUNCTION OVERLAY-WITH-STRATEGY-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "CHECK-FOR-DUPLICATE-GOAL?"
    "(DEFUN (CHECK-FOR-DUPLICATE-GOAL? BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION CHECK-FOR-DUPLICATE-GOAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIATE-ATOMIC-GOAL-PROOFS"
    "(DEFUN (INITIATE-ATOMIC-GOAL-PROOFS KEYWORD) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION INITIATE-ATOMIC-GOAL-PROOFS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-ARGUMENTS-BOUND?"
    "(DEFUN (ALL-ARGUMENTS-BOUND? BOOLEAN) ((GOAL PROPOSITION)))"
    (CL:FUNCTION ALL-ARGUMENTS-BOUND?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-KEY-ARGUMENTS-BOUND?"
    "(DEFUN (ALL-KEY-ARGUMENTS-BOUND? BOOLEAN) ((GOAL PROPOSITION)))"
    (CL:FUNCTION ALL-KEY-ARGUMENTS-BOUND?) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-PATTERN-RECORD"
    "(DEFUN (CREATE-PATTERN-RECORD PATTERN-RECORD) ((FRAME CONTROL-FRAME) (DESCRIPTION DESCRIPTION) (EXTERNALARGUMENTS ARGUMENTS-VECTOR)))"
    (CL:FUNCTION CREATE-PATTERN-RECORD) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMINATE-PATTERN-RECORD?"
    "(DEFUN (TERMINATE-PATTERN-RECORD? BOOLEAN) ((SELF PATTERN-RECORD)))"
    (CL:FUNCTION TERMINATE-PATTERN-RECORD?) NULL)
   (DEFINE-FUNCTION-OBJECT "COPY-PATTERN-ARGUMENTS"
    "(DEFUN (COPY-PATTERN-ARGUMENTS ARGUMENTS-VECTOR) ((ARGUMENTS OBJECT-VECTOR) (DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION COPY-PATTERN-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-EXTERNAL-BINDINGS"
    "(DEFUN (COMPUTE-EXTERNAL-BINDINGS CONS) ((EXTERNALARGUMENTS ARGUMENTS-VECTOR)))"
    (CL:FUNCTION COMPUTE-EXTERNAL-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "INSTANTIATE-EXTERNAL-BINDINGS"
    "(DEFUN (INSTANTIATE-EXTERNAL-BINDINGS OBJECT) ((SELF OBJECT)))"
    (CL:FUNCTION INSTANTIATE-EXTERNAL-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "INSTANTIATE-EXTERNAL-VARIABLES"
    "(DEFUN (INSTANTIATE-EXTERNAL-VARIABLES DESCRIPTION) ((SELF DESCRIPTION) (BINDINGS ENTITY-MAPPING)))"
    (CL:FUNCTION INSTANTIATE-EXTERNAL-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "CHECK-FOR-SINGLE-VALUED-GOAL?"
    "(DEFUN (CHECK-FOR-SINGLE-VALUED-GOAL? BOOLEAN) ((PATTERN DESCRIPTION) (IOBINDINGS CONS)))"
    (CL:FUNCTION CHECK-FOR-SINGLE-VALUED-GOAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "OVERLAY-WITH-PATTERN-FRAME?"
    "(DEFUN (OVERLAY-WITH-PATTERN-FRAME? BOOLEAN) ((FRAME CONTROL-FRAME) (DESCRIPTION DESCRIPTION) (IOARGUMENTS ARGUMENTS-VECTOR)))"
    (CL:FUNCTION OVERLAY-WITH-PATTERN-FRAME?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSFER-PATTERN-QUERY-BINDINGS?"
    "(DEFUN (TRANSFER-PATTERN-QUERY-BINDINGS? BOOLEAN) ((FRAME CONTROL-FRAME) (FUTUREBINDINGS? BOOLEAN)))"
    (CL:FUNCTION TRANSFER-PATTERN-QUERY-BINDINGS?) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-PATTERN-QUERY-BINDINGS"
    "(DEFUN COLLECT-PATTERN-QUERY-BINDINGS ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION COLLECT-PATTERN-QUERY-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-RULE-OF-ANTECEDENT-FRAME"
    "(DEFUN (GET-RULE-OF-ANTECEDENT-FRAME PROPOSITION) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION GET-RULE-OF-ANTECEDENT-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTINUE-PATTERN-PROOF"
    "(DEFUN (CONTINUE-PATTERN-PROOF KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PATTERN-PROOF) NULL)
   (DEFINE-FUNCTION-OBJECT "DISJOINT-CLASSES?"
    "(DEFUN (DISJOINT-CLASSES? BOOLEAN) ((DESC1 NAMED-DESCRIPTION) (DESC2 NAMED-DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION DISJOINT-CLASSES?) NULL)
   (DEFINE-FUNCTION-OBJECT "DISJOINT-TERMS?"
    "(DEFUN (DISJOINT-TERMS? BOOLEAN) ((D1 DESCRIPTION) (D2 DESCRIPTION)) :DOCUMENTATION \"Return TRUE if 'd1' and 'd2' belong to disjoint partitions.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DISJOINT-TERMS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPENSIVE-DISJOINT-TERMS?"
    "(DEFUN (EXPENSIVE-DISJOINT-TERMS? BOOLEAN) ((D1 DESCRIPTION) (D2 DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION EXPENSIVE-DISJOINT-TERMS?) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECTIONOF-PROPOSITION?"
    "(DEFUN (COLLECTIONOF-PROPOSITION? BOOLEAN) ((DEFININGPROPOSITION PROPOSITION)))"
    (CL:FUNCTION COLLECTIONOF-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "MEMBER-OF-COLLECTION?"
    "(DEFUN (MEMBER-OF-COLLECTION? BOOLEAN) ((MEMBER OBJECT) (COLLECTION OBJECT)))"
    (CL:FUNCTION MEMBER-OF-COLLECTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERTED-COLLECTION-MEMBERS"
    "(DEFUN (ASSERTED-COLLECTION-MEMBERS LIST) ((SELF OBJECT) (DIRECT? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION ASSERTED-COLLECTION-MEMBERS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-TRUE-EXTENSION-MEMBERS"
    "(DEFUN (ALL-TRUE-EXTENSION-MEMBERS DESCRIPTION-EXTENSION-ITERATOR) ((SELF NAMED-DESCRIPTION) (SPECIALIZE? BOOLEAN)))"
    (CL:FUNCTION ALL-TRUE-EXTENSION-MEMBERS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-MATCHING-EXTENSION-MEMBERS"
    "(DEFUN (ALL-MATCHING-EXTENSION-MEMBERS (ITERATOR OF PROPOSITION)) ((SELF PROPOSITION) (SPECIALIZE? BOOLEAN)))"
    (CL:FUNCTION ALL-MATCHING-EXTENSION-MEMBERS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF DESCRIPTION-EXTENSION-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-FIND-DUPLICATED-GOAL"
    "(DEFUN (HELP-FIND-DUPLICATED-GOAL CONTROL-FRAME CONTROL-FRAME INTEGER) ((GOALFRAME CONTROL-FRAME)))"
    (CL:FUNCTION HELP-FIND-DUPLICATED-GOAL) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-DUPLICATED-GOAL"
    "(DEFUN (FIND-DUPLICATED-GOAL CONTROL-FRAME CONTROL-FRAME INTEGER) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION FIND-DUPLICATED-GOAL) NULL)
   (DEFINE-FUNCTION-OBJECT "HANDLE-DEPTH-VIOLATION"
    "(DEFUN (HANDLE-DEPTH-VIOLATION CONTROL-FRAME INTEGER) ((FRAME CONTROL-FRAME) (DEPTH INTEGER)))"
    (CL:FUNCTION HANDLE-DEPTH-VIOLATION) NULL)
   (DEFINE-FUNCTION-OBJECT "HANDLE-TIMEOUT"
    "(DEFUN (HANDLE-TIMEOUT CONTROL-FRAME INTEGER) ((FRAME CONTROL-FRAME) (DEPTH INTEGER)))"
    (CL:FUNCTION HANDLE-TIMEOUT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF QUERY-SOLUTION-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Lookup the solution identified by `key' in `self' and
return its value, or NULL if no such solution exists.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF QUERY-SOLUTION-TABLE) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Insert `value' identified by `key' into `self'.  If a solution
with that key already exists, destructively modify it with the slot values of
`value'.  This is necessary to preserve the order of solutions in `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION INSERT-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DELETED? BOOLEAN) ((SELF QUERY-SOLUTION)))"
    (CL:FUNCTION DELETED?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DELETED?-SETTER BOOLEAN) ((SELF QUERY-SOLUTION) (VALUE BOOLEAN)))"
    (CL:FUNCTION DELETED?-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REMOVE-AT ((SELF QUERY-SOLUTION-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Remove the solution identified by `key' from `self'.
To preserve the solution ordering chain, the solution is marked as deleted
and will be completely removed upon the next iteration through `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REMOVE-AT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ((SELF QUERY-SOLUTION-TABLE)) :DOCUMENTATION \"Remove and return the first solution of `self' or NULL
if the table is empty.\" :PUBLIC? TRUE)" (CL:FUNCTION POP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF QUERY-SOLUTION-TABLE)) :DOCUMENTATION \"Return the number of entries in `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF QUERY-SOLUTION-TABLE)) :DOCUMENTATION \"Return TRUE if `self' has zero entries.\" :PUBLIC? TRUE)"
    (CL:FUNCTION EMPTY?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF QUERY-SOLUTION-TABLE)) :DOCUMENTATION \"Return TRUE if `self' has at least 1 entry.\" :PUBLIC? TRUE)"
    (CL:FUNCTION NON-EMPTY?) NULL)))

(CL:DEFUN HELP-STARTUP-QUERY10 ()
  (CL:PROGN
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ((SELF QUERY-SOLUTION-TABLE) (POSITION INTEGER)) :DOCUMENTATION \"Return the nth solution in `self', or NULL if it is empty.\" :PUBLIC? TRUE)"
    (CL:FUNCTION NTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR ((SELF QUERY-SOLUTION-TABLE)))"
    (CL:FUNCTION CLEAR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONSIFY CONS) ((SELF QUERY-SOLUTION-TABLE)) :DOCUMENTATION \"Collect all solutions of `self' into a cons list and return the result.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CONSIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SORT (LIKE SELF)) ((SELF QUERY-SOLUTION-TABLE) (PREDICATE FUNCTION-CODE)) :DOCUMENTATION \"Perform a stable, destructive sort of `self' according to
`predicate', and return the result.  If `predicate' has a '<' semantics, the
result will be in ascending order.\" :PUBLIC? TRUE)" (CL:FUNCTION SORT)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ALLOCATE-ITERATOR DICTIONARY-ITERATOR) ((SELF QUERY-SOLUTION-TABLE)))"
    (CL:FUNCTION ALLOCATE-ITERATOR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF QUERY-SOLUTION-TABLE-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-CONTROL-FRAME"
    "(DEFUN PRINT-CONTROL-FRAME ((SELF CONTROL-FRAME) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-CONTROL-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-GOAL-STACK"
    "(DEFUN PRINT-GOAL-STACK ((FRAME CONTROL-FRAME) (VERBOSE? BOOLEAN)) :DOCUMENTATION \"Print stack of goals.  Assumes that query has been interrupted
with a full stack of control frames.\")" (CL:FUNCTION PRINT-GOAL-STACK)
    NULL)
   (DEFINE-FUNCTION-OBJECT "PGS" "(DEFUN PGS ())" (CL:FUNCTION PGS)
    NULL)
   (DEFINE-FUNCTION-OBJECT "VPGS" "(DEFUN VPGS ())" (CL:FUNCTION VPGS)
    NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-QUERY-ITERATOR"
    "(DEFUN PRINT-QUERY-ITERATOR ((SELF QUERY-ITERATOR) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-QUERY-ITERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-QUERY-ITERATOR-ORNATELY"
    "(DEFUN PRINT-QUERY-ITERATOR-ORNATELY ((SELF QUERY-ITERATOR) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-QUERY-ITERATOR-ORNATELY) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-QUERY-ITERATOR-SOLUTION-ORNATELY"
    "(DEFUN PRINT-QUERY-ITERATOR-SOLUTION-ORNATELY ((SELF QUERY-ITERATOR) (SOLUTION QUERY-SOLUTION) (SOLUTIONNUMBER INTEGER) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-QUERY-ITERATOR-SOLUTION-ORNATELY) NULL)
   (DEFINE-FUNCTION-OBJECT "TRACE-SOLUTION"
    "(DEFUN TRACE-SOLUTION ((SELF QUERY-ITERATOR) (SOLUTION QUERY-SOLUTION) (SOLUTIONNUMBER INTEGER)))"
    (CL:FUNCTION TRACE-SOLUTION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-QUERY-ITERATOR-READABLY"
    "(DEFUN PRINT-QUERY-ITERATOR-READABLY ((SELF QUERY-ITERATOR) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-QUERY-ITERATOR-READABLY) NULL)
   (DEFINE-FUNCTION-OBJECT "ALLOCATE-QUERY-ITERATOR"
    "(DEFUN (ALLOCATE-QUERY-ITERATOR QUERY-ITERATOR) ())"
    (CL:FUNCTION ALLOCATE-QUERY-ITERATOR) NULL)
   (DEFINE-METHOD-OBJECT "(DEFMETHOD FREE ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION FREE) NULL)
   (DEFINE-FUNCTION-OBJECT "FREE-QUERY-ITERATOR"
    "(DEFUN FREE-QUERY-ITERATOR ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION FREE-QUERY-ITERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "ALLOCATE-COLLECTION-VARIABLES"
    "(DEFUN (ALLOCATE-COLLECTION-VARIABLES VARIABLES-VECTOR) ((FRAME CONTROL-FRAME) (DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION ALLOCATE-COLLECTION-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-QUERY-ITERATOR"
    "(DEFUN (CREATE-QUERY-ITERATOR QUERY-ITERATOR) ((DESCRIPTION DESCRIPTION) (OUTSIDEBINDINGS VECTOR)))"
    (CL:FUNCTION CREATE-QUERY-ITERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-QUERY-ITERATOR"
    "(DEFUN (INITIALIZE-QUERY-ITERATOR QUERY-ITERATOR) ((QUERYITERATOR QUERY-ITERATOR) (DESCRIPTION DESCRIPTION) (OUTSIDEBINDINGS VECTOR)))"
    (CL:FUNCTION INITIALIZE-QUERY-ITERATOR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (QUERY-PROPOSITION PROPOSITION) ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION QUERY-PROPOSITION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (QUERY-DESCRIPTION DESCRIPTION) ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION QUERY-DESCRIPTION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (QUERY-IS-TRUE-FALSE? BOOLEAN) ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION QUERY-IS-TRUE-FALSE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (QUERY-IS-PARTIAL? BOOLEAN) ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION QUERY-IS-PARTIAL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (QUERY-SUCCEEDED? BOOLEAN) ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION QUERY-SUCCEEDED?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRY-TO-DEFEAT-LAST-ANSWER?"
    "(DEFUN (TRY-TO-DEFEAT-LAST-ANSWER? BOOLEAN) ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION TRY-TO-DEFEAT-LAST-ANSWER?) NULL)
   (DEFINE-METHOD-OBJECT "(DEFMETHOD RESET ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION RESET) NULL)
   (DEFINE-FUNCTION-OBJECT "STANDARDIZE-QUERY-TREE"
    "(DEFUN (STANDARDIZE-QUERY-TREE CONS) ((IOVARIABLES OBJECT) (QUERYBODY OBJECT) (EXTERNALVARIABLES CONS)))"
    (CL:FUNCTION STANDARDIZE-QUERY-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-QUERY"
    "(DEFUN (MAKE-QUERY QUERY-ITERATOR) ((IOVARIABLES OBJECT) (QUERYTREE OBJECT) (EXTERNALBINDINGS CONS) (OPTIONS OBJECT)))"
    (CL:FUNCTION MAKE-QUERY) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-QUERY-AND-OPTIONS"
    "(DEFUN (PARSE-QUERY-AND-OPTIONS OBJECT OBJECT PROPERTY-LIST) ((|QUERY&OPTIONS| CONS)))"
    (CL:FUNCTION PARSE-QUERY-AND-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "PROCESS-QUERY-OPTIONS"
    "(DEFUN PROCESS-QUERY-OPTIONS ((QUERY QUERY-ITERATOR) (OPTIONS OBJECT)))"
    (CL:FUNCTION PROCESS-QUERY-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-QUERY-OPTION"
    "(DEFUN (LOOKUP-QUERY-OPTION OBJECT) ((QUERYOROPTIONS OBJECT) (KEY KEYWORD)))"
    (CL:FUNCTION LOOKUP-QUERY-OPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-QUERY-OPTION?"
    "(DEFUN (TEST-QUERY-OPTION? BOOLEAN) ((QUERYOROPTIONS OBJECT) (KEY KEYWORD)))"
    (CL:FUNCTION TEST-QUERY-OPTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-DEFERRED-QUERY-OPTION"
    "(DEFUN (LOOKUP-DEFERRED-QUERY-OPTION OBJECT) ((QUERYOROPTIONS OBJECT) (KEY KEYWORD) (COERCETOTYPE TYPE)))"
    (CL:FUNCTION LOOKUP-DEFERRED-QUERY-OPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-HOW-MANY-SOLUTIONS"
    "(DEFUN (LOOKUP-HOW-MANY-SOLUTIONS INTEGER) ((QUERYOROPTIONS OBJECT)))"
    (CL:FUNCTION LOOKUP-HOW-MANY-SOLUTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-YES-OR-NO-QUERY?"
    "(DEFUN (RUN-YES-OR-NO-QUERY? THREE-VALUED-BOOLEAN) ((QUERY QUERY-ITERATOR)))"
    (CL:FUNCTION RUN-YES-OR-NO-QUERY?) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-TREE"
    "(DEFUN (COERCE-TO-TREE OBJECT) ((SELF OBJECT)))"
    (CL:FUNCTION COERCE-TO-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-STRING"
    "(DEFUN (COERCE-TO-STRING STRING) ((SELF OBJECT)))"
    (CL:FUNCTION COERCE-TO-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-ASK-QUERY"
    "(DEFUN (CREATE-ASK-QUERY QUERY-ITERATOR) ((QUERY OBJECT)))"
    (CL:FUNCTION CREATE-ASK-QUERY) NULL)
   (DEFINE-FUNCTION-OBJECT "CALL-ASK"
    "(DEFUN (CALL-ASK TRUTH-VALUE) ((QUERY OBJECT)) :DOCUMENTATION \"Callable version of `ask' (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to `ask'.  Raises LOGIC-EXCEPTIONs in case of illegal
queries and logical expressions.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CALL-ASK) NULL)
   (DEFINE-FUNCTION-OBJECT "ASK"
    "(DEFUN (ASK TRUTH-VALUE) (|&REST| (|PROPOSITION&OPTIONS| PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Perform inference to determine whether the proposition specified in
`proposition&options' is true.  Return the truth-value found.  `ask'
will spend most of its effort to determine whether the proposition
is true and only a little effort via shallow inference strategies to
determine whether it is false.  To find out whether a proposition is
false with full inference effort `ask' its negation.

KIF example: `(ask (happy Fred))' will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic
constant `Fred' and the relation `happy' must already be defined (see
`assert').  Use `(set/unset-feature goal-trace)' to en/disable goal
tracing of the inference engine.

The `ask' command supports the following options: `:TIMEOUT' is an
integer or floating point time limit, specified in seconds.  For
example, the command `(ask (nervous Fred) :timeout 2.0)' will cease
inference after two seconds if a proof has not been found by then.
If the `:DONT-OPTIMIZE?' is given as TRUE, it tells PowerLoom to
not optimize the order of clauses in the query before evaluating it.
This is useful for cases where a specific evaluation order of the
clauses is required (or the optimizer doesn't do the right thing).
If `:THREE-VALUED?' is given as TRUE, PowerLoom will try to prove
the negation of the query with full effort in case the given query
returned UNKNOWN.  By default, PowerLoom uses full effort to prove
the query as stated and only a little opportunistic effort to see
whether it is actually false.\")" (CL:FUNCTION %ASK)
    (CL:FUNCTION ASK-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "RETRIEVE-BINDINGS"
    "(DEFUN (RETRIEVE-BINDINGS QUERY-ITERATOR) ((QUERY OBJECT) (NOFBINDINGS INTEGER)))"
    (CL:FUNCTION RETRIEVE-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-RETRIEVE-QUERY"
    "(DEFUN (CREATE-RETRIEVE-QUERY QUERY-ITERATOR) ((QUERY OBJECT)))"
    (CL:FUNCTION CREATE-RETRIEVE-QUERY) NULL)
   (DEFINE-FUNCTION-OBJECT "CALL-RETRIEVE"
    "(DEFUN (CALL-RETRIEVE QUERY-ITERATOR) ((QUERY OBJECT)) :DOCUMENTATION \"Callable version of `retrieve' (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to `retrieve'.  Raises LOGIC-EXCEPTIONs in case of illegal
queries and logical expressions.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CALL-RETRIEVE) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRIEVE"
    "(DEFUN (RETRIEVE QUERY-ITERATOR) (|&REST| (QUERY PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Retrieve elements of a relation (tuples) that satisfy a proposition.
The accepted syntax is:
	 
  (retrieve [<integer> | all]
            [[{<vardecl> | (<vardecl>+)}]
            <proposition>])
	
The variables and proposition are similar to an `exists' sentence or
`kappa' term without the explicit quantifier.  If variables are declared,
they must match the free variables referenced by <proposition>.  Otherwise,
the free variables referenced in <proposition> will be used as the query
variables.  If <proposition> is omitted, the most recently asked query
will be continued.

A solution is a set of bindings for the listed variables for which
<proposition> is true.  The optional first argument controls how many
solutions should be generated before control is returned.  The keyword
`all' indicates that all solutions should be generated.  By default,
`retrieve' returns after it has found one new solution or if it cannot
find any more solutions.

`retrieve' returns an iterator which saves all the necessary state of
a query and stores all generated solutions.  When used interactively,
the returned iterator will print out with the set of solutions collected
so far.  Calling `retrieve' without any arguments (or only with the first
argument) will generate one (or more) solutions to the most recently
asked query.

KIF examples:
	 
  (retrieve (happy ?x))
	
will try to find one happy entity and store it in the returned 
query iterator.
	 
  (retrieve 10 (happy ?x))
	
will try to find 10 happy entities.
	 
  (retrieve 10)
	
will try to find the next 10 happy entities..
	 
  (retrieve all (happy ?x))
	
will find all happy entities.
	 
  (retrieve all (?x Person) (happy ?x))
	
will to find all happy people.  Here we used the optional retrieve variable
syntax to restrict the acceptable solutions.  The above is equivalent to
the following query:
	 
  (retrieve all (and (Person ?x) (happy ?x)))
	
Similarly,
	 
  (retrieve all (?x Person))
  (retrieve all (Person ?x))
  (retrieve all ?x (Person ?x))
	
will find all people.  Note that in the first case we only specify a query
variable and its type but omit the logic sentence which defaults to TRUE.  This
somewhat impoverished looking query can be paraphrased as \\\"retrieve all ?x of
type Person such that TRUE.\\\"
	 
  (retrieve ?x (or (happy ?x) (parent-of Fred ?x)))
	
will try to find a person that is happy or has Fred as a parent.
	 
  (retrieve (?y ?x) (parent-of ?x ?y))
	
will try to find the one pair of parent/child and return it in the order
of child/parent.
	 
  (retrieve all (?x Person)
            (exists (?y Person) (parent-of ?x ?y)))
	
will generate the set of all parents.  Note, that for these queries to run,
the class `Person', the relations `happy' and `parent-of', and the logic
constant `Fred' must already be defined (see `assert').

Use `(set/unset-feature trace-subgoals)' to en/disable goal tracing of the
inference engine.\")" (CL:FUNCTION %RETRIEVE)
    (CL:FUNCTION RETRIEVE-EVALUATOR-WRAPPER))
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONSIFY-CURRENT-SOLUTIONS CONS) ((SELF QUERY-ITERATOR)) :DOCUMENTATION \"Collect the current solutions of `self' into a cons list
of result tuples.  If `:SINGLETONS? TRUE', collect a list of atoms rather than a
list of lists for tuples of arity=1.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CONSIFY-CURRENT-SOLUTIONS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONSIFY CONS) ((SELF QUERY-ITERATOR)) :DOCUMENTATION \"Generate all solutions for the query self, and collect them into a cons list
of result tuples.  If `:SINGLETONS? TRUE', collect a list of atoms rather than a
list of lists for tuples of arity=1.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CONSIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "CONSIFY-QUERY"
    "(DEFUN (CONSIFY-QUERY CONS) ((SELF QUERY-ITERATOR)) :GLOBALLY-INLINE? TRUE (RETURN (CONSIFY SELF)))"
    (CL:FUNCTION CONSIFY-QUERY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LISTIFY LIST) ((SELF QUERY-ITERATOR)) :DOCUMENTATION \"Just like `QUERY-ITERATOR.consify' but return a LIST instead.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LISTIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "FLUSH-INLINE-QUERY-CACHES"
    "(DEFUN FLUSH-INLINE-QUERY-CACHES ())"
    (CL:FUNCTION FLUSH-INLINE-QUERY-CACHES) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-CACHED-QUERY"
    "(DEFUN (MAKE-CACHED-QUERY QUERY-ITERATOR) ((VARIABLES CONS) (QUERYBODY CONS) (INPUTBINDINGS CONS) (OPTIONS OBJECT) (CACHEID SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION MAKE-CACHED-QUERY) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-CACHED-RETRIEVE"
    "(DEFUN (APPLY-CACHED-RETRIEVE CONS CONS) ((VARIABLES CONS) (QUERYBODY CONS) (INPUTBINDINGS CONS) (OPTIONS OBJECT) (CACHEID SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION APPLY-CACHED-RETRIEVE) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-CACHED-ASK"
    "(DEFUN (APPLY-CACHED-ASK BOOLEAN TRUTH-VALUE) ((INPUTVARIABLES CONS) (QUERYBODY CONS) (INPUTBINDINGS CONS) (OPTIONS OBJECT) (CACHEID SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION APPLY-CACHED-ASK) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-PROTOTYPE"
    "(DEFUN (GET-PROTOTYPE LOGIC-OBJECT) ((DESCRIPTION DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION GET-PROTOTYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION?"
    "(DEFUN (UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION? TRUTH-VALUE) ((SUB DESCRIPTION) (SUPER DESCRIPTION)))"
    (CL:FUNCTION UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "DESCRIPTION-SPECIALIZES-DESCRIPTION?"
    "(DEFUN (DESCRIPTION-SPECIALIZES-DESCRIPTION? TRUTH-VALUE) ((SUB DESCRIPTION) (SUPER DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION DESCRIPTION-SPECIALIZES-DESCRIPTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "VECTOR-SATISFIES-DESCRIPTION?"
    "(DEFUN (VECTOR-SATISFIES-DESCRIPTION? TRUTH-VALUE) ((VECTOR VECTOR) (DESCRIPTION DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION VECTOR-SATISFIES-DESCRIPTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "INSTANCE-SATISFIES-DESCRIPTION?"
    "(DEFUN (INSTANCE-SATISFIES-DESCRIPTION? TRUTH-VALUE) ((INSTANCE OBJECT) (DESCRIPTION DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION INSTANCE-SATISFIES-DESCRIPTION?) NULL)))

(CL:DEFUN HELP-STARTUP-QUERY11 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-DESCRIPTION"
    "(DEFUN (COERCE-TO-DESCRIPTION DESCRIPTION) ((SELF OBJECT) (ORIGINAL OBJECT)))"
    (CL:FUNCTION COERCE-TO-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "SPECIALIZES?"
    "(DEFUN (SPECIALIZES? TRUTH-VALUE) ((SUBOBJECT OBJECT) (SUPEROBJECT OBJECT)) :DOCUMENTATION \"Try to prove if the description associated with `subObject'
specializes the description for `superObject' and return the result truth
value of the query.\" :PUBLIC? TRUE)" (CL:FUNCTION SPECIALIZES?) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-INSTANCE"
    "(DEFUN (COERCE-TO-INSTANCE LOGIC-OBJECT) ((SELF OBJECT) (ORIGINAL OBJECT)) :DOCUMENTATION \"Return the logic instance referred to by 'self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-TO-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-INSTANCE-OR-LITERAL"
    "(DEFUN (COERCE-TO-INSTANCE-OR-LITERAL OBJECT) ((SELF OBJECT) (ORIGINAL OBJECT)) :DOCUMENTATION \"Return the logic instance referred to by `self', or `self' if it is a
literal (e.g., string or number) that can't be coerced.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-TO-INSTANCE-OR-LITERAL) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-VECTOR"
    "(DEFUN (COERCE-TO-VECTOR VECTOR) ((SELF OBJECT)) :DOCUMENTATION \"Return a vector containing the elements in `self'.
Coerce each element of `self' to be a logic object or literal.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-TO-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "SATISFIES?"
    "(DEFUN (SATISFIES? TRUTH-VALUE) ((INSTANCEORTUPLE OBJECT) (RELATIONREF OBJECT)) :DOCUMENTATION \"Try to prove whether `instanceOrTuple' satisfies the
definition of the relation `relationRef' and return the result truth value
of the query.  `instanceOrTuple' can be a single object, the name or surrogate
of an object, or a collection (a list or vector) of objects.  `relationRef'
can be a relation, description, surrogate or relation name.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SATISFIES?) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-KAPPA?"
    "(DEFUN (APPLY-KAPPA? BOOLEAN) ((DESCRIPTION DESCRIPTION) (VECTOR VECTOR)) :PUBLIC? TRUE :DOCUMENTATION \"Apply (inherit) the description 'description'
to members of the vector 'vector'.  Return TRUE if no clash was detected.
Constraint propagation happens only if it is enabled prior to calling
'apply-kappa?'.\")" (CL:FUNCTION APPLY-KAPPA?) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-PROPOSITIONS-FROM-QUERY"
    "(DEFUN (UPDATE-PROPOSITIONS-FROM-QUERY (CONS OF PROPOSITION)) ((QUERY QUERY-ITERATOR) (DESCRIPTION DESCRIPTION) (MODULE MODULE) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION UPDATE-PROPOSITIONS-FROM-QUERY) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-QUERY-ITERATOR-FROM-COMMAND"
    "(DEFUN (GET-QUERY-ITERATOR-FROM-COMMAND QUERY-ITERATOR) ((QUERY CONS)))"
    (CL:FUNCTION GET-QUERY-ITERATOR-FROM-COMMAND) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-FROM-QUERY"
    "(DEFUN (ASSERT-FROM-QUERY (CONS OF PROPOSITION)) ((QUERY CONS) |&REST| (OPTIONS OBJECT)) :DOCUMENTATION \"Evaluate `query', instantiate the query proposition for each generated
solution and assert the resulting propositions.  The accepted syntax
is as follows:
	 
 (assert-from-query <query-command>
                    [:relation <relation-name>]
                    [:pattern <description-term>]
                    [:module <module-name>])
	
<query-command> has to be a strict or partial retrieval command. If a
:relation option is supplied, <relation-name> is used as the relation
of the resulting propositions.  In this case the bindings of each
solution will become arguments to the specified relation in the order
of `query's output variables (the arities have to match).  The
:pattern option is a generalization of this mechanism that specifies
an arbitrary proposition pattern to be instantiated by the query's
solution.  In this case <description-term> has to be a SETOFALL or
KAPPA expression whose IO-variables will be bound in sequence to the
bindings of a query solution to generate the resulting proposition.
Finally, if a :module option is specified, the assertions will be
generated in that module.  Note that for this to work the relations
referenced in the query proposition or pattern have to be visible in
the module.  Also, instances will not be copied to the target module,
therefore, the resulting propositions might reference external
out-of-module objects in case they are not visible there.
Here are some examples:
	 
 (assert-from-query (retrieve all (foo ?x ?y)))
 (assert-from-query (retrieve all (?y ?x)
                             (exists ?z
                               (and (foo ?x ?z)
                                    (foo ?z ?y))))
                    :relation bar :module other)
 (assert-from-query
   (retrieve all (and (relation ?x) (symmetric ?x)))
   :pattern (kappa (?pred)
              (forall (?x ?y)
                (=> (holds ?pred ?x ?y)
                    (holds ?pred ?y ?x))))))
	
\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %ASSERT-FROM-QUERY)
    (CL:FUNCTION ASSERT-FROM-QUERY-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "RETRACT-FROM-QUERY"
    "(DEFUN (RETRACT-FROM-QUERY (CONS OF PROPOSITION)) ((QUERY CONS) |&REST| (OPTIONS OBJECT)) :DOCUMENTATION \"Evaluate `query' which has to be a strict or partial retrieval
command, instantiate the query proposition for each generated solution
and retract the resulting propositions.  See `assert-from-query' for
available command options.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %RETRACT-FROM-QUERY)
    (CL:FUNCTION RETRACT-FROM-QUERY-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "DISPLAY-SETTINGS"
    "(DEFUN (DISPLAY-SETTINGS STRING) ())"
    (CL:FUNCTION DISPLAY-SETTINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-QUERY"
    "(DEFUN STARTUP-QUERY () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-QUERY) NULL)
   (CL:LET*
    ((FUNCTION (LOOKUP-FUNCTION SYM-QUERY-LOGIC-STARTUP-QUERY)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-QUERY-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupQuery") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-QUERY ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-QUERY1)
    (HELP-STARTUP-QUERY2) (HELP-STARTUP-QUERY3) (HELP-STARTUP-QUERY4)
    (HELP-STARTUP-QUERY5))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4) (HELP-STARTUP-QUERY6))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5) (HELP-STARTUP-QUERY7))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-QUERY8)
    (HELP-STARTUP-QUERY9) (HELP-STARTUP-QUERY10)
    (HELP-STARTUP-QUERY11))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NORMAL-INFERENCE NORMAL-INFERENCE-LEVEL (NEW NORMAL-INFERENCE-LEVEL :KEYWORD :NORMAL))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL BACKTRACKING-INFERENCE BACKTRACKING-INFERENCE-LEVEL (NEW BACKTRACKING-INFERENCE-LEVEL :KEYWORD :BACKTRACKING))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL SUBSUMPTION-INFERENCE SUBSUMPTION-INFERENCE-LEVEL (NEW SUBSUMPTION-INFERENCE-LEVEL :KEYWORD :SUBSUMPTION))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL SHALLOW-INFERENCE SHALLOW-INFERENCE-LEVEL (NEW SHALLOW-INFERENCE-LEVEL :KEYWORD :SHALLOW))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL ASSERTION-INFERENCE ASSERTION-INFERENCE-LEVEL (NEW ASSERTION-INFERENCE-LEVEL :KEYWORD :ASSERTION))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL REFUTATION-INFERENCE REFUTATION-INFERENCE-LEVEL (NEW REFUTATION-INFERENCE-LEVEL :KEYWORD :REFUTATION))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *INFERENCELEVEL* NORMAL-INFERENCE-LEVEL NORMAL-INFERENCE :DOCUMENTATION \"Specifies the level/depth of inference applied
during a query.  Possible values are:
  :ASSERTION -- database lookup with no inheritance;
  :SHALLOW -- includes database lookup, computed predicates and specialists;
  :SUBSUMPTION -- shallow plus cached subsumption links and equality reasoning;
  :BACKTRACKING -- all of the above plus backtracking over rules;
  :NORMAL -- all of the above plus universal introduction;
  :REFUTATION -- all of the above plus disjunctive implication introduction and refutation.\")")
    (REGISTER-NATIVE-NAME SYM-QUERY-LOGIC-SET-INFERENCE-LEVEL
     KWD-QUERY-COMMON-LISP KWD-QUERY-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DONTUSEDEFAULTKNOWLEDGE?* BOOLEAN FALSE :DOCUMENTATION \"Controls whether queries use default knowledge or not.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAXIMUM-BACKTRACKING-DEPTH* INTEGER *DEFAULT-MAXIMUM-DEPTH* :DOCUMENTATION \"Value for the maximum depth allowable during
backtrack search.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TYPE-CHECK-STRATEGY* KEYWORD :LOOKUP :DOCUMENTATION \"Determines whether there is a slow but thorough type test
when variables are bound, a fast but very shallow one, or none.  Values
are :NONE, :LOOKUP, :DISJOINT.  The default is :LOOKUP.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DUPLICATE-SUBGOAL-STRATEGY* KEYWORD :DUPLICATE-GOALS :DOCUMENTATION \"Determines what kind of duplicate subgoal test to use.  Choices
are :DUPLICATE-RULES, :DUPLICATE-GOALS, and :DUPLICATE-GOALS-WITH-CACHING.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DUPLICATE-GOAL-SEARCH-DEPTH* INTEGER NULL :DOCUMENTATION \"Sets the maximum number of frames search looking for
a duplicate subgoal.  Default value is infinite.  Possibly this should
be replaced by a function that increases with depth of search.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DUPLICATE-RULE-SEARCH-DEPTH* INTEGER NULL :DOCUMENTATION \"Set limit on number of frames searched looking for
a duplicate rule.  Default value is infinite.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *GLOBALLY-CLOSED-COLLECTIONS?* BOOLEAN FALSE :DOCUMENTATION \"If TRUE, all collections are assumed to be closed.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *GENERATE-ALL-PROOFS?* BOOLEAN FALSE :DOCUMENTATION \"If TRUE, the backchainer follows all lines of proof
for each goal, rather than switching to a new goal once the first proof
of a goal is achieved.  The partial matcher sets this variable to
TRUE to force generation of proofs having possibly different
weights.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *QUERYITERATOR* QUERY-ITERATOR NULL :DOCUMENTATION \"Points to the query iterator for the currently executing query.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEFAULT-MAXIMUM-DEPTH* INTEGER 25 :DOCUMENTATION \"Possibly a good value for the maximum backtracking depth.
More testing is needed.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INITIAL-BACKTRACKING-DEPTH* INTEGER 5 :DOCUMENTATION \"Value of the initial depth used during an interative
deepening search.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ITERATIVE-DEEPENING-MODE?* BOOLEAN FALSE :DOCUMENTATION \"Default setting.  If TRUE, queries are evaluated
using iterative deepening from depth '*initial-backtracking-depth*'
to depth '*maximum-backtracking-depth*'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EMIT-THINKING-DOTS?* BOOLEAN TRUE :DOCUMENTATION \"When TRUE, various kinds of characters are
emitted to STANDARD-OUTPUT while PowerLoom is 'thinking'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *THINKING-DOT-COUNTER* INTEGER 0 :DOCUMENTATION \"Used to determine when to generate linefeeds
after forty-or-so thinking dots.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *THINKING-DOT-TABLE* (PROPERTY-LIST OF KEYWORD CHARACTER-WRAPPER) (NEW PROPERTY-LIST :THE-PLIST (BQUOTE (:UPCLASSIFY |&| (WRAP-LITERAL #\\u) :DOWNCLASSIFY |&| (WRAP-LITERAL #\\d) :PROPAGATE |&| (WRAP-LITERAL #\\f) :PARTIAL-MATCH |&| (WRAP-LITERAL #\\p)))) :DOCUMENTATION \"Maps kind of thinking keywords to characters.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *BOOLEAN-VECTOR-INDEX* BOOLEAN-VECTOR-INDEX-NODE (NEW BOOLEAN-VECTOR-INDEX-NODE :THE-VECTOR (NEW BOOLEAN-VECTOR :ARRAY-SIZE 0)) :DOCUMENTATION \"Points to the head of a discrimination tree of containing
all boolean vectors.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PRINTINFRAME* CONTROL-FRAME NULL :DOCUMENTATION \"If set, controls diagnostic printing by making
variable bindings appear relative to the frame '*printInFrame*'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CONTROL-FRAME-ID-COUNTER* INTEGER -1 :DOCUMENTATION \"Generates unique IDs for control frames.  Used only for debugging.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *REVERSEPOLARITY?* BOOLEAN FALSE :PUBLIC? TRUE :DOCUMENTATION \"Signals atomic proposition provers that polarity is negative.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DUPLICATEINSTANCESCACHECROSSOVERPOINT* INTEGER 20 :DOCUMENTATION \"Point where a cache of generated instances in a 
description extension iterator is switched from a list to a hash table\")")
    (DEFINE-EXPLANATION-PHRASE KWD-QUERY-DEPTH-CUTOFF
     KWD-QUERY-TECHNICAL "because of an inference depth cutoff")
    (DEFINE-EXPLANATION-PHRASE KWD-QUERY-DEPTH-CUTOFF KWD-QUERY-LAY
     "because the maximum inference search depth was exceeded")
    (DEFINE-EXPLANATION-PHRASE KWD-QUERY-TIMEOUT KWD-QUERY-TECHNICAL
     "because of an inference timeout")
    (DEFINE-EXPLANATION-PHRASE KWD-QUERY-TIMEOUT KWD-QUERY-LAY
     "because the allotted inference CPU time was exceeded")
    (REGISTER-NATIVE-NAME SYM-QUERY-STELLA-ASK KWD-QUERY-COMMON-LISP
     KWD-QUERY-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MOST-RECENT-QUERY* QUERY-ITERATOR NULL)")
    (REGISTER-NATIVE-NAME SYM-QUERY-STELLA-RETRIEVE
     KWD-QUERY-COMMON-LISP KWD-QUERY-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *QUERY-CACHE* (HASH-TABLE OF SYMBOL QUERY-ITERATOR) (NEW HASH-TABLE) :DOCUMENTATION \"Caches in-line queries, so that they
don't have to be reparsed and reoptimized each time they
are invoked.\")")
    (REGISTER-NATIVE-NAME SYM-QUERY-LOGIC-ASSERT-FROM-QUERY
     KWD-QUERY-COMMON-LISP KWD-QUERY-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-QUERY-LOGIC-RETRACT-FROM-QUERY
     KWD-QUERY-COMMON-LISP KWD-QUERY-FUNCTION))))
