;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; specialists.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2014      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-SPECIALISTS-LOGIC-COMPUTED-PROCEDURE NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-PROCEDURE-NAME NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-PROCEDURE-FUNCTION NULL)
(CL:DEFVAR KWD-SPECIALISTS-ERROR NULL)
(CL:DEFVAR KWD-SPECIALISTS-RELEASE NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-SPECIALIST NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-HANDLES-REVERSE-POLARITY NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-CONSTRAINT NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-COMPUTATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-EVALUATOR NULL)
(CL:DEFVAR KWD-SPECIALISTS-FAIL NULL)
(CL:DEFVAR KWD-SPECIALISTS-TERMINAL-FAILURE NULL)
(CL:DEFVAR KWD-SPECIALISTS-FAILURE NULL)
(CL:DEFVAR KWD-SPECIALISTS-TRUE NULL)
(CL:DEFVAR KWD-SPECIALISTS-FINAL-SUCCESS NULL)
(CL:DEFVAR KWD-SPECIALISTS-CONTINUING-SUCCESS NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-THING NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-FUNCTION-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-METHOD-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-SUBSTRING-POSITION-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-SUPER-STRING NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-SUB-STRING NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-START NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-SUB-LENGTH NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-TOTAL NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-CONS NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-OBJECT NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-ITERATOR NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-COLLECTIONOF NULL)
(CL:DEFVAR KWD-SPECIALISTS-UP-TRUE NULL)
(CL:DEFVAR KWD-SPECIALISTS-UP-FAIL NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-ISA NULL)
(CL:DEFVAR KWD-SPECIALISTS-MOVE-DOWN NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-COLLECTION NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR KWD-SPECIALISTS-SCAN-COLLECTION NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR KWD-SPECIALISTS-DOWN NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-PREDICATE NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-FUNCTION NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-DUMMY NULL)
(CL:DEFVAR KWD-SPECIALISTS-FULL-SUBQUERY NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR KWD-SPECIALISTS-FUNCTION NULL)
(CL:DEFVAR KWD-SPECIALISTS-PREDICATE NULL)
(CL:DEFVAR KWD-SPECIALISTS-ISA NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-SKOLEM NULL)
(CL:DEFVAR KWD-SPECIALISTS-AND NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-ARGUMENTS NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-FORK-PROOF-ADJUNCT NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-CONDITION-JUSTIFICATION NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-DOWN-FRAME NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT NULL)
(CL:DEFVAR KWD-SPECIALISTS-FAIL-INTRODUCTION NULL)
(CL:DEFVAR KWD-SPECIALISTS-FORK-ELSE NULL)
(CL:DEFVAR KWD-SPECIALISTS-FORK-THEN NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)
(CL:DEFVAR KWD-SPECIALISTS-TECHNICAL NULL)
(CL:DEFVAR KWD-SPECIALISTS-LAY NULL)
(CL:DEFVAR KWD-SPECIALISTS-HOW-MANY NULL)
(CL:DEFVAR KWD-SPECIALISTS-INHERIT NULL)
(CL:DEFVAR KWD-SPECIALISTS-ALL NULL)
(CL:DEFVAR KWD-SPECIALISTS-CURRENT NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-QUERY-SPECIALIST-IO-VARIABLES NULL)
(CL:DEFVAR KWD-SPECIALISTS-MATCH-MODE NULL)
(CL:DEFVAR KWD-SPECIALISTS-DESCRIPTION NULL)
(CL:DEFVAR KWD-SPECIALISTS-SORT-BY NULL)
(CL:DEFVAR KWD-SPECIALISTS-GOAL-TREE NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-SAVED-INFERENCE-LEVEL NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-INFERENCE-LEVEL NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-ASSERTION-QUERY NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-SHALLOW-QUERY NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-SUBSUMPTION-QUERY NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-BACKTRACKING-QUERY NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-NORMAL-QUERY NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-REFUTATION-QUERY NULL)
(CL:DEFVAR KWD-SPECIALISTS-LEVELED-QUERY NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-CONCEPT-PROTOTYPE NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-HYPOTHESIZED-INSTANCE? NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-MONOTONIC? NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-F-CLOSED-TERM?-MEMO-TABLE-000 NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-EQUIVALENT-VALUE NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-F-CLOSED-PROPOSITION?-MEMO-TABLE-000 NULL)
(CL:DEFVAR KWD-SPECIALISTS-OR NULL)
(CL:DEFVAR KWD-SPECIALISTS-NOT NULL)
(CL:DEFVAR KWD-SPECIALISTS-FORALL NULL)
(CL:DEFVAR KWD-SPECIALISTS-EXISTS NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-MEMBER-OF NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-SINGLE-VALUED NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-F-SINGLE-VALUED-TERM?-MEMO-TABLE-000 NULL)
(CL:DEFVAR KWD-SPECIALISTS-EQUIVALENT NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-COLLECT-INTO-LIST NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-COLLECT-INTO-ORDERED-SET NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-INFERENCE-CUTOFF-REASON NULL)
(CL:DEFVAR KWD-SPECIALISTS-COLLECT-MEMBERS NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-?SUPER NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-?MDC NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-AND NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-MEMBER-OF NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-MUTUALLY-DISJOINT-COLLECTION NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-F-HELP-DERIVE-PARTITION-MEMBERSHIPS-QUERY-000 NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-MUTUALLY-DISJOINT-COLLECTION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-PARTITION-MEMBERSHIP NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-DISJOINT NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-HAS-PARTITION-MEMBERSHIP NULL)
(CL:DEFVAR KWD-SPECIALISTS-ASSERT-TRUE NULL)
(CL:DEFVAR KWD-SPECIALISTS-ASSERT-FALSE NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-EMPTY NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-SAVED-CONTEXT-PROOF-ADJUNCT NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-SAVED-CONTEXT NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-CONTEXT NULL)
(CL:DEFVAR KWD-SPECIALISTS-IST-INTRODUCTION NULL)
(CL:DEFVAR KWD-SPECIALISTS-PARTIAL NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-THE-ROLESET NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-CARDINALITY NULL)
(CL:DEFVAR KWD-SPECIALISTS-LOWER NULL)
(CL:DEFVAR KWD-SPECIALISTS-UPPER NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-SURROGATE NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUBRELATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUPERRELATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-SUBRELATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-SUPERRELATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUBRELATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUPERRELATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-EQUIVALENT-RELATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-LIST NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-SYNONYM NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-CS-VALUE NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-REGISTER-SPECIALIST-FUNCTION-NAME NULL)
(CL:DEFVAR KWD-SPECIALISTS-COMMON-LISP NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-REGISTER-COMPUTATION-FUNCTION-NAME NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-STARTUP-SPECIALISTS NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* DEFAULT-TRUE-TRUTH-VALUE
  DEFAULT-FALSE-TRUTH-VALUE UNKNOWN-TRUTH-VALUE *MODULE*
  *CYC-KLUDGES-ENABLED?* *MEMOIZATION-ENABLED?* MEMOIZED-NULL-VALUE
  *CONTEXT* *INFERENCELEVEL* SHALLOW-INFERENCE SUBSUMPTION-INFERENCE
  BACKTRACKING-INFERENCE NORMAL-INFERENCE *TRACED-KEYWORDS* NIL-LIST
  *RECORD-JUSTIFICATIONS?* EMPTY-PROPOSITIONS-ITERATOR
  REFUTATION-INFERENCE ASSERTION-INFERENCE FALSE-WRAPPER NIL
  NULL-INTEGER TRUE-WRAPPER NULL-INTEGER-WRAPPER NULL-STRING-WRAPPER
  NULL-FLOAT-WRAPPER NULL-CHARACTER-WRAPPER NULL-FUNCTION-CODE-WRAPPER
  NULL-METHOD-CODE-WRAPPER STANDARD-OUTPUT FALSE-TRUTH-VALUE
  *QUERYITERATOR* TRUE-TRUTH-VALUE *REVERSEPOLARITY?*
  *PL-KERNEL-MODULE* EOL *POWERLOOM-EXECUTION-MODE*))

(CL:DEFUN NEW-COMPUTED-PROCEDURE ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-COMPUTED-PROCEDURE))
   (CL:SETF (%COMPUTED-PROCEDURE.DYNAMIC-SLOTS SELF)
    (NEW-KEY-VALUE-LIST))
   (CL:SETF (%COMPUTED-PROCEDURE.SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%COMPUTED-PROCEDURE.PROCEDURE-FUNCTION SELF) NULL)
   (CL:SETF (%COMPUTED-PROCEDURE.PROCEDURE-NAME SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF COMPUTED-PROCEDURE))
  SGT-SPECIALISTS-LOGIC-COMPUTED-PROCEDURE)

(CL:DEFUN ACCESS-COMPUTED-PROCEDURE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-PROCEDURE-NAME)
    (CL:IF SETVALUE?
     (CL:SETF (%COMPUTED-PROCEDURE.PROCEDURE-NAME SELF) VALUE)
     (CL:SETQ VALUE (%COMPUTED-PROCEDURE.PROCEDURE-NAME SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-PROCEDURE-FUNCTION)
    (CL:IF SETVALUE?
     (CL:SETF (%COMPUTED-PROCEDURE.PROCEDURE-FUNCTION SELF) VALUE)
     (CL:SETQ VALUE (%COMPUTED-PROCEDURE.PROCEDURE-FUNCTION SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%COMPUTED-PROCEDURE.DYNAMIC-SLOTS SELF)
      SLOTNAME VALUE NULL)
     (CL:SETQ VALUE
      (LOOKUP (%COMPUTED-PROCEDURE.DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFUN (STELLA-FUNCTION-FROM-PROCEDURE FUNCTION) ...)

(CL:DEFUN STELLA-FUNCTION-FROM-PROCEDURE (PROCEDURE)
  (CL:WHEN
   (CL:NOT
    (CL:EQ (%COMPUTED-PROCEDURE.PROCEDURE-FUNCTION PROCEDURE) NULL))
   (CL:RETURN-FROM STELLA-FUNCTION-FROM-PROCEDURE
    (%COMPUTED-PROCEDURE.PROCEDURE-FUNCTION PROCEDURE)))
  (CL:LET*
   ((PROCEDURENAME (%COMPUTED-PROCEDURE.PROCEDURE-NAME PROCEDURE))
    (STELLAFUNCTION NULL))
   (CL:WHEN (CL:EQ PROCEDURENAME NULL)
    (CL:SETQ PROCEDURENAME
     (INTERN-SYMBOL-IN-MODULE
      (%SURROGATE.SYMBOL-NAME
       (%COMPUTED-PROCEDURE.SURROGATE-VALUE-INVERSE PROCEDURE))
      (%SURROGATE.HOME-CONTEXT
       (%COMPUTED-PROCEDURE.SURROGATE-VALUE-INVERSE PROCEDURE))
      CL:T))
    (CL:SETF (%COMPUTED-PROCEDURE.PROCEDURE-NAME PROCEDURE)
     PROCEDURENAME))
   (CL:SETQ STELLAFUNCTION (LOOKUP-FUNCTION PROCEDURENAME))
   (CL:WHEN (CL:EQ STELLAFUNCTION NULL)
    (CL:LET*
     ((KERNELNAME
       (LOOKUP-SYMBOL-IN-MODULE (%SYMBOL.SYMBOL-NAME PROCEDURENAME)
        *PL-KERNEL-MODULE* CL:NIL)))
     (CL:WHEN (CL:NOT (CL:EQ KERNELNAME NULL))
      (CL:SETQ STELLAFUNCTION (LOOKUP-FUNCTION KERNELNAME)))))
   (CL:WHEN (CL:EQ STELLAFUNCTION NULL)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "ERROR: Missing specialist, no STELLA function is named `"
       PROCEDURENAME "'." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-SPECIALISTS-ERROR))
     (CL:ERROR
      (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   (CL:WHEN (CL:EQ *POWERLOOM-EXECUTION-MODE* KWD-SPECIALISTS-RELEASE)
    (CL:SETF (%COMPUTED-PROCEDURE.PROCEDURE-FUNCTION PROCEDURE)
     STELLAFUNCTION))
   STELLAFUNCTION))

;;; (DEFUN (FUNCTION-CODE-FROM-PROCEDURE FUNCTION-CODE) ...)

(CL:DEFUN FUNCTION-CODE-FROM-PROCEDURE (PROCEDURE)
  (CL:LET*
   ((STELLAFUNCTION
     (%COMPUTED-PROCEDURE.PROCEDURE-FUNCTION PROCEDURE)))
   (CL:WHEN (CL:EQ STELLAFUNCTION NULL)
    (CL:SETQ STELLAFUNCTION
     (STELLA-FUNCTION-FROM-PROCEDURE PROCEDURE)))
   (%METHOD-SLOT.FUNCTION-CODE STELLAFUNCTION)))

;;; (DEFUN (LOOKUP-SPECIALIST FUNCTION-CODE) ...)

(CL:DEFUN LOOKUP-SPECIALIST (DESCRIPTION)
  (CL:LET*
   ((SPECIALISTPROCEDURE
     (ACCESS-BINARY-VALUE DESCRIPTION
      SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-SPECIALIST))
    (FUNCTIONCODE NULL))
   (CL:WHEN (CL:NOT (CL:EQ SPECIALISTPROCEDURE NULL))
    (CL:IF
     (CL:AND *REVERSEPOLARITY?*
      (CL:NOT
       (TEST-PROPERTY? SPECIALISTPROCEDURE
        SGT-SPECIALISTS-PL-KERNEL-KB-HANDLES-REVERSE-POLARITY)))
     (CL:RETURN-FROM LOOKUP-SPECIALIST NULL)
     (CL:SETQ FUNCTIONCODE
      (FUNCTION-CODE-FROM-PROCEDURE SPECIALISTPROCEDURE))))
   (CL:WHEN (CL:EQ FUNCTIONCODE NULL)
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ (NATIVE-RELATION DESCRIPTION) NULL))
      (CL:NOT (CLASS-DESCRIPTION? DESCRIPTION)))
     (CL:SETQ FUNCTIONCODE
      (CL:FUNCTION NATIVE-SLOT-READER-SPECIALIST))))
   FUNCTIONCODE))

;;; (DEFUN (LOOKUP-CONSTRAINT-FUNCTION FUNCTION) ...)

(CL:DEFUN LOOKUP-CONSTRAINT-FUNCTION (DESCRIPTION)
  (CL:LET*
   ((COMPUTATIONPROCEDURE
     (ACCESS-BINARY-VALUE DESCRIPTION
      SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-CONSTRAINT)))
   (CL:IF (CL:NOT (CL:EQ COMPUTATIONPROCEDURE NULL))
    (STELLA-FUNCTION-FROM-PROCEDURE COMPUTATIONPROCEDURE) NULL)))

;;; (DEFUN (LOOKUP-CONSTRAINT FUNCTION-CODE) ...)

(CL:DEFUN LOOKUP-CONSTRAINT (DESCRIPTION)
  (CL:LET* ((FUNCTION (LOOKUP-CONSTRAINT-FUNCTION DESCRIPTION)))
   (CL:IF (CL:NOT (CL:EQ FUNCTION NULL))
    (%METHOD-SLOT.FUNCTION-CODE FUNCTION) NULL)))

;;; (DEFUN (LOOKUP-COMPUTATION-FUNCTION FUNCTION) ...)

(CL:DEFUN LOOKUP-COMPUTATION-FUNCTION (DESCRIPTION)
  (CL:LET*
   ((COMPUTATIONPROCEDURE
     (ACCESS-BINARY-VALUE DESCRIPTION
      SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-COMPUTATION)))
   (CL:IF (CL:NOT (CL:EQ COMPUTATIONPROCEDURE NULL))
    (STELLA-FUNCTION-FROM-PROCEDURE COMPUTATIONPROCEDURE) NULL)))

;;; (DEFUN (LOOKUP-COMPUTATION FUNCTION-CODE) ...)

(CL:DEFUN LOOKUP-COMPUTATION (DESCRIPTION)
  (CL:LET* ((FUNCTION (LOOKUP-COMPUTATION-FUNCTION DESCRIPTION)))
   (CL:IF (CL:NOT (CL:EQ FUNCTION NULL))
    (%METHOD-SLOT.FUNCTION-CODE FUNCTION) NULL)))

;;; (DEFUN (LOOKUP-EVALUATOR-FUNCTION FUNCTION) ...)

(CL:DEFUN LOOKUP-EVALUATOR-FUNCTION (DESCRIPTION)
  (CL:LET*
   ((COMPUTATIONPROCEDURE
     (ACCESS-BINARY-VALUE DESCRIPTION
      SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-EVALUATOR)))
   (CL:IF (CL:NOT (CL:EQ COMPUTATIONPROCEDURE NULL))
    (STELLA-FUNCTION-FROM-PROCEDURE COMPUTATIONPROCEDURE) NULL)))

;;; (DEFUN (LOOKUP-EVALUATOR FUNCTION-CODE) ...)

(CL:DEFUN LOOKUP-EVALUATOR (DESCRIPTION)
  (CL:LET* ((FUNCTION (LOOKUP-EVALUATOR-FUNCTION DESCRIPTION)))
   (CL:IF (CL:NOT (CL:EQ FUNCTION NULL))
    (%METHOD-SLOT.FUNCTION-CODE FUNCTION) NULL)))

;;; (DEFUN (SELECT-TEST-RESULT KEYWORD) ...)

(CL:DEFUN SELECT-TEST-RESULT (SUCCESS? TERMINAL? FRAME)
  "Helping function for specialists testing the validity of a
fully bound inference frame.  Based on the test result `success?'
and `reversePolarity?*', set the truth value of `frame' and return
an appropriate keyword.  The keyword will be either `:final-success'
`:terminal-failure' if `terminal?' is true.  Otherwise it will be
`:final-success' or `:failure'."
  (CL:COND
   ((CL:EQ SUCCESS? *REVERSEPOLARITY?*)
    (SET-FRAME-TRUTH-VALUE FRAME FALSE-TRUTH-VALUE)
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT
       (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
        NULL)))
     (SET-BASE-PARTIAL-MATCH-TRUTH
      (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
      (%CONTROL-FRAME.PROPOSITION FRAME) KWD-SPECIALISTS-FAIL))
    (CL:IF TERMINAL? KWD-SPECIALISTS-TERMINAL-FAILURE
     KWD-SPECIALISTS-FAILURE))
   (CL:T (SET-FRAME-TRUTH-VALUE FRAME TRUE-TRUTH-VALUE)
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT
       (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
        NULL)))
     (SET-BASE-PARTIAL-MATCH-TRUTH
      (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
      (%CONTROL-FRAME.PROPOSITION FRAME) KWD-SPECIALISTS-TRUE))
    KWD-SPECIALISTS-FINAL-SUCCESS)))

;;; (DEFUN (SELECT-PROOF-RESULT KEYWORD) ...)

(CL:DEFUN SELECT-PROOF-RESULT (SUCCESS? CONTINUING? TERMINAL?)
  "Helping function for specialists.   Return the appropriate
keyword indicating success or failure of a proof."
  (CL:IF SUCCESS?
   (CL:IF CONTINUING? KWD-SPECIALISTS-CONTINUING-SUCCESS
    KWD-SPECIALISTS-FINAL-SUCCESS)
   (CL:IF TERMINAL? KWD-SPECIALISTS-TERMINAL-FAILURE
    KWD-SPECIALISTS-FAILURE)))

;;; (DEFUN (NULL-WRAPPER? BOOLEAN) ...)

(CL:DEFUN NULL-WRAPPER? (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-THING)
     (CL:PROGN (CL:RETURN-FROM NULL-WRAPPER? (CL:EQ SELF NULL))))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM NULL-WRAPPER? (EQL? SELF NULL-INTEGER-WRAPPER))))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM NULL-WRAPPER? (EQL? SELF NULL-STRING-WRAPPER))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM NULL-WRAPPER? (EQL? SELF NULL-FLOAT-WRAPPER))))
    ((SUBTYPE-OF-CHARACTER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM NULL-WRAPPER?
       (EQL? SELF NULL-CHARACTER-WRAPPER))))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-SPECIALISTS-STELLA-FUNCTION-CODE-WRAPPER)
     (CL:PROGN
      (CL:RETURN-FROM NULL-WRAPPER?
       (EQL? SELF NULL-FUNCTION-CODE-WRAPPER))))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-SPECIALISTS-STELLA-METHOD-CODE-WRAPPER)
     (CL:PROGN
      (CL:RETURN-FROM NULL-WRAPPER?
       (EQL? SELF NULL-METHOD-CODE-WRAPPER))))
    (CL:T
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Not prepared to handle native slots with type "
      (PRIMARY-TYPE SELF) EOL))))
  CL:NIL)

;;; (DEFUN (NATIVE-SLOT-READER-SPECIALIST KEYWORD) ...)

(CL:DEFUN NATIVE-SLOT-READER-SPECIALIST (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (DESCRIPTION (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION)))
    (ARGUMENTVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       0)))
    (SLOT
     (CL:IF (CL:NOT (CLASS-DESCRIPTION? DESCRIPTION))
      (NATIVE-RELATION DESCRIPTION) NULL))
    (SUCCESS? CL:NIL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ ARGUMENTVALUE NULL))
     (CL:NOT (CL:EQ SLOT NULL))
     (ISA? ARGUMENTVALUE SGT-SPECIALISTS-STELLA-THING)
     (CL:NOT (%SLOT.ABSTRACT? SLOT)))
    (CL:LET* ((VALUE (READ-SLOT-VALUE ARGUMENTVALUE SLOT)))
     (CL:WHEN (CL:EQ VALUE NULL)
      (CL:RETURN-FROM NATIVE-SLOT-READER-SPECIALIST
       KWD-SPECIALISTS-FAILURE))
     (CL:WHEN (CL:NOT (NULL-WRAPPER? VALUE))
      (CL:IF (FUNCTION-DESCRIPTION? DESCRIPTION)
       (CL:SETQ SUCCESS?
        (BIND-VARIABLE-TO-VALUE?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
          (CL:THE CL:FIXNUM
           (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION)))))
         VALUE CL:T))
       (CL:SETQ SUCCESS? (EQL? VALUE TRUE-WRAPPER)))
      (CL:RETURN-FROM NATIVE-SLOT-READER-SPECIALIST
       (SELECT-TEST-RESULT SUCCESS? CL:T FRAME)))))
   KWD-SPECIALISTS-FAILURE))

(CL:DEFUN NEW-SUBSTRING-POSITION-ITERATOR (SUPER-STRING SUB-STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SUPER-STRING SUB-STRING))
  #+MCL
  (CL:CHECK-TYPE SUPER-STRING CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SUB-STRING CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-SUBSTRING-POSITION-ITERATOR))
   (CL:SETF (%SUBSTRING-POSITION-ITERATOR.SUPER-STRING SELF)
    SUPER-STRING)
   (CL:SETF (%SUBSTRING-POSITION-ITERATOR.SUB-STRING SELF) SUB-STRING)
   (CL:SETF (%SUBSTRING-POSITION-ITERATOR.FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%SUBSTRING-POSITION-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%SUBSTRING-POSITION-ITERATOR.SUB-LENGTH SELF)
    (CL:THE CL:FIXNUM
     (CL:LENGTH
      (CL:THE CL:SIMPLE-STRING
       (%SUBSTRING-POSITION-ITERATOR.SUB-STRING SELF)))))
   (CL:SETF (%SUBSTRING-POSITION-ITERATOR.START SELF) 0) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SUBSTRING-POSITION-ITERATOR))
  SGT-SPECIALISTS-LOGIC-SUBSTRING-POSITION-ITERATOR)

(CL:DEFUN ACCESS-SUBSTRING-POSITION-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-SUPER-STRING)
    (CL:IF SETVALUE?
     (CL:SETF (%SUBSTRING-POSITION-ITERATOR.SUPER-STRING SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-STRING (%SUBSTRING-POSITION-ITERATOR.SUPER-STRING SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-SUB-STRING)
    (CL:IF SETVALUE?
     (CL:SETF (%SUBSTRING-POSITION-ITERATOR.SUB-STRING SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-STRING (%SUBSTRING-POSITION-ITERATOR.SUB-STRING SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-STELLA-START)
    (CL:IF SETVALUE?
     (CL:SETF (%SUBSTRING-POSITION-ITERATOR.START SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%SUBSTRING-POSITION-ITERATOR.START SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-SUB-LENGTH)
    (CL:IF SETVALUE?
     (CL:SETF (%SUBSTRING-POSITION-ITERATOR.SUB-LENGTH SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%SUBSTRING-POSITION-ITERATOR.SUB-LENGTH SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((IT SUBSTRING-POSITION-ITERATOR))
  (CL:LET*
   ((P1
     (STRING-SEARCH (%SUBSTRING-POSITION-ITERATOR.SUPER-STRING IT)
      (%SUBSTRING-POSITION-ITERATOR.SUB-STRING IT)
      (%SUBSTRING-POSITION-ITERATOR.START IT))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM P1))
   (CL:IF (CL:NOT (CL:= P1 NULL-INTEGER))
    (CL:PROGN
     (CL:SETF (%SUBSTRING-POSITION-ITERATOR.VALUE IT)
      (CONS (WRAP-INTEGER P1)
       (CONS
        (WRAP-INTEGER
         (CL:+ P1 (%SUBSTRING-POSITION-ITERATOR.SUB-LENGTH IT)))
        NIL)))
     (CL:SETF (%SUBSTRING-POSITION-ITERATOR.START IT) (CL:1+ P1)) CL:T)
    (CL:PROGN (CL:SETF (%SUBSTRING-POSITION-ITERATOR.VALUE IT) NULL)
     CL:NIL))))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((IT SUBSTRING-POSITION-ITERATOR))
  (CL:LET*
   ((COUNT 0) (SUPER (%SUBSTRING-POSITION-ITERATOR.SUPER-STRING IT))
    (SUB (%SUBSTRING-POSITION-ITERATOR.SUB-STRING IT))
    (P1 (STRING-SEARCH SUPER SUB 0)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT P1)
    (CL:TYPE CL:SIMPLE-STRING SUPER SUB))
   (CL:LOOP WHILE (CL:NOT (CL:= P1 NULL-INTEGER)) DO
    (CL:SETQ COUNT (CL:1+ COUNT))
    (CL:SETQ P1 (STRING-SEARCH SUPER SUB (CL:1+ P1))))
   COUNT))

;;; (DEFUN (BOUND-COMPUTATION-INPUT-SKOLEM? BOOLEAN) ...)

(CL:DEFUN BOUND-COMPUTATION-INPUT-SKOLEM? (SKOLEM)
  (CL:IF (LOGICAL-COLLECTION? SKOLEM) CL:T
   (CL:LET* ((PROP (%SKOLEM.DEFINING-PROPOSITION SKOLEM)))
    (CL:AND (CL:NOT (CL:EQ PROP NULL))
     (TEST-PROPERTY? (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROP))
      SGT-SPECIALISTS-PL-KERNEL-KB-TOTAL)))))

;;; (DEFUN (ARGUMENT-TARGET-TYPE TYPE) ...)

(CL:DEFUN ARGUMENT-TARGET-TYPE (PARAMETERTYPES NINPUTTYPES ARGINDEX)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NINPUTTYPES ARGINDEX))
  #+MCL
  (CL:CHECK-TYPE NINPUTTYPES CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE ARGINDEX CL:FIXNUM)
  (CL:LET*
   ((TARGETTYPE
     (NTH PARAMETERTYPES (MIN ARGINDEX (CL:1- NINPUTTYPES)))))
   (CL:COND
    ((CL:EQ (TYPE-SPEC-TO-BASE-TYPE TARGETTYPE)
      SGT-SPECIALISTS-STELLA-CONS)
     (CL:COND
      ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER?
        (SAFE-PRIMARY-TYPE TARGETTYPE))
       (CL:PROGN
        (TYPE-SPEC-TO-BASE-TYPE
         (FIRST
          (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
           TARGETTYPE)))))
      (CL:T SGT-SPECIALISTS-STELLA-OBJECT)))
    (CL:T TARGETTYPE))))

;;; (DEFUN (COMPUTE-RELATION-VALUE OBJECT) ...)

(CL:DEFUN COMPUTE-RELATION-VALUE (PROPOSITION COMPUTATION ERROR?)
  (CL:LET*
   ((ARGUMENTS (%PROPOSITION.ARGUMENTS PROPOSITION))
    (DESCRIPTION (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION)))
    (FUNCTION? (FUNCTION-DESCRIPTION? DESCRIPTION))
    (ARGTYPES (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES DESCRIPTION))
    (NINPUTTYPES (CL:- (LENGTH ARGTYPES) (CL:IF FUNCTION? 1 0)))
    (COMPARGTYPES NULL) (VALUE NULL) (BOUNDARGUMENTS NIL)
    (VARIABLEARITY? (VARIABLE-ARITY? DESCRIPTION)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NINPUTTYPES))
   (CL:WHEN (CL:EQ COMPUTATION NULL)
    (CL:SETQ COMPUTATION (LOOKUP-COMPUTATION-FUNCTION DESCRIPTION)))
   (CL:SETQ COMPARGTYPES
    (METHOD-PARAMETER-TYPE-SPECIFIERS COMPUTATION))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:- (LENGTH ARGUMENTS) (CL:IF FUNCTION? 2 1)))
     (COLLECT-000 NULL))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000
      UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000)
      (CL:<= ITER-000 UPPER-BOUND-000))
     DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000) (CL:SETQ VALUE (SAFE-ARGUMENT-BOUND-TO ARG))
     (CL:COND
      ((CL:EQ VALUE NULL) (CL:RETURN-FROM COMPUTE-RELATION-VALUE NULL))
      ((CL:AND
        (CHECK-STRICT-TYPE? VALUE
         (ARGUMENT-TARGET-TYPE ARGTYPES NINPUTTYPES I) CL:T)
        (SUBTYPE-OF? (PRIMARY-TYPE VALUE)
         (ARGUMENT-TARGET-TYPE COMPARGTYPES NINPUTTYPES I))))
      ((CL:AND (SKOLEM? VALUE)
        (CL:NOT (BOUND-COMPUTATION-INPUT-SKOLEM? VALUE)))
       (CL:RETURN-FROM COMPUTE-RELATION-VALUE NULL))
      (CL:T
       (CL:IF ERROR?
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
           "ERROR: compute-relation-value: incorrect argument type for `"
           VALUE "' in `" PROPOSITION "'." EOL)
          (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
           KWD-SPECIALISTS-ERROR))
         (CL:ERROR
          (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))
        (CL:RETURN-FROM COMPUTE-RELATION-VALUE NULL))))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS VALUE NIL))
       (CL:IF (CL:EQ BOUNDARGUMENTS NIL)
        (CL:SETQ BOUNDARGUMENTS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST BOUNDARGUMENTS COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VALUE NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:WHEN VARIABLEARITY?
    (CL:LET* ((NFIXED (CL:- (LENGTH ARGTYPES) (CL:IF FUNCTION? 2 1))))
     (CL:DECLARE (CL:TYPE CL:FIXNUM NFIXED))
     (CL:COND
      ((CL:= NFIXED 0)
       (CL:SETQ BOUNDARGUMENTS (CONS BOUNDARGUMENTS NIL)))
      ((CL:>= (LENGTH BOUNDARGUMENTS) NFIXED)
       (NTH-REST-SETTER BOUNDARGUMENTS
        (CONS (NTH-REST BOUNDARGUMENTS NFIXED) NIL) NFIXED))
      (CL:T (CL:RETURN-FROM COMPUTE-RELATION-VALUE NULL)))))
   (CL:SETQ VALUE
    (APPLY (%METHOD-SLOT.FUNCTION-CODE COMPUTATION) BOUNDARGUMENTS))
   VALUE))

;;; (DEFUN (/PL-KERNEL-KB/COMPUTATION-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/COMPUTATION-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (VALUE (COMPUTE-RELATION-VALUE PROPOSITION NULL CL:NIL))
    (SUCCESS? NULL))
   (CL:WHEN (CL:EQ VALUE NULL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/COMPUTATION-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:IF
    (FUNCTION-DESCRIPTION?
     (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION)))
    (CL:SETQ SUCCESS?
     (CL:IF
      (BIND-ARGUMENT-TO-VALUE?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
        (CL:THE CL:FIXNUM
         (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION)))))
       VALUE CL:T)
      TRUE-WRAPPER FALSE-WRAPPER))
    (CL:SETQ SUCCESS? VALUE))
   (SELECT-TEST-RESULT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN SUCCESS?)
    CL:T FRAME)))

;;; (DEFUN (COMPUTE-SIMPLE-RELATION-CONSTRAINT OBJECT INTEGER) ...)

(CL:DEFUN COMPUTE-SIMPLE-RELATION-CONSTRAINT (PROPOSITION COMPUTATION ERROR?)
  (CL:LET*
   ((ARGUMENTS (%PROPOSITION.ARGUMENTS PROPOSITION))
    (DESCRIPTION (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION)))
    (ARGTYPES (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES DESCRIPTION))
    (NINPUTTYPES (LENGTH ARGTYPES)) (COMPARGTYPES NULL) (VALUE NULL)
    (NULLCOUNT 0) (VARIABLEINDEX -1) (BOUNDARGUMENTS NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NINPUTTYPES NULLCOUNT VARIABLEINDEX))
   (CL:WHEN (CL:EQ COMPUTATION NULL)
    (CL:SETQ COMPUTATION (LOOKUP-CONSTRAINT-FUNCTION DESCRIPTION)))
   (CL:SETQ COMPARGTYPES
    (METHOD-PARAMETER-TYPE-SPECIFIERS COMPUTATION))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 0)
     (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000) (CL:SETQ VALUE (SAFE-ARGUMENT-BOUND-TO ARG))
     (CL:COND
      ((CL:EQ VALUE NULL) (CL:SETQ VALUE NULL)
       (CL:SETQ NULLCOUNT (CL:1+ NULLCOUNT)) (CL:SETQ VARIABLEINDEX I))
      ((CL:AND
        (CHECK-STRICT-TYPE? VALUE
         (ARGUMENT-TARGET-TYPE ARGTYPES NINPUTTYPES I) CL:T)
        (SUBTYPE-OF? (PRIMARY-TYPE VALUE)
         (ARGUMENT-TARGET-TYPE COMPARGTYPES (CL:1+ NINPUTTYPES)
          (CL:1+ I)))))
      ((CL:AND (SKOLEM? VALUE)
        (CL:NOT (BOUND-COMPUTATION-INPUT-SKOLEM? VALUE)))
       (CL:SETQ VALUE NULL) (CL:SETQ NULLCOUNT (CL:1+ NULLCOUNT))
       (CL:SETQ VARIABLEINDEX I))
      (CL:T
       (CL:IF ERROR?
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
           "ERROR: compute-relation-constraint: incorrect argument type for `"
           VALUE "' in `" PROPOSITION "'." EOL)
          (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
           KWD-SPECIALISTS-ERROR))
         (CL:ERROR
          (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))
        (CL:RETURN-FROM COMPUTE-SIMPLE-RELATION-CONSTRAINT
         (CL:VALUES NULL -1)))))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS VALUE NIL))
       (CL:IF (CL:EQ BOUNDARGUMENTS NIL)
        (CL:SETQ BOUNDARGUMENTS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST BOUNDARGUMENTS COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VALUE NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:CASE NULLCOUNT
    (0
     (CL:SETQ VALUE
      (APPLY (%METHOD-SLOT.FUNCTION-CODE COMPUTATION)
       (CONS (WRAP-INTEGER VARIABLEINDEX) BOUNDARGUMENTS))))
    (1
     (CL:WHEN *REVERSEPOLARITY?*
      (CL:RETURN-FROM COMPUTE-SIMPLE-RELATION-CONSTRAINT
       (CL:VALUES NULL -1)))
     (CL:SETQ VALUE
      (APPLY (%METHOD-SLOT.FUNCTION-CODE COMPUTATION)
       (CONS (WRAP-INTEGER VARIABLEINDEX) BOUNDARGUMENTS))))
    (CL:OTHERWISE
     (CL:RETURN-FROM COMPUTE-SIMPLE-RELATION-CONSTRAINT
      (CL:VALUES NULL -1))))
   (CL:VALUES VALUE VARIABLEINDEX)))

;;; (DEFUN (/PL-KERNEL-KB/CONSTRAINT-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/CONSTRAINT-SPECIALIST| (FRAME LASTMOVE)
  (CL:SETQ LASTMOVE LASTMOVE)
  (CL:LET* ((VALUE NULL) (VARIABLEINDEX NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM VARIABLEINDEX))
   (CL:MULTIPLE-VALUE-SETQ (VALUE VARIABLEINDEX)
    (COMPUTE-SIMPLE-RELATION-CONSTRAINT
     (%CONTROL-FRAME.PROPOSITION FRAME) NULL CL:NIL))
   (CL:WHEN (CL:EQ VALUE NULL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/CONSTRAINT-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:CASE VARIABLEINDEX
    (-1 (SELECT-TEST-RESULT (CL:EQ VALUE TRUE-WRAPPER) CL:T FRAME))
    (CL:OTHERWISE
     (SELECT-TEST-RESULT
      (BIND-ARGUMENT-TO-VALUE?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY
          (%PROPOSITION.ARGUMENTS (%CONTROL-FRAME.PROPOSITION FRAME))))
        VARIABLEINDEX)
       VALUE CL:T)
      CL:T FRAME)))))

;;; (DEFUN (/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (MAINARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (MAINARGVALUE (ARGUMENT-BOUND-TO MAINARG))
    (ROOTARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (ROOTARGVALUE (ARGUMENT-BOUND-TO ROOTARG))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL))
    (COLLECTION NIL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:IF (CL:EQ MAINARGVALUE NULL)
     (CL:IF (CL:EQ ROOTARGVALUE NULL)
      (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
       KWD-SPECIALISTS-TERMINAL-FAILURE)
      (CL:IF (ISA? ROOTARGVALUE SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (CL:IF *REVERSEPOLARITY?*
        (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
         KWD-SPECIALISTS-FAILURE)
        (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
         (SELECT-PROOF-RESULT
          (BIND-ARGUMENT-TO-VALUE? MAINARG
           (|/PL-KERNEL-KB/TIMES-COMPUTATION| ROOTARGVALUE
            ROOTARGVALUE)
           CL:T)
          CL:NIL CL:T)))
       (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
        KWD-SPECIALISTS-TERMINAL-FAILURE)))
     (CL:IF (ISA? MAINARGVALUE SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
      (CL:IF
       (|/PL-KERNEL-KB/ARITHMETIC-LESS-TEST| MAINARGVALUE
        (WRAP-INTEGER 0))
       (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
        KWD-SPECIALISTS-TERMINAL-FAILURE)
       (CL:IF (CL:AND (CL:EQ ROOTARGVALUE NULL) *REVERSEPOLARITY?*)
        (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
         KWD-SPECIALISTS-FAILURE)
        (CL:LET*
         ((SQRT (|/PL-KERNEL-KB/SQRT-COMPUTATION| MAINARGVALUE)))
         (CL:SETQ COLLECTION
          (CONS-LIST SQRT
           (|/PL-KERNEL-KB/NEGATE-COMPUTATION| SQRT))))))
      (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
       KWD-SPECIALISTS-TERMINAL-FAILURE))))
   (CL:WHEN (CL:NOT (CL:EQ ROOTARGVALUE NULL))
    (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
     (SELECT-TEST-RESULT
      (CL:OR
       (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST| ROOTARGVALUE
        (%%VALUE COLLECTION))
       (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST| ROOTARGVALUE
        (%%VALUE (%%REST COLLECTION))))
      CL:T FRAME)))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:SETQ ITERATOR (ALLOCATE-ITERATOR COLLECTION))
    (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
   (CL:IF
    (CL:AND (NEXT? ITERATOR)
     (BIND-ARGUMENT-TO-VALUE? ROOTARG (%ITERATOR.VALUE ITERATOR) CL:T))
    KWD-SPECIALISTS-CONTINUING-SUCCESS
    KWD-SPECIALISTS-TERMINAL-FAILURE)))

;;; (DEFUN (/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (MAINARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (MAINARGVALUE (ARGUMENT-BOUND-TO MAINARG))
    (ABSARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (ABSARGVALUE (ARGUMENT-BOUND-TO ABSARG))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL))
    (COLLECTION NIL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:IF (CL:EQ ABSARGVALUE NULL)
     (CL:IF (CL:EQ MAINARGVALUE NULL)
      (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
       KWD-SPECIALISTS-TERMINAL-FAILURE)
      (CL:IF (ISA? MAINARGVALUE SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (CL:IF *REVERSEPOLARITY?*
        (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
         KWD-SPECIALISTS-FAILURE)
        (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
         (SELECT-PROOF-RESULT
          (BIND-ARGUMENT-TO-VALUE? ABSARG
           (|/PL-KERNEL-KB/ABS-COMPUTATION| MAINARGVALUE) CL:T)
          CL:NIL CL:T)))
       (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
        KWD-SPECIALISTS-TERMINAL-FAILURE)))
     (CL:IF (ISA? ABSARGVALUE SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
      (CL:IF
       (|/PL-KERNEL-KB/ARITHMETIC-LESS-TEST| ABSARGVALUE
        (WRAP-INTEGER 0))
       (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
        KWD-SPECIALISTS-TERMINAL-FAILURE)
       (CL:IF *REVERSEPOLARITY?*
        (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
         KWD-SPECIALISTS-FAILURE)
        (CL:SETQ COLLECTION
         (CONS-LIST ABSARGVALUE
          (|/PL-KERNEL-KB/NEGATE-COMPUTATION| ABSARGVALUE)))))
      (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
       KWD-SPECIALISTS-TERMINAL-FAILURE))))
   (CL:WHEN (CL:NOT (CL:EQ MAINARGVALUE NULL))
    (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
     (SELECT-TEST-RESULT
      (CL:OR
       (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST| MAINARGVALUE
        (%%VALUE COLLECTION))
       (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST| MAINARGVALUE
        (%%VALUE (%%REST COLLECTION))))
      CL:T FRAME)))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:SETQ ITERATOR (ALLOCATE-ITERATOR COLLECTION))
    (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
   (CL:IF
    (CL:AND (NEXT? ITERATOR)
     (BIND-ARGUMENT-TO-VALUE? MAINARG (%ITERATOR.VALUE ITERATOR) CL:T))
    KWD-SPECIALISTS-CONTINUING-SUCCESS
    KWD-SPECIALISTS-TERMINAL-FAILURE)))

;;; (DEFUN (ENUMERATIONS-CONTAINING-MEMBER LIST) ...)

(CL:DEFUN ENUMERATIONS-CONTAINING-MEMBER (SELF)
  (CL:LET* ((LIST (NEW-LIST)))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF
       SGT-SPECIALISTS-PL-KERNEL-KB-COLLECTIONOF CL:T)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ P (%ITERATOR.VALUE ITER-000))
     (CL:LET*
      ((SKOLEMLIST
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
         (CL:THE CL:FIXNUM
          (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS P)))))))
      (CL:WHEN (CL:NOT (EQL? SELF SKOLEMLIST))
       (PUSH LIST SKOLEMLIST)))))
   LIST))

;;; (DEFUN (/PL-KERNEL-KB/MEMBER-OF-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (ARGUMENTS (%PROPOSITION.ARGUMENTS PROPOSITION))
    (MEMBERARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
      0))
    (MEMBER (ARGUMENT-BOUND-TO MEMBERARG))
    (COLLECTIONARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
      1))
    (COLLECTION (ARGUMENT-BOUND-TO COLLECTIONARG))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-TRUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
      (CL:IF (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
       KWD-SPECIALISTS-CONTINUING-SUCCESS
       KWD-SPECIALISTS-FINAL-SUCCESS)))
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-FAIL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
      KWD-SPECIALISTS-FAILURE))
    (CL:T))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:COND
     ((CL:EQ COLLECTION NULL)
      (CL:WHEN (CL:EQ MEMBER NULL)
       (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
        KWD-SPECIALISTS-FAILURE))
      (CL:SETQ ITERATOR
       (ALLOCATE-ITERATOR (ENUMERATIONS-CONTAINING-MEMBER MEMBER))))
     (CL:T
      (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE COLLECTION)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-001
          SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION)
         (CL:PROGN
          (CL:LET*
           ((ISAPROP
             (CREATE-PROPOSITION SYM-SPECIALISTS-STELLA-ISA 1)))
           (CL:SETF (%PROPOSITION.OPERATOR ISAPROP)
            (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE COLLECTION))
           (CL:LET
            ((SELF
              (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS ISAPROP)))
             (VALUE MEMBERARG) (POSITION 0))
            (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
             (CL:TYPE CL:FIXNUM POSITION))
            (CL:SETF (CL:AREF SELF POSITION) VALUE))
           (CREATE-DOWN-FRAME FRAME ISAPROP)
           (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
            KWD-SPECIALISTS-MOVE-DOWN))))
        ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-LOGIC-DESCRIPTION)
         (CL:PROGN
          (CL:LET* ((TEST-VALUE-000 CL:NIL))
           (CL:SETQ TEST-VALUE-000 (CL:= (ARITY COLLECTION) 1))
           (CL:WHEN TEST-VALUE-000
            (CL:IF
             (CL:EQ
              (DYNAMIC-SLOT-VALUE
               (%DESCRIPTION.DYNAMIC-SLOTS COLLECTION)
               SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES NULL)
              NULL)
             (CL:SETQ TEST-VALUE-000 CL:T)
             (CL:LET* ((ALWAYS?-000 CL:T))
              (CL:LET*
               ((VAR NULL)
                (VECTOR-000
                 (DYNAMIC-SLOT-VALUE
                  (%DESCRIPTION.DYNAMIC-SLOTS COLLECTION)
                  SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES NULL))
                (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
               (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
               (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
                (CL:SETQ VAR
                 (CL:AREF
                  (CL:THE CL:SIMPLE-VECTOR
                   (%VECTOR.THE-ARRAY VECTOR-000))
                  INDEX-000))
                (CL:WHEN (CL:EQ (ARGUMENT-BOUND-TO VAR) NULL)
                 (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
                (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
              (CL:SETQ TEST-VALUE-000 ALWAYS?-000))))
           (CL:IF TEST-VALUE-000
            (CL:PROGN
             (CL:IF
              (OVERLAY-WITH-PATTERN-FRAME?
               (CREATE-DOWN-FRAME FRAME NULL) COLLECTION
               (VECTOR MEMBERARG))
              (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
               KWD-SPECIALISTS-MOVE-DOWN)
              (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
               KWD-SPECIALISTS-FAILURE)))
            (CL:PROGN
             (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
              KWD-SPECIALISTS-FAILURE))))))
        ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-STELLA-COLLECTION)
         (CL:PROGN
          (CL:IF (CL:EQ MEMBER NULL)
           (CL:SETQ ITERATOR
            (ALLOCATE-ITERATOR
             (ASSERTED-COLLECTION-MEMBERS COLLECTION CL:NIL)))
           (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
            (SELECT-TEST-RESULT
             (MEMBER-OF-COLLECTION? MEMBER COLLECTION) CL:NIL
             FRAME)))))
        ((SUBTYPE-OF? TEST-VALUE-001
          SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
         (CL:PROGN
          (CL:IF (CL:EQ MEMBER NULL)
           (CL:SETQ ITERATOR
            (ALLOCATE-ITERATOR
             (ASSERTED-COLLECTION-MEMBERS COLLECTION CL:NIL)))
           (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
            (SELECT-TEST-RESULT
             (MEMBER-OF-COLLECTION? MEMBER COLLECTION) CL:NIL
             FRAME)))))
        (CL:T
         (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
          KWD-SPECIALISTS-FAILURE))))))
    (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
   (CL:LOOP WHILE (NEXT? ITERATOR) DO
    (CL:IF (CL:EQ COLLECTION NULL)
     (CL:WHEN
      (BIND-VARIABLE-TO-VALUE? COLLECTIONARG
       (VALUE-OF (%ITERATOR.VALUE ITERATOR)) CL:T)
      (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
       KWD-SPECIALISTS-CONTINUING-SUCCESS))
     (CL:WHEN
      (BIND-VARIABLE-TO-VALUE? MEMBERARG
       (VALUE-OF (%ITERATOR.VALUE ITERATOR)) CL:T)
      (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
       KWD-SPECIALISTS-CONTINUING-SUCCESS))))
   KWD-SPECIALISTS-FAILURE))

;;; (DEFUN /PL-KERNEL-KB/MEMBER-OF-EVALUATOR ...)

(CL:DEFUN |/PL-KERNEL-KB/MEMBER-OF-EVALUATOR| (SELF)
  (CL:LET*
   ((MEMBER
     (VALUE-OF
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
       0)))
    (COLLECTION
     (VALUE-OF
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
       1))))
   (CL:WHEN (TRUE? SELF)
    (CL:WHEN
     (CL:AND (ISA? COLLECTION SGT-SPECIALISTS-LOGIC-DESCRIPTION)
      (ISA? MEMBER SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
      (CL:NOT (NAMED-DESCRIPTION? COLLECTION)))
     (INHERIT-UNNAMED-DESCRIPTION MEMBER COLLECTION
      (DEFAULT-TRUE? SELF)))
    (CL:WHEN (LOGICAL-COLLECTION? COLLECTION)
     (CL:LET* ((*REVERSEPOLARITY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
      (CL:WHEN
       (CL:AND (MEMBER-OF-COLLECTION? MEMBER COLLECTION)
        (CL:NOT (SKOLEM? MEMBER)))
       (SIGNAL-TRUTH-VALUE-CLASH SELF)))))))

;;; (DEFUN (/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (ARGUMENTS (%PROPOSITION.ARGUMENTS PROPOSITION))
    (MEMBERARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
      0))
    (MEMBER (ARGUMENT-BOUND-TO MEMBERARG))
    (COLLECTIONARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
      1))
    (COLLECTION (ARGUMENT-BOUND-TO COLLECTIONARG))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-TRUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
      (CL:IF (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
       KWD-SPECIALISTS-CONTINUING-SUCCESS
       KWD-SPECIALISTS-FINAL-SUCCESS)))
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-FAIL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
      KWD-SPECIALISTS-FAILURE))
    (CL:T))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:COND
     ((CL:NOT (CL:EQ COLLECTION NULL))
      (CL:COND
       ((CL:AND (CLASS? COLLECTION)
         (ISA? COLLECTION SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION))
        (CL:LET*
         ((ISAPROPOSITION
           (CREATE-PROPOSITION SYM-SPECIALISTS-STELLA-ISA 1)))
         (CL:SETF (%PROPOSITION.OPERATOR ISAPROPOSITION)
          (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE COLLECTION))
         (CL:LET
          ((SELF
            (%VECTOR.THE-ARRAY
             (%PROPOSITION.ARGUMENTS ISAPROPOSITION)))
           (VALUE MEMBERARG) (POSITION 0))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CREATE-SUBGOAL-FRAME FRAME ISAPROPOSITION NULL)
         (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
          KWD-SPECIALISTS-MOVE-DOWN)))
       ((CL:EQ MEMBER NULL)
        (CREATE-SUBGOAL-FRAME FRAME (%CONTROL-FRAME.PROPOSITION FRAME)
         KWD-SPECIALISTS-SCAN-COLLECTION)
        (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
         KWD-SPECIALISTS-MOVE-DOWN))
       (CL:T
        (CL:IF (MEMBER-OF-COLLECTION? MEMBER COLLECTION)
         (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
          KWD-SPECIALISTS-FINAL-SUCCESS)
         (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
          KWD-SPECIALISTS-FAILURE)))))
     ((CL:NOT (CL:EQ MEMBER NULL))
      (CL:SETQ ITERATOR (ALLOCATE-ITERATOR (ALL-TYPES MEMBER)))
      (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
       SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
     (CL:T
      (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
       KWD-SPECIALISTS-FAILURE))))
   (CL:WHEN (CL:NOT (CL:EQ ITERATOR NULL))
    (CL:LOOP WHILE (NEXT? ITERATOR) DO
     (CL:WHEN
      (BIND-VARIABLE-TO-VALUE? COLLECTIONARG (%ITERATOR.VALUE ITERATOR)
       CL:T)
      (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
       KWD-SPECIALISTS-CONTINUING-SUCCESS)))
    (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   KWD-SPECIALISTS-FAILURE))

;;; (DEFUN (/PL-KERNEL-KB/DIRECT-INSTANCE-OF-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/DIRECT-INSTANCE-OF-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (ARGUMENTS (%PROPOSITION.ARGUMENTS PROPOSITION))
    (MEMBERARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
      0))
    (MEMBER (ARGUMENT-BOUND-TO MEMBERARG))
    (COLLECTIONARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
      1))
    (COLLECTION (ARGUMENT-BOUND-TO COLLECTIONARG))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-TRUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/DIRECT-INSTANCE-OF-SPECIALIST|
      (CL:IF (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
       KWD-SPECIALISTS-CONTINUING-SUCCESS
       KWD-SPECIALISTS-FINAL-SUCCESS)))
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-FAIL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/DIRECT-INSTANCE-OF-SPECIALIST|
      KWD-SPECIALISTS-FAILURE))
    (CL:T))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:COND
     ((CL:AND (CL:NOT (CL:EQ COLLECTION NULL)) (CLASS? COLLECTION)
       (ISA? COLLECTION SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION))
      (CL:COND
       ((CL:EQ MEMBER NULL)
        (CL:SETQ ITERATOR (ALL-EXTENSION-MEMBERS COLLECTION)))
       ((LEVELLIZED-TEST-TYPE-ON-INSTANCE? ASSERTION-INFERENCE MEMBER
         (OBJECT-SURROGATE COLLECTION))
        (CL:RETURN-FROM |/PL-KERNEL-KB/DIRECT-INSTANCE-OF-SPECIALIST|
         KWD-SPECIALISTS-FINAL-SUCCESS))
       (CL:T
        (CL:RETURN-FROM |/PL-KERNEL-KB/DIRECT-INSTANCE-OF-SPECIALIST|
         KWD-SPECIALISTS-FAILURE))))
     ((CL:NOT (CL:EQ MEMBER NULL))
      (CL:SETQ ITERATOR (ALLOCATE-ITERATOR (ALL-DIRECT-TYPES MEMBER))))
     (CL:T
      (CL:RETURN-FROM |/PL-KERNEL-KB/DIRECT-INSTANCE-OF-SPECIALIST|
       KWD-SPECIALISTS-FAILURE)))
    (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
   (CL:WHEN (CL:NOT (CL:EQ ITERATOR NULL))
    (CL:LOOP WHILE (NEXT? ITERATOR) DO
     (CL:LET* ((VALUE (%ITERATOR.VALUE ITERATOR)))
      (CL:COND
       ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE VALUE)
         SGT-SPECIALISTS-LOGIC-PROPOSITION)
        (CL:PROGN
         (CL:WHEN
          (BIND-VARIABLE-TO-VALUE? MEMBERARG
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS VALUE)))
            0)
           CL:T)
          (CL:RETURN-FROM |/PL-KERNEL-KB/DIRECT-INSTANCE-OF-SPECIALIST|
           KWD-SPECIALISTS-CONTINUING-SUCCESS))))
       (CL:T
        (CL:WHEN (BIND-VARIABLE-TO-VALUE? COLLECTIONARG VALUE CL:T)
         (CL:RETURN-FROM |/PL-KERNEL-KB/DIRECT-INSTANCE-OF-SPECIALIST|
          KWD-SPECIALISTS-CONTINUING-SUCCESS))))))
    (CL:RETURN-FROM |/PL-KERNEL-KB/DIRECT-INSTANCE-OF-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   KWD-SPECIALISTS-FAILURE))

;;; (DEFUN (TEST-DISJOINT-TERMS? BOOLEAN) ...)

(CL:DEFUN TEST-DISJOINT-TERMS? (TERM1 TERM2)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM1)
     SGT-SPECIALISTS-LOGIC-DESCRIPTION)
    (CL:PROGN
     (CL:COND
      ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM2)
        SGT-SPECIALISTS-LOGIC-DESCRIPTION)
       (CL:PROGN
        (CL:IF (CL:EQ (CURRENT-INFERENCE-LEVEL) REFUTATION-INFERENCE)
         (EXPENSIVE-DISJOINT-TERMS? TERM1 TERM2)
         (DISJOINT-TERMS? TERM1 TERM2))))
      (CL:T CL:NIL))))
   (CL:T CL:NIL)))

;;; (DEFUN (/PL-KERNEL-KB/SUBSET-OF-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (SUBCOLLECTIONARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (SUPERCOLLECTIONARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (SUBCOLLECTION
     (EQUIVALENT-VALUE-OF (ARGUMENT-BOUND-TO SUBCOLLECTIONARG)))
    (SUPERCOLLECTION
     (EQUIVALENT-VALUE-OF (ARGUMENT-BOUND-TO SUPERCOLLECTIONARG)))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:COND
     ((CL:AND (CL:NOT (CL:EQ SUBCOLLECTION NULL))
       (CL:NOT (CL:EQ SUPERCOLLECTION NULL)))
      (CL:COND
       ((CL:AND (ISA? SUBCOLLECTION SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
         (ISA? SUPERCOLLECTION SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
         (COLLECTION-IMPLIES-COLLECTION? SUBCOLLECTION
          SUPERCOLLECTION))
        (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|
         (SELECT-TEST-RESULT CL:T CL:T FRAME)))
       ((TEST-DISJOINT-TERMS? SUBCOLLECTION SUPERCOLLECTION)
        (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|
         (SELECT-TEST-RESULT CL:NIL CL:T FRAME)))
       (CL:T
        (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|
         KWD-SPECIALISTS-FAILURE))))
     ((CL:NOT (CL:EQ SUBCOLLECTION NULL))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SUBCOLLECTION)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000
          SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
         (CL:PROGN
          (CL:SETQ ITERATOR
           (CONCATENATE (ALLOCATE-ITERATOR (CONS SUBCOLLECTION NIL))
            (ALL-SUPERCOLLECTIONS SUBCOLLECTION)))))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-COLLECTION)
         (CL:PROGN
          (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|
           KWD-SPECIALISTS-FAILURE)))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
           TEST-VALUE-000 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
     ((CL:NOT (CL:EQ SUPERCOLLECTION NULL))
      (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SUPERCOLLECTION)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-001
          SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
         (CL:PROGN
          (CL:SETQ ITERATOR
           (CONCATENATE (ALLOCATE-ITERATOR (CONS SUPERCOLLECTION NIL))
            (ALL-SUBCOLLECTIONS SUPERCOLLECTION)))))
        ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-STELLA-COLLECTION)
         (CL:PROGN
          (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|
           KWD-SPECIALISTS-FAILURE)))
        (CL:T
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
           TEST-VALUE-001 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))
     (CL:T
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       EOL " Found 'subset-of' goal with two unbound arguments." EOL
       "   Possibly the query needs rewriting." EOL EOL)
      (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|
       KWD-SPECIALISTS-FAILURE)))
    (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
   (CL:LOOP WHILE (NEXT? ITERATOR) DO
    (CL:LET* ((VALUE (VALUE-OF (%ITERATOR.VALUE ITERATOR))))
     (CL:WHEN
      (CL:AND CL:T
       (CL:IF (CL:NOT (CL:EQ SUBCOLLECTION NULL))
        (BIND-VARIABLE-TO-VALUE? SUPERCOLLECTIONARG VALUE CL:T)
        (BIND-VARIABLE-TO-VALUE? SUBCOLLECTIONARG VALUE CL:T)))
      (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|
       KWD-SPECIALISTS-CONTINUING-SUCCESS))))
   KWD-SPECIALISTS-FAILURE))

;;; (DEFUN (/PL-KERNEL-KB/HOLDS-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/HOLDS-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((HOLDSPROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (HOLDSARGUMENTS (%PROPOSITION.ARGUMENTS HOLDSPROPOSITION))
    (HOLDSARITY (CL:1- (LENGTH HOLDSARGUMENTS)))
    (DESCRIPTION
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY HOLDSARGUMENTS))
       0))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM HOLDSARITY))
   (CL:COND
    ((CL:NOT (CL:EQ DESCRIPTION NULL))
     (CL:COND
      ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-TRUE)
       (CL:RETURN-FROM |/PL-KERNEL-KB/HOLDS-SPECIALIST|
        (CL:IF (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
         KWD-SPECIALISTS-CONTINUING-SUCCESS
         KWD-SPECIALISTS-FINAL-SUCCESS)))
      ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-FAIL)
       (CL:RETURN-FROM |/PL-KERNEL-KB/HOLDS-SPECIALIST|
        KWD-SPECIALISTS-FAILURE))
      ((CL:EQ LASTMOVE KWD-SPECIALISTS-DOWN))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`" LASTMOVE
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE DESCRIPTION)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION)
        (CL:PROGN
         (CL:LET*
          ((ARGCOUNTMINUS1 (CL:1- (LENGTH HOLDSARGUMENTS)))
           (KIND SYM-SPECIALISTS-STELLA-PREDICATE)
           (RELATIONPROPOSITION NULL)
           (RELATIONREF
            (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE DESCRIPTION)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM ARGCOUNTMINUS1))
          (CL:COND
           ((CLASS-DESCRIPTION? DESCRIPTION)
            (CL:SETQ KIND SYM-SPECIALISTS-STELLA-ISA))
           ((FUNCTION-DESCRIPTION? DESCRIPTION)
            (CL:SETQ KIND SYM-SPECIALISTS-STELLA-FUNCTION)))
          (CL:SETQ RELATIONPROPOSITION
           (CREATE-PROPOSITION KIND ARGCOUNTMINUS1))
          (CL:SETF (%PROPOSITION.OPERATOR RELATIONPROPOSITION)
           RELATIONREF)
          (CL:LET*
           ((I NULL-INTEGER) (ITER-000 0)
            (UPPER-BOUND-000 (CL:1- ARGCOUNTMINUS1)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
           (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
            (CL:SETQ I ITER-000)
            (CL:LET
             ((SELF
               (%VECTOR.THE-ARRAY
                (%PROPOSITION.ARGUMENTS RELATIONPROPOSITION)))
              (VALUE
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR
                 (%VECTOR.THE-ARRAY HOLDSARGUMENTS))
                (CL:THE CL:FIXNUM (CL:1+ I))))
              (POSITION I))
             (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
              (CL:TYPE CL:FIXNUM POSITION))
             (CL:SETF (CL:AREF SELF POSITION) VALUE))
            (CL:SETQ ITER-000 (CL:1+ ITER-000))))
          (CREATE-SUBGOAL-FRAME FRAME RELATIONPROPOSITION NULL)
          (CL:RETURN-FROM |/PL-KERNEL-KB/HOLDS-SPECIALIST|
           KWD-SPECIALISTS-MOVE-DOWN))))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-DESCRIPTION)
        (CL:PROGN
         (CL:LET*
          ((ARGCOUNTMINUS1 (CL:1- (LENGTH HOLDSARGUMENTS)))
           (DUMMYPROPOSITION
            (CREATE-PROPOSITION SYM-SPECIALISTS-STELLA-DUMMY
             ARGCOUNTMINUS1))
           (SUBGOALFRAME
            (CREATE-SUBGOAL-FRAME FRAME DUMMYPROPOSITION
             KWD-SPECIALISTS-FULL-SUBQUERY)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM ARGCOUNTMINUS1))
          (CL:LET*
           ((I NULL-INTEGER) (ITER-001 0)
            (UPPER-BOUND-001 (CL:1- ARGCOUNTMINUS1)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
           (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO
            (CL:SETQ I ITER-001)
            (CL:LET
             ((SELF
               (%VECTOR.THE-ARRAY
                (%PROPOSITION.ARGUMENTS DUMMYPROPOSITION)))
              (VALUE
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR
                 (%VECTOR.THE-ARRAY HOLDSARGUMENTS))
                (CL:THE CL:FIXNUM (CL:1+ I))))
              (POSITION I))
             (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
              (CL:TYPE CL:FIXNUM POSITION))
             (CL:SETF (CL:AREF SELF POSITION) VALUE))
            (CL:SETQ ITER-001 (CL:1+ ITER-001))))
          (SET-DYNAMIC-SLOT-VALUE
           (%CONTROL-FRAME.DYNAMIC-SLOTS SUBGOALFRAME)
           SYM-SPECIALISTS-LOGIC-DESCRIPTION DESCRIPTION NULL)
          (CL:RETURN-FROM |/PL-KERNEL-KB/HOLDS-SPECIALIST|
           KWD-SPECIALISTS-MOVE-DOWN))))
       (CL:T))))
    (CL:T
     (CL:LET*
      ((ITERATOR
        (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
         SYM-SPECIALISTS-STELLA-ITERATOR NULL))
       (BACKLINKEDARG NULL) (BACKLINKEDARGPOSITION -1)
       (NOMATCHES? CL:NIL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM BACKLINKEDARGPOSITION))
      (CL:SETQ NOMATCHES? NOMATCHES?)
      (CL:WHEN (CL:EQ ITERATOR NULL)
       (CL:MULTIPLE-VALUE-SETQ (BACKLINKEDARG NOMATCHES?)
        (SELECT-ARGUMENT-WITH-BACKLINKS HOLDSPROPOSITION))
       (CL:WHEN (CL:NOT (CL:EQ BACKLINKEDARG NULL))
        (CL:LET* ((VALUE-000 NULL-INTEGER))
         (CL:DECLARE (CL:TYPE CL:FIXNUM VALUE-000))
         (CL:LET*
          ((I NULL-INTEGER) (ITER-002 (INTERVAL -1 NULL-INTEGER))
           (ARG NULL) (VECTOR-000 HOLDSARGUMENTS) (INDEX-000 0)
           (LENGTH-000 (LENGTH VECTOR-000)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM I INDEX-000 LENGTH-000))
          (CL:LOOP WHILE
           (CL:AND (NEXT? ITER-002) (CL:< INDEX-000 LENGTH-000)) DO
           (CL:SETQ I (%INTEGER-INTERVAL-ITERATOR.VALUE ITER-002))
           (CL:SETQ ARG
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
             INDEX-000))
           (CL:WHEN
            (CL:AND (CL:>= I 0)
             (EQL? BACKLINKEDARG (ARGUMENT-BOUND-TO ARG)))
            (CL:SETQ VALUE-000 I) (CL:RETURN))
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
         (CL:SETQ BACKLINKEDARGPOSITION VALUE-000))
        (CL:LET* ((VALUE-001 NIL))
         (CL:LET*
          ((PROP NULL)
           (ITER-003
            (ALLOCATE-ITERATOR
             (UNFILTERED-DEPENDENT-PROPOSITIONS BACKLINKEDARG NULL)))
           (COLLECT-000 NULL))
          (CL:LOOP WHILE (NEXT? ITER-003) DO
           (CL:SETQ PROP (%ITERATOR.VALUE ITER-003))
           (CL:WHEN
            (CL:AND
             (CL:OR
              (CL:EQ (%PROPOSITION.KIND PROP) KWD-SPECIALISTS-FUNCTION)
              (CL:EQ (%PROPOSITION.KIND PROP)
               KWD-SPECIALISTS-PREDICATE)
              (CL:EQ (%PROPOSITION.KIND PROP) KWD-SPECIALISTS-ISA))
             (CL:= (LENGTH (%PROPOSITION.ARGUMENTS PROP)) HOLDSARITY)
             (CL:AND (CL:NOT (DELETED? PROP))
              (CL:IF *REVERSEPOLARITY?* (FALSE? PROP)
               (CL:OR (TRUE? PROP)
                (FUNCTION-WITH-DEFINED-VALUE? PROP))))
             (CL:=
              (POSITION (%PROPOSITION.ARGUMENTS PROP) BACKLINKEDARG 0)
              BACKLINKEDARGPOSITION))
            (CL:IF (CL:EQ COLLECT-000 NULL)
             (CL:PROGN (CL:SETQ COLLECT-000 (CONS PROP NIL))
              (CL:IF (CL:EQ VALUE-001 NIL)
               (CL:SETQ VALUE-001 COLLECT-000)
               (ADD-CONS-TO-END-OF-CONS-LIST VALUE-001 COLLECT-000)))
             (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS PROP NIL))
              (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
         (CL:SETQ ITERATOR (ALLOCATE-ITERATOR VALUE-001))))
       (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
        SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
      (CL:WHEN (CL:NOT (CL:EQ ITERATOR NULL))
       (CL:LET*
        ((PATTERNRECORD
          (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))
         (UBSTACKOFFSET
          (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
        (CL:LET* ((PROP NULL) (ITER-004 ITERATOR))
         (CL:LOOP WHILE (NEXT? ITER-004) DO
          (CL:SETQ PROP (%ITERATOR.VALUE ITER-004))
          (CL:TAGBODY
           (CL:WHEN
            (CL:NOT
             (BIND-VARIABLE-TO-VALUE?
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (%VECTOR.THE-ARRAY HOLDSARGUMENTS))
               0)
              (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROP)) CL:T))
            (CL:GO :CONTINUE))
           (CL:LET* ((ALWAYS?-000 CL:T))
            (CL:LET*
             ((ARG NULL) (VECTOR-001 HOLDSARGUMENTS) (INDEX-001 0)
              (LENGTH-001 (LENGTH VECTOR-001)) (I NULL-INTEGER)
              (ITER-005 -1))
             (CL:DECLARE
              (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 I ITER-005))
             (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
              (CL:SETQ ARG
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR
                 (%VECTOR.THE-ARRAY VECTOR-001))
                INDEX-001))
              (CL:SETQ I ITER-005)
              (CL:WHEN (CL:>= I 0)
               (CL:WHEN
                (CL:NOT
                 (BIND-ARGUMENT-TO-VALUE? ARG
                  (CL:AREF
                   (CL:THE CL:SIMPLE-VECTOR
                    (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROP)))
                   I)
                  CL:T))
                (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN)))
              (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
              (CL:SETQ ITER-005 (CL:1+ ITER-005))))
            (CL:WHEN ALWAYS?-000
             (CL:RETURN-FROM |/PL-KERNEL-KB/HOLDS-SPECIALIST|
              KWD-SPECIALISTS-CONTINUING-SUCCESS)))
           (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD
            (CL:1+ UBSTACKOFFSET))
           :CONTINUE))))))))
   KWD-SPECIALISTS-FAILURE))

;;; (DEFUN (/PL-KERNEL-KB/TOTAL-VALUE-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/TOTAL-VALUE-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((VALUEPROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (VALUEARGUMENTS (%PROPOSITION.ARGUMENTS VALUEPROPOSITION))
    (DESCRIPTION
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VALUEARGUMENTS))
       0))))
   (CL:COND
    ((CL:NOT (CL:EQ DESCRIPTION NULL))
     (CL:COND
      ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-TRUE)
       (CL:WHEN
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
          SYM-SPECIALISTS-STELLA-ITERATOR NULL)
         NULL)
        (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
         SYM-SPECIALISTS-STELLA-ITERATOR EMPTY-PROPOSITIONS-ITERATOR
         NULL))
       (CL:IF (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
        KWD-SPECIALISTS-CONTINUING-SUCCESS
        KWD-SPECIALISTS-FINAL-SUCCESS))
      ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-FAIL)
       (CL:COND
        ((CL:OR
          (CL:NOT
           (CL:EQ
            (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
             SYM-SPECIALISTS-STELLA-ITERATOR NULL)
            NULL))
          (%CONTROL-FRAME.REVERSE-POLARITY? FRAME))
         KWD-SPECIALISTS-FAILURE)
        ((CL:AND
          (ISA? DESCRIPTION SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION)
          (FUNCTION-DESCRIPTION? DESCRIPTION)
          (ALL-KEY-ARGUMENTS-BOUND? VALUEPROPOSITION)
          (CL:EQ (ARGUMENT-BOUND-TO (LAST VALUEARGUMENTS)) NULL))
         (CL:LET* ((VALUE-000 NIL))
          (CL:LET*
           ((I NULL-INTEGER) (ITER-000 1)
            (UPPER-BOUND-000 (CL:- (LENGTH VALUEARGUMENTS) 2))
            (COLLECT-000 NULL))
           (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
           (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
            (CL:SETQ I ITER-000)
            (CL:IF (CL:EQ COLLECT-000 NULL)
             (CL:PROGN
              (CL:SETQ COLLECT-000
               (CONS
                (ARGUMENT-BOUND-TO
                 (CL:AREF
                  (CL:THE CL:SIMPLE-VECTOR
                   (%VECTOR.THE-ARRAY VALUEARGUMENTS))
                  I))
                NIL))
              (CL:IF (CL:EQ VALUE-000 NIL)
               (CL:SETQ VALUE-000 COLLECT-000)
               (ADD-CONS-TO-END-OF-CONS-LIST VALUE-000 COLLECT-000)))
             (CL:PROGN
              (CL:SETF (%%REST COLLECT-000)
               (CONS
                (ARGUMENT-BOUND-TO
                 (CL:AREF
                  (CL:THE CL:SIMPLE-VECTOR
                   (%VECTOR.THE-ARRAY VALUEARGUMENTS))
                  I))
                NIL))
              (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
            (CL:SETQ ITER-000 (CL:1+ ITER-000))))
          (CL:LET*
           ((FUNCTIONPROP
             (FIND-OR-CREATE-FUNCTION-PROPOSITION
              (OBJECT-SURROGATE DESCRIPTION) VALUE-000)))
           (BIND-VARIABLE-TO-VALUE?
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%VECTOR.THE-ARRAY
               (%PROPOSITION.ARGUMENTS VALUEPROPOSITION)))
             (CL:THE CL:FIXNUM
              (CL:1-
               (LENGTH (%PROPOSITION.ARGUMENTS VALUEPROPOSITION)))))
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%VECTOR.THE-ARRAY
               (%PROPOSITION.ARGUMENTS FUNCTIONPROP)))
             (CL:THE CL:FIXNUM
              (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS FUNCTIONPROP)))))
            CL:T)
           KWD-SPECIALISTS-FINAL-SUCCESS)))
        (CL:T KWD-SPECIALISTS-FAILURE)))
      ((CL:EQ LASTMOVE KWD-SPECIALISTS-DOWN)
       (|/PL-KERNEL-KB/HOLDS-SPECIALIST| FRAME LASTMOVE))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`" LASTMOVE
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (CL:T (|/PL-KERNEL-KB/HOLDS-SPECIALIST| FRAME LASTMOVE)))))

;;; (DEFUN (/PL-KERNEL-KB/PROPOSITION-RELATION-COMPUTATION OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/PROPOSITION-RELATION-COMPUTATION| (P)
  (CL:WHEN (FUNCTION-OUTPUT-SKOLEM? P)
   (CL:SETQ P (%SKOLEM.DEFINING-PROPOSITION P)))
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE P)
     SGT-SPECIALISTS-LOGIC-PROPOSITION)
    (CL:PROGN
     (CL:LET* ((OPERATOR (%PROPOSITION.OPERATOR P)))
      (CL:COND
       ((SUBTYPE-OF-SURROGATE? (SAFE-PRIMARY-TYPE OPERATOR))
        (CL:PROGN
         (CL:RETURN-FROM
          |/PL-KERNEL-KB/PROPOSITION-RELATION-COMPUTATION|
          (%SURROGATE.SURROGATE-VALUE OPERATOR))))
       (CL:T)))))
   (CL:T))
  NULL)

;;; (DEFUN (/PL-KERNEL-KB/PROPOSITION-ARGUMENT-COMPUTATION OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/PROPOSITION-ARGUMENT-COMPUTATION| (P I)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE P)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:LET* ((ARGUMENTS (%PROPOSITION.ARGUMENTS P)))
       (CL:WHEN
        (CL:AND (CL:>= (%INTEGER-WRAPPER.WRAPPER-VALUE I) 0)
         (CL:< (%INTEGER-WRAPPER.WRAPPER-VALUE I) (LENGTH ARGUMENTS)))
        (CL:RETURN-FROM
         |/PL-KERNEL-KB/PROPOSITION-ARGUMENT-COMPUTATION|
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
          (CL:THE CL:FIXNUM (%INTEGER-WRAPPER.WRAPPER-VALUE I))))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:WHEN (FUNCTION-OUTPUT-SKOLEM? P)
       (CL:LET*
        ((PROP (%SKOLEM.DEFINING-PROPOSITION P))
         (ARGUMENTS (%PROPOSITION.ARGUMENTS PROP)))
        (CL:WHEN
         (CL:AND (CL:>= (%INTEGER-WRAPPER.WRAPPER-VALUE I) 0)
          (CL:< (%INTEGER-WRAPPER.WRAPPER-VALUE I)
           (CL:1- (LENGTH ARGUMENTS))))
         (CL:RETURN-FROM
          |/PL-KERNEL-KB/PROPOSITION-ARGUMENT-COMPUTATION|
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
           (CL:THE CL:FIXNUM (%INTEGER-WRAPPER.WRAPPER-VALUE I)))))))))
    (CL:T)))
  NULL)

;;; (DEFUN (/PL-KERNEL-KB/PROPOSITION-ARGUMENTS-COMPUTATION SKOLEM) ...)

(CL:DEFUN |/PL-KERNEL-KB/PROPOSITION-ARGUMENTS-COMPUTATION| (P)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE P)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:RETURN-FROM |/PL-KERNEL-KB/PROPOSITION-ARGUMENTS-COMPUTATION|
       (CREATE-LOGICAL-LIST (LISTIFY (%PROPOSITION.ARGUMENTS P))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:WHEN (FUNCTION-OUTPUT-SKOLEM? P)
       (CL:RETURN-FROM
        |/PL-KERNEL-KB/PROPOSITION-ARGUMENTS-COMPUTATION|
        (CREATE-LOGICAL-LIST
         (LISTIFY
          (BUT-LAST
           (%PROPOSITION.ARGUMENTS
            (%SKOLEM.DEFINING-PROPOSITION P)))))))))
    (CL:T)))
  NULL)

;;; (DEFUN (/PL-KERNEL-KB/PROPOSITION-ARITY-COMPUTATION INTEGER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/PROPOSITION-ARITY-COMPUTATION| (P)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE P)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:RETURN-FROM |/PL-KERNEL-KB/PROPOSITION-ARITY-COMPUTATION|
       (WRAP-INTEGER (LENGTH (%PROPOSITION.ARGUMENTS P))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:WHEN (FUNCTION-OUTPUT-SKOLEM? P)
       (CL:RETURN-FROM |/PL-KERNEL-KB/PROPOSITION-ARITY-COMPUTATION|
        (WRAP-INTEGER
         (CL:1-
          (LENGTH
           (%PROPOSITION.ARGUMENTS
            (%SKOLEM.DEFINING-PROPOSITION P)))))))))
    (CL:T)))
  NULL)

;;; (DEFUN (/PL-KERNEL-KB/CUT-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/CUT-SPECIALIST| (FRAME LASTMOVE)
  (CL:SETQ LASTMOVE LASTMOVE)
  (CL:COND
   ((CL:EQ
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL)
     NULL)
    (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-STELLA-ITERATOR EMPTY-PROPOSITIONS-ITERATOR NULL)
    KWD-SPECIALISTS-CONTINUING-SUCCESS)
   (CL:T
    (CL:LET* ((PARENTFRAME (%CONTROL-FRAME.UP FRAME)))
     (CL:WHEN
      (CL:OR (CL:EQ PARENTFRAME NULL)
       (CL:NOT
        (CL:EQ (%CONTROL-FRAME.STATE PARENTFRAME)
         KWD-SPECIALISTS-AND)))
      (CL:RETURN-FROM |/PL-KERNEL-KB/CUT-SPECIALIST|
       KWD-SPECIALISTS-TERMINAL-FAILURE))
     (CL:LET*
      ((CONJUNCTS
        (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS PARENTFRAME)
         SYM-SPECIALISTS-STELLA-ARGUMENTS NULL)))
      (CL:WHEN (CL:NOT (CL:EQ CONJUNCTS NULL))
       (CL:LET*
        ((CONJUNCT NULL) (VECTOR-000 CONJUNCTS) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ CONJUNCT
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:IF (CL:EQ CONJUNCT FRAME) (CL:RETURN)
          (POP-CONTROL-FRAME CONJUNCT))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))))
     KWD-SPECIALISTS-TERMINAL-FAILURE))))

;;; (DEFUN (/PL-KERNEL-KB/BOUND-VARIABLES-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/BOUND-VARIABLES-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET* ((ALWAYS?-000 CL:T))
   (CL:LET*
    ((ARG NULL)
     (VECTOR-000
      (%PROPOSITION.ARGUMENTS (%CONTROL-FRAME.PROPOSITION FRAME)))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:WHEN (CL:EQ (ARGUMENT-BOUND-TO ARG) NULL)
      (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET* ((ALLBOUND? ALWAYS?-000)) (CL:SETQ LASTMOVE LASTMOVE)
    (SELECT-TEST-RESULT ALLBOUND? CL:T FRAME))))

(CL:DEFUN NEW-FORK-PROOF-ADJUNCT ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-FORK-PROOF-ADJUNCT))
   (CL:SETF (%FORK-PROOF-ADJUNCT.DOWN-FRAME SELF) NULL)
   (CL:SETF (%FORK-PROOF-ADJUNCT.CONDITION-JUSTIFICATION SELF) NULL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FORK-PROOF-ADJUNCT))
  SGT-SPECIALISTS-LOGIC-FORK-PROOF-ADJUNCT)

(CL:DEFUN ACCESS-FORK-PROOF-ADJUNCT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-CONDITION-JUSTIFICATION)
    (CL:IF SETVALUE?
     (CL:SETF (%FORK-PROOF-ADJUNCT.CONDITION-JUSTIFICATION SELF) VALUE)
     (CL:SETQ VALUE
      (%FORK-PROOF-ADJUNCT.CONDITION-JUSTIFICATION SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-DOWN-FRAME)
    (CL:IF SETVALUE?
     (CL:SETF (%FORK-PROOF-ADJUNCT.DOWN-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%FORK-PROOF-ADJUNCT.DOWN-FRAME SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (/PL-KERNEL-KB/FORK-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/FORK-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((RECORDJUSTIFICATIONS? *RECORD-JUSTIFICATIONS?*)
    (ADJUNCT
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT NULL)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-DOWN)
     (CL:WHEN RECORDJUSTIFICATIONS?
      (CL:WHEN (CL:EQ ADJUNCT NULL)
       (CL:SETQ ADJUNCT (NEW-FORK-PROOF-ADJUNCT))
       (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
        SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT ADJUNCT NULL))
      (CL:SETF (%CONTROL-FRAME.DOWN FRAME)
       (%FORK-PROOF-ADJUNCT.DOWN-FRAME ADJUNCT)))
     KWD-SPECIALISTS-MOVE-DOWN)
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-TRUE)
     (CL:WHEN (CL:> (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME) 0)
      (CL:WHEN RECORDJUSTIFICATIONS?
       (CL:SETF (%FORK-PROOF-ADJUNCT.DOWN-FRAME ADJUNCT)
        (%CONTROL-FRAME.DOWN FRAME))
       (PROPAGATE-FRAME-TRUTH-VALUE (%CONTROL-FRAME.RESULT FRAME)
        FRAME)
       (CL:LET* ((SELF-001 (NEW-JUSTIFICATION)))
        (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-001)
         (CL:IF
          (CL:EQ
           (%JUSTIFICATION.INFERENCE-RULE
            (%FORK-PROOF-ADJUNCT.CONDITION-JUSTIFICATION ADJUNCT))
           KWD-SPECIALISTS-FAIL-INTRODUCTION)
          KWD-SPECIALISTS-FORK-ELSE KWD-SPECIALISTS-FORK-THEN))
        (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-001)
         (CONS (%FORK-PROOF-ADJUNCT.CONDITION-JUSTIFICATION ADJUNCT)
          (CONS
           (DYNAMIC-SLOT-VALUE
            (%CONTROL-FRAME.DYNAMIC-SLOTS
             (%CONTROL-FRAME.RESULT FRAME))
            SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)
           NIL)))
        (RECORD-GOAL-JUSTIFICATION FRAME SELF-001)))
      (CL:COND
       ((CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
        (CL:WHEN RECORDJUSTIFICATIONS?
         (CL:SETF (%CONTROL-FRAME.DOWN FRAME) NULL))
        (CL:RETURN-FROM |/PL-KERNEL-KB/FORK-SPECIALIST|
         KWD-SPECIALISTS-CONTINUING-SUCCESS))
       (CL:T
        (CL:RETURN-FROM |/PL-KERNEL-KB/FORK-SPECIALIST|
         KWD-SPECIALISTS-FINAL-SUCCESS))))
     (CL:WHEN RECORDJUSTIFICATIONS?
      (CL:SETF (%FORK-PROOF-ADJUNCT.CONDITION-JUSTIFICATION ADJUNCT)
       (DYNAMIC-SLOT-VALUE
        (%CONTROL-FRAME.DYNAMIC-SLOTS (%CONTROL-FRAME.RESULT FRAME))
        SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)))
     (CL:SETF (%CONTROL-FRAME.DOWN FRAME) NULL)
     (CL:SETF (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME) 1)
     KWD-SPECIALISTS-MOVE-DOWN)
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-FAIL)
     (CL:WHEN (CL:> (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME) 0)
      (CL:RETURN-FROM |/PL-KERNEL-KB/FORK-SPECIALIST|
       KWD-SPECIALISTS-FAILURE))
     (CL:WHEN RECORDJUSTIFICATIONS?
      (RECORD-FAIL-JUSTIFICATION (%CONTROL-FRAME.RESULT FRAME)
       KWD-SPECIALISTS-UP-FAIL)
      (CL:SETF (%FORK-PROOF-ADJUNCT.CONDITION-JUSTIFICATION ADJUNCT)
       (DYNAMIC-SLOT-VALUE
        (%CONTROL-FRAME.DYNAMIC-SLOTS (%CONTROL-FRAME.RESULT FRAME))
        SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)))
     (CL:SETF (%CONTROL-FRAME.DOWN FRAME) NULL)
     (CL:SETF (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME) 2)
     KWD-SPECIALISTS-MOVE-DOWN)
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" LASTMOVE "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (COMPUTE-SUBQUERY-OPTIONS PROPOSITION PROPERTY-LIST) ...)

(CL:DEFUN COMPUTE-SUBQUERY-OPTIONS (FRAME)
  (CL:LET*
   ((ARGUMENTS
     (%PROPOSITION.ARGUMENTS (%CONTROL-FRAME.PROPOSITION FRAME)))
    (ARG NULL) (PROPARG NULL)
    (LASTOPTIONARGINDEX (CL:1- (LENGTH ARGUMENTS))) (CURSOR 1)
    (KEY NULL) (VALUE NULL) (SUBQUERYOPTIONS (NEW-PROPERTY-LIST))
    (PARENTOPTIONS (%QUERY-ITERATOR.OPTIONS *QUERYITERATOR*)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LASTOPTIONARGINDEX CURSOR))
   (CL:WHEN (CL:< LASTOPTIONARGINDEX 0)
    (CL:RETURN-FROM COMPUTE-SUBQUERY-OPTIONS (CL:VALUES NULL NULL)))
   (CL:SETQ ARG
    (ARGUMENT-BOUND-TO
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
      0)))
   (CL:COND
    ((CL:AND (CL:NOT (CL:EQ ARG NULL))
      (ISA? ARG SGT-SPECIALISTS-LOGIC-PROPOSITION))
     (CL:SETQ PROPARG ARG))
    ((CL:>= LASTOPTIONARGINDEX 1) (CL:SETQ CURSOR 0)
     (CL:SETQ KEY KWD-SPECIALISTS-HOW-MANY) (CL:SETQ VALUE ARG)
     (CL:SETQ ARG
      (ARGUMENT-BOUND-TO
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
        1)))
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ ARG NULL))
       (ISA? ARG SGT-SPECIALISTS-LOGIC-PROPOSITION))
      (CL:SETQ PROPARG ARG)
      (CL:RETURN-FROM COMPUTE-SUBQUERY-OPTIONS (CL:VALUES NULL NULL))))
    (CL:T
     (CL:RETURN-FROM COMPUTE-SUBQUERY-OPTIONS (CL:VALUES NULL NULL))))
   (CL:WHEN
    (CL:LET ((X (CL:- LASTOPTIONARGINDEX CURSOR)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM X)) (CL:NOT (CL:LOGBITP 0 X)))
    (CL:SETQ LASTOPTIONARGINDEX (CL:1- LASTOPTIONARGINDEX)))
   (CL:LOOP WHILE (CL:< CURSOR LASTOPTIONARGINDEX) DO
    (CL:COND ((CL:= CURSOR 0))
     (CL:T
      (CL:SETQ KEY
       (GENERATE-TERM
        (ARGUMENT-BOUND-TO
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
          CURSOR))))
      (CL:SETQ VALUE
       (GENERATE-TERM
        (ARGUMENT-BOUND-TO
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
          (CL:THE CL:FIXNUM (CL:1+ CURSOR))))))))
    (CL:SETQ CURSOR (CL:+ CURSOR 2))
    (CL:WHEN (CL:OR (CL:EQ KEY NULL) (CL:EQ VALUE NULL))
     (CL:RETURN-FROM COMPUTE-SUBQUERY-OPTIONS (CL:VALUES NULL NULL)))
    (CL:COND
     ((CL:EQ KEY KWD-SPECIALISTS-INHERIT)
      (CL:WHEN
       (CL:OR (CL:EQ VALUE KWD-SPECIALISTS-ALL)
        (CL:EQ VALUE KWD-SPECIALISTS-CURRENT))
       (CL:LET*
        ((PKEY NULL) (PVALUE NULL)
         (ITER-000 (%PROPERTY-LIST.THE-PLIST PARENTOPTIONS)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ PKEY (%%VALUE ITER-000))
         (CL:SETQ PVALUE (%%VALUE (%%REST ITER-000)))
         (INSERT-AT SUBQUERYOPTIONS PKEY PVALUE)
         (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))))
     ((CL:OR (CL:EQ VALUE KWD-SPECIALISTS-INHERIT)
       (CL:EQ VALUE KWD-SPECIALISTS-CURRENT))
      (CL:WHEN
       (CL:NOT (CL:EQ (LOOKUP-QUERY-OPTION PARENTOPTIONS KEY) NULL))
       (INSERT-AT SUBQUERYOPTIONS KEY
        (LOOKUP-QUERY-OPTION PARENTOPTIONS KEY))))
     (CL:T (INSERT-AT SUBQUERYOPTIONS KEY VALUE))))
   (CL:VALUES PROPARG SUBQUERYOPTIONS)))

(CL:DEFMETHOD QUERY-SPECIALIST-IO-VARIABLES ((SELF CONTROL-FRAME))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS SELF)
      SYM-SPECIALISTS-LOGIC-QUERY-SPECIALIST-IO-VARIABLES NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

;;; (DEFUN (CREATE-QUERY-SPECIALIST-ITERATOR QUERY-ITERATOR BOOLEAN BOOLEAN) ...)

(CL:DEFUN CREATE-QUERY-SPECIALIST-ITERATOR (FRAME)
  (CL:LET* ((PROPOSITION NULL) (SUBQUERYOPTIONS NULL))
   (CL:MULTIPLE-VALUE-SETQ (PROPOSITION SUBQUERYOPTIONS)
    (COMPUTE-SUBQUERY-OPTIONS FRAME))
   (CL:LET*
    ((SUBQUERYITERATOR (ALLOCATE-QUERY-ITERATOR))
     (SUBQUERYDESCRIPTION NULL) (MATCHMODE NULL)
     (TRUEFALSEQUERY? CL:NIL) (PARTIALQUERY? CL:NIL)
     (IOVARIABLES (NEW-LIST)) (IOVARIABLEBINDINGS NULL))
    (CL:IF (CL:EQ PROPOSITION NULL)
     (CL:RETURN-FROM CREATE-QUERY-SPECIALIST-ITERATOR
      (CL:VALUES NULL CL:NIL CL:NIL))
     (PROCESS-QUERY-OPTIONS SUBQUERYITERATOR SUBQUERYOPTIONS))
    (CL:SETQ MATCHMODE
     (LOOKUP-QUERY-OPTION SUBQUERYITERATOR KWD-SPECIALISTS-MATCH-MODE))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ MATCHMODE NULL))
      (CL:NOT (STRING-EQUAL? (COERCE-TO-STRING MATCHMODE) "STRICT")))
     (CL:SETQ PARTIALQUERY? CL:T))
    (COLLECT-FREE-VARIABLES PROPOSITION IOVARIABLES (LIST) (LIST))
    (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-LOGIC-QUERY-SPECIALIST-IO-VARIABLES IOVARIABLES
     NULL)
    (CL:LET* ((*EVALUATIONMODE* KWD-SPECIALISTS-DESCRIPTION))
     (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
     (CL:LET* ((SELF-001 (NEW-DESCRIPTION)))
      (CL:SETF (%DESCRIPTION.IO-VARIABLES SELF-001)
       (COPY-LIST-TO-ARGUMENTS-VECTOR IOVARIABLES))
      (CL:SETF (%DESCRIPTION.PROPOSITION SELF-001) PROPOSITION)
      (CL:SETQ SUBQUERYDESCRIPTION SELF-001))
     (COMPUTE-INTERNAL-VARIABLES SUBQUERYDESCRIPTION)
     (CL:LET*
      ((TEMP-000 (FIND-DUPLICATE-DESCRIPTION SUBQUERYDESCRIPTION)))
      (CL:SETQ SUBQUERYDESCRIPTION
       (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000
        SUBQUERYDESCRIPTION))))
    (CL:SETQ IOVARIABLEBINDINGS (NEW-VECTOR (LENGTH IOVARIABLES)))
    (CL:SETQ TRUEFALSEQUERY? CL:T)
    (CL:LET*
     ((VAR NULL) (ITER-000 (%LIST.THE-CONS-LIST IOVARIABLES))
      (I NULL-INTEGER) (ITER-001 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ VAR (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
      (CL:LET
       ((SELF (%VECTOR.THE-ARRAY IOVARIABLEBINDINGS))
        (VALUE (ARGUMENT-BOUND-TO VAR)) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:WHEN
       (CL:EQ
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY IOVARIABLEBINDINGS))
         I)
        NULL)
       (CL:SETQ TRUEFALSEQUERY? CL:NIL))
      (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (CL:1+ ITER-001))))
    (INITIALIZE-QUERY-ITERATOR SUBQUERYITERATOR SUBQUERYDESCRIPTION
     IOVARIABLEBINDINGS)
    (CL:VALUES SUBQUERYITERATOR TRUEFALSEQUERY? PARTIALQUERY?))))

;;; (DEFUN (/PL-KERNEL-KB/QUERY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/QUERY-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((SUBQUERYITERATOR
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL))
    (TRUEFALSEQUERY? CL:NIL) (PARTIALQUERY? CL:NIL)
    (SORTEDQUERY? CL:NIL) (SUCCESS? CL:NIL) (RESULT NULL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:COND
    ((CL:EQ SUBQUERYITERATOR NULL)
     (CL:MULTIPLE-VALUE-SETQ
      (SUBQUERYITERATOR TRUEFALSEQUERY? PARTIALQUERY?)
      (CREATE-QUERY-SPECIALIST-ITERATOR FRAME))
     (CL:IF (CL:EQ SUBQUERYITERATOR NULL)
      (CL:RETURN-FROM |/PL-KERNEL-KB/QUERY-SPECIALIST|
       KWD-SPECIALISTS-TERMINAL-FAILURE)
      (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
       SYM-SPECIALISTS-STELLA-ITERATOR SUBQUERYITERATOR NULL))
     (CL:COND
      (PARTIALQUERY?
       (CL:IF TRUEFALSEQUERY? (CALL-ASK-PARTIAL SUBQUERYITERATOR)
        (CALL-RETRIEVE-PARTIAL SUBQUERYITERATOR)))
      ((CL:AND (CL:NOT TRUEFALSEQUERY?)
        (CL:NOT
         (CL:EQ
          (LOOKUP-QUERY-OPTION SUBQUERYITERATOR
           KWD-SPECIALISTS-SORT-BY)
          NULL)))
       (CL:SETQ SORTEDQUERY? CL:T) (CALL-RETRIEVE SUBQUERYITERATOR))))
    (CL:T
     (CL:SETQ PARTIALQUERY?
      (CL:NOT
       (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY SUBQUERYITERATOR)
        NULL)))
     (CL:SETQ SORTEDQUERY?
      (CL:NOT
       (CL:EQ
        (LOOKUP-QUERY-OPTION SUBQUERYITERATOR KWD-SPECIALISTS-SORT-BY)
        NULL)))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-SPECIALISTS-GOAL-TREE))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     EOL))
   (CL:LOOP
    (CL:TAGBODY
     (CL:COND
      ((CL:OR PARTIALQUERY? SORTEDQUERY?)
       (CL:SETQ SUCCESS? (QUERY-SUCCEEDED? SUBQUERYITERATOR))
       (CL:WHEN SUCCESS?
        (CL:LET*
         ((SOLUTION
           (POP (%QUERY-ITERATOR.SOLUTIONS SUBQUERYITERATOR))))
         (CL:SETQ RESULT
          (%QUERY-ITERATOR.BASE-CONTROL-FRAME SUBQUERYITERATOR))
         (CL:WHEN (CL:NOT TRUEFALSEQUERY?)
          (CL:SETF (%QUERY-ITERATOR.VALUE SUBQUERYITERATOR) SOLUTION))
         (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE RESULT)
          (%QUERY-SOLUTION.TRUTH-VALUE SOLUTION))
         (CL:WHEN *RECORD-JUSTIFICATIONS?*
          (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS RESULT)
           SYM-SPECIALISTS-LOGIC-JUSTIFICATION
           (%QUERY-SOLUTION.JUSTIFICATION SOLUTION) NULL))
         (CL:WHEN PARTIALQUERY?
          (CL:SETF
           (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE
            (%CONTROL-FRAME.PARTIAL-MATCH-FRAME RESULT))
           (%QUERY-SOLUTION.MATCH-SCORE SOLUTION))))))
      (CL:T
       (CL:LET*
        ((*QUERYITERATOR* SUBQUERYITERATOR)
         (*REVERSEPOLARITY?* (%CONTROL-FRAME.REVERSE-POLARITY? FRAME))
         (*INFERENCELEVEL* (CURRENT-INFERENCE-LEVEL))
         (*GENERATE-ALL-PROOFS?* CL:NIL))
        (CL:DECLARE
         (CL:SPECIAL *QUERYITERATOR* *REVERSEPOLARITY?*
          *INFERENCELEVEL* *GENERATE-ALL-PROOFS?*))
        (CL:LET*
         ((HOWMANY (LOOKUP-HOW-MANY-SOLUTIONS SUBQUERYITERATOR)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM HOWMANY))
         (CL:WHEN (CL:OR (CL:= HOWMANY NULL-INTEGER) (CL:>= HOWMANY 1))
          (CL:SETQ SUCCESS? (NEXT? SUBQUERYITERATOR)))
         (CL:COND ((CL:= HOWMANY NULL-INTEGER))
          ((CL:<= HOWMANY 1)
           (CL:SETF (%QUERY-ITERATOR.EXHAUSTED? SUBQUERYITERATOR)
            CL:T))
          (CL:T
           (INSERT-AT (%QUERY-ITERATOR.OPTIONS SUBQUERYITERATOR)
            KWD-SPECIALISTS-HOW-MANY (WRAP-INTEGER (CL:1- HOWMANY)))))
         (CL:WHEN SUCCESS?
          (CL:SETQ RESULT
           (%QUERY-ITERATOR.BASE-CONTROL-FRAME SUBQUERYITERATOR)))))))
     (CL:WHEN SUCCESS?
      (CL:LET*
       ((VAR NULL)
        (ITER-000
         (%LIST.THE-CONS-LIST (QUERY-SPECIALIST-IO-VARIABLES FRAME)))
        (VALUE NULL)
        (VECTOR-000
         (%QUERY-SOLUTION.BINDINGS
          (%QUERY-ITERATOR.VALUE SUBQUERYITERATOR)))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
         (CL:< INDEX-000 LENGTH-000))
        DO (CL:SETQ VAR (%%VALUE ITER-000))
        (CL:SETQ VALUE
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:WHEN (CL:NOT (BIND-VARIABLE-TO-VALUE? VAR VALUE CL:T))
         (CL:SETQ SUCCESS? CL:NIL) (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:WHEN (CL:AND (CL:NOT SUCCESS?) (CL:NOT TRUEFALSEQUERY?))
       (CL:GO :CONTINUE)))
     (CL:RETURN) :CONTINUE))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-SPECIALISTS-GOAL-TREE))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     EOL))
   (CL:COND
    (SUCCESS? (PROPAGATE-FRAME-TRUTH-VALUE RESULT FRAME)
     (CL:WHEN
      (CL:AND
       (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
        (CL:NOT
         (CL:EQ
          (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
          NULL)))
       PARTIALQUERY?)
      (PROPAGATE-FRAME-PARTIAL-TRUTH
       (%CONTROL-FRAME.PARTIAL-MATCH-FRAME RESULT) FRAME))
     (CL:WHEN *RECORD-JUSTIFICATIONS?*
      (RECORD-GOAL-JUSTIFICATION FRAME
       (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS RESULT)
        SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)))
     (CL:IF TRUEFALSEQUERY? KWD-SPECIALISTS-FINAL-SUCCESS
      KWD-SPECIALISTS-CONTINUING-SUCCESS))
    (CL:T KWD-SPECIALISTS-TERMINAL-FAILURE))))

(CL:DEFUN NEW-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT))
   (CL:SETF (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.DOWN-FRAME SELF)
    NULL)
   (CL:SETF (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.INFERENCE-LEVEL SELF)
    NULL)
   (CL:SETF
    (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.SAVED-INFERENCE-LEVEL SELF)
    NULL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT))
  SGT-SPECIALISTS-LOGIC-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT)

(CL:DEFUN ACCESS-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-SAVED-INFERENCE-LEVEL)
    (CL:IF SETVALUE?
     (CL:SETF
      (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.SAVED-INFERENCE-LEVEL SELF)
      VALUE)
     (CL:SETQ VALUE
      (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.SAVED-INFERENCE-LEVEL
       SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-INFERENCE-LEVEL)
    (CL:IF SETVALUE?
     (CL:SETF
      (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.INFERENCE-LEVEL SELF)
      VALUE)
     (CL:SETQ VALUE
      (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.INFERENCE-LEVEL SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-DOWN-FRAME)
    (CL:IF SETVALUE?
     (CL:SETF (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.DOWN-FRAME SELF)
      VALUE)
     (CL:SETQ VALUE
      (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.DOWN-FRAME SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (LEVELED-QUERY-RELATION-TO-INFERENCE-LEVEL INFERENCE-LEVEL) ...)

(CL:DEFUN LEVELED-QUERY-RELATION-TO-INFERENCE-LEVEL (RELATION)
  (CL:COND
   ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-ASSERTION-QUERY)
    ASSERTION-INFERENCE)
   ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SHALLOW-QUERY)
    SHALLOW-INFERENCE)
   ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SUBSUMPTION-QUERY)
    SUBSUMPTION-INFERENCE)
   ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-BACKTRACKING-QUERY)
    BACKTRACKING-INFERENCE)
   ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-NORMAL-QUERY)
    NORMAL-INFERENCE)
   ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-REFUTATION-QUERY)
    REFUTATION-INFERENCE)
   (CL:T
    (GET-INFERENCE-LEVEL
     (KEYWORDIFY
      (%%VALUE (SPLIT-STRING (%SURROGATE.SYMBOL-NAME RELATION) #\-)))))))

;;; (DEFUN (/PL-KERNEL-KB/LEVELED-QUERY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/LEVELED-QUERY-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (ADJUNCT
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT NULL)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-DOWN)
     (CL:WHEN (CL:EQ ADJUNCT NULL)
      (CL:LET*
       ((ARGPROPVALUE
         (ARGUMENT-BOUND-TO
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
           0))))
       (CL:WHEN
        (CL:OR (CL:EQ ARGPROPVALUE NULL)
         (CL:NOT
          (ISA? ARGPROPVALUE SGT-SPECIALISTS-LOGIC-PROPOSITION)))
        (CL:RETURN-FROM |/PL-KERNEL-KB/LEVELED-QUERY-SPECIALIST|
         KWD-SPECIALISTS-TERMINAL-FAILURE))
       (CL:LET* ((SELF-000 (NEW-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT)))
        (CL:SETF
         (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.SAVED-INFERENCE-LEVEL
          SELF-000)
         (CURRENT-INFERENCE-LEVEL))
        (CL:SETF
         (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.INFERENCE-LEVEL
          SELF-000)
         (LEVELED-QUERY-RELATION-TO-INFERENCE-LEVEL
          (%PROPOSITION.OPERATOR PROPOSITION)))
        (CL:SETF
         (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.DOWN-FRAME SELF-000)
         (CREATE-DOWN-FRAME FRAME ARGPROPVALUE))
        (CL:SETQ ADJUNCT SELF-000))
       (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
        SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT ADJUNCT NULL)))
     (CL:SETF (%CONTROL-FRAME.DOWN FRAME)
      (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.DOWN-FRAME ADJUNCT))
     (CALL-SET-INFERENCE-LEVEL
      (%INFERENCE-LEVEL.KEYWORD
       (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.INFERENCE-LEVEL ADJUNCT))
      NULL)
     (CL:SETQ *INFERENCELEVEL*
      (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.INFERENCE-LEVEL ADJUNCT))
     KWD-SPECIALISTS-MOVE-DOWN)
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-TRUE)
     (PROPAGATE-FRAME-TRUTH-VALUE (%CONTROL-FRAME.RESULT FRAME) FRAME)
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT
        (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
         NULL)))
      (PROPAGATE-FRAME-PARTIAL-TRUTH
       (%CONTROL-FRAME.PARTIAL-MATCH-FRAME
        (%CONTROL-FRAME.RESULT FRAME))
       FRAME))
     (CL:WHEN *RECORD-JUSTIFICATIONS?*
      (CL:LET* ((SELF-001 (NEW-JUSTIFICATION)))
       (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-001)
        KWD-SPECIALISTS-LEVELED-QUERY)
       (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-001)
        (CONS
         (DYNAMIC-SLOT-VALUE
          (%CONTROL-FRAME.DYNAMIC-SLOTS (%CONTROL-FRAME.RESULT FRAME))
          SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)
         NIL))
       (RECORD-GOAL-JUSTIFICATION FRAME SELF-001)))
     (CALL-SET-INFERENCE-LEVEL
      (%INFERENCE-LEVEL.KEYWORD
       (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.SAVED-INFERENCE-LEVEL
        ADJUNCT))
      NULL)
     (CL:SETQ *INFERENCELEVEL*
      (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.SAVED-INFERENCE-LEVEL
       ADJUNCT))
     (CL:COND
      ((CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
       (CL:SETF
        (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.DOWN-FRAME ADJUNCT)
        (%CONTROL-FRAME.DOWN FRAME))
       (CL:SETF (%CONTROL-FRAME.DOWN FRAME) NULL)
       KWD-SPECIALISTS-CONTINUING-SUCCESS)
      (CL:T KWD-SPECIALISTS-FINAL-SUCCESS)))
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-FAIL)
     (PROPAGATE-FRAME-TRUTH-VALUE (%CONTROL-FRAME.RESULT FRAME) FRAME)
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT
        (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
         NULL)))
      (PROPAGATE-FRAME-PARTIAL-TRUTH
       (%CONTROL-FRAME.PARTIAL-MATCH-FRAME
        (%CONTROL-FRAME.RESULT FRAME))
       FRAME))
     (CL:WHEN *RECORD-JUSTIFICATIONS?*
      (RECORD-PRIMITIVE-JUSTIFICATION FRAME KWD-SPECIALISTS-UP-FAIL))
     (CALL-SET-INFERENCE-LEVEL
      (%INFERENCE-LEVEL.KEYWORD
       (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.SAVED-INFERENCE-LEVEL
        ADJUNCT))
      NULL)
     (CL:SETQ *INFERENCELEVEL*
      (%SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT.SAVED-INFERENCE-LEVEL
       ADJUNCT))
     KWD-SPECIALISTS-TERMINAL-FAILURE)
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" LASTMOVE "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFGLOBAL *PROTOTYPE-ID-COUNTER* ...)

(CL:DEFVAR *PROTOTYPE-ID-COUNTER* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *PROTOTYPE-ID-COUNTER*))

;;; (DEFUN (/PL-KERNEL-KB/CONCEPT-PROTOTYPE-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/CONCEPT-PROTOTYPE-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (CLASS
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       0)))
    (PROTOTYPEARGUMENT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (PROTOTYPE NULL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:OR (CL:EQ CLASS NULL)
     (CL:NOT (ISA? CLASS SGT-SPECIALISTS-LOGIC-DESCRIPTION)))
    (CL:RETURN-FROM |/PL-KERNEL-KB/CONCEPT-PROTOTYPE-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:SETQ PROTOTYPE
    (ACCESS-BINARY-VALUE CLASS
     SGT-SPECIALISTS-PL-KERNEL-KB-CONCEPT-PROTOTYPE))
   (CL:WHEN (CL:EQ PROTOTYPE NULL)
    (CL:LET* ((EQUIVALENCE NULL))
     (CL:LET*
      ((*CONTEXT* (%DESCRIPTION.HOME-CONTEXT CLASS))
       (*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)))
      (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
      (CL:SETQ PROTOTYPE
       (CREATE-HYPOTHESIZED-INSTANCE
        (CL:IF (ISA? CLASS SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION)
         (CONCATENATE "proto-" (OBJECT-NAME-STRING CLASS))
         "prototype")))
      (CL:LET* ((*INVISIBLEASSERTION?* CL:T))
       (CL:DECLARE (CL:SPECIAL *INVISIBLEASSERTION?*))
       (ASSERT-MEMBER-OF-PROPOSITION PROTOTYPE CLASS)
       (CL:SETQ EQUIVALENCE
        (ASSERT-BINARY-VALUE
         SGT-SPECIALISTS-PL-KERNEL-KB-CONCEPT-PROTOTYPE CLASS
         PROTOTYPE))))
     (REACT-TO-INFERENCE-UPDATE EQUIVALENCE)))
   (SELECT-PROOF-RESULT
    (BIND-ARGUMENT-TO-VALUE? PROTOTYPEARGUMENT PROTOTYPE CL:T) CL:NIL
    CL:T)))

;;; (DEFUN (CONCEPT-PROTOTYPE-OF NAMED-DESCRIPTION) ...)

(CL:DEFUN CONCEPT-PROTOTYPE-OF (SELF)
  (CL:WHEN
   (%BOOLEAN-WRAPPER.WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%LOGIC-OBJECT.DYNAMIC-SLOTS SELF)
     SYM-SPECIALISTS-LOGIC-HYPOTHESIZED-INSTANCE? FALSE-WRAPPER))
   (CL:LET*
    ((PROP NULL) (ITER-000 (ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ PROP (%ITERATOR.VALUE ITER-000))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (ACCESS-BINARY-VALUE
         (SURROGATE-TO-DESCRIPTION (%PROPOSITION.OPERATOR PROP))
         SGT-SPECIALISTS-PL-KERNEL-KB-CONCEPT-PROTOTYPE)
        NULL))
      (CL:RETURN-FROM CONCEPT-PROTOTYPE-OF
       (SURROGATE-TO-DESCRIPTION (%PROPOSITION.OPERATOR PROP)))))))
  NULL)

;;; (DEFUN (CONCEPT-PROTOTYPE? BOOLEAN) ...)

(CL:DEFUN CONCEPT-PROTOTYPE? (SELF)
  (CL:NOT (CL:EQ (CONCEPT-PROTOTYPE-OF SELF) NULL)))

;;; (DEFUN (/PL-KERNEL-KB/CLOSED-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/CLOSED-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (ARGVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       0)))
    (CLOSED? (CLOSED-TERM? ARGVALUE)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ ARGVALUE NULL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/CLOSED-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:WHEN *REVERSEPOLARITY?* (CL:SETQ CLOSED? (CL:NOT CLOSED?)))
   (SELECT-PROOF-RESULT CLOSED? CL:NIL CL:T)))

;;; (DEFUN (CLOSED-BY-ASSERTION? BOOLEAN) ...)

(CL:DEFUN CLOSED-BY-ASSERTION? (SELF)
  (CL:AND (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED)
   (CL:NOT
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
      SYM-SPECIALISTS-LOGIC-MONOTONIC? FALSE-WRAPPER)))))

;;; (DEFUN (CLOSED-TERM? BOOLEAN) ...)

(CL:DEFUN CLOSED-TERM? (SELF)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
    (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE.SURROGATE-VALUE
      SGT-SPECIALISTS-LOGIC-F-CLOSED-TERM?-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-SPECIALISTS-LOGIC-F-CLOSED-TERM?-MEMO-TABLE-000
      "(:MAX-VALUES 500 :TIMESTAMPS (:KB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE.SURROGATE-VALUE
       SGT-SPECIALISTS-LOGIC-F-CLOSED-TERM?-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF *CONTEXT*
      MEMOIZED-NULL-VALUE NULL 2))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (CL:IF (HELP-CLOSED-TERM? SELF NIL) TRUE-WRAPPER FALSE-WRAPPER))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE-000))))

;;; (DEFUN (HELP-CLOSED-TERM? BOOLEAN) ...)

(CL:DEFUN HELP-CLOSED-TERM? (SELF ACTIVETERMS)
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM HELP-CLOSED-TERM? CL:NIL))
  (CL:IF (MEMB? ACTIVETERMS SELF)
   (CL:RETURN-FROM HELP-CLOSED-TERM? CL:NIL)
   (CL:SETQ ACTIVETERMS (CONS SELF ACTIVETERMS)))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:OR
       (CL:AND
        (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED)
        (CL:NOT
         (%BOOLEAN-WRAPPER.WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
           SYM-SPECIALISTS-LOGIC-MONOTONIC? FALSE-WRAPPER))))
       (CL:AND
        (CL:NOT
         (CL:EQ
          (ACCESS-IN-CONTEXT
           (DYNAMIC-SLOT-VALUE (%LOGIC-OBJECT.DYNAMIC-SLOTS SELF)
            SYM-SPECIALISTS-LOGIC-EQUIVALENT-VALUE NULL)
           (%LOGIC-OBJECT.HOME-CONTEXT SELF) CL:NIL)
          NULL))
        (HELP-CLOSED-TERM?
         (ACCESS-IN-CONTEXT
          (DYNAMIC-SLOT-VALUE (%LOGIC-OBJECT.DYNAMIC-SLOTS SELF)
           SYM-SPECIALISTS-LOGIC-EQUIVALENT-VALUE NULL)
          (%LOGIC-OBJECT.HOME-CONTEXT SELF) CL:NIL)
         ACTIVETERMS)))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:OR
       (CL:AND
        (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED)
        (CL:NOT
         (%BOOLEAN-WRAPPER.WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
           SYM-SPECIALISTS-LOGIC-MONOTONIC? FALSE-WRAPPER))))
       (HELP-CLOSED-PROPOSITION? (%DESCRIPTION.PROPOSITION SELF)
        ACTIVETERMS))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (HELP-CLOSED-TERM? (VALUE-OF SELF) ACTIVETERMS)))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-SPECIALISTS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN CL:NIL))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET* ((DEFININGPROP (%SKOLEM.DEFINING-PROPOSITION SELF)))
       (CL:OR
        (CL:AND (CL:NOT (CL:EQ DEFININGPROP NULL))
         (COLLECTIONOF-PROPOSITION? DEFININGPROP))
        (CL:AND
         (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED)
         (CL:NOT
          (%BOOLEAN-WRAPPER.WRAPPER-VALUE
           (DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
            SYM-SPECIALISTS-LOGIC-MONOTONIC? FALSE-WRAPPER))))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:AND (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED)
       (CL:NOT
        (%BOOLEAN-WRAPPER.WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
          SYM-SPECIALISTS-LOGIC-MONOTONIC? FALSE-WRAPPER))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-THING)
     (CL:PROGN
      (CL:AND (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED)
       (CL:NOT
        (%BOOLEAN-WRAPPER.WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
          SYM-SPECIALISTS-LOGIC-MONOTONIC? FALSE-WRAPPER))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-COLLECTION)
     (CL:PROGN CL:T))
    (CL:T CL:NIL))))

;;; (DEFUN (CLOSED-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN CLOSED-PROPOSITION? (SELF)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
    (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE.SURROGATE-VALUE
      SGT-SPECIALISTS-LOGIC-F-CLOSED-PROPOSITION?-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-SPECIALISTS-LOGIC-F-CLOSED-PROPOSITION?-MEMO-TABLE-000
      "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE.SURROGATE-VALUE
       SGT-SPECIALISTS-LOGIC-F-CLOSED-PROPOSITION?-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF *CONTEXT*
      MEMOIZED-NULL-VALUE NULL -1))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (CL:IF (HELP-CLOSED-PROPOSITION? SELF NIL) TRUE-WRAPPER
       FALSE-WRAPPER))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE-000))))

;;; (DEFUN (HELP-CLOSED-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN HELP-CLOSED-PROPOSITION? (SELF ACTIVETERMS)
  (CL:IF (MEMB? ACTIVETERMS SELF)
   (CL:RETURN-FROM HELP-CLOSED-PROPOSITION? CL:NIL)
   (CL:SETQ ACTIVETERMS (CONS SELF ACTIVETERMS)))
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-AND)
      (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-OR)
      (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-NOT)
      (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-FORALL)
      (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-EXISTS))
     (CL:LET* ((ALWAYS?-000 CL:T))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:WHEN (CL:NOT (HELP-CLOSED-PROPOSITION? ARG ACTIVETERMS))
         (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:LET* ((VALUE-000 ALWAYS?-000)) VALUE-000)))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-ISA))
     (CL:COND
      ((CL:EQ (%PROPOSITION.OPERATOR SELF)
        SGT-SPECIALISTS-PL-KERNEL-KB-MEMBER-OF)
       (CL:LET*
        ((COLLECTIONARG
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
           1))
         (COLLECTIONVALUE (SAFE-ARGUMENT-BOUND-TO COLLECTIONARG)))
        (CL:IF (CL:NOT (CL:EQ COLLECTIONVALUE NULL))
         (HELP-CLOSED-TERM? COLLECTIONVALUE ACTIVETERMS)
         (CL:LET* ((FOUND?-000 CL:NIL))
          (CL:LET*
           ((PROP NULL)
            (ITER-000
             (ALLOCATE-ITERATOR
              (UNFILTERED-DEPENDENT-PROPOSITIONS COLLECTIONARG NULL))))
           (CL:LOOP WHILE (NEXT? ITER-000) DO
            (CL:SETQ PROP (%ITERATOR.VALUE ITER-000))
            (CL:WHEN
             (CL:AND
              (EQL? COLLECTIONARG (LAST (%PROPOSITION.ARGUMENTS PROP)))
              (COLLECTIONOF-PROPOSITION? PROP))
             (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))))
          (CL:LET* ((VALUE-001 FOUND?-000)) VALUE-001)))))
      (CL:T
       (HELP-CLOSED-TERM?
        (GET-DESCRIPTION (%PROPOSITION.OPERATOR SELF)) ACTIVETERMS))))
    ((CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-FAIL) CL:T) (CL:T CL:NIL))))

;;; (DEFUN (/PL-KERNEL-KB/SINGLE-VALUED-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/SINGLE-VALUED-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (ARGVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       0)))
    (SINGLEVALUED? (SINGLE-VALUED-TERM? ARGVALUE)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ ARGVALUE NULL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/SINGLE-VALUED-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:WHEN *REVERSEPOLARITY?*
    (CL:SETQ SINGLEVALUED? (CL:NOT SINGLEVALUED?)))
   (CL:IF SINGLEVALUED? KWD-SPECIALISTS-FINAL-SUCCESS
    KWD-SPECIALISTS-TERMINAL-FAILURE)))

;;; (DEFUN (SINGLE-VALUED-TERM? BOOLEAN) ...)

(CL:DEFUN SINGLE-VALUED-TERM? (SELF)
  (CL:LET* ((*REVERSEPOLARITY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (CL:WHEN *CYC-KLUDGES-ENABLED?*
    (CL:RETURN-FROM SINGLE-VALUED-TERM?
     (CL:OR (FUNCTION? SELF)
      (TEST-PROPERTY? SELF
       SGT-SPECIALISTS-PL-KERNEL-KB-SINGLE-VALUED))))
   (CL:LET*
    ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
     (MEMOIZED-VALUE-000 NULL))
    (CL:WHEN *MEMOIZATION-ENABLED?*
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE.SURROGATE-VALUE
       SGT-SPECIALISTS-LOGIC-F-SINGLE-VALUED-TERM?-MEMO-TABLE-000))
     (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
      (INITIALIZE-MEMOIZATION-TABLE
       SGT-SPECIALISTS-LOGIC-F-SINGLE-VALUED-TERM?-MEMO-TABLE-000
       "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))")
      (CL:SETQ MEMO-TABLE-000
       (%SURROGATE.SURROGATE-VALUE
        SGT-SPECIALISTS-LOGIC-F-SINGLE-VALUED-TERM?-MEMO-TABLE-000)))
     (CL:SETQ MEMOIZED-ENTRY-000
      (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF *CONTEXT*
       MEMOIZED-NULL-VALUE NULL 2))
     (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
    (CL:COND
     ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
      (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
       (CL:SETQ MEMOIZED-VALUE-000 NULL)))
     (CL:T
      (CL:LET* ((TEST-VALUE-001 CL:NIL))
       (CL:IF (NON-RECURSIVE-SINGLE-VALUED-TERM? SELF)
        (CL:SETQ TEST-VALUE-001 CL:T)
        (CL:PROGN (CL:SETQ TEST-VALUE-001 (CL:NOT (CLASS? SELF)))
         (CL:WHEN TEST-VALUE-001
          (CL:LET* ((FOUND?-001 CL:NIL))
           (CL:LET* ((D NULL) (ITER-001 (ALL-SUPERCOLLECTIONS SELF)))
            (CL:LOOP WHILE (NEXT? ITER-001) DO
             (CL:SETQ D (%ITERATOR.VALUE ITER-001))
             (CL:WHEN (NON-RECURSIVE-SINGLE-VALUED-TERM? D)
              (CL:SETQ FOUND?-001 CL:T) (CL:RETURN))))
           (CL:SETQ TEST-VALUE-001 FOUND?-001)))))
       (CL:SETQ MEMOIZED-VALUE-000
        (CL:IF TEST-VALUE-001 TRUE-WRAPPER FALSE-WRAPPER)))
      (CL:WHEN *MEMOIZATION-ENABLED?*
       (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
        (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
         MEMOIZED-VALUE-000)))))
    (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE-000)))))

;;; (DEFUN (NON-RECURSIVE-SINGLE-VALUED-TERM? BOOLEAN) ...)

(CL:DEFUN NON-RECURSIVE-SINGLE-VALUED-TERM? (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:OR (FUNCTION-DESCRIPTION? SELF)
       (TEST-PROPERTY? SELF
        SGT-SPECIALISTS-PL-KERNEL-KB-SINGLE-VALUED))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:LET*
       ((PROPOSITION (%DESCRIPTION.PROPOSITION SELF))
        (IOVARIABLES NIL))
       (CL:LET*
        ((ARG NULL) (VECTOR-000 (%DESCRIPTION.IO-VARIABLES SELF))
         (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ ARG
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ IOVARIABLES (CONS ARG IOVARIABLES))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
       (HELP-SINGLE-VALUED-GOAL? PROPOSITION IOVARIABLES
        (COPY-CONS-LIST (%%REST IOVARIABLES)) CL:NIL))))
    (CL:T CL:NIL))))

;;; (DEFUN (SINGLE-VALUED-GOAL? BOOLEAN) ...)

(CL:DEFUN SINGLE-VALUED-GOAL? (PROPOSITION IOVARIABLES BOUNDVARIABLES)
  (HELP-SINGLE-VALUED-GOAL? PROPOSITION IOVARIABLES BOUNDVARIABLES CL:T))

;;; (DEFUN (HELP-SINGLE-VALUED-GOAL? BOOLEAN) ...)

(CL:DEFUN HELP-SINGLE-VALUED-GOAL? (PROPOSITION IOVARIABLES BOUNDVARIABLES RECURSIVE?)
  (CL:LET*
   ((BOUNDVARIABLESLIST (LISTIFY BOUNDVARIABLES))
    (OLDCOUNT (LENGTH BOUNDVARIABLESLIST)) (NEWCOUNT NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OLDCOUNT NEWCOUNT))
   (CL:LOOP
    (HELP-COLLECT-SINGLY-BOUND-VARIABLES PROPOSITION BOUNDVARIABLESLIST
     RECURSIVE?)
    (CL:SETQ NEWCOUNT (LENGTH BOUNDVARIABLESLIST))
    (CL:WHEN (CL:= OLDCOUNT NEWCOUNT) (CL:RETURN))
    (CL:SETQ OLDCOUNT NEWCOUNT))
   (CL:LET* ((ALWAYS?-000 CL:T))
    (CL:LET* ((VBL NULL) (ITER-000 IOVARIABLES))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ VBL (%%VALUE ITER-000))
      (CL:WHEN (CL:NOT (MEMBER? BOUNDVARIABLESLIST VBL))
       (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:LET* ((VALUE-000 ALWAYS?-000)) VALUE-000))))

;;; (DEFUN HELP-COLLECT-SINGLY-BOUND-VARIABLES ...)

(CL:DEFUN HELP-COLLECT-SINGLY-BOUND-VARIABLES (PROPOSITION BOUNDVARIABLES RECURSIVE?)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-AND)
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (HELP-COLLECT-SINGLY-BOUND-VARIABLES ARG BOUNDVARIABLES
        RECURSIVE?)
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-PREDICATE))
     (CL:WHEN (CL:> (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION)) 0)
      (CL:LET*
       ((LASTARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
          (CL:THE CL:FIXNUM
           (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION)))))))
       (CL:LET* ((TEST-VALUE-001 CL:NIL))
        (CL:SETQ TEST-VALUE-001 (VARIABLE? LASTARG))
        (CL:WHEN TEST-VALUE-001
         (CL:SETQ TEST-VALUE-001
          (CL:NOT (MEMBER? BOUNDVARIABLES LASTARG)))
         (CL:WHEN TEST-VALUE-001
          (CL:SETQ TEST-VALUE-001
           (CL:OR
            (CL:EQ (%PROPOSITION.KIND PROPOSITION)
             KWD-SPECIALISTS-FUNCTION)
            (CL:AND RECURSIVE?
             (SINGLE-VALUED-TERM?
              (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION))))
            (CL:AND (CL:NOT RECURSIVE?)
             (NON-RECURSIVE-SINGLE-VALUED-TERM?
              (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION))))))
          (CL:WHEN TEST-VALUE-001
           (CL:LET* ((ALWAYS?-000 CL:T))
            (CL:LET*
             ((ARG NULL)
              (ITER-000
               (BUT-LAST (%PROPOSITION.ARGUMENTS PROPOSITION))))
             (CL:LOOP WHILE (NEXT? ITER-000) DO
              (CL:SETQ ARG (%ITERATOR.VALUE ITER-000))
              (CL:WHEN
               (CL:NOT
                (CL:OR (CL:NOT (VARIABLE? ARG))
                 (MEMBER? BOUNDVARIABLES ARG)))
               (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))))
            (CL:SETQ TEST-VALUE-001 ALWAYS?-000)))))
        (CL:WHEN TEST-VALUE-001 (PUSH BOUNDVARIABLES LASTARG))))))
    ((CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-EQUIVALENT)
     (CL:LET* ((UNBOUNDVARIABLES NIL))
      (CL:LET*
       ((ARG NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS PROPOSITION))
        (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:WHEN
         (CL:AND (VARIABLE? ARG) (CL:NOT (MEMBER? BOUNDVARIABLES ARG)))
         (CL:SETQ UNBOUNDVARIABLES (CONS ARG UNBOUNDVARIABLES)))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      (CL:WHEN (CL:= (LENGTH UNBOUNDVARIABLES) 1)
       (PUSH BOUNDVARIABLES (%%VALUE UNBOUNDVARIABLES)))))
    (CL:T))))

;;; (DEFUN CREATE-COLLECT-DESCRIPTION-EXTENSION-FRAME ...)

(CL:DEFUN CREATE-COLLECT-DESCRIPTION-EXTENSION-FRAME (FRAME DESCRIPTION)
  (CL:LET* ((DOWNFRAME (CREATE-DOWN-FRAME FRAME NULL)))
   (OVERLAY-WITH-PATTERN-FRAME? DOWNFRAME DESCRIPTION NULL)
   (CL:SETF
    (%PATTERN-RECORD.COLLECTION-LIST
     (%CONTROL-FRAME.PATTERN-RECORD DOWNFRAME))
    (NEW-LIST))))

;;; (DEFUN (COLLECT-DESCRIPTION-EXTENSION-FRAME? BOOLEAN) ...)

(CL:DEFUN COLLECT-DESCRIPTION-EXTENSION-FRAME? (FRAME)
  (CL:AND (CL:NOT (CL:EQ (%CONTROL-FRAME.PATTERN-RECORD FRAME) NULL))
   (CL:NOT
    (CL:EQ
     (%PATTERN-RECORD.COLLECTION-LIST
      (%CONTROL-FRAME.PATTERN-RECORD FRAME))
     NULL))))

;;; (DEFUN (/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (COLLECTIONARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (COLLECTIONVALUE (ARGUMENT-BOUND-TO COLLECTIONARG))
    (LISTARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (LIST? CL:NIL) (UNIQUE? CL:T) (MEMBERS NULL) (RESULT NULL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ COLLECTIONVALUE NULL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.OPERATOR PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000
       SGT-SPECIALISTS-PL-KERNEL-KB-COLLECT-INTO-LIST)
      (CL:SETQ LIST? CL:T) (CL:SETQ UNIQUE? CL:NIL))
     ((CL:EQ TEST-VALUE-000
       SGT-SPECIALISTS-PL-KERNEL-KB-COLLECT-INTO-ORDERED-SET)
      (CL:SETQ LIST? CL:T))
     (CL:T)))
   (CL:COND
    ((CL:AND
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
        SYM-SPECIALISTS-STELLA-ITERATOR NULL)
       NULL)
      (CL:OR (CL:AND (ENUMERATED-SET? COLLECTIONVALUE) (CL:NOT LIST?))
       (CL:AND (ENUMERATED-LIST? COLLECTIONVALUE) (CL:NOT UNIQUE?)))
      (CL:EQ (VARIABLE-VALUE-INVERSE COLLECTIONVALUE) NIL))
     (CL:SETQ RESULT COLLECTIONVALUE))
    ((CL:EQ
      (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
       SYM-SPECIALISTS-STELLA-ITERATOR NULL)
      NULL)
     (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE COLLECTIONVALUE)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-002 SGT-SPECIALISTS-STELLA-COLLECTION)
        (CL:PROGN
         (CL:SETQ MEMBERS
          (ASSERTED-COLLECTION-MEMBERS COLLECTIONVALUE CL:NIL))
         (CL:WHEN (CL:EQ MEMBERS NULL)
          (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
           KWD-SPECIALISTS-TERMINAL-FAILURE))))
       ((SUBTYPE-OF? TEST-VALUE-002 SGT-SPECIALISTS-LOGIC-SKOLEM)
        (CL:PROGN
         (CL:SETQ MEMBERS
          (ASSERTED-COLLECTION-MEMBERS COLLECTIONVALUE CL:NIL))
         (CL:WHEN (CL:EQ MEMBERS NULL)
          (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
           KWD-SPECIALISTS-TERMINAL-FAILURE))))
       ((SUBTYPE-OF? TEST-VALUE-002 SGT-SPECIALISTS-LOGIC-DESCRIPTION)
        (CL:PROGN
         (CL:LET* ((TEST-VALUE-001 CL:NIL))
          (CL:SETQ TEST-VALUE-001
           (CL:NOT
            (CL:EQ
             (DYNAMIC-SLOT-VALUE
              (%DESCRIPTION.DYNAMIC-SLOTS COLLECTIONVALUE)
              SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES NULL)
             NULL)))
          (CL:WHEN TEST-VALUE-001
           (CL:LET* ((FOUND?-000 CL:NIL))
            (CL:LET*
             ((V NULL)
              (VECTOR-000
               (DYNAMIC-SLOT-VALUE
                (%DESCRIPTION.DYNAMIC-SLOTS COLLECTIONVALUE)
                SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES NULL))
              (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
             (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
             (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
              (CL:SETQ V
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR
                 (%VECTOR.THE-ARRAY VECTOR-000))
                INDEX-000))
              (CL:WHEN (CL:EQ (ARGUMENT-BOUND-TO V) NULL)
               (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
              (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
            (CL:SETQ TEST-VALUE-001 FOUND?-000)))
          (CL:WHEN TEST-VALUE-001
           (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
            KWD-SPECIALISTS-TERMINAL-FAILURE)))
         (CL:COND
          ((INFERABLE? COLLECTIONVALUE)
           (CREATE-COLLECT-DESCRIPTION-EXTENSION-FRAME FRAME
            COLLECTIONVALUE)
           (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
            SYM-SPECIALISTS-STELLA-ITERATOR EMPTY-PROPOSITIONS-ITERATOR
            NULL)
           (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
            KWD-SPECIALISTS-MOVE-DOWN))
          (CL:T
           (CL:SETQ MEMBERS
            (ASSERTED-COLLECTION-MEMBERS COLLECTIONVALUE CL:NIL))
           (CL:WHEN (CL:EQ MEMBERS NULL)
            (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
             KWD-SPECIALISTS-TERMINAL-FAILURE))
           (CL:SETQ UNIQUE? CL:NIL)))))
       (CL:T
        (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
         KWD-SPECIALISTS-FAILURE)))))
    (CL:T
     (CL:WHEN (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL)
      (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
       KWD-SPECIALISTS-FAILURE))
     (CL:LET* ((PATTERNFRAME (%CONTROL-FRAME.DOWN FRAME)))
      (CL:SETQ MEMBERS
       (REVERSE
        (%PATTERN-RECORD.COLLECTION-LIST
         (%CONTROL-FRAME.PATTERN-RECORD PATTERNFRAME))))
      (POP-FRAMES-UP-TO PATTERNFRAME)
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (DYNAMIC-SLOT-VALUE
          (%CONTROL-FRAME.DYNAMIC-SLOTS PATTERNFRAME)
          SYM-SPECIALISTS-LOGIC-INFERENCE-CUTOFF-REASON NULL)
         NULL))
       (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
        KWD-SPECIALISTS-FAILURE)))))
   (CL:WHEN (CL:EQ RESULT NULL)
    (CL:WHEN UNIQUE?
     (CL:SETQ MEMBERS
      (CL:IF (CONS? (FIRST MEMBERS)) (REMOVE-DUPLICATES-EQUAL MEMBERS)
       (REMOVE-DUPLICATES MEMBERS))))
    (CL:LET* ((*MODULE* *MODULE*) (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CL:SETQ RESULT
      (CL:IF LIST? (CREATE-LOGICAL-LIST MEMBERS)
       (CREATE-ENUMERATED-SET MEMBERS)))))
   (CL:LET*
    ((SUCCESS
      (SELECT-TEST-RESULT (BIND-ARGUMENT-TO-VALUE? LISTARG RESULT CL:T)
       CL:T FRAME)))
    (CL:WHEN
     (CL:AND *RECORD-JUSTIFICATIONS?*
      (CL:NOT (CL:EQ SUCCESS KWD-SPECIALISTS-TERMINAL-FAILURE)))
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-000)
       KWD-SPECIALISTS-COLLECT-MEMBERS)
      (CL:LET*
       ((JUSTIFICATION SELF-000)
        (ANTECEDENTS
         (CL:IF (CL:NOT (CL:EQ (%CONTROL-FRAME.RESULT FRAME) NULL))
          (DYNAMIC-SLOT-VALUE
           (%CONTROL-FRAME.DYNAMIC-SLOTS (%CONTROL-FRAME.RESULT FRAME))
           SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)
          NULL)))
       (CL:WHEN (CL:NOT (CL:EQ ANTECEDENTS NULL))
        (CL:SETF (%JUSTIFICATION.ANTECEDENTS JUSTIFICATION)
         (CONS ANTECEDENTS NIL)))
       (RECORD-GOAL-JUSTIFICATION FRAME JUSTIFICATION))))
    SUCCESS)))

;;; (DEFUN (/PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (COLLECTIONARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (COLLECTION (ARGUMENT-BOUND-TO COLLECTIONARG))
    (NARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (N (ARGUMENT-BOUND-TO NARG))
    (ELEMENTARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      2))
    (ELEMENT (ARGUMENT-BOUND-TO ELEMENTARG)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (LOGICAL-COLLECTION? COLLECTION)
    (CL:LET*
     ((THEN NULL-INTEGER)
      (ARGUMENTS
       (%PROPOSITION.ARGUMENTS
        (%SKOLEM.DEFINING-PROPOSITION COLLECTION)))
      (NARGS (CL:1- (LENGTH ARGUMENTS))))
     (CL:DECLARE (CL:TYPE CL:FIXNUM THEN NARGS))
     (CL:COND
      ((INTEGER? N) (CL:SETQ THEN (UNWRAP-INTEGER N))
       (CL:WHEN (CL:< THEN 0) (CL:SETQ THEN (CL:+ NARGS THEN)))
       (CL:WHEN (CL:AND (CL:>= THEN 0) (CL:< THEN NARGS))
        (CL:RETURN-FROM |/PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST|
         (SELECT-TEST-RESULT
          (BIND-ARGUMENT-TO-VALUE? ELEMENTARG
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
            THEN)
           CL:T)
          CL:T FRAME))))
      ((CL:AND (CL:EQ N NULL) (CL:NOT (CL:EQ ELEMENT NULL)))
       (CL:LET*
        ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 0)
         (UPPER-BOUND-000 (CL:1- NARGS)))
        (CL:DECLARE
         (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000
          UPPER-BOUND-000))
        (CL:LOOP WHILE
         (CL:AND (CL:< INDEX-000 LENGTH-000)
          (CL:<= ITER-000 UPPER-BOUND-000))
         DO
         (CL:SETQ ARG
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ I ITER-000)
         (CL:WHEN (EQL? (ARGUMENT-BOUND-TO ARG) ELEMENT)
          (CL:RETURN-FROM |/PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST|
           (SELECT-TEST-RESULT
            (BIND-ARGUMENT-TO-VALUE? NARG (WRAP-INTEGER I) CL:T) CL:T
            FRAME)))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
         (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
      ((CL:AND (CL:EQ N NULL) (CL:EQ ELEMENT NULL))
       (CL:LET*
        ((ITERATOR
          (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
           SYM-SPECIALISTS-STELLA-ITERATOR NULL)))
        (CL:WHEN (CL:EQ ITERATOR NULL)
         (CL:SETQ ITERATOR (ALLOCATE-ITERATOR ARGUMENTS))
         (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
          SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
        (CL:SETQ THEN
         (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER ITERATOR))
        (CL:WHEN (CL:AND (CL:< THEN NARGS) (NEXT? ITERATOR))
         (CL:SETQ ELEMENT (%ALL-PURPOSE-ITERATOR.VALUE ITERATOR))
         (CL:WHEN
          (CL:AND
           (BIND-ARGUMENT-TO-VALUE? NARG (WRAP-INTEGER THEN) CL:T)
           (BIND-ARGUMENT-TO-VALUE? ELEMENTARG ELEMENT CL:T))
          (CL:RETURN-FROM |/PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST|
           KWD-SPECIALISTS-CONTINUING-SUCCESS))))))))
   KWD-SPECIALISTS-TERMINAL-FAILURE))

;;; (DEFUN (/PL-KERNEL-KB/NTH-HEAD-COMPUTATION SKOLEM) ...)

(CL:DEFUN |/PL-KERNEL-KB/NTH-HEAD-COMPUTATION| (LIST NARG)
  (CL:WHEN (CL:NOT (ENUMERATED-LIST? LIST))
   (CL:RETURN-FROM |/PL-KERNEL-KB/NTH-HEAD-COMPUTATION| NULL))
  (CL:LET*
   ((N (%INTEGER-WRAPPER.WRAPPER-VALUE NARG))
    (ELEMENTS
     (%PROPOSITION.ARGUMENTS (%SKOLEM.DEFINING-PROPOSITION LIST)))
    (NELEMENTS (CL:1- (LENGTH ELEMENTS))) (HEADELEMENTS (NEW-LIST)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM N NELEMENTS))
   (CL:WHEN (CL:< N 0) (CL:SETQ N (CL:+ NELEMENTS N)))
   (CL:WHEN (CL:OR (CL:< N 0) (CL:> N NELEMENTS))
    (CL:RETURN-FROM |/PL-KERNEL-KB/NTH-HEAD-COMPUTATION| NULL))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- N))
     (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ELEMENTS)) I)
         NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST HEADELEMENTS) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST HEADELEMENTS) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST
         (%LIST.THE-CONS-LIST HEADELEMENTS) COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ELEMENTS)) I)
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CREATE-LOGICAL-LIST HEADELEMENTS)))

;;; (DEFUN (/PL-KERNEL-KB/NTH-REST-COMPUTATION SKOLEM) ...)

(CL:DEFUN |/PL-KERNEL-KB/NTH-REST-COMPUTATION| (LIST NARG)
  (CL:WHEN (CL:NOT (ENUMERATED-LIST? LIST))
   (CL:RETURN-FROM |/PL-KERNEL-KB/NTH-REST-COMPUTATION| NULL))
  (CL:LET*
   ((N (%INTEGER-WRAPPER.WRAPPER-VALUE NARG))
    (ELEMENTS
     (%PROPOSITION.ARGUMENTS (%SKOLEM.DEFINING-PROPOSITION LIST)))
    (NELEMENTS (CL:1- (LENGTH ELEMENTS))) (RESTELEMENTS (NEW-LIST)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM N NELEMENTS))
   (CL:WHEN (CL:< N 0) (CL:SETQ N (CL:+ NELEMENTS N)))
   (CL:WHEN (CL:OR (CL:< N 0) (CL:> N NELEMENTS))
    (CL:RETURN-FROM |/PL-KERNEL-KB/NTH-REST-COMPUTATION| NULL))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 N) (UPPER-BOUND-000 (CL:1- NELEMENTS))
     (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ELEMENTS)) I)
         NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST RESTELEMENTS) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST RESTELEMENTS) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST
         (%LIST.THE-CONS-LIST RESTELEMENTS) COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ELEMENTS)) I)
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CREATE-LOGICAL-LIST RESTELEMENTS)))

;;; (DEFUN (/PL-KERNEL-KB/INSERT-ELEMENT-COMPUTATION SKOLEM) ...)

(CL:DEFUN |/PL-KERNEL-KB/INSERT-ELEMENT-COMPUTATION| (LIST NARG ELEMENT)
  (CL:WHEN (CL:NOT (ENUMERATED-LIST? LIST))
   (CL:RETURN-FROM |/PL-KERNEL-KB/INSERT-ELEMENT-COMPUTATION| NULL))
  (CL:LET*
   ((N (%INTEGER-WRAPPER.WRAPPER-VALUE NARG))
    (ELEMENTS
     (%PROPOSITION.ARGUMENTS (%SKOLEM.DEFINING-PROPOSITION LIST)))
    (NELEMENTS (CL:1- (LENGTH ELEMENTS))) (NEWELEMENTS (NEW-LIST)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM N NELEMENTS))
   (CL:WHEN (CL:< N 0) (CL:SETQ N (CL:+ NELEMENTS N 1)))
   (CL:WHEN (CL:OR (CL:< N 0) (CL:> N NELEMENTS))
    (CL:RETURN-FROM |/PL-KERNEL-KB/INSERT-ELEMENT-COMPUTATION| NULL))
   (CL:LET*
    ((ELT NULL) (VECTOR-000 ELEMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- NELEMENTS)))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000
      UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000)
      (CL:<= ITER-000 UPPER-BOUND-000))
     DO
     (CL:SETQ ELT
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:WHEN (CL:= I N) (PUSH NEWELEMENTS ELEMENT))
     (PUSH NEWELEMENTS ELT) (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:WHEN (CL:= N NELEMENTS) (PUSH NEWELEMENTS ELEMENT))
   (CREATE-LOGICAL-LIST (REVERSE NEWELEMENTS))))

;;; (DEFUN (/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (LISTARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (LISTSKOLEM (ARGUMENT-BOUND-TO LISTARG))
    (MINARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (MINVALUE (ARGUMENT-BOUND-TO MINARG)) (MINIMUM NULL)
    (MISSINGNUMBERS? CL:NIL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ LISTSKOLEM NULL))
     (CL:NOT (LOGICAL-COLLECTION? LISTSKOLEM)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Non list appears in second argument to 'MINIMUM-OF-NUMBERS'" EOL
     EOL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET* ((LISTVALUE (ASSERTED-COLLECTION-MEMBERS LISTSKOLEM CL:T)))
    (CL:WHEN (EMPTY? LISTVALUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:LET* ((V NULL) (ITER-000 (%LIST.THE-CONS-LIST LISTVALUE)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ V (%%VALUE ITER-000))
      (CL:IF (ISA? V SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (CL:WHEN
        (CL:OR (CL:EQ MINIMUM NULL)
         (|/PL-KERNEL-KB/ARITHMETIC-LESS-TEST| V MINIMUM))
        (CL:SETQ MINIMUM V))
       (CL:SETQ MISSINGNUMBERS? CL:T))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:WHEN (CL:EQ MINIMUM NULL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:WHEN MISSINGNUMBERS?
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ MINVALUE NULL))
       (ISA? MINVALUE SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (|/PL-KERNEL-KB/ARITHMETIC-GREATER-TEST| MINVALUE MINIMUM))
      (CL:PROGN (SET-FRAME-TRUTH-VALUE FRAME FALSE-TRUTH-VALUE)
       (CL:RETURN-FROM |/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST|
        KWD-SPECIALISTS-TERMINAL-FAILURE))
      (CL:PROGN (SET-FRAME-TRUTH-VALUE FRAME UNKNOWN-TRUTH-VALUE)
       (CL:RETURN-FROM |/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST|
        KWD-SPECIALISTS-FAILURE))))
    (SELECT-TEST-RESULT (BIND-ARGUMENT-TO-VALUE? MINARG MINIMUM CL:T)
     CL:T FRAME))))

;;; (DEFUN (/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (LISTARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (LISTSKOLEM (ARGUMENT-BOUND-TO LISTARG))
    (MAXARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (MAXVALUE (ARGUMENT-BOUND-TO MAXARG)) (MAXIMUM NULL)
    (MISSINGNUMBERS? CL:NIL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ LISTSKOLEM NULL))
     (CL:NOT (LOGICAL-COLLECTION? LISTSKOLEM)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Non list appears in second argument to 'MAXIMUM-OF-NUMBERS'" EOL
     EOL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET* ((LISTVALUE (ASSERTED-COLLECTION-MEMBERS LISTSKOLEM CL:T)))
    (CL:WHEN (EMPTY? LISTVALUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:LET* ((V NULL) (ITER-000 (%LIST.THE-CONS-LIST LISTVALUE)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ V (%%VALUE ITER-000))
      (CL:IF (ISA? V SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (CL:WHEN
        (CL:OR (CL:EQ MAXIMUM NULL)
         (|/PL-KERNEL-KB/ARITHMETIC-GREATER-TEST| V MAXIMUM))
        (CL:SETQ MAXIMUM V))
       (CL:SETQ MISSINGNUMBERS? CL:T))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:WHEN (CL:EQ MAXIMUM NULL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:WHEN MISSINGNUMBERS?
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ MAXVALUE NULL))
       (ISA? MAXVALUE SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (|/PL-KERNEL-KB/ARITHMETIC-LESS-TEST| MAXVALUE MAXIMUM))
      (CL:PROGN (SET-FRAME-TRUTH-VALUE FRAME FALSE-TRUTH-VALUE)
       (CL:RETURN-FROM |/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST|
        KWD-SPECIALISTS-TERMINAL-FAILURE))
      (CL:PROGN (SET-FRAME-TRUTH-VALUE FRAME UNKNOWN-TRUTH-VALUE)
       (CL:RETURN-FROM |/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST|
        KWD-SPECIALISTS-FAILURE))))
    (SELECT-TEST-RESULT (BIND-ARGUMENT-TO-VALUE? MAXARG MAXIMUM CL:T)
     CL:T FRAME))))

;;; (DEFUN (/PL-KERNEL-KB/SUM-OF-NUMBERS-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/SUM-OF-NUMBERS-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (LISTARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (LISTSKOLEM (ARGUMENT-BOUND-TO LISTARG))
    (SUMARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (SUM (WRAP-INTEGER 0)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ LISTSKOLEM NULL))
     (CL:NOT (LOGICAL-COLLECTION? LISTSKOLEM)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Non list appears in second argument to 'SUM-OF-NUMBERS'" EOL EOL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/SUM-OF-NUMBERS-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET* ((LISTVALUE (ASSERTED-COLLECTION-MEMBERS LISTSKOLEM CL:T)))
    (CL:LET* ((V NULL) (ITER-000 (%LIST.THE-CONS-LIST LISTVALUE)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ V (%%VALUE ITER-000))
      (CL:IF (ISA? V SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (CL:SETQ SUM (|/PL-KERNEL-KB/PLUS-COMPUTATION| V SUM))
       (CL:RETURN-FROM |/PL-KERNEL-KB/SUM-OF-NUMBERS-SPECIALIST|
        KWD-SPECIALISTS-TERMINAL-FAILURE))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (SELECT-TEST-RESULT (BIND-ARGUMENT-TO-VALUE? SUMARG SUM CL:T) CL:T
     FRAME))))

;;; (DEFUN (/PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (LISTARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (LISTSKOLEM (ARGUMENT-BOUND-TO LISTARG))
    (MEANARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (SUM (WRAP-INTEGER 0)) (NUMBERCOUNT 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUMBERCOUNT))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ LISTSKOLEM NULL))
     (CL:NOT (LOGICAL-COLLECTION? LISTSKOLEM)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Non list appears in second argument to 'MEAN-OF-NUMBERS'" EOL
     EOL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET* ((LISTVALUE (ASSERTED-COLLECTION-MEMBERS LISTSKOLEM CL:T)))
    (CL:WHEN (EMPTY? LISTVALUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:LET* ((V NULL) (ITER-000 (%LIST.THE-CONS-LIST LISTVALUE)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ V (%%VALUE ITER-000))
      (CL:IF (ISA? V SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (CL:PROGN (CL:SETQ SUM (|/PL-KERNEL-KB/PLUS-COMPUTATION| V SUM))
        (CL:SETQ NUMBERCOUNT (CL:1+ NUMBERCOUNT)))
       (CL:RETURN-FROM |/PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST|
        KWD-SPECIALISTS-FAILURE))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:IF (CL:= NUMBERCOUNT 0) KWD-SPECIALISTS-TERMINAL-FAILURE
     (SELECT-TEST-RESULT
      (BIND-ARGUMENT-TO-VALUE? MEANARG
       (|/PL-KERNEL-KB/DIVIDE-COMPUTATION| SUM
        (WRAP-INTEGER NUMBERCOUNT))
       CL:T)
      CL:T FRAME)))))

;;; (DEFUN (/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (LISTARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (SORTLIST (NEW-LIST)) (LISTSKOLEM (ARGUMENT-BOUND-TO LISTARG))
    (MEDIANARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (NUMBERCOUNT 0) (RESULT NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUMBERCOUNT))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ LISTSKOLEM NULL))
     (CL:NOT (LOGICAL-COLLECTION? LISTSKOLEM)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Non list appears in second argument to 'MEDIAN-OF-NUMBERS'" EOL
     EOL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET* ((LISTVALUE (ASSERTED-COLLECTION-MEMBERS LISTSKOLEM CL:T)))
    (CL:WHEN (EMPTY? LISTVALUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:LET* ((V NULL) (ITER-000 (%LIST.THE-CONS-LIST LISTVALUE)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ V (%%VALUE ITER-000))
      (CL:IF (ISA? V SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (PUSH SORTLIST V)
       (CL:RETURN-FROM |/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST|
        KWD-SPECIALISTS-FAILURE))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:SETQ NUMBERCOUNT (LENGTH SORTLIST))
    (CL:WHEN (CL:= NUMBERCOUNT 0)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (SORT SORTLIST (CL:FUNCTION |/PL-KERNEL-KB/ARITHMETIC-LESS-TEST|))
    (CL:IF (CL:LOGBITP 0 NUMBERCOUNT)
     (CL:SETQ RESULT
      (NTH SORTLIST (CL:TRUNCATE (CL:/ (CL:1- NUMBERCOUNT) 2.0d0))))
     (CL:SETQ RESULT
      (|/PL-KERNEL-KB/DIVIDE-COMPUTATION|
       (|/PL-KERNEL-KB/PLUS-COMPUTATION|
        (NTH SORTLIST (CL:TRUNCATE (CL:1- (CL:/ NUMBERCOUNT 2.0d0))))
        (NTH SORTLIST (CL:TRUNCATE (CL:/ NUMBERCOUNT 2.0d0))))
       (WRAP-INTEGER 2))))
    (SELECT-TEST-RESULT (BIND-ARGUMENT-TO-VALUE? MEDIANARG RESULT CL:T)
     CL:T FRAME))))

;;; (DEFUN (COMPUTE-VARIANCE-OR-STANDARD-DEVIATION KEYWORD) ...)

(CL:DEFUN COMPUTE-VARIANCE-OR-STANDARD-DEVIATION (FRAME LASTMOVE STANDARD-DEVIATION?)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (LISTARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (LISTSKOLEM (ARGUMENT-BOUND-TO LISTARG))
    (RESULTARGG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (SUM 0.0d0) (SUM2 0.0d0) (X 0.0d0) (NUMBERCOUNT 0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SUM SUM2 X)
    (CL:TYPE CL:FIXNUM NUMBERCOUNT))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ LISTSKOLEM NULL))
     (CL:NOT (LOGICAL-COLLECTION? LISTSKOLEM)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Non list appears in second argument to 'VARIANCE or STANDARD-DEVIATION'"
     EOL EOL)
    (CL:RETURN-FROM COMPUTE-VARIANCE-OR-STANDARD-DEVIATION
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET* ((LISTVALUE (ASSERTED-COLLECTION-MEMBERS LISTSKOLEM CL:T)))
    (CL:WHEN (EMPTY? LISTVALUE)
     (CL:RETURN-FROM COMPUTE-VARIANCE-OR-STANDARD-DEVIATION
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:LET* ((V NULL) (ITER-000 (%LIST.THE-CONS-LIST LISTVALUE)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ V (%%VALUE ITER-000))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE V)))
       (CL:COND
        ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
         (CL:PROGN
          (CL:SETQ X
           (CL:FLOAT (%INTEGER-WRAPPER.WRAPPER-VALUE V) 0.0d0))))
        ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
         (CL:PROGN (CL:SETQ X (%FLOAT-WRAPPER.WRAPPER-VALUE V))))
        (CL:T (SET-FRAME-TRUTH-VALUE FRAME UNKNOWN-TRUTH-VALUE)
         (CL:RETURN-FROM COMPUTE-VARIANCE-OR-STANDARD-DEVIATION
          KWD-SPECIALISTS-FAILURE))))
      (CL:SETQ SUM (CL:+ SUM X)) (CL:SETQ SUM2 (CL:+ SUM2 (CL:* X X)))
      (CL:SETQ NUMBERCOUNT (CL:1+ NUMBERCOUNT))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:CASE NUMBERCOUNT (0 KWD-SPECIALISTS-TERMINAL-FAILURE)
     (1
      (SELECT-TEST-RESULT
       (BIND-ARGUMENT-TO-VALUE? RESULTARGG (WRAP-FLOAT 0.0d0) CL:T)
       CL:T FRAME))
     (CL:OTHERWISE
      (CL:SETQ X
       (CL:/ (CL:- SUM2 (CL:/ (CL:* SUM SUM) NUMBERCOUNT))
        (CL:1- NUMBERCOUNT)))
      (CL:WHEN STANDARD-DEVIATION?
       (CL:SETQ X (CL:THE CL:DOUBLE-FLOAT (CL:SQRT X))))
      (SELECT-TEST-RESULT
       (BIND-ARGUMENT-TO-VALUE? RESULTARGG (WRAP-FLOAT X) CL:T) CL:T
       FRAME))))))

;;; (DEFUN (/PL-KERNEL-KB/STANDARD-DEVIATION-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/STANDARD-DEVIATION-SPECIALIST| (FRAME LASTMOVE)
  (COMPUTE-VARIANCE-OR-STANDARD-DEVIATION FRAME LASTMOVE CL:T))

;;; (DEFUN (/PL-KERNEL-KB/VARIANCE-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/VARIANCE-SPECIALIST| (FRAME LASTMOVE)
  (COMPUTE-VARIANCE-OR-STANDARD-DEVIATION FRAME LASTMOVE CL:NIL))

;;; (DEFUN HELP-DERIVE-PARTITION-MEMBERSHIPS ...)

(CL:DEFUN HELP-DERIVE-PARTITION-MEMBERSHIPS (SELF SUPER TUPLES)
  (CL:LET*
   ((MC NULL)
    (ITER-000
     (APPLY-CACHED-RETRIEVE
      (LIST* SYM-SPECIALISTS-LOGIC-?SUPER SYM-SPECIALISTS-LOGIC-?MDC
       NIL)
      (LIST* SYM-SPECIALISTS-STELLA-AND
       (LIST* SYM-SPECIALISTS-LOGIC-MEMBER-OF
        SYM-SPECIALISTS-LOGIC-?SUPER SYM-SPECIALISTS-LOGIC-?MDC NIL)
       (LIST* SYM-SPECIALISTS-LOGIC-MUTUALLY-DISJOINT-COLLECTION
        SYM-SPECIALISTS-LOGIC-?MDC NIL)
       NIL)
      (CONS-LIST SUPER NULL) (CONS-LIST)
      SYM-SPECIALISTS-LOGIC-F-HELP-DERIVE-PARTITION-MEMBERSHIPS-QUERY-000)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ MC (%%VALUE ITER-000))
    (CL:LET*
     ((MDCPROPOSITION
       (%%VALUE
        (CONSIFY
         (ALL-TRUE-DEPENDENT-PROPOSITIONS MC
          SGT-SPECIALISTS-PL-KERNEL-KB-MUTUALLY-DISJOINT-COLLECTION
          CL:NIL)))))
     (PUSH TUPLES
      (ASSERT-TUPLE SGT-SPECIALISTS-PL-KERNEL-KB-PARTITION-MEMBERSHIP
       (CONS-LIST SELF MDCPROPOSITION SUPER))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:LET*
   ((P NULL)
    (ITER-001
     (ALL-TRUE-DEPENDENT-PROPOSITIONS SUPER
      SGT-SPECIALISTS-PL-KERNEL-KB-DISJOINT CL:NIL)))
   (CL:LOOP WHILE (NEXT? ITER-001) DO
    (CL:SETQ P (%ITERATOR.VALUE ITER-001))
    (PUSH TUPLES
     (ASSERT-TUPLE SGT-SPECIALISTS-PL-KERNEL-KB-PARTITION-MEMBERSHIP
      (CONS-LIST SELF P SUPER))))))

;;; (DEFUN (DERIVE-PARTITION-MEMBERSHIPS? BOOLEAN) ...)

(CL:DEFUN DERIVE-PARTITION-MEMBERSHIPS? (SELF)
  (CL:LET* ((TUPLES (LIST)))
   (HELP-DERIVE-PARTITION-MEMBERSHIPS SELF SELF TUPLES)
   (CL:LET* ((SUPER NULL) (ITER-000 (ALL-SUPERCOLLECTIONS SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ SUPER (%ITERATOR.VALUE ITER-000))
     (HELP-DERIVE-PARTITION-MEMBERSHIPS SELF SUPER TUPLES)))
   (NON-EMPTY? TUPLES)))

;;; (DEFUN (/PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (ARGUMENTVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       0))))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:OR (CL:EQ ARGUMENTVALUE NULL)
     (CL:NOT (ISA? ARGUMENTVALUE SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)))
    (CL:RETURN-FROM |/PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:LET* ((VALUE-000 NULL))
    (CL:LET*
     ((P NULL)
      (ITER-000
       (ALLOCATE-ITERATOR
        (UNFILTERED-DEPENDENT-PROPOSITIONS ARGUMENTVALUE
         SGT-SPECIALISTS-PL-KERNEL-KB-HAS-PARTITION-MEMBERSHIP))))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ P (%ITERATOR.VALUE ITER-000))
      (CL:WHEN
       (CL:EQ (%PROPOSITION.OPERATOR P)
        SGT-SPECIALISTS-PL-KERNEL-KB-HAS-PARTITION-MEMBERSHIP)
       (CL:SETQ VALUE-000 P) (CL:RETURN))))
    (CL:LET* ((HASPARTITIONPROPOSITION VALUE-000))
     (CL:WHEN (CL:NOT (CL:EQ HASPARTITIONPROPOSITION NULL))
      (CL:COND
       ((TRUE? HASPARTITIONPROPOSITION)
        (CL:RETURN-FROM
         |/PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST|
         KWD-SPECIALISTS-FINAL-SUCCESS))
       ((FALSE? HASPARTITIONPROPOSITION)
        (CL:RETURN-FROM
         |/PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST|
         KWD-SPECIALISTS-TERMINAL-FAILURE))))
     (CL:IF (DERIVE-PARTITION-MEMBERSHIPS? ARGUMENTVALUE)
      (CL:PROGN
       (UPDATE-PROPERTY ARGUMENTVALUE
        SGT-SPECIALISTS-PL-KERNEL-KB-HAS-PARTITION-MEMBERSHIP
        KWD-SPECIALISTS-ASSERT-TRUE)
       KWD-SPECIALISTS-FINAL-SUCCESS)
      (CL:PROGN
       (UPDATE-PROPERTY ARGUMENTVALUE
        SGT-SPECIALISTS-PL-KERNEL-KB-HAS-PARTITION-MEMBERSHIP
        KWD-SPECIALISTS-ASSERT-FALSE)
       KWD-SPECIALISTS-TERMINAL-FAILURE))))))

;;; (DEFUN (/PL-KERNEL-KB/REFUTATION-DISJOINT-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/REFUTATION-DISJOINT-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (ARG1
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       0)))
    (ARG2
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       1))))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:OR (CL:EQ ARG1 NULL) (CL:EQ ARG2 NULL)
     (CL:NOT (ISA? ARG1 SGT-SPECIALISTS-LOGIC-DESCRIPTION))
     (CL:NOT (ISA? ARG2 SGT-SPECIALISTS-LOGIC-DESCRIPTION))
     (CL:> (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION)) 2))
    (CL:RETURN-FROM |/PL-KERNEL-KB/REFUTATION-DISJOINT-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (PUSH-MONOTONIC-WORLD) (INITIALIZE-INFERENCE-WORLD *CONTEXT*)
   (CL:HANDLER-CASE
    (CL:LET*
     ((SKOLEM (CREATE-HYPOTHESIZED-INSTANCE "refutation-disjoint")))
     (CL:LET* ((C NULL) (ITER-000 (CONS-LIST ARG1 ARG2)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ C (%%VALUE ITER-000))
       (ASSERT-MEMBER-OF-PROPOSITION SKOLEM C)
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (ELABORATE-INSTANCE SKOLEM))
    (CLASH () (POP-WORLD)
     (CL:RETURN-FROM |/PL-KERNEL-KB/REFUTATION-DISJOINT-SPECIALIST|
      KWD-SPECIALISTS-FINAL-SUCCESS)))
   (POP-WORLD) KWD-SPECIALISTS-FAILURE))

;;; (DEFUN (/PL-KERNEL-KB/EMPTY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/EMPTY-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (ARGVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       0)))
    (EMPTY? (EMPTY-TERM? ARGVALUE)))
   (CL:SETQ LASTMOVE LASTMOVE) (SELECT-PROOF-RESULT EMPTY? CL:NIL CL:T)))

;;; (DEFUN (EMPTY-TERM? BOOLEAN) ...)

(CL:DEFUN EMPTY-TERM? (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:OR (CHEAP-EMPTY-TERM? SELF) (EXPENSIVE-EMPTY-TERM? SELF))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-COLLECTION)
     (CL:PROGN (CL:= (LENGTH SELF) 0)))
    (CL:T CL:NIL))))

;;; (DEFUN (CHEAP-EMPTY-TERM? BOOLEAN) ...)

(CL:DEFUN CHEAP-EMPTY-TERM? (SELF)
  (CL:WHEN (SKOLEM? SELF)
   (CL:LET* ((DEFININGPROPOSITION (%SKOLEM.DEFINING-PROPOSITION SELF)))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ DEFININGPROPOSITION NULL))
      (COLLECTIONOF-PROPOSITION? DEFININGPROPOSITION)
      (CL:= (LENGTH (%PROPOSITION.ARGUMENTS DEFININGPROPOSITION)) 1))
     (CL:RETURN-FROM CHEAP-EMPTY-TERM? CL:T))))
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:IF (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-EMPTY)
    (CL:SETQ TEST-VALUE-000 CL:T)
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((SUPER NULL)
       (ITER-000 (ALL-DIRECT-SUPERCOLLECTIONS SELF CL:NIL)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ SUPER (%ITERATOR.VALUE ITER-000))
       (CL:WHEN (CHEAP-EMPTY-TERM? SUPER) (CL:SETQ FOUND?-000 CL:T)
        (CL:RETURN))))
     (CL:SETQ TEST-VALUE-000 FOUND?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (EXPENSIVE-EMPTY-TERM? BOOLEAN) ...)

(CL:DEFUN EXPENSIVE-EMPTY-TERM? (SELF)
  (CL:LET*
   ((SUPER1 NULL) (ITER-000 (ALL-DIRECT-SUPERCOLLECTIONS SELF CL:NIL)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ SUPER1 (%ITERATOR.VALUE ITER-000))
    (CL:LET*
     ((SUPER2 NULL)
      (ITER-001 (ALL-DIRECT-SUPERCOLLECTIONS SELF CL:NIL)))
     (CL:LOOP WHILE (NEXT? ITER-001) DO
      (CL:SETQ SUPER2 (%ITERATOR.VALUE ITER-001))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ SUPER1 SUPER2))
        (DISJOINT-TERMS? SUPER1 SUPER2))
       (CL:RETURN-FROM EXPENSIVE-EMPTY-TERM? CL:T))))))
  CL:NIL)

;;; (DEFUN (/PL-KERNEL-KB/CONTEXT-OF-COMPUTATION CONTEXT) ...)

(CL:DEFUN |/PL-KERNEL-KB/CONTEXT-OF-COMPUTATION| (INSTANCE)
  (HOME-MODULE INSTANCE))

(CL:DEFUN NEW-SAVED-CONTEXT-PROOF-ADJUNCT ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-SAVED-CONTEXT-PROOF-ADJUNCT))
   (CL:SETF (%SAVED-CONTEXT-PROOF-ADJUNCT.DOWN-FRAME SELF) NULL)
   (CL:SETF (%SAVED-CONTEXT-PROOF-ADJUNCT.SAVED-CONTEXT SELF) NULL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SAVED-CONTEXT-PROOF-ADJUNCT))
  SGT-SPECIALISTS-LOGIC-SAVED-CONTEXT-PROOF-ADJUNCT)

(CL:DEFUN ACCESS-SAVED-CONTEXT-PROOF-ADJUNCT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-SAVED-CONTEXT)
    (CL:IF SETVALUE?
     (CL:SETF (%SAVED-CONTEXT-PROOF-ADJUNCT.SAVED-CONTEXT SELF) VALUE)
     (CL:SETQ VALUE
      (%SAVED-CONTEXT-PROOF-ADJUNCT.SAVED-CONTEXT SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-DOWN-FRAME)
    (CL:IF SETVALUE?
     (CL:SETF (%SAVED-CONTEXT-PROOF-ADJUNCT.DOWN-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%SAVED-CONTEXT-PROOF-ADJUNCT.DOWN-FRAME SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (/PL-KERNEL-KB/IST-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/IST-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (CONTEXTVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       0)))
    (ADJUNCT
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT NULL)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-DOWN)
     (CL:WHEN (CL:EQ ADJUNCT NULL)
      (CL:LET*
       ((PROPOSITIONVALUE
         (ARGUMENT-BOUND-TO
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
           1))))
       (CL:WHEN
        (CL:OR (CL:EQ CONTEXTVALUE NULL) (CL:EQ PROPOSITIONVALUE NULL)
         (CL:NOT (ISA? CONTEXTVALUE SGT-SPECIALISTS-STELLA-CONTEXT)))
        (CL:RETURN-FROM |/PL-KERNEL-KB/IST-SPECIALIST|
         KWD-SPECIALISTS-TERMINAL-FAILURE))
       (CL:LET* ((SELF-000 (NEW-SAVED-CONTEXT-PROOF-ADJUNCT)))
        (CL:SETF (%SAVED-CONTEXT-PROOF-ADJUNCT.SAVED-CONTEXT SELF-000)
         *CONTEXT*)
        (CL:SETF (%SAVED-CONTEXT-PROOF-ADJUNCT.DOWN-FRAME SELF-000)
         (CREATE-DOWN-FRAME FRAME PROPOSITIONVALUE))
        (CL:SETQ ADJUNCT SELF-000))
       (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
        SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT ADJUNCT NULL)))
     (CL:SETF (%CONTROL-FRAME.DOWN FRAME)
      (%SAVED-CONTEXT-PROOF-ADJUNCT.DOWN-FRAME ADJUNCT))
     (CHANGE-CONTEXT (BEST-INFERENCE-CACHE CONTEXTVALUE))
     KWD-SPECIALISTS-MOVE-DOWN)
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-TRUE)
     (PROPAGATE-FRAME-TRUTH-VALUE (%CONTROL-FRAME.RESULT FRAME) FRAME)
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT
        (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
         NULL)))
      (PROPAGATE-FRAME-PARTIAL-TRUTH
       (%CONTROL-FRAME.PARTIAL-MATCH-FRAME
        (%CONTROL-FRAME.RESULT FRAME))
       FRAME))
     (CL:WHEN *RECORD-JUSTIFICATIONS?*
      (CL:LET* ((SELF-001 (NEW-JUSTIFICATION)))
       (CL:SETF (%JUSTIFICATION.INFERENCE-RULE SELF-001)
        KWD-SPECIALISTS-IST-INTRODUCTION)
       (CL:SETF (%JUSTIFICATION.ANTECEDENTS SELF-001)
        (CONS
         (DYNAMIC-SLOT-VALUE
          (%CONTROL-FRAME.DYNAMIC-SLOTS (%CONTROL-FRAME.RESULT FRAME))
          SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)
         NIL))
       (RECORD-GOAL-JUSTIFICATION FRAME SELF-001)))
     (CHANGE-CONTEXT
      (%SAVED-CONTEXT-PROOF-ADJUNCT.SAVED-CONTEXT ADJUNCT))
     (CL:COND
      ((CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
       (CL:SETF (%SAVED-CONTEXT-PROOF-ADJUNCT.DOWN-FRAME ADJUNCT)
        (%CONTROL-FRAME.DOWN FRAME))
       (CL:SETF (%CONTROL-FRAME.DOWN FRAME) NULL)
       KWD-SPECIALISTS-CONTINUING-SUCCESS)
      (CL:T KWD-SPECIALISTS-FINAL-SUCCESS)))
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-FAIL)
     (PROPAGATE-FRAME-TRUTH-VALUE (%CONTROL-FRAME.RESULT FRAME) FRAME)
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT
        (CL:EQ (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
         NULL)))
      (PROPAGATE-FRAME-PARTIAL-TRUTH
       (%CONTROL-FRAME.PARTIAL-MATCH-FRAME
        (%CONTROL-FRAME.RESULT FRAME))
       FRAME))
     (CL:WHEN *RECORD-JUSTIFICATIONS?*
      (RECORD-PRIMITIVE-JUSTIFICATION FRAME KWD-SPECIALISTS-UP-FAIL))
     (CHANGE-CONTEXT
      (%SAVED-CONTEXT-PROOF-ADJUNCT.SAVED-CONTEXT ADJUNCT))
     KWD-SPECIALISTS-FAILURE)
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" LASTMOVE "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFGLOBAL *ACCELERATE-FRAME-COMPUTATIONS?* ...)

(CL:DEFVAR *ACCELERATE-FRAME-COMPUTATIONS?* CL:T
  "Used to test how big is the effect of the frame
specialists.")

;;; (DEFUN (GET-ROLESET-OF SKOLEM) ...)

(CL:DEFUN GET-ROLESET-OF (RELATION INSTANCE)
  (%%VALUE
   (ALL-RELATION-VALUES SGT-SPECIALISTS-PL-KERNEL-KB-THE-ROLESET
    (CONS-LIST RELATION INSTANCE))))

;;; (DEFUN (COMPUTE-STORED-BOUND-ON-ROLESET INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:T) CL:FIXNUM)
  COMPUTE-STORED-BOUND-ON-ROLESET))
(CL:DEFUN COMPUTE-STORED-BOUND-ON-ROLESET (RELATION INSTANCE LOWERORUPPER)
  (CL:LET*
   ((ROLESET (GET-ROLESET-OF RELATION INSTANCE)) (CARDINALITY NULL)
    (INTERVALCACHE NULL) (BOUND NULL))
   (CL:WHEN (CL:EQ ROLESET NULL)
    (CL:RETURN-FROM COMPUTE-STORED-BOUND-ON-ROLESET NULL-INTEGER))
   (CL:SETQ CARDINALITY
    (ACCESS-BINARY-VALUE ROLESET
     SGT-SPECIALISTS-PL-KERNEL-KB-CARDINALITY))
   (CL:WHEN (CL:NOT (CL:EQ CARDINALITY NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE CARDINALITY)))
     (CL:COND
      ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
       (CL:PROGN
        (CL:RETURN-FROM COMPUTE-STORED-BOUND-ON-ROLESET
         (%INTEGER-WRAPPER.WRAPPER-VALUE CARDINALITY))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-SKOLEM)
       (CL:PROGN
        (CL:LET* ()
         (CL:SETQ INTERVALCACHE
          (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| CARDINALITY))
         (CL:WHEN (CL:NOT (CL:EQ INTERVALCACHE NULL))
          (CL:COND
           ((CL:EQ LOWERORUPPER KWD-SPECIALISTS-LOWER)
            (CL:SETQ BOUND
             (|/PL-KERNEL-KB/%INTERVAL-CACHE.LOWER-BOUND|
              INTERVALCACHE)))
           ((CL:EQ LOWERORUPPER KWD-SPECIALISTS-UPPER)
            (CL:SETQ BOUND
             (|/PL-KERNEL-KB/%INTERVAL-CACHE.UPPER-BOUND|
              INTERVALCACHE)))
           (CL:T
            (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
              LOWERORUPPER "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
          (CL:WHEN
           (CL:AND (CL:NOT (CL:EQ BOUND NULL))
            (ISA? BOUND SGT-SPECIALISTS-STELLA-INTEGER-WRAPPER))
           (CL:RETURN-FROM COMPUTE-STORED-BOUND-ON-ROLESET
            (UNWRAP-INTEGER BOUND)))))))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
         TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))
   NULL-INTEGER))

;;; (DEFUN (COMPUTE-MINIMUM-CARDINALITY INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM)
  COMPUTE-MINIMUM-CARDINALITY))
(CL:DEFUN COMPUTE-MINIMUM-CARDINALITY (RELATION INSTANCE)
  (CL:LET* ((*REVERSEPOLARITY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (CL:LET*
    ((RELATIONREF
      (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE RELATION)))
    (CL:WHEN
     (CL:AND (SINGLE-VALUED-TERM? RELATION)
      (CL:NOT (CL:EQ (ACCESS-BINARY-VALUE INSTANCE RELATIONREF) NULL)))
     (CL:RETURN-FROM COMPUTE-MINIMUM-CARDINALITY 1))
    (CL:LET*
     ((MINCARDS
       (CONS-LIST (WRAP-INTEGER 0)
        (WRAP-INTEGER
         (COMPUTE-STORED-BOUND-ON-ROLESET RELATION INSTANCE
          KWD-SPECIALISTS-LOWER)))))
     (CL:SETQ MINCARDS
      (CONS
       (WRAP-INTEGER (LENGTH (ALL-SLOT-VALUES INSTANCE RELATIONREF)))
       MINCARDS))
     (CL:LET*
      ((SUBR NULL) (ITER-000 (ALL-SUBRELATIONS RELATION CL:NIL)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SUBR (%%VALUE ITER-000))
       (CL:SETQ MINCARDS
        (CONS
         (WRAP-INTEGER
          (COMPUTE-STORED-BOUND-ON-ROLESET SUBR INSTANCE
           KWD-SPECIALISTS-LOWER))
         MINCARDS))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:LET*
      ((MAXMIN (%INTEGER-WRAPPER.WRAPPER-VALUE (%%VALUE MINCARDS))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM MAXMIN))
      (CL:LET* ((LB NULL) (ITER-001 (%%REST MINCARDS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ LB (%%VALUE ITER-001))
        (CL:WHEN (CL:NOT (CL:EQ LB NULL))
         (CL:SETQ MAXMIN
          (MAX MAXMIN (%INTEGER-WRAPPER.WRAPPER-VALUE LB))))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      MAXMIN)))))

;;; (DEFUN (/PL-KERNEL-KB/RANGE-MIN-CARDINALITY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/RANGE-MIN-CARDINALITY-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (RELATION
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       0)))
    (INSTANCE
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       1)))
    (MINCARDARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      2))
    (MINCARDVALUE (ARGUMENT-BOUND-TO MINCARDARG))
    (COMPUTEDVALUE NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COMPUTEDVALUE))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:NOT *ACCELERATE-FRAME-COMPUTATIONS?*)
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-MIN-CARDINALITY-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:WHEN (CL:OR (CL:EQ RELATION NULL) (CL:EQ INSTANCE NULL))
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-MIN-CARDINALITY-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:SETQ TEST-VALUE-000
     (ISA? RELATION SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ()
      (CL:SETQ COMPUTEDVALUE
       (COMPUTE-MINIMUM-CARDINALITY RELATION INSTANCE))
      (CL:SETQ TEST-VALUE-000
       (CL:NOT (CL:= COMPUTEDVALUE NULL-INTEGER)))))
    (CL:IF TEST-VALUE-000
     (CL:LET* ((TV UNKNOWN-TRUTH-VALUE))
      (CL:IF
       (CL:AND (CL:NOT (CL:EQ MINCARDVALUE NULL))
        (ISA? MINCARDVALUE SGT-SPECIALISTS-STELLA-INTEGER-WRAPPER))
       (CL:IF
        (CL:>= COMPUTEDVALUE (NUMBER-WRAPPER-TO-FLOAT MINCARDVALUE))
        (CL:PROGN (CL:SETQ TV TRUE-TRUTH-VALUE))
        (CL:IF (CLOSED-TERM? RELATION)
         (CL:PROGN (CL:SETQ TV FALSE-TRUTH-VALUE))
         (CL:LET* ((TEST-VALUE-001 CL:NIL))
          (CL:LET* ()
           (CL:SETQ COMPUTEDVALUE
            (COMPUTE-MAXIMUM-CARDINALITY RELATION INSTANCE))
           (CL:SETQ TEST-VALUE-001
            (CL:NOT (CL:= COMPUTEDVALUE NULL-INTEGER))))
          (CL:WHEN TEST-VALUE-001
           (CL:SETQ TEST-VALUE-001
            (< COMPUTEDVALUE (NUMBER-WRAPPER-TO-FLOAT MINCARDVALUE))))
          (CL:WHEN TEST-VALUE-001 (CL:SETQ TV FALSE-TRUTH-VALUE)))))
       (CL:IF
        (BIND-ARGUMENT-TO-VALUE? MINCARDARG
         (WRAP-INTEGER COMPUTEDVALUE) CL:T)
        (CL:SETQ TV TRUE-TRUTH-VALUE) (CL:SETQ TV FALSE-TRUTH-VALUE)))
      (CL:WHEN *REVERSEPOLARITY?* (CL:SETQ TV (INVERT-TRUTH-VALUE TV)))
      (SET-FRAME-TRUTH-VALUE FRAME TV)
      (CL:COND
       ((CL:OR (CL:EQ TV TRUE-TRUTH-VALUE)
         (CL:EQ TV DEFAULT-TRUE-TRUTH-VALUE))
        KWD-SPECIALISTS-FINAL-SUCCESS)
       ((CL:OR (CL:EQ TV FALSE-TRUTH-VALUE)
         (CL:EQ TV DEFAULT-FALSE-TRUTH-VALUE))
        KWD-SPECIALISTS-FAILURE)
       (CL:T KWD-SPECIALISTS-FAILURE)))
     KWD-SPECIALISTS-FAILURE))))

;;; (DEFUN (COMPUTE-MAXIMUM-CARDINALITY INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM)
  COMPUTE-MAXIMUM-CARDINALITY))
(CL:DEFUN COMPUTE-MAXIMUM-CARDINALITY (RELATION INSTANCE)
  (CL:LET* ((*REVERSEPOLARITY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (CL:LET*
    ((RELATIONREF
      (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE RELATION))
     (SINGLEVALUED? (SINGLE-VALUED-TERM? RELATION)))
    (CL:WHEN
     (CL:AND SINGLEVALUED?
      (CL:NOT (CL:EQ (ACCESS-BINARY-VALUE INSTANCE RELATIONREF) NULL)))
     (CL:RETURN-FROM COMPUTE-MAXIMUM-CARDINALITY 1))
    (CL:LET*
     ((MAXCARDS
       (CONS-LIST
        (WRAP-INTEGER
         (COMPUTE-STORED-BOUND-ON-ROLESET RELATION INSTANCE
          KWD-SPECIALISTS-UPPER)))))
     (CL:WHEN SINGLEVALUED?
      (CL:SETQ MAXCARDS (CONS (WRAP-INTEGER 1) MAXCARDS)))
     (CL:LET* ((ROLESET (GET-ROLESET-OF RELATION INSTANCE)))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ ROLESET NULL)) (EMPTY-TERM? ROLESET))
       (CL:RETURN-FROM COMPUTE-MAXIMUM-CARDINALITY 0)))
     (CL:WHEN (CLOSED-TERM? RELATION)
      (CL:SETQ MAXCARDS
       (CONS
        (WRAP-INTEGER (COMPUTE-MINIMUM-CARDINALITY RELATION INSTANCE))
        MAXCARDS)))
     (CL:LET*
      ((SUPERR NULL) (ITER-000 (ALL-SUPERRELATIONS RELATION CL:NIL)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SUPERR (%%VALUE ITER-000))
       (CL:SETQ MAXCARDS
        (CONS
         (WRAP-INTEGER
          (COMPUTE-STORED-BOUND-ON-ROLESET SUPERR INSTANCE
           KWD-SPECIALISTS-UPPER))
         MAXCARDS))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:LET*
      ((MINMAX (%INTEGER-WRAPPER.WRAPPER-VALUE (%%VALUE MAXCARDS))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM MINMAX))
      (CL:LET* ((UB NULL) (ITER-001 (%%REST MAXCARDS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ UB (%%VALUE ITER-001))
        (CL:WHEN (CL:NOT (CL:EQ UB NULL))
         (CL:SETQ MINMAX
          (MIN MINMAX (%INTEGER-WRAPPER.WRAPPER-VALUE UB))))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      MINMAX)))))

;;; (DEFUN (/PL-KERNEL-KB/RANGE-MAX-CARDINALITY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/RANGE-MAX-CARDINALITY-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (RELATION
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       0)))
    (INSTANCE
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       1)))
    (MAXCARDARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      2))
    (MAXCARDVALUE (ARGUMENT-BOUND-TO MAXCARDARG))
    (COMPUTEDVALUE NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COMPUTEDVALUE))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:NOT *ACCELERATE-FRAME-COMPUTATIONS?*)
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-MAX-CARDINALITY-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:WHEN (CL:OR (CL:EQ RELATION NULL) (CL:EQ INSTANCE NULL))
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-MAX-CARDINALITY-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:SETQ TEST-VALUE-000
     (ISA? RELATION SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ()
      (CL:SETQ COMPUTEDVALUE
       (COMPUTE-MAXIMUM-CARDINALITY RELATION INSTANCE))
      (CL:SETQ TEST-VALUE-000
       (CL:NOT (CL:= COMPUTEDVALUE NULL-INTEGER)))))
    (CL:IF TEST-VALUE-000
     (CL:LET*
      ((SUCCESS?
        (CL:IF
         (CL:AND (CL:NOT (CL:EQ MAXCARDVALUE NULL))
          (ISA? MAXCARDVALUE SGT-SPECIALISTS-STELLA-INTEGER-WRAPPER))
         (<= COMPUTEDVALUE (NUMBER-WRAPPER-TO-FLOAT MAXCARDVALUE))
         (BIND-ARGUMENT-TO-VALUE? MAXCARDARG
          (WRAP-INTEGER COMPUTEDVALUE) CL:T))))
      (SELECT-TEST-RESULT SUCCESS? CL:T FRAME))
     (CL:LET* ((TEST-VALUE-001 CL:NIL))
      (CL:SETQ TEST-VALUE-001 (CL:NOT (CL:EQ MAXCARDVALUE NULL)))
      (CL:WHEN TEST-VALUE-001
       (CL:SETQ TEST-VALUE-001
        (ISA? MAXCARDVALUE SGT-SPECIALISTS-STELLA-INTEGER-WRAPPER))
       (CL:WHEN TEST-VALUE-001
        (CL:LET* ()
         (CL:SETQ COMPUTEDVALUE
          (COMPUTE-MINIMUM-CARDINALITY RELATION INSTANCE))
         (CL:SETQ TEST-VALUE-001
          (CL:NOT (CL:= COMPUTEDVALUE NULL-INTEGER))))
        (CL:WHEN TEST-VALUE-001
         (CL:SETQ TEST-VALUE-001
          (> COMPUTEDVALUE (NUMBER-WRAPPER-TO-FLOAT MAXCARDVALUE))))))
      (CL:IF TEST-VALUE-001 (SELECT-TEST-RESULT CL:NIL CL:T FRAME)
       KWD-SPECIALISTS-FAILURE))))))

;;; (DEFUN (TEST-RANGE-TYPE? BOOLEAN) ...)

(CL:DEFUN TEST-RANGE-TYPE? (RELATION INSTANCE VALUETYPE)
  (CL:LET*
   ((RELATIONREF (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE RELATION))
    (VALUESURROGATE
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE VALUETYPE)))
   (CL:WHEN (SINGLE-VALUED-TERM? RELATION)
    (CL:LET* ((FILLER (ACCESS-BINARY-VALUE INSTANCE RELATIONREF)))
     (CL:WHEN (CL:NOT (CL:EQ FILLER NULL))
      (CL:RETURN-FROM TEST-RANGE-TYPE?
       (TEST-TYPE-ON-INSTANCE? FILLER VALUESURROGATE)))))
   (CL:LET*
    ((ROLESET (GET-ROLESET-OF RELATION INSTANCE))
     (CLOSED? (CL:OR (CLOSED-TERM? RELATION) (CLOSED-TERM? ROLESET))))
    (CL:IF (CL:NOT (CL:EQ ROLESET NULL))
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:IF (COLLECTION-IMPLIES-COLLECTION? ROLESET VALUETYPE)
       (CL:SETQ TEST-VALUE-000 CL:T)
       (CL:PROGN (CL:SETQ TEST-VALUE-000 CLOSED?)
        (CL:WHEN TEST-VALUE-000
         (CL:LET* ((ALWAYS?-000 CL:T))
          (CL:LET*
           ((FILLER NULL)
            (ITER-000 (ALL-SLOT-VALUES INSTANCE RELATIONREF)))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
            (CL:SETQ FILLER (%%VALUE ITER-000))
            (CL:WHEN
             (CL:NOT (TEST-TYPE-ON-INSTANCE? FILLER VALUESURROGATE))
             (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
            (CL:SETQ ITER-000 (%%REST ITER-000))))
          (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))))
      (CL:WHEN TEST-VALUE-000 (CL:RETURN-FROM TEST-RANGE-TYPE? CL:T)))
     (CL:LET* ((TEST-VALUE-001 CL:NIL))
      (CL:SETQ TEST-VALUE-001 CLOSED?)
      (CL:WHEN TEST-VALUE-001
       (CL:LET* ((ALWAYS?-001 CL:T))
        (CL:LET*
         ((FILLER NULL)
          (ITER-001 (ALL-SLOT-VALUES INSTANCE RELATIONREF)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ FILLER (%%VALUE ITER-001))
          (CL:WHEN
           (CL:NOT (TEST-TYPE-ON-INSTANCE? FILLER VALUESURROGATE))
           (CL:SETQ ALWAYS?-001 CL:NIL) (CL:RETURN))
          (CL:SETQ ITER-001 (%%REST ITER-001))))
        (CL:SETQ TEST-VALUE-001 ALWAYS?-001)))
      (CL:WHEN TEST-VALUE-001
       (CL:RETURN-FROM TEST-RANGE-TYPE? CL:T)))))
   (CL:LET*
    ((SUPERR NULL) (ITER-002 (ALL-SUPERRELATIONS RELATION CL:NIL)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ SUPERR (%%VALUE ITER-002))
     (CL:LET* ((SUPERROLESET (GET-ROLESET-OF SUPERR INSTANCE)))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ SUPERROLESET NULL))
        (COLLECTION-IMPLIES-COLLECTION? SUPERROLESET VALUETYPE))
       (CL:RETURN-FROM TEST-RANGE-TYPE? CL:T)))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   CL:NIL))

;;; (DEFUN (/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (RELATION
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       0)))
    (INSTANCE
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       1)))
    (VALUETYPEARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      2))
    (VALUETYPEVALUE (ARGUMENT-BOUND-TO VALUETYPEARG)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:NOT *ACCELERATE-FRAME-COMPUTATIONS?*)
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:WHEN (CL:OR (CL:EQ RELATION NULL) (CL:EQ INSTANCE NULL))
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:WHEN (CL:EQ VALUETYPEVALUE NULL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:WHEN (ISA? VALUETYPEVALUE SGT-SPECIALISTS-STELLA-SURROGATE)
    (CL:SETQ VALUETYPEVALUE (SURROGATE-TO-DESCRIPTION VALUETYPEVALUE)))
   (CL:WHEN
    (CL:OR
     (CL:NOT (ISA? RELATION SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION))
     (CL:NOT
      (ISA? VALUETYPEVALUE SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION))
     (CL:EQ VALUETYPEVALUE NULL))
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:IF (TEST-RANGE-TYPE? RELATION INSTANCE VALUETYPEVALUE)
    (SELECT-TEST-RESULT CL:T CL:T FRAME) KWD-SPECIALISTS-FAILURE)))

;;; (DEFUN (/PL-KERNEL-KB/REFLEXIVE-RELATION-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/REFLEXIVE-RELATION-SPECIALIST| (FRAME LASTMOVE)
  (CL:SETQ LASTMOVE LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (ARG1
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (ARG2
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (ARG1VAL (ARGUMENT-BOUND-TO ARG1))
    (ARG2VAL (ARGUMENT-BOUND-TO ARG2)))
   (CL:COND
    ((CL:AND (CL:NOT (CL:EQ ARG1VAL NULL))
      (BIND-ARGUMENT-TO-VALUE? ARG2 ARG1VAL CL:T))
     (SELECT-TEST-RESULT CL:T CL:T FRAME))
    ((CL:AND (CL:NOT (CL:EQ ARG2VAL NULL))
      (BIND-ARGUMENT-TO-VALUE? ARG1 ARG2VAL CL:T))
     (SELECT-TEST-RESULT CL:T CL:T FRAME))
    (CL:T KWD-SPECIALISTS-FAILURE))))

;;; (DEFUN (/PL-KERNEL-KB/IRREFLEXIVE-RELATION-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/IRREFLEXIVE-RELATION-SPECIALIST| (FRAME LASTMOVE)
  (CL:SETQ LASTMOVE LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (ARG1
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       0)))
    (ARG2
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       1))))
   (CL:IF (CL:AND (CL:NOT (CL:EQ ARG1 NULL)) (EQL? ARG1 ARG2))
    (SELECT-TEST-RESULT CL:NIL CL:T FRAME) KWD-SPECIALISTS-FAILURE)))

;;; (DEFUN (/PL-KERNEL-KB/OBJECT-NAME-COMPUTATION STRING-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/OBJECT-NAME-COMPUTATION| (OBJECTARG)
  (CL:LET* ((NAME-STRING (OBJECT-NAME-STRING (VALUE-OF OBJECTARG))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME-STRING))
   (CL:IF (CL:EQ NAME-STRING STELLA::NULL-STRING) NULL
    (WRAP-STRING NAME-STRING))))

;;; (DEFUN (/PL-KERNEL-KB/NAME-TO-OBJECT-COMPUTATION OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/NAME-TO-OBJECT-COMPUTATION| (NAMEARG)
  (CL:LET*
   ((*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CL:NOT (STRING? NAMEARG))
    (CL:LET* ((INSTANCE (GET-INSTANCE NAMEARG)))
     (CL:WHEN (CL:NOT (CL:EQ INSTANCE NULL))
      (CL:RETURN-FROM |/PL-KERNEL-KB/NAME-TO-OBJECT-COMPUTATION|
       INSTANCE))))
   (CL:LET*
    ((NAMEARGSTRING (PLI::OBJECT-TO-STRING NAMEARG))
     (INSTANCENAME (LOOKUP-SURROGATE NAMEARGSTRING)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAMEARGSTRING))
    (CL:LET* ((TEMP-000 (GET-INSTANCE INSTANCENAME)))
     (CL:LET*
      ((VALUE-000
        (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000
         (CREATE-LOGIC-INSTANCE
          (INTERN-SURROGATE-IN-MODULE NAMEARGSTRING *MODULE* CL:T)
          NULL))))
      VALUE-000)))))

;;; (DEFUN (/PL-KERNEL-KB/ARITY-COMPUTATION INTEGER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/ARITY-COMPUTATION| (DESCRIPTIONARG)
  (CL:LET* ((DESCRIPTION (VALUE-OF DESCRIPTIONARG)))
   (CL:IF (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE DESCRIPTION)
       SGT-SPECIALISTS-LOGIC-DESCRIPTION)
      (CL:PROGN (WRAP-INTEGER (ARITY DESCRIPTION))))
     (CL:T NULL))
    NULL)))

;;; (DEFUN (/PL-KERNEL-KB/ARITY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/ARITY-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (RELATION-ARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (RELATION-ARG-VALUE (ARGUMENT-BOUND-TO RELATION-ARG))
    (ARITY-ARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (ARITY-ARG-VALUE (ARGUMENT-BOUND-TO ARITY-ARG))
    (COMPUTED-ARITY
     (|/PL-KERNEL-KB/ARITY-COMPUTATION| RELATION-ARG-VALUE))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:COND
     ((CL:EQ RELATION-ARG-VALUE NULL)
      (CL:SETQ ITERATOR (ALL-NAMED-DESCRIPTIONS *MODULE* CL:NIL))
      (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
       SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
     ((CL:EQ ARITY-ARG-VALUE NULL)
      (CL:RETURN-FROM |/PL-KERNEL-KB/ARITY-SPECIALIST|
       (SELECT-PROOF-RESULT
        (BIND-ARGUMENT-TO-VALUE? ARITY-ARG COMPUTED-ARITY CL:T) CL:NIL
        CL:T)))
     (CL:T
      (CL:IF (CL:EQ COMPUTED-ARITY NULL)
       (CL:RETURN-FROM |/PL-KERNEL-KB/ARITY-SPECIALIST|
        KWD-SPECIALISTS-FAILURE)
       (CL:COND
        ((SUBTYPE-OF-INTEGER? (SAFE-PRIMARY-TYPE ARITY-ARG-VALUE))
         (CL:PROGN
          (CL:RETURN-FROM |/PL-KERNEL-KB/ARITY-SPECIALIST|
           (SELECT-TEST-RESULT (EQL? ARITY-ARG-VALUE COMPUTED-ARITY)
            CL:T FRAME))))
        (CL:T
         (CL:RETURN-FROM |/PL-KERNEL-KB/ARITY-SPECIALIST|
          (SELECT-TEST-RESULT
           (BIND-ARGUMENT-TO-VALUE? ARITY-ARG COMPUTED-ARITY CL:T) CL:T
           FRAME))))))))
   (CL:LET* ((DESCRIPTION NULL))
    (CL:LOOP WHILE (NEXT? ITERATOR) DO
     (CL:SETQ DESCRIPTION (%ITERATOR.VALUE ITERATOR))
     (CL:SETQ COMPUTED-ARITY
      (|/PL-KERNEL-KB/ARITY-COMPUTATION| DESCRIPTION))
     (CL:WHEN
      (CL:AND (BIND-ARGUMENT-TO-VALUE? ARITY-ARG COMPUTED-ARITY CL:T)
       (BIND-ARGUMENT-TO-VALUE? RELATION-ARG DESCRIPTION CL:T))
      (CL:RETURN-FROM |/PL-KERNEL-KB/ARITY-SPECIALIST|
       KWD-SPECIALISTS-CONTINUING-SUCCESS)))
    KWD-SPECIALISTS-FAILURE)))

;;; (DEFUN (/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (RELATION (%PROPOSITION.OPERATOR PROPOSITION))
    (BOUNDARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (BOUNDARGVALUE (ARGUMENT-BOUND-TO BOUNDARG))
    (OTHERARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (OTHERARGVALUE (ARGUMENT-BOUND-TO OTHERARG)) (REFLEXIVE? CL:NIL)
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL))
    (COLLECTION NIL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ BOUNDARGVALUE NULL)
    (CL:COND
     ((CL:EQ OTHERARGVALUE NULL)
      (CL:RETURN-FROM |/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST|
       KWD-SPECIALISTS-TERMINAL-FAILURE))
     (CL:T (CL:SETQ BOUNDARG OTHERARG)
      (CL:SETQ BOUNDARGVALUE OTHERARGVALUE)
      (CL:SETQ OTHERARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
        0))
      (CL:SETQ OTHERARGVALUE NULL)
      (CL:COND
       ((CL:EQ RELATION
         SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUBRELATION)
        (CL:SETQ RELATION
         SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUPERRELATION))
       ((CL:EQ RELATION
         SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUPERRELATION)
        (CL:SETQ RELATION
         SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUBRELATION))
       ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SUBRELATION)
        (CL:SETQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SUPERRELATION))
       ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SUPERRELATION)
        (CL:SETQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SUBRELATION))
       ((CL:EQ RELATION
         SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUBRELATION)
        (CL:SETQ RELATION
         SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUPERRELATION))
       ((CL:EQ RELATION
         SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUPERRELATION)
        (CL:SETQ RELATION
         SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUBRELATION))
       (CL:T)))))
   (CL:WHEN
    (CL:NOT
     (ISA? BOUNDARGVALUE SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION))
    (CL:RETURN-FROM |/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:COND
     ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUBRELATION)
      (CL:SETQ COLLECTION
       (ALL-DIRECT-SUBRELATIONS BOUNDARGVALUE CL:T)))
     ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SUBRELATION)
      (CL:SETQ REFLEXIVE? CL:T)
      (CL:SETQ COLLECTION (ALL-SUBRELATIONS BOUNDARGVALUE CL:NIL)))
     ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUBRELATION)
      (CL:SETQ COLLECTION (ALL-SUBRELATIONS BOUNDARGVALUE CL:T)))
     ((CL:EQ RELATION
       SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUPERRELATION)
      (CL:SETQ COLLECTION
       (ALL-DIRECT-SUPERRELATIONS BOUNDARGVALUE CL:T)))
     ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SUPERRELATION)
      (CL:SETQ REFLEXIVE? CL:T)
      (CL:SETQ COLLECTION (ALL-SUPERRELATIONS BOUNDARGVALUE CL:NIL)))
     ((CL:EQ RELATION
       SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUPERRELATION)
      (CL:SETQ COLLECTION (ALL-SUPERRELATIONS BOUNDARGVALUE CL:T)))
     ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-EQUIVALENT-RELATION)
      (CL:SETQ COLLECTION
       (ALL-EQUIVALENT-RELATIONS BOUNDARGVALUE CL:T)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" RELATION "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
    (CL:WHEN
     (CL:AND REFLEXIVE? (CL:NOT (MEMB? COLLECTION BOUNDARGVALUE)))
     (CL:SETQ COLLECTION (CONS BOUNDARGVALUE COLLECTION))))
   (CL:WHEN (CL:NOT (CL:EQ OTHERARGVALUE NULL))
    (CL:IF (MEMB? COLLECTION OTHERARGVALUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST|
      KWD-SPECIALISTS-FINAL-SUCCESS)
     (CL:RETURN-FROM |/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE)))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:WHEN (CL:EQ COLLECTION NIL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:SETQ ITERATOR (ALLOCATE-ITERATOR COLLECTION))
    (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
   (CL:IF
    (CL:AND (NEXT? ITERATOR)
     (BIND-ARGUMENT-TO-VALUE? OTHERARG (%ITERATOR.VALUE ITERATOR)
      CL:T))
    KWD-SPECIALISTS-CONTINUING-SUCCESS
    KWD-SPECIALISTS-TERMINAL-FAILURE)))

;;; (DEFUN (HELP-PROJECT-NTH-COLUMN LIST) ...)

(CL:DEFUN HELP-PROJECT-NTH-COLUMN (N TUPLELIST)
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:WHEN (CL:EQ TUPLELIST NULL)
   (CL:RETURN-FROM HELP-PROJECT-NTH-COLUMN NULL))
  (CL:LET* ((PROJECTEDLIST (NEW-LIST)) (ITEM NULL))
   (CL:LET*
    ((TUPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST TUPLELIST))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ TUPLE (%%VALUE ITER-000))
     (CL:TAGBODY
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TUPLE)))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 SGT-SPECIALISTS-STELLA-CONS)
         (CL:PROGN (CL:SETQ ITEM (NTH TUPLE N))))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-LIST)
         (CL:PROGN (CL:SETQ ITEM (NTH TUPLE N))))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-COLLECTION)
         (CL:PROGN
          (CL:LET*
           ((MEMBERS (ASSERTED-COLLECTION-MEMBERS TUPLE CL:NIL)))
           (CL:IF (CL:NOT (CL:EQ MEMBERS NULL))
            (CL:SETQ ITEM (NTH MEMBERS N)) (CL:GO :CONTINUE)))))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-SKOLEM)
         (CL:PROGN
          (CL:LET*
           ((MEMBERS (ASSERTED-COLLECTION-MEMBERS TUPLE CL:NIL)))
           (CL:IF (CL:NOT (CL:EQ MEMBERS NULL))
            (CL:SETQ ITEM (NTH MEMBERS N)) (CL:GO :CONTINUE)))))
        (CL:T
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "Can't handle tuple object `" TUPLE "'" EOL EOL)
         (CL:GO :CONTINUE))))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS ITEM NIL))
        (CL:IF (CL:EQ (%LIST.THE-CONS-LIST PROJECTEDLIST) NIL)
         (CL:SETF (%LIST.THE-CONS-LIST PROJECTEDLIST) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST
          (%LIST.THE-CONS-LIST PROJECTEDLIST) COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ITEM NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      :CONTINUE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:IF (EMPTY? PROJECTEDLIST) NULL PROJECTEDLIST)))

;;; (DEFUN (/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (PROJECTIONARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (PROJECTIONVALUE (ARGUMENT-BOUND-TO PROJECTIONARG))
    (COLLECTIONARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      1))
    (COLLECTIONVALUE (ARGUMENT-BOUND-TO COLLECTIONARG))
    (SELECTOR NULL-INTEGER)
    (LISTARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      2)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SELECTOR))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:OR (CL:EQ COLLECTIONVALUE NULL) (CL:EQ PROJECTIONVALUE NULL)
     (CL:NOT
      (ISA? PROJECTIONVALUE SGT-SPECIALISTS-STELLA-INTEGER-WRAPPER)))
    (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:SETQ SELECTOR (%INTEGER-WRAPPER.WRAPPER-VALUE PROJECTIONVALUE))
   (CL:WHEN
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL)
     NULL)
    (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE COLLECTIONVALUE)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-STELLA-COLLECTION)
       (CL:PROGN
        (CL:LET*
         ((MEMBERS
           (HELP-PROJECT-NTH-COLUMN SELECTOR
            (ASSERTED-COLLECTION-MEMBERS COLLECTIONVALUE CL:NIL))))
         (CL:WHEN (CL:EQ MEMBERS NULL)
          (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
           KWD-SPECIALISTS-TERMINAL-FAILURE))
         (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
          (SELECT-PROOF-RESULT
           (BIND-ARGUMENT-TO-VALUE? LISTARG
            (CREATE-LOGICAL-LIST MEMBERS) CL:T)
           CL:NIL CL:T)))))
      ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-LOGIC-SKOLEM)
       (CL:PROGN
        (CL:LET*
         ((MEMBERS
           (HELP-PROJECT-NTH-COLUMN SELECTOR
            (ASSERTED-COLLECTION-MEMBERS COLLECTIONVALUE CL:NIL))))
         (CL:WHEN (CL:EQ MEMBERS NULL)
          (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
           KWD-SPECIALISTS-TERMINAL-FAILURE))
         (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
          (SELECT-PROOF-RESULT
           (BIND-ARGUMENT-TO-VALUE? LISTARG
            (CREATE-LOGICAL-LIST MEMBERS) CL:T)
           CL:NIL CL:T)))))
      ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-LOGIC-DESCRIPTION)
       (CL:PROGN
        (CL:LET* ((TEST-VALUE-000 CL:NIL))
         (CL:SETQ TEST-VALUE-000
          (CL:NOT
           (CL:EQ
            (DYNAMIC-SLOT-VALUE
             (%DESCRIPTION.DYNAMIC-SLOTS COLLECTIONVALUE)
             SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES NULL)
            NULL)))
         (CL:WHEN TEST-VALUE-000
          (CL:LET* ((FOUND?-000 CL:NIL))
           (CL:LET*
            ((V NULL)
             (VECTOR-000
              (DYNAMIC-SLOT-VALUE
               (%DESCRIPTION.DYNAMIC-SLOTS COLLECTIONVALUE)
               SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES NULL))
             (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
            (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
            (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
             (CL:SETQ V
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
               INDEX-000))
             (CL:WHEN (CL:EQ (ARGUMENT-BOUND-TO V) NULL)
              (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
             (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
           (CL:SETQ TEST-VALUE-000 FOUND?-000)))
         (CL:WHEN TEST-VALUE-000
          (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
           KWD-SPECIALISTS-TERMINAL-FAILURE)))
        (CL:IF (INFERABLE? COLLECTIONVALUE)
         (CL:PROGN
          (CREATE-COLLECT-DESCRIPTION-EXTENSION-FRAME FRAME
           COLLECTIONVALUE)
          (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
           SYM-SPECIALISTS-STELLA-ITERATOR EMPTY-PROPOSITIONS-ITERATOR
           NULL)
          (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
           KWD-SPECIALISTS-MOVE-DOWN))
         (CL:LET*
          ((MEMBERS
            (HELP-PROJECT-NTH-COLUMN SELECTOR
             (ASSERTED-COLLECTION-MEMBERS COLLECTIONVALUE CL:NIL))))
          (CL:WHEN (CL:EQ MEMBERS NULL)
           (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
            KWD-SPECIALISTS-TERMINAL-FAILURE))
          (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
           (SELECT-PROOF-RESULT
            (BIND-ARGUMENT-TO-VALUE? LISTARG
             (CREATE-LOGICAL-LIST MEMBERS) CL:T)
            CL:NIL CL:T))))))
      (CL:T
       (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
        KWD-SPECIALISTS-FAILURE)))))
   (CL:WHEN (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:LET*
    ((LIST
      (HELP-PROJECT-NTH-COLUMN SELECTOR
       (%PATTERN-RECORD.COLLECTION-LIST
        (%CONTROL-FRAME.PATTERN-RECORD (%CONTROL-FRAME.DOWN FRAME))))))
    (POP-FRAMES-UP-TO (%CONTROL-FRAME.DOWN FRAME))
    (CL:WHEN (CL:EQ LIST NULL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (SELECT-PROOF-RESULT
     (BIND-ARGUMENT-TO-VALUE? LISTARG (CREATE-LOGICAL-LIST LIST) CL:T)
     CL:NIL CL:T))))

;;; (DEFUN /PL-KERNEL-KB/ASSERT-SYNONYM-DEMON ...)

(CL:DEFUN |/PL-KERNEL-KB/ASSERT-SYNONYM-DEMON| (SELF)
  (CL:LET*
   ((TERM
     (VALUE-OF
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
       0)))
    (SYNONYM
     (VALUE-OF
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
       1)))
    (SYNONYMNAME NULL))
   (CL:WHEN
    (CL:AND (CL:NOT (EQL? TERM SYNONYM))
     (ISA? SYNONYM SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT))
    (CL:SETQ SYNONYMNAME
     (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE SYNONYM))
    (CL:SETF (%SURROGATE.SURROGATE-VALUE SYNONYMNAME) TERM)
    (ASSERT-TUPLE SGT-SPECIALISTS-PL-KERNEL-KB-SYNONYM
     (CONS-LIST TERM TERM)))))

;;; (DEFUN /PL-KERNEL-KB/RETRACT-SYNONYM-DEMON ...)

(CL:DEFUN |/PL-KERNEL-KB/RETRACT-SYNONYM-DEMON| (SELF)
  (CL:LET*
   ((TERM
     (VALUE-OF
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
       0)))
    (SYNONYM NULL) (SYNONYMNAME NULL))
   (CL:LET*
    ((PROP NULL)
     (ITER-000
      (ALL-TRUE-DEPENDENT-PROPOSITIONS TERM
       SGT-SPECIALISTS-PL-KERNEL-KB-SYNONYM CL:NIL)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ PROP (%ITERATOR.VALUE ITER-000))
     (CL:SETQ SYNONYM
      (VALUE-OF
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROP)))
        1)))
     (CL:WHEN (ISA? SYNONYM SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
      (CL:SETQ SYNONYMNAME
       (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE SYNONYM))
      (CL:SETF (%SURROGATE.SURROGATE-VALUE SYNONYMNAME) SYNONYM))
     (CL:LET*
      ((OBJECT-000 PROP) (VALUE-000 NULL)
       (OLD-VALUE-000 (%PROPOSITION.TRUTH-VALUE OBJECT-000))
       (NEW-VALUE-000
        (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
         (%PROPOSITION.HOME-CONTEXT OBJECT-000) CL:NIL)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
          SGT-SPECIALISTS-STELLA-CS-VALUE)))
       (CL:SETF (%PROPOSITION.TRUTH-VALUE OBJECT-000)
        NEW-VALUE-000)))))))

;;; (DEFUN (GET-SYNONYMS (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-SYNONYMS (TERM)
  (CL:LET*
   ((TERMVALUE (VALUE-OF TERM)) (FIRSTARG NULL) (SECONDARG NULL)
    (SYNONYMS NIL))
   (CL:LET*
    ((PROP NULL)
     (ITER-000
      (ALL-TRUE-DEPENDENT-PROPOSITIONS TERM
       SGT-SPECIALISTS-PL-KERNEL-KB-SYNONYM CL:NIL)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ PROP (%ITERATOR.VALUE ITER-000))
     (CL:SETQ FIRSTARG
      (VALUE-OF
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROP)))
        0)))
     (CL:SETQ SECONDARG
      (VALUE-OF
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROP)))
        1)))
     (CL:WHEN
      (CL:AND (EQL? FIRSTARG TERMVALUE)
       (CL:NOT (EQL? FIRSTARG SECONDARG))
       (CL:NOT (MEMB? SYNONYMS SECONDARG)))
      (CL:SETQ SYNONYMS (CONS SECONDARG SYNONYMS)))))
   SYNONYMS))

;;; (DEFUN (SYNONYM-SURROGATE? BOOLEAN) ...)

(CL:DEFUN SYNONYM-SURROGATE? (NAME)
  (CL:LET* ((*MODULE* (HOME-MODULE NAME)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:LET*
    ((VALUE (%SURROGATE.SURROGATE-VALUE NAME))
     (VALUENAME (OBJECT-SURROGATE VALUE)))
    (CL:LET* ((TEST-VALUE-000 CL:NIL))
     (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ VALUENAME NULL)))
     (CL:WHEN TEST-VALUE-000
      (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ NAME VALUENAME)))
      (CL:WHEN TEST-VALUE-000
       (CL:LET* ((FOUND?-000 CL:NIL))
        (CL:LET* ((SYNONYM NULL) (ITER-000 (GET-SYNONYMS VALUE)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ SYNONYM (%%VALUE ITER-000))
          (CL:WHEN
           (CL:EQ (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE SYNONYM) NAME)
           (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
          (CL:SETQ ITER-000 (%%REST ITER-000))))
        (CL:SETQ TEST-VALUE-000 FOUND?-000))))
     (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))))

;;; (DEFUN TRANSFER-SYNONYMS ...)

(CL:DEFUN TRANSFER-SYNONYMS (OLDOBJECT NEWOBJECT)
  (CL:LET* ((ORIGINATEDPROPS (ORIGINATED-PROPOSITIONS OLDOBJECT)))
   (CL:LET* ((SYNONYM NULL) (ITER-000 (GET-SYNONYMS OLDOBJECT)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SYNONYM (%%VALUE ITER-000))
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET*
       ((PROP NULL)
        (ITER-001
         (ALL-TRUE-DEPENDENT-PROPOSITIONS SYNONYM
          SGT-SPECIALISTS-PL-KERNEL-KB-SYNONYM CL:NIL)))
       (CL:LOOP WHILE (NEXT? ITER-001) DO
        (CL:SETQ PROP (%ITERATOR.VALUE ITER-001))
        (CL:WHEN
         (CL:AND
          (EQL?
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROP)))
            0)
           OLDOBJECT)
          (CL:EQ
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROP)))
            1)
           SYNONYM)
          (CL:NOT (MEMB? ORIGINATEDPROPS PROP)))
         (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))))
      (CL:IF FOUND?-000
       (CL:SETF (%SURROGATE.SURROGATE-VALUE (OBJECT-SURROGATE SYNONYM))
        NEWOBJECT)
       (CL:SETF (%SURROGATE.SURROGATE-VALUE (OBJECT-SURROGATE SYNONYM))
        NULL)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

;;; (DEFUN (/PL-KERNEL-KB/DIFFERENT-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/DIFFERENT-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((ARGUMENTS
     (%PROPOSITION.ARGUMENTS (%CONTROL-FRAME.PROPOSITION FRAME)))
    (ARGUMENTVALUES NIL) (UNBOUNDARGS? CL:NIL) (VALUE NULL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS (VALUE-OF (ARGUMENT-BOUND-TO ARG)) NIL))
       (CL:IF (CL:EQ ARGUMENTVALUES NIL)
        (CL:SETQ ARGUMENTVALUES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST ARGUMENTVALUES COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (VALUE-OF (ARGUMENT-BOUND-TO ARG)) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ARGUMENTVALUES NIL)) DO
    (CL:SETQ VALUE (%%VALUE ARGUMENTVALUES))
    (CL:IF (CL:EQ VALUE NULL) (CL:SETQ UNBOUNDARGS? CL:T)
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET* ((VALUE2 NULL) (ITER-000 (%%REST ARGUMENTVALUES)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ VALUE2 (%%VALUE ITER-000))
        (CL:WHEN (EQL? VALUE VALUE2) (CL:SETQ FOUND?-000 CL:T)
         (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:WHEN FOUND?-000
       (CL:RETURN-FROM |/PL-KERNEL-KB/DIFFERENT-SPECIALIST|
        (SELECT-TEST-RESULT CL:NIL CL:T FRAME)))))
    (CL:SETQ ARGUMENTVALUES (%%REST ARGUMENTVALUES)))
   (CL:IF UNBOUNDARGS? KWD-SPECIALISTS-FAILURE
    (SELECT-TEST-RESULT CL:T CL:T FRAME))))

;;; (DEFUN (LOOKUP-NATIVE-SPECIALIST FUNCTION-CODE) ...)

(CL:DEFUN LOOKUP-NATIVE-SPECIALIST (NATIVE-NAME)
  "Returns the native funtion code for `native-name' if it exists
and the underlying programming languages supports such lookups.  Uses the signature
of a specialist function."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NATIVE-NAME))
  #+MCL
  (CL:CHECK-TYPE NATIVE-NAME CL:SIMPLE-STRING)
  (CL:LET* ((CODE NULL))
   (cl:setq code (cl:symbol-function (cl:read-from-string native-name)))
   (CL:WHEN (CL:EQ CODE NULL)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Couldn't locate native function for `" NATIVE-NAME "'")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
   CODE))

;;; (DEFUN REGISTER-SPECIALIST-FUNCTION ...)

(CL:DEFUN REGISTER-SPECIALIST-FUNCTION (NAME CODE)
  "Creates a registration entry for `name' as a specialist which
executes `code'.  Essentially just builds the Stella meta-information
tructure needed to funcall `name' as a specialist.  The function definition
in `code' needs to accept a CONTROL-FRAME and KEYWORD as arguments and
return a KEYWORD.  Side effects on elements of the proposition in the
control frame can be used to bind and thus return values."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (DEFINE-FUNCTION-OBJECT (CONCATENATE " " NAME)
   (CONCATENATE "(DEFUN (" NAME
    " KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))")
   CODE NULL))

;;; (DEFUN REGISTER-SPECIALIST-FUNCTION-NAME ...)

(CL:DEFUN %REGISTER-SPECIALIST-FUNCTION-NAME (STELLA-NAME NATIVE-NAME)
  "registers a specialist function `stella-name' based on the `native-name'
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STELLA-NAME NATIVE-NAME))
  #+MCL
  (CL:CHECK-TYPE STELLA-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NATIVE-NAME CL:SIMPLE-STRING)
  (REGISTER-SPECIALIST-FUNCTION STELLA-NAME
   (LOOKUP-NATIVE-SPECIALIST NATIVE-NAME)))

(CL:DEFUN REGISTER-SPECIALIST-FUNCTION-NAME-EVALUATOR-WRAPPER (ARGUMENTS)
  (%REGISTER-SPECIALIST-FUNCTION-NAME
   (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))
   (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO REGISTER-SPECIALIST-FUNCTION-NAME (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "registers a specialist function `stella-name' based on the `native-name'
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/REGISTER-SPECIALIST-FUNCTION-NAME|)) (CL:MACRO-FUNCTION (CL:QUOTE REGISTER-SPECIALIST-FUNCTION-NAME)))

;;; (DEFUN (LOOKUP-NATIVE-COMPUTATION FUNCTION-CODE) ...)

(CL:DEFUN LOOKUP-NATIVE-COMPUTATION (NATIVE-NAME ARITY)
  "Returns the native funtion code for `native-name' if it exists
and the underlying programming languages supports such lookups.  It is looked up
using the signature of a computation function supported by the computation specialist."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NATIVE-NAME)
   (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE NATIVE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (CL:LET* ((CODE NULL))
   (cl:setq code (cl:symbol-function (cl:read-from-string native-name)))
   (CL:WHEN (CL:EQ CODE NULL)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Couldn't locate native function for `" NATIVE-NAME "'")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
   CODE))

;;; (DEFUN REGISTER-COMPUTATION-FUNCTION ...)

(CL:DEFUN REGISTER-COMPUTATION-FUNCTION (NAME CODE ARITY)
  "Creates a registration entry for `name' as a computation which
executes `code'.  Essentially just builds the Stella meta-information
tructure needed to funcall `name' as a computation function by the
computation specialist.  The function definition in `code' needs to
accept ARITY Stella OBJECTs as arguments and return a Stella OBJECT 
suitable for PowerLoom use.  (These are generally LOGIC-OBJECTs and the
literal wrappers FLOAT-WRAPPER, INTEGER-WRAPPER and STRING-WRAPPER.)"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME) (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (CL:LET* ((DEFINITION-STRING "(DEFUN ("))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DEFINITION-STRING))
   (CL:SETQ DEFINITION-STRING
    (CONCATENATE DEFINITION-STRING NAME " OBJECT) ("))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 ARITY)
     (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000)
     (CL:SETQ DEFINITION-STRING
      (CONCATENATE DEFINITION-STRING "(X"
       (INTEGER-TO-STRING (CL:TRUNCATE I)) " OBJECT) "))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETQ DEFINITION-STRING (CONCATENATE DEFINITION-STRING "))"))
   (DEFINE-FUNCTION-OBJECT (CONCATENATE " " NAME) DEFINITION-STRING
    CODE NULL)))

;;; (DEFUN REGISTER-COMPUTATION-FUNCTION-NAME ...)

(CL:DEFUN %REGISTER-COMPUTATION-FUNCTION-NAME (STELLA-NAME NATIVE-NAME ARITY)
  "registers a computation function `stella-name' based on the `native-name'
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STELLA-NAME NATIVE-NAME)
   (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE STELLA-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NATIVE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (REGISTER-COMPUTATION-FUNCTION STELLA-NAME
   (LOOKUP-NATIVE-COMPUTATION NATIVE-NAME ARITY) ARITY))

(CL:DEFUN REGISTER-COMPUTATION-FUNCTION-NAME-EVALUATOR-WRAPPER (ARGUMENTS)
  (%REGISTER-COMPUTATION-FUNCTION-NAME
   (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))
   (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))
   (%INTEGER-WRAPPER.WRAPPER-VALUE
    (%%VALUE (%%REST (%%REST ARGUMENTS))))))

(CL:DEFMACRO REGISTER-COMPUTATION-FUNCTION-NAME (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "registers a computation function `stella-name' based on the `native-name'
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/REGISTER-COMPUTATION-FUNCTION-NAME|)) (CL:MACRO-FUNCTION (CL:QUOTE REGISTER-COMPUTATION-FUNCTION-NAME)))

(CL:DEFUN HELP-STARTUP-SPECIALISTS1 ()
  (CL:PROGN
   (CL:SETQ SGT-SPECIALISTS-LOGIC-COMPUTED-PROCEDURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPUTED-PROCEDURE" NULL 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-PROCEDURE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROCEDURE-NAME" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-PROCEDURE-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROCEDURE-FUNCTION" NULL 0))
   (CL:SETQ KWD-SPECIALISTS-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-RELEASE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELEASE" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-SPECIALIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-SPECIALIST"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-HANDLES-REVERSE-POLARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HANDLES-REVERSE-POLARITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-CONSTRAINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-CONSTRAINT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-COMPUTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-COMPUTATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-EVALUATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-EVALUATOR"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-SPECIALISTS-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-TERMINAL-FAILURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TERMINAL-FAILURE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-FAILURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILURE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-FINAL-SUCCESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINAL-SUCCESS" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-CONTINUING-SUCCESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUING-SUCCESS" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-FUNCTION-CODE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-METHOD-CODE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-SUBSTRING-POSITION-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSTRING-POSITION-ITERATOR" NULL
     1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-SUPER-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPER-STRING" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-SUB-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUB-STRING" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-STELLA-START
    (INTERN-RIGID-SYMBOL-WRT-MODULE "START"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-SUB-LENGTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUB-LENGTH" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-TOTAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOTAL"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-SPECIALISTS-STELLA-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-COLLECTIONOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTIONOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-SPECIALISTS-UP-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TRUE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-UP-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-FAIL" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-STELLA-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-SPECIALISTS-MOVE-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MOVE-DOWN" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTERNAL-VARIABLES" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ KWD-SPECIALISTS-SCAN-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-COLLECTION" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ KWD-SPECIALISTS-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWN" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-STELLA-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-SPECIALISTS-STELLA-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-SPECIALISTS-STELLA-DUMMY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DUMMY"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-SPECIALISTS-FULL-SUBQUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULL-SUBQUERY" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ KWD-SPECIALISTS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ KWD-SPECIALISTS-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-STELLA-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-FORK-PROOF-ADJUNCT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORK-PROOF-ADJUNCT" NULL 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-CONDITION-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONDITION-JUSTIFICATION" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-DOWN-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWN-FRAME" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROOF-ADJUNCT" NULL 0))
   (CL:SETQ KWD-SPECIALISTS-FAIL-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-FORK-ELSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORK-ELSE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-FORK-THEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORK-THEN" NULL 2))))

(CL:DEFUN HELP-STARTUP-SPECIALISTS2 ()
  (CL:PROGN
   (CL:SETQ SYM-SPECIALISTS-LOGIC-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATION" NULL 0))
   (CL:SETQ KWD-SPECIALISTS-TECHNICAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TECHNICAL" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-LAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LAY" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-HOW-MANY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOW-MANY" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-INHERIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INHERIT" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-ALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-CURRENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-QUERY-SPECIALIST-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-SPECIALIST-IO-VARIABLES"
     NULL 0))
   (CL:SETQ KWD-SPECIALISTS-MATCH-MODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MATCH-MODE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-SORT-BY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SORT-BY" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-GOAL-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-TREE" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT" NULL 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-SAVED-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVED-INFERENCE-LEVEL" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-LEVEL" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-ASSERTION-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERTION-QUERY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-SHALLOW-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHALLOW-QUERY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-SUBSUMPTION-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-QUERY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-BACKTRACKING-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKTRACKING-QUERY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-NORMAL-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NORMAL-QUERY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-REFUTATION-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFUTATION-QUERY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-SPECIALISTS-LEVELED-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LEVELED-QUERY" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-CONCEPT-PROTOTYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEPT-PROTOTYPE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-HYPOTHESIZED-INSTANCE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HYPOTHESIZED-INSTANCE?" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-MONOTONIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MONOTONIC?" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-F-CLOSED-TERM?-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-CLOSED-TERM?-MEMO-TABLE-000"
     NULL 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-EQUIVALENT-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT-VALUE" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-F-CLOSED-PROPOSITION?-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-CLOSED-PROPOSITION?-MEMO-TABLE-000" NULL 1))
   (CL:SETQ KWD-SPECIALISTS-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-SINGLE-VALUED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SINGLE-VALUED"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-F-SINGLE-VALUED-TERM?-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-SINGLE-VALUED-TERM?-MEMO-TABLE-000" NULL 1))
   (CL:SETQ KWD-SPECIALISTS-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-COLLECT-INTO-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-INTO-LIST"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-COLLECT-INTO-ORDERED-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-INTO-ORDERED-SET"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-INFERENCE-CUTOFF-REASON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-CUTOFF-REASON" NULL 0))
   (CL:SETQ KWD-SPECIALISTS-COLLECT-MEMBERS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-MEMBERS" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-?SUPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?SUPER" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-?MDC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?MDC" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-MUTUALLY-DISJOINT-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTUALLY-DISJOINT-COLLECTION" NULL
     0))
   (CL:SETQ
    SYM-SPECIALISTS-LOGIC-F-HELP-DERIVE-PARTITION-MEMBERSHIPS-QUERY-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-HELP-DERIVE-PARTITION-MEMBERSHIPS-QUERY-000" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-MUTUALLY-DISJOINT-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTUALLY-DISJOINT-COLLECTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-PARTITION-MEMBERSHIP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTITION-MEMBERSHIP"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-DISJOINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISJOINT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-HAS-PARTITION-MEMBERSHIP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HAS-PARTITION-MEMBERSHIP"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-SPECIALISTS-ASSERT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-ASSERT-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-FALSE" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-EMPTY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EMPTY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-SAVED-CONTEXT-PROOF-ADJUNCT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVED-CONTEXT-PROOF-ADJUNCT" NULL
     1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-SAVED-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVED-CONTEXT" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-STELLA-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-SPECIALISTS-IST-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IST-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-PARTIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL" NULL 2))))

(CL:DEFUN HELP-STARTUP-SPECIALISTS3 ()
  (CL:PROGN
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-THE-ROLESET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-ROLESET"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-CARDINALITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CARDINALITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-SPECIALISTS-LOWER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOWER" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-UPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UPPER" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-STELLA-INTEGER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUBRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECT-SUBRELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUPERRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECT-SUPERRELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-SUBRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBRELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-SUPERRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPERRELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUBRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPER-SUBRELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUPERRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPER-SUPERRELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-EQUIVALENT-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT-RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-SYNONYM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYNONYM"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-CS-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CS-VALUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-REGISTER-SPECIALIST-FUNCTION-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REGISTER-SPECIALIST-FUNCTION-NAME"
     NULL 0))
   (CL:SETQ KWD-SPECIALISTS-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-REGISTER-COMPUTATION-FUNCTION-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "REGISTER-COMPUTATION-FUNCTION-NAME" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-STARTUP-SPECIALISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-SPECIALISTS" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-SPECIALISTS4 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "STELLA-FUNCTION-FROM-PROCEDURE"
    "(DEFUN (STELLA-FUNCTION-FROM-PROCEDURE FUNCTION) ((PROCEDURE /PL-KERNEL-KB/COMPUTED-PROCEDURE)))"
    (CL:FUNCTION STELLA-FUNCTION-FROM-PROCEDURE) NULL)
   (DEFINE-FUNCTION-OBJECT "FUNCTION-CODE-FROM-PROCEDURE"
    "(DEFUN (FUNCTION-CODE-FROM-PROCEDURE FUNCTION-CODE) ((PROCEDURE /PL-KERNEL-KB/COMPUTED-PROCEDURE)))"
    (CL:FUNCTION FUNCTION-CODE-FROM-PROCEDURE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-SPECIALIST"
    "(DEFUN (LOOKUP-SPECIALIST FUNCTION-CODE) ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION LOOKUP-SPECIALIST) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-CONSTRAINT-FUNCTION"
    "(DEFUN (LOOKUP-CONSTRAINT-FUNCTION FUNCTION) ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION LOOKUP-CONSTRAINT-FUNCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-CONSTRAINT"
    "(DEFUN (LOOKUP-CONSTRAINT FUNCTION-CODE) ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION LOOKUP-CONSTRAINT) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-COMPUTATION-FUNCTION"
    "(DEFUN (LOOKUP-COMPUTATION-FUNCTION FUNCTION) ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION LOOKUP-COMPUTATION-FUNCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-COMPUTATION"
    "(DEFUN (LOOKUP-COMPUTATION FUNCTION-CODE) ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION LOOKUP-COMPUTATION) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-EVALUATOR-FUNCTION"
    "(DEFUN (LOOKUP-EVALUATOR-FUNCTION FUNCTION) ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION LOOKUP-EVALUATOR-FUNCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-EVALUATOR"
    "(DEFUN (LOOKUP-EVALUATOR FUNCTION-CODE) ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION LOOKUP-EVALUATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "SELECT-TEST-RESULT"
    "(DEFUN (SELECT-TEST-RESULT KEYWORD) ((SUCCESS? BOOLEAN) (TERMINAL? BOOLEAN) (FRAME CONTROL-FRAME)) :PUBLIC? TRUE :DOCUMENTATION \"Helping function for specialists testing the validity of a
fully bound inference frame.  Based on the test result `success?'
and `reversePolarity?*', set the truth value of `frame' and return
an appropriate keyword.  The keyword will be either `:final-success'
`:terminal-failure' if `terminal?' is true.  Otherwise it will be
`:final-success' or `:failure'.\")" (CL:FUNCTION SELECT-TEST-RESULT)
    NULL)
   (DEFINE-FUNCTION-OBJECT "SELECT-PROOF-RESULT"
    "(DEFUN (SELECT-PROOF-RESULT KEYWORD) ((SUCCESS? BOOLEAN) (CONTINUING? BOOLEAN) (TERMINAL? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Helping function for specialists.   Return the appropriate
keyword indicating success or failure of a proof.\")"
    (CL:FUNCTION SELECT-PROOF-RESULT) NULL)
   (DEFINE-FUNCTION-OBJECT "NULL-WRAPPER?"
    "(DEFUN (NULL-WRAPPER? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION NULL-WRAPPER?) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-SLOT-READER-SPECIALIST"
    "(DEFUN (NATIVE-SLOT-READER-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION NATIVE-SLOT-READER-SPECIALIST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((IT SUBSTRING-POSITION-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((IT SUBSTRING-POSITION-ITERATOR)))"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-FUNCTION-OBJECT "BOUND-COMPUTATION-INPUT-SKOLEM?"
    "(DEFUN (BOUND-COMPUTATION-INPUT-SKOLEM? BOOLEAN) ((SKOLEM SKOLEM)))"
    (CL:FUNCTION BOUND-COMPUTATION-INPUT-SKOLEM?) NULL)
   (DEFINE-FUNCTION-OBJECT "ARGUMENT-TARGET-TYPE"
    "(DEFUN (ARGUMENT-TARGET-TYPE TYPE) ((PARAMETERTYPES (LIST OF TYPE-SPEC)) (NINPUTTYPES INTEGER) (ARGINDEX INTEGER)))"
    (CL:FUNCTION ARGUMENT-TARGET-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-RELATION-VALUE"
    "(DEFUN (COMPUTE-RELATION-VALUE OBJECT) ((PROPOSITION PROPOSITION) (COMPUTATION FUNCTION) (ERROR? BOOLEAN)))"
    (CL:FUNCTION COMPUTE-RELATION-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/COMPUTATION-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/COMPUTATION-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/COMPUTATION-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-SIMPLE-RELATION-CONSTRAINT"
    "(DEFUN (COMPUTE-SIMPLE-RELATION-CONSTRAINT OBJECT INTEGER) ((PROPOSITION PROPOSITION) (COMPUTATION FUNCTION) (ERROR? BOOLEAN)))"
    (CL:FUNCTION COMPUTE-SIMPLE-RELATION-CONSTRAINT) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/CONSTRAINT-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/CONSTRAINT-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/CONSTRAINT-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "ENUMERATIONS-CONTAINING-MEMBER"
    "(DEFUN (ENUMERATIONS-CONTAINING-MEMBER LIST) ((SELF OBJECT)))"
    (CL:FUNCTION ENUMERATIONS-CONTAINING-MEMBER) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/MEMBER-OF-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/MEMBER-OF-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/MEMBER-OF-EVALUATOR"
    "(DEFUN /PL-KERNEL-KB/MEMBER-OF-EVALUATOR ((SELF PROPOSITION)))"
    (CL:FUNCTION |/PL-KERNEL-KB/MEMBER-OF-EVALUATOR|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/INSTANCE-OF-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/DIRECT-INSTANCE-OF-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/DIRECT-INSTANCE-OF-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/DIRECT-INSTANCE-OF-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-DISJOINT-TERMS?"
    "(DEFUN (TEST-DISJOINT-TERMS? BOOLEAN) ((TERM1 OBJECT) (TERM2 OBJECT)))"
    (CL:FUNCTION TEST-DISJOINT-TERMS?) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/SUBSET-OF-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/SUBSET-OF-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/HOLDS-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/HOLDS-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/HOLDS-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/TOTAL-VALUE-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/TOTAL-VALUE-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/TOTAL-VALUE-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/PROPOSITION-RELATION-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/PROPOSITION-RELATION-COMPUTATION OBJECT) ((P OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/PROPOSITION-RELATION-COMPUTATION|)
    NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/PROPOSITION-ARGUMENT-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/PROPOSITION-ARGUMENT-COMPUTATION OBJECT) ((P OBJECT) (I INTEGER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/PROPOSITION-ARGUMENT-COMPUTATION|)
    NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/PROPOSITION-ARGUMENTS-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/PROPOSITION-ARGUMENTS-COMPUTATION SKOLEM) ((P OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/PROPOSITION-ARGUMENTS-COMPUTATION|)
    NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/PROPOSITION-ARITY-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/PROPOSITION-ARITY-COMPUTATION INTEGER-WRAPPER) ((P OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/PROPOSITION-ARITY-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/CUT-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/CUT-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/CUT-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/BOUND-VARIABLES-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/BOUND-VARIABLES-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/BOUND-VARIABLES-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/FORK-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/FORK-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/FORK-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-SUBQUERY-OPTIONS"
    "(DEFUN (COMPUTE-SUBQUERY-OPTIONS PROPOSITION PROPERTY-LIST) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION COMPUTE-SUBQUERY-OPTIONS) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT CONTROL-FRAME QUERY-SPECIALIST-IO-VARIABLES :TYPE LIST :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "CREATE-QUERY-SPECIALIST-ITERATOR"
    "(DEFUN (CREATE-QUERY-SPECIALIST-ITERATOR QUERY-ITERATOR BOOLEAN BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION CREATE-QUERY-SPECIALIST-ITERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/QUERY-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/QUERY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/QUERY-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "LEVELED-QUERY-RELATION-TO-INFERENCE-LEVEL"
    "(DEFUN (LEVELED-QUERY-RELATION-TO-INFERENCE-LEVEL INFERENCE-LEVEL) ((RELATION SURROGATE)))"
    (CL:FUNCTION LEVELED-QUERY-RELATION-TO-INFERENCE-LEVEL) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/LEVELED-QUERY-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/LEVELED-QUERY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/LEVELED-QUERY-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/CONCEPT-PROTOTYPE-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/CONCEPT-PROTOTYPE-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/CONCEPT-PROTOTYPE-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "CONCEPT-PROTOTYPE-OF"
    "(DEFUN (CONCEPT-PROTOTYPE-OF NAMED-DESCRIPTION) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION CONCEPT-PROTOTYPE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "CONCEPT-PROTOTYPE?"
    "(DEFUN (CONCEPT-PROTOTYPE? BOOLEAN) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION CONCEPT-PROTOTYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/CLOSED-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/CLOSED-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/CLOSED-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "CLOSED-BY-ASSERTION?"
    "(DEFUN (CLOSED-BY-ASSERTION? BOOLEAN) ((SELF OBJECT)) :GLOBALLY-INLINE? TRUE (RETURN (AND (TEST-PROPERTY? SELF /PL-KERNEL-KB/@CLOSED) (NOT (MONOTONIC? *CONTEXT*)))))"
    (CL:FUNCTION CLOSED-BY-ASSERTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLOSED-TERM?"
    "(DEFUN (CLOSED-TERM? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (MEMOIZE (SELF *CONTEXT*) :TIMESTAMPS :KB-UPDATE :MAX-VALUES 500 (HELP-CLOSED-TERM? SELF NIL))))"
    (CL:FUNCTION CLOSED-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-CLOSED-TERM?"
    "(DEFUN (HELP-CLOSED-TERM? BOOLEAN) ((SELF OBJECT) (ACTIVETERMS CONS)))"
    (CL:FUNCTION HELP-CLOSED-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLOSED-PROPOSITION?"
    "(DEFUN (CLOSED-PROPOSITION? BOOLEAN) ((SELF PROPOSITION)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (MEMOIZE (SELF *CONTEXT*) :TIMESTAMPS :META-KB-UPDATE :MAX-VALUES 500 (HELP-CLOSED-PROPOSITION? SELF NIL))))"
    (CL:FUNCTION CLOSED-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-CLOSED-PROPOSITION?"
    "(DEFUN (HELP-CLOSED-PROPOSITION? BOOLEAN) ((SELF PROPOSITION) (ACTIVETERMS CONS)))"
    (CL:FUNCTION HELP-CLOSED-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/SINGLE-VALUED-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/SINGLE-VALUED-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/SINGLE-VALUED-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "SINGLE-VALUED-TERM?"
    "(DEFUN (SINGLE-VALUED-TERM? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION SINGLE-VALUED-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "NON-RECURSIVE-SINGLE-VALUED-TERM?"
    "(DEFUN (NON-RECURSIVE-SINGLE-VALUED-TERM? BOOLEAN) ((SELF OBJECT)))"
    (CL:FUNCTION NON-RECURSIVE-SINGLE-VALUED-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "SINGLE-VALUED-GOAL?"
    "(DEFUN (SINGLE-VALUED-GOAL? BOOLEAN) ((PROPOSITION PROPOSITION) (IOVARIABLES (CONS OF PATTERN-VARIABLE)) (BOUNDVARIABLES (CONS OF PATTERN-VARIABLE))) :PUBLIC? TRUE)"
    (CL:FUNCTION SINGLE-VALUED-GOAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-SINGLE-VALUED-GOAL?"
    "(DEFUN (HELP-SINGLE-VALUED-GOAL? BOOLEAN) ((PROPOSITION PROPOSITION) (IOVARIABLES (CONS OF PATTERN-VARIABLE)) (BOUNDVARIABLES (CONS OF PATTERN-VARIABLE)) (RECURSIVE? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION HELP-SINGLE-VALUED-GOAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-SINGLY-BOUND-VARIABLES"
    "(DEFUN HELP-COLLECT-SINGLY-BOUND-VARIABLES ((PROPOSITION PROPOSITION) (BOUNDVARIABLES (LIST OF PATTERN-VARIABLE)) (RECURSIVE? BOOLEAN)))"
    (CL:FUNCTION HELP-COLLECT-SINGLY-BOUND-VARIABLES) NULL)))

(CL:DEFUN HELP-STARTUP-SPECIALISTS5 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "CREATE-COLLECT-DESCRIPTION-EXTENSION-FRAME"
    "(DEFUN CREATE-COLLECT-DESCRIPTION-EXTENSION-FRAME ((FRAME CONTROL-FRAME) (DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION CREATE-COLLECT-DESCRIPTION-EXTENSION-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-DESCRIPTION-EXTENSION-FRAME?"
    "(DEFUN (COLLECT-DESCRIPTION-EXTENSION-FRAME? BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION COLLECT-DESCRIPTION-EXTENSION-FRAME?) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/NTH-HEAD-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/NTH-HEAD-COMPUTATION SKOLEM) ((LIST SKOLEM) (NARG INTEGER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/NTH-HEAD-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/NTH-REST-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/NTH-REST-COMPUTATION SKOLEM) ((LIST SKOLEM) (NARG INTEGER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/NTH-REST-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/INSERT-ELEMENT-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/INSERT-ELEMENT-COMPUTATION SKOLEM) ((LIST SKOLEM) (NARG INTEGER-WRAPPER) (ELEMENT OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/INSERT-ELEMENT-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/SUM-OF-NUMBERS-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/SUM-OF-NUMBERS-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/SUM-OF-NUMBERS-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-VARIANCE-OR-STANDARD-DEVIATION"
    "(DEFUN (COMPUTE-VARIANCE-OR-STANDARD-DEVIATION KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD) (STANDARD-DEVIATION? BOOLEAN)))"
    (CL:FUNCTION COMPUTE-VARIANCE-OR-STANDARD-DEVIATION) NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/STANDARD-DEVIATION-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/STANDARD-DEVIATION-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/STANDARD-DEVIATION-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/VARIANCE-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/VARIANCE-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/VARIANCE-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-DERIVE-PARTITION-MEMBERSHIPS"
    "(DEFUN HELP-DERIVE-PARTITION-MEMBERSHIPS ((SELF LOGIC-OBJECT) (SUPER LOGIC-OBJECT) (TUPLES (LIST OF PROPOSITION))))"
    (CL:FUNCTION HELP-DERIVE-PARTITION-MEMBERSHIPS) NULL)
   (DEFINE-FUNCTION-OBJECT "DERIVE-PARTITION-MEMBERSHIPS?"
    "(DEFUN (DERIVE-PARTITION-MEMBERSHIPS? BOOLEAN) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION DERIVE-PARTITION-MEMBERSHIPS?) NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST|)
    NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/REFUTATION-DISJOINT-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/REFUTATION-DISJOINT-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/REFUTATION-DISJOINT-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/EMPTY-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/EMPTY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/EMPTY-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "EMPTY-TERM?"
    "(DEFUN (EMPTY-TERM? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION EMPTY-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "CHEAP-EMPTY-TERM?"
    "(DEFUN (CHEAP-EMPTY-TERM? BOOLEAN) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION CHEAP-EMPTY-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPENSIVE-EMPTY-TERM?"
    "(DEFUN (EXPENSIVE-EMPTY-TERM? BOOLEAN) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION EXPENSIVE-EMPTY-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/CONTEXT-OF-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/CONTEXT-OF-COMPUTATION CONTEXT) ((INSTANCE OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/CONTEXT-OF-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/IST-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/IST-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/IST-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-ROLESET-OF"
    "(DEFUN (GET-ROLESET-OF SKOLEM) ((RELATION NAMED-DESCRIPTION) (INSTANCE OBJECT)))"
    (CL:FUNCTION GET-ROLESET-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-STORED-BOUND-ON-ROLESET"
    "(DEFUN (COMPUTE-STORED-BOUND-ON-ROLESET INTEGER) ((RELATION NAMED-DESCRIPTION) (INSTANCE OBJECT) (LOWERORUPPER KEYWORD)))"
    (CL:FUNCTION COMPUTE-STORED-BOUND-ON-ROLESET) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-MINIMUM-CARDINALITY"
    "(DEFUN (COMPUTE-MINIMUM-CARDINALITY INTEGER) ((RELATION NAMED-DESCRIPTION) (INSTANCE OBJECT)))"
    (CL:FUNCTION COMPUTE-MINIMUM-CARDINALITY) NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/RANGE-MIN-CARDINALITY-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/RANGE-MIN-CARDINALITY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/RANGE-MIN-CARDINALITY-SPECIALIST|)
    NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-MAXIMUM-CARDINALITY"
    "(DEFUN (COMPUTE-MAXIMUM-CARDINALITY INTEGER) ((RELATION NAMED-DESCRIPTION) (INSTANCE OBJECT)))"
    (CL:FUNCTION COMPUTE-MAXIMUM-CARDINALITY) NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/RANGE-MAX-CARDINALITY-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/RANGE-MAX-CARDINALITY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/RANGE-MAX-CARDINALITY-SPECIALIST|)
    NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-RANGE-TYPE?"
    "(DEFUN (TEST-RANGE-TYPE? BOOLEAN) ((RELATION NAMED-DESCRIPTION) (INSTANCE OBJECT) (VALUETYPE NAMED-DESCRIPTION)))"
    (CL:FUNCTION TEST-RANGE-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/RANGE-TYPE-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/REFLEXIVE-RELATION-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/REFLEXIVE-RELATION-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/REFLEXIVE-RELATION-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/IRREFLEXIVE-RELATION-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/IRREFLEXIVE-RELATION-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/IRREFLEXIVE-RELATION-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/OBJECT-NAME-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/OBJECT-NAME-COMPUTATION STRING-WRAPPER) ((OBJECTARG OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/OBJECT-NAME-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/NAME-TO-OBJECT-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/NAME-TO-OBJECT-COMPUTATION OBJECT) ((NAMEARG OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/NAME-TO-OBJECT-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/ARITY-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/ARITY-COMPUTATION INTEGER-WRAPPER) ((DESCRIPTIONARG OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/ARITY-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/ARITY-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/ARITY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/ARITY-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-PROJECT-NTH-COLUMN"
    "(DEFUN (HELP-PROJECT-NTH-COLUMN LIST) ((N INTEGER) (TUPLELIST LIST)))"
    (CL:FUNCTION HELP-PROJECT-NTH-COLUMN) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/ASSERT-SYNONYM-DEMON"
    "(DEFUN /PL-KERNEL-KB/ASSERT-SYNONYM-DEMON ((SELF PROPOSITION)))"
    (CL:FUNCTION |/PL-KERNEL-KB/ASSERT-SYNONYM-DEMON|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/RETRACT-SYNONYM-DEMON"
    "(DEFUN /PL-KERNEL-KB/RETRACT-SYNONYM-DEMON ((SELF PROPOSITION)))"
    (CL:FUNCTION |/PL-KERNEL-KB/RETRACT-SYNONYM-DEMON|) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SYNONYMS"
    "(DEFUN (GET-SYNONYMS (CONS OF LOGIC-OBJECT)) ((TERM OBJECT)))"
    (CL:FUNCTION GET-SYNONYMS) NULL)
   (DEFINE-FUNCTION-OBJECT "SYNONYM-SURROGATE?"
    "(DEFUN (SYNONYM-SURROGATE? BOOLEAN) ((NAME SURROGATE)))"
    (CL:FUNCTION SYNONYM-SURROGATE?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSFER-SYNONYMS"
    "(DEFUN TRANSFER-SYNONYMS ((OLDOBJECT OBJECT) (NEWOBJECT OBJECT)))"
    (CL:FUNCTION TRANSFER-SYNONYMS) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/DIFFERENT-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/DIFFERENT-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/DIFFERENT-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-NATIVE-SPECIALIST"
    "(DEFUN (LOOKUP-NATIVE-SPECIALIST FUNCTION-CODE) ((NATIVE-NAME STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the native funtion code for `native-name' if it exists
and the underlying programming languages supports such lookups.  Uses the signature
of a specialist function.\")" (CL:FUNCTION LOOKUP-NATIVE-SPECIALIST)
    NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-SPECIALIST-FUNCTION"
    "(DEFUN REGISTER-SPECIALIST-FUNCTION ((NAME STRING) (CODE FUNCTION-CODE)) :DOCUMENTATION \"Creates a registration entry for `name' as a specialist which
executes `code'.  Essentially just builds the Stella meta-information
tructure needed to funcall `name' as a specialist.  The function definition
in `code' needs to accept a CONTROL-FRAME and KEYWORD as arguments and
return a KEYWORD.  Side effects on elements of the proposition in the
control frame can be used to bind and thus return values.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REGISTER-SPECIALIST-FUNCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-SPECIALIST-FUNCTION-NAME"
    "(DEFUN REGISTER-SPECIALIST-FUNCTION-NAME ((STELLA-NAME STRING) (NATIVE-NAME STRING)) :PUBLIC? TRUE :COMMAND? TRUE :DOCUMENTATION \"registers a specialist function `stella-name' based on the `native-name'
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages.\")"
    (CL:FUNCTION %REGISTER-SPECIALIST-FUNCTION-NAME)
    (CL:FUNCTION REGISTER-SPECIALIST-FUNCTION-NAME-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "LOOKUP-NATIVE-COMPUTATION"
    "(DEFUN (LOOKUP-NATIVE-COMPUTATION FUNCTION-CODE) ((NATIVE-NAME STRING) (ARITY INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the native funtion code for `native-name' if it exists
and the underlying programming languages supports such lookups.  It is looked up
using the signature of a computation function supported by the computation specialist.\")"
    (CL:FUNCTION LOOKUP-NATIVE-COMPUTATION) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-COMPUTATION-FUNCTION"
    "(DEFUN REGISTER-COMPUTATION-FUNCTION ((NAME STRING) (CODE FUNCTION-CODE) (ARITY INTEGER)) :DOCUMENTATION \"Creates a registration entry for `name' as a computation which
executes `code'.  Essentially just builds the Stella meta-information
tructure needed to funcall `name' as a computation function by the
computation specialist.  The function definition in `code' needs to
accept ARITY Stella OBJECTs as arguments and return a Stella OBJECT 
suitable for PowerLoom use.  (These are generally LOGIC-OBJECTs and the
literal wrappers FLOAT-WRAPPER, INTEGER-WRAPPER and STRING-WRAPPER.)\" :PUBLIC? TRUE)"
    (CL:FUNCTION REGISTER-COMPUTATION-FUNCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-COMPUTATION-FUNCTION-NAME"
    "(DEFUN REGISTER-COMPUTATION-FUNCTION-NAME ((STELLA-NAME STRING) (NATIVE-NAME STRING) (ARITY INTEGER)) :PUBLIC? TRUE :COMMAND? TRUE :DOCUMENTATION \"registers a computation function `stella-name' based on the `native-name'
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages.\")"
    (CL:FUNCTION %REGISTER-COMPUTATION-FUNCTION-NAME)
    (CL:FUNCTION REGISTER-COMPUTATION-FUNCTION-NAME-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "STARTUP-SPECIALISTS"
    "(DEFUN STARTUP-SPECIALISTS () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-SPECIALISTS) NULL)
   (CL:LET*
    ((FUNCTION
      (LOOKUP-FUNCTION SYM-SPECIALISTS-LOGIC-STARTUP-SPECIALISTS)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-SPECIALISTS-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupSpecialists") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-SPECIALISTS ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-SPECIALISTS1)
    (HELP-STARTUP-SPECIALISTS2) (HELP-STARTUP-SPECIALISTS3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "COMPUTED-PROCEDURE"
        "(DEFCLASS COMPUTED-PROCEDURE (THING) :DOCUMENTATION \"Each instance denotes a programming language 
function that computes some procedure.  The slot 'procedure-name'
provides the name of the procedure.  The slot 'procedure-function'
points to the STELLA function object carrying out the computation.
If neither is supplied, the procedure will be looked up by extracting
its name from the name of the instance.  Pointing to a function object
instead of just the code gives us access to argument type information.
Note that we support external non-STELLA functions by creating a dummy
STELLA function object during registration of the computation (see
`register-computation-function' and friends).\" :PUBLIC? TRUE :PUBLIC-SLOTS ((PROCEDURE-NAME :TYPE SYMBOL) (PROCEDURE-FUNCTION :TYPE FUNCTION)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-COMPUTED-PROCEDURE))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-COMPUTED-PROCEDURE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "SUBSTRING-POSITION-ITERATOR"
        "(DEFCLASS SUBSTRING-POSITION-ITERATOR (ITERATOR) :SLOTS ((SUPER-STRING :TYPE STRING :REQUIRED? TRUE) (SUB-STRING :TYPE STRING :REQUIRED? TRUE) (START :TYPE INTEGER :INITIALLY 0) (SUB-LENGTH :TYPE INTEGER :INITIALLY (LENGTH (SUB-STRING SELF)))))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SUBSTRING-POSITION-ITERATOR))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SUBSTRING-POSITION-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FORK-PROOF-ADJUNCT"
        "(DEFCLASS FORK-PROOF-ADJUNCT (PROOF-ADJUNCT) :SLOTS ((CONDITION-JUSTIFICATION :TYPE JUSTIFICATION) (DOWN-FRAME :TYPE CONTROL-FRAME)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-FORK-PROOF-ADJUNCT))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-FORK-PROOF-ADJUNCT-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT"
        "(DEFCLASS SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT (PROOF-ADJUNCT) :SLOTS ((SAVED-INFERENCE-LEVEL :TYPE INFERENCE-LEVEL) (INFERENCE-LEVEL :TYPE INFERENCE-LEVEL) (DOWN-FRAME :TYPE CONTROL-FRAME)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION
       ACCESS-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "SAVED-CONTEXT-PROOF-ADJUNCT"
        "(DEFCLASS SAVED-CONTEXT-PROOF-ADJUNCT (PROOF-ADJUNCT) :SLOTS ((SAVED-CONTEXT :TYPE CONTEXT) (DOWN-FRAME :TYPE CONTROL-FRAME)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SAVED-CONTEXT-PROOF-ADJUNCT))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SAVED-CONTEXT-PROOF-ADJUNCT-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-SPECIALISTS4)
    (HELP-STARTUP-SPECIALISTS5))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC")))
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-FORK-THEN
     KWD-SPECIALISTS-TECHNICAL
     "by FORK-introduction of its THEN argument")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-FORK-THEN
     KWD-SPECIALISTS-LAY
     "since the condition and THEN-clause of a FORK-proposition succeeded")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-FORK-ELSE
     KWD-SPECIALISTS-TECHNICAL
     "by FORK-introduction of its ELSE argument")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-FORK-ELSE
     KWD-SPECIALISTS-LAY
     "since the condition and ELSE-clause of a FORK-proposition succeeded")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PROTOTYPE-ID-COUNTER* INTEGER 0)")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-COLLECT-MEMBERS
     KWD-SPECIALISTS-TECHNICAL
     "since it was proven by the COLLECT-MEMBERS specialist")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-COLLECT-MEMBERS
     KWD-SPECIALISTS-LAY
     "because of a specialized COLLECT-MEMBERS reasoning procedure")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-IST-INTRODUCTION
     KWD-SPECIALISTS-TECHNICAL "by IST-Introduction")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-IST-INTRODUCTION
     KWD-SPECIALISTS-LAY "because its argument is true")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-IST-INTRODUCTION
     KWD-SPECIALISTS-LAY "because its argument is partly true"
     KWD-SPECIALISTS-PARTIAL)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ACCELERATE-FRAME-COMPUTATIONS?* BOOLEAN TRUE :DOCUMENTATION \"Used to test how big is the effect of the frame
specialists.\")")
    (REGISTER-NATIVE-NAME
     SYM-SPECIALISTS-LOGIC-REGISTER-SPECIALIST-FUNCTION-NAME
     KWD-SPECIALISTS-COMMON-LISP KWD-SPECIALISTS-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-SPECIALISTS-LOGIC-REGISTER-COMPUTATION-FUNCTION-NAME
     KWD-SPECIALISTS-COMMON-LISP KWD-SPECIALISTS-FUNCTION))))
