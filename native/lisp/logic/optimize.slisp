;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; optimize.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-OPTIMIZE-LOGIC-GOAL-RECORD NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-GENERATOR-GOALS NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-OTHER-GOALS NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-EXTERNAL-VARIABLES NULL)
(CL:DEFVAR SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-OPTIMIZE-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-OPTIMIZE-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR KWD-OPTIMIZE-OR NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-PERMUTATION-TABLE NULL)
(CL:DEFVAR SGT-OPTIMIZE-PL-KERNEL-KB-COMPUTED NULL)
(CL:DEFVAR SGT-OPTIMIZE-PL-KERNEL-KB-RELATION-CONSTRAINT NULL)
(CL:DEFVAR SGT-OPTIMIZE-PL-KERNEL-KB-ABSTRACT NULL)
(CL:DEFVAR SGT-OPTIMIZE-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-OPTIMIZER-GOAL-RECORDS NULL)
(CL:DEFVAR KWD-OPTIMIZE-FUNCTION NULL)
(CL:DEFVAR KWD-OPTIMIZE-EQUIVALENT NULL)
(CL:DEFVAR KWD-OPTIMIZE-ISA NULL)
(CL:DEFVAR KWD-OPTIMIZE-PREDICATE NULL)
(CL:DEFVAR KWD-OPTIMIZE-NOT NULL)
(CL:DEFVAR KWD-OPTIMIZE-FAIL NULL)
(CL:DEFVAR KWD-OPTIMIZE-IMPLIES NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-UNIQUENESSVECTORS NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-INVERSE-DESCRIPTION NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-INDEXING-VECTOR NULL)
(CL:DEFVAR SGT-OPTIMIZE-PL-KERNEL-KB-OBSERVED-CARDINALITY-OF NULL)
(CL:DEFVAR SGT-OPTIMIZE-STELLA-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-OPTIMIZE-STELLA-COLLECTION NULL)
(CL:DEFVAR SGT-OPTIMIZE-PL-KERNEL-KB-MEMBER-OF NULL)
(CL:DEFVAR KWD-OPTIMIZE-OPTIMIZER NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-BEST-GOAL-SEQUENCE NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-BEST-COST NULL)
(CL:DEFVAR KWD-OPTIMIZE-FORALL NULL)
(CL:DEFVAR KWD-OPTIMIZE-EXISTS NULL)
(CL:DEFVAR KWD-OPTIMIZE-STATIC-WITH-CLUSTERING NULL)
(CL:DEFVAR KWD-OPTIMIZE-DESCRIPTION NULL)
(CL:DEFVAR KWD-OPTIMIZE-AND NULL)
(CL:DEFVAR KWD-OPTIMIZE-BOUND NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-RESIDUE-GOALS NULL)
(CL:DEFVAR KWD-OPTIMIZE-PATTERN NULL)
(CL:DEFVAR KWD-OPTIMIZE-DYNAMIC NULL)
(CL:DEFVAR KWD-OPTIMIZE-DYNAMIC-WITH-CLUSTERING NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-DONT-OPTIMIZE? NULL)
(CL:DEFVAR KWD-OPTIMIZE-NONE NULL)
(CL:DEFVAR SGT-OPTIMIZE-PL-KERNEL-KB-CUT NULL)
(CL:DEFVAR SGT-OPTIMIZE-PL-KERNEL-KB-BOUND-VARIABLES NULL)
(CL:DEFVAR SGT-OPTIMIZE-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SGT-OPTIMIZE-PL-KERNEL-KB-INSTANCE-OF NULL)
(CL:DEFVAR SGT-OPTIMIZE-PL-KERNEL-KB-TOTAL NULL)
(CL:DEFVAR KWD-OPTIMIZE-RELATION NULL)
(CL:DEFVAR SGT-OPTIMIZE-STELLA-THING NULL)
(CL:DEFVAR KWD-OPTIMIZE-REALISTIC NULL)
(CL:DEFVAR KWD-OPTIMIZE-FLAT NULL)
(CL:DEFVAR SGT-OPTIMIZE-STELLA-CS-VALUE NULL)
(CL:DEFVAR KWD-OPTIMIZE-CONSTANT NULL)
(CL:DEFVAR SYM-OPTIMIZE-STELLA-PREDICATE NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-WEIGHT NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-VARIABLE-TYPE? NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-DESCRIPTIVE? NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-ANNOTATIONS NULL)
(CL:DEFVAR SGT-OPTIMIZE-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-OPTIMIZE-PL-KERNEL-KB-EQUIVALENT NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-EQUIVALENT NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-CONSTANT NULL)
(CL:DEFVAR SGT-OPTIMIZE-STELLA-VECTOR NULL)
(CL:DEFVAR KWD-OPTIMIZE-CONCEIVE NULL)
(CL:DEFVAR SYM-OPTIMIZE-LOGIC-STARTUP-OPTIMIZE NULL)
(CL:DEFVAR SYM-OPTIMIZE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *COLLECTFORWARDPROPOSITIONS*
  DEFAULT-TRUE-TRUTH-VALUE TRUE-TRUTH-VALUE ZERO-VARIABLES-VECTOR
  *PRINTMODE* TRUE-PROPOSITION *QUERY-OPTIMIZATION-STRATEGY*
  NULL-FLOAT-WRAPPER *TRACED-KEYWORDS* STANDARD-OUTPUT EOL TRUE-WRAPPER
  FALSE-WRAPPER NULL-FLOAT *MODULE* ONE-WRAPPER ZERO-WRAPPER NIL-LIST
  NULL-INTEGER *REVERSEPOLARITY?* *CONTEXT* NIL *QUERYITERATOR*))

(CL:DEFUN NEW-GOAL-RECORD ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-GOAL-RECORD))
   (CL:SETF (%GOAL-RECORD.OTHER-GOALS SELF) (NEW-LIST))
   (CL:SETF (%GOAL-RECORD.GENERATOR-GOALS SELF) (NEW-LIST)) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF GOAL-RECORD))
  SGT-OPTIMIZE-LOGIC-GOAL-RECORD)

(CL:DEFUN ACCESS-GOAL-RECORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-OPTIMIZE-LOGIC-GENERATOR-GOALS)
    (CL:IF SETVALUE?
     (CL:SETF (%GOAL-RECORD.GENERATOR-GOALS SELF) VALUE)
     (CL:SETQ VALUE (%GOAL-RECORD.GENERATOR-GOALS SELF))))
   ((CL:EQ SLOTNAME SYM-OPTIMIZE-LOGIC-OTHER-GOALS)
    (CL:IF SETVALUE? (CL:SETF (%GOAL-RECORD.OTHER-GOALS SELF) VALUE)
     (CL:SETQ VALUE (%GOAL-RECORD.OTHER-GOALS SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (VARIABLE-BOUND? BOOLEAN) ...)

(CL:DEFUN VARIABLE-BOUND? (VARIABLE)
  (CL:OR
   (CL:NOT
    (CL:EQ
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY
        (%PATTERN-RECORD.VARIABLE-BINDINGS
         (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
      (CL:THE CL:FIXNUM (%PATTERN-VARIABLE.BOUND-TO-OFFSET VARIABLE)))
     NULL))
   (CL:NOT
    (CL:EQ
     (ACCESS-IN-CONTEXT (%SKOLEM.VARIABLE-VALUE VARIABLE)
      (%SKOLEM.HOME-CONTEXT VARIABLE) CL:NIL)
     NULL))))

;;; (DEFUN (ARGUMENT-BOUND? BOOLEAN) ...)

(CL:DEFUN ARGUMENT-BOUND? (ARGUMENT)
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE ARGUMENT)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN (VARIABLE-BOUND? ARGUMENT)))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-OPTIMIZE-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:IF
       (CL:NOT
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS ARGUMENT)
          SYM-OPTIMIZE-LOGIC-IO-VARIABLES NULL)
         NULL))
       (QUANTIFIED-ARGUMENT-BOUND? ARGUMENT NULL)
       (CL:LET* ((ALWAYS?-000 CL:T))
        (CL:LET*
         ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS ARGUMENT))
          (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:SETQ ARG
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:WHEN (CL:NOT (ARGUMENT-BOUND? ARG))
           (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
        (CL:LET* ((VALUE-000 ALWAYS?-000)) VALUE-000)))))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-OPTIMIZE-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 CL:NIL))
       (CL:IF
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS ARGUMENT)
          SYM-OPTIMIZE-LOGIC-EXTERNAL-VARIABLES NULL)
         NULL)
        (CL:SETQ TEST-VALUE-000 CL:T)
        (CL:LET* ((ALWAYS?-001 CL:T))
         (CL:LET*
          ((V NULL)
           (VECTOR-001
            (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS ARGUMENT)
             SYM-OPTIMIZE-LOGIC-EXTERNAL-VARIABLES NULL))
           (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
          (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
           (CL:SETQ V
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
             INDEX-001))
           (CL:WHEN (CL:NOT (ARGUMENT-BOUND? V))
            (CL:SETQ ALWAYS?-001 CL:NIL) (CL:RETURN))
           (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
         (CL:SETQ TEST-VALUE-000 ALWAYS?-001)))
       (CL:LET* ((VALUE-001 TEST-VALUE-000)) VALUE-001))))
    (CL:T CL:T))))

;;; (DEFUN (QUANTIFIED-ARGUMENT-BOUND? BOOLEAN) ...)

(CL:DEFUN QUANTIFIED-ARGUMENT-BOUND? (ARGUMENT QUANTIFIEDVARS)
  (CL:WHEN (CL:EQ QUANTIFIEDVARS NULL)
   (CL:SETQ QUANTIFIEDVARS (NEW-LIST)))
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE ARGUMENT)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN
      (CL:OR (VARIABLE-BOUND? ARGUMENT)
       (MEMB? QUANTIFIEDVARS ARGUMENT))))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-OPTIMIZE-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:LET*
       ((IOVARS
         (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS ARGUMENT)
          SYM-OPTIMIZE-LOGIC-IO-VARIABLES NULL)))
       (CL:WHEN (CL:NOT (CL:EQ IOVARS NULL))
        (CL:LET*
         ((VAR NULL) (VECTOR-000 IOVARS) (INDEX-000 0)
          (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:SETQ VAR
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
            INDEX-000))
          (INSERT QUANTIFIEDVARS VAR)
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
       (CL:LET* ((ALWAYS?-000 CL:T))
        (CL:LET*
         ((ARG NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS ARGUMENT))
          (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
         (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
          (CL:SETQ ARG
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
            INDEX-001))
          (CL:WHEN
           (CL:NOT (QUANTIFIED-ARGUMENT-BOUND? ARG QUANTIFIEDVARS))
           (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
          (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
        (CL:LET* ((VALUE-000 ALWAYS?-000)) VALUE-000)))))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-OPTIMIZE-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 CL:NIL))
       (CL:IF
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS ARGUMENT)
          SYM-OPTIMIZE-LOGIC-EXTERNAL-VARIABLES NULL)
         NULL)
        (CL:SETQ TEST-VALUE-000 CL:T)
        (CL:LET* ((ALWAYS?-001 CL:T))
         (CL:LET*
          ((V NULL)
           (VECTOR-002
            (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS ARGUMENT)
             SYM-OPTIMIZE-LOGIC-EXTERNAL-VARIABLES NULL))
           (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
          (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
           (CL:SETQ V
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
             INDEX-002))
           (CL:WHEN
            (CL:NOT (QUANTIFIED-ARGUMENT-BOUND? V QUANTIFIEDVARS))
            (CL:SETQ ALWAYS?-001 CL:NIL) (CL:RETURN))
           (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
         (CL:SETQ TEST-VALUE-000 ALWAYS?-001)))
       (CL:LET* ((VALUE-001 TEST-VALUE-000)) VALUE-001))))
    (CL:T CL:T))))

;;; (DEFUN (UNBOUND-VARIABLE? BOOLEAN) ...)

(CL:DEFUN UNBOUND-VARIABLE? (ARGUMENT)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARGUMENT)
     SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)
    (CL:PROGN (CL:NOT (VARIABLE-BOUND? ARGUMENT))))
   (CL:T CL:NIL)))

;;; (DEFUN (HAS-DISJUNCTION? BOOLEAN) ...)

(CL:DEFUN HAS-DISJUNCTION? (GOAL)
  (CL:WHEN (CL:EQ (%PROPOSITION.KIND GOAL) KWD-OPTIMIZE-OR)
   (CL:RETURN-FROM HAS-DISJUNCTION? CL:T))
  (CL:LET* ((FOUND?-000 CL:NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS GOAL))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:WHEN
      (CL:AND (ISA? ARG SGT-OPTIMIZE-LOGIC-PROPOSITION)
       (HAS-DISJUNCTION? ARG))
      (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000)))

;;; (DEFUN (MODAL-GOAL? BOOLEAN) ...)

(CL:DEFUN MODAL-GOAL? (GOAL)
  (CL:LET* ((FOUND?-000 CL:NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS GOAL))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:WHEN (ISA? ARG SGT-OPTIMIZE-LOGIC-PROPOSITION)
      (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000)))

;;; (DEFUN (HAS-INVERSIONS? BOOLEAN) ...)

(CL:DEFUN HAS-INVERSIONS? (GOAL)
  (CL:NOT
   (CL:EQ
    (DYNAMIC-SLOT-VALUE
     (%NAMED-DESCRIPTION.DYNAMIC-SLOTS
      (GET-DESCRIPTION (%PROPOSITION.OPERATOR GOAL)))
     SYM-OPTIMIZE-LOGIC-PERMUTATION-TABLE NULL)
    NULL)))

;;; (DEFUN (COMPUTED-TERM? BOOLEAN) ...)

(CL:DEFUN COMPUTED-TERM? (SELF)
  (TEST-PROPERTY? SELF SGT-OPTIMIZE-PL-KERNEL-KB-COMPUTED))

;;; (DEFUN (COMPUTED-CONSTRAINT? BOOLEAN) ...)

(CL:DEFUN COMPUTED-CONSTRAINT? (SELF)
  (CL:AND (TEST-PROPERTY? SELF SGT-OPTIMIZE-PL-KERNEL-KB-COMPUTED)
   (CL:NOT
    (CL:EQ
     (ACCESS-BINARY-VALUE SELF
      SGT-OPTIMIZE-PL-KERNEL-KB-RELATION-CONSTRAINT)
     NULL))))

;;; (DEFUN (COMPUTED-PREDICATE? BOOLEAN) ...)

(CL:DEFUN COMPUTED-PREDICATE? (GOAL)
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION (%PROPOSITION.OPERATOR GOAL))))
   (CL:AND (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:OR (COMPUTED-TERM? DESCRIPTION)
     (MEMBER?
      (GET-QUOTED-TREE
       "((/PL-KERNEL-KB/@LISTOF /PL-KERNEL-KB/@SETOF) \"/LOGIC\")"
       "/LOGIC")
      (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE DESCRIPTION))))))

;;; (DEFUN (SIMULATE-CREATE-CHOICE-POINT INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION () CL:FIXNUM) SIMULATE-CREATE-CHOICE-POINT))
(CL:DEFUN SIMULATE-CREATE-CHOICE-POINT ()
  (CL:1+
   (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET
    (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))))

;;; (DEFUN (RELATION-SUPPORTS-EXTENSION? BOOLEAN) ...)

(CL:DEFUN RELATION-SUPPORTS-EXTENSION? (SELF)
  (CL:AND
   (CL:NOT (TEST-PROPERTY? SELF SGT-OPTIMIZE-PL-KERNEL-KB-ABSTRACT))
   (CL:NOT
    (LOGICAL-SUBTYPE-OF-LITERAL?
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE SELF)))))

;;; (DEFUN (GENERATOR-COLLECTION? BOOLEAN) ...)

(CL:DEFUN GENERATOR-COLLECTION? (COLLECTION)
  (CL:WHEN
   (CL:AND *REVERSEPOLARITY?* (CL:NOT (CLOSED-TERM? COLLECTION)))
   (CL:RETURN-FROM GENERATOR-COLLECTION? CL:NIL))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE COLLECTION)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-OPTIMIZE-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:OR
       (CL:NOT (ISA? COLLECTION SGT-OPTIMIZE-LOGIC-NAMED-DESCRIPTION))
       (RELATION-SUPPORTS-EXTENSION? COLLECTION))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN
      (CL:LET* ((BOUNDTOVALUE (ARGUMENT-BOUND-TO COLLECTION)))
       (CL:COND
        ((CL:NOT (CL:EQ BOUNDTOVALUE NULL))
         (GENERATOR-COLLECTION? BOUNDTOVALUE))
        ((CL:NOT
          (CL:EQ (%PATTERN-VARIABLE.DEFINING-PROPOSITION COLLECTION)
           NULL))
         CL:T)
        (CL:T CL:NIL)))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (RELATION-SUPPORTS-EXTENSION? (GET-DESCRIPTION COLLECTION))))
    (CL:T CL:T))))

;;; (DEFUN INITIALIZE-OPTIMIZER-GOAL-RECORDS ...)

(CL:DEFUN INITIALIZE-OPTIMIZER-GOAL-RECORDS (SIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
  #+MCL
  (CL:CHECK-TYPE SIZE CL:FIXNUM)
  (CL:LET*
   ((STACK
     (DYNAMIC-SLOT-VALUE
      (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
      SYM-OPTIMIZE-LOGIC-OPTIMIZER-GOAL-RECORDS NULL)))
   (CL:WHEN (CL:EQ STACK NULL)
    (CL:SETQ STACK (NEW-EXTENSIBLE-VECTOR 20))
    (SET-DYNAMIC-SLOT-VALUE
     (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
     SYM-OPTIMIZE-LOGIC-OPTIMIZER-GOAL-RECORDS STACK NULL))
   (CL:WHEN (CL:> SIZE (LENGTH STACK)) (INSERT-AT STACK SIZE NULL))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- SIZE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:LET*
      ((GOALRECORD
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY STACK))
         I)))
      (CL:WHEN (CL:EQ GOALRECORD NULL)
       (CL:SETQ GOALRECORD (NEW-GOAL-RECORD))
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY STACK)) (VALUE GOALRECORD)
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE)))
      (CLEAR (%GOAL-RECORD.GENERATOR-GOALS GOALRECORD))
      (CLEAR (%GOAL-RECORD.OTHER-GOALS GOALRECORD)))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))))

;;; (DEFUN (GOAL-RECORD GOAL-RECORD) ...)

(CL:DEFUN GOAL-RECORD (VARIABLE)
  (CL:AREF
   (CL:THE CL:SIMPLE-VECTOR
    (%VECTOR.THE-ARRAY
     (DYNAMIC-SLOT-VALUE
      (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
      SYM-OPTIMIZE-LOGIC-OPTIMIZER-GOAL-RECORDS NULL)))
   (CL:THE CL:FIXNUM (%PATTERN-VARIABLE.BOUND-TO-OFFSET VARIABLE))))

;;; (DEFSPECIAL *DISTRIBUTEDOPENGOAL?* ...)

(CL:DEFVAR *DISTRIBUTEDOPENGOAL?* CL:NIL
  "Used by 'distribute-open-goal' to signal that
a goal was distributed by 'help-distribute-goal'.")

;;; (DEFUN HELP-DISTRIBUTE-GOAL ...)

(CL:DEFUN HELP-DISTRIBUTE-GOAL (ARGUMENT PARENTGOAL GENERATOR?)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARGUMENT)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN
      (CL:WHEN (VARIABLE-BOUND? ARGUMENT)
       (CL:RETURN-FROM HELP-DISTRIBUTE-GOAL))
      (CL:LET* ((GOALRECORD (GOAL-RECORD ARGUMENT)))
       (CL:WHEN
        (CL:OR
         (MEMBER? (%GOAL-RECORD.GENERATOR-GOALS GOALRECORD) PARENTGOAL)
         (MEMBER? (%GOAL-RECORD.OTHER-GOALS GOALRECORD) PARENTGOAL))
        (CL:RETURN-FROM HELP-DISTRIBUTE-GOAL))
       (CL:IF GENERATOR?
        (INSERT (%GOAL-RECORD.GENERATOR-GOALS GOALRECORD) PARENTGOAL)
        (INSERT (%GOAL-RECORD.OTHER-GOALS GOALRECORD) PARENTGOAL))
       (CL:SETQ *DISTRIBUTEDOPENGOAL?* CL:T))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-OPTIMIZE-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS ARGUMENT))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (HELP-DISTRIBUTE-GOAL ARG PARENTGOAL GENERATOR?)
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))))
    (CL:T))))

;;; (DEFUN DISTRIBUTE-OPEN-GOAL ...)

(CL:DEFUN DISTRIBUTE-OPEN-GOAL (GOAL)
  (CL:LET* ((*DISTRIBUTEDOPENGOAL?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *DISTRIBUTEDOPENGOAL?*))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND GOAL)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FUNCTION)
      (CL:LET*
       ((ARG NULL) (ITER-000 (BUT-LAST (%PROPOSITION.ARGUMENTS GOAL))))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ ARG (%ITERATOR.VALUE ITER-000))
        (HELP-DISTRIBUTE-GOAL ARG GOAL
         (CL:NOT (COMPUTED-PREDICATE? GOAL)))))
      (HELP-DISTRIBUTE-GOAL
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
        (CL:THE CL:FIXNUM
         (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS GOAL)))))
       GOAL CL:NIL))
     ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-EQUIVALENT)
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS GOAL))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (HELP-DISTRIBUTE-GOAL ARG GOAL CL:NIL)
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
     ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-ISA)
      (HELP-DISTRIBUTE-GOAL
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
        0)
       GOAL
       (GENERATOR-COLLECTION?
        (GET-DESCRIPTION (%PROPOSITION.OPERATOR GOAL)))))
     ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-PREDICATE)
      (CL:LET*
       ((ARG NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS GOAL))
        (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (HELP-DISTRIBUTE-GOAL ARG GOAL
         (CL:NOT (COMPUTED-PREDICATE? GOAL)))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-NOT)
       (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FAIL))
      (HELP-DISTRIBUTE-GOAL
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
        0)
       GOAL CL:NIL))
     ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-IMPLIES)
      (CL:LET*
       ((ARG NULL) (VECTOR-002 (%PROPOSITION.ARGUMENTS GOAL))
        (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
       (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
          INDEX-002))
        (HELP-DISTRIBUTE-GOAL ARG GOAL CL:T)
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))))
     (CL:T)))
   (CL:WHEN (CL:NOT *DISTRIBUTEDOPENGOAL?*)
    (INSERT (RESIDUE-GOALS *QUERYITERATOR*) GOAL))))

(CL:DEFMETHOD UNIQUENESSVECTORS ((SELF NAMED-DESCRIPTION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
      SYM-OPTIMIZE-LOGIC-UNIQUENESSVECTORS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

;;; (DEFCONSTANT V-0-0 ...)

(CL:DEFVAR V-0-0 NULL)

;;; (DEFCONSTANT V-1-0 ...)

(CL:DEFVAR V-1-0 NULL)

;;; (DEFCONSTANT V-0-1 ...)

(CL:DEFVAR V-0-1 NULL)

;;; (DEFCONSTANT V-1-1 ...)

(CL:DEFVAR V-1-1 NULL)

;;; (DEFCONSTANT V-1-0-AND-V-0-1 ...)

(CL:DEFVAR V-1-0-AND-V-0-1 NULL)

;;; (DEFCONSTANT V-1-0-SINGLETON ...)

(CL:DEFVAR V-1-0-SINGLETON NULL)

;;; (DEFCONSTANT V-0-1-SINGLETON ...)

(CL:DEFVAR V-0-1-SINGLETON NULL)

;;; (DEFUN (GET-BINARY-UNIQUENESS-VECTORS (LIST OF BOOLEAN-VECTOR)) ...)

(CL:DEFUN GET-BINARY-UNIQUENESS-VECTORS (SELF)
  (CL:LET*
   ((SINGLEVALUEDINVERSE?
     (CL:AND
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
         SYM-OPTIMIZE-LOGIC-INVERSE-DESCRIPTION NULL)
        NULL))
      (SINGLE-VALUED-TERM?
       (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-OPTIMIZE-LOGIC-INVERSE-DESCRIPTION NULL)))))
   (CL:IF (SINGLE-VALUED-TERM? SELF)
    (CL:IF SINGLEVALUEDINVERSE? V-1-0-AND-V-0-1 V-1-0-SINGLETON)
    (CL:IF SINGLEVALUEDINVERSE? V-0-1-SINGLETON NIL-LIST))))

;;; (DEFUN (GET-UNIQUENESS-VECTORS (LIST OF BOOLEAN-VECTOR)) ...)

(CL:DEFUN GET-UNIQUENESS-VECTORS (SELF)
  (CL:WHEN (CL:= (ARITY SELF) 2)
   (CL:RETURN-FROM GET-UNIQUENESS-VECTORS
    (GET-BINARY-UNIQUENESS-VECTORS SELF)))
  (CL:LET* ((CACHEDVECTORLIST (UNIQUENESSVECTORS SELF)))
   (CL:IF (CL:NOT (CL:EQ CACHEDVECTORLIST NULL)) CACHEDVECTORLIST
    NIL-LIST)))

;;; (DEFUN (GET-BINARY-INDEXING-VECTOR BOOLEAN-VECTOR) ...)

(CL:DEFUN GET-BINARY-INDEXING-VECTOR (SELF)
  (CL:LET*
   ((IOVARIABLETYPES (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES SELF))
    (TYPEONE (ENSURE-DEFERRED-DESCRIPTION (NTH IOVARIABLETYPES 0)))
    (TYPETWO (ENSURE-DEFERRED-DESCRIPTION (NTH IOVARIABLETYPES 1)))
    (BITONE? (TYPE-HAS-BACKLINKS? TYPEONE))
    (BITTWO? (TYPE-HAS-BACKLINKS? TYPETWO)))
   (CL:IF BITONE? (CL:IF BITTWO? V-1-1 V-1-0)
    (CL:IF BITTWO? V-0-1 V-0-0))))

;;; (DEFUN (GET-INDEXING-VECTOR BOOLEAN-VECTOR) ...)

(CL:DEFUN GET-INDEXING-VECTOR (SELF)
  (CL:WHEN (CL:= (ARITY SELF) 2)
   (CL:RETURN-FROM GET-INDEXING-VECTOR
    (GET-BINARY-INDEXING-VECTOR SELF)))
  (CL:LET*
   ((CACHEDVECTOR
     (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
      SYM-OPTIMIZE-LOGIC-INDEXING-VECTOR NULL)))
   (CL:WHEN (CL:NOT (CL:EQ CACHEDVECTOR NULL))
    (CL:RETURN-FROM GET-INDEXING-VECTOR CACHEDVECTOR))
   (CL:LET* ((ZEROONELIST (NEW-LIST)))
    (CL:LET*
     ((TYPE NULL)
      (ITER-000
       (%LIST.THE-CONS-LIST
        (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES SELF)))
      (COLLECT-000 NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ TYPE (%%VALUE ITER-000))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000
         (CONS
          (CL:IF
           (TYPE-HAS-BACKLINKS? (ENSURE-DEFERRED-DESCRIPTION TYPE))
           ONE-WRAPPER ZERO-WRAPPER)
          NIL))
        (CL:IF (CL:EQ (%LIST.THE-CONS-LIST ZEROONELIST) NIL)
         (CL:SETF (%LIST.THE-CONS-LIST ZEROONELIST) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST
          (%LIST.THE-CONS-LIST ZEROONELIST) COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS
          (CL:IF
           (TYPE-HAS-BACKLINKS? (ENSURE-DEFERRED-DESCRIPTION TYPE))
           ONE-WRAPPER ZERO-WRAPPER)
          NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (SET-DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
     SYM-OPTIMIZE-LOGIC-INDEXING-VECTOR
     (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR ZEROONELIST) NULL)
    (FREE ZEROONELIST)
    (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
     SYM-OPTIMIZE-LOGIC-INDEXING-VECTOR NULL))))

;;; (DEFCONSTANT ESTIMATED-SLOT-VALUE-COLLECTION-SIZE ...)

(CL:DEFVAR ESTIMATED-SLOT-VALUE-COLLECTION-SIZE 4.0d0
  "Estimate of the average size of a collection
representing the fillers of a slot.")
(CL:DECLAIM
 (CL:TYPE CL:DOUBLE-FLOAT ESTIMATED-SLOT-VALUE-COLLECTION-SIZE))

;;; (DEFCONSTANT ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS ...)

(CL:DEFVAR ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS 6.0d0
  "Very crude estimate of the number of stored propositions
that will match a predicate at least one of whose arguments are bound.
Chosen to be larger than ESTIMATED-SLOT-VALUE-COLLECTION-SIZE.")
(CL:DECLAIM
 (CL:TYPE CL:DOUBLE-FLOAT ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS))

;;; (DEFCONSTANT ESTIMATED-SIZE-OF-CLASS-EXTENSION ...)

(CL:DEFVAR ESTIMATED-SIZE-OF-CLASS-EXTENSION 11.0d0
  "Must be greater than ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS
to force the optimizer to prefer predicates containing at least
one bound variable.  Also greater than ESTIMATED-SIZE-OF-PREDICATE-EXTENSION,
for no particularly valid reason.")
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT ESTIMATED-SIZE-OF-CLASS-EXTENSION))

;;; (DEFCONSTANT ESTIMATED-CARDINALITY-OF-DESCRIPTION ...)

(CL:DEFVAR ESTIMATED-CARDINALITY-OF-DESCRIPTION 20.0d0
  "Indefensible estimate of the number instances
generable by an arbitrary unnamed description.")
(CL:DECLAIM
 (CL:TYPE CL:DOUBLE-FLOAT ESTIMATED-CARDINALITY-OF-DESCRIPTION))

;;; (DEFCONSTANT ESTIMATED-CARDINALITY-OF-MEMBER-OF ...)

(CL:DEFVAR ESTIMATED-CARDINALITY-OF-MEMBER-OF 30.0d0
  "Even more indefensible estimate of the number instances
generable by a 'member-of' predicate.  CAUTION: Must be set
less than 'ESTIMATED-CARDINALITY-OF-SUBSET-OF'.")
(CL:DECLAIM
 (CL:TYPE CL:DOUBLE-FLOAT ESTIMATED-CARDINALITY-OF-MEMBER-OF))

;;; (DEFCONSTANT ESTIMATED-CARDINALITY-OF-SUBSET-OF ...)

(CL:DEFVAR ESTIMATED-CARDINALITY-OF-SUBSET-OF 40.0d0
  "Egregiously indefensible estimate of the number instances
generable by a 'subset-of' predicate.  Set high because 'subset-of'
can't generate all defined supersets or subsets, causing potential
incompleteness.")
(CL:DECLAIM
 (CL:TYPE CL:DOUBLE-FLOAT ESTIMATED-CARDINALITY-OF-SUBSET-OF))

;;; (DEFUN UPDATE-OBSERVED-CARDINALITY ...)

(CL:DEFUN UPDATE-OBSERVED-CARDINALITY (SELF CARDINALITY)
  (CL:DECLARE (CL:TYPE CL:FIXNUM CARDINALITY))
  #+MCL
  (CL:CHECK-TYPE CARDINALITY CL:FIXNUM)
  (CL:LET*
   ((*CONTEXT* *MODULE*) (*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)))
   (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
   (CL:LET* ((*INVISIBLEASSERTION?* CL:T))
    (CL:DECLARE (CL:SPECIAL *INVISIBLEASSERTION?*))
    (ASSERT-TUPLE SGT-OPTIMIZE-PL-KERNEL-KB-OBSERVED-CARDINALITY-OF
     (CONS-LIST SELF (WRAP-INTEGER CARDINALITY))))))

;;; (DEFUN (ACCESS-OBSERVED-CARDINALITY INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) ACCESS-OBSERVED-CARDINALITY))
(CL:DEFUN ACCESS-OBSERVED-CARDINALITY (SELF)
  (CL:LET*
   ((*CONTEXT* *MODULE*) (*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)))
   (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
   (CL:LET*
    ((VALUE
      (ACCESS-BINARY-VALUE SELF
       SGT-OPTIMIZE-PL-KERNEL-KB-OBSERVED-CARDINALITY-OF)))
    (CL:IF
     (CL:AND (CL:NOT (CL:EQ VALUE NULL))
      (ISA? VALUE SGT-OPTIMIZE-STELLA-INTEGER-WRAPPER))
     (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE) NULL-INTEGER))))

;;; (DEFUN (ESTIMATE-CARDINALITY-OF-EXTENSION COST-ESTIMATE) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT)
  ESTIMATE-CARDINALITY-OF-EXTENSION))
(CL:DEFUN ESTIMATE-CARDINALITY-OF-EXTENSION (DESCRIPTION)
  (CL:WHEN
   (CL:OR (CL:EQ DESCRIPTION NULL)
    (CL:NOT (RELATION-SUPPORTS-EXTENSION? DESCRIPTION)))
   (CL:RETURN-FROM ESTIMATE-CARDINALITY-OF-EXTENSION NULL-FLOAT))
  (CL:LET* ((ESTIMATE (ACCESS-OBSERVED-CARDINALITY DESCRIPTION)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ESTIMATE))
   (CL:WHEN
    (CL:AND (NULL? ESTIMATE)
     (CL:NOT (CL:EQ (%NAMED-DESCRIPTION.EXTENSION DESCRIPTION) NULL)))
    (CL:SETQ ESTIMATE
     (ESTIMATED-LENGTH (%NAMED-DESCRIPTION.EXTENSION DESCRIPTION))))
   (CL:WHEN (NULL? ESTIMATE) (CL:SETQ ESTIMATE 0))
   (CL:FLOAT
    (MAX ESTIMATE
     (CL:IF (CLASS-DESCRIPTION? DESCRIPTION)
      (CL:TRUNCATE ESTIMATED-SIZE-OF-CLASS-EXTENSION)
      (CL:TRUNCATE
       (CL:* ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS
        ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS
        ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS))))
    0.0d0)))

;;; (DEFUN (ESTIMATE-MEMBER-OF-GOAL-FANOUT COST-ESTIMATE) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT)
  ESTIMATE-MEMBER-OF-GOAL-FANOUT))
(CL:DEFUN ESTIMATE-MEMBER-OF-GOAL-FANOUT (GOAL)
  (CL:LET*
   ((MEMBERVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
       0)))
    (COLLECTIONVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
       1))))
   (CL:COND
    ((CL:NOT (CL:EQ MEMBERVALUE NULL))
     ESTIMATED-CARDINALITY-OF-MEMBER-OF)
    ((CL:NOT (CL:EQ COLLECTIONVALUE NULL))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE COLLECTIONVALUE)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-OPTIMIZE-LOGIC-DESCRIPTION)
        (CL:PROGN
         (CL:IF
          (ISA? COLLECTIONVALUE SGT-OPTIMIZE-LOGIC-NAMED-DESCRIPTION)
          (ESTIMATE-CARDINALITY-OF-EXTENSION COLLECTIONVALUE)
          ESTIMATED-CARDINALITY-OF-DESCRIPTION)))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-OPTIMIZE-STELLA-COLLECTION)
        (CL:PROGN (CL:FLOAT (LENGTH COLLECTIONVALUE) 0.0d0)))
       (CL:T ESTIMATED-SLOT-VALUE-COLLECTION-SIZE))))
    (CL:T NULL-FLOAT))))

;;; (DEFUN (ESTIMATE-PREDICATE-GOAL-FANOUT COST-ESTIMATE) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT)
  ESTIMATE-PREDICATE-GOAL-FANOUT))
(CL:DEFUN ESTIMATE-PREDICATE-GOAL-FANOUT (GOAL)
  (CL:WHEN
   (CL:EQ (%PROPOSITION.OPERATOR GOAL)
    SGT-OPTIMIZE-PL-KERNEL-KB-MEMBER-OF)
   (CL:RETURN-FROM ESTIMATE-PREDICATE-GOAL-FANOUT
    (ESTIMATE-MEMBER-OF-GOAL-FANOUT GOAL)))
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION (%PROPOSITION.OPERATOR GOAL)))
    (GOALVECTOR
     (ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR
      (%PROPOSITION.ARGUMENTS GOAL))))
   (CL:WHEN (CL:EQ DESCRIPTION NULL)
    (CL:RETURN-FROM ESTIMATE-PREDICATE-GOAL-FANOUT NULL-FLOAT))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((GBIT NULL) (VECTOR-000 GOALVECTOR) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)) (IBIT NULL)
       (VECTOR-001 (GET-INDEXING-VECTOR DESCRIPTION)) (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:DECLARE
       (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
      (CL:LOOP WHILE
       (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
       DO
       (CL:SETQ GBIT
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ IBIT
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:WHEN
        (CL:AND (CL:EQ IBIT TRUE-WRAPPER) (CL:EQ GBIT TRUE-WRAPPER))
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
     (CL:SETQ TEST-VALUE-000 FOUND?-000))
    (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
    (CL:WHEN TEST-VALUE-000
     (CL:RETURN-FROM ESTIMATE-PREDICATE-GOAL-FANOUT
      (ESTIMATE-CARDINALITY-OF-EXTENSION
       (GET-DESCRIPTION (%PROPOSITION.OPERATOR GOAL))))))
   (CL:LET* ((ALLBITSMATCH? CL:NIL))
    (CL:LET*
     ((UNIQUENESSKEY NULL)
      (ITER-000
       (%LIST.THE-CONS-LIST (GET-UNIQUENESS-VECTORS DESCRIPTION))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ UNIQUENESSKEY (%%VALUE ITER-000))
      (CL:SETQ ALLBITSMATCH? CL:T)
      (CL:LET*
       ((UBIT NULL) (VECTOR-002 UNIQUENESSKEY) (INDEX-002 0)
        (LENGTH-002 (LENGTH VECTOR-002)) (GBIT NULL)
        (VECTOR-003 GOALVECTOR) (INDEX-003 0)
        (LENGTH-003 (LENGTH VECTOR-003)))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002 INDEX-003 LENGTH-003))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-002 LENGTH-002)
         (CL:< INDEX-003 LENGTH-003))
        DO
        (CL:SETQ UBIT
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
          INDEX-002))
        (CL:SETQ GBIT
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-003))
          INDEX-003))
        (CL:WHEN
         (CL:AND (CL:EQ UBIT TRUE-WRAPPER) (CL:EQ GBIT FALSE-WRAPPER))
         (CL:SETQ ALLBITSMATCH? CL:NIL) (CL:RETURN))
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002))
        (CL:SETQ INDEX-003 (CL:1+ INDEX-003))))
      (CL:WHEN ALLBITSMATCH?
       (CL:RETURN-FROM ESTIMATE-PREDICATE-GOAL-FANOUT 1.0d0))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS)))

;;; (DEFCONSTANT INFERABLE-PENALTY-COST ...)

(CL:DEFVAR INFERABLE-PENALTY-COST 7.0d0
  "Amount of penalty for using inferable relations as goals.")
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT INFERABLE-PENALTY-COST))

;;; (DEFCONSTANT SUBSET-OF-PENALTY-COST ...)

(CL:DEFVAR SUBSET-OF-PENALTY-COST 20.0d0
  "Amount of penalty for using 'subset-of' as a goal.")
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT SUBSET-OF-PENALTY-COST))

;;; (DEFUN (ESTIMATE-GOAL-COST COST-ESTIMATE) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT) ESTIMATE-GOAL-COST))
(CL:DEFUN ESTIMATE-GOAL-COST (GOAL)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND GOAL)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-ISA)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-PREDICATE))
     (CL:LET*
      ((DESCRIPTION (GET-DESCRIPTION (%PROPOSITION.OPERATOR GOAL))))
      (CL:IF
       (CL:OR (CL:EQ DESCRIPTION NULL)
        (CL:NOT (INFERABLE? DESCRIPTION)))
       1.0d0 INFERABLE-PENALTY-COST)))
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-IMPLIES)
     SUBSET-OF-PENALTY-COST)
    (CL:T 1.0d0))))

;;; (DEFUN (ESTIMATE-GOAL-FANOUT COST-ESTIMATE) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT) ESTIMATE-GOAL-FANOUT))
(CL:DEFUN ESTIMATE-GOAL-FANOUT (GOAL)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND GOAL)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-ISA)
     (ESTIMATE-CARDINALITY-OF-EXTENSION
      (GET-DESCRIPTION (%PROPOSITION.OPERATOR GOAL))))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-PREDICATE))
     (ESTIMATE-PREDICATE-GOAL-FANOUT GOAL))
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-IMPLIES)
     ESTIMATED-CARDINALITY-OF-SUBSET-OF)
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-EQUIVALENT)
     (CL:IF
      (CL:OR
       (ARGUMENT-BOUND?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
         0))
       (ARGUMENT-BOUND?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
         1)))
      1.0d0 NULL-FLOAT))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-NOT)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FAIL))
     NULL-FLOAT)
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (CHEAPEST-GENERATOR-GOAL PROPOSITION COST-ESTIMATE COST-ESTIMATE) ...)

(CL:DEFUN CHEAPEST-GENERATOR-GOAL (VARIABLE)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-OPTIMIZE-OPTIMIZER))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
    "CHEAPEST: " VARIABLE " GENERATORS: "
    (%GOAL-RECORD.GENERATOR-GOALS (GOAL-RECORD VARIABLE)) EOL))
  (CL:LET*
   ((BESTGOAL NULL) (BESTCOST NULL-FLOAT) (BESTFANOUT NULL-FLOAT)
    (GENERATORCOST NULL-FLOAT) (GENERATORFANOUT NULL-FLOAT))
   (CL:DECLARE
    (CL:TYPE CL:DOUBLE-FLOAT BESTCOST BESTFANOUT GENERATORCOST
     GENERATORFANOUT))
   (CL:LET*
    ((GOAL NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST
       (%GOAL-RECORD.GENERATOR-GOALS (GOAL-RECORD VARIABLE)))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ GOAL (%%VALUE ITER-000))
     (CL:SETQ GENERATORCOST (ESTIMATE-GOAL-COST GOAL))
     (CL:SETQ GENERATORFANOUT (ESTIMATE-GOAL-FANOUT GOAL))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:= GENERATORFANOUT NULL-FLOAT))
       (CL:OR (CL:= BESTFANOUT NULL-FLOAT)
        (CL:< GENERATORFANOUT BESTFANOUT)
        (CL:AND (CL:= GENERATORFANOUT BESTFANOUT)
         (CL:< GENERATORCOST BESTCOST))))
      (CL:WHEN
       (CL:AND (CL:= GENERATORFANOUT 1.0d0) (CL:= GENERATORCOST 1.0d0))
       (CL:RETURN-FROM CHEAPEST-GENERATOR-GOAL
        (CL:VALUES GOAL 1.0d0 1.0d0)))
      (CL:SETQ BESTGOAL GOAL) (CL:SETQ BESTFANOUT GENERATORFANOUT)
      (CL:SETQ BESTCOST GENERATORCOST))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:IF (CL:NOT (CL:= BESTFANOUT NULL-FLOAT))
    (CL:PROGN
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
       (MEMB? *TRACED-KEYWORDS* KWD-OPTIMIZE-OPTIMIZER))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "  SELECTED: " BESTGOAL "  " BESTCOST "  " BESTFANOUT EOL))
     (CL:VALUES BESTGOAL BESTCOST BESTFANOUT))
    (CL:VALUES NULL 0.0d0 0.0d0))))

;;; (DEFUN PROPAGATE-SINGLE-VALUED-CONSTRAINTS ...)

(CL:DEFUN PROPAGATE-SINGLE-VALUED-CONSTRAINTS (GOAL GOALSEQUENCE)
  (CL:LET* ((ARGUMENTS (%PROPOSITION.ARGUMENTS GOAL)))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND GOAL)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FUNCTION)
       (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-PREDICATE))
      (CL:WHEN
       (SINGLE-VALUED-TERM?
        (GET-DESCRIPTION (%PROPOSITION.OPERATOR GOAL)))
       (CL:LET* ((TEST-VALUE-001 CL:NIL))
        (CL:LET* ((ALWAYS?-000 CL:T))
         (CL:LET* ((ARG NULL) (ITER-000 (BUT-LAST ARGUMENTS)))
          (CL:LOOP WHILE (NEXT? ITER-000) DO
           (CL:SETQ ARG (%ITERATOR.VALUE ITER-000))
           (CL:WHEN (CL:NOT (ARGUMENT-BOUND? ARG))
            (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))))
         (CL:SETQ TEST-VALUE-001 ALWAYS?-000))
        (CL:WHEN TEST-VALUE-001
         (CL:SETQ TEST-VALUE-001 (UNBOUND-VARIABLE? (LAST ARGUMENTS))))
        (CL:IF TEST-VALUE-001
         (CL:PROGN
          (CL:WHEN (CL:NOT (MEMBER? GOALSEQUENCE GOAL))
           (PUSH GOALSEQUENCE GOAL))
          (SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS
           (LAST ARGUMENTS) GOALSEQUENCE))
         (CL:PROGN)))))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-ISA)
       (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-IMPLIES)))
     ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-EQUIVALENT)
      (CL:COND
       ((UNBOUND-VARIABLE?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) 0))
        (PUSH GOALSEQUENCE GOAL)
        (SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) 0)
         GOALSEQUENCE))
       ((UNBOUND-VARIABLE?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) 1))
        (PUSH GOALSEQUENCE GOAL)
        (SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) 1)
         GOALSEQUENCE))))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-NOT)
       (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FAIL)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN COLLECT-CLOSED-GOALS ...)

(CL:DEFUN COLLECT-CLOSED-GOALS (GOALS GOALSEQUENCE)
  (CL:LET* ((G NULL) (ITER-000 (%LIST.THE-CONS-LIST GOALS)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ G (%%VALUE ITER-000))
    (CL:WHEN
     (CL:AND (ALL-ARGUMENTS-BOUND? G)
      (CL:NOT (MEMBER? GOALSEQUENCE G)))
     (PUSH GOALSEQUENCE G))
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS ...)

(CL:DEFUN SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS (VARIABLE GOALSEQUENCE)
  (CL:LET* ((GOALRECORD (GOAL-RECORD VARIABLE)))
   (SIMULATE-BIND-VARIABLE-TO-VALUE VARIABLE)
   (COLLECT-CLOSED-GOALS (%GOAL-RECORD.GENERATOR-GOALS GOALRECORD)
    GOALSEQUENCE)
   (COLLECT-CLOSED-GOALS (%GOAL-RECORD.OTHER-GOALS GOALRECORD)
    GOALSEQUENCE)
   (CL:LET*
    ((G NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (%GOAL-RECORD.GENERATOR-GOALS GOALRECORD))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ G (%%VALUE ITER-000))
     (PROPAGATE-SINGLE-VALUED-CONSTRAINTS G GOALSEQUENCE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((G NULL)
     (ITER-001
      (%LIST.THE-CONS-LIST (%GOAL-RECORD.OTHER-GOALS GOALRECORD))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ G (%%VALUE ITER-001))
     (PROPAGATE-SINGLE-VALUED-CONSTRAINTS G GOALSEQUENCE)
     (CL:SETQ ITER-001 (%%REST ITER-001))))))

;;; (DEFUN BIND-ALL-VARIABLES-IN-GENERATOR-GOAL ...)

(CL:DEFUN BIND-ALL-VARIABLES-IN-GENERATOR-GOAL (GOAL GOALSEQUENCE)
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS GOAL)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ ARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
      INDEX-000))
    (CL:WHEN
     (CL:AND (ISA? ARG SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)
      (UNBOUND-VARIABLE? ARG))
     (SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS ARG
      GOALSEQUENCE))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))

;;; (DEFSPECIAL *OPTIMALGOALORDERINGRECURSIONS* ...)

(CL:DEFVAR *OPTIMALGOALORDERINGRECURSIONS* NULL-INTEGER)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *OPTIMALGOALORDERINGRECURSIONS*))

;;; (DEFGLOBAL *OPTIMAL-GOAL-ORDERING-CUTOFF* ...)

(CL:DEFVAR *OPTIMAL-GOAL-ORDERING-CUTOFF* 100)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *OPTIMAL-GOAL-ORDERING-CUTOFF*))

;;; (DEFUN COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING ...)

(CL:DEFUN COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING (OPTIMIZERVARIABLES NUMBEROFOPENGOALS GOALSEQUENCE PRIORCOST PRIORFANOUT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NUMBEROFOPENGOALS)
   (CL:TYPE CL:DOUBLE-FLOAT PRIORCOST PRIORFANOUT))
  #+MCL
  (CL:CHECK-TYPE NUMBEROFOPENGOALS CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE PRIORCOST CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE PRIORFANOUT CL:DOUBLE-FLOAT)
  (CL:LET*
   ((GOALSEQUENCECHECKPOINT NULL)
    (CHOICEPOINTUNBINDINGOFFSET NULL-INTEGER)
    (CUMULATIVECOST NULL-FLOAT) (CUMULATIVEFANOUT NULL-FLOAT))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CHOICEPOINTUNBINDINGOFFSET)
    (CL:TYPE CL:DOUBLE-FLOAT CUMULATIVECOST CUMULATIVEFANOUT))
   (CL:IF
    (CL:>= *OPTIMALGOALORDERINGRECURSIONS*
     *OPTIMAL-GOAL-ORDERING-CUTOFF*)
    (CL:RETURN-FROM COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING)
    (CL:SETQ *OPTIMALGOALORDERINGRECURSIONS*
     (CL:1+ *OPTIMALGOALORDERINGRECURSIONS*)))
   (CL:WHEN (EMPTY? OPTIMIZERVARIABLES)
    (SET-DYNAMIC-SLOT-VALUE
     (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
     SYM-OPTIMIZE-LOGIC-BEST-GOAL-SEQUENCE GOALSEQUENCE NULL)
    (CL:RETURN-FROM COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING))
   (CL:LET*
    ((VBL NULL) (ITER-000 (%LIST.THE-CONS-LIST OPTIMIZERVARIABLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ VBL (%%VALUE ITER-000))
     (CL:TAGBODY
      (CL:WHEN (CL:NOT (VARIABLE-BOUND? VBL))
       (CL:LET*
        ((GENERATORGOAL NULL) (GENERATORCOST NULL-FLOAT)
         (GENERATORFANOUT NULL-FLOAT))
        (CL:DECLARE
         (CL:TYPE CL:DOUBLE-FLOAT GENERATORCOST GENERATORFANOUT))
        (CL:MULTIPLE-VALUE-SETQ
         (GENERATORGOAL GENERATORCOST GENERATORFANOUT)
         (CHEAPEST-GENERATOR-GOAL VBL))
        (CL:WHEN (CL:EQ GENERATORGOAL NULL) (CL:GO :CONTINUE))
        (CL:SETQ CUMULATIVEFANOUT (CL:* PRIORFANOUT GENERATORFANOUT))
        (CL:SETQ CUMULATIVECOST
         (CL:+ PRIORCOST (CL:* CUMULATIVEFANOUT GENERATORCOST)))
        (CL:WHEN
         (CL:OR (CL:= CUMULATIVECOST NULL-FLOAT)
          (CL:< CUMULATIVECOST PRIORCOST))
         (CL:GO :CONTINUE))
        (CL:WHEN
         (CL:AND
          (CL:NOT
           (CL:=
            (%FLOAT-WRAPPER.WRAPPER-VALUE
             (DYNAMIC-SLOT-VALUE
              (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
              SYM-OPTIMIZE-LOGIC-BEST-COST NULL-FLOAT-WRAPPER))
            NULL-FLOAT))
          (CL:>= CUMULATIVECOST
           (%FLOAT-WRAPPER.WRAPPER-VALUE
            (DYNAMIC-SLOT-VALUE
             (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
             SYM-OPTIMIZE-LOGIC-BEST-COST NULL-FLOAT-WRAPPER))))
         (CL:GO :CONTINUE))
        (CL:SETQ GOALSEQUENCECHECKPOINT
         (%LIST.THE-CONS-LIST GOALSEQUENCE))
        (CL:SETQ CHOICEPOINTUNBINDINGOFFSET
         (SIMULATE-CREATE-CHOICE-POINT))
        (PUSH GOALSEQUENCE GENERATORGOAL)
        (BIND-ALL-VARIABLES-IN-GENERATOR-GOAL GENERATORGOAL
         GOALSEQUENCE))
       (CL:IF (CL:= (LENGTH GOALSEQUENCE) NUMBEROFOPENGOALS)
        (CL:WHEN
         (CL:OR
          (CL:=
           (%FLOAT-WRAPPER.WRAPPER-VALUE
            (DYNAMIC-SLOT-VALUE
             (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
             SYM-OPTIMIZE-LOGIC-BEST-COST NULL-FLOAT-WRAPPER))
           NULL-FLOAT)
          (CL:< CUMULATIVECOST
           (%FLOAT-WRAPPER.WRAPPER-VALUE
            (DYNAMIC-SLOT-VALUE
             (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
             SYM-OPTIMIZE-LOGIC-BEST-COST NULL-FLOAT-WRAPPER))))
         (SET-DYNAMIC-SLOT-VALUE
          (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
          SYM-OPTIMIZE-LOGIC-BEST-COST (WRAP-FLOAT CUMULATIVECOST)
          NULL-FLOAT-WRAPPER)
         (SET-DYNAMIC-SLOT-VALUE
          (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
          SYM-OPTIMIZE-LOGIC-BEST-GOAL-SEQUENCE (COPY GOALSEQUENCE)
          NULL))
        (COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING OPTIMIZERVARIABLES
         NUMBEROFOPENGOALS GOALSEQUENCE CUMULATIVECOST
         CUMULATIVEFANOUT))
       (CL:SETF (%LIST.THE-CONS-LIST GOALSEQUENCE)
        GOALSEQUENCECHECKPOINT)
       (UNBIND-VARIABLES-BEGINNING-AT
        (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*)
        CHOICEPOINTUNBINDINGOFFSET))
      :CONTINUE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

;;; (DEFUN COMPUTE-GREEDY-OPEN-GOAL-ORDERING ...)

(CL:DEFUN COMPUTE-GREEDY-OPEN-GOAL-ORDERING (OPTIMIZERVARIABLES NUMBEROFOPENGOALS GOALSEQUENCE PRIORCOST PRIORFANOUT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NUMBEROFOPENGOALS)
   (CL:TYPE CL:DOUBLE-FLOAT PRIORCOST PRIORFANOUT))
  #+MCL
  (CL:CHECK-TYPE NUMBEROFOPENGOALS CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE PRIORCOST CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE PRIORFANOUT CL:DOUBLE-FLOAT)
  (CL:LET*
   ((GOALSEQUENCECHECKPOINT NULL)
    (CHOICEPOINTUNBINDINGOFFSET NULL-INTEGER) (BESTGENERATORGOAL NULL)
    (BESTGENERATORFANOUT NULL-FLOAT) (BESTCOMBINEDCOST NULL-FLOAT)
    (OPENGOALREDUCTION NULL-INTEGER))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM CHOICEPOINTUNBINDINGOFFSET OPENGOALREDUCTION)
    (CL:TYPE CL:DOUBLE-FLOAT BESTGENERATORFANOUT BESTCOMBINEDCOST))
   (CL:WHEN (EMPTY? OPTIMIZERVARIABLES)
    (SET-DYNAMIC-SLOT-VALUE
     (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
     SYM-OPTIMIZE-LOGIC-BEST-GOAL-SEQUENCE GOALSEQUENCE NULL)
    (CL:RETURN-FROM COMPUTE-GREEDY-OPEN-GOAL-ORDERING))
   (CL:LOOP (CL:SETQ BESTGENERATORGOAL NULL)
    (CL:SETQ BESTGENERATORFANOUT NULL-FLOAT)
    (CL:SETQ BESTCOMBINEDCOST NULL-FLOAT)
    (CL:LET*
     ((VBL NULL) (ITER-000 (%LIST.THE-CONS-LIST OPTIMIZERVARIABLES)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ VBL (%%VALUE ITER-000))
      (CL:TAGBODY
       (CL:WHEN (CL:NOT (VARIABLE-BOUND? VBL))
        (CL:LET*
         ((GENERATORGOAL NULL) (GENERATORCOST NULL-FLOAT)
          (GENERATORFANOUT NULL-FLOAT))
         (CL:DECLARE
          (CL:TYPE CL:DOUBLE-FLOAT GENERATORCOST GENERATORFANOUT))
         (CL:MULTIPLE-VALUE-SETQ
          (GENERATORGOAL GENERATORCOST GENERATORFANOUT)
          (CHEAPEST-GENERATOR-GOAL VBL))
         (CL:WHEN (CL:EQ GENERATORGOAL NULL) (CL:GO :CONTINUE))
         (CL:SETQ GOALSEQUENCECHECKPOINT
          (%LIST.THE-CONS-LIST GOALSEQUENCE))
         (CL:SETQ CHOICEPOINTUNBINDINGOFFSET
          (SIMULATE-CREATE-CHOICE-POINT))
         (PUSH GOALSEQUENCE GENERATORGOAL)
         (BIND-ALL-VARIABLES-IN-GENERATOR-GOAL GENERATORGOAL
          GOALSEQUENCE)
         (CL:SETQ OPENGOALREDUCTION
          (CEILING
           (CL:*
            (CL:/
             (CL:FLOAT
              (CL:- (LENGTH GOALSEQUENCE)
               (LENGTH GOALSEQUENCECHECKPOINT))
              0.0d0)
             NUMBEROFOPENGOALS)
            100)))
         (CL:LET*
          ((COMBINEDCOST
            (CL:- (CL:+ GENERATORFANOUT GENERATORCOST)
             OPENGOALREDUCTION)))
          (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT COMBINEDCOST))
          (CL:WHEN
           (CL:OR (CL:= BESTCOMBINEDCOST NULL-FLOAT)
            (CL:< COMBINEDCOST BESTCOMBINEDCOST))
           (CL:SETQ BESTGENERATORGOAL GENERATORGOAL)
           (CL:SETQ BESTGENERATORFANOUT GENERATORFANOUT)
           (CL:SETQ BESTCOMBINEDCOST COMBINEDCOST)))
         (CL:SETF (%LIST.THE-CONS-LIST GOALSEQUENCE)
          GOALSEQUENCECHECKPOINT)
         (UNBIND-VARIABLES-BEGINNING-AT
          (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*)
          CHOICEPOINTUNBINDINGOFFSET)))
       :CONTINUE)
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:WHEN (CL:EQ BESTGENERATORGOAL NULL)
     (CL:WHEN (CL:= (LENGTH GOALSEQUENCE) NUMBEROFOPENGOALS)
      (SET-DYNAMIC-SLOT-VALUE
       (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
       SYM-OPTIMIZE-LOGIC-BEST-COST (WRAP-FLOAT PRIORCOST)
       NULL-FLOAT-WRAPPER)
      (SET-DYNAMIC-SLOT-VALUE
       (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
       SYM-OPTIMIZE-LOGIC-BEST-GOAL-SEQUENCE GOALSEQUENCE NULL))
     (CL:RETURN-FROM COMPUTE-GREEDY-OPEN-GOAL-ORDERING))
    (CL:SETQ PRIORFANOUT (CL:* PRIORFANOUT BESTGENERATORFANOUT))
    (PUSH GOALSEQUENCE BESTGENERATORGOAL)
    (BIND-ALL-VARIABLES-IN-GENERATOR-GOAL BESTGENERATORGOAL
     GOALSEQUENCE))))

;;; (DEFUN COMPUTE-BACKUP-OPEN-GOAL-ORDERING ...)

(CL:DEFUN COMPUTE-BACKUP-OPEN-GOAL-ORDERING (GOALSEQUENCE)
  (CL:LET* ((G NULL) (ITER-000 (%LIST.THE-CONS-LIST GOALSEQUENCE)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ G (%%VALUE ITER-000))
    (CL:IF
     (CL:AND (CL:= (ESTIMATE-GOAL-COST G) NULL-FLOAT)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? G)))
     (INSERT-LAST (RESIDUE-GOALS *QUERYITERATOR*) G)
     (PUSH (BEST-GOAL-SEQUENCE *QUERYITERATOR*) G))
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN COLLECT-UNBOUND-GOAL-VARIABLES ...)

(CL:DEFUN COLLECT-UNBOUND-GOAL-VARIABLES (GOAL UNBOUNDVARIABLES)
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS GOAL)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ ARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
      INDEX-000))
    (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE ARG)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-001 SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)
       (CL:PROGN
        (CL:WHEN (UNBOUND-VARIABLE? ARG)
         (INSERT-NEW UNBOUNDVARIABLES ARG))))
      ((SUBTYPE-OF? TEST-VALUE-001 SGT-OPTIMIZE-LOGIC-PROPOSITION)
       (CL:PROGN (COLLECT-UNBOUND-GOAL-VARIABLES ARG UNBOUNDVARIABLES)
        (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND ARG)))
         (CL:COND
          ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FORALL)
            (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-EXISTS))
           (CL:LET*
            ((VAR NULL)
             (VECTOR-001
              (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS ARG)
               SYM-OPTIMIZE-LOGIC-IO-VARIABLES NULL))
             (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
            (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
            (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
             (CL:SETQ VAR
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
               INDEX-001))
             (REMOVE UNBOUNDVARIABLES VAR)
             (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
          (CL:T)))))
      (CL:T)))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))

;;; (DEFUN EXTRACT-OPEN-GOAL-CLUSTERS ...)

(CL:DEFUN EXTRACT-OPEN-GOAL-CLUSTERS (OPENGOALS OPENGOALCLUSTERS)
  (CL:LET*
   ((ALLGOALS (COPY-CONS-LIST (%LIST.THE-CONS-LIST OPENGOALS)))
    (REMAININGGOALS ALLGOALS) (CURSOR NULL) (GOAL NULL)
    (CLUSTERS (NEW-LIST)) (CURRENTCLUSTER NULL)
    (CURRENTCLUSTERVARS (NEW-LIST)) (CURRENTCLUSTERVARSGREW? CL:NIL)
    (UNBOUNDGOALVARS (NEW-LIST)))
   (CL:LOOP (CLEAR CURRENTCLUSTERVARS)
    (CL:LOOP (CL:WHEN (CL:EQ REMAININGGOALS NIL) (CL:RETURN))
     (CL:WHEN (CL:NOT (CL:EQ (%%VALUE REMAININGGOALS) NULL))
      (COLLECT-UNBOUND-GOAL-VARIABLES (%%VALUE REMAININGGOALS)
       CURRENTCLUSTERVARS))
     (CL:IF (NON-EMPTY? CURRENTCLUSTERVARS) (CL:RETURN)
      (CL:SETQ REMAININGGOALS (%%REST REMAININGGOALS))))
    (CL:WHEN (EMPTY? CURRENTCLUSTERVARS) (CL:RETURN))
    (CL:SETQ CURRENTCLUSTER (NEW-LIST))
    (INSERT CURRENTCLUSTER (%%VALUE REMAININGGOALS))
    (FIRST-SETTER REMAININGGOALS NULL)
    (CL:SETQ REMAININGGOALS (%%REST REMAININGGOALS))
    (CL:LOOP (CL:SETQ CURRENTCLUSTERVARSGREW? CL:NIL)
     (CL:SETQ CURSOR REMAININGGOALS)
     (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
      (CL:SETQ GOAL (%%VALUE CURSOR))
      (CL:WHEN (CL:NOT (CL:EQ GOAL NULL)) (CLEAR UNBOUNDGOALVARS)
       (COLLECT-UNBOUND-GOAL-VARIABLES GOAL UNBOUNDGOALVARS)
       (CL:LET* ((FOUND?-000 CL:NIL))
        (CL:LET*
         ((VAR NULL) (ITER-000 (%LIST.THE-CONS-LIST UNBOUNDGOALVARS)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ VAR (%%VALUE ITER-000))
          (CL:WHEN (MEMBER? CURRENTCLUSTERVARS VAR)
           (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
          (CL:SETQ ITER-000 (%%REST ITER-000))))
        (CL:WHEN FOUND?-000 (PUSH CURRENTCLUSTER GOAL)
         (FIRST-SETTER CURSOR NULL)
         (CL:LET*
          ((VAR NULL) (ITER-001 (%LIST.THE-CONS-LIST UNBOUNDGOALVARS)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:SETQ VAR (%%VALUE ITER-001))
           (CL:WHEN (CL:NOT (MEMBER? CURRENTCLUSTERVARS VAR))
            (INSERT CURRENTCLUSTERVARS VAR)
            (CL:SETQ CURRENTCLUSTERVARSGREW? CL:T))
           (CL:SETQ ITER-001 (%%REST ITER-001)))))))
      (CL:SETQ CURSOR (%%REST CURSOR)))
     (CL:WHEN (CL:NOT CURRENTCLUSTERVARSGREW?) (CL:RETURN)))
    (PUSH CLUSTERS (REVERSE CURRENTCLUSTER)))
   (FREE CURRENTCLUSTERVARS)
   (CL:COND
    ((CL:>= (LENGTH CLUSTERS) 2) (CLEAR OPENGOALS)
     (CL:SETF (%LIST.THE-CONS-LIST OPENGOALS) (REMOVE ALLGOALS NULL))
     (CL:LET*
      ((CLUSTER NULL)
       (ITER-002 (%LIST.THE-CONS-LIST (REVERSE CLUSTERS)))
       (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ CLUSTER (%%VALUE ITER-002))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS CLUSTER NIL))
         (CL:IF (CL:EQ (%LIST.THE-CONS-LIST OPENGOALCLUSTERS) NIL)
          (CL:SETF (%LIST.THE-CONS-LIST OPENGOALCLUSTERS) COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST
           (%LIST.THE-CONS-LIST OPENGOALCLUSTERS) COLLECT-000)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS CLUSTER NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ ITER-002 (%%REST ITER-002)))))
    (CL:T
     (CL:WHEN (CL:NOT (CL:EQ CURRENTCLUSTER NULL))
      (FREE CURRENTCLUSTER))))
   (FREE CLUSTERS)))

;;; (DEFUN COLLECT-OPTIMIZER-VARIABLES ...)

(CL:DEFUN COLLECT-OPTIMIZER-VARIABLES (PROPOSITION COLLECTION)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-ISA)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-EQUIVALENT)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-IMPLIES))
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:WHEN (UNBOUND-VARIABLE? ARG)
        (CL:LET* ((VARIABLE ARG))
         (CL:COND
          ((CL:NOT (CL:EQ VARIABLE (INNERMOST-OF VARIABLE)))
           (SIMULATE-BIND-VARIABLE-TO-VALUE VARIABLE))
          ((CL:AND
            (CL:EQ (%PATTERN-VARIABLE.DEFINING-PROPOSITION VARIABLE)
             NULL)
            (CL:NOT (ANONYMOUS-VARIABLE? VARIABLE)))
           (INSERT-NEW COLLECTION VARIABLE)))))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
    (CL:T))))

;;; (DEFUN (BIGGER-CONJUNCTION? BOOLEAN) ...)

(CL:DEFUN BIGGER-CONJUNCTION? (PROP1 PROP2)
  (> (LENGTH (%PROPOSITION.ARGUMENTS PROP1))
   (LENGTH (%PROPOSITION.ARGUMENTS PROP2))))

;;; (DEFUN COMPUTE-OPEN-GOAL-ORDERING ...)

(CL:DEFUN COMPUTE-OPEN-GOAL-ORDERING (ANDPROPOSITION OPENGOALS GOALSEQUENCE)
  (CL:LET*
   ((OPENGOALCLUSTERS (NEW-LIST)) (CLUSTERPROPOSITIONS NIL-LIST)
    (OPTIMIZERVARIABLES (NEW-LIST)) (INITIALGOALSEQUENCE NULL)
    (INITIALRESIDUEGOALS NULL))
   (CL:WHEN
    (CL:EQ *QUERY-OPTIMIZATION-STRATEGY*
     KWD-OPTIMIZE-STATIC-WITH-CLUSTERING)
    (EXTRACT-OPEN-GOAL-CLUSTERS OPENGOALS OPENGOALCLUSTERS))
   (CL:WHEN (NON-EMPTY? OPENGOALCLUSTERS)
    (CL:SETQ CLUSTERPROPOSITIONS (NEW-LIST))
    (CL:LET* ((*EVALUATIONMODE* KWD-OPTIMIZE-DESCRIPTION))
     (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
     (CL:LET*
      ((CLUSTER NULL) (ITER-000 (%LIST.THE-CONS-LIST OPENGOALCLUSTERS))
       (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ CLUSTER (%%VALUE ITER-000))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-000
          (CONS
           (CL:IF (CL:> (LENGTH CLUSTER) 1)
            (FASTEN-DOWN-ONE-PROPOSITION
             (CONJOIN-PROPOSITIONS (%LIST.THE-CONS-LIST CLUSTER)) CL:T)
            (FIRST CLUSTER))
           NIL))
         (CL:IF (CL:EQ (%LIST.THE-CONS-LIST CLUSTERPROPOSITIONS) NIL)
          (CL:SETF (%LIST.THE-CONS-LIST CLUSTERPROPOSITIONS)
           COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST
           (%LIST.THE-CONS-LIST CLUSTERPROPOSITIONS) COLLECT-000)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-000)
          (CONS
           (CL:IF (CL:> (LENGTH CLUSTER) 1)
            (FASTEN-DOWN-ONE-PROPOSITION
             (CONJOIN-PROPOSITIONS (%LIST.THE-CONS-LIST CLUSTER)) CL:T)
            (FIRST CLUSTER))
           NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    (CL:LET*
     ((PROP NULL) (ITER-001 (%LIST.THE-CONS-LIST CLUSTERPROPOSITIONS))
      (COLLECT-001 NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ PROP (%%VALUE ITER-001))
      (CL:WHEN
       (CL:NOT (CL:EQ (%PROPOSITION.KIND PROP) KWD-OPTIMIZE-AND))
       (CL:IF (CL:EQ COLLECT-001 NULL)
        (CL:PROGN (CL:SETQ COLLECT-001 (CONS PROP NIL))
         (CL:IF (CL:EQ (%LIST.THE-CONS-LIST OPENGOALS) NIL)
          (CL:SETF (%LIST.THE-CONS-LIST OPENGOALS) COLLECT-001)
          (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST OPENGOALS)
           COLLECT-001)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS PROP NIL))
         (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))
      (CL:SETQ ITER-001 (%%REST ITER-001))))
    (CL:LET* ((IT (ALLOCATE-ITERATOR GOALSEQUENCE)))
     (CL:LOOP WHILE (NEXT? IT) DO
      (CL:WHEN (CL:NOT (MEMBER? OPENGOALS (%LIST-ITERATOR.VALUE IT)))
       (VALUE-SETTER IT NULL))))
    (REMOVE GOALSEQUENCE NULL))
   (FREE OPENGOALCLUSTERS)
   (CL:SETQ INITIALGOALSEQUENCE (%LIST.THE-CONS-LIST GOALSEQUENCE))
   (CL:SETQ INITIALRESIDUEGOALS
    (%LIST.THE-CONS-LIST (RESIDUE-GOALS *QUERYITERATOR*)))
   (CL:LET* ((GOAL NULL) (ITER-002 (%LIST.THE-CONS-LIST OPENGOALS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ GOAL (%%VALUE ITER-002))
     (COLLECT-OPTIMIZER-VARIABLES GOAL OPTIMIZERVARIABLES)
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (CL:LET* ((*OPTIMALGOALORDERINGRECURSIONS* 0))
    (CL:DECLARE (CL:SPECIAL *OPTIMALGOALORDERINGRECURSIONS*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *OPTIMALGOALORDERINGRECURSIONS*))
    (COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING OPTIMIZERVARIABLES
     (LENGTH OPENGOALS) GOALSEQUENCE 1.0d0 1.0d0)
    (CL:WHEN
     (CL:>= *OPTIMALGOALORDERINGRECURSIONS*
      *OPTIMAL-GOAL-ORDERING-CUTOFF*)
     (CL:SETF (%LIST.THE-CONS-LIST GOALSEQUENCE) INITIALGOALSEQUENCE)
     (CL:SETF (%LIST.THE-CONS-LIST (RESIDUE-GOALS *QUERYITERATOR*))
      INITIALRESIDUEGOALS)
     (CLEAR (BEST-GOAL-SEQUENCE *QUERYITERATOR*))
     (SET-DYNAMIC-SLOT-VALUE
      (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
      SYM-OPTIMIZE-LOGIC-BEST-COST (WRAP-FLOAT NULL-FLOAT)
      NULL-FLOAT-WRAPPER)
     (COMPUTE-GREEDY-OPEN-GOAL-ORDERING OPTIMIZERVARIABLES
      (LENGTH OPENGOALS) GOALSEQUENCE 1.0d0 1.0d0)))
   (CL:WHEN
    (CL:AND (EMPTY? (BEST-GOAL-SEQUENCE *QUERYITERATOR*))
     (CL:NOT (EMPTY? OPENGOALS)))
    (COMPUTE-BACKUP-OPEN-GOAL-ORDERING (REVERSE OPENGOALS))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
      (MEMB? *TRACED-KEYWORDS* KWD-OPTIMIZE-OPTIMIZER))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Using backup goal ordering:" EOL "Original Goal: "
      ANDPROPOSITION EOL)))
   (CL:LET*
    ((PROP NULL)
     (ITER-003
      (%LIST.THE-CONS-LIST
       (SORT CLUSTERPROPOSITIONS (CL:FUNCTION BIGGER-CONJUNCTION?)))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
     (CL:SETQ PROP (%%VALUE ITER-003))
     (CL:WHEN (CL:EQ (%PROPOSITION.KIND PROP) KWD-OPTIMIZE-AND)
      (PUSH (BEST-GOAL-SEQUENCE *QUERYITERATOR*) PROP))
     (CL:SETQ ITER-003 (%%REST ITER-003))))))

;;; (DEFUN OPTIMIZE-ORDERING-OF-CONJUNCTS ...)

(CL:DEFUN OPTIMIZE-ORDERING-OF-CONJUNCTS (ANDPROPOSITION)
  (CL:LET*
   ((INITIALLYCLOSEDGOALS (NEW-LIST)) (OPENGOALS (NEW-LIST))
    (GOALSEQUENCE (NEW-LIST)))
   (CL:LET*
    ((G NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS ANDPROPOSITION))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ G
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:COND
      ((ALL-ARGUMENTS-BOUND? G) (INSERT INITIALLYCLOSEDGOALS G))
      ((CL:OR (HAS-DISJUNCTION? G)
        (CL:EQ (%PROPOSITION.KIND G) KWD-OPTIMIZE-FORALL))
       (INSERT (RESIDUE-GOALS *QUERYITERATOR*) G))
      (CL:T (INSERT OPENGOALS G)))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET* ((GOAL NULL) (ITER-000 (%LIST.THE-CONS-LIST OPENGOALS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ GOAL (%%VALUE ITER-000)) (DISTRIBUTE-OPEN-GOAL GOAL)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((G NULL) (ITER-001 (%LIST.THE-CONS-LIST OPENGOALS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ G (%%VALUE ITER-001))
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET*
       ((ARG NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS G))
        (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:WHEN (ARGUMENT-BOUND? ARG) (CL:SETQ FOUND?-000 CL:T)
         (CL:RETURN))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      (CL:WHEN FOUND?-000
       (PROPAGATE-SINGLE-VALUED-CONSTRAINTS G GOALSEQUENCE)))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (COMPUTE-OPEN-GOAL-ORDERING ANDPROPOSITION OPENGOALS GOALSEQUENCE)
   (REORDER-GOALS ANDPROPOSITION (REVERSE INITIALLYCLOSEDGOALS)
    (REVERSE (BEST-GOAL-SEQUENCE *QUERYITERATOR*))
    (RESIDUE-GOALS *QUERYITERATOR*))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-OPTIMIZE-OPTIMIZER))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "Optimized goal: " ANDPROPOSITION EOL))))

;;; (DEFUN REORDER-GOALS ...)

(CL:DEFUN REORDER-GOALS (ANDPROPOSITION INITIALLYCLOSEDGOALS GOALSEQUENCE RESIDUEGOALS)
  (CL:LET*
   ((ARGUMENTS (%PROPOSITION.ARGUMENTS ANDPROPOSITION))
    (ORIGINALNUMBEROFARGUMENTS (LENGTH ARGUMENTS)) (INDEX 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ORIGINALNUMBEROFARGUMENTS INDEX))
   (CL:LET*
    ((G NULL) (ITER-000 (%LIST.THE-CONS-LIST INITIALLYCLOSEDGOALS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ G (%%VALUE ITER-000))
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY ARGUMENTS)) (VALUE G) (POSITION INDEX))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ INDEX (CL:1+ INDEX))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((G NULL) (ITER-001 (%LIST.THE-CONS-LIST GOALSEQUENCE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ G (%%VALUE ITER-001)) (REMOVE RESIDUEGOALS G)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY ARGUMENTS)) (VALUE G) (POSITION INDEX))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ INDEX (CL:1+ INDEX))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET* ((G NULL) (ITER-002 (%LIST.THE-CONS-LIST RESIDUEGOALS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ G (%%VALUE ITER-002))
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY ARGUMENTS)) (VALUE G) (POSITION INDEX))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ INDEX (CL:1+ INDEX))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (CL:WHEN (CL:< INDEX ORIGINALNUMBEROFARGUMENTS)
    (CL:SETF (%PROPOSITION.ARGUMENTS ANDPROPOSITION)
     (NEW-VECTOR INDEX))
    (CL:LET*
     ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-003 0)
      (UPPER-BOUND-000 (CL:1- INDEX)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-003
       UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000)
       (CL:<= ITER-003 UPPER-BOUND-000))
      DO
      (CL:SETQ ARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ I ITER-003)
      (CL:LET
       ((SELF
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS ANDPROPOSITION)))
        (VALUE ARG) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
      (CL:SETQ ITER-003 (CL:1+ ITER-003)))))))

;;; (DEFUN SIMULATE-BIND-VARIABLE-TO-VALUE ...)

(CL:DEFUN SIMULATE-BIND-VARIABLE-TO-VALUE (FORMULA)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE FORMULA)
     SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)
    (CL:PROGN
     (CL:WHEN (CL:NOT (ARGUMENT-BOUND? FORMULA))
      (SET-PATTERN-VARIABLE-BINDING FORMULA KWD-OPTIMIZE-BOUND))))
   (CL:T)))

;;; (DEFUN WARN-OF-UNBOUND-VARIABLE-ARGUMENT ...)

(CL:DEFUN WARN-OF-UNBOUND-VARIABLE-ARGUMENT (PROPOSITION)
  NULL)

;;; (DEFUN SIMULATE-GOAL-EVALUATION ...)

(CL:DEFUN SIMULATE-GOAL-EVALUATION (GOAL)
  (CL:LET* ((ARGUMENTS (%PROPOSITION.ARGUMENTS GOAL)) (OK? CL:NIL))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND GOAL)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FUNCTION)
      (CL:LET* ((CHOOSE-VALUE-000 CL:NIL))
       (CL:IF (COMPUTED-PREDICATE? GOAL)
        (CL:LET* ((ALWAYS?-000 CL:T))
         (CL:LET* ((ARG NULL) (ITER-000 (BUT-LAST ARGUMENTS)))
          (CL:LOOP WHILE (NEXT? ITER-000) DO
           (CL:SETQ ARG (%ITERATOR.VALUE ITER-000))
           (CL:WHEN (CL:NOT (ARGUMENT-BOUND? ARG))
            (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))))
         (CL:SETQ CHOOSE-VALUE-000 ALWAYS?-000))
        (CL:LET* ((FOUND?-000 CL:NIL))
         (CL:LET*
          ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
           (LENGTH-000 (LENGTH VECTOR-000)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
          (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
           (CL:SETQ ARG
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
             INDEX-000))
           (CL:WHEN
            (CL:AND (ARGUMENT-BOUND? ARG)
             (TYPE-HAS-BACKLINKS?
              (ENSURE-DEFERRED-DESCRIPTION (LOGICAL-TYPE ARG))))
            (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
         (CL:SETQ CHOOSE-VALUE-000 FOUND?-000)))
       (CL:SETQ OK? CHOOSE-VALUE-000)))
     ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-PREDICATE)
      (CL:IF
       (CL:EQ (%PROPOSITION.OPERATOR GOAL)
        SGT-OPTIMIZE-PL-KERNEL-KB-MEMBER-OF)
       (CL:SETQ OK?
        (ARGUMENT-BOUND?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) 1)))
       (CL:LET* ((CHOOSE-VALUE-001 CL:NIL))
        (CL:IF (COMPUTED-PREDICATE? GOAL)
         (CL:LET* ((ALWAYS?-001 CL:T))
          (CL:LET*
           ((ARG NULL) (VECTOR-001 ARGUMENTS) (INDEX-001 0)
            (LENGTH-001 (LENGTH VECTOR-001)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
           (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
            (CL:SETQ ARG
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
              INDEX-001))
            (CL:WHEN (CL:NOT (ARGUMENT-BOUND? ARG))
             (CL:SETQ ALWAYS?-001 CL:NIL) (CL:RETURN))
            (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
          (CL:SETQ CHOOSE-VALUE-001 ALWAYS?-001))
         (CL:LET* ((FOUND?-001 CL:NIL))
          (CL:LET*
           ((ARG NULL) (VECTOR-002 ARGUMENTS) (INDEX-002 0)
            (LENGTH-002 (LENGTH VECTOR-002)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
           (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
            (CL:SETQ ARG
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
              INDEX-002))
            (CL:WHEN
             (CL:AND (ARGUMENT-BOUND? ARG)
              (TYPE-HAS-BACKLINKS?
               (ENSURE-DEFERRED-DESCRIPTION (LOGICAL-TYPE ARG))))
             (CL:SETQ FOUND?-001 CL:T) (CL:RETURN))
            (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
          (CL:SETQ CHOOSE-VALUE-001 FOUND?-001)))
        (CL:SETQ OK? CHOOSE-VALUE-001))))
     ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-ISA) (CL:SETQ OK? CL:T))
     ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-EQUIVALENT)
      (CL:SETQ OK?
       (CL:OR
        (ARGUMENT-BOUND?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) 0))
        (ARGUMENT-BOUND?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
          1)))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:WHEN (CL:NOT OK?) (WARN-OF-UNBOUND-VARIABLE-ARGUMENT GOAL))
   (CL:LET*
    ((ARG NULL) (VECTOR-003 ARGUMENTS) (INDEX-003 0)
     (LENGTH-003 (LENGTH VECTOR-003)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-003 LENGTH-003))
    (CL:LOOP WHILE (CL:< INDEX-003 LENGTH-003) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-003))
       INDEX-003))
     (SIMULATE-BIND-VARIABLE-TO-VALUE ARG)
     (CL:SETQ INDEX-003 (CL:1+ INDEX-003))))))

;;; (DEFUN SIMULATE-AND-OPTIMIZE-ARGUMENT ...)

(CL:DEFUN SIMULATE-AND-OPTIMIZE-ARGUMENT (FORMULA)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE FORMULA)
     SGT-OPTIMIZE-LOGIC-PROPOSITION)
    (CL:PROGN (SIMULATE-AND-OPTIMIZE-QUERY FORMULA)))
   (CL:T)))

;;; (DEFUN SIMULATE-AND-OPTIMIZE-QUERY ...)

(CL:DEFUN SIMULATE-AND-OPTIMIZE-QUERY (PROPOSITION)
  (CL:LET*
   ((ARGUMENTS (%PROPOSITION.ARGUMENTS PROPOSITION))
    (KIND (%PROPOSITION.KIND PROPOSITION)))
   (CL:WHEN *REVERSEPOLARITY?*
    (CL:COND
     ((CL:EQ KIND KWD-OPTIMIZE-AND) (CL:SETQ KIND KWD-OPTIMIZE-OR))
     ((CL:EQ KIND KWD-OPTIMIZE-OR) (CL:SETQ KIND KWD-OPTIMIZE-AND))
     ((CL:EQ KIND KWD-OPTIMIZE-IMPLIES)
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "REVERSE POLARITY NOT YET IMPLEMENTED FOR :IMPLIES WITHIN QUERY OPTIMIZER")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
     (CL:T)))
   (CL:COND
    ((CL:OR (CL:EQ KIND KWD-OPTIMIZE-ISA)
      (CL:EQ KIND KWD-OPTIMIZE-PREDICATE)
      (CL:EQ KIND KWD-OPTIMIZE-FUNCTION)
      (CL:EQ KIND KWD-OPTIMIZE-EQUIVALENT))
     (SIMULATE-GOAL-EVALUATION PROPOSITION)
     (CL:LET*
      ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (SIMULATE-AND-OPTIMIZE-ARGUMENT ARG)
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
    ((CL:EQ KIND KWD-OPTIMIZE-AND)
     (CL:LET*
      ((CHOICEPOINTUNBINDINGOFFSET (SIMULATE-CREATE-CHOICE-POINT)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM CHOICEPOINTUNBINDINGOFFSET))
      (INITIALIZE-OPTIMIZER-MEMORY -1)
      (OPTIMIZE-ORDERING-OF-CONJUNCTS PROPOSITION)
      (UNBIND-VARIABLES-BEGINNING-AT
       (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*)
       CHOICEPOINTUNBINDINGOFFSET))
     (CL:LET*
      ((ARG NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS PROPOSITION))
       (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:SETQ ARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
         INDEX-001))
       (SIMULATE-AND-OPTIMIZE-QUERY ARG)
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
    ((CL:EQ KIND KWD-OPTIMIZE-OR)
     (CL:LET*
      ((ARG NULL) (VECTOR-002 ARGUMENTS) (INDEX-002 0)
       (LENGTH-002 (LENGTH VECTOR-002)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
      (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
       (CL:SETQ ARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
         INDEX-002))
       (CL:LET*
        ((CHOICEPOINTUNBINDINGOFFSET (SIMULATE-CREATE-CHOICE-POINT)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM CHOICEPOINTUNBINDINGOFFSET))
        (SIMULATE-AND-OPTIMIZE-QUERY ARG)
        (UNBIND-VARIABLES-BEGINNING-AT
         (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*)
         CHOICEPOINTUNBINDINGOFFSET))
       (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))))
    ((CL:EQ KIND KWD-OPTIMIZE-NOT)
     (CL:LET* ((OLDREVERSEPOLARITY? *REVERSEPOLARITY?*))
      (CL:LET* ((*REVERSEPOLARITY?* (CL:NOT OLDREVERSEPOLARITY?)))
       (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
       (CL:WHEN *REVERSEPOLARITY?*
        (WARN-OF-UNBOUND-VARIABLE-ARGUMENT PROPOSITION))
       (SIMULATE-AND-OPTIMIZE-QUERY
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) 0)))))
    ((CL:EQ KIND KWD-OPTIMIZE-IMPLIES)
     (WARN-OF-UNBOUND-VARIABLE-ARGUMENT PROPOSITION)
     (CL:LET*
      ((ARG NULL) (VECTOR-003 ARGUMENTS) (INDEX-003 0)
       (LENGTH-003 (LENGTH VECTOR-003)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-003 LENGTH-003))
      (CL:LOOP WHILE (CL:< INDEX-003 LENGTH-003) DO
       (CL:SETQ ARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-003))
         INDEX-003))
       (SIMULATE-AND-OPTIMIZE-ARGUMENT ARG)
       (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))))
    ((CL:EQ KIND KWD-OPTIMIZE-EXISTS)
     (SIMULATE-AND-OPTIMIZE-QUERY
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
       0)))
    ((CL:EQ KIND KWD-OPTIMIZE-FORALL)
     (CL:LET*
      ((CHOICEPOINTUNBINDINGOFFSET (SIMULATE-CREATE-CHOICE-POINT)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM CHOICEPOINTUNBINDINGOFFSET))
      (CL:LET*
       ((ARG NULL) (VECTOR-004 ARGUMENTS) (INDEX-004 0)
        (LENGTH-004 (LENGTH VECTOR-004)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-004 LENGTH-004))
       (CL:LOOP WHILE (CL:< INDEX-004 LENGTH-004) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-004))
          INDEX-004))
        (SIMULATE-AND-OPTIMIZE-ARGUMENT ARG)
        (CL:SETQ INDEX-004 (CL:1+ INDEX-004))))
      (UNBIND-VARIABLES-BEGINNING-AT
       (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*)
       CHOICEPOINTUNBINDINGOFFSET)))
    (CL:T))))

;;; (DEFUN INITIALIZE-OPTIMIZER-MEMORY ...)

(CL:DEFUN INITIALIZE-OPTIMIZER-MEMORY (STACKSIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM STACKSIZE))
  #+MCL
  (CL:CHECK-TYPE STACKSIZE CL:FIXNUM)
  (CL:WHEN
   (CL:AND (CL:<= STACKSIZE 0)
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE
       (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
       SYM-OPTIMIZE-LOGIC-OPTIMIZER-GOAL-RECORDS NULL)
      NULL)))
   (CL:SETQ STACKSIZE
    (LENGTH
     (DYNAMIC-SLOT-VALUE
      (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
      SYM-OPTIMIZE-LOGIC-OPTIMIZER-GOAL-RECORDS NULL))))
  (INITIALIZE-OPTIMIZER-GOAL-RECORDS STACKSIZE)
  (SET-DYNAMIC-SLOT-VALUE
   (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
   SYM-OPTIMIZE-LOGIC-RESIDUE-GOALS (LIST) NULL)
  (SET-DYNAMIC-SLOT-VALUE
   (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
   SYM-OPTIMIZE-LOGIC-BEST-GOAL-SEQUENCE (LIST) NULL)
  (SET-DYNAMIC-SLOT-VALUE
   (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
   SYM-OPTIMIZE-LOGIC-BEST-COST (WRAP-FLOAT NULL-FLOAT)
   NULL-FLOAT-WRAPPER))

;;; (DEFSPECIAL *QUERYOPTIMIZERCONTROLFRAME* ...)

(CL:DEFVAR *QUERYOPTIMIZERCONTROLFRAME*)

;;; (DEFUN OPTIMIZE-QUERY ...)

(CL:DEFUN OPTIMIZE-QUERY (DESCRIPTION BOOLEANVECTOR PARENTFRAME)
  (CL:LET*
   ((FRAME (CREATE-DOWN-FRAME PARENTFRAME NULL))
    (VARIABLESCOUNT
     (CL:+ (LENGTH (%DESCRIPTION.IO-VARIABLES DESCRIPTION))
      (LENGTH (%DESCRIPTION.INTERNAL-VARIABLES DESCRIPTION))
      (CL:IF
       (CL:NOT
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
          SYM-OPTIMIZE-LOGIC-EXTERNAL-VARIABLES NULL)
         NULL))
       (LENGTH
        (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
         SYM-OPTIMIZE-LOGIC-EXTERNAL-VARIABLES NULL))
       0))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM VARIABLESCOUNT))
   (INITIALIZE-OPTIMIZER-MEMORY VARIABLESCOUNT)
   (CREATE-PATTERN-RECORD FRAME NULL NULL)
   (ACTIVATE-PATTERN-RECORD (%CONTROL-FRAME.PATTERN-RECORD FRAME)
    VARIABLESCOUNT)
   (CL:LET*
    ((IOVAR NULL) (VECTOR-000 (%DESCRIPTION.IO-VARIABLES DESCRIPTION))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
     (INITIALLYBOUND? NULL) (VECTOR-001 BOOLEANVECTOR) (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
     DO
     (CL:SETQ IOVAR
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ INITIALLYBOUND?
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
       INDEX-001))
     (CL:WHEN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN INITIALLYBOUND?)
      (SIMULATE-BIND-VARIABLE-TO-VALUE IOVAR))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
   (CL:LET* ((*QUERYOPTIMIZERCONTROLFRAME* FRAME))
    (CL:DECLARE (CL:SPECIAL *QUERYOPTIMIZERCONTROLFRAME*))
    (SIMULATE-AND-OPTIMIZE-QUERY
     (%DESCRIPTION.PROPOSITION DESCRIPTION)))
   (CL:SETF (%CONTROL-FRAME.STATE FRAME) KWD-OPTIMIZE-PATTERN)
   (POP-DOWN-FRAME PARENTFRAME)))

;;; (DEFSPECIAL *BOUNDTOOFFSETCOUNTER* ...)

(CL:DEFVAR *BOUNDTOOFFSETCOUNTER* NULL-INTEGER
  "Enables 'select-optimal-query-pattern' to tell
'copy-variables-vector' that it should initialize the 'bound-to-offset'
slot of each variable in the copy operation.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *BOUNDTOOFFSETCOUNTER*))

;;; (DEFGLOBAL *QUERY-OPTIMIZATION-STRATEGY* ...)

(CL:DEFVAR *QUERY-OPTIMIZATION-STRATEGY* NULL
  "Keyword indicating what clause reordering strategy should
be used for conjunctive queries.  Legal values are :STATIC which performs
optimization once for each conjunctive pattern by simulating a query,
:STATIC-WITH-CLUSTERING which additionally tries to cluster conjunction into
independent clusters, :DYNAMIC which performs simple greedy optimization
dynamically during a query, :DYNAMIC-WITH-CLUSTERING which also looks
for clusters (not yet implemented), and :NONE to indicate no optimization
should be performed.")

;;; (DEFUN (USE-DYNAMIC-QUERY-OPTIMIZATION? BOOLEAN) ...)

(CL:DEFUN USE-DYNAMIC-QUERY-OPTIMIZATION? ()
  (CL:OR (CL:EQ *QUERY-OPTIMIZATION-STRATEGY* KWD-OPTIMIZE-DYNAMIC)
   (CL:EQ *QUERY-OPTIMIZATION-STRATEGY*
    KWD-OPTIMIZE-DYNAMIC-WITH-CLUSTERING)))

;;; (DEFUN (DYNAMICALLY-OPTIMIZE-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN DYNAMICALLY-OPTIMIZE-PROPOSITION? (SELF)
  (CL:AND
   (CL:OR (CL:EQ *QUERY-OPTIMIZATION-STRATEGY* KWD-OPTIMIZE-DYNAMIC)
    (CL:EQ *QUERY-OPTIMIZATION-STRATEGY*
     KWD-OPTIMIZE-DYNAMIC-WITH-CLUSTERING))
   (CL:NOT
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
      SYM-OPTIMIZE-LOGIC-DONT-OPTIMIZE? FALSE-WRAPPER)))))

;;; (DEFUN (USE-STATIC-QUERY-OPTIMIZATION? BOOLEAN) ...)

(CL:DEFUN USE-STATIC-QUERY-OPTIMIZATION? ()
  (CL:AND
   (CL:NOT (CL:EQ *QUERY-OPTIMIZATION-STRATEGY* KWD-OPTIMIZE-NONE))
   (CL:NOT
    (CL:OR (CL:EQ *QUERY-OPTIMIZATION-STRATEGY* KWD-OPTIMIZE-DYNAMIC)
     (CL:EQ *QUERY-OPTIMIZATION-STRATEGY*
      KWD-OPTIMIZE-DYNAMIC-WITH-CLUSTERING)))))

;;; (DEFUN (STATICALLY-OPTIMIZE-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN STATICALLY-OPTIMIZE-PROPOSITION? (SELF)
  (CL:AND
   (CL:AND
    (CL:NOT (CL:EQ *QUERY-OPTIMIZATION-STRATEGY* KWD-OPTIMIZE-NONE))
    (CL:NOT
     (CL:OR (CL:EQ *QUERY-OPTIMIZATION-STRATEGY* KWD-OPTIMIZE-DYNAMIC)
      (CL:EQ *QUERY-OPTIMIZATION-STRATEGY*
       KWD-OPTIMIZE-DYNAMIC-WITH-CLUSTERING))))
   (CL:NOT
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
      SYM-OPTIMIZE-LOGIC-DONT-OPTIMIZE? FALSE-WRAPPER)))))

;;; (DEFUN (TRY-TO-CLUSTER-CONJUNCTIONS? BOOLEAN) ...)

(CL:DEFUN TRY-TO-CLUSTER-CONJUNCTIONS? ()
  (CL:EQ *QUERY-OPTIMIZATION-STRATEGY*
   KWD-OPTIMIZE-STATIC-WITH-CLUSTERING))

;;; (DEFUN (SELECT-OPTIMAL-QUERY-PATTERN DESCRIPTION) ...)

(CL:DEFUN SELECT-OPTIMAL-QUERY-PATTERN (DESCRIPTION BOOLEANVECTOR PARENTFRAME)
  (CL:LET*
   ((PATTERN NULL)
    (QUERYPATTERNS (%DESCRIPTION.QUERY-PATTERNS DESCRIPTION)))
   (CL:WHEN (CL:NOT (CL:EQ QUERYPATTERNS NULL))
    (CL:SETQ PATTERN (LOOKUP QUERYPATTERNS BOOLEANVECTOR)))
   (CL:WHEN (TRACE-KEYWORD? KWD-OPTIMIZE-OPTIMIZER)
    (CL:SETQ PATTERN NULL))
   (CL:WHEN (CL:NOT (CL:EQ PATTERN NULL))
    (CL:RETURN-FROM SELECT-OPTIMAL-QUERY-PATTERN PATTERN))
   (CL:WHEN (CL:EQ QUERYPATTERNS NULL)
    (CL:SETF (%DESCRIPTION.QUERY-PATTERNS DESCRIPTION)
     (NEW-KEY-VALUE-LIST)))
   (CL:LET* ((*BOUNDTOOFFSETCOUNTER* 0))
    (CL:DECLARE (CL:SPECIAL *BOUNDTOOFFSETCOUNTER*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *BOUNDTOOFFSETCOUNTER*))
    (CL:SETQ PATTERN (COPY-DESCRIPTION DESCRIPTION NULL CL:T)))
   (INSERT-AT (%DESCRIPTION.QUERY-PATTERNS DESCRIPTION) BOOLEANVECTOR
    PATTERN)
   (CL:WHEN
    (CL:NOT
     (CL:OR
      (CL:NOT
       (CL:AND
        (CL:NOT
         (CL:EQ *QUERY-OPTIMIZATION-STRATEGY* KWD-OPTIMIZE-NONE))
        (CL:NOT
         (CL:OR
          (CL:EQ *QUERY-OPTIMIZATION-STRATEGY* KWD-OPTIMIZE-DYNAMIC)
          (CL:EQ *QUERY-OPTIMIZATION-STRATEGY*
           KWD-OPTIMIZE-DYNAMIC-WITH-CLUSTERING)))))
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
        SYM-OPTIMIZE-LOGIC-DONT-OPTIMIZE? FALSE-WRAPPER))
      (CONTAINS-OPERATOR? (%DESCRIPTION.PROPOSITION DESCRIPTION)
       SGT-OPTIMIZE-PL-KERNEL-KB-CUT)
      (CONTAINS-OPERATOR? (%DESCRIPTION.PROPOSITION DESCRIPTION)
       SGT-OPTIMIZE-PL-KERNEL-KB-BOUND-VARIABLES)))
    (OPTIMIZE-QUERY PATTERN BOOLEANVECTOR PARENTFRAME))
   (SIMPLIFY-DESCRIPTION PATTERN CL:T) PATTERN))

;;; (DEFUN (DYNAMICALLY-ESTIMATE-GOAL-COST COST-ESTIMATE) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT)
  DYNAMICALLY-ESTIMATE-GOAL-COST))
(CL:DEFUN DYNAMICALLY-ESTIMATE-GOAL-COST (GOAL)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND GOAL)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-ISA)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-PREDICATE))
     (CL:LET*
      ((OPERATOR (%PROPOSITION.OPERATOR GOAL))
       (DESCRIPTION (GET-DESCRIPTION OPERATOR)) (FIRSTARGVALUE NULL))
      (CL:WHEN (CL:EQ OPERATOR SGT-OPTIMIZE-PL-KERNEL-KB-HOLDS)
       (CL:SETQ FIRSTARGVALUE
        (ARGUMENT-BOUND-TO
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
          0)))
       (CL:IF (CL:NOT (CL:EQ FIRSTARGVALUE NULL))
        (CL:IF
         (ISA? FIRSTARGVALUE SGT-OPTIMIZE-LOGIC-NAMED-DESCRIPTION)
         (CL:SETQ DESCRIPTION FIRSTARGVALUE)
         (CL:SETQ DESCRIPTION NULL))
        (CL:RETURN-FROM DYNAMICALLY-ESTIMATE-GOAL-COST
         INFERABLE-PENALTY-COST)))
      (CL:IF
       (CL:OR (CL:EQ DESCRIPTION NULL)
        (CL:NOT (INFERABLE? DESCRIPTION)))
       1.0d0 INFERABLE-PENALTY-COST)))
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-IMPLIES)
     SUBSET-OF-PENALTY-COST)
    (CL:T 1.0d0))))

;;; (DEFUN (DYNAMICALLY-ESTIMATE-GOAL-FANOUT COST-ESTIMATE) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT)
  DYNAMICALLY-ESTIMATE-GOAL-FANOUT))
(CL:DEFUN DYNAMICALLY-ESTIMATE-GOAL-FANOUT (GOAL)
  (CL:WHEN (ALL-ARGUMENTS-BOUND? GOAL)
   (CL:RETURN-FROM DYNAMICALLY-ESTIMATE-GOAL-FANOUT 1.0d0))
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND GOAL)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-ISA)
     (DYNAMICALLY-ESTIMATE-EXTENSION-SIZE
      (GET-DESCRIPTION (%PROPOSITION.OPERATOR GOAL))))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-PREDICATE))
     (CL:WHEN
      (CL:EQ (%PROPOSITION.OPERATOR GOAL)
       SGT-OPTIMIZE-PL-KERNEL-KB-HOLDS)
      (CL:IF
       (CL:NOT
        (ARGUMENT-BOUND?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
          0)))
       (CL:RETURN-FROM DYNAMICALLY-ESTIMATE-GOAL-FANOUT NULL-FLOAT)
       (CL:RETURN-FROM DYNAMICALLY-ESTIMATE-GOAL-FANOUT
        (DYNAMICALLY-ESTIMATE-PREDICATE-GOAL-FANOUT GOAL))))
     (CL:IF (ALL-KEY-ARGUMENTS-BOUND? GOAL) 1.0d0
      (DYNAMICALLY-ESTIMATE-PREDICATE-GOAL-FANOUT GOAL)))
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-IMPLIES)
     ESTIMATED-CARDINALITY-OF-SUBSET-OF)
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-EQUIVALENT)
     (CL:IF
      (CL:OR
       (ARGUMENT-BOUND?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
         0))
       (ARGUMENT-BOUND?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
         1)))
      1.0d0 NULL-FLOAT))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-NOT)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FAIL)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FORALL))
     NULL-FLOAT)
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-AND)
     (CL:LET* ((FANOUT NULL-FLOAT) (MINFANOUT NULL-FLOAT))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT FANOUT MINFANOUT))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS GOAL))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ FANOUT (DYNAMICALLY-ESTIMATE-GOAL-FANOUT ARG))
        (CL:WHEN
         (CL:OR (CL:= MINFANOUT NULL-FLOAT) (CL:< FANOUT MINFANOUT))
         (CL:SETQ MINFANOUT FANOUT))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      MINFANOUT))
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-OR)
     (CL:LET* ((FANOUT NULL-FLOAT) (TOTALFANOUT NULL-FLOAT))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT FANOUT TOTALFANOUT))
      (CL:LET*
       ((ARG NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS GOAL))
        (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:SETQ FANOUT (DYNAMICALLY-ESTIMATE-GOAL-FANOUT ARG))
        (CL:WHEN (CL:NOT (CL:= FANOUT NULL-FLOAT))
         (CL:WHEN (CL:= TOTALFANOUT NULL-FLOAT)
          (CL:SETQ TOTALFANOUT 0.0d0))
         (CL:SETQ TOTALFANOUT (CL:+ TOTALFANOUT FANOUT)))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      TOTALFANOUT))
    (CL:T NULL-FLOAT))))

;;; (DEFUN (DYNAMICALLY-ESTIMATE-PREDICATE-GOAL-FANOUT COST-ESTIMATE) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT)
  DYNAMICALLY-ESTIMATE-PREDICATE-GOAL-FANOUT))
(CL:DEFUN DYNAMICALLY-ESTIMATE-PREDICATE-GOAL-FANOUT (GOAL)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.OPERATOR GOAL)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-OPTIMIZE-PL-KERNEL-KB-MEMBER-OF)
     (ESTIMATE-MEMBER-OF-GOAL-FANOUT GOAL))
    ((CL:EQ TEST-VALUE-000 SGT-OPTIMIZE-PL-KERNEL-KB-INSTANCE-OF)
     (DYNAMICALLY-ESTIMATE-INSTANCE-OF-GOAL-FANOUT GOAL))
    (CL:T
     (CL:LET*
      ((PATTERNARGS NIL) (RELATION (%PROPOSITION.OPERATOR GOAL))
       (ARGUMENTS (%PROPOSITION.ARGUMENTS GOAL)) (FIRSTARGINDEX 0)
       (NOFUNBOUNDARGS 0) (UNBOUNDARGINDEX NULL-INTEGER) (KEY NULL)
       (RELATIONEXTENSION? CL:T)
       (DESCRIPTION (GET-DESCRIPTION RELATION)))
      (CL:DECLARE
       (CL:TYPE CL:FIXNUM FIRSTARGINDEX NOFUNBOUNDARGS
        UNBOUNDARGINDEX))
      (CL:WHEN (CL:EQ RELATION SGT-OPTIMIZE-PL-KERNEL-KB-HOLDS)
       (CL:COND
        ((ISA?
          (ARGUMENT-BOUND-TO
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) 0))
          SGT-OPTIMIZE-LOGIC-NAMED-DESCRIPTION)
         (CL:SETQ DESCRIPTION
          (ARGUMENT-BOUND-TO
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
            0)))
         (CL:SETQ FIRSTARGINDEX 1))
        (CL:T (CL:SETQ DESCRIPTION NULL))))
      (CL:WHEN (CL:EQ DESCRIPTION NULL)
       (CL:RETURN-FROM DYNAMICALLY-ESTIMATE-PREDICATE-GOAL-FANOUT
        NULL-FLOAT))
      (CL:LET*
       ((I NULL-INTEGER) (ITER-000 FIRSTARGINDEX)
        (UPPER-BOUND-000 (CL:1- (LENGTH ARGUMENTS)))
        (COLLECT-000 NULL))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
       (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
        (CL:SETQ I ITER-000)
        (CL:SETQ KEY
         (ARGUMENT-BOUND-TO
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) I)))
        (CL:COND
         ((CL:NOT (CL:EQ KEY NULL))
          (CL:WHEN (INSTANCE-HAS-BACKLINKS? KEY)
           (CL:SETQ RELATIONEXTENSION? CL:NIL)))
         (CL:T (CL:SETQ NOFUNBOUNDARGS (CL:1+ NOFUNBOUNDARGS))
          (CL:SETQ UNBOUNDARGINDEX I)))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS KEY NIL))
          (CL:IF (CL:EQ PATTERNARGS NIL)
           (CL:SETQ PATTERNARGS COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST PATTERNARGS COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS KEY NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
        (CL:SETQ ITER-000 (CL:1+ ITER-000))))
      (CL:WHEN (COMPUTED-TERM? DESCRIPTION)
       (CL:CASE NOFUNBOUNDARGS
        (0
         (CL:RETURN-FROM DYNAMICALLY-ESTIMATE-PREDICATE-GOAL-FANOUT
          (CL:FLOAT 1 0.0d0)))
        (1
         (CL:COND
          ((CL:= UNBOUNDARGINDEX (CL:1- (LENGTH ARGUMENTS)))
           (CL:RETURN-FROM DYNAMICALLY-ESTIMATE-PREDICATE-GOAL-FANOUT
            (CL:FLOAT 1 0.0d0)))
          ((COMPUTED-CONSTRAINT? DESCRIPTION)
           (CL:RETURN-FROM DYNAMICALLY-ESTIMATE-PREDICATE-GOAL-FANOUT
            (CL:FLOAT 1 0.0d0)))))
        (CL:OTHERWISE))
       (CL:RETURN-FROM DYNAMICALLY-ESTIMATE-PREDICATE-GOAL-FANOUT
        NULL-FLOAT))
      (CL:WHEN
       (CL:AND
        (TEST-PROPERTY? DESCRIPTION SGT-OPTIMIZE-PL-KERNEL-KB-TOTAL)
        (CL:> NOFUNBOUNDARGS 1)
        (CL:= UNBOUNDARGINDEX (CL:1- (LENGTH ARGUMENTS))))
       (CL:RETURN-FROM DYNAMICALLY-ESTIMATE-PREDICATE-GOAL-FANOUT
        NULL-FLOAT))
      (CL:IF RELATIONEXTENSION?
       (DYNAMICALLY-ESTIMATE-EXTENSION-SIZE DESCRIPTION)
       (CL:FLOAT
        (ESTIMATED-LENGTH
         (SELECT-PROPOSITIONS
          (CONS KWD-OPTIMIZE-RELATION
           (CONS (CL:IF (CL:EQ NIL NULL) NIL NIL)
            (CONS RELATION PATTERNARGS)))))
        0.0d0)))))))

;;; (DEFUN (DYNAMICALLY-ESTIMATE-INSTANCE-OF-GOAL-FANOUT COST-ESTIMATE) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT)
  DYNAMICALLY-ESTIMATE-INSTANCE-OF-GOAL-FANOUT))
(CL:DEFUN DYNAMICALLY-ESTIMATE-INSTANCE-OF-GOAL-FANOUT (GOAL)
  (CL:LET*
   ((INSTANCEVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
       0)))
    (COLLECTIONVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
       1))))
   (CL:COND
    ((CL:NOT (CL:EQ INSTANCEVALUE NULL))
     (CL:FLOAT (LENGTH (ALL-TYPES INSTANCEVALUE)) 0.0d0))
    ((CL:NOT (CL:EQ COLLECTIONVALUE NULL))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE COLLECTIONVALUE)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-OPTIMIZE-LOGIC-DESCRIPTION)
        (CL:PROGN
         (CL:IF
          (ISA? COLLECTIONVALUE SGT-OPTIMIZE-LOGIC-NAMED-DESCRIPTION)
          (DYNAMICALLY-ESTIMATE-EXTENSION-SIZE COLLECTIONVALUE)
          ESTIMATED-CARDINALITY-OF-DESCRIPTION)))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-OPTIMIZE-STELLA-COLLECTION)
        (CL:PROGN (CL:FLOAT (LENGTH COLLECTIONVALUE) 0.0d0)))
       (CL:T NULL-FLOAT))))
    (CL:T NULL-FLOAT))))

;;; (DEFUN (DYNAMICALLY-ESTIMATE-EXTENSION-SIZE COST-ESTIMATE) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT)
  DYNAMICALLY-ESTIMATE-EXTENSION-SIZE))
(CL:DEFUN DYNAMICALLY-ESTIMATE-EXTENSION-SIZE (DESCRIPTION)
  (CL:WHEN
   (CL:OR (CL:EQ DESCRIPTION NULL)
    (CL:NOT (RELATION-SUPPORTS-EXTENSION? DESCRIPTION)))
   (CL:RETURN-FROM DYNAMICALLY-ESTIMATE-EXTENSION-SIZE NULL-FLOAT))
  (CL:LET* ((ESTIMATE NULL-FLOAT))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT ESTIMATE))
   (CL:WHEN (CL:= ESTIMATE NULL-FLOAT)
    (CL:SETQ ESTIMATE
     (CL:FLOAT
      (ESTIMATED-LENGTH (GET-DESCRIPTION-EXTENSION DESCRIPTION CL:T))
      0.0d0)))
   ESTIMATE))

;;; (DEFUN (DYNAMICALLY-ESTIMATE-UNBOUND-VARIABLE-PENALTY COST-ESTIMATE) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT)
  DYNAMICALLY-ESTIMATE-UNBOUND-VARIABLE-PENALTY))
(CL:DEFUN DYNAMICALLY-ESTIMATE-UNBOUND-VARIABLE-PENALTY (GOAL)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND GOAL)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-NOT)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FAIL))
     (DYNAMICALLY-ESTIMATE-UNBOUND-VARIABLE-PENALTY
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS GOAL)))
       0)))
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-AND)
     (CL:LET* ((PENALTY NULL-FLOAT) (MINPENALTY NULL-FLOAT))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT PENALTY MINPENALTY))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS GOAL))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ PENALTY
         (DYNAMICALLY-ESTIMATE-UNBOUND-VARIABLE-PENALTY ARG))
        (CL:WHEN
         (CL:OR (CL:= MINPENALTY NULL-FLOAT) (CL:< PENALTY MINPENALTY))
         (CL:SETQ MINPENALTY PENALTY))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      MINPENALTY))
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-OR)
     (CL:LET* ((TOTALPENALTY 0.0d0))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT TOTALPENALTY))
      (CL:LET*
       ((ARG NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS GOAL))
        (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:SETQ TOTALPENALTY
         (CL:+ TOTALPENALTY
          (DYNAMICALLY-ESTIMATE-UNBOUND-VARIABLE-PENALTY ARG)))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      TOTALPENALTY))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-EQUIVALENT)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-ISA))
     (CL:LET*
      ((ARGUMENTS (%PROPOSITION.ARGUMENTS GOAL))
       (OPERATOR (%PROPOSITION.OPERATOR GOAL))
       (HOLDS? (CL:EQ OPERATOR SGT-OPTIMIZE-PL-KERNEL-KB-HOLDS))
       (ISFUNCTION?
        (CL:OR (CL:EQ (%PROPOSITION.KIND GOAL) KWD-OPTIMIZE-FUNCTION)
         (CL:AND HOLDS?
          (CL:NOT
           (UNBOUND-VARIABLE?
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
             0)))
          (FUNCTION?
           (ARGUMENT-BOUND-TO
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
             0))))))
       (FIRSTKEYARGINDEX (CL:IF HOLDS? 1 0))
       (LASTKEYARGINDEX
        (CL:IF ISFUNCTION? (CL:- (LENGTH ARGUMENTS) 2)
         (CL:1- (LENGTH ARGUMENTS))))
       (NOFUNBOUNDVARS
        (CL:IF
         (CL:AND HOLDS?
          (UNBOUND-VARIABLE?
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
            0)))
         10 0)))
      (CL:DECLARE
       (CL:TYPE CL:FIXNUM FIRSTKEYARGINDEX LASTKEYARGINDEX
        NOFUNBOUNDVARS))
      (CL:LET*
       ((I NULL-INTEGER) (ITER-000 FIRSTKEYARGINDEX)
        (UPPER-BOUND-000 LASTKEYARGINDEX)
        (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
       (CL:LOOP WHILE
        (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
        (CL:SETQ I ITER-000)
        (CL:WHEN
         (UNBOUND-VARIABLE?
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) I))
         (CL:SETQ NOFUNBOUNDVARS (CL:1+ NOFUNBOUNDVARS)))
        (CL:SETQ ITER-000 (CL:1+ ITER-000))))
      (CL:WHEN (COMPUTED-PREDICATE? GOAL)
       (CL:CASE NOFUNBOUNDVARS
        (0
         (CL:RETURN-FROM DYNAMICALLY-ESTIMATE-UNBOUND-VARIABLE-PENALTY
          0.0d0))
        (1
         (CL:WHEN
          (CL:AND (COMPUTED-CONSTRAINT? (GET-DESCRIPTION OPERATOR))
           (CL:OR (CL:NOT ISFUNCTION?)
            (CL:NOT
             (UNBOUND-VARIABLE?
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
               (CL:THE CL:FIXNUM (CL:1+ LASTKEYARGINDEX)))))))
          (CL:RETURN-FROM DYNAMICALLY-ESTIMATE-UNBOUND-VARIABLE-PENALTY
           0.0d0)))
        (CL:OTHERWISE))
       (CL:RETURN-FROM DYNAMICALLY-ESTIMATE-UNBOUND-VARIABLE-PENALTY
        10000.0d0))
      (CL:+ 1.0d0
       (CL:* NOFUNBOUNDVARS
        (CL:/ (CL:FLOAT NOFUNBOUNDVARS 0.0d0)
         (CL:- LASTKEYARGINDEX FIRSTKEYARGINDEX -1))))))
    (CL:T 3.0d0))))

;;; (DEFUN DYNAMICALLY-REOPTIMIZE-ARGUMENTS ...)

(CL:DEFUN DYNAMICALLY-REOPTIMIZE-ARGUMENTS (ARGUMENTS CURSOR)
  (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR))
  #+MCL
  (CL:CHECK-TYPE CURSOR CL:FIXNUM)
  (CL:LET*
   ((LASTARGINDEX (CL:1- (LENGTH ARGUMENTS))) (CHEAPESTARGINDEX CURSOR)
    (COST NULL-FLOAT) (FANOUT NULL-FLOAT) (UNBOUND NULL-FLOAT)
    (BESTCOST NULL-FLOAT) (ARGUMENT NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LASTARGINDEX CHEAPESTARGINDEX)
    (CL:TYPE CL:DOUBLE-FLOAT COST FANOUT UNBOUND BESTCOST))
   (CL:WHEN (CL:>= CURSOR LASTARGINDEX)
    (CL:RETURN-FROM DYNAMICALLY-REOPTIMIZE-ARGUMENTS))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 CURSOR) (UPPER-BOUND-000 LASTARGINDEX)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000)
     (CL:TAGBODY
      (CL:SETQ ARGUMENT
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
        I))
      (CL:WHEN
       (CL:OR
        (CONTAINS-OPERATOR? ARGUMENT SGT-OPTIMIZE-PL-KERNEL-KB-CUT)
        (CONTAINS-OPERATOR? ARGUMENT
         SGT-OPTIMIZE-PL-KERNEL-KB-BOUND-VARIABLES))
       (CL:RETURN))
      (CL:SETQ UNBOUND
       (DYNAMICALLY-ESTIMATE-UNBOUND-VARIABLE-PENALTY ARGUMENT))
      (CL:IF (CL:= UNBOUND 1.0d0) (CL:SETQ FANOUT 1.0d0)
       (CL:SETQ FANOUT (DYNAMICALLY-ESTIMATE-GOAL-FANOUT ARGUMENT)))
      (CL:WHEN (CL:= FANOUT NULL-FLOAT) (CL:GO :CONTINUE))
      (CL:WHEN (CL:< FANOUT 1.0d0) (CL:SETQ FANOUT 1.0d0))
      (CL:SETQ COST (DYNAMICALLY-ESTIMATE-GOAL-COST ARGUMENT))
      (CL:SETQ COST (CL:* COST FANOUT UNBOUND))
      (CL:WHEN (CL:OR (CL:= BESTCOST NULL-FLOAT) (CL:< COST BESTCOST))
       (CL:SETQ BESTCOST COST) (CL:SETQ CHEAPESTARGINDEX I)
       (CL:WHEN (CL:= BESTCOST 1.0d0) (CL:RETURN)))
      :CONTINUE)
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:WHEN (CL:> CHEAPESTARGINDEX CURSOR)
    (CL:SETQ ARGUMENT
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
      CURSOR))
    (CL:LET
     ((SELF (%VECTOR.THE-ARRAY ARGUMENTS))
      (VALUE
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
        CHEAPESTARGINDEX))
      (POSITION CURSOR))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET
     ((SELF (%VECTOR.THE-ARRAY ARGUMENTS)) (VALUE ARGUMENT)
      (POSITION CHEAPESTARGINDEX))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE)))))

;;; (DEFSPECIAL *POSTOPTIMIZATION?* ...)

(CL:DEFVAR *POSTOPTIMIZATION?* CL:NIL
  "Used by 'simplify-description' to permit application
of order-dependent optimizations.")

;;; (DEFUN SIMPLIFY-DESCRIPTION ...)

(CL:DEFUN SIMPLIFY-DESCRIPTION (DESCRIPTION POSTOPTIMIZATION?)
  (CL:WHEN (CL:EQ (%DESCRIPTION.PROPOSITION DESCRIPTION) NULL)
   (CL:RETURN-FROM SIMPLIFY-DESCRIPTION))
  (CL:LET* ((*POSTOPTIMIZATION?* POSTOPTIMIZATION?))
   (CL:DECLARE (CL:SPECIAL *POSTOPTIMIZATION?*))
   (SIMPLIFY-PROPOSITION (%DESCRIPTION.PROPOSITION DESCRIPTION))))

;;; (DEFUN (COPY-LIST-TO-ARGUMENTS-VECTOR ARGUMENTS-VECTOR) ...)

(CL:DEFUN COPY-LIST-TO-ARGUMENTS-VECTOR (ARGUMENTS)
  (CL:LET* ((VECTOR (NEW-VECTOR (LENGTH ARGUMENTS))))
   (CL:LET*
    ((ARG NULL) (ITER-000 (%LIST.THE-CONS-LIST ARGUMENTS))
     (I NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ARG (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY VECTOR)) (VALUE ARG) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   VECTOR))

;;; (DEFUN (CONJUNCT-CANCELS-ISA-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN CONJUNCT-CANCELS-ISA-PROPOSITION? (ISACONJUNCT OTHERCONJUNCT)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND OTHERCONJUNCT)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-ISA)
     (CL:AND
      (EQL?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS OTHERCONJUNCT)))
        0)
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS ISACONJUNCT)))
        0))
      (CL:IF *POSTOPTIMIZATION?*
       (RELATIONREF-SPECIALIZES-RELATIONREF?
        (%PROPOSITION.OPERATOR OTHERCONJUNCT)
        (%PROPOSITION.OPERATOR ISACONJUNCT))
       (CL:EQ (%PROPOSITION.OPERATOR OTHERCONJUNCT)
        (%PROPOSITION.OPERATOR ISACONJUNCT)))))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-PREDICATE))
     (CL:LET*
      ((INMEMBER
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS ISACONJUNCT)))
         0))
       (INTYPE (%PROPOSITION.OPERATOR ISACONJUNCT)))
      (CL:LET* ((TEST-VALUE-001 CL:NIL))
       (CL:SETQ TEST-VALUE-001 *POSTOPTIMIZATION?*)
       (CL:WHEN TEST-VALUE-001 (CL:SETQ TEST-VALUE-001 (TYPE? INTYPE))
        (CL:WHEN TEST-VALUE-001
         (CL:SETQ TEST-VALUE-001
          (SURROGATE? (%PROPOSITION.OPERATOR OTHERCONJUNCT)))
         (CL:WHEN TEST-VALUE-001
          (CL:LET* ((FOUND?-000 CL:NIL))
           (CL:LET*
            ((ARG NULL)
             (VECTOR-000 (%PROPOSITION.ARGUMENTS OTHERCONJUNCT))
             (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
             (ARGTYPE NULL)
             (ITER-000
              (%LIST.THE-CONS-LIST
               (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES
                (GET-DESCRIPTION
                 (%PROPOSITION.OPERATOR OTHERCONJUNCT))))))
            (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
            (CL:LOOP WHILE
             (CL:AND (CL:< INDEX-000 LENGTH-000)
              (CL:NOT (CL:EQ ITER-000 NIL)))
             DO
             (CL:SETQ ARG
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
               INDEX-000))
             (CL:SETQ ARGTYPE (%%VALUE ITER-000))
             (CL:WHEN
              (CL:AND (EQL? ARG INMEMBER)
               (LOGICAL-SUBTYPE-OF? ARGTYPE INTYPE))
              (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
             (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
             (CL:SETQ ITER-000 (%%REST ITER-000))))
           (CL:SETQ TEST-VALUE-001 FOUND?-000)))))
       (CL:LET* ((VALUE-000 TEST-VALUE-001)) VALUE-000))))
    (CL:T CL:NIL))))

;;; (DEFUN SIMPLIFY-CONJUNCTION ...)

(CL:DEFUN SIMPLIFY-CONJUNCTION (ANDPROPOSITION)
  (CL:LET* ((CONJUNCTSLIST (NEW-LIST)) (CURSOR NULL) (CURSORPOS 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSORPOS))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS ANDPROPOSITION))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (PUSH CONJUNCTSLIST ARG) (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:SETQ CURSOR (%LIST.THE-CONS-LIST CONJUNCTSLIST))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:LET* ((CONJUNCT (%%VALUE CURSOR)))
     (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND CONJUNCT)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-EQUIVALENT)
        (CL:WHEN
         (CL:OR
          (EQL?
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS CONJUNCT)))
            0)
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS CONJUNCT)))
            1))
          (CL:AND
           (EQL?
            (VALUE-OF
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS CONJUNCT)))
              0))
            (VALUE-OF
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS CONJUNCT)))
              1)))
           (ISA?
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS CONJUNCT)))
             0)
            SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)
           (ISA?
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS CONJUNCT)))
             1)
            SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)))
         (CL:LET*
          ((ARG NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS CONJUNCT))
           (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
          (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
           (CL:SETQ ARG
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
             INDEX-001))
           (REMOVE-DEPENDENT-PROPOSITION-LINK ARG CONJUNCT)
           (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
         (CL:SETF (%%VALUE CURSOR) TRUE-PROPOSITION)))
       ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-ISA)
        (CL:LET* ((VALUE-000 NULL))
         (CL:LET*
          ((OTHERCONJ NULL)
           (ITER-000 (%LIST.THE-CONS-LIST CONJUNCTSLIST))
           (I NULL-INTEGER) (ITER-001 0))
          (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
           (CL:SETQ OTHERCONJ (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
           (CL:WHEN
            (CL:AND (CL:NOT (CL:= I CURSORPOS))
             (CONJUNCT-CANCELS-ISA-PROPOSITION? CONJUNCT OTHERCONJ))
            (CL:SETQ VALUE-000 OTHERCONJ) (CL:RETURN))
           (CL:SETQ ITER-000 (%%REST ITER-000))
           (CL:SETQ ITER-001 (CL:1+ ITER-001))))
         (CL:LET* ((DOMINATINGCONJUNCT VALUE-000))
          (CL:WHEN
           (CL:OR
            (CL:EQ (%PROPOSITION.OPERATOR CONJUNCT)
             SGT-OPTIMIZE-STELLA-THING)
            (CL:NOT (CL:EQ DOMINATINGCONJUNCT NULL)))
           (CL:WHEN (CL:NOT (CL:EQ CONJUNCT DOMINATINGCONJUNCT))
            (CL:LET*
             ((ARG NULL) (VECTOR-002 (%PROPOSITION.ARGUMENTS CONJUNCT))
              (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)))
             (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
             (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
              (CL:SETQ ARG
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR
                 (%VECTOR.THE-ARRAY VECTOR-002))
                INDEX-002))
              (REMOVE-DEPENDENT-PROPOSITION-LINK ARG CONJUNCT)
              (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))))
           (CL:SETF (%%VALUE CURSOR) TRUE-PROPOSITION)))))
       ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-AND)
        (SIMPLIFY-CONJUNCTION (%%VALUE CURSOR)))
       (CL:T))))
    (CL:SETQ CURSOR (%%REST CURSOR))
    (CL:SETQ CURSORPOS (CL:1+ CURSORPOS)))
   (CL:WHEN (MEMBER? CONJUNCTSLIST TRUE-PROPOSITION)
    (REMOVE CONJUNCTSLIST TRUE-PROPOSITION) (REVERSE CONJUNCTSLIST)
    (CL:CASE (LENGTH CONJUNCTSLIST)
     (0
      (OVERLAY-WITH-CONSTANT-PROPOSITION ANDPROPOSITION
       TRUE-PROPOSITION))
     (1 (OVERLAY-PROPOSITION ANDPROPOSITION (FIRST CONJUNCTSLIST))
      (CL:LET*
       ((ARG NULL) (VECTOR-003 (%PROPOSITION.ARGUMENTS ANDPROPOSITION))
        (INDEX-003 0) (LENGTH-003 (LENGTH VECTOR-003)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-003 LENGTH-003))
       (CL:LOOP WHILE (CL:< INDEX-003 LENGTH-003) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-003))
          INDEX-003))
        (ADD-DEPENDENT-PROPOSITION-LINK ARG ANDPROPOSITION)
        (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))))
     (CL:OTHERWISE
      (CL:SETF (%PROPOSITION.ARGUMENTS ANDPROPOSITION)
       (COPY-LIST-TO-ARGUMENTS-VECTOR CONJUNCTSLIST))))
    (FREE CONJUNCTSLIST))))

;;; (DEFUN SIMPLIFY-PROPOSITION ...)

(CL:DEFUN SIMPLIFY-PROPOSITION (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FORALL))
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-AND)
     (SIMPLIFY-CONJUNCTION PROPOSITION))
    (CL:T
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE ARG)))
        (CL:COND
         ((SUBTYPE-OF? TEST-VALUE-001 SGT-OPTIMIZE-LOGIC-PROPOSITION)
          (CL:PROGN (SIMPLIFY-PROPOSITION ARG)))
         ((SUBTYPE-OF? TEST-VALUE-001 SGT-OPTIMIZE-LOGIC-DESCRIPTION)
          (CL:PROGN (SIMPLIFY-DESCRIPTION ARG *POSTOPTIMIZATION?*)))
         (CL:T)))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))))))

;;; (DEFUN (COPY-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN COPY-DESCRIPTION (SELF PARENTMAPPING ADDBACKLINKS?)
  (CL:LET*
   ((*CONTEXT* (%DESCRIPTION.HOME-CONTEXT SELF))
    (*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)))
   (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
   (CL:LET*
    ((COPY (CREATE-DESCRIPTION NULL-INTEGER CL:NIL))
     (MAPPING (NEW-KEY-VALUE-LIST)))
    (CL:WHEN (CL:NOT (CL:EQ PARENTMAPPING NULL))
     (CL:LET*
      ((K NULL) (V NULL)
       (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST PARENTMAPPING)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
       (CL:SETQ K (%KV-CONS.KEY ITER-000))
       (CL:SETQ V (%KV-CONS.VALUE ITER-000))
       (CL:WHEN (ISA? K SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)
        (INSERT-AT MAPPING K V))
       (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000)))))
    (CL:SETF (%DESCRIPTION.IO-VARIABLES COPY)
     (COPY-VARIABLES-VECTOR (%DESCRIPTION.IO-VARIABLES SELF) MAPPING))
    (CL:SETF (%DESCRIPTION.INTERNAL-VARIABLES COPY)
     (COPY-VARIABLES-VECTOR (%DESCRIPTION.INTERNAL-VARIABLES SELF)
      MAPPING))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-OPTIMIZE-LOGIC-EXTERNAL-VARIABLES NULL)
       NULL))
     (CL:LET* ((VALUE-000 NIL))
      (CL:LET*
       ((VAR NULL)
        (VECTOR-000
         (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
          SYM-OPTIMIZE-LOGIC-EXTERNAL-VARIABLES NULL))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
        (COLLECT-000 NULL))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ VAR
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:WHEN
         (CL:OR (CL:EQ (LOOKUP MAPPING VAR) NULL)
          (VARIABLE? (LOOKUP MAPPING VAR)))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN (CL:SETQ COLLECT-000 (CONS VAR NIL))
           (CL:IF (CL:EQ VALUE-000 NIL) (CL:SETQ VALUE-000 COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST VALUE-000 COLLECT-000)))
          (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VAR NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:LET* ((REALEXTERNALVARS VALUE-000) (EXTERNALVARSCOPY NULL))
       (CL:IF
        (CL:=
         (LENGTH
          (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
           SYM-OPTIMIZE-LOGIC-EXTERNAL-VARIABLES NULL))
         (LENGTH REALEXTERNALVARS))
        (CL:SETQ EXTERNALVARSCOPY
         (COPY-VARIABLES-VECTOR
          (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
           SYM-OPTIMIZE-LOGIC-EXTERNAL-VARIABLES NULL)
          MAPPING))
        (CL:WHEN (CL:NOT (CL:EQ REALEXTERNALVARS NIL))
         (CL:SETQ EXTERNALVARSCOPY
          (COPY-VARIABLES-VECTOR
           (COPY-CONS-LIST-TO-VARIABLES-VECTOR REALEXTERNALVARS)
           MAPPING))))
       (SET-DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS COPY)
        SYM-OPTIMIZE-LOGIC-EXTERNAL-VARIABLES EXTERNALVARSCOPY NULL))))
    (CL:WHEN (CL:NOT (CL:EQ (%DESCRIPTION.PROPOSITION SELF) NULL))
     (CL:LET*
      ((*BOUNDTOOFFSETCOUNTER* NULL-INTEGER)
       (*EVALUATIONMODE* KWD-OPTIMIZE-DESCRIPTION))
      (CL:DECLARE (CL:SPECIAL *BOUNDTOOFFSETCOUNTER* *EVALUATIONMODE*))
      (CL:DECLARE (CL:TYPE CL:FIXNUM *BOUNDTOOFFSETCOUNTER*))
      (CL:SETF (%DESCRIPTION.PROPOSITION COPY)
       (CL:IF ADDBACKLINKS?
        (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS
         (COPY-PROPOSITION (%DESCRIPTION.PROPOSITION SELF) MAPPING)
         CL:NIL)
        (COPY-PROPOSITION (%DESCRIPTION.PROPOSITION SELF) MAPPING)))))
    (CL:WHEN
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
       SYM-OPTIMIZE-LOGIC-DONT-OPTIMIZE? FALSE-WRAPPER))
     (SET-DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS COPY)
      SYM-OPTIMIZE-LOGIC-DONT-OPTIMIZE?
      (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
    (FREE MAPPING) COPY)))

;;; (DEFUN (COPY-VARIABLE PATTERN-VARIABLE) ...)

(CL:DEFUN COPY-VARIABLE (SELF MAPPING)
  (CL:LET* ((COPY (LOOKUP MAPPING SELF)))
   (CL:WHEN (CL:NOT (CL:EQ COPY NULL))
    (CL:RETURN-FROM COPY-VARIABLE COPY))
   (CL:SETQ COPY
    (CREATE-VARIABLE (%PATTERN-VARIABLE.SKOLEM-TYPE SELF)
     (%PATTERN-VARIABLE.SKOLEM-NAME SELF) CL:NIL))
   (CL:COND
    ((CL:OR (CL:EQ *PRINTMODE* KWD-OPTIMIZE-REALISTIC)
      (CL:EQ *PRINTMODE* KWD-OPTIMIZE-FLAT))
     (CL:SETF (%PATTERN-VARIABLE.SKOLEM-NAME COPY)
      (%PATTERN-VARIABLE.SKOLEM-NAME SELF)))
    (CL:T
     (CL:LET*
      ((COPYNAME
        (CONCATENATE "?CP_"
         (SUBSEQUENCE
          (%SYMBOL.SYMBOL-NAME (%PATTERN-VARIABLE.SKOLEM-NAME SELF)) 1
          NULL-INTEGER))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING COPYNAME))
      (CL:SETF (%PATTERN-VARIABLE.SKOLEM-NAME COPY)
       (INTERN-SYMBOL COPYNAME)))))
   (CL:SETF (%PATTERN-VARIABLE.SKOLEM-TYPE COPY)
    (%PATTERN-VARIABLE.SKOLEM-TYPE SELF))
   (CL:WHEN
    (CL:NOT
     (CL:EQ
      (ACCESS-IN-CONTEXT (%SKOLEM.VARIABLE-VALUE SELF)
       (%SKOLEM.HOME-CONTEXT SELF) CL:NIL)
      NULL))
    (CL:LET*
     ((OBJECT-000 COPY)
      (VALUE-000
       (ACCESS-IN-CONTEXT (%SKOLEM.VARIABLE-VALUE SELF)
        (%SKOLEM.HOME-CONTEXT SELF) CL:NIL))
      (OLD-VALUE-002 (%SKOLEM.VARIABLE-VALUE OBJECT-000))
      (NEW-VALUE-000
       (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-000
        (%PATTERN-VARIABLE.HOME-CONTEXT OBJECT-000) CL:NIL)))
     (CL:WHEN
      (CL:NOT
       (CL:AND (CL:NOT (CL:EQ OLD-VALUE-002 NULL))
        (CL:EQ (PRIMARY-TYPE OLD-VALUE-002)
         SGT-OPTIMIZE-STELLA-CS-VALUE)))
      (CL:SETF (%SKOLEM.VARIABLE-VALUE OBJECT-000) NEW-VALUE-000))))
   (INSERT-AT MAPPING SELF COPY) COPY))

;;; (DEFUN (COPY-VARIABLES-VECTOR VARIABLES-VECTOR) ...)

(CL:DEFUN COPY-VARIABLES-VECTOR (SELF MAPPING)
  (CL:WHEN (CL:= (%VECTOR.ARRAY-SIZE SELF) 0)
   (CL:RETURN-FROM COPY-VARIABLES-VECTOR ZERO-VARIABLES-VECTOR))
  (CL:LET* ((COPY (NEW-VECTOR (LENGTH SELF))))
   (CL:LET*
    ((VBL NULL) (VECTOR-000 SELF) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ VBL
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:LET* ((VBLCOPY (COPY-VARIABLE VBL MAPPING)))
      (CL:WHEN (DEFINED? *BOUNDTOOFFSETCOUNTER*)
       (CL:SETF (%PATTERN-VARIABLE.BOUND-TO-OFFSET VBLCOPY)
        *BOUNDTOOFFSETCOUNTER*)
       (CL:SETQ *BOUNDTOOFFSETCOUNTER* (CL:1+ *BOUNDTOOFFSETCOUNTER*)))
      (CL:LET
       ((SELF (%VECTOR.THE-ARRAY COPY)) (VALUE VBLCOPY) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE)))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   COPY))

;;; (DEFUN (COPY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN COPY-PROPOSITION (SELF MAPPING)
  (CL:LET* ((COPY (LOOKUP MAPPING SELF)))
   (CL:COND
    ((CL:NOT (CL:EQ COPY NULL)) (CL:RETURN-FROM COPY-PROPOSITION COPY))
    ((CL:EQ (%PROPOSITION.KIND SELF) KWD-OPTIMIZE-CONSTANT)
     (CL:RETURN-FROM COPY-PROPOSITION SELF)))
   (CL:SETQ COPY
    (CREATE-PROPOSITION SYM-OPTIMIZE-STELLA-PREDICATE
     (LENGTH (%PROPOSITION.ARGUMENTS SELF))))
   (CL:SETF (%PROPOSITION.HOME-CONTEXT COPY) *MODULE*)
   (CL:SETF (%PROPOSITION.KIND COPY) (%PROPOSITION.KIND SELF))
   (CL:SETF (%PROPOSITION.OPERATOR COPY)
    (COPY-PROPOSITION-ARGUMENT (%PROPOSITION.OPERATOR SELF) MAPPING))
   (CL:LET*
    ((OBJECT-000 COPY)
     (VALUE-000
      (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE SELF)
       (%PROPOSITION.HOME-CONTEXT SELF) CL:NIL))
     (OLD-VALUE-001 (%PROPOSITION.TRUTH-VALUE OBJECT-000))
     (NEW-VALUE-000
      (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-000
       (%PROPOSITION.HOME-CONTEXT OBJECT-000) CL:NIL)))
    (CL:WHEN
     (CL:NOT
      (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
       (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
        SGT-OPTIMIZE-STELLA-CS-VALUE)))
     (CL:SETF (%PROPOSITION.TRUTH-VALUE OBJECT-000) NEW-VALUE-000)))
   (CL:WHEN
    (CL:NOT
     (CL:=
      (%FLOAT-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
        SYM-OPTIMIZE-LOGIC-WEIGHT NULL-FLOAT-WRAPPER))
      NULL-FLOAT))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS COPY)
     SYM-OPTIMIZE-LOGIC-WEIGHT
     (WRAP-FLOAT
      (%FLOAT-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
        SYM-OPTIMIZE-LOGIC-WEIGHT NULL-FLOAT-WRAPPER)))
     NULL-FLOAT-WRAPPER))
   (CL:WHEN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? SELF))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS COPY)
     SYM-OPTIMIZE-LOGIC-VARIABLE-TYPE? TRUE-WRAPPER NULL))
   (CL:WHEN
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
      SYM-OPTIMIZE-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS COPY)
     SYM-OPTIMIZE-LOGIC-DESCRIPTIVE?
     (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
   (CL:WHEN
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
      SYM-OPTIMIZE-LOGIC-DONT-OPTIMIZE? FALSE-WRAPPER))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS COPY)
     SYM-OPTIMIZE-LOGIC-DONT-OPTIMIZE?
     (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
   (CL:WHEN
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
       SYM-OPTIMIZE-LOGIC-ANNOTATIONS NULL)
      NULL))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS COPY)
     SYM-OPTIMIZE-LOGIC-ANNOTATIONS
     (COPY
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
       SYM-OPTIMIZE-LOGIC-ANNOTATIONS NULL))
     NULL)
    (FINALIZE-PROPOSITION-ANNOTATIONS COPY))
   (INSERT-AT MAPPING SELF COPY)
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FORALL)
       (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-EXISTS))
      (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS COPY)
       SYM-OPTIMIZE-LOGIC-IO-VARIABLES
       (COPY-VARIABLES-VECTOR
        (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
         SYM-OPTIMIZE-LOGIC-IO-VARIABLES NULL)
        MAPPING)
       NULL))
     (CL:T)))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER)
     (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS COPY)))
       (VALUE (COPY-PROPOSITION-ARGUMENT ARG MAPPING)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   COPY))

;;; (DEFUN (COPY-PROPOSITION-ARGUMENT OBJECT) ...)

(CL:DEFUN COPY-PROPOSITION-ARGUMENT (SELF MAPPING)
  (CL:LET* ((COPY (LOOKUP MAPPING SELF)))
   (CL:WHEN (CL:NOT (CL:EQ COPY NULL))
    (CL:WHEN (DESCRIPTION-MODE?)
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE COPY)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)
        (CL:PROGN))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-OPTIMIZE-LOGIC-LOGIC-OBJECT)
        (CL:PROGN
         (CL:WHEN
          (CL:NOT
           (CL:EQ (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE COPY) NULL))
          (CL:RETURN-FROM COPY-PROPOSITION-ARGUMENT
           (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE COPY)))))
       (CL:T))))
    (CL:RETURN-FROM COPY-PROPOSITION-ARGUMENT COPY))
   (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-001 SGT-OPTIMIZE-LOGIC-PROPOSITION)
      (CL:PROGN (COPY-PROPOSITION SELF MAPPING)))
     ((SUBTYPE-OF? TEST-VALUE-001 SGT-OPTIMIZE-LOGIC-DESCRIPTION)
      (CL:PROGN
       (CL:IF
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
           SYM-OPTIMIZE-LOGIC-EXTERNAL-VARIABLES NULL)
          NULL))
        (CL:LET* ((COPY (COPY-DESCRIPTION SELF MAPPING CL:T)))
         (INSERT-AT MAPPING SELF COPY) COPY)
        SELF)))
     ((SUBTYPE-OF? TEST-VALUE-001 SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)
      (CL:PROGN
       (CL:ERROR
        (NEW-STELLA-EXCEPTION "OOPS -- BUG IN 'copy-description'"))))
     (CL:T SELF)))))

;;; (DEFUN (MAPPED-VALUE-OF OBJECT) ...)

(CL:DEFUN MAPPED-VALUE-OF (SELF MAPPING CREATESKOLEM?)
  (CL:LET*
   ((VALUE
     (CL:IF (CL:NOT (CL:EQ MAPPING NULL)) (LOOKUP MAPPING SELF) NULL)))
   (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
    (CL:RETURN-FROM MAPPED-VALUE-OF VALUE))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
     (CL:OR (CL:NOT (VARIABLE? SELF))
      (DEFINED? (%PATTERN-VARIABLE.BOUND-TO-OFFSET SELF))))
    (CL:SETQ VALUE (ARGUMENT-BOUND-TO SELF))
    (CL:PROGN (CL:SETQ VALUE (VALUE-OF SELF))
     (CL:WHEN (VARIABLE? SELF) (CL:SETQ VALUE NULL))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ MAPPING NULL)) (CL:NOT (CL:EQ VALUE NULL)))
    (CL:WHEN (CL:NOT (ISA? SELF SGT-OPTIMIZE-LOGIC-PROPOSITION))
     (INSERT-AT MAPPING SELF VALUE))
    (CL:RETURN-FROM MAPPED-VALUE-OF VALUE))
   (CL:IF CREATESKOLEM?
    (CREATE-SKOLEM-FOR-UNMAPPED-VARIABLE SELF MAPPING) NULL)))

;;; (DEFUN (SINGLE-VALUED-PREDICATE? BOOLEAN) ...)

(CL:DEFUN SINGLE-VALUED-PREDICATE? (PROPOSITION)
  (CL:AND
   (CL:EQ (%PROPOSITION.KIND PROPOSITION) KWD-OPTIMIZE-PREDICATE)
   (SINGLE-VALUED-TERM?
    (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION)))))

;;; (DEFUN (BINARY-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN BINARY-PROPOSITION? (PROPOSITION)
  (CL:= (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION)) 2))

;;; (DEFUN (INHERIT-EQUIVALENT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN INHERIT-EQUIVALENT-PROPOSITION (SKOLEM VALUE)
  (CL:LET* ((VALUE-000 NULL))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALLOCATE-ITERATOR
       (UNFILTERED-DEPENDENT-PROPOSITIONS SKOLEM
        SGT-OPTIMIZE-PL-KERNEL-KB-EQUIVALENT))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ P (%ITERATOR.VALUE ITER-000))
     (CL:WHEN
      (CL:AND
       (CL:EQ (%PROPOSITION.OPERATOR P)
        SGT-OPTIMIZE-PL-KERNEL-KB-EQUIVALENT)
       (CL:OR
        (EQL?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
          0)
         VALUE)
        (EQL?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
          1)
         VALUE)))
      (CL:SETQ VALUE-000 P) (CL:RETURN))))
   (CL:LET* ((EQUIVALENTPROP VALUE-000))
    (CL:WHEN (CL:EQ EQUIVALENTPROP NULL)
     (CL:SETQ EQUIVALENTPROP
      (CREATE-PROPOSITION SYM-OPTIMIZE-LOGIC-EQUIVALENT 2))
     (CL:LET
      ((SELF
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS EQUIVALENTPROP)))
       (VALUE SKOLEM) (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET
      ((SELF
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS EQUIVALENTPROP)))
       (VALUE VALUE) (POSITION 1))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE)))
    EQUIVALENTPROP)))

;;; (DEFUN (INHERIT-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN INHERIT-FUNCTION-PROPOSITION (SELF MAPPING)
  (CL:LET*
   ((COPY NULL) (INPUTARGS NIL)
    (NOFINPUTARGS (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS SELF))))
    (ARGMAPSTO NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFINPUTARGS))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER)
     (ITER-000 1) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:WHEN (CL:<= I NOFINPUTARGS)
      (CL:SETQ ARGMAPSTO (MAPPED-VALUE-OF ARG MAPPING CL:NIL))
      (CL:WHEN (CL:EQ ARGMAPSTO NULL)
       (CL:RETURN-FROM INHERIT-FUNCTION-PROPOSITION NULL))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARGMAPSTO NIL))
        (CL:IF (CL:EQ INPUTARGS NIL) (CL:SETQ INPUTARGS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST INPUTARGS COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARGMAPSTO NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETQ COPY
    (CREATE-FUNCTION-PROPOSITION (%PROPOSITION.OPERATOR SELF)
     INPUTARGS))
   COPY))

;;; (DEFUN (EQUAL-UP-TO-SKOLEM-IDENTITY? BOOLEAN) ...)

(CL:DEFUN EQUAL-UP-TO-SKOLEM-IDENTITY? (INHERITEDARG BASEARG MAPPING)
  (CL:LET*
   ((INHERITEDVALUE
     (CL:IF (CL:NOT (CL:EQ MAPPING NULL))
      (MAPPED-VALUE-OF INHERITEDARG MAPPING CL:NIL) INHERITEDARG))
    (BASEVALUE (VALUE-OF BASEARG)))
   (CL:WHEN (EQL? INHERITEDVALUE BASEVALUE)
    (CL:RETURN-FROM EQUAL-UP-TO-SKOLEM-IDENTITY? CL:T))
   CL:NIL))

;;; (DEFUN (FIND-SIMILAR-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FIND-SIMILAR-PROPOSITION (PROPOSITION MAPPING)
  (CL:WHEN
   (CL:EQ (%PROPOSITION.KIND PROPOSITION) KWD-OPTIMIZE-CONSTANT)
   (CL:RETURN-FROM FIND-SIMILAR-PROPOSITION NULL))
  (CL:LET*
   ((KIND (%PROPOSITION.KIND PROPOSITION))
    (OPERATOR (%PROPOSITION.OPERATOR PROPOSITION)) (ARGMAPSTO NULL)
    (DEPENDENTSLIST NULL) (HASDISCOURAGEDARGUMENT? CL:NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:TAGBODY
      (CL:WHEN CL:NIL (CL:SETQ HASDISCOURAGEDARGUMENT? CL:T)
       (CL:GO :CONTINUE))
      (CL:LET* ((MAPSTO (MAPPED-VALUE-OF ARG MAPPING CL:NIL)))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ MAPSTO NULL))
         (INSTANCE-HAS-BACKLINKS? MAPSTO))
        (CL:SETQ ARGMAPSTO MAPSTO) (CL:RETURN)))
      :CONTINUE)
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:WHEN (CL:AND (CL:EQ ARGMAPSTO NULL) HASDISCOURAGEDARGUMENT?)
    (CL:LET*
     ((ARG NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS PROPOSITION))
      (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
     (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
      (CL:SETQ ARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
        INDEX-001))
      (CL:WHEN CL:NIL
       (CL:LET* ((MAPSTO (MAPPED-VALUE-OF ARG MAPPING CL:NIL)))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ MAPSTO NULL))
          (INSTANCE-HAS-BACKLINKS? MAPSTO))
         (CL:SETQ ARGMAPSTO MAPSTO) (CL:RETURN))))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
   (CL:WHEN (CL:EQ ARGMAPSTO NULL)
    (CL:RETURN-FROM FIND-SIMILAR-PROPOSITION NULL))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARGMAPSTO)
      SGT-OPTIMIZE-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:SETQ DEPENDENTSLIST
       (UNFILTERED-DEPENDENT-PROPOSITIONS ARGMAPSTO OPERATOR))
      (CL:COND
       ((CL:EQ KIND KWD-OPTIMIZE-FUNCTION)
        (CL:LET* ((VALUE-000 NULL))
         (CL:LET*
          ((P NULL) (ITER-000 (ALLOCATE-ITERATOR DEPENDENTSLIST)))
          (CL:LOOP WHILE (NEXT? ITER-000) DO
           (CL:SETQ P (%ITERATOR.VALUE ITER-000))
           (CL:LET* ((TEST-VALUE-000 CL:NIL))
            (CL:SETQ TEST-VALUE-000 (CL:EQ (%PROPOSITION.KIND P) KIND))
            (CL:WHEN TEST-VALUE-000
             (CL:SETQ TEST-VALUE-000
              (CL:EQ (%PROPOSITION.OPERATOR P) OPERATOR))
             (CL:WHEN TEST-VALUE-000
              (CL:LET* ((ALWAYS?-000 CL:T))
               (CL:LET*
                ((ARG1 NULL)
                 (ITER-001
                  (BUT-LAST (%PROPOSITION.ARGUMENTS PROPOSITION)))
                 (ARG2 NULL)
                 (ITER-002 (BUT-LAST (%PROPOSITION.ARGUMENTS P))))
                (CL:LOOP WHILE
                 (CL:AND (NEXT? ITER-001) (NEXT? ITER-002)) DO
                 (CL:SETQ ARG1 (%ITERATOR.VALUE ITER-001))
                 (CL:SETQ ARG2 (%ITERATOR.VALUE ITER-002))
                 (CL:WHEN
                  (CL:NOT
                   (EQUAL-UP-TO-SKOLEM-IDENTITY? ARG1 ARG2 MAPPING))
                  (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))))
               (CL:SETQ TEST-VALUE-000 ALWAYS?-000))))
            (CL:WHEN TEST-VALUE-000 (CL:SETQ VALUE-000 P)
             (CL:RETURN)))))
         (CL:LET* ((VALUE-001 VALUE-000))
          (CL:RETURN-FROM FIND-SIMILAR-PROPOSITION VALUE-001))))
       (CL:T
        (CL:LET* ((VALUE-002 NULL))
         (CL:LET*
          ((P NULL) (ITER-003 (ALLOCATE-ITERATOR DEPENDENTSLIST)))
          (CL:LOOP WHILE (NEXT? ITER-003) DO
           (CL:SETQ P (%ITERATOR.VALUE ITER-003))
           (CL:LET* ((TEST-VALUE-001 CL:NIL))
            (CL:SETQ TEST-VALUE-001 (CL:EQ (%PROPOSITION.KIND P) KIND))
            (CL:WHEN TEST-VALUE-001
             (CL:SETQ TEST-VALUE-001
              (CL:EQ (%PROPOSITION.OPERATOR P) OPERATOR))
             (CL:WHEN TEST-VALUE-001
              (CL:LET* ((ALWAYS?-001 CL:T))
               (CL:LET*
                ((ARG1 NULL)
                 (VECTOR-002 (%PROPOSITION.ARGUMENTS PROPOSITION))
                 (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002))
                 (ARG2 NULL) (VECTOR-003 (%PROPOSITION.ARGUMENTS P))
                 (INDEX-003 0) (LENGTH-003 (LENGTH VECTOR-003)))
                (CL:DECLARE
                 (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002 INDEX-003
                  LENGTH-003))
                (CL:LOOP WHILE
                 (CL:AND (CL:< INDEX-002 LENGTH-002)
                  (CL:< INDEX-003 LENGTH-003))
                 DO
                 (CL:SETQ ARG1
                  (CL:AREF
                   (CL:THE CL:SIMPLE-VECTOR
                    (%VECTOR.THE-ARRAY VECTOR-002))
                   INDEX-002))
                 (CL:SETQ ARG2
                  (CL:AREF
                   (CL:THE CL:SIMPLE-VECTOR
                    (%VECTOR.THE-ARRAY VECTOR-003))
                   INDEX-003))
                 (CL:WHEN
                  (CL:NOT
                   (EQUAL-UP-TO-SKOLEM-IDENTITY? ARG1 ARG2 MAPPING))
                  (CL:SETQ ALWAYS?-001 CL:NIL) (CL:RETURN))
                 (CL:SETQ INDEX-002 (CL:1+ INDEX-002))
                 (CL:SETQ INDEX-003 (CL:1+ INDEX-003))))
               (CL:SETQ TEST-VALUE-001 ALWAYS?-001))))
            (CL:WHEN TEST-VALUE-001 (CL:SETQ VALUE-002 P)
             (CL:RETURN)))))
         (CL:LET* ((VALUE-003 VALUE-002))
          (CL:RETURN-FROM FIND-SIMILAR-PROPOSITION VALUE-003)))))))
    (CL:T))
   NULL))

;;; (DEFUN (INHERIT-PROPOSITION-ARGUMENT OBJECT) ...)

(CL:DEFUN INHERIT-PROPOSITION-ARGUMENT (ARGUMENT PARENT MAPPING)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARGUMENT)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-OPTIMIZE-LOGIC-PROPOSITION)
     (CL:PROGN (INHERIT-PROPOSITION ARGUMENT MAPPING)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-OPTIMIZE-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:IF (NAMED-DESCRIPTION? ARGUMENT) ARGUMENT
       (COPY-DESCRIPTION ARGUMENT MAPPING CL:T))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN (MAPPED-VALUE-OF ARGUMENT MAPPING CL:T)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF
       (CL:OR (DESCRIPTION-MODE?)
        (CL:AND (CL:EQ (%PROPOSITION.KIND PARENT) KWD-OPTIMIZE-ISA)
         (CL:EQ (%PROPOSITION.OPERATOR PARENT) ARGUMENT)))
       ARGUMENT
       (CL:LET* ((VALUE (%SURROGATE.SURROGATE-VALUE ARGUMENT)))
        (CL:IF (RELATION? VALUE) (SURROGATE-TO-DESCRIPTION ARGUMENT)
         VALUE)))))
    (CL:T ARGUMENT))))

;;; (DEFUN (ERADICATE-HOLDS-PROPOSITION PROPOSITION) ...)

(CL:DEFUN ERADICATE-HOLDS-PROPOSITION (SELF)
  (CL:WHEN
   (CL:AND
    (CL:EQ (%PROPOSITION.OPERATOR SELF)
     SGT-OPTIMIZE-PL-KERNEL-KB-HOLDS)
    (CL:NOT
     (ISA?
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
       0)
      SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)))
   (NORMALIZE-PREDICATE-PROPOSITION SELF)
   (CL:LET* ((DUPLICATE (FIND-SIMILAR-PROPOSITION SELF NULL)))
    (CL:WHEN (CL:NOT (CL:EQ DUPLICATE NULL))
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER)
       (ITER-000 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ I ITER-000)
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS DUPLICATE)))
         (VALUE ARG) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
       (CL:SETQ ITER-000 (CL:1+ ITER-000))))
     (FREE SELF)
     (CL:RETURN-FROM ERADICATE-HOLDS-PROPOSITION DUPLICATE))))
  SELF)

;;; (DEFUN (INHERIT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN INHERIT-PROPOSITION (SELF MAPPING)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FORALL)
      (CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-EXISTS))
     (CL:LET* ((*EVALUATIONMODE* KWD-OPTIMIZE-DESCRIPTION))
      (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
      (CL:RETURN-FROM INHERIT-PROPOSITION
       (COPY-PROPOSITION SELF MAPPING))))
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FUNCTION)
     (CL:LET*
      ((VALUE
        (INHERIT-PROPOSITION-ARGUMENT
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
          (CL:THE CL:FIXNUM
           (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS SELF)))))
         SELF MAPPING))
       (COPY NULL))
      (CL:WHEN (CL:EQ VALUE NULL)
       (CL:RETURN-FROM INHERIT-PROPOSITION NULL))
      (CL:SETQ COPY (FIND-SIMILAR-PROPOSITION SELF MAPPING))
      (CL:WHEN (CL:EQ COPY NULL)
       (CL:SETQ COPY (INHERIT-FUNCTION-PROPOSITION SELF MAPPING))
       (CL:SETQ COPY (ERADICATE-HOLDS-PROPOSITION COPY)))
      (CL:IF
       (EQL?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS COPY)))
         (CL:THE CL:FIXNUM
          (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS COPY)))))
        VALUE)
       (CL:SETQ COPY TRUE-PROPOSITION)
       (CL:SETQ COPY
        (INHERIT-EQUIVALENT-PROPOSITION
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS COPY)))
          (CL:THE CL:FIXNUM
           (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS COPY)))))
         VALUE)))
      (INSERT-AT MAPPING SELF COPY)
      (CL:RETURN-FROM INHERIT-PROPOSITION COPY)))
    (CL:T)))
  (CL:LET* ((MATCHINGPROPOSITION (LOOKUP MAPPING SELF)))
   (CL:WHEN (CL:NOT (CL:EQ MATCHINGPROPOSITION NULL))
    (CL:RETURN-FROM INHERIT-PROPOSITION MATCHINGPROPOSITION))
   (CL:WHEN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? SELF))
    (CL:LET*
     ((BINDING
       (LOOKUP MAPPING
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
         0))))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ BINDING NULL)) (CL:NOT (SKOLEM? BINDING)))
      (CL:RETURN-FROM INHERIT-PROPOSITION TRUE-PROPOSITION))))
   (CL:WHEN (CL:NOT (CL:EQ MATCHINGPROPOSITION NULL))
    (INSERT-AT MAPPING SELF MATCHINGPROPOSITION)
    (CL:RETURN-FROM INHERIT-PROPOSITION MATCHINGPROPOSITION)))
  (CL:LET*
   ((OPERATOR (%PROPOSITION.OPERATOR SELF)) (ARGUMENTSMAPTO (NEW-LIST))
    (COPY NULL) (ARGMAPSTO NULL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ ARGMAPSTO
      (INHERIT-PROPOSITION-ARGUMENT ARG SELF MAPPING))
     (CL:WHEN (CL:EQ ARGMAPSTO NULL)
      (CL:RETURN-FROM INHERIT-PROPOSITION NULL))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARGMAPSTO NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST ARGUMENTSMAPTO) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST ARGUMENTSMAPTO) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST
         (%LIST.THE-CONS-LIST ARGUMENTSMAPTO) COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARGMAPSTO NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:SETQ COPY (CREATE-PROPOSITION SYM-OPTIMIZE-LOGIC-CONSTANT 0))
   (CL:SETF (%PROPOSITION.KIND COPY) (%PROPOSITION.KIND SELF))
   (CL:SETF (%PROPOSITION.OPERATOR COPY) OPERATOR)
   (CL:SETF (%PROPOSITION.ARGUMENTS COPY)
    (COPY-LIST-TO-ARGUMENTS-VECTOR ARGUMENTSMAPTO))
   (CL:WHEN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? SELF))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS COPY)
     SYM-OPTIMIZE-LOGIC-VARIABLE-TYPE? TRUE-WRAPPER NULL))
   (CL:SETQ COPY (ERADICATE-HOLDS-PROPOSITION COPY))
   (INSERT-AT MAPPING SELF COPY) COPY))

;;; (DEFUN (CREATE-SKOLEM-FOR-UNMAPPED-VARIABLE SKOLEM) ...)

(CL:DEFUN CREATE-SKOLEM-FOR-UNMAPPED-VARIABLE (VARIABLE MAPPING)
  (CL:LET* ((SKOLEM (LOOKUP MAPPING VARIABLE)))
   (CL:WHEN (CL:NOT (CL:EQ SKOLEM NULL))
    (CL:RETURN-FROM CREATE-SKOLEM-FOR-UNMAPPED-VARIABLE SKOLEM))
   (CL:SETQ SKOLEM
    (CREATE-VARIABLE-OR-SKOLEM (%PATTERN-VARIABLE.SKOLEM-TYPE VARIABLE)
     NULL))
   (INSERT-AT MAPPING VARIABLE SKOLEM) SKOLEM))

;;; (DEFUN (INHERIT-AS-TOP-LEVEL-PROPOSITION (CONS OF PROPOSITION)) ...)

(CL:DEFUN INHERIT-AS-TOP-LEVEL-PROPOSITION (PROPOSITION MAPPING)
  (CL:LET* ((RESULTLIST NIL))
   (CL:WHEN (CL:EQ MAPPING NULL)
    (CL:SETQ MAPPING (NEW-KEY-VALUE-LIST)))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-AND)
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ RESULTLIST
         (CONS (INHERIT-PROPOSITION ARG MAPPING) RESULTLIST))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
     ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-EXISTS)
      (CL:LET*
       ((VBL NULL)
        (VECTOR-001
         (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
          SYM-OPTIMIZE-LOGIC-IO-VARIABLES NULL))
        (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ VBL
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CREATE-SKOLEM-FOR-UNMAPPED-VARIABLE VBL MAPPING)
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      (CL:SETQ RESULTLIST
       (CONS
        (INHERIT-PROPOSITION
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
          0)
         MAPPING)
        RESULTLIST)))
     (CL:T
      (CL:SETQ RESULTLIST
       (CONS (INHERIT-PROPOSITION PROPOSITION MAPPING) RESULTLIST)))))
   (FREE MAPPING)
   (CL:LET* ((P NULL) (ITER-000 RESULTLIST))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ P (%%VALUE ITER-000))
     (NORMALIZE-TOP-LEVEL-PROPOSITION P NULL)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   RESULTLIST))

;;; (DEFUN (MAP-AND-ENQUEUE-VARIABLE? BOOLEAN) ...)

(CL:DEFUN MAP-AND-ENQUEUE-VARIABLE? (VARIABLE LOCALVALUE MAPPING QUEUE)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE VARIABLE)
     SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE)
    (CL:PROGN
     (CL:LET* ((MAPSTOVALUE (LOOKUP MAPPING VARIABLE)))
      (CL:WHEN (CL:EQ MAPSTOVALUE NULL)
       (CL:SETQ MAPSTOVALUE (NATIVE-VALUE-OF VARIABLE))
       (CL:WHEN (CL:NOT (CL:EQ MAPSTOVALUE NULL))
        (INSERT-AT MAPPING VARIABLE MAPSTOVALUE)))
      (CL:COND
       ((CL:NOT (CL:EQ MAPSTOVALUE NULL))
        (CL:RETURN-FROM MAP-AND-ENQUEUE-VARIABLE?
         (CL:OR (CL:EQ LOCALVALUE NULL) (EQL? MAPSTOVALUE LOCALVALUE)
          (SKOLEM? LOCALVALUE) (SKOLEM? MAPSTOVALUE))))
       ((CL:NOT (CL:EQ LOCALVALUE NULL))
        (INSERT-AT MAPPING VARIABLE LOCALVALUE)
        (CL:WHEN (ISA? LOCALVALUE SGT-OPTIMIZE-LOGIC-LOGIC-OBJECT)
         (PUSH QUEUE VARIABLE)))
       (CL:T
        (CL:LET*
         ((SKOLEM
           (CREATE-VARIABLE-OR-SKOLEM
            (%PATTERN-VARIABLE.SKOLEM-TYPE VARIABLE) NULL)))
         (INSERT-AT MAPPING VARIABLE SKOLEM)
         (PUSH QUEUE VARIABLE)))))))
   (CL:T))
  CL:T)

;;; (DEFUN COLLECT-STRUCTURAL-FUNCTIONS ...)

(CL:DEFUN COLLECT-STRUCTURAL-FUNCTIONS (PROPOSITION STRUCTURALFUNCTIONS)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-FUNCTION)
     (INSERT STRUCTURALFUNCTIONS PROPOSITION))
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-PREDICATE)
     (CL:WHEN (SINGLE-VALUED-PREDICATE? PROPOSITION)
      (INSERT STRUCTURALFUNCTIONS PROPOSITION)))
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-AND)
     (CL:LET*
      ((CONJUNCT NULL)
       (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION)) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ CONJUNCT
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (COLLECT-STRUCTURAL-FUNCTIONS CONJUNCT STRUCTURALFUNCTIONS)
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
    ((CL:EQ TEST-VALUE-000 KWD-OPTIMIZE-EXISTS)
     (COLLECT-STRUCTURAL-FUNCTIONS
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       0)
      STRUCTURALFUNCTIONS))
    (CL:T))))

;;; (DEFUN (MAP-FUNCTIONAL-VALUE? BOOLEAN) ...)

(CL:DEFUN MAP-FUNCTIONAL-VALUE? (PROPOSITION MAPPING QUEUE)
  (CL:LET* ((COPY (FIND-SIMILAR-PROPOSITION PROPOSITION MAPPING)))
   (CL:WHEN
    (CL:AND (CL:EQ COPY NULL)
     (CL:EQ (%PROPOSITION.KIND PROPOSITION) KWD-OPTIMIZE-FUNCTION))
    (CL:SETQ COPY (INHERIT-FUNCTION-PROPOSITION PROPOSITION MAPPING)))
   (CL:WHEN (CL:NOT (CL:EQ COPY NULL))
    (CL:LET*
     ((LOCALFUNCTIONALVALUE
       (VALUE-OF
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS COPY)))
         (CL:THE CL:FIXNUM
          (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS COPY))))))))
     (CL:RETURN-FROM MAP-FUNCTIONAL-VALUE?
      (MAP-AND-ENQUEUE-VARIABLE?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
        (CL:THE CL:FIXNUM
         (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION)))))
       LOCALFUNCTIONALVALUE MAPPING QUEUE))))
   CL:T))

;;; (DEFUN (INHERIT-DESCRIPTION-PROPOSITIONS (CONS OF PROPOSITION)) ...)

(CL:DEFUN INHERIT-DESCRIPTION-PROPOSITIONS (ARGUMENTS DESCRIPTION)
  (CL:LET*
   ((MAPPING (NEW-KEY-VALUE-LIST)) (VARIABLEQUEUE (NEW-LIST))
    (STRUCTURALFUNCTIONS (NEW-LIST)))
   (CL:LET*
    ((V NULL) (VECTOR-000 (%DESCRIPTION.IO-VARIABLES DESCRIPTION))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (ARG NULL)
     (VECTOR-001 ARGUMENTS) (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
     DO
     (CL:SETQ V
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
       INDEX-001))
     (CL:WHEN
      (CL:NOT (MAP-AND-ENQUEUE-VARIABLE? V ARG MAPPING VARIABLEQUEUE))
      (CL:RETURN-FROM INHERIT-DESCRIPTION-PROPOSITIONS NIL))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
   (CL:LET*
    ((V NULL)
     (VECTOR-002 (%DESCRIPTION.INTERNAL-VARIABLES DESCRIPTION))
     (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
    (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
     (CL:SETQ V
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
       INDEX-002))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS V NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST VARIABLEQUEUE) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST VARIABLEQUEUE) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST
         (%LIST.THE-CONS-LIST VARIABLEQUEUE) COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS V NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
   (COLLECT-STRUCTURAL-FUNCTIONS (%DESCRIPTION.PROPOSITION DESCRIPTION)
    STRUCTURALFUNCTIONS)
   (CL:LOOP (CL:WHEN (EMPTY? VARIABLEQUEUE) (CL:RETURN))
    (CL:LET* ((VARIABLE (POP VARIABLEQUEUE)))
     (CL:LET*
      ((P NULL)
       (ITER-000
        (ALLOCATE-ITERATOR
         (UNFILTERED-DEPENDENT-PROPOSITIONS VARIABLE NULL))))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ P (%ITERATOR.VALUE ITER-000))
       (CL:WHEN (MEMBER? STRUCTURALFUNCTIONS P)
        (CL:WHEN
         (CL:NOT (MAP-FUNCTIONAL-VALUE? P MAPPING VARIABLEQUEUE))
         (CL:RETURN-FROM INHERIT-DESCRIPTION-PROPOSITIONS NIL)))))))
   (CL:LET*
    ((PROPOSITIONS
      (INHERIT-AS-TOP-LEVEL-PROPOSITION
       (%DESCRIPTION.PROPOSITION DESCRIPTION) MAPPING)))
    (CL:LET* ((IT (ALLOCATE-ITERATOR PROPOSITIONS)))
     (CL:LOOP WHILE (NEXT? IT) DO
      (VALUE-SETTER IT
       (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS (%CONS-ITERATOR.VALUE IT)
        CL:NIL))))
    PROPOSITIONS)))

;;; (DEFUN INHERIT-UNNAMED-DESCRIPTION ...)

(CL:DEFUN INHERIT-UNNAMED-DESCRIPTION (SELF DESCRIPTION DEFAULTTRUE?)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-OPTIMIZE-STELLA-VECTOR)
     (CL:PROGN
      (VECTOR.INHERIT-UNNAMED-DESCRIPTION SELF DESCRIPTION
       DEFAULTTRUE?)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-OPTIMIZE-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (LOGIC-OBJECT.INHERIT-UNNAMED-DESCRIPTION SELF DESCRIPTION
       DEFAULTTRUE?)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN VECTOR.INHERIT-UNNAMED-DESCRIPTION ...)

(CL:DEFUN VECTOR.INHERIT-UNNAMED-DESCRIPTION (ARGUMENTS DESCRIPTION DEFAULTTRUE?)
  (CL:LET*
   ((PROP NULL)
    (ITER-000 (INHERIT-DESCRIPTION-PROPOSITIONS ARGUMENTS DESCRIPTION))
    (COLLECT-000 NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ PROP (%%VALUE ITER-000))
    (CL:TAGBODY
     (CL:WHEN (CL:NOT (TRUE? PROP))
      (ASSIGN-TRUTH-VALUE PROP
       (CL:IF DEFAULTTRUE? DEFAULT-TRUE-TRUTH-VALUE TRUE-TRUTH-VALUE))
      (CL:WHEN (CL:EQ *COLLECTFORWARDPROPOSITIONS* NULL)
       (CL:GO :CONTINUE))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS PROP NIL))
        (CL:IF (CL:EQ *COLLECTFORWARDPROPOSITIONS* NIL)
         (CL:SETQ *COLLECTFORWARDPROPOSITIONS* COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST *COLLECTFORWARDPROPOSITIONS*
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS PROP NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     :CONTINUE)
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN LOGIC-OBJECT.INHERIT-UNNAMED-DESCRIPTION ...)

(CL:DEFUN LOGIC-OBJECT.INHERIT-UNNAMED-DESCRIPTION (INSTANCE DESCRIPTION DEFAULTTRUE?)
  (CL:LET* ((VECTOR (NEW-VECTOR 1)))
   (CL:LET
    ((SELF (%VECTOR.THE-ARRAY VECTOR)) (VALUE INSTANCE) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (INHERIT-UNNAMED-DESCRIPTION VECTOR DESCRIPTION DEFAULTTRUE?)))

;;; (DEFUN INHERIT-DESCRIPTION ...)

(CL:DEFUN INHERIT-DESCRIPTION (ARGUMENTS DESCRIPTION DEFAULTTRUE?)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE DESCRIPTION)
     SGT-OPTIMIZE-LOGIC-NAMED-DESCRIPTION)
    (CL:PROGN
     (CL:LET*
      ((PROP
        (UPDATE-TUPLE
         (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE DESCRIPTION)
         (CONSIFY ARGUMENTS) KWD-OPTIMIZE-CONCEIVE)))
      (CL:WHEN (CL:NOT (TRUE? PROP))
       (CL:WHEN (CL:NOT (CL:EQ *COLLECTFORWARDPROPOSITIONS* NULL))
        (CL:SETQ *COLLECTFORWARDPROPOSITIONS*
         (CONS PROP *COLLECTFORWARDPROPOSITIONS*)))
       (ASSIGN-TRUTH-VALUE PROP
        (CL:IF DEFAULTTRUE? DEFAULT-TRUE-TRUTH-VALUE
         TRUE-TRUTH-VALUE))))))
   (CL:T
    (INHERIT-UNNAMED-DESCRIPTION ARGUMENTS DESCRIPTION DEFAULTTRUE?))))

(CL:DEFUN HELP-STARTUP-OPTIMIZE1 ()
  (CL:PROGN
   (CL:SETQ SGT-OPTIMIZE-LOGIC-GOAL-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-RECORD" NULL 1))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-GENERATOR-GOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERATOR-GOALS" NULL 0))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-OTHER-GOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHER-GOALS" NULL 0))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-EXTERNAL-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTERNAL-VARIABLES" NULL 0))
   (CL:SETQ SGT-OPTIMIZE-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-OPTIMIZE-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SGT-OPTIMIZE-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ KWD-OPTIMIZE-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-PERMUTATION-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PERMUTATION-TABLE" NULL 0))
   (CL:SETQ SGT-OPTIMIZE-PL-KERNEL-KB-COMPUTED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPUTED"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-OPTIMIZE-PL-KERNEL-KB-RELATION-CONSTRAINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-CONSTRAINT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-OPTIMIZE-PL-KERNEL-KB-ABSTRACT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-OPTIMIZE-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-OPTIMIZER-GOAL-RECORDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTIMIZER-GOAL-RECORDS" NULL 0))
   (CL:SETQ KWD-OPTIMIZE-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-OPTIMIZE-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ KWD-OPTIMIZE-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ KWD-OPTIMIZE-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-OPTIMIZE-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-OPTIMIZE-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ KWD-OPTIMIZE-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-UNIQUENESSVECTORS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNIQUENESSVECTORS" NULL 0))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-INVERSE-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INVERSE-DESCRIPTION" NULL 0))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-INDEXING-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INDEXING-VECTOR" NULL 0))
   (CL:SETQ SGT-OPTIMIZE-PL-KERNEL-KB-OBSERVED-CARDINALITY-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBSERVED-CARDINALITY-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-OPTIMIZE-STELLA-INTEGER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-OPTIMIZE-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-OPTIMIZE-PL-KERNEL-KB-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-OPTIMIZE-OPTIMIZER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTIMIZER" NULL 2))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-BEST-GOAL-SEQUENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BEST-GOAL-SEQUENCE" NULL 0))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-BEST-COST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BEST-COST" NULL 0))
   (CL:SETQ KWD-OPTIMIZE-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ KWD-OPTIMIZE-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ KWD-OPTIMIZE-STATIC-WITH-CLUSTERING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STATIC-WITH-CLUSTERING" NULL 2))
   (CL:SETQ KWD-OPTIMIZE-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ KWD-OPTIMIZE-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-OPTIMIZE-BOUND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOUND" NULL 2))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-RESIDUE-GOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RESIDUE-GOALS" NULL 0))
   (CL:SETQ KWD-OPTIMIZE-PATTERN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN" NULL 2))
   (CL:SETQ KWD-OPTIMIZE-DYNAMIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC" NULL 2))
   (CL:SETQ KWD-OPTIMIZE-DYNAMIC-WITH-CLUSTERING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC-WITH-CLUSTERING" NULL 2))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-DONT-OPTIMIZE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-OPTIMIZE?" NULL 0))
   (CL:SETQ KWD-OPTIMIZE-NONE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NONE" NULL 2))
   (CL:SETQ SGT-OPTIMIZE-PL-KERNEL-KB-CUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CUT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-OPTIMIZE-PL-KERNEL-KB-BOUND-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOUND-VARIABLES"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-OPTIMIZE-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-OPTIMIZE-PL-KERNEL-KB-INSTANCE-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INSTANCE-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-OPTIMIZE-PL-KERNEL-KB-TOTAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOTAL"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-OPTIMIZE-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION" NULL 2))
   (CL:SETQ SGT-OPTIMIZE-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-OPTIMIZE-REALISTIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REALISTIC" NULL 2))
   (CL:SETQ KWD-OPTIMIZE-FLAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLAT" NULL 2))
   (CL:SETQ SGT-OPTIMIZE-STELLA-CS-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CS-VALUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-OPTIMIZE-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 2))
   (CL:SETQ SYM-OPTIMIZE-STELLA-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-WEIGHT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WEIGHT" NULL 0))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-VARIABLE-TYPE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE?" NULL 0))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-DESCRIPTIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTIVE?" NULL 0))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-ANNOTATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANNOTATIONS" NULL 0))))

(CL:DEFUN HELP-STARTUP-OPTIMIZE2 ()
  (CL:PROGN
   (CL:SETQ SGT-OPTIMIZE-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SGT-OPTIMIZE-PL-KERNEL-KB-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 0))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 0))
   (CL:SETQ SGT-OPTIMIZE-STELLA-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-OPTIMIZE-CONCEIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEIVE" NULL 2))
   (CL:SETQ SYM-OPTIMIZE-LOGIC-STARTUP-OPTIMIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-OPTIMIZE" NULL 0))
   (CL:SETQ SYM-OPTIMIZE-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-OPTIMIZE3 ()
  (CL:PROGN
   (CL:SETQ V-0-0
    (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR
     (LIST (WRAP-INTEGER 0) (WRAP-INTEGER 0))))
   (CL:SETQ V-1-0
    (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR
     (LIST (WRAP-INTEGER 1) (WRAP-INTEGER 0))))
   (CL:SETQ V-0-1
    (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR
     (LIST (WRAP-INTEGER 0) (WRAP-INTEGER 1))))
   (CL:SETQ V-1-1
    (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR
     (LIST (WRAP-INTEGER 1) (WRAP-INTEGER 1))))
   (CL:SETQ V-1-0-AND-V-0-1 (LIST V-1-0 V-0-1))
   (CL:SETQ V-1-0-SINGLETON (LIST V-1-0))
   (CL:SETQ V-0-1-SINGLETON (LIST V-0-1))
   (CL:SETQ *QUERY-OPTIMIZATION-STRATEGY* KWD-OPTIMIZE-DYNAMIC)))

(CL:DEFUN HELP-STARTUP-OPTIMIZE4 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "VARIABLE-BOUND?"
    "(DEFUN (VARIABLE-BOUND? BOOLEAN) ((VARIABLE PATTERN-VARIABLE)))"
    (CL:FUNCTION VARIABLE-BOUND?) NULL)
   (DEFINE-FUNCTION-OBJECT "ARGUMENT-BOUND?"
    "(DEFUN (ARGUMENT-BOUND? BOOLEAN) ((ARGUMENT OBJECT)))"
    (CL:FUNCTION ARGUMENT-BOUND?) NULL)
   (DEFINE-FUNCTION-OBJECT "QUANTIFIED-ARGUMENT-BOUND?"
    "(DEFUN (QUANTIFIED-ARGUMENT-BOUND? BOOLEAN) ((ARGUMENT OBJECT) (QUANTIFIEDVARS LIST)))"
    (CL:FUNCTION QUANTIFIED-ARGUMENT-BOUND?) NULL)
   (DEFINE-FUNCTION-OBJECT "UNBOUND-VARIABLE?"
    "(DEFUN (UNBOUND-VARIABLE? BOOLEAN) ((ARGUMENT OBJECT)))"
    (CL:FUNCTION UNBOUND-VARIABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "HAS-DISJUNCTION?"
    "(DEFUN (HAS-DISJUNCTION? BOOLEAN) ((GOAL PROPOSITION)))"
    (CL:FUNCTION HAS-DISJUNCTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "MODAL-GOAL?"
    "(DEFUN (MODAL-GOAL? BOOLEAN) ((GOAL PROPOSITION)))"
    (CL:FUNCTION MODAL-GOAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "HAS-INVERSIONS?"
    "(DEFUN (HAS-INVERSIONS? BOOLEAN) ((GOAL PROPOSITION)))"
    (CL:FUNCTION HAS-INVERSIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTED-TERM?"
    "(DEFUN (COMPUTED-TERM? BOOLEAN) ((SELF DESCRIPTION)))"
    (CL:FUNCTION COMPUTED-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTED-CONSTRAINT?"
    "(DEFUN (COMPUTED-CONSTRAINT? BOOLEAN) ((SELF DESCRIPTION)))"
    (CL:FUNCTION COMPUTED-CONSTRAINT?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTED-PREDICATE?"
    "(DEFUN (COMPUTED-PREDICATE? BOOLEAN) ((GOAL PROPOSITION)))"
    (CL:FUNCTION COMPUTED-PREDICATE?) NULL)
   (DEFINE-FUNCTION-OBJECT "SIMULATE-CREATE-CHOICE-POINT"
    "(DEFUN (SIMULATE-CREATE-CHOICE-POINT INTEGER) ())"
    (CL:FUNCTION SIMULATE-CREATE-CHOICE-POINT) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATION-SUPPORTS-EXTENSION?"
    "(DEFUN (RELATION-SUPPORTS-EXTENSION? BOOLEAN) ((SELF NAMED-DESCRIPTION)))"
    (CL:FUNCTION RELATION-SUPPORTS-EXTENSION?) NULL)
   (DEFINE-FUNCTION-OBJECT "GENERATOR-COLLECTION?"
    "(DEFUN (GENERATOR-COLLECTION? BOOLEAN) ((COLLECTION OBJECT)))"
    (CL:FUNCTION GENERATOR-COLLECTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-OPTIMIZER-GOAL-RECORDS"
    "(DEFUN INITIALIZE-OPTIMIZER-GOAL-RECORDS ((SIZE INTEGER)))"
    (CL:FUNCTION INITIALIZE-OPTIMIZER-GOAL-RECORDS) NULL)
   (DEFINE-FUNCTION-OBJECT "GOAL-RECORD"
    "(DEFUN (GOAL-RECORD GOAL-RECORD) ((VARIABLE PATTERN-VARIABLE)))"
    (CL:FUNCTION GOAL-RECORD) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-DISTRIBUTE-GOAL"
    "(DEFUN HELP-DISTRIBUTE-GOAL ((ARGUMENT OBJECT) (PARENTGOAL PROPOSITION) (GENERATOR? BOOLEAN)))"
    (CL:FUNCTION HELP-DISTRIBUTE-GOAL) NULL)
   (DEFINE-FUNCTION-OBJECT "DISTRIBUTE-OPEN-GOAL"
    "(DEFUN DISTRIBUTE-OPEN-GOAL ((GOAL PROPOSITION)))"
    (CL:FUNCTION DISTRIBUTE-OPEN-GOAL) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT NAMED-DESCRIPTION UNIQUENESSVECTORS :TYPE (LIST OF BOOLEAN-VECTOR) :DOCUMENTATION \"Caches a list of vectors representing keys
for the slot/relation.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT NAMED-DESCRIPTION INDEXING-VECTOR :TYPE BOOLEAN-VECTOR :DOCUMENTATION \"Caches a vector indicating which arguments
of a slot/relation have backlinks to referencing propositions.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "GET-BINARY-UNIQUENESS-VECTORS"
    "(DEFUN (GET-BINARY-UNIQUENESS-VECTORS (LIST OF BOOLEAN-VECTOR)) ((SELF NAMED-DESCRIPTION)))"
    (CL:FUNCTION GET-BINARY-UNIQUENESS-VECTORS) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-UNIQUENESS-VECTORS"
    "(DEFUN (GET-UNIQUENESS-VECTORS (LIST OF BOOLEAN-VECTOR)) ((SELF NAMED-DESCRIPTION)))"
    (CL:FUNCTION GET-UNIQUENESS-VECTORS) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-BINARY-INDEXING-VECTOR"
    "(DEFUN (GET-BINARY-INDEXING-VECTOR BOOLEAN-VECTOR) ((SELF NAMED-DESCRIPTION)))"
    (CL:FUNCTION GET-BINARY-INDEXING-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-INDEXING-VECTOR"
    "(DEFUN (GET-INDEXING-VECTOR BOOLEAN-VECTOR) ((SELF NAMED-DESCRIPTION)))"
    (CL:FUNCTION GET-INDEXING-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-OBSERVED-CARDINALITY"
    "(DEFUN UPDATE-OBSERVED-CARDINALITY ((SELF NAMED-DESCRIPTION) (CARDINALITY INTEGER)))"
    (CL:FUNCTION UPDATE-OBSERVED-CARDINALITY) NULL)
   (DEFINE-FUNCTION-OBJECT "ACCESS-OBSERVED-CARDINALITY"
    "(DEFUN (ACCESS-OBSERVED-CARDINALITY INTEGER) ((SELF DESCRIPTION)))"
    (CL:FUNCTION ACCESS-OBSERVED-CARDINALITY) NULL)
   (DEFINE-FUNCTION-OBJECT "ESTIMATE-CARDINALITY-OF-EXTENSION"
    "(DEFUN (ESTIMATE-CARDINALITY-OF-EXTENSION COST-ESTIMATE) ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION ESTIMATE-CARDINALITY-OF-EXTENSION) NULL)
   (DEFINE-FUNCTION-OBJECT "ESTIMATE-MEMBER-OF-GOAL-FANOUT"
    "(DEFUN (ESTIMATE-MEMBER-OF-GOAL-FANOUT COST-ESTIMATE) ((GOAL PROPOSITION)))"
    (CL:FUNCTION ESTIMATE-MEMBER-OF-GOAL-FANOUT) NULL)
   (DEFINE-FUNCTION-OBJECT "ESTIMATE-PREDICATE-GOAL-FANOUT"
    "(DEFUN (ESTIMATE-PREDICATE-GOAL-FANOUT COST-ESTIMATE) ((GOAL PROPOSITION)))"
    (CL:FUNCTION ESTIMATE-PREDICATE-GOAL-FANOUT) NULL)
   (DEFINE-FUNCTION-OBJECT "ESTIMATE-GOAL-COST"
    "(DEFUN (ESTIMATE-GOAL-COST COST-ESTIMATE) ((GOAL PROPOSITION)))"
    (CL:FUNCTION ESTIMATE-GOAL-COST) NULL)
   (DEFINE-FUNCTION-OBJECT "ESTIMATE-GOAL-FANOUT"
    "(DEFUN (ESTIMATE-GOAL-FANOUT COST-ESTIMATE) ((GOAL PROPOSITION)))"
    (CL:FUNCTION ESTIMATE-GOAL-FANOUT) NULL)
   (DEFINE-FUNCTION-OBJECT "CHEAPEST-GENERATOR-GOAL"
    "(DEFUN (CHEAPEST-GENERATOR-GOAL PROPOSITION COST-ESTIMATE COST-ESTIMATE) ((VARIABLE PATTERN-VARIABLE)))"
    (CL:FUNCTION CHEAPEST-GENERATOR-GOAL) NULL)
   (DEFINE-FUNCTION-OBJECT "PROPAGATE-SINGLE-VALUED-CONSTRAINTS"
    "(DEFUN PROPAGATE-SINGLE-VALUED-CONSTRAINTS ((GOAL PROPOSITION) (GOALSEQUENCE (LIST OF PROPOSITION))))"
    (CL:FUNCTION PROPAGATE-SINGLE-VALUED-CONSTRAINTS) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-CLOSED-GOALS"
    "(DEFUN COLLECT-CLOSED-GOALS ((GOALS (LIST OF PROPOSITION)) (GOALSEQUENCE (LIST OF PROPOSITION))))"
    (CL:FUNCTION COLLECT-CLOSED-GOALS) NULL)
   (DEFINE-FUNCTION-OBJECT
    "SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS"
    "(DEFUN SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS ((VARIABLE PATTERN-VARIABLE) (GOALSEQUENCE (LIST OF PROPOSITION))))"
    (CL:FUNCTION SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS)
    NULL)
   (DEFINE-FUNCTION-OBJECT "BIND-ALL-VARIABLES-IN-GENERATOR-GOAL"
    "(DEFUN BIND-ALL-VARIABLES-IN-GENERATOR-GOAL ((GOAL PROPOSITION) (GOALSEQUENCE (LIST OF PROPOSITION))))"
    (CL:FUNCTION BIND-ALL-VARIABLES-IN-GENERATOR-GOAL) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING"
    "(DEFUN COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING ((OPTIMIZERVARIABLES (LIST OF PATTERN-VARIABLE)) (NUMBEROFOPENGOALS INTEGER) (GOALSEQUENCE (LIST OF PROPOSITION)) (PRIORCOST COST-ESTIMATE) (PRIORFANOUT COST-ESTIMATE)))"
    (CL:FUNCTION COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-GREEDY-OPEN-GOAL-ORDERING"
    "(DEFUN COMPUTE-GREEDY-OPEN-GOAL-ORDERING ((OPTIMIZERVARIABLES (LIST OF PATTERN-VARIABLE)) (NUMBEROFOPENGOALS INTEGER) (GOALSEQUENCE (LIST OF PROPOSITION)) (PRIORCOST COST-ESTIMATE) (PRIORFANOUT COST-ESTIMATE)))"
    (CL:FUNCTION COMPUTE-GREEDY-OPEN-GOAL-ORDERING) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-BACKUP-OPEN-GOAL-ORDERING"
    "(DEFUN COMPUTE-BACKUP-OPEN-GOAL-ORDERING ((GOALSEQUENCE (LIST OF PROPOSITION))))"
    (CL:FUNCTION COMPUTE-BACKUP-OPEN-GOAL-ORDERING) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-UNBOUND-GOAL-VARIABLES"
    "(DEFUN COLLECT-UNBOUND-GOAL-VARIABLES ((GOAL PROPOSITION) (UNBOUNDVARIABLES (LIST OF PATTERN-VARIABLE))))"
    (CL:FUNCTION COLLECT-UNBOUND-GOAL-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "EXTRACT-OPEN-GOAL-CLUSTERS"
    "(DEFUN EXTRACT-OPEN-GOAL-CLUSTERS ((OPENGOALS (LIST OF PROPOSITION)) (OPENGOALCLUSTERS (LIST OF (LIST OF PROPOSITION)))))"
    (CL:FUNCTION EXTRACT-OPEN-GOAL-CLUSTERS) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-OPTIMIZER-VARIABLES"
    "(DEFUN COLLECT-OPTIMIZER-VARIABLES ((PROPOSITION PROPOSITION) (COLLECTION LIST)))"
    (CL:FUNCTION COLLECT-OPTIMIZER-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "BIGGER-CONJUNCTION?"
    "(DEFUN (BIGGER-CONJUNCTION? BOOLEAN) ((PROP1 PROPOSITION) (PROP2 PROPOSITION)))"
    (CL:FUNCTION BIGGER-CONJUNCTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-OPEN-GOAL-ORDERING"
    "(DEFUN COMPUTE-OPEN-GOAL-ORDERING ((ANDPROPOSITION PROPOSITION) (OPENGOALS (LIST OF PROPOSITION)) (GOALSEQUENCE (LIST OF PROPOSITION))))"
    (CL:FUNCTION COMPUTE-OPEN-GOAL-ORDERING) NULL)
   (DEFINE-FUNCTION-OBJECT "OPTIMIZE-ORDERING-OF-CONJUNCTS"
    "(DEFUN OPTIMIZE-ORDERING-OF-CONJUNCTS ((ANDPROPOSITION PROPOSITION)))"
    (CL:FUNCTION OPTIMIZE-ORDERING-OF-CONJUNCTS) NULL)
   (DEFINE-FUNCTION-OBJECT "REORDER-GOALS"
    "(DEFUN REORDER-GOALS ((ANDPROPOSITION PROPOSITION) (INITIALLYCLOSEDGOALS (LIST OF PROPOSITION)) (GOALSEQUENCE (LIST OF PROPOSITION)) (RESIDUEGOALS (LIST OF PROPOSITION))))"
    (CL:FUNCTION REORDER-GOALS) NULL)
   (DEFINE-FUNCTION-OBJECT "SIMULATE-BIND-VARIABLE-TO-VALUE"
    "(DEFUN SIMULATE-BIND-VARIABLE-TO-VALUE ((FORMULA OBJECT)))"
    (CL:FUNCTION SIMULATE-BIND-VARIABLE-TO-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "WARN-OF-UNBOUND-VARIABLE-ARGUMENT"
    "(DEFUN WARN-OF-UNBOUND-VARIABLE-ARGUMENT ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION WARN-OF-UNBOUND-VARIABLE-ARGUMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "SIMULATE-GOAL-EVALUATION"
    "(DEFUN SIMULATE-GOAL-EVALUATION ((GOAL PROPOSITION)))"
    (CL:FUNCTION SIMULATE-GOAL-EVALUATION) NULL)
   (DEFINE-FUNCTION-OBJECT "SIMULATE-AND-OPTIMIZE-ARGUMENT"
    "(DEFUN SIMULATE-AND-OPTIMIZE-ARGUMENT ((FORMULA OBJECT)))"
    (CL:FUNCTION SIMULATE-AND-OPTIMIZE-ARGUMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "SIMULATE-AND-OPTIMIZE-QUERY"
    "(DEFUN SIMULATE-AND-OPTIMIZE-QUERY ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION SIMULATE-AND-OPTIMIZE-QUERY) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-OPTIMIZER-MEMORY"
    "(DEFUN INITIALIZE-OPTIMIZER-MEMORY ((STACKSIZE INTEGER)))"
    (CL:FUNCTION INITIALIZE-OPTIMIZER-MEMORY) NULL)
   (DEFINE-FUNCTION-OBJECT "OPTIMIZE-QUERY"
    "(DEFUN OPTIMIZE-QUERY ((DESCRIPTION DESCRIPTION) (BOOLEANVECTOR BOOLEAN-VECTOR) (PARENTFRAME CONTROL-FRAME)))"
    (CL:FUNCTION OPTIMIZE-QUERY) NULL)
   (DEFINE-FUNCTION-OBJECT "USE-DYNAMIC-QUERY-OPTIMIZATION?"
    "(DEFUN (USE-DYNAMIC-QUERY-OPTIMIZATION? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (AND (OR (EQL? *QUERY-OPTIMIZATION-STRATEGY* :DYNAMIC) (EQL? *QUERY-OPTIMIZATION-STRATEGY* :DYNAMIC-WITH-CLUSTERING)))))"
    (CL:FUNCTION USE-DYNAMIC-QUERY-OPTIMIZATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "DYNAMICALLY-OPTIMIZE-PROPOSITION?"
    "(DEFUN (DYNAMICALLY-OPTIMIZE-PROPOSITION? BOOLEAN) ((SELF PROPOSITION)))"
    (CL:FUNCTION DYNAMICALLY-OPTIMIZE-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "USE-STATIC-QUERY-OPTIMIZATION?"
    "(DEFUN (USE-STATIC-QUERY-OPTIMIZATION? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (AND (NOT (EQL? *QUERY-OPTIMIZATION-STRATEGY* :NONE)) (NOT (USE-DYNAMIC-QUERY-OPTIMIZATION?)))))"
    (CL:FUNCTION USE-STATIC-QUERY-OPTIMIZATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "STATICALLY-OPTIMIZE-PROPOSITION?"
    "(DEFUN (STATICALLY-OPTIMIZE-PROPOSITION? BOOLEAN) ((SELF PROPOSITION)))"
    (CL:FUNCTION STATICALLY-OPTIMIZE-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRY-TO-CLUSTER-CONJUNCTIONS?"
    "(DEFUN (TRY-TO-CLUSTER-CONJUNCTIONS? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (OR (EQL? *QUERY-OPTIMIZATION-STRATEGY* :STATIC-WITH-CLUSTERING))))"
    (CL:FUNCTION TRY-TO-CLUSTER-CONJUNCTIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "SELECT-OPTIMAL-QUERY-PATTERN"
    "(DEFUN (SELECT-OPTIMAL-QUERY-PATTERN DESCRIPTION) ((DESCRIPTION DESCRIPTION) (BOOLEANVECTOR BOOLEAN-VECTOR) (PARENTFRAME CONTROL-FRAME)))"
    (CL:FUNCTION SELECT-OPTIMAL-QUERY-PATTERN) NULL)
   (DEFINE-FUNCTION-OBJECT "DYNAMICALLY-ESTIMATE-GOAL-COST"
    "(DEFUN (DYNAMICALLY-ESTIMATE-GOAL-COST COST-ESTIMATE) ((GOAL PROPOSITION)))"
    (CL:FUNCTION DYNAMICALLY-ESTIMATE-GOAL-COST) NULL)
   (DEFINE-FUNCTION-OBJECT "DYNAMICALLY-ESTIMATE-GOAL-FANOUT"
    "(DEFUN (DYNAMICALLY-ESTIMATE-GOAL-FANOUT COST-ESTIMATE) ((GOAL PROPOSITION)))"
    (CL:FUNCTION DYNAMICALLY-ESTIMATE-GOAL-FANOUT) NULL)))

(CL:DEFUN HELP-STARTUP-OPTIMIZE5 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "DYNAMICALLY-ESTIMATE-PREDICATE-GOAL-FANOUT"
    "(DEFUN (DYNAMICALLY-ESTIMATE-PREDICATE-GOAL-FANOUT COST-ESTIMATE) ((GOAL PROPOSITION)))"
    (CL:FUNCTION DYNAMICALLY-ESTIMATE-PREDICATE-GOAL-FANOUT) NULL)
   (DEFINE-FUNCTION-OBJECT
    "DYNAMICALLY-ESTIMATE-INSTANCE-OF-GOAL-FANOUT"
    "(DEFUN (DYNAMICALLY-ESTIMATE-INSTANCE-OF-GOAL-FANOUT COST-ESTIMATE) ((GOAL PROPOSITION)))"
    (CL:FUNCTION DYNAMICALLY-ESTIMATE-INSTANCE-OF-GOAL-FANOUT) NULL)
   (DEFINE-FUNCTION-OBJECT "DYNAMICALLY-ESTIMATE-EXTENSION-SIZE"
    "(DEFUN (DYNAMICALLY-ESTIMATE-EXTENSION-SIZE COST-ESTIMATE) ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION DYNAMICALLY-ESTIMATE-EXTENSION-SIZE) NULL)
   (DEFINE-FUNCTION-OBJECT
    "DYNAMICALLY-ESTIMATE-UNBOUND-VARIABLE-PENALTY"
    "(DEFUN (DYNAMICALLY-ESTIMATE-UNBOUND-VARIABLE-PENALTY COST-ESTIMATE) ((GOAL PROPOSITION)))"
    (CL:FUNCTION DYNAMICALLY-ESTIMATE-UNBOUND-VARIABLE-PENALTY) NULL)
   (DEFINE-FUNCTION-OBJECT "DYNAMICALLY-REOPTIMIZE-ARGUMENTS"
    "(DEFUN DYNAMICALLY-REOPTIMIZE-ARGUMENTS ((ARGUMENTS (VECTOR OF PROPOSITION)) (CURSOR INTEGER)))"
    (CL:FUNCTION DYNAMICALLY-REOPTIMIZE-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "SIMPLIFY-DESCRIPTION"
    "(DEFUN SIMPLIFY-DESCRIPTION ((DESCRIPTION DESCRIPTION) (POSTOPTIMIZATION? BOOLEAN)))"
    (CL:FUNCTION SIMPLIFY-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "COPY-LIST-TO-ARGUMENTS-VECTOR"
    "(DEFUN (COPY-LIST-TO-ARGUMENTS-VECTOR ARGUMENTS-VECTOR) ((ARGUMENTS LIST)))"
    (CL:FUNCTION COPY-LIST-TO-ARGUMENTS-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "CONJUNCT-CANCELS-ISA-PROPOSITION?"
    "(DEFUN (CONJUNCT-CANCELS-ISA-PROPOSITION? BOOLEAN) ((ISACONJUNCT PROPOSITION) (OTHERCONJUNCT PROPOSITION)))"
    (CL:FUNCTION CONJUNCT-CANCELS-ISA-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "SIMPLIFY-CONJUNCTION"
    "(DEFUN SIMPLIFY-CONJUNCTION ((ANDPROPOSITION PROPOSITION)))"
    (CL:FUNCTION SIMPLIFY-CONJUNCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "SIMPLIFY-PROPOSITION"
    "(DEFUN SIMPLIFY-PROPOSITION ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION SIMPLIFY-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "COPY-DESCRIPTION"
    "(DEFUN (COPY-DESCRIPTION DESCRIPTION) ((SELF DESCRIPTION) (PARENTMAPPING ENTITY-MAPPING) (ADDBACKLINKS? BOOLEAN)))"
    (CL:FUNCTION COPY-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "COPY-VARIABLE"
    "(DEFUN (COPY-VARIABLE PATTERN-VARIABLE) ((SELF PATTERN-VARIABLE) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION COPY-VARIABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "COPY-VARIABLES-VECTOR"
    "(DEFUN (COPY-VARIABLES-VECTOR VARIABLES-VECTOR) ((SELF VARIABLES-VECTOR) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION COPY-VARIABLES-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "COPY-PROPOSITION"
    "(DEFUN (COPY-PROPOSITION PROPOSITION) ((SELF PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION COPY-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "COPY-PROPOSITION-ARGUMENT"
    "(DEFUN (COPY-PROPOSITION-ARGUMENT OBJECT) ((SELF OBJECT) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION COPY-PROPOSITION-ARGUMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "MAPPED-VALUE-OF"
    "(DEFUN (MAPPED-VALUE-OF OBJECT) ((SELF OBJECT) (MAPPING ENTITY-MAPPING) (CREATESKOLEM? BOOLEAN)))"
    (CL:FUNCTION MAPPED-VALUE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "SINGLE-VALUED-PREDICATE?"
    "(DEFUN (SINGLE-VALUED-PREDICATE? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION SINGLE-VALUED-PREDICATE?) NULL)
   (DEFINE-FUNCTION-OBJECT "BINARY-PROPOSITION?"
    "(DEFUN (BINARY-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)) :GLOBALLY-INLINE? TRUE (RETURN (EQL? (LENGTH (ARGUMENTS PROPOSITION)) 2)))"
    (CL:FUNCTION BINARY-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "INHERIT-EQUIVALENT-PROPOSITION"
    "(DEFUN (INHERIT-EQUIVALENT-PROPOSITION PROPOSITION) ((SKOLEM SKOLEM) (VALUE OBJECT)))"
    (CL:FUNCTION INHERIT-EQUIVALENT-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "INHERIT-FUNCTION-PROPOSITION"
    "(DEFUN (INHERIT-FUNCTION-PROPOSITION PROPOSITION) ((SELF PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION INHERIT-FUNCTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUAL-UP-TO-SKOLEM-IDENTITY?"
    "(DEFUN (EQUAL-UP-TO-SKOLEM-IDENTITY? BOOLEAN) ((INHERITEDARG OBJECT) (BASEARG OBJECT) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION EQUAL-UP-TO-SKOLEM-IDENTITY?) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-SIMILAR-PROPOSITION"
    "(DEFUN (FIND-SIMILAR-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION FIND-SIMILAR-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "INHERIT-PROPOSITION-ARGUMENT"
    "(DEFUN (INHERIT-PROPOSITION-ARGUMENT OBJECT) ((ARGUMENT OBJECT) (PARENT PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION INHERIT-PROPOSITION-ARGUMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "ERADICATE-HOLDS-PROPOSITION"
    "(DEFUN (ERADICATE-HOLDS-PROPOSITION PROPOSITION) ((SELF PROPOSITION)))"
    (CL:FUNCTION ERADICATE-HOLDS-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "INHERIT-PROPOSITION"
    "(DEFUN (INHERIT-PROPOSITION PROPOSITION) ((SELF PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION INHERIT-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-SKOLEM-FOR-UNMAPPED-VARIABLE"
    "(DEFUN (CREATE-SKOLEM-FOR-UNMAPPED-VARIABLE SKOLEM) ((VARIABLE PATTERN-VARIABLE) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION CREATE-SKOLEM-FOR-UNMAPPED-VARIABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "INHERIT-AS-TOP-LEVEL-PROPOSITION"
    "(DEFUN (INHERIT-AS-TOP-LEVEL-PROPOSITION (CONS OF PROPOSITION)) ((PROPOSITION PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION INHERIT-AS-TOP-LEVEL-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "MAP-AND-ENQUEUE-VARIABLE?"
    "(DEFUN (MAP-AND-ENQUEUE-VARIABLE? BOOLEAN) ((VARIABLE OBJECT) (LOCALVALUE OBJECT) (MAPPING ENTITY-MAPPING) (QUEUE LIST)))"
    (CL:FUNCTION MAP-AND-ENQUEUE-VARIABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-STRUCTURAL-FUNCTIONS"
    "(DEFUN COLLECT-STRUCTURAL-FUNCTIONS ((PROPOSITION PROPOSITION) (STRUCTURALFUNCTIONS (LIST OF PROPOSITION))))"
    (CL:FUNCTION COLLECT-STRUCTURAL-FUNCTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "MAP-FUNCTIONAL-VALUE?"
    "(DEFUN (MAP-FUNCTIONAL-VALUE? BOOLEAN) ((PROPOSITION PROPOSITION) (MAPPING ENTITY-MAPPING) (QUEUE LIST)))"
    (CL:FUNCTION MAP-FUNCTIONAL-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "INHERIT-DESCRIPTION-PROPOSITIONS"
    "(DEFUN (INHERIT-DESCRIPTION-PROPOSITIONS (CONS OF PROPOSITION)) ((ARGUMENTS VECTOR) (DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION INHERIT-DESCRIPTION-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "INHERIT-UNNAMED-DESCRIPTION"
    "(DEFUN INHERIT-UNNAMED-DESCRIPTION ((SELF OBJECT) (DESCRIPTION DESCRIPTION) (DEFAULTTRUE? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION INHERIT-UNNAMED-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "VECTOR.INHERIT-UNNAMED-DESCRIPTION"
    "(DEFUN VECTOR.INHERIT-UNNAMED-DESCRIPTION ((ARGUMENTS VECTOR) (DESCRIPTION DESCRIPTION) (DEFAULTTRUE? BOOLEAN)))"
    (CL:FUNCTION VECTOR.INHERIT-UNNAMED-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGIC-OBJECT.INHERIT-UNNAMED-DESCRIPTION"
    "(DEFUN LOGIC-OBJECT.INHERIT-UNNAMED-DESCRIPTION ((INSTANCE LOGIC-OBJECT) (DESCRIPTION DESCRIPTION) (DEFAULTTRUE? BOOLEAN)))"
    (CL:FUNCTION LOGIC-OBJECT.INHERIT-UNNAMED-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "INHERIT-DESCRIPTION"
    "(DEFUN INHERIT-DESCRIPTION ((ARGUMENTS VECTOR) (DESCRIPTION DESCRIPTION) (DEFAULTTRUE? BOOLEAN)))"
    (CL:FUNCTION INHERIT-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-OPTIMIZE"
    "(DEFUN STARTUP-OPTIMIZE () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-OPTIMIZE) NULL)
   (CL:LET*
    ((FUNCTION (LOOKUP-FUNCTION SYM-OPTIMIZE-LOGIC-STARTUP-OPTIMIZE)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-OPTIMIZE-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupOptimize") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-OPTIMIZE ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-OPTIMIZE1)
    (HELP-STARTUP-OPTIMIZE2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4) (HELP-STARTUP-OPTIMIZE3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "GOAL-RECORD"
        "(DEFCLASS GOAL-RECORD (STANDARD-OBJECT) :SLOTS ((GENERATOR-GOALS :TYPE (LIST OF PROPOSITION) :ALLOCATION :EMBEDDED) (OTHER-GOALS :TYPE (LIST OF PROPOSITION) :ALLOCATION :EMBEDDED)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-GOAL-RECORD))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-GOAL-RECORD-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-OPTIMIZE4)
    (HELP-STARTUP-OPTIMIZE5))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DISTRIBUTEDOPENGOAL?* BOOLEAN FALSE :DOCUMENTATION \"Used by 'distribute-open-goal' to signal that
a goal was distributed by 'help-distribute-goal'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT V-0-0 BOOLEAN-VECTOR (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR (LIST 0 0)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT V-1-0 BOOLEAN-VECTOR (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR (LIST 1 0)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT V-0-1 BOOLEAN-VECTOR (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR (LIST 0 1)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT V-1-1 BOOLEAN-VECTOR (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR (LIST 1 1)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT V-1-0-AND-V-0-1 (LIST OF BOOLEAN-VECTOR) (LIST V-1-0 V-0-1))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT V-1-0-SINGLETON (LIST OF BOOLEAN-VECTOR) (LIST V-1-0))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT V-0-1-SINGLETON (LIST OF BOOLEAN-VECTOR) (LIST V-0-1))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ESTIMATED-SLOT-VALUE-COLLECTION-SIZE COST-ESTIMATE 4.0 :DOCUMENTATION \"Estimate of the average size of a collection
representing the fillers of a slot.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS COST-ESTIMATE 6.0 :DOCUMENTATION \"Very crude estimate of the number of stored propositions
that will match a predicate at least one of whose arguments are bound.
Chosen to be larger than ESTIMATED-SLOT-VALUE-COLLECTION-SIZE.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ESTIMATED-SIZE-OF-CLASS-EXTENSION COST-ESTIMATE 11.0 :DOCUMENTATION \"Must be greater than ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS
to force the optimizer to prefer predicates containing at least
one bound variable.  Also greater than ESTIMATED-SIZE-OF-PREDICATE-EXTENSION,
for no particularly valid reason.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ESTIMATED-CARDINALITY-OF-DESCRIPTION COST-ESTIMATE 20.0 :DOCUMENTATION \"Indefensible estimate of the number instances
generable by an arbitrary unnamed description.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ESTIMATED-CARDINALITY-OF-MEMBER-OF COST-ESTIMATE 30.0 :DOCUMENTATION \"Even more indefensible estimate of the number instances
generable by a 'member-of' predicate.  CAUTION: Must be set
less than 'ESTIMATED-CARDINALITY-OF-SUBSET-OF'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ESTIMATED-CARDINALITY-OF-SUBSET-OF COST-ESTIMATE 40.0 :DOCUMENTATION \"Egregiously indefensible estimate of the number instances
generable by a 'subset-of' predicate.  Set high because 'subset-of'
can't generate all defined supersets or subsets, causing potential
incompleteness.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT INFERABLE-PENALTY-COST COST-ESTIMATE 7.0 :DOCUMENTATION \"Amount of penalty for using inferable relations as goals.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT SUBSET-OF-PENALTY-COST COST-ESTIMATE 20.0 :DOCUMENTATION \"Amount of penalty for using 'subset-of' as a goal.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *OPTIMALGOALORDERINGRECURSIONS* INTEGER NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *OPTIMAL-GOAL-ORDERING-CUTOFF* INTEGER 100)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *QUERYOPTIMIZERCONTROLFRAME* CONTROL-FRAME :DOCUMENTATION \"Keeps track of last control frame allocated by
the query optimizer.  Used by recursive invocations of the optimizer.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *BOUNDTOOFFSETCOUNTER* INTEGER NULL :DOCUMENTATION \"Enables 'select-optimal-query-pattern' to tell
'copy-variables-vector' that it should initialize the 'bound-to-offset'
slot of each variable in the copy operation.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *QUERY-OPTIMIZATION-STRATEGY* KEYWORD :DYNAMIC :DOCUMENTATION \"Keyword indicating what clause reordering strategy should
be used for conjunctive queries.  Legal values are :STATIC which performs
optimization once for each conjunctive pattern by simulating a query,
:STATIC-WITH-CLUSTERING which additionally tries to cluster conjunction into
independent clusters, :DYNAMIC which performs simple greedy optimization
dynamically during a query, :DYNAMIC-WITH-CLUSTERING which also looks
for clusters (not yet implemented), and :NONE to indicate no optimization
should be performed.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *POSTOPTIMIZATION?* BOOLEAN FALSE :DOCUMENTATION \"Used by 'simplify-description' to permit application
of order-dependent optimizations.\")"))))
