;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; descriptions.lisp

#|
 +--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997-2003              |
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-SLOT NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-METHOD-SLOT NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-STELLA-ANY-VALUE NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-EXTENSIONAL-ASSERTION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PL-KERNEL-KB-RELATION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PL-KERNEL-KB-POLYMORPHIC NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X1 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X2 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X3 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X4 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X5 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X6 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X7 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X8 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X9 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X10 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X11 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X12 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X13 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X14 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X15 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X16 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X17 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X18 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X19 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X20 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X21 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X22 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X23 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X24 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X25 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X26 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X27 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X28 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X29 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X30 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X31 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X32 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X33 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X34 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X35 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X36 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X37 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X38 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X39 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X40 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X41 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X42 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X43 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X44 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X45 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X46 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X47 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X48 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X49 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X50 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X51 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X52 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X53 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X54 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X55 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X56 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X57 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X58 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X59 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X60 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X61 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X62 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X63 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X64 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X65 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X66 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X67 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X68 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X69 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X70 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X71 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X72 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X73 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X74 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X75 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X76 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X77 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X78 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X79 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X80 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X81 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X82 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X83 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X84 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X85 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X86 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X87 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X88 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X89 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X90 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X91 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X92 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X93 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X94 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X95 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X96 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X97 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X98 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X99 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X100 NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-STELLA-ISA NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-KAPPA NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-KIF NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-DESCRIPTION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PL-KERNEL-KB-CONCEPT NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PL-KERNEL-KB-FUNCTION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PL-KERNEL-KB-VARIABLE-ARITY NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-CLASS NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-ERROR NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-RELATION NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-OBJECT-STORE NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-THING NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-LITERAL NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-WARNING NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-CONS NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-ISA NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-VARIABLE-TYPE? NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-STELLA-EXISTS NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-ENTITY-MAPPING NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-AND NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-OR NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-EQUIVALENT NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-FORALL NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-EXISTS NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-FUNCTION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-SET NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-LIST NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-SURROGATE NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-NOT NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-ORIGINAL-SKOLEM-NAME NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-STELLA-AND NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-STELLA-OR NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-STELLA-NOT NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-STELLA-FORALL NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-DEPENDENT-DESCRIPTIONS NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-PREDICATE NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-IMPLIES NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-PROPOSITION.IF NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-CS-VALUE NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-THE-ONLY NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-IOTA? NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-VARIABLE-TYPE-TABLE NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-SYMBOL NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-UNDECLARED? NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-LIST-UNDEFINED-RELATIONS NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-COMMON-LISP NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-PL-KERNEL-KB-RELATION NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-F-CALL-LIST-UNDEFINED-RELATIONS-QUERY-000 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-DESCRIPTIVE? NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-STARTUP-DESCRIPTIONS NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *SURROGATE-ARRAY* FALSE-WRAPPER
  *VARIABLEIDCOUNTER* STANDARD-ERROR *UNIFY-PROPOSITIONS?*
  *QUERYITERATOR* ZERO-VARIABLES-VECTOR TRUE-WRAPPER STANDARD-WARNING
  *SUPPRESSNONLOGICOBJECTWARNING?* STANDARD-OUTPUT *PL-KERNEL-MODULE*
  NIL-LIST EOL *MODULE* TRUE-PROPOSITION TRUE FALSE NIL NULL-INTEGER))

;;; (DEFUN (DIRECT-SUPERRELATIONS (ITERATOR OF (LIKE SELF))) ...)

(CL:DEFUN DIRECT-SUPERRELATIONS (SELF)
  "Return direct super classes/slots of 'self'."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
     (CL:PROGN (DIRECT-SUPER-CLASSES SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-SLOT)
     (CL:PROGN (ALLOCATE-ITERATOR (SLOT-DIRECT-SUPERS SELF))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (SLOT-COLUMN-TYPES (CONS OF TYPE)) ...)

(CL:DEFUN SLOT-COLUMN-TYPES (SELF COUNT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT))
  #+MCL
  (CL:CHECK-TYPE COUNT CL:FIXNUM)
  (CL:COND
   ((SUBTYPE-OF-STORAGE-SLOT? (SAFE-PRIMARY-TYPE SELF))
    (CL:PROGN
     (CL:LET*
      ((DOMAIN (%SLOT-OWNER SELF)) (RANGE (%SLOT-BASE-TYPE SELF))
       (TYPESLIST
        (CL:IF (BOOLEAN-TYPE? RANGE) (CONS-LIST DOMAIN)
         (CONS-LIST DOMAIN RANGE))))
      TYPESLIST)))
   (CL:T
    (CL:LET*
     ((TYPESPECIFIERS
       (CL:IF (ISA? SELF SGT-DESCRIPTIONS-STELLA-METHOD-SLOT)
        (METHOD-PARAMETER-TYPE-SPECIFIERS SELF) (%TUPLE-DOMAINS SELF)))
      (TYPESLIST NIL) (VARIABLETYPES NIL) (RETURNTYPES NIL)
      (RETURNTYPE (UNWRAP-WRAPPED-TYPE (%SLOT-BASE-TYPE SELF))))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ RETURNTYPE NULL))
       (CL:NOT (BOOLEAN-TYPE? RETURNTYPE)))
      (CL:SETQ RETURNTYPES (CONS RETURNTYPE RETURNTYPES)))
     (CL:IF (NULL? (ARITY SELF))
      (CL:LET*
       ((VARIABLEARGUMENTSTYPE
         (EXTRACT-PARAMETER-TYPE (LAST TYPESPECIFIERS)
          SYM-DESCRIPTIONS-STELLA-ANY-VALUE)))
       (CL:LET*
        ((TSPEC NULL) (ITER-000 (BUT-LAST TYPESPECIFIERS))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (NEXT? ITER-000) DO
         (CL:SETQ TSPEC (%VALUE ITER-000))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-000
            (CONS (UNWRAP-WRAPPED-TYPE (TYPE-SPEC-TO-BASE-TYPE TSPEC))
             NIL))
           (CL:IF (CL:EQ TYPESLIST NIL) (CL:SETQ TYPESLIST COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST TYPESLIST COLLECT-000)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-000)
            (CONS (UNWRAP-WRAPPED-TYPE (TYPE-SPEC-TO-BASE-TYPE TSPEC))
             NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
       (CL:IF (NULL? COUNT) (CL:SETQ COUNT 1)
        (CL:SETQ COUNT
         (CL:- COUNT (CL:+ (LENGTH TYPESLIST) (LENGTH RETURNTYPES)))))
       (CL:LET*
        ((I NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-000 COUNT)
         (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 UPPER-BOUND-000 I))
        (CL:LOOP WHILE
         (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)) DO
         (CL:PROGN (CL:SETQ I ITER-001)
          (CL:SETQ ITER-001 (CL:1+ ITER-001)))
         (CL:SETQ I I)
         (CL:SETQ VARIABLETYPES
          (CONS VARIABLEARGUMENTSTYPE VARIABLETYPES))))
       (CL:SETQ TYPESLIST (CONCATENATE TYPESLIST VARIABLETYPES)))
      (CL:LET*
       ((TSPEC NULL) (ITER-002 (%THE-CONS-LIST TYPESPECIFIERS))
        (COLLECT-001 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:PROGN (CL:SETQ TSPEC (%%VALUE ITER-002))
         (CL:SETQ ITER-002 (%%REST ITER-002)))
        (CL:IF (CL:EQ COLLECT-001 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-001
           (CONS (UNWRAP-WRAPPED-TYPE (TYPE-SPEC-TO-BASE-TYPE TSPEC))
            NIL))
          (CL:IF (CL:EQ TYPESLIST NIL) (CL:SETQ TYPESLIST COLLECT-001)
           (ADD-CONS-TO-END-OF-CONS-LIST TYPESLIST COLLECT-001)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-001)
           (CONS (UNWRAP-WRAPPED-TYPE (TYPE-SPEC-TO-BASE-TYPE TSPEC))
            NIL))
          (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))))
     (CL:SETQ TYPESLIST (CONCATENATE TYPESLIST RETURNTYPES))
     TYPESLIST))))

;;; (DEFCONSTANT FAKE-IO-VARIABLES ...)

(CL:DEFVAR FAKE-IO-VARIABLES NULL
  "Installed in a description with undetermined arity.")

;;; (DEFUN (CREATE-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN CREATE-DESCRIPTION (ARITY NAMED?)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (ENFORCE-CODE-ONLY)
  (CL:LET*
   ((DESCRIPTION
     (CL:IF NAMED? (NEW-NAMED-DESCRIPTION) (NEW-DESCRIPTION))))
   (CL:SETF (%IO-VARIABLES DESCRIPTION)
    (CL:IF (DEFINED? ARITY) (NEW-VECTOR ARITY) FAKE-IO-VARIABLES))
   DESCRIPTION))

;;; (DEFMETHOD (DESCRIPTION-NAME SYMBOL) ...)

(CL:DEFMETHOD DESCRIPTION-NAME ((SELF DESCRIPTION))
  "Return the name of the description `self', if it has one."
  NULL)

;;; (DEFMETHOD (DESCRIPTION-NAME SYMBOL) ...)

(CL:DEFMETHOD DESCRIPTION-NAME ((SELF NAMED-DESCRIPTION))
  "Return the name of the description `self'."
  (OBJECT-NAME SELF))

;;; (DEFUN CREATE-BASE-RELATION-FOR-POLYMORPHIC-DESCRIPTION ...)

(CL:DEFUN CREATE-BASE-RELATION-FOR-POLYMORPHIC-DESCRIPTION (DESCRIPTION)
  (CL:LET*
   ((SURROGATE
     (INTERN-SURROGATE-IN-MODULE
      (%SYMBOL-NAME (DESCRIPTION-NAME DESCRIPTION))
      (%HOME-CONTEXT DESCRIPTION) TRUE))
    (RELATION (%SURROGATE-VALUE SURROGATE)))
   (CL:WHEN (CL:EQ RELATION NULL)
    (CL:LET*
     ((*EVALUATIONMODE* KWD-DESCRIPTIONS-EXTENSIONAL-ASSERTION)
      (*FILLINGCONSTRAINTPROPAGATIONQUEUES?* FALSE))
     (CL:DECLARE
      (CL:SPECIAL *EVALUATIONMODE*
       *FILLINGCONSTRAINTPROPAGATIONQUEUES?*))
     (ASSERT-ISA-PROPOSITION
      (CREATE-LOGIC-INSTANCE SURROGATE
       SGT-DESCRIPTIONS-PL-KERNEL-KB-RELATION)
      SGT-DESCRIPTIONS-PL-KERNEL-KB-POLYMORPHIC)))))

;;; (DEFCONSTANT SYSTEM-DEFINED-ARGUMENT-NAMES ...)

(CL:DEFVAR SYSTEM-DEFINED-ARGUMENT-NAMES NULL)

;;; (DEFUN (YIELD-SYSTEM-DEFINED-PARAMETER-NAME SYMBOL) ...)

(CL:DEFUN YIELD-SYSTEM-DEFINED-PARAMETER-NAME (INDEX REFERENCEOBJECT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX))
  #+MCL
  (CL:CHECK-TYPE INDEX CL:FIXNUM)
  (CL:IF (CL:< INDEX 100)
   (INTERN-SYMBOL-IN-MODULE
    (%SYMBOL-NAME (NTH SYSTEM-DEFINED-ARGUMENT-NAMES INDEX))
    (HOME-MODULE REFERENCEOBJECT) TRUE)
   (INTERN-SYMBOL-IN-MODULE
    (CONCATENATE "?X" (INTEGER-TO-STRING (CL:1+ INDEX)))
    (HOME-MODULE REFERENCEOBJECT) TRUE)))

;;; (DEFUN ENSURE-DESCRIPTION-BODY ...)

(CL:DEFUN ENSURE-DESCRIPTION-BODY (DESCRIPTION)
  (CL:WHEN
   (CL:AND
    (CL:OR (CL:EQ (%PROPOSITION DESCRIPTION) NULL)
     (CL:EQ (%PROPOSITION DESCRIPTION) TRUE-PROPOSITION))
    (ISA? DESCRIPTION SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION))
   (MATERIALIZE-PRIMITIVE-DESCRIPTION-BODY DESCRIPTION)))

;;; (DEFUN MATERIALIZE-PRIMITIVE-DESCRIPTION-BODY ...)

(CL:DEFUN MATERIALIZE-PRIMITIVE-DESCRIPTION-BODY (DESCRIPTION)
  (CL:LET*
   ((NATIVE? (CL:NOT (CL:EQ (NATIVE-RELATION DESCRIPTION) NULL)))
    (NAME
     (CL:IF NATIVE?
      (INTERN-SYMBOL-IN-MODULE (NAME (NATIVE-RELATION DESCRIPTION))
       (HOME-MODULE (NATIVE-RELATION DESCRIPTION)) TRUE)
      (DESCRIPTION-NAME DESCRIPTION)))
    (VARIABLETYPES (%IO-VARIABLE-TYPES DESCRIPTION))
    (ARITY (LENGTH VARIABLETYPES)) (TREE NULL) (VARIABLES NIL)
    (ARGUMENTS NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
   (CL:LET*
    ((NAME NULL) (I (INTERVAL 1 ARITY))
     (ITER-000 SYSTEM-DEFINED-ARGUMENT-NAMES) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:AND (NEXT? I) (CL:NOT (CL:EQ ITER-000 NIL))) DO
     (CL:PROGN (CL:SETQ NAME (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS NAME NIL))
       (CL:IF (CL:EQ VARIABLES NIL) (CL:SETQ VARIABLES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST VARIABLES COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS NAME NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:SETQ ARGUMENTS (COPY-CONS-LIST VARIABLES))
   (CL:WHEN (CL:AND NATIVE? (CL:> ARITY 1))
    (FIRST-SETTER VARIABLES
     (LIST* SYM-DESCRIPTIONS-STELLA-ISA (%%VALUE VARIABLES)
      (CONS (TYPE-TO-SYMBOL (FIRST VARIABLETYPES)) NIL))))
   (CL:SETQ TREE
    (LIST* SYM-DESCRIPTIONS-LOGIC-KAPPA VARIABLES
     (CONS (CONS NAME (CONCATENATE ARGUMENTS NIL)) NIL)))
   (CL:LET*
    ((*LOGIC-DIALECT* KWD-DESCRIPTIONS-KIF) (*LOGICVARIABLETABLE* NIL)
     (*TERMUNDERCONSTRUCTION* TREE)
     (*EVALUATIONMODE* KWD-DESCRIPTIONS-DESCRIPTION)
     (*CONTEXT* (%HOME-CONTEXT DESCRIPTION)))
    (CL:DECLARE
     (CL:SPECIAL *LOGIC-DIALECT* *LOGICVARIABLETABLE*
      *TERMUNDERCONSTRUCTION* *EVALUATIONMODE* *CONTEXT*))
    (CL:LET*
     ((SACRIFICIALDESCRIPTION (EVALUATE-DESCRIPTION-TERM TREE FALSE)))
     (CL:SETF (%IO-VARIABLES DESCRIPTION)
      (%IO-VARIABLES SACRIFICIALDESCRIPTION))
     (CL:SETF (%PROPOSITION DESCRIPTION)
      (%PROPOSITION SACRIFICIALDESCRIPTION))
     (DELETED?-SETTER SACRIFICIALDESCRIPTION TRUE)))))

;;; (DEFUN (CREATE-PRIMITIVE-DESCRIPTION NAMED-DESCRIPTION) ...)

(CL:DEFUN CREATE-PRIMITIVE-DESCRIPTION (IOVARIABLENAMES IOVARIABLETYPES VARIABLEARITY? CLASS? FUNCTION? MODULE)
  (CL:WHEN
   (CL:> (LENGTH IOVARIABLETYPES)
    (LENGTH SYSTEM-DEFINED-ARGUMENT-NAMES))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
     "PowerLoom can't handle relations with arity > `"
     (LENGTH SYSTEM-DEFINED-ARGUMENT-NAMES) "'" EOL)
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
  (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:LET* ((*FILLINGCONSTRAINTPROPAGATIONQUEUES?* FALSE))
    (CL:DECLARE (CL:SPECIAL *FILLINGCONSTRAINTPROPAGATIONQUEUES?*))
    (CL:LET* ((DESCRIPTION (CREATE-DESCRIPTION NULL-INTEGER TRUE)))
     (CL:SETF (%IO-VARIABLE-NAMES DESCRIPTION) IOVARIABLENAMES)
     (CL:SETF (%IO-VARIABLE-TYPES DESCRIPTION) IOVARIABLETYPES)
     (CL:COND
      (CLASS?
       (LINK-ORIGINATED-PROPOSITION DESCRIPTION
        (ASSERT-ISA-PROPOSITION DESCRIPTION
         SGT-DESCRIPTIONS-PL-KERNEL-KB-CONCEPT)))
      (FUNCTION?
       (LINK-ORIGINATED-PROPOSITION DESCRIPTION
        (ASSERT-ISA-PROPOSITION DESCRIPTION
         SGT-DESCRIPTIONS-PL-KERNEL-KB-FUNCTION)))
      (CL:T
       (LINK-ORIGINATED-PROPOSITION DESCRIPTION
        (ASSERT-ISA-PROPOSITION DESCRIPTION
         SGT-DESCRIPTIONS-PL-KERNEL-KB-RELATION))))
     (CL:WHEN VARIABLEARITY?
      (LINK-ORIGINATED-PROPOSITION DESCRIPTION
       (ASSERT-PROPERTY DESCRIPTION
        SGT-DESCRIPTIONS-PL-KERNEL-KB-VARIABLE-ARITY)))
     DESCRIPTION))))

;;; (DEFUN LINK-STELLA-RELATION-AND-DESCRIPTION ...)

(CL:DEFUN LINK-STELLA-RELATION-AND-DESCRIPTION (SELF DESCRIPTION)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-DESCRIPTIONS-LOGIC-DESCRIPTION DESCRIPTION NULL)
  (NATIVE-RELATION-SETTER DESCRIPTION SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
     (CL:PROGN
      (CL:SETF (%SURROGATE-VALUE-INVERSE DESCRIPTION)
       (CLASS-LOGICAL-TYPE SELF))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-SLOT)
     (CL:PROGN
      (CL:SETF (%SURROGATE-VALUE-INVERSE DESCRIPTION)
       (%SLOT-SLOTREF SELF))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
  (CL:WHEN (POLYMORPHIC-RELATION? SELF)
   (CREATE-BASE-RELATION-FOR-POLYMORPHIC-DESCRIPTION DESCRIPTION))
  NULL)

;;; (DEFUN (CREATE-DESCRIPTION-FOR-STELLA-RELATION NAMED-DESCRIPTION) ...)

(CL:DEFUN CREATE-DESCRIPTION-FOR-STELLA-RELATION (SELF)
  (CL:LET* ((SUPER NULL) (ITER-000 (DIRECT-SUPERRELATIONS SELF)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ SUPER (%VALUE ITER-000))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ SUPER NULL))
      (CL:OR (CL:NOT (ISA? SUPER SGT-DESCRIPTIONS-STELLA-CLASS))
       (LOGIC-CLASS? SUPER)))
     (GET-DESCRIPTION SUPER))))
  (CL:LET* ((DESCRIPTION NULL) (HOMEMODULE NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ HOMEMODULE (HOME-MODULE (CLASS-LOGICAL-TYPE SELF)))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-SLOT)
      (CL:PROGN (CL:SETQ HOMEMODULE (HOME-MODULE SELF))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:WHEN (CL:NOT (VISIBLE-FROM? *PL-KERNEL-MODULE* HOMEMODULE))
    (CL:SETQ HOMEMODULE *PL-KERNEL-MODULE*))
   (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF-CLASS? TEST-VALUE-001)
      (CL:PROGN
       (CL:WHEN (CL:NOT (LOGIC-CLASS? SELF))
        (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((*PRINTREADABLY?* TRUE))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
           "ERROR: Can't use the class `" SELF
           "' as a logic class because it" EOL
           "   does not inherit the top-level class THING.." EOL)
          (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001
           KWD-DESCRIPTIONS-ERROR))
         (CL:ERROR
          (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001)))))
       (CL:SETQ DESCRIPTION
        (CREATE-PRIMITIVE-DESCRIPTION NIL-LIST
         (LIST (CLASS-LOGICAL-TYPE SELF)) FALSE TRUE FALSE
         HOMEMODULE))))
     ((SUBTYPE-OF? TEST-VALUE-001 SGT-DESCRIPTIONS-STELLA-SLOT)
      (CL:PROGN
       (CL:LET*
        ((SLOTREF (%SLOT-SLOTREF SELF))
         (SUPERSLOTREF (MOST-GENERAL-EQUIVALENT-SLOTREF SLOTREF)))
        (CL:WHEN (CL:NOT (CL:EQ SLOTREF SUPERSLOTREF))
         (CL:SETQ SELF (%SURROGATE-VALUE SUPERSLOTREF))
         (CL:WHEN
          (CL:NOT
           (CL:EQ
            (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
             SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
            NULL))
          (CL:RETURN-FROM CREATE-DESCRIPTION-FOR-STELLA-RELATION
           (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
            SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)))))
       (CL:LET* ((SELF-004 (NEW-LIST)))
        (CL:SETF (%THE-CONS-LIST SELF-004)
         (SLOT-COLUMN-TYPES SELF NULL-INTEGER))
        (CL:SETQ DESCRIPTION
         (CREATE-PRIMITIVE-DESCRIPTION NIL-LIST SELF-004 FALSE FALSE
          (CL:NOT (BOOLEAN-TYPE? (%SLOT-BASE-TYPE SELF)))
          HOMEMODULE)))))
     (CL:T
      (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`" TEST-VALUE-001
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))))
   (LINK-STELLA-RELATION-AND-DESCRIPTION SELF DESCRIPTION)
   (FINALIZE-SUPERRELATION-LINKS SELF)
   (ENSURE-DESCRIPTION-BODY DESCRIPTION) DESCRIPTION))

;;; (DEFUN (SURROGATE-TO-DESCRIPTION NAMED-DESCRIPTION) ...)

(CL:DEFUN SURROGATE-TO-DESCRIPTION (SELF)
  (CL:LET* ((SURROGATEVALUE (%SURROGATE-VALUE SELF)))
   (CL:WHEN (CL:EQ SURROGATEVALUE NULL)
    (CL:RETURN-FROM SURROGATE-TO-DESCRIPTION NULL))
   (CL:IF
    (ISA? SURROGATEVALUE SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION)
    SURROGATEVALUE (GET-DESCRIPTION SELF))))

;;; (DEFUN (GET-DESCRIPTION NAMED-DESCRIPTION) ...)

(CL:DEFUN GET-DESCRIPTION (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN SELF))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (SURROGATE.GET-DESCRIPTION SELF)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN (GET-DESCRIPTION (SYMBOL-TO-SURROGATE SELF))))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN (STRING.GET-DESCRIPTION (%WRAPPER-VALUE SELF))))
    ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
     (CL:PROGN (CLASS.GET-DESCRIPTION SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-SLOT)
     (CL:PROGN (SLOT.GET-DESCRIPTION SELF)))
    (CL:T NULL))))

;;; (DEFUN (SURROGATE.GET-DESCRIPTION NAMED-DESCRIPTION) ...)

(CL:DEFUN SURROGATE.GET-DESCRIPTION (SELF)
  (CL:LET* ((VALUE (%SURROGATE-VALUE SELF)) (STORE NULL))
   (CL:COND
    ((CL:NOT (CL:EQ VALUE NULL))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VALUE)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION)
        (CL:PROGN VALUE))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-RELATION)
        (CL:PROGN
         (CL:COND
          ((CL:NOT
            (CL:EQ
             (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS VALUE)
              SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
             NULL))
           (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS VALUE)
            SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL))
          (CL:T (CREATE-DESCRIPTION-FOR-STELLA-RELATION VALUE)))))
       (CL:T NULL))))
    ((CL:NOT (CL:EQ (CL:SETQ STORE (HOME-OBJECT-STORE SELF)) NULL))
     (FETCH-RELATION STORE SELF))
    (CL:T NULL))))

;;; (DEFUN (STRING.GET-DESCRIPTION NAMED-DESCRIPTION) ...)

(CL:DEFUN STRING.GET-DESCRIPTION (SELF)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:SIMPLE-STRING)
  (CL:LET* ((SURROGATE (LOOKUP-SURROGATE SELF)) (STORE NULL))
   (CL:COND
    ((CL:NOT (CL:EQ SURROGATE NULL)) (GET-DESCRIPTION SURROGATE))
    ((CL:NOT
      (CL:EQ
       (CL:SETQ STORE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *MODULE*)
         SYM-DESCRIPTIONS-LOGIC-OBJECT-STORE NULL))
       NULL))
     (FETCH-RELATION STORE (WRAP-STRING SELF)))
    (CL:T NULL))))

;;; (DEFUN (CLASS.GET-DESCRIPTION NAMED-DESCRIPTION) ...)

(CL:DEFUN CLASS.GET-DESCRIPTION (SELF)
  (CL:COND
   ((CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
      NULL))
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL))
   ((CL:NOT (LOGIC-CLASS? SELF))
    (CL:WHEN (CL:NOT *SUPPRESSNONLOGICOBJECTWARNING?*)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "Reference to non-logic class: `" (NAME SELF) "'" EOL
      "Class must inherit 'THING' to be used by PowerLoom's logic." EOL
      EOL))
    NULL)
   (CL:T (GET-DESCRIPTION (CLASS-LOGICAL-TYPE SELF)))))

;;; (DEFUN (SLOT.GET-DESCRIPTION NAMED-DESCRIPTION) ...)

(CL:DEFUN SLOT.GET-DESCRIPTION (SELF)
  (CL:COND
   ((CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
      NULL))
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL))
   ((CL:NOT (CL:EQ (%SLOT-SLOTREF SELF) NULL))
    (GET-DESCRIPTION (%SLOT-SLOTREF SELF)))
   (CL:T
    (GET-DESCRIPTION
     (LOOKUP-SLOTREF (%SLOT-OWNER SELF) (%SLOT-NAME SELF))))))

;;; (DEFUN (ENSURE-DEFERRED-DESCRIPTION SURROGATE) ...)

(CL:DEFUN ENSURE-DEFERRED-DESCRIPTION (SELF)
  (CL:WHEN
   (CL:AND (CL:EQ (%SURROGATE-VALUE SELF) NULL)
    (CL:NOT (CL:EQ (HOME-OBJECT-STORE SELF) NULL)))
   (GET-DESCRIPTION SELF))
  SELF)

;;; (DEFUN (LOGIC-CLASS? BOOLEAN) ...)

(CL:DEFUN LOGIC-CLASS? (SELF)
  "Return TRUE if the class 'self' or one of its
supers supports indices that record extensions referenced by
the logic system. Also return true for literal classes."
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:IF
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
      NULL))
    (CL:SETQ TEST-VALUE-000 TRUE)
    (CL:PROGN
     (CL:LET* ((FOUND?-000 FALSE))
      (CL:LET* ((C NULL) (ITER-000 (%CLASS-ALL-SUPER-CLASSES SELF)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:PROGN (CL:SETQ C (%%VALUE ITER-000))
         (CL:SETQ ITER-000 (%%REST ITER-000)))
        (CL:WHEN
         (CL:OR
          (CL:NOT
           (CL:EQ
            (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS C)
             SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
            NULL))
          (CL:EQ C (%SURROGATE-VALUE SGT-DESCRIPTIONS-STELLA-THING)))
         (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
      (CL:SETQ TEST-VALUE-000 FOUND?-000))
     (CL:WHEN (CL:NOT TEST-VALUE-000)
      (CL:SETQ TEST-VALUE-000
       (CL:OR
        (CL:EQ SELF (%SURROGATE-VALUE SGT-DESCRIPTIONS-STELLA-THING))
        (SUBCLASS-OF? SELF
         (%SURROGATE-VALUE SGT-DESCRIPTIONS-STELLA-LITERAL))
        (CL:EQ SELF
         (%SURROGATE-VALUE SGT-DESCRIPTIONS-LOGIC-PROPOSITION)))))))
   (CL:WHEN TEST-VALUE-000 (CL:RETURN-FROM LOGIC-CLASS? TRUE)))
  (CL:WHEN (CL:NOT (%CLASS-FINALIZED? SELF))
   (CL:LET*
    ((BADSUPERS (COLLECT-BAD-SUPER-CLASSES (%CLASS-TYPE SELF) (LIST))))
    (CL:IF (EMPTY? BADSUPERS)
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING)
       "WARNING: Could not determine whether " SELF
       " is a logic class, because it is not finalized." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
       KWD-DESCRIPTIONS-WARNING))
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING)
       "WARNING: Could not determine whether " SELF
       " is a logic class, because it is not finalized." EOL
       "   It has these undefined or bad supers: "
       (%THE-CONS-LIST BADSUPERS) EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
       KWD-DESCRIPTIONS-WARNING)))))
  FALSE)

;;; (DEFUN (VARIABLE-ARITY-DOMAIN-TYPES-NEXT? BOOLEAN) ...)

(CL:DEFUN VARIABLE-ARITY-DOMAIN-TYPES-NEXT? (SELF)
  (CL:LET* ((NESTEDITERATOR (%ITERATOR-NESTED-ITERATOR SELF)))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ NESTEDITERATOR NULL))
     (NEXT? NESTEDITERATOR))
    (CL:SETF (%VALUE SELF) (%VALUE NESTEDITERATOR))
    (CL:PROGN (CL:SETF (%ITERATOR-NESTED-ITERATOR SELF) NULL)
     (CL:SETF (%VALUE SELF) (%ITERATOR-OBJECT SELF))))
   TRUE))

;;; (DEFUN (ALL-DOMAIN-TYPES ITERATOR) ...)

(CL:DEFUN ALL-DOMAIN-TYPES (SELF)
  (CL:LET*
   ((ITERATOR
     (CL:IF (FUNCTION-DESCRIPTION? SELF)
      (BUT-LAST (%IO-VARIABLE-TYPES SELF))
      (ALLOCATE-ITERATOR (%IO-VARIABLE-TYPES SELF)))))
   (CL:WHEN (VARIABLE-ARITY? SELF)
    (CL:LET* ((ALLPURPOSEITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
     (CL:SETF (%ITERATOR-NEXT-CODE ALLPURPOSEITERATOR)
      (CL:FUNCTION VARIABLE-ARITY-DOMAIN-TYPES-NEXT?))
     (CL:SETF (%ITERATOR-NESTED-ITERATOR ALLPURPOSEITERATOR) ITERATOR)
     (CL:SETQ ITERATOR ALLPURPOSEITERATOR)))
   ITERATOR))

;;; (DEFSPECIAL *LOGICVARIABLETABLE* ...)

(CL:DEFVAR *LOGICVARIABLETABLE* NULL
  "Table mapping logic variable names to variables or skolems.
Used during construction of a proposition or description.")

;;; (DEFUN PUSH-LOGIC-VARIABLE-BINDING ...)

(CL:DEFUN PUSH-LOGIC-VARIABLE-BINDING (VARIABLE)
  (CL:WHEN (ANONYMOUS-VARIABLE? VARIABLE)
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "ERROR: Illegal nameless variable '?' found in list of
quantified variables." EOL "   Quantified variables must have names.."
      EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-DESCRIPTIONS-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:SETQ *LOGICVARIABLETABLE* (CONS VARIABLE *LOGICVARIABLETABLE*)))

;;; (DEFUN POP-LOGIC-VARIABLE-BINDING ...)

(CL:DEFUN POP-LOGIC-VARIABLE-BINDING ()
  (CL:LET* ((HEADCONS *LOGICVARIABLETABLE*))
   (CL:SETQ *LOGICVARIABLETABLE* (%%REST HEADCONS)) (FREE HEADCONS)))

;;; (DEFUN POP-LOGIC-VARIABLE-BINDINGS ...)

(CL:DEFUN POP-LOGIC-VARIABLE-BINDINGS (VARIABLES)
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 (LENGTH VARIABLES)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
   (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
    (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
    (CL:SETQ I I) (POP-LOGIC-VARIABLE-BINDING))))

;;; (DEFUN (LOOKUP-LOGIC-VARIABLE-BINDING OBJECT) ...)

(CL:DEFUN LOOKUP-LOGIC-VARIABLE-BINDING (VARIABLENAME)
  (CL:WHEN (CL:NOT (CL:EQ *LOGICVARIABLETABLE* NULL))
   (CL:LET* ((VBL NULL) (ITER-000 *LOGICVARIABLETABLE*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ VBL (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (CL:EQ (%SKOLEM-NAME VBL) VARIABLENAME)
      (CL:RETURN-FROM LOOKUP-LOGIC-VARIABLE-BINDING VBL)))))
  NULL)

;;; (DEFSPECIAL *VARIABLETYPEPROPOSITIONS* ...)

(CL:DEFVAR *VARIABLETYPEPROPOSITIONS*)

;;; (DEFUN PARSE-ONE-VARIABLE-DECLARATION ...)

(CL:DEFUN PARSE-ONE-VARIABLE-DECLARATION (VDEC LOCALDECLARATIONS)
  (CL:LET* ((VARIABLENAME NULL) (ISATREE NULL) (VARIABLE NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VDEC)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-CONS)
      (CL:PROGN (CL:SETQ VARIABLENAME (%%VALUE (%%REST VDEC)))
       (CL:SETQ ISATREE VDEC)))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ VARIABLENAME VDEC)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:LET* ((V NULL) (ITER-000 (%THE-CONS-LIST LOCALDECLARATIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ V (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (CL:EQ (%SKOLEM-NAME V) VARIABLENAME)
      (CL:SETQ VARIABLE V))))
   (CL:WHEN (CL:EQ VARIABLE NULL)
    (CL:SETQ VARIABLE (CREATE-VARIABLE NULL VARIABLENAME TRUE)))
   (PUSH-LOGIC-VARIABLE-BINDING VARIABLE)
   (INSERT-LAST LOCALDECLARATIONS VARIABLE)
   (CL:WHEN (CL:NOT (CL:EQ ISATREE NULL))
    (CL:LET*
     ((PROPOSITION (BUILD-TOP-LEVEL-PROPOSITION ISATREE FALSE)))
     (CL:WHEN (CL:EQ PROPOSITION NULL)
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
         "ERROR: Error in declarations." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001
         KWD-DESCRIPTIONS-ERROR))
       (CL:ERROR
        (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001)))))
     (CL:WHEN (CL:EQ (%KIND PROPOSITION) KWD-DESCRIPTIONS-ISA)
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
       SYM-DESCRIPTIONS-LOGIC-VARIABLE-TYPE? TRUE-WRAPPER NULL)
      (UPDATE-SKOLEM-TYPE
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        0)
       (%OPERATOR PROPOSITION))
      (CL:SETQ *VARIABLETYPEPROPOSITIONS*
       (CONS PROPOSITION *VARIABLETYPEPROPOSITIONS*)))))))

;;; (DEFUN (PARSE-LOGIC-VARIABLE-DECLARATIONS (CONS OF PATTERN-VARIABLE)) ...)

(CL:DEFUN PARSE-LOGIC-VARIABLE-DECLARATIONS (TREE)
  (CL:LET*
   ((CONSTREE
     (CL:IF (ISA? TREE SGT-DESCRIPTIONS-STELLA-CONS) TREE
      (CONS-LIST TREE)))
    (DECLARATIONS (NEW-LIST)))
   (CL:LET* ((TERM NULL) (ITER-000 CONSTREE))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ TERM (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (PARSE-ONE-VARIABLE-DECLARATION TERM DECLARATIONS)))
   (%THE-CONS-LIST DECLARATIONS)))

;;; (DEFUN (HELP-BUILD-QUANTIFIED-PROPOSITION (CONS OF SKOLEM) PROPOSITION PROPOSITION) ...)

(CL:DEFUN HELP-BUILD-QUANTIFIED-PROPOSITION (TREE CONVERTTYPESTOCONSTRAINTS?)
  (CL:LET* ((*VARIABLETYPEPROPOSITIONS* NIL))
   (CL:DECLARE (CL:SPECIAL *VARIABLETYPEPROPOSITIONS*))
   (CL:LET*
    ((QUANTIFIER (%%VALUE TREE))
     (ANTECEDENTCLAUSE (%%VALUE (%%REST (%%REST TREE))))
     (CONSEQUENTCLAUSE (FOURTH TREE)) (VARIABLES NULL)
     (ANTECEDENTPROPOSITION NULL) (CONSEQUENTPROPOSITION NULL))
    (CL:SETQ VARIABLES
     (PARSE-LOGIC-VARIABLE-DECLARATIONS (%%VALUE (%%REST TREE))))
    (CL:WHEN (CL:NOT (CL:EQ ANTECEDENTCLAUSE NULL))
     (CL:SETQ ANTECEDENTPROPOSITION
      (BUILD-PROPOSITION ANTECEDENTCLAUSE)))
    (CL:WHEN (CL:NOT (CL:EQ CONSEQUENTCLAUSE NULL))
     (CL:SETQ CONSEQUENTPROPOSITION
      (BUILD-PROPOSITION CONSEQUENTCLAUSE)))
    (POP-LOGIC-VARIABLE-BINDINGS VARIABLES)
    (CL:WHEN CONVERTTYPESTOCONSTRAINTS?
     (CL:WHEN (CL:NOT (CL:EQ *VARIABLETYPEPROPOSITIONS* NIL))
      (CL:WHEN (CL:NOT (CL:EQ ANTECEDENTPROPOSITION NULL))
       (CL:SETQ *VARIABLETYPEPROPOSITIONS*
        (CONS ANTECEDENTPROPOSITION *VARIABLETYPEPROPOSITIONS*)))
      (CL:SETQ *VARIABLETYPEPROPOSITIONS*
       (REMOVE-DUPLICATES (REVERSE *VARIABLETYPEPROPOSITIONS*)))
      (CL:SETQ ANTECEDENTPROPOSITION
       (CONJOIN-PROPOSITIONS *VARIABLETYPEPROPOSITIONS*))))
    (CL:VALUES VARIABLES ANTECEDENTPROPOSITION CONSEQUENTPROPOSITION))))

;;; (DEFUN (BUILD-QUANTIFIED-PROPOSITION (CONS OF SKOLEM) PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-QUANTIFIED-PROPOSITION (TREE CONVERTTYPESTOCONSTRAINTS?)
  (CL:COND
   ((CL:EQ (%%VALUE TREE) SYM-DESCRIPTIONS-STELLA-EXISTS)
    (CL:LET* ((*EVALUATIONMODE* KWD-DESCRIPTIONS-DESCRIPTION))
     (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
     (HELP-BUILD-QUANTIFIED-PROPOSITION TREE
      CONVERTTYPESTOCONSTRAINTS?)))
   (CL:T
    (CL:LET* ((*EVALUATIONMODE* KWD-DESCRIPTIONS-DESCRIPTION))
     (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
     (HELP-BUILD-QUANTIFIED-PROPOSITION TREE
      CONVERTTYPESTOCONSTRAINTS?)))))

;;; (DEFUN (COPY-CONS-LIST-TO-VARIABLES-VECTOR VARIABLES-VECTOR) ...)

(CL:DEFUN COPY-CONS-LIST-TO-VARIABLES-VECTOR (CONSLIST)
  (CL:WHEN (CL:EQ CONSLIST NIL)
   (CL:RETURN-FROM COPY-CONS-LIST-TO-VARIABLES-VECTOR
    ZERO-VARIABLES-VECTOR))
  (CL:LET* ((VECTOR (NEW-VECTOR (LENGTH CONSLIST))))
   (CL:LET*
    ((I NULL-INTEGER) (T NULL) (ITER-000 CONSLIST) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ T (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ I ITER-001)
      (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:LET ((SELF (%THE-ARRAY VECTOR)) (VALUE T) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   VECTOR))

;;; (DEFUN (EQUIVALENT-HOLDS-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN EQUIVALENT-HOLDS-PROPOSITION? (SELF OTHER MAPPING)
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:SETQ TEST-VALUE-000
    (EQUIVALENT-FORMULAE?
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
      0)
     (%OPERATOR OTHER) MAPPING))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000
     (CL:= (CL:1- (LENGTH (%ARGUMENTS SELF)))
      (LENGTH (%ARGUMENTS OTHER))))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((ALWAYS?-000 TRUE))
      (CL:LET*
       ((ARG2 NULL) (I1 NULL-INTEGER) (ITER-000 1)
        (VECTOR-000 (%ARGUMENTS OTHER)) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM ITER-000 INDEX-000 LENGTH-000 I1))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:PROGN (CL:SETQ I1 ITER-000)
         (CL:SETQ ITER-000 (CL:1+ ITER-000)))
        (CL:PROGN
         (CL:SETQ ARG2
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
        (CL:WHEN
         (CL:NOT
          (EQUIVALENT-FORMULAE?
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
            I1)
           ARG2 MAPPING))
         (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
      (CL:SETQ TEST-VALUE-000 ALWAYS?-000))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (EQUIVALENT-COMMUTATIVE-PROPOSITIONS? BOOLEAN) ...)

(CL:DEFUN EQUIVALENT-COMMUTATIVE-PROPOSITIONS? (SELF OTHER MAPPING)
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:SETQ TEST-VALUE-000 (CL:EQ (%OPERATOR SELF) (%OPERATOR OTHER)))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000
     (CL:= (LENGTH (%ARGUMENTS SELF)) (LENGTH (%ARGUMENTS OTHER))))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((ALWAYS?-000 TRUE))
      (CL:LET*
       ((ARG1 NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:PROGN
         (CL:SETQ ARG1
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
        (CL:LET* ((TEST-VALUE-001 FALSE))
         (CL:LET* ((FOUND?-000 FALSE))
          (CL:LET*
           ((ARG2 NULL) (VECTOR-001 (%ARGUMENTS OTHER)) (INDEX-001 0)
            (LENGTH-001 (LENGTH VECTOR-001)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
           (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
            (CL:PROGN
             (CL:SETQ ARG2
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
               INDEX-001))
             (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
            (CL:WHEN (EQUIVALENT-FORMULAE? ARG1 ARG2 MAPPING)
             (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
          (CL:SETQ TEST-VALUE-001 FOUND?-000))
         (CL:SETQ TEST-VALUE-001 (CL:NOT TEST-VALUE-001))
         (CL:WHEN TEST-VALUE-001 (CL:SETQ ALWAYS?-000 FALSE)
          (CL:RETURN)))))
      (CL:SETQ TEST-VALUE-000 ALWAYS?-000))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (EQUIVALENT-PROPOSITIONS? BOOLEAN) ...)

(CL:DEFUN EQUIVALENT-PROPOSITIONS? (SELF OTHER MAPPING)
  (CL:WHEN (CL:EQ SELF OTHER)
   (CL:RETURN-FROM EQUIVALENT-PROPOSITIONS? TRUE))
  (CL:WHEN (CL:NOT (CL:EQ (%KIND SELF) (%KIND OTHER)))
   (CL:RETURN-FROM EQUIVALENT-PROPOSITIONS? FALSE))
  (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-AND)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-OR)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EQUIVALENT))
     (EQUIVALENT-COMMUTATIVE-PROPOSITIONS? SELF OTHER MAPPING))
    (CL:T
     (CL:LET* ((TEST-VALUE-001 (%KIND SELF)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-001 KWD-DESCRIPTIONS-FORALL)
         (CL:EQ TEST-VALUE-001 KWD-DESCRIPTIONS-EXISTS))
        (CL:LET*
         ((IOVARS1
           (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
            SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL))
          (IOVARS2
           (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OTHER)
            SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL)))
         (CL:WHEN (CL:NOT (CL:= (LENGTH IOVARS1) (LENGTH IOVARS2)))
          (CL:RETURN-FROM EQUIVALENT-PROPOSITIONS? FALSE))
         (CL:WHEN (CL:EQ MAPPING NULL)
          (CL:SETQ MAPPING (NEW-KEY-VALUE-LIST)))
         (CL:LET*
          ((V2 NULL) (V1 NULL) (VECTOR-000 IOVARS1) (INDEX-000 0)
           (LENGTH-000 (LENGTH VECTOR-000)) (VECTOR-001 IOVARS2)
           (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
          (CL:DECLARE
           (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001
            LENGTH-001))
          (CL:LOOP WHILE
           (CL:AND (CL:< INDEX-000 LENGTH-000)
            (CL:< INDEX-001 LENGTH-001))
           DO
           (CL:PROGN
            (CL:SETQ V1
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
              INDEX-000))
            (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
           (CL:PROGN
            (CL:SETQ V2
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
              INDEX-001))
            (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
           (INSERT-AT MAPPING V1 V2)))))
       (CL:T)))
     (CL:LET* ((TEST-VALUE-002 FALSE))
      (CL:SETQ TEST-VALUE-002
       (CL:EQ (%OPERATOR SELF) (%OPERATOR OTHER)))
      (CL:WHEN TEST-VALUE-002
       (CL:LET* ((ALWAYS?-000 TRUE))
        (CL:LET*
         ((ARG2 NULL) (ARG1 NULL) (VECTOR-002 (%ARGUMENTS SELF))
          (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002))
          (VECTOR-003 (%ARGUMENTS OTHER)) (INDEX-003 0)
          (LENGTH-003 (LENGTH VECTOR-003)))
         (CL:DECLARE
          (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002 INDEX-003
           LENGTH-003))
         (CL:LOOP WHILE
          (CL:AND (CL:< INDEX-002 LENGTH-002)
           (CL:< INDEX-003 LENGTH-003))
          DO
          (CL:PROGN
           (CL:SETQ ARG1
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-002))
             INDEX-002))
           (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
          (CL:PROGN
           (CL:SETQ ARG2
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-003))
             INDEX-003))
           (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))
          (CL:WHEN (CL:NOT (EQUIVALENT-FORMULAE? ARG1 ARG2 MAPPING))
           (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
        (CL:SETQ TEST-VALUE-002 ALWAYS?-000))
       (CL:WHEN TEST-VALUE-002
        (CL:SETQ TEST-VALUE-002
         (CL:= (LENGTH (%ARGUMENTS SELF))
          (LENGTH (%ARGUMENTS OTHER))))))
      (CL:WHEN (CL:NOT TEST-VALUE-002)
       (CL:SETQ TEST-VALUE-002
        (CL:AND (CL:NOT (CL:EQ MAPPING NULL))
         (CL:EQ (%OPERATOR SELF) SGT-DESCRIPTIONS-PL-KERNEL-KB-HOLDS)
         (EQUIVALENT-HOLDS-PROPOSITION? SELF OTHER MAPPING))))
      (CL:LET* ((VALUE-000 TEST-VALUE-002)) VALUE-000))))))

;;; (DEFUN (EQUIVALENT-FUNCTION-PROPOSITIONS? BOOLEAN) ...)

(CL:DEFUN EQUIVALENT-FUNCTION-PROPOSITIONS? (SELF OTHER MAPPING)
  (CL:WHEN
   (CL:AND (CL:EQ (%KIND SELF) KWD-DESCRIPTIONS-FUNCTION)
    (CL:EQ (%KIND OTHER) KWD-DESCRIPTIONS-FUNCTION))
   (CL:WHEN (CL:EQ MAPPING NULL)
    (CL:SETQ MAPPING (NEW-KEY-VALUE-LIST)))
   (INSERT-AT MAPPING
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
     (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS SELF)))))
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS OTHER)))
     (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS OTHER))))))
   (CL:RETURN-FROM EQUIVALENT-FUNCTION-PROPOSITIONS?
    (EQUIVALENT-PROPOSITIONS? SELF OTHER MAPPING)))
  FALSE)

;;; (DEFUN (EQUIVALENT-DESCRIPTIONS? BOOLEAN) ...)

(CL:DEFUN EQUIVALENT-DESCRIPTIONS? (SELF OTHER MAPPING)
  (CL:WHEN (CL:EQ SELF OTHER)
   (CL:RETURN-FROM EQUIVALENT-DESCRIPTIONS? TRUE))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ (DESCRIPTION-NAME SELF) NULL))
    (CL:NOT (CL:EQ (DESCRIPTION-NAME OTHER) NULL)))
   (CL:RETURN-FROM EQUIVALENT-DESCRIPTIONS? FALSE))
  (CL:WHEN (CL:NOT (CL:= (ARITY SELF) (ARITY OTHER)))
   (CL:RETURN-FROM EQUIVALENT-DESCRIPTIONS? FALSE))
  (CL:COND ((NAMED-DESCRIPTION? SELF) FALSE)
   (CL:T
    (CL:WHEN (CL:EQ MAPPING NULL)
     (CL:SETQ MAPPING (NEW-KEY-VALUE-LIST)))
    (CL:LET*
     ((V2 NULL) (V1 NULL) (VECTOR-000 (%IO-VARIABLES SELF))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
      (VECTOR-001 (%IO-VARIABLES OTHER)) (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
      DO
      (CL:PROGN
       (CL:SETQ V1
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
      (CL:PROGN
       (CL:SETQ V2
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (INSERT-AT MAPPING V1 V2)))
    (CL:LET*
     ((V2 NULL) (V1 NULL) (VECTOR-002 (%INTERNAL-VARIABLES SELF))
      (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002))
      (VECTOR-003 (%INTERNAL-VARIABLES OTHER)) (INDEX-003 0)
      (LENGTH-003 (LENGTH VECTOR-003)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002 INDEX-003 LENGTH-003))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-002 LENGTH-002) (CL:< INDEX-003 LENGTH-003))
      DO
      (CL:PROGN
       (CL:SETQ V1
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-002))
         INDEX-002))
       (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
      (CL:PROGN
       (CL:SETQ V2
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-003))
         INDEX-003))
       (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))
      (INSERT-AT MAPPING V1 V2)))
    (EQUIVALENT-FORMULAE? (%PROPOSITION SELF) (%PROPOSITION OTHER)
     MAPPING))))

;;; (DEFUN (EQUIVALENT-ENUMERATIONS? BOOLEAN) ...)

(CL:DEFUN EQUIVALENT-ENUMERATIONS? (SELF OTHER)
  (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-002 SGT-DESCRIPTIONS-STELLA-SET)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 FALSE))
       (CL:SETQ TEST-VALUE-000 (CL:= (LENGTH SELF) (LENGTH OTHER)))
       (CL:WHEN TEST-VALUE-000
        (CL:LET* ((ALWAYS?-000 TRUE))
         (CL:LET* ((M NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
          (CL:LOOP WHILE (NEXT? ITER-000) DO
           (CL:SETQ M (%VALUE ITER-000))
           (CL:WHEN (CL:NOT (MEMBER? OTHER M))
            (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
         (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
       (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000))))
    ((SUBTYPE-OF? TEST-VALUE-002 SGT-DESCRIPTIONS-STELLA-LIST)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-001 FALSE))
       (CL:SETQ TEST-VALUE-001 (CL:= (LENGTH SELF) (LENGTH OTHER)))
       (CL:WHEN TEST-VALUE-001
        (CL:LET* ((ALWAYS?-001 TRUE))
         (CL:LET* ((M NULL) (ITER-001 (%THE-CONS-LIST SELF)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:PROGN (CL:SETQ M (%%VALUE ITER-001))
            (CL:SETQ ITER-001 (%%REST ITER-001)))
           (CL:WHEN (CL:NOT (MEMBER? OTHER M))
            (CL:SETQ ALWAYS?-001 FALSE) (CL:RETURN))))
         (CL:SETQ TEST-VALUE-001 ALWAYS?-001)))
       (CL:LET* ((VALUE-001 TEST-VALUE-001)) VALUE-001))))
    (CL:T FALSE))))

;;; (DEFUN (EQUIVALENT-FORMULAE? BOOLEAN) ...)

(CL:DEFUN EQUIVALENT-FORMULAE? (SELF OTHER MAPPING)
  (CL:LET* ((SURROGATEVALUE NULL))
   (CL:WHEN (ISA? SELF SGT-DESCRIPTIONS-STELLA-SURROGATE)
    (CL:SETQ SURROGATEVALUE (%SURROGATE-VALUE SELF))
    (CL:WHEN (CL:NOT (CL:EQ SURROGATEVALUE NULL))
     (CL:SETQ SELF SURROGATEVALUE)))
   (CL:WHEN (ISA? OTHER SGT-DESCRIPTIONS-STELLA-SURROGATE)
    (CL:SETQ SURROGATEVALUE (%SURROGATE-VALUE OTHER))
    (CL:WHEN (CL:NOT (CL:EQ SURROGATEVALUE NULL))
     (CL:SETQ OTHER SURROGATEVALUE))))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ MAPPING NULL))
    (EQL? OTHER (LOOKUP MAPPING SELF)))
   (CL:RETURN-FROM EQUIVALENT-FORMULAE? TRUE))
  (CL:WHEN (EQUAL? SELF OTHER)
   (CL:RETURN-FROM EQUIVALENT-FORMULAE? TRUE))
  (CL:WHEN (CL:NOT (CL:EQ MAPPING NULL))
   (CL:WHEN
    (CL:AND *UNIFY-PROPOSITIONS?*
     (CL:OR (VARIABLE? SELF) (VARIABLE? OTHER)))
    (CL:WHEN (CL:EQ *QUERYITERATOR* NULL)
     (INSERT-AT MAPPING SELF OTHER)
     (CL:RETURN-FROM EQUIVALENT-FORMULAE? TRUE))
    (CL:LET*
     ((VALUE1 (ARGUMENT-BOUND-TO SELF))
      (VALUE2 (ARGUMENT-BOUND-TO OTHER)))
     (CL:COND
      ((CL:OR (CL:EQ VALUE1 NULL) (CL:EQ VALUE2 NULL))
       (INSERT-AT MAPPING SELF OTHER)
       (CL:RETURN-FROM EQUIVALENT-FORMULAE? TRUE))
      (CL:T
       (CL:RETURN-FROM EQUIVALENT-FORMULAE? (EQUAL? VALUE1 VALUE2)))))))
  (CL:WHEN (CL:NOT (CL:EQ (PRIMARY-TYPE SELF) (PRIMARY-TYPE OTHER)))
   (CL:RETURN-FROM EQUIVALENT-FORMULAE? FALSE))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
     (CL:PROGN (EQUIVALENT-PROPOSITIONS? SELF OTHER MAPPING)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-DESCRIPTION)
     (CL:PROGN (EQUIVALENT-DESCRIPTIONS? SELF OTHER MAPPING)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-SET)
     (CL:PROGN (EQUIVALENT-ENUMERATIONS? SELF OTHER)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-LIST)
     (CL:PROGN (EQUIVALENT-ENUMERATIONS? SELF OTHER)))
    (CL:T FALSE))))

;;; (DEFUN (SAME-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN SAME-ARGUMENTS? (VARIABLES ARGUMENTS)
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:LET* ((ALWAYS?-000 TRUE))
    (CL:LET*
     ((ARG NULL) (V NULL) (VECTOR-000 VARIABLES) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)) (VECTOR-001 ARGUMENTS)
      (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
      DO
      (CL:PROGN
       (CL:SETQ V
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
      (CL:PROGN
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (CL:WHEN (CL:NOT (CL:EQ V ARG)) (CL:SETQ ALWAYS?-000 FALSE)
       (CL:RETURN))))
    (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000
     (CL:= (LENGTH VARIABLES) (LENGTH ARGUMENTS))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFSPECIAL *UNIFY-PROPOSITIONS?* ...)

(CL:DEFVAR *UNIFY-PROPOSITIONS?* FALSE)

;;; (DEFUN (UNIFY-PROPOSITIONS? BOOLEAN) ...)

(CL:DEFUN UNIFY-PROPOSITIONS? (SELF OTHER MAPPING)
  (CL:LET* ((*UNIFY-PROPOSITIONS?* TRUE))
   (CL:DECLARE (CL:SPECIAL *UNIFY-PROPOSITIONS?*))
   (EQUIVALENT-PROPOSITIONS? SELF OTHER MAPPING)))

;;; (DEFUN (NAMED-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN NAMED-DESCRIPTION? (SELF)
  (CL:NOT (CL:EQ (%SURROGATE-VALUE-INVERSE SELF) NULL)))

;;; (DEFMETHOD (FIND-DUPLICATE-NAMED-DESCRIPTION LOGIC-OBJECT) ...)

(CL:DEFMETHOD FIND-DUPLICATE-NAMED-DESCRIPTION ((SELF DESCRIPTION))
  (CL:WHEN (NAMED-DESCRIPTION? SELF)
   (CL:RETURN-FROM FIND-DUPLICATE-NAMED-DESCRIPTION SELF))
  (CL:LET* ((PROPOSITION (%PROPOSITION SELF)))
   (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-AND)
      (CL:LET* ((ONLYGOAL NULL))
       (CL:LET*
        ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:PROGN
          (CL:SETQ ARG
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
         (CL:COND
          ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? ARG)))
          ((CL:NOT (CL:EQ ONLYGOAL NULL))
           (CL:RETURN-FROM FIND-DUPLICATE-NAMED-DESCRIPTION NULL))
          (CL:T (CL:SETQ ONLYGOAL ARG)))))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ ONLYGOAL NULL))
         (SAME-ARGUMENTS? (%IO-VARIABLES SELF)
          (CL:IF (CL:EQ (%KIND ONLYGOAL) KWD-DESCRIPTIONS-NOT)
           (%ARGUMENTS
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%THE-ARRAY (%ARGUMENTS ONLYGOAL)))
             0))
           (%ARGUMENTS ONLYGOAL))))
        (CL:RETURN-FROM FIND-DUPLICATE-NAMED-DESCRIPTION
         (EXTRACT-GOAL-DESCRIPTION ONLYGOAL NULL)))))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-NOT)
      (CL:WHEN
       (SAME-ARGUMENTS? (%IO-VARIABLES SELF)
        (%ARGUMENTS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          0)))
       (CL:RETURN-FROM FIND-DUPLICATE-NAMED-DESCRIPTION
        (EXTRACT-GOAL-DESCRIPTION PROPOSITION NULL))))
     (CL:T
      (CL:WHEN
       (SAME-ARGUMENTS? (%IO-VARIABLES SELF) (%ARGUMENTS PROPOSITION))
       (CL:RETURN-FROM FIND-DUPLICATE-NAMED-DESCRIPTION
        (EXTRACT-GOAL-DESCRIPTION PROPOSITION NULL))))))
   NULL))

;;; (DEFGLOBAL *STRINGIFIED-DESCRIPTION-INDEX* ...)

(CL:DEFVAR *STRINGIFIED-DESCRIPTION-INDEX* NULL
  "Contains a table of unnamed descriptions, indexed by the
stringification of their propositions.  Tricky: Descriptions in two
different modules could have the same stringification but be different.")

;;; (DEFUN (DELETED-LOGIC-OBJECT? BOOLEAN) ...)

(CL:DEFUN DELETED-LOGIC-OBJECT? (SELF)
  (DELETED? SELF))

;;; (DEFUN UNIQUIFY-DESCRIPTION-VARIABLES ...)

(CL:DEFUN UNIQUIFY-DESCRIPTION-VARIABLES (SELF)
  (CL:LET* ((VARIABLENAMES SYSTEM-DEFINED-ARGUMENT-NAMES))
   (CL:WHEN
    (CL:>
     (CL:+ (LENGTH (%IO-VARIABLES SELF))
      (LENGTH (%INTERNAL-VARIABLES SELF)))
     (LENGTH VARIABLENAMES))
    (CL:RETURN-FROM UNIQUIFY-DESCRIPTION-VARIABLES))
   (CL:LET*
    ((V NULL) (VECTOR-000 (%IO-VARIABLES SELF)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ V
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:WHEN
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS V)
        SYM-DESCRIPTIONS-LOGIC-ORIGINAL-SKOLEM-NAME NULL)
       NULL)
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS V)
       SYM-DESCRIPTIONS-LOGIC-ORIGINAL-SKOLEM-NAME (%SKOLEM-NAME V)
       NULL)
      (CL:LET* ((HEAD-000 (%%VALUE VARIABLENAMES)))
       (CL:SETQ VARIABLENAMES (%%REST VARIABLENAMES))
       (CL:SETF (%SKOLEM-NAME V) HEAD-000)))))
   (CL:LET*
    ((V NULL) (VECTOR-001 (%INTERNAL-VARIABLES SELF)) (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
    (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
     (CL:PROGN
      (CL:SETQ V
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
        INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:WHEN
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS V)
        SYM-DESCRIPTIONS-LOGIC-ORIGINAL-SKOLEM-NAME NULL)
       NULL)
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS V)
       SYM-DESCRIPTIONS-LOGIC-ORIGINAL-SKOLEM-NAME (%SKOLEM-NAME V)
       NULL)
      (CL:LET* ((HEAD-001 (%%VALUE VARIABLENAMES)))
       (CL:SETQ VARIABLENAMES (%%REST VARIABLENAMES))
       (CL:SETF (%SKOLEM-NAME V) HEAD-001)))))))

;;; (DEFUN RESTORE-DESCRIPTION-VARIABLE-NAMES ...)

(CL:DEFUN RESTORE-DESCRIPTION-VARIABLE-NAMES (SELF)
  (CL:WHEN (CL:= (LENGTH (%IO-VARIABLES SELF)) 0)
   (CL:RETURN-FROM RESTORE-DESCRIPTION-VARIABLE-NAMES))
  (CL:WHEN
   (CL:EQ
    (DYNAMIC-SLOT-VALUE
     (%DYNAMIC-SLOTS
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IO-VARIABLES SELF))) 0))
     SYM-DESCRIPTIONS-LOGIC-ORIGINAL-SKOLEM-NAME NULL)
    NULL)
   (CL:RETURN-FROM RESTORE-DESCRIPTION-VARIABLE-NAMES))
  (CL:LET*
   ((V NULL) (VECTOR-000 (%IO-VARIABLES SELF)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:PROGN
     (CL:SETQ V
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS V)
        SYM-DESCRIPTIONS-LOGIC-ORIGINAL-SKOLEM-NAME NULL)
       NULL))
     (CL:SETF (%SKOLEM-NAME V)
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS V)
       SYM-DESCRIPTIONS-LOGIC-ORIGINAL-SKOLEM-NAME NULL))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS V)
      SYM-DESCRIPTIONS-LOGIC-ORIGINAL-SKOLEM-NAME NULL NULL))))
  (CL:LET*
   ((V NULL) (VECTOR-001 (%INTERNAL-VARIABLES SELF)) (INDEX-001 0)
    (LENGTH-001 (LENGTH VECTOR-001)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
   (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
    (CL:PROGN
     (CL:SETQ V
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
       INDEX-001))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS V)
        SYM-DESCRIPTIONS-LOGIC-ORIGINAL-SKOLEM-NAME NULL)
       NULL))
     (CL:SETF (%SKOLEM-NAME V)
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS V)
       SYM-DESCRIPTIONS-LOGIC-ORIGINAL-SKOLEM-NAME NULL))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS V)
      SYM-DESCRIPTIONS-LOGIC-ORIGINAL-SKOLEM-NAME NULL NULL)))))

;;; (DEFUN (CONS-TREE-LESS-THAN? BOOLEAN) ...)

(CL:DEFUN CONS-TREE-LESS-THAN? (TREE1 TREE2)
  (CL:WHEN (CL:OR (CL:EQ TREE1 NULL) (CL:EQ TREE2 NULL))
   (CL:RETURN-FROM CONS-TREE-LESS-THAN? FALSE))
  (CL:LET* ((TYPE1 (PRIMARY-TYPE TREE1)) (TYPE2 (PRIMARY-TYPE TREE2)))
   (CL:WHEN (CL:NOT (CL:EQ TYPE1 TYPE2))
    (CL:RETURN-FROM CONS-TREE-LESS-THAN?
     (< (%SYMBOL-ID TYPE1) (%SYMBOL-ID TYPE2))))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TREE1)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-CONS)
      (CL:PROGN
       (CL:LET* ((CONS2 TREE2))
        (CL:WHEN (CL:NOT (CL:= (LENGTH TREE1) (LENGTH CONS2)))
         (CL:RETURN-FROM CONS-TREE-LESS-THAN?
          (< (LENGTH TREE1) (LENGTH CONS2))))
        (CL:LET*
         ((V2 NULL) (V1 NULL) (ITER-000 TREE1) (ITER-001 CONS2))
         (CL:LOOP WHILE
          (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
           (CL:NOT (CL:EQ ITER-001 NIL)))
          DO
          (CL:PROGN (CL:SETQ V1 (%%VALUE ITER-000))
           (CL:SETQ ITER-000 (%%REST ITER-000)))
          (CL:PROGN (CL:SETQ V2 (%%VALUE ITER-001))
           (CL:SETQ ITER-001 (%%REST ITER-001)))
          (CL:COND
           ((CONS-TREE-LESS-THAN? V1 V2)
            (CL:RETURN-FROM CONS-TREE-LESS-THAN? TRUE))
           ((CONS-TREE-LESS-THAN? V2 V1)
            (CL:RETURN-FROM CONS-TREE-LESS-THAN? FALSE)))))
        FALSE)))
     ((SUBTYPE-OF? TEST-VALUE-000
       SGT-DESCRIPTIONS-STELLA-GENERALIZED-SYMBOL)
      (CL:PROGN (< (%SYMBOL-ID TREE1) (%SYMBOL-ID TREE2))))
     ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
      (CL:PROGN (WRAPPED-INTEGER-LESS-THAN? TREE1 TREE2)))
     ((SUBTYPE-OF-STRING? TEST-VALUE-000)
      (CL:PROGN (WRAPPED-STRING-LESS-THAN? TREE1 TREE2)))
     ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
      (CL:PROGN (WRAPPED-FLOAT-LESS-THAN? TREE1 TREE2)))
     (CL:T (CL:NOT (EQL? TREE1 TREE2)))))))

;;; (DEFUN (SORT-PROPOSITION-CLAUSES CONS) ...)

(CL:DEFUN SORT-PROPOSITION-CLAUSES (CLAUSES)
  (CL:LET* ((CANONICALCLAUSES NIL))
   (CL:LET* ((C NULL) (ITER-000 CLAUSES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ C (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:SETQ CANONICALCLAUSES
      (CONS (UNIQUIFY-PROPOSITION-TREE C) CANONICALCLAUSES))))
   (SORT CANONICALCLAUSES (CL:FUNCTION CONS-TREE-LESS-THAN?))))

;;; (DEFUN (UNIQUIFY-PROPOSITION-TREE OBJECT) ...)

(CL:DEFUN UNIQUIFY-PROPOSITION-TREE (TREE)
  (CL:WHEN (CL:EQ TREE NULL)
   (CL:RETURN-FROM UNIQUIFY-PROPOSITION-TREE TREE))
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-DESCRIPTIONS-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-DESCRIPTIONS-STELLA-AND)
         (CL:EQ TEST-VALUE-000 SYM-DESCRIPTIONS-STELLA-OR))
        (CL:SETF (%%REST TREE)
         (SORT-PROPOSITION-CLAUSES (%%REST TREE))))
       ((CL:EQ TEST-VALUE-000 SYM-DESCRIPTIONS-STELLA-NOT)
        (SECOND-SETTER TREE
         (UNIQUIFY-PROPOSITION-TREE (%%VALUE (%%REST TREE)))))
       ((CL:EQ TEST-VALUE-000 SYM-DESCRIPTIONS-STELLA-EXISTS)
        (THIRD-SETTER TREE
         (UNIQUIFY-PROPOSITION-TREE (%%VALUE (%%REST (%%REST TREE))))))
       ((CL:EQ TEST-VALUE-000 SYM-DESCRIPTIONS-STELLA-FORALL)
        (THIRD-SETTER TREE
         (UNIQUIFY-PROPOSITION-TREE (%%VALUE (%%REST (%%REST TREE)))))
        (CL:WHEN (CL:NOT (CL:EQ (FOURTH TREE) NULL))
         (FOURTH-SETTER TREE
          (UNIQUIFY-PROPOSITION-TREE (FOURTH TREE)))))
       (CL:T)))))
   (CL:T))
  TREE)

;;; (DEFUN (FIND-EXACT-DUPLICATE-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN FIND-EXACT-DUPLICATE-DESCRIPTION (SELF)
  (UNIQUIFY-DESCRIPTION-VARIABLES SELF)
  (CL:LET*
   ((STRINGIFICATION
     (STRINGIFY
      (UNIQUIFY-PROPOSITION-TREE
       (GENERATE-PROPOSITION (%PROPOSITION SELF)))))
    (BUCKET (LOOKUP *STRINGIFIED-DESCRIPTION-INDEX* STRINGIFICATION)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFICATION))
   (RESTORE-DESCRIPTION-VARIABLE-NAMES SELF)
   (CL:WHEN (CL:EQ BUCKET NULL)
    (INSERT-AT *STRINGIFIED-DESCRIPTION-INDEX* STRINGIFICATION
     (LIST SELF))
    (CL:RETURN-FROM FIND-EXACT-DUPLICATE-DESCRIPTION NULL))
   (REMOVE-IF BUCKET (CL:FUNCTION DELETED-LOGIC-OBJECT?))
   (CL:LET* ((D NULL) (ITER-000 (%THE-CONS-LIST BUCKET)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ D (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN
      (CL:AND (EQUIVALENT-DESCRIPTIONS? SELF D NULL)
       (CL:OR (CL:EQ (%HOME-CONTEXT SELF) (%HOME-CONTEXT D))
        (MEMB? (%ALL-SUPER-CONTEXTS (%HOME-CONTEXT SELF))
         (%HOME-CONTEXT D))))
      (CL:RETURN-FROM FIND-EXACT-DUPLICATE-DESCRIPTION D))))
   (PUSH BUCKET SELF) NULL))

;;; (DEFUN HELP-COLLECT-CONSTANT-REFERENCES ...)

(CL:DEFUN HELP-COLLECT-CONSTANT-REFERENCES (SELF COLLECTION STOPATONE?)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:PROGN
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
        (HELP-COLLECT-CONSTANT-REFERENCES ARG COLLECTION STOPATONE?)
        (CL:WHEN (CL:AND STOPATONE? (NON-EMPTY? COLLECTION))
         (CL:RETURN-FROM HELP-COLLECT-CONSTANT-REFERENCES))))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (HELP-COLLECT-CONSTANT-REFERENCES (%SURROGATE-VALUE SELF)
       COLLECTION STOPATONE?)))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-DESCRIPTION)
     (CL:PROGN
      (HELP-COLLECT-CONSTANT-REFERENCES (%PROPOSITION SELF) COLLECTION
       STOPATONE?)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN (INSERT-NEW COLLECTION SELF)))
    (CL:T))))

;;; (DEFUN (COLLECT-CONSTANT-DESCRIPTION-REFERENCES (LIST OF LOGIC-OBJECT)) ...)

(CL:DEFUN COLLECT-CONSTANT-DESCRIPTION-REFERENCES (SELF COLLECTION STOPATONE?)
  (CL:WHEN (CL:EQ COLLECTION NULL) (CL:SETQ COLLECTION (NEW-LIST)))
  (HELP-COLLECT-CONSTANT-REFERENCES (%PROPOSITION SELF) COLLECTION
   STOPATONE?)
  COLLECTION)

;;; (DEFUN (FIND-DUPLICATE-DESCRIPTION-WITH-CONSTANT-REFERENCE DESCRIPTION) ...)

(CL:DEFUN FIND-DUPLICATE-DESCRIPTION-WITH-CONSTANT-REFERENCE (SELF)
  (CL:LET*
   ((REFERENCEDCONSTANT
     (FIRST (COLLECT-CONSTANT-DESCRIPTION-REFERENCES SELF NULL TRUE))))
   (CL:WHEN (CL:NOT (CL:EQ REFERENCEDCONSTANT NULL))
    (CL:LET* ((MAPPING NULL))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES NULL)
        NULL))
      (CL:WHEN (CL:EQ *QUERYITERATOR* NULL)
       (CL:RETURN-FROM
        FIND-DUPLICATE-DESCRIPTION-WITH-CONSTANT-REFERENCE NULL))
      (CL:LET*
       ((V NULL)
        (VECTOR-000
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
          SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES NULL))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:PROGN
         (CL:SETQ V
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
        (CL:LET* ((BINDING (ARGUMENT-BOUND-TO V)))
         (CL:WHEN (CL:EQ BINDING NULL)
          (CL:RETURN-FROM
           FIND-DUPLICATE-DESCRIPTION-WITH-CONSTANT-REFERENCE NULL))
         (INSERT-AT MAPPING V BINDING)))))
     (CL:LET*
      ((DEP NULL)
       (ITER-000
        (%THE-CONS-LIST (DEPENDENT-DESCRIPTIONS REFERENCEDCONSTANT))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ DEP (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:WHEN
        (CL:AND (CL:NOT (DELETED? DEP))
         (EQUIVALENT-DESCRIPTIONS? DEP SELF MAPPING))
        (CL:RETURN-FROM
         FIND-DUPLICATE-DESCRIPTION-WITH-CONSTANT-REFERENCE DEP))))))
   NULL))

;;; (DEFUN (FIND-DUPLICATE-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN FIND-DUPLICATE-DESCRIPTION (SELF)
  (CL:LET* ((DUPLICATE NULL))
   (CL:IF (NAMED-DESCRIPTION? SELF) (CL:PROGN NULL)
    (CL:LET* ()
     (CL:SETQ DUPLICATE (FIND-DUPLICATE-NAMED-DESCRIPTION SELF))
     (CL:IF (CL:NOT (CL:EQ DUPLICATE NULL)) (CL:PROGN DUPLICATE)
      (CL:LET* ()
       (CL:SETQ DUPLICATE (FIND-EXACT-DUPLICATE-DESCRIPTION SELF))
       (CL:IF (CL:NOT (CL:EQ DUPLICATE NULL)) (CL:PROGN DUPLICATE)
        (CL:PROGN NULL))))))))

;;; (DEFUN ADD-DEPENDENT-DESCRIPTION-LINK ...)

(CL:DEFUN ADD-DEPENDENT-DESCRIPTION-LINK (SELF DESCRIPTION)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT)
    (CL:PROGN
     (CL:LET* ((DEPENDENTS (DEPENDENT-DESCRIPTIONS SELF)))
      (CL:WHEN (CL:EQ DEPENDENTS NIL-LIST)
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
        SYM-DESCRIPTIONS-LOGIC-DEPENDENT-DESCRIPTIONS (NEW-LIST) NULL))
      (INSERT-NEW (DEPENDENT-DESCRIPTIONS SELF) DESCRIPTION))))
   (CL:T)))

;;; (DEFUN FASTEN-DOWN-DESCRIPTION ...)

(CL:DEFUN FASTEN-DOWN-DESCRIPTION (SELF)
  (CL:LET*
   ((REF NULL)
    (ITER-000
     (%THE-CONS-LIST
      (COLLECT-CONSTANT-DESCRIPTION-REFERENCES SELF NULL FALSE))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ REF (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (ADD-DEPENDENT-DESCRIPTION-LINK REF SELF))))

;;; (DEFUN (CONTAINS-NESTED-ARGUMENT? BOOLEAN) ...)

(CL:DEFUN CONTAINS-NESTED-ARGUMENT? (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-ISA)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EQUIVALENT)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-IMPLIES))
     (CL:LET*
      ((TERM NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:PROGN
        (CL:SETQ TERM
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
       (CL:COND
        ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM)
          SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
         (CL:PROGN
          (CL:WHEN (CL:NOT (CL:EQ (%DEFINING-PROPOSITION TERM) NULL))
           (CL:RETURN-FROM CONTAINS-NESTED-ARGUMENT? TRUE))))
        (CL:T)))))
    (CL:T)))
  FALSE)

;;; (DEFUN (EXPAND-IF-PROPOSITION PROPOSITION) ...)

(CL:DEFUN EXPAND-IF-PROPOSITION (IFPROPOSITION)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS IFPROPOSITION))
    (TESTPROP
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0))
    (NEGATEDTESTPROP
     (CREATE-PROPOSITION SYM-DESCRIPTIONS-STELLA-NOT 1))
    (TRUEVALUE
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1))
    (FALSEVALUE
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 2))
    (VALUEVARIABLE
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS IFPROPOSITION)))
      (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS IFPROPOSITION))))))
    (TRUEEQUIVALENCE
     (CREATE-EQUIVALENCE-PROPOSITION VALUEVARIABLE TRUEVALUE))
    (FALSEEQUIVALENCE
     (CL:IF (CL:NOT (CL:EQ FALSEVALUE NULL))
      (CREATE-EQUIVALENCE-PROPOSITION VALUEVARIABLE FALSEVALUE) NULL)))
   (CL:SETF (%DEFINING-PROPOSITION VALUEVARIABLE) NULL)
   (CL:IF (CL:NOT (CL:EQ FALSEVALUE NULL))
    (CL:PROGN
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS NEGATEDTESTPROP)))
       (VALUE
        (CL:IF (ISA? TESTPROP SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
         TESTPROP (SHALLOW-COPY-PROPOSITION TESTPROP)))
       (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (DISJOIN-PROPOSITIONS
      (CONS-LIST (CONJOIN-TWO-PROPOSITIONS TESTPROP TRUEEQUIVALENCE)
       (CONJOIN-TWO-PROPOSITIONS NEGATEDTESTPROP FALSEEQUIVALENCE))))
    (CONJOIN-TWO-PROPOSITIONS TESTPROP TRUEEQUIVALENCE))))

;;; (DEFUN HELP-COLLECT-FLATTENED-ARGUMENTS ...)

(CL:DEFUN HELP-COLLECT-FLATTENED-ARGUMENTS (SELF FLATTENEDARGUMENTS EXISTSVARIABLES)
  (CL:LET*
   ((TERM NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:PROGN
     (CL:SETQ TERM
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM)
       SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
      (CL:PROGN
       (CL:LET* ((FUNCTIONARG (%DEFINING-PROPOSITION TERM)))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ FUNCTIONARG NULL))
          (CL:NOT (MEMBER? EXISTSVARIABLES TERM)))
         (PUSH EXISTSVARIABLES TERM)
         (HELP-COLLECT-FLATTENED-ARGUMENTS FUNCTIONARG
          FLATTENEDARGUMENTS EXISTSVARIABLES)
         (CL:IF
          (CL:EQ (%OPERATOR FUNCTIONARG)
           SGT-DESCRIPTIONS-STELLA-PROPOSITION.IF)
          (PUSH FLATTENEDARGUMENTS (EXPAND-IF-PROPOSITION FUNCTIONARG))
          (PUSH FLATTENEDARGUMENTS FUNCTIONARG))))))
     (CL:T)))))

;;; (DEFUN (YIELD-FLATTENED-ARGUMENTS (LIST OF PROPOSITION)) ...)

(CL:DEFUN YIELD-FLATTENED-ARGUMENTS (PROPOSITION EXISTSVARIABLES)
  (CL:LET* ((FLATTENEDARGUMENTS (NEW-LIST)))
   (HELP-COLLECT-FLATTENED-ARGUMENTS PROPOSITION FLATTENEDARGUMENTS
    EXISTSVARIABLES)
   (PUSH FLATTENEDARGUMENTS PROPOSITION) (REVERSE EXISTSVARIABLES)
   (REVERSE FLATTENEDARGUMENTS)))

;;; (DEFUN (FLATTEN-NESTED-FUNCTION-ARGUMENTS PROPOSITION) ...)

(CL:DEFUN FLATTEN-NESTED-FUNCTION-ARGUMENTS (PROPOSITION)
  (CL:LET*
   ((EXISTSPROPOSITION
     (CREATE-PROPOSITION SYM-DESCRIPTIONS-STELLA-EXISTS 1))
    (EXISTSVARIABLES (NEW-LIST))
    (FLATTENEDPROPOSITIONS
     (YIELD-FLATTENED-ARGUMENTS PROPOSITION EXISTSVARIABLES))
    (ANDPROPOSITION
     (CREATE-PROPOSITION SYM-DESCRIPTIONS-STELLA-AND
      (LENGTH FLATTENEDPROPOSITIONS))))
   (CL:LET*
    ((I NULL-INTEGER) (PROP NULL)
     (ITER-000 (%THE-CONS-LIST FLATTENEDPROPOSITIONS)) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ PROP (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ I ITER-001)
      (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS ANDPROPOSITION))) (VALUE PROP)
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:LET* ((VBL NULL) (ITER-002 (%THE-CONS-LIST EXISTSVARIABLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:PROGN (CL:SETQ VBL (%%VALUE ITER-002))
      (CL:SETQ ITER-002 (%%REST ITER-002)))
     (CL:SETF (%DEFINING-PROPOSITION VBL) NULL)))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS EXISTSPROPOSITION)
    SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES
    (COPY-CONS-LIST-TO-VARIABLES-VECTOR
     (%THE-CONS-LIST EXISTSVARIABLES))
    NULL)
   (FREE EXISTSVARIABLES)
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS EXISTSPROPOSITION)))
     (VALUE ANDPROPOSITION) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   EXISTSPROPOSITION))

;;; (DEFUN COLLAPSE-VALUE-OF-CHAINS-FOR-IO-VARIABLES ...)

(CL:DEFUN COLLAPSE-VALUE-OF-CHAINS-FOR-IO-VARIABLES (IOVARIABLES)
  (CL:LET* ((TIGHTESTVARIABLE NULL))
   (CL:LET*
    ((I NULL-INTEGER) (VBL NULL) (VECTOR-000 IOVARIABLES) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-000 I))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ VBL
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:PROGN (CL:SETQ I ITER-000)
      (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:WHEN (CL:NOT (CL:EQ VBL (INNERMOST-VARIABLE-OF VBL)))
      (CL:SETQ TIGHTESTVARIABLE (INNERMOST-VARIABLE-OF VBL))
      (CL:LET
       ((SELF (%THE-ARRAY IOVARIABLES)) (VALUE TIGHTESTVARIABLE)
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETF (%SKOLEM-NAME TIGHTESTVARIABLE) (%SKOLEM-NAME VBL))
      (CL:LET*
       ((OBJECT-000 TIGHTESTVARIABLE) (VALUE-000 NIL)
        (OLD-VALUE-000 (%VARIABLE-VALUE-INVERSE OBJECT-000))
        (NEW-VALUE-000
         (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
          (%HOME-CONTEXT OBJECT-000) FALSE)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
           SGT-DESCRIPTIONS-STELLA-CS-VALUE)))
        (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-000) NEW-VALUE-000)))
      (FREE VBL))))))

;;; (DEFUN (REMOVE-NULLS-IN-VARIABLES-VECTOR VARIABLES-VECTOR) ...)

(CL:DEFUN REMOVE-NULLS-IN-VARIABLES-VECTOR (IOVARIABLES)
  (CL:WHEN (CL:NOT (MEMBER? IOVARIABLES NULL))
   (CL:RETURN-FROM REMOVE-NULLS-IN-VARIABLES-VECTOR IOVARIABLES))
  (CL:LET* ((NEWVBLLIST NIL) (RESULT NULL))
   (CL:LET*
    ((VBL NULL) (VECTOR-000 IOVARIABLES) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ VBL
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:WHEN (CL:NOT (CL:EQ VBL NULL))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS VBL NIL))
        (CL:IF (CL:EQ NEWVBLLIST NIL) (CL:SETQ NEWVBLLIST COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST NEWVBLLIST COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VBL NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:SETQ RESULT (COPY-CONS-LIST-TO-VARIABLES-VECTOR NEWVBLLIST))
   RESULT))

;;; (DEFUN COLLAPSE-VALUE-OF-CHAINS ...)

(CL:DEFUN COLLAPSE-VALUE-OF-CHAINS (DESCRIPTION)
  (TIGHTEN-ARGUMENT-BINDINGS (%PROPOSITION DESCRIPTION)
   (%IO-VARIABLES DESCRIPTION))
  (COLLAPSE-VALUE-OF-CHAINS-FOR-IO-VARIABLES
   (%IO-VARIABLES DESCRIPTION))
  (CL:LET* ((VALUE NULL))
   (CL:LET*
    ((I NULL-INTEGER) (VBL NULL)
     (VECTOR-000 (%INTERNAL-VARIABLES DESCRIPTION)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-000 I))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ VBL
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:PROGN (CL:SETQ I ITER-000)
      (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:WHEN
      (CL:AND
       (CL:NOT
        (CL:EQ
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE VBL) (%HOME-CONTEXT VBL)
          FALSE)
         NULL))
       (VARIABLE?
        (ACCESS-IN-CONTEXT (%VARIABLE-VALUE VBL) (%HOME-CONTEXT VBL)
         FALSE)))
      (CL:SETQ VALUE
       (ACCESS-IN-CONTEXT (%VARIABLE-VALUE VBL) (%HOME-CONTEXT VBL)
        FALSE))
      (CL:LET
       ((SELF (%THE-ARRAY (%INTERNAL-VARIABLES DESCRIPTION)))
        (VALUE NULL) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:COND
       ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE VALUE)
         SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT)
        (CL:PROGN
         (CL:WHEN
          (CL:NOT
           (MEMBER? (%IO-VARIABLES DESCRIPTION)
            (VARIABLE-VALUE-INVERSE VALUE)))
          (CL:LET*
           ((OBJECT-000 VALUE) (VALUE-000 NIL)
            (OLD-VALUE-003 (%VARIABLE-VALUE-INVERSE OBJECT-000))
            (NEW-VALUE-000
             (UPDATE-IN-CONTEXT OLD-VALUE-003 VALUE-000
              (%HOME-CONTEXT OBJECT-000) FALSE)))
           (CL:WHEN
            (CL:NOT
             (CL:AND (CL:NOT (CL:EQ OLD-VALUE-003 NULL))
              (CL:EQ (PRIMARY-TYPE OLD-VALUE-003)
               SGT-DESCRIPTIONS-STELLA-CS-VALUE)))
            (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-000)
             NEW-VALUE-000))))))
       (CL:T))
      (FREE VBL))))
   (CL:LET*
    ((I NULL-INTEGER) (VBL NULL)
     (VECTOR-001 (%INTERNAL-VARIABLES DESCRIPTION)) (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 ITER-001 I))
    (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
     (CL:PROGN
      (CL:SETQ VBL
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
        INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:PROGN (CL:SETQ I ITER-001)
      (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:WHEN (MEMBER? (%IO-VARIABLES DESCRIPTION) VBL)
      (CL:SETQ VALUE VBL)
      (CL:LET
       ((SELF (%THE-ARRAY (%INTERNAL-VARIABLES DESCRIPTION)))
        (VALUE NULL) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE)))))
   (CL:SETF (%INTERNAL-VARIABLES DESCRIPTION)
    (REMOVE-NULLS-IN-VARIABLES-VECTOR
     (%INTERNAL-VARIABLES DESCRIPTION)))))

;;; (DEFUN TIGHTEN-ARGUMENT-BINDINGS ...)

(CL:DEFUN TIGHTEN-ARGUMENT-BINDINGS (PROPOSITION IOVARIABLES)
  (CL:LET* ((TIGHTENEDACHAIN? FALSE))
   (CL:LET*
    ((I NULL-INTEGER) (ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-000 I))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:PROGN (CL:SETQ I ITER-000)
      (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
        (CL:PROGN
         (CL:LET*
          ((VALUE
            (CL:IF
             (CL:AND (CL:NOT (CL:EQ IOVARIABLES NULL))
              (MEMBER? IOVARIABLES ARG))
             (INNERMOST-VARIABLE-OF ARG) (INNERMOST-OF ARG))))
          (CL:WHEN (CL:NOT (CL:EQ VALUE ARG))
           (CL:LET
            ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION))) (VALUE VALUE)
             (POSITION I))
            (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
             (CL:TYPE CL:FIXNUM POSITION))
            (CL:SETF (CL:AREF SELF POSITION) VALUE))
           (CL:SETQ TIGHTENEDACHAIN? TRUE)))))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
        (CL:PROGN (TIGHTEN-ARGUMENT-BINDINGS ARG IOVARIABLES)))
       (CL:T)))))
   (CL:WHEN
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
       SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL)
      NULL))
    (CL:LET*
     ((QUANTIFIEDVARIABLES
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
        SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL)))
     (CL:LET*
      ((I NULL-INTEGER) (VBL NULL) (VECTOR-001 QUANTIFIEDVARIABLES)
       (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)) (ITER-001 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 ITER-001 I))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:PROGN
        (CL:SETQ VBL
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (CL:PROGN (CL:SETQ I ITER-001)
        (CL:SETQ ITER-001 (CL:1+ ITER-001)))
       (CL:WHEN (CL:NOT (CL:EQ VBL (INNERMOST-VARIABLE-OF VBL)))
        (CL:LET
         ((SELF (%THE-ARRAY QUANTIFIEDVARIABLES)) (VALUE NULL)
          (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))
        (FREE VBL))))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES
      (REMOVE-NULLS-IN-VARIABLES-VECTOR QUANTIFIEDVARIABLES) NULL)
     (CL:WHEN
      (CL:=
       (%ARRAY-SIZE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
         SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL))
       0)
      (UNFASTEN-PROPOSITION PROPOSITION)
      (NORMALIZE-PROPOSITION PROPOSITION)
      (FASTEN-DOWN-ONE-PROPOSITION PROPOSITION FALSE))))
   (CL:WHEN TIGHTENEDACHAIN? (UNFASTEN-PROPOSITION PROPOSITION)
    (FASTEN-DOWN-ONE-PROPOSITION PROPOSITION FALSE))))

;;; (DEFUN COLLECT-ALL-VARIABLES ...)

(CL:DEFUN COLLECT-ALL-VARIABLES (SELF COLLECTION BEENTHERE)
  (INSERT BEENTHERE SELF)
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:PROGN
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000
        SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
       (CL:PROGN (INSERT-NEW COLLECTION ARG)))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
       (CL:PROGN
        (CL:WHEN (CL:NOT (MEMBER? BEENTHERE ARG))
         (COLLECT-ALL-VARIABLES ARG COLLECTION BEENTHERE))))
      (CL:T))))))

;;; (DEFUN COMPUTE-INTERNAL-VARIABLES ...)

(CL:DEFUN COMPUTE-INTERNAL-VARIABLES (SELF)
  (CL:LET* ((COLLECTION (NEW-LIST)) (BEENTHERE (NEW-LIST)))
   (COLLECT-ALL-VARIABLES (%PROPOSITION SELF) COLLECTION BEENTHERE)
   (CL:LET*
    ((VBL NULL) (VECTOR-000 (%IO-VARIABLES SELF)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ VBL
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (REMOVE COLLECTION VBL)))
   (CL:WHEN
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES NULL)
      NULL))
    (CL:LET*
     ((VBL NULL)
      (VECTOR-001
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
        SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES NULL))
      (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
     (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
      (CL:PROGN
       (CL:SETQ VBL
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (REMOVE COLLECTION VBL))))
   (CL:SETF (%INTERNAL-VARIABLES SELF)
    (COPY-CONS-LIST-TO-VARIABLES-VECTOR (%THE-CONS-LIST COLLECTION)))
   (FREE COLLECTION) (FREE BEENTHERE)))

;;; (DEFUN EQUATE-TOP-LEVEL-EQUIVALENCES ...)

(CL:DEFUN EQUATE-TOP-LEVEL-EQUIVALENCES (PROPOSITION)
  (CL:LET* ((ARGUMENTS (%ARGUMENTS PROPOSITION)))
   (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EQUIVALENT)
      (EQUATE-VALUES
       (INNERMOST-OF
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0))
       (INNERMOST-OF
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1))))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-AND)
      (CL:LET*
       ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:PROGN
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
        (EQUATE-TOP-LEVEL-EQUIVALENCES ARG))))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EXISTS)
      (EQUATE-TOP-LEVEL-EQUIVALENCES
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0)))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FUNCTION)
      (EVALUATE-FUNCTION-PROPOSITION PROPOSITION))
     (CL:T)))))

;;; (DEFSPECIAL *EXTERNALVARIABLES* ...)

(CL:DEFVAR *EXTERNALVARIABLES*)

;;; (DEFUN COLLECT-EXTERNAL-VARIABLES ...)

(CL:DEFUN COLLECT-EXTERNAL-VARIABLES (PROPOSITION)
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:PROGN
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000
        SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
       (CL:PROGN
        (CL:WHEN
         (CL:AND (MEMBER? *LOGICVARIABLETABLE* ARG)
          (CL:NOT (MEMBER? *EXTERNALVARIABLES* ARG)))
         (CL:SETQ *EXTERNALVARIABLES*
          (CONS ARG *EXTERNALVARIABLES*)))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
       (CL:PROGN (COLLECT-EXTERNAL-VARIABLES ARG)))
      (CL:T))))))

;;; (DEFUN (FINISH-BUILDING-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN FINISH-BUILDING-DESCRIPTION (DESCRIPTION CHECKFORDUPLICATE?)
  (CL:LET* ((PROPOSITION (%PROPOSITION DESCRIPTION)))
   (NORMALIZE-PROPOSITION PROPOSITION)
   (CL:WHEN (CL:EQ (%KIND PROPOSITION) KWD-DESCRIPTIONS-EXISTS)
    (CL:SETQ PROPOSITION
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (CL:SETF (%PROPOSITION DESCRIPTION) PROPOSITION))
   (RESOLVE-UNRESOLVED-SLOT-REFERENCES DESCRIPTION)
   (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS PROPOSITION FALSE)
   (UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS PROPOSITION)
   (CL:HANDLER-CASE (EQUATE-TOP-LEVEL-EQUIVALENCES PROPOSITION)
    (CLASH (E)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
      (EXCEPTION-MESSAGE E) EOL))))
  (COLLAPSE-VALUE-OF-CHAINS DESCRIPTION)
  (SIMPLIFY-DESCRIPTION DESCRIPTION FALSE)
  (COMPUTE-INTERNAL-VARIABLES DESCRIPTION)
  (CL:WHEN CHECKFORDUPLICATE?
   (CL:LET*
    ((DUPLICATEDESCRIPTION (FIND-DUPLICATE-DESCRIPTION DESCRIPTION)))
    (CL:WHEN (CL:NOT (CL:EQ DUPLICATEDESCRIPTION NULL))
     (FREE DESCRIPTION)
     (CL:RETURN-FROM FINISH-BUILDING-DESCRIPTION
      DUPLICATEDESCRIPTION))))
  DESCRIPTION)

;;; (DEFUN (EVALUATE-DESCRIPTION-TERM DESCRIPTION) ...)

(CL:DEFUN EVALUATE-DESCRIPTION-TERM (TERM CHECKFORDUPLICATE?)
  (CL:LET* ((DESCRIPTION (CREATE-DESCRIPTION NULL-INTEGER FALSE)))
   (CL:COND
    ((CL:EQ (%%VALUE TERM) SYM-DESCRIPTIONS-LOGIC-THE-ONLY)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS DESCRIPTION)
      SYM-DESCRIPTIONS-LOGIC-IOTA?
      (CL:IF TRUE TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
    (CL:T))
   (CL:LET*
    ((*DESCRIPTIONUNDERCONSTRUCTION* DESCRIPTION)
     (*EVALUATIONMODE* KWD-DESCRIPTIONS-DESCRIPTION)
     (*VARIABLEIDCOUNTER* *VARIABLEIDCOUNTER*))
    (CL:DECLARE
     (CL:SPECIAL *DESCRIPTIONUNDERCONSTRUCTION* *EVALUATIONMODE*
      *VARIABLEIDCOUNTER*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *VARIABLEIDCOUNTER*))
    (CL:LET* ((IOVARS NULL) (PROPOSITION NULL) (UNUSED NULL))
     (CL:MULTIPLE-VALUE-SETQ (IOVARS PROPOSITION UNUSED)
      (BUILD-QUANTIFIED-PROPOSITION TERM TRUE))
     (CL:SETQ UNUSED UNUSED)
     (CL:SETF (%IO-VARIABLES DESCRIPTION)
      (COPY-CONS-LIST-TO-VARIABLES-VECTOR IOVARS))
     (CL:WHEN (CL:NOT (CL:EQ *LOGICVARIABLETABLE* NIL))
      (CL:LET* ((*EXTERNALVARIABLES* NIL))
       (CL:DECLARE (CL:SPECIAL *EXTERNALVARIABLES*))
       (COLLECT-EXTERNAL-VARIABLES PROPOSITION)
       (CL:WHEN (CL:NOT (CL:EQ *EXTERNALVARIABLES* NIL))
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS DESCRIPTION)
         SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES
         (COPY-CONS-LIST-TO-VARIABLES-VECTOR *EXTERNALVARIABLES*)
         NULL))))
     (CL:SETF (%PROPOSITION DESCRIPTION)
      (CL:IF (CL:NOT (CL:EQ PROPOSITION NULL)) PROPOSITION
       TRUE-PROPOSITION)))
    (FINISH-BUILDING-DESCRIPTION DESCRIPTION FALSE)
    (CL:WHEN CHECKFORDUPLICATE?
     (CL:LET* ((DUPLICATE (FIND-DUPLICATE-DESCRIPTION DESCRIPTION)))
      (CL:WHEN (CL:NOT (CL:EQ DUPLICATE NULL))
       (CL:RETURN-FROM EVALUATE-DESCRIPTION-TERM DUPLICATE))
      (FASTEN-DOWN-DESCRIPTION DESCRIPTION)))
    DESCRIPTION)))

;;; (DEFUN (REMOVE-VARIABLE-TYPE-PROPOSITIONS (CONS OF PROPOSITION)) ...)

(CL:DEFUN REMOVE-VARIABLE-TYPE-PROPOSITIONS (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-AND)
     (CL:LET* ((TYPEDECLARATIONS NIL) (GOALPROPOSITION NULL))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:PROGN
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
        (CL:COND
         ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? ARG))
          (CL:SETQ TYPEDECLARATIONS (CONS ARG TYPEDECLARATIONS)))
         ((CL:NOT (CL:EQ GOALPROPOSITION NULL)))
         (CL:T (CL:SETQ GOALPROPOSITION ARG)))))
      (OVERLAY-PROPOSITION PROPOSITION GOALPROPOSITION)
      (CL:RETURN-FROM REMOVE-VARIABLE-TYPE-PROPOSITIONS
       TYPEDECLARATIONS)))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-ISA)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-NOT))
     (CL:RETURN-FROM REMOVE-VARIABLE-TYPE-PROPOSITIONS NIL))
    (CL:T)))
  NIL)

;;; (DEFSPECIAL *RECURSIVEGETCOMPLEMENTARGUMENT* ...)

(CL:DEFVAR *RECURSIVEGETCOMPLEMENTARGUMENT* NULL
  "Used to prevent infinite looping.")

;;; (DEFUN (GET-COMPLEMENT-OF-GOAL-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN GET-COMPLEMENT-OF-GOAL-DESCRIPTION (SELF)
  (CL:LET*
   ((COMPLEMENT
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-DESCRIPTIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL)))
   (CL:WHEN (CL:NOT (CL:EQ COMPLEMENT NULL))
    (CL:RETURN-FROM GET-COMPLEMENT-OF-GOAL-DESCRIPTION COMPLEMENT))
   (CL:WHEN (CL:EQ SELF *RECURSIVEGETCOMPLEMENTARGUMENT*)
    (CL:RETURN-FROM GET-COMPLEMENT-OF-GOAL-DESCRIPTION NULL))
   (CL:LET* ((*MODULE* (HOME-MODULE SELF)) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:LET* ((DECLARATIONS NIL) (VARIABLES NIL) (CLAUSES NIL))
     (CL:LET*
      ((TYPE NULL) (V NULL) (VECTOR-000 (%IO-VARIABLES SELF))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
       (ITER-000 (%THE-CONS-LIST (%IO-VARIABLE-TYPES SELF)))
       (COLLECT-000 NULL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE
       (CL:AND (CL:< INDEX-000 LENGTH-000)
        (CL:NOT (CL:EQ ITER-000 NIL)))
       DO
       (CL:PROGN
        (CL:SETQ V
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
       (CL:PROGN (CL:SETQ TYPE (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:IF (CL:OR (CL:EQ TYPE NULL) (CLASS-DESCRIPTION? SELF))
        (CL:SETQ DECLARATIONS (CONS (%SKOLEM-NAME V) DECLARATIONS))
        (CL:SETQ DECLARATIONS
         (CONS
          (CONS (%SKOLEM-NAME V) (CONS (SURROGATE-TO-SYMBOL TYPE) NIL))
          DECLARATIONS)))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS (%SKOLEM-NAME V) NIL))
         (CL:IF (CL:EQ VARIABLES NIL) (CL:SETQ VARIABLES COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST VARIABLES COLLECT-000)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-000) (CONS (%SKOLEM-NAME V) NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
     (CL:SETQ DECLARATIONS (REVERSE DECLARATIONS))
     (CL:SETQ CLAUSES
      (CONS
       (LIST* SYM-DESCRIPTIONS-STELLA-NOT
        (CONS (DESCRIPTION-NAME SELF) (CONCATENATE VARIABLES NIL)) NIL)
       NIL))
     (CL:WHEN (CLASS-DESCRIPTION? SELF)
      (CL:LET*
       ((P NULL) (ITER-001 (ALL-DIRECT-SUPERRELATIONS SELF TRUE)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:PROGN (CL:SETQ P (%%VALUE ITER-001))
         (CL:SETQ ITER-001 (%%REST ITER-001)))
        (CL:SETQ CLAUSES
         (CONS
          (CONS (DESCRIPTION-NAME P) (CONS (%%VALUE VARIABLES) NIL))
          CLAUSES)))))
     (CL:LET* ((*RECURSIVEGETCOMPLEMENTARGUMENT* SELF))
      (CL:DECLARE (CL:SPECIAL *RECURSIVEGETCOMPLEMENTARGUMENT*))
      (CL:SETQ COMPLEMENT
       (CONCEIVE-TERM
        (LIST* SYM-DESCRIPTIONS-LOGIC-KAPPA DECLARATIONS
         (CONS
          (CONS SYM-DESCRIPTIONS-STELLA-AND (CONCATENATE CLAUSES NIL))
          NIL)))))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-DESCRIPTIONS-LOGIC-COMPLEMENT-DESCRIPTION COMPLEMENT NULL)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS COMPLEMENT)
      SYM-DESCRIPTIONS-LOGIC-COMPLEMENT-DESCRIPTION SELF NULL)
     (DERIVE-DEFERRED-CONTRAPOSITIVE-SATELLITE-RULES SELF) COMPLEMENT))))

;;; (DEFUN COLLECT-FREE-VARIABLES ...)

(CL:DEFUN COLLECT-FREE-VARIABLES (SELF COLLECTION QUANTIFIEDVARS BEENTHERE)
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-001
      SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN
      (CL:WHEN (CL:NOT (MEMBER? QUANTIFIEDVARS SELF))
       (INSERT-NEW COLLECTION SELF))))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:WHEN (CL:NOT (MEMBER? BEENTHERE SELF))
       (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
        (CL:COND
         ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FORALL)
           (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EXISTS))
          (CL:LET*
           ((V NULL)
            (VECTOR-000
             (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
              SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL))
            (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
           (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
            (CL:PROGN
             (CL:SETQ V
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
               INDEX-000))
             (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
            (INSERT QUANTIFIEDVARS V))))
         (CL:T)))
       (INSERT BEENTHERE SELF)
       (CL:LET*
        ((ARG NULL) (VECTOR-001 (%ARGUMENTS SELF)) (INDEX-001 0)
         (LENGTH-001 (LENGTH VECTOR-001)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
        (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
         (CL:PROGN
          (CL:SETQ ARG
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
            INDEX-001))
          (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
         (COLLECT-FREE-VARIABLES ARG COLLECTION QUANTIFIEDVARS
          BEENTHERE))))))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-DESCRIPTIONS-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:LET*
       ((V NULL) (VECTOR-002 (%IO-VARIABLES SELF)) (INDEX-002 0)
        (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
       (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
        (CL:PROGN
         (CL:SETQ V
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-002))
           INDEX-002))
         (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
        (INSERT QUANTIFIEDVARS V)))
      (CL:LET*
       ((V NULL) (ITER-000 (TOP-LEVEL-EXISTENTIAL-VARIABLES SELF)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:PROGN (CL:SETQ V (%%VALUE ITER-000))
         (CL:SETQ ITER-000 (%%REST ITER-000)))
        (INSERT QUANTIFIEDVARS V)))
      (COLLECT-FREE-VARIABLES (%PROPOSITION SELF) COLLECTION
       QUANTIFIEDVARS BEENTHERE)))
    (CL:T))))

;;; (DEFUN (TOP-LEVEL-EXISTENTIAL-VARIABLES (CONS OF PATTERN-VARIABLE)) ...)

(CL:DEFUN TOP-LEVEL-EXISTENTIAL-VARIABLES (SELF)
  (CL:LET*
   ((QUANTIFIEDVARIABLES (NEW-LIST)) (BEENTHERE (NEW-LIST))
    (COLLECTION (NEW-LIST)))
   (CL:LET*
    ((V NULL) (VECTOR-000 (%IO-VARIABLES SELF)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ V
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (INSERT QUANTIFIEDVARIABLES V)))
   (CL:WHEN
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES NULL)
      NULL))
    (CL:LET*
     ((V NULL)
      (VECTOR-001
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
        SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES NULL))
      (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
     (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
      (CL:PROGN
       (CL:SETQ V
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (INSERT QUANTIFIEDVARIABLES V))))
   (CL:WHEN (CL:EQ (%PROPOSITION SELF) NULL)
    (CL:RETURN-FROM TOP-LEVEL-EXISTENTIAL-VARIABLES
     (%THE-CONS-LIST QUANTIFIEDVARIABLES)))
   (COLLECT-FREE-VARIABLES (%PROPOSITION SELF) COLLECTION
    QUANTIFIEDVARIABLES BEENTHERE)
   (FREE QUANTIFIEDVARIABLES) (FREE BEENTHERE)
   (%THE-CONS-LIST COLLECTION)))

;;; (DEFUN (TOP-LEVEL-EXISTENTIAL-VARIABLE? BOOLEAN) ...)

(CL:DEFUN TOP-LEVEL-EXISTENTIAL-VARIABLE? (VARIABLE DESCRIPTION)
  (CL:AND (CL:NOT (MEMBER? (%IO-VARIABLES DESCRIPTION) VARIABLE))
   (MEMBER? (%INTERNAL-VARIABLES DESCRIPTION) VARIABLE)
   (FREE-VARIABLE? VARIABLE (%PROPOSITION DESCRIPTION))))

;;; (DEFUN (FREE-VARIABLE? BOOLEAN) ...)

(CL:DEFUN FREE-VARIABLE? (VARIABLE PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FORALL)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EXISTS))
     (CL:WHEN
      (MEMBER?
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
        SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL)
       VARIABLE)
      (CL:RETURN-FROM FREE-VARIABLE? FALSE)))
    (CL:T)))
  (CL:LET* ((ALWAYS?-000 TRUE))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:WHEN (ISA? ARG SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
      (CL:WHEN (CL:NOT (FREE-VARIABLE? VARIABLE ARG))
       (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN)))))
   (CL:LET* ((VALUE-000 ALWAYS?-000)) VALUE-000)))

;;; (DEFUN (MOST-SPECIFIC-TYPES (LIST OF TYPE)) ...)

(CL:DEFUN MOST-SPECIFIC-TYPES (TYPES)
  (CL:WHEN (CL:EQ (REST TYPES) NULL)
   (CL:RETURN-FROM MOST-SPECIFIC-TYPES TYPES))
  (CL:LET*
   ((CURSOR1 (%THE-CONS-LIST TYPES)) (CURSOR2 NULL) (VALUE1 NULL)
    (VALUE2 NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR1 NIL)) DO
    (CL:SETQ VALUE1 (%%VALUE CURSOR1))
    (CL:WHEN (CL:NOT (CL:EQ (%%VALUE CURSOR1) NULL))
     (CL:SETQ CURSOR2 (%%REST CURSOR1))
     (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR2 NIL)) DO
      (CL:SETQ VALUE2 (%%VALUE CURSOR2))
      (CL:WHEN (CL:NOT (CL:EQ VALUE2 NULL))
       (CL:IF (LOGICAL-SUBTYPE-OF? VALUE1 VALUE2)
        (CL:SETF (%%VALUE CURSOR2) NULL)
        (CL:WHEN (LOGICAL-SUBTYPE-OF? VALUE2 VALUE1)
         (CL:SETF (%%VALUE CURSOR1) NULL) (CL:RETURN))))
      (CL:SETQ CURSOR2 (%%REST CURSOR2))))
    (CL:SETQ CURSOR1 (%%REST CURSOR1))))
  (REMOVE TYPES NULL)
  TYPES)

;;; (DEFSPECIAL *ADDEDNEWTYPE?* ...)

(CL:DEFVAR *ADDEDNEWTYPE?* FALSE
  "Used by 'infer-variable-types'.")

;;; (DEFUN ADD-VARIABLE-TYPE ...)

(CL:DEFUN ADD-VARIABLE-TYPE (VARIABLE NEWTYPE TABLE VISIBLEVARIABLES)
  (CL:WHEN (CL:NOT (MEMBER? VISIBLEVARIABLES VARIABLE))
   (CL:RETURN-FROM ADD-VARIABLE-TYPE))
  (CL:LET* ((TYPES (LOOKUP TABLE VARIABLE)))
   (CL:IF (CL:EQ TYPES NULL) (INSERT-AT TABLE VARIABLE (LIST NEWTYPE))
    (CL:PROGN
     (CL:LET* ((T NULL) (ITER-000 (%THE-CONS-LIST TYPES)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ T (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:WHEN (LOGICAL-SUBTYPE-OF? T NEWTYPE)
        (CL:RETURN-FROM ADD-VARIABLE-TYPE))
       (CL:WHEN (LOGICAL-SUBTYPE-OF? NEWTYPE T) (REMOVE TYPES T)
        (ADD-VARIABLE-TYPE VARIABLE NEWTYPE TABLE VISIBLEVARIABLES)
        (CL:RETURN-FROM ADD-VARIABLE-TYPE))))
     (INSERT TYPES NEWTYPE)))
   (CL:SETQ *ADDEDNEWTYPE?* TRUE)))

;;; (DEFUN (INFER-PREDICATE-FROM-OPERATOR-AND-TYPES OBJECT) ...)

(CL:DEFUN INFER-PREDICATE-FROM-OPERATOR-AND-TYPES (OPERATOR TYPES)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OPERATOR)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF
       (ISA? (%SURROGATE-VALUE OPERATOR) SGT-DESCRIPTIONS-STELLA-SLOT)
       (CL:LET* ((SLOT (%SURROGATE-VALUE OPERATOR)))
        (CL:SETQ SLOT
         (INFER-PREDICATE-FROM-OPERATOR-AND-TYPES (%SLOT-NAME SLOT)
          TYPES))
        (CL:IF (CL:NOT (CL:EQ SLOT NULL))
         (CL:RETURN-FROM INFER-PREDICATE-FROM-OPERATOR-AND-TYPES SLOT)
         (CL:RETURN-FROM INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
          (%SURROGATE-VALUE OPERATOR))))
       (CL:RETURN-FROM INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
        (%SURROGATE-VALUE OPERATOR)))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((SLOTREF NULL))
       (CL:LET* ((TYPE NULL) (ITER-000 (%THE-CONS-LIST TYPES)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:PROGN (CL:SETQ TYPE (%%VALUE ITER-000))
          (CL:SETQ ITER-000 (%%REST ITER-000)))
         (CL:WHEN
          (ISA? (%SURROGATE-VALUE TYPE) SGT-DESCRIPTIONS-STELLA-CLASS)
          (CL:SETQ SLOTREF (LOOKUP-SLOTREF TYPE OPERATOR))
          (CL:WHEN (CL:NOT (CL:EQ SLOTREF NULL))
           (CL:RETURN-FROM INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
            (%SURROGATE-VALUE SLOTREF)))
          (CL:WHEN (LOGICAL-SUBTYPE-OF-LITERAL? TYPE)
           (CL:SETQ TYPE (TYPE-TO-WRAPPED-TYPE TYPE))
           (CL:SETQ SLOTREF (LOOKUP-SLOTREF TYPE OPERATOR))
           (CL:WHEN (CL:NOT (CL:EQ SLOTREF NULL))
            (CL:RETURN-FROM INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
             (%SURROGATE-VALUE SLOTREF))))))))))
    (CL:T)))
  NULL)

;;; (DEFUN INFER-TYPES-FROM-ONE-PROPOSITION ...)

(CL:DEFUN INFER-TYPES-FROM-ONE-PROPOSITION (PROPOSITION TABLE VISIBLEVARS)
  (CL:WHEN (CL:= (LENGTH (%ARGUMENTS PROPOSITION)) 0)
   (CL:RETURN-FROM INFER-TYPES-FROM-ONE-PROPOSITION))
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS PROPOSITION))
    (FIRSTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0)))
   (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-ISA)
      (CL:WHEN (ISA? FIRSTARG SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
       (ADD-VARIABLE-TYPE FIRSTARG (%OPERATOR PROPOSITION) TABLE
        VISIBLEVARS)))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FUNCTION))
      (CL:LET* ((PREDICATE NULL))
       (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE FIRSTARG)))
        (CL:COND
         ((SUBTYPE-OF? TEST-VALUE-001
           SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
          (CL:PROGN
           (CL:LET* ((TYPES (LOOKUP TABLE FIRSTARG)))
            (CL:WHEN (CL:NOT (CL:EQ TYPES NULL))
             (CL:SETQ PREDICATE
              (INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
               (%OPERATOR PROPOSITION) TYPES))))))
         ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
          (CL:PROGN
           (CL:LET*
            ((VALUE (%SURROGATE-VALUE FIRSTARG)) (TYPES (NEW-LIST)))
            (CL:WHEN
             (CL:AND (CL:NOT (CL:EQ VALUE NULL))
              (ISA? VALUE SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT))
             (CL:LET*
              ((D NULL) (ITER-000 (ALL-ASSERTED-TYPES VALUE))
               (COLLECT-000 NULL))
              (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
               (CL:PROGN (CL:SETQ D (%%VALUE ITER-000))
                (CL:SETQ ITER-000 (%%REST ITER-000)))
               (CL:IF (CL:EQ COLLECT-000 NULL)
                (CL:PROGN
                 (CL:SETQ COLLECT-000
                  (CONS (%SURROGATE-VALUE-INVERSE D) NIL))
                 (CL:IF (CL:EQ (%THE-CONS-LIST TYPES) NIL)
                  (CL:SETF (%THE-CONS-LIST TYPES) COLLECT-000)
                  (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST TYPES)
                   COLLECT-000)))
                (CL:PROGN
                 (CL:SETF (%%REST COLLECT-000)
                  (CONS (%SURROGATE-VALUE-INVERSE D) NIL))
                 (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
             (CL:SETQ TYPES (MOST-SPECIFIC-TYPES TYPES))
             (CL:SETQ PREDICATE
              (INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
               (%OPERATOR PROPOSITION) TYPES))))))
         (CL:T
          (CL:LET* ((OPERATOR (%OPERATOR PROPOSITION)))
           (CL:WHEN
            (CL:AND (ISA? OPERATOR SGT-DESCRIPTIONS-STELLA-SURROGATE)
             (ISA? (%SURROGATE-VALUE OPERATOR)
              SGT-DESCRIPTIONS-STELLA-SLOT))
            (CL:SETQ PREDICATE (%SURROGATE-VALUE OPERATOR)))))))
       (CL:WHEN (CL:NOT (CL:EQ PREDICATE NULL))
        (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE PREDICATE)))
         (CL:COND
          ((SUBTYPE-OF? TEST-VALUE-002
            SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION)
           (CL:PROGN
            (CL:COND
             ((CL:NOT (CL:EQ (%IO-VARIABLE-TYPES PREDICATE) NULL))
              (CL:LET*
               ((TYPE NULL) (ARG NULL) (VECTOR-000 ARGUMENTS)
                (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
                (ITER-001
                 (%THE-CONS-LIST (%IO-VARIABLE-TYPES PREDICATE))))
               (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
               (CL:LOOP WHILE
                (CL:AND (CL:< INDEX-000 LENGTH-000)
                 (CL:NOT (CL:EQ ITER-001 NIL)))
                DO
                (CL:PROGN
                 (CL:SETQ ARG
                  (CL:AREF
                   (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
                   INDEX-000))
                 (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
                (CL:PROGN (CL:SETQ TYPE (%%VALUE ITER-001))
                 (CL:SETQ ITER-001 (%%REST ITER-001)))
                (CL:WHEN
                 (ISA? ARG SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
                 (ADD-VARIABLE-TYPE ARG TYPE TABLE VISIBLEVARS)))))
             (CL:T))))
          ((SUBTYPE-OF? TEST-VALUE-002 SGT-DESCRIPTIONS-STELLA-SLOT)
           (CL:PROGN
            (CL:LET*
             ((COLUMNTYPE NULL) (ARG NULL) (VECTOR-001 ARGUMENTS)
              (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001))
              (ITER-002
               (SLOT-COLUMN-TYPES PREDICATE (LENGTH ARGUMENTS))))
             (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
             (CL:LOOP WHILE
              (CL:AND (CL:< INDEX-001 LENGTH-001)
               (CL:NOT (CL:EQ ITER-002 NIL)))
              DO
              (CL:PROGN
               (CL:SETQ ARG
                (CL:AREF
                 (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
                 INDEX-001))
               (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
              (CL:PROGN (CL:SETQ COLUMNTYPE (%%VALUE ITER-002))
               (CL:SETQ ITER-002 (%%REST ITER-002)))
              (CL:WHEN
               (ISA? ARG SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
               (ADD-VARIABLE-TYPE ARG COLUMNTYPE TABLE
                VISIBLEVARS))))))
          ((SUBTYPE-OF? TEST-VALUE-002
            SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT)
           (CL:PROGN))
          (CL:T
           (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
            (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
             TEST-VALUE-002 "' is not a valid case option")
            (CL:ERROR
             (NEW-STELLA-EXCEPTION
              (THE-STRING-READER STREAM-000))))))))))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EQUIVALENT)
      (CL:LET*
       ((SECONDARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1)))
       (CL:WHEN (ISA? FIRSTARG SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
        (CL:IF (ISA? SECONDARG SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
         (CL:LET*
          ((T NULL)
           (ITER-003
            (%THE-CONS-LIST
             (MAP-NULL-TO-NIL-LIST (LOOKUP TABLE SECONDARG)))))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
           (CL:PROGN (CL:SETQ T (%%VALUE ITER-003))
            (CL:SETQ ITER-003 (%%REST ITER-003)))
           (ADD-VARIABLE-TYPE FIRSTARG T TABLE VISIBLEVARS)))
         (ADD-VARIABLE-TYPE FIRSTARG (LOGICAL-TYPE SECONDARG) TABLE
          VISIBLEVARS)))
       (CL:WHEN
        (ISA? SECONDARG SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
        (CL:IF (ISA? FIRSTARG SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
         (CL:LET*
          ((T NULL)
           (ITER-004
            (%THE-CONS-LIST
             (MAP-NULL-TO-NIL-LIST (LOOKUP TABLE FIRSTARG)))))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
           (CL:PROGN (CL:SETQ T (%%VALUE ITER-004))
            (CL:SETQ ITER-004 (%%REST ITER-004)))
           (ADD-VARIABLE-TYPE SECONDARG T TABLE VISIBLEVARS)))
         (ADD-VARIABLE-TYPE SECONDARG (LOGICAL-TYPE FIRSTARG) TABLE
          VISIBLEVARS)))))
     (CL:T)))))

;;; (DEFUN INFER-TYPES-FROM-PROPOSITIONS ...)

(CL:DEFUN INFER-TYPES-FROM-PROPOSITIONS (PROPOSITION TABLE VISIBLEVARS)
  (CL:LET* ((ARGUMENTS (%ARGUMENTS PROPOSITION)))
   (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-AND)
      (CL:LET*
       ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:PROGN
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
        (INFER-TYPES-FROM-PROPOSITIONS ARG TABLE VISIBLEVARS))))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-OR)
      (CL:LET*
       ((ARG NULL) (VECTOR-001 ARGUMENTS) (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:PROGN
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
           INDEX-001))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
        (INFER-TYPES-FROM-PROPOSITIONS ARG TABLE NIL))))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-ISA)
       (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FUNCTION)
       (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EQUIVALENT))
      (INFER-TYPES-FROM-ONE-PROPOSITION PROPOSITION TABLE VISIBLEVARS))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FORALL)
      (CL:SETQ VISIBLEVARS NIL)
      (CL:LET*
       ((V NULL)
        (VECTOR-002
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
          SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL))
        (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
       (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
        (CL:PROGN
         (CL:SETQ V
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-002))
           INDEX-002))
         (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
        (CL:SETQ VISIBLEVARS (CONS V VISIBLEVARS))))
      (INFER-TYPES-FROM-PROPOSITIONS
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0)
       TABLE VISIBLEVARS)
      (INFER-TYPES-FROM-PROPOSITIONS
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1)
       TABLE VISIBLEVARS))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EXISTS)
      (CL:LET*
       ((V NULL)
        (VECTOR-003
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
          SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL))
        (INDEX-003 0) (LENGTH-003 (LENGTH VECTOR-003)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-003 LENGTH-003))
       (CL:LOOP WHILE (CL:< INDEX-003 LENGTH-003) DO
        (CL:PROGN
         (CL:SETQ V
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-003))
           INDEX-003))
         (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))
        (CL:SETQ VISIBLEVARS (CONS V VISIBLEVARS))))
      (INFER-TYPES-FROM-PROPOSITIONS
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0)
       TABLE VISIBLEVARS))
     (CL:T)))))

;;; (DEFUN (INFER-VARIABLE-TYPES-IN-PROPOSITION VARIABLE-TYPE-TABLE) ...)

(CL:DEFUN INFER-VARIABLE-TYPES-IN-PROPOSITION (PROPOSITION VISIBLEVARIABLES)
  (CL:LET* ((VARIABLETYPESTABLE (NEW-KEY-VALUE-LIST)))
   (CL:LET* ((*ADDEDNEWTYPE?* FALSE))
    (CL:DECLARE (CL:SPECIAL *ADDEDNEWTYPE?*))
    (CL:LOOP (CL:SETQ *ADDEDNEWTYPE?* FALSE)
     (INFER-TYPES-FROM-PROPOSITIONS PROPOSITION VARIABLETYPESTABLE
      VISIBLEVARIABLES)
     (CL:WHEN (CL:NOT *ADDEDNEWTYPE?*)
      (CL:RETURN-FROM INFER-VARIABLE-TYPES-IN-PROPOSITION
       VARIABLETYPESTABLE))))))

;;; (DEFUN (INFER-VARIABLE-TYPES-IN-DESCRIPTION VARIABLE-TYPE-TABLE) ...)

(CL:DEFUN INFER-VARIABLE-TYPES-IN-DESCRIPTION (DESCRIPTION)
  (CL:LET* ((VISIBLEVARIABLES NIL))
   (CL:LET*
    ((V NULL) (VECTOR-000 (%IO-VARIABLES DESCRIPTION)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ V
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:SETQ VISIBLEVARIABLES (CONS V VISIBLEVARIABLES))))
   (CL:LET*
    ((V NULL) (ITER-000 (TOP-LEVEL-EXISTENTIAL-VARIABLES DESCRIPTION)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ V (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:SETQ VISIBLEVARIABLES (CONS V VISIBLEVARIABLES))))
   (INFER-VARIABLE-TYPES-IN-PROPOSITION (%PROPOSITION DESCRIPTION)
    VISIBLEVARIABLES)))

;;; (DEFUN (COLLECT-UNRESOLVED-SLOT-REFERENCES (CONS OF PROPOSITION)) ...)

(CL:DEFUN COLLECT-UNRESOLVED-SLOT-REFERENCES (SELF)
  (CL:LET* ((UNRESOLVEDSLOTREFERENCES NIL))
   (CL:WHEN
    (CL:AND
     (MEMBER?
      (GET-QUOTED-TREE "((:PREDICATE :FUNCTION) \"/LOGIC\")" "/LOGIC")
      (%KIND SELF))
     (ISA? (%OPERATOR SELF) SGT-DESCRIPTIONS-STELLA-SYMBOL))
    (CL:SETQ UNRESOLVEDSLOTREFERENCES
     (CONS SELF UNRESOLVEDSLOTREFERENCES)))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:WHEN (ISA? ARG SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
      (CL:LET*
       ((U NULL) (ITER-000 (COLLECT-UNRESOLVED-SLOT-REFERENCES ARG)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:PROGN (CL:SETQ U (%%VALUE ITER-000))
         (CL:SETQ ITER-000 (%%REST ITER-000)))
        (CL:SETQ UNRESOLVEDSLOTREFERENCES
         (CONS U UNRESOLVEDSLOTREFERENCES)))))))
   UNRESOLVEDSLOTREFERENCES))

;;; (DEFUN (RESOLVE-ONE-SLOT-REFERENCE? BOOLEAN) ...)

(CL:DEFUN RESOLVE-ONE-SLOT-REFERENCE? (PROPOSITION VARIABLETYPESTABLE)
  (CL:LET*
   ((FIRSTARGUMENT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (PREDICATE NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE FIRSTARGUMENT)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000
       SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
      (CL:PROGN
       (CL:LET* ((TYPES (LOOKUP VARIABLETYPESTABLE FIRSTARGUMENT)))
        (CL:WHEN (CL:NOT (CL:EQ TYPES NULL))
         (CL:SETQ PREDICATE
          (INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
           (%OPERATOR PROPOSITION)
           (LOOKUP VARIABLETYPESTABLE FIRSTARGUMENT)))))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT)
      (CL:PROGN
       (CL:LET* ((ROOTTYPE (SAFE-LOGICAL-TYPE FIRSTARGUMENT)))
        (CL:WHEN (CL:NOT (CL:EQ ROOTTYPE NULL))
         (CL:SETQ PREDICATE
          (INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
           (%OPERATOR PROPOSITION) (LIST ROOTTYPE)))))))
     (CL:T)))
   (CL:WHEN (CL:NOT (CL:EQ PREDICATE NULL))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE PREDICATE)
       SGT-DESCRIPTIONS-STELLA-SLOT)
      (CL:PROGN
       (CL:LET*
        ((RETURNTYPE
          (UNWRAP-WRAPPED-TYPE (%SLOT-BASE-TYPE PREDICATE))))
        (CL:WHEN (CL:NOT (BOOLEAN-TYPE? RETURNTYPE))
         (CL:SETF (%KIND PROPOSITION) KWD-DESCRIPTIONS-FUNCTION)
         (CL:WHEN
          (VARIABLE?
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
            (CL:THE CL:FIXNUM
             (CL:1- (LENGTH (%ARGUMENTS PROPOSITION))))))
          (CL:LET*
           ((LASTARGUMENT
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
              (CL:THE CL:FIXNUM
               (CL:1- (LENGTH (%ARGUMENTS PROPOSITION)))))))
           (UPDATE-SKOLEM-TYPE LASTARGUMENT RETURNTYPE))))
        (CL:SETF (%OPERATOR PROPOSITION)
         (MOST-GENERAL-EQUIVALENT-SLOTREF (%SLOT-SLOTREF PREDICATE)))
        (EVALUATE-NEW-PROPOSITION PROPOSITION)
        (CL:RETURN-FROM RESOLVE-ONE-SLOT-REFERENCE? TRUE))))
     (CL:T)))
   FALSE))

;;; (DEFUN RESOLVE-UNRESOLVED-SLOT-REFERENCES ...)

(CL:DEFUN RESOLVE-UNRESOLVED-SLOT-REFERENCES (FORMULA)
  (CL:LET*
   ((PROPOSITION NULL) (UNRESOLVEDPROPOSITIONS NULL)
    (VARIABLETYPESTABLE NULL) (UNRESOLVABLEPROPOSITIONS NIL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE FORMULA)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-DESCRIPTION)
      (CL:PROGN (CL:SETQ PROPOSITION (%PROPOSITION FORMULA))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
      (CL:PROGN (CL:SETQ PROPOSITION FORMULA)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:SETQ UNRESOLVEDPROPOSITIONS
    (COLLECT-UNRESOLVED-SLOT-REFERENCES PROPOSITION))
   (CL:WHEN (CL:EQ UNRESOLVEDPROPOSITIONS NIL)
    (CL:RETURN-FROM RESOLVE-UNRESOLVED-SLOT-REFERENCES))
   (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE FORMULA)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-001 SGT-DESCRIPTIONS-LOGIC-DESCRIPTION)
      (CL:PROGN
       (CL:SETQ VARIABLETYPESTABLE
        (INFER-VARIABLE-TYPES-IN-DESCRIPTION FORMULA))))
     ((SUBTYPE-OF? TEST-VALUE-001 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
      (CL:PROGN
       (CL:SETQ VARIABLETYPESTABLE
        (INFER-VARIABLE-TYPES-IN-PROPOSITION FORMULA NIL))))
     (CL:T
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" TEST-VALUE-001
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
   (CL:LET*
    ((PROP NULL) (ITER-000 UNRESOLVEDPROPOSITIONS) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ PROP (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN
      (CL:AND (SYMBOL? (%OPERATOR PROP))
       (CL:NOT (RESOLVE-ONE-SLOT-REFERENCE? PROP VARIABLETYPESTABLE)))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS PROP NIL))
        (CL:IF (CL:EQ UNRESOLVABLEPROPOSITIONS NIL)
         (CL:SETQ UNRESOLVABLEPROPOSITIONS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST UNRESOLVABLEPROPOSITIONS
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS PROP NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:WHEN (CL:NOT (CL:EQ UNRESOLVABLEPROPOSITIONS NIL))
    (CL:LET* ((P NULL) (ITER-001 UNRESOLVABLEPROPOSITIONS))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:PROGN (CL:SETQ P (%%VALUE ITER-001))
       (CL:SETQ ITER-001 (%%REST ITER-001)))
      (COMPLAIN-ABOUT-UNDECLARED-REFERENCE P)
      (CREATE-DUMMY-RELATION P))))))

;;; (DEFUN CREATE-DUMMY-RELATION ...)

(CL:DEFUN CREATE-DUMMY-RELATION (WAYWARDPROPOSITION)
  (CL:LET*
   ((FAKEVARIABLETYPES (NEW-LIST))
    (SYMBOLREF (%OPERATOR WAYWARDPROPOSITION))
    (RELATIONREF (SYMBOL-TO-SURROGATE SYMBOLREF)) (DESCRIPTION NULL))
   (CL:LET* ((I (INTERVAL 1 (LENGTH (%ARGUMENTS WAYWARDPROPOSITION)))))
    (CL:LOOP WHILE (NEXT? I) DO
     (PUSH FAKEVARIABLETYPES SGT-DESCRIPTIONS-STELLA-THING)))
   (CL:SETQ DESCRIPTION
    (CREATE-PRIMITIVE-DESCRIPTION NIL-LIST FAKEVARIABLETYPES FALSE
     (CL:EQ (%KIND WAYWARDPROPOSITION) KWD-DESCRIPTIONS-ISA)
     (CL:EQ (%KIND WAYWARDPROPOSITION) KWD-DESCRIPTIONS-FUNCTION)
     (%HOME-CONTEXT RELATIONREF)))
   (CL:SETF (%OPERATOR WAYWARDPROPOSITION) RELATIONREF)
   (BIND-LOGIC-OBJECT-TO-SURROGATE SYMBOLREF DESCRIPTION)
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS DESCRIPTION)
    SYM-DESCRIPTIONS-LOGIC-UNDECLARED?
    (CL:IF TRUE TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)))

;;; (DEFUN (DEFINED-RELATION? BOOLEAN) ...)

(CL:DEFUN DEFINED-RELATION? (SELF)
  (CL:AND
   (CL:NOT
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-DESCRIPTIONS-LOGIC-UNDECLARED? FALSE-WRAPPER)))
   (CL:OR
    (CL:NOT (CL:EQ (STRINGIFIED-SOURCE SELF) STELLA::NULL-STRING))
    (CL:NOT (CL:EQ (NATIVE-RELATION SELF) NULL)))))

;;; (DEFUN (LIST-UNDEFINED-RELATIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN %LIST-UNDEFINED-RELATIONS (MODULE LOCAL?)
  "Return a list of as yet undefined concepts and relations in `module'.
These relations were defined by the system, since they were referenced
but have not yet been defined by the user.  If `module' is NULL look in
the current module.  If `local?' only look in `module' but not in any
modules it inherits."
  (CL:LET* ((THEMODULE (COERCE-TO-MODULE MODULE TRUE)))
   (CL:WHEN (CL:NOT (CL:EQ THEMODULE NULL))
    (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ THEMODULE NULL)))
   (CL:WHEN (CL:EQ THEMODULE NULL) (CL:SETQ THEMODULE *MODULE*))
   (CALL-LIST-UNDEFINED-RELATIONS THEMODULE LOCAL?)))

(CL:DEFUN LIST-UNDEFINED-RELATIONS-EVALUATOR-WRAPPER (ARGUMENTS)
  (%LIST-UNDEFINED-RELATIONS (%%VALUE ARGUMENTS)
   (%WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO LIST-UNDEFINED-RELATIONS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Return a list of as yet undefined concepts and relations in `module'.
These relations were defined by the system, since they were referenced
but have not yet been defined by the user.  If `module' is NULL look in
the current module.  If `local?' only look in `module' but not in any
modules it inherits."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/LIST-UNDEFINED-RELATIONS)) (CL:MACRO-FUNCTION (CL:QUOTE LIST-UNDEFINED-RELATIONS)))

;;; (DEFUN (CALL-LIST-UNDEFINED-RELATIONS CONS) ...)

(CL:DEFUN CALL-LIST-UNDEFINED-RELATIONS (MODULE LOCAL?)
  "Callable version of `list-undefined-relations' (which see)."
  (CL:LET* ((UNDEFINED NIL)) (FINALIZE-OBJECTS)
   (CL:LET* ((TERM NULL) (ITER-000 (ALL-NAMED-TERMS MODULE LOCAL?)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ TERM (%VALUE ITER-000))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TERM)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION)
        (CL:PROGN
         (CL:WHEN (CL:NOT (DEFINED-RELATION? TERM))
          (CL:SETQ UNDEFINED (CONS TERM UNDEFINED)))))
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT)
        (CL:PROGN
         (CL:LET*
          ((*MODULE*
            (CL:IF (CL:EQ MODULE NULL) (HOME-MODULE TERM) MODULE))
           (*CONTEXT* *MODULE*))
          (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
          (CL:WHEN
           (APPLY-CACHED-ASK (CONS SYM-DESCRIPTIONS-LOGIC-?X NIL)
            (LIST* SYM-DESCRIPTIONS-PL-KERNEL-KB-RELATION
             SYM-DESCRIPTIONS-LOGIC-?X NIL)
            (CONS-LIST TERM) (CONS-LIST)
            SYM-DESCRIPTIONS-LOGIC-F-CALL-LIST-UNDEFINED-RELATIONS-QUERY-000)
           (CL:SETQ UNDEFINED (CONS TERM UNDEFINED))))))
       (CL:T)))))
   UNDEFINED))

;;; (DEFUN COMPLAIN-ABOUT-UNDECLARED-REFERENCE ...)

(CL:DEFUN COMPLAIN-ABOUT-UNDECLARED-REFERENCE (WAYWARDPROPOSITION)
  (CL:IF
   (%WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WAYWARDPROPOSITION)
     SYM-DESCRIPTIONS-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "ERROR: Undeclared predicate or function reference: `"
      (%OPERATOR WAYWARDPROPOSITION) "'." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-DESCRIPTIONS-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))
   (CL:LET* ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING)
     "WARNING: Undeclared predicate or function reference: "
     (%OPERATOR WAYWARDPROPOSITION) EOL)
    (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
     KWD-DESCRIPTIONS-WARNING))))

;;; (DEFUN (ALL-NAMED-DESCRIPTIONS-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-NAMED-DESCRIPTIONS-NEXT? (SELF)
  (CL:LET*
   ((CURSOR (%ITERATOR-INTEGER SELF)) (SURROGATE NULL)
    (SURROGATEVALUE NULL) (DESCRIPTION NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR))
   (CL:LOOP WHILE (CL:< CURSOR (%ITERATOR-SECOND-INTEGER SELF)) DO
    (CL:SETQ SURROGATE
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY *SURROGATE-ARRAY*))
      CURSOR))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ SURROGATE NULL))
      (SELECTED-META-OBJECT? SELF (%HOME-CONTEXT SURROGATE)))
     (CL:SETQ SURROGATEVALUE (%SURROGATE-VALUE SURROGATE)))
    (CL:SETQ DESCRIPTION NULL)
    (CL:WHEN (CL:NOT (CL:EQ SURROGATEVALUE NULL))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SURROGATEVALUE)))
      (CL:COND
       ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
        (CL:PROGN
         (CL:WHEN (CL:EQ (%CLASS-TYPE SURROGATEVALUE) SURROGATE)
          (CL:SETQ DESCRIPTION
           (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SURROGATEVALUE)
            SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)))))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-RELATION)
        (CL:PROGN
         (CL:SETQ DESCRIPTION
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SURROGATEVALUE)
           SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL))))
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION)
        (CL:PROGN (CL:SETQ DESCRIPTION SURROGATEVALUE)))
       (CL:T))))
    (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
     (CL:SETF (%VALUE SELF) DESCRIPTION)
     (CL:SETF (%ITERATOR-INTEGER SELF) (CL:1+ CURSOR))
     (CL:RETURN-FROM ALL-NAMED-DESCRIPTIONS-NEXT? TRUE))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   FALSE))

;;; (DEFUN (ALL-NAMED-DESCRIPTIONS (ITERATOR OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN ALL-NAMED-DESCRIPTIONS (MODULE LOCAL?)
  "Iterate over all named descriptions visible from 'module'.
If 'local?', return only named descriptions interned in 'module'.
If 'module' is null, return all named descriptions interned everywhere."
  (ALLOCATE-ALL-META-OBJECTS-ITERATOR
   (CL:1+ (%TOP-SYMBOL-OFFSET *SURROGATE-ARRAY*))
   (CL:FUNCTION ALL-NAMED-DESCRIPTIONS-NEXT?) MODULE LOCAL?))

(CL:DEFUN HELP-STARTUP-DESCRIPTIONS1 ()
  (CL:PROGN
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-METHOD-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SLOT"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-DESCRIPTIONS-STELLA-ANY-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY-VALUE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ KWD-DESCRIPTIONS-EXTENSIONAL-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIONAL-ASSERTION" NULL 2))
   (CL:SETQ SGT-DESCRIPTIONS-PL-KERNEL-KB-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-DESCRIPTIONS-PL-KERNEL-KB-POLYMORPHIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POLYMORPHIC"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X1
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X1" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X2
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X2" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X3
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X3" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X4
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X4" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X5
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X5" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X6
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X6" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X7
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X7" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X8
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X8" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X9
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X9" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X10
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X10" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X11
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X11" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X12
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X12" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X13
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X13" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X14
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X14" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X15
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X15" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X16
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X16" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X17
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X17" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X18
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X18" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X19
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X19" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X20
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X20" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X21
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X21" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X22
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X22" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X23
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X23" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X24
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X24" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X25
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X25" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X26
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X26" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X27
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X27" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X28
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X28" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X29
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X29" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X30
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X30" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X31
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X31" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X32
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X32" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X33
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X33" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X34
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X34" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X35
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X35" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X36
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X36" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X37
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X37" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X38
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X38" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X39
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X39" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X40
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X40" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X41
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X41" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X42
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X42" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X43
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X43" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X44
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X44" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X45
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X45" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X46
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X46" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X47
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X47" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X48
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X48" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X49
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X49" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X50
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X50" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X51
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X51" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X52
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X52" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X53
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X53" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X54
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X54" NULL 0))))

(CL:DEFUN HELP-STARTUP-DESCRIPTIONS2 ()
  (CL:PROGN
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X55
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X55" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X56
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X56" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X57
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X57" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X58
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X58" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X59
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X59" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X60
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X60" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X61
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X61" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X62
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X62" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X63
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X63" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X64
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X64" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X65
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X65" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X66
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X66" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X67
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X67" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X68
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X68" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X69
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X69" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X70
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X70" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X71
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X71" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X72
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X72" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X73
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X73" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X74
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X74" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X75
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X75" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X76
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X76" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X77
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X77" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X78
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X78" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X79
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X79" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X80
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X80" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X81
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X81" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X82
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X82" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X83
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X83" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X84
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X84" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X85
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X85" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X86
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X86" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X87
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X87" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X88
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X88" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X89
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X89" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X90
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X90" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X91
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X91" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X92
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X92" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X93
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X93" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X94
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X94" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X95
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X95" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X96
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X96" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X97
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X97" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X98
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X98" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X99
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X99" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X100
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X100" NULL 0))
   (CL:SETQ SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SYM-DESCRIPTIONS-STELLA-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-KAPPA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
   (CL:SETQ KWD-DESCRIPTIONS-KIF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KIF" NULL 2))
   (CL:SETQ KWD-DESCRIPTIONS-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ SGT-DESCRIPTIONS-PL-KERNEL-KB-CONCEPT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEPT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-DESCRIPTIONS-PL-KERNEL-KB-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-DESCRIPTIONS-PL-KERNEL-KB-VARIABLE-ARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-ARITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ KWD-DESCRIPTIONS-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-OBJECT-STORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-STORE" NULL 0))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))))

(CL:DEFUN HELP-STARTUP-DESCRIPTIONS3 ()
  (CL:PROGN
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-LITERAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-DESCRIPTIONS-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ KWD-DESCRIPTIONS-WARNING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARNING" NULL 2))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ KWD-DESCRIPTIONS-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-VARIABLE-TYPE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE?" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-ENTITY-MAPPING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ENTITY-MAPPING" NULL 0))
   (CL:SETQ KWD-DESCRIPTIONS-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-DESCRIPTIONS-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-DESCRIPTIONS-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ KWD-DESCRIPTIONS-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ KWD-DESCRIPTIONS-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
   (CL:SETQ SGT-DESCRIPTIONS-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ KWD-DESCRIPTIONS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-DESCRIPTIONS-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ KWD-DESCRIPTIONS-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-ORIGINAL-SKOLEM-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ORIGINAL-SKOLEM-NAME" NULL 0))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-DESCRIPTIONS-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-DESCRIPTIONS-STELLA-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-DESCRIPTIONS-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-DESCRIPTIONS-STELLA-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTERNAL-VARIABLES" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-DEPENDENT-DESCRIPTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPENDENT-DESCRIPTIONS" NULL 0))
   (CL:SETQ KWD-DESCRIPTIONS-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-DESCRIPTIONS-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-PROPOSITION.IF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION.IF"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-CS-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CS-VALUE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-THE-ONLY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-ONLY" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-IOTA?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IOTA?" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-COMPLEMENT-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT-DESCRIPTION" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-VARIABLE-TYPE-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE-TABLE" NULL 0))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-UNDECLARED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNDECLARED?" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-LIST-UNDEFINED-RELATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-UNDEFINED-RELATIONS" NULL 0))
   (CL:SETQ KWD-DESCRIPTIONS-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-PL-KERNEL-KB-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 0))
   (CL:SETQ
    SYM-DESCRIPTIONS-LOGIC-F-CALL-LIST-UNDEFINED-RELATIONS-QUERY-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-CALL-LIST-UNDEFINED-RELATIONS-QUERY-000" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-DESCRIPTIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTIVE?" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-STARTUP-DESCRIPTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-DESCRIPTIONS" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))))

(CL:DEFUN HELP-STARTUP-DESCRIPTIONS4 ()
  (CL:PROGN
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT RELATION DESCRIPTION :TYPE NAMED-DESCRIPTION :DOCUMENTATION \"Maps a relation (class or slot or table) to a
primitive description.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "DIRECT-SUPERRELATIONS"
    "(DEFUN (DIRECT-SUPERRELATIONS (ITERATOR OF (LIKE SELF))) ((SELF RELATION)) :DOCUMENTATION \"Return direct super classes/slots of 'self'.\")"
    (CL:FUNCTION DIRECT-SUPERRELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "SLOT-COLUMN-TYPES"
    "(DEFUN (SLOT-COLUMN-TYPES (CONS OF TYPE)) ((SELF SLOT) (COUNT INTEGER)))"
    (CL:FUNCTION SLOT-COLUMN-TYPES) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-DESCRIPTION"
    "(DEFUN (CREATE-DESCRIPTION DESCRIPTION) ((ARITY INTEGER) (NAMED? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-DESCRIPTION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DESCRIPTION-NAME SYMBOL) ((SELF DESCRIPTION)) :DOCUMENTATION \"Return the name of the description `self', if it has one.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DESCRIPTION-NAME) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DESCRIPTION-NAME SYMBOL) ((SELF NAMED-DESCRIPTION)) :DOCUMENTATION \"Return the name of the description `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DESCRIPTION-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT
    "CREATE-BASE-RELATION-FOR-POLYMORPHIC-DESCRIPTION"
    "(DEFUN CREATE-BASE-RELATION-FOR-POLYMORPHIC-DESCRIPTION ((DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION CREATE-BASE-RELATION-FOR-POLYMORPHIC-DESCRIPTION)
    NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-SYSTEM-DEFINED-PARAMETER-NAME"
    "(DEFUN (YIELD-SYSTEM-DEFINED-PARAMETER-NAME SYMBOL) ((INDEX INTEGER) (REFERENCEOBJECT OBJECT)))"
    (CL:FUNCTION YIELD-SYSTEM-DEFINED-PARAMETER-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "ENSURE-DESCRIPTION-BODY"
    "(DEFUN ENSURE-DESCRIPTION-BODY ((DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION ENSURE-DESCRIPTION-BODY) NULL)
   (DEFINE-FUNCTION-OBJECT "MATERIALIZE-PRIMITIVE-DESCRIPTION-BODY"
    "(DEFUN MATERIALIZE-PRIMITIVE-DESCRIPTION-BODY ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION MATERIALIZE-PRIMITIVE-DESCRIPTION-BODY) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-PRIMITIVE-DESCRIPTION"
    "(DEFUN (CREATE-PRIMITIVE-DESCRIPTION NAMED-DESCRIPTION) ((IOVARIABLENAMES (LIST OF SYMBOL)) (IOVARIABLETYPES (LIST OF TYPE)) (VARIABLEARITY? BOOLEAN) (CLASS? BOOLEAN) (FUNCTION? BOOLEAN) (MODULE MODULE)))"
    (CL:FUNCTION CREATE-PRIMITIVE-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "LINK-STELLA-RELATION-AND-DESCRIPTION"
    "(DEFUN LINK-STELLA-RELATION-AND-DESCRIPTION ((SELF RELATION) (DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION LINK-STELLA-RELATION-AND-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-DESCRIPTION-FOR-STELLA-RELATION"
    "(DEFUN (CREATE-DESCRIPTION-FOR-STELLA-RELATION NAMED-DESCRIPTION) ((SELF RELATION)))"
    (CL:FUNCTION CREATE-DESCRIPTION-FOR-STELLA-RELATION) NULL)
   (DEFINE-FUNCTION-OBJECT "SURROGATE-TO-DESCRIPTION"
    "(DEFUN (SURROGATE-TO-DESCRIPTION NAMED-DESCRIPTION) ((SELF SURROGATE)))"
    (CL:FUNCTION SURROGATE-TO-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-DESCRIPTION"
    "(DEFUN (GET-DESCRIPTION NAMED-DESCRIPTION) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION GET-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "SURROGATE.GET-DESCRIPTION"
    "(DEFUN (SURROGATE.GET-DESCRIPTION NAMED-DESCRIPTION) ((SELF SURROGATE)))"
    (CL:FUNCTION SURROGATE.GET-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING.GET-DESCRIPTION"
    "(DEFUN (STRING.GET-DESCRIPTION NAMED-DESCRIPTION) ((SELF STRING)))"
    (CL:FUNCTION STRING.GET-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS.GET-DESCRIPTION"
    "(DEFUN (CLASS.GET-DESCRIPTION NAMED-DESCRIPTION) ((SELF CLASS)))"
    (CL:FUNCTION CLASS.GET-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "SLOT.GET-DESCRIPTION"
    "(DEFUN (SLOT.GET-DESCRIPTION NAMED-DESCRIPTION) ((SELF SLOT)))"
    (CL:FUNCTION SLOT.GET-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "ENSURE-DEFERRED-DESCRIPTION"
    "(DEFUN (ENSURE-DEFERRED-DESCRIPTION SURROGATE) ((SELF SURROGATE)))"
    (CL:FUNCTION ENSURE-DEFERRED-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGIC-CLASS?"
    "(DEFUN (LOGIC-CLASS? BOOLEAN) ((SELF CLASS)) :DOCUMENTATION \"Return TRUE if the class 'self' or one of its
supers supports indices that record extensions referenced by
the logic system. Also return true for literal classes.\")"
    (CL:FUNCTION LOGIC-CLASS?) NULL)
   (DEFINE-FUNCTION-OBJECT "VARIABLE-ARITY-DOMAIN-TYPES-NEXT?"
    "(DEFUN (VARIABLE-ARITY-DOMAIN-TYPES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION VARIABLE-ARITY-DOMAIN-TYPES-NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DOMAIN-TYPES"
    "(DEFUN (ALL-DOMAIN-TYPES ITERATOR) ((SELF NAMED-DESCRIPTION)))"
    (CL:FUNCTION ALL-DOMAIN-TYPES) NULL)
   (DEFINE-FUNCTION-OBJECT "PUSH-LOGIC-VARIABLE-BINDING"
    "(DEFUN PUSH-LOGIC-VARIABLE-BINDING ((VARIABLE SKOLEM)))"
    (CL:FUNCTION PUSH-LOGIC-VARIABLE-BINDING) NULL)
   (DEFINE-FUNCTION-OBJECT "POP-LOGIC-VARIABLE-BINDING"
    "(DEFUN POP-LOGIC-VARIABLE-BINDING ())"
    (CL:FUNCTION POP-LOGIC-VARIABLE-BINDING) NULL)
   (DEFINE-FUNCTION-OBJECT "POP-LOGIC-VARIABLE-BINDINGS"
    "(DEFUN POP-LOGIC-VARIABLE-BINDINGS ((VARIABLES (CONS OF SKOLEM))))"
    (CL:FUNCTION POP-LOGIC-VARIABLE-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-LOGIC-VARIABLE-BINDING"
    "(DEFUN (LOOKUP-LOGIC-VARIABLE-BINDING OBJECT) ((VARIABLENAME SYMBOL)))"
    (CL:FUNCTION LOOKUP-LOGIC-VARIABLE-BINDING) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-ONE-VARIABLE-DECLARATION"
    "(DEFUN PARSE-ONE-VARIABLE-DECLARATION ((VDEC OBJECT) (LOCALDECLARATIONS (LIST OF PATTERN-VARIABLE))))"
    (CL:FUNCTION PARSE-ONE-VARIABLE-DECLARATION) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-LOGIC-VARIABLE-DECLARATIONS"
    "(DEFUN (PARSE-LOGIC-VARIABLE-DECLARATIONS (CONS OF PATTERN-VARIABLE)) ((TREE OBJECT)))"
    (CL:FUNCTION PARSE-LOGIC-VARIABLE-DECLARATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-BUILD-QUANTIFIED-PROPOSITION"
    "(DEFUN (HELP-BUILD-QUANTIFIED-PROPOSITION (CONS OF SKOLEM) PROPOSITION PROPOSITION) ((TREE CONS) (CONVERTTYPESTOCONSTRAINTS? BOOLEAN)))"
    (CL:FUNCTION HELP-BUILD-QUANTIFIED-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-QUANTIFIED-PROPOSITION"
    "(DEFUN (BUILD-QUANTIFIED-PROPOSITION (CONS OF SKOLEM) PROPOSITION PROPOSITION) ((TREE CONS) (CONVERTTYPESTOCONSTRAINTS? BOOLEAN)))"
    (CL:FUNCTION BUILD-QUANTIFIED-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "COPY-CONS-LIST-TO-VARIABLES-VECTOR"
    "(DEFUN (COPY-CONS-LIST-TO-VARIABLES-VECTOR VARIABLES-VECTOR) ((CONSLIST CONS)))"
    (CL:FUNCTION COPY-CONS-LIST-TO-VARIABLES-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-HOLDS-PROPOSITION?"
    "(DEFUN (EQUIVALENT-HOLDS-PROPOSITION? BOOLEAN) ((SELF PROPOSITION) (OTHER PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION EQUIVALENT-HOLDS-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-COMMUTATIVE-PROPOSITIONS?"
    "(DEFUN (EQUIVALENT-COMMUTATIVE-PROPOSITIONS? BOOLEAN) ((SELF PROPOSITION) (OTHER PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION EQUIVALENT-COMMUTATIVE-PROPOSITIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-PROPOSITIONS?"
    "(DEFUN (EQUIVALENT-PROPOSITIONS? BOOLEAN) ((SELF PROPOSITION) (OTHER PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION EQUIVALENT-PROPOSITIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-FUNCTION-PROPOSITIONS?"
    "(DEFUN (EQUIVALENT-FUNCTION-PROPOSITIONS? BOOLEAN) ((SELF PROPOSITION) (OTHER PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION EQUIVALENT-FUNCTION-PROPOSITIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-DESCRIPTIONS?"
    "(DEFUN (EQUIVALENT-DESCRIPTIONS? BOOLEAN) ((SELF DESCRIPTION) (OTHER DESCRIPTION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION EQUIVALENT-DESCRIPTIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-ENUMERATIONS?"
    "(DEFUN (EQUIVALENT-ENUMERATIONS? BOOLEAN) ((SELF COLLECTION) (OTHER COLLECTION)))"
    (CL:FUNCTION EQUIVALENT-ENUMERATIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-FORMULAE?"
    "(DEFUN (EQUIVALENT-FORMULAE? BOOLEAN) ((SELF OBJECT) (OTHER OBJECT) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION EQUIVALENT-FORMULAE?) NULL)
   (DEFINE-FUNCTION-OBJECT "SAME-ARGUMENTS?"
    "(DEFUN (SAME-ARGUMENTS? BOOLEAN) ((VARIABLES VARIABLES-VECTOR) (ARGUMENTS VECTOR)))"
    (CL:FUNCTION SAME-ARGUMENTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "UNIFY-PROPOSITIONS?"
    "(DEFUN (UNIFY-PROPOSITIONS? BOOLEAN) ((SELF PROPOSITION) (OTHER PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION UNIFY-PROPOSITIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "NAMED-DESCRIPTION?"
    "(DEFUN (NAMED-DESCRIPTION? BOOLEAN) ((SELF DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION NAMED-DESCRIPTION?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIND-DUPLICATE-NAMED-DESCRIPTION LOGIC-OBJECT) ((SELF DESCRIPTION)))"
    (CL:FUNCTION FIND-DUPLICATE-NAMED-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "DELETED-LOGIC-OBJECT?"
    "(DEFUN (DELETED-LOGIC-OBJECT? BOOLEAN) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION DELETED-LOGIC-OBJECT?) NULL)
   (DEFINE-FUNCTION-OBJECT "UNIQUIFY-DESCRIPTION-VARIABLES"
    "(DEFUN UNIQUIFY-DESCRIPTION-VARIABLES ((SELF DESCRIPTION)))"
    (CL:FUNCTION UNIQUIFY-DESCRIPTION-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "RESTORE-DESCRIPTION-VARIABLE-NAMES"
    "(DEFUN RESTORE-DESCRIPTION-VARIABLE-NAMES ((SELF DESCRIPTION)))"
    (CL:FUNCTION RESTORE-DESCRIPTION-VARIABLE-NAMES) NULL)
   (DEFINE-FUNCTION-OBJECT "CONS-TREE-LESS-THAN?"
    "(DEFUN (CONS-TREE-LESS-THAN? BOOLEAN) ((TREE1 OBJECT) (TREE2 OBJECT)))"
    (CL:FUNCTION CONS-TREE-LESS-THAN?) NULL)
   (DEFINE-FUNCTION-OBJECT "SORT-PROPOSITION-CLAUSES"
    "(DEFUN (SORT-PROPOSITION-CLAUSES CONS) ((CLAUSES CONS)))"
    (CL:FUNCTION SORT-PROPOSITION-CLAUSES) NULL)
   (DEFINE-FUNCTION-OBJECT "UNIQUIFY-PROPOSITION-TREE"
    "(DEFUN (UNIQUIFY-PROPOSITION-TREE OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION UNIQUIFY-PROPOSITION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-EXACT-DUPLICATE-DESCRIPTION"
    "(DEFUN (FIND-EXACT-DUPLICATE-DESCRIPTION DESCRIPTION) ((SELF DESCRIPTION)))"
    (CL:FUNCTION FIND-EXACT-DUPLICATE-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-CONSTANT-REFERENCES"
    "(DEFUN HELP-COLLECT-CONSTANT-REFERENCES ((SELF OBJECT) (COLLECTION (LIST OF LOGIC-OBJECT)) (STOPATONE? BOOLEAN)))"
    (CL:FUNCTION HELP-COLLECT-CONSTANT-REFERENCES) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-CONSTANT-DESCRIPTION-REFERENCES"
    "(DEFUN (COLLECT-CONSTANT-DESCRIPTION-REFERENCES (LIST OF LOGIC-OBJECT)) ((SELF DESCRIPTION) (COLLECTION (LIST OF LOGIC-OBJECT)) (STOPATONE? BOOLEAN)))"
    (CL:FUNCTION COLLECT-CONSTANT-DESCRIPTION-REFERENCES) NULL)
   (DEFINE-FUNCTION-OBJECT
    "FIND-DUPLICATE-DESCRIPTION-WITH-CONSTANT-REFERENCE"
    "(DEFUN (FIND-DUPLICATE-DESCRIPTION-WITH-CONSTANT-REFERENCE DESCRIPTION) ((SELF DESCRIPTION)))"
    (CL:FUNCTION FIND-DUPLICATE-DESCRIPTION-WITH-CONSTANT-REFERENCE)
    NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-DUPLICATE-DESCRIPTION"
    "(DEFUN (FIND-DUPLICATE-DESCRIPTION DESCRIPTION) ((SELF DESCRIPTION)))"
    (CL:FUNCTION FIND-DUPLICATE-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-DEPENDENT-DESCRIPTION-LINK"
    "(DEFUN ADD-DEPENDENT-DESCRIPTION-LINK ((SELF OBJECT) (DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION ADD-DEPENDENT-DESCRIPTION-LINK) NULL)
   (DEFINE-FUNCTION-OBJECT "FASTEN-DOWN-DESCRIPTION"
    "(DEFUN FASTEN-DOWN-DESCRIPTION ((SELF DESCRIPTION)))"
    (CL:FUNCTION FASTEN-DOWN-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTAINS-NESTED-ARGUMENT?"
    "(DEFUN (CONTAINS-NESTED-ARGUMENT? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION CONTAINS-NESTED-ARGUMENT?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPAND-IF-PROPOSITION"
    "(DEFUN (EXPAND-IF-PROPOSITION PROPOSITION) ((IFPROPOSITION PROPOSITION)))"
    (CL:FUNCTION EXPAND-IF-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-FLATTENED-ARGUMENTS"
    "(DEFUN HELP-COLLECT-FLATTENED-ARGUMENTS ((SELF PROPOSITION) (FLATTENEDARGUMENTS (LIST OF PROPOSITION)) (EXISTSVARIABLES (LIST OF PATTERN-VARIABLE))))"
    (CL:FUNCTION HELP-COLLECT-FLATTENED-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-FLATTENED-ARGUMENTS"
    "(DEFUN (YIELD-FLATTENED-ARGUMENTS (LIST OF PROPOSITION)) ((PROPOSITION PROPOSITION) (EXISTSVARIABLES (LIST OF PATTERN-VARIABLE))))"
    (CL:FUNCTION YIELD-FLATTENED-ARGUMENTS) NULL)))

(CL:DEFUN STARTUP-DESCRIPTIONS ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-DESCRIPTIONS1) (HELP-STARTUP-DESCRIPTIONS2)
    (HELP-STARTUP-DESCRIPTIONS3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ FAKE-IO-VARIABLES (NEW-VECTOR 0))
    (CL:SETQ SYSTEM-DEFINED-ARGUMENT-NAMES
     (LIST* SYM-DESCRIPTIONS-LOGIC-?X1 SYM-DESCRIPTIONS-LOGIC-?X2
      SYM-DESCRIPTIONS-LOGIC-?X3 SYM-DESCRIPTIONS-LOGIC-?X4
      SYM-DESCRIPTIONS-LOGIC-?X5 SYM-DESCRIPTIONS-LOGIC-?X6
      SYM-DESCRIPTIONS-LOGIC-?X7 SYM-DESCRIPTIONS-LOGIC-?X8
      SYM-DESCRIPTIONS-LOGIC-?X9 SYM-DESCRIPTIONS-LOGIC-?X10
      SYM-DESCRIPTIONS-LOGIC-?X11 SYM-DESCRIPTIONS-LOGIC-?X12
      SYM-DESCRIPTIONS-LOGIC-?X13 SYM-DESCRIPTIONS-LOGIC-?X14
      SYM-DESCRIPTIONS-LOGIC-?X15 SYM-DESCRIPTIONS-LOGIC-?X16
      SYM-DESCRIPTIONS-LOGIC-?X17 SYM-DESCRIPTIONS-LOGIC-?X18
      SYM-DESCRIPTIONS-LOGIC-?X19 SYM-DESCRIPTIONS-LOGIC-?X20
      SYM-DESCRIPTIONS-LOGIC-?X21 SYM-DESCRIPTIONS-LOGIC-?X22
      SYM-DESCRIPTIONS-LOGIC-?X23 SYM-DESCRIPTIONS-LOGIC-?X24
      SYM-DESCRIPTIONS-LOGIC-?X25 SYM-DESCRIPTIONS-LOGIC-?X26
      SYM-DESCRIPTIONS-LOGIC-?X27 SYM-DESCRIPTIONS-LOGIC-?X28
      SYM-DESCRIPTIONS-LOGIC-?X29 SYM-DESCRIPTIONS-LOGIC-?X30
      SYM-DESCRIPTIONS-LOGIC-?X31 SYM-DESCRIPTIONS-LOGIC-?X32
      SYM-DESCRIPTIONS-LOGIC-?X33 SYM-DESCRIPTIONS-LOGIC-?X34
      SYM-DESCRIPTIONS-LOGIC-?X35 SYM-DESCRIPTIONS-LOGIC-?X36
      SYM-DESCRIPTIONS-LOGIC-?X37 SYM-DESCRIPTIONS-LOGIC-?X38
      SYM-DESCRIPTIONS-LOGIC-?X39 SYM-DESCRIPTIONS-LOGIC-?X40
      SYM-DESCRIPTIONS-LOGIC-?X41 SYM-DESCRIPTIONS-LOGIC-?X42
      SYM-DESCRIPTIONS-LOGIC-?X43 SYM-DESCRIPTIONS-LOGIC-?X44
      SYM-DESCRIPTIONS-LOGIC-?X45 SYM-DESCRIPTIONS-LOGIC-?X46
      SYM-DESCRIPTIONS-LOGIC-?X47 SYM-DESCRIPTIONS-LOGIC-?X48
      SYM-DESCRIPTIONS-LOGIC-?X49 SYM-DESCRIPTIONS-LOGIC-?X50
      SYM-DESCRIPTIONS-LOGIC-?X51 SYM-DESCRIPTIONS-LOGIC-?X52
      SYM-DESCRIPTIONS-LOGIC-?X53 SYM-DESCRIPTIONS-LOGIC-?X54
      SYM-DESCRIPTIONS-LOGIC-?X55 SYM-DESCRIPTIONS-LOGIC-?X56
      SYM-DESCRIPTIONS-LOGIC-?X57 SYM-DESCRIPTIONS-LOGIC-?X58
      SYM-DESCRIPTIONS-LOGIC-?X59 SYM-DESCRIPTIONS-LOGIC-?X60
      SYM-DESCRIPTIONS-LOGIC-?X61 SYM-DESCRIPTIONS-LOGIC-?X62
      SYM-DESCRIPTIONS-LOGIC-?X63 SYM-DESCRIPTIONS-LOGIC-?X64
      SYM-DESCRIPTIONS-LOGIC-?X65 SYM-DESCRIPTIONS-LOGIC-?X66
      SYM-DESCRIPTIONS-LOGIC-?X67 SYM-DESCRIPTIONS-LOGIC-?X68
      SYM-DESCRIPTIONS-LOGIC-?X69 SYM-DESCRIPTIONS-LOGIC-?X70
      SYM-DESCRIPTIONS-LOGIC-?X71 SYM-DESCRIPTIONS-LOGIC-?X72
      SYM-DESCRIPTIONS-LOGIC-?X73 SYM-DESCRIPTIONS-LOGIC-?X74
      SYM-DESCRIPTIONS-LOGIC-?X75 SYM-DESCRIPTIONS-LOGIC-?X76
      SYM-DESCRIPTIONS-LOGIC-?X77 SYM-DESCRIPTIONS-LOGIC-?X78
      SYM-DESCRIPTIONS-LOGIC-?X79 SYM-DESCRIPTIONS-LOGIC-?X80
      SYM-DESCRIPTIONS-LOGIC-?X81 SYM-DESCRIPTIONS-LOGIC-?X82
      SYM-DESCRIPTIONS-LOGIC-?X83 SYM-DESCRIPTIONS-LOGIC-?X84
      SYM-DESCRIPTIONS-LOGIC-?X85 SYM-DESCRIPTIONS-LOGIC-?X86
      SYM-DESCRIPTIONS-LOGIC-?X87 SYM-DESCRIPTIONS-LOGIC-?X88
      SYM-DESCRIPTIONS-LOGIC-?X89 SYM-DESCRIPTIONS-LOGIC-?X90
      SYM-DESCRIPTIONS-LOGIC-?X91 SYM-DESCRIPTIONS-LOGIC-?X92
      SYM-DESCRIPTIONS-LOGIC-?X93 SYM-DESCRIPTIONS-LOGIC-?X94
      SYM-DESCRIPTIONS-LOGIC-?X95 SYM-DESCRIPTIONS-LOGIC-?X96
      SYM-DESCRIPTIONS-LOGIC-?X97 SYM-DESCRIPTIONS-LOGIC-?X98
      SYM-DESCRIPTIONS-LOGIC-?X99 SYM-DESCRIPTIONS-LOGIC-?X100 NIL))
    (CL:SETQ *UNIFY-PROPOSITIONS?* FALSE)
    (CL:SETQ *STRINGIFIED-DESCRIPTION-INDEX* (NEW-STRING-HASH-TABLE))
    (CL:SETQ *ADDEDNEWTYPE?* FALSE))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE ENTITY-MAPPING (KEY-VALUE-LIST OF OBJECT OBJECT) :DOCUMENTATION \"Used to keep track of already copied variables
and propositions within a 'copy-description' procedure.\")")
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE VARIABLE-TYPE-TABLE (KEY-VALUE-LIST OF PATTERN-VARIABLE (LIST OF TYPE)))"))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (HELP-STARTUP-DESCRIPTIONS4)
    (DEFINE-FUNCTION-OBJECT "FLATTEN-NESTED-FUNCTION-ARGUMENTS"
     "(DEFUN (FLATTEN-NESTED-FUNCTION-ARGUMENTS PROPOSITION) ((PROPOSITION PROPOSITION)))"
     (CL:FUNCTION FLATTEN-NESTED-FUNCTION-ARGUMENTS) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLAPSE-VALUE-OF-CHAINS-FOR-IO-VARIABLES"
     "(DEFUN COLLAPSE-VALUE-OF-CHAINS-FOR-IO-VARIABLES ((IOVARIABLES VARIABLES-VECTOR)))"
     (CL:FUNCTION COLLAPSE-VALUE-OF-CHAINS-FOR-IO-VARIABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "REMOVE-NULLS-IN-VARIABLES-VECTOR"
     "(DEFUN (REMOVE-NULLS-IN-VARIABLES-VECTOR VARIABLES-VECTOR) ((IOVARIABLES VARIABLES-VECTOR)))"
     (CL:FUNCTION REMOVE-NULLS-IN-VARIABLES-VECTOR) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLAPSE-VALUE-OF-CHAINS"
     "(DEFUN COLLAPSE-VALUE-OF-CHAINS ((DESCRIPTION DESCRIPTION)))"
     (CL:FUNCTION COLLAPSE-VALUE-OF-CHAINS) NULL)
    (DEFINE-FUNCTION-OBJECT "TIGHTEN-ARGUMENT-BINDINGS"
     "(DEFUN TIGHTEN-ARGUMENT-BINDINGS ((PROPOSITION PROPOSITION) (IOVARIABLES VARIABLES-VECTOR)))"
     (CL:FUNCTION TIGHTEN-ARGUMENT-BINDINGS) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-ALL-VARIABLES"
     "(DEFUN COLLECT-ALL-VARIABLES ((SELF PROPOSITION) (COLLECTION (LIST OF PATTERN-VARIABLE)) (BEENTHERE LIST)))"
     (CL:FUNCTION COLLECT-ALL-VARIABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "COMPUTE-INTERNAL-VARIABLES"
     "(DEFUN COMPUTE-INTERNAL-VARIABLES ((SELF DESCRIPTION)))"
     (CL:FUNCTION COMPUTE-INTERNAL-VARIABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "EQUATE-TOP-LEVEL-EQUIVALENCES"
     "(DEFUN EQUATE-TOP-LEVEL-EQUIVALENCES ((PROPOSITION PROPOSITION)))"
     (CL:FUNCTION EQUATE-TOP-LEVEL-EQUIVALENCES) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-EXTERNAL-VARIABLES"
     "(DEFUN COLLECT-EXTERNAL-VARIABLES ((PROPOSITION PROPOSITION)))"
     (CL:FUNCTION COLLECT-EXTERNAL-VARIABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "FINISH-BUILDING-DESCRIPTION"
     "(DEFUN (FINISH-BUILDING-DESCRIPTION DESCRIPTION) ((DESCRIPTION DESCRIPTION) (CHECKFORDUPLICATE? BOOLEAN)))"
     (CL:FUNCTION FINISH-BUILDING-DESCRIPTION) NULL)
    (DEFINE-FUNCTION-OBJECT "EVALUATE-DESCRIPTION-TERM"
     "(DEFUN (EVALUATE-DESCRIPTION-TERM DESCRIPTION) ((TERM CONS) (CHECKFORDUPLICATE? BOOLEAN)))"
     (CL:FUNCTION EVALUATE-DESCRIPTION-TERM) NULL)
    (DEFINE-FUNCTION-OBJECT "REMOVE-VARIABLE-TYPE-PROPOSITIONS"
     "(DEFUN (REMOVE-VARIABLE-TYPE-PROPOSITIONS (CONS OF PROPOSITION)) ((PROPOSITION PROPOSITION)))"
     (CL:FUNCTION REMOVE-VARIABLE-TYPE-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-COMPLEMENT-OF-GOAL-DESCRIPTION"
     "(DEFUN (GET-COMPLEMENT-OF-GOAL-DESCRIPTION DESCRIPTION) ((SELF NAMED-DESCRIPTION)))"
     (CL:FUNCTION GET-COMPLEMENT-OF-GOAL-DESCRIPTION) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-FREE-VARIABLES"
     "(DEFUN COLLECT-FREE-VARIABLES ((SELF OBJECT) (COLLECTION (LIST OF PATTERN-VARIABLE)) (QUANTIFIEDVARS LIST) (BEENTHERE LIST)))"
     (CL:FUNCTION COLLECT-FREE-VARIABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "TOP-LEVEL-EXISTENTIAL-VARIABLES"
     "(DEFUN (TOP-LEVEL-EXISTENTIAL-VARIABLES (CONS OF PATTERN-VARIABLE)) ((SELF DESCRIPTION)))"
     (CL:FUNCTION TOP-LEVEL-EXISTENTIAL-VARIABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "TOP-LEVEL-EXISTENTIAL-VARIABLE?"
     "(DEFUN (TOP-LEVEL-EXISTENTIAL-VARIABLE? BOOLEAN) ((VARIABLE PATTERN-VARIABLE) (DESCRIPTION DESCRIPTION)))"
     (CL:FUNCTION TOP-LEVEL-EXISTENTIAL-VARIABLE?) NULL)
    (DEFINE-FUNCTION-OBJECT "FREE-VARIABLE?"
     "(DEFUN (FREE-VARIABLE? BOOLEAN) ((VARIABLE PATTERN-VARIABLE) (PROPOSITION PROPOSITION)))"
     (CL:FUNCTION FREE-VARIABLE?) NULL)
    (DEFINE-FUNCTION-OBJECT "MOST-SPECIFIC-TYPES"
     "(DEFUN (MOST-SPECIFIC-TYPES (LIST OF TYPE)) ((TYPES (LIST OF TYPE))))"
     (CL:FUNCTION MOST-SPECIFIC-TYPES) NULL)
    (DEFINE-FUNCTION-OBJECT "ADD-VARIABLE-TYPE"
     "(DEFUN ADD-VARIABLE-TYPE ((VARIABLE PATTERN-VARIABLE) (NEWTYPE TYPE) (TABLE VARIABLE-TYPE-TABLE) (VISIBLEVARIABLES (CONS OF PATTERN-VARIABLE))))"
     (CL:FUNCTION ADD-VARIABLE-TYPE) NULL)
    (DEFINE-FUNCTION-OBJECT "INFER-PREDICATE-FROM-OPERATOR-AND-TYPES"
     "(DEFUN (INFER-PREDICATE-FROM-OPERATOR-AND-TYPES OBJECT) ((OPERATOR OBJECT) (TYPES (LIST OF TYPE))))"
     (CL:FUNCTION INFER-PREDICATE-FROM-OPERATOR-AND-TYPES) NULL)
    (DEFINE-FUNCTION-OBJECT "INFER-TYPES-FROM-ONE-PROPOSITION"
     "(DEFUN INFER-TYPES-FROM-ONE-PROPOSITION ((PROPOSITION PROPOSITION) (TABLE VARIABLE-TYPE-TABLE) (VISIBLEVARS (CONS OF PATTERN-VARIABLE))))"
     (CL:FUNCTION INFER-TYPES-FROM-ONE-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "INFER-TYPES-FROM-PROPOSITIONS"
     "(DEFUN INFER-TYPES-FROM-PROPOSITIONS ((PROPOSITION PROPOSITION) (TABLE VARIABLE-TYPE-TABLE) (VISIBLEVARS (CONS OF PATTERN-VARIABLE))))"
     (CL:FUNCTION INFER-TYPES-FROM-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "INFER-VARIABLE-TYPES-IN-PROPOSITION"
     "(DEFUN (INFER-VARIABLE-TYPES-IN-PROPOSITION VARIABLE-TYPE-TABLE) ((PROPOSITION PROPOSITION) (VISIBLEVARIABLES (CONS OF PATTERN-VARIABLE))))"
     (CL:FUNCTION INFER-VARIABLE-TYPES-IN-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "INFER-VARIABLE-TYPES-IN-DESCRIPTION"
     "(DEFUN (INFER-VARIABLE-TYPES-IN-DESCRIPTION VARIABLE-TYPE-TABLE) ((DESCRIPTION DESCRIPTION)))"
     (CL:FUNCTION INFER-VARIABLE-TYPES-IN-DESCRIPTION) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-UNRESOLVED-SLOT-REFERENCES"
     "(DEFUN (COLLECT-UNRESOLVED-SLOT-REFERENCES (CONS OF PROPOSITION)) ((SELF PROPOSITION)))"
     (CL:FUNCTION COLLECT-UNRESOLVED-SLOT-REFERENCES) NULL)
    (DEFINE-FUNCTION-OBJECT "RESOLVE-ONE-SLOT-REFERENCE?"
     "(DEFUN (RESOLVE-ONE-SLOT-REFERENCE? BOOLEAN) ((PROPOSITION PROPOSITION) (VARIABLETYPESTABLE VARIABLE-TYPE-TABLE)))"
     (CL:FUNCTION RESOLVE-ONE-SLOT-REFERENCE?) NULL)
    (DEFINE-FUNCTION-OBJECT "RESOLVE-UNRESOLVED-SLOT-REFERENCES"
     "(DEFUN RESOLVE-UNRESOLVED-SLOT-REFERENCES ((FORMULA OBJECT)))"
     (CL:FUNCTION RESOLVE-UNRESOLVED-SLOT-REFERENCES) NULL)
    (DEFINE-FUNCTION-OBJECT "CREATE-DUMMY-RELATION"
     "(DEFUN CREATE-DUMMY-RELATION ((WAYWARDPROPOSITION PROPOSITION)))"
     (CL:FUNCTION CREATE-DUMMY-RELATION) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINED-RELATION?"
     "(DEFUN (DEFINED-RELATION? BOOLEAN) ((SELF NAMED-DESCRIPTION)))"
     (CL:FUNCTION DEFINED-RELATION?) NULL)
    (DEFINE-FUNCTION-OBJECT "LIST-UNDEFINED-RELATIONS"
     "(DEFUN (LIST-UNDEFINED-RELATIONS (CONS OF NAMED-DESCRIPTION)) ((MODULE NAME) (LOCAL? BOOLEAN)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Return a list of as yet undefined concepts and relations in `module'.
These relations were defined by the system, since they were referenced
but have not yet been defined by the user.  If `module' is NULL look in
the current module.  If `local?' only look in `module' but not in any
modules it inherits.\")" (CL:FUNCTION %LIST-UNDEFINED-RELATIONS)
     (CL:FUNCTION LIST-UNDEFINED-RELATIONS-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "CALL-LIST-UNDEFINED-RELATIONS"
     "(DEFUN (CALL-LIST-UNDEFINED-RELATIONS CONS) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Callable version of `list-undefined-relations' (which see).\" :PUBLIC? TRUE)"
     (CL:FUNCTION CALL-LIST-UNDEFINED-RELATIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "COMPLAIN-ABOUT-UNDECLARED-REFERENCE"
     "(DEFUN COMPLAIN-ABOUT-UNDECLARED-REFERENCE ((WAYWARDPROPOSITION PROPOSITION)))"
     (CL:FUNCTION COMPLAIN-ABOUT-UNDECLARED-REFERENCE) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-NAMED-DESCRIPTIONS-NEXT?"
     "(DEFUN (ALL-NAMED-DESCRIPTIONS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
     (CL:FUNCTION ALL-NAMED-DESCRIPTIONS-NEXT?) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-NAMED-DESCRIPTIONS"
     "(DEFUN (ALL-NAMED-DESCRIPTIONS (ITERATOR OF NAMED-DESCRIPTION)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all named descriptions visible from 'module'.
If 'local?', return only named descriptions interned in 'module'.
If 'module' is null, return all named descriptions interned everywhere.\" :PUBLIC? TRUE)"
     (CL:FUNCTION ALL-NAMED-DESCRIPTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-DESCRIPTIONS"
     "(DEFUN STARTUP-DESCRIPTIONS () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-DESCRIPTIONS) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-DESCRIPTIONS-LOGIC-STARTUP-DESCRIPTIONS)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-DESCRIPTIONS-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_Startup-Descriptions") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT FAKE-IO-VARIABLES VARIABLES-VECTOR (NEW VARIABLES-VECTOR :ARRAY-SIZE 0) :DOCUMENTATION \"Installed in a description with undetermined arity.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT SYSTEM-DEFINED-ARGUMENT-NAMES (CONS OF SYMBOL) (BQUOTE (?X1 ?X2 ?X3 ?X4 ?X5 ?X6 ?X7 ?X8 ?X9 ?X10 ?X11 ?X12 ?X13 ?X14 ?X15 ?X16 ?X17 ?X18 ?X19 ?X20 ?X21 ?X22 ?X23 ?X24 ?X25 ?X26 ?X27 ?X28 ?X29 ?X30 ?X31 ?X32 ?X33 ?X34 ?X35 ?X36 ?X37 ?X38 ?X39 ?X40 ?X41 ?X42 ?X43 ?X44 ?X45 ?X46 ?X47 ?X48 ?X49 ?X50 ?X51 ?X52 ?X53 ?X54 ?X55 ?X56 ?X57 ?X58 ?X59 ?X60 ?X61 ?X62 ?X63 ?X64 ?X65 ?X66 ?X67 ?X68 ?X69 ?X70 ?X71 ?X72 ?X73 ?X74 ?X75 ?X76 ?X77 ?X78 ?X79 ?X80 ?X81 ?X82 ?X83 ?X84 ?X85 ?X86 ?X87 ?X88 ?X89 ?X90 ?X91 ?X92 ?X93 ?X94 ?X95 ?X96 ?X97 ?X98 ?X99 ?X100)) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *LOGICVARIABLETABLE* (CONS OF SKOLEM) NULL :DOCUMENTATION \"Table mapping logic variable names to variables or skolems.
Used during construction of a proposition or description.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *VARIABLETYPEPROPOSITIONS* (CONS OF PROPOSITION) :DOCUMENTATION \"List of propositions extracted from parsing
a list of quantified, typed variables.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *UNIFY-PROPOSITIONS?* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *STRINGIFIED-DESCRIPTION-INDEX* (STRING-HASH-TABLE OF STRING LIST) (NEW STRING-HASH-TABLE) :DOCUMENTATION \"Contains a table of unnamed descriptions, indexed by the
stringification of their propositions.  Tricky: Descriptions in two
different modules could have the same stringification but be different.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EXTERNALVARIABLES* CONS :DOCUMENTATION \"Used by 'evaluate-DESCRIPTION-term' for collecting
a list of variables declared external to the description in which they
are referenced.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *RECURSIVEGETCOMPLEMENTARGUMENT* NAMED-DESCRIPTION NULL :DOCUMENTATION \"Used to prevent infinite looping.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *ADDEDNEWTYPE?* BOOLEAN FALSE :DOCUMENTATION \"Used by 'infer-variable-types'.\")")
    (REGISTER-NATIVE-NAME
     SYM-DESCRIPTIONS-LOGIC-LIST-UNDEFINED-RELATIONS
     KWD-DESCRIPTIONS-COMMON-LISP KWD-DESCRIPTIONS-FUNCTION))))
