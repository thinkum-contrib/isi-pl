;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; rule-induction.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-RULE-INDUCTION-TOP-DOWN NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-SET-SIGNATURE-STRATEGY NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-COMMON-LISP NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-FUNCTION NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-SET-SIGNATURE-RULES NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-SET-RULE-INDUCTION-STRATEGY NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-SET-RECURSIVE-DECISION-NODES NULL)
(CL:DEFVAR SGT-RULE-INDUCTION-LOGIC-DECISION-TREE NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-FEATURE NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-FEATURE-INDEX NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-TRUTH-VALUE NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-CONCEPT NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-TRUE-BRANCH NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-FALSE-BRANCH NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-BOTTOM-UP NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-INDUCE-INFERENCE-RULES NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-?Y NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-=> NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-AND NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-BOTTOM-UP-RULE-INDUCTION NULL)
(CL:DEFVAR SGT-RULE-INDUCTION-STELLA-CONS NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-NOT NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-> NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-< NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA->= NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-=< NULL)
(CL:DEFVAR SGT-RULE-INDUCTION-STELLA-NUMBER-WRAPPER NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-FAIL NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-DECISION-TREE NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-TOP-DOWN-RULE-INDUCTION NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-USER-THING NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-EXISTS NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-TIMEOUT NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-DONT-OPTIMIZE? NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-TRUE NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-EVALUATE-RULE-INDUCTION NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-INDUCE-DECISION-RULES NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-INDUCE-DECISION-TREE NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-DEFRULE NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-FORALL NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-OR NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-NOT NULL)
(CL:DEFVAR KWD-RULE-INDUCTION-AND NULL)
(CL:DEFVAR SGT-RULE-INDUCTION-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-RULE-INDUCTION-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-RULE-INDUCTION-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-LOGIC-STARTUP-RULE-INDUCTION NULL)
(CL:DEFVAR SYM-RULE-INDUCTION-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *CONTEXT* TRUE-TRUTH-VALUE
  DEFAULT-TRUE-TRUTH-VALUE ONE-WRAPPER ZERO-WRAPPER *MODULE*
  *FAIL-UNBOUND-CLAUSES?* NIL *TABOO-OPERATORS* *CASE-ANTECEDENT-TABLE*
  STANDARD-OUTPUT EOL *TRAINING-EXAMPLES* TRUE-WRAPPER FALSE-WRAPPER
  NULL-INTEGER))

;;; (DEFGLOBAL *RULE-INDUCTION-STRATEGY* ...)

(CL:DEFVAR *RULE-INDUCTION-STRATEGY* NULL)

;;; (DEFGLOBAL *SIGNATURE-STRATEGY* ...)

(CL:DEFVAR *SIGNATURE-STRATEGY* NULL)

;;; (DEFUN SET-SIGNATURE-STRATEGY ...)

(CL:DEFUN %SET-SIGNATURE-STRATEGY (K)
  (CL:SETQ *SIGNATURE-STRATEGY* K))

(CL:DEFMACRO SET-SIGNATURE-STRATEGY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-SIGNATURE-STRATEGY|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-SIGNATURE-STRATEGY)))

;;; (DEFGLOBAL *ENABLE-USER-THING* ...)

(CL:DEFVAR *ENABLE-USER-THING* CL:T)

;;; (DEFGLOBAL *OPTIMIZE-INDUCED-QUERIES* ...)

(CL:DEFVAR *OPTIMIZE-INDUCED-QUERIES* CL:T)

;;; (DEFGLOBAL *SIMPLIFY-RULE-ANTECEDENT?* ...)

(CL:DEFVAR *SIMPLIFY-RULE-ANTECEDENT?* CL:NIL
  "Flag to control whether we try to simplify the rule antecedent.
This should be set to FALSE if we expect the user to edit the rule and
TRUE if we want to have final rules as general as possible.")

;;; (DEFGLOBAL *TRACE-ID3* ...)

(CL:DEFVAR *TRACE-ID3* CL:NIL)

;;; (DEFGLOBAL *TRACE-FOIL* ...)

(CL:DEFVAR *TRACE-FOIL* CL:NIL)

;;; (DEFGLOBAL *INDUCE-RULES-FROM-SIGNATURES* ...)

(CL:DEFVAR *INDUCE-RULES-FROM-SIGNATURES* CL:T)

;;; (DEFUN SET-SIGNATURE-RULES ...)

(CL:DEFUN %SET-SIGNATURE-RULES (B)
  (CL:SETQ *INDUCE-RULES-FROM-SIGNATURES* B))

(CL:DEFUN SET-SIGNATURE-RULES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-SIGNATURE-RULES
   (%BOOLEAN-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-SIGNATURE-RULES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-SIGNATURE-RULES|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-SIGNATURE-RULES)))

;;; (DEFGLOBAL *NUM-LGGS* ...)

(CL:DEFVAR *NUM-LGGS* 2000)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *NUM-LGGS*))

;;; (DEFGLOBAL *ENFORCE-LINKED-VARIABLES* ...)

(CL:DEFVAR *ENFORCE-LINKED-VARIABLES* CL:NIL)

;;; (DEFGLOBAL *LOG-INDUCED-RULES* ...)

(CL:DEFVAR *LOG-INDUCED-RULES* CL:NIL)

;;; (DEFGLOBAL *ALLOW-RECURSIVE-DECISION-NODES* ...)

(CL:DEFVAR *ALLOW-RECURSIVE-DECISION-NODES* CL:T)

;;; (DEFGLOBAL *LOG-DECISION-RULE-CONSTRUCTION* ...)

(CL:DEFVAR *LOG-DECISION-RULE-CONSTRUCTION* CL:NIL)

;;; (DEFGLOBAL LOG_2 ...)

(CL:DEFVAR LOG_2 0.6931472d0)
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT LOG_2))

;;; (DEFUN SET-RULE-INDUCTION-STRATEGY ...)

(CL:DEFUN %SET-RULE-INDUCTION-STRATEGY (K)
  (CL:SETQ *RULE-INDUCTION-STRATEGY* K))

(CL:DEFMACRO SET-RULE-INDUCTION-STRATEGY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-RULE-INDUCTION-STRATEGY|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-RULE-INDUCTION-STRATEGY)))

;;; (DEFUN SET-RECURSIVE-DECISION-NODES ...)

(CL:DEFUN %SET-RECURSIVE-DECISION-NODES (B)
  (CL:SETQ *ALLOW-RECURSIVE-DECISION-NODES* B))

(CL:DEFUN SET-RECURSIVE-DECISION-NODES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-RECURSIVE-DECISION-NODES
   (%BOOLEAN-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-RECURSIVE-DECISION-NODES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-RECURSIVE-DECISION-NODES|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-RECURSIVE-DECISION-NODES)))

(CL:DEFUN NEW-DECISION-TREE ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-DECISION-TREE))
   (CL:SETF (%DECISION-TREE.FALSE-BRANCH SELF) NULL)
   (CL:SETF (%DECISION-TREE.TRUE-BRANCH SELF) NULL)
   (CL:SETF (%DECISION-TREE.CONCEPT SELF) NULL)
   (CL:SETF (%DECISION-TREE.TRUTH-VALUE SELF) CL:NIL)
   (CL:SETF (%DECISION-TREE.PROPOSITION SELF) NULL)
   (CL:SETF (%DECISION-TREE.FEATURE-INDEX SELF) NULL-INTEGER)
   (CL:SETF (%DECISION-TREE.FEATURE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DECISION-TREE))
  SGT-RULE-INDUCTION-LOGIC-DECISION-TREE)

(CL:DEFUN ACCESS-DECISION-TREE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-RULE-INDUCTION-LOGIC-FEATURE)
    (CL:IF SETVALUE? (CL:SETF (%DECISION-TREE.FEATURE SELF) VALUE)
     (CL:SETQ VALUE (%DECISION-TREE.FEATURE SELF))))
   ((CL:EQ SLOTNAME SYM-RULE-INDUCTION-LOGIC-FEATURE-INDEX)
    (CL:IF SETVALUE?
     (CL:SETF (%DECISION-TREE.FEATURE-INDEX SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%DECISION-TREE.FEATURE-INDEX SELF)))))
   ((CL:EQ SLOTNAME SYM-RULE-INDUCTION-LOGIC-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%DECISION-TREE.PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%DECISION-TREE.PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-RULE-INDUCTION-LOGIC-TRUTH-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%DECISION-TREE.TRUTH-VALUE SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%DECISION-TREE.TRUTH-VALUE SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-RULE-INDUCTION-LOGIC-CONCEPT)
    (CL:IF SETVALUE? (CL:SETF (%DECISION-TREE.CONCEPT SELF) VALUE)
     (CL:SETQ VALUE (%DECISION-TREE.CONCEPT SELF))))
   ((CL:EQ SLOTNAME SYM-RULE-INDUCTION-LOGIC-TRUE-BRANCH)
    (CL:IF SETVALUE? (CL:SETF (%DECISION-TREE.TRUE-BRANCH SELF) VALUE)
     (CL:SETQ VALUE (%DECISION-TREE.TRUE-BRANCH SELF))))
   ((CL:EQ SLOTNAME SYM-RULE-INDUCTION-LOGIC-FALSE-BRANCH)
    (CL:IF SETVALUE? (CL:SETF (%DECISION-TREE.FALSE-BRANCH SELF) VALUE)
     (CL:SETQ VALUE (%DECISION-TREE.FALSE-BRANCH SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF DECISION-TREE) STREAM)
  (PRINT-DECISION-TREE SELF STREAM))

;;; (DEFGLOBAL *INDUCED-DECISION-RULES* ...)

(CL:DEFVAR *INDUCED-DECISION-RULES* NULL)

;;; (DEFGLOBAL *INDUCED-RULE-COUNTER* ...)

(CL:DEFVAR *INDUCED-RULE-COUNTER* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *INDUCED-RULE-COUNTER*))

;;; (DEFGLOBAL *CANDIDATE-CLAUSES* ...)

(CL:DEFVAR *CANDIDATE-CLAUSES* NULL)

;;; (DEFUN INDUCE-INFERENCE-RULES ...)

(CL:DEFUN %INDUCE-INFERENCE-RULES (RELATION-NAME CLASS-NAME)
  (CL:SETQ RELATION-NAME (PERMANENTIFY RELATION-NAME))
  (CLEAR-CASES)
  (CLEAR-TRAINING-EXAMPLES)
  (CL:SETQ *INDUCED-DECISION-RULES* (NEW-LIST))
  (CL:SETQ CLASS-NAME (PERMANENTIFY CLASS-NAME))
  (CL:LET*
   ((CLASS
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION CLASS-NAME)))
    (RELATION
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION RELATION-NAME)))
    (ILIST (LISTIFY (ALL-CLASS-INSTANCES CLASS))) (NUM (LENGTH ILIST))
    (INSTANCES (NEW-VECTOR NUM)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM))
   (CL:LET*
    ((INSTANCE NULL) (ITER-000 (%LIST.THE-CONS-LIST ILIST))
     (I NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ INSTANCE (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY INSTANCES)) (VALUE INSTANCE)
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:COND
    ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-TOP-DOWN)
     (CL:SETQ *ENABLE-USER-THING* CL:T)
     (CL:WHEN (CL:NOT *ALLOW-RECURSIVE-DECISION-NODES*)
      (INSERT-NEW *TABOO-OPERATORS* RELATION))
     (GENERATE-CLASSIFICATION-RULE INSTANCES RELATION-NAME CLASS-NAME
      CL:T)
     (CL:LET*
      ((CLAUSES
        (LOOKUP *CASE-ANTECEDENT-TABLE*
         (CONCATENATE (%SYMBOL.SYMBOL-NAME CLASS-NAME) "-match"))))
      (CL:SETQ *CANDIDATE-CLAUSES* (NEW-VECTOR (LENGTH CLAUSES)))
      (CL:LET*
       ((CLAUSE NULL) (ITER-002 (%LIST.THE-CONS-LIST CLAUSES))
        (I NULL-INTEGER) (ITER-003 0))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:SETQ CLAUSE (%%VALUE ITER-002)) (CL:SETQ I ITER-003)
        (CL:LET
         ((SELF (%VECTOR.THE-ARRAY *CANDIDATE-CLAUSES*)) (VALUE CLAUSE)
          (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))
        (CL:SETQ ITER-002 (%%REST ITER-002))
        (CL:SETQ ITER-003 (CL:1+ ITER-003)))))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Generating Training Examples" EOL)
     (GENERATE-CLASSIFICATION-TRAINING-EXAMPLES INSTANCES RELATION
      *INDUCE-RULES-FROM-SIGNATURES*)
     (CL:SETQ *OPTIMIZE-INDUCED-QUERIES* CL:T)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Generating Decision Rules" EOL)
     (%TOP-DOWN-RULE-INDUCTION *TRAINING-EXAMPLES*))
    ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-BOTTOM-UP)
     (CL:SETQ *ENABLE-USER-THING* CL:NIL)
     (GENERATE-TRAINING-EXAMPLES INSTANCES RELATION)
     (CL:SETQ *OPTIMIZE-INDUCED-QUERIES* CL:T)
     (%BOTTOM-UP-RULE-INDUCTION *TRAINING-EXAMPLES*
      *SIMPLIFY-RULE-ANTECEDENT?*))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" *RULE-INDUCTION-STRATEGY* "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

(CL:DEFMACRO INDUCE-INFERENCE-RULES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/INDUCE-INFERENCE-RULES|)) (CL:MACRO-FUNCTION (CL:QUOTE INDUCE-INFERENCE-RULES)))

;;; (DEFUN MODULAR-INDUCE-INFERENCE-RULES ...)

(CL:DEFUN MODULAR-INDUCE-INFERENCE-RULES (RELATION-NAME CLASS-NAME MODULES)
  (CLEAR-TRAINING-EXAMPLES)
  (CLEAR-CASES)
  (CL:LET*
   ((CLASS
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION CLASS-NAME)))
    (RELATION
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION RELATION-NAME)))
    (ILIST (NEW-LIST)) (HOME *MODULE*)
    (FAIL-UNBOUND *FAIL-UNBOUND-CLAUSES?*) (NUM (LENGTH ILIST))
    (INSTANCE-VEC (NEW-VECTOR (LENGTH MODULES))) (INSTANCES NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM))
   (CL:SETQ *FAIL-UNBOUND-CLAUSES?* CL:T)
   (CL:WHEN (CL:NOT *ALLOW-RECURSIVE-DECISION-NODES*)
    (INSERT-NEW *TABOO-OPERATORS* RELATION))
   (CL:COND
    ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-TOP-DOWN)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Building Classification Rule" EOL)
     (CL:SETQ *ENABLE-USER-THING* CL:T)
     (CL:LET*
      ((MODULE NULL) (ITER-000 (%LIST.THE-CONS-LIST MODULES))
       (J NULL-INTEGER) (ITER-001 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM J ITER-001))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ MODULE (%%VALUE ITER-000)) (CL:SETQ J ITER-001)
       (CHANGE-MODULE MODULE)
       (CL:SETQ ILIST (LISTIFY (ALL-CLASS-INSTANCES CLASS)))
       (CL:SETQ NUM (LENGTH ILIST))
       (CL:SETQ INSTANCES (NEW-VECTOR NUM))
       (CL:LET*
        ((INSTANCE NULL) (ITER-002 (%LIST.THE-CONS-LIST ILIST))
         (I NULL-INTEGER) (ITER-003 0))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
         (CL:SETQ INSTANCE (%%VALUE ITER-002)) (CL:SETQ I ITER-003)
         (CL:LET
          ((SELF (%VECTOR.THE-ARRAY INSTANCES)) (VALUE INSTANCE)
           (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:SETQ ITER-002 (%%REST ITER-002))
         (CL:SETQ ITER-003 (CL:1+ ITER-003))))
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY INSTANCE-VEC)) (VALUE INSTANCES)
         (POSITION J))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (GENERATE-CLASSIFICATION-RULE INSTANCES RELATION-NAME CLASS-NAME
        CL:NIL)
       (CL:SETQ ITER-000 (%%REST ITER-000))
       (CL:SETQ ITER-001 (CL:1+ ITER-001))))
     (CHANGE-MODULE HOME)
     (BUILD-CLASSIFICATION-RULE RELATION-NAME CLASS-NAME)
     (CL:LET*
      ((CLAUSES
        (LOOKUP *CASE-ANTECEDENT-TABLE*
         (CONCATENATE (%SYMBOL.SYMBOL-NAME CLASS-NAME) "-match"))))
      (CL:SETQ *CANDIDATE-CLAUSES* (NEW-VECTOR (LENGTH CLAUSES)))
      (CL:LET*
       ((CLAUSE NULL) (ITER-004 (%LIST.THE-CONS-LIST CLAUSES))
        (I NULL-INTEGER) (ITER-005 0))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-005))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
        (CL:SETQ CLAUSE (%%VALUE ITER-004)) (CL:SETQ I ITER-005)
        (CL:LET
         ((SELF (%VECTOR.THE-ARRAY *CANDIDATE-CLAUSES*)) (VALUE CLAUSE)
          (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))
        (CL:SETQ ITER-004 (%%REST ITER-004))
        (CL:SETQ ITER-005 (CL:1+ ITER-005)))))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Generating Training Examples" EOL)
     (CL:LET*
      ((MODULE NULL) (ITER-006 (%LIST.THE-CONS-LIST MODULES))
       (VEC NULL) (VECTOR-000 INSTANCE-VEC) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE
       (CL:AND (CL:NOT (CL:EQ ITER-006 NIL))
        (CL:< INDEX-000 LENGTH-000))
       DO (CL:SETQ MODULE (%%VALUE ITER-006))
       (CL:SETQ VEC
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CHANGE-MODULE MODULE)
       (GENERATE-CLASSIFICATION-TRAINING-EXAMPLES VEC RELATION CL:T)
       (CL:SETQ ITER-006 (%%REST ITER-006))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Generating Inference Rules" EOL)
     (%TOP-DOWN-RULE-INDUCTION *TRAINING-EXAMPLES*)
     (CL:SETQ *FAIL-UNBOUND-CLAUSES?* FAIL-UNBOUND))
    ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-BOTTOM-UP)
     (CL:SETQ *ENABLE-USER-THING* CL:NIL)
     (CL:LET*
      ((MODULE NULL) (ITER-007 (%LIST.THE-CONS-LIST MODULES))
       (VEC NULL) (VECTOR-001 INSTANCE-VEC) (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
      (CL:LOOP WHILE
       (CL:AND (CL:NOT (CL:EQ ITER-007 NIL))
        (CL:< INDEX-001 LENGTH-001))
       DO (CL:SETQ MODULE (%%VALUE ITER-007))
       (CL:SETQ VEC
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:SETQ VEC VEC) (CHANGE-MODULE MODULE)
       (GENERATE-TRAINING-EXAMPLES INSTANCES RELATION)
       (CL:SETQ ITER-007 (%%REST ITER-007))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
     (CL:SETQ *OPTIMIZE-INDUCED-QUERIES* CL:T)
     (%BOTTOM-UP-RULE-INDUCTION *TRAINING-EXAMPLES*
      *SIMPLIFY-RULE-ANTECEDENT?*))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" *RULE-INDUCTION-STRATEGY* "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN BOTTOM-UP-RULE-INDUCTION ...)

(CL:DEFUN %BOTTOM-UP-RULE-INDUCTION (EXAMPLES SIMPLIFY-RULE?)
  (CL:LET*
   ((POSITIVE (NEW-LIST)) (NEGATIVE (NEW-LIST)) (ALL-POSITIVE NULL)
    (ALL-NEGATIVE NULL) (RULES (NEW-LIST))
    (CONCEPT (%TRAINING-EXAMPLE.CONCEPT (FIRST EXAMPLES))) (RULE NIL))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:IF
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (%TRAINING-EXAMPLE.OUTPUT EXAMPLE))
      (PUSH POSITIVE EXAMPLE) (PUSH NEGATIVE EXAMPLE))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ ALL-POSITIVE (COPY POSITIVE))
   (CL:SETQ ALL-NEGATIVE (COPY NEGATIVE))
   (COLLECT-FACTS-IN-EXAMPLES POSITIVE)
   (CL:LET* ((EXAMPLE NULL) (ITER-001 (%LIST.THE-CONS-LIST POSITIVE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-001))
     (CL:SETF (%TRAINING-EXAMPLE.FACTS EXAMPLE)
      (SUBSTITUTE-CONS-TREE (%TRAINING-EXAMPLE.FACTS EXAMPLE)
       SYM-RULE-INDUCTION-LOGIC-?Y (%TRAINING-EXAMPLE.NAME EXAMPLE)))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Starting rule induction with " (LENGTH POSITIVE) " positive and "
    (LENGTH NEGATIVE) " negative examples" EOL)
   (CL:LOOP WHILE (CL:NOT (EMPTY? POSITIVE)) DO
    (CL:SETQ RULE (LEARN-ONE-RULE-BOTTOM-UP POSITIVE NEGATIVE))
    (CL:COND
     ((CL:EQ RULE NIL)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Quiting with " (LENGTH POSITIVE) " examples uncovered" EOL)
      (CL:RETURN))
     ((CL:AND SIMPLIFY-RULE? (NON-EMPTY? ALL-NEGATIVE))
      (CL:SETQ RULE
       (SIMPLIFY-ANTECEDENT RULE
        (GET-QUOTED-TREE "((?Y) \"/LOGIC\")" "/LOGIC") ALL-POSITIVE
        ALL-NEGATIVE)))
     (CL:T))
    (PUSH RULES
     (LIST* SYM-RULE-INDUCTION-STELLA-=>
      (CONS SYM-RULE-INDUCTION-STELLA-AND
       (CONCATENATE (COPY-CONS-TREE RULE) NIL))
      (CONS CONCEPT (CONS SYM-RULE-INDUCTION-LOGIC-?Y NIL)) NIL)))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
    "PowerLoom has induced the following rules" EOL EOL)
   (CL:WHEN (CL:NOT (CL:EQ RULES NULL))
    (CL:LET* ((RULE NULL) (ITER-002 (%LIST.THE-CONS-LIST RULES)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:SETQ RULE (%%VALUE ITER-002))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       RULE EOL)
      (CL:SETQ ITER-002 (%%REST ITER-002))))
    (CL:SETQ *INDUCED-DECISION-RULES* RULES))))

(CL:DEFUN BOTTOM-UP-RULE-INDUCTION-EVALUATOR-WRAPPER (ARGUMENTS)
  (%BOTTOM-UP-RULE-INDUCTION (%%VALUE ARGUMENTS)
   (%BOOLEAN-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO BOTTOM-UP-RULE-INDUCTION (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/BOTTOM-UP-RULE-INDUCTION|)) (CL:MACRO-FUNCTION (CL:QUOTE BOTTOM-UP-RULE-INDUCTION)))

;;; (DEFUN (LEARN-ONE-RULE-BOTTOM-UP (CONS OF CONS)) ...)

(CL:DEFUN LEARN-ONE-RULE-BOTTOM-UP (POSITIVE NEGATIVE)
  (CL:LET*
   ((LGG NIL) (RULE NIL) (SCORE 0) (NUM-POSITIVE (LENGTH POSITIVE))
    (INDEX1 0) (INDEX2 0) (FACTS1 NIL) (FACTS2 NIL) (MAX 0) (COVER 0)
    (NUM-LGGS (CL:* (LENGTH POSITIVE) 5)) (BEST-LGG NIL))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM SCORE NUM-POSITIVE INDEX1 INDEX2 MAX COVER
     NUM-LGGS))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Learning rule bottom up over " (LENGTH POSITIVE) " positives" EOL)
   (CL:SETQ MAX 0) (CL:SETQ BEST-LGG NIL)
   (CL:WHEN (CL:= (LENGTH POSITIVE) 1)
    (CL:SETQ RULE (%TRAINING-EXAMPLE.FACTS (FIRST POSITIVE)))
    (POP POSITIVE) (CL:RETURN-FROM LEARN-ONE-RULE-BOTTOM-UP RULE))
   (CL:LOOP WHILE
    (CL:AND (NON-EMPTY? POSITIVE)
     (CL:OR (CL:> MAX 0) (CL:EQ RULE NIL)))
    DO (CL:SETQ COVER (CL:+ MAX COVER)) (CL:SETQ MAX 0)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "   Current rule covers " COVER " positive examples" EOL)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "           rule is " RULE EOL)
    (CL:WHEN (CL:NOT (CL:EQ RULE NIL))
     (REMOVE-COVERED-EXAMPLES RULE POSITIVE))
    (CL:SETQ NUM-LGGS (CL:* (LENGTH POSITIVE) 5))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 NUM-LGGS)
      (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
      (CL:SETQ I ITER-000) (CL:SETQ I I)
      (CL:SETQ INDEX1 (RANDOM (LENGTH POSITIVE)))
      (CL:SETQ FACTS1 (%TRAINING-EXAMPLE.FACTS (NTH POSITIVE INDEX1)))
      (CL:IF (CL:EQ RULE NIL)
       (CL:PROGN (CL:SETQ INDEX2 (RANDOM (LENGTH POSITIVE)))
        (CL:LOOP WHILE (CL:= INDEX1 INDEX2) DO
         (CL:SETQ INDEX2 (RANDOM (LENGTH POSITIVE))))
        (CL:SETQ FACTS2
         (%TRAINING-EXAMPLE.FACTS (NTH POSITIVE INDEX2))))
       (CL:SETQ FACTS2 RULE))
      (CL:SETQ LGG (LEAST-GENERAL-GENERALIZATION FACTS1 FACTS2))
      (CL:WHEN (CL:NOT (RULE-COVERS-ANY-EXAMPLE? LGG NEGATIVE))
       (CL:SETQ SCORE (NUM-EXAMPLES-COVERED LGG POSITIVE))
       (CL:WHEN (CL:> SCORE MAX)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "   Best covers " SCORE " positives" EOL)
        (CL:SETQ BEST-LGG LGG)
        (CL:WHEN (CL:>= (CL:+ COVER SCORE) NUM-POSITIVE)
         (REMOVE-COVERED-EXAMPLES LGG POSITIVE)
         (CL:RETURN-FROM LEARN-ONE-RULE-BOTTOM-UP
          (REMOVE-REDUNDANT-CLAUSES LGG)))
        (CL:SETQ MAX SCORE)))
      (CL:SETQ ITER-000 (CL:1+ ITER-000))))
    (CL:SETQ RULE BEST-LGG))
   (REMOVE-REDUNDANT-CLAUSES RULE)))

;;; (DEFUN (CONTAINS-OUTPUT-VARIABLE? BOOLEAN) ...)

(CL:DEFUN CONTAINS-OUTPUT-VARIABLE? (CLAUSE OUTPUT-VARIABLES)
  (CL:LET* ((TERM NULL) (ITER-000 CLAUSE))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ TERM (%%VALUE ITER-000))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TERM)))
     (CL:COND
      ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
       (CL:PROGN
        (CL:WHEN (MEMBER? OUTPUT-VARIABLES TERM)
         (CL:RETURN-FROM CONTAINS-OUTPUT-VARIABLE? CL:T))))
      ((CL:EQ TEST-VALUE-000 SGT-RULE-INDUCTION-STELLA-CONS)
       (CL:PROGN
        (CL:WHEN (CONTAINS-OUTPUT-VARIABLE? TERM OUTPUT-VARIABLES)
         (CL:RETURN-FROM CONTAINS-OUTPUT-VARIABLE? CL:T))))
      (CL:T)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  CL:NIL)

;;; (DEFUN (SIMPLIFY-ANTECEDENT (CONS OF CONS)) ...)

(CL:DEFUN SIMPLIFY-ANTECEDENT (ANTECEDENT OUTPUT-VARIABLES POSITIVE NEGATIVE)
  (CL:LET*
   ((NEW-ANTECEDENT NIL) (CANDIDATE NIL)
    (DISCARDED-POTENTIAL-GENERATORS NIL) (COVERED-EXAMPLES 0)
    (PREVIOUS-COVERED-EXAMPLES 0)
    (SCORE (NUM-EXAMPLES-COVERED ANTECEDENT POSITIVE)))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM COVERED-EXAMPLES PREVIOUS-COVERED-EXAMPLES
     SCORE))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ANTECEDENT NIL)) DO
    (CL:LET* ((HEAD-000 (%%VALUE ANTECEDENT)))
     (CL:SETQ ANTECEDENT (%%REST ANTECEDENT))
     (CL:SETQ CANDIDATE HEAD-000))
    (CL:IF
     (RULE-COVERS-ANY-EXAMPLE? (APPEND NEW-ANTECEDENT ANTECEDENT)
      NEGATIVE)
     (CL:SETQ NEW-ANTECEDENT (CONS CANDIDATE NEW-ANTECEDENT))
     (CL:PROGN
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Removing clause " CANDIDATE EOL)
      (CL:WHEN (CONTAINS-OUTPUT-VARIABLE? CANDIDATE OUTPUT-VARIABLES)
       (CL:SETQ DISCARDED-POTENTIAL-GENERATORS
        (CONS CANDIDATE DISCARDED-POTENTIAL-GENERATORS))))))
   (CL:SETQ COVERED-EXAMPLES
    (NUM-EXAMPLES-COVERED NEW-ANTECEDENT POSITIVE))
   (CL:LOOP WHILE
    (CL:AND (CL:NOT (CL:EQ DISCARDED-POTENTIAL-GENERATORS NIL))
     (CL:< COVERED-EXAMPLES SCORE))
    DO
    (CL:LET* ((HEAD-001 (%%VALUE DISCARDED-POTENTIAL-GENERATORS)))
     (CL:SETQ DISCARDED-POTENTIAL-GENERATORS
      (%%REST DISCARDED-POTENTIAL-GENERATORS))
     (CL:SETQ CANDIDATE HEAD-001))
    (CL:SETQ PREVIOUS-COVERED-EXAMPLES COVERED-EXAMPLES)
    (CL:SETQ COVERED-EXAMPLES
     (NUM-EXAMPLES-COVERED (CONS CANDIDATE NEW-ANTECEDENT) POSITIVE))
    (CL:WHEN (CL:> COVERED-EXAMPLES PREVIOUS-COVERED-EXAMPLES)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Reinserting clause " CANDIDATE EOL)
     (CL:SETQ NEW-ANTECEDENT (CONS CANDIDATE NEW-ANTECEDENT))))
   NEW-ANTECEDENT))

;;; (DEFSPECIAL *BOTTOM-UP-VARIABLE-COUNTER* ...)

(CL:DEFVAR *BOTTOM-UP-VARIABLE-COUNTER* -1)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *BOTTOM-UP-VARIABLE-COUNTER*))

;;; (DEFUN (LEAST-GENERAL-GENERALIZATION CONS) ...)

(CL:DEFUN LEAST-GENERAL-GENERALIZATION (CLAUSE1 CLAUSE2)
  (CL:LET*
   ((MATCHES (NEW-LIST)) (PROBE NIL) (OPERATOR NULL)
    (BINDINGS (NEW-LIST)) (NEW-CLAUSE NIL)
    (VARS1 (GET-VARIABLES-FROM-CONS-PROPOSITIONS (CONS-LIST CLAUSE1)))
    (VARS2 (GET-VARIABLES-FROM-CONS-PROPOSITIONS (CONS-LIST CLAUSE2)))
    (NOT? CL:NIL) (VAR NULL) (RESULT NIL))
   (CL:LET*
    ((VAR NULL) (ITER-000 (%LIST.THE-CONS-LIST VARS1)) (I NULL-INTEGER)
     (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ VAR (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:WHEN (CL:NOT (CL:EQ VAR SYM-RULE-INDUCTION-LOGIC-?Y))
      (CL:SETQ CLAUSE1
       (SUBSTITUTE-CONS-TREE CLAUSE1 VAR
        (INTERN-SYMBOL
         (CONCATENATE "?A" (STRINGIFY (WRAP-INTEGER I)))))))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:LET*
    ((VAR NULL) (ITER-002 (%LIST.THE-CONS-LIST VARS2)) (I NULL-INTEGER)
     (ITER-003 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ VAR (%%VALUE ITER-002)) (CL:SETQ I ITER-003)
     (CL:WHEN (CL:NOT (CL:EQ VAR SYM-RULE-INDUCTION-LOGIC-?Y))
      (CL:SETQ CLAUSE2
       (SUBSTITUTE-CONS-TREE CLAUSE1 VAR
        (INTERN-SYMBOL
         (CONCATENATE "?B" (STRINGIFY (WRAP-INTEGER I)))))))
     (CL:SETQ ITER-002 (%%REST ITER-002))
     (CL:SETQ ITER-003 (CL:1+ ITER-003))))
   (CL:SETQ *BOTTOM-UP-VARIABLE-COUNTER* 0)
   (CL:LET* ((CLAUSE NULL) (ITER-004 (COPY-CONS-TREE CLAUSE1)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
     (CL:SETQ CLAUSE (%%VALUE ITER-004))
     (CL:IF (CL:EQ (%%VALUE CLAUSE) SYM-RULE-INDUCTION-STELLA-NOT)
      (CL:PROGN (CL:SETQ NOT? CL:T)
       (CL:SETQ PROBE (%%VALUE (%%REST CLAUSE))))
      (CL:PROGN (CL:SETQ NOT? CL:NIL) (CL:SETQ PROBE CLAUSE)))
     (CL:SETQ OPERATOR (%%VALUE PROBE)) (CL:SETQ MATCHES (NEW-LIST))
     (CL:LET*
      ((POTENTIAL-MATCH NULL) (ITER-005 (COPY-CONS-TREE CLAUSE2)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
       (CL:SETQ POTENTIAL-MATCH (%%VALUE ITER-005))
       (CL:WHEN
        (CL:AND NOT?
         (CL:EQ (%%VALUE POTENTIAL-MATCH)
          SYM-RULE-INDUCTION-STELLA-NOT)
         (CL:EQ (%%VALUE (%%VALUE (%%REST POTENTIAL-MATCH))) OPERATOR))
        (PUSH MATCHES (%%VALUE (%%REST POTENTIAL-MATCH))))
       (CL:WHEN
        (CL:AND (CL:NOT NOT?)
         (CL:EQ (%%VALUE POTENTIAL-MATCH) OPERATOR))
        (PUSH MATCHES POTENTIAL-MATCH))
       (CL:SETQ ITER-005 (%%REST ITER-005))))
     (CL:WHEN (CL:NOT (EMPTY? MATCHES))
      (CL:LET* ((MATCH NULL) (ITER-006 (%LIST.THE-CONS-LIST MATCHES)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
        (CL:SETQ MATCH (%%VALUE ITER-006))
        (CL:COND
         ((CL:OR (CL:EQ OPERATOR SYM-RULE-INDUCTION-STELLA->)
           (CL:EQ OPERATOR SYM-RULE-INDUCTION-STELLA-<)
           (CL:EQ OPERATOR SYM-RULE-INDUCTION-STELLA->=)
           (CL:EQ OPERATOR SYM-RULE-INDUCTION-STELLA-=<))
          (CL:SETQ NEW-CLAUSE
           (GENERALIZE-INEQUALITY PROBE MATCH BINDINGS)))
         (CL:T (CL:SETQ NEW-CLAUSE (CONS OPERATOR NIL))
          (CL:LET*
           ((ARG1 NULL) (ITER-007 (%%REST PROBE)) (ARG2 NULL)
            (ITER-008 (%%REST MATCH)))
           (CL:LOOP WHILE
            (CL:AND (CL:NOT (CL:EQ ITER-007 NIL))
             (CL:NOT (CL:EQ ITER-008 NIL)))
            DO (CL:SETQ ARG1 (%%VALUE ITER-007))
            (CL:SETQ ARG2 (%%VALUE ITER-008))
            (CL:IF (CL:NOT (EQUAL-CONS-TREES? ARG1 ARG2))
             (CL:PROGN
              (CL:SETQ VAR
               (LOOKUP-VARIABLE-IN-BINDINGS ARG1 ARG2 BINDINGS))
              (CL:WHEN (CL:EQ VAR NULL)
               (CL:SETQ VAR
                (INTERN-SYMBOL
                 (CONCATENATE "?X"
                  (STRINGIFY
                   (WRAP-INTEGER *BOTTOM-UP-VARIABLE-COUNTER*)))))
               (CL:WHEN (CL:NOT (EITHER-NUMBERS? ARG1 ARG2))
                (PUSH BINDINGS (CONS-LIST ARG1 ARG2 VAR)))
               (CL:SETQ *BOTTOM-UP-VARIABLE-COUNTER*
                (CL:1+ *BOTTOM-UP-VARIABLE-COUNTER*)))
              (CL:SETQ NEW-CLAUSE (CONS VAR NEW-CLAUSE)))
             (CL:SETQ NEW-CLAUSE (CONS ARG1 NEW-CLAUSE)))
            (CL:SETQ ITER-007 (%%REST ITER-007))
            (CL:SETQ ITER-008 (%%REST ITER-008))))
          (CL:SETQ NEW-CLAUSE (REVERSE NEW-CLAUSE))))
        (CL:WHEN NOT?
         (CL:SETQ NEW-CLAUSE
          (LIST* SYM-RULE-INDUCTION-STELLA-NOT NEW-CLAUSE NIL)))
        (CL:SETQ RESULT (CONS NEW-CLAUSE RESULT))
        (CL:SETQ ITER-006 (%%REST ITER-006)))))
     (CL:SETQ ITER-004 (%%REST ITER-004))))
   (REMOVE-REDUNDANT-CLAUSES (REVERSE RESULT))))

;;; (DEFUN (GENERALIZE-INEQUALITY CONS) ...)

(CL:DEFUN GENERALIZE-INEQUALITY (PROBE MATCH BINDINGS)
  (CL:LET*
   ((OPERATOR (%%VALUE PROBE)) (NEW-CLAUSE (CONS-LIST OPERATOR))
    (VAR NULL))
   (CL:LET*
    ((ARG1 NULL) (ITER-000 (%%REST PROBE)) (ARG2 NULL)
     (ITER-001 (%%REST MATCH)))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
      (CL:NOT (CL:EQ ITER-001 NIL)))
     DO (CL:SETQ ARG1 (%%VALUE ITER-000))
     (CL:SETQ ARG2 (%%VALUE ITER-001))
     (CL:IF (CL:NOT (EQUAL-CONS-TREES? ARG1 ARG2))
      (CL:IF (BOTH-NUMBERS? ARG1 ARG2)
       (CL:LET* ((TEST-VALUE-000 OPERATOR))
        (CL:COND
         ((CL:OR (CL:EQ TEST-VALUE-000 SYM-RULE-INDUCTION-STELLA->)
           (CL:EQ TEST-VALUE-000 SYM-RULE-INDUCTION-STELLA->=))
          (CL:SETQ NEW-CLAUSE
           (CONS
            (WRAP-INTEGER
             (MIN (%INTEGER-WRAPPER.WRAPPER-VALUE ARG1)
              (%INTEGER-WRAPPER.WRAPPER-VALUE ARG2)))
            NEW-CLAUSE)))
         ((CL:OR (CL:EQ TEST-VALUE-000 SYM-RULE-INDUCTION-STELLA-<)
           (CL:EQ TEST-VALUE-000 SYM-RULE-INDUCTION-STELLA-=<))
          (CL:SETQ NEW-CLAUSE
           (CONS
            (WRAP-INTEGER
             (MAX (%INTEGER-WRAPPER.WRAPPER-VALUE ARG1)
              (%INTEGER-WRAPPER.WRAPPER-VALUE ARG2)))
            NEW-CLAUSE)))
         (CL:T
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
           "Bug in generalize-inequality." EOL))))
       (CL:PROGN
        (CL:SETQ VAR (LOOKUP-VARIABLE-IN-BINDINGS ARG1 ARG2 BINDINGS))
        (CL:WHEN (CL:EQ VAR NULL)
         (CL:SETQ VAR
          (INTERN-SYMBOL
           (CONCATENATE "?X"
            (STRINGIFY (WRAP-INTEGER *BOTTOM-UP-VARIABLE-COUNTER*)))))
         (CL:WHEN (CL:NOT (EITHER-NUMBERS? ARG1 ARG2))
          (PUSH BINDINGS (CONS-LIST ARG1 ARG2 VAR)))
         (CL:SETQ *BOTTOM-UP-VARIABLE-COUNTER*
          (CL:1+ *BOTTOM-UP-VARIABLE-COUNTER*)))
        (CL:SETQ NEW-CLAUSE (CONS VAR NEW-CLAUSE))))
      (CL:SETQ NEW-CLAUSE (CONS ARG1 NEW-CLAUSE)))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (REVERSE NEW-CLAUSE)))

;;; (DEFUN (BOTH-NUMBERS? BOOLEAN) ...)

(CL:DEFUN BOTH-NUMBERS? (T1 T2)
  (CL:IF
   (CL:AND (ISA? T1 SGT-RULE-INDUCTION-STELLA-NUMBER-WRAPPER)
    (ISA? T2 SGT-RULE-INDUCTION-STELLA-NUMBER-WRAPPER))
   CL:T CL:NIL))

;;; (DEFUN (EITHER-NUMBERS? BOOLEAN) ...)

(CL:DEFUN EITHER-NUMBERS? (T1 T2)
  (CL:IF
   (CL:OR (ISA? T1 SGT-RULE-INDUCTION-STELLA-NUMBER-WRAPPER)
    (ISA? T2 SGT-RULE-INDUCTION-STELLA-NUMBER-WRAPPER))
   CL:T CL:NIL))

;;; (DEFUN (REMOVE-REDUNDANT-CLAUSES (CONS OF CONS)) ...)

(CL:DEFUN REMOVE-REDUNDANT-CLAUSES (CLAUSES)
  (CL:LET*
   ((RESULT NIL) (TRUE-TABLE (NEW-HASH-TABLE))
    (NOT-TABLE (NEW-HASH-TABLE)) (ENTRIES NULL)
    (SHARED-VARIABLES (NEW-LIST)) (KNOWN-VARIABLES (NEW-LIST))
    (OPERATOR NULL) (SUBSUMED? CL:NIL) (OPERATORS (NEW-LIST)))
   (CL:LET* ((CLAUSE NULL) (ITER-000 (COPY-CONS-TREE CLAUSES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CLAUSE (%%VALUE ITER-000))
     (CL:IF (CL:EQ (%%VALUE CLAUSE) SYM-RULE-INDUCTION-STELLA-NOT)
      (CL:PROGN (CL:SETQ OPERATOR (%%VALUE (%%VALUE (%%REST CLAUSE))))
       (INSERT-NEW OPERATORS OPERATOR)
       (CL:SETQ ENTRIES (LOOKUP NOT-TABLE OPERATOR))
       (CL:WHEN (CL:EQ ENTRIES NULL) (CL:SETQ ENTRIES (NEW-LIST)))
       (PUSH ENTRIES (%%VALUE (%%REST CLAUSE)))
       (INSERT-AT NOT-TABLE OPERATOR ENTRIES))
      (CL:PROGN (CL:SETQ OPERATOR (%%VALUE CLAUSE))
       (INSERT-NEW OPERATORS OPERATOR)
       (CL:SETQ ENTRIES (LOOKUP TRUE-TABLE OPERATOR))
       (CL:WHEN (CL:EQ ENTRIES NULL) (CL:SETQ ENTRIES (NEW-LIST)))
       (PUSH ENTRIES CLAUSE) (INSERT-AT TRUE-TABLE OPERATOR ENTRIES)))
     (CL:LET*
      ((V NULL)
       (ITER-001
        (%LIST.THE-CONS-LIST
         (GET-VARIABLES-FROM-CONS-PROPOSITIONS (CONS-LIST CLAUSE)))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ V (%%VALUE ITER-001))
       (CL:IF (MEMBER? KNOWN-VARIABLES V)
        (INSERT-NEW SHARED-VARIABLES V) (PUSH KNOWN-VARIABLES V))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((OPERATOR NULL) (ITER-002 (%LIST.THE-CONS-LIST OPERATORS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ OPERATOR (%%VALUE ITER-002))
     (CL:SETQ ENTRIES (LOOKUP TRUE-TABLE OPERATOR))
     (CL:WHEN (CL:NOT (CL:EQ ENTRIES NULL))
      (CL:LET*
       ((CLAUSE1 NULL) (ITER-003 (%LIST.THE-CONS-LIST ENTRIES)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
        (CL:SETQ CLAUSE1 (%%VALUE ITER-003)) (CL:SETQ SUBSUMED? CL:NIL)
        (CL:LET*
         ((CLAUSE2 NULL) (ITER-004 (%LIST.THE-CONS-LIST ENTRIES)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
          (CL:SETQ CLAUSE2 (%%VALUE ITER-004))
          (CL:WHEN (CL:NOT (CL:EQ CLAUSE1 CLAUSE2))
           (CL:SETQ SUBSUMED? CL:T)
           (CL:LET*
            ((ARG1 NULL) (ITER-005 (%%REST CLAUSE1)) (ARG2 NULL)
             (ITER-006 (%%REST CLAUSE2)))
            (CL:LOOP WHILE
             (CL:AND (CL:NOT (CL:EQ ITER-005 NIL))
              (CL:NOT (CL:EQ ITER-006 NIL)))
             DO (CL:SETQ ARG1 (%%VALUE ITER-005))
             (CL:SETQ ARG2 (%%VALUE ITER-006))
             (CL:WHEN
              (CL:AND (CL:NOT (EQUAL-CONS-TREES? ARG1 ARG2))
               (CL:OR
                (CL:AND (SYMBOL? ARG1) (MEMBER? SHARED-VARIABLES ARG1))
                (CONS? ARG1)))
              (CL:SETQ SUBSUMED? CL:NIL) (CL:RETURN))
             (CL:SETQ ITER-005 (%%REST ITER-005))
             (CL:SETQ ITER-006 (%%REST ITER-006))))
           (CL:WHEN SUBSUMED? (CL:RETURN)))
          (CL:SETQ ITER-004 (%%REST ITER-004))))
        (CL:WHEN (CL:NOT SUBSUMED?)
         (CL:SETQ RESULT (CONS CLAUSE1 RESULT)))
        (CL:SETQ ITER-003 (%%REST ITER-003)))))
     (CL:SETQ ENTRIES (LOOKUP NOT-TABLE OPERATOR))
     (CL:WHEN (CL:NOT (CL:EQ ENTRIES NULL))
      (CL:LET*
       ((CLAUSE1 NULL) (ITER-007 (%LIST.THE-CONS-LIST ENTRIES)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-007 NIL)) DO
        (CL:SETQ CLAUSE1 (%%VALUE ITER-007)) (CL:SETQ SUBSUMED? CL:NIL)
        (CL:LET*
         ((CLAUSE2 NULL) (ITER-008 (%LIST.THE-CONS-LIST ENTRIES)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-008 NIL)) DO
          (CL:SETQ CLAUSE2 (%%VALUE ITER-008))
          (CL:WHEN (CL:NOT (CL:EQ CLAUSE1 CLAUSE2))
           (CL:SETQ SUBSUMED? CL:T)
           (CL:LET*
            ((ARG1 NULL) (ITER-009 (%%REST CLAUSE1)) (ARG2 NULL)
             (ITER-010 (%%REST CLAUSE2)))
            (CL:LOOP WHILE
             (CL:AND (CL:NOT (CL:EQ ITER-009 NIL))
              (CL:NOT (CL:EQ ITER-010 NIL)))
             DO (CL:SETQ ARG1 (%%VALUE ITER-009))
             (CL:SETQ ARG2 (%%VALUE ITER-010))
             (CL:WHEN
              (CL:AND (CL:NOT (EQUAL-CONS-TREES? ARG1 ARG2))
               (CL:OR
                (CL:AND (SYMBOL? ARG1) (MEMBER? SHARED-VARIABLES ARG1))
                (CONS? ARG1)))
              (CL:SETQ SUBSUMED? CL:NIL) (CL:RETURN))
             (CL:SETQ ITER-009 (%%REST ITER-009))
             (CL:SETQ ITER-010 (%%REST ITER-010))))
           (CL:WHEN SUBSUMED? (CL:RETURN)))
          (CL:SETQ ITER-008 (%%REST ITER-008))))
        (CL:WHEN (CL:NOT SUBSUMED?)
         (CL:SETQ RESULT
          (CONS (LIST* SYM-RULE-INDUCTION-STELLA-NOT CLAUSE1 NIL)
           RESULT)))
        (CL:SETQ ITER-007 (%%REST ITER-007)))))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   RESULT))

;;; (DEFUN (LOOKUP-VARIABLE-IN-BINDINGS OBJECT) ...)

(CL:DEFUN LOOKUP-VARIABLE-IN-BINDINGS (OBJ1 OBJ2 BINDINGS)
  (CL:LET* ((BIND NULL) (ITER-000 (%LIST.THE-CONS-LIST BINDINGS)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ BIND (%%VALUE ITER-000))
    (CL:WHEN
     (CL:AND (EQUAL-CONS-TREES? (%%VALUE BIND) OBJ1)
      (EQUAL-CONS-TREES? (%%VALUE (%%REST BIND)) OBJ2))
     (CL:RETURN-FROM LOOKUP-VARIABLE-IN-BINDINGS
      (%%VALUE (%%REST (%%REST BIND)))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:WHEN (CL:AND (CONS? OBJ1) (CONS? OBJ2))
   (CL:LET* ((ANSWER NIL) (BIND NULL))
    (CL:LET* ((ARG1 NULL) (ITER-001 OBJ1) (ARG2 NULL) (ITER-002 OBJ2))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-001 NIL))
       (CL:NOT (CL:EQ ITER-002 NIL)))
      DO (CL:SETQ ARG1 (%%VALUE ITER-001))
      (CL:SETQ ARG2 (%%VALUE ITER-002))
      (CL:IF (EQL? ARG1 ARG2) (CL:SETQ ANSWER (CONS ARG1 ANSWER))
       (CL:PROGN
        (CL:SETQ BIND (LOOKUP-VARIABLE-IN-BINDINGS ARG1 ARG2 BINDINGS))
        (CL:WHEN (CL:EQ BIND NULL)
         (CL:RETURN-FROM LOOKUP-VARIABLE-IN-BINDINGS NULL))
        (CL:SETQ ANSWER (CONS BIND ANSWER))))
      (CL:SETQ ITER-001 (%%REST ITER-001))
      (CL:SETQ ITER-002 (%%REST ITER-002))))
    (CL:RETURN-FROM LOOKUP-VARIABLE-IN-BINDINGS (REVERSE ANSWER))))
  NULL)

;;; (DEFUN (LEARN-ONE-RULE-BOTTOM-UP-FROM-SIGNATURES (CONS OF CONS)) ...)

(CL:DEFUN LEARN-ONE-RULE-BOTTOM-UP-FROM-SIGNATURES (POSITIVE NEGATIVE COVERED CONS-PROPS)
  (CL:LET*
   ((TEMP-POSITIVE (COPY POSITIVE)) (MAX 0) (COVER 0) (INDEX1 0)
    (INDEX2 0)
    (VEC-SIZE (LENGTH (%TRAINING-EXAMPLE.INPUT (FIRST NEGATIVE))))
    (INDICES NULL) (BEST-INDICES (NEW-LIST)) (LGG NULL) (SIG1 NULL)
    (SIG2 NULL) (STOP CL:NIL) (RESULT NIL) (SCORE 0) (NUM-LGGS 0))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM MAX COVER INDEX1 INDEX2 VEC-SIZE SCORE
     NUM-LGGS))
   (CL:LOOP WHILE (CL:OR (CL:> MAX 0) (CL:EQ LGG NULL)) DO
    (CL:SETQ COVER (CL:+ COVER MAX))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "   Current rule covers " COVER " positive examples" EOL)
    (CL:WHEN (CL:NOT (CL:EQ LGG NULL))
     (CL:LET*
      ((EXAMPLE NULL)
       (ITER-000
        (%LIST.THE-CONS-LIST
         (REMOVE-SIGNATURE-COVERED-EXAMPLES BEST-INDICES
          TEMP-POSITIVE))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ EXAMPLE (%%VALUE ITER-000)) (PUSH COVERED EXAMPLE)
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    (CL:SETQ NUM-LGGS (CL:* (LENGTH TEMP-POSITIVE) 1)) (CL:SETQ MAX 0)
    (CL:LET*
     ((I NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-000 NUM-LGGS)
      (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)) DO
      (CL:SETQ I ITER-001) (CL:SETQ I I)
      (CL:SETQ INDEX1 (RANDOM (LENGTH TEMP-POSITIVE)))
      (CL:SETQ SIG1
       (%TRAINING-EXAMPLE.INPUT (NTH TEMP-POSITIVE INDEX1)))
      (CL:IF (CL:EQ LGG NULL)
       (CL:PROGN (CL:SETQ INDEX2 (RANDOM (LENGTH TEMP-POSITIVE)))
        (CL:LOOP WHILE (CL:= INDEX1 INDEX2) DO
         (CL:SETQ INDEX2 (RANDOM (LENGTH TEMP-POSITIVE))))
        (CL:SETQ SIG2
         (%TRAINING-EXAMPLE.INPUT (NTH TEMP-POSITIVE INDEX2))))
       (CL:SETQ SIG2 LGG))
      (CL:SETQ INDICES (INTERSECT-SIGNATURES SIG1 SIG2))
      (CL:WHEN
       (CL:NOT (SIGNATURE-INDICES-COVER-ANY-EXAMPLE? INDICES NEGATIVE))
       (CL:SETQ SCORE
        (NUM-SIGNATURE-INDICES-COVERED INDICES TEMP-POSITIVE))
       (CL:WHEN (CL:> SCORE MAX)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "    New best: " SCORE " examples" EOL)
        (CL:SETQ BEST-INDICES INDICES) (CL:SETQ MAX SCORE)))
      (CL:SETQ ITER-001 (CL:1+ ITER-001))))
    (CL:SETQ LGG (NEW-VECTOR VEC-SIZE))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-001 (CL:1- VEC-SIZE)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-001))
     (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-001) DO
      (CL:SETQ I ITER-002)
      (CL:LET
       ((SELF (%VECTOR.THE-ARRAY LGG)) (VALUE (WRAP-INTEGER 2))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ ITER-002 (CL:1+ ITER-002))))
    (CL:LET*
     ((INDEX NULL) (ITER-003 (%LIST.THE-CONS-LIST BEST-INDICES)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
      (CL:SETQ INDEX (%%VALUE ITER-003))
      (CL:IF (CL:> (%INTEGER-WRAPPER.WRAPPER-VALUE INDEX) 0)
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY LGG)) (VALUE (WRAP-INTEGER 1))
         (POSITION (CL:1- (%INTEGER-WRAPPER.WRAPPER-VALUE INDEX))))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY LGG)) (VALUE (WRAP-INTEGER 0))
         (POSITION
          (CL:1- (CL:- 0 (%INTEGER-WRAPPER.WRAPPER-VALUE INDEX)))))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE)))
      (CL:SETQ ITER-003 (%%REST ITER-003)))))
   (CL:LOOP WHILE STOP DO (CL:SETQ STOP CL:T)
    (CL:LET*
     ((INDEX NULL)
      (ITER-004 (%LIST.THE-CONS-LIST (COPY BEST-INDICES))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
      (CL:SETQ INDEX (%%VALUE ITER-004))
      (CL:WHEN
       (CL:NOT
        (SIGNATURE-INDICES-COVER-ANY-EXAMPLE?
         (REMOVE (COPY BEST-INDICES) INDEX) NEGATIVE))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "     Removing clause" EOL)
       (CL:SETQ BEST-INDICES (REMOVE BEST-INDICES INDEX))
       (CL:SETQ STOP CL:NIL) (CL:RETURN))
      (CL:SETQ ITER-004 (%%REST ITER-004)))))
   (CL:LET*
    ((INDEX NULL) (ITER-005 (%LIST.THE-CONS-LIST BEST-INDICES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
     (CL:SETQ INDEX (%%VALUE ITER-005))
     (CL:IF (CL:> (%INTEGER-WRAPPER.WRAPPER-VALUE INDEX) 0)
      (CL:SETQ RESULT
       (CONS
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY CONS-PROPS))
         (CL:THE CL:FIXNUM
          (CL:1- (%INTEGER-WRAPPER.WRAPPER-VALUE INDEX))))
        RESULT))
      (CL:SETQ RESULT
       (CONS
        (LIST* SYM-RULE-INDUCTION-LOGIC-FAIL
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY CONS-PROPS))
          (CL:THE CL:FIXNUM
           (CL:1- (CL:- 0 (%INTEGER-WRAPPER.WRAPPER-VALUE INDEX)))))
         NIL)
        RESULT)))
     (CL:SETQ ITER-005 (%%REST ITER-005))))
   RESULT))

;;; (DEFUN (INTERSECT-SIGNATURES (LIST OF INTEGER-WRAPPER)) ...)

(CL:DEFUN INTERSECT-SIGNATURES (SIG1 SIG2)
  (CL:LET* ((RESULT (NEW-LIST)))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH SIG1))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:WHEN
      (CL:AND
       (EQL?
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SIG1)) I)
        ONE-WRAPPER)
       (EQL?
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SIG2)) I)
        ONE-WRAPPER))
      (PUSH RESULT (WRAP-INTEGER (CL:1+ I))))
     (CL:WHEN
      (CL:AND
       (EQL?
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SIG1)) I)
        ZERO-WRAPPER)
       (EQL?
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SIG2)) I)
        ZERO-WRAPPER))
      (PUSH RESULT (WRAP-INTEGER (CL:- 0 (CL:1+ I)))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   RESULT))

;;; (DEFUN (REMOVE-SIGNATURE-COVERED-EXAMPLES (LIST OF TRAINING-EXAMPLE)) ...)

(CL:DEFUN REMOVE-SIGNATURE-COVERED-EXAMPLES (INDICES EXAMPLES)
  (CL:LET* ((REMOVED (NEW-LIST)))
   (CL:LET*
    ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST (COPY EXAMPLES))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:WHEN (SIGNATURE-INDICES-COVER-EXAMPLE? INDICES EXAMPLE)
      (PUSH REMOVED EXAMPLE)
      (CL:SETQ EXAMPLES (REMOVE EXAMPLES EXAMPLE)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   REMOVED))

;;; (DEFUN (NUM-SIGNATURE-INDICES-COVERED INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM)
  NUM-SIGNATURE-INDICES-COVERED))
(CL:DEFUN NUM-SIGNATURE-INDICES-COVERED (INDICES EXAMPLES)
  (CL:LET* ((COUNT 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:WHEN (SIGNATURE-INDICES-COVER-EXAMPLE? INDICES EXAMPLE)
      (CL:SETQ COUNT (CL:1+ COUNT)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   COUNT))

;;; (DEFUN (SIGNATURE-INDICES-COVER-ANY-EXAMPLE? BOOLEAN) ...)

(CL:DEFUN SIGNATURE-INDICES-COVER-ANY-EXAMPLE? (INDICES EXAMPLES)
  (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ EXAMPLE (%%VALUE ITER-000))
    (CL:WHEN (SIGNATURE-INDICES-COVER-EXAMPLE? INDICES EXAMPLE)
     (CL:RETURN-FROM SIGNATURE-INDICES-COVER-ANY-EXAMPLE? CL:T))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  CL:NIL)

;;; (DEFUN (SIGNATURE-INDICES-COVER-EXAMPLE? BOOLEAN) ...)

(CL:DEFUN SIGNATURE-INDICES-COVER-EXAMPLE? (INDICES EXAMPLE)
  (CL:LET* ((ACTUAL 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM ACTUAL))
   (CL:LET* ((INDEX NULL) (ITER-000 (%LIST.THE-CONS-LIST INDICES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ INDEX (%%VALUE ITER-000))
     (CL:SETQ ACTUAL
      (CL:1- (ABS (%INTEGER-WRAPPER.WRAPPER-VALUE INDEX))))
     (CL:IF (CL:> (%INTEGER-WRAPPER.WRAPPER-VALUE INDEX) 0)
      (CL:WHEN
       (EQL?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%TRAINING-EXAMPLE.INPUT EXAMPLE)))
         ACTUAL)
        ZERO-WRAPPER)
       (CL:RETURN-FROM SIGNATURE-INDICES-COVER-EXAMPLE? CL:NIL))
      (CL:WHEN
       (EQL?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%TRAINING-EXAMPLE.INPUT EXAMPLE)))
         ACTUAL)
        ONE-WRAPPER)
       (CL:RETURN-FROM SIGNATURE-INDICES-COVER-EXAMPLE? CL:NIL)))
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  CL:T)

;;; (DEFUN TOP-DOWN-RULE-INDUCTION ...)

(CL:DEFUN %TOP-DOWN-RULE-INDUCTION (EXAMPLES)
  (CL:LET*
   ((POSITIVE (NEW-LIST)) (ALL-POSITIVES (NEW-LIST))
    (NEGATIVE (NEW-LIST)) (UNCOVERED NULL) (COVERED (NEW-LIST))
    (ANTECEDENT NIL) (LINKED-ANTECEDENTS NULL)
    (CONCEPT (%TRAINING-EXAMPLE.CONCEPT (FIRST EXAMPLES)))
    (NUM-RULES 0) (LOOP-CHECK 0)
    (SIGNATURES? *INDUCE-RULES-FROM-SIGNATURES*) (CONS-PROPS NULL)
    (PROPS (NEW-LIST)) (PROPOSITION-VECTOR NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-RULES LOOP-CHECK))
   (CL:SETQ *INDUCED-DECISION-RULES* (NEW-LIST))
   (CL:WHEN
    (CL:NOT
     (CL:EQ (%TRAINING-EXAMPLE.MODULE (FIRST *TRAINING-EXAMPLES*))
      NULL))
    (CHANGE-MODULE
     (%TRAINING-EXAMPLE.MODULE (FIRST *TRAINING-EXAMPLES*))))
   (CL:SETQ PROPS
    (GET-CLASSIFICATION-RELATIONS
     (%TRAINING-EXAMPLE.QUERY (FIRST *TRAINING-EXAMPLES*))))
   (CL:SETQ CONS-PROPS (NEW-VECTOR (LENGTH PROPS)))
   (CL:SETQ PROPOSITION-VECTOR (NEW-VECTOR (LENGTH PROPS)))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH PROPS))) (PROP NULL)
     (ITER-001 (%LIST.THE-CONS-LIST PROPS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:<= ITER-000 UPPER-BOUND-000)
      (CL:NOT (CL:EQ ITER-001 NIL)))
     DO (CL:SETQ I ITER-000) (CL:SETQ PROP (%%VALUE ITER-001))
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY PROPOSITION-VECTOR)) (VALUE PROP)
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY CONS-PROPS))
       (VALUE (PROPOSITION-TO-CONS PROP)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET* ((EXAMPLE NULL) (ITER-002 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-002))
     (CL:IF
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (%TRAINING-EXAMPLE.OUTPUT EXAMPLE))
      (CL:PROGN (PUSH POSITIVE EXAMPLE) (PUSH ALL-POSITIVES EXAMPLE))
      (PUSH NEGATIVE EXAMPLE))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Starting rule induction with " (LENGTH POSITIVE) " positive and "
    (LENGTH NEGATIVE) " negative examples" EOL)
   (CL:LOOP WHILE (CL:NOT (EMPTY? POSITIVE)) DO
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
     (LENGTH POSITIVE) " positive examples left to be covered" EOL)
    (CL:SETQ COVERED (NEW-LIST))
    (CL:SETQ LINKED-ANTECEDENTS (LIST NIL))
    (CL:WHEN *INDUCE-RULES-FROM-SIGNATURES*
     (CL:COND
      ((CL:EQ *SIGNATURE-STRATEGY* KWD-RULE-INDUCTION-BOTTOM-UP)
       (CL:SETQ ANTECEDENT
        (LEARN-ONE-RULE-BOTTOM-UP-FROM-SIGNATURES POSITIVE NEGATIVE
         COVERED CONS-PROPS))
       (CL:SETQ LINKED-ANTECEDENTS
        (LINK-VARIABLES-IN-INDUCED-RULE ANTECEDENT COVERED
         CONS-PROPS)))
      ((CL:EQ *SIGNATURE-STRATEGY* KWD-RULE-INDUCTION-DECISION-TREE)
       (CL:SETQ UNCOVERED (NEW-LIST))
       (CL:LET*
        ((EXAMPLE NULL) (ITER-003 (%LIST.THE-CONS-LIST POSITIVE)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
         (CL:SETQ EXAMPLE (%%VALUE ITER-003)) (PUSH UNCOVERED EXAMPLE)
         (CL:SETQ ITER-003 (%%REST ITER-003))))
       (CL:LET*
        ((EXAMPLE NULL) (ITER-004 (%LIST.THE-CONS-LIST NEGATIVE)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
         (CL:SETQ EXAMPLE (%%VALUE ITER-004)) (PUSH UNCOVERED EXAMPLE)
         (CL:SETQ ITER-004 (%%REST ITER-004))))
       (CL:LET*
        ((TREE-RULE NULL)
         (ITER-005
          (%LIST.THE-CONS-LIST
           (GET-RULES-FROM-TREE
            (%TRAINING-EXAMPLE.QUERY (FIRST UNCOVERED))
            (%INDUCE-DECISION-TREE UNCOVERED))))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
         (CL:SETQ TREE-RULE (%%VALUE ITER-005))
         (CL:WHEN
          (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (%%VALUE TREE-RULE))
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN
            (CL:SETQ COLLECT-000 (CONS (%%REST TREE-RULE) NIL))
            (CL:IF (CL:EQ (%LIST.THE-CONS-LIST LINKED-ANTECEDENTS) NIL)
             (CL:SETF (%LIST.THE-CONS-LIST LINKED-ANTECEDENTS)
              COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST
              (%LIST.THE-CONS-LIST LINKED-ANTECEDENTS) COLLECT-000)))
           (CL:PROGN
            (CL:SETF (%%REST COLLECT-000)
             (CONS (%%REST TREE-RULE) NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
         (CL:SETQ ITER-005 (%%REST ITER-005))))
       (CL:SETQ LINKED-ANTECEDENTS (REMOVE LINKED-ANTECEDENTS NIL)))
      ((CL:EQ *SIGNATURE-STRATEGY* KWD-RULE-INDUCTION-TOP-DOWN)
       (CL:SETQ ANTECEDENT
        (LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES POSITIVE NEGATIVE
         COVERED CONS-PROPS))
       (CL:SETQ LINKED-ANTECEDENTS
        (LINK-VARIABLES-IN-INDUCED-RULE ANTECEDENT COVERED
         CONS-PROPS)))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
         *SIGNATURE-STRATEGY* "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (CL:LET*
     ((ANT NULL) (ITER-006 (%LIST.THE-CONS-LIST LINKED-ANTECEDENTS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
      (CL:SETQ ANT (%%VALUE ITER-006))
      (CL:SETQ COVERED (GET-COVERED-EXAMPLES ANT NEGATIVE))
      (CL:WHEN
       (CL:OR (CL:< (LENGTH COVERED) 10)
        (CL:< (LENGTH COVERED) (LENGTH POSITIVE)) (CL:EQ ANT NIL))
       (CL:WHEN (CL:> (LENGTH COVERED) 0)
        (CL:SETQ ANT
         (SPECIALIZE-RULE ANT *CANDIDATE-CLAUSES* POSITIVE COVERED))
        (CL:SETQ LOOP-CHECK 0)
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ ANT NIL))
          (RULE-COVERS-ANY-EXAMPLE? ANT NEGATIVE))
         DO (CL:SETQ LOOP-CHECK (CL:1+ LOOP-CHECK))
         (CL:WHEN (CL:= LOOP-CHECK 4) (CL:SETQ ANT NIL)
          (CL:SETQ COVERED NEGATIVE) (CL:RETURN))
         (CL:SETQ ANT
          (SPECIALIZE-RULE ANT *CANDIDATE-CLAUSES* POSITIVE COVERED)))
        (CL:WHEN (CL:NOT (CL:EQ ANT NIL)) (CL:SETQ COVERED NULL)))
       (CL:WHEN (CL:OR (CL:EQ COVERED NULL) (EMPTY? COVERED))
        (CL:SETQ COVERED (GET-COVERED-EXAMPLES ANT POSITIVE))
        (CL:LET*
         ((EXAMPLE NULL) (ITER-007 (%LIST.THE-CONS-LIST COVERED)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-007 NIL)) DO
          (CL:SETQ EXAMPLE (%%VALUE ITER-007))
          (CL:SETQ POSITIVE (REMOVE POSITIVE EXAMPLE))
          (CL:SETQ ITER-007 (%%REST ITER-007))))
        (CL:WHEN (CL:= (LENGTH COVERED) 0)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "No Positives Covered by" ANT EOL))
        (CL:WHEN (CL:> (LENGTH COVERED) 0)
         (PUSH *INDUCED-DECISION-RULES*
          (LIST* SYM-RULE-INDUCTION-STELLA-=>
           (CONS SYM-RULE-INDUCTION-STELLA-AND
            (CONCATENATE (REVERSE (COPY-CONS-TREE ANT)) NIL))
           (CONS CONCEPT (CONS SYM-RULE-INDUCTION-LOGIC-?Y NIL)) NIL))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "Adding rule to cover " (LENGTH COVERED) " examples" EOL))))
      (CL:SETQ ITER-006 (%%REST ITER-006))))
    (CL:IF (CL:= (LENGTH *INDUCED-DECISION-RULES*) NUM-RULES)
     (CL:PROGN
      (CL:WHEN (CL:NOT *INDUCE-RULES-FROM-SIGNATURES*)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "Stopping with " (LENGTH POSITIVE) " examples uncovered" EOL)
       (CL:RETURN))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       (LENGTH POSITIVE)
       " examples uncovered, switching to full query-based induction"
       EOL)
      (CL:SETQ *INDUCE-RULES-FROM-SIGNATURES* CL:NIL))
     (CL:SETQ *INDUCE-RULES-FROM-SIGNATURES* SIGNATURES?))
    (CL:SETQ NUM-RULES (LENGTH *INDUCED-DECISION-RULES*)))
   (CL:SETQ *INDUCE-RULES-FROM-SIGNATURES* SIGNATURES?)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
    "PowerLoom has induced the following rules" EOL EOL)
   (CL:LET*
    ((RULE NULL)
     (ITER-008 (%LIST.THE-CONS-LIST *INDUCED-DECISION-RULES*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-008 NIL)) DO
     (CL:SETQ RULE (%%VALUE ITER-008))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      RULE EOL)
     (CL:SETQ ITER-008 (%%REST ITER-008))))))

(CL:DEFMACRO TOP-DOWN-RULE-INDUCTION (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/TOP-DOWN-RULE-INDUCTION|)) (CL:MACRO-FUNCTION (CL:QUOTE TOP-DOWN-RULE-INDUCTION)))

;;; (DEFUN (BUILD-ANTECEDENT-FROM-RULE-INDEX (CONS OF CONS)) ...)

(CL:DEFUN BUILD-ANTECEDENT-FROM-RULE-INDEX (PROPS RULE-INDEX)
  (CL:LET* ((ANTECEDENT NIL) (CONS-PROP NIL))
   (CL:LET* ((INDEX NULL) (ITER-000 (%LIST.THE-CONS-LIST RULE-INDEX)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ INDEX (%%VALUE ITER-000))
     (CL:IF (CL:< (%INTEGER-WRAPPER.WRAPPER-VALUE INDEX) 0)
      (CL:SETQ CONS-PROP
       (LIST* SYM-RULE-INDUCTION-LOGIC-FAIL
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY PROPS))
         (CL:THE CL:FIXNUM
          (CL:1- (ABS (%INTEGER-WRAPPER.WRAPPER-VALUE INDEX)))))
        NIL))
      (CL:SETQ CONS-PROP
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY PROPS))
        (CL:THE CL:FIXNUM
         (CL:1- (ABS (%INTEGER-WRAPPER.WRAPPER-VALUE INDEX)))))))
     (CL:SETQ ANTECEDENT (CONS CONS-PROP ANTECEDENT))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   ANTECEDENT))

;;; (DEFUN (LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES (CONS OF CONS)) ...)

(CL:DEFUN LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES (POSITIVE NEGATIVE COVERED_POS CONS-PROPS)
  (CL:LET*
   ((CURRENT_UTILITY 0.0d0) (RULE (NEW-LIST)) (GAIN 0.0d0)
    (MAX_GAIN 0.0d0) (USED_FEATURES (NEW-LIST)) (NUM_FEATURES 0)
    (VARS (NEW-LIST)) (VARIABLE-TABLE NULL) (FEATURE_INDEX 0)
    (COVERED_NEG (NEW-LIST)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT CURRENT_UTILITY GAIN MAX_GAIN)
    (CL:TYPE CL:FIXNUM NUM_FEATURES FEATURE_INDEX))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Learning rule top down from signatures over " (LENGTH POSITIVE)
    " positives" EOL)
   (CL:WHEN (EMPTY? POSITIVE)
    (CL:RETURN-FROM LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES NIL))
   (CL:SETQ NUM_FEATURES
    (LENGTH (%TRAINING-EXAMPLE.INPUT (FIRST POSITIVE))))
   (CL:SETQ VARIABLE-TABLE (NEW-VECTOR (CL:1+ NUM_FEATURES)))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 NUM_FEATURES)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY VARIABLE-TABLE))
       (VALUE
        (GET-VARIABLES-FROM-CONS-PROPOSITIONS
         (CONS-LIST
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY CONS-PROPS))
           (CL:THE CL:FIXNUM (CL:1- I))))))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (PUSH VARS SYM-RULE-INDUCTION-LOGIC-?Y)
   (CL:LET*
    ((EXAMPLE NULL) (ITER-001 (%LIST.THE-CONS-LIST NEGATIVE))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-001))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS EXAMPLE NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST COVERED_NEG) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST COVERED_NEG) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST COVERED_NEG)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS EXAMPLE NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET*
    ((EXAMPLE NULL) (ITER-002 (%LIST.THE-CONS-LIST POSITIVE))
     (COLLECT-001 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-002))
     (CL:IF (CL:EQ COLLECT-001 NULL)
      (CL:PROGN (CL:SETQ COLLECT-001 (CONS EXAMPLE NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST COVERED_POS) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST COVERED_POS) COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST COVERED_POS)
         COLLECT-001)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS EXAMPLE NIL))
       (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (CL:LOOP WHILE (CL:NOT (EMPTY? COVERED_NEG)) DO
    (CL:SETQ CURRENT_UTILITY
     (FOIL-UTILITY (LENGTH COVERED_POS) (LENGTH COVERED_NEG)))
    (CL:SETQ MAX_GAIN 0.0d0)
    (CL:LET*
     ((I NULL-INTEGER) (ITER-003 1) (UPPER-BOUND-001 NUM_FEATURES)
      (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003 UPPER-BOUND-001))
     (CL:LOOP WHILE
      (CL:OR UNBOUNDED?-001 (CL:<= ITER-003 UPPER-BOUND-001)) DO
      (CL:SETQ I ITER-003)
      (CL:WHEN (CL:NOT (MEMBER? USED_FEATURES (WRAP-INTEGER I)))
       (CL:LET* ((TEST-VALUE-000 CL:NIL))
        (CL:SETQ TEST-VALUE-000 *ENFORCE-LINKED-VARIABLES*)
        (CL:WHEN TEST-VALUE-000
         (CL:LET* ((FOUND?-000 CL:NIL))
          (CL:LET*
           ((ELE NULL)
            (ITER-004
             (%LIST.THE-CONS-LIST
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (%VECTOR.THE-ARRAY VARIABLE-TABLE))
               I))))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
            (CL:SETQ ELE (%%VALUE ITER-004))
            (CL:WHEN (MEMBER? VARS ELE) (CL:SETQ FOUND?-000 CL:T)
             (CL:RETURN))
            (CL:SETQ ITER-004 (%%REST ITER-004))))
          (CL:SETQ TEST-VALUE-000 FOUND?-000))
         (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000)))
        (CL:IF TEST-VALUE-000 (CL:SETQ GAIN -9999.0d0)
         (CL:SETQ GAIN
          (FOIL-GAIN I CURRENT_UTILITY COVERED_POS COVERED_NEG))))
       (CL:WHEN *TRACE-FOIL*
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "Foil gain on feature " I ": " GAIN EOL))
       (CL:WHEN (CL:> GAIN MAX_GAIN) (CL:SETQ FEATURE_INDEX I)
        (CL:SETQ MAX_GAIN GAIN))
       (CL:LET* ((TEST-VALUE-001 CL:NIL))
        (CL:SETQ TEST-VALUE-001 *ENFORCE-LINKED-VARIABLES*)
        (CL:WHEN TEST-VALUE-001
         (CL:LET* ((FOUND?-001 CL:NIL))
          (CL:LET*
           ((ELE NULL)
            (ITER-005
             (%LIST.THE-CONS-LIST
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (%VECTOR.THE-ARRAY VARIABLE-TABLE))
               I))))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
            (CL:SETQ ELE (%%VALUE ITER-005))
            (CL:WHEN (MEMBER? VARS ELE) (CL:SETQ FOUND?-001 CL:T)
             (CL:RETURN))
            (CL:SETQ ITER-005 (%%REST ITER-005))))
          (CL:SETQ TEST-VALUE-001 FOUND?-001))
         (CL:SETQ TEST-VALUE-001 (CL:NOT TEST-VALUE-001)))
        (CL:IF TEST-VALUE-001 (CL:SETQ GAIN -9999.0d0)
         (CL:SETQ GAIN
          (FOIL-GAIN (CL:- 0 I) CURRENT_UTILITY COVERED_POS
           COVERED_NEG))))
       (CL:WHEN *TRACE-FOIL*
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "Foil gain on feature " I ": " GAIN EOL))
       (CL:WHEN (CL:> GAIN MAX_GAIN) (CL:SETQ FEATURE_INDEX (CL:- 0 I))
        (CL:SETQ MAX_GAIN GAIN)))
      (CL:SETQ ITER-003 (CL:1+ ITER-003))))
    (CL:WHEN (CL:= MAX_GAIN 0.0d0) (CL:SETQ COVERED_POS (NEW-LIST))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "   Darn, nothing we can do here, returning nil." EOL)
     (CL:RETURN-FROM LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES NIL))
    (CL:WHEN *TRACE-FOIL*
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "** Choosing feature "
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY CONS-PROPS))
       (CL:THE CL:FIXNUM (ABS (CL:1- FEATURE_INDEX))))
      EOL))
    (CL:WHEN *ENFORCE-LINKED-VARIABLES*
     (CL:LET*
      ((VAR NULL)
       (ITER-006
        (%LIST.THE-CONS-LIST
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VARIABLE-TABLE))
          (CL:THE CL:FIXNUM
           (CL:IF (CL:< FEATURE_INDEX 0) (CL:- 0 FEATURE_INDEX)
            FEATURE_INDEX))))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
       (CL:SETQ VAR (%%VALUE ITER-006))
       (CL:WHEN (CL:NOT (MEMBER? VARS VAR)) (PUSH VARS VAR))
       (CL:SETQ ITER-006 (%%REST ITER-006)))))
    (UPDATE-COVERED-EXAMPLES FEATURE_INDEX COVERED_POS COVERED_NEG)
    (PUSH USED_FEATURES
     (WRAP-INTEGER
      (CL:IF (CL:< FEATURE_INDEX 0) (CL:- 0 FEATURE_INDEX)
       FEATURE_INDEX)))
    (PUSH RULE (WRAP-INTEGER FEATURE_INDEX)))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "   Returning with " (LENGTH COVERED_POS) " positives and "
    (LENGTH COVERED_NEG) " negatives covered" EOL)
   (BUILD-ANTECEDENT-FROM-RULE-INDEX CONS-PROPS RULE)))

;;; (DEFUN UPDATE-EXAMPLE-MATCHES ...)

(CL:DEFUN UPDATE-EXAMPLE-MATCHES (EXAMPLES INDEX MATCH-VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX))
  #+MCL
  (CL:CHECK-TYPE INDEX CL:FIXNUM)
  (CL:LET* ((TEMP NIL))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:COND
      ((CL:<= (LENGTH (%TRAINING-EXAMPLE.INPUT EXAMPLE)) INDEX)
       (CL:WARN
        "Bad training example, not enough features.  Needs `~A'~%`~A'"
        (CL:1+ INDEX) (%TRAINING-EXAMPLE.QUERY EXAMPLE)))
      ((EQL?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%TRAINING-EXAMPLE.INPUT EXAMPLE)))
         INDEX)
        MATCH-VALUE)
       (CL:SETQ TEMP (CONS EXAMPLE TEMP))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETF (%LIST.THE-CONS-LIST EXAMPLES) TEMP)))

;;; (DEFUN UPDATE-COVERED-EXAMPLES ...)

(CL:DEFUN UPDATE-COVERED-EXAMPLES (FEATURE_INDEX COVERED_POS COVERED_NEG)
  (CL:DECLARE (CL:TYPE CL:FIXNUM FEATURE_INDEX))
  #+MCL
  (CL:CHECK-TYPE FEATURE_INDEX CL:FIXNUM)
  (CL:LET*
   ((MATCH-VALUE
     (CL:IF (CL:> FEATURE_INDEX 0) ZERO-WRAPPER ONE-WRAPPER))
    (INDEX
     (CL:1-
      (CL:IF (CL:< FEATURE_INDEX 0) (CL:- 0 FEATURE_INDEX)
       FEATURE_INDEX))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX))
   (UPDATE-EXAMPLE-MATCHES COVERED_POS INDEX MATCH-VALUE)
   (UPDATE-EXAMPLE-MATCHES COVERED_NEG INDEX MATCH-VALUE)))

;;; (DEFUN (COUNT-EXAMPLE-MATCHES INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:FIXNUM CL:T) CL:FIXNUM)
  COUNT-EXAMPLE-MATCHES))
(CL:DEFUN COUNT-EXAMPLE-MATCHES (EXAMPLES INDEX MATCH-VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX))
  #+MCL
  (CL:CHECK-TYPE INDEX CL:FIXNUM)
  (CL:LET* ((N 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM N))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:COND
      ((CL:<= (LENGTH (%TRAINING-EXAMPLE.INPUT EXAMPLE)) INDEX)
       (CL:WARN
        "Bad training example, not enough features.  Needs `~A'~%`~A'"
        (CL:1+ INDEX) (%TRAINING-EXAMPLE.QUERY EXAMPLE)))
      ((EQL?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%TRAINING-EXAMPLE.INPUT EXAMPLE)))
         INDEX)
        MATCH-VALUE)
       (CL:SETQ N (CL:1+ N))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   N))

;;; (DEFUN (FOIL-GAIN FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:FIXNUM CL:DOUBLE-FLOAT CL:T CL:T) CL:DOUBLE-FLOAT)
  FOIL-GAIN))
(CL:DEFUN FOIL-GAIN (FEATURE-INDEX UTILITY COVERED-POS COVERED-NEG)
  (CL:DECLARE (CL:TYPE CL:FIXNUM FEATURE-INDEX)
   (CL:TYPE CL:DOUBLE-FLOAT UTILITY))
  #+MCL
  (CL:CHECK-TYPE FEATURE-INDEX CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE UTILITY CL:DOUBLE-FLOAT)
  (CL:LET*
   ((MATCH-VALUE
     (CL:IF (CL:< FEATURE-INDEX 0) ZERO-WRAPPER ONE-WRAPPER))
    (INDEX
     (CL:1-
      (CL:IF (CL:< FEATURE-INDEX 0) (CL:- 0 FEATURE-INDEX)
       FEATURE-INDEX)))
    (P (COUNT-EXAMPLE-MATCHES COVERED-POS INDEX MATCH-VALUE))
    (N (COUNT-EXAMPLE-MATCHES COVERED-NEG INDEX MATCH-VALUE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX P N))
   (CL:* P (CL:- (FOIL-UTILITY P N) UTILITY))))

;;; (DEFUN (FOIL-UTILITY FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:FIXNUM CL:FIXNUM) CL:DOUBLE-FLOAT)
  FOIL-UTILITY))
(CL:DEFUN FOIL-UTILITY (P N)
  (CL:DECLARE (CL:TYPE CL:FIXNUM P N))
  #+MCL
  (CL:CHECK-TYPE P CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:WHEN (CL:= P 0) (CL:RETURN-FROM FOIL-UTILITY (CL:FLOAT 0 0.0d0)))
  (CL:/
   (CL:THE CL:DOUBLE-FLOAT
    (CL:LOG
     (CL:THE CL:DOUBLE-FLOAT (CL:/ (CL:FLOAT P 0.0d0) (CL:+ P N)))))
   LOG_2))

;;; (DEFUN (LEARN-ONE-RULE-TOP-DOWN (CONS OF CONS)) ...)

(CL:DEFUN LEARN-ONE-RULE-TOP-DOWN (PROPOSITIONS POSITIVE NEGATIVE)
  (SPECIALIZE-RULE NIL PROPOSITIONS POSITIVE NEGATIVE))

;;; (DEFUN (SPECIALIZE-RULE (CONS OF CONS)) ...)

(CL:DEFUN SPECIALIZE-RULE (RULE PROPOSITIONS POSITIVE NEGATIVE)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "Specializing " EOL)
  (CL:LET*
   ((CANDIDATES (NEW-LIST)) (COVERED-NEGS (NEW-LIST))
    (COVERED-POS (NEW-LIST)) (CURRENT_UTILITY 0.0d0) (FEATURE-INDEX 0)
    (NEW-CLAUSE NIL) (VARS (GET-VARIABLES-FROM-CONS-PROPOSITIONS RULE))
    (VARIABLE-TABLE NULL) (GAIN 0.0d0) (MAX 0.0d0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT CURRENT_UTILITY GAIN MAX)
    (CL:TYPE CL:FIXNUM FEATURE-INDEX))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST NEGATIVE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
      (PUSH COVERED-NEGS EXAMPLE))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((EXAMPLE NULL) (ITER-001 (%LIST.THE-CONS-LIST POSITIVE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-001))
     (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
      (PUSH COVERED-POS EXAMPLE))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:WHEN (EMPTY? COVERED-NEGS)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     " No covered negatives" EOL)
    (CL:RETURN-FROM SPECIALIZE-RULE RULE))
   (CL:WHEN (CL:NOT (MEMBER? VARS SYM-RULE-INDUCTION-LOGIC-?Y))
    (PUSH VARS SYM-RULE-INDUCTION-LOGIC-?Y))
   (CL:SETQ VARIABLE-TABLE (NEW-VECTOR (CL:1+ (LENGTH PROPOSITIONS))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-002 1)
     (UPPER-BOUND-000 (LENGTH PROPOSITIONS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-002)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY VARIABLE-TABLE))
       (VALUE
        (GET-VARIABLES-FROM-CONS-PROPOSITIONS
         (CONS-LIST
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY PROPOSITIONS))
           (CL:THE CL:FIXNUM (CL:1- I))))))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-003 1)
     (UPPER-BOUND-001 (LENGTH PROPOSITIONS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-003 UPPER-BOUND-001) DO
     (CL:SETQ I ITER-003) (PUSH CANDIDATES (WRAP-INTEGER I))
     (PUSH CANDIDATES (WRAP-INTEGER (CL:- 0 I)))
     (CL:SETQ ITER-003 (CL:1+ ITER-003))))
   (CL:LET* ((CLAUSE NULL) (ITER-004 RULE))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
     (CL:SETQ CLAUSE (%%VALUE ITER-004))
     (CL:LET*
      ((PROP NULL) (VECTOR-000 PROPOSITIONS) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-005 1))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-005))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ PROP
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ I ITER-005)
       (CL:WHEN (EQUAL-CONS-TREES? PROP CLAUSE)
        (CL:SETQ CANDIDATES (REMOVE CANDIDATES (WRAP-INTEGER I)))
        (CL:RETURN))
       (CL:WHEN
        (EQUAL-CONS-TREES?
         (LIST* SYM-RULE-INDUCTION-LOGIC-FAIL PROP NIL) CLAUSE)
        (CL:SETQ CANDIDATES
         (REMOVE CANDIDATES (WRAP-INTEGER (CL:- 0 I))))
        (CL:RETURN))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
       (CL:SETQ ITER-005 (CL:1+ ITER-005))))
     (CL:SETQ ITER-004 (%%REST ITER-004))))
   (CL:LOOP WHILE (CL:NOT (EMPTY? COVERED-NEGS)) DO
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "   Covers " (LENGTH COVERED-NEGS) " negs, and "
     (LENGTH COVERED-POS) " pos" EOL)
    (CL:SETQ CURRENT_UTILITY
     (FOIL-UTILITY (LENGTH COVERED-POS) (LENGTH COVERED-NEGS)))
    (CL:SETQ MAX 0.0d0)
    (CL:LET*
     ((I NULL) (ITER-006 (%LIST.THE-CONS-LIST (COPY CANDIDATES))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
      (CL:SETQ I (%%VALUE ITER-006))
      (CL:LET* ((FOUND?-000 CL:NIL))
       (CL:LET*
        ((ELE NULL)
         (ITER-007
          (%LIST.THE-CONS-LIST
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY VARIABLE-TABLE))
            (CL:THE CL:FIXNUM
             (ABS (%INTEGER-WRAPPER.WRAPPER-VALUE I)))))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-007 NIL)) DO
         (CL:SETQ ELE (%%VALUE ITER-007))
         (CL:WHEN (MEMBER? VARS ELE) (CL:SETQ FOUND?-000 CL:T)
          (CL:RETURN))
         (CL:SETQ ITER-007 (%%REST ITER-007))))
       (CL:WHEN FOUND?-000
        (CL:IF (CL:> (%INTEGER-WRAPPER.WRAPPER-VALUE I) 0)
         (CL:SETQ GAIN
          (QUERY-FOIL-GAIN
           (CONS
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY PROPOSITIONS))
             (CL:THE CL:FIXNUM
              (CL:1- (%INTEGER-WRAPPER.WRAPPER-VALUE I))))
            RULE)
           CURRENT_UTILITY COVERED-POS COVERED-NEGS))
         (CL:SETQ GAIN
          (QUERY-FOIL-GAIN
           (CONS
            (LIST* SYM-RULE-INDUCTION-LOGIC-FAIL
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%VECTOR.THE-ARRAY PROPOSITIONS))
              (CL:THE CL:FIXNUM
               (CL:1- (CL:- 0 (%INTEGER-WRAPPER.WRAPPER-VALUE I)))))
             NIL)
            RULE)
           CURRENT_UTILITY COVERED-POS COVERED-NEGS)))
        (CL:WHEN (CL:> GAIN MAX)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "    Current: "
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY PROPOSITIONS))
           (CL:THE CL:FIXNUM
            (CL:1- (ABS (%INTEGER-WRAPPER.WRAPPER-VALUE I)))))
          ": " GAIN)
         (CL:IF (CL:< (%INTEGER-WRAPPER.WRAPPER-VALUE I) 0)
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) " Negated"
           EOL)
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL))
         (CL:SETQ FEATURE-INDEX (%INTEGER-WRAPPER.WRAPPER-VALUE I))
         (CL:SETQ MAX GAIN))))
      (CL:SETQ ITER-006 (%%REST ITER-006))))
    (CL:WHEN (CL:= MAX 0.0d0)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "   No features provide any gain" EOL)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "   Can't separate " EOL)
     (CL:LET* ((POS NULL) (ITER-008 (%LIST.THE-CONS-LIST COVERED-POS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-008 NIL)) DO
       (CL:SETQ POS (%%VALUE ITER-008))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "     " (%TRAINING-EXAMPLE.NAME POS) EOL)
       (CL:SETQ ITER-008 (%%REST ITER-008))))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "   From " EOL)
     (CL:LET*
      ((NEG NULL) (ITER-009 (%LIST.THE-CONS-LIST COVERED-NEGS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-009 NIL)) DO
       (CL:SETQ NEG (%%VALUE ITER-009))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "     " (%TRAINING-EXAMPLE.NAME NEG) EOL)
       (CL:SETQ ITER-009 (%%REST ITER-009))))
     (CL:RETURN-FROM SPECIALIZE-RULE NIL))
    (CL:LET*
     ((VAR NULL)
      (ITER-010
       (%LIST.THE-CONS-LIST
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VARIABLE-TABLE))
         (CL:THE CL:FIXNUM
          (CL:IF (CL:< FEATURE-INDEX 0) (CL:- 0 FEATURE-INDEX)
           FEATURE-INDEX))))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-010 NIL)) DO
      (CL:SETQ VAR (%%VALUE ITER-010))
      (CL:WHEN (CL:NOT (MEMBER? VARS VAR)) (PUSH VARS VAR))
      (CL:SETQ ITER-010 (%%REST ITER-010))))
    (CL:SETQ CANDIDATES
     (REMOVE CANDIDATES (WRAP-INTEGER FEATURE-INDEX)))
    (CL:SETQ NEW-CLAUSE
     (COPY-CONS-TREE
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY PROPOSITIONS))
       (CL:THE CL:FIXNUM
        (CL:1-
         (CL:IF (CL:< FEATURE-INDEX 0) (CL:- 0 FEATURE-INDEX)
          FEATURE-INDEX))))))
    (CL:WHEN (CL:< FEATURE-INDEX 0)
     (CL:SETQ NEW-CLAUSE
      (LIST* SYM-RULE-INDUCTION-LOGIC-FAIL NEW-CLAUSE NIL)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "   Adding clause " NEW-CLAUSE EOL)
    (CL:SETQ RULE (CONS NEW-CLAUSE RULE))
    (REMOVE-EXCLUDED-EXAMPLES RULE COVERED-POS COVERED-NEGS))
   RULE))

;;; (DEFUN REMOVE-EXCLUDED-EXAMPLES ...)

(CL:DEFUN REMOVE-EXCLUDED-EXAMPLES (RULE COVERED-POS COVERED-NEG)
  (CL:LET*
   ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST (COPY COVERED-NEG))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ EXAMPLE (%%VALUE ITER-000))
    (CL:WHEN (CL:NOT (RULE-COVERS-EXAMPLE? RULE EXAMPLE))
     (CL:SETQ COVERED-NEG (REMOVE COVERED-NEG EXAMPLE)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:LET*
   ((EXAMPLE NULL) (ITER-001 (%LIST.THE-CONS-LIST (COPY COVERED-POS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:SETQ EXAMPLE (%%VALUE ITER-001))
    (CL:WHEN (CL:NOT (RULE-COVERS-EXAMPLE? RULE EXAMPLE))
     (CL:SETQ COVERED-POS (REMOVE COVERED-POS EXAMPLE)))
    (CL:SETQ ITER-001 (%%REST ITER-001)))))

;;; (DEFUN (QUERY-FOIL-GAIN FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:T CL:DOUBLE-FLOAT CL:T CL:T) CL:DOUBLE-FLOAT)
  QUERY-FOIL-GAIN))
(CL:DEFUN QUERY-FOIL-GAIN (RULE UTILITY COVERED-POS COVERED-NEG)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT UTILITY))
  #+MCL
  (CL:CHECK-TYPE UTILITY CL:DOUBLE-FLOAT)
  (CL:LET* ((P 0) (N 0) (RESULT 0.0d0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM P N)
    (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CL:LET*
    ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST COVERED-NEG)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
      (CL:SETQ N (CL:1+ N)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((EXAMPLE NULL) (ITER-001 (%LIST.THE-CONS-LIST COVERED-POS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-001))
     (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
      (CL:SETQ P (CL:1+ P)))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:WHEN (CL:AND (CL:= P 0) (CL:= N 0))
    (CL:RETURN-FROM QUERY-FOIL-GAIN 0.0d0))
   (CL:SETQ RESULT (CL:* P (CL:- (FOIL-UTILITY P N) UTILITY)))
   (CL:WHEN (CL:< RESULT 1.0d-6) (CL:SETQ RESULT 0.0d0)) RESULT))

;;; (DEFUN QUERY-AND-UPDATE-COVERED-EXAMPLES ...)

(CL:DEFUN QUERY-AND-UPDATE-COVERED-EXAMPLES (RULE UNCOVERED COVERED)
  (CL:LET*
   ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST (COPY UNCOVERED)))
    (COLLECT-000 NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ EXAMPLE (%%VALUE ITER-000))
    (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS EXAMPLE NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST COVERED) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST COVERED) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST COVERED)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS EXAMPLE NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN REMOVE-COVERED-EXAMPLES ...)

(CL:DEFUN REMOVE-COVERED-EXAMPLES (RULE UNCOVERED)
  (CL:LET*
   ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST (COPY UNCOVERED))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ EXAMPLE (%%VALUE ITER-000))
    (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
     (CL:SETQ UNCOVERED (REMOVE UNCOVERED EXAMPLE)))
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN (NUM-EXAMPLES-COVERED INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM) NUM-EXAMPLES-COVERED))
(CL:DEFUN NUM-EXAMPLES-COVERED (RULE EXAMPLES)
  (CL:LET* ((COUNT 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
      (CL:SETQ COUNT (CL:1+ COUNT)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   COUNT))

;;; (DEFUN (GET-COVERED-EXAMPLES (LIST OF TRAINING-EXAMPLE)) ...)

(CL:DEFUN GET-COVERED-EXAMPLES (RULE UNCOVERED)
  (CL:LET* ((COVERED (NEW-LIST)))
   (CL:LET*
    ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST UNCOVERED))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS EXAMPLE NIL))
        (CL:IF (CL:EQ (%LIST.THE-CONS-LIST COVERED) NIL)
         (CL:SETF (%LIST.THE-CONS-LIST COVERED) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST COVERED)
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS EXAMPLE NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   COVERED))

;;; (DEFUN (RULE-COVERS-ANY-EXAMPLE? BOOLEAN) ...)

(CL:DEFUN RULE-COVERS-ANY-EXAMPLE? (RULE EXAMPLES)
  (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ EXAMPLE (%%VALUE ITER-000))
    (CL:WHEN (RULE-COVERS-EXAMPLE? RULE EXAMPLE)
     (CL:RETURN-FROM RULE-COVERS-ANY-EXAMPLE? CL:T))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  CL:NIL)

;;; (DEFUN (RULE-COVERS-EXAMPLE? BOOLEAN) ...)

(CL:DEFUN RULE-COVERS-EXAMPLE? (REVERSE-RULE EXAMPLE)
  (CL:WHEN (CL:EQ REVERSE-RULE NIL)
   (CL:RETURN-FROM RULE-COVERS-EXAMPLE? CL:T))
  (CL:LET*
   ((QUERY NULL) (RULE (REVERSE (COPY-CONS-TREE REVERSE-RULE)))
    (VARS
     (REMOVE (GET-VARIABLES-FROM-CONS-PROPOSITIONS RULE)
      SYM-RULE-INDUCTION-LOGIC-?Y))
    (CONS-QUERY NIL) (TYPES NIL))
   (CL:WHEN (CL:NOT (CL:EQ (%TRAINING-EXAMPLE.MODULE EXAMPLE) NULL))
    (CHANGE-MODULE (%TRAINING-EXAMPLE.MODULE EXAMPLE)))
   (CL:SETQ CONS-QUERY
    (CONS SYM-RULE-INDUCTION-STELLA-AND
     (SUBSTITUTE-CONS-TREE RULE (%TRAINING-EXAMPLE.NAME EXAMPLE)
      SYM-RULE-INDUCTION-LOGIC-?Y)))
   (CL:WHEN (CL:NOT (EMPTY? VARS))
    (CL:LET* ((VAR NULL) (ITER-000 (%LIST.THE-CONS-LIST VARS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ VAR (%%VALUE ITER-000))
      (CL:IF
       (CL:AND *ENABLE-USER-THING*
        (CL:EQL
         (CL:LET ((SELF (%SYMBOL.SYMBOL-NAME VAR)) (POSITION 1))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION)))
         #\X))
       (CL:SETQ TYPES
        (CONS (CONS VAR (CONS SYM-RULE-INDUCTION-LOGIC-USER-THING NIL))
         TYPES))
       (CL:SETQ TYPES (CONS VAR TYPES)))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:SETQ CONS-QUERY
     (LIST* SYM-RULE-INDUCTION-STELLA-EXISTS TYPES
      (CONS CONS-QUERY NIL))))
   (CL:IF *OPTIMIZE-INDUCED-QUERIES*
    (CL:SETQ QUERY
     (MAKE-QUERY NIL CONS-QUERY NIL
      (LIST* KWD-RULE-INDUCTION-TIMEOUT (WRAP-INTEGER 300) NIL)))
    (CL:SETQ QUERY
     (MAKE-QUERY NIL CONS-QUERY NIL
      (LIST* KWD-RULE-INDUCTION-TIMEOUT (WRAP-INTEGER 300)
       KWD-RULE-INDUCTION-DONT-OPTIMIZE? SYM-RULE-INDUCTION-STELLA-TRUE
       NIL))))
   (TRUE-TRUTH-VALUE? (CALL-ASK QUERY))))

;;; (DEFUN (LINK-VARIABLES-IN-INDUCED-RULE (LIST OF (CONS OF CONS))) ...)

(CL:DEFUN LINK-VARIABLES-IN-INDUCED-RULE (RULE EXAMPLES CONS-PROPS)
  (CL:LET*
   ((VARS NULL) (TEMP-RULE NIL) (VAR NULL) (UNLINKED NULL)
    (LINKED NULL) (NEW-RULES (NEW-LIST)))
   (CL:SETQ VARS (GET-VARIABLES-FROM-CONS-PROPOSITIONS RULE))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%TRAINING-EXAMPLE.INPUT EXAMPLE) NULL)
      (CL:SETF (%TRAINING-EXAMPLE.INPUT EXAMPLE)
       (CREATE-INPUT-SIGNATURE (%TRAINING-EXAMPLE.QUERY EXAMPLE))))
     (CL:SETQ TEMP-RULE (COPY-CONS-TREE RULE))
     (CL:SETQ UNLINKED (NEW-LIST)) (CL:SETQ LINKED (NEW-LIST))
     (CL:LET*
      ((VAR NULL) (ITER-001 (%LIST.THE-CONS-LIST VARS))
       (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ VAR (%%VALUE ITER-001))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS VAR NIL))
         (CL:IF (CL:EQ (%LIST.THE-CONS-LIST UNLINKED) NIL)
          (CL:SETF (%LIST.THE-CONS-LIST UNLINKED) COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST UNLINKED)
           COLLECT-000)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VAR NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:SETQ UNLINKED (REMOVE UNLINKED SYM-RULE-INDUCTION-LOGIC-?Y))
     (PUSH LINKED SYM-RULE-INDUCTION-LOGIC-?Y)
     (CL:LOOP WHILE (CL:NOT (EMPTY? UNLINKED)) DO
      (CL:SETQ VAR (POP UNLINKED))
      (CL:LET*
       ((PROP NULL) (VECTOR-000 CONS-PROPS) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-002 0))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-002))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ PROP
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ I ITER-002)
        (CL:WHEN (MEMBER? PROP VAR)
         (CL:LET* ((FOUND?-000 CL:NIL))
          (CL:LET* ((ELE NULL) (ITER-003 TEMP-RULE))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
            (CL:SETQ ELE (%%VALUE ITER-003))
            (CL:WHEN (EQUAL-CONS-TREES? ELE PROP)
             (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
            (CL:SETQ ITER-003 (%%REST ITER-003))))
          (CL:WHEN FOUND?-000 (PUSH LINKED VAR) (CL:RETURN)))
         (CL:WHEN
          (EQL?
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY (%TRAINING-EXAMPLE.INPUT EXAMPLE)))
            I)
           ONE-WRAPPER)
          (CL:SETQ TEMP-RULE
           (CONCATENATE TEMP-RULE (CONS-LIST (COPY-CONS-TREE PROP))))
          (CL:LET* ((NEW-VAR NULL) (ITER-004 (%%REST PROP)))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
            (CL:SETQ NEW-VAR (%%VALUE ITER-004))
            (CL:WHEN
             (CL:AND (CL:NOT (CL:EQ NEW-VAR VAR)) (SYMBOL? NEW-VAR)
              (CL:NOT (MEMBER? LINKED NEW-VAR)))
             (PUSH UNLINKED NEW-VAR))
            (CL:SETQ ITER-004 (%%REST ITER-004))))
          (PUSH LINKED VAR) (CL:RETURN)))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
        (CL:SETQ ITER-002 (CL:1+ ITER-002)))))
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:LET* ((FOUND?-001 CL:NIL))
       (CL:LET* ((ELE NULL) (ITER-005 (%LIST.THE-CONS-LIST NEW-RULES)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
         (CL:SETQ ELE (%%VALUE ITER-005))
         (CL:WHEN (EQUAL-CONS-TREES? ELE TEMP-RULE)
          (CL:SETQ FOUND?-001 CL:T) (CL:RETURN))
         (CL:SETQ ITER-005 (%%REST ITER-005))))
       (CL:SETQ TEST-VALUE-000 FOUND?-001))
      (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
      (CL:WHEN TEST-VALUE-000 (PUSH NEW-RULES TEMP-RULE)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((IT (ALLOCATE-ITERATOR NEW-RULES)))
    (CL:LOOP WHILE (NEXT? IT) DO
     (VALUE-SETTER IT (REVERSE (%LIST-ITERATOR.VALUE IT)))))
   NEW-RULES))

;;; (DEFUN (EVALUATE-RULE-INDUCTION (VECTOR OF FLOAT-WRAPPER)) ...)

(CL:DEFUN %EVALUATE-RULE-INDUCTION (RELATION-NAME CLASS-NAME NUM-TRIALS CURVE-SPLITS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-TRIALS CURVE-SPLITS))
  #+MCL
  (CL:CHECK-TYPE NUM-TRIALS CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE CURVE-SPLITS CL:FIXNUM)
  (CL:LET*
   ((CLASS
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION CLASS-NAME)))
    (RELATION
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION RELATION-NAME)))
    (ILIST (LISTIFY (ALL-CLASS-INSTANCES CLASS))) (NUM (LENGTH ILIST))
    (NUM-TRAIN (CL:/ (CL:* 1 NUM) 2.0d0)) (CURRENT-SPLIT NUM-TRAIN)
    (TRAINING-INSTANCES NULL) (INSTANCES (NEW-VECTOR NUM))
    (RESULT 0.0d0) (RESULTS (NEW-VECTOR CURVE-SPLITS)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM)
    (CL:TYPE CL:DOUBLE-FLOAT NUM-TRAIN CURRENT-SPLIT RESULT))
   (CL:LET*
    ((INSTANCE NULL) (ITER-000 (%LIST.THE-CONS-LIST ILIST))
     (I NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ INSTANCE (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY INSTANCES)) (VALUE INSTANCE)
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-002 0)
     (UPPER-BOUND-000 (CL:1- CURVE-SPLITS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-002)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY RESULTS)) (VALUE (WRAP-FLOAT 0.0d0))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))))
   (CL:LET*
    ((SPLIT NULL-INTEGER) (ITER-003 0)
     (UPPER-BOUND-001 (CL:1- CURVE-SPLITS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM SPLIT ITER-003 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-003 UPPER-BOUND-001) DO
     (CL:SETQ SPLIT ITER-003)
     (CL:SETQ CURRENT-SPLIT
      (CL:* NUM-TRAIN
       (CL:/ (CL:FLOAT (CL:1+ SPLIT) 0.0d0) CURVE-SPLITS)))
     (CL:LET*
      ((I NULL-INTEGER) (ITER-004 0)
       (UPPER-BOUND-002 (CL:1- NUM-TRIALS)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-004 UPPER-BOUND-002))
      (CL:LOOP WHILE (CL:<= ITER-004 UPPER-BOUND-002) DO
       (CL:SETQ I ITER-004) (SHUFFLE-VECTOR INSTANCES)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "Starting Trial " (CL:1+ I) " of split " (CL:1+ SPLIT) " with "
        CURRENT-SPLIT " examples" EOL)
       (CLEAR-TRAINING-EXAMPLES) (CLEAR-CASES)
       (CL:SETQ TRAINING-INSTANCES
        (NEW-VECTOR (CL:TRUNCATE CURRENT-SPLIT)))
       (CL:LET*
        ((J NULL-INTEGER) (ITER-005 0)
         (UPPER-BOUND-003 (CL:TRUNCATE (CL:1- CURRENT-SPLIT))))
        (CL:DECLARE (CL:TYPE CL:FIXNUM J ITER-005 UPPER-BOUND-003))
        (CL:LOOP WHILE (CL:<= ITER-005 UPPER-BOUND-003) DO
         (CL:SETQ J ITER-005)
         (CL:LET
          ((SELF (%VECTOR.THE-ARRAY TRAINING-INSTANCES))
           (VALUE
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES))
             J))
           (POSITION J))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:SETQ ITER-005 (CL:1+ ITER-005))))
       (CL:COND
        ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-TOP-DOWN)
         (CL:SETQ *ENABLE-USER-THING* CL:T)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "  Creating Match Criteria" EOL)
         (GENERATE-CLASSIFICATION-RULE TRAINING-INSTANCES RELATION-NAME
          CLASS-NAME CL:T)
         (SET-CANDIDATE-CLAUSES CLASS-NAME)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "  Generating Training Examples" EOL)
         (GENERATE-CLASSIFICATION-TRAINING-EXAMPLES INSTANCES RELATION
          CL:T)
         (CL:SETQ *OPTIMIZE-INDUCED-QUERIES* CL:T))
        ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-BOTTOM-UP)
         (CL:SETQ *ENABLE-USER-THING* CL:NIL)
         (GENERATE-TRAINING-EXAMPLES INSTANCES RELATION)
         (CL:SETQ *OPTIMIZE-INDUCED-QUERIES* CL:T))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
           *RULE-INDUCTION-STRATEGY* "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
       (CL:SETQ *TRAINING-EXAMPLES* (REVERSE *TRAINING-EXAMPLES*))
       (CL:LET* ((TRAIN-SET (NEW-LIST)) (TEST-SET (NEW-LIST)))
        (CL:LET*
         ((EXAMPLE NULL)
          (ITER-006 (%LIST.THE-CONS-LIST *TRAINING-EXAMPLES*))
          (J NULL-INTEGER) (ITER-007 0))
         (CL:DECLARE (CL:TYPE CL:FIXNUM J ITER-007))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
          (CL:SETQ EXAMPLE (%%VALUE ITER-006)) (CL:SETQ J ITER-007)
          (CL:WHEN (CL:< J CURRENT-SPLIT) (PUSH TRAIN-SET EXAMPLE))
          (CL:WHEN (CL:>= J NUM-TRAIN) (PUSH TEST-SET EXAMPLE))
          (CL:SETQ ITER-006 (%%REST ITER-006))
          (CL:SETQ ITER-007 (CL:1+ ITER-007))))
        (CL:SETQ RESULT
         (TRAIN-AND-TEST-RULE-INDUCTION TRAIN-SET TEST-SET))
        (CL:LET
         ((SELF (%VECTOR.THE-ARRAY RESULTS))
          (VALUE
           (WRAP-FLOAT
            (CL:+
             (%FLOAT-WRAPPER.WRAPPER-VALUE
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY RESULTS))
               SPLIT))
             RESULT)))
          (POSITION SPLIT))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         EOL "  Result: " RESULT EOL))
       (CL:SETQ ITER-004 (CL:1+ ITER-004))))
     (CL:SETQ ITER-003 (CL:1+ ITER-003))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-008 0)
     (UPPER-BOUND-004 (CL:1- CURVE-SPLITS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-008 UPPER-BOUND-004))
    (CL:LOOP WHILE (CL:<= ITER-008 UPPER-BOUND-004) DO
     (CL:SETQ I ITER-008)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY RESULTS))
       (VALUE
        (WRAP-FLOAT
         (CL:/
          (%FLOAT-WRAPPER.WRAPPER-VALUE
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY RESULTS)) I))
          NUM-TRIALS)))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-008 (CL:1+ ITER-008))))
   RESULTS))

(CL:DEFUN EVALUATE-RULE-INDUCTION-EVALUATOR-WRAPPER (ARGUMENTS)
  (%EVALUATE-RULE-INDUCTION (%%VALUE ARGUMENTS)
   (%%VALUE (%%REST ARGUMENTS))
   (%INTEGER-WRAPPER.WRAPPER-VALUE
    (%%VALUE (%%REST (%%REST ARGUMENTS))))
   (%INTEGER-WRAPPER.WRAPPER-VALUE
    (%%VALUE (%%REST (%%REST (%%REST ARGUMENTS)))))))

(CL:DEFMACRO EVALUATE-RULE-INDUCTION (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/EVALUATE-RULE-INDUCTION|)) (CL:MACRO-FUNCTION (CL:QUOTE EVALUATE-RULE-INDUCTION)))

;;; (DEFUN (TRAIN-AND-TEST-RULE-INDUCTION FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:DOUBLE-FLOAT)
  TRAIN-AND-TEST-RULE-INDUCTION))
(CL:DEFUN TRAIN-AND-TEST-RULE-INDUCTION (TRAIN-SET TEST-SET)
  (CL:LET*
   ((HOME-MODULE *CONTEXT*)
    (TEST-MODULE
     (FIND-OR-CREATE-MODULE
      (CONCATENATE (%MODULE.MODULE-FULL-NAME *CONTEXT*)
       "INDUCED-RULES")))
    (RESULT 0.0d0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CHANGE-MODULE TEST-MODULE) (CLEAR-CONTEXT TEST-MODULE)
   (CL:COND
    ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-TOP-DOWN)
     (%TOP-DOWN-RULE-INDUCTION TRAIN-SET))
    ((CL:EQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-BOTTOM-UP)
     (%BOTTOM-UP-RULE-INDUCTION TRAIN-SET *SIMPLIFY-RULE-ANTECEDENT?*))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" *RULE-INDUCTION-STRATEGY* "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (ASSERT-INDUCED-RULES)
   (CL:SETQ RESULT (TEST-THEORY-OVER-EXAMPLES TEST-SET))
   (CHANGE-MODULE HOME-MODULE) RESULT))

;;; (DEFUN INDUCE-DECISION-RULES ...)

(CL:DEFUN %INDUCE-DECISION-RULES (RELATION-NAME CLASS-NAME)
  (CL:SETQ RELATION-NAME (PERMANENTIFY RELATION-NAME))
  (CLEAR-CASES)
  (CLEAR-TRAINING-EXAMPLES)
  (CL:SETQ *INDUCED-DECISION-RULES* (NEW-LIST))
  (CL:SETQ CLASS-NAME (PERMANENTIFY CLASS-NAME))
  (CL:LET*
   ((CLASS
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION CLASS-NAME)))
    (RELATION
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION RELATION-NAME)))
    (ILIST (LISTIFY (ALL-CLASS-INSTANCES CLASS))) (NUM (LENGTH ILIST))
    (TREE NULL) (INSTANCES (NEW-VECTOR NUM)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM))
   (CL:LET*
    ((INSTANCE NULL) (ITER-000 (%LIST.THE-CONS-LIST ILIST))
     (I NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ INSTANCE (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY INSTANCES)) (VALUE INSTANCE)
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:WHEN (CL:NOT *ALLOW-RECURSIVE-DECISION-NODES*)
    (INSERT-NEW *TABOO-OPERATORS* RELATION))
   (GENERATE-CLASSIFICATION-RULE INSTANCES RELATION-NAME CLASS-NAME
    CL:T)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Generating Training Examples" EOL)
   (GENERATE-CLASSIFICATION-TRAINING-EXAMPLES INSTANCES RELATION CL:T)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Generating Decision Rules" EOL)
   (CL:SETQ TREE (%INDUCE-DECISION-TREE *TRAINING-EXAMPLES*))
   (CL:SETF (%DECISION-TREE.CONCEPT TREE) RELATION-NAME)
   (GET-RULES-FROM-TREE
    (%TRAINING-EXAMPLE.QUERY (FIRST *TRAINING-EXAMPLES*)) TREE)))

(CL:DEFMACRO INDUCE-DECISION-RULES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/INDUCE-DECISION-RULES|)) (CL:MACRO-FUNCTION (CL:QUOTE INDUCE-DECISION-RULES)))

;;; (DEFUN MODULAR-INDUCE-DECISION-RULES ...)

(CL:DEFUN MODULAR-INDUCE-DECISION-RULES (RELATION-NAME CLASS-NAME MODULES)
  (CL:SETQ RELATION-NAME (PERMANENTIFY RELATION-NAME))
  (CL:SETQ CLASS-NAME (PERMANENTIFY CLASS-NAME))
  (CLEAR-TRAINING-EXAMPLES)
  (CLEAR-CASES)
  (CL:LET*
   ((CLASS
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION CLASS-NAME)))
    (RELATION
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION RELATION-NAME)))
    (ILIST (NEW-LIST)) (TREE NULL) (HOME *MODULE*) (NUM (LENGTH ILIST))
    (INSTANCE-VEC (NEW-VECTOR (LENGTH MODULES))) (INSTANCES NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM))
   (CL:WHEN (CL:NOT *ALLOW-RECURSIVE-DECISION-NODES*)
    (INSERT-NEW *TABOO-OPERATORS* RELATION))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Building Classification Rule" EOL)
   (CL:LET*
    ((MODULE NULL) (ITER-000 (%LIST.THE-CONS-LIST MODULES))
     (J NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM J ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ MODULE (%%VALUE ITER-000)) (CL:SETQ J ITER-001)
     (CHANGE-MODULE MODULE)
     (CL:SETQ ILIST (LISTIFY (ALL-CLASS-INSTANCES CLASS)))
     (CL:SETQ NUM (LENGTH ILIST)) (CL:SETQ INSTANCES (NEW-VECTOR NUM))
     (CL:LET*
      ((INSTANCE NULL) (ITER-002 (%LIST.THE-CONS-LIST ILIST))
       (I NULL-INTEGER) (ITER-003 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ INSTANCE (%%VALUE ITER-002)) (CL:SETQ I ITER-003)
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY INSTANCES)) (VALUE INSTANCE)
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-002 (%%REST ITER-002))
       (CL:SETQ ITER-003 (CL:1+ ITER-003))))
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY INSTANCE-VEC)) (VALUE INSTANCES)
       (POSITION J))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (GENERATE-CLASSIFICATION-RULE INSTANCES RELATION-NAME CLASS-NAME
      CL:NIL)
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CHANGE-MODULE HOME)
   (BUILD-CLASSIFICATION-RULE RELATION-NAME CLASS-NAME)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Generating Training Examples" EOL)
   (CL:LET*
    ((MODULE NULL) (ITER-004 (%LIST.THE-CONS-LIST MODULES)) (VEC NULL)
     (VECTOR-000 INSTANCE-VEC) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-004 NIL)) (CL:< INDEX-000 LENGTH-000))
     DO (CL:SETQ MODULE (%%VALUE ITER-004))
     (CL:SETQ VEC
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CHANGE-MODULE MODULE)
     (GENERATE-CLASSIFICATION-TRAINING-EXAMPLES VEC RELATION CL:T)
     (CL:SETQ ITER-004 (%%REST ITER-004))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Inducing Decision Tree" EOL)
   (CL:SETQ TREE (%INDUCE-DECISION-TREE *TRAINING-EXAMPLES*))
   (CL:SETF (%DECISION-TREE.CONCEPT TREE) RELATION-NAME)
   (CL:WHEN
    (CL:NOT
     (CL:EQ (%TRAINING-EXAMPLE.MODULE (FIRST *TRAINING-EXAMPLES*))
      NULL))
    (CHANGE-MODULE
     (%TRAINING-EXAMPLE.MODULE (FIRST *TRAINING-EXAMPLES*))))))

;;; (DEFUN (ASK-DECISION-TREE BOOLEAN) ...)

(CL:DEFUN ASK-DECISION-TREE (TREE QUERY)
  (CL:LET* ((SIGNATURE (CREATE-INPUT-SIGNATURE QUERY)))
   (TRAVERSE-DECISION-TREE TREE SIGNATURE)))

;;; (DEFUN (TRAVERSE-DECISION-TREE BOOLEAN) ...)

(CL:DEFUN TRAVERSE-DECISION-TREE (TREE FEATURES)
  (CL:WHEN (CL:EQ (%DECISION-TREE.FEATURE TREE) NULL)
   (CL:RETURN-FROM TRAVERSE-DECISION-TREE
    (%DECISION-TREE.TRUTH-VALUE TREE)))
  (CL:IF
   (EQL?
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY FEATURES))
     (CL:THE CL:FIXNUM (%DECISION-TREE.FEATURE-INDEX TREE)))
    ONE-WRAPPER)
   (TRAVERSE-DECISION-TREE (%DECISION-TREE.TRUE-BRANCH TREE) FEATURES)
   (TRAVERSE-DECISION-TREE (%DECISION-TREE.FALSE-BRANCH TREE) FEATURES)))

;;; (DEFUN (INDUCE-DECISION-TREE DECISION-TREE) ...)

(CL:DEFUN %INDUCE-DECISION-TREE (EXAMPLES)
  (CL:LET*
   ((FEATURES (NEW-LIST)) (FEATURE NULL) (TREE NULL) (PROPS (NEW-LIST))
    (PROPOSITION-TABLE (NEW-HASH-TABLE)))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "  Inducing decision tree" EOL)
   (CL:WHEN
    (CL:NOT (CL:EQ (%TRAINING-EXAMPLE.MODULE (FIRST EXAMPLES)) NULL))
    (CHANGE-MODULE (%TRAINING-EXAMPLE.MODULE (FIRST EXAMPLES))))
   (CL:SETQ PROPS
    (GET-CLASSIFICATION-RELATIONS
     (%TRAINING-EXAMPLE.QUERY (FIRST EXAMPLES))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH PROPS))) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:SETQ FEATURE
      (INTERN-SYMBOL (CONCATENATE "A" (STRINGIFY (WRAP-INTEGER I)))))
     (INSERT-AT PROPOSITION-TABLE FEATURE (NTH PROPS I))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS FEATURE NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST FEATURES) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST FEATURES) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST FEATURES)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS FEATURE NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETQ TREE (BUILD-DECISION-TREE EXAMPLES FEATURES NIL))
   (ADD-PROPOSITIONS-TO-DECISION-TREE TREE PROPOSITION-TABLE) TREE))

(CL:DEFMACRO INDUCE-DECISION-TREE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/INDUCE-DECISION-TREE|)) (CL:MACRO-FUNCTION (CL:QUOTE INDUCE-DECISION-TREE)))

;;; (DEFUN ADD-PROPOSITIONS-TO-DECISION-TREE ...)

(CL:DEFUN ADD-PROPOSITIONS-TO-DECISION-TREE (TREE TABLE)
  (CL:WHEN (CL:EQ (%DECISION-TREE.FEATURE TREE) NULL)
   (CL:RETURN-FROM ADD-PROPOSITIONS-TO-DECISION-TREE))
  (CL:SETF (%DECISION-TREE.PROPOSITION TREE)
   (LOOKUP TABLE (%DECISION-TREE.FEATURE TREE)))
  (ADD-PROPOSITIONS-TO-DECISION-TREE (%DECISION-TREE.TRUE-BRANCH TREE)
   TABLE)
  (ADD-PROPOSITIONS-TO-DECISION-TREE (%DECISION-TREE.FALSE-BRANCH TREE)
   TABLE))

;;; (DEFUN (BUILD-DECISION-TREE OBJECT) ...)

(CL:DEFUN BUILD-DECISION-TREE (EXAMPLES FEATURES FEATURE-STACK)
  (CL:LET*
   ((P 0) (N 0) (CURRENT-ENTROPY 0.0d0) (NEW-ENTROPY 0.0d0)
    (TREE (NEW-DECISION-TREE)) (MIN-NEW-ENTROPY 1.0d0)
    (FEATURE-INDEX 0) (SPLIT-FEATURE NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM P N FEATURE-INDEX)
    (CL:TYPE CL:DOUBLE-FLOAT CURRENT-ENTROPY NEW-ENTROPY
     MIN-NEW-ENTROPY))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:IF
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (%TRAINING-EXAMPLE.OUTPUT EXAMPLE))
      (CL:SETQ P (CL:1+ P)) (CL:SETQ N (CL:1+ N)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:IF (CL:> P N) (CL:SETF (%DECISION-TREE.TRUTH-VALUE TREE) CL:T)
    (CL:SETF (%DECISION-TREE.TRUTH-VALUE TREE) CL:NIL))
   (CL:WHEN (CL:OR (CL:= P 0) (CL:= N 0))
    (CL:RETURN-FROM BUILD-DECISION-TREE TREE))
   (CL:SETQ CURRENT-ENTROPY (ENTROPY P N))
   (CL:LET*
    ((FEATURE NULL) (ITER-001 (%LIST.THE-CONS-LIST FEATURES))
     (I NULL-INTEGER) (ITER-002 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ FEATURE (%%VALUE ITER-001)) (CL:SETQ I ITER-002)
     (CL:WHEN (CL:NOT (MEMBER? FEATURE-STACK FEATURE))
      (CL:SETQ NEW-ENTROPY (EXPECTED-ENTROPY I EXAMPLES))
      (CL:WHEN (CL:< NEW-ENTROPY MIN-NEW-ENTROPY)
       (CL:WHEN *TRACE-ID3*
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "Info gain for feature " FEATURE ": "
         (CL:- CURRENT-ENTROPY NEW-ENTROPY) EOL))
       (CL:SETQ MIN-NEW-ENTROPY NEW-ENTROPY) (CL:SETQ FEATURE-INDEX I)
       (CL:SETQ SPLIT-FEATURE FEATURE)))
     (CL:SETQ ITER-001 (%%REST ITER-001))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))))
   (CL:WHEN *TRACE-ID3*
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "Splitting on feature " SPLIT-FEATURE EOL))
   (CL:WHEN (CL:EQ SPLIT-FEATURE NULL)
    (CL:RETURN-FROM BUILD-DECISION-TREE TREE))
   (CL:LET* ((LEFT-EXAMPLES (NEW-LIST)) (RIGHT-EXAMPLES (NEW-LIST)))
    (CL:LET* ((EXAMPLE NULL) (ITER-003 (%LIST.THE-CONS-LIST EXAMPLES)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
      (CL:SETQ EXAMPLE (%%VALUE ITER-003))
      (CL:IF
       (EQL?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%TRAINING-EXAMPLE.INPUT EXAMPLE)))
         FEATURE-INDEX)
        ONE-WRAPPER)
       (PUSH LEFT-EXAMPLES EXAMPLE) (PUSH RIGHT-EXAMPLES EXAMPLE))
      (CL:SETQ ITER-003 (%%REST ITER-003))))
    (CL:SETF (%DECISION-TREE.FEATURE TREE) SPLIT-FEATURE)
    (CL:SETF (%DECISION-TREE.FEATURE-INDEX TREE) FEATURE-INDEX)
    (CL:SETF (%DECISION-TREE.TRUE-BRANCH TREE)
     (BUILD-DECISION-TREE LEFT-EXAMPLES FEATURES
      (CONS SPLIT-FEATURE FEATURE-STACK)))
    (CL:SETF (%DECISION-TREE.FALSE-BRANCH TREE)
     (BUILD-DECISION-TREE RIGHT-EXAMPLES FEATURES
      (CONS SPLIT-FEATURE FEATURE-STACK))))
   TREE))

;;; (DEFUN (EXPECTED-ENTROPY FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:FIXNUM CL:T) CL:DOUBLE-FLOAT)
  EXPECTED-ENTROPY))
(CL:DEFUN EXPECTED-ENTROPY (FEATURE-INDEX EXAMPLES)
  (CL:DECLARE (CL:TYPE CL:FIXNUM FEATURE-INDEX))
  #+MCL
  (CL:CHECK-TYPE FEATURE-INDEX CL:FIXNUM)
  (CL:LET* ((E 0.0d0) (NUM-EXAMPLES (LENGTH EXAMPLES)) (P 0) (N 0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT E)
    (CL:TYPE CL:FIXNUM NUM-EXAMPLES P N))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:WHEN
      (EQL?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%TRAINING-EXAMPLE.INPUT EXAMPLE)))
        FEATURE-INDEX)
       ONE-WRAPPER)
      (CL:IF
       (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
        (%TRAINING-EXAMPLE.OUTPUT EXAMPLE))
       (CL:SETQ P (CL:1+ P)) (CL:SETQ N (CL:1+ N))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ E
    (CL:* (CL:/ (CL:FLOAT (CL:+ P N) 0.0d0) NUM-EXAMPLES)
     (ENTROPY P N)))
   (CL:SETQ P 0) (CL:SETQ N 0)
   (CL:LET* ((EXAMPLE NULL) (ITER-001 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-001))
     (CL:WHEN
      (EQL?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%TRAINING-EXAMPLE.INPUT EXAMPLE)))
        FEATURE-INDEX)
       ZERO-WRAPPER)
      (CL:IF
       (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
        (%TRAINING-EXAMPLE.OUTPUT EXAMPLE))
       (CL:SETQ P (CL:1+ P)) (CL:SETQ N (CL:1+ N))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:SETQ E
    (CL:+ E
     (CL:* (CL:/ (CL:FLOAT (CL:+ P N) 0.0d0) NUM-EXAMPLES)
      (ENTROPY P N))))
   E))

;;; (DEFUN (ENTROPY FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:FIXNUM CL:FIXNUM) CL:DOUBLE-FLOAT) ENTROPY))
(CL:DEFUN ENTROPY (P N)
  (CL:DECLARE (CL:TYPE CL:FIXNUM P N))
  #+MCL
  (CL:CHECK-TYPE P CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:WHEN (CL:AND (CL:= P 0) (CL:= N 0))
   (CL:RETURN-FROM ENTROPY 0.0d0))
  (CL:LET*
   ((SUM (CL:+ P N)) (POS-IMPURITY 0.0d0)
    (POS-PERC (CL:/ (CL:FLOAT P 0.0d0) SUM)) (NEG-IMPURITY 0.0d0)
    (NEG-PERC (CL:/ (CL:FLOAT N 0.0d0) SUM)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SUM)
    (CL:TYPE CL:DOUBLE-FLOAT POS-IMPURITY POS-PERC NEG-IMPURITY
     NEG-PERC))
   (CL:IF (CL:= P 0) (CL:SETQ POS-IMPURITY 0.0d0)
    (CL:SETQ POS-IMPURITY
     (CL:- 0
      (CL:* POS-PERC
       (CL:/ (CL:THE CL:DOUBLE-FLOAT (CL:LOG POS-PERC))
        (CL:THE CL:DOUBLE-FLOAT (CL:LOG 2.0d0)))))))
   (CL:IF (CL:= N 0) (CL:SETQ NEG-IMPURITY 0.0d0)
    (CL:SETQ NEG-IMPURITY
     (CL:- 0
      (CL:* NEG-PERC
       (CL:/ (CL:THE CL:DOUBLE-FLOAT (CL:LOG NEG-PERC))
        (CL:THE CL:DOUBLE-FLOAT (CL:LOG 2.0d0)))))))
   (CL:+ POS-IMPURITY NEG-IMPURITY)))

;;; (DEFUN PRINT-DECISION-TREE ...)

(CL:DEFUN PRINT-DECISION-TREE (TREE STREAM)
  (HELP-PRINT-DECISION-TREE TREE 0 STREAM))

;;; (DEFUN HELP-PRINT-DECISION-TREE ...)

(CL:DEFUN HELP-PRINT-DECISION-TREE (TREE LEVEL STREAM)
  (CL:DECLARE (CL:TYPE CL:FIXNUM LEVEL))
  #+MCL
  (CL:CHECK-TYPE LEVEL CL:FIXNUM)
  (CL:WHEN (CL:EQ (%DECISION-TREE.FEATURE TREE) NULL)
   (CL:IF (%DECISION-TREE.TRUTH-VALUE TREE)
    (%%PRINT-STREAM STREAM "True" EOL)
    (%%PRINT-STREAM STREAM "False" EOL))
   (CL:RETURN-FROM HELP-PRINT-DECISION-TREE))
  (%%PRINT-STREAM STREAM EOL)
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 LEVEL)
    (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
   (CL:LOOP WHILE
    (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
    (CL:SETQ I ITER-000) (CL:SETQ I I) (%%PRINT-STREAM STREAM "|   ")
    (CL:SETQ ITER-000 (CL:1+ ITER-000))))
  (%%PRINT-STREAM STREAM (%DECISION-TREE.PROPOSITION TREE) " = 1: ")
  (HELP-PRINT-DECISION-TREE (%DECISION-TREE.TRUE-BRANCH TREE)
   (CL:1+ LEVEL) STREAM)
  (CL:LET*
   ((I NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-001 LEVEL)
    (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
   (CL:LOOP WHILE
    (CL:OR UNBOUNDED?-001 (CL:<= ITER-001 UPPER-BOUND-001)) DO
    (CL:SETQ I ITER-001) (CL:SETQ I I) (%%PRINT-STREAM STREAM "|   ")
    (CL:SETQ ITER-001 (CL:1+ ITER-001))))
  (%%PRINT-STREAM STREAM (%DECISION-TREE.PROPOSITION TREE) " = 0: ")
  (HELP-PRINT-DECISION-TREE (%DECISION-TREE.FALSE-BRANCH TREE)
   (CL:1+ LEVEL) STREAM))

;;; (DEFUN (GET-RULES-FROM-TREE (LIST OF CONS)) ...)

(CL:DEFUN GET-RULES-FROM-TREE (QUERY TREE)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "  Extracting rules from decision tree" EOL)
  (BUILD-RULES-FROM-TREE TREE (GET-CLASSIFICATION-RELATIONS QUERY)))

;;; (DEFUN (BUILD-RULES-FROM-TREE (LIST OF CONS)) ...)

(CL:DEFUN BUILD-RULES-FROM-TREE (TREE PROPS)
  (CL:LET* ((RULES (NEW-LIST)) (CONS-PROPS NIL))
   (CL:LET*
    ((PROP NULL) (ITER-000 (%LIST.THE-CONS-LIST PROPS))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PROP (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000 (CONS (PROPOSITION-TO-CONS PROP) NIL))
       (CL:IF (CL:EQ CONS-PROPS NIL) (CL:SETQ CONS-PROPS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST CONS-PROPS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (PROPOSITION-TO-CONS PROP) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ *INDUCED-DECISION-RULES* (NEW-LIST))
   (EXTRACT-PATHS-FROM-TREE TREE NIL RULES) RULES))

;;; (DEFUN EXTRACT-PATHS-FROM-TREE ...)

(CL:DEFUN EXTRACT-PATHS-FROM-TREE (TREE ANTECEDENT-STACK ANTECEDENT)
  (CL:WHEN (CL:EQ (%DECISION-TREE.FEATURE TREE) NULL)
   (PUSH ANTECEDENT
    (CONS
     (CL:IF (%DECISION-TREE.TRUTH-VALUE TREE) TRUE-WRAPPER
      FALSE-WRAPPER)
     ANTECEDENT-STACK))
   (CL:RETURN-FROM EXTRACT-PATHS-FROM-TREE))
  (CL:LET*
   ((PROP (PROPOSITION-TO-CONS (%DECISION-TREE.PROPOSITION TREE))))
   (EXTRACT-PATHS-FROM-TREE (%DECISION-TREE.TRUE-BRANCH TREE)
    (CONS PROP ANTECEDENT-STACK) ANTECEDENT)
   (EXTRACT-PATHS-FROM-TREE (%DECISION-TREE.FALSE-BRANCH TREE)
    (CONS (LIST* SYM-RULE-INDUCTION-LOGIC-FAIL PROP NIL)
     ANTECEDENT-STACK)
    ANTECEDENT)))

;;; (DEFUN SORT-EXAMPLES-BY-TREE ...)

(CL:DEFUN SORT-EXAMPLES-BY-TREE (TREE EXAMPLES SORTED-EXAMPLES)
  (CL:WHEN (CL:EQ (%DECISION-TREE.FEATURE TREE) NULL)
   (PUSH SORTED-EXAMPLES EXAMPLES)
   (CL:RETURN-FROM SORT-EXAMPLES-BY-TREE))
  (CL:LET* ((TRUE-EXAMPLES (NEW-LIST)) (FALSE-EXAMPLES (NEW-LIST)))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%LIST.THE-CONS-LIST EXAMPLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:IF
      (EQL?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%TRAINING-EXAMPLE.INPUT EXAMPLE)))
        (CL:THE CL:FIXNUM (%DECISION-TREE.FEATURE-INDEX TREE)))
       ONE-WRAPPER)
      (PUSH TRUE-EXAMPLES EXAMPLE) (PUSH FALSE-EXAMPLES EXAMPLE))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (SORT-EXAMPLES-BY-TREE (%DECISION-TREE.TRUE-BRANCH TREE)
    TRUE-EXAMPLES SORTED-EXAMPLES)
   (SORT-EXAMPLES-BY-TREE (%DECISION-TREE.FALSE-BRANCH TREE)
    FALSE-EXAMPLES SORTED-EXAMPLES)))

;;; (DEFUN ASSERT-INDUCED-RULES ...)

(CL:DEFUN ASSERT-INDUCED-RULES ()
  (CL:LET* ((COMMAND NIL) (NAME NULL) (VARS NULL) (TYPES NIL))
   (CL:LET*
    ((RULE NULL)
     (ITER-000 (%LIST.THE-CONS-LIST *INDUCED-DECISION-RULES*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ RULE (%%VALUE ITER-000))
     (CL:SETQ NAME
      (INTERN-SYMBOL
       (CONCATENATE "Induced-Rule-"
        (STRINGIFY (WRAP-INTEGER *INDUCED-RULE-COUNTER*)))))
     (CL:SETQ VARS (GET-VARIABLES-FROM-CONS-PROPOSITIONS RULE))
     (CL:SETQ TYPES NIL)
     (CL:IF *ENABLE-USER-THING*
      (CL:LET*
       ((VAR NULL) (ITER-001 (%LIST.THE-CONS-LIST VARS))
        (COLLECT-000 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ VAR (%%VALUE ITER-001))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-000
           (CONS
            (CONS VAR (CONS SYM-RULE-INDUCTION-LOGIC-USER-THING NIL))
            NIL))
          (CL:IF (CL:EQ TYPES NIL) (CL:SETQ TYPES COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST TYPES COLLECT-000)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-000)
           (CONS
            (CONS VAR (CONS SYM-RULE-INDUCTION-LOGIC-USER-THING NIL))
            NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      (CL:LET*
       ((VAR NULL) (ITER-002 (%LIST.THE-CONS-LIST VARS))
        (COLLECT-001 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:SETQ VAR (%%VALUE ITER-002))
        (CL:IF (CL:EQ COLLECT-001 NULL)
         (CL:PROGN (CL:SETQ COLLECT-001 (CONS VAR NIL))
          (CL:IF (CL:EQ TYPES NIL) (CL:SETQ TYPES COLLECT-001)
           (ADD-CONS-TO-END-OF-CONS-LIST TYPES COLLECT-001)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS VAR NIL))
          (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
        (CL:SETQ ITER-002 (%%REST ITER-002)))))
     (CL:SETQ *INDUCED-RULE-COUNTER* (CL:1+ *INDUCED-RULE-COUNTER*))
     (CL:SETQ COMMAND
      (LIST* SYM-RULE-INDUCTION-LOGIC-DEFRULE NAME
       (CONS
        (LIST* SYM-RULE-INDUCTION-STELLA-FORALL TYPES
         (CONS (COPY-CONS-TREE RULE) NIL))
        NIL)))
     (CL:IF *LOG-INDUCED-RULES*
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       COMMAND EOL EOL)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Asserting " NAME EOL))
     (EVALUATE-LOGIC-COMMAND COMMAND CL:NIL)
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

;;; (DEFUN SET-CANDIDATE-CLAUSES ...)

(CL:DEFUN SET-CANDIDATE-CLAUSES (CLASS-NAME)
  (CL:LET*
   ((CLAUSES
     (LOOKUP *CASE-ANTECEDENT-TABLE*
      (CONCATENATE (%SYMBOL.SYMBOL-NAME CLASS-NAME) "-match"))))
   (CL:SETQ *CANDIDATE-CLAUSES* (NEW-VECTOR (LENGTH CLAUSES)))
   (CL:LET*
    ((CLAUSE NULL) (ITER-000 (%LIST.THE-CONS-LIST CLAUSES))
     (K NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM K ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CLAUSE (%%VALUE ITER-000)) (CL:SETQ K ITER-001)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY *CANDIDATE-CLAUSES*)) (VALUE CLAUSE)
       (POSITION K))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))))

;;; (DEFUN (GET-VARIABLES-FROM-PROPOSITION-LIST (LIST OF SYMBOL)) ...)

(CL:DEFUN GET-VARIABLES-FROM-PROPOSITION-LIST (PROPS)
  (CL:LET* ((THE-LIST (NEW-LIST)) (VARIABLE NULL))
   (CL:LET* ((PROP NULL) (ITER-000 (%LIST.THE-CONS-LIST PROPS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PROP (%%VALUE ITER-000))
     (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROP)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-000 KWD-RULE-INDUCTION-OR)
         (CL:EQ TEST-VALUE-000 KWD-RULE-INDUCTION-NOT)
         (CL:EQ TEST-VALUE-000 KWD-RULE-INDUCTION-AND))
        (CL:LET*
         ((VAR NULL)
          (ITER-001
           (%LIST.THE-CONS-LIST
            (GET-VARIABLES-FROM-PROPOSITION-LIST
             (LISTIFY (%PROPOSITION.ARGUMENTS PROP))))))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ VAR (%%VALUE ITER-001)) (INSERT-NEW THE-LIST VAR)
          (CL:SETQ ITER-001 (%%REST ITER-001)))))
       (CL:T
        (CL:LET*
         ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROP))
          (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:SETQ ARG
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE ARG)))
           (CL:COND
            ((SUBTYPE-OF? TEST-VALUE-001
              SGT-RULE-INDUCTION-LOGIC-PATTERN-VARIABLE)
             (CL:PROGN
              (CL:SETQ VARIABLE (%PATTERN-VARIABLE.SKOLEM-NAME ARG))))
            ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
             (CL:PROGN (CL:SETQ VARIABLE ARG)))
            ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
             (CL:PROGN
              (CL:SETQ VARIABLE
               (INTERN-SYMBOL (%SURROGATE.SYMBOL-NAME ARG)))))
            ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
             (CL:PROGN (CL:SETQ VARIABLE NULL)))
            ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
             (CL:PROGN (CL:SETQ VARIABLE NULL)))
            ((SUBTYPE-OF-STRING? TEST-VALUE-001)
             (CL:PROGN (CL:SETQ VARIABLE NULL)))
            ((SUBTYPE-OF? TEST-VALUE-001
              SGT-RULE-INDUCTION-LOGIC-PROPOSITION)
             (CL:PROGN
              (%%PRINT-STREAM
               (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
               "Dave, you've got a proposition" EOL)))
            ((SUBTYPE-OF? TEST-VALUE-001
              SGT-RULE-INDUCTION-LOGIC-LOGIC-OBJECT)
             (CL:PROGN (CL:SETQ VARIABLE (OBJECT-NAME ARG))))
            (CL:T
             (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
              (%%PRINT-STREAM
               (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
               TEST-VALUE-001 "' is not a valid case option")
              (CL:ERROR
               (NEW-STELLA-EXCEPTION
                (THE-STRING-READER STREAM-000)))))))
          (CL:WHEN (CL:NOT (CL:EQ VARIABLE NULL))
           (INSERT-NEW THE-LIST VARIABLE))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   THE-LIST))

;;; (DEFUN (GET-VARIABLES-FROM-CONS-PROPOSITIONS (LIST OF SYMBOL)) ...)

(CL:DEFUN GET-VARIABLES-FROM-CONS-PROPOSITIONS (PROPS)
  (HELP-GET-VARIABLES-FROM-CONS-PROPOSITIONS PROPS (NEW-LIST)))

;;; (DEFUN (HELP-GET-VARIABLES-FROM-CONS-PROPOSITIONS (LIST OF SYMBOL)) ...)

(CL:DEFUN HELP-GET-VARIABLES-FROM-CONS-PROPOSITIONS (ELE THE-LIST)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ELE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-RULE-INDUCTION-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((ARG NULL) (ITER-000 ELE))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ ARG (%%VALUE ITER-000))
        (HELP-GET-VARIABLES-FROM-CONS-PROPOSITIONS ARG THE-LIST)
        (CL:SETQ ITER-000 (%%REST ITER-000))))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN
       (CL:EQL
        (CL:LET ((SELF (%SYMBOL.SYMBOL-NAME ELE)) (POSITION 0))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION)))
        #\?)
       (INSERT-NEW THE-LIST ELE))))
    (CL:T)))
  THE-LIST)

;;; (DEFUN (GET-PROPOSITIONS-FROM-DECISION-TREE (LIST OF PROPOSITION)) ...)

(CL:DEFUN GET-PROPOSITIONS-FROM-DECISION-TREE (TREE)
  (CL:WHEN (CL:EQ (%DECISION-TREE.FEATURE TREE) NULL)
   (CL:RETURN-FROM GET-PROPOSITIONS-FROM-DECISION-TREE (NEW-LIST)))
  (CL:LET*
   ((THE-LIST
     (CONCATENATE
      (GET-PROPOSITIONS-FROM-DECISION-TREE
       (%DECISION-TREE.TRUE-BRANCH TREE))
      (GET-PROPOSITIONS-FROM-DECISION-TREE
       (%DECISION-TREE.FALSE-BRANCH TREE)))))
   (PUSH THE-LIST (%DECISION-TREE.PROPOSITION TREE)) THE-LIST))

(CL:DEFUN HELP-STARTUP-RULE-INDUCTION1 ()
  (CL:PROGN
   (CL:SETQ KWD-RULE-INDUCTION-TOP-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOP-DOWN" NULL 2))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-SET-SIGNATURE-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-SIGNATURE-STRATEGY" NULL 0))
   (CL:SETQ KWD-RULE-INDUCTION-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-RULE-INDUCTION-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-SET-SIGNATURE-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-SIGNATURE-RULES" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-SET-RULE-INDUCTION-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-RULE-INDUCTION-STRATEGY" NULL
     0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-SET-RECURSIVE-DECISION-NODES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-RECURSIVE-DECISION-NODES" NULL
     0))
   (CL:SETQ SGT-RULE-INDUCTION-LOGIC-DECISION-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DECISION-TREE" NULL 1))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-FEATURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FEATURE" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-FEATURE-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FEATURE-INDEX" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-CONCEPT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEPT" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-TRUE-BRANCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE-BRANCH" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-FALSE-BRANCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE-BRANCH" NULL 0))
   (CL:SETQ KWD-RULE-INDUCTION-BOTTOM-UP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOTTOM-UP" NULL 2))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-INDUCE-INFERENCE-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INDUCE-INFERENCE-RULES" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-?Y
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?Y" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-=>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=>"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-BOTTOM-UP-RULE-INDUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOTTOM-UP-RULE-INDUCTION" NULL 0))
   (CL:SETQ SGT-RULE-INDUCTION-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA->
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-<
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA->=
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">="
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-=<
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=<"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-RULE-INDUCTION-STELLA-NUMBER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 0))
   (CL:SETQ KWD-RULE-INDUCTION-DECISION-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DECISION-TREE" NULL 2))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-TOP-DOWN-RULE-INDUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOP-DOWN-RULE-INDUCTION" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-USER-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USER-THING" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-RULE-INDUCTION-TIMEOUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMEOUT" NULL 2))
   (CL:SETQ KWD-RULE-INDUCTION-DONT-OPTIMIZE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-OPTIMIZE?" NULL 2))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-EVALUATE-RULE-INDUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATE-RULE-INDUCTION" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-INDUCE-DECISION-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INDUCE-DECISION-RULES" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-INDUCE-DECISION-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INDUCE-DECISION-TREE" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-DEFRULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFRULE" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-RULE-INDUCTION-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-RULE-INDUCTION-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-RULE-INDUCTION-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ SGT-RULE-INDUCTION-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-RULE-INDUCTION-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SGT-RULE-INDUCTION-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SYM-RULE-INDUCTION-LOGIC-STARTUP-RULE-INDUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-RULE-INDUCTION" NULL 0))
   (CL:SETQ SYM-RULE-INDUCTION-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-RULE-INDUCTION2 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "SET-SIGNATURE-STRATEGY"
    "(DEFUN SET-SIGNATURE-STRATEGY ((K KEYWORD)) :COMMAND? TRUE)"
    (CL:FUNCTION %SET-SIGNATURE-STRATEGY) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-SIGNATURE-RULES"
    "(DEFUN SET-SIGNATURE-RULES ((B BOOLEAN)) :COMMAND? TRUE)"
    (CL:FUNCTION %SET-SIGNATURE-RULES)
    (CL:FUNCTION SET-SIGNATURE-RULES-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-RULE-INDUCTION-STRATEGY"
    "(DEFUN SET-RULE-INDUCTION-STRATEGY ((K KEYWORD)) :COMMAND? TRUE)"
    (CL:FUNCTION %SET-RULE-INDUCTION-STRATEGY) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-RECURSIVE-DECISION-NODES"
    "(DEFUN SET-RECURSIVE-DECISION-NODES ((B BOOLEAN)) :COMMAND? TRUE)"
    (CL:FUNCTION %SET-RECURSIVE-DECISION-NODES)
    (CL:FUNCTION SET-RECURSIVE-DECISION-NODES-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "INDUCE-INFERENCE-RULES"
    "(DEFUN INDUCE-INFERENCE-RULES ((RELATION-NAME SYMBOL) (CLASS-NAME SYMBOL)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %INDUCE-INFERENCE-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "MODULAR-INDUCE-INFERENCE-RULES"
    "(DEFUN MODULAR-INDUCE-INFERENCE-RULES ((RELATION-NAME SYMBOL) (CLASS-NAME SYMBOL) (MODULES (LIST OF MODULE))))"
    (CL:FUNCTION MODULAR-INDUCE-INFERENCE-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "BOTTOM-UP-RULE-INDUCTION"
    "(DEFUN BOTTOM-UP-RULE-INDUCTION ((EXAMPLES (LIST OF TRAINING-EXAMPLE)) (SIMPLIFY-RULE? BOOLEAN)) :COMMAND? TRUE)"
    (CL:FUNCTION %BOTTOM-UP-RULE-INDUCTION)
    (CL:FUNCTION BOTTOM-UP-RULE-INDUCTION-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "LEARN-ONE-RULE-BOTTOM-UP"
    "(DEFUN (LEARN-ONE-RULE-BOTTOM-UP (CONS OF CONS)) ((POSITIVE (LIST OF TRAINING-EXAMPLE)) (NEGATIVE (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION LEARN-ONE-RULE-BOTTOM-UP) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTAINS-OUTPUT-VARIABLE?"
    "(DEFUN (CONTAINS-OUTPUT-VARIABLE? BOOLEAN) ((CLAUSE CONS) (OUTPUT-VARIABLES (CONS OF SYMBOL))))"
    (CL:FUNCTION CONTAINS-OUTPUT-VARIABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "SIMPLIFY-ANTECEDENT"
    "(DEFUN (SIMPLIFY-ANTECEDENT (CONS OF CONS)) ((ANTECEDENT (CONS OF CONS)) (OUTPUT-VARIABLES (CONS OF SYMBOL)) (POSITIVE (LIST OF TRAINING-EXAMPLE)) (NEGATIVE (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION SIMPLIFY-ANTECEDENT) NULL)
   (DEFINE-FUNCTION-OBJECT "LEAST-GENERAL-GENERALIZATION"
    "(DEFUN (LEAST-GENERAL-GENERALIZATION CONS) ((CLAUSE1 (CONS OF CONS)) (CLAUSE2 (CONS OF CONS))))"
    (CL:FUNCTION LEAST-GENERAL-GENERALIZATION) NULL)
   (DEFINE-FUNCTION-OBJECT "GENERALIZE-INEQUALITY"
    "(DEFUN (GENERALIZE-INEQUALITY CONS) ((PROBE CONS) (MATCH CONS) (BINDINGS (LIST OF CONS))))"
    (CL:FUNCTION GENERALIZE-INEQUALITY) NULL)
   (DEFINE-FUNCTION-OBJECT "BOTH-NUMBERS?"
    "(DEFUN (BOTH-NUMBERS? BOOLEAN) ((T1 OBJECT) (T2 OBJECT)))"
    (CL:FUNCTION BOTH-NUMBERS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EITHER-NUMBERS?"
    "(DEFUN (EITHER-NUMBERS? BOOLEAN) ((T1 OBJECT) (T2 OBJECT)))"
    (CL:FUNCTION EITHER-NUMBERS?) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-REDUNDANT-CLAUSES"
    "(DEFUN (REMOVE-REDUNDANT-CLAUSES (CONS OF CONS)) ((CLAUSES (CONS OF CONS))))"
    (CL:FUNCTION REMOVE-REDUNDANT-CLAUSES) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-VARIABLE-IN-BINDINGS"
    "(DEFUN (LOOKUP-VARIABLE-IN-BINDINGS OBJECT) ((OBJ1 OBJECT) (OBJ2 OBJECT) (BINDINGS (LIST OF CONS))))"
    (CL:FUNCTION LOOKUP-VARIABLE-IN-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "LEARN-ONE-RULE-BOTTOM-UP-FROM-SIGNATURES"
    "(DEFUN (LEARN-ONE-RULE-BOTTOM-UP-FROM-SIGNATURES (CONS OF CONS)) ((POSITIVE (LIST OF TRAINING-EXAMPLE)) (NEGATIVE (LIST OF TRAINING-EXAMPLE)) (COVERED (LIST OF TRAINING-EXAMPLE)) (CONS-PROPS (VECTOR OF CONS))))"
    (CL:FUNCTION LEARN-ONE-RULE-BOTTOM-UP-FROM-SIGNATURES) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERSECT-SIGNATURES"
    "(DEFUN (INTERSECT-SIGNATURES (LIST OF INTEGER-WRAPPER)) ((SIG1 VECTOR) (SIG2 VECTOR)))"
    (CL:FUNCTION INTERSECT-SIGNATURES) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-SIGNATURE-COVERED-EXAMPLES"
    "(DEFUN (REMOVE-SIGNATURE-COVERED-EXAMPLES (LIST OF TRAINING-EXAMPLE)) ((INDICES (LIST OF INTEGER-WRAPPER)) (EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION REMOVE-SIGNATURE-COVERED-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "NUM-SIGNATURE-INDICES-COVERED"
    "(DEFUN (NUM-SIGNATURE-INDICES-COVERED INTEGER) ((INDICES (LIST OF INTEGER-WRAPPER)) (EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION NUM-SIGNATURE-INDICES-COVERED) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNATURE-INDICES-COVER-ANY-EXAMPLE?"
    "(DEFUN (SIGNATURE-INDICES-COVER-ANY-EXAMPLE? BOOLEAN) ((INDICES (LIST OF INTEGER-WRAPPER)) (EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION SIGNATURE-INDICES-COVER-ANY-EXAMPLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNATURE-INDICES-COVER-EXAMPLE?"
    "(DEFUN (SIGNATURE-INDICES-COVER-EXAMPLE? BOOLEAN) ((INDICES (LIST OF INTEGER-WRAPPER)) (EXAMPLE TRAINING-EXAMPLE)))"
    (CL:FUNCTION SIGNATURE-INDICES-COVER-EXAMPLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "TOP-DOWN-RULE-INDUCTION"
    "(DEFUN TOP-DOWN-RULE-INDUCTION ((EXAMPLES (LIST OF TRAINING-EXAMPLE))) :COMMAND? TRUE)"
    (CL:FUNCTION %TOP-DOWN-RULE-INDUCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-ANTECEDENT-FROM-RULE-INDEX"
    "(DEFUN (BUILD-ANTECEDENT-FROM-RULE-INDEX (CONS OF CONS)) ((PROPS (VECTOR OF CONS)) (RULE-INDEX (LIST OF INTEGER-WRAPPER))))"
    (CL:FUNCTION BUILD-ANTECEDENT-FROM-RULE-INDEX) NULL)
   (DEFINE-FUNCTION-OBJECT "LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES"
    "(DEFUN (LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES (CONS OF CONS)) ((POSITIVE (LIST OF TRAINING-EXAMPLE)) (NEGATIVE (LIST OF TRAINING-EXAMPLE)) (COVERED_POS (LIST OF TRAINING-EXAMPLE)) (CONS-PROPS (VECTOR OF CONS))))"
    (CL:FUNCTION LEARN-ONE-RULE-TOP-DOWN-FROM-SIGNATURES) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-EXAMPLE-MATCHES"
    "(DEFUN UPDATE-EXAMPLE-MATCHES ((EXAMPLES (LIST OF TRAINING-EXAMPLE)) (INDEX INTEGER) (MATCH-VALUE INTEGER-WRAPPER)))"
    (CL:FUNCTION UPDATE-EXAMPLE-MATCHES) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-COVERED-EXAMPLES"
    "(DEFUN UPDATE-COVERED-EXAMPLES ((FEATURE_INDEX INTEGER) (COVERED_POS (LIST OF TRAINING-EXAMPLE)) (COVERED_NEG (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION UPDATE-COVERED-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "COUNT-EXAMPLE-MATCHES"
    "(DEFUN (COUNT-EXAMPLE-MATCHES INTEGER) ((EXAMPLES (LIST OF TRAINING-EXAMPLE)) (INDEX INTEGER) (MATCH-VALUE INTEGER-WRAPPER)))"
    (CL:FUNCTION COUNT-EXAMPLE-MATCHES) NULL)
   (DEFINE-FUNCTION-OBJECT "FOIL-GAIN"
    "(DEFUN (FOIL-GAIN FLOAT) ((FEATURE-INDEX INTEGER) (UTILITY FLOAT) (COVERED-POS (LIST OF TRAINING-EXAMPLE)) (COVERED-NEG (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION FOIL-GAIN) NULL)
   (DEFINE-FUNCTION-OBJECT "FOIL-UTILITY"
    "(DEFUN (FOIL-UTILITY FLOAT) ((P INTEGER) (N INTEGER)))"
    (CL:FUNCTION FOIL-UTILITY) NULL)
   (DEFINE-FUNCTION-OBJECT "LEARN-ONE-RULE-TOP-DOWN"
    "(DEFUN (LEARN-ONE-RULE-TOP-DOWN (CONS OF CONS)) ((PROPOSITIONS (VECTOR OF CONS)) (POSITIVE (LIST OF TRAINING-EXAMPLE)) (NEGATIVE (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION LEARN-ONE-RULE-TOP-DOWN) NULL)
   (DEFINE-FUNCTION-OBJECT "SPECIALIZE-RULE"
    "(DEFUN (SPECIALIZE-RULE (CONS OF CONS)) ((RULE (CONS OF CONS)) (PROPOSITIONS (VECTOR OF CONS)) (POSITIVE (LIST OF TRAINING-EXAMPLE)) (NEGATIVE (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION SPECIALIZE-RULE) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-EXCLUDED-EXAMPLES"
    "(DEFUN REMOVE-EXCLUDED-EXAMPLES ((RULE (CONS OF CONS)) (COVERED-POS (LIST OF TRAINING-EXAMPLE)) (COVERED-NEG (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION REMOVE-EXCLUDED-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "QUERY-FOIL-GAIN"
    "(DEFUN (QUERY-FOIL-GAIN FLOAT) ((RULE (CONS OF CONS)) (UTILITY FLOAT) (COVERED-POS (LIST OF TRAINING-EXAMPLE)) (COVERED-NEG (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION QUERY-FOIL-GAIN) NULL)
   (DEFINE-FUNCTION-OBJECT "QUERY-AND-UPDATE-COVERED-EXAMPLES"
    "(DEFUN QUERY-AND-UPDATE-COVERED-EXAMPLES ((RULE (CONS OF CONS)) (UNCOVERED (LIST OF TRAINING-EXAMPLE)) (COVERED (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION QUERY-AND-UPDATE-COVERED-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-COVERED-EXAMPLES"
    "(DEFUN REMOVE-COVERED-EXAMPLES ((RULE (CONS OF CONS)) (UNCOVERED (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION REMOVE-COVERED-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "NUM-EXAMPLES-COVERED"
    "(DEFUN (NUM-EXAMPLES-COVERED INTEGER) ((RULE (CONS OF CONS)) (EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION NUM-EXAMPLES-COVERED) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-COVERED-EXAMPLES"
    "(DEFUN (GET-COVERED-EXAMPLES (LIST OF TRAINING-EXAMPLE)) ((RULE (CONS OF CONS)) (UNCOVERED (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION GET-COVERED-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "RULE-COVERS-ANY-EXAMPLE?"
    "(DEFUN (RULE-COVERS-ANY-EXAMPLE? BOOLEAN) ((RULE (CONS OF CONS)) (EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION RULE-COVERS-ANY-EXAMPLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "RULE-COVERS-EXAMPLE?"
    "(DEFUN (RULE-COVERS-EXAMPLE? BOOLEAN) ((REVERSE-RULE (CONS OF CONS)) (EXAMPLE TRAINING-EXAMPLE)))"
    (CL:FUNCTION RULE-COVERS-EXAMPLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "LINK-VARIABLES-IN-INDUCED-RULE"
    "(DEFUN (LINK-VARIABLES-IN-INDUCED-RULE (LIST OF (CONS OF CONS))) ((RULE (CONS OF CONS)) (EXAMPLES (LIST OF TRAINING-EXAMPLE)) (CONS-PROPS (VECTOR OF CONS))))"
    (CL:FUNCTION LINK-VARIABLES-IN-INDUCED-RULE) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-RULE-INDUCTION"
    "(DEFUN (EVALUATE-RULE-INDUCTION (VECTOR OF FLOAT-WRAPPER)) ((RELATION-NAME SYMBOL) (CLASS-NAME SYMBOL) (NUM-TRIALS INTEGER) (CURVE-SPLITS INTEGER)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %EVALUATE-RULE-INDUCTION)
    (CL:FUNCTION EVALUATE-RULE-INDUCTION-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "TRAIN-AND-TEST-RULE-INDUCTION"
    "(DEFUN (TRAIN-AND-TEST-RULE-INDUCTION FLOAT) ((TRAIN-SET (LIST OF TRAINING-EXAMPLE)) (TEST-SET (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION TRAIN-AND-TEST-RULE-INDUCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "INDUCE-DECISION-RULES"
    "(DEFUN INDUCE-DECISION-RULES ((RELATION-NAME SYMBOL) (CLASS-NAME SYMBOL)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %INDUCE-DECISION-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "MODULAR-INDUCE-DECISION-RULES"
    "(DEFUN MODULAR-INDUCE-DECISION-RULES ((RELATION-NAME SYMBOL) (CLASS-NAME SYMBOL) (MODULES (LIST OF MODULE))))"
    (CL:FUNCTION MODULAR-INDUCE-DECISION-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "ASK-DECISION-TREE"
    "(DEFUN (ASK-DECISION-TREE BOOLEAN) ((TREE DECISION-TREE) (QUERY CONS)))"
    (CL:FUNCTION ASK-DECISION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "TRAVERSE-DECISION-TREE"
    "(DEFUN (TRAVERSE-DECISION-TREE BOOLEAN) ((TREE DECISION-TREE) (FEATURES (VECTOR OF INTEGER-WRAPPER))))"
    (CL:FUNCTION TRAVERSE-DECISION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "INDUCE-DECISION-TREE"
    "(DEFUN (INDUCE-DECISION-TREE DECISION-TREE) ((EXAMPLES (LIST OF TRAINING-EXAMPLE))) :COMMAND? TRUE)"
    (CL:FUNCTION %INDUCE-DECISION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-PROPOSITIONS-TO-DECISION-TREE"
    "(DEFUN ADD-PROPOSITIONS-TO-DECISION-TREE ((TREE DECISION-TREE) (TABLE (HASH-TABLE OF SYMBOL PROPOSITION))))"
    (CL:FUNCTION ADD-PROPOSITIONS-TO-DECISION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-DECISION-TREE"
    "(DEFUN (BUILD-DECISION-TREE OBJECT) ((EXAMPLES (LIST OF TRAINING-EXAMPLE)) (FEATURES (LIST OF SYMBOL)) (FEATURE-STACK (CONS OF SYMBOL))))"
    (CL:FUNCTION BUILD-DECISION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPECTED-ENTROPY"
    "(DEFUN (EXPECTED-ENTROPY FLOAT) ((FEATURE-INDEX INTEGER) (EXAMPLES (LIST OF TRAINING-EXAMPLE))))"
    (CL:FUNCTION EXPECTED-ENTROPY) NULL)
   (DEFINE-FUNCTION-OBJECT "ENTROPY"
    "(DEFUN (ENTROPY FLOAT) ((P INTEGER) (N INTEGER)))"
    (CL:FUNCTION ENTROPY) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-DECISION-TREE"
    "(DEFUN PRINT-DECISION-TREE ((TREE DECISION-TREE) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-DECISION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-PRINT-DECISION-TREE"
    "(DEFUN HELP-PRINT-DECISION-TREE ((TREE DECISION-TREE) (LEVEL INTEGER) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION HELP-PRINT-DECISION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-RULES-FROM-TREE"
    "(DEFUN (GET-RULES-FROM-TREE (LIST OF CONS)) ((QUERY CONS) (TREE DECISION-TREE)))"
    (CL:FUNCTION GET-RULES-FROM-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-RULES-FROM-TREE"
    "(DEFUN (BUILD-RULES-FROM-TREE (LIST OF CONS)) ((TREE DECISION-TREE) (PROPS (LIST OF PROPOSITION))))"
    (CL:FUNCTION BUILD-RULES-FROM-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "EXTRACT-PATHS-FROM-TREE"
    "(DEFUN EXTRACT-PATHS-FROM-TREE ((TREE DECISION-TREE) (ANTECEDENT-STACK (CONS OF CONS)) (ANTECEDENT (LIST OF CONS))))"
    (CL:FUNCTION EXTRACT-PATHS-FROM-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "SORT-EXAMPLES-BY-TREE"
    "(DEFUN SORT-EXAMPLES-BY-TREE ((TREE DECISION-TREE) (EXAMPLES (LIST OF TRAINING-EXAMPLE)) (SORTED-EXAMPLES (LIST OF (LIST OF TRAINING-EXAMPLE)))))"
    (CL:FUNCTION SORT-EXAMPLES-BY-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-INDUCED-RULES"
    "(DEFUN ASSERT-INDUCED-RULES () :COMMAND? TRUE)"
    (CL:FUNCTION ASSERT-INDUCED-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-CANDIDATE-CLAUSES"
    "(DEFUN SET-CANDIDATE-CLAUSES ((CLASS-NAME SYMBOL)))"
    (CL:FUNCTION SET-CANDIDATE-CLAUSES) NULL)))

(CL:DEFUN STARTUP-RULE-INDUCTION ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-RULE-INDUCTION1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *RULE-INDUCTION-STRATEGY* KWD-RULE-INDUCTION-TOP-DOWN)
    (CL:SETQ *SIGNATURE-STRATEGY* KWD-RULE-INDUCTION-TOP-DOWN))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "DECISION-TREE"
        "(DEFCLASS DECISION-TREE (STANDARD-OBJECT) :SLOTS ((FEATURE :TYPE SYMBOL) (FEATURE-INDEX :TYPE INTEGER) (PROPOSITION :TYPE PROPOSITION) (TRUTH-VALUE :TYPE BOOLEAN) (CONCEPT :TYPE SYMBOL) (TRUE-BRANCH :TYPE DECISION-TREE) (FALSE-BRANCH :TYPE DECISION-TREE)) :PRINT-FORM (PRINT-DECISION-TREE SELF STREAM))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-DECISION-TREE))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-DECISION-TREE-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (HELP-STARTUP-RULE-INDUCTION2)
    (DEFINE-FUNCTION-OBJECT "GET-VARIABLES-FROM-PROPOSITION-LIST"
     "(DEFUN (GET-VARIABLES-FROM-PROPOSITION-LIST (LIST OF SYMBOL)) ((PROPS (LIST OF PROPOSITION))))"
     (CL:FUNCTION GET-VARIABLES-FROM-PROPOSITION-LIST) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-VARIABLES-FROM-CONS-PROPOSITIONS"
     "(DEFUN (GET-VARIABLES-FROM-CONS-PROPOSITIONS (LIST OF SYMBOL)) ((PROPS (CONS OF CONS))))"
     (CL:FUNCTION GET-VARIABLES-FROM-CONS-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-GET-VARIABLES-FROM-CONS-PROPOSITIONS"
     "(DEFUN (HELP-GET-VARIABLES-FROM-CONS-PROPOSITIONS (LIST OF SYMBOL)) ((ELE PARSE-TREE) (THE-LIST (LIST OF SYMBOL))))"
     (CL:FUNCTION HELP-GET-VARIABLES-FROM-CONS-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-PROPOSITIONS-FROM-DECISION-TREE"
     "(DEFUN (GET-PROPOSITIONS-FROM-DECISION-TREE (LIST OF PROPOSITION)) ((TREE DECISION-TREE)))"
     (CL:FUNCTION GET-PROPOSITIONS-FROM-DECISION-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-RULE-INDUCTION"
     "(DEFUN STARTUP-RULE-INDUCTION () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-RULE-INDUCTION) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION
        SYM-RULE-INDUCTION-LOGIC-STARTUP-RULE-INDUCTION)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-RULE-INDUCTION-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupRuleInduction") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *RULE-INDUCTION-STRATEGY* KEYWORD :TOP-DOWN)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SIGNATURE-STRATEGY* KEYWORD :TOP-DOWN)")
    (REGISTER-NATIVE-NAME
     SYM-RULE-INDUCTION-LOGIC-SET-SIGNATURE-STRATEGY
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ENABLE-USER-THING* BOOLEAN TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *OPTIMIZE-INDUCED-QUERIES* BOOLEAN TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SIMPLIFY-RULE-ANTECEDENT?* BOOLEAN FALSE :DOCUMENTATION \"Flag to control whether we try to simplify the rule antecedent.
This should be set to FALSE if we expect the user to edit the rule and
TRUE if we want to have final rules as general as possible.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TRACE-ID3* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TRACE-FOIL* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INDUCE-RULES-FROM-SIGNATURES* BOOLEAN TRUE)")
    (REGISTER-NATIVE-NAME SYM-RULE-INDUCTION-LOGIC-SET-SIGNATURE-RULES
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *NUM-LGGS* INTEGER 2000)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ENFORCE-LINKED-VARIABLES* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOG-INDUCED-RULES* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ALLOW-RECURSIVE-DECISION-NODES* BOOLEAN TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOG-DECISION-RULE-CONSTRUCTION* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL LOG_2 FLOAT 0.6931472)")
    (REGISTER-NATIVE-NAME
     SYM-RULE-INDUCTION-LOGIC-SET-RULE-INDUCTION-STRATEGY
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-RULE-INDUCTION-LOGIC-SET-RECURSIVE-DECISION-NODES
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INDUCED-DECISION-RULES* (LIST OF CONS) NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INDUCED-RULE-COUNTER* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CANDIDATE-CLAUSES* (VECTOR OF CONS) NULL)")
    (REGISTER-NATIVE-NAME
     SYM-RULE-INDUCTION-LOGIC-INDUCE-INFERENCE-RULES
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-RULE-INDUCTION-LOGIC-BOTTOM-UP-RULE-INDUCTION
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *BOTTOM-UP-VARIABLE-COUNTER* INTEGER -1)")
    (REGISTER-NATIVE-NAME
     SYM-RULE-INDUCTION-LOGIC-TOP-DOWN-RULE-INDUCTION
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-RULE-INDUCTION-LOGIC-EVALUATE-RULE-INDUCTION
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-RULE-INDUCTION-LOGIC-INDUCE-DECISION-RULES
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-RULE-INDUCTION-LOGIC-INDUCE-DECISION-TREE
     KWD-RULE-INDUCTION-COMMON-LISP KWD-RULE-INDUCTION-FUNCTION))))
