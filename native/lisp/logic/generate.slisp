;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; generate.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-GENERATE-STELLA-THING NULL)
(CL:DEFVAR SYM-GENERATE-STELLA-SETOF NULL)
(CL:DEFVAR SYM-GENERATE-LOGIC-LISTOF NULL)
(CL:DEFVAR SYM-GENERATE-LOGIC-COMPLEMENT-DESCRIPTION NULL)
(CL:DEFVAR SYM-GENERATE-STELLA-NOT NULL)
(CL:DEFVAR SYM-GENERATE-LOGIC-KAPPA NULL)
(CL:DEFVAR SYM-GENERATE-STELLA-NULL NULL)
(CL:DEFVAR KWD-GENERATE-PREDICATE NULL)
(CL:DEFVAR KWD-GENERATE-FUNCTION NULL)
(CL:DEFVAR KWD-GENERATE-ISA NULL)
(CL:DEFVAR KWD-GENERATE-AND NULL)
(CL:DEFVAR KWD-GENERATE-OR NULL)
(CL:DEFVAR KWD-GENERATE-NOT NULL)
(CL:DEFVAR KWD-GENERATE-EQUIVALENT NULL)
(CL:DEFVAR SYM-GENERATE-STELLA-= NULL)
(CL:DEFVAR KWD-GENERATE-EXISTS NULL)
(CL:DEFVAR SYM-GENERATE-STELLA-EXISTS NULL)
(CL:DEFVAR SYM-GENERATE-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR KWD-GENERATE-FORALL NULL)
(CL:DEFVAR SYM-GENERATE-LOGIC-BACKWARD-ONLY? NULL)
(CL:DEFVAR SYM-GENERATE-STELLA-FORALL NULL)
(CL:DEFVAR KWD-GENERATE-IMPLIES NULL)
(CL:DEFVAR KWD-GENERATE-FAIL NULL)
(CL:DEFVAR SYM-GENERATE-LOGIC-FAIL NULL)
(CL:DEFVAR KWD-GENERATE-CONSTANT NULL)
(CL:DEFVAR SYM-GENERATE-PL-KERNEL-KB-CONCEPT-PROTOTYPE NULL)
(CL:DEFVAR SYM-GENERATE-LOGIC-UNIDENTIFIED-SKOLEM NULL)
(CL:DEFVAR SYM-GENERATE-LOGIC-UNNAMED_OBJECT NULL)
(CL:DEFVAR SGT-GENERATE-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-GENERATE-STELLA-LITERAL-WRAPPER NULL)
(CL:DEFVAR SGT-GENERATE-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-GENERATE-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-GENERATE-LOGIC-SKOLEM NULL)
(CL:DEFVAR SGT-GENERATE-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-GENERATE-STELLA-COLLECTION NULL)
(CL:DEFVAR SGT-GENERATE-LOGIC-LOGIC-THING NULL)
(CL:DEFVAR SYM-GENERATE-LOGIC-ILLEGAL-TERM NULL)
(CL:DEFVAR SYM-GENERATE-PL-KERNEL-KB-SUBSET-OF NULL)
(CL:DEFVAR SYM-GENERATE-LOGIC-FORWARD-ONLY? NULL)
(CL:DEFVAR SGT-GENERATE-STELLA-CONS NULL)
(CL:DEFVAR SYM-GENERATE-LOGIC-STARTUP-GENERATE NULL)
(CL:DEFVAR SYM-GENERATE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* EOL FALSE-WRAPPER
  *CURRENTJUSTIFICATION* NIL *SKOLEMNAMEMAPPINGTABLE*
  SYSTEM-DEFINED-ARGUMENT-NAMES NULL-INTEGER))

;;; (DEFSPECIAL *CANONICALVARIABLENAMEMAPPING* ...)

(CL:DEFVAR *CANONICALVARIABLENAMEMAPPING* NULL
  "Maps variables to symbols in SYSTEM-DEFINED-ARGUMENT-NAMES.")

;;; (DEFSPECIAL *CANONICALVARIABLECOUNTER* ...)

(CL:DEFVAR *CANONICALVARIABLECOUNTER* NULL-INTEGER
  "Number of the last canonically-mapped variable.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *CANONICALVARIABLECOUNTER*))

(CL:DEFUN NEW-TERM-GENERATION-EXCEPTION (OFFENDING-TERM MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE TERM-GENERATION-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:SETF (%OFFENDING-TERM SELF) OFFENDING-TERM) SELF))

;;; (DEFUN (GENERATE-EXPRESSION OBJECT) ...)

(CL:DEFUN GENERATE-EXPRESSION (SELF CANONICALIZEVARIABLENAMES?)
  "Return an s-expression representing the source expression for 'self'."
  (CL:LET*
   ((*CANONICALVARIABLENAMEMAPPING*
     (CL:IF CANONICALIZEVARIABLENAMES? (NEW-KEY-VALUE-LIST) NULL))
    (*CANONICALVARIABLECOUNTER* -1))
   (CL:DECLARE
    (CL:SPECIAL *CANONICALVARIABLENAMEMAPPING*
     *CANONICALVARIABLECOUNTER*))
   (CL:DECLARE (CL:TYPE CL:FIXNUM *CANONICALVARIABLECOUNTER*))
   (GENERATE-TERM SELF)))

;;; (DEFUN (GENERATE-NAME-OF-VARIABLE SYMBOL) ...)

(CL:DEFUN GENERATE-NAME-OF-VARIABLE (SELF)
  (CL:WHEN (CL:NOT (CL:EQ *SKOLEMNAMEMAPPINGTABLE* NULL))
   (CL:LET* ((TEMP-000 (LOOKUP *SKOLEMNAMEMAPPINGTABLE* SELF)))
    (CL:SETQ SELF
     (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 SELF))))
  (CL:WHEN (CL:EQ *CANONICALVARIABLENAMEMAPPING* NULL)
   (CL:RETURN-FROM GENERATE-NAME-OF-VARIABLE
    (%PATTERN-VARIABLE.SKOLEM-NAME SELF)))
  (CL:LET*
   ((CANONICALNAME (LOOKUP *CANONICALVARIABLENAMEMAPPING* SELF)))
   (CL:WHEN (CL:EQ CANONICALNAME NULL)
    (CL:SETQ CANONICALNAME
     (NTH SYSTEM-DEFINED-ARGUMENT-NAMES
      (CL:SETQ *CANONICALVARIABLECOUNTER*
       (CL:1+ *CANONICALVARIABLECOUNTER*))))
    (INSERT-AT *CANONICALVARIABLENAMEMAPPING* SELF CANONICALNAME))
   CANONICALNAME))

;;; (DEFUN (GENERATE-ONE-VARIABLE OBJECT) ...)

(CL:DEFUN GENERATE-ONE-VARIABLE (SELF TYPED?)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *CURRENTJUSTIFICATION* NULL))
    (CL:NOT (CL:EQ (JUSTIFICATION-ARGUMENT-BOUND-TO SELF NULL) NULL)))
   (CL:RETURN-FROM GENERATE-ONE-VARIABLE
    (GENERATE-TERM (JUSTIFICATION-ARGUMENT-BOUND-TO SELF NULL))))
  (CL:LET* ((NAME (GENERATE-NAME-OF-VARIABLE SELF)))
   (CL:IF
    (CL:AND TYPED?
     (CL:NOT (CL:EQ (LOGICAL-TYPE SELF) SGT-GENERATE-STELLA-THING)))
    (CONS NAME (CONS (SYMBOLIZE (LOGICAL-TYPE SELF)) NIL)) NAME)))

;;; (DEFUN (GENERATE-VARIABLES CONS) ...)

(CL:DEFUN GENERATE-VARIABLES (VECTOR TYPED?)
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((V NULL) (VECTOR-000 VECTOR) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ V
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS (GENERATE-ONE-VARIABLE V TYPED?) NIL))
       (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (GENERATE-ONE-VARIABLE V TYPED?) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   RESULT))

;;; (DEFUN (GENERATE-STELLA-COLLECTION CONS) ...)

(CL:DEFUN GENERATE-STELLA-COLLECTION (SELF)
  (CL:LET* ((COLLECTION NIL))
   (CL:LET*
    ((M NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ M (%ITERATOR.VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (GENERATE-TERM M) NIL))
       (CL:IF (CL:EQ COLLECTION NIL) (CL:SETQ COLLECTION COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST COLLECTION COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000) (CONS (GENERATE-TERM M) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CONS
    (CL:IF (NO-DUPLICATES? SELF) SYM-GENERATE-STELLA-SETOF
     SYM-GENERATE-LOGIC-LISTOF)
    (CONCATENATE COLLECTION NIL))))

;;; (DEFUN (GENERATE-DESCRIPTION OBJECT) ...)

(CL:DEFUN GENERATE-DESCRIPTION (SELF)
  (CL:COND
   ((NAMED-DESCRIPTION? SELF)
    (INTERNAL-STELLA-OPERATOR-TO-KIF (DESCRIPTION-NAME SELF)))
   ((CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
       SYM-GENERATE-LOGIC-COMPLEMENT-DESCRIPTION NULL)
      NULL))
    (LIST* SYM-GENERATE-STELLA-NOT
     (INTERNAL-STELLA-OPERATOR-TO-KIF
      (DESCRIPTION-NAME
       (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-GENERATE-LOGIC-COMPLEMENT-DESCRIPTION NULL)))
     NIL))
   (CL:T
    (LIST* SYM-GENERATE-LOGIC-KAPPA
     (GENERATE-VARIABLES (%DESCRIPTION.IO-VARIABLES SELF) CL:T)
     (CONS (GENERATE-DESCRIPTION-PROPOSITION SELF CL:NIL) NIL)))))

;;; (DEFUN (GENERATE-ARGUMENTS CONS) ...)

(CL:DEFUN GENERATE-ARGUMENTS (ARGUMENTS)
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (GENERATE-TERM ARG) NIL))
       (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000) (CONS (GENERATE-TERM ARG) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   RESULT))

;;; (DEFUN (GENERATE-OPERATOR SYMBOL) ...)

(CL:DEFUN GENERATE-OPERATOR (SELF)
  (CL:LET* ((OPERATOR (%PROPOSITION.OPERATOR SELF)))
   (CL:WHEN (CL:EQ OPERATOR NULL)
    (CL:RETURN-FROM GENERATE-OPERATOR SYM-GENERATE-STELLA-NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OPERATOR)))
    (CL:COND
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN
       (CL:LET*
        ((DESCRIPTION (GET-DESCRIPTION OPERATOR))
         (SYMBOL
          (INTERN-SYMBOL-IN-MODULE (%SURROGATE.SYMBOL-NAME OPERATOR)
           (%SURROGATE.HOME-CONTEXT OPERATOR) CL:NIL)))
        (CL:IF (CL:NOT (CL:EQ DESCRIPTION NULL))
         (INTERNAL-STELLA-OPERATOR-TO-KIF SYMBOL) SYMBOL))))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000) (CL:PROGN OPERATOR))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN (GENERATE-PROPOSITION OBJECT) ...)

(CL:DEFUN GENERATE-PROPOSITION (SELF)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-GENERATE-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-GENERATE-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-GENERATE-ISA)
      (CL:EQ TEST-VALUE-000 KWD-GENERATE-AND)
      (CL:EQ TEST-VALUE-000 KWD-GENERATE-OR)
      (CL:EQ TEST-VALUE-000 KWD-GENERATE-NOT))
     (CL:LET* ((OPERATOR (GENERATE-OPERATOR SELF)))
      (CONS OPERATOR
       (CONCATENATE (GENERATE-ARGUMENTS (%PROPOSITION.ARGUMENTS SELF))
        NIL))))
    ((CL:EQ TEST-VALUE-000 KWD-GENERATE-EQUIVALENT)
     (CONS SYM-GENERATE-STELLA-=
      (CONCATENATE (GENERATE-ARGUMENTS (%PROPOSITION.ARGUMENTS SELF))
       NIL)))
    ((CL:EQ TEST-VALUE-000 KWD-GENERATE-EXISTS)
     (LIST* SYM-GENERATE-STELLA-EXISTS
      (GENERATE-VARIABLES
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
        SYM-GENERATE-LOGIC-IO-VARIABLES NULL)
       CL:NIL)
      (CONS
       (GENERATE-PROPOSITION
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
         0))
       NIL)))
    ((CL:EQ TEST-VALUE-000 KWD-GENERATE-FORALL)
     (CL:LET*
      ((FORWARD?
        (CL:NOT
         (%BOOLEAN-WRAPPER.WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
           SYM-GENERATE-LOGIC-BACKWARD-ONLY? FALSE-WRAPPER))))
       (ARROW (SYMBOLIZE (CHOOSE-IMPLICATION-OPERATOR SELF FORWARD?))))
      (LIST* SYM-GENERATE-STELLA-FORALL
       (GENERATE-VARIABLES
        (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
         SYM-GENERATE-LOGIC-IO-VARIABLES NULL)
        CL:NIL)
       (CONS
        (CONS ARROW
         (CONS
          (GENERATE-PROPOSITION
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
            (CL:THE CL:FIXNUM (CL:IF FORWARD? 0 1))))
          (CONS
           (GENERATE-PROPOSITION
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
             (CL:THE CL:FIXNUM (CL:IF FORWARD? 1 0))))
           NIL)))
        NIL))))
    ((CL:EQ TEST-VALUE-000 KWD-GENERATE-IMPLIES)
     (GENERATE-IMPLIES-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-GENERATE-FAIL)
     (CONS SYM-GENERATE-LOGIC-FAIL
      (CONCATENATE (GENERATE-ARGUMENTS (%PROPOSITION.ARGUMENTS SELF))
       NIL)))
    ((CL:EQ TEST-VALUE-000 KWD-GENERATE-CONSTANT)
     (GENERATE-OPERATOR SELF))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (GENERATE-FUNCTION-AS-TERM CONS) ...)

(CL:DEFUN GENERATE-FUNCTION-AS-TERM (SELF)
  (CL:LET* ((ARGUMENTS NIL))
   (CL:LET*
    ((ARG NULL) (ITER-000 (BUT-LAST (%PROPOSITION.ARGUMENTS SELF)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ ARG (%ITERATOR.VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (GENERATE-TERM ARG) NIL))
       (CL:IF (CL:EQ ARGUMENTS NIL) (CL:SETQ ARGUMENTS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST ARGUMENTS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000) (CONS (GENERATE-TERM ARG) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CONS (GENERATE-OPERATOR SELF) (CONCATENATE ARGUMENTS NIL))))

;;; (DEFUN (GENERATE-SKOLEM OBJECT) ...)

(CL:DEFUN GENERATE-SKOLEM (SELF)
  (CL:COND
   ((CL:NOT (CL:EQ (NATIVE-VALUE-OF SELF) NULL))
    (GENERATE-TERM (NATIVE-VALUE-OF SELF)))
   ((CL:AND (CL:NOT (CL:EQ (%SKOLEM.DEFINING-PROPOSITION SELF) NULL))
     (CL:EQ
      (ACCESS-IN-CONTEXT (%SKOLEM.VARIABLE-VALUE SELF)
       (%SKOLEM.HOME-CONTEXT SELF) CL:NIL)
      NULL))
    (GENERATE-FUNCTION-AS-TERM (%SKOLEM.DEFINING-PROPOSITION SELF)))
   ((CL:AND (CL:NOT (CL:EQ (INNERMOST-OF SELF) NULL))
     (CL:NOT (CL:EQ SELF (INNERMOST-OF SELF))))
    (GENERATE-TERM (INNERMOST-OF SELF)))
   ((CONCEPT-PROTOTYPE? SELF)
    (LIST* SYM-GENERATE-PL-KERNEL-KB-CONCEPT-PROTOTYPE
     (GENERATE-TERM (CONCEPT-PROTOTYPE-OF SELF)) NIL))
   (CL:T (CL:WARN "Don't know how to generate skolem: `~A'~%" SELF)
    SYM-GENERATE-LOGIC-UNIDENTIFIED-SKOLEM)))

;;; (DEFMETHOD (GENERATE-SPECIALIZED-TERM OBJECT) ...)

(CL:DEFMETHOD GENERATE-SPECIALIZED-TERM ((SELF LOGIC-THING))
  "Method to generate a specialized term for `self'.  This is designed
to allow for extension of the term generation code to cover other
types of objects for the logic.  This particular method will signal
an error unless there is a surrogate-value-inverse link set."
  (CL:IF
   (CL:NOT (CL:EQ (%LOGIC-THING.SURROGATE-VALUE-INVERSE SELF) NULL))
   (%LOGIC-THING.SURROGATE-VALUE-INVERSE SELF)
   (CL:ERROR
    (NEW-TERM-GENERATION-EXCEPTION SELF
     (CONCATENATE
      "DON'T KNOW HOW TO GENERATE EXPRESSION FOR THE THING: "
      (STRINGIFY SELF))))))

;;; (DEFUN (GENERATE-TERM OBJECT) ...)

(CL:DEFUN GENERATE-TERM (SELF)
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM GENERATE-TERM NULL))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-GENERATE-LOGIC-PROPOSITION)
     (CL:PROGN (GENERATE-PROPOSITION SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-GENERATE-STELLA-LITERAL-WRAPPER)
     (CL:PROGN SELF))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-GENERATE-LOGIC-DESCRIPTION)
     (CL:PROGN (GENERATE-DESCRIPTION SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-GENERATE-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN (GENERATE-ONE-VARIABLE SELF CL:NIL)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-GENERATE-LOGIC-SKOLEM)
     (CL:PROGN (GENERATE-SKOLEM SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-GENERATE-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:IF
       (CL:NOT
        (CL:EQ (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE SELF) NULL))
       (INTERN-SYMBOL-IN-MODULE
        (%SURROGATE.SYMBOL-NAME
         (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE SELF))
        (%SURROGATE.HOME-CONTEXT
         (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE SELF))
        CL:NIL)
       SYM-GENERATE-LOGIC-UNNAMED_OBJECT)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (INTERN-SYMBOL-IN-MODULE (%SURROGATE.SYMBOL-NAME SELF)
       (%SURROGATE.HOME-CONTEXT SELF) CL:NIL)))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000) (CL:PROGN SELF))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-GENERATE-STELLA-COLLECTION)
     (CL:PROGN (GENERATE-STELLA-COLLECTION SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-GENERATE-LOGIC-LOGIC-THING)
     (CL:PROGN (GENERATE-SPECIALIZED-TERM SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-GENERATE-STELLA-THING)
     (CL:PROGN
      (CL:IF
       (CL:NOT (CL:EQ (%THING.SURROGATE-VALUE-INVERSE SELF) NULL))
       (%THING.SURROGATE-VALUE-INVERSE SELF)
       (CL:ERROR
        (NEW-TERM-GENERATION-EXCEPTION SELF
         (CONCATENATE
          "DON'T KNOW HOW TO GENERATE EXPRESSION FOR THE THING: "
          (STRINGIFY SELF)))))))
    (CL:T (CL:WARN "Illegal logical form: `~A'~%" SELF)
     SYM-GENERATE-LOGIC-ILLEGAL-TERM))))

;;; (DEFUN (GENERATE-IMPLIES-PROPOSITION CONS) ...)

(CL:DEFUN GENERATE-IMPLIES-PROPOSITION (SELF)
  (CL:LET*
   ((TAILARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      0))
    (HEADARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      1)))
   (CL:IF
    (CL:AND (ISA? HEADARG SGT-GENERATE-LOGIC-DESCRIPTION)
     (ISA? TAILARG SGT-GENERATE-LOGIC-DESCRIPTION))
    (GENERATE-DESCRIPTIONS-AS-RULE HEADARG TAILARG SELF CL:NIL)
    (CONS SYM-GENERATE-PL-KERNEL-KB-SUBSET-OF
     (CONCATENATE (GENERATE-ARGUMENTS (%PROPOSITION.ARGUMENTS SELF))
      NIL)))))

;;; (DEFUN (GENERATE-DESCRIPTION-PROPOSITION CONS) ...)

(CL:DEFUN GENERATE-DESCRIPTION-PROPOSITION (SELF INVERT?)
  (CL:LET*
   ((PROP (GENERATE-PROPOSITION (%DESCRIPTION.PROPOSITION SELF)))
    (EXISTENTALS
     (CL:IF
      (CL:> (%VECTOR.ARRAY-SIZE (%DESCRIPTION.INTERNAL-VARIABLES SELF))
       0)
      (TOP-LEVEL-EXISTENTIAL-VARIABLES SELF) NIL)))
   (CL:LET*
    ((VAR NULL) (ITER-000 EXISTENTALS) (I NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ VAR (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (NTH-SETTER EXISTENTALS (GENERATE-ONE-VARIABLE VAR CL:T) I)
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:WHEN (CL:NOT (CL:EQ EXISTENTALS NIL))
    (CL:SETQ PROP
     (LIST* SYM-GENERATE-STELLA-EXISTS EXISTENTALS (CONS PROP NIL))))
   (CL:IF INVERT? (LIST* SYM-GENERATE-STELLA-NOT PROP NIL) PROP)))

;;; (DEFUN (GENERATE-DESCRIPTIONS-AS-RULE CONS) ...)

(CL:DEFUN GENERATE-DESCRIPTIONS-AS-RULE (HEAD TAIL RULE REVERSEPOLARITY?)
  (CL:LET*
   ((FORWARDARROW?
     (CL:AND
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS RULE)
        SYM-GENERATE-LOGIC-FORWARD-ONLY? FALSE-WRAPPER))
      (CL:NOT REVERSEPOLARITY?)))
    (REVERSEARGUMENTS? (CL:OR FORWARDARROW? REVERSEPOLARITY?))
    (ARROW
     (SYMBOLIZE (CHOOSE-IMPLICATION-OPERATOR RULE FORWARDARROW?)))
    (MAPHEADVARIABLES? (NAMED-DESCRIPTION? HEAD)) (HEADPROP NULL)
    (TAILPROP NULL) (UNIVERSALS NIL))
   (CL:WHEN REVERSEARGUMENTS?
    (CL:LET* ((TEMP HEAD)) (CL:SETQ HEAD TAIL) (CL:SETQ TAIL TEMP))
    (CL:SETQ MAPHEADVARIABLES? (CL:NOT MAPHEADVARIABLES?)))
   (CL:LET*
    ((VAR NULL)
     (VECTOR-000
      (CL:IF MAPHEADVARIABLES? (%DESCRIPTION.IO-VARIABLES TAIL)
       (%DESCRIPTION.IO-VARIABLES HEAD)))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ VAR
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS (GENERATE-ONE-VARIABLE VAR CL:T) NIL))
       (CL:IF (CL:EQ UNIVERSALS NIL) (CL:SETQ UNIVERSALS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST UNIVERSALS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (GENERATE-ONE-VARIABLE VAR CL:T) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET*
    ((*SKOLEMNAMEMAPPINGTABLE*
      (CL:IF MAPHEADVARIABLES?
       (CREATE-SKOLEM-MAPPING-TABLE (%DESCRIPTION.IO-VARIABLES HEAD)
        (%DESCRIPTION.IO-VARIABLES TAIL))
       NULL)))
    (CL:DECLARE (CL:SPECIAL *SKOLEMNAMEMAPPINGTABLE*))
    (CL:SETQ HEADPROP
     (GENERATE-DESCRIPTION-PROPOSITION HEAD REVERSEPOLARITY?)))
   (CL:LET*
    ((*SKOLEMNAMEMAPPINGTABLE*
      (CL:IF (CL:NOT MAPHEADVARIABLES?)
       (CREATE-SKOLEM-MAPPING-TABLE (%DESCRIPTION.IO-VARIABLES TAIL)
        (%DESCRIPTION.IO-VARIABLES HEAD))
       NULL)))
    (CL:DECLARE (CL:SPECIAL *SKOLEMNAMEMAPPINGTABLE*))
    (CL:SETQ TAILPROP
     (GENERATE-DESCRIPTION-PROPOSITION TAIL REVERSEPOLARITY?)))
   (LIST* SYM-GENERATE-STELLA-FORALL UNIVERSALS
    (CONS (CONS ARROW (CONS HEADPROP (CONS TAILPROP NIL))) NIL))))

;;; (DEFUN (DEOBJECTIFY-TREE OBJECT) ...)

(CL:DEFUN DEOBJECTIFY-TREE (SELF)
  "Return a copy of `self' where all logic objects are
replaced by their `generated' parse-tree version.  This is useful to
convert the result of a retrieval query into a regular parse tree."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-GENERATE-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((RESULT NIL))
       (CL:LET* ((ELT NULL) (ITER-000 SELF) (COLLECT-000 NULL))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ ELT (%%VALUE ITER-000))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-000 (CONS (DEOBJECTIFY-TREE ELT) NIL))
           (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-000)
            (CONS (DEOBJECTIFY-TREE ELT) NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       RESULT)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-GENERATE-LOGIC-PROPOSITION)
     (CL:PROGN (GENERATE-TERM SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-GENERATE-LOGIC-LOGIC-OBJECT)
     (CL:PROGN (GENERATE-TERM SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-GENERATE-STELLA-COLLECTION)
     (CL:PROGN (GENERATE-TERM SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-GENERATE-STELLA-THING)
     (CL:PROGN (GENERATE-TERM SELF)))
    (CL:T SELF))))

(CL:DEFUN HELP-STARTUP-GENERATE1 ()
  (CL:PROGN
   (CL:SETQ SGT-GENERATE-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-GENERATE-STELLA-SETOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOF"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-GENERATE-LOGIC-LISTOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISTOF" NULL 0))
   (CL:SETQ SYM-GENERATE-LOGIC-COMPLEMENT-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT-DESCRIPTION" NULL 0))
   (CL:SETQ SYM-GENERATE-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-GENERATE-LOGIC-KAPPA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
   (CL:SETQ SYM-GENERATE-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-GENERATE-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-GENERATE-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-GENERATE-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ KWD-GENERATE-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-GENERATE-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-GENERATE-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-GENERATE-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ SYM-GENERATE-STELLA-=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "="
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-GENERATE-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ SYM-GENERATE-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-GENERATE-LOGIC-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
   (CL:SETQ KWD-GENERATE-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ SYM-GENERATE-LOGIC-BACKWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD-ONLY?" NULL 0))
   (CL:SETQ SYM-GENERATE-STELLA-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-GENERATE-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ KWD-GENERATE-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ SYM-GENERATE-LOGIC-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 0))
   (CL:SETQ KWD-GENERATE-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 2))
   (CL:SETQ SYM-GENERATE-PL-KERNEL-KB-CONCEPT-PROTOTYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEPT-PROTOTYPE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-GENERATE-LOGIC-UNIDENTIFIED-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNIDENTIFIED-SKOLEM" NULL 0))
   (CL:SETQ SYM-GENERATE-LOGIC-UNNAMED_OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNNAMED_OBJECT" NULL 0))
   (CL:SETQ SGT-GENERATE-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SGT-GENERATE-STELLA-LITERAL-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-GENERATE-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SGT-GENERATE-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-GENERATE-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SGT-GENERATE-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SGT-GENERATE-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-GENERATE-LOGIC-LOGIC-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-THING" NULL 1))
   (CL:SETQ SYM-GENERATE-LOGIC-ILLEGAL-TERM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ILLEGAL-TERM" NULL 0))
   (CL:SETQ SYM-GENERATE-PL-KERNEL-KB-SUBSET-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-GENERATE-LOGIC-FORWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-ONLY?" NULL 0))
   (CL:SETQ SGT-GENERATE-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-GENERATE-LOGIC-STARTUP-GENERATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-GENERATE" NULL 0))
   (CL:SETQ SYM-GENERATE-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN STARTUP-GENERATE ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-GENERATE1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TERM-GENERATION-EXCEPTION"
        "(DEFCLASS TERM-GENERATION-EXCEPTION (LOGIC-EXCEPTION) :PUBLIC? TRUE :DOCUMENTATION \"Signals an exception during term generation.\" :PUBLIC-SLOTS ((OFFENDING-TERM :TYPE OBJECT :REQUIRED? TRUE)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TERM-GENERATION-EXCEPTION))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "GENERATE-EXPRESSION"
     "(DEFUN (GENERATE-EXPRESSION OBJECT) ((SELF LOGIC-OBJECT) (CANONICALIZEVARIABLENAMES? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Return an s-expression representing the source expression for 'self'.\")"
     (CL:FUNCTION GENERATE-EXPRESSION) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-NAME-OF-VARIABLE"
     "(DEFUN (GENERATE-NAME-OF-VARIABLE SYMBOL) ((SELF PATTERN-VARIABLE)))"
     (CL:FUNCTION GENERATE-NAME-OF-VARIABLE) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-ONE-VARIABLE"
     "(DEFUN (GENERATE-ONE-VARIABLE OBJECT) ((SELF PATTERN-VARIABLE) (TYPED? BOOLEAN)))"
     (CL:FUNCTION GENERATE-ONE-VARIABLE) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-VARIABLES"
     "(DEFUN (GENERATE-VARIABLES CONS) ((VECTOR VECTOR) (TYPED? BOOLEAN)))"
     (CL:FUNCTION GENERATE-VARIABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-STELLA-COLLECTION"
     "(DEFUN (GENERATE-STELLA-COLLECTION CONS) ((SELF COLLECTION)))"
     (CL:FUNCTION GENERATE-STELLA-COLLECTION) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-DESCRIPTION"
     "(DEFUN (GENERATE-DESCRIPTION OBJECT) ((SELF DESCRIPTION)))"
     (CL:FUNCTION GENERATE-DESCRIPTION) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-ARGUMENTS"
     "(DEFUN (GENERATE-ARGUMENTS CONS) ((ARGUMENTS VECTOR)))"
     (CL:FUNCTION GENERATE-ARGUMENTS) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-OPERATOR"
     "(DEFUN (GENERATE-OPERATOR SYMBOL) ((SELF PROPOSITION)))"
     (CL:FUNCTION GENERATE-OPERATOR) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-PROPOSITION"
     "(DEFUN (GENERATE-PROPOSITION OBJECT) ((SELF PROPOSITION)))"
     (CL:FUNCTION GENERATE-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-FUNCTION-AS-TERM"
     "(DEFUN (GENERATE-FUNCTION-AS-TERM CONS) ((SELF PROPOSITION)))"
     (CL:FUNCTION GENERATE-FUNCTION-AS-TERM) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-SKOLEM"
     "(DEFUN (GENERATE-SKOLEM OBJECT) ((SELF SKOLEM)))"
     (CL:FUNCTION GENERATE-SKOLEM) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (GENERATE-SPECIALIZED-TERM OBJECT) ((SELF LOGIC-THING)) :PUBLIC? TRUE :DOCUMENTATION \"Method to generate a specialized term for `self'.  This is designed
to allow for extension of the term generation code to cover other
types of objects for the logic.  This particular method will signal
an error unless there is a surrogate-value-inverse link set.\")"
     (CL:FUNCTION GENERATE-SPECIALIZED-TERM) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-TERM"
     "(DEFUN (GENERATE-TERM OBJECT) ((SELF OBJECT)))"
     (CL:FUNCTION GENERATE-TERM) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-IMPLIES-PROPOSITION"
     "(DEFUN (GENERATE-IMPLIES-PROPOSITION CONS) ((SELF PROPOSITION)))"
     (CL:FUNCTION GENERATE-IMPLIES-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-DESCRIPTION-PROPOSITION"
     "(DEFUN (GENERATE-DESCRIPTION-PROPOSITION CONS) ((SELF DESCRIPTION) (INVERT? BOOLEAN)))"
     (CL:FUNCTION GENERATE-DESCRIPTION-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-DESCRIPTIONS-AS-RULE"
     "(DEFUN (GENERATE-DESCRIPTIONS-AS-RULE CONS) ((HEAD DESCRIPTION) (TAIL DESCRIPTION) (RULE PROPOSITION) (REVERSEPOLARITY? BOOLEAN)))"
     (CL:FUNCTION GENERATE-DESCRIPTIONS-AS-RULE) NULL)
    (DEFINE-FUNCTION-OBJECT "DEOBJECTIFY-TREE"
     "(DEFUN (DEOBJECTIFY-TREE OBJECT) ((SELF OBJECT)) :DOCUMENTATION \"Return a copy of `self' where all logic objects are
replaced by their `generated' parse-tree version.  This is useful to
convert the result of a retrieval query into a regular parse tree.\" :PUBLIC? TRUE)"
     (CL:FUNCTION DEOBJECTIFY-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-GENERATE"
     "(DEFUN STARTUP-GENERATE () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-GENERATE) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-GENERATE-LOGIC-STARTUP-GENERATE)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-GENERATE-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupGenerate") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CANONICALVARIABLENAMEMAPPING* KEY-VALUE-LIST NULL :DOCUMENTATION \"Maps variables to symbols in SYSTEM-DEFINED-ARGUMENT-NAMES.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CANONICALVARIABLECOUNTER* INTEGER NULL :DOCUMENTATION \"Number of the last canonically-mapped variable.\")"))))
