;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; propagate.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-PROPAGATE-LOGIC-DEFERRED-DEFAULT-PROPOSITIONS-INTERNAL NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-EVALUATION-STATE-TABLE NULL)
(CL:DEFVAR KWD-PROPAGATE-POSTED NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-EVALUATION-QUEUE NULL)
(CL:DEFVAR KWD-PROPAGATE-FORWARD NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-BACKWARD-ONLY? NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-FORWARD-ONLY? NULL)
(CL:DEFVAR SGT-PROPAGATE-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SGT-PROPAGATE-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-PROPAGATE-LOGIC-F-COLLECT-FORWARD-CHAINING-RULES-MEMO-TABLE-000 NULL)
(CL:DEFVAR KWD-PROPAGATE-FUNCTION NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-FORWARD-CHAINING-QUEUE NULL)
(CL:DEFVAR KWD-PROPAGATE-ISA NULL)
(CL:DEFVAR KWD-PROPAGATE-PREDICATE NULL)
(CL:DEFVAR SGT-PROPAGATE-LOGIC-SKOLEM NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-HYPOTHESIZED-INSTANCE? NULL)
(CL:DEFVAR KWD-PROPAGATE-PROPAGATE NULL)
(CL:DEFVAR SGT-PROPAGATE-PL-KERNEL-KB-AND NULL)
(CL:DEFVAR KWD-PROPAGATE-GOAL-TREE NULL)
(CL:DEFVAR KWD-PROPAGATE-SINGLETONS? NULL)
(CL:DEFVAR SGT-PROPAGATE-LOGIC-PROPOSITION NULL)
(CL:DEFVAR KWD-PROPAGATE-KB-UPDATE NULL)
(CL:DEFVAR KWD-PROPAGATE-META-KB-UPDATE NULL)
(CL:DEFVAR KWD-PROPAGATE-META NULL)
(CL:DEFVAR SGT-PROPAGATE-STELLA-MODULE NULL)
(CL:DEFVAR SGT-PROPAGATE-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-PROPAGATE-STELLA-SYMBOL NULL)
(CL:DEFVAR KWD-PROPAGATE-EVALUATED NULL)
(CL:DEFVAR KWD-PROPAGATE-AND NULL)
(CL:DEFVAR KWD-PROPAGATE-OR NULL)
(CL:DEFVAR KWD-PROPAGATE-NOT NULL)
(CL:DEFVAR KWD-PROPAGATE-EQUIVALENT NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-ELABORATED-IN-WORLDS NULL)
(CL:DEFVAR KWD-PROPAGATE-ELABORATE NULL)
(CL:DEFVAR KWD-PROPAGATE-EXTENSIONAL-ASSERTION NULL)
(CL:DEFVAR SGT-PROPAGATE-PL-KERNEL-KB-INEQUALITY NULL)
(CL:DEFVAR SGT-PROPAGATE-STELLA-SURROGATE NULL)
(CL:DEFVAR KWD-PROPAGATE-EXISTS NULL)
(CL:DEFVAR KWD-PROPAGATE-FORALL NULL)
(CL:DEFVAR SGT-PROPAGATE-STELLA-LITERAL-WRAPPER NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-PROPAGATE-STELLA-SLOT NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-ALL-FACTS-OF NULL)
(CL:DEFVAR KWD-PROPAGATE-COMMON-LISP NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-CALL-ALL-FACTS-OF NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-RETRACT-FACTS-OF NULL)
(CL:DEFVAR SGT-PROPAGATE-PL-KERNEL-KB-PHRASE NULL)
(CL:DEFVAR KWD-PROPAGATE-IMPLIES NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-ALL-SENTENCES-OF NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-ALL-FACTS-OF-N NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-STARTUP-PROPAGATE NULL)
(CL:DEFVAR SYM-PROPAGATE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* STANDARD-ERROR NIL-LIST
  DEFAULT-FALSE-TRUTH-VALUE *INVISIBLEASSERTION?* *MODULE*
  *TRACED-KEYWORDS* DEFAULT-TRUE-TRUTH-VALUE STANDARD-OUTPUT EOL
  NULL-INTEGER *COLLECTFORWARDPROPOSITIONS* *MEMOIZATION-ENABLED?*
  MEMOIZED-NULL-VALUE TRUE-WRAPPER FALSE-WRAPPER *CONTEXT* NIL))

;;; (DEFSPECIAL *FILLINGCONSTRAINTPROPAGATIONQUEUES?* ...)

(CL:DEFVAR *FILLINGCONSTRAINTPROPAGATIONQUEUES?* CL:NIL
  "True if we are inside of 'react-to-kb-update'.")

;;; (DEFSPECIAL *DEFERINGDEFAULTFORWARDINFERENCES?* ...)

(CL:DEFVAR *DEFERINGDEFAULTFORWARDINFERENCES?* CL:NIL
  "True if we are propagating strict inferences, and
posting derived default propositions to temporary queues.")

;;; (DEFUN (DEFERRED-DEFAULT-PROPOSITIONS (CONS OF PROPOSITION)) ...)

(CL:DEFUN DEFERRED-DEFAULT-PROPOSITIONS (SELF)
  (CL:LET*
   ((VALUE
     (DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS SELF)
      SYM-PROPAGATE-LOGIC-DEFERRED-DEFAULT-PROPOSITIONS-INTERNAL
      NULL)))
   (CL:IF (CL:EQ VALUE NULL) NIL VALUE)))

;;; (DEFUN DEFERRED-DEFAULT-PROPOSITIONS-SETTER ...)

(CL:DEFUN DEFERRED-DEFAULT-PROPOSITIONS-SETTER (SELF NEWVALUE)
  (SET-DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS SELF)
   SYM-PROPAGATE-LOGIC-DEFERRED-DEFAULT-PROPOSITIONS-INTERNAL NEWVALUE
   NULL))

;;; (DEFUN (EVALUATION-STATE KEYWORD) ...)

(CL:DEFUN EVALUATION-STATE (PROPOSITION)
  (CL:LET*
   ((TABLE
     (DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
      SYM-PROPAGATE-LOGIC-EVALUATION-STATE-TABLE NULL)))
   (CL:WHEN (CL:EQ TABLE NULL) (CL:RETURN-FROM EVALUATION-STATE NULL))
   (LOOKUP TABLE PROPOSITION)))

;;; (DEFUN EVALUATION-STATE-SETTER ...)

(CL:DEFUN EVALUATION-STATE-SETTER (PROPOSITION STATE)
  (CL:LET*
   ((TABLE
     (DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
      SYM-PROPAGATE-LOGIC-EVALUATION-STATE-TABLE NULL)))
   (CL:WHEN (CL:EQ TABLE NULL)
    (CL:RETURN-FROM EVALUATION-STATE-SETTER))
   (INSERT-AT TABLE PROPOSITION STATE)))

;;; (DEFUN POST-FOR-EVALUATION ...)

(CL:DEFUN POST-FOR-EVALUATION (SELF)
  (CL:WHEN (CL:NOT *FILLINGCONSTRAINTPROPAGATIONQUEUES?*)
   (EVALUATE-PROPOSITION SELF) (CL:RETURN-FROM POST-FOR-EVALUATION))
  (CL:WHEN (CL:EQ (EVALUATION-STATE SELF) KWD-PROPAGATE-POSTED)
   (CL:RETURN-FROM POST-FOR-EVALUATION))
  (INSERT
   (DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
    SYM-PROPAGATE-LOGIC-EVALUATION-QUEUE NULL)
   SELF)
  (EVALUATION-STATE-SETTER SELF KWD-PROPAGATE-POSTED))

;;; (DEFSPECIAL *CURRENTLYEXECUTINGFORWARDCHAININGQUEUE* ...)

(CL:DEFVAR *CURRENTLYEXECUTINGFORWARDCHAININGQUEUE* NULL
  "Points to an active queue of propositions that will trigger
forward inference.  New queue entries are posted to a separate queue
attached to *context*.")

;;; (DEFUN (HELP-COLLECT-FORWARD-RULES (CONS OF KEY-VALUE-LIST)) ...)

(CL:DEFUN HELP-COLLECT-FORWARD-RULES (DESCRIPTION RULES INDICES TOUCHEDDEFAULT? BEENTHERE)
  (CL:WHEN (CL:EQ RULES NULL) (CL:SETQ RULES (NEW-KEY-VALUE-LIST)))
  (CL:WHEN (CL:EQ INDICES NULL) (CL:SETQ INDICES (NEW-KEY-VALUE-LIST)))
  (CL:WHEN (CL:EQ BEENTHERE NULL) (CL:SETQ BEENTHERE (NEW-LIST)))
  (INSERT BEENTHERE DESCRIPTION)
  (CL:LET*
   ((INDEX NULL)
    (ITER-000
     (%LIST.THE-CONS-LIST (FORWARD-CHAINING-INDICES DESCRIPTION))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ INDEX (%%VALUE ITER-000))
    (CL:WHEN
     (CL:AND
      (CL:NOT (DELETED? (%FORWARD-CHAINING-INDEX.MASTER-RULE INDEX)))
      (TRUE? (%FORWARD-CHAINING-INDEX.MASTER-RULE INDEX)))
     (INSERT-AT INDICES INDEX
      (CL:IF TOUCHEDDEFAULT? TRUE-WRAPPER FALSE-WRAPPER)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:LET*
   ((P NULL)
    (ITER-001
     (APPLICABLE-RULES-OF-DESCRIPTION DESCRIPTION KWD-PROPAGATE-FORWARD
      CL:T)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:SETQ P (%%VALUE ITER-001))
    (CL:WHEN
     (CL:NOT
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS P)
        SYM-PROPAGATE-LOGIC-BACKWARD-ONLY? FALSE-WRAPPER)))
     (CL:LET*
      ((CONSEQUENT
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
         1)))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE CONSEQUENT)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000
          SGT-PROPAGATE-LOGIC-NAMED-DESCRIPTION)
         (CL:PROGN
          (CL:LET* ((SUPER (VALUE-OF CONSEQUENT)))
           (CL:WHEN (DEFAULT-TRUE? P) (CL:SETQ TOUCHEDDEFAULT? CL:T))
           (CL:WHEN
            (CL:OR
             (%BOOLEAN-WRAPPER.WRAPPER-VALUE
              (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS P)
               SYM-PROPAGATE-LOGIC-FORWARD-ONLY? FALSE-WRAPPER))
             (CL:NOT (CL:EQ (CLASS? DESCRIPTION) (CLASS? SUPER))))
            (INSERT-AT RULES P
             (CL:IF TOUCHEDDEFAULT? TRUE-WRAPPER FALSE-WRAPPER)))
           (CL:WHEN (CL:NOT (MEMBER? BEENTHERE SUPER))
            (HELP-COLLECT-FORWARD-RULES SUPER RULES INDICES
             TOUCHEDDEFAULT? BEENTHERE)))))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-DESCRIPTION)
         (CL:PROGN
          (INSERT-AT RULES P
           (CL:IF TOUCHEDDEFAULT? TRUE-WRAPPER FALSE-WRAPPER))))
        (CL:T)))))
    (CL:SETQ ITER-001 (%%REST ITER-001))))
  (CONS RULES (CONS INDICES NIL)))

;;; (DEFUN (COLLECT-FORWARD-CHAINING-RULES (KEY-VALUE-LIST OF PROPOSITION BOOLEAN-WRAPPER) (KEY-VALUE-LIST OF FORWARD-CHAINING-INDEX BOOLEAN-WRAPPER)) ...)

(CL:DEFUN COLLECT-FORWARD-CHAINING-RULES (DESCRIPTION)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
    (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE.SURROGATE-VALUE
      SGT-PROPAGATE-LOGIC-F-COLLECT-FORWARD-CHAINING-RULES-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-PROPAGATE-LOGIC-F-COLLECT-FORWARD-CHAINING-RULES-MEMO-TABLE-000
      "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE.SURROGATE-VALUE
       SGT-PROPAGATE-LOGIC-F-COLLECT-FORWARD-CHAINING-RULES-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 DESCRIPTION *CONTEXT*
      MEMOIZED-NULL-VALUE NULL -1))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (HELP-COLLECT-FORWARD-RULES DESCRIPTION NULL NULL CL:NIL NULL))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((RULES MEMOIZED-VALUE-000))
    (CL:VALUES (%%VALUE RULES) (%%VALUE (%%REST RULES))))))

;;; (DEFUN (HAS-FORWARD-CHAINING-RULES? BOOLEAN) ...)

(CL:DEFUN HAS-FORWARD-CHAINING-RULES? (DESCRIPTION PROPOSITION)
  (CL:WHEN (FALSE? PROPOSITION)
   (CL:SETQ DESCRIPTION
    (GET-INFERABLE-COMPLEMENT-DESCRIPTION DESCRIPTION))
   (CL:WHEN (CL:EQ DESCRIPTION NULL)
    (CL:RETURN-FROM HAS-FORWARD-CHAINING-RULES? CL:NIL)))
  (CL:LET* ((RULES NULL) (INDICES NULL))
   (CL:MULTIPLE-VALUE-SETQ (RULES INDICES)
    (COLLECT-FORWARD-CHAINING-RULES DESCRIPTION))
   (CL:OR (NON-EMPTY? RULES) (NON-EMPTY? INDICES))))

;;; (DEFUN POST-TO-FORWARD-CHAINING-QUEUE ...)

(CL:DEFUN POST-TO-FORWARD-CHAINING-QUEUE (SELF WORLD)
  (CL:WHEN
   (CL:AND (UNKNOWN? SELF)
    (CL:NOT (CL:EQ (%PROPOSITION.KIND SELF) KWD-PROPAGATE-FUNCTION)))
   (CL:RETURN-FROM POST-TO-FORWARD-CHAINING-QUEUE))
  (CL:LET*
   ((FORWARDCHAININGQUEUE
     (DYNAMIC-SLOT-VALUE (%WORLD.DYNAMIC-SLOTS WORLD)
      SYM-PROPAGATE-LOGIC-FORWARD-CHAINING-QUEUE NULL)))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-ISA)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-FUNCTION))
      (CL:LET* ((FOUND?-000 CL:NIL))
       (CL:LET*
        ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
         (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ ARG
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:WHEN
          (CL:AND (ISA? ARG SGT-PROPAGATE-LOGIC-SKOLEM)
           (CL:EQ (%SKOLEM.DEFINING-PROPOSITION ARG) NULL)
           (CL:NOT
            (%BOOLEAN-WRAPPER.WRAPPER-VALUE
             (DYNAMIC-SLOT-VALUE (%SKOLEM.DYNAMIC-SLOTS ARG)
              SYM-PROPAGATE-LOGIC-HYPOTHESIZED-INSTANCE?
              FALSE-WRAPPER))))
          (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
       (CL:WHEN FOUND?-000
        (CL:WHEN (CL:NOT (CL:EQ *COLLECTFORWARDPROPOSITIONS* NULL))
         (CL:RETURN-FROM POST-TO-FORWARD-CHAINING-QUEUE))))
      (CL:LET*
       ((DESCRIPTION (GET-DESCRIPTION (%PROPOSITION.OPERATOR SELF))))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ DESCRIPTION NULL))
         (HAS-FORWARD-CHAINING-RULES? DESCRIPTION SELF))
        (PUSH FORWARDCHAININGQUEUE SELF))))
     (CL:T)))))

;;; (DEFSPECIAL *COLLECTFORWARDPROPOSITIONS* ...)

(CL:DEFVAR *COLLECTFORWARDPROPOSITIONS* NULL
  "Collect goes-true propositions produced by forward
chaining.")

;;; (DEFUN APPLY-RULE-CONSEQUENT-TO-VECTOR ...)

(CL:DEFUN APPLY-RULE-CONSEQUENT-TO-VECTOR (CONSEQUENT ARGUMENTS RULE TRIGGERDESCRIPTION TRIGGERPROPOSITION TOUCHEDDEFAULT?)
  (CL:LET* ((*COLLECTFORWARDPROPOSITIONS* NIL))
   (CL:DECLARE (CL:SPECIAL *COLLECTFORWARDPROPOSITIONS*))
   (CL:LET*
    ((TOUCHEDDEFAULTKNOWLEDGE?
      (CL:OR (DEFAULT-TRUE? TRIGGERPROPOSITION) (DEFAULT-TRUE? RULE)
       TOUCHEDDEFAULT?)))
    (CL:LET*
     ((*QUERYITERATOR* NULL)
      (*DONT-CHECK-FOR-DUPLICATE-PROPOSITIONS?* CL:NIL))
     (CL:DECLARE
      (CL:SPECIAL *QUERYITERATOR*
       *DONT-CHECK-FOR-DUPLICATE-PROPOSITIONS?*))
     (INHERIT-DESCRIPTION ARGUMENTS CONSEQUENT
      TOUCHEDDEFAULTKNOWLEDGE?)))
   (CL:WHEN (TRACE-KEYWORD? KWD-PROPAGATE-PROPAGATE)
    (TRACE-FORWARD-RULE RULE TRIGGERPROPOSITION
     *COLLECTFORWARDPROPOSITIONS*))
   (CL:LET* ((P NULL) (ITER-000 *COLLECTFORWARDPROPOSITIONS*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ P (%%VALUE ITER-000))
     (RECORD-FORWARD-GOAL RULE ARGUMENTS P)
     (RECORD-FORWARD-JUSTIFICATION P RULE
      (CONS-LIST TRIGGERPROPOSITION))
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

;;; (DEFUN TRACE-FORWARD-RULE ...)

(CL:DEFUN TRACE-FORWARD-RULE (RULE TRIGGER CONSEQUENTS)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ CONSEQUENTS NULL))
    (CL:NOT (CL:EQ CONSEQUENTS NIL)))
   (CL:LET* ((INDENT 11)) (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "RUNNING FORWARD RULE:" EOL "  TRIGGER: ")
    (PRINT-FORMULA TRIGGER INDENT)
    (CL:WHEN (FALSE? TRIGGER)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      ")"))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
     "  RULE:    ")
    (PRINT-FORMULA RULE INDENT)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
     "  RESULT:  ")
    (CL:WHEN (CL:NOT (CL:EQ (%%REST CONSEQUENTS) NIL))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "("
      (STRINGIFIED-SURROGATE SGT-PROPAGATE-PL-KERNEL-KB-AND) " ")
     (CL:SETQ INDENT (CL:+ INDENT 5)))
    (CL:LET*
     ((C NULL) (ITER-000 CONSEQUENTS) (I NULL-INTEGER) (ITER-001 1))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ C (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
      (CL:WHEN (CL:> I 1)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        EOL)
       (CL:LET*
        ((I NULL-INTEGER) (ITER-002 1) (UPPER-BOUND-000 INDENT)
         (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-000))
        (CL:LOOP WHILE
         (CL:OR UNBOUNDED?-000 (CL:<= ITER-002 UPPER-BOUND-000)) DO
         (CL:SETQ I ITER-002) (CL:SETQ I I)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          " ")
         (CL:SETQ ITER-002 (CL:1+ ITER-002)))))
      (PRINT-FORMULA C INDENT) (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (CL:1+ ITER-001))))
    (CL:WHEN (CL:NOT (CL:EQ (%%REST CONSEQUENTS) NIL))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      ")")
     (CL:SETQ INDENT (CL:- INDENT 5)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     EOL))))

;;; (DEFUN APPLY-FORWARD-RULES-TO-VECTOR ...)

(CL:DEFUN APPLY-FORWARD-RULES-TO-VECTOR (TRIGGERDESCRIPTION ARGUMENTS TRIGGERPROPOSITION)
  (CL:LET* ((EVALUATEDARGS ARGUMENTS))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:COND
      ((DELETED? ARG) (CL:RETURN-FROM APPLY-FORWARD-RULES-TO-VECTOR))
      ((CL:NOT (EQL? ARG (VALUE-OF ARG)))
       (CL:WHEN (CL:EQ ARGUMENTS EVALUATEDARGS)
        (CL:SETQ EVALUATEDARGS (COPY ARGUMENTS)))
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY EVALUATEDARGS))
         (VALUE (VALUE-OF ARG)) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETQ ARGUMENTS EVALUATEDARGS))
  (CL:LET* ((RULES NULL) (INDICES NULL))
   (CL:MULTIPLE-VALUE-SETQ (RULES INDICES)
    (COLLECT-FORWARD-CHAINING-RULES TRIGGERDESCRIPTION))
   (CL:LET*
    ((R NULL) (TOUCHEDDEFAULT? NULL)
     (ITER-001 (%KEY-VALUE-LIST.THE-KV-LIST RULES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NULL)) DO
     (CL:SETQ R (%KV-CONS.KEY ITER-001))
     (CL:SETQ TOUCHEDDEFAULT? (%KV-CONS.VALUE ITER-001))
     (CL:WHEN (APPLICABLE-FORWARD-RULE? R ARGUMENTS)
      (APPLY-RULE-CONSEQUENT-TO-VECTOR
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS R)))
        1)
       ARGUMENTS R TRIGGERDESCRIPTION TRIGGERPROPOSITION
       (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN TOUCHEDDEFAULT?)))
     (CL:SETQ ITER-001 (%KV-CONS.REST ITER-001))))
   (CL:LET*
    ((FWDINDEX NULL) (TOUCHEDDEFAULT? NULL)
     (ITER-002 (%KEY-VALUE-LIST.THE-KV-LIST INDICES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NULL)) DO
     (CL:SETQ FWDINDEX (%KV-CONS.KEY ITER-002))
     (CL:SETQ TOUCHEDDEFAULT? (%KV-CONS.VALUE ITER-002))
     (CL:TAGBODY
      (CL:LET* ((INPUTARGS NIL))
       (CL:WHEN
        (CL:NOT
         (CL:= (LENGTH ARGUMENTS)
          (LENGTH
           (%PROPOSITION.ARGUMENTS
            (%FORWARD-CHAINING-INDEX.FORWARD-GOAL FWDINDEX)))))
        (CL:GO :CONTINUE))
       (CL:LET*
        ((ARG NULL) (VECTOR-001 ARGUMENTS) (INDEX-001 0)
         (LENGTH-001 (LENGTH VECTOR-001)) (GOALARG NULL)
         (VECTOR-002
          (%PROPOSITION.ARGUMENTS
           (%FORWARD-CHAINING-INDEX.FORWARD-GOAL FWDINDEX)))
         (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)))
        (CL:DECLARE
         (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 INDEX-002 LENGTH-002))
        (CL:LOOP WHILE
         (CL:AND (CL:< INDEX-001 LENGTH-001)
          (CL:< INDEX-002 LENGTH-002))
         DO
         (CL:SETQ ARG
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
           INDEX-001))
         (CL:SETQ GOALARG
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
           INDEX-002))
         (CL:COND
          ((VARIABLE? GOALARG)
           (CL:SETQ INPUTARGS (CONS ARG INPUTARGS)))
          ((CL:NOT (EQL? ARG (VALUE-OF GOALARG)))
           (CL:SETQ INPUTARGS NULL) (CL:RETURN)))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
         (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
       (CL:WHEN (CL:EQ INPUTARGS NULL) (CL:GO :CONTINUE))
       (CL:LET*
        ((IT
          (ALLOCATE-ITERATOR
           (%FORWARD-CHAINING-INDEX.INPUT-BINDINGS FWDINDEX)))
         (ARG NULL) (ITER-003 (REVERSE INPUTARGS)))
        (CL:LOOP WHILE
         (CL:AND (NEXT? IT) (CL:NOT (CL:EQ ITER-003 NIL))) DO
         (CL:SETQ ARG (%%VALUE ITER-003)) (CL:PROGN)
         (VALUE-SETTER IT ARG) (CL:SETQ ITER-003 (%%REST ITER-003)))))
      (CL:LET*
       ((OUTPUTBINDINGS NULL) (TRUTHVALUES NULL)
        (TRACEFORWARDINFERENCE?
         (TRACE-KEYWORD? KWD-PROPAGATE-PROPAGATE))
        (TRACEGOALTREE?
         (CL:AND TRACEFORWARDINFERENCE?
          (TRACE-KEYWORD? KWD-PROPAGATE-GOAL-TREE)))
        (OLDTRACEKEYWORDS *TRACED-KEYWORDS*))
       (CL:COND
        (TRACEFORWARDINFERENCE?
         (CL:WHEN TRACEGOALTREE?
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
           "Proving forward goal: "
           (%FORWARD-CHAINING-INDEX.QUERY-BODY FWDINDEX) EOL)))
        ((TRACE-KEYWORD? KWD-PROPAGATE-GOAL-TREE)
         (CL:SETQ *TRACED-KEYWORDS*
          (REMOVE (COPY *TRACED-KEYWORDS*) KWD-PROPAGATE-GOAL-TREE))))
       (CL:MULTIPLE-VALUE-SETQ (OUTPUTBINDINGS TRUTHVALUES)
        (APPLY-CACHED-RETRIEVE
         (%FORWARD-CHAINING-INDEX.IO-VARIABLES FWDINDEX)
         (%FORWARD-CHAINING-INDEX.QUERY-BODY FWDINDEX)
         (%FORWARD-CHAINING-INDEX.INPUT-BINDINGS FWDINDEX)
         (CONS-LIST KWD-PROPAGATE-SINGLETONS? TRUE-WRAPPER)
         (%FORWARD-CHAINING-INDEX.CACHE-ID FWDINDEX)))
       (CL:WHEN TRACEGOALTREE?
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "Done proving forward goal: "
         (%FORWARD-CHAINING-INDEX.QUERY-BODY FWDINDEX) EOL EOL))
       (CL:SETQ *TRACED-KEYWORDS* OLDTRACEKEYWORDS)
       (CL:LET*
        ((OB NULL) (ITER-004 OUTPUTBINDINGS) (TV NULL)
         (ITER-005 TRUTHVALUES))
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ ITER-004 NIL))
          (CL:NOT (CL:EQ ITER-005 NIL)))
         DO (CL:SETQ OB (%%VALUE ITER-004))
         (CL:SETQ TV (%%VALUE ITER-005))
         (APPLY-RULE-CONSEQUENT-TO-VECTOR
          (%FORWARD-CHAINING-INDEX.CONSEQUENT FWDINDEX)
          (COPY-LIST-TO-ARGUMENTS-VECTOR (LISTIFY OB))
          (%FORWARD-CHAINING-INDEX.MASTER-RULE FWDINDEX)
          TRIGGERDESCRIPTION TRIGGERPROPOSITION
          (CL:OR (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN TOUCHEDDEFAULT?)
           (CL:EQ TV DEFAULT-TRUE-TRUTH-VALUE)))
         (CL:SETQ ITER-004 (%%REST ITER-004))
         (CL:SETQ ITER-005 (%%REST ITER-005)))))
      :CONTINUE)
     (CL:SETQ ITER-002 (%KV-CONS.REST ITER-002))))))

;;; (DEFUN (APPLICABLE-FORWARD-RULE? BOOLEAN) ...)

(CL:DEFUN APPLICABLE-FORWARD-RULE? (RULE ARGUMENTS)
  (CL:LET*
   ((ANTECEDENTDESCRIPTION
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS RULE)))
      0)))
   (CL:AND (TRUE? RULE)
    (CL:= (LENGTH ARGUMENTS)
     (LENGTH (%DESCRIPTION.IO-VARIABLES ANTECEDENTDESCRIPTION))))))

;;; (DEFMETHOD REACT-TO-INFERENCE-UPDATE ...)

(CL:DEFMETHOD REACT-TO-INFERENCE-UPDATE ((SELF SKOLEM))
  (CL:LET* ((DERIVEDVALUE (VALUE-OF SELF)) (ASSERTEDVALUE NULL))
   (CL:LET*
    ((*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:SETQ ASSERTEDVALUE (VALUE-OF SELF)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ ASSERTEDVALUE NULL))
     (CL:NOT (EQL? ASSERTEDVALUE DERIVEDVALUE)))
    (EQUATE-VALUES (VALUE-OF ASSERTEDVALUE) DERIVEDVALUE))
   (CL:LET*
    ((PROP NULL)
     (ITER-000
      (ALLOCATE-ITERATOR
       (UNFILTERED-DEPENDENT-PROPOSITIONS SELF NULL))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ PROP (%ITERATOR.VALUE ITER-000))
     (POST-FOR-EVALUATION PROP)))
   (CL:WHEN *FILLINGCONSTRAINTPROPAGATIONQUEUES?*
    (CL:LET*
     ((DEFININGPROPOSITION (%SKOLEM.DEFINING-PROPOSITION SELF)))
     (CL:WHEN (CL:NOT (CL:EQ DEFININGPROPOSITION NULL))
      (POST-TO-FORWARD-CHAINING-QUEUE DEFININGPROPOSITION *CONTEXT*))))))

;;; (DEFMETHOD REACT-TO-INFERENCE-UPDATE ...)

(CL:DEFMETHOD REACT-TO-INFERENCE-UPDATE ((SELF PROPOSITION))
  (CL:LET*
   ((PARENTTRUTHVALUE
     (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE SELF)
      (%PROPOSITION.HOME-CONTEXT SELF) CL:NIL)))
   (CL:WHEN
    (CL:AND
     (CL:NOT
      (CL:EQ PARENTTRUTHVALUE
       (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE SELF)
        (%PROPOSITION.HOME-CONTEXT SELF) CL:NIL)))
     (CL:NOT (CL:EQ PARENTTRUTHVALUE NULL)))
    (SIGNAL-TRUTH-VALUE-CLASH SELF))
   (POST-FOR-EVALUATION SELF)
   (CL:LET*
    ((PROP NULL)
     (ITER-000
      (ALLOCATE-ITERATOR (%PROPOSITION.DEPENDENT-PROPOSITIONS SELF))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ PROP (%ITERATOR.VALUE ITER-000))
     (POST-FOR-EVALUATION PROP)))
   (CL:WHEN *FILLINGCONSTRAINTPROPAGATIONQUEUES?*
    (POST-TO-FORWARD-CHAINING-QUEUE SELF *CONTEXT*))))

;;; (DEFUN REACT-TO-KB-UPDATE ...)

(CL:DEFUN REACT-TO-KB-UPDATE (CONTEXT OBJECT)
  (CL:LET*
   ((SKOLEM? CL:NIL) (PROPOSITION? CL:NIL) (METAPROPOSITION? CL:NIL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OBJECT)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-SKOLEM)
      (CL:PROGN (CL:SETQ SKOLEM? CL:T)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-PROPOSITION)
      (CL:PROGN (CL:SETQ PROPOSITION? CL:T)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:WHEN (CL:AND PROPOSITION? (META-PROPOSITION? OBJECT))
    (CL:SETQ METAPROPOSITION? CL:T))
   (BUMP-MEMOIZATION-TIMESTAMP KWD-PROPAGATE-KB-UPDATE)
   (CL:WHEN METAPROPOSITION?
    (BUMP-MEMOIZATION-TIMESTAMP KWD-PROPAGATE-META-KB-UPDATE))
   (CL:COND (*INVISIBLEASSERTION?* (CL:RETURN-FROM REACT-TO-KB-UPDATE))
    ((DESCRIPTION-MODE?)
     (CL:LET* ((*FILLINGCONSTRAINTPROPAGATIONQUEUES?* CL:NIL))
      (CL:DECLARE (CL:SPECIAL *FILLINGCONSTRAINTPROPAGATIONQUEUES?*))
      (CL:COND (PROPOSITION? (REACT-TO-INFERENCE-UPDATE OBJECT))
       (SKOLEM? (REACT-TO-INFERENCE-UPDATE OBJECT))))
     (CL:RETURN-FROM REACT-TO-KB-UPDATE))
    (*FILLINGCONSTRAINTPROPAGATIONQUEUES?*
     (CL:COND (PROPOSITION? (REACT-TO-INFERENCE-UPDATE OBJECT))
      (SKOLEM? (REACT-TO-INFERENCE-UPDATE OBJECT)))
     (CL:RETURN-FROM REACT-TO-KB-UPDATE)))
   (CL:LET*
    ((WORLD
      (CL:IF METAPROPOSITION?
       (LOOKUP-INFERENCE-CACHE CONTEXT KWD-PROPAGATE-META)
       (LOOKUP-CONSTRAINT-PROPAGATION-WORLD CONTEXT))))
    (CL:WHEN (CL:NOT (CL:EQ WORLD NULL))
     (CL:LET*
      ((*CONTEXT* WORLD) (*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)))
      (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
      (INITIALIZE-CONSTRAINT-PROPAGATION-QUEUES WORLD)
      (CL:LET* ((*FILLINGCONSTRAINTPROPAGATIONQUEUES?* CL:T))
       (CL:DECLARE (CL:SPECIAL *FILLINGCONSTRAINTPROPAGATIONQUEUES?*))
       (CL:COND (PROPOSITION? (REACT-TO-INFERENCE-UPDATE OBJECT))
        (SKOLEM? (REACT-TO-INFERENCE-UPDATE OBJECT)))
       (EXECUTE-CONSTRAINT-PROPAGATION-QUEUES)))))
   (CL:WHEN (ISA? CONTEXT SGT-PROPAGATE-STELLA-MODULE)
    (CL:LET*
     ((CHILD NULL)
      (ITER-000
       (%LIST.THE-CONS-LIST (%CONTEXT.CHILD-CONTEXTS CONTEXT))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ CHILD (%%VALUE ITER-000))
      (CL:WHEN (ISA? CHILD SGT-PROPAGATE-STELLA-MODULE)
       (REACT-TO-KB-UPDATE CHILD OBJECT))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))))

;;; (DEFUN INITIALIZE-CONSTRAINT-PROPAGATION-QUEUES ...)

(CL:DEFUN INITIALIZE-CONSTRAINT-PROPAGATION-QUEUES (WORLD)
  (SET-DYNAMIC-SLOT-VALUE (%WORLD.DYNAMIC-SLOTS WORLD)
   SYM-PROPAGATE-LOGIC-EVALUATION-QUEUE (NEW-LIST) NULL)
  (SET-DYNAMIC-SLOT-VALUE (%WORLD.DYNAMIC-SLOTS WORLD)
   SYM-PROPAGATE-LOGIC-FORWARD-CHAINING-QUEUE (NEW-LIST) NULL))

;;; (DEFUN EXECUTE-CONSTRAINT-PROPAGATION-QUEUES ...)

(CL:DEFUN EXECUTE-CONSTRAINT-PROPAGATION-QUEUES ()
  (CL:LET* ((*INHIBITOBJECTFINALIZATION?* CL:T))
   (CL:DECLARE (CL:SPECIAL *INHIBITOBJECTFINALIZATION?*))
   (CL:LOOP
    (CL:LET*
     ((QUEUE
       (DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
        SYM-PROPAGATE-LOGIC-EVALUATION-QUEUE NULL)))
     (SET-DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
      SYM-PROPAGATE-LOGIC-EVALUATION-QUEUE (NEW-LIST) NULL)
     (CL:LET* ((P NULL) (ITER-000 (%LIST.THE-CONS-LIST QUEUE)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ P (%%VALUE ITER-000)) (EVALUATE-PROPOSITION P)
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    (CL:LET*
     ((QUEUE
       (DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
        SYM-PROPAGATE-LOGIC-FORWARD-CHAINING-QUEUE NULL)))
     (SET-DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
      SYM-PROPAGATE-LOGIC-FORWARD-CHAINING-QUEUE (NEW-LIST) NULL)
     (CL:LET*
      ((PROPOSITION NULL) (ITER-001 (%LIST.THE-CONS-LIST QUEUE)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ PROPOSITION (%%VALUE ITER-001)) (CL:PROGN)
       (CL:LET*
        ((DESCRIPTION
          (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION))))
        (CL:WHEN (FALSE? PROPOSITION)
         (CL:SETQ DESCRIPTION
          (GET-INFERABLE-COMPLEMENT-DESCRIPTION DESCRIPTION)))
        (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
         (APPLY-FORWARD-RULES-TO-VECTOR DESCRIPTION
          (%PROPOSITION.ARGUMENTS PROPOSITION) PROPOSITION)))
       (CL:SETQ ITER-001 (%%REST ITER-001)))))
    (CL:WHEN
     (CL:AND
      (EMPTY?
       (DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
        SYM-PROPAGATE-LOGIC-EVALUATION-QUEUE NULL))
      (EMPTY?
       (DYNAMIC-SLOT-VALUE (%CONTEXT.DYNAMIC-SLOTS *CONTEXT*)
        SYM-PROPAGATE-LOGIC-FORWARD-CHAINING-QUEUE NULL)))
     (CL:RETURN-FROM EXECUTE-CONSTRAINT-PROPAGATION-QUEUES)))))

;;; (DEFUN EVALUATE-NEW-PROPOSITION ...)

(CL:DEFUN EVALUATE-NEW-PROPOSITION (SELF)
  (CL:WHEN (DESCRIPTION-MODE?)
   (CL:RETURN-FROM EVALUATE-NEW-PROPOSITION))
  (CL:LET* ((WORLD (LOOKUP-CONSTRAINT-PROPAGATION-WORLD *CONTEXT*)))
   (CL:WHEN (CL:NOT (CL:EQ WORLD NULL))
    (CL:LET* ((*CONTEXT* WORLD)) (CL:DECLARE (CL:SPECIAL *CONTEXT*))
     (EVALUATE-PROPOSITION SELF)
     (CL:WHEN (CL:NOT (UNKNOWN? SELF))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
        (MEMB? *TRACED-KEYWORDS* KWD-PROPAGATE-PROPAGATE))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "evaluate-new-proposition:  " SELF EOL))
      (CL:LET*
       ((PROP NULL)
        (ITER-000
         (ALLOCATE-ITERATOR
          (%PROPOSITION.DEPENDENT-PROPOSITIONS SELF))))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ PROP (%ITERATOR.VALUE ITER-000))
        (EVALUATE-PROPOSITION PROP))))))))

;;; (DEFUN EVALUATE-AND-PROPOSITION ...)

(CL:DEFUN EVALUATE-AND-PROPOSITION (SELF)
  (CL:LET* ((ARGUMENTS (%PROPOSITION.ARGUMENTS SELF)))
   (CL:COND
    ((TRUE? SELF)
     (CL:LET*
      ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (ASSIGN-TRUTH-VALUE ARG
        (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE SELF)
         (%PROPOSITION.HOME-CONTEXT SELF) CL:NIL))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
    ((FALSE? SELF)
     (CL:LET*
      ((ONLYUNBOUNDARG NULL) (TOUCHEDDEFAULT? (DEFAULT-FALSE? SELF)))
      (CL:LET*
       ((ARG NULL) (VECTOR-001 ARGUMENTS) (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:COND
         ((FALSE? ARG) (CL:RETURN-FROM EVALUATE-AND-PROPOSITION))
         ((UNKNOWN? ARG)
          (CL:WHEN (CL:NOT (CL:EQ ONLYUNBOUNDARG NULL))
           (CL:RETURN-FROM EVALUATE-AND-PROPOSITION))
          (CL:SETQ ONLYUNBOUNDARG ARG))
         ((DEFAULT-TRUE? ARG) (CL:SETQ TOUCHEDDEFAULT? CL:T)))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      (CL:IF (CL:NOT (CL:EQ ONLYUNBOUNDARG NULL))
       (ASSIGN-TRUTH-VALUE ONLYUNBOUNDARG
        (DEFAULTIFY-TRUTH-VALUE CL:NIL TOUCHEDDEFAULT?))
       (ASSIGN-TRUTH-VALUE SELF
        (DEFAULTIFY-TRUTH-VALUE CL:T TOUCHEDDEFAULT?)))))
    (CL:T
     (CL:LET* ((UNBOUNDARG? CL:NIL) (TOUCHEDDEFAULT? CL:NIL))
      (CL:LET*
       ((ARG NULL) (VECTOR-002 ARGUMENTS) (INDEX-002 0)
        (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
       (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
          INDEX-002))
        (CL:COND
         ((FALSE? ARG)
          (CL:IF (DEFAULT-FALSE? ARG)
           (ASSIGN-TRUTH-VALUE SELF DEFAULT-FALSE-TRUTH-VALUE)
           (CL:PROGN (ASSIGN-TRUTH-VALUE SELF FALSE-WRAPPER)
            (CL:RETURN-FROM EVALUATE-AND-PROPOSITION))))
         ((UNKNOWN? ARG) (CL:SETQ UNBOUNDARG? CL:T))
         ((DEFAULT-TRUE? ARG) (CL:SETQ TOUCHEDDEFAULT? CL:T)))
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
      (CL:WHEN
       (CL:AND (CL:NOT UNBOUNDARG?) (CL:NOT (DEFAULT-FALSE? SELF)))
       (ASSIGN-TRUTH-VALUE SELF
        (DEFAULTIFY-TRUTH-VALUE CL:T TOUCHEDDEFAULT?))))))))

;;; (DEFUN EVALUATE-OR-PROPOSITION ...)

(CL:DEFUN EVALUATE-OR-PROPOSITION (SELF)
  (CL:LET* ((ARGUMENTS (%PROPOSITION.ARGUMENTS SELF)))
   (CL:COND
    ((FALSE? SELF)
     (CL:LET*
      ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (ASSIGN-TRUTH-VALUE ARG
        (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE SELF)
         (%PROPOSITION.HOME-CONTEXT SELF) CL:NIL))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
    ((TRUE? SELF)
     (CL:LET*
      ((ONLYUNBOUNDARG NULL) (TOUCHEDDEFAULT? (DEFAULT-TRUE? SELF)))
      (CL:LET*
       ((ARG NULL) (VECTOR-001 ARGUMENTS) (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:COND ((TRUE? ARG) (CL:RETURN-FROM EVALUATE-OR-PROPOSITION))
         ((UNKNOWN? ARG)
          (CL:WHEN (CL:NOT (CL:EQ ONLYUNBOUNDARG NULL))
           (CL:RETURN-FROM EVALUATE-OR-PROPOSITION))
          (CL:SETQ ONLYUNBOUNDARG ARG))
         ((DEFAULT-FALSE? ARG) (CL:SETQ TOUCHEDDEFAULT? CL:T)))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      (CL:IF (CL:NOT (CL:EQ ONLYUNBOUNDARG NULL))
       (ASSIGN-TRUTH-VALUE ONLYUNBOUNDARG
        (DEFAULTIFY-TRUTH-VALUE CL:T TOUCHEDDEFAULT?))
       (ASSIGN-TRUTH-VALUE SELF
        (DEFAULTIFY-TRUTH-VALUE CL:NIL TOUCHEDDEFAULT?)))))
    (CL:T
     (CL:LET* ((UNBOUNDARG? CL:NIL) (TOUCHEDDEFAULT? CL:NIL))
      (CL:LET*
       ((ARG NULL) (VECTOR-002 ARGUMENTS) (INDEX-002 0)
        (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
       (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
          INDEX-002))
        (CL:COND
         ((TRUE? ARG)
          (CL:IF (DEFAULT-TRUE? ARG)
           (ASSIGN-TRUTH-VALUE SELF DEFAULT-TRUE-TRUTH-VALUE)
           (CL:PROGN (ASSIGN-TRUTH-VALUE SELF TRUE-WRAPPER)
            (CL:RETURN-FROM EVALUATE-OR-PROPOSITION))))
         ((UNKNOWN? ARG) (CL:SETQ UNBOUNDARG? CL:T))
         ((DEFAULT-FALSE? ARG) (CL:SETQ TOUCHEDDEFAULT? CL:T)))
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
      (CL:WHEN
       (CL:AND (CL:NOT UNBOUNDARG?) (CL:NOT (DEFAULT-TRUE? SELF)))
       (ASSIGN-TRUTH-VALUE SELF
        (DEFAULTIFY-TRUTH-VALUE CL:NIL TOUCHEDDEFAULT?))))))))

;;; (DEFUN EVALUATE-NOT-PROPOSITION ...)

(CL:DEFUN EVALUATE-NOT-PROPOSITION (SELF)
  (CL:LET*
   ((ARGUMENT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      0)))
   (CL:WHEN (CL:OR (TRUE? ARGUMENT) (FALSE? ARGUMENT))
    (ASSIGN-TRUTH-VALUE SELF
     (INVERT-TRUTH-VALUE
      (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE ARGUMENT)
       (%PROPOSITION.HOME-CONTEXT ARGUMENT) CL:NIL))))
   (CL:WHEN (CL:OR (TRUE? SELF) (FALSE? SELF))
    (ASSIGN-TRUTH-VALUE ARGUMENT
     (INVERT-TRUTH-VALUE
      (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE SELF)
       (%PROPOSITION.HOME-CONTEXT SELF) CL:NIL))))))

;;; (DEFUN EVALUATE-EQUIVALENT-PROPOSITION ...)

(CL:DEFUN EVALUATE-EQUIVALENT-PROPOSITION (SELF)
  (CL:LET*
   ((ARGUMENTS (%PROPOSITION.ARGUMENTS SELF))
    (FIRSTARG
     (INNERMOST-OF
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
       0)))
    (SECONDARG
     (INNERMOST-OF
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
       1))))
   (CL:COND
    ((TRUE? SELF)
     (CL:WHEN (DEFAULT-TRUE? SELF)
      (CL:WARN
       "INTERNAL ERROR: DON'T KNOW YET HOW TO EQUATE THINGS BY DEFAULT."))
     (EQUATE-VALUES FIRSTARG SECONDARG))
    ((EQL? FIRSTARG SECONDARG) (ASSIGN-TRUTH-VALUE SELF TRUE-WRAPPER))
    ((CL:AND (CL:NOT (SKOLEM? FIRSTARG)) (CL:NOT (SKOLEM? SECONDARG)))
     (ASSIGN-TRUTH-VALUE SELF FALSE-WRAPPER)))))

;;; (DEFUN EQUATE-EQUIVALENT-FUNCTION-PROPOSITIONS ...)

(CL:DEFUN EQUATE-EQUIVALENT-FUNCTION-PROPOSITIONS (SELF)
  (CL:LET*
   ((RELATIONREF (%PROPOSITION.OPERATOR SELF))
    (NOFARGS (LENGTH (%PROPOSITION.ARGUMENTS SELF)))
    (CANDIDATEPROPOSITIONS (NEW-LIST)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFARGS))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER)
     (ITER-000 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:WHEN (CL:NOT (CL:= I NOFARGS))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-SKOLEM)
         (CL:PROGN
          (CL:WHEN
           (CL:AND
            (CL:NOT
             (CL:EQ
              (ACCESS-IN-CONTEXT (%SKOLEM.VARIABLE-VALUE ARG)
               (%SKOLEM.HOME-CONTEXT ARG) CL:NIL)
              NULL))
            (ISA?
             (ACCESS-IN-CONTEXT (%SKOLEM.VARIABLE-VALUE ARG)
              (%SKOLEM.HOME-CONTEXT ARG) CL:NIL)
             SGT-PROPAGATE-LOGIC-LOGIC-OBJECT))
           (CL:LET*
            ((PROP NULL)
             (ITER-001
              (ALLOCATE-ITERATOR
               (UNFILTERED-DEPENDENT-PROPOSITIONS
                (ACCESS-IN-CONTEXT (%SKOLEM.VARIABLE-VALUE ARG)
                 (%SKOLEM.HOME-CONTEXT ARG) CL:NIL)
                RELATIONREF))))
            (CL:LOOP WHILE (NEXT? ITER-001) DO
             (CL:SETQ PROP (%ITERATOR.VALUE ITER-001))
             (CL:WHEN
              (CL:AND (CL:EQ (%PROPOSITION.OPERATOR PROP) RELATIONREF)
               (CL:NOT (CL:EQ PROP SELF)))
              (INSERT-NEW CANDIDATEPROPOSITIONS PROP)))))
          (CL:LET*
           ((INVARG NULL) (ITER-002 (VARIABLE-VALUE-INVERSE ARG)))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
            (CL:SETQ INVARG (%%VALUE ITER-002))
            (CL:LET*
             ((PROP NULL)
              (ITER-003
               (ALLOCATE-ITERATOR
                (UNFILTERED-DEPENDENT-PROPOSITIONS INVARG
                 RELATIONREF))))
             (CL:LOOP WHILE (NEXT? ITER-003) DO
              (CL:SETQ PROP (%ITERATOR.VALUE ITER-003))
              (CL:WHEN
               (CL:AND (CL:EQ (%PROPOSITION.OPERATOR PROP) RELATIONREF)
                (CL:NOT (CL:EQ PROP SELF)))
               (INSERT-NEW CANDIDATEPROPOSITIONS PROP))))
            (CL:SETQ ITER-002 (%%REST ITER-002))))))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-LOGIC-OBJECT)
         (CL:PROGN
          (CL:LET*
           ((INVARG NULL) (ITER-004 (VARIABLE-VALUE-INVERSE ARG)))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
            (CL:SETQ INVARG (%%VALUE ITER-004))
            (CL:LET*
             ((PROP NULL)
              (ITER-005
               (ALLOCATE-ITERATOR
                (UNFILTERED-DEPENDENT-PROPOSITIONS INVARG
                 RELATIONREF))))
             (CL:LOOP WHILE (NEXT? ITER-005) DO
              (CL:SETQ PROP (%ITERATOR.VALUE ITER-005))
              (CL:WHEN
               (CL:AND (CL:EQ (%PROPOSITION.OPERATOR PROP) RELATIONREF)
                (CL:NOT (CL:EQ PROP SELF)))
               (INSERT-NEW CANDIDATEPROPOSITIONS PROP))))
            (CL:SETQ ITER-004 (%%REST ITER-004))))))
        (CL:T))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET*
    ((PROP NULL)
     (ITER-006 (%LIST.THE-CONS-LIST CANDIDATEPROPOSITIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
     (CL:SETQ PROP (%%VALUE ITER-006))
     (CL:LET* ((ALWAYS?-000 CL:T))
      (CL:LET*
       ((ARG1 NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS SELF))
        (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)) (ARG2 NULL)
        (VECTOR-002 (%PROPOSITION.ARGUMENTS PROP)) (INDEX-002 0)
        (LENGTH-002 (LENGTH VECTOR-002)) (I NULL-INTEGER) (ITER-007 1))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 INDEX-002 LENGTH-002 I
         ITER-007))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-001 LENGTH-001)
         (CL:< INDEX-002 LENGTH-002))
        DO
        (CL:SETQ ARG1
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:SETQ ARG2
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
          INDEX-002))
        (CL:SETQ I ITER-007)
        (CL:WHEN (CL:NOT (CL:= I NOFARGS))
         (CL:WHEN
          (CL:NOT (EQL? (INNERMOST-OF ARG1) (INNERMOST-OF ARG2)))
          (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN)))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002))
        (CL:SETQ ITER-007 (CL:1+ ITER-007))))
      (CL:WHEN ALWAYS?-000
       (EQUATE-VALUES
        (INNERMOST-OF (LAST (%PROPOSITION.ARGUMENTS SELF)))
        (INNERMOST-OF (LAST (%PROPOSITION.ARGUMENTS PROP))))))
     (CL:SETQ ITER-006 (%%REST ITER-006))))
   (FREE CANDIDATEPROPOSITIONS)))

;;; (DEFUN EVALUATE-FUNCTION-PROPOSITION ...)

(CL:DEFUN EVALUATE-FUNCTION-PROPOSITION (SELF)
  (CL:WHEN
   (ISA? (%PROPOSITION.OPERATOR SELF) SGT-PROPAGATE-STELLA-SYMBOL)
   (CL:RETURN-FROM EVALUATE-FUNCTION-PROPOSITION))
  (EQUATE-EQUIVALENT-FUNCTION-PROPOSITIONS SELF)
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION (%PROPOSITION.OPERATOR SELF)))
    (CODE (LOOKUP-CONSTRAINT DESCRIPTION)) (ARGUMENT-VALUE NULL)
    (BOUNDARGUMENTS NIL) (COMPUTEDVALUE NULL) (STOREDVALUE NULL)
    (MISSINGVALUEINDEX -1))
   (CL:DECLARE (CL:TYPE CL:FIXNUM MISSINGVALUEINDEX))
   (CL:WHEN (CL:NOT (CL:EQ CODE NULL))
    (CL:LET*
     ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (DOMAIN NULL)
      (ITER-000 (ALL-ARGUMENT-TYPES DESCRIPTION)) (I NULL-INTEGER)
      (ITER-001 0) (COLLECT-000 NULL))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (NEXT? ITER-000)) DO
      (CL:SETQ ARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ DOMAIN (%ITERATOR.VALUE ITER-000)) (CL:SETQ I ITER-001)
      (CL:SETQ ARGUMENT-VALUE (VALUE-OF ARG))
      (CL:COND
       ((ISA? ARGUMENT-VALUE SGT-PROPAGATE-LOGIC-SKOLEM)
        (CL:IF (CL:= MISSINGVALUEINDEX -1)
         (CL:PROGN (CL:SETQ MISSINGVALUEINDEX I)
          (CL:SETQ ARGUMENT-VALUE NULL))
         (CL:RETURN-FROM EVALUATE-FUNCTION-PROPOSITION)))
       ((CL:NOT (CHECK-STRICT-TYPE? ARGUMENT-VALUE DOMAIN CL:T))
        (CL:RETURN-FROM EVALUATE-FUNCTION-PROPOSITION))
       (CL:T))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARGUMENT-VALUE NIL))
        (CL:IF (CL:EQ BOUNDARGUMENTS NIL)
         (CL:SETQ BOUNDARGUMENTS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST BOUNDARGUMENTS COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000) (CONS ARGUMENT-VALUE NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
      (CL:SETQ ITER-001 (CL:1+ ITER-001))))
    (CL:WHEN (CL:= MISSINGVALUEINDEX -1)
     (CL:RETURN-FROM EVALUATE-FUNCTION-PROPOSITION))
    (CL:SETQ COMPUTEDVALUE
     (APPLY CODE
      (CONS (WRAP-INTEGER MISSINGVALUEINDEX) BOUNDARGUMENTS)))
    (CL:SETQ STOREDVALUE
     (VALUE-OF
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
       MISSINGVALUEINDEX)))
    (CL:WHEN
     (CL:AND (CL:NOT (EQL? COMPUTEDVALUE STOREDVALUE))
      (CL:NOT (CL:EQ COMPUTEDVALUE NULL)))
     (EQUATE-VALUES COMPUTEDVALUE STOREDVALUE))
    (CL:RETURN-FROM EVALUATE-FUNCTION-PROPOSITION))
   (CL:SETQ CODE (LOOKUP-COMPUTATION DESCRIPTION))
   (CL:WHEN (CL:NOT (CL:EQ CODE NULL))
    (CL:LET*
     ((ARG NULL) (ITER-002 (BUT-LAST (%PROPOSITION.ARGUMENTS SELF)))
      (COLLECT-001 NULL))
     (CL:LOOP WHILE (NEXT? ITER-002) DO
      (CL:SETQ ARG (%ITERATOR.VALUE ITER-002))
      (CL:WHEN (ISA? (VALUE-OF ARG) SGT-PROPAGATE-LOGIC-SKOLEM)
       (CL:RETURN-FROM EVALUATE-FUNCTION-PROPOSITION))
      (CL:IF (CL:EQ COLLECT-001 NULL)
       (CL:PROGN (CL:SETQ COLLECT-001 (CONS (VALUE-OF ARG) NIL))
        (CL:IF (CL:EQ BOUNDARGUMENTS NIL)
         (CL:SETQ BOUNDARGUMENTS COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST BOUNDARGUMENTS COLLECT-001)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-001) (CONS (VALUE-OF ARG) NIL))
        (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))))
    (CL:SETQ COMPUTEDVALUE (APPLY CODE BOUNDARGUMENTS))
    (CL:WHEN (CL:NOT (CL:EQ COMPUTEDVALUE NULL))
     (CL:SETQ COMPUTEDVALUE (EVALUATE-TERM COMPUTEDVALUE)))
    (CL:SETQ STOREDVALUE
     (VALUE-OF
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
       (CL:THE CL:FIXNUM
        (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS SELF)))))))
    (CL:WHEN
     (CL:AND (CL:NOT (EQL? COMPUTEDVALUE STOREDVALUE))
      (CL:NOT (CL:EQ COMPUTEDVALUE NULL)))
     (EQUATE-VALUES COMPUTEDVALUE STOREDVALUE)))))

;;; (DEFUN EVALUATE-PREDICATE-PROPOSITION ...)

(CL:DEFUN EVALUATE-PREDICATE-PROPOSITION (SELF)
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION (%PROPOSITION.OPERATOR SELF)))
    (CODE (LOOKUP-CONSTRAINT DESCRIPTION)) (BOUNDARGUMENTS NIL)
    (SUCCESS? CL:NIL))
   (CL:WHEN (CL:NOT (CL:EQ CODE NULL))
    (CL:LET*
     ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
      (COLLECT-000 NULL))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:SETQ ARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:WHEN (ISA? (VALUE-OF ARG) SGT-PROPAGATE-LOGIC-SKOLEM)
       (CL:RETURN-FROM EVALUATE-PREDICATE-PROPOSITION))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG NIL))
        (CL:IF (CL:EQ BOUNDARGUMENTS NIL)
         (CL:SETQ BOUNDARGUMENTS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST BOUNDARGUMENTS COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
    (CL:SETQ SUCCESS?
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
      (APPLY CODE (CONS (WRAP-INTEGER -1) BOUNDARGUMENTS))))
    (ASSIGN-TRUTH-VALUE SELF
     (CL:IF SUCCESS? TRUE-WRAPPER FALSE-WRAPPER))
    (CL:RETURN-FROM EVALUATE-PREDICATE-PROPOSITION))
   (CL:SETQ CODE (LOOKUP-COMPUTATION DESCRIPTION))
   (CL:WHEN (CL:NOT (CL:EQ CODE NULL))
    (CL:LET*
     ((ARG NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS SELF))
      (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001))
      (COLLECT-001 NULL))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
     (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
      (CL:SETQ ARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
        INDEX-001))
      (CL:WHEN (ISA? (VALUE-OF ARG) SGT-PROPAGATE-LOGIC-SKOLEM)
       (CL:RETURN-FROM EVALUATE-PREDICATE-PROPOSITION))
      (CL:IF (CL:EQ COLLECT-001 NULL)
       (CL:PROGN (CL:SETQ COLLECT-001 (CONS ARG NIL))
        (CL:IF (CL:EQ BOUNDARGUMENTS NIL)
         (CL:SETQ BOUNDARGUMENTS COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST BOUNDARGUMENTS COLLECT-001)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS ARG NIL))
        (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
    (CL:SETQ SUCCESS?
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (APPLY CODE BOUNDARGUMENTS)))
    (ASSIGN-TRUTH-VALUE SELF
     (CL:IF SUCCESS? TRUE-WRAPPER FALSE-WRAPPER)))))

;;; (DEFUN EVALUATE-PROPOSITION ...)

(CL:DEFUN EVALUATE-PROPOSITION (SELF)
  (EVALUATION-STATE-SETTER SELF KWD-PROPAGATE-EVALUATED)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-PROPAGATE-AND)
     (EVALUATE-AND-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-PROPAGATE-OR)
     (EVALUATE-OR-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-PROPAGATE-NOT)
     (EVALUATE-NOT-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-PROPAGATE-EQUIVALENT)
     (EVALUATE-EQUIVALENT-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-PROPAGATE-ISA))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-PREDICATE))
     (CL:LET*
      ((DESCRIPTION (GET-DESCRIPTION (%PROPOSITION.OPERATOR SELF)))
       (EVALUATOR (LOOKUP-EVALUATOR DESCRIPTION)))
      (CL:COND
       ((CL:NOT (CL:EQ EVALUATOR NULL)) (CL:FUNCALL EVALUATOR SELF))
       ((CL:EQ (%PROPOSITION.KIND SELF) KWD-PROPAGATE-PREDICATE)
        (EVALUATE-PREDICATE-PROPOSITION SELF))
       (CL:T (EVALUATE-FUNCTION-PROPOSITION SELF)))))
    (CL:T))))

;;; (DEFMETHOD MARK-AS-INCOHERENT ...)

(CL:DEFMETHOD MARK-AS-INCOHERENT ((SELF LOGIC-OBJECT)))

;;; (DEFMETHOD MARK-AS-INCOHERENT ...)

(CL:DEFMETHOD MARK-AS-INCOHERENT ((SELF SKOLEM))
  (CL:WHEN (CL:NOT (CL:EQ (%SKOLEM.DEFINING-PROPOSITION SELF) NULL))
   (CL:LET*
    ((FIRSTARG
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY
         (%PROPOSITION.ARGUMENTS (%SKOLEM.DEFINING-PROPOSITION SELF))))
       0)))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE FIRSTARG)
       SGT-PROPAGATE-LOGIC-LOGIC-OBJECT)
      (CL:PROGN (MARK-AS-INCOHERENT FIRSTARG) NULL))
     (CL:T)))))

;;; (DEFGLOBAL *JUST-IN-TIME-FORWARD-INFERENCE?* ...)

(CL:DEFVAR *JUST-IN-TIME-FORWARD-INFERENCE?* CL:T
  "If TRUE, ensures that forward propagation has
been applied to each instance 'touched' during a query.")

(CL:DEFMETHOD ELABORATED-IN-WORLDS ((SELF LOGIC-OBJECT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%LOGIC-OBJECT.DYNAMIC-SLOTS SELF)
      SYM-PROPAGATE-LOGIC-ELABORATED-IN-WORLDS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

;;; (DEFUN RECURSIVELY-REACT-TO-INFERENCE-UPDATE ...)

(CL:DEFUN RECURSIVELY-REACT-TO-INFERENCE-UPDATE (SELF)
  (REACT-TO-INFERENCE-UPDATE SELF)
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ ARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
      INDEX-000))
    (CL:WHEN (ISA? ARG SGT-PROPAGATE-LOGIC-PROPOSITION)
     (RECURSIVELY-REACT-TO-INFERENCE-UPDATE ARG))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))

;;; (DEFUN ELABORATE-META-INSTANCE ...)

(CL:DEFUN ELABORATE-META-INSTANCE (SELF)
  (CL:LET*
   ((WORLDSTATE (GET-WORLD-STATE *CONTEXT*))
    (METAWORLD (GET-INFERENCE-CACHE WORLDSTATE KWD-PROPAGATE-META)))
   (CL:LET* ((*CONTEXT* METAWORLD)) (CL:DECLARE (CL:SPECIAL *CONTEXT*))
    (ELABORATE-INSTANCE SELF))))

;;; (DEFUN ELABORATE-INSTANCE ...)

(CL:DEFUN ELABORATE-INSTANCE (SELF)
  (CL:WHEN *FILLINGCONSTRAINTPROPAGATIONQUEUES?*
   (CL:RETURN-FROM ELABORATE-INSTANCE))
  (CL:WHEN *JUST-IN-TIME-FORWARD-INFERENCE?*
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
      SGT-PROPAGATE-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:WHEN (MEMBER? (ELABORATED-IN-WORLDS SELF) *CONTEXT*)
       (CL:RETURN-FROM ELABORATE-INSTANCE))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
        (MEMB? *TRACED-KEYWORDS* KWD-PROPAGATE-ELABORATE))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        " ELABORATING:  " SELF " in world " *CONTEXT* EOL))
      (CL:IF (CL:EQ (ELABORATED-IN-WORLDS SELF) NIL-LIST)
       (SET-DYNAMIC-SLOT-VALUE (%LOGIC-OBJECT.DYNAMIC-SLOTS SELF)
        SYM-PROPAGATE-LOGIC-ELABORATED-IN-WORLDS (LIST) NULL)
       (REMOVE-DELETED-MEMBERS (ELABORATED-IN-WORLDS SELF)))
      (PUSH (ELABORATED-IN-WORLDS SELF) *CONTEXT*)
      (CL:LET*
       ((*EVALUATIONMODE* KWD-PROPAGATE-EXTENSIONAL-ASSERTION)
        (*INHIBITOBJECTFINALIZATION?* CL:T) (*QUERYITERATOR* NULL))
       (CL:DECLARE
        (CL:SPECIAL *EVALUATIONMODE* *INHIBITOBJECTFINALIZATION?*
         *QUERYITERATOR*))
       (CL:HANDLER-CASE
        (CL:PROGN (INITIALIZE-CONSTRAINT-PROPAGATION-QUEUES *CONTEXT*)
         (CL:LET* ((*FILLINGCONSTRAINTPROPAGATIONQUEUES?* CL:T))
          (CL:DECLARE
           (CL:SPECIAL *FILLINGCONSTRAINTPROPAGATIONQUEUES?*))
          (EVALUATE-REACHABLE-INEQUALITIES SELF (LIST))
          (CL:LET*
           ((PROP NULL)
            (ITER-000
             (%LIST.THE-CONS-LIST
              (ALL-FACTS-OF-INSTANCE SELF CL:T CL:NIL))))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
            (CL:SETQ PROP (%%VALUE ITER-000))
            (RECURSIVELY-REACT-TO-INFERENCE-UPDATE PROP)
            (CL:SETQ ITER-000 (%%REST ITER-000))))
          (CL:LET* ((*DEFERINGDEFAULTFORWARDINFERENCES?* CL:T))
           (CL:DECLARE
            (CL:SPECIAL *DEFERINGDEFAULTFORWARDINFERENCES?*))
           (EXECUTE-CONSTRAINT-PROPAGATION-QUEUES))
          (CL:LET*
           ((P NULL)
            (ITER-001 (DEFERRED-DEFAULT-PROPOSITIONS *CONTEXT*)))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
            (CL:SETQ P (%%VALUE ITER-001))
            (ASSIGN-TRUTH-VALUE P DEFAULT-TRUE-TRUTH-VALUE)
            (CL:SETQ ITER-001 (%%REST ITER-001))))
          (DEFERRED-DEFAULT-PROPOSITIONS-SETTER *CONTEXT* NIL))
         (EXECUTE-CONSTRAINT-PROPAGATION-QUEUES))
        (CLASH (E)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
          (EXCEPTION-MESSAGE E) EOL))))))
    (CL:T))))

;;; (DEFUN EVALUATE-REACHABLE-INEQUALITIES ...)

(CL:DEFUN EVALUATE-REACHABLE-INEQUALITIES (SELF VISITEDLIST)
  (CL:LET*
   ((P NULL)
    (ITER-000
     (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF
      SGT-PROPAGATE-PL-KERNEL-KB-INEQUALITY CL:T)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ P (%ITERATOR.VALUE ITER-000))
    (CL:WHEN (CL:EQ (EVALUATION-STATE P) NULL) (POST-FOR-EVALUATION P))
    (PUSH VISITEDLIST SELF)
    (CL:LET*
     ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS P)) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:SETQ ARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:WHEN
       (CL:AND (CL:NOT (MEMBER? VISITEDLIST ARG))
        (ISA? ARG SGT-PROPAGATE-LOGIC-LOGIC-OBJECT))
       (EVALUATE-REACHABLE-INEQUALITIES ARG VISITEDLIST))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))))

;;; (DEFUN ELABORATE-SURROGATES-IN-PROPOSITION ...)

(CL:DEFUN ELABORATE-SURROGATES-IN-PROPOSITION (PROPOSITION)
  (CL:WHEN *JUST-IN-TIME-FORWARD-INFERENCE?*
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-FUNCTION)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-ISA))
      (ELABORATE-META-INSTANCE
       (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION)))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:WHEN (ISA? ARG SGT-PROPAGATE-STELLA-SURROGATE)
         (CL:LET* ((VALUE (VALUE-OF ARG)))
          (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
           (ELABORATE-INSTANCE VALUE))))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-AND)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-OR)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-NOT)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-EXISTS)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-FORALL))
      (CL:LET*
       ((P NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS PROPOSITION))
        (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ P
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (ELABORATE-SURROGATES-IN-PROPOSITION P)
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
     (CL:T)))))

;;; (DEFUN COLLECT-FUNCTION-PROPOSITION-FACTS ...)

(CL:DEFUN COLLECT-FUNCTION-PROPOSITION-FACTS (SELF FACTS BEENTHERE INCLUDEUNKNOWN?)
  (INSERT BEENTHERE SELF)
  (CL:LET*
   ((OUTPUTSKOLEM
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      (CL:THE CL:FIXNUM
       (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS SELF))))))
    (VALUE (VALUE-OF OUTPUTSKOLEM))
    (HASASSERTEDVALUE? (CL:NOT (EQL? VALUE OUTPUTSKOLEM))))
   (CL:WHEN HASASSERTEDVALUE?
    (CL:WHEN (CL:NOT (MEMBER? FACTS SELF)) (INSERT FACTS SELF)))
   (CL:WHEN
    (CL:OR (CL:NOT HASASSERTEDVALUE?)
     (CL:AND (NATIVE-VALUE? VALUE)
      (CL:NOT (ISA? VALUE SGT-PROPAGATE-STELLA-LITERAL-WRAPPER))))
    (HELP-COLLECT-FACTS OUTPUTSKOLEM FACTS BEENTHERE INCLUDEUNKNOWN?))))

;;; (DEFUN HELP-COLLECT-FACTS ...)

(CL:DEFUN HELP-COLLECT-FACTS (SELF FACTS BEENTHERE INCLUDEUNKNOWN?)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:LET*
       ((P NULL)
        (ITER-000
         (ALLOCATE-ITERATOR
          (UNFILTERED-DEPENDENT-PROPOSITIONS SELF NULL))))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ P (%ITERATOR.VALUE ITER-000))
        (CL:WHEN (CL:NOT (MEMBER? BEENTHERE P))
         (CL:IF (CL:EQ (%PROPOSITION.KIND P) KWD-PROPAGATE-FUNCTION)
          (COLLECT-FUNCTION-PROPOSITION-FACTS P FACTS BEENTHERE
           INCLUDEUNKNOWN?)
          (HELP-COLLECT-FACTS P FACTS BEENTHERE INCLUDEUNKNOWN?)))))
      (CL:LET*
       ((EQUIVALENT NULL) (ITER-001 (VARIABLE-VALUE-INVERSE SELF)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ EQUIVALENT (%%VALUE ITER-001))
        (HELP-COLLECT-FACTS EQUIVALENT FACTS BEENTHERE INCLUDEUNKNOWN?)
        (CL:SETQ ITER-001 (%%REST ITER-001))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-PROPOSITION)
     (CL:PROGN (INSERT BEENTHERE SELF)
      (CL:WHEN (CL:OR (CL:NOT (UNKNOWN? SELF)) INCLUDEUNKNOWN?)
       (INSERT FACTS SELF))
      (CL:LET*
       ((P NULL)
        (ITER-002
         (ALLOCATE-ITERATOR
          (%PROPOSITION.DEPENDENT-PROPOSITIONS SELF))))
       (CL:LOOP WHILE (NEXT? ITER-002) DO
        (CL:SETQ P (%ITERATOR.VALUE ITER-002))
        (CL:WHEN (CL:NOT (MEMBER? BEENTHERE P))
         (HELP-COLLECT-FACTS P FACTS BEENTHERE INCLUDEUNKNOWN?))))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SELF) NULL))
       (HELP-COLLECT-FACTS (%SURROGATE.SURROGATE-VALUE SELF) FACTS
        BEENTHERE INCLUDEUNKNOWN?))))
    ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS SELF)
          SYM-PROPAGATE-LOGIC-DESCRIPTION NULL)
         NULL))
       (HELP-COLLECT-FACTS
        (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS SELF)
         SYM-PROPAGATE-LOGIC-DESCRIPTION NULL)
        FACTS BEENTHERE INCLUDEUNKNOWN?))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-STELLA-SLOT)
     (CL:PROGN
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
          SYM-PROPAGATE-LOGIC-DESCRIPTION NULL)
         NULL))
       (HELP-COLLECT-FACTS
        (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
         SYM-PROPAGATE-LOGIC-DESCRIPTION NULL)
        FACTS BEENTHERE INCLUDEUNKNOWN?))))
    (CL:T))))

;;; (DEFUN (ALL-FACTS-OF-INSTANCE (LIST OF PROPOSITION)) ...)

(CL:DEFUN ALL-FACTS-OF-INSTANCE (SELF INCLUDEUNKNOWNFACTS? ELABORATE?)
  "Return a list of all definite (TRUE or FALSE) propositions
attached to `self'."
  (CL:LET* ((FACTS (NEW-LIST)) (BEENTHERE (NEW-LIST)))
   (CL:LET*
    ((*CONTEXT* (GET-QUERY-CONTEXT))
     (*MODULE* (%CONTEXT.BASE-MODULE *CONTEXT*)))
    (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
    (CL:WHEN ELABORATE? (ELABORATE-INSTANCE SELF))
    (HELP-COLLECT-FACTS SELF FACTS BEENTHERE INCLUDEUNKNOWNFACTS?))
   FACTS))

;;; (DEFUN (ALL-FACTS-OF (CONS OF PROPOSITION)) ...)

(CL:DEFUN %ALL-FACTS-OF (INSTANCEREF)
  "Return a cons list of all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'.  This includes propositions
asserted to be true by default, but it does not include propositions
that are found to be TRUE only by running the query engine.  Facts
inferred to be TRUE by the forward chainer will be included.
Hence, the returned list of facts may be longer in a context where the
forward chainer has been run then in one where it has not (see
`run-forward-rules')."
  (CL:LET* ((INSTANCE (COERCE-TO-INSTANCE INSTANCEREF NULL)))
   (CL:IF (CL:NOT (CL:EQ INSTANCE NULL))
    (%LIST.THE-CONS-LIST (ALL-FACTS-OF-INSTANCE INSTANCE CL:NIL CL:T))
    NULL)))

(CL:DEFMACRO ALL-FACTS-OF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Return a cons list of all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'.  This includes propositions
asserted to be true by default, but it does not include propositions
that are found to be TRUE only by running the query engine.  Facts
inferred to be TRUE by the forward chainer will be included.
Hence, the returned list of facts may be longer in a context where the
forward chainer has been run then in one where it has not (see
`run-forward-rules')."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/ALL-FACTS-OF|)) (CL:MACRO-FUNCTION (CL:QUOTE ALL-FACTS-OF)))

;;; (DEFUN (CALL-ALL-FACTS-OF (LIST OF PROPOSITION)) ...)

(CL:DEFUN %CALL-ALL-FACTS-OF (INSTANCEREF)
  "Return a list of all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'."
  (CL:LET* ((INSTANCE (COERCE-TO-INSTANCE INSTANCEREF NULL)))
   (CL:IF (CL:NOT (CL:EQ INSTANCE NULL))
    (ALL-FACTS-OF-INSTANCE INSTANCE CL:NIL CL:T) NULL)))

(CL:DEFMACRO CALL-ALL-FACTS-OF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Return a list of all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/CALL-ALL-FACTS-OF|)) (CL:MACRO-FUNCTION (CL:QUOTE CALL-ALL-FACTS-OF)))

;;; (DEFUN RETRACT-FACTS-OF-INSTANCE ...)

(CL:DEFUN RETRACT-FACTS-OF-INSTANCE (SELF)
  "Retract all definite (TRUE or FALSE) propositions attached to `self'."
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM RETRACT-FACTS-OF-INSTANCE))
  (CL:LET*
   ((P NULL)
    (ITER-000
     (%LIST.THE-CONS-LIST (ALL-FACTS-OF-INSTANCE SELF CL:NIL CL:T))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ P (%%VALUE ITER-000))
    (CL:TAGBODY
     (CL:COND
      ((CL:EQ (%PROPOSITION.KIND P) KWD-PROPAGATE-FUNCTION)
       (CL:LET* ((SKOLEM (LAST (%PROPOSITION.ARGUMENTS P))))
        (CL:WHEN (CL:EQ SKOLEM SELF) (CL:GO :CONTINUE))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ SKOLEM NULL))
          (CL:NOT
           (CL:EQ
            (ACCESS-IN-CONTEXT (%SKOLEM.VARIABLE-VALUE SKOLEM)
             (%SKOLEM.HOME-CONTEXT SKOLEM) CL:NIL)
            NULL)))
         (UNASSERT-PROPOSITION P))
        (RETRACT-FACTS-OF-INSTANCE SKOLEM)))
      (CL:T (UNASSERT-PROPOSITION P)))
     :CONTINUE)
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN RETRACT-FACTS-OF ...)

(CL:DEFUN %RETRACT-FACTS-OF (INSTANCEREF)
  "Retract all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'."
  (CL:LET* ((INSTANCE (COERCE-TO-INSTANCE INSTANCEREF NULL)))
   (CL:WHEN (CL:NOT (CL:EQ INSTANCE NULL))
    (RETRACT-FACTS-OF-INSTANCE INSTANCE))))

(CL:DEFMACRO RETRACT-FACTS-OF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Retract all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/RETRACT-FACTS-OF|)) (CL:MACRO-FUNCTION (CL:QUOTE RETRACT-FACTS-OF)))

;;; (DEFUN (EXPLODE-VARIABLIZED-STRING LIST) ...)

(CL:DEFUN EXPLODE-VARIABLIZED-STRING (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:LET*
   ((LIST (NEW-LIST))
    (ENDOFSTRING (CL:THE CL:FIXNUM (CL:LENGTH STRING))) (BEGIN 0)
    (END NULL-INTEGER) (SUBSTRING STELLA::NULL-STRING) (SYMBOL NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ENDOFSTRING BEGIN END)
    (CL:TYPE CL:SIMPLE-STRING SUBSTRING))
   (CL:LOOP
    (CL:WHEN (CL:>= BEGIN ENDOFSTRING)
     (CL:RETURN-FROM EXPLODE-VARIABLIZED-STRING LIST))
    (CL:SETQ END (POSITION STRING #\? BEGIN))
    (CL:COND
     ((NULL? END)
      (CL:SETQ SUBSTRING (SUBSEQUENCE STRING BEGIN ENDOFSTRING))
      (INSERT-LAST LIST (WRAP-STRING SUBSTRING))
      (CL:RETURN-FROM EXPLODE-VARIABLIZED-STRING LIST))
     ((CL:> END BEGIN)
      (CL:SETQ SUBSTRING (SUBSEQUENCE STRING BEGIN END))
      (INSERT-LAST LIST (WRAP-STRING SUBSTRING))))
    (CL:SETQ BEGIN END) (CL:SETQ END (POSITION STRING #\  BEGIN))
    (CL:WHEN (NULL? END) (CL:SETQ END ENDOFSTRING))
    (CL:SETQ SUBSTRING (SUBSEQUENCE STRING BEGIN END))
    (CL:SETQ SYMBOL (INTERN-SYMBOL (STRING-UPCASE SUBSTRING)))
    (INSERT-LAST LIST SYMBOL) (CL:SETQ BEGIN END))))

;;; (DEFUN (FACT-TO-SENTENCE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:SIMPLE-STRING) FACT-TO-SENTENCE))
(CL:DEFUN FACT-TO-SENTENCE (SELF PERIOD?)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-ISA))
     (CL:LET*
      ((RELATION
        (%SURROGATE.SURROGATE-VALUE (%PROPOSITION.OPERATOR SELF)))
       (PHRASE
        (ACCESS-BINARY-VALUE RELATION
         SGT-PROPAGATE-PL-KERNEL-KB-PHRASE))
       (EXPLODEDSTRING
        (CL:IF (CL:NOT (CL:EQ PHRASE NULL))
         (EXPLODE-VARIABLIZED-STRING
          (%STRING-WRAPPER.WRAPPER-VALUE PHRASE))
         NULL)))
      (CL:WHEN (CL:NOT (CL:EQ EXPLODEDSTRING NULL))
       (CL:LET* ((TABLE (NEW-KEY-VALUE-LIST)) (SENTENCE ""))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SENTENCE))
        (CL:LET*
         ((VBL NULL)
          (ITER-000
           (%LIST.THE-CONS-LIST
            (%NAMED-DESCRIPTION.IO-VARIABLE-NAMES RELATION)))
          (ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
          (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE
          (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
           (CL:< INDEX-000 LENGTH-000))
          DO (CL:SETQ VBL (%%VALUE ITER-000))
          (CL:SETQ ARG
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
            INDEX-000))
          (INSERT-AT TABLE VBL ARG)
          (CL:SETQ ITER-000 (%%REST ITER-000))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
        (CL:LET*
         ((ITEM NULL) (ITER-001 (%LIST.THE-CONS-LIST EXPLODEDSTRING)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ ITEM (%%VALUE ITER-001))
          (CL:LET* ((VALUE NULL) (STRINGVALUE STELLA::NULL-STRING))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGVALUE))
           (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE ITEM)))
            (CL:COND
             ((SUBTYPE-OF-SYMBOL? TEST-VALUE-002)
              (CL:PROGN (CL:SETQ VALUE (LOOKUP TABLE ITEM))
               (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
                (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE VALUE)))
                 (CL:COND
                  ((SUBTYPE-OF? TEST-VALUE-001
                    SGT-PROPAGATE-LOGIC-SKOLEM)
                   (CL:PROGN
                    (CL:LET*
                     ((SURROGATE
                       (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE VALUE))
                      (DEFININGPROPOSITION
                       (%SKOLEM.DEFINING-PROPOSITION VALUE)))
                     (CL:COND
                      ((CL:NOT (CL:EQ DEFININGPROPOSITION NULL))
                       (CL:SETQ STRINGVALUE
                        (FACT-TO-SENTENCE DEFININGPROPOSITION CL:NIL)))
                      ((CL:NOT (CL:EQ SURROGATE NULL))
                       (CL:SETQ STRINGVALUE
                        (%SURROGATE.SYMBOL-NAME SURROGATE)))
                      (CL:T
                       (CL:SETQ STRINGVALUE
                        (%SYMBOL.SYMBOL-NAME
                         (%SKOLEM.SKOLEM-NAME VALUE))))))))
                  ((SUBTYPE-OF? TEST-VALUE-001
                    SGT-PROPAGATE-LOGIC-LOGIC-OBJECT)
                   (CL:PROGN
                    (CL:LET*
                     ((SURROGATE
                       (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE VALUE)))
                     (CL:WHEN (CL:NOT (CL:EQ SURROGATE NULL))
                      (CL:SETQ STRINGVALUE
                       (%SURROGATE.SYMBOL-NAME SURROGATE))))))
                  ((SUBTYPE-OF-STRING? TEST-VALUE-001)
                   (CL:PROGN
                    (CL:SETQ STRINGVALUE
                     (CONCATENATE "'"
                      (%STRING-WRAPPER.WRAPPER-VALUE VALUE) "'"))))
                  ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
                   (CL:PROGN
                    (CL:SETQ STRINGVALUE
                     (INTEGER-TO-STRING
                      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE)))))
                  ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
                   (CL:PROGN
                    (CL:SETQ STRINGVALUE
                     (FLOAT-TO-STRING
                      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE)))))
                  (CL:T))))
               (CL:IF (CL:NOT (CL:EQ STRINGVALUE STELLA::NULL-STRING))
                (CL:SETQ SENTENCE (CONCATENATE SENTENCE STRINGVALUE))
                (CL:SETQ SENTENCE
                 (CONCATENATE SENTENCE (%SYMBOL.SYMBOL-NAME ITEM))))))
             ((SUBTYPE-OF-STRING? TEST-VALUE-002)
              (CL:PROGN
               (CL:SETQ SENTENCE
                (CONCATENATE SENTENCE
                 (%STRING-WRAPPER.WRAPPER-VALUE ITEM)))))
             (CL:T
              (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
               (%%PRINT-STREAM
                (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
                TEST-VALUE-002 "' is not a valid case option")
               (CL:ERROR
                (NEW-STELLA-EXCEPTION
                 (THE-STRING-READER STREAM-000))))))))
          (CL:SETQ ITER-001 (%%REST ITER-001))))
        (CL:WHEN PERIOD? (CL:SETQ SENTENCE (CONCATENATE SENTENCE ".")))
        (CL:RETURN-FROM FACT-TO-SENTENCE SENTENCE)))
      STELLA::NULL-STRING))
    ((CL:EQ TEST-VALUE-000 KWD-PROPAGATE-IMPLIES)
     "rules not yet implemented")
    (CL:T "???"))))

;;; (DEFUN (ALL-SENTENCES-OF (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN %ALL-SENTENCES-OF (INSTANCEREF)
  "Return a list of sentences describing facts about 'instanceRef'."
  (CL:LET*
   ((INSTANCE (COERCE-TO-INSTANCE INSTANCEREF NULL))
    (SENTENCE STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SENTENCE))
   (CL:IF (CL:NOT (CL:EQ INSTANCE NULL))
    (CL:LET* ((LIST NIL))
     (CL:LET*
      ((FACT NULL)
       (ITER-000
        (%LIST.THE-CONS-LIST
         (ALL-FACTS-OF-INSTANCE INSTANCE CL:NIL CL:T)))
       (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ FACT (%%VALUE ITER-000))
       (CL:TAGBODY
        (CL:PROGN (CL:SETQ SENTENCE (FACT-TO-SENTENCE FACT CL:T))
         (CL:WHEN (CL:EQ SENTENCE STELLA::NULL-STRING)
          (CL:GO :CONTINUE)))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-000 (CONS (WRAP-STRING SENTENCE) NIL))
          (CL:IF (CL:EQ LIST NIL) (CL:SETQ LIST COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST LIST COLLECT-000)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-000)
           (CONS (WRAP-STRING SENTENCE) NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
        :CONTINUE)
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     LIST)
    NULL)))

(CL:DEFMACRO ALL-SENTENCES-OF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Return a list of sentences describing facts about 'instanceRef'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/ALL-SENTENCES-OF|)) (CL:MACRO-FUNCTION (CL:QUOTE ALL-SENTENCES-OF)))

;;; (DEFUN (CALL-ALL-FACTS-OF-N (LIST OF PROPOSITION)) ...)

(CL:DEFUN CALL-ALL-FACTS-OF-N (N SEEDREFS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:LET*
   ((VISITED (NEW-HASH-TABLE)) (FACTS (NEW-HASH-TABLE))
    (FACTLIST (NEW-LIST)) (SEEDS (NEW-LIST)) (NEWSEEDS (NEW-LIST))
    (INSTANCE NULL))
   (CL:LET* ((SEEDREF NULL) (ITER-000 SEEDREFS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SEEDREF (%%VALUE ITER-000))
     (CL:SETQ INSTANCE (COERCE-TO-INSTANCE SEEDREF NULL))
     (CL:WHEN (CL:NOT (CL:EQ INSTANCE NULL))
      (INSERT-NEW SEEDS INSTANCE))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-001 0)
     (UPPER-BOUND-000 (CL:IF (DEFINED? N) N 0))
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-001) (CL:SETQ I I)
     (CL:LET* ((SEED NULL) (ITER-002 (%LIST.THE-CONS-LIST SEEDS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ SEED (%%VALUE ITER-002)) (INSERT-AT VISITED SEED SEED)
       (CL:SETQ ITER-002 (%%REST ITER-002))))
     (CL:LET* ((SEED NULL) (ITER-003 (%LIST.THE-CONS-LIST SEEDS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
       (CL:SETQ SEED (%%VALUE ITER-003))
       (CL:LET*
        ((PROP NULL)
         (ITER-004
          (%LIST.THE-CONS-LIST
           (ALL-FACTS-OF-INSTANCE SEED CL:NIL CL:T))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
         (CL:SETQ PROP (%%VALUE ITER-004))
         (CL:TAGBODY
          (CL:WHEN (CL:NOT (CL:EQ (LOOKUP FACTS PROP) NULL))
           (CL:GO :CONTINUE))
          (INSERT-AT FACTS PROP PROP) (INSERT FACTLIST PROP)
          (CL:LET*
           ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROP))
            (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
           (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
            (CL:SETQ ARG
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
              INDEX-000))
            (CL:WHEN (CL:EQ (LOOKUP VISITED ARG) NULL)
             (INSERT-NEW NEWSEEDS ARG))
            (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
          :CONTINUE)
         (CL:SETQ ITER-004 (%%REST ITER-004))))
       (CL:SETQ ITER-003 (%%REST ITER-003))))
     (CL:SETQ SEEDS NEWSEEDS) (CL:SETQ NEWSEEDS (NEW-LIST))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (REVERSE FACTLIST)))

;;; (DEFUN (FILTERED-ALL-FACTS-OF-N (LIST OF PROPOSITION)) ...)

(CL:DEFUN FILTERED-ALL-FACTS-OF-N (N SEEDREFS FILTER)
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:LET*
   ((VISITED (NEW-HASH-TABLE)) (FACTS (NEW-HASH-TABLE))
    (FACTLIST (NEW-LIST)) (SEEDS (NEW-LIST)) (NEWSEEDS (NEW-LIST))
    (INSTANCE NULL))
   (CL:LET* ((SEEDREF NULL) (ITER-000 SEEDREFS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SEEDREF (%%VALUE ITER-000))
     (CL:SETQ INSTANCE (COERCE-TO-INSTANCE SEEDREF NULL))
     (CL:WHEN (CL:NOT (CL:EQ INSTANCE NULL))
      (INSERT-NEW SEEDS INSTANCE))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-001 0)
     (UPPER-BOUND-000 (CL:IF (DEFINED? N) N 0))
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-001) (CL:SETQ I I)
     (CL:LET* ((SEED NULL) (ITER-002 (%LIST.THE-CONS-LIST SEEDS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ SEED (%%VALUE ITER-002)) (INSERT-AT VISITED SEED SEED)
       (CL:SETQ ITER-002 (%%REST ITER-002))))
     (CL:LET* ((SEED NULL) (ITER-003 (%LIST.THE-CONS-LIST SEEDS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
       (CL:SETQ SEED (%%VALUE ITER-003))
       (CL:LET*
        ((PROP NULL)
         (ITER-004
          (%LIST.THE-CONS-LIST
           (ALL-FACTS-OF-INSTANCE SEED CL:NIL CL:T))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
         (CL:SETQ PROP (%%VALUE ITER-004))
         (CL:TAGBODY
          (CL:WHEN (CL:NOT (CL:EQ (LOOKUP FACTS PROP) NULL))
           (CL:GO :CONTINUE))
          (CL:LET*
           ((FILTEROUTPUT (CL:FUNCALL FILTER PROP))
            (FACTPROPS (%%VALUE FILTEROUTPUT))
            (PROPSEEDS (%%VALUE (%%REST FILTEROUTPUT))))
           (CL:LET* ((FACTPROP NULL) (ITER-005 FACTPROPS))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
             (CL:SETQ FACTPROP (%%VALUE ITER-005))
             (INSERT-AT FACTS FACTPROP FACTPROP)
             (INSERT FACTLIST FACTPROP)
             (CL:SETQ ITER-005 (%%REST ITER-005))))
           (CL:LET* ((ARG NULL) (ITER-006 PROPSEEDS))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
             (CL:SETQ ARG (%%VALUE ITER-006))
             (CL:WHEN (CL:EQ (LOOKUP VISITED ARG) NULL)
              (INSERT-NEW NEWSEEDS ARG))
             (CL:SETQ ITER-006 (%%REST ITER-006)))))
          :CONTINUE)
         (CL:SETQ ITER-004 (%%REST ITER-004))))
       (CL:SETQ ITER-003 (%%REST ITER-003))))
     (CL:SETQ SEEDS NEWSEEDS) (CL:SETQ NEWSEEDS (NEW-LIST))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (REVERSE FACTLIST)))

;;; (DEFUN (ALL-FACTS-OF-N (CONS OF PROPOSITION)) ...)

(CL:DEFUN %ALL-FACTS-OF-N (N INSTANCEREFS)
  "This is a generalization of `all-facts-of' (which see).  With `n' = 0
and only one instance this command behaves just like `all-facts-of'.
Otherwise, returns a cons list of all definite (TRUE or FALSE) propositions
that reference any of the instances listed in `instanceRefs', plus if `n' >= 1
all propositions that reference any instances that are arguments of
propositions collected in the previous step, plus if `n' >= 2... and so on.
That is, if we only consider binary propositions, this can be viewed as
growing a graph with instances as its nodes and predicates as its arcs
starting from the set of seed `instanceRefs' to depth `n'-1.
Caution: with a fully connected KB and large enough `n' this could return
the whole knowledge base.

The returned propositions include those asserted to be true or false by
default, but it does not include propositions that are found to be
true only by running the query engine.  Facts inferred to be true by
the forward chainer will be included.  Hence, the returned list of
facts may be longer in a context where the forward chainer has been
run then in one where it has not (see `run-forward-rules')."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (%LIST.THE-CONS-LIST (CALL-ALL-FACTS-OF-N N INSTANCEREFS)))

(CL:DEFUN ALL-FACTS-OF-N-EVALUATOR-WRAPPER (ARGUMENTS)
  (%ALL-FACTS-OF-N (%INTEGER-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))
   (%%REST ARGUMENTS)))

(CL:DEFMACRO ALL-FACTS-OF-N (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "This is a generalization of `all-facts-of' (which see).  With `n' = 0
and only one instance this command behaves just like `all-facts-of'.
Otherwise, returns a cons list of all definite (TRUE or FALSE) propositions
that reference any of the instances listed in `instanceRefs', plus if `n' >= 1
all propositions that reference any instances that are arguments of
propositions collected in the previous step, plus if `n' >= 2... and so on.
That is, if we only consider binary propositions, this can be viewed as
growing a graph with instances as its nodes and predicates as its arcs
starting from the set of seed `instanceRefs' to depth `n'-1.
Caution: with a fully connected KB and large enough `n' this could return
the whole knowledge base.

The returned propositions include those asserted to be true or false by
default, but it does not include propositions that are found to be
true only by running the query engine.  Facts inferred to be true by
the forward chainer will be included.  Hence, the returned list of
facts may be longer in a context where the forward chainer has been
run then in one where it has not (see `run-forward-rules')."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/ALL-FACTS-OF-N|)) (CL:MACRO-FUNCTION (CL:QUOTE ALL-FACTS-OF-N)))

(CL:DEFUN HELP-STARTUP-PROPAGATE1 ()
  (CL:PROGN
   (CL:SETQ SYM-PROPAGATE-LOGIC-DEFERRED-DEFAULT-PROPOSITIONS-INTERNAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "DEFERRED-DEFAULT-PROPOSITIONS-INTERNAL" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-EVALUATION-STATE-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATION-STATE-TABLE" NULL 0))
   (CL:SETQ KWD-PROPAGATE-POSTED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POSTED" NULL 2))
   (CL:SETQ SYM-PROPAGATE-LOGIC-EVALUATION-QUEUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATION-QUEUE" NULL 0))
   (CL:SETQ KWD-PROPAGATE-FORWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD" NULL 2))
   (CL:SETQ SYM-PROPAGATE-LOGIC-BACKWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD-ONLY?" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-FORWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-ONLY?" NULL 0))
   (CL:SETQ SGT-PROPAGATE-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SGT-PROPAGATE-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ
    SGT-PROPAGATE-LOGIC-F-COLLECT-FORWARD-CHAINING-RULES-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-COLLECT-FORWARD-CHAINING-RULES-MEMO-TABLE-000" NULL 1))
   (CL:SETQ KWD-PROPAGATE-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-PROPAGATE-LOGIC-FORWARD-CHAINING-QUEUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-CHAINING-QUEUE" NULL 0))
   (CL:SETQ KWD-PROPAGATE-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ KWD-PROPAGATE-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ SGT-PROPAGATE-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SYM-PROPAGATE-LOGIC-HYPOTHESIZED-INSTANCE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HYPOTHESIZED-INSTANCE?" NULL 0))
   (CL:SETQ KWD-PROPAGATE-PROPAGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPAGATE" NULL 2))
   (CL:SETQ SGT-PROPAGATE-PL-KERNEL-KB-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PROPAGATE-GOAL-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-TREE" NULL 2))
   (CL:SETQ KWD-PROPAGATE-SINGLETONS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SINGLETONS?" NULL 2))
   (CL:SETQ SGT-PROPAGATE-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ KWD-PROPAGATE-KB-UPDATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KB-UPDATE" NULL 2))
   (CL:SETQ KWD-PROPAGATE-META-KB-UPDATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-KB-UPDATE" NULL 2))
   (CL:SETQ KWD-PROPAGATE-META
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META" NULL 2))
   (CL:SETQ SGT-PROPAGATE-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PROPAGATE-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SGT-PROPAGATE-STELLA-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-PROPAGATE-EVALUATED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATED" NULL 2))
   (CL:SETQ KWD-PROPAGATE-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-PROPAGATE-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-PROPAGATE-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-PROPAGATE-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ SYM-PROPAGATE-LOGIC-ELABORATED-IN-WORLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ELABORATED-IN-WORLDS" NULL 0))
   (CL:SETQ KWD-PROPAGATE-ELABORATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ELABORATE" NULL 2))
   (CL:SETQ KWD-PROPAGATE-EXTENSIONAL-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIONAL-ASSERTION" NULL 2))
   (CL:SETQ SGT-PROPAGATE-PL-KERNEL-KB-INEQUALITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INEQUALITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPAGATE-STELLA-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-PROPAGATE-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ KWD-PROPAGATE-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ SGT-PROPAGATE-STELLA-LITERAL-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PROPAGATE-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ SGT-PROPAGATE-STELLA-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PROPAGATE-LOGIC-ALL-FACTS-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-FACTS-OF" NULL 0))
   (CL:SETQ KWD-PROPAGATE-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-PROPAGATE-LOGIC-CALL-ALL-FACTS-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CALL-ALL-FACTS-OF" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-RETRACT-FACTS-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-FACTS-OF" NULL 0))
   (CL:SETQ SGT-PROPAGATE-PL-KERNEL-KB-PHRASE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PHRASE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PROPAGATE-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ SYM-PROPAGATE-LOGIC-ALL-SENTENCES-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-SENTENCES-OF" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-ALL-FACTS-OF-N
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-FACTS-OF-N" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-STARTUP-PROPAGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-PROPAGATE" NULL 0))
   (CL:SETQ SYM-PROPAGATE-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-PROPAGATE2 ()
  (CL:PROGN
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT CONTEXT DEFERRED-DEFAULT-PROPOSITIONS-INTERNAL :TYPE (CONS OF PROPOSITION) :PUBLIC? TRUE :DOCUMENTATION \"List of propositions infered to be true or false by
default before we enter default propagation mode.\" :DEFAULT NULL :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "DEFERRED-DEFAULT-PROPOSITIONS"
    "(DEFUN (DEFERRED-DEFAULT-PROPOSITIONS (CONS OF PROPOSITION)) ((SELF CONTEXT)))"
    (CL:FUNCTION DEFERRED-DEFAULT-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFERRED-DEFAULT-PROPOSITIONS-SETTER"
    "(DEFUN DEFERRED-DEFAULT-PROPOSITIONS-SETTER ((SELF CONTEXT) (NEWVALUE (CONS OF PROPOSITION))))"
    (CL:FUNCTION DEFERRED-DEFAULT-PROPOSITIONS-SETTER) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT CONTEXT EVALUATION-QUEUE :TYPE (LIST OF PROPOSITION) :PUBLIC? TRUE :DOCUMENTATION \"List of propositions waiting for evaluation in 
*context*.\" :DEFAULT NULL :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT CONTEXT EVALUATION-STATE-TABLE :TYPE (HASH-TABLE OF PROPOSITION KEYWORD) :PUBLIC? TRUE :DOCUMENTATION \"Records which propositions have been evaluated at
least once in the world 'self'.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "EVALUATION-STATE"
    "(DEFUN (EVALUATION-STATE KEYWORD) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION EVALUATION-STATE) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATION-STATE-SETTER"
    "(DEFUN EVALUATION-STATE-SETTER ((PROPOSITION PROPOSITION) (STATE KEYWORD)))"
    (CL:FUNCTION EVALUATION-STATE-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "POST-FOR-EVALUATION"
    "(DEFUN POST-FOR-EVALUATION ((SELF PROPOSITION)) :PUBLIC? TRUE)"
    (CL:FUNCTION POST-FOR-EVALUATION) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT CONTEXT FORWARD-CHAINING-QUEUE :TYPE (LIST OF PROPOSITION) :PUBLIC? TRUE :DOCUMENTATION \"Queue of recently asserted or inferred propositions
having applicable forward rules.  Rules are triggered for each queue entry.\" :DEFAULT NULL :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-FORWARD-RULES"
    "(DEFUN (HELP-COLLECT-FORWARD-RULES (CONS OF KEY-VALUE-LIST)) ((DESCRIPTION DESCRIPTION) (RULES KEY-VALUE-LIST) (INDICES KEY-VALUE-LIST) (TOUCHEDDEFAULT? BOOLEAN) (BEENTHERE LIST)))"
    (CL:FUNCTION HELP-COLLECT-FORWARD-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-FORWARD-CHAINING-RULES"
    "(DEFUN (COLLECT-FORWARD-CHAINING-RULES (KEY-VALUE-LIST OF PROPOSITION BOOLEAN-WRAPPER) (KEY-VALUE-LIST OF FORWARD-CHAINING-INDEX BOOLEAN-WRAPPER)) ((DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION COLLECT-FORWARD-CHAINING-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "HAS-FORWARD-CHAINING-RULES?"
    "(DEFUN (HAS-FORWARD-CHAINING-RULES? BOOLEAN) ((DESCRIPTION DESCRIPTION) (PROPOSITION PROPOSITION)))"
    (CL:FUNCTION HAS-FORWARD-CHAINING-RULES?) NULL)
   (DEFINE-FUNCTION-OBJECT "POST-TO-FORWARD-CHAINING-QUEUE"
    "(DEFUN POST-TO-FORWARD-CHAINING-QUEUE ((SELF PROPOSITION) (WORLD WORLD)))"
    (CL:FUNCTION POST-TO-FORWARD-CHAINING-QUEUE) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-RULE-CONSEQUENT-TO-VECTOR"
    "(DEFUN APPLY-RULE-CONSEQUENT-TO-VECTOR ((CONSEQUENT DESCRIPTION) (ARGUMENTS ARGUMENTS-VECTOR) (RULE PROPOSITION) (TRIGGERDESCRIPTION DESCRIPTION) (TRIGGERPROPOSITION PROPOSITION) (TOUCHEDDEFAULT? BOOLEAN)))"
    (CL:FUNCTION APPLY-RULE-CONSEQUENT-TO-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "TRACE-FORWARD-RULE"
    "(DEFUN TRACE-FORWARD-RULE ((RULE PROPOSITION) (TRIGGER PROPOSITION) (CONSEQUENTS (CONS OF PROPOSITION))))"
    (CL:FUNCTION TRACE-FORWARD-RULE) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-FORWARD-RULES-TO-VECTOR"
    "(DEFUN APPLY-FORWARD-RULES-TO-VECTOR ((TRIGGERDESCRIPTION DESCRIPTION) (ARGUMENTS ARGUMENTS-VECTOR) (TRIGGERPROPOSITION PROPOSITION)))"
    (CL:FUNCTION APPLY-FORWARD-RULES-TO-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLICABLE-FORWARD-RULE?"
    "(DEFUN (APPLICABLE-FORWARD-RULE? BOOLEAN) ((RULE PROPOSITION) (ARGUMENTS ARGUMENTS-VECTOR)))"
    (CL:FUNCTION APPLICABLE-FORWARD-RULE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REACT-TO-INFERENCE-UPDATE ((SELF SKOLEM)))"
    (CL:FUNCTION REACT-TO-INFERENCE-UPDATE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REACT-TO-INFERENCE-UPDATE ((SELF PROPOSITION)))"
    (CL:FUNCTION REACT-TO-INFERENCE-UPDATE) NULL)
   (DEFINE-FUNCTION-OBJECT "REACT-TO-KB-UPDATE"
    "(DEFUN REACT-TO-KB-UPDATE ((CONTEXT CONTEXT) (OBJECT OBJECT)))"
    (CL:FUNCTION REACT-TO-KB-UPDATE) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-CONSTRAINT-PROPAGATION-QUEUES"
    "(DEFUN INITIALIZE-CONSTRAINT-PROPAGATION-QUEUES ((WORLD WORLD)))"
    (CL:FUNCTION INITIALIZE-CONSTRAINT-PROPAGATION-QUEUES) NULL)
   (DEFINE-FUNCTION-OBJECT "EXECUTE-CONSTRAINT-PROPAGATION-QUEUES"
    "(DEFUN EXECUTE-CONSTRAINT-PROPAGATION-QUEUES ())"
    (CL:FUNCTION EXECUTE-CONSTRAINT-PROPAGATION-QUEUES) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-NEW-PROPOSITION"
    "(DEFUN EVALUATE-NEW-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION EVALUATE-NEW-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-AND-PROPOSITION"
    "(DEFUN EVALUATE-AND-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION EVALUATE-AND-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-OR-PROPOSITION"
    "(DEFUN EVALUATE-OR-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION EVALUATE-OR-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-NOT-PROPOSITION"
    "(DEFUN EVALUATE-NOT-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION EVALUATE-NOT-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-EQUIVALENT-PROPOSITION"
    "(DEFUN EVALUATE-EQUIVALENT-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION EVALUATE-EQUIVALENT-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUATE-EQUIVALENT-FUNCTION-PROPOSITIONS"
    "(DEFUN EQUATE-EQUIVALENT-FUNCTION-PROPOSITIONS ((SELF PROPOSITION)))"
    (CL:FUNCTION EQUATE-EQUIVALENT-FUNCTION-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-FUNCTION-PROPOSITION"
    "(DEFUN EVALUATE-FUNCTION-PROPOSITION ((SELF PROPOSITION)) :PUBLIC? TRUE)"
    (CL:FUNCTION EVALUATE-FUNCTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-PREDICATE-PROPOSITION"
    "(DEFUN EVALUATE-PREDICATE-PROPOSITION ((SELF PROPOSITION)) :PUBLIC? TRUE)"
    (CL:FUNCTION EVALUATE-PREDICATE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-PROPOSITION"
    "(DEFUN EVALUATE-PROPOSITION ((SELF PROPOSITION)) :PUBLIC? TRUE)"
    (CL:FUNCTION EVALUATE-PROPOSITION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD MARK-AS-INCOHERENT ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION MARK-AS-INCOHERENT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD MARK-AS-INCOHERENT ((SELF SKOLEM)))"
    (CL:FUNCTION MARK-AS-INCOHERENT) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT LOGIC-OBJECT ELABORATED-IN-WORLDS :TYPE (LIST OF WORLD) :DOCUMENTATION \"List of worlds in which 'elaborate-instance' has
been applied to 'self'.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "RECURSIVELY-REACT-TO-INFERENCE-UPDATE"
    "(DEFUN RECURSIVELY-REACT-TO-INFERENCE-UPDATE ((SELF PROPOSITION)))"
    (CL:FUNCTION RECURSIVELY-REACT-TO-INFERENCE-UPDATE) NULL)
   (DEFINE-FUNCTION-OBJECT "ELABORATE-META-INSTANCE"
    "(DEFUN ELABORATE-META-INSTANCE ((SELF OBJECT)))"
    (CL:FUNCTION ELABORATE-META-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "ELABORATE-INSTANCE"
    "(DEFUN ELABORATE-INSTANCE ((SELF OBJECT)))"
    (CL:FUNCTION ELABORATE-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-REACHABLE-INEQUALITIES"
    "(DEFUN EVALUATE-REACHABLE-INEQUALITIES ((SELF LOGIC-OBJECT) (VISITEDLIST LIST)))"
    (CL:FUNCTION EVALUATE-REACHABLE-INEQUALITIES) NULL)
   (DEFINE-FUNCTION-OBJECT "ELABORATE-SURROGATES-IN-PROPOSITION"
    "(DEFUN ELABORATE-SURROGATES-IN-PROPOSITION ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION ELABORATE-SURROGATES-IN-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-FUNCTION-PROPOSITION-FACTS"
    "(DEFUN COLLECT-FUNCTION-PROPOSITION-FACTS ((SELF PROPOSITION) (FACTS (LIST OF PROPOSITION)) (BEENTHERE (LIST OF PROPOSITION)) (INCLUDEUNKNOWN? BOOLEAN)))"
    (CL:FUNCTION COLLECT-FUNCTION-PROPOSITION-FACTS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-FACTS"
    "(DEFUN HELP-COLLECT-FACTS ((SELF OBJECT) (FACTS (LIST OF PROPOSITION)) (BEENTHERE (LIST OF PROPOSITION)) (INCLUDEUNKNOWN? BOOLEAN)))"
    (CL:FUNCTION HELP-COLLECT-FACTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-FACTS-OF-INSTANCE"
    "(DEFUN (ALL-FACTS-OF-INSTANCE (LIST OF PROPOSITION)) ((SELF OBJECT) (INCLUDEUNKNOWNFACTS? BOOLEAN) (ELABORATE? BOOLEAN)) :DOCUMENTATION \"Return a list of all definite (TRUE or FALSE) propositions
attached to `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-FACTS-OF-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-FACTS-OF"
    "(DEFUN (ALL-FACTS-OF (CONS OF PROPOSITION)) ((INSTANCEREF NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Return a cons list of all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'.  This includes propositions
asserted to be true by default, but it does not include propositions
that are found to be TRUE only by running the query engine.  Facts
inferred to be TRUE by the forward chainer will be included.
Hence, the returned list of facts may be longer in a context where the
forward chainer has been run then in one where it has not (see
`run-forward-rules').\")" (CL:FUNCTION %ALL-FACTS-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "CALL-ALL-FACTS-OF"
    "(DEFUN (CALL-ALL-FACTS-OF (LIST OF PROPOSITION)) ((INSTANCEREF OBJECT)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? TRUE :DOCUMENTATION \"Return a list of all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'.\")"
    (CL:FUNCTION %CALL-ALL-FACTS-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRACT-FACTS-OF-INSTANCE"
    "(DEFUN RETRACT-FACTS-OF-INSTANCE ((SELF LOGIC-OBJECT)) :DOCUMENTATION \"Retract all definite (TRUE or FALSE) propositions attached to `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION RETRACT-FACTS-OF-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRACT-FACTS-OF"
    "(DEFUN RETRACT-FACTS-OF ((INSTANCEREF OBJECT)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Retract all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'.\")"
    (CL:FUNCTION %RETRACT-FACTS-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPLODE-VARIABLIZED-STRING"
    "(DEFUN (EXPLODE-VARIABLIZED-STRING LIST) ((STRING STRING)))"
    (CL:FUNCTION EXPLODE-VARIABLIZED-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "FACT-TO-SENTENCE"
    "(DEFUN (FACT-TO-SENTENCE STRING) ((SELF PROPOSITION) (PERIOD? BOOLEAN)))"
    (CL:FUNCTION FACT-TO-SENTENCE) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SENTENCES-OF"
    "(DEFUN (ALL-SENTENCES-OF (CONS OF STRING-WRAPPER)) ((INSTANCEREF OBJECT)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? TRUE :DOCUMENTATION \"Return a list of sentences describing facts about 'instanceRef'.\")"
    (CL:FUNCTION %ALL-SENTENCES-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "CALL-ALL-FACTS-OF-N"
    "(DEFUN (CALL-ALL-FACTS-OF-N (LIST OF PROPOSITION)) ((N INTEGER) (SEEDREFS CONS)))"
    (CL:FUNCTION CALL-ALL-FACTS-OF-N) NULL)
   (DEFINE-FUNCTION-OBJECT "FILTERED-ALL-FACTS-OF-N"
    "(DEFUN (FILTERED-ALL-FACTS-OF-N (LIST OF PROPOSITION)) ((N INTEGER) (SEEDREFS CONS) (FILTER FUNCTION-CODE)))"
    (CL:FUNCTION FILTERED-ALL-FACTS-OF-N) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-FACTS-OF-N"
    "(DEFUN (ALL-FACTS-OF-N (CONS OF PROPOSITION)) ((N INTEGER) |&REST| (INSTANCEREFS NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"This is a generalization of `all-facts-of' (which see).  With `n' = 0
and only one instance this command behaves just like `all-facts-of'.
Otherwise, returns a cons list of all definite (TRUE or FALSE) propositions
that reference any of the instances listed in `instanceRefs', plus if `n' >= 1
all propositions that reference any instances that are arguments of
propositions collected in the previous step, plus if `n' >= 2... and so on.
That is, if we only consider binary propositions, this can be viewed as
growing a graph with instances as its nodes and predicates as its arcs
starting from the set of seed `instanceRefs' to depth `n'-1.
Caution: with a fully connected KB and large enough `n' this could return
the whole knowledge base.

The returned propositions include those asserted to be true or false by
default, but it does not include propositions that are found to be
true only by running the query engine.  Facts inferred to be true by
the forward chainer will be included.  Hence, the returned list of
facts may be longer in a context where the forward chainer has been
run then in one where it has not (see `run-forward-rules').\")"
    (CL:FUNCTION %ALL-FACTS-OF-N)
    (CL:FUNCTION ALL-FACTS-OF-N-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "STARTUP-PROPAGATE"
    "(DEFUN STARTUP-PROPAGATE () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-PROPAGATE) NULL)
   (CL:LET*
    ((FUNCTION
      (LOOKUP-FUNCTION SYM-PROPAGATE-LOGIC-STARTUP-PROPAGATE)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-PROPAGATE-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupPropagate") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-PROPAGATE ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-PROPAGATE1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-PROPAGATE2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *FILLINGCONSTRAINTPROPAGATIONQUEUES?* BOOLEAN FALSE :DOCUMENTATION \"True if we are inside of 'react-to-kb-update'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DEFERINGDEFAULTFORWARDINFERENCES?* BOOLEAN FALSE :DOCUMENTATION \"True if we are propagating strict inferences, and
posting derived default propositions to temporary queues.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CURRENTLYEXECUTINGFORWARDCHAININGQUEUE* (LIST OF PROPOSITION) NULL :DOCUMENTATION \"Points to an active queue of propositions that will trigger
forward inference.  New queue entries are posted to a separate queue
attached to *context*.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *COLLECTFORWARDPROPOSITIONS* (CONS OF PROPOSITION) NULL :DOCUMENTATION \"Collect goes-true propositions produced by forward
chaining.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *JUST-IN-TIME-FORWARD-INFERENCE?* BOOLEAN TRUE :DOCUMENTATION \"If TRUE, ensures that forward propagation has
been applied to each instance 'touched' during a query.\")")
    (REGISTER-NATIVE-NAME SYM-PROPAGATE-LOGIC-ALL-FACTS-OF
     KWD-PROPAGATE-COMMON-LISP KWD-PROPAGATE-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPAGATE-LOGIC-CALL-ALL-FACTS-OF
     KWD-PROPAGATE-COMMON-LISP KWD-PROPAGATE-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPAGATE-LOGIC-RETRACT-FACTS-OF
     KWD-PROPAGATE-COMMON-LISP KWD-PROPAGATE-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPAGATE-LOGIC-ALL-SENTENCES-OF
     KWD-PROPAGATE-COMMON-LISP KWD-PROPAGATE-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPAGATE-LOGIC-ALL-FACTS-OF-N
     KWD-PROPAGATE-COMMON-LISP KWD-PROPAGATE-FUNCTION))))
