;;; -*- Mode: Lisp; Package: PLI; Syntax: COMMON-LISP; Base: 10 -*-

;;; pli.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:EVAL-WHEN (CL:COMPILE CL:LOAD CL:EVAL)
  (CL:UNLESS (CL:FIND-PACKAGE "PLI")
     (CL:DEFPACKAGE "PLI" (:USE))))

(CL:IN-PACKAGE "PLI")

;;; Auxiliary variables:

(CL:DEFVAR SGT-PLI-PLI-ENVIRONMENT STELLA::NULL)
(CL:DEFVAR SYM-PLI-LOGIC-LEVEL STELLA::NULL)
(CL:DEFVAR SGT-PLI-PLI-PL-ITERATOR STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-CURSOR STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-CONS STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-LIST STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-VECTOR STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-NULL STELLA::NULL)
(CL:DEFVAR SGT-PLI-LOGIC-SKOLEM STELLA::NULL)
(CL:DEFVAR SGT-PLI-LOGIC-LOGIC-OBJECT STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-GENERALIZED-SYMBOL STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-MODULE STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-CONTEXT STELLA::NULL)
(CL:DEFVAR SGT-PLI-LOGIC-COMPUTED-PROCEDURE STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-LITERAL-WRAPPER STELLA::NULL)
(CL:DEFVAR SGT-PLI-LOGIC-NAMED-DESCRIPTION STELLA::NULL)
(CL:DEFVAR SYM-PLI-PLI-?R STELLA::NULL)
(CL:DEFVAR SYM-PLI-PLI-?I STELLA::NULL)
(CL:DEFVAR SYM-PLI-PLI-?V STELLA::NULL)
(CL:DEFVAR SYM-PLI-PLI-F-GET-INFERRED-BINARY-PROPOSITION-VALUES-QUERY-000 STELLA::NULL)
(CL:DEFVAR SYM-PLI-LOGIC-ALL STELLA::NULL)
(CL:DEFVAR SYM-PLI-LOGIC-?X STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-AND STELLA::NULL)
(CL:DEFVAR SYM-PLI-LOGIC-FAIL STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-EXISTS STELLA::NULL)
(CL:DEFVAR SYM-PLI-LOGIC-?Y STELLA::NULL)
(CL:DEFVAR SYM-PLI-PLI-PROPER-SUBRELATION STELLA::NULL)
(CL:DEFVAR KWD-PLI-ISA STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-TRUE STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-FALSE STELLA::NULL)
(CL:DEFVAR KWD-PLI-CASE-SENSITIVE? STELLA::NULL)
(CL:DEFVAR KWD-PLI-SUBSET-OF STELLA::NULL)
(CL:DEFVAR KWD-PLI-ERROR STELLA::NULL)
(CL:DEFVAR KWD-PLI-RETRACT-TRUE STELLA::NULL)
(CL:DEFVAR KWD-PLI-ASSERT-TRUE STELLA::NULL)
(CL:DEFVAR SGT-PLI-LOGIC-PROPOSITION STELLA::NULL)
(CL:DEFVAR SYM-PLI-LOGIC-DESCRIPTION STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-INTEGER-WRAPPER STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-FLOAT-WRAPPER STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-NUMBER-WRAPPER STELLA::NULL)
(CL:DEFVAR SGT-PLI-STELLA-STRING-WRAPPER STELLA::NULL)
(CL:DEFVAR SYM-PLI-PLI-STARTUP-PLI STELLA::NULL)
(CL:DEFVAR SYM-PLI-STELLA-METHOD-STARTUP-CLASSNAME STELLA::NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL STELLA::*STARTUP-TIME-PHASE*
  STELLA::INCONSISTENT-TRUTH-VALUE STELLA::UNKNOWN-TRUTH-VALUE
  STELLA::FALSE-TRUTH-VALUE STELLA::DEFAULT-FALSE-TRUTH-VALUE
  STELLA::STANDARD-OUTPUT STELLA::EOL STELLA::KEYWORD-SYM
  STELLA::TRUE-TRUTH-VALUE STELLA::DEFAULT-TRUE-TRUTH-VALUE
  STELLA::*REVERSEPOLARITY?* STELLA::*ROOT-MODULE*
  STELLA::*LOGIC-MODULE* STELLA::*CONTEXT*
  STELLA::*KIF-SENTENCE-OPERATORS* STELLA::*KIF-TERM-OPERATORS*
  STELLA::NULL-INTEGER STELLA::*MODULE* STELLA::NIL
  STELLA::*POWERLOOM-LOCK* STELLA::*BOOTSTRAP-LOCK*))

;;; (DEFGLOBAL *POWERLOOM-INITIALIZED?* ...)

(CL:DEFVAR *POWERLOOM-INITIALIZED?* CL:NIL)

;;; (DEFUN INITIALIZE ...)

(CL:DEFUN INITIALIZE ()
  "Initialize the PowerLoom logic system.  This function
needs to be called by all applications before using PowerLoom.  If it
is called more than once, every call after the first one is a no-op."
  (STELLA::WITH-PROCESS-LOCK STELLA::*BOOTSTRAP-LOCK*
   (CL:WHEN (CL:NOT *POWERLOOM-INITIALIZED?*)
    (STELLA::STARTUP-LOGIC-SYSTEM))))

;;; (DEFUN RESET-POWERLOOM ...)

(CL:DEFUN RESET-POWERLOOM ()
  "Reset PowerLoom to its initial state.
CAUTION: This will destroy all loaded knowledge bases and might break other
loaded STELLA systems if they do reference PowerLoom symbols in their code."
  (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
   (STELLA::RESET-POWERLOOM)))

;;; (DEFUN CLEAR-CACHES ...)

(CL:DEFUN CLEAR-CACHES ()
  "Clear all query and memoization caches."
  (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
   (STELLA::CLEAR-CACHES)))

;;; (DEFCLASS ENVIRONMENT ...)

(CL:DEFCLASS ENVIRONMENT (STELLA::STANDARD-OBJECT)
  ((STELLA::LEVEL :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR STELLA::%LEVEL)))

(CL:DEFUN NEW-ENVIRONMENT ()
  (CL:LET* ((SELF STELLA::NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE ENVIRONMENT)))
   (CL:SETF (STELLA::%LEVEL SELF) STELLA::NULL-STRING) SELF))

(CL:DEFMETHOD STELLA::PRIMARY-TYPE ((SELF ENVIRONMENT))
  SGT-PLI-PLI-ENVIRONMENT)

(CL:DEFUN ACCESS-ENVIRONMENT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PLI-LOGIC-LEVEL)
    (CL:IF SETVALUE?
     (CL:SETF (STELLA::%LEVEL SELF) (STELLA::%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (STELLA::WRAP-STRING (STELLA::%LEVEL SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR
      (STELLA::NEW-STELLA-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD STELLA::PRINT-OBJECT ((SELF ENVIRONMENT) STREAM)
  (STELLA::%%PRINT-STREAM STREAM "|ENV|" (STELLA::%LEVEL SELF)))

;;; (DEFCONSTANT ASSERTION-ENV ...)

(CL:DEFVAR ASSERTION-ENV STELLA::NULL)

;;; (DEFCONSTANT TAXONOMIC-ENV ...)

(CL:DEFVAR TAXONOMIC-ENV STELLA::NULL)

;;; (DEFCONSTANT INFERENCE-ENV ...)

(CL:DEFVAR INFERENCE-ENV STELLA::NULL)

;;; (DEFCLASS PL-ITERATOR ...)

(CL:DEFCLASS PL-ITERATOR (STELLA::ITERATOR)
  ((STELLA::CURSOR :ALLOCATION :INSTANCE :ACCESSOR STELLA::%CURSOR)))

(CL:DEFUN NEW-PL-ITERATOR ()
  (CL:LET* ((SELF STELLA::NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PL-ITERATOR)))
   (CL:SETF (STELLA::%FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (STELLA::%VALUE SELF) STELLA::NULL)
   (CL:SETF (STELLA::%CURSOR SELF) STELLA::NULL) SELF))

(CL:DEFMETHOD STELLA::PRIMARY-TYPE ((SELF PL-ITERATOR))
  SGT-PLI-PLI-PL-ITERATOR)

(CL:DEFUN ACCESS-PL-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PLI-STELLA-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (STELLA::%CURSOR SELF) VALUE)
     (CL:SETQ VALUE (STELLA::%CURSOR SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR
      (STELLA::NEW-STELLA-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD STELLA::NEXT? ((SELF PL-ITERATOR))
  "Advance the PL-Iterator `self' and return `true' if more
elements are available, `false' otherwise."
  (CL:LET* ((CURSOR (STELLA::%CURSOR SELF)))
   (CL:WHEN (CL:EQ CURSOR STELLA::NIL)
    (CL:SETF (STELLA::%VALUE SELF) STELLA::NULL)
    (CL:RETURN-FROM STELLA::NEXT? CL:NIL))
   (CL:SETF (STELLA::%VALUE SELF) (STELLA::%%VALUE CURSOR))
   (CL:SETF (STELLA::%CURSOR SELF) (STELLA::%%REST CURSOR)) CL:T))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD STELLA::EMPTY? ((SELF PL-ITERATOR))
  "Return TRUE if the iterator `self' has no more elements."
  (CL:EQ (STELLA::%CURSOR SELF) STELLA::NIL))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD STELLA::LENGTH ((SELF PL-ITERATOR))
  "Number of items remaining in `self'.  Non destructive."
  (STELLA::LENGTH (STELLA::%CURSOR SELF)))

;;; (DEFGLOBAL EMPTY-PL-ITERATOR ...)

(CL:DEFVAR EMPTY-PL-ITERATOR STELLA::NULL
  "Iterator that generates no values.")

;;; (DEFUN (CONS-TO-PL-ITERATOR PL-ITERATOR) ...)

(CL:DEFUN CONS-TO-PL-ITERATOR (SELF)
  "Convert a Stella cons list into an API iterator."
  (CL:IF (CL:EQ SELF STELLA::NIL) EMPTY-PL-ITERATOR
   (CL:LET* ((SELF-000 (NEW-PL-ITERATOR)))
    (CL:SETF (STELLA::%CURSOR SELF-000) SELF)
    (CL:LET* ((VALUE-000 SELF-000)) VALUE-000))))

;;; (DEFUN (LIST-TO-PL-ITERATOR PL-ITERATOR) ...)

(CL:DEFUN LIST-TO-PL-ITERATOR (SELF)
  "Convert a Stella list into an API iterator."
  (CL:IF (STELLA::EMPTY? SELF) EMPTY-PL-ITERATOR
   (CONS-TO-PL-ITERATOR (STELLA::%THE-CONS-LIST SELF))))

;;; (DEFUN (ITERATOR-TO-PL-ITERATOR PL-ITERATOR) ...)

(CL:DEFUN ITERATOR-TO-PL-ITERATOR (SELF)
  "Convert an arbitrary Stella iterator into an API iterator."
  (CONS-TO-PL-ITERATOR (STELLA::CONSIFY SELF)))

;;; (DEFMETHOD (LISTIFY LIST) ...)

(CL:DEFMETHOD STELLA::LISTIFY ((SELF PL-ITERATOR))
  "Convert `self' into a Stella LIST."
  (CL:LET* ((SELF-000 (STELLA::NEW-LIST)))
   (CL:LET* ((VALUE-001 STELLA::NIL))
    (CL:LET*
     ((X STELLA::NULL) (ITER-000 SELF) (COLLECT-000 STELLA::NULL))
     (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
      (CL:SETQ X (STELLA::%VALUE ITER-000))
      (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (STELLA::CONS X STELLA::NIL))
        (CL:IF (CL:EQ VALUE-001 STELLA::NIL)
         (CL:SETQ VALUE-001 COLLECT-000)
         (STELLA::ADD-CONS-TO-END-OF-CONS-LIST VALUE-001 COLLECT-000)))
       (CL:PROGN
        (CL:SETF (STELLA::%%REST COLLECT-000)
         (STELLA::CONS X STELLA::NIL))
        (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000))))))
    (CL:SETF (STELLA::%THE-CONS-LIST SELF-000) VALUE-001))
   (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))

;;; (DEFMETHOD (CONSIFY CONS) ...)

(CL:DEFMETHOD STELLA::CONSIFY ((SELF PL-ITERATOR))
  "Convert `self' into a Stella CONS."
  (CL:LET* ((VALUE-000 STELLA::NIL))
   (CL:LET*
    ((X STELLA::NULL) (ITER-000 SELF) (COLLECT-000 STELLA::NULL))
    (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
     (CL:SETQ X (STELLA::%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (STELLA::CONS X STELLA::NIL))
       (CL:IF (CL:EQ VALUE-000 STELLA::NIL)
        (CL:SETQ VALUE-000 COLLECT-000)
        (STELLA::ADD-CONS-TO-END-OF-CONS-LIST VALUE-000 COLLECT-000)))
      (CL:PROGN
       (CL:SETF (STELLA::%%REST COLLECT-000)
        (STELLA::CONS X STELLA::NIL))
       (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000))))))
   (CL:LET* ((VALUE-001 VALUE-000)) VALUE-001)))

;;; (DEFUN (SAFELY-GET-OBJECT OBJECT) ...)

(CL:DEFUN SAFELY-GET-OBJECT (NAME MODULE ENVIRONMENT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ NAME STELLA::NULL-STRING)
   (CL:RETURN-FROM SAFELY-GET-OBJECT STELLA::NULL))
  (CL:LET* ((OBJECT (GET-OBJECT NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:EQ OBJECT STELLA::NULL)
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000)
      "Can't find an object named `" NAME "'")
     (CL:ERROR
      (STELLA::NEW-NO-SUCH-OBJECT-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000))))
    OBJECT)))

;;; (DEFUN (SAFELY-GET-CONCEPT OBJECT) ...)

(CL:DEFUN SAFELY-GET-CONCEPT (NAME MODULE ENVIRONMENT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ NAME STELLA::NULL-STRING)
   (CL:RETURN-FROM SAFELY-GET-CONCEPT STELLA::NULL))
  (CL:LET* ((OBJECT (GET-CONCEPT NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:EQ OBJECT STELLA::NULL)
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000)
      "Can't find a concept named `" NAME "'")
     (CL:ERROR
      (STELLA::NEW-NO-SUCH-OBJECT-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000))))
    OBJECT)))

;;; (DEFUN (SAFELY-GET-RELATION OBJECT) ...)

(CL:DEFUN SAFELY-GET-RELATION (NAME MODULE ENVIRONMENT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ NAME STELLA::NULL-STRING)
   (CL:RETURN-FROM SAFELY-GET-RELATION STELLA::NULL))
  (CL:LET* ((OBJECT (GET-RELATION NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:EQ OBJECT STELLA::NULL)
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000)
      "Can't find a relation named `" NAME "'")
     (CL:ERROR
      (STELLA::NEW-NO-SUCH-OBJECT-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000))))
    OBJECT)))

;;; (DEFUN (SAFELY-GET-MODULE CONTEXT) ...)

(CL:DEFUN SAFELY-GET-MODULE (NAME ENVIRONMENT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:SETQ ENVIRONMENT ENVIRONMENT)
  (CL:WHEN
   (CL:OR (CL:EQ NAME STELLA::NULL-STRING)
    (STELLA::STRING-EQL? NAME ""))
   (CL:RETURN-FROM SAFELY-GET-MODULE STELLA::*MODULE*))
  (STELLA::GET-STELLA-MODULE NAME CL:T))

;;; (DEFUN (SAFELY-GET-OBJECT-OR-NULL OBJECT) ...)

(CL:DEFUN SAFELY-GET-OBJECT-OR-NULL (NAME MODULE ENVIRONMENT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN
   (CL:OR (CL:EQ MODULE STELLA::NULL) (CL:EQ NAME STELLA::NULL-STRING)
    (STELLA::STRING-EQL? NAME "") (STELLA::STRING-EQUAL? NAME "null"))
   (CL:RETURN-FROM SAFELY-GET-OBJECT-OR-NULL STELLA::NULL))
  (CL:HANDLER-CASE
   (CL:RETURN-FROM SAFELY-GET-OBJECT-OR-NULL
    (GET-OBJECT NAME MODULE ENVIRONMENT))
   (STELLA::NO-SUCH-OBJECT-EXCEPTION () STELLA::NULL)))

;;; (DEFUN (SEQUENCE-TO-CONS-LIST CONS) ...)

(CL:DEFUN SEQUENCE-TO-CONS-LIST (SEQUENCE)
  (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE SEQUENCE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-PLI-STELLA-CONS) (CL:PROGN SEQUENCE))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-STELLA-LIST)
     (CL:PROGN (STELLA::%THE-CONS-LIST SEQUENCE)))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-STELLA-VECTOR)
     (CL:PROGN
      (CL:LET* ((RESULT STELLA::NIL))
       (CL:LET*
        ((I STELLA::NULL-INTEGER) (ITER-000 0)
         (UPPER-BOUND-000 (STELLA::LENGTH SEQUENCE))
         (COLLECT-000 STELLA::NULL))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
        (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
         (CL:SETQ I ITER-000)
         (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-000
            (STELLA::CONS
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (STELLA::%THE-ARRAY SEQUENCE))
              I)
             STELLA::NIL))
           (CL:IF (CL:EQ RESULT STELLA::NIL)
            (CL:SETQ RESULT COLLECT-000)
            (STELLA::ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
          (CL:PROGN
           (CL:SETF (STELLA::%%REST COLLECT-000)
            (STELLA::CONS
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (STELLA::%THE-ARRAY SEQUENCE))
              I)
             STELLA::NIL))
           (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000))))
         (CL:SETQ ITER-000 (CL:1+ ITER-000))))
       RESULT)))
    (CL:T
     (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
      (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000)
       "Don't know how to convert object of type `"
       (STELLA::PRIMARY-TYPE SEQUENCE) "' into a cons list.")
      (CL:ERROR
       (STELLA::NEW-STELLA-EXCEPTION
        (STELLA::THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (EXPLODE-STRING-LIST CONS) ...)

(CL:DEFUN EXPLODE-STRING-LIST (STRINGLIST MODULE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGLIST))
  #+MCL
  (CL:CHECK-TYPE STRINGLIST CL:SIMPLE-STRING)
  (CL:LET*
   ((STELLA::*MODULE* MODULE) (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:LET*
    ((EXPRESSION (STELLA::READ-S-EXPRESSION-FROM-STRING STRINGLIST))
     (TERM STELLA::NULL) (RESULT STELLA::NIL))
    (CL:LET*
     ((REF STELLA::NULL) (ITER-000 EXPRESSION)
      (COLLECT-000 STELLA::NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 STELLA::NIL)) DO
      (CL:SETQ REF (STELLA::%%VALUE ITER-000))
      (CL:SETQ TERM
       (CL:IF (CL:EQ REF SYM-PLI-STELLA-NULL) STELLA::NULL
        (STELLA::EVALUATE-TERM REF)))
      (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (STELLA::CONS TERM STELLA::NIL))
        (CL:IF (CL:EQ RESULT STELLA::NIL) (CL:SETQ RESULT COLLECT-000)
         (STELLA::ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
       (CL:PROGN
        (CL:SETF (STELLA::%%REST COLLECT-000)
         (STELLA::CONS TERM STELLA::NIL))
        (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000))))
      (CL:SETQ ITER-000 (STELLA::%%REST ITER-000))))
    RESULT)))

;;; (DEFUN (LEGAL-OPERATOR? BOOLEAN) ...)

(CL:DEFUN LEGAL-OPERATOR? (OPERATOR)
  (CL:OR (STELLA::MEMBER? STELLA::*KIF-SENTENCE-OPERATORS* OPERATOR)
   (STELLA::MEMBER? STELLA::*KIF-TERM-OPERATORS* OPERATOR)
   (STELLA::MEMBER?
    (STELLA::GET-QUOTED-TREE
     "((<=>> <<=> <<=>> <~> <~>> <<~> <<~>> ABOUT <<= =>> <~ ~> <<~ ~>>) \"/PLI\")"
     "/PLI")
    OPERATOR)))

;;; (DEFUN (GET-KEYWORD KEYWORD) ...)

(CL:DEFUN GET-KEYWORD (NAME)
  "Returns the Stella KEYWORD `name' if it exists.  Case sensitive."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (STELLA::LOOKUP-KEYWORD NAME))

;;; (DEFUN (GET-SYMBOL SYMBOL) ...)

(CL:DEFUN GET-SYMBOL (NAME MODULE ENVIRONMENT)
  "Returns the Stella SYMBOL `name' visible in `module' if it
exists.  `name' is ALWAYS treated case sensitively."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::LOOKUP-SYMBOL NAME)))))

;;; (DEFUN (GET-OPERATOR SYMBOL) ...)

(CL:DEFUN GET-OPERATOR (NAME)
  "Returns the logical operator object (a Stella SYMBOL) for `name'.
If no such operator exists then a `no-such-object' exception is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:NOT (STELLA::ALL-UPPER-CASE-STRING? NAME))
   (CL:SETQ NAME (STELLA::STRING-UPCASE NAME)))
  (CL:LET*
   ((OPERATOR
     (STELLA::LOOKUP-SYMBOL-IN-MODULE NAME STELLA::*LOGIC-MODULE*
      CL:NIL)))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ OPERATOR STELLA::NULL))
     (LEGAL-OPERATOR? OPERATOR))
    OPERATOR
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000)
      "No operator named `" NAME "'")
     (CL:ERROR
      (STELLA::NEW-NO-SUCH-OBJECT-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (GET-OBJECT OBJECT) ...)

(CL:DEFUN GET-OBJECT (NAME MODULE ENVIRONMENT)
  "Look for an object named `name' that is local to
or visible from the module `module'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::GET-INSTANCE (STELLA::INTERN-STELLA-NAME NAME))))))

;;; (DEFUN (S-GET-OBJECT OBJECT) ...)

(CL:DEFUN S-GET-OBJECT (NAME MODULE-NAME ENVIRONMENT)
  "Look for an object named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (GET-OBJECT NAME (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)
   ENVIRONMENT))

;;; (DEFUN (GET-CONCEPT LOGIC-OBJECT) ...)

(CL:DEFUN GET-CONCEPT (NAME MODULE ENVIRONMENT)
  "Return a class/concept named `name' that is local to
or visible from the module `module'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::GET-CLASS (STELLA::INTERN-STELLA-NAME NAME))))))

;;; (DEFUN (S-GET-CONCEPT LOGIC-OBJECT) ...)

(CL:DEFUN S-GET-CONCEPT (NAME MODULE-NAME ENVIRONMENT)
  "Return a class/concept named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (GET-CONCEPT NAME (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)
   ENVIRONMENT))

;;; (DEFUN (GET-RELATION LOGIC-OBJECT) ...)

(CL:DEFUN GET-RELATION (NAME MODULE ENVIRONMENT)
  "Return a concept or relation named `name' that is local to
or visible from the module `module'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::GET-RELATION (STELLA::INTERN-STELLA-NAME NAME))))))

;;; (DEFUN (S-GET-RELATION LOGIC-OBJECT) ...)

(CL:DEFUN S-GET-RELATION (NAME MODULE-NAME ENVIRONMENT)
  "Return a concept or relation named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (GET-RELATION NAME (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)
   ENVIRONMENT))

;;; (DEFUN (GET-NAME-IN-MODULE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:T) CL:SIMPLE-STRING)
  GET-NAME-IN-MODULE))
(CL:DEFUN GET-NAME-IN-MODULE (OBJ MODULE ENVIRONMENT)
  "Return the name, qualified as necessary, so that `obj' can be found from
`module'.  If there is no name for the object return `null'."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE OBJ)))
      (CL:COND
       ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-SKOLEM)
        (CL:PROGN STELLA::NULL-STRING))
       ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-LOGIC-OBJECT)
        (CL:PROGN (STELLA::STRINGIFY (STELLA::OBJECT-NAME OBJ))))
       ((STELLA::SUBTYPE-OF? TEST-VALUE-000
         SGT-PLI-STELLA-GENERALIZED-SYMBOL)
        (CL:PROGN (STELLA::STRINGIFY OBJ)))
       ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-STELLA-MODULE)
        (CL:PROGN (STELLA::%MODULE-FULL-NAME OBJ)))
       ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-STELLA-CONTEXT)
        (CL:PROGN (STELLA::CONTEXT-NAME OBJ)))
       ((STELLA::SUBTYPE-OF? TEST-VALUE-000
         SGT-PLI-LOGIC-COMPUTED-PROCEDURE)
        (CL:PROGN
         (STELLA::STRINGIFY (STELLA::%SURROGATE-VALUE-INVERSE OBJ))))
       (CL:T STELLA::NULL-STRING)))))))

;;; (DEFUN (GET-NAME STRING) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) GET-NAME))
(CL:DEFUN GET-NAME (OBJ)
  "Return the fully qualified name of `obj', if it has one.  Otherwise return `null'."
  (GET-NAME-IN-MODULE OBJ STELLA::*ROOT-MODULE* STELLA::NULL))

;;; (DEFUN (GET-SHORT-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) GET-SHORT-NAME))
(CL:DEFUN GET-SHORT-NAME (OBJ)
  "Return the short name of `obj', if it has one.  Otherwise return `null'."
  (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE OBJ)))
   (CL:COND
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-SKOLEM)
     (CL:PROGN STELLA::NULL-STRING))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-LOGIC-OBJECT)
     (CL:PROGN (STELLA::OBJECT-NAME-STRING OBJ)))
    ((STELLA::SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN (STELLA::CONCATENATE ":" (STELLA::%SYMBOL-NAME OBJ))))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000
      SGT-PLI-STELLA-GENERALIZED-SYMBOL)
     (CL:PROGN (STELLA::%SYMBOL-NAME OBJ)))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-STELLA-CONTEXT)
     (CL:PROGN (STELLA::CONTEXT-NAME OBJ)))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000
      SGT-PLI-LOGIC-COMPUTED-PROCEDURE)
     (CL:PROGN
      (STELLA::%SYMBOL-NAME (STELLA::%SURROGATE-VALUE-INVERSE OBJ))))
    (CL:T STELLA::NULL-STRING))))

;;; (DEFUN (OBJECT-TO-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) OBJECT-TO-STRING))
(CL:DEFUN OBJECT-TO-STRING (SELF)
  "Return a printed representation of the term `self' as a string."
  (CL:IF (CL:EQ SELF STELLA::NULL) STELLA::NULL-STRING
   (CL:LET* ((STELLA::*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL STELLA::*PRINTREADABLY?*))
    (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE SELF)))
     (CL:COND
      ((STELLA::SUBTYPE-OF-STRING? TEST-VALUE-000)
       (CL:PROGN (STELLA::%WRAPPER-VALUE SELF)))
      ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-SKOLEM)
       (CL:PROGN
        (CL:LET* ((VALUE (STELLA::VALUE-OF SELF)))
         (CL:IF (CL:EQ VALUE SELF) (STELLA::STRINGIFY SELF)
          (OBJECT-TO-STRING VALUE)))))
      ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-PLI-PL-ITERATOR)
       (CL:PROGN (STELLA::STRINGIFY (STELLA::CONSIFY SELF))))
      (CL:T (STELLA::STRINGIFY SELF)))))))

;;; (DEFUN (OBJECT-TO-INTEGER INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) OBJECT-TO-INTEGER))
(CL:DEFUN OBJECT-TO-INTEGER (SELF)
  "Coerce `self' to an integer, or throw a Stella Exception if the coersion is not feasible.
Floating point values will be coerced by rounding."
  (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET* ((VALUE (STELLA::VALUE-OF SELF)))
       (CL:IF (CL:EQ VALUE SELF)
        (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
         (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000)
          "Can't coerce `" SELF "' to an integer.")
         (CL:ERROR
          (STELLA::NEW-STELLA-EXCEPTION
           (STELLA::THE-STRING-READER STREAM-000))))
        (OBJECT-TO-INTEGER VALUE)))))
    ((STELLA::SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN (STELLA::%WRAPPER-VALUE SELF)))
    ((STELLA::SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN (STELLA::ROUND (STELLA::%WRAPPER-VALUE SELF))))
    (CL:T
     (CL:LET* ((STREAM-001 (STELLA::NEW-OUTPUT-STRING-STREAM)))
      (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-001)
       "Can't coerce `" SELF "' to an integer.")
      (CL:ERROR
       (STELLA::NEW-STELLA-EXCEPTION
        (STELLA::THE-STRING-READER STREAM-001))))))))

;;; (DEFUN (OBJECT-TO-FLOAT FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT) OBJECT-TO-FLOAT))
(CL:DEFUN OBJECT-TO-FLOAT (SELF)
  "Coerce `self' to a float, or throw a Stella Exception if the coersion is not feasible."
  (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET* ((VALUE (STELLA::VALUE-OF SELF)))
       (CL:IF (CL:EQ VALUE SELF)
        (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
         (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000)
          "Can't coerce `" SELF "' to a float.")
         (CL:ERROR
          (STELLA::NEW-STELLA-EXCEPTION
           (STELLA::THE-STRING-READER STREAM-000))))
        (OBJECT-TO-FLOAT VALUE)))))
    ((STELLA::SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN (STELLA::NUMBER-WRAPPER-TO-FLOAT SELF)))
    ((STELLA::SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN (STELLA::%WRAPPER-VALUE SELF)))
    (CL:T
     (CL:LET* ((STREAM-001 (STELLA::NEW-OUTPUT-STRING-STREAM)))
      (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-001)
       "Can't coerce `" SELF "' to a float.")
      (CL:ERROR
       (STELLA::NEW-STELLA-EXCEPTION
        (STELLA::THE-STRING-READER STREAM-001))))))))

;;; (DEFUN (OBJECT-TO-PARSABLE-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  OBJECT-TO-PARSABLE-STRING))
(CL:DEFUN OBJECT-TO-PARSABLE-STRING (SELF)
  "Return a string representing a printed
representation of the object `self'.  Like `object-to-string', but puts
escaped double quotes around strings."
  (CL:COND
   ((STELLA::SUBTYPE-OF-STRING? (STELLA::SAFE-PRIMARY-TYPE SELF))
    (CL:PROGN
     (STELLA::CONCATENATE "\"" (STELLA::%WRAPPER-VALUE SELF) "\"")))
   (CL:T (OBJECT-TO-STRING SELF))))

;;; (DEFGLOBAL *LITERAL-CONCEPT* ...)

(CL:DEFVAR *LITERAL-CONCEPT* STELLA::NULL)

;;; (DEFGLOBAL *STRING-CONCEPT* ...)

(CL:DEFVAR *STRING-CONCEPT* STELLA::NULL)

;;; (DEFGLOBAL *INTEGER-CONCEPT* ...)

(CL:DEFVAR *INTEGER-CONCEPT* STELLA::NULL)

;;; (DEFGLOBAL *FLOAT-CONCEPT* ...)

(CL:DEFVAR *FLOAT-CONCEPT* STELLA::NULL)

;;; (DEFUN (STRING-TO-OBJECT OBJECT) ...)

(CL:DEFUN STRING-TO-OBJECT (STRING TYPE MODULE ENVIRONMENT)
  "Evaluate `string' with respect to `module' and `environment'
and return the corresponding logical term.  `type' is a concept used to assist the
correct interpretation of `string'.

Currently `type' only has an effect on the interpretation of literal types."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET* ((OBJ (STELLA::READ-S-EXPRESSION-FROM-STRING STRING)))
      (CL:COND
       ((STELLA::SUBTYPE-OF? (STELLA::SAFE-PRIMARY-TYPE OBJ)
         SGT-PLI-STELLA-LITERAL-WRAPPER)
        (CL:PROGN
         (CL:WHEN (CL:EQ TYPE STELLA::NULL)
          (CL:RETURN-FROM STRING-TO-OBJECT OBJ))
         (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE OBJ)))
          (CL:COND
           ((STELLA::SUBTYPE-OF-STRING? TEST-VALUE-000)
            (CL:PROGN
             (CL:IF (STELLA::SUBRELATION-OF? TYPE *STRING-CONCEPT*) OBJ
              (CL:LET*
               ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
               (STELLA::%%PRINT-STREAM
                (STELLA::%NATIVE-STREAM STREAM-000)
                "String argument found, but `" TYPE
                "' is not a subconcept of `" *STRING-CONCEPT* "'")
               (CL:ERROR
                (STELLA::NEW-PARSING-ERROR
                 (STELLA::THE-STRING-READER STREAM-000)))))))
           ((STELLA::SUBTYPE-OF-INTEGER? TEST-VALUE-000)
            (CL:PROGN
             (CL:COND
              ((STELLA::SUBRELATION-OF? TYPE *INTEGER-CONCEPT*) OBJ)
              ((STELLA::SUBRELATION-OF? TYPE *FLOAT-CONCEPT*)
               (STELLA::WRAP-FLOAT
                (CL:FLOAT (STELLA::%WRAPPER-VALUE OBJ) 0.0d0)))
              (CL:T (GET-OBJECT STRING MODULE ENVIRONMENT)))))
           ((STELLA::SUBTYPE-OF-FLOAT? TEST-VALUE-000)
            (CL:PROGN
             (CL:COND
              ((STELLA::SUBRELATION-OF? TYPE *FLOAT-CONCEPT*) OBJ)
              (CL:T (GET-OBJECT STRING MODULE ENVIRONMENT)))))
           (CL:T
            (CL:LET* ((STREAM-001 (STELLA::NEW-OUTPUT-STRING-STREAM)))
             (STELLA::%%PRINT-STREAM
              (STELLA::%NATIVE-STREAM STREAM-001) "`" TEST-VALUE-000
              "' is not a valid case option")
             (CL:ERROR
              (STELLA::NEW-STELLA-EXCEPTION
               (STELLA::THE-STRING-READER STREAM-001)))))))))
       (CL:T
        (CL:COND
         ((CL:EQ TYPE STELLA::NULL)
          (GET-OBJECT STRING MODULE ENVIRONMENT))
         ((STELLA::SUBRELATION-OF? TYPE *STRING-CONCEPT*)
          (STELLA::WRAP-STRING STRING))
         ((STELLA::SUBRELATION-OF? TYPE *LITERAL-CONCEPT*)
          (CL:LET* ((STREAM-002 (STELLA::NEW-OUTPUT-STRING-STREAM)))
           (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-002)
            "`" STRING "' is a non-literal, but `" TYPE
            "' is a subconcept of `" *LITERAL-CONCEPT* "'")
           (CL:ERROR
            (STELLA::NEW-PARSING-ERROR
             (STELLA::THE-STRING-READER STREAM-002)))))
         (CL:T (GET-OBJECT STRING MODULE ENVIRONMENT))))))))))

;;; (DEFUN (HELP-GET-TRUE-EXTENSION-MEMBERS (CONS OF PROPOSITION)) ...)

(CL:DEFUN HELP-GET-TRUE-EXTENSION-MEMBERS (RELATION SPECIALIZE?)
  (CL:LET* ((VALUE-000 STELLA::NIL))
   (CL:LET*
    ((P STELLA::NULL)
     (ITER-000 (STELLA::ALL-EXTENSION-MEMBERS RELATION))
     (COLLECT-000 STELLA::NULL))
    (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
     (CL:SETQ P (STELLA::%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:NOT (STELLA::DELETED? P))
       (CL:IF STELLA::*REVERSEPOLARITY?* (STELLA::FALSE? P)
        (CL:OR (STELLA::TRUE? P)
         (STELLA::FUNCTION-WITH-DEFINED-VALUE? P))))
      (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (STELLA::CONS P STELLA::NIL))
        (CL:IF (CL:EQ VALUE-000 STELLA::NIL)
         (CL:SETQ VALUE-000 COLLECT-000)
         (STELLA::ADD-CONS-TO-END-OF-CONS-LIST VALUE-000 COLLECT-000)))
       (CL:PROGN
        (CL:SETF (STELLA::%%REST COLLECT-000)
         (STELLA::CONS P STELLA::NIL))
        (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000)))))))
   (CL:LET* ((RESULT VALUE-000))
    (CL:WHEN SPECIALIZE?
     (CL:LET*
      ((SUB STELLA::NULL)
       (ITER-001 (STELLA::ALL-SUBCOLLECTIONS RELATION)))
      (CL:LOOP WHILE (STELLA::NEXT? ITER-001) DO
       (CL:SETQ SUB (STELLA::%VALUE ITER-001))
       (CL:WHEN (STELLA::ISA? SUB SGT-PLI-LOGIC-NAMED-DESCRIPTION)
        (CL:LET*
         ((P STELLA::NULL)
          (ITER-002 (STELLA::ALL-EXTENSION-MEMBERS SUB)))
         (CL:LOOP WHILE (STELLA::NEXT? ITER-002) DO
          (CL:SETQ P (STELLA::%VALUE ITER-002))
          (CL:WHEN
           (CL:AND (CL:NOT (STELLA::DELETED? P))
            (CL:IF STELLA::*REVERSEPOLARITY?* (STELLA::FALSE? P)
             (CL:OR (STELLA::TRUE? P)
              (STELLA::FUNCTION-WITH-DEFINED-VALUE? P))))
           (CL:SETQ RESULT (STELLA::CONS P RESULT))))))))
     (CL:RETURN-FROM HELP-GET-TRUE-EXTENSION-MEMBERS
      (STELLA::REMOVE-DUPLICATES RESULT)))
    RESULT)))

;;; (DEFUN (HELP-GET-PROPOSITIONS (CONS OF PROPOSITION)) ...)

(CL:DEFUN HELP-GET-PROPOSITIONS (RELATION ARGUMENTS LIMIT MODULE ENVIRONMENT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM LIMIT))
  #+MCL
  (CL:CHECK-TYPE LIMIT CL:FIXNUM)
  (CL:WHEN (CL:EQ RELATION STELLA::NULL)
   (CL:RETURN-FROM HELP-GET-PROPOSITIONS STELLA::NIL))
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET*
      ((SPECIALIZE? (CL:NOT (CL:EQ ENVIRONMENT ASSERTION-ENV))))
      (CL:LET* ((VALUE-000 STELLA::NULL))
       (CL:LET* ((ARG STELLA::NULL) (ITER-000 ARGUMENTS))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 STELLA::NIL)) DO
         (CL:SETQ ARG (STELLA::%%VALUE ITER-000))
         (CL:WHEN
          (CL:AND (CL:NOT (CL:EQ ARG STELLA::NULL))
           (STELLA::ISA? ARG SGT-PLI-LOGIC-LOGIC-OBJECT))
          (CL:SETQ VALUE-000 ARG) (CL:RETURN))
         (CL:SETQ ITER-000 (STELLA::%%REST ITER-000))))
       (CL:LET*
        ((ARGUMENTWITHBACKLINKS VALUE-000)
         (ITERATOR
          (CL:IF (CL:NOT (CL:EQ ARGUMENTWITHBACKLINKS STELLA::NULL))
           (STELLA::ALL-TRUE-DEPENDENT-PROPOSITIONS
            ARGUMENTWITHBACKLINKS
            (STELLA::%SURROGATE-VALUE-INVERSE RELATION) SPECIALIZE?)
           (STELLA::ALLOCATE-ITERATOR
            (HELP-GET-TRUE-EXTENSION-MEMBERS RELATION SPECIALIZE?))))
         (RESULTS STELLA::NIL))
        (CL:LET* ((P STELLA::NULL) (ITER-001 ITERATOR))
         (CL:LOOP WHILE (STELLA::NEXT? ITER-001) DO
          (CL:SETQ P (STELLA::%VALUE ITER-001))
          (CL:LET* ((TEST-VALUE-000 CL:NIL))
           (CL:LET* ((ALWAYS?-000 CL:T))
            (CL:LET*
             ((INPUTARG STELLA::NULL) (ITER-002 ARGUMENTS)
              (ARG2 STELLA::NULL) (VECTOR-000 (STELLA::%ARGUMENTS P))
              (INDEX-000 0) (LENGTH-000 (STELLA::LENGTH VECTOR-000)))
             (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
             (CL:LOOP WHILE
              (CL:AND (CL:NOT (CL:EQ ITER-002 STELLA::NIL))
               (CL:< INDEX-000 LENGTH-000))
              DO (CL:SETQ INPUTARG (STELLA::%%VALUE ITER-002))
              (CL:SETQ ARG2
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR
                 (STELLA::%THE-ARRAY VECTOR-000))
                INDEX-000))
              (CL:WHEN
               (CL:NOT
                (CL:OR (CL:EQ INPUTARG STELLA::NULL)
                 (STELLA::EQL? INPUTARG (STELLA::VALUE-OF ARG2))))
               (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
              (CL:SETQ ITER-002 (STELLA::%%REST ITER-002))
              (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
            (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
           (CL:WHEN TEST-VALUE-000
            (CL:SETQ TEST-VALUE-000
             (CL:= (STELLA::LENGTH ARGUMENTS)
              (STELLA::LENGTH (STELLA::%ARGUMENTS P)))))
           (CL:WHEN TEST-VALUE-000
            (CL:SETQ RESULTS (STELLA::CONS P RESULTS))
            (CL:SETQ LIMIT (CL:1- LIMIT))
            (CL:WHEN (CL:= LIMIT 0) (CL:RETURN))))))
        RESULTS)))))))

;;; (DEFUN (GET-PROPOSITION PROPOSITION) ...)

(CL:DEFUN GET-PROPOSITION (RELATION-AND-ARGUMENTS MODULE ENVIRONMENT)
  "Return a proposition matching `relation-and-arguments' that
has been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card.  If more than one 
proposition matches the input criteria, the selection among satisficing
propositions is arbitrary.  This procedure is normally applied to single-valued
relations or functions."
  (CL:LET*
   ((LIST (SEQUENCE-TO-CONS-LIST RELATION-AND-ARGUMENTS))
    (RELATION (STELLA::%%VALUE LIST))
    (ARGUMENTS (STELLA::%%REST LIST)))
   (STELLA::%%VALUE
    (HELP-GET-PROPOSITIONS RELATION ARGUMENTS 1 MODULE ENVIRONMENT))))

;;; (DEFUN (S-GET-PROPOSITION PROPOSITION) ...)

(CL:DEFUN S-GET-PROPOSITION (RELATION-AND-ARGUMENTS MODULE-NAME ENVIRONMENT)
  "Return a proposition matching `relation-and-arguments' that
has been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal
reference (e.g., a number), the null identifier, or a variable (an identifier that begins
with a question mark). Each occurrence of a null or a variable acts like a wild card.
If more than one proposition matches the input criteria, the selection among
satisficing propositions is arbitrary.  This procedure is normally applied to
single-valued relations or functions.

A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING RELATION-AND-ARGUMENTS MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-AND-ARGUMENTS CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (ELEMENTS (EXPLODE-STRING-LIST RELATION-AND-ARGUMENTS MODULE))
    (RELATION (STELLA::%%VALUE ELEMENTS))
    (ARGUMENTS (STELLA::%%REST ELEMENTS)))
   (STELLA::%%VALUE
    (HELP-GET-PROPOSITIONS RELATION ARGUMENTS 1 MODULE ENVIRONMENT))))

;;; (DEFUN (GET-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN GET-PROPOSITIONS (RELATION-AND-ARGUMENTS MODULE ENVIRONMENT)
  "Return propositions matching `relation-and-arguments' that
have been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card."
  (CL:LET*
   ((LIST (SEQUENCE-TO-CONS-LIST RELATION-AND-ARGUMENTS))
    (RELATION (STELLA::%%VALUE LIST))
    (ARGUMENTS (STELLA::%%REST LIST)))
   (CONS-TO-PL-ITERATOR
    (HELP-GET-PROPOSITIONS RELATION ARGUMENTS 0 MODULE ENVIRONMENT))))

;;; (DEFUN (S-GET-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN S-GET-PROPOSITIONS (RELATION-AND-ARGUMENTS MODULE-NAME ENVIRONMENT)
  "Return propositions matching `relation-and-arguments' that
have been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal 
reference (e.g., a number), the null identifier, or a variable (an identifier that begins
with a question mark). Each occurrence of a null or a variable acts like a wild card.

A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING RELATION-AND-ARGUMENTS MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-AND-ARGUMENTS CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (ELEMENTS (EXPLODE-STRING-LIST RELATION-AND-ARGUMENTS MODULE))
    (RELATION (STELLA::%%VALUE ELEMENTS))
    (ARGUMENTS (STELLA::%%REST ELEMENTS)))
   (CONS-TO-PL-ITERATOR
    (HELP-GET-PROPOSITIONS RELATION ARGUMENTS 0 MODULE ENVIRONMENT))))

;;; (DEFUN (GET-BINARY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN GET-BINARY-PROPOSITION (RELATION ARG1 ARG2 MODULE ENVIRONMENT)
  "Return a proposition such that (`relation' `arg1' `arg2')
is true.  The `relation' argument must be bound to a relation.  One or both
of the `arg1' and `arg2' arguments may be set to NULL, which is interpreted
as a wildcard. If more than one proposition matches the input criteria,
the selection is arbitrary.  This procedure is normally applied to single-valued
relations or functions."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET* ((ARGUMENTWITHBACKLINKS STELLA::NULL))
      (CL:COND
       ((CL:AND (CL:NOT (CL:EQ ARG1 STELLA::NULL))
         (STELLA::ISA? ARG1 SGT-PLI-LOGIC-LOGIC-OBJECT))
        (CL:SETQ ARGUMENTWITHBACKLINKS ARG1))
       ((CL:AND (CL:NOT (CL:EQ ARG2 STELLA::NULL))
         (STELLA::ISA? ARG2 SGT-PLI-LOGIC-LOGIC-OBJECT))
        (CL:SETQ ARGUMENTWITHBACKLINKS ARG2)))
      (CL:IF (CL:NOT (CL:EQ ARGUMENTWITHBACKLINKS STELLA::NULL))
       (CL:LET*
        ((P STELLA::NULL)
         (ITER-000
          (STELLA::ALL-TRUE-DEPENDENT-PROPOSITIONS
           ARGUMENTWITHBACKLINKS
           (STELLA::%SURROGATE-VALUE-INVERSE RELATION) CL:NIL)))
        (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
         (CL:SETQ P (STELLA::%VALUE ITER-000))
         (CL:WHEN
          (CL:AND
           (CL:OR (CL:EQ ARG1 STELLA::NULL)
            (STELLA::EQL? ARG1
             (STELLA::VALUE-OF
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (STELLA::%THE-ARRAY (STELLA::%ARGUMENTS P)))
               0))))
           (CL:OR (CL:EQ ARG2 STELLA::NULL)
            (STELLA::EQL? ARG2
             (STELLA::VALUE-OF
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (STELLA::%THE-ARRAY (STELLA::%ARGUMENTS P)))
               1)))))
          (CL:RETURN-FROM GET-BINARY-PROPOSITION P))))
       (CL:RETURN-FROM GET-BINARY-PROPOSITION
        (STELLA::%%VALUE
         (HELP-GET-PROPOSITIONS RELATION (STELLA::CONS-LIST ARG1 ARG2)
          1 MODULE ENVIRONMENT))))
      STELLA::NULL)))))

;;; (DEFUN (GET-BINARY-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN GET-BINARY-PROPOSITIONS (RELATION ARG1 ARG2 MODULE ENVIRONMENT)
  "Return propositions such that (`relation' `arg1' `arg2')
is true.  The `relation' argument
must be bound to a relation.  One or both of the `arg1' and `arg2' arguments
may be set to NULL, which is interpreted as a wildcard."
  (CONS-TO-PL-ITERATOR
   (HELP-GET-PROPOSITIONS RELATION (STELLA::CONS-LIST ARG1 ARG2) 0
    MODULE ENVIRONMENT)))

;;; (DEFUN (GET-INFERRED-BINARY-PROPOSITION-VALUES PL-ITERATOR) ...)

(CL:DEFUN GET-INFERRED-BINARY-PROPOSITION-VALUES (RELATION ARG MODULE ENVIRONMENT)
  "Return all values `v' such that (`relation' `arg' `v')
has been asserted or can be inferred."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CONS-TO-PL-ITERATOR
      (STELLA::APPLY-CACHED-RETRIEVE
       (STELLA::LIST* SYM-PLI-PLI-?R SYM-PLI-PLI-?I SYM-PLI-PLI-?V
        STELLA::NIL)
       (STELLA::LIST* SYM-PLI-PLI-?R SYM-PLI-PLI-?I SYM-PLI-PLI-?V
        STELLA::NIL)
       (STELLA::CONS-LIST RELATION ARG STELLA::NULL)
       (STELLA::CONS-LIST)
       SYM-PLI-PLI-F-GET-INFERRED-BINARY-PROPOSITION-VALUES-QUERY-000))))))

;;; (DEFUN (S-GET-INFERRED-BINARY-PROPOSITION-VALUES PL-ITERATOR) ...)

(CL:DEFUN S-GET-INFERRED-BINARY-PROPOSITION-VALUES (RELATION-NAME ARG-NAME MODULE-NAME ENVIRONMENT)
  "Return all values `v' such that (`relation-name' `arg-name' `v')
has been asserted or can be inferred.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING RELATION-NAME ARG-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARG-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (RELATION (SAFELY-GET-RELATION RELATION-NAME MODULE ENVIRONMENT))
    (OBJECT (SAFELY-GET-OBJECT ARG-NAME MODULE ENVIRONMENT)))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ OBJECT STELLA::NULL))
     (CL:NOT (CL:EQ RELATION STELLA::NULL)))
    (GET-INFERRED-BINARY-PROPOSITION-VALUES RELATION OBJECT MODULE
     ENVIRONMENT)
    EMPTY-PL-ITERATOR)))

;;; (DEFUN (GET-PROPOSITIONS-OF (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN GET-PROPOSITIONS-OF (OBJECT MODULE ENVIRONMENT)
  "Return all propositions that have `object' among their arguments,
and that are TRUE in the scope of the module `module'."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (LIST-TO-PL-ITERATOR
      (STELLA::ALL-FACTS-OF-INSTANCE OBJECT CL:NIL CL:NIL))))))

;;; (DEFUN (S-GET-PROPOSITIONS-OF (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN S-GET-PROPOSITIONS-OF (OBJECT-NAME MODULE-NAME ENVIRONMENT)
  "Return all propositions that have the object named `object-name' among
their arguments, and that are TRUE in the scope of the module `module-name'.
A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OBJECT-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE OBJECT-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (OBJECT (SAFELY-GET-OBJECT OBJECT-NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:NOT (CL:EQ OBJECT STELLA::NULL))
    (GET-PROPOSITIONS-OF OBJECT MODULE ENVIRONMENT) EMPTY-PL-ITERATOR)))

;;; (DEFUN (GET-PROPOSITIONS-IN-MODULE (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN GET-PROPOSITIONS-IN-MODULE (MODULE ENVIRONMENT)
  "Return propositions that have been conceived in
the module `module'."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CONS-TO-PL-ITERATOR
      (STELLA::CONSIFY
       (STELLA::ALL-PROPOSITIONS STELLA::*MODULE* CL:T)))))))

;;; (DEFUN (IS-TRUE-UNARY-PROPOSITION BOOLEAN) ...)

(CL:DEFUN IS-TRUE-UNARY-PROPOSITION (RELATION ARG MODULE ENVIRONMENT)
  "Return TRUE if the proposition (`relation' `arg') has
been asserted (or inferred by forward chaining)."
  (CL:NOT
   (CL:EQ
    (HELP-GET-PROPOSITIONS RELATION (STELLA::CONS-LIST ARG) 1 MODULE
     ENVIRONMENT)
    STELLA::NULL)))

;;; (DEFUN (IS-TRUE-BINARY-PROPOSITION BOOLEAN) ...)

(CL:DEFUN IS-TRUE-BINARY-PROPOSITION (RELATION ARG VALUE MODULE ENVIRONMENT)
  "Return TRUE if the proposition (`relation' `arg' `value') has
been asserted (or inferred by forward chaining)."
  (CL:NOT
   (CL:EQ
    (GET-BINARY-PROPOSITION RELATION ARG VALUE MODULE ENVIRONMENT)
    STELLA::NULL)))

;;; (DEFUN (IS-TRUE-PROPOSITION1 BOOLEAN) ...)

(CL:DEFUN IS-TRUE-PROPOSITION1 (RELATION-AND-ARGUMENTS MODULE ENVIRONMENT)
  "Return TRUE if a proposition (`relation' `args') has
been asserted (or inferred by forward chaining)."
  (CL:LET*
   ((LIST (SEQUENCE-TO-CONS-LIST RELATION-AND-ARGUMENTS))
    (RELATION (STELLA::%%VALUE LIST))
    (ARGUMENTS (STELLA::%%REST LIST)))
   (CL:NOT
    (CL:EQ
     (HELP-GET-PROPOSITIONS RELATION ARGUMENTS 1 MODULE ENVIRONMENT)
     STELLA::NULL))))

;;; (DEFUN (IS-TRUE-PROPOSITION BOOLEAN) ...)

(CL:DEFUN IS-TRUE-PROPOSITION (PROPOSITION MODULE ENVIRONMENT)
  "Return TRUE if `proposition' is  TRUE in the module `module'."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:AND (CL:NOT (STELLA::DELETED? PROPOSITION))
      (CL:IF STELLA::*REVERSEPOLARITY?* (STELLA::FALSE? PROPOSITION)
       (CL:OR (STELLA::TRUE? PROPOSITION)
        (STELLA::FUNCTION-WITH-DEFINED-VALUE? PROPOSITION))))))))

;;; (DEFUN (S-IS-TRUE-PROPOSITION BOOLEAN) ...)

(CL:DEFUN S-IS-TRUE-PROPOSITION (RELATION-AND-ARGUMENTS MODULE-NAME ENVIRONMENT)
  "Return TRUE if a proposition that prints as the string
`relation-and-arguments' is true in the module named `module-name'.
A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING RELATION-AND-ARGUMENTS MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-AND-ARGUMENTS CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:NOT
   (CL:EQ
    (S-GET-PROPOSITION RELATION-AND-ARGUMENTS MODULE-NAME ENVIRONMENT)
    STELLA::NULL)))

;;; (DEFUN (IS-SUBRELATION BOOLEAN) ...)

(CL:DEFUN IS-SUBRELATION (SUB SUPER MODULE ENVIRONMENT)
  "Return TRUE if `sub' is a subconcept/subrelation of `super'."
  (CL:WHEN (CL:OR (CL:EQ SUB STELLA::NULL) (CL:EQ SUPER STELLA::NULL))
   (CL:RETURN-FROM IS-SUBRELATION CL:NIL))
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::TRUE-TRUTH-VALUE?
      (STELLA::DESCRIPTION-SPECIALIZES-DESCRIPTION? SUB SUPER))))))

;;; (DEFUN (GET-PROPER-SUBRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-PROPER-SUBRELATIONS (RELATION MODULE ENVIRONMENT)
  "Return relations that specialize `relation'.
Non-reflexive."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CONS-TO-PL-ITERATOR (STELLA::ALL-SUBRELATIONS RELATION CL:T))))))

;;; (DEFUN (GET-DIRECT-SUBRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-DIRECT-SUBRELATIONS (RELATION MODULE ENVIRONMENT)
  "Return relations that directly specialize `relation'.
Non-reflexive."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CONS-TO-PL-ITERATOR
      (STELLA::ALL-DIRECT-SUBRELATIONS RELATION CL:T))))))

;;; (DEFUN (GET-PROPER-SUPERRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-PROPER-SUPERRELATIONS (RELATION MODULE ENVIRONMENT)
  "Return relations that generalize `relation'.
Non-reflexive."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CONS-TO-PL-ITERATOR (STELLA::ALL-SUPERRELATIONS RELATION CL:T))))))

;;; (DEFUN (GET-DIRECT-SUPERRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-DIRECT-SUPERRELATIONS (RELATION MODULE ENVIRONMENT)
  "Return relations that directly generalize `relation'.
Non-reflexive."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CONS-TO-PL-ITERATOR
      (STELLA::ALL-DIRECT-SUPERRELATIONS RELATION CL:T))))))

;;; (DEFUN (IS-A BOOLEAN) ...)

(CL:DEFUN IS-A (OBJECT CONCEPT MODULE ENVIRONMENT)
  "Return TRUE if `object' is a member of the concept `concept'."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::TEST-ISA? OBJECT
      (STELLA::%SURROGATE-VALUE-INVERSE CONCEPT))))))

;;; (DEFUN (GET-CONCEPT-INSTANCES PL-ITERATOR) ...)

(CL:DEFUN GET-CONCEPT-INSTANCES (CONCEPT MODULE ENVIRONMENT)
  "Return instances of the concept `concept'.
Include instances of subconcepts of `concept'.  Depending on `concept',
the return values could be (wrapped) literals."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ ENVIRONMENT STELLA::NULL))
       (STELLA::STRING-EQL? (STELLA::%LEVEL ENVIRONMENT) "ASSERTION"))
      (LIST-TO-PL-ITERATOR
       (STELLA::REMOVE-DELETED-MEMBERS
        (STELLA::ASSERTED-COLLECTION-MEMBERS CONCEPT CL:NIL)))
      (RETRIEVE
       (STELLA::LIST* SYM-PLI-LOGIC-ALL SYM-PLI-LOGIC-?X
        (STELLA::CONS (STELLA::OBJECT-NAME CONCEPT)
         (STELLA::CONS SYM-PLI-LOGIC-?X STELLA::NIL))
        STELLA::NIL)
       MODULE ENVIRONMENT))))))

;;; (DEFUN (S-GET-CONCEPT-INSTANCES PL-ITERATOR) ...)

(CL:DEFUN S-GET-CONCEPT-INSTANCES (CONCEPT-NAME MODULE-NAME ENVIRONMENT)
  "Return instances of concept `concept-name'.
Include instances of subconcepts of `concept-name'.  Depending on `concept-name',
the return values could be (wrapped) literals.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING CONCEPT-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE CONCEPT-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (CONCEPT (SAFELY-GET-CONCEPT CONCEPT-NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:NOT (CL:EQ CONCEPT STELLA::NULL))
    (GET-CONCEPT-INSTANCES CONCEPT MODULE ENVIRONMENT)
    EMPTY-PL-ITERATOR)))

;;; (DEFUN (GET-DIRECT-CONCEPT-INSTANCES PL-ITERATOR) ...)

(CL:DEFUN GET-DIRECT-CONCEPT-INSTANCES (CONCEPT MODULE ENVIRONMENT)
  "Return instances of concept `concept'.
Exclude instances of subconcepts of `concept'.  Depending on `concept',
the return values could be (wrapped) literals."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ ENVIRONMENT STELLA::NULL))
       (STELLA::STRING-EQL? (STELLA::%LEVEL ENVIRONMENT) "ASSERTION"))
      (LIST-TO-PL-ITERATOR
       (STELLA::REMOVE-DELETED-MEMBERS
        (STELLA::ASSERTED-COLLECTION-MEMBERS CONCEPT CL:T)))
      (RETRIEVE
       (STELLA::LIST* SYM-PLI-LOGIC-ALL SYM-PLI-LOGIC-?X
        (STELLA::LIST* SYM-PLI-STELLA-AND
         (STELLA::CONS (STELLA::OBJECT-NAME CONCEPT)
          (STELLA::CONS SYM-PLI-LOGIC-?X STELLA::NIL))
         (STELLA::LIST* SYM-PLI-LOGIC-FAIL
          (STELLA::LIST* SYM-PLI-STELLA-EXISTS
           (STELLA::CONS SYM-PLI-LOGIC-?Y STELLA::NIL)
           (STELLA::LIST* SYM-PLI-STELLA-AND
            (STELLA::LIST* SYM-PLI-PLI-PROPER-SUBRELATION
             (STELLA::OBJECT-NAME CONCEPT)
             (STELLA::CONS SYM-PLI-LOGIC-?Y STELLA::NIL))
            (STELLA::LIST* SYM-PLI-LOGIC-?Y SYM-PLI-LOGIC-?X
             STELLA::NIL)
            STELLA::NIL)
           STELLA::NIL)
          STELLA::NIL)
         STELLA::NIL)
        STELLA::NIL)
       MODULE ENVIRONMENT))))))

;;; (DEFUN (S-GET-DIRECT-CONCEPT-INSTANCES PL-ITERATOR) ...)

(CL:DEFUN S-GET-DIRECT-CONCEPT-INSTANCES (CONCEPT-NAME MODULE-NAME ENVIRONMENT)
  "Return instances of concept `concept-name'.
Exclude instances of subconcepts of `concept-name'.  Depending on `concept-name',
the return values could be (wrapped) literals.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING CONCEPT-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE CONCEPT-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (CONCEPT (SAFELY-GET-CONCEPT CONCEPT-NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:NOT (CL:EQ CONCEPT STELLA::NULL))
    (GET-DIRECT-CONCEPT-INSTANCES CONCEPT MODULE ENVIRONMENT)
    EMPTY-PL-ITERATOR)))

;;; (DEFUN (GET-CONCEPT-INSTANCES-MATCHING-VALUE PL-ITERATOR) ...)

(CL:DEFUN GET-CONCEPT-INSTANCES-MATCHING-VALUE (CONCEPT RELATION VALUE MODULE ENVIRONMENT)
  "Return members of concept `concept' that
have an attribute matching `value' for the binary relation `relation', i.e.,
`(relation <result> value)' holds."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET*
      ((INSTANCES (GET-CONCEPT-INSTANCES CONCEPT MODULE ENVIRONMENT))
       (ANSWERS STELLA::NIL))
      (CL:LET* ((I STELLA::NULL) (ITER-000 INSTANCES))
       (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
        (CL:SETQ I (STELLA::%VALUE ITER-000))
        (CL:WHEN
         (IS-TRUE-BINARY-PROPOSITION RELATION I VALUE MODULE
          ENVIRONMENT)
         (CL:SETQ ANSWERS (STELLA::CONS I ANSWERS)))))
      (CONS-TO-PL-ITERATOR ANSWERS))))))

;;; (DEFUN (GET-CONCEPT-INSTANCE-MATCHING-VALUE OBJECT) ...)

(CL:DEFUN GET-CONCEPT-INSTANCE-MATCHING-VALUE (CONCEPT RELATION VALUE MODULE ENVIRONMENT)
  "Return a member of concept `concept' that
has an attribute matching `value' for the binary relation `relation', i.e.,
`(relation <result> value)' holds."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET*
      ((INSTANCES (GET-CONCEPT-INSTANCES CONCEPT MODULE ENVIRONMENT)))
      (CL:LET* ((I STELLA::NULL) (ITER-000 INSTANCES))
       (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
        (CL:SETQ I (STELLA::%VALUE ITER-000))
        (CL:WHEN
         (IS-TRUE-BINARY-PROPOSITION RELATION I VALUE MODULE
          ENVIRONMENT)
         (CL:RETURN-FROM GET-CONCEPT-INSTANCE-MATCHING-VALUE I))))
      STELLA::NULL)))))

;;; (DEFUN (GET-TYPES (PL-ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-TYPES (OBJECT MODULE ENVIRONMENT)
  "Return all named concepts that `object' belongs to."
  (CL:LET*
   ((DIRECTTYPES (GET-DIRECT-TYPES OBJECT MODULE ENVIRONMENT))
    (TYPES STELLA::NIL))
   (CL:LET* ((D STELLA::NULL) (ITER-000 DIRECTTYPES))
    (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
     (CL:SETQ D (STELLA::%VALUE ITER-000))
     (CL:WHEN (CL:NOT (STELLA::MEMBER? TYPES D))
      (CL:SETQ TYPES (STELLA::CONS D TYPES)))
     (CL:LET*
      ((C STELLA::NULL) (ITER-001 (STELLA::ALL-SUPERCOLLECTIONS D)))
      (CL:LOOP WHILE (STELLA::NEXT? ITER-001) DO
       (CL:SETQ C (STELLA::%VALUE ITER-001))
       (CL:WHEN (STELLA::ISA? C SGT-PLI-LOGIC-NAMED-DESCRIPTION)
        (CL:WHEN (CL:NOT (STELLA::MEMBER? TYPES C))
         (CL:SETQ TYPES (STELLA::CONS C TYPES))))))))
   (CONS-TO-PL-ITERATOR TYPES)))

;;; (DEFUN (GET-DIRECT-TYPES (PL-ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-DIRECT-TYPES (OBJECT MODULE ENVIRONMENT)
  "Return most specific concepts that `object' belongs to."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET* ((DERIVABLETYPES STELLA::NIL))
      (CL:LET*
       ((PROP STELLA::NULL)
        (ITER-000
         (STELLA::ALL-TRUE-DEPENDENT-PROPOSITIONS OBJECT STELLA::NULL
          CL:NIL)))
       (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
        (CL:SETQ PROP (STELLA::%VALUE ITER-000))
        (CL:WHEN (CL:EQ (STELLA::%KIND PROP) KWD-PLI-ISA)
         (CL:SETQ DERIVABLETYPES
          (STELLA::CONS (GET-NTH-VALUE PROP 0 MODULE ENVIRONMENT)
           DERIVABLETYPES)))))
      (CONS-TO-PL-ITERATOR
       (STELLA::MOST-SPECIFIC-NAMED-DESCRIPTIONS DERIVABLETYPES)))))))

;;; (DEFUN (GET-RELATION-EXTENSION (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN GET-RELATION-EXTENSION (RELATION MODULE ENVIRONMENT)
  "Return propositions that satisfy `relation'.
Include propositions that satisfy subrelations of `relation'."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CONS-TO-PL-ITERATOR
      (HELP-GET-TRUE-EXTENSION-MEMBERS RELATION
       (CL:NOT (CL:EQ ENVIRONMENT ASSERTION-ENV))))))))

;;; (DEFUN (S-GET-RELATION-EXTENSION (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN S-GET-RELATION-EXTENSION (RELATION-NAME MODULE ENVIRONMENT)
  "Return propositions that satisfy the relation named
`relation-name'.  Include propositions that satisfy subrelations of the relation."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RELATION-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((RELATION (SAFELY-GET-RELATION RELATION-NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:NOT (CL:EQ RELATION STELLA::NULL))
    (GET-RELATION-EXTENSION RELATION MODULE ENVIRONMENT)
    EMPTY-PL-ITERATOR)))

;;; (DEFUN (GET-MODULE MODULE) ...)

(CL:DEFUN GET-MODULE (NAME ENVIRONMENT)
  "Return a module named `name'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:SETQ ENVIRONMENT ENVIRONMENT)
  (STELLA::GET-STELLA-MODULE NAME CL:NIL))

;;; (DEFUN (GET-CURRENT-MODULE MODULE) ...)

(CL:DEFUN GET-CURRENT-MODULE (ENVIRONMENT)
  "Return the currently set module"
  (CL:SETQ ENVIRONMENT ENVIRONMENT)
  STELLA::*MODULE*)

;;; (DEFUN (GET-HOME-MODULE MODULE) ...)

(CL:DEFUN GET-HOME-MODULE (OBJECT)
  "Return the module in which `object' was created."
  (STELLA::HOME-MODULE OBJECT))

;;; (DEFUN (GET-MODULES (PL-ITERATOR OF MODULE)) ...)

(CL:DEFUN GET-MODULES (KB-MODULES-ONLY?)
  "Return all modules currently loaded into PowerLoom.  If `kb-modules-only?'
is `true', then Stella modules that are used only for program code are
not included in the list."
  (CONS-TO-PL-ITERATOR (STELLA::%LIST-MODULES KB-MODULES-ONLY?)))

;;; (DEFUN (CREATE-MODULE MODULE) ...)

(CL:DEFUN CREATE-MODULE (NAME PARENT CASE-SENSITIVE?)
  "Creates a new module `name' as a child of `parent'.  The flag
`case-sensitive?' controls whether names read in this module will be
case sensitive or not."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((FULL-NAME
     (CL:IF (CL:NOT (CL:EQ PARENT STELLA::NULL))
      (STELLA::CONCATENATE (STELLA::%MODULE-FULL-NAME PARENT) "/" NAME)
      NAME))
    (CASE-SENSITIVE-SYMBOL
     (CL:IF CASE-SENSITIVE? SYM-PLI-STELLA-TRUE SYM-PLI-STELLA-FALSE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FULL-NAME))
   (STELLA::DEFINE-MODULE FULL-NAME
    (STELLA::LIST* KWD-PLI-CASE-SENSITIVE? CASE-SENSITIVE-SYMBOL
     STELLA::NIL))))

;;; (DEFUN (S-CREATE-MODULE MODULE) ...)

(CL:DEFUN S-CREATE-MODULE (NAME PARENT-NAME CASE-SENSITIVE? ENVIRONMENT)
  "Creates a new module `name' as a child of `parent-name'.  The flag
`case-sensitive?' controls whether names read in this module will be
case sensitive or not."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME PARENT-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PARENT-NAME CL:SIMPLE-STRING)
  (CREATE-MODULE NAME (SAFELY-GET-MODULE PARENT-NAME ENVIRONMENT)
   CASE-SENSITIVE?))

;;; (DEFUN (CHANGE-MODULE MODULE) ...)

(CL:DEFUN CHANGE-MODULE (MODULE)
  "Set the current module to `module' and return it.
If `module' is `null', then no switch is performed and the current
module is returned."
  (CL:WHEN (CL:EQ MODULE STELLA::NULL)
   (CL:RETURN-FROM CHANGE-MODULE STELLA::*MODULE*))
  (STELLA::CHANGE-MODULE MODULE))

;;; (DEFUN (S-CHANGE-MODULE MODULE) ...)

(CL:DEFUN S-CHANGE-MODULE (NAME ENVIRONMENT)
  "Set the current module to the module named `name'.
The return value is the module named `name' unless `name' is null or
the empty string.  In that case, the current module is returned.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CHANGE-MODULE (SAFELY-GET-MODULE NAME ENVIRONMENT)))

;;; (DEFUN (CLEAR-MODULE MODULE) ...)

(CL:DEFUN CLEAR-MODULE (MODULE)
  "Destroy the contents of the module `module' as well as
the contents of all of its children, recursively."
  (STELLA::CALL-CLEAR-MODULE (STELLA::CONS-LIST MODULE))
  MODULE)

;;; (DEFUN (S-CLEAR-MODULE MODULE) ...)

(CL:DEFUN S-CLEAR-MODULE (NAME ENVIRONMENT)
  "Destroy the contents of the module named `name', as
well as the contents of all of its children, recursively.  If no module
named `name' exists, a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((MODULE (SAFELY-GET-MODULE NAME ENVIRONMENT)))
   (STELLA::CALL-CLEAR-MODULE (STELLA::CONS-LIST MODULE)) MODULE))

;;; (DEFUN (GET-CHILD-MODULES (PL-ITERATOR OF MODULE)) ...)

(CL:DEFUN GET-CHILD-MODULES (MODULE)
  "Return the modules that are immediate children of `module'."
  (CL:LET* ((DIRECTSUBMODULES STELLA::NIL))
   (CL:LET*
    ((CHILD STELLA::NULL)
     (ITER-000
      (STELLA::%THE-CONS-LIST (STELLA::%CHILD-CONTEXTS MODULE)))
     (COLLECT-000 STELLA::NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 STELLA::NIL)) DO
     (CL:SETQ CHILD (STELLA::%%VALUE ITER-000))
     (CL:WHEN (STELLA::ISA? CHILD SGT-PLI-STELLA-MODULE)
      (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (STELLA::CONS CHILD STELLA::NIL))
        (CL:IF (CL:EQ DIRECTSUBMODULES STELLA::NIL)
         (CL:SETQ DIRECTSUBMODULES COLLECT-000)
         (STELLA::ADD-CONS-TO-END-OF-CONS-LIST DIRECTSUBMODULES
          COLLECT-000)))
       (CL:PROGN
        (CL:SETF (STELLA::%%REST COLLECT-000)
         (STELLA::CONS CHILD STELLA::NIL))
        (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000)))))
     (CL:SETQ ITER-000 (STELLA::%%REST ITER-000))))
   (CONS-TO-PL-ITERATOR DIRECTSUBMODULES)))

;;; (DEFUN (S-GET-CHILD-MODULES (PL-ITERATOR OF MODULE)) ...)

(CL:DEFUN S-GET-CHILD-MODULES (NAME ENVIRONMENT)
  "Return the modules that are immediate children of module `name'.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (GET-CHILD-MODULES (SAFELY-GET-MODULE NAME ENVIRONMENT)))

;;; (DEFUN (GET-PARENT-MODULES (PL-ITERATOR OF MODULE)) ...)

(CL:DEFUN GET-PARENT-MODULES (MODULE)
  "Return the modules that are immediate parents of `module'."
  (LIST-TO-PL-ITERATOR (STELLA::%PARENT-MODULES MODULE)))

;;; (DEFUN (S-GET-PARENT-MODULES (PL-ITERATOR OF MODULE)) ...)

(CL:DEFUN S-GET-PARENT-MODULES (NAME ENVIRONMENT)
  "Return the modules that are immediate parents of module `name'.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (GET-PARENT-MODULES (SAFELY-GET-MODULE NAME ENVIRONMENT)))

;;; (DEFUN (GENERATE-UNIQUE-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING CL:T CL:T) CL:SIMPLE-STRING)
  GENERATE-UNIQUE-NAME))
(CL:DEFUN GENERATE-UNIQUE-NAME (PREFIX MODULE ENVIRONMENT)
  "Generates a name based on `prefix' with a number appended that
is not currently in use in `module.'  In a non-case-sensitive module, the returned
name will be all upper case (This latter feature may change!)"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PREFIX))
  #+MCL
  (CL:CHECK-TYPE PREFIX CL:SIMPLE-STRING)
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:WHEN
      (CL:NOT
       (CL:OR (STELLA::%CASE-SENSITIVE? STELLA::*MODULE*)
        (STELLA::ALL-UPPER-CASE-STRING? PREFIX)))
      (CL:SETQ PREFIX (STELLA::STRING-UPCASE PREFIX)))
     (STELLA::YIELD-UNIQUE-GENSYM-NAME PREFIX STELLA::*MODULE*)))))

;;; (DEFUN (CREATE-KEYWORD KEYWORD) ...)

(CL:DEFUN CREATE-KEYWORD (NAME)
  "Returns the Stella keyword `name', creating it if
necessary.  `name' is treated case-sensitively.  This should
generally not be necessary to do."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE NAME STELLA::*MODULE*
   STELLA::KEYWORD-SYM))

;;; (DEFUN (CREATE-SYMBOL SYMBOL) ...)

(CL:DEFUN CREATE-SYMBOL (NAME MODULE ENVIRONMENT)
  "Returns the Stella symbol `name' visible in `module',
creating it if necessary.  `name' is ALWAYS treated case-sensitively,
even if `module' is case insensitive. This should generally not be
necessary to do."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::INTERN-SYMBOL-IN-MODULE NAME STELLA::*MODULE* CL:NIL)))))

;;; (DEFUN (CREATE-OBJECT LOGIC-OBJECT) ...)

(CL:DEFUN CREATE-OBJECT (NAME CONCEPT MODULE ENVIRONMENT)
  "Create an object named `name' of type `concept' in the designated
module.  Both `name' and `concept' can be `null'.  If `name' is `null' then an
object will be created with a new, non-conflicting name based on the name of
`concept', or system-generated if no concept is specified.  If `concept' is
`null', then the object will be of type THING.  It is an error to create an
object with the same name as an existing object.

Note that the string can be a qualified name, in which case the object
will be created in the module specified, but with a name as determined
by the qualified name.  Vertical bars in the name string are interpreted
as Stella escape characters.

Note that because names in modules that are not case-sensitive are
canonicalized, the name of the returned object may not match `name'
exactly.

Return the object."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET*
      ((OBJECT STELLA::NULL) (NAME-SYMBOL STELLA::NULL)
       (OBJECT-SURROGATE STELLA::NULL))
      (CL:COND
       ((CL:NOT (CL:EQ NAME STELLA::NULL-STRING))
        (CL:SETQ NAME-SYMBOL (STELLA::INTERN-STELLA-NAME NAME)))
       ((CL:NOT (CL:EQ CONCEPT STELLA::NULL))
        (CL:SETQ NAME-SYMBOL
         (STELLA::INTERN-SYMBOL (GET-SHORT-NAME CONCEPT)))
        (CL:SETQ NAME-SYMBOL
         (STELLA::INTERN-SYMBOL-IN-MODULE
          (GENERATE-UNIQUE-NAME (STELLA::%SYMBOL-NAME NAME-SYMBOL)
           (STELLA::%HOME-CONTEXT NAME-SYMBOL) STELLA::NULL)
          (STELLA::%HOME-CONTEXT NAME-SYMBOL) CL:T)))
       (CL:T
        (CL:SETQ NAME-SYMBOL
         (STELLA::INTERN-SYMBOL-IN-MODULE
          (GENERATE-UNIQUE-NAME "I" STELLA::NULL STELLA::NULL)
          STELLA::*MODULE* CL:T))))
      (CL:SETQ OBJECT-SURROGATE
       (STELLA::LOOKUP-SURROGATE-IN-MODULE
        (STELLA::%SYMBOL-NAME NAME-SYMBOL)
        (STELLA::%HOME-CONTEXT NAME-SYMBOL) CL:NIL))
      (CL:WHEN (CL:EQ OBJECT-SURROGATE STELLA::NULL)
       (CL:SETQ OBJECT-SURROGATE
        (STELLA::INTERN-SURROGATE-IN-MODULE
         (STELLA::%SYMBOL-NAME NAME-SYMBOL)
         (STELLA::%HOME-CONTEXT NAME-SYMBOL) CL:NIL)))
      (CL:SETQ OBJECT
       (STELLA::HELP-CREATE-LOGIC-INSTANCE OBJECT-SURROGATE
        STELLA::NULL))
      (CL:WHEN (CL:NOT (CL:EQ CONCEPT STELLA::NULL))
       (CL:IF
        (CL:NOT
         (CL:EQ
          (ASSERT-UNARY-PROPOSITION CONCEPT OBJECT MODULE ENVIRONMENT)
          STELLA::NULL))
        (CL:RETURN-FROM CREATE-OBJECT OBJECT)
        (CL:RETURN-FROM CREATE-OBJECT STELLA::NULL)))
      OBJECT)))))

;;; (DEFUN (S-CREATE-OBJECT LOGIC-OBJECT) ...)

(CL:DEFUN S-CREATE-OBJECT (NAME CONCEPT-NAME MODULE-NAME ENVIRONMENT)
  "Create an object named `name' of type `concept-name' in the designated
module.  Both `name' and `concept-name' can be null strings.  If `name' is a null string
then an object will be created with a new, non-conflicting name based on `concept-name', or
system-generated if no concept nameis specified.  If `concept-name' is the null string, then
the object will be of type THING.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.

Return the object."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME CONCEPT-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE CONCEPT-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET* ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)))
   (CREATE-OBJECT NAME
    (SAFELY-GET-CONCEPT CONCEPT-NAME MODULE ENVIRONMENT) MODULE
    ENVIRONMENT)))

;;; (DEFUN (CREATE-CONCEPT LOGIC-OBJECT) ...)

(CL:DEFUN CREATE-CONCEPT (NAME PARENT MODULE ENVIRONMENT)
  "Create a concept named `name' in the designated `module', with the
designated `parent' superconcept (which can be left undefined).  Additional
superconcepts can be added via assertions of the `subset-of' relation.  Note
that a specified `parent' concept needs to be created separately.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::CALL-DEFCONCEPT
      (STELLA::CONS (STELLA::INTERN-STELLA-NAME NAME)
       (STELLA::CONCATENATE
        (CL:IF (CL:NOT (CL:EQ PARENT STELLA::NULL))
         (STELLA::LIST* KWD-PLI-SUBSET-OF (STELLA::OBJECT-NAME PARENT)
          STELLA::NIL)
         STELLA::NIL)
        STELLA::NIL)))))))

;;; (DEFUN (S-CREATE-CONCEPT LOGIC-OBJECT) ...)

(CL:DEFUN S-CREATE-CONCEPT (NAME PARENT-NAME MODULE-NAME ENVIRONMENT)
  "Create a concept named `name' in the designated module, with
with the concept named `parent-name' as superconcept (which can be left
undefined).  Additional superconcepts can be added via assertions of the
`subset-of' relation.  Note that a specified parent concept needs to be
created separately.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME PARENT-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PARENT-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET* ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)))
   (CREATE-CONCEPT NAME
    (SAFELY-GET-CONCEPT PARENT-NAME MODULE ENVIRONMENT) MODULE
    ENVIRONMENT)))

;;; (DEFUN (CREATE-RELATION LOGIC-OBJECT) ...)

(CL:DEFUN CREATE-RELATION (NAME ARITY MODULE ENVIRONMENT)
  "Create a relation named `name' with arity `arity' in the
designated module.  Domain and range information can be added via assertions
of `nth-domain' (or `domain' and `range') relations.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME) (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (CL:WHEN (CL:<= ARITY 0)
   (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((STELLA::*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL STELLA::*PRINTREADABLY?*))
     (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000)
      "PARSING ERROR: Relations must have arity of at least 1." EOL)
     (STELLA::HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PLI-ERROR))
    (CL:ERROR
     (STELLA::NEW-PARSING-ERROR
      (STELLA::THE-STRING-READER STREAM-000)))))
  (CL:LET* ((ARGS STELLA::NIL))
   (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
    (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
     (CL:SETQ MDL-000 STELLA::*MODULE*)
     (CL:SETQ CXT-000 STELLA::*CONTEXT*))
    (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
     (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
     (CL:SETQ ENVIRONMENT ENVIRONMENT)
     (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
      (CL:LET*
       ((I STELLA::NULL-INTEGER) (ITER-000 0)
        (UPPER-BOUND-000 (CL:1- ARITY)) (COLLECT-000 STELLA::NULL))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
       (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
        (CL:SETQ I ITER-000)
        (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-000
           (STELLA::CONS
            (STELLA::YIELD-SYSTEM-DEFINED-PARAMETER-NAME I
             STELLA::*MODULE*)
            STELLA::NIL))
          (CL:IF (CL:EQ ARGS STELLA::NIL) (CL:SETQ ARGS COLLECT-000)
           (STELLA::ADD-CONS-TO-END-OF-CONS-LIST ARGS COLLECT-000)))
         (CL:PROGN
          (CL:SETF (STELLA::%%REST COLLECT-000)
           (STELLA::CONS
            (STELLA::YIELD-SYSTEM-DEFINED-PARAMETER-NAME I
             STELLA::*MODULE*)
            STELLA::NIL))
          (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000))))
        (CL:SETQ ITER-000 (CL:1+ ITER-000))))
      (STELLA::CALL-DEFRELATION
       (STELLA::CONS (STELLA::INTERN-STELLA-NAME NAME)
        (STELLA::CONS ARGS STELLA::NIL))))))))

;;; (DEFUN (S-CREATE-RELATION LOGIC-OBJECT) ...)

(CL:DEFUN S-CREATE-RELATION (NAME ARITY MODULE-NAME ENVIRONMENT)
  "Create a relation named `name' with arity `arity' in the
designated module.  Domain and range information can be added via assertions
of `nth-domain' (or `domain' and `range') relations.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME MODULE-NAME)
   (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CREATE-RELATION NAME ARITY
   (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT) ENVIRONMENT))

;;; (DEFUN (CREATE-FUNCTION LOGIC-OBJECT) ...)

(CL:DEFUN CREATE-FUNCTION (NAME ARITY MODULE ENVIRONMENT)
  "Create a function named `name' with arity `arity'  in the designated 
`module'.  Domain and range information can be added via assertions of
`nth-domain' (or `domain' and `range') relations.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME) (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (CL:WHEN (CL:<= ARITY 0)
   (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((STELLA::*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL STELLA::*PRINTREADABLY?*))
     (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000)
      "PARSING ERROR: Functions must have arity of at least 1." EOL)
     (STELLA::HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PLI-ERROR))
    (CL:ERROR
     (STELLA::NEW-PARSING-ERROR
      (STELLA::THE-STRING-READER STREAM-000)))))
  (CL:LET* ((ARGS STELLA::NIL))
   (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
    (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
     (CL:SETQ MDL-000 STELLA::*MODULE*)
     (CL:SETQ CXT-000 STELLA::*CONTEXT*))
    (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
     (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
     (CL:SETQ ENVIRONMENT ENVIRONMENT)
     (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
      (CL:LET*
       ((I STELLA::NULL-INTEGER) (ITER-000 0)
        (UPPER-BOUND-000 (CL:1- ARITY)) (COLLECT-000 STELLA::NULL))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
       (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
        (CL:SETQ I ITER-000)
        (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-000
           (STELLA::CONS
            (STELLA::YIELD-SYSTEM-DEFINED-PARAMETER-NAME I
             STELLA::*MODULE*)
            STELLA::NIL))
          (CL:IF (CL:EQ ARGS STELLA::NIL) (CL:SETQ ARGS COLLECT-000)
           (STELLA::ADD-CONS-TO-END-OF-CONS-LIST ARGS COLLECT-000)))
         (CL:PROGN
          (CL:SETF (STELLA::%%REST COLLECT-000)
           (STELLA::CONS
            (STELLA::YIELD-SYSTEM-DEFINED-PARAMETER-NAME I
             STELLA::*MODULE*)
            STELLA::NIL))
          (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000))))
        (CL:SETQ ITER-000 (CL:1+ ITER-000))))
      (STELLA::CALL-DEFFUNCTION
       (STELLA::CONS (STELLA::INTERN-STELLA-NAME NAME)
        (STELLA::CONS ARGS STELLA::NIL))))))))

;;; (DEFUN (S-CREATE-FUNCTION LOGIC-OBJECT) ...)

(CL:DEFUN S-CREATE-FUNCTION (NAME ARITY MODULE-NAME ENVIRONMENT)
  "Create a function named `name' with arity `arity' in the designated 
module.  Domain and range information can be added via assertions of
`domain', `nth-domain' and `range' relations.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME MODULE-NAME)
   (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CREATE-FUNCTION NAME ARITY
   (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT) ENVIRONMENT))

;;; (DEFUN REGISTER-SPECIALIST-FUNCTION ...)

(CL:DEFUN REGISTER-SPECIALIST-FUNCTION (NAME FUNCTION-REFERENCE MODULE ENVIRONMENT)
  "Register `name' as a function name in `module' which will invoke the
native code procedure described by `function-reference.'  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The function must conform
to the signature for specialist functions.

The exact form of `function-reference' depends on the underlying
programming language.  The following type mappings are used:
          C++:  
  Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))
         Java:  java.lang.reflect.Method"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::REGISTER-SPECIALIST-FUNCTION NAME FUNCTION-REFERENCE)))))

;;; (DEFUN S-REGISTER-SPECIALIST-FUNCTION ...)

(CL:DEFUN S-REGISTER-SPECIALIST-FUNCTION (NAME NATIVE-NAME MODULE-NAME ENVIRONMENT)
  "Register `name' as a function name in the module named `module-name'.
This function will the native code named `native-name'.  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The `native-name' will be
processed in a manner that depends on the underlying programming
language.  The following type mappings are used:
          C++:  Not available.  Error signaled.
  Common Lisp:  The native-name is read by READ-FROM-STRING and then
                the SYMBOL-FUNCTION is taken.
         Java:  A fully package-qualified name is required.  It is
                looked up using the Reflection tools.
The function found must conform to the signature for specialist functions."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME NATIVE-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NATIVE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MDL-000 (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::%REGISTER-SPECIALIST-FUNCTION-NAME NAME NATIVE-NAME)))))

;;; (DEFUN (CREATE-ENUMERATED-LIST LOGIC-OBJECT) ...)

(CL:DEFUN CREATE-ENUMERATED-LIST (MEMBERS MODULE ENVIRONMENT)
  "Create a logical term that denotes a list containing `members' in
`module' using `environment'.  Useful for passing lists as arguments
to parameterized queries."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET* ((SELF-000 (STELLA::NEW-LIST)))
      (CL:SETF (STELLA::%THE-CONS-LIST SELF-000) MEMBERS)
      (CL:LET* ((VALUE-000 (STELLA::CREATE-LOGICAL-LIST SELF-000)))
       VALUE-000))))))

;;; (DEFUN (CREATE-ENUMERATED-SET LOGIC-OBJECT) ...)

(CL:DEFUN CREATE-ENUMERATED-SET (MEMBERS MODULE ENVIRONMENT)
  "Create a logical term that denotes the enumerated set containing `members'
in `module' using `environment'."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET* ((SELF-000 (STELLA::NEW-LIST)))
      (CL:SETF (STELLA::%THE-CONS-LIST SELF-000) MEMBERS)
      (CL:LET* ((VALUE-000 (STELLA::CREATE-ENUMERATED-SET SELF-000)))
       VALUE-000))))))

;;; (DEFUN DESTROY-OBJECT ...)

(CL:DEFUN DESTROY-OBJECT (OBJECT)
  "Delete the object `object', retracting all facts attached to it."
  (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
   (STELLA::DESTROY-INSTANCE OBJECT)))

;;; (DEFUN S-DESTROY-OBJECT ...)

(CL:DEFUN S-DESTROY-OBJECT (OBJECT-NAME MODULE-NAME ENVIRONMENT)
  "Delete the object named `object-name', retracting all facts
attached to it.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OBJECT-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE OBJECT-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (OBJECT (SAFELY-GET-OBJECT OBJECT-NAME MODULE ENVIRONMENT)))
   (CL:WHEN (CL:NOT (CL:EQ OBJECT STELLA::NULL))
    (DESTROY-OBJECT OBJECT))))

;;; (DEFUN (ASSERT-UNARY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN ASSERT-UNARY-PROPOSITION (RELATION ARG MODULE ENVIRONMENT)
  "Assert that the proposition (`relation' `arg') is TRUE in `module'.  Return the asserted proposition."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:IF (STELLA::CLASS? RELATION)
      (STELLA::ASSERT-ISA-PROPOSITION ARG
       (STELLA::%SURROGATE-VALUE-INVERSE RELATION))
      (STELLA::ASSERT-PROPERTY ARG
       (STELLA::%SURROGATE-VALUE-INVERSE RELATION)))))))

;;; (DEFUN (ASSERT-BINARY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN ASSERT-BINARY-PROPOSITION (RELATION ARG VALUE MODULE ENVIRONMENT)
  "Assert that the proposition (`relation' `arg' `value') is TRUE
in `module'.  Return the asserted proposition."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::ASSERT-BINARY-VALUE
      (STELLA::%SURROGATE-VALUE-INVERSE RELATION) ARG VALUE)))))

;;; (DEFUN (ASSERT-NARY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN ASSERT-NARY-PROPOSITION (RELATION-AND-ARGUMENTS MODULE ENVIRONMENT)
  "Assert that the proposition represented by the list ` relation-and-arguments' satisfies
the relation `relation'."
  (CL:LET*
   ((LIST (SEQUENCE-TO-CONS-LIST RELATION-AND-ARGUMENTS))
    (RELATION (STELLA::%%VALUE LIST))
    (RELATIONSURROGATE (STELLA::%SURROGATE-VALUE-INVERSE RELATION))
    (ARGUMENTS (STELLA::%%REST LIST)))
   (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
    (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
     (CL:SETQ MDL-000 STELLA::*MODULE*)
     (CL:SETQ CXT-000 STELLA::*CONTEXT*))
    (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
     (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
     (CL:SETQ ENVIRONMENT ENVIRONMENT)
     (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
      (STELLA::ASSERT-TUPLE RELATIONSURROGATE ARGUMENTS))))))

;;; (DEFUN (RETRACT-UNARY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN RETRACT-UNARY-PROPOSITION (RELATION ARG MODULE ENVIRONMENT)
  "Retract that the proposition (`relation' `arg') is TRUE in `module'.  Return the asserted proposition."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:IF (STELLA::CLASS? RELATION)
      (STELLA::RETRACT-ISA-PROPOSITION ARG
       (STELLA::%SURROGATE-VALUE-INVERSE RELATION))
      (STELLA::RETRACT-PROPERTY ARG
       (STELLA::%SURROGATE-VALUE-INVERSE RELATION)))))))

;;; (DEFUN (RETRACT-BINARY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN RETRACT-BINARY-PROPOSITION (RELATION ARG VALUE MODULE ENVIRONMENT)
  "Retract that the proposition (`relation' `arg' `value') is TRUE
in `module'.  Return the asserted proposition."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::RETRACT-BINARY-VALUE
      (STELLA::%SURROGATE-VALUE-INVERSE RELATION) ARG VALUE)))))

;;; (DEFUN (RETRACT-NARY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN RETRACT-NARY-PROPOSITION (RELATION-AND-ARGUMENTS MODULE ENVIRONMENT)
  "Retract the proposition that `arguments' satisfies
the relation `relation'."
  (CL:LET*
   ((LIST (SEQUENCE-TO-CONS-LIST RELATION-AND-ARGUMENTS))
    (RELATION (STELLA::%%VALUE LIST))
    (RELATIONSURROGATE (STELLA::%SURROGATE-VALUE-INVERSE RELATION))
    (ARGUMENTS (STELLA::%%REST LIST)))
   (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
    (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
     (CL:SETQ MDL-000 STELLA::*MODULE*)
     (CL:SETQ CXT-000 STELLA::*CONTEXT*))
    (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
     (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
     (CL:SETQ ENVIRONMENT ENVIRONMENT)
     (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
      (STELLA::UPDATE-TUPLE RELATIONSURROGATE ARGUMENTS
       KWD-PLI-RETRACT-TRUE))))))

;;; (DEFUN (ASSERT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN ASSERT-PROPOSITION (PROPOSITION MODULE ENVIRONMENT)
  "Assert that the proposition `proposition' is true in `module'.
Return the asserted proposition."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::HELP-UPDATE-TOP-LEVEL-PROPOSITION PROPOSITION
      KWD-PLI-ASSERT-TRUE)
     PROPOSITION))))

;;; (DEFUN (S-ASSERT-PROPOSITION (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN S-ASSERT-PROPOSITION (SENTENCE MODULE-NAME ENVIRONMENT)
  "Assert that the logical sentence `sentence' is true in the module
named `module-name'.  A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.

Return an iterator of the propositions resulting from sentence."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SENTENCE MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE SENTENCE CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (PROPOSITIONS STELLA::NULL) (RETURN-VALUE STELLA::NULL))
   (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
    (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
     (CL:SETQ MDL-000 STELLA::*MODULE*)
     (CL:SETQ CXT-000 STELLA::*CONTEXT*))
    (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
     (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
     (CL:SETQ ENVIRONMENT ENVIRONMENT)
     (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
      (CL:SETQ PROPOSITIONS
       (S-CONCEIVE SENTENCE MODULE-NAME ENVIRONMENT))
      (CL:SETQ RETURN-VALUE
       (CONS-TO-PL-ITERATOR (STELLA::%CURSOR PROPOSITIONS)))
      (CL:LET* ((PROPOSITION STELLA::NULL) (ITER-000 PROPOSITIONS))
       (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
        (CL:SETQ PROPOSITION (STELLA::%VALUE ITER-000))
        (STELLA::HELP-UPDATE-TOP-LEVEL-PROPOSITION PROPOSITION
         KWD-PLI-ASSERT-TRUE)))
      RETURN-VALUE)))))

;;; (DEFUN (RETRACT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN RETRACT-PROPOSITION (PROPOSITION MODULE ENVIRONMENT)
  "Retract the truth of the proposition `proposition' in `module'.
Return the retracted proposition."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::HELP-UPDATE-TOP-LEVEL-PROPOSITION PROPOSITION
      KWD-PLI-RETRACT-TRUE)
     PROPOSITION))))

;;; (DEFUN (S-RETRACT-PROPOSITION (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN S-RETRACT-PROPOSITION (SENTENCE MODULE-NAME ENVIRONMENT)
  "Retract the truth of the logical sentence `sentence' in the module named
`module-name'.  A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.

Return an iterator of the retracted propositions resulting from sentence."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SENTENCE MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE SENTENCE CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (PROPOSITIONS STELLA::NULL) (RETURN-VALUE STELLA::NULL))
   (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
    (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
     (CL:SETQ MDL-000 STELLA::*MODULE*)
     (CL:SETQ CXT-000 STELLA::*CONTEXT*))
    (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
     (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
     (CL:SETQ ENVIRONMENT ENVIRONMENT)
     (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
      (CL:SETQ PROPOSITIONS
       (S-CONCEIVE SENTENCE MODULE-NAME ENVIRONMENT))
      (CL:SETQ RETURN-VALUE
       (CONS-TO-PL-ITERATOR (STELLA::%CURSOR PROPOSITIONS)))
      (CL:LET* ((PROPOSITION STELLA::NULL) (ITER-000 PROPOSITIONS))
       (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
        (CL:SETQ PROPOSITION (STELLA::%VALUE ITER-000))
        (STELLA::HELP-UPDATE-TOP-LEVEL-PROPOSITION PROPOSITION
         KWD-PLI-RETRACT-TRUE)))
      RETURN-VALUE)))))

;;; (DEFUN (CONCEIVE (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN CONCEIVE (SENTENCE MODULE ENVIRONMENT)
  "Create one or more proposition objects from the sentence `sentence'
in the  module `module'.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.

Signals a `Proposition-Error' if PowerLoom could not conceive `sentence'."
  (CL:IF (CL:EQ SENTENCE STELLA::NULL) STELLA::NULL
   (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
    (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
     (CL:SETQ MDL-000 STELLA::*MODULE*)
     (CL:SETQ CXT-000 STELLA::*CONTEXT*))
    (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
     (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
     (CL:SETQ ENVIRONMENT ENVIRONMENT)
     (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
      (CL:LET* ((PROPOSITIONS (STELLA::CONCEIVE-FORMULA SENTENCE)))
       (CL:WHEN (CL:EQ PROPOSITIONS STELLA::NULL)
        (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((STELLA::*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL STELLA::*PRINTREADABLY?*))
          (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000)
           "ERROR: Failed to conceive `" SENTENCE "'." EOL)
          (STELLA::HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
           KWD-PLI-ERROR))
         (CL:ERROR
          (STELLA::NEW-PROPOSITION-ERROR
           (STELLA::THE-STRING-READER STREAM-000)))))
       (CL:LET*
        ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE PROPOSITIONS)))
        (CL:COND
         ((STELLA::SUBTYPE-OF? TEST-VALUE-000
           SGT-PLI-LOGIC-PROPOSITION)
          (CL:PROGN
           (CONS-TO-PL-ITERATOR
            (STELLA::CONS PROPOSITIONS STELLA::NIL))))
         ((CL:EQ TEST-VALUE-000 SGT-PLI-STELLA-CONS)
          (CL:PROGN (CONS-TO-PL-ITERATOR PROPOSITIONS)))
         (CL:T
          (CL:LET* ((STREAM-001 (STELLA::NEW-OUTPUT-STRING-STREAM)))
           (CL:LET* ((STELLA::*PRINTREADABLY?* CL:T))
            (CL:DECLARE (CL:SPECIAL STELLA::*PRINTREADABLY?*))
            (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-001)
             "ERROR: Formula is not a sentence: `" SENTENCE "'." EOL)
            (STELLA::HELP-SIGNAL-PROPOSITION-ERROR STREAM-001
             KWD-PLI-ERROR))
           (CL:ERROR
            (STELLA::NEW-PROPOSITION-ERROR
             (STELLA::THE-STRING-READER STREAM-001)))))))))))))

;;; (DEFUN (S-CONCEIVE (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN S-CONCEIVE (SENTENCE MODULE-NAME ENVIRONMENT)
  "Create one or more proposition objects from the sentence `sentence'
in the  module named `module-name'.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.

A module name of `null' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a Stella
`No-Such-Context-Exception' is thrown.

Signals a `Proposition-Error' if PowerLoom could not conceive `sentence'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SENTENCE MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE SENTENCE CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET* ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)))
   (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
    (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
     (CL:SETQ MDL-000 STELLA::*MODULE*)
     (CL:SETQ CXT-000 STELLA::*CONTEXT*))
    (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
     (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
     (CL:SETQ ENVIRONMENT ENVIRONMENT)
     (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
      (CONCEIVE (STELLA::READ-S-EXPRESSION-FROM-STRING SENTENCE) MODULE
       ENVIRONMENT))))))

;;; (DEFUN (GET-RULES (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN GET-RULES (RELATION MODULE ENVIRONMENT)
  "Return rules attached to the concept/relation `relation'
in either antecedent or consequent position."
  (CL:IF (CL:EQ RELATION STELLA::NULL) EMPTY-PL-ITERATOR
   (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
    (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
     (CL:SETQ MDL-000 STELLA::*MODULE*)
     (CL:SETQ CXT-000 STELLA::*CONTEXT*))
    (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
     (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
     (CL:SETQ ENVIRONMENT ENVIRONMENT)
     (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
      (CONS-TO-PL-ITERATOR (STELLA::CALL-GET-RULES RELATION)))))))

;;; (DEFUN (S-GET-RULES (PL-ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN S-GET-RULES (RELATION-NAME MODULE-NAME ENVIRONMENT)
  "Return rules attached to the concept/relation named
`relation-name' found in the module named `module-name'.

A module name of `null' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a Stella
`No-Such-Context-Exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RELATION-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (RELATION (SAFELY-GET-RELATION RELATION-NAME MODULE ENVIRONMENT)))
   (GET-RULES RELATION MODULE ENVIRONMENT)))

;;; (DEFUN S-PRINT-RULES ...)

(CL:DEFUN S-PRINT-RULES (NAME STREAM MODULE-NAME ENVIRONMENT)
  "Print rules attached to the concept/relation named `name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ STREAM STELLA::NULL)
   (CL:SETQ STREAM STELLA::STANDARD-OUTPUT))
  (CL:LET*
   ((RULE STELLA::NULL)
    (ITER-000 (S-GET-RULES NAME MODULE-NAME ENVIRONMENT)))
   (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
    (CL:SETQ RULE (STELLA::%VALUE ITER-000))
    (STELLA::PRINT-LOGICAL-FORM RULE STREAM)
    (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM) EOL EOL))))

;;; (DEFUN RUN-FORWARD-RULES ...)

(CL:DEFUN RUN-FORWARD-RULES (MODULE FORCE?)
  "Run forward inference rules in module `module'.
If `module' is NULL, the
current module will be used.  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless `force'
is set to TRUE, in which case all forward rules are run or rerun.

Calling `run-forward-rules' temporarily puts the module into a mode where
future assertional (monotonic) updates will trigger additional forward
inference.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of relation value, all cached forward inferences will be discarded
and forward inferencing will be disabled until this function is
called again."
  (CL:WHEN (CL:EQ MODULE STELLA::NULL)
   (CL:SETQ MODULE STELLA::*MODULE*))
  (CL:WHEN (CL:NOT (CL:EQ MODULE STELLA::NULL))
   (STELLA::CALL-RUN-FORWARD-RULES MODULE FORCE?)))

;;; (DEFUN (GET-ARITY INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) GET-ARITY))
(CL:DEFUN GET-ARITY (RELATION)
  "Return the arity of the relation `relation'."
  (CL:COND
   ((STELLA::SUBTYPE-OF? (STELLA::SAFE-PRIMARY-TYPE RELATION)
     SGT-PLI-LOGIC-NAMED-DESCRIPTION)
    (CL:PROGN (STELLA::ARITY RELATION)))
   (CL:T 0)))

;;; (DEFUN (S-GET-ARITY INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:SIMPLE-STRING CL:SIMPLE-STRING CL:T) CL:FIXNUM)
  S-GET-ARITY))
(CL:DEFUN S-GET-ARITY (RELATION-NAME MODULE-NAME ENVIRONMENT)
  "Return the arity of the relation named `relation-name'.

 A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RELATION-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (RELATION (SAFELY-GET-RELATION RELATION-NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:NOT (CL:EQ RELATION STELLA::NULL)) (GET-ARITY RELATION)
    STELLA::NULL-INTEGER)))

;;; (DEFUN (GET-DOMAIN LOGIC-OBJECT) ...)

(CL:DEFUN GET-DOMAIN (RELATION)
  "Return the type (a concept) for the first argument to the binary
relation `relation'."
  (CL:COND
   ((STELLA::SUBTYPE-OF? (STELLA::SAFE-PRIMARY-TYPE RELATION)
     SGT-PLI-LOGIC-NAMED-DESCRIPTION)
    (CL:PROGN (GET-NTH-DOMAIN RELATION 0)))
   (CL:T STELLA::NULL)))

;;; (DEFUN (S-GET-DOMAIN LOGIC-OBJECT) ...)

(CL:DEFUN S-GET-DOMAIN (RELATION-NAME MODULE-NAME ENVIRONMENT)
  "Return the type (concept) for the first argument to the binary
relation `relation-name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RELATION-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (RELATION (SAFELY-GET-RELATION RELATION-NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:NOT (CL:EQ RELATION STELLA::NULL)) (GET-DOMAIN RELATION)
    STELLA::NULL)))

;;; (DEFUN (GET-RANGE LOGIC-OBJECT) ...)

(CL:DEFUN GET-RANGE (RELATION)
  "Return the type (a concept) for fillers of the binary relation
`relation'."
  (CL:COND
   ((STELLA::SUBTYPE-OF? (STELLA::SAFE-PRIMARY-TYPE RELATION)
     SGT-PLI-LOGIC-NAMED-DESCRIPTION)
    (CL:PROGN (GET-NTH-DOMAIN RELATION 1)))
   (CL:T STELLA::NULL)))

;;; (DEFUN (S-GET-RANGE LOGIC-OBJECT) ...)

(CL:DEFUN S-GET-RANGE (RELATION-NAME MODULE-NAME ENVIRONMENT)
  "Return the type (a concept) for fillers of the binary relation
`relation-name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RELATION-NAME MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RELATION-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (RELATION (SAFELY-GET-RELATION RELATION-NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:NOT (CL:EQ RELATION STELLA::NULL)) (GET-RANGE RELATION)
    STELLA::NULL)))

;;; (DEFUN (GET-NTH-DOMAIN LOGIC-OBJECT) ...)

(CL:DEFUN GET-NTH-DOMAIN (RELATION N)
  "Return the type (a concept) for the the nth argument of the
relation `relation'.  Counting starts at zero."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:IF (STELLA::CLASS? RELATION)
   (CL:IF (CL:= N 0) RELATION STELLA::NULL)
   (CL:COND
    ((STELLA::SUBTYPE-OF? (STELLA::SAFE-PRIMARY-TYPE RELATION)
      SGT-PLI-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:IF
       (CL:AND (CL:>= N 0)
        (CL:< N
         (STELLA::LENGTH (STELLA::%IO-VARIABLE-TYPES RELATION))))
       (CL:LET*
        ((TYPE
          (STELLA::%SURROGATE-VALUE
           (STELLA::NTH (STELLA::%IO-VARIABLE-TYPES RELATION) N))))
        (CL:WHEN (CL:EQ TYPE STELLA::NULL)
         (CL:RETURN-FROM GET-NTH-DOMAIN STELLA::NULL))
        (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE TYPE)))
         (CL:COND
          ((STELLA::SUBTYPE-OF-CLASS? TEST-VALUE-000)
           (CL:PROGN
            (STELLA::DYNAMIC-SLOT-VALUE (STELLA::%DYNAMIC-SLOTS TYPE)
             SYM-PLI-LOGIC-DESCRIPTION STELLA::NULL)))
          ((STELLA::SUBTYPE-OF? TEST-VALUE-000
            SGT-PLI-LOGIC-LOGIC-OBJECT)
           (CL:PROGN TYPE))
          (CL:T
           (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
            (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000)
             "`" TEST-VALUE-000 "' is not a valid case option")
            (CL:ERROR
             (STELLA::NEW-STELLA-EXCEPTION
              (STELLA::THE-STRING-READER STREAM-000))))))))
       STELLA::NULL)))
    (CL:T STELLA::NULL))))

;;; (DEFUN (S-GET-NTH-DOMAIN LOGIC-OBJECT) ...)

(CL:DEFUN S-GET-NTH-DOMAIN (RELATION-NAME N MODULE-NAME ENVIRONMENT)
  "Return the type (a concept) for the nth argument of the relation
named `relation-name'.  Counting starts at zero.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RELATION-NAME MODULE-NAME)
   (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE RELATION-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT))
    (RELATION (SAFELY-GET-RELATION RELATION-NAME MODULE ENVIRONMENT)))
   (CL:IF (CL:NOT (CL:EQ RELATION STELLA::NULL))
    (GET-NTH-DOMAIN RELATION N) STELLA::NULL)))

;;; (DEFUN LOAD ...)

(CL:DEFUN LOAD (FILENAME ENVIRONMENT)
  "Read logic commands from the file named `filename' and evaluate them.
The file should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME))
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  (CL:LET* ((MDL-000 STELLA::*MODULE*) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::%LOAD FILENAME STELLA::NIL)))))

;;; (DEFUN LOAD-STREAM ...)

(CL:DEFUN LOAD-STREAM (STREAM ENVIRONMENT)
  "Read logic commands from the STELLA stream `stream' and evaluate them.
The stream should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them."
  (CL:LET* ((MDL-000 STELLA::*MODULE*) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (STELLA::LOAD-STREAM STREAM)))))

;;; (DEFUN LOAD-NATIVE-STREAM ...)

(CL:DEFUN LOAD-NATIVE-STREAM (STREAM ENVIRONMENT)
  "Read logic commands from the native input stream `stream' and evaluate them.
Assumes `stream' is a line-buffered stream which is a safe compromise but does
not generate the best efficiency for block-buffered streams such as files.
The stream should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them."
  (CL:LET* ((MDL-000 STELLA::*MODULE*) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET* ((SELF-000 (STELLA::NEW-INPUT-STREAM)))
      (CL:SETF (STELLA::%NATIVE-STREAM SELF-000) STREAM)
      (STELLA::LOAD-STREAM SELF-000))))))

;;; (DEFUN SAVE-MODULE ...)

(CL:DEFUN SAVE-MODULE (MODULE FILENAME IFEXISTS ENVIRONMENT)
  "Save the contents of the module `mod' into a file named `filename'.
If a file named `filename' already exists, then the action taken depends on the
value of `ifexists'.  Possible values are \"ASK\", \"REPLACE\", \"WARN\" and \"ERROR\":

  REPLACE => Means overwrite without warning.
  WARN    => Means overwrite with a warning.
  ERROR   => Means don't overwrite, signal an error instead.
  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an 
             exception is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME IFEXISTS))
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE IFEXISTS CL:SIMPLE-STRING)
  (CL:LET* ((EXISTS? (STELLA::PROBE-FILE? FILENAME)))
   (CL:COND
    ((CL:OR (CL:NOT EXISTS?)
      (STELLA::STRING-EQUAL? IFEXISTS "REPLACE")))
    ((STELLA::STRING-EQUAL? IFEXISTS "ASK")
     (CL:WHEN
      (CL:NOT
       (STELLA::YES-OR-NO?
        (STELLA::CONCATENATE "File `" FILENAME
         "' already exists.  Overwrite it? (yes or no) ")))
      (STELLA::ENSURE-FILE-DOES-NOT-EXIST FILENAME "save-module")))
    ((STELLA::STRING-EQUAL? IFEXISTS "WARN")
     (CL:WARN "File `~A' already exists, overwriting." FILENAME))
    ((STELLA::STRING-EQUAL? IFEXISTS "ERROR")
     (STELLA::ENSURE-FILE-DOES-NOT-EXIST FILENAME "save-module"))
    (CL:T
     (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
      (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000)
       "Unrecognized ifexists option `" IFEXISTS "'")
      (CL:ERROR
       (STELLA::NEW-BAD-ARGUMENT-EXCEPTION
        (STELLA::THE-STRING-READER STREAM-000))))))
   (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
    (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
     (CL:SETQ MDL-000 STELLA::*MODULE*)
     (CL:SETQ CXT-000 STELLA::*CONTEXT*))
    (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
     (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
     (CL:SETQ ENVIRONMENT ENVIRONMENT)
     (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
      (CL:LET* ((STREAM STELLA::NULL))
       (CL:UNWIND-PROTECT
        (CL:PROGN (CL:SETQ STREAM (STELLA::OPEN-OUTPUT-FILE FILENAME))
         (STELLA::DO-SAVE-MODULE STELLA::*MODULE* STREAM))
        (CL:WHEN (CL:NOT (CL:EQ STREAM STELLA::NULL))
         (STELLA::FREE STREAM)))))))))

;;; (DEFUN S-SAVE-MODULE ...)

(CL:DEFUN S-SAVE-MODULE (MODULE-NAME FILENAME IFEXISTS ENVIRONMENT)
  "Save the contents of the module `module-name' into a file named `filename'.
If a file named `filename' already exists, then the action taken depends on the
value of `ifexists'.  Possible values are \"ASK\", \"REPLACE\", \"WARN\" and \"ERROR\":

  REPLACE => Means overwrite without warning.
  WARN    => Means overwrite with a warning.
  ERROR   => Means don't overwrite, signal an error instead.
  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an
             exception is thrown.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULE-NAME FILENAME IFEXISTS))
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE IFEXISTS CL:SIMPLE-STRING)
  (SAVE-MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT) FILENAME
   IFEXISTS ENVIRONMENT))

;;; (DEFUN (GET-PREDICATE LOGIC-OBJECT) ...)

(CL:DEFUN GET-PREDICATE (PROP)
  "Return the concept or relation predicate for
the proposition `prop'."
  (CL:LET*
   ((RELATION (STELLA::GET-DESCRIPTION (STELLA::%OPERATOR PROP))))
   (CL:WHEN (CL:EQ RELATION STELLA::NULL)
    (CL:SETQ RELATION
     (STELLA::%SURROGATE-VALUE (STELLA::%OPERATOR PROP))))
   RELATION))

;;; (DEFUN (GET-COLUMN-COUNT INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) GET-COLUMN-COUNT))
(CL:DEFUN GET-COLUMN-COUNT (OBJ)
  "Return the number of columns in `obj', which must
be of type proposition, cons, vector or PL-iterator.  For a proposition,
the number includes both the predidate and arguments. For the PL-iterator
case,the number of columns is for the current value of the iterator.

For non sequence objects, the column count is zero."
  (CL:WHEN (CL:EQ OBJ STELLA::NULL) (CL:RETURN-FROM GET-COLUMN-COUNT 0))
  (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE OBJ)))
   (CL:COND
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-PROPOSITION)
     (CL:PROGN (CL:1+ (STELLA::LENGTH (STELLA::%ARGUMENTS OBJ)))))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-PLI-PL-ITERATOR)
     (CL:PROGN (GET-COLUMN-COUNT (STELLA::%VALUE OBJ))))
    ((CL:EQ TEST-VALUE-000 SGT-PLI-STELLA-CONS)
     (CL:PROGN (STELLA::LENGTH OBJ)))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-STELLA-VECTOR)
     (CL:PROGN (STELLA::LENGTH OBJ)))
    (CL:T 1))))

;;; (DEFUN (GET-NTH-VALUE OBJECT) ...)

(CL:DEFUN GET-NTH-VALUE (SEQUENCE N MODULE ENVIRONMENT)
  "Return the value in the `nth' column of `sequence'.
Counting starts at zero.  Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the number
of columns is for the current value of the iterator.

As a special case, a column number of zero will also return `sequence' itself
if it is not one of the types enumerated above.  This is done to allow the
use of `get-nth-value' on PL-iterators with only a single return variable."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:WHEN (CL:OR (CL:>= N (GET-COLUMN-COUNT SEQUENCE)) (CL:< N 0))
   (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
    (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000)
     "Column index `" N "' is out of range for `" SEQUENCE "'")
    (CL:ERROR
     (STELLA::NEW-LOGIC-EXCEPTION
      (STELLA::THE-STRING-READER STREAM-000)))))
  (CL:LET* ((TEST-VALUE-000 (STELLA::SAFE-PRIMARY-TYPE SEQUENCE)))
   (CL:COND
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:IF (CL:= N 0) (GET-PREDICATE SEQUENCE)
       (CL:LET*
        ((VALUE
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (STELLA::%THE-ARRAY (STELLA::%ARGUMENTS SEQUENCE)))
           (CL:THE CL:FIXNUM (CL:1- N)))))
        (CL:COND
         ((STELLA::SUBTYPE-OF? (STELLA::SAFE-PRIMARY-TYPE VALUE)
           SGT-PLI-LOGIC-SKOLEM)
          (CL:PROGN
           (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
            (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
             (CL:SETQ MDL-000 STELLA::*MODULE*)
             (CL:SETQ CXT-000 STELLA::*CONTEXT*))
            (CL:LET*
             ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
             (CL:DECLARE
              (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
             (CL:SETQ ENVIRONMENT ENVIRONMENT)
             (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
              (STELLA::VALUE-OF VALUE))))))
         (CL:T VALUE))))))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-PLI-PL-ITERATOR)
     (CL:PROGN
      (GET-NTH-VALUE (STELLA::%VALUE SEQUENCE) N MODULE ENVIRONMENT)))
    ((CL:EQ TEST-VALUE-000 SGT-PLI-STELLA-CONS)
     (CL:PROGN (STELLA::NTH SEQUENCE N)))
    ((STELLA::SUBTYPE-OF? TEST-VALUE-000 SGT-PLI-STELLA-VECTOR)
     (CL:PROGN
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (STELLA::%THE-ARRAY SEQUENCE))
       N)))
    (CL:T SEQUENCE))))

;;; (DEFUN (GET-NTH-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:FIXNUM CL:T CL:T) CL:SIMPLE-STRING)
  GET-NTH-STRING))
(CL:DEFUN GET-NTH-STRING (SEQUENCE N MODULE ENVIRONMENT)
  "Return a string representation of the value in the `nth' column of
`sequence'. Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  This will always
succeed, even if the `nth' value is not a string object.  In that case, a
string reprensentation will be returned.


As a special case, a column number of zero will also return `sequence' itself
as a string if it is not one of the types enumerated above.  This is done to 
allow the use of `get-nth-string' on PL-iterators with only a single return variable."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (OBJECT-TO-STRING (GET-NTH-VALUE SEQUENCE N MODULE ENVIRONMENT)))

;;; (DEFUN (GET-NTH-INTEGER INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:FIXNUM CL:T CL:T) CL:FIXNUM)
  GET-NTH-INTEGER))
(CL:DEFUN GET-NTH-INTEGER (SEQUENCE N MODULE ENVIRONMENT)
  "Return an integer representation of the value in the `nth' column of
`sequence'. Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
an integer value, then an exception will be thrown.


As a special case, a column number of zero will also return the integer
value of `sequence' itself if it is not one of the types enumerated
above.   This allows the use of `get-nth-integer' on PL-iterators with
only a single return variable.  If  `sequence' cannot be turned into an
integer, an exception will be thrown."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (OBJECT-TO-INTEGER (GET-NTH-VALUE SEQUENCE N MODULE ENVIRONMENT)))

;;; (DEFUN (GET-NTH-FLOAT FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:FIXNUM CL:T CL:T) CL:DOUBLE-FLOAT)
  GET-NTH-FLOAT))
(CL:DEFUN GET-NTH-FLOAT (SEQUENCE N MODULE ENVIRONMENT)
  "Return the floating point value in the `nth' column of
`sequence'. Counting starts at zero.  `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
a floating point value, then an exception will be thrown.


As a special case, a column number of zero will also return the floating
point value of `sequence' itself if it is not one of the types enumerated
above.  This allows the use of `get-nth-float' on PL-iterators with only
a single return variable.    If  `sequence' cannot be turned into a floating
point value, an exception will be thrown."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (OBJECT-TO-FLOAT (GET-NTH-VALUE SEQUENCE N MODULE ENVIRONMENT)))

;;; (DEFUN (GET-NTH-LOGIC-OBJECT LOGIC-OBJECT) ...)

(CL:DEFUN GET-NTH-LOGIC-OBJECT (SEQUENCE N MODULE ENVIRONMENT)
  "Return a logic object representation of the value in the `nth' column
of `sequence'.  Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  A zero column number
returns the proposition's relational predicate.  If the return value is
not a LOGIC-OBJECT, an exception is thrown.

As a special case, a column number of zero will also return `sequence' itself
if it is not one of the types enumerated above.  This is done to allow the
use of `get-nth-value' on PL-iterators with only a single return variable.
If `sequence' is not a LOGIC-OBJECT, an exception is thrown."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:LET* ((VALUE (GET-NTH-VALUE SEQUENCE N MODULE ENVIRONMENT)))
   (CL:IF (STELLA::ISA? VALUE SGT-PLI-LOGIC-LOGIC-OBJECT) VALUE
    (CL:LET* ((STREAM-000 (STELLA::NEW-OUTPUT-STRING-STREAM)))
     (STELLA::%%PRINT-STREAM (STELLA::%NATIVE-STREAM STREAM-000)
      "Can't coerce `" VALUE "' to a LOGIC-OBJECT.")
     (CL:ERROR
      (STELLA::NEW-STELLA-EXCEPTION
       (STELLA::THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (GET-ENUMERATED-COLLECTION-MEMBERS CONS) ...)

(CL:DEFUN GET-ENUMERATED-COLLECTION-MEMBERS (COLLECTION MODULE ENVIRONMENT)
  "Returns the members of an enumerated collection.  This works on all types
of collection, i.e., sets and lists"
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:LET*
      ((MEMBERS (STELLA::ASSERTED-COLLECTION-MEMBERS COLLECTION CL:T)))
      (CL:IF (CL:NOT (CL:EQ MEMBERS STELLA::NULL))
       (STELLA::%THE-CONS-LIST MEMBERS) STELLA::NULL))))))

;;; (DEFUN (EVALUATE OBJECT) ...)

(CL:DEFUN EVALUATE (COMMAND MODULE ENVIRONMENT)
  "Evaluate the command `command' within `module' and return
the result. Currently, only the evaluation of (possibly nested) commands and
global variables is supported.  Commands are simple to program in Common Lisp,
since they are built into the language, and relatively awkward in Java and C++.
Users of either of those languages are more likely to want to call `s-evaluate'."
  (CL:WHEN (CL:NOT (CL:EQ COMMAND STELLA::NULL))
   (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
    (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
     (CL:SETQ MDL-000 STELLA::*MODULE*)
     (CL:SETQ CXT-000 STELLA::*CONTEXT*))
    (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
     (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
     (CL:SETQ ENVIRONMENT ENVIRONMENT)
     (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
      (CL:RETURN-FROM EVALUATE (STELLA::%EVALUATE COMMAND))))))
  STELLA::NULL)

;;; (DEFUN (S-EVALUATE OBJECT) ...)

(CL:DEFUN S-EVALUATE (COMMAND MODULE-NAME ENVIRONMENT)
  "Evaluate the command represented by the string `command' within `module' and
return the result.  Currently, only the evaluation of (possibly nested) commands and
global variables is supported.

 A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING COMMAND MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE COMMAND CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET* ((MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)))
   (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
    (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
     (CL:SETQ MDL-000 STELLA::*MODULE*)
     (CL:SETQ CXT-000 STELLA::*CONTEXT*))
    (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
     (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
     (CL:SETQ ENVIRONMENT ENVIRONMENT)
     (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
      (EVALUATE (STELLA::READ-S-EXPRESSION-FROM-STRING COMMAND) MODULE
       ENVIRONMENT))))))

;;; (DEFUN (IS-LOGIC-OBJECT BOOLEAN) ...)

(CL:DEFUN IS-LOGIC-OBJECT (OBJ)
  "Test whether `obj' is of type LOGIC-OBJECT"
  (STELLA::ISA? OBJ SGT-PLI-LOGIC-LOGIC-OBJECT))

;;; (DEFUN (IS-INTEGER BOOLEAN) ...)

(CL:DEFUN IS-INTEGER (OBJ)
  "Test whether `obj' is of type INTEGER"
  (STELLA::ISA? OBJ SGT-PLI-STELLA-INTEGER-WRAPPER))

;;; (DEFUN (IS-FLOAT BOOLEAN) ...)

(CL:DEFUN IS-FLOAT (OBJ)
  "Test whether `obj' is of type FLOAT (double)"
  (STELLA::ISA? OBJ SGT-PLI-STELLA-FLOAT-WRAPPER))

;;; (DEFUN (IS-NUMBER BOOLEAN) ...)

(CL:DEFUN IS-NUMBER (OBJ)
  "Test whether `obj' is of type NUMBER.  This can
be either an integer or a floating point number.  One key characteristic
is that 'object-to-integer' and `object-to-float' will both work on it."
  (STELLA::ISA? OBJ SGT-PLI-STELLA-NUMBER-WRAPPER))

;;; (DEFUN (IS-STRING BOOLEAN) ...)

(CL:DEFUN IS-STRING (OBJ)
  "Test whether `obj' is of type STRING"
  (STELLA::ISA? OBJ SGT-PLI-STELLA-STRING-WRAPPER))

;;; (DEFUN (IS-ENUMERATED-COLLECTION BOOLEAN) ...)

(CL:DEFUN IS-ENUMERATED-COLLECTION (OBJ)
  "Test whether `obj' is an enumerated collection.  This
subsumes both sets and lists."
  (STELLA::LOGICAL-COLLECTION? OBJ))

;;; (DEFUN (IS-ENUMERATED-SET BOOLEAN) ...)

(CL:DEFUN IS-ENUMERATED-SET (OBJ)
  "Test whether `obj' is an enumerated set."
  (STELLA::ENUMERATED-SET? OBJ))

;;; (DEFUN (IS-ENUMERATED-LIST BOOLEAN) ...)

(CL:DEFUN IS-ENUMERATED-LIST (OBJ)
  "Test whether `obj' is an enumerated list"
  (STELLA::ENUMERATED-LIST? OBJ))

;;; (DEFUN (IS-TRUE BOOLEAN) ...)

(CL:DEFUN IS-TRUE (TV)
  "Tests whether `tv' is a true truth value.  It can be true
either absolutely or by default."
  (CL:OR (CL:EQ TV STELLA::TRUE-TRUTH-VALUE)
   (CL:EQ TV STELLA::DEFAULT-TRUE-TRUTH-VALUE)))

;;; (DEFUN (IS-FALSE BOOLEAN) ...)

(CL:DEFUN IS-FALSE (TV)
  "Tests whether `tv' is a false truth value.  It can be false
either absolutely or by default."
  (CL:OR (CL:EQ TV STELLA::FALSE-TRUTH-VALUE)
   (CL:EQ TV STELLA::DEFAULT-FALSE-TRUTH-VALUE)))

;;; (DEFUN (IS-UNKNOWN BOOLEAN) ...)

(CL:DEFUN IS-UNKNOWN (TV)
  "Tests whether `tv' is an unknown truth value."
  (CL:OR (CL:EQ TV STELLA::UNKNOWN-TRUTH-VALUE) (CL:EQ TV STELLA::NULL)))

;;; (DEFUN (IS-INCONSISTENT BOOLEAN) ...)

(CL:DEFUN IS-INCONSISTENT (TV)
  "Tests whether `tv' is an inconsistent truth value."
  (CL:EQ TV STELLA::INCONSISTENT-TRUTH-VALUE))

;;; (DEFUN (IS-STRICT BOOLEAN) ...)

(CL:DEFUN IS-STRICT (TV)
  "Tests whether `tv' is a strict (non-default) truth value."
  (CL:OR (CL:EQ TV STELLA::TRUE-TRUTH-VALUE)
   (CL:EQ TV STELLA::FALSE-TRUTH-VALUE)))

;;; (DEFUN (IS-DEFAULT BOOLEAN) ...)

(CL:DEFUN IS-DEFAULT (TV)
  "Tests whether `tv' is a default truth value."
  (CL:OR (CL:EQ TV STELLA::DEFAULT-TRUE-TRUTH-VALUE)
   (CL:EQ TV STELLA::DEFAULT-FALSE-TRUTH-VALUE)))

;;; (DEFUN (ASK TRUTH-VALUE) ...)

(CL:DEFUN ASK (QUERY MODULE ENVIRONMENT)
  "Returns a truth value for `query' in `module' and `environment'.
`query' has the same syntax as the PowerLoom `ask' command (which see)
but with the `ask' operator omitted.  For example, here are some legal
`query' arguments:
	 
    ((happy Fred))
    ((happy Fred) :inference-level :assertion)
    ((happy Fred) :inference-level :assertion :timeout 1.0)
	
As a convenience, a `query' argument whose first element is a symbol is
interpreted as a sentence that is queried without any options.  For example:
	 
    (happy Fred)
	
is a legal `query' argument.  Note that for a setence whose relation is a list
itself, e.g., `((FruitFn BananaTree) MyBanana)' this shortcut is not available,
that is, in that case an extra level of list nesting is always necessary.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions `is-true',
`is-false' and `is-unknown' (which see)."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:SETQ QUERY (STELLA::DEOBJECTIFY-TREE QUERY))
     (CL:WHEN (STELLA::SYMBOL? (STELLA::%%VALUE QUERY))
      (CL:SETQ QUERY (STELLA::CONS QUERY STELLA::NIL)))
     (STELLA::CALL-ASK QUERY)))))

;;; (DEFUN (S-ASK TRUTH-VALUE) ...)

(CL:DEFUN S-ASK (QUERY MODULE-NAME ENVIRONMENT)
  "Returns a truth value for `query' in module `module-name' and `environment'.
`query' has the same syntax as the PowerLoom `ask' command (which see) but
with the `ask' operator omitted.  Different from the PLI `ask' function, `s-ask'
does not expect a top-level pair of parentheses.  For example, here are some legal
`query' arguments:
	 
    \"(happy Fred)\"
    \"(happy Fred) :inference-level :assertion\"
    \"(happy Fred) :inference-level :assertion :timeout 1.0\"
	
Names in `query' will be interpreted relative to module `module-name'.
A null `module-name' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions `is-true',
`is-false' and `is-unknown' (which see)."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUERY MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE QUERY CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((QUERYFORM STELLA::NIL)
    (MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)))
   (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
    (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
     (CL:SETQ MDL-000 STELLA::*MODULE*)
     (CL:SETQ CXT-000 STELLA::*CONTEXT*))
    (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
     (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
     (CL:SETQ ENVIRONMENT ENVIRONMENT)
     (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
      (CL:LET*
       ((SEXP STELLA::NULL)
        (ITER-000
         (STELLA::S-EXPRESSIONS
          (STELLA::NEW-INPUT-STRING-STREAM QUERY)))
        (COLLECT-000 STELLA::NULL))
       (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
        (CL:SETQ SEXP (STELLA::%VALUE ITER-000))
        (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-000 (STELLA::CONS SEXP STELLA::NIL))
          (CL:IF (CL:EQ QUERYFORM STELLA::NIL)
           (CL:SETQ QUERYFORM COLLECT-000)
           (STELLA::ADD-CONS-TO-END-OF-CONS-LIST QUERYFORM
            COLLECT-000)))
         (CL:PROGN
          (CL:SETF (STELLA::%%REST COLLECT-000)
           (STELLA::CONS SEXP STELLA::NIL))
          (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000)))))))))
   (ASK QUERYFORM (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)
    ENVIRONMENT)))

;;; (DEFUN (RETRIEVE PL-ITERATOR) ...)

(CL:DEFUN RETRIEVE (QUERY MODULE ENVIRONMENT)
  "Returns an iterator of variable bindings that when substituted for the
open variables in `query' satisfy the query proposition.  The query is
run in `module' and relative to `environment'.  `query' has the same syntax
as the PowerLoom `retrieve' command (which see) but with the `retrieve'
operator omitted.    For example, here are some legal `query' arguments:
	 
    ((happy ?x))
    (10 (happy ?x))
    (all (happy ?x))
    (all ?x (happy ?x))
    (10 (happy ?x) :inference-level :assertion)
    (10 (happy ?x) :inference-level :assertion :timeout 1.0)
	
If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:
	 
    (all (?x) (happy ?x))
	
In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various `get-nth-...' functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables."
  (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
   (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
    (CL:SETQ MDL-000 STELLA::*MODULE*)
    (CL:SETQ CXT-000 STELLA::*CONTEXT*))
   (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
    (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
    (CL:SETQ ENVIRONMENT ENVIRONMENT)
    (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
     (CL:SETQ QUERY (STELLA::DEOBJECTIFY-TREE QUERY))
     (CONS-TO-PL-ITERATOR
      (STELLA::CONSIFY-CURRENT-SOLUTIONS
       (STELLA::CALL-RETRIEVE QUERY)))))))

;;; (DEFUN (S-RETRIEVE PL-ITERATOR) ...)

(CL:DEFUN S-RETRIEVE (QUERY MODULE-NAME ENVIRONMENT)
  "Returns an iterator of variable bindings that when substituted for the
open variables in `query' satisfy the query proposition.  The query is
run in `module' and relative to `environment'.  `query' has the same syntax
as the PowerLoom `retrieve' command (which see) but with the `retrieve'
operator omitted.  Different from the PLI `retrieve' function, `s-retrieve'
does not expect a top-level pair of parentheses.  For example, here are some
legal `query' arguments:
	 
    \"(happy ?x)\"
    \"10 (happy ?x)\"
    \"all (happy ?x)\"
    \"all ?x (happy ?x)\"
    \"10 (happy ?x) :inference-level :assertion\"
    \"10 (happy ?x) :inference-level :assertion :timeout 1.0\"
	
If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:
	 
    \"all (?x) (happy ?x)\"
	
In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various `get-nth-...' functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables.

Names in `query' will be interpreted relative to module `module-name'.
A null `module-name' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUERY MODULE-NAME))
  #+MCL
  (CL:CHECK-TYPE QUERY CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((QUERYFORM STELLA::NIL)
    (MODULE (SAFELY-GET-MODULE MODULE-NAME ENVIRONMENT)))
   (CL:LET* ((MDL-000 MODULE) (CXT-000 MDL-000))
    (CL:WHEN (CL:EQ MDL-000 STELLA::NULL)
     (CL:SETQ MDL-000 STELLA::*MODULE*)
     (CL:SETQ CXT-000 STELLA::*CONTEXT*))
    (CL:LET* ((STELLA::*MODULE* MDL-000) (STELLA::*CONTEXT* CXT-000))
     (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
     (CL:SETQ ENVIRONMENT ENVIRONMENT)
     (STELLA::WITH-PROCESS-LOCK STELLA::*POWERLOOM-LOCK*
      (CL:LET*
       ((SEXP STELLA::NULL)
        (ITER-000
         (STELLA::S-EXPRESSIONS
          (STELLA::NEW-INPUT-STRING-STREAM QUERY)))
        (COLLECT-000 STELLA::NULL))
       (CL:LOOP WHILE (STELLA::NEXT? ITER-000) DO
        (CL:SETQ SEXP (STELLA::%VALUE ITER-000))
        (CL:IF (CL:EQ COLLECT-000 STELLA::NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-000 (STELLA::CONS SEXP STELLA::NIL))
          (CL:IF (CL:EQ QUERYFORM STELLA::NIL)
           (CL:SETQ QUERYFORM COLLECT-000)
           (STELLA::ADD-CONS-TO-END-OF-CONS-LIST QUERYFORM
            COLLECT-000)))
         (CL:PROGN
          (CL:SETF (STELLA::%%REST COLLECT-000)
           (STELLA::CONS SEXP STELLA::NIL))
          (CL:SETQ COLLECT-000 (STELLA::%%REST COLLECT-000)))))))))
   (RETRIEVE QUERYFORM MODULE ENVIRONMENT)))

;;; (DEFUN MAIN ...)

(CL:DEFUN MAIN ()
  "Main PowerLoom entry point for your code in C++ and Java."
  (STELLA::%%PRINT-STREAM
   (STELLA::%NATIVE-STREAM STELLA::STANDARD-OUTPUT)
   "Initializing STELLA..." EOL)
  (STELLA::STARTUP-STELLA-SYSTEM)
  (STELLA::%%PRINT-STREAM
   (STELLA::%NATIVE-STREAM STELLA::STANDARD-OUTPUT)
   "Initializing PowerLoom..." EOL)
  (STELLA::STARTUP-LOGIC-SYSTEM)
  (STELLA::CHANGE-MODULE "PL-USER")
  (STELLA::POWERLOOM))

(CL:DEFUN HELP-STARTUP-PLI1 ()
  (CL:PROGN
   (CL:SETQ SGT-PLI-PLI-ENVIRONMENT
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "ENVIRONMENT" STELLA::NULL
     1))
   (CL:SETQ SYM-PLI-LOGIC-LEVEL
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "LEVEL"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 0))
   (CL:SETQ SGT-PLI-PLI-PL-ITERATOR
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "PL-ITERATOR" STELLA::NULL
     1))
   (CL:SETQ SYM-PLI-STELLA-CURSOR
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "CURSOR"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-PLI-STELLA-CONS
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-LIST
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "LIST"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-VECTOR
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PLI-STELLA-NULL
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "NULL"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-PLI-LOGIC-SKOLEM
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ SGT-PLI-LOGIC-LOGIC-OBJECT
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-GENERALIZED-SYMBOL
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-MODULE
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-CONTEXT
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-LOGIC-COMPUTED-PROCEDURE
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "COMPUTED-PROCEDURE"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-LITERAL-WRAPPER
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL-WRAPPER"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-LOGIC-NAMED-DESCRIPTION
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ SYM-PLI-PLI-?R
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "?R" STELLA::NULL 0))
   (CL:SETQ SYM-PLI-PLI-?I
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "?I" STELLA::NULL 0))
   (CL:SETQ SYM-PLI-PLI-?V
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "?V" STELLA::NULL 0))
   (CL:SETQ
    SYM-PLI-PLI-F-GET-INFERRED-BINARY-PROPOSITION-VALUES-QUERY-000
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-GET-INFERRED-BINARY-PROPOSITION-VALUES-QUERY-000" STELLA::NULL
     0))
   (CL:SETQ SYM-PLI-LOGIC-ALL
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "ALL"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 0))
   (CL:SETQ SYM-PLI-LOGIC-?X
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "?X"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 0))
   (CL:SETQ SYM-PLI-STELLA-AND
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PLI-LOGIC-FAIL
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 0))
   (CL:SETQ SYM-PLI-STELLA-EXISTS
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PLI-LOGIC-?Y
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "?Y"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 0))
   (CL:SETQ SYM-PLI-PLI-PROPER-SUBRELATION
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "PROPER-SUBRELATION"
     STELLA::NULL 0))
   (CL:SETQ KWD-PLI-ISA
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" STELLA::NULL 2))
   (CL:SETQ SYM-PLI-STELLA-TRUE
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PLI-STELLA-FALSE
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-PLI-CASE-SENSITIVE?
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "CASE-SENSITIVE?"
     STELLA::NULL 2))
   (CL:SETQ KWD-PLI-SUBSET-OF
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET-OF" STELLA::NULL
     2))
   (CL:SETQ KWD-PLI-ERROR
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" STELLA::NULL 2))
   (CL:SETQ KWD-PLI-RETRACT-TRUE
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-TRUE" STELLA::NULL
     2))
   (CL:SETQ KWD-PLI-ASSERT-TRUE
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" STELLA::NULL
     2))
   (CL:SETQ SGT-PLI-LOGIC-PROPOSITION
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ SYM-PLI-LOGIC-DESCRIPTION
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION"
     (STELLA::GET-STELLA-MODULE "/LOGIC" CL:T) 0))
   (CL:SETQ SGT-PLI-STELLA-INTEGER-WRAPPER
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-WRAPPER"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-FLOAT-WRAPPER
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT-WRAPPER"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-NUMBER-WRAPPER
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PLI-STELLA-STRING-WRAPPER
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-WRAPPER"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PLI-PLI-STARTUP-PLI
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-PLI" STELLA::NULL
     0))
   (CL:SETQ SYM-PLI-STELLA-METHOD-STARTUP-CLASSNAME
    (STELLA::INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (STELLA::GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-PLI2 ()
  (CL:PROGN
   (STELLA::DEFINE-FUNCTION-OBJECT "INITIALIZE"
    "(DEFUN INITIALIZE () :DOCUMENTATION \"Initialize the PowerLoom logic system.  This function
needs to be called by all applications before using PowerLoom.  If it
is called more than once, every call after the first one is a no-op.\" :PUBLIC? TRUE)"
    (CL:FUNCTION INITIALIZE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "RESET-POWERLOOM"
    "(DEFUN RESET-POWERLOOM () :DOCUMENTATION \"Reset PowerLoom to its initial state.
CAUTION: This will destroy all loaded knowledge bases and might break other
loaded STELLA systems if they do reference PowerLoom symbols in their code.\" :PUBLIC? TRUE)"
    (CL:FUNCTION RESET-POWERLOOM) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CLEAR-CACHES"
    "(DEFUN CLEAR-CACHES () :DOCUMENTATION \"Clear all query and memoization caches.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CLEAR-CACHES) STELLA::NULL)
   (STELLA::DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF PL-ITERATOR)) :PUBLIC? TRUE :DOCUMENTATION \"Advance the PL-Iterator `self' and return `true' if more
elements are available, `false' otherwise.\")"
    (CL:FUNCTION STELLA::NEXT?) STELLA::NULL)
   (STELLA::DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF PL-ITERATOR)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the iterator `self' has no more elements.\")"
    (CL:FUNCTION STELLA::EMPTY?) STELLA::NULL)
   (STELLA::DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF PL-ITERATOR)) :PUBLIC? TRUE :DOCUMENTATION \"Number of items remaining in `self'.  Non destructive.\")"
    (CL:FUNCTION STELLA::LENGTH) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CONS-TO-PL-ITERATOR"
    "(DEFUN (CONS-TO-PL-ITERATOR PL-ITERATOR) ((SELF CONS)) :PUBLIC? FALSE :DOCUMENTATION \"Convert a Stella cons list into an API iterator.\")"
    (CL:FUNCTION CONS-TO-PL-ITERATOR) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LIST-TO-PL-ITERATOR"
    "(DEFUN (LIST-TO-PL-ITERATOR PL-ITERATOR) ((SELF LIST)) :PUBLIC? FALSE :DOCUMENTATION \"Convert a Stella list into an API iterator.\")"
    (CL:FUNCTION LIST-TO-PL-ITERATOR) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "ITERATOR-TO-PL-ITERATOR"
    "(DEFUN (ITERATOR-TO-PL-ITERATOR PL-ITERATOR) ((SELF ITERATOR)) :PUBLIC? FALSE :DOCUMENTATION \"Convert an arbitrary Stella iterator into an API iterator.\")"
    (CL:FUNCTION ITERATOR-TO-PL-ITERATOR) STELLA::NULL)
   (STELLA::DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LISTIFY LIST) ((SELF PL-ITERATOR)) :PUBLIC? TRUE :DOCUMENTATION \"Convert `self' into a Stella LIST.\")"
    (CL:FUNCTION STELLA::LISTIFY) STELLA::NULL)
   (STELLA::DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONSIFY CONS) ((SELF PL-ITERATOR)) :PUBLIC? TRUE :DOCUMENTATION \"Convert `self' into a Stella CONS.\")"
    (CL:FUNCTION STELLA::CONSIFY) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SAFELY-GET-OBJECT"
    "(DEFUN (SAFELY-GET-OBJECT OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)"
    (CL:FUNCTION SAFELY-GET-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SAFELY-GET-CONCEPT"
    "(DEFUN (SAFELY-GET-CONCEPT OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)"
    (CL:FUNCTION SAFELY-GET-CONCEPT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SAFELY-GET-RELATION"
    "(DEFUN (SAFELY-GET-RELATION OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)"
    (CL:FUNCTION SAFELY-GET-RELATION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SAFELY-GET-MODULE"
    "(DEFUN (SAFELY-GET-MODULE CONTEXT) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)"
    (CL:FUNCTION SAFELY-GET-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SAFELY-GET-OBJECT-OR-NULL"
    "(DEFUN (SAFELY-GET-OBJECT-OR-NULL OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)"
    (CL:FUNCTION SAFELY-GET-OBJECT-OR-NULL) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SEQUENCE-TO-CONS-LIST"
    "(DEFUN (SEQUENCE-TO-CONS-LIST CONS) ((SEQUENCE OBJECT)) :PUBLIC? FALSE)"
    (CL:FUNCTION SEQUENCE-TO-CONS-LIST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "EXPLODE-STRING-LIST"
    "(DEFUN (EXPLODE-STRING-LIST CONS) ((STRINGLIST STRING) (MODULE MODULE)) :PUBLIC? FALSE)"
    (CL:FUNCTION EXPLODE-STRING-LIST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LEGAL-OPERATOR?"
    "(DEFUN (LEGAL-OPERATOR? BOOLEAN) ((OPERATOR SYMBOL)) :PUBLIC? FALSE)"
    (CL:FUNCTION LEGAL-OPERATOR?) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-KEYWORD"
    "(DEFUN (GET-KEYWORD KEYWORD) ((NAME STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the Stella KEYWORD `name' if it exists.  Case sensitive.\")"
    (CL:FUNCTION GET-KEYWORD) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-SYMBOL"
    "(DEFUN (GET-SYMBOL SYMBOL) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the Stella SYMBOL `name' visible in `module' if it
exists.  `name' is ALWAYS treated case sensitively.\")"
    (CL:FUNCTION GET-SYMBOL) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-OPERATOR"
    "(DEFUN (GET-OPERATOR SYMBOL) ((NAME STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the logical operator object (a Stella SYMBOL) for `name'.
If no such operator exists then a `no-such-object' exception is thrown.\")"
    (CL:FUNCTION GET-OPERATOR) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-OBJECT"
    "(DEFUN (GET-OBJECT OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Look for an object named `name' that is local to
or visible from the module `module'.\")" (CL:FUNCTION GET-OBJECT)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-OBJECT"
    "(DEFUN (S-GET-OBJECT OBJECT) ((NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Look for an object named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-CONCEPT"
    "(DEFUN (GET-CONCEPT LOGIC-OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a class/concept named `name' that is local to
or visible from the module `module'.\")" (CL:FUNCTION GET-CONCEPT)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-CONCEPT"
    "(DEFUN (S-GET-CONCEPT LOGIC-OBJECT) ((NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a class/concept named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-CONCEPT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-RELATION"
    "(DEFUN (GET-RELATION LOGIC-OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a concept or relation named `name' that is local to
or visible from the module `module'.\")" (CL:FUNCTION GET-RELATION)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-RELATION"
    "(DEFUN (S-GET-RELATION LOGIC-OBJECT) ((NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a concept or relation named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-RELATION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NAME-IN-MODULE"
    "(DEFUN (GET-NAME-IN-MODULE STRING) ((OBJ OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the name, qualified as necessary, so that `obj' can be found from
`module'.  If there is no name for the object return `null'.\")"
    (CL:FUNCTION GET-NAME-IN-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NAME"
    "(DEFUN (GET-NAME STRING) ((OBJ OBJECT)) :DOCUMENTATION \"Return the fully qualified name of `obj', if it has one.  Otherwise return `null'.\")"
    (CL:FUNCTION GET-NAME) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-SHORT-NAME"
    "(DEFUN (GET-SHORT-NAME STRING) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the short name of `obj', if it has one.  Otherwise return `null'.\")"
    (CL:FUNCTION GET-SHORT-NAME) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "OBJECT-TO-STRING"
    "(DEFUN (OBJECT-TO-STRING STRING) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a printed representation of the term `self' as a string.\")"
    (CL:FUNCTION OBJECT-TO-STRING) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "OBJECT-TO-INTEGER"
    "(DEFUN (OBJECT-TO-INTEGER INTEGER) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Coerce `self' to an integer, or throw a Stella Exception if the coersion is not feasible.
Floating point values will be coerced by rounding.\")"
    (CL:FUNCTION OBJECT-TO-INTEGER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "OBJECT-TO-FLOAT"
    "(DEFUN (OBJECT-TO-FLOAT FLOAT) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Coerce `self' to a float, or throw a Stella Exception if the coersion is not feasible.\")"
    (CL:FUNCTION OBJECT-TO-FLOAT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "OBJECT-TO-PARSABLE-STRING"
    "(DEFUN (OBJECT-TO-PARSABLE-STRING STRING) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a string representing a printed
representation of the object `self'.  Like `object-to-string', but puts
escaped double quotes around strings.\")"
    (CL:FUNCTION OBJECT-TO-PARSABLE-STRING) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "STRING-TO-OBJECT"
    "(DEFUN (STRING-TO-OBJECT OBJECT) ((STRING STRING) (TYPE LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Evaluate `string' with respect to `module' and `environment'
and return the corresponding logical term.  `type' is a concept used to assist the
correct interpretation of `string'.

Currently `type' only has an effect on the interpretation of literal types.\")"
    (CL:FUNCTION STRING-TO-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "HELP-GET-TRUE-EXTENSION-MEMBERS"
    "(DEFUN (HELP-GET-TRUE-EXTENSION-MEMBERS (CONS OF PROPOSITION)) ((RELATION NAMED-DESCRIPTION) (SPECIALIZE? BOOLEAN)) :PUBLIC? FALSE)"
    (CL:FUNCTION HELP-GET-TRUE-EXTENSION-MEMBERS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "HELP-GET-PROPOSITIONS"
    "(DEFUN (HELP-GET-PROPOSITIONS (CONS OF PROPOSITION)) ((RELATION LOGIC-OBJECT) (ARGUMENTS CONS) (LIMIT INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)"
    (CL:FUNCTION HELP-GET-PROPOSITIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPOSITION"
    "(DEFUN (GET-PROPOSITION PROPOSITION) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a proposition matching `relation-and-arguments' that
has been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card.  If more than one 
proposition matches the input criteria, the selection among satisficing
propositions is arbitrary.  This procedure is normally applied to single-valued
relations or functions.\")" (CL:FUNCTION GET-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-PROPOSITION"
    "(DEFUN (S-GET-PROPOSITION PROPOSITION) ((RELATION-AND-ARGUMENTS STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a proposition matching `relation-and-arguments' that
has been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal
reference (e.g., a number), the null identifier, or a variable (an identifier that begins
with a question mark). Each occurrence of a null or a variable acts like a wild card.
If more than one proposition matches the input criteria, the selection among
satisficing propositions is arbitrary.  This procedure is normally applied to
single-valued relations or functions.

A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPOSITIONS"
    "(DEFUN (GET-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return propositions matching `relation-and-arguments' that
have been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card.\")"
    (CL:FUNCTION GET-PROPOSITIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-PROPOSITIONS"
    "(DEFUN (S-GET-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ((RELATION-AND-ARGUMENTS STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return propositions matching `relation-and-arguments' that
have been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal 
reference (e.g., a number), the null identifier, or a variable (an identifier that begins
with a question mark). Each occurrence of a null or a variable acts like a wild card.

A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-PROPOSITIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-BINARY-PROPOSITION"
    "(DEFUN (GET-BINARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG1 OBJECT) (ARG2 OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a proposition such that (`relation' `arg1' `arg2')
is true.  The `relation' argument must be bound to a relation.  One or both
of the `arg1' and `arg2' arguments may be set to NULL, which is interpreted
as a wildcard. If more than one proposition matches the input criteria,
the selection is arbitrary.  This procedure is normally applied to single-valued
relations or functions.\")" (CL:FUNCTION GET-BINARY-PROPOSITION)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-BINARY-PROPOSITIONS"
    "(DEFUN (GET-BINARY-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ((RELATION LOGIC-OBJECT) (ARG1 OBJECT) (ARG2 OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return propositions such that (`relation' `arg1' `arg2')
is true.  The `relation' argument
must be bound to a relation.  One or both of the `arg1' and `arg2' arguments
may be set to NULL, which is interpreted as a wildcard.\")"
    (CL:FUNCTION GET-BINARY-PROPOSITIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT
    "GET-INFERRED-BINARY-PROPOSITION-VALUES"
    "(DEFUN (GET-INFERRED-BINARY-PROPOSITION-VALUES PL-ITERATOR) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return all values `v' such that (`relation' `arg' `v')
has been asserted or can be inferred.\")"
    (CL:FUNCTION GET-INFERRED-BINARY-PROPOSITION-VALUES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT
    "S-GET-INFERRED-BINARY-PROPOSITION-VALUES"
    "(DEFUN (S-GET-INFERRED-BINARY-PROPOSITION-VALUES PL-ITERATOR) ((RELATION-NAME STRING) (ARG-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return all values `v' such that (`relation-name' `arg-name' `v')
has been asserted or can be inferred.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-INFERRED-BINARY-PROPOSITION-VALUES)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPOSITIONS-OF"
    "(DEFUN (GET-PROPOSITIONS-OF (PL-ITERATOR OF PROPOSITION)) ((OBJECT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return all propositions that have `object' among their arguments,
and that are TRUE in the scope of the module `module'.\")"
    (CL:FUNCTION GET-PROPOSITIONS-OF) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-PROPOSITIONS-OF"
    "(DEFUN (S-GET-PROPOSITIONS-OF (PL-ITERATOR OF PROPOSITION)) ((OBJECT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return all propositions that have the object named `object-name' among
their arguments, and that are TRUE in the scope of the module `module-name'.
A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-PROPOSITIONS-OF) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPOSITIONS-IN-MODULE"
    "(DEFUN (GET-PROPOSITIONS-IN-MODULE (PL-ITERATOR OF PROPOSITION)) ((MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return propositions that have been conceived in
the module `module'.\")" (CL:FUNCTION GET-PROPOSITIONS-IN-MODULE)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-TRUE-UNARY-PROPOSITION"
    "(DEFUN (IS-TRUE-UNARY-PROPOSITION BOOLEAN) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the proposition (`relation' `arg') has
been asserted (or inferred by forward chaining).\")"
    (CL:FUNCTION IS-TRUE-UNARY-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-TRUE-BINARY-PROPOSITION"
    "(DEFUN (IS-TRUE-BINARY-PROPOSITION BOOLEAN) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the proposition (`relation' `arg' `value') has
been asserted (or inferred by forward chaining).\")"
    (CL:FUNCTION IS-TRUE-BINARY-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-TRUE-PROPOSITION1"
    "(DEFUN (IS-TRUE-PROPOSITION1 BOOLEAN) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if a proposition (`relation' `args') has
been asserted (or inferred by forward chaining).\")"
    (CL:FUNCTION IS-TRUE-PROPOSITION1) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-TRUE-PROPOSITION"
    "(DEFUN (IS-TRUE-PROPOSITION BOOLEAN) ((PROPOSITION PROPOSITION) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if `proposition' is  TRUE in the module `module'.\")"
    (CL:FUNCTION IS-TRUE-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-IS-TRUE-PROPOSITION"
    "(DEFUN (S-IS-TRUE-PROPOSITION BOOLEAN) ((RELATION-AND-ARGUMENTS STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if a proposition that prints as the string
`relation-and-arguments' is true in the module named `module-name'.
A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-IS-TRUE-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-SUBRELATION"
    "(DEFUN (IS-SUBRELATION BOOLEAN) ((SUB LOGIC-OBJECT) (SUPER LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if `sub' is a subconcept/subrelation of `super'.\")"
    (CL:FUNCTION IS-SUBRELATION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPER-SUBRELATIONS"
    "(DEFUN (GET-PROPER-SUBRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return relations that specialize `relation'.
Non-reflexive.\")" (CL:FUNCTION GET-PROPER-SUBRELATIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-DIRECT-SUBRELATIONS"
    "(DEFUN (GET-DIRECT-SUBRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return relations that directly specialize `relation'.
Non-reflexive.\")" (CL:FUNCTION GET-DIRECT-SUBRELATIONS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PROPER-SUPERRELATIONS"
    "(DEFUN (GET-PROPER-SUPERRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return relations that generalize `relation'.
Non-reflexive.\")" (CL:FUNCTION GET-PROPER-SUPERRELATIONS)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-DIRECT-SUPERRELATIONS"
    "(DEFUN (GET-DIRECT-SUPERRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return relations that directly generalize `relation'.
Non-reflexive.\")" (CL:FUNCTION GET-DIRECT-SUPERRELATIONS)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-A"
    "(DEFUN (IS-A BOOLEAN) ((OBJECT OBJECT) (CONCEPT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if `object' is a member of the concept `concept'.\")"
    (CL:FUNCTION IS-A) STELLA::NULL)))

(CL:DEFUN HELP-STARTUP-PLI3 ()
  (CL:PROGN
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-CONCEPT-INSTANCES"
    "(DEFUN (GET-CONCEPT-INSTANCES PL-ITERATOR) ((CONCEPT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return instances of the concept `concept'.
Include instances of subconcepts of `concept'.  Depending on `concept',
the return values could be (wrapped) literals.\")"
    (CL:FUNCTION GET-CONCEPT-INSTANCES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-CONCEPT-INSTANCES"
    "(DEFUN (S-GET-CONCEPT-INSTANCES PL-ITERATOR) ((CONCEPT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return instances of concept `concept-name'.
Include instances of subconcepts of `concept-name'.  Depending on `concept-name',
the return values could be (wrapped) literals.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-CONCEPT-INSTANCES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-DIRECT-CONCEPT-INSTANCES"
    "(DEFUN (GET-DIRECT-CONCEPT-INSTANCES PL-ITERATOR) ((CONCEPT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return instances of concept `concept'.
Exclude instances of subconcepts of `concept'.  Depending on `concept',
the return values could be (wrapped) literals.\")"
    (CL:FUNCTION GET-DIRECT-CONCEPT-INSTANCES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-DIRECT-CONCEPT-INSTANCES"
    "(DEFUN (S-GET-DIRECT-CONCEPT-INSTANCES PL-ITERATOR) ((CONCEPT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return instances of concept `concept-name'.
Exclude instances of subconcepts of `concept-name'.  Depending on `concept-name',
the return values could be (wrapped) literals.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-DIRECT-CONCEPT-INSTANCES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT
    "GET-CONCEPT-INSTANCES-MATCHING-VALUE"
    "(DEFUN (GET-CONCEPT-INSTANCES-MATCHING-VALUE PL-ITERATOR) ((CONCEPT LOGIC-OBJECT) (RELATION LOGIC-OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return members of concept `concept' that
have an attribute matching `value' for the binary relation `relation', i.e.,
`(relation <result> value)' holds.\")"
    (CL:FUNCTION GET-CONCEPT-INSTANCES-MATCHING-VALUE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT
    "GET-CONCEPT-INSTANCE-MATCHING-VALUE"
    "(DEFUN (GET-CONCEPT-INSTANCE-MATCHING-VALUE OBJECT) ((CONCEPT LOGIC-OBJECT) (RELATION LOGIC-OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a member of concept `concept' that
has an attribute matching `value' for the binary relation `relation', i.e.,
`(relation <result> value)' holds.\")"
    (CL:FUNCTION GET-CONCEPT-INSTANCE-MATCHING-VALUE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-TYPES"
    "(DEFUN (GET-TYPES (PL-ITERATOR OF LOGIC-OBJECT)) ((OBJECT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return all named concepts that `object' belongs to.\")"
    (CL:FUNCTION GET-TYPES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-DIRECT-TYPES"
    "(DEFUN (GET-DIRECT-TYPES (PL-ITERATOR OF LOGIC-OBJECT)) ((OBJECT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return most specific concepts that `object' belongs to.\")"
    (CL:FUNCTION GET-DIRECT-TYPES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-RELATION-EXTENSION"
    "(DEFUN (GET-RELATION-EXTENSION (PL-ITERATOR OF PROPOSITION)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Return propositions that satisfy `relation'.
Include propositions that satisfy subrelations of `relation'.\")"
    (CL:FUNCTION GET-RELATION-EXTENSION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-RELATION-EXTENSION"
    "(DEFUN (S-GET-RELATION-EXTENSION (PL-ITERATOR OF PROPOSITION)) ((RELATION-NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return propositions that satisfy the relation named
`relation-name'.  Include propositions that satisfy subrelations of the relation.\")"
    (CL:FUNCTION S-GET-RELATION-EXTENSION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-MODULE"
    "(DEFUN (GET-MODULE MODULE) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a module named `name'.\")"
    (CL:FUNCTION GET-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-CURRENT-MODULE"
    "(DEFUN (GET-CURRENT-MODULE MODULE) ((ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the currently set module\")"
    (CL:FUNCTION GET-CURRENT-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-HOME-MODULE"
    "(DEFUN (GET-HOME-MODULE MODULE) ((OBJECT LOGIC-OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the module in which `object' was created.\")"
    (CL:FUNCTION GET-HOME-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-MODULES"
    "(DEFUN (GET-MODULES (PL-ITERATOR OF MODULE)) ((KB-MODULES-ONLY? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Return all modules currently loaded into PowerLoom.  If `kb-modules-only?'
is `true', then Stella modules that are used only for program code are
not included in the list.\")" (CL:FUNCTION GET-MODULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-MODULE"
    "(DEFUN (CREATE-MODULE MODULE) ((NAME STRING) (PARENT MODULE) (CASE-SENSITIVE? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Creates a new module `name' as a child of `parent'.  The flag
`case-sensitive?' controls whether names read in this module will be
case sensitive or not.\")" (CL:FUNCTION CREATE-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CREATE-MODULE"
    "(DEFUN (S-CREATE-MODULE MODULE) ((NAME STRING) (PARENT-NAME STRING) (CASE-SENSITIVE? BOOLEAN) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Creates a new module `name' as a child of `parent-name'.  The flag
`case-sensitive?' controls whether names read in this module will be
case sensitive or not.\")" (CL:FUNCTION S-CREATE-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CHANGE-MODULE"
    "(DEFUN (CHANGE-MODULE MODULE) ((MODULE MODULE)) :PUBLIC? TRUE :DOCUMENTATION \"Set the current module to `module' and return it.
If `module' is `null', then no switch is performed and the current
module is returned.\")" (CL:FUNCTION CHANGE-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CHANGE-MODULE"
    "(DEFUN (S-CHANGE-MODULE MODULE) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Set the current module to the module named `name'.
The return value is the module named `name' unless `name' is null or
the empty string.  In that case, the current module is returned.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown.\")" (CL:FUNCTION S-CHANGE-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CLEAR-MODULE"
    "(DEFUN (CLEAR-MODULE MODULE) ((MODULE MODULE)) :PUBLIC? TRUE :DOCUMENTATION \"Destroy the contents of the module `module' as well as
the contents of all of its children, recursively.\")"
    (CL:FUNCTION CLEAR-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CLEAR-MODULE"
    "(DEFUN (S-CLEAR-MODULE MODULE) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Destroy the contents of the module named `name', as
well as the contents of all of its children, recursively.  If no module
named `name' exists, a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-CLEAR-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-CHILD-MODULES"
    "(DEFUN (GET-CHILD-MODULES (PL-ITERATOR OF MODULE)) ((MODULE MODULE)) :PUBLIC? TRUE :DOCUMENTATION \"Return the modules that are immediate children of `module'.\")"
    (CL:FUNCTION GET-CHILD-MODULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-CHILD-MODULES"
    "(DEFUN (S-GET-CHILD-MODULES (PL-ITERATOR OF MODULE)) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the modules that are immediate children of module `name'.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown.\")" (CL:FUNCTION S-GET-CHILD-MODULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PARENT-MODULES"
    "(DEFUN (GET-PARENT-MODULES (PL-ITERATOR OF MODULE)) ((MODULE MODULE)) :PUBLIC? TRUE :DOCUMENTATION \"Return the modules that are immediate parents of `module'.\")"
    (CL:FUNCTION GET-PARENT-MODULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-PARENT-MODULES"
    "(DEFUN (S-GET-PARENT-MODULES (PL-ITERATOR OF MODULE)) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the modules that are immediate parents of module `name'.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown.\")" (CL:FUNCTION S-GET-PARENT-MODULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GENERATE-UNIQUE-NAME"
    "(DEFUN (GENERATE-UNIQUE-NAME STRING) ((PREFIX STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Generates a name based on `prefix' with a number appended that
is not currently in use in `module.'  In a non-case-sensitive module, the returned
name will be all upper case (This latter feature may change!)\")"
    (CL:FUNCTION GENERATE-UNIQUE-NAME) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-KEYWORD"
    "(DEFUN (CREATE-KEYWORD KEYWORD) ((NAME STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the Stella keyword `name', creating it if
necessary.  `name' is treated case-sensitively.  This should
generally not be necessary to do.\")" (CL:FUNCTION CREATE-KEYWORD)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-SYMBOL"
    "(DEFUN (CREATE-SYMBOL SYMBOL) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the Stella symbol `name' visible in `module',
creating it if necessary.  `name' is ALWAYS treated case-sensitively,
even if `module' is case insensitive. This should generally not be
necessary to do.\")" (CL:FUNCTION CREATE-SYMBOL) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-OBJECT"
    "(DEFUN (CREATE-OBJECT LOGIC-OBJECT) ((NAME STRING) (CONCEPT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create an object named `name' of type `concept' in the designated
module.  Both `name' and `concept' can be `null'.  If `name' is `null' then an
object will be created with a new, non-conflicting name based on the name of
`concept', or system-generated if no concept is specified.  If `concept' is
`null', then the object will be of type THING.  It is an error to create an
object with the same name as an existing object.

Note that the string can be a qualified name, in which case the object
will be created in the module specified, but with a name as determined
by the qualified name.  Vertical bars in the name string are interpreted
as Stella escape characters.

Note that because names in modules that are not case-sensitive are
canonicalized, the name of the returned object may not match `name'
exactly.

Return the object.\")" (CL:FUNCTION CREATE-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CREATE-OBJECT"
    "(DEFUN (S-CREATE-OBJECT LOGIC-OBJECT) ((NAME STRING) (CONCEPT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create an object named `name' of type `concept-name' in the designated
module.  Both `name' and `concept-name' can be null strings.  If `name' is a null string
then an object will be created with a new, non-conflicting name based on `concept-name', or
system-generated if no concept nameis specified.  If `concept-name' is the null string, then
the object will be of type THING.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.

Return the object.\")" (CL:FUNCTION S-CREATE-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-CONCEPT"
    "(DEFUN (CREATE-CONCEPT LOGIC-OBJECT) ((NAME STRING) (PARENT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a concept named `name' in the designated `module', with the
designated `parent' superconcept (which can be left undefined).  Additional
superconcepts can be added via assertions of the `subset-of' relation.  Note
that a specified `parent' concept needs to be created separately.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.\")"
    (CL:FUNCTION CREATE-CONCEPT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CREATE-CONCEPT"
    "(DEFUN (S-CREATE-CONCEPT LOGIC-OBJECT) ((NAME STRING) (PARENT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a concept named `name' in the designated module, with
with the concept named `parent-name' as superconcept (which can be left
undefined).  Additional superconcepts can be added via assertions of the
`subset-of' relation.  Note that a specified parent concept needs to be
created separately.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.\")"
    (CL:FUNCTION S-CREATE-CONCEPT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-RELATION"
    "(DEFUN (CREATE-RELATION LOGIC-OBJECT) ((NAME STRING) (ARITY INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a relation named `name' with arity `arity' in the
designated module.  Domain and range information can be added via assertions
of `nth-domain' (or `domain' and `range') relations.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.\")"
    (CL:FUNCTION CREATE-RELATION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CREATE-RELATION"
    "(DEFUN (S-CREATE-RELATION LOGIC-OBJECT) ((NAME STRING) (ARITY INTEGER) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a relation named `name' with arity `arity' in the
designated module.  Domain and range information can be added via assertions
of `nth-domain' (or `domain' and `range') relations.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.\")"
    (CL:FUNCTION S-CREATE-RELATION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-FUNCTION"
    "(DEFUN (CREATE-FUNCTION LOGIC-OBJECT) ((NAME STRING) (ARITY INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a function named `name' with arity `arity'  in the designated 
`module'.  Domain and range information can be added via assertions of
`nth-domain' (or `domain' and `range') relations.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.\")"
    (CL:FUNCTION CREATE-FUNCTION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CREATE-FUNCTION"
    "(DEFUN (S-CREATE-FUNCTION LOGIC-OBJECT) ((NAME STRING) (ARITY INTEGER) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a function named `name' with arity `arity' in the designated 
module.  Domain and range information can be added via assertions of
`domain', `nth-domain' and `range' relations.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.\")"
    (CL:FUNCTION S-CREATE-FUNCTION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "REGISTER-SPECIALIST-FUNCTION"
    "(DEFUN REGISTER-SPECIALIST-FUNCTION ((NAME STRING) (FUNCTION-REFERENCE FUNCTION-CODE) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Register `name' as a function name in `module' which will invoke the
native code procedure described by `function-reference.'  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The function must conform
to the signature for specialist functions.

The exact form of `function-reference' depends on the underlying
programming language.  The following type mappings are used:
          C++:  
  Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))
         Java:  java.lang.reflect.Method\")"
    (CL:FUNCTION REGISTER-SPECIALIST-FUNCTION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-REGISTER-SPECIALIST-FUNCTION"
    "(DEFUN S-REGISTER-SPECIALIST-FUNCTION ((NAME STRING) (NATIVE-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Register `name' as a function name in the module named `module-name'.
This function will the native code named `native-name'.  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The `native-name' will be
processed in a manner that depends on the underlying programming
language.  The following type mappings are used:
          C++:  Not available.  Error signaled.
  Common Lisp:  The native-name is read by READ-FROM-STRING and then
                the SYMBOL-FUNCTION is taken.
         Java:  A fully package-qualified name is required.  It is
                looked up using the Reflection tools.
The function found must conform to the signature for specialist functions.\")"
    (CL:FUNCTION S-REGISTER-SPECIALIST-FUNCTION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-ENUMERATED-LIST"
    "(DEFUN (CREATE-ENUMERATED-LIST LOGIC-OBJECT) ((MEMBERS CONS) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a logical term that denotes a list containing `members' in
`module' using `environment'.  Useful for passing lists as arguments
to parameterized queries.\")" (CL:FUNCTION CREATE-ENUMERATED-LIST)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CREATE-ENUMERATED-SET"
    "(DEFUN (CREATE-ENUMERATED-SET LOGIC-OBJECT) ((MEMBERS CONS) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a logical term that denotes the enumerated set containing `members'
in `module' using `environment'.\")"
    (CL:FUNCTION CREATE-ENUMERATED-SET) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "DESTROY-OBJECT"
    "(DEFUN DESTROY-OBJECT ((OBJECT LOGIC-OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Delete the object `object', retracting all facts attached to it.\")"
    (CL:FUNCTION DESTROY-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-DESTROY-OBJECT"
    "(DEFUN S-DESTROY-OBJECT ((OBJECT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Delete the object named `object-name', retracting all facts
attached to it.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-DESTROY-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "ASSERT-UNARY-PROPOSITION"
    "(DEFUN (ASSERT-UNARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Assert that the proposition (`relation' `arg') is TRUE in `module'.  Return the asserted proposition.\")"
    (CL:FUNCTION ASSERT-UNARY-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "ASSERT-BINARY-PROPOSITION"
    "(DEFUN (ASSERT-BINARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Assert that the proposition (`relation' `arg' `value') is TRUE
in `module'.  Return the asserted proposition.\")"
    (CL:FUNCTION ASSERT-BINARY-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "ASSERT-NARY-PROPOSITION"
    "(DEFUN (ASSERT-NARY-PROPOSITION PROPOSITION) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Assert that the proposition represented by the list ` relation-and-arguments' satisfies
the relation `relation'.\")" (CL:FUNCTION ASSERT-NARY-PROPOSITION)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "RETRACT-UNARY-PROPOSITION"
    "(DEFUN (RETRACT-UNARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Retract that the proposition (`relation' `arg') is TRUE in `module'.  Return the asserted proposition.\")"
    (CL:FUNCTION RETRACT-UNARY-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "RETRACT-BINARY-PROPOSITION"
    "(DEFUN (RETRACT-BINARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Retract that the proposition (`relation' `arg' `value') is TRUE
in `module'.  Return the asserted proposition.\")"
    (CL:FUNCTION RETRACT-BINARY-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "RETRACT-NARY-PROPOSITION"
    "(DEFUN (RETRACT-NARY-PROPOSITION PROPOSITION) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Retract the proposition that `arguments' satisfies
the relation `relation'.\")" (CL:FUNCTION RETRACT-NARY-PROPOSITION)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "ASSERT-PROPOSITION"
    "(DEFUN (ASSERT-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Assert that the proposition `proposition' is true in `module'.
Return the asserted proposition.\")" (CL:FUNCTION ASSERT-PROPOSITION)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-ASSERT-PROPOSITION"
    "(DEFUN (S-ASSERT-PROPOSITION (PL-ITERATOR OF PROPOSITION)) ((SENTENCE STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Assert that the logical sentence `sentence' is true in the module
named `module-name'.  A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.

Return an iterator of the propositions resulting from sentence.\")"
    (CL:FUNCTION S-ASSERT-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "RETRACT-PROPOSITION"
    "(DEFUN (RETRACT-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Retract the truth of the proposition `proposition' in `module'.
Return the retracted proposition.\")" (CL:FUNCTION RETRACT-PROPOSITION)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-RETRACT-PROPOSITION"
    "(DEFUN (S-RETRACT-PROPOSITION (PL-ITERATOR OF PROPOSITION)) ((SENTENCE STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Retract the truth of the logical sentence `sentence' in the module named
`module-name'.  A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.

Return an iterator of the retracted propositions resulting from sentence.\")"
    (CL:FUNCTION S-RETRACT-PROPOSITION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "CONCEIVE"
    "(DEFUN (CONCEIVE (PL-ITERATOR OF PROPOSITION)) ((SENTENCE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create one or more proposition objects from the sentence `sentence'
in the  module `module'.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.

Signals a `Proposition-Error' if PowerLoom could not conceive `sentence'.\")"
    (CL:FUNCTION CONCEIVE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-CONCEIVE"
    "(DEFUN (S-CONCEIVE (PL-ITERATOR OF PROPOSITION)) ((SENTENCE STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create one or more proposition objects from the sentence `sentence'
in the  module named `module-name'.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.

A module name of `null' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a Stella
`No-Such-Context-Exception' is thrown.

Signals a `Proposition-Error' if PowerLoom could not conceive `sentence'.\")"
    (CL:FUNCTION S-CONCEIVE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-RULES"
    "(DEFUN (GET-RULES (PL-ITERATOR OF PROPOSITION)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return rules attached to the concept/relation `relation'
in either antecedent or consequent position.\")"
    (CL:FUNCTION GET-RULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-RULES"
    "(DEFUN (S-GET-RULES (PL-ITERATOR OF PROPOSITION)) ((RELATION-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return rules attached to the concept/relation named
`relation-name' found in the module named `module-name'.

A module name of `null' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a Stella
`No-Such-Context-Exception' is thrown.\")" (CL:FUNCTION S-GET-RULES)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-PRINT-RULES"
    "(DEFUN S-PRINT-RULES ((NAME STRING) (STREAM OUTPUT-STREAM) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Print rules attached to the concept/relation named `name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.\" :PUBLIC? TRUE)"
    (CL:FUNCTION S-PRINT-RULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "RUN-FORWARD-RULES"
    "(DEFUN RUN-FORWARD-RULES ((MODULE OBJECT) (FORCE? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Run forward inference rules in module `module'.
If `module' is NULL, the
current module will be used.  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless `force'
is set to TRUE, in which case all forward rules are run or rerun.

Calling `run-forward-rules' temporarily puts the module into a mode where
future assertional (monotonic) updates will trigger additional forward
inference.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of relation value, all cached forward inferences will be discarded
and forward inferencing will be disabled until this function is
called again.\")" (CL:FUNCTION RUN-FORWARD-RULES) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-ARITY"
    "(DEFUN (GET-ARITY INTEGER) ((RELATION LOGIC-OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the arity of the relation `relation'.\")"
    (CL:FUNCTION GET-ARITY) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-ARITY"
    "(DEFUN (S-GET-ARITY INTEGER) ((RELATION-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the arity of the relation named `relation-name'.

 A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-ARITY) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-DOMAIN"
    "(DEFUN (GET-DOMAIN LOGIC-OBJECT) ((RELATION LOGIC-OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the type (a concept) for the first argument to the binary
relation `relation'.\")" (CL:FUNCTION GET-DOMAIN) STELLA::NULL)))

(CL:DEFUN HELP-STARTUP-PLI4 ()
  (CL:PROGN
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-DOMAIN"
    "(DEFUN (S-GET-DOMAIN LOGIC-OBJECT) ((RELATION-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the type (concept) for the first argument to the binary
relation `relation-name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-DOMAIN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-RANGE"
    "(DEFUN (GET-RANGE LOGIC-OBJECT) ((RELATION LOGIC-OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the type (a concept) for fillers of the binary relation
`relation'.\")" (CL:FUNCTION GET-RANGE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-RANGE"
    "(DEFUN (S-GET-RANGE LOGIC-OBJECT) ((RELATION-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the type (a concept) for fillers of the binary relation
`relation-name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-RANGE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NTH-DOMAIN"
    "(DEFUN (GET-NTH-DOMAIN LOGIC-OBJECT) ((RELATION LOGIC-OBJECT) (N INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Return the type (a concept) for the the nth argument of the
relation `relation'.  Counting starts at zero.\")"
    (CL:FUNCTION GET-NTH-DOMAIN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-GET-NTH-DOMAIN"
    "(DEFUN (S-GET-NTH-DOMAIN LOGIC-OBJECT) ((RELATION-NAME STRING) (N INTEGER) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the type (a concept) for the nth argument of the relation
named `relation-name'.  Counting starts at zero.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-GET-NTH-DOMAIN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LOAD"
    "(DEFUN LOAD ((FILENAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Read logic commands from the file named `filename' and evaluate them.
The file should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them.\")" (CL:FUNCTION LOAD) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LOAD-STREAM"
    "(DEFUN LOAD-STREAM ((STREAM INPUT-STREAM) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Read logic commands from the STELLA stream `stream' and evaluate them.
The stream should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them.\")" (CL:FUNCTION LOAD-STREAM) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "LOAD-NATIVE-STREAM"
    "(DEFUN LOAD-NATIVE-STREAM ((STREAM NATIVE-INPUT-STREAM) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Read logic commands from the native input stream `stream' and evaluate them.
Assumes `stream' is a line-buffered stream which is a safe compromise but does
not generate the best efficiency for block-buffered streams such as files.
The stream should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them.\")" (CL:FUNCTION LOAD-NATIVE-STREAM)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "SAVE-MODULE"
    "(DEFUN SAVE-MODULE ((MODULE MODULE) (FILENAME STRING) (IFEXISTS STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Save the contents of the module `mod' into a file named `filename'.
If a file named `filename' already exists, then the action taken depends on the
value of `ifexists'.  Possible values are \\\"ASK\\\", \\\"REPLACE\\\", \\\"WARN\\\" and \\\"ERROR\\\":

  REPLACE => Means overwrite without warning.
  WARN    => Means overwrite with a warning.
  ERROR   => Means don't overwrite, signal an error instead.
  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an 
             exception is thrown.\")" (CL:FUNCTION SAVE-MODULE)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-SAVE-MODULE"
    "(DEFUN S-SAVE-MODULE ((MODULE-NAME STRING) (FILENAME STRING) (IFEXISTS STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Save the contents of the module `module-name' into a file named `filename'.
If a file named `filename' already exists, then the action taken depends on the
value of `ifexists'.  Possible values are \\\"ASK\\\", \\\"REPLACE\\\", \\\"WARN\\\" and \\\"ERROR\\\":

  REPLACE => Means overwrite without warning.
  WARN    => Means overwrite with a warning.
  ERROR   => Means don't overwrite, signal an error instead.
  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an
             exception is thrown.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-SAVE-MODULE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-PREDICATE"
    "(DEFUN (GET-PREDICATE LOGIC-OBJECT) ((PROP PROPOSITION)) :PUBLIC? TRUE :DOCUMENTATION \"Return the concept or relation predicate for
the proposition `prop'.\")" (CL:FUNCTION GET-PREDICATE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-COLUMN-COUNT"
    "(DEFUN (GET-COLUMN-COUNT INTEGER) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the number of columns in `obj', which must
be of type proposition, cons, vector or PL-iterator.  For a proposition,
the number includes both the predidate and arguments. For the PL-iterator
case,the number of columns is for the current value of the iterator.

For non sequence objects, the column count is zero.\")"
    (CL:FUNCTION GET-COLUMN-COUNT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NTH-VALUE"
    "(DEFUN (GET-NTH-VALUE OBJECT) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the value in the `nth' column of `sequence'.
Counting starts at zero.  Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the number
of columns is for the current value of the iterator.

As a special case, a column number of zero will also return `sequence' itself
if it is not one of the types enumerated above.  This is done to allow the
use of `get-nth-value' on PL-iterators with only a single return variable.\")"
    (CL:FUNCTION GET-NTH-VALUE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NTH-STRING"
    "(DEFUN (GET-NTH-STRING STRING) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a string representation of the value in the `nth' column of
`sequence'. Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  This will always
succeed, even if the `nth' value is not a string object.  In that case, a
string reprensentation will be returned.


As a special case, a column number of zero will also return `sequence' itself
as a string if it is not one of the types enumerated above.  This is done to 
allow the use of `get-nth-string' on PL-iterators with only a single return variable.\")"
    (CL:FUNCTION GET-NTH-STRING) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NTH-INTEGER"
    "(DEFUN (GET-NTH-INTEGER INTEGER) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return an integer representation of the value in the `nth' column of
`sequence'. Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
an integer value, then an exception will be thrown.


As a special case, a column number of zero will also return the integer
value of `sequence' itself if it is not one of the types enumerated
above.   This allows the use of `get-nth-integer' on PL-iterators with
only a single return variable.  If  `sequence' cannot be turned into an
integer, an exception will be thrown.\")" (CL:FUNCTION GET-NTH-INTEGER)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NTH-FLOAT"
    "(DEFUN (GET-NTH-FLOAT FLOAT) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the floating point value in the `nth' column of
`sequence'. Counting starts at zero.  `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
a floating point value, then an exception will be thrown.


As a special case, a column number of zero will also return the floating
point value of `sequence' itself if it is not one of the types enumerated
above.  This allows the use of `get-nth-float' on PL-iterators with only
a single return variable.    If  `sequence' cannot be turned into a floating
point value, an exception will be thrown.\")"
    (CL:FUNCTION GET-NTH-FLOAT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-NTH-LOGIC-OBJECT"
    "(DEFUN (GET-NTH-LOGIC-OBJECT LOGIC-OBJECT) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a logic object representation of the value in the `nth' column
of `sequence'.  Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  A zero column number
returns the proposition's relational predicate.  If the return value is
not a LOGIC-OBJECT, an exception is thrown.

As a special case, a column number of zero will also return `sequence' itself
if it is not one of the types enumerated above.  This is done to allow the
use of `get-nth-value' on PL-iterators with only a single return variable.
If `sequence' is not a LOGIC-OBJECT, an exception is thrown.\")"
    (CL:FUNCTION GET-NTH-LOGIC-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "GET-ENUMERATED-COLLECTION-MEMBERS"
    "(DEFUN (GET-ENUMERATED-COLLECTION-MEMBERS CONS) ((COLLECTION OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the members of an enumerated collection.  This works on all types
of collection, i.e., sets and lists\")"
    (CL:FUNCTION GET-ENUMERATED-COLLECTION-MEMBERS) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "EVALUATE"
    "(DEFUN (EVALUATE OBJECT) ((COMMAND OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Evaluate the command `command' within `module' and return
the result. Currently, only the evaluation of (possibly nested) commands and
global variables is supported.  Commands are simple to program in Common Lisp,
since they are built into the language, and relatively awkward in Java and C++.
Users of either of those languages are more likely to want to call `s-evaluate'.\")"
    (CL:FUNCTION EVALUATE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-EVALUATE"
    "(DEFUN (S-EVALUATE OBJECT) ((COMMAND STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Evaluate the command represented by the string `command' within `module' and
return the result.  Currently, only the evaluation of (possibly nested) commands and
global variables is supported.

 A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.\")"
    (CL:FUNCTION S-EVALUATE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-LOGIC-OBJECT"
    "(DEFUN (IS-LOGIC-OBJECT BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is of type LOGIC-OBJECT\")"
    (CL:FUNCTION IS-LOGIC-OBJECT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-INTEGER"
    "(DEFUN (IS-INTEGER BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is of type INTEGER\")"
    (CL:FUNCTION IS-INTEGER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-FLOAT"
    "(DEFUN (IS-FLOAT BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is of type FLOAT (double)\")"
    (CL:FUNCTION IS-FLOAT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-NUMBER"
    "(DEFUN (IS-NUMBER BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is of type NUMBER.  This can
be either an integer or a floating point number.  One key characteristic
is that 'object-to-integer' and `object-to-float' will both work on it.\")"
    (CL:FUNCTION IS-NUMBER) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-STRING"
    "(DEFUN (IS-STRING BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is of type STRING\")"
    (CL:FUNCTION IS-STRING) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-ENUMERATED-COLLECTION"
    "(DEFUN (IS-ENUMERATED-COLLECTION BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is an enumerated collection.  This
subsumes both sets and lists.\")"
    (CL:FUNCTION IS-ENUMERATED-COLLECTION) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-ENUMERATED-SET"
    "(DEFUN (IS-ENUMERATED-SET BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is an enumerated set.\")"
    (CL:FUNCTION IS-ENUMERATED-SET) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-ENUMERATED-LIST"
    "(DEFUN (IS-ENUMERATED-LIST BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is an enumerated list\")"
    (CL:FUNCTION IS-ENUMERATED-LIST) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-TRUE"
    "(DEFUN (IS-TRUE BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :DOCUMENTATION \"Tests whether `tv' is a true truth value.  It can be true
either absolutely or by default.\")" (CL:FUNCTION IS-TRUE)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-FALSE"
    "(DEFUN (IS-FALSE BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :DOCUMENTATION \"Tests whether `tv' is a false truth value.  It can be false
either absolutely or by default.\")" (CL:FUNCTION IS-FALSE)
    STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-UNKNOWN"
    "(DEFUN (IS-UNKNOWN BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :DOCUMENTATION \"Tests whether `tv' is an unknown truth value.\")"
    (CL:FUNCTION IS-UNKNOWN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-INCONSISTENT"
    "(DEFUN (IS-INCONSISTENT BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :DOCUMENTATION \"Tests whether `tv' is an inconsistent truth value.\")"
    (CL:FUNCTION IS-INCONSISTENT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-STRICT"
    "(DEFUN (IS-STRICT BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :DOCUMENTATION \"Tests whether `tv' is a strict (non-default) truth value.\")"
    (CL:FUNCTION IS-STRICT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "IS-DEFAULT"
    "(DEFUN (IS-DEFAULT BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :DOCUMENTATION \"Tests whether `tv' is a default truth value.\")"
    (CL:FUNCTION IS-DEFAULT) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "ASK"
    "(DEFUN (ASK TRUTH-VALUE) ((QUERY CONS) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Returns a truth value for `query' in `module' and `environment'.
`query' has the same syntax as the PowerLoom `ask' command (which see)
but with the `ask' operator omitted.  For example, here are some legal
`query' arguments:
	 
    ((happy Fred))
    ((happy Fred) :inference-level :assertion)
    ((happy Fred) :inference-level :assertion :timeout 1.0)
	
As a convenience, a `query' argument whose first element is a symbol is
interpreted as a sentence that is queried without any options.  For example:
	 
    (happy Fred)
	
is a legal `query' argument.  Note that for a setence whose relation is a list
itself, e.g., `((FruitFn BananaTree) MyBanana)' this shortcut is not available,
that is, in that case an extra level of list nesting is always necessary.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions `is-true',
`is-false' and `is-unknown' (which see).\" :PUBLIC? TRUE)"
    (CL:FUNCTION ASK) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-ASK"
    "(DEFUN (S-ASK TRUTH-VALUE) ((QUERY STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Returns a truth value for `query' in module `module-name' and `environment'.
`query' has the same syntax as the PowerLoom `ask' command (which see) but
with the `ask' operator omitted.  Different from the PLI `ask' function, `s-ask'
does not expect a top-level pair of parentheses.  For example, here are some legal
`query' arguments:
	 
    \\\"(happy Fred)\\\"
    \\\"(happy Fred) :inference-level :assertion\\\"
    \\\"(happy Fred) :inference-level :assertion :timeout 1.0\\\"
	
Names in `query' will be interpreted relative to module `module-name'.
A null `module-name' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions `is-true',
`is-false' and `is-unknown' (which see).\" :PUBLIC? TRUE)"
    (CL:FUNCTION S-ASK) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "RETRIEVE"
    "(DEFUN (RETRIEVE PL-ITERATOR) ((QUERY CONS) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Returns an iterator of variable bindings that when substituted for the
open variables in `query' satisfy the query proposition.  The query is
run in `module' and relative to `environment'.  `query' has the same syntax
as the PowerLoom `retrieve' command (which see) but with the `retrieve'
operator omitted.    For example, here are some legal `query' arguments:
	 
    ((happy ?x))
    (10 (happy ?x))
    (all (happy ?x))
    (all ?x (happy ?x))
    (10 (happy ?x) :inference-level :assertion)
    (10 (happy ?x) :inference-level :assertion :timeout 1.0)
	
If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:
	 
    (all (?x) (happy ?x))
	
In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various `get-nth-...' functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables.\" :PUBLIC? TRUE)"
    (CL:FUNCTION RETRIEVE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "S-RETRIEVE"
    "(DEFUN (S-RETRIEVE PL-ITERATOR) ((QUERY STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Returns an iterator of variable bindings that when substituted for the
open variables in `query' satisfy the query proposition.  The query is
run in `module' and relative to `environment'.  `query' has the same syntax
as the PowerLoom `retrieve' command (which see) but with the `retrieve'
operator omitted.  Different from the PLI `retrieve' function, `s-retrieve'
does not expect a top-level pair of parentheses.  For example, here are some
legal `query' arguments:
	 
    \\\"(happy ?x)\\\"
    \\\"10 (happy ?x)\\\"
    \\\"all (happy ?x)\\\"
    \\\"all ?x (happy ?x)\\\"
    \\\"10 (happy ?x) :inference-level :assertion\\\"
    \\\"10 (happy ?x) :inference-level :assertion :timeout 1.0\\\"
	
If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:
	 
    \\\"all (?x) (happy ?x)\\\"
	
In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various `get-nth-...' functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables.

Names in `query' will be interpreted relative to module `module-name'.
A null `module-name' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown.\" :PUBLIC? TRUE)"
    (CL:FUNCTION S-RETRIEVE) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "MAIN"
    "(DEFUN MAIN () :PUBLIC? TRUE :DOCUMENTATION \"Main PowerLoom entry point for your code in C++ and Java.\")"
    (CL:FUNCTION MAIN) STELLA::NULL)
   (STELLA::DEFINE-FUNCTION-OBJECT "STARTUP-PLI"
    "(DEFUN STARTUP-PLI () :PUBLIC? TRUE)" (CL:FUNCTION STARTUP-PLI)
    STELLA::NULL)
   (CL:LET*
    ((FUNCTION (STELLA::LOOKUP-FUNCTION SYM-PLI-PLI-STARTUP-PLI)))
    (STELLA::SET-DYNAMIC-SLOT-VALUE (STELLA::%DYNAMIC-SLOTS FUNCTION)
     SYM-PLI-STELLA-METHOD-STARTUP-CLASSNAME
     (STELLA::WRAP-STRING "_StartupPli") STELLA::NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-PLI ()
  (CL:LET*
   ((STELLA::*MODULE*
     (STELLA::GET-STELLA-MODULE "/PLI"
      (STELLA::> STELLA::*STARTUP-TIME-PHASE* 1)))
    (STELLA::*CONTEXT* STELLA::*MODULE*))
   (CL:DECLARE (CL:SPECIAL STELLA::*MODULE* STELLA::*CONTEXT*))
   (CL:WHEN (STELLA::CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-PLI1))
   (CL:WHEN (STELLA::CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:LET* ((SELF-058 (NEW-ENVIRONMENT)))
     (CL:SETF (STELLA::%LEVEL SELF-058) "ASSERTION")
     (CL:SETQ ASSERTION-ENV SELF-058))
    (CL:LET* ((SELF-059 (NEW-ENVIRONMENT)))
     (CL:SETF (STELLA::%LEVEL SELF-059) "TAXONOMIC")
     (CL:SETQ TAXONOMIC-ENV SELF-059))
    (CL:LET* ((SELF-060 (NEW-ENVIRONMENT)))
     (CL:SETF (STELLA::%LEVEL SELF-060) "INFERENCE")
     (CL:SETQ INFERENCE-ENV SELF-060))
    (CL:LET* ((SELF-061 (NEW-PL-ITERATOR)))
     (CL:SETF (STELLA::%CURSOR SELF-061) STELLA::NIL)
     (CL:SETQ EMPTY-PL-ITERATOR SELF-061)))
   (CL:WHEN (STELLA::CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (STELLA::DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ENVIRONMENT"
        "(DEFCLASS ENVIRONMENT (STANDARD-OBJECT) :PUBLIC? TRUE :SLOTS ((LEVEL :TYPE STRING)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|ENV|\" (LEVEL SELF)))")))
     (CL:SETF (STELLA::%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-ENVIRONMENT))
     (CL:SETF (STELLA::%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-ENVIRONMENT-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (STELLA::DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PL-ITERATOR"
        "(DEFCLASS PL-ITERATOR (ITERATOR) :PUBLIC? TRUE :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((CURSOR :TYPE CONS)))")))
     (CL:SETF (STELLA::%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-PL-ITERATOR))
     (CL:SETF (STELLA::%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-PL-ITERATOR-SLOT-VALUE))))
   (CL:WHEN (STELLA::CURRENT-STARTUP-TIME-PHASE? 6)
    (STELLA::FINALIZE-CLASSES))
   (CL:WHEN (STELLA::CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-PLI2)
    (HELP-STARTUP-PLI3) (HELP-STARTUP-PLI4))
   (CL:WHEN (STELLA::CURRENT-STARTUP-TIME-PHASE? 8)
    (STELLA::FINALIZE-SLOTS) (STELLA::CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (STELLA::CURRENT-STARTUP-TIME-PHASE? 9)
    (STELLA::DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *POWERLOOM-INITIALIZED?* BOOLEAN FALSE)")
    (CL:SETQ *POWERLOOM-INITIALIZED?* CL:T)
    (STELLA::DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ASSERTION-ENV ENVIRONMENT (NEW ENVIRONMENT :LEVEL \"ASSERTION\") :PUBLIC? TRUE)")
    (STELLA::DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT TAXONOMIC-ENV ENVIRONMENT (NEW ENVIRONMENT :LEVEL \"TAXONOMIC\") :PUBLIC? TRUE)")
    (STELLA::DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT INFERENCE-ENV ENVIRONMENT (NEW ENVIRONMENT :LEVEL \"INFERENCE\") :PUBLIC? TRUE)")
    (STELLA::DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL EMPTY-PL-ITERATOR PL-ITERATOR (NEW PL-ITERATOR :CURSOR NIL) :PUBLIC? FALSE :DOCUMENTATION \"Iterator that generates no values.\")")
    (STELLA::DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LITERAL-CONCEPT* NAMED-DESCRIPTION NULL :PUBLIC? FALSE)")
    (STELLA::DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *STRING-CONCEPT* NAMED-DESCRIPTION NULL :PUBLIC? FALSE)")
    (STELLA::DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INTEGER-CONCEPT* NAMED-DESCRIPTION NULL :PUBLIC? FALSE)")
    (STELLA::DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *FLOAT-CONCEPT* NAMED-DESCRIPTION NULL :PUBLIC? FALSE)")
    (CL:SETQ *LITERAL-CONCEPT*
     (S-GET-CONCEPT "LITERAL" "PL-USER" STELLA::NULL))
    (CL:SETQ *STRING-CONCEPT*
     (S-GET-CONCEPT "STRING" "PL-USER" STELLA::NULL))
    (CL:SETQ *INTEGER-CONCEPT*
     (S-GET-CONCEPT "INTEGER" "PL-USER" STELLA::NULL))
    (CL:SETQ *FLOAT-CONCEPT*
     (S-GET-CONCEPT "FLOAT" "PL-USER" STELLA::NULL)))))
