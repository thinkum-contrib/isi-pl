;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; frame-support.lisp

#|
 +--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997-2003              |
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-FRAME-SUPPORT-LOGIC-OBJECT-STORE NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-STELLA-RELATION NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-STELLA-THING NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-FRAME-SUPPORT-LOGIC-FIND-INSTANCE NULL)
(CL:DEFVAR KWD-FRAME-SUPPORT-COMMON-LISP NULL)
(CL:DEFVAR KWD-FRAME-SUPPORT-FUNCTION NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-STELLA-MODULE NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-PL-KERNEL-KB-COLLECTION NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-PL-KERNEL-KB-CLASS NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-PL-KERNEL-KB-RELATION NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-PL-KERNEL-KB-FUNCTION NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-STELLA-LITERAL NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-PL-KERNEL-KB-SCALAR NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-STELLA-LITERAL-WRAPPER NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-LOGIC-F-ALL-TYPES-MEMO-TABLE-000 NULL)
(CL:DEFVAR KWD-FRAME-SUPPORT-ISA NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-LOGIC-F-ALL-EQUIVALENT-RELATIONS-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-LOGIC-F-ALL-SUPERRELATIONS-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-LOGIC-F-ALL-SUBRELATIONS-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-LOGIC-F-ALL-DIRECT-SUPERRELATIONS-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-LOGIC-F-ALL-DIRECT-SUBRELATIONS-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-PL-KERNEL-KB-RANGE-MIN-CARDINALITY NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-PL-KERNEL-KB-RANGE-MAX-CARDINALITY NULL)
(CL:DEFVAR SGT-FRAME-SUPPORT-PL-KERNEL-KB-RANGE-TYPE NULL)
(CL:DEFVAR SYM-FRAME-SUPPORT-LOGIC-STARTUP-FRAME-SUPPORT NULL)
(CL:DEFVAR SYM-FRAME-SUPPORT-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* NULL-INTEGER SHALLOW-INFERENCE
  SUBSUMPTION-INFERENCE TRUE-WRAPPER FALSE-WRAPPER *CONTEXT*
  *MEMOIZATION-ENABLED?* MEMOIZED-NULL-VALUE NIL STANDARD-OUTPUT EOL
  *MODULE* TRUE FALSE))

;;; (DEFUN (COERCE-TO-INSTANCE-IN-MODULE OBJECT) ...)

(CL:DEFUN COERCE-TO-INSTANCE-IN-MODULE (SELF MODULE LOCAL? ORIGINAL)
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:WHEN (CL:NOT (CL:EQ ORIGINAL NULL))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "Can't find the entity referenced as: `" ORIGINAL "'." EOL))
   (CL:RETURN-FROM COERCE-TO-INSTANCE-IN-MODULE NULL))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-FRAME-SUPPORT-LOGIC-LOGIC-OBJECT)
     (CL:PROGN SELF))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((NAME (%WRAPPER-VALUE SELF)) (MODULEFROMSTRING NULL))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
       (CL:WHEN (QUALIFIED-NAME? NAME)
        (CL:MULTIPLE-VALUE-SETQ (MODULEFROMSTRING NAME)
         (COMPUTE-MODULE-AND-BARE-NAME NAME)))
       (CL:WHEN (CL:EQ MODULE NULL)
        (CL:IF (CL:NOT (CL:EQ MODULEFROMSTRING NULL))
         (CL:SETQ MODULE MODULEFROMSTRING) (CL:SETQ MODULE *MODULE*)))
       (CL:LET*
        ((SURROGATE (LOOKUP-SURROGATE-IN-MODULE NAME MODULE LOCAL?)))
        (CL:WHEN
         (CL:OR (CL:EQ SURROGATE NULL)
          (CL:EQ (%SURROGATE-VALUE SURROGATE) NULL))
         (CL:COND
          ((CL:AND (CL:NOT (CL:EQ SURROGATE NULL))
            (CL:NOT (CL:EQ (HOME-OBJECT-STORE SURROGATE) NULL)))
           (FETCH-INSTANCE (HOME-OBJECT-STORE SURROGATE) SURROGATE))
          ((CL:AND (CL:EQ SURROGATE NULL)
            (CL:NOT
             (CL:EQ
              (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS MODULE)
               SYM-FRAME-SUPPORT-LOGIC-OBJECT-STORE NULL)
              NULL)))
           (FETCH-INSTANCE
            (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS MODULE)
             SYM-FRAME-SUPPORT-LOGIC-OBJECT-STORE NULL)
            (INTERN-SURROGATE-IN-MODULE NAME MODULE LOCAL?)))))
        (CL:IF
         (CL:AND (CL:NOT (CL:EQ SURROGATE NULL))
          (CL:NOT (CL:EQ (%SURROGATE-VALUE SURROGATE) NULL)))
         (COERCE-TO-INSTANCE-IN-MODULE SURROGATE MODULE TRUE ORIGINAL)
         NULL)))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET*
       ((STARTINGMODULE
         (CL:IF (CL:NOT (CL:EQ MODULE NULL)) MODULE
          (%HOME-CONTEXT SELF)))
        (VALUE
         (COERCE-TO-INSTANCE-IN-MODULE
          (LOOKUP-SURROGATE-IN-MODULE (%SYMBOL-NAME SELF)
           STARTINGMODULE LOCAL?)
          NULL LOCAL? NULL)))
       (CL:COND ((CL:NOT (CL:EQ VALUE NULL)) VALUE)
        ((CL:NOT (CL:EQ MODULE *MODULE*))
         (COERCE-TO-INSTANCE-IN-MODULE
          (LOOKUP-SURROGATE-IN-MODULE (%SYMBOL-NAME SELF) *MODULE*
           LOCAL?)
          *MODULE* LOCAL? ORIGINAL))
        ((CL:NOT (CL:EQ ORIGINAL NULL))
         (COERCE-TO-INSTANCE-IN-MODULE NULL NULL FALSE ORIGINAL))
        (CL:T NULL)))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((VALUE (%SURROGATE-VALUE SELF)))
       (CL:IF (CL:NOT (CL:EQ VALUE NULL))
        (COERCE-TO-INSTANCE-IN-MODULE VALUE NULL TRUE ORIGINAL)
        (COERCE-TO-INSTANCE-IN-MODULE (WRAP-STRING (%SYMBOL-NAME SELF))
         (%HOME-CONTEXT SELF) LOCAL? ORIGINAL)))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-FRAME-SUPPORT-STELLA-RELATION)
     (CL:PROGN (GET-DESCRIPTION SELF)))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-INSTANCE-IN-MODULE (WRAP-STRING (%SYMBOL-NAME SELF))
       MODULE LOCAL? ORIGINAL)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-FRAME-SUPPORT-STELLA-THING)
     (CL:PROGN SELF))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-FRAME-SUPPORT-LOGIC-PROPOSITION)
     (CL:PROGN SELF))
    (CL:T (COERCE-TO-INSTANCE-IN-MODULE NULL NULL FALSE ORIGINAL)))))

;;; (DEFUN (GET-INSTANCE OBJECT) ...)

(CL:DEFUN GET-INSTANCE (INSTANCEREF)
  "Return the nearest instance with name 'instanceRef'
visible from the current module.  'instanceRef' can be a string, symbol,
or surrogate.  If 'instanceRef' is a surrogate, the search originates
in the module the surrogate was interned in."
  (CL:COND ((CL:EQ INSTANCEREF NULL) NULL)
   ((ISA? INSTANCEREF SGT-FRAME-SUPPORT-LOGIC-LOGIC-OBJECT)
    INSTANCEREF)
   (CL:T (COERCE-TO-INSTANCE-IN-MODULE INSTANCEREF NULL FALSE NULL))))

;;; (DEFUN (FIND-INSTANCE OBJECT) ...)

(CL:DEFUN %FIND-INSTANCE (INSTANCEREF)
  "Return the nearest instance with name 'instanceRef'
visible from the current module.  'instanceRef' can be a string, symbol,
or surrogate.  If 'instanceRef' is a surrogate, the search originates
in the module the surrogate was interned in."
  (GET-INSTANCE INSTANCEREF))

(CL:DEFMACRO FIND-INSTANCE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Return the nearest instance with name 'instanceRef'
visible from the current module.  'instanceRef' can be a string, symbol,
or surrogate.  If 'instanceRef' is a surrogate, the search originates
in the module the surrogate was interned in."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/FIND-INSTANCE)) (CL:MACRO-FUNCTION (CL:QUOTE FIND-INSTANCE)))

;;; (DEFUN (GET-SELF-OR-PROTOTYPE LOGIC-OBJECT) ...)

(CL:DEFUN GET-SELF-OR-PROTOTYPE (INSTANCEREF)
  "Used to convert a computation to reference so-called
'template' slots rather than 'own' slots:  If 'instanceRef' denotes a class,
return a prototype of that class.  Otherwise, return 'instanceRef'."
  (CL:IF (CLASS? INSTANCEREF) (GET-PROTOTYPE INSTANCEREF) INSTANCEREF))

;;; (DEFUN (GET-CLASS LOGIC-OBJECT) ...)

(CL:DEFUN GET-CLASS (INSTANCEREF)
  "Return the nearest class with name 'instanceRef'
visible from the current module.  'instanceRef' can be a string, symbol,
or surrogate.  If 'instanceRef' is a surrogate, the search originates
in the module the surrogate was interned in."
  (CL:LET*
   ((INSTANCE
     (COERCE-TO-INSTANCE-IN-MODULE INSTANCEREF NULL FALSE NULL)))
   (CL:IF (CLASS? INSTANCE) INSTANCE NULL)))

;;; (DEFUN (GET-RELATION LOGIC-OBJECT) ...)

(CL:DEFUN GET-RELATION (INSTANCEREF)
  "Return the nearest relation with name 'instanceRef'
visible from the current module.  'instanceRef' can be a string, symbol,
or surrogate.  If 'instanceRef' is a surrogate, the search originates
in the module the surrogate was interned in."
  (CL:LET*
   ((INSTANCE
     (COERCE-TO-INSTANCE-IN-MODULE INSTANCEREF NULL FALSE NULL)))
   (CL:IF (RELATION? INSTANCE) INSTANCE NULL)))

;;; (DEFUN (GET-MODULE MODULE) ...)

(CL:DEFUN GET-MODULE (MODULEREF)
  "Return a module named 'moduleRef'."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE MODULEREF)))
   (CL:COND
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN (GET-STELLA-MODULE (%WRAPPER-VALUE MODULEREF) FALSE)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (GET-STELLA-MODULE (%SYMBOL-NAME MODULEREF) FALSE)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN (GET-STELLA-MODULE (%SYMBOL-NAME MODULEREF) FALSE)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-FRAME-SUPPORT-STELLA-MODULE)
     (CL:PROGN MODULEREF))
    (CL:T NULL))))

;;; (DEFUN (COLLECTION? BOOLEAN) ...)

(CL:DEFUN COLLECTION? (OBJECTREF)
  "Return TRUE if 'objectRef' denotes a relation or a class."
  (CL:LET* ((INSTANCE (GET-INSTANCE OBJECTREF)))
   (CL:WHEN (CL:EQ INSTANCE NULL) (CL:RETURN-FROM COLLECTION? FALSE))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE INSTANCE)
      SGT-FRAME-SUPPORT-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (TEST-ISA? INSTANCE SGT-FRAME-SUPPORT-PL-KERNEL-KB-COLLECTION)))
    (CL:T FALSE))))

;;; (DEFUN (CLASS? BOOLEAN) ...)

(CL:DEFUN CLASS? (OBJECTREF)
  "Return TRUE if 'objectRef' denotes a class."
  (CL:LET* ((INSTANCE (GET-INSTANCE OBJECTREF)))
   (CL:IF (CL:EQ INSTANCE NULL) FALSE
    (TEST-ISA? INSTANCE SGT-FRAME-SUPPORT-PL-KERNEL-KB-CLASS))))

;;; (DEFUN (RELATION? BOOLEAN) ...)

(CL:DEFUN RELATION? (OBJECTREF)
  "Return TRUE if 'objectRef' denotes a relation or a class."
  (CL:LET* ((INSTANCE (GET-INSTANCE OBJECTREF)))
   (CL:IF (CL:EQ INSTANCE NULL) FALSE
    (TEST-ISA? INSTANCE SGT-FRAME-SUPPORT-PL-KERNEL-KB-RELATION))))

;;; (DEFUN (FUNCTION? BOOLEAN) ...)

(CL:DEFUN FUNCTION? (RELATIONREF)
  "Return TRUE if 'relationRef' references a function."
  (CL:LET* ((INSTANCE (GET-INSTANCE RELATIONREF)))
   (CL:IF
    (CL:OR (CL:EQ INSTANCE NULL)
     (CL:EQ (%SURROGATE-VALUE SGT-FRAME-SUPPORT-PL-KERNEL-KB-FUNCTION)
      NULL))
    FALSE (TEST-ISA? INSTANCE SGT-FRAME-SUPPORT-PL-KERNEL-KB-FUNCTION))))

;;; (DEFUN (CONSTANT? BOOLEAN) ...)

(CL:DEFUN CONSTANT? (OBJECTREF)
  "Return TRUE if `objectRef' denotes a literal or scalar."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OBJECTREF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-FRAME-SUPPORT-STELLA-LITERAL-WRAPPER)
     (CL:PROGN TRUE))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (CONSTANT? (%SURROGATE-VALUE OBJECTREF))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-FRAME-SUPPORT-STELLA-THING)
     (CL:PROGN
      (CL:OR (TEST-ISA? OBJECTREF SGT-FRAME-SUPPORT-STELLA-LITERAL)
       (TEST-ISA? OBJECTREF SGT-FRAME-SUPPORT-PL-KERNEL-KB-SCALAR))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-FRAME-SUPPORT-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:OR (TEST-ISA? OBJECTREF SGT-FRAME-SUPPORT-STELLA-LITERAL)
       (TEST-ISA? OBJECTREF SGT-FRAME-SUPPORT-PL-KERNEL-KB-SCALAR))))
    (CL:T FALSE))))

;;; (DEFUN (RELATION-NAME STRING) ...)

(CL:DEFUN RELATION-NAME (SELF)
  "Given a relation object, return it's name."
  (%SYMBOL-NAME (%SURROGATE-VALUE-INVERSE SELF)))
(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) RELATION-NAME))

;;; (DEFUN (TERMIFY OBJECT) ...)

(CL:DEFUN TERMIFY (SELF)
  "Convert 'self' into an equivalent PowerLoom object
that can be passed as an argument wherever an instance is expected."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-FRAME-SUPPORT-STELLA-LITERAL-WRAPPER)
     (CL:PROGN (PERMANENTIFY SELF)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN (CL:NOT (CL:EQ (%SURROGATE-VALUE SELF) NULL))
       (CL:RETURN-FROM TERMIFY (VALUE-OF (%SURROGATE-VALUE SELF))))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "Can't termify the surrogate 'self' because it is undefined.")
      NULL))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-FRAME-SUPPORT-LOGIC-LOGIC-OBJECT)
     (CL:PROGN (VALUE-OF SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-FRAME-SUPPORT-STELLA-THING)
     (CL:PROGN SELF))
    (CL:T
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "Can't 'termify': " SELF)
     NULL))))

;;; (DEFUN (RELATION-ARITY-OK? BOOLEAN) ...)

(CL:DEFUN RELATION-ARITY-OK? (RELATIONREF ARITY)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (CL:LET* ((RELATION (GET-DESCRIPTION RELATIONREF)))
   (CL:WHEN (CL:EQ RELATION NULL)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "Reference to undefined relation " (%SYMBOL-NAME RELATIONREF) EOL)
    (CL:RETURN-FROM RELATION-ARITY-OK? FALSE))
   (CL:WHEN (CL:NOT (CL:= (ARITY RELATION) ARITY))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "Error:  Relation " (%SYMBOL-NAME RELATIONREF) " has arity "
     (ARITY RELATION) EOL "   when arity " ARITY " expected." EOL)
    (CL:RETURN-FROM RELATION-ARITY-OK? FALSE))
   TRUE))

;;; (DEFUN (FILTER-OUT-UNNAMED-DESCRIPTIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN FILTER-OUT-UNNAMED-DESCRIPTIONS (DESCRIPTIONS)
  (CL:LET* ((NAMEDONES NIL))
   (CL:LET* ((D NULL) (ITER-000 DESCRIPTIONS) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ D (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (ISA? D SGT-FRAME-SUPPORT-LOGIC-NAMED-DESCRIPTION)
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS D NIL))
        (CL:IF (CL:EQ NAMEDONES NIL) (CL:SETQ NAMEDONES COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST NAMEDONES COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS D NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   NAMEDONES))

;;; (DEFUN (ALL-ASSERTED-TYPES (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN ALL-ASSERTED-TYPES (SELF)
  "Return a set of all of the types that are
asserted to be satisfied by 'self'."
  (CL:LET* ((TYPES NIL))
   (CL:LET*
    ((P NULL) (ITER-000 (ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:LET* ((DESCRIPTION (GET-DESCRIPTION (%OPERATOR P))))
      (CL:WHEN (CL:NOT (MEMBER? TYPES DESCRIPTION))
       (CL:SETQ TYPES (CONS DESCRIPTION TYPES))))))
   TYPES))

;;; (DEFUN (ALL-TYPES (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN ALL-TYPES (SELF)
  "Return a set of all of the types that are
satisfied by 'self'."
  (CL:LET*
   ((MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-FRAME-SUPPORT-LOGIC-F-ALL-TYPES-MEMO-TABLE-000))
    (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
    (INITIALIZE-MEMOIZATION-TABLE
     SGT-FRAME-SUPPORT-LOGIC-F-ALL-TYPES-MEMO-TABLE-000
     "(:MAX-VALUES 500 :TIMESTAMPS (:KB-UPDATE))")
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-FRAME-SUPPORT-LOGIC-F-ALL-TYPES-MEMO-TABLE-000)))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF *CONTEXT*
      MEMOIZED-NULL-VALUE NULL 2))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T (CL:SETQ MEMOIZED-VALUE-000 (HELP-ALL-TYPES SELF))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000)) VALUE-000)))

;;; (DEFUN (HELP-ALL-TYPES (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN HELP-ALL-TYPES (SELF)
  (CL:LET*
   ((ASSERTEDTYPES (ALL-ASSERTED-TYPES SELF))
    (TYPES (COPY-CONS-LIST ASSERTEDTYPES)))
   (CL:LET* ((D NULL) (ITER-000 ASSERTEDTYPES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ D (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:LET* ((C NULL) (ITER-001 (ALL-SUPERCOLLECTIONS D)))
      (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ C (%VALUE ITER-001))
       (CL:WHEN (ISA? C SGT-FRAME-SUPPORT-LOGIC-NAMED-DESCRIPTION)
        (CL:WHEN (CL:NOT (MEMBER? TYPES C))
         (CL:SETQ TYPES (CONS C TYPES))))))))
   TYPES))

;;; (DEFUN (ALL-DIRECT-TYPES (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-TYPES (SELF)
  "Return a set of most specific types that are
satisfied by 'self'."
  (MOST-SPECIFIC-NAMED-DESCRIPTIONS (ALL-ASSERTED-TYPES SELF)))

;;; (DEFUN (TEST-TYPE-ON-INSTANCE? BOOLEAN) ...)

(CL:DEFUN TEST-TYPE-ON-INSTANCE? (SELF TYPE)
  "Return TRUE if 'self' satisfies 'type'."
  (LEVELLIZED-TEST-TYPE-ON-INSTANCE? (CURRENT-INFERENCE-LEVEL) SELF
   TYPE))

;;; (DEFMETHOD (LEVELLIZED-TEST-TYPE-ON-INSTANCE? BOOLEAN) ...)

(CL:DEFMETHOD LEVELLIZED-TEST-TYPE-ON-INSTANCE? ((LEVEL SUBSUMPTION-INFERENCE-LEVEL) SELF TYPE)
  (CL:LET* ((FOUND?-000 FALSE))
   (CL:LET*
    ((P NULL)
     (ITER-000 (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF TYPE TRUE)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%KIND P) KWD-FRAME-SUPPORT-ISA)
      (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
   (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000)))

;;; (DEFMETHOD (LEVELLIZED-TEST-TYPE-ON-INSTANCE? BOOLEAN) ...)

(CL:DEFMETHOD LEVELLIZED-TEST-TYPE-ON-INSTANCE? ((LEVEL SHALLOW-INFERENCE-LEVEL) SELF TYPE)
  (CL:LET* ((FOUND?-000 FALSE))
   (CL:LET*
    ((P NULL)
     (ITER-000 (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF TYPE FALSE)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%KIND P) KWD-FRAME-SUPPORT-ISA)
      (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
   (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000)))

;;; (DEFUN (ALL-EQUIVALENT-RELATIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN ALL-EQUIVALENT-RELATIONS (RELATION REFLEXIVE?)
  "Return a list of all relations equivalent to 'relation'.
If 'reflexive?', include 'relation' in the list."
  (CL:LET*
   ((MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-FRAME-SUPPORT-LOGIC-F-ALL-EQUIVALENT-RELATIONS-MEMO-TABLE-000))
    (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
    (INITIALIZE-MEMOIZATION-TABLE
     SGT-FRAME-SUPPORT-LOGIC-F-ALL-EQUIVALENT-RELATIONS-MEMO-TABLE-000
     "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))")
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-FRAME-SUPPORT-LOGIC-F-ALL-EQUIVALENT-RELATIONS-MEMO-TABLE-000)))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 RELATION *CONTEXT*
      (CL:IF REFLEXIVE? TRUE-WRAPPER FALSE-WRAPPER) MEMOIZED-NULL-VALUE
      -1))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (FILTER-OUT-UNNAMED-DESCRIPTIONS
       (ALL-EQUIVALENT-COLLECTIONS RELATION REFLEXIVE?)))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000)) VALUE-000)))

;;; (DEFUN (REMOVE-EQUIVALENT-RELATIONS (LIKE SELF)) ...)

(CL:DEFUN REMOVE-EQUIVALENT-RELATIONS (RELATIONSLIST RELATION)
  (CL:WHEN (MEMBER? RELATIONSLIST RELATION)
   (CL:LET*
    ((M NULL) (ITER-000 (ALL-EQUIVALENT-RELATIONS RELATION TRUE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ M (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:SETQ RELATIONSLIST (REMOVE RELATIONSLIST M)))))
  RELATIONSLIST)

;;; (DEFUN (HELP-MEMOIZE-ALL-SUPERRELATIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN HELP-MEMOIZE-ALL-SUPERRELATIONS (RELATION REMOVEEQUIVALENTS?)
  (CL:LET*
   ((SUPERSLOTS
     (FILTER-OUT-UNNAMED-DESCRIPTIONS
      (CONSIFY (ALL-SUPERCOLLECTIONS RELATION)))))
   (CL:IF REMOVEEQUIVALENTS?
    (REMOVE-EQUIVALENT-RELATIONS SUPERSLOTS RELATION) SUPERSLOTS)))

;;; (DEFUN (ALL-SUPERRELATIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN ALL-SUPERRELATIONS (RELATION REMOVEEQUIVALENTS?)
  "Return a set of all relations that subsume relation."
  (CL:LET*
   ((MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-FRAME-SUPPORT-LOGIC-F-ALL-SUPERRELATIONS-MEMO-TABLE-000))
    (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
    (INITIALIZE-MEMOIZATION-TABLE
     SGT-FRAME-SUPPORT-LOGIC-F-ALL-SUPERRELATIONS-MEMO-TABLE-000
     "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))")
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-FRAME-SUPPORT-LOGIC-F-ALL-SUPERRELATIONS-MEMO-TABLE-000)))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 RELATION *CONTEXT*
      (CL:IF REMOVEEQUIVALENTS? TRUE-WRAPPER FALSE-WRAPPER)
      MEMOIZED-NULL-VALUE -1))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (HELP-MEMOIZE-ALL-SUPERRELATIONS RELATION REMOVEEQUIVALENTS?))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000)) VALUE-000)))

;;; (DEFUN (HELP-MEMOIZE-ALL-SUBRELATIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN HELP-MEMOIZE-ALL-SUBRELATIONS (RELATION REMOVEEQUIVALENTS?)
  (CL:LET*
   ((SUBSLOTS
     (FILTER-OUT-UNNAMED-DESCRIPTIONS
      (CONSIFY (ALL-SUBCOLLECTIONS RELATION)))))
   (CL:IF REMOVEEQUIVALENTS?
    (REMOVE-EQUIVALENT-RELATIONS SUBSLOTS RELATION) SUBSLOTS)))

;;; (DEFUN (ALL-SUBRELATIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN ALL-SUBRELATIONS (RELATION REMOVEEQUIVALENTS?)
  "Return a set of all (named) relations that specialize
relation."
  (CL:LET*
   ((MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-FRAME-SUPPORT-LOGIC-F-ALL-SUBRELATIONS-MEMO-TABLE-000))
    (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
    (INITIALIZE-MEMOIZATION-TABLE
     SGT-FRAME-SUPPORT-LOGIC-F-ALL-SUBRELATIONS-MEMO-TABLE-000
     "(:MAX-VALUES 1000 :TIMESTAMPS (:META-KB-UPDATE))")
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-FRAME-SUPPORT-LOGIC-F-ALL-SUBRELATIONS-MEMO-TABLE-000)))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 RELATION *CONTEXT*
      (CL:IF REMOVEEQUIVALENTS? TRUE-WRAPPER FALSE-WRAPPER)
      MEMOIZED-NULL-VALUE -1))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (HELP-MEMOIZE-ALL-SUBRELATIONS RELATION REMOVEEQUIVALENTS?))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000)) VALUE-000)))

;;; (DEFUN (ALL-DIRECT-SUPERRELATIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN ALL-DIRECT-SUPERRELATIONS (RELATION REMOVEEQUIVALENTS?)
  "Return a set of relations that immediately subsume
'relation'.  If 'removeEquivalents?' (recommended), don't include any
relations equivalent to 'relation'."
  (CL:LET*
   ((MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-FRAME-SUPPORT-LOGIC-F-ALL-DIRECT-SUPERRELATIONS-MEMO-TABLE-000))
    (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
    (INITIALIZE-MEMOIZATION-TABLE
     SGT-FRAME-SUPPORT-LOGIC-F-ALL-DIRECT-SUPERRELATIONS-MEMO-TABLE-000
     "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))")
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-FRAME-SUPPORT-LOGIC-F-ALL-DIRECT-SUPERRELATIONS-MEMO-TABLE-000)))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 RELATION *CONTEXT*
      (CL:IF REMOVEEQUIVALENTS? TRUE-WRAPPER FALSE-WRAPPER)
      MEMOIZED-NULL-VALUE -1))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (FILTER-OUT-UNNAMED-DESCRIPTIONS
       (CONSIFY
        (ALL-DIRECT-SUPERCOLLECTIONS RELATION REMOVEEQUIVALENTS?))))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000)) VALUE-000)))

;;; (DEFUN (ALL-DIRECT-SUBRELATIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN ALL-DIRECT-SUBRELATIONS (RELATION REMOVEEQUIVALENTS?)
  "Return a set of relations that immediately specialize
'relation'.  If 'removeEquivalents?' (recommended), don't include any
relations equivalent to 'relation'."
  (CL:LET*
   ((MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-FRAME-SUPPORT-LOGIC-F-ALL-DIRECT-SUBRELATIONS-MEMO-TABLE-000))
    (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
    (INITIALIZE-MEMOIZATION-TABLE
     SGT-FRAME-SUPPORT-LOGIC-F-ALL-DIRECT-SUBRELATIONS-MEMO-TABLE-000
     "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))")
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-FRAME-SUPPORT-LOGIC-F-ALL-DIRECT-SUBRELATIONS-MEMO-TABLE-000)))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 RELATION *CONTEXT*
      (CL:IF REMOVEEQUIVALENTS? TRUE-WRAPPER FALSE-WRAPPER)
      MEMOIZED-NULL-VALUE -1))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (FILTER-OUT-UNNAMED-DESCRIPTIONS
       (CONSIFY
        (ALL-DIRECT-SUBCOLLECTIONS RELATION REMOVEEQUIVALENTS?))))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000)) VALUE-000)))

;;; (DEFUN (TEST-SUBRELATION? BOOLEAN) ...)

(CL:DEFUN TEST-SUBRELATION? (SUBRELATION SUPERRELATION)
  "Return TRUE if 'subrelation' specializes 'superrelation'."
  (CL:WHEN (CL:EQ SUBRELATION SUPERRELATION)
   (CL:RETURN-FROM TEST-SUBRELATION? TRUE))
  (CL:LET* ((DESCRIPTION (GET-DESCRIPTION SUBRELATION)))
   (CL:LET* ((FOUND?-000 FALSE))
    (CL:LET*
     ((SUPER NULL) (ITER-000 (ALL-SUPERCOLLECTIONS DESCRIPTION)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ SUPER (%VALUE ITER-000))
      (CL:WHEN (CL:EQ (%SURROGATE-VALUE-INVERSE SUPER) SUPERRELATION)
       (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
    (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000))))

;;; (DEFUN (ALL-CLASS-INSTANCES CONS) ...)

(CL:DEFUN ALL-CLASS-INSTANCES (TYPE)
  "Return a set of instances that belong to the class 'type'."
  (REMOVE-DUPLICATES
   (LEVELLIZED-ALL-CLASS-INSTANCES (CURRENT-INFERENCE-LEVEL) TYPE)))

;;; (DEFMETHOD (LEVELLIZED-ALL-CLASS-INSTANCES CONS) ...)

(CL:DEFMETHOD LEVELLIZED-ALL-CLASS-INSTANCES ((LEVEL SUBSUMPTION-INFERENCE-LEVEL) TYPE)
  (CL:LET* ((MEMBERS NIL))
   (CL:LET*
    ((M NULL)
     (ITER-000
      (%THE-CONS-LIST
       (ASSERTED-COLLECTION-MEMBERS (GET-DESCRIPTION TYPE) FALSE))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ M (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:SETQ MEMBERS (CONS M MEMBERS))))
   MEMBERS))

;;; (DEFMETHOD (LEVELLIZED-ALL-CLASS-INSTANCES CONS) ...)

(CL:DEFMETHOD LEVELLIZED-ALL-CLASS-INSTANCES ((LEVEL ASSERTION-INFERENCE-LEVEL) TYPE)
  (CL:LET* ((MEMBERS NIL))
   (CL:LET*
    ((M NULL)
     (ITER-000
      (%THE-CONS-LIST
       (ASSERTED-COLLECTION-MEMBERS (GET-DESCRIPTION TYPE) TRUE))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ M (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (LEVELLIZED-TEST-TYPE-ON-INSTANCE? LEVEL M TYPE)
      (CL:SETQ MEMBERS (CONS M MEMBERS)))))
   MEMBERS))

;;; (DEFUN (ALL-RELATION-VALUES CONS) ...)

(CL:DEFUN ALL-RELATION-VALUES (RELATION NMINUSONEARGUMENTS)
  "Return a set of values that satisfy the relation
'relation' (a surrogate) applied to 'nMinusOneArguments' plus that last value."
  (CL:WHEN
   (CL:NOT
    (RELATION-ARITY-OK? RELATION (CL:1+ (LENGTH NMINUSONEARGUMENTS))))
   (CL:RETURN-FROM ALL-RELATION-VALUES NIL))
  (LEVELLIZED-ALL-RELATION-VALUES (CURRENT-INFERENCE-LEVEL) RELATION
   NMINUSONEARGUMENTS))

;;; (DEFMETHOD (LEVELLIZED-ALL-RELATION-VALUES CONS) ...)

(CL:DEFMETHOD LEVELLIZED-ALL-RELATION-VALUES ((LEVEL SUBSUMPTION-INFERENCE-LEVEL) RELATION NMINUSONEARGUMENTS)
  (CL:LET* ((VALUES NIL))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALL-PROPOSITIONS-MATCHING-ARGUMENTS NMINUSONEARGUMENTS RELATION
       (CL:EQ LEVEL SUBSUMPTION-INFERENCE)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ P (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (VALUE-OF
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
           (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS P))))))
         NIL))
       (CL:IF (CL:EQ VALUES NIL) (CL:SETQ VALUES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST VALUES COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (VALUE-OF
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
           (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS P))))))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   VALUES))

;;; (DEFUN (TEST-RELATION-ON-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN TEST-RELATION-ON-ARGUMENTS? (RELATION ARGUMENTS)
  "Return TRUE if 'relation' (a surrogate) is TRUE when
applied to 'arguments'."
  (CL:WHEN (CL:NOT (RELATION-ARITY-OK? RELATION (LENGTH ARGUMENTS)))
   (CL:RETURN-FROM TEST-RELATION-ON-ARGUMENTS? FALSE))
  (LEVELLIZED-TEST-RELATION-ON-ARGUMENTS? (CURRENT-INFERENCE-LEVEL)
   RELATION ARGUMENTS))

;;; (DEFMETHOD (LEVELLIZED-TEST-RELATION-ON-ARGUMENTS? BOOLEAN) ...)

(CL:DEFMETHOD LEVELLIZED-TEST-RELATION-ON-ARGUMENTS? ((LEVEL SUBSUMPTION-INFERENCE-LEVEL) RELATION ARGUMENTS)
  (CL:LET* ((FOUND?-000 FALSE))
   (CL:LET*
    ((P
      (ALLOCATE-ITERATOR
       (ALL-PROPOSITIONS-MATCHING-ARGUMENTS ARGUMENTS RELATION
        (CL:EQ LEVEL SUBSUMPTION-INFERENCE)))))
    (CL:LOOP WHILE (NEXT? P) DO (CL:SETQ FOUND?-000 TRUE) (CL:RETURN)))
   (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000)))

;;; (DEFUN (ALL-SLOT-VALUES CONS) ...)

(CL:DEFUN ALL-SLOT-VALUES (SELF RELATION)
  "Return a set of values for the slot 'relation' (a surrogate)
applied to 'self' (an object)."
  (ALL-RELATION-VALUES RELATION (CONS-LIST SELF)))

;;; (DEFUN (GET-SLOT-VALUE OBJECT) ...)

(CL:DEFUN GET-SLOT-VALUE (SELF RELATION)
  "Return a single value for the slot 'relation' (a surrogate)
applied to 'self' (an object)."
  (%%VALUE (ALL-SLOT-VALUES SELF RELATION)))

;;; (DEFUN (TEST-SLOT-VALUE? BOOLEAN) ...)

(CL:DEFUN TEST-SLOT-VALUE? (SELF RELATION FILLER)
  "Return TRUE if the proposition '(<relation> <self> <filler>)'
is true."
  (TEST-RELATION-ON-ARGUMENTS? RELATION (CONS-LIST SELF FILLER)))

;;; (DEFUN (GET-SLOT-MINIMUM-CARDINALITY INTEGER) ...)

(CL:DEFUN GET-SLOT-MINIMUM-CARDINALITY (SELF RELATION)
  "Return a minimum value for the number of fillers of relation
'relation' (a surrogate) applied to the instance 'self' (an object)."
  (LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY (CURRENT-INFERENCE-LEVEL)
   SELF RELATION))
(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM)
  GET-SLOT-MINIMUM-CARDINALITY))

;;; (DEFMETHOD (LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY INTEGER) ...)

(CL:DEFMETHOD LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY ((LEVEL SHALLOW-INFERENCE-LEVEL) SELF RELATION)
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION RELATION))
    (MINCARDINALITY
     (%%VALUE
      (ALL-RELATION-VALUES
       SGT-FRAME-SUPPORT-PL-KERNEL-KB-RANGE-MIN-CARDINALITY
       (CONS-LIST DESCRIPTION SELF))))
    (FILLERCOUNT (LENGTH (ALL-SLOT-VALUES SELF RELATION))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM FILLERCOUNT))
   (CL:WHEN (CL:EQ MINCARDINALITY NULL)
    (CL:SETQ MINCARDINALITY (WRAP-INTEGER 0)))
   (MAX (%WRAPPER-VALUE MINCARDINALITY) FILLERCOUNT)))

;;; (DEFMETHOD (LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY INTEGER) ...)

(CL:DEFMETHOD LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY ((LEVEL SUBSUMPTION-INFERENCE-LEVEL) SELF RELATION)
  (CL:LET*
   ((MINCARDINALITY
     (LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY SHALLOW-INFERENCE SELF
      RELATION)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM MINCARDINALITY))
   (CL:LET*
    ((SUBDESCRIPTION NULL)
     (ITER-000 (ALL-SUBRELATIONS (GET-DESCRIPTION RELATION) FALSE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ SUBDESCRIPTION (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:LET*
      ((SUBMINCARDINALITY
        (%%VALUE
         (ALL-RELATION-VALUES
          SGT-FRAME-SUPPORT-PL-KERNEL-KB-RANGE-MIN-CARDINALITY
          (CONS-LIST SUBDESCRIPTION SELF)))))
      (CL:WHEN (CL:NOT (CL:EQ SUBMINCARDINALITY NULL))
       (CL:SETQ MINCARDINALITY
        (MAX MINCARDINALITY (%WRAPPER-VALUE SUBMINCARDINALITY)))))))
   MINCARDINALITY))

;;; (DEFUN (TEST-CLOSED-SLOT? BOOLEAN) ...)

(CL:DEFUN TEST-CLOSED-SLOT? (RELATION)
  "Return TRUE if 'relation' (a surrogate) is asserted to 
be closed or if the current module closes all relations."
  (CLOSED-TERM? (GET-DESCRIPTION RELATION)))

;;; (DEFUN (TEST-FUNCTION-SLOT? BOOLEAN) ...)

(CL:DEFUN TEST-FUNCTION-SLOT? (RELATION)
  "Return TRUE if 'relation' (a surrogate) is a function."
  (FUNCTION-DESCRIPTION? (GET-DESCRIPTION RELATION)))

;;; (DEFUN (GET-SLOT-MAXIMUM-CARDINALITY INTEGER) ...)

(CL:DEFUN GET-SLOT-MAXIMUM-CARDINALITY (SELF RELATION)
  "Return a maximum value for the number of fillers of relation
'relation' (a surrogate) applied to the instance 'self' (an object)."
  (LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY (CURRENT-INFERENCE-LEVEL)
   SELF RELATION))
(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM)
  GET-SLOT-MAXIMUM-CARDINALITY))

;;; (DEFMETHOD (LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY INTEGER) ...)

(CL:DEFMETHOD LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY ((LEVEL SHALLOW-INFERENCE-LEVEL) SELF RELATION)
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION RELATION))
    (MAXCARDINALITY
     (%%VALUE
      (ALL-RELATION-VALUES
       SGT-FRAME-SUPPORT-PL-KERNEL-KB-RANGE-MAX-CARDINALITY
       (CONS-LIST DESCRIPTION SELF))))
    (FILLERCOUNT NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM FILLERCOUNT))
   (CL:COND
    ((TEST-CLOSED-SLOT? RELATION)
     (CL:SETQ FILLERCOUNT (LENGTH (ALL-SLOT-VALUES SELF RELATION))))
    ((TEST-FUNCTION-SLOT? RELATION) (CL:SETQ FILLERCOUNT 1)))
   (CL:COND ((CL:EQ MAXCARDINALITY NULL) FILLERCOUNT)
    ((NULL? FILLERCOUNT) (%WRAPPER-VALUE MAXCARDINALITY))
    (CL:T (MIN (%WRAPPER-VALUE MAXCARDINALITY) FILLERCOUNT)))))

;;; (DEFMETHOD (LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY INTEGER) ...)

(CL:DEFMETHOD LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY ((LEVEL SUBSUMPTION-INFERENCE-LEVEL) SELF RELATION)
  (CL:LET*
   ((MAXCARDINALITY
     (LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY SHALLOW-INFERENCE SELF
      RELATION)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM MAXCARDINALITY))
   (CL:LET*
    ((SUPERDESCRIPTION NULL)
     (ITER-000 (ALL-SUPERRELATIONS (GET-DESCRIPTION RELATION) FALSE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ SUPERDESCRIPTION (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:LET*
      ((SUPERMAXCARDINALITY
        (%%VALUE
         (ALL-RELATION-VALUES
          SGT-FRAME-SUPPORT-PL-KERNEL-KB-RANGE-MAX-CARDINALITY
          (CONS-LIST SUPERDESCRIPTION SELF)))))
      (CL:WHEN (CL:NOT (CL:EQ SUPERMAXCARDINALITY NULL))
       (CL:IF (DEFINED? MAXCARDINALITY)
        (CL:SETQ MAXCARDINALITY
         (MIN MAXCARDINALITY (%WRAPPER-VALUE SUPERMAXCARDINALITY)))
        (CL:SETQ MAXCARDINALITY
         (%WRAPPER-VALUE SUPERMAXCARDINALITY)))))))
   MAXCARDINALITY))

;;; (DEFUN (GET-SLOT-VALUE-TYPE NAMED-DESCRIPTION) ...)

(CL:DEFUN GET-SLOT-VALUE-TYPE (SELF RELATION)
  "Return a most specific type for fillers of the slot 'relation'
(a surrogate) applied to 'self'. If there is more than one, pick one."
  (%%VALUE (ALL-SLOT-VALUE-TYPES SELF RELATION)))

;;; (DEFUN (ALL-SLOT-VALUE-TYPES (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN ALL-SLOT-VALUE-TYPES (SELF RELATION)
  "Return a set of the most specific types for fillers
of the slot 'relation' applied to 'self'."
  (MOST-SPECIFIC-NAMED-DESCRIPTIONS
   (LEVELLIZED-ALL-SLOT-VALUE-TYPES (CURRENT-INFERENCE-LEVEL) SELF
    RELATION)))

;;; (DEFMETHOD (LEVELLIZED-ALL-SLOT-VALUE-TYPES (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFMETHOD LEVELLIZED-ALL-SLOT-VALUE-TYPES ((LEVEL SHALLOW-INFERENCE-LEVEL) SELF RELATION)
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION RELATION))
    (VALUETYPES
     (ALL-RELATION-VALUES SGT-FRAME-SUPPORT-PL-KERNEL-KB-RANGE-TYPE
      (CONS-LIST DESCRIPTION SELF))))
   (CL:WHEN
    (CL:OR (TEST-CLOSED-SLOT? RELATION) (TEST-FUNCTION-SLOT? RELATION))
    (CL:LET*
     ((FILLERS (ALL-SLOT-VALUES SELF RELATION)) (POSSIBLETYPES NIL))
     (CL:LET* ((F NULL) (ITER-000 FILLERS))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ F (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:LET* ((D NULL) (ITER-001 (ALL-ASSERTED-TYPES F)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:PROGN (CL:SETQ D (%%VALUE ITER-001))
          (CL:SETQ ITER-001 (%%REST ITER-001)))
         (CL:WHEN (CL:NOT (MEMBER? POSSIBLETYPES D))
          (CL:SETQ POSSIBLETYPES (CONS D POSSIBLETYPES)))))))
     (CL:LET* ((D NULL) (ITER-002 POSSIBLETYPES))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:PROGN (CL:SETQ D (%%VALUE ITER-002))
        (CL:SETQ ITER-002 (%%REST ITER-002)))
       (CL:LET* ((TEST-VALUE-000 FALSE))
        (CL:SETQ TEST-VALUE-000 (CL:NOT (MEMBER? VALUETYPES D)))
        (CL:WHEN TEST-VALUE-000
         (CL:LET* ((ALWAYS?-000 TRUE))
          (CL:LET* ((F NULL) (ITER-003 FILLERS))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
            (CL:PROGN (CL:SETQ F (%%VALUE ITER-003))
             (CL:SETQ ITER-003 (%%REST ITER-003)))
            (CL:WHEN
             (CL:NOT
              (TEST-TYPE-ON-INSTANCE? F (%SURROGATE-VALUE-INVERSE D)))
             (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
          (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
        (CL:WHEN TEST-VALUE-000
         (CL:SETQ VALUETYPES (CONS D VALUETYPES))))))))
   (FILTER-OUT-UNNAMED-DESCRIPTIONS VALUETYPES)))

;;; (DEFMETHOD (LEVELLIZED-ALL-SLOT-VALUE-TYPES (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFMETHOD LEVELLIZED-ALL-SLOT-VALUE-TYPES ((LEVEL SUBSUMPTION-INFERENCE-LEVEL) SELF RELATION)
  (CL:LET*
   ((VALUETYPES
     (LEVELLIZED-ALL-SLOT-VALUE-TYPES SHALLOW-INFERENCE SELF
      RELATION)))
   (CL:LET*
    ((SUPERRELATION NULL)
     (ITER-000 (ALL-SUPERRELATIONS (GET-DESCRIPTION RELATION) FALSE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ SUPERRELATION (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:LET*
      ((SUPERTYPE NULL)
       (ITER-001
        (ALL-RELATION-VALUES SGT-FRAME-SUPPORT-PL-KERNEL-KB-RANGE-TYPE
         (CONS-LIST SUPERRELATION SELF))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:PROGN (CL:SETQ SUPERTYPE (%%VALUE ITER-001))
        (CL:SETQ ITER-001 (%%REST ITER-001)))
       (CL:WHEN (CL:NOT (MEMBER? VALUETYPES SUPERTYPE))
        (CL:SETQ VALUETYPES (CONS SUPERTYPE VALUETYPES)))))))
   (FILTER-OUT-UNNAMED-DESCRIPTIONS VALUETYPES)))

;;; (DEFMETHOD (LEVELLIZED-TEST-TYPE-ON-INSTANCE? BOOLEAN) ...)

(CL:DEFMETHOD LEVELLIZED-TEST-TYPE-ON-INSTANCE? ((LEVEL NORMAL-INFERENCE-LEVEL) SELF TYPE)
  (LEVELLIZED-TEST-TYPE-ON-INSTANCE? SUBSUMPTION-INFERENCE SELF TYPE))

;;; (DEFMETHOD (LEVELLIZED-ALL-CLASS-INSTANCES CONS) ...)

(CL:DEFMETHOD LEVELLIZED-ALL-CLASS-INSTANCES ((LEVEL NORMAL-INFERENCE-LEVEL) TYPE)
  (LEVELLIZED-ALL-CLASS-INSTANCES SUBSUMPTION-INFERENCE TYPE))

;;; (DEFMETHOD (LEVELLIZED-ALL-RELATION-VALUES CONS) ...)

(CL:DEFMETHOD LEVELLIZED-ALL-RELATION-VALUES ((LEVEL NORMAL-INFERENCE-LEVEL) RELATION NMINUSONEARGUMENTS)
  (LEVELLIZED-ALL-RELATION-VALUES SUBSUMPTION-INFERENCE RELATION
   NMINUSONEARGUMENTS))

;;; (DEFMETHOD (LEVELLIZED-TEST-RELATION-ON-ARGUMENTS? BOOLEAN) ...)

(CL:DEFMETHOD LEVELLIZED-TEST-RELATION-ON-ARGUMENTS? ((LEVEL NORMAL-INFERENCE-LEVEL) RELATION ARGUMENTS)
  (LEVELLIZED-TEST-RELATION-ON-ARGUMENTS? SUBSUMPTION-INFERENCE
   RELATION ARGUMENTS))

;;; (DEFMETHOD (LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY INTEGER) ...)

(CL:DEFMETHOD LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY ((LEVEL NORMAL-INFERENCE-LEVEL) SELF RELATION)
  (LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY SUBSUMPTION-INFERENCE SELF
   RELATION))

;;; (DEFMETHOD (LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY INTEGER) ...)

(CL:DEFMETHOD LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY ((LEVEL NORMAL-INFERENCE-LEVEL) SELF RELATION)
  (LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY SUBSUMPTION-INFERENCE SELF
   RELATION))

;;; (DEFMETHOD (LEVELLIZED-ALL-SLOT-VALUE-TYPES (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFMETHOD LEVELLIZED-ALL-SLOT-VALUE-TYPES ((LEVEL NORMAL-INFERENCE-LEVEL) SELF RELATION)
  (LEVELLIZED-ALL-SLOT-VALUE-TYPES SUBSUMPTION-INFERENCE SELF RELATION))

(CL:DEFUN HELP-STARTUP-FRAME-SUPPORT1 ()
  (CL:PROGN
   (CL:SETQ SYM-FRAME-SUPPORT-LOGIC-OBJECT-STORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-STORE" NULL 0))
   (CL:SETQ SGT-FRAME-SUPPORT-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SGT-FRAME-SUPPORT-STELLA-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-FRAME-SUPPORT-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-FRAME-SUPPORT-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SYM-FRAME-SUPPORT-LOGIC-FIND-INSTANCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FIND-INSTANCE" NULL 0))
   (CL:SETQ KWD-FRAME-SUPPORT-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-FRAME-SUPPORT-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SGT-FRAME-SUPPORT-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-FRAME-SUPPORT-PL-KERNEL-KB-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-FRAME-SUPPORT-PL-KERNEL-KB-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-FRAME-SUPPORT-PL-KERNEL-KB-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-FRAME-SUPPORT-PL-KERNEL-KB-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-FRAME-SUPPORT-STELLA-LITERAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-FRAME-SUPPORT-PL-KERNEL-KB-SCALAR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCALAR"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-FRAME-SUPPORT-STELLA-LITERAL-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-FRAME-SUPPORT-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SGT-FRAME-SUPPORT-LOGIC-F-ALL-TYPES-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-ALL-TYPES-MEMO-TABLE-000" NULL
     1))
   (CL:SETQ KWD-FRAME-SUPPORT-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ
    SGT-FRAME-SUPPORT-LOGIC-F-ALL-EQUIVALENT-RELATIONS-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-ALL-EQUIVALENT-RELATIONS-MEMO-TABLE-000" NULL 1))
   (CL:SETQ SGT-FRAME-SUPPORT-LOGIC-F-ALL-SUPERRELATIONS-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-ALL-SUPERRELATIONS-MEMO-TABLE-000" NULL 1))
   (CL:SETQ SGT-FRAME-SUPPORT-LOGIC-F-ALL-SUBRELATIONS-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-ALL-SUBRELATIONS-MEMO-TABLE-000"
     NULL 1))
   (CL:SETQ
    SGT-FRAME-SUPPORT-LOGIC-F-ALL-DIRECT-SUPERRELATIONS-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-ALL-DIRECT-SUPERRELATIONS-MEMO-TABLE-000" NULL 1))
   (CL:SETQ
    SGT-FRAME-SUPPORT-LOGIC-F-ALL-DIRECT-SUBRELATIONS-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-ALL-DIRECT-SUBRELATIONS-MEMO-TABLE-000" NULL 1))
   (CL:SETQ SGT-FRAME-SUPPORT-PL-KERNEL-KB-RANGE-MIN-CARDINALITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RANGE-MIN-CARDINALITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-FRAME-SUPPORT-PL-KERNEL-KB-RANGE-MAX-CARDINALITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RANGE-MAX-CARDINALITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-FRAME-SUPPORT-PL-KERNEL-KB-RANGE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RANGE-TYPE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SYM-FRAME-SUPPORT-LOGIC-STARTUP-FRAME-SUPPORT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-FRAME-SUPPORT" NULL 0))
   (CL:SETQ SYM-FRAME-SUPPORT-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))))

(CL:DEFUN HELP-STARTUP-FRAME-SUPPORT2 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-INSTANCE-IN-MODULE"
    "(DEFUN (COERCE-TO-INSTANCE-IN-MODULE OBJECT) ((SELF OBJECT) (MODULE MODULE) (LOCAL? BOOLEAN) (ORIGINAL OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-TO-INSTANCE-IN-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-INSTANCE"
    "(DEFUN (GET-INSTANCE OBJECT) ((INSTANCEREF OBJECT)) :DOCUMENTATION \"Return the nearest instance with name 'instanceRef'
visible from the current module.  'instanceRef' can be a string, symbol,
or surrogate.  If 'instanceRef' is a surrogate, the search originates
in the module the surrogate was interned in.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-INSTANCE"
    "(DEFUN (FIND-INSTANCE OBJECT) ((INSTANCEREF OBJECT)) :DOCUMENTATION \"Return the nearest instance with name 'instanceRef'
visible from the current module.  'instanceRef' can be a string, symbol,
or surrogate.  If 'instanceRef' is a surrogate, the search originates
in the module the surrogate was interned in.\" :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %FIND-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SELF-OR-PROTOTYPE"
    "(DEFUN (GET-SELF-OR-PROTOTYPE LOGIC-OBJECT) ((INSTANCEREF OBJECT)) :DOCUMENTATION \"Used to convert a computation to reference so-called
'template' slots rather than 'own' slots:  If 'instanceRef' denotes a class,
return a prototype of that class.  Otherwise, return 'instanceRef'.\")"
    (CL:FUNCTION GET-SELF-OR-PROTOTYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-CLASS"
    "(DEFUN (GET-CLASS LOGIC-OBJECT) ((INSTANCEREF OBJECT)) :DOCUMENTATION \"Return the nearest class with name 'instanceRef'
visible from the current module.  'instanceRef' can be a string, symbol,
or surrogate.  If 'instanceRef' is a surrogate, the search originates
in the module the surrogate was interned in.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-RELATION"
    "(DEFUN (GET-RELATION LOGIC-OBJECT) ((INSTANCEREF OBJECT)) :DOCUMENTATION \"Return the nearest relation with name 'instanceRef'
visible from the current module.  'instanceRef' can be a string, symbol,
or surrogate.  If 'instanceRef' is a surrogate, the search originates
in the module the surrogate was interned in.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-RELATION) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-MODULE"
    "(DEFUN (GET-MODULE MODULE) ((MODULEREF OBJECT)) :DOCUMENTATION \"Return a module named 'moduleRef'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECTION?"
    "(DEFUN (COLLECTION? BOOLEAN) ((OBJECTREF OBJECT)) :DOCUMENTATION \"Return TRUE if 'objectRef' denotes a relation or a class.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COLLECTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS?"
    "(DEFUN (CLASS? BOOLEAN) ((OBJECTREF OBJECT)) :DOCUMENTATION \"Return TRUE if 'objectRef' denotes a class.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CLASS?) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATION?"
    "(DEFUN (RELATION? BOOLEAN) ((OBJECTREF OBJECT)) :DOCUMENTATION \"Return TRUE if 'objectRef' denotes a relation or a class.\" :PUBLIC? TRUE)"
    (CL:FUNCTION RELATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "FUNCTION?"
    "(DEFUN (FUNCTION? BOOLEAN) ((RELATIONREF OBJECT)) :DOCUMENTATION \"Return TRUE if 'relationRef' references a function.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FUNCTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "CONSTANT?"
    "(DEFUN (CONSTANT? BOOLEAN) ((OBJECTREF OBJECT)) :DOCUMENTATION \"Return TRUE if `objectRef' denotes a literal or scalar.\")"
    (CL:FUNCTION CONSTANT?) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATION-NAME"
    "(DEFUN (RELATION-NAME STRING) ((SELF NAMED-DESCRIPTION)) :DOCUMENTATION \"Given a relation object, return it's name.\")"
    (CL:FUNCTION RELATION-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMIFY"
    "(DEFUN (TERMIFY OBJECT) ((SELF OBJECT)) :DOCUMENTATION \"Convert 'self' into an equivalent PowerLoom object
that can be passed as an argument wherever an instance is expected.\")"
    (CL:FUNCTION TERMIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATION-ARITY-OK?"
    "(DEFUN (RELATION-ARITY-OK? BOOLEAN) ((RELATIONREF SURROGATE) (ARITY INTEGER)))"
    (CL:FUNCTION RELATION-ARITY-OK?) NULL)
   (DEFINE-FUNCTION-OBJECT "FILTER-OUT-UNNAMED-DESCRIPTIONS"
    "(DEFUN (FILTER-OUT-UNNAMED-DESCRIPTIONS (CONS OF NAMED-DESCRIPTION)) ((DESCRIPTIONS (CONS OF LOGIC-OBJECT))))"
    (CL:FUNCTION FILTER-OUT-UNNAMED-DESCRIPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-ASSERTED-TYPES"
    "(DEFUN (ALL-ASSERTED-TYPES (CONS OF NAMED-DESCRIPTION)) ((SELF OBJECT)) :DOCUMENTATION \"Return a set of all of the types that are
asserted to be satisfied by 'self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-ASSERTED-TYPES) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-TYPES"
    "(DEFUN (ALL-TYPES (CONS OF NAMED-DESCRIPTION)) ((SELF OBJECT)) :DOCUMENTATION \"Return a set of all of the types that are
satisfied by 'self'.\" :PUBLIC? TRUE)" (CL:FUNCTION ALL-TYPES) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-ALL-TYPES"
    "(DEFUN (HELP-ALL-TYPES (CONS OF NAMED-DESCRIPTION)) ((SELF OBJECT)))"
    (CL:FUNCTION HELP-ALL-TYPES) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DIRECT-TYPES"
    "(DEFUN (ALL-DIRECT-TYPES (CONS OF LOGIC-OBJECT)) ((SELF OBJECT)) :DOCUMENTATION \"Return a set of most specific types that are
satisfied by 'self'.\" :PUBLIC? TRUE)" (CL:FUNCTION ALL-DIRECT-TYPES)
    NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-TYPE-ON-INSTANCE?"
    "(DEFUN (TEST-TYPE-ON-INSTANCE? BOOLEAN) ((SELF OBJECT) (TYPE SURROGATE)) :DOCUMENTATION \"Return TRUE if 'self' satisfies 'type'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION TEST-TYPE-ON-INSTANCE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-TEST-TYPE-ON-INSTANCE? BOOLEAN) ((LEVEL SUBSUMPTION-INFERENCE-LEVEL) (SELF OBJECT) (TYPE SURROGATE)))"
    (CL:FUNCTION LEVELLIZED-TEST-TYPE-ON-INSTANCE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-TEST-TYPE-ON-INSTANCE? BOOLEAN) ((LEVEL SHALLOW-INFERENCE-LEVEL) (SELF OBJECT) (TYPE SURROGATE)))"
    (CL:FUNCTION LEVELLIZED-TEST-TYPE-ON-INSTANCE?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-EQUIVALENT-RELATIONS"
    "(DEFUN (ALL-EQUIVALENT-RELATIONS (CONS OF NAMED-DESCRIPTION)) ((RELATION NAMED-DESCRIPTION) (REFLEXIVE? BOOLEAN)) :DOCUMENTATION \"Return a list of all relations equivalent to 'relation'.
If 'reflexive?', include 'relation' in the list.\")"
    (CL:FUNCTION ALL-EQUIVALENT-RELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-EQUIVALENT-RELATIONS"
    "(DEFUN (REMOVE-EQUIVALENT-RELATIONS (LIKE SELF)) ((RELATIONSLIST (CONS OF LOGIC-OBJECT)) (RELATION NAMED-DESCRIPTION)))"
    (CL:FUNCTION REMOVE-EQUIVALENT-RELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-MEMOIZE-ALL-SUPERRELATIONS"
    "(DEFUN (HELP-MEMOIZE-ALL-SUPERRELATIONS (CONS OF NAMED-DESCRIPTION)) ((RELATION NAMED-DESCRIPTION) (REMOVEEQUIVALENTS? BOOLEAN)))"
    (CL:FUNCTION HELP-MEMOIZE-ALL-SUPERRELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SUPERRELATIONS"
    "(DEFUN (ALL-SUPERRELATIONS (CONS OF NAMED-DESCRIPTION)) ((RELATION NAMED-DESCRIPTION) (REMOVEEQUIVALENTS? BOOLEAN)) :DOCUMENTATION \"Return a set of all relations that subsume relation.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-SUPERRELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-MEMOIZE-ALL-SUBRELATIONS"
    "(DEFUN (HELP-MEMOIZE-ALL-SUBRELATIONS (CONS OF NAMED-DESCRIPTION)) ((RELATION NAMED-DESCRIPTION) (REMOVEEQUIVALENTS? BOOLEAN)))"
    (CL:FUNCTION HELP-MEMOIZE-ALL-SUBRELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SUBRELATIONS"
    "(DEFUN (ALL-SUBRELATIONS (CONS OF NAMED-DESCRIPTION)) ((RELATION NAMED-DESCRIPTION) (REMOVEEQUIVALENTS? BOOLEAN)) :DOCUMENTATION \"Return a set of all (named) relations that specialize
relation.\" :PUBLIC? TRUE)" (CL:FUNCTION ALL-SUBRELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DIRECT-SUPERRELATIONS"
    "(DEFUN (ALL-DIRECT-SUPERRELATIONS (CONS OF NAMED-DESCRIPTION)) ((RELATION NAMED-DESCRIPTION) (REMOVEEQUIVALENTS? BOOLEAN)) :DOCUMENTATION \"Return a set of relations that immediately subsume
'relation'.  If 'removeEquivalents?' (recommended), don't include any
relations equivalent to 'relation'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-DIRECT-SUPERRELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DIRECT-SUBRELATIONS"
    "(DEFUN (ALL-DIRECT-SUBRELATIONS (CONS OF NAMED-DESCRIPTION)) ((RELATION NAMED-DESCRIPTION) (REMOVEEQUIVALENTS? BOOLEAN)) :DOCUMENTATION \"Return a set of relations that immediately specialize
'relation'.  If 'removeEquivalents?' (recommended), don't include any
relations equivalent to 'relation'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-DIRECT-SUBRELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-SUBRELATION?"
    "(DEFUN (TEST-SUBRELATION? BOOLEAN) ((SUBRELATION SURROGATE) (SUPERRELATION SURROGATE)) :DOCUMENTATION \"Return TRUE if 'subrelation' specializes 'superrelation'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION TEST-SUBRELATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-CLASS-INSTANCES"
    "(DEFUN (ALL-CLASS-INSTANCES CONS) ((TYPE SURROGATE)) :DOCUMENTATION \"Return a set of instances that belong to the class 'type'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-CLASS-INSTANCES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-ALL-CLASS-INSTANCES CONS) ((LEVEL SUBSUMPTION-INFERENCE-LEVEL) (TYPE SURROGATE)))"
    (CL:FUNCTION LEVELLIZED-ALL-CLASS-INSTANCES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-ALL-CLASS-INSTANCES CONS) ((LEVEL ASSERTION-INFERENCE-LEVEL) (TYPE SURROGATE)))"
    (CL:FUNCTION LEVELLIZED-ALL-CLASS-INSTANCES) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-RELATION-VALUES"
    "(DEFUN (ALL-RELATION-VALUES CONS) ((RELATION SURROGATE) (NMINUSONEARGUMENTS CONS)) :DOCUMENTATION \"Return a set of values that satisfy the relation
'relation' (a surrogate) applied to 'nMinusOneArguments' plus that last value.\")"
    (CL:FUNCTION ALL-RELATION-VALUES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-ALL-RELATION-VALUES CONS) ((LEVEL SUBSUMPTION-INFERENCE-LEVEL) (RELATION SURROGATE) (NMINUSONEARGUMENTS CONS)))"
    (CL:FUNCTION LEVELLIZED-ALL-RELATION-VALUES) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-RELATION-ON-ARGUMENTS?"
    "(DEFUN (TEST-RELATION-ON-ARGUMENTS? BOOLEAN) ((RELATION SURROGATE) (ARGUMENTS CONS)) :DOCUMENTATION \"Return TRUE if 'relation' (a surrogate) is TRUE when
applied to 'arguments'.\")" (CL:FUNCTION TEST-RELATION-ON-ARGUMENTS?)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-TEST-RELATION-ON-ARGUMENTS? BOOLEAN) ((LEVEL SUBSUMPTION-INFERENCE-LEVEL) (RELATION SURROGATE) (ARGUMENTS CONS)))"
    (CL:FUNCTION LEVELLIZED-TEST-RELATION-ON-ARGUMENTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SLOT-VALUES"
    "(DEFUN (ALL-SLOT-VALUES CONS) ((SELF LOGIC-OBJECT) (RELATION SURROGATE)) :DOCUMENTATION \"Return a set of values for the slot 'relation' (a surrogate)
applied to 'self' (an object).\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-SLOT-VALUES) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SLOT-VALUE"
    "(DEFUN (GET-SLOT-VALUE OBJECT) ((SELF LOGIC-OBJECT) (RELATION SURROGATE)) :DOCUMENTATION \"Return a single value for the slot 'relation' (a surrogate)
applied to 'self' (an object).\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-SLOT-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-SLOT-VALUE?"
    "(DEFUN (TEST-SLOT-VALUE? BOOLEAN) ((SELF LOGIC-OBJECT) (RELATION SURROGATE) (FILLER OBJECT)) :DOCUMENTATION \"Return TRUE if the proposition '(<relation> <self> <filler>)'
is true.\" :PUBLIC? TRUE)" (CL:FUNCTION TEST-SLOT-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SLOT-MINIMUM-CARDINALITY"
    "(DEFUN (GET-SLOT-MINIMUM-CARDINALITY INTEGER) ((SELF LOGIC-OBJECT) (RELATION SURROGATE)) :DOCUMENTATION \"Return a minimum value for the number of fillers of relation
'relation' (a surrogate) applied to the instance 'self' (an object).\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-SLOT-MINIMUM-CARDINALITY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY INTEGER) ((LEVEL SHALLOW-INFERENCE-LEVEL) (SELF LOGIC-OBJECT) (RELATION SURROGATE)))"
    (CL:FUNCTION LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY INTEGER) ((LEVEL SUBSUMPTION-INFERENCE-LEVEL) (SELF LOGIC-OBJECT) (RELATION SURROGATE)))"
    (CL:FUNCTION LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-CLOSED-SLOT?"
    "(DEFUN (TEST-CLOSED-SLOT? BOOLEAN) ((RELATION SURROGATE)) :DOCUMENTATION \"Return TRUE if 'relation' (a surrogate) is asserted to 
be closed or if the current module closes all relations.\" :PUBLIC? TRUE)"
    (CL:FUNCTION TEST-CLOSED-SLOT?) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-FUNCTION-SLOT?"
    "(DEFUN (TEST-FUNCTION-SLOT? BOOLEAN) ((RELATION SURROGATE)) :DOCUMENTATION \"Return TRUE if 'relation' (a surrogate) is a function.\" :PUBLIC? TRUE)"
    (CL:FUNCTION TEST-FUNCTION-SLOT?) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SLOT-MAXIMUM-CARDINALITY"
    "(DEFUN (GET-SLOT-MAXIMUM-CARDINALITY INTEGER) ((SELF LOGIC-OBJECT) (RELATION SURROGATE)) :DOCUMENTATION \"Return a maximum value for the number of fillers of relation
'relation' (a surrogate) applied to the instance 'self' (an object).\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-SLOT-MAXIMUM-CARDINALITY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY INTEGER) ((LEVEL SHALLOW-INFERENCE-LEVEL) (SELF LOGIC-OBJECT) (RELATION SURROGATE)))"
    (CL:FUNCTION LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY INTEGER) ((LEVEL SUBSUMPTION-INFERENCE-LEVEL) (SELF LOGIC-OBJECT) (RELATION SURROGATE)))"
    (CL:FUNCTION LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SLOT-VALUE-TYPE"
    "(DEFUN (GET-SLOT-VALUE-TYPE NAMED-DESCRIPTION) ((SELF LOGIC-OBJECT) (RELATION SURROGATE)) :DOCUMENTATION \"Return a most specific type for fillers of the slot 'relation'
(a surrogate) applied to 'self'. If there is more than one, pick one.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-SLOT-VALUE-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SLOT-VALUE-TYPES"
    "(DEFUN (ALL-SLOT-VALUE-TYPES (CONS OF NAMED-DESCRIPTION)) ((SELF LOGIC-OBJECT) (RELATION SURROGATE)) :DOCUMENTATION \"Return a set of the most specific types for fillers
of the slot 'relation' applied to 'self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-SLOT-VALUE-TYPES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-ALL-SLOT-VALUE-TYPES (CONS OF NAMED-DESCRIPTION)) ((LEVEL SHALLOW-INFERENCE-LEVEL) (SELF LOGIC-OBJECT) (RELATION SURROGATE)))"
    (CL:FUNCTION LEVELLIZED-ALL-SLOT-VALUE-TYPES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-ALL-SLOT-VALUE-TYPES (CONS OF NAMED-DESCRIPTION)) ((LEVEL SUBSUMPTION-INFERENCE-LEVEL) (SELF LOGIC-OBJECT) (RELATION SURROGATE)))"
    (CL:FUNCTION LEVELLIZED-ALL-SLOT-VALUE-TYPES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-TEST-TYPE-ON-INSTANCE? BOOLEAN) ((LEVEL NORMAL-INFERENCE-LEVEL) (SELF OBJECT) (TYPE SURROGATE)))"
    (CL:FUNCTION LEVELLIZED-TEST-TYPE-ON-INSTANCE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-ALL-CLASS-INSTANCES CONS) ((LEVEL NORMAL-INFERENCE-LEVEL) (TYPE SURROGATE)))"
    (CL:FUNCTION LEVELLIZED-ALL-CLASS-INSTANCES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-ALL-RELATION-VALUES CONS) ((LEVEL NORMAL-INFERENCE-LEVEL) (RELATION SURROGATE) (NMINUSONEARGUMENTS CONS)))"
    (CL:FUNCTION LEVELLIZED-ALL-RELATION-VALUES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-TEST-RELATION-ON-ARGUMENTS? BOOLEAN) ((LEVEL NORMAL-INFERENCE-LEVEL) (RELATION SURROGATE) (ARGUMENTS CONS)))"
    (CL:FUNCTION LEVELLIZED-TEST-RELATION-ON-ARGUMENTS?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY INTEGER) ((LEVEL NORMAL-INFERENCE-LEVEL) (SELF LOGIC-OBJECT) (RELATION SURROGATE)))"
    (CL:FUNCTION LEVELLIZED-GET-SLOT-MINIMUM-CARDINALITY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY INTEGER) ((LEVEL NORMAL-INFERENCE-LEVEL) (SELF LOGIC-OBJECT) (RELATION SURROGATE)))"
    (CL:FUNCTION LEVELLIZED-GET-SLOT-MAXIMUM-CARDINALITY) NULL)))

(CL:DEFUN STARTUP-FRAME-SUPPORT ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-FRAME-SUPPORT1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (HELP-STARTUP-FRAME-SUPPORT2)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LEVELLIZED-ALL-SLOT-VALUE-TYPES (CONS OF NAMED-DESCRIPTION)) ((LEVEL NORMAL-INFERENCE-LEVEL) (SELF LOGIC-OBJECT) (RELATION SURROGATE)))"
     (CL:FUNCTION LEVELLIZED-ALL-SLOT-VALUE-TYPES) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-FRAME-SUPPORT"
     "(DEFUN STARTUP-FRAME-SUPPORT () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-FRAME-SUPPORT) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION
        SYM-FRAME-SUPPORT-LOGIC-STARTUP-FRAME-SUPPORT)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-FRAME-SUPPORT-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_Startup-Frame-Support") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (REGISTER-NATIVE-NAME SYM-FRAME-SUPPORT-LOGIC-FIND-INSTANCE
     KWD-FRAME-SUPPORT-COMMON-LISP KWD-FRAME-SUPPORT-FUNCTION))))
