;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997-2000              | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-CLASSIFY-LOGIC-GLOBAL-TIMESTAMPS-RECORD NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-INFERABLE-TIMESTAMP NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-READ-SINCE-LAST-INFERABLE-BUMP? NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-DISJOINTNESS-TIMESTAMP NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-READ-SINCE-LAST-DISJOINTNESS-BUMP? NULL)
(CL:DEFVAR SGT-CLASSIFY-LOGIC-INFERABLE-CACHE-RECORD NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-INFERABLE-CACHE-TIMESTAMP NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-INFERABLE-CACHE-TABLE NULL)
(CL:DEFVAR KWD-CLASSIFY-INFERABLE NULL)
(CL:DEFVAR SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SGT-CLASSIFY-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR KWD-CLASSIFY-NON-INFERABLE NULL)
(CL:DEFVAR KWD-CLASSIFY-PREDICATE NULL)
(CL:DEFVAR KWD-CLASSIFY-FUNCTION NULL)
(CL:DEFVAR KWD-CLASSIFY-ISA NULL)
(CL:DEFVAR KWD-CLASSIFY-AND NULL)
(CL:DEFVAR KWD-CLASSIFY-EXISTS NULL)
(CL:DEFVAR KWD-CLASSIFY-BACKWARD NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-FORWARD-ONLY? NULL)
(CL:DEFVAR SGT-CLASSIFY-STELLA-THING NULL)
(CL:DEFVAR SGT-CLASSIFY-LOGIC-DISJOINTNESS-CACHE-RECORD NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-DISJOINTNESS-CACHE-TIMESTAMP NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-DISJOINTNESS-CACHE-TABLE NULL)
(CL:DEFVAR KWD-CLASSIFY-DISJOINT NULL)
(CL:DEFVAR KWD-CLASSIFY-NON-DISJOINT NULL)
(CL:DEFVAR SGT-CLASSIFY-LOGIC-MARKER-TABLE NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-TEST-TABLE NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-RECALL-TABLE NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-SUPPORTS-RECALL? NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-SUBSUMPTION-LINK? NULL)
(CL:DEFVAR KWD-CLASSIFY-CLASSIFIER-INFERENCES NULL)
(CL:DEFVAR SGT-CLASSIFY-LOGIC-CLASSIFICATION-CACHE NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-INFERABLE-DIRECT-SUBDESCRIPTIONS NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CACHE-UPCLASSIFICATION-TIMESTAMP NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CACHE-DOWNCLASSIFICATION-TIMESTAMP NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-INTRODUCTION-TIMESTAMP NULL)
(CL:DEFVAR SGT-CLASSIFY-LOGIC-CLASSIFICATION-SESSION NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CLASSIFICATION-WORLD NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CLASSIFICATION-CACHE-TABLE NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CLASSIFICATION-TIMECLOCK NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-INTRODUCTION-TIMESTAMP-STACK NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-EVERYTHING-CLASSIFIED? NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-LAST-CACHE-TABLE-KEY NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-LAST-CACHE-TABLE-VALUE NULL)
(CL:DEFVAR KWD-CLASSIFY-DESCRIPTION NULL)
(CL:DEFVAR KWD-CLASSIFY-META NULL)
(CL:DEFVAR KWD-CLASSIFY-INSTANCE NULL)
(CL:DEFVAR KWD-CLASSIFY-TMS NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-META-INFERENCE-CACHE NULL)
(CL:DEFVAR KWD-CLASSIFY-JUST-IN-TIME NULL)
(CL:DEFVAR KWD-CLASSIFY-CLASSIFIER NULL)
(CL:DEFVAR KWD-CLASSIFY-UPCLASSIFY NULL)
(CL:DEFVAR KWD-CLASSIFY-DOWNCLASSIFY NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-SUBRELATION-LINK? NULL)
(CL:DEFVAR KWD-CLASSIFY-ASSERT-TRUE NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CLASSIFY-RELATIONS NULL)
(CL:DEFVAR KWD-CLASSIFY-COMMON-LISP NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CLASSIFY-INSTANCES NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-STARTUP-CLASSIFY NULL)
(CL:DEFVAR SYM-CLASSIFY-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *CONTEXT* *TRACED-KEYWORDS* *MODULE*
  *EMIT-THINKING-DOTS?* STANDARD-OUTPUT EOL TRUE-WRAPPER FALSE-WRAPPER))

(CL:DEFUN NEW-GLOBAL-TIMESTAMPS-RECORD ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-GLOBAL-TIMESTAMPS-RECORD))
   (CL:SETF
    (%GLOBAL-TIMESTAMPS-RECORD.READ-SINCE-LAST-DISJOINTNESS-BUMP? SELF)
    FALSE)
   (CL:SETF (%GLOBAL-TIMESTAMPS-RECORD.DISJOINTNESS-TIMESTAMP SELF) 0)
   (CL:SETF
    (%GLOBAL-TIMESTAMPS-RECORD.READ-SINCE-LAST-INFERABLE-BUMP? SELF)
    FALSE)
   (CL:SETF (%GLOBAL-TIMESTAMPS-RECORD.INFERABLE-TIMESTAMP SELF) 0) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF GLOBAL-TIMESTAMPS-RECORD))
  SGT-CLASSIFY-LOGIC-GLOBAL-TIMESTAMPS-RECORD)

(CL:DEFUN ACCESS-GLOBAL-TIMESTAMPS-RECORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-INFERABLE-TIMESTAMP)
    (CL:IF SETVALUE?
     (CL:SETF (%GLOBAL-TIMESTAMPS-RECORD.INFERABLE-TIMESTAMP SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER
       (%GLOBAL-TIMESTAMPS-RECORD.INFERABLE-TIMESTAMP SELF)))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-READ-SINCE-LAST-INFERABLE-BUMP?)
    (CL:IF SETVALUE?
     (CL:SETF
      (%GLOBAL-TIMESTAMPS-RECORD.READ-SINCE-LAST-INFERABLE-BUMP? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF
       (%GLOBAL-TIMESTAMPS-RECORD.READ-SINCE-LAST-INFERABLE-BUMP? SELF)
       TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-DISJOINTNESS-TIMESTAMP)
    (CL:IF SETVALUE?
     (CL:SETF (%GLOBAL-TIMESTAMPS-RECORD.DISJOINTNESS-TIMESTAMP SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER
       (%GLOBAL-TIMESTAMPS-RECORD.DISJOINTNESS-TIMESTAMP SELF)))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-READ-SINCE-LAST-DISJOINTNESS-BUMP?)
    (CL:IF SETVALUE?
     (CL:SETF
      (%GLOBAL-TIMESTAMPS-RECORD.READ-SINCE-LAST-DISJOINTNESS-BUMP? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF
       (%GLOBAL-TIMESTAMPS-RECORD.READ-SINCE-LAST-DISJOINTNESS-BUMP? SELF)
       TRUE-WRAPPER FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFGLOBAL *GLOBAL-TIMESTAMPS* ...)

(CL:DEFVAR *GLOBAL-TIMESTAMPS* NULL
  "Keeps track of all global timestamps, making
maintenance (e.g., resetting) more manageable.")

;;; (DEFUN (GET-INFERABLE-TIMESTAMP TIMESTAMP) ...)

(CL:DEFUN GET-INFERABLE-TIMESTAMP ()
  (CL:SETF
   (%GLOBAL-TIMESTAMPS-RECORD.READ-SINCE-LAST-INFERABLE-BUMP?
    *GLOBAL-TIMESTAMPS*)
   TRUE)
  (%GLOBAL-TIMESTAMPS-RECORD.INFERABLE-TIMESTAMP *GLOBAL-TIMESTAMPS*))

;;; (DEFUN BUMP-INFERABLE-TIMESTAMP ...)

(CL:DEFUN BUMP-INFERABLE-TIMESTAMP ()
  (CL:WHEN
   (%GLOBAL-TIMESTAMPS-RECORD.READ-SINCE-LAST-INFERABLE-BUMP?
    *GLOBAL-TIMESTAMPS*)
   (CL:SETF
    (%GLOBAL-TIMESTAMPS-RECORD.INFERABLE-TIMESTAMP *GLOBAL-TIMESTAMPS*)
    (CL:1+
     (%GLOBAL-TIMESTAMPS-RECORD.INFERABLE-TIMESTAMP *GLOBAL-TIMESTAMPS*)))
   (CL:SETF
    (%GLOBAL-TIMESTAMPS-RECORD.READ-SINCE-LAST-INFERABLE-BUMP?
     *GLOBAL-TIMESTAMPS*)
    FALSE)))

(CL:DEFUN NEW-INFERABLE-CACHE-RECORD ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-INFERABLE-CACHE-RECORD))
   (CL:SETF (%INFERABLE-CACHE-RECORD.INFERABLE-CACHE-TABLE SELF) NULL)
   (CL:SETF (%INFERABLE-CACHE-RECORD.INFERABLE-CACHE-TIMESTAMP SELF) -1)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INFERABLE-CACHE-RECORD))
  SGT-CLASSIFY-LOGIC-INFERABLE-CACHE-RECORD)

(CL:DEFUN ACCESS-INFERABLE-CACHE-RECORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-INFERABLE-CACHE-TIMESTAMP)
    (CL:IF SETVALUE?
     (CL:SETF (%INFERABLE-CACHE-RECORD.INFERABLE-CACHE-TIMESTAMP SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER
       (%INFERABLE-CACHE-RECORD.INFERABLE-CACHE-TIMESTAMP SELF)))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-INFERABLE-CACHE-TABLE)
    (CL:IF SETVALUE?
     (CL:SETF (%INFERABLE-CACHE-RECORD.INFERABLE-CACHE-TABLE SELF) VALUE)
     (CL:SETQ VALUE
      (%INFERABLE-CACHE-RECORD.INFERABLE-CACHE-TABLE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFGLOBAL *INFERABLE-CACHE* ...)

(CL:DEFVAR *INFERABLE-CACHE* NULL
  "Pointer to cache containing table that maps descriptions
to :INFERABLE or :NON-INFERABLE.")

;;; (DEFGLOBAL *INFERABLE-CACHE-ENABLED?* ...)

(CL:DEFVAR *INFERABLE-CACHE-ENABLED?* TRUE)

;;; (DEFUN (TOGGLE-INFERABLE-CACHE STRING) ...)

(CL:DEFUN TOGGLE-INFERABLE-CACHE ()
  (CL:SETQ *INFERABLE-CACHE-ENABLED?* (CL:NOT *INFERABLE-CACHE-ENABLED?*))
  (CL:WHEN (CL:NOT *INFERABLE-CACHE-ENABLED?*)
   (CL:SETF
    (%INFERABLE-CACHE-RECORD.INFERABLE-CACHE-TIMESTAMP *INFERABLE-CACHE*)
    -1))
  (CL:IF *INFERABLE-CACHE-ENABLED?* "Inferable cache enabled."
   "Inferable cache disabled."))

;;; (DEFUN (GET-INFERABLE-CACHED-KEYWORD KEYWORD) ...)

(CL:DEFUN GET-INFERABLE-CACHED-KEYWORD (DESCRIPTION)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE DESCRIPTION)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:LET* ((CACHE *INFERABLE-CACHE*))
       (CL:WHEN (CL:NOT *INFERABLE-CACHE-ENABLED?*)
        (CL:RETURN-FROM GET-INFERABLE-CACHED-KEYWORD NULL))
       (CL:IF
        (CL:>= (%INFERABLE-CACHE-RECORD.INFERABLE-CACHE-TIMESTAMP CACHE)
         (GET-INFERABLE-TIMESTAMP))
        (LOOKUP (%INFERABLE-CACHE-RECORD.INFERABLE-CACHE-TABLE CACHE)
         DESCRIPTION)
        NULL))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-CLASSIFY-LOGIC-DESCRIPTION)
     (CL:PROGN KWD-CLASSIFY-INFERABLE))
    (CL:T KWD-CLASSIFY-NON-INFERABLE))))

;;; (DEFUN SET-INFERABLE-CACHED-KEYWORD ...)

(CL:DEFUN SET-INFERABLE-CACHED-KEYWORD (DESCRIPTION INFERABLE?)
  (CL:WHEN (CL:NOT *INFERABLE-CACHE-ENABLED?*)
   (CL:RETURN-FROM SET-INFERABLE-CACHED-KEYWORD))
  (CL:LET* ((CACHE *INFERABLE-CACHE*))
   (CL:WHEN
    (CL:< (%INFERABLE-CACHE-RECORD.INFERABLE-CACHE-TIMESTAMP CACHE)
     (GET-INFERABLE-TIMESTAMP))
    (CL:SETF (%INFERABLE-CACHE-RECORD.INFERABLE-CACHE-TABLE CACHE)
     (NEW-HASH-TABLE))
    (CL:SETF (%INFERABLE-CACHE-RECORD.INFERABLE-CACHE-TIMESTAMP CACHE)
     (GET-INFERABLE-TIMESTAMP)))
   (INSERT-AT (%INFERABLE-CACHE-RECORD.INFERABLE-CACHE-TABLE CACHE)
    DESCRIPTION
    (CL:IF INFERABLE? KWD-CLASSIFY-INFERABLE KWD-CLASSIFY-NON-INFERABLE))))

;;; (DEFUN HELP-COLLECT-INTENSIONAL-PARENTS ...)

(CL:DEFUN HELP-COLLECT-INTENSIONAL-PARENTS (DESCRIPTION PROPOSITION COLLECTION)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-CLASSIFY-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-CLASSIFY-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-CLASSIFY-ISA))
     (CL:LET* ((TEST-VALUE-001 FALSE))
      (CL:LET* ((ALWAYS?-000 TRUE))
       (CL:LET*
        ((ARG2 NULL) (ARG1 NULL)
         (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION)) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000))
         (VECTOR-001 (%DESCRIPTION.IO-VARIABLES DESCRIPTION))
         (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
        (CL:DECLARE
         (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
        (CL:LOOP WHILE
         (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
         DO
         (CL:PROGN
          (CL:SETQ ARG1
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
         (CL:PROGN
          (CL:SETQ ARG2
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
            INDEX-001))
          (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
         (CL:WHEN (CL:NOT (CL:EQ ARG1 ARG2)) (CL:SETQ ALWAYS?-000 FALSE)
          (CL:RETURN))))
       (CL:SETQ TEST-VALUE-001 ALWAYS?-000))
      (CL:WHEN TEST-VALUE-001
       (CL:SETQ TEST-VALUE-001
        (CL:= (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION))
         (LENGTH (%DESCRIPTION.IO-VARIABLES DESCRIPTION)))))
      (CL:WHEN TEST-VALUE-001
       (PUSH COLLECTION
        (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION))))))
    ((CL:EQ TEST-VALUE-000 KWD-CLASSIFY-AND)
     (CL:LET*
      ((ARG NULL) (VECTOR-002 (%PROPOSITION.ARGUMENTS PROPOSITION))
       (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
      (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
       (CL:PROGN
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
          INDEX-002))
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
       (HELP-COLLECT-INTENSIONAL-PARENTS DESCRIPTION ARG COLLECTION))))
    ((CL:EQ TEST-VALUE-000 KWD-CLASSIFY-EXISTS)
     (HELP-COLLECT-INTENSIONAL-PARENTS DESCRIPTION
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
       0)
      COLLECTION))
    (CL:T))))

;;; (DEFUN (ALL-INTENSIONAL-PARENTS (LIST OF DESCRIPTION)) ...)

(CL:DEFUN ALL-INTENSIONAL-PARENTS (SELF)
  (CL:LET* ((COLLECTION (NEW-LIST)))
   (HELP-COLLECT-INTENSIONAL-PARENTS SELF (%DESCRIPTION.PROPOSITION SELF)
    COLLECTION)
   COLLECTION))

;;; (DEFUN (INFERABLE-THROUGH-BY-SOME-DESCENDANT? BOOLEAN) ...)

(CL:DEFUN INFERABLE-THROUGH-BY-SOME-DESCENDANT? (SELF THROUGHCHILD ALREADYVISITEDLIST)
  (CL:COND
   ((CL:NOT (ISA? THROUGHCHILD SGT-CLASSIFY-LOGIC-DESCRIPTION))
    (CL:RETURN-FROM INFERABLE-THROUGH-BY-SOME-DESCENDANT? FALSE))
   ((CL:NOT
     (CL:EQ (%PROPOSITION.KIND (%NAMED-DESCRIPTION.PROPOSITION SELF))
      (%PROPOSITION.KIND (%DESCRIPTION.PROPOSITION THROUGHCHILD))))
    (CL:RETURN-FROM INFERABLE-THROUGH-BY-SOME-DESCENDANT? TRUE))
   ((CL:AND (ISA? THROUGHCHILD SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION)
     (CL:NOT (CL:EQ (LOOKUP-SPECIALIST THROUGHCHILD) NULL)))
    (CL:RETURN-FROM INFERABLE-THROUGH-BY-SOME-DESCENDANT? TRUE))
   ((CL:NOT (INFERABLE-WITH-CYCLE-CHECK? THROUGHCHILD ALREADYVISITEDLIST))
    (CL:RETURN-FROM INFERABLE-THROUGH-BY-SOME-DESCENDANT? FALSE)))
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE THROUGHCHILD)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:WHEN (MEMBER? ALREADYVISITEDLIST SELF)
       (CL:RETURN-FROM INFERABLE-THROUGH-BY-SOME-DESCENDANT? FALSE))
      (CL:LET*
       ((P NULL)
        (ITER-000
         (APPLICABLE-RULES-OF-DESCRIPTION THROUGHCHILD
          KWD-CLASSIFY-BACKWARD FALSE)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:PROGN (CL:SETQ P (%%VALUE ITER-000))
         (CL:SETQ ITER-000 (%%REST ITER-000)))
        (CL:WHEN
         (CL:NOT
          (%BOOLEAN-WRAPPER.WRAPPER-VALUE
           (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS P)
            SYM-CLASSIFY-LOGIC-FORWARD-ONLY? FALSE-WRAPPER)))
         (CL:WHEN
          (INFERABLE-THROUGH-BY-SOME-DESCENDANT? SELF
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
            0)
           ALREADYVISITEDLIST)
          (CL:RETURN-FROM INFERABLE-THROUGH-BY-SOME-DESCENDANT?
           TRUE)))))))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-CLASSIFY-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 FALSE))
       (CL:LET* ((FOUND?-000 FALSE))
        (CL:LET*
         ((PARENT NULL)
          (ITER-001
           (%LIST.THE-CONS-LIST (ALL-INTENSIONAL-PARENTS THROUGHCHILD))))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:PROGN (CL:SETQ PARENT (%%VALUE ITER-001))
           (CL:SETQ ITER-001 (%%REST ITER-001)))
          (CL:WHEN (DESCRIPTION-IMPLIES-DESCRIPTION? PARENT SELF)
           (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
        (CL:SETQ TEST-VALUE-000 FOUND?-000))
       (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
       (CL:LET* ((VALUE-000 TEST-VALUE-000))
        (CL:RETURN-FROM INFERABLE-THROUGH-BY-SOME-DESCENDANT?
         VALUE-000)))))
    (CL:T)))
  FALSE)

;;; (DEFUN (COMPUTE-INFERABLE? BOOLEAN) ...)

(CL:DEFUN COMPUTE-INFERABLE? (SELF ALREADYVISITEDLIST)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION)
    (CL:PROGN
     (CL:LET* ((TEST-VALUE-000 FALSE))
      (CL:SETQ TEST-VALUE-000
       (CL:NOT
        (CL:EQ (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE SELF)
         SGT-CLASSIFY-STELLA-THING)))
      (CL:WHEN TEST-VALUE-000
       (CL:LET* ((FOUND?-000 FALSE))
        (CL:LET*
         ((P NULL)
          (ITER-000
           (APPLICABLE-RULES-OF-DESCRIPTION SELF KWD-CLASSIFY-BACKWARD
            FALSE)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:PROGN (CL:SETQ P (%%VALUE ITER-000))
           (CL:SETQ ITER-000 (%%REST ITER-000)))
          (CL:WHEN
           (INFERABLE-THROUGH-BY-SOME-DESCENDANT? SELF
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
             0)
            ALREADYVISITEDLIST)
           (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
        (CL:SETQ TEST-VALUE-000 FOUND?-000)))
      (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000))))
   (CL:T TRUE)))

;;; (DEFUN (INFERABLE-WITH-CYCLE-CHECK? BOOLEAN) ...)

(CL:DEFUN INFERABLE-WITH-CYCLE-CHECK? (SELF ALREADYVISITEDLIST)
  (CL:LET* ((KEYWORD (GET-INFERABLE-CACHED-KEYWORD SELF)))
   (CL:WHEN (CL:NOT (CL:EQ KEYWORD NULL))
    (CL:RETURN-FROM INFERABLE-WITH-CYCLE-CHECK?
     (CL:EQ KEYWORD KWD-CLASSIFY-INFERABLE)))
   (CL:WHEN (MEMBER? ALREADYVISITEDLIST SELF)
    (CL:RETURN-FROM INFERABLE-WITH-CYCLE-CHECK? FALSE))
   (CL:LET*
    ((INFERABLE?
      (COMPUTE-INFERABLE? SELF (CONS SELF ALREADYVISITEDLIST))))
    (SET-INFERABLE-CACHED-KEYWORD SELF INFERABLE?) INFERABLE?)))

;;; (DEFUN (INFERABLE? BOOLEAN) ...)

(CL:DEFUN INFERABLE? (SELF)
  (INFERABLE-WITH-CYCLE-CHECK? SELF NIL))

;;; (DEFUN (NON-INFERABLE? BOOLEAN) ...)

(CL:DEFUN NON-INFERABLE? (SELF)
  (CL:NOT (INFERABLE? SELF)))

(CL:DEFUN NEW-DISJOINTNESS-CACHE-RECORD ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-DISJOINTNESS-CACHE-RECORD))
   (CL:SETF (%DISJOINTNESS-CACHE-RECORD.DISJOINTNESS-CACHE-TABLE SELF)
    NULL)
   (CL:SETF (%DISJOINTNESS-CACHE-RECORD.DISJOINTNESS-CACHE-TIMESTAMP SELF)
    NULL-INTEGER)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DISJOINTNESS-CACHE-RECORD))
  SGT-CLASSIFY-LOGIC-DISJOINTNESS-CACHE-RECORD)

(CL:DEFUN ACCESS-DISJOINTNESS-CACHE-RECORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-DISJOINTNESS-CACHE-TIMESTAMP)
    (CL:IF SETVALUE?
     (CL:SETF
      (%DISJOINTNESS-CACHE-RECORD.DISJOINTNESS-CACHE-TIMESTAMP SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER
       (%DISJOINTNESS-CACHE-RECORD.DISJOINTNESS-CACHE-TIMESTAMP SELF)))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-DISJOINTNESS-CACHE-TABLE)
    (CL:IF SETVALUE?
     (CL:SETF (%DISJOINTNESS-CACHE-RECORD.DISJOINTNESS-CACHE-TABLE SELF)
      VALUE)
     (CL:SETQ VALUE
      (%DISJOINTNESS-CACHE-RECORD.DISJOINTNESS-CACHE-TABLE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFGLOBAL *DISJOINTNESS-CACHE* ...)

(CL:DEFVAR *DISJOINTNESS-CACHE* NULL
  "Pointer to cache containing table that maps descriptions
to :DISJOINT or :NON-DISJOINT.")

;;; (DEFGLOBAL *DISJOINTNESS-CACHE-ENABLED?* ...)

(CL:DEFVAR *DISJOINTNESS-CACHE-ENABLED?* TRUE)

;;; (DEFUN (TOGGLE-DISJOINTNESS-CACHE STRING) ...)

(CL:DEFUN TOGGLE-DISJOINTNESS-CACHE ()
  (CL:SETQ *DISJOINTNESS-CACHE-ENABLED?*
   (CL:NOT *DISJOINTNESS-CACHE-ENABLED?*))
  (CL:IF *DISJOINTNESS-CACHE-ENABLED?* "Disjointness cache enabled."
   "Disjointness cache disabled."))

;;; (DEFUN (GET-DISJOINTNESS-TIMESTAMP TIMESTAMP) ...)

(CL:DEFUN GET-DISJOINTNESS-TIMESTAMP ()
  (CL:SETF
   (%GLOBAL-TIMESTAMPS-RECORD.READ-SINCE-LAST-DISJOINTNESS-BUMP?
    *GLOBAL-TIMESTAMPS*)
   TRUE)
  (%GLOBAL-TIMESTAMPS-RECORD.DISJOINTNESS-TIMESTAMP *GLOBAL-TIMESTAMPS*))

;;; (DEFUN BUMP-DISJOINTNESS-TIMESTAMP ...)

(CL:DEFUN BUMP-DISJOINTNESS-TIMESTAMP ()
  (CL:WHEN
   (%GLOBAL-TIMESTAMPS-RECORD.READ-SINCE-LAST-DISJOINTNESS-BUMP?
    *GLOBAL-TIMESTAMPS*)
   (CL:SETF
    (%GLOBAL-TIMESTAMPS-RECORD.DISJOINTNESS-TIMESTAMP *GLOBAL-TIMESTAMPS*)
    (CL:1+
     (%GLOBAL-TIMESTAMPS-RECORD.DISJOINTNESS-TIMESTAMP
      *GLOBAL-TIMESTAMPS*)))
   (CL:SETF
    (%GLOBAL-TIMESTAMPS-RECORD.READ-SINCE-LAST-DISJOINTNESS-BUMP?
     *GLOBAL-TIMESTAMPS*)
    FALSE)))

;;; (DEFUN (GET-DISJOINTNESS-CACHED-KEYWORD KEYWORD) ...)

(CL:DEFUN GET-DISJOINTNESS-CACHED-KEYWORD (DESCRIPTION)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE DESCRIPTION)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:LET* ((CACHE *DISJOINTNESS-CACHE*))
       (CL:WHEN (CL:NOT *DISJOINTNESS-CACHE-ENABLED?*)
        (CL:RETURN-FROM GET-DISJOINTNESS-CACHED-KEYWORD NULL))
       (CL:IF
        (CL:>=
         (%DISJOINTNESS-CACHE-RECORD.DISJOINTNESS-CACHE-TIMESTAMP CACHE)
         (%GLOBAL-TIMESTAMPS-RECORD.DISJOINTNESS-TIMESTAMP
          *GLOBAL-TIMESTAMPS*))
        (LOOKUP
         (%DISJOINTNESS-CACHE-RECORD.DISJOINTNESS-CACHE-TABLE CACHE)
         DESCRIPTION)
        NULL))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-CLASSIFY-LOGIC-DESCRIPTION)
     (CL:PROGN KWD-CLASSIFY-DISJOINT))
    (CL:T KWD-CLASSIFY-NON-DISJOINT))))

;;; (DEFUN SET-DISJOINTNESS-CACHED-KEYWORD ...)

(CL:DEFUN SET-DISJOINTNESS-CACHED-KEYWORD (DESCRIPTION DISJOINT?)
  (CL:WHEN (CL:NOT *DISJOINTNESS-CACHE-ENABLED?*)
   (CL:RETURN-FROM SET-DISJOINTNESS-CACHED-KEYWORD))
  (CL:LET* ((CACHE *DISJOINTNESS-CACHE*))
   (CL:WHEN
    (CL:< (%DISJOINTNESS-CACHE-RECORD.DISJOINTNESS-CACHE-TIMESTAMP CACHE)
     (%GLOBAL-TIMESTAMPS-RECORD.DISJOINTNESS-TIMESTAMP
      *GLOBAL-TIMESTAMPS*))
    (CL:SETF (%DISJOINTNESS-CACHE-RECORD.DISJOINTNESS-CACHE-TABLE CACHE)
     (NEW-HASH-TABLE))
    (CL:SETF
     (%DISJOINTNESS-CACHE-RECORD.DISJOINTNESS-CACHE-TIMESTAMP CACHE)
     (%GLOBAL-TIMESTAMPS-RECORD.DISJOINTNESS-TIMESTAMP
      *GLOBAL-TIMESTAMPS*)))
   (INSERT-AT (%DISJOINTNESS-CACHE-RECORD.DISJOINTNESS-CACHE-TABLE CACHE)
    DESCRIPTION
    (CL:IF DISJOINT? KWD-CLASSIFY-DISJOINT KWD-CLASSIFY-NON-DISJOINT))))

(CL:DEFUN NEW-MARKER-TABLE ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-MARKER-TABLE))
   (CL:SETF (%MARKER-TABLE.SUPPORTS-RECALL? SELF) FALSE)
   (CL:SETF (%MARKER-TABLE.RECALL-TABLE SELF) NULL)
   (CL:SETF (%MARKER-TABLE.TEST-TABLE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF MARKER-TABLE))
  SGT-CLASSIFY-LOGIC-MARKER-TABLE)

(CL:DEFUN ACCESS-MARKER-TABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-TEST-TABLE)
    (CL:IF SETVALUE? (CL:SETF (%MARKER-TABLE.TEST-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%MARKER-TABLE.TEST-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-RECALL-TABLE)
    (CL:IF SETVALUE? (CL:SETF (%MARKER-TABLE.RECALL-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%MARKER-TABLE.RECALL-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-SUPPORTS-RECALL?)
    (CL:IF SETVALUE?
     (CL:SETF (%MARKER-TABLE.SUPPORTS-RECALL? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%MARKER-TABLE.SUPPORTS-RECALL? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (CREATE-MARKER-STORAGE MARKER-TABLE) ...)

(CL:DEFUN CREATE-MARKER-STORAGE (SUPPORTRECALL?)
  "Return a new marker storage object, used to
remember with objects have been 'marked'.  If 'supportRecall?'
is set, then the iterator 'recall-marked-objects' can be invoked
on the new marker storage object."
  (CL:LET* ((TABLE (NEW-MARKER-TABLE)))
   (CL:SETF (%MARKER-TABLE.TEST-TABLE TABLE) (NEW-HASH-TABLE))
   (CL:WHEN SUPPORTRECALL?
    (CL:SETF (%MARKER-TABLE.SUPPORTS-RECALL? TABLE) TRUE)
    (CL:SETF (%MARKER-TABLE.RECALL-TABLE TABLE) (NEW-LIST)))
   TABLE))

;;; (DEFMETHOD SET-MARKER ...)

(CL:DEFMETHOD SET-MARKER ((SELF MARKER-TABLE) OBJECT)
  "Record membership of 'object' in the marker
storage object 'self'."
  (CL:IF (%MARKER-TABLE.SUPPORTS-RECALL? SELF)
   (CL:WHEN (CL:EQ (LOOKUP (%MARKER-TABLE.TEST-TABLE SELF) OBJECT) NULL)
    (INSERT-AT (%MARKER-TABLE.TEST-TABLE SELF) OBJECT TRUE-WRAPPER)
    (PUSH (%MARKER-TABLE.RECALL-TABLE SELF) OBJECT))
   (INSERT-AT (%MARKER-TABLE.TEST-TABLE SELF) OBJECT TRUE-WRAPPER)))

;;; (DEFMETHOD (TEST-MARKER? BOOLEAN) ...)

(CL:DEFMETHOD TEST-MARKER? ((SELF MARKER-TABLE) OBJECT)
  "Return TRUE if 'object' is stored (marked) in 'self'."
  (CL:NOT (CL:EQ (LOOKUP (%MARKER-TABLE.TEST-TABLE SELF) OBJECT) NULL)))

;;; (DEFSPECIAL *SPECIALMARKERTABLE* ...)

(CL:DEFVAR *SPECIALMARKERTABLE*)

;;; (DEFUN (TEST-SPECIAL-MARKER-TABLE? BOOLEAN) ...)

(CL:DEFUN TEST-SPECIAL-MARKER-TABLE? (SELF)
  "Return TRUE if the object 'self' is stored (marked)
in the table pointed at by the special variable *specialMarkerTable*.
Designed for use by 'remove-if'."
  (TEST-MARKER? *SPECIALMARKERTABLE* SELF))

;;; (DEFMETHOD (RECALL-MARKED-OBJECTS LIST-ITERATOR) ...)

(CL:DEFMETHOD RECALL-MARKED-OBJECTS ((SELF MARKER-TABLE))
  "Return an iterator that generates all marked objects
recorded in 'self'."
  (ALLOCATE-ITERATOR (%MARKER-TABLE.RECALL-TABLE SELF)))

;;; (DEFUN (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN ALL-NAMED-DIRECT-SUPERDESCRIPTIONS (SELF REMOVEEQUIVALENTS?)
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((D NULL)
     (ITER-000 (ALL-DIRECT-SUPERCOLLECTIONS SELF REMOVEEQUIVALENTS?)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ D (%ITERATOR.VALUE ITER-000))
     (CL:WHEN (ISA? D SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION)
      (CL:SETQ RESULT (CONS D RESULT)))))
   RESULT))

;;; (DEFUN (ALL-NAMED-DIRECT-SUBDESCRIPTIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN ALL-NAMED-DIRECT-SUBDESCRIPTIONS (SELF)
  (CL:LET* ((RESULT NIL))
   (CL:LET* ((D NULL) (ITER-000 (ALL-DIRECT-SUBCOLLECTIONS SELF FALSE)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ D (%ITERATOR.VALUE ITER-000))
     (CL:WHEN (ISA? D SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION)
      (CL:SETQ RESULT (CONS D RESULT)))))
   RESULT))

;;; (DEFUN ADD-ISA-LINK ...)

(CL:DEFUN ADD-ISA-LINK (INSTANCE SUPERDESCRIPTION)
  (CL:LET*
   ((ISAPROP
     (ASSERT-ISA-PROPOSITION INSTANCE
      (%DESCRIPTION.SURROGATE-VALUE-INVERSE SUPERDESCRIPTION))))
   (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS ISAPROP)
    SYM-CLASSIFY-LOGIC-SUBSUMPTION-LINK?
    (CL:IF TRUE TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
   (CL:WHEN (TRACE-KEYWORD? KWD-CLASSIFY-CLASSIFIER-INFERENCES)
    (CL:LET* ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (CL:WHEN *EMIT-THINKING-DOTS?*
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Recognized type: " ISAPROP EOL)))))

;;; (DEFUN ADD-SUBSUMPTION-LINK ...)

(CL:DEFUN ADD-SUBSUMPTION-LINK (SUBDESCRIPTION SUPERDESCRIPTION)
  (CL:LET*
   ((IMPLIESPROP
     (ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION SUBDESCRIPTION
      SUPERDESCRIPTION FALSE)))
   (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS IMPLIESPROP)
    SYM-CLASSIFY-LOGIC-SUBSUMPTION-LINK?
    (CL:IF TRUE TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
   (CL:WHEN (TRACE-KEYWORD? KWD-CLASSIFY-CLASSIFIER-INFERENCES)
    (CL:LET* ((*INDENTCOUNTER* 4) (*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *INDENTCOUNTER* *PRINTREADABLY?*))
     (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
     (CL:WHEN *EMIT-THINKING-DOTS?*
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Recognized subsumption link:" EOL "    " IMPLIESPROP EOL))))
  (PUSH (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS SUPERDESCRIPTION)
   SUBDESCRIPTION)
  (CL:LET*
   ((P NULL)
    (ITER-000
     (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS SUPERDESCRIPTION FALSE)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ P (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:LET* ((SUBCOLLECTIONS (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS P)))
     (CL:SETF (%LIST.THE-CONS-LIST SUBCOLLECTIONS)
      (MOST-GENERAL-COLLECTIONS (%LIST.THE-CONS-LIST SUBCOLLECTIONS)))))))

;;; (DEFUN (MOST-SPECIFIC-COLLECTIONS (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN MOST-SPECIFIC-COLLECTIONS (DESCRIPTIONS)
  (CL:WHEN (CL:EQ (%%REST DESCRIPTIONS) NULL)
   (CL:RETURN-FROM MOST-SPECIFIC-COLLECTIONS DESCRIPTIONS))
  (CL:LET*
   ((CURSOR1 DESCRIPTIONS) (CURSOR2 NULL) (VALUE1 NULL) (VALUE2 NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR1 NIL)) DO
    (CL:SETQ VALUE1 (%%VALUE CURSOR1))
    (CL:WHEN (CL:NOT (CL:EQ (%%VALUE CURSOR1) NULL))
     (CL:SETQ CURSOR2 (%%REST CURSOR1))
     (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR2 NIL)) DO
      (CL:SETQ VALUE2 (%%VALUE CURSOR2))
      (CL:WHEN (CL:NOT (CL:EQ VALUE2 NULL))
       (CL:IF (COLLECTION-IMPLIES-COLLECTION? VALUE1 VALUE2)
        (CL:SETF (%%VALUE CURSOR2) NULL)
        (CL:WHEN (COLLECTION-IMPLIES-COLLECTION? VALUE2 VALUE1)
         (CL:SETF (%%VALUE CURSOR1) NULL) (CL:RETURN))))
      (CL:SETQ CURSOR2 (%%REST CURSOR2))))
    (CL:SETQ CURSOR1 (%%REST CURSOR1))))
  (CL:SETQ DESCRIPTIONS (REMOVE DESCRIPTIONS NULL))
  DESCRIPTIONS)

;;; (DEFUN (MOST-GENERAL-COLLECTIONS (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN MOST-GENERAL-COLLECTIONS (DESCRIPTIONS)
  (CL:WHEN (CL:EQ (%%REST DESCRIPTIONS) NULL)
   (CL:RETURN-FROM MOST-GENERAL-COLLECTIONS DESCRIPTIONS))
  (CL:LET*
   ((CURSOR1 DESCRIPTIONS) (CURSOR2 NULL) (VALUE1 NULL) (VALUE2 NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR1 NIL)) DO
    (CL:SETQ VALUE1 (%%VALUE CURSOR1))
    (CL:WHEN (CL:NOT (CL:EQ (%%VALUE CURSOR1) NULL))
     (CL:SETQ CURSOR2 (%%REST CURSOR1))
     (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR2 NIL)) DO
      (CL:SETQ VALUE2 (%%VALUE CURSOR2))
      (CL:WHEN (CL:NOT (CL:EQ VALUE2 NULL))
       (CL:IF (COLLECTION-IMPLIES-COLLECTION? VALUE2 VALUE1)
        (CL:SETF (%%VALUE CURSOR2) NULL)
        (CL:WHEN (COLLECTION-IMPLIES-COLLECTION? VALUE1 VALUE2)
         (CL:SETF (%%VALUE CURSOR1) NULL) (CL:RETURN))))
      (CL:SETQ CURSOR2 (%%REST CURSOR2))))
    (CL:SETQ CURSOR1 (%%REST CURSOR1))))
  (CL:SETQ DESCRIPTIONS (REMOVE DESCRIPTIONS NULL))
  DESCRIPTIONS)

;;; (DEFSPECIAL *FINDSUPERSANDSUBSDESCRIPTION* ...)

(CL:DEFVAR *FINDSUPERSANDSUBSDESCRIPTION* NULL
  "Points to a possibly unnamed description being
temporarily classified.")

;;; (DEFUN (NAMED-COLLECTION? BOOLEAN) ...)

(CL:DEFUN NAMED-COLLECTION? (SELF)
  (CL:OR
   (CL:NOT (CL:EQ (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE SELF) NULL))
   (CL:EQ SELF *FINDSUPERSANDSUBSDESCRIPTION*)))

;;; (DEFUN (MOST-SPECIFIC-NAMED-COLLECTIONS (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN MOST-SPECIFIC-NAMED-COLLECTIONS (DESCRIPTIONS)
  (CL:SETQ DESCRIPTIONS (MOST-SPECIFIC-COLLECTIONS DESCRIPTIONS))
  (CL:LET* ((RECOMPUTE? FALSE))
   (CL:LET* ((D NULL) (ITER-000 (COPY-CONS-LIST DESCRIPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ D (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (CL:NOT (NAMED-COLLECTION? D))
      (CL:SETQ DESCRIPTIONS (REMOVE DESCRIPTIONS D))
      (CL:LET*
       ((SUPER NULL) (ITER-001 (ALL-DIRECT-SUPERCOLLECTIONS D FALSE)))
       (CL:LOOP WHILE (NEXT? ITER-001) DO
        (CL:SETQ SUPER (%ITERATOR.VALUE ITER-001))
        (CL:SETQ DESCRIPTIONS (CONS SUPER DESCRIPTIONS))))
      (CL:SETQ RECOMPUTE? TRUE))))
   (CL:WHEN RECOMPUTE? (MOST-SPECIFIC-NAMED-COLLECTIONS DESCRIPTIONS))
   DESCRIPTIONS))

;;; (DEFUN (MOST-SPECIFIC-NAMED-DESCRIPTIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN MOST-SPECIFIC-NAMED-DESCRIPTIONS (DESCRIPTIONS)
  (CL:SETQ DESCRIPTIONS (MOST-SPECIFIC-COLLECTIONS DESCRIPTIONS))
  (CL:LET* ((RECOMPUTE? FALSE))
   (CL:LET* ((D NULL) (ITER-000 (COPY-CONS-LIST DESCRIPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ D (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (CL:NOT (NAMED-DESCRIPTION? D))
      (CL:SETQ DESCRIPTIONS (REMOVE DESCRIPTIONS D))
      (CL:LET*
       ((SUPER NULL) (ITER-001 (ALL-DIRECT-SUPERCOLLECTIONS D FALSE)))
       (CL:LOOP WHILE (NEXT? ITER-001) DO
        (CL:SETQ SUPER (%ITERATOR.VALUE ITER-001))
        (CL:SETQ DESCRIPTIONS (CONS SUPER DESCRIPTIONS))))
      (CL:SETQ RECOMPUTE? TRUE))))
   (CL:WHEN RECOMPUTE? (MOST-SPECIFIC-NAMED-COLLECTIONS DESCRIPTIONS))
   DESCRIPTIONS))

(CL:DEFUN NEW-CLASSIFICATION-CACHE ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-CLASSIFICATION-CACHE))
   (CL:SETF (%CLASSIFICATION-CACHE.INTRODUCTION-TIMESTAMP SELF) 0)
   (CL:SETF
    (%CLASSIFICATION-CACHE.CACHE-DOWNCLASSIFICATION-TIMESTAMP SELF) -1)
   (CL:SETF (%CLASSIFICATION-CACHE.CACHE-UPCLASSIFICATION-TIMESTAMP SELF)
    -1)
   (CL:SETF (%CLASSIFICATION-CACHE.INFERABLE-DIRECT-SUBDESCRIPTIONS SELF)
    NULL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CLASSIFICATION-CACHE))
  SGT-CLASSIFY-LOGIC-CLASSIFICATION-CACHE)

(CL:DEFUN ACCESS-CLASSIFICATION-CACHE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-INFERABLE-DIRECT-SUBDESCRIPTIONS)
    (CL:IF SETVALUE?
     (CL:SETF
      (%CLASSIFICATION-CACHE.INFERABLE-DIRECT-SUBDESCRIPTIONS SELF) VALUE)
     (CL:SETQ VALUE
      (%CLASSIFICATION-CACHE.INFERABLE-DIRECT-SUBDESCRIPTIONS SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-CACHE-UPCLASSIFICATION-TIMESTAMP)
    (CL:IF SETVALUE?
     (CL:SETF
      (%CLASSIFICATION-CACHE.CACHE-UPCLASSIFICATION-TIMESTAMP SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER
       (%CLASSIFICATION-CACHE.CACHE-UPCLASSIFICATION-TIMESTAMP SELF)))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-CACHE-DOWNCLASSIFICATION-TIMESTAMP)
    (CL:IF SETVALUE?
     (CL:SETF
      (%CLASSIFICATION-CACHE.CACHE-DOWNCLASSIFICATION-TIMESTAMP SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER
       (%CLASSIFICATION-CACHE.CACHE-DOWNCLASSIFICATION-TIMESTAMP SELF)))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-INTRODUCTION-TIMESTAMP)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASSIFICATION-CACHE.INTRODUCTION-TIMESTAMP SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER
       (%CLASSIFICATION-CACHE.INTRODUCTION-TIMESTAMP SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFUN NEW-CLASSIFICATION-SESSION ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-CLASSIFICATION-SESSION))
   (CL:SETF (%CLASSIFICATION-SESSION.LAST-CACHE-TABLE-VALUE SELF) NULL)
   (CL:SETF (%CLASSIFICATION-SESSION.LAST-CACHE-TABLE-KEY SELF) NULL)
   (CL:SETF (%CLASSIFICATION-SESSION.EVERYTHING-CLASSIFIED? SELF) FALSE)
   (CL:SETF (%CLASSIFICATION-SESSION.INTRODUCTION-TIMESTAMP-STACK SELF)
    (LIST (WRAP-INTEGER 0)))
   (CL:SETF (%CLASSIFICATION-SESSION.CLASSIFICATION-TIMECLOCK SELF) 0)
   (CL:SETF (%CLASSIFICATION-SESSION.CLASSIFICATION-CACHE-TABLE SELF)
    (NEW-HASH-TABLE))
   (CL:SETF (%CLASSIFICATION-SESSION.CLASSIFICATION-WORLD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CLASSIFICATION-SESSION))
  SGT-CLASSIFY-LOGIC-CLASSIFICATION-SESSION)

(CL:DEFUN ACCESS-CLASSIFICATION-SESSION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-CLASSIFICATION-WORLD)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASSIFICATION-SESSION.CLASSIFICATION-WORLD SELF) VALUE)
     (CL:SETQ VALUE (%CLASSIFICATION-SESSION.CLASSIFICATION-WORLD SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-CLASSIFICATION-CACHE-TABLE)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASSIFICATION-SESSION.CLASSIFICATION-CACHE-TABLE SELF)
      VALUE)
     (CL:SETQ VALUE
      (%CLASSIFICATION-SESSION.CLASSIFICATION-CACHE-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-CLASSIFICATION-TIMECLOCK)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASSIFICATION-SESSION.CLASSIFICATION-TIMECLOCK SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER
       (%CLASSIFICATION-SESSION.CLASSIFICATION-TIMECLOCK SELF)))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-INTRODUCTION-TIMESTAMP-STACK)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASSIFICATION-SESSION.INTRODUCTION-TIMESTAMP-STACK SELF)
      VALUE)
     (CL:SETQ VALUE
      (%CLASSIFICATION-SESSION.INTRODUCTION-TIMESTAMP-STACK SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-EVERYTHING-CLASSIFIED?)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASSIFICATION-SESSION.EVERYTHING-CLASSIFIED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CLASSIFICATION-SESSION.EVERYTHING-CLASSIFIED? SELF)
       TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-LAST-CACHE-TABLE-KEY)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASSIFICATION-SESSION.LAST-CACHE-TABLE-KEY SELF) VALUE)
     (CL:SETQ VALUE (%CLASSIFICATION-SESSION.LAST-CACHE-TABLE-KEY SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-LAST-CACHE-TABLE-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASSIFICATION-SESSION.LAST-CACHE-TABLE-VALUE SELF) VALUE)
     (CL:SETQ VALUE
      (%CLASSIFICATION-SESSION.LAST-CACHE-TABLE-VALUE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFSPECIAL *CLASSIFICATIONSESSION* ...)

(CL:DEFVAR *CLASSIFICATIONSESSION* NULL
  "Points to state of on-going classification session.")

;;; (DEFUN (GET-CLASSIFICATION-WORLD WORLD) ...)

(CL:DEFUN GET-CLASSIFICATION-WORLD ()
  (%CLASSIFICATION-SESSION.CLASSIFICATION-WORLD *CLASSIFICATIONSESSION*))

;;; (DEFUN (GET-CLASSIFICATION-SESSION CLASSIFICATION-SESSION) ...)

(CL:DEFUN GET-CLASSIFICATION-SESSION (INSTANCEORDESCRIPTION)
  (CL:WHEN (CL:NOT (CL:EQ *CLASSIFICATIONSESSION* NULL))
   (CL:RETURN-FROM GET-CLASSIFICATION-SESSION *CLASSIFICATIONSESSION*))
  (CL:LET* ((WORLD NULL) (SESSION NULL))
   (CL:COND
    ((CL:EQ INSTANCEORDESCRIPTION KWD-CLASSIFY-DESCRIPTION)
     (CL:SETQ WORLD (GET-INFERENCE-CACHE *MODULE* KWD-CLASSIFY-META)))
    ((CL:EQ INSTANCEORDESCRIPTION KWD-CLASSIFY-INSTANCE)
     (CL:SETQ WORLD (GET-INFERENCE-CACHE *MODULE* KWD-CLASSIFY-TMS)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
       INSTANCEORDESCRIPTION "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:SETQ SESSION
    (DYNAMIC-SLOT-VALUE (%WORLD.DYNAMIC-SLOTS WORLD)
     SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION NULL))
   (CL:WHEN (CL:EQ SESSION NULL)
    (CL:SETQ SESSION (NEW-CLASSIFICATION-SESSION))
    (SET-DYNAMIC-SLOT-VALUE (%WORLD.DYNAMIC-SLOTS WORLD)
     SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION SESSION NULL)
    (CL:SETF (%CLASSIFICATION-SESSION.CLASSIFICATION-WORLD SESSION)
     WORLD))
   SESSION))

;;; (DEFUN (GET-CLASSIFICATION-CACHE CLASSIFICATION-CACHE) ...)

(CL:DEFUN GET-CLASSIFICATION-CACHE (SELF)
  (CL:LET* ((SESSION *CLASSIFICATIONSESSION*) (CACHE NULL))
   (CL:WHEN
    (CL:EQ (%CLASSIFICATION-SESSION.LAST-CACHE-TABLE-KEY SESSION) SELF)
    (CL:RETURN-FROM GET-CLASSIFICATION-CACHE
     (%CLASSIFICATION-SESSION.LAST-CACHE-TABLE-VALUE SESSION)))
   (CL:SETQ CACHE
    (LOOKUP (%CLASSIFICATION-SESSION.CLASSIFICATION-CACHE-TABLE SESSION)
     SELF))
   (CL:WHEN (CL:EQ CACHE NULL) (CL:SETQ CACHE (NEW-CLASSIFICATION-CACHE))
    (INSERT-AT
     (%CLASSIFICATION-SESSION.CLASSIFICATION-CACHE-TABLE SESSION) SELF
     CACHE))
   (CL:SETF (%CLASSIFICATION-SESSION.LAST-CACHE-TABLE-KEY SESSION) SELF)
   (CL:SETF (%CLASSIFICATION-SESSION.LAST-CACHE-TABLE-VALUE SESSION)
    CACHE)
   CACHE))

;;; (DEFGLOBAL *CACHE-INFERABLE-SUBCOLLECTIONS?* ...)

(CL:DEFVAR *CACHE-INFERABLE-SUBCOLLECTIONS?* TRUE
  "If TRUE, prevents caching of computations of
all inferable subcollections of a collection.")

;;; (DEFUN (TOGGLE-INFERABLE-DIRECT-SUBCOLLECTIONS-CACHING STRING) ...)

(CL:DEFUN TOGGLE-INFERABLE-DIRECT-SUBCOLLECTIONS-CACHING ()
  (CL:SETQ *CACHE-INFERABLE-SUBCOLLECTIONS?*
   (CL:NOT *CACHE-INFERABLE-SUBCOLLECTIONS?*))
  (CL:IF *CACHE-INFERABLE-SUBCOLLECTIONS?*
   "Inferable subcollections caching enabled"
   "Inferable subcollections caching disabled"))

;;; (DEFUN (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS (LIST OF DESCRIPTION)) ...)

(CL:DEFUN ALL-INFERABLE-DIRECT-SUBCOLLECTIONS (SELF)
  (CL:LET*
   ((CACHE (GET-CLASSIFICATION-CACHE SELF))
    (LIST (%CLASSIFICATION-CACHE.INFERABLE-DIRECT-SUBDESCRIPTIONS CACHE)))
   (CL:WHEN
    (CL:OR (CL:EQ LIST NULL) (CL:NOT *CACHE-INFERABLE-SUBCOLLECTIONS?*))
    (CL:SETQ LIST (NEW-LIST))
    (CL:LET*
     ((SUB NULL) (ITER-000 (ALL-NAMED-DIRECT-SUBDESCRIPTIONS SELF)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:PROGN (CL:SETQ SUB (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (CL:WHEN (INFERABLE? SUB) (INSERT LIST SUB))))
    (CL:SETF
     (%CLASSIFICATION-CACHE.INFERABLE-DIRECT-SUBDESCRIPTIONS CACHE) LIST))
   LIST))

;;; (DEFUN FLUSH-INFERABLE-DIRECT-SUBDESCRIPTIONS-CACHE ...)

(CL:DEFUN FLUSH-INFERABLE-DIRECT-SUBDESCRIPTIONS-CACHE (IMPLIESPROPOSITION)
  (CL:WHEN (CL:EQ *CLASSIFICATIONSESSION* NULL)
   (CL:RETURN-FROM FLUSH-INFERABLE-DIRECT-SUBDESCRIPTIONS-CACHE))
  (CL:LET*
   ((CACHE
     (GET-CLASSIFICATION-CACHE
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS IMPLIESPROPOSITION)))
       1))))
   (CL:WHEN (CL:NOT (CL:EQ CACHE NULL))
    (CL:SETF
     (%CLASSIFICATION-CACHE.INFERABLE-DIRECT-SUBDESCRIPTIONS CACHE) NULL))))

;;; (DEFUN (CURRENT-CLASSIFICATION-TIME TIMESTAMP) ...)

(CL:DEFUN CURRENT-CLASSIFICATION-TIME ()
  (%CLASSIFICATION-SESSION.CLASSIFICATION-TIMECLOCK
   *CLASSIFICATIONSESSION*))

;;; (DEFUN (BUMP-CLASSIFICATION-TIMECLOCK TIMESTAMP) ...)

(CL:DEFUN BUMP-CLASSIFICATION-TIMECLOCK ()
  (CL:SETF
   (%CLASSIFICATION-SESSION.CLASSIFICATION-TIMECLOCK
    *CLASSIFICATIONSESSION*)
   (CL:1+
    (%CLASSIFICATION-SESSION.CLASSIFICATION-TIMECLOCK
     *CLASSIFICATIONSESSION*))))

;;; (DEFMETHOD (INTRODUCTION-TIMESTAMP TIMESTAMP) ...)

(CL:DEFMETHOD INTRODUCTION-TIMESTAMP ((SELF LOGIC-OBJECT))
  (%CLASSIFICATION-CACHE.INTRODUCTION-TIMESTAMP
   (GET-CLASSIFICATION-CACHE SELF)))

;;; (DEFUN INTRODUCE-INTO-CLASSIFICATION-SESSION ...)

(CL:DEFUN INTRODUCE-INTO-CLASSIFICATION-SESSION (SELF)
  (CL:LET*
   ((WORLD
     (DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS *MODULE*)
      SYM-CLASSIFY-LOGIC-META-INFERENCE-CACHE NULL)))
   (CL:WHEN
    (CL:OR (CL:EQ WORLD NULL)
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%WORLD.DYNAMIC-SLOTS WORLD)
       SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION NULL)
      NULL))
    (CL:RETURN-FROM INTRODUCE-INTO-CLASSIFICATION-SESSION))
   (CL:LET* ((NEWTIMESTAMP (BUMP-CLASSIFICATION-TIMECLOCK)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM NEWTIMESTAMP))
    (CL:SETF
     (%CLASSIFICATION-CACHE.INTRODUCTION-TIMESTAMP
      (GET-CLASSIFICATION-CACHE SELF))
     NEWTIMESTAMP)
    (PUSH
     (%CLASSIFICATION-SESSION.INTRODUCTION-TIMESTAMP-STACK
      *CLASSIFICATIONSESSION*)
     (WRAP-INTEGER NEWTIMESTAMP)))))

;;; (DEFUN (YOUNGEST-INTRODUCTION-TIMESTAMP INTEGER) ...)

(CL:DEFUN YOUNGEST-INTRODUCTION-TIMESTAMP ()
  (%INTEGER-WRAPPER.WRAPPER-VALUE
   (FIRST
    (%CLASSIFICATION-SESSION.INTRODUCTION-TIMESTAMP-STACK
     *CLASSIFICATIONSESSION*))))

;;; (DEFUN (UPCLASSIFICATION-TIMESTAMP INTEGER) ...)

(CL:DEFUN UPCLASSIFICATION-TIMESTAMP (SELF)
  (%CLASSIFICATION-CACHE.CACHE-UPCLASSIFICATION-TIMESTAMP
   (GET-CLASSIFICATION-CACHE SELF)))

;;; (DEFUN (DOWNCLASSIFICATION-TIMESTAMP INTEGER) ...)

(CL:DEFUN DOWNCLASSIFICATION-TIMESTAMP (SELF)
  (%CLASSIFICATION-CACHE.CACHE-DOWNCLASSIFICATION-TIMESTAMP
   (GET-CLASSIFICATION-CACHE SELF)))

;;; (DEFUN REFRESH-UPCLASSIFICATION-TIMESTAMP ...)

(CL:DEFUN REFRESH-UPCLASSIFICATION-TIMESTAMP (SELF)
  (CL:SETF
   (%CLASSIFICATION-CACHE.CACHE-UPCLASSIFICATION-TIMESTAMP
    (GET-CLASSIFICATION-CACHE SELF))
   (BUMP-CLASSIFICATION-TIMECLOCK)))

;;; (DEFUN REFRESH-DOWNCLASSIFICATION-TIMESTAMP ...)

(CL:DEFUN REFRESH-DOWNCLASSIFICATION-TIMESTAMP (SELF)
  (CL:SETF
   (%CLASSIFICATION-CACHE.CACHE-DOWNCLASSIFICATION-TIMESTAMP
    (GET-CLASSIFICATION-CACHE SELF))
   (BUMP-CLASSIFICATION-TIMECLOCK)))

;;; (DEFUN FLUSH-CLASSIFICATION-SESSIONS ...)

(CL:DEFUN FLUSH-CLASSIFICATION-SESSIONS ()
  (CL:LET*
   ((JITWORLD (LOOKUP-INFERENCE-CACHE *MODULE* KWD-CLASSIFY-JUST-IN-TIME))
    (METAWORLD (LOOKUP-INFERENCE-CACHE *MODULE* KWD-CLASSIFY-META))
    (TMSWORLD (LOOKUP-INFERENCE-CACHE *MODULE* KWD-CLASSIFY-TMS)))
   (CL:WHEN (CL:NOT (CL:EQ JITWORLD NULL))
    (SET-DYNAMIC-SLOT-VALUE (%WORLD.DYNAMIC-SLOTS JITWORLD)
     SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION NULL NULL))
   (CL:WHEN (CL:NOT (CL:EQ METAWORLD NULL))
    (SET-DYNAMIC-SLOT-VALUE (%WORLD.DYNAMIC-SLOTS METAWORLD)
     SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION NULL NULL))
   (CL:WHEN (CL:NOT (CL:EQ TMSWORLD NULL))
    (SET-DYNAMIC-SLOT-VALUE (%WORLD.DYNAMIC-SLOTS TMSWORLD)
     SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION NULL NULL))))

;;; (DEFUN (UPCLASSIFIED? BOOLEAN) ...)

(CL:DEFUN UPCLASSIFIED? (SELF)
  (> (UPCLASSIFICATION-TIMESTAMP SELF) (YOUNGEST-INTRODUCTION-TIMESTAMP)))

;;; (DEFUN (UPCLASSIFIED-LATER-THAN? BOOLEAN) ...)

(CL:DEFUN UPCLASSIFIED-LATER-THAN? (SELF OTHER)
  (> (UPCLASSIFICATION-TIMESTAMP SELF) (INTRODUCTION-TIMESTAMP OTHER)))

;;; (DEFUN (DOWNCLASSIFIED? BOOLEAN) ...)

(CL:DEFUN DOWNCLASSIFIED? (SELF)
  (CL:OR (NON-INFERABLE? SELF)
   (CL:> (DOWNCLASSIFICATION-TIMESTAMP SELF)
    (YOUNGEST-INTRODUCTION-TIMESTAMP))))

;;; (DEFUN MARK-UNMARKED-SUPERRELATIONS ...)

(CL:DEFUN MARK-UNMARKED-SUPERRELATIONS (DESCRIPTION SELFISBELOWTABLE)
  (SET-MARKER SELFISBELOWTABLE DESCRIPTION)
  (CL:LET*
   ((SUPER NULL)
    (ITER-000 (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS DESCRIPTION TRUE)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ SUPER (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (CL:NOT (TEST-MARKER? SELFISBELOWTABLE DESCRIPTION))
     (MARK-UNMARKED-SUPERRELATIONS SUPER SELFISBELOWTABLE)))))

;;; (DEFUN (APPLY-SUBSUMPTION-TEST? BOOLEAN) ...)

(CL:DEFUN APPLY-SUBSUMPTION-TEST? (SUBSUMPTIONTEST SELF SUPER)
  (CL:LET* ((RESULT? (CL:FUNCALL SUBSUMPTIONTEST SELF SUPER)))
   (CL:LET* ((TEST-VALUE-000 FALSE))
    (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL)))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((FOUND?-000 FALSE))
      (CL:LET*
       ((KWD NULL)
        (ITER-000
         (GET-QUOTED-TREE "((:CLASSIFIER :CLASSIFIER-PROFILE) \"/LOGIC\")"
          "/LOGIC")))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:PROGN (CL:SETQ KWD (%%VALUE ITER-000))
         (CL:SETQ ITER-000 (%%REST ITER-000)))
        (CL:WHEN (MEMB? *TRACED-KEYWORDS* KWD) (CL:SETQ FOUND?-000 TRUE)
         (CL:RETURN))))
      (CL:SETQ TEST-VALUE-000 FOUND?-000)))
    (CL:WHEN TEST-VALUE-000
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "   SPECIALIZES??:  " RESULT? "  self= " SELF "   super= " SUPER
      EOL)))
   RESULT?))

;;; (DEFUN (HELP-COLLECT-PARENTS-BELOW? BOOLEAN) ...)

(CL:DEFUN HELP-COLLECT-PARENTS-BELOW? (SELF SUPER NEWPARENTDESCRIPTIONS ALREADYVISITEDTABLE SELFISBELOWTABLE SUBSUMPTIONTEST)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "HELP-COLLECT-PARENTS-BELOW  self= " SELF "    super= " SUPER EOL))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "   TEST-MARKER of 'super': " (TEST-MARKER? SELFISBELOWTABLE SUPER)
    EOL))
  (CL:LET* ((FOUNDSUBSUMINGSUB? FALSE))
   (SET-MARKER ALREADYVISITEDTABLE SUPER)
   (CL:COND
    ((TEST-MARKER? SELFISBELOWTABLE SUPER)
     (CL:SETQ FOUNDSUBSUMINGSUB? TRUE)
     (CL:LET*
      ((SUB NULL)
       (ITER-000
        (%LIST.THE-CONS-LIST
         (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS SUPER))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ SUB (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:WHEN (CL:NOT (TEST-MARKER? ALREADYVISITEDTABLE SUB))
        (HELP-COLLECT-PARENTS-BELOW? SELF SUB NEWPARENTDESCRIPTIONS
         ALREADYVISITEDTABLE SELFISBELOWTABLE SUBSUMPTIONTEST)))))
    ((CL:AND (CL:NOT (UPCLASSIFIED-LATER-THAN? SELF SUPER))
      (APPLY-SUBSUMPTION-TEST? SUBSUMPTIONTEST SELF SUPER))
     (CL:SETQ FOUNDSUBSUMINGSUB? TRUE)
     (MARK-UNMARKED-SUPERRELATIONS SUPER SELFISBELOWTABLE)
     (CL:LET* ((FOUND?-000 FALSE))
      (CL:LET*
       ((SUB NULL)
        (ITER-001
         (%LIST.THE-CONS-LIST
          (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS SUPER))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:PROGN (CL:SETQ SUB (%%VALUE ITER-001))
         (CL:SETQ ITER-001 (%%REST ITER-001)))
        (CL:WHEN
         (CL:AND (CL:NOT (TEST-MARKER? ALREADYVISITEDTABLE SUB))
          (HELP-COLLECT-PARENTS-BELOW? SELF SUB NEWPARENTDESCRIPTIONS
           ALREADYVISITEDTABLE SELFISBELOWTABLE SUBSUMPTIONTEST))
         (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
      (CL:LET* ((EXISTSMORESPECIFICSUB? FOUND?-000))
       (CL:WHEN (CL:NOT EXISTSMORESPECIFICSUB?)
        (CL:LET* ((TEST-VALUE-000 FALSE))
         (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL)))
         (CL:WHEN TEST-VALUE-000
          (CL:LET* ((FOUND?-001 FALSE))
           (CL:LET*
            ((KWD NULL)
             (ITER-002
              (GET-QUOTED-TREE
               "((:CLASSIFIER :CLASSIFIER-PROFILE) \"/LOGIC\")"
               "/LOGIC")))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
             (CL:PROGN (CL:SETQ KWD (%%VALUE ITER-002))
              (CL:SETQ ITER-002 (%%REST ITER-002)))
             (CL:WHEN (MEMB? *TRACED-KEYWORDS* KWD)
              (CL:SETQ FOUND?-001 TRUE) (CL:RETURN))))
           (CL:SETQ TEST-VALUE-000 FOUND?-001)))
         (CL:WHEN TEST-VALUE-000
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
           EOL "XXXXXXX PUSHING NEW PARENT: " SUPER "  of " SELF EOL
           EOL)))
        (PUSH NEWPARENTDESCRIPTIONS SUPER)))))
    (CL:T))
   FOUNDSUBSUMINGSUB?))

;;; (DEFUN COLLECT-SUBSUMING-PARENTS-BELOW ...)

(CL:DEFUN COLLECT-SUBSUMING-PARENTS-BELOW (SELF SUPER NEWPARENTDESCRIPTIONS ALREADYVISITEDTABLE SELFISBELOWTABLE SUBSUMPTIONTEST)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "COLLECT-SUBSUMING  self= " SELF "    super= " SUPER EOL))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "   ALL-INFERABLE-SUBS:  "
    (CONS-LIST (LISTIFY (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS SUPER))) EOL))
  (CL:LET* ((*REVERSEPOLARITY?* FALSE))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (CL:LET*
    ((SUB NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS SUPER))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ SUB (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (CL:NOT (TEST-MARKER? ALREADYVISITEDTABLE SUB))
      (HELP-COLLECT-PARENTS-BELOW? SELF SUB NEWPARENTDESCRIPTIONS
       ALREADYVISITEDTABLE SELFISBELOWTABLE SUBSUMPTIONTEST))))))

;;; (DEFUN (ALL-ANCESTORS-OF-PARENTS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-ANCESTORS-OF-PARENTS (SUPERS)
  (CL:LET* ((COLLECTION (COPY-CONS-LIST SUPERS)))
   (CL:LET* ((S NULL) (ITER-000 SUPERS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ S (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:LET* ((A NULL) (ITER-001 (ALL-SUPERCOLLECTIONS S)))
      (CL:LOOP WHILE (NEXT? ITER-001) DO
       (CL:SETQ A (%ITERATOR.VALUE ITER-001))
       (CL:WHEN (CL:NOT (MEMBER? SUPERS A))
        (CL:SETQ COLLECTION (CONS A COLLECTION)))))))
   (ALLOCATE-ITERATOR COLLECTION)))

;;; (DEFUN (ALL-ANCESTOR-COLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-ANCESTOR-COLLECTIONS (SELF INSTANCEORDESCRIPTION)
  (CL:COND
   ((CL:EQ INSTANCEORDESCRIPTION KWD-CLASSIFY-INSTANCE)
    (ALL-ANCESTORS-OF-PARENTS (ALL-ISA-COLLECTIONS SELF)))
   ((CL:EQ INSTANCEORDESCRIPTION KWD-CLASSIFY-DESCRIPTION)
    (ALL-SUPERCOLLECTIONS SELF))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      INSTANCEORDESCRIPTION "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN HELP-UPCLASSIFY-ONE-ENTITY ...)

(CL:DEFUN HELP-UPCLASSIFY-ONE-ENTITY (SELF INSTANCEORDESCRIPTION)
  (CL:WHEN (UPCLASSIFIED? SELF)
   (CL:RETURN-FROM HELP-UPCLASSIFY-ONE-ENTITY))
  (CL:LET*
   ((ALREADYVISITEDTABLE (CREATE-MARKER-STORAGE FALSE))
    (INSTANCEISBELOWTABLE (CREATE-MARKER-STORAGE FALSE))
    (NEWPARENTDESCRIPTIONS (NEW-LIST)))
   (SET-MARKER INSTANCEISBELOWTABLE SELF)
   (CL:LET*
    ((SUPER NULL)
     (ITER-000 (ALL-ANCESTOR-COLLECTIONS SELF INSTANCEORDESCRIPTION)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ SUPER (%ITERATOR.VALUE ITER-000))
     (SET-MARKER INSTANCEISBELOWTABLE SUPER)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "   WORLD: " *CONTEXT* "  self: " SELF EOL "   ANCESTORS: "
     (LISTIFY (ALL-ANCESTOR-COLLECTIONS SELF INSTANCEORDESCRIPTION)) EOL))
   (CL:LET*
    ((SUPER NULL)
     (ITER-001 (ALL-ANCESTOR-COLLECTIONS SELF INSTANCEORDESCRIPTION)))
    (CL:LOOP WHILE (NEXT? ITER-001) DO
     (CL:SETQ SUPER (%ITERATOR.VALUE ITER-001))
     (CL:WHEN
      (CL:AND (ISA? SUPER SGT-CLASSIFY-LOGIC-DESCRIPTION)
       (NON-INFERABLE? SUPER)
       (CL:NOT (TEST-MARKER? ALREADYVISITEDTABLE SUPER)))
      (SET-MARKER ALREADYVISITEDTABLE SUPER)
      (COLLECT-SUBSUMING-PARENTS-BELOW SELF SUPER NEWPARENTDESCRIPTIONS
       ALREADYVISITEDTABLE INSTANCEISBELOWTABLE
       (CL:IF (CL:EQ INSTANCEORDESCRIPTION KWD-CLASSIFY-INSTANCE)
        (CL:FUNCTION INSTANCE-SATISFIES-DESCRIPTION?)
        (CL:FUNCTION DESCRIPTION-SPECIALIZES-DESCRIPTION?))))))
   (CL:LET*
    ((PD NULL)
     (ITER-002
      (MOST-SPECIFIC-NAMED-COLLECTIONS
       (%LIST.THE-CONS-LIST NEWPARENTDESCRIPTIONS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:PROGN (CL:SETQ PD (%%VALUE ITER-002))
      (CL:SETQ ITER-002 (%%REST ITER-002)))
     (CL:COND
      ((CL:EQ INSTANCEORDESCRIPTION KWD-CLASSIFY-INSTANCE)
       (ADD-ISA-LINK SELF PD))
      ((CL:EQ INSTANCEORDESCRIPTION KWD-CLASSIFY-DESCRIPTION)
       (ADD-SUBSUMPTION-LINK SELF PD))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "`" INSTANCEORDESCRIPTION "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
   (REFRESH-UPCLASSIFICATION-TIMESTAMP SELF)))

;;; (DEFUN UPCLASSIFY-ONE-INSTANCE ...)

(CL:DEFUN UPCLASSIFY-ONE-INSTANCE (SELF)
  (CL:WHEN (UPCLASSIFIED? SELF) (CL:RETURN-FROM UPCLASSIFY-ONE-INSTANCE))
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL)))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((FOUND?-000 FALSE))
     (CL:LET*
      ((KWD NULL)
       (ITER-000
        (GET-QUOTED-TREE "((:CLASSIFIER :CLASSIFIER-PROFILE) \"/LOGIC\")"
         "/LOGIC")))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ KWD (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:WHEN (MEMB? *TRACED-KEYWORDS* KWD) (CL:SETQ FOUND?-000 TRUE)
        (CL:RETURN))))
     (CL:SETQ TEST-VALUE-000 FOUND?-000)))
   (CL:WHEN TEST-VALUE-000
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "UPCLASSIFY:  " SELF EOL)))
  (EMIT-THINKING-DOT KWD-CLASSIFY-UPCLASSIFY)
  (HELP-UPCLASSIFY-ONE-ENTITY SELF KWD-CLASSIFY-INSTANCE))

;;; (DEFUN UPCLASSIFY-ONE-DESCRIPTION ...)

(CL:DEFUN UPCLASSIFY-ONE-DESCRIPTION (SELF)
  (CL:WHEN
   (CL:OR (UPCLASSIFIED? SELF)
    (CL:NOT (ISA? SELF SGT-CLASSIFY-LOGIC-DESCRIPTION)))
   (CL:RETURN-FROM UPCLASSIFY-ONE-DESCRIPTION))
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL)))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((FOUND?-000 FALSE))
     (CL:LET*
      ((KWD NULL)
       (ITER-000
        (GET-QUOTED-TREE "((:CLASSIFIER :CLASSIFIER-PROFILE) \"/LOGIC\")"
         "/LOGIC")))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ KWD (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:WHEN (MEMB? *TRACED-KEYWORDS* KWD) (CL:SETQ FOUND?-000 TRUE)
        (CL:RETURN))))
     (CL:SETQ TEST-VALUE-000 FOUND?-000)))
   (CL:WHEN TEST-VALUE-000
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "UPCLASSIFY: " SELF EOL)))
  (EMIT-THINKING-DOT KWD-CLASSIFY-UPCLASSIFY)
  (CL:LET* ((EQUIVALENTS (ALL-EQUIVALENT-COLLECTIONS SELF TRUE)))
   (CL:LET* ((E NULL) (ITER-001 EQUIVALENTS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ E (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:WHEN (CL:NOT (NAMED-DESCRIPTION? E))
      (CL:LET*
       ((PD NULL)
        (ITER-002 (%LIST.THE-CONS-LIST (ALL-INTENSIONAL-PARENTS E))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:PROGN (CL:SETQ PD (%%VALUE ITER-002))
         (CL:SETQ ITER-002 (%%REST ITER-002)))
        (ADD-SUBSUMPTION-LINK SELF PD)))))))
  (CL:LET*
   ((SUPER NULL)
    (ITER-003 (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS SELF TRUE)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
    (CL:PROGN (CL:SETQ SUPER (%%VALUE ITER-003))
     (CL:SETQ ITER-003 (%%REST ITER-003)))
    (UPCLASSIFY-ONE-DESCRIPTION SUPER)))
  (HELP-UPCLASSIFY-ONE-ENTITY SELF KWD-CLASSIFY-DESCRIPTION))

;;; (DEFUN HELP-DOWNCLASSIFY-ONE-DESCRIPTION ...)

(CL:DEFUN HELP-DOWNCLASSIFY-ONE-DESCRIPTION (NODE SELF NECESSARYANCESTORS ALREADYVISITEDTABLE)
  (CL:WHEN
   (CL:OR (TEST-MARKER? ALREADYVISITEDTABLE NODE)
    (DESCRIPTION-IMPLIES-DESCRIPTION? NODE SELF))
   (CL:RETURN-FROM HELP-DOWNCLASSIFY-ONE-DESCRIPTION))
  (SET-MARKER ALREADYVISITEDTABLE NODE)
  (CL:LET* ((NODECOULDBETHEONE? TRUE))
   (CL:COND
    ((CL:= (UPCLASSIFICATION-TIMESTAMP NODE) -1)
     (UPCLASSIFY-ONE-DESCRIPTION NODE))
    ((CL:NOT (UPCLASSIFIED-LATER-THAN? NODE SELF))
     (CL:LET* ((FOUND?-000 FALSE))
      (CL:LET* ((ANCESTOR NULL) (ITER-000 NECESSARYANCESTORS))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:PROGN (CL:SETQ ANCESTOR (%%VALUE ITER-000))
         (CL:SETQ ITER-000 (%%REST ITER-000)))
        (CL:WHEN
         (CL:AND (UPCLASSIFIED-LATER-THAN? NODE ANCESTOR)
          (CL:NOT (DESCRIPTION-IMPLIES-DESCRIPTION? NODE ANCESTOR)))
         (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
      (CL:IF FOUND?-000 (CL:SETQ NODECOULDBETHEONE? FALSE)
       (UPCLASSIFY-ONE-DESCRIPTION NODE)))))
   (CL:WHEN
    (CL:AND NODECOULDBETHEONE?
     (DESCRIPTION-IMPLIES-DESCRIPTION? NODE SELF))
    (CL:RETURN-FROM HELP-DOWNCLASSIFY-ONE-DESCRIPTION))
   (CL:LET*
    ((SUBNODE NULL) (ITER-001 (ALL-NAMED-DIRECT-SUBDESCRIPTIONS NODE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ SUBNODE (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (HELP-DOWNCLASSIFY-ONE-DESCRIPTION SUBNODE SELF NECESSARYANCESTORS
      ALREADYVISITEDTABLE)))))

;;; (DEFUN (COLLECTION-WITH-FEWEST-CHILDREN LOGIC-OBJECT) ...)

(CL:DEFUN COLLECTION-WITH-FEWEST-CHILDREN (COLLECTIONS)
  (CL:WHEN (CL:EQ (%%REST COLLECTIONS) NULL)
   (CL:RETURN-FROM COLLECTION-WITH-FEWEST-CHILDREN (%%VALUE COLLECTIONS)))
  (CL:LET* ((BESTCOLLECTION (%%VALUE COLLECTIONS)) (LOWESTCHILDCOUNT 100))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LOWESTCHILDCOUNT))
   (CL:LET* ((C NULL) (ITER-000 COLLECTIONS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ C (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:LET* ((CHILDCOUNT 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM CHILDCOUNT))
      (CL:LET*
       ((P
         (ALLOCATE-ITERATOR
          (APPLICABLE-RULES-OF-DESCRIPTION C KWD-CLASSIFY-BACKWARD
           TRUE))))
       (CL:LOOP WHILE (NEXT? P) DO
        (CL:SETQ CHILDCOUNT (CL:1+ CHILDCOUNT))))
      (CL:WHEN (CL:< CHILDCOUNT LOWESTCHILDCOUNT)
       (CL:SETQ BESTCOLLECTION C)
       (CL:SETQ LOWESTCHILDCOUNT CHILDCOUNT)))))
   BESTCOLLECTION))

;;; (DEFUN (CHOOSE-BEST-DOWNCLASSIFIED-PARENT LOGIC-OBJECT) ...)

(CL:DEFUN CHOOSE-BEST-DOWNCLASSIFIED-PARENT (PARENTS)
  (CL:WHEN (CL:EQ PARENTS NIL)
   (CL:RETURN-FROM CHOOSE-BEST-DOWNCLASSIFIED-PARENT NULL))
  (CL:LET* ((DOWNCLASSIFIEDPARENTS NIL) (BESTPARENT NULL))
   (CL:LET* ((P NULL) (ITER-000 PARENTS) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ P (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (DOWNCLASSIFIED? P) (CL:PROGN)
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS P NIL))
        (CL:IF (CL:EQ DOWNCLASSIFIEDPARENTS NIL)
         (CL:SETQ DOWNCLASSIFIEDPARENTS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST DOWNCLASSIFIEDPARENTS
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS P NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:CASE (LENGTH DOWNCLASSIFIEDPARENTS)
    (0
     (CL:LET* ((NAMEDPARENTS NIL))
      (CL:LET* ((P NULL) (ITER-001 PARENTS) (COLLECT-001 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:PROGN (CL:SETQ P (%%VALUE ITER-001))
         (CL:SETQ ITER-001 (%%REST ITER-001)))
        (CL:WHEN (NAMED-DESCRIPTION? P)
         (CL:IF (CL:EQ COLLECT-001 NULL)
          (CL:PROGN (CL:SETQ COLLECT-001 (CONS P NIL))
           (CL:IF (CL:EQ NAMEDPARENTS NIL)
            (CL:SETQ NAMEDPARENTS COLLECT-001)
            (ADD-CONS-TO-END-OF-CONS-LIST NAMEDPARENTS COLLECT-001)))
          (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS P NIL))
           (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))))
      (CL:WHEN (CL:NOT (CL:EQ NAMEDPARENTS NIL))
       (CL:SETQ BESTPARENT
        (COLLECTION-WITH-FEWEST-CHILDREN NAMEDPARENTS)))
      (CL:WHEN (CL:EQ BESTPARENT NULL)
       (CL:SETQ BESTPARENT (COLLECTION-WITH-FEWEST-CHILDREN PARENTS)))
      (DOWNCLASSIFY-ONE-DESCRIPTION BESTPARENT)))
    (1 (CL:SETQ BESTPARENT (%%VALUE DOWNCLASSIFIEDPARENTS)))
    (CL:OTHERWISE
     (CL:SETQ BESTPARENT
      (COLLECTION-WITH-FEWEST-CHILDREN DOWNCLASSIFIEDPARENTS))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "   BEST PARENT:   " BESTPARENT "   ALL-PARENTS: " PARENTS EOL))
   BESTPARENT))

;;; (DEFUN DOWNCLASSIFY-ONE-DESCRIPTION ...)

(CL:DEFUN DOWNCLASSIFY-ONE-DESCRIPTION (SELF)
  (CL:LET*
   ((*CLASSIFICATIONSESSION*
     (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-DESCRIPTION)))
   (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION*))
   (CL:WHEN (CL:NOT (DOWNCLASSIFIED? SELF))
    (CL:WHEN (NON-INFERABLE? SELF)
     (REFRESH-DOWNCLASSIFICATION-TIMESTAMP SELF)
     (CL:RETURN-FROM DOWNCLASSIFY-ONE-DESCRIPTION))
    (CL:LET* ((TEST-VALUE-000 FALSE))
     (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL)))
     (CL:WHEN TEST-VALUE-000
      (CL:LET* ((FOUND?-000 FALSE))
       (CL:LET*
        ((KWD NULL)
         (ITER-000
          (GET-QUOTED-TREE
           "((:CLASSIFIER :CLASSIFIER-PROFILE) \"/LOGIC\")" "/LOGIC")))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:PROGN (CL:SETQ KWD (%%VALUE ITER-000))
          (CL:SETQ ITER-000 (%%REST ITER-000)))
         (CL:WHEN (MEMB? *TRACED-KEYWORDS* KWD) (CL:SETQ FOUND?-000 TRUE)
          (CL:RETURN))))
       (CL:SETQ TEST-VALUE-000 FOUND?-000)))
     (CL:WHEN TEST-VALUE-000
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "DOWNCLASSIFY-ONE-DESCRIPTION:  " SELF EOL)))
    (EMIT-THINKING-DOT KWD-CLASSIFY-DOWNCLASSIFY)
    (CL:LET*
     ((ALREADYVISITEDTABLE (CREATE-MARKER-STORAGE FALSE))
      (PARENTS (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS SELF FALSE))
      (BESTPARENT (CHOOSE-BEST-DOWNCLASSIFIED-PARENT PARENTS))
      (OTHERPARENTS (REMOVE PARENTS BESTPARENT)))
     (SET-MARKER ALREADYVISITEDTABLE SELF)
     (CL:WHEN (CL:NOT (CL:EQ BESTPARENT NULL))
      (CL:LET*
       ((CHILD NULL)
        (ITER-001 (ALL-NAMED-DIRECT-SUBDESCRIPTIONS BESTPARENT)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:PROGN (CL:SETQ CHILD (%%VALUE ITER-001))
         (CL:SETQ ITER-001 (%%REST ITER-001)))
        (HELP-DOWNCLASSIFY-ONE-DESCRIPTION CHILD SELF OTHERPARENTS
         ALREADYVISITEDTABLE)))))
    (REFRESH-DOWNCLASSIFICATION-TIMESTAMP SELF))))

;;; (DEFMETHOD (VIRGIN? BOOLEAN) ...)

(CL:DEFMETHOD VIRGIN? ((SELF DESCRIPTION))
  (CL:AND (EMPTY? (UNFILTERED-DEPENDENT-PROPOSITIONS SELF NULL))
   (CL:NOT (NAMED-COLLECTION? SELF))))

;;; (DEFUN EVAPORATE-VIRGIN ...)

(CL:DEFUN EVAPORATE-VIRGIN (SELF)
  (CL:LET*
   ((PARENTIMPLIES (NEW-LIST)) (CHILDIMPLIES (NEW-LIST)) (PARENT NULL)
    (CHILD NULL) (BRIDGEPROP NULL))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALLOCATE-ITERATOR (UNFILTERED-DEPENDENT-PROPOSITIONS SELF NULL))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ P (%ITERATOR.VALUE ITER-000))
     (CL:IF
      (CL:EQ
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
        0)
       SELF)
      (PUSH PARENTIMPLIES P) (PUSH CHILDIMPLIES P))))
   (CL:LET* ((CP NULL) (ITER-001 (%LIST.THE-CONS-LIST CHILDIMPLIES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ CP (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:SETQ CHILD
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS CP)))
       0))
     (CL:LET* ((PP NULL) (ITER-002 (%LIST.THE-CONS-LIST PARENTIMPLIES)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:PROGN (CL:SETQ PP (%%VALUE ITER-002))
        (CL:SETQ ITER-002 (%%REST ITER-002)))
       (CL:SETQ PARENT
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PP)))
         1))
       (CL:SETQ BRIDGEPROP
        (ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION CHILD PARENT TRUE))
       (CL:WHEN
        (CL:AND
         (%BOOLEAN-WRAPPER.WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS CP)
           SYM-CLASSIFY-LOGIC-SUBRELATION-LINK? FALSE-WRAPPER))
         (%BOOLEAN-WRAPPER.WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PP)
           SYM-CLASSIFY-LOGIC-SUBRELATION-LINK? FALSE-WRAPPER)))
        (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS BRIDGEPROP)
         SYM-CLASSIFY-LOGIC-SUBRELATION-LINK?
         (CL:IF TRUE TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
       (UPDATE-PROPOSITION-TRUTH-VALUE BRIDGEPROP
        KWD-CLASSIFY-ASSERT-TRUE)))))
   (CL:LET*
    ((P NULL)
     (ITER-003
      (ALLOCATE-ITERATOR (UNFILTERED-DEPENDENT-PROPOSITIONS SELF NULL))))
    (CL:LOOP WHILE (NEXT? ITER-003) DO
     (CL:SETQ P (%ITERATOR.VALUE ITER-003)) (DESTROY-PROPOSITION P)))))

;;; (DEFUN (FIND-DIRECT-SUPERS-AND-SUBS (CONS OF DESCRIPTION) (CONS OF DESCRIPTION) (CONS OF DESCRIPTION)) ...)

(CL:DEFUN FIND-DIRECT-SUPERS-AND-SUBS (SELF ONLYSUPERS?)
  "Classify 'self' and return three values, its direct
supers, direct subs, and a list of equivalent descriptions.
Setting 'supersOnly?' may speed up the computation (perhaps by a lot).
If 'description' is nameless and has no dependent propositions, then
it is automatically removed from the hierarchy after classification."
  (FINALIZE-RELATIONS)
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:RETURN-FROM FIND-DIRECT-SUPERS-AND-SUBS (CL:VALUES NIL NIL NIL)))
  (CL:LET* ((*FINDSUPERSANDSUBSDESCRIPTION* SELF))
   (CL:DECLARE (CL:SPECIAL *FINDSUPERSANDSUBSDESCRIPTION*))
   (CL:LET*
    ((*CLASSIFICATIONSESSION*
      (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-DESCRIPTION))
     (*CONTEXT*
      (%CLASSIFICATION-SESSION.CLASSIFICATION-WORLD
       *CLASSIFICATIONSESSION*)))
    (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION* *CONTEXT*))
    (CL:LET*
     ((VIRGIN? (VIRGIN? SELF))
      (OLDCURRENTTIME (CURRENT-CLASSIFICATION-TIME)) (SUPERS NIL)
      (SUBS NIL) (EQUIVALENTS NIL))
     (CL:DECLARE (CL:TYPE CL:FIXNUM OLDCURRENTTIME))
     (CL:WHEN VIRGIN? (INTRODUCE-INTO-CLASSIFICATION-SESSION SELF))
     (UPCLASSIFY-ONE-DESCRIPTION SELF)
     (CL:LET*
      ((SUPER NULL)
       (ITER-000 (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS SELF FALSE)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ SUPER (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (UPCLASSIFY-ONE-DESCRIPTION SUPER)))
     (CL:SETQ SUPERS (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS SELF TRUE))
     (CL:WHEN (CL:NOT ONLYSUPERS?) (DOWNCLASSIFY-ONE-DESCRIPTION SELF)
      (CL:SETQ SUBS (CONSIFY (ALL-DIRECT-SUBCOLLECTIONS SELF TRUE))))
     (CL:LET*
      ((E NULL) (ITER-001 (ALL-EQUIVALENT-COLLECTIONS SELF FALSE))
       (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:PROGN (CL:SETQ E (%%VALUE ITER-001))
        (CL:SETQ ITER-001 (%%REST ITER-001)))
       (CL:WHEN (NAMED-DESCRIPTION? E)
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS E NIL))
          (CL:IF (CL:EQ EQUIVALENTS NIL) (CL:SETQ EQUIVALENTS COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST EQUIVALENTS COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS E NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
     (CL:WHEN VIRGIN? (EVAPORATE-VIRGIN SELF)
      (POP
       (%CLASSIFICATION-SESSION.INTRODUCTION-TIMESTAMP-STACK
        *CLASSIFICATIONSESSION*)))
     (CL:VALUES SUPERS SUBS EQUIVALENTS)))))

;;; (DEFUN (FIND-DIRECT-SUPERS-OF-INSTANCE (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN FIND-DIRECT-SUPERS-OF-INSTANCE (SELF)
  "Classify 'self' and return a list of most specific 
named descriptions among all descriptions that it satisfies."
  (FINALIZE-RELATIONS)
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:RETURN-FROM FIND-DIRECT-SUPERS-OF-INSTANCE NIL))
  (CL:LET*
   ((*CLASSIFICATIONSESSION*
     (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-INSTANCE))
    (*CONTEXT*
     (%CLASSIFICATION-SESSION.CLASSIFICATION-WORLD
      *CLASSIFICATIONSESSION*)))
   (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION* *CONTEXT*))
   (UPCLASSIFY-ONE-INSTANCE SELF)
   (MOST-SPECIFIC-NAMED-COLLECTIONS (ALL-ISA-COLLECTIONS SELF))))

;;; (DEFUN UPCLASSIFY-NAMED-DESCRIPTIONS ...)

(CL:DEFUN UPCLASSIFY-NAMED-DESCRIPTIONS (MODULE LOCAL?)
  "Classify named descriptions local to 'module' and inherited
by 'module'.  If 'local?', don't classify inherited descriptions.  If
'module' is NULL, classify descriptions in all modules."
  (CL:LET*
   ((*CLASSIFICATIONSESSION*
     (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-DESCRIPTION))
    (*CONTEXT*
     (%CLASSIFICATION-SESSION.CLASSIFICATION-WORLD
      *CLASSIFICATIONSESSION*)))
   (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION* *CONTEXT*))
   (CL:LET*
    ((*MODULE* (CL:IF (CL:EQ MODULE NULL) *MODULE* MODULE))
     (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:COND ((CL:EQ MODULE NULL) (UPCLASSIFY-ALL-DESCRIPTIONS))
     (LOCAL?
      (CL:LET* ((D NULL) (ITER-000 (ALL-NAMED-DESCRIPTIONS MODULE TRUE)))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ D (%ITERATOR.VALUE ITER-000))
        (UPCLASSIFY-ONE-DESCRIPTION D))))
     (CL:T
      (CL:LET* ((SESSION *CLASSIFICATIONSESSION*))
       (CL:WHEN
        (CL:NOT (%CLASSIFICATION-SESSION.EVERYTHING-CLASSIFIED? SESSION))
        (CL:LET* ((M NULL) (ITER-001 (ALL-INCLUDED-MODULES MODULE)))
         (CL:LOOP WHILE (NEXT? ITER-001) DO
          (CL:SETQ M (%ITERATOR.VALUE ITER-001))
          (CL:LET* ((D NULL) (ITER-002 (ALL-NAMED-DESCRIPTIONS M TRUE)))
           (CL:LOOP WHILE (NEXT? ITER-002) DO
            (CL:SETQ D (%ITERATOR.VALUE ITER-002))
            (UPCLASSIFY-ONE-DESCRIPTION D)))))
        (CL:SETF (%CLASSIFICATION-SESSION.EVERYTHING-CLASSIFIED? SESSION)
         TRUE))))))))

;;; (DEFUN CLASSIFY-RELATIONS ...)

(CL:DEFUN %CLASSIFY-RELATIONS (MODULE LOCAL?)
  "Classify named relations visible in `module'.
If `local?', don't classify inherited descriptions.  If `module' is
NULL, classify relations in all modules."
  (CL:LET* ((THEMODULE (COERCE-TO-MODULE MODULE TRUE)))
   (CL:WHEN (CL:NOT (CL:EQ THEMODULE NULL))
    (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ THEMODULE NULL))
    (UPCLASSIFY-NAMED-DESCRIPTIONS THEMODULE LOCAL?))))

(CL:DEFUN CLASSIFY-RELATIONS-EVALUATOR-WRAPPER (ARGUMENTS)
  (%CLASSIFY-RELATIONS (%%VALUE ARGUMENTS)
   (%BOOLEAN-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO CLASSIFY-RELATIONS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Classify named relations visible in `module'.
If `local?', don't classify inherited descriptions.  If `module' is
NULL, classify relations in all modules."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/CLASSIFY-RELATIONS)) (CL:MACRO-FUNCTION (CL:QUOTE CLASSIFY-RELATIONS)))

;;; (DEFUN UPCLASSIFY-INSTANCES ...)

(CL:DEFUN UPCLASSIFY-INSTANCES (MODULE LOCAL?)
  "Classify instances local to 'module' and inherited
by 'module'.  If 'local?', don't classify inherited descriptions.  If
'module' is NULL, classify descriptions in all modules."
  (CL:LET*
   ((*CLASSIFICATIONSESSION*
     (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-DESCRIPTION))
    (*CONTEXT*
     (%CLASSIFICATION-SESSION.CLASSIFICATION-WORLD
      *CLASSIFICATIONSESSION*)))
   (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION* *CONTEXT*))
   (CL:LET*
    ((*MODULE* (CL:IF (CL:EQ MODULE NULL) *MODULE* MODULE))
     (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:COND ((CL:EQ MODULE NULL) (UPCLASSIFY-ALL-INSTANCES))
     (LOCAL?
      (CL:LET* ((I NULL) (ITER-000 (ALL-INSTANCES MODULE TRUE)))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ I (%ITERATOR.VALUE ITER-000))
        (UPCLASSIFY-ONE-INSTANCE I))))
     (CL:T
      (CL:LET* ((M NULL) (ITER-001 (ALL-INCLUDED-MODULES MODULE)))
       (CL:LOOP WHILE (NEXT? ITER-001) DO
        (CL:SETQ M (%ITERATOR.VALUE ITER-001))
        (CL:LET* ((I NULL) (ITER-002 (ALL-INSTANCES M TRUE)))
         (CL:LOOP WHILE (NEXT? ITER-002) DO
          (CL:SETQ I (%ITERATOR.VALUE ITER-002))
          (UPCLASSIFY-ONE-INSTANCE I))))))))))

;;; (DEFUN CLASSIFY-INSTANCES ...)

(CL:DEFUN %CLASSIFY-INSTANCES (MODULE LOCAL?)
  "Classify instances visible in `module'.
If `local?', don't classify inherited instances.  If `module' is
NULL, classify instances. in all modules."
  (CL:LET* ((THEMODULE (COERCE-TO-MODULE MODULE TRUE)))
   (CL:WHEN (CL:NOT (CL:EQ THEMODULE NULL))
    (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ THEMODULE NULL))
    (UPCLASSIFY-INSTANCES THEMODULE LOCAL?))))

(CL:DEFUN CLASSIFY-INSTANCES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%CLASSIFY-INSTANCES (%%VALUE ARGUMENTS)
   (%BOOLEAN-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO CLASSIFY-INSTANCES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Classify instances visible in `module'.
If `local?', don't classify inherited instances.  If `module' is
NULL, classify instances. in all modules."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/CLASSIFY-INSTANCES)) (CL:MACRO-FUNCTION (CL:QUOTE CLASSIFY-INSTANCES)))

;;; (DEFUN UPCLASSIFY-ALL-DESCRIPTIONS ...)

(CL:DEFUN UPCLASSIFY-ALL-DESCRIPTIONS ()
  "Classify all named descriptions."
  (FINALIZE-RELATIONS)
  (CL:LET*
   ((*CLASSIFICATIONSESSION*
     (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-DESCRIPTION))
    (*CONTEXT*
     (%CLASSIFICATION-SESSION.CLASSIFICATION-WORLD
      *CLASSIFICATIONSESSION*)))
   (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION* *CONTEXT*))
   (CL:LET* ((D NULL) (ITER-000 (ALL-NAMED-DESCRIPTIONS NULL FALSE)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ D (%ITERATOR.VALUE ITER-000))
     (UPCLASSIFY-ONE-DESCRIPTION D)))))

;;; (DEFUN UPCLASSIFY-ALL-INSTANCES ...)

(CL:DEFUN UPCLASSIFY-ALL-INSTANCES ()
  "Classify all named instances."
  (FINALIZE-RELATIONS)
  (CL:LET*
   ((*CLASSIFICATIONSESSION*
     (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-DESCRIPTION))
    (*CONTEXT*
     (%CLASSIFICATION-SESSION.CLASSIFICATION-WORLD
      *CLASSIFICATIONSESSION*)))
   (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION* *CONTEXT*))
   (CL:LET* ((I NULL) (ITER-000 (ALL-INSTANCES NULL FALSE)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ I (%ITERATOR.VALUE ITER-000)) (UPCLASSIFY-ONE-INSTANCE I)))))

;;; (DEFUN (ALL-EQUIVALENT-COLLECTIONS (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-EQUIVALENT-COLLECTIONS (SELF REFLEXIVE?)
  (CL:LET*
   ((EQUIVALENTS (CONS-LIST SELF)) (UNSCANNEDEQUIVALENTS (LIST SELF))
    (U NULL))
   (CL:WHEN (MEMBER? (ALL-SUPERCOLLECTIONS SELF) SELF)
    (CL:LOOP (CL:SETQ U (POP UNSCANNEDEQUIVALENTS))
     (CL:LET*
      ((PARENT NULL) (ITER-000 (ALL-DIRECT-SUPERCOLLECTIONS U FALSE)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ PARENT (%ITERATOR.VALUE ITER-000))
       (CL:WHEN
        (CL:AND (CL:NOT (MEMBER? EQUIVALENTS PARENT))
         (MEMBER? (ALL-SUPERCOLLECTIONS PARENT) U))
        (CL:SETQ EQUIVALENTS (CONS PARENT EQUIVALENTS))
        (PUSH UNSCANNEDEQUIVALENTS PARENT))))
     (CL:WHEN (EMPTY? UNSCANNEDEQUIVALENTS) (CL:RETURN))))
   (CL:IF REFLEXIVE? EQUIVALENTS (REMOVE EQUIVALENTS SELF))))

;;; (DEFUN (ALL-CYCLES (CONS OF CONS)) ...)

(CL:DEFUN ALL-CYCLES (MODULE LOCAL?)
  "Return a list of lists of descriptions that are
provably co-extensional."
  NULL)

(CL:DEFUN HELP-STARTUP-CLASSIFY1 ()
  (CL:PROGN
   (CL:SETQ SGT-CLASSIFY-LOGIC-GLOBAL-TIMESTAMPS-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBAL-TIMESTAMPS-RECORD" NULL 1))
   (CL:SETQ SYM-CLASSIFY-LOGIC-INFERABLE-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERABLE-TIMESTAMP" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-READ-SINCE-LAST-INFERABLE-BUMP?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "READ-SINCE-LAST-INFERABLE-BUMP?" NULL
     0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-DISJOINTNESS-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISJOINTNESS-TIMESTAMP" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-READ-SINCE-LAST-DISJOINTNESS-BUMP?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "READ-SINCE-LAST-DISJOINTNESS-BUMP?"
     NULL 0))
   (CL:SETQ SGT-CLASSIFY-LOGIC-INFERABLE-CACHE-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERABLE-CACHE-RECORD" NULL 1))
   (CL:SETQ SYM-CLASSIFY-LOGIC-INFERABLE-CACHE-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERABLE-CACHE-TIMESTAMP" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-INFERABLE-CACHE-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERABLE-CACHE-TABLE" NULL 0))
   (CL:SETQ KWD-CLASSIFY-INFERABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERABLE" NULL 2))
   (CL:SETQ SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SGT-CLASSIFY-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ KWD-CLASSIFY-NON-INFERABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NON-INFERABLE" NULL 2))
   (CL:SETQ KWD-CLASSIFY-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-CLASSIFY-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-CLASSIFY-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ KWD-CLASSIFY-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-CLASSIFY-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ KWD-CLASSIFY-BACKWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD" NULL 2))
   (CL:SETQ SYM-CLASSIFY-LOGIC-FORWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-ONLY?" NULL 0))
   (CL:SETQ SGT-CLASSIFY-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-CLASSIFY-LOGIC-DISJOINTNESS-CACHE-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISJOINTNESS-CACHE-RECORD" NULL 1))
   (CL:SETQ SYM-CLASSIFY-LOGIC-DISJOINTNESS-CACHE-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISJOINTNESS-CACHE-TIMESTAMP" NULL
     0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-DISJOINTNESS-CACHE-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISJOINTNESS-CACHE-TABLE" NULL 0))
   (CL:SETQ KWD-CLASSIFY-DISJOINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISJOINT" NULL 2))
   (CL:SETQ KWD-CLASSIFY-NON-DISJOINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NON-DISJOINT" NULL 2))
   (CL:SETQ SGT-CLASSIFY-LOGIC-MARKER-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MARKER-TABLE" NULL 1))
   (CL:SETQ SYM-CLASSIFY-LOGIC-TEST-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TEST-TABLE" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-RECALL-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RECALL-TABLE" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-SUPPORTS-RECALL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPPORTS-RECALL?" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-SUBSUMPTION-LINK?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-LINK?" NULL 0))
   (CL:SETQ KWD-CLASSIFY-CLASSIFIER-INFERENCES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFIER-INFERENCES" NULL 2))
   (CL:SETQ SGT-CLASSIFY-LOGIC-CLASSIFICATION-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFICATION-CACHE" NULL 1))
   (CL:SETQ SYM-CLASSIFY-LOGIC-INFERABLE-DIRECT-SUBDESCRIPTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERABLE-DIRECT-SUBDESCRIPTIONS"
     NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CACHE-UPCLASSIFICATION-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHE-UPCLASSIFICATION-TIMESTAMP"
     NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CACHE-DOWNCLASSIFICATION-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHE-DOWNCLASSIFICATION-TIMESTAMP"
     NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-INTRODUCTION-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTRODUCTION-TIMESTAMP" NULL 0))
   (CL:SETQ SGT-CLASSIFY-LOGIC-CLASSIFICATION-SESSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFICATION-SESSION" NULL 1))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CLASSIFICATION-WORLD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFICATION-WORLD" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CLASSIFICATION-CACHE-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFICATION-CACHE-TABLE" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CLASSIFICATION-TIMECLOCK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFICATION-TIMECLOCK" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-INTRODUCTION-TIMESTAMP-STACK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTRODUCTION-TIMESTAMP-STACK" NULL
     0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-EVERYTHING-CLASSIFIED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVERYTHING-CLASSIFIED?" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-LAST-CACHE-TABLE-KEY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LAST-CACHE-TABLE-KEY" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-LAST-CACHE-TABLE-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LAST-CACHE-TABLE-VALUE" NULL 0))
   (CL:SETQ KWD-CLASSIFY-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ KWD-CLASSIFY-META
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META" NULL 2))
   (CL:SETQ KWD-CLASSIFY-INSTANCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INSTANCE" NULL 2))
   (CL:SETQ KWD-CLASSIFY-TMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TMS" NULL 2))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFICATION-SESSION" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-META-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-INFERENCE-CACHE" NULL 0))
   (CL:SETQ KWD-CLASSIFY-JUST-IN-TIME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUST-IN-TIME" NULL 2))
   (CL:SETQ KWD-CLASSIFY-CLASSIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFIER" NULL 2))
   (CL:SETQ KWD-CLASSIFY-UPCLASSIFY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UPCLASSIFY" NULL 2))
   (CL:SETQ KWD-CLASSIFY-DOWNCLASSIFY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWNCLASSIFY" NULL 2))
   (CL:SETQ SYM-CLASSIFY-LOGIC-SUBRELATION-LINK?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBRELATION-LINK?" NULL 0))
   (CL:SETQ KWD-CLASSIFY-ASSERT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CLASSIFY-RELATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFY-RELATIONS" NULL 0))
   (CL:SETQ KWD-CLASSIFY-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CLASSIFY-INSTANCES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFY-INSTANCES" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-STARTUP-CLASSIFY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-CLASSIFY" NULL 0))))

(CL:DEFUN HELP-STARTUP-CLASSIFY2 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "GET-INFERABLE-TIMESTAMP"
    "(DEFUN (GET-INFERABLE-TIMESTAMP TIMESTAMP) ())"
    (CL:FUNCTION GET-INFERABLE-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "BUMP-INFERABLE-TIMESTAMP"
    "(DEFUN BUMP-INFERABLE-TIMESTAMP ())"
    (CL:FUNCTION BUMP-INFERABLE-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "TOGGLE-INFERABLE-CACHE"
    "(DEFUN (TOGGLE-INFERABLE-CACHE STRING) ())"
    (CL:FUNCTION TOGGLE-INFERABLE-CACHE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-INFERABLE-CACHED-KEYWORD"
    "(DEFUN (GET-INFERABLE-CACHED-KEYWORD KEYWORD) ((DESCRIPTION LOGIC-OBJECT)))"
    (CL:FUNCTION GET-INFERABLE-CACHED-KEYWORD) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-INFERABLE-CACHED-KEYWORD"
    "(DEFUN SET-INFERABLE-CACHED-KEYWORD ((DESCRIPTION NAMED-DESCRIPTION) (INFERABLE? BOOLEAN)))"
    (CL:FUNCTION SET-INFERABLE-CACHED-KEYWORD) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-INTENSIONAL-PARENTS"
    "(DEFUN HELP-COLLECT-INTENSIONAL-PARENTS ((DESCRIPTION DESCRIPTION) (PROPOSITION PROPOSITION) (COLLECTION LIST)))"
    (CL:FUNCTION HELP-COLLECT-INTENSIONAL-PARENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-INTENSIONAL-PARENTS"
    "(DEFUN (ALL-INTENSIONAL-PARENTS (LIST OF DESCRIPTION)) ((SELF DESCRIPTION)))"
    (CL:FUNCTION ALL-INTENSIONAL-PARENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "INFERABLE-THROUGH-BY-SOME-DESCENDANT?"
    "(DEFUN (INFERABLE-THROUGH-BY-SOME-DESCENDANT? BOOLEAN) ((SELF NAMED-DESCRIPTION) (THROUGHCHILD LOGIC-OBJECT) (ALREADYVISITEDLIST CONS)))"
    (CL:FUNCTION INFERABLE-THROUGH-BY-SOME-DESCENDANT?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-INFERABLE?"
    "(DEFUN (COMPUTE-INFERABLE? BOOLEAN) ((SELF DESCRIPTION) (ALREADYVISITEDLIST CONS)))"
    (CL:FUNCTION COMPUTE-INFERABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "INFERABLE-WITH-CYCLE-CHECK?"
    "(DEFUN (INFERABLE-WITH-CYCLE-CHECK? BOOLEAN) ((SELF DESCRIPTION) (ALREADYVISITEDLIST CONS)))"
    (CL:FUNCTION INFERABLE-WITH-CYCLE-CHECK?) NULL)
   (DEFINE-FUNCTION-OBJECT "INFERABLE?"
    "(DEFUN (INFERABLE? BOOLEAN) ((SELF DESCRIPTION)) :INLINE INFERABLE-WITH-CYCLE-CHECK?)"
    (CL:FUNCTION INFERABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "NON-INFERABLE?"
    "(DEFUN (NON-INFERABLE? BOOLEAN) ((SELF DESCRIPTION)) :INLINE INFERABLE?)"
    (CL:FUNCTION NON-INFERABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "TOGGLE-DISJOINTNESS-CACHE"
    "(DEFUN (TOGGLE-DISJOINTNESS-CACHE STRING) ())"
    (CL:FUNCTION TOGGLE-DISJOINTNESS-CACHE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-DISJOINTNESS-TIMESTAMP"
    "(DEFUN (GET-DISJOINTNESS-TIMESTAMP TIMESTAMP) ())"
    (CL:FUNCTION GET-DISJOINTNESS-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "BUMP-DISJOINTNESS-TIMESTAMP"
    "(DEFUN BUMP-DISJOINTNESS-TIMESTAMP ())"
    (CL:FUNCTION BUMP-DISJOINTNESS-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-DISJOINTNESS-CACHED-KEYWORD"
    "(DEFUN (GET-DISJOINTNESS-CACHED-KEYWORD KEYWORD) ((DESCRIPTION LOGIC-OBJECT)))"
    (CL:FUNCTION GET-DISJOINTNESS-CACHED-KEYWORD) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-DISJOINTNESS-CACHED-KEYWORD"
    "(DEFUN SET-DISJOINTNESS-CACHED-KEYWORD ((DESCRIPTION NAMED-DESCRIPTION) (DISJOINT? BOOLEAN)))"
    (CL:FUNCTION SET-DISJOINTNESS-CACHED-KEYWORD) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-MARKER-STORAGE"
    "(DEFUN (CREATE-MARKER-STORAGE MARKER-TABLE) ((SUPPORTRECALL? BOOLEAN)) :DOCUMENTATION \"Return a new marker storage object, used to
remember with objects have been 'marked'.  If 'supportRecall?'
is set, then the iterator 'recall-marked-objects' can be invoked
on the new marker storage object.\")" (CL:FUNCTION CREATE-MARKER-STORAGE)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-MARKER ((SELF MARKER-TABLE) (OBJECT OBJECT)) :DOCUMENTATION \"Record membership of 'object' in the marker
storage object 'self'.\")" (CL:FUNCTION SET-MARKER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (TEST-MARKER? BOOLEAN) ((SELF MARKER-TABLE) (OBJECT OBJECT)) :DOCUMENTATION \"Return TRUE if 'object' is stored (marked) in 'self'.\")"
    (CL:FUNCTION TEST-MARKER?) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-SPECIAL-MARKER-TABLE?"
    "(DEFUN (TEST-SPECIAL-MARKER-TABLE? BOOLEAN) ((SELF OBJECT)) :DOCUMENTATION \"Return TRUE if the object 'self' is stored (marked)
in the table pointed at by the special variable *specialMarkerTable*.
Designed for use by 'remove-if'.\")"
    (CL:FUNCTION TEST-SPECIAL-MARKER-TABLE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (RECALL-MARKED-OBJECTS LIST-ITERATOR) ((SELF MARKER-TABLE)) :DOCUMENTATION \"Return an iterator that generates all marked objects
recorded in 'self'.\")" (CL:FUNCTION RECALL-MARKED-OBJECTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-NAMED-DIRECT-SUPERDESCRIPTIONS"
    "(DEFUN (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS (CONS OF NAMED-DESCRIPTION)) ((SELF DESCRIPTION) (REMOVEEQUIVALENTS? BOOLEAN)))"
    (CL:FUNCTION ALL-NAMED-DIRECT-SUPERDESCRIPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-NAMED-DIRECT-SUBDESCRIPTIONS"
    "(DEFUN (ALL-NAMED-DIRECT-SUBDESCRIPTIONS (CONS OF NAMED-DESCRIPTION)) ((SELF DESCRIPTION)))"
    (CL:FUNCTION ALL-NAMED-DIRECT-SUBDESCRIPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-ISA-LINK"
    "(DEFUN ADD-ISA-LINK ((INSTANCE LOGIC-OBJECT) (SUPERDESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION ADD-ISA-LINK) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-SUBSUMPTION-LINK"
    "(DEFUN ADD-SUBSUMPTION-LINK ((SUBDESCRIPTION DESCRIPTION) (SUPERDESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION ADD-SUBSUMPTION-LINK) NULL)
   (DEFINE-FUNCTION-OBJECT "MOST-SPECIFIC-COLLECTIONS"
    "(DEFUN (MOST-SPECIFIC-COLLECTIONS (CONS OF LOGIC-OBJECT)) ((DESCRIPTIONS (CONS OF LOGIC-OBJECT))))"
    (CL:FUNCTION MOST-SPECIFIC-COLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "MOST-GENERAL-COLLECTIONS"
    "(DEFUN (MOST-GENERAL-COLLECTIONS (CONS OF LOGIC-OBJECT)) ((DESCRIPTIONS (CONS OF LOGIC-OBJECT))))"
    (CL:FUNCTION MOST-GENERAL-COLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "NAMED-COLLECTION?"
    "(DEFUN (NAMED-COLLECTION? BOOLEAN) ((SELF LOGIC-OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION NAMED-COLLECTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "MOST-SPECIFIC-NAMED-COLLECTIONS"
    "(DEFUN (MOST-SPECIFIC-NAMED-COLLECTIONS (CONS OF LOGIC-OBJECT)) ((DESCRIPTIONS (CONS OF LOGIC-OBJECT))) :PUBLIC? TRUE)"
    (CL:FUNCTION MOST-SPECIFIC-NAMED-COLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "MOST-SPECIFIC-NAMED-DESCRIPTIONS"
    "(DEFUN (MOST-SPECIFIC-NAMED-DESCRIPTIONS (CONS OF NAMED-DESCRIPTION)) ((DESCRIPTIONS (CONS OF LOGIC-OBJECT))))"
    (CL:FUNCTION MOST-SPECIFIC-NAMED-DESCRIPTIONS) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT WORLD CLASSIFICATION-SESSION :PUBLIC? TRUE :DOCUMENTATION \"Points to a record that caches the distributed
state of descriptions participating in a classification session.\" :TYPE CLASSIFICATION-SESSION :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "GET-CLASSIFICATION-WORLD"
    "(DEFUN (GET-CLASSIFICATION-WORLD WORLD) () :PUBLIC? TRUE)"
    (CL:FUNCTION GET-CLASSIFICATION-WORLD) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-CLASSIFICATION-SESSION"
    "(DEFUN (GET-CLASSIFICATION-SESSION CLASSIFICATION-SESSION) ((INSTANCEORDESCRIPTION KEYWORD)) :PUBLIC? TRUE)"
    (CL:FUNCTION GET-CLASSIFICATION-SESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-CLASSIFICATION-CACHE"
    "(DEFUN (GET-CLASSIFICATION-CACHE CLASSIFICATION-CACHE) ((SELF OBJECT)))"
    (CL:FUNCTION GET-CLASSIFICATION-CACHE) NULL)
   (DEFINE-FUNCTION-OBJECT
    "TOGGLE-INFERABLE-DIRECT-SUBCOLLECTIONS-CACHING"
    "(DEFUN (TOGGLE-INFERABLE-DIRECT-SUBCOLLECTIONS-CACHING STRING) ())"
    (CL:FUNCTION TOGGLE-INFERABLE-DIRECT-SUBCOLLECTIONS-CACHING) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-INFERABLE-DIRECT-SUBCOLLECTIONS"
    "(DEFUN (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS (LIST OF DESCRIPTION)) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION ALL-INFERABLE-DIRECT-SUBCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "FLUSH-INFERABLE-DIRECT-SUBDESCRIPTIONS-CACHE"
    "(DEFUN FLUSH-INFERABLE-DIRECT-SUBDESCRIPTIONS-CACHE ((IMPLIESPROPOSITION PROPOSITION)))"
    (CL:FUNCTION FLUSH-INFERABLE-DIRECT-SUBDESCRIPTIONS-CACHE) NULL)
   (DEFINE-FUNCTION-OBJECT "CURRENT-CLASSIFICATION-TIME"
    "(DEFUN (CURRENT-CLASSIFICATION-TIME TIMESTAMP) ())"
    (CL:FUNCTION CURRENT-CLASSIFICATION-TIME) NULL)
   (DEFINE-FUNCTION-OBJECT "BUMP-CLASSIFICATION-TIMECLOCK"
    "(DEFUN (BUMP-CLASSIFICATION-TIMECLOCK TIMESTAMP) ())"
    (CL:FUNCTION BUMP-CLASSIFICATION-TIMECLOCK) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (INTRODUCTION-TIMESTAMP TIMESTAMP) ((SELF LOGIC-OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION INTRODUCTION-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "INTRODUCE-INTO-CLASSIFICATION-SESSION"
    "(DEFUN INTRODUCE-INTO-CLASSIFICATION-SESSION ((SELF DESCRIPTION)))"
    (CL:FUNCTION INTRODUCE-INTO-CLASSIFICATION-SESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "YOUNGEST-INTRODUCTION-TIMESTAMP"
    "(DEFUN (YOUNGEST-INTRODUCTION-TIMESTAMP INTEGER) ())"
    (CL:FUNCTION YOUNGEST-INTRODUCTION-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "UPCLASSIFICATION-TIMESTAMP"
    "(DEFUN (UPCLASSIFICATION-TIMESTAMP INTEGER) ((SELF OBJECT)))"
    (CL:FUNCTION UPCLASSIFICATION-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "DOWNCLASSIFICATION-TIMESTAMP"
    "(DEFUN (DOWNCLASSIFICATION-TIMESTAMP INTEGER) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION DOWNCLASSIFICATION-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "REFRESH-UPCLASSIFICATION-TIMESTAMP"
    "(DEFUN REFRESH-UPCLASSIFICATION-TIMESTAMP ((SELF OBJECT)))"
    (CL:FUNCTION REFRESH-UPCLASSIFICATION-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "REFRESH-DOWNCLASSIFICATION-TIMESTAMP"
    "(DEFUN REFRESH-DOWNCLASSIFICATION-TIMESTAMP ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION REFRESH-DOWNCLASSIFICATION-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "FLUSH-CLASSIFICATION-SESSIONS"
    "(DEFUN FLUSH-CLASSIFICATION-SESSIONS ())"
    (CL:FUNCTION FLUSH-CLASSIFICATION-SESSIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "UPCLASSIFIED?"
    "(DEFUN (UPCLASSIFIED? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION UPCLASSIFIED?) NULL)
   (DEFINE-FUNCTION-OBJECT "UPCLASSIFIED-LATER-THAN?"
    "(DEFUN (UPCLASSIFIED-LATER-THAN? BOOLEAN) ((SELF LOGIC-OBJECT) (OTHER LOGIC-OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION UPCLASSIFIED-LATER-THAN?) NULL)
   (DEFINE-FUNCTION-OBJECT "DOWNCLASSIFIED?"
    "(DEFUN (DOWNCLASSIFIED? BOOLEAN) ((SELF LOGIC-OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION DOWNCLASSIFIED?) NULL)
   (DEFINE-FUNCTION-OBJECT "MARK-UNMARKED-SUPERRELATIONS"
    "(DEFUN MARK-UNMARKED-SUPERRELATIONS ((DESCRIPTION DESCRIPTION) (SELFISBELOWTABLE MARKER-TABLE)))"
    (CL:FUNCTION MARK-UNMARKED-SUPERRELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-SUBSUMPTION-TEST?"
    "(DEFUN (APPLY-SUBSUMPTION-TEST? BOOLEAN) ((SUBSUMPTIONTEST FUNCTION-CODE) (SELF LOGIC-OBJECT) (SUPER LOGIC-OBJECT)))"
    (CL:FUNCTION APPLY-SUBSUMPTION-TEST?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-PARENTS-BELOW?"
    "(DEFUN (HELP-COLLECT-PARENTS-BELOW? BOOLEAN) ((SELF LOGIC-OBJECT) (SUPER DESCRIPTION) (NEWPARENTDESCRIPTIONS (LIST OF DESCRIPTION)) (ALREADYVISITEDTABLE MARKER-TABLE) (SELFISBELOWTABLE MARKER-TABLE) (SUBSUMPTIONTEST FUNCTION-CODE)))"
    (CL:FUNCTION HELP-COLLECT-PARENTS-BELOW?) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-SUBSUMING-PARENTS-BELOW"
    "(DEFUN COLLECT-SUBSUMING-PARENTS-BELOW ((SELF LOGIC-OBJECT) (SUPER DESCRIPTION) (NEWPARENTDESCRIPTIONS (LIST OF DESCRIPTION)) (ALREADYVISITEDTABLE MARKER-TABLE) (SELFISBELOWTABLE MARKER-TABLE) (SUBSUMPTIONTEST FUNCTION-CODE)))"
    (CL:FUNCTION COLLECT-SUBSUMING-PARENTS-BELOW) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-ANCESTORS-OF-PARENTS"
    "(DEFUN (ALL-ANCESTORS-OF-PARENTS (ITERATOR OF LOGIC-OBJECT)) ((SUPERS (CONS OF LOGIC-OBJECT))))"
    (CL:FUNCTION ALL-ANCESTORS-OF-PARENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-ANCESTOR-COLLECTIONS"
    "(DEFUN (ALL-ANCESTOR-COLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF OBJECT) (INSTANCEORDESCRIPTION KEYWORD)))"
    (CL:FUNCTION ALL-ANCESTOR-COLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-UPCLASSIFY-ONE-ENTITY"
    "(DEFUN HELP-UPCLASSIFY-ONE-ENTITY ((SELF LOGIC-OBJECT) (INSTANCEORDESCRIPTION KEYWORD)))"
    (CL:FUNCTION HELP-UPCLASSIFY-ONE-ENTITY) NULL)
   (DEFINE-FUNCTION-OBJECT "UPCLASSIFY-ONE-INSTANCE"
    "(DEFUN UPCLASSIFY-ONE-INSTANCE ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION UPCLASSIFY-ONE-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "UPCLASSIFY-ONE-DESCRIPTION"
    "(DEFUN UPCLASSIFY-ONE-DESCRIPTION ((SELF LOGIC-OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION UPCLASSIFY-ONE-DESCRIPTION) NULL)))

(CL:DEFUN STARTUP-CLASSIFY ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-CLASSIFY1)
    (CL:SETQ SYM-CLASSIFY-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
      (GET-STELLA-MODULE "/STELLA" TRUE) 0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *GLOBAL-TIMESTAMPS* (NEW-GLOBAL-TIMESTAMPS-RECORD))
    (CL:SETQ *INFERABLE-CACHE* (NEW-INFERABLE-CACHE-RECORD))
    (CL:SETQ *DISJOINTNESS-CACHE* (NEW-DISJOINTNESS-CACHE-RECORD)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "GLOBAL-TIMESTAMPS-RECORD"
        "(DEFCLASS GLOBAL-TIMESTAMPS-RECORD (STANDARD-OBJECT) :SLOTS ((INFERABLE-TIMESTAMP :TYPE TIMESTAMP :INITIALLY 0) (READ-SINCE-LAST-INFERABLE-BUMP? :TYPE BOOLEAN) (DISJOINTNESS-TIMESTAMP :TYPE TIMESTAMP :INITIALLY 0) (READ-SINCE-LAST-DISJOINTNESS-BUMP? :TYPE BOOLEAN)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-GLOBAL-TIMESTAMPS-RECORD))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-GLOBAL-TIMESTAMPS-RECORD-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INFERABLE-CACHE-RECORD"
        "(DEFCLASS INFERABLE-CACHE-RECORD (STANDARD-OBJECT) :SLOTS ((INFERABLE-CACHE-TIMESTAMP :TYPE TIMESTAMP :INITIALLY -1) (INFERABLE-CACHE-TABLE :TYPE (HASH-TABLE OF DESCRIPTION KEYWORD))))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INFERABLE-CACHE-RECORD))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-INFERABLE-CACHE-RECORD-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "DISJOINTNESS-CACHE-RECORD"
        "(DEFCLASS DISJOINTNESS-CACHE-RECORD (STANDARD-OBJECT) :SLOTS ((DISJOINTNESS-CACHE-TIMESTAMP :TYPE TIMESTAMP) (DISJOINTNESS-CACHE-TABLE :TYPE (HASH-TABLE OF DESCRIPTION KEYWORD))))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-DISJOINTNESS-CACHE-RECORD))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-DISJOINTNESS-CACHE-RECORD-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "MARKER-TABLE"
        "(DEFCLASS MARKER-TABLE (STANDARD-OBJECT) :DOCUMENTATION \"Used to record (mark) a set of objects.
Can be optimized for testing only, or also for recall.\" :SLOTS ((TEST-TABLE :TYPE HASH-TABLE) (RECALL-TABLE :TYPE LIST) (SUPPORTS-RECALL? :TYPE BOOLEAN)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-MARKER-TABLE))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-MARKER-TABLE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CLASSIFICATION-CACHE"
        "(DEFCLASS CLASSIFICATION-CACHE (STANDARD-OBJECT) :DOCUMENTATION \"Records various kinds of data about a description
during a classification session.\" :SLOTS ((INFERABLE-DIRECT-SUBDESCRIPTIONS :TYPE (LIST OF DESCRIPTION)) (CACHE-UPCLASSIFICATION-TIMESTAMP :TYPE INTEGER :INITIALLY -1) (CACHE-DOWNCLASSIFICATION-TIMESTAMP :TYPE INTEGER :INITIALLY -1) (INTRODUCTION-TIMESTAMP :TYPE INTEGER :INITIALLY 0)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CLASSIFICATION-CACHE))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CLASSIFICATION-CACHE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CLASSIFICATION-SESSION"
        "(DEFCLASS CLASSIFICATION-SESSION (STANDARD-OBJECT) :SLOTS ((CLASSIFICATION-WORLD :TYPE WORLD) (CLASSIFICATION-CACHE-TABLE :TYPE (HASH-TABLE OF OBJECT CLASSIFICATION-CACHE) :ALLOCATION :EMBEDDED) (CLASSIFICATION-TIMECLOCK :TYPE INTEGER :INITIALLY 0) (INTRODUCTION-TIMESTAMP-STACK :TYPE (LIST OF INTEGER-WRAPPER) :INITIALLY (LIST 0)) (EVERYTHING-CLASSIFIED? :TYPE BOOLEAN) (LAST-CACHE-TABLE-KEY :TYPE LOGIC-OBJECT) (LAST-CACHE-TABLE-VALUE :TYPE CLASSIFICATION-CACHE)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CLASSIFICATION-SESSION))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CLASSIFICATION-SESSION-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-CLASSIFY2)
    (DEFINE-FUNCTION-OBJECT "HELP-DOWNCLASSIFY-ONE-DESCRIPTION"
     "(DEFUN HELP-DOWNCLASSIFY-ONE-DESCRIPTION ((NODE LOGIC-OBJECT) (SELF LOGIC-OBJECT) (NECESSARYANCESTORS (CONS OF LOGIC-OBJECT)) (ALREADYVISITEDTABLE MARKER-TABLE)))"
     (CL:FUNCTION HELP-DOWNCLASSIFY-ONE-DESCRIPTION) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECTION-WITH-FEWEST-CHILDREN"
     "(DEFUN (COLLECTION-WITH-FEWEST-CHILDREN LOGIC-OBJECT) ((COLLECTIONS (CONS OF LOGIC-OBJECT))))"
     (CL:FUNCTION COLLECTION-WITH-FEWEST-CHILDREN) NULL)
    (DEFINE-FUNCTION-OBJECT "CHOOSE-BEST-DOWNCLASSIFIED-PARENT"
     "(DEFUN (CHOOSE-BEST-DOWNCLASSIFIED-PARENT LOGIC-OBJECT) ((PARENTS (CONS OF LOGIC-OBJECT))))"
     (CL:FUNCTION CHOOSE-BEST-DOWNCLASSIFIED-PARENT) NULL)
    (DEFINE-FUNCTION-OBJECT "DOWNCLASSIFY-ONE-DESCRIPTION"
     "(DEFUN DOWNCLASSIFY-ONE-DESCRIPTION ((SELF LOGIC-OBJECT)) :PUBLIC? TRUE)"
     (CL:FUNCTION DOWNCLASSIFY-ONE-DESCRIPTION) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (VIRGIN? BOOLEAN) ((SELF DESCRIPTION)))"
     (CL:FUNCTION VIRGIN?) NULL)
    (DEFINE-FUNCTION-OBJECT "EVAPORATE-VIRGIN"
     "(DEFUN EVAPORATE-VIRGIN ((SELF DESCRIPTION)))"
     (CL:FUNCTION EVAPORATE-VIRGIN) NULL)
    (DEFINE-FUNCTION-OBJECT "FIND-DIRECT-SUPERS-AND-SUBS"
     "(DEFUN (FIND-DIRECT-SUPERS-AND-SUBS (CONS OF DESCRIPTION) (CONS OF DESCRIPTION) (CONS OF DESCRIPTION)) ((SELF DESCRIPTION) (ONLYSUPERS? BOOLEAN)) :DOCUMENTATION \"Classify 'self' and return three values, its direct
supers, direct subs, and a list of equivalent descriptions.
Setting 'supersOnly?' may speed up the computation (perhaps by a lot).
If 'description' is nameless and has no dependent propositions, then
it is automatically removed from the hierarchy after classification.\" :PUBLIC? TRUE)"
     (CL:FUNCTION FIND-DIRECT-SUPERS-AND-SUBS) NULL)
    (DEFINE-FUNCTION-OBJECT "FIND-DIRECT-SUPERS-OF-INSTANCE"
     "(DEFUN (FIND-DIRECT-SUPERS-OF-INSTANCE (CONS OF LOGIC-OBJECT)) ((SELF OBJECT)) :DOCUMENTATION \"Classify 'self' and return a list of most specific 
named descriptions among all descriptions that it satisfies.\" :PUBLIC? TRUE)"
     (CL:FUNCTION FIND-DIRECT-SUPERS-OF-INSTANCE) NULL)
    (DEFINE-FUNCTION-OBJECT "UPCLASSIFY-NAMED-DESCRIPTIONS"
     "(DEFUN UPCLASSIFY-NAMED-DESCRIPTIONS ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Classify named descriptions local to 'module' and inherited
by 'module'.  If 'local?', don't classify inherited descriptions.  If
'module' is NULL, classify descriptions in all modules.\")"
     (CL:FUNCTION UPCLASSIFY-NAMED-DESCRIPTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "CLASSIFY-RELATIONS"
     "(DEFUN CLASSIFY-RELATIONS ((MODULE NAME) (LOCAL? BOOLEAN)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Classify named relations visible in `module'.
If `local?', don't classify inherited descriptions.  If `module' is
NULL, classify relations in all modules.\")"
     (CL:FUNCTION %CLASSIFY-RELATIONS)
     (CL:FUNCTION CLASSIFY-RELATIONS-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "UPCLASSIFY-INSTANCES"
     "(DEFUN UPCLASSIFY-INSTANCES ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Classify instances local to 'module' and inherited
by 'module'.  If 'local?', don't classify inherited descriptions.  If
'module' is NULL, classify descriptions in all modules.\")"
     (CL:FUNCTION UPCLASSIFY-INSTANCES) NULL)
    (DEFINE-FUNCTION-OBJECT "CLASSIFY-INSTANCES"
     "(DEFUN CLASSIFY-INSTANCES ((MODULE NAME) (LOCAL? BOOLEAN)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Classify instances visible in `module'.
If `local?', don't classify inherited instances.  If `module' is
NULL, classify instances. in all modules.\")"
     (CL:FUNCTION %CLASSIFY-INSTANCES)
     (CL:FUNCTION CLASSIFY-INSTANCES-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "UPCLASSIFY-ALL-DESCRIPTIONS"
     "(DEFUN UPCLASSIFY-ALL-DESCRIPTIONS () :DOCUMENTATION \"Classify all named descriptions.\")"
     (CL:FUNCTION UPCLASSIFY-ALL-DESCRIPTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "UPCLASSIFY-ALL-INSTANCES"
     "(DEFUN UPCLASSIFY-ALL-INSTANCES () :DOCUMENTATION \"Classify all named instances.\")"
     (CL:FUNCTION UPCLASSIFY-ALL-INSTANCES) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-EQUIVALENT-COLLECTIONS"
     "(DEFUN (ALL-EQUIVALENT-COLLECTIONS (CONS OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT) (REFLEXIVE? BOOLEAN)) :PUBLIC? TRUE)"
     (CL:FUNCTION ALL-EQUIVALENT-COLLECTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-CYCLES"
     "(DEFUN (ALL-CYCLES (CONS OF CONS)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Return a list of lists of descriptions that are
provably co-extensional.\")" (CL:FUNCTION ALL-CYCLES) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-CLASSIFY"
     "(DEFUN STARTUP-CLASSIFY () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-CLASSIFY) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-CLASSIFY-LOGIC-STARTUP-CLASSIFY)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-CLASSIFY-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "Startup-Classify") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *GLOBAL-TIMESTAMPS* GLOBAL-TIMESTAMPS-RECORD (NEW GLOBAL-TIMESTAMPS-RECORD) :DOCUMENTATION \"Keeps track of all global timestamps, making
maintenance (e.g., resetting) more manageable.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INFERABLE-CACHE* INFERABLE-CACHE-RECORD (NEW INFERABLE-CACHE-RECORD) :DOCUMENTATION \"Pointer to cache containing table that maps descriptions
to :INFERABLE or :NON-INFERABLE.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INFERABLE-CACHE-ENABLED?* BOOLEAN TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DISJOINTNESS-CACHE* DISJOINTNESS-CACHE-RECORD (NEW DISJOINTNESS-CACHE-RECORD) :DOCUMENTATION \"Pointer to cache containing table that maps descriptions
to :DISJOINT or :NON-DISJOINT.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DISJOINTNESS-CACHE-ENABLED?* BOOLEAN TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *SPECIALMARKERTABLE* MARKER-TABLE :DOCUMENTATION \"Special variable that points to the marker table 
referenced by the function 'test-special-marker-table?'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *FINDSUPERSANDSUBSDESCRIPTION* DESCRIPTION NULL :DOCUMENTATION \"Points to a possibly unnamed description being
temporarily classified.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CLASSIFICATIONSESSION* CLASSIFICATION-SESSION NULL :PUBLIC? TRUE :DOCUMENTATION \"Points to state of on-going classification session.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CACHE-INFERABLE-SUBCOLLECTIONS?* BOOLEAN TRUE :DOCUMENTATION \"If TRUE, prevents caching of computations of
all inferable subcollections of a collection.\")")
    (REGISTER-NATIVE-NAME SYM-CLASSIFY-LOGIC-CLASSIFY-RELATIONS
     KWD-CLASSIFY-COMMON-LISP KWD-CLASSIFY-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-CLASSIFY-LOGIC-CLASSIFY-INSTANCES
     KWD-CLASSIFY-COMMON-LISP KWD-CLASSIFY-FUNCTION))))
