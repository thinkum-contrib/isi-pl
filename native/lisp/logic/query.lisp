;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997-2000              | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-QUERY-LOGIC-INFERENCE-LEVEL NULL)
(CL:DEFVAR SYM-QUERY-STELLA-KEYWORD NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-NORMAL-INFERENCE-LEVEL NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-BACKTRACKING-INFERENCE-LEVEL NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-SUBSUMPTION-INFERENCE-LEVEL NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-SHALLOW-INFERENCE-LEVEL NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-ASSERTION-INFERENCE-LEVEL NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-REFUTATION-INFERENCE-LEVEL NULL)
(CL:DEFVAR KWD-QUERY-NORMAL NULL)
(CL:DEFVAR KWD-QUERY-BACKTRACKING NULL)
(CL:DEFVAR KWD-QUERY-SUBSUMPTION NULL)
(CL:DEFVAR KWD-QUERY-SHALLOW NULL)
(CL:DEFVAR KWD-QUERY-ASSERTION NULL)
(CL:DEFVAR KWD-QUERY-REFUTATION NULL)
(CL:DEFVAR KWD-QUERY-LOOKUP NULL)
(CL:DEFVAR KWD-QUERY-DUPLICATE-GOALS NULL)
(CL:DEFVAR KWD-QUERY-TRACE-SUBGOALS NULL)
(CL:DEFVAR KWD-QUERY-PROPAGATE NULL)
(CL:DEFVAR KWD-QUERY-STRATEGIES NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-COST-ESTIMATE NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-QUERY-ITERATOR NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-EXTERNAL-VARIABLES NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-SOLUTIONS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-EXHAUSTED? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-NEGATED-QUERY NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ATOMIC-SINGLETONS? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-QUERY-CONTEXT NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-BASE-CONTROL-FRAME NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CURRENT-CONTROL-FRAME NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CURRENT-PATTERN-RECORD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CURRENT-PARALLEL-THREAD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-PARTIAL-MATCH-STRATEGY NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CONTROL-FRAME-PRIORITY-QUEUE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ITERATIVE-DEEPENING? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CURRENT-DEPTH-CUTOFF NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-MAXIMUM-DEPTH NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-AUGMENTED-GOAL-CACHE? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ACTIVE-GOAL-CACHES NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-TRIGGERED-DEPTH-CUTOFF? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-FAILED-TO-FIND-DUPLICATE-SUBGOAL? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-FOUND-AT-LEAST-ONE-SOLUTION? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-QUERY-THREAD-OFFSET NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-TIMESTAMP NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-LATEST-TOUCHED-DEFAULT? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-TRUTH-VALUES NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-LATEST-PARTIAL-SCORE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-MATCH-SCORES NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-OPTIMIZER-GOAL-RECORDS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-RESIDUE-GOALS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-BEST-GOAL-SEQUENCE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-BEST-COST NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ALLOTTED-TIME NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-TIMEOUT? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-GOAL-BINDINGS NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-CONTROL-FRAME NULL)
(CL:DEFVAR SYM-QUERY-STELLA-BAD? NULL)
(CL:DEFVAR SYM-QUERY-STELLA-STATE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-REVERSE-POLARITY? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-UP NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-DOWN NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ARGUMENT-CURSOR NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-PATTERN-RECORD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-INHERITED-PATTERN-RECORD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CHOICE-POINT-UNBINDING-OFFSET NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CURRENT-STRATEGY NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-NEXT-STRATEGIES NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-HOLDS-BY-DEFAULT? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-PARTIAL-MATCH-FRAME NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-DEBUG-FRAME-ID NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-DEBUG-DEPTH NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-JUSTIFICATIONS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-JUSTIFICATION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CACHED-BINDINGS-ITERATOR NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-GOAL-CACHE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-BINDINGS-COUNTER NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CACHED-SINGLE-VALUED? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-STARTING-CLOCK-TICKS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-DONT-CACHE-GOAL-FAILURE? NULL)
(CL:DEFVAR SYM-QUERY-STELLA-DELETED-OBJECT? NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-PARALLEL-THREAD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-TOP-CONTROL-FRAME NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-HYPOTHETICAL-WORLD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-VARIABLE-BINDINGS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-UNBINDING-STACK NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-TOP-UNBINDING-STACK-OFFSET NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-PRIORITY NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-STATUS NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-PARALLEL-CONTROL-FRAME NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CHILD-THREADS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-UNBOUND-VARIABLES? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CURRENT-CHILD-THREAD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-SAVED-PARENT-CONTEXT NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-SAVED-PARENT-PARALLEL-THREAD NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-CONTROL-FRAME-PRIORITY-QUEUE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-QUEUE NULL)
(CL:DEFVAR KWD-QUERY-UPCLASSIFY NULL)
(CL:DEFVAR KWD-QUERY-DOWNCLASSIFY NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-PROOF-ADJUNCT NULL)
(CL:DEFVAR *RECYCLE-LIST-FOR-PATTERN-RECORD-S* NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-PATTERN-RECORD NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-CONTROL-FRAME NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-EXTERNAL-ARGUMENTS NULL)
(CL:DEFVAR SYM-QUERY-STELLA-BOOLEAN-VECTOR NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-OPTIMAL-PATTERN NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-COLLECTION-LIST NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-BOOLEAN-VECTOR-INDEX-NODE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-TRUE-LINK NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-FALSE-LINK NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-THE-VECTOR NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR KWD-QUERY-PATTERN NULL)
(CL:DEFVAR KWD-QUERY-CONTAINED-BY NULL)
(CL:DEFVAR KWD-QUERY-PARENT NULL)
(CL:DEFVAR KWD-QUERY-POPPED NULL)
(CL:DEFVAR KWD-QUERY-LOCAL NULL)
(CL:DEFVAR KWD-QUERY-QUERY-STACKS NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-QUERY-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR KWD-QUERY-NONE NULL)
(CL:DEFVAR KWD-QUERY-SHALLOW-DISJOINT NULL)
(CL:DEFVAR KWD-QUERY-DISJOINT NULL)
(CL:DEFVAR KWD-QUERY-ISA NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR KWD-QUERY-PERFORMANCE-CLUES NULL)
(CL:DEFVAR SYM-QUERY-STELLA-NULL NULL)
(CL:DEFVAR SGT-QUERY-STELLA-LIST NULL)
(CL:DEFVAR SYM-QUERY-STELLA-SURROGATE-VALUE-INVERSE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-MASTER-PROPOSITION NULL)
(CL:DEFVAR KWD-QUERY-FLAT NULL)
(CL:DEFVAR KWD-QUERY-REALISTIC NULL)
(CL:DEFVAR KWD-QUERY-DOWN NULL)
(CL:DEFVAR KWD-QUERY-ITERATIVE-FORALL NULL)
(CL:DEFVAR KWD-QUERY-STATE-MACHINE NULL)
(CL:DEFVAR KWD-QUERY-PARALLEL-STRATEGIES NULL)
(CL:DEFVAR KWD-QUERY-STRATEGY NULL)
(CL:DEFVAR KWD-QUERY-SPECIALIST NULL)
(CL:DEFVAR KWD-QUERY-ATOMIC-GOAL NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ANTECEDENTS-RULE NULL)
(CL:DEFVAR KWD-QUERY-UP-TRUE NULL)
(CL:DEFVAR KWD-QUERY-UP-FAIL NULL)
(CL:DEFVAR KWD-QUERY-AND NULL)
(CL:DEFVAR KWD-QUERY-GOAL-TREE NULL)
(CL:DEFVAR KWD-QUERY-FUNCTION NULL)
(CL:DEFVAR KWD-QUERY-OR NULL)
(CL:DEFVAR KWD-QUERY-NOT NULL)
(CL:DEFVAR KWD-QUERY-FULL-SUBQUERY NULL)
(CL:DEFVAR KWD-QUERY-ANTECEDENTS NULL)
(CL:DEFVAR SYM-QUERY-STELLA-ITERATOR NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-NN-PARTIAL-MATCH NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-MATCH-SCORE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-SUPPORT NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-BACK NULL)
(CL:DEFVAR KWD-QUERY-TRUE NULL)
(CL:DEFVAR KWD-QUERY-FAIL NULL)
(CL:DEFVAR KWD-QUERY-MOVE-DOWN NULL)
(CL:DEFVAR KWD-QUERY-FINAL-SUCCESS NULL)
(CL:DEFVAR KWD-QUERY-CONTINUING-SUCCESS NULL)
(CL:DEFVAR KWD-QUERY-FAILURE NULL)
(CL:DEFVAR KWD-QUERY-MOVE-IN-PLACE NULL)
(CL:DEFVAR KWD-QUERY-TIMEOUT NULL)
(CL:DEFVAR KWD-QUERY-PREDICATE NULL)
(CL:DEFVAR KWD-QUERY-EQUIVALENT NULL)
(CL:DEFVAR KWD-QUERY-IMPLIES NULL)
(CL:DEFVAR KWD-QUERY-SCAN-CACHED-BINDINGS NULL)
(CL:DEFVAR KWD-QUERY-FORALL NULL)
(CL:DEFVAR KWD-QUERY-EXISTS NULL)
(CL:DEFVAR KWD-QUERY-CONSTANT NULL)
(CL:DEFVAR KWD-QUERY-CLUSTERED-CONJUNCTION NULL)
(CL:DEFVAR KWD-QUERY-DISJUNCTIVE-IMPLICATION-INTRODUCTION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-FAIL NULL)
(CL:DEFVAR KWD-QUERY-DUPLICATE-GOALS-WITH-CACHING NULL)
(CL:DEFVAR KWD-QUERY-MANUFACTURE-SKOLEM NULL)
(CL:DEFVAR KWD-QUERY-FAILED-OVERLAY NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-?D1 NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-?D2 NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-DISJOINT NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-QUERY-060 NULL)
(CL:DEFVAR SYM-QUERY-STELLA-OR NULL)
(CL:DEFVAR SYM-QUERY-STELLA-AND NULL)
(CL:DEFVAR SYM-QUERY-PL-KERNEL-KB-CLASS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-REFUTATION-DISJOINT NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-QUERY-061 NULL)
(CL:DEFVAR SGT-QUERY-PL-KERNEL-KB-COLLECTIONOF NULL)
(CL:DEFVAR SGT-QUERY-PL-KERNEL-KB-MEMBER-OF NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SGT-QUERY-STELLA-COLLECTION NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-SKOLEM NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-DESCRIPTION-EXTENSION-ITERATOR NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-EXTENSION-ITERATOR NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-REFERENCE-PROPOSITION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-SUBCOLLECTION NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-SUBCOLLECTION-ITERATOR NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ALREADY-GENERATED-LIST NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ALREADY-GENERATED-TABLE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-REMOVING-DUPLICATES? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ITERATOR-VALUE-HOLDS-BY-DEFAULT? NULL)
(CL:DEFVAR KWD-QUERY-GOAL-CACHES NULL)
(CL:DEFVAR KWD-QUERY-EXECUTE-QUERY NULL)
(CL:DEFVAR KWD-QUERY-DESCRIPTION NULL)
(CL:DEFVAR SYM-QUERY-STELLA-TRUE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-KAPPA NULL)
(CL:DEFVAR SYM-QUERY-STELLA-EXISTS NULL)
(CL:DEFVAR KWD-QUERY-ERROR NULL)
(CL:DEFVAR KWD-QUERY-SINGLETONS? NULL)
(CL:DEFVAR KWD-QUERY-DONT-OPTIMIZE? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-DONT-OPTIMIZE? NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-ASK NULL)
(CL:DEFVAR KWD-QUERY-COMMON-LISP NULL)
(CL:DEFVAR SGT-QUERY-STELLA-CONS NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-RETRIEVE NULL)
(CL:DEFVAR SGT-QUERY-PL-KERNEL-KB-CLASS-PROTOTYPE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-?C NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-?P NULL)
(CL:DEFVAR SYM-QUERY-PL-KERNEL-KB-CLASS-PROTOTYPE NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-QUERY-065 NULL)
(CL:DEFVAR KWD-QUERY-EXTENSIONAL-ASSERTION NULL)
(CL:DEFVAR KWD-QUERY-META NULL)
(CL:DEFVAR SGT-QUERY-STELLA-RELATION NULL)
(CL:DEFVAR SGT-QUERY-STELLA-VECTOR NULL)
(CL:DEFVAR SYM-QUERY-LOGIC-STARTUP-QUERY NULL)
(CL:DEFVAR SYM-QUERY-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *LAZY-SATELLITE-RULES?*
  *INFERABLE-CACHE-ENABLED?* *DISJOINTNESS-CACHE-ENABLED?*
  *CACHE-GOAL-QUANTUM* *CACHE-INFERABLE-SUBCOLLECTIONS?*
  *LAST-DYNAMIC-CUTOFF* *MOST-RECENT-QUERY* *MODULE*
  DEFAULT-TRUE-TRUTH-VALUE TRUE-TRUTH-VALUE *PRINTREADABLY?*
  NIL-PAGING-INDEX NIL-LIST ZERO-WRAPPER *RECORD-JUSTIFICATIONS?*
  *CACHE-SUCCEEDED-GOALS?* *CACHE-FAILED-GOALS?* STANDARD-ERROR *CONTEXT*
  *PARTIAL-SUPPORT-COUNTER* NULL-FLOAT-WRAPPER *FAIL-UNBOUND-CLAUSES*
  ONE-WRAPPER *RECYCLE-LISTS-MAINTENANCE-TIMER* *RECYCLING-ENABLED?*
  *RECYCLE-LIST-FOR-PATTERN-RECORD-S* STANDARD-OUTPUT TRUE-WRAPPER
  FALSE-WRAPPER *TRACED-KEYWORDS* *CURRENT-POWERLOOM-FEATURES* EOL))

;;; (DEFCLASS INFERENCE-LEVEL ...)

(CL:DEFCLASS INFERENCE-LEVEL (STANDARD-OBJECT)
  ((KEYWORD :ALLOCATION :INSTANCE :ACCESSOR %KEYWORD))
  (:DOCUMENTATION "This class hierarchy is used to choose the
level of inference applied when dispatching queries (canned
or ad hoc)."))

(CL:DEFUN NEW-INFERENCE-LEVEL ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INFERENCE-LEVEL)))
   (CL:SETF (%KEYWORD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INFERENCE-LEVEL))
  SGT-QUERY-LOGIC-INFERENCE-LEVEL)

(CL:DEFUN ACCESS-INFERENCE-LEVEL-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-STELLA-KEYWORD)
    (CL:IF SETVALUE? (CL:SETF (%KEYWORD SELF) VALUE)
     (CL:SETQ VALUE (%KEYWORD SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFCLASS NORMAL-INFERENCE-LEVEL ...)

(CL:DEFCLASS NORMAL-INFERENCE-LEVEL (INFERENCE-LEVEL)
  ()
  (:DOCUMENTATION "The normal inference level employs all proof strategies
except disjunctive implication introduction and refutation."))

(CL:DEFUN NEW-NORMAL-INFERENCE-LEVEL ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE NORMAL-INFERENCE-LEVEL)))
   (CL:SETF (%KEYWORD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF NORMAL-INFERENCE-LEVEL))
  SGT-QUERY-LOGIC-NORMAL-INFERENCE-LEVEL)

;;; (DEFCLASS BACKTRACKING-INFERENCE-LEVEL ...)

(CL:DEFCLASS BACKTRACKING-INFERENCE-LEVEL (NORMAL-INFERENCE-LEVEL)
  ()
  (:DOCUMENTATION
   "Specifies subsumption level inference plus backtracking."))

(CL:DEFUN NEW-BACKTRACKING-INFERENCE-LEVEL ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE BACKTRACKING-INFERENCE-LEVEL)))
   (CL:SETF (%KEYWORD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF BACKTRACKING-INFERENCE-LEVEL))
  SGT-QUERY-LOGIC-BACKTRACKING-INFERENCE-LEVEL)

;;; (DEFCLASS SUBSUMPTION-INFERENCE-LEVEL ...)

(CL:DEFCLASS SUBSUMPTION-INFERENCE-LEVEL (BACKTRACKING-INFERENCE-LEVEL)
  ()
  (:DOCUMENTATION "Specifies lookup augmented with cached
subsumption links and equality reasoning."))

(CL:DEFUN NEW-SUBSUMPTION-INFERENCE-LEVEL ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE SUBSUMPTION-INFERENCE-LEVEL)))
   (CL:SETF (%KEYWORD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SUBSUMPTION-INFERENCE-LEVEL))
  SGT-QUERY-LOGIC-SUBSUMPTION-INFERENCE-LEVEL)

;;; (DEFCLASS SHALLOW-INFERENCE-LEVEL ...)

(CL:DEFCLASS SHALLOW-INFERENCE-LEVEL (SUBSUMPTION-INFERENCE-LEVEL)
  ()
  (:DOCUMENTATION
   "Specifies lookup of assertions plus simple frame computations."))

(CL:DEFUN NEW-SHALLOW-INFERENCE-LEVEL ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SHALLOW-INFERENCE-LEVEL)))
   (CL:SETF (%KEYWORD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SHALLOW-INFERENCE-LEVEL))
  SGT-QUERY-LOGIC-SHALLOW-INFERENCE-LEVEL)

;;; (DEFCLASS ASSERTION-INFERENCE-LEVEL ...)

(CL:DEFCLASS ASSERTION-INFERENCE-LEVEL (SUBSUMPTION-INFERENCE-LEVEL)
  ()
  (:DOCUMENTATION "Specifies lookup of assertions only."))

(CL:DEFUN NEW-ASSERTION-INFERENCE-LEVEL ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE ASSERTION-INFERENCE-LEVEL)))
   (CL:SETF (%KEYWORD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ASSERTION-INFERENCE-LEVEL))
  SGT-QUERY-LOGIC-ASSERTION-INFERENCE-LEVEL)

;;; (DEFCLASS REFUTATION-INFERENCE-LEVEL ...)

(CL:DEFCLASS REFUTATION-INFERENCE-LEVEL (NORMAL-INFERENCE-LEVEL)
  ()
  (:DOCUMENTATION
   "Normal inference augmented by refutation proof strategy."))

(CL:DEFUN NEW-REFUTATION-INFERENCE-LEVEL ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE REFUTATION-INFERENCE-LEVEL)))
   (CL:SETF (%KEYWORD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF REFUTATION-INFERENCE-LEVEL))
  SGT-QUERY-LOGIC-REFUTATION-INFERENCE-LEVEL)

;;; (DEFGLOBAL NORMAL-INFERENCE ...)

(CL:DEFVAR NORMAL-INFERENCE NULL)

;;; (DEFGLOBAL BACKTRACKING-INFERENCE ...)

(CL:DEFVAR BACKTRACKING-INFERENCE NULL)

;;; (DEFGLOBAL SUBSUMPTION-INFERENCE ...)

(CL:DEFVAR SUBSUMPTION-INFERENCE NULL)

;;; (DEFGLOBAL SHALLOW-INFERENCE ...)

(CL:DEFVAR SHALLOW-INFERENCE NULL)

;;; (DEFGLOBAL ASSERTION-INFERENCE ...)

(CL:DEFVAR ASSERTION-INFERENCE NULL)

;;; (DEFGLOBAL REFUTATION-INFERENCE ...)

(CL:DEFVAR REFUTATION-INFERENCE NULL)

;;; (DEFSPECIAL *INFERENCELEVEL* ...)

(CL:DEFVAR *INFERENCELEVEL* NULL
  "Specifies the level/depth of inference applied
during a query.  Possible values are:
  :ASSERTION -- database lookup with no inheritance;
  :SHALLOW -- includes database lookup, computed predicates and specialists;
  :SUBSUMPTION -- shallow plus cached subsumption links and equality reasoning;
  :BACKTRACKING -- all of the above plus backtracking over rules;
  :NORMAL -- all of the above plus universal introduction;
  :REFUTATION -- all of the above plus disjunctive implication introduction and refutation.")

;;; (DEFUN (CURRENT-INFERENCE-LEVEL NORMAL-INFERENCE-LEVEL) ...)

(CL:DEFUN CURRENT-INFERENCE-LEVEL ()
  *INFERENCELEVEL*)

;;; (DEFUN (GET-INFERENCE-LEVEL INFERENCE-LEVEL) ...)

(CL:DEFUN GET-INFERENCE-LEVEL (LEVELKEYWORD)
  (CL:COND
   ((CL:EQ LEVELKEYWORD KWD-QUERY-NORMAL)
    (CL:RETURN-FROM GET-INFERENCE-LEVEL NORMAL-INFERENCE))
   ((CL:EQ LEVELKEYWORD KWD-QUERY-SHALLOW)
    (CL:RETURN-FROM GET-INFERENCE-LEVEL SHALLOW-INFERENCE))
   ((CL:EQ LEVELKEYWORD KWD-QUERY-ASSERTION)
    (CL:RETURN-FROM GET-INFERENCE-LEVEL ASSERTION-INFERENCE))
   ((CL:EQ LEVELKEYWORD KWD-QUERY-SUBSUMPTION)
    (CL:RETURN-FROM GET-INFERENCE-LEVEL SUBSUMPTION-INFERENCE))
   ((CL:EQ LEVELKEYWORD KWD-QUERY-BACKTRACKING)
    (CL:RETURN-FROM GET-INFERENCE-LEVEL BACKTRACKING-INFERENCE))
   ((CL:EQ LEVELKEYWORD KWD-QUERY-REFUTATION)
    (CL:RETURN-FROM GET-INFERENCE-LEVEL REFUTATION-INFERENCE))
   (CL:T
    (CL:WARN
     "Illegal inference level: `~A'.~%   Legal values are :ASSERTION :SHALLOW :SUBSUMPTION :BACKTRACKING :NORMAL :REFUTATION.~%"
     LEVELKEYWORD)))
  *INFERENCELEVEL*)

;;; (DEFUN (SET-INFERENCE-LEVEL KEYWORD) ...)

(CL:DEFUN SET-INFERENCE-LEVEL (LEVELKEYWORD)
  (CL:SETQ *INFERENCELEVEL* (GET-INFERENCE-LEVEL LEVELKEYWORD))
  (%KEYWORD *INFERENCELEVEL*))

;;; (DEFSPECIAL *DONTUSEDEFAULTKNOWLEDGE?* ...)

(CL:DEFVAR *DONTUSEDEFAULTKNOWLEDGE?* FALSE
  "Controls whether queries use default knowledge or not.")

;;; (DEFUN (USING-DEFAULT-KNOWLEDGE? BOOLEAN) ...)

(CL:DEFUN USING-DEFAULT-KNOWLEDGE? ()
  (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*))

;;; (DEFGLOBAL *MAXIMUM-BACKTRACKING-DEPTH* ...)

(CL:PROGN (CL:DEFVAR *MAXIMUM-BACKTRACKING-DEPTH* NULL-INTEGER "Value for the maximum depth allowable during
backtrack search.") (CL:DECLAIM (CL:TYPE CL:FIXNUM *MAXIMUM-BACKTRACKING-DEPTH*)))

;;; (DEFGLOBAL *TYPE-CHECK-STRATEGY* ...)

(CL:DEFVAR *TYPE-CHECK-STRATEGY* NULL
  "Determines whether there is a slow but thorough type test
when variables are bound, a fast but very shallow one, or none.  Values
are :NONE, :LOOKUP, :DISJOINT.  The default is ::LOOKUP.")

;;; (DEFGLOBAL *DUPLICATE-SUBGOAL-STRATEGY* ...)

(CL:DEFVAR *DUPLICATE-SUBGOAL-STRATEGY* NULL
  "Determines what kind of duplicate subgoal test to use.  Choices
are :DUPLICATE-RULES, :DUPLICATE-GOALS, and :DUPLICATE-GOALS-WITH-CACHING.")

;;; (DEFGLOBAL *DUPLICATE-GOAL-SEARCH-DEPTH* ...)

(CL:PROGN (CL:DEFVAR *DUPLICATE-GOAL-SEARCH-DEPTH* NULL-INTEGER "Sets the maximum number of frames search looking for
a duplicate subgoal.  Default value is infinite.  Possibly this should
be replaced by a function that increases with depth of search.") (CL:DECLAIM (CL:TYPE CL:FIXNUM *DUPLICATE-GOAL-SEARCH-DEPTH*)))

;;; (DEFGLOBAL *DUPLICATE-RULE-SEARCH-DEPTH* ...)

(CL:PROGN (CL:DEFVAR *DUPLICATE-RULE-SEARCH-DEPTH* NULL-INTEGER "Set limit on number of frames searched looking for
a duplicate rule.  Default value is infinite.") (CL:DECLAIM (CL:TYPE CL:FIXNUM *DUPLICATE-RULE-SEARCH-DEPTH*)))

;;; (DEFGLOBAL *GLOBALLY-CLOSED-COLLECTIONS?* ...)

(CL:DEFVAR *GLOBALLY-CLOSED-COLLECTIONS?* FALSE
  "If TRUE, all collections are assumed to be closed.")

;;; (DEFSPECIAL *GENERATE-ALL-PROOFS?* ...)

(CL:DEFVAR *GENERATE-ALL-PROOFS?* FALSE
  "If TRUE, the backchainer follows all lines of proof
for each goal, rather than switching to a new goal once the first proof
of a goal is achieved.  The partial matcher sets this variable to
TRUE to force generation of proofs having possibly different
weights.")

;;; (DEFUN TRACE-SUBGOALS ...)

(CL:DEFUN TRACE-SUBGOALS ()
  (%SET-FEATURE (CONS-LIST KWD-QUERY-TRACE-SUBGOALS)))

;;; (DEFUN UNTRACE-SUBGOALS ...)

(CL:DEFUN UNTRACE-SUBGOALS ()
  (%UNSET-FEATURE (CONS-LIST KWD-QUERY-TRACE-SUBGOALS)))

;;; (DEFUN TRACE-RULES ...)

(CL:DEFUN TRACE-RULES ()
  (%ADD-TRACE (CONS-LIST KWD-QUERY-PROPAGATE)))

;;; (DEFUN UNTRACE-RULES ...)

(CL:DEFUN UNTRACE-RULES ()
  (%DROP-TRACE (CONS-LIST KWD-QUERY-PROPAGATE)))

;;; (DEFUN (TOGGLE-TRACE-SUBGOALS STRING) ...)

(CL:DEFUN TOGGLE-TRACE-SUBGOALS ()
  (CL:IF (MEMBER? *CURRENT-POWERLOOM-FEATURES* KWD-QUERY-TRACE-SUBGOALS)
   (CL:PROGN (%UNSET-FEATURE (CONS-LIST KWD-QUERY-TRACE-SUBGOALS))
    (%DROP-TRACE (CONS-LIST KWD-QUERY-STRATEGIES))
    "Subgoal tracing disabled.")
   (CL:PROGN (%SET-FEATURE (CONS-LIST KWD-QUERY-TRACE-SUBGOALS))
    (%ADD-TRACE (CONS-LIST KWD-QUERY-STRATEGIES))
    "Subgoal tracing enabled.")))

;;; (DEFUN (TOGGLE-TRACE-RULES STRING) ...)

(CL:DEFUN TOGGLE-TRACE-RULES ()
  (CL:IF (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-PROPAGATE)
   (CL:PROGN (%DROP-TRACE (CONS-LIST KWD-QUERY-PROPAGATE))
    "Rule tracing disabled.")
   (CL:PROGN (%ADD-TRACE (CONS-LIST KWD-QUERY-PROPAGATE))
    "Rule tracing enabled.")))

;;; (DEFCLASS QUERY-ITERATOR ...)

(CL:DEFCLASS QUERY-ITERATOR (ITERATOR)
  ((EXTERNAL-VARIABLES :ALLOCATION :INSTANCE :ACCESSOR
    %EXTERNAL-VARIABLES)
   (SOLUTIONS :ALLOCATION :INSTANCE :ACCESSOR %SOLUTIONS)
   (EXHAUSTED? :ALLOCATION :INSTANCE :ACCESSOR %EXHAUSTED?)
   (NEGATED-QUERY :ALLOCATION :INSTANCE :ACCESSOR %NEGATED-QUERY)
   (ATOMIC-SINGLETONS? :ALLOCATION :INSTANCE :ACCESSOR
    %ATOMIC-SINGLETONS?)
   (QUERY-CONTEXT :ALLOCATION :INSTANCE :ACCESSOR %QUERY-CONTEXT)
   (BASE-CONTROL-FRAME :ALLOCATION :INSTANCE :ACCESSOR
    %BASE-CONTROL-FRAME)
   (CURRENT-CONTROL-FRAME :ALLOCATION :INSTANCE :ACCESSOR
    %CURRENT-CONTROL-FRAME)
   (CURRENT-PATTERN-RECORD :ALLOCATION :INSTANCE :ACCESSOR
    %CURRENT-PATTERN-RECORD)
   (CURRENT-PARALLEL-THREAD :ALLOCATION :INSTANCE :ACCESSOR
    %CURRENT-PARALLEL-THREAD)
   (PARTIAL-MATCH-STRATEGY :ALLOCATION :INSTANCE :ACCESSOR
    %PARTIAL-MATCH-STRATEGY)
   (CONTROL-FRAME-PRIORITY-QUEUE :ALLOCATION :INSTANCE :ACCESSOR
    %CONTROL-FRAME-PRIORITY-QUEUE)
   (ITERATIVE-DEEPENING? :ALLOCATION :INSTANCE :ACCESSOR
    %ITERATIVE-DEEPENING?)
   (CURRENT-DEPTH-CUTOFF :ALLOCATION :INSTANCE :ACCESSOR
    %CURRENT-DEPTH-CUTOFF)
   (MAXIMUM-DEPTH :ALLOCATION :INSTANCE :ACCESSOR %MAXIMUM-DEPTH)
   (AUGMENTED-GOAL-CACHE? :ALLOCATION :INSTANCE :ACCESSOR
    %AUGMENTED-GOAL-CACHE?)
   (ACTIVE-GOAL-CACHES :ALLOCATION :INSTANCE :ACCESSOR
    %ACTIVE-GOAL-CACHES)
   (TRIGGERED-DEPTH-CUTOFF? :ALLOCATION :INSTANCE :ACCESSOR
    %TRIGGERED-DEPTH-CUTOFF?)
   (FAILED-TO-FIND-DUPLICATE-SUBGOAL? :ALLOCATION :INSTANCE :ACCESSOR
    %FAILED-TO-FIND-DUPLICATE-SUBGOAL?)
   (FOUND-AT-LEAST-ONE-SOLUTION? :ALLOCATION :INSTANCE :ACCESSOR
    %FOUND-AT-LEAST-ONE-SOLUTION?)
   (QUERY-THREAD-OFFSET :ALLOCATION :INSTANCE :ACCESSOR
    %QUERY-THREAD-OFFSET)
   (TIMESTAMP :ALLOCATION :INSTANCE :ACCESSOR %TIMESTAMP)
   (LATEST-TOUCHED-DEFAULT? :ALLOCATION :INSTANCE :ACCESSOR
    %LATEST-TOUCHED-DEFAULT?)
   (TRUTH-VALUES :ALLOCATION :INSTANCE :ACCESSOR %TRUTH-VALUES)
   (LATEST-POSITIVE-SCORE :ALLOCATION :INSTANCE :ACCESSOR
    %LATEST-POSITIVE-SCORE)
   (LATEST-PARTIAL-SCORE :ALLOCATION :INSTANCE :ACCESSOR
    %LATEST-PARTIAL-SCORE)
   (MATCH-SCORES :ALLOCATION :INSTANCE :ACCESSOR %MATCH-SCORES)
   (OPTIMIZER-GOAL-RECORDS :ALLOCATION :INSTANCE :ACCESSOR
    %OPTIMIZER-GOAL-RECORDS)
   (RESIDUE-GOALS :ALLOCATION :INSTANCE :ACCESSOR %RESIDUE-GOALS)
   (BEST-GOAL-SEQUENCE :ALLOCATION :INSTANCE :ACCESSOR
    %BEST-GOAL-SEQUENCE)
   (BEST-COST :ALLOCATION :INSTANCE :ACCESSOR %BEST-COST)
   (ALLOTTED-TIME :ALLOCATION :INSTANCE :ACCESSOR %ALLOTTED-TIME)
   (TIMEOUT? :ALLOCATION :INSTANCE :ACCESSOR %TIMEOUT?))
  (:DOCUMENTATION "A query iterator points to a query environment
representing the initial or intermediate state of a query.  The iterator's
'value' is a vector representing a satisfying set bindings of the query's
output variables.  Each call to the iterator writes a new set of bindings
into the vector."))

(CL:DEFUN NEW-QUERY-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE QUERY-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) TRUE) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%TIMEOUT? SELF) FALSE)
   (CL:SETF (%ALLOTTED-TIME SELF) NULL-FLOAT)
   (CL:SETF (%BEST-COST SELF) NULL-FLOAT)
   (CL:SETF (%BEST-GOAL-SEQUENCE SELF) (NEW-LIST))
   (CL:SETF (%RESIDUE-GOALS SELF) (NEW-LIST))
   (CL:SETF (%OPTIMIZER-GOAL-RECORDS SELF) NULL)
   (CL:SETF (%MATCH-SCORES SELF) (NEW-LIST))
   (CL:SETF (%LATEST-PARTIAL-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%LATEST-POSITIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%TRUTH-VALUES SELF) (NEW-LIST))
   (CL:SETF (%LATEST-TOUCHED-DEFAULT? SELF) FALSE)
   (CL:SETF (%TIMESTAMP SELF) NULL-INTEGER)
   (CL:SETF (%QUERY-THREAD-OFFSET SELF) NULL-INTEGER)
   (CL:SETF (%FOUND-AT-LEAST-ONE-SOLUTION? SELF) FALSE)
   (CL:SETF (%FAILED-TO-FIND-DUPLICATE-SUBGOAL? SELF) FALSE)
   (CL:SETF (%TRIGGERED-DEPTH-CUTOFF? SELF) FALSE)
   (CL:SETF (%ACTIVE-GOAL-CACHES SELF) (NEW-LIST))
   (CL:SETF (%AUGMENTED-GOAL-CACHE? SELF) FALSE)
   (CL:SETF (%MAXIMUM-DEPTH SELF) NULL-INTEGER)
   (CL:SETF (%CURRENT-DEPTH-CUTOFF SELF) NULL-INTEGER)
   (CL:SETF (%ITERATIVE-DEEPENING? SELF) FALSE)
   (CL:SETF (%CONTROL-FRAME-PRIORITY-QUEUE SELF) NULL)
   (CL:SETF (%PARTIAL-MATCH-STRATEGY SELF) NULL)
   (CL:SETF (%CURRENT-PARALLEL-THREAD SELF) NULL)
   (CL:SETF (%CURRENT-PATTERN-RECORD SELF) NULL)
   (CL:SETF (%CURRENT-CONTROL-FRAME SELF) NULL)
   (CL:SETF (%BASE-CONTROL-FRAME SELF) NULL)
   (CL:SETF (%QUERY-CONTEXT SELF) NULL)
   (CL:SETF (%ATOMIC-SINGLETONS? SELF) FALSE)
   (CL:SETF (%NEGATED-QUERY SELF) NULL) (CL:SETF (%EXHAUSTED? SELF) FALSE)
   (CL:SETF (%SOLUTIONS SELF) (NEW-LIST))
   (CL:SETF (%EXTERNAL-VARIABLES SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF QUERY-ITERATOR))
  SGT-QUERY-LOGIC-QUERY-ITERATOR)

(CL:DEFUN ACCESS-QUERY-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-EXTERNAL-VARIABLES)
    (CL:IF SETVALUE? (CL:SETF (%EXTERNAL-VARIABLES SELF) VALUE)
     (CL:SETQ VALUE (%EXTERNAL-VARIABLES SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-SOLUTIONS)
    (CL:IF SETVALUE? (CL:SETF (%SOLUTIONS SELF) VALUE)
     (CL:SETQ VALUE (%SOLUTIONS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-EXHAUSTED?)
    (CL:IF SETVALUE?
     (CL:SETF (%EXHAUSTED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%EXHAUSTED? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-NEGATED-QUERY)
    (CL:IF SETVALUE? (CL:SETF (%NEGATED-QUERY SELF) VALUE)
     (CL:SETQ VALUE (%NEGATED-QUERY SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ATOMIC-SINGLETONS?)
    (CL:IF SETVALUE?
     (CL:SETF (%ATOMIC-SINGLETONS? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%ATOMIC-SINGLETONS? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-QUERY-CONTEXT)
    (CL:IF SETVALUE? (CL:SETF (%QUERY-CONTEXT SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-CONTEXT SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-BASE-CONTROL-FRAME)
    (CL:IF SETVALUE? (CL:SETF (%BASE-CONTROL-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%BASE-CONTROL-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CURRENT-CONTROL-FRAME)
    (CL:IF SETVALUE? (CL:SETF (%CURRENT-CONTROL-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%CURRENT-CONTROL-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CURRENT-PATTERN-RECORD)
    (CL:IF SETVALUE? (CL:SETF (%CURRENT-PATTERN-RECORD SELF) VALUE)
     (CL:SETQ VALUE (%CURRENT-PATTERN-RECORD SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CURRENT-PARALLEL-THREAD)
    (CL:IF SETVALUE? (CL:SETF (%CURRENT-PARALLEL-THREAD SELF) VALUE)
     (CL:SETQ VALUE (%CURRENT-PARALLEL-THREAD SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-PARTIAL-MATCH-STRATEGY)
    (CL:IF SETVALUE? (CL:SETF (%PARTIAL-MATCH-STRATEGY SELF) VALUE)
     (CL:SETQ VALUE (%PARTIAL-MATCH-STRATEGY SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CONTROL-FRAME-PRIORITY-QUEUE)
    (CL:IF SETVALUE? (CL:SETF (%CONTROL-FRAME-PRIORITY-QUEUE SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME-PRIORITY-QUEUE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ITERATIVE-DEEPENING?)
    (CL:IF SETVALUE?
     (CL:SETF (%ITERATIVE-DEEPENING? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%ITERATIVE-DEEPENING? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CURRENT-DEPTH-CUTOFF)
    (CL:IF SETVALUE?
     (CL:SETF (%CURRENT-DEPTH-CUTOFF SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%CURRENT-DEPTH-CUTOFF SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-MAXIMUM-DEPTH)
    (CL:IF SETVALUE?
     (CL:SETF (%MAXIMUM-DEPTH SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%MAXIMUM-DEPTH SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-AUGMENTED-GOAL-CACHE?)
    (CL:IF SETVALUE?
     (CL:SETF (%AUGMENTED-GOAL-CACHE? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%AUGMENTED-GOAL-CACHE? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ACTIVE-GOAL-CACHES)
    (CL:IF SETVALUE? (CL:SETF (%ACTIVE-GOAL-CACHES SELF) VALUE)
     (CL:SETQ VALUE (%ACTIVE-GOAL-CACHES SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TRIGGERED-DEPTH-CUTOFF?)
    (CL:IF SETVALUE?
     (CL:SETF (%TRIGGERED-DEPTH-CUTOFF? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%TRIGGERED-DEPTH-CUTOFF? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-FAILED-TO-FIND-DUPLICATE-SUBGOAL?)
    (CL:IF SETVALUE?
     (CL:SETF (%FAILED-TO-FIND-DUPLICATE-SUBGOAL? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%FAILED-TO-FIND-DUPLICATE-SUBGOAL? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-FOUND-AT-LEAST-ONE-SOLUTION?)
    (CL:IF SETVALUE?
     (CL:SETF (%FOUND-AT-LEAST-ONE-SOLUTION? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%FOUND-AT-LEAST-ONE-SOLUTION? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-QUERY-THREAD-OFFSET)
    (CL:IF SETVALUE?
     (CL:SETF (%QUERY-THREAD-OFFSET SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%QUERY-THREAD-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TIMESTAMP)
    (CL:IF SETVALUE? (CL:SETF (%TIMESTAMP SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%TIMESTAMP SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-LATEST-TOUCHED-DEFAULT?)
    (CL:IF SETVALUE?
     (CL:SETF (%LATEST-TOUCHED-DEFAULT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%LATEST-TOUCHED-DEFAULT? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TRUTH-VALUES)
    (CL:IF SETVALUE? (CL:SETF (%TRUTH-VALUES SELF) VALUE)
     (CL:SETQ VALUE (%TRUTH-VALUES SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%LATEST-POSITIVE-SCORE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%LATEST-POSITIVE-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-LATEST-PARTIAL-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%LATEST-PARTIAL-SCORE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%LATEST-PARTIAL-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-MATCH-SCORES)
    (CL:IF SETVALUE? (CL:SETF (%MATCH-SCORES SELF) VALUE)
     (CL:SETQ VALUE (%MATCH-SCORES SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-OPTIMIZER-GOAL-RECORDS)
    (CL:IF SETVALUE? (CL:SETF (%OPTIMIZER-GOAL-RECORDS SELF) VALUE)
     (CL:SETQ VALUE (%OPTIMIZER-GOAL-RECORDS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-RESIDUE-GOALS)
    (CL:IF SETVALUE? (CL:SETF (%RESIDUE-GOALS SELF) VALUE)
     (CL:SETQ VALUE (%RESIDUE-GOALS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-BEST-GOAL-SEQUENCE)
    (CL:IF SETVALUE? (CL:SETF (%BEST-GOAL-SEQUENCE SELF) VALUE)
     (CL:SETQ VALUE (%BEST-GOAL-SEQUENCE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-BEST-COST)
    (CL:IF SETVALUE? (CL:SETF (%BEST-COST SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%BEST-COST SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ALLOTTED-TIME)
    (CL:IF SETVALUE?
     (CL:SETF (%ALLOTTED-TIME SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%ALLOTTED-TIME SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TIMEOUT?)
    (CL:IF SETVALUE?
     (CL:SETF (%TIMEOUT? SELF) (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE (CL:IF (%TIMEOUT? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF QUERY-ITERATOR) STREAM)
  (PRINT-QUERY-ITERATOR SELF STREAM))

;;; (DEFCLASS CONTROL-FRAME ...)

(CL:DEFCLASS CONTROL-FRAME (STANDARD-OBJECT)
  ((STATE :ALLOCATION :INSTANCE :ACCESSOR %STATE)
   (PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR %PROPOSITION)
   (REVERSE-POLARITY? :ALLOCATION :INSTANCE :ACCESSOR %REVERSE-POLARITY?)
   (UP :ALLOCATION :INSTANCE :ACCESSOR %UP)
   (DOWN :ALLOCATION :INSTANCE :ACCESSOR %DOWN)
   (ARGUMENT-CURSOR :ALLOCATION :INSTANCE :ACCESSOR %ARGUMENT-CURSOR)
   (PATTERN-RECORD :ALLOCATION :INSTANCE :ACCESSOR %PATTERN-RECORD)
   (INHERITED-PATTERN-RECORD :ALLOCATION :INSTANCE :ACCESSOR
    %INHERITED-PATTERN-RECORD)
   (CHOICE-POINT-UNBINDING-OFFSET :ALLOCATION :INSTANCE :ACCESSOR
    %CHOICE-POINT-UNBINDING-OFFSET)
   (CURRENT-STRATEGY :ALLOCATION :INSTANCE :ACCESSOR %CURRENT-STRATEGY)
   (NEXT-STRATEGIES :ALLOCATION :INSTANCE :ACCESSOR %NEXT-STRATEGIES)
   (HOLDS-BY-DEFAULT? :ALLOCATION :INSTANCE :ACCESSOR %HOLDS-BY-DEFAULT?)
   (PARTIAL-MATCH-FRAME :ALLOCATION :INSTANCE :ACCESSOR
    %PARTIAL-MATCH-FRAME)
   (DEBUG-FRAME-ID :ALLOCATION :INSTANCE :ACCESSOR %DEBUG-FRAME-ID)
   (DEBUG-DEPTH :ALLOCATION :INSTANCE :ACCESSOR %DEBUG-DEPTH)
   (JUSTIFICATIONS :ALLOCATION :INSTANCE :ACCESSOR %JUSTIFICATIONS)
   (JUSTIFICATION :ALLOCATION :INSTANCE :ACCESSOR %JUSTIFICATION)
   (CACHED-BINDINGS-ITERATOR :ALLOCATION :INSTANCE :ACCESSOR
    %CACHED-BINDINGS-ITERATOR)
   (GOAL-BINDINGS :ALLOCATION :INSTANCE :ACCESSOR %GOAL-BINDINGS)
   (GOAL-CACHE :ALLOCATION :INSTANCE :ACCESSOR %GOAL-CACHE)
   (BINDINGS-COUNTER :ALLOCATION :INSTANCE :ACCESSOR %BINDINGS-COUNTER)
   (CACHED-SINGLE-VALUED? :ALLOCATION :INSTANCE :ACCESSOR
    %CACHED-SINGLE-VALUED?)
   (STARTING-CLOCK-TICKS :ALLOCATION :INSTANCE :ACCESSOR
    %STARTING-CLOCK-TICKS)
   (DONT-CACHE-GOAL-FAILURE? :ALLOCATION :INSTANCE :ACCESSOR
    %DONT-CACHE-GOAL-FAILURE?)
   (DYNAMIC-SLOTS :ALLOCATION :INSTANCE :ACCESSOR %DYNAMIC-SLOTS)))

(CL:DEFUN NEW-CONTROL-FRAME ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CONTROL-FRAME)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%DONT-CACHE-GOAL-FAILURE? SELF) FALSE)
   (CL:SETF (%STARTING-CLOCK-TICKS SELF) NULL-INTEGER)
   (CL:SETF (%CACHED-SINGLE-VALUED? SELF) FALSE)
   (CL:SETF (%BINDINGS-COUNTER SELF) NULL-INTEGER)
   (CL:SETF (%GOAL-CACHE SELF) NULL) (CL:SETF (%GOAL-BINDINGS SELF) NULL)
   (CL:SETF (%CACHED-BINDINGS-ITERATOR SELF) NULL)
   (CL:SETF (%JUSTIFICATION SELF) NULL)
   (CL:SETF (%JUSTIFICATIONS SELF) (NEW-LIST))
   (CL:SETF (%DEBUG-DEPTH SELF) 0)
   (CL:SETF (%DEBUG-FRAME-ID SELF) NULL-INTEGER)
   (CL:SETF (%PARTIAL-MATCH-FRAME SELF) NULL)
   (CL:SETF (%HOLDS-BY-DEFAULT? SELF) FALSE)
   (CL:SETF (%NEXT-STRATEGIES SELF) NIL)
   (CL:SETF (%CURRENT-STRATEGY SELF) NULL)
   (CL:SETF (%CHOICE-POINT-UNBINDING-OFFSET SELF) NULL-INTEGER)
   (CL:SETF (%INHERITED-PATTERN-RECORD SELF) NULL)
   (CL:SETF (%PATTERN-RECORD SELF) NULL)
   (CL:SETF (%ARGUMENT-CURSOR SELF) 0) (CL:SETF (%DOWN SELF) NULL)
   (CL:SETF (%UP SELF) NULL) (CL:SETF (%REVERSE-POLARITY? SELF) FALSE)
   (CL:SETF (%PROPOSITION SELF) NULL) (CL:SETF (%STATE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CONTROL-FRAME))
  SGT-QUERY-LOGIC-CONTROL-FRAME)

(CL:DEFMETHOD BAD? ((SELF CONTROL-FRAME))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SYM-QUERY-STELLA-BAD?
      NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:IF FALSE TRUE-WRAPPER FALSE-WRAPPER)
    ANSWER)))

(CL:DEFUN ACCESS-CONTROL-FRAME-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-STELLA-STATE)
    (CL:IF SETVALUE? (CL:SETF (%STATE SELF) VALUE)
     (CL:SETQ VALUE (%STATE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-REVERSE-POLARITY?)
    (CL:IF SETVALUE?
     (CL:SETF (%REVERSE-POLARITY? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%REVERSE-POLARITY? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-UP)
    (CL:IF SETVALUE? (CL:SETF (%UP SELF) VALUE)
     (CL:SETQ VALUE (%UP SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-DOWN)
    (CL:IF SETVALUE? (CL:SETF (%DOWN SELF) VALUE)
     (CL:SETQ VALUE (%DOWN SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ARGUMENT-CURSOR)
    (CL:IF SETVALUE?
     (CL:SETF (%ARGUMENT-CURSOR SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%ARGUMENT-CURSOR SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-PATTERN-RECORD)
    (CL:IF SETVALUE? (CL:SETF (%PATTERN-RECORD SELF) VALUE)
     (CL:SETQ VALUE (%PATTERN-RECORD SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-INHERITED-PATTERN-RECORD)
    (CL:IF SETVALUE? (CL:SETF (%INHERITED-PATTERN-RECORD SELF) VALUE)
     (CL:SETQ VALUE (%INHERITED-PATTERN-RECORD SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CHOICE-POINT-UNBINDING-OFFSET)
    (CL:IF SETVALUE?
     (CL:SETF (%CHOICE-POINT-UNBINDING-OFFSET SELF)
      (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%CHOICE-POINT-UNBINDING-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CURRENT-STRATEGY)
    (CL:IF SETVALUE? (CL:SETF (%CURRENT-STRATEGY SELF) VALUE)
     (CL:SETQ VALUE (%CURRENT-STRATEGY SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-NEXT-STRATEGIES)
    (CL:IF SETVALUE? (CL:SETF (%NEXT-STRATEGIES SELF) VALUE)
     (CL:SETQ VALUE (%NEXT-STRATEGIES SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-HOLDS-BY-DEFAULT?)
    (CL:IF SETVALUE?
     (CL:SETF (%HOLDS-BY-DEFAULT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%HOLDS-BY-DEFAULT? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-PARTIAL-MATCH-FRAME)
    (CL:IF SETVALUE? (CL:SETF (%PARTIAL-MATCH-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%PARTIAL-MATCH-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-DEBUG-FRAME-ID)
    (CL:IF SETVALUE?
     (CL:SETF (%DEBUG-FRAME-ID SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%DEBUG-FRAME-ID SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-DEBUG-DEPTH)
    (CL:IF SETVALUE? (CL:SETF (%DEBUG-DEPTH SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%DEBUG-DEPTH SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-JUSTIFICATIONS)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATIONS SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATIONS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-JUSTIFICATION)
    (CL:IF SETVALUE? (CL:SETF (%JUSTIFICATION SELF) VALUE)
     (CL:SETQ VALUE (%JUSTIFICATION SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CACHED-BINDINGS-ITERATOR)
    (CL:IF SETVALUE? (CL:SETF (%CACHED-BINDINGS-ITERATOR SELF) VALUE)
     (CL:SETQ VALUE (%CACHED-BINDINGS-ITERATOR SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-GOAL-BINDINGS)
    (CL:IF SETVALUE? (CL:SETF (%GOAL-BINDINGS SELF) VALUE)
     (CL:SETQ VALUE (%GOAL-BINDINGS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-GOAL-CACHE)
    (CL:IF SETVALUE? (CL:SETF (%GOAL-CACHE SELF) VALUE)
     (CL:SETQ VALUE (%GOAL-CACHE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-BINDINGS-COUNTER)
    (CL:IF SETVALUE?
     (CL:SETF (%BINDINGS-COUNTER SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%BINDINGS-COUNTER SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CACHED-SINGLE-VALUED?)
    (CL:IF SETVALUE?
     (CL:SETF (%CACHED-SINGLE-VALUED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CACHED-SINGLE-VALUED? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-STARTING-CLOCK-TICKS)
    (CL:IF SETVALUE?
     (CL:SETF (%STARTING-CLOCK-TICKS SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%STARTING-CLOCK-TICKS SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-DONT-CACHE-GOAL-FAILURE?)
    (CL:IF SETVALUE?
     (CL:SETF (%DONT-CACHE-GOAL-FAILURE? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%DONT-CACHE-GOAL-FAILURE? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

(CL:DEFMETHOD DELETED? ((SELF CONTROL-FRAME))
  (CL:LET*
   ((DELETED?
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-QUERY-STELLA-DELETED-OBJECT? NULL)))
   (CL:IF (CL:NOT (CL:EQ DELETED? NULL))
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN DELETED?) FALSE)))

(CL:DEFMETHOD DELETED?-SETTER ((SELF CONTROL-FRAME) VALUE)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-QUERY-STELLA-DELETED-OBJECT?
   (CL:IF VALUE TRUE-WRAPPER FALSE-WRAPPER) NULL)
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF CONTROL-FRAME) STREAM)
  (PRINT-CONTROL-FRAME SELF STREAM))

;;; (DEFCLASS PARALLEL-THREAD ...)

(CL:DEFCLASS PARALLEL-THREAD (STANDARD-OBJECT)
  ((TOP-CONTROL-FRAME :ALLOCATION :INSTANCE :ACCESSOR %TOP-CONTROL-FRAME)
   (HYPOTHETICAL-WORLD :ALLOCATION :INSTANCE :ACCESSOR
    %HYPOTHETICAL-WORLD)
   (VARIABLE-BINDINGS :ALLOCATION :INSTANCE :ACCESSOR %VARIABLE-BINDINGS)
   (UNBINDING-STACK :ALLOCATION :INSTANCE :ACCESSOR %UNBINDING-STACK)
   (TOP-UNBINDING-STACK-OFFSET :ALLOCATION :INSTANCE :ACCESSOR
    %TOP-UNBINDING-STACK-OFFSET)
   (PRIORITY :ALLOCATION :INSTANCE :ACCESSOR %PRIORITY)
   (STATUS :ALLOCATION :INSTANCE :ACCESSOR %STATUS)))

(CL:DEFUN NEW-PARALLEL-THREAD ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PARALLEL-THREAD)))
   (CL:SETF (%STATUS SELF) NULL) (CL:SETF (%PRIORITY SELF) NULL-INTEGER)
   (CL:SETF (%TOP-UNBINDING-STACK-OFFSET SELF) NULL-INTEGER)
   (CL:SETF (%UNBINDING-STACK SELF) NULL)
   (CL:SETF (%VARIABLE-BINDINGS SELF) NULL)
   (CL:SETF (%HYPOTHETICAL-WORLD SELF) NULL)
   (CL:SETF (%TOP-CONTROL-FRAME SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PARALLEL-THREAD))
  SGT-QUERY-LOGIC-PARALLEL-THREAD)

(CL:DEFUN ACCESS-PARALLEL-THREAD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TOP-CONTROL-FRAME)
    (CL:IF SETVALUE? (CL:SETF (%TOP-CONTROL-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%TOP-CONTROL-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-HYPOTHETICAL-WORLD)
    (CL:IF SETVALUE? (CL:SETF (%HYPOTHETICAL-WORLD SELF) VALUE)
     (CL:SETQ VALUE (%HYPOTHETICAL-WORLD SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-VARIABLE-BINDINGS)
    (CL:IF SETVALUE? (CL:SETF (%VARIABLE-BINDINGS SELF) VALUE)
     (CL:SETQ VALUE (%VARIABLE-BINDINGS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-UNBINDING-STACK)
    (CL:IF SETVALUE? (CL:SETF (%UNBINDING-STACK SELF) VALUE)
     (CL:SETQ VALUE (%UNBINDING-STACK SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TOP-UNBINDING-STACK-OFFSET)
    (CL:IF SETVALUE?
     (CL:SETF (%TOP-UNBINDING-STACK-OFFSET SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%TOP-UNBINDING-STACK-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-PRIORITY)
    (CL:IF SETVALUE? (CL:SETF (%PRIORITY SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%PRIORITY SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-STATUS)
    (CL:IF SETVALUE? (CL:SETF (%STATUS SELF) VALUE)
     (CL:SETQ VALUE (%STATUS SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFCLASS PARALLEL-CONTROL-FRAME ...)

(CL:DEFCLASS PARALLEL-CONTROL-FRAME (CONTROL-FRAME)
  ((CHILD-THREADS :ALLOCATION :INSTANCE :ACCESSOR %CHILD-THREADS)
   (UNBOUND-VARIABLES? :ALLOCATION :INSTANCE :ACCESSOR
    %UNBOUND-VARIABLES?)
   (CURRENT-CHILD-THREAD :ALLOCATION :INSTANCE :ACCESSOR
    %CURRENT-CHILD-THREAD)
   (SAVED-PARENT-CONTEXT :ALLOCATION :INSTANCE :ACCESSOR
    %SAVED-PARENT-CONTEXT)
   (SAVED-PARENT-PARALLEL-THREAD :ALLOCATION :INSTANCE :ACCESSOR
    %SAVED-PARENT-PARALLEL-THREAD)))

(CL:DEFUN NEW-PARALLEL-CONTROL-FRAME ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PARALLEL-CONTROL-FRAME)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%DONT-CACHE-GOAL-FAILURE? SELF) FALSE)
   (CL:SETF (%STARTING-CLOCK-TICKS SELF) NULL-INTEGER)
   (CL:SETF (%CACHED-SINGLE-VALUED? SELF) FALSE)
   (CL:SETF (%BINDINGS-COUNTER SELF) NULL-INTEGER)
   (CL:SETF (%GOAL-CACHE SELF) NULL) (CL:SETF (%GOAL-BINDINGS SELF) NULL)
   (CL:SETF (%CACHED-BINDINGS-ITERATOR SELF) NULL)
   (CL:SETF (%JUSTIFICATION SELF) NULL)
   (CL:SETF (%JUSTIFICATIONS SELF) (NEW-LIST))
   (CL:SETF (%DEBUG-DEPTH SELF) 0)
   (CL:SETF (%DEBUG-FRAME-ID SELF) NULL-INTEGER)
   (CL:SETF (%PARTIAL-MATCH-FRAME SELF) NULL)
   (CL:SETF (%HOLDS-BY-DEFAULT? SELF) FALSE)
   (CL:SETF (%NEXT-STRATEGIES SELF) NIL)
   (CL:SETF (%CURRENT-STRATEGY SELF) NULL)
   (CL:SETF (%CHOICE-POINT-UNBINDING-OFFSET SELF) NULL-INTEGER)
   (CL:SETF (%INHERITED-PATTERN-RECORD SELF) NULL)
   (CL:SETF (%PATTERN-RECORD SELF) NULL)
   (CL:SETF (%ARGUMENT-CURSOR SELF) 0) (CL:SETF (%DOWN SELF) NULL)
   (CL:SETF (%UP SELF) NULL) (CL:SETF (%REVERSE-POLARITY? SELF) FALSE)
   (CL:SETF (%PROPOSITION SELF) NULL) (CL:SETF (%STATE SELF) NULL)
   (CL:SETF (%SAVED-PARENT-PARALLEL-THREAD SELF) NULL)
   (CL:SETF (%SAVED-PARENT-CONTEXT SELF) NULL)
   (CL:SETF (%CURRENT-CHILD-THREAD SELF) NULL)
   (CL:SETF (%UNBOUND-VARIABLES? SELF) FALSE)
   (CL:SETF (%CHILD-THREADS SELF) (NEW-LIST)) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PARALLEL-CONTROL-FRAME))
  SGT-QUERY-LOGIC-PARALLEL-CONTROL-FRAME)

(CL:DEFUN ACCESS-PARALLEL-CONTROL-FRAME-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CHILD-THREADS)
    (CL:IF SETVALUE? (CL:SETF (%CHILD-THREADS SELF) VALUE)
     (CL:SETQ VALUE (%CHILD-THREADS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-UNBOUND-VARIABLES?)
    (CL:IF SETVALUE?
     (CL:SETF (%UNBOUND-VARIABLES? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%UNBOUND-VARIABLES? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CURRENT-CHILD-THREAD)
    (CL:IF SETVALUE? (CL:SETF (%CURRENT-CHILD-THREAD SELF) VALUE)
     (CL:SETQ VALUE (%CURRENT-CHILD-THREAD SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-SAVED-PARENT-CONTEXT)
    (CL:IF SETVALUE? (CL:SETF (%SAVED-PARENT-CONTEXT SELF) VALUE)
     (CL:SETQ VALUE (%SAVED-PARENT-CONTEXT SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-SAVED-PARENT-PARALLEL-THREAD)
    (CL:IF SETVALUE? (CL:SETF (%SAVED-PARENT-PARALLEL-THREAD SELF) VALUE)
     (CL:SETQ VALUE (%SAVED-PARENT-PARALLEL-THREAD SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFCLASS CONTROL-FRAME-PRIORITY-QUEUE ...)

(CL:DEFCLASS CONTROL-FRAME-PRIORITY-QUEUE (STANDARD-OBJECT)
  ((QUEUE :ALLOCATION :INSTANCE :ACCESSOR %QUEUE)))

(CL:DEFUN NEW-CONTROL-FRAME-PRIORITY-QUEUE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE CONTROL-FRAME-PRIORITY-QUEUE)))
   (CL:SETF (%QUEUE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CONTROL-FRAME-PRIORITY-QUEUE))
  SGT-QUERY-LOGIC-CONTROL-FRAME-PRIORITY-QUEUE)

(CL:DEFUN ACCESS-CONTROL-FRAME-PRIORITY-QUEUE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-QUEUE)
    (CL:IF SETVALUE? (CL:SETF (%QUEUE SELF) VALUE)
     (CL:SETQ VALUE (%QUEUE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFSPECIAL *QUERYITERATOR* ...)

(CL:DEFVAR *QUERYITERATOR* NULL
  "Points to the query iterator for the currently executing query.")

;;; (DEFGLOBAL *DEFAULT-MAXIMUM-DEPTH* ...)

(CL:PROGN (CL:DEFVAR *DEFAULT-MAXIMUM-DEPTH* 25 "Possibly a good value for the maximum backtracking depth.
More testing is needed.") (CL:DECLAIM (CL:TYPE CL:FIXNUM *DEFAULT-MAXIMUM-DEPTH*)))

;;; (DEFGLOBAL *INITIAL-BACKTRACKING-DEPTH* ...)

(CL:PROGN (CL:DEFVAR *INITIAL-BACKTRACKING-DEPTH* 5 "Value of the initial depth used during an interative
deepening search.") (CL:DECLAIM (CL:TYPE CL:FIXNUM *INITIAL-BACKTRACKING-DEPTH*)))

;;; (DEFGLOBAL *ITERATIVE-DEEPENING-MODE?* ...)

(CL:DEFVAR *ITERATIVE-DEEPENING-MODE?* FALSE
  "Default setting.  If TRUE, queries are evaluated
using iterative deepening from depth '*initial-backtracking-depth*'
to depth '*maximum-backtracking-depth*'.")

;;; (DEFGLOBAL *EMIT-THINKING-DOTS?* ...)

(CL:DEFVAR *EMIT-THINKING-DOTS?* TRUE
  "When TRUE, various kinds of characters are
emitted to STANDARD-OUTPUT while PowerLoom is 'thinking'.")

;;; (DEFGLOBAL *THINKING-DOT-COUNTER* ...)

(CL:PROGN (CL:DEFVAR *THINKING-DOT-COUNTER* 0 "Used to determine when to generate linefeeds
after forty-or-so thinking dots.") (CL:DECLAIM (CL:TYPE CL:FIXNUM *THINKING-DOT-COUNTER*)))

;;; (DEFGLOBAL *THINKING-DOT-TABLE* ...)

(CL:DEFVAR *THINKING-DOT-TABLE* NULL
  "Maps kind of thinking keywords to characters.")

;;; (DEFUN EMIT-THINKING-DOT ...)

(CL:DEFUN EMIT-THINKING-DOT (KINDOFTHINKING)
  (CL:WHEN *EMIT-THINKING-DOTS?*
   (CL:LET*
    ((CHARACTER
      (%WRAPPER-VALUE (LOOKUP *THINKING-DOT-TABLE* KINDOFTHINKING))))
    (CL:WHEN (DEFINED? CHARACTER)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) CHARACTER)
     (CL:SETQ *THINKING-DOT-COUNTER* (CL:1+ *THINKING-DOT-COUNTER*))
     (CL:WHEN (CL:>= *THINKING-DOT-COUNTER* 70)
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL)
      (CL:SETQ *THINKING-DOT-COUNTER* 0))))))

;;; (DEFCLASS PROOF-ADJUNCT ...)

(CL:DEFCLASS PROOF-ADJUNCT (STANDARD-OBJECT)
  ()
  (:DOCUMENTATION "Subclasses of 'PROOF-ADJUNCT' provide for specialized
slots (specialized for a particular strategy) to hold a record of
an ongoing proof thread."))

(CL:DEFUN NEW-PROOF-ADJUNCT ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PROOF-ADJUNCT))) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PROOF-ADJUNCT))
  SGT-QUERY-LOGIC-PROOF-ADJUNCT)

;;; (DEFCLASS PATTERN-RECORD ...)

(CL:DEFCLASS PATTERN-RECORD (STANDARD-OBJECT)
  ((CONTROL-FRAME :ALLOCATION :INSTANCE :ACCESSOR %CONTROL-FRAME)
   (VARIABLE-BINDINGS :ALLOCATION :INSTANCE :ACCESSOR %VARIABLE-BINDINGS)
   (UNBINDING-STACK :ALLOCATION :INSTANCE :ACCESSOR %UNBINDING-STACK)
   (TOP-UNBINDING-STACK-OFFSET :ALLOCATION :INSTANCE :ACCESSOR
    %TOP-UNBINDING-STACK-OFFSET)
   (DESCRIPTION :ALLOCATION :INSTANCE :ACCESSOR %DESCRIPTION)
   (EXTERNAL-ARGUMENTS :ALLOCATION :INSTANCE :ACCESSOR
    %EXTERNAL-ARGUMENTS)
   (BOOLEAN-VECTOR :ALLOCATION :INSTANCE :ACCESSOR %BOOLEAN-VECTOR)
   (OPTIMAL-PATTERN :ALLOCATION :INSTANCE :ACCESSOR %OPTIMAL-PATTERN)
   (COLLECTION-LIST :ALLOCATION :INSTANCE :ACCESSOR %COLLECTION-LIST))
  (:DOCUMENTATION "A pattern record records bookkeeping data used during
the processing of a description."))

(CL:DEFUN NEW-PATTERN-RECORD ()
  (CL:LET* ((SELF NULL))
   (CL:WHEN
    (CL:AND *RECYCLING-ENABLED?*
     (CL:NOT (CL:EQ *RECYCLE-LIST-FOR-PATTERN-RECORD-S* NULL)))
    (CL:SETQ SELF
     (POP (%LIST-OF-RECYCLED-ITEMS *RECYCLE-LIST-FOR-PATTERN-RECORD-S*))))
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL))
     (CL:SETF (%CURRENT-LENGTH *RECYCLE-LIST-FOR-PATTERN-RECORD-S*)
      (CL:1- (%CURRENT-LENGTH *RECYCLE-LIST-FOR-PATTERN-RECORD-S*))))
    (CL:T (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PATTERN-RECORD)))
     (CL:SETF (%COLLECTION-LIST SELF) NULL)
     (CL:SETF (%OPTIMAL-PATTERN SELF) NULL)
     (CL:SETF (%BOOLEAN-VECTOR SELF) NULL)
     (CL:SETF (%EXTERNAL-ARGUMENTS SELF) NULL)
     (CL:SETF (%DESCRIPTION SELF) NULL)
     (CL:SETF (%TOP-UNBINDING-STACK-OFFSET SELF) NULL-INTEGER)
     (CL:SETF (%UNBINDING-STACK SELF) NULL)
     (CL:SETF (%VARIABLE-BINDINGS SELF) NULL)
     (CL:SETF (%CONTROL-FRAME SELF) NULL)))
   SELF))

(CL:DEFMETHOD FREE ((SELF PATTERN-RECORD))
  (CL:WHEN
   (CL:AND *RECYCLING-ENABLED?*
    (CL:NOT (CL:EQ *RECYCLE-LIST-FOR-PATTERN-RECORD-S* NULL)))
   (CL:WHEN (CL:NOT (TERMINATE-PATTERN-RECORD? SELF))
    (CL:RETURN-FROM FREE))
   (CL:SETF (%COLLECTION-LIST SELF) NULL)
   (CL:SETF (%OPTIMAL-PATTERN SELF) NULL)
   (CL:SETF (%BOOLEAN-VECTOR SELF) NULL)
   (CL:SETF (%EXTERNAL-ARGUMENTS SELF) NULL)
   (CL:SETF (%DESCRIPTION SELF) NULL)
   (CL:SETF (%TOP-UNBINDING-STACK-OFFSET SELF) NULL-INTEGER)
   (CL:SETF (%UNBINDING-STACK SELF) NULL)
   (CL:SETF (%VARIABLE-BINDINGS SELF) NULL)
   (CL:SETF (%CONTROL-FRAME SELF) NULL)
   (PUSH (%LIST-OF-RECYCLED-ITEMS *RECYCLE-LIST-FOR-PATTERN-RECORD-S*)
    SELF)
   (CL:SETF (%CURRENT-LENGTH *RECYCLE-LIST-FOR-PATTERN-RECORD-S*)
    (CL:1+ (%CURRENT-LENGTH *RECYCLE-LIST-FOR-PATTERN-RECORD-S*)))
   (CL:WHEN
    (CL:=
     (CL:SETQ *RECYCLE-LISTS-MAINTENANCE-TIMER*
      (CL:1- *RECYCLE-LISTS-MAINTENANCE-TIMER*))
     0)
    (MAINTAIN-RECYCLE-LISTS))))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PATTERN-RECORD))
  SGT-QUERY-LOGIC-PATTERN-RECORD)

(CL:DEFUN ACCESS-PATTERN-RECORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-CONTROL-FRAME)
    (CL:IF SETVALUE? (CL:SETF (%CONTROL-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%CONTROL-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-VARIABLE-BINDINGS)
    (CL:IF SETVALUE? (CL:SETF (%VARIABLE-BINDINGS SELF) VALUE)
     (CL:SETQ VALUE (%VARIABLE-BINDINGS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-UNBINDING-STACK)
    (CL:IF SETVALUE? (CL:SETF (%UNBINDING-STACK SELF) VALUE)
     (CL:SETQ VALUE (%UNBINDING-STACK SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TOP-UNBINDING-STACK-OFFSET)
    (CL:IF SETVALUE?
     (CL:SETF (%TOP-UNBINDING-STACK-OFFSET SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%TOP-UNBINDING-STACK-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-DESCRIPTION)
    (CL:IF SETVALUE? (CL:SETF (%DESCRIPTION SELF) VALUE)
     (CL:SETQ VALUE (%DESCRIPTION SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-EXTERNAL-ARGUMENTS)
    (CL:IF SETVALUE? (CL:SETF (%EXTERNAL-ARGUMENTS SELF) VALUE)
     (CL:SETQ VALUE (%EXTERNAL-ARGUMENTS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-STELLA-BOOLEAN-VECTOR)
    (CL:IF SETVALUE? (CL:SETF (%BOOLEAN-VECTOR SELF) VALUE)
     (CL:SETQ VALUE (%BOOLEAN-VECTOR SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-OPTIMAL-PATTERN)
    (CL:IF SETVALUE? (CL:SETF (%OPTIMAL-PATTERN SELF) VALUE)
     (CL:SETQ VALUE (%OPTIMAL-PATTERN SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-COLLECTION-LIST)
    (CL:IF SETVALUE? (CL:SETF (%COLLECTION-LIST SELF) VALUE)
     (CL:SETQ VALUE (%COLLECTION-LIST SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFCLASS BOOLEAN-VECTOR-INDEX-NODE ...)

(CL:DEFCLASS BOOLEAN-VECTOR-INDEX-NODE (STANDARD-OBJECT)
  ((TRUE-LINK :ALLOCATION :INSTANCE :ACCESSOR %TRUE-LINK)
   (FALSE-LINK :ALLOCATION :INSTANCE :ACCESSOR %FALSE-LINK)
   (THE-VECTOR :ALLOCATION :INSTANCE :ACCESSOR %THE-VECTOR)))

(CL:DEFUN NEW-BOOLEAN-VECTOR-INDEX-NODE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE BOOLEAN-VECTOR-INDEX-NODE)))
   (CL:SETF (%THE-VECTOR SELF) NULL) (CL:SETF (%FALSE-LINK SELF) NULL)
   (CL:SETF (%TRUE-LINK SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF BOOLEAN-VECTOR-INDEX-NODE))
  SGT-QUERY-LOGIC-BOOLEAN-VECTOR-INDEX-NODE)

(CL:DEFUN ACCESS-BOOLEAN-VECTOR-INDEX-NODE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-TRUE-LINK)
    (CL:IF SETVALUE? (CL:SETF (%TRUE-LINK SELF) VALUE)
     (CL:SETQ VALUE (%TRUE-LINK SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-FALSE-LINK)
    (CL:IF SETVALUE? (CL:SETF (%FALSE-LINK SELF) VALUE)
     (CL:SETQ VALUE (%FALSE-LINK SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-THE-VECTOR)
    (CL:IF SETVALUE? (CL:SETF (%THE-VECTOR SELF) VALUE)
     (CL:SETQ VALUE (%THE-VECTOR SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFGLOBAL *BOOLEAN-VECTOR-INDEX* ...)

(CL:DEFVAR *BOOLEAN-VECTOR-INDEX* NULL
  "Points to the head of a discrimination tree of containing
all boolean vectors.")

;;; (DEFUN (CREATE-BOOLEAN-VECTOR-INDEX-NODE BOOLEAN-VECTOR-INDEX-NODE) ...)

(CL:DEFUN CREATE-BOOLEAN-VECTOR-INDEX-NODE (PARENTNODE LASTVALUE)
  (CL:LET*
   ((NODE (NEW-BOOLEAN-VECTOR-INDEX-NODE))
    (VECTORLENGTH (CL:1+ (LENGTH (%THE-VECTOR PARENTNODE))))
    (VECTOR (NEW-BOOLEAN-VECTOR VECTORLENGTH)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM VECTORLENGTH))
   (CL:SETF (%THE-VECTOR NODE) VECTOR)
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:- VECTORLENGTH 2)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:LET
      ((SELF (%THE-ARRAY VECTOR))
       (VALUE
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%THE-VECTOR PARENTNODE)))
         I))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:LET
    ((SELF (%THE-ARRAY VECTOR))
     (VALUE (CL:IF LASTVALUE TRUE-WRAPPER FALSE-WRAPPER))
     (POSITION (CL:1- VECTORLENGTH)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:IF LASTVALUE (CL:SETF (%TRUE-LINK PARENTNODE) NODE)
    (CL:SETF (%FALSE-LINK PARENTNODE) NODE))
   NODE))

;;; (DEFUN (ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR BOOLEAN-VECTOR) ...)

(CL:DEFUN ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR (ARGUMENTSVECTOR)
  (CL:LET* ((NODE *BOOLEAN-VECTOR-INDEX*) (NEXTNODE NULL) (BOUND? FALSE))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTSVECTOR) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:SETQ BOUND? TRUE)
     (CL:COND
      ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARG)
        SGT-QUERY-LOGIC-PATTERN-VARIABLE)
       (CL:PROGN
        (CL:SETQ BOUND?
         (CL:NOT
          (CL:EQ
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%THE-ARRAY
              (%VARIABLE-BINDINGS
               (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
            (CL:THE CL:FIXNUM (%BOUND-TO-OFFSET ARG)))
           NULL)))))
      (CL:T))
     (CL:IF BOUND?
      (CL:PROGN (CL:SETQ NEXTNODE (%TRUE-LINK NODE))
       (CL:WHEN (CL:EQ NEXTNODE NULL)
        (CL:SETQ NEXTNODE (CREATE-BOOLEAN-VECTOR-INDEX-NODE NODE TRUE))))
      (CL:PROGN (CL:SETQ NEXTNODE (%FALSE-LINK NODE))
       (CL:WHEN (CL:EQ NEXTNODE NULL)
        (CL:SETQ NEXTNODE
         (CREATE-BOOLEAN-VECTOR-INDEX-NODE NODE FALSE)))))
     (CL:SETQ NODE NEXTNODE)))
   (%THE-VECTOR NODE)))

;;; (DEFUN (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR BOOLEAN-VECTOR) ...)

(CL:DEFUN ZERO-ONE-LIST-TO-BOOLEAN-VECTOR (ZEROONELIST)
  (CL:LET* ((NODE *BOOLEAN-VECTOR-INDEX*) (NEXTNODE NULL))
   (CL:LET* ((BIT NULL) (ITER-000 (%THE-CONS-LIST ZEROONELIST)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ BIT (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:IF (EQL? BIT ONE-WRAPPER)
      (CL:PROGN (CL:SETQ NEXTNODE (%TRUE-LINK NODE))
       (CL:WHEN (CL:EQ NEXTNODE NULL)
        (CL:SETQ NEXTNODE (CREATE-BOOLEAN-VECTOR-INDEX-NODE NODE TRUE))))
      (CL:PROGN (CL:SETQ NEXTNODE (%FALSE-LINK NODE))
       (CL:WHEN (CL:EQ NEXTNODE NULL)
        (CL:SETQ NEXTNODE
         (CREATE-BOOLEAN-VECTOR-INDEX-NODE NODE FALSE)))))
     (CL:SETQ NODE NEXTNODE)))
   (%THE-VECTOR NODE)))

;;; (DEFUN POP-CONTROL-FRAME ...)

(CL:DEFUN POP-CONTROL-FRAME (FRAME)
  (CL:WHEN
   (CL:OR (CL:EQ (%STATE FRAME) KWD-QUERY-PATTERN)
    (CL:EQ (%STATE FRAME) KWD-QUERY-CONTAINED-BY))
   (RESET-CURRENT-PATTERN-RECORD FRAME KWD-QUERY-PARENT))
  (CL:WHEN (CL:NOT (CL:EQ (%CACHED-BINDINGS-ITERATOR FRAME) NULL))
   (FREE (%CACHED-BINDINGS-ITERATOR FRAME))
   (CL:SETF (%CACHED-BINDINGS-ITERATOR FRAME) NULL))
  (CL:SETF (%CHOICE-POINT-UNBINDING-OFFSET FRAME) NULL-INTEGER)
  (FREE FRAME)
  (CL:SETF (%STATE FRAME) KWD-QUERY-POPPED))

;;; (DEFUN POP-FRAMES-UP-TO ...)

(CL:DEFUN POP-FRAMES-UP-TO (FRAME)
  (CL:WHEN (CL:NOT (CL:EQ (%DOWN FRAME) NULL))
   (POP-FRAMES-UP-TO (%DOWN FRAME)))
  (CL:WHEN (CL:NOT (CL:EQ (%UP FRAME) NULL))
   (CL:SETF (%DOWN (%UP FRAME)) NULL))
  (POP-CONTROL-FRAME FRAME))

;;; (DEFUN POP-DOWN-FRAME ...)

(CL:DEFUN POP-DOWN-FRAME (FRAME)
  (POP-CONTROL-FRAME (%DOWN FRAME))
  (CL:SETF (%DOWN FRAME) NULL))

;;; (DEFUN ACTIVATE-PATTERN-RECORD ...)

(CL:DEFUN ACTIVATE-PATTERN-RECORD (PATTERNRECORD VARIABLECOUNT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM VARIABLECOUNT))
  (CL:LET*
   ((VECTOR (%VARIABLE-BINDINGS PATTERNRECORD))
    (STACK (%UNBINDING-STACK PATTERNRECORD)))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ VECTOR NULL))
     (CL:>= (%ARRAY-SIZE VECTOR) VARIABLECOUNT))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-000 0)
      (UPPER-BOUND-000 (CL:1- VARIABLECOUNT)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
     (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
      (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
      (CL:LET ((SELF (%THE-ARRAY VECTOR)) (VALUE NULL) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:LET ((SELF (%THE-ARRAY STACK)) (VALUE NULL) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))))
    (CL:PROGN
     (CL:SETF (%VARIABLE-BINDINGS PATTERNRECORD)
      (NEW-VECTOR VARIABLECOUNT))
     (CL:SETF (%UNBINDING-STACK PATTERNRECORD)
      (NEW-INTEGER-VECTOR VARIABLECOUNT))))
   (CL:SETF (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD) -1)
   (CL:SETF (%CURRENT-PATTERN-RECORD *QUERYITERATOR*) PATTERNRECORD)))

;;; (DEFUN RESET-CURRENT-PATTERN-RECORD ...)

(CL:DEFUN RESET-CURRENT-PATTERN-RECORD (FRAME LOCALORPARENT)
  (CL:COND
   ((CL:EQ LOCALORPARENT KWD-QUERY-LOCAL)
    (CL:SETF (%CURRENT-PATTERN-RECORD *QUERYITERATOR*)
     (%PATTERN-RECORD FRAME)))
   ((CL:EQ LOCALORPARENT KWD-QUERY-PARENT)
    (CL:IF (CL:NOT (CL:EQ (%INHERITED-PATTERN-RECORD FRAME) NULL))
     (CL:SETF (%CURRENT-PATTERN-RECORD *QUERYITERATOR*)
      (%INHERITED-PATTERN-RECORD FRAME))
     (CL:SETF (%CURRENT-PATTERN-RECORD *QUERYITERATOR*)
      (%PATTERN-RECORD (%BASE-CONTROL-FRAME *QUERYITERATOR*)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LOCALORPARENT
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN PRINT-ENVIRONMENT-STACKS ...)

(CL:DEFUN PRINT-ENVIRONMENT-STACKS ()
  (CL:LET*
   ((FRAME (%CURRENT-CONTROL-FRAME *QUERYITERATOR*))
    (CURRENTPATTERNRECORD (%CURRENT-PATTERN-RECORD *QUERYITERATOR*)))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "-------------------------" EOL)
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "current-control-frame " FRAME EOL)
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "    ")
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%VARIABLE-BINDINGS CURRENTPATTERNRECORD))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:IF (CL:NOT (CL:EQ ARG NULL))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) ARG " ")
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "_ "))))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL)
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "    "
    (%UNBINDING-STACK CURRENTPATTERNRECORD) EOL)
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "-------------------------" EOL)))

;;; (DEFUN SET-PATTERN-VARIABLE-BINDING ...)

(CL:DEFUN SET-PATTERN-VARIABLE-BINDING (VARIABLE VALUE)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "set-pattern-variable-binding: " VARIABLE " " VALUE "  F"
    (%DEBUG-FRAME-ID
     (%CONTROL-FRAME (%CURRENT-PATTERN-RECORD *QUERYITERATOR*)))
    EOL))
  (CL:LET*
   ((PATTERNRECORD (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))
    (VBOFFSET (%BOUND-TO-OFFSET VARIABLE))
    (UBSTACKOFFSET (CL:1+ (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM VBOFFSET UBSTACKOFFSET))
   (CL:LET
    ((SELF (%THE-ARRAY (%VARIABLE-BINDINGS PATTERNRECORD))) (VALUE VALUE)
     (POSITION VBOFFSET))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD) UBSTACKOFFSET)
   (CL:LET
    ((SELF (%THE-ARRAY (%UNBINDING-STACK PATTERNRECORD)))
     (VALUE (WRAP-INTEGER VBOFFSET)) (POSITION UBSTACKOFFSET))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFUN UNBIND-VARIABLES-BEGINNING-AT ...)

(CL:DEFUN UNBIND-VARIABLES-BEGINNING-AT (PATTERNRECORD UBSTACKOFFSET)
  (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
  (CL:LET*
   ((VARIABLEBINDINGSVECTOR (%VARIABLE-BINDINGS PATTERNRECORD))
    (UNBINDINGSTACK (%UNBINDING-STACK PATTERNRECORD)))
   (CL:WHEN
    (CL:< (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD) UBSTACKOFFSET)
    (CL:RETURN-FROM UNBIND-VARIABLES-BEGINNING-AT))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "unbind-variables-beginning-at: UBS= " UBSTACKOFFSET "  F"
     (%DEBUG-FRAME-ID (%CONTROL-FRAME PATTERNRECORD)) "  #bindings= "
     (CL:1+
      (CL:- (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD) UBSTACKOFFSET))
     EOL))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 UBSTACKOFFSET)
     (UPPER-BOUND-000 (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000))
     DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:LET
      ((SELF (%THE-ARRAY VARIABLEBINDINGSVECTOR)) (VALUE NULL)
       (POSITION
        (%WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY UNBINDINGSTACK))
          I))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET
      ((SELF (%THE-ARRAY UNBINDINGSTACK)) (VALUE NULL) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:SETF (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD)
    (CL:1- UBSTACKOFFSET))))

;;; (DEFUN CREATE-CHOICE-POINT ...)

(CL:DEFUN CREATE-CHOICE-POINT (FRAME)
  (CL:LET* ((PATTERNRECORD (%INHERITED-PATTERN-RECORD FRAME)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "create-choice-point: CP= " (%CHOICE-POINT-UNBINDING-OFFSET FRAME)
     " NEWCP= " (CL:1+ (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD)) EOL))
   (CL:IF (NULL? (%CHOICE-POINT-UNBINDING-OFFSET FRAME))
    (CL:SETF (%CHOICE-POINT-UNBINDING-OFFSET FRAME)
     (CL:1+ (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD)))
    (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD
     (%CHOICE-POINT-UNBINDING-OFFSET FRAME)))))

;;; (DEFUN UNWIND-TO-CHOICE-POINT ...)

(CL:DEFUN UNWIND-TO-CHOICE-POINT (FRAME)
  (CL:LET* ((CHOICEPOINT (%CHOICE-POINT-UNBINDING-OFFSET FRAME)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CHOICEPOINT))
   (CL:WHEN (DEFINED? CHOICEPOINT)
    (UNBIND-VARIABLES-BEGINNING-AT (%INHERITED-PATTERN-RECORD FRAME)
     CHOICEPOINT))))

;;; (DEFUN (NEW-BINDINGS-SINCE-LAST-CHOICE-POINT? BOOLEAN) ...)

(CL:DEFUN NEW-BINDINGS-SINCE-LAST-CHOICE-POINT? (FRAME)
  (<= (%CHOICE-POINT-UNBINDING-OFFSET FRAME)
   (%TOP-UNBINDING-STACK-OFFSET (%INHERITED-PATTERN-RECORD FRAME))))

;;; (DEFUN (BOUND-TO OBJECT) ...)

(CL:DEFUN BOUND-TO (SELF)
  (CL:AREF
   (CL:THE CL:SIMPLE-VECTOR
    (%THE-ARRAY
     (%VARIABLE-BINDINGS (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
   (CL:THE CL:FIXNUM (%BOUND-TO-OFFSET SELF))))

;;; (DEFUN (CONTAINS-OPERATOR? BOOLEAN) ...)

(CL:DEFUN CONTAINS-OPERATOR? (PROPOSITION OPERATOR)
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:IF (CL:EQ (%OPERATOR PROPOSITION) OPERATOR)
    (CL:SETQ TEST-VALUE-000 TRUE)
    (CL:LET* ((FOUND?-000 FALSE))
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:PROGN
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
       (CL:WHEN
        (CL:AND (ISA? ARG SGT-QUERY-LOGIC-PROPOSITION)
         (CONTAINS-OPERATOR? ARG OPERATOR))
        (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
     (CL:SETQ TEST-VALUE-000 FOUND?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (ARGUMENT-BOUND-TO OBJECT) ...)

(CL:DEFUN ARGUMENT-BOUND-TO (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN
      (CL:LET*
       ((VALUE
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY
            (%VARIABLE-BINDINGS
             (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
          (CL:THE CL:FIXNUM (%BOUND-TO-OFFSET SELF)))))
       (CL:WHEN
        (CL:AND (CL:EQ VALUE NULL)
         (CL:NOT
          (CL:EQ
           (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SELF) (%HOME-CONTEXT SELF)
            FALSE)
           NULL)))
        (CL:SETQ VALUE (VALUE-OF SELF))
        (CL:WHEN (SKOLEM? VALUE) (CL:RETURN-FROM ARGUMENT-BOUND-TO NULL))
        (BIND-VARIABLE-TO-VALUE? SELF VALUE TRUE))
       VALUE)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000) (CL:PROGN (VALUE-OF SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:WHEN
       (CL:AND
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
           SYM-QUERY-LOGIC-EXTERNAL-VARIABLES NULL)
          NULL))
        (CONTAINS-OPERATOR? (%PROPOSITION SELF)
         SGT-QUERY-PL-KERNEL-KB-HOLDS))
       (CL:LET*
        ((DUPLICATE
          (FIND-DUPLICATE-DESCRIPTION-WITH-CONSTANT-REFERENCE SELF)))
        (CL:RETURN-FROM ARGUMENT-BOUND-TO
         (CL:IF (CL:NOT (CL:EQ DUPLICATE NULL)) DUPLICATE SELF))))
      (VALUE-OF SELF)))
    (CL:T (VALUE-OF SELF)))))

;;; (DEFUN (HELP-UNIFY-ATTRIBUTES? BOOLEAN) ...)

(CL:DEFUN HELP-UNIFY-ATTRIBUTES? (VALUE1 VALUE2)
  (CL:OR (EQL? VALUE1 VALUE2)
   (CL:AND (SKOLEM? VALUE1) (HELP-BIND-VARIABLE-TO-VALUE? VALUE1 VALUE2))))

;;; (DEFUN (FAILS-UNIFICATION-TYPE-CHECK? BOOLEAN) ...)

(CL:DEFUN FAILS-UNIFICATION-TYPE-CHECK? (V1 I2)
  (CL:COND ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-NONE) FALSE)
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-LOOKUP)
    (CL:LET*
     ((TYPE (%ROOT-TYPE V1)) (TYPEISOK? (CHECK-TYPE? I2 TYPE TRUE)))
     (CL:IF
      (CL:AND (CL:NOT TYPEISOK?)
       (NON-INFERABLE? (SURROGATE-TO-DESCRIPTION TYPE)))
      TRUE FALSE)))
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-SHALLOW-DISJOINT)
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ (%ROOT-TYPE V1) NULL))
      (DISJOINT-CLASSES? (GET-DESCRIPTION (%ROOT-TYPE V1))
       (GET-DESCRIPTION (LOGICAL-TYPE I2))))
     (CL:RETURN-FROM FAILS-UNIFICATION-TYPE-CHECK? TRUE))
    FALSE)
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-DISJOINT)
    (CL:LET* ((TYPE1 NULL) (TYPE2 NULL))
     (CL:LET*
      ((P NULL)
       (ITER-000
        (ALLOCATE-ITERATOR (UNFILTERED-DEPENDENT-ISA-PROPOSITIONS V1))))
      (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
       (CL:WHEN (CL:EQ (%KIND P) KWD-QUERY-ISA)
        (CL:SETQ TYPE1
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
          1))
        (CL:RETURN))))
     (CL:WHEN (CL:EQ TYPE1 NULL)
      (CL:RETURN-FROM FAILS-UNIFICATION-TYPE-CHECK? FALSE))
     (CL:COND
      ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE I2) SGT-QUERY-LOGIC-LOGIC-OBJECT)
       (CL:PROGN
        (CL:LET*
         ((P NULL)
          (ITER-001
           (ALLOCATE-ITERATOR
            (UNFILTERED-DEPENDENT-ISA-PROPOSITIONS I2))))
         (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ P (%VALUE ITER-001))
          (CL:WHEN (CL:EQ (%KIND P) KWD-QUERY-ISA)
           (CL:SETQ TYPE2
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
             1))
           (CL:RETURN))))))
      (CL:T (CL:SETQ TYPE2 (LOGICAL-TYPE I2))))
     (CL:WHEN (CL:EQ TYPE2 NULL)
      (CL:RETURN-FROM FAILS-UNIFICATION-TYPE-CHECK? FALSE))
     (DISJOINT-CLASSES? (GET-DESCRIPTION TYPE1) (GET-DESCRIPTION TYPE2))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" *TYPE-CHECK-STRATEGY*
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (FAILS-ANTECEDENT-TYPE-CHECK? BOOLEAN) ...)

(CL:DEFUN FAILS-ANTECEDENT-TYPE-CHECK? (V1 I2)
  (CL:COND
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-LOOKUP)
    (CL:LET*
     ((TYPE (%ROOT-TYPE V1)) (TYPEISOK? (CHECK-TYPE? I2 TYPE TRUE)))
     (CL:IF
      (CL:AND (CL:NOT TYPEISOK?)
       (NON-INFERABLE? (SURROGATE-TO-DESCRIPTION TYPE)))
      TRUE FALSE)))
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-NONE) FALSE)
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" *TYPE-CHECK-STRATEGY*
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (HELP-BIND-VARIABLE-TO-VALUE? BOOLEAN) ...)

(CL:DEFUN HELP-BIND-VARIABLE-TO-VALUE? (VARIABLE VALUE)
  (CL:COND
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-LOOKUP)
    (CL:LET* ((TYPEISOK? FALSE))
     (CL:MULTIPLE-VALUE-SETQ (TYPEISOK? VALUE)
      (CHECK-TYPE? VALUE (%ROOT-TYPE VARIABLE) TRUE))
     (CL:WHEN
      (CL:AND (CL:NOT TYPEISOK?)
       (NON-INFERABLE? (SURROGATE-TO-DESCRIPTION (%ROOT-TYPE VARIABLE))))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
        (MEMB? *TRACED-KEYWORDS* KWD-QUERY-PERFORMANCE-CLUES))
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
        "TYPE CHECK VIOLATION in 'bind-variable-to-value?'.  Type= "
        (%ROOT-TYPE VARIABLE) " Value= " VALUE EOL))
      (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE? FALSE))))
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-NONE))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" *TYPE-CHECK-STRATEGY*
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:LET*
   ((BOUNDTOVALUE
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%THE-ARRAY
        (%VARIABLE-BINDINGS (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
      (CL:THE CL:FIXNUM (%BOUND-TO-OFFSET VARIABLE))))
    (VARIABLEVALUE
     (ACCESS-IN-CONTEXT (%VARIABLE-VALUE VARIABLE)
      (%HOME-CONTEXT VARIABLE) FALSE)))
   (ELABORATE-INSTANCE VALUE)
   (CL:COND
    ((CL:AND (CL:NOT (CL:EQ VARIABLEVALUE NULL))
      (CL:EQ BOUNDTOVALUE NULL))
     (CL:SETQ VARIABLEVALUE (VALUE-OF VARIABLEVALUE))
     (SET-PATTERN-VARIABLE-BINDING VARIABLE VARIABLEVALUE)
     (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE?
      (EQL? VARIABLEVALUE VALUE)))
    ((CL:EQ BOUNDTOVALUE NULL)
     (SET-PATTERN-VARIABLE-BINDING VARIABLE VALUE))
    ((EQL? BOUNDTOVALUE VALUE)
     (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE? TRUE))
    (CL:T (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE? FALSE)))
   TRUE))

;;; (DEFUN (BIND-VARIABLE-TO-VALUE? BOOLEAN) ...)

(CL:DEFUN BIND-VARIABLE-TO-VALUE? (VARIABLE VALUE AUTOCLEANUP?)
  (CL:IF AUTOCLEANUP?
   (CL:LET*
    ((PATTERNRECORD (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))
     (UBSTACKOFFSET (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))
     (SUCCESS? FALSE))
    (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
    (CL:SETQ SUCCESS? (HELP-BIND-VARIABLE-TO-VALUE? VARIABLE VALUE))
    (CL:WHEN (CL:NOT SUCCESS?)
     (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD (CL:1+ UBSTACKOFFSET)))
    SUCCESS?)
   (HELP-BIND-VARIABLE-TO-VALUE? VARIABLE VALUE)))

;;; (DEFUN (BIND-ARGUMENT-TO-VALUE? BOOLEAN) ...)

(CL:DEFUN BIND-ARGUMENT-TO-VALUE? (ARGUMENT VALUE AUTOCLEANUP?)
  (CL:WHEN (CL:EQ VALUE NULL)
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Tried to bind `"
    ARGUMENT "' to NULL value.  Last time we saw" EOL
    "   this bug, it was caused by COLLECT-INTO-LIST applied to" EOL
    "   KAPPA with unbound external variables." EOL)
   (CL:RETURN-FROM BIND-ARGUMENT-TO-VALUE? FALSE))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARGUMENT)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN (BIND-VARIABLE-TO-VALUE? ARGUMENT VALUE AUTOCLEANUP?)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (EQL? (VALUE-OF ARGUMENT) VALUE)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-PROPOSITION)
     (CL:PROGN (EQUIVALENT-PROPOSITIONS? ARGUMENT VALUE NULL)))
    (CL:T (EQL? ARGUMENT VALUE)))))

;;; (DEFUN (BIND-VECTOR-OF-ARGUMENTS-TO-VALUES? BOOLEAN) ...)

(CL:DEFUN BIND-VECTOR-OF-ARGUMENTS-TO-VALUES? (ARGUMENTS VALUES)
  (CL:LET*
   ((PATTERNRECORD (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))
    (UBSTACKOFFSET (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))
    (SUCCESS? FALSE))
   (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
   (CL:LET* ((ALWAYS?-000 TRUE))
    (CL:LET*
     ((V NULL) (ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)) (ITER-000 VALUES))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:NOT (CL:EQ ITER-000 NIL)))
      DO
      (CL:PROGN
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
      (CL:PROGN (CL:SETQ V (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (CL:WHEN (CL:NOT (BIND-ARGUMENT-TO-VALUE? ARG V FALSE))
       (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
    (CL:SETQ SUCCESS? ALWAYS?-000))
   (CL:WHEN (CL:NOT SUCCESS?)
    (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD (CL:1+ UBSTACKOFFSET)))
   SUCCESS?))

;;; (DEFUN PRINT-CONTROL-FRAME-STACK ...)

(CL:DEFUN PRINT-CONTROL-FRAME-STACK (FRAME)
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) FRAME EOL)
  (CL:WHEN (CL:NOT (CL:EQ (%DOWN FRAME) NULL))
   (PRINT-CONTROL-FRAME-STACK (%DOWN FRAME))))

;;; (DEFUN PCS ...)

(CL:DEFUN PCS ()
  (PRINT-CONTROL-FRAME-STACK (%BASE-CONTROL-FRAME *QUERYITERATOR*)))

;;; (DEFUN (VARIABLE-FROM-UNBINDING-OFFSET PATTERN-VARIABLE) ...)

(CL:DEFUN VARIABLE-FROM-UNBINDING-OFFSET (DESCRIPTION UBOFFSET)
  (CL:DECLARE (CL:TYPE CL:FIXNUM UBOFFSET))
  (CL:LET*
   ((PATTERNRECORD (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))
    (OFFSET
     (%WRAPPER-VALUE
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%THE-ARRAY (%UNBINDING-STACK PATTERNRECORD)))
       UBOFFSET))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
   (CL:LET*
    ((VBL NULL) (VECTOR-000 (%IO-VARIABLES DESCRIPTION)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ VBL
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:WHEN (CL:= (%BOUND-TO-OFFSET VBL) OFFSET)
      (CL:RETURN-FROM VARIABLE-FROM-UNBINDING-OFFSET VBL))))
   (CL:LET*
    ((VBL NULL) (VECTOR-001 (%INTERNAL-VARIABLES DESCRIPTION))
     (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
    (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
     (CL:PROGN
      (CL:SETQ VBL
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
        INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:WHEN (CL:= (%BOUND-TO-OFFSET VBL) OFFSET)
      (CL:RETURN-FROM VARIABLE-FROM-UNBINDING-OFFSET VBL))))
   NULL))

;;; (DEFUN PRINT-ONE-VARIABLE-BINDING ...)

(CL:DEFUN PRINT-ONE-VARIABLE-BINDING (VARIABLE)
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) (%SKOLEM-NAME VARIABLE)
   "=")
  (CL:IF (DEFINED? (%BOUND-TO-OFFSET VARIABLE))
   (PRINT-UNFORMATTED-LOGICAL-FORM
    (CL:AREF
     (CL:THE CL:SIMPLE-VECTOR
      (%THE-ARRAY
       (%VARIABLE-BINDINGS (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
     (CL:THE CL:FIXNUM (%BOUND-TO-OFFSET VARIABLE)))
    STANDARD-OUTPUT)
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) SYM-QUERY-STELLA-NULL))
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) " "))

;;; (DEFUN PRINT-VARIABLE-BINDINGS ...)

(CL:DEFUN PRINT-VARIABLE-BINDINGS (FRAME)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ (%INHERITED-PATTERN-RECORD FRAME) NULL))
    (CL:NOT (CL:EQ (%STATE FRAME) KWD-QUERY-PATTERN)))
   (CL:SETQ FRAME (%CONTROL-FRAME (%INHERITED-PATTERN-RECORD FRAME))))
  (CL:LET* ((PATTERNRECORD (%PATTERN-RECORD FRAME)) (DESCRIPTION NULL))
   (CL:WHEN (CL:NOT (CL:EQ PATTERNRECORD NULL))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE PATTERNRECORD)
       SGT-QUERY-LOGIC-PATTERN-RECORD)
      (CL:PROGN
       (CL:WHEN (CL:EQ (%STATE FRAME) KWD-QUERY-CONTAINED-BY)
        (CL:LET*
         ((MEMBERPROPOSITION
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%THE-ARRAY (%ARGUMENTS (%PROPOSITION FRAME))))
            0))
          (MEMBER
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%THE-ARRAY (%ARGUMENTS MEMBERPROPOSITION)))
            0)))
         (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE MEMBER)))
          (CL:COND
           ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-PATTERN-VARIABLE)
            (CL:PROGN (PRINT-ONE-VARIABLE-BINDING MEMBER)))
           ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-LIST)
            (CL:PROGN
             (CL:LET* ((M NULL) (ITER-000 (%THE-CONS-LIST MEMBER)))
              (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
               (CL:PROGN (CL:SETQ M (%%VALUE ITER-000))
                (CL:SETQ ITER-000 (%%REST ITER-000)))
               (PRINT-ONE-VARIABLE-BINDING M)))))
           (CL:T
            (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
              TEST-VALUE-000 "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
        (CL:RETURN-FROM PRINT-VARIABLE-BINDINGS))
       (CL:SETQ DESCRIPTION (%OPTIMAL-PATTERN PATTERNRECORD))
       (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
        (CL:LET*
         ((VBL NULL) (VECTOR-000 (%IO-VARIABLES DESCRIPTION))
          (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:PROGN
           (CL:SETQ VBL
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
             INDEX-000))
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
          (CL:WHEN
           (CL:NOT
            (CL:EQ
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%THE-ARRAY
                (%VARIABLE-BINDINGS
                 (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
              (CL:THE CL:FIXNUM (%BOUND-TO-OFFSET VBL)))
             NULL))
           (PRINT-ONE-VARIABLE-BINDING VBL))))
        (CL:LET*
         ((VBL NULL) (VECTOR-001 (%INTERNAL-VARIABLES DESCRIPTION))
          (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
         (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
          (CL:PROGN
           (CL:SETQ VBL
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
             INDEX-001))
           (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
          (CL:WHEN
           (CL:NOT
            (CL:EQ
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%THE-ARRAY
                (%VARIABLE-BINDINGS
                 (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
              (CL:THE CL:FIXNUM (%BOUND-TO-OFFSET VBL)))
             NULL))
           (PRINT-ONE-VARIABLE-BINDING VBL)))))
       NULL))
     (CL:T)))))

;;; (DEFUN PRINT-RULE-IN-GOAL-TREE ...)

(CL:DEFUN PRINT-RULE-IN-GOAL-TREE (FRAME IMPLIESPROP DEPTH)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
  (CL:LET* ((PATTERNRECORD (%PATTERN-RECORD FRAME)))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "RULE: ")
   (CL:LET*
    ((RULENAME
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS IMPLIESPROP)
       SYM-QUERY-STELLA-SURROGATE-VALUE-INVERSE NULL)))
    (CL:WHEN
     (CL:AND (CL:EQ RULENAME NULL)
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS IMPLIESPROP)
         SYM-QUERY-LOGIC-MASTER-PROPOSITION NULL)
        NULL)))
     (CL:SETQ RULENAME
      (DYNAMIC-SLOT-VALUE
       (%DYNAMIC-SLOTS
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS IMPLIESPROP)
         SYM-QUERY-LOGIC-MASTER-PROPOSITION NULL))
       SYM-QUERY-STELLA-SURROGATE-VALUE-INVERSE NULL)))
    (CL:WHEN (CL:NOT (CL:EQ RULENAME NULL))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      (%SYMBOL-NAME RULENAME) EOL)
     (PRINT-INDENT STANDARD-OUTPUT (CL:+ (CL:* 2 DEPTH) 6))))
   (CL:LET*
    ((*PRINTMODE* KWD-QUERY-FLAT)
     (*PRINTLOGICALFORMSTREAM* STANDARD-OUTPUT)
     (*INDENTCOUNTER* (CL:+ (CL:* 2 DEPTH) 7)) (*QUERYITERATOR* NULL)
     (*REVERSEPOLARITY?* (%REVERSE-POLARITY? FRAME)))
    (CL:DECLARE
     (CL:SPECIAL *PRINTMODE* *PRINTLOGICALFORMSTREAM* *INDENTCOUNTER*
      *QUERYITERATOR* *REVERSEPOLARITY?*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
    (PRINT-DESCRIPTIONS-AS-KIF-RULE
     (CL:IF
      (CL:EQ (%DESCRIPTION PATTERNRECORD)
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS IMPLIESPROP)))
        1))
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS IMPLIESPROP))) 0)
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS IMPLIESPROP))) 1))
     (CL:IF (CL:NOT (CL:EQ (%OPTIMAL-PATTERN PATTERNRECORD) NULL))
      (%OPTIMAL-PATTERN PATTERNRECORD) (%DESCRIPTION PATTERNRECORD))
     IMPLIESPROP))))

;;; (DEFUN PRINT-GOAL-IN-GOAL-TREE ...)

(CL:DEFUN PRINT-GOAL-IN-GOAL-TREE (FRAME DEPTH)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
  (CL:IF (CL:NOT (CL:EQ (%PROPOSITION FRAME) NULL))
   (CL:LET* ((INVERT? (%REVERSE-POLARITY? FRAME)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "GOAL: ")
    (CL:WHEN INVERT?
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "~"))
    (CL:LET*
     ((*PRINTMODE* KWD-QUERY-REALISTIC)
      (*PRINTLOGICALFORMSTREAM* STANDARD-OUTPUT)
      (*INDENTCOUNTER* (CL:+ (CL:* 2 DEPTH) 7)))
     (CL:DECLARE
      (CL:SPECIAL *PRINTMODE* *PRINTLOGICALFORMSTREAM* *INDENTCOUNTER*))
     (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
     (PRINT-UNFORMATTED-LOGICAL-FORM (%PROPOSITION FRAME)
      STANDARD-OUTPUT)))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "STRATEGY: "
    (%CURRENT-STRATEGY (%UP FRAME)))))

;;; (DEFUN (COMPUTE-FRAME-DEPTH INTEGER) ...)

(CL:DEFUN COMPUTE-FRAME-DEPTH (FRAME)
  (CL:LET* ((DEPTH 0) (CURSOR (%BASE-CONTROL-FRAME *QUERYITERATOR*)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
    (CL:WHEN (CL:EQ CURSOR FRAME) (CL:RETURN))
    (CL:SETQ CURSOR (%DOWN CURSOR)) (CL:SETQ DEPTH (CL:1+ DEPTH)))
   (CL:IF (CL:EQ CURSOR FRAME) DEPTH NULL-INTEGER)))

;;; (DEFUN PRINT-VERTICAL-BARS ...)

(CL:DEFUN PRINT-VERTICAL-BARS (DEPTH)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
  (CL:LET* ((I (INTERVAL 1 DEPTH)))
   (CL:LOOP WHILE (NEXT? I) DO
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "| "))))

;;; (DEFUN UNWIND-TO-CHOICE-POINTS-BELOW-FRAME ...)

(CL:DEFUN UNWIND-TO-CHOICE-POINTS-BELOW-FRAME (FRAME)
  (CL:WHEN (CL:NOT (CL:EQ FRAME NULL)) (UNWIND-TO-CHOICE-POINT FRAME)
   (UNWIND-TO-CHOICE-POINTS-BELOW-FRAME (%DOWN FRAME))))

;;; (DEFUN TRACE-GOAL-TREE ...)

(CL:DEFUN TRACE-GOAL-TREE (FRAME DEPTH LASTMOVE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
  (CL:WHEN (CL:EQ LASTMOVE KWD-QUERY-DOWN)
   (UNWIND-TO-CHOICE-POINTS-BELOW-FRAME FRAME))
  (CL:WHEN
   (CL:AND (CL:EQ (%STATE FRAME) KWD-QUERY-ITERATIVE-FORALL)
    (CL:EQ LASTMOVE KWD-QUERY-DOWN))
   (CL:RETURN-FROM TRACE-GOAL-TREE))
  (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-STATE-MACHINE)
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE FRAME)
      SGT-QUERY-LOGIC-PARALLEL-CONTROL-FRAME)
     (CL:PROGN
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "P"
       (%DEBUG-FRAME-ID FRAME))))
    (CL:T
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "F"
      (%DEBUG-FRAME-ID FRAME))))
   (CL:IF (DEFINED? (%CHOICE-POINT-UNBINDING-OFFSET FRAME))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) ","
     (%CHOICE-POINT-UNBINDING-OFFSET FRAME) " ")
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   "))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    (CL:IF (%HOLDS-BY-DEFAULT? FRAME) "D " "S ")))
  (CL:WHEN
   (CL:OR (CL:EQ (%STATE FRAME) KWD-QUERY-PARALLEL-STRATEGIES)
    (CL:AND (CL:EQ (%STATE FRAME) KWD-QUERY-STRATEGY)
     (CL:EQ (%CURRENT-STRATEGY FRAME) NULL)))
   (CL:RETURN-FROM TRACE-GOAL-TREE))
  (CL:WHEN
   (CL:NOT
    (CL:AND (CL:EQ LASTMOVE KWD-QUERY-DOWN)
     (MEMBER?
      (GET-QUOTED-TREE "((:ATOMIC-GOAL :STRATEGY) \"/LOGIC\")" "/LOGIC")
      (%STATE FRAME))
     (CL:EQ (%%VALUE (%NEXT-STRATEGIES FRAME)) KWD-QUERY-SPECIALIST)
     (CL:NOT (TRACE-KEYWORD? KWD-QUERY-STRATEGIES))))
   (PRINT-VERTICAL-BARS DEPTH))
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:LET* ((TEST-VALUE-000 (%STATE FRAME)))
     (CL:COND
      ((CL:OR (CL:EQ TEST-VALUE-000 KWD-QUERY-ATOMIC-GOAL)
        (CL:EQ TEST-VALUE-000 KWD-QUERY-STRATEGY))
       (CL:IF
        (CL:EQ (%%VALUE (%NEXT-STRATEGIES FRAME)) KWD-QUERY-SPECIALIST)
        (CL:PROGN
         (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-STRATEGIES)
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
           "TRY STRATEGIES: "))
         (CL:RETURN-FROM TRACE-GOAL-TREE))
        (CL:PROGN (PRINT-GOAL-IN-GOAL-TREE FRAME DEPTH)
         (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-STRATEGIES)
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL)
          (PRINT-VERTICAL-BARS DEPTH)
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "STRATEGY: ")
          (CL:RETURN-FROM TRACE-GOAL-TREE)))))
      ((CL:EQ TEST-VALUE-000 KWD-QUERY-PATTERN)
       (CL:LET* ((UPFRAME (%UP FRAME)))
        (CL:IF
         (CL:AND (CL:NOT (CL:EQ UPFRAME NULL))
          (CL:NOT
           (CL:EQ
            (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS UPFRAME)
             SYM-QUERY-LOGIC-ANTECEDENTS-RULE NULL)
            NULL)))
         (PRINT-RULE-IN-GOAL-TREE FRAME
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS UPFRAME)
           SYM-QUERY-LOGIC-ANTECEDENTS-RULE NULL)
          DEPTH)
         (CL:PROGN
          (CL:WHEN
           (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
            (CL:NOT
             (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL))
          (CL:IF
           (CL:NOT
            (CL:EQ (%COLLECTION-LIST (%PATTERN-RECORD FRAME)) NULL))
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
            "COLLECTION: [")
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "PATTERN: ["))
          (CL:LET* ((FIRSTTIME? TRUE))
           (CL:LET*
            ((TV NULL)
             (VECTOR-000 (%BOOLEAN-VECTOR (%PATTERN-RECORD FRAME)))
             (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
            (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
            (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
             (CL:PROGN
              (CL:SETQ TV
               (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
                INDEX-000))
              (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
             (CL:IF FIRSTTIME? (CL:SETQ FIRSTTIME? FALSE)
              (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) ","))
             (CL:IF (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN TV)
              (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "T")
              (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "F")))))
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "]")))))
      (CL:T (PRINT-GOAL-IN-GOAL-TREE FRAME DEPTH)))))
   ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
    (CL:COND
     (CL:T
      (CL:IF (%HOLDS-BY-DEFAULT? FRAME)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
        "| DEFAULT-SUCC: ")
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "| SUCC: "))
      (CL:LET* ((*PRINTINFRAME* FRAME))
       (CL:DECLARE (CL:SPECIAL *PRINTINFRAME*))
       (PRINT-VARIABLE-BINDINGS FRAME)))))
   ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
    (CL:LET* ((TEST-VALUE-001 (%STATE FRAME)))
     (CL:COND
      ((CL:OR (CL:EQ TEST-VALUE-001 KWD-QUERY-ATOMIC-GOAL)
        (CL:EQ TEST-VALUE-001 KWD-QUERY-STRATEGY))
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "| FAIL ")
       (CL:WHEN
        (CL:AND (TRACE-KEYWORD? KWD-QUERY-STRATEGIES)
         (CL:NOT (CL:EQ (%NEXT-STRATEGIES FRAME) NIL)))
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL)
        (PRINT-VERTICAL-BARS DEPTH)
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
         "TRY STRATEGIES: ")
        (CL:RETURN-FROM TRACE-GOAL-TREE)))
      (CL:T
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "| FAIL ")))))
   (CL:T (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "????: ")))
  (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-STATE-MACHINE)
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) " state= "
    (%STATE FRAME) "  lastMove= " LASTMOVE " depth= " DEPTH " revPty?= "
    (%REVERSE-POLARITY? FRAME)))
  (CL:COND
   ((CL:EQ (%PARTIAL-MATCH-FRAME FRAME) NULL)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL))
   ((CL:AND (CL:EQ LASTMOVE KWD-QUERY-DOWN)
     (CL:NOT (CL:EQ (%PARTIAL-MATCH-FRAME FRAME) NULL)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) " Search Cutoff: "
     (%DYNAMIC-CUTOFF (%PARTIAL-MATCH-FRAME FRAME)) EOL))))

;;; (DEFUN (INTERPRET-AND-SCORES KEYWORD) ...)

(CL:DEFUN INTERPRET-AND-SCORES (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:LET* ((PMF (%PARTIAL-MATCH-FRAME FRAME)))
     (CL:IF (CL:EQ PMF NULL)
      (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME KWD-QUERY-AND)
      (CL:PROGN
       (CL:LOOP WHILE
        (CL:> (LENGTH (%ARGUMENT-SCORES (%PARTIAL-MATCH-FRAME FRAME)))
         (%ARGUMENT-CURSOR FRAME))
        DO (POP-PARTIAL-MATCH-SCORE (%PARTIAL-MATCH-FRAME FRAME)))
       (SET-DYNAMIC-CUTOFF PMF
        (PROPOSITION-WEIGHT (%PROPOSITION FRAME)))))))
   ((CL:OR (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
    (CL:LET*
     ((PMF (%PARTIAL-MATCH-FRAME FRAME))
      (ARITY (LENGTH (%ARGUMENTS (%PROPOSITION FRAME)))) (TEMP 0.0d0)
      (I 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY I)
      (CL:TYPE CL:DOUBLE-FLOAT TEMP))
     (CL:IF (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
      (CL:SETF (%SUCCESS? PMF) TRUE) (CL:SETF (%SUCCESS? PMF) FALSE))
     (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)
     (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE)
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) ", "
       (COMPUTE-AND-SCORE (%PARTIAL-MATCH-FRAME FRAME)) EOL))
     (CL:WHEN (CL:NOT (CL:EQ (%UNBOUND-VARS PMF) NIL))
      (CL:SETF (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) 0.0d0)
      (CL:LOOP
       (CL:LET* ((TEST-VALUE-000 FALSE))
        (CL:SETQ TEST-VALUE-000
         (< (CL:1+ (%ARGUMENT-CURSOR FRAME)) ARITY))
        (CL:WHEN TEST-VALUE-000
         (CL:LET* ((FOUND?-000 FALSE))
          (CL:LET*
           ((VAR NULL)
            (ITER-000
             (GET-UNBOUND-VARIABLES
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (%THE-ARRAY (%ARGUMENTS (%PROPOSITION FRAME))))
               (CL:THE CL:FIXNUM (CL:1+ (%ARGUMENT-CURSOR FRAME)))))))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
            (CL:PROGN (CL:SETQ VAR (%%VALUE ITER-000))
             (CL:SETQ ITER-000 (%%REST ITER-000)))
            (CL:WHEN (SEARCH-CONS-TREE? (%UNBOUND-VARS PMF) VAR)
             (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
          (CL:SETQ TEST-VALUE-000 FOUND?-000)))
        (CL:WHEN (CL:NOT TEST-VALUE-000) (CL:RETURN)))
       (CL:SETQ I (CL:1+ I))
       (CL:SETF (%ARGUMENT-CURSOR FRAME) (CL:1+ (%ARGUMENT-CURSOR FRAME)))
       (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME))
      (CL:SETF (%UNBOUND-VARS PMF) NIL)
      (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   *** Skipping "
        I " propositions . . ." EOL)))
     (CL:WHEN *FAIL-UNBOUND-CLAUSES*
      (CL:LOOP WHILE
       (CL:AND (CL:< (CL:1+ (%ARGUMENT-CURSOR FRAME)) ARITY)
        (ALL-VARIABLES-UNBOUND?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY (%ARGUMENTS (%PROPOSITION FRAME))))
          (CL:THE CL:FIXNUM (CL:1+ (%ARGUMENT-CURSOR FRAME))))))
       DO (CL:SETQ I (CL:1+ I))
       (CL:SETF (%ARGUMENT-CURSOR FRAME) (CL:1+ (%ARGUMENT-CURSOR FRAME)))
       (CL:SETF (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) 0.0d0)
       (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME))
      (CL:WHEN (CL:AND (CL:> I 0) (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE))
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   *** Skipping "
        I " propositions . . ." EOL)))
     (CL:COND
      ((COMPUTE-PARTIAL-MATCH-AND-FAILURE? FRAME)
       (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
      ((CL:AND
        (CL:= (CL:1+ (%ARGUMENT-CURSOR FRAME))
         (LENGTH (%ARGUMENTS (%PROPOSITION FRAME))))
        (CL:NOT (COMPUTE-PARTIAL-MATCH-SCORE? FRAME)))
       (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
      (CL:T (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  LASTMOVE)

;;; (DEFUN (FRAME-DEPTH INTEGER) ...)

(CL:DEFUN FRAME-DEPTH (FRAME)
  (CL:LET* ((I 0) (TEMP FRAME)) (CL:DECLARE (CL:TYPE CL:FIXNUM I))
   (CL:LOOP WHILE (CL:NOT (CL:EQ TEMP NULL)) DO (CL:SETQ TEMP (%UP TEMP))
    (CL:SETQ I (CL:1+ I)))
   I))

;;; (DEFUN (UNBOUND-VARIABLES-IN-FRAME? BOOLEAN) ...)

(CL:DEFUN UNBOUND-VARIABLES-IN-FRAME? (FRAME)
  (CL:NOT (CL:EQ (GET-UNBOUND-VARIABLES (%PROPOSITION FRAME)) NIL)))

;;; (DEFUN (GET-UNBOUND-VARIABLES-NON-FUNCTIONAL CONS) ...)

(CL:DEFUN GET-UNBOUND-VARIABLES-NON-FUNCTIONAL (PROP)
  (CL:LET* ((VARS (GET-UNBOUND-VARIABLES PROP)))
   (CL:WHEN (CL:NOT (CL:EQ (%KIND PROP) KWD-QUERY-FUNCTION))
    (CL:RETURN-FROM GET-UNBOUND-VARIABLES-NON-FUNCTIONAL VARS))
   (CL:WHEN (CL:EQ (ARGUMENT-BOUND-TO (LAST (%ARGUMENTS PROP))) NULL)
    (CL:SETQ VARS (REMOVE VARS (LAST (%ARGUMENTS PROP)))))
   VARS))

;;; (DEFUN (INTERPRET-ITERATIVE-FORALL-SCORES KEYWORD) ...)

(CL:DEFUN INTERPRET-ITERATIVE-FORALL-SCORES (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:IF (CL:EQ (%PARTIAL-MATCH-FRAME FRAME) NULL)
     (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME
      KWD-QUERY-ITERATIVE-FORALL)
     (CL:LOOP WHILE
      (CL:> (LENGTH (%ARGUMENT-SCORES (%PARTIAL-MATCH-FRAME FRAME)))
       (%ARGUMENT-CURSOR FRAME))
      DO (POP-PARTIAL-MATCH-SCORE (%PARTIAL-MATCH-FRAME FRAME)))))
   ((CL:OR (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
    (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)
    (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "ITERATIVE-FORALL "
      (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) EOL))
    (CL:WHEN (CL:< (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) 0.9d0)
     (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  LASTMOVE)

;;; (DEFUN (INTERPRET-OR-SCORES KEYWORD) ...)

(CL:DEFUN INTERPRET-OR-SCORES (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:LET* ((PMF (%PARTIAL-MATCH-FRAME FRAME)))
     (CL:IF (CL:EQ PMF NULL)
      (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME KWD-QUERY-OR)
      (CL:PROGN
       (CL:LOOP WHILE
        (CL:> (LENGTH (%ARGUMENT-SCORES (%PARTIAL-MATCH-FRAME FRAME)))
         (%ARGUMENT-CURSOR FRAME))
        DO (POP-PARTIAL-MATCH-SCORE (%PARTIAL-MATCH-FRAME FRAME)))
       (SET-DYNAMIC-CUTOFF PMF
        (PROPOSITION-WEIGHT (%PROPOSITION FRAME)))))))
   ((CL:OR (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
    (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)
    (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) ", "
      (COMPUTE-OR-SCORE (%PARTIAL-MATCH-FRAME FRAME)) EOL))
    (CL:COND
     ((COMPUTE-PARTIAL-MATCH-OR-SUCCESS? FRAME)
      (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))
     ((CL:AND
       (CL:= (CL:1+ (%ARGUMENT-CURSOR FRAME))
        (LENGTH (%ARGUMENTS (%PROPOSITION FRAME))))
       (COMPUTE-PARTIAL-MATCH-SCORE? FRAME))
      (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))
     (CL:T (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  LASTMOVE)

;;; (DEFUN (INTERPRET-FAIL-SCORE KEYWORD) ...)

(CL:DEFUN INTERPRET-FAIL-SCORE (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:SETF (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) 0.0d0)
    (CL:WHEN (CL:EQ (%PARTIAL-MATCH-FRAME FRAME) NULL)
     (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME KWD-QUERY-NOT)))
   ((CL:OR (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
    (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)
    (CL:IF (COMPUTE-PARTIAL-MATCH-SCORE? FRAME)
     (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  LASTMOVE)

;;; (DEFUN (INTERPRET-GOAL-SCORES KEYWORD) ...)

(CL:DEFUN INTERPRET-GOAL-SCORES (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:LET* ((PMF (%PARTIAL-MATCH-FRAME FRAME)))
     (CL:IF (CL:EQ PMF NULL)
      (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME KWD-QUERY-ATOMIC-GOAL)
      (SET-DYNAMIC-CUTOFF PMF
       (PROPOSITION-WEIGHT (%PROPOSITION FRAME))))))
   ((CL:OR (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
    (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) EOL))
    (CL:WHEN
     (CL:OR (CL:EQ (%CURRENT-STRATEGY FRAME) KWD-QUERY-FULL-SUBQUERY)
      (CL:EQ (%CURRENT-STRATEGY FRAME) KWD-QUERY-ANTECEDENTS))
     (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)
     (CL:COND
      ((CL:AND (COMPUTE-PARTIAL-MATCH-OR-SUCCESS? FRAME)
        (CL:NOT (UNBOUND-VARIABLES-IN-FRAME? FRAME)))
       (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))
      ((CL:AND
        (EMPTY?
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
          SYM-QUERY-STELLA-ITERATOR NULL))
        (CL:NOT (UNBOUND-VARIABLES-IN-FRAME? FRAME))
        (COMPUTE-PARTIAL-MATCH-SCORE? FRAME))
       (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))
      (CL:T (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  LASTMOVE)

;;; (DEFUN ATTACH-SUPPORT ...)

(CL:DEFUN ATTACH-SUPPORT (FRAME LASTMOVE)
  (CL:IF
   (CL:AND (CL:NOT (CL:EQ LASTMOVE KWD-QUERY-DOWN))
    (CL:EQ (%CURRENT-STRATEGY FRAME) KWD-QUERY-ANTECEDENTS)
    (ISA? (%PARTIAL-MATCH-FRAME FRAME) SGT-QUERY-LOGIC-NN-PARTIAL-MATCH)
    (CL:NOT (CL:EQ (%CHILD (%PARTIAL-MATCH-FRAME FRAME)) NULL)))
   (CL:LET*
    ((PMF (%PARTIAL-MATCH-FRAME FRAME)) (SUPPORT (NEW-PARTIAL-SUPPORT)))
    (CL:SETF (%ID SUPPORT)
     (CL:SETQ *PARTIAL-SUPPORT-COUNTER*
      (CL:1+ *PARTIAL-SUPPORT-COUNTER*)))
    (CL:SETF (%AXIOM SUPPORT) (%%VALUE (%RULES PMF)))
    (CL:SETF (%FACT SUPPORT) (%PROPOSITION (%FRAME-PTR (%CHILD PMF))))
    (CL:SETF (%ARGUMENT-SCORES SUPPORT)
     (REVERSE (COPY-CONS-LIST (%ARGUMENT-SCORES (%CHILD PMF)))))
    (CL:SETF (%SCORE SUPPORT)
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%FACT SUPPORT))
       SYM-QUERY-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER)))
    (CL:IF (CL:NOT (CL:EQ (SUPPORT (%PROPOSITION FRAME)) NULL))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%PROPOSITION FRAME))
      SYM-QUERY-LOGIC-SUPPORT
      (CONS SUPPORT (SUPPORT (%PROPOSITION FRAME))) NULL)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%PROPOSITION FRAME))
      SYM-QUERY-LOGIC-SUPPORT (CONS-LIST SUPPORT) NULL)))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%PROPOSITION FRAME))
    SYM-QUERY-LOGIC-SUPPORT NULL NULL)))

;;; (DEFGLOBAL *CONTROL-FRAME-ID-COUNTER* ...)

(CL:PROGN (CL:DEFVAR *CONTROL-FRAME-ID-COUNTER* -1 "Generates unique IDs for control frames.  Used
only for debugging.") (CL:DECLAIM (CL:TYPE CL:FIXNUM *CONTROL-FRAME-ID-COUNTER*)))

;;; (DEFUN (OPERATIVE-PATTERN-RECORD PATTERN-RECORD) ...)

(CL:DEFUN OPERATIVE-PATTERN-RECORD (FRAME)
  (CL:IF (CL:NOT (CL:EQ (%PATTERN-RECORD FRAME) NULL))
   (%PATTERN-RECORD FRAME) (%INHERITED-PATTERN-RECORD FRAME)))

;;; (DEFUN (CREATE-DOWN-FRAME CONTROL-FRAME) ...)

(CL:DEFUN CREATE-DOWN-FRAME (UPFRAME DOWNPROPOSITION)
  (CL:LET* ((DOWNFRAME (NEW-CONTROL-FRAME)))
   (CL:SETF (%DOWN UPFRAME) DOWNFRAME) (CL:SETF (%UP DOWNFRAME) UPFRAME)
   (CL:SETF (%REVERSE-POLARITY? DOWNFRAME) (%REVERSE-POLARITY? UPFRAME))
   (CL:SETF (%PROPOSITION DOWNFRAME) DOWNPROPOSITION)
   (CL:SETF (%DOWN DOWNFRAME) NULL)
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS DOWNFRAME) SYM-QUERY-LOGIC-BACK
    NULL NULL)
   (CL:SETF (%PATTERN-RECORD DOWNFRAME) NULL)
   (CL:SETF (%HOLDS-BY-DEFAULT? DOWNFRAME) FALSE)
   (CLEAR (%JUSTIFICATIONS DOWNFRAME))
   (CL:SETF (%JUSTIFICATION DOWNFRAME) NULL)
   (CL:SETF (%GOAL-CACHE DOWNFRAME) NULL)
   (CL:SETF (%BINDINGS-COUNTER DOWNFRAME) 0)
   (CL:SETF (%GOAL-BINDINGS DOWNFRAME) NULL)
   (CL:SETF (%CACHED-BINDINGS-ITERATOR DOWNFRAME) NULL)
   (CL:SETF (%DEBUG-DEPTH DOWNFRAME) 0)
   (CL:WHEN (CL:NOT (CL:EQ DOWNPROPOSITION NULL))
    (CL:SETF (%STATE DOWNFRAME) (%KIND DOWNPROPOSITION))
    (CL:WHEN (%REVERSE-POLARITY? DOWNFRAME)
     (CL:LET* ((TEST-VALUE-000 (%STATE DOWNFRAME)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-AND)
        (CL:SETF (%STATE DOWNFRAME) KWD-QUERY-OR))
       ((CL:EQ TEST-VALUE-000 KWD-QUERY-OR)
        (CL:SETF (%STATE DOWNFRAME) KWD-QUERY-AND))
       (CL:T))))
    (CL:SETF (%ARGUMENT-CURSOR DOWNFRAME) 0))
   (CL:SETF (%INHERITED-PATTERN-RECORD DOWNFRAME)
    (OPERATIVE-PATTERN-RECORD UPFRAME))
   (CL:SETQ *CONTROL-FRAME-ID-COUNTER* (CL:1+ *CONTROL-FRAME-ID-COUNTER*))
   (CL:SETF (%DEBUG-FRAME-ID DOWNFRAME) *CONTROL-FRAME-ID-COUNTER*)
   DOWNFRAME))

;;; (DEFUN COPY-FRAME-STATE ...)

(CL:DEFUN COPY-FRAME-STATE (FROMFRAME TOFRAME)
  (CL:SETF (%PROPOSITION TOFRAME) (%PROPOSITION FROMFRAME))
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS TOFRAME)
   SYM-QUERY-LOGIC-DESCRIPTION
   (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FROMFRAME)
    SYM-QUERY-LOGIC-DESCRIPTION NULL)
   NULL)
  (CL:SETF (%REVERSE-POLARITY? TOFRAME) (%REVERSE-POLARITY? FROMFRAME))
  (CL:SETF (%UP TOFRAME) (%UP FROMFRAME))
  (CL:SETF (%PARTIAL-MATCH-FRAME TOFRAME) (%PARTIAL-MATCH-FRAME FROMFRAME))
  (CL:SETF (%INHERITED-PATTERN-RECORD TOFRAME)
   (%INHERITED-PATTERN-RECORD FROMFRAME))
  (CL:SETF (%CHOICE-POINT-UNBINDING-OFFSET TOFRAME)
   (%CHOICE-POINT-UNBINDING-OFFSET FROMFRAME))
  (CL:SETF (%NEXT-STRATEGIES TOFRAME) (%NEXT-STRATEGIES FROMFRAME))
  (CL:SETF (%CACHED-BINDINGS-ITERATOR TOFRAME)
   (%CACHED-BINDINGS-ITERATOR FROMFRAME))
  (CL:SETF (%GOAL-BINDINGS TOFRAME) (%GOAL-BINDINGS FROMFRAME))
  (CL:SETF (%GOAL-CACHE TOFRAME) (%GOAL-CACHE FROMFRAME))
  (CL:SETF (%BINDINGS-COUNTER TOFRAME) (%BINDINGS-COUNTER FROMFRAME))
  (CL:SETF (%DEBUG-DEPTH TOFRAME) (%DEBUG-DEPTH FROMFRAME)))

;;; (DEFUN (PARALLELIZE-CONTROL-FRAME PARALLEL-CONTROL-FRAME) ...)

(CL:DEFUN PARALLELIZE-CONTROL-FRAME (FRAME)
  (CL:WHEN (CL:EQ (%STATE FRAME) KWD-QUERY-PARALLEL-STRATEGIES)
   (CL:RETURN-FROM PARALLELIZE-CONTROL-FRAME FRAME))
  (CL:LET* ((PARALLELPARENT (NEW-PARALLEL-CONTROL-FRAME)))
   (CL:SETF (%STATE PARALLELPARENT) KWD-QUERY-PARALLEL-STRATEGIES)
   (CL:SETQ *CONTROL-FRAME-ID-COUNTER* (CL:1+ *CONTROL-FRAME-ID-COUNTER*))
   (CL:SETF (%DEBUG-FRAME-ID PARALLELPARENT) *CONTROL-FRAME-ID-COUNTER*)
   (COPY-FRAME-STATE FRAME PARALLELPARENT)
   (CL:SETF (%DOWN (%UP FRAME)) PARALLELPARENT)
   (CL:SETF (%NEXT-STRATEGIES FRAME) NIL)
   (CL:SETF (%CACHED-BINDINGS-ITERATOR FRAME) NULL)
   (CL:SETF (%GOAL-CACHE FRAME) NULL)
   (CL:SETF (%UNBOUND-VARIABLES? PARALLELPARENT)
    (CL:NOT (ALL-ARGUMENTS-BOUND? (%PROPOSITION PARALLELPARENT))))
   (CL:WHEN
    (CL:OR (CL:NOT (CL:EQ (%DOWN FRAME) NULL))
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
        SYM-QUERY-STELLA-ITERATOR NULL)
       NULL)))
    (CL:LET* ((CHILDTHREAD (NEW-PARALLEL-THREAD)))
     (CL:SETF (%UP FRAME) PARALLELPARENT)
     (CL:SETF (%DEBUG-DEPTH FRAME) (CL:1+ (%DEBUG-DEPTH FRAME)))
     (CL:SETF (%TOP-CONTROL-FRAME CHILDTHREAD) FRAME)
     (INSERT (%CHILD-THREADS PARALLELPARENT) CHILDTHREAD)
     (CL:WHEN (%UNBOUND-VARIABLES? PARALLELPARENT)
      (CL:LET* ((PATTERNRECORD (%INHERITED-PATTERN-RECORD FRAME)))
       (CL:SETF (%VARIABLE-BINDINGS CHILDTHREAD)
        (COPY (%VARIABLE-BINDINGS PATTERNRECORD)))
       (CL:SETF (%UNBINDING-STACK CHILDTHREAD)
        (COPY (%UNBINDING-STACK PATTERNRECORD)))
       (CL:SETF (%TOP-UNBINDING-STACK-OFFSET CHILDTHREAD)
        (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))))))
   (CL:WHEN (CL:EQ (%CURRENT-CONTROL-FRAME *QUERYITERATOR*) FRAME)
    (CL:SETF (%CURRENT-CONTROL-FRAME *QUERYITERATOR*) PARALLELPARENT))
   PARALLELPARENT))

;;; (DEFUN ENTER-PARALLEL-THREAD ...)

(CL:DEFUN ENTER-PARALLEL-THREAD (PFRAME CHILDTHREAD)
  (CL:IF (CL:NOT (CL:EQ CHILDTHREAD NULL))
   (CL:PROGN (CL:SETF (%CURRENT-CHILD-THREAD PFRAME) CHILDTHREAD)
    (CL:SETF (%DOWN PFRAME) (%TOP-CONTROL-FRAME CHILDTHREAD)))
   (CL:SETQ CHILDTHREAD (%CURRENT-CHILD-THREAD PFRAME)))
  (CL:SETF (%SAVED-PARENT-PARALLEL-THREAD PFRAME)
   (%CURRENT-PARALLEL-THREAD *QUERYITERATOR*))
  (CL:SETF (%CURRENT-PARALLEL-THREAD *QUERYITERATOR*) CHILDTHREAD)
  (CL:SETF (%SAVED-PARENT-CONTEXT PFRAME) *CONTEXT*)
  (CL:WHEN (CL:NOT (CL:EQ (%HYPOTHETICAL-WORLD CHILDTHREAD) NULL))
   (CHANGE-CONTEXT (%HYPOTHETICAL-WORLD CHILDTHREAD))))

;;; (DEFUN EXIT-PARALLEL-THREAD ...)

(CL:DEFUN EXIT-PARALLEL-THREAD (PFRAME)
  (CL:SETF (%CURRENT-PARALLEL-THREAD *QUERYITERATOR*)
   (%SAVED-PARENT-PARALLEL-THREAD PFRAME))
  (CL:WHEN (CL:NOT (CL:EQ (%SAVED-PARENT-CONTEXT PFRAME) NULL))
   (CL:IF
    (CL:AND (CL:EQ (%DOWN PFRAME) NULL)
     (CL:NOT
      (CL:EQ (%HYPOTHETICAL-WORLD (%CURRENT-CHILD-THREAD PFRAME)) NULL)))
    (CL:PROGN (POP-WORLD))
    (CHANGE-CONTEXT (%SAVED-PARENT-CONTEXT PFRAME)))
   (CL:SETF (%SAVED-PARENT-CONTEXT PFRAME) NULL))
  (CL:WHEN (CL:EQ (%DOWN PFRAME) NULL)
   (REMOVE (%CHILD-THREADS PFRAME) (%CURRENT-CHILD-THREAD PFRAME))
   (CL:SETF (%CURRENT-CHILD-THREAD PFRAME) NULL)))

;;; (DEFUN (ENTER-HYPOTHETICAL-WORLD WORLD) ...)

(CL:DEFUN ENTER-HYPOTHETICAL-WORLD (PFRAME)
  (CL:LET*
   ((CHILDTHREAD (%CURRENT-CHILD-THREAD PFRAME))
    (WORLD (%HYPOTHETICAL-WORLD CHILDTHREAD)))
   (CL:IF (CL:EQ WORLD NULL)
    (CL:PROGN
     (CL:SETF (%HYPOTHETICAL-WORLD CHILDTHREAD) (PUSH-MONOTONIC-WORLD))
     (INITIALIZE-INFERENCE-WORLD *CONTEXT*))
    NULL)
   WORLD))

;;; (DEFUN (PARTIAL-MATCH-MODE? BOOLEAN) ...)

(CL:DEFUN PARTIAL-MATCH-MODE? ()
  (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
   (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL))))

;;; (DEFUN (EXECUTE-BACKWARD-CHAINING-PROOF? BOOLEAN) ...)

(CL:DEFUN EXECUTE-BACKWARD-CHAINING-PROOF? (QUERYITERATOR)
  (CL:WHEN (CL:EQ (%DOWN (%BASE-CONTROL-FRAME QUERYITERATOR)) NULL)
   (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? FALSE))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
    (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
   (CL:SETF (%PARTIAL-MATCH-FRAME (%BASE-CONTROL-FRAME QUERYITERATOR))
    (%PARTIAL-MATCH-STRATEGY QUERYITERATOR)))
  (CL:LET* ((*QUERYITERATOR* QUERYITERATOR))
   (CL:DECLARE (CL:SPECIAL *QUERYITERATOR*))
   (CL:LET*
    ((FRAME (%BASE-CONTROL-FRAME QUERYITERATOR)) (DEPTH 0)
     (LASTMOVE KWD-QUERY-DOWN) (RESULTOFNEXTMOVE NULL) (CLOCKTICKS 0)
     (STARTTIME (GET-TICKTOCK))
     (ALLOTTEDTIME (%ALLOTTED-TIME QUERYITERATOR))
     (CHECKFORTIMEOUT? (CL:NOT (CL:= ALLOTTEDTIME NULL-FLOAT)))
     (TIMEOUT? FALSE)
     (PARTIALMATCHMODE?
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH CLOCKTICKS)
     (CL:TYPE CL:DOUBLE-FLOAT ALLOTTEDTIME))
    (CL:SETF (%TIMEOUT? QUERYITERATOR) FALSE)
    (CL:LOOP (CL:SETF (%CURRENT-CONTROL-FRAME QUERYITERATOR) FRAME)
     (CL:WHEN (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE)
      (TRACE-GOAL-TREE FRAME DEPTH LASTMOVE))
     (CL:SETQ CLOCKTICKS (CL:1+ CLOCKTICKS))
     (CL:WHEN
      (CL:AND CHECKFORTIMEOUT?
       (CL:= (CL:THE CL:FIXNUM (CL:LOGAND CLOCKTICKS 15)) 0)
       (CL:>= (TICKTOCK-DIFFERENCE STARTTIME (GET-TICKTOCK))
        ALLOTTEDTIME))
      (CL:SETQ TIMEOUT? TRUE))
     (CL:WHEN
      (CL:AND PARTIALMATCHMODE? (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
       (CL:= (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) 0.0d0))
      (SET-BASE-PARTIAL-MATCH-TRUTH
       (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) (%PROPOSITION FRAME)
       KWD-QUERY-TRUE))
     (CL:WHEN
      (CL:AND
       (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
        (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
       (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
       (CL:= (%LATEST-POSITIVE-SCORE *QUERYITERATOR*) 1.0d0))
      (SET-BASE-PARTIAL-MATCH-TRUTH
       (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) (%PROPOSITION FRAME)
       KWD-QUERY-FAIL))
     (CL:WHEN (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)
      (CL:SETF (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*) FALSE))
     (CL:SETQ RESULTOFNEXTMOVE
      (EVALUATE-NEXT-MOVE FRAME LASTMOVE CLOCKTICKS))
     (CL:SETQ FRAME (%CURRENT-CONTROL-FRAME QUERYITERATOR))
     (RECORD-LAST-DYNAMIC-CUTOFF FRAME RESULTOFNEXTMOVE)
     (CL:COND
      ((CL:EQ RESULTOFNEXTMOVE KWD-QUERY-MOVE-DOWN)
       (CL:PROGN (CL:SETQ DEPTH (CL:1+ DEPTH))
        (CL:SETF (%STARTING-CLOCK-TICKS FRAME) CLOCKTICKS)
        (CL:COND
         ((CL:> DEPTH (%CURRENT-DEPTH-CUTOFF QUERYITERATOR))
          (CL:WHEN (CL:NOT (CL:EQ (%DOWN FRAME) NULL))
           (POP-FRAMES-UP-TO (%DOWN FRAME)))
          (CL:SETQ DEPTH (CL:1- DEPTH))
          (CL:MULTIPLE-VALUE-SETQ (FRAME DEPTH)
           (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
          (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
         ((CL:NOT (CL:EQ (%DOWN FRAME) NULL))
          (CL:SETQ FRAME (%DOWN FRAME))
          (CL:SETF (%STARTING-CLOCK-TICKS FRAME) CLOCKTICKS)
          (CL:SETF (%HOLDS-BY-DEFAULT? FRAME) FALSE)
          (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
         (CL:T
          (CL:LET*
           ((UPFRAME FRAME)
            (PROPOSITION
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%THE-ARRAY (%ARGUMENTS (%PROPOSITION UPFRAME))))
              (CL:THE CL:FIXNUM (%ARGUMENT-CURSOR UPFRAME)))))
           (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
           (CL:SETF (%DEBUG-DEPTH FRAME) DEPTH)
           (CL:SETF (%STARTING-CLOCK-TICKS FRAME) CLOCKTICKS)
           (CL:SETQ LASTMOVE KWD-QUERY-DOWN)))))
       (CL:WHEN (CL:AND TIMEOUT? (CL:EQ LASTMOVE KWD-QUERY-DOWN))
        (CL:SETF (%TIMEOUT? QUERYITERATOR) TRUE)
        (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? FALSE)))
      ((CL:EQ RESULTOFNEXTMOVE KWD-QUERY-FINAL-SUCCESS)
       (CL:PROGN
        (CL:WHEN (CL:NOT (CL:EQ (%UP FRAME) NULL))
         (CL:WHEN *RECORD-JUSTIFICATIONS?*
          (RECORD-JUSTIFICATION FRAME KWD-QUERY-UP-TRUE))
         (CL:WHEN (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)
          (RECORD-HOLDS-BY-DEFAULT FRAME KWD-QUERY-UP-TRUE))
         (CL:IF
          (CL:AND (CL:OR *CACHE-SUCCEEDED-GOALS?* *CACHE-FAILED-GOALS?*)
           (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
           (CL:NOT
            (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
             (CL:NOT
              (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))))
          (CACHE-GOAL FRAME TRUE FALSE CLOCKTICKS)
          (UPDATE-GOAL-CACHE FRAME TRUE)))
        (CL:SETQ DEPTH (CL:1- DEPTH)) (CL:SETQ FRAME (%UP FRAME))
        (CL:WHEN (CL:EQ FRAME NULL)
         (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? TRUE))
        (POP-DOWN-FRAME FRAME) (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))
      ((CL:EQ RESULTOFNEXTMOVE KWD-QUERY-CONTINUING-SUCCESS)
       (CL:PROGN
        (CL:WHEN (CL:NOT (CL:EQ (%UP FRAME) NULL))
         (CL:WHEN *RECORD-JUSTIFICATIONS?*
          (RECORD-JUSTIFICATION FRAME KWD-QUERY-UP-TRUE))
         (CL:WHEN (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)
          (RECORD-HOLDS-BY-DEFAULT FRAME KWD-QUERY-UP-TRUE))
         (CL:IF
          (CL:AND (CL:OR *CACHE-SUCCEEDED-GOALS?* *CACHE-FAILED-GOALS?*)
           (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
           (CL:NOT
            (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
             (CL:NOT
              (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))))
          (CACHE-GOAL FRAME TRUE TRUE CLOCKTICKS)
          (UPDATE-GOAL-CACHE FRAME TRUE))
         (CL:SETF (%JUSTIFICATION FRAME) NULL))
        (CL:SETQ DEPTH (CL:1- DEPTH)) (CL:SETQ FRAME (%UP FRAME))
        (CL:WHEN (CL:EQ FRAME NULL)
         (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? TRUE))
        (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))
      ((CL:EQ RESULTOFNEXTMOVE KWD-QUERY-FAILURE)
       (CL:PROGN
        (CL:WHEN (CL:NOT (CL:EQ (%UP FRAME) NULL))
         (CL:WHEN *RECORD-JUSTIFICATIONS?*
          (RECORD-JUSTIFICATION FRAME KWD-QUERY-UP-FAIL))
         (CL:WHEN (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)
          (RECORD-HOLDS-BY-DEFAULT FRAME KWD-QUERY-UP-FAIL))
         (CL:IF
          (CL:AND (CL:OR *CACHE-SUCCEEDED-GOALS?* *CACHE-FAILED-GOALS?*)
           (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
           (CL:NOT
            (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
             (CL:NOT
              (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))))
          (CACHE-GOAL FRAME FALSE FALSE CLOCKTICKS)
          (UPDATE-GOAL-CACHE FRAME FALSE)))
        (CL:SETQ DEPTH (CL:1- DEPTH)) (CL:SETQ FRAME (%UP FRAME))
        (CL:WHEN (CL:EQ FRAME NULL)
         (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? FALSE))
        (POP-DOWN-FRAME FRAME) (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
      ((CL:EQ RESULTOFNEXTMOVE KWD-QUERY-MOVE-IN-PLACE)
       (CL:PROGN (CL:SETF (%STARTING-CLOCK-TICKS FRAME) CLOCKTICKS)
        (CL:SETQ LASTMOVE KWD-QUERY-DOWN)))
      ((CL:EQ RESULTOFNEXTMOVE KWD-QUERY-TIMEOUT)
       (CL:PROGN
        (CL:WHEN (CL:NOT (CL:EQ (%UP FRAME) NULL))
         (CL:WHEN *RECORD-JUSTIFICATIONS?*
          (RECORD-JUSTIFICATION FRAME KWD-QUERY-UP-FAIL))
         (CL:WHEN (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)
          (RECORD-HOLDS-BY-DEFAULT FRAME KWD-QUERY-UP-FAIL))
         (CL:IF
          (CL:AND (CL:OR *CACHE-SUCCEEDED-GOALS?* *CACHE-FAILED-GOALS?*)
           (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
           (CL:NOT
            (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
             (CL:NOT
              (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))))
          (CACHE-GOAL FRAME FALSE TRUE CLOCKTICKS)
          (UPDATE-GOAL-CACHE FRAME FALSE))
         (CL:SETF (%JUSTIFICATION FRAME) NULL))
        (CL:SETQ DEPTH (CL:1- DEPTH)) (CL:SETQ FRAME (%UP FRAME))
        (CL:WHEN (CL:EQ FRAME NULL)
         (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? FALSE))
        (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" RESULTOFNEXTMOVE
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
     (CL:WHEN
      (CL:AND (%HOLDS-BY-DEFAULT? FRAME) *DONTUSEDEFAULTKNOWLEDGE?*)
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
       "BUG: NOT USING DEFAULTS, BUT FRAME IS SET TO DEFAULT" EOL))))))

;;; (DEFUN (EVALUATE-NEXT-MOVE KEYWORD) ...)

(CL:DEFUN EVALUATE-NEXT-MOVE (FRAME LASTMOVE CLOCKTICKS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM CLOCKTICKS))
  (CL:LET* ((TEST-VALUE-000 (%STATE FRAME)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-AND)
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
      (CL:SETQ LASTMOVE (INTERPRET-AND-SCORES FRAME LASTMOVE))
      (CL:IF
       (CL:AND (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
        (CL:NOT (CL:EQ (%DOWN FRAME) NULL)))
       (CL:SETF (%DOWN FRAME) NULL)
       (RECORD-FAILURE-JUSTIFICATION FRAME LASTMOVE)))
     (CONTINUE-AND-PROOF FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-OR)
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
      (CL:SETQ LASTMOVE (INTERPRET-OR-SCORES FRAME LASTMOVE))
      (RECORD-FAILURE-JUSTIFICATION FRAME LASTMOVE))
     (CONTINUE-OR-PROOF FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-NOT)
     (CONTINUE-NOT-PROOF FRAME LASTMOVE))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-QUERY-ISA)
      (CL:EQ TEST-VALUE-000 KWD-QUERY-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-QUERY-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-QUERY-EQUIVALENT)
      (CL:EQ TEST-VALUE-000 KWD-QUERY-IMPLIES))
     (CREATE-CHOICE-POINT FRAME) (INITIATE-ATOMIC-GOAL-PROOFS FRAME))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-ATOMIC-GOAL)
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
      (CL:SETQ LASTMOVE (INTERPRET-GOAL-SCORES FRAME LASTMOVE))
      (RECORD-FAILURE-JUSTIFICATION FRAME LASTMOVE)
      (ATTACH-SUPPORT FRAME LASTMOVE)
      (CL:WHEN
       (CL:AND (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
        (CL:NOT (CL:EQ (%DOWN FRAME) NULL)))
       (CL:SETF (%DOWN FRAME) NULL))
      (CL:LET*
       ((RESULT (CONTINUE-STRATEGIES-PROOFS FRAME LASTMOVE))
        (PROP (%PROPOSITION FRAME)))
       (CL:WHEN
        (CL:NOT
         (CL:EQ
          (ACCESS-IN-CONTEXT (%TRUTH-VALUE PROP) (%HOME-CONTEXT PROP)
           FALSE)
          NULL))
        (CL:SETF (%WEIGHT PROP)
         (%POSITIVE-SCORE
          (ACCESS-IN-CONTEXT (%TRUTH-VALUE PROP) (%HOME-CONTEXT PROP)
           FALSE))))
       (CL:COND
        ((CL:AND (CL:EQ RESULT KWD-QUERY-FAILURE)
          (COMPUTE-PARTIAL-MATCH-SCORE? FRAME))
         (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)
         (CL:RETURN-FROM EVALUATE-NEXT-MOVE KWD-QUERY-FINAL-SUCCESS))
        (CL:T (CL:RETURN-FROM EVALUATE-NEXT-MOVE RESULT)))))
     (CONTINUE-STRATEGIES-PROOFS FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-STRATEGY)
     (CONTINUE-STRATEGIES-PROOFS FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-SCAN-CACHED-BINDINGS)
     (CONTINUE-CACHED-BINDINGS-PROOF FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-PATTERN)
     (CONTINUE-PATTERN-PROOF FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-FORALL)
     (CONTINUE-FORALL-PROOF FRAME LASTMOVE))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-QUERY-CONTAINED-BY)
      (CL:EQ TEST-VALUE-000 KWD-QUERY-ITERATIVE-FORALL))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
      (CL:SETQ LASTMOVE
       (INTERPRET-ITERATIVE-FORALL-SCORES FRAME LASTMOVE))
      (RECORD-FAILURE-JUSTIFICATION FRAME LASTMOVE))
     (CONTINUE-CONTAINED-BY-PROOF FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-EXISTS)
     (CONTINUE-EXISTS-PROOF FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-CONSTANT)
     (CONTINUE-CONSTANT-PROOF FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-FAIL)
     (CONTINUE-FAIL-PROOF FRAME LASTMOVE))
    ((CL:EQ TEST-VALUE-000 KWD-QUERY-PARALLEL-STRATEGIES)
     (CONTINUE-PARALLEL-STRATEGIES-PROOFS FRAME LASTMOVE))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "Error.  No query state implemented for operator `" (%STATE FRAME)
       "'" EOL)
      (CL:ERROR (NEW-FAIL-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (MOVE-FORWARD-AND-DOWN KEYWORD) ...)

(CL:DEFUN MOVE-FORWARD-AND-DOWN (FRAME)
  (CL:LET* ((BACKFRAME FRAME) (UPFRAME (%UP BACKFRAME)))
   (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME (%PROPOSITION BACKFRAME)))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME) SYM-QUERY-LOGIC-BACK
    BACKFRAME NULL)
   (CL:SETF (%STATE FRAME) KWD-QUERY-AND)
   (CL:SETF (%ARGUMENT-CURSOR FRAME) (CL:1+ (%ARGUMENT-CURSOR BACKFRAME)))
   (CL:WHEN (%HOLDS-BY-DEFAULT? BACKFRAME)
    (CL:SETF (%HOLDS-BY-DEFAULT? FRAME) TRUE)))
  (CL:SETF (%CURRENT-CONTROL-FRAME *QUERYITERATOR*) FRAME)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
    (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
   (CL:SETF (%PARTIAL-MATCH-FRAME FRAME)
    (%PARTIAL-MATCH-FRAME
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME) SYM-QUERY-LOGIC-BACK
      NULL))))
  KWD-QUERY-MOVE-DOWN)

;;; (DEFUN (MOVE-BACKWARD-AND-UP-OR-DOWN KEYWORD) ...)

(CL:DEFUN MOVE-BACKWARD-AND-UP-OR-DOWN (FRAME NEXTMOVE)
  (CL:LET* ((POS (%ARGUMENT-CURSOR FRAME)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM POS))
   (CL:LET* ((FORWARDFRAME FRAME))
    (CL:SETQ FRAME
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME) SYM-QUERY-LOGIC-BACK
      NULL))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FORWARDFRAME)
     SYM-QUERY-LOGIC-BACK NULL NULL)
    (CL:SETF (%DOWN (%UP FORWARDFRAME)) FRAME)
    (POP-CONTROL-FRAME FORWARDFRAME))
   (CL:SETF (%CURRENT-CONTROL-FRAME *QUERYITERATOR*) FRAME)
   (CL:COND
    ((CL:EQ NEXTMOVE KWD-QUERY-MOVE-DOWN)
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
      (CL:LET*
       ((I NULL-INTEGER) (ITER-000 (%ARGUMENT-CURSOR FRAME))
        (UPPER-BOUND-000 POS) (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
       (CL:LOOP WHILE
        (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
        (CL:PROGN (CL:SETQ I ITER-000)
         (CL:SETQ ITER-000 (CL:1+ ITER-000)))
        (POP-PARTIAL-MATCH-SCORE (%PARTIAL-MATCH-FRAME FRAME))))))
    ((CL:EQ NEXTMOVE KWD-QUERY-CONTINUING-SUCCESS))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" NEXTMOVE
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
  NEXTMOVE)

;;; (DEFMETHOD (CLUSTERED-CONJUNCTION? BOOLEAN) ...)

(CL:DEFMETHOD CLUSTERED-CONJUNCTION? ((SELF PROPOSITION))
  (CL:LET* ((FOUND?-000 FALSE))
   (CL:LET*
    ((CONJUNCT NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ CONJUNCT
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:WHEN (CL:EQ (%KIND CONJUNCT) KWD-QUERY-AND)
      (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
   (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000)))

;;; (DEFUN (CONTINUE-AND-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-AND-PROOF (FRAME LASTMOVE)
  (CL:LET* ((PROPOSITION (%PROPOSITION FRAME)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
     (CL:COND
      ((CLUSTERED-CONJUNCTION? PROPOSITION)
       (OVERLAY-WITH-STRATEGY-FRAME FRAME KWD-QUERY-CLUSTERED-CONJUNCTION)
       KWD-QUERY-MOVE-IN-PLACE)
      ((CL:AND (%REVERSE-POLARITY? FRAME)
        (CLOSED-PROPOSITION? PROPOSITION))
       (OVERLAY-WITH-FAIL-FRAME FRAME PROPOSITION))
      (CL:T KWD-QUERY-MOVE-DOWN)))
    ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:COND
      ((CL:EQ (%DOWN FRAME) NULL)
       (CL:SETF (%ARGUMENT-CURSOR FRAME) (CL:1+ (%ARGUMENT-CURSOR FRAME)))
       (CL:IF
        (CL:< (%ARGUMENT-CURSOR FRAME) (LENGTH (%ARGUMENTS PROPOSITION)))
        KWD-QUERY-MOVE-DOWN
        (CL:IF
         (CL:EQ
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME) SYM-QUERY-LOGIC-BACK
           NULL)
          NULL)
         KWD-QUERY-FINAL-SUCCESS
         (MOVE-BACKWARD-AND-UP-OR-DOWN FRAME
          KWD-QUERY-CONTINUING-SUCCESS))))
      ((CL:= (%ARGUMENT-CURSOR FRAME)
        (CL:1- (LENGTH (%ARGUMENTS PROPOSITION))))
       KWD-QUERY-CONTINUING-SUCCESS)
      (CL:T (MOVE-FORWARD-AND-DOWN FRAME))))
    ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
     (CL:IF
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME) SYM-QUERY-LOGIC-BACK
        NULL)
       NULL)
      KWD-QUERY-FAILURE
      (MOVE-BACKWARD-AND-UP-OR-DOWN FRAME KWD-QUERY-MOVE-DOWN)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (CONTINUE-OR-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-OR-PROOF (FRAME LASTMOVE)
  (CL:LET* ((PROPOSITION (%PROPOSITION FRAME)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
     (CL:WHEN
      (CL:AND (%REVERSE-POLARITY? FRAME)
       (CLOSED-PROPOSITION? PROPOSITION))
      (CL:RETURN-FROM CONTINUE-OR-PROOF
       (OVERLAY-WITH-FAIL-FRAME FRAME PROPOSITION)))
     (CREATE-CHOICE-POINT FRAME) KWD-QUERY-MOVE-DOWN)
    ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:WHEN (CL:EQ (%DOWN FRAME) NULL)
      (CL:SETF (%ARGUMENT-CURSOR FRAME) (CL:1+ (%ARGUMENT-CURSOR FRAME))))
     (CL:COND
      ((CL:OR
        (CL:>= (%ARGUMENT-CURSOR FRAME) (LENGTH (%ARGUMENTS PROPOSITION)))
        (CL:AND (CL:NOT (NEW-BINDINGS-SINCE-LAST-CHOICE-POINT? FRAME))
         (CL:NOT *GENERATE-ALL-PROOFS?*)))
       (CL:WHEN (CL:NOT (CL:EQ (%DOWN FRAME) NULL))
        (POP-FRAMES-UP-TO (%DOWN FRAME)))
       KWD-QUERY-FINAL-SUCCESS)
      (CL:T KWD-QUERY-CONTINUING-SUCCESS)))
    ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
     (CL:SETF (%ARGUMENT-CURSOR FRAME) (CL:1+ (%ARGUMENT-CURSOR FRAME)))
     (CL:IF
      (CL:< (%ARGUMENT-CURSOR FRAME) (LENGTH (%ARGUMENTS PROPOSITION)))
      (CL:PROGN (CREATE-CHOICE-POINT FRAME) KWD-QUERY-MOVE-DOWN)
      (CL:COND
       ((CL:EQ (%KEYWORD (CURRENT-INFERENCE-LEVEL)) KWD-QUERY-REFUTATION)
        (OVERLAY-WITH-STRATEGY-FRAME FRAME
         KWD-QUERY-DISJUNCTIVE-IMPLICATION-INTRODUCTION)
        KWD-QUERY-MOVE-IN-PLACE)
       (CL:T KWD-QUERY-FAILURE))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (CONTINUE-NOT-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-NOT-PROOF (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:WHEN (CL:NOT (CL:EQ (%DOWN FRAME) NULL))
     (CL:RETURN-FROM CONTINUE-NOT-PROOF KWD-QUERY-MOVE-DOWN))
    (CL:LET*
     ((ARGUMENT
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%THE-ARRAY (%ARGUMENTS (%PROPOSITION FRAME))))
        0)))
     (CL:WHEN
      (CL:AND (CL:NOT (%REVERSE-POLARITY? FRAME))
       (CLOSED-PROPOSITION? ARGUMENT))
      (CL:RETURN-FROM CONTINUE-NOT-PROOF
       (OVERLAY-WITH-FAIL-FRAME FRAME ARGUMENT)))
     (CREATE-DOWN-FRAME FRAME ARGUMENT)
     (CL:SETF (%REVERSE-POLARITY? (%DOWN FRAME))
      (CL:NOT (%REVERSE-POLARITY? FRAME)))
     KWD-QUERY-MOVE-DOWN))
   ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
    (CL:COND ((CL:EQ (%DOWN FRAME) NULL) KWD-QUERY-FINAL-SUCCESS)
     (TRUE KWD-QUERY-CONTINUING-SUCCESS)
     (*GENERATE-ALL-PROOFS?* KWD-QUERY-CONTINUING-SUCCESS)
     (CL:T (POP-FRAMES-UP-TO (%DOWN FRAME)) KWD-QUERY-FINAL-SUCCESS)))
   ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL) KWD-QUERY-FAILURE)
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (OVERLAY-WITH-FAIL-FRAME KEYWORD) ...)

(CL:DEFUN OVERLAY-WITH-FAIL-FRAME (FRAME PROPOSITION)
  (CL:LET* ((FAILPROPOSITION (CREATE-PROPOSITION SYM-QUERY-LOGIC-FAIL 1)))
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS FAILPROPOSITION))) (VALUE PROPOSITION)
     (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%PROPOSITION FRAME) FAILPROPOSITION)
   (CL:SETF (%STATE FRAME) KWD-QUERY-FAIL)
   (CL:SETF (%REVERSE-POLARITY? FRAME) FALSE) KWD-QUERY-MOVE-IN-PLACE))

;;; (DEFSPECIAL *REVERSEPOLARITY?* ...)

(CL:DEFVAR *REVERSEPOLARITY?* FALSE
  "Signals atomic proposition provers that polarity is negative.")

;;; (DEFUN (OVERLAY-WITH-STRATEGY-FRAME KEYWORD) ...)

(CL:DEFUN OVERLAY-WITH-STRATEGY-FRAME (FRAME STRATEGY)
  (CL:SETF (%NEXT-STRATEGIES FRAME) (CONS-LIST STRATEGY))
  (CL:SETF (%STATE FRAME) KWD-QUERY-STRATEGY)
  KWD-QUERY-MOVE-IN-PLACE)

;;; (DEFUN (CHECK-FOR-DUPLICATE-GOAL? BOOLEAN) ...)

(CL:DEFUN CHECK-FOR-DUPLICATE-GOAL? (FRAME)
  (CL:WHEN
   (CL:NOT
    (CL:OR (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
     (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY*
      KWD-QUERY-DUPLICATE-GOALS-WITH-CACHING)))
   (CL:RETURN-FROM CHECK-FOR-DUPLICATE-GOAL? FALSE))
  (CL:LET*
   ((OPERATOR (%OPERATOR (%PROPOSITION FRAME)))
    (GOALBINDINGS (%GOAL-BINDINGS FRAME)) (PREVIOUSFRAME (%UP FRAME))
    (DUPLICATEFRAME NULL))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 1)
     (UPPER-BOUND-000 *DUPLICATE-GOAL-SEARCH-DEPTH*)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000))
     DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:WHEN (CL:EQ PREVIOUSFRAME NULL) (CL:RETURN))
     (CL:LET* ((TEST-VALUE-000 FALSE))
      (CL:SETQ TEST-VALUE-000
       (CL:NOT (CL:EQ (%GOAL-BINDINGS PREVIOUSFRAME) NULL)))
      (CL:WHEN TEST-VALUE-000
       (CL:SETQ TEST-VALUE-000
        (CL:EQ OPERATOR (%OPERATOR (%PROPOSITION PREVIOUSFRAME))))
       (CL:WHEN TEST-VALUE-000
        (CL:LET* ((ALWAYS?-000 TRUE))
         (CL:LET*
          ((B2 NULL) (B1 NULL) (ITER-001 GOALBINDINGS)
           (ITER-002 (%GOAL-BINDINGS PREVIOUSFRAME)))
          (CL:LOOP WHILE
           (CL:AND (CL:NOT (CL:EQ ITER-001 NIL))
            (CL:NOT (CL:EQ ITER-002 NIL)))
           DO
           (CL:PROGN (CL:SETQ B1 (%%VALUE ITER-001))
            (CL:SETQ ITER-001 (%%REST ITER-001)))
           (CL:PROGN (CL:SETQ B2 (%%VALUE ITER-002))
            (CL:SETQ ITER-002 (%%REST ITER-002)))
           (CL:WHEN (CL:NOT (EQL? B1 B2)) (CL:SETQ ALWAYS?-000 FALSE)
            (CL:RETURN))))
         (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
        (CL:WHEN TEST-VALUE-000
         (CL:SETQ TEST-VALUE-000
          (CL:EQ (%REVERSE-POLARITY? FRAME)
           (%REVERSE-POLARITY? PREVIOUSFRAME))))))
      (CL:WHEN TEST-VALUE-000 (CL:SETQ DUPLICATEFRAME PREVIOUSFRAME)
       (CL:RETURN)))
     (CL:SETQ PREVIOUSFRAME (%UP PREVIOUSFRAME))))
   (CL:COND
    ((CL:NOT (CL:EQ DUPLICATEFRAME NULL))
     (TRACE-GOAL-CACHE "DUPLICATE GOAL:" FRAME)
     (CL:WHEN
      (CL:AND (CL:OR *CACHE-SUCCEEDED-GOALS?* *CACHE-FAILED-GOALS?*)
       (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
         (CL:NOT
          (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))))
      (DONT-CACHE-GOAL-FAILURE-BETWEEN-FRAMES FRAME
       (%DOWN DUPLICATEFRAME)))
     TRUE)
    (CL:T FALSE))))

;;; (DEFUN (INITIATE-ATOMIC-GOAL-PROOFS KEYWORD) ...)

(CL:DEFUN INITIATE-ATOMIC-GOAL-PROOFS (FRAME)
  (CL:LET* ((*REVERSEPOLARITY?* (%REVERSE-POLARITY? FRAME)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (CL:LET*
    ((PROPOSITION (%PROPOSITION FRAME))
     (INFERENCELEVEL (%KEYWORD (CURRENT-INFERENCE-LEVEL)))
     (STRATEGIES NULL))
    (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
     (CL:COND
      ((CL:OR (CL:EQ TEST-VALUE-000 KWD-QUERY-PREDICATE)
        (CL:EQ TEST-VALUE-000 KWD-QUERY-ISA)
        (CL:EQ TEST-VALUE-000 KWD-QUERY-FUNCTION))
       (CL:SETF (%GOAL-BINDINGS FRAME) (YIELD-GOAL-BINDINGS PROPOSITION))
       (CL:WHEN (CHECK-FOR-DUPLICATE-GOAL? FRAME)
        (CL:COND
         ((CL:EQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
          (CL:SETQ INFERENCELEVEL KWD-QUERY-SHALLOW))
         ((CL:EQ *DUPLICATE-SUBGOAL-STRATEGY*
           KWD-QUERY-DUPLICATE-GOALS-WITH-CACHING)
          (CL:SETF (%STATE FRAME) KWD-QUERY-SCAN-CACHED-BINDINGS)
          (CL:RETURN-FROM INITIATE-ATOMIC-GOAL-PROOFS
           KWD-QUERY-MOVE-IN-PLACE))
         (CL:T
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
            *DUPLICATE-SUBGOAL-STRATEGY* "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
       (CL:COND
        ((CL:OR (CL:EQ INFERENCELEVEL KWD-QUERY-NORMAL)
          (CL:EQ INFERENCELEVEL KWD-QUERY-BACKTRACKING))
         (CL:SETQ STRATEGIES
          (GET-QUOTED-TREE
           "((:SPECIALIST :LOOKUP-GOAL-CACHES :LOOKUP-ASSERTIONS :SHALLOW-DISPROOF :ALL-SUBGOAL-STRATEGIES) \"/LOGIC\")"
           "/LOGIC")))
        ((CL:EQ INFERENCELEVEL KWD-QUERY-REFUTATION)
         (CL:SETQ STRATEGIES
          (GET-QUOTED-TREE
           "((:SPECIALIST :LOOKUP-GOAL-CACHES :LOOKUP-ASSERTIONS :SHALLOW-DISPROOF :ALL-SUBGOAL-STRATEGIES :REFUTATION) \"/LOGIC\")"
           "/LOGIC")))
        (CL:T
         (CL:SETQ STRATEGIES
          (GET-QUOTED-TREE
           "((:SPECIALIST :LOOKUP-GOAL-CACHES :LOOKUP-ASSERTIONS :SHALLOW-DISPROOF) \"/LOGIC\")"
           "/LOGIC"))))
       (CL:WHEN
        (CL:AND (CL:EQ (%KIND PROPOSITION) KWD-QUERY-FUNCTION)
         (CL:NOT *REVERSEPOLARITY?*))
        (CL:SETQ STRATEGIES
         (CONCATENATE (COPY-CONS-LIST STRATEGIES)
          (CONS-LIST KWD-QUERY-MANUFACTURE-SKOLEM)))))
      ((CL:EQ TEST-VALUE-000 KWD-QUERY-EQUIVALENT)
       (CL:SETQ STRATEGIES
        (GET-QUOTED-TREE "((:EQUIVALENCE) \"/LOGIC\")" "/LOGIC")))
      ((CL:EQ TEST-VALUE-000 KWD-QUERY-IMPLIES)
       (CL:SETQ STRATEGIES
        (GET-QUOTED-TREE
         "((:SPECIALIST :ALL-SUBGOAL-STRATEGIES :IMPLIES) \"/LOGIC\")"
         "/LOGIC")))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" TEST-VALUE-000
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
    (CL:SETF (%NEXT-STRATEGIES FRAME) STRATEGIES)
    (CL:SETF (%STATE FRAME) KWD-QUERY-ATOMIC-GOAL)
    KWD-QUERY-MOVE-IN-PLACE)))

;;; (DEFUN (ALL-ARGUMENTS-BOUND? BOOLEAN) ...)

(CL:DEFUN ALL-ARGUMENTS-BOUND? (GOAL)
  (CL:LET* ((ALWAYS?-000 TRUE))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%ARGUMENTS GOAL)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:WHEN (CL:NOT (ARGUMENT-BOUND? ARG)) (CL:SETQ ALWAYS?-000 FALSE)
      (CL:RETURN))))
   (CL:LET* ((VALUE-000 ALWAYS?-000)) VALUE-000)))

;;; (DEFUN (ALL-KEY-ARGUMENTS-BOUND? BOOLEAN) ...)

(CL:DEFUN ALL-KEY-ARGUMENTS-BOUND? (GOAL)
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:SETQ TEST-VALUE-000
    (CL:OR (CL:EQ (%KIND GOAL) KWD-QUERY-FUNCTION)
     (SINGLE-VALUED-PREDICATE? GOAL)))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((ALWAYS?-000 TRUE))
     (CL:LET*
      ((I NULL-INTEGER) (ITER-000 0)
       (UPPER-BOUND-000 (CL:- (LENGTH (%ARGUMENTS GOAL)) 2)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
      (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
       (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
       (CL:WHEN
        (CL:NOT
         (ARGUMENT-BOUND?
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS GOAL))) I)))
        (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
     (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (CREATE-PATTERN-RECORD PATTERN-RECORD) ...)

(CL:DEFUN CREATE-PATTERN-RECORD (FRAME DESCRIPTION EXTERNALARGUMENTS)
  (CL:LET* ((PATTERNRECORD (NEW-PATTERN-RECORD)))
   (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:SETF (%DESCRIPTION PATTERNRECORD) DESCRIPTION)
    (CL:IF (CL:NOT (CL:EQ EXTERNALARGUMENTS NULL))
     (CL:LET*
      ((EXTERNALARGUMENTSCOPY
        (COPY-PATTERN-ARGUMENTS EXTERNALARGUMENTS DESCRIPTION)))
      (CL:SETF (%EXTERNAL-ARGUMENTS PATTERNRECORD) EXTERNALARGUMENTSCOPY)
      (CL:SETF (%BOOLEAN-VECTOR PATTERNRECORD)
       (ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR EXTERNALARGUMENTSCOPY)))
     (CL:LET* ((ONESLIST (NEW-LIST)))
      (CL:LET*
       ((V (ALLOCATE-ITERATOR (%IO-VARIABLES DESCRIPTION)))
        (COLLECT-000 NULL))
       (CL:LOOP WHILE (NEXT? V) DO
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS ZERO-WRAPPER NIL))
          (CL:IF (CL:EQ (%THE-CONS-LIST ONESLIST) NIL)
           (CL:SETF (%THE-CONS-LIST ONESLIST) COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST ONESLIST)
            COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ZERO-WRAPPER NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
      (CL:SETF (%BOOLEAN-VECTOR PATTERNRECORD)
       (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR ONESLIST))
      (FREE ONESLIST))))
   (CL:SETF (%COLLECTION-LIST PATTERNRECORD) NULL)
   (CL:SETF (%PATTERN-RECORD FRAME) PATTERNRECORD)
   (CL:SETF (%CONTROL-FRAME PATTERNRECORD) FRAME) PATTERNRECORD))

;;; (DEFUN (TERMINATE-PATTERN-RECORD? BOOLEAN) ...)

(CL:DEFUN TERMINATE-PATTERN-RECORD? (SELF)
  (CL:WHEN (CL:NOT (CL:EQ (%EXTERNAL-ARGUMENTS SELF) NULL))
   (FREE (%EXTERNAL-ARGUMENTS SELF)))
  (CL:SETF (%OPTIMAL-PATTERN SELF) NULL)
  TRUE)

;;; (DEFUN (COPY-PATTERN-ARGUMENTS ARGUMENTS-VECTOR) ...)

(CL:DEFUN COPY-PATTERN-ARGUMENTS (ARGUMENTS DESCRIPTION)
  (CL:WHEN (CL:EQ ARGUMENTS NULL)
   (CL:RETURN-FROM COPY-PATTERN-ARGUMENTS NULL))
  (CL:LET*
   ((ARGUMENTCOUNT (ARITY DESCRIPTION))
    (COPIEDARGUMENTS (NEW-VECTOR ARGUMENTCOUNT)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARGUMENTCOUNT))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- ARGUMENTCOUNT)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:LET
      ((SELF (%THE-ARRAY COPIEDARGUMENTS))
       (VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) I))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   COPIEDARGUMENTS))

;;; (DEFUN (COMPUTE-EXTERNAL-BINDINGS CONS) ...)

(CL:DEFUN COMPUTE-EXTERNAL-BINDINGS (EXTERNALARGUMENTS)
  (CL:LET* ((EXTERNALBINDINGS NIL))
   (CL:WHEN (CL:EQ EXTERNALARGUMENTS NULL)
    (CL:RETURN-FROM COMPUTE-EXTERNAL-BINDINGS NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 EXTERNALARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (ARGUMENT-BOUND-TO ARG) NIL))
       (CL:IF (CL:EQ EXTERNALBINDINGS NIL)
        (CL:SETQ EXTERNALBINDINGS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST EXTERNALBINDINGS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000) (CONS (ARGUMENT-BOUND-TO ARG) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   EXTERNALBINDINGS))

;;; (DEFUN (CHECK-FOR-SINGLE-VALUED-GOAL? BOOLEAN) ...)

(CL:DEFUN CHECK-FOR-SINGLE-VALUED-GOAL? (PATTERN IOBINDINGS)
  (CL:LET* ((IOVARIABLES NIL) (BOUNDVARIABLES NIL))
   (CL:LET*
    ((VBL NULL) (VECTOR-000 (%IO-VARIABLES PATTERN)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ VBL
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS VBL NIL))
       (CL:IF (CL:EQ IOVARIABLES NIL) (CL:SETQ IOVARIABLES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST IOVARIABLES COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VBL NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:LET*
    ((V2 NULL) (V1 NULL) (ITER-000 IOVARIABLES) (ITER-001 IOBINDINGS))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:NOT (CL:EQ ITER-001 NIL)))
     DO
     (CL:PROGN (CL:SETQ V1 (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ V2 (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:WHEN (CL:NOT (CL:EQ V2 NULL))
      (CL:SETQ BOUNDVARIABLES (CONS V1 BOUNDVARIABLES)))))
   (SINGLE-VALUED-GOAL? (%PROPOSITION PATTERN) IOVARIABLES BOUNDVARIABLES)))

;;; (DEFUN (OVERLAY-WITH-PATTERN-FRAME? BOOLEAN) ...)

(CL:DEFUN OVERLAY-WITH-PATTERN-FRAME? (FRAME DESCRIPTION IOARGUMENTS)
  (CL:LET*
   ((IOBINDINGS (COMPUTE-EXTERNAL-BINDINGS IOARGUMENTS))
    (EXTERNALBINDINGS
     (CL:IF
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS DESCRIPTION)
         SYM-QUERY-LOGIC-EXTERNAL-VARIABLES NULL)
        NULL))
      (COMPUTE-EXTERNAL-BINDINGS
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS DESCRIPTION)
        SYM-QUERY-LOGIC-EXTERNAL-VARIABLES NULL))
      NIL))
    (PATTERNRECORD (CREATE-PATTERN-RECORD FRAME DESCRIPTION IOARGUMENTS))
    (OPTIMALPATTERN NULL))
   (CL:WHEN (CL:EQ IOARGUMENTS NULL)
    (CL:LET*
     ((V (ALLOCATE-ITERATOR (%IO-VARIABLES DESCRIPTION)))
      (COLLECT-000 NULL))
     (CL:LOOP WHILE (NEXT? V) DO
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS NULL NIL))
        (CL:IF (CL:EQ IOBINDINGS NIL) (CL:SETQ IOBINDINGS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST IOBINDINGS COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS NULL NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:SETF (%STATE FRAME) KWD-QUERY-PATTERN)
   (CL:SETQ OPTIMALPATTERN
    (SELECT-OPTIMAL-QUERY-PATTERN DESCRIPTION
     (%BOOLEAN-VECTOR PATTERNRECORD) FRAME))
   (CL:SETF (%OPTIMAL-PATTERN PATTERNRECORD) OPTIMALPATTERN)
   (CL:SETF (%CACHED-SINGLE-VALUED? FRAME)
    (CHECK-FOR-SINGLE-VALUED-GOAL? OPTIMALPATTERN IOBINDINGS))
   (CL:SETF (%PROPOSITION FRAME) (%PROPOSITION OPTIMALPATTERN))
   (CL:LET*
    ((VARIABLESCOUNT
      (CL:+ (LENGTH IOBINDINGS)
       (LENGTH (%INTERNAL-VARIABLES OPTIMALPATTERN))
       (LENGTH EXTERNALBINDINGS))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM VARIABLESCOUNT))
    (ACTIVATE-PATTERN-RECORD PATTERNRECORD VARIABLESCOUNT))
   (CL:LET*
    ((BINDING NULL) (IOVAR NULL)
     (VECTOR-000 (%IO-VARIABLES OPTIMALPATTERN)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (ITER-000 IOBINDINGS))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:NOT (CL:EQ ITER-000 NIL))) DO
     (CL:PROGN
      (CL:SETQ IOVAR
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:PROGN (CL:SETQ BINDING (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ BINDING NULL))
       (CL:NOT (BIND-VARIABLE-TO-VALUE? IOVAR BINDING FALSE)))
      (CL:RETURN-FROM OVERLAY-WITH-PATTERN-FRAME? FALSE))))
   (CL:WHEN (CL:NOT (CL:EQ EXTERNALBINDINGS NIL))
    (CL:LET*
     ((BINDING NULL) (EXTERNALVAR NULL)
      (VECTOR-001
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OPTIMALPATTERN)
        SYM-QUERY-LOGIC-EXTERNAL-VARIABLES NULL))
      (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001))
      (ITER-001 EXTERNALBINDINGS))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:NOT (CL:EQ ITER-001 NIL)))
      DO
      (CL:PROGN
       (CL:SETQ EXTERNALVAR
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (CL:PROGN (CL:SETQ BINDING (%%VALUE ITER-001))
       (CL:SETQ ITER-001 (%%REST ITER-001)))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ BINDING NULL))
        (CL:NOT (BIND-VARIABLE-TO-VALUE? EXTERNALVAR BINDING FALSE)))
       (CL:RETURN-FROM OVERLAY-WITH-PATTERN-FRAME? FALSE)))))
   (CL:WHEN (CL:EQ (%DOWN FRAME) NULL)
    (CREATE-DOWN-FRAME FRAME (%PROPOSITION OPTIMALPATTERN)))
   (ELABORATE-SURROGATES-IN-PROPOSITION (%PROPOSITION OPTIMALPATTERN))
   TRUE))

;;; (DEFUN (TRANSFER-PATTERN-QUERY-BINDINGS? BOOLEAN) ...)

(CL:DEFUN TRANSFER-PATTERN-QUERY-BINDINGS? (FRAME FUTUREBINDINGS?)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "TRANSFER-pattern-query-bindings?: " EOL))
  (CL:LET*
   ((CHILDPATTERNRECORD (%PATTERN-RECORD FRAME))
    (BOOLEANVECTOR (%BOOLEAN-VECTOR CHILDPATTERNRECORD))
    (EXTERNALARGUMENTS (%EXTERNAL-ARGUMENTS CHILDPATTERNRECORD))
    (IOVARIABLES (%IO-VARIABLES (%OPTIMAL-PATTERN CHILDPATTERNRECORD)))
    (LASTINDEX (CL:1- (LENGTH BOOLEANVECTOR))) (IOVARIABLEVALUES NIL)
    (TOPUNBINDINGOFFSET NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LASTINDEX TOPUNBINDINGOFFSET))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 LASTINDEX)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000))
     DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CL:IF
          (CL:NOT
           (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY BOOLEANVECTOR))
             I)))
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%THE-ARRAY
             (%VARIABLE-BINDINGS
              (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
           (CL:THE CL:FIXNUM
            (%BOUND-TO-OFFSET
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY IOVARIABLES))
              I))))
          NULL)
         NIL))
       (CL:IF (CL:EQ IOVARIABLEVALUES NIL)
        (CL:SETQ IOVARIABLEVALUES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST IOVARIABLEVALUES COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CL:IF
          (CL:NOT
           (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY BOOLEANVECTOR))
             I)))
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%THE-ARRAY
             (%VARIABLE-BINDINGS
              (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
           (CL:THE CL:FIXNUM
            (%BOUND-TO-OFFSET
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY IOVARIABLES))
              I))))
          NULL)
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (RESET-CURRENT-PATTERN-RECORD FRAME KWD-QUERY-PARENT)
   (CL:LET*
    ((PARENTPATTERNRECORD (%CURRENT-PATTERN-RECORD *QUERYITERATOR*)))
    (CL:SETQ TOPUNBINDINGOFFSET
     (%TOP-UNBINDING-STACK-OFFSET PARENTPATTERNRECORD))
    (CL:LET*
     ((INITIALLYBOUND? NULL) (EXTERNALARG NULL) (VALUE NULL)
      (ITER-001 IOVARIABLEVALUES) (VECTOR-000 EXTERNALARGUMENTS)
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
      (VECTOR-001 BOOLEANVECTOR) (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:< INDEX-000 LENGTH-000)
       (CL:< INDEX-001 LENGTH-001))
      DO
      (CL:PROGN (CL:SETQ VALUE (%%VALUE ITER-001))
       (CL:SETQ ITER-001 (%%REST ITER-001)))
      (CL:PROGN
       (CL:SETQ EXTERNALARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
      (CL:PROGN
       (CL:SETQ INITIALLYBOUND?
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (CL:WHEN
       (CL:NOT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN INITIALLYBOUND?))
       (CL:WHEN (CL:NOT (BIND-ARGUMENT-TO-VALUE? EXTERNALARG VALUE FALSE))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
          (MEMB? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS))
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
          "TRANSFER FAILS! " EOL))
        (UNBIND-VARIABLES-BEGINNING-AT PARENTPATTERNRECORD
         (CL:1+ TOPUNBINDINGOFFSET))
        (CL:WHEN FUTUREBINDINGS?
         (RESET-CURRENT-PATTERN-RECORD FRAME KWD-QUERY-LOCAL))
        (CL:RETURN-FROM TRANSFER-PATTERN-QUERY-BINDINGS? FALSE))))))
   TRUE))

;;; (DEFUN COLLECT-PATTERN-QUERY-BINDINGS ...)

(CL:DEFUN COLLECT-PATTERN-QUERY-BINDINGS (FRAME)
  (CL:LET*
   ((PATTERNRECORD (%PATTERN-RECORD FRAME))
    (IOVARIABLES (%IO-VARIABLES (%OPTIMAL-PATTERN PATTERNRECORD)))
    (IOVARIABLEVALUES NIL))
   (CL:LET*
    ((V NULL) (VECTOR-000 IOVARIABLES) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ V
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY
            (%VARIABLE-BINDINGS
             (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
          (CL:THE CL:FIXNUM (%BOUND-TO-OFFSET V)))
         NIL))
       (CL:IF (CL:EQ IOVARIABLEVALUES NIL)
        (CL:SETQ IOVARIABLEVALUES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST IOVARIABLEVALUES COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY
            (%VARIABLE-BINDINGS
             (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
          (CL:THE CL:FIXNUM (%BOUND-TO-OFFSET V)))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:CASE (LENGTH IOVARIABLEVALUES)
    (1
     (CL:WHEN (CL:EQ (%%VALUE IOVARIABLEVALUES) NULL)
      (CL:WARN "Pushing NULL binding onto collection.  Variable= `~A'"
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY IOVARIABLES)) 0))
      (CL:RETURN-FROM COLLECT-PATTERN-QUERY-BINDINGS))
     (PUSH (%COLLECTION-LIST PATTERNRECORD) (%%VALUE IOVARIABLEVALUES)))
    (CL:OTHERWISE
     (PUSH (%COLLECTION-LIST PATTERNRECORD) IOVARIABLEVALUES)))))

;;; (DEFUN (CONTINUE-PATTERN-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-PATTERN-PROOF (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (RESET-CURRENT-PATTERN-RECORD FRAME KWD-QUERY-LOCAL)
    KWD-QUERY-MOVE-DOWN)
   ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
    (CL:LET* ((FUTUREBINDINGS? (CL:NOT (CL:EQ (%DOWN FRAME) NULL))))
     (CL:COND
      ((CL:NOT (CL:EQ (%COLLECTION-LIST (%PATTERN-RECORD FRAME)) NULL))
       (COLLECT-PATTERN-QUERY-BINDINGS FRAME)
       (CL:IF FUTUREBINDINGS? KWD-QUERY-MOVE-DOWN
        (CL:PROGN (RESET-CURRENT-PATTERN-RECORD FRAME KWD-QUERY-PARENT)
         KWD-QUERY-CONTINUING-SUCCESS)))
      ((TRANSFER-PATTERN-QUERY-BINDINGS? FRAME FUTUREBINDINGS?)
       (CL:IF FUTUREBINDINGS?
        (CL:PROGN
         (CL:WHEN
          (CL:AND (%CACHED-SINGLE-VALUED? FRAME)
           (CL:NOT *GENERATE-ALL-PROOFS?*))
          (POP-FRAMES-UP-TO (%DOWN FRAME))
          (CL:RETURN-FROM CONTINUE-PATTERN-PROOF KWD-QUERY-FINAL-SUCCESS))
         KWD-QUERY-CONTINUING-SUCCESS)
        KWD-QUERY-FINAL-SUCCESS))
      (FUTUREBINDINGS? KWD-QUERY-MOVE-DOWN) (CL:T KWD-QUERY-FAILURE))))
   ((CL:OR (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
     (CL:EQ LASTMOVE KWD-QUERY-FAILED-OVERLAY))
    (CL:IF
     (CL:NOT (CL:EQ (%COLLECTION-LIST (%PATTERN-RECORD FRAME)) NULL))
     (CL:PROGN (RESET-CURRENT-PATTERN-RECORD FRAME KWD-QUERY-PARENT)
      KWD-QUERY-CONTINUING-SUCCESS)
     KWD-QUERY-FAILURE))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (DISJOINT-CLASSES? BOOLEAN) ...)

(CL:DEFUN DISJOINT-CLASSES? (DESC1 DESC2)
  (CL:AND (CL:NOT (CL:EQ DESC1 DESC2))
   (CL:NOT (RELATION-IMPLIES-RELATION? DESC1 DESC2))
   (CL:NOT (RELATION-IMPLIES-RELATION? DESC2 DESC1))))

;;; (DEFUN (DISJOINT-TERMS? BOOLEAN) ...)

(CL:DEFUN DISJOINT-TERMS? (D1 D2)
  (APPLY-CACHED-ASK (LIST* SYM-QUERY-LOGIC-?D1 SYM-QUERY-LOGIC-?D2 NIL)
   (LIST* SYM-QUERY-LOGIC-DISJOINT SYM-QUERY-LOGIC-?D1 SYM-QUERY-LOGIC-?D2
    NIL)
   (CONS-LIST D1 D2) (CONS-LIST) SYM-QUERY-LOGIC-QUERY-060))

;;; (DEFUN (EXPENSIVE-DISJOINT-TERMS? BOOLEAN) ...)

(CL:DEFUN EXPENSIVE-DISJOINT-TERMS? (D1 D2)
  (APPLY-CACHED-ASK (LIST* SYM-QUERY-LOGIC-?D1 SYM-QUERY-LOGIC-?D2 NIL)
   (LIST* SYM-QUERY-STELLA-OR
    (LIST* SYM-QUERY-LOGIC-DISJOINT SYM-QUERY-LOGIC-?D1
     SYM-QUERY-LOGIC-?D2 NIL)
    (LIST* SYM-QUERY-STELLA-AND
     (LIST* SYM-QUERY-PL-KERNEL-KB-CLASS SYM-QUERY-LOGIC-?D1 NIL)
     (LIST* SYM-QUERY-PL-KERNEL-KB-CLASS SYM-QUERY-LOGIC-?D2 NIL)
     (LIST* SYM-QUERY-LOGIC-REFUTATION-DISJOINT SYM-QUERY-LOGIC-?D1
      SYM-QUERY-LOGIC-?D2 NIL)
     NIL)
    NIL)
   (CONS-LIST D1 D2) (CONS-LIST) SYM-QUERY-LOGIC-QUERY-061))

;;; (DEFUN (COLLECTIONOF-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN COLLECTIONOF-PROPOSITION? (DEFININGPROPOSITION)
  (LOGICAL-SUBTYPE-OF? (%OPERATOR DEFININGPROPOSITION)
   SGT-QUERY-PL-KERNEL-KB-COLLECTIONOF))

;;; (DEFUN (MEMBER-OF-COLLECTION? BOOLEAN) ...)

(CL:DEFUN MEMBER-OF-COLLECTION? (MEMBER COLLECTION)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE COLLECTION)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:LET* ((FOUND?-000 FALSE))
       (CL:LET*
        ((P NULL)
         (ITER-000
          (ALL-TRUE-DEPENDENT-PROPOSITIONS MEMBER
           (%SURROGATE-VALUE-INVERSE COLLECTION) TRUE)))
        (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
         (CL:SETQ FOUND?-000 TRUE) (CL:RETURN)))
       (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-COLLECTION)
     (CL:PROGN
      (CL:LET* ((FOUND?-001 FALSE))
       (CL:LET* ((M NULL) (ITER-001 (ALLOCATE-ITERATOR COLLECTION)))
        (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ M (%VALUE ITER-001))
         (CL:WHEN (EQL? (VALUE-OF M) MEMBER) (CL:SETQ FOUND?-001 TRUE)
          (CL:RETURN))))
       (CL:LET* ((MEMBER? FOUND?-001))
        (CL:IF *REVERSEPOLARITY?* (CL:NOT MEMBER?) MEMBER?)))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET* ((DEFININGPROPOSITION (%DEFINING-PROPOSITION COLLECTION)))
       (CL:IF
        (CL:AND (CL:NOT (CL:EQ DEFININGPROPOSITION NULL))
         (COLLECTIONOF-PROPOSITION? DEFININGPROPOSITION))
        (CL:LET* ((SUCCESS? FALSE))
         (CL:LET*
          ((ARG NULL) (VECTOR-000 (%ARGUMENTS DEFININGPROPOSITION))
           (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
          (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
           (CL:PROGN
            (CL:SETQ ARG
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
              INDEX-000))
            (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
           (CL:WHEN
            (CL:AND (EQL? (VALUE-OF ARG) MEMBER)
             (CL:NOT (CL:EQ MEMBER COLLECTION)))
            (CL:SETQ SUCCESS? TRUE) (CL:RETURN))))
         (CL:IF *REVERSEPOLARITY?*
          (CL:RETURN-FROM MEMBER-OF-COLLECTION? (CL:NOT SUCCESS?))
          (CL:RETURN-FROM MEMBER-OF-COLLECTION? SUCCESS?)))
        (CL:LET*
         ((P NULL)
          (ITER-002
           (ALL-TRUE-DEPENDENT-PROPOSITIONS MEMBER
            SGT-QUERY-PL-KERNEL-KB-MEMBER-OF FALSE)))
         (CL:LOOP WHILE (NEXT? ITER-002) DO (CL:SETQ P (%VALUE ITER-002))
          (CL:LET*
           ((SUBCOLLECTION
             (VALUE-OF
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P))) 1))))
           (CL:WHEN
            (CL:IF *REVERSEPOLARITY?*
             (COLLECTION-IMPLIES-COLLECTION? COLLECTION SUBCOLLECTION)
             (COLLECTION-IMPLIES-COLLECTION? SUBCOLLECTION COLLECTION))
            (CL:RETURN-FROM MEMBER-OF-COLLECTION? TRUE))))))
       FALSE)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:WARN
       "Bug: PowerLoom doesn't know how to handle a LOGIC-OBJECT that ~%   denotes a collection.  Please complain to your PowerLoom dealer.~%")
      FALSE))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (ASSERTED-COLLECTION-MEMBERS LIST) ...)

(CL:DEFUN ASSERTED-COLLECTION-MEMBERS (SELF DIRECT?)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-COLLECTION)
     (CL:PROGN
      (CL:LET* ((MEMBERS (NEW-LIST)))
       (CL:LET*
        ((M NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)) (COLLECT-000 NULL))
        (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ M (%VALUE ITER-000))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN (CL:SETQ COLLECT-000 (CONS M NIL))
           (CL:IF (CL:EQ (%THE-CONS-LIST MEMBERS) NIL)
            (CL:SETF (%THE-CONS-LIST MEMBERS) COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST MEMBERS)
             COLLECT-000)))
          (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS M NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
       MEMBERS)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:LET* ((MEMBERS (LIST)))
       (CL:WHEN (CL:NOT (CL:EQ (%EXTENSION SELF) NULL))
        (CLEANUP-DESCRIPTION-EXTENSION SELF)
        (CL:LET*
         ((P NULL) (ITER-001 (ALLOCATE-ITERATOR (%EXTENSION SELF)))
          (COLLECT-001 NULL))
         (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ P (%VALUE ITER-001))
          (CL:WHEN (TRUE? P)
           (CL:IF (CL:EQ COLLECT-001 NULL)
            (CL:PROGN
             (CL:SETQ COLLECT-001
              (CONS
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P))) 0)
               NIL))
             (CL:IF (CL:EQ (%THE-CONS-LIST MEMBERS) NIL)
              (CL:SETF (%THE-CONS-LIST MEMBERS) COLLECT-001)
              (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST MEMBERS)
               COLLECT-001)))
            (CL:PROGN
             (CL:SETF (%%REST COLLECT-001)
              (CONS
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P))) 0)
               NIL))
             (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))))))
       (CL:WHEN DIRECT?
        (CL:RETURN-FROM ASSERTED-COLLECTION-MEMBERS MEMBERS))
       (CL:LET* ((D NULL) (ITER-002 (ALL-SUBRELATIONS SELF TRUE)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
         (CL:PROGN (CL:SETQ D (%%VALUE ITER-002))
          (CL:SETQ ITER-002 (%%REST ITER-002)))
         (CL:WHEN (CL:NOT (CL:EQ (%EXTENSION D) NULL))
          (CLEANUP-DESCRIPTION-EXTENSION D)
          (CL:LET*
           ((P NULL) (ITER-003 (ALLOCATE-ITERATOR (%EXTENSION D)))
            (COLLECT-002 NULL))
           (CL:LOOP WHILE (NEXT? ITER-003) DO
            (CL:SETQ P (%VALUE ITER-003))
            (CL:WHEN (TRUE? P)
             (CL:IF (CL:EQ COLLECT-002 NULL)
              (CL:PROGN
               (CL:SETQ COLLECT-002
                (CONS
                 (CL:AREF
                  (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P))) 0)
                 NIL))
               (CL:IF (CL:EQ (%THE-CONS-LIST MEMBERS) NIL)
                (CL:SETF (%THE-CONS-LIST MEMBERS) COLLECT-002)
                (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST MEMBERS)
                 COLLECT-002)))
              (CL:PROGN
               (CL:SETF (%%REST COLLECT-002)
                (CONS
                 (CL:AREF
                  (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P))) 0)
                 NIL))
               (CL:SETQ COLLECT-002 (%%REST COLLECT-002))))))))))
       (REMOVE-DUPLICATES MEMBERS) MEMBERS)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-DESCRIPTION)
     (CL:PROGN NULL))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET*
       ((MEMBERS (NEW-LIST))
        (ENUMERATEDCOLLECTIONS
         (ALL-DEFINING-PROPOSITIONS SELF
          SGT-QUERY-PL-KERNEL-KB-COLLECTIONOF TRUE)))
       (CL:IF (CL:NOT (CL:EQ ENUMERATEDCOLLECTIONS NIL))
        (CL:LET* ((COL NULL) (ITER-004 ENUMERATEDCOLLECTIONS))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
          (CL:PROGN (CL:SETQ COL (%%VALUE ITER-004))
           (CL:SETQ ITER-004 (%%REST ITER-004)))
          (CL:LET*
           ((I NULL-INTEGER) (ARG NULL) (VECTOR-000 (%ARGUMENTS COL))
            (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (ITER-005 2)
            (UPPER-BOUND-000 (LENGTH (%ARGUMENTS COL)))
            (COLLECT-003 NULL))
           (CL:DECLARE
            (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-005
             UPPER-BOUND-000 I))
           (CL:LOOP WHILE
            (CL:AND (CL:< INDEX-000 LENGTH-000)
             (CL:<= ITER-005 UPPER-BOUND-000))
            DO
            (CL:PROGN
             (CL:SETQ ARG
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
               INDEX-000))
             (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
            (CL:PROGN (CL:SETQ I ITER-005)
             (CL:SETQ ITER-005 (CL:1+ ITER-005)))
            (CL:IF (CL:EQ COLLECT-003 NULL)
             (CL:PROGN (CL:SETQ COLLECT-003 (CONS (VALUE-OF ARG) NIL))
              (CL:IF (CL:EQ (%THE-CONS-LIST MEMBERS) NIL)
               (CL:SETF (%THE-CONS-LIST MEMBERS) COLLECT-003)
               (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST MEMBERS)
                COLLECT-003)))
             (CL:PROGN
              (CL:SETF (%%REST COLLECT-003) (CONS (VALUE-OF ARG) NIL))
              (CL:SETQ COLLECT-003 (%%REST COLLECT-003))))))))
        (CL:LET*
         ((P NULL)
          (ITER-006
           (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF
            SGT-QUERY-PL-KERNEL-KB-MEMBER-OF FALSE))
          (COLLECT-004 NULL))
         (CL:LOOP WHILE (NEXT? ITER-006) DO (CL:SETQ P (%VALUE ITER-006))
          (CL:WHEN
           (CL:EQ
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
             1)
            SELF)
           (CL:IF (CL:EQ COLLECT-004 NULL)
            (CL:PROGN
             (CL:SETQ COLLECT-004
              (CONS
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P))) 0)
               NIL))
             (CL:IF (CL:EQ (%THE-CONS-LIST MEMBERS) NIL)
              (CL:SETF (%THE-CONS-LIST MEMBERS) COLLECT-004)
              (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST MEMBERS)
               COLLECT-004)))
            (CL:PROGN
             (CL:SETF (%%REST COLLECT-004)
              (CONS
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P))) 0)
               NIL))
             (CL:SETQ COLLECT-004 (%%REST COLLECT-004))))))))
       MEMBERS)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:LET*
       ((EQUIVALENTSKOLEM (%%VALUE (VARIABLE-VALUE-INVERSE SELF))))
       (CL:WHEN (CL:NOT (CL:EQ EQUIVALENTSKOLEM NULL))
        (CL:RETURN-FROM ASSERTED-COLLECTION-MEMBERS
         (ASSERTED-COLLECTION-MEMBERS EQUIVALENTSKOLEM DIRECT?))))
      (CL:WARN
       "Hmm. PowerLoom doesn't know how to interpret the LOGIC-OBJECT: `~A'~%   as a collection.~%"
       SELF)
      NIL-LIST))
    (CL:T NULL))))

;;; (DEFCLASS DESCRIPTION-EXTENSION-ITERATOR ...)

(CL:DEFCLASS DESCRIPTION-EXTENSION-ITERATOR (ITERATOR)
  ((EXTENSION-ITERATOR :ALLOCATION :INSTANCE :ACCESSOR
    %EXTENSION-ITERATOR)
   (REFERENCE-PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR
    %REFERENCE-PROPOSITION)
   (SUBCOLLECTION :ALLOCATION :INSTANCE :ACCESSOR %SUBCOLLECTION)
   (SUBCOLLECTION-ITERATOR :ALLOCATION :INSTANCE :ACCESSOR
    %SUBCOLLECTION-ITERATOR)
   (ALREADY-GENERATED-LIST :ALLOCATION :INSTANCE :ACCESSOR
    %ALREADY-GENERATED-LIST)
   (ALREADY-GENERATED-TABLE :ALLOCATION :INSTANCE :ACCESSOR
    %ALREADY-GENERATED-TABLE)
   (REMOVING-DUPLICATES? :ALLOCATION :INSTANCE :ACCESSOR
    %REMOVING-DUPLICATES?)
   (ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? :ALLOCATION :INSTANCE
    :ACCESSOR %ITERATOR-INITIALIZATION-TOUCHED-DEFAULT?)
   (ITERATOR-VALUE-HOLDS-BY-DEFAULT? :ALLOCATION :INSTANCE :ACCESSOR
    %ITERATOR-VALUE-HOLDS-BY-DEFAULT?))
  (:DOCUMENTATION "Iterates over the extension of a description and
its subdescriptions, returning those propositions that are currently true."))

(CL:DEFUN NEW-DESCRIPTION-EXTENSION-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE DESCRIPTION-EXTENSION-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) TRUE) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%ITERATOR-VALUE-HOLDS-BY-DEFAULT? SELF) FALSE)
   (CL:SETF (%ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? SELF) FALSE)
   (CL:SETF (%REMOVING-DUPLICATES? SELF) FALSE)
   (CL:SETF (%ALREADY-GENERATED-TABLE SELF) NULL)
   (CL:SETF (%ALREADY-GENERATED-LIST SELF) (NEW-LIST))
   (CL:SETF (%SUBCOLLECTION-ITERATOR SELF) NULL)
   (CL:SETF (%SUBCOLLECTION SELF) NULL)
   (CL:SETF (%REFERENCE-PROPOSITION SELF) NULL)
   (CL:SETF (%EXTENSION-ITERATOR SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DESCRIPTION-EXTENSION-ITERATOR))
  SGT-QUERY-LOGIC-DESCRIPTION-EXTENSION-ITERATOR)

(CL:DEFUN ACCESS-DESCRIPTION-EXTENSION-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-EXTENSION-ITERATOR)
    (CL:IF SETVALUE? (CL:SETF (%EXTENSION-ITERATOR SELF) VALUE)
     (CL:SETQ VALUE (%EXTENSION-ITERATOR SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-REFERENCE-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%REFERENCE-PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%REFERENCE-PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-SUBCOLLECTION)
    (CL:IF SETVALUE? (CL:SETF (%SUBCOLLECTION SELF) VALUE)
     (CL:SETQ VALUE (%SUBCOLLECTION SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-SUBCOLLECTION-ITERATOR)
    (CL:IF SETVALUE? (CL:SETF (%SUBCOLLECTION-ITERATOR SELF) VALUE)
     (CL:SETQ VALUE (%SUBCOLLECTION-ITERATOR SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ALREADY-GENERATED-LIST)
    (CL:IF SETVALUE? (CL:SETF (%ALREADY-GENERATED-LIST SELF) VALUE)
     (CL:SETQ VALUE (%ALREADY-GENERATED-LIST SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ALREADY-GENERATED-TABLE)
    (CL:IF SETVALUE? (CL:SETF (%ALREADY-GENERATED-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%ALREADY-GENERATED-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-REMOVING-DUPLICATES?)
    (CL:IF SETVALUE?
     (CL:SETF (%REMOVING-DUPLICATES? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%REMOVING-DUPLICATES? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME
     SYM-QUERY-LOGIC-ITERATOR-INITIALIZATION-TOUCHED-DEFAULT?)
    (CL:IF SETVALUE?
     (CL:SETF (%ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOGIC-ITERATOR-VALUE-HOLDS-BY-DEFAULT?)
    (CL:IF SETVALUE?
     (CL:SETF (%ITERATOR-VALUE-HOLDS-BY-DEFAULT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%ITERATOR-VALUE-HOLDS-BY-DEFAULT? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (ALL-TRUE-EXTENSION-MEMBERS DESCRIPTION-EXTENSION-ITERATOR) ...)

(CL:DEFUN ALL-TRUE-EXTENSION-MEMBERS (SELF SPECIALIZE?)
  (CL:LET*
   ((ITERATOR (NEW-DESCRIPTION-EXTENSION-ITERATOR))
    (DETERMINEDEFAULTTRUTH?
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)))
    (LATESTTOUCHEDDEFAULT? FALSE))
   (CL:WHEN DETERMINEDEFAULTTRUTH?
    (CL:SETQ LATESTTOUCHEDDEFAULT?
     (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*))
    (CL:SETF (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*) FALSE))
   (CL:SETF (%SUBCOLLECTION ITERATOR) SELF)
   (CL:SETF (%EXTENSION-ITERATOR ITERATOR) (ALL-EXTENSION-MEMBERS SELF))
   (CL:WHEN SPECIALIZE?
    (CL:SETF (%SUBCOLLECTION-ITERATOR ITERATOR)
     (ALL-SUBCOLLECTIONS SELF)))
   (CL:SETF (%REMOVING-DUPLICATES? ITERATOR)
    (CL:AND SPECIALIZE? (CL:= (ARITY SELF) 1)))
   (CL:WHEN DETERMINEDEFAULTTRUTH?
    (CL:WHEN (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*)
     (CL:SETF (%ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? ITERATOR) TRUE))
    (CL:SETF (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*)
     LATESTTOUCHEDDEFAULT?))
   ITERATOR))

;;; (DEFUN (ALL-MATCHING-EXTENSION-MEMBERS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-MATCHING-EXTENSION-MEMBERS (SELF SPECIALIZE?)
  (CL:LET*
   ((ITERATOR
     (ALL-TRUE-EXTENSION-MEMBERS
      (SURROGATE-TO-DESCRIPTION (%OPERATOR SELF)) SPECIALIZE?)))
   (CL:SETF (%REFERENCE-PROPOSITION ITERATOR) SELF) ITERATOR))

;;; (DEFGLOBAL *DUPLICATEINSTANCESCACHECROSSOVERPOINT* ...)

(CL:PROGN (CL:DEFVAR *DUPLICATEINSTANCESCACHECROSSOVERPOINT* 20 "Point where a cache of generated instances in a 
description extension iterator is switched from a list to a hash table") (CL:DECLAIM (CL:TYPE CL:FIXNUM *DUPLICATEINSTANCESCACHECROSSOVERPOINT*)))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF DESCRIPTION-EXTENSION-ITERATOR))
  (CL:LET*
   ((PATTERNRECORD (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))
    (UBSTACKOFFSET (CL:1+ (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD)))
    (DETERMINEDEFAULTTRUTH?
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)))
    (LATESTTOUCHEDDEFAULT? FALSE))
   (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
   (CL:WHEN DETERMINEDEFAULTTRUTH?
    (CL:SETQ LATESTTOUCHEDDEFAULT?
     (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*)))
   (CL:LOOP
    (CL:TAGBODY
     (CL:LOOP
      (CL:TAGBODY
       (CL:WHEN DETERMINEDEFAULTTRUTH?
        (CL:SETF (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*) FALSE)
        (CL:SETF (%ITERATOR-VALUE-HOLDS-BY-DEFAULT? SELF) FALSE))
       (CL:WHEN (CL:NOT (NEXT? (%EXTENSION-ITERATOR SELF))) (CL:RETURN))
       (CL:LET* ((VALUE (%VALUE (%EXTENSION-ITERATOR SELF))))
        (CL:WHEN
         (CL:NOT
          (CL:AND (TRUE-PROPOSITION? VALUE)
           (CL:OR (CL:EQ (%REFERENCE-PROPOSITION SELF) NULL)
            (ARGUMENTS-MATCH-ARGUMENTS? VALUE
             (%REFERENCE-PROPOSITION SELF)))))
         (CL:GO :CONTINUE))
        (CL:SETF (%VALUE SELF) VALUE)
        (CL:WHEN DETERMINEDEFAULTTRUTH?
         (CL:SETF (%ITERATOR-VALUE-HOLDS-BY-DEFAULT? SELF)
          (CL:OR (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*)
           (%ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? SELF)))
         (CL:SETF (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*)
          LATESTTOUCHEDDEFAULT?))
        (CL:WHEN (CL:NOT (%REMOVING-DUPLICATES? SELF))
         (CL:RETURN-FROM NEXT? TRUE))
        (CL:LET*
         ((INSTANCE
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS VALUE))) 0)))
         (CL:WHEN
          (CL:AND (CL:EQ (%ALREADY-GENERATED-TABLE SELF) NULL)
           (CL:>= (LENGTH (%ALREADY-GENERATED-LIST SELF))
            *DUPLICATEINSTANCESCACHECROSSOVERPOINT*))
          (CL:LET* ((HASHTABLE (NEW-HASH-TABLE)))
           (CL:LET*
            ((M NULL)
             (ITER-000 (%THE-CONS-LIST (%ALREADY-GENERATED-LIST SELF))))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
             (CL:PROGN (CL:SETQ M (%%VALUE ITER-000))
              (CL:SETQ ITER-000 (%%REST ITER-000)))
             (INSERT-AT HASHTABLE M M)))
           (CL:SETF (%ALREADY-GENERATED-TABLE SELF) HASHTABLE)))
         (CL:IF (CL:NOT (CL:EQ (%ALREADY-GENERATED-TABLE SELF) NULL))
          (CL:WHEN
           (CL:EQ (LOOKUP (%ALREADY-GENERATED-TABLE SELF) INSTANCE) NULL)
           (INSERT-AT (%ALREADY-GENERATED-TABLE SELF) INSTANCE INSTANCE)
           (CL:RETURN-FROM NEXT? TRUE))
          (CL:WHEN
           (CL:NOT (MEMBER? (%ALREADY-GENERATED-LIST SELF) INSTANCE))
           (PUSH (%ALREADY-GENERATED-LIST SELF) INSTANCE)
           (CL:RETURN-FROM NEXT? TRUE)))
         (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD UBSTACKOFFSET)))
       :CONTINUE))
     (CL:WHEN (CL:EQ (%SUBCOLLECTION-ITERATOR SELF) NULL) (CL:RETURN))
     (CL:LET*
      ((SUBCOLLECTIONITERATOR (%SUBCOLLECTION-ITERATOR SELF))
       (SUBCOLLECTION NULL))
      (CL:WHEN DETERMINEDEFAULTTRUTH?
       (CL:SETF (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*) FALSE))
      (CL:LOOP WHILE (NEXT? SUBCOLLECTIONITERATOR) DO
       (CL:SETQ SUBCOLLECTION (%VALUE SUBCOLLECTIONITERATOR))
       (CL:IF
        (CL:AND (ISA? SUBCOLLECTION SGT-QUERY-LOGIC-NAMED-DESCRIPTION)
         (CL:NOT
          (CL:EQ (DESCRIPTION-EXTENSION SUBCOLLECTION) NIL-PAGING-INDEX)))
        (CL:RETURN) (CL:SETQ SUBCOLLECTION NULL)))
      (CL:WHEN (CL:EQ SUBCOLLECTION NULL) (CL:RETURN))
      (CL:SETF (%SUBCOLLECTION SELF) SUBCOLLECTION)
      (CL:SETF (%EXTENSION-ITERATOR SELF)
       (ALL-EXTENSION-MEMBERS SUBCOLLECTION))
      (CL:WHEN
       (CL:AND DETERMINEDEFAULTTRUTH?
        (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*))
       (CL:SETF (%ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? SELF) TRUE)))
     :CONTINUE))
   (CL:WHEN DETERMINEDEFAULTTRUTH?
    (CL:SETF (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*)
     LATESTTOUCHEDDEFAULT?))
   FALSE))

;;; (DEFCONSTANT *QUERY-THREAD-LIMIT* ...)

(CL:PROGN (CL:DEFVAR *QUERY-THREAD-LIMIT* 8 "Maximum number of simultaneous query threads.") (CL:DECLAIM (CL:TYPE CL:FIXNUM *QUERY-THREAD-LIMIT*)))

;;; (DEFGLOBAL *MAXIMUM-QUERY-THREAD-OFFSET* ...)

(CL:PROGN (CL:DEFVAR *MAXIMUM-QUERY-THREAD-OFFSET* NULL-INTEGER) (CL:DECLAIM (CL:TYPE CL:FIXNUM *MAXIMUM-QUERY-THREAD-OFFSET*)))

;;; (DEFGLOBAL *FREE-QUERY-THREAD-OFFSETS* ...)

(CL:DEFVAR *FREE-QUERY-THREAD-OFFSETS* NULL
  "List of unused query thread offsets.")

;;; (DEFGLOBAL *QUERY-ITERATORS-VECTOR* ...)

(CL:DEFVAR *QUERY-ITERATORS-VECTOR* NULL
  "Records currently active (unreleased) query iterators.")

;;; (DEFUN RESERVE-QUERY-THREAD ...)

(CL:DEFUN RESERVE-QUERY-THREAD (QUERYITERATOR)
  "Find a free query thread and assign it to 'queryIterator'.
Signal a :QUERY-THREAD-LIMIT-VIOLATION exception if all threads are taken."
  (CL:LET* ((OFFSET (POP *FREE-QUERY-THREAD-OFFSETS*)))
   (CL:WHEN (CL:EQ OFFSET NULL) (CLEAR-QUERY-THREADS)
    (RESERVE-QUERY-THREAD QUERYITERATOR)
    (CL:RETURN-FROM RESERVE-QUERY-THREAD))
   (CL:LET
    ((SELF (%THE-ARRAY *QUERY-ITERATORS-VECTOR*)) (VALUE QUERYITERATOR)
     (POSITION (%WRAPPER-VALUE OFFSET)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%QUERY-THREAD-OFFSET QUERYITERATOR) (%WRAPPER-VALUE OFFSET))
   NULL))

;;; (DEFUN RELEASE-QUERY-THREAD ...)

(CL:DEFUN RELEASE-QUERY-THREAD (QUERYITERATOR)
  "Release the query thread for 'queryIterator'."
  (CL:WHEN (CL:EQ QUERYITERATOR NULL)
   (CL:RETURN-FROM RELEASE-QUERY-THREAD))
  (CL:LET* ((OFFSET (%QUERY-THREAD-OFFSET QUERYITERATOR)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
   (CL:WHEN (DEFINED? OFFSET)
    (CL:LET
     ((SELF (%THE-ARRAY *QUERY-ITERATORS-VECTOR*)) (VALUE NULL)
      (POSITION OFFSET))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (PUSH *FREE-QUERY-THREAD-OFFSETS* (WRAP-INTEGER OFFSET)))))

;;; (DEFUN (RELEASE-ALL-QUERY-THREADS (LIST OF INTEGER-WRAPPER)) ...)

(CL:DEFUN RELEASE-ALL-QUERY-THREADS ()
  "Free up all query threads (buggy queries may have
failed to terminate)."
  (CL:LET*
   ((OFFSET NULL-INTEGER) (ITER-000 0)
    (UPPER-BOUND-000 *MAXIMUM-QUERY-THREAD-OFFSET*)
    (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 OFFSET))
   (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000))
    DO
    (CL:PROGN (CL:SETQ OFFSET ITER-000)
     (CL:SETQ ITER-000 (CL:1+ ITER-000)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "off" OFFSET " mm "
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY *QUERY-ITERATORS-VECTOR*))
      OFFSET)
     EOL)
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY *QUERY-ITERATORS-VECTOR*))
        OFFSET)
       NULL))
     (FREE-QUERY-ITERATOR
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY *QUERY-ITERATORS-VECTOR*))
       OFFSET)))))
  *FREE-QUERY-THREAD-OFFSETS*)

;;; (DEFUN (CLEAR-QUERY-THREADS (LIST OF INTEGER-WRAPPER)) ...)

(CL:DEFUN CLEAR-QUERY-THREADS ()
  (CL:LET*
   ((OFFSET NULL-INTEGER) (ITER-000 0)
    (UPPER-BOUND-000 *MAXIMUM-QUERY-THREAD-OFFSET*)
    (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 OFFSET))
   (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000))
    DO
    (CL:PROGN (CL:SETQ OFFSET ITER-000)
     (CL:SETQ ITER-000 (CL:1+ ITER-000)))
    (CL:LET
     ((SELF (%THE-ARRAY *QUERY-ITERATORS-VECTOR*)) (VALUE NULL)
      (POSITION OFFSET))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (INSERT-NEW *FREE-QUERY-THREAD-OFFSETS* (WRAP-INTEGER OFFSET))))
  *FREE-QUERY-THREAD-OFFSETS*)

;;; (DEFUN (HELP-FIND-DUPLICATED-GOAL CONTROL-FRAME CONTROL-FRAME INTEGER) ...)

(CL:DEFUN HELP-FIND-DUPLICATED-GOAL (GOALFRAME)
  (CL:LET*
   ((ATOMICGOAL (%PROPOSITION GOALFRAME))
    (BINDINGS (%GOAL-BINDINGS GOALFRAME)) (DEPTH 1) (FIRSTGOALFRAME NULL)
    (TESTGOAL NULL) (TESTFRAME NULL) (RESTARTFRAME NULL)
    (RESTARTDEPTH NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH RESTARTDEPTH))
   (CL:SETQ TESTFRAME (%DOWN (%BASE-CONTROL-FRAME *QUERYITERATOR*)))
   (CL:LOOP (CL:SETQ TESTGOAL (%PROPOSITION TESTFRAME))
    (CL:LET* ((TEST-VALUE-000 FALSE))
     (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ TESTGOAL NULL)))
     (CL:WHEN TEST-VALUE-000
      (CL:SETQ TEST-VALUE-000
       (CL:EQ (%OPERATOR TESTGOAL) (%OPERATOR ATOMICGOAL)))
      (CL:WHEN TEST-VALUE-000
       (CL:SETQ TEST-VALUE-000
        (CL:EQ (%REVERSE-POLARITY? TESTFRAME)
         (%REVERSE-POLARITY? GOALFRAME)))
       (CL:WHEN TEST-VALUE-000
        (CL:IF
         (CL:AND (CL:EQ BINDINGS NULL)
          (CL:EQ (%GOAL-BINDINGS TESTFRAME) NULL))
         (CL:SETQ TEST-VALUE-000 TRUE)
         (CL:PROGN (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ BINDINGS NULL)))
          (CL:WHEN TEST-VALUE-000
           (CL:SETQ TEST-VALUE-000
            (CL:NOT (CL:EQ (%GOAL-BINDINGS TESTFRAME) NULL)))
           (CL:WHEN TEST-VALUE-000
            (CL:LET* ((ALWAYS?-000 TRUE))
             (CL:LET*
              ((B2 NULL) (B1 NULL) (ITER-000 BINDINGS)
               (ITER-001 (%GOAL-BINDINGS TESTFRAME)))
              (CL:LOOP WHILE
               (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
                (CL:NOT (CL:EQ ITER-001 NIL)))
               DO
               (CL:PROGN (CL:SETQ B1 (%%VALUE ITER-000))
                (CL:SETQ ITER-000 (%%REST ITER-000)))
               (CL:PROGN (CL:SETQ B2 (%%VALUE ITER-001))
                (CL:SETQ ITER-001 (%%REST ITER-001)))
               (CL:WHEN (CL:NOT (EQL? B1 B2)) (CL:SETQ ALWAYS?-000 FALSE)
                (CL:RETURN))))
             (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))))))))
     (CL:WHEN TEST-VALUE-000
      (CL:IF (CL:EQ FIRSTGOALFRAME NULL)
       (CL:SETQ FIRSTGOALFRAME TESTFRAME)
       (CL:RETURN-FROM HELP-FIND-DUPLICATED-GOAL
        (CL:VALUES FIRSTGOALFRAME RESTARTFRAME RESTARTDEPTH)))))
    (CL:SETQ RESTARTFRAME TESTFRAME) (CL:SETQ RESTARTDEPTH DEPTH)
    (CL:SETQ TESTFRAME (%DOWN TESTFRAME)) (CL:SETQ DEPTH (CL:1+ DEPTH))
    (CL:WHEN (CL:EQ TESTFRAME NULL)
     (CL:RETURN-FROM HELP-FIND-DUPLICATED-GOAL
      (CL:VALUES NULL NULL NULL-INTEGER))))))

;;; (DEFUN (FIND-DUPLICATED-GOAL CONTROL-FRAME CONTROL-FRAME INTEGER) ...)

(CL:DEFUN FIND-DUPLICATED-GOAL (FRAME)
  (CL:LET*
   ((TRIALFRAME FRAME) (TRIALGOAL NULL)
    (FIRSTREALCONTROLFRAME (%DOWN (%BASE-CONTROL-FRAME *QUERYITERATOR*))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ TRIALFRAME FIRSTREALCONTROLFRAME)) DO
    (CL:SETQ TRIALGOAL (%PROPOSITION TRIALFRAME))
    (CL:WHEN (CL:NOT (CL:EQ TRIALGOAL NULL))
     (CL:LET* ((TEST-VALUE-000 (%KIND TRIALGOAL)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-000 KWD-QUERY-ISA)
         (CL:EQ TEST-VALUE-000 KWD-QUERY-PREDICATE)
         (CL:EQ TEST-VALUE-000 KWD-QUERY-FUNCTION))
        (CL:LET*
         ((GOALFRAME NULL) (RESTARTFRAME NULL)
          (RESTARTDEPTH NULL-INTEGER))
         (CL:DECLARE (CL:TYPE CL:FIXNUM RESTARTDEPTH))
         (CL:MULTIPLE-VALUE-SETQ (GOALFRAME RESTARTFRAME RESTARTDEPTH)
          (HELP-FIND-DUPLICATED-GOAL TRIALFRAME))
         (CL:WHEN (CL:NOT (CL:EQ GOALFRAME NULL))
          (TRACE-GOAL-CACHE "DUPLICATED GOAL: " TRIALFRAME)
          (CL:WHEN
           (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
            (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES))
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
            "   RESTART DEPTH " RESTARTDEPTH EOL))
          (CL:RETURN-FROM FIND-DUPLICATED-GOAL
           (CL:VALUES GOALFRAME RESTARTFRAME RESTARTDEPTH)))))
       (CL:T))))
    (CL:SETQ TRIALFRAME (%UP TRIALFRAME)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "FAILED TO FIND DUPLICATE GOAL" EOL))
   (CL:SETF (%FAILED-TO-FIND-DUPLICATE-SUBGOAL? *QUERYITERATOR*) TRUE)
   (CL:VALUES NULL NULL NULL-INTEGER)))

;;; (DEFUN (HANDLE-DEPTH-VIOLATION CONTROL-FRAME INTEGER) ...)

(CL:DEFUN HANDLE-DEPTH-VIOLATION (FRAME DEPTH)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DEPTH))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "CUTOFF: depth = "
    DEPTH EOL))
  (CL:SETF (%TRIGGERED-DEPTH-CUTOFF? *QUERYITERATOR*) TRUE)
  (CL:WHEN
   (CL:AND (CL:OR *CACHE-SUCCEEDED-GOALS?* *CACHE-FAILED-GOALS?*)
    (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
    (CL:NOT
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))))
   (DONT-CACHE-GOAL-FAILURE-BETWEEN-FRAMES FRAME
    (%BASE-CONTROL-FRAME *QUERYITERATOR*)))
  (CL:WHEN
   (CL:OR (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
    (CL:EQ *DUPLICATE-SUBGOAL-STRATEGY*
     KWD-QUERY-DUPLICATE-GOALS-WITH-CACHING))
   (CL:RETURN-FROM HANDLE-DEPTH-VIOLATION (CL:VALUES FRAME DEPTH)))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "CUTOFF: depth = "
    DEPTH EOL))
  (CL:LET*
   ((GOALFRAME NULL) (RESTARTFRAME NULL) (RESTARTDEPTH NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM RESTARTDEPTH))
   (CL:MULTIPLE-VALUE-SETQ (GOALFRAME RESTARTFRAME RESTARTDEPTH)
    (FIND-DUPLICATED-GOAL FRAME))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ GOALFRAME NULL))
     (CL:EQ (FIND-GOAL-CACHE GOALFRAME) NULL)
     (CREATE-GOAL-CACHE? GOALFRAME))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
      (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "RESTART: restartDepth = " RESTARTDEPTH EOL))
    (CL:WHEN (CL:NOT (CL:EQ (%DOWN RESTARTFRAME) NULL))
     (POP-FRAMES-UP-TO (%DOWN RESTARTFRAME))
     (CL:SETF (%DOWN RESTARTFRAME) NULL))
    (CL:RETURN-FROM HANDLE-DEPTH-VIOLATION
     (CL:VALUES RESTARTFRAME RESTARTDEPTH))))
  (CL:VALUES FRAME DEPTH))

;;; (DEFUN PRINT-CONTROL-FRAME ...)

(CL:DEFUN PRINT-CONTROL-FRAME (SELF STREAM)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-QUERY-LOGIC-PARALLEL-CONTROL-FRAME)
    (CL:PROGN
     (%%PRINT-STREAM STREAM "|PLL-CF|" (%DEBUG-FRAME-ID SELF) "[")))
   (CL:T (%%PRINT-STREAM STREAM "|CF|" (%DEBUG-FRAME-ID SELF) "[")))
  (CL:IF (DEFINED? (%CHOICE-POINT-UNBINDING-OFFSET SELF))
   (%%PRINT-STREAM STREAM (%CHOICE-POINT-UNBINDING-OFFSET SELF))
   (%%PRINT-STREAM STREAM "_"))
  (CL:LET* ((*PRINTINFRAME* SELF))
   (CL:DECLARE (CL:SPECIAL *PRINTINFRAME*))
   (%%PRINT-STREAM STREAM " " (%STATE SELF) " " (%CURRENT-STRATEGY SELF)
    "  UP: "
    (CL:IF (CL:NOT (CL:EQ (%UP SELF) NULL)) (%DEBUG-FRAME-ID (%UP SELF))
     NULL-INTEGER)
    "  DOWN: "
    (CL:IF (CL:NOT (CL:EQ (%DOWN SELF) NULL))
     (%DEBUG-FRAME-ID (%DOWN SELF)) NULL-INTEGER)
    "  DEPTH: " (%DEBUG-DEPTH SELF) " " (%PROPOSITION SELF) "]")))

;;; (DEFUN PRINT-GOAL-STACK ...)

(CL:DEFUN PRINT-GOAL-STACK (FRAME VERBOSE?)
  "Print stack of goals.  Assumes that query has been interrupted
with a full stack of control frames."
  (CL:WHEN (CL:NOT (CL:EQ (%PROPOSITION FRAME) NULL))
   (CL:LET* ((*PRINTINFRAME* FRAME))
    (CL:DECLARE (CL:SPECIAL *PRINTINFRAME*))
    (CL:IF VERBOSE?
     (CL:PROGN
      (PRINT-CONTROL-FRAME FRAME (%NATIVE-STREAM STANDARD-OUTPUT))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) (%PROPOSITION FRAME)
      EOL))))
  (CL:WHEN (CL:NOT (CL:EQ (%DOWN FRAME) NULL))
   (PRINT-GOAL-STACK (%DOWN FRAME) VERBOSE?)))

;;; (DEFUN PGS ...)

(CL:DEFUN PGS ()
  (PRINT-GOAL-STACK (%BASE-CONTROL-FRAME *QUERYITERATOR*) FALSE))

;;; (DEFUN VPGS ...)

(CL:DEFUN VPGS ()
  (PRINT-GOAL-STACK (%BASE-CONTROL-FRAME *QUERYITERATOR*) TRUE))

;;; (DEFUN PRINT-QUERY-ITERATOR ...)

(CL:DEFUN PRINT-QUERY-ITERATOR (SELF STREAM)
  (CL:IF *PRINTREADABLY?* (PRINT-QUERY-ITERATOR-READABLY SELF STREAM)
   (PRINT-QUERY-ITERATOR-ORNATELY SELF STREAM)))

;;; (DEFUN PRINT-QUERY-ITERATOR-ORNATELY ...)

(CL:DEFUN PRINT-QUERY-ITERATOR-ORNATELY (SELF STREAM)
  (CL:LET*
   ((SOLUTIONS (%SOLUTIONS SELF)) (NOFSOLUTIONS (LENGTH SOLUTIONS))
    (EXHAUSTED? (%EXHAUSTED? SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFSOLUTIONS))
   (CL:CASE NOFSOLUTIONS (0 (%%PRINT-STREAM STREAM "No solutions"))
    (1 (%%PRINT-STREAM STREAM "There is 1 solution"))
    (CL:OTHERWISE
     (%%PRINT-STREAM STREAM "There are " NOFSOLUTIONS " solutions")))
   (CL:WHEN (CL:NOT EXHAUSTED?) (%%PRINT-STREAM STREAM " so far"))
   (CL:WHEN (%TIMEOUT? SELF)
    (%%PRINT-STREAM STREAM " (timed out after " (%ALLOTTED-TIME SELF)
     " seconds)"))
   (CL:WHEN (CL:= NOFSOLUTIONS 0) (%%PRINT-STREAM STREAM "." EOL)
    (CL:RETURN-FROM PRINT-QUERY-ITERATOR-ORNATELY))
   (%%PRINT-STREAM STREAM ":" EOL)
   (CL:LET*
    ((SCORE NULL) (I NULL-INTEGER) (SOLUTION NULL)
     (ITER-000 (%THE-CONS-LIST SOLUTIONS)) (ITER-001 1)
     (ITER-002 (%THE-CONS-LIST (%MATCH-SCORES SELF))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:NOT (CL:EQ ITER-002 NIL)))
     DO
     (CL:PROGN (CL:SETQ SOLUTION (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:PROGN (CL:SETQ SCORE (%%VALUE ITER-002))
      (CL:SETQ ITER-002 (%%REST ITER-002)))
     (%%PRINT-STREAM STREAM "  #" I ": ")
     (CL:LET*
      ((VI NULL-INTEGER) (VALUE NULL) (VECTOR-000 SOLUTION) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)) (ITER-003 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-003 VI))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:PROGN
        (CL:SETQ VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
       (CL:PROGN (CL:SETQ VI ITER-003)
        (CL:SETQ ITER-003 (CL:1+ ITER-003)))
       (%%PRINT-STREAM STREAM (CL:IF (CL:= VI 0) "" ", ")
        (%SKOLEM-NAME
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY (%EXTERNAL-VARIABLES SELF)))
          VI))
        "=" VALUE)
       (CL:WHEN (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY SELF) NULL))
        (%%PRINT-STREAM STREAM " " SCORE))))
     (CL:WHEN (CL:< I NOFSOLUTIONS) (%%PRINT-STREAM STREAM EOL))))))

;;; (DEFUN PRINT-QUERY-ITERATOR-READABLY ...)

(CL:DEFUN PRINT-QUERY-ITERATOR-READABLY (SELF STREAM)
  (CL:LET*
   ((SOLUTIONS (%SOLUTIONS SELF)) (FIRST? TRUE)
    (ATOMICSINGLETONS?
     (CL:AND (%ATOMIC-SINGLETONS? SELF)
      (CL:EQ (%PARTIAL-MATCH-STRATEGY SELF) NULL))))
   (%%PRINT-STREAM STREAM "(")
   (CL:LET*
    ((SCORE NULL) (SOLUTION NULL) (ITER-000 (%THE-CONS-LIST SOLUTIONS))
     (ITER-001 (%THE-CONS-LIST (%MATCH-SCORES SELF))))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:NOT (CL:EQ ITER-001 NIL)))
     DO
     (CL:PROGN (CL:SETQ SOLUTION (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ SCORE (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:WHEN (CL:NOT FIRST?)
      (CL:IF ATOMICSINGLETONS? (%%PRINT-STREAM STREAM " ")
       (%%PRINT-STREAM STREAM EOL " ")))
     (CL:SETQ FIRST? FALSE)
     (CL:WHEN (CL:NOT ATOMICSINGLETONS?) (%%PRINT-STREAM STREAM "("))
     (CL:LET*
      ((VI NULL-INTEGER) (VALUE NULL) (VECTOR-000 SOLUTION) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)) (ITER-002 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-002 VI))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:PROGN
        (CL:SETQ VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
       (CL:PROGN (CL:SETQ VI ITER-002)
        (CL:SETQ ITER-002 (CL:1+ ITER-002)))
       (%%PRINT-STREAM STREAM (CL:IF (CL:= VI 0) "" " ") VALUE)
       (CL:WHEN (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY SELF) NULL))
        (%%PRINT-STREAM STREAM " " SCORE))))
     (CL:WHEN (CL:NOT ATOMICSINGLETONS?) (%%PRINT-STREAM STREAM ")"))))
   (%%PRINT-STREAM STREAM ")" EOL)))

;;; (DEFUN (ALLOCATE-QUERY-ITERATOR QUERY-ITERATOR) ...)

(CL:DEFUN ALLOCATE-QUERY-ITERATOR ()
  (CL:LET* ((QUERYITERATOR (NEW-QUERY-ITERATOR)))
   (RESERVE-QUERY-THREAD QUERYITERATOR)
   (UPDATE-NOW-TIMESTAMP KWD-QUERY-EXECUTE-QUERY)
   (CL:SETF (%TIMESTAMP QUERYITERATOR) (GET-NOW-TIMESTAMP)) QUERYITERATOR))

;;; (DEFMETHOD FREE ...)

(CL:DEFMETHOD FREE ((SELF QUERY-ITERATOR))
  (FREE-QUERY-ITERATOR SELF))

;;; (DEFUN FREE-QUERY-ITERATOR ...)

(CL:DEFUN FREE-QUERY-ITERATOR (SELF)
  (CL:WHEN (CL:EQ (%BASE-CONTROL-FRAME SELF) NULL)
   (CL:RETURN-FROM FREE-QUERY-ITERATOR))
  (FREE (%VALUE SELF))
  (CL:SETF (%BASE-CONTROL-FRAME SELF) NULL))

;;; (DEFUN (ALLOCATE-COLLECTION-VARIABLES VARIABLES-VECTOR) ...)

(CL:DEFUN ALLOCATE-COLLECTION-VARIABLES (FRAME DESCRIPTION)
  (CL:LET*
   ((VARIABLESCOUNT (LENGTH (%IO-VARIABLES DESCRIPTION)))
    (EXTERNALVARIABLES (NEW-VECTOR VARIABLESCOUNT)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM VARIABLESCOUNT))
   (CL:LET*
    ((I NULL-INTEGER) (IOVAR NULL)
     (VECTOR-000 (%IO-VARIABLES DESCRIPTION)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-000 I))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ IOVAR
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:LET
      ((SELF (%THE-ARRAY EXTERNALVARIABLES))
       (VALUE
        (CREATE-VARIABLE (%ROOT-TYPE IOVAR) (%SKOLEM-NAME IOVAR) FALSE))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETF
      (%BOUND-TO-OFFSET
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY EXTERNALVARIABLES))
        I))
      I)))
   (CL:WHEN (CL:EQ (%PATTERN-RECORD FRAME) NULL)
    (CREATE-PATTERN-RECORD FRAME NULL NULL))
   (ACTIVATE-PATTERN-RECORD (%PATTERN-RECORD FRAME) VARIABLESCOUNT)
   EXTERNALVARIABLES))

;;; (DEFUN (CREATE-QUERY-ITERATOR QUERY-ITERATOR) ...)

(CL:DEFUN CREATE-QUERY-ITERATOR (DESCRIPTION OUTSIDEBINDINGS ATOMICSINGLETONS?)
  (CL:LET*
   ((QUERYITERATOR (ALLOCATE-QUERY-ITERATOR))
    (BASECONTROLFRAME (NEW-CONTROL-FRAME))
    (VARIABLESCOUNT (LENGTH (%IO-VARIABLES DESCRIPTION)))
    (EXTERNALVARIABLES NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM VARIABLESCOUNT))
   (CL:LET*
    ((*QUERYITERATOR* QUERYITERATOR)
     (*EVALUATIONMODE* KWD-QUERY-DESCRIPTION))
    (CL:DECLARE (CL:SPECIAL *QUERYITERATOR* *EVALUATIONMODE*))
    (CL:SETF (%QUERY-CONTEXT QUERYITERATOR) *CONTEXT*)
    (CL:SETF (%ATOMIC-SINGLETONS? QUERYITERATOR) ATOMICSINGLETONS?)
    (CL:SETF (%BASE-CONTROL-FRAME QUERYITERATOR) BASECONTROLFRAME)
    (CL:SETF (%CURRENT-CONTROL-FRAME QUERYITERATOR) BASECONTROLFRAME)
    (CL:SETQ *CONTROL-FRAME-ID-COUNTER* 0)
    (CL:SETF (%PROPOSITION BASECONTROLFRAME) (%PROPOSITION DESCRIPTION))
    (CL:SETF (%UP BASECONTROLFRAME) NULL)
    (CL:SETF (%GOAL-CACHE BASECONTROLFRAME) NULL)
    (CL:SETF (%GOAL-BINDINGS BASECONTROLFRAME) NULL)
    (CL:SETF (%DEBUG-FRAME-ID BASECONTROLFRAME)
     *CONTROL-FRAME-ID-COUNTER*)
    (CL:SETQ EXTERNALVARIABLES
     (ALLOCATE-COLLECTION-VARIABLES BASECONTROLFRAME DESCRIPTION))
    (CL:LET*
     ((*CONTEXT* (GET-QUERY-CONTEXT)) (*MODULE* (%BASE-MODULE *CONTEXT*)))
     (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
     (CL:WHEN (CL:NOT (CL:EQ OUTSIDEBINDINGS NULL))
      (CL:WHEN (CL:> (LENGTH OUTSIDEBINDINGS) (LENGTH EXTERNALVARIABLES))
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
         "Arity mismatch between bindings `" OUTSIDEBINDINGS
         "' and external varaibles `" EXTERNALVARIABLES "'.")
        (CL:ERROR (NEW-FAIL-EXCEPTION (THE-STRING-READER STREAM-000)))))
      (CL:LET*
       ((VALUE NULL) (ARG NULL) (VECTOR-000 EXTERNALVARIABLES)
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
        (VECTOR-001 OUTSIDEBINDINGS) (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
        DO
        (CL:PROGN
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
        (CL:PROGN
         (CL:SETQ VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
           INDEX-001))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ VALUE NULL))
          (CL:NOT (BIND-ARGUMENT-TO-VALUE? ARG VALUE FALSE)))
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "Binding of `" ARG
           "' to `" VALUE "' failed.")
          (CL:ERROR
           (NEW-FAIL-EXCEPTION (THE-STRING-READER STREAM-001))))))))
     (OVERLAY-WITH-PATTERN-FRAME? BASECONTROLFRAME DESCRIPTION
      EXTERNALVARIABLES))
    (CL:SETF (%CONTROL-FRAME-PRIORITY-QUEUE QUERYITERATOR)
     (NEW-CONTROL-FRAME-PRIORITY-QUEUE))
    (CL:SETF (%MAXIMUM-DEPTH QUERYITERATOR) *MAXIMUM-BACKTRACKING-DEPTH*)
    (CL:SETF (%AUGMENTED-GOAL-CACHE? QUERYITERATOR) FALSE)
    (CLEAR (%ACTIVE-GOAL-CACHES QUERYITERATOR))
    (CL:SETF (%ITERATIVE-DEEPENING? QUERYITERATOR)
     *ITERATIVE-DEEPENING-MODE?*)
    (CL:SETF (%CURRENT-DEPTH-CUTOFF QUERYITERATOR)
     (CL:IF (%ITERATIVE-DEEPENING? QUERYITERATOR)
      (MIN *INITIAL-BACKTRACKING-DEPTH* (%MAXIMUM-DEPTH QUERYITERATOR))
      (%MAXIMUM-DEPTH QUERYITERATOR)))
    (CL:SETF (%TRIGGERED-DEPTH-CUTOFF? QUERYITERATOR) FALSE)
    (CL:SETF (%FAILED-TO-FIND-DUPLICATE-SUBGOAL? QUERYITERATOR) FALSE)
    (CL:SETF (%FOUND-AT-LEAST-ONE-SOLUTION? QUERYITERATOR) FALSE)
    (CL:SETF (%EXTERNAL-VARIABLES QUERYITERATOR) EXTERNALVARIABLES)
    (CL:SETF (%VALUE QUERYITERATOR) (NEW-VECTOR VARIABLESCOUNT))
    QUERYITERATOR)))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF QUERY-ITERATOR))
  (CL:LET* ((VALUEVECTOR (%VALUE SELF)) (HOLDSBYDEFAULT? FALSE))
   (CL:WHEN (%EXHAUSTED? SELF) (CL:RETURN-FROM NEXT? FALSE))
   (CL:LOOP
    (CL:TAGBODY
     (CL:LET*
      ((*CONTEXT* (GET-QUERY-CONTEXT))
       (*MODULE* (%BASE-MODULE *CONTEXT*)))
      (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
      (CL:LOOP WHILE (EXECUTE-BACKWARD-CHAINING-PROOF? SELF) DO
       (CL:TAGBODY
        (CL:LET*
         ((I NULL-INTEGER) (EV NULL)
          (VECTOR-000 (%EXTERNAL-VARIABLES SELF)) (INDEX-000 0)
          (LENGTH-000 (LENGTH VECTOR-000)) (ITER-000 0))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-000 I))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:PROGN
           (CL:SETQ EV
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
             INDEX-000))
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
          (CL:PROGN (CL:SETQ I ITER-000)
           (CL:SETQ ITER-000 (CL:1+ ITER-000)))
          (CL:LET
           ((SELF (%THE-ARRAY VALUEVECTOR))
            (VALUE
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%THE-ARRAY
                (%VARIABLE-BINDINGS
                 (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
              (CL:THE CL:FIXNUM (%BOUND-TO-OFFSET EV))))
            (POSITION I))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SETF (CL:AREF SELF POSITION) VALUE))))
        (CL:SETF (%FOUND-AT-LEAST-ONE-SOLUTION? SELF) TRUE)
        (CL:LET* ((FOUND?-000 FALSE))
         (CL:LET*
          ((SOLUTION NULL) (ITER-001 (%THE-CONS-LIST (%SOLUTIONS SELF))))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:PROGN (CL:SETQ SOLUTION (%%VALUE ITER-001))
            (CL:SETQ ITER-001 (%%REST ITER-001)))
           (CL:LET* ((TEST-VALUE-000 FALSE))
            (CL:LET* ((ALWAYS?-000 TRUE))
             (CL:LET*
              ((NEWBINDING NULL) (OLDBINDING NULL) (VECTOR-001 SOLUTION)
               (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001))
               (VECTOR-002 VALUEVECTOR) (INDEX-002 0)
               (LENGTH-002 (LENGTH VECTOR-002)))
              (CL:DECLARE
               (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 INDEX-002
                LENGTH-002))
              (CL:LOOP WHILE
               (CL:AND (CL:< INDEX-001 LENGTH-001)
                (CL:< INDEX-002 LENGTH-002))
               DO
               (CL:PROGN
                (CL:SETQ OLDBINDING
                 (CL:AREF
                  (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
                  INDEX-001))
                (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
               (CL:PROGN
                (CL:SETQ NEWBINDING
                 (CL:AREF
                  (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-002))
                  INDEX-002))
                (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
               (CL:WHEN (CL:NOT (EQL? OLDBINDING NEWBINDING))
                (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
             (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
            (CL:WHEN TEST-VALUE-000
             (CL:SETQ TEST-VALUE-000
              (CL:NOT (CL:= (%ARRAY-SIZE SOLUTION) 0))))
            (CL:WHEN TEST-VALUE-000 (CL:SETQ FOUND?-000 TRUE)
             (CL:RETURN)))))
         (CL:WHEN FOUND?-000 (CL:GO :CONTINUE)))
        (CL:SETQ HOLDSBYDEFAULT?
         (%HOLDS-BY-DEFAULT? (%CURRENT-CONTROL-FRAME SELF)))
        (CL:WHEN HOLDSBYDEFAULT?
         (CL:WHEN (TRY-TO-DEFEAT-LAST-ANSWER? SELF) (CL:GO :CONTINUE)))
        (INSERT-LAST (%SOLUTIONS SELF) (COPY VALUEVECTOR))
        (INSERT-LAST (%TRUTH-VALUES SELF)
         (CL:IF HOLDSBYDEFAULT? DEFAULT-TRUE-TRUTH-VALUE
          TRUE-TRUTH-VALUE))
        (INSERT-LAST (%MATCH-SCORES SELF)
         (WRAP-FLOAT (%LATEST-POSITIVE-SCORE SELF)))
        (CL:RETURN-FROM NEXT? TRUE) :CONTINUE)))
     (CL:COND ((%TIMEOUT? SELF) (CL:RETURN-FROM NEXT? FALSE))
      ((%AUGMENTED-GOAL-CACHE? SELF) (RESET SELF))
      ((CL:AND (%ITERATIVE-DEEPENING? SELF)
        (%TRIGGERED-DEPTH-CUTOFF? SELF)
        (CL:< (%CURRENT-DEPTH-CUTOFF SELF) (%MAXIMUM-DEPTH SELF)))
       (CL:SETF (%CURRENT-DEPTH-CUTOFF SELF)
        (CL:1+ (%CURRENT-DEPTH-CUTOFF SELF)))
       (RESET SELF))
      (CL:T
       (CL:WHEN
        (CL:AND (%FAILED-TO-FIND-DUPLICATE-SUBGOAL? SELF)
         (CL:NOT (%FOUND-AT-LEAST-ONE-SOLUTION? SELF)))
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
         "Failed to find a duplicate subgoal on one or more occurrences when"
         EOL "   the depth cutoff " (%CURRENT-DEPTH-CUTOFF SELF)
         " was exceeded.  Consider increasing the cutoff" EOL
         "   (by setting the variable *maximum-backtracking-depth*)" EOL
         "   and trying again." EOL))
       (RELEASE-QUERY-THREAD SELF)
       (CL:SETF (%QUERY-THREAD-OFFSET SELF) NULL-INTEGER)
       (CL:SETF (%EXHAUSTED? SELF) TRUE) (CL:RETURN-FROM NEXT? FALSE)))
     :CONTINUE))))

;;; (DEFUN (TRY-TO-DEFEAT-LAST-ANSWER? BOOLEAN) ...)

(CL:DEFUN TRY-TO-DEFEAT-LAST-ANSWER? (SELF)
  (CL:LET*
   ((NEGATEDQUERY
     (CL:IF (CL:= (LENGTH (%VALUE SELF)) 0) SELF (%NEGATED-QUERY SELF)))
    (QUERYCONTEXT (%QUERY-CONTEXT SELF)) (STRICTPOSITIVEANSWER? FALSE)
    (STRICTNEGATIVEANSWER? FALSE) (DEFEATED? FALSE))
   (CL:COND
    ((CL:EQ NEGATEDQUERY NULL)
     (CL:SETQ NEGATEDQUERY
      (CREATE-QUERY-ITERATOR
       (%DESCRIPTION (%PATTERN-RECORD (%BASE-CONTROL-FRAME SELF)))
       (%VALUE SELF) (%ATOMIC-SINGLETONS? SELF)))
     (CL:SETF (%QUERY-CONTEXT NEGATEDQUERY) QUERYCONTEXT))
    (CL:T
     (CL:WHEN (CL:EQ SELF (%NEGATED-QUERY NEGATEDQUERY))
      (CL:RETURN-FROM TRY-TO-DEFEAT-LAST-ANSWER? FALSE))
     (CL:SETF
      (%VARIABLE-BINDINGS
       (%PATTERN-RECORD (%BASE-CONTROL-FRAME NEGATEDQUERY)))
      (%VALUE SELF))))
   (CL:SETF (%NEGATED-QUERY SELF) NEGATEDQUERY)
   (CL:SETF (%NEGATED-QUERY NEGATEDQUERY) SELF)
   (CL:SETF (%REVERSE-POLARITY? (%BASE-CONTROL-FRAME NEGATEDQUERY)) TRUE)
   (RESET NEGATEDQUERY)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "Looking for conflicting default conclusion:" EOL))
   (CL:WHEN (NEXT? NEGATEDQUERY) (RESET NEGATEDQUERY)
    (CL:LET* ((*DONTUSEDEFAULTKNOWLEDGE?* TRUE))
     (CL:DECLARE (CL:SPECIAL *DONTUSEDEFAULTKNOWLEDGE?*))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
       (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "Looking for conflicting strict conclusion:" EOL))
     (CL:SETQ STRICTNEGATIVEANSWER? (NEXT? NEGATEDQUERY)))
    (CL:SETF (%REVERSE-POLARITY? (%BASE-CONTROL-FRAME NEGATEDQUERY))
     FALSE)
    (RESET NEGATEDQUERY)
    (CL:LET* ((*DONTUSEDEFAULTKNOWLEDGE?* TRUE))
     (CL:DECLARE (CL:SPECIAL *DONTUSEDEFAULTKNOWLEDGE?*))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
       (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "Looking for strict conclusion:" EOL))
     (CL:SETQ STRICTPOSITIVEANSWER? (NEXT? NEGATEDQUERY)))
    (CL:IF STRICTPOSITIVEANSWER?
     (CL:COND
      (STRICTNEGATIVEANSWER?
       (CL:LET* ((*QUERYITERATOR* NEGATEDQUERY))
        (CL:DECLARE (CL:SPECIAL *QUERYITERATOR*))
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
         "CONTRADICTION: Discovered strict arguments for" EOL "    `"
         (%PROPOSITION (%BASE-CONTROL-FRAME NEGATEDQUERY)) "'" EOL
         "and its negation." EOL EOL))
       (CL:SETQ DEFEATED? TRUE))
      (CL:T (CL:SETQ DEFEATED? FALSE)))
     (CL:SETQ DEFEATED? TRUE)))
   (CL:SETF (%NEGATED-QUERY NEGATEDQUERY) NULL) DEFEATED?))

;;; (DEFMETHOD RESET ...)

(CL:DEFMETHOD RESET ((SELF QUERY-ITERATOR))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "------------- RESET -------------" EOL))
  (CL:LET* ((INITIALFRAME (%BASE-CONTROL-FRAME SELF)))
   (CL:WHEN (CL:NOT (CL:EQ (%DOWN INITIALFRAME) NULL))
    (POP-FRAMES-UP-TO (%DOWN INITIALFRAME)))
   (CL:LET* ((PATTERNRECORD (%PATTERN-RECORD INITIALFRAME)))
    (CL:LET* ((*CONTEXT* (GET-QUERY-CONTEXT)))
     (CL:DECLARE (CL:SPECIAL *CONTEXT*))
     (OVERLAY-WITH-PATTERN-FRAME? INITIALFRAME
      (%DESCRIPTION PATTERNRECORD) (%EXTERNAL-ARGUMENTS PATTERNRECORD))))
   (CL:SETF (%EXHAUSTED? SELF) FALSE) (CL:SETF (%TIMEOUT? SELF) FALSE)
   (CLEAR (%SOLUTIONS SELF)) (CLEAR (%TRUTH-VALUES SELF))
   (CLEAR (%MATCH-SCORES SELF))
   (CL:SETF (%HOLDS-BY-DEFAULT? INITIALFRAME) FALSE)
   (CL:SETF (%AUGMENTED-GOAL-CACHE? SELF) FALSE)
   (CL:SETF (%TRIGGERED-DEPTH-CUTOFF? SELF) FALSE)))

;;; (DEFUN (COPY-VECTOR-TO-CONS-LIST CONS) ...)

(CL:DEFUN COPY-VECTOR-TO-CONS-LIST (VECTOR)
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((ELEMENT NULL) (VECTOR-000 VECTOR) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ ELEMENT
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS ELEMENT NIL))
       (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ELEMENT NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   RESULT))

;;; (DEFUN (STANDARDIZE-QUERY-TREE CONS) ...)

(CL:DEFUN STANDARDIZE-QUERY-TREE (IOVARIABLES QUERYBODY EXTERNALVARIABLES)
  (CL:COND ((CL:EQ IOVARIABLES NULL) (CL:SETQ IOVARIABLES NIL))
   ((CL:NOT (CONS? IOVARIABLES))
    (CL:SETQ IOVARIABLES (CONS-LIST IOVARIABLES))))
  (CL:LET* ((STANDARDIZEDTREE NULL) (ALLVARIABLES IOVARIABLES))
   (CL:LET* ((V NULL) (ITER-000 (REVERSE EXTERNALVARIABLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ V (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:SETQ ALLVARIABLES (CONS V ALLVARIABLES))))
   (CL:WHEN (CL:EQ QUERYBODY NULL)
    (CL:SETQ QUERYBODY SYM-QUERY-STELLA-TRUE))
   (CL:COND
    ((CL:EQ ALLVARIABLES NIL)
     (CL:SETQ STANDARDIZEDTREE
      (LIST* SYM-QUERY-LOGIC-KAPPA NIL QUERYBODY NIL)))
    (CL:T
     (CL:SETQ STANDARDIZEDTREE
      (LIST* SYM-QUERY-STELLA-EXISTS ALLVARIABLES (CONS QUERYBODY NIL)))))
   (CL:SETQ STANDARDIZEDTREE
    (CANONICALIZE-QUANTIFICATION-TREE
     (STANDARDIZE-LOGICAL-PARSE-TREE STANDARDIZEDTREE)))
   (FIRST-SETTER STANDARDIZEDTREE SYM-QUERY-LOGIC-KAPPA) STANDARDIZEDTREE))

;;; (DEFUN (MAKE-QUERY QUERY-ITERATOR) ...)

(CL:DEFUN MAKE-QUERY (IOVARIABLES QUERYTREE EXTERNALBINDINGS OPTIONS)
  (FINALIZE-RELATIONS)
  (PROCESS-CHECK-TYPES-AGENDA)
  (CL:LET*
   ((PREFIXQUERYTREE (STANDARDIZE-QUERY-TREE IOVARIABLES QUERYTREE NIL))
    (EXTERNALVECTOR
     (CL:IF (CL:NOT (CL:EQ EXTERNALBINDINGS NIL))
      (COPY-LIST-TO-ARGUMENTS-VECTOR (LISTIFY EXTERNALBINDINGS)) NULL))
    (DESCRIPTION NULL) (QUERY NULL)
    (ATOMICSINGLETONS?
     (CL:OR (CL:NOT (CONS? IOVARIABLES))
      (SURROGATE? (%%VALUE (%%REST IOVARIABLES))))))
   (CL:LET*
    ((*EVALUATIONMODE* KWD-QUERY-DESCRIPTION) (*LOGICVARIABLETABLE* NIL)
     (*TERMUNDERCONSTRUCTION* PREFIXQUERYTREE))
    (CL:DECLARE
     (CL:SPECIAL *EVALUATIONMODE* *LOGICVARIABLETABLE*
      *TERMUNDERCONSTRUCTION*))
    (CL:LET* ((*MODULE* *MODULE*) (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CL:SETQ DESCRIPTION
      (EVALUATE-DESCRIPTION-TERM PREFIXQUERYTREE FALSE))))
   (PROCESS-CHECK-TYPES-AGENDA)
   (CL:SETQ QUERY
    (CREATE-QUERY-ITERATOR DESCRIPTION EXTERNALVECTOR ATOMICSINGLETONS?))
   (CL:WHEN (CL:NOT (CL:EQ OPTIONS NIL))
    (PROCESS-QUERY-OPTIONS QUERY OPTIONS))
   QUERY))

;;; (DEFUN PROCESS-QUERY-OPTIONS ...)

(CL:DEFUN PROCESS-QUERY-OPTIONS (QUERY OPTIONS)
  (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
   (CL:SETF (%THE-PLIST SELF-000) OPTIONS)
   (CL:LET*
    ((PLIST
      (VET-OPTIONS SELF-000
       (GET-QUOTED-TREE
        "((:TIMEOUT :SINGLETONS? :DONT-OPTIMIZE?) \"/LOGIC\")"
        "/LOGIC"))))
    (CL:LET* ((VALUE NULL) (KEY NULL) (ITER-000 (%THE-PLIST PLIST)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ KEY (%%VALUE ITER-000))
      (CL:PROGN (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
       (CL:SETQ ITER-000 (%%REST (%%REST ITER-000))))
      (CL:LET* ((TEST-VALUE-000 KEY))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 KWD-QUERY-TIMEOUT)
         (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE VALUE)))
          (CL:COND
           ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
            (CL:PROGN
             (CL:SETF (%ALLOTTED-TIME QUERY)
              (CL:FLOAT (%WRAPPER-VALUE VALUE) 0.0d0))))
           ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
            (CL:PROGN
             (CL:SETF (%ALLOTTED-TIME QUERY) (%WRAPPER-VALUE VALUE))))
           (CL:T
            (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
             (CL:LET* ((*PRINTREADABLY?* TRUE))
              (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
              (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
               "PARSING ERROR: Illegal timeout value: `" VALUE "'." EOL)
              (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-QUERY-ERROR))
             (CL:ERROR
              (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))))
         (CL:SETF (%TIMEOUT? QUERY) FALSE))
        ((CL:EQ TEST-VALUE-000 KWD-QUERY-SINGLETONS?))
        ((CL:EQ TEST-VALUE-000 KWD-QUERY-DONT-OPTIMIZE?)
         (CL:WHEN (CL:EQ (COERCE-TO-BOOLEAN VALUE) TRUE-WRAPPER)
          (CL:LET*
           ((BASECONTROLFRAME (%BASE-CONTROL-FRAME QUERY))
            (PATTERNRECORD (%PATTERN-RECORD BASECONTROLFRAME))
            (DESCRIPTION (%DESCRIPTION PATTERNRECORD)))
           (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS DESCRIPTION)
            SYM-QUERY-LOGIC-DONT-OPTIMIZE?
            (CL:IF TRUE TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
           (CL:SETF (%QUERY-PATTERNS DESCRIPTION) NULL)
           (CL:LET*
            ((*QUERYITERATOR* QUERY)
             (*EVALUATIONMODE* KWD-QUERY-DESCRIPTION))
            (CL:DECLARE (CL:SPECIAL *QUERYITERATOR* *EVALUATIONMODE*))
            (CL:SETF (%DOWN BASECONTROLFRAME) NULL)
            (CL:LET*
             ((*CONTEXT* (GET-QUERY-CONTEXT))
              (*MODULE* (%BASE-MODULE *CONTEXT*)))
             (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
             (OVERLAY-WITH-PATTERN-FRAME? BASECONTROLFRAME DESCRIPTION
              (%EXTERNAL-ARGUMENTS PATTERNRECORD)))))))
        (CL:T
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (CL:LET* ((*PRINTREADABLY?* TRUE))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
            "PARSING ERROR: Illegal query option: `" KEY "'." EOL)
           (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-QUERY-ERROR))
          (CL:ERROR
           (NEW-PARSING-ERROR (THE-STRING-READER STREAM-001))))))))))))

;;; (DEFUN (RUN-YES-OR-NO-QUERY? THREE-VALUED-BOOLEAN) ...)

(CL:DEFUN RUN-YES-OR-NO-QUERY? (QUERYITERATOR)
  (CL:LET* ((*QUERYITERATOR* QUERYITERATOR) (*REVERSEPOLARITY?* FALSE))
   (CL:DECLARE (CL:SPECIAL *QUERYITERATOR* *REVERSEPOLARITY?*))
   (CL:WHEN (CL:EQ *MOST-RECENT-QUERY* NULL)
    (CL:SETQ *MOST-RECENT-QUERY* QUERYITERATOR))
   (CL:WHEN (NEXT? QUERYITERATOR) (RELEASE-QUERY-THREAD QUERYITERATOR)
    (CL:SETF (%QUERY-THREAD-OFFSET QUERYITERATOR) NULL-INTEGER)
    (CL:RETURN-FROM RUN-YES-OR-NO-QUERY?
     (CL:IF TRUE TRUE-WRAPPER FALSE-WRAPPER))))
  NULL)

;;; (DEFUN (COERCE-TO-TREE OBJECT) ...)

(CL:DEFUN COERCE-TO-TREE (SELF)
  (CL:COND
   ((SUBTYPE-OF-STRING? (SAFE-PRIMARY-TYPE SELF))
    (CL:PROGN (READ-S-EXPRESSION-FROM-STRING (%WRAPPER-VALUE SELF))))
   (CL:T SELF)))

;;; (DEFUN (COERCE-TO-STRING STRING) ...)

(CL:DEFUN COERCE-TO-STRING (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-STRING? TEST-VALUE-000) (CL:PROGN (%WRAPPER-VALUE SELF)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000) (CL:PROGN (%SYMBOL-NAME SELF)))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000) (CL:PROGN (%SYMBOL-NAME SELF)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (%SYMBOL-NAME SELF)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Can't convert `" SELF
       "' into a string." EOL)
      (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (ASK THREE-VALUED-BOOLEAN) ...)

(CL:DEFUN %ASK (|PROPOSITION&OPTIONS|)
  "Perform inference to determine whether `proposition' is true.
Return TRUE if `proposition' was found to be true; return NULL otherwise.
KIF example: `(ask (happy Fred))' will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic constant
`Fred' and the relation (or slot) `happy' must already be defined (see
`assert').  Use `(set/unset-feature goal-trace)' to en/disable goal tracing
of the inference engine."
  (CL:HANDLER-CASE
   (CL:LET*
    ((QUERYARGS |PROPOSITION&OPTIONS|)
     (TREE (COERCE-TO-TREE (%%VALUE QUERYARGS)))
     (OPTIONS (%%REST QUERYARGS)))
    (CL:SETQ *MOST-RECENT-QUERY* NULL)
    (CL:IF (CL:NOT (CL:EQ TREE NULL))
     (CL:RETURN-FROM %ASK
      (RUN-YES-OR-NO-QUERY? (MAKE-QUERY NIL TREE NIL OPTIONS)))
     (CL:RETURN-FROM %ASK NULL)))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))))
  NULL)

(CL:DEFUN ASK-EVALUATOR-WRAPPER (ARGUMENTS)
  (%ASK ARGUMENTS))

(CL:DEFMACRO ASK (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Perform inference to determine whether `proposition' is true.
Return TRUE if `proposition' was found to be true; return NULL otherwise.
KIF example: `(ask (happy Fred))' will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic constant
`Fred' and the relation (or slot) `happy' must already be defined (see
`assert').  Use `(set/unset-feature goal-trace)' to en/disable goal tracing
of the inference engine."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/ASK)) (CL:MACRO-FUNCTION (CL:QUOTE ASK)))

;;; (DEFUN (RETRIEVE-BINDINGS QUERY-ITERATOR) ...)

(CL:DEFUN RETRIEVE-BINDINGS (QUERY NOFBINDINGS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NOFBINDINGS))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE QUERY)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-QUERY-ITERATOR)
     (CL:PROGN (QUERY-ITERATOR.RETRIEVE-BINDINGS QUERY NOFBINDINGS)))
    ((CL:EQ TEST-VALUE-000 SGT-QUERY-STELLA-CONS)
     (CL:PROGN (CONS.RETRIEVE-BINDINGS QUERY NOFBINDINGS)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (QUERY-ITERATOR.RETRIEVE-BINDINGS QUERY-ITERATOR) ...)

(CL:DEFUN QUERY-ITERATOR.RETRIEVE-BINDINGS (QUERY NOFBINDINGS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NOFBINDINGS))
  (CL:LET* ((*QUERYITERATOR* QUERY) (*REVERSEPOLARITY?* FALSE))
   (CL:DECLARE (CL:SPECIAL *QUERYITERATOR* *REVERSEPOLARITY?*))
   (CL:LET*
    ((SOLUTION NULL) (I NULL-INTEGER) (ITER-000 1)
     (UPPER-BOUND-000 NOFBINDINGS)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)) (ITER-001 QUERY))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE
     (CL:AND (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000))
      (NEXT? ITER-001))
     DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:SETQ SOLUTION (%VALUE ITER-001))
     (CL:PROGN (CL:SETQ SOLUTION SOLUTION) (CL:SETQ I I))))
   QUERY))

;;; (DEFUN (CONS.RETRIEVE-BINDINGS QUERY-ITERATOR) ...)

(CL:DEFUN CONS.RETRIEVE-BINDINGS (QUERY NOFBINDINGS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NOFBINDINGS))
  (CL:WHEN (CL:AND (CL:= (LENGTH QUERY) 1) (STRING? (%%VALUE QUERY)))
   (CL:SETQ QUERY (COERCE-TO-TREE (%%VALUE QUERY))))
  (RETRIEVE-BINDINGS
   (MAKE-QUERY (%%VALUE QUERY) (%%VALUE (%%REST QUERY)) NIL
    (%%REST (%%REST QUERY)))
   NOFBINDINGS))

;;; (DEFGLOBAL *MOST-RECENT-QUERY* ...)

(CL:DEFVAR *MOST-RECENT-QUERY* NULL)

;;; (DEFUN (RETRIEVE QUERY-ITERATOR) ...)

(CL:DEFUN %RETRIEVE (QUERY)
  "Retrieve elements of a relation (tuples) that satisfy a proposition.
The accepted syntax is:
	 
  (retrieve [<integer> | all]
            [{<variable-spec> | (<variable-spec>+)}
             [<proposition>]])
	
The variables and proposition are similar to an `exists' sentence or
`kappa' term without the quantifier.  <proposition> usually contains
references to the listed variables.  No other free variable references
are allowed.  If <proposition> is omitted, it defaults to TRUE.  

A solution is a set of bindings for the listed variables for which
<proposition> is true.  The optional first argument controls how many
solutions should be generated before control is returned.  The keyword
`all' indicates that all solutions should be generated.  By default,
`retrieve' returns after it has found one new solution or if it cannot
find any more solutions.

`retrieve' returns an iterator which saves all the necessary state of
a query and stores all generated solutions.  When used interactively,
the returned iterator will print out with the set of solutions collected
so far.  Calling `retrieve' without any arguments (or only with the first
argument) will generate one (or more) solutions to the most recently
asked query.

KIF examples:
	 
  (retrieve (?x Person) (happy ?x)) 
	
will try to find the next happy person and store it in the returned 
query iterator.
	 
  (retrieve 10 (?x Person) (happy ?x))
	
will try to find 10 happy people.
	 
  (retrieve 10)
	
will try to find the next 10 happy people.
	 
  (retrieve all (?x Person) (happy ?x))
	
will find all happy people.
	 
  (retrieve all (?x Person))
	
will find all people.
	 
  (retrieve (?x Person) (or (happy ?x) (parent-of Fred ?x)))
	
will try to find the next person that is happy or has Fred as a parent.
	 
  (retrieve ((?x Person) (?y Person)) (parent-of ?x ?y))
	
will try to find the next pair of parent/child.
	 
  (retrieve all (?x Person)
            (exists (?y Person) (parent-of ?x ?y)))
	
will generate the set of all parents.  Note, that for these queries to run,
the class `Person', the relations `happy' and `parent-of', and the logic
constant `Fred' must already be defined (see `assert').

Use `(set/unset-feature goal-trace)' to en/disable goal tracing of the
inference engine."
  (CL:LET*
   ((THEQUERY QUERY) (FIRSTARG (%%VALUE THEQUERY)) (NOFBINDINGS 1))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFBINDINGS))
   (CL:WHEN (CL:NOT (CL:EQ FIRSTARG NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE FIRSTARG)))
     (CL:COND
      ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
       (CL:PROGN (CL:SETQ NOFBINDINGS (%WRAPPER-VALUE FIRSTARG))
        (CL:SETQ THEQUERY (%%REST THEQUERY))))
      ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
       (CL:PROGN
        (CL:WHEN (STRING-EQL? (%SYMBOL-NAME FIRSTARG) "ALL")
         (CL:SETQ NOFBINDINGS NULL-INTEGER)
         (CL:SETQ THEQUERY (%%REST THEQUERY)))))
      ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
       (CL:PROGN
        (CL:WHEN (STRING-EQL? (%SYMBOL-NAME FIRSTARG) "ALL")
         (CL:SETQ NOFBINDINGS NULL-INTEGER)
         (CL:SETQ THEQUERY (%%REST THEQUERY)))))
      (CL:T))))
   (CL:HANDLER-CASE
    (CL:COND
     ((CL:AND (CL:NOT (CL:EQ *MOST-RECENT-QUERY* NULL))
       (CL:OR (CL:EQ THEQUERY NIL) (KEYWORD? (%%VALUE THEQUERY))))
      (PROCESS-QUERY-OPTIONS *MOST-RECENT-QUERY* THEQUERY)
      (CL:RETURN-FROM %RETRIEVE
       (RETRIEVE-BINDINGS *MOST-RECENT-QUERY* NOFBINDINGS)))
     (CL:T
      (CL:RETURN-FROM %RETRIEVE
       (CL:SETQ *MOST-RECENT-QUERY*
        (RETRIEVE-BINDINGS THEQUERY NOFBINDINGS)))))
    (LOGIC-EXCEPTION (E)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
      (EXCEPTION-MESSAGE E))))
   NULL))

(CL:DEFUN RETRIEVE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%RETRIEVE ARGUMENTS))

(CL:DEFMACRO RETRIEVE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Retrieve elements of a relation (tuples) that satisfy a proposition.
The accepted syntax is:
	 
  (retrieve [<integer> | all]
            [{<variable-spec> | (<variable-spec>+)}
             [<proposition>]])
	
The variables and proposition are similar to an `exists' sentence or
`kappa' term without the quantifier.  <proposition> usually contains
references to the listed variables.  No other free variable references
are allowed.  If <proposition> is omitted, it defaults to TRUE.  

A solution is a set of bindings for the listed variables for which
<proposition> is true.  The optional first argument controls how many
solutions should be generated before control is returned.  The keyword
`all' indicates that all solutions should be generated.  By default,
`retrieve' returns after it has found one new solution or if it cannot
find any more solutions.

`retrieve' returns an iterator which saves all the necessary state of
a query and stores all generated solutions.  When used interactively,
the returned iterator will print out with the set of solutions collected
so far.  Calling `retrieve' without any arguments (or only with the first
argument) will generate one (or more) solutions to the most recently
asked query.

KIF examples:
	 
  (retrieve (?x Person) (happy ?x)) 
	
will try to find the next happy person and store it in the returned 
query iterator.
	 
  (retrieve 10 (?x Person) (happy ?x))
	
will try to find 10 happy people.
	 
  (retrieve 10)
	
will try to find the next 10 happy people.
	 
  (retrieve all (?x Person) (happy ?x))
	
will find all happy people.
	 
  (retrieve all (?x Person))
	
will find all people.
	 
  (retrieve (?x Person) (or (happy ?x) (parent-of Fred ?x)))
	
will try to find the next person that is happy or has Fred as a parent.
	 
  (retrieve ((?x Person) (?y Person)) (parent-of ?x ?y))
	
will try to find the next pair of parent/child.
	 
  (retrieve all (?x Person)
            (exists (?y Person) (parent-of ?x ?y)))
	
will generate the set of all parents.  Note, that for these queries to run,
the class `Person', the relations `happy' and `parent-of', and the logic
constant `Fred' must already be defined (see `assert').

Use `(set/unset-feature goal-trace)' to en/disable goal tracing of the
inference engine."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/RETRIEVE)) (CL:MACRO-FUNCTION (CL:QUOTE RETRIEVE)))

;;; (DEFUN (CONSIFY-QUERY CONS) ...)

(CL:DEFUN CONSIFY-QUERY (SELF)
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM CONSIFY-QUERY NIL))
  (CL:LET*
   ((SOLUTIONS (%SOLUTIONS SELF)) (LISTIFIEDSOLUTIONS NIL) (ARITY 0)
    (ATOMICSINGLETONS? (%ATOMIC-SINGLETONS? SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
   (CL:LET* ((*QUERYITERATOR* SELF) (*REVERSEPOLARITY?* FALSE))
    (CL:DECLARE (CL:SPECIAL *QUERYITERATOR* *REVERSEPOLARITY?*))
    (CL:LOOP WHILE (NEXT? SELF)))
   (CL:WHEN (NON-EMPTY? SOLUTIONS)
    (CL:SETQ ARITY (LENGTH (FIRST SOLUTIONS))))
   (CL:LET*
    ((SOLUTION NULL) (ITER-000 (%THE-CONS-LIST SOLUTIONS))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ SOLUTION (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CL:IF (CL:AND ATOMICSINGLETONS? (CL:= ARITY 1))
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SOLUTION)) 0)
          (COPY-VECTOR-TO-CONS-LIST SOLUTION))
         NIL))
       (CL:IF (CL:EQ LISTIFIEDSOLUTIONS NIL)
        (CL:SETQ LISTIFIEDSOLUTIONS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST LISTIFIEDSOLUTIONS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CL:IF (CL:AND ATOMICSINGLETONS? (CL:= ARITY 1))
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SOLUTION)) 0)
          (COPY-VECTOR-TO-CONS-LIST SOLUTION))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   LISTIFIEDSOLUTIONS))

;;; (DEFMETHOD (LISTIFY LIST) ...)

(CL:DEFMETHOD LISTIFY ((SELF QUERY-ITERATOR))
  "Return the list of tuples generated by 'self'.
Tuples of arity=1 are represented directly by the first element,
tuples of arity>1 are represented by a CONS list."
  (CL:LET* ((SELF-000 (NEW-LIST)))
   (CL:SETF (%THE-CONS-LIST SELF-000) (CONSIFY-QUERY SELF))
   (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))

;;; (DEFGLOBAL *QUERY-CACHE* ...)

(CL:DEFVAR *QUERY-CACHE* NULL
  "Caches in-line queries, so that they
don't have to be reparsed and reoptimized each time they
are invoked.")

;;; (DEFUN FLUSH-INLINE-QUERY-CACHES ...)

(CL:DEFUN FLUSH-INLINE-QUERY-CACHES ()
  (CL:SETQ *QUERY-CACHE* (NEW-HASH-TABLE)))

;;; (DEFUN (MAKE-CACHED-QUERY QUERY-ITERATOR) ...)

(CL:DEFUN MAKE-CACHED-QUERY (VARIABLES QUERYBODY INPUTBINDINGS OPTIONS CACHEID)
  (CL:LET*
   ((QUERYITERATOR (LOOKUP *QUERY-CACHE* CACHEID)) (BINDINGSCOUNT 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM BINDINGSCOUNT))
   (CL:WHEN (CL:NOT (CL:= (LENGTH VARIABLES) (LENGTH INPUTBINDINGS)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "Number of variables does not equal number of input bindings." EOL)
    (CL:RETURN-FROM MAKE-CACHED-QUERY NULL))
   (CL:LET* ((IT (ALLOCATE-ITERATOR INPUTBINDINGS)))
    (CL:LOOP WHILE (NEXT? IT) DO
     (CL:WHEN (CL:NOT (CL:EQ (%VALUE IT) NULL))
      (VALUE-SETTER IT (VALUE-OF (%VALUE IT)))
      (CL:SETQ BINDINGSCOUNT (CL:1+ BINDINGSCOUNT)))))
   (CL:WHEN (CL:NOT (CL:EQ QUERYITERATOR NULL))
    (CL:LET*
     ((NEWB NULL) (OLDB NULL)
      (VECTOR-000
       (%VARIABLE-BINDINGS (%CURRENT-PATTERN-RECORD QUERYITERATOR)))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
      (ITER-000 INPUTBINDINGS))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:NOT (CL:EQ ITER-000 NIL)))
      DO
      (CL:PROGN
       (CL:SETQ OLDB
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
      (CL:PROGN (CL:SETQ NEWB (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (CL:WHEN (CL:NOT (CL:EQ (CL:EQ OLDB NULL) (CL:EQ NEWB NULL)))
       (CL:SETQ QUERYITERATOR NULL)))))
   (CL:IF (CL:EQ QUERYITERATOR NULL)
    (CL:PROGN
     (CL:HANDLER-CASE
      (CL:PROGN (CL:SETQ VARIABLES (COPY-CONS-LIST VARIABLES))
       (CL:SETQ QUERYBODY (COPY-CONS-TREE QUERYBODY))
       (CL:SETQ QUERYITERATOR
        (MAKE-QUERY VARIABLES QUERYBODY INPUTBINDINGS OPTIONS)))
      (LOGIC-EXCEPTION (E)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
        (EXCEPTION-MESSAGE E))
       (CL:RETURN-FROM MAKE-CACHED-QUERY NULL)))
     (CL:WHEN (CL:NOT (CL:EQ CACHEID NULL))
      (INSERT-AT *QUERY-CACHE* CACHEID QUERYITERATOR)))
    (CL:LET*
     ((*QUERYITERATOR* QUERYITERATOR) (*CONTEXT* (GET-QUERY-CONTEXT)))
     (CL:DECLARE (CL:SPECIAL *QUERYITERATOR* *CONTEXT*))
     (RESET QUERYITERATOR)
     (UNBIND-VARIABLES-BEGINNING-AT
      (%CURRENT-PATTERN-RECORD QUERYITERATOR) 0)
     (CL:WHEN (CL:> BINDINGSCOUNT 0)
      (CL:LET* ((EXTERNALVARIABLES (%EXTERNAL-VARIABLES QUERYITERATOR)))
       (CL:LET*
        ((VALUE NULL) (ARG NULL) (VECTOR-001 EXTERNALVARIABLES)
         (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001))
         (ITER-001 INPUTBINDINGS))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
        (CL:LOOP WHILE
         (CL:AND (CL:< INDEX-001 LENGTH-001)
          (CL:NOT (CL:EQ ITER-001 NIL)))
         DO
         (CL:PROGN
          (CL:SETQ ARG
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
            INDEX-001))
          (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
         (CL:PROGN (CL:SETQ VALUE (%%VALUE ITER-001))
          (CL:SETQ ITER-001 (%%REST ITER-001)))
         (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
          (CL:WHEN (CL:NOT (BIND-ARGUMENT-TO-VALUE? ARG VALUE FALSE))
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
            "Query failure: Can't bind `" VALUE "' to `" ARG "'." EOL EOL)
           (CL:RETURN-FROM MAKE-CACHED-QUERY NULL)))))))))
   (CL:WHEN (CL:NOT (CL:EQ OPTIONS NIL))
    (PROCESS-QUERY-OPTIONS QUERYITERATOR OPTIONS))
   QUERYITERATOR))

;;; (DEFUN (APPLY-CACHED-RETRIEVE CONS CONS) ...)

(CL:DEFUN APPLY-CACHED-RETRIEVE (VARIABLES QUERYBODY INPUTBINDINGS OPTIONS CACHEID)
  (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
   (CL:SETF (%THE-PLIST SELF-000) OPTIONS)
   (CL:LET*
    ((THEOPTIONS
      (VET-OPTIONS SELF-000
       (GET-QUOTED-TREE "((:SINGLETONS?) \"/LOGIC\")" "/LOGIC")))
     (QUERYITERATOR NULL) (BINDINGSCOUNT 0) (OUTPUTBINDINGS NIL)
     (FORCESINGLETONS? FALSE))
    (CL:DECLARE (CL:TYPE CL:FIXNUM BINDINGSCOUNT))
    (CL:LET* ((IT (ALLOCATE-ITERATOR INPUTBINDINGS)))
     (CL:LOOP WHILE (NEXT? IT) DO
      (CL:WHEN (CL:NOT (CL:EQ (%VALUE IT) NULL))
       (CL:SETQ BINDINGSCOUNT (CL:1+ BINDINGSCOUNT)))))
    (CL:SETQ QUERYITERATOR
     (MAKE-CACHED-QUERY VARIABLES QUERYBODY INPUTBINDINGS OPTIONS
      CACHEID))
    (CL:WHEN (CL:EQ QUERYITERATOR NULL)
     (CL:RETURN-FROM APPLY-CACHED-RETRIEVE (CL:VALUES NIL NIL)))
    (CL:LET*
     ((VALUE NULL) (KEYWORD NULL) (ITER-000 (%THE-PLIST THEOPTIONS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ KEYWORD (%%VALUE ITER-000))
      (CL:PROGN (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
       (CL:SETQ ITER-000 (%%REST (%%REST ITER-000))))
      (CL:COND
       ((CL:EQ KEYWORD KWD-QUERY-SINGLETONS?)
        (CL:SETQ FORCESINGLETONS?
         (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE)))
       (CL:T
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KEYWORD
          "' is not a valid case option")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
    (CL:LET* ((*QUERYITERATOR* QUERYITERATOR) (*REVERSEPOLARITY?* FALSE))
     (CL:DECLARE (CL:SPECIAL *QUERYITERATOR* *REVERSEPOLARITY?*))
     (CL:LOOP WHILE (NEXT? QUERYITERATOR)))
    (CL:LET*
     ((TUPLE NULL)
      (ATOMICSINGLETONS?
       (CL:AND (CL:= (LENGTH INPUTBINDINGS) (CL:1+ BINDINGSCOUNT))
        (CL:NOT FORCESINGLETONS?))))
     (CL:LET*
      ((S NULL) (ITER-001 (%THE-CONS-LIST (%SOLUTIONS QUERYITERATOR)))
       (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:PROGN (CL:SETQ S (%%VALUE ITER-001))
        (CL:SETQ ITER-001 (%%REST ITER-001)))
       (CL:IF ATOMICSINGLETONS?
        (CL:LET*
         ((B NULL) (V NULL) (VECTOR-000 S) (INDEX-000 0)
          (LENGTH-000 (LENGTH VECTOR-000)) (ITER-002 INPUTBINDINGS))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE
          (CL:AND (CL:< INDEX-000 LENGTH-000)
           (CL:NOT (CL:EQ ITER-002 NIL)))
          DO
          (CL:PROGN
           (CL:SETQ V
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
             INDEX-000))
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
          (CL:PROGN (CL:SETQ B (%%VALUE ITER-002))
           (CL:SETQ ITER-002 (%%REST ITER-002)))
          (CL:WHEN (CL:EQ B NULL) (CL:SETQ TUPLE V))))
        (CL:LET* ((VALUES NIL))
         (CL:LET*
          ((B NULL) (V NULL) (VECTOR-001 S) (INDEX-001 0)
           (LENGTH-001 (LENGTH VECTOR-001)) (ITER-003 INPUTBINDINGS)
           (COLLECT-001 NULL))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
          (CL:LOOP WHILE
           (CL:AND (CL:< INDEX-001 LENGTH-001)
            (CL:NOT (CL:EQ ITER-003 NIL)))
           DO
           (CL:PROGN
            (CL:SETQ V
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
              INDEX-001))
            (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
           (CL:PROGN (CL:SETQ B (%%VALUE ITER-003))
            (CL:SETQ ITER-003 (%%REST ITER-003)))
           (CL:WHEN (CL:EQ B NULL)
            (CL:IF (CL:EQ COLLECT-001 NULL)
             (CL:PROGN (CL:SETQ COLLECT-001 (CONS V NIL))
              (CL:IF (CL:EQ VALUES NIL) (CL:SETQ VALUES COLLECT-001)
               (ADD-CONS-TO-END-OF-CONS-LIST VALUES COLLECT-001)))
             (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS V NIL))
              (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))))
         (CL:SETQ TUPLE VALUES)))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS TUPLE NIL))
         (CL:IF (CL:EQ OUTPUTBINDINGS NIL)
          (CL:SETQ OUTPUTBINDINGS COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST OUTPUTBINDINGS COLLECT-000)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS TUPLE NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
    (CL:VALUES OUTPUTBINDINGS
     (%THE-CONS-LIST (%TRUTH-VALUES QUERYITERATOR))))))

;;; (DEFUN (APPLY-CACHED-ASK BOOLEAN TRUTH-VALUE) ...)

(CL:DEFUN APPLY-CACHED-ASK (INPUTVARIABLES QUERYBODY INPUTBINDINGS OPTIONS CACHEID)
  (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
   (CL:SETF (%THE-PLIST SELF-000) OPTIONS)
   (CL:LET*
    ((THEOPTIONS SELF-000)
     (QUERYITERATOR
      (MAKE-CACHED-QUERY INPUTVARIABLES QUERYBODY INPUTBINDINGS OPTIONS
       CACHEID))
     (RESULT? FALSE))
    (CL:SETQ THEOPTIONS THEOPTIONS)
    (CL:WHEN (CL:EQ QUERYITERATOR NULL)
     (CL:RETURN-FROM APPLY-CACHED-ASK (CL:VALUES FALSE NULL)))
    (CL:SETQ RESULT?
     (CL:NOT (CL:EQ (RUN-YES-OR-NO-QUERY? QUERYITERATOR) NULL)))
    (CL:VALUES RESULT? (FIRST (%TRUTH-VALUES QUERYITERATOR))))))

;;; (DEFUN (GET-PROTOTYPE LOGIC-OBJECT) ...)

(CL:DEFUN GET-PROTOTYPE (DESCRIPTION)
  (CL:WHEN (CL:EQ DESCRIPTION NULL) (CL:RETURN-FROM GET-PROTOTYPE NULL))
  (CL:LET*
   ((PROTOTYPE
     (ACCESS-BINARY-VALUE DESCRIPTION
      SGT-QUERY-PL-KERNEL-KB-CLASS-PROTOTYPE)))
   (CL:WHEN (CL:EQ PROTOTYPE NULL)
    (CL:SETQ PROTOTYPE
     (%%VALUE
      (APPLY-CACHED-RETRIEVE
       (LIST* SYM-QUERY-LOGIC-?C SYM-QUERY-LOGIC-?P NIL)
       (LIST* SYM-QUERY-PL-KERNEL-KB-CLASS-PROTOTYPE SYM-QUERY-LOGIC-?C
        SYM-QUERY-LOGIC-?P NIL)
       (CONS-LIST DESCRIPTION NULL) (CONS-LIST)
       SYM-QUERY-LOGIC-QUERY-065))))
   (CL:LET*
    ((*EVALUATIONMODE* KWD-QUERY-EXTENSIONAL-ASSERTION)
     (*QUERYITERATOR* NULL))
    (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE* *QUERYITERATOR*))
    (ELABORATE-META-INSTANCE PROTOTYPE) PROTOTYPE)))

;;; (DEFUN (UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION? (SUB SUPER)
  (CL:WHEN (DESCRIPTION-IMPLIES-DESCRIPTION? SUB SUPER)
   (CL:RETURN-FROM UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION? TRUE))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
    "Prototype Subsumption Test:" EOL "   sub= " SUB EOL "   super= "
    SUPER EOL))
  (CL:HANDLER-CASE
   (CL:LET* ((*CONTEXT* (GET-INFERENCE-CACHE *MODULE* KWD-QUERY-META)))
    (CL:DECLARE (CL:SPECIAL *CONTEXT*))
    (CL:LET* ((SUBPROTOTYPE (GET-PROTOTYPE SUB)) (QUERYITERATOR NULL))
     (CL:SETQ QUERYITERATOR
      (CREATE-QUERY-ITERATOR SUPER
       (COPY-LIST-TO-ARGUMENTS-VECTOR (LIST SUBPROTOTYPE)) FALSE))
     (CL:RETURN-FROM UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION?
      (CL:NOT (CL:EQ (RUN-YES-OR-NO-QUERY? QUERYITERATOR) NULL)))))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))))
  FALSE)

;;; (DEFUN (DESCRIPTION-SPECIALIZES-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN DESCRIPTION-SPECIALIZES-DESCRIPTION? (SUBDESCRIPTION SUPERDESCRIPTION)
  (CL:WHEN
   (DESCRIPTION-IMPLIES-DESCRIPTION? SUBDESCRIPTION SUPERDESCRIPTION)
   (CL:RETURN-FROM DESCRIPTION-SPECIALIZES-DESCRIPTION? TRUE))
  (CL:WHEN (CL:= (ARITY SUPERDESCRIPTION) 1)
   (CL:RETURN-FROM DESCRIPTION-SPECIALIZES-DESCRIPTION?
    (UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION? SUBDESCRIPTION
     SUPERDESCRIPTION)))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
    "Subsumption Test:" EOL))
  (CL:HANDLER-CASE
   (CL:LET*
    ((SKOLEMSLIST (NEW-LIST)) (SKOLEMSVECTOR NULL) (RESULT? FALSE))
    (PUSH-MONOTONIC-WORLD) (INITIALIZE-INFERENCE-WORLD *CONTEXT*)
    (CL:LET*
     ((V NULL) (VECTOR-000 (%IO-VARIABLES SUBDESCRIPTION)) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:PROGN
       (CL:SETQ V
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000
         (CONS (CREATE-HYPOTHESIZED-SKOLEM "ANONYMOUS") NIL))
        (CL:IF (CL:EQ (%THE-CONS-LIST SKOLEMSLIST) NIL)
         (CL:SETF (%THE-CONS-LIST SKOLEMSLIST) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST SKOLEMSLIST)
          COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS (CREATE-HYPOTHESIZED-SKOLEM "ANONYMOUS") NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
    (CL:SETQ SKOLEMSVECTOR (COPY-LIST-TO-ARGUMENTS-VECTOR SKOLEMSLIST))
    (INHERIT-DESCRIPTION SKOLEMSVECTOR SUBDESCRIPTION FALSE)
    (CL:LET*
     ((QUERYITERATOR
       (CREATE-QUERY-ITERATOR SUPERDESCRIPTION SKOLEMSVECTOR FALSE)))
     (CL:SETQ RESULT?
      (CL:NOT (CL:EQ (RUN-YES-OR-NO-QUERY? QUERYITERATOR) NULL))))
    (POP-WORLD)
    (CL:RETURN-FROM DESCRIPTION-SPECIALIZES-DESCRIPTION? RESULT?))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))))
  FALSE)

;;; (DEFUN (VECTOR-SATISFIES-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN VECTOR-SATISFIES-DESCRIPTION? (VECTOR DESCRIPTION)
  (CL:HANDLER-CASE
   (CL:LET* ((TEST-VALUE-000 FALSE))
    (CL:SETQ TEST-VALUE-000 (CL:= (LENGTH VECTOR) (ARITY DESCRIPTION)))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((ALWAYS?-000 TRUE))
      (CL:LET*
       ((VALUE NULL) (VECTOR-000 VECTOR) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:PROGN
         (CL:SETQ VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
        (CL:WHEN (CL:EQ VALUE NULL) (CL:SETQ ALWAYS?-000 FALSE)
         (CL:RETURN))))
      (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
     (CL:WHEN TEST-VALUE-000
      (CL:SETQ TEST-VALUE-000
       (CL:NOT
        (CL:EQ
         (RUN-YES-OR-NO-QUERY?
          (CREATE-QUERY-ITERATOR DESCRIPTION VECTOR FALSE))
         NULL)))))
    (CL:LET* ((VALUE-000 TEST-VALUE-000))
     (CL:RETURN-FROM VECTOR-SATISFIES-DESCRIPTION? VALUE-000)))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))))
  FALSE)

;;; (DEFUN (INSTANCE-SATISFIES-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN INSTANCE-SATISFIES-DESCRIPTION? (INSTANCE DESCRIPTION)
  (CL:LET* ((VECTOR (NEW-VECTOR 1)))
   (CL:LET ((SELF (%THE-ARRAY VECTOR)) (VALUE INSTANCE) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (VECTOR-SATISFIES-DESCRIPTION? VECTOR DESCRIPTION)))

;;; (DEFUN (COERCE-TO-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN COERCE-TO-DESCRIPTION (SELF ORIGINAL)
  (CL:WHEN (CL:EQ ORIGINAL NULL) (CL:SETQ ORIGINAL SELF))
  (CL:WHEN (CL:EQ SELF NULL)
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "Can't find a description for the object `" ORIGINAL "'." EOL)
   (CL:RETURN-FROM COERCE-TO-DESCRIPTION NULL))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-DESCRIPTION)
     (CL:PROGN SELF))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-RELATION)
     (CL:PROGN (GET-DESCRIPTION SELF)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (COERCE-TO-DESCRIPTION (%SURROGATE-VALUE SELF) ORIGINAL)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-DESCRIPTION
       (LOOKUP-SURROGATE-IN-MODULE (%SYMBOL-NAME SELF)
        (%HOME-CONTEXT SELF) FALSE)
       ORIGINAL)))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-DESCRIPTION (LOOKUP-SURROGATE (%SYMBOL-NAME SELF))
       ORIGINAL)))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-DESCRIPTION (LOOKUP-SURROGATE (%WRAPPER-VALUE SELF))
       ORIGINAL)))
    (CL:T (COERCE-TO-DESCRIPTION NULL ORIGINAL)))))

;;; (DEFUN (SPECIALIZES? BOOLEAN) ...)

(CL:DEFUN SPECIALIZES? (SUBOBJECT SUPEROBJECT)
  "Return TRUE if the description associated with `subObject'
specializes the description for `superObject'.  Return FALSE if we could
not prove that `subObject' specializes `superObject'."
  (CL:LET*
   ((SUBDESCRIPTION (COERCE-TO-DESCRIPTION SUBOBJECT NULL))
    (SUPERDESCRIPTION (COERCE-TO-DESCRIPTION SUPEROBJECT NULL)))
   (FINALIZE-RELATIONS)
   (CL:LET* ((*CONTEXT* (GET-INFERENCE-CACHE *MODULE* KWD-QUERY-META)))
    (CL:DECLARE (CL:SPECIAL *CONTEXT*))
    (CL:AND (CL:NOT (CL:EQ SUBDESCRIPTION NULL))
     (CL:NOT (CL:EQ SUPERDESCRIPTION NULL))
     (DESCRIPTION-SPECIALIZES-DESCRIPTION? SUBDESCRIPTION
      SUPERDESCRIPTION)))))

;;; (DEFUN (COERCE-TO-INSTANCE LOGIC-OBJECT) ...)

(CL:DEFUN COERCE-TO-INSTANCE (SELF ORIGINAL)
  (CL:WHEN (CL:EQ ORIGINAL NULL) (CL:SETQ ORIGINAL SELF))
  (CL:WHEN (CL:EQ SELF NULL)
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "Can't find a logic object `" ORIGINAL "'." EOL)
   (CL:RETURN-FROM COERCE-TO-INSTANCE NULL))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-LOGIC-LOGIC-OBJECT)
     (CL:PROGN SELF))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-RELATION)
     (CL:PROGN (GET-DESCRIPTION SELF)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (COERCE-TO-INSTANCE (%SURROGATE-VALUE SELF) ORIGINAL)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-INSTANCE
       (LOOKUP-SURROGATE-IN-MODULE (%SYMBOL-NAME SELF)
        (%HOME-CONTEXT SELF) FALSE)
       ORIGINAL)))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-INSTANCE (LOOKUP-SURROGATE (%SYMBOL-NAME SELF))
       ORIGINAL)))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (COERCE-TO-INSTANCE (LOOKUP-SURROGATE (%WRAPPER-VALUE SELF))
       ORIGINAL)))
    (CL:T (COERCE-TO-INSTANCE NULL ORIGINAL)))))

;;; (DEFUN (COERCE-TO-VECTOR VECTOR) ...)

(CL:DEFUN COERCE-TO-VECTOR (SELF)
  (CL:LET* ((VECTOR NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-VECTOR)
      (CL:PROGN (CL:SETQ VECTOR SELF)
       (CL:LET*
        ((I NULL-INTEGER) (M NULL) (VECTOR-000 SELF) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)) (ITER-000 0))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-000 I))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:PROGN
          (CL:SETQ M
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
         (CL:PROGN (CL:SETQ I ITER-000)
          (CL:SETQ ITER-000 (CL:1+ ITER-000)))
         (CL:LET
          ((SELF (%THE-ARRAY VECTOR)) (VALUE (COERCE-TO-INSTANCE M NULL))
           (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-QUERY-STELLA-LIST)
      (CL:PROGN (CL:SETQ VECTOR (NEW-VECTOR (LENGTH SELF)))
       (CL:LET*
        ((I NULL-INTEGER) (M NULL) (ITER-001 (%THE-CONS-LIST SELF))
         (ITER-002 0))
        (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-002 I))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:PROGN (CL:SETQ M (%%VALUE ITER-001))
          (CL:SETQ ITER-001 (%%REST ITER-001)))
         (CL:PROGN (CL:SETQ I ITER-002)
          (CL:SETQ ITER-002 (CL:1+ ITER-002)))
         (CL:LET
          ((SELF (%THE-ARRAY VECTOR)) (VALUE (COERCE-TO-INSTANCE M NULL))
           (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))))))
     ((CL:EQ TEST-VALUE-000 SGT-QUERY-STELLA-CONS)
      (CL:PROGN (CL:SETQ VECTOR (NEW-VECTOR (LENGTH SELF)))
       (CL:LET* ((I NULL-INTEGER) (M NULL) (ITER-003 SELF) (ITER-004 0))
        (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-004 I))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
         (CL:PROGN (CL:SETQ M (%%VALUE ITER-003))
          (CL:SETQ ITER-003 (%%REST ITER-003)))
         (CL:PROGN (CL:SETQ I ITER-004)
          (CL:SETQ ITER-004 (CL:1+ ITER-004)))
         (CL:LET
          ((SELF (%THE-ARRAY VECTOR)) (VALUE (COERCE-TO-INSTANCE M NULL))
           (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))))))
     (CL:T
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "Don't know how to coerce `" SELF "' of type `" (PRIMARY-TYPE SELF)
       "'" EOL "   into a vector." EOL))))
   VECTOR))

;;; (DEFUN (SATISFIES? BOOLEAN) ...)

(CL:DEFUN SATISFIES? (INSTANCEORTUPLE RELATIONREF)
  "Return TRUE if `instanceOrTuple' satisfies the
definition of the relation `relationRef'.  `instanceOrTuple' can be a single
object, the name or surrogate of an object, or a collection (a list or vector)
of objects. `relationRef' can be a relation, description, surrogate or relation
name.  Return FALSE if we could not prove that `instanceOrTuple' satisfies
`relationRef'."
  (CL:LET* ((DESCRIPTION (COERCE-TO-DESCRIPTION RELATIONREF NULL)))
   (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL)) (FINALIZE-RELATIONS)
    (CL:LET*
     ((*CONTEXT* (GET-QUERY-CONTEXT)) (*MODULE* (%BASE-MODULE *CONTEXT*)))
     (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
     (CL:IF
      (CL:OR (ISA? INSTANCEORTUPLE SGT-QUERY-STELLA-COLLECTION)
       (CONS? INSTANCEORTUPLE))
      (CL:LET* ((VECTOR (COERCE-TO-VECTOR INSTANCEORTUPLE)))
       (CL:RETURN-FROM SATISFIES?
        (CL:AND (CL:NOT (CL:EQ VECTOR NULL))
         (VECTOR-SATISFIES-DESCRIPTION? VECTOR DESCRIPTION))))
      (CL:LET* ((INSTANCE (COERCE-TO-INSTANCE INSTANCEORTUPLE NULL)))
       (CL:RETURN-FROM SATISFIES?
        (CL:AND (CL:NOT (CL:EQ INSTANCE NULL))
         (INSTANCE-SATISFIES-DESCRIPTION? INSTANCE DESCRIPTION)))))))
   FALSE))

;;; (DEFUN (APPLY-KAPPA? BOOLEAN) ...)

(CL:DEFUN APPLY-KAPPA? (DESCRIPTION VECTOR)
  "Apply (inherit) the description 'description'
to members of the vector 'vector'.  Return TRUE if no clash was detected.
Constraint propagation happens only if it is enabled prior to calling
'apply-kappa?'."
  (CL:HANDLER-CASE (INHERIT-UNNAMED-DESCRIPTION VECTOR DESCRIPTION FALSE)
   (CLASH (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) (EXCEPTION-MESSAGE E))
    (CL:RETURN-FROM APPLY-KAPPA? FALSE)))
  TRUE)

;;; (DEFUN (DISPLAY-SETTINGS STRING) ...)

(CL:DEFUN DISPLAY-SETTINGS ()
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
   "*LAZY-SATELLITE-RULES?* =  " *LAZY-SATELLITE-RULES?* EOL
   "*INFERABLE-CACHE-ENABLED?* =  " *INFERABLE-CACHE-ENABLED?* EOL
   "*DISJOINTNESS-CACHE-ENABLED?* =  " *DISJOINTNESS-CACHE-ENABLED?* EOL
   "*CACHE-SUCCEEDED-GOALS?* =  " *CACHE-SUCCEEDED-GOALS?* EOL
   "*CACHE-FAILED-GOALS?* =  " *CACHE-FAILED-GOALS?* EOL
   "*CACHE-GOAL-QUANTUM* =  " *CACHE-GOAL-QUANTUM* EOL
   "*CACHE-INFERABLE-SUBCOLLECTIONS?* =  "
   *CACHE-INFERABLE-SUBCOLLECTIONS?* EOL "*INFERENCELEVEL* =  "
   *INFERENCELEVEL* EOL "*MAXIMUM-BACKTRACKING-DEPTH* =  "
   *MAXIMUM-BACKTRACKING-DEPTH* EOL "*TYPE-CHECK-STRATEGY* =  "
   *TYPE-CHECK-STRATEGY* EOL "*DUPLICATE-SUBGOAL-STRATEGY* =  "
   *DUPLICATE-SUBGOAL-STRATEGY* EOL "*DUPLICATE-GOAL-SEARCH-DEPTH* =  "
   *DUPLICATE-GOAL-SEARCH-DEPTH* EOL "*DUPLICATE-RULE-SEARCH-DEPTH* =  "
   *DUPLICATE-RULE-SEARCH-DEPTH* EOL "*GLOBALLY-CLOSED-COLLECTIONS?* =  "
   *GLOBALLY-CLOSED-COLLECTIONS?* EOL "*DEFAULT-MAXIMUM-DEPTH* =  "
   *DEFAULT-MAXIMUM-DEPTH* EOL "*INITIAL-BACKTRACKING-DEPTH* =  "
   *INITIAL-BACKTRACKING-DEPTH* EOL "*ITERATIVE-DEEPENING-MODE?* =  "
   *ITERATIVE-DEEPENING-MODE?* EOL
   "*DUPLICATEINSTANCESCACHECROSSOVERPOINT* =  "
   *DUPLICATEINSTANCESCACHECROSSOVERPOINT* EOL "*LAST-DYNAMIC-CUTOFF* =  "
   *LAST-DYNAMIC-CUTOFF* EOL EOL)
  "")

(CL:DEFUN HELP-STARTUP-QUERY1 ()
  (CL:PROGN
   (CL:SETQ SGT-QUERY-LOGIC-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-LEVEL" NULL 1))
   (CL:SETQ SYM-QUERY-STELLA-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SGT-QUERY-LOGIC-NORMAL-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NORMAL-INFERENCE-LEVEL" NULL 1))
   (CL:SETQ SGT-QUERY-LOGIC-BACKTRACKING-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKTRACKING-INFERENCE-LEVEL" NULL
     1))
   (CL:SETQ SGT-QUERY-LOGIC-SUBSUMPTION-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-INFERENCE-LEVEL" NULL 1))
   (CL:SETQ SGT-QUERY-LOGIC-SHALLOW-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHALLOW-INFERENCE-LEVEL" NULL 1))
   (CL:SETQ SGT-QUERY-LOGIC-ASSERTION-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERTION-INFERENCE-LEVEL" NULL 1))
   (CL:SETQ SGT-QUERY-LOGIC-REFUTATION-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFUTATION-INFERENCE-LEVEL" NULL 1))
   (CL:SETQ KWD-QUERY-NORMAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NORMAL" NULL 2))
   (CL:SETQ KWD-QUERY-BACKTRACKING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKTRACKING" NULL 2))
   (CL:SETQ KWD-QUERY-SUBSUMPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION" NULL 2))
   (CL:SETQ KWD-QUERY-SHALLOW
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHALLOW" NULL 2))
   (CL:SETQ KWD-QUERY-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERTION" NULL 2))
   (CL:SETQ KWD-QUERY-REFUTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFUTATION" NULL 2))
   (CL:SETQ KWD-QUERY-LOOKUP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP" NULL 2))
   (CL:SETQ KWD-QUERY-DUPLICATE-GOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DUPLICATE-GOALS" NULL 2))
   (CL:SETQ KWD-QUERY-TRACE-SUBGOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRACE-SUBGOALS" NULL 2))
   (CL:SETQ KWD-QUERY-PROPAGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPAGATE" NULL 2))
   (CL:SETQ KWD-QUERY-STRATEGIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRATEGIES" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-COST-ESTIMATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COST-ESTIMATE" NULL 0))
   (CL:SETQ SGT-QUERY-LOGIC-QUERY-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-ITERATOR" NULL 1))
   (CL:SETQ SYM-QUERY-LOGIC-EXTERNAL-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTERNAL-VARIABLES" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-SOLUTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SOLUTIONS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-EXHAUSTED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXHAUSTED?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-NEGATED-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEGATED-QUERY" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ATOMIC-SINGLETONS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ATOMIC-SINGLETONS?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-QUERY-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-CONTEXT" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-BASE-CONTROL-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BASE-CONTROL-FRAME" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CURRENT-CONTROL-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-CONTROL-FRAME" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CURRENT-PATTERN-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-PATTERN-RECORD" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CURRENT-PARALLEL-THREAD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-PARALLEL-THREAD" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-PARTIAL-MATCH-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL-MATCH-STRATEGY" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CONTROL-FRAME-PRIORITY-QUEUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTROL-FRAME-PRIORITY-QUEUE" NULL
     0))
   (CL:SETQ SYM-QUERY-LOGIC-ITERATIVE-DEEPENING?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATIVE-DEEPENING?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CURRENT-DEPTH-CUTOFF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-DEPTH-CUTOFF" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-MAXIMUM-DEPTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAXIMUM-DEPTH" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-AUGMENTED-GOAL-CACHE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AUGMENTED-GOAL-CACHE?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ACTIVE-GOAL-CACHES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-GOAL-CACHES" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-TRIGGERED-DEPTH-CUTOFF?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRIGGERED-DEPTH-CUTOFF?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-FAILED-TO-FIND-DUPLICATE-SUBGOAL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILED-TO-FIND-DUPLICATE-SUBGOAL?"
     NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-FOUND-AT-LEAST-ONE-SOLUTION?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FOUND-AT-LEAST-ONE-SOLUTION?" NULL
     0))
   (CL:SETQ SYM-QUERY-LOGIC-QUERY-THREAD-OFFSET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-THREAD-OFFSET" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMESTAMP" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-LATEST-TOUCHED-DEFAULT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LATEST-TOUCHED-DEFAULT?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-TRUTH-VALUES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUES" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-LATEST-POSITIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LATEST-POSITIVE-SCORE" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-LATEST-PARTIAL-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LATEST-PARTIAL-SCORE" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-MATCH-SCORES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MATCH-SCORES" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-OPTIMIZER-GOAL-RECORDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTIMIZER-GOAL-RECORDS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-RESIDUE-GOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RESIDUE-GOALS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-BEST-GOAL-SEQUENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BEST-GOAL-SEQUENCE" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-BEST-COST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BEST-COST" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ALLOTTED-TIME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOTTED-TIME" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-TIMEOUT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMEOUT?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-GOAL-BINDINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-BINDINGS" NULL 0))
   (CL:SETQ SGT-QUERY-LOGIC-CONTROL-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTROL-FRAME" NULL 1))
   (CL:SETQ SYM-QUERY-STELLA-BAD?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BAD?"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-QUERY-STELLA-STATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STATE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-QUERY-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-REVERSE-POLARITY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REVERSE-POLARITY?" NULL 0))))

(CL:DEFUN HELP-STARTUP-QUERY2 ()
  (CL:PROGN
   (CL:SETQ SYM-QUERY-LOGIC-UP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWN" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ARGUMENT-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-CURSOR" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-PATTERN-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-RECORD" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-INHERITED-PATTERN-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INHERITED-PATTERN-RECORD" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CHOICE-POINT-UNBINDING-OFFSET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHOICE-POINT-UNBINDING-OFFSET" NULL
     0))
   (CL:SETQ SYM-QUERY-LOGIC-CURRENT-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-STRATEGY" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-NEXT-STRATEGIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEXT-STRATEGIES" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-HOLDS-BY-DEFAULT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS-BY-DEFAULT?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-PARTIAL-MATCH-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL-MATCH-FRAME" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-DEBUG-FRAME-ID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEBUG-FRAME-ID" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-DEBUG-DEPTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEBUG-DEPTH" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATIONS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATION" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CACHED-BINDINGS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHED-BINDINGS-ITERATOR" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-GOAL-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-CACHE" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-BINDINGS-COUNTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BINDINGS-COUNTER" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CACHED-SINGLE-VALUED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHED-SINGLE-VALUED?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-STARTING-CLOCK-TICKS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTING-CLOCK-TICKS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-DONT-CACHE-GOAL-FAILURE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-CACHE-GOAL-FAILURE?" NULL 0))
   (CL:SETQ SYM-QUERY-STELLA-DELETED-OBJECT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DELETED-OBJECT?"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SGT-QUERY-LOGIC-PARALLEL-THREAD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARALLEL-THREAD" NULL 1))
   (CL:SETQ SYM-QUERY-LOGIC-TOP-CONTROL-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOP-CONTROL-FRAME" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-HYPOTHETICAL-WORLD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HYPOTHETICAL-WORLD" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-VARIABLE-BINDINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-BINDINGS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-UNBINDING-STACK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBINDING-STACK" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-TOP-UNBINDING-STACK-OFFSET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOP-UNBINDING-STACK-OFFSET" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-PRIORITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIORITY" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-STATUS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STATUS" NULL 0))
   (CL:SETQ SGT-QUERY-LOGIC-PARALLEL-CONTROL-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARALLEL-CONTROL-FRAME" NULL 1))
   (CL:SETQ SYM-QUERY-LOGIC-CHILD-THREADS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHILD-THREADS" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-UNBOUND-VARIABLES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBOUND-VARIABLES?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-CURRENT-CHILD-THREAD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-CHILD-THREAD" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-SAVED-PARENT-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVED-PARENT-CONTEXT" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-SAVED-PARENT-PARALLEL-THREAD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVED-PARENT-PARALLEL-THREAD" NULL
     0))
   (CL:SETQ SGT-QUERY-LOGIC-CONTROL-FRAME-PRIORITY-QUEUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTROL-FRAME-PRIORITY-QUEUE" NULL
     1))
   (CL:SETQ SYM-QUERY-LOGIC-QUEUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUEUE" NULL 0))
   (CL:SETQ KWD-QUERY-UPCLASSIFY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UPCLASSIFY" NULL 2))
   (CL:SETQ KWD-QUERY-DOWNCLASSIFY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWNCLASSIFY" NULL 2))
   (CL:SETQ SGT-QUERY-LOGIC-PROOF-ADJUNCT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROOF-ADJUNCT" NULL 1))
   (CL:SETQ SGT-QUERY-LOGIC-PATTERN-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-RECORD" NULL 1))
   (CL:SETQ SYM-QUERY-LOGIC-CONTROL-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTROL-FRAME" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-EXTERNAL-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTERNAL-ARGUMENTS" NULL 0))
   (CL:SETQ SYM-QUERY-STELLA-BOOLEAN-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-VECTOR"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-QUERY-LOGIC-OPTIMAL-PATTERN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTIMAL-PATTERN" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-COLLECTION-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION-LIST" NULL 0))
   (CL:SETQ SGT-QUERY-LOGIC-BOOLEAN-VECTOR-INDEX-NODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-VECTOR-INDEX-NODE" NULL 1))
   (CL:SETQ SYM-QUERY-LOGIC-TRUE-LINK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE-LINK" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-FALSE-LINK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE-LINK" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-THE-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-VECTOR" NULL 0))
   (CL:SETQ SGT-QUERY-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ KWD-QUERY-PATTERN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN" NULL 2))
   (CL:SETQ KWD-QUERY-CONTAINED-BY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTAINED-BY" NULL 2))
   (CL:SETQ KWD-QUERY-PARENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT" NULL 2))
   (CL:SETQ KWD-QUERY-POPPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POPPED" NULL 2))
   (CL:SETQ KWD-QUERY-LOCAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOCAL" NULL 2))
   (CL:SETQ KWD-QUERY-QUERY-STACKS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-STACKS" NULL 2))
   (CL:SETQ SGT-QUERY-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SGT-QUERY-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))))

(CL:DEFUN HELP-STARTUP-QUERY3 ()
  (CL:PROGN
   (CL:SETQ SGT-QUERY-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ KWD-QUERY-NONE (INTERN-RIGID-SYMBOL-WRT-MODULE "NONE" NULL 2))
   (CL:SETQ KWD-QUERY-SHALLOW-DISJOINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHALLOW-DISJOINT" NULL 2))
   (CL:SETQ KWD-QUERY-DISJOINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISJOINT" NULL 2))
   (CL:SETQ KWD-QUERY-ISA (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ SGT-QUERY-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ KWD-QUERY-PERFORMANCE-CLUES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PERFORMANCE-CLUES" NULL 2))
   (CL:SETQ SYM-QUERY-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SGT-QUERY-STELLA-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-QUERY-STELLA-SURROGATE-VALUE-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE-INVERSE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-QUERY-LOGIC-MASTER-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
   (CL:SETQ KWD-QUERY-FLAT (INTERN-RIGID-SYMBOL-WRT-MODULE "FLAT" NULL 2))
   (CL:SETQ KWD-QUERY-REALISTIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REALISTIC" NULL 2))
   (CL:SETQ KWD-QUERY-DOWN (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWN" NULL 2))
   (CL:SETQ KWD-QUERY-ITERATIVE-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATIVE-FORALL" NULL 2))
   (CL:SETQ KWD-QUERY-STATE-MACHINE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STATE-MACHINE" NULL 2))
   (CL:SETQ KWD-QUERY-PARALLEL-STRATEGIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARALLEL-STRATEGIES" NULL 2))
   (CL:SETQ KWD-QUERY-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRATEGY" NULL 2))
   (CL:SETQ KWD-QUERY-SPECIALIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIALIST" NULL 2))
   (CL:SETQ KWD-QUERY-ATOMIC-GOAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ATOMIC-GOAL" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-ANTECEDENTS-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS-RULE" NULL 0))
   (CL:SETQ KWD-QUERY-UP-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TRUE" NULL 2))
   (CL:SETQ KWD-QUERY-UP-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-FAIL" NULL 2))
   (CL:SETQ KWD-QUERY-AND (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-QUERY-GOAL-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-TREE" NULL 2))
   (CL:SETQ KWD-QUERY-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-QUERY-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-QUERY-NOT (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-QUERY-FULL-SUBQUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULL-SUBQUERY" NULL 2))
   (CL:SETQ KWD-QUERY-ANTECEDENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS" NULL 2))
   (CL:SETQ SYM-QUERY-STELLA-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SGT-QUERY-LOGIC-NN-PARTIAL-MATCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NN-PARTIAL-MATCH" NULL 1))
   (CL:SETQ SYM-QUERY-LOGIC-MATCH-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MATCH-SCORE" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-SUPPORT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPPORT" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-BACK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACK" NULL 0))
   (CL:SETQ KWD-QUERY-TRUE (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 2))
   (CL:SETQ KWD-QUERY-FAIL (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ KWD-QUERY-MOVE-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MOVE-DOWN" NULL 2))
   (CL:SETQ KWD-QUERY-FINAL-SUCCESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINAL-SUCCESS" NULL 2))
   (CL:SETQ KWD-QUERY-CONTINUING-SUCCESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUING-SUCCESS" NULL 2))
   (CL:SETQ KWD-QUERY-FAILURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILURE" NULL 2))
   (CL:SETQ KWD-QUERY-MOVE-IN-PLACE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MOVE-IN-PLACE" NULL 2))
   (CL:SETQ KWD-QUERY-TIMEOUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMEOUT" NULL 2))
   (CL:SETQ KWD-QUERY-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-QUERY-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ KWD-QUERY-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ KWD-QUERY-SCAN-CACHED-BINDINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-CACHED-BINDINGS" NULL 2))
   (CL:SETQ KWD-QUERY-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ KWD-QUERY-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ KWD-QUERY-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 2))
   (CL:SETQ KWD-QUERY-CLUSTERED-CONJUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLUSTERED-CONJUNCTION" NULL 2))
   (CL:SETQ KWD-QUERY-DISJUNCTIVE-IMPLICATION-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISJUNCTIVE-IMPLICATION-INTRODUCTION"
     NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 0))
   (CL:SETQ KWD-QUERY-DUPLICATE-GOALS-WITH-CACHING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DUPLICATE-GOALS-WITH-CACHING" NULL
     2))
   (CL:SETQ KWD-QUERY-MANUFACTURE-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MANUFACTURE-SKOLEM" NULL 2))
   (CL:SETQ KWD-QUERY-FAILED-OVERLAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILED-OVERLAY" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-?D1
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?D1" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-?D2
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?D2" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-DISJOINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISJOINT" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-QUERY-060
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-060" NULL 0))))

(CL:DEFUN HELP-STARTUP-QUERY4 ()
  (CL:PROGN
   (CL:SETQ SYM-QUERY-STELLA-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-QUERY-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-QUERY-PL-KERNEL-KB-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 0))
   (CL:SETQ SYM-QUERY-LOGIC-REFUTATION-DISJOINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFUTATION-DISJOINT" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-QUERY-061
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-061" NULL 0))
   (CL:SETQ SGT-QUERY-PL-KERNEL-KB-COLLECTIONOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTIONOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-QUERY-PL-KERNEL-KB-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-QUERY-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SGT-QUERY-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-QUERY-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SGT-QUERY-LOGIC-DESCRIPTION-EXTENSION-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION-EXTENSION-ITERATOR" NULL
     1))
   (CL:SETQ SYM-QUERY-LOGIC-EXTENSION-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSION-ITERATOR" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-REFERENCE-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFERENCE-PROPOSITION" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-SUBCOLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBCOLLECTION" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-SUBCOLLECTION-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBCOLLECTION-ITERATOR" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ALREADY-GENERATED-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALREADY-GENERATED-LIST" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ALREADY-GENERATED-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALREADY-GENERATED-TABLE" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-REMOVING-DUPLICATES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REMOVING-DUPLICATES?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ITERATOR-INITIALIZATION-TOUCHED-DEFAULT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "ITERATOR-INITIALIZATION-TOUCHED-DEFAULT?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ITERATOR-VALUE-HOLDS-BY-DEFAULT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-VALUE-HOLDS-BY-DEFAULT?"
     NULL 0))
   (CL:SETQ KWD-QUERY-GOAL-CACHES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-CACHES" NULL 2))
   (CL:SETQ KWD-QUERY-EXECUTE-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXECUTE-QUERY" NULL 2))
   (CL:SETQ KWD-QUERY-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ SYM-QUERY-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-QUERY-LOGIC-KAPPA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
   (CL:SETQ SYM-QUERY-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ KWD-QUERY-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ KWD-QUERY-SINGLETONS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SINGLETONS?" NULL 2))
   (CL:SETQ KWD-QUERY-DONT-OPTIMIZE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-OPTIMIZE?" NULL 2))
   (CL:SETQ SYM-QUERY-LOGIC-DONT-OPTIMIZE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-OPTIMIZE?" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-ASK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASK" NULL 0))
   (CL:SETQ KWD-QUERY-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SGT-QUERY-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-QUERY-LOGIC-RETRIEVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRIEVE" NULL 0))
   (CL:SETQ SGT-QUERY-PL-KERNEL-KB-CLASS-PROTOTYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-PROTOTYPE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SYM-QUERY-LOGIC-?C
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?C" NULL 0))
   (CL:SETQ SYM-QUERY-LOGIC-?P
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?P" NULL 0))
   (CL:SETQ SYM-QUERY-PL-KERNEL-KB-CLASS-PROTOTYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-PROTOTYPE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 0))
   (CL:SETQ SYM-QUERY-LOGIC-QUERY-065
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-065" NULL 0))
   (CL:SETQ KWD-QUERY-EXTENSIONAL-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIONAL-ASSERTION" NULL 2))
   (CL:SETQ KWD-QUERY-META (INTERN-RIGID-SYMBOL-WRT-MODULE "META" NULL 2))
   (CL:SETQ SGT-QUERY-STELLA-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-QUERY-STELLA-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-QUERY-LOGIC-STARTUP-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-QUERY" NULL 0))
   (CL:SETQ SYM-QUERY-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))))

(CL:DEFUN HELP-STARTUP-QUERY5 ()
  (CL:PROGN
   (CL:LET* ((SELF-051 (NEW-NORMAL-INFERENCE-LEVEL)))
    (CL:SETF (%KEYWORD SELF-051) KWD-QUERY-NORMAL)
    (CL:SETQ NORMAL-INFERENCE SELF-051))
   (CL:LET* ((SELF-052 (NEW-BACKTRACKING-INFERENCE-LEVEL)))
    (CL:SETF (%KEYWORD SELF-052) KWD-QUERY-BACKTRACKING)
    (CL:SETQ BACKTRACKING-INFERENCE SELF-052))
   (CL:LET* ((SELF-053 (NEW-SUBSUMPTION-INFERENCE-LEVEL)))
    (CL:SETF (%KEYWORD SELF-053) KWD-QUERY-SUBSUMPTION)
    (CL:SETQ SUBSUMPTION-INFERENCE SELF-053))
   (CL:LET* ((SELF-054 (NEW-SHALLOW-INFERENCE-LEVEL)))
    (CL:SETF (%KEYWORD SELF-054) KWD-QUERY-SHALLOW)
    (CL:SETQ SHALLOW-INFERENCE SELF-054))
   (CL:LET* ((SELF-055 (NEW-ASSERTION-INFERENCE-LEVEL)))
    (CL:SETF (%KEYWORD SELF-055) KWD-QUERY-ASSERTION)
    (CL:SETQ ASSERTION-INFERENCE SELF-055))
   (CL:LET* ((SELF-056 (NEW-REFUTATION-INFERENCE-LEVEL)))
    (CL:SETF (%KEYWORD SELF-056) KWD-QUERY-REFUTATION)
    (CL:SETQ REFUTATION-INFERENCE SELF-056))
   (CL:SETQ *INFERENCELEVEL* NORMAL-INFERENCE)
   (CL:SETQ *MAXIMUM-BACKTRACKING-DEPTH* *DEFAULT-MAXIMUM-DEPTH*)
   (CL:SETQ *TYPE-CHECK-STRATEGY* KWD-QUERY-LOOKUP)
   (CL:SETQ *DUPLICATE-SUBGOAL-STRATEGY* KWD-QUERY-DUPLICATE-GOALS)
   (CL:LET* ((SELF-057 (NEW-PROPERTY-LIST)))
    (CL:SETF (%THE-PLIST SELF-057)
     (LIST* KWD-QUERY-UPCLASSIFY (WRAP-CHARACTER #\U)
      (LIST* KWD-QUERY-DOWNCLASSIFY (WRAP-CHARACTER #\D)
       (LIST* KWD-QUERY-PROPAGATE (WRAP-CHARACTER #\P) NIL))))
    (CL:SETQ *THINKING-DOT-TABLE* SELF-057))
   (CL:SETQ *RECYCLE-LIST-FOR-PATTERN-RECORD-S*
    (CREATE-RECYCLE-LIST SGT-QUERY-LOGIC-PATTERN-RECORD 21))
   (CL:LET* ((SELF-058 (NEW-BOOLEAN-VECTOR-INDEX-NODE)))
    (CL:SETF (%THE-VECTOR SELF-058) (NEW-BOOLEAN-VECTOR 0))
    (CL:SETQ *BOOLEAN-VECTOR-INDEX* SELF-058))
   (CL:SETQ *MAXIMUM-QUERY-THREAD-OFFSET* (CL:1- *QUERY-THREAD-LIMIT*))
   (CL:SETQ *FREE-QUERY-THREAD-OFFSETS* (LIST))
   (CL:SETQ *QUERY-ITERATORS-VECTOR* (NEW-VECTOR *QUERY-THREAD-LIMIT*))
   (CL:SETQ *QUERY-CACHE* (NEW-HASH-TABLE))))

(CL:DEFUN HELP-STARTUP-QUERY6 ()
  (CL:PROGN
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INFERENCE-LEVEL"
       "(DEFCLASS INFERENCE-LEVEL (STANDARD-OBJECT) :SLOTS ((KEYWORD :TYPE KEYWORD)) :DOCUMENTATION \"This class hierarchy is used to choose the
level of inference applied when dispatching queries (canned
or ad hoc).\")")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-INFERENCE-LEVEL))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-INFERENCE-LEVEL-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NORMAL-INFERENCE-LEVEL"
       "(DEFCLASS NORMAL-INFERENCE-LEVEL (INFERENCE-LEVEL) :DOCUMENTATION \"The normal inference level employs all proof strategies
except disjunctive implication introduction and refutation.\")")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-NORMAL-INFERENCE-LEVEL)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "BACKTRACKING-INFERENCE-LEVEL"
       "(DEFCLASS BACKTRACKING-INFERENCE-LEVEL (NORMAL-INFERENCE-LEVEL) :DOCUMENTATION \"Specifies subsumption level inference plus backtracking.\")")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-BACKTRACKING-INFERENCE-LEVEL)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SUBSUMPTION-INFERENCE-LEVEL"
       "(DEFCLASS SUBSUMPTION-INFERENCE-LEVEL (BACKTRACKING-INFERENCE-LEVEL) :DOCUMENTATION \"Specifies lookup augmented with cached
subsumption links and equality reasoning.\")")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-SUBSUMPTION-INFERENCE-LEVEL)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SHALLOW-INFERENCE-LEVEL"
       "(DEFCLASS SHALLOW-INFERENCE-LEVEL (SUBSUMPTION-INFERENCE-LEVEL) :DOCUMENTATION \"Specifies lookup of assertions plus simple frame computations.\")")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-SHALLOW-INFERENCE-LEVEL)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ASSERTION-INFERENCE-LEVEL"
       "(DEFCLASS ASSERTION-INFERENCE-LEVEL (SUBSUMPTION-INFERENCE-LEVEL) :DOCUMENTATION \"Specifies lookup of assertions only.\")")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-ASSERTION-INFERENCE-LEVEL)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "REFUTATION-INFERENCE-LEVEL"
       "(DEFCLASS REFUTATION-INFERENCE-LEVEL (NORMAL-INFERENCE-LEVEL) :DOCUMENTATION \"Normal inference augmented by refutation proof strategy.\")")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-REFUTATION-INFERENCE-LEVEL)))
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE COST-ESTIMATE FLOAT \"Type used by the query optimizer to compute estimates of the cost of
executing a query.\")")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "QUERY-ITERATOR"
       "(DEFCLASS QUERY-ITERATOR (ITERATOR) :PUBLIC? TRUE :DOCUMENTATION \"A query iterator points to a query environment
representing the initial or intermediate state of a query.  The iterator's
'value' is a vector representing a satisfying set bindings of the query's
output variables.  Each call to the iterator writes a new set of bindings
into the vector.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT-VECTOR)) :PUBLIC-SLOTS ((EXTERNAL-VARIABLES :TYPE VARIABLES-VECTOR) (SOLUTIONS :TYPE (LIST OF ARGUMENTS-VECTOR) :INITIALLY (NEW LIST)) (EXHAUSTED? :TYPE BOOLEAN) (NEGATED-QUERY :TYPE QUERY-ITERATOR) (ATOMIC-SINGLETONS? :TYPE BOOLEAN) (QUERY-CONTEXT :TYPE CONTEXT) (BASE-CONTROL-FRAME :TYPE CONTROL-FRAME) (CURRENT-CONTROL-FRAME :TYPE CONTROL-FRAME) (CURRENT-PATTERN-RECORD :TYPE PATTERN-RECORD) (CURRENT-PARALLEL-THREAD :TYPE PARALLEL-THREAD) (PARTIAL-MATCH-STRATEGY :TYPE PARTIAL-MATCH-FRAME) (CONTROL-FRAME-PRIORITY-QUEUE :TYPE CONTROL-FRAME-PRIORITY-QUEUE) (ITERATIVE-DEEPENING? :TYPE BOOLEAN) (CURRENT-DEPTH-CUTOFF :TYPE INTEGER) (MAXIMUM-DEPTH :TYPE INTEGER) (AUGMENTED-GOAL-CACHE? :TYPE BOOLEAN) (ACTIVE-GOAL-CACHES :TYPE (LIST OF GOAL-CACHE) :ALLOCATION :EMBEDDED) (TRIGGERED-DEPTH-CUTOFF? :TYPE BOOLEAN) (FAILED-TO-FIND-DUPLICATE-SUBGOAL? :TYPE BOOLEAN) (FOUND-AT-LEAST-ONE-SOLUTION? :TYPE BOOLEAN) (QUERY-THREAD-OFFSET :TYPE INTEGER) (TIMESTAMP :TYPE TIMESTAMP) (LATEST-TOUCHED-DEFAULT? :TYPE BOOLEAN) (TRUTH-VALUES :TYPE (LIST OF TRUTH-VALUE) :ALLOCATION :EMBEDDED) (LATEST-POSITIVE-SCORE :TYPE PARTIAL-MATCH-SCORE) (LATEST-PARTIAL-SCORE :TYPE PARTIAL-MATCH-SCORE) (MATCH-SCORES :TYPE (LIST OF FLOAT-WRAPPER) :ALLOCATION :EMBEDDED) (OPTIMIZER-GOAL-RECORDS :TYPE (EXTENSIBLE-VECTOR OF GOAL-RECORD)) (RESIDUE-GOALS :TYPE (LIST OF PROPOSITION) :ALLOCATION :EMBEDDED) (BEST-GOAL-SEQUENCE :TYPE (LIST OF PROPOSITION) :ALLOCATION :EMBEDDED) (BEST-COST :TYPE COST-ESTIMATE) (ALLOTTED-TIME :TYPE FLOAT) (TIMEOUT? :TYPE BOOLEAN)) :PRINT-FORM (PRINT-QUERY-ITERATOR SELF STREAM))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-QUERY-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-QUERY-ITERATOR-SLOT-VALUE)))
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE GOAL-BINDINGS (CONS OF OBJECT))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CONTROL-FRAME"
       "(DEFCLASS CONTROL-FRAME (STANDARD-OBJECT DYNAMIC-SLOTS-MIXIN) :PUBLIC? TRUE :PUBLIC-SLOTS ((STATE :TYPE KEYWORD) (PROPOSITION :TYPE PROPOSITION) (DESCRIPTION :TYPE DESCRIPTION :ALLOCATION :DYNAMIC) (REVERSE-POLARITY? :TYPE BOOLEAN) (UP :TYPE CONTROL-FRAME) (DOWN :TYPE CONTROL-FRAME) (BACK :TYPE CONTROL-FRAME :ALLOCATION :DYNAMIC) (ARGUMENT-CURSOR :TYPE INTEGER :INITIALLY 0) (PATTERN-RECORD :TYPE PATTERN-RECORD) (INHERITED-PATTERN-RECORD :TYPE PATTERN-RECORD) (CHOICE-POINT-UNBINDING-OFFSET :TYPE INTEGER) (CURRENT-STRATEGY :TYPE KEYWORD) (NEXT-STRATEGIES :TYPE (CONS OF KEYWORD) :INITIALLY NIL) (HOLDS-BY-DEFAULT? :TYPE BOOLEAN) (ITERATOR :TYPE ITERATOR :ALLOCATION :DYNAMIC) (ANTECEDENTS-RULE :TYPE PROPOSITION :ALLOCATION :DYNAMIC) (PROOF-ADJUNCT :TYPE PROOF-ADJUNCT :ALLOCATION :DYNAMIC) (PARTIAL-MATCH-FRAME :TYPE PARTIAL-MATCH-FRAME) (DEBUG-FRAME-ID :TYPE INTEGER) (DEBUG-DEPTH :TYPE INTEGER :INITIALLY 0) (JUSTIFICATIONS :TYPE LIST :ALLOCATION :EMBEDDED) (JUSTIFICATION :TYPE JUSTIFICATION) (CACHED-BINDINGS-ITERATOR :TYPE (ITERATOR OF GOAL-BINDINGS)) (GOAL-BINDINGS :TYPE GOAL-BINDINGS) (GOAL-CACHE :TYPE GOAL-CACHE) (BINDINGS-COUNTER :TYPE INTEGER) (CACHED-SINGLE-VALUED? :TYPE BOOLEAN) (STARTING-CLOCK-TICKS :TYPE INTEGER) (CACHED-GOAL-RESULT? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (DONT-CACHE-GOAL-FAILURE? :TYPE BOOLEAN)) :PRINT-FORM (PRINT-CONTROL-FRAME SELF STREAM))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-CONTROL-FRAME))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-CONTROL-FRAME-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PARALLEL-THREAD"
       "(DEFCLASS PARALLEL-THREAD (STANDARD-OBJECT) :SLOTS ((TOP-CONTROL-FRAME :TYPE CONTROL-FRAME) (HYPOTHETICAL-WORLD :TYPE WORLD) (VARIABLE-BINDINGS :TYPE (VECTOR OF OBJECT)) (UNBINDING-STACK :TYPE INTEGER-VECTOR) (TOP-UNBINDING-STACK-OFFSET :TYPE INTEGER) (PRIORITY :TYPE INTEGER) (STATUS :TYPE KEYWORD)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PARALLEL-THREAD))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PARALLEL-THREAD-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PARALLEL-CONTROL-FRAME"
       "(DEFCLASS PARALLEL-CONTROL-FRAME (CONTROL-FRAME) :SLOTS ((CHILD-THREADS :TYPE (LIST OF PARALLEL-THREAD) :ALLOCATION :EMBEDDED) (UNBOUND-VARIABLES? :TYPE BOOLEAN) (CURRENT-CHILD-THREAD :TYPE PARALLEL-THREAD) (SAVED-PARENT-CONTEXT :TYPE CONTEXT) (SAVED-PARENT-PARALLEL-THREAD :TYPE PARALLEL-THREAD)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PARALLEL-CONTROL-FRAME))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PARALLEL-CONTROL-FRAME-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CONTROL-FRAME-PRIORITY-QUEUE"
       "(DEFCLASS CONTROL-FRAME-PRIORITY-QUEUE (STANDARD-OBJECT) :SLOTS ((QUEUE :TYPE (LIST OF PARALLEL-CONTROL-FRAME))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-CONTROL-FRAME-PRIORITY-QUEUE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-CONTROL-FRAME-PRIORITY-QUEUE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PROOF-ADJUNCT"
       "(DEFCLASS PROOF-ADJUNCT (STANDARD-OBJECT) :DOCUMENTATION \"Subclasses of 'PROOF-ADJUNCT' provide for specialized
slots (specialized for a particular strategy) to hold a record of
an ongoing proof thread.\")")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PROOF-ADJUNCT)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PATTERN-RECORD"
       "(DEFCLASS PATTERN-RECORD (STANDARD-OBJECT) :DOCUMENTATION \"A pattern record records bookkeeping data used during
the processing of a description.\" :SLOTS ((CONTROL-FRAME :TYPE CONTROL-FRAME) (VARIABLE-BINDINGS :TYPE (VECTOR OF OBJECT)) (UNBINDING-STACK :TYPE INTEGER-VECTOR) (TOP-UNBINDING-STACK-OFFSET :TYPE INTEGER) (DESCRIPTION :TYPE DESCRIPTION) (EXTERNAL-ARGUMENTS :TYPE ARGUMENTS-VECTOR) (BOOLEAN-VECTOR :TYPE BOOLEAN-VECTOR) (OPTIMAL-PATTERN :TYPE DESCRIPTION) (COLLECTION-LIST :TYPE LIST)) :RECYCLE-METHOD :FREE-LIST :TERMINATOR TERMINATE-PATTERN-RECORD?)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PATTERN-RECORD))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PATTERN-RECORD-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "BOOLEAN-VECTOR-INDEX-NODE"
       "(DEFCLASS BOOLEAN-VECTOR-INDEX-NODE (STANDARD-OBJECT) :SLOTS ((TRUE-LINK :TYPE BOOLEAN-VECTOR-INDEX-NODE) (FALSE-LINK :TYPE BOOLEAN-VECTOR-INDEX-NODE) (THE-VECTOR :TYPE BOOLEAN-VECTOR)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-BOOLEAN-VECTOR-INDEX-NODE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-BOOLEAN-VECTOR-INDEX-NODE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "DESCRIPTION-EXTENSION-ITERATOR"
       "(DEFCLASS DESCRIPTION-EXTENSION-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterates over the extension of a description and
its subdescriptions, returning those propositions that are currently true.\" :PARAMETERS ((ANY-VALUE :TYPE PROPOSITION)) :SLOTS ((EXTENSION-ITERATOR :TYPE (ITERATOR OF PROPOSITION)) (REFERENCE-PROPOSITION :TYPE PROPOSITION) (SUBCOLLECTION :TYPE NAMED-DESCRIPTION) (SUBCOLLECTION-ITERATOR :TYPE ITERATOR) (ALREADY-GENERATED-LIST :TYPE LIST :INITIALLY (NEW LIST)) (ALREADY-GENERATED-TABLE :TYPE HASH-TABLE) (REMOVING-DUPLICATES? :TYPE BOOLEAN) (ITERATOR-INITIALIZATION-TOUCHED-DEFAULT? :TYPE BOOLEAN :INITIALLY FALSE) (ITERATOR-VALUE-HOLDS-BY-DEFAULT? :TYPE BOOLEAN :INITIALLY FALSE)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-DESCRIPTION-EXTENSION-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-DESCRIPTION-EXTENSION-ITERATOR-SLOT-VALUE)))))

(CL:DEFUN HELP-STARTUP-QUERY7 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "CURRENT-INFERENCE-LEVEL"
    "(DEFUN (CURRENT-INFERENCE-LEVEL NORMAL-INFERENCE-LEVEL) ())"
    (CL:FUNCTION CURRENT-INFERENCE-LEVEL) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-INFERENCE-LEVEL"
    "(DEFUN (GET-INFERENCE-LEVEL INFERENCE-LEVEL) ((LEVELKEYWORD KEYWORD)))"
    (CL:FUNCTION GET-INFERENCE-LEVEL) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-INFERENCE-LEVEL"
    "(DEFUN (SET-INFERENCE-LEVEL KEYWORD) ((LEVELKEYWORD KEYWORD)))"
    (CL:FUNCTION SET-INFERENCE-LEVEL) NULL)
   (DEFINE-FUNCTION-OBJECT "USING-DEFAULT-KNOWLEDGE?"
    "(DEFUN (USING-DEFAULT-KNOWLEDGE? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (NOT *DONTUSEDEFAULTKNOWLEDGE?*)))"
    (CL:FUNCTION USING-DEFAULT-KNOWLEDGE?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRACE-SUBGOALS" "(DEFUN TRACE-SUBGOALS ())"
    (CL:FUNCTION TRACE-SUBGOALS) NULL)
   (DEFINE-FUNCTION-OBJECT "UNTRACE-SUBGOALS"
    "(DEFUN UNTRACE-SUBGOALS ())" (CL:FUNCTION UNTRACE-SUBGOALS) NULL)
   (DEFINE-FUNCTION-OBJECT "TRACE-RULES" "(DEFUN TRACE-RULES ())"
    (CL:FUNCTION TRACE-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "UNTRACE-RULES" "(DEFUN UNTRACE-RULES ())"
    (CL:FUNCTION UNTRACE-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "TOGGLE-TRACE-SUBGOALS"
    "(DEFUN (TOGGLE-TRACE-SUBGOALS STRING) ())"
    (CL:FUNCTION TOGGLE-TRACE-SUBGOALS) NULL)
   (DEFINE-FUNCTION-OBJECT "TOGGLE-TRACE-RULES"
    "(DEFUN (TOGGLE-TRACE-RULES STRING) ())"
    (CL:FUNCTION TOGGLE-TRACE-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "EMIT-THINKING-DOT"
    "(DEFUN EMIT-THINKING-DOT ((KINDOFTHINKING KEYWORD)))"
    (CL:FUNCTION EMIT-THINKING-DOT) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-BOOLEAN-VECTOR-INDEX-NODE"
    "(DEFUN (CREATE-BOOLEAN-VECTOR-INDEX-NODE BOOLEAN-VECTOR-INDEX-NODE) ((PARENTNODE BOOLEAN-VECTOR-INDEX-NODE) (LASTVALUE BOOLEAN)))"
    (CL:FUNCTION CREATE-BOOLEAN-VECTOR-INDEX-NODE) NULL)
   (DEFINE-FUNCTION-OBJECT "ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR"
    "(DEFUN (ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR BOOLEAN-VECTOR) ((ARGUMENTSVECTOR ARGUMENTS-VECTOR)))"
    (CL:FUNCTION ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "ZERO-ONE-LIST-TO-BOOLEAN-VECTOR"
    "(DEFUN (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR BOOLEAN-VECTOR) ((ZEROONELIST (LIST OF INTEGER-WRAPPER))))"
    (CL:FUNCTION ZERO-ONE-LIST-TO-BOOLEAN-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "POP-CONTROL-FRAME"
    "(DEFUN POP-CONTROL-FRAME ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION POP-CONTROL-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "POP-FRAMES-UP-TO"
    "(DEFUN POP-FRAMES-UP-TO ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION POP-FRAMES-UP-TO) NULL)
   (DEFINE-FUNCTION-OBJECT "POP-DOWN-FRAME"
    "(DEFUN POP-DOWN-FRAME ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION POP-DOWN-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "ACTIVATE-PATTERN-RECORD"
    "(DEFUN ACTIVATE-PATTERN-RECORD ((PATTERNRECORD PATTERN-RECORD) (VARIABLECOUNT INTEGER)))"
    (CL:FUNCTION ACTIVATE-PATTERN-RECORD) NULL)
   (DEFINE-FUNCTION-OBJECT "RESET-CURRENT-PATTERN-RECORD"
    "(DEFUN RESET-CURRENT-PATTERN-RECORD ((FRAME CONTROL-FRAME) (LOCALORPARENT KEYWORD)))"
    (CL:FUNCTION RESET-CURRENT-PATTERN-RECORD) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-ENVIRONMENT-STACKS"
    "(DEFUN PRINT-ENVIRONMENT-STACKS ())"
    (CL:FUNCTION PRINT-ENVIRONMENT-STACKS) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-PATTERN-VARIABLE-BINDING"
    "(DEFUN SET-PATTERN-VARIABLE-BINDING ((VARIABLE PATTERN-VARIABLE) (VALUE OBJECT)))"
    (CL:FUNCTION SET-PATTERN-VARIABLE-BINDING) NULL)
   (DEFINE-FUNCTION-OBJECT "UNBIND-VARIABLES-BEGINNING-AT"
    "(DEFUN UNBIND-VARIABLES-BEGINNING-AT ((PATTERNRECORD PATTERN-RECORD) (UBSTACKOFFSET INTEGER)))"
    (CL:FUNCTION UNBIND-VARIABLES-BEGINNING-AT) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-CHOICE-POINT"
    "(DEFUN CREATE-CHOICE-POINT ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION CREATE-CHOICE-POINT) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWIND-TO-CHOICE-POINT"
    "(DEFUN UNWIND-TO-CHOICE-POINT ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION UNWIND-TO-CHOICE-POINT) NULL)
   (DEFINE-FUNCTION-OBJECT "NEW-BINDINGS-SINCE-LAST-CHOICE-POINT?"
    "(DEFUN (NEW-BINDINGS-SINCE-LAST-CHOICE-POINT? BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION NEW-BINDINGS-SINCE-LAST-CHOICE-POINT?) NULL)
   (DEFINE-FUNCTION-OBJECT "BOUND-TO"
    "(DEFUN (BOUND-TO OBJECT) ((SELF PATTERN-VARIABLE)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH (VARIABLE-BINDINGS (CURRENT-PATTERN-RECORD *QUERYITERATOR*)) (BOUND-TO-OFFSET SELF))))"
    (CL:FUNCTION BOUND-TO) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTAINS-OPERATOR?"
    "(DEFUN (CONTAINS-OPERATOR? BOOLEAN) ((PROPOSITION PROPOSITION) (OPERATOR SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION CONTAINS-OPERATOR?) NULL)
   (DEFINE-FUNCTION-OBJECT "ARGUMENT-BOUND-TO"
    "(DEFUN (ARGUMENT-BOUND-TO OBJECT) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION ARGUMENT-BOUND-TO) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-UNIFY-ATTRIBUTES?"
    "(DEFUN (HELP-UNIFY-ATTRIBUTES? BOOLEAN) ((VALUE1 OBJECT) (VALUE2 OBJECT)))"
    (CL:FUNCTION HELP-UNIFY-ATTRIBUTES?) NULL)
   (DEFINE-FUNCTION-OBJECT "FAILS-UNIFICATION-TYPE-CHECK?"
    "(DEFUN (FAILS-UNIFICATION-TYPE-CHECK? BOOLEAN) ((V1 PATTERN-VARIABLE) (I2 OBJECT)))"
    (CL:FUNCTION FAILS-UNIFICATION-TYPE-CHECK?) NULL)
   (DEFINE-FUNCTION-OBJECT "FAILS-ANTECEDENT-TYPE-CHECK?"
    "(DEFUN (FAILS-ANTECEDENT-TYPE-CHECK? BOOLEAN) ((V1 PATTERN-VARIABLE) (I2 OBJECT)))"
    (CL:FUNCTION FAILS-ANTECEDENT-TYPE-CHECK?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-BIND-VARIABLE-TO-VALUE?"
    "(DEFUN (HELP-BIND-VARIABLE-TO-VALUE? BOOLEAN) ((VARIABLE PATTERN-VARIABLE) (VALUE OBJECT)))"
    (CL:FUNCTION HELP-BIND-VARIABLE-TO-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "BIND-VARIABLE-TO-VALUE?"
    "(DEFUN (BIND-VARIABLE-TO-VALUE? BOOLEAN) ((VARIABLE PATTERN-VARIABLE) (VALUE OBJECT) (AUTOCLEANUP? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION BIND-VARIABLE-TO-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "BIND-ARGUMENT-TO-VALUE?"
    "(DEFUN (BIND-ARGUMENT-TO-VALUE? BOOLEAN) ((ARGUMENT OBJECT) (VALUE OBJECT) (AUTOCLEANUP? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION BIND-ARGUMENT-TO-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "BIND-VECTOR-OF-ARGUMENTS-TO-VALUES?"
    "(DEFUN (BIND-VECTOR-OF-ARGUMENTS-TO-VALUES? BOOLEAN) ((ARGUMENTS ARGUMENTS-VECTOR) (VALUES CONS)))"
    (CL:FUNCTION BIND-VECTOR-OF-ARGUMENTS-TO-VALUES?) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-CONTROL-FRAME-STACK"
    "(DEFUN PRINT-CONTROL-FRAME-STACK ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION PRINT-CONTROL-FRAME-STACK) NULL)
   (DEFINE-FUNCTION-OBJECT "PCS" "(DEFUN PCS ())" (CL:FUNCTION PCS) NULL)
   (DEFINE-FUNCTION-OBJECT "VARIABLE-FROM-UNBINDING-OFFSET"
    "(DEFUN (VARIABLE-FROM-UNBINDING-OFFSET PATTERN-VARIABLE) ((DESCRIPTION DESCRIPTION) (UBOFFSET INTEGER)))"
    (CL:FUNCTION VARIABLE-FROM-UNBINDING-OFFSET) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-ONE-VARIABLE-BINDING"
    "(DEFUN PRINT-ONE-VARIABLE-BINDING ((VARIABLE PATTERN-VARIABLE)))"
    (CL:FUNCTION PRINT-ONE-VARIABLE-BINDING) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-VARIABLE-BINDINGS"
    "(DEFUN PRINT-VARIABLE-BINDINGS ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION PRINT-VARIABLE-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-RULE-IN-GOAL-TREE"
    "(DEFUN PRINT-RULE-IN-GOAL-TREE ((FRAME CONTROL-FRAME) (IMPLIESPROP PROPOSITION) (DEPTH INTEGER)))"
    (CL:FUNCTION PRINT-RULE-IN-GOAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-GOAL-IN-GOAL-TREE"
    "(DEFUN PRINT-GOAL-IN-GOAL-TREE ((FRAME CONTROL-FRAME) (DEPTH INTEGER)))"
    (CL:FUNCTION PRINT-GOAL-IN-GOAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-FRAME-DEPTH"
    "(DEFUN (COMPUTE-FRAME-DEPTH INTEGER) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION COMPUTE-FRAME-DEPTH) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-VERTICAL-BARS"
    "(DEFUN PRINT-VERTICAL-BARS ((DEPTH INTEGER)))"
    (CL:FUNCTION PRINT-VERTICAL-BARS) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWIND-TO-CHOICE-POINTS-BELOW-FRAME"
    "(DEFUN UNWIND-TO-CHOICE-POINTS-BELOW-FRAME ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION UNWIND-TO-CHOICE-POINTS-BELOW-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "TRACE-GOAL-TREE"
    "(DEFUN TRACE-GOAL-TREE ((FRAME CONTROL-FRAME) (DEPTH INTEGER) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION TRACE-GOAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERPRET-AND-SCORES"
    "(DEFUN (INTERPRET-AND-SCORES KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION INTERPRET-AND-SCORES) NULL)
   (DEFINE-FUNCTION-OBJECT "FRAME-DEPTH"
    "(DEFUN (FRAME-DEPTH INTEGER) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION FRAME-DEPTH) NULL)
   (DEFINE-FUNCTION-OBJECT "UNBOUND-VARIABLES-IN-FRAME?"
    "(DEFUN (UNBOUND-VARIABLES-IN-FRAME? BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION UNBOUND-VARIABLES-IN-FRAME?) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-UNBOUND-VARIABLES-NON-FUNCTIONAL"
    "(DEFUN (GET-UNBOUND-VARIABLES-NON-FUNCTIONAL CONS) ((PROP PROPOSITION)))"
    (CL:FUNCTION GET-UNBOUND-VARIABLES-NON-FUNCTIONAL) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERPRET-ITERATIVE-FORALL-SCORES"
    "(DEFUN (INTERPRET-ITERATIVE-FORALL-SCORES KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION INTERPRET-ITERATIVE-FORALL-SCORES) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERPRET-OR-SCORES"
    "(DEFUN (INTERPRET-OR-SCORES KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION INTERPRET-OR-SCORES) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERPRET-FAIL-SCORE"
    "(DEFUN (INTERPRET-FAIL-SCORE KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION INTERPRET-FAIL-SCORE) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERPRET-GOAL-SCORES"
    "(DEFUN (INTERPRET-GOAL-SCORES KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION INTERPRET-GOAL-SCORES) NULL)
   (DEFINE-FUNCTION-OBJECT "ATTACH-SUPPORT"
    "(DEFUN ATTACH-SUPPORT ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION ATTACH-SUPPORT) NULL)
   (DEFINE-FUNCTION-OBJECT "OPERATIVE-PATTERN-RECORD"
    "(DEFUN (OPERATIVE-PATTERN-RECORD PATTERN-RECORD) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION OPERATIVE-PATTERN-RECORD) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-DOWN-FRAME"
    "(DEFUN (CREATE-DOWN-FRAME CONTROL-FRAME) ((UPFRAME CONTROL-FRAME) (DOWNPROPOSITION PROPOSITION)))"
    (CL:FUNCTION CREATE-DOWN-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "COPY-FRAME-STATE"
    "(DEFUN COPY-FRAME-STATE ((FROMFRAME CONTROL-FRAME) (TOFRAME CONTROL-FRAME)))"
    (CL:FUNCTION COPY-FRAME-STATE) NULL)
   (DEFINE-FUNCTION-OBJECT "PARALLELIZE-CONTROL-FRAME"
    "(DEFUN (PARALLELIZE-CONTROL-FRAME PARALLEL-CONTROL-FRAME) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION PARALLELIZE-CONTROL-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "ENTER-PARALLEL-THREAD"
    "(DEFUN ENTER-PARALLEL-THREAD ((PFRAME PARALLEL-CONTROL-FRAME) (CHILDTHREAD PARALLEL-THREAD)))"
    (CL:FUNCTION ENTER-PARALLEL-THREAD) NULL)))

(CL:DEFUN HELP-STARTUP-QUERY8 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "EXIT-PARALLEL-THREAD"
    "(DEFUN EXIT-PARALLEL-THREAD ((PFRAME PARALLEL-CONTROL-FRAME)))"
    (CL:FUNCTION EXIT-PARALLEL-THREAD) NULL)
   (DEFINE-FUNCTION-OBJECT "ENTER-HYPOTHETICAL-WORLD"
    "(DEFUN (ENTER-HYPOTHETICAL-WORLD WORLD) ((PFRAME PARALLEL-CONTROL-FRAME)))"
    (CL:FUNCTION ENTER-HYPOTHETICAL-WORLD) NULL)
   (DEFINE-FUNCTION-OBJECT "PARTIAL-MATCH-MODE?"
    "(DEFUN (PARTIAL-MATCH-MODE? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (AND (DEFINED? *QUERYITERATOR*) (DEFINED? (PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)))))"
    (CL:FUNCTION PARTIAL-MATCH-MODE?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXECUTE-BACKWARD-CHAINING-PROOF?"
    "(DEFUN (EXECUTE-BACKWARD-CHAINING-PROOF? BOOLEAN) ((QUERYITERATOR QUERY-ITERATOR)))"
    (CL:FUNCTION EXECUTE-BACKWARD-CHAINING-PROOF?) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-NEXT-MOVE"
    "(DEFUN (EVALUATE-NEXT-MOVE KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD) (CLOCKTICKS INTEGER)))"
    (CL:FUNCTION EVALUATE-NEXT-MOVE) NULL)
   (DEFINE-FUNCTION-OBJECT "MOVE-FORWARD-AND-DOWN"
    "(DEFUN (MOVE-FORWARD-AND-DOWN KEYWORD) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION MOVE-FORWARD-AND-DOWN) NULL)
   (DEFINE-FUNCTION-OBJECT "MOVE-BACKWARD-AND-UP-OR-DOWN"
    "(DEFUN (MOVE-BACKWARD-AND-UP-OR-DOWN KEYWORD) ((FRAME CONTROL-FRAME) (NEXTMOVE KEYWORD)))"
    (CL:FUNCTION MOVE-BACKWARD-AND-UP-OR-DOWN) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CLUSTERED-CONJUNCTION? BOOLEAN) ((SELF PROPOSITION)))"
    (CL:FUNCTION CLUSTERED-CONJUNCTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTINUE-AND-PROOF"
    "(DEFUN (CONTINUE-AND-PROOF KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-AND-PROOF) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTINUE-OR-PROOF"
    "(DEFUN (CONTINUE-OR-PROOF KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-OR-PROOF) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTINUE-NOT-PROOF"
    "(DEFUN (CONTINUE-NOT-PROOF KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-NOT-PROOF) NULL)
   (DEFINE-FUNCTION-OBJECT "OVERLAY-WITH-FAIL-FRAME"
    "(DEFUN (OVERLAY-WITH-FAIL-FRAME KEYWORD) ((FRAME CONTROL-FRAME) (PROPOSITION PROPOSITION)))"
    (CL:FUNCTION OVERLAY-WITH-FAIL-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "OVERLAY-WITH-STRATEGY-FRAME"
    "(DEFUN (OVERLAY-WITH-STRATEGY-FRAME KEYWORD) ((FRAME CONTROL-FRAME) (STRATEGY KEYWORD)))"
    (CL:FUNCTION OVERLAY-WITH-STRATEGY-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "CHECK-FOR-DUPLICATE-GOAL?"
    "(DEFUN (CHECK-FOR-DUPLICATE-GOAL? BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION CHECK-FOR-DUPLICATE-GOAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIATE-ATOMIC-GOAL-PROOFS"
    "(DEFUN (INITIATE-ATOMIC-GOAL-PROOFS KEYWORD) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION INITIATE-ATOMIC-GOAL-PROOFS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-ARGUMENTS-BOUND?"
    "(DEFUN (ALL-ARGUMENTS-BOUND? BOOLEAN) ((GOAL PROPOSITION)))"
    (CL:FUNCTION ALL-ARGUMENTS-BOUND?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-KEY-ARGUMENTS-BOUND?"
    "(DEFUN (ALL-KEY-ARGUMENTS-BOUND? BOOLEAN) ((GOAL PROPOSITION)))"
    (CL:FUNCTION ALL-KEY-ARGUMENTS-BOUND?) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-PATTERN-RECORD"
    "(DEFUN (CREATE-PATTERN-RECORD PATTERN-RECORD) ((FRAME CONTROL-FRAME) (DESCRIPTION DESCRIPTION) (EXTERNALARGUMENTS ARGUMENTS-VECTOR)))"
    (CL:FUNCTION CREATE-PATTERN-RECORD) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMINATE-PATTERN-RECORD?"
    "(DEFUN (TERMINATE-PATTERN-RECORD? BOOLEAN) ((SELF PATTERN-RECORD)))"
    (CL:FUNCTION TERMINATE-PATTERN-RECORD?) NULL)
   (DEFINE-FUNCTION-OBJECT "COPY-PATTERN-ARGUMENTS"
    "(DEFUN (COPY-PATTERN-ARGUMENTS ARGUMENTS-VECTOR) ((ARGUMENTS OBJECT-VECTOR) (DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION COPY-PATTERN-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-EXTERNAL-BINDINGS"
    "(DEFUN (COMPUTE-EXTERNAL-BINDINGS CONS) ((EXTERNALARGUMENTS ARGUMENTS-VECTOR)))"
    (CL:FUNCTION COMPUTE-EXTERNAL-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "CHECK-FOR-SINGLE-VALUED-GOAL?"
    "(DEFUN (CHECK-FOR-SINGLE-VALUED-GOAL? BOOLEAN) ((PATTERN DESCRIPTION) (IOBINDINGS CONS)))"
    (CL:FUNCTION CHECK-FOR-SINGLE-VALUED-GOAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "OVERLAY-WITH-PATTERN-FRAME?"
    "(DEFUN (OVERLAY-WITH-PATTERN-FRAME? BOOLEAN) ((FRAME CONTROL-FRAME) (DESCRIPTION DESCRIPTION) (IOARGUMENTS ARGUMENTS-VECTOR)))"
    (CL:FUNCTION OVERLAY-WITH-PATTERN-FRAME?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSFER-PATTERN-QUERY-BINDINGS?"
    "(DEFUN (TRANSFER-PATTERN-QUERY-BINDINGS? BOOLEAN) ((FRAME CONTROL-FRAME) (FUTUREBINDINGS? BOOLEAN)))"
    (CL:FUNCTION TRANSFER-PATTERN-QUERY-BINDINGS?) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-PATTERN-QUERY-BINDINGS"
    "(DEFUN COLLECT-PATTERN-QUERY-BINDINGS ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION COLLECT-PATTERN-QUERY-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTINUE-PATTERN-PROOF"
    "(DEFUN (CONTINUE-PATTERN-PROOF KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PATTERN-PROOF) NULL)
   (DEFINE-FUNCTION-OBJECT "DISJOINT-CLASSES?"
    "(DEFUN (DISJOINT-CLASSES? BOOLEAN) ((DESC1 NAMED-DESCRIPTION) (DESC2 NAMED-DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION DISJOINT-CLASSES?) NULL)
   (DEFINE-FUNCTION-OBJECT "DISJOINT-TERMS?"
    "(DEFUN (DISJOINT-TERMS? BOOLEAN) ((D1 DESCRIPTION) (D2 DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION DISJOINT-TERMS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPENSIVE-DISJOINT-TERMS?"
    "(DEFUN (EXPENSIVE-DISJOINT-TERMS? BOOLEAN) ((D1 DESCRIPTION) (D2 DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION EXPENSIVE-DISJOINT-TERMS?) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECTIONOF-PROPOSITION?"
    "(DEFUN (COLLECTIONOF-PROPOSITION? BOOLEAN) ((DEFININGPROPOSITION PROPOSITION)))"
    (CL:FUNCTION COLLECTIONOF-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "MEMBER-OF-COLLECTION?"
    "(DEFUN (MEMBER-OF-COLLECTION? BOOLEAN) ((MEMBER OBJECT) (COLLECTION OBJECT)))"
    (CL:FUNCTION MEMBER-OF-COLLECTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERTED-COLLECTION-MEMBERS"
    "(DEFUN (ASSERTED-COLLECTION-MEMBERS LIST) ((SELF OBJECT) (DIRECT? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION ASSERTED-COLLECTION-MEMBERS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-TRUE-EXTENSION-MEMBERS"
    "(DEFUN (ALL-TRUE-EXTENSION-MEMBERS DESCRIPTION-EXTENSION-ITERATOR) ((SELF NAMED-DESCRIPTION) (SPECIALIZE? BOOLEAN)))"
    (CL:FUNCTION ALL-TRUE-EXTENSION-MEMBERS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-MATCHING-EXTENSION-MEMBERS"
    "(DEFUN (ALL-MATCHING-EXTENSION-MEMBERS (ITERATOR OF PROPOSITION)) ((SELF PROPOSITION) (SPECIALIZE? BOOLEAN)))"
    (CL:FUNCTION ALL-MATCHING-EXTENSION-MEMBERS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF DESCRIPTION-EXTENSION-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "RESERVE-QUERY-THREAD"
    "(DEFUN RESERVE-QUERY-THREAD ((QUERYITERATOR QUERY-ITERATOR)) :DOCUMENTATION \"Find a free query thread and assign it to 'queryIterator'.
Signal a :QUERY-THREAD-LIMIT-VIOLATION exception if all threads are taken.\")"
    (CL:FUNCTION RESERVE-QUERY-THREAD) NULL)
   (DEFINE-FUNCTION-OBJECT "RELEASE-QUERY-THREAD"
    "(DEFUN RELEASE-QUERY-THREAD ((QUERYITERATOR QUERY-ITERATOR)) :DOCUMENTATION \"Release the query thread for 'queryIterator'.\")"
    (CL:FUNCTION RELEASE-QUERY-THREAD) NULL)
   (DEFINE-FUNCTION-OBJECT "RELEASE-ALL-QUERY-THREADS"
    "(DEFUN (RELEASE-ALL-QUERY-THREADS (LIST OF INTEGER-WRAPPER)) () :DOCUMENTATION \"Free up all query threads (buggy queries may have
failed to terminate).\")" (CL:FUNCTION RELEASE-ALL-QUERY-THREADS) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-QUERY-THREADS"
    "(DEFUN (CLEAR-QUERY-THREADS (LIST OF INTEGER-WRAPPER)) ())"
    (CL:FUNCTION CLEAR-QUERY-THREADS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-FIND-DUPLICATED-GOAL"
    "(DEFUN (HELP-FIND-DUPLICATED-GOAL CONTROL-FRAME CONTROL-FRAME INTEGER) ((GOALFRAME CONTROL-FRAME)))"
    (CL:FUNCTION HELP-FIND-DUPLICATED-GOAL) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-DUPLICATED-GOAL"
    "(DEFUN (FIND-DUPLICATED-GOAL CONTROL-FRAME CONTROL-FRAME INTEGER) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION FIND-DUPLICATED-GOAL) NULL)
   (DEFINE-FUNCTION-OBJECT "HANDLE-DEPTH-VIOLATION"
    "(DEFUN (HANDLE-DEPTH-VIOLATION CONTROL-FRAME INTEGER) ((FRAME CONTROL-FRAME) (DEPTH INTEGER)))"
    (CL:FUNCTION HANDLE-DEPTH-VIOLATION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-CONTROL-FRAME"
    "(DEFUN PRINT-CONTROL-FRAME ((SELF CONTROL-FRAME) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-CONTROL-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-GOAL-STACK"
    "(DEFUN PRINT-GOAL-STACK ((FRAME CONTROL-FRAME) (VERBOSE? BOOLEAN)) :DOCUMENTATION \"Print stack of goals.  Assumes that query has been interrupted
with a full stack of control frames.\")" (CL:FUNCTION PRINT-GOAL-STACK)
    NULL)
   (DEFINE-FUNCTION-OBJECT "PGS" "(DEFUN PGS ())" (CL:FUNCTION PGS) NULL)
   (DEFINE-FUNCTION-OBJECT "VPGS" "(DEFUN VPGS ())" (CL:FUNCTION VPGS)
    NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-QUERY-ITERATOR"
    "(DEFUN PRINT-QUERY-ITERATOR ((SELF QUERY-ITERATOR) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-QUERY-ITERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-QUERY-ITERATOR-ORNATELY"
    "(DEFUN PRINT-QUERY-ITERATOR-ORNATELY ((SELF QUERY-ITERATOR) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-QUERY-ITERATOR-ORNATELY) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-QUERY-ITERATOR-READABLY"
    "(DEFUN PRINT-QUERY-ITERATOR-READABLY ((SELF QUERY-ITERATOR) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-QUERY-ITERATOR-READABLY) NULL)
   (DEFINE-FUNCTION-OBJECT "ALLOCATE-QUERY-ITERATOR"
    "(DEFUN (ALLOCATE-QUERY-ITERATOR QUERY-ITERATOR) ())"
    (CL:FUNCTION ALLOCATE-QUERY-ITERATOR) NULL)
   (DEFINE-METHOD-OBJECT "(DEFMETHOD FREE ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION FREE) NULL)
   (DEFINE-FUNCTION-OBJECT "FREE-QUERY-ITERATOR"
    "(DEFUN FREE-QUERY-ITERATOR ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION FREE-QUERY-ITERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "ALLOCATE-COLLECTION-VARIABLES"
    "(DEFUN (ALLOCATE-COLLECTION-VARIABLES VARIABLES-VECTOR) ((FRAME CONTROL-FRAME) (DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION ALLOCATE-COLLECTION-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-QUERY-ITERATOR"
    "(DEFUN (CREATE-QUERY-ITERATOR QUERY-ITERATOR) ((DESCRIPTION DESCRIPTION) (OUTSIDEBINDINGS VECTOR) (ATOMICSINGLETONS? BOOLEAN)))"
    (CL:FUNCTION CREATE-QUERY-ITERATOR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRY-TO-DEFEAT-LAST-ANSWER?"
    "(DEFUN (TRY-TO-DEFEAT-LAST-ANSWER? BOOLEAN) ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION TRY-TO-DEFEAT-LAST-ANSWER?) NULL)
   (DEFINE-METHOD-OBJECT "(DEFMETHOD RESET ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION RESET) NULL)
   (DEFINE-FUNCTION-OBJECT "COPY-VECTOR-TO-CONS-LIST"
    "(DEFUN (COPY-VECTOR-TO-CONS-LIST CONS) ((VECTOR VECTOR)))"
    (CL:FUNCTION COPY-VECTOR-TO-CONS-LIST) NULL)
   (DEFINE-FUNCTION-OBJECT "STANDARDIZE-QUERY-TREE"
    "(DEFUN (STANDARDIZE-QUERY-TREE CONS) ((IOVARIABLES OBJECT) (QUERYBODY OBJECT) (EXTERNALVARIABLES CONS)))"
    (CL:FUNCTION STANDARDIZE-QUERY-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-QUERY"
    "(DEFUN (MAKE-QUERY QUERY-ITERATOR) ((IOVARIABLES OBJECT) (QUERYTREE OBJECT) (EXTERNALBINDINGS CONS) (OPTIONS CONS)))"
    (CL:FUNCTION MAKE-QUERY) NULL)))

(CL:DEFUN HELP-STARTUP-QUERY9 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "PROCESS-QUERY-OPTIONS"
    "(DEFUN PROCESS-QUERY-OPTIONS ((QUERY QUERY-ITERATOR) (OPTIONS CONS)))"
    (CL:FUNCTION PROCESS-QUERY-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-YES-OR-NO-QUERY?"
    "(DEFUN (RUN-YES-OR-NO-QUERY? THREE-VALUED-BOOLEAN) ((QUERYITERATOR QUERY-ITERATOR)))"
    (CL:FUNCTION RUN-YES-OR-NO-QUERY?) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-TREE"
    "(DEFUN (COERCE-TO-TREE OBJECT) ((SELF OBJECT)))"
    (CL:FUNCTION COERCE-TO-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-STRING"
    "(DEFUN (COERCE-TO-STRING STRING) ((SELF OBJECT)))"
    (CL:FUNCTION COERCE-TO-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "ASK"
    "(DEFUN (ASK THREE-VALUED-BOOLEAN) (|&REST| (|PROPOSITION&OPTIONS| PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Perform inference to determine whether `proposition' is true.
Return TRUE if `proposition' was found to be true; return NULL otherwise.
KIF example: `(ask (happy Fred))' will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic constant
`Fred' and the relation (or slot) `happy' must already be defined (see
`assert').  Use `(set/unset-feature goal-trace)' to en/disable goal tracing
of the inference engine.\")" (CL:FUNCTION %ASK)
    (CL:FUNCTION ASK-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "RETRIEVE-BINDINGS"
    "(DEFUN (RETRIEVE-BINDINGS QUERY-ITERATOR) ((QUERY OBJECT) (NOFBINDINGS INTEGER)))"
    (CL:FUNCTION RETRIEVE-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "QUERY-ITERATOR.RETRIEVE-BINDINGS"
    "(DEFUN (QUERY-ITERATOR.RETRIEVE-BINDINGS QUERY-ITERATOR) ((QUERY QUERY-ITERATOR) (NOFBINDINGS INTEGER)))"
    (CL:FUNCTION QUERY-ITERATOR.RETRIEVE-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "CONS.RETRIEVE-BINDINGS"
    "(DEFUN (CONS.RETRIEVE-BINDINGS QUERY-ITERATOR) ((QUERY CONS) (NOFBINDINGS INTEGER)))"
    (CL:FUNCTION CONS.RETRIEVE-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRIEVE"
    "(DEFUN (RETRIEVE QUERY-ITERATOR) (|&REST| (QUERY PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Retrieve elements of a relation (tuples) that satisfy a proposition.
The accepted syntax is:
	 
  (retrieve [<integer> | all]
            [{<variable-spec> | (<variable-spec>+)}
             [<proposition>]])
	
The variables and proposition are similar to an `exists' sentence or
`kappa' term without the quantifier.  <proposition> usually contains
references to the listed variables.  No other free variable references
are allowed.  If <proposition> is omitted, it defaults to TRUE.  

A solution is a set of bindings for the listed variables for which
<proposition> is true.  The optional first argument controls how many
solutions should be generated before control is returned.  The keyword
`all' indicates that all solutions should be generated.  By default,
`retrieve' returns after it has found one new solution or if it cannot
find any more solutions.

`retrieve' returns an iterator which saves all the necessary state of
a query and stores all generated solutions.  When used interactively,
the returned iterator will print out with the set of solutions collected
so far.  Calling `retrieve' without any arguments (or only with the first
argument) will generate one (or more) solutions to the most recently
asked query.

KIF examples:
	 
  (retrieve (?x Person) (happy ?x)) 
	
will try to find the next happy person and store it in the returned 
query iterator.
	 
  (retrieve 10 (?x Person) (happy ?x))
	
will try to find 10 happy people.
	 
  (retrieve 10)
	
will try to find the next 10 happy people.
	 
  (retrieve all (?x Person) (happy ?x))
	
will find all happy people.
	 
  (retrieve all (?x Person))
	
will find all people.
	 
  (retrieve (?x Person) (or (happy ?x) (parent-of Fred ?x)))
	
will try to find the next person that is happy or has Fred as a parent.
	 
  (retrieve ((?x Person) (?y Person)) (parent-of ?x ?y))
	
will try to find the next pair of parent/child.
	 
  (retrieve all (?x Person)
            (exists (?y Person) (parent-of ?x ?y)))
	
will generate the set of all parents.  Note, that for these queries to run,
the class `Person', the relations `happy' and `parent-of', and the logic
constant `Fred' must already be defined (see `assert').

Use `(set/unset-feature goal-trace)' to en/disable goal tracing of the
inference engine.\")" (CL:FUNCTION %RETRIEVE)
    (CL:FUNCTION RETRIEVE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "CONSIFY-QUERY"
    "(DEFUN (CONSIFY-QUERY CONS) ((SELF QUERY-ITERATOR)))"
    (CL:FUNCTION CONSIFY-QUERY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LISTIFY LIST) ((SELF QUERY-ITERATOR)) :DOCUMENTATION \"Return the list of tuples generated by 'self'.
Tuples of arity=1 are represented directly by the first element,
tuples of arity>1 are represented by a CONS list.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LISTIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "FLUSH-INLINE-QUERY-CACHES"
    "(DEFUN FLUSH-INLINE-QUERY-CACHES ())"
    (CL:FUNCTION FLUSH-INLINE-QUERY-CACHES) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-CACHED-QUERY"
    "(DEFUN (MAKE-CACHED-QUERY QUERY-ITERATOR) ((VARIABLES CONS) (QUERYBODY CONS) (INPUTBINDINGS CONS) (OPTIONS CONS) (CACHEID SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION MAKE-CACHED-QUERY) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-CACHED-RETRIEVE"
    "(DEFUN (APPLY-CACHED-RETRIEVE CONS CONS) ((VARIABLES CONS) (QUERYBODY CONS) (INPUTBINDINGS CONS) (OPTIONS CONS) (CACHEID SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION APPLY-CACHED-RETRIEVE) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-CACHED-ASK"
    "(DEFUN (APPLY-CACHED-ASK BOOLEAN TRUTH-VALUE) ((INPUTVARIABLES CONS) (QUERYBODY CONS) (INPUTBINDINGS CONS) (OPTIONS CONS) (CACHEID SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION APPLY-CACHED-ASK) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-PROTOTYPE"
    "(DEFUN (GET-PROTOTYPE LOGIC-OBJECT) ((DESCRIPTION DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION GET-PROTOTYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION?"
    "(DEFUN (UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION? BOOLEAN) ((SUB DESCRIPTION) (SUPER DESCRIPTION)))"
    (CL:FUNCTION UNARY-DESCRIPTION-SPECIALIZES-DESCRIPTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "DESCRIPTION-SPECIALIZES-DESCRIPTION?"
    "(DEFUN (DESCRIPTION-SPECIALIZES-DESCRIPTION? BOOLEAN) ((SUBDESCRIPTION DESCRIPTION) (SUPERDESCRIPTION DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION DESCRIPTION-SPECIALIZES-DESCRIPTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "VECTOR-SATISFIES-DESCRIPTION?"
    "(DEFUN (VECTOR-SATISFIES-DESCRIPTION? BOOLEAN) ((VECTOR VECTOR) (DESCRIPTION DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION VECTOR-SATISFIES-DESCRIPTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "INSTANCE-SATISFIES-DESCRIPTION?"
    "(DEFUN (INSTANCE-SATISFIES-DESCRIPTION? BOOLEAN) ((INSTANCE OBJECT) (DESCRIPTION DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION INSTANCE-SATISFIES-DESCRIPTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-DESCRIPTION"
    "(DEFUN (COERCE-TO-DESCRIPTION DESCRIPTION) ((SELF OBJECT) (ORIGINAL OBJECT)))"
    (CL:FUNCTION COERCE-TO-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "SPECIALIZES?"
    "(DEFUN (SPECIALIZES? BOOLEAN) ((SUBOBJECT OBJECT) (SUPEROBJECT OBJECT)) :DOCUMENTATION \"Return TRUE if the description associated with `subObject'
specializes the description for `superObject'.  Return FALSE if we could
not prove that `subObject' specializes `superObject'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SPECIALIZES?) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-INSTANCE"
    "(DEFUN (COERCE-TO-INSTANCE LOGIC-OBJECT) ((SELF OBJECT) (ORIGINAL OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-TO-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-VECTOR"
    "(DEFUN (COERCE-TO-VECTOR VECTOR) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-TO-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "SATISFIES?"
    "(DEFUN (SATISFIES? BOOLEAN) ((INSTANCEORTUPLE OBJECT) (RELATIONREF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if `instanceOrTuple' satisfies the
definition of the relation `relationRef'.  `instanceOrTuple' can be a single
object, the name or surrogate of an object, or a collection (a list or vector)
of objects. `relationRef' can be a relation, description, surrogate or relation
name.  Return FALSE if we could not prove that `instanceOrTuple' satisfies
`relationRef'.\")" (CL:FUNCTION SATISFIES?) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-KAPPA?"
    "(DEFUN (APPLY-KAPPA? BOOLEAN) ((DESCRIPTION DESCRIPTION) (VECTOR VECTOR)) :PUBLIC? TRUE :DOCUMENTATION \"Apply (inherit) the description 'description'
to members of the vector 'vector'.  Return TRUE if no clash was detected.
Constraint propagation happens only if it is enabled prior to calling
'apply-kappa?'.\")" (CL:FUNCTION APPLY-KAPPA?) NULL)
   (DEFINE-FUNCTION-OBJECT "DISPLAY-SETTINGS"
    "(DEFUN (DISPLAY-SETTINGS STRING) ())" (CL:FUNCTION DISPLAY-SETTINGS)
    NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-QUERY"
    "(DEFUN STARTUP-QUERY () :PUBLIC? TRUE)" (CL:FUNCTION STARTUP-QUERY)
    NULL)
   (CL:LET* ((FUNCTION (LOOKUP-FUNCTION SYM-QUERY-LOGIC-STARTUP-QUERY)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
     SYM-QUERY-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "Startup-Query") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-QUERY ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-QUERY1)
    (HELP-STARTUP-QUERY2) (HELP-STARTUP-QUERY3) (HELP-STARTUP-QUERY4))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4) (HELP-STARTUP-QUERY5))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5) (HELP-STARTUP-QUERY6))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-QUERY7)
    (HELP-STARTUP-QUERY8) (HELP-STARTUP-QUERY9))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NORMAL-INFERENCE NORMAL-INFERENCE-LEVEL (NEW NORMAL-INFERENCE-LEVEL :KEYWORD :NORMAL))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL BACKTRACKING-INFERENCE BACKTRACKING-INFERENCE-LEVEL (NEW BACKTRACKING-INFERENCE-LEVEL :KEYWORD :BACKTRACKING))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL SUBSUMPTION-INFERENCE SUBSUMPTION-INFERENCE-LEVEL (NEW SUBSUMPTION-INFERENCE-LEVEL :KEYWORD :SUBSUMPTION))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL SHALLOW-INFERENCE SHALLOW-INFERENCE-LEVEL (NEW SHALLOW-INFERENCE-LEVEL :KEYWORD :SHALLOW))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL ASSERTION-INFERENCE ASSERTION-INFERENCE-LEVEL (NEW ASSERTION-INFERENCE-LEVEL :KEYWORD :ASSERTION))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL REFUTATION-INFERENCE REFUTATION-INFERENCE-LEVEL (NEW REFUTATION-INFERENCE-LEVEL :KEYWORD :REFUTATION))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *INFERENCELEVEL* NORMAL-INFERENCE-LEVEL NORMAL-INFERENCE :DOCUMENTATION \"Specifies the level/depth of inference applied
during a query.  Possible values are:
  :ASSERTION -- database lookup with no inheritance;
  :SHALLOW -- includes database lookup, computed predicates and specialists;
  :SUBSUMPTION -- shallow plus cached subsumption links and equality reasoning;
  :BACKTRACKING -- all of the above plus backtracking over rules;
  :NORMAL -- all of the above plus universal introduction;
  :REFUTATION -- all of the above plus disjunctive implication introduction and refutation.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DONTUSEDEFAULTKNOWLEDGE?* BOOLEAN FALSE :DOCUMENTATION \"Controls whether queries use default knowledge or not.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAXIMUM-BACKTRACKING-DEPTH* INTEGER *DEFAULT-MAXIMUM-DEPTH* :DOCUMENTATION \"Value for the maximum depth allowable during
backtrack search.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TYPE-CHECK-STRATEGY* KEYWORD :LOOKUP :DOCUMENTATION \"Determines whether there is a slow but thorough type test
when variables are bound, a fast but very shallow one, or none.  Values
are :NONE, :LOOKUP, :DISJOINT.  The default is ::LOOKUP.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DUPLICATE-SUBGOAL-STRATEGY* KEYWORD :DUPLICATE-GOALS :DOCUMENTATION \"Determines what kind of duplicate subgoal test to use.  Choices
are :DUPLICATE-RULES, :DUPLICATE-GOALS, and :DUPLICATE-GOALS-WITH-CACHING.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DUPLICATE-GOAL-SEARCH-DEPTH* INTEGER NULL :DOCUMENTATION \"Sets the maximum number of frames search looking for
a duplicate subgoal.  Default value is infinite.  Possibly this should
be replaced by a function that increases with depth of search.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DUPLICATE-RULE-SEARCH-DEPTH* INTEGER NULL :DOCUMENTATION \"Set limit on number of frames searched looking for
a duplicate rule.  Default value is infinite.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *GLOBALLY-CLOSED-COLLECTIONS?* BOOLEAN FALSE :DOCUMENTATION \"If TRUE, all collections are assumed to be closed.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *GENERATE-ALL-PROOFS?* BOOLEAN FALSE :DOCUMENTATION \"If TRUE, the backchainer follows all lines of proof
for each goal, rather than switching to a new goal once the first proof
of a goal is achieved.  The partial matcher sets this variable to
TRUE to force generation of proofs having possibly different
weights.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *QUERYITERATOR* QUERY-ITERATOR NULL :DOCUMENTATION \"Points to the query iterator for the currently executing query.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEFAULT-MAXIMUM-DEPTH* INTEGER 25 :DOCUMENTATION \"Possibly a good value for the maximum backtracking depth.
More testing is needed.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INITIAL-BACKTRACKING-DEPTH* INTEGER 5 :DOCUMENTATION \"Value of the initial depth used during an interative
deepening search.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ITERATIVE-DEEPENING-MODE?* BOOLEAN FALSE :DOCUMENTATION \"Default setting.  If TRUE, queries are evaluated
using iterative deepening from depth '*initial-backtracking-depth*'
to depth '*maximum-backtracking-depth*'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EMIT-THINKING-DOTS?* BOOLEAN TRUE :DOCUMENTATION \"When TRUE, various kinds of characters are
emitted to STANDARD-OUTPUT while PowerLoom is 'thinking'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *THINKING-DOT-COUNTER* INTEGER 0 :DOCUMENTATION \"Used to determine when to generate linefeeds
after forty-or-so thinking dots.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *THINKING-DOT-TABLE* (PROPERTY-LIST OF KEYWORD CHARACTER-WRAPPER) (NEW PROPERTY-LIST :THE-PLIST (BQUOTE (:UPCLASSIFY |&| (WRAP-LITERAL #\\U) :DOWNCLASSIFY |&| (WRAP-LITERAL #\\D) :PROPAGATE |&| (WRAP-LITERAL #\\P)))) :DOCUMENTATION \"Maps kind of thinking keywords to characters.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *BOOLEAN-VECTOR-INDEX* BOOLEAN-VECTOR-INDEX-NODE (NEW BOOLEAN-VECTOR-INDEX-NODE :THE-VECTOR (NEW BOOLEAN-VECTOR :ARRAY-SIZE 0)) :DOCUMENTATION \"Points to the head of a discrimination tree of containing
all boolean vectors.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CONTROL-FRAME-ID-COUNTER* INTEGER -1 :DOCUMENTATION \"Generates unique IDs for control frames.  Used
only for debugging.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *REVERSEPOLARITY?* BOOLEAN FALSE :PUBLIC? TRUE :DOCUMENTATION \"Signals atomic proposition provers that polarity is negative.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DUPLICATEINSTANCESCACHECROSSOVERPOINT* INTEGER 20 :DOCUMENTATION \"Point where a cache of generated instances in a 
description extension iterator is switched from a list to a hash table\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT *QUERY-THREAD-LIMIT* INTEGER 8 :DOCUMENTATION \"Maximum number of simultaneous query threads.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAXIMUM-QUERY-THREAD-OFFSET* INTEGER (1- *QUERY-THREAD-LIMIT*))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *FREE-QUERY-THREAD-OFFSETS* (LIST OF INTEGER-WRAPPER) (LIST) :DOCUMENTATION \"List of unused query thread offsets.\")")
    (CL:LET*
     ((I NULL-INTEGER)
      (ITER-062 (REVERSE (INTERVAL 0 *MAXIMUM-QUERY-THREAD-OFFSET*))))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I))
     (CL:LOOP WHILE (NEXT? ITER-062) DO (CL:SETQ I (%VALUE ITER-062))
      (PUSH *FREE-QUERY-THREAD-OFFSETS* (WRAP-INTEGER I))))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *QUERY-ITERATORS-VECTOR* (VECTOR OF QUERY-ITERATOR) (NEW VECTOR :ARRAY-SIZE *QUERY-THREAD-LIMIT*) :DOCUMENTATION \"Records currently active (unreleased) query iterators.\")")
    (REGISTER-NATIVE-NAME SYM-QUERY-LOGIC-ASK KWD-QUERY-COMMON-LISP
     KWD-QUERY-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MOST-RECENT-QUERY* QUERY-ITERATOR NULL)")
    (REGISTER-NATIVE-NAME SYM-QUERY-LOGIC-RETRIEVE KWD-QUERY-COMMON-LISP
     KWD-QUERY-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *QUERY-CACHE* (HASH-TABLE OF SYMBOL QUERY-ITERATOR) (NEW HASH-TABLE) :DOCUMENTATION \"Caches in-line queries, so that they
don't have to be reparsed and reoptimized each time they
are invoked.\")"))))
