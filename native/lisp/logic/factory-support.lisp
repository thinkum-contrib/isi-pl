;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-FACTORY-SUPPORT-LOGIC-ASK NULL)
(CL:DEFVAR KWD-FACTORY-SUPPORT-COMMON-LISP NULL)
(CL:DEFVAR KWD-FACTORY-SUPPORT-FUNCTION NULL)
(CL:DEFVAR SGT-FACTORY-SUPPORT-STELLA-MODULE NULL)
(CL:DEFVAR SGT-FACTORY-SUPPORT-STELLA-STRING-WRAPPER NULL)
(CL:DEFVAR KWD-FACTORY-SUPPORT-EXACT-NAME NULL)
(CL:DEFVAR SGT-FACTORY-SUPPORT-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-FACTORY-SUPPORT-STELLA-CONS NULL)
(CL:DEFVAR SGT-FACTORY-SUPPORT-LOGIC-NAMED-DESCRIPTION NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* EOL *MODULE* *EXCEPTIONHANDLERADDRESS*
  *EXCEPTION*))

;;; (DEFUN (ASK THREE-VALUED-BOOLEAN) ...)

(CL:DEFUN %ASK (PROPOSITION)
  "Perform inference to determine whether `proposition' is true.
Return TRUE if `proposition' was found to be true; return NULL otherwise.
KIF example: `(ask (happy Fred))' will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic constant
`Fred' and the relation (or slot) `happy' must already be defined (see
`assert').  Use `(set/unset-feature goal-trace)' to en/disable goal tracing
of the inference engine."
  (CL:PROGN
   (CL:LET* ((*PENDINGEXCEPTIONHANDLER?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PENDINGEXCEPTIONHANDLER?*))
    (CL:CATCH *EXCEPTIONHANDLERADDRESS*
     (CL:PROGN
      (CL:LET* ((TREE (COERCE-TO-TREE PROPOSITION)) (OPTIONS NIL))
       (FINALIZE-RELATIONS)
       (CL:IF (CL:NOT (CL:EQ TREE NULL))
        (CL:RETURN-FROM %ASK
         (RUN-YES-OR-NO-QUERY? (MAKE-QUERY NIL TREE NIL OPTIONS)))
        (CL:RETURN-FROM %ASK NULL)))
      (CL:SETQ *EXCEPTION* NULL))))
   (CL:WHEN (CL:NOT (CL:EQ *EXCEPTION* NULL))
    (CL:COND
     (TRUE (CL:LET* ((E *EXCEPTION*)) (HANDLE-QUERY-EXCEPTION E "ask"))))))
  NULL)

(CL:DEFMACRO ASK (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Perform inference to determine whether `proposition' is true.
Return TRUE if `proposition' was found to be true; return NULL otherwise.
KIF example: `(ask (happy Fred))' will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic constant
`Fred' and the relation (or slot) `happy' must already be defined (see
`assert').  Use `(set/unset-feature goal-trace)' to en/disable goal tracing
of the inference engine."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/ASK)) (CL:MACRO-FUNCTION
                                                    (CL:QUOTE ASK)))

;;; (DEFUN (FACTORY-GET-SUB-MODULE STRING) ...)

(CL:DEFUN FACTORY-GET-SUB-MODULE (PARENT INDEX)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PARENT) (CL:TYPE CL:FIXNUM INDEX))
  (CL:LET*
   ((CONTEXT NULL)
    (ITER-000
     (%THE-CONS-LIST (%CHILD-CONTEXTS (GET-STELLA-MODULE PARENT TRUE)))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ CONTEXT (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (ISA? CONTEXT SGT-FACTORY-SUPPORT-STELLA-MODULE)
     (CL:WHEN (CL:= INDEX 0)
      (CL:RETURN-FROM FACTORY-GET-SUB-MODULE
       (%MODULE-FULL-NAME (CAST CONTEXT SGT-FACTORY-SUPPORT-STELLA-MODULE))))
     (CL:SETQ INDEX (CL:1- INDEX)))))
  NULL)

(CL:DEFUN FACTORY-GET-SUB-MODULE-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (FACTORY-GET-SUB-MODULE (%WRAPPER-VALUE (%%VALUE ARGUMENTS))
      (%WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS))))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:IF (CL:NOT (CL:EQ RESULT NULL)) (WRAP-STRING RESULT) NULL)))

;;; (DEFUN (FACTORY-GET-MODULE-NAME STRING) ...)

(CL:DEFUN FACTORY-GET-MODULE-NAME (MODULE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULE))
  (%MODULE-NAME (GET-STELLA-MODULE MODULE TRUE)))

(CL:DEFUN FACTORY-GET-MODULE-NAME-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT (FACTORY-GET-MODULE-NAME (%WRAPPER-VALUE (%%VALUE ARGUMENTS)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:IF (CL:NOT (CL:EQ RESULT NULL)) (WRAP-STRING RESULT) NULL)))

;;; (DEFUN (FACTORY-GET-SUB-MODULE-COUNT INTEGER) ...)

(CL:DEFUN FACTORY-GET-SUB-MODULE-COUNT (PARENT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PARENT))
  (CL:LET* ((COUNT 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT))
   (CL:LET*
    ((CONTEXT NULL)
     (ITER-000
      (%THE-CONS-LIST (%CHILD-CONTEXTS (GET-STELLA-MODULE PARENT TRUE)))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ CONTEXT (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (ISA? CONTEXT SGT-FACTORY-SUPPORT-STELLA-MODULE)
      (CL:SETQ COUNT (CL:1+ COUNT)))))
   COUNT))

(CL:DEFUN FACTORY-GET-SUB-MODULE-COUNT-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (FACTORY-GET-SUB-MODULE-COUNT (%WRAPPER-VALUE (%%VALUE ARGUMENTS)))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM RESULT))
   (CL:IF (DEFINED? RESULT) (WRAP-INTEGER RESULT) NULL)))

;;; (DEFUN (FACTORY-GET-SUB-MODULE-POSITION INTEGER) ...)

(CL:DEFUN FACTORY-GET-SUB-MODULE-POSITION (PARENT CHILD)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PARENT CHILD))
  (CL:LET* ((POSITION 0) (CHILDMODULE (GET-STELLA-MODULE CHILD TRUE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
   (CL:LET*
    ((CONTEXT NULL)
     (ITER-000
      (%THE-CONS-LIST (%CHILD-CONTEXTS (GET-STELLA-MODULE PARENT TRUE)))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ CONTEXT (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:WHEN (ISA? CONTEXT SGT-FACTORY-SUPPORT-STELLA-MODULE)
      (CL:IF (CL:EQ CONTEXT CHILDMODULE)
       (CL:RETURN-FROM FACTORY-GET-SUB-MODULE-POSITION POSITION)
       (CL:SETQ POSITION (CL:1+ POSITION))))))
   -1))

(CL:DEFUN FACTORY-GET-SUB-MODULE-POSITION-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (FACTORY-GET-SUB-MODULE-POSITION (%WRAPPER-VALUE (%%VALUE ARGUMENTS))
      (%WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS))))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM RESULT))
   (CL:IF (DEFINED? RESULT) (WRAP-INTEGER RESULT) NULL)))

;;; (DEFUN (FACTORY-EVALUATE-LOGIC-COMMAND-IN-MODULE STRING TYPE-SPEC BOOLEAN) ...)

(CL:DEFUN FACTORY-EVALUATE-LOGIC-COMMAND-IN-MODULE (COMMAND
                                                    MODULENAME
                                                    FINALIZE?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING COMMAND MODULENAME))
  (CL:LET* ((MODULE (GET-STELLA-MODULE MODULENAME FALSE)))
   (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE *MODULE*))
   (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:LET* ((RESULT NULL) (TYPE NULL) (ERROR? FALSE))
     (CL:MULTIPLE-VALUE-SETQ (RESULT TYPE ERROR?)
      (EVALUATE-LOGIC-COMMAND
       (READ-S-EXPRESSION (NEW-INPUT-STRING-STREAM COMMAND)) FINALIZE?))
     (CL:COND ((CL:EQ RESULT NULL) (CL:VALUES "" TYPE ERROR?))
      ((STRING? RESULT)
       (CL:VALUES
        (%WRAPPER-VALUE
         (CAST RESULT SGT-FACTORY-SUPPORT-STELLA-STRING-WRAPPER))
        TYPE ERROR?))
      (CL:T
       (CL:LET*
        ((RESULTSTREAM (NEW-OUTPUT-STRING-STREAM))
         (NATIVESTREAM (%NATIVE-STREAM RESULTSTREAM)))
        (CL:LET* ((*PRINTREADABLY?* TRUE) (*PRINTPRETTY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?* *PRINTPRETTY?*))
         (CL:WHEN (USE-CL-CONSES?)
          (CL:LET ((CL:*PRINT-PRETTY* CL:T)) (CL:PRIN1 RESULT NATIVESTREAM)
           (SETQ RESULT NULL)))
         (CL:WHEN (CL:NOT (CL:EQ RESULT NULL))
          (%%PRINT-STREAM (%NATIVE-STREAM RESULTSTREAM) RESULT)))
        (CL:VALUES (THE-STRING-READER RESULTSTREAM) TYPE ERROR?))))))))

;;; (DEFUN (FACTORY-FIND-PROPOSITIONS STRING) ...)

(CL:DEFUN FACTORY-FIND-PROPOSITIONS (NAME MODE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  (CL:LET* ((RESULT NULL)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:COND
    ((CL:EQ MODE KWD-FACTORY-SUPPORT-EXACT-NAME)
     (CL:LET* ((THING (GET-OBJECT NAME NULL)))
      (CL:COND
       ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE THING)
         SGT-FACTORY-SUPPORT-LOGIC-PROPOSITION)
        (CL:PROGN
         (CL:WHEN (CL:EQ (HOME-MODULE THING) *MODULE*)
          (CL:LET* ((*PRETTYPRINTLOGICALFORMS?* TRUE))
           (CL:DECLARE (CL:SPECIAL *PRETTYPRINTLOGICALFORMS?*))
           (CL:SETQ RESULT (STRINGIFY THING)))
          (CL:COND
           ((CL:= (STRING-SEARCH RESULT "|P|" 0) 0)
            (CL:SETQ RESULT (SUBSEQUENCE RESULT 3 NULL-INTEGER)))
           ((CL:= (STRING-SEARCH RESULT "|P~|" 0) 0)
            (CL:SETQ RESULT
             (CONCATENATE "(not " (SUBSEQUENCE RESULT 4 NULL-INTEGER) ")")))
           ((CL:= (STRING-SEARCH RESULT "|P?|" 0) 0)
            (CL:SETQ RESULT (SUBSEQUENCE RESULT 4 NULL-INTEGER)))))))
       (CL:T))))
    (CL:T))
   RESULT))

(CL:DEFUN FACTORY-FIND-PROPOSITIONS-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (FACTORY-FIND-PROPOSITIONS (%WRAPPER-VALUE (%%VALUE ARGUMENTS))
      (%%VALUE (%%REST ARGUMENTS)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:IF (CL:NOT (CL:EQ RESULT NULL)) (WRAP-STRING RESULT) NULL)))

;;; (DEFUN (FACTORY-FIND-RELATIONS STRING) ...)

(CL:DEFUN FACTORY-FIND-RELATIONS (NAME MODE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  (CL:LET* ((RESULT NULL)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:COND
    ((CL:EQ MODE KWD-FACTORY-SUPPORT-EXACT-NAME)
     (CL:LET* ((THING (GET-OBJECT NAME NULL)))
      (CL:COND
       ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE THING)
         SGT-FACTORY-SUPPORT-LOGIC-NAMED-DESCRIPTION)
        (CL:PROGN
         (CL:WHEN (CL:EQ (HOME-MODULE THING) *MODULE*)
          (CL:LET* ((*PRINTPRETTY?* TRUE) (*PRINTREADABLY?* TRUE))
           (CL:DECLARE (CL:SPECIAL *PRINTPRETTY?* *PRINTREADABLY?*))
           (CL:LET* ((STREAM (NEW-OUTPUT-STRING-STREAM)))
            (PRETTY-PRINT-RELATION-DEFINITION-TREE
             (CAST
              (READ-S-EXPRESSION-FROM-STRING
               (%RELATION-STRINGIFIED-SOURCE THING))
              SGT-FACTORY-SUPPORT-STELLA-CONS)
             STREAM)
            (CL:SETQ RESULT (THE-STRING-READER STREAM)))))))
       (CL:T))))
    (CL:T))
   RESULT))

(CL:DEFUN FACTORY-FIND-RELATIONS-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (FACTORY-FIND-RELATIONS (%WRAPPER-VALUE (%%VALUE ARGUMENTS))
      (%%VALUE (%%REST ARGUMENTS)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:IF (CL:NOT (CL:EQ RESULT NULL)) (WRAP-STRING RESULT) NULL)))

;;; (DEFUN PRETTY-PRINT-RULESET ...)

(CL:DEFUN PRETTY-PRINT-RULESET (RULESET STREAM)
  (CL:LET*
   ((SOURCE
     (CL:THE CL:SIMPLE-STRING (CL:COPY-SEQ (%STRINGIFIED-SOURCE RULESET))))
    (PARENS NIL) (TEMPSTREAM (NEW-OUTPUT-STRING-STREAM))
    (NATIVETEMPSTREAM (%NATIVE-STREAM TEMPSTREAM)) (USOURCE NIL) (INDENT "  ")
    (COMPLEXRULE? FALSE))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SOURCE INDENT))
   (CL:LET*
    ((I NULL) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH SOURCE)))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:WHEN
      (CL:AND
       (MEMBER? "()<>{}"
        (CL:LET ((SELF SOURCE) (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))))
       (CL:NOT
        (CL:AND
         (CL:EQL
          (CL:LET ((SELF SOURCE) (POSITION I))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION)))
          #\>)
         (CL:EQL
          (CL:LET ((SELF SOURCE) (POSITION (CL:1- I)))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION)))
          #\=)
         (CL:EQL
          (CL:LET ((SELF SOURCE) (POSITION (CL:- I 2)))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION)))
          #\=))))
      (CL:SETQ PARENS
       (CONS
        (WRAP-CHARACTER
         (CL:LET ((SELF SOURCE) (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))
        PARENS))
      (CL:LET
       ((SELF SOURCE)
        (CH
         (CL:IF
          (MEMBER? "(<{"
           (CL:LET ((SELF SOURCE) (POSITION I))
            (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
             (CL:TYPE CL:FIXNUM POSITION))
            (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
             (CL:THE CL:FIXNUM POSITION))))
          #\( #\)))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (SETF
        (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))
        (CL:THE CL:CHARACTER CH))))))
   (CL:SETQ PARENS (REVERSE PARENS))
   (CL:LET* ((*PRINTPRETTY?* TRUE) (*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTPRETTY?* *PRINTREADABLY?*))
    (CL:LET* ((*MODULE* (HOME-MODULE RULESET)) (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CL:SETQ USOURCE
      (CAST
       (READ-S-EXPRESSION
        (NEW-INPUT-STRING-STREAM
         (CL:LET ((S SOURCE)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
          (CL:THE CL:SIMPLE-STRING S))))
       SGT-FACTORY-SUPPORT-STELLA-CONS))
     (%%PRINT-STREAM (%NATIVE-STREAM TEMPSTREAM) "(" (%%VALUE USOURCE) " "
      (%%VALUE (%%REST USOURCE)) EOL)
     (CL:SETQ USOURCE (%%REST (%%REST USOURCE)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ USOURCE NIL)) DO
      (CL:SETQ COMPLEXRULE? FALSE)
      (%%PRINT-STREAM (%NATIVE-STREAM TEMPSTREAM) INDENT (%%VALUE USOURCE))
      (CL:WHEN (CONS? (%%VALUE USOURCE))
       (%%PRINT-STREAM (%NATIVE-STREAM TEMPSTREAM) EOL)
       (CL:SETQ COMPLEXRULE? TRUE))
      (%%PRINT-STREAM (%NATIVE-STREAM TEMPSTREAM) INDENT
       (%%VALUE (%%REST USOURCE)) " " (%%VALUE (%%REST (%%REST USOURCE))))
      (CL:SETQ USOURCE (%%REST (%%REST (%%REST USOURCE))))
      (CL:WHEN (CL:NOT (CL:EQ USOURCE NIL))
       (%%PRINT-STREAM (%NATIVE-STREAM TEMPSTREAM) EOL)
       (CL:WHEN (CL:OR COMPLEXRULE? (CONS? (%%VALUE USOURCE)))
        (%%PRINT-STREAM (%NATIVE-STREAM TEMPSTREAM) EOL))))
     (%%PRINT-STREAM (%NATIVE-STREAM TEMPSTREAM) ")")))
   (CL:SETQ SOURCE
    (CL:THE CL:SIMPLE-STRING (CL:COPY-SEQ (THE-STRING-READER TEMPSTREAM))))
   (CL:LET*
    ((I NULL) (ITER-001 0)
     (UPPER-BOUND-001 (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH SOURCE)))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 UPPER-BOUND-001 I))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:WHEN
      (CL:AND
       (MEMBER? "()"
        (CL:LET ((SELF SOURCE) (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:AREF (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))))
       (CL:NOT (CL:EQ PARENS NIL)))
      (CL:LET* ((HEAD-000 (%%VALUE PARENS))) (CL:SETQ PARENS (%%REST PARENS))
       (CL:LET ((SELF SOURCE) (CH (%WRAPPER-VALUE HEAD-000)) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (SETF
         (CL:AREF (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION))
         (CL:THE CL:CHARACTER CH)))))))
   (%%PRINT-STREAM (%NATIVE-STREAM STREAM) SOURCE)))

;;; (DEFUN (FACTORY-FIND-REWRITE-RULES STRING) ...)

(CL:DEFUN FACTORY-FIND-REWRITE-RULES (NAME MODE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  (CL:LET* ((RESULT NULL)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:COND
    ((CL:EQ MODE KWD-FACTORY-SUPPORT-EXACT-NAME)
     (CL:LET* ((RULESET (LOOKUP-REWRITE-RULESET (INTERN-SYMBOL NAME))))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ RULESET NULL))
        (CL:EQ (HOME-MODULE RULESET) *MODULE*))
       (CL:LET* ((STREAM (NEW-OUTPUT-STRING-STREAM)))
        (PRETTY-PRINT-RULESET RULESET STREAM)
        (CL:SETQ RESULT (THE-STRING-READER STREAM))))))
    (CL:T))
   RESULT))

(CL:DEFUN FACTORY-FIND-REWRITE-RULES-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (FACTORY-FIND-REWRITE-RULES (%WRAPPER-VALUE (%%VALUE ARGUMENTS))
      (%%VALUE (%%REST ARGUMENTS)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:IF (CL:NOT (CL:EQ RESULT NULL)) (WRAP-STRING RESULT) NULL)))

(CL:DEFUN STARTUP-FACTORY-SUPPORT ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (CL:SETQ SYM-FACTORY-SUPPORT-LOGIC-ASK
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ASK" NULL 0))
    (CL:SETQ KWD-FACTORY-SUPPORT-COMMON-LISP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
    (CL:SETQ KWD-FACTORY-SUPPORT-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ SGT-FACTORY-SUPPORT-STELLA-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
      (GET-STELLA-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ SGT-FACTORY-SUPPORT-STELLA-STRING-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-WRAPPER"
      (GET-STELLA-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ KWD-FACTORY-SUPPORT-EXACT-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXACT-NAME" NULL 2))
    (CL:SETQ SGT-FACTORY-SUPPORT-LOGIC-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
    (CL:SETQ SGT-FACTORY-SUPPORT-STELLA-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-STELLA-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ SGT-FACTORY-SUPPORT-LOGIC-NAMED-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "ASK"
     "(DEFUN (ASK THREE-VALUED-BOOLEAN) ((PROPOSITION PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Perform inference to determine whether `proposition' is true.
Return TRUE if `proposition' was found to be true; return NULL otherwise.
KIF example: `(ask (happy Fred))' will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic constant
`Fred' and the relation (or slot) `happy' must already be defined (see
`assert').  Use `(set/unset-feature goal-trace)' to en/disable goal tracing
of the inference engine.\")" (CL:FUNCTION %ASK) NULL)
    (DEFINE-FUNCTION-OBJECT "FACTORY-GET-SUB-MODULE"
     "(DEFUN (FACTORY-GET-SUB-MODULE STRING) ((PARENT STRING) (INDEX INTEGER)) :PUBLIC? TRUE :COMMAND? TRUE :LISP-MACRO? FALSE)"
     (CL:FUNCTION FACTORY-GET-SUB-MODULE)
     (CL:FUNCTION FACTORY-GET-SUB-MODULE-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "FACTORY-GET-MODULE-NAME"
     "(DEFUN (FACTORY-GET-MODULE-NAME STRING) ((MODULE STRING)) :PUBLIC? TRUE :COMMAND? TRUE :LISP-MACRO? FALSE)"
     (CL:FUNCTION FACTORY-GET-MODULE-NAME)
     (CL:FUNCTION FACTORY-GET-MODULE-NAME-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "FACTORY-GET-SUB-MODULE-COUNT"
     "(DEFUN (FACTORY-GET-SUB-MODULE-COUNT INTEGER) ((PARENT STRING)) :PUBLIC? TRUE :COMMAND? TRUE :LISP-MACRO? FALSE)"
     (CL:FUNCTION FACTORY-GET-SUB-MODULE-COUNT)
     (CL:FUNCTION FACTORY-GET-SUB-MODULE-COUNT-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "FACTORY-GET-SUB-MODULE-POSITION"
     "(DEFUN (FACTORY-GET-SUB-MODULE-POSITION INTEGER) ((PARENT STRING) (CHILD STRING)) :PUBLIC? TRUE :COMMAND? TRUE :LISP-MACRO? FALSE)"
     (CL:FUNCTION FACTORY-GET-SUB-MODULE-POSITION)
     (CL:FUNCTION FACTORY-GET-SUB-MODULE-POSITION-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "FACTORY-EVALUATE-LOGIC-COMMAND-IN-MODULE"
     "(DEFUN (FACTORY-EVALUATE-LOGIC-COMMAND-IN-MODULE STRING TYPE-SPEC BOOLEAN) ((COMMAND STRING) (MODULENAME STRING) (FINALIZE? BOOLEAN)))"
     (CL:FUNCTION FACTORY-EVALUATE-LOGIC-COMMAND-IN-MODULE) NULL)
    (DEFINE-FUNCTION-OBJECT "FACTORY-FIND-PROPOSITIONS"
     "(DEFUN (FACTORY-FIND-PROPOSITIONS STRING) ((NAME STRING) (MODE KEYWORD)) :PUBLIC? TRUE :COMMAND? TRUE :LISP-MACRO? FALSE)"
     (CL:FUNCTION FACTORY-FIND-PROPOSITIONS)
     (CL:FUNCTION FACTORY-FIND-PROPOSITIONS-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "FACTORY-FIND-RELATIONS"
     "(DEFUN (FACTORY-FIND-RELATIONS STRING) ((NAME STRING) (MODE KEYWORD)) :PUBLIC? TRUE :COMMAND? TRUE :LISP-MACRO? FALSE)"
     (CL:FUNCTION FACTORY-FIND-RELATIONS)
     (CL:FUNCTION FACTORY-FIND-RELATIONS-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-RULESET"
     "(DEFUN PRETTY-PRINT-RULESET ((RULESET /ONTOMORPH/REWRITE-RULESET) (STREAM OUTPUT-STREAM)))"
     (CL:FUNCTION PRETTY-PRINT-RULESET) NULL)
    (DEFINE-FUNCTION-OBJECT "FACTORY-FIND-REWRITE-RULES"
     "(DEFUN (FACTORY-FIND-REWRITE-RULES STRING) ((NAME STRING) (MODE KEYWORD)) :PUBLIC? TRUE :COMMAND? TRUE :LISP-MACRO? FALSE)"
     (CL:FUNCTION FACTORY-FIND-REWRITE-RULES)
     (CL:FUNCTION FACTORY-FIND-REWRITE-RULES-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "STARTUP-FACTORY-SUPPORT"
     "(DEFUN STARTUP-FACTORY-SUPPORT () :PUBLIC? TRUE)" NULL NULL))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (REGISTER-NATIVE-NAME SYM-FACTORY-SUPPORT-LOGIC-ASK
     KWD-FACTORY-SUPPORT-COMMON-LISP KWD-FACTORY-SUPPORT-FUNCTION))))
