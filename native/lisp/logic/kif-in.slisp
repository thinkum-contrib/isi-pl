;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; kif-in.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-KIF-IN-LOGIC-PARSE-TREE NULL)
(CL:DEFVAR KWD-KIF-IN-ERROR NULL)
(CL:DEFVAR SGT-KIF-IN-STELLA-CONS NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-ISA NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-EXISTS NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-FORALL NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-SETOFALL NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-KAPPA NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-THE NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-THE-ONLY NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-TRUE NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-AND NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-= NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-IF NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-NOT NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-<= NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-OR NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-=> NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-<=>> NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-<<=> NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-<<=>> NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-<~> NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-<~>> NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-<<~> NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-<<~>> NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-=>> NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-<<= NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-~> NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-<~ NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-~>> NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-<<~ NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-ABOUT NULL)
(CL:DEFVAR SYM-KIF-IN-PL-KERNEL-KB-VALUE NULL)
(CL:DEFVAR KWD-KIF-IN-DIRECTION NULL)
(CL:DEFVAR KWD-KIF-IN-BACKWARD NULL)
(CL:DEFVAR KWD-KIF-IN-FORWARD NULL)
(CL:DEFVAR KWD-KIF-IN-CONFIDENCE-LEVEL NULL)
(CL:DEFVAR KWD-KIF-IN-DEFAULT NULL)
(CL:DEFVAR KWD-KIF-IN-ABOUT NULL)
(CL:DEFVAR SYM-KIF-IN-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-FAIL NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-<=> NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-LAMBDA NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-COND NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-SETOF NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-LISTOF NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-WHERE NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-ALWAYS NULL)
(CL:DEFVAR KWD-KIF-IN-KIF NULL)
(CL:DEFVAR KWD-KIF-IN-STELLA NULL)
(CL:DEFVAR KWD-KIF-IN-PREFIX-STELLA NULL)
(CL:DEFVAR KWD-KIF-IN-MELD NULL)
(CL:DEFVAR KWD-KIF-IN-LOOM NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-IN-DIALECT NULL)
(CL:DEFVAR KWD-KIF-IN-COMMON-LISP NULL)
(CL:DEFVAR KWD-KIF-IN-FUNCTION NULL)
(CL:DEFVAR SYM-KIF-IN-LOGIC-STARTUP-KIF-IN NULL)
(CL:DEFVAR SYM-KIF-IN-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* NIL EOL))

;;; (DEFUN (QUESTION-MARK-SYMBOL? BOOLEAN) ...)

(CL:DEFUN QUESTION-MARK-SYMBOL? (SYMBOL)
  (CL:AND (SYMBOL? SYMBOL)
   (CL:EQL
    (CL:LET ((SELF (%SYMBOL.SYMBOL-NAME SYMBOL)) (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
      (CL:THE CL:FIXNUM POSITION)))
    #\?)))

;;; (DEFUN (SEQUENCE-VARIABLE-SYMBOL? BOOLEAN) ...)

(CL:DEFUN SEQUENCE-VARIABLE-SYMBOL? (SELF)
  (CL:SETQ SELF SELF)
  CL:NIL)

;;; (DEFGLOBAL *AUTOMATIC-INSTANCE-CHARACTER* ...)

(CL:DEFVAR *AUTOMATIC-INSTANCE-CHARACTER* #\$
  "Character that identifies variables representing
instances named by the system.")

;;; (DEFUN (AUTOMATIC-INSTANCE-SYMBOL? BOOLEAN) ...)

(CL:DEFUN AUTOMATIC-INSTANCE-SYMBOL? (SYMBOL)
  (CL:AND (SYMBOL? SYMBOL)
   (CL:EQL
    (CL:LET ((SELF (%SYMBOL.SYMBOL-NAME SYMBOL)) (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
      (CL:THE CL:FIXNUM POSITION)))
    *AUTOMATIC-INSTANCE-CHARACTER*)))

;;; (DEFUN (KIF-SYMBOL-TO-STELLA-SYMBOL GENERALIZED-SYMBOL) ...)

(CL:DEFUN KIF-SYMBOL-TO-STELLA-SYMBOL (SYMBOL)
  (CL:IF
   (CL:OR (QUESTION-MARK-SYMBOL? SYMBOL)
    (AUTOMATIC-INSTANCE-SYMBOL? SYMBOL))
   SYMBOL (COERCE-TO-BOUND-OR-LOCAL-SURROGATE SYMBOL)))

;;; (DEFUN (KIF-VARIABLE-TO-STELLA-VARIABLE SYMBOL) ...)

(CL:DEFUN KIF-VARIABLE-TO-STELLA-VARIABLE (VARIABLE)
  (CL:COND
   ((SUBTYPE-OF-SYMBOL? (SAFE-PRIMARY-TYPE VARIABLE))
    (CL:PROGN
     (CL:WHEN (CL:NOT (QUESTION-MARK-SYMBOL? VARIABLE))
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "PARSING ERROR: Missing question mark on KIF variable: `"
         VARIABLE "'." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-KIF-IN-ERROR))
       (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
     (KIF-SYMBOL-TO-STELLA-SYMBOL VARIABLE)))
   (CL:T
    (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
       "PARSING ERROR: Illegal value in KIF expression where symbol expected `"
       VARIABLE "'." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-KIF-IN-ERROR))
     (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-001)))))))

;;; (DEFUN (KIF-VARIABLE-DECLARATION? BOOLEAN) ...)

(CL:DEFUN KIF-VARIABLE-DECLARATION? (TREE)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-KIF-IN-STELLA-CONS)
     (CL:PROGN
      (CL:CASE (LENGTH TREE)
       (1
        (CL:RETURN-FROM KIF-VARIABLE-DECLARATION?
         (QUESTION-MARK-SYMBOL? (%%VALUE TREE))))
       (2
        (CL:RETURN-FROM KIF-VARIABLE-DECLARATION?
         (CL:AND (QUESTION-MARK-SYMBOL? (%%VALUE TREE))
          (SYMBOL? (%%VALUE (%%REST TREE)))
          (CL:NOT (QUESTION-MARK-SYMBOL? (%%VALUE (%%REST TREE)))))))
       (CL:OTHERWISE
        (CL:RETURN-FROM KIF-VARIABLE-DECLARATION? CL:NIL)))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN (QUESTION-MARK-SYMBOL? TREE)
       (CL:RETURN-FROM KIF-VARIABLE-DECLARATION? CL:T))))
    (CL:T (CL:RETURN-FROM KIF-VARIABLE-DECLARATION? CL:NIL))))
  CL:NIL)

;;; (DEFUN (ONE-KIF-VARIABLE-DECLARATION-TO-STELLA OBJECT) ...)

(CL:DEFUN ONE-KIF-VARIABLE-DECLARATION-TO-STELLA (TREE)
  (CL:WHEN (CL:NOT (KIF-VARIABLE-DECLARATION? TREE))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "PARSING ERROR: Illegal KIF variable declaration: `" TREE "'."
      EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-KIF-IN-ERROR))
    (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-KIF-IN-STELLA-CONS)
    (CL:PROGN
     (FIRST-SETTER TREE
      (KIF-VARIABLE-TO-STELLA-VARIABLE (%%VALUE TREE)))
     (CL:IF (CL:NOT (CL:EQ (%%VALUE (%%REST TREE)) NULL))
      (CL:PROGN
       (SECOND-SETTER TREE
        (KIF-SYMBOL-TO-STELLA-SYMBOL (%%VALUE (%%REST TREE))))
       (CONS SYM-KIF-IN-STELLA-ISA (CONCATENATE TREE NIL)))
      (KIF-VARIABLE-TO-STELLA-VARIABLE (%%VALUE TREE)))))
   (CL:T (KIF-VARIABLE-TO-STELLA-VARIABLE TREE))))

;;; (DEFUN (STELLA-VARIABLE-DECLARATIONS? BOOLEAN) ...)

(CL:DEFUN STELLA-VARIABLE-DECLARATIONS? (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-KIF-IN-STELLA-CONS)
    (CL:PROGN
     (CL:WHEN
      (CL:OR (CL:EQ (%%VALUE TREE) SYM-KIF-IN-STELLA-ISA)
       (CL:AND (CONS? (%%VALUE TREE))
        (CL:EQ (%%VALUE (%%VALUE TREE)) SYM-KIF-IN-STELLA-ISA)))
      (CL:RETURN-FROM STELLA-VARIABLE-DECLARATIONS? CL:T))))
   (CL:T))
  CL:NIL)

;;; (DEFUN (KIF-VARIABLE-DECLARATIONS-TO-STELLA CONS) ...)

(CL:DEFUN KIF-VARIABLE-DECLARATIONS-TO-STELLA (TREE ERROR?)
  (CL:IF (STELLA-VARIABLE-DECLARATIONS? TREE) (CL:PROGN TREE)
   (CL:IF (KIF-VARIABLE-DECLARATION? TREE)
    (CL:PROGN (CONS (ONE-KIF-VARIABLE-DECLARATION-TO-STELLA TREE) NIL))
    (CL:LET* ((TEST-VALUE-000 CL:NIL))
     (CL:SETQ TEST-VALUE-000 (CONS? TREE))
     (CL:WHEN TEST-VALUE-000
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET* ((D NULL) (ITER-000 TREE))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ D (%%VALUE ITER-000))
         (CL:WHEN (CL:NOT (KIF-VARIABLE-DECLARATION? D))
          (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
     (CL:IF TEST-VALUE-000
      (CL:PROGN
       (CL:LET* ((IT (ALLOCATE-ITERATOR TREE)))
        (CL:LOOP WHILE (NEXT? IT) DO
         (VALUE-SETTER IT
          (ONE-KIF-VARIABLE-DECLARATION-TO-STELLA
           (%CONS-ITERATOR.VALUE IT)))))
       TREE)
      (CL:PROGN
       (CL:WHEN ERROR?
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
           "PARSING ERROR: Illegal declaration syntax: `" TREE "'."
           EOL)
          (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-KIF-IN-ERROR))
         (CL:ERROR
          (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
       NULL))))))

;;; (DEFUN (KIF-QUANTIFIER-SYMBOL? BOOLEAN) ...)

(CL:DEFUN KIF-QUANTIFIER-SYMBOL? (SELF)
  (CL:COND
   ((CL:OR (CL:EQ SELF SYM-KIF-IN-STELLA-EXISTS)
     (CL:EQ SELF SYM-KIF-IN-STELLA-FORALL)
     (CL:EQ SELF SYM-KIF-IN-LOGIC-SETOFALL)
     (CL:EQ SELF SYM-KIF-IN-LOGIC-KAPPA)
     (CL:EQ SELF SYM-KIF-IN-LOGIC-THE))
    CL:T)
   (CL:T CL:NIL)))

;;; (DEFUN (KIF-THE-TO-STELLA-THE-ONLY CONS) ...)

(CL:DEFUN KIF-THE-TO-STELLA-THE-ONLY (TREE)
  (CL:SETQ TREE (KIF-SETOFALL-TO-STELLA-SETOFALL TREE))
  (FIRST-SETTER TREE SYM-KIF-IN-LOGIC-THE-ONLY)
  TREE)

;;; (DEFUN (KIF-SETOFALL-TO-STELLA-SETOFALL CONS) ...)

(CL:DEFUN KIF-SETOFALL-TO-STELLA-SETOFALL (TREE)
  (CL:WHEN
   (CL:NOT (CL:OR (CL:= (LENGTH TREE) 3) (CL:= (LENGTH TREE) 2)))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "PARSING ERROR: Illegal `" (%%VALUE TREE) "' tree: `" TREE "'."
      EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-KIF-IN-ERROR))
    (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:LET*
   ((DECLARATIONS
     (KIF-VARIABLE-DECLARATIONS-TO-STELLA (%%VALUE (%%REST TREE))
      CL:NIL)))
   (CL:COND
    ((CL:EQ DECLARATIONS NULL)
     (CL:SETQ DECLARATIONS
      (KIF-TERM-TO-UNTYPED-STELLA-TERM (%%VALUE (%%REST TREE)))))
    ((CL:> (LENGTH DECLARATIONS) 1)
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
        "PARSING ERROR: Too many declarations in SETOFALL expression."
        EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-KIF-IN-ERROR))
      (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-001))))))
   (SECOND-SETTER TREE DECLARATIONS))
  (CL:WHEN (CL:NOT (CL:EQ (%%VALUE (%%REST (%%REST TREE))) NULL))
   (THIRD-SETTER TREE
    (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
     (%%VALUE (%%REST (%%REST TREE))))))
  TREE)

;;; (DEFUN (KIF-KAPPA-TO-STELLA-KAPPA CONS) ...)

(CL:DEFUN KIF-KAPPA-TO-STELLA-KAPPA (TREE)
  (CL:WHEN (CL:< (LENGTH TREE) 2)
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "PARSING ERROR: Illegal KAPPA tree: `" TREE "'." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-KIF-IN-ERROR))
    (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:LET* ((SENTENCES (%%REST (%%REST TREE))))
   (SECOND-SETTER TREE
    (KIF-VARIABLE-DECLARATIONS-TO-STELLA (%%VALUE (%%REST TREE)) CL:T))
   (CL:LET* ((IT (ALLOCATE-ITERATOR SENTENCES)))
    (CL:LOOP WHILE (NEXT? IT) DO
     (VALUE-SETTER IT
      (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
       (%CONS-ITERATOR.VALUE IT)))))
   (CL:CASE (LENGTH SENTENCES)
    (0
     (CL:SETF (%%REST (%%REST TREE))
      (CONS SYM-KIF-IN-STELLA-TRUE NIL)))
    (1 (THIRD-SETTER TREE (%%VALUE (%%REST (%%REST TREE)))))
    (CL:OTHERWISE
     (CL:SETF (%%REST (%%REST TREE))
      (CONS (CONS SYM-KIF-IN-STELLA-AND (CONCATENATE SENTENCES NIL))
       NIL))))
   TREE))

;;; (DEFUN (KIF-LAMBDA-TO-STELLA-KAPPA CONS) ...)

(CL:DEFUN KIF-LAMBDA-TO-STELLA-KAPPA (TREE)
  (CL:LET*
   ((VALUEVARIABLE (GENSYM "?v")) (VARIABLES (%%VALUE (%%REST TREE)))
    (TERM (%%VALUE (%%REST (%%REST TREE))))
    (OPENQUANTIFIER?
     (CL:AND (CL:= (LENGTH VARIABLES) 2)
      (CL:NOT (QUESTION-MARK-SYMBOL? (%%VALUE (%%REST VARIABLES)))))))
   (CL:WHEN OPENQUANTIFIER? (CL:SETQ VARIABLES (CONS VARIABLES NIL)))
   (LIST* SYM-KIF-IN-LOGIC-KAPPA
    (CONCATENATE VARIABLES (CONS VALUEVARIABLE NIL))
    (LIST* SYM-KIF-IN-STELLA-= VALUEVARIABLE (CONS TERM NIL)) NIL)))

;;; (DEFUN (KIF-COND-TO-IF CONS) ...)

(CL:DEFUN KIF-COND-TO-IF (CONDITIONS)
  (CL:IF (CL:EQ CONDITIONS NIL) NIL
   (CL:PROGN
    (CL:WHEN
     (CL:NOT
      (CL:AND (CONS? (%%VALUE CONDITIONS))
       (CL:NOT (CL:EQ (%%VALUE (%%REST (%%VALUE CONDITIONS))) NIL))))
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "PARSING ERROR: Illegal condition in 'COND': `"
        (%%VALUE CONDITIONS) "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-KIF-IN-ERROR))
      (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
    (CL:LET*
     ((FIRSTCONDITION (%%VALUE CONDITIONS))
      (VALUETERM (KIF-COND-TO-IF (%%REST CONDITIONS))))
     (CL:WHEN (CL:NOT (CL:EQ VALUETERM NIL))
      (CL:SETQ VALUETERM (CONS-LIST VALUETERM)))
     (LIST* SYM-KIF-IN-STELLA-IF (%%VALUE FIRSTCONDITION)
      (CONS (%%VALUE (%%REST FIRSTCONDITION))
       (CONCATENATE VALUETERM NIL)))))))

;;; (DEFUN (KIF-INVERT-SENTENCE OBJECT) ...)

(CL:DEFUN KIF-INVERT-SENTENCE (TREE)
  (CL:IF
   (CL:AND (CONS? TREE) (CL:EQ (%%VALUE TREE) SYM-KIF-IN-STELLA-NOT))
   (%%VALUE (%%REST TREE)) (LIST* SYM-KIF-IN-STELLA-NOT TREE NIL)))

;;; (DEFUN (KIF-IMPLIES-TO-OR-NOT CONS) ...)

(CL:DEFUN KIF-IMPLIES-TO-OR-NOT (TREE)
  (CL:WHEN (CL:< (LENGTH TREE) 2)
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "PARSING ERROR: Illegal implication tree: `" TREE "'." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-KIF-IN-ERROR))
    (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:COND
   ((CL:EQ (%%VALUE TREE) SYM-KIF-IN-STELLA-<=)
    (CL:SETF (%%REST TREE) (REVERSE (%%REST TREE))))
   (CL:T))
  (CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS (%%REST TREE) CL:NIL)
  (FIRST-SETTER TREE SYM-KIF-IN-STELLA-OR)
  (CL:CASE (LENGTH TREE) (2 (%%VALUE (%%REST TREE)))
   (3
    (SECOND-SETTER TREE (KIF-INVERT-SENTENCE (%%VALUE (%%REST TREE))))
    TREE)
   (CL:OTHERWISE (CL:SETF (%%REST TREE) (REVERSE (%%REST TREE)))
    (CL:SETF (%%REST (%%REST TREE))
     (CONS
      (CONS SYM-KIF-IN-STELLA-AND
       (CONCATENATE (REVERSE (%%REST (%%REST TREE))) NIL))
      NIL))
    (CL:SETF (%%REST TREE) (REVERSE (%%REST TREE)))
    (SECOND-SETTER TREE (KIF-INVERT-SENTENCE (%%VALUE (%%REST TREE))))
    TREE)))

;;; (DEFUN (KIF-BICONDITIONAL-TO-TWO-IMPLIES CONS) ...)

(CL:DEFUN KIF-BICONDITIONAL-TO-TWO-IMPLIES (TREE)
  (CL:WHEN (CL:> (LENGTH TREE) 3)
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "PARSING ERROR: Too many arguments to <=>: `" TREE "'." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-KIF-IN-ERROR))
    (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:LET*
   ((COPY (COPY-CONS-TREE TREE)) (ARROW (%%VALUE TREE))
    (FORWARDARROW SYM-KIF-IN-STELLA-=>)
    (BACKWARDARROW SYM-KIF-IN-STELLA-<=))
   (CL:LET* ((TEST-VALUE-000 ARROW))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<=>>)
      (CL:SETQ FORWARDARROW SYM-KIF-IN-LOGIC-=>>))
     ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<<=>)
      (CL:SETQ BACKWARDARROW SYM-KIF-IN-LOGIC-<<=))
     ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<<=>>)
      (CL:SETQ FORWARDARROW SYM-KIF-IN-LOGIC-=>>)
      (CL:SETQ BACKWARDARROW SYM-KIF-IN-LOGIC-<<=))
     ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<~>)
      (CL:SETQ FORWARDARROW SYM-KIF-IN-LOGIC-~>)
      (CL:SETQ BACKWARDARROW SYM-KIF-IN-LOGIC-<~))
     ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<~>>)
      (CL:SETQ FORWARDARROW SYM-KIF-IN-LOGIC-~>>)
      (CL:SETQ BACKWARDARROW SYM-KIF-IN-LOGIC-<~))
     ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<<~>)
      (CL:SETQ FORWARDARROW SYM-KIF-IN-LOGIC-~>)
      (CL:SETQ BACKWARDARROW SYM-KIF-IN-LOGIC-<<~))
     ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<<~>>)
      (CL:SETQ FORWARDARROW SYM-KIF-IN-LOGIC-~>>)
      (CL:SETQ BACKWARDARROW SYM-KIF-IN-LOGIC-<<~))
     (CL:T)))
   (FIRST-SETTER COPY FORWARDARROW) (FIRST-SETTER TREE BACKWARDARROW)
   (LIST* SYM-KIF-IN-STELLA-AND TREE (CONS COPY NIL))))

;;; (DEFUN (KIF-EXISTS-TO-STELLA-EXISTS CONS) ...)

(CL:DEFUN KIF-EXISTS-TO-STELLA-EXISTS (TREE)
  (CL:WHEN (CL:OR (CL:< (LENGTH TREE) 3) (CL:> (LENGTH TREE) 4))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "PARSING ERROR: Illegal EXISTS tree: `" TREE "'." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-KIF-IN-ERROR))
    (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:LET*
   ((SENTENCE1
     (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
      (%%VALUE (%%REST (%%REST TREE)))))
    (SENTENCE2
     (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE (FOURTH TREE))))
   (SECOND-SETTER TREE
    (KIF-VARIABLE-DECLARATIONS-TO-STELLA (%%VALUE (%%REST TREE)) CL:T))
   (CL:WHEN (CL:NOT (CL:EQ SENTENCE2 NULL))
    (CL:RETURN-FROM KIF-EXISTS-TO-STELLA-EXISTS
     (LIST* SYM-KIF-IN-STELLA-EXISTS (%%VALUE (%%REST TREE))
      (CONS
       (LIST* SYM-KIF-IN-STELLA-AND SENTENCE1 (CONS SENTENCE2 NIL))
       NIL))))
   (THIRD-SETTER TREE SENTENCE1) TREE))

;;; (DEFUN (KIF-THREE-ARGUMENT-FORALL-TO-STELLA-FORALL CONS) ...)

(CL:DEFUN KIF-THREE-ARGUMENT-FORALL-TO-STELLA-FORALL (TREE DECLARATIONS)
  (CL:LET*
   ((ANTECEDENT
     (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
      (%%VALUE (%%REST (%%REST TREE)))))
    (CONSEQUENT
     (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE (FOURTH TREE))))
   (LIST* SYM-KIF-IN-STELLA-FORALL DECLARATIONS
    (CONS ANTECEDENT (CONS CONSEQUENT NIL)))))

;;; (DEFUN (KIF-TWO-ARGUMENT-FORALL-TO-STELLA-FORALL CONS) ...)

(CL:DEFUN KIF-TWO-ARGUMENT-FORALL-TO-STELLA-FORALL (TREE DECLARATIONS)
  (CL:LET*
   ((SENTENCE
     (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
      (%%VALUE (%%REST (%%REST TREE))))))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE SENTENCE) SGT-KIF-IN-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 (%%VALUE SENTENCE)))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-AND)
         (CL:LET* ((FORALLS NIL))
          (CL:LET* ((CONJUNCT NULL) (ITER-000 (%%REST SENTENCE)))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
            (CL:SETQ CONJUNCT (%%VALUE ITER-000))
            (CL:SETQ FORALLS
             (CONS
              (LIST* SYM-KIF-IN-STELLA-FORALL
               (COPY-CONS-TREE (%%VALUE (%%REST TREE)))
               (CONS CONJUNCT NIL))
              FORALLS))
            (CL:SETQ ITER-000 (%%REST ITER-000))))
          (CL:RETURN-FROM KIF-TWO-ARGUMENT-FORALL-TO-STELLA-FORALL
           (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
            (CONS SYM-KIF-IN-STELLA-AND (CONCATENATE FORALLS NIL))))))
        ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-OR)
         (CL:LET*
          ((ANTECEDENT
            (KIF-INVERT-SENTENCE (%%VALUE (%%REST SENTENCE))))
           (CONSEQUENT (%%VALUE (%%REST (%%REST SENTENCE)))))
          (CL:RETURN-FROM KIF-TWO-ARGUMENT-FORALL-TO-STELLA-FORALL
           (LIST* SYM-KIF-IN-STELLA-FORALL DECLARATIONS
            (CONS ANTECEDENT (CONS CONSEQUENT NIL))))))
        ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-FORALL)
         (CL:LET* ((V NULL) (ITER-001 DECLARATIONS))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:SETQ V (%%VALUE ITER-001))
           (SECOND-SETTER SENTENCE
            (CONS V (%%VALUE (%%REST SENTENCE))))
           (CL:SETQ ITER-001 (%%REST ITER-001))))
         (CL:RETURN-FROM KIF-TWO-ARGUMENT-FORALL-TO-STELLA-FORALL
          SENTENCE))
        ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-ABOUT)
         (CL:RETURN-FROM KIF-TWO-ARGUMENT-FORALL-TO-STELLA-FORALL
          (LIST* SYM-KIF-IN-LOGIC-ABOUT
           (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
            (LIST* SYM-KIF-IN-STELLA-FORALL DECLARATIONS
             (CONS (%%VALUE (%%REST SENTENCE)) NIL)))
           (CONCATENATE (%%REST (%%REST SENTENCE)) NIL))))
        (CL:T)))))
    (CL:T))
   (LIST* SYM-KIF-IN-STELLA-FORALL DECLARATIONS
    (LIST* SYM-KIF-IN-STELLA-TRUE SENTENCE NIL))))

;;; (DEFUN (KIF-FORALL-TO-STELLA-FORALL CONS) ...)

(CL:DEFUN KIF-FORALL-TO-STELLA-FORALL (TREE)
  (CL:WHEN (CL:OR (CL:< (LENGTH TREE) 3) (CL:> (LENGTH TREE) 4))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "PARSING ERROR: Illegal FORALL tree: `" TREE "'." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-KIF-IN-ERROR))
    (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:LET*
   ((DECLARATIONS
     (KIF-VARIABLE-DECLARATIONS-TO-STELLA (%%VALUE (%%REST TREE))
      CL:T)))
   (CL:ECASE (LENGTH TREE)
    (3 (KIF-TWO-ARGUMENT-FORALL-TO-STELLA-FORALL TREE DECLARATIONS))
    (4 (KIF-THREE-ARGUMENT-FORALL-TO-STELLA-FORALL TREE DECLARATIONS)))))

;;; (DEFUN (KIF-PREDICATION-TO-STELLA-PREDICATION CONS) ...)

(CL:DEFUN KIF-PREDICATION-TO-STELLA-PREDICATION (TREE)
  (CL:LET*
   ((OPERATOR (KIF-OPERATOR-TO-INTERNAL-STELLA (%%VALUE TREE)))
    (ARGUMENTS (%%REST TREE)))
   (FIRST-SETTER TREE OPERATOR)
   (CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS ARGUMENTS CL:T) TREE))

;;; (DEFUN (HELP-TRANSFORM-KIF-FUNCTION CONS) ...)

(CL:DEFUN HELP-TRANSFORM-KIF-FUNCTION (ARG1 ARG2)
  (CL:WHEN (CL:NOT (CONS? ARG1))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE ARG2) SGT-KIF-IN-STELLA-CONS)
     (CL:PROGN
      (CL:WHEN (CL:NOT (TERM-KIF-SPECIAL-FORM? (%%VALUE ARG2)))
       (CL:RETURN-FROM HELP-TRANSFORM-KIF-FUNCTION
        (CONCATENATE ARG2 (CONS ARG1 NIL))))))
    (CL:T)))
  NULL)

;;; (DEFUN (KIF-EQUALITY-TO-STELLA-EQUALITY CONS) ...)

(CL:DEFUN KIF-EQUALITY-TO-STELLA-EQUALITY (TREE)
  (CL:WHEN (CL:= (LENGTH TREE) 3)
   (CL:LET*
    ((FUNCTIONTREE NULL) (ARG1 (%%VALUE (%%REST TREE)))
     (ARG2 (%%VALUE (%%REST (%%REST TREE)))))
    (CL:LET* ((TEST-VALUE-000 CL:NIL))
     (CL:LET* ()
      (CL:SETQ FUNCTIONTREE (HELP-TRANSFORM-KIF-FUNCTION ARG1 ARG2))
      (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ FUNCTIONTREE NULL))))
     (CL:WHEN (CL:NOT TEST-VALUE-000)
      (CL:LET* ()
       (CL:SETQ FUNCTIONTREE (HELP-TRANSFORM-KIF-FUNCTION ARG2 ARG1))
       (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ FUNCTIONTREE NULL)))))
     (CL:WHEN TEST-VALUE-000
      (CL:WHEN (CONS? (%%VALUE FUNCTIONTREE))
       (CL:SETQ FUNCTIONTREE
        (CONS SYM-KIF-IN-PL-KERNEL-KB-VALUE FUNCTIONTREE)))
      (FIRST-SETTER FUNCTIONTREE
       (KIF-OPERATOR-TO-INTERNAL-STELLA (%%VALUE FUNCTIONTREE)))
      (CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS
       (%%REST FUNCTIONTREE) CL:T)
      (CL:RETURN-FROM KIF-EQUALITY-TO-STELLA-EQUALITY FUNCTIONTREE)))))
  (CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS (%%REST TREE) CL:T)
  TREE)

;;; (DEFUN (KIF-OPERATOR-TO-INTERNAL-STELLA SYMBOL) ...)

(CL:DEFUN KIF-OPERATOR-TO-INTERNAL-STELLA (OPERATOR)
  OPERATOR)

;;; (DEFUN (INTERNAL-STELLA-OPERATOR-TO-KIF SYMBOL) ...)

(CL:DEFUN INTERNAL-STELLA-OPERATOR-TO-KIF (OPERATOR)
  OPERATOR)

;;; (DEFUN CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS ...)

(CL:DEFUN CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS (EXPRESSIONS TERMS?)
  (CL:LET* ((IT (ALLOCATE-ITERATOR EXPRESSIONS)))
   (CL:LOOP WHILE (NEXT? IT) DO
    (VALUE-SETTER IT
     (CL:IF TERMS?
      (KIF-TERM-TO-UNTYPED-STELLA-TERM (%CONS-ITERATOR.VALUE IT))
      (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
       (%CONS-ITERATOR.VALUE IT)))))))

;;; (DEFGLOBAL *ANNOTATION-TRANSLATION-TABLE* ...)

(CL:DEFVAR *ANNOTATION-TRANSLATION-TABLE* NULL)

;;; (DEFUN (CANONICALIZE-ANNOTATION CONS) ...)

(CL:DEFUN CANONICALIZE-ANNOTATION (TREE)
  (CL:LET* ((OPERATOR (%%VALUE TREE)))
   (CL:WHEN (CL:EQ OPERATOR KWD-KIF-IN-ABOUT)
    (FIRST-SETTER TREE SYM-KIF-IN-LOGIC-ABOUT)
    (CL:RETURN-FROM CANONICALIZE-ANNOTATION TREE))
   (CL:LET* ((ENTRY NULL) (ITER-000 *ANNOTATION-TRANSLATION-TABLE*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ENTRY (%%VALUE ITER-000))
     (CL:WHEN (EQL? OPERATOR (%%VALUE ENTRY))
      (FIRST-SETTER TREE (%%VALUE (%%REST ENTRY)))
      (CL:RETURN-FROM CANONICALIZE-ANNOTATION
       (LIST* SYM-KIF-IN-LOGIC-ABOUT TREE
        (CONCATENATE (COPY-CONS-TREE (%%VALUE (%%REST (%%REST ENTRY))))
         NIL))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "``" OPERATOR "'' not found in *ANNOTATION-TRANSLATION-TABLE*")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))

;;; (DEFUN (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE OBJECT) ...)

(CL:DEFUN KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE (TREE)
  (CL:WHEN (CL:EQ TREE NULL)
   (CL:RETURN-FROM KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE NULL))
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 SGT-KIF-IN-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((OPERATOR (%%VALUE TREE)))
       (CL:WHEN (ISA? OPERATOR SGT-KIF-IN-STELLA-CONS)
        (CL:RETURN-FROM KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
         (KIF-PREDICATION-TO-STELLA-PREDICATION
          (CONS SYM-KIF-IN-PL-KERNEL-KB-HOLDS
           (CONCATENATE TREE NIL)))))
       (CL:WHEN (CL:NOT (SYMBOL? OPERATOR))
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
           "PARSING ERROR: Bad first argument in KIF sentence: `"
           OPERATOR "'" EOL
           "   Operator must be a symbol or an expression." EOL)
          (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-KIF-IN-ERROR))
         (CL:ERROR
          (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
       (CL:LET* ((TEST-VALUE-000 OPERATOR))
        (CL:COND
         ((CL:OR (CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-AND)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-OR)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-NOT)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-FAIL))
          (CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS (%%REST TREE)
           CL:NIL)
          TREE)
         ((CL:OR (CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-=>)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-<=))
          (KIF-IMPLIES-TO-OR-NOT TREE))
         ((CL:OR (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<=>)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<=>>)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<<=>)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<<=>>)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<~>)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<~>>)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<<~>)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<<~>>))
          (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
           (KIF-BICONDITIONAL-TO-TWO-IMPLIES TREE)))
         ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-EXISTS)
          (KIF-EXISTS-TO-STELLA-EXISTS TREE))
         ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-FORALL)
          (KIF-FORALL-TO-STELLA-FORALL TREE))
         ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-=)
          (KIF-EQUALITY-TO-STELLA-EQUALITY TREE))
         ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-ABOUT)
          (SECOND-SETTER TREE
           (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
            (%%VALUE (%%REST TREE))))
          TREE)
         ((CL:OR (CL:EQ TEST-VALUE-000 KWD-KIF-IN-ABOUT)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<<=)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-=>>)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<~)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-~>)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<<~)
           (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-~>>))
          (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
           (CANONICALIZE-ANNOTATION TREE)))
         (CL:T (KIF-PREDICATION-TO-STELLA-PREDICATION TREE)))))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
     (CL:PROGN (KIF-SYMBOL-TO-STELLA-SYMBOL TREE)))
    ((SUBTYPE-OF-STRING? TEST-VALUE-001)
     (CL:PROGN
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
         "PARSING ERROR: Illegal term in sentence position: `" TREE
         "'." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-KIF-IN-ERROR))
       (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-001))))))
    (CL:T TREE))))

;;; (DEFGLOBAL *KIF-SENTENCE-OPERATORS* ...)

(CL:DEFVAR *KIF-SENTENCE-OPERATORS* NULL)

;;; (DEFGLOBAL *KIF-TERM-OPERATORS* ...)

(CL:DEFVAR *KIF-TERM-OPERATORS* NULL)

;;; (DEFUN (TERM-KIF-SPECIAL-FORM? BOOLEAN) ...)

(CL:DEFUN TERM-KIF-SPECIAL-FORM? (OPERATOR)
  (MEMB? *KIF-TERM-OPERATORS* OPERATOR))

;;; (DEFUN (KIF-TERM-TO-UNTYPED-STELLA-TERM OBJECT) ...)

(CL:DEFUN KIF-TERM-TO-UNTYPED-STELLA-TERM (TREE)
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
     (CL:PROGN (KIF-SYMBOL-TO-STELLA-SYMBOL TREE)))
    ((CL:EQ TEST-VALUE-001 SGT-KIF-IN-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((OPERATOR (%%VALUE TREE)))
       (CL:WHEN (ISA? OPERATOR SGT-KIF-IN-STELLA-CONS)
        (CL:RETURN-FROM KIF-TERM-TO-UNTYPED-STELLA-TERM
         (KIF-TERM-TO-UNTYPED-STELLA-TERM
          (CONS SYM-KIF-IN-PL-KERNEL-KB-VALUE
           (CONCATENATE TREE NIL)))))
       (CL:WHEN (CL:NOT (SYMBOL? OPERATOR))
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
           "PARSING ERROR: Bad first argument in KIF term: `" OPERATOR
           "'" EOL "   Operator must be a symbol or an expression."
           EOL)
          (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-KIF-IN-ERROR))
         (CL:ERROR
          (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
       (CL:COND
        ((MEMBER? *KIF-SENTENCE-OPERATORS* OPERATOR)
         (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE TREE))
        ((TERM-KIF-SPECIAL-FORM? OPERATOR)
         (CL:LET* ((TEST-VALUE-000 OPERATOR))
          (CL:COND
           ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-THE)
            (KIF-THE-TO-STELLA-THE-ONLY TREE))
           ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-SETOFALL)
            (KIF-SETOFALL-TO-STELLA-SETOFALL TREE))
           ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-KAPPA)
            (KIF-KAPPA-TO-STELLA-KAPPA TREE))
           ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-LAMBDA)
            (KIF-TERM-TO-UNTYPED-STELLA-TERM
             (KIF-LAMBDA-TO-STELLA-KAPPA TREE)))
           ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-IF)
            (SECOND-SETTER TREE
             (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
              (%%VALUE (%%REST TREE))))
            (CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS
             (%%REST (%%REST TREE)) CL:T)
            TREE)
           ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-COND)
            (KIF-TERM-TO-UNTYPED-STELLA-TERM
             (KIF-COND-TO-IF (%%REST TREE))))
           ((CL:OR (CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-SETOF)
             (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-LISTOF))
            (CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS (%%REST TREE)
             CL:T)
            TREE)
           (CL:T
            (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
              TEST-VALUE-000 "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION
               (THE-STRING-READER STREAM-001))))))))
        (CL:T
         (FIRST-SETTER TREE (KIF-OPERATOR-TO-INTERNAL-STELLA OPERATOR))
         (CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS (%%REST TREE)
          CL:T)
         TREE)))))
    (CL:T TREE))))

;;; (DEFUN (KIF-VARIABLE? BOOLEAN) ...)

(CL:DEFUN KIF-VARIABLE? (SELF)
  (QUESTION-MARK-SYMBOL? SELF))

;;; (DEFUN (EXTRACT-VARIABLES-FROM-DECLARATIONS CONS) ...)

(CL:DEFUN EXTRACT-VARIABLES-FROM-DECLARATIONS (DECLARATIONS)
  (CL:LET* ((RESULT NIL))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE DECLARATIONS) SGT-KIF-IN-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((ITEM NULL) (ITER-000 DECLARATIONS))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ ITEM (%%VALUE ITER-000))
        (CL:COND
         ((CL:EQ (SAFE-PRIMARY-TYPE ITEM) SGT-KIF-IN-STELLA-CONS)
          (CL:PROGN
           (CL:IF (KIF-VARIABLE? (%%VALUE ITEM))
            (CL:SETQ RESULT (CONS (%%VALUE ITEM) RESULT))
            (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
             (CL:LET* ((*PRINTREADABLY?* CL:T))
              (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
              (%%PRINT-STREAM
               (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
               "PARSING ERROR: Non-variable `" (%%VALUE ITEM)
               "' found where ?variable expected." EOL)
              (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
               KWD-KIF-IN-ERROR))
             (CL:ERROR
              (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))))
         (CL:T
          (CL:WHEN (KIF-VARIABLE? ITEM)
           (CL:SETQ RESULT (CONS ITEM RESULT)))))
        (CL:SETQ ITER-000 (%%REST ITER-000))))))
    (CL:T
     (CL:IF (KIF-VARIABLE? DECLARATIONS)
      (CL:SETQ RESULT (CONS DECLARATIONS RESULT))
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
         "PARSING ERROR: Non-variable `" DECLARATIONS
         "' found where ?variable expected." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-KIF-IN-ERROR))
       (CL:ERROR
        (NEW-PARSING-ERROR (THE-STRING-READER STREAM-001)))))))
   (REVERSE RESULT)))

;;; (DEFUN COLLECT-UNDECLARED-VARIABLES ...)

(CL:DEFUN COLLECT-UNDECLARED-VARIABLES (TREE DECLAREDVARIABLES UNDECLAREDVARIABLES)
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 SGT-KIF-IN-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((OPERATOR (%%VALUE TREE)))
       (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OPERATOR)))
        (CL:COND
         ((CL:EQ TEST-VALUE-000 SGT-KIF-IN-STELLA-CONS)
          (CL:PROGN
           (COLLECT-UNDECLARED-VARIABLES OPERATOR DECLAREDVARIABLES
            UNDECLAREDVARIABLES)
           (CL:LET* ((ARG NULL) (ITER-000 (%%REST TREE)))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
             (CL:SETQ ARG (%%VALUE ITER-000))
             (COLLECT-UNDECLARED-VARIABLES ARG DECLAREDVARIABLES
              UNDECLAREDVARIABLES)
             (CL:SETQ ITER-000 (%%REST ITER-000))))))
         ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
          (CL:PROGN
           (CL:COND
            ((CL:OR (CL:EQ OPERATOR SYM-KIF-IN-STELLA-EXISTS)
              (CL:EQ OPERATOR SYM-KIF-IN-STELLA-FORALL))
             (CL:LET*
              ((V NULL)
               (ITER-001
                (EXTRACT-VARIABLES-FROM-DECLARATIONS
                 (%%VALUE (%%REST TREE)))))
              (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
               (CL:SETQ V (%%VALUE ITER-001))
               (CL:SETQ DECLAREDVARIABLES (CONS V DECLAREDVARIABLES))
               (CL:SETQ ITER-001 (%%REST ITER-001))))
             (CL:LET* ((ARG NULL) (ITER-002 (%%REST (%%REST TREE))))
              (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
               (CL:SETQ ARG (%%VALUE ITER-002))
               (COLLECT-UNDECLARED-VARIABLES ARG DECLAREDVARIABLES
                UNDECLAREDVARIABLES)
               (CL:SETQ ITER-002 (%%REST ITER-002)))))
            ((CL:OR (CL:EQ OPERATOR SYM-KIF-IN-LOGIC-SETOFALL)
              (CL:EQ OPERATOR SYM-KIF-IN-LOGIC-KAPPA)
              (CL:EQ OPERATOR SYM-KIF-IN-LOGIC-LAMBDA)
              (CL:EQ OPERATOR SYM-KIF-IN-LOGIC-THE)))
            (CL:T
             (CL:LET* ((ARG NULL) (ITER-003 (%%REST TREE)))
              (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
               (CL:SETQ ARG (%%VALUE ITER-003))
               (COLLECT-UNDECLARED-VARIABLES ARG DECLAREDVARIABLES
                UNDECLAREDVARIABLES)
               (CL:SETQ ITER-003 (%%REST ITER-003))))))))
         (CL:T))))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
     (CL:PROGN
      (CL:WHEN
       (CL:AND (QUESTION-MARK-SYMBOL? TREE)
        (CL:NOT (MEMBER? DECLAREDVARIABLES TREE)))
       (CL:WHEN (CL:NOT (MEMBER? UNDECLAREDVARIABLES TREE))
        (INSERT-LAST UNDECLAREDVARIABLES TREE)))))
    (CL:T))))

;;; (DEFUN (WRAP-KIF-WITH-FORALL OBJECT) ...)

(CL:DEFUN WRAP-KIF-WITH-FORALL (TREE DECLAREDVARIABLES)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-KIF-IN-STELLA-CONS)
    (CL:PROGN
     (CL:WHEN (SYMBOL? (%%VALUE TREE))
      (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-STELLA-AND)
         (CL:LET* ((SENTENCES NIL))
          (CL:LET*
           ((CONJUNCT NULL) (ITER-000 (%%REST TREE))
            (COLLECT-000 NULL))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
            (CL:SETQ CONJUNCT (%%VALUE ITER-000))
            (CL:IF (CL:EQ COLLECT-000 NULL)
             (CL:PROGN
              (CL:SETQ COLLECT-000
               (CONS (WRAP-KIF-WITH-FORALL CONJUNCT DECLAREDVARIABLES)
                NIL))
              (CL:IF (CL:EQ SENTENCES NIL)
               (CL:SETQ SENTENCES COLLECT-000)
               (ADD-CONS-TO-END-OF-CONS-LIST SENTENCES COLLECT-000)))
             (CL:PROGN
              (CL:SETF (%%REST COLLECT-000)
               (CONS (WRAP-KIF-WITH-FORALL CONJUNCT DECLAREDVARIABLES)
                NIL))
              (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
            (CL:SETQ ITER-000 (%%REST ITER-000))))
          (CL:RETURN-FROM WRAP-KIF-WITH-FORALL
           (CONS SYM-KIF-IN-STELLA-AND (CONCATENATE SENTENCES NIL)))))
        ((CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-<=>)
         (CL:RETURN-FROM WRAP-KIF-WITH-FORALL
          (WRAP-KIF-WITH-FORALL (KIF-BICONDITIONAL-TO-TWO-IMPLIES TREE)
           DECLAREDVARIABLES)))
        (CL:T))))))
   (CL:T))
  (CL:LET* ((UNDECLAREDVARIABLES (NEW-LIST)))
   (COLLECT-UNDECLARED-VARIABLES TREE DECLAREDVARIABLES
    UNDECLAREDVARIABLES)
   (CL:CASE (LENGTH UNDECLAREDVARIABLES)
    (0 (FREE UNDECLAREDVARIABLES) TREE)
    (1
     (LIST* SYM-KIF-IN-STELLA-FORALL (FIRST UNDECLAREDVARIABLES)
      (CONS TREE NIL)))
    (CL:OTHERWISE
     (LIST* SYM-KIF-IN-STELLA-FORALL
      (COPY-CONS-TREE (%LIST.THE-CONS-LIST UNDECLAREDVARIABLES))
      (CONS TREE NIL))))))

;;; (DEFUN (KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION OBJECT) ...)

(CL:DEFUN KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-KIF-IN-STELLA-CONS)
    (CL:PROGN
     (CL:WHEN (SYMBOL? (%%VALUE TREE))
      (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
       (CL:COND
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-THE)
          (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-SETOFALL)
          (CL:EQ TEST-VALUE-000 SYM-KIF-IN-LOGIC-KAPPA))
         (CL:RETURN-FROM KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION
          (KIF-TERM-TO-UNTYPED-STELLA-TERM TREE)))
        (CL:T))))))
   (CL:T))
  (CL:SETQ TREE (WRAP-KIF-WITH-FORALL TREE NIL))
  (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE TREE))

;;; (DEFUN (CONVERT-TO-PREFIX-PROPOSITION-TREE OBJECT) ...)

(CL:DEFUN CONVERT-TO-PREFIX-PROPOSITION-TREE (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-KIF-IN-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((OPERATOR (%%VALUE TREE)))
      (CL:IF (KIF-QUANTIFIER-SYMBOL? OPERATOR)
       (CL:SETQ TREE (INFIX-TO-PREFIX-QUANTIFICATION-TREE TREE))
       (CL:LET* ((IT (ALLOCATE-ITERATOR (%%REST TREE))))
        (CL:LOOP WHILE (NEXT? IT) DO
         (CL:WHEN (CONS? (%CONS-ITERATOR.VALUE IT))
          (VALUE-SETTER IT
           (CONVERT-TO-PREFIX-PROPOSITION-TREE
            (%CONS-ITERATOR.VALUE IT)))))))
      TREE)))
   (CL:T TREE)))

;;; (DEFUN (INFIX-TO-PREFIX-QUANTIFICATION-TREE CONS) ...)

(CL:DEFUN INFIX-TO-PREFIX-QUANTIFICATION-TREE (TREE)
  (CL:LET*
   ((QUANTIFIER (%%VALUE TREE)) (GENERATORSCLAUSE NULL)
    (WHERECLAUSE NULL) (ALWAYSCLAUSE NULL) (RESIDUE (%%REST TREE))
    (OTREE NULL))
   (CL:MULTIPLE-VALUE-SETQ (GENERATORSCLAUSE RESIDUE)
    (EXTRACT-GENERATORS-CLAUSE RESIDUE))
   (CL:WHEN (CL:EQ GENERATORSCLAUSE NULL)
    (CL:RETURN-FROM INFIX-TO-PREFIX-QUANTIFICATION-TREE NULL))
   (CL:MULTIPLE-VALUE-SETQ (WHERECLAUSE RESIDUE)
    (EXTRACT-OPTION-AND-RESIDUE SYM-KIF-IN-STELLA-WHERE RESIDUE))
   (CL:MULTIPLE-VALUE-SETQ (ALWAYSCLAUSE RESIDUE)
    (EXTRACT-OPTION-AND-RESIDUE SYM-KIF-IN-STELLA-ALWAYS RESIDUE))
   (CL:SETQ OTREE
    (CONS QUANTIFIER
     (CONS (CONVERT-TO-PREFIX-PROPOSITION-TREE GENERATORSCLAUSE)
      (CONCATENATE
       (CL:IF (CL:NOT (CL:EQ WHERECLAUSE NULL))
        (CONS (CONVERT-TO-PREFIX-PROPOSITION-TREE WHERECLAUSE) NIL)
        (GET-QUOTED-TREE "((TRUE) \"/LOGIC\")" "/LOGIC"))
       (CONCATENATE
        (CL:IF (CL:NOT (CL:EQ ALWAYSCLAUSE NULL))
         (CONS (CONVERT-TO-PREFIX-PROPOSITION-TREE ALWAYSCLAUSE) NIL)
         NIL)
        NIL)))))
   (CL:WHEN (CL:NOT (CL:EQ RESIDUE NIL))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "PARSING ERROR: Extra expressions at the end of quantified expression."
       EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-KIF-IN-ERROR))
     (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
   OTREE))

;;; (DEFSPECIAL *LOGIC-DIALECT* ...)

(CL:DEFVAR *LOGIC-DIALECT* NULL
  "Indicates the current dialect of logic used to phrase
queries, assertions, and definitions.")

;;; (DEFUN (STANDARDIZE-LOGICAL-PARSE-TREE OBJECT) ...)

(CL:DEFUN STANDARDIZE-LOGICAL-PARSE-TREE (TREE)
  (CL:LET* ((STANDARDIZEDTREE NULL))
   (CL:COND
    ((CL:EQ *LOGIC-DIALECT* KWD-KIF-IN-KIF)
     (CL:SETQ STANDARDIZEDTREE
      (KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION TREE)))
    ((CL:EQ *LOGIC-DIALECT* KWD-KIF-IN-STELLA)
     (CL:SETQ STANDARDIZEDTREE
      (CONVERT-TO-PREFIX-PROPOSITION-TREE TREE)))
    ((CL:EQ *LOGIC-DIALECT* KWD-KIF-IN-PREFIX-STELLA)
     (CL:SETQ STANDARDIZEDTREE TREE))
    ((CL:EQ *LOGIC-DIALECT* KWD-KIF-IN-MELD))
    ((CL:EQ *LOGIC-DIALECT* KWD-KIF-IN-LOOM)
     (CL:SETQ STANDARDIZEDTREE
      (KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION TREE)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" *LOGIC-DIALECT* "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   STANDARDIZEDTREE))

;;; (DEFUN (IN-DIALECT KEYWORD) ...)

(CL:DEFUN %IN-DIALECT (DIALECT)
  "Change the current logic dialect to `dialect'.
Currently supported dialects are `KIF', `STELLA', and `PREFIX-STELLA'.
The STELLA dialects are not recommended for the construction of knowledge
bases, they are mainly used internally by PowerLoom."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE DIALECT)))
   (CL:COND
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN (CL:SETQ *LOGIC-DIALECT* (KEYWORDIFY DIALECT))))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (CL:SETQ *LOGIC-DIALECT*
       (KEYWORDIFY (%STRING-WRAPPER.WRAPPER-VALUE DIALECT)))))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN (CL:SETQ *LOGIC-DIALECT* DIALECT)))
    (CL:T
     (CL:WARN "IN-DIALECT: Illegal dialect specification: `~A'"
      DIALECT))))
  *LOGIC-DIALECT*)

(CL:DEFMACRO IN-DIALECT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Change the current logic dialect to `dialect'.
Currently supported dialects are `KIF', `STELLA', and `PREFIX-STELLA'.
The STELLA dialects are not recommended for the construction of knowledge
bases, they are mainly used internally by PowerLoom."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/IN-DIALECT|)) (CL:MACRO-FUNCTION (CL:QUOTE IN-DIALECT)))

(CL:DEFUN HELP-STARTUP-KIF-IN1 ()
  (CL:PROGN
   (CL:SETQ SYM-KIF-IN-LOGIC-PARSE-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARSE-TREE" NULL 0))
   (CL:SETQ KWD-KIF-IN-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ SGT-KIF-IN-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-KIF-IN-STELLA-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-STELLA-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-SETOFALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOFALL" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-KAPPA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-THE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-THE-ONLY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-ONLY" NULL 0))
   (CL:SETQ SYM-KIF-IN-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-STELLA-=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "="
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-STELLA-IF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-STELLA-<=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<="
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-STELLA-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-STELLA-=>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=>"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-<=>>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<=>>" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-<<=>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<<=>" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-<<=>>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<<=>>" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-<~>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<~>" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-<~>>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<~>>" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-<<~>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<<~>" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-<<~>>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<<~>>" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-=>>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=>>" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-<<=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<<=" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-~>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "~>" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-<~
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<~" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-~>>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "~>>" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-<<~
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<<~" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-ABOUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABOUT" NULL 0))
   (CL:SETQ SYM-KIF-IN-PL-KERNEL-KB-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ KWD-KIF-IN-DIRECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTION" NULL 2))
   (CL:SETQ KWD-KIF-IN-BACKWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD" NULL 2))
   (CL:SETQ KWD-KIF-IN-FORWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD" NULL 2))
   (CL:SETQ KWD-KIF-IN-CONFIDENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONFIDENCE-LEVEL" NULL 2))
   (CL:SETQ KWD-KIF-IN-DEFAULT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULT" NULL 2))
   (CL:SETQ KWD-KIF-IN-ABOUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABOUT" NULL 2))
   (CL:SETQ SYM-KIF-IN-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-<=>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<=>" NULL 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-LAMBDA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LAMBDA" NULL 0))
   (CL:SETQ SYM-KIF-IN-STELLA-COND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COND"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-STELLA-SETOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOF"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-LOGIC-LISTOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISTOF" NULL 0))
   (CL:SETQ SYM-KIF-IN-STELLA-WHERE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHERE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-IN-STELLA-ALWAYS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALWAYS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-KIF-IN-KIF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KIF" NULL 2))
   (CL:SETQ KWD-KIF-IN-STELLA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA" NULL 2))
   (CL:SETQ KWD-KIF-IN-PREFIX-STELLA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREFIX-STELLA" NULL 2))
   (CL:SETQ KWD-KIF-IN-MELD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MELD" NULL 2))
   (CL:SETQ KWD-KIF-IN-LOOM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOM" NULL 2))
   (CL:SETQ SYM-KIF-IN-LOGIC-IN-DIALECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN-DIALECT" NULL 0))
   (CL:SETQ KWD-KIF-IN-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-KIF-IN-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-KIF-IN-LOGIC-STARTUP-KIF-IN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-KIF-IN" NULL 0))
   (CL:SETQ SYM-KIF-IN-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN STARTUP-KIF-IN ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-KIF-IN1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *ANNOTATION-TRANSLATION-TABLE*
     (LIST*
      (LIST* SYM-KIF-IN-LOGIC-<<= SYM-KIF-IN-STELLA-<=
       (LIST* KWD-KIF-IN-DIRECTION KWD-KIF-IN-BACKWARD NIL) NIL)
      (LIST* SYM-KIF-IN-LOGIC-=>> SYM-KIF-IN-STELLA-=>
       (LIST* KWD-KIF-IN-DIRECTION KWD-KIF-IN-FORWARD NIL) NIL)
      (LIST* SYM-KIF-IN-LOGIC-<~ SYM-KIF-IN-STELLA-<=
       (LIST* KWD-KIF-IN-CONFIDENCE-LEVEL KWD-KIF-IN-DEFAULT NIL) NIL)
      (LIST* SYM-KIF-IN-LOGIC-~> SYM-KIF-IN-STELLA-=>
       (LIST* KWD-KIF-IN-CONFIDENCE-LEVEL KWD-KIF-IN-DEFAULT NIL) NIL)
      (LIST* SYM-KIF-IN-LOGIC-<<~ SYM-KIF-IN-STELLA-<=
       (LIST* KWD-KIF-IN-CONFIDENCE-LEVEL KWD-KIF-IN-DEFAULT
        KWD-KIF-IN-DIRECTION KWD-KIF-IN-BACKWARD NIL)
       NIL)
      (LIST* SYM-KIF-IN-LOGIC-~>> SYM-KIF-IN-STELLA-=>
       (LIST* KWD-KIF-IN-CONFIDENCE-LEVEL KWD-KIF-IN-DEFAULT
        KWD-KIF-IN-DIRECTION KWD-KIF-IN-FORWARD NIL)
       NIL)
      NIL))
    (CL:SETQ *KIF-SENTENCE-OPERATORS*
     (GET-QUOTED-TREE
      "((AND OR NOT FAIL EXISTS FORALL => <= <=> =) \"/LOGIC\")"
      "/LOGIC"))
    (CL:SETQ *KIF-TERM-OPERATORS*
     (GET-QUOTED-TREE
      "((THE SETOFALL KAPPA LAMBDA COND IF SETOF LISTOF) \"/LOGIC\")"
      "/LOGIC"))
    (CL:SETQ *LOGIC-DIALECT* KWD-KIF-IN-KIF))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE PARSE-TREE OBJECT)"))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "QUESTION-MARK-SYMBOL?"
     "(DEFUN (QUESTION-MARK-SYMBOL? BOOLEAN) ((SYMBOL OBJECT)))"
     (CL:FUNCTION QUESTION-MARK-SYMBOL?) NULL)
    (DEFINE-FUNCTION-OBJECT "SEQUENCE-VARIABLE-SYMBOL?"
     "(DEFUN (SEQUENCE-VARIABLE-SYMBOL? BOOLEAN) ((SELF OBJECT)))"
     (CL:FUNCTION SEQUENCE-VARIABLE-SYMBOL?) NULL)
    (DEFINE-FUNCTION-OBJECT "AUTOMATIC-INSTANCE-SYMBOL?"
     "(DEFUN (AUTOMATIC-INSTANCE-SYMBOL? BOOLEAN) ((SYMBOL OBJECT)))"
     (CL:FUNCTION AUTOMATIC-INSTANCE-SYMBOL?) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-SYMBOL-TO-STELLA-SYMBOL"
     "(DEFUN (KIF-SYMBOL-TO-STELLA-SYMBOL GENERALIZED-SYMBOL) ((SYMBOL SYMBOL)))"
     (CL:FUNCTION KIF-SYMBOL-TO-STELLA-SYMBOL) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-VARIABLE-TO-STELLA-VARIABLE"
     "(DEFUN (KIF-VARIABLE-TO-STELLA-VARIABLE SYMBOL) ((VARIABLE OBJECT)))"
     (CL:FUNCTION KIF-VARIABLE-TO-STELLA-VARIABLE) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-VARIABLE-DECLARATION?"
     "(DEFUN (KIF-VARIABLE-DECLARATION? BOOLEAN) ((TREE OBJECT)))"
     (CL:FUNCTION KIF-VARIABLE-DECLARATION?) NULL)
    (DEFINE-FUNCTION-OBJECT "ONE-KIF-VARIABLE-DECLARATION-TO-STELLA"
     "(DEFUN (ONE-KIF-VARIABLE-DECLARATION-TO-STELLA OBJECT) ((TREE OBJECT)))"
     (CL:FUNCTION ONE-KIF-VARIABLE-DECLARATION-TO-STELLA) NULL)
    (DEFINE-FUNCTION-OBJECT "STELLA-VARIABLE-DECLARATIONS?"
     "(DEFUN (STELLA-VARIABLE-DECLARATIONS? BOOLEAN) ((TREE OBJECT)))"
     (CL:FUNCTION STELLA-VARIABLE-DECLARATIONS?) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-VARIABLE-DECLARATIONS-TO-STELLA"
     "(DEFUN (KIF-VARIABLE-DECLARATIONS-TO-STELLA CONS) ((TREE OBJECT) (ERROR? BOOLEAN)))"
     (CL:FUNCTION KIF-VARIABLE-DECLARATIONS-TO-STELLA) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-QUANTIFIER-SYMBOL?"
     "(DEFUN (KIF-QUANTIFIER-SYMBOL? BOOLEAN) ((SELF SYMBOL)))"
     (CL:FUNCTION KIF-QUANTIFIER-SYMBOL?) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-THE-TO-STELLA-THE-ONLY"
     "(DEFUN (KIF-THE-TO-STELLA-THE-ONLY CONS) ((TREE CONS)))"
     (CL:FUNCTION KIF-THE-TO-STELLA-THE-ONLY) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-SETOFALL-TO-STELLA-SETOFALL"
     "(DEFUN (KIF-SETOFALL-TO-STELLA-SETOFALL CONS) ((TREE CONS)))"
     (CL:FUNCTION KIF-SETOFALL-TO-STELLA-SETOFALL) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-KAPPA-TO-STELLA-KAPPA"
     "(DEFUN (KIF-KAPPA-TO-STELLA-KAPPA CONS) ((TREE CONS)))"
     (CL:FUNCTION KIF-KAPPA-TO-STELLA-KAPPA) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-LAMBDA-TO-STELLA-KAPPA"
     "(DEFUN (KIF-LAMBDA-TO-STELLA-KAPPA CONS) ((TREE CONS)))"
     (CL:FUNCTION KIF-LAMBDA-TO-STELLA-KAPPA) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-COND-TO-IF"
     "(DEFUN (KIF-COND-TO-IF CONS) ((CONDITIONS CONS)))"
     (CL:FUNCTION KIF-COND-TO-IF) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-INVERT-SENTENCE"
     "(DEFUN (KIF-INVERT-SENTENCE OBJECT) ((TREE OBJECT)))"
     (CL:FUNCTION KIF-INVERT-SENTENCE) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-IMPLIES-TO-OR-NOT"
     "(DEFUN (KIF-IMPLIES-TO-OR-NOT CONS) ((TREE CONS)))"
     (CL:FUNCTION KIF-IMPLIES-TO-OR-NOT) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-BICONDITIONAL-TO-TWO-IMPLIES"
     "(DEFUN (KIF-BICONDITIONAL-TO-TWO-IMPLIES CONS) ((TREE CONS)))"
     (CL:FUNCTION KIF-BICONDITIONAL-TO-TWO-IMPLIES) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-EXISTS-TO-STELLA-EXISTS"
     "(DEFUN (KIF-EXISTS-TO-STELLA-EXISTS CONS) ((TREE CONS)))"
     (CL:FUNCTION KIF-EXISTS-TO-STELLA-EXISTS) NULL)
    (DEFINE-FUNCTION-OBJECT
     "KIF-THREE-ARGUMENT-FORALL-TO-STELLA-FORALL"
     "(DEFUN (KIF-THREE-ARGUMENT-FORALL-TO-STELLA-FORALL CONS) ((TREE CONS) (DECLARATIONS CONS)))"
     (CL:FUNCTION KIF-THREE-ARGUMENT-FORALL-TO-STELLA-FORALL) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-TWO-ARGUMENT-FORALL-TO-STELLA-FORALL"
     "(DEFUN (KIF-TWO-ARGUMENT-FORALL-TO-STELLA-FORALL CONS) ((TREE CONS) (DECLARATIONS CONS)))"
     (CL:FUNCTION KIF-TWO-ARGUMENT-FORALL-TO-STELLA-FORALL) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-FORALL-TO-STELLA-FORALL"
     "(DEFUN (KIF-FORALL-TO-STELLA-FORALL CONS) ((TREE CONS)))"
     (CL:FUNCTION KIF-FORALL-TO-STELLA-FORALL) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-PREDICATION-TO-STELLA-PREDICATION"
     "(DEFUN (KIF-PREDICATION-TO-STELLA-PREDICATION CONS) ((TREE CONS)))"
     (CL:FUNCTION KIF-PREDICATION-TO-STELLA-PREDICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-TRANSFORM-KIF-FUNCTION"
     "(DEFUN (HELP-TRANSFORM-KIF-FUNCTION CONS) ((ARG1 OBJECT) (ARG2 OBJECT)))"
     (CL:FUNCTION HELP-TRANSFORM-KIF-FUNCTION) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-EQUALITY-TO-STELLA-EQUALITY"
     "(DEFUN (KIF-EQUALITY-TO-STELLA-EQUALITY CONS) ((TREE CONS)))"
     (CL:FUNCTION KIF-EQUALITY-TO-STELLA-EQUALITY) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-OPERATOR-TO-INTERNAL-STELLA"
     "(DEFUN (KIF-OPERATOR-TO-INTERNAL-STELLA SYMBOL) ((OPERATOR SYMBOL)))"
     (CL:FUNCTION KIF-OPERATOR-TO-INTERNAL-STELLA) NULL)
    (DEFINE-FUNCTION-OBJECT "INTERNAL-STELLA-OPERATOR-TO-KIF"
     "(DEFUN (INTERNAL-STELLA-OPERATOR-TO-KIF SYMBOL) ((OPERATOR SYMBOL)))"
     (CL:FUNCTION INTERNAL-STELLA-OPERATOR-TO-KIF) NULL)
    (DEFINE-FUNCTION-OBJECT
     "CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS"
     "(DEFUN CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS ((EXPRESSIONS CONS) (TERMS? BOOLEAN)))"
     (CL:FUNCTION CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "CANONICALIZE-ANNOTATION"
     "(DEFUN (CANONICALIZE-ANNOTATION CONS) ((TREE CONS)))"
     (CL:FUNCTION CANONICALIZE-ANNOTATION) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE"
     "(DEFUN (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE OBJECT) ((TREE OBJECT)))"
     (CL:FUNCTION KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE) NULL)
    (DEFINE-FUNCTION-OBJECT "TERM-KIF-SPECIAL-FORM?"
     "(DEFUN (TERM-KIF-SPECIAL-FORM? BOOLEAN) ((OPERATOR OBJECT)))"
     (CL:FUNCTION TERM-KIF-SPECIAL-FORM?) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-TERM-TO-UNTYPED-STELLA-TERM"
     "(DEFUN (KIF-TERM-TO-UNTYPED-STELLA-TERM OBJECT) ((TREE OBJECT)))"
     (CL:FUNCTION KIF-TERM-TO-UNTYPED-STELLA-TERM) NULL)
    (DEFINE-FUNCTION-OBJECT "KIF-VARIABLE?"
     "(DEFUN (KIF-VARIABLE? BOOLEAN) ((SELF OBJECT)))"
     (CL:FUNCTION KIF-VARIABLE?) NULL)
    (DEFINE-FUNCTION-OBJECT "EXTRACT-VARIABLES-FROM-DECLARATIONS"
     "(DEFUN (EXTRACT-VARIABLES-FROM-DECLARATIONS CONS) ((DECLARATIONS OBJECT)))"
     (CL:FUNCTION EXTRACT-VARIABLES-FROM-DECLARATIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-UNDECLARED-VARIABLES"
     "(DEFUN COLLECT-UNDECLARED-VARIABLES ((TREE OBJECT) (DECLAREDVARIABLES CONS) (UNDECLAREDVARIABLES (LIST OF SYMBOL))))"
     (CL:FUNCTION COLLECT-UNDECLARED-VARIABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "WRAP-KIF-WITH-FORALL"
     "(DEFUN (WRAP-KIF-WITH-FORALL OBJECT) ((TREE OBJECT) (DECLAREDVARIABLES CONS)))"
     (CL:FUNCTION WRAP-KIF-WITH-FORALL) NULL)
    (DEFINE-FUNCTION-OBJECT
     "KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION"
     "(DEFUN (KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION OBJECT) ((TREE OBJECT)))"
     (CL:FUNCTION KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION) NULL)
    (DEFINE-FUNCTION-OBJECT "CONVERT-TO-PREFIX-PROPOSITION-TREE"
     "(DEFUN (CONVERT-TO-PREFIX-PROPOSITION-TREE OBJECT) ((TREE OBJECT)))"
     (CL:FUNCTION CONVERT-TO-PREFIX-PROPOSITION-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "INFIX-TO-PREFIX-QUANTIFICATION-TREE"
     "(DEFUN (INFIX-TO-PREFIX-QUANTIFICATION-TREE CONS) ((TREE CONS)))"
     (CL:FUNCTION INFIX-TO-PREFIX-QUANTIFICATION-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "STANDARDIZE-LOGICAL-PARSE-TREE"
     "(DEFUN (STANDARDIZE-LOGICAL-PARSE-TREE OBJECT) ((TREE OBJECT)))"
     (CL:FUNCTION STANDARDIZE-LOGICAL-PARSE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "IN-DIALECT"
     "(DEFUN (IN-DIALECT KEYWORD) ((DIALECT NAME)) :DOCUMENTATION \"Change the current logic dialect to `dialect'.
Currently supported dialects are `KIF', `STELLA', and `PREFIX-STELLA'.
The STELLA dialects are not recommended for the construction of knowledge
bases, they are mainly used internally by PowerLoom.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
     (CL:FUNCTION %IN-DIALECT) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-KIF-IN"
     "(DEFUN STARTUP-KIF-IN () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-KIF-IN) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-KIF-IN-LOGIC-STARTUP-KIF-IN)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-KIF-IN-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupKifIn") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *AUTOMATIC-INSTANCE-CHARACTER* CHARACTER #\\$ :DOCUMENTATION \"Character that identifies variables representing
instances named by the system.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ANNOTATION-TRANSLATION-TABLE* (CONS OF CONS) (BQUOTE ((<<= <= (:DIRECTION :BACKWARD)) (=>> => (:DIRECTION :FORWARD)) (<~ <= (:CONFIDENCE-LEVEL :DEFAULT)) (~> => (:CONFIDENCE-LEVEL :DEFAULT)) (<<~ <= (:CONFIDENCE-LEVEL :DEFAULT :DIRECTION :BACKWARD)) (~>> => (:CONFIDENCE-LEVEL :DEFAULT :DIRECTION :FORWARD)))))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *KIF-SENTENCE-OPERATORS* (CONS OF SYMBOL) (QUOTE (AND OR NOT FAIL EXISTS FORALL => <= <=> =)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *KIF-TERM-OPERATORS* (CONS OF SYMBOL) (QUOTE (THE SETOFALL KAPPA LAMBDA COND IF SETOF LISTOF)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *LOGIC-DIALECT* KEYWORD :KIF :DOCUMENTATION \"Indicates the current dialect of logic used to phrase
queries, assertions, and definitions.\")")
    (REGISTER-NATIVE-NAME SYM-KIF-IN-LOGIC-IN-DIALECT
     KWD-KIF-IN-COMMON-LISP KWD-KIF-IN-FUNCTION))))
