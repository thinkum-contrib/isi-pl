;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; descriptions.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-SLOT NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-METHOD-SLOT NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-STELLA-ANY-VALUE NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-EXTENSIONAL-ASSERTION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PL-KERNEL-KB-RELATION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PL-KERNEL-KB-POLYMORPHIC NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X1 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X2 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X3 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X4 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X5 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X6 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X7 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X8 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X9 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X10 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X11 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X12 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X13 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X14 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X15 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X16 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X17 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X18 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X19 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X20 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X21 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X22 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X23 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X24 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X25 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X26 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X27 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X28 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X29 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X30 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X31 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X32 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X33 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X34 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X35 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X36 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X37 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X38 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X39 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X40 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X41 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X42 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X43 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X44 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X45 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X46 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X47 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X48 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X49 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X50 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X51 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X52 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X53 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X54 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X55 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X56 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X57 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X58 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X59 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X60 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X61 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X62 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X63 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X64 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X65 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X66 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X67 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X68 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X69 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X70 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X71 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X72 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X73 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X74 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X75 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X76 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X77 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X78 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X79 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X80 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X81 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X82 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X83 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X84 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X85 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X86 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X87 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X88 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X89 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X90 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X91 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X92 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X93 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X94 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X95 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X96 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X97 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X98 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X99 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X100 NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-STELLA-ISA NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-KAPPA NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-KIF NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-DESCRIPTION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PL-KERNEL-KB-CONCEPT NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PL-KERNEL-KB-FUNCTION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PL-KERNEL-KB-VARIABLE-ARITY NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-CLASS NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-ERROR NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-RELATION NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-OBJECT-STORE NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-THING NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-LITERAL NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-WARNING NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-CONS NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-ISA NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-VARIABLE-TYPE? NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-STELLA-EXISTS NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-ENTITY-MAPPING NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-AND NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-OR NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-EQUIVALENT NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-FORALL NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-EXISTS NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-FUNCTION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-SET NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-LIST NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-SURROGATE NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-NOT NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-PREDICATE NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-IMPLIES NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-STELLA-NOT NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-PROPOSITION.IF NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-STELLA-AND NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-CS-VALUE NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-THE-ONLY NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-IOTA? NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-VARIABLE-TYPE-TABLE NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-STELLA-SYMBOL NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-UNDECLARED? NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-LIST-UNDEFINED-RELATIONS NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-COMMON-LISP NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-?X NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-PL-KERNEL-KB-RELATION NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-F-CALL-LIST-UNDEFINED-RELATIONS-QUERY-000 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-DESCRIPTIVE? NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LOGIC-STARTUP-DESCRIPTIONS NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *SURROGATE-ARRAY* FALSE-WRAPPER
  *VARIABLEIDCOUNTER* *STRUCTURED-OBJECTS-INDEX* *UNIFY-PROPOSITIONS?*
  *QUERYITERATOR* ZERO-VARIABLES-VECTOR TRUE-WRAPPER STANDARD-WARNING
  *SUPPRESSNONLOGICOBJECTWARNING?* STANDARD-OUTPUT *PL-KERNEL-MODULE*
  NIL-LIST EOL *MODULE* TRUE-PROPOSITION NIL NULL-INTEGER))

;;; (DEFUN (DIRECT-SUPERRELATIONS (ITERATOR OF (LIKE SELF))) ...)

(CL:DEFUN DIRECT-SUPERRELATIONS (SELF)
  "Return direct super classes/slots of 'self'."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
     (CL:PROGN (DIRECT-SUPER-CLASSES SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-SLOT)
     (CL:PROGN (ALLOCATE-ITERATOR (SLOT-DIRECT-SUPERS SELF))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (SLOT-COLUMN-TYPES (CONS OF TYPE)) ...)

(CL:DEFUN SLOT-COLUMN-TYPES (SELF COUNT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT))
  #+MCL
  (CL:CHECK-TYPE COUNT CL:FIXNUM)
  (CL:COND
   ((SUBTYPE-OF-STORAGE-SLOT? (SAFE-PRIMARY-TYPE SELF))
    (CL:PROGN
     (CL:LET*
      ((DOMAIN (%STORAGE-SLOT.SLOT-OWNER SELF))
       (RANGE (%STORAGE-SLOT.SLOT-BASE-TYPE SELF))
       (TYPESLIST
        (CL:IF (BOOLEAN-TYPE? RANGE) (CONS-LIST DOMAIN)
         (CONS-LIST DOMAIN RANGE))))
      TYPESLIST)))
   (CL:T
    (CL:LET*
     ((TYPESPECIFIERS
       (CL:IF (ISA? SELF SGT-DESCRIPTIONS-STELLA-METHOD-SLOT)
        (METHOD-PARAMETER-TYPE-SPECIFIERS SELF)
        (%TABLE.TUPLE-DOMAINS SELF)))
      (TYPESLIST NIL) (VARIABLETYPES NIL) (RETURNTYPES NIL)
      (RETURNTYPE (UNWRAP-WRAPPED-TYPE (%SLOT.SLOT-BASE-TYPE SELF))))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ RETURNTYPE NULL))
       (CL:NOT (BOOLEAN-TYPE? RETURNTYPE)))
      (CL:SETQ RETURNTYPES (CONS RETURNTYPE RETURNTYPES)))
     (CL:IF (NULL? (ARITY SELF))
      (CL:LET*
       ((VARIABLEARGUMENTSTYPE
         (EXTRACT-PARAMETER-TYPE (LAST TYPESPECIFIERS)
          SYM-DESCRIPTIONS-STELLA-ANY-VALUE)))
       (CL:LET*
        ((TSPEC NULL) (ITER-000 (BUT-LAST TYPESPECIFIERS))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (NEXT? ITER-000) DO
         (CL:SETQ TSPEC (%ITERATOR.VALUE ITER-000))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-000
            (CONS (UNWRAP-WRAPPED-TYPE (TYPE-SPEC-TO-BASE-TYPE TSPEC))
             NIL))
           (CL:IF (CL:EQ TYPESLIST NIL) (CL:SETQ TYPESLIST COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST TYPESLIST COLLECT-000)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-000)
            (CONS (UNWRAP-WRAPPED-TYPE (TYPE-SPEC-TO-BASE-TYPE TSPEC))
             NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
       (CL:IF (NULL? COUNT) (CL:SETQ COUNT 1)
        (CL:SETQ COUNT
         (CL:- COUNT (CL:+ (LENGTH TYPESLIST) (LENGTH RETURNTYPES)))))
       (CL:LET*
        ((I NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-000 COUNT)
         (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
        (CL:LOOP WHILE
         (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)) DO
         (CL:SETQ I ITER-001) (CL:SETQ I I)
         (CL:SETQ VARIABLETYPES
          (CONS VARIABLEARGUMENTSTYPE VARIABLETYPES))
         (CL:SETQ ITER-001 (CL:1+ ITER-001))))
       (CL:SETQ TYPESLIST (CONCATENATE TYPESLIST VARIABLETYPES)))
      (CL:LET*
       ((TSPEC NULL) (ITER-002 (%LIST.THE-CONS-LIST TYPESPECIFIERS))
        (COLLECT-001 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:SETQ TSPEC (%%VALUE ITER-002))
        (CL:IF (CL:EQ COLLECT-001 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-001
           (CONS (UNWRAP-WRAPPED-TYPE (TYPE-SPEC-TO-BASE-TYPE TSPEC))
            NIL))
          (CL:IF (CL:EQ TYPESLIST NIL) (CL:SETQ TYPESLIST COLLECT-001)
           (ADD-CONS-TO-END-OF-CONS-LIST TYPESLIST COLLECT-001)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-001)
           (CONS (UNWRAP-WRAPPED-TYPE (TYPE-SPEC-TO-BASE-TYPE TSPEC))
            NIL))
          (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
        (CL:SETQ ITER-002 (%%REST ITER-002)))))
     (CL:SETQ TYPESLIST (CONCATENATE TYPESLIST RETURNTYPES))
     TYPESLIST))))

;;; (DEFCONSTANT FAKE-IO-VARIABLES ...)

(CL:DEFVAR FAKE-IO-VARIABLES NULL
  "Installed in a description with undetermined arity.")

;;; (DEFUN (CREATE-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN CREATE-DESCRIPTION (ARITY NAMED?)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (ENFORCE-CODE-ONLY)
  (CL:LET*
   ((DESCRIPTION
     (CL:IF NAMED? (NEW-NAMED-DESCRIPTION) (NEW-DESCRIPTION))))
   (CL:SETF (%DESCRIPTION.IO-VARIABLES DESCRIPTION)
    (CL:IF (DEFINED? ARITY) (NEW-VECTOR ARITY) FAKE-IO-VARIABLES))
   DESCRIPTION))

;;; (DEFMETHOD (DESCRIPTION-NAME SYMBOL) ...)

(CL:DEFMETHOD DESCRIPTION-NAME ((SELF DESCRIPTION))
  "Return the name of the description `self', if it has one."
  NULL)

;;; (DEFMETHOD (DESCRIPTION-NAME SYMBOL) ...)

(CL:DEFMETHOD DESCRIPTION-NAME ((SELF NAMED-DESCRIPTION))
  "Return the name of the description `self'."
  (OBJECT-NAME SELF))

;;; (DEFUN CREATE-BASE-RELATION-FOR-POLYMORPHIC-DESCRIPTION ...)

(CL:DEFUN CREATE-BASE-RELATION-FOR-POLYMORPHIC-DESCRIPTION (DESCRIPTION)
  (CL:LET*
   ((SURROGATE
     (INTERN-SURROGATE-IN-MODULE
      (%SYMBOL.SYMBOL-NAME (DESCRIPTION-NAME DESCRIPTION))
      (%DESCRIPTION.HOME-CONTEXT DESCRIPTION) CL:T))
    (RELATION (%SURROGATE.SURROGATE-VALUE SURROGATE)))
   (CL:WHEN (CL:EQ RELATION NULL)
    (CL:LET*
     ((*EVALUATIONMODE* KWD-DESCRIPTIONS-EXTENSIONAL-ASSERTION)
      (*FILLINGCONSTRAINTPROPAGATIONQUEUES?* CL:NIL))
     (CL:DECLARE
      (CL:SPECIAL *EVALUATIONMODE*
       *FILLINGCONSTRAINTPROPAGATIONQUEUES?*))
     (ASSERT-ISA-PROPOSITION
      (CREATE-LOGIC-INSTANCE SURROGATE
       SGT-DESCRIPTIONS-PL-KERNEL-KB-RELATION)
      SGT-DESCRIPTIONS-PL-KERNEL-KB-POLYMORPHIC)))))

;;; (DEFCONSTANT SYSTEM-DEFINED-ARGUMENT-NAMES ...)

(CL:DEFVAR SYSTEM-DEFINED-ARGUMENT-NAMES NULL)

;;; (DEFUN (YIELD-SYSTEM-DEFINED-PARAMETER-NAME SYMBOL) ...)

(CL:DEFUN YIELD-SYSTEM-DEFINED-PARAMETER-NAME (INDEX REFERENCEOBJECT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX))
  #+MCL
  (CL:CHECK-TYPE INDEX CL:FIXNUM)
  (CL:IF (CL:< INDEX 100)
   (INTERN-SYMBOL-IN-MODULE
    (%SYMBOL.SYMBOL-NAME (NTH SYSTEM-DEFINED-ARGUMENT-NAMES INDEX))
    (HOME-MODULE REFERENCEOBJECT) CL:T)
   (INTERN-SYMBOL-IN-MODULE
    (CONCATENATE "?X" (INTEGER-TO-STRING (CL:1+ INDEX)))
    (HOME-MODULE REFERENCEOBJECT) CL:T)))

;;; (DEFUN ENSURE-DESCRIPTION-BODY ...)

(CL:DEFUN ENSURE-DESCRIPTION-BODY (DESCRIPTION)
  (CL:WHEN
   (CL:AND
    (CL:OR (CL:EQ (%DESCRIPTION.PROPOSITION DESCRIPTION) NULL)
     (CL:EQ (%DESCRIPTION.PROPOSITION DESCRIPTION) TRUE-PROPOSITION))
    (ISA? DESCRIPTION SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION))
   (MATERIALIZE-PRIMITIVE-DESCRIPTION-BODY DESCRIPTION)))

;;; (DEFUN MATERIALIZE-PRIMITIVE-DESCRIPTION-BODY ...)

(CL:DEFUN MATERIALIZE-PRIMITIVE-DESCRIPTION-BODY (DESCRIPTION)
  (CL:LET*
   ((NATIVE? (CL:NOT (CL:EQ (NATIVE-RELATION DESCRIPTION) NULL)))
    (NAME
     (CL:IF NATIVE?
      (INTERN-SYMBOL-IN-MODULE (NAME (NATIVE-RELATION DESCRIPTION))
       (HOME-MODULE (NATIVE-RELATION DESCRIPTION)) CL:T)
      (DESCRIPTION-NAME DESCRIPTION)))
    (VARIABLETYPES (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES DESCRIPTION))
    (ARITY (LENGTH VARIABLETYPES)) (TREE NULL) (VARIABLES NIL)
    (ARGUMENTS NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
   (CL:LET*
    ((I (INTERVAL 1 ARITY)) (NAME NULL)
     (ITER-000 SYSTEM-DEFINED-ARGUMENT-NAMES) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:AND (NEXT? I) (CL:NOT (CL:EQ ITER-000 NIL))) DO
     (CL:SETQ NAME (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS NAME NIL))
       (CL:IF (CL:EQ VARIABLES NIL) (CL:SETQ VARIABLES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST VARIABLES COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS NAME NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ ARGUMENTS (COPY-CONS-LIST VARIABLES))
   (CL:WHEN (CL:AND NATIVE? (CL:> ARITY 1))
    (FIRST-SETTER VARIABLES
     (LIST* SYM-DESCRIPTIONS-STELLA-ISA (%%VALUE VARIABLES)
      (CONS (TYPE-TO-SYMBOL (FIRST VARIABLETYPES)) NIL))))
   (CL:SETQ TREE
    (LIST* SYM-DESCRIPTIONS-LOGIC-KAPPA VARIABLES
     (CONS (CONS NAME (CONCATENATE ARGUMENTS NIL)) NIL)))
   (CL:LET*
    ((*LOGIC-DIALECT* KWD-DESCRIPTIONS-KIF) (*LOGICVARIABLETABLE* NIL)
     (*TERMUNDERCONSTRUCTION* TREE)
     (*EVALUATIONMODE* KWD-DESCRIPTIONS-DESCRIPTION)
     (*CONTEXT* (%NAMED-DESCRIPTION.HOME-CONTEXT DESCRIPTION)))
    (CL:DECLARE
     (CL:SPECIAL *LOGIC-DIALECT* *LOGICVARIABLETABLE*
      *TERMUNDERCONSTRUCTION* *EVALUATIONMODE* *CONTEXT*))
    (CL:LET*
     ((SACRIFICIALDESCRIPTION (EVALUATE-DESCRIPTION-TERM TREE CL:NIL)))
     (CL:SETF (%NAMED-DESCRIPTION.IO-VARIABLES DESCRIPTION)
      (%DESCRIPTION.IO-VARIABLES SACRIFICIALDESCRIPTION))
     (CL:SETF (%NAMED-DESCRIPTION.PROPOSITION DESCRIPTION)
      (%DESCRIPTION.PROPOSITION SACRIFICIALDESCRIPTION))
     (DELETED?-SETTER SACRIFICIALDESCRIPTION CL:T)))))

;;; (DEFUN (CREATE-PRIMITIVE-DESCRIPTION NAMED-DESCRIPTION) ...)

(CL:DEFUN CREATE-PRIMITIVE-DESCRIPTION (IOVARIABLENAMES IOVARIABLETYPES VARIABLEARITY? CLASS? FUNCTION? MODULE)
  (CL:WHEN
   (CL:> (LENGTH IOVARIABLETYPES)
    (LENGTH SYSTEM-DEFINED-ARGUMENT-NAMES))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "PowerLoom can't handle relations with arity > `"
     (LENGTH SYSTEM-DEFINED-ARGUMENT-NAMES) "'" EOL)
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
  (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:LET* ((DESCRIPTION (CREATE-DESCRIPTION NULL-INTEGER CL:T)))
    (CL:SETF (%NAMED-DESCRIPTION.IO-VARIABLE-NAMES DESCRIPTION)
     IOVARIABLENAMES)
    (CL:SETF (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES DESCRIPTION)
     IOVARIABLETYPES)
    (CL:LET*
     ((*FILLINGCONSTRAINTPROPAGATIONQUEUES?* CL:NIL)
      (*EVALUATIONMODE* KWD-DESCRIPTIONS-EXTENSIONAL-ASSERTION))
     (CL:DECLARE
      (CL:SPECIAL *FILLINGCONSTRAINTPROPAGATIONQUEUES?*
       *EVALUATIONMODE*))
     (CL:COND
      (CLASS?
       (LINK-ORIGINATED-PROPOSITION DESCRIPTION
        (ASSERT-ISA-PROPOSITION DESCRIPTION
         SGT-DESCRIPTIONS-PL-KERNEL-KB-CONCEPT)))
      (FUNCTION?
       (LINK-ORIGINATED-PROPOSITION DESCRIPTION
        (ASSERT-ISA-PROPOSITION DESCRIPTION
         SGT-DESCRIPTIONS-PL-KERNEL-KB-FUNCTION)))
      (CL:T
       (LINK-ORIGINATED-PROPOSITION DESCRIPTION
        (ASSERT-ISA-PROPOSITION DESCRIPTION
         SGT-DESCRIPTIONS-PL-KERNEL-KB-RELATION))))
     (CL:WHEN VARIABLEARITY?
      (LINK-ORIGINATED-PROPOSITION DESCRIPTION
       (ASSERT-PROPERTY DESCRIPTION
        SGT-DESCRIPTIONS-PL-KERNEL-KB-VARIABLE-ARITY)))
     DESCRIPTION))))

;;; (DEFUN LINK-STELLA-RELATION-AND-DESCRIPTION ...)

(CL:DEFUN LINK-STELLA-RELATION-AND-DESCRIPTION (SELF DESCRIPTION)
  (SET-DYNAMIC-SLOT-VALUE (%RELATION.DYNAMIC-SLOTS SELF)
   SYM-DESCRIPTIONS-LOGIC-DESCRIPTION DESCRIPTION NULL)
  (NATIVE-RELATION-SETTER DESCRIPTION SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
     (CL:PROGN
      (CL:SETF (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE DESCRIPTION)
       (CLASS-LOGICAL-TYPE SELF))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-SLOT)
     (CL:PROGN
      (CL:SETF (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE DESCRIPTION)
       (%SLOT.SLOT-SLOTREF SELF))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
  (CL:WHEN (POLYMORPHIC-RELATION? SELF)
   (CREATE-BASE-RELATION-FOR-POLYMORPHIC-DESCRIPTION DESCRIPTION))
  NULL)

;;; (DEFUN (CREATE-DESCRIPTION-FOR-STELLA-RELATION NAMED-DESCRIPTION) ...)

(CL:DEFUN CREATE-DESCRIPTION-FOR-STELLA-RELATION (SELF)
  (CL:LET* ((SUPER NULL) (ITER-000 (DIRECT-SUPERRELATIONS SELF)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ SUPER (%ITERATOR.VALUE ITER-000))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ SUPER NULL))
      (CL:OR (CL:NOT (ISA? SUPER SGT-DESCRIPTIONS-STELLA-CLASS))
       (LOGIC-CLASS? SUPER)))
     (GET-DESCRIPTION SUPER))))
  (CL:LET* ((DESCRIPTION NULL) (HOMEMODULE NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ HOMEMODULE (HOME-MODULE (CLASS-LOGICAL-TYPE SELF)))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-SLOT)
      (CL:PROGN (CL:SETQ HOMEMODULE (HOME-MODULE SELF))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:WHEN (CL:NOT (VISIBLE-FROM? *PL-KERNEL-MODULE* HOMEMODULE))
    (CL:SETQ HOMEMODULE *PL-KERNEL-MODULE*))
   (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF-CLASS? TEST-VALUE-001)
      (CL:PROGN
       (CL:WHEN (CL:NOT (LOGIC-CLASS? SELF))
        (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
           "ERROR: Can't use the class `" SELF
           "' as a logic class because it" EOL
           "   does not inherit the top-level class THING.." EOL)
          (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001
           KWD-DESCRIPTIONS-ERROR))
         (CL:ERROR
          (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001)))))
       (CL:SETQ DESCRIPTION
        (CREATE-PRIMITIVE-DESCRIPTION NIL-LIST
         (LIST (CLASS-LOGICAL-TYPE SELF)) CL:NIL CL:T CL:NIL
         HOMEMODULE))))
     ((SUBTYPE-OF? TEST-VALUE-001 SGT-DESCRIPTIONS-STELLA-SLOT)
      (CL:PROGN
       (CL:LET*
        ((SLOTREF (%SLOT.SLOT-SLOTREF SELF))
         (SUPERSLOTREF (MOST-GENERAL-EQUIVALENT-SLOTREF SLOTREF)))
        (CL:WHEN (CL:NOT (CL:EQ SLOTREF SUPERSLOTREF))
         (CL:SETQ SELF (%SURROGATE.SURROGATE-VALUE SUPERSLOTREF))
         (CL:WHEN
          (CL:NOT
           (CL:EQ
            (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
             SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
            NULL))
          (CL:RETURN-FROM CREATE-DESCRIPTION-FOR-STELLA-RELATION
           (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
            SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)))))
       (CL:LET* ((SELF-004 (NEW-LIST)))
        (CL:SETF (%LIST.THE-CONS-LIST SELF-004)
         (SLOT-COLUMN-TYPES SELF NULL-INTEGER))
        (CL:SETQ DESCRIPTION
         (CREATE-PRIMITIVE-DESCRIPTION NIL-LIST SELF-004 CL:NIL CL:NIL
          (CL:NOT (BOOLEAN-TYPE? (%SLOT.SLOT-BASE-TYPE SELF)))
          HOMEMODULE)))))
     (CL:T
      (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
        "`" TEST-VALUE-001 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))))
   (LINK-STELLA-RELATION-AND-DESCRIPTION SELF DESCRIPTION)
   (FINALIZE-SUPERRELATION-LINKS SELF)
   (ENSURE-DESCRIPTION-BODY DESCRIPTION) DESCRIPTION))

;;; (DEFUN (SURROGATE-TO-DESCRIPTION NAMED-DESCRIPTION) ...)

(CL:DEFUN SURROGATE-TO-DESCRIPTION (SELF)
  (CL:LET* ((SURROGATEVALUE (%SURROGATE.SURROGATE-VALUE SELF)))
   (CL:WHEN (CL:EQ SURROGATEVALUE NULL)
    (CL:RETURN-FROM SURROGATE-TO-DESCRIPTION NULL))
   (CL:IF
    (ISA? SURROGATEVALUE SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION)
    SURROGATEVALUE (GET-DESCRIPTION SELF))))

;;; (DEFUN (GET-DESCRIPTION NAMED-DESCRIPTION) ...)

(CL:DEFUN GET-DESCRIPTION (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN SELF))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (SURROGATE.GET-DESCRIPTION SELF)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN (GET-DESCRIPTION (SYMBOL-TO-SURROGATE SELF))))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (STRING.GET-DESCRIPTION (%STRING-WRAPPER.WRAPPER-VALUE SELF))))
    ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
     (CL:PROGN (CLASS.GET-DESCRIPTION SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-SLOT)
     (CL:PROGN (SLOT.GET-DESCRIPTION SELF)))
    (CL:T NULL))))

;;; (DEFUN (SURROGATE.GET-DESCRIPTION NAMED-DESCRIPTION) ...)

(CL:DEFUN SURROGATE.GET-DESCRIPTION (SELF)
  (CL:LET* ((VALUE (%SURROGATE.SURROGATE-VALUE SELF)) (STORE NULL))
   (CL:COND
    ((CL:NOT (CL:EQ VALUE NULL))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VALUE)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION)
        (CL:PROGN VALUE))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-RELATION)
        (CL:PROGN
         (CL:COND
          ((CL:NOT
            (CL:EQ
             (DYNAMIC-SLOT-VALUE (%RELATION.DYNAMIC-SLOTS VALUE)
              SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
             NULL))
           (DYNAMIC-SLOT-VALUE (%RELATION.DYNAMIC-SLOTS VALUE)
            SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL))
          (CL:T (CREATE-DESCRIPTION-FOR-STELLA-RELATION VALUE)))))
       (CL:T NULL))))
    ((CL:NOT (CL:EQ (CL:SETQ STORE (HOME-OBJECT-STORE SELF)) NULL))
     (FETCH-RELATION STORE SELF))
    (CL:T NULL))))

;;; (DEFUN (STRING.GET-DESCRIPTION NAMED-DESCRIPTION) ...)

(CL:DEFUN STRING.GET-DESCRIPTION (SELF)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:SIMPLE-STRING)
  (CL:LET* ((SURROGATE (LOOKUP-SURROGATE SELF)) (STORE NULL))
   (CL:COND
    ((CL:NOT (CL:EQ SURROGATE NULL)) (GET-DESCRIPTION SURROGATE))
    ((CL:NOT
      (CL:EQ
       (CL:SETQ STORE
        (DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS *MODULE*)
         SYM-DESCRIPTIONS-LOGIC-OBJECT-STORE NULL))
       NULL))
     (FETCH-RELATION STORE (WRAP-STRING SELF)))
    (CL:T NULL))))

;;; (DEFUN (CLASS.GET-DESCRIPTION NAMED-DESCRIPTION) ...)

(CL:DEFUN CLASS.GET-DESCRIPTION (SELF)
  (CL:COND
   ((CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS SELF)
       SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
      NULL))
    (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS SELF)
     SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL))
   ((CL:NOT (LOGIC-CLASS? SELF))
    (CL:WHEN (CL:NOT *SUPPRESSNONLOGICOBJECTWARNING?*)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Reference to non-logic class: `" (NAME SELF) "'" EOL
      "Class must inherit 'THING' to be used by PowerLoom's logic." EOL
      EOL))
    NULL)
   (CL:T (GET-DESCRIPTION (CLASS-LOGICAL-TYPE SELF)))))

;;; (DEFUN (SLOT.GET-DESCRIPTION NAMED-DESCRIPTION) ...)

(CL:DEFUN SLOT.GET-DESCRIPTION (SELF)
  (CL:COND
   ((CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
       SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
      NULL))
    (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
     SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL))
   ((CL:NOT (CL:EQ (%SLOT.SLOT-SLOTREF SELF) NULL))
    (GET-DESCRIPTION (%SLOT.SLOT-SLOTREF SELF)))
   (CL:T
    (GET-DESCRIPTION
     (LOOKUP-SLOTREF (%SLOT.SLOT-OWNER SELF) (%SLOT.SLOT-NAME SELF))))))

;;; (DEFUN (ENSURE-DEFERRED-DESCRIPTION SURROGATE) ...)

(CL:DEFUN ENSURE-DEFERRED-DESCRIPTION (SELF)
  (CL:WHEN
   (CL:AND (CL:EQ (%SURROGATE.SURROGATE-VALUE SELF) NULL)
    (CL:NOT (CL:EQ (HOME-OBJECT-STORE SELF) NULL)))
   (GET-DESCRIPTION SELF))
  SELF)

;;; (DEFUN (LOGIC-CLASS? BOOLEAN) ...)

(CL:DEFUN LOGIC-CLASS? (SELF)
  "Return TRUE if the class 'self' or one of its
supers supports indices that record extensions referenced by
the logic system. Also return true for literal classes."
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:IF
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS SELF)
       SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
      NULL))
    (CL:SETQ TEST-VALUE-000 CL:T)
    (CL:PROGN
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET*
       ((C NULL) (ITER-000 (%CLASS.CLASS-ALL-SUPER-CLASSES SELF)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ C (%%VALUE ITER-000))
        (CL:WHEN
         (CL:OR
          (CL:NOT
           (CL:EQ
            (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS C)
             SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)
            NULL))
          (CL:EQ C
           (%SURROGATE.SURROGATE-VALUE SGT-DESCRIPTIONS-STELLA-THING)))
         (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:SETQ TEST-VALUE-000 FOUND?-000))
     (CL:WHEN (CL:NOT TEST-VALUE-000)
      (CL:SETQ TEST-VALUE-000
       (CL:OR
        (CL:EQ SELF
         (%SURROGATE.SURROGATE-VALUE SGT-DESCRIPTIONS-STELLA-THING))
        (SUBCLASS-OF? SELF
         (%SURROGATE.SURROGATE-VALUE SGT-DESCRIPTIONS-STELLA-LITERAL))
        (CL:EQ SELF
         (%SURROGATE.SURROGATE-VALUE
          SGT-DESCRIPTIONS-LOGIC-PROPOSITION)))))))
   (CL:WHEN TEST-VALUE-000 (CL:RETURN-FROM LOGIC-CLASS? CL:T)))
  (CL:WHEN (CL:NOT (%CLASS.CLASS-FINALIZED? SELF))
   (CL:LET*
    ((BADSUPERS
      (COLLECT-BAD-SUPER-CLASSES (%CLASS.CLASS-TYPE SELF) (LIST))))
    (CL:IF (EMPTY? BADSUPERS)
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
       "WARNING: Could not determine whether " SELF
       " is a logic class, because it is not finalized." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
       KWD-DESCRIPTIONS-WARNING))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
       "WARNING: Could not determine whether " SELF
       " is a logic class, because it is not finalized." EOL
       "   It has these undefined or bad supers: "
       (%LIST.THE-CONS-LIST BADSUPERS) EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
       KWD-DESCRIPTIONS-WARNING)))))
  CL:NIL)

;;; (DEFUN (VARIABLE-ARITY-DOMAIN-TYPES-NEXT? BOOLEAN) ...)

(CL:DEFUN VARIABLE-ARITY-DOMAIN-TYPES-NEXT? (SELF)
  (CL:LET*
   ((NESTEDITERATOR
     (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR SELF)))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ NESTEDITERATOR NULL))
     (NEXT? NESTEDITERATOR))
    (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF)
     (%ITERATOR.VALUE NESTEDITERATOR))
    (CL:PROGN
     (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR SELF)
      NULL)
     (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF)
      (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT SELF))))
   CL:T))

;;; (DEFUN (WRAP-ITERATOR-FOR-VARIABLE-ARITY ITERATOR) ...)

(CL:DEFUN WRAP-ITERATOR-FOR-VARIABLE-ARITY (ITERATOR)
  (CL:LET* ((ALLPURPOSEITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE ALLPURPOSEITERATOR)
    (CL:FUNCTION VARIABLE-ARITY-DOMAIN-TYPES-NEXT?))
   (CL:SETF
    (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR ALLPURPOSEITERATOR)
    ITERATOR)
   ALLPURPOSEITERATOR))

;;; (DEFUN (ALL-DOMAIN-TYPES ITERATOR) ...)

(CL:DEFUN ALL-DOMAIN-TYPES (SELF)
  (CL:LET*
   ((ITERATOR
     (CL:IF (FUNCTION-DESCRIPTION? SELF)
      (BUT-LAST (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES SELF))
      (ALLOCATE-ITERATOR
       (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES SELF)))))
   (CL:IF (VARIABLE-ARITY? SELF)
    (WRAP-ITERATOR-FOR-VARIABLE-ARITY ITERATOR) ITERATOR)))

;;; (DEFUN (ALL-ARGUMENT-TYPES ITERATOR) ...)

(CL:DEFUN ALL-ARGUMENT-TYPES (SELF)
  (CL:IF (VARIABLE-ARITY? SELF)
   (WRAP-ITERATOR-FOR-VARIABLE-ARITY
    (ALLOCATE-ITERATOR (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES SELF)))
   (ALLOCATE-ITERATOR (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES SELF))))

;;; (DEFSPECIAL *LOGICVARIABLETABLE* ...)

(CL:DEFVAR *LOGICVARIABLETABLE* NULL
  "Table mapping logic variable names to variables or skolems.
Used during construction of a proposition or description.")

;;; (DEFUN PUSH-LOGIC-VARIABLE-BINDING ...)

(CL:DEFUN PUSH-LOGIC-VARIABLE-BINDING (VARIABLE)
  (CL:WHEN (ANONYMOUS-VARIABLE? VARIABLE)
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "ERROR: Illegal nameless variable '?' found in list of
quantified variables." EOL "   Quantified variables must have names.."
      EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-DESCRIPTIONS-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:SETQ *LOGICVARIABLETABLE* (CONS VARIABLE *LOGICVARIABLETABLE*)))

;;; (DEFUN POP-LOGIC-VARIABLE-BINDING ...)

(CL:DEFUN POP-LOGIC-VARIABLE-BINDING ()
  (CL:LET* ((HEADCONS *LOGICVARIABLETABLE*))
   (CL:SETQ *LOGICVARIABLETABLE* (%%REST HEADCONS)) (FREE HEADCONS)))

;;; (DEFUN POP-LOGIC-VARIABLE-BINDINGS ...)

(CL:DEFUN POP-LOGIC-VARIABLE-BINDINGS (VARIABLES)
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 (LENGTH VARIABLES)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
   (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
    (CL:SETQ I ITER-000) (CL:SETQ I I) (POP-LOGIC-VARIABLE-BINDING)
    (CL:SETQ ITER-000 (CL:1+ ITER-000)))))

;;; (DEFUN (LOOKUP-LOGIC-VARIABLE-BINDING OBJECT) ...)

(CL:DEFUN LOOKUP-LOGIC-VARIABLE-BINDING (VARIABLENAME)
  (CL:WHEN (CL:NOT (CL:EQ *LOGICVARIABLETABLE* NULL))
   (CL:LET* ((VBL NULL) (ITER-000 *LOGICVARIABLETABLE*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ VBL (%%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%SKOLEM.SKOLEM-NAME VBL) VARIABLENAME)
      (CL:RETURN-FROM LOOKUP-LOGIC-VARIABLE-BINDING VBL))
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  NULL)

;;; (DEFSPECIAL *VARIABLETYPEPROPOSITIONS* ...)

(CL:DEFVAR *VARIABLETYPEPROPOSITIONS*)

;;; (DEFUN PARSE-ONE-VARIABLE-DECLARATION ...)

(CL:DEFUN PARSE-ONE-VARIABLE-DECLARATION (VDEC LOCALDECLARATIONS)
  (CL:LET* ((VARIABLENAME NULL) (ISATREE NULL) (VARIABLE NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VDEC)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-CONS)
      (CL:PROGN (CL:SETQ VARIABLENAME (%%VALUE (%%REST VDEC)))
       (CL:SETQ ISATREE VDEC)))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ VARIABLENAME VDEC)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:LET*
    ((V NULL) (ITER-000 (%LIST.THE-CONS-LIST LOCALDECLARATIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ V (%%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%PATTERN-VARIABLE.SKOLEM-NAME V) VARIABLENAME)
      (CL:SETQ VARIABLE V))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:EQ VARIABLE NULL)
    (CL:SETQ VARIABLE (CREATE-VARIABLE NULL VARIABLENAME CL:T)))
   (PUSH-LOGIC-VARIABLE-BINDING VARIABLE)
   (INSERT-LAST LOCALDECLARATIONS VARIABLE)
   (CL:WHEN (CL:NOT (CL:EQ ISATREE NULL))
    (CL:LET*
     ((PROPOSITION (BUILD-TOP-LEVEL-PROPOSITION ISATREE CL:NIL)))
     (CL:WHEN (CL:EQ PROPOSITION NULL)
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
         "ERROR: Error in declarations." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001
         KWD-DESCRIPTIONS-ERROR))
       (CL:ERROR
        (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001)))))
     (CL:WHEN
      (CL:EQ (%PROPOSITION.KIND PROPOSITION) KWD-DESCRIPTIONS-ISA)
      (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
       SYM-DESCRIPTIONS-LOGIC-VARIABLE-TYPE? TRUE-WRAPPER NULL)
      (UPDATE-SKOLEM-TYPE
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
        0)
       (%PROPOSITION.OPERATOR PROPOSITION))
      (CL:SETQ *VARIABLETYPEPROPOSITIONS*
       (CONS PROPOSITION *VARIABLETYPEPROPOSITIONS*)))))))

;;; (DEFUN (PARSE-LOGIC-VARIABLE-DECLARATIONS (CONS OF PATTERN-VARIABLE)) ...)

(CL:DEFUN PARSE-LOGIC-VARIABLE-DECLARATIONS (TREE)
  (CL:LET*
   ((CONSTREE
     (CL:IF (ISA? TREE SGT-DESCRIPTIONS-STELLA-CONS) TREE
      (CONS-LIST TREE)))
    (DECLARATIONS (NEW-LIST)))
   (CL:LET* ((TERM NULL) (ITER-000 CONSTREE))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ TERM (%%VALUE ITER-000))
     (PARSE-ONE-VARIABLE-DECLARATION TERM DECLARATIONS)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (%LIST.THE-CONS-LIST DECLARATIONS)))

;;; (DEFUN (HELP-BUILD-QUANTIFIED-PROPOSITION (CONS OF SKOLEM) PROPOSITION PROPOSITION) ...)

(CL:DEFUN HELP-BUILD-QUANTIFIED-PROPOSITION (TREE CONVERTTYPESTOCONSTRAINTS?)
  (CL:LET* ((*VARIABLETYPEPROPOSITIONS* NIL))
   (CL:DECLARE (CL:SPECIAL *VARIABLETYPEPROPOSITIONS*))
   (CL:LET*
    ((QUANTIFIER (%%VALUE TREE))
     (ANTECEDENTCLAUSE (%%VALUE (%%REST (%%REST TREE))))
     (CONSEQUENTCLAUSE (FOURTH TREE)) (VARIABLES NULL)
     (ANTECEDENTPROPOSITION NULL) (CONSEQUENTPROPOSITION NULL))
    (CL:SETQ VARIABLES
     (PARSE-LOGIC-VARIABLE-DECLARATIONS (%%VALUE (%%REST TREE))))
    (CL:WHEN (CL:NOT (CL:EQ ANTECEDENTCLAUSE NULL))
     (CL:SETQ ANTECEDENTPROPOSITION
      (BUILD-PROPOSITION ANTECEDENTCLAUSE)))
    (CL:WHEN (CL:NOT (CL:EQ CONSEQUENTCLAUSE NULL))
     (CL:SETQ CONSEQUENTPROPOSITION
      (BUILD-PROPOSITION CONSEQUENTCLAUSE)))
    (POP-LOGIC-VARIABLE-BINDINGS VARIABLES)
    (CL:WHEN CONVERTTYPESTOCONSTRAINTS?
     (CL:WHEN (CL:NOT (CL:EQ *VARIABLETYPEPROPOSITIONS* NIL))
      (CL:WHEN (CL:NOT (CL:EQ ANTECEDENTPROPOSITION NULL))
       (CL:SETQ *VARIABLETYPEPROPOSITIONS*
        (CONS ANTECEDENTPROPOSITION *VARIABLETYPEPROPOSITIONS*)))
      (CL:SETQ *VARIABLETYPEPROPOSITIONS*
       (REMOVE-DUPLICATES (REVERSE *VARIABLETYPEPROPOSITIONS*)))
      (CL:SETQ ANTECEDENTPROPOSITION
       (CONJOIN-PROPOSITIONS *VARIABLETYPEPROPOSITIONS*))))
    (CL:VALUES VARIABLES ANTECEDENTPROPOSITION CONSEQUENTPROPOSITION))))

;;; (DEFUN (BUILD-QUANTIFIED-PROPOSITION (CONS OF SKOLEM) PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-QUANTIFIED-PROPOSITION (TREE CONVERTTYPESTOCONSTRAINTS?)
  (CL:COND
   ((CL:EQ (%%VALUE TREE) SYM-DESCRIPTIONS-STELLA-EXISTS)
    (CL:LET* ((*EVALUATIONMODE* KWD-DESCRIPTIONS-DESCRIPTION))
     (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
     (HELP-BUILD-QUANTIFIED-PROPOSITION TREE
      CONVERTTYPESTOCONSTRAINTS?)))
   (CL:T
    (CL:LET* ((*EVALUATIONMODE* KWD-DESCRIPTIONS-DESCRIPTION))
     (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
     (HELP-BUILD-QUANTIFIED-PROPOSITION TREE
      CONVERTTYPESTOCONSTRAINTS?)))))

;;; (DEFUN (COPY-CONS-LIST-TO-VARIABLES-VECTOR VARIABLES-VECTOR) ...)

(CL:DEFUN COPY-CONS-LIST-TO-VARIABLES-VECTOR (CONSLIST)
  (CL:WHEN (CL:EQ CONSLIST NIL)
   (CL:RETURN-FROM COPY-CONS-LIST-TO-VARIABLES-VECTOR
    ZERO-VARIABLES-VECTOR))
  (CL:LET* ((VECTOR (NEW-VECTOR (LENGTH CONSLIST))))
   (CL:LET*
    ((T NULL) (ITER-000 CONSLIST) (I NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ T (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:LET ((SELF (%VECTOR.THE-ARRAY VECTOR)) (VALUE T) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   VECTOR))

;;; (DEFUN (EQUIVALENT-HOLDS-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN EQUIVALENT-HOLDS-PROPOSITION? (SELF OTHER MAPPING)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000
    (EQUIVALENT-FORMULAE?
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      0)
     (%PROPOSITION.OPERATOR OTHER) MAPPING))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000
     (CL:= (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS SELF)))
      (LENGTH (%PROPOSITION.ARGUMENTS OTHER))))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((ALWAYS?-000 CL:T))
      (CL:LET*
       ((I1 NULL-INTEGER) (ITER-000 1) (ARG2 NULL)
        (VECTOR-000 (%PROPOSITION.ARGUMENTS OTHER)) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM I1 ITER-000 INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ I1 ITER-000)
        (CL:SETQ ARG2
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:WHEN
         (CL:NOT
          (EQUIVALENT-FORMULAE?
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
            I1)
           ARG2 MAPPING))
         (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
        (CL:SETQ ITER-000 (CL:1+ ITER-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:SETQ TEST-VALUE-000 ALWAYS?-000))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (EQUIVALENT-COMMUTATIVE-PROPOSITIONS? BOOLEAN) ...)

(CL:DEFUN EQUIVALENT-COMMUTATIVE-PROPOSITIONS? (SELF OTHER MAPPING)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000
    (CL:EQ (%PROPOSITION.OPERATOR SELF) (%PROPOSITION.OPERATOR OTHER)))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000
     (CL:= (LENGTH (%PROPOSITION.ARGUMENTS SELF))
      (LENGTH (%PROPOSITION.ARGUMENTS OTHER))))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((ALWAYS?-000 CL:T))
      (CL:LET*
       ((ARG1 NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG1
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:LET* ((TEST-VALUE-001 CL:NIL))
         (CL:LET* ((FOUND?-000 CL:NIL))
          (CL:LET*
           ((ARG2 NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS OTHER))
            (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
           (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
            (CL:SETQ ARG2
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
              INDEX-001))
            (CL:WHEN (EQUIVALENT-FORMULAE? ARG1 ARG2 MAPPING)
             (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
            (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
          (CL:SETQ TEST-VALUE-001 FOUND?-000))
         (CL:SETQ TEST-VALUE-001 (CL:NOT TEST-VALUE-001))
         (CL:WHEN TEST-VALUE-001 (CL:SETQ ALWAYS?-000 CL:NIL)
          (CL:RETURN)))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:SETQ TEST-VALUE-000 ALWAYS?-000))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (EQUIVALENT-PROPOSITIONS? BOOLEAN) ...)

(CL:DEFUN EQUIVALENT-PROPOSITIONS? (SELF OTHER MAPPING)
  (CL:WHEN (CL:EQ SELF OTHER)
   (CL:RETURN-FROM EQUIVALENT-PROPOSITIONS? CL:T))
  (CL:WHEN
   (CL:NOT (CL:EQ (%PROPOSITION.KIND SELF) (%PROPOSITION.KIND OTHER)))
   (CL:RETURN-FROM EQUIVALENT-PROPOSITIONS? CL:NIL))
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-AND)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-OR)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EQUIVALENT))
     (EQUIVALENT-COMMUTATIVE-PROPOSITIONS? SELF OTHER MAPPING))
    (CL:T
     (CL:LET* ((TEST-VALUE-001 (%PROPOSITION.KIND SELF)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-001 KWD-DESCRIPTIONS-FORALL)
         (CL:EQ TEST-VALUE-001 KWD-DESCRIPTIONS-EXISTS))
        (CL:LET*
         ((IOVARS1
           (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
            SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL))
          (IOVARS2
           (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS OTHER)
            SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL)))
         (CL:WHEN (CL:NOT (CL:= (LENGTH IOVARS1) (LENGTH IOVARS2)))
          (CL:RETURN-FROM EQUIVALENT-PROPOSITIONS? CL:NIL))
         (CL:WHEN (CL:EQ MAPPING NULL)
          (CL:SETQ MAPPING (NEW-KEY-VALUE-LIST)))
         (CL:LET*
          ((V1 NULL) (VECTOR-000 IOVARS1) (INDEX-000 0)
           (LENGTH-000 (LENGTH VECTOR-000)) (V2 NULL)
           (VECTOR-001 IOVARS2) (INDEX-001 0)
           (LENGTH-001 (LENGTH VECTOR-001)))
          (CL:DECLARE
           (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001
            LENGTH-001))
          (CL:LOOP WHILE
           (CL:AND (CL:< INDEX-000 LENGTH-000)
            (CL:< INDEX-001 LENGTH-001))
           DO
           (CL:SETQ V1
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
             INDEX-000))
           (CL:SETQ V2
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
             INDEX-001))
           (INSERT-AT MAPPING V1 V2)
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
           (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))))
       (CL:T)))
     (CL:LET* ((TEST-VALUE-002 CL:NIL))
      (CL:SETQ TEST-VALUE-002
       (CL:EQ (%PROPOSITION.OPERATOR SELF)
        (%PROPOSITION.OPERATOR OTHER)))
      (CL:WHEN TEST-VALUE-002
       (CL:LET* ((ALWAYS?-000 CL:T))
        (CL:LET*
         ((ARG1 NULL) (VECTOR-002 (%PROPOSITION.ARGUMENTS SELF))
          (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)) (ARG2 NULL)
          (VECTOR-003 (%PROPOSITION.ARGUMENTS OTHER)) (INDEX-003 0)
          (LENGTH-003 (LENGTH VECTOR-003)))
         (CL:DECLARE
          (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002 INDEX-003
           LENGTH-003))
         (CL:LOOP WHILE
          (CL:AND (CL:< INDEX-002 LENGTH-002)
           (CL:< INDEX-003 LENGTH-003))
          DO
          (CL:SETQ ARG1
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
            INDEX-002))
          (CL:SETQ ARG2
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-003))
            INDEX-003))
          (CL:WHEN (CL:NOT (EQUIVALENT-FORMULAE? ARG1 ARG2 MAPPING))
           (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
          (CL:SETQ INDEX-002 (CL:1+ INDEX-002))
          (CL:SETQ INDEX-003 (CL:1+ INDEX-003))))
        (CL:SETQ TEST-VALUE-002 ALWAYS?-000))
       (CL:WHEN TEST-VALUE-002
        (CL:SETQ TEST-VALUE-002
         (CL:= (LENGTH (%PROPOSITION.ARGUMENTS SELF))
          (LENGTH (%PROPOSITION.ARGUMENTS OTHER))))))
      (CL:WHEN (CL:NOT TEST-VALUE-002)
       (CL:SETQ TEST-VALUE-002
        (CL:AND (CL:NOT (CL:EQ MAPPING NULL))
         (CL:EQ (%PROPOSITION.OPERATOR SELF)
          SGT-DESCRIPTIONS-PL-KERNEL-KB-HOLDS)
         (EQUIVALENT-HOLDS-PROPOSITION? SELF OTHER MAPPING))))
      (CL:LET* ((VALUE-000 TEST-VALUE-002)) VALUE-000))))))

;;; (DEFUN (EQUIVALENT-FUNCTION-PROPOSITIONS? BOOLEAN) ...)

(CL:DEFUN EQUIVALENT-FUNCTION-PROPOSITIONS? (SELF OTHER MAPPING)
  (CL:WHEN
   (CL:AND (CL:EQ (%PROPOSITION.KIND SELF) KWD-DESCRIPTIONS-FUNCTION)
    (CL:EQ (%PROPOSITION.KIND OTHER) KWD-DESCRIPTIONS-FUNCTION))
   (CL:WHEN (CL:EQ MAPPING NULL)
    (CL:SETQ MAPPING (NEW-KEY-VALUE-LIST)))
   (INSERT-AT MAPPING
    (CL:AREF
     (CL:THE CL:SIMPLE-VECTOR
      (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
     (CL:THE CL:FIXNUM (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS SELF)))))
    (CL:AREF
     (CL:THE CL:SIMPLE-VECTOR
      (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS OTHER)))
     (CL:THE CL:FIXNUM
      (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS OTHER))))))
   (CL:RETURN-FROM EQUIVALENT-FUNCTION-PROPOSITIONS?
    (EQUIVALENT-PROPOSITIONS? SELF OTHER MAPPING)))
  CL:NIL)

;;; (DEFUN (EQUIVALENT-DESCRIPTIONS? BOOLEAN) ...)

(CL:DEFUN EQUIVALENT-DESCRIPTIONS? (SELF OTHER MAPPING)
  (CL:WHEN (CL:EQ SELF OTHER)
   (CL:RETURN-FROM EQUIVALENT-DESCRIPTIONS? CL:T))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ (DESCRIPTION-NAME SELF) NULL))
    (CL:NOT (CL:EQ (DESCRIPTION-NAME OTHER) NULL)))
   (CL:RETURN-FROM EQUIVALENT-DESCRIPTIONS? CL:NIL))
  (CL:WHEN (CL:NOT (CL:= (ARITY SELF) (ARITY OTHER)))
   (CL:RETURN-FROM EQUIVALENT-DESCRIPTIONS? CL:NIL))
  (CL:COND ((NAMED-DESCRIPTION? SELF) CL:NIL)
   (CL:T
    (CL:WHEN (CL:EQ MAPPING NULL)
     (CL:SETQ MAPPING (NEW-KEY-VALUE-LIST)))
    (CL:LET*
     ((V1 NULL) (VECTOR-000 (%DESCRIPTION.IO-VARIABLES SELF))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (V2 NULL)
      (VECTOR-001 (%DESCRIPTION.IO-VARIABLES OTHER)) (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
      DO
      (CL:SETQ V1
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ V2
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
        INDEX-001))
      (INSERT-AT MAPPING V1 V2) (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
    (CL:LET*
     ((V1 NULL) (VECTOR-002 (%DESCRIPTION.INTERNAL-VARIABLES SELF))
      (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)) (V2 NULL)
      (VECTOR-003 (%DESCRIPTION.INTERNAL-VARIABLES OTHER))
      (INDEX-003 0) (LENGTH-003 (LENGTH VECTOR-003)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002 INDEX-003 LENGTH-003))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-002 LENGTH-002) (CL:< INDEX-003 LENGTH-003))
      DO
      (CL:SETQ V1
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
        INDEX-002))
      (CL:SETQ V2
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-003))
        INDEX-003))
      (INSERT-AT MAPPING V1 V2) (CL:SETQ INDEX-002 (CL:1+ INDEX-002))
      (CL:SETQ INDEX-003 (CL:1+ INDEX-003))))
    (EQUIVALENT-FORMULAE? (%DESCRIPTION.PROPOSITION SELF)
     (%DESCRIPTION.PROPOSITION OTHER) MAPPING))))

;;; (DEFUN (EQUIVALENT-ENUMERATIONS? BOOLEAN) ...)

(CL:DEFUN EQUIVALENT-ENUMERATIONS? (SELF OTHER)
  (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-002 SGT-DESCRIPTIONS-STELLA-SET)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 CL:NIL))
       (CL:SETQ TEST-VALUE-000 (CL:= (LENGTH SELF) (LENGTH OTHER)))
       (CL:WHEN TEST-VALUE-000
        (CL:LET* ((ALWAYS?-000 CL:T))
         (CL:LET* ((M NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
          (CL:LOOP WHILE (NEXT? ITER-000) DO
           (CL:SETQ M (%LIST-ITERATOR.VALUE ITER-000))
           (CL:WHEN (CL:NOT (MEMBER? OTHER M))
            (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))))
         (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
       (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000))))
    ((SUBTYPE-OF? TEST-VALUE-002 SGT-DESCRIPTIONS-STELLA-LIST)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-001 CL:NIL))
       (CL:SETQ TEST-VALUE-001 (CL:= (LENGTH SELF) (LENGTH OTHER)))
       (CL:WHEN TEST-VALUE-001
        (CL:LET* ((ALWAYS?-001 CL:T))
         (CL:LET* ((M NULL) (ITER-001 (%LIST.THE-CONS-LIST SELF)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:SETQ M (%%VALUE ITER-001))
           (CL:WHEN (CL:NOT (MEMBER? OTHER M))
            (CL:SETQ ALWAYS?-001 CL:NIL) (CL:RETURN))
           (CL:SETQ ITER-001 (%%REST ITER-001))))
         (CL:SETQ TEST-VALUE-001 ALWAYS?-001)))
       (CL:LET* ((VALUE-001 TEST-VALUE-001)) VALUE-001))))
    (CL:T CL:NIL))))

;;; (DEFUN (EQUIVALENT-FORMULAE? BOOLEAN) ...)

(CL:DEFUN EQUIVALENT-FORMULAE? (SELF OTHER MAPPING)
  (CL:LET* ((SURROGATEVALUE NULL))
   (CL:WHEN (ISA? SELF SGT-DESCRIPTIONS-STELLA-SURROGATE)
    (CL:SETQ SURROGATEVALUE (%SURROGATE.SURROGATE-VALUE SELF))
    (CL:WHEN (CL:NOT (CL:EQ SURROGATEVALUE NULL))
     (CL:SETQ SELF SURROGATEVALUE)))
   (CL:WHEN (ISA? OTHER SGT-DESCRIPTIONS-STELLA-SURROGATE)
    (CL:SETQ SURROGATEVALUE (%SURROGATE.SURROGATE-VALUE OTHER))
    (CL:WHEN (CL:NOT (CL:EQ SURROGATEVALUE NULL))
     (CL:SETQ OTHER SURROGATEVALUE))))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ MAPPING NULL))
    (CL:OR (EQL? OTHER (LOOKUP MAPPING SELF))
     (EQL? SELF (LOOKUP MAPPING OTHER))))
   (CL:RETURN-FROM EQUIVALENT-FORMULAE? CL:T))
  (CL:WHEN (EQUAL? SELF OTHER)
   (CL:RETURN-FROM EQUIVALENT-FORMULAE? CL:T))
  (CL:WHEN (CL:NOT (CL:EQ MAPPING NULL))
   (CL:WHEN
    (CL:AND *UNIFY-PROPOSITIONS?*
     (CL:OR (VARIABLE? SELF) (VARIABLE? OTHER)))
    (CL:WHEN (CL:EQ *QUERYITERATOR* NULL)
     (INSERT-AT MAPPING SELF OTHER)
     (CL:RETURN-FROM EQUIVALENT-FORMULAE? CL:T))
    (CL:LET*
     ((VALUE1 (ARGUMENT-BOUND-TO SELF))
      (VALUE2 (ARGUMENT-BOUND-TO OTHER)))
     (CL:COND
      ((CL:OR (CL:EQ VALUE1 NULL) (CL:EQ VALUE2 NULL))
       (INSERT-AT MAPPING SELF OTHER)
       (CL:RETURN-FROM EQUIVALENT-FORMULAE? CL:T))
      (CL:T
       (CL:RETURN-FROM EQUIVALENT-FORMULAE? (EQUAL? VALUE1 VALUE2)))))))
  (CL:WHEN (CL:NOT (CL:EQ (PRIMARY-TYPE SELF) (PRIMARY-TYPE OTHER)))
   (CL:RETURN-FROM EQUIVALENT-FORMULAE? CL:NIL))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
     (CL:PROGN (EQUIVALENT-PROPOSITIONS? SELF OTHER MAPPING)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-DESCRIPTION)
     (CL:PROGN (EQUIVALENT-DESCRIPTIONS? SELF OTHER MAPPING)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-SET)
     (CL:PROGN (EQUIVALENT-ENUMERATIONS? SELF OTHER)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-LIST)
     (CL:PROGN (EQUIVALENT-ENUMERATIONS? SELF OTHER)))
    (CL:T CL:NIL))))

;;; (DEFUN (SAME-AND-UNIQUE-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN SAME-AND-UNIQUE-ARGUMENTS? (VARIABLES ARGUMENTS)
  (CL:WHEN (EQUAL? VARIABLES ARGUMENTS)
   (CL:LET* ((COUNT 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT))
    (CL:LET*
     ((V NULL) (VECTOR-000 VARIABLES) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:SETQ V
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:LET*
       ((V2 NULL) (VECTOR-001 VARIABLES) (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ V2
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:WHEN (CL:EQ V V2) (CL:SETQ COUNT (CL:1+ COUNT)))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
    (CL:RETURN-FROM SAME-AND-UNIQUE-ARGUMENTS?
     (CL:= COUNT (LENGTH VARIABLES)))))
  CL:NIL)

;;; (DEFSPECIAL *UNIFY-PROPOSITIONS?* ...)

(CL:DEFVAR *UNIFY-PROPOSITIONS?* CL:NIL)

;;; (DEFUN (UNIFY-PROPOSITIONS? BOOLEAN) ...)

(CL:DEFUN UNIFY-PROPOSITIONS? (SELF OTHER MAPPING)
  (CL:LET* ((*UNIFY-PROPOSITIONS?* CL:T))
   (CL:DECLARE (CL:SPECIAL *UNIFY-PROPOSITIONS?*))
   (EQUIVALENT-PROPOSITIONS? SELF OTHER MAPPING)))

;;; (DEFUN (NAMED-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN NAMED-DESCRIPTION? (SELF)
  "Return TRUE if 'self' is the description of a named class or relation."
  (CL:NOT (CL:EQ (%DESCRIPTION.SURROGATE-VALUE-INVERSE SELF) NULL)))

;;; (DEFMETHOD (FIND-DUPLICATE-NAMED-DESCRIPTION LOGIC-OBJECT) ...)

(CL:DEFMETHOD FIND-DUPLICATE-NAMED-DESCRIPTION ((SELF DESCRIPTION))
  (CL:WHEN (NAMED-DESCRIPTION? SELF)
   (CL:RETURN-FROM FIND-DUPLICATE-NAMED-DESCRIPTION SELF))
  (CL:LET* ((PROPOSITION (%DESCRIPTION.PROPOSITION SELF)))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-AND)
      (CL:LET* ((ONLYGOAL NULL))
       (CL:LET*
        ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
         (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ ARG
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:COND
          ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? ARG)))
          ((CL:NOT (CL:EQ ONLYGOAL NULL))
           (CL:RETURN-FROM FIND-DUPLICATE-NAMED-DESCRIPTION NULL))
          (CL:T (CL:SETQ ONLYGOAL ARG)))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ ONLYGOAL NULL))
         (SAME-AND-UNIQUE-ARGUMENTS? (%DESCRIPTION.IO-VARIABLES SELF)
          (CL:IF
           (CL:EQ (%PROPOSITION.KIND ONLYGOAL) KWD-DESCRIPTIONS-NOT)
           (%PROPOSITION.ARGUMENTS
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS ONLYGOAL)))
             0))
           (%PROPOSITION.ARGUMENTS ONLYGOAL))))
        (CL:RETURN-FROM FIND-DUPLICATE-NAMED-DESCRIPTION
         (EXTRACT-GOAL-DESCRIPTION ONLYGOAL NULL)))))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-NOT)
      (CL:WHEN
       (SAME-AND-UNIQUE-ARGUMENTS? (%DESCRIPTION.IO-VARIABLES SELF)
        (%PROPOSITION.ARGUMENTS
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
          0)))
       (CL:RETURN-FROM FIND-DUPLICATE-NAMED-DESCRIPTION
        (EXTRACT-GOAL-DESCRIPTION PROPOSITION NULL))))
     (CL:T
      (CL:WHEN
       (SAME-AND-UNIQUE-ARGUMENTS? (%DESCRIPTION.IO-VARIABLES SELF)
        (%PROPOSITION.ARGUMENTS PROPOSITION))
       (CL:RETURN-FROM FIND-DUPLICATE-NAMED-DESCRIPTION
        (EXTRACT-GOAL-DESCRIPTION PROPOSITION NULL))))))
   NULL))

;;; (DEFUN (FIND-DUPLICATE-COMPLEX-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN FIND-DUPLICATE-COMPLEX-DESCRIPTION (SELF)
  (CL:LET*
   ((INDEX
     (WRAP-INTEGER
      (PROPOSITION-HASH-INDEX (%DESCRIPTION.PROPOSITION SELF))))
    (BUCKET (LOOKUP *STRUCTURED-OBJECTS-INDEX* INDEX))
    (HOMEMODULE
     (%CONTEXT.BASE-MODULE (%DESCRIPTION.HOME-CONTEXT SELF)))
    (MAPPING (NEW-KEY-VALUE-LIST)))
   (CL:WHEN (CL:EQ BUCKET NULL)
    (INSERT-AT *STRUCTURED-OBJECTS-INDEX* INDEX (LIST SELF))
    (CL:RETURN-FROM FIND-DUPLICATE-COMPLEX-DESCRIPTION NULL))
   (REMOVE-DELETED-MEMBERS BUCKET)
   (CL:WHEN
    (CL:AND
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES NULL)
       NULL))
     (CL:NOT (CL:EQ *QUERYITERATOR* NULL)))
    (CL:SETQ MAPPING (NEW-KEY-VALUE-LIST))
    (CL:LET*
     ((V NULL)
      (VECTOR-000
       (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES NULL))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:SETQ V
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:LET* ((TEMP-000 (ARGUMENT-BOUND-TO V)))
       (INSERT-AT MAPPING V
        (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 V)))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
   (CL:LET* ((D NULL) (ITER-000 (%LIST.THE-CONS-LIST BUCKET)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ D (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (ISA? D SGT-DESCRIPTIONS-LOGIC-DESCRIPTION)
       (EQUIVALENT-DESCRIPTIONS? SELF D MAPPING)
       (SUBCONTEXT? HOMEMODULE
        (%CONTEXT.BASE-MODULE
         (%CONTEXT-SENSITIVE-OBJECT.HOME-CONTEXT D))))
      (CL:RETURN-FROM FIND-DUPLICATE-COMPLEX-DESCRIPTION D))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (PUSH BUCKET SELF) NULL))

;;; (DEFUN (FIND-DUPLICATE-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN FIND-DUPLICATE-DESCRIPTION (SELF)
  (CL:IF (NAMED-DESCRIPTION? SELF) NULL
   (CL:LET* ((TEMP-000 (FIND-DUPLICATE-NAMED-DESCRIPTION SELF)))
    (CL:LET*
     ((VALUE-000
       (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000
        (FIND-DUPLICATE-COMPLEX-DESCRIPTION SELF))))
     VALUE-000))))

;;; (DEFUN (CONTAINS-NESTED-ARGUMENT? BOOLEAN) ...)

(CL:DEFUN CONTAINS-NESTED-ARGUMENT? (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-ISA)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EQUIVALENT)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-IMPLIES))
     (CL:LET*
      ((TERM NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ TERM
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:COND
        ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM)
          SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
         (CL:PROGN
          (CL:WHEN
           (CL:NOT
            (CL:EQ (%PATTERN-VARIABLE.DEFINING-PROPOSITION TERM) NULL))
           (CL:RETURN-FROM CONTAINS-NESTED-ARGUMENT? CL:T))))
        (CL:T))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
    (CL:T)))
  CL:NIL)

;;; (DEFUN (EXPAND-IF-PROPOSITION PROPOSITION) ...)

(CL:DEFUN EXPAND-IF-PROPOSITION (IFPROPOSITION)
  (CL:LET*
   ((ARGUMENTS (%PROPOSITION.ARGUMENTS IFPROPOSITION))
    (TESTPROP
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
      0))
    (NEGATEDTESTPROP
     (CREATE-PROPOSITION SYM-DESCRIPTIONS-STELLA-NOT 1))
    (TRUEVALUE
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
      1))
    (FALSEVALUE
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
      2))
    (VALUEVARIABLE
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS IFPROPOSITION)))
      (CL:THE CL:FIXNUM
       (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS IFPROPOSITION))))))
    (TRUEEQUIVALENCE
     (CREATE-EQUIVALENCE-PROPOSITION VALUEVARIABLE TRUEVALUE))
    (FALSEEQUIVALENCE
     (CL:IF (CL:NOT (CL:EQ FALSEVALUE NULL))
      (CREATE-EQUIVALENCE-PROPOSITION VALUEVARIABLE FALSEVALUE) NULL)))
   (CL:SETF (%PATTERN-VARIABLE.DEFINING-PROPOSITION VALUEVARIABLE)
    NULL)
   (CL:IF (CL:NOT (CL:EQ FALSEVALUE NULL))
    (CL:PROGN
     (CL:LET
      ((SELF
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS NEGATEDTESTPROP)))
       (VALUE
        (CL:IF (ISA? TESTPROP SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
         TESTPROP (SHALLOW-COPY-PROPOSITION TESTPROP)))
       (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (DISJOIN-PROPOSITIONS
      (CONS-LIST (CONJOIN-TWO-PROPOSITIONS TESTPROP TRUEEQUIVALENCE)
       (CONJOIN-TWO-PROPOSITIONS NEGATEDTESTPROP FALSEEQUIVALENCE))))
    (CONJOIN-TWO-PROPOSITIONS TESTPROP TRUEEQUIVALENCE))))

;;; (DEFUN HELP-COLLECT-FLATTENED-ARGUMENTS ...)

(CL:DEFUN HELP-COLLECT-FLATTENED-ARGUMENTS (SELF FLATTENEDARGUMENTS EXISTSVARIABLES)
  (CL:LET*
   ((TERM NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
    (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ TERM
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
      INDEX-000))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM)
       SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
      (CL:PROGN
       (CL:LET*
        ((FUNCTIONARG (%PATTERN-VARIABLE.DEFINING-PROPOSITION TERM)))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ FUNCTIONARG NULL))
          (CL:NOT (MEMBER? EXISTSVARIABLES TERM)))
         (PUSH EXISTSVARIABLES TERM)
         (HELP-COLLECT-FLATTENED-ARGUMENTS FUNCTIONARG
          FLATTENEDARGUMENTS EXISTSVARIABLES)
         (CL:IF
          (CL:EQ (%PROPOSITION.OPERATOR FUNCTIONARG)
           SGT-DESCRIPTIONS-STELLA-PROPOSITION.IF)
          (PUSH FLATTENEDARGUMENTS (EXPAND-IF-PROPOSITION FUNCTIONARG))
          (PUSH FLATTENEDARGUMENTS FUNCTIONARG))))))
     (CL:T))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))

;;; (DEFUN (YIELD-FLATTENED-ARGUMENTS (LIST OF PROPOSITION)) ...)

(CL:DEFUN YIELD-FLATTENED-ARGUMENTS (PROPOSITION EXISTSVARIABLES)
  (CL:LET* ((FLATTENEDARGUMENTS (NEW-LIST)))
   (HELP-COLLECT-FLATTENED-ARGUMENTS PROPOSITION FLATTENEDARGUMENTS
    EXISTSVARIABLES)
   (PUSH FLATTENEDARGUMENTS PROPOSITION) (REVERSE EXISTSVARIABLES)
   (REVERSE FLATTENEDARGUMENTS)))

;;; (DEFUN (FLATTEN-NESTED-FUNCTION-ARGUMENTS PROPOSITION) ...)

(CL:DEFUN FLATTEN-NESTED-FUNCTION-ARGUMENTS (PROPOSITION)
  (CL:LET*
   ((EXISTSPROPOSITION
     (CREATE-PROPOSITION SYM-DESCRIPTIONS-STELLA-EXISTS 1))
    (EXISTSVARIABLES (NEW-LIST))
    (FLATTENEDPROPOSITIONS
     (YIELD-FLATTENED-ARGUMENTS PROPOSITION EXISTSVARIABLES))
    (ANDPROPOSITION
     (CREATE-PROPOSITION SYM-DESCRIPTIONS-STELLA-AND
      (LENGTH FLATTENEDPROPOSITIONS))))
   (CL:LET*
    ((PROP NULL) (ITER-000 (%LIST.THE-CONS-LIST FLATTENEDPROPOSITIONS))
     (I NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PROP (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:LET
      ((SELF
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS ANDPROPOSITION)))
       (VALUE PROP) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:LET*
    ((VBL NULL) (ITER-002 (%LIST.THE-CONS-LIST EXISTSVARIABLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ VBL (%%VALUE ITER-002))
     (CL:SETF (%PATTERN-VARIABLE.DEFINING-PROPOSITION VBL) NULL)
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (SET-DYNAMIC-SLOT-VALUE
    (%PROPOSITION.DYNAMIC-SLOTS EXISTSPROPOSITION)
    SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES
    (COPY-CONS-LIST-TO-VARIABLES-VECTOR
     (%LIST.THE-CONS-LIST EXISTSVARIABLES))
    NULL)
   (FREE EXISTSVARIABLES)
   (CL:LET
    ((SELF
      (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS EXISTSPROPOSITION)))
     (VALUE ANDPROPOSITION) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   EXISTSPROPOSITION))

;;; (DEFUN COLLAPSE-VALUE-OF-CHAINS-FOR-IO-VARIABLES ...)

(CL:DEFUN COLLAPSE-VALUE-OF-CHAINS-FOR-IO-VARIABLES (IOVARIABLES)
  (CL:LET* ((TIGHTESTVARIABLE NULL))
   (CL:LET*
    ((VBL NULL) (VECTOR-000 IOVARIABLES) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ VBL
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:WHEN (CL:NOT (CL:EQ VBL (INNERMOST-VARIABLE-OF VBL)))
      (CL:SETQ TIGHTESTVARIABLE (INNERMOST-VARIABLE-OF VBL))
      (CL:LET
       ((SELF (%VECTOR.THE-ARRAY IOVARIABLES)) (VALUE TIGHTESTVARIABLE)
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETF (%PATTERN-VARIABLE.SKOLEM-NAME TIGHTESTVARIABLE)
       (%PATTERN-VARIABLE.SKOLEM-NAME VBL))
      (CL:LET*
       ((OBJECT-000 TIGHTESTVARIABLE) (VALUE-000 NIL)
        (OLD-VALUE-000
         (%LOGIC-OBJECT.VARIABLE-VALUE-INVERSE OBJECT-000))
        (NEW-VALUE-000
         (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
          (%PATTERN-VARIABLE.HOME-CONTEXT OBJECT-000) CL:NIL)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
           SGT-DESCRIPTIONS-STELLA-CS-VALUE)))
        (CL:SETF (%LOGIC-OBJECT.VARIABLE-VALUE-INVERSE OBJECT-000)
         NEW-VALUE-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))))

;;; (DEFUN (REMOVE-NULLS-IN-VARIABLES-VECTOR VARIABLES-VECTOR) ...)

(CL:DEFUN REMOVE-NULLS-IN-VARIABLES-VECTOR (IOVARIABLES)
  (CL:WHEN (CL:NOT (MEMBER? IOVARIABLES NULL))
   (CL:RETURN-FROM REMOVE-NULLS-IN-VARIABLES-VECTOR IOVARIABLES))
  (CL:LET* ((NEWVBLLIST NIL) (RESULT NULL))
   (CL:LET*
    ((VBL NULL) (VECTOR-000 IOVARIABLES) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ VBL
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:WHEN (CL:NOT (CL:EQ VBL NULL))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS VBL NIL))
        (CL:IF (CL:EQ NEWVBLLIST NIL) (CL:SETQ NEWVBLLIST COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST NEWVBLLIST COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VBL NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:SETQ RESULT (COPY-CONS-LIST-TO-VARIABLES-VECTOR NEWVBLLIST))
   RESULT))

;;; (DEFUN TIGHTEN-ARGUMENT-BINDINGS ...)

(CL:DEFUN TIGHTEN-ARGUMENT-BINDINGS (PROPOSITION IOVARIABLES)
  (CL:LET* ()
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER)
     (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
        (CL:PROGN
         (CL:LET*
          ((VALUE
            (CL:IF
             (CL:AND (CL:NOT (CL:EQ IOVARIABLES NULL))
              (MEMBER? IOVARIABLES ARG))
             (INNERMOST-VARIABLE-OF ARG) (INNERMOST-OF ARG))))
          (CL:WHEN (CL:NOT (CL:EQ VALUE ARG))
           (CL:LET
            ((SELF
              (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
             (VALUE VALUE) (POSITION I))
            (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
             (CL:TYPE CL:FIXNUM POSITION))
            (CL:SETF (CL:AREF SELF POSITION) VALUE))))))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
        (CL:PROGN (TIGHTEN-ARGUMENT-BINDINGS ARG IOVARIABLES)))
       (CL:T)))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:WHEN
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
       SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL)
      NULL))
    (CL:LET*
     ((QUANTIFIEDVARIABLES
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
        SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL)))
     (CL:LET*
      ((VBL NULL) (VECTOR-001 QUANTIFIEDVARIABLES) (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)) (I NULL-INTEGER) (ITER-001 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 I ITER-001))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:SETQ VBL
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:SETQ I ITER-001)
       (CL:WHEN (CL:NOT (CL:EQ VBL (INNERMOST-VARIABLE-OF VBL)))
        (CL:LET
         ((SELF (%VECTOR.THE-ARRAY QUANTIFIEDVARIABLES)) (VALUE NULL)
          (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE)))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
       (CL:SETQ ITER-001 (CL:1+ ITER-001))))
     (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
      SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES
      (REMOVE-NULLS-IN-VARIABLES-VECTOR QUANTIFIEDVARIABLES) NULL)
     (NORMALIZE-PROPOSITION PROPOSITION)))))

;;; (DEFUN EQUATE-TOP-LEVEL-EQUIVALENCES ...)

(CL:DEFUN EQUATE-TOP-LEVEL-EQUIVALENCES (PROPOSITION)
  (CL:LET* ((ARGUMENTS (%PROPOSITION.ARGUMENTS PROPOSITION)))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EQUIVALENT)
      (EQUATE-VALUES
       (INNERMOST-OF
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) 0))
       (INNERMOST-OF
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) 1))))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-AND)
      (CL:LET*
       ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (EQUATE-TOP-LEVEL-EQUIVALENCES ARG)
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EXISTS)
      (EQUATE-TOP-LEVEL-EQUIVALENCES
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
        0)))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FUNCTION)
      (EVALUATE-FUNCTION-PROPOSITION PROPOSITION))
     (CL:T)))))

;;; (DEFUN COLLECT-ALL-VARIABLES ...)

(CL:DEFUN COLLECT-ALL-VARIABLES (SELF COLLECTION BEENTHERE)
  (INSERT BEENTHERE SELF)
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ ARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
      INDEX-000))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000
        SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
       (CL:PROGN (INSERT-NEW COLLECTION ARG)))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
       (CL:PROGN
        (CL:WHEN (CL:NOT (MEMBER? BEENTHERE ARG))
         (COLLECT-ALL-VARIABLES ARG COLLECTION BEENTHERE))))
      (CL:T)))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))

;;; (DEFUN COMPUTE-INTERNAL-VARIABLES ...)

(CL:DEFUN COMPUTE-INTERNAL-VARIABLES (SELF)
  (CL:LET* ((COLLECTION (NEW-LIST)) (BEENTHERE (NEW-LIST)))
   (COLLECT-ALL-VARIABLES (%DESCRIPTION.PROPOSITION SELF) COLLECTION
    BEENTHERE)
   (CL:LET*
    ((VBL NULL) (VECTOR-000 (%DESCRIPTION.IO-VARIABLES SELF))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ VBL
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (REMOVE COLLECTION VBL) (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:WHEN
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
       SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES NULL)
      NULL))
    (CL:LET*
     ((VBL NULL)
      (VECTOR-001
       (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES NULL))
      (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
     (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
      (CL:SETQ VBL
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
        INDEX-001))
      (REMOVE COLLECTION VBL) (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
   (CL:SETF (%DESCRIPTION.INTERNAL-VARIABLES SELF)
    (COPY-CONS-LIST-TO-VARIABLES-VECTOR
     (%LIST.THE-CONS-LIST COLLECTION)))
   (FREE COLLECTION) (FREE BEENTHERE)))

;;; (DEFSPECIAL *EXTERNALVARIABLES* ...)

(CL:DEFVAR *EXTERNALVARIABLES*)

;;; (DEFUN COLLECT-EXTERNAL-VARIABLES ...)

(CL:DEFUN COLLECT-EXTERNAL-VARIABLES (PROPOSITION)
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
    (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ ARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
      INDEX-000))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000
        SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
       (CL:PROGN
        (CL:WHEN
         (CL:AND (MEMBER? *LOGICVARIABLETABLE* ARG)
          (CL:NOT (MEMBER? *EXTERNALVARIABLES* ARG)))
         (CL:SETQ *EXTERNALVARIABLES*
          (CONS ARG *EXTERNALVARIABLES*)))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
       (CL:PROGN (COLLECT-EXTERNAL-VARIABLES ARG)))
      (CL:T)))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))

;;; (DEFUN (FINISH-BUILDING-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN FINISH-BUILDING-DESCRIPTION (DESCRIPTION CHECKFORDUPLICATE?)
  (CL:LET* ((PROPOSITION (%DESCRIPTION.PROPOSITION DESCRIPTION)))
   (NORMALIZE-PROPOSITION PROPOSITION)
   (CL:WHEN
    (CL:EQ (%PROPOSITION.KIND PROPOSITION) KWD-DESCRIPTIONS-EXISTS)
    (CL:SETQ PROPOSITION
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (CL:SETF (%DESCRIPTION.PROPOSITION DESCRIPTION) PROPOSITION))
   (RESOLVE-UNRESOLVED-SLOT-REFERENCES DESCRIPTION)
   (UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS PROPOSITION)
   (NORMALIZE-TOP-LEVEL-PROPOSITION PROPOSITION
    (%DESCRIPTION.IO-VARIABLES DESCRIPTION))
   (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS PROPOSITION CL:T)
   (COMPUTE-INTERNAL-VARIABLES DESCRIPTION)
   (CL:WHEN CHECKFORDUPLICATE?
    (CL:LET*
     ((DUPLICATEDESCRIPTION (FIND-DUPLICATE-DESCRIPTION DESCRIPTION)))
     (CL:WHEN (CL:NOT (CL:EQ DUPLICATEDESCRIPTION NULL))
      (CL:SETQ DESCRIPTION DUPLICATEDESCRIPTION))))
   DESCRIPTION))

;;; (DEFUN (EVALUATE-DESCRIPTION-TERM DESCRIPTION) ...)

(CL:DEFUN EVALUATE-DESCRIPTION-TERM (TERM CHECKFORDUPLICATE?)
  (CL:LET* ((DESCRIPTION (CREATE-DESCRIPTION NULL-INTEGER CL:NIL)))
   (CL:COND
    ((CL:EQ (%%VALUE TERM) SYM-DESCRIPTIONS-LOGIC-THE-ONLY)
     (SET-DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
      SYM-DESCRIPTIONS-LOGIC-IOTA?
      (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
    (CL:T))
   (CL:LET*
    ((*DESCRIPTIONUNDERCONSTRUCTION* DESCRIPTION)
     (*EVALUATIONMODE* KWD-DESCRIPTIONS-DESCRIPTION)
     (*VARIABLEIDCOUNTER* *VARIABLEIDCOUNTER*))
    (CL:DECLARE
     (CL:SPECIAL *DESCRIPTIONUNDERCONSTRUCTION* *EVALUATIONMODE*
      *VARIABLEIDCOUNTER*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *VARIABLEIDCOUNTER*))
    (CL:LET* ((IOVARS NULL) (PROPOSITION NULL) (UNUSED NULL))
     (CL:MULTIPLE-VALUE-SETQ (IOVARS PROPOSITION UNUSED)
      (BUILD-QUANTIFIED-PROPOSITION TERM CL:T))
     (CL:SETQ UNUSED UNUSED)
     (CL:SETF (%DESCRIPTION.IO-VARIABLES DESCRIPTION)
      (COPY-CONS-LIST-TO-VARIABLES-VECTOR IOVARS))
     (CL:WHEN (CL:NOT (CL:EQ *LOGICVARIABLETABLE* NIL))
      (CL:LET* ((*EXTERNALVARIABLES* NIL))
       (CL:DECLARE (CL:SPECIAL *EXTERNALVARIABLES*))
       (COLLECT-EXTERNAL-VARIABLES PROPOSITION)
       (CL:WHEN (CL:NOT (CL:EQ *EXTERNALVARIABLES* NIL))
        (SET-DYNAMIC-SLOT-VALUE
         (%DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
         SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES
         (COPY-CONS-LIST-TO-VARIABLES-VECTOR *EXTERNALVARIABLES*)
         NULL))))
     (CL:SETF (%DESCRIPTION.PROPOSITION DESCRIPTION)
      (CL:IF (CL:NOT (CL:EQ PROPOSITION NULL)) PROPOSITION
       TRUE-PROPOSITION)))
    (FINISH-BUILDING-DESCRIPTION DESCRIPTION CHECKFORDUPLICATE?))))

;;; (DEFUN (REMOVE-VARIABLE-TYPE-PROPOSITIONS (CONS OF PROPOSITION)) ...)

(CL:DEFUN REMOVE-VARIABLE-TYPE-PROPOSITIONS (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-AND)
     (CL:LET* ((TYPEDECLARATIONS NIL) (GOALPROPOSITION NULL))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:COND
         ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? ARG))
          (CL:SETQ TYPEDECLARATIONS (CONS ARG TYPEDECLARATIONS)))
         ((CL:NOT (CL:EQ GOALPROPOSITION NULL)))
         (CL:T (CL:SETQ GOALPROPOSITION ARG)))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (OVERLAY-PROPOSITION PROPOSITION GOALPROPOSITION)
      (CL:RETURN-FROM REMOVE-VARIABLE-TYPE-PROPOSITIONS
       TYPEDECLARATIONS)))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-ISA)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-NOT))
     (CL:RETURN-FROM REMOVE-VARIABLE-TYPE-PROPOSITIONS NIL))
    (CL:T)))
  NIL)

;;; (DEFSPECIAL *RECURSIVEGETCOMPLEMENTARGUMENT* ...)

(CL:DEFVAR *RECURSIVEGETCOMPLEMENTARGUMENT* NULL
  "Used to prevent infinite looping.")

;;; (DEFUN (GET-COMPLEMENT-OF-GOAL-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN GET-COMPLEMENT-OF-GOAL-DESCRIPTION (SELF)
  (CL:LET*
   ((COMPLEMENT
     (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
      SYM-DESCRIPTIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL)))
   (CL:WHEN (CL:NOT (CL:EQ COMPLEMENT NULL))
    (CL:RETURN-FROM GET-COMPLEMENT-OF-GOAL-DESCRIPTION COMPLEMENT))
   (CL:WHEN (CL:EQ SELF *RECURSIVEGETCOMPLEMENTARGUMENT*)
    (CL:RETURN-FROM GET-COMPLEMENT-OF-GOAL-DESCRIPTION NULL))
   (CL:LET* ((*MODULE* (HOME-MODULE SELF)) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:LET* ((DECLARATIONS NIL) (VARIABLES NIL) (CLAUSES NIL))
     (CL:LET*
      ((V NULL) (VECTOR-000 (%NAMED-DESCRIPTION.IO-VARIABLES SELF))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (TYPE NULL)
       (ITER-000
        (%LIST.THE-CONS-LIST
         (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES SELF)))
       (COLLECT-000 NULL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE
       (CL:AND (CL:< INDEX-000 LENGTH-000)
        (CL:NOT (CL:EQ ITER-000 NIL)))
       DO
       (CL:SETQ V
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ TYPE (%%VALUE ITER-000))
       (CL:IF (CL:OR (CL:EQ TYPE NULL) (CLASS-DESCRIPTION? SELF))
        (CL:SETQ DECLARATIONS
         (CONS (%PATTERN-VARIABLE.SKOLEM-NAME V) DECLARATIONS))
        (CL:SETQ DECLARATIONS
         (CONS
          (CONS (%PATTERN-VARIABLE.SKOLEM-NAME V)
           (CONS (SURROGATE-TO-SYMBOL TYPE) NIL))
          DECLARATIONS)))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-000
          (CONS (%PATTERN-VARIABLE.SKOLEM-NAME V) NIL))
         (CL:IF (CL:EQ VARIABLES NIL) (CL:SETQ VARIABLES COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST VARIABLES COLLECT-000)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-000)
          (CONS (%PATTERN-VARIABLE.SKOLEM-NAME V) NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:SETQ DECLARATIONS (REVERSE DECLARATIONS))
     (CL:SETQ CLAUSES
      (CONS
       (LIST* SYM-DESCRIPTIONS-STELLA-NOT
        (CONS (DESCRIPTION-NAME SELF) (CONCATENATE VARIABLES NIL)) NIL)
       NIL))
     (CL:WHEN (CLASS-DESCRIPTION? SELF)
      (CL:LET*
       ((P NULL) (ITER-001 (ALL-DIRECT-SUPERRELATIONS SELF CL:T)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ P (%%VALUE ITER-001))
        (CL:SETQ CLAUSES
         (CONS
          (CONS (DESCRIPTION-NAME P) (CONS (%%VALUE VARIABLES) NIL))
          CLAUSES))
        (CL:SETQ ITER-001 (%%REST ITER-001)))))
     (CL:LET* ((*RECURSIVEGETCOMPLEMENTARGUMENT* SELF))
      (CL:DECLARE (CL:SPECIAL *RECURSIVEGETCOMPLEMENTARGUMENT*))
      (CL:SETQ COMPLEMENT
       (CONCEIVE-TERM
        (LIST* SYM-DESCRIPTIONS-LOGIC-KAPPA DECLARATIONS
         (CONS
          (CONS SYM-DESCRIPTIONS-STELLA-AND (CONCATENATE CLAUSES NIL))
          NIL)))))
     (CL:WHEN (CL:EQ COMPLEMENT NULL)
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
        "WARNING: Couldn't conceive goal complement for" EOL
        (LIST* SYM-DESCRIPTIONS-LOGIC-KAPPA DECLARATIONS
         (CONS
          (CONS SYM-DESCRIPTIONS-STELLA-AND (CONCATENATE CLAUSES NIL))
          NIL))
        EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
        KWD-DESCRIPTIONS-WARNING))
      (CL:RETURN-FROM GET-COMPLEMENT-OF-GOAL-DESCRIPTION NULL))
     (SET-DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
      SYM-DESCRIPTIONS-LOGIC-COMPLEMENT-DESCRIPTION COMPLEMENT NULL)
     (SET-DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS COMPLEMENT)
      SYM-DESCRIPTIONS-LOGIC-COMPLEMENT-DESCRIPTION SELF NULL)
     (DERIVE-DEFERRED-CONTRAPOSITIVE-SATELLITE-RULES SELF) COMPLEMENT))))

;;; (DEFUN COLLECT-FREE-VARIABLES ...)

(CL:DEFUN COLLECT-FREE-VARIABLES (SELF COLLECTION QUANTIFIEDVARS BEENTHERE)
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-001
      SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN
      (CL:WHEN
       (CL:AND (CL:NOT (MEMBER? QUANTIFIEDVARS SELF))
        (CL:NOT (MEMBER? COLLECTION SELF)))
       (INSERT-LAST COLLECTION SELF))))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:WHEN (CL:NOT (MEMBER? BEENTHERE SELF))
       (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
        (CL:COND
         ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FORALL)
           (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EXISTS))
          (CL:LET*
           ((V NULL)
            (VECTOR-000
             (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
              SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL))
            (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
           (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
            (CL:SETQ V
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
              INDEX-000))
            (INSERT QUANTIFIEDVARS V)
            (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
         (CL:T)))
       (INSERT BEENTHERE SELF)
       (CL:LET*
        ((ARG NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS SELF))
         (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
        (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
         (CL:SETQ ARG
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
           INDEX-001))
         (COLLECT-FREE-VARIABLES ARG COLLECTION QUANTIFIEDVARS
          BEENTHERE)
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-DESCRIPTIONS-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:LET*
       ((V NULL) (VECTOR-002 (%DESCRIPTION.IO-VARIABLES SELF))
        (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
       (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
        (CL:SETQ V
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
          INDEX-002))
        (INSERT QUANTIFIEDVARS V)
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
      (CL:LET*
       ((V NULL) (ITER-000 (TOP-LEVEL-EXISTENTIAL-VARIABLES SELF)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ V (%%VALUE ITER-000)) (INSERT QUANTIFIEDVARS V)
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (COLLECT-FREE-VARIABLES (%DESCRIPTION.PROPOSITION SELF)
       COLLECTION QUANTIFIEDVARS BEENTHERE)))
    (CL:T))))

;;; (DEFUN (TOP-LEVEL-EXISTENTIAL-VARIABLES (CONS OF PATTERN-VARIABLE)) ...)

(CL:DEFUN TOP-LEVEL-EXISTENTIAL-VARIABLES (SELF)
  (CL:LET*
   ((QUANTIFIEDVARIABLES (NEW-LIST)) (BEENTHERE (NEW-LIST))
    (COLLECTION (NEW-LIST)))
   (CL:LET*
    ((V NULL) (VECTOR-000 (%DESCRIPTION.IO-VARIABLES SELF))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ V
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (INSERT QUANTIFIEDVARIABLES V)
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:WHEN
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
       SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES NULL)
      NULL))
    (CL:LET*
     ((V NULL)
      (VECTOR-001
       (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
        SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES NULL))
      (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
     (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
      (CL:SETQ V
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
        INDEX-001))
      (INSERT QUANTIFIEDVARIABLES V)
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
   (CL:WHEN (CL:EQ (%DESCRIPTION.PROPOSITION SELF) NULL)
    (CL:RETURN-FROM TOP-LEVEL-EXISTENTIAL-VARIABLES
     (%LIST.THE-CONS-LIST QUANTIFIEDVARIABLES)))
   (COLLECT-FREE-VARIABLES (%DESCRIPTION.PROPOSITION SELF) COLLECTION
    QUANTIFIEDVARIABLES BEENTHERE)
   (FREE QUANTIFIEDVARIABLES) (FREE BEENTHERE)
   (%LIST.THE-CONS-LIST COLLECTION)))

;;; (DEFUN (TOP-LEVEL-EXISTENTIAL-VARIABLE? BOOLEAN) ...)

(CL:DEFUN TOP-LEVEL-EXISTENTIAL-VARIABLE? (VARIABLE DESCRIPTION)
  (CL:AND
   (CL:NOT (MEMBER? (%DESCRIPTION.IO-VARIABLES DESCRIPTION) VARIABLE))
   (MEMBER? (%DESCRIPTION.INTERNAL-VARIABLES DESCRIPTION) VARIABLE)
   (FREE-VARIABLE? VARIABLE (%DESCRIPTION.PROPOSITION DESCRIPTION))))

;;; (DEFUN (FREE-VARIABLE? BOOLEAN) ...)

(CL:DEFUN FREE-VARIABLE? (VARIABLE PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FORALL)
      (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EXISTS))
     (CL:WHEN
      (MEMBER?
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
        SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL)
       VARIABLE)
      (CL:RETURN-FROM FREE-VARIABLE? CL:NIL)))
    (CL:T)))
  (CL:LET* ((ALWAYS?-000 CL:T))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:WHEN (ISA? ARG SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
      (CL:WHEN (CL:NOT (FREE-VARIABLE? VARIABLE ARG))
       (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN)))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET* ((VALUE-000 ALWAYS?-000)) VALUE-000)))

;;; (DEFUN (MOST-SPECIFIC-TYPES (LIST OF TYPE)) ...)

(CL:DEFUN MOST-SPECIFIC-TYPES (TYPES)
  (CL:WHEN (CL:EQ (REST TYPES) NULL)
   (CL:RETURN-FROM MOST-SPECIFIC-TYPES TYPES))
  (CL:LET*
   ((CURSOR1 (%LIST.THE-CONS-LIST TYPES)) (CURSOR2 NULL) (VALUE1 NULL)
    (VALUE2 NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR1 NIL)) DO
    (CL:SETQ VALUE1 (%%VALUE CURSOR1))
    (CL:WHEN (CL:NOT (CL:EQ (%%VALUE CURSOR1) NULL))
     (CL:SETQ CURSOR2 (%%REST CURSOR1))
     (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR2 NIL)) DO
      (CL:SETQ VALUE2 (%%VALUE CURSOR2))
      (CL:WHEN (CL:NOT (CL:EQ VALUE2 NULL))
       (CL:IF (LOGICAL-SUBTYPE-OF? VALUE1 VALUE2)
        (CL:SETF (%%VALUE CURSOR2) NULL)
        (CL:WHEN (LOGICAL-SUBTYPE-OF? VALUE2 VALUE1)
         (CL:SETF (%%VALUE CURSOR1) NULL) (CL:RETURN))))
      (CL:SETQ CURSOR2 (%%REST CURSOR2))))
    (CL:SETQ CURSOR1 (%%REST CURSOR1))))
  (REMOVE TYPES NULL)
  TYPES)

;;; (DEFSPECIAL *ADDEDNEWTYPE?* ...)

(CL:DEFVAR *ADDEDNEWTYPE?* CL:NIL
  "Used by 'infer-variable-types'.")

;;; (DEFUN ADD-VARIABLE-TYPE ...)

(CL:DEFUN ADD-VARIABLE-TYPE (VARIABLE NEWTYPE TABLE VISIBLEVARIABLES)
  (CL:WHEN (CL:NOT (MEMBER? VISIBLEVARIABLES VARIABLE))
   (CL:RETURN-FROM ADD-VARIABLE-TYPE))
  (CL:LET* ((TYPES (LOOKUP TABLE VARIABLE)))
   (CL:IF (CL:EQ TYPES NULL) (INSERT-AT TABLE VARIABLE (LIST NEWTYPE))
    (CL:PROGN
     (CL:LET* ((T NULL) (ITER-000 (%LIST.THE-CONS-LIST TYPES)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ T (%%VALUE ITER-000))
       (CL:WHEN (LOGICAL-SUBTYPE-OF? T NEWTYPE)
        (CL:RETURN-FROM ADD-VARIABLE-TYPE))
       (CL:WHEN (LOGICAL-SUBTYPE-OF? NEWTYPE T) (REMOVE TYPES T)
        (ADD-VARIABLE-TYPE VARIABLE NEWTYPE TABLE VISIBLEVARIABLES)
        (CL:RETURN-FROM ADD-VARIABLE-TYPE))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (INSERT TYPES NEWTYPE)))
   (CL:SETQ *ADDEDNEWTYPE?* CL:T)))

;;; (DEFUN (INFER-PREDICATE-FROM-OPERATOR-AND-TYPES OBJECT) ...)

(CL:DEFUN INFER-PREDICATE-FROM-OPERATOR-AND-TYPES (OPERATOR TYPES)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OPERATOR)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF
       (ISA? (%SURROGATE.SURROGATE-VALUE OPERATOR)
        SGT-DESCRIPTIONS-STELLA-SLOT)
       (CL:LET* ((SLOT (%SURROGATE.SURROGATE-VALUE OPERATOR)))
        (CL:SETQ SLOT
         (INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
          (%SLOT.SLOT-NAME SLOT) TYPES))
        (CL:IF (CL:NOT (CL:EQ SLOT NULL))
         (CL:RETURN-FROM INFER-PREDICATE-FROM-OPERATOR-AND-TYPES SLOT)
         (CL:RETURN-FROM INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
          (%SURROGATE.SURROGATE-VALUE OPERATOR))))
       (CL:RETURN-FROM INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
        (%SURROGATE.SURROGATE-VALUE OPERATOR)))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((SLOTREF NULL))
       (CL:LET* ((TYPE NULL) (ITER-000 (%LIST.THE-CONS-LIST TYPES)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ TYPE (%%VALUE ITER-000))
         (CL:WHEN
          (ISA? (%SURROGATE.SURROGATE-VALUE TYPE)
           SGT-DESCRIPTIONS-STELLA-CLASS)
          (CL:SETQ SLOTREF (LOOKUP-SLOTREF TYPE OPERATOR))
          (CL:WHEN (CL:NOT (CL:EQ SLOTREF NULL))
           (CL:RETURN-FROM INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
            (%SURROGATE.SURROGATE-VALUE SLOTREF)))
          (CL:WHEN (LOGICAL-SUBTYPE-OF-LITERAL? TYPE)
           (CL:SETQ TYPE (TYPE-TO-WRAPPED-TYPE TYPE))
           (CL:SETQ SLOTREF (LOOKUP-SLOTREF TYPE OPERATOR))
           (CL:WHEN (CL:NOT (CL:EQ SLOTREF NULL))
            (CL:RETURN-FROM INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
             (%SURROGATE.SURROGATE-VALUE SLOTREF)))))
         (CL:SETQ ITER-000 (%%REST ITER-000)))))))
    (CL:T)))
  NULL)

;;; (DEFUN INFER-TYPES-FROM-ONE-PROPOSITION ...)

(CL:DEFUN INFER-TYPES-FROM-ONE-PROPOSITION (PROPOSITION TABLE VISIBLEVARS)
  (CL:WHEN (CL:= (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION)) 0)
   (CL:RETURN-FROM INFER-TYPES-FROM-ONE-PROPOSITION))
  (CL:LET*
   ((ARGUMENTS (%PROPOSITION.ARGUMENTS PROPOSITION))
    (FIRSTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
      0)))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-ISA)
      (CL:WHEN (ISA? FIRSTARG SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
       (ADD-VARIABLE-TYPE FIRSTARG (%PROPOSITION.OPERATOR PROPOSITION)
        TABLE VISIBLEVARS)))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FUNCTION))
      (CL:LET* ((PREDICATE NULL))
       (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE FIRSTARG)))
        (CL:COND
         ((SUBTYPE-OF? TEST-VALUE-001
           SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
          (CL:PROGN
           (CL:LET* ((TYPES (LOOKUP TABLE FIRSTARG)))
            (CL:WHEN (CL:NOT (CL:EQ TYPES NULL))
             (CL:SETQ PREDICATE
              (INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
               (%PROPOSITION.OPERATOR PROPOSITION) TYPES))))))
         ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
          (CL:PROGN
           (CL:LET*
            ((VALUE (%SURROGATE.SURROGATE-VALUE FIRSTARG))
             (TYPES (NEW-LIST)))
            (CL:WHEN
             (CL:AND (CL:NOT (CL:EQ VALUE NULL))
              (ISA? VALUE SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT))
             (CL:LET*
              ((D NULL) (ITER-000 (ALL-ASSERTED-TYPES VALUE))
               (COLLECT-000 NULL))
              (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
               (CL:SETQ D (%%VALUE ITER-000))
               (CL:IF (CL:EQ COLLECT-000 NULL)
                (CL:PROGN
                 (CL:SETQ COLLECT-000
                  (CONS (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE D)
                   NIL))
                 (CL:IF (CL:EQ (%LIST.THE-CONS-LIST TYPES) NIL)
                  (CL:SETF (%LIST.THE-CONS-LIST TYPES) COLLECT-000)
                  (ADD-CONS-TO-END-OF-CONS-LIST
                   (%LIST.THE-CONS-LIST TYPES) COLLECT-000)))
                (CL:PROGN
                 (CL:SETF (%%REST COLLECT-000)
                  (CONS (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE D)
                   NIL))
                 (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
               (CL:SETQ ITER-000 (%%REST ITER-000))))
             (CL:SETQ TYPES (MOST-SPECIFIC-TYPES TYPES))
             (CL:SETQ PREDICATE
              (INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
               (%PROPOSITION.OPERATOR PROPOSITION) TYPES))))))
         (CL:T
          (CL:LET* ((OPERATOR (%PROPOSITION.OPERATOR PROPOSITION)))
           (CL:WHEN
            (CL:AND (ISA? OPERATOR SGT-DESCRIPTIONS-STELLA-SURROGATE)
             (ISA? (%SURROGATE.SURROGATE-VALUE OPERATOR)
              SGT-DESCRIPTIONS-STELLA-SLOT))
            (CL:SETQ PREDICATE
             (%SURROGATE.SURROGATE-VALUE OPERATOR)))))))
       (CL:WHEN (CL:NOT (CL:EQ PREDICATE NULL))
        (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE PREDICATE)))
         (CL:COND
          ((SUBTYPE-OF? TEST-VALUE-002
            SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION)
           (CL:PROGN
            (CL:COND
             ((CL:NOT
               (CL:EQ (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES PREDICATE)
                NULL))
              (CL:LET*
               ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
                (LENGTH-000 (LENGTH VECTOR-000)) (TYPE NULL)
                (ITER-001
                 (%LIST.THE-CONS-LIST
                  (%NAMED-DESCRIPTION.IO-VARIABLE-TYPES PREDICATE))))
               (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
               (CL:LOOP WHILE
                (CL:AND (CL:< INDEX-000 LENGTH-000)
                 (CL:NOT (CL:EQ ITER-001 NIL)))
                DO
                (CL:SETQ ARG
                 (CL:AREF
                  (CL:THE CL:SIMPLE-VECTOR
                   (%VECTOR.THE-ARRAY VECTOR-000))
                  INDEX-000))
                (CL:SETQ TYPE (%%VALUE ITER-001))
                (CL:WHEN
                 (ISA? ARG SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
                 (ADD-VARIABLE-TYPE ARG TYPE TABLE VISIBLEVARS))
                (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
                (CL:SETQ ITER-001 (%%REST ITER-001)))))
             (CL:T))))
          ((SUBTYPE-OF? TEST-VALUE-002 SGT-DESCRIPTIONS-STELLA-SLOT)
           (CL:PROGN
            (CL:LET*
             ((ARG NULL) (VECTOR-001 ARGUMENTS) (INDEX-001 0)
              (LENGTH-001 (LENGTH VECTOR-001)) (COLUMNTYPE NULL)
              (ITER-002
               (SLOT-COLUMN-TYPES PREDICATE (LENGTH ARGUMENTS))))
             (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
             (CL:LOOP WHILE
              (CL:AND (CL:< INDEX-001 LENGTH-001)
               (CL:NOT (CL:EQ ITER-002 NIL)))
              DO
              (CL:SETQ ARG
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR
                 (%VECTOR.THE-ARRAY VECTOR-001))
                INDEX-001))
              (CL:SETQ COLUMNTYPE (%%VALUE ITER-002))
              (CL:WHEN
               (ISA? ARG SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
               (ADD-VARIABLE-TYPE ARG COLUMNTYPE TABLE VISIBLEVARS))
              (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
              (CL:SETQ ITER-002 (%%REST ITER-002))))))
          ((SUBTYPE-OF? TEST-VALUE-002
            SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT)
           (CL:PROGN))
          (CL:T
           (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
             TEST-VALUE-002 "' is not a valid case option")
            (CL:ERROR
             (NEW-STELLA-EXCEPTION
              (THE-STRING-READER STREAM-000))))))))))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EQUIVALENT)
      (CL:LET*
       ((SECONDARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS)) 1)))
       (CL:WHEN (ISA? FIRSTARG SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
        (CL:IF (ISA? SECONDARG SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
         (CL:LET*
          ((T NULL)
           (ITER-003
            (%LIST.THE-CONS-LIST
             (MAP-NULL-TO-NIL-LIST (LOOKUP TABLE SECONDARG)))))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
           (CL:SETQ T (%%VALUE ITER-003))
           (ADD-VARIABLE-TYPE FIRSTARG T TABLE VISIBLEVARS)
           (CL:SETQ ITER-003 (%%REST ITER-003))))
         (ADD-VARIABLE-TYPE FIRSTARG (LOGICAL-TYPE SECONDARG) TABLE
          VISIBLEVARS)))
       (CL:WHEN
        (ISA? SECONDARG SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
        (CL:IF (ISA? FIRSTARG SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
         (CL:LET*
          ((T NULL)
           (ITER-004
            (%LIST.THE-CONS-LIST
             (MAP-NULL-TO-NIL-LIST (LOOKUP TABLE FIRSTARG)))))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
           (CL:SETQ T (%%VALUE ITER-004))
           (ADD-VARIABLE-TYPE SECONDARG T TABLE VISIBLEVARS)
           (CL:SETQ ITER-004 (%%REST ITER-004))))
         (ADD-VARIABLE-TYPE SECONDARG (LOGICAL-TYPE FIRSTARG) TABLE
          VISIBLEVARS)))))
     (CL:T)))))

;;; (DEFUN INFER-TYPES-FROM-PROPOSITIONS ...)

(CL:DEFUN INFER-TYPES-FROM-PROPOSITIONS (PROPOSITION TABLE VISIBLEVARS)
  (CL:LET* ((ARGUMENTS (%PROPOSITION.ARGUMENTS PROPOSITION)))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-AND)
      (CL:LET*
       ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (INFER-TYPES-FROM-PROPOSITIONS ARG TABLE VISIBLEVARS)
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-OR)
      (CL:LET*
       ((ARG NULL) (VECTOR-001 ARGUMENTS) (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ ARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (INFER-TYPES-FROM-PROPOSITIONS ARG TABLE NIL)
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-ISA)
       (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FUNCTION)
       (CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EQUIVALENT))
      (INFER-TYPES-FROM-ONE-PROPOSITION PROPOSITION TABLE VISIBLEVARS))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-FORALL)
      (CL:SETQ VISIBLEVARS NIL)
      (CL:LET*
       ((V NULL)
        (VECTOR-002
         (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
          SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL))
        (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
       (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
        (CL:SETQ V
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
          INDEX-002))
        (CL:SETQ VISIBLEVARS (CONS V VISIBLEVARS))
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
      (INFER-TYPES-FROM-PROPOSITIONS
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
        0)
       TABLE VISIBLEVARS)
      (INFER-TYPES-FROM-PROPOSITIONS
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
        1)
       TABLE VISIBLEVARS))
     ((CL:EQ TEST-VALUE-000 KWD-DESCRIPTIONS-EXISTS)
      (CL:LET*
       ((V NULL)
        (VECTOR-003
         (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
          SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES NULL))
        (INDEX-003 0) (LENGTH-003 (LENGTH VECTOR-003)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-003 LENGTH-003))
       (CL:LOOP WHILE (CL:< INDEX-003 LENGTH-003) DO
        (CL:SETQ V
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-003))
          INDEX-003))
        (CL:SETQ VISIBLEVARS (CONS V VISIBLEVARS))
        (CL:SETQ INDEX-003 (CL:1+ INDEX-003))))
      (INFER-TYPES-FROM-PROPOSITIONS
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY ARGUMENTS))
        0)
       TABLE VISIBLEVARS))
     (CL:T)))))

;;; (DEFUN (INFER-VARIABLE-TYPES-IN-PROPOSITION VARIABLE-TYPE-TABLE) ...)

(CL:DEFUN INFER-VARIABLE-TYPES-IN-PROPOSITION (PROPOSITION VISIBLEVARIABLES)
  (CL:LET* ((VARIABLETYPESTABLE (NEW-KEY-VALUE-LIST)))
   (CL:LET* ((*ADDEDNEWTYPE?* CL:NIL))
    (CL:DECLARE (CL:SPECIAL *ADDEDNEWTYPE?*))
    (CL:LOOP (CL:SETQ *ADDEDNEWTYPE?* CL:NIL)
     (INFER-TYPES-FROM-PROPOSITIONS PROPOSITION VARIABLETYPESTABLE
      VISIBLEVARIABLES)
     (CL:WHEN (CL:NOT *ADDEDNEWTYPE?*)
      (CL:RETURN-FROM INFER-VARIABLE-TYPES-IN-PROPOSITION
       VARIABLETYPESTABLE))))))

;;; (DEFUN (INFER-VARIABLE-TYPES-IN-DESCRIPTION VARIABLE-TYPE-TABLE) ...)

(CL:DEFUN INFER-VARIABLE-TYPES-IN-DESCRIPTION (DESCRIPTION)
  (CL:LET* ((VISIBLEVARIABLES NIL))
   (CL:LET*
    ((V NULL) (VECTOR-000 (%DESCRIPTION.IO-VARIABLES DESCRIPTION))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ V
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ VISIBLEVARIABLES (CONS V VISIBLEVARIABLES))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET*
    ((V NULL) (ITER-000 (TOP-LEVEL-EXISTENTIAL-VARIABLES DESCRIPTION)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ V (%%VALUE ITER-000))
     (CL:SETQ VISIBLEVARIABLES (CONS V VISIBLEVARIABLES))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (INFER-VARIABLE-TYPES-IN-PROPOSITION
    (%DESCRIPTION.PROPOSITION DESCRIPTION) VISIBLEVARIABLES)))

;;; (DEFUN (COLLECT-UNRESOLVED-SLOT-REFERENCES (CONS OF PROPOSITION)) ...)

(CL:DEFUN COLLECT-UNRESOLVED-SLOT-REFERENCES (SELF)
  (CL:LET* ((UNRESOLVEDSLOTREFERENCES NIL))
   (CL:WHEN
    (CL:AND
     (MEMBER?
      (GET-QUOTED-TREE "((:PREDICATE :FUNCTION) \"/LOGIC\")" "/LOGIC")
      (%PROPOSITION.KIND SELF))
     (ISA? (%PROPOSITION.OPERATOR SELF)
      SGT-DESCRIPTIONS-STELLA-SYMBOL))
    (CL:SETQ UNRESOLVEDSLOTREFERENCES
     (CONS SELF UNRESOLVEDSLOTREFERENCES)))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:WHEN (ISA? ARG SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
      (CL:LET*
       ((U NULL) (ITER-000 (COLLECT-UNRESOLVED-SLOT-REFERENCES ARG)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ U (%%VALUE ITER-000))
        (CL:SETQ UNRESOLVEDSLOTREFERENCES
         (CONS U UNRESOLVEDSLOTREFERENCES))
        (CL:SETQ ITER-000 (%%REST ITER-000)))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   UNRESOLVEDSLOTREFERENCES))

;;; (DEFUN (RESOLVE-ONE-SLOT-REFERENCE? BOOLEAN) ...)

(CL:DEFUN RESOLVE-ONE-SLOT-REFERENCE? (PROPOSITION VARIABLETYPESTABLE)
  (CL:LET*
   ((FIRSTARGUMENT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
      0))
    (PREDICATE NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE FIRSTARGUMENT)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000
       SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE)
      (CL:PROGN
       (CL:LET* ((TYPES (LOOKUP VARIABLETYPESTABLE FIRSTARGUMENT)))
        (CL:WHEN (CL:NOT (CL:EQ TYPES NULL))
         (CL:SETQ PREDICATE
          (INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
           (%PROPOSITION.OPERATOR PROPOSITION)
           (LOOKUP VARIABLETYPESTABLE FIRSTARGUMENT)))))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT)
      (CL:PROGN
       (CL:LET* ((ROOTTYPE (SAFE-LOGICAL-TYPE FIRSTARGUMENT)))
        (CL:WHEN (CL:NOT (CL:EQ ROOTTYPE NULL))
         (CL:SETQ PREDICATE
          (INFER-PREDICATE-FROM-OPERATOR-AND-TYPES
           (%PROPOSITION.OPERATOR PROPOSITION) (LIST ROOTTYPE)))))))
     (CL:T)))
   (CL:WHEN (CL:NOT (CL:EQ PREDICATE NULL))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE PREDICATE)
       SGT-DESCRIPTIONS-STELLA-SLOT)
      (CL:PROGN
       (CL:LET*
        ((RETURNTYPE
          (UNWRAP-WRAPPED-TYPE (%SLOT.SLOT-BASE-TYPE PREDICATE))))
        (CL:WHEN (CL:NOT (BOOLEAN-TYPE? RETURNTYPE))
         (CL:SETF (%PROPOSITION.KIND PROPOSITION)
          KWD-DESCRIPTIONS-FUNCTION)
         (CL:WHEN
          (VARIABLE?
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
            (CL:THE CL:FIXNUM
             (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION))))))
          (CL:LET*
           ((LASTARGUMENT
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%VECTOR.THE-ARRAY
                (%PROPOSITION.ARGUMENTS PROPOSITION)))
              (CL:THE CL:FIXNUM
               (CL:1-
                (LENGTH (%PROPOSITION.ARGUMENTS PROPOSITION)))))))
           (UPDATE-SKOLEM-TYPE LASTARGUMENT RETURNTYPE))))
        (CL:SETF (%PROPOSITION.OPERATOR PROPOSITION)
         (MOST-GENERAL-EQUIVALENT-SLOTREF
          (%SLOT.SLOT-SLOTREF PREDICATE)))
        (EVALUATE-NEW-PROPOSITION PROPOSITION)
        (CL:RETURN-FROM RESOLVE-ONE-SLOT-REFERENCE? CL:T))))
     (CL:T)))
   CL:NIL))

;;; (DEFUN RESOLVE-UNRESOLVED-SLOT-REFERENCES ...)

(CL:DEFUN RESOLVE-UNRESOLVED-SLOT-REFERENCES (FORMULA)
  (CL:LET*
   ((PROPOSITION NULL) (UNRESOLVEDPROPOSITIONS NULL)
    (VARIABLETYPESTABLE NULL) (UNRESOLVABLEPROPOSITIONS NIL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE FORMULA)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-DESCRIPTION)
      (CL:PROGN
       (CL:SETQ PROPOSITION (%DESCRIPTION.PROPOSITION FORMULA))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
      (CL:PROGN (CL:SETQ PROPOSITION FORMULA)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:SETQ UNRESOLVEDPROPOSITIONS
    (COLLECT-UNRESOLVED-SLOT-REFERENCES PROPOSITION))
   (CL:WHEN (CL:EQ UNRESOLVEDPROPOSITIONS NIL)
    (CL:RETURN-FROM RESOLVE-UNRESOLVED-SLOT-REFERENCES))
   (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE FORMULA)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-001 SGT-DESCRIPTIONS-LOGIC-DESCRIPTION)
      (CL:PROGN
       (CL:SETQ VARIABLETYPESTABLE
        (INFER-VARIABLE-TYPES-IN-DESCRIPTION FORMULA))))
     ((SUBTYPE-OF? TEST-VALUE-001 SGT-DESCRIPTIONS-LOGIC-PROPOSITION)
      (CL:PROGN
       (CL:SETQ VARIABLETYPESTABLE
        (INFER-VARIABLE-TYPES-IN-PROPOSITION FORMULA NIL))))
     (CL:T
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
        "`" TEST-VALUE-001 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
   (CL:LET*
    ((PROP NULL) (ITER-000 UNRESOLVEDPROPOSITIONS) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PROP (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (SYMBOL? (%PROPOSITION.OPERATOR PROP))
       (CL:NOT (RESOLVE-ONE-SLOT-REFERENCE? PROP VARIABLETYPESTABLE)))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS PROP NIL))
        (CL:IF (CL:EQ UNRESOLVABLEPROPOSITIONS NIL)
         (CL:SETQ UNRESOLVABLEPROPOSITIONS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST UNRESOLVABLEPROPOSITIONS
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS PROP NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:NOT (CL:EQ UNRESOLVABLEPROPOSITIONS NIL))
    (CL:LET* ((P NULL) (ITER-001 UNRESOLVABLEPROPOSITIONS))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ P (%%VALUE ITER-001))
      (COMPLAIN-ABOUT-UNDECLARED-REFERENCE P) (CREATE-DUMMY-RELATION P)
      (CL:SETQ ITER-001 (%%REST ITER-001)))))))

;;; (DEFUN CREATE-DUMMY-RELATION ...)

(CL:DEFUN CREATE-DUMMY-RELATION (WAYWARDPROPOSITION)
  (CL:LET*
   ((FAKEVARIABLETYPES (NEW-LIST))
    (SYMBOLREF (%PROPOSITION.OPERATOR WAYWARDPROPOSITION))
    (RELATIONREF (SYMBOL-TO-SURROGATE SYMBOLREF)) (DESCRIPTION NULL))
   (CL:LET*
    ((I
      (INTERVAL 1
       (LENGTH (%PROPOSITION.ARGUMENTS WAYWARDPROPOSITION)))))
    (CL:LOOP WHILE (NEXT? I) DO
     (PUSH FAKEVARIABLETYPES SGT-DESCRIPTIONS-STELLA-THING)))
   (CL:SETQ DESCRIPTION
    (CREATE-PRIMITIVE-DESCRIPTION NIL-LIST FAKEVARIABLETYPES CL:NIL
     (CL:EQ (%PROPOSITION.KIND WAYWARDPROPOSITION)
      KWD-DESCRIPTIONS-ISA)
     (CL:EQ (%PROPOSITION.KIND WAYWARDPROPOSITION)
      KWD-DESCRIPTIONS-FUNCTION)
     (%SURROGATE.HOME-CONTEXT RELATIONREF)))
   (CL:SETF (%PROPOSITION.OPERATOR WAYWARDPROPOSITION) RELATIONREF)
   (BIND-LOGIC-OBJECT-TO-SURROGATE SYMBOLREF DESCRIPTION)
   (SET-DYNAMIC-SLOT-VALUE
    (%NAMED-DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
    SYM-DESCRIPTIONS-LOGIC-UNDECLARED?
    (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)))

;;; (DEFUN (DEFINED-RELATION? BOOLEAN) ...)

(CL:DEFUN DEFINED-RELATION? (SELF)
  (CL:AND
   (CL:NOT
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS SELF)
      SYM-DESCRIPTIONS-LOGIC-UNDECLARED? FALSE-WRAPPER)))
   (CL:OR
    (CL:NOT (CL:EQ (STRINGIFIED-SOURCE SELF) STELLA::NULL-STRING))
    (CL:NOT (CL:EQ (NATIVE-RELATION SELF) NULL)))))

;;; (DEFUN (LIST-UNDEFINED-RELATIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN %LIST-UNDEFINED-RELATIONS (MODULE LOCAL?)
  "Return a list of as yet undefined concepts and relations in `module'.
These relations were defined by the system, since they were referenced
but have not yet been defined by the user.  If `module' is NULL look in
the current module.  If `local?' only look in `module' but not in any
modules it inherits."
  (CL:LET* ((THEMODULE (COERCE-TO-MODULE MODULE CL:T)))
   (CL:WHEN (CL:NOT (CL:EQ THEMODULE NULL))
    (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ THEMODULE NULL)))
   (CL:WHEN (CL:EQ THEMODULE NULL) (CL:SETQ THEMODULE *MODULE*))
   (CALL-LIST-UNDEFINED-RELATIONS THEMODULE LOCAL?)))

(CL:DEFUN LIST-UNDEFINED-RELATIONS-EVALUATOR-WRAPPER (ARGUMENTS)
  (%LIST-UNDEFINED-RELATIONS (%%VALUE ARGUMENTS)
   (%BOOLEAN-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO LIST-UNDEFINED-RELATIONS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Return a list of as yet undefined concepts and relations in `module'.
These relations were defined by the system, since they were referenced
but have not yet been defined by the user.  If `module' is NULL look in
the current module.  If `local?' only look in `module' but not in any
modules it inherits."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/LIST-UNDEFINED-RELATIONS|)) (CL:MACRO-FUNCTION (CL:QUOTE LIST-UNDEFINED-RELATIONS)))

;;; (DEFUN (CALL-LIST-UNDEFINED-RELATIONS CONS) ...)

(CL:DEFUN CALL-LIST-UNDEFINED-RELATIONS (MODULE LOCAL?)
  "Callable version of `list-undefined-relations' (which see)."
  (CL:LET* ((UNDEFINED NIL)) (FINALIZE-OBJECTS)
   (CL:LET* ((TERM NULL) (ITER-000 (ALL-NAMED-TERMS MODULE LOCAL?)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ TERM (%ITERATOR.VALUE ITER-000))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TERM)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION)
        (CL:PROGN
         (CL:WHEN (CL:NOT (DEFINED-RELATION? TERM))
          (CL:SETQ UNDEFINED (CONS TERM UNDEFINED)))))
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT)
        (CL:PROGN
         (CL:LET*
          ((*MODULE*
            (CL:IF (CL:EQ MODULE NULL) (HOME-MODULE TERM) MODULE))
           (*CONTEXT* *MODULE*))
          (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
          (CL:WHEN
           (APPLY-CACHED-ASK (CONS SYM-DESCRIPTIONS-LOGIC-?X NIL)
            (LIST* SYM-DESCRIPTIONS-PL-KERNEL-KB-RELATION
             SYM-DESCRIPTIONS-LOGIC-?X NIL)
            (CONS-LIST TERM) (CONS-LIST)
            SYM-DESCRIPTIONS-LOGIC-F-CALL-LIST-UNDEFINED-RELATIONS-QUERY-000)
           (CL:SETQ UNDEFINED (CONS TERM UNDEFINED))))))
       (CL:T)))))
   UNDEFINED))

;;; (DEFUN COMPLAIN-ABOUT-UNDECLARED-REFERENCE ...)

(CL:DEFUN COMPLAIN-ABOUT-UNDECLARED-REFERENCE (WAYWARDPROPOSITION)
  (CL:IF
   (%BOOLEAN-WRAPPER.WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS WAYWARDPROPOSITION)
     SYM-DESCRIPTIONS-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "ERROR: Undeclared predicate or function reference: `"
      (%PROPOSITION.OPERATOR WAYWARDPROPOSITION) "'." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-DESCRIPTIONS-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
     "WARNING: Undeclared predicate or function reference: "
     (%PROPOSITION.OPERATOR WAYWARDPROPOSITION) EOL)
    (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
     KWD-DESCRIPTIONS-WARNING))))

;;; (DEFUN (ALL-NAMED-DESCRIPTIONS-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-NAMED-DESCRIPTIONS-NEXT? (SELF)
  (CL:LET*
   ((CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER SELF))
    (SURROGATE NULL) (SURROGATEVALUE NULL) (DESCRIPTION NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR))
   (CL:LOOP WHILE
    (CL:< CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-SECOND-INTEGER SELF))
    DO
    (CL:SETQ SURROGATE
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY *SURROGATE-ARRAY*))
      CURSOR))
    (CL:WHEN (CL:NOT (CL:EQ SURROGATE NULL))
     (CL:SETQ SURROGATEVALUE (%SURROGATE.SURROGATE-VALUE SURROGATE))
     (CL:WHEN (CL:NOT (CL:EQ SURROGATEVALUE NULL))
      (CL:WHEN
       (CL:NOT
        (SELECTED-META-OBJECT? SELF (HOME-MODULE SURROGATEVALUE)))
       (CL:SETQ SURROGATEVALUE NULL))))
    (CL:SETQ DESCRIPTION NULL)
    (CL:WHEN (CL:NOT (CL:EQ SURROGATEVALUE NULL))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SURROGATEVALUE)))
      (CL:COND
       ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
        (CL:PROGN
         (CL:WHEN (CL:EQ (%CLASS.CLASS-TYPE SURROGATEVALUE) SURROGATE)
          (CL:SETQ DESCRIPTION
           (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS SURROGATEVALUE)
            SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL)))))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIPTIONS-STELLA-RELATION)
        (CL:PROGN
         (CL:SETQ DESCRIPTION
          (DYNAMIC-SLOT-VALUE (%RELATION.DYNAMIC-SLOTS SURROGATEVALUE)
           SYM-DESCRIPTIONS-LOGIC-DESCRIPTION NULL))))
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION)
        (CL:PROGN (CL:SETQ DESCRIPTION SURROGATEVALUE)))
       (CL:T))))
    (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
     (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) DESCRIPTION)
     (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER SELF)
      (CL:1+ CURSOR))
     (CL:RETURN-FROM ALL-NAMED-DESCRIPTIONS-NEXT? CL:T))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   CL:NIL))

;;; (DEFUN (ALL-NAMED-DESCRIPTIONS (ITERATOR OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN ALL-NAMED-DESCRIPTIONS (MODULE LOCAL?)
  "Iterate over all named descriptions visible from 'module'.
If 'local?', return only named descriptions interned in 'module'.
If 'module' is null, return all named descriptions interned everywhere."
  (ALLOCATE-ALL-META-OBJECTS-ITERATOR
   (CL:1+
    (%EXTENSIBLE-SYMBOL-ARRAY.TOP-SYMBOL-OFFSET *SURROGATE-ARRAY*))
   (CL:FUNCTION ALL-NAMED-DESCRIPTIONS-NEXT?) MODULE LOCAL?))

(CL:DEFUN HELP-STARTUP-DESCRIPTIONS1 ()
  (CL:PROGN
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-METHOD-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SLOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-DESCRIPTIONS-STELLA-ANY-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY-VALUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-DESCRIPTIONS-EXTENSIONAL-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIONAL-ASSERTION" NULL 2))
   (CL:SETQ SGT-DESCRIPTIONS-PL-KERNEL-KB-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-DESCRIPTIONS-PL-KERNEL-KB-POLYMORPHIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POLYMORPHIC"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X1
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X1" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X2
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X2" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X3
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X3" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X4
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X4" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X5
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X5" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X6
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X6" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X7
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X7" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X8
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X8" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X9
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X9" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X10
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X10" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X11
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X11" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X12
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X12" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X13
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X13" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X14
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X14" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X15
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X15" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X16
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X16" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X17
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X17" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X18
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X18" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X19
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X19" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X20
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X20" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X21
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X21" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X22
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X22" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X23
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X23" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X24
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X24" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X25
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X25" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X26
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X26" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X27
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X27" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X28
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X28" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X29
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X29" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X30
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X30" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X31
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X31" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X32
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X32" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X33
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X33" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X34
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X34" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X35
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X35" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X36
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X36" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X37
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X37" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X38
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X38" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X39
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X39" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X40
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X40" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X41
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X41" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X42
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X42" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X43
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X43" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X44
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X44" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X45
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X45" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X46
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X46" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X47
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X47" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X48
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X48" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X49
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X49" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X50
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X50" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X51
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X51" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X52
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X52" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X53
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X53" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X54
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X54" NULL 0))))

(CL:DEFUN HELP-STARTUP-DESCRIPTIONS2 ()
  (CL:PROGN
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X55
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X55" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X56
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X56" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X57
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X57" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X58
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X58" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X59
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X59" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X60
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X60" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X61
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X61" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X62
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X62" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X63
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X63" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X64
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X64" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X65
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X65" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X66
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X66" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X67
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X67" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X68
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X68" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X69
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X69" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X70
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X70" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X71
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X71" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X72
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X72" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X73
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X73" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X74
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X74" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X75
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X75" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X76
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X76" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X77
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X77" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X78
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X78" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X79
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X79" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X80
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X80" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X81
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X81" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X82
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X82" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X83
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X83" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X84
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X84" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X85
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X85" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X86
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X86" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X87
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X87" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X88
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X88" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X89
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X89" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X90
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X90" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X91
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X91" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X92
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X92" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X93
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X93" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X94
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X94" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X95
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X95" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X96
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X96" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X97
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X97" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X98
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X98" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X99
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X99" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X100
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X100" NULL 0))
   (CL:SETQ SGT-DESCRIPTIONS-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SYM-DESCRIPTIONS-STELLA-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-KAPPA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
   (CL:SETQ KWD-DESCRIPTIONS-KIF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KIF" NULL 2))
   (CL:SETQ KWD-DESCRIPTIONS-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ SGT-DESCRIPTIONS-PL-KERNEL-KB-CONCEPT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEPT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-DESCRIPTIONS-PL-KERNEL-KB-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-DESCRIPTIONS-PL-KERNEL-KB-VARIABLE-ARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-ARITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-DESCRIPTIONS-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-OBJECT-STORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-STORE" NULL 0))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))))

(CL:DEFUN HELP-STARTUP-DESCRIPTIONS3 ()
  (CL:PROGN
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-LITERAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-DESCRIPTIONS-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ KWD-DESCRIPTIONS-WARNING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARNING" NULL 2))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-DESCRIPTIONS-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-VARIABLE-TYPE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE?" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-ENTITY-MAPPING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ENTITY-MAPPING" NULL 0))
   (CL:SETQ KWD-DESCRIPTIONS-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-DESCRIPTIONS-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-DESCRIPTIONS-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ KWD-DESCRIPTIONS-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ KWD-DESCRIPTIONS-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
   (CL:SETQ SGT-DESCRIPTIONS-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-DESCRIPTIONS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-DESCRIPTIONS-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ KWD-DESCRIPTIONS-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-EXTERNAL-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTERNAL-VARIABLES" NULL 0))
   (CL:SETQ KWD-DESCRIPTIONS-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-DESCRIPTIONS-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ SGT-DESCRIPTIONS-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SYM-DESCRIPTIONS-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-PROPOSITION.IF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION.IF"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-DESCRIPTIONS-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-CS-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CS-VALUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-THE-ONLY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-ONLY" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-IOTA?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IOTA?" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-COMPLEMENT-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT-DESCRIPTION" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-VARIABLE-TYPE-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE-TABLE" NULL 0))
   (CL:SETQ SGT-DESCRIPTIONS-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SGT-DESCRIPTIONS-STELLA-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-UNDECLARED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNDECLARED?" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-LIST-UNDEFINED-RELATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-UNDEFINED-RELATIONS" NULL 0))
   (CL:SETQ KWD-DESCRIPTIONS-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-?X
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-PL-KERNEL-KB-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ
    SYM-DESCRIPTIONS-LOGIC-F-CALL-LIST-UNDEFINED-RELATIONS-QUERY-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-CALL-LIST-UNDEFINED-RELATIONS-QUERY-000" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-DESCRIPTIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTIVE?" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-LOGIC-STARTUP-DESCRIPTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-DESCRIPTIONS" NULL 0))
   (CL:SETQ SYM-DESCRIPTIONS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-DESCRIPTIONS4 ()
  (CL:PROGN
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT RELATION DESCRIPTION :TYPE NAMED-DESCRIPTION :DOCUMENTATION \"Maps a relation (class or slot or table) to a
primitive description.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "DIRECT-SUPERRELATIONS"
    "(DEFUN (DIRECT-SUPERRELATIONS (ITERATOR OF (LIKE SELF))) ((SELF RELATION)) :DOCUMENTATION \"Return direct super classes/slots of 'self'.\")"
    (CL:FUNCTION DIRECT-SUPERRELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "SLOT-COLUMN-TYPES"
    "(DEFUN (SLOT-COLUMN-TYPES (CONS OF TYPE)) ((SELF SLOT) (COUNT INTEGER)))"
    (CL:FUNCTION SLOT-COLUMN-TYPES) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-DESCRIPTION"
    "(DEFUN (CREATE-DESCRIPTION DESCRIPTION) ((ARITY INTEGER) (NAMED? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-DESCRIPTION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DESCRIPTION-NAME SYMBOL) ((SELF DESCRIPTION)) :DOCUMENTATION \"Return the name of the description `self', if it has one.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DESCRIPTION-NAME) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DESCRIPTION-NAME SYMBOL) ((SELF NAMED-DESCRIPTION)) :DOCUMENTATION \"Return the name of the description `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DESCRIPTION-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT
    "CREATE-BASE-RELATION-FOR-POLYMORPHIC-DESCRIPTION"
    "(DEFUN CREATE-BASE-RELATION-FOR-POLYMORPHIC-DESCRIPTION ((DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION CREATE-BASE-RELATION-FOR-POLYMORPHIC-DESCRIPTION)
    NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-SYSTEM-DEFINED-PARAMETER-NAME"
    "(DEFUN (YIELD-SYSTEM-DEFINED-PARAMETER-NAME SYMBOL) ((INDEX INTEGER) (REFERENCEOBJECT OBJECT)))"
    (CL:FUNCTION YIELD-SYSTEM-DEFINED-PARAMETER-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "ENSURE-DESCRIPTION-BODY"
    "(DEFUN ENSURE-DESCRIPTION-BODY ((DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION ENSURE-DESCRIPTION-BODY) NULL)
   (DEFINE-FUNCTION-OBJECT "MATERIALIZE-PRIMITIVE-DESCRIPTION-BODY"
    "(DEFUN MATERIALIZE-PRIMITIVE-DESCRIPTION-BODY ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION MATERIALIZE-PRIMITIVE-DESCRIPTION-BODY) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-PRIMITIVE-DESCRIPTION"
    "(DEFUN (CREATE-PRIMITIVE-DESCRIPTION NAMED-DESCRIPTION) ((IOVARIABLENAMES (LIST OF SYMBOL)) (IOVARIABLETYPES (LIST OF TYPE)) (VARIABLEARITY? BOOLEAN) (CLASS? BOOLEAN) (FUNCTION? BOOLEAN) (MODULE MODULE)))"
    (CL:FUNCTION CREATE-PRIMITIVE-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "LINK-STELLA-RELATION-AND-DESCRIPTION"
    "(DEFUN LINK-STELLA-RELATION-AND-DESCRIPTION ((SELF RELATION) (DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION LINK-STELLA-RELATION-AND-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-DESCRIPTION-FOR-STELLA-RELATION"
    "(DEFUN (CREATE-DESCRIPTION-FOR-STELLA-RELATION NAMED-DESCRIPTION) ((SELF RELATION)))"
    (CL:FUNCTION CREATE-DESCRIPTION-FOR-STELLA-RELATION) NULL)
   (DEFINE-FUNCTION-OBJECT "SURROGATE-TO-DESCRIPTION"
    "(DEFUN (SURROGATE-TO-DESCRIPTION NAMED-DESCRIPTION) ((SELF SURROGATE)))"
    (CL:FUNCTION SURROGATE-TO-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-DESCRIPTION"
    "(DEFUN (GET-DESCRIPTION NAMED-DESCRIPTION) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION GET-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "SURROGATE.GET-DESCRIPTION"
    "(DEFUN (SURROGATE.GET-DESCRIPTION NAMED-DESCRIPTION) ((SELF SURROGATE)))"
    (CL:FUNCTION SURROGATE.GET-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING.GET-DESCRIPTION"
    "(DEFUN (STRING.GET-DESCRIPTION NAMED-DESCRIPTION) ((SELF STRING)))"
    (CL:FUNCTION STRING.GET-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS.GET-DESCRIPTION"
    "(DEFUN (CLASS.GET-DESCRIPTION NAMED-DESCRIPTION) ((SELF CLASS)))"
    (CL:FUNCTION CLASS.GET-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "SLOT.GET-DESCRIPTION"
    "(DEFUN (SLOT.GET-DESCRIPTION NAMED-DESCRIPTION) ((SELF SLOT)))"
    (CL:FUNCTION SLOT.GET-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "ENSURE-DEFERRED-DESCRIPTION"
    "(DEFUN (ENSURE-DEFERRED-DESCRIPTION SURROGATE) ((SELF SURROGATE)))"
    (CL:FUNCTION ENSURE-DEFERRED-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGIC-CLASS?"
    "(DEFUN (LOGIC-CLASS? BOOLEAN) ((SELF CLASS)) :DOCUMENTATION \"Return TRUE if the class 'self' or one of its
supers supports indices that record extensions referenced by
the logic system. Also return true for literal classes.\")"
    (CL:FUNCTION LOGIC-CLASS?) NULL)
   (DEFINE-FUNCTION-OBJECT "VARIABLE-ARITY-DOMAIN-TYPES-NEXT?"
    "(DEFUN (VARIABLE-ARITY-DOMAIN-TYPES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION VARIABLE-ARITY-DOMAIN-TYPES-NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-ITERATOR-FOR-VARIABLE-ARITY"
    "(DEFUN (WRAP-ITERATOR-FOR-VARIABLE-ARITY ITERATOR) ((ITERATOR ITERATOR)))"
    (CL:FUNCTION WRAP-ITERATOR-FOR-VARIABLE-ARITY) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DOMAIN-TYPES"
    "(DEFUN (ALL-DOMAIN-TYPES ITERATOR) ((SELF NAMED-DESCRIPTION)))"
    (CL:FUNCTION ALL-DOMAIN-TYPES) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-ARGUMENT-TYPES"
    "(DEFUN (ALL-ARGUMENT-TYPES ITERATOR) ((SELF NAMED-DESCRIPTION)))"
    (CL:FUNCTION ALL-ARGUMENT-TYPES) NULL)
   (DEFINE-FUNCTION-OBJECT "PUSH-LOGIC-VARIABLE-BINDING"
    "(DEFUN PUSH-LOGIC-VARIABLE-BINDING ((VARIABLE SKOLEM)))"
    (CL:FUNCTION PUSH-LOGIC-VARIABLE-BINDING) NULL)
   (DEFINE-FUNCTION-OBJECT "POP-LOGIC-VARIABLE-BINDING"
    "(DEFUN POP-LOGIC-VARIABLE-BINDING ())"
    (CL:FUNCTION POP-LOGIC-VARIABLE-BINDING) NULL)
   (DEFINE-FUNCTION-OBJECT "POP-LOGIC-VARIABLE-BINDINGS"
    "(DEFUN POP-LOGIC-VARIABLE-BINDINGS ((VARIABLES (CONS OF SKOLEM))))"
    (CL:FUNCTION POP-LOGIC-VARIABLE-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-LOGIC-VARIABLE-BINDING"
    "(DEFUN (LOOKUP-LOGIC-VARIABLE-BINDING OBJECT) ((VARIABLENAME SYMBOL)))"
    (CL:FUNCTION LOOKUP-LOGIC-VARIABLE-BINDING) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-ONE-VARIABLE-DECLARATION"
    "(DEFUN PARSE-ONE-VARIABLE-DECLARATION ((VDEC OBJECT) (LOCALDECLARATIONS (LIST OF PATTERN-VARIABLE))))"
    (CL:FUNCTION PARSE-ONE-VARIABLE-DECLARATION) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-LOGIC-VARIABLE-DECLARATIONS"
    "(DEFUN (PARSE-LOGIC-VARIABLE-DECLARATIONS (CONS OF PATTERN-VARIABLE)) ((TREE OBJECT)))"
    (CL:FUNCTION PARSE-LOGIC-VARIABLE-DECLARATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-BUILD-QUANTIFIED-PROPOSITION"
    "(DEFUN (HELP-BUILD-QUANTIFIED-PROPOSITION (CONS OF SKOLEM) PROPOSITION PROPOSITION) ((TREE CONS) (CONVERTTYPESTOCONSTRAINTS? BOOLEAN)))"
    (CL:FUNCTION HELP-BUILD-QUANTIFIED-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-QUANTIFIED-PROPOSITION"
    "(DEFUN (BUILD-QUANTIFIED-PROPOSITION (CONS OF SKOLEM) PROPOSITION PROPOSITION) ((TREE CONS) (CONVERTTYPESTOCONSTRAINTS? BOOLEAN)))"
    (CL:FUNCTION BUILD-QUANTIFIED-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "COPY-CONS-LIST-TO-VARIABLES-VECTOR"
    "(DEFUN (COPY-CONS-LIST-TO-VARIABLES-VECTOR VARIABLES-VECTOR) ((CONSLIST CONS)))"
    (CL:FUNCTION COPY-CONS-LIST-TO-VARIABLES-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-HOLDS-PROPOSITION?"
    "(DEFUN (EQUIVALENT-HOLDS-PROPOSITION? BOOLEAN) ((SELF PROPOSITION) (OTHER PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION EQUIVALENT-HOLDS-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-COMMUTATIVE-PROPOSITIONS?"
    "(DEFUN (EQUIVALENT-COMMUTATIVE-PROPOSITIONS? BOOLEAN) ((SELF PROPOSITION) (OTHER PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION EQUIVALENT-COMMUTATIVE-PROPOSITIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-PROPOSITIONS?"
    "(DEFUN (EQUIVALENT-PROPOSITIONS? BOOLEAN) ((SELF PROPOSITION) (OTHER PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION EQUIVALENT-PROPOSITIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-FUNCTION-PROPOSITIONS?"
    "(DEFUN (EQUIVALENT-FUNCTION-PROPOSITIONS? BOOLEAN) ((SELF PROPOSITION) (OTHER PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION EQUIVALENT-FUNCTION-PROPOSITIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-DESCRIPTIONS?"
    "(DEFUN (EQUIVALENT-DESCRIPTIONS? BOOLEAN) ((SELF DESCRIPTION) (OTHER DESCRIPTION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION EQUIVALENT-DESCRIPTIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-ENUMERATIONS?"
    "(DEFUN (EQUIVALENT-ENUMERATIONS? BOOLEAN) ((SELF COLLECTION) (OTHER COLLECTION)))"
    (CL:FUNCTION EQUIVALENT-ENUMERATIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-FORMULAE?"
    "(DEFUN (EQUIVALENT-FORMULAE? BOOLEAN) ((SELF OBJECT) (OTHER OBJECT) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION EQUIVALENT-FORMULAE?) NULL)
   (DEFINE-FUNCTION-OBJECT "SAME-AND-UNIQUE-ARGUMENTS?"
    "(DEFUN (SAME-AND-UNIQUE-ARGUMENTS? BOOLEAN) ((VARIABLES VARIABLES-VECTOR) (ARGUMENTS VECTOR)))"
    (CL:FUNCTION SAME-AND-UNIQUE-ARGUMENTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "UNIFY-PROPOSITIONS?"
    "(DEFUN (UNIFY-PROPOSITIONS? BOOLEAN) ((SELF PROPOSITION) (OTHER PROPOSITION) (MAPPING ENTITY-MAPPING)))"
    (CL:FUNCTION UNIFY-PROPOSITIONS?) NULL)
   (DEFINE-FUNCTION-OBJECT "NAMED-DESCRIPTION?"
    "(DEFUN (NAMED-DESCRIPTION? BOOLEAN) ((SELF DESCRIPTION)) :DOCUMENTATION \"Return TRUE if 'self' is the description of a named class or relation.\" :PUBLIC? TRUE)"
    (CL:FUNCTION NAMED-DESCRIPTION?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIND-DUPLICATE-NAMED-DESCRIPTION LOGIC-OBJECT) ((SELF DESCRIPTION)))"
    (CL:FUNCTION FIND-DUPLICATE-NAMED-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-DUPLICATE-COMPLEX-DESCRIPTION"
    "(DEFUN (FIND-DUPLICATE-COMPLEX-DESCRIPTION DESCRIPTION) ((SELF DESCRIPTION)))"
    (CL:FUNCTION FIND-DUPLICATE-COMPLEX-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-DUPLICATE-DESCRIPTION"
    "(DEFUN (FIND-DUPLICATE-DESCRIPTION DESCRIPTION) ((SELF DESCRIPTION)))"
    (CL:FUNCTION FIND-DUPLICATE-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTAINS-NESTED-ARGUMENT?"
    "(DEFUN (CONTAINS-NESTED-ARGUMENT? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION CONTAINS-NESTED-ARGUMENT?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPAND-IF-PROPOSITION"
    "(DEFUN (EXPAND-IF-PROPOSITION PROPOSITION) ((IFPROPOSITION PROPOSITION)))"
    (CL:FUNCTION EXPAND-IF-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-FLATTENED-ARGUMENTS"
    "(DEFUN HELP-COLLECT-FLATTENED-ARGUMENTS ((SELF PROPOSITION) (FLATTENEDARGUMENTS (LIST OF PROPOSITION)) (EXISTSVARIABLES (LIST OF PATTERN-VARIABLE))))"
    (CL:FUNCTION HELP-COLLECT-FLATTENED-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-FLATTENED-ARGUMENTS"
    "(DEFUN (YIELD-FLATTENED-ARGUMENTS (LIST OF PROPOSITION)) ((PROPOSITION PROPOSITION) (EXISTSVARIABLES (LIST OF PATTERN-VARIABLE))))"
    (CL:FUNCTION YIELD-FLATTENED-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "FLATTEN-NESTED-FUNCTION-ARGUMENTS"
    "(DEFUN (FLATTEN-NESTED-FUNCTION-ARGUMENTS PROPOSITION) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION FLATTEN-NESTED-FUNCTION-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLAPSE-VALUE-OF-CHAINS-FOR-IO-VARIABLES"
    "(DEFUN COLLAPSE-VALUE-OF-CHAINS-FOR-IO-VARIABLES ((IOVARIABLES VARIABLES-VECTOR)))"
    (CL:FUNCTION COLLAPSE-VALUE-OF-CHAINS-FOR-IO-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-NULLS-IN-VARIABLES-VECTOR"
    "(DEFUN (REMOVE-NULLS-IN-VARIABLES-VECTOR VARIABLES-VECTOR) ((IOVARIABLES VARIABLES-VECTOR)))"
    (CL:FUNCTION REMOVE-NULLS-IN-VARIABLES-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "TIGHTEN-ARGUMENT-BINDINGS"
    "(DEFUN TIGHTEN-ARGUMENT-BINDINGS ((PROPOSITION PROPOSITION) (IOVARIABLES VARIABLES-VECTOR)))"
    (CL:FUNCTION TIGHTEN-ARGUMENT-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUATE-TOP-LEVEL-EQUIVALENCES"
    "(DEFUN EQUATE-TOP-LEVEL-EQUIVALENCES ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION EQUATE-TOP-LEVEL-EQUIVALENCES) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-ALL-VARIABLES"
    "(DEFUN COLLECT-ALL-VARIABLES ((SELF PROPOSITION) (COLLECTION (LIST OF PATTERN-VARIABLE)) (BEENTHERE LIST)))"
    (CL:FUNCTION COLLECT-ALL-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-INTERNAL-VARIABLES"
    "(DEFUN COMPUTE-INTERNAL-VARIABLES ((SELF DESCRIPTION)))"
    (CL:FUNCTION COMPUTE-INTERNAL-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-EXTERNAL-VARIABLES"
    "(DEFUN COLLECT-EXTERNAL-VARIABLES ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION COLLECT-EXTERNAL-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "FINISH-BUILDING-DESCRIPTION"
    "(DEFUN (FINISH-BUILDING-DESCRIPTION DESCRIPTION) ((DESCRIPTION DESCRIPTION) (CHECKFORDUPLICATE? BOOLEAN)))"
    (CL:FUNCTION FINISH-BUILDING-DESCRIPTION) NULL)))

(CL:DEFUN STARTUP-DESCRIPTIONS ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-DESCRIPTIONS1) (HELP-STARTUP-DESCRIPTIONS2)
    (HELP-STARTUP-DESCRIPTIONS3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ FAKE-IO-VARIABLES (NEW-VECTOR 0))
    (CL:SETQ SYSTEM-DEFINED-ARGUMENT-NAMES
     (LIST* SYM-DESCRIPTIONS-LOGIC-?X1 SYM-DESCRIPTIONS-LOGIC-?X2
      SYM-DESCRIPTIONS-LOGIC-?X3 SYM-DESCRIPTIONS-LOGIC-?X4
      SYM-DESCRIPTIONS-LOGIC-?X5 SYM-DESCRIPTIONS-LOGIC-?X6
      SYM-DESCRIPTIONS-LOGIC-?X7 SYM-DESCRIPTIONS-LOGIC-?X8
      SYM-DESCRIPTIONS-LOGIC-?X9 SYM-DESCRIPTIONS-LOGIC-?X10
      SYM-DESCRIPTIONS-LOGIC-?X11 SYM-DESCRIPTIONS-LOGIC-?X12
      SYM-DESCRIPTIONS-LOGIC-?X13 SYM-DESCRIPTIONS-LOGIC-?X14
      SYM-DESCRIPTIONS-LOGIC-?X15 SYM-DESCRIPTIONS-LOGIC-?X16
      SYM-DESCRIPTIONS-LOGIC-?X17 SYM-DESCRIPTIONS-LOGIC-?X18
      SYM-DESCRIPTIONS-LOGIC-?X19 SYM-DESCRIPTIONS-LOGIC-?X20
      SYM-DESCRIPTIONS-LOGIC-?X21 SYM-DESCRIPTIONS-LOGIC-?X22
      SYM-DESCRIPTIONS-LOGIC-?X23 SYM-DESCRIPTIONS-LOGIC-?X24
      SYM-DESCRIPTIONS-LOGIC-?X25 SYM-DESCRIPTIONS-LOGIC-?X26
      SYM-DESCRIPTIONS-LOGIC-?X27 SYM-DESCRIPTIONS-LOGIC-?X28
      SYM-DESCRIPTIONS-LOGIC-?X29 SYM-DESCRIPTIONS-LOGIC-?X30
      SYM-DESCRIPTIONS-LOGIC-?X31 SYM-DESCRIPTIONS-LOGIC-?X32
      SYM-DESCRIPTIONS-LOGIC-?X33 SYM-DESCRIPTIONS-LOGIC-?X34
      SYM-DESCRIPTIONS-LOGIC-?X35 SYM-DESCRIPTIONS-LOGIC-?X36
      SYM-DESCRIPTIONS-LOGIC-?X37 SYM-DESCRIPTIONS-LOGIC-?X38
      SYM-DESCRIPTIONS-LOGIC-?X39 SYM-DESCRIPTIONS-LOGIC-?X40
      SYM-DESCRIPTIONS-LOGIC-?X41 SYM-DESCRIPTIONS-LOGIC-?X42
      SYM-DESCRIPTIONS-LOGIC-?X43 SYM-DESCRIPTIONS-LOGIC-?X44
      SYM-DESCRIPTIONS-LOGIC-?X45 SYM-DESCRIPTIONS-LOGIC-?X46
      SYM-DESCRIPTIONS-LOGIC-?X47 SYM-DESCRIPTIONS-LOGIC-?X48
      SYM-DESCRIPTIONS-LOGIC-?X49 SYM-DESCRIPTIONS-LOGIC-?X50
      SYM-DESCRIPTIONS-LOGIC-?X51 SYM-DESCRIPTIONS-LOGIC-?X52
      SYM-DESCRIPTIONS-LOGIC-?X53 SYM-DESCRIPTIONS-LOGIC-?X54
      SYM-DESCRIPTIONS-LOGIC-?X55 SYM-DESCRIPTIONS-LOGIC-?X56
      SYM-DESCRIPTIONS-LOGIC-?X57 SYM-DESCRIPTIONS-LOGIC-?X58
      SYM-DESCRIPTIONS-LOGIC-?X59 SYM-DESCRIPTIONS-LOGIC-?X60
      SYM-DESCRIPTIONS-LOGIC-?X61 SYM-DESCRIPTIONS-LOGIC-?X62
      SYM-DESCRIPTIONS-LOGIC-?X63 SYM-DESCRIPTIONS-LOGIC-?X64
      SYM-DESCRIPTIONS-LOGIC-?X65 SYM-DESCRIPTIONS-LOGIC-?X66
      SYM-DESCRIPTIONS-LOGIC-?X67 SYM-DESCRIPTIONS-LOGIC-?X68
      SYM-DESCRIPTIONS-LOGIC-?X69 SYM-DESCRIPTIONS-LOGIC-?X70
      SYM-DESCRIPTIONS-LOGIC-?X71 SYM-DESCRIPTIONS-LOGIC-?X72
      SYM-DESCRIPTIONS-LOGIC-?X73 SYM-DESCRIPTIONS-LOGIC-?X74
      SYM-DESCRIPTIONS-LOGIC-?X75 SYM-DESCRIPTIONS-LOGIC-?X76
      SYM-DESCRIPTIONS-LOGIC-?X77 SYM-DESCRIPTIONS-LOGIC-?X78
      SYM-DESCRIPTIONS-LOGIC-?X79 SYM-DESCRIPTIONS-LOGIC-?X80
      SYM-DESCRIPTIONS-LOGIC-?X81 SYM-DESCRIPTIONS-LOGIC-?X82
      SYM-DESCRIPTIONS-LOGIC-?X83 SYM-DESCRIPTIONS-LOGIC-?X84
      SYM-DESCRIPTIONS-LOGIC-?X85 SYM-DESCRIPTIONS-LOGIC-?X86
      SYM-DESCRIPTIONS-LOGIC-?X87 SYM-DESCRIPTIONS-LOGIC-?X88
      SYM-DESCRIPTIONS-LOGIC-?X89 SYM-DESCRIPTIONS-LOGIC-?X90
      SYM-DESCRIPTIONS-LOGIC-?X91 SYM-DESCRIPTIONS-LOGIC-?X92
      SYM-DESCRIPTIONS-LOGIC-?X93 SYM-DESCRIPTIONS-LOGIC-?X94
      SYM-DESCRIPTIONS-LOGIC-?X95 SYM-DESCRIPTIONS-LOGIC-?X96
      SYM-DESCRIPTIONS-LOGIC-?X97 SYM-DESCRIPTIONS-LOGIC-?X98
      SYM-DESCRIPTIONS-LOGIC-?X99 SYM-DESCRIPTIONS-LOGIC-?X100 NIL)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE ENTITY-MAPPING (KEY-VALUE-LIST OF OBJECT OBJECT) :DOCUMENTATION \"Used to keep track of copied or substituted variables
and propositions within 'copy-description', etc.  This needs to be a
subtype of DICTIONARY.  KEY-VALUE-LIST is a good choice for most cases,
however, for very high-arity relations and descriptions we do get bad performance
during copying and equivalence checking and KEY-VALUE-MAP (though more
heavy-weight) would be the better option.\")")
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE VARIABLE-TYPE-TABLE (KEY-VALUE-LIST OF PATTERN-VARIABLE (LIST OF TYPE)))"))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (HELP-STARTUP-DESCRIPTIONS4)
    (DEFINE-FUNCTION-OBJECT "EVALUATE-DESCRIPTION-TERM"
     "(DEFUN (EVALUATE-DESCRIPTION-TERM DESCRIPTION) ((TERM CONS) (CHECKFORDUPLICATE? BOOLEAN)))"
     (CL:FUNCTION EVALUATE-DESCRIPTION-TERM) NULL)
    (DEFINE-FUNCTION-OBJECT "REMOVE-VARIABLE-TYPE-PROPOSITIONS"
     "(DEFUN (REMOVE-VARIABLE-TYPE-PROPOSITIONS (CONS OF PROPOSITION)) ((PROPOSITION PROPOSITION)))"
     (CL:FUNCTION REMOVE-VARIABLE-TYPE-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-COMPLEMENT-OF-GOAL-DESCRIPTION"
     "(DEFUN (GET-COMPLEMENT-OF-GOAL-DESCRIPTION DESCRIPTION) ((SELF NAMED-DESCRIPTION)))"
     (CL:FUNCTION GET-COMPLEMENT-OF-GOAL-DESCRIPTION) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-FREE-VARIABLES"
     "(DEFUN COLLECT-FREE-VARIABLES ((SELF OBJECT) (COLLECTION (LIST OF PATTERN-VARIABLE)) (QUANTIFIEDVARS LIST) (BEENTHERE LIST)))"
     (CL:FUNCTION COLLECT-FREE-VARIABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "TOP-LEVEL-EXISTENTIAL-VARIABLES"
     "(DEFUN (TOP-LEVEL-EXISTENTIAL-VARIABLES (CONS OF PATTERN-VARIABLE)) ((SELF DESCRIPTION)))"
     (CL:FUNCTION TOP-LEVEL-EXISTENTIAL-VARIABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "TOP-LEVEL-EXISTENTIAL-VARIABLE?"
     "(DEFUN (TOP-LEVEL-EXISTENTIAL-VARIABLE? BOOLEAN) ((VARIABLE PATTERN-VARIABLE) (DESCRIPTION DESCRIPTION)))"
     (CL:FUNCTION TOP-LEVEL-EXISTENTIAL-VARIABLE?) NULL)
    (DEFINE-FUNCTION-OBJECT "FREE-VARIABLE?"
     "(DEFUN (FREE-VARIABLE? BOOLEAN) ((VARIABLE PATTERN-VARIABLE) (PROPOSITION PROPOSITION)))"
     (CL:FUNCTION FREE-VARIABLE?) NULL)
    (DEFINE-FUNCTION-OBJECT "MOST-SPECIFIC-TYPES"
     "(DEFUN (MOST-SPECIFIC-TYPES (LIST OF TYPE)) ((TYPES (LIST OF TYPE))))"
     (CL:FUNCTION MOST-SPECIFIC-TYPES) NULL)
    (DEFINE-FUNCTION-OBJECT "ADD-VARIABLE-TYPE"
     "(DEFUN ADD-VARIABLE-TYPE ((VARIABLE PATTERN-VARIABLE) (NEWTYPE TYPE) (TABLE VARIABLE-TYPE-TABLE) (VISIBLEVARIABLES (CONS OF PATTERN-VARIABLE))))"
     (CL:FUNCTION ADD-VARIABLE-TYPE) NULL)
    (DEFINE-FUNCTION-OBJECT "INFER-PREDICATE-FROM-OPERATOR-AND-TYPES"
     "(DEFUN (INFER-PREDICATE-FROM-OPERATOR-AND-TYPES OBJECT) ((OPERATOR OBJECT) (TYPES (LIST OF TYPE))))"
     (CL:FUNCTION INFER-PREDICATE-FROM-OPERATOR-AND-TYPES) NULL)
    (DEFINE-FUNCTION-OBJECT "INFER-TYPES-FROM-ONE-PROPOSITION"
     "(DEFUN INFER-TYPES-FROM-ONE-PROPOSITION ((PROPOSITION PROPOSITION) (TABLE VARIABLE-TYPE-TABLE) (VISIBLEVARS (CONS OF PATTERN-VARIABLE))))"
     (CL:FUNCTION INFER-TYPES-FROM-ONE-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "INFER-TYPES-FROM-PROPOSITIONS"
     "(DEFUN INFER-TYPES-FROM-PROPOSITIONS ((PROPOSITION PROPOSITION) (TABLE VARIABLE-TYPE-TABLE) (VISIBLEVARS (CONS OF PATTERN-VARIABLE))))"
     (CL:FUNCTION INFER-TYPES-FROM-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "INFER-VARIABLE-TYPES-IN-PROPOSITION"
     "(DEFUN (INFER-VARIABLE-TYPES-IN-PROPOSITION VARIABLE-TYPE-TABLE) ((PROPOSITION PROPOSITION) (VISIBLEVARIABLES (CONS OF PATTERN-VARIABLE))))"
     (CL:FUNCTION INFER-VARIABLE-TYPES-IN-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "INFER-VARIABLE-TYPES-IN-DESCRIPTION"
     "(DEFUN (INFER-VARIABLE-TYPES-IN-DESCRIPTION VARIABLE-TYPE-TABLE) ((DESCRIPTION DESCRIPTION)))"
     (CL:FUNCTION INFER-VARIABLE-TYPES-IN-DESCRIPTION) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-UNRESOLVED-SLOT-REFERENCES"
     "(DEFUN (COLLECT-UNRESOLVED-SLOT-REFERENCES (CONS OF PROPOSITION)) ((SELF PROPOSITION)))"
     (CL:FUNCTION COLLECT-UNRESOLVED-SLOT-REFERENCES) NULL)
    (DEFINE-FUNCTION-OBJECT "RESOLVE-ONE-SLOT-REFERENCE?"
     "(DEFUN (RESOLVE-ONE-SLOT-REFERENCE? BOOLEAN) ((PROPOSITION PROPOSITION) (VARIABLETYPESTABLE VARIABLE-TYPE-TABLE)))"
     (CL:FUNCTION RESOLVE-ONE-SLOT-REFERENCE?) NULL)
    (DEFINE-FUNCTION-OBJECT "RESOLVE-UNRESOLVED-SLOT-REFERENCES"
     "(DEFUN RESOLVE-UNRESOLVED-SLOT-REFERENCES ((FORMULA OBJECT)))"
     (CL:FUNCTION RESOLVE-UNRESOLVED-SLOT-REFERENCES) NULL)
    (DEFINE-FUNCTION-OBJECT "CREATE-DUMMY-RELATION"
     "(DEFUN CREATE-DUMMY-RELATION ((WAYWARDPROPOSITION PROPOSITION)))"
     (CL:FUNCTION CREATE-DUMMY-RELATION) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINED-RELATION?"
     "(DEFUN (DEFINED-RELATION? BOOLEAN) ((SELF NAMED-DESCRIPTION)))"
     (CL:FUNCTION DEFINED-RELATION?) NULL)
    (DEFINE-FUNCTION-OBJECT "LIST-UNDEFINED-RELATIONS"
     "(DEFUN (LIST-UNDEFINED-RELATIONS (CONS OF NAMED-DESCRIPTION)) ((MODULE NAME) (LOCAL? BOOLEAN)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Return a list of as yet undefined concepts and relations in `module'.
These relations were defined by the system, since they were referenced
but have not yet been defined by the user.  If `module' is NULL look in
the current module.  If `local?' only look in `module' but not in any
modules it inherits.\")" (CL:FUNCTION %LIST-UNDEFINED-RELATIONS)
     (CL:FUNCTION LIST-UNDEFINED-RELATIONS-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "CALL-LIST-UNDEFINED-RELATIONS"
     "(DEFUN (CALL-LIST-UNDEFINED-RELATIONS CONS) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Callable version of `list-undefined-relations' (which see).\" :PUBLIC? TRUE)"
     (CL:FUNCTION CALL-LIST-UNDEFINED-RELATIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "COMPLAIN-ABOUT-UNDECLARED-REFERENCE"
     "(DEFUN COMPLAIN-ABOUT-UNDECLARED-REFERENCE ((WAYWARDPROPOSITION PROPOSITION)))"
     (CL:FUNCTION COMPLAIN-ABOUT-UNDECLARED-REFERENCE) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-NAMED-DESCRIPTIONS-NEXT?"
     "(DEFUN (ALL-NAMED-DESCRIPTIONS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
     (CL:FUNCTION ALL-NAMED-DESCRIPTIONS-NEXT?) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-NAMED-DESCRIPTIONS"
     "(DEFUN (ALL-NAMED-DESCRIPTIONS (ITERATOR OF NAMED-DESCRIPTION)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all named descriptions visible from 'module'.
If 'local?', return only named descriptions interned in 'module'.
If 'module' is null, return all named descriptions interned everywhere.\" :PUBLIC? TRUE)"
     (CL:FUNCTION ALL-NAMED-DESCRIPTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-DESCRIPTIONS"
     "(DEFUN STARTUP-DESCRIPTIONS () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-DESCRIPTIONS) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-DESCRIPTIONS-LOGIC-STARTUP-DESCRIPTIONS)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-DESCRIPTIONS-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupDescriptions") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT FAKE-IO-VARIABLES VARIABLES-VECTOR (NEW VARIABLES-VECTOR :ARRAY-SIZE 0) :DOCUMENTATION \"Installed in a description with undetermined arity.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT SYSTEM-DEFINED-ARGUMENT-NAMES (CONS OF SYMBOL) (BQUOTE (?X1 ?X2 ?X3 ?X4 ?X5 ?X6 ?X7 ?X8 ?X9 ?X10 ?X11 ?X12 ?X13 ?X14 ?X15 ?X16 ?X17 ?X18 ?X19 ?X20 ?X21 ?X22 ?X23 ?X24 ?X25 ?X26 ?X27 ?X28 ?X29 ?X30 ?X31 ?X32 ?X33 ?X34 ?X35 ?X36 ?X37 ?X38 ?X39 ?X40 ?X41 ?X42 ?X43 ?X44 ?X45 ?X46 ?X47 ?X48 ?X49 ?X50 ?X51 ?X52 ?X53 ?X54 ?X55 ?X56 ?X57 ?X58 ?X59 ?X60 ?X61 ?X62 ?X63 ?X64 ?X65 ?X66 ?X67 ?X68 ?X69 ?X70 ?X71 ?X72 ?X73 ?X74 ?X75 ?X76 ?X77 ?X78 ?X79 ?X80 ?X81 ?X82 ?X83 ?X84 ?X85 ?X86 ?X87 ?X88 ?X89 ?X90 ?X91 ?X92 ?X93 ?X94 ?X95 ?X96 ?X97 ?X98 ?X99 ?X100)) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *LOGICVARIABLETABLE* (CONS OF SKOLEM) NULL :DOCUMENTATION \"Table mapping logic variable names to variables or skolems.
Used during construction of a proposition or description.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *VARIABLETYPEPROPOSITIONS* (CONS OF PROPOSITION) :DOCUMENTATION \"List of propositions extracted from parsing
a list of quantified, typed variables.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *UNIFY-PROPOSITIONS?* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EXTERNALVARIABLES* CONS :DOCUMENTATION \"Used by 'evaluate-DESCRIPTION-term' for collecting
a list of variables declared external to the description in which they
are referenced.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *RECURSIVEGETCOMPLEMENTARGUMENT* NAMED-DESCRIPTION NULL :DOCUMENTATION \"Used to prevent infinite looping.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *ADDEDNEWTYPE?* BOOLEAN FALSE :DOCUMENTATION \"Used by 'infer-variable-types'.\")")
    (REGISTER-NATIVE-NAME
     SYM-DESCRIPTIONS-LOGIC-LIST-UNDEFINED-RELATIONS
     KWD-DESCRIPTIONS-COMMON-LISP KWD-DESCRIPTIONS-FUNCTION))))
