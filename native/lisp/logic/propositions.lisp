;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; propositions.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PROPOSITIONS-INDEX NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-INSTANCES-INDEX NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-BACKLINKS-INDEX NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS-LIST NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DEPENDENT-ISA-PROPOSITIONS-LIST NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PREDICATE-PROPOSITIONS-TABLE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-BAD? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-HOME-CONTEXT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-VARIABLE-VALUE-INVERSE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-SURROGATE-VALUE-INVERSE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-OBJECT-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-OBJECT-ORIGINATED-PROPOSITIONS NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-CS-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-DELETED-OBJECT? NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-LOGIC-THING NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-SKOLEM NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SKOLEM-TYPE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SKOLEM-NAME NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-VARIABLE-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DEFINING-PROPOSITION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-BOUND-TO-OFFSET NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-VARIABLE-NAME NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-OBJECT-VECTOR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-ARGUMENTS-VECTOR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-VARIABLES-VECTOR NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDEX NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-FORWARD-GOAL NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-MASTER-RULE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-QUERY-BODY NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-INPUT-BINDINGS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CACHE-ID NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CONSEQUENT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDICES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DEFERRED-CONTRAPOSITIVES? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-INTERNAL-VARIABLES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-QUERY-PATTERNS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-RELATIVE-COMPLEMENT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-NATIVE-RELATION-BACK-POINTER NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-IO-VARIABLE-NAMES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-IO-VARIABLE-TYPES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-EXTENSION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PARTIAL-MATCH-SCORE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SET-OF-SUPPORT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-TIMESTAMP NULL)
(CL:DEFVAR KWD-PROPOSITIONS-UNKNOWN NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-TRUTH-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-POLARITY NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-STRENGTH NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-POSITIVE-SCORE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-PARTIAL-SUPPORT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-FACT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-AXIOM NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SCORE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-ID NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-ARGUMENT-SCORES NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-VARIABLE-TYPE? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SATELLITE-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-UNFASTENED? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-WEIGHT-DELTA NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SUPPORT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-KIND NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-TRUTH-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-ARGUMENTS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-OPERATOR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-RELATIONREF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PROPOSITION-ORIGINATED-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PROPOSITION-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-QUANTITY-LOGIC-WRAPPER NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-WRAPPER-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-FUNCTION-TERM NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-INTEGER-LOGIC-WRAPPER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-FLOAT-LOGIC-WRAPPER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-STRING-LOGIC-WRAPPER NULL)
(CL:DEFVAR KWD-PROPOSITIONS-AND NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-AND NULL)
(CL:DEFVAR KWD-PROPOSITIONS-OR NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-OR NULL)
(CL:DEFVAR KWD-PROPOSITIONS-NOT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-NOT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-FORALL NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-FORALL NULL)
(CL:DEFVAR KWD-PROPOSITIONS-EXISTS NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-EXISTS NULL)
(CL:DEFVAR KWD-PROPOSITIONS-EQUIVALENT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-EQUIVALENT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-FAIL NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-FAIL NULL)
(CL:DEFVAR KWD-PROPOSITIONS-COLLECT-INTO NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-COLLECT-INTO NULL)
(CL:DEFVAR KWD-PROPOSITIONS-IMPLIES NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-FUNCTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-PREDICATE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-ISA NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DESCRIPTIVE? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-CODE-ONLY? NULL)
(CL:DEFVAR KWD-PROPOSITIONS-ERROR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-PROPOSITIONS-INTERNAL NULL)
(CL:DEFVAR KWD-PROPOSITIONS-PAGING NULL)
(CL:DEFVAR KWD-PROPOSITIONS-CONTEXT-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-INSTANCES-INTERNAL NULL)
(CL:DEFVAR KWD-PROPOSITIONS-CONTEXT-INSTANCES NULL)
(CL:DEFVAR KWD-PROPOSITIONS-UPDATE-PROPOSITION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-EXECUTE-QUERY NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-BOTTOM NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-LITERAL NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-F-LOGICAL-SUBTYPE-OF-LITERAL?-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-CLASS NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-BOOLEAN NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-VARIABLE-ARITY NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-COLLECTION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION-COMPUTATION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-THING NULL)
(CL:DEFVAR KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-DESCRIPTION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-DEVELOPMENT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-WARNING NULL)
(CL:DEFVAR KWD-PROPOSITIONS-RETRACT-TRUE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-UPDATE-PROPOSITION-DEMON NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-OBJECT-STORE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-FUNCTION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-ISA NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-TRUE-DEMON NULL)
(CL:DEFVAR KWD-PROPOSITIONS-PREDICATE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-FALSE-DEMON NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-UNKNOWN-DEMON NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-MASTER-PROPOSITION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-ASSERT-TRUE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-PRESUME-TRUE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-ASSERT-FALSE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-PRESUME-FALSE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-RETRACT-FALSE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-ASSERT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-RETRACT-INCONSISTENT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-RETRACT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-CONCEIVE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-HIDDEN-RELATION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-HIDDEN-INSTANCE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-KB-UPDATE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-META-KB-UPDATE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-STORAGE-SLOT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-SURROGATE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-RELATION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-TRUE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-STRICT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-FALSE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-DEFAULT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-INCONSISTENT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-META-INFERENCE-CACHE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-IOTA? NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-CONCEPT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-SET NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-FUNCTION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-SET NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-SLOT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-INTERVAL-CACHE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB->= NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CONFLICTING-DEFAULT-VALUES NULL)
(CL:DEFVAR KWD-PROPOSITIONS-CONSTANT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-TRUE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-FALSE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SETOFALL NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-THE-ONLY NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-KAPPA NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CREATE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-CONS NULL)
(CL:DEFVAR KWD-PROPOSITIONS-INTENSIONAL-ASSERTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-? NULL)
(CL:DEFVAR KWD-PROPOSITIONS-COMMON-LISP NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-CLASS-EXTENSION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SUBRELATION-LINK? NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-MEMBER-OF NULL)
(CL:DEFVAR KWD-PROPOSITIONS-DISABLED NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-ANNOTATIONS NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-STRING-WRAPPER NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CONSTANT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-TRUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-FALSE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-SYMBOL NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-= NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-AND NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-OR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-NOT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PL-KERNEL-KB-MEMBER-OF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-IMPLIES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-EXISTS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-FORALL NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-FAIL NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-COLLECT-INTO NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-ABOUT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR KWD-PROPOSITIONS-DIRECTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-FORWARD-ONLY? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-BACKWARD-ONLY? NULL)
(CL:DEFVAR KWD-PROPOSITIONS-WEIGHT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-WEIGHT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-CONFIDENCE-LEVEL NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-SETOF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-LISTOF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-EQUIVALENT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-TABLE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-POLYMORPHIC NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PL-KERNEL-KB-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PL-KERNEL-KB-CUT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-VALUE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-QUANTITY NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-DATE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-FLOAT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-INTEGER NULL)
(CL:DEFVAR KWD-PROPOSITIONS-AUTOMATICALLY-FIX-TYPE-VIOLATIONS NULL)
(CL:DEFVAR KWD-PROPOSITIONS-POST-TYPE-VIOLATIONS NULL)
(CL:DEFVAR KWD-PROPOSITIONS-IGNORE-TYPE-VIOLATIONS NULL)
(CL:DEFVAR KWD-PROPOSITIONS-REPORT-TYPE-VIOLATIONS NULL)
(CL:DEFVAR KWD-PROPOSITIONS-SIGNAL-TYPE-VIOLATIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-ASSERTED-BY-TYPE-CHECKER? NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-CHECK-TYPES-RECORD NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PARENT-PROPOSITION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PARENT-DESCRIPTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-MODULE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-MEDIUM NULL)
(CL:DEFVAR KWD-PROPOSITIONS-REALISTIC NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-SETOF NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-TOTAL NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-LISTOF NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-LIST NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-LAMBDA NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PL-KERNEL-KB-SETOF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PL-KERNEL-KB-LISTOF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-BAGOF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-ASSERT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PRESUME NULL)
(CL:DEFVAR KWD-PROPOSITIONS-CPP NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-RETRACT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DENY NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-CONCEIVE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-UNASSERT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-DELETED NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DESTROY NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-MODULE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-INTRODUCE-MODULE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CLEAR-LOGIC-MODULE-HOOK NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CLEAR-INSTANCES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-MONOTONIC? NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-WORLD NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DESTROY-LOGIC-CONTEXT-HOOK NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-CLEARABLE? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-PROTECT-SURROGATES? NULL)
(CL:DEFVAR KWD-PROPOSITIONS-PREORDER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-MUTABLE-STRING-WRAPPER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-CONTEXT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-COMPUTED-PROCEDURE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-NUMBER-WRAPPER NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-STARTUP-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *STELLA-MODULE* *PL-ANONYMOUS-MODULE*
  *DEFINE-MODULE-HOOKS* *CLEAR-MODULE-HOOKS* *DESTROY-CONTEXT-HOOKS*
  *REDEFINE-RELATION-HOOKS* *REVERSEPOLARITY?*
  *INHIBITOBJECTFINALIZATION?* *DESCRIPTIONUNDERCONSTRUCTION*
  *LOGICVARIABLETABLE* *INTEGER-MSB-MASK* STANDARD-ERROR
  *TERMUNDERCONSTRUCTION* *DONTUSEDEFAULTKNOWLEDGE?* *QUERYITERATOR*
  *SUPPRESSNONLOGICOBJECTWARNING?* TRUE-TRUTH-VALUE FALSE-TRUTH-VALUE
  TRUE-PROPOSITION FALSE-PROPOSITION INCONSISTENT-TRUTH-VALUE
  DEFAULT-TRUE-TRUTH-VALUE DEFAULT-FALSE-TRUTH-VALUE
  *DEFERINGDEFAULTFORWARDINFERENCES?* STANDARD-OUTPUT
  *POWERLOOM-EXECUTION-MODE* STANDARD-WARNING *MEMOIZATION-ENABLED?*
  MEMOIZED-NULL-VALUE *INVISIBLEASSERTION?* EOL NULL-STRING-WRAPPER
  *PRINTREADABLY?* NULL-FLOAT-WRAPPER NIL-NON-PAGING-INDEX NULL-FLOAT
  NIL-LIST NULL-INTEGER *LOADINGREGENERABLEOBJECTS?* *CONTEXT*
  TRUE-WRAPPER FALSE-WRAPPER NIL *MODULE*))

;;; (DEFCLASS BACKLINKS-INDEX ...)

(CL:DEFCLASS BACKLINKS-INDEX (STANDARD-OBJECT)
  ((DEPENDENT-PROPOSITIONS-LIST :ALLOCATION :INSTANCE :ACCESSOR
    %DEPENDENT-PROPOSITIONS-LIST)
   (DEPENDENT-ISA-PROPOSITIONS-LIST :ALLOCATION :INSTANCE :ACCESSOR
    %DEPENDENT-ISA-PROPOSITIONS-LIST)
   (PREDICATE-PROPOSITIONS-TABLE :ALLOCATION :INSTANCE :ACCESSOR
    %PREDICATE-PROPOSITIONS-TABLE))
  (:DOCUMENTATION
   "Contains several types of indices pointing at dependent propositions."))

(CL:DEFUN NEW-BACKLINKS-INDEX ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE BACKLINKS-INDEX)))
   (CL:SETF (%PREDICATE-PROPOSITIONS-TABLE SELF) NULL)
   (CL:SETF (%DEPENDENT-ISA-PROPOSITIONS-LIST SELF) NULL)
   (CL:SETF (%DEPENDENT-PROPOSITIONS-LIST SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF BACKLINKS-INDEX))
  SGT-PROPOSITIONS-LOGIC-BACKLINKS-INDEX)

(CL:DEFUN ACCESS-BACKLINKS-INDEX-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS-LIST)
    (CL:IF SETVALUE?
     (CL:SETF (%DEPENDENT-PROPOSITIONS-LIST SELF) VALUE)
     (CL:SETQ VALUE (%DEPENDENT-PROPOSITIONS-LIST SELF))))
   ((CL:EQ SLOTNAME
     SYM-PROPOSITIONS-LOGIC-DEPENDENT-ISA-PROPOSITIONS-LIST)
    (CL:IF SETVALUE?
     (CL:SETF (%DEPENDENT-ISA-PROPOSITIONS-LIST SELF) VALUE)
     (CL:SETQ VALUE (%DEPENDENT-ISA-PROPOSITIONS-LIST SELF))))
   ((CL:EQ SLOTNAME
     SYM-PROPOSITIONS-LOGIC-PREDICATE-PROPOSITIONS-TABLE)
    (CL:IF SETVALUE?
     (CL:SETF (%PREDICATE-PROPOSITIONS-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%PREDICATE-PROPOSITIONS-TABLE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFCLASS LOGIC-OBJECT ...)

(CL:DEFCLASS LOGIC-OBJECT (CONTEXT-SENSITIVE-OBJECT)
  ((VARIABLE-VALUE-INVERSE :ALLOCATION :INSTANCE :ACCESSOR
    %VARIABLE-VALUE-INVERSE)
   (SURROGATE-VALUE-INVERSE :ALLOCATION :INSTANCE :ACCESSOR
    %SURROGATE-VALUE-INVERSE)
   (DYNAMIC-SLOTS :ALLOCATION :INSTANCE :ACCESSOR %DYNAMIC-SLOTS)
   (DEPENDENT-PROPOSITIONS-INDEX :ALLOCATION :INSTANCE :ACCESSOR
    %DEPENDENT-PROPOSITIONS-INDEX))
  (:DOCUMENTATION
   "Object with propositions, and possibly a variable value."))

(CL:DEFUN NEW-LOGIC-OBJECT ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE LOGIC-OBJECT)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL)
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%HOME-CONTEXT SELF) *MODULE*) (LOG-LOGIC-OBJECT SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LOGIC-OBJECT))
  SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)

(CL:DEFMETHOD VARIABLE-VALUE-INVERSE ((SELF LOGIC-OBJECT))
  (CL:LET*
   ((ANSWER
     (ACCESS-IN-CONTEXT (%VARIABLE-VALUE-INVERSE SELF)
      (%HOME-CONTEXT SELF) CL:NIL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL ANSWER)))

(CL:DEFMETHOD BAD? ((SELF LOGIC-OBJECT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-STELLA-BAD? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:IF CL:NIL TRUE-WRAPPER FALSE-WRAPPER)
    ANSWER)))

(CL:DEFUN ACCESS-LOGIC-OBJECT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-HOME-CONTEXT)
    (CL:IF SETVALUE? (CL:SETF (%HOME-CONTEXT SELF) VALUE)
     (CL:SETQ VALUE (%HOME-CONTEXT SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-VARIABLE-VALUE-INVERSE)
    (CL:IF SETVALUE?
     (CL:LET*
      ((OBJECT-000 SELF) (VALUE-000 VALUE)
       (OLD-VALUE-000 (%VARIABLE-VALUE-INVERSE OBJECT-000))
       (NEW-VALUE-000
        (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
         (%HOME-CONTEXT OBJECT-000) CL:NIL)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-000) NEW-VALUE-000)))
     (CL:SETQ VALUE (VARIABLE-VALUE-INVERSE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-SURROGATE-VALUE-INVERSE)
    (CL:IF SETVALUE? (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) VALUE)
     (CL:SETQ VALUE (%SURROGATE-VALUE-INVERSE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-OBJECT-STRINGIFIED-SOURCE)
    (CL:IF SETVALUE?
     (STRINGIFIED-SOURCE-SETTER SELF (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (STRINGIFIED-SOURCE SELF)))))
   ((CL:EQ SLOTNAME
     SYM-PROPOSITIONS-LOGIC-OBJECT-ORIGINATED-PROPOSITIONS)
    (CL:IF SETVALUE? (ORIGINATED-PROPOSITIONS-SETTER SELF VALUE)
     (CL:SETQ VALUE (ORIGINATED-PROPOSITIONS SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

(CL:DEFMETHOD DELETED? ((SELF LOGIC-OBJECT))
  (CL:LET*
   ((DELETED?
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-STELLA-DELETED-OBJECT? NULL)))
   (CL:IF (CL:NOT (CL:EQ DELETED? NULL))
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN DELETED?) CL:NIL)))

(CL:DEFMETHOD DELETED?-SETTER ((SELF LOGIC-OBJECT) VALUE)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-PROPOSITIONS-STELLA-DELETED-OBJECT?
   (CL:IF VALUE TRUE-WRAPPER FALSE-WRAPPER) NULL)
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF LOGIC-OBJECT) STREAM)
  (PRINT-TOP-LEVEL-OBJECT SELF STREAM))

;;; (DEFCLASS LOGIC-THING ...)

(CL:DEFCLASS LOGIC-THING (THING)
  ()
  (:DOCUMENTATION "A subclass of THING so we can add methods to it in
the PowerLoom LOGIC module."))

(CL:DEFUN NEW-LOGIC-THING ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE LOGIC-THING)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LOGIC-THING))
  SGT-PROPOSITIONS-LOGIC-LOGIC-THING)

(CL:DEFUN ACCESS-LOGIC-THING-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFUN LOG-LOGIC-OBJECT ...)

(CL:DEFUN LOG-LOGIC-OBJECT (SELF)
  (CL:WHEN
   (CL:OR (DESCRIPTION-MODE?)
    (ISA? SELF SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE))
   (CL:RETURN-FROM LOG-LOGIC-OBJECT))
  (CL:WHEN (CL:NOT *LOADINGREGENERABLEOBJECTS?*)
   (PUSH (LOCALLY-CONCEIVED-INSTANCES *CONTEXT*) SELF)))

;;; (DEFCLASS SKOLEM ...)

(CL:DEFCLASS SKOLEM (LOGIC-OBJECT)
  ((SKOLEM-TYPE :ALLOCATION :INSTANCE :ACCESSOR %SKOLEM-TYPE)
   (SKOLEM-NAME :ALLOCATION :INSTANCE :ACCESSOR %SKOLEM-NAME)
   (VARIABLE-VALUE :ALLOCATION :INSTANCE :ACCESSOR %VARIABLE-VALUE)
   (DEFINING-PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR
    %DEFINING-PROPOSITION))
  (:DOCUMENTATION
   "Object whose identity and type are not fixed at creation time.
Potentially unifiable with any other object."))

(CL:DEFUN NEW-SKOLEM ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SKOLEM)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL)
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (%DEFINING-PROPOSITION SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE SELF) NULL)
   (CL:SETF (%SKOLEM-NAME SELF) NULL)
   (CL:SETF (%SKOLEM-TYPE SELF) NULL) (LOG-LOGIC-OBJECT SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SKOLEM))
  SGT-PROPOSITIONS-LOGIC-SKOLEM)

(CL:DEFUN ACCESS-SKOLEM-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-SKOLEM-TYPE)
    (CL:IF SETVALUE? (CL:SETF (%SKOLEM-TYPE SELF) VALUE)
     (CL:SETQ VALUE (%SKOLEM-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-SKOLEM-NAME)
    (CL:IF SETVALUE? (CL:SETF (%SKOLEM-NAME SELF) VALUE)
     (CL:SETQ VALUE (%SKOLEM-NAME SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-VARIABLE-VALUE)
    (CL:IF SETVALUE?
     (CL:LET*
      ((OBJECT-000 SELF) (VALUE-000 VALUE)
       (OLD-VALUE-000 (%VARIABLE-VALUE OBJECT-000))
       (NEW-VALUE-000
        (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
         (%HOME-CONTEXT OBJECT-000) CL:NIL)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%VARIABLE-VALUE OBJECT-000) NEW-VALUE-000)))
     (CL:SETQ VALUE
      (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SELF) (%HOME-CONTEXT SELF)
       CL:NIL))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-DEFINING-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%DEFINING-PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%DEFINING-PROPOSITION SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFCLASS PATTERN-VARIABLE ...)

(CL:DEFCLASS PATTERN-VARIABLE (SKOLEM)
  ((BOUND-TO-OFFSET :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %BOUND-TO-OFFSET))
  (:DOCUMENTATION "A variable in a logical expression."))

(CL:DEFUN NEW-PATTERN-VARIABLE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PATTERN-VARIABLE)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL)
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (%DEFINING-PROPOSITION SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE SELF) NULL)
   (CL:SETF (%SKOLEM-TYPE SELF) NULL)
   (CL:SETF (%SKOLEM-NAME SELF) NULL)
   (CL:SETF (%BOUND-TO-OFFSET SELF) NULL-INTEGER)
   (LOG-LOGIC-OBJECT SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PATTERN-VARIABLE))
  SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)

(CL:DEFUN ACCESS-PATTERN-VARIABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-BOUND-TO-OFFSET)
    (CL:IF SETVALUE?
     (CL:SETF (%BOUND-TO-OFFSET SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%BOUND-TO-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-VARIABLE-NAME)
    (CL:IF SETVALUE? (CL:SETF (%SKOLEM-NAME SELF) VALUE)
     (CL:SETQ VALUE (%SKOLEM-NAME SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFCONSTANT ZERO-VARIABLES-VECTOR ...)

(CL:DEFVAR ZERO-VARIABLES-VECTOR NULL
  "Save space by structure-sharing zero-length variable vectors.")

;;; (DEFCLASS FORWARD-CHAINING-INDEX ...)

(CL:DEFCLASS FORWARD-CHAINING-INDEX (STANDARD-OBJECT)
  ((FORWARD-GOAL :ALLOCATION :INSTANCE :ACCESSOR %FORWARD-GOAL)
   (MASTER-RULE :ALLOCATION :INSTANCE :ACCESSOR %MASTER-RULE)
   (IO-VARIABLES :ALLOCATION :INSTANCE :ACCESSOR %IO-VARIABLES)
   (QUERY-BODY :ALLOCATION :INSTANCE :ACCESSOR %QUERY-BODY)
   (INPUT-BINDINGS :ALLOCATION :INSTANCE :ACCESSOR %INPUT-BINDINGS)
   (CACHE-ID :ALLOCATION :INSTANCE :ACCESSOR %CACHE-ID)
   (CONSEQUENT :ALLOCATION :INSTANCE :ACCESSOR %CONSEQUENT)))

(CL:DEFUN NEW-FORWARD-CHAINING-INDEX ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE FORWARD-CHAINING-INDEX)))
   (CL:SETF (%CONSEQUENT SELF) NULL) (CL:SETF (%CACHE-ID SELF) NULL)
   (CL:SETF (%INPUT-BINDINGS SELF) NULL)
   (CL:SETF (%QUERY-BODY SELF) NULL)
   (CL:SETF (%IO-VARIABLES SELF) NULL)
   (CL:SETF (%MASTER-RULE SELF) NULL)
   (CL:SETF (%FORWARD-GOAL SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FORWARD-CHAINING-INDEX))
  SGT-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDEX)

(CL:DEFUN ACCESS-FORWARD-CHAINING-INDEX-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-FORWARD-GOAL)
    (CL:IF SETVALUE? (CL:SETF (%FORWARD-GOAL SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-GOAL SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-MASTER-RULE)
    (CL:IF SETVALUE? (CL:SETF (%MASTER-RULE SELF) VALUE)
     (CL:SETQ VALUE (%MASTER-RULE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-IO-VARIABLES)
    (CL:IF SETVALUE? (CL:SETF (%IO-VARIABLES SELF) VALUE)
     (CL:SETQ VALUE (%IO-VARIABLES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-QUERY-BODY)
    (CL:IF SETVALUE? (CL:SETF (%QUERY-BODY SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-BODY SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-INPUT-BINDINGS)
    (CL:IF SETVALUE? (CL:SETF (%INPUT-BINDINGS SELF) VALUE)
     (CL:SETQ VALUE (%INPUT-BINDINGS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-CACHE-ID)
    (CL:IF SETVALUE? (CL:SETF (%CACHE-ID SELF) VALUE)
     (CL:SETQ VALUE (%CACHE-ID SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-CONSEQUENT)
    (CL:IF SETVALUE? (CL:SETF (%CONSEQUENT SELF) VALUE)
     (CL:SETQ VALUE (%CONSEQUENT SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFCLASS DESCRIPTION ...)

(CL:DEFCLASS DESCRIPTION (LOGIC-OBJECT)
  ((PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR %PROPOSITION)
   (IO-VARIABLES :ALLOCATION :INSTANCE :ACCESSOR %IO-VARIABLES)
   (INTERNAL-VARIABLES :DOCUMENTATION
    "The set of internally quantified variables besides the
descriptions's IO variables.  This set includes any top-level implicit
existential variables plus any variables introduced by some nested quantifier.
IMPORTANT: therefore, a description's internal variables are not necessarily
equivalent to its top-level implicit existential variables."
    :ALLOCATION :INSTANCE :ACCESSOR %INTERNAL-VARIABLES)
   (QUERY-PATTERNS :ALLOCATION :INSTANCE :ACCESSOR %QUERY-PATTERNS)))

(CL:DEFUN NEW-DESCRIPTION ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE DESCRIPTION)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL)
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (%QUERY-PATTERNS SELF) NULL)
   (CL:SETF (%INTERNAL-VARIABLES SELF) ZERO-VARIABLES-VECTOR)
   (CL:SETF (%IO-VARIABLES SELF) NULL)
   (CL:SETF (%PROPOSITION SELF) NULL) (LOG-LOGIC-OBJECT SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DESCRIPTION))
  SGT-PROPOSITIONS-LOGIC-DESCRIPTION)

(CL:DEFMETHOD NATIVE-RELATION ((SELF DESCRIPTION))
  NULL)

(CL:DEFMETHOD FORWARD-CHAINING-INDICES ((SELF DESCRIPTION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDICES NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

(CL:DEFMETHOD DEFERRED-CONTRAPOSITIVES? ((SELF DESCRIPTION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-DEFERRED-CONTRAPOSITIVES? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:IF CL:NIL TRUE-WRAPPER FALSE-WRAPPER)
    ANSWER)))

(CL:DEFUN ACCESS-DESCRIPTION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-IO-VARIABLES)
    (CL:IF SETVALUE? (CL:SETF (%IO-VARIABLES SELF) VALUE)
     (CL:SETQ VALUE (%IO-VARIABLES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-INTERNAL-VARIABLES)
    (CL:IF SETVALUE? (CL:SETF (%INTERNAL-VARIABLES SELF) VALUE)
     (CL:SETQ VALUE (%INTERNAL-VARIABLES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-QUERY-PATTERNS)
    (CL:IF SETVALUE? (CL:SETF (%QUERY-PATTERNS SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-PATTERNS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDICES)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDICES VALUE NULL)
     (CL:SETQ VALUE (FORWARD-CHAINING-INDICES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-DEFERRED-CONTRAPOSITIVES?)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-DEFERRED-CONTRAPOSITIVES? VALUE NULL)
     (CL:SETQ VALUE (DEFERRED-CONTRAPOSITIVES? SELF))))
   (CL:T
    (CL:COND
     ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-RELATIVE-COMPLEMENT)
      (CL:SETQ SLOTNAME SYM-PROPOSITIONS-LOGIC-COMPLEMENT-DESCRIPTION))
     (CL:T))
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFCLASS NAMED-DESCRIPTION ...)

(CL:DEFCLASS NAMED-DESCRIPTION (DESCRIPTION)
  ((IO-VARIABLE-NAMES :ALLOCATION :INSTANCE :ACCESSOR
    %IO-VARIABLE-NAMES)
   (IO-VARIABLE-TYPES :ALLOCATION :INSTANCE :ACCESSOR
    %IO-VARIABLE-TYPES)
   (EXTENSION :ALLOCATION :INSTANCE :ACCESSOR %EXTENSION)
   (OBJECT-STRINGIFIED-SOURCE :TYPE CL:SIMPLE-STRING :INITFORM
    STELLA::NULL-STRING :ALLOCATION :INSTANCE :ACCESSOR
    %OBJECT-STRINGIFIED-SOURCE)
   (OBJECT-ORIGINATED-PROPOSITIONS :DOCUMENTATION
    "List of propositions generated by the definition of
this description." :ALLOCATION :INSTANCE :ACCESSOR
    %OBJECT-ORIGINATED-PROPOSITIONS)))

(CL:DEFUN NEW-NAMED-DESCRIPTION ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE NAMED-DESCRIPTION)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL)
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (%QUERY-PATTERNS SELF) NULL)
   (CL:SETF (%INTERNAL-VARIABLES SELF) ZERO-VARIABLES-VECTOR)
   (CL:SETF (%IO-VARIABLES SELF) NULL)
   (CL:SETF (%PROPOSITION SELF) NULL)
   (CL:SETF (%OBJECT-ORIGINATED-PROPOSITIONS SELF) NULL)
   (CL:SETF (%OBJECT-STRINGIFIED-SOURCE SELF) STELLA::NULL-STRING)
   (CL:SETF (%EXTENSION SELF) NULL)
   (CL:SETF (%IO-VARIABLE-TYPES SELF) NULL)
   (CL:SETF (%IO-VARIABLE-NAMES SELF) NULL) (LOG-LOGIC-OBJECT SELF)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF NAMED-DESCRIPTION))
  SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)

(CL:DEFMETHOD NATIVE-RELATION ((SELF NAMED-DESCRIPTION))
  (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-PROPOSITIONS-LOGIC-NATIVE-RELATION-BACK-POINTER NULL))

(CL:DEFMETHOD NATIVE-RELATION-SETTER ((SELF NAMED-DESCRIPTION) VALUE)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-PROPOSITIONS-LOGIC-NATIVE-RELATION-BACK-POINTER VALUE NULL))

(CL:DEFUN ACCESS-NAMED-DESCRIPTION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-IO-VARIABLE-NAMES)
    (CL:IF SETVALUE? (CL:SETF (%IO-VARIABLE-NAMES SELF) VALUE)
     (CL:SETQ VALUE (%IO-VARIABLE-NAMES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-IO-VARIABLE-TYPES)
    (CL:IF SETVALUE? (CL:SETF (%IO-VARIABLE-TYPES SELF) VALUE)
     (CL:SETQ VALUE (%IO-VARIABLE-TYPES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-EXTENSION)
    (CL:IF SETVALUE? (CL:SETF (%EXTENSION SELF) VALUE)
     (CL:SETQ VALUE (%EXTENSION SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-OBJECT-STRINGIFIED-SOURCE)
    (CL:IF SETVALUE?
     (STRINGIFIED-SOURCE-SETTER SELF (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (STRINGIFIED-SOURCE SELF)))))
   ((CL:EQ SLOTNAME
     SYM-PROPOSITIONS-LOGIC-OBJECT-ORIGINATED-PROPOSITIONS)
    (CL:IF SETVALUE? (ORIGINATED-PROPOSITIONS-SETTER SELF VALUE)
     (CL:SETQ VALUE (ORIGINATED-PROPOSITIONS SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFCLASS TRUTH-VALUE ...)

(CL:DEFCLASS TRUTH-VALUE (LOGIC-OBJECT)
  ((POLARITY :DOCUMENTATION
    "One of :TRUE, :FALSE, :UNKNOWN or :INCONSISTENT." :ALLOCATION
    :INSTANCE :ACCESSOR %POLARITY)
   (STRENGTH :DOCUMENTATION "Either NULL, :STRICT or :DEFAULT."
    :ALLOCATION :INSTANCE :ACCESSOR %STRENGTH)
   (POSITIVE-SCORE :TYPE CL:DOUBLE-FLOAT :INITFORM NULL-FLOAT
    :ALLOCATION :INSTANCE :ACCESSOR %POSITIVE-SCORE)))

(CL:DEFUN NEW-TRUTH-VALUE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRUTH-VALUE)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL)
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (%POSITIVE-SCORE SELF) 0.0d0)
   (CL:SETF (%STRENGTH SELF) NULL)
   (CL:SETF (%POLARITY SELF) KWD-PROPOSITIONS-UNKNOWN)
   (LOG-LOGIC-OBJECT SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRUTH-VALUE))
  SGT-PROPOSITIONS-LOGIC-TRUTH-VALUE)

(CL:DEFUN ACCESS-TRUTH-VALUE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-POLARITY)
    (CL:IF SETVALUE? (CL:SETF (%POLARITY SELF) VALUE)
     (CL:SETQ VALUE (%POLARITY SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-STRENGTH)
    (CL:IF SETVALUE? (CL:SETF (%STRENGTH SELF) VALUE)
     (CL:SETQ VALUE (%STRENGTH SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-POSITIVE-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%POSITIVE-SCORE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%POSITIVE-SCORE SELF)))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFCLASS PARTIAL-SUPPORT ...)

(CL:DEFCLASS PARTIAL-SUPPORT (STANDARD-OBJECT)
  ((FACT :ALLOCATION :INSTANCE :ACCESSOR %FACT)
   (AXIOM :ALLOCATION :INSTANCE :ACCESSOR %AXIOM)
   (SCORE :TYPE CL:DOUBLE-FLOAT :INITFORM NULL-FLOAT :ALLOCATION
    :INSTANCE :ACCESSOR %SCORE)
   (ID :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %ID)
   (ARGUMENT-SCORES :ALLOCATION :INSTANCE :ACCESSOR %ARGUMENT-SCORES)))

(CL:DEFUN NEW-PARTIAL-SUPPORT ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PARTIAL-SUPPORT)))
   (CL:SETF (%ARGUMENT-SCORES SELF) NULL)
   (CL:SETF (%ID SELF) NULL-INTEGER) (CL:SETF (%SCORE SELF) NULL-FLOAT)
   (CL:SETF (%AXIOM SELF) NULL) (CL:SETF (%FACT SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PARTIAL-SUPPORT))
  SGT-PROPOSITIONS-LOGIC-PARTIAL-SUPPORT)

(CL:DEFUN ACCESS-PARTIAL-SUPPORT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-FACT)
    (CL:IF SETVALUE? (CL:SETF (%FACT SELF) VALUE)
     (CL:SETQ VALUE (%FACT SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-AXIOM)
    (CL:IF SETVALUE? (CL:SETF (%AXIOM SELF) VALUE)
     (CL:SETQ VALUE (%AXIOM SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-SCORE)
    (CL:IF SETVALUE? (CL:SETF (%SCORE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-ID)
    (CL:IF SETVALUE? (CL:SETF (%ID SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%ID SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-ARGUMENT-SCORES)
    (CL:IF SETVALUE? (CL:SETF (%ARGUMENT-SCORES SELF) VALUE)
     (CL:SETQ VALUE (%ARGUMENT-SCORES SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFGLOBAL *PARTIAL-SUPPORT-COUNTER* ...)

(CL:DEFVAR *PARTIAL-SUPPORT-COUNTER* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *PARTIAL-SUPPORT-COUNTER*))

;;; (DEFCLASS PROPOSITION ...)

(CL:DEFCLASS PROPOSITION (CONTEXT-SENSITIVE-OBJECT)
  ((KIND :ALLOCATION :INSTANCE :ACCESSOR %KIND)
   (TRUTH-VALUE :ALLOCATION :INSTANCE :ACCESSOR %TRUTH-VALUE)
   (ARGUMENTS :ALLOCATION :INSTANCE :ACCESSOR %ARGUMENTS)
   (OPERATOR :ALLOCATION :INSTANCE :ACCESSOR %OPERATOR)
   (DEPENDENT-PROPOSITIONS :ALLOCATION :INSTANCE :ACCESSOR
    %DEPENDENT-PROPOSITIONS)
   (DYNAMIC-SLOTS :ALLOCATION :INSTANCE :ACCESSOR %DYNAMIC-SLOTS))
  (:DOCUMENTATION ""))

(CL:DEFUN NEW-PROPOSITION ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PROPOSITION)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%DEPENDENT-PROPOSITIONS SELF) NIL-NON-PAGING-INDEX)
   (CL:SETF (%OPERATOR SELF) NULL) (CL:SETF (%ARGUMENTS SELF) NULL)
   (CL:SETF (%TRUTH-VALUE SELF) NULL) (CL:SETF (%KIND SELF) NULL)
   (CL:SETF (%HOME-CONTEXT SELF) *MODULE*) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PROPOSITION))
  SGT-PROPOSITIONS-LOGIC-PROPOSITION)

(CL:DEFMETHOD VARIABLE-TYPE? ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-VARIABLE-TYPE? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:IF CL:NIL TRUE-WRAPPER FALSE-WRAPPER)
    ANSWER)))

(CL:DEFMETHOD SATELLITE-PROPOSITIONS ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-SATELLITE-PROPOSITIONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

(CL:DEFMETHOD UNFASTENED? ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-UNFASTENED? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:IF CL:NIL TRUE-WRAPPER FALSE-WRAPPER)
    ANSWER)))

(CL:DEFMETHOD WEIGHT-DELTA ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-PROPOSITIONS-LOGIC-WEIGHT-DELTA NULL-FLOAT-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT ANSWER))
   (CL:IF (CL:= ANSWER NULL-FLOAT) 0.0d0 ANSWER)))

(CL:DEFMETHOD SUPPORT ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-SUPPORT NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL ANSWER)))

(CL:DEFMETHOD BAD? ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-STELLA-BAD? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:IF CL:NIL TRUE-WRAPPER FALSE-WRAPPER)
    ANSWER)))

(CL:DEFUN ACCESS-PROPOSITION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-HOME-CONTEXT)
    (CL:IF SETVALUE? (CL:SETF (%HOME-CONTEXT SELF) VALUE)
     (CL:SETQ VALUE (%HOME-CONTEXT SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-KIND)
    (CL:IF SETVALUE? (CL:SETF (%KIND SELF) VALUE)
     (CL:SETQ VALUE (%KIND SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-TRUTH-VALUE)
    (CL:IF SETVALUE?
     (CL:LET*
      ((OBJECT-000 SELF) (VALUE-000 VALUE)
       (OLD-VALUE-000 (%TRUTH-VALUE OBJECT-000))
       (NEW-VALUE-000
        (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
         (%HOME-CONTEXT OBJECT-000) CL:NIL)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%TRUTH-VALUE OBJECT-000) NEW-VALUE-000)))
     (CL:SETQ VALUE
      (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF)
       CL:NIL))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-ARGUMENTS)
    (CL:IF SETVALUE? (CL:SETF (%ARGUMENTS SELF) VALUE)
     (CL:SETQ VALUE (%ARGUMENTS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-OPERATOR)
    (CL:IF SETVALUE? (CL:SETF (%OPERATOR SELF) VALUE)
     (CL:SETQ VALUE (%OPERATOR SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-RELATIONREF)
    (CL:IF SETVALUE? (CL:SETF (%OPERATOR SELF) VALUE)
     (CL:SETQ VALUE (%OPERATOR SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS)
    (CL:IF SETVALUE? (CL:SETF (%DEPENDENT-PROPOSITIONS SELF) VALUE)
     (CL:SETQ VALUE (%DEPENDENT-PROPOSITIONS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-VARIABLE-TYPE?)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-VARIABLE-TYPE? VALUE NULL)
     (CL:SETQ VALUE (VARIABLE-TYPE? SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-SATELLITE-PROPOSITIONS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-SATELLITE-PROPOSITIONS VALUE NULL)
     (CL:SETQ VALUE (SATELLITE-PROPOSITIONS SELF))))
   ((CL:EQ SLOTNAME
     SYM-PROPOSITIONS-LOGIC-PROPOSITION-ORIGINATED-PROPOSITIONS)
    (CL:IF SETVALUE? (ORIGINATED-PROPOSITIONS-SETTER SELF VALUE)
     (CL:SETQ VALUE (ORIGINATED-PROPOSITIONS SELF))))
   ((CL:EQ SLOTNAME
     SYM-PROPOSITIONS-LOGIC-PROPOSITION-STRINGIFIED-SOURCE)
    (CL:IF SETVALUE?
     (STRINGIFIED-SOURCE-SETTER SELF (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (STRINGIFIED-SOURCE SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-UNFASTENED?)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-UNFASTENED? VALUE NULL)
     (CL:SETQ VALUE (UNFASTENED? SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-WEIGHT-DELTA)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-WEIGHT-DELTA
      (WRAP-FLOAT (%WRAPPER-VALUE VALUE)) NULL-FLOAT-WRAPPER)
     (CL:SETQ VALUE (WRAP-FLOAT (WEIGHT-DELTA SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-SUPPORT)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-SUPPORT VALUE NULL)
     (CL:SETQ VALUE (SUPPORT SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF PROPOSITION) STREAM)
  (PRINT-TOP-LEVEL-OBJECT SELF STREAM))

;;; (DEFCLASS QUANTITY-LOGIC-WRAPPER ...)

(CL:DEFCLASS QUANTITY-LOGIC-WRAPPER (LOGIC-THING)
  ((WRAPPER-VALUE :ALLOCATION :INSTANCE :ACCESSOR %WRAPPER-VALUE)
   (FUNCTION-TERM :ALLOCATION :INSTANCE :ACCESSOR %FUNCTION-TERM)))

(CL:DEFUN NEW-QUANTITY-LOGIC-WRAPPER (WRAPPER-VALUE)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE QUANTITY-LOGIC-WRAPPER)))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%FUNCTION-TERM SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF QUANTITY-LOGIC-WRAPPER))
  SGT-PROPOSITIONS-LOGIC-QUANTITY-LOGIC-WRAPPER)

(CL:DEFUN ACCESS-QUANTITY-LOGIC-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-WRAPPER-VALUE)
    (CL:IF SETVALUE? (CL:SETF (%WRAPPER-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%WRAPPER-VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-FUNCTION-TERM)
    (CL:IF SETVALUE? (CL:SETF (%FUNCTION-TERM SELF) VALUE)
     (CL:SETQ VALUE (%FUNCTION-TERM SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF QUANTITY-LOGIC-WRAPPER) STREAM)
  (CL:IF *PRINTREADABLY?* (%%PRINT-STREAM STREAM (%WRAPPER-VALUE SELF))
   (%%PRINT-STREAM STREAM "|Q|" (%WRAPPER-VALUE SELF))))

;;; (DEFCLASS INTEGER-LOGIC-WRAPPER ...)

(CL:DEFCLASS INTEGER-LOGIC-WRAPPER (INTEGER-WRAPPER)
  ((DEPENDENT-PROPOSITIONS-INDEX :ALLOCATION :INSTANCE :ACCESSOR
    %DEPENDENT-PROPOSITIONS-INDEX)))

(CL:DEFUN NEW-INTEGER-LOGIC-WRAPPER (WRAPPER-VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM WRAPPER-VALUE))
  #+MCL
  (CL:CHECK-TYPE WRAPPER-VALUE CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INTEGER-LOGIC-WRAPPER)))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INTEGER-LOGIC-WRAPPER))
  SGT-PROPOSITIONS-LOGIC-INTEGER-LOGIC-WRAPPER)

(CL:DEFMETHOD PRINT-OBJECT ((SELF INTEGER-LOGIC-WRAPPER) STREAM)
  (CL:IF *PRINTREADABLY?* (%%PRINT-STREAM STREAM (%WRAPPER-VALUE SELF))
   (%%PRINT-STREAM STREAM "|W|" (%WRAPPER-VALUE SELF))))

;;; (DEFCLASS FLOAT-LOGIC-WRAPPER ...)

(CL:DEFCLASS FLOAT-LOGIC-WRAPPER (FLOAT-WRAPPER)
  ((DEPENDENT-PROPOSITIONS-INDEX :ALLOCATION :INSTANCE :ACCESSOR
    %DEPENDENT-PROPOSITIONS-INDEX)))

(CL:DEFUN NEW-FLOAT-LOGIC-WRAPPER (WRAPPER-VALUE)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT WRAPPER-VALUE))
  #+MCL
  (CL:CHECK-TYPE WRAPPER-VALUE CL:DOUBLE-FLOAT)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE FLOAT-LOGIC-WRAPPER)))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FLOAT-LOGIC-WRAPPER))
  SGT-PROPOSITIONS-LOGIC-FLOAT-LOGIC-WRAPPER)

(CL:DEFMETHOD PRINT-OBJECT ((SELF FLOAT-LOGIC-WRAPPER) STREAM)
  (CL:IF *PRINTREADABLY?* (%%PRINT-STREAM STREAM (%WRAPPER-VALUE SELF))
   (%%PRINT-STREAM STREAM "|W|" (%WRAPPER-VALUE SELF))))

;;; (DEFCLASS STRING-LOGIC-WRAPPER ...)

(CL:DEFCLASS STRING-LOGIC-WRAPPER (STRING-WRAPPER)
  ((DEPENDENT-PROPOSITIONS-INDEX :ALLOCATION :INSTANCE :ACCESSOR
    %DEPENDENT-PROPOSITIONS-INDEX)))

(CL:DEFUN NEW-STRING-LOGIC-WRAPPER (WRAPPER-VALUE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING WRAPPER-VALUE))
  #+MCL
  (CL:CHECK-TYPE WRAPPER-VALUE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STRING-LOGIC-WRAPPER)))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STRING-LOGIC-WRAPPER))
  SGT-PROPOSITIONS-LOGIC-STRING-LOGIC-WRAPPER)

(CL:DEFMETHOD PRINT-OBJECT ((SELF STRING-LOGIC-WRAPPER) STREAM)
  (CL:LET* ((VALUE (%WRAPPER-VALUE SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
   (CL:IF *PRINTREADABLY?* (PRINT-STRING-READABLY VALUE STREAM)
    (CL:IF (CL:NOT (CL:EQ VALUE STELLA::NULL-STRING))
     (%%PRINT-STREAM STREAM "|W|\"" VALUE "\"")
     (%%PRINT-STREAM STREAM "|W|NULL-STRING")))))

;;; (DEFUN (STRINGIFIED-SOURCE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) STRINGIFIED-SOURCE))
(CL:DEFUN STRINGIFIED-SOURCE (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN (%OBJECT-STRINGIFIED-SOURCE SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (%WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
        SYM-PROPOSITIONS-LOGIC-OBJECT-STRINGIFIED-SOURCE
        NULL-STRING-WRAPPER))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
     (CL:PROGN
      (%WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
        SYM-PROPOSITIONS-LOGIC-PROPOSITION-STRINGIFIED-SOURCE
        NULL-STRING-WRAPPER))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (STRINGIFIED-SOURCE-SETTER STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  STRINGIFIED-SOURCE-SETTER))
(CL:DEFUN STRINGIFIED-SOURCE-SETTER (SELF VALUE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:SIMPLE-STRING)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN (CL:SETF (%OBJECT-STRINGIFIED-SOURCE SELF) VALUE)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-PROPOSITIONS-LOGIC-OBJECT-STRINGIFIED-SOURCE
       (WRAP-STRING VALUE) NULL-STRING-WRAPPER)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
     (CL:PROGN
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-PROPOSITIONS-LOGIC-PROPOSITION-STRINGIFIED-SOURCE
       (WRAP-STRING VALUE) NULL-STRING-WRAPPER)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
  VALUE)

;;; (DEFUN (ORIGINATED-PROPOSITIONS (LIST OF PROPOSITION)) ...)

(CL:DEFUN ORIGINATED-PROPOSITIONS (SELF)
  (CL:LET* ((VALUE NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000
       SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
      (CL:PROGN
       (CL:SETQ VALUE (%OBJECT-ORIGINATED-PROPOSITIONS SELF))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
      (CL:PROGN
       (CL:SETQ VALUE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-PROPOSITIONS-LOGIC-OBJECT-ORIGINATED-PROPOSITIONS NULL))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
      (CL:PROGN
       (CL:SETQ VALUE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-PROPOSITIONS-LOGIC-PROPOSITION-ORIGINATED-PROPOSITIONS
         NULL))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:IF (CL:EQ VALUE NULL) NIL-LIST VALUE)))

;;; (DEFUN (ORIGINATED-PROPOSITIONS-SETTER (LIST OF PROPOSITION)) ...)

(CL:DEFUN ORIGINATED-PROPOSITIONS-SETTER (SELF VALUE)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN (CL:SETF (%OBJECT-ORIGINATED-PROPOSITIONS SELF) VALUE)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-PROPOSITIONS-LOGIC-OBJECT-ORIGINATED-PROPOSITIONS VALUE
       NULL)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
     (CL:PROGN
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-PROPOSITIONS-LOGIC-PROPOSITION-ORIGINATED-PROPOSITIONS VALUE
       NULL)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
  VALUE)

;;; (DEFGLOBAL *OPERATOR-NAME-TO-SURROGATE-TABLE* ...)

(CL:DEFVAR *OPERATOR-NAME-TO-SURROGATE-TABLE* NULL
  "Maps names of KIF operators to relational surrogates.")

;;; (DEFUN (CREATE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN CREATE-PROPOSITION (KIND ARGUMENTCOUNT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARGUMENTCOUNT))
  #+MCL
  (CL:CHECK-TYPE ARGUMENTCOUNT CL:FIXNUM)
  (ENFORCE-CODE-ONLY)
  (CL:LET* ((PROPOSITION (NEW-PROPOSITION)))
   (CL:SETF (%ARGUMENTS PROPOSITION) (NEW-VECTOR ARGUMENTCOUNT))
   (CL:SETF (%KIND PROPOSITION) (INTERN-KEYWORD (%SYMBOL-NAME KIND)))
   (CL:COND
    ((CL:OR (CL:EQ KIND SYM-PROPOSITIONS-STELLA-FUNCTION)
      (CL:EQ KIND SYM-PROPOSITIONS-STELLA-PREDICATE)
      (CL:EQ KIND SYM-PROPOSITIONS-STELLA-ISA)))
    (CL:T
     (CL:SETF (%OPERATOR PROPOSITION)
      (LOOKUP *OPERATOR-NAME-TO-SURROGATE-TABLE*
       (%KIND PROPOSITION)))))
   (CL:WHEN (DESCRIPTION-MODE?)
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
     SYM-PROPOSITIONS-LOGIC-DESCRIPTIVE?
     (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
    SYM-PROPOSITIONS-LOGIC-UNFASTENED? TRUE-WRAPPER NULL)
   PROPOSITION))

;;; (DEFUN ENFORCE-CODE-ONLY ...)

(CL:DEFUN ENFORCE-CODE-ONLY ()
  (CL:WHEN
   (%WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *MODULE*)
     SYM-PROPOSITIONS-STELLA-CODE-ONLY? FALSE-WRAPPER))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "ERROR: Can't create a relation, instance or proposition in module:"
      EOL "       `" (%MODULE-NAME *MODULE*) "'" EOL
      "    because it is marked as 'code-only?'" EOL "." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))))

;;; (DEFGLOBAL *LOGIC-MODULE* ...)

(CL:DEFVAR *LOGIC-MODULE* NULL)

;;; (DEFGLOBAL *PL-KERNEL-MODULE* ...)

(CL:DEFVAR *PL-KERNEL-MODULE* NULL)

;;; (DEFUN (LOGIC-MODULE? BOOLEAN) ...)

(CL:DEFUN LOGIC-MODULE? (SELF)
  "Return TRUE if 'self' is a logic module, implying
that relations defined within it define a knowledge base.  A module
is a logic module iff it inherits the module 'PL-KERNEL'."
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:IF (CL:EQ SELF *PL-KERNEL-MODULE*) (CL:SETQ TEST-VALUE-000 CL:T)
    (CL:PROGN
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET*
       ((M NULL) (ITER-000 (%THE-CONS-LIST (%PARENT-MODULES SELF))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ M (%%VALUE ITER-000))
        (CL:WHEN (LOGIC-MODULE? M) (CL:SETQ FOUND?-000 CL:T)
         (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:SETQ TEST-VALUE-000 FOUND?-000))
     (CL:WHEN (CL:NOT TEST-VALUE-000)
      (CL:LET* ((FOUND?-001 CL:NIL))
       (CL:LET* ((M NULL) (ITER-001 (%THE-CONS-LIST (%USES SELF))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ M (%%VALUE ITER-001))
         (CL:WHEN (LOGIC-MODULE? M) (CL:SETQ FOUND?-001 CL:T)
          (CL:RETURN))
         (CL:SETQ ITER-001 (%%REST ITER-001))))
       (CL:SETQ TEST-VALUE-000 FOUND?-001)))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (LOCALLY-CONCEIVED-PROPOSITIONS PROPOSITIONS-INDEX) ...)

(CL:DEFUN LOCALLY-CONCEIVED-PROPOSITIONS (SELF)
  (CL:LET*
   ((PROPOSITIONS
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-PROPOSITIONS-INTERNAL
      NULL)))
   (CL:WHEN (CL:EQ PROPOSITIONS NULL)
    (CL:SETQ PROPOSITIONS
     (CREATE-SEQUENCE-INDEX KWD-PROPOSITIONS-PAGING
      (CONS KWD-PROPOSITIONS-CONTEXT-PROPOSITIONS
       (CONS (CL:IF (CL:EQ NIL NULL) NIL NIL) (CONS SELF NIL)))))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-PROPOSITIONS-INTERNAL
     PROPOSITIONS NULL))
   PROPOSITIONS))

;;; (DEFUN LOCALLY-CONCEIVED-PROPOSITIONS-SETTER ...)

(CL:DEFUN LOCALLY-CONCEIVED-PROPOSITIONS-SETTER (SELF VALUE)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-PROPOSITIONS-INTERNAL VALUE
   NULL))

;;; (DEFUN (LOCALLY-CONCEIVED-INSTANCES INSTANCES-INDEX) ...)

(CL:DEFUN LOCALLY-CONCEIVED-INSTANCES (SELF)
  (CL:LET*
   ((INSTANCES
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-INSTANCES-INTERNAL
      NULL)))
   (CL:WHEN (CL:EQ INSTANCES NULL)
    (CL:SETQ INSTANCES
     (CREATE-SEQUENCE-INDEX KWD-PROPOSITIONS-PAGING
      (CONS KWD-PROPOSITIONS-CONTEXT-INSTANCES
       (CONS (CL:IF (CL:EQ NIL NULL) NIL NIL) (CONS SELF NIL)))))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-INSTANCES-INTERNAL
     INSTANCES NULL))
   INSTANCES))

;;; (DEFUN LOCALLY-CONCEIVED-INSTANCES-SETTER ...)

(CL:DEFUN LOCALLY-CONCEIVED-INSTANCES-SETTER (SELF VALUE)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-INSTANCES-INTERNAL VALUE
   NULL))

;;; (DEFGLOBAL *NOW-TIMESTAMP* ...)

(CL:DEFVAR *NOW-TIMESTAMP* 0
  "The NOW time stamp is incremented whenever a series
of one or more updates is followed by a query.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *NOW-TIMESTAMP*))

;;; (DEFUN INCREMENT-NOW-TIMESTAMP ...)

(CL:DEFUN INCREMENT-NOW-TIMESTAMP ()
  (CL:SETQ *NOW-TIMESTAMP* (CL:1+ *NOW-TIMESTAMP*)))

;;; (DEFUN (GET-NOW-TIMESTAMP TIMESTAMP) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION () CL:FIXNUM) GET-NOW-TIMESTAMP))
(CL:DEFUN GET-NOW-TIMESTAMP ()
  *NOW-TIMESTAMP*)

;;; (DEFGLOBAL *LAST-KB-ACTION* ...)

(CL:DEFVAR *LAST-KB-ACTION* NULL
  "Records whether the last KB access was a query or
an update.  Used to determine when to increment the NOW time stamp
counter.")

;;; (DEFUN UPDATE-NOW-TIMESTAMP ...)

(CL:DEFUN UPDATE-NOW-TIMESTAMP (KBACTION)
  (CL:WHEN (CL:EQ KBACTION *LAST-KB-ACTION*)
   (CL:RETURN-FROM UPDATE-NOW-TIMESTAMP))
  (CL:COND
   ((CL:EQ KBACTION KWD-PROPOSITIONS-UPDATE-PROPOSITION)
    (CL:WHEN
     (CL:OR (DESCRIPTION-MODE?) (CL:NOT (CL:EQ *MODULE* *CONTEXT*))
      *INVISIBLEASSERTION?*)
     (CL:RETURN-FROM UPDATE-NOW-TIMESTAMP))
    (INCREMENT-NOW-TIMESTAMP))
   ((CL:EQ KBACTION KWD-PROPOSITIONS-EXECUTE-QUERY))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KBACTION
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:SETQ *LAST-KB-ACTION* KBACTION))

;;; (DEFGLOBAL BOTTOM ...)

(CL:DEFVAR BOTTOM NULL
  "The undefined individual.  Denotes the non-existence of
an individual in whatever slot it occupies.")

;;; (DEFUN (BOTTOM? BOOLEAN) ...)

(CL:DEFUN BOTTOM? (SELF)
  "Return TRUE if 'self' is the undefined individual BOTTOM."
  (CL:EQ SELF BOTTOM))

;;; (DEFUN (SUBRELATION-OF? BOOLEAN) ...)

(CL:DEFUN SUBRELATION-OF? (DESC1 DESC2)
  (CL:LET* ((*REVERSEPOLARITY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (COLLECTION-IMPLIES-COLLECTION? DESC1 DESC2)))

;;; (DEFUN (LOGICAL-SUBTYPE-OF? BOOLEAN) ...)

(CL:DEFUN LOGICAL-SUBTYPE-OF? (TYPE1 TYPE2)
  (CL:IF (CL:EQ TYPE1 TYPE2) CL:T
   (CL:LET*
    ((DESC1 (GET-DESCRIPTION TYPE1)) (DESC2 (GET-DESCRIPTION TYPE2)))
    (CL:WHEN (CL:OR (CL:EQ DESC1 NULL) (CL:EQ DESC2 NULL))
     (CL:RETURN-FROM LOGICAL-SUBTYPE-OF? CL:NIL))
    (SUBRELATION-OF? DESC1 DESC2))))

;;; (DEFUN (LOGICAL-SUBTYPE-OF-LITERAL? BOOLEAN) ...)

(CL:DEFUN LOGICAL-SUBTYPE-OF-LITERAL? (TYPE)
  (CL:LET*
   ((DESC (SURROGATE-TO-DESCRIPTION TYPE))
    (LITERALCLASS
     (SURROGATE-TO-DESCRIPTION SGT-PROPOSITIONS-STELLA-LITERAL))
    (LITERALSUBS NIL))
   (CL:COND
    ((CL:EQ DESC NULL)
     (CL:RETURN-FROM LOGICAL-SUBTYPE-OF-LITERAL? CL:NIL))
    ((CL:EQ DESC LITERALCLASS)
     (CL:RETURN-FROM LOGICAL-SUBTYPE-OF-LITERAL? CL:T))
    (CL:T
     (CL:LET*
      ((*REVERSEPOLARITY?* CL:NIL)
       (*CONTEXT* (GET-PROPERTY-TEST-CONTEXT)))
      (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?* *CONTEXT*))
      (CL:LET*
       ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
        (MEMOIZED-VALUE-000 NULL))
       (CL:WHEN *MEMOIZATION-ENABLED?*
        (CL:SETQ MEMO-TABLE-000
         (%SURROGATE-VALUE
          SGT-PROPOSITIONS-LOGIC-F-LOGICAL-SUBTYPE-OF-LITERAL?-MEMO-TABLE-000))
        (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
         (INITIALIZE-MEMOIZATION-TABLE
          SGT-PROPOSITIONS-LOGIC-F-LOGICAL-SUBTYPE-OF-LITERAL?-MEMO-TABLE-000
          "(:MAX-VALUES 10 :TIMESTAMPS (:META-KB-UPDATE))")
         (CL:SETQ MEMO-TABLE-000
          (%SURROGATE-VALUE
           SGT-PROPOSITIONS-LOGIC-F-LOGICAL-SUBTYPE-OF-LITERAL?-MEMO-TABLE-000)))
        (CL:SETQ MEMOIZED-ENTRY-000
         (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 *CONTEXT*
          MEMOIZED-NULL-VALUE NULL NULL -1))
        (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
       (CL:COND
        ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
         (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
          (CL:SETQ MEMOIZED-VALUE-000 NULL)))
        (CL:T
         (CL:SETQ MEMOIZED-VALUE-000
          (CONSIFY (ALL-SUBCOLLECTIONS LITERALCLASS)))
         (CL:WHEN *MEMOIZATION-ENABLED?*
          (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
           (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
            MEMOIZED-VALUE-000)))))
       (CL:SETQ LITERALSUBS MEMOIZED-VALUE-000))
      (CL:WHEN (MEMB? LITERALSUBS DESC)
       (CL:RETURN-FROM LOGICAL-SUBTYPE-OF-LITERAL? CL:T)))))
   CL:NIL))

;;; (DEFUN (LITERAL-TYPE? BOOLEAN) ...)

(CL:DEFUN LITERAL-TYPE? (TYPE)
  (CL:LET* ((VALUE (%SURROGATE-VALUE TYPE)))
   (CL:AND (ISA? VALUE SGT-PROPOSITIONS-STELLA-CLASS)
    (CL:OR (SUBTYPE-OF? TYPE SGT-PROPOSITIONS-STELLA-LITERAL)
     (SUBTYPE-OF? TYPE SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER)))))

;;; (DEFUN (BOOLEAN-TYPE? BOOLEAN) ...)

(CL:DEFUN BOOLEAN-TYPE? (SELF)
  (CL:OR (CL:EQ SELF SGT-PROPOSITIONS-STELLA-BOOLEAN)
   (CL:EQ SELF SGT-PROPOSITIONS-STELLA-BOOLEAN-WRAPPER)))

;;; (DEFUN (CLASS-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN CLASS-DESCRIPTION? (SELF)
  (CLASS? SELF))

;;; (DEFUN (FUNCTION-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN FUNCTION-DESCRIPTION? (SELF)
  (FUNCTION? SELF))

;;; (DEFUN (VARIABLE-ARITY? BOOLEAN) ...)

(CL:DEFUN VARIABLE-ARITY? (SELF)
  (TEST-PROPERTY? SELF SGT-PROPOSITIONS-PL-KERNEL-KB-VARIABLE-ARITY))

;;; (DEFMETHOD (ARITY INTEGER) ...)

(CL:DEFMETHOD ARITY ((SELF NAMED-DESCRIPTION))
  (CL:IF (VARIABLE-ARITY? SELF) -1 (LENGTH (%IO-VARIABLE-TYPES SELF))))

;;; (DEFMETHOD (ARITY INTEGER) ...)

(CL:DEFMETHOD ARITY ((SELF DESCRIPTION))
  (LENGTH (%IO-VARIABLES SELF)))

;;; (DEFUN (MONADIC? BOOLEAN) ...)

(CL:DEFUN MONADIC? (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
     (CL:PROGN (CL:= (ARITY SELF) 1)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-COLLECTION)
     (CL:PROGN CL:T))
    (CL:T CL:NIL))))

;;; (DEFUN (COMPUTED-RELATION? BOOLEAN) ...)

(CL:DEFUN COMPUTED-RELATION? (DESCRIPTION)
  (CL:OR
   (CL:AND (CL:NOT (CL:EQ (NATIVE-RELATION DESCRIPTION) NULL))
    (CL:NOT (%ABSTRACT? (NATIVE-RELATION DESCRIPTION))))
   (CL:NOT
    (CL:EQ
     (ACCESS-BINARY-VALUE DESCRIPTION
      SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION-COMPUTATION)
     NULL))))

;;; (DEFUN (LAST-ARGUMENT OBJECT) ...)

(CL:DEFUN LAST-ARGUMENT (PROPOSITION)
  (CL:AREF
   (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
   (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS PROPOSITION))))))

;;; (DEFUN (OBJECT-SURROGATE SURROGATE) ...)

(CL:DEFUN OBJECT-SURROGATE (SELF)
  "Return the surrogate naming the object `self', which
may be a Stella class that is used in PowerLoom as well as
a more normal powerloom object."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN (%SURROGATE-VALUE-INVERSE SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
     (CL:PROGN
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-PROPOSITIONS-STELLA-SURROGATE-VALUE-INVERSE NULL)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-THING)
     (CL:PROGN (%SURROGATE-VALUE-INVERSE SELF)))
    ((SUBTYPE-OF-CLASS? TEST-VALUE-000) (CL:PROGN (%CLASS-TYPE SELF)))
    (CL:T NULL))))

;;; (DEFUN (OBJECT-SURROGATE-SETTER SURROGATE) ...)

(CL:DEFUN OBJECT-SURROGATE-SETTER (SELF NAME)
  "Return the name of the logic object `self' to `name'."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NAME) NAME))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
     (CL:PROGN
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-PROPOSITIONS-STELLA-SURROGATE-VALUE-INVERSE NAME NULL)
      NAME))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-THING)
     (CL:PROGN (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NAME) NAME))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (OBJECT-NAME SYMBOL) ...)

(CL:DEFUN OBJECT-NAME (SELF)
  "Return the name symbol for the logic object `self'."
  (CL:LET* ((SURROGATE (OBJECT-SURROGATE SELF)))
   (CL:IF (CL:NOT (CL:EQ SURROGATE NULL))
    (INTERN-SYMBOL-IN-MODULE (%SYMBOL-NAME SURROGATE)
     (%HOME-CONTEXT SURROGATE) CL:T)
    NULL)))

;;; (DEFUN (OBJECT-NAME-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) OBJECT-NAME-STRING))
(CL:DEFUN OBJECT-NAME-STRING (SELF)
  "Return the name string for the logic object `self'."
  (CL:LET* ((SURROGATE (OBJECT-SURROGATE SELF)))
   (CL:IF (CL:NOT (CL:EQ SURROGATE NULL)) (%SYMBOL-NAME SURROGATE)
    STELLA::NULL-STRING)))

;;; (DEFUN (OBJECT-STRING-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) OBJECT-STRING-NAME))
(CL:DEFUN OBJECT-STRING-NAME (SELF)
  (OBJECT-NAME-STRING SELF))

;;; (DEFSPECIAL *EVALUATIONMODE* ...)

(CL:DEFVAR *EVALUATIONMODE* NULL
  "Indicates the context for evaluating a proposition.  One
of :DESCRIPTION, :INTENSIONAL-ASSERTION, or :EXTENSIONAL-ASSERTION.")

;;; (DEFUN (DESCRIPTION-MODE? BOOLEAN) ...)

(CL:DEFUN DESCRIPTION-MODE? ()
  (CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-DESCRIPTION))

;;; (DEFSPECIAL *CLIPPINGENABLED?* ...)

(CL:DEFVAR *CLIPPINGENABLED?* CL:T
  "When enabled, slot-value assertions can be retracted
by later conflicting assertions.")

;;; (DEFSPECIAL *NATURALDEDUCTIONMODE?* ...)

(CL:DEFVAR *NATURALDEDUCTIONMODE?* CL:T
  "When enabled, blocks normalizations that significantly
change the behavior of inference rules.")

;;; (DEFUN (NATURAL-DEDUCTION-MODE? BOOLEAN) ...)

(CL:DEFUN NATURAL-DEDUCTION-MODE? ()
  "True if normalization is governed by natural
deduction semantics."
  *NATURALDEDUCTIONMODE?*)

;;; (DEFGLOBAL *CONTEXT-DEPENDENT-SEARCH-MODE?* ...)

(CL:DEFVAR *CONTEXT-DEPENDENT-SEARCH-MODE?* CL:NIL
  "Signals that we are performing search across multiple
contexts.  Used to disable retraction from collections, since that increases
the overhead of the context mechanism.")

;;; (DEFUN (CONTEXT-DEPENDENT-SEARCH-MODE? BOOLEAN) ...)

(CL:DEFUN CONTEXT-DEPENDENT-SEARCH-MODE? ()
  *CONTEXT-DEPENDENT-SEARCH-MODE?*)

;;; (DEFUN LOG-NEWLY-CONCEIVED-PROPOSITION ...)

(CL:DEFUN LOG-NEWLY-CONCEIVED-PROPOSITION (SELF PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:LET* ((FOUND?-000 CL:NIL))
    (CL:LET*
     ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:WHEN (ISA? ARG SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
       (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
    (CL:SETQ TEST-VALUE-000 FOUND?-000))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000
     (CL:EQ *POWERLOOM-EXECUTION-MODE* KWD-PROPOSITIONS-DEVELOPMENT)))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING)
      "WARNING: LOGGED QUESTIONABLE CONCEPTION: " EOL "   " PROPOSITION
      EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
      KWD-PROPOSITIONS-WARNING))))
  (INSERT (LOCALLY-CONCEIVED-PROPOSITIONS SELF) PROPOSITION))

;;; (DEFUN CLIP-OR-CLASH-WITH-OLD-PREDICATE-VALUE ...)

(CL:DEFUN CLIP-OR-CLASH-WITH-OLD-PREDICATE-VALUE (PROPOSITION)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS PROPOSITION))
    (COUNTMINUSTWO (CL:- (LENGTH ARGUMENTS) 2)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COUNTMINUSTWO))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALL-TRUE-DEPENDENT-PROPOSITIONS
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0)
       (%OPERATOR PROPOSITION) CL:NIL)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:LET* ((ALWAYS?-000 CL:T))
      (CL:LET*
       ((I NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-000 COUNTMINUSTWO)
        (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
       (CL:LOOP WHILE
        (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)) DO
        (CL:SETQ I ITER-001)
        (CL:WHEN
         (CL:NOT
          (EQL?
           (VALUE-OF
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS))
             I))
           (VALUE-OF
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
             I))))
         (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
        (CL:SETQ ITER-001 (CL:1+ ITER-001))))
      (CL:WHEN ALWAYS?-000
       (CL:COND
        ((EQL?
          (VALUE-OF
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
            (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS P))))))
          (VALUE-OF (LAST ARGUMENTS))))
        ((CL:AND *CLIPPINGENABLED?* (WORLD-STATE? *CONTEXT*))
         (DEASSIGN-TRUTH-VALUE P KWD-PROPOSITIONS-RETRACT-TRUE))
        (CL:T
         (SIGNAL-UNIFICATION-CLASH
          (VALUE-OF
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
            (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS P))))))
          (VALUE-OF (LAST ARGUMENTS)))))))))))

;;; (DEFUN RUN-UPDATE-EQUIVALENCE-PROPOSITION-DEMON ...)

(CL:DEFUN RUN-UPDATE-EQUIVALENCE-PROPOSITION-DEMON (PROPOSITION UPDATEMODE)
  (CL:LET*
   ((TERM1
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (TERM2
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (DESCRIPTION
     (CL:IF (FUNCTION-OUTPUT-SKOLEM? TERM1)
      (GET-DESCRIPTION (%OPERATOR (%DEFINING-PROPOSITION TERM1)))
      (CL:IF (FUNCTION-OUTPUT-SKOLEM? TERM2)
       (GET-DESCRIPTION (%OPERATOR (%DEFINING-PROPOSITION TERM2)))
       NULL)))
    (DEMONCOMPUTATION
     (CL:IF (CL:NOT (CL:EQ DESCRIPTION NULL))
      (ACCESS-BINARY-VALUE DESCRIPTION
       SGT-PROPOSITIONS-PL-KERNEL-KB-UPDATE-PROPOSITION-DEMON)
      NULL)))
   (CL:WHEN (CL:NOT (CL:EQ DEMONCOMPUTATION NULL))
    (CL:LET*
     ((FUNCTIONCODE (FUNCTION-CODE-FROM-PROCEDURE DEMONCOMPUTATION)))
     (CL:WHEN (CL:NOT (CL:EQ FUNCTIONCODE NULL))
      (CL:FUNCALL FUNCTIONCODE PROPOSITION UPDATEMODE))))))

;;; (DEFUN HELP-RUN-UPDATE-PROPOSITION-DEMON ...)

(CL:DEFUN HELP-RUN-UPDATE-PROPOSITION-DEMON (PROPOSITION UPDATEMODE)
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION (%OPERATOR PROPOSITION)))
    (DEMONCOMPUTATION
     (CL:IF (CL:NOT (CL:EQ DESCRIPTION NULL))
      (ACCESS-BINARY-VALUE DESCRIPTION
       SGT-PROPOSITIONS-PL-KERNEL-KB-UPDATE-PROPOSITION-DEMON)
      NULL)))
   (CL:WHEN (CL:NOT (CL:EQ DEMONCOMPUTATION NULL))
    (CL:LET*
     ((FUNCTIONCODE (FUNCTION-CODE-FROM-PROCEDURE DEMONCOMPUTATION)))
     (CL:WHEN (CL:NOT (CL:EQ FUNCTIONCODE NULL))
      (CL:FUNCALL FUNCTIONCODE PROPOSITION UPDATEMODE))))))

;;; (DEFUN RUN-UPDATE-PROPOSITION-DEMON ...)

(CL:DEFUN RUN-UPDATE-PROPOSITION-DEMON (PROPOSITION UPDATEMODE)
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *MODULE*)
      SYM-PROPOSITIONS-LOGIC-OBJECT-STORE NULL)
     NULL))
   (UPDATE-PROPOSITION-IN-STORE
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *MODULE*)
     SYM-PROPOSITIONS-LOGIC-OBJECT-STORE NULL)
    PROPOSITION UPDATEMODE))
  (CL:COND
   ((CL:EQ (%KIND PROPOSITION) KWD-PROPOSITIONS-EQUIVALENT)
    (RUN-UPDATE-EQUIVALENCE-PROPOSITION-DEMON PROPOSITION UPDATEMODE))
   (CL:T (HELP-RUN-UPDATE-PROPOSITION-DEMON PROPOSITION UPDATEMODE))))

;;; (DEFUN RUN-TRUTH-CHANGE-DEMON ...)

(CL:DEFUN RUN-TRUTH-CHANGE-DEMON (PROPOSITION TRUTHCHANGERELATION)
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION (%OPERATOR PROPOSITION)))
    (DEMONCOMPUTATION
     (CL:IF (CL:NOT (CL:EQ DESCRIPTION NULL))
      (ACCESS-BINARY-VALUE DESCRIPTION TRUTHCHANGERELATION) NULL)))
   (CL:WHEN (CL:NOT (CL:EQ DEMONCOMPUTATION NULL))
    (CL:LET*
     ((FUNCTIONCODE (FUNCTION-CODE-FROM-PROCEDURE DEMONCOMPUTATION)))
     (CL:WHEN (CL:NOT (CL:EQ FUNCTIONCODE NULL))
      (CL:FUNCALL FUNCTIONCODE PROPOSITION))))))

;;; (DEFUN RUN-GOES-TRUE-DEMONS ...)

(CL:DEFUN RUN-GOES-TRUE-DEMONS (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-ISA))
     (RUN-TRUTH-CHANGE-DEMON PROPOSITION
      SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-TRUE-DEMON))
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-PREDICATE)
     (CL:LET* ((DESCRIPTION (GET-DESCRIPTION (%OPERATOR PROPOSITION))))
      (CL:WHEN (SINGLE-VALUED-TERM? DESCRIPTION)
       (CLIP-OR-CLASH-WITH-OLD-PREDICATE-VALUE PROPOSITION)))
     (RUN-TRUTH-CHANGE-DEMON PROPOSITION
      SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-TRUE-DEMON))
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-IMPLIES)
     (CL:WHEN
      (CL:OR
       (CL:NOT
        (ISA?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          0)
         SGT-PROPOSITIONS-LOGIC-DESCRIPTION))
       (CL:NOT
        (ISA?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          1)
         SGT-PROPOSITIONS-LOGIC-DESCRIPTION)))
      (CL:RETURN-FROM RUN-GOES-TRUE-DEMONS))
     (CL:WHEN (CL:NOT (DESCRIPTION-MODE?))
      (ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        0)
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        1)))
     (REVISE-EQUIVALENCES PROPOSITION CL:T)
     (CL:WHEN (CL:EQ *MODULE* *CONTEXT*) (BUMP-INFERABLE-TIMESTAMP))
     (FLUSH-INFERABLE-DIRECT-SUBDESCRIPTIONS-CACHE PROPOSITION))
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FORALL)
     (CL:WHEN (CL:EQ (SATELLITE-PROPOSITIONS PROPOSITION) NIL-LIST)
      (DERIVE-SATELLITE-RULES PROPOSITION))
     (BUMP-INFERABLE-TIMESTAMP))
    (CL:T)))
  NULL)

;;; (DEFUN RUN-GOES-FALSE-DEMONS ...)

(CL:DEFUN RUN-GOES-FALSE-DEMONS (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-ISA)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-PREDICATE))
     (RUN-TRUTH-CHANGE-DEMON PROPOSITION
      SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-FALSE-DEMON))
    (CL:T)))
  NULL)

;;; (DEFUN RUN-GOES-UNKNOWN-DEMONS ...)

(CL:DEFUN RUN-GOES-UNKNOWN-DEMONS (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-ISA)
     (CL:LET*
      ((ARGUMENT
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         0)))
      (CL:COND
       ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARGUMENT)
         SGT-PROPOSITIONS-LOGIC-SKOLEM)
        (CL:PROGN
         (CL:LET* ((SKOLEMTYPE (%SKOLEM-TYPE ARGUMENT)))
          (CL:WHEN
           (CL:AND (CL:EQ SKOLEMTYPE (%OPERATOR PROPOSITION))
            (CL:NOT (CL:EQ SKOLEMTYPE SGT-PROPOSITIONS-STELLA-THING)))
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
            "Can't retract skolem type of `" ARGUMENT "' equaling `"
            (%SYMBOL-NAME SKOLEMTYPE) "'." EOL EOL)))))
       (CL:T)))
     (RUN-TRUTH-CHANGE-DEMON PROPOSITION
      SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-UNKNOWN-DEMON))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FUNCTION))
     (RUN-TRUTH-CHANGE-DEMON PROPOSITION
      SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-UNKNOWN-DEMON))
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-IMPLIES)
     (DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       1))
     (REVISE-EQUIVALENCES PROPOSITION CL:NIL)
     (CL:LET*
      ((P
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
         SYM-PROPOSITIONS-LOGIC-MASTER-PROPOSITION NULL)))
      (CL:WHEN (CL:AND (CL:NOT (CL:EQ P NULL)) (TRUE? P))
       (DEASSIGN-TRUTH-VALUE P KWD-PROPOSITIONS-RETRACT-TRUE))))
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FORALL)
     (CL:LET*
      ((P NULL)
       (ITER-000
        (%THE-CONS-LIST (SATELLITE-PROPOSITIONS PROPOSITION))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ P (%%VALUE ITER-000))
       (DEASSIGN-TRUTH-VALUE P KWD-PROPOSITIONS-RETRACT-TRUE)
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    (CL:T)))
  NULL)

;;; (DEFUN UPDATE-LINKS-AND-TIMESTAMPS ...)

(CL:DEFUN UPDATE-LINKS-AND-TIMESTAMPS (PROPOSITION UPDATEMODE)
  (CL:WHEN (CL:EQ PROPOSITION NULL)
   (CL:RETURN-FROM UPDATE-LINKS-AND-TIMESTAMPS))
  (UPDATE-NOW-TIMESTAMP KWD-PROPOSITIONS-UPDATE-PROPOSITION)
  (CL:COND
   ((CL:OR (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
     (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-TRUE))
    (RUN-GOES-TRUE-DEMONS PROPOSITION))
   ((CL:OR (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
     (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-FALSE))
    (RUN-GOES-FALSE-DEMONS PROPOSITION))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
    (RUN-GOES-UNKNOWN-DEMONS PROPOSITION))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-FALSE)
    (RUN-GOES-UNKNOWN-DEMONS PROPOSITION))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" UPDATEMODE
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN ASSIGN-TRUTH-VALUE ...)

(CL:DEFUN ASSIGN-TRUTH-VALUE (SELF TRUTHVALUE)
  (CL:LET*
   ((OLDTRUTHVALUE
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF)
      CL:NIL))
    (NEWTRUTHVALUE NULL))
   (CL:COND
    ((CL:EQ TRUTHVALUE TRUE-WRAPPER)
     (CL:SETQ NEWTRUTHVALUE TRUE-TRUTH-VALUE))
    ((CL:EQ TRUTHVALUE FALSE-WRAPPER)
     (CL:SETQ NEWTRUTHVALUE FALSE-TRUTH-VALUE))
    (CL:T (CL:SETQ NEWTRUTHVALUE TRUTHVALUE)))
   (CL:COND ((CL:EQ OLDTRUTHVALUE NEWTRUTHVALUE))
    ((CL:NOT (CL:EQ OLDTRUTHVALUE NULL))
     (CL:COND
      ((CL:OR (CL:EQ SELF TRUE-PROPOSITION)
        (CL:EQ SELF FALSE-PROPOSITION)))
      ((CL:EQ OLDTRUTHVALUE INCONSISTENT-TRUTH-VALUE))
      ((CL:EQ NEWTRUTHVALUE TRUE-TRUTH-VALUE)
       (CL:COND
        ((CL:EQ OLDTRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
         (CL:LET*
          ((OBJECT-000 SELF) (VALUE-000 NULL)
           (OLD-VALUE-001 (%TRUTH-VALUE OBJECT-000))
           (NEW-VALUE-000
            (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-000
             (%HOME-CONTEXT OBJECT-000) CL:NIL)))
          (CL:WHEN
           (CL:NOT
            (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
             (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
              SGT-PROPOSITIONS-STELLA-CS-VALUE)))
           (CL:SETF (%TRUTH-VALUE OBJECT-000) NEW-VALUE-000)))
         (ASSIGN-TRUTH-VALUE SELF NEWTRUTHVALUE))
        ((CL:EQ OLDTRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE)
         (DEASSIGN-TRUTH-VALUE SELF KWD-PROPOSITIONS-RETRACT-FALSE)
         (ASSIGN-TRUTH-VALUE SELF NEWTRUTHVALUE))
        ((CL:EQ OLDTRUTHVALUE FALSE-TRUTH-VALUE)
         (SIGNAL-TRUTH-VALUE-CLASH SELF))))
      ((CL:EQ NEWTRUTHVALUE FALSE-TRUTH-VALUE)
       (CL:COND
        ((CL:EQ OLDTRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE)
         (CL:LET*
          ((OBJECT-001 SELF) (VALUE-001 NULL)
           (OLD-VALUE-002 (%TRUTH-VALUE OBJECT-001))
           (NEW-VALUE-001
            (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-001
             (%HOME-CONTEXT OBJECT-001) CL:NIL)))
          (CL:WHEN
           (CL:NOT
            (CL:AND (CL:NOT (CL:EQ OLD-VALUE-002 NULL))
             (CL:EQ (PRIMARY-TYPE OLD-VALUE-002)
              SGT-PROPOSITIONS-STELLA-CS-VALUE)))
           (CL:SETF (%TRUTH-VALUE OBJECT-001) NEW-VALUE-001)))
         (ASSIGN-TRUTH-VALUE SELF NEWTRUTHVALUE))
        ((CL:EQ OLDTRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
         (DEASSIGN-TRUTH-VALUE SELF KWD-PROPOSITIONS-RETRACT-TRUE)
         (ASSIGN-TRUTH-VALUE SELF NEWTRUTHVALUE))
        ((CL:EQ OLDTRUTHVALUE TRUE-TRUTH-VALUE)
         (SIGNAL-TRUTH-VALUE-CLASH SELF))))
      ((CL:EQ NEWTRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
       (CL:COND
        (*DEFERINGDEFAULTFORWARDINFERENCES?*
         (DEFERRED-DEFAULT-PROPOSITIONS-SETTER *CONTEXT*
          (CONS SELF (DEFERRED-DEFAULT-PROPOSITIONS *CONTEXT*)))
         NULL)
        ((CL:OR (CL:EQ OLDTRUTHVALUE TRUE-TRUTH-VALUE)
          (CL:EQ OLDTRUTHVALUE FALSE-TRUTH-VALUE)))
        ((CL:EQ OLDTRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE)
         (DEASSIGN-TRUTH-VALUE SELF KWD-PROPOSITIONS-RETRACT-FALSE))))
      ((CL:EQ NEWTRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE)
       (CL:COND
        (*DEFERINGDEFAULTFORWARDINFERENCES?*
         (DEFERRED-DEFAULT-PROPOSITIONS-SETTER *CONTEXT*
          (CONS SELF (DEFERRED-DEFAULT-PROPOSITIONS *CONTEXT*)))
         NULL)
        ((CL:OR (CL:EQ OLDTRUTHVALUE FALSE-TRUTH-VALUE)
          (CL:EQ OLDTRUTHVALUE TRUE-TRUTH-VALUE)))
        ((CL:EQ OLDTRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
         (DEASSIGN-TRUTH-VALUE SELF KWD-PROPOSITIONS-RETRACT-TRUE))))
      ((CL:EQ NEWTRUTHVALUE INCONSISTENT-TRUTH-VALUE)
       (CL:COND
        ((CL:OR (CL:EQ OLDTRUTHVALUE TRUE-TRUTH-VALUE)
          (CL:EQ OLDTRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE))
         (DEASSIGN-TRUTH-VALUE SELF KWD-PROPOSITIONS-RETRACT-TRUE))
        ((CL:OR (CL:EQ OLDTRUTHVALUE FALSE-TRUTH-VALUE)
          (CL:EQ OLDTRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE))
         (DEASSIGN-TRUTH-VALUE SELF KWD-PROPOSITIONS-RETRACT-FALSE)))
       (ASSIGN-TRUTH-VALUE SELF NEWTRUTHVALUE))
      (CL:T (SIGNAL-TRUTH-VALUE-CLASH SELF))))
    ((CL:EQ (%KIND SELF) KWD-PROPOSITIONS-FUNCTION)
     (CL:LET*
      ((OBJECT-002 SELF) (VALUE-002 TRUE-TRUTH-VALUE)
       (OLD-VALUE-003 (%TRUTH-VALUE OBJECT-002))
       (NEW-VALUE-002
        (UPDATE-IN-CONTEXT OLD-VALUE-003 VALUE-002
         (%HOME-CONTEXT OBJECT-002) CL:NIL)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-003 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-003)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%TRUTH-VALUE OBJECT-002) NEW-VALUE-002))))
    ((CL:EQ NEWTRUTHVALUE INCONSISTENT-TRUTH-VALUE)
     (CL:LET*
      ((OBJECT-003 SELF) (VALUE-003 NEWTRUTHVALUE)
       (OLD-VALUE-004 (%TRUTH-VALUE OBJECT-003))
       (NEW-VALUE-003
        (UPDATE-IN-CONTEXT OLD-VALUE-004 VALUE-003
         (%HOME-CONTEXT OBJECT-003) CL:NIL)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-004 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-004)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%TRUTH-VALUE OBJECT-003) NEW-VALUE-003))))
    (CL:T
     (CL:LET*
      ((OBJECT-004 SELF) (VALUE-004 NEWTRUTHVALUE)
       (OLD-VALUE-005 (%TRUTH-VALUE OBJECT-004))
       (NEW-VALUE-004
        (UPDATE-IN-CONTEXT OLD-VALUE-005 VALUE-004
         (%HOME-CONTEXT OBJECT-004) CL:NIL)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-005 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-005)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%TRUTH-VALUE OBJECT-004) NEW-VALUE-004)))
     (HANDLE-OUT-OF-DATE-INFERENCE-CACHE KWD-PROPOSITIONS-ASSERT SELF)
     (CL:COND
      ((CL:EQ NEWTRUTHVALUE TRUE-TRUTH-VALUE)
       (UPDATE-LINKS-AND-TIMESTAMPS SELF KWD-PROPOSITIONS-ASSERT-TRUE))
      ((CL:EQ NEWTRUTHVALUE FALSE-TRUTH-VALUE)
       (UPDATE-LINKS-AND-TIMESTAMPS SELF
        KWD-PROPOSITIONS-ASSERT-FALSE))
      ((CL:EQ NEWTRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
       (UPDATE-LINKS-AND-TIMESTAMPS SELF
        KWD-PROPOSITIONS-PRESUME-TRUE))
      ((CL:EQ NEWTRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE)
       (UPDATE-LINKS-AND-TIMESTAMPS SELF
        KWD-PROPOSITIONS-PRESUME-FALSE)))
     (REACT-TO-KB-UPDATE *CONTEXT* SELF)))))

;;; (DEFUN DEASSIGN-TRUTH-VALUE ...)

(CL:DEFUN DEASSIGN-TRUTH-VALUE (SELF UPDATEMODE)
  (CL:LET*
   ((OBJECT-000 SELF) (VALUE-000 NULL)
    (OLD-VALUE-000 (%TRUTH-VALUE OBJECT-000))
    (NEW-VALUE-000
     (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
      (%HOME-CONTEXT OBJECT-000) CL:NIL)))
   (CL:WHEN
    (CL:NOT
     (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
      (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
       SGT-PROPOSITIONS-STELLA-CS-VALUE)))
    (CL:SETF (%TRUTH-VALUE OBJECT-000) NEW-VALUE-000)))
  (CL:WHEN
   (CL:NOT (CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-INCONSISTENT))
   (HANDLE-OUT-OF-DATE-INFERENCE-CACHE KWD-PROPOSITIONS-RETRACT SELF)
   (UPDATE-LINKS-AND-TIMESTAMPS SELF UPDATEMODE)))

;;; (DEFUN UPDATE-PROPOSITION-TRUTH-VALUE ...)

(CL:DEFUN UPDATE-PROPOSITION-TRUTH-VALUE (SELF UPDATEMODE)
  (CL:COND
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
    (ASSIGN-TRUTH-VALUE SELF TRUE-WRAPPER))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
    (ASSIGN-TRUTH-VALUE SELF FALSE-WRAPPER))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-TRUE)
    (ASSIGN-TRUTH-VALUE SELF DEFAULT-TRUE-TRUTH-VALUE))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-FALSE)
    (ASSIGN-TRUTH-VALUE SELF DEFAULT-FALSE-TRUTH-VALUE))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
    (CL:WHEN
     (CL:AND (TRUE? SELF)
      (CL:NOT (CL:EQ (%KIND SELF) KWD-PROPOSITIONS-FUNCTION)))
     (DEASSIGN-TRUTH-VALUE SELF UPDATEMODE)))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-FALSE)
    (CL:WHEN (FALSE? SELF) (DEASSIGN-TRUTH-VALUE SELF UPDATEMODE)))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-CONCEIVE))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" UPDATEMODE
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (RUN-UPDATE-PROPOSITION-DEMON SELF UPDATEMODE))

;;; (DEFUN ASSIGN-PROPOSITION-WEIGHT ...)

(CL:DEFUN ASSIGN-PROPOSITION-WEIGHT (SELF WEIGHT)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT WEIGHT))
  #+MCL
  (CL:CHECK-TYPE WEIGHT CL:DOUBLE-FLOAT)
  (CL:LET*
   ((TV
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF)
      CL:NIL)))
   (CL:COND
    ((CL:= WEIGHT 1.0d0) (ASSIGN-TRUTH-VALUE SELF TRUE-WRAPPER))
    ((CL:= WEIGHT 0.0d0) (ASSIGN-TRUTH-VALUE SELF FALSE-WRAPPER))
    ((CL:OR (CL:EQ TV TRUE-TRUTH-VALUE) (CL:EQ TV FALSE-TRUTH-VALUE)
      (CL:EQ TV NULL))
     (CL:LET* ((SELF-000 (NEW-TRUTH-VALUE)))
      (CL:SETF (%POSITIVE-SCORE SELF-000) WEIGHT)
      (CL:LET*
       ((OBJECT-000 SELF) (VALUE-000 SELF-000)
        (OLD-VALUE-001 (%TRUTH-VALUE OBJECT-000))
        (NEW-VALUE-000
         (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-000
          (%HOME-CONTEXT OBJECT-000) CL:NIL)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
           SGT-PROPOSITIONS-STELLA-CS-VALUE)))
        (CL:SETF (%TRUTH-VALUE OBJECT-000) NEW-VALUE-000)))))
    (CL:T
     (CL:SETF
      (%POSITIVE-SCORE
       (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF)
        CL:NIL))
      WEIGHT)))))

;;; (DEFUN (TICKLE-CONTEXT CONTEXT) ...)

(CL:DEFUN TICKLE-CONTEXT ()
  (CL:LET*
   ((DESCRIPTION
     (GET-DESCRIPTION SGT-PROPOSITIONS-PL-KERNEL-KB-HIDDEN-RELATION)))
   (ASSERT-PROPERTY DESCRIPTION
    SGT-PROPOSITIONS-PL-KERNEL-KB-HIDDEN-RELATION)
   (UPDATE-PROPERTY DESCRIPTION
    SGT-PROPOSITIONS-PL-KERNEL-KB-HIDDEN-RELATION
    KWD-PROPOSITIONS-RETRACT-TRUE)
   *CONTEXT*))

;;; (DEFUN (TICKLE-INSTANCES CONTEXT) ...)

(CL:DEFUN TICKLE-INSTANCES ()
  (CL:LET* ((TEMP-000 (GET-INSTANCE (WRAP-STRING "HIDDEN-INSTANCE"))))
   (CL:LET*
    ((INSTANCE
      (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000
       (CREATE-LOGIC-INSTANCE SGT-PROPOSITIONS-LOGIC-HIDDEN-INSTANCE
        NULL))))
    (ASSERT-PROPERTY INSTANCE
     SGT-PROPOSITIONS-PL-KERNEL-KB-HIDDEN-RELATION)
    (UPDATE-PROPERTY INSTANCE
     SGT-PROPOSITIONS-PL-KERNEL-KB-HIDDEN-RELATION
     KWD-PROPOSITIONS-RETRACT-TRUE)
    *CONTEXT*)))

;;; (DEFUN REACT-TO-SKOLEM-VALUE-UPDATE ...)

(CL:DEFUN REACT-TO-SKOLEM-VALUE-UPDATE (SKOLEM OLDVALUE NEWVALUE TOPLEVELUPDATE?)
  (CL:LET* ((PROPOSITION (%DEFINING-PROPOSITION SKOLEM)))
   (CL:WHEN
    (CL:AND TOPLEVELUPDATE? (NATIVE-SLOT-PROPOSITION? PROPOSITION))
    (CL:LET*
     ((SLOT
       (NATIVE-RELATION (GET-DESCRIPTION (%OPERATOR PROPOSITION))))
      (NATIVEFIRSTARGVALUE
       (VALUE-OF
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         0))))
     (CL:IF (CL:NOT (CL:EQ NEWVALUE NULL))
      (ASSIGN-NATIVE-SLOT-VALUE NATIVEFIRSTARGVALUE SLOT NEWVALUE)
      (DROP-NATIVE-SLOT-VALUE NATIVEFIRSTARGVALUE SLOT OLDVALUE))))
   (CL:WHEN (CL:NOT (EQL? OLDVALUE NEWVALUE))
    (BUMP-MEMOIZATION-TIMESTAMP KWD-PROPOSITIONS-KB-UPDATE)
    (CL:WHEN
     (CL:OR
      (CL:AND (CL:NOT (CL:EQ NEWVALUE NULL))
       (ISA? NEWVALUE SGT-PROPOSITIONS-LOGIC-DESCRIPTION))
      (META-PROPOSITION? PROPOSITION))
     (BUMP-MEMOIZATION-TIMESTAMP KWD-PROPOSITIONS-META-KB-UPDATE))
    (CL:WHEN (CL:NOT (CL:EQ OLDVALUE NULL))
     (UPDATE-LINKS-AND-TIMESTAMPS PROPOSITION
      KWD-PROPOSITIONS-RETRACT-TRUE))
    (CL:WHEN (CL:NOT (CL:EQ NEWVALUE NULL))
     (UPDATE-LINKS-AND-TIMESTAMPS PROPOSITION
      KWD-PROPOSITIONS-ASSERT-TRUE)))))

;;; (DEFUN (NATIVE-SLOT-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN NATIVE-SLOT-PROPOSITION? (SELF)
  (CL:LET* ((ARGUMENTS (%ARGUMENTS SELF)))
   (CL:WHEN (CL:= (CL:THE CL:FIXNUM (LENGTH ARGUMENTS)) 0)
    (CL:RETURN-FROM NATIVE-SLOT-PROPOSITION? CL:NIL))
   (CL:LET*
    ((FIRSTARG
      (CL:IF
       (CL:NOT
        (CL:EQ
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0)
         NULL))
       (VALUE-OF
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0))
       NULL)))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ FIRSTARG NULL))
      (ISA? FIRSTARG SGT-PROPOSITIONS-STELLA-THING))
     (CL:LET* ((DESCRIPTION (GET-DESCRIPTION (%OPERATOR SELF))))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ DESCRIPTION NULL))
        (CL:NOT (CL:EQ (NATIVE-RELATION DESCRIPTION) NULL))
        (ISA? (NATIVE-RELATION DESCRIPTION)
         SGT-PROPOSITIONS-STELLA-STORAGE-SLOT))
       (CL:RETURN-FROM NATIVE-SLOT-PROPOSITION? CL:T))))
    CL:NIL)))

;;; (DEFUN (UPDATE-NATIVE-SLOT-PROPOSITION (CONS OF PROPOSITION)) ...)

(CL:DEFUN UPDATE-NATIVE-SLOT-PROPOSITION (PROPOSITION UPDATEMODE)
  (CL:LET*
   ((SLOT
     (NATIVE-RELATION
      (SURROGATE-TO-DESCRIPTION (%OPERATOR PROPOSITION))))
    (OBJECT
     (VALUE-OF
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (VALUE
     (VALUE-OF
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       1))))
   (CL:COND
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
     (CL:WHEN *CLIPPINGENABLED?* (CLEAR-NATIVE-SLOT-VALUE OBJECT SLOT))
     (ASSIGN-NATIVE-SLOT-VALUE OBJECT SLOT VALUE))
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
     (DROP-NATIVE-SLOT-VALUE OBJECT SLOT VALUE))
    (CL:T
     (CL:WARN
      "Illegal update to native slot value.  Mode:  `~A'~%   Proposition:  `~A'~%"
      UPDATEMODE PROPOSITION)))
   NIL))

;;; (DEFUN ASSIGN-NATIVE-SLOT-VALUE ...)

(CL:DEFUN ASSIGN-NATIVE-SLOT-VALUE (SELF SLOT VALUE)
  (CL:WHEN (SKOLEM? VALUE) (CL:RETURN-FROM ASSIGN-NATIVE-SLOT-VALUE))
  (CL:LET* ((OLDVALUE (READ-SLOT-VALUE SELF SLOT)))
   (CL:WHEN (EQL? OLDVALUE VALUE)
    (CL:RETURN-FROM ASSIGN-NATIVE-SLOT-VALUE))
   (CL:WHEN (CL:NOT (CL:EQ OLDVALUE NULL))
    (SIGNAL-UNIFICATION-CLASH OLDVALUE VALUE))
   (PUT-SLOT-VALUE SELF SLOT VALUE)))

;;; (DEFUN CLEAR-NATIVE-SLOT-VALUE ...)

(CL:DEFUN CLEAR-NATIVE-SLOT-VALUE (OBJECT SLOT)
  (PUT-SLOT-VALUE OBJECT SLOT NULL))

;;; (DEFUN DROP-NATIVE-SLOT-VALUE ...)

(CL:DEFUN DROP-NATIVE-SLOT-VALUE (SELF SLOT VALUE)
  (CL:LET* ((OLDVALUE (READ-SLOT-VALUE SELF SLOT)))
   (CL:WHEN (EQL? VALUE OLDVALUE) (CLEAR-NATIVE-SLOT-VALUE SELF SLOT))))

;;; (DEFUN (LOOKUP-SLOTREF-ON-INSTANCE SURROGATE) ...)

(CL:DEFUN LOOKUP-SLOTREF-ON-INSTANCE (TERM SLOTNAME)
  (CL:LET* ((TERMTYPE NULL))
   (CL:SETQ TERMTYPE (SAFE-LOGICAL-TYPE TERM))
   (CL:WHEN (CL:EQ TERMTYPE NULL)
    (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE NULL))
   (CL:WHEN
    (CL:OR (CL:EQ (%SURROGATE-VALUE TERMTYPE) NULL)
     (CL:NOT
      (ISA? (%SURROGATE-VALUE TERMTYPE) SGT-PROPOSITIONS-STELLA-CLASS))
     (CL:EQ TERMTYPE SGT-PROPOSITIONS-STELLA-THING))
    (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE NULL))
   (CL:WHEN (CL:NOT (CL:EQ (LOOKUP-FUNCTION SLOTNAME) NULL))
    (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE NULL))
   (CL:LET* ((SURROGATE (LOOKUP-SLOTREF TERMTYPE SLOTNAME)))
    (CL:WHEN (CL:NOT (CL:EQ SURROGATE NULL))
     (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE SURROGATE))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM)
       SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
      (CL:PROGN
       (CL:LET*
        ((PROP NULL)
         (ITER-000
          (ALLOCATE-ITERATOR
           (UNFILTERED-DEPENDENT-ISA-PROPOSITIONS TERM))))
        (CL:LOOP WHILE (NEXT? ITER-000) DO
         (CL:SETQ PROP (%VALUE ITER-000))
         (CL:WHEN (CL:EQ (%KIND PROP) KWD-PROPOSITIONS-ISA)
          (CL:SETQ SURROGATE
           (LOOKUP-SLOTREF (%OPERATOR PROP) SLOTNAME))
          (CL:WHEN (CL:NOT (CL:EQ SURROGATE NULL))
           (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE SURROGATE)))))))
     (CL:T))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM)
       SGT-PROPOSITIONS-LOGIC-SKOLEM)
      (CL:PROGN
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ (%DEFINING-PROPOSITION TERM) NULL))
         (ISA? (%OPERATOR (%DEFINING-PROPOSITION TERM))
          SGT-PROPOSITIONS-STELLA-SURROGATE))
        (CL:LET*
         ((DESCRIPTION
           (GET-DESCRIPTION (%OPERATOR (%DEFINING-PROPOSITION TERM)))))
         (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
          (CL:SETQ TERMTYPE (LAST (%IO-VARIABLE-TYPES DESCRIPTION)))
          (CL:SETQ SURROGATE (LOOKUP-SLOTREF TERMTYPE SLOTNAME))
          (CL:WHEN (CL:NOT (CL:EQ SURROGATE NULL))
           (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE SURROGATE)))))))
     (CL:T))
    NULL)))

;;; (DEFUN (UNBOUND? BOOLEAN) ...)

(CL:DEFUN UNBOUND? (SKOLEM)
  (CL:EQ
   (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SKOLEM) (%HOME-CONTEXT SKOLEM)
    CL:NIL)
   NULL))

;;; (DEFUN (VALUE-OF OBJECT) ...)

(CL:DEFUN VALUE-OF (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:IF
       (CL:EQ
        (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SELF) (%HOME-CONTEXT SELF)
         CL:NIL)
        NULL)
       SELF
       (VALUE-OF
        (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SELF) (%HOME-CONTEXT SELF)
         CL:NIL)))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (SURROGATE.VALUE-OF SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-RELATION)
     (CL:PROGN (RELATION.VALUE-OF SELF)))
    (CL:T SELF))))

;;; (DEFUN (SURROGATE.VALUE-OF OBJECT) ...)

(CL:DEFUN SURROGATE.VALUE-OF (SELF)
  (CL:LET* ((VALUE (%SURROGATE-VALUE SELF)))
   (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (VALUE-OF VALUE)
    (CL:PROGN
     (CL:WHEN (DOTTED-STRING? (%SYMBOL-NAME SELF))
      (CL:LET* ((SLOT (STRING-TO-SLOT (%SYMBOL-NAME SELF))))
       (CL:WHEN (CL:NOT (CL:EQ SLOT NULL))
        (CL:RETURN-FROM SURROGATE.VALUE-OF (VALUE-OF SLOT)))))
     (CL:WHEN (CL:NOT *SUPPRESSNONLOGICOBJECTWARNING?*)
      (SIGNAL-UNDEFINED-TERM (WRAP-STRING (%SYMBOL-NAME SELF))))
     NULL))))

;;; (DEFUN (RELATION.VALUE-OF DESCRIPTION) ...)

(CL:DEFUN RELATION.VALUE-OF (SELF)
  (CL:LET*
   ((DESCRIPTION
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL)))
   (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:RETURN-FROM RELATION.VALUE-OF DESCRIPTION))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
      SGT-PROPOSITIONS-STELLA-RELATION)
     (CL:PROGN (CL:SETQ DESCRIPTION (GET-DESCRIPTION SELF))))
    (CL:T))
   (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:RETURN-FROM RELATION.VALUE-OF DESCRIPTION))
   (CL:WHEN (CL:NOT *SUPPRESSNONLOGICOBJECTWARNING?*)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING)
      "WARNING: value-of: encountered missing description on class or relation "
      (NAME SELF) EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
      KWD-PROPOSITIONS-WARNING)))
   NULL))

;;; (DEFUN (EQUIVALENT-VALUE-OF OBJECT) ...)

(CL:DEFUN EQUIVALENT-VALUE-OF (SELF)
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM EQUIVALENT-VALUE-OF NULL))
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
    (CL:PROGN
     (CL:IF
      (CL:NOT
       (CL:EQ
        (ACCESS-IN-CONTEXT
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
          SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE NULL)
         (%HOME-CONTEXT SELF) CL:NIL)
        NULL))
      (EQUIVALENT-VALUE-OF
       (ACCESS-IN-CONTEXT
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE NULL)
        (%HOME-CONTEXT SELF) CL:NIL))
      SELF)))
   (CL:T SELF)))

;;; (DEFSPECIAL *COMPUTEDQUERY?* ...)

(CL:DEFVAR *COMPUTEDQUERY?* CL:NIL
  "Used to signal 'ground-value-of' that it can
call 'bound-to' safely.")

;;; (DEFUN (GROUND-VALUE-OF OBJECT) ...)

(CL:DEFUN GROUND-VALUE-OF (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN
      (CL:LET* ((VALUE NULL))
       (CL:WHEN
        (CL:AND (DEFINED? (%BOUND-TO-OFFSET SELF)) *COMPUTEDQUERY?*)
        (CL:SETQ VALUE
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY
            (%VARIABLE-BINDINGS
             (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
          (CL:THE CL:FIXNUM (%BOUND-TO-OFFSET SELF)))))
       (CL:WHEN (CL:EQ VALUE NULL)
        (CL:SETQ VALUE
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SELF) (%HOME-CONTEXT SELF)
          CL:NIL)))
       (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (GROUND-VALUE-OF VALUE)
        NULL))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET*
       ((VALUE
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SELF) (%HOME-CONTEXT SELF)
          CL:NIL)))
       (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (GROUND-VALUE-OF VALUE)
        NULL))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((VALUE (%SURROGATE-VALUE SELF)))
       (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (GROUND-VALUE-OF VALUE)
        NULL))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-RELATION)
     (CL:PROGN
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL)))
    (CL:T SELF))))

;;; (DEFUN (SKOLEM? BOOLEAN) ...)

(CL:DEFUN SKOLEM? (SELF)
  (CL:AND (CL:NOT (CL:EQ SELF NULL))
   (ISA? SELF SGT-PROPOSITIONS-LOGIC-SKOLEM)))

;;; (DEFUN (VARIABLE? BOOLEAN) ...)

(CL:DEFUN VARIABLE? (SELF)
  (CL:AND (CL:NOT (CL:EQ SELF NULL))
   (ISA? SELF SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)))

;;; (DEFUN (NATIVE-VALUE? BOOLEAN) ...)

(CL:DEFUN NATIVE-VALUE? (SELF)
  (CL:IF (CL:NOT (CL:EQ SELF NULL))
   (CL:NOT (ISA? SELF SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)) CL:NIL))

;;; (DEFUN (NATIVE-VALUE-OF OBJECT) ...)

(CL:DEFUN NATIVE-VALUE-OF (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN
      (CL:LET* ((VALUE (GROUND-VALUE-OF SELF)))
       (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (NATIVE-VALUE-OF VALUE)
        NULL))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET*
       ((VALUE
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SELF) (%HOME-CONTEXT SELF)
          CL:NIL)))
       (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (NATIVE-VALUE-OF VALUE)
        NULL))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN NULL))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((VALUE (%SURROGATE-VALUE SELF)))
       (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (NATIVE-VALUE-OF VALUE)
        NULL))))
    (CL:T SELF))))

;;; (DEFUN (INNERMOST-VARIABLE-OF PATTERN-VARIABLE) ...)

(CL:DEFUN INNERMOST-VARIABLE-OF (SELF)
  (CL:LOOP
   (CL:LET* ((TIGHTESTVARIABLE SELF) (VALUE NULL))
    (CL:LOOP
     (CL:SETQ VALUE
      (ACCESS-IN-CONTEXT (%VARIABLE-VALUE TIGHTESTVARIABLE)
       (%HOME-CONTEXT TIGHTESTVARIABLE) CL:NIL))
     (CL:IF (CL:AND (CL:NOT (CL:EQ VALUE NULL)) (VARIABLE? VALUE))
      (CL:SETQ TIGHTESTVARIABLE VALUE)
      (CL:RETURN-FROM INNERMOST-VARIABLE-OF TIGHTESTVARIABLE))))))

;;; (DEFUN (INNERMOST-OF OBJECT) ...)

(CL:DEFUN INNERMOST-OF (SELF)
  (CL:IF (DESCRIPTION-MODE?)
   (CL:LET*
    ((NEXTVALUE SELF) (TIGHTESTVARIABLE NULL) (EQUIVALENT NULL))
    (CL:LOOP
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NEXTVALUE)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
        (CL:PROGN
         (CL:SETQ EQUIVALENT
          (ACCESS-IN-CONTEXT (%VARIABLE-VALUE NEXTVALUE)
           (%HOME-CONTEXT NEXTVALUE) CL:NIL))
         (CL:WHEN (CL:EQ EQUIVALENT NULL)
          (CL:RETURN-FROM INNERMOST-OF NEXTVALUE))
         (CL:SETQ TIGHTESTVARIABLE NEXTVALUE)))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
        (CL:PROGN (CL:RETURN-FROM INNERMOST-OF NEXTVALUE)))
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
        (CL:PROGN (CL:RETURN-FROM INNERMOST-OF TIGHTESTVARIABLE)))
       ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
        (CL:PROGN (CL:RETURN-FROM INNERMOST-OF NEXTVALUE)))
       (CL:T (CL:RETURN-FROM INNERMOST-OF NEXTVALUE))))
     (CL:SETQ NEXTVALUE EQUIVALENT)))
   (CL:LET* ((TIGHTESTVALUE SELF) (EQUIVALENT NULL))
    (CL:LOOP
     (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE TIGHTESTVALUE)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-001 SGT-PROPOSITIONS-LOGIC-SKOLEM)
        (CL:PROGN
         (CL:WHEN
          (CL:EQ
           (ACCESS-IN-CONTEXT (%VARIABLE-VALUE TIGHTESTVALUE)
            (%HOME-CONTEXT TIGHTESTVALUE) CL:NIL)
           NULL)
          (CL:RETURN-FROM INNERMOST-OF TIGHTESTVALUE))
         (CL:SETQ EQUIVALENT
          (ACCESS-IN-CONTEXT (%VARIABLE-VALUE TIGHTESTVALUE)
           (%HOME-CONTEXT TIGHTESTVALUE) CL:NIL))))
       ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
        (CL:PROGN
         (CL:WHEN (CL:EQ (%SURROGATE-VALUE TIGHTESTVALUE) NULL)
          (CL:RETURN-FROM INNERMOST-OF TIGHTESTVALUE))
         (CL:SETQ EQUIVALENT (%SURROGATE-VALUE TIGHTESTVALUE))))
       (CL:T (CL:RETURN-FROM INNERMOST-OF TIGHTESTVALUE))))
     (CL:SETQ TIGHTESTVALUE EQUIVALENT)))))

;;; (DEFGLOBAL *SKOLEM-ID-COUNTER* ...)

(CL:DEFVAR *SKOLEM-ID-COUNTER* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *SKOLEM-ID-COUNTER*))

;;; (DEFSPECIAL *VARIABLEIDCOUNTER* ...)

(CL:DEFVAR *VARIABLEIDCOUNTER* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *VARIABLEIDCOUNTER*))

;;; (DEFUN (YIELD-ANONYMOUS-SKOLEM-NAME SYMBOL) ...)

(CL:DEFUN YIELD-ANONYMOUS-SKOLEM-NAME (VARIABLE?)
  (CL:LET*
   ((SUFFIX
     (CL:IF VARIABLE?
      (INTEGER-TO-STRING
       (CL:SETQ *VARIABLEIDCOUNTER* (CL:1+ *VARIABLEIDCOUNTER*)))
      (INTEGER-TO-STRING
       (CL:SETQ *SKOLEM-ID-COUNTER* (CL:1+ *SKOLEM-ID-COUNTER*))))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SUFFIX))
   (INTERN-SYMBOL
    (CONCATENATE (CL:IF VARIABLE? "?V" "SK")
     (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LENGTH SUFFIX)) 1) "0" "")
     SUFFIX))))

;;; (DEFSPECIAL *FREESKOLEMS* ...)

(CL:DEFVAR *FREESKOLEMS* NULL
  "Cons-list of top-level existentially-quantified skolems.")

;;; (DEFUN (HELP-CREATE-SKOLEM SKOLEM) ...)

(CL:DEFUN HELP-CREATE-SKOLEM (SELF TYPE NAME ASSERTISA?)
  (CL:SETQ TYPE (UNWRAP-WRAPPED-TYPE TYPE))
  (CL:WHEN (CL:EQ NAME NULL)
   (CL:SETQ NAME (YIELD-ANONYMOUS-SKOLEM-NAME (VARIABLE? SELF))))
  (CL:SETF (%SKOLEM-NAME SELF) NAME)
  (CL:WHEN (CL:AND ASSERTISA? (CL:NOT (CL:EQ TYPE NULL)))
   (ASSERT-ISA-PROPOSITION SELF TYPE))
  SELF)

;;; (DEFUN (CREATE-SKOLEM SKOLEM) ...)

(CL:DEFUN CREATE-SKOLEM (TYPE NAME)
  (CL:LET* ((SKOLEM (NEW-SKOLEM)))
   (CL:WHEN (CL:NOT (CL:EQ *FREESKOLEMS* NULL))
    (CL:SETQ *FREESKOLEMS* (CONS SKOLEM *FREESKOLEMS*)))
   (HELP-CREATE-SKOLEM SKOLEM TYPE NAME CL:T) SKOLEM))

;;; (DEFUN (CREATE-VARIABLE PATTERN-VARIABLE) ...)

(CL:DEFUN CREATE-VARIABLE (TYPE NAME ASSERTISA?)
  (CL:LET* ((EVALUATIONMODE *EVALUATIONMODE*))
   (CL:LET* ((*EVALUATIONMODE* EVALUATIONMODE))
    (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
    (CL:WHEN (CL:AND ASSERTISA? (CL:NOT (DESCRIPTION-MODE?)))
     (CL:SETQ *EVALUATIONMODE* KWD-PROPOSITIONS-DESCRIPTION))
    (HELP-CREATE-SKOLEM (NEW-PATTERN-VARIABLE) TYPE NAME ASSERTISA?))))

;;; (DEFUN (CREATE-VARIABLE-OR-SKOLEM SKOLEM) ...)

(CL:DEFUN CREATE-VARIABLE-OR-SKOLEM (TYPE NAME)
  (CL:IF (DESCRIPTION-MODE?) (CREATE-VARIABLE TYPE NAME CL:NIL)
   (CL:LET* ((SKOLEM (NEW-SKOLEM)))
    (CL:LET* ((*INVISIBLEASSERTION?* CL:T))
     (CL:DECLARE (CL:SPECIAL *INVISIBLEASSERTION?*))
     (HELP-CREATE-SKOLEM SKOLEM TYPE NAME CL:NIL))
    SKOLEM)))

;;; (DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQUAL? ((SELF SKOLEM) OTHER)
  (CL:IF (CL:EQ SELF OTHER) (CL:RETURN-FROM OBJECT-EQUAL? CL:T)
   (CL:WHEN (SKOLEM? OTHER)
    (CL:LET*
     ((PROPSELF (%DEFINING-PROPOSITION SELF))
      (PROPOTHER (%DEFINING-PROPOSITION OTHER)))
     (CL:RETURN-FROM OBJECT-EQUAL?
      (CL:AND (CL:NOT (CL:EQ PROPSELF NULL))
       (CL:NOT (CL:EQ PROPOTHER NULL))
       (EQUIVALENT-FUNCTION-PROPOSITIONS? PROPSELF PROPOTHER NULL))))))
  CL:NIL)

;;; (DEFCONSTANT TRUE-TRUTH-VALUE ...)

(CL:DEFVAR TRUE-TRUTH-VALUE NULL
  "Value representing TRUE.")

;;; (DEFCONSTANT FALSE-TRUTH-VALUE ...)

(CL:DEFVAR FALSE-TRUTH-VALUE NULL
  "Value representing FALSE.")

;;; (DEFCONSTANT DEFAULT-TRUE-TRUTH-VALUE ...)

(CL:DEFVAR DEFAULT-TRUE-TRUTH-VALUE NULL
  "Value representing DEFAULT-TRUE.")

;;; (DEFCONSTANT DEFAULT-FALSE-TRUTH-VALUE ...)

(CL:DEFVAR DEFAULT-FALSE-TRUTH-VALUE NULL
  "Value representing DEFAULT-FALSE.")

;;; (DEFCONSTANT UNKNOWN-TRUTH-VALUE ...)

(CL:DEFVAR UNKNOWN-TRUTH-VALUE NULL
  "Value representing UNKNOWN.  Needed for those cases
where we need a non-NULL truth value to represents UNKNOWN.")

;;; (DEFCONSTANT INCONSISTENT-TRUTH-VALUE ...)

(CL:DEFVAR INCONSISTENT-TRUTH-VALUE NULL
  "Value representing a contradiction.")

;;; (DEFUN (TRUE? BOOLEAN) ...)

(CL:DEFUN TRUE? (SELF)
  "Return true if `self' is true (or default-true if we are
considering default assertions)."
  (CL:LET*
   ((TRUTHVALUE
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF)
      CL:NIL)))
   (CL:COND
    ((CL:EQ TRUTHVALUE TRUE-TRUTH-VALUE) (CL:RETURN-FROM TRUE? CL:T))
    ((CL:EQ TRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
     (CL:WHEN (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)
      (CL:RETURN-FROM TRUE? CL:T)))
    ((CL:AND (CL:NOT (CL:EQ TRUTHVALUE NULL))
      (CL:EQ (%POLARITY TRUTHVALUE) KWD-PROPOSITIONS-TRUE)
      (CL:OR (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)
       (CL:EQ (%STRENGTH TRUTHVALUE) KWD-PROPOSITIONS-STRICT)))
     (CL:RETURN-FROM TRUE? CL:T)))
   CL:NIL))

;;; (DEFUN (FALSE? BOOLEAN) ...)

(CL:DEFUN FALSE? (SELF)
  "Return true if `self' is false (or default-false if we are
considering default assertions)."
  (CL:LET*
   ((TRUTHVALUE
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF)
      CL:NIL)))
   (CL:COND
    ((CL:EQ TRUTHVALUE FALSE-TRUTH-VALUE) (CL:RETURN-FROM FALSE? CL:T))
    ((CL:EQ TRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE)
     (CL:WHEN (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)
      (CL:RETURN-FROM FALSE? CL:T)))
    ((CL:AND (CL:NOT (CL:EQ TRUTHVALUE NULL))
      (CL:EQ (%POLARITY TRUTHVALUE) KWD-PROPOSITIONS-FALSE)
      (CL:OR (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)
       (CL:EQ (%STRENGTH TRUTHVALUE) KWD-PROPOSITIONS-STRICT)))
     (CL:RETURN-FROM FALSE? CL:T)))
   CL:NIL))

;;; (DEFUN (UNKNOWN? BOOLEAN) ...)

(CL:DEFUN UNKNOWN? (SELF)
  "Return true if the truth of `self' is unknown."
  (CL:LET*
   ((TV
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF)
      CL:NIL)))
   (CL:OR (CL:OR (CL:EQ TV UNKNOWN-TRUTH-VALUE) (CL:EQ TV NULL))
    (CL:AND *DONTUSEDEFAULTKNOWLEDGE?*
     (CL:OR (CL:EQ TV DEFAULT-TRUE-TRUTH-VALUE)
      (CL:EQ TV DEFAULT-FALSE-TRUTH-VALUE)))
    (CL:EQ TV INCONSISTENT-TRUTH-VALUE))))

;;; (DEFUN (INCONSISTENT? BOOLEAN) ...)

(CL:DEFUN INCONSISTENT? (SELF)
  "Return true if `self' is inconsistent (true and false)."
  (CL:EQ
   (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) CL:NIL)
   INCONSISTENT-TRUTH-VALUE))

;;; (DEFUN (DEFAULT-TRUE? BOOLEAN) ...)

(CL:DEFUN DEFAULT-TRUE? (SELF)
  "Return true if `self' is default true."
  (CL:EQ
   (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) CL:NIL)
   DEFAULT-TRUE-TRUTH-VALUE))

;;; (DEFUN (DEFAULT-FALSE? BOOLEAN) ...)

(CL:DEFUN DEFAULT-FALSE? (SELF)
  "Return true if `self' is default false."
  (CL:EQ
   (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) CL:NIL)
   DEFAULT-FALSE-TRUTH-VALUE))

;;; (DEFUN (DEFAULTIFY-TRUTH-VALUE TRUTH-VALUE) ...)

(CL:DEFUN DEFAULTIFY-TRUTH-VALUE (TRUE? BYDEFAULT?)
  (CL:IF TRUE?
   (CL:IF BYDEFAULT? DEFAULT-TRUE-TRUTH-VALUE TRUE-TRUTH-VALUE)
   (CL:IF BYDEFAULT? DEFAULT-FALSE-TRUTH-VALUE FALSE-TRUTH-VALUE)))

;;; (DEFUN (CONJOIN-TRUTH-VALUES TRUTH-VALUE) ...)

(CL:DEFUN CONJOIN-TRUTH-VALUES (TV1 TV2)
  "Return the logical conjunction of truth values `tv1' and `tv2'."
  (CL:COND
   ((CL:OR (CL:EQ TV1 INCONSISTENT-TRUTH-VALUE)
     (CL:EQ TV2 INCONSISTENT-TRUTH-VALUE))
    INCONSISTENT-TRUTH-VALUE)
   ((CL:OR (CL:EQ TV1 FALSE-TRUTH-VALUE) (CL:EQ TV2 FALSE-TRUTH-VALUE))
    FALSE-TRUTH-VALUE)
   ((CL:AND (CL:EQ TV1 DEFAULT-FALSE-TRUTH-VALUE)
     (CL:EQ TV2 DEFAULT-TRUE-TRUTH-VALUE))
    UNKNOWN-TRUTH-VALUE)
   ((CL:AND (CL:EQ TV1 DEFAULT-TRUE-TRUTH-VALUE)
     (CL:EQ TV2 DEFAULT-FALSE-TRUTH-VALUE))
    UNKNOWN-TRUTH-VALUE)
   ((CL:OR (CL:EQ TV1 NULL) (CL:EQ TV1 UNKNOWN-TRUTH-VALUE)
     (CL:EQ TV2 NULL) (CL:EQ TV2 UNKNOWN-TRUTH-VALUE))
    UNKNOWN-TRUTH-VALUE)
   ((CL:OR (CL:EQ TV1 DEFAULT-FALSE-TRUTH-VALUE)
     (CL:EQ TV2 DEFAULT-FALSE-TRUTH-VALUE))
    DEFAULT-FALSE-TRUTH-VALUE)
   ((CL:OR (CL:EQ TV1 DEFAULT-TRUE-TRUTH-VALUE)
     (CL:EQ TV2 DEFAULT-TRUE-TRUTH-VALUE))
    DEFAULT-TRUE-TRUTH-VALUE)
   (CL:T TRUE-TRUTH-VALUE)))

;;; (DEFUN (DISJOIN-TRUTH-VALUES TRUTH-VALUE) ...)

(CL:DEFUN DISJOIN-TRUTH-VALUES (TV1 TV2)
  "Return the logical disjunction of truth values `tv1' and `tv2'."
  (CL:COND
   ((CL:OR (CL:EQ TV1 TRUE-TRUTH-VALUE) (CL:EQ TV2 TRUE-TRUTH-VALUE))
    TRUE-TRUTH-VALUE)
   ((CL:OR (CL:EQ TV1 DEFAULT-TRUE-TRUTH-VALUE)
     (CL:EQ TV2 DEFAULT-TRUE-TRUTH-VALUE))
    DEFAULT-TRUE-TRUTH-VALUE)
   ((CL:OR (CL:EQ TV1 NULL) (CL:EQ TV1 UNKNOWN-TRUTH-VALUE)
     (CL:EQ TV2 NULL) (CL:EQ TV2 UNKNOWN-TRUTH-VALUE))
    UNKNOWN-TRUTH-VALUE)
   ((CL:OR (CL:EQ TV1 DEFAULT-FALSE-TRUTH-VALUE)
     (CL:EQ TV2 DEFAULT-FALSE-TRUTH-VALUE))
    DEFAULT-FALSE-TRUTH-VALUE)
   (CL:T FALSE-TRUTH-VALUE)))

;;; (DEFUN (INVERT-TRUTH-VALUE TRUTH-VALUE) ...)

(CL:DEFUN INVERT-TRUTH-VALUE (SELF)
  "Return the logical negation of `self'."
  (CL:COND ((CL:EQ SELF TRUE-TRUTH-VALUE) FALSE-TRUTH-VALUE)
   ((CL:EQ SELF DEFAULT-TRUE-TRUTH-VALUE) DEFAULT-FALSE-TRUTH-VALUE)
   ((CL:EQ SELF FALSE-TRUTH-VALUE) TRUE-TRUTH-VALUE)
   ((CL:EQ SELF DEFAULT-FALSE-TRUTH-VALUE) DEFAULT-TRUE-TRUTH-VALUE)
   ((CL:EQ SELF INCONSISTENT-TRUTH-VALUE) INCONSISTENT-TRUTH-VALUE)
   (CL:T UNKNOWN-TRUTH-VALUE)))

;;; (DEFUN (WEAKEN-TRUTH-VALUE TRUTH-VALUE) ...)

(CL:DEFUN WEAKEN-TRUTH-VALUE (TV1 TV2)
  "If `tv2' has lesser strength than `tv1', adapt the strength of `tv1' (not
its value!) and return the result.  Otherwise, return `tv1' unmodified."
  (CL:COND
   ((CL:OR (CL:EQ TV2 UNKNOWN-TRUTH-VALUE) (CL:EQ TV2 NULL))
    (CL:RETURN-FROM WEAKEN-TRUTH-VALUE UNKNOWN-TRUTH-VALUE))
   ((CL:OR (CL:EQ TV2 DEFAULT-TRUE-TRUTH-VALUE)
     (CL:EQ TV2 DEFAULT-FALSE-TRUTH-VALUE))
    (CL:WHEN
     (CL:OR (CL:EQ TV1 TRUE-TRUTH-VALUE)
      (CL:EQ TV1 DEFAULT-TRUE-TRUTH-VALUE))
     (CL:RETURN-FROM WEAKEN-TRUTH-VALUE DEFAULT-TRUE-TRUTH-VALUE))
    (CL:WHEN
     (CL:OR (CL:EQ TV1 FALSE-TRUTH-VALUE)
      (CL:EQ TV1 DEFAULT-FALSE-TRUTH-VALUE))
     (CL:RETURN-FROM WEAKEN-TRUTH-VALUE DEFAULT-FALSE-TRUTH-VALUE))))
  TV1)

;;; (DEFUN (STRENGTHEN-TRUTH-VALUE TRUTH-VALUE) ...)

(CL:DEFUN STRENGTHEN-TRUTH-VALUE (TV1 TV2)
  "If `tv2' has greater strength than `tv1', adapt the strength of `tv1' (not
its value!) and return the result.  Otherwise, return `tv1' unmodified."
  (CL:WHEN
   (CL:AND
    (CL:OR (CL:EQ TV2 TRUE-TRUTH-VALUE) (CL:EQ TV2 FALSE-TRUTH-VALUE))
    (CL:OR (CL:EQ TV1 DEFAULT-TRUE-TRUTH-VALUE)
     (CL:EQ TV1 DEFAULT-FALSE-TRUTH-VALUE)))
   (CL:WHEN
    (CL:OR (CL:EQ TV1 TRUE-TRUTH-VALUE)
     (CL:EQ TV1 DEFAULT-TRUE-TRUTH-VALUE))
    (CL:RETURN-FROM STRENGTHEN-TRUTH-VALUE TRUE-TRUTH-VALUE))
   (CL:WHEN
    (CL:OR (CL:EQ TV1 FALSE-TRUTH-VALUE)
     (CL:EQ TV1 DEFAULT-FALSE-TRUTH-VALUE))
    (CL:RETURN-FROM STRENGTHEN-TRUTH-VALUE FALSE-TRUTH-VALUE)))
  TV1)

;;; (DEFUN (TRUE-TRUTH-VALUE? BOOLEAN) ...)

(CL:DEFUN TRUE-TRUTH-VALUE? (SELF)
  "Return TRUE if `self' represents some form of truth."
  (CL:OR (CL:EQ SELF TRUE-TRUTH-VALUE)
   (CL:EQ SELF DEFAULT-TRUE-TRUTH-VALUE)))

;;; (DEFUN (FALSE-TRUTH-VALUE? BOOLEAN) ...)

(CL:DEFUN FALSE-TRUTH-VALUE? (SELF)
  "Return TRUE if `self' represents some form of falsehood."
  (CL:OR (CL:EQ SELF FALSE-TRUTH-VALUE)
   (CL:EQ SELF DEFAULT-FALSE-TRUTH-VALUE)))

;;; (DEFUN (STRICT-TRUTH-VALUE? BOOLEAN) ...)

(CL:DEFUN STRICT-TRUTH-VALUE? (SELF)
  "Return TRUE if `self' is a strict truth value."
  (CL:OR (CL:EQ SELF TRUE-TRUTH-VALUE) (CL:EQ SELF FALSE-TRUTH-VALUE)))

;;; (DEFUN (DEFAULT-TRUTH-VALUE? BOOLEAN) ...)

(CL:DEFUN DEFAULT-TRUTH-VALUE? (SELF)
  "Return TRUE if `self' is a default truth value."
  (CL:OR (CL:EQ SELF DEFAULT-TRUE-TRUTH-VALUE)
   (CL:EQ SELF DEFAULT-FALSE-TRUTH-VALUE)))

;;; (DEFUN (UNKNOWN-TRUTH-VALUE? BOOLEAN) ...)

(CL:DEFUN UNKNOWN-TRUTH-VALUE? (SELF)
  "Return TRUE if `self' represents UNKNOWN."
  (CL:OR (CL:EQ SELF UNKNOWN-TRUTH-VALUE) (CL:EQ SELF NULL)))

;;; (DEFUN (INCONSISTENT-TRUTH-VALUE? BOOLEAN) ...)

(CL:DEFUN INCONSISTENT-TRUTH-VALUE? (SELF)
  "Return TRUE if `self' represents INCONSISTENT."
  (CL:EQ SELF INCONSISTENT-TRUTH-VALUE))

;;; (DEFUN PRINT-TRUTH-VALUE ...)

(CL:DEFUN PRINT-TRUTH-VALUE (SELF STREAM)
  (CL:COND
   ((CL:EQ SELF TRUE-TRUTH-VALUE)
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "TRUE"))
   ((CL:EQ SELF FALSE-TRUTH-VALUE)
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "FALSE"))
   ((CL:EQ SELF DEFAULT-TRUE-TRUTH-VALUE)
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "DEFAULT-TRUE"))
   ((CL:EQ SELF DEFAULT-FALSE-TRUTH-VALUE)
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "DEFAULT-FALSE"))
   ((CL:EQ SELF UNKNOWN-TRUTH-VALUE)
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "UNKNOWN"))
   ((CL:EQ SELF INCONSISTENT-TRUTH-VALUE)
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "INCONSISTENT"))
   (CL:T
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "|i|" (PRIMARY-TYPE SELF)))))

;;; (DEFUN SIGNAL-UNIFICATION-CLASH ...)

(CL:DEFUN SIGNAL-UNIFICATION-CLASH (TERM1 TERM2)
  (CL:IF
   (CL:AND (CL:NOT (CL:EQ TERM1 NULL)) (CL:NOT (CL:EQ TERM2 NULL)))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TERM1
     "' clashes with `" TERM2 "'")
    (CL:ERROR (NEW-CLASH (THE-STRING-READER STREAM-000))))
   (CL:ERROR (NEW-CLASH "Unification clash."))))

;;; (DEFUN SIGNAL-VARIABLE-VALUE-CLASH ...)

(CL:DEFUN SIGNAL-VARIABLE-VALUE-CLASH (SKOLEM VALUE1 VALUE2)
  (CL:IF
   (CL:AND (CL:NOT (CL:EQ VALUE1 NULL)) (CL:NOT (CL:EQ VALUE2 NULL)))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Skolem `" SKOLEM
     "' is equated with multiple values:" EOL "   `" VALUE1 "' and `"
     VALUE2 "'.")
    (CL:ERROR (NEW-CLASH (THE-STRING-READER STREAM-000))))
   (CL:ERROR (NEW-CLASH "Variable value clash."))))

;;; (DEFUN SIGNAL-TRUTH-VALUE-CLASH ...)

(CL:DEFUN SIGNAL-TRUTH-VALUE-CLASH (PROPOSITION)
  (ASSIGN-TRUTH-VALUE PROPOSITION INCONSISTENT-TRUTH-VALUE)
  (CL:COND
   ((CL:EQ *CONTEXT*
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *MODULE*)
      SYM-PROPOSITIONS-LOGIC-META-INFERENCE-CACHE NULL))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "Derived both TRUE and FALSE for the proposition `" PROPOSITION
      "'." EOL
      "   Clash occurred in the meta inference cache for module `"
      *MODULE* "'.")
     (CL:ERROR (NEW-CLASH (THE-STRING-READER STREAM-000)))))
   ((CL:EQ *CONTEXT*
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *MODULE*)
      SYM-PROPOSITIONS-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE NULL))
    (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
      "Derived both TRUE and FALSE for the proposition `" PROPOSITION
      "'." EOL
      "   Clash occurred in the default inference cache for module `"
      *MODULE* "'.")
     (CL:ERROR (NEW-CLASH (THE-STRING-READER STREAM-001)))))
   ((CL:EQ *CONTEXT* *MODULE*)
    (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002)
      "Derived both TRUE and FALSE for the proposition `" PROPOSITION
      "'." EOL "   Clash occurred in module `" *MODULE* "'.")
     (CL:ERROR (NEW-CLASH (THE-STRING-READER STREAM-002)))))
   (CL:T
    (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-003)
      "Derived both TRUE and FALSE for the proposition `" PROPOSITION
      "'." EOL "   Clash occurred in the world `" *CONTEXT*
      "' in module `" *MODULE* "'.")
     (CL:ERROR (NEW-CLASH (THE-STRING-READER STREAM-003)))))))

;;; (DEFUN (LOGICAL-TYPE TYPE) ...)

(CL:DEFUN LOGICAL-TYPE (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:COND
       ((CL:AND (MONADIC? SELF)
         (%WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
           SYM-PROPOSITIONS-LOGIC-IOTA? FALSE-WRAPPER)))
        (%SKOLEM-TYPE
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IO-VARIABLES SELF)))
          0)))
       ((CL:AND (MONADIC? SELF)
         (CL:> (%ARRAY-SIZE (%IO-VARIABLES SELF)) 0)
         (CL:NOT
          (CL:EQ
           (%SKOLEM-TYPE
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%THE-ARRAY (%IO-VARIABLES SELF)))
             0))
           NULL))
         (CLASS-DESCRIPTION?
          (SURROGATE-TO-DESCRIPTION
           (%SKOLEM-TYPE
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%THE-ARRAY (%IO-VARIABLES SELF)))
             0)))))
        SGT-PROPOSITIONS-PL-KERNEL-KB-CONCEPT)
       (CL:T SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION))))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN
      (CL:LET* ((TYPE (%SKOLEM-TYPE SELF)))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ TYPE NULL))
         (CL:NOT (CL:EQ TYPE SGT-PROPOSITIONS-STELLA-THING)))
        (CL:RETURN-FROM LOGICAL-TYPE TYPE)))
      (CL:LET*
       ((P NULL)
        (ITER-000
         (ALLOCATE-ITERATOR
          (UNFILTERED-DEPENDENT-ISA-PROPOSITIONS SELF))))
       (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
        (CL:WHEN
         (CL:AND (CL:EQ (%KIND P) KWD-PROPOSITIONS-ISA)
          (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? P)))
         (CL:RETURN-FROM LOGICAL-TYPE (%OPERATOR P)))))
      SGT-PROPOSITIONS-STELLA-THING))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:IF (CL:NOT (CL:EQ (%SKOLEM-TYPE SELF) NULL))
       (%SKOLEM-TYPE SELF) SGT-PROPOSITIONS-STELLA-THING)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN SGT-PROPOSITIONS-STELLA-THING))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER)
     (CL:PROGN (WRAPPER-VALUE-TYPE SELF)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF
       (CL:AND (CL:NOT (CL:EQ (%SURROGATE-VALUE SELF) NULL))
        (CL:NOT (CL:EQ (%SURROGATE-VALUE SELF) BOTTOM)))
       (LOGICAL-TYPE (%SURROGATE-VALUE SELF))
       SGT-PROPOSITIONS-STELLA-THING)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-SET)
     (CL:PROGN SGT-PROPOSITIONS-PL-KERNEL-KB-SET))
    ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
     (CL:PROGN SGT-PROPOSITIONS-PL-KERNEL-KB-CONCEPT))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-SLOT)
     (CL:PROGN
      (CL:IF (BOOLEAN-TYPE? (%SLOT-BASE-TYPE SELF))
       SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION
       SGT-PROPOSITIONS-PL-KERNEL-KB-FUNCTION)))
    (CL:T (PRIMARY-TYPE SELF)))))

;;; (DEFSPECIAL *SUPPRESSUNTYPEDTYPEERROR?* ...)

(CL:DEFVAR *SUPPRESSUNTYPEDTYPEERROR?* CL:NIL
  "Used by 'safe-logical-type' to ask for a type
without signalling an error if none exists.")

;;; (DEFUN (SAFE-LOGICAL-TYPE TYPE) ...)

(CL:DEFUN SAFE-LOGICAL-TYPE (SELF)
  (CL:LET* ((*SUPPRESSUNTYPEDTYPEERROR?* CL:T))
   (CL:DECLARE (CL:SPECIAL *SUPPRESSUNTYPEDTYPEERROR?*))
   (LOGICAL-TYPE SELF)))

;;; (DEFUN (CLASS-LOGICAL-TYPE TYPE) ...)

(CL:DEFUN CLASS-LOGICAL-TYPE (SELF)
  (%CLASS-TYPE SELF))

;;; (DEFUN UNIFY-TYPES ...)

(CL:DEFUN UNIFY-TYPES (TERM1 TERM2)
  (CL:LET* ((TYPE1 (LOGICAL-TYPE TERM1)) (TYPE2 (LOGICAL-TYPE TERM2)))
   (CL:COND
    ((CL:OR (CL:EQ TYPE1 TYPE2)
      (CL:OR (LOGICAL-SUBTYPE-OF? TYPE1 TYPE2)
       (LOGICAL-SUBTYPE-OF? TYPE2 TYPE1))))
    ((CL:EQ TYPE1 SGT-PROPOSITIONS-STELLA-THING)
     (CL:WHEN (ISA? TERM1 SGT-PROPOSITIONS-LOGIC-SKOLEM))
     (CL:SETF (%SKOLEM-TYPE TERM1) TYPE2))
    ((CL:EQ TYPE2 SGT-PROPOSITIONS-STELLA-THING)
     (CL:WHEN (ISA? TERM2 SGT-PROPOSITIONS-LOGIC-SKOLEM)
      (CL:SETF (%SKOLEM-TYPE TERM2) TYPE1)))
    (CL:T (CL:WHEN (BOTTOM? TERM2) (CL:RETURN-FROM UNIFY-TYPES))
     (SIGNAL-UNIFICATION-CLASH TERM1 TERM2)))))

;;; (DEFUN UNIFY-SKOLEM-AND-VALUE ...)

(CL:DEFUN UNIFY-SKOLEM-AND-VALUE (SKOLEM VALUE)
  (CL:LET*
   ((PROP NULL)
    (ITER-000
     (ALLOCATE-ITERATOR
      (UNFILTERED-DEPENDENT-PROPOSITIONS SKOLEM NULL))))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PROP (%VALUE ITER-000))
    (EVALUATE-PROPOSITION PROP))))

;;; (DEFUN BIND-SKOLEM-TO-VALUE ...)

(CL:DEFUN BIND-SKOLEM-TO-VALUE (FROMSKOLEM TOVALUE TOPLEVELUPDATE?)
  (CL:LET*
   ((TYPEISOK? CL:NIL) (TYPE (%SKOLEM-TYPE FROMSKOLEM))
    (EQUATINGPROPOSITION NULL))
   (CL:WHEN (SKOLEM? TOVALUE)
    (CL:SETQ EQUATINGPROPOSITION
     (FIND-EQUATING-PROPOSITION TOVALUE FROMSKOLEM))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ EQUATINGPROPOSITION NULL))
      (DEFAULT-TRUE? EQUATINGPROPOSITION))
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
        "ERROR: Equating two skolems `" FROMSKOLEM "' and `" TOVALUE
        "' by default is not yet supported." EOL "." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
        KWD-PROPOSITIONS-ERROR))
      (CL:ERROR
       (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))))
   (CL:MULTIPLE-VALUE-SETQ (TYPEISOK? TOVALUE)
    (CHECK-COERCED-TYPE? TOVALUE TYPE CL:T))
   (CL:WHEN (CL:NOT TYPEISOK?)
    (CL:SETQ EQUATINGPROPOSITION
     (FIND-EQUATING-PROPOSITION TOVALUE FROMSKOLEM))
    (CL:COND
     ((CL:EQ EQUATINGPROPOSITION NULL)
      (CL:LET* ((*TERMUNDERCONSTRUCTION* *TERMUNDERCONSTRUCTION*))
       (CL:DECLARE (CL:SPECIAL *TERMUNDERCONSTRUCTION*))
       (CL:WHEN (CL:EQ *TERMUNDERCONSTRUCTION* NULL)
        (CL:SETQ *TERMUNDERCONSTRUCTION*
         (%DEFINING-PROPOSITION FROMSKOLEM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING)
         "WARNING: Type check violation: Assigned value `" TOVALUE "'"
         EOL "   to skolem with type `" TYPE "'." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
         KWD-PROPOSITIONS-WARNING))))
     (CL:T (VERIFY-ARGUMENT-TYPES-AND-COUNT EQUATINGPROPOSITION)))))
  (CL:LET*
   ((OBJECT-000 FROMSKOLEM) (VALUE-000 TOVALUE)
    (OLD-VALUE-000 (%VARIABLE-VALUE OBJECT-000))
    (NEW-VALUE-000
     (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
      (%HOME-CONTEXT OBJECT-000) CL:NIL)))
   (CL:WHEN
    (CL:NOT
     (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
      (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
       SGT-PROPOSITIONS-STELLA-CS-VALUE)))
    (CL:SETF (%VARIABLE-VALUE OBJECT-000) NEW-VALUE-000)))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TOVALUE)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET*
       ((EQUIVALENTSKOLEM
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE TOVALUE)
          (%HOME-CONTEXT TOVALUE) CL:NIL)))
       (CL:LOOP (CL:WHEN (CL:EQ EQUIVALENTSKOLEM NULL) (CL:RETURN))
        (CL:COND
         ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE EQUIVALENTSKOLEM)
           SGT-PROPOSITIONS-LOGIC-SKOLEM)
          (CL:PROGN
           (CL:WHEN (CL:EQ EQUIVALENTSKOLEM TOVALUE)
            (CL:LET*
             ((OBJECT-001 FROMSKOLEM) (VALUE-001 NULL)
              (OLD-VALUE-002 (%VARIABLE-VALUE OBJECT-001))
              (NEW-VALUE-001
               (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-001
                (%HOME-CONTEXT OBJECT-001) CL:NIL)))
             (CL:WHEN
              (CL:NOT
               (CL:AND (CL:NOT (CL:EQ OLD-VALUE-002 NULL))
                (CL:EQ (PRIMARY-TYPE OLD-VALUE-002)
                 SGT-PROPOSITIONS-STELLA-CS-VALUE)))
              (CL:SETF (%VARIABLE-VALUE OBJECT-001) NEW-VALUE-001)))
            (CL:RETURN-FROM BIND-SKOLEM-TO-VALUE))
           (CL:SETQ EQUIVALENTSKOLEM
            (ACCESS-IN-CONTEXT (%VARIABLE-VALUE EQUIVALENTSKOLEM)
             (%HOME-CONTEXT EQUIVALENTSKOLEM) CL:NIL))))
         (CL:T (CL:RETURN)))))
      (CL:LET*
       ((OBJECT-002 TOVALUE)
        (VALUE-002 (CONS FROMSKOLEM (VARIABLE-VALUE-INVERSE TOVALUE)))
        (OLD-VALUE-004 (%VARIABLE-VALUE-INVERSE OBJECT-002))
        (NEW-VALUE-002
         (UPDATE-IN-CONTEXT OLD-VALUE-004 VALUE-002
          (%HOME-CONTEXT OBJECT-002) CL:NIL)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-004 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-004)
           SGT-PROPOSITIONS-STELLA-CS-VALUE)))
        (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-002) NEW-VALUE-002)))
      (CL:WHEN (CL:EQ (%SKOLEM-TYPE TOVALUE) NULL)
       (CL:SETF (%SKOLEM-TYPE TOVALUE) (%SKOLEM-TYPE FROMSKOLEM)))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:LET*
       ((OBJECT-003 TOVALUE)
        (VALUE-003 (CONS FROMSKOLEM (VARIABLE-VALUE-INVERSE TOVALUE)))
        (OLD-VALUE-005 (%VARIABLE-VALUE-INVERSE OBJECT-003))
        (NEW-VALUE-003
         (UPDATE-IN-CONTEXT OLD-VALUE-005 VALUE-003
          (%HOME-CONTEXT OBJECT-003) CL:NIL)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-005 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-005)
           SGT-PROPOSITIONS-STELLA-CS-VALUE)))
        (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-003)
         NEW-VALUE-003)))))
    (CL:T
     (CL:LET* ((PROPOSITION (%DEFINING-PROPOSITION FROMSKOLEM)))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ PROPOSITION NULL))
        (REWRAP-ITH-ARGUMENT? TOVALUE PROPOSITION
         (LENGTH (%ARGUMENTS PROPOSITION))))
       (CL:LET*
        ((OBJECT-004 FROMSKOLEM) (VALUE-004 (REWRAP-ARGUMENT TOVALUE))
         (OLD-VALUE-006 (%VARIABLE-VALUE OBJECT-004))
         (NEW-VALUE-004
          (UPDATE-IN-CONTEXT OLD-VALUE-006 VALUE-004
           (%HOME-CONTEXT OBJECT-004) CL:NIL)))
        (CL:WHEN
         (CL:NOT
          (CL:AND (CL:NOT (CL:EQ OLD-VALUE-006 NULL))
           (CL:EQ (PRIMARY-TYPE OLD-VALUE-006)
            SGT-PROPOSITIONS-STELLA-CS-VALUE)))
         (CL:SETF (%VARIABLE-VALUE OBJECT-004) NEW-VALUE-004))))))))
  (HANDLE-OUT-OF-DATE-INFERENCE-CACHE KWD-PROPOSITIONS-ASSERT
   (%DEFINING-PROPOSITION FROMSKOLEM))
  (REACT-TO-KB-UPDATE *CONTEXT* FROMSKOLEM)
  (CL:WHEN (CL:NOT (SKOLEM? TOVALUE))
   (CL:WHEN (CL:NOT (CL:EQ (%DEFINING-PROPOSITION FROMSKOLEM) NULL))
    (REACT-TO-SKOLEM-VALUE-UPDATE FROMSKOLEM NULL TOVALUE
     TOPLEVELUPDATE?))))

;;; (DEFUN UNBIND-SKOLEM-VALUE ...)

(CL:DEFUN UNBIND-SKOLEM-VALUE (SKOLEM TOPLEVELUPDATE?)
  (CL:LET*
   ((OLDVALUE (VALUE-OF SKOLEM))
    (DEFININGPROP (%DEFINING-PROPOSITION SKOLEM)) (EQUATINGPROP NULL))
   (UNLINK-EQUIVALENT-VALUE SKOLEM)
   (CL:SETQ EQUATINGPROP (FIND-EQUATING-PROPOSITION OLDVALUE SKOLEM))
   (CL:COND
    ((CL:NOT (CL:EQ EQUATINGPROP NULL))
     (UPDATE-PROPOSITION-TRUTH-VALUE EQUATINGPROP
      KWD-PROPOSITIONS-RETRACT-TRUE)
     (HANDLE-OUT-OF-DATE-INFERENCE-CACHE KWD-PROPOSITIONS-RETRACT
      EQUATINGPROP))
    (CL:T
     (HANDLE-OUT-OF-DATE-INFERENCE-CACHE KWD-PROPOSITIONS-RETRACT
      DEFININGPROP)))
   (CL:WHEN (CL:NOT (CL:EQ DEFININGPROP NULL))
    (REACT-TO-SKOLEM-VALUE-UPDATE SKOLEM OLDVALUE NULL
     TOPLEVELUPDATE?))))

;;; (DEFUN CONSTRAIN-AS-SUBSET ...)

(CL:DEFUN CONSTRAIN-AS-SUBSET (SET1 SET2)
  (CL:WHEN (CL:> (LENGTH SET1) (LENGTH SET2))
   (SIGNAL-UNIFICATION-CLASH SET1 SET2))
  (CL:LET* ((COPY1 NIL) (COPY2 NIL))
   (CL:LET* ((I2 NULL) (ITER-000 (ALLOCATE-ITERATOR SET2)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ I2 (%VALUE ITER-000))
     (CL:SETQ COPY2 (CONS I2 COPY2))))
   (CL:LET* ((I1 NULL) (ITER-001 (ALLOCATE-ITERATOR SET1)))
    (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ I1 (%VALUE ITER-001))
     (CL:IF (MEMBER? COPY2 I1) (CL:SETQ COPY2 (REMOVE COPY2 I1))
      (CL:SETQ COPY1 (CONS I1 COPY1)))))
   (CL:WHEN (CL:EQ COPY1 NIL) (CL:RETURN-FROM CONSTRAIN-AS-SUBSET))
   (CL:WHEN (CL:= (LENGTH COPY2) 1)
    (CL:LET* ((ITEM1 (%%VALUE COPY1)) (ITEM2 (%%VALUE COPY2)))
     (EQUATE-VALUES ITEM1 ITEM2) (CL:RETURN-FROM CONSTRAIN-AS-SUBSET)))
   (CL:LET* ((SKOLEMCOUNT1 0) (SKOLEMCOUNT2 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM SKOLEMCOUNT1 SKOLEMCOUNT2))
    (CL:LET* ((I1 NULL) (ITER-002 COPY1))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:SETQ I1 (%%VALUE ITER-002))
      (CL:WHEN (SKOLEM? I1)
       (CL:SETQ SKOLEMCOUNT1 (CL:1+ SKOLEMCOUNT1)))
      (CL:SETQ ITER-002 (%%REST ITER-002))))
    (CL:LET* ((I2 NULL) (ITER-003 COPY2))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
      (CL:SETQ I2 (%%VALUE ITER-003))
      (CL:WHEN (SKOLEM? I2)
       (CL:SETQ SKOLEMCOUNT2 (CL:1+ SKOLEMCOUNT2)))
      (CL:SETQ ITER-003 (%%REST ITER-003))))
    (CL:WHEN (CL:= (CL:+ SKOLEMCOUNT1 SKOLEMCOUNT2) 0)
     (SIGNAL-UNIFICATION-CLASH SET1 SET2)))))

;;; (DEFUN EQUATE-COLLECTIONS ...)

(CL:DEFUN EQUATE-COLLECTIONS (COL1 COL2)
  (CL:WHEN (CL:AND (ORDERED? COL1) (ORDERED? COL2))
   (CL:LET*
    ((I1 NULL) (ITER-000 (ALLOCATE-ITERATOR COL1)) (I2 NULL)
     (ITER-001 (ALLOCATE-ITERATOR COL2)))
    (CL:LOOP WHILE (CL:AND (NEXT? ITER-000) (NEXT? ITER-001)) DO
     (CL:SETQ I1 (%VALUE ITER-000)) (CL:SETQ I2 (%VALUE ITER-001))
     (EQUATE-VALUES I1 I2)))
   (CL:RETURN-FROM EQUATE-COLLECTIONS))
  (CL:WHEN (CL:AND (NO-DUPLICATES? COL1) (NO-DUPLICATES? COL2))
   (CONSTRAIN-AS-SUBSET COL1 COL2) (CONSTRAIN-AS-SUBSET COL2 COL1)))

;;; (DEFUN (LOGIC-COLLECTION? BOOLEAN) ...)

(CL:DEFUN LOGIC-COLLECTION? (TERM)
  (TEST-TYPE-ON-INSTANCE? TERM SGT-PROPOSITIONS-STELLA-COLLECTION))

;;; (DEFUN EQUATE-VALUES ...)

(CL:DEFUN EQUATE-VALUES (TERM1 TERM2)
  (CL:COND ((EQL? TERM1 TERM2))
   ((SKOLEM? TERM1) (BIND-SKOLEM-TO-VALUE TERM1 TERM2 CL:NIL))
   ((SKOLEM? TERM2) (BIND-SKOLEM-TO-VALUE TERM2 TERM1 CL:NIL))
   ((CL:AND (STELLA-COLLECTION? TERM1) (STELLA-COLLECTION? TERM2))
    (EQUATE-COLLECTIONS TERM1 TERM2))
   ((CL:AND (ISA? TERM1 SGT-PROPOSITIONS-PL-KERNEL-KB-INTERVAL-CACHE)
     (ISA? TERM2 SGT-PROPOSITIONS-PL-KERNEL-KB-INTERVAL-CACHE))
    (|/PL-KERNEL-KB/UNIFY-INTERVAL-CACHES| TERM1 TERM2
     SGT-PROPOSITIONS-PL-KERNEL-KB->=)
    (|/PL-KERNEL-KB/UNIFY-INTERVAL-CACHES| TERM2 TERM1
     SGT-PROPOSITIONS-PL-KERNEL-KB->=))
   (CL:T (SIGNAL-UNIFICATION-CLASH TERM1 TERM2))))

(CL:DEFMETHOD CONFLICTING-DEFAULT-VALUES ((SELF SKOLEM))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-CONFLICTING-DEFAULT-VALUES NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL ANSWER)))

;;; (DEFUN (UNEQUATE-CONFLICTING-DEFAULT-VALUES? BOOLEAN) ...)

(CL:DEFUN UNEQUATE-CONFLICTING-DEFAULT-VALUES? (NEWEQUATINGPROP)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS NEWEQUATINGPROP))
    (FIRSTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0))
    (FIRSTARGISSKOLEM? (SKOLEM? FIRSTARG))
    (FIRSTARGVALUE (INNERMOST-OF FIRSTARG))
    (SECONDARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1))
    (SECONDARGISSKOLEM? (SKOLEM? SECONDARG))
    (SECONDARGVALUE (INNERMOST-OF SECONDARG))
    (NEWISDEFAULT? (DEFAULT-TRUE? NEWEQUATINGPROP))
    (NEWTRUTHVALUE NULL) (EQUATINGPROP NULL))
   (CL:COND
    ((EQL? FIRSTARGVALUE SECONDARGVALUE)
     (CL:RETURN-FROM UNEQUATE-CONFLICTING-DEFAULT-VALUES? CL:T))
    ((SKOLEM? FIRSTARGVALUE)
     (CL:IF
      (CL:OR (CL:EQ (CONFLICTING-DEFAULT-VALUES FIRSTARGVALUE) NIL)
       (CL:NOT NEWISDEFAULT?))
      (CL:RETURN-FROM UNEQUATE-CONFLICTING-DEFAULT-VALUES? CL:T)
      (CL:RETURN-FROM UNEQUATE-CONFLICTING-DEFAULT-VALUES? CL:NIL)))
    ((SKOLEM? SECONDARGVALUE)
     (CL:IF
      (CL:OR (CL:EQ (CONFLICTING-DEFAULT-VALUES SECONDARGVALUE) NIL)
       (CL:NOT NEWISDEFAULT?))
      (CL:RETURN-FROM UNEQUATE-CONFLICTING-DEFAULT-VALUES? CL:T)
      (CL:RETURN-FROM UNEQUATE-CONFLICTING-DEFAULT-VALUES? CL:NIL))))
   (CL:WHEN (CL:AND FIRSTARGISSKOLEM? SECONDARGISSKOLEM? NEWISDEFAULT?)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "ERROR: Equating two skolems `" FIRSTARG "' and `" SECONDARG
       "' by default is not yet supported." EOL "." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
       KWD-PROPOSITIONS-ERROR))
     (CL:ERROR
      (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   (CL:SETQ NEWTRUTHVALUE (%TRUTH-VALUE NEWEQUATINGPROP))
   (CL:SETF (%TRUTH-VALUE NEWEQUATINGPROP) NULL)
   (CL:WHEN FIRSTARGISSKOLEM?
    (CL:LET* ((*DONTUSEDEFAULTKNOWLEDGE?* CL:T))
     (CL:DECLARE (CL:SPECIAL *DONTUSEDEFAULTKNOWLEDGE?*))
     (CL:SETQ EQUATINGPROP
      (FIND-EQUATING-PROPOSITION FIRSTARGVALUE FIRSTARG)))
    (CL:WHEN (CL:EQ EQUATINGPROP NULL)
     (CL:SETQ EQUATINGPROP
      (FIND-EQUATING-PROPOSITION FIRSTARGVALUE FIRSTARG))
     (CL:LOOP WHILE (CL:NOT (EQL? (VALUE-OF FIRSTARG) FIRSTARGVALUE))
      DO (CL:SETQ FIRSTARG (VALUE-OF FIRSTARG)))
     (CL:LET* ((SKOLEM FIRSTARG))
      (CL:LET*
       ((OBJECT-000 SKOLEM) (VALUE-000 NULL)
        (OLD-VALUE-001 (%VARIABLE-VALUE OBJECT-000))
        (NEW-VALUE-000
         (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-000
          (%HOME-CONTEXT OBJECT-000) CL:NIL)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
           SGT-PROPOSITIONS-STELLA-CS-VALUE)))
        (CL:SETF (%VARIABLE-VALUE OBJECT-000) NEW-VALUE-000)))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SKOLEM)
       SYM-PROPOSITIONS-LOGIC-CONFLICTING-DEFAULT-VALUES
       (CONS EQUATINGPROP (CONFLICTING-DEFAULT-VALUES SKOLEM)) NULL)
      (CL:WHEN NEWISDEFAULT?
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SKOLEM)
        SYM-PROPOSITIONS-LOGIC-CONFLICTING-DEFAULT-VALUES
        (CONS NEWEQUATINGPROP (CONFLICTING-DEFAULT-VALUES SKOLEM))
        NULL)))))
   (CL:WHEN SECONDARGISSKOLEM?
    (CL:LET* ((*DONTUSEDEFAULTKNOWLEDGE?* CL:T))
     (CL:DECLARE (CL:SPECIAL *DONTUSEDEFAULTKNOWLEDGE?*))
     (CL:SETQ EQUATINGPROP
      (FIND-EQUATING-PROPOSITION SECONDARGVALUE SECONDARG)))
    (CL:WHEN (CL:EQ EQUATINGPROP NULL)
     (CL:SETQ EQUATINGPROP
      (FIND-EQUATING-PROPOSITION FIRSTARGVALUE FIRSTARG))
     (CL:LOOP WHILE (CL:NOT (EQL? (VALUE-OF SECONDARG) SECONDARGVALUE))
      DO (CL:SETQ SECONDARG (VALUE-OF SECONDARG)))
     (CL:LET* ((SKOLEM SECONDARG))
      (CL:LET*
       ((OBJECT-001 SKOLEM) (VALUE-001 NULL)
        (OLD-VALUE-002 (%VARIABLE-VALUE OBJECT-001))
        (NEW-VALUE-001
         (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-001
          (%HOME-CONTEXT OBJECT-001) CL:NIL)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-002 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-002)
           SGT-PROPOSITIONS-STELLA-CS-VALUE)))
        (CL:SETF (%VARIABLE-VALUE OBJECT-001) NEW-VALUE-001)))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SKOLEM)
       SYM-PROPOSITIONS-LOGIC-CONFLICTING-DEFAULT-VALUES
       (CONS EQUATINGPROP (CONFLICTING-DEFAULT-VALUES SKOLEM)) NULL)
      (CL:WHEN NEWISDEFAULT?
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SKOLEM)
        SYM-PROPOSITIONS-LOGIC-CONFLICTING-DEFAULT-VALUES
        (CONS NEWEQUATINGPROP (CONFLICTING-DEFAULT-VALUES SKOLEM))
        NULL)))))
   (CL:SETF (%TRUTH-VALUE NEWEQUATINGPROP) NEWTRUTHVALUE)
   (CL:OR
    (CL:AND (CL:NOT FIRSTARGISSKOLEM?) (CL:NOT SECONDARGISSKOLEM?))
    (CL:NOT NEWISDEFAULT?))))

;;; (DEFUN (UNEQUATE-VALUES? BOOLEAN) ...)

(CL:DEFUN UNEQUATE-VALUES? (TERM1 TERM2)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM1)
     SGT-PROPOSITIONS-LOGIC-SKOLEM)
    (CL:PROGN
     (CL:WHEN
      (EQL?
       (ACCESS-IN-CONTEXT (%VARIABLE-VALUE TERM1) (%HOME-CONTEXT TERM1)
        CL:NIL)
       TERM2)
      (UNBIND-SKOLEM-VALUE TERM1 CL:NIL)
      (CL:RETURN-FROM UNEQUATE-VALUES? CL:T))))
   (CL:T))
  CL:NIL)

;;; (DEFUN BIND-TO-EQUIVALENT-VALUE ...)

(CL:DEFUN BIND-TO-EQUIVALENT-VALUE (FROM TO)
  (CL:WHEN (CL:EQ FROM TO) (CL:RETURN-FROM BIND-TO-EQUIVALENT-VALUE))
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE FROM)
     SGT-PROPOSITIONS-LOGIC-SKOLEM)
    (CL:PROGN
     (CL:LET*
      ((OBJECT-000 FROM) (VALUE-000 TO)
       (OLD-VALUE-000 (%VARIABLE-VALUE OBJECT-000))
       (NEW-VALUE-000
        (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
         (%HOME-CONTEXT OBJECT-000) CL:NIL)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%VARIABLE-VALUE OBJECT-000) NEW-VALUE-000)))))
   (CL:T
    (CL:WHEN
     (CL:EQ
      (ACCESS-IN-CONTEXT
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FROM)
        SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE NULL)
       (%HOME-CONTEXT FROM) CL:NIL)
      TO)
     (CL:RETURN-FROM BIND-TO-EQUIVALENT-VALUE))
    (CL:LET*
     ((OBJECT-001 FROM) (VALUE-001 TO)
      (OLD-VALUE-002
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OBJECT-001)
        SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE NULL))
      (NEW-VALUE-001
       (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-001
        (%HOME-CONTEXT OBJECT-001) CL:NIL)))
     (CL:WHEN
      (CL:NOT
       (CL:AND (CL:NOT (CL:EQ OLD-VALUE-002 NULL))
        (CL:EQ (PRIMARY-TYPE OLD-VALUE-002)
         SGT-PROPOSITIONS-STELLA-CS-VALUE)))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OBJECT-001)
       SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE NEW-VALUE-001 NULL)))))
  (CL:LET*
   ((OBJECT-002 TO)
    (VALUE-002 (CONS FROM (VARIABLE-VALUE-INVERSE FROM)))
    (OLD-VALUE-003 (%VARIABLE-VALUE-INVERSE OBJECT-002))
    (NEW-VALUE-002
     (UPDATE-IN-CONTEXT OLD-VALUE-003 VALUE-002
      (%HOME-CONTEXT OBJECT-002) CL:NIL)))
   (CL:WHEN
    (CL:NOT
     (CL:AND (CL:NOT (CL:EQ OLD-VALUE-003 NULL))
      (CL:EQ (PRIMARY-TYPE OLD-VALUE-003)
       SGT-PROPOSITIONS-STELLA-CS-VALUE)))
    (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-002) NEW-VALUE-002))))

;;; (DEFUN UNBIND-EQUIVALENT-VALUE ...)

(CL:DEFUN UNBIND-EQUIVALENT-VALUE (SELF)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-PROPOSITIONS-LOGIC-SKOLEM)
    (CL:PROGN (UNBIND-SKOLEM-VALUE SELF CL:NIL)))
   (CL:T (UNLINK-EQUIVALENT-VALUE SELF)
    (HANDLE-OUT-OF-DATE-INFERENCE-CACHE KWD-PROPOSITIONS-RETRACT NULL))))

;;; (DEFUN UNLINK-EQUIVALENT-VALUE ...)

(CL:DEFUN UNLINK-EQUIVALENT-VALUE (SELF)
  (CL:LET* ((OLDVALUE NULL))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
      SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN (CL:SETQ OLDVALUE (VALUE-OF SELF))
      (CL:LET*
       ((OBJECT-000 SELF) (VALUE-000 NULL)
        (OLD-VALUE-000 (%VARIABLE-VALUE OBJECT-000))
        (NEW-VALUE-000
         (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
          (%HOME-CONTEXT OBJECT-000) CL:NIL)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
           SGT-PROPOSITIONS-STELLA-CS-VALUE)))
        (CL:SETF (%VARIABLE-VALUE OBJECT-000) NEW-VALUE-000)))))
    (CL:T (CL:SETQ OLDVALUE (EQUIVALENT-VALUE-OF SELF))
     (CL:LET*
      ((OBJECT-001 SELF) (VALUE-001 NULL)
       (OLD-VALUE-001
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OBJECT-001)
         SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE NULL))
       (NEW-VALUE-001
        (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001
         (%HOME-CONTEXT OBJECT-001) CL:NIL)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OBJECT-001)
        SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE NEW-VALUE-001 NULL)))))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE OLDVALUE)
      SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:IF (CL:EQ (%%VALUE (VARIABLE-VALUE-INVERSE OLDVALUE)) SELF)
       (CL:LET*
        ((OBJECT-002 OLDVALUE)
         (VALUE-002 (%%REST (VARIABLE-VALUE-INVERSE OLDVALUE)))
         (OLD-VALUE-002 (%VARIABLE-VALUE-INVERSE OBJECT-002))
         (NEW-VALUE-002
          (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-002
           (%HOME-CONTEXT OBJECT-002) CL:NIL)))
        (CL:WHEN
         (CL:NOT
          (CL:AND (CL:NOT (CL:EQ OLD-VALUE-002 NULL))
           (CL:EQ (PRIMARY-TYPE OLD-VALUE-002)
            SGT-PROPOSITIONS-STELLA-CS-VALUE)))
         (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-002) NEW-VALUE-002)))
       (CL:LET*
        ((OBJECT-003 OLDVALUE)
         (VALUE-003
          (REMOVE (COPY-CONS-LIST (VARIABLE-VALUE-INVERSE OLDVALUE))
           SELF))
         (OLD-VALUE-003 (%VARIABLE-VALUE-INVERSE OBJECT-003))
         (NEW-VALUE-003
          (UPDATE-IN-CONTEXT OLD-VALUE-003 VALUE-003
           (%HOME-CONTEXT OBJECT-003) CL:NIL)))
        (CL:WHEN
         (CL:NOT
          (CL:AND (CL:NOT (CL:EQ OLD-VALUE-003 NULL))
           (CL:EQ (PRIMARY-TYPE OLD-VALUE-003)
            SGT-PROPOSITIONS-STELLA-CS-VALUE)))
         (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-003)
          NEW-VALUE-003))))))
    (CL:T))))

;;; (DEFUN (EQUIVALENT-COLLECTION-PRIORITY INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM)
  EQUIVALENT-COLLECTION-PRIORITY))
(CL:DEFUN EQUIVALENT-COLLECTION-PRIORITY (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN 1))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
     (CL:PROGN 2))
    (CL:T 0))))

;;; (DEFGLOBAL *EQUIVALENCE-COLLECTIONS?* ...)

(CL:DEFVAR *EQUIVALENCE-COLLECTIONS?* CL:T
  "Experiment with equality reasoning on collections.")

;;; (DEFUN EQUIVALENCE-COLLECTIONS ...)

(CL:DEFUN EQUIVALENCE-COLLECTIONS (COLLECTION1 COLLECTION2)
  (CL:WHEN (CL:NOT *EQUIVALENCE-COLLECTIONS?*)
   (CL:RETURN-FROM EQUIVALENCE-COLLECTIONS))
  (CL:LET*
   ((VALUE1 (EQUIVALENT-VALUE-OF (VALUE-OF COLLECTION1)))
    (VALUE2 (EQUIVALENT-VALUE-OF (VALUE-OF COLLECTION2))))
   (CL:IF
    (CL:> (EQUIVALENT-COLLECTION-PRIORITY VALUE1)
     (EQUIVALENT-COLLECTION-PRIORITY VALUE2))
    (BIND-TO-EQUIVALENT-VALUE VALUE2 VALUE1)
    (BIND-TO-EQUIVALENT-VALUE VALUE1 VALUE2))))

;;; (DEFUN REVISE-EQUIVALENCES ...)

(CL:DEFUN REVISE-EQUIVALENCES (PROPOSITION GOESTRUE?)
  (CL:LET*
   ((ARG1
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (ARG2
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1)))
   (CL:WHEN (CL:NOT *EQUIVALENCE-COLLECTIONS?*)
    (CL:RETURN-FROM REVISE-EQUIVALENCES))
   (CL:COND
    (GOESTRUE?
     (CL:WHEN
      (CL:AND (COLLECTION-IMPLIES-COLLECTION? ARG1 ARG2)
       (COLLECTION-IMPLIES-COLLECTION? ARG2 ARG1))
      (EQUIVALENCE-COLLECTIONS ARG1 ARG2)))
    ((CL:OR
      (CL:NOT
       (CL:EQ
        (ACCESS-IN-CONTEXT
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ARG1)
          SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE NULL)
         (%HOME-CONTEXT ARG1) CL:NIL)
        NULL))
      (CL:NOT
       (CL:EQ
        (ACCESS-IN-CONTEXT
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ARG2)
          SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE NULL)
         (%HOME-CONTEXT ARG2) CL:NIL)
        NULL)))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "DIDN'T FINISH 'revise-equivalences' YET. DON'T KNOW HOW" EOL
      "   TO REMOVE AN 'equivalent-value' LINK" EOL))
    ((CL:OR
      (CL:AND (ISA? ARG1 SGT-PROPOSITIONS-LOGIC-SKOLEM)
       (CL:NOT
        (CL:EQ
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE ARG1) (%HOME-CONTEXT ARG1)
          CL:NIL)
         NULL)))
      (CL:AND (ISA? ARG2 SGT-PROPOSITIONS-LOGIC-SKOLEM)
       (CL:NOT
        (CL:EQ
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE ARG2) (%HOME-CONTEXT ARG2)
          CL:NIL)
         NULL))))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "DIDN'T FINISH 'revise-equivalences' YET. DON'T KNOW HOW" EOL
      "   TO REMOVE AN 'equivalent-value' LINK" EOL)))))

;;; (DEFUN (FIND-EQUATING-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FIND-EQUATING-PROPOSITION (DIRECTOBJECT INDIRECTOBJECT)
  (CL:LET*
   ((INDIRECTOBJECTVALUE (VALUE-OF INDIRECTOBJECT))
    (BACKLINKEDINDIRECTOBJECT INDIRECTOBJECTVALUE))
   (CL:WHEN
    (CL:NOT
     (ISA? BACKLINKEDINDIRECTOBJECT
      SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT))
    (CL:SETQ BACKLINKEDINDIRECTOBJECT INDIRECTOBJECT))
   (CL:LET* ((VALUE-000 NULL))
    (CL:LET*
     ((PROP NULL)
      (ITER-000
       (CL:IF (DESCRIPTION-MODE?)
        (ALLOCATE-ITERATOR
         (UNFILTERED-DEPENDENT-PROPOSITIONS BACKLINKEDINDIRECTOBJECT
          SGT-PROPOSITIONS-PL-KERNEL-KB-EQUIVALENT))
        (ALL-TRUE-DEPENDENT-PROPOSITIONS BACKLINKEDINDIRECTOBJECT
         SGT-PROPOSITIONS-PL-KERNEL-KB-EQUIVALENT CL:NIL))))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ PROP (%VALUE ITER-000))
      (CL:WHEN
       (CL:AND
        (CL:EQ (%OPERATOR PROP)
         SGT-PROPOSITIONS-PL-KERNEL-KB-EQUIVALENT)
        (CL:OR
         (CL:AND
          (EQL?
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP))) 0)
           DIRECTOBJECT)
          (EQL?
           (VALUE-OF
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP)))
             1))
           INDIRECTOBJECTVALUE))
         (CL:AND
          (EQL?
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP))) 1)
           DIRECTOBJECT)
          (EQL?
           (VALUE-OF
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP)))
             0))
           INDIRECTOBJECTVALUE))))
       (CL:SETQ VALUE-000 PROP) (CL:RETURN))))
    (CL:LET* ((VALUE-001 VALUE-000)) VALUE-001))))

;;; (DEFCONSTANT TRUE-PROPOSITION ...)

(CL:DEFVAR TRUE-PROPOSITION NULL)

;;; (DEFCONSTANT FALSE-PROPOSITION ...)

(CL:DEFVAR FALSE-PROPOSITION NULL)

;;; (DEFUN (EVALUATE-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-TERM (SELF)
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-001
      SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER)
     (CL:PROGN (EVALUATE-LITERAL-WRAPPER-TERM SELF)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
     (CL:PROGN (EVALUATE-SURROGATE-TERM SELF)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
     (CL:PROGN (EVALUATE-SYMBOL-TERM SELF)))
    ((CL:EQ TEST-VALUE-001 SGT-PROPOSITIONS-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 (%%VALUE SELF)))
       (CL:COND
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-SETOFALL)
          (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-THE-ONLY)
          (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-KAPPA))
         (EVALUATE-LOGIC-OBJECT-TERM
          (EVALUATE-DESCRIPTION-TERM SELF CL:T)))
        ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-CREATE)
         (EVALUATE-CREATE-TERM SELF))
        (CL:T (EVALUATE-FUNCTION-TERM SELF))))))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN (EVALUATE-LOGIC-OBJECT-TERM SELF)))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
     (CL:PROGN SELF))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-PROPOSITIONS-STELLA-THING)
     (CL:PROGN SELF))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-001) (CL:PROGN SELF))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "Can't evaluate the term `" SELF "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (EVALUATE-LITERAL-WRAPPER-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-LITERAL-WRAPPER-TERM (SELF)
  (PERMANENTIFY SELF))

;;; (DEFUN (EVALUATE-SURROGATE-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-SURROGATE-TERM (SELF)
  (CL:COND
   ((CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION)
    (CL:LET* ((VALUE (%SURROGATE-VALUE SELF)) (STORE NULL))
     (CL:COND
      ((CL:NOT (CL:EQ VALUE NULL))
       (CL:COND
        ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE VALUE)
          SGT-PROPOSITIONS-STELLA-RELATION)
         (CL:PROGN (GET-DESCRIPTION SELF)))
        (CL:T VALUE)))
      (CL:T (CL:SETQ SELF (COERCE-TO-BOUND-OR-LOCAL-SURROGATE SELF))
       (CL:SETQ STORE (HOME-OBJECT-STORE SELF))
       (CL:WHEN (CL:NOT (CL:EQ STORE NULL))
        (FETCH-INSTANCE STORE SELF))
       (CL:WHEN (CL:EQ (%SURROGATE-VALUE SELF) NULL)
        (CREATE-LOGIC-INSTANCE SELF NULL))
       (%SURROGATE-VALUE SELF)))))
   ((CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-DESCRIPTION)
    (CL:LET* ((SURROGATEVALUE (%SURROGATE-VALUE SELF)) (STORE NULL))
     (CL:COND
      ((CL:EQ SURROGATEVALUE NULL)
       (CL:SETQ SELF (COERCE-TO-BOUND-OR-LOCAL-SURROGATE SELF))
       (CL:SETQ STORE (HOME-OBJECT-STORE SELF))
       (CL:WHEN (CL:NOT (CL:EQ STORE NULL))
        (FETCH-INSTANCE STORE SELF))
       (CL:WHEN (CL:EQ (%SURROGATE-VALUE SELF) NULL)
        (CREATE-LOGIC-INSTANCE SELF NULL))
       SELF)
      ((ISA? SURROGATEVALUE SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER)
       SURROGATEVALUE)
      (CL:T SELF))))
   ((CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-INTENSIONAL-ASSERTION)
    (CL:LET*
     ((DIRECTVALUE (%SURROGATE-VALUE SELF)) (INTENSIONALSKOLEM NULL))
     (CL:WHEN (SKOLEM? DIRECTVALUE)
      (CL:RETURN-FROM EVALUATE-SURROGATE-TERM DIRECTVALUE))
     (CL:SETQ INTENSIONALSKOLEM
      (CREATE-SKOLEM
       (CL:IF (CL:NOT (CL:EQ DIRECTVALUE NULL))
        (LOGICAL-TYPE (VALUE-OF DIRECTVALUE)) NULL)
       NULL))
     (CL:SETF (%SURROGATE-VALUE SELF) INTENSIONALSKOLEM)
     (BIND-SKOLEM-TO-VALUE INTENSIONALSKOLEM DIRECTVALUE CL:NIL)
     INTENSIONALSKOLEM))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" *EVALUATIONMODE*
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (EVALUATE-LOGIC-OBJECT-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-LOGIC-OBJECT-TERM (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN (CL:RETURN-FROM EVALUATE-LOGIC-OBJECT-TERM SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:WHEN (DESCRIPTION-MODE?)
       (CL:LET* ((NAME (%SURROGATE-VALUE-INVERSE SELF)))
        (CL:WHEN (CL:NOT (CL:EQ NAME NULL))
         (CL:RETURN-FROM EVALUATE-LOGIC-OBJECT-TERM NAME))))
      (CL:RETURN-FROM EVALUATE-LOGIC-OBJECT-TERM SELF)))
    (CL:T
     (CL:IF (DESCRIPTION-MODE?)
      (CL:LET* ((NAME (%SURROGATE-VALUE-INVERSE SELF)))
       (CL:WHEN (CL:NOT (CL:EQ NAME NULL))
        (CL:RETURN-FROM EVALUATE-LOGIC-OBJECT-TERM NAME)))
      (CL:RETURN-FROM EVALUATE-LOGIC-OBJECT-TERM SELF)))))
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
     "ERROR: Illegal LOGIC-OBJECT term: `" SELF "'." EOL)
    (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
   (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))

;;; (DEFCONSTANT ANONYMOUS-VARIABLE-NAME ...)

(CL:DEFVAR ANONYMOUS-VARIABLE-NAME NULL
  "Variables with name 'ANONYMOUS-VARIABLE-NAME' are considered
anonymous, and are not assumed to be identical to any other variable also named
'ANONYMOUS-VARIABLE-NAME'.")

;;; (DEFUN (ANONYMOUS-VARIABLE? BOOLEAN) ...)

(CL:DEFUN ANONYMOUS-VARIABLE? (SELF)
  (CL:AND (CL:EQ (%SKOLEM-NAME SELF) ANONYMOUS-VARIABLE-NAME)
   (VARIABLE? SELF)))

;;; (DEFUN (EVALUATE-SYMBOL-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-SYMBOL-TERM (SELF)
  (CL:LET* ((VALUE (LOOKUP-LOGIC-VARIABLE-BINDING SELF)))
   (CL:COND ((CL:NOT (CL:EQ VALUE NULL)) VALUE)
    ((CL:EQ SELF ANONYMOUS-VARIABLE-NAME)
     (CREATE-VARIABLE NULL ANONYMOUS-VARIABLE-NAME CL:NIL))
    ((QUESTION-MARK-SYMBOL? SELF)
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
        "ERROR: Reference to undeclared variable: `" SELF "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
        KWD-PROPOSITIONS-ERROR))
      (CL:ERROR
       (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
    ((AUTOMATIC-INSTANCE-SYMBOL? SELF)
     (EVALUATE-AUTOMATIC-INSTANCE SELF))
    (CL:T (CL:SETQ VALUE (%SURROGATE-VALUE (SYMBOL-TO-SURROGATE SELF)))
     (CL:IF (CL:NOT (CL:EQ VALUE NULL)) VALUE
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
         "ERROR: Reference to undeclared symbol: `" SELF "'." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001
         KWD-PROPOSITIONS-ERROR))
       (CL:ERROR
        (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001)))))))))

;;; (DEFGLOBAL *MISSING-KEY-VALUE-LIST* ...)

(CL:DEFVAR *MISSING-KEY-VALUE-LIST* NULL
  "Represents a key-value list that should never be used.")

;;; (DEFSPECIAL *AUTOMATICINSTANCETABLE* ...)

(CL:DEFVAR *AUTOMATICINSTANCETABLE* NULL
  "Used by 'evaluate-automatic-instance' to
record current bindings of automatic instance symbols.")

;;; (DEFUN (EVALUATE-AUTOMATIC-INSTANCE OBJECT) ...)

(CL:DEFUN EVALUATE-AUTOMATIC-INSTANCE (NAME)
  (CL:WHEN (CL:EQ *AUTOMATICINSTANCETABLE* *MISSING-KEY-VALUE-LIST*)
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "ERROR: Automatic instance `" NAME "' found outside" EOL
      "   the scope of an assertion.." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:LET*
   ((INSTANCE
     (CL:IF (CL:NOT (CL:EQ *AUTOMATICINSTANCETABLE* NULL))
      (LOOKUP *AUTOMATICINSTANCETABLE* NAME) NULL)))
   (CL:WHEN (CL:EQ INSTANCE NULL)
    (CL:LET*
     ((SURROGATE
       (STRING-TO-SURROGATE
        (%SYMBOL-NAME
         (GENSYM (SUBSEQUENCE (%SYMBOL-NAME NAME) 1 NULL-INTEGER))))))
     (CL:SETQ INSTANCE (CREATE-LOGIC-INSTANCE SURROGATE NULL))
     (CL:WHEN (CL:EQ *AUTOMATICINSTANCETABLE* NULL)
      (CL:SETQ *AUTOMATICINSTANCETABLE* (NEW-KEY-VALUE-LIST)))
     (INSERT-AT *AUTOMATICINSTANCETABLE* NAME INSTANCE)))
   (EVALUATE-LOGIC-OBJECT-TERM INSTANCE)))

;;; (DEFUN SIGNAL-UNDEFINED-TERM ...)

(CL:DEFUN SIGNAL-UNDEFINED-TERM (TERM)
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
     "ERROR: Reference to undefined term: `" TERM "'." EOL)
    (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
   (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))

;;; (DEFUN SIGNAL-UNTYPED-TERM ...)

(CL:DEFUN SIGNAL-UNTYPED-TERM (TERM)
  (CL:WHEN (CL:NOT *SUPPRESSUNTYPEDTYPEERROR?*)
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "ERROR: Need a type for the untyped term: `" TERM "'." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))))

;;; (DEFUN (EVALUATE-CREATE-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-CREATE-TERM (TERM)
  (CL:LET*
   ((NAMESYMBOL (%%VALUE (%%REST TERM)))
    (NAME
     (CL:IF (CL:NOT (CL:EQ NAMESYMBOL NULL))
      (SYMBOL-TO-SURROGATE NAMESYMBOL) NULL))
    (TYPESYMBOL (%%VALUE (%%REST (%%REST TERM))))
    (TYPE
     (CL:IF (CL:NOT (CL:EQ TYPESYMBOL NULL))
      (SYMBOL-TO-SURROGATE TYPESYMBOL) NULL))
    (TERM NULL))
   (CL:HANDLER-CASE (CL:SETQ TERM (CREATE-LOGIC-INSTANCE NAME TYPE))
    (LOGIC-EXCEPTION (E)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
      (EXCEPTION-MESSAGE E))))
   TERM))

;;; (DEFUN (CREATE OBJECT) ...)

(CL:DEFUN %CREATE (NAME TYPE)
  "Create a logic object with name 'name' and return it.
If `type' is also supplied, assert that the object belongs to that type."
  (CL:LET*
   ((CREATETREE
     (LIST* SYM-PROPOSITIONS-LOGIC-CREATE NAME (CONCATENATE TYPE NIL)))
    (RESULT (EVALUATE-CREATE-TERM CREATETREE)))
   RESULT))

(CL:DEFUN CREATE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%CREATE (%%VALUE ARGUMENTS) (%%REST ARGUMENTS)))

(CL:DEFMACRO CREATE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Create a logic object with name 'name' and return it.
If `type' is also supplied, assert that the object belongs to that type."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/CREATE|)) (CL:MACRO-FUNCTION (CL:QUOTE CREATE)))

;;; (DEFUN UPDATE-SKOLEM-TYPE ...)

(CL:DEFUN UPDATE-SKOLEM-TYPE (SELF TYPE)
  (CL:LET* ((OLDTYPE (%SKOLEM-TYPE SELF)))
   (CL:WHEN
    (CL:OR (CL:EQ OLDTYPE NULL) (LOGICAL-SUBTYPE-OF? TYPE OLDTYPE))
    (CL:SETF (%SKOLEM-TYPE SELF) TYPE))))

;;; (DEFUN UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS ...)

(CL:DEFUN UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS (SELF)
  (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-ISA)
     (CL:LET*
      ((OBJECT
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 0)))
      (CL:WHEN (ISA? OBJECT SGT-PROPOSITIONS-LOGIC-SKOLEM)
       (UPDATE-SKOLEM-TYPE OBJECT (%OPERATOR SELF)))))
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-AND)
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS ARG)
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
    (CL:T))))

;;; (DEFUN (DESCRIPTION-EXTENSION< BOOLEAN) ...)

(CL:DEFUN DESCRIPTION-EXTENSION< (DESC1 DESC2)
  (< (ESTIMATED-LENGTH (GET-DESCRIPTION-EXTENSION DESC1 CL:T))
   (ESTIMATED-LENGTH (GET-DESCRIPTION-EXTENSION DESC2 CL:T))))

;;; (DEFUN PRINT-EXTENSION-SIZES ...)

(CL:DEFUN PRINT-EXTENSION-SIZES (MODULE SIZECUTOFF)
  "Print the extension sizes of concepts visible in `module'.
If `module' is NULL the current module is used.  Do not report extensions
with size less than `sizeCutoff' (default is 10)."
  (CL:DECLARE (CL:TYPE CL:FIXNUM SIZECUTOFF))
  #+MCL
  (CL:CHECK-TYPE SIZECUTOFF CL:FIXNUM)
  (CL:WHEN (NULL? SIZECUTOFF) (CL:SETQ SIZECUTOFF 10))
  (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE *MODULE*))
  (CL:LET* ((DESCRIPTIONS (NEW-LIST)) (SIZE STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SIZE))
   (CL:LET*
    ((D NULL) (ITER-000 (ALL-NAMED-DESCRIPTIONS MODULE CL:NIL))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ D (%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ (%EXTENSION D) NULL))
       (CL:>= (ESTIMATED-LENGTH (%EXTENSION D)) SIZECUTOFF))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS D NIL))
        (CL:IF (CL:EQ (%THE-CONS-LIST DESCRIPTIONS) NIL)
         (CL:SETF (%THE-CONS-LIST DESCRIPTIONS) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST DESCRIPTIONS)
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS D NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (SORT DESCRIPTIONS (CL:FUNCTION DESCRIPTION-EXTENSION<))
   (CL:LET*
    ((DESC NULL) (ITER-001 (%THE-CONS-LIST (REVERSE DESCRIPTIONS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ DESC (%%VALUE ITER-001))
     (CL:SETQ SIZE
      (INTEGER-TO-STRING (ESTIMATED-LENGTH (%EXTENSION DESC))))
     (CL:SETQ SIZE
      (CONCATENATE
       (MAKE-STRING (CL:- 8 (CL:THE CL:FIXNUM (CL:LENGTH SIZE))) #\ )
       SIZE))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) SIZE " : "
      (DESCRIPTION-NAME DESC) EOL)
     (CL:SETQ ITER-001 (%%REST ITER-001))))))

;;; (DEFUN TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK ...)

(CL:DEFUN TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK (RELATIONSLIST)
  (CL:LET*
   ((OLDRELATION (FIRST RELATIONSLIST))
    (NEWRELATION (SECOND RELATIONSLIST))
    (OLDDESCRIPTION
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OLDRELATION)
      SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL))
    (NEWDESCRIPTION
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWRELATION)
      SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL)))
   (CL:WHEN (CL:NOT (CL:EQ OLDDESCRIPTION NULL))
    (RETRACT-RELATION-AXIOMS OLDDESCRIPTION)
    (CL:IF (CL:NOT (CL:EQ NEWDESCRIPTION NULL))
     (CL:PROGN
      (TRANSFER-PROPOSITIONS-AND-BACKLINKS
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OLDRELATION)
        SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL)
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWRELATION)
        SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL))
      (DESTROY-INSTANCE OLDDESCRIPTION))
     (CL:PROGN
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWRELATION)
       SYM-PROPOSITIONS-LOGIC-DESCRIPTION OLDDESCRIPTION NULL)
      (NATIVE-RELATION-SETTER OLDDESCRIPTION NEWRELATION)
      (FINALIZE-SUPERRELATION-LINKS NEWRELATION)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OLDRELATION)
     SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL NULL))
   (CL:COND
    ((SUBTYPE-OF-CLASS? (SAFE-PRIMARY-TYPE OLDRELATION))
     (CL:PROGN
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWRELATION)
       SYM-PROPOSITIONS-STELLA-CLASS-EXTENSION
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OLDRELATION)
        SYM-PROPOSITIONS-STELLA-CLASS-EXTENSION NULL)
       NULL)
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OLDRELATION)
       SYM-PROPOSITIONS-STELLA-CLASS-EXTENSION NULL NULL)))
    (CL:T))))

;;; (DEFUN RETRACT-RELATION-AXIOMS ...)

(CL:DEFUN RETRACT-RELATION-AXIOMS (OLDRELATION)
  (CL:LET*
   ((ORIGINATEDPROPOSITIONS (ORIGINATED-PROPOSITIONS OLDRELATION)))
   (CL:WHEN (CL:NOT (CL:EQ ORIGINATEDPROPOSITIONS NULL))
    (CL:LET*
     ((PROPOSITION NULL)
      (ITER-000 (%THE-CONS-LIST ORIGINATEDPROPOSITIONS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ PROPOSITION (%%VALUE ITER-000))
      (UNASSERT-PROPOSITION PROPOSITION)
      (CL:SETQ ITER-000 (%%REST ITER-000)))))))

;;; (DEFUN (ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION PROPOSITION) ...)

(CL:DEFUN ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION (SUB SUPER DONTUPDATE?)
  (CL:LET* ((IMPLIESPROP (CREATE-IMPLIES-PROPOSITION SUB SUPER)))
   (CL:SETQ IMPLIESPROP
    (FASTEN-DOWN-ONE-PROPOSITION IMPLIESPROP CL:NIL))
   (CL:WHEN (CL:NOT DONTUPDATE?)
    (UPDATE-PROPOSITION-TRUTH-VALUE IMPLIESPROP
     KWD-PROPOSITIONS-ASSERT-TRUE))
   IMPLIESPROP))

;;; (DEFUN (ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS PROPOSITION) ...)

(CL:DEFUN ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS (SUB SUPER)
  (CL:LET*
   ((IMPLIESPROP
     (ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION SUB SUPER CL:T)))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS IMPLIESPROP)
    SYM-PROPOSITIONS-LOGIC-SUBRELATION-LINK?
    (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
   (UPDATE-PROPOSITION-TRUTH-VALUE IMPLIESPROP
    KWD-PROPOSITIONS-ASSERT-TRUE)
   (LINK-ORIGINATED-PROPOSITION SUB IMPLIESPROP) IMPLIESPROP))

;;; (DEFUN FINALIZE-SUPERRELATION-LINKS ...)

(CL:DEFUN FINALIZE-SUPERRELATION-LINKS (SELF)
  (CL:LET* ((SUBDESCRIPTION (GET-DESCRIPTION SELF)))
   (CL:LET*
    ((*EVALUATIONMODE* KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION)
     (*FILLINGCONSTRAINTPROPAGATIONQUEUES?* CL:NIL))
    (CL:DECLARE
     (CL:SPECIAL *EVALUATIONMODE*
      *FILLINGCONSTRAINTPROPAGATIONQUEUES?*))
    (CL:LET*
     ((*MODULE* (%HOME-CONTEXT SUBDESCRIPTION)) (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CL:LET* ((SUPER NULL) (ITER-000 (DIRECT-SUPERRELATIONS SELF)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ SUPER (%VALUE ITER-000))
       (CL:WHEN
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SUPER)
           SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL)
          NULL))
        (ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS SUBDESCRIPTION
         (GET-DESCRIPTION SUPER)))))))))

;;; (DEFUN (UPDATE-ISA-PROPOSITION PROPOSITION) ...)

(CL:DEFUN UPDATE-ISA-PROPOSITION (SELF TYPE UPDATEMODE)
  (CL:LET* ((VALUE-000 NULL))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALLOCATE-ITERATOR
       (UNFILTERED-DEPENDENT-ISA-PROPOSITIONS SELF))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%OPERATOR P) TYPE) (CL:SETQ VALUE-000 P)
      (CL:RETURN))))
   (CL:LET* ((ISAPROPOSITION VALUE-000))
    (CL:WHEN (CL:EQ ISAPROPOSITION NULL)
     (CL:SETQ ISAPROPOSITION
      (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-ISA 1))
     (CL:SETF (%OPERATOR ISAPROPOSITION) TYPE)
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS ISAPROPOSITION))) (VALUE SELF)
       (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (FASTEN-DOWN-ONE-PROPOSITION ISAPROPOSITION CL:T))
    (UPDATE-PROPOSITION-TRUTH-VALUE ISAPROPOSITION UPDATEMODE)
    ISAPROPOSITION)))

;;; (DEFUN (ASSERT-ISA-PROPOSITION PROPOSITION) ...)

(CL:DEFUN ASSERT-ISA-PROPOSITION (SELF TYPE)
  (CL:IF (CL:NOT (CL:EQ TYPE NULL))
   (UPDATE-ISA-PROPOSITION SELF TYPE KWD-PROPOSITIONS-ASSERT-TRUE) NULL))

;;; (DEFUN (RETRACT-ISA-PROPOSITION PROPOSITION) ...)

(CL:DEFUN RETRACT-ISA-PROPOSITION (SELF TYPE)
  (CL:IF (CL:NOT (CL:EQ TYPE NULL))
   (UPDATE-ISA-PROPOSITION SELF TYPE KWD-PROPOSITIONS-RETRACT-TRUE)
   NULL))

;;; (DEFUN (UPDATE-PROPERTY PROPOSITION) ...)

(CL:DEFUN UPDATE-PROPERTY (SELF SURROGATE UPDATEMODE)
  (CL:LET* ((VALUE-000 NULL))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALLOCATE-ITERATOR
       (UNFILTERED-DEPENDENT-PROPOSITIONS SELF SURROGATE))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:EQ (%OPERATOR P) SURROGATE)
       (CL:= (LENGTH (%ARGUMENTS P)) 1))
      (CL:SETQ VALUE-000 P) (CL:RETURN))))
   (CL:LET* ((PROPERTYPROPOSITION VALUE-000))
    (CL:WHEN
     (CL:OR (CL:EQ SURROGATE NULL)
      (CL:EQ (%SURROGATE-VALUE SURROGATE) NULL))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "Error: Property " SURROGATE " is not defined." EOL)
     (CL:RETURN-FROM UPDATE-PROPERTY NULL))
    (CL:WHEN (CL:EQ PROPERTYPROPOSITION NULL)
     (CL:SETQ PROPERTYPROPOSITION
      (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-PREDICATE 1))
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS PROPERTYPROPOSITION)))
       (VALUE SELF) (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETF (%OPERATOR PROPERTYPROPOSITION) SURROGATE)
     (FASTEN-DOWN-ONE-PROPOSITION PROPERTYPROPOSITION CL:T))
    (UPDATE-PROPOSITION-TRUTH-VALUE PROPERTYPROPOSITION UPDATEMODE)
    PROPERTYPROPOSITION)))

;;; (DEFUN (ASSERT-PROPERTY PROPOSITION) ...)

(CL:DEFUN ASSERT-PROPERTY (INSTANCE PROPERTY)
  (UPDATE-PROPERTY INSTANCE PROPERTY KWD-PROPOSITIONS-ASSERT-TRUE))

;;; (DEFUN (RETRACT-PROPERTY PROPOSITION) ...)

(CL:DEFUN RETRACT-PROPERTY (INSTANCE PROPERTY)
  (UPDATE-PROPERTY INSTANCE PROPERTY KWD-PROPOSITIONS-RETRACT-TRUE))

;;; (DEFUN (UPDATE-TUPLE PROPOSITION) ...)

(CL:DEFUN UPDATE-TUPLE (RELATION ARGUMENTS UPDATEMODE)
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION RELATION)) (PROPOSITION NULL))
   (CL:COND
    ((FUNCTION-DESCRIPTION? DESCRIPTION)
     (CL:LET*
      ((DEFININGPROPOSITION
        (FIND-OR-CREATE-FUNCTION-PROPOSITION RELATION
         (CONSIFY (BUT-LAST ARGUMENTS)))))
      (CL:SETQ PROPOSITION
       (UPDATE-EQUIVALENCE-PROPOSITION
        (CREATE-EQUIVALENCE-PROPOSITION
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY (%ARGUMENTS DEFININGPROPOSITION)))
          (CL:THE CL:FIXNUM
           (CL:1- (LENGTH (%ARGUMENTS DEFININGPROPOSITION)))))
         (LAST ARGUMENTS))
        UPDATEMODE))
      (CL:WHEN (CL:EQ PROPOSITION NULL)
       (CL:RETURN-FROM UPDATE-TUPLE DEFININGPROPOSITION))))
    ((CLASS-DESCRIPTION? DESCRIPTION)
     (CL:RETURN-FROM UPDATE-TUPLE
      (UPDATE-ISA-PROPOSITION (%%VALUE ARGUMENTS) RELATION
       UPDATEMODE)))
    (CL:T
     (CL:SETQ PROPOSITION
      (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-PREDICATE
       (LENGTH ARGUMENTS)))
     (CL:SETF (%OPERATOR PROPOSITION) RELATION)
     (CL:LET*
      ((ARG NULL) (ITER-000 ARGUMENTS) (I NULL-INTEGER) (ITER-001 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ ARG (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
       (CL:LET
        ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION))) (VALUE ARG)
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-000 (%%REST ITER-000))
       (CL:SETQ ITER-001 (CL:1+ ITER-001))))))
   (CL:SETQ PROPOSITION
    (FASTEN-DOWN-ONE-PROPOSITION PROPOSITION CL:NIL))
   (UPDATE-PROPOSITION-TRUTH-VALUE PROPOSITION UPDATEMODE) PROPOSITION))

;;; (DEFUN (ASSERT-TUPLE PROPOSITION) ...)

(CL:DEFUN ASSERT-TUPLE (RELATION ARGUMENTS)
  (UPDATE-TUPLE RELATION ARGUMENTS KWD-PROPOSITIONS-ASSERT-TRUE))

;;; (DEFUN (UPDATE-BINARY-VALUE PROPOSITION) ...)

(CL:DEFUN UPDATE-BINARY-VALUE (RELATION SELF VALUE UPDATEMODE)
  (CL:LET* ((*CLIPPINGENABLED?* CL:T))
   (CL:DECLARE (CL:SPECIAL *CLIPPINGENABLED?*))
   (CL:IF (FUNCTION-DESCRIPTION? (GET-DESCRIPTION RELATION))
    (CL:LET* ((VALUE-000 NULL))
     (CL:LET*
      ((P NULL)
       (ITER-000
        (ALLOCATE-ITERATOR
         (UNFILTERED-DEPENDENT-PROPOSITIONS SELF RELATION))))
      (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
       (CL:WHEN (CL:EQ (%OPERATOR P) RELATION) (CL:SETQ VALUE-000 P)
        (CL:RETURN))))
     (CL:LET* ((PROPOSITION VALUE-000))
      (CL:WHEN (CL:OR (CL:EQ PROPOSITION NULL) (SKOLEM? VALUE))
       (CL:RETURN-FROM UPDATE-BINARY-VALUE
        (UPDATE-TUPLE RELATION (CONS-LIST SELF VALUE) UPDATEMODE)))
      (CL:LET*
       ((SKOLEMOUTPUT
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          (CL:THE CL:FIXNUM
           (CL:1- (LENGTH (%ARGUMENTS PROPOSITION)))))))
       (CL:COND
        ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
         (CL:COND ((CLIP-VALUE? SKOLEMOUTPUT VALUE))
          (CL:T
           (EQUATE-VALUES (VALUE-OF SKOLEMOUTPUT) (VALUE-OF VALUE)))))
        ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
         (UNEQUATE-VALUES? SKOLEMOUTPUT VALUE))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" UPDATEMODE
           "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
       PROPOSITION)))
    (UPDATE-TUPLE RELATION (CONS-LIST SELF VALUE) UPDATEMODE))))

;;; (DEFUN (ASSERT-BINARY-VALUE PROPOSITION) ...)

(CL:DEFUN ASSERT-BINARY-VALUE (RELATION SELF VALUE)
  (UPDATE-BINARY-VALUE RELATION SELF VALUE KWD-PROPOSITIONS-ASSERT-TRUE))

;;; (DEFUN (RETRACT-BINARY-VALUE PROPOSITION) ...)

(CL:DEFUN RETRACT-BINARY-VALUE (RELATION SELF VALUE)
  (UPDATE-BINARY-VALUE RELATION SELF VALUE
   KWD-PROPOSITIONS-RETRACT-TRUE))

;;; (DEFUN (ASSERT-MEMBER-OF-PROPOSITION PROPOSITION) ...)

(CL:DEFUN ASSERT-MEMBER-OF-PROPOSITION (SELF COLLECTION)
  (CL:WHEN (CL:EQ COLLECTION NULL)
   (CL:RETURN-FROM ASSERT-MEMBER-OF-PROPOSITION NULL))
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE COLLECTION)
     SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
    (CL:PROGN
     (CL:WHEN
      (CL:EQ (%SURROGATE-VALUE-INVERSE COLLECTION)
       SGT-PROPOSITIONS-STELLA-THING)
      (CL:RETURN-FROM ASSERT-MEMBER-OF-PROPOSITION NULL))
     (ASSERT-ISA-PROPOSITION SELF
      (%SURROGATE-VALUE-INVERSE COLLECTION))))
   (CL:T
    (ASSERT-TUPLE SGT-PROPOSITIONS-PL-KERNEL-KB-MEMBER-OF
     (CONS-LIST SELF COLLECTION)))))

;;; (DEFSPECIAL *DEFAULTCREATIONTYPE* ...)

(CL:DEFVAR *DEFAULTCREATIONTYPE* NULL)

;;; (DEFCLASS OBJECT-ALREADY-EXISTS-EXCEPTION ...)

(CL:DEFINE-CONDITION OBJECT-ALREADY-EXISTS-EXCEPTION (STELLA-EXCEPTION)
  ((EXISTING-OBJECT :ALLOCATION :INSTANCE :ACCESSOR %EXISTING-OBJECT)))

(CL:DEFUN NEW-OBJECT-ALREADY-EXISTS-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE OBJECT-ALREADY-EXISTS-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:SETF (%EXISTING-OBJECT SELF) NULL) SELF))

;;; (DEFUN (HELP-CREATE-LOGIC-INSTANCE OBJECT) ...)

(CL:DEFUN HELP-CREATE-LOGIC-INSTANCE (NAME TYPE)
  (ENFORCE-CODE-ONLY)
  (CL:WHEN (CL:EQ TYPE NULL) (CL:SETQ TYPE *DEFAULTCREATIONTYPE*))
  (CL:LET*
   ((DESCRIPTION
     (CL:IF (CL:NOT (CL:EQ TYPE NULL)) (GET-DESCRIPTION TYPE) NULL))
    (NATIVECLASS NULL) (NEWOBJECT NULL))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ TYPE NULL)) (CL:EQ DESCRIPTION NULL))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "Can't create an instance of the undefined class `"
      (%SYMBOL-NAME TYPE) "'")
     (CL:ERROR
      (NEW-UNDEFINED-CLASS-EXCEPTION (THE-STRING-READER STREAM-000)))))
   (CL:IF (CL:EQ DESCRIPTION NULL)
    (CL:SETQ NEWOBJECT (NEW-LOGIC-OBJECT))
    (CL:PROGN
     (CL:WHEN (CL:NOT (CLASS-DESCRIPTION? DESCRIPTION))
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
        "Can't create an instance of a relation: `" (%SYMBOL-NAME TYPE)
        "'")
       (CL:ERROR
        (NEW-OBJECT-NOT-CLASS-EXCEPTION
         (THE-STRING-READER STREAM-001)))))
     (CL:SETQ NATIVECLASS (NATIVE-RELATION DESCRIPTION))
     (CL:COND
      ((CL:OR (CL:EQ NATIVECLASS NULL) (%ABSTRACT? NATIVECLASS))
       (CL:SETQ NEWOBJECT (NEW-LOGIC-OBJECT)))
      ((SUBTYPE-OF? (%CLASS-TYPE NATIVECLASS)
        SGT-PROPOSITIONS-STELLA-THING)
       (CL:SETQ NEWOBJECT (CREATE-OBJECT TYPE)))
      (CL:T
       (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002)
         "Can't create an instance of the class `" (%SYMBOL-NAME TYPE)
         "'" EOL "   because it doesn't inherit the class 'THING'.")
        (CL:ERROR
         (NEW-BAD-ARGUMENT-EXCEPTION
          (THE-STRING-READER STREAM-002))))))))
   (CL:WHEN (CL:NOT (CL:EQ NAME NULL))
    (CL:WHEN (CL:NOT (CL:EQ (%SURROGATE-VALUE NAME) NULL))
     (CL:LET*
      ((SELF-008
        (NEW-OBJECT-ALREADY-EXISTS-EXCEPTION
         (CONCATENATE "An object named " (%SYMBOL-NAME NAME)
          " already exists."))))
      (CL:SETF (%EXISTING-OBJECT SELF-008) (%SURROGATE-VALUE NAME))
      (CL:LET* ((ERROR SELF-008)) (CL:ERROR ERROR))))
    (CL:SETF (%SURROGATE-VALUE NAME) NEWOBJECT)
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NEWOBJECT)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
       (CL:PROGN (CL:SETF (%SURROGATE-VALUE-INVERSE NEWOBJECT) NAME)))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-THING)
       (CL:PROGN (CL:SETF (%SURROGATE-VALUE-INVERSE NEWOBJECT) NAME)))
      (CL:T
       (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-003) "`" TEST-VALUE-000
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-003))))))))
   NEWOBJECT))

;;; (DEFUN (CREATE-LOGIC-INSTANCE OBJECT) ...)

(CL:DEFUN CREATE-LOGIC-INSTANCE (NAME TYPE)
  (CL:HANDLER-CASE
   (CL:RETURN-FROM CREATE-LOGIC-INSTANCE
    (HELP-CREATE-LOGIC-INSTANCE NAME TYPE))
   (UNDEFINED-CLASS-EXCEPTION (UNDEFINED)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "`"
     (EXCEPTION-MESSAGE UNDEFINED) "'" EOL)
    (CL:RETURN-FROM CREATE-LOGIC-INSTANCE NULL))
   (OBJECT-NOT-CLASS-EXCEPTION (NO-CLASS)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "`"
     (EXCEPTION-MESSAGE NO-CLASS) "'" EOL)
    (CL:RETURN-FROM CREATE-LOGIC-INSTANCE NULL))
   (BAD-ARGUMENT-EXCEPTION (BAD-ARG)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "`"
     (EXCEPTION-MESSAGE BAD-ARG) "'" EOL)
    (CL:RETURN-FROM CREATE-LOGIC-INSTANCE NULL))
   (OBJECT-ALREADY-EXISTS-EXCEPTION (EXISTS)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     (EXCEPTION-MESSAGE EXISTS) EOL "Redefining the surrogate "
     (%SYMBOL-NAME NAME) " will cause the existing" EOL
     "   object named " (%SYMBOL-NAME NAME) " to be destroyed. ")
    (CL:IF (Y-OR-N? "Do it? ")
     (CL:PROGN (DESTROY-INSTANCE (%EXISTING-OBJECT EXISTS))
      (HELP-CREATE-LOGIC-INSTANCE NAME TYPE))
     (CL:PROGN
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "Returning existing object:" EOL)
      (%EXISTING-OBJECT EXISTS))))))

;;; (DEFGLOBAL *STRUCTURED-OBJECTS-INDEX* ...)

(CL:DEFVAR *STRUCTURED-OBJECTS-INDEX* NULL
  "Contains a table of propositions and descriptions, indexed by a
structure hash code which might be shared by different objects.")

;;; (DEFUN CLEANUP-STRUCTURED-OBJECTS-INDEX ...)

(CL:DEFUN CLEANUP-STRUCTURED-OBJECTS-INDEX (CLEARMODULE)
  (CL:LET*
   ((KEY NULL) (BUCKET NULL)
    (ITER-000 (ALLOCATE-ITERATOR *STRUCTURED-OBJECTS-INDEX*)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ KEY (%KEY ITER-000))
    (CL:SETQ BUCKET (%VALUE ITER-000))
    (CL:LET* ((OBJ NULL) (ITER-001 (%THE-CONS-LIST BUCKET)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ OBJ (%%VALUE ITER-001))
      (CL:LET* ((CONTEXT (%HOME-CONTEXT OBJ)))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ CONTEXT NULL))
         (CL:OR (DELETED? CONTEXT)
          (CL:OR (CL:EQ CONTEXT CLEARMODULE)
           (MEMB? (%ALL-SUPER-CONTEXTS CONTEXT) CLEARMODULE))))
        (DESTROY-OBJECT OBJ)))
      (CL:SETQ ITER-001 (%%REST ITER-001))))
    (REMOVE-DELETED-MEMBERS BUCKET)
    (CL:WHEN (EMPTY? BUCKET)
     (REMOVE-AT *STRUCTURED-OBJECTS-INDEX* KEY)))))

;;; (DEFUN (PROPOSITION-HASH-INDEX INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) PROPOSITION-HASH-INDEX))
(CL:DEFUN PROPOSITION-HASH-INDEX (SELF)
  (CL:LET*
   ((CODE
     (CL:LET ((SELF (%OPERATOR SELF)))
      (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF))))
    (ARGCODE 0) (COMMUTATIVE? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CODE ARGCODE))
   (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-AND)
       (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-OR)
       (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-EQUIVALENT))
      (CL:SETQ COMMUTATIVE? CL:T))
     (CL:T)))
   (CL:SETQ CODE
    (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND CODE 1)) 0)
     (CL:LET ((ARG CODE)) (CL:DECLARE (CL:TYPE CL:FIXNUM ARG))
      (CL:THE CL:FIXNUM
       (CL:LOGAND (CL:THE CL:FIXNUM (CL:ASH ARG -1))
        *INTEGER-UNSIGNED-BITS-MASK*)))
     (CL:THE CL:FIXNUM
      (CL:LOGIOR
       (CL:THE CL:FIXNUM
        (CL:LET ((ARG CODE) (COUNT 1))
         (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
         (CL:THE CL:FIXNUM
          (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))
       *INTEGER-MSB-MASK*))))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL)) (VARIABLE? ARG))
      (CL:LET* ((TEMP-000 (SAFE-BOUND-TO ARG)))
       (CL:SETQ ARG
        (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 ARG))))
     (CL:IF (CL:EQ ARG NULL)
      (CL:SETQ ARGCODE
       (CL:LET ((SELF SGT-PROPOSITIONS-LOGIC-SKOLEM))
        (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF))))
      (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE ARG)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-001
          SGT-PROPOSITIONS-LOGIC-PROPOSITION)
         (CL:PROGN (CL:SETQ ARGCODE (PROPOSITION-HASH-INDEX ARG))))
        ((SUBTYPE-OF? TEST-VALUE-001
          SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
         (CL:PROGN
          (CL:SETQ ARGCODE
           (CL:LET ((SELF ARG))
            (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF))))))
        ((SUBTYPE-OF? TEST-VALUE-001
          SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
         (CL:PROGN
          (CL:SETQ ARGCODE
           (PROPOSITION-HASH-INDEX (%PROPOSITION ARG)))))
        ((SUBTYPE-OF? TEST-VALUE-001
          SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
         (CL:PROGN
          (CL:SETQ ARGCODE
           (CL:LET ((SELF SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE))
            (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF))))))
        ((SUBTYPE-OF? TEST-VALUE-001 SGT-PROPOSITIONS-LOGIC-SKOLEM)
         (CL:PROGN
          (CL:LET* ((DEFININGPROP (%DEFINING-PROPOSITION ARG)))
           (CL:IF
            (CL:AND (CL:NOT (CL:EQ DEFININGPROP NULL))
             (CL:NOT (CL:EQ DEFININGPROP SELF)))
            (CL:SETQ ARGCODE (PROPOSITION-HASH-INDEX DEFININGPROP))
            (CL:SETQ ARGCODE
             (CL:LET ((SELF SGT-PROPOSITIONS-LOGIC-SKOLEM))
              (CL:THE CL:FIXNUM
               (STELLA::%%OBJECT-HASH-CODE SELF))))))))
        ((SUBTYPE-OF-WRAPPER? TEST-VALUE-001)
         (CL:PROGN (CL:SETQ ARGCODE (HASH-CODE ARG))))
        (CL:T
         (CL:SETQ ARGCODE
          (CL:LET ((SELF ARG))
           (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF))))))))
     (CL:SETQ CODE (CL:THE CL:FIXNUM (CL:LOGXOR CODE ARGCODE)))
     (CL:WHEN (CL:NOT COMMUTATIVE?)
      (CL:SETQ CODE
       (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND CODE 1)) 0)
        (CL:LET ((ARG CODE)) (CL:DECLARE (CL:TYPE CL:FIXNUM ARG))
         (CL:THE CL:FIXNUM
          (CL:LOGAND (CL:THE CL:FIXNUM (CL:ASH ARG -1))
           *INTEGER-UNSIGNED-BITS-MASK*)))
        (CL:THE CL:FIXNUM
         (CL:LOGIOR
          (CL:THE CL:FIXNUM
           (CL:LET ((ARG CODE) (COUNT 1))
            (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
            (CL:THE CL:FIXNUM
             (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))
          *INTEGER-MSB-MASK*)))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   CODE))

;;; (DEFUN (FIND-DUPLICATE-COMPLEX-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FIND-DUPLICATE-COMPLEX-PROPOSITION (SELF)
  (CL:LET*
   ((INDEX (WRAP-INTEGER (PROPOSITION-HASH-INDEX SELF)))
    (BUCKET (LOOKUP *STRUCTURED-OBJECTS-INDEX* INDEX))
    (HOMEMODULE (%BASE-MODULE (%HOME-CONTEXT SELF)))
    (FUNCTION? (CL:EQ (%KIND SELF) KWD-PROPOSITIONS-FUNCTION)))
   (CL:WHEN (CL:EQ BUCKET NULL)
    (INSERT-AT *STRUCTURED-OBJECTS-INDEX* INDEX (LIST SELF))
    (CL:RETURN-FROM FIND-DUPLICATE-COMPLEX-PROPOSITION NULL))
   (REMOVE-DELETED-MEMBERS BUCKET)
   (CL:LET* ((P NULL) (ITER-000 (%THE-CONS-LIST BUCKET)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ P (%%VALUE ITER-000))
     (CL:COND
      ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE P)
        SGT-PROPOSITIONS-LOGIC-PROPOSITION)
       (CL:PROGN
        (CL:IF FUNCTION?
         (CL:LET*
          ((OPERATOR (%OPERATOR SELF)) (ARGUMENTS (%ARGUMENTS SELF))
           (ARITY (LENGTH ARGUMENTS)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
          (CL:LET* ((TEST-VALUE-000 CL:NIL))
           (CL:SETQ TEST-VALUE-000 (CL:EQ OPERATOR (%OPERATOR P)))
           (CL:WHEN TEST-VALUE-000
            (CL:LET* ((ALWAYS?-000 CL:T))
             (CL:LET*
              ((ARG1 NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
               (LENGTH-000 (LENGTH VECTOR-000)) (ARG2 NULL)
               (VECTOR-001 (%ARGUMENTS P)) (INDEX-001 0)
               (LENGTH-001 (LENGTH VECTOR-001)) (I NULL-INTEGER)
               (ITER-001 2) (UPPER-BOUND-000 ARITY)
               (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
              (CL:DECLARE
               (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001
                LENGTH-001 I ITER-001 UPPER-BOUND-000))
              (CL:LOOP WHILE
               (CL:AND (CL:< INDEX-000 LENGTH-000)
                (CL:< INDEX-001 LENGTH-001)
                (CL:OR UNBOUNDED?-000
                 (CL:<= ITER-001 UPPER-BOUND-000)))
               DO
               (CL:SETQ ARG1
                (CL:AREF
                 (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
                 INDEX-000))
               (CL:SETQ ARG2
                (CL:AREF
                 (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
                 INDEX-001))
               (CL:SETQ I ITER-001)
               (CL:WHEN (CL:NOT (EQL? (VALUE-OF ARG1) (VALUE-OF ARG2)))
                (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
               (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
               (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
               (CL:SETQ ITER-001 (CL:1+ ITER-001))))
             (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
            (CL:WHEN TEST-VALUE-000
             (CL:SETQ TEST-VALUE-000
              (CL:AND (CL:= ARITY (LENGTH (%ARGUMENTS P)))
               (SUBCONTEXT? HOMEMODULE
                (%BASE-MODULE (%HOME-CONTEXT P)))))))
           (CL:WHEN TEST-VALUE-000
            (CL:RETURN-FROM FIND-DUPLICATE-COMPLEX-PROPOSITION P))))
         (CL:WHEN
          (CL:AND (EQUIVALENT-PROPOSITIONS? SELF P NULL)
           (SUBCONTEXT? HOMEMODULE (%BASE-MODULE (%HOME-CONTEXT P))))
          (CL:RETURN-FROM FIND-DUPLICATE-COMPLEX-PROPOSITION P)))))
      (CL:T))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (PUSH BUCKET SELF) NULL))

;;; (DEFUN (FIND-DUPLICATE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FIND-DUPLICATE-PROPOSITION (SELF)
  (CL:WHEN
   (CL:OR (DESCRIPTION-MODE?)
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-DESCRIPTIVE? FALSE-WRAPPER)))
   (CL:RETURN-FROM FIND-DUPLICATE-PROPOSITION NULL))
  (CL:COND
   ((CL:EQ (%KIND SELF) KWD-PROPOSITIONS-DISABLED)
    (CL:LET* ((VALUE-000 NULL))
     (CL:LET*
      ((P NULL)
       (ITER-000 (ALLOCATE-ITERATOR (FIND-SIMILAR-PROPOSITIONS SELF))))
      (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
       (CL:WHEN
        (CL:AND (EQUIVALENT-PROPOSITIONS? SELF P NULL)
         (SUBCONTEXT? (%BASE-MODULE (%HOME-CONTEXT SELF))
          (%BASE-MODULE (%HOME-CONTEXT P))))
        (CL:SETQ VALUE-000 P) (CL:RETURN))))
     (CL:LET* ((VALUE-001 VALUE-000)) VALUE-001)))
   (CL:T (FIND-DUPLICATE-COMPLEX-PROPOSITION SELF))))

;;; (DEFSPECIAL *DONT-CHECK-FOR-DUPLICATE-PROPOSITIONS?* ...)

(CL:DEFVAR *DONT-CHECK-FOR-DUPLICATE-PROPOSITIONS?* CL:NIL
  "If TRUE never check for the existence of duplicate
propositions when building a new proposition.")

;;; (DEFUN (FASTEN-DOWN-ONE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FASTEN-DOWN-ONE-PROPOSITION (SELF DONTCHECKFORDUPLICATES?)
  (CL:WHEN (NATIVE-SLOT-PROPOSITION? SELF)
   (CL:RETURN-FROM FASTEN-DOWN-ONE-PROPOSITION SELF))
  (CL:WHEN (CL:NOT *LOADINGREGENERABLEOBJECTS?*)
   (SURROGATIFY-DISCOURAGED-ARGUMENTS SELF))
  (CL:LET* ((DUPLICATE NULL))
   (CL:WHEN
    (CL:NOT
     (CL:OR DONTCHECKFORDUPLICATES?
      *DONT-CHECK-FOR-DUPLICATE-PROPOSITIONS?*
      *LOADINGREGENERABLEOBJECTS?*))
    (CL:SETQ DUPLICATE (FIND-DUPLICATE-PROPOSITION SELF)))
   (CL:IF (CL:NOT (CL:EQ DUPLICATE NULL))
    (CL:PROGN
     (CL:WHEN
      (CL:NOT
       (EQUAL?
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS DUPLICATE)
         SYM-PROPOSITIONS-LOGIC-ANNOTATIONS NULL)
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-PROPOSITIONS-LOGIC-ANNOTATIONS NULL)))
      (CLEAR-PROPOSITION-ANNOTATIONS DUPLICATE)
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS DUPLICATE)
       SYM-PROPOSITIONS-LOGIC-ANNOTATIONS
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
        SYM-PROPOSITIONS-LOGIC-ANNOTATIONS NULL)
       NULL)
      (FINALIZE-PROPOSITION-ANNOTATIONS DUPLICATE)
      (EVALUATE-NEW-PROPOSITION DUPLICATE))
     DUPLICATE)
    (CL:PROGN
     (CL:WHEN
      (CL:NOT
       (CL:OR
        (%WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
          SYM-PROPOSITIONS-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
        (DESCRIPTION-MODE?)))
      (CL:WHEN (CL:NOT *LOADINGREGENERABLEOBJECTS?*)
       (LOG-NEWLY-CONCEIVED-PROPOSITION *MODULE* SELF)))
     (CL:WHEN (CL:NOT *LOADINGREGENERABLEOBJECTS?*)
      (REWRAP-PROPOSITION-ARGUMENTS SELF))
     (CL:WHEN (CL:NOT *LOADINGREGENERABLEOBJECTS?*)
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (ADD-DEPENDENT-PROPOSITION-LINK ARG SELF)
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
     (UPDATE-DESCRIPTION-EXTENSION SELF)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-UNFASTENED? NULL NULL)
     (FINALIZE-PROPOSITION-ANNOTATIONS SELF)
     (EVALUATE-NEW-PROPOSITION SELF) SELF))))

;;; (DEFSPECIAL *VISITEDUNFASTENEDDEFININGPROPOSITIONS* ...)

(CL:DEFVAR *VISITEDUNFASTENEDDEFININGPROPOSITIONS* NULL
  "Used by 'recursively-fasten-down-propositions'.")

;;; (DEFUN (HELP-FASTEN-DOWN-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN HELP-FASTEN-DOWN-PROPOSITIONS (SELF DONTCHECKFORDUPLICATES?)
  (CL:LET* ((DONTCHECKARGSFORDUPLICATES? DONTCHECKFORDUPLICATES?))
   (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FORALL)
       (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-EXISTS))
      (CL:SETQ DONTCHECKARGSFORDUPLICATES? CL:T))
     (CL:T
      (CL:WHEN
       (%WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-PROPOSITIONS-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
       (CL:SETQ DONTCHECKARGSFORDUPLICATES? CL:T)))))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE ARG)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-001 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
        (CL:PROGN
         (CL:WHEN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (UNFASTENED? ARG))
          (CL:LET
           ((SELF (%THE-ARRAY (%ARGUMENTS SELF)))
            (VALUE
             (HELP-FASTEN-DOWN-PROPOSITIONS ARG
              DONTCHECKARGSFORDUPLICATES?))
            (POSITION I))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SETF (CL:AREF SELF POSITION) VALUE)))))
       ((SUBTYPE-OF? TEST-VALUE-001 SGT-PROPOSITIONS-LOGIC-SKOLEM)
        (CL:PROGN
         (CL:LET* ((DEFININGPROP (%DEFINING-PROPOSITION ARG)))
          (CL:WHEN
           (CL:AND (CL:NOT (CL:EQ DEFININGPROP NULL))
            (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
             (UNFASTENED? DEFININGPROP))
            (CL:NOT
             (MEMBER? *VISITEDUNFASTENEDDEFININGPROPOSITIONS*
              DEFININGPROP)))
           (INSERT *VISITEDUNFASTENEDDEFININGPROPOSITIONS*
            DEFININGPROP)
           (HELP-FASTEN-DOWN-PROPOSITIONS DEFININGPROP
            DONTCHECKARGSFORDUPLICATES?)))))
       (CL:T)))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (FASTEN-DOWN-ONE-PROPOSITION SELF DONTCHECKFORDUPLICATES?)))

;;; (DEFUN (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN RECURSIVELY-FASTEN-DOWN-PROPOSITIONS (SELF DONTCHECKFORDUPLICATES?)
  (CL:WHEN
   (CL:NOT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (UNFASTENED? SELF)))
   (CL:RETURN-FROM RECURSIVELY-FASTEN-DOWN-PROPOSITIONS SELF))
  (CL:LET* ((*VISITEDUNFASTENEDDEFININGPROPOSITIONS* (LIST)))
   (CL:DECLARE (CL:SPECIAL *VISITEDUNFASTENEDDEFININGPROPOSITIONS*))
   (HELP-FASTEN-DOWN-PROPOSITIONS SELF DONTCHECKFORDUPLICATES?)))

;;; (DEFUN UNFASTEN-PROPOSITION ...)

(CL:DEFUN UNFASTEN-PROPOSITION (PROPOSITION)
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ ARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
      INDEX-000))
    (REMOVE-DEPENDENT-PROPOSITION-LINK ARG PROPOSITION)
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
   SYM-PROPOSITIONS-LOGIC-UNFASTENED? TRUE-WRAPPER NULL))

;;; (DEFUN INSTANTIATE-UNDEFINED-SURROGATES ...)

(CL:DEFUN INSTANTIATE-UNDEFINED-SURROGATES (SELF)
  (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-AND)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-OR)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-NOT)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-EXISTS))
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (INSTANTIATE-UNDEFINED-SURROGATES ARG)
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-ISA))
     (CL:LET*
      ((ARG NULL) (VECTOR-001 (%ARGUMENTS SELF)) (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:COND
        ((SUBTYPE-OF-SURROGATE? (SAFE-PRIMARY-TYPE ARG))
         (CL:PROGN
          (CL:WHEN (CL:EQ (%SURROGATE-VALUE ARG) NULL)
           (CREATE-LOGIC-INSTANCE ARG NULL))))
        (CL:T))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
    (CL:T))))

;;; (DEFUN (BUILD-TOP-LEVEL-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-TOP-LEVEL-PROPOSITION (TREE TRUEASSERTION?)
  (CL:WHEN (ISA? TREE SGT-PROPOSITIONS-STELLA-STRING-WRAPPER)
   (CL:RETURN-FROM BUILD-TOP-LEVEL-PROPOSITION
    (BUILD-TOP-LEVEL-PROPOSITION
     (READ-S-EXPRESSION-FROM-STRING (%WRAPPER-VALUE TREE))
     TRUEASSERTION?)))
  (CL:LET*
   ((PROPOSITION NULL) (LOGICVARIABLETABLE *LOGICVARIABLETABLE*))
   (CL:LET*
    ((*LOGICVARIABLETABLE*
      (CL:IF (CL:NOT (CL:EQ LOGICVARIABLETABLE NULL))
       LOGICVARIABLETABLE NIL))
     (*VARIABLEIDCOUNTER* *VARIABLEIDCOUNTER*)
     (*TERMUNDERCONSTRUCTION* TREE))
    (CL:DECLARE
     (CL:SPECIAL *LOGICVARIABLETABLE* *VARIABLEIDCOUNTER*
      *TERMUNDERCONSTRUCTION*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *VARIABLEIDCOUNTER*))
    (CL:SETQ PROPOSITION (BUILD-PROPOSITION TREE))
    (CL:WHEN (CL:NOT (CL:EQ PROPOSITION NULL))
     (NORMALIZE-TOP-LEVEL-PROPOSITION PROPOSITION NULL)
     (VERIFY-FORALL-PROPOSITIONS PROPOSITION)
     (CL:WHEN
      (CL:NOT
       (CL:EQ (COLLECT-UNRESOLVED-SLOT-REFERENCES PROPOSITION) NIL))
      (CL:WHEN TRUEASSERTION?
       (UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS PROPOSITION))
      (RESOLVE-UNRESOLVED-SLOT-REFERENCES PROPOSITION))
     (CL:WHEN
      (CL:AND TRUEASSERTION?
       (CL:EQ (%KIND PROPOSITION) KWD-PROPOSITIONS-EXISTS)
       (CL:NOT (DESCRIPTION-MODE?)))
      (INSTANTIATE-UNDEFINED-SURROGATES PROPOSITION))
     (CL:SETQ PROPOSITION
      (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS PROPOSITION CL:NIL))))
   PROPOSITION))

;;; (DEFUN (BUILD-PROPOSITION OBJECT) ...)

(CL:DEFUN BUILD-PROPOSITION (TREE)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-CONS)
     (CL:PROGN (CONS.BUILD-PROPOSITION TREE)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (SURROGATE.BUILD-PROPOSITION TREE)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN (SYMBOL.BUILD-PROPOSITION TREE)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
        "ERROR: Illegal logical sentence: `" TREE "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
        KWD-PROPOSITIONS-ERROR))
      (CL:ERROR
       (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (SURROGATE.BUILD-PROPOSITION PROPOSITION) ...)

(CL:DEFUN SURROGATE.BUILD-PROPOSITION (SELF)
  (CL:LET* ((VALUE (%SURROGATE-VALUE SELF)) (PROPOSITION NULL))
   (CL:IF (CL:NOT (CL:EQ VALUE NULL))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE VALUE)
       SGT-PROPOSITIONS-LOGIC-PROPOSITION)
      (CL:PROGN (CL:SETQ PROPOSITION VALUE)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "ERROR: Expected `"
         (%SYMBOL-NAME SELF) "' to have type proposition." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
         KWD-PROPOSITIONS-ERROR))
       (CL:ERROR
        (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))))
    (CL:PROGN
     (CL:SETQ PROPOSITION
      (CREATE-PROPOSITION SYM-PROPOSITIONS-LOGIC-CONSTANT 0))
     (CL:SETF (%OPERATOR PROPOSITION) SELF)
     (CL:SETF (%SURROGATE-VALUE SELF) PROPOSITION)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-STELLA-SURROGATE-VALUE-INVERSE SELF NULL)))
   PROPOSITION))

;;; (DEFUN (SYMBOL.BUILD-PROPOSITION OBJECT) ...)

(CL:DEFUN SYMBOL.BUILD-PROPOSITION (SYMBOL)
  (CL:LET* ((PROPOSITION NULL))
   (CL:COND
    ((CL:EQ SYMBOL SYM-PROPOSITIONS-STELLA-TRUE)
     (CL:SETQ PROPOSITION TRUE-PROPOSITION))
    ((CL:EQ SYMBOL SYM-PROPOSITIONS-STELLA-FALSE)
     (CL:SETQ PROPOSITION FALSE-PROPOSITION))
    (CL:T
     (CL:RETURN-FROM SYMBOL.BUILD-PROPOSITION
      (EVALUATE-SYMBOL-TERM SYMBOL))))
   PROPOSITION))

;;; (DEFUN (CONS.BUILD-PROPOSITION PROPOSITION) ...)

(CL:DEFUN CONS.BUILD-PROPOSITION (TREE)
  (CL:LET* ((PROPOSITION NULL))
   (CL:WHEN
    (CL:NOT (ISA? (%%VALUE TREE) SGT-PROPOSITIONS-STELLA-SYMBOL))
    (CL:ERROR
     "Safety violation: INTERNAL ERROR: Illegal operator in proposition tree."))
   (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-=)
      (CL:SETQ PROPOSITION (BUILD-EQUIVALENCE-PROPOSITION TREE)))
     ((CL:OR (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-AND)
       (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-OR)
       (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-NOT))
      (CL:SETQ PROPOSITION (BUILD-AND-OR-NOT-PROPOSITION TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-ISA)
      (CL:SETQ PROPOSITION (BUILD-ISA-PROPOSITION TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-PL-KERNEL-KB-MEMBER-OF)
      (CL:SETQ PROPOSITION (BUILD-MEMBER-OF-PROPOSITION TREE)))
     ((CL:OR (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-IMPLIES)
       (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF))
      (CL:SETQ PROPOSITION (BUILD-IMPLIES-PROPOSITION TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-EXISTS)
      (CL:SETQ PROPOSITION (BUILD-EXISTS-PROPOSITION TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-FORALL)
      (CL:SETQ PROPOSITION (BUILD-FORALL-PROPOSITION TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-FAIL)
      (CL:SETQ PROPOSITION (BUILD-FAIL-PROPOSITION TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-COLLECT-INTO)
      (CL:SETQ PROPOSITION (BUILD-COLLECT-INTO-PROPOSITION TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-ABOUT)
      (CL:SETQ PROPOSITION (BUILD-ANNOTATED-PROPOSITION TREE)))
     (CL:T (CL:SETQ PROPOSITION (BUILD-PREDICATE-PROPOSITION TREE)))))
   (CL:WHEN (CL:EQ PROPOSITION NULL)
    (CL:RETURN-FROM CONS.BUILD-PROPOSITION NULL))
   (CL:WHEN (CONTAINS-NESTED-ARGUMENT? PROPOSITION)
    (CL:SETQ PROPOSITION
     (FLATTEN-NESTED-FUNCTION-ARGUMENTS PROPOSITION)))
   PROPOSITION))

;;; (DEFUN VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS ...)

(CL:DEFUN VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS (TREE CORRECTNUMBER)
  (CL:DECLARE (CL:TYPE CL:FIXNUM CORRECTNUMBER))
  #+MCL
  (CL:CHECK-TYPE CORRECTNUMBER CL:FIXNUM)
  (CL:WHEN (CL:NOT (CL:= (LENGTH (%%REST TREE)) CORRECTNUMBER))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "ERROR: Wrong number of arguments in proposition: `" TREE "'" EOL
      "   Expected `" CORRECTNUMBER "' arguments.." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))))

;;; (DEFMETHOD (DESCRIPTION-SURROGATE TYPE) ...)

(CL:DEFMETHOD DESCRIPTION-SURROGATE ((SELF DESCRIPTION))
  (CL:LET* ((NATIVERELATION (NATIVE-RELATION SELF)))
   (CL:WHEN (CL:NOT (CL:EQ NATIVERELATION NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NATIVERELATION)))
     (CL:COND
      ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
       (CL:PROGN
        (CL:RETURN-FROM DESCRIPTION-SURROGATE
         (CLASS-LOGICAL-TYPE NATIVERELATION))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-SLOT)
       (CL:PROGN
        (CL:RETURN-FROM DESCRIPTION-SURROGATE
         (%SLOT-SLOTREF NATIVERELATION))))
      (CL:T))))
   NULL))

;;; (DEFUN (BUILD-ISA-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-ISA-PROPOSITION (TREE)
  (VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS TREE 2)
  (CL:LET*
   ((PROPOSITION (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-ISA 1))
    (TYPE NULL) (SYMBOL (%%VALUE (%%REST (%%REST TREE)))))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SYMBOL)))
    (CL:COND
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ TYPE SYMBOL)))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ TYPE (SYMBOL-TO-SURROGATE SYMBOL))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
         "ERROR: Illegal token where symbol expected: `" SYMBOL "'."
         EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
         KWD-PROPOSITIONS-ERROR))
       (CL:ERROR
        (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))))
   (CL:LET* ((CLASS (GET-DESCRIPTION TYPE)))
    (CL:WHEN (CL:EQ CLASS NULL)
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
        "ERROR: No class is associated with the term `"
        (%SYMBOL-NAME TYPE) "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001
        KWD-PROPOSITIONS-ERROR))
      (CL:ERROR
       (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001)))))
    (CL:WHEN (CL:NOT (CLASS-DESCRIPTION? CLASS))
     (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "ERROR: Term `"
        (%SYMBOL-NAME TYPE) "' found where class expected.." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-002
        KWD-PROPOSITIONS-ERROR))
      (CL:ERROR
       (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-002))))))
   (CL:SETF (%OPERATOR PROPOSITION) TYPE)
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
     (VALUE (EVALUATE-TYPED-ARGUMENT (%%VALUE (%%REST TREE)) TYPE))
     (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   PROPOSITION))

;;; (DEFUN (BUILD-MEMBER-OF-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-MEMBER-OF-PROPOSITION (TREE)
  (VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS TREE 2)
  (CL:LET* ((COLLECTIONREF (%%VALUE (%%REST (%%REST TREE)))))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE COLLECTIONREF)))
    (CL:COND
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN
       (CL:WHEN
        (CL:NOT (CL:EQ (GET-STELLA-CLASS COLLECTIONREF CL:NIL) NULL))
        (CL:RETURN-FROM BUILD-MEMBER-OF-PROPOSITION
         (BUILD-ISA-PROPOSITION TREE)))))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN
       (CL:WHEN
        (CL:NOT (CL:EQ (GET-STELLA-CLASS COLLECTIONREF CL:NIL) NULL))
        (CL:RETURN-FROM BUILD-MEMBER-OF-PROPOSITION
         (BUILD-ISA-PROPOSITION TREE)))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
      (CL:PROGN
       (CL:WHEN
        (CL:AND (NAMED-DESCRIPTION? COLLECTIONREF)
         (CLASS-DESCRIPTION? COLLECTIONREF))
        (CL:RETURN-FROM BUILD-MEMBER-OF-PROPOSITION
         (BUILD-ISA-PROPOSITION
          (LIST* SYM-PROPOSITIONS-STELLA-ISA (%%VALUE (%%REST TREE))
           (CONS (DESCRIPTION-SURROGATE COLLECTIONREF) NIL)))))))
     (CL:T))))
  (BUILD-PREDICATE-PROPOSITION TREE))

;;; (DEFUN (MEMBER-OF-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN MEMBER-OF-PROPOSITION? (PROPOSITION)
  (CL:EQ (%OPERATOR PROPOSITION)
   SGT-PROPOSITIONS-PL-KERNEL-KB-MEMBER-OF))

;;; (DEFUN (SUBSET-OF-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN SUBSET-OF-PROPOSITION? (PROPOSITION)
  (CL:EQ (%OPERATOR PROPOSITION)
   SGT-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF))

;;; (DEFUN (SIMPLE-SUBRELATION-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN SIMPLE-SUBRELATION-PROPOSITION? (PROPOSITION)
  (CL:AND
   (CL:EQ (%OPERATOR PROPOSITION)
    SGT-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF)
   (ISA?
    (CL:AREF
     (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 0)
    SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
   (ISA?
    (CL:AREF
     (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 1)
    SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)))

;;; (DEFUN (EXTRACT-ANNOTATION OBJECT OBJECT) ...)

(CL:DEFUN EXTRACT-ANNOTATION (TREE OPTION)
  (CL:LET* ((VALUE NULL))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-PROPOSITIONS-STELLA-CONS)
     (CL:PROGN
      (CL:WHEN (CL:EQ (%%VALUE TREE) SYM-PROPOSITIONS-LOGIC-ABOUT)
       (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
        (CL:SETF (%THE-PLIST SELF-000) (%%REST (%%REST TREE)))
        (CL:LET* ((OPTIONS SELF-000))
         (CL:SETQ VALUE (LOOKUP OPTIONS OPTION))
         (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
          (REMOVE-AT OPTIONS OPTION)
          (CL:SETF (%%REST (%%REST TREE)) (%THE-PLIST OPTIONS))))))))
    (CL:T))
   (CL:VALUES TREE VALUE)))

;;; (DEFUN (LOOKUP-ANNOTATION OBJECT) ...)

(CL:DEFUN LOOKUP-ANNOTATION (PROPOSITION KEY)
  (CL:LET*
   ((ANNOTATIONS
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-LOGIC-ANNOTATIONS NULL)))
   (CL:IF (CL:NOT (CL:EQ ANNOTATIONS NULL)) (LOOKUP ANNOTATIONS KEY)
    NULL)))

;;; (DEFUN INSERT-ANNOTATION ...)

(CL:DEFUN INSERT-ANNOTATION (PROPOSITION KEY VALUE)
  (CL:LET*
   ((ANNOTATIONS
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-LOGIC-ANNOTATIONS NULL)))
   (CL:WHEN (CL:EQ ANNOTATIONS NULL)
    (CL:SETQ ANNOTATIONS (NEW-PROPERTY-LIST))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
     SYM-PROPOSITIONS-LOGIC-ANNOTATIONS ANNOTATIONS NULL))
   (INSERT-AT ANNOTATIONS KEY VALUE)))

;;; (DEFUN REMOVE-ANNOTATION ...)

(CL:DEFUN REMOVE-ANNOTATION (PROPOSITION KEY)
  (CL:LET*
   ((ANNOTATIONS
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-LOGIC-ANNOTATIONS NULL)))
   (CL:WHEN (CL:EQ ANNOTATIONS NULL)
    (CL:RETURN-FROM REMOVE-ANNOTATION))
   (REMOVE-AT ANNOTATIONS KEY)
   (CL:WHEN (CL:EQ (%THE-PLIST ANNOTATIONS) NIL)
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
     SYM-PROPOSITIONS-LOGIC-ANNOTATIONS NULL NULL))))

;;; (DEFUN (BUILD-ANNOTATED-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-ANNOTATED-PROPOSITION (TREE)
  (CL:LET*
   ((PROPOSITION (BUILD-PROPOSITION (%%VALUE (%%REST TREE))))
    (OPTIONS (%%REST (%%REST TREE))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ OPTIONS NIL)) DO
    (CL:IF
     (ISA? (%%VALUE OPTIONS)
      SGT-PROPOSITIONS-STELLA-GENERALIZED-SYMBOL)
     (FIRST-SETTER OPTIONS (KEYWORDIFY (%%VALUE OPTIONS)))
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
        "PARSING ERROR: Illegal annotation option: `" (%%VALUE OPTIONS)
        "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
        KWD-PROPOSITIONS-ERROR))
      (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
    (CL:WHEN (CL:EQ (%%VALUE (%%REST OPTIONS)) NULL)
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
        "PARSING ERROR: Missing annotation value for option: `"
        (%%VALUE OPTIONS) "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001
        KWD-PROPOSITIONS-ERROR))
      (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-001)))))
    (CL:SETQ OPTIONS (%%REST (%%REST OPTIONS))))
   (CL:LET* ((SELF-004 (NEW-PROPERTY-LIST)))
    (CL:SETF (%THE-PLIST SELF-004) (%%REST (%%REST TREE)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
     SYM-PROPOSITIONS-LOGIC-ANNOTATIONS SELF-004 NULL))
   (FINALIZE-PROPOSITION-ANNOTATIONS PROPOSITION) PROPOSITION))

;;; (DEFUN FINALIZE-PROPOSITION-ANNOTATIONS ...)

(CL:DEFUN FINALIZE-PROPOSITION-ANNOTATIONS (PROPOSITION)
  (CL:LET*
   ((ANNOTATIONS
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-LOGIC-ANNOTATIONS NULL)))
   (CL:WHEN (CL:NOT (CL:EQ ANNOTATIONS NULL))
    (CL:LET*
     ((OPTION NULL) (VALUE NULL) (ITER-000 (%THE-PLIST ANNOTATIONS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ OPTION (%%VALUE ITER-000))
      (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
      (CL:COND
       ((CL:EQ OPTION KWD-PROPOSITIONS-DIRECTION)
        (CL:COND
         ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE VALUE)
           SGT-PROPOSITIONS-STELLA-GENERALIZED-SYMBOL)
          (CL:PROGN
           (CL:LET*
            ((TEST-VALUE-000 (STRING-UPCASE (%SYMBOL-NAME VALUE))))
            (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEST-VALUE-000))
            (CL:COND
             ((STRING-EQL? TEST-VALUE-000 "FORWARD")
              (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
               SYM-PROPOSITIONS-LOGIC-FORWARD-ONLY?
               (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
             ((STRING-EQL? TEST-VALUE-000 "BACKWARD")
              (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
               SYM-PROPOSITIONS-LOGIC-BACKWARD-ONLY?
               (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
             (CL:T (REMOVE-AT ANNOTATIONS OPTION)
              (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
               (CL:LET* ((*PRINTREADABLY?* CL:T))
                (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
                (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
                 "PARSING ERROR: Illegal value for :direction option: `"
                 VALUE "'." EOL)
                (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
                 KWD-PROPOSITIONS-ERROR))
               (CL:ERROR
                (NEW-PARSING-ERROR
                 (THE-STRING-READER STREAM-000)))))))))
         (CL:T (REMOVE-AT ANNOTATIONS OPTION)
          (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
           (CL:LET* ((*PRINTREADABLY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
             "PARSING ERROR: Illegal value for :direction option: `"
             VALUE "'." EOL)
            (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001
             KWD-PROPOSITIONS-ERROR))
           (CL:ERROR
            (NEW-PARSING-ERROR (THE-STRING-READER STREAM-001)))))))
       ((CL:EQ OPTION KWD-PROPOSITIONS-WEIGHT)
        (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE VALUE)))
         (CL:COND
          ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
           (CL:PROGN
            (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
             SYM-PROPOSITIONS-LOGIC-WEIGHT
             (WRAP-FLOAT (NUMBER-WRAPPER-TO-FLOAT VALUE))
             NULL-FLOAT-WRAPPER)))
          ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
           (CL:PROGN
            (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
             SYM-PROPOSITIONS-LOGIC-WEIGHT
             (WRAP-FLOAT (%WRAPPER-VALUE VALUE)) NULL-FLOAT-WRAPPER)))
          (CL:T (REMOVE-AT ANNOTATIONS OPTION)
           (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002)
              "PARSING ERROR: Illegal value for :weight option: `"
              VALUE "'." EOL)
             (HELP-SIGNAL-PROPOSITION-ERROR STREAM-002
              KWD-PROPOSITIONS-ERROR))
            (CL:ERROR
             (NEW-PARSING-ERROR (THE-STRING-READER STREAM-002))))))))
       ((CL:EQ OPTION KWD-PROPOSITIONS-CONFIDENCE-LEVEL))
       (CL:T
        (CL:WHEN
         (CL:NOT (RUN-OPTION-HANDLER? PROPOSITION OPTION VALUE))
         (REMOVE-AT ANNOTATIONS OPTION)
         (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-003)
            "PARSING ERROR: Unrecognized annotation option: `" OPTION
            "'." EOL)
           (HELP-SIGNAL-PROPOSITION-ERROR STREAM-003
            KWD-PROPOSITIONS-ERROR))
          (CL:ERROR
           (NEW-PARSING-ERROR (THE-STRING-READER STREAM-003)))))))
      (CL:SETQ ITER-000 (%%REST (%%REST ITER-000))))))))

;;; (DEFUN CLEAR-PROPOSITION-ANNOTATIONS ...)

(CL:DEFUN CLEAR-PROPOSITION-ANNOTATIONS (PROPOSITION)
  (CL:LET*
   ((ANNOTATIONS
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-LOGIC-ANNOTATIONS NULL)))
   (CL:WHEN (CL:NOT (CL:EQ ANNOTATIONS NULL))
    (CL:LET*
     ((OPTION NULL) (VALUE NULL) (ITER-000 (%THE-PLIST ANNOTATIONS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ OPTION (%%VALUE ITER-000))
      (CL:SETQ VALUE (%%VALUE (%%REST ITER-000))) (CL:SETQ VALUE VALUE)
      (CL:COND
       ((CL:EQ OPTION KWD-PROPOSITIONS-DIRECTION)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
         SYM-PROPOSITIONS-LOGIC-FORWARD-ONLY?
         (CL:IF CL:NIL TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
         SYM-PROPOSITIONS-LOGIC-BACKWARD-ONLY?
         (CL:IF CL:NIL TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
       ((CL:EQ OPTION KWD-PROPOSITIONS-WEIGHT)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
         SYM-PROPOSITIONS-LOGIC-WEIGHT (WRAP-FLOAT NULL-FLOAT)
         NULL-FLOAT-WRAPPER))
       (CL:T (RUN-OPTION-HANDLER? PROPOSITION OPTION NULL)))
      (CL:SETQ ITER-000 (%%REST (%%REST ITER-000))))))))

;;; (DEFUN (FUNCTION-INDUCED-EXISTS? BOOLEAN) ...)

(CL:DEFUN FUNCTION-INDUCED-EXISTS? (PROPOSITION)
  (CL:WHEN (CL:EQ (%KIND PROPOSITION) KWD-PROPOSITIONS-EXISTS)
   (CL:LET*
    ((FIRSTARGUMENT
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (CL:WHEN
     (CL:AND (ISA? FIRSTARGUMENT SGT-PROPOSITIONS-LOGIC-PROPOSITION)
      (CL:EQ (%KIND FIRSTARGUMENT) KWD-PROPOSITIONS-AND))
     (CL:LET*
      ((EXISTSVARIABLES
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
         SYM-PROPOSITIONS-LOGIC-IO-VARIABLES NULL))
       (ANDPROP FIRSTARGUMENT) (ANDARGUMENTS (%ARGUMENTS ANDPROP))
       (NONFUNCTIONSCOUNT 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM NONFUNCTIONSCOUNT))
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET*
        ((VARIABLE NULL) (VECTOR-000 EXISTSVARIABLES) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ VARIABLE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:LET* ((TEST-VALUE-000 CL:NIL))
          (CL:LET* ((FOUND?-000 CL:NIL))
           (CL:LET*
            ((ARG NULL) (VECTOR-001 ANDARGUMENTS) (INDEX-001 0)
             (LENGTH-001 (LENGTH VECTOR-001)))
            (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
            (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
             (CL:SETQ ARG
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
               INDEX-001))
             (CL:WHEN
              (CL:AND (CL:EQ (%KIND ARG) KWD-PROPOSITIONS-FUNCTION)
               (CL:EQ (LAST (%ARGUMENTS ARG)) VARIABLE))
              (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
             (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
           (CL:SETQ TEST-VALUE-000 FOUND?-000))
          (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
          (CL:WHEN TEST-VALUE-000 (CL:SETQ ALWAYS?-000 CL:NIL)
           (CL:RETURN)))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
       (CL:WHEN ALWAYS?-000
        (CL:LET*
         ((ARG NULL) (VECTOR-002 ANDARGUMENTS) (INDEX-002 0)
          (LENGTH-002 (LENGTH VECTOR-002)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
         (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
          (CL:SETQ ARG
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-002))
            INDEX-002))
          (CL:WHEN
           (CL:AND
            (CL:NOT (CL:EQ (%KIND ARG) KWD-PROPOSITIONS-FUNCTION))
            (CL:NOT
             (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? ARG))))
           (CL:SETQ NONFUNCTIONSCOUNT (CL:1+ NONFUNCTIONSCOUNT)))
          (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
        (CL:RETURN-FROM FUNCTION-INDUCED-EXISTS?
         (CL:= NONFUNCTIONSCOUNT 1))))))))
  CL:NIL)

;;; (DEFUN (PREDICATE-OF-FUNCTION-INDUCED-EXISTS PROPOSITION) ...)

(CL:DEFUN PREDICATE-OF-FUNCTION-INDUCED-EXISTS (EXISTSPROPOSITION)
  (CL:LET* ((VALUE-000 NULL))
   (CL:LET*
    ((ARG NULL)
     (VECTOR-000
      (%ARGUMENTS
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%THE-ARRAY (%ARGUMENTS EXISTSPROPOSITION)))
        0)))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ (%KIND ARG) KWD-PROPOSITIONS-FUNCTION))
       (CL:NOT
        (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? ARG))))
      (CL:SETQ VALUE-000 ARG) (CL:RETURN))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET* ((VALUE-001 VALUE-000)) VALUE-001)))

;;; (DEFUN (EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS PROPOSITION) ...)

(CL:DEFUN EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS (EXISTSPROPOSITION)
  (INVERT-PROPOSITION
   (PREDICATE-OF-FUNCTION-INDUCED-EXISTS EXISTSPROPOSITION))
  EXISTSPROPOSITION)

;;; (DEFUN (BUILD-AND-OR-NOT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-AND-OR-NOT-PROPOSITION (TREE)
  (CL:LET*
   ((TERM NULL) (ARGUMENTS NIL) (PROPOSITION NULL)
    (ARGUMENTSVECTOR NULL))
   (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-AND)
       (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-OR)
       (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-NOT))
      (CL:LET* ((ARG NULL) (ITER-000 (%%REST TREE)) (COLLECT-000 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ ARG (%%VALUE ITER-000))
        (CL:LET* () (CL:SETQ TERM (BUILD-PROPOSITION ARG))
         (CL:WHEN (CL:NOT (CL:EQ TERM NULL))
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS TERM NIL))
            (CL:IF (CL:EQ ARGUMENTS NIL)
             (CL:SETQ ARGUMENTS COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST ARGUMENTS COLLECT-000)))
           (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS TERM NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
        (CL:SETQ ITER-000 (%%REST ITER-000)))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:WHEN
    (CL:AND (CL:EQ ARGUMENTS NIL)
     (CL:EQ (%%VALUE TREE) SYM-PROPOSITIONS-STELLA-NOT))
    (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
       "ERROR: Missing argument in NOT proposition: `" TREE "'." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001
       KWD-PROPOSITIONS-ERROR))
     (CL:ERROR
      (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001)))))
   (CL:WHEN
    (CL:AND (CL:EQ (%%VALUE TREE) SYM-PROPOSITIONS-STELLA-NOT)
     (ISA? (%%VALUE ARGUMENTS) SGT-PROPOSITIONS-LOGIC-PROPOSITION)
     (FUNCTION-INDUCED-EXISTS? (%%VALUE ARGUMENTS)))
    (CL:RETURN-FROM BUILD-AND-OR-NOT-PROPOSITION
     (EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS
      (%%VALUE ARGUMENTS))))
   (CL:SETQ PROPOSITION
    (CREATE-PROPOSITION (%%VALUE TREE) (LENGTH ARGUMENTS)))
   (CL:SETQ ARGUMENTSVECTOR (%ARGUMENTS PROPOSITION))
   (CL:LET*
    ((ARG NULL) (ITER-001 ARGUMENTS) (I NULL-INTEGER) (ITER-002 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ ARG (%%VALUE ITER-001)) (CL:SETQ I ITER-002)
     (CL:LET
      ((SELF (%THE-ARRAY ARGUMENTSVECTOR)) (VALUE ARG) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-001 (%%REST ITER-001))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))))
   PROPOSITION))

;;; (DEFUN (FUNCTIONAL-TERM? BOOLEAN) ...)

(CL:DEFUN FUNCTIONAL-TERM? (TERM)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TERM) SGT-PROPOSITIONS-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((TEST-VALUE-000 (%%VALUE TERM)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-SETOFALL)
         (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-THE-ONLY)
         (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-SETOF)
         (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-LISTOF)
         (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-KAPPA))
        CL:NIL)
       (CL:T CL:T)))))
   (CL:T CL:NIL)))

;;; (DEFUN (CLIP-VALUE? BOOLEAN) ...)

(CL:DEFUN CLIP-VALUE? (TERM1 TERM2)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM1)
     SGT-PROPOSITIONS-LOGIC-SKOLEM)
    (CL:PROGN
     (CL:LET* ((VALUE1 (VALUE-OF TERM1)))
      (CL:WHEN (EQL? VALUE1 TERM2) (CL:RETURN-FROM CLIP-VALUE? CL:T))
      (CL:WHEN
       (CL:AND (CL:NOT (SKOLEM? VALUE1))
        (CL:NOT (CL:EQ (%DEFINING-PROPOSITION TERM1) NULL))
        *CLIPPINGENABLED?*)
       (UNBIND-SKOLEM-VALUE TERM1 CL:T)
       (BIND-SKOLEM-TO-VALUE TERM1 (VALUE-OF TERM2) CL:T)
       (CL:RETURN-FROM CLIP-VALUE? CL:T)))))
   (CL:T))
  CL:NIL)

;;; (DEFUN (CREATE-EQUIVALENCE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN CREATE-EQUIVALENCE-PROPOSITION (TERM1 TERM2)
  (CL:LET*
   ((PROPOSITION
     (CREATE-PROPOSITION SYM-PROPOSITIONS-LOGIC-EQUIVALENT 2))
    (ARGUMENTSVECTOR (%ARGUMENTS PROPOSITION)))
   (CL:LET
    ((SELF (%THE-ARRAY ARGUMENTSVECTOR)) (VALUE TERM1) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY ARGUMENTSVECTOR)) (VALUE TERM2) (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   PROPOSITION))

;;; (DEFUN (BUILD-EQUIVALENCE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-EQUIVALENCE-PROPOSITION (TREE)
  (CL:CASE (LENGTH TREE)
   (3
    (CREATE-EQUIVALENCE-PROPOSITION
     (EVALUATE-TERM (%%VALUE (%%REST TREE)))
     (EVALUATE-TERM (%%VALUE (%%REST (%%REST TREE))))))
   ((1 2)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "ERROR: Missing argument/s in `=' proposition.." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
       KWD-PROPOSITIONS-ERROR))
     (CL:ERROR
      (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   (CL:OTHERWISE
    (BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS (%%REST TREE) NIL))))

;;; (DEFUN (BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS (REMAININGTERMS EQUIVALENCES)
  (CL:WHEN (CL:EQ (%%REST REMAININGTERMS) NIL)
   (CL:RETURN-FROM BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS
    (CONJOIN-PROPOSITIONS EQUIVALENCES)))
  (CL:SETQ EQUIVALENCES
   (CONS
    (BUILD-EQUIVALENCE-PROPOSITION
     (LIST* SYM-PROPOSITIONS-STELLA-= (%%VALUE REMAININGTERMS)
      (CONS (%%VALUE (%%REST REMAININGTERMS)) NIL)))
    EQUIVALENCES))
  (BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS (%%REST REMAININGTERMS)
   EQUIVALENCES))

;;; (DEFUN (BUILD-FAIL-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-FAIL-PROPOSITION (TREE)
  (CL:LET*
   ((PROPOSITION (CREATE-PROPOSITION SYM-PROPOSITIONS-LOGIC-FAIL 1))
    (ARGUMENT (BUILD-PROPOSITION (%%VALUE (%%REST TREE)))))
   (CL:WHEN (CL:EQ ARGUMENT NULL)
    (CL:RETURN-FROM BUILD-FAIL-PROPOSITION NULL))
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION))) (VALUE ARGUMENT)
     (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   PROPOSITION))

;;; (DEFUN (BUILD-COLLECT-INTO-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-COLLECT-INTO-PROPOSITION (TREE)
  (CL:LET*
   ((PROPOSITION
     (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-COLLECT-INTO 2))
    (ARGUMENTSVECTOR (%ARGUMENTS PROPOSITION)))
   (CL:LET
    ((SELF (%THE-ARRAY ARGUMENTSVECTOR))
     (VALUE (EVALUATE-TERM (%%VALUE (%%REST TREE)))) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY ARGUMENTSVECTOR))
     (VALUE (EVALUATE-TERM (%%VALUE (%%REST (%%REST TREE)))))
     (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   PROPOSITION))

;;; (DEFUN (HOLDS-OPERATOR? BOOLEAN) ...)

(CL:DEFUN HOLDS-OPERATOR? (OPERATOR)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OPERATOR)))
   (CL:COND
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:OR (CL:EQ OPERATOR SYM-PROPOSITIONS-PL-KERNEL-KB-HOLDS)
       (CL:NOT
        (CL:EQ (LOOKUP-LOGIC-VARIABLE-BINDING OPERATOR) NULL)))))
    ((CL:EQ TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-CONS)
     (CL:PROGN CL:T))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN VERIFY-EVALUABLE-OPERATOR ...)

(CL:DEFUN VERIFY-EVALUABLE-OPERATOR (OPERATOR KIND)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE OPERATOR)
     SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
    (CL:PROGN
     (CL:COND
      ((CL:EQ KIND KWD-PROPOSITIONS-PREDICATE)
       (CL:SETF (%SKOLEM-TYPE OPERATOR)
        SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION))
      ((CL:EQ KIND KWD-PROPOSITIONS-FUNCTION)
       (CL:SETF (%SKOLEM-TYPE OPERATOR)
        SGT-PROPOSITIONS-PL-KERNEL-KB-FUNCTION))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KIND
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
   (CL:T)))

;;; (DEFUN (BUILD-HOLDS-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-HOLDS-PROPOSITION (TREE)
  (CL:LET*
   ((OPERATOREXPRESSION (%%VALUE TREE))
    (EXPLICITHOLDS?
     (CL:EQ OPERATOREXPRESSION SYM-PROPOSITIONS-PL-KERNEL-KB-HOLDS))
    (ARGCOUNT (LENGTH (%%REST TREE)))
    (PROPOSITION
     (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-PREDICATE
      (CL:IF EXPLICITHOLDS? ARGCOUNT (CL:1+ ARGCOUNT)))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARGCOUNT))
   (CL:SETF (%OPERATOR PROPOSITION)
    SGT-PROPOSITIONS-PL-KERNEL-KB-HOLDS)
   (CL:WHEN EXPLICITHOLDS?
    (CL:LET*
     ((ARG NULL) (ITER-000 (%%REST TREE)) (I NULL-INTEGER)
      (ITER-001 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ ARG (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
      (CL:LET
       ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        (VALUE
         (CL:IF (CL:= I 0)
          (EVALUATE-FIRST-ARGUMENT ARG
           SYM-PROPOSITIONS-PL-KERNEL-KB-HOLDS)
          (EVALUATE-TERM ARG)))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (CL:1+ ITER-001))))
    (CL:RETURN-FROM BUILD-HOLDS-PROPOSITION PROPOSITION))
   (CL:LET* ((OPERATOR NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OPERATOREXPRESSION)))
     (CL:COND
      ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
       (CL:PROGN
        (CL:SETQ OPERATOR
         (LOOKUP-LOGIC-VARIABLE-BINDING OPERATOREXPRESSION))))
      ((CL:EQ TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-CONS)
       (CL:PROGN
        (CL:SETQ OPERATOR
         (EVALUATE-FIRST-ARGUMENT OPERATOREXPRESSION
          SYM-PROPOSITIONS-PL-KERNEL-KB-HOLDS))))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (VERIFY-EVALUABLE-OPERATOR OPERATOR KWD-PROPOSITIONS-PREDICATE)
    (CL:LET
     ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION))) (VALUE OPERATOR)
      (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET*
     ((ARG NULL) (ITER-002 (%%REST TREE)) (I NULL-INTEGER)
      (ITER-003 1))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:SETQ ARG (%%VALUE ITER-002)) (CL:SETQ I ITER-003)
      (CL:LET
       ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        (VALUE (EVALUATE-TERM ARG)) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ ITER-002 (%%REST ITER-002))
      (CL:SETQ ITER-003 (CL:1+ ITER-003))))
    PROPOSITION)))

;;; (DEFUN (MOST-GENERAL-EQUIVALENT-SLOTREF SURROGATE) ...)

(CL:DEFUN MOST-GENERAL-EQUIVALENT-SLOTREF (SURROGATE)
  (CL:LET* ((SLOT (%SURROGATE-VALUE SURROGATE)))
   (CL:WHEN (CL:EQ SLOT NULL)
    (CL:RETURN-FROM MOST-GENERAL-EQUIVALENT-SLOTREF NULL))
   (CL:WHEN (CL:NOT (CL:EQ (%SLOT-DIRECT-EQUIVALENT SLOT) NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ (%SLOT-DIRECT-EQUIVALENT SLOT) NULL))
     DO (CL:SETQ SLOT (%SLOT-DIRECT-EQUIVALENT SLOT)))
    (CL:WHEN (CL:EQ (%SLOT-SLOTREF SLOT) NULL)
     (LOOKUP-SLOTREF (%SLOT-OWNER SLOT) (%SLOT-NAME SLOT))))
   (%SLOT-SLOTREF SLOT)))

;;; (DEFUN (POLYMORPHIC-RELATION? BOOLEAN) ...)

(CL:DEFUN POLYMORPHIC-RELATION? (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND ((SUBTYPE-OF-STORAGE-SLOT? TEST-VALUE-000) (CL:PROGN CL:T))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-TABLE)
     (CL:PROGN CL:T))
    (CL:T CL:NIL))))

;;; (DEFUN (NON-POLYMORPHIC-PREDICATE? BOOLEAN) ...)

(CL:DEFUN NON-POLYMORPHIC-PREDICATE? (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:LET* ((RELATION (NATIVE-RELATION SELF)))
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ RELATION NULL))
         (POLYMORPHIC-RELATION? RELATION))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:NOT
       (TEST-ISA? SELF SGT-PROPOSITIONS-PL-KERNEL-KB-POLYMORPHIC))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (EVALUATE-PREDICATE LOGIC-OBJECT) ...)

(CL:DEFUN EVALUATE-PREDICATE (NAME FIRSTARGUMENT)
  (CL:LET* ((SURROGATE NULL) (PREDICATEVALUE NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NAME)))
    (CL:COND
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ SURROGATE (SYMBOL-TO-SURROGATE NAME))))
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ SURROGATE NAME)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:SETQ PREDICATEVALUE (GET-DESCRIPTION SURROGATE))
   (CL:IF (CL:NOT (CL:EQ PREDICATEVALUE NULL))
    (CL:RETURN-FROM EVALUATE-PREDICATE PREDICATEVALUE)
    (CL:PROGN (CL:SETQ PREDICATEVALUE (%SURROGATE-VALUE SURROGATE))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ PREDICATEVALUE NULL))
       (TEST-ISA? PREDICATEVALUE
        SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION)
       (NON-POLYMORPHIC-PREDICATE? PREDICATEVALUE))
      (CL:RETURN-FROM EVALUATE-PREDICATE PREDICATEVALUE))))
   (CL:WHEN (CL:NOT (CL:EQ FIRSTARGUMENT NULL))
    (CL:LET*
     ((FIRSTARGVALUE (VALUE-OF FIRSTARGUMENT))
      (SYMBOL (SURROGATE-TO-SYMBOL SURROGATE)))
     (CL:WHEN (CL:EQ FIRSTARGVALUE NULL)
      (SIGNAL-UNDEFINED-TERM FIRSTARGUMENT))
     (CL:SETQ SURROGATE
      (LOOKUP-SLOTREF-ON-INSTANCE FIRSTARGVALUE SYMBOL))
     (CL:WHEN (CL:NOT (CL:EQ SURROGATE NULL))
      (CL:RETURN-FROM EVALUATE-PREDICATE
       (GET-DESCRIPTION
        (MOST-GENERAL-EQUIVALENT-SLOTREF SURROGATE))))))
   NULL))

;;; (DEFGLOBAL *AUTO-COERCE-PROPOSITIONAL-ARGUMENTS?* ...)

(CL:DEFVAR *AUTO-COERCE-PROPOSITIONAL-ARGUMENTS?* CL:NIL
  "If TRUE, automatically coerce propositional arguments of a
proposition, even if the corresponding argument type of the hosting relation
doesn't indicate that.")

;;; (DEFUN (PROPOSITIONAL-ARGUMENT? BOOLEAN) ...)

(CL:DEFUN PROPOSITIONAL-ARGUMENT? (ARGUMENT)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE ARGUMENT) SGT-PROPOSITIONS-STELLA-CONS)
    (CL:PROGN
     (CL:LET*
      ((OPERATOR (%%VALUE ARGUMENT))
       (FIRSTARG (%%VALUE (%%REST ARGUMENT))))
      (CL:WHEN
       (CL:AND
        (CL:NOT (CL:EQ OPERATOR SYM-PROPOSITIONS-PL-KERNEL-KB-VALUE))
        (HOLDS-OPERATOR? OPERATOR))
       (CL:RETURN-FROM PROPOSITIONAL-ARGUMENT? CL:T))
      (CL:WHEN (SYMBOL? OPERATOR)
       (CL:LET* ((TEST-VALUE-000 OPERATOR))
        (CL:COND
         ((CL:OR (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-AND)
           (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-OR)
           (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-NOT)
           (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-EXISTS)
           (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-FORALL)
           (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-=))
          (CL:RETURN-FROM PROPOSITIONAL-ARGUMENT? CL:T))
         (CL:T
          (CL:LET*
           ((PREDICATE (EVALUATE-PREDICATE OPERATOR FIRSTARG))
            (ARITY 0))
           (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
           (CL:WHEN (CL:NOT (CL:EQ PREDICATE NULL))
            (CL:COND
             ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE PREDICATE)
               SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
              (CL:PROGN
               (CL:COND
                ((FUNCTION? PREDICATE)
                 (CL:SETQ ARITY (ARITY PREDICATE))
                 (CL:IF
                  (CL:OR (CL:= ARITY -1)
                   (CL:= ARITY (LENGTH ARGUMENT)))
                  (CL:RETURN-FROM PROPOSITIONAL-ARGUMENT? CL:NIL)
                  (CL:RETURN-FROM PROPOSITIONAL-ARGUMENT? CL:T)))
                (CL:T (CL:RETURN-FROM PROPOSITIONAL-ARGUMENT? CL:T)))))
             (CL:T)))))))))))
   (CL:T))
  CL:NIL)

;;; (DEFUN (EVALUATE-TYPED-ARGUMENT OBJECT) ...)

(CL:DEFUN EVALUATE-TYPED-ARGUMENT (ARGUMENT TYPE)
  (CL:COND
   ((CL:OR (CL:EQ TYPE SGT-PROPOSITIONS-LOGIC-PROPOSITION)
     (CL:AND *AUTO-COERCE-PROPOSITIONAL-ARGUMENTS?*
      (PROPOSITIONAL-ARGUMENT? ARGUMENT)))
    (BUILD-PROPOSITION ARGUMENT))
   ((CL:NOT (CL:EQ TYPE NULL))
    (CL:LET* ((*DEFAULTCREATIONTYPE* TYPE))
     (CL:DECLARE (CL:SPECIAL *DEFAULTCREATIONTYPE*))
     (EVALUATE-TERM ARGUMENT)))
   (CL:T (EVALUATE-TERM ARGUMENT))))

;;; (DEFUN (EVALUATE-FIRST-ARGUMENT OBJECT) ...)

(CL:DEFUN EVALUATE-FIRST-ARGUMENT (ARGUMENT RELATIONNAME)
  (CL:LET*
   ((PREDICATEVALUE (EVALUATE-PREDICATE RELATIONNAME NULL)) (TYPE NULL)
    (FIRSTARGUMENT NULL))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ PREDICATEVALUE NULL))
     (ISA? PREDICATEVALUE SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION))
    (CL:SETQ TYPE (FIRST (%IO-VARIABLE-TYPES PREDICATEVALUE))))
   (CL:SETQ FIRSTARGUMENT (EVALUATE-TYPED-ARGUMENT ARGUMENT TYPE))
   (CL:COND
    ((CL:OR (CL:EQ RELATIONNAME SYM-PROPOSITIONS-PL-KERNEL-KB-VALUE)
      (CL:EQ RELATIONNAME SYM-PROPOSITIONS-PL-KERNEL-KB-HOLDS))
     (CL:WHEN (CL:AND (DESCRIPTION-MODE?) (VARIABLE? FIRSTARGUMENT))
      (CL:LET* ((FNPROP (%DEFINING-PROPOSITION FIRSTARGUMENT)))
       (CL:LET* ((TEST-VALUE-000 CL:NIL))
        (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ FNPROP NULL)))
        (CL:WHEN TEST-VALUE-000
         (CL:LET* ((FOUND?-000 CL:NIL))
          (CL:LET*
           ((I NULL-INTEGER) (ITER-000 0)
            (UPPER-BOUND-000 (CL:- (LENGTH (%ARGUMENTS FNPROP)) 2)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
           (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
            (CL:SETQ I ITER-000)
            (CL:WHEN
             (VARIABLE?
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (%THE-ARRAY (%ARGUMENTS FNPROP)))
               I))
             (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
            (CL:SETQ ITER-000 (CL:1+ ITER-000))))
          (CL:SETQ TEST-VALUE-000 FOUND?-000))
         (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000)))
        (CL:WHEN TEST-VALUE-000
         (CL:LET*
          ((*EVALUATIONMODE* KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION))
          (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
          (CL:SETQ FIRSTARGUMENT
           (EVALUATE-TYPED-ARGUMENT ARGUMENT TYPE))))))))
    (CL:T))
   (CL:WHEN (CL:EQ FIRSTARGUMENT NULL)
    (SIGNAL-UNDEFINED-TERM ARGUMENT))
   (CL:LET* ((*SUPPRESSNONLOGICOBJECTWARNING?* CL:T))
    (CL:DECLARE (CL:SPECIAL *SUPPRESSNONLOGICOBJECTWARNING?*))
    (CL:WHEN (CL:EQ (VALUE-OF FIRSTARGUMENT) BOTTOM)
     (SIGNAL-UNDEFINED-TERM FIRSTARGUMENT)))
   FIRSTARGUMENT))

;;; (DEFUN (EVALUATE-REMAINING-ARGUMENTS CONS) ...)

(CL:DEFUN EVALUATE-REMAINING-ARGUMENTS (PREDICATEVALUE ARGUMENTS)
  (CL:LET* ((EVALUATEDARGUMENTS NIL))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ PREDICATEVALUE NULL))
     (ISA? PREDICATEVALUE SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION))
    (CL:LET* ((VARIABLETYPES (%IO-VARIABLE-TYPES PREDICATEVALUE)))
     (CL:LET* ((TYPE NULL) (ITER-000 (REST VARIABLETYPES)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ TYPE (%%VALUE ITER-000))
       (CL:LET* ((HEAD-000 (%%VALUE ARGUMENTS)))
        (CL:SETQ ARGUMENTS (%%REST ARGUMENTS))
        (CL:LET* ((ARG HEAD-000))
         (CL:WHEN (CL:NOT (CL:EQ ARG NULL))
          (CL:SETQ EVALUATEDARGUMENTS
           (CONS (EVALUATE-TYPED-ARGUMENT ARG TYPE)
            EVALUATEDARGUMENTS)))))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:LET* ((ARG NULL) (ITER-001 ARGUMENTS))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ ARG (%%VALUE ITER-001))
       (CL:SETQ EVALUATEDARGUMENTS
        (CONS (EVALUATE-TYPED-ARGUMENT ARG (LAST VARIABLETYPES))
         EVALUATEDARGUMENTS))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (REVERSE EVALUATEDARGUMENTS))
    (CL:PROGN
     (CL:LET* ((ARG NULL) (ITER-002 ARGUMENTS) (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ ARG (%%VALUE ITER-002))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS (EVALUATE-TERM ARG) NIL))
         (CL:IF (CL:EQ EVALUATEDARGUMENTS NIL)
          (CL:SETQ EVALUATEDARGUMENTS COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST EVALUATEDARGUMENTS
           COLLECT-000)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-000) (CONS (EVALUATE-TERM ARG) NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ ITER-002 (%%REST ITER-002))))
     EVALUATEDARGUMENTS))))

;;; (DEFUN (CLASS-OPERATOR? BOOLEAN) ...)

(CL:DEFUN CLASS-OPERATOR? (OPERATOR)
  (CL:LET* ((DESCRIPTION (GET-DESCRIPTION OPERATOR)))
   (CL:AND (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CLASS-DESCRIPTION? DESCRIPTION))))

;;; (DEFUN (BUILD-PREDICATE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-PREDICATE-PROPOSITION (TREE)
  (CL:WHEN
   (CL:AND (CL:= (LENGTH TREE) 2) (CLASS-OPERATOR? (%%VALUE TREE)))
   (CL:RETURN-FROM BUILD-PREDICATE-PROPOSITION
    (BUILD-ISA-PROPOSITION
     (LIST* SYM-PROPOSITIONS-STELLA-ISA (%%VALUE (%%REST TREE))
      (CONS (%%VALUE TREE) NIL)))))
  (CL:WHEN (HOLDS-OPERATOR? (%%VALUE TREE))
   (CL:RETURN-FROM BUILD-PREDICATE-PROPOSITION
    (BUILD-HOLDS-PROPOSITION TREE)))
  (CL:LET*
   ((PREDICATENAME (%%VALUE TREE))
    (PROPOSITION
     (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-PREDICATE
      (LENGTH (%%REST TREE))))
    (FIRSTARGUMENT NULL) (PREDICATEVALUE NULL))
   (CL:COND
    ((CL:EQ (%%REST TREE) NIL)
     (CL:IF (CL:EQ PREDICATENAME SYM-PROPOSITIONS-PL-KERNEL-KB-CUT)
      NULL
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Predicate `"
       PREDICATENAME "' applied to zero arguments." EOL)))
    (CL:T
     (CL:SETQ FIRSTARGUMENT
      (EVALUATE-FIRST-ARGUMENT (%%VALUE (%%REST TREE)) PREDICATENAME))
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       (VALUE FIRSTARGUMENT) (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:SETQ PREDICATEVALUE
    (EVALUATE-PREDICATE PREDICATENAME FIRSTARGUMENT))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ PREDICATEVALUE NULL))
     (FUNCTION? PREDICATEVALUE))
    (CL:IF (DESCRIPTION-MODE?)
     (CL:SETF (%KIND PROPOSITION) KWD-PROPOSITIONS-FUNCTION)
     (CL:LET*
      ((LASTARGINDEX (CL:1- (LENGTH TREE)))
       (RESULTARGUMENT (NTH TREE LASTARGINDEX)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM LASTARGINDEX))
      (NTH-SETTER TREE NULL LASTARGINDEX)
      (CL:SETQ TREE (REMOVE TREE NULL))
      (CL:RETURN-FROM BUILD-PREDICATE-PROPOSITION
       (BUILD-PROPOSITION
        (LIST* SYM-PROPOSITIONS-STELLA-= TREE
         (CONS RESULTARGUMENT NIL)))))))
   (CL:LET*
    ((ARG NULL)
     (ITER-000
      (EVALUATE-REMAINING-ARGUMENTS PREDICATEVALUE
       (%%REST (%%REST TREE))))
     (I NULL-INTEGER) (ITER-001 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ARG (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION))) (VALUE ARG)
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:SETF (%OPERATOR PROPOSITION)
    (CL:IF (CL:NOT (CL:EQ PREDICATEVALUE NULL))
     (%SURROGATE-VALUE-INVERSE PREDICATEVALUE) PREDICATENAME))
   (CL:WHEN
    (CL:EQ (%OPERATOR PROPOSITION) SGT-PROPOSITIONS-PL-KERNEL-KB-VALUE)
    (CL:SETQ PROPOSITION (NORMALIZE-VALUE-FUNCTION PROPOSITION)))
   (VERIFY-ARGUMENT-TYPES-AND-COUNT PROPOSITION) PROPOSITION))

;;; (DEFUN (CHECK-STRICT-TYPE? BOOLEAN) ...)

(CL:DEFUN CHECK-STRICT-TYPE? (SELF TYPE SHALLOW?)
  (CL:SETQ SHALLOW? SHALLOW?)
  (CL:WHEN
   (CL:OR (CL:EQ TYPE NULL) (CL:EQ SELF NULL)
    (CL:EQ TYPE SGT-PROPOSITIONS-STELLA-THING))
   (CL:RETURN-FROM CHECK-STRICT-TYPE? CL:T))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN (CL:RETURN-FROM CHECK-STRICT-TYPE? CL:T)))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER)
     (CL:PROGN
      (CL:WHEN
       (CL:AND
        (ISA? (%SURROGATE-VALUE TYPE) SGT-PROPOSITIONS-STELLA-CLASS)
        (SUBTYPE-OF? (LOGICAL-TYPE SELF) TYPE))
       (CL:RETURN-FROM CHECK-STRICT-TYPE? CL:T))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:WHEN
       (CL:AND
        (ISA? (%SURROGATE-VALUE TYPE) SGT-PROPOSITIONS-STELLA-CLASS)
        (SUBTYPE-OF? (LOGICAL-TYPE SELF) TYPE))
       (CL:RETURN-FROM CHECK-STRICT-TYPE? CL:T))))
    (CL:T)))
  (CL:OR (TEST-ISA? SELF TYPE)
   (LOGICAL-SUBTYPE-OF? (LOGICAL-TYPE SELF) TYPE)))

;;; (DEFUN (CHECK-TYPE? BOOLEAN) ...)

(CL:DEFUN CHECK-TYPE? (SELF TYPE SHALLOW?)
  (CL:OR
   (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
    (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
   (CHECK-STRICT-TYPE? SELF TYPE SHALLOW?)))

;;; (DEFUN (CHECK-COERCED-TYPE? BOOLEAN OBJECT) ...)

(CL:DEFUN CHECK-COERCED-TYPE? (SELF TYPE SHALLOW?)
  (CL:WHEN (CHECK-STRICT-TYPE? SELF TYPE SHALLOW?)
   (CL:RETURN-FROM CHECK-COERCED-TYPE? (CL:VALUES CL:T SELF)))
  (CL:LET* ((SUBSTITUTEDVALUE (COERCE-INCOMPATIBLE-VALUE SELF TYPE)))
   (CL:WHEN (CL:NOT (CL:EQ SUBSTITUTEDVALUE NULL))
    (CL:RETURN-FROM CHECK-COERCED-TYPE?
     (CL:VALUES CL:T SUBSTITUTEDVALUE))))
  (CL:IF
   (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
    (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
   (CL:VALUES CL:T SELF) (CL:VALUES CL:NIL SELF)))

;;; (DEFUN (COERCE-INCOMPATIBLE-VALUE OBJECT) ...)

(CL:DEFUN COERCE-INCOMPATIBLE-VALUE (VALUE TYPE)
  (CL:LET* ((SUBSTITUTE-VALUE NULL))
   (CL:COND
    ((RELATIONREF-SPECIALIZES-RELATIONREF? TYPE
      SGT-PROPOSITIONS-PL-KERNEL-KB-QUANTITY)
     (CL:RETURN-FROM COERCE-INCOMPATIBLE-VALUE
      (COERCE-QUANTITY VALUE TYPE)))
    ((RELATIONREF-SPECIALIZES-RELATIONREF? TYPE
      SGT-PROPOSITIONS-PL-KERNEL-KB-DATE)
     (CL:RETURN-FROM COERCE-INCOMPATIBLE-VALUE
      (COERCE-DATE VALUE TYPE)))
    ((CL:AND (ISA? VALUE SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER)
      (TEST-ISA? (REWRAP-ARGUMENT VALUE) TYPE))
     (CL:RETURN-FROM COERCE-INCOMPATIBLE-VALUE
      (REWRAP-ARGUMENT VALUE))))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VALUE)))
    (CL:COND
     ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
      (CL:PROGN
       (CL:WHEN (CL:EQ TYPE SGT-PROPOSITIONS-STELLA-FLOAT)
        (CL:LET*
         ((INTVALUE (%WRAPPER-VALUE VALUE))
          (FLOATVALUE (CL:FLOAT INTVALUE 0.0d0)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INTVALUE)
          (CL:TYPE CL:DOUBLE-FLOAT FLOATVALUE))
         (CL:SETQ SUBSTITUTE-VALUE (WRAP-FLOAT FLOATVALUE))))))
     ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
      (CL:PROGN
       (CL:WHEN (CL:EQ TYPE SGT-PROPOSITIONS-STELLA-INTEGER)
        (CL:LET*
         ((FLOATVALUE (%WRAPPER-VALUE VALUE))
          (INTVALUE (FLOOR FLOATVALUE)))
         (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT FLOATVALUE)
          (CL:TYPE CL:FIXNUM INTVALUE))
         (CL:WHEN (CL:= (CL:FLOAT INTVALUE 0.0d0) FLOATVALUE)
          (CL:SETQ SUBSTITUTE-VALUE (WRAP-INTEGER INTVALUE)))))))
     (CL:T)))
   SUBSTITUTE-VALUE))

;;; (DEFUN (COERCE-QUANTITY OBJECT) ...)

(CL:DEFUN COERCE-QUANTITY (VALUE QUANTITYTYPEREF)
  VALUE)

;;; (DEFUN (COERCE-DATE OBJECT) ...)

(CL:DEFUN COERCE-DATE (VALUE DATETYPEREF)
  VALUE)

;;; (DEFGLOBAL *TYPE-CHECK-POLICY* ...)

(CL:DEFVAR *TYPE-CHECK-POLICY* NULL
  "Three policies are implemented:
   :AUTOMATICALLY-FIX-TYPE-VIOLATIONS asserts missing types to fix type
       violations (default),
   :REPORT-TYPE-VIOLATIONS complains about missing or incorrect types,
   :SIGNAL-TYPE-VIOLATIONS throws exception for missing or incorrect types, and
   :IGNORE-TYPE-VIOLATIONS which disables all type checking.")

;;; (DEFSPECIAL *TYPECHECKMODE* ...)

(CL:DEFVAR *TYPECHECKMODE* NULL
  "Controls the behavior of the type-checking
routines in the event that a type-check fails.  Options are:
  :POST-TYPE-VIOLATIONS              push offending proposition onto queue,
  :REPORT-TYPE-VIOLATIONS            print occasions of failed type checks,
  :SIGNAL-TYPE-VIOLATIONS            throw exception for failed type checks,
  :AUTOMATICALLY-FIX-TYPE-VIOLATIONS assert missing types on propositions, and
  :IGNORE-TYPE-VIOLATIONS            don't perform any type checking at all.")

;;; (DEFUN VERIFY-ONE-ARGUMENT-TYPE ...)

(CL:DEFUN VERIFY-ONE-ARGUMENT-TYPE (ARG TYPE PROPOSITION DESCRIPTION)
  (CL:WHEN
   (CL:OR
    (CL:EQ *TYPECHECKMODE* KWD-PROPOSITIONS-IGNORE-TYPE-VIOLATIONS)
    (CL:EQ (%SURROGATE-VALUE TYPE) NULL))
   (CL:RETURN-FROM VERIFY-ONE-ARGUMENT-TYPE))
  (CL:LET*
   ((ARGVALUE (VALUE-OF ARG)) (TYPEISOK? CL:NIL)
    (SUBSTITUTEVALUE NULL))
   (CL:MULTIPLE-VALUE-SETQ (TYPEISOK? SUBSTITUTEVALUE)
    (CHECK-COERCED-TYPE? ARGVALUE TYPE CL:NIL))
   (CL:COND
    ((CL:NOT (EQL? ARGVALUE SUBSTITUTEVALUE))
     (CL:LET*
      ((ARGTOO NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (T NULL)
       (ITER-000 (%THE-CONS-LIST (%IO-VARIABLE-TYPES DESCRIPTION)))
       (I NULL-INTEGER) (ITER-001 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-001))
      (CL:LOOP WHILE
       (CL:AND (CL:< INDEX-000 LENGTH-000)
        (CL:NOT (CL:EQ ITER-000 NIL)))
       DO
       (CL:SETQ ARGTOO
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ T (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
       (CL:WHEN (CL:AND (EQL? ARGTOO ARG) (CL:EQ T TYPE))
        (CL:LET
         ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          (VALUE SUBSTITUTEVALUE) (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE)))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
       (CL:SETQ ITER-000 (%%REST ITER-000))
       (CL:SETQ ITER-001 (CL:1+ ITER-001)))))
    ((CL:NOT TYPEISOK?)
     (HANDLE-ARGUMENT-TYPE-VIOLATION PROPOSITION ARG TYPE)))))

;;; (DEFUN VERIFY-ARGUMENT-TYPES-AND-COUNT ...)

(CL:DEFUN VERIFY-ARGUMENT-TYPES-AND-COUNT (PROPOSITION)
  (CL:WHEN
   (CL:OR
    (CL:EQ *TYPECHECKMODE* KWD-PROPOSITIONS-IGNORE-TYPE-VIOLATIONS)
    (CL:NOT (WORLD-STATE? *CONTEXT*))
    (CL:NOT
     (ISA? (%OPERATOR PROPOSITION) SGT-PROPOSITIONS-STELLA-SURROGATE)))
   (CL:RETURN-FROM VERIFY-ARGUMENT-TYPES-AND-COUNT))
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION (%OPERATOR PROPOSITION)))
    (ARGUMENTCOUNT (LENGTH (%ARGUMENTS PROPOSITION))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARGUMENTCOUNT))
   (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FUNCTION)
       (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-ISA))
      (CL:WHEN (CL:EQ DESCRIPTION NULL)
       (CL:RETURN-FROM VERIFY-ARGUMENT-TYPES-AND-COUNT))
      (CL:LET*
       ((ARITY (ARITY DESCRIPTION))
        (VARIABLEARITY? (CL:NOT (CL:> ARITY 0)))
        (FUNCTION?
         (CL:EQ (%KIND PROPOSITION) KWD-PROPOSITIONS-FUNCTION)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
       (CL:WHEN
        (CL:AND (CL:NOT VARIABLEARITY?)
         (CL:NOT (CL:= ARGUMENTCOUNT ARITY)))
        (HANDLE-ARITY-VIOLATION PROPOSITION ARITY))
       (CL:LET*
        ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000))
         (I
          (INTERVAL 1
           (CL:IF (CL:AND VARIABLEARITY? FUNCTION?)
            (CL:1- ARGUMENTCOUNT) ARGUMENTCOUNT)))
         (TYPE NULL) (ITER-000 (ALL-DOMAIN-TYPES DESCRIPTION)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE
         (CL:AND (CL:< INDEX-000 LENGTH-000) (NEXT? I)
          (NEXT? ITER-000))
         DO
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ TYPE (%VALUE ITER-000))
         (CL:WHEN
          (CL:AND (CL:NOT (CL:EQ TYPE NULL))
           (CL:NOT (CL:EQ TYPE SGT-PROPOSITIONS-STELLA-THING))
           (CL:NOT (CL:EQ ARG NULL)))
          (VERIFY-ONE-ARGUMENT-TYPE ARG TYPE PROPOSITION DESCRIPTION))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
       (CL:WHEN FUNCTION?
        (VERIFY-ONE-ARGUMENT-TYPE (LAST (%ARGUMENTS PROPOSITION))
         (LAST (%IO-VARIABLE-TYPES DESCRIPTION)) PROPOSITION
         DESCRIPTION))))
     ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-EQUIVALENT)
      (CL:LET*
       ((ARG1
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          0))
        (ARG2
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          1))
        (REQUIREDTYPE NULL) (CONSTRAININGARG NULL) (OFFENDINGARG NULL)
        (TYPEISOK? CL:NIL) (SUBSTITUTEVALUE NULL))
       (CL:SETQ REQUIREDTYPE (SAFE-LOGICAL-TYPE ARG2))
       (CL:MULTIPLE-VALUE-SETQ (TYPEISOK? SUBSTITUTEVALUE)
        (CHECK-COERCED-TYPE? ARG1 REQUIREDTYPE CL:NIL))
       (CL:COND
        ((CL:NOT (EQL? ARG1 SUBSTITUTEVALUE))
         (CL:LET
          ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
           (VALUE SUBSTITUTEVALUE) (POSITION 0))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:RETURN-FROM VERIFY-ARGUMENT-TYPES-AND-COUNT))
        ((CL:NOT TYPEISOK?) (CL:SETQ CONSTRAININGARG ARG2)
         (CL:SETQ OFFENDINGARG ARG1)))
       (CL:WHEN TYPEISOK?
        (CL:SETQ REQUIREDTYPE (SAFE-LOGICAL-TYPE ARG1))
        (CL:MULTIPLE-VALUE-SETQ (TYPEISOK? SUBSTITUTEVALUE)
         (CHECK-COERCED-TYPE? ARG2 REQUIREDTYPE CL:NIL))
        (CL:COND
         ((CL:NOT (EQL? ARG2 SUBSTITUTEVALUE))
          (CL:LET
           ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
            (VALUE SUBSTITUTEVALUE) (POSITION 1))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SETF (CL:AREF SELF POSITION) VALUE))
          (CL:RETURN-FROM VERIFY-ARGUMENT-TYPES-AND-COUNT))
         ((CL:NOT TYPEISOK?) (CL:SETQ CONSTRAININGARG ARG1)
          (CL:SETQ OFFENDINGARG ARG2))))
       (CL:WHEN (CL:NOT TYPEISOK?)
        (CL:LET* ((*TERMUNDERCONSTRUCTION* *TERMUNDERCONSTRUCTION*))
         (CL:DECLARE (CL:SPECIAL *TERMUNDERCONSTRUCTION*))
         (CL:WHEN
          (CL:AND (CL:EQ *TERMUNDERCONSTRUCTION* NULL)
           (SKOLEM? CONSTRAININGARG))
          (CL:SETQ *TERMUNDERCONSTRUCTION*
           (%DEFINING-PROPOSITION CONSTRAININGARG)))
         (HANDLE-ARGUMENT-TYPE-VIOLATION PROPOSITION OFFENDINGARG
          REQUIREDTYPE)))))
     (CL:T)))))

;;; (DEFUN HANDLE-ARGUMENT-TYPE-VIOLATION ...)

(CL:DEFUN HANDLE-ARGUMENT-TYPE-VIOLATION (PROPOSITION ARG REQUIREDTYPE)
  (CL:COND
   ((CL:EQ *TYPECHECKMODE* KWD-PROPOSITIONS-POST-TYPE-VIOLATIONS)
    (POST-TO-CHECK-TYPES-AGENDA PROPOSITION))
   ((CL:EQ *TYPECHECKMODE* KWD-PROPOSITIONS-REPORT-TYPE-VIOLATIONS)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING)
      "WARNING: Type check violation on argument `" ARG
      "' in proposition" EOL "   " PROPOSITION "." EOL
      "   Argument must have type `" (%SYMBOL-NAME REQUIREDTYPE) "'."
      EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
      KWD-PROPOSITIONS-WARNING)))
   ((CL:EQ *TYPECHECKMODE* KWD-PROPOSITIONS-SIGNAL-TYPE-VIOLATIONS)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "ERROR: Type check violation on argument ``" ARG
       "'' in proposition" EOL "   `" PROPOSITION "'." EOL
       "   Argument must have type ``" (%SYMBOL-NAME REQUIREDTYPE)
       "''.." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
       KWD-PROPOSITIONS-ERROR))
     (CL:ERROR
      (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   ((CL:EQ *TYPECHECKMODE*
     KWD-PROPOSITIONS-AUTOMATICALLY-FIX-TYPE-VIOLATIONS)
    (CL:LET*
     ((ISAPROPOSITION (ASSERT-ISA-PROPOSITION ARG REQUIREDTYPE)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ISAPROPOSITION)
      SYM-PROPOSITIONS-LOGIC-ASSERTED-BY-TYPE-CHECKER?
      (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)))
   (CL:T
    (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" *TYPECHECKMODE*
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))

;;; (DEFUN HANDLE-ARITY-VIOLATION ...)

(CL:DEFUN HANDLE-ARITY-VIOLATION (PROPOSITION REQUIREDARITY)
  (CL:DECLARE (CL:TYPE CL:FIXNUM REQUIREDARITY))
  #+MCL
  (CL:CHECK-TYPE REQUIREDARITY CL:FIXNUM)
  (CL:COND
   ((CL:EQ *TYPECHECKMODE* KWD-PROPOSITIONS-POST-TYPE-VIOLATIONS)
    (POST-TO-CHECK-TYPES-AGENDA PROPOSITION))
   ((CL:OR
     (CL:EQ *TYPECHECKMODE* KWD-PROPOSITIONS-SIGNAL-TYPE-VIOLATIONS)
     (CL:EQ *TYPECHECKMODE* KWD-PROPOSITIONS-REPORT-TYPE-VIOLATIONS)
     (CL:EQ *TYPECHECKMODE*
      KWD-PROPOSITIONS-AUTOMATICALLY-FIX-TYPE-VIOLATIONS))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "ERROR: Too `"
       (CL:IF (CL:> (LENGTH (%ARGUMENTS PROPOSITION)) REQUIREDARITY)
        "many" "few")
       "' arguments in the proposition" EOL "   `"
       (GENERATE-TERM PROPOSITION) "'" EOL "   Expected `"
       REQUIREDARITY "' argument(s).." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
       KWD-PROPOSITIONS-ERROR))
     (CL:ERROR
      (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   (CL:T
    (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" *TYPECHECKMODE*
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))

;;; (DEFCLASS CHECK-TYPES-RECORD ...)

(CL:DEFCLASS CHECK-TYPES-RECORD (STANDARD-OBJECT)
  ((PARENT-PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR
    %PARENT-PROPOSITION)
   (PARENT-DESCRIPTION :ALLOCATION :INSTANCE :ACCESSOR
    %PARENT-DESCRIPTION)
   (MODULE :ALLOCATION :INSTANCE :ACCESSOR %MODULE)))

(CL:DEFUN NEW-CHECK-TYPES-RECORD ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CHECK-TYPES-RECORD)))
   (CL:SETF (%MODULE SELF) NULL)
   (CL:SETF (%PARENT-DESCRIPTION SELF) NULL)
   (CL:SETF (%PARENT-PROPOSITION SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CHECK-TYPES-RECORD))
  SGT-PROPOSITIONS-LOGIC-CHECK-TYPES-RECORD)

(CL:DEFUN ACCESS-CHECK-TYPES-RECORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-PARENT-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%PARENT-PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%PARENT-PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-PARENT-DESCRIPTION)
    (CL:IF SETVALUE? (CL:SETF (%PARENT-DESCRIPTION SELF) VALUE)
     (CL:SETQ VALUE (%PARENT-DESCRIPTION SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-MODULE)
    (CL:IF SETVALUE? (CL:SETF (%MODULE SELF) VALUE)
     (CL:SETQ VALUE (%MODULE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFGLOBAL *CHECK-TYPES-AGENDA* ...)

(CL:DEFVAR *CHECK-TYPES-AGENDA* NULL
  "List of propositions that have failed a type check,
but might pass once finalization is complete.")

;;; (DEFUN POST-TO-CHECK-TYPES-AGENDA ...)

(CL:DEFUN POST-TO-CHECK-TYPES-AGENDA (SELF)
  (CL:LET* ((SELF-000 (NEW-CHECK-TYPES-RECORD)))
   (CL:SETF (%PARENT-PROPOSITION SELF-000) *TERMUNDERCONSTRUCTION*)
   (CL:SETF (%PARENT-DESCRIPTION SELF-000)
    *DESCRIPTIONUNDERCONSTRUCTION*)
   (CL:SETF (%MODULE SELF-000) *MODULE*)
   (INSERT-AT *CHECK-TYPES-AGENDA* SELF SELF-000)))

;;; (DEFUN PROCESS-CHECK-TYPES-AGENDA ...)

(CL:DEFUN PROCESS-CHECK-TYPES-AGENDA ()
  (CL:WHEN
   (CL:OR (EMPTY? *CHECK-TYPES-AGENDA*) *INHIBITOBJECTFINALIZATION?*)
   (CL:RETURN-FROM PROCESS-CHECK-TYPES-AGENDA))
  (PL-LOG KWD-PROPOSITIONS-MEDIUM
   (WRAP-STRING "Processing check-types agenda..."))
  (CL:LET* ((AGENDA (REVERSE *CHECK-TYPES-AGENDA*)))
   (CL:SETQ *CHECK-TYPES-AGENDA* (NEW-KEY-VALUE-LIST))
   (CL:LET*
    ((PROPOSITION NULL) (RECORD NULL) (ITER-000 (%THE-KV-LIST AGENDA)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
     (CL:SETQ PROPOSITION (%KEY ITER-000))
     (CL:SETQ RECORD (%VALUE ITER-000))
     (CL:TAGBODY
      (CL:WHEN (CL:NOT (DELETED? PROPOSITION))
       (CL:LET*
        ((*TYPECHECKMODE*
          (CL:IF
           (CL:AND
            (%WRAPPER-VALUE
             (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
              SYM-PROPOSITIONS-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
            (CL:NOT
             (CL:EQ *TYPE-CHECK-POLICY*
              KWD-PROPOSITIONS-IGNORE-TYPE-VIOLATIONS)))
           KWD-PROPOSITIONS-REPORT-TYPE-VIOLATIONS
           *TYPE-CHECK-POLICY*))
         (*TERMUNDERCONSTRUCTION* (%PARENT-PROPOSITION RECORD))
         (*DESCRIPTIONUNDERCONSTRUCTION* (%PARENT-DESCRIPTION RECORD)))
        (CL:DECLARE
         (CL:SPECIAL *TYPECHECKMODE* *TERMUNDERCONSTRUCTION*
          *DESCRIPTIONUNDERCONSTRUCTION*))
        (CL:WHEN
         (CL:OR (DELETED? PROPOSITION)
          (CL:AND (CL:NOT (CL:EQ *TERMUNDERCONSTRUCTION* NULL))
           (DELETED? *TERMUNDERCONSTRUCTION*))
          (CL:AND (CL:NOT (CL:EQ *DESCRIPTIONUNDERCONSTRUCTION* NULL))
           (DELETED? *DESCRIPTIONUNDERCONSTRUCTION*)))
         (CL:GO :CONTINUE))
        (CL:HANDLER-CASE
         (CL:LET* ((*MODULE* (%MODULE RECORD)) (*CONTEXT* *MODULE*))
          (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
          (VERIFY-ARGUMENT-TYPES-AND-COUNT PROPOSITION))
         (LOGIC-EXCEPTION (E)
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
           (EXCEPTION-MESSAGE E))))))
      :CONTINUE)
     (CL:SETQ ITER-000 (%REST ITER-000))))))

;;; (DEFUN PROCESS-DEFINITIONS ...)

(CL:DEFUN PROCESS-DEFINITIONS ()
  "Finish processing all definitions and assertions that have
been evaluated/loaded since that last call to 'process-definitions'.
PowerLoom defers complete processing of definitions to make it easier
to support cyclic definitions.  Following finalization of definitions,
this call performs semantic validation of any assertions evaluated since
the last call to 'process-definitions'.  PowerLoom calls this function
internally before each query; the primary reason to call it explicitly
is to force the production of any diagnostic information that results from
the processing and validation."
  (FINALIZE-OBJECTS)
  (PROCESS-CHECK-TYPES-AGENDA))

;;; (DEFUN (BUILD-EXISTS-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-EXISTS-PROPOSITION (TREE)
  (CL:LET* ((VARIABLES NULL) (PROPOSITION NULL) (UNUSED NULL))
   (CL:MULTIPLE-VALUE-SETQ (VARIABLES PROPOSITION UNUSED)
    (BUILD-QUANTIFIED-PROPOSITION TREE CL:T))
   (CL:SETQ UNUSED UNUSED)
   (CL:LET*
    ((EXISTSPROP
      (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-EXISTS 1)))
    (CL:SETF (%KIND EXISTSPROP) KWD-PROPOSITIONS-EXISTS)
    (CL:LET
     ((SELF (%THE-ARRAY (%ARGUMENTS EXISTSPROP))) (VALUE PROPOSITION)
      (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS EXISTSPROP)
     SYM-PROPOSITIONS-LOGIC-IO-VARIABLES
     (COPY-CONS-LIST-TO-VARIABLES-VECTOR VARIABLES) NULL)
    EXISTSPROP)))

;;; (DEFUN (TOP-LEVEL-EXISTS-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN TOP-LEVEL-EXISTS-PROPOSITION? (PROPOSITION)
  (CL:AND (CL:NOT (UNKNOWN? PROPOSITION))
   (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? PROPOSITION NULL)))

;;; (DEFUN (COLLECT-SKOLEMIZED-EXISTS-VARIABLES (VECTOR OF SKOLEM)) ...)

(CL:DEFUN COLLECT-SKOLEMIZED-EXISTS-VARIABLES (PROPOSITION)
  (CL:LET* ((SKOLEMS (NEW-LIST)) (RESULT NULL))
   (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? PROPOSITION SKOLEMS)
   (CL:IF (EMPTY? SKOLEMS) (CL:SETQ RESULT ZERO-VARIABLES-VECTOR)
    (CL:SETQ RESULT (NEW-VECTOR (LENGTH SKOLEMS))))
   (CL:LET*
    ((SKOLEM NULL) (ITER-000 (%THE-CONS-LIST SKOLEMS)) (I NULL-INTEGER)
     (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SKOLEM (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:LET ((SELF (%THE-ARRAY RESULT)) (VALUE SKOLEM) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (FREE SKOLEMS) RESULT))

;;; (DEFUN (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? BOOLEAN) ...)

(CL:DEFUN HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? (PROPOSITION RESULT)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS PROPOSITION))
    (ARGUMENTCOUNT (LENGTH ARGUMENTS)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARGUMENTCOUNT))
   (CL:WHEN (CL:EQ (%KIND PROPOSITION) KWD-PROPOSITIONS-FUNCTION)
    (CL:SETQ ARGUMENTCOUNT (CL:1- ARGUMENTCOUNT)))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 1)
     (UPPER-BOUND-000 ARGUMENTCOUNT)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000
      UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000)
      (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)))
     DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000) (CL:SETQ I I)
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
        (CL:PROGN
         (CL:WHEN
          (CL:AND
           (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? ARG RESULT)
           (CL:EQ RESULT NULL))
          (CL:RETURN-FROM HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES?
           CL:T))))
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
        (CL:PROGN))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
        (CL:PROGN
         (CL:LET* ((FOUND?-000 CL:NIL))
          (CL:LET*
           ((PROP NULL)
            (ITER-001
             (ALLOCATE-ITERATOR
              (UNFILTERED-DEPENDENT-ISA-PROPOSITIONS ARG))))
           (CL:LOOP WHILE (NEXT? ITER-001) DO
            (CL:SETQ PROP (%VALUE ITER-001))
            (CL:WHEN
             (CL:AND (CL:EQ (%KIND PROP) KWD-PROPOSITIONS-ISA)
              (TRUE? PROP)
              (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
               (VARIABLE-TYPE? PROP)))
             (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))))
          (CL:WHEN FOUND?-000
           (CL:IF (CL:NOT (CL:EQ RESULT NULL)) (INSERT-NEW RESULT ARG)
            (CL:RETURN-FROM HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES?
             CL:T))))))
       (CL:T)))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:IF (CL:NOT (CL:EQ RESULT NULL)) (NON-EMPTY? RESULT) CL:NIL)))

;;; (DEFUN (BUILD-FORALL-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-FORALL-PROPOSITION (TREE)
  (CL:LET*
   ((FORALLPROP (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-FORALL 2)))
   (CL:LET* ((VARIABLES NULL) (ANTECEDENT NULL) (CONSEQUENT NULL))
    (CL:MULTIPLE-VALUE-SETQ (VARIABLES ANTECEDENT CONSEQUENT)
     (BUILD-QUANTIFIED-PROPOSITION TREE CL:T))
    (CL:SETF (%KIND FORALLPROP) KWD-PROPOSITIONS-FORALL)
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FORALLPROP)
     SYM-PROPOSITIONS-LOGIC-IO-VARIABLES
     (COPY-CONS-LIST-TO-VARIABLES-VECTOR VARIABLES) NULL)
    (CL:LET
     ((SELF (%THE-ARRAY (%ARGUMENTS FORALLPROP)))
      (VALUE
       (CL:IF (CL:NOT (CL:EQ ANTECEDENT NULL)) ANTECEDENT
        TRUE-PROPOSITION))
      (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET
     ((SELF (%THE-ARRAY (%ARGUMENTS FORALLPROP))) (VALUE CONSEQUENT)
      (POSITION 1))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE)))
   FORALLPROP))

;;; (DEFUN VERIFY-FORALL-PROPOSITIONS ...)

(CL:DEFUN VERIFY-FORALL-PROPOSITIONS (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FORALL)
     (CL:LET*
      ((ANTECEDENT
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         0))
       (CONSEQUENT
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         1))
       (ANTVARS NULL) (CQVARS NULL))
      (CL:WHEN (CL:EQ (%KIND ANTECEDENT) KWD-PROPOSITIONS-CONSTANT)
       (CL:RETURN-FROM VERIFY-FORALL-PROPOSITIONS))
      (CL:SETQ ANTVARS (LIST)) (CL:SETQ CQVARS (LIST))
      (COLLECT-FREE-VARIABLES ANTECEDENT ANTVARS (LIST) (LIST))
      (COLLECT-FREE-VARIABLES CONSEQUENT CQVARS (LIST) (LIST))
      (CL:WHEN
       (CL:NOT (CL:AND (NON-EMPTY? CQVARS) (SUBSET? CQVARS ANTVARS)))
       (CL:LET*
        ((*TERMSOURCEBEINGPARSED* STELLA::NULL-STRING)
         (*TERMUNDERCONSTRUCTION* NULL) (*PRINTREADABLY?* CL:T)
         (*PRINTMODE* KWD-PROPOSITIONS-REALISTIC)
         (*PRETTYPRINTLOGICALFORMS?* CL:T) (*PRETTYPRINTKIF?* CL:T))
        (CL:DECLARE
         (CL:SPECIAL *TERMSOURCEBEINGPARSED* *TERMUNDERCONSTRUCTION*
          *PRINTREADABLY?* *PRINTMODE* *PRETTYPRINTLOGICALFORMS?*
          *PRETTYPRINTKIF?*))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING *TERMSOURCEBEINGPARSED*))
        (CL:SETQ CQVARS (DIFFERENCE CQVARS ANTVARS))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING)
          "WARNING: Potentially problematic implication rule, consequent variable(s) "
          (REPLACE-SUBSTRINGS (STRINGIFY (%THE-CONS-LIST CQVARS)) "?"
           "|V|?")
          EOL "   are not restricted/used by the antecedent: " EOL
          PROPOSITION EOL)
         (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
          KWD-PROPOSITIONS-WARNING))))))
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-AND)
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (VERIFY-FORALL-PROPOSITIONS ARG)
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
    (CL:T))))

;;; (DEFUN (MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT OBJECT) ...)

(CL:DEFUN MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT (ARG1 ARG2)
  (CL:WHEN (CL:OR (SKOLEM? ARG2) (DESCRIPTION-MODE?))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARG1)
      SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:WHEN (CL:NOT (CL:EQ (DESCRIPTION-SURROGATE ARG1) NULL))
       (CL:RETURN-FROM MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT
        (DESCRIPTION-SURROGATE ARG1)))))
    (CL:T)))
  ARG1)

;;; (DEFUN (CREATE-IMPLIES-PROPOSITION PROPOSITION) ...)

(CL:DEFUN CREATE-IMPLIES-PROPOSITION (TAIL HEAD)
  (CL:LET*
   ((IMPLIESPROP
     (CREATE-PROPOSITION SYM-PROPOSITIONS-LOGIC-IMPLIES 2)))
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS IMPLIESPROP)))
     (VALUE (MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT TAIL HEAD))
     (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS IMPLIESPROP)))
     (VALUE (MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT HEAD TAIL))
     (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (VERIFY-ARGUMENT-TYPES-AND-COUNT IMPLIESPROP) IMPLIESPROP))

;;; (DEFUN (BUILD-IMPLIES-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-IMPLIES-PROPOSITION (TREE)
  (VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS TREE 2)
  (CL:LET*
   ((TAILARG (EVALUATE-TERM (%%VALUE (%%REST TREE))))
    (HEADARG (EVALUATE-TERM (%%VALUE (%%REST (%%REST TREE))))))
   (CREATE-IMPLIES-PROPOSITION TAILARG HEADARG)))

;;; (DEFUN (FIND-DUPLICATE-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FIND-DUPLICATE-FUNCTION-PROPOSITION (PROPOSITION)
  (CL:IF
   (CL:OR *LOADINGREGENERABLEOBJECTS?*
    (CL:NOT
     (ISA? (%OPERATOR PROPOSITION) SGT-PROPOSITIONS-STELLA-SURROGATE)))
   NULL (FIND-DUPLICATE-PROPOSITION PROPOSITION)))

;;; (DEFUN (UNWRAP-WRAPPED-TYPE TYPE) ...)

(CL:DEFUN UNWRAP-WRAPPED-TYPE (TYPE)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ TYPE NULL))
    (CL:NOT (CL:EQ (%SURROGATE-VALUE TYPE) NULL))
    (ISA? (%SURROGATE-VALUE TYPE) SGT-PROPOSITIONS-STELLA-CLASS)
    (SUBTYPE-OF? TYPE SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER))
   (CL:SETQ TYPE (WRAPPED-TYPE-TO-TYPE TYPE)))
  TYPE)

;;; (DEFUN (BEGIN-CREATING-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BEGIN-CREATING-FUNCTION-PROPOSITION (SURROGATE INPUTARGUMENTS)
  (CL:LET*
   ((ARGCOUNT (CL:1+ (LENGTH INPUTARGUMENTS)))
    (PROPOSITION
     (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-FUNCTION ARGCOUNT)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARGCOUNT))
   (CL:SETF (%OPERATOR PROPOSITION) SURROGATE)
   (CL:LET*
    ((ARG NULL) (ITER-000 INPUTARGUMENTS) (I NULL-INTEGER)
     (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ARG (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION))) (VALUE ARG)
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   PROPOSITION))

;;; (DEFUN (FINISH-CREATING-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FINISH-CREATING-FUNCTION-PROPOSITION (PROPOSITION)
  (CL:LET*
   ((ARGCOUNT (LENGTH (%ARGUMENTS PROPOSITION)))
    (DESCRIPTION (GET-DESCRIPTION (%OPERATOR PROPOSITION))) (TYPE NULL)
    (SKOLEM NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARGCOUNT))
   (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:SETQ TYPE
     (UNWRAP-WRAPPED-TYPE (LAST (%IO-VARIABLE-TYPES DESCRIPTION)))))
   (CL:LET*
    ((*CONTEXT* (%HOME-CONTEXT PROPOSITION))
     (*MODULE* (%BASE-MODULE *CONTEXT*)))
    (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
    (CL:SETQ SKOLEM (CREATE-VARIABLE-OR-SKOLEM TYPE NULL)))
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION))) (VALUE SKOLEM)
     (POSITION (CL:1- ARGCOUNT)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%DEFINING-PROPOSITION SKOLEM) PROPOSITION)
   (CL:WHEN (CL:NOT (CL:EQ TYPE NULL))
    (UPDATE-SKOLEM-TYPE SKOLEM TYPE))
   (CL:WHEN
    (CL:EQ (%OPERATOR PROPOSITION) SGT-PROPOSITIONS-PL-KERNEL-KB-VALUE)
    (CL:SETQ PROPOSITION (NORMALIZE-VALUE-FUNCTION PROPOSITION)))
   (VERIFY-ARGUMENT-TYPES-AND-COUNT PROPOSITION)
   (CL:WHEN
    (ISA? (%OPERATOR PROPOSITION) SGT-PROPOSITIONS-STELLA-SURROGATE)
    (FASTEN-DOWN-ONE-PROPOSITION PROPOSITION CL:T))
   PROPOSITION))

;;; (DEFUN (FIND-OR-CREATE-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FIND-OR-CREATE-FUNCTION-PROPOSITION (PREDICATE INPUTARGUMENTS)
  (CL:LET*
   ((PROPOSITION
     (BEGIN-CREATING-FUNCTION-PROPOSITION PREDICATE INPUTARGUMENTS))
    (DUPLICATE
     (CL:IF (CL:NOT (DESCRIPTION-MODE?))
      (FIND-DUPLICATE-FUNCTION-PROPOSITION PROPOSITION) NULL)))
   (CL:WHEN (CL:NOT (CL:EQ DUPLICATE NULL))
    (CL:RETURN-FROM FIND-OR-CREATE-FUNCTION-PROPOSITION DUPLICATE))
   (CL:SETQ PROPOSITION
    (FINISH-CREATING-FUNCTION-PROPOSITION PROPOSITION))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:IF
     (CL:NOT
      (%WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
        SYM-PROPOSITIONS-LOGIC-DESCRIPTIVE? FALSE-WRAPPER)))
     (CL:SETQ TEST-VALUE-000 CL:T)
     (CL:LET* ((ALWAYS?-000 CL:T))
      (CL:LET*
       ((I NULL-INTEGER) (ITER-000 0)
        (UPPER-BOUND-000 (CL:- (LENGTH (%ARGUMENTS PROPOSITION)) 2)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
       (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
        (CL:SETQ I ITER-000)
        (CL:WHEN
         (VARIABLE?
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
           I))
         (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
        (CL:SETQ ITER-000 (CL:1+ ITER-000))))
      (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
    (CL:WHEN TEST-VALUE-000 (RUN-GOES-TRUE-DEMONS PROPOSITION)))
   PROPOSITION))

;;; (DEFUN (CREATE-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN CREATE-FUNCTION-PROPOSITION (PREDICATE INPUTARGUMENTS)
  (CL:LET*
   ((PROPOSITION
     (BEGIN-CREATING-FUNCTION-PROPOSITION PREDICATE INPUTARGUMENTS)))
   (FINISH-CREATING-FUNCTION-PROPOSITION PROPOSITION)))

;;; (DEFUN (EVALUATE-FUNCTION-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-FUNCTION-TERM (TREE)
  (CL:WHEN
   (CL:NOT
    (ISA? (%%VALUE TREE) SGT-PROPOSITIONS-STELLA-GENERALIZED-SYMBOL))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "ERROR: Illegal function name in function term: `" TREE "'." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:LET*
   ((NAME (%%VALUE TREE))
    (FIRSTARGUMENT
     (EVALUATE-FIRST-ARGUMENT (%%VALUE (%%REST TREE)) NAME))
    (PREDICATEVALUE (EVALUATE-PREDICATE NAME FIRSTARGUMENT))
    (INPUTARGUMENTS
     (EVALUATE-REMAINING-ARGUMENTS PREDICATEVALUE
      (%%REST (%%REST TREE)))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ PREDICATEVALUE NULL))
     (ISA? PREDICATEVALUE SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
     (CL:NOT (FUNCTION-DESCRIPTION? PREDICATEVALUE)))
    (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "ERROR: Relation `"
       (DESCRIPTION-NAME PREDICATEVALUE)
       "' found in function position.." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001
       KWD-PROPOSITIONS-ERROR))
     (CL:ERROR
      (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001)))))
   (CL:SETQ INPUTARGUMENTS (CONS FIRSTARGUMENT INPUTARGUMENTS))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ PREDICATEVALUE NULL))
     (CL:EQ (OBJECT-SURROGATE PREDICATEVALUE)
      SGT-PROPOSITIONS-PL-KERNEL-KB-SETOF))
    (CL:SETQ INPUTARGUMENTS
     (SORT INPUTARGUMENTS (CL:FUNCTION LOGIC-FORM-LESS?))))
   (CL:LET*
    ((FUNCTIONPROPOSITION
      (FIND-OR-CREATE-FUNCTION-PROPOSITION
       (CL:IF (CL:NOT (CL:EQ PREDICATEVALUE NULL))
        (%SURROGATE-VALUE-INVERSE PREDICATEVALUE) NAME)
       INPUTARGUMENTS)))
    (CL:WHEN
     (CL:AND (SYMBOL? (%OPERATOR FUNCTIONPROPOSITION))
      (CL:NOT (DESCRIPTION-MODE?)))
     (COMPLAIN-ABOUT-UNDECLARED-REFERENCE FUNCTIONPROPOSITION)
     (CREATE-DUMMY-RELATION FUNCTIONPROPOSITION))
    (CL:AREF
     (CL:THE CL:SIMPLE-VECTOR
      (%THE-ARRAY (%ARGUMENTS FUNCTIONPROPOSITION)))
     (CL:THE CL:FIXNUM
      (CL:1- (LENGTH (%ARGUMENTS FUNCTIONPROPOSITION))))))))

;;; (DEFUN (EXTENSIONAL-INDIVIDUAL? BOOLEAN) ...)

(CL:DEFUN EXTENSIONAL-INDIVIDUAL? (INDIVIDUAL)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE INDIVIDUAL)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN CL:NIL))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET*
       ((DEFININGPROPOSITION (%DEFINING-PROPOSITION INDIVIDUAL)))
       (CL:LET* ((FOUND?-000 CL:NIL))
        (CL:LET*
         ((PROP NULL)
          (ITER-000
           (ALLOCATE-ITERATOR
            (UNFILTERED-DEPENDENT-PROPOSITIONS INDIVIDUAL NULL))))
         (CL:LOOP WHILE (NEXT? ITER-000) DO
          (CL:SETQ PROP (%VALUE ITER-000))
          (CL:WHEN
           (CL:AND (CL:NOT (CL:EQ PROP DEFININGPROPOSITION))
            (CL:AND (CL:NOT (DELETED? PROP))
             (CL:IF *REVERSEPOLARITY?* (FALSE? PROP)
              (CL:OR (TRUE? PROP)
               (FUNCTION-WITH-DEFINED-VALUE? PROP)))))
           (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))))
        (CL:WHEN FOUND?-000
         (CL:RETURN-FROM EXTENSIONAL-INDIVIDUAL? CL:T))))
      (CL:LET* ((FOUND?-001 CL:NIL))
       (CL:LET*
        ((SK NULL) (ITER-001 (VARIABLE-VALUE-INVERSE INDIVIDUAL)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ SK (%%VALUE ITER-001))
         (CL:WHEN (EXTENSIONAL-INDIVIDUAL? SK)
          (CL:SETQ FOUND?-001 CL:T) (CL:RETURN))
         (CL:SETQ ITER-001 (%%REST ITER-001))))
       (CL:LET* ((VALUE-000 FOUND?-001)) VALUE-000))))
    (CL:T CL:T))))

;;; (DEFUN (FUNCTION-WITH-DEFINED-VALUE? BOOLEAN) ...)

(CL:DEFUN FUNCTION-WITH-DEFINED-VALUE? (PROPOSITION)
  (CL:WHEN
   (CL:NOT (CL:EQ (%KIND PROPOSITION) KWD-PROPOSITIONS-FUNCTION))
   (CL:RETURN-FROM FUNCTION-WITH-DEFINED-VALUE? CL:NIL))
  (CL:LET*
   ((LASTARGUMENT (LAST (%ARGUMENTS PROPOSITION)))
    (RESULT?
     (CL:OR
      (TEST-PROPERTY? (GET-DESCRIPTION (%OPERATOR PROPOSITION))
       SGT-PROPOSITIONS-PL-KERNEL-KB-TOTAL)
      (EXTENSIONAL-INDIVIDUAL? (VALUE-OF LASTARGUMENT)))))
   (CL:WHEN (CL:AND RESULT? (CL:NOT (WORLD-STATE? *CONTEXT*)))
    (ASSIGN-TRUTH-VALUE PROPOSITION TRUE-WRAPPER)
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE LASTARGUMENT)
       SGT-PROPOSITIONS-LOGIC-SKOLEM)
      (CL:PROGN
       (CL:WHEN (CL:NOT (CL:EQ (%SKOLEM-TYPE LASTARGUMENT) NULL))
        (CL:LET*
         ((*EVALUATIONMODE* KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION)
          (*INVISIBLEASSERTION?* CL:T))
         (CL:DECLARE
          (CL:SPECIAL *EVALUATIONMODE* *INVISIBLEASSERTION?*))
         (ASSERT-ISA-PROPOSITION LASTARGUMENT
          (%SKOLEM-TYPE LASTARGUMENT))))))
     (CL:T)))
   RESULT?))

;;; (DEFUN (CREATE-ENUMERATED-SET SKOLEM) ...)

(CL:DEFUN CREATE-ENUMERATED-SET (SET)
  (CL:LET*
   ((SETPROP
     (BEGIN-CREATING-FUNCTION-PROPOSITION
      SGT-PROPOSITIONS-PL-KERNEL-KB-SETOF (%THE-CONS-LIST SET)))
    (SKOLEM (CREATE-SKOLEM SGT-PROPOSITIONS-PL-KERNEL-KB-SET NULL)))
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS SETPROP))) (VALUE SKOLEM)
     (POSITION (LENGTH SET)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%DEFINING-PROPOSITION SKOLEM) SETPROP)
   (ADD-DEPENDENT-PROPOSITION-LINK SKOLEM SETPROP)
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SETPROP)
    SYM-PROPOSITIONS-LOGIC-UNFASTENED? NULL NULL)
   SKOLEM))

;;; (DEFUN (CREATE-LOGICAL-LIST SKOLEM) ...)

(CL:DEFUN CREATE-LOGICAL-LIST (LIST)
  (CL:LET*
   ((LISTPROP
     (BEGIN-CREATING-FUNCTION-PROPOSITION
      SGT-PROPOSITIONS-PL-KERNEL-KB-LISTOF (%THE-CONS-LIST LIST)))
    (SKOLEM (CREATE-SKOLEM SGT-PROPOSITIONS-PL-KERNEL-KB-LIST NULL)))
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS LISTPROP))) (VALUE SKOLEM)
     (POSITION (LENGTH LIST)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%DEFINING-PROPOSITION SKOLEM) LISTPROP)
   (ADD-DEPENDENT-PROPOSITION-LINK SKOLEM LISTPROP)
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS LISTPROP)
    SYM-PROPOSITIONS-LOGIC-UNFASTENED? NULL NULL)
   SKOLEM))

;;; (DEFUN (LOGICAL-COLLECTION? BOOLEAN) ...)

(CL:DEFUN LOGICAL-COLLECTION? (SELF)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-PROPOSITIONS-LOGIC-SKOLEM)
    (CL:PROGN
     (CL:LET* ((DEFININGPROPOSITION (%DEFINING-PROPOSITION SELF)))
      (CL:AND (CL:NOT (CL:EQ DEFININGPROPOSITION NULL))
       (COLLECTIONOF-PROPOSITION? DEFININGPROPOSITION)))))
   (CL:T CL:NIL)))

;;; (DEFUN (SKOLEM-DEFINED-BY-OPERATOR? BOOLEAN) ...)

(CL:DEFUN SKOLEM-DEFINED-BY-OPERATOR? (SELF OPERATOR)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-PROPOSITIONS-LOGIC-SKOLEM)
    (CL:PROGN
     (CL:LET* ((DEFININGPROPOSITION (%DEFINING-PROPOSITION SELF)))
      (CL:AND (CL:NOT (CL:EQ DEFININGPROPOSITION NULL))
       (CL:EQ (%OPERATOR DEFININGPROPOSITION) OPERATOR)))))
   (CL:T CL:NIL)))

;;; (DEFUN (ENUMERATED-SET? BOOLEAN) ...)

(CL:DEFUN ENUMERATED-SET? (SELF)
  (SKOLEM-DEFINED-BY-OPERATOR? SELF SGT-PROPOSITIONS-PL-KERNEL-KB-SETOF))

;;; (DEFUN (ENUMERATED-LIST? BOOLEAN) ...)

(CL:DEFUN ENUMERATED-LIST? (SELF)
  (SKOLEM-DEFINED-BY-OPERATOR? SELF
   SGT-PROPOSITIONS-PL-KERNEL-KB-LISTOF))

;;; (DEFUN (CANONICALIZE-PROPOSITION-TREE OBJECT) ...)

(CL:DEFUN CANONICALIZE-PROPOSITION-TREE (TREE)
  TREE)

;;; (DEFUN ERASE-PROPOSITION ...)

(CL:DEFUN ERASE-PROPOSITION (PROPOSITION)
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ ARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
      INDEX-000))
    (CL:WHEN (CL:NOT (CL:EQ ARG NULL))
     (REMOVE-DEPENDENT-PROPOSITION-LINK ARG PROPOSITION))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
  (FREE (%ARGUMENTS PROPOSITION))
  (CL:SETF (%ARGUMENTS PROPOSITION) NULL)
  (DELETED?-SETTER PROPOSITION CL:T))

;;; (DEFUN (UPDATE-EQUIVALENCE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN UPDATE-EQUIVALENCE-PROPOSITION (PROPOSITION UPDATEMODE)
  (CL:LET*
   ((TERM1
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (TERM2
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1)))
   (CL:WHEN (CL:AND (SKOLEM? TERM1) (SKOLEM? TERM2))
    (CL:WHEN (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-TRUE)
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
        "ERROR: Equating two skolems by default is not yet supported."
        EOL "." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
        KWD-PROPOSITIONS-ERROR))
      (CL:ERROR
       (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
    (CL:RETURN-FROM UPDATE-EQUIVALENCE-PROPOSITION PROPOSITION))
   (CL:COND
    ((CL:OR (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
      (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-TRUE))
     (UPDATE-PROPOSITION-TRUTH-VALUE PROPOSITION UPDATEMODE)
     (CL:COND ((CLIP-VALUE? TERM1 TERM2)) ((CLIP-VALUE? TERM2 TERM1))
      (CL:T (EQUATE-VALUES (VALUE-OF TERM1) (VALUE-OF TERM2)))))
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
     (CL:COND ((UNEQUATE-VALUES? TERM1 TERM2))
      ((UNEQUATE-VALUES? TERM2 TERM1))))
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-CONCEIVE)
     (CL:RETURN-FROM UPDATE-EQUIVALENCE-PROPOSITION PROPOSITION))
    (CL:T
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" UPDATEMODE
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))
   (CL:WHEN
    (CL:AND (FUNCTION-OUTPUT-SKOLEM? TERM1)
     (CL:NOT (FUNCTION-OUTPUT-SKOLEM? TERM2)))
    (RUN-UPDATE-PROPOSITION-DEMON PROPOSITION UPDATEMODE)
    (CL:RETURN-FROM UPDATE-EQUIVALENCE-PROPOSITION
     (CL:IF (DELETED? PROPOSITION) NULL
      (%DEFINING-PROPOSITION TERM1))))
   (CL:WHEN
    (CL:AND (FUNCTION-OUTPUT-SKOLEM? TERM2)
     (CL:NOT (FUNCTION-OUTPUT-SKOLEM? TERM1)))
    (RUN-UPDATE-PROPOSITION-DEMON PROPOSITION UPDATEMODE)
    (CL:RETURN-FROM UPDATE-EQUIVALENCE-PROPOSITION
     (CL:IF (DELETED? PROPOSITION) NULL
      (%DEFINING-PROPOSITION TERM2))))
   NULL))

;;; (DEFUN (SKOLEMIZE-EXISTS-PROPOSITION PROPOSITION) ...)

(CL:DEFUN SKOLEMIZE-EXISTS-PROPOSITION (EXISTSPROPOSITION)
  (CL:LET*
   ((MAPPING (NEW-KEY-VALUE-LIST)) (SKOLEMIZEDPROPOSITION NULL))
   (CL:LET*
    ((VAR NULL)
     (VECTOR-000
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS EXISTSPROPOSITION)
       SYM-PROPOSITIONS-LOGIC-IO-VARIABLES NULL))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ VAR
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CREATE-SKOLEM-FOR-UNMAPPED-VARIABLE VAR MAPPING)
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:SETQ SKOLEMIZEDPROPOSITION
    (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS
     (INHERIT-PROPOSITION
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%THE-ARRAY (%ARGUMENTS EXISTSPROPOSITION)))
       0)
      MAPPING)
     CL:NIL))
   (ERASE-PROPOSITION EXISTSPROPOSITION) SKOLEMIZEDPROPOSITION))

;;; (DEFUN (HELP-UPDATE-TOP-LEVEL-PROPOSITION (CONS OF PROPOSITION)) ...)

(CL:DEFUN HELP-UPDATE-TOP-LEVEL-PROPOSITION (PROPOSITION UPDATEMODE)
  (CL:WHEN (CL:EQ PROPOSITION NULL)
   (CL:RETURN-FROM HELP-UPDATE-TOP-LEVEL-PROPOSITION NULL))
  (CL:WHEN
   (CL:EQ
    (LOOKUP-ANNOTATION PROPOSITION KWD-PROPOSITIONS-CONFIDENCE-LEVEL)
    KWD-PROPOSITIONS-DEFAULT)
   (CL:SETQ UPDATEMODE (DEFAULTIFY-UPDATE-MODE UPDATEMODE))
   (CL:WHEN
    (CL:OR (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-TRUE)
     (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-FALSE))
    (REMOVE-ANNOTATION PROPOSITION KWD-PROPOSITIONS-CONFIDENCE-LEVEL)))
  (CL:WHEN (NATIVE-SLOT-PROPOSITION? PROPOSITION)
   (CL:RETURN-FROM HELP-UPDATE-TOP-LEVEL-PROPOSITION
    (UPDATE-NATIVE-SLOT-PROPOSITION PROPOSITION UPDATEMODE)))
  (CL:LET* ((*CONTEXT* (GET-TOP-LEVEL-UPDATE-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *CONTEXT*))
   (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-AND)
      (CL:LET* ((PROPOSITIONS NIL))
       (CL:LET*
        ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:LET*
          ((P NULL)
           (ITER-000
            (HELP-UPDATE-TOP-LEVEL-PROPOSITION ARG UPDATEMODE))
           (COLLECT-000 NULL))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
           (CL:SETQ P (%%VALUE ITER-000))
           (CL:WHEN
            (CL:AND (CL:NOT (CL:EQ P NULL)) (CL:NOT (DELETED? P)))
            (CL:IF (CL:EQ COLLECT-000 NULL)
             (CL:PROGN (CL:SETQ COLLECT-000 (CONS P NIL))
              (CL:IF (CL:EQ PROPOSITIONS NIL)
               (CL:SETQ PROPOSITIONS COLLECT-000)
               (ADD-CONS-TO-END-OF-CONS-LIST PROPOSITIONS
                COLLECT-000)))
             (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS P NIL))
              (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
           (CL:SETQ ITER-000 (%%REST ITER-000))))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
       (ERASE-PROPOSITION PROPOSITION)
       (CL:RETURN-FROM HELP-UPDATE-TOP-LEVEL-PROPOSITION
        PROPOSITIONS)))
     ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-EQUIVALENT)
      (CL:SETQ PROPOSITION
       (UPDATE-EQUIVALENCE-PROPOSITION PROPOSITION UPDATEMODE))
      (CL:WHEN (CL:EQ PROPOSITION NULL)
       (CL:RETURN-FROM HELP-UPDATE-TOP-LEVEL-PROPOSITION NIL)))
     ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-NOT)
      (CL:LET*
       ((ARGUMENT
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          0)))
       (CL:COND
        ((CL:OR (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
          (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
          (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-TRUE)
          (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-FALSE)
          (CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
          (CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-FALSE))
         (UPDATE-PROPOSITION-TRUTH-VALUE ARGUMENT
          (INVERT-UPDATE-MODE UPDATEMODE))
         (ERASE-PROPOSITION PROPOSITION)
         (CL:IF
          (CL:AND (CL:NOT (CL:EQ ARGUMENT NULL))
           (CL:NOT (DELETED? ARGUMENT)))
          (CL:RETURN-FROM HELP-UPDATE-TOP-LEVEL-PROPOSITION
           (CONS-LIST ARGUMENT))
          (CL:RETURN-FROM HELP-UPDATE-TOP-LEVEL-PROPOSITION NIL)))
        (CL:T))))
     ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-EXISTS)
      (CL:RETURN-FROM HELP-UPDATE-TOP-LEVEL-PROPOSITION
       (HELP-UPDATE-TOP-LEVEL-PROPOSITION
        (SKOLEMIZE-EXISTS-PROPOSITION PROPOSITION) UPDATEMODE)))
     (CL:T)))
   (CL:WHEN
    (CL:NOT (CL:EQ (%KIND PROPOSITION) KWD-PROPOSITIONS-FUNCTION))
    (UPDATE-PROPOSITION-TRUTH-VALUE PROPOSITION UPDATEMODE))
   (CL:IF (DELETED? PROPOSITION) NIL (CONS-LIST PROPOSITION))))

;;; (DEFUN (INVERT-UPDATE-MODE KEYWORD) ...)

(CL:DEFUN INVERT-UPDATE-MODE (UPDATEMODE)
  (CL:COND
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
    KWD-PROPOSITIONS-ASSERT-FALSE)
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-TRUE)
    KWD-PROPOSITIONS-PRESUME-FALSE)
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
    KWD-PROPOSITIONS-RETRACT-FALSE)
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
    KWD-PROPOSITIONS-ASSERT-TRUE)
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-FALSE)
    KWD-PROPOSITIONS-PRESUME-TRUE)
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-FALSE)
    KWD-PROPOSITIONS-RETRACT-TRUE)
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" UPDATEMODE
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (DEFAULTIFY-UPDATE-MODE KEYWORD) ...)

(CL:DEFUN DEFAULTIFY-UPDATE-MODE (UPDATEMODE)
  (CL:COND
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
    KWD-PROPOSITIONS-PRESUME-TRUE)
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
    KWD-PROPOSITIONS-PRESUME-FALSE)
   (CL:T UPDATEMODE)))

;;; (DEFUN (UPDATE-TOP-LEVEL-PROPOSITION (CONS OF PROPOSITION)) ...)

(CL:DEFUN UPDATE-TOP-LEVEL-PROPOSITION (TREE UPDATEMODE)
  (CL:COND
   ((CL:OR (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
     (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-FALSE)
     (CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-FALSE))
    (CL:SETQ TREE (LIST* SYM-PROPOSITIONS-STELLA-NOT TREE NIL))
    (CL:SETQ UPDATEMODE (INVERT-UPDATE-MODE UPDATEMODE)))
   (CL:T))
  (CL:COND
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
    (CL:LET* ((*AUTOMATICINSTANCETABLE* NULL))
     (CL:DECLARE (CL:SPECIAL *AUTOMATICINSTANCETABLE*))
     (HELP-UPDATE-TOP-LEVEL-PROPOSITION
      (BUILD-TOP-LEVEL-PROPOSITION TREE CL:T) UPDATEMODE)))
   (CL:T
    (HELP-UPDATE-TOP-LEVEL-PROPOSITION
     (BUILD-TOP-LEVEL-PROPOSITION TREE CL:NIL) UPDATEMODE))))

;;; (DEFUN (STANDARDIZE-PROPOSITION-TREE OBJECT) ...)

(CL:DEFUN STANDARDIZE-PROPOSITION-TREE (TREE)
  (CL:WHEN (STRING? TREE)
   (CL:SETQ TREE (READ-S-EXPRESSION-FROM-STRING (%WRAPPER-VALUE TREE))))
  (CL:SETQ TREE (STANDARDIZE-LOGICAL-PARSE-TREE TREE))
  (CL:WHEN (CONS? TREE)
   (CL:SETQ TREE (CANONICALIZE-PROPOSITION-TREE TREE)))
  TREE)

;;; (DEFUN (UPDATE-PROPOSITION (CONS OF PROPOSITION)) ...)

(CL:DEFUN UPDATE-PROPOSITION (TREE UPDATEMODE)
  (CL:HANDLER-CASE
   (CL:LET* ((*INHIBITOBJECTFINALIZATION?* CL:T))
    (CL:DECLARE (CL:SPECIAL *INHIBITOBJECTFINALIZATION?*))
    (CL:RETURN-FROM UPDATE-PROPOSITION
     (UPDATE-TOP-LEVEL-PROPOSITION (STANDARDIZE-PROPOSITION-TREE TREE)
      UPDATEMODE)))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E)))
   (READ-EXCEPTION (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))))
  NULL)

;;; (DEFUN (BUILD-TOP-LEVEL-TERM OBJECT) ...)

(CL:DEFUN BUILD-TOP-LEVEL-TERM (TREE)
  (CL:LET* ((TERM NULL))
   (CL:LET*
    ((*LOGICVARIABLETABLE* NIL) (*VARIABLEIDCOUNTER* 0)
     (*TERMUNDERCONSTRUCTION* TREE))
    (CL:DECLARE
     (CL:SPECIAL *LOGICVARIABLETABLE* *VARIABLEIDCOUNTER*
      *TERMUNDERCONSTRUCTION*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *VARIABLEIDCOUNTER*))
    (CL:COND
     ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-PROPOSITIONS-STELLA-CONS)
      (CL:PROGN
       (CL:WHEN
        (MEMBER?
         (GET-QUOTED-TREE
          "((FORALL EXISTS IMPLIES AND OR NOT) \"/LOGIC\")" "/LOGIC")
         (%%VALUE TREE))
        (CL:WARN "Sentence where term expected: `~A'~%" TREE)
        (CL:RETURN-FROM BUILD-TOP-LEVEL-TERM NULL))))
     (CL:T))
    (CL:SETQ TERM (EVALUATE-TERM TREE)))
   TERM))

;;; (DEFUN (CONCEIVE-TERM OBJECT) ...)

(CL:DEFUN CONCEIVE-TERM (TREE)
  "`tree' is a term expression (a string or an s-expression),
or is a class reference (a symbol or surrogate).  Return a (possibly 
newly-conceived) term representing the internalized representation of that term."
  (CL:HANDLER-CASE
   (CL:LET*
    ((STANDARDIZEDTREE (STANDARDIZE-PROPOSITION-TREE TREE))
     (OPERATOR NULL) (TERM NULL))
    (CL:WHEN (CONS? STANDARDIZEDTREE)
     (CL:SETQ OPERATOR (%%VALUE STANDARDIZEDTREE)))
    (CL:IF
     (CL:AND (CL:NOT (CL:EQ OPERATOR NULL))
      (CL:NOT (CL:EQ (GET-RELATION OPERATOR) NULL))
      (CL:NOT (FUNCTION? (GET-RELATION OPERATOR))))
     (CL:SETQ TERM (CONCEIVE-SENTENCE TREE))
     (CL:SETQ TERM (BUILD-TOP-LEVEL-TERM STANDARDIZEDTREE)))
    (CL:RETURN-FROM CONCEIVE-TERM TERM))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E)))
   (READ-EXCEPTION (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))))
  NULL)

;;; (DEFUN (CONCEIVE-SENTENCE OBJECT) ...)

(CL:DEFUN CONCEIVE-SENTENCE (TREE)
  (CL:COND
   ((SUBTYPE-OF-STRING? (SAFE-PRIMARY-TYPE TREE))
    (CL:PROGN
     (CONCEIVE-SENTENCE
      (READ-S-EXPRESSION-FROM-STRING (%WRAPPER-VALUE TREE)))))
   (CL:T (SMART-UPDATE-PROPOSITION TREE KWD-PROPOSITIONS-CONCEIVE))))

;;; (DEFUN (CONCEIVE-FORMULA OBJECT) ...)

(CL:DEFUN CONCEIVE-FORMULA (TREE)
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((SUBTYPE-OF-STRING? TEST-VALUE-001)
     (CL:PROGN
      (CONCEIVE-FORMULA
       (READ-S-EXPRESSION-FROM-STRING (%WRAPPER-VALUE TREE)))))
    ((CL:EQ TEST-VALUE-001 SGT-PROPOSITIONS-STELLA-CONS)
     (CL:PROGN
      (CL:WHEN (SYMBOL? (%%VALUE TREE))
       (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
        (CL:COND
         ((CL:OR (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-KAPPA)
           (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-LAMBDA)
           (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-SETOFALL)
           (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-PL-KERNEL-KB-SETOF)
           (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-PL-KERNEL-KB-LISTOF)
           (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-BAGOF))
          (CL:RETURN-FROM CONCEIVE-FORMULA (CONCEIVE-TERM TREE)))
         (CL:T))))
      (CONCEIVE-SENTENCE TREE)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
     (CL:PROGN (CONCEIVE-TERM TREE)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
     (CL:PROGN (CONCEIVE-TERM (SURROGATE-TO-SYMBOL TREE))))
    (CL:T (CONCEIVE-SENTENCE TREE)))))

;;; (DEFUN (SMART-UPDATE-PROPOSITION OBJECT) ...)

(CL:DEFUN SMART-UPDATE-PROPOSITION (TREE UPDATEMODE)
  (CL:LET* ((PROPOSITIONS (UPDATE-PROPOSITION TREE UPDATEMODE)))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ PROPOSITIONS NULL))
     (CL:EQ (%%REST PROPOSITIONS) NIL))
    (%%VALUE PROPOSITIONS) PROPOSITIONS)))

;;; (DEFUN (ASSERT OBJECT) ...)

(CL:DEFUN %ASSERT (PROPOSITION)
  "Assert the truth of `proposition'.  Return the asserted proposition object.
KIF example:  \"(assert (happy Fred))\" asserts that Fred is indeed happy.
Note that for this assertion to succeed, the relation `happy' must already
be defined.  If the constant `Fred' has not yet been created, it is
automatically created as a side-effect of calling `assert'."
  (SMART-UPDATE-PROPOSITION PROPOSITION KWD-PROPOSITIONS-ASSERT-TRUE))

(CL:DEFMACRO ASSERT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Assert the truth of `proposition'.  Return the asserted proposition object.
KIF example:  \"(assert (happy Fred))\" asserts that Fred is indeed happy.
Note that for this assertion to succeed, the relation `happy' must already
be defined.  If the constant `Fred' has not yet been created, it is
automatically created as a side-effect of calling `assert'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/ASSERT|)) (CL:MACRO-FUNCTION (CL:QUOTE ASSERT)))

;;; (DEFUN (PRESUME OBJECT) ...)

(CL:DEFUN %PRESUME (PROPOSITION)
  "Presume the default truth of `proposition'.  Return the presumed
proposition object.  KIF example:  \"(presume (happy Fred))\" states that Fred
is most probably happy.  Note, that for this to succeed, the relation
`happy' must already be defined (see `assert')."
  (SMART-UPDATE-PROPOSITION PROPOSITION KWD-PROPOSITIONS-PRESUME-TRUE))

(CL:DEFMACRO PRESUME (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Presume the default truth of `proposition'.  Return the presumed
proposition object.  KIF example:  \"(presume (happy Fred))\" states that Fred
is most probably happy.  Note, that for this to succeed, the relation
`happy' must already be defined (see `assert')."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/PRESUME|)) (CL:MACRO-FUNCTION (CL:QUOTE PRESUME)))

;;; (DEFUN (RETRACT OBJECT) ...)

(CL:DEFUN %RETRACT (PROPOSITION)
  "Retract the truth of `proposition'.  Return the retracted proposition
object.  KIF example:  \"(retract (happy Fred))\" retracts that Fred is
happy.  Note that for this assertion to succeed, the relation `happy' must already
be defined.  If the constant `Fred' has not yet been created, it is
automatically created as a side-effect of calling `retract'."
  (SMART-UPDATE-PROPOSITION PROPOSITION KWD-PROPOSITIONS-RETRACT-TRUE))

(CL:DEFMACRO RETRACT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Retract the truth of `proposition'.  Return the retracted proposition
object.  KIF example:  \"(retract (happy Fred))\" retracts that Fred is
happy.  Note that for this assertion to succeed, the relation `happy' must already
be defined.  If the constant `Fred' has not yet been created, it is
automatically created as a side-effect of calling `retract'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/RETRACT|)) (CL:MACRO-FUNCTION (CL:QUOTE RETRACT)))

;;; (DEFUN (DENY OBJECT) ...)

(CL:DEFUN %DENY (PROPOSITION)
  "Assert the falsity of `proposition'.  Return the asserted proposition
object.  KIF example:  \"(deny (happy Fred))\" asserts that Fred is not happy,
which could have been done equivalently by \"(assert (not (happy Fred)))\".
Note, that for this to succeed, the relation `happy' must already be defined
(see `assert')."
  (SMART-UPDATE-PROPOSITION PROPOSITION KWD-PROPOSITIONS-ASSERT-FALSE))

(CL:DEFMACRO DENY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Assert the falsity of `proposition'.  Return the asserted proposition
object.  KIF example:  \"(deny (happy Fred))\" asserts that Fred is not happy,
which could have been done equivalently by \"(assert (not (happy Fred)))\".
Note, that for this to succeed, the relation `happy' must already be defined
(see `assert')."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/DENY|)) (CL:MACRO-FUNCTION (CL:QUOTE DENY)))

;;; (DEFUN (CONCEIVE OBJECT) ...)

(CL:DEFUN %CONCEIVE (FORMULA)
  "Guess whether 'formula' represents a term or a sentence/proposition.
If we are not sure, assume its a proposition.
If its, a term, return its internal representation.  If a proposition,
construct a proposition for 'formula' without asserting its truth value.
Return the conceived proposition object.  KIF example: \"(conceive (happy Fred))\"
builds the proposition expressing that Fred is happy without explictly asserting
or denying it.  Note, that for this to succeed, the relation `happy' must already
be defined (see `assert').  If the logic constant `Fred' has not yet been
created, it is automatically created as a side-effect of calling `conceive'."
  (CONCEIVE-FORMULA FORMULA))

(CL:DEFMACRO CONCEIVE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Guess whether 'formula' represents a term or a sentence/proposition.
If we are not sure, assume its a proposition.
If its, a term, return its internal representation.  If a proposition,
construct a proposition for 'formula' without asserting its truth value.
Return the conceived proposition object.  KIF example: \"(conceive (happy Fred))\"
builds the proposition expressing that Fred is happy without explictly asserting
or denying it.  Note, that for this to succeed, the relation `happy' must already
be defined (see `assert').  If the logic constant `Fred' has not yet been
created, it is automatically created as a side-effect of calling `conceive'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/CONCEIVE|)) (CL:MACRO-FUNCTION (CL:QUOTE CONCEIVE)))

;;; (DEFUN (UNASSERT OBJECT) ...)

(CL:DEFUN %UNASSERT (PROPOSITION)
  "Retract the truth, falsity or inconsistency of `proposition'.  This is a
more general version of `retract' that also handles falsity.  For example, if
we assert the proposition \"(not (sad Fred))\", and then execute the statement
\"(unassert (sad Fred))\", the truth value of the proposition \"(sad Fred)\"
will be set to UNKNOWN.  If we had called `retract' in place of `unassert',
the proposition \"(sad Fred)\" would remain set to FALSE.   Note that for this
unassertion to succeed, the logic constant `Fred' and the relation `sad' must
already be defined."
  (CL:LET*
   ((PARSEDPROPS
     (UPDATE-PROPOSITION PROPOSITION KWD-PROPOSITIONS-CONCEIVE))
    (RESULT NIL))
   (CL:WHEN (CL:NOT (CL:EQ PARSEDPROPS NULL))
    (CL:LET* ((PROP NULL) (ITER-000 PARSEDPROPS) (COLLECT-000 NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ PROP (%%VALUE ITER-000))
      (CL:WHEN (CL:EQ (%KIND PROP) KWD-PROPOSITIONS-NOT)
       (CL:SETQ PROP
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP))) 0)))
      (UNASSERT-PROPOSITION PROP)
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS PROP NIL))
        (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS PROP NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))
   (CL:IF (CL:> (LENGTH RESULT) 1) RESULT (%%VALUE RESULT))))

(CL:DEFMACRO UNASSERT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Retract the truth, falsity or inconsistency of `proposition'.  This is a
more general version of `retract' that also handles falsity.  For example, if
we assert the proposition \"(not (sad Fred))\", and then execute the statement
\"(unassert (sad Fred))\", the truth value of the proposition \"(sad Fred)\"
will be set to UNKNOWN.  If we had called `retract' in place of `unassert',
the proposition \"(sad Fred)\" would remain set to FALSE.   Note that for this
unassertion to succeed, the logic constant `Fred' and the relation `sad' must
already be defined."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/UNASSERT|)) (CL:MACRO-FUNCTION (CL:QUOTE UNASSERT)))

;;; (DEFUN UNASSERT-PROPOSITION ...)

(CL:DEFUN UNASSERT-PROPOSITION (SELF)
  "Retract the truth, falsity or inconsistency of the proposition `self'."
  (CL:WHEN (CL:NOT (CL:EQ SELF NULL))
   (CL:LET*
    ((EQUIVALENCE? (CL:EQ (%KIND SELF) KWD-PROPOSITIONS-EQUIVALENT)))
    (CL:COND
     ((TRUE? SELF)
      (CL:IF EQUIVALENCE?
       (UPDATE-EQUIVALENCE-PROPOSITION SELF
        KWD-PROPOSITIONS-RETRACT-TRUE)
       (UPDATE-PROPOSITION-TRUTH-VALUE SELF
        KWD-PROPOSITIONS-RETRACT-TRUE)))
     ((FALSE? SELF)
      (CL:IF EQUIVALENCE?
       (UPDATE-EQUIVALENCE-PROPOSITION SELF
        KWD-PROPOSITIONS-RETRACT-FALSE)
       (UPDATE-PROPOSITION-TRUTH-VALUE SELF
        KWD-PROPOSITIONS-RETRACT-FALSE)))
     ((INCONSISTENT? SELF)
      (CL:COND
       (EQUIVALENCE?
        (DEASSIGN-TRUTH-VALUE SELF
         KWD-PROPOSITIONS-RETRACT-INCONSISTENT)
        (UPDATE-EQUIVALENCE-PROPOSITION SELF
         KWD-PROPOSITIONS-RETRACT-TRUE)
        (UPDATE-EQUIVALENCE-PROPOSITION SELF
         KWD-PROPOSITIONS-RETRACT-FALSE))
       (CL:T
        (DEASSIGN-TRUTH-VALUE SELF
         KWD-PROPOSITIONS-RETRACT-INCONSISTENT)
        (UPDATE-PROPOSITION-TRUTH-VALUE SELF
         KWD-PROPOSITIONS-RETRACT-TRUE)
        (UPDATE-PROPOSITION-TRUTH-VALUE SELF
         KWD-PROPOSITIONS-RETRACT-FALSE))))))))

;;; (DEFMETHOD (DELETED? BOOLEAN) ...)

(CL:DEFMETHOD DELETED? ((SELF PROPOSITION))
  (DELETED-PROPOSITION? SELF))

;;; (DEFMETHOD (DELETED?-SETTER BOOLEAN) ...)

(CL:DEFMETHOD DELETED?-SETTER ((SELF PROPOSITION) VALUE)
  (CL:WHEN VALUE (CL:SETF (%KIND SELF) KWD-PROPOSITIONS-DELETED))
  VALUE)

;;; (DEFUN (DELETED-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN DELETED-PROPOSITION? (SELF)
  (CL:WHEN (CL:EQ (%KIND SELF) KWD-PROPOSITIONS-DELETED)
   (CL:RETURN-FROM DELETED-PROPOSITION? CL:T))
  CL:NIL)

;;; (DEFUN (DESTROY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN DESTROY-PROPOSITION (PROPOSITION)
  "Retract and destroy the proposition 'proposition'.
Recursively destroy all propositions that reference 'proposition'.
Also, destroy all satellite propositions of 'proposition'."
  (CL:WHEN (DELETED? PROPOSITION)
   (CL:RETURN-FROM DESTROY-PROPOSITION PROPOSITION))
  (DELETED?-SETTER PROPOSITION CL:T)
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-STELLA-SURROGATE-VALUE-INVERSE NULL)
     NULL))
   (CL:SETF
    (%SURROGATE-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-STELLA-SURROGATE-VALUE-INVERSE NULL))
    NULL))
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ ARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
      INDEX-000))
    (CL:WHEN (CL:AND (CL:NOT (CL:EQ ARG NULL)) (CL:NOT (DELETED? ARG)))
     (CL:WHEN
      (CL:AND (SKOLEM? ARG)
       (CL:EQ (%DEFINING-PROPOSITION ARG) PROPOSITION))
      (DESTROY-TERM ARG))
     (REMOVE-DEPENDENT-PROPOSITION-LINK ARG PROPOSITION))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
  (CL:LET*
   ((DEP NULL)
    (ITER-000
     (ALLOCATE-ITERATOR (COPY (%DEPENDENT-PROPOSITIONS PROPOSITION)))))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ DEP (%VALUE ITER-000))
    (DESTROY-PROPOSITION DEP)))
  (CL:LET*
   ((SATELLITE NULL)
    (ITER-001
     (%THE-CONS-LIST (COPY (SATELLITE-PROPOSITIONS PROPOSITION)))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:SETQ SATELLITE (%%VALUE ITER-001))
    (DESTROY-PROPOSITION SATELLITE)
    (CL:SETQ ITER-001 (%%REST ITER-001))))
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-LOGIC-MASTER-PROPOSITION NULL)
     NULL))
   (REMOVE
    (SATELLITE-PROPOSITIONS
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-LOGIC-MASTER-PROPOSITION NULL))
    PROPOSITION))
  (CL:WHEN (CL:NOT (CL:EQ (%HOME-CONTEXT PROPOSITION) NULL))
   (HANDLE-OUT-OF-DATE-INFERENCE-CACHE KWD-PROPOSITIONS-RETRACT
    PROPOSITION))
  (CL:SETF (%DEPENDENT-PROPOSITIONS PROPOSITION) NULL)
  (CL:SETF (%OPERATOR PROPOSITION) NULL)
  (CL:SETF (%ARGUMENTS PROPOSITION) NULL)
  (CL:SETF (%HOME-CONTEXT PROPOSITION) NULL)
  (CL:SETF (%TRUTH-VALUE PROPOSITION) NULL)
  (CL:SETF (%DYNAMIC-SLOTS PROPOSITION) NULL)
  PROPOSITION)

;;; (DEFUN DESTROY-LOGIC-INSTANCE ...)

(CL:DEFUN DESTROY-LOGIC-INSTANCE (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:WHEN (CL:OR (CL:EQ SELF NULL) (DELETED? SELF))
       (CL:RETURN-FROM DESTROY-LOGIC-INSTANCE))
      (DELETED?-SETTER SELF CL:T)
      (CL:LET* ((SURROGATE (%SURROGATE-VALUE-INVERSE SELF)))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ SURROGATE NULL))
         (CL:EQ (%SURROGATE-VALUE SURROGATE) SELF))
        (CL:SETF (%SURROGATE-VALUE SURROGATE) NULL)))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-THING)
     (CL:PROGN
      (CL:WHEN (CL:OR (CL:EQ SELF NULL) (DELETED? SELF))
       (CL:RETURN-FROM DESTROY-LOGIC-INSTANCE))
      (DELETED?-SETTER SELF CL:T)
      (CL:LET* ((SURROGATE (%SURROGATE-VALUE-INVERSE SELF)))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ SURROGATE NULL))
         (CL:EQ (%SURROGATE-VALUE SURROGATE) SELF))
        (CL:SETF (%SURROGATE-VALUE SURROGATE) NULL)))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
  (CL:LET*
   ((P NULL)
    (ITER-000
     (ALLOCATE-ITERATOR
      (UNFILTERED-DEPENDENT-PROPOSITIONS SELF NULL))))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
    (DESTROY-PROPOSITION P)))
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
    (CL:PROGN (UNLINK-EQUIVALENT-VALUE SELF)
     (CL:LET*
      ((EQUIVALENT NULL) (ITER-001 (VARIABLE-VALUE-INVERSE SELF)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ EQUIVALENT (%%VALUE ITER-001))
       (CL:WHEN (CL:NOT (DELETED? EQUIVALENT))
        (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE EQUIVALENT)))
         (CL:COND
          ((SUBTYPE-OF? TEST-VALUE-001 SGT-PROPOSITIONS-LOGIC-SKOLEM)
           (CL:PROGN
            (CL:LET*
             ((OBJECT-000 EQUIVALENT) (VALUE-000 NULL)
              (OLD-VALUE-000 (%VARIABLE-VALUE OBJECT-000))
              (NEW-VALUE-000
               (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
                (%HOME-CONTEXT OBJECT-000) CL:NIL)))
             (CL:WHEN
              (CL:NOT
               (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
                (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
                 SGT-PROPOSITIONS-STELLA-CS-VALUE)))
              (CL:SETF (%VARIABLE-VALUE OBJECT-000) NEW-VALUE-000)))))
          ((SUBTYPE-OF? TEST-VALUE-001
            SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
           (CL:PROGN
            (CL:LET*
             ((OBJECT-001 EQUIVALENT) (VALUE-001 NULL)
              (OLD-VALUE-001
               (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OBJECT-001)
                SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE NULL))
              (NEW-VALUE-001
               (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001
                (%HOME-CONTEXT OBJECT-001) CL:NIL)))
             (CL:WHEN
              (CL:NOT
               (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
                (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
                 SGT-PROPOSITIONS-STELLA-CS-VALUE)))
              (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OBJECT-001)
               SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE NEW-VALUE-001
               NULL)))))
          (CL:T
           (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
            (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
             TEST-VALUE-001 "' is not a valid case option")
            (CL:ERROR
             (NEW-STELLA-EXCEPTION
              (THE-STRING-READER STREAM-001))))))))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:LET*
      ((OBJECT-002 SELF) (VALUE-002 NULL)
       (OLD-VALUE-002 (%VARIABLE-VALUE-INVERSE OBJECT-002))
       (NEW-VALUE-002
        (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-002
         (%HOME-CONTEXT OBJECT-002) CL:NIL)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-002 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-002)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-002) NEW-VALUE-002)))))
   (CL:T)))

;;; (DEFUN DESTROY-TERM ...)

(CL:DEFUN DESTROY-TERM (SELF)
  "Destroy all propositions that reference 'self',
and mark it as 'deleted?', thereby making it invisible within class
extensions.  Unlink descriptions from native relations."
  (CL:WHEN (CL:OR (CL:EQ SELF NULL) (DELETED? SELF))
   (CL:RETURN-FROM DESTROY-TERM))
  (DESTROY-LOGIC-INSTANCE SELF)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
    (CL:PROGN
     (CL:COND
      ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
        SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
       (CL:PROGN
        (CL:LET* ((NATIVERELATION (NATIVE-RELATION SELF)))
         (NATIVE-RELATION-SETTER SELF NULL)
         (CL:WHEN (CL:NOT (CL:EQ NATIVERELATION NULL))
          (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NATIVERELATION)
           SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL NULL))
         (CL:WHEN (CL:NOT (CL:EQ (%EXTENSION SELF) NULL))
          (CL:SETF (%EXTENSION SELF) NULL)))))
      (CL:T))
     (CL:LET*
      ((COMPLEMENT
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-PROPOSITIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL)))
      (CL:WHEN (CL:NOT (CL:EQ COMPLEMENT NULL))
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS COMPLEMENT)
        SYM-PROPOSITIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL NULL)
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
        SYM-PROPOSITIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL NULL)))
     (REMOVE-ALL-DEPENDENT-PROPOSITION-LINKS SELF)
     (CL:SETF (%IO-VARIABLES SELF) NULL)
     (CL:SETF (%INTERNAL-VARIABLES SELF) NULL)
     (CL:SETF (%PROPOSITION SELF) NULL)
     (CL:SETF (%HOME-CONTEXT SELF) NULL)))
   (CL:T))
  (CLEAR (%DYNAMIC-SLOTS SELF))
  (DELETED?-SETTER SELF CL:T))

;;; (DEFUN DESTROY-INSTANCE ...)

(CL:DEFUN DESTROY-INSTANCE (SELF)
  "Destroy all propositions that reference 'self',
and mark it as 'deleted?', thereby making it invisible within class
extensions."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN (DESTROY-TERM SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-THING)
     (CL:PROGN (DESTROY-LOGIC-INSTANCE SELF)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN DESTROY-OBJECT ...)

(CL:DEFUN DESTROY-OBJECT (SELF)
  "Destroy `self' which can be a term or a proposition.  Destroy all
propositions that reference 'self' and mark it as 'deleted?' (thereby
making it invisible within class extensions)."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN (DESTROY-TERM SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-THING)
     (CL:PROGN (DESTROY-LOGIC-INSTANCE SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
     (CL:PROGN (DESTROY-PROPOSITION SELF)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (DESTROY OBJECT) ...)

(CL:DEFUN %DESTROY (OBJECTSPEC)
  "Find an object or proposition as specified by `objectSpec', and destroy all
propositions and indices that reference it.  `objectSpec' must be a name or
a parse tree that evaluates to a proposition.  Return the deleted object, or
NULL if no matching object was found."
  (CL:LET* ((OBJECT NULL))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE OBJECTSPEC)
      SGT-PROPOSITIONS-STELLA-CONS)
     (CL:PROGN (CL:SETQ OBJECT (CONCEIVE-FORMULA OBJECTSPEC))))
    (CL:T
     (CL:SETQ OBJECT
      (COERCE-TO-INSTANCE-IN-MODULE OBJECTSPEC NULL CL:NIL NULL))))
   (CL:WHEN (CL:NOT (CL:EQ OBJECT NULL)) (DESTROY-OBJECT OBJECT))
   OBJECT))

(CL:DEFMACRO DESTROY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Find an object or proposition as specified by `objectSpec', and destroy all
propositions and indices that reference it.  `objectSpec' must be a name or
a parse tree that evaluates to a proposition.  Return the deleted object, or
NULL if no matching object was found."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/DESTROY|)) (CL:MACRO-FUNCTION (CL:QUOTE DESTROY)))

;;; (DEFUN (RELATION-IN-MODULE? BOOLEAN) ...)

(CL:DEFUN RELATION-IN-MODULE? (SELF)
  (CL:EQ (%HOME-CONTEXT SELF) *MODULE*))

;;; (DEFUN INTRODUCE-MODULE ...)

(CL:DEFUN INTRODUCE-MODULE (MODULE)
  (CL:SETF (%SURROGATE-VALUE-INVERSE MODULE) NULL)
  (CL:LET*
   ((*CONTEXT* *PL-KERNEL-MODULE*) (*MODULE* (%BASE-MODULE *CONTEXT*)))
   (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
   (CL:WHEN (CL:EQ (%SURROGATE-VALUE-INVERSE MODULE) NULL)
    (CL:LET* ((SUCCESS? CL:NIL) (UNUSED NULL) (SURROGATE NULL))
     (CL:MULTIPLE-VALUE-SETQ (SUCCESS? UNUSED SURROGATE)
      (BIND-TO-SURROGATE? MODULE (NAME MODULE) CL:T CL:T))
     (CL:SETQ UNUSED UNUSED)
     (CL:WHEN SUCCESS?
      (CL:SETF (%SURROGATE-VALUE-INVERSE MODULE) SURROGATE))))
   (ASSERT-ISA-PROPOSITION MODULE SGT-PROPOSITIONS-STELLA-MODULE)))

;;; (DEFUN CLEAR-LOGIC-MODULE-HOOK ...)

(CL:DEFUN CLEAR-LOGIC-MODULE-HOOK (MODULE)
  (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (DESTROY-INFERENCE-CACHES MODULE) (FLUSH-INLINE-QUERY-CACHES)
   (CL:LET*
    ((TERM NULL)
     (ITER-000 (%THE-CONS-LIST (LISTIFY (ALL-TERMS MODULE CL:T)))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ TERM (%%VALUE ITER-000)) (DESTROY-INSTANCE TERM)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((PROPOSITION NULL) (ITER-001 (ALL-PROPOSITIONS MODULE CL:T)))
    (CL:LOOP WHILE (NEXT? ITER-001) DO
     (CL:SETQ PROPOSITION (%VALUE ITER-001))
     (DESTROY-PROPOSITION PROPOSITION)))
   (CLEANUP-STRUCTURED-OBJECTS-INDEX MODULE)
   (REMOVE-DELETED-MEMBERS (LOCALLY-CONCEIVED-PROPOSITIONS MODULE))
   (REMOVE-DELETED-MEMBERS (LOCALLY-CONCEIVED-INSTANCES MODULE))
   (CLEANUP-ALL-DESCRIPTION-EXTENSIONS) (CLEANUP-UNFINALIZED-OBJECTS)
   (CLEAR-MEMOIZATION-TABLES KWD-PROPOSITIONS-KB-UPDATE)
   (CLEAR-MEMOIZATION-TABLES KWD-PROPOSITIONS-META-KB-UPDATE)))

;;; (DEFUN CLEAR-INSTANCES ...)

(CL:DEFUN %CLEAR-INSTANCES (NAME)
  "Destroy all instances belonging to module `name' or any of its children.
Leave meta-objects, e.g., concepts and relations, alone.
If no `name' is supplied, the current module will be cleared after
confirming with the user."
  (CL:LET*
   ((OPTIONALNAME NAME)
    (MODULE (COERCE-TO-MODULE (%%VALUE OPTIONALNAME) CL:T)))
   (CL:WHEN (CL:NOT (CL:EQ MODULE NULL))
    (CL:WHEN
     (CL:OR (CL:NOT (CL:EQ OPTIONALNAME NIL))
      (Y-OR-N?
       (CONCATENATE "Really clear instances of module "
        (CONCATENATE (%MODULE-FULL-NAME MODULE) "? "))))
     (DO-CLEAR-INSTANCES MODULE)))))

(CL:DEFUN CLEAR-INSTANCES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%CLEAR-INSTANCES ARGUMENTS))

(CL:DEFMACRO CLEAR-INSTANCES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Destroy all instances belonging to module `name' or any of its children.
Leave meta-objects, e.g., concepts and relations, alone.
If no `name' is supplied, the current module will be cleared after
confirming with the user."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/CLEAR-INSTANCES|)) (CL:MACRO-FUNCTION (CL:QUOTE CLEAR-INSTANCES)))

;;; (DEFUN DO-CLEAR-INSTANCES ...)

(CL:DEFUN DO-CLEAR-INSTANCES (MODULE)
  "Function version of `clear-instances' that evaluates its argument."
  (CL:LET*
   ((CHILD NULL) (ITER-000 (%THE-CONS-LIST (%CHILD-CONTEXTS MODULE))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ CHILD (%%VALUE ITER-000))
    (CL:WHEN (ISA? CHILD SGT-PROPOSITIONS-STELLA-MODULE)
     (DO-CLEAR-INSTANCES CHILD))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (DESTROY-INFERENCE-CACHES MODULE)
   (CL:LET* ((INSTANCE NULL) (ITER-001 (ALL-INSTANCES MODULE CL:T)))
    (CL:LOOP WHILE (NEXT? ITER-001) DO
     (CL:SETQ INSTANCE (%VALUE ITER-001)) (DESTROY-INSTANCE INSTANCE)))
   (REMOVE-DELETED-MEMBERS (LOCALLY-CONCEIVED-PROPOSITIONS MODULE))))

;;; (DEFUN DESTROY-LOGIC-CONTEXT-HOOK ...)

(CL:DEFUN DESTROY-LOGIC-CONTEXT-HOOK (SELF)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-PROPOSITIONS-LOGIC-MONOTONIC?
   (CL:IF CL:NIL TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
  (CL:LET* ((*CONTEXT* SELF) (*MODULE* (%BASE-MODULE *CONTEXT*)))
   (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
   (CL:LET*
    ((I NULL)
     (ITER-000 (ALLOCATE-ITERATOR (LOCALLY-CONCEIVED-INSTANCES SELF))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ I (%VALUE ITER-000))
     (DESTROY-TERM I))))
  (CL:WHEN (ISA? SELF SGT-PROPOSITIONS-STELLA-MODULE)
   (CLEAR-LOGIC-MODULE-HOOK SELF)
   (CL:SETF (%SURROGATE-VALUE (%SURROGATE-VALUE-INVERSE SELF)) NULL))
  (CL:WHEN (ISA? SELF SGT-PROPOSITIONS-STELLA-WORLD)
   (UNLINK-INFERENCE-CACHE SELF)))

;;; (DEFUN CLEAR-CACHES ...)

(CL:DEFUN CLEAR-CACHES ()
  "Clear all query and memoization caches."
  (CLEAR-QUERY-RESULTS-CACHE)
  (CLEAR-ALL-MEMOIZATION-TABLES))

;;; (DEFUN RESET-POWERLOOM ...)

(CL:DEFUN RESET-POWERLOOM ()
  "Reset PowerLoom to its initial state.
CAUTION: This will destroy all loaded knowledge bases and might break other
loaded STELLA systems if they do reference PowerLoom symbols in their code."
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:LET*
    ((MODULES
      (LIST (GET-STELLA-MODULE "PLI" CL:T) *PL-ANONYMOUS-MODULE*
       *PL-KERNEL-MODULE* *LOGIC-MODULE*)))
    (CL:LET* ((MOD NULL) (ITER-000 (%THE-CONS-LIST MODULES)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ MOD (%%VALUE ITER-000))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS MOD)
       SYM-PROPOSITIONS-STELLA-CLEARABLE?
       (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS MOD)
       SYM-PROPOSITIONS-STELLA-PROTECT-SURROGATES?
       (CL:IF CL:NIL TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
      (CL:LET*
       ((SUB NULL)
        (ITER-001 (ALL-SUBCONTEXTS MOD KWD-PROPOSITIONS-PREORDER)))
       (CL:LOOP WHILE (NEXT? ITER-001) DO
        (CL:SETQ SUB (%VALUE ITER-001))
        (CL:COND
         ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SUB)
           SGT-PROPOSITIONS-STELLA-MODULE)
          (CL:PROGN
           (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SUB)
            SYM-PROPOSITIONS-STELLA-CLEARABLE?
            (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
           (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SUB)
            SYM-PROPOSITIONS-STELLA-PROTECT-SURROGATES?
            (CL:IF CL:NIL TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)))
         (CL:T))))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:LET* ((MOD NULL) (ITER-002 (%THE-CONS-LIST MODULES)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:SETQ MOD (%%VALUE ITER-002)) (CLEAR-CONTEXT MOD)
      (CL:SETQ ITER-002 (%%REST ITER-002))))
    (DROP-HOOK *DEFINE-MODULE-HOOKS*
     SYM-PROPOSITIONS-LOGIC-INTRODUCE-MODULE)
    (DROP-HOOK *CLEAR-MODULE-HOOKS*
     SYM-PROPOSITIONS-LOGIC-CLEAR-LOGIC-MODULE-HOOK)
    (DROP-HOOK *DESTROY-CONTEXT-HOOKS*
     SYM-PROPOSITIONS-LOGIC-DESTROY-LOGIC-CONTEXT-HOOK)
    (DROP-HOOK *REDEFINE-RELATION-HOOKS*
     SYM-PROPOSITIONS-LOGIC-TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK)
    (CL:LET* ((MOD NULL) (ITER-003 (%THE-CONS-LIST MODULES)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
      (CL:SETQ MOD (%%VALUE ITER-003)) (DESTROY-MODULE MOD)
      (CL:SETQ ITER-003 (%%REST ITER-003))))
    (CL:SETQ *PL-KERNEL-MODULE* NULL) (CL:SETQ *LOGIC-MODULE* NULL)
    (CLEAR-ALL-MEMOIZATION-TABLES) (STARTUP-LOGIC-SYSTEM)))
  (CHANGE-MODULE (GET-STELLA-MODULE "PL-USER" CL:T)))

;;; (DEFUN (CONS-LESS-THAN? BOOLEAN) ...)

(CL:DEFUN CONS-LESS-THAN? (O1 O2)
  (CL:LET* ((I1 NULL) (ITER-000 O1) (I2 NULL) (ITER-001 O2))
   (CL:LOOP WHILE
    (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
     (CL:NOT (CL:EQ ITER-001 NIL)))
    DO (CL:SETQ I1 (%%VALUE ITER-000)) (CL:SETQ I2 (%%VALUE ITER-001))
    (CL:WHEN (LOGIC-FORM-LESS? I1 I2)
     (CL:RETURN-FROM CONS-LESS-THAN? CL:T))
    (CL:WHEN (LOGIC-FORM-LESS? I2 I1)
     (CL:RETURN-FROM CONS-LESS-THAN? CL:NIL))
    (CL:SETQ ITER-000 (%%REST ITER-000))
    (CL:SETQ ITER-001 (%%REST ITER-001))))
  (< (LENGTH O1) (LENGTH O2)))

;;; (DEFUN (SAFE-STRING-LESS? BOOLEAN) ...)

(CL:DEFUN SAFE-STRING-LESS? (S1 S2)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S1 S2))
  #+MCL
  (CL:CHECK-TYPE S1 CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE S2 CL:SIMPLE-STRING)
  (CL:COND
   ((CL:AND (CL:NOT (CL:EQ S1 STELLA::NULL-STRING))
     (CL:NOT (CL:EQ S2 STELLA::NULL-STRING)))
    (STRING-LESS? S1 S2))
   ((CL:NOT (CL:EQ S2 STELLA::NULL-STRING)) CL:NIL) (CL:T CL:T)))

;;; (DEFUN (SAFE-QUANTITY-LESS? BOOLEAN) ...)

(CL:DEFUN SAFE-QUANTITY-LESS? (Q1 O2)
  (CL:COND
   ((CL:AND (CL:NOT (CL:EQ Q1 NULL)) (CL:NOT (CL:EQ O2 NULL)))
    (CL:HANDLER-CASE (CL:RETURN-FROM SAFE-QUANTITY-LESS? (LESS? Q1 O2))
     (INCOMPATIBLE-QUANTITY-EXCEPTION () CL:NIL)))
   ((CL:NOT (CL:EQ O2 NULL)) CL:NIL) (CL:T CL:T)))

;;; (DEFUN (SAFE-QUANTITY-GREATER-EQUAL? BOOLEAN) ...)

(CL:DEFUN SAFE-QUANTITY-GREATER-EQUAL? (Q1 O2)
  (CL:COND
   ((CL:AND (CL:NOT (CL:EQ Q1 NULL)) (CL:NOT (CL:EQ O2 NULL)))
    (CL:HANDLER-CASE
     (CL:RETURN-FROM SAFE-QUANTITY-GREATER-EQUAL?
      (GREATER-EQUAL? Q1 O2))
     (INCOMPATIBLE-QUANTITY-EXCEPTION () CL:NIL)))
   ((CL:NOT (CL:EQ O2 NULL)) CL:NIL) (CL:T CL:T)))

;;; (DEFUN (OBJECT-NAME-LESS-THAN? BOOLEAN) ...)

(CL:DEFUN OBJECT-NAME-LESS-THAN? (O1 O2)
  (SAFE-STRING-LESS? (%SYMBOL-NAME (OBJECT-NAME O1))
   (%SYMBOL-NAME (OBJECT-NAME O2))))

;;; (DEFUN (MODULE-NAME-LESS-THAN? BOOLEAN) ...)

(CL:DEFUN MODULE-NAME-LESS-THAN? (M1 M2)
  (SAFE-STRING-LESS? (CONTEXT-NAME M1) (CONTEXT-NAME M2)))

;;; (DEFUN (PROPOSITION-LESS-THAN? BOOLEAN) ...)

(CL:DEFUN PROPOSITION-LESS-THAN? (P1 P2)
  (CL:WHEN
   (STRING-LESS? (%SYMBOL-NAME (%OPERATOR P1))
    (%SYMBOL-NAME (%OPERATOR P2)))
   (CL:RETURN-FROM PROPOSITION-LESS-THAN? CL:T))
  (CL:WHEN
   (STRING-LESS? (%SYMBOL-NAME (%OPERATOR P2))
    (%SYMBOL-NAME (%OPERATOR P1)))
   (CL:RETURN-FROM PROPOSITION-LESS-THAN? CL:NIL))
  (CL:LET*
   ((A1 NULL) (VECTOR-000 (%ARGUMENTS P1)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)) (A2 NULL)
    (VECTOR-001 (%ARGUMENTS P2)) (INDEX-001 0)
    (LENGTH-001 (LENGTH VECTOR-001)))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
   (CL:LOOP WHILE
    (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
    (CL:SETQ A1
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
      INDEX-000))
    (CL:SETQ A2
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
      INDEX-001))
    (CL:IF (LOGIC-FORM-LESS? A1 A2)
     (CL:RETURN-FROM PROPOSITION-LESS-THAN? CL:T)
     (CL:WHEN (LOGIC-FORM-LESS? A2 A1)
      (CL:RETURN-FROM PROPOSITION-LESS-THAN? CL:NIL)))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
    (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
  (< (LENGTH (%ARGUMENTS P1)) (LENGTH (%ARGUMENTS P2))))

;;; (DEFUN (PROPOSITION-HEAD-SORT-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  PROPOSITION-HEAD-SORT-STRING))
(CL:DEFUN PROPOSITION-HEAD-SORT-STRING (P)
  (CL:COND
   ((CL:EQ (%KIND P) KWD-PROPOSITIONS-IMPLIES)
    (CL:IF
     (CL:AND
      (ISA?
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
        0)
       SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
      (ISA?
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
        1)
       SGT-PROPOSITIONS-LOGIC-DESCRIPTION))
     "FORALL" "SUBSET-OF"))
   (CL:T (%SYMBOL-NAME (%OPERATOR P)))))

;;; (DEFUN (OBJECT-SORT-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) OBJECT-SORT-STRING))
(CL:DEFUN OBJECT-SORT-STRING (O)
  (CL:WHEN (CL:EQ O NULL) (CL:RETURN-FROM OBJECT-SORT-STRING "NULL"))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE O)))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000) (CL:PROGN (STRINGIFY O)))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000) (CL:PROGN (STRINGIFY O)))
    ((SUBTYPE-OF-BOOLEAN? TEST-VALUE-000)
     (CL:PROGN
      (CL:COND ((CL:EQ O FALSE-WRAPPER) "FALSE")
       ((CL:EQ O TRUE-WRAPPER) "TRUE") (CL:T "UNKNOWN"))))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000) (CL:PROGN (%WRAPPER-VALUE O)))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-STELLA-MUTABLE-STRING-WRAPPER)
     (CL:PROGN
      (CL:LET ((S (%WRAPPER-VALUE O)))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
       (CL:THE CL:SIMPLE-STRING S))))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-STELLA-GENERALIZED-SYMBOL)
     (CL:PROGN (%SYMBOL-NAME O)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET*
       ((VAL
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE O) (%HOME-CONTEXT O)
          CL:NIL)))
       (CL:IF (CL:OR (CL:EQ VAL NULL) (CL:EQ VAL O)) (STRINGIFY O)
        (OBJECT-SORT-STRING
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE O) (%HOME-CONTEXT O)
          CL:NIL))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN (OBJECT-STRING-NAME O)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-CONTEXT)
     (CL:PROGN (CONTEXT-NAME O)))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-PROPOSITIONS-LOGIC-COMPUTED-PROCEDURE)
     (CL:PROGN (%SYMBOL-NAME (%SURROGATE-VALUE-INVERSE O))))
    (CL:T
     (CL:WHEN (CL:EQ (HOME-MODULE (PRIMARY-TYPE O)) *LOGIC-MODULE*)
      (CL:WARN
       "OBJECT-SORT-STRING: Doesn't specifically handle object `~A' yet!"
       O))
     (STRINGIFY O)))))

;;; (DEFUN (LOGIC-FORM-LESS? BOOLEAN) ...)

(CL:DEFUN LOGIC-FORM-LESS? (O1 O2)
  "A sorting predicate for objects `o1' and `o2' that can appear in logical
forms.  Performs a combined numeric and lexocographic sort that accounts
for lists, collections and propositions.  Numbers precede all other values,
`null' follows all other values."
  (CL:WHEN (CL:EQ O1 O2) (CL:RETURN-FROM LOGIC-FORM-LESS? CL:NIL))
  (CL:WHEN (ISA? O1 SGT-PROPOSITIONS-LOGIC-SKOLEM)
   (CL:LET*
    ((VALUE
      (ACCESS-IN-CONTEXT (%VARIABLE-VALUE O1) (%HOME-CONTEXT O1)
       CL:NIL)))
    (CL:IF (CL:AND (CL:EQ VALUE NULL) (FUNCTION-OUTPUT-SKOLEM? O1))
     (CL:SETQ O1 (%DEFINING-PROPOSITION O1)) (CL:SETQ O1 VALUE))))
  (CL:WHEN (ISA? O2 SGT-PROPOSITIONS-LOGIC-SKOLEM)
   (CL:LET*
    ((VALUE
      (ACCESS-IN-CONTEXT (%VARIABLE-VALUE O2) (%HOME-CONTEXT O2)
       CL:NIL)))
    (CL:IF (CL:AND (CL:EQ VALUE NULL) (FUNCTION-OUTPUT-SKOLEM? O2))
     (CL:SETQ O2 (%DEFINING-PROPOSITION O2)) (CL:SETQ O2 VALUE))))
  (CL:WHEN (CL:EQ O1 NULL) (CL:RETURN-FROM LOGIC-FORM-LESS? CL:NIL))
  (CL:WHEN (CL:EQ O2 NULL) (CL:RETURN-FROM LOGIC-FORM-LESS? CL:T))
  (CL:LET* ((TEST-VALUE-005 (SAFE-PRIMARY-TYPE O1)))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-005)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE O2)))
       (CL:COND
        ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
         (CL:PROGN (< (%WRAPPER-VALUE O1) (%WRAPPER-VALUE O2))))
        ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
         (CL:PROGN (< (%WRAPPER-VALUE O1) (%WRAPPER-VALUE O2))))
        ((SUBTYPE-OF? TEST-VALUE-000
          SGT-PROPOSITIONS-LOGIC-QUANTITY-LOGIC-WRAPPER)
         (CL:PROGN
          (CL:NOT
           (SAFE-QUANTITY-GREATER-EQUAL? (%WRAPPER-VALUE O2) O1))))
        (CL:T CL:T)))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-005)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE O2)))
       (CL:COND
        ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
         (CL:PROGN (< (%WRAPPER-VALUE O1) (%WRAPPER-VALUE O2))))
        ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
         (CL:PROGN (< (%WRAPPER-VALUE O1) (%WRAPPER-VALUE O2))))
        ((SUBTYPE-OF? TEST-VALUE-001
          SGT-PROPOSITIONS-LOGIC-QUANTITY-LOGIC-WRAPPER)
         (CL:PROGN
          (CL:NOT
           (SAFE-QUANTITY-GREATER-EQUAL? (%WRAPPER-VALUE O2) O1))))
        (CL:T CL:T)))))
    ((SUBTYPE-OF? TEST-VALUE-005
      SGT-PROPOSITIONS-LOGIC-QUANTITY-LOGIC-WRAPPER)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE O2)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-002
          SGT-PROPOSITIONS-LOGIC-QUANTITY-LOGIC-WRAPPER)
         (CL:PROGN
          (SAFE-QUANTITY-LESS? (%WRAPPER-VALUE O1)
           (%WRAPPER-VALUE O2))))
        ((SUBTYPE-OF? TEST-VALUE-002
          SGT-PROPOSITIONS-STELLA-NUMBER-WRAPPER)
         (CL:PROGN (LESS? (%WRAPPER-VALUE O1) O2)))
        (CL:T CL:T)))))
    ((SUBTYPE-OF? TEST-VALUE-005 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-003 (SAFE-PRIMARY-TYPE O2)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-003
          SGT-PROPOSITIONS-LOGIC-PROPOSITION)
         (CL:PROGN (PROPOSITION-LESS-THAN? O1 O2)))
        ((SUBTYPE-OF? TEST-VALUE-003
          SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
         (CL:PROGN
          (STRING-LESS? (PROPOSITION-HEAD-SORT-STRING O1)
           (OBJECT-SORT-STRING O2))))
        ((SUBTYPE-OF? TEST-VALUE-003
          SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
         (CL:PROGN (PROPOSITION-LESS-THAN? O1 (%PROPOSITION O2))))
        (CL:T
         (STRING-LESS? (PROPOSITION-HEAD-SORT-STRING O1)
          (OBJECT-SORT-STRING O2)))))))
    ((SUBTYPE-OF? TEST-VALUE-005
      SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-004 (SAFE-PRIMARY-TYPE O2)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-004
          SGT-PROPOSITIONS-LOGIC-PROPOSITION)
         (CL:PROGN
          (STRING-LESS? (OBJECT-SORT-STRING O1)
           (PROPOSITION-HEAD-SORT-STRING O2))))
        ((SUBTYPE-OF? TEST-VALUE-004
          SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
         (CL:PROGN
          (STRING-LESS? (OBJECT-SORT-STRING O1)
           (OBJECT-SORT-STRING O2))))
        ((SUBTYPE-OF? TEST-VALUE-004
          SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
         (CL:PROGN
          (STRING-LESS? (OBJECT-SORT-STRING O1)
           (PROPOSITION-HEAD-SORT-STRING (%PROPOSITION O2)))))
        (CL:T
         (STRING-LESS? (OBJECT-SORT-STRING O1)
          (OBJECT-SORT-STRING O2)))))))
    ((SUBTYPE-OF? TEST-VALUE-005 SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
     (CL:PROGN (LOGIC-FORM-LESS? (%PROPOSITION O1) O2)))
    (CL:T
     (CL:LET* ((TEST-VALUE-006 (SAFE-PRIMARY-TYPE O2)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-006 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
        (CL:PROGN
         (CL:NOT
          (STRING-LESS? (OBJECT-SORT-STRING O1)
           (PROPOSITION-HEAD-SORT-STRING O2)))))
       ((SUBTYPE-OF? TEST-VALUE-006
         SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
        (CL:PROGN
         (STRING-LESS? (OBJECT-SORT-STRING O1)
          (OBJECT-SORT-STRING O2))))
       ((SUBTYPE-OF? TEST-VALUE-006 SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
        (CL:PROGN
         (STRING-LESS? (OBJECT-SORT-STRING O1)
          (PROPOSITION-HEAD-SORT-STRING (%PROPOSITION O2)))))
       (CL:T
        (STRING-LESS? (OBJECT-SORT-STRING O1)
         (OBJECT-SORT-STRING O2)))))))))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS1 ()
  (CL:PROGN
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PROPOSITIONS-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITIONS-INDEX" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-INSTANCES-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INSTANCES-INDEX" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-BACKLINKS-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKLINKS-INDEX" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPENDENT-PROPOSITIONS-LIST" NULL
     0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DEPENDENT-ISA-PROPOSITIONS-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPENDENT-ISA-PROPOSITIONS-LIST"
     NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PREDICATE-PROPOSITIONS-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE-PROPOSITIONS-TABLE" NULL
     0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-BAD?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BAD?"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-HOME-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOME-CONTEXT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-VARIABLE-VALUE-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-VALUE-INVERSE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-SURROGATE-VALUE-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE-INVERSE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-OBJECT-STRINGIFIED-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-STRINGIFIED-SOURCE" NULL
     0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-OBJECT-ORIGINATED-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-ORIGINATED-PROPOSITIONS"
     NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-CS-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CS-VALUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-DELETED-OBJECT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DELETED-OBJECT?"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-LOGIC-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-THING" NULL 1))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SKOLEM-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM-TYPE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SKOLEM-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM-NAME" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-VARIABLE-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-VALUE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DEFINING-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINING-PROPOSITION" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-BOUND-TO-OFFSET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOUND-TO-OFFSET" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-VARIABLE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-NAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-OBJECT-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-VECTOR" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-ARGUMENTS-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS-VECTOR" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-VARIABLES-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLES-VECTOR" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-CHAINING-INDEX" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-FORWARD-GOAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-GOAL" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-MASTER-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-RULE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-QUERY-BODY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-BODY" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-INPUT-BINDINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-BINDINGS" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CACHE-ID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHE-ID" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CONSEQUENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSEQUENT" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDICES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-CHAINING-INDICES" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DEFERRED-CONTRAPOSITIVES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFERRED-CONTRAPOSITIVES?" NULL
     0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-INTERNAL-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERNAL-VARIABLES" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-QUERY-PATTERNS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-PATTERNS" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-RELATIVE-COMPLEMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATIVE-COMPLEMENT" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-COMPLEMENT-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT-DESCRIPTION" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-NATIVE-RELATION-BACK-POINTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-RELATION-BACK-POINTER" NULL
     0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-IO-VARIABLE-NAMES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLE-NAMES" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-IO-VARIABLE-TYPES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLE-TYPES" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-EXTENSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PARTIAL-MATCH-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL-MATCH-SCORE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SET-OF-SUPPORT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-OF-SUPPORT" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMESTAMP" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-UNKNOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-POLARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POLARITY" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-STRENGTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRENGTH" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-POSITIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITIVE-SCORE" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-PARTIAL-SUPPORT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL-SUPPORT" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-FACT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FACT" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-AXIOM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AXIOM" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCORE" NULL 0))))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS2 ()
  (CL:PROGN
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-ID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ID" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-ARGUMENT-SCORES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-SCORES" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-VARIABLE-TYPE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE?" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SATELLITE-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SATELLITE-PROPOSITIONS" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-UNFASTENED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNFASTENED?" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-WEIGHT-DELTA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WEIGHT-DELTA" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SUPPORT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPPORT" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-KIND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KIND" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-OPERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPERATOR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-RELATIONREF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATIONREF" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPENDENT-PROPOSITIONS" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PROPOSITION-ORIGINATED-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "PROPOSITION-ORIGINATED-PROPOSITIONS" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PROPOSITION-STRINGIFIED-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION-STRINGIFIED-SOURCE"
     NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-QUANTITY-LOGIC-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUANTITY-LOGIC-WRAPPER" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-WRAPPER-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAPPER-VALUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-FUNCTION-TERM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-TERM" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-INTEGER-LOGIC-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-LOGIC-WRAPPER" NULL 1))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-FLOAT-LOGIC-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT-LOGIC-WRAPPER" NULL 1))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-STRING-LOGIC-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-LOGIC-WRAPPER" NULL 1))
   (CL:SETQ KWD-PROPOSITIONS-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PROPOSITIONS-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PROPOSITIONS-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PROPOSITIONS-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PROPOSITIONS-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PROPOSITIONS-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PROPOSITIONS-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PROPOSITIONS-COLLECT-INTO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-INTO" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-COLLECT-INTO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-INTO"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PROPOSITIONS-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DESCRIPTIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTIVE?" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-CODE-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CODE-ONLY?"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-PROPOSITIONS-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ
    SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-PROPOSITIONS-INTERNAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "LOCALLY-CONCEIVED-PROPOSITIONS-INTERNAL" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-PAGING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PAGING" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-CONTEXT-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-PROPOSITIONS" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-INSTANCES-INTERNAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "LOCALLY-CONCEIVED-INSTANCES-INTERNAL" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-CONTEXT-INSTANCES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-INSTANCES" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-UPDATE-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UPDATE-PROPOSITION" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-EXECUTE-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXECUTE-QUERY" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-BOTTOM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOTTOM" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-LITERAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ
    SGT-PROPOSITIONS-LOGIC-F-LOGICAL-SUBTYPE-OF-LITERAL?-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-LOGICAL-SUBTYPE-OF-LITERAL?-MEMO-TABLE-000" NULL 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-BOOLEAN-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS3 ()
  (CL:PROGN
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-VARIABLE-ARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-ARITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION-COMPUTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-COMPUTATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIONAL-ASSERTION" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-DEVELOPMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEVELOPMENT" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-WARNING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARNING" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-RETRACT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-TRUE" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-UPDATE-PROPOSITION-DEMON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UPDATE-PROPOSITION-DEMON"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-OBJECT-STORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-STORE" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-TRUE-DEMON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOES-TRUE-DEMON"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PROPOSITIONS-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-FALSE-DEMON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOES-FALSE-DEMON"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-UNKNOWN-DEMON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOES-UNKNOWN-DEMON"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-MASTER-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-ASSERT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-PRESUME-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRESUME-TRUE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-ASSERT-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-FALSE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-PRESUME-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRESUME-FALSE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-RETRACT-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-FALSE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-ASSERT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-RETRACT-INCONSISTENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-INCONSISTENT" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-RETRACT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-CONCEIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEIVE" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-HIDDEN-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HIDDEN-RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-HIDDEN-INSTANCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HIDDEN-INSTANCE" NULL 1))
   (CL:SETQ KWD-PROPOSITIONS-KB-UPDATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KB-UPDATE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-META-KB-UPDATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-KB-UPDATE" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-STORAGE-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT-VALUE" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-STRICT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRICT" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-DEFAULT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULT" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-INCONSISTENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INCONSISTENT" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-META-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-INFERENCE-CACHE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-MAINTAINED-INFERENCE-CACHE"
     NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-IOTA?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IOTA?" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-CONCEPT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEPT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-INTERVAL-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL-CACHE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB->=
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">="
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CONFLICTING-DEFAULT-VALUES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONFLICTING-DEFAULT-VALUES" NULL
     0))
   (CL:SETQ KWD-PROPOSITIONS-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SETOFALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOFALL" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-THE-ONLY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-ONLY" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-KAPPA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CREATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CREATE" NULL 0))))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS4 ()
  (CL:PROGN
   (CL:SETQ SGT-PROPOSITIONS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-PROPOSITIONS-INTENSIONAL-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTENSIONAL-ASSERTION" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-PROPOSITIONS-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-CLASS-EXTENSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-EXTENSION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ
    SYM-PROPOSITIONS-LOGIC-TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SUBRELATION-LINK?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBRELATION-LINK?" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PROPOSITIONS-DISABLED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISABLED" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-ANNOTATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANNOTATIONS" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "="
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-PL-KERNEL-KB-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-COLLECT-INTO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-INTO"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-ABOUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABOUT" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-PROPOSITIONS-DIRECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTION" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-FORWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-ONLY?" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-BACKWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD-ONLY?" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-WEIGHT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WEIGHT" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-WEIGHT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WEIGHT" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-CONFIDENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONFIDENCE-LEVEL" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-SETOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOF"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-LISTOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISTOF" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TABLE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-POLYMORPHIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POLYMORPHIC"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-PROPOSITIONS-PL-KERNEL-KB-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-PL-KERNEL-KB-CUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CUT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-QUANTITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUANTITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-DATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DATE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-PROPOSITIONS-AUTOMATICALLY-FIX-TYPE-VIOLATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AUTOMATICALLY-FIX-TYPE-VIOLATIONS"
     NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-POST-TYPE-VIOLATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POST-TYPE-VIOLATIONS" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-IGNORE-TYPE-VIOLATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IGNORE-TYPE-VIOLATIONS" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-REPORT-TYPE-VIOLATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REPORT-TYPE-VIOLATIONS" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-SIGNAL-TYPE-VIOLATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIGNAL-TYPE-VIOLATIONS" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-ASSERTED-BY-TYPE-CHECKER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERTED-BY-TYPE-CHECKER?" NULL
     0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-CHECK-TYPES-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHECK-TYPES-RECORD" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PARENT-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT-PROPOSITION" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PARENT-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT-DESCRIPTION" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-PROPOSITIONS-MEDIUM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEDIUM" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-REALISTIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REALISTIC" NULL 2))))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS5 ()
  (CL:PROGN
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-SETOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-TOTAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOTAL"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-LISTOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISTOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-LAMBDA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LAMBDA" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-PL-KERNEL-KB-SETOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-PL-KERNEL-KB-LISTOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISTOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-BAGOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BAGOF" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-ASSERT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PRESUME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRESUME" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-CPP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-RETRACT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DENY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DENY" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-CONCEIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEIVE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-UNASSERT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNASSERT" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-DELETED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DELETED" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DESTROY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESTROY" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-INTRODUCE-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTRODUCE-MODULE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CLEAR-LOGIC-MODULE-HOOK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEAR-LOGIC-MODULE-HOOK" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CLEAR-INSTANCES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEAR-INSTANCES" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-MONOTONIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MONOTONIC?" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-WORLD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DESTROY-LOGIC-CONTEXT-HOOK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESTROY-LOGIC-CONTEXT-HOOK" NULL
     0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-CLEARABLE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEARABLE?"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-PROTECT-SURROGATES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROTECT-SURROGATES?"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-PROPOSITIONS-PREORDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREORDER" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-MUTABLE-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTABLE-STRING-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-COMPUTED-PROCEDURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPUTED-PROCEDURE" NULL 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-NUMBER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-STARTUP-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-PROPOSITIONS" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS6 ()
  (CL:PROGN (CL:SETQ ZERO-VARIABLES-VECTOR (NEW-VECTOR 0))
   (CL:LET* ((SELF-003 (NEW-PROPERTY-LIST)))
    (CL:SETF (%THE-PLIST SELF-003)
     (LIST* KWD-PROPOSITIONS-AND SGT-PROPOSITIONS-PL-KERNEL-KB-AND
      KWD-PROPOSITIONS-OR SGT-PROPOSITIONS-PL-KERNEL-KB-OR
      KWD-PROPOSITIONS-NOT SGT-PROPOSITIONS-PL-KERNEL-KB-NOT
      KWD-PROPOSITIONS-FORALL SGT-PROPOSITIONS-PL-KERNEL-KB-FORALL
      KWD-PROPOSITIONS-EXISTS SGT-PROPOSITIONS-PL-KERNEL-KB-EXISTS
      KWD-PROPOSITIONS-EQUIVALENT
      SGT-PROPOSITIONS-PL-KERNEL-KB-EQUIVALENT KWD-PROPOSITIONS-FAIL
      SGT-PROPOSITIONS-PL-KERNEL-KB-FAIL KWD-PROPOSITIONS-COLLECT-INTO
      SGT-PROPOSITIONS-PL-KERNEL-KB-COLLECT-INTO
      KWD-PROPOSITIONS-IMPLIES SGT-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF
      NIL))
    (CL:SETQ *OPERATOR-NAME-TO-SURROGATE-TABLE* SELF-003))
   (CL:SETQ *LOGIC-MODULE* (GET-STELLA-MODULE "LOGIC" CL:T))
   (CL:SETQ *PL-KERNEL-MODULE* (GET-STELLA-MODULE "PL-KERNEL" CL:T))
   (CL:SETQ *LAST-KB-ACTION* KWD-PROPOSITIONS-UPDATE-PROPOSITION)
   (CL:SETQ *EVALUATIONMODE* KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION)
   (CL:LET* ((SELF-004 (NEW-TRUTH-VALUE)))
    (CL:SETF (%POLARITY SELF-004) KWD-PROPOSITIONS-TRUE)
    (CL:SETF (%STRENGTH SELF-004) KWD-PROPOSITIONS-STRICT)
    (CL:SETF (%POSITIVE-SCORE SELF-004) 1.0d0)
    (CL:SETQ TRUE-TRUTH-VALUE SELF-004))
   (CL:LET* ((SELF-005 (NEW-TRUTH-VALUE)))
    (CL:SETF (%POLARITY SELF-005) KWD-PROPOSITIONS-FALSE)
    (CL:SETF (%STRENGTH SELF-005) KWD-PROPOSITIONS-STRICT)
    (CL:SETF (%POSITIVE-SCORE SELF-005) -1.0d0)
    (CL:SETQ FALSE-TRUTH-VALUE SELF-005))
   (CL:LET* ((SELF-006 (NEW-TRUTH-VALUE)))
    (CL:SETF (%POLARITY SELF-006) KWD-PROPOSITIONS-TRUE)
    (CL:SETF (%STRENGTH SELF-006) KWD-PROPOSITIONS-DEFAULT)
    (CL:SETF (%POSITIVE-SCORE SELF-006) 0.8d0)
    (CL:SETQ DEFAULT-TRUE-TRUTH-VALUE SELF-006))
   (CL:LET* ((SELF-007 (NEW-TRUTH-VALUE)))
    (CL:SETF (%POLARITY SELF-007) KWD-PROPOSITIONS-FALSE)
    (CL:SETF (%STRENGTH SELF-007) KWD-PROPOSITIONS-DEFAULT)
    (CL:SETF (%POSITIVE-SCORE SELF-007) -0.8d0)
    (CL:SETQ DEFAULT-FALSE-TRUTH-VALUE SELF-007))
   (CL:LET* ((SELF-008 (NEW-TRUTH-VALUE)))
    (CL:SETF (%POLARITY SELF-008) KWD-PROPOSITIONS-UNKNOWN)
    (CL:SETQ UNKNOWN-TRUTH-VALUE SELF-008))
   (CL:LET* ((SELF-009 (NEW-TRUTH-VALUE)))
    (CL:SETF (%POLARITY SELF-009) KWD-PROPOSITIONS-INCONSISTENT)
    (CL:SETF (%STRENGTH SELF-009) KWD-PROPOSITIONS-STRICT)
    (CL:SETQ INCONSISTENT-TRUTH-VALUE SELF-009))
   (CL:LET* ((SELF-010 (NEW-PROPOSITION)))
    (CL:SETF (%KIND SELF-010) KWD-PROPOSITIONS-CONSTANT)
    (CL:SETF (%OPERATOR SELF-010) SGT-PROPOSITIONS-STELLA-TRUE)
    (CL:SETF (%ARGUMENTS SELF-010) (NEW-VECTOR 0))
    (CL:LET*
     ((OBJECT-012 SELF-010) (VALUE-013 TRUE-TRUTH-VALUE)
      (OLD-VALUE-014 (%TRUTH-VALUE OBJECT-012))
      (NEW-VALUE-015
       (UPDATE-IN-CONTEXT OLD-VALUE-014 VALUE-013
        (%HOME-CONTEXT OBJECT-012) CL:NIL)))
     (CL:WHEN
      (CL:NOT
       (CL:AND (CL:NOT (CL:EQ OLD-VALUE-014 NULL))
        (CL:EQ (PRIMARY-TYPE OLD-VALUE-014)
         SGT-PROPOSITIONS-STELLA-CS-VALUE)))
      (CL:SETF (%TRUTH-VALUE OBJECT-012) NEW-VALUE-015)))
    (CL:SETQ TRUE-PROPOSITION SELF-010))
   (CL:LET* ((SELF-016 (NEW-PROPOSITION)))
    (CL:SETF (%KIND SELF-016) KWD-PROPOSITIONS-CONSTANT)
    (CL:SETF (%OPERATOR SELF-016) SGT-PROPOSITIONS-STELLA-FALSE)
    (CL:SETF (%ARGUMENTS SELF-016) (NEW-VECTOR 0))
    (CL:LET*
     ((OBJECT-018 SELF-016) (VALUE-019 FALSE-TRUTH-VALUE)
      (OLD-VALUE-020 (%TRUTH-VALUE OBJECT-018))
      (NEW-VALUE-021
       (UPDATE-IN-CONTEXT OLD-VALUE-020 VALUE-019
        (%HOME-CONTEXT OBJECT-018) CL:NIL)))
     (CL:WHEN
      (CL:NOT
       (CL:AND (CL:NOT (CL:EQ OLD-VALUE-020 NULL))
        (CL:EQ (PRIMARY-TYPE OLD-VALUE-020)
         SGT-PROPOSITIONS-STELLA-CS-VALUE)))
      (CL:SETF (%TRUTH-VALUE OBJECT-018) NEW-VALUE-021)))
    (CL:SETQ FALSE-PROPOSITION SELF-016))
   (CL:SETQ ANONYMOUS-VARIABLE-NAME SYM-PROPOSITIONS-STELLA-?)
   (CL:SETQ *MISSING-KEY-VALUE-LIST* (NEW-KEY-VALUE-LIST))
   (CL:SETQ *AUTOMATICINSTANCETABLE* *MISSING-KEY-VALUE-LIST*)
   (CL:SETQ *STRUCTURED-OBJECTS-INDEX* (NEW-KEY-VALUE-MAP))
   (CL:SETQ *TYPE-CHECK-POLICY*
    KWD-PROPOSITIONS-AUTOMATICALLY-FIX-TYPE-VIOLATIONS)
   (CL:SETQ *TYPECHECKMODE* KWD-PROPOSITIONS-POST-TYPE-VIOLATIONS)
   (CL:SETQ *CHECK-TYPES-AGENDA* (NEW-KEY-VALUE-LIST))))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS7 ()
  (CL:PROGN
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE PROPOSITIONS-INDEX (SEQUENCE-INDEX OF PROPOSITION))")
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE INSTANCES-INDEX (SEQUENCE-INDEX OF LOGIC-OBJECT))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "BACKLINKS-INDEX"
       "(DEFCLASS BACKLINKS-INDEX (STANDARD-OBJECT) :DOCUMENTATION \"Contains several types of indices pointing at dependent propositions.\" :SLOTS ((DEPENDENT-PROPOSITIONS-LIST :TYPE PROPOSITIONS-INDEX) (DEPENDENT-ISA-PROPOSITIONS-LIST :TYPE PROPOSITIONS-INDEX) (PREDICATE-PROPOSITIONS-TABLE :TYPE (HASH-TABLE OF SURROGATE PROPOSITIONS-INDEX))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-BACKLINKS-INDEX))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-BACKLINKS-INDEX-SLOT-VALUE)))
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "BACKLINKS-MIXIN"
    "(DEFCLASS BACKLINKS-MIXIN () :DOCUMENTATION \"Inherited by objects that point back at propositions that reference
them.\" :SLOTS ((DEPENDENT-PROPOSITIONS-INDEX :TYPE BACKLINKS-INDEX)) :MIXIN? TRUE)")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "LOGIC-OBJECT"
       "(DEFCLASS LOGIC-OBJECT (CONTEXT-SENSITIVE-OBJECT DYNAMIC-SLOTS-MIXIN BACKLINKS-MIXIN) :DOCUMENTATION \"Object with propositions, and possibly a variable value.\" :PUBLIC-SLOTS ((HOME-CONTEXT :INITIALLY *MODULE*) (VARIABLE-VALUE-INVERSE :TYPE (CONS OF LOGIC-OBJECT) :DEFAULT NIL :CONTEXT-SENSITIVE? TRUE) (EQUIVALENT-VALUE :TYPE DESCRIPTION :CONTEXT-SENSITIVE? TRUE :ALLOCATION :DYNAMIC) (SURROGATE-VALUE-INVERSE :TYPE SURROGATE) (UNDECLARED? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (HYPOTHESIZED-INSTANCE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (OBJECT-STRINGIFIED-SOURCE :TYPE STRING :ALLOCATION :DYNAMIC :READER STRINGIFIED-SOURCE :WRITER STRINGIFIED-SOURCE-SETTER) (OBJECT-ORIGINATED-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :DEFAULT NIL-LIST :ALLOCATION :DYNAMIC :READER ORIGINATED-PROPOSITIONS :WRITER ORIGINATED-PROPOSITIONS-SETTER :DOCUMENTATION \"List of propositions generated by the definition of
this object.\")) :PRINT-FORM (PRINT-TOP-LEVEL-OBJECT SELF STREAM) :INITIALIZER LOG-LOGIC-OBJECT)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-LOGIC-OBJECT))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-LOGIC-OBJECT-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "LOGIC-THING"
       "(DEFCLASS LOGIC-THING (THING) :DOCUMENTATION \"A subclass of THING so we can add methods to it in
the PowerLoom LOGIC module.\")")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-LOGIC-THING)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SKOLEM"
       "(DEFCLASS SKOLEM (LOGIC-OBJECT) :DOCUMENTATION \"Object whose identity and type are not fixed at creation time.
Potentially unifiable with any other object.\" :PUBLIC-SLOTS ((SKOLEM-TYPE :TYPE TYPE) (SKOLEM-NAME :TYPE SYMBOL) (VARIABLE-VALUE :TYPE OBJECT :CONTEXT-SENSITIVE? TRUE) (DEFINING-PROPOSITION :TYPE PROPOSITION)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-SKOLEM))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-SKOLEM-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PATTERN-VARIABLE"
       "(DEFCLASS PATTERN-VARIABLE (SKOLEM) :DOCUMENTATION \"A variable in a logical expression.\" :SLOTS ((BOUND-TO-OFFSET :TYPE INTEGER) (ORIGINAL-SKOLEM-NAME :TYPE SYMBOL :ALLOCATION :DYNAMIC) (VARIABLE-NAME :RENAMES SKOLEM-NAME)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PATTERN-VARIABLE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PATTERN-VARIABLE-SLOT-VALUE)))
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE OBJECT-VECTOR (VECTOR OF OBJECT))")
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE ARGUMENTS-VECTOR OBJECT-VECTOR)")
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE VARIABLES-VECTOR (VECTOR OF PATTERN-VARIABLE))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FORWARD-CHAINING-INDEX"
       "(DEFCLASS FORWARD-CHAINING-INDEX (STANDARD-OBJECT) :SLOTS ((FORWARD-GOAL :TYPE PROPOSITION) (MASTER-RULE :TYPE PROPOSITION) (IO-VARIABLES :TYPE CONS) (QUERY-BODY :TYPE CONS) (INPUT-BINDINGS :TYPE CONS) (CACHE-ID :TYPE SYMBOL) (CONSEQUENT :TYPE DESCRIPTION)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-FORWARD-CHAINING-INDEX))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-FORWARD-CHAINING-INDEX-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "DESCRIPTION"
       "(DEFCLASS DESCRIPTION (LOGIC-OBJECT) :PUBLIC-SLOTS ((PROPOSITION :TYPE PROPOSITION) (IO-VARIABLES :TYPE VARIABLES-VECTOR) (INTERNAL-VARIABLES :TYPE VARIABLES-VECTOR :INITIALLY ZERO-VARIABLES-VECTOR :DOCUMENTATION \"The set of internally quantified variables besides the
descriptions's IO variables.  This set includes any top-level implicit
existential variables plus any variables introduced by some nested quantifier.
IMPORTANT: therefore, a description's internal variables are not necessarily
equivalent to its top-level implicit existential variables.\") (EXTERNAL-VARIABLES :TYPE VARIABLES-VECTOR :ALLOCATION :DYNAMIC) (QUERY-PATTERNS :TYPE (KEY-VALUE-LIST OF BOOLEAN-VECTOR DESCRIPTION)) (COMPLEMENT-DESCRIPTION :TYPE DESCRIPTION :ALLOCATION :DYNAMIC) (RELATIVE-COMPLEMENT :RENAMES COMPLEMENT-DESCRIPTION) (TAXONOMY-NODE :TYPE TAXONOMY-NODE :ALLOCATION :DYNAMIC) (IOTA? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (DONT-OPTIMIZE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (FORWARD-CHAINING-INDICES :TYPE (LIST OF FORWARD-CHAINING-INDEX) :ALLOCATION :DYNAMIC) (RULES-WITH-DEFERRED-SATELLITES :TYPE PROPOSITIONS-INDEX :ALLOCATION :DYNAMIC) (DEFERRED-CONTRAPOSITIVES? :TYPE BOOLEAN-WRAPPER :ALLOCATION :DYNAMIC :DEFAULT FALSE)) :METHODS ((NATIVE-RELATION ((SELF DESCRIPTION)) :TYPE RELATION (RETURN NULL))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-DESCRIPTION))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-DESCRIPTION-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NAMED-DESCRIPTION"
       "(DEFCLASS NAMED-DESCRIPTION (DESCRIPTION) :PUBLIC-SLOTS ((IO-VARIABLE-NAMES :TYPE (LIST OF SYMBOL)) (IO-VARIABLE-TYPES :TYPE (LIST OF TYPE)) (EXTENSION :TYPE PROPOSITIONS-INDEX) (OBJECT-STRINGIFIED-SOURCE :ALLOCATION :INSTANCE) (OBJECT-ORIGINATED-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :DEFAULT NIL-LIST :ALLOCATION :INSTANCE :DOCUMENTATION \"List of propositions generated by the definition of
this description.\") (NATIVE-RELATION-BACK-POINTER :TYPE RELATION :ALLOCATION :DYNAMIC) (CHECK-FOR-CACHED-GOALS? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (INVERSE-DESCRIPTION :TYPE NAMED-DESCRIPTION :ALLOCATION :DYNAMIC)) :METHODS ((NATIVE-RELATION ((SELF NAMED-DESCRIPTION)) :TYPE RELATION (RETURN (NATIVE-RELATION-BACK-POINTER SELF))) (NATIVE-RELATION-SETTER ((SELF NAMED-DESCRIPTION) (VALUE RELATION)) (SETF (NATIVE-RELATION-BACK-POINTER SELF) VALUE))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-NAMED-DESCRIPTION))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-NAMED-DESCRIPTION-SLOT-VALUE)))
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE PARTIAL-MATCH-SCORE FLOAT)")
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE SET-OF-SUPPORT LIST)")
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE TIMESTAMP INTEGER)")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TRUTH-VALUE"
       "(DEFCLASS TRUTH-VALUE (LOGIC-OBJECT) :PUBLIC-SLOTS ((POLARITY :TYPE KEYWORD :INITIALLY :UNKNOWN :DOCUMENTATION \"One of :TRUE, :FALSE, :UNKNOWN or :INCONSISTENT.\") (STRENGTH :TYPE KEYWORD :INITIALLY NULL :DOCUMENTATION \"Either NULL, :STRICT or :DEFAULT.\") (POSITIVE-SCORE :TYPE PARTIAL-MATCH-SCORE :INITIALLY 0.0)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-TRUTH-VALUE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-TRUTH-VALUE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PARTIAL-SUPPORT"
       "(DEFCLASS PARTIAL-SUPPORT (STANDARD-OBJECT) :PUBLIC-SLOTS ((FACT :TYPE PROPOSITION) (AXIOM :TYPE PROPOSITION) (SCORE :TYPE FLOAT) (ID :TYPE INTEGER) (ARGUMENT-SCORES :TYPE (CONS OF FLOAT-WRAPPER))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PARTIAL-SUPPORT))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PARTIAL-SUPPORT-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PROPOSITION"
       "(DEFCLASS PROPOSITION (CONTEXT-SENSITIVE-OBJECT DYNAMIC-SLOTS-MIXIN BACKLINKS-MIXIN) :DOCUMENTATION \"\" :PUBLIC-SLOTS ((HOME-CONTEXT :INITIALLY *MODULE*) (KIND :TYPE KEYWORD) (TRUTH-VALUE :TYPE TRUTH-VALUE :CONTEXT-SENSITIVE? TRUE) (ARGUMENTS :TYPE VECTOR) (OPERATOR :TYPE GENERALIZED-SYMBOL) (RELATIONREF :TYPE SURROGATE :RENAMES OPERATOR) (DEPENDENT-PROPOSITIONS :TYPE (NON-PAGING-INDEX OF PROPOSITION) :INITIALLY NIL-NON-PAGING-INDEX) (SURROGATE-VALUE-INVERSE :TYPE SURROGATE :ALLOCATION :DYNAMIC) (IO-VARIABLES :TYPE VARIABLES-VECTOR :ALLOCATION :DYNAMIC) (VARIABLE-TYPE? :TYPE BOOLEAN-WRAPPER :ALLOCATION :DYNAMIC :DEFAULT FALSE) (ASSERTED-BY-TYPE-CHECKER? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (DESCRIPTIVE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (SUBRELATION-LINK? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (SUBSUMPTION-LINK? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (SATELLITE-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :ALLOCATION :DYNAMIC) (MASTER-PROPOSITION :TYPE PROPOSITION :ALLOCATION :DYNAMIC) (PROPOSITION-ORIGINATED-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :DEFAULT NIL-LIST :ALLOCATION :DYNAMIC :READER ORIGINATED-PROPOSITIONS :WRITER ORIGINATED-PROPOSITIONS-SETTER :DOCUMENTATION \"List of propositions generated by the definition of
this proposition.\") (DONT-OPTIMIZE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :OPTION-KEYWORD :DONT-OPTIMIZE?) (FORWARD-ONLY? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :OPTION-KEYWORD :FORWARD-ONLY?) (BACKWARD-ONLY? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :OPTION-KEYWORD :BACKWARD-ONLY?) (PROPOSITION-STRINGIFIED-SOURCE :TYPE STRING :ALLOCATION :DYNAMIC :READER STRINGIFIED-SOURCE :WRITER STRINGIFIED-SOURCE-SETTER) (UNFASTENED? :TYPE BOOLEAN-WRAPPER :ALLOCATION :DYNAMIC :DEFAULT FALSE) (ANNOTATIONS :TYPE (PROPERTY-LIST OF KEYWORD OBJECT) :ALLOCATION :DYNAMIC) (WEIGHT :TYPE FLOAT :ALLOCATION :DYNAMIC) (NEURAL-NETWORK :TYPE PROPOSITION-NEURAL-NETWORK :ALLOCATION :DYNAMIC) (WEIGHT-DELTA :TYPE FLOAT :DEFAULT 0.0 :ALLOCATION :DYNAMIC) (MATCH-SCORE :TYPE FLOAT :ALLOCATION :DYNAMIC) (SUPPORT :TYPE (CONS OF PARTIAL-SUPPORT) :ALLOCATION :DYNAMIC)) :PRINT-FORM (PRINT-TOP-LEVEL-OBJECT SELF STREAM))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PROPOSITION))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PROPOSITION-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "QUANTITY-LOGIC-WRAPPER"
       "(DEFCLASS QUANTITY-LOGIC-WRAPPER (LOGIC-THING) :PUBLIC? TRUE :PUBLIC-SLOTS ((WRAPPER-VALUE :TYPE QUANTITY :REQUIRED? TRUE) (FUNCTION-TERM :TYPE CONS)) :PRINT-FORM (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM (WRAPPER-VALUE SELF)) (PRINT-NATIVE-STREAM STREAM \"|Q|\" (WRAPPER-VALUE SELF))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-QUANTITY-LOGIC-WRAPPER))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-QUANTITY-LOGIC-WRAPPER-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INTEGER-LOGIC-WRAPPER"
       "(DEFCLASS INTEGER-LOGIC-WRAPPER (INTEGER-WRAPPER BACKLINKS-MIXIN) :PRINT-FORM (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM (WRAPPER-VALUE SELF)) (PRINT-NATIVE-STREAM STREAM \"|W|\" (WRAPPER-VALUE SELF))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-INTEGER-LOGIC-WRAPPER)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FLOAT-LOGIC-WRAPPER"
       "(DEFCLASS FLOAT-LOGIC-WRAPPER (FLOAT-WRAPPER BACKLINKS-MIXIN) :PRINT-FORM (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM (WRAPPER-VALUE SELF)) (PRINT-NATIVE-STREAM STREAM \"|W|\" (WRAPPER-VALUE SELF))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-FLOAT-LOGIC-WRAPPER)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STRING-LOGIC-WRAPPER"
       "(DEFCLASS STRING-LOGIC-WRAPPER (STRING-WRAPPER BACKLINKS-MIXIN) :PRINT-FORM (LET ((VALUE (WRAPPER-VALUE SELF))) (IF *PRINTREADABLY?* (PRINT-STRING-READABLY VALUE STREAM) (IF (DEFINED? VALUE) (PRINT-NATIVE-STREAM STREAM \"|W|\" #\\\" VALUE #\\\") (PRINT-NATIVE-STREAM STREAM \"|W|\" \"NULL-STRING\")))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-STRING-LOGIC-WRAPPER)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "OBJECT-ALREADY-EXISTS-EXCEPTION"
       "(DEFCLASS OBJECT-ALREADY-EXISTS-EXCEPTION (STELLA-EXCEPTION) :PUBLIC? TRUE :PUBLIC-SLOTS ((EXISTING-OBJECT :TYPE OBJECT)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-OBJECT-ALREADY-EXISTS-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CHECK-TYPES-RECORD"
       "(DEFCLASS CHECK-TYPES-RECORD (STANDARD-OBJECT) :SLOTS ((PARENT-PROPOSITION :TYPE OBJECT) (PARENT-DESCRIPTION :TYPE DESCRIPTION) (MODULE :TYPE MODULE)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-CHECK-TYPES-RECORD))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-CHECK-TYPES-RECORD-SLOT-VALUE)))))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS8 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "LOG-LOGIC-OBJECT"
    "(DEFUN LOG-LOGIC-OBJECT ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION LOG-LOGIC-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "STRINGIFIED-SOURCE"
    "(DEFUN (STRINGIFIED-SOURCE STRING) ((SELF OBJECT)))"
    (CL:FUNCTION STRINGIFIED-SOURCE) NULL)
   (DEFINE-FUNCTION-OBJECT "STRINGIFIED-SOURCE-SETTER"
    "(DEFUN (STRINGIFIED-SOURCE-SETTER STRING) ((SELF OBJECT) (VALUE STRING)))"
    (CL:FUNCTION STRINGIFIED-SOURCE-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "ORIGINATED-PROPOSITIONS"
    "(DEFUN (ORIGINATED-PROPOSITIONS (LIST OF PROPOSITION)) ((SELF OBJECT)))"
    (CL:FUNCTION ORIGINATED-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ORIGINATED-PROPOSITIONS-SETTER"
    "(DEFUN (ORIGINATED-PROPOSITIONS-SETTER (LIST OF PROPOSITION)) ((SELF OBJECT) (VALUE (LIST OF PROPOSITION))))"
    (CL:FUNCTION ORIGINATED-PROPOSITIONS-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-PROPOSITION"
    "(DEFUN (CREATE-PROPOSITION PROPOSITION) ((KIND SYMBOL) (ARGUMENTCOUNT INTEGER)))"
    (CL:FUNCTION CREATE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "ENFORCE-CODE-ONLY"
    "(DEFUN ENFORCE-CODE-ONLY ())" (CL:FUNCTION ENFORCE-CODE-ONLY)
    NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT CONTEXT MONOTONIC? :TYPE BOOLEAN :PUBLIC? TRUE :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT WORLD TRUTH-MAINTAINED? :TYPE BOOLEAN :PUBLIC? TRUE :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT WORLD UP-TO-DATE-INFERENCES? :TYPE BOOLEAN :PUBLIC? TRUE :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "LOGIC-MODULE?"
    "(DEFUN (LOGIC-MODULE? BOOLEAN) ((SELF MODULE)) :DOCUMENTATION \"Return TRUE if 'self' is a logic module, implying
that relations defined within it define a knowledge base.  A module
is a logic module iff it inherits the module 'PL-KERNEL'.\")"
    (CL:FUNCTION LOGIC-MODULE?) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT MODULE LOCALLY-CONCEIVED-PROPOSITIONS-INTERNAL :TYPE PROPOSITIONS-INDEX :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "LOCALLY-CONCEIVED-PROPOSITIONS"
    "(DEFUN (LOCALLY-CONCEIVED-PROPOSITIONS PROPOSITIONS-INDEX) ((SELF MODULE)))"
    (CL:FUNCTION LOCALLY-CONCEIVED-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "LOCALLY-CONCEIVED-PROPOSITIONS-SETTER"
    "(DEFUN LOCALLY-CONCEIVED-PROPOSITIONS-SETTER ((SELF MODULE) (VALUE PROPOSITIONS-INDEX)))"
    (CL:FUNCTION LOCALLY-CONCEIVED-PROPOSITIONS-SETTER) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT CONTEXT LOCALLY-CONCEIVED-INSTANCES-INTERNAL :TYPE INSTANCES-INDEX :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "LOCALLY-CONCEIVED-INSTANCES"
    "(DEFUN (LOCALLY-CONCEIVED-INSTANCES INSTANCES-INDEX) ((SELF CONTEXT)))"
    (CL:FUNCTION LOCALLY-CONCEIVED-INSTANCES) NULL)
   (DEFINE-FUNCTION-OBJECT "LOCALLY-CONCEIVED-INSTANCES-SETTER"
    "(DEFUN LOCALLY-CONCEIVED-INSTANCES-SETTER ((SELF CONTEXT) (VALUE INSTANCES-INDEX)))"
    (CL:FUNCTION LOCALLY-CONCEIVED-INSTANCES-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "INCREMENT-NOW-TIMESTAMP"
    "(DEFUN INCREMENT-NOW-TIMESTAMP ())"
    (CL:FUNCTION INCREMENT-NOW-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-NOW-TIMESTAMP"
    "(DEFUN (GET-NOW-TIMESTAMP TIMESTAMP) ())"
    (CL:FUNCTION GET-NOW-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-NOW-TIMESTAMP"
    "(DEFUN UPDATE-NOW-TIMESTAMP ((KBACTION KEYWORD)))"
    (CL:FUNCTION UPDATE-NOW-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "BOTTOM?"
    "(DEFUN (BOTTOM? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'self' is the undefined individual BOTTOM.\")"
    (CL:FUNCTION BOTTOM?) NULL)
   (DEFINE-FUNCTION-OBJECT "SUBRELATION-OF?"
    "(DEFUN (SUBRELATION-OF? BOOLEAN) ((DESC1 NAMED-DESCRIPTION) (DESC2 NAMED-DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION SUBRELATION-OF?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGICAL-SUBTYPE-OF?"
    "(DEFUN (LOGICAL-SUBTYPE-OF? BOOLEAN) ((TYPE1 SURROGATE) (TYPE2 SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION LOGICAL-SUBTYPE-OF?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGICAL-SUBTYPE-OF-LITERAL?"
    "(DEFUN (LOGICAL-SUBTYPE-OF-LITERAL? BOOLEAN) ((TYPE SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION LOGICAL-SUBTYPE-OF-LITERAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "LITERAL-TYPE?"
    "(DEFUN (LITERAL-TYPE? BOOLEAN) ((TYPE SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION LITERAL-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT "BOOLEAN-TYPE?"
    "(DEFUN (BOOLEAN-TYPE? BOOLEAN) ((SELF TYPE)) :PUBLIC? TRUE)"
    (CL:FUNCTION BOOLEAN-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS-DESCRIPTION?"
    "(DEFUN (CLASS-DESCRIPTION? BOOLEAN) ((SELF NAMED-DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION CLASS-DESCRIPTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "FUNCTION-DESCRIPTION?"
    "(DEFUN (FUNCTION-DESCRIPTION? BOOLEAN) ((SELF NAMED-DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION FUNCTION-DESCRIPTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "VARIABLE-ARITY?"
    "(DEFUN (VARIABLE-ARITY? BOOLEAN) ((SELF DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION VARIABLE-ARITY?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ARITY INTEGER) ((SELF NAMED-DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION ARITY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ARITY INTEGER) ((SELF DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION ARITY) NULL)
   (DEFINE-FUNCTION-OBJECT "MONADIC?"
    "(DEFUN (MONADIC? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION MONADIC?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTED-RELATION?"
    "(DEFUN (COMPUTED-RELATION? BOOLEAN) ((DESCRIPTION NAMED-DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION COMPUTED-RELATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "LAST-ARGUMENT"
    "(DEFUN (LAST-ARGUMENT OBJECT) ((PROPOSITION PROPOSITION)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH (ARGUMENTS PROPOSITION) (1- (LENGTH (ARGUMENTS PROPOSITION))))))"
    (CL:FUNCTION LAST-ARGUMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "OBJECT-SURROGATE"
    "(DEFUN (OBJECT-SURROGATE SURROGATE) ((SELF OBJECT)) :DOCUMENTATION \"Return the surrogate naming the object `self', which
may be a Stella class that is used in PowerLoom as well as
a more normal powerloom object.\" :PUBLIC? TRUE)"
    (CL:FUNCTION OBJECT-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "OBJECT-SURROGATE-SETTER"
    "(DEFUN (OBJECT-SURROGATE-SETTER SURROGATE) ((SELF OBJECT) (NAME SURROGATE)) :DOCUMENTATION \"Return the name of the logic object `self' to `name'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION OBJECT-SURROGATE-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "OBJECT-NAME"
    "(DEFUN (OBJECT-NAME SYMBOL) ((SELF OBJECT)) :DOCUMENTATION \"Return the name symbol for the logic object `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION OBJECT-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "OBJECT-NAME-STRING"
    "(DEFUN (OBJECT-NAME-STRING STRING) ((SELF OBJECT)) :DOCUMENTATION \"Return the name string for the logic object `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION OBJECT-NAME-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "OBJECT-STRING-NAME"
    "(DEFUN (OBJECT-STRING-NAME STRING) ((SELF OBJECT)))"
    (CL:FUNCTION OBJECT-STRING-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "DESCRIPTION-MODE?"
    "(DEFUN (DESCRIPTION-MODE? BOOLEAN) ())"
    (CL:FUNCTION DESCRIPTION-MODE?) NULL)
   (DEFINE-FUNCTION-OBJECT "NATURAL-DEDUCTION-MODE?"
    "(DEFUN (NATURAL-DEDUCTION-MODE? BOOLEAN) () :DOCUMENTATION \"True if normalization is governed by natural
deduction semantics.\")" (CL:FUNCTION NATURAL-DEDUCTION-MODE?) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTEXT-DEPENDENT-SEARCH-MODE?"
    "(DEFUN (CONTEXT-DEPENDENT-SEARCH-MODE? BOOLEAN) ())"
    (CL:FUNCTION CONTEXT-DEPENDENT-SEARCH-MODE?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOG-NEWLY-CONCEIVED-PROPOSITION"
    "(DEFUN LOG-NEWLY-CONCEIVED-PROPOSITION ((SELF MODULE) (PROPOSITION PROPOSITION)))"
    (CL:FUNCTION LOG-NEWLY-CONCEIVED-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "CLIP-OR-CLASH-WITH-OLD-PREDICATE-VALUE"
    "(DEFUN CLIP-OR-CLASH-WITH-OLD-PREDICATE-VALUE ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION CLIP-OR-CLASH-WITH-OLD-PREDICATE-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-UPDATE-EQUIVALENCE-PROPOSITION-DEMON"
    "(DEFUN RUN-UPDATE-EQUIVALENCE-PROPOSITION-DEMON ((PROPOSITION PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION RUN-UPDATE-EQUIVALENCE-PROPOSITION-DEMON) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-RUN-UPDATE-PROPOSITION-DEMON"
    "(DEFUN HELP-RUN-UPDATE-PROPOSITION-DEMON ((PROPOSITION PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION HELP-RUN-UPDATE-PROPOSITION-DEMON) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-UPDATE-PROPOSITION-DEMON"
    "(DEFUN RUN-UPDATE-PROPOSITION-DEMON ((PROPOSITION PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION RUN-UPDATE-PROPOSITION-DEMON) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-TRUTH-CHANGE-DEMON"
    "(DEFUN RUN-TRUTH-CHANGE-DEMON ((PROPOSITION PROPOSITION) (TRUTHCHANGERELATION SURROGATE)))"
    (CL:FUNCTION RUN-TRUTH-CHANGE-DEMON) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-GOES-TRUE-DEMONS"
    "(DEFUN RUN-GOES-TRUE-DEMONS ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION RUN-GOES-TRUE-DEMONS) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-GOES-FALSE-DEMONS"
    "(DEFUN RUN-GOES-FALSE-DEMONS ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION RUN-GOES-FALSE-DEMONS) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-GOES-UNKNOWN-DEMONS"
    "(DEFUN RUN-GOES-UNKNOWN-DEMONS ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION RUN-GOES-UNKNOWN-DEMONS) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-LINKS-AND-TIMESTAMPS"
    "(DEFUN UPDATE-LINKS-AND-TIMESTAMPS ((PROPOSITION PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION UPDATE-LINKS-AND-TIMESTAMPS) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSIGN-TRUTH-VALUE"
    "(DEFUN ASSIGN-TRUTH-VALUE ((SELF PROPOSITION) (TRUTHVALUE OBJECT)))"
    (CL:FUNCTION ASSIGN-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "DEASSIGN-TRUTH-VALUE"
    "(DEFUN DEASSIGN-TRUTH-VALUE ((SELF PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION DEASSIGN-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-PROPOSITION-TRUTH-VALUE"
    "(DEFUN UPDATE-PROPOSITION-TRUTH-VALUE ((SELF PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION UPDATE-PROPOSITION-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSIGN-PROPOSITION-WEIGHT"
    "(DEFUN ASSIGN-PROPOSITION-WEIGHT ((SELF PROPOSITION) (WEIGHT PARTIAL-MATCH-SCORE)))"
    (CL:FUNCTION ASSIGN-PROPOSITION-WEIGHT) NULL)
   (DEFINE-FUNCTION-OBJECT "TICKLE-CONTEXT"
    "(DEFUN (TICKLE-CONTEXT CONTEXT) ())" (CL:FUNCTION TICKLE-CONTEXT)
    NULL)
   (DEFINE-FUNCTION-OBJECT "TICKLE-INSTANCES"
    "(DEFUN (TICKLE-INSTANCES CONTEXT) ())"
    (CL:FUNCTION TICKLE-INSTANCES) NULL)
   (DEFINE-FUNCTION-OBJECT "REACT-TO-SKOLEM-VALUE-UPDATE"
    "(DEFUN REACT-TO-SKOLEM-VALUE-UPDATE ((SKOLEM SKOLEM) (OLDVALUE OBJECT) (NEWVALUE OBJECT) (TOPLEVELUPDATE? BOOLEAN)))"
    (CL:FUNCTION REACT-TO-SKOLEM-VALUE-UPDATE) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-SLOT-PROPOSITION?"
    "(DEFUN (NATIVE-SLOT-PROPOSITION? BOOLEAN) ((SELF PROPOSITION)))"
    (CL:FUNCTION NATIVE-SLOT-PROPOSITION?) NULL)))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS9 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "UPDATE-NATIVE-SLOT-PROPOSITION"
    "(DEFUN (UPDATE-NATIVE-SLOT-PROPOSITION (CONS OF PROPOSITION)) ((PROPOSITION PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION UPDATE-NATIVE-SLOT-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSIGN-NATIVE-SLOT-VALUE"
    "(DEFUN ASSIGN-NATIVE-SLOT-VALUE ((SELF THING) (SLOT STORAGE-SLOT) (VALUE OBJECT)))"
    (CL:FUNCTION ASSIGN-NATIVE-SLOT-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-NATIVE-SLOT-VALUE"
    "(DEFUN CLEAR-NATIVE-SLOT-VALUE ((OBJECT THING) (SLOT STORAGE-SLOT)))"
    (CL:FUNCTION CLEAR-NATIVE-SLOT-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "DROP-NATIVE-SLOT-VALUE"
    "(DEFUN DROP-NATIVE-SLOT-VALUE ((SELF THING) (SLOT STORAGE-SLOT) (VALUE OBJECT)))"
    (CL:FUNCTION DROP-NATIVE-SLOT-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-SLOTREF-ON-INSTANCE"
    "(DEFUN (LOOKUP-SLOTREF-ON-INSTANCE SURROGATE) ((TERM OBJECT) (SLOTNAME SYMBOL)))"
    (CL:FUNCTION LOOKUP-SLOTREF-ON-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNBOUND?"
    "(DEFUN (UNBOUND? BOOLEAN) ((SKOLEM SKOLEM)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NULL? (VARIABLE-VALUE SKOLEM))))"
    (CL:FUNCTION UNBOUND?) NULL)
   (DEFINE-FUNCTION-OBJECT "VALUE-OF"
    "(DEFUN (VALUE-OF OBJECT) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION VALUE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "SURROGATE.VALUE-OF"
    "(DEFUN (SURROGATE.VALUE-OF OBJECT) ((SELF SURROGATE)))"
    (CL:FUNCTION SURROGATE.VALUE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATION.VALUE-OF"
    "(DEFUN (RELATION.VALUE-OF DESCRIPTION) ((SELF RELATION)))"
    (CL:FUNCTION RELATION.VALUE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-VALUE-OF"
    "(DEFUN (EQUIVALENT-VALUE-OF OBJECT) ((SELF OBJECT)))"
    (CL:FUNCTION EQUIVALENT-VALUE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "GROUND-VALUE-OF"
    "(DEFUN (GROUND-VALUE-OF OBJECT) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION GROUND-VALUE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "SKOLEM?"
    "(DEFUN (SKOLEM? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION SKOLEM?) NULL)
   (DEFINE-FUNCTION-OBJECT "VARIABLE?"
    "(DEFUN (VARIABLE? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION VARIABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-VALUE?"
    "(DEFUN (NATIVE-VALUE? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION NATIVE-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-VALUE-OF"
    "(DEFUN (NATIVE-VALUE-OF OBJECT) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION NATIVE-VALUE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "INNERMOST-VARIABLE-OF"
    "(DEFUN (INNERMOST-VARIABLE-OF PATTERN-VARIABLE) ((SELF PATTERN-VARIABLE)))"
    (CL:FUNCTION INNERMOST-VARIABLE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "INNERMOST-OF"
    "(DEFUN (INNERMOST-OF OBJECT) ((SELF OBJECT)))"
    (CL:FUNCTION INNERMOST-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-ANONYMOUS-SKOLEM-NAME"
    "(DEFUN (YIELD-ANONYMOUS-SKOLEM-NAME SYMBOL) ((VARIABLE? BOOLEAN)))"
    (CL:FUNCTION YIELD-ANONYMOUS-SKOLEM-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-CREATE-SKOLEM"
    "(DEFUN (HELP-CREATE-SKOLEM SKOLEM) ((SELF SKOLEM) (TYPE TYPE) (NAME SYMBOL) (ASSERTISA? BOOLEAN)))"
    (CL:FUNCTION HELP-CREATE-SKOLEM) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-SKOLEM"
    "(DEFUN (CREATE-SKOLEM SKOLEM) ((TYPE TYPE) (NAME SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-SKOLEM) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-VARIABLE"
    "(DEFUN (CREATE-VARIABLE PATTERN-VARIABLE) ((TYPE TYPE) (NAME SYMBOL) (ASSERTISA? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-VARIABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-VARIABLE-OR-SKOLEM"
    "(DEFUN (CREATE-VARIABLE-OR-SKOLEM SKOLEM) ((TYPE TYPE) (NAME SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-VARIABLE-OR-SKOLEM) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((SELF SKOLEM) (OTHER OBJECT)))"
    (CL:FUNCTION OBJECT-EQUAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRUE?"
    "(DEFUN (TRUE? BOOLEAN) ((SELF PROPOSITION)) :DOCUMENTATION \"Return true if `self' is true (or default-true if we are
considering default assertions).\" :PUBLIC? TRUE)" (CL:FUNCTION TRUE?)
    NULL)
   (DEFINE-FUNCTION-OBJECT "FALSE?"
    "(DEFUN (FALSE? BOOLEAN) ((SELF PROPOSITION)) :DOCUMENTATION \"Return true if `self' is false (or default-false if we are
considering default assertions).\" :PUBLIC? TRUE)" (CL:FUNCTION FALSE?)
    NULL)
   (DEFINE-FUNCTION-OBJECT "UNKNOWN?"
    "(DEFUN (UNKNOWN? BOOLEAN) ((SELF PROPOSITION)) :DOCUMENTATION \"Return true if the truth of `self' is unknown.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNKNOWN?) NULL)
   (DEFINE-FUNCTION-OBJECT "INCONSISTENT?"
    "(DEFUN (INCONSISTENT? BOOLEAN) ((SELF PROPOSITION)) :DOCUMENTATION \"Return true if `self' is inconsistent (true and false).\" :PUBLIC? TRUE)"
    (CL:FUNCTION INCONSISTENT?) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFAULT-TRUE?"
    "(DEFUN (DEFAULT-TRUE? BOOLEAN) ((SELF PROPOSITION)) :DOCUMENTATION \"Return true if `self' is default true.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DEFAULT-TRUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFAULT-FALSE?"
    "(DEFUN (DEFAULT-FALSE? BOOLEAN) ((SELF PROPOSITION)) :DOCUMENTATION \"Return true if `self' is default false.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DEFAULT-FALSE?) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFAULTIFY-TRUTH-VALUE"
    "(DEFUN (DEFAULTIFY-TRUTH-VALUE TRUTH-VALUE) ((TRUE? BOOLEAN) (BYDEFAULT? BOOLEAN)))"
    (CL:FUNCTION DEFAULTIFY-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "CONJOIN-TRUTH-VALUES"
    "(DEFUN (CONJOIN-TRUTH-VALUES TRUTH-VALUE) ((TV1 TRUTH-VALUE) (TV2 TRUTH-VALUE)) :DOCUMENTATION \"Return the logical conjunction of truth values `tv1' and `tv2'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CONJOIN-TRUTH-VALUES) NULL)
   (DEFINE-FUNCTION-OBJECT "DISJOIN-TRUTH-VALUES"
    "(DEFUN (DISJOIN-TRUTH-VALUES TRUTH-VALUE) ((TV1 TRUTH-VALUE) (TV2 TRUTH-VALUE)) :DOCUMENTATION \"Return the logical disjunction of truth values `tv1' and `tv2'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DISJOIN-TRUTH-VALUES) NULL)
   (DEFINE-FUNCTION-OBJECT "INVERT-TRUTH-VALUE"
    "(DEFUN (INVERT-TRUTH-VALUE TRUTH-VALUE) ((SELF TRUTH-VALUE)) :DOCUMENTATION \"Return the logical negation of `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION INVERT-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "WEAKEN-TRUTH-VALUE"
    "(DEFUN (WEAKEN-TRUTH-VALUE TRUTH-VALUE) ((TV1 TRUTH-VALUE) (TV2 TRUTH-VALUE)) :DOCUMENTATION \"If `tv2' has lesser strength than `tv1', adapt the strength of `tv1' (not
its value!) and return the result.  Otherwise, return `tv1' unmodified.\" :PUBLIC? TRUE)"
    (CL:FUNCTION WEAKEN-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "STRENGTHEN-TRUTH-VALUE"
    "(DEFUN (STRENGTHEN-TRUTH-VALUE TRUTH-VALUE) ((TV1 TRUTH-VALUE) (TV2 TRUTH-VALUE)) :DOCUMENTATION \"If `tv2' has greater strength than `tv1', adapt the strength of `tv1' (not
its value!) and return the result.  Otherwise, return `tv1' unmodified.\" :PUBLIC? TRUE)"
    (CL:FUNCTION STRENGTHEN-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "TRUE-TRUTH-VALUE?"
    "(DEFUN (TRUE-TRUTH-VALUE? BOOLEAN) ((SELF TRUTH-VALUE)) :DOCUMENTATION \"Return TRUE if `self' represents some form of truth.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (OR (EQL? SELF TRUE-TRUTH-VALUE) (EQL? SELF DEFAULT-TRUE-TRUTH-VALUE))))"
    (CL:FUNCTION TRUE-TRUTH-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "FALSE-TRUTH-VALUE?"
    "(DEFUN (FALSE-TRUTH-VALUE? BOOLEAN) ((SELF TRUTH-VALUE)) :DOCUMENTATION \"Return TRUE if `self' represents some form of falsehood.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (OR (EQL? SELF FALSE-TRUTH-VALUE) (EQL? SELF DEFAULT-FALSE-TRUTH-VALUE))))"
    (CL:FUNCTION FALSE-TRUTH-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "STRICT-TRUTH-VALUE?"
    "(DEFUN (STRICT-TRUTH-VALUE? BOOLEAN) ((SELF TRUTH-VALUE)) :DOCUMENTATION \"Return TRUE if `self' is a strict truth value.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (OR (EQL? SELF TRUE-TRUTH-VALUE) (EQL? SELF FALSE-TRUTH-VALUE))))"
    (CL:FUNCTION STRICT-TRUTH-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFAULT-TRUTH-VALUE?"
    "(DEFUN (DEFAULT-TRUTH-VALUE? BOOLEAN) ((SELF TRUTH-VALUE)) :DOCUMENTATION \"Return TRUE if `self' is a default truth value.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (OR (EQL? SELF DEFAULT-TRUE-TRUTH-VALUE) (EQL? SELF DEFAULT-FALSE-TRUTH-VALUE))))"
    (CL:FUNCTION DEFAULT-TRUTH-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "UNKNOWN-TRUTH-VALUE?"
    "(DEFUN (UNKNOWN-TRUTH-VALUE? BOOLEAN) ((SELF TRUTH-VALUE)) :DOCUMENTATION \"Return TRUE if `self' represents UNKNOWN.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (OR (EQL? SELF UNKNOWN-TRUTH-VALUE) (NULL? SELF))))"
    (CL:FUNCTION UNKNOWN-TRUTH-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "INCONSISTENT-TRUTH-VALUE?"
    "(DEFUN (INCONSISTENT-TRUTH-VALUE? BOOLEAN) ((SELF TRUTH-VALUE)) :DOCUMENTATION \"Return TRUE if `self' represents INCONSISTENT.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQL? SELF INCONSISTENT-TRUTH-VALUE)))"
    (CL:FUNCTION INCONSISTENT-TRUTH-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-TRUTH-VALUE"
    "(DEFUN PRINT-TRUTH-VALUE ((SELF TRUTH-VALUE) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-UNIFICATION-CLASH"
    "(DEFUN SIGNAL-UNIFICATION-CLASH ((TERM1 OBJECT) (TERM2 OBJECT)))"
    (CL:FUNCTION SIGNAL-UNIFICATION-CLASH) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-VARIABLE-VALUE-CLASH"
    "(DEFUN SIGNAL-VARIABLE-VALUE-CLASH ((SKOLEM SKOLEM) (VALUE1 OBJECT) (VALUE2 OBJECT)))"
    (CL:FUNCTION SIGNAL-VARIABLE-VALUE-CLASH) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-TRUTH-VALUE-CLASH"
    "(DEFUN SIGNAL-TRUTH-VALUE-CLASH ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION SIGNAL-TRUTH-VALUE-CLASH) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGICAL-TYPE"
    "(DEFUN (LOGICAL-TYPE TYPE) ((SELF OBJECT)))"
    (CL:FUNCTION LOGICAL-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "SAFE-LOGICAL-TYPE"
    "(DEFUN (SAFE-LOGICAL-TYPE TYPE) ((SELF OBJECT)))"
    (CL:FUNCTION SAFE-LOGICAL-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS-LOGICAL-TYPE"
    "(DEFUN (CLASS-LOGICAL-TYPE TYPE) ((SELF CLASS)))"
    (CL:FUNCTION CLASS-LOGICAL-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNIFY-TYPES"
    "(DEFUN UNIFY-TYPES ((TERM1 SKOLEM) (TERM2 OBJECT)))"
    (CL:FUNCTION UNIFY-TYPES) NULL)
   (DEFINE-FUNCTION-OBJECT "UNIFY-SKOLEM-AND-VALUE"
    "(DEFUN UNIFY-SKOLEM-AND-VALUE ((SKOLEM SKOLEM) (VALUE OBJECT)))"
    (CL:FUNCTION UNIFY-SKOLEM-AND-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "BIND-SKOLEM-TO-VALUE"
    "(DEFUN BIND-SKOLEM-TO-VALUE ((FROMSKOLEM SKOLEM) (TOVALUE OBJECT) (TOPLEVELUPDATE? BOOLEAN)))"
    (CL:FUNCTION BIND-SKOLEM-TO-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNBIND-SKOLEM-VALUE"
    "(DEFUN UNBIND-SKOLEM-VALUE ((SKOLEM SKOLEM) (TOPLEVELUPDATE? BOOLEAN)))"
    (CL:FUNCTION UNBIND-SKOLEM-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "CONSTRAIN-AS-SUBSET"
    "(DEFUN CONSTRAIN-AS-SUBSET ((SET1 COLLECTION) (SET2 COLLECTION)))"
    (CL:FUNCTION CONSTRAIN-AS-SUBSET) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUATE-COLLECTIONS"
    "(DEFUN EQUATE-COLLECTIONS ((COL1 COLLECTION) (COL2 COLLECTION)))"
    (CL:FUNCTION EQUATE-COLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGIC-COLLECTION?"
    "(DEFUN (LOGIC-COLLECTION? BOOLEAN) ((TERM OBJECT)))"
    (CL:FUNCTION LOGIC-COLLECTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUATE-VALUES"
    "(DEFUN EQUATE-VALUES ((TERM1 OBJECT) (TERM2 OBJECT)))"
    (CL:FUNCTION EQUATE-VALUES) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT SKOLEM CONFLICTING-DEFAULT-VALUES :TYPE (CONS OF PROPOSITION) :DEFAULT NIL :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "UNEQUATE-CONFLICTING-DEFAULT-VALUES?"
    "(DEFUN (UNEQUATE-CONFLICTING-DEFAULT-VALUES? BOOLEAN) ((NEWEQUATINGPROP PROPOSITION)))"
    (CL:FUNCTION UNEQUATE-CONFLICTING-DEFAULT-VALUES?) NULL)
   (DEFINE-FUNCTION-OBJECT "UNEQUATE-VALUES?"
    "(DEFUN (UNEQUATE-VALUES? BOOLEAN) ((TERM1 OBJECT) (TERM2 OBJECT)))"
    (CL:FUNCTION UNEQUATE-VALUES?) NULL)
   (DEFINE-FUNCTION-OBJECT "BIND-TO-EQUIVALENT-VALUE"
    "(DEFUN BIND-TO-EQUIVALENT-VALUE ((FROM LOGIC-OBJECT) (TO DESCRIPTION)))"
    (CL:FUNCTION BIND-TO-EQUIVALENT-VALUE) NULL)))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS10 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "UNBIND-EQUIVALENT-VALUE"
    "(DEFUN UNBIND-EQUIVALENT-VALUE ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION UNBIND-EQUIVALENT-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNLINK-EQUIVALENT-VALUE"
    "(DEFUN UNLINK-EQUIVALENT-VALUE ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION UNLINK-EQUIVALENT-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-COLLECTION-PRIORITY"
    "(DEFUN (EQUIVALENT-COLLECTION-PRIORITY INTEGER) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION EQUIVALENT-COLLECTION-PRIORITY) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENCE-COLLECTIONS"
    "(DEFUN EQUIVALENCE-COLLECTIONS ((COLLECTION1 LOGIC-OBJECT) (COLLECTION2 LOGIC-OBJECT)))"
    (CL:FUNCTION EQUIVALENCE-COLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "REVISE-EQUIVALENCES"
    "(DEFUN REVISE-EQUIVALENCES ((PROPOSITION PROPOSITION) (GOESTRUE? BOOLEAN)))"
    (CL:FUNCTION REVISE-EQUIVALENCES) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-EQUATING-PROPOSITION"
    "(DEFUN (FIND-EQUATING-PROPOSITION PROPOSITION) ((DIRECTOBJECT OBJECT) (INDIRECTOBJECT LOGIC-OBJECT)))"
    (CL:FUNCTION FIND-EQUATING-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-TERM"
    "(DEFUN (EVALUATE-TERM OBJECT) ((SELF OBJECT)))"
    (CL:FUNCTION EVALUATE-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-LITERAL-WRAPPER-TERM"
    "(DEFUN (EVALUATE-LITERAL-WRAPPER-TERM OBJECT) ((SELF LITERAL-WRAPPER)))"
    (CL:FUNCTION EVALUATE-LITERAL-WRAPPER-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-SURROGATE-TERM"
    "(DEFUN (EVALUATE-SURROGATE-TERM OBJECT) ((SELF SURROGATE)))"
    (CL:FUNCTION EVALUATE-SURROGATE-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-LOGIC-OBJECT-TERM"
    "(DEFUN (EVALUATE-LOGIC-OBJECT-TERM OBJECT) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION EVALUATE-LOGIC-OBJECT-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "ANONYMOUS-VARIABLE?"
    "(DEFUN (ANONYMOUS-VARIABLE? BOOLEAN) ((SELF SKOLEM)))"
    (CL:FUNCTION ANONYMOUS-VARIABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-SYMBOL-TERM"
    "(DEFUN (EVALUATE-SYMBOL-TERM OBJECT) ((SELF SYMBOL)))"
    (CL:FUNCTION EVALUATE-SYMBOL-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-AUTOMATIC-INSTANCE"
    "(DEFUN (EVALUATE-AUTOMATIC-INSTANCE OBJECT) ((NAME SYMBOL)))"
    (CL:FUNCTION EVALUATE-AUTOMATIC-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-UNDEFINED-TERM"
    "(DEFUN SIGNAL-UNDEFINED-TERM ((TERM OBJECT)))"
    (CL:FUNCTION SIGNAL-UNDEFINED-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-UNTYPED-TERM"
    "(DEFUN SIGNAL-UNTYPED-TERM ((TERM OBJECT)))"
    (CL:FUNCTION SIGNAL-UNTYPED-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-CREATE-TERM"
    "(DEFUN (EVALUATE-CREATE-TERM OBJECT) ((TERM CONS)))"
    (CL:FUNCTION EVALUATE-CREATE-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE"
    "(DEFUN (CREATE OBJECT) ((NAME GENERALIZED-SYMBOL) |&REST| (TYPE GENERALIZED-SYMBOL)) :DOCUMENTATION \"Create a logic object with name 'name' and return it.
If `type' is also supplied, assert that the object belongs to that type.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %CREATE) (CL:FUNCTION CREATE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "UPDATE-SKOLEM-TYPE"
    "(DEFUN UPDATE-SKOLEM-TYPE ((SELF SKOLEM) (TYPE TYPE)))"
    (CL:FUNCTION UPDATE-SKOLEM-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS"
    "(DEFUN UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS ((SELF PROPOSITION)))"
    (CL:FUNCTION UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "DESCRIPTION-EXTENSION<"
    "(DEFUN (DESCRIPTION-EXTENSION< BOOLEAN) ((DESC1 DESCRIPTION) (DESC2 DESCRIPTION)))"
    (CL:FUNCTION DESCRIPTION-EXTENSION<) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-EXTENSION-SIZES"
    "(DEFUN PRINT-EXTENSION-SIZES ((MODULE MODULE) (SIZECUTOFF INTEGER)) :DOCUMENTATION \"Print the extension sizes of concepts visible in `module'.
If `module' is NULL the current module is used.  Do not report extensions
with size less than `sizeCutoff' (default is 10).\" :PUBLIC? TRUE)"
    (CL:FUNCTION PRINT-EXTENSION-SIZES) NULL)
   (DEFINE-FUNCTION-OBJECT
    "TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK"
    "(DEFUN TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK ((RELATIONSLIST (LIST OF RELATION))))"
    (CL:FUNCTION TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRACT-RELATION-AXIOMS"
    "(DEFUN RETRACT-RELATION-AXIOMS ((OLDRELATION NAMED-DESCRIPTION)))"
    (CL:FUNCTION RETRACT-RELATION-AXIOMS) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION"
    "(DEFUN (ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION PROPOSITION) ((SUB DESCRIPTION) (SUPER DESCRIPTION) (DONTUPDATE? BOOLEAN)))"
    (CL:FUNCTION ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS"
    "(DEFUN (ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS PROPOSITION) ((SUB NAMED-DESCRIPTION) (SUPER NAMED-DESCRIPTION)))"
    (CL:FUNCTION ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-SUPERRELATION-LINKS"
    "(DEFUN FINALIZE-SUPERRELATION-LINKS ((SELF RELATION)))"
    (CL:FUNCTION FINALIZE-SUPERRELATION-LINKS) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-ISA-PROPOSITION"
    "(DEFUN (UPDATE-ISA-PROPOSITION PROPOSITION) ((SELF OBJECT) (TYPE TYPE) (UPDATEMODE KEYWORD)) :PUBLIC? TRUE)"
    (CL:FUNCTION UPDATE-ISA-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-ISA-PROPOSITION"
    "(DEFUN (ASSERT-ISA-PROPOSITION PROPOSITION) ((SELF OBJECT) (TYPE TYPE)) :PUBLIC? TRUE)"
    (CL:FUNCTION ASSERT-ISA-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRACT-ISA-PROPOSITION"
    "(DEFUN (RETRACT-ISA-PROPOSITION PROPOSITION) ((SELF OBJECT) (TYPE TYPE)) :PUBLIC? TRUE)"
    (CL:FUNCTION RETRACT-ISA-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-PROPERTY"
    "(DEFUN (UPDATE-PROPERTY PROPOSITION) ((SELF LOGIC-OBJECT) (SURROGATE SURROGATE) (UPDATEMODE KEYWORD)) :PUBLIC? TRUE)"
    (CL:FUNCTION UPDATE-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-PROPERTY"
    "(DEFUN (ASSERT-PROPERTY PROPOSITION) ((INSTANCE LOGIC-OBJECT) (PROPERTY SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION ASSERT-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRACT-PROPERTY"
    "(DEFUN (RETRACT-PROPERTY PROPOSITION) ((INSTANCE LOGIC-OBJECT) (PROPERTY SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION RETRACT-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-TUPLE"
    "(DEFUN (UPDATE-TUPLE PROPOSITION) ((RELATION SURROGATE) (ARGUMENTS (CONS OF OBJECT)) (UPDATEMODE KEYWORD)) :PUBLIC? TRUE)"
    (CL:FUNCTION UPDATE-TUPLE) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-TUPLE"
    "(DEFUN (ASSERT-TUPLE PROPOSITION) ((RELATION SURROGATE) (ARGUMENTS (CONS OF OBJECT))) :PUBLIC? TRUE)"
    (CL:FUNCTION ASSERT-TUPLE) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-BINARY-VALUE"
    "(DEFUN (UPDATE-BINARY-VALUE PROPOSITION) ((RELATION SURROGATE) (SELF OBJECT) (VALUE OBJECT) (UPDATEMODE KEYWORD)) :PUBLIC? TRUE)"
    (CL:FUNCTION UPDATE-BINARY-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-BINARY-VALUE"
    "(DEFUN (ASSERT-BINARY-VALUE PROPOSITION) ((RELATION SURROGATE) (SELF OBJECT) (VALUE OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION ASSERT-BINARY-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRACT-BINARY-VALUE"
    "(DEFUN (RETRACT-BINARY-VALUE PROPOSITION) ((RELATION SURROGATE) (SELF OBJECT) (VALUE OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION RETRACT-BINARY-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-MEMBER-OF-PROPOSITION"
    "(DEFUN (ASSERT-MEMBER-OF-PROPOSITION PROPOSITION) ((SELF OBJECT) (COLLECTION OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION ASSERT-MEMBER-OF-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-CREATE-LOGIC-INSTANCE"
    "(DEFUN (HELP-CREATE-LOGIC-INSTANCE OBJECT) ((NAME SURROGATE) (TYPE SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION HELP-CREATE-LOGIC-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-LOGIC-INSTANCE"
    "(DEFUN (CREATE-LOGIC-INSTANCE OBJECT) ((NAME SURROGATE) (TYPE SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-LOGIC-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEANUP-STRUCTURED-OBJECTS-INDEX"
    "(DEFUN CLEANUP-STRUCTURED-OBJECTS-INDEX ((CLEARMODULE MODULE)))"
    (CL:FUNCTION CLEANUP-STRUCTURED-OBJECTS-INDEX) NULL)
   (DEFINE-FUNCTION-OBJECT "PROPOSITION-HASH-INDEX"
    "(DEFUN (PROPOSITION-HASH-INDEX INTEGER) ((SELF PROPOSITION)))"
    (CL:FUNCTION PROPOSITION-HASH-INDEX) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-DUPLICATE-COMPLEX-PROPOSITION"
    "(DEFUN (FIND-DUPLICATE-COMPLEX-PROPOSITION PROPOSITION) ((SELF PROPOSITION)))"
    (CL:FUNCTION FIND-DUPLICATE-COMPLEX-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-DUPLICATE-PROPOSITION"
    "(DEFUN (FIND-DUPLICATE-PROPOSITION PROPOSITION) ((SELF PROPOSITION)))"
    (CL:FUNCTION FIND-DUPLICATE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FASTEN-DOWN-ONE-PROPOSITION"
    "(DEFUN (FASTEN-DOWN-ONE-PROPOSITION PROPOSITION) ((SELF PROPOSITION) (DONTCHECKFORDUPLICATES? BOOLEAN)))"
    (CL:FUNCTION FASTEN-DOWN-ONE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-FASTEN-DOWN-PROPOSITIONS"
    "(DEFUN (HELP-FASTEN-DOWN-PROPOSITIONS PROPOSITION) ((SELF PROPOSITION) (DONTCHECKFORDUPLICATES? BOOLEAN)))"
    (CL:FUNCTION HELP-FASTEN-DOWN-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "RECURSIVELY-FASTEN-DOWN-PROPOSITIONS"
    "(DEFUN (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS PROPOSITION) ((SELF PROPOSITION) (DONTCHECKFORDUPLICATES? BOOLEAN)))"
    (CL:FUNCTION RECURSIVELY-FASTEN-DOWN-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "UNFASTEN-PROPOSITION"
    "(DEFUN UNFASTEN-PROPOSITION ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION UNFASTEN-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "INSTANTIATE-UNDEFINED-SURROGATES"
    "(DEFUN INSTANTIATE-UNDEFINED-SURROGATES ((SELF PROPOSITION)))"
    (CL:FUNCTION INSTANTIATE-UNDEFINED-SURROGATES) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-TOP-LEVEL-PROPOSITION"
    "(DEFUN (BUILD-TOP-LEVEL-PROPOSITION PROPOSITION) ((TREE OBJECT) (TRUEASSERTION? BOOLEAN)))"
    (CL:FUNCTION BUILD-TOP-LEVEL-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-PROPOSITION"
    "(DEFUN (BUILD-PROPOSITION OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION BUILD-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "SURROGATE.BUILD-PROPOSITION"
    "(DEFUN (SURROGATE.BUILD-PROPOSITION PROPOSITION) ((SELF SURROGATE)))"
    (CL:FUNCTION SURROGATE.BUILD-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "SYMBOL.BUILD-PROPOSITION"
    "(DEFUN (SYMBOL.BUILD-PROPOSITION OBJECT) ((SYMBOL SYMBOL)))"
    (CL:FUNCTION SYMBOL.BUILD-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "CONS.BUILD-PROPOSITION"
    "(DEFUN (CONS.BUILD-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION CONS.BUILD-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS"
    "(DEFUN VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS ((TREE CONS) (CORRECTNUMBER INTEGER)))"
    (CL:FUNCTION VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DESCRIPTION-SURROGATE TYPE) ((SELF DESCRIPTION)))"
    (CL:FUNCTION DESCRIPTION-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-ISA-PROPOSITION"
    "(DEFUN (BUILD-ISA-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-ISA-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-MEMBER-OF-PROPOSITION"
    "(DEFUN (BUILD-MEMBER-OF-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-MEMBER-OF-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "MEMBER-OF-PROPOSITION?"
    "(DEFUN (MEMBER-OF-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)) :GLOBALLY-INLINE? TRUE (RETURN (EQL? (OPERATOR PROPOSITION) /PL-KERNEL-KB/@MEMBER-OF)))"
    (CL:FUNCTION MEMBER-OF-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "SUBSET-OF-PROPOSITION?"
    "(DEFUN (SUBSET-OF-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)) :GLOBALLY-INLINE? TRUE (RETURN (EQL? (OPERATOR PROPOSITION) /PL-KERNEL-KB/@SUBSET-OF)))"
    (CL:FUNCTION SUBSET-OF-PROPOSITION?) NULL)))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS11 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "SIMPLE-SUBRELATION-PROPOSITION?"
    "(DEFUN (SIMPLE-SUBRELATION-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)) :PUBLIC? TRUE)"
    (CL:FUNCTION SIMPLE-SUBRELATION-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXTRACT-ANNOTATION"
    "(DEFUN (EXTRACT-ANNOTATION OBJECT OBJECT) ((TREE OBJECT) (OPTION KEYWORD)))"
    (CL:FUNCTION EXTRACT-ANNOTATION) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-ANNOTATION"
    "(DEFUN (LOOKUP-ANNOTATION OBJECT) ((PROPOSITION PROPOSITION) (KEY KEYWORD)))"
    (CL:FUNCTION LOOKUP-ANNOTATION) NULL)
   (DEFINE-FUNCTION-OBJECT "INSERT-ANNOTATION"
    "(DEFUN INSERT-ANNOTATION ((PROPOSITION PROPOSITION) (KEY KEYWORD) (VALUE OBJECT)))"
    (CL:FUNCTION INSERT-ANNOTATION) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-ANNOTATION"
    "(DEFUN REMOVE-ANNOTATION ((PROPOSITION PROPOSITION) (KEY KEYWORD)))"
    (CL:FUNCTION REMOVE-ANNOTATION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-ANNOTATED-PROPOSITION"
    "(DEFUN (BUILD-ANNOTATED-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-ANNOTATED-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-PROPOSITION-ANNOTATIONS"
    "(DEFUN FINALIZE-PROPOSITION-ANNOTATIONS ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION FINALIZE-PROPOSITION-ANNOTATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-PROPOSITION-ANNOTATIONS"
    "(DEFUN CLEAR-PROPOSITION-ANNOTATIONS ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION CLEAR-PROPOSITION-ANNOTATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "FUNCTION-INDUCED-EXISTS?"
    "(DEFUN (FUNCTION-INDUCED-EXISTS? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION FUNCTION-INDUCED-EXISTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "PREDICATE-OF-FUNCTION-INDUCED-EXISTS"
    "(DEFUN (PREDICATE-OF-FUNCTION-INDUCED-EXISTS PROPOSITION) ((EXISTSPROPOSITION PROPOSITION)))"
    (CL:FUNCTION PREDICATE-OF-FUNCTION-INDUCED-EXISTS) NULL)
   (DEFINE-FUNCTION-OBJECT
    "EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS"
    "(DEFUN (EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS PROPOSITION) ((EXISTSPROPOSITION PROPOSITION)))"
    (CL:FUNCTION EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-AND-OR-NOT-PROPOSITION"
    "(DEFUN (BUILD-AND-OR-NOT-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-AND-OR-NOT-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FUNCTIONAL-TERM?"
    "(DEFUN (FUNCTIONAL-TERM? BOOLEAN) ((TERM OBJECT)))"
    (CL:FUNCTION FUNCTIONAL-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLIP-VALUE?"
    "(DEFUN (CLIP-VALUE? BOOLEAN) ((TERM1 OBJECT) (TERM2 OBJECT)))"
    (CL:FUNCTION CLIP-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-EQUIVALENCE-PROPOSITION"
    "(DEFUN (CREATE-EQUIVALENCE-PROPOSITION PROPOSITION) ((TERM1 OBJECT) (TERM2 OBJECT)))"
    (CL:FUNCTION CREATE-EQUIVALENCE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-EQUIVALENCE-PROPOSITION"
    "(DEFUN (BUILD-EQUIVALENCE-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-EQUIVALENCE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS"
    "(DEFUN (BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS PROPOSITION) ((REMAININGTERMS CONS) (EQUIVALENCES (CONS OF PROPOSITION))))"
    (CL:FUNCTION BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-FAIL-PROPOSITION"
    "(DEFUN (BUILD-FAIL-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-FAIL-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-COLLECT-INTO-PROPOSITION"
    "(DEFUN (BUILD-COLLECT-INTO-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-COLLECT-INTO-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "HOLDS-OPERATOR?"
    "(DEFUN (HOLDS-OPERATOR? BOOLEAN) ((OPERATOR OBJECT)))"
    (CL:FUNCTION HOLDS-OPERATOR?) NULL)
   (DEFINE-FUNCTION-OBJECT "VERIFY-EVALUABLE-OPERATOR"
    "(DEFUN VERIFY-EVALUABLE-OPERATOR ((OPERATOR OBJECT) (KIND KEYWORD)))"
    (CL:FUNCTION VERIFY-EVALUABLE-OPERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-HOLDS-PROPOSITION"
    "(DEFUN (BUILD-HOLDS-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-HOLDS-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "MOST-GENERAL-EQUIVALENT-SLOTREF"
    "(DEFUN (MOST-GENERAL-EQUIVALENT-SLOTREF SURROGATE) ((SURROGATE SURROGATE)))"
    (CL:FUNCTION MOST-GENERAL-EQUIVALENT-SLOTREF) NULL)
   (DEFINE-FUNCTION-OBJECT "POLYMORPHIC-RELATION?"
    "(DEFUN (POLYMORPHIC-RELATION? BOOLEAN) ((SELF RELATION)))"
    (CL:FUNCTION POLYMORPHIC-RELATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "NON-POLYMORPHIC-PREDICATE?"
    "(DEFUN (NON-POLYMORPHIC-PREDICATE? BOOLEAN) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION NON-POLYMORPHIC-PREDICATE?) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-PREDICATE"
    "(DEFUN (EVALUATE-PREDICATE LOGIC-OBJECT) ((NAME GENERALIZED-SYMBOL) (FIRSTARGUMENT OBJECT)))"
    (CL:FUNCTION EVALUATE-PREDICATE) NULL)
   (DEFINE-FUNCTION-OBJECT "PROPOSITIONAL-ARGUMENT?"
    "(DEFUN (PROPOSITIONAL-ARGUMENT? BOOLEAN) ((ARGUMENT OBJECT)))"
    (CL:FUNCTION PROPOSITIONAL-ARGUMENT?) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-TYPED-ARGUMENT"
    "(DEFUN (EVALUATE-TYPED-ARGUMENT OBJECT) ((ARGUMENT OBJECT) (TYPE SURROGATE)))"
    (CL:FUNCTION EVALUATE-TYPED-ARGUMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-FIRST-ARGUMENT"
    "(DEFUN (EVALUATE-FIRST-ARGUMENT OBJECT) ((ARGUMENT OBJECT) (RELATIONNAME SYMBOL)))"
    (CL:FUNCTION EVALUATE-FIRST-ARGUMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-REMAINING-ARGUMENTS"
    "(DEFUN (EVALUATE-REMAINING-ARGUMENTS CONS) ((PREDICATEVALUE LOGIC-OBJECT) (ARGUMENTS CONS)))"
    (CL:FUNCTION EVALUATE-REMAINING-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS-OPERATOR?"
    "(DEFUN (CLASS-OPERATOR? BOOLEAN) ((OPERATOR GENERALIZED-SYMBOL)))"
    (CL:FUNCTION CLASS-OPERATOR?) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-PREDICATE-PROPOSITION"
    "(DEFUN (BUILD-PREDICATE-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-PREDICATE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "CHECK-STRICT-TYPE?"
    "(DEFUN (CHECK-STRICT-TYPE? BOOLEAN) ((SELF OBJECT) (TYPE SURROGATE) (SHALLOW? BOOLEAN)))"
    (CL:FUNCTION CHECK-STRICT-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT "CHECK-TYPE?"
    "(DEFUN (CHECK-TYPE? BOOLEAN) ((SELF OBJECT) (TYPE SURROGATE) (SHALLOW? BOOLEAN)) :GLOBALLY-INLINE? TRUE (RETURN (OR (PARTIAL-MATCH-MODE?) (CHECK-STRICT-TYPE? SELF TYPE SHALLOW?))))"
    (CL:FUNCTION CHECK-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT "CHECK-COERCED-TYPE?"
    "(DEFUN (CHECK-COERCED-TYPE? BOOLEAN OBJECT) ((SELF OBJECT) (TYPE SURROGATE) (SHALLOW? BOOLEAN)))"
    (CL:FUNCTION CHECK-COERCED-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-INCOMPATIBLE-VALUE"
    "(DEFUN (COERCE-INCOMPATIBLE-VALUE OBJECT) ((VALUE OBJECT) (TYPE SURROGATE)))"
    (CL:FUNCTION COERCE-INCOMPATIBLE-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-QUANTITY"
    "(DEFUN (COERCE-QUANTITY OBJECT) ((VALUE OBJECT) (QUANTITYTYPEREF SURROGATE)))"
    (CL:FUNCTION COERCE-QUANTITY) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-DATE"
    "(DEFUN (COERCE-DATE OBJECT) ((VALUE OBJECT) (DATETYPEREF SURROGATE)))"
    (CL:FUNCTION COERCE-DATE) NULL)
   (DEFINE-FUNCTION-OBJECT "VERIFY-ONE-ARGUMENT-TYPE"
    "(DEFUN VERIFY-ONE-ARGUMENT-TYPE ((ARG OBJECT) (TYPE SURROGATE) (PROPOSITION PROPOSITION) (DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION VERIFY-ONE-ARGUMENT-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "VERIFY-ARGUMENT-TYPES-AND-COUNT"
    "(DEFUN VERIFY-ARGUMENT-TYPES-AND-COUNT ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION VERIFY-ARGUMENT-TYPES-AND-COUNT) NULL)
   (DEFINE-FUNCTION-OBJECT "HANDLE-ARGUMENT-TYPE-VIOLATION"
    "(DEFUN HANDLE-ARGUMENT-TYPE-VIOLATION ((PROPOSITION PROPOSITION) (ARG OBJECT) (REQUIREDTYPE SURROGATE)))"
    (CL:FUNCTION HANDLE-ARGUMENT-TYPE-VIOLATION) NULL)
   (DEFINE-FUNCTION-OBJECT "HANDLE-ARITY-VIOLATION"
    "(DEFUN HANDLE-ARITY-VIOLATION ((PROPOSITION PROPOSITION) (REQUIREDARITY INTEGER)))"
    (CL:FUNCTION HANDLE-ARITY-VIOLATION) NULL)
   (DEFINE-FUNCTION-OBJECT "POST-TO-CHECK-TYPES-AGENDA"
    "(DEFUN POST-TO-CHECK-TYPES-AGENDA ((SELF PROPOSITION)))"
    (CL:FUNCTION POST-TO-CHECK-TYPES-AGENDA) NULL)
   (DEFINE-FUNCTION-OBJECT "PROCESS-CHECK-TYPES-AGENDA"
    "(DEFUN PROCESS-CHECK-TYPES-AGENDA ())"
    (CL:FUNCTION PROCESS-CHECK-TYPES-AGENDA) NULL)
   (DEFINE-FUNCTION-OBJECT "PROCESS-DEFINITIONS"
    "(DEFUN PROCESS-DEFINITIONS () :PUBLIC? TRUE :COMMAND? TRUE :DOCUMENTATION \"Finish processing all definitions and assertions that have
been evaluated/loaded since that last call to 'process-definitions'.
PowerLoom defers complete processing of definitions to make it easier
to support cyclic definitions.  Following finalization of definitions,
this call performs semantic validation of any assertions evaluated since
the last call to 'process-definitions'.  PowerLoom calls this function
internally before each query; the primary reason to call it explicitly
is to force the production of any diagnostic information that results from
the processing and validation.\")" (CL:FUNCTION PROCESS-DEFINITIONS)
    NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-EXISTS-PROPOSITION"
    "(DEFUN (BUILD-EXISTS-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-EXISTS-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "TOP-LEVEL-EXISTS-PROPOSITION?"
    "(DEFUN (TOP-LEVEL-EXISTS-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION TOP-LEVEL-EXISTS-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-SKOLEMIZED-EXISTS-VARIABLES"
    "(DEFUN (COLLECT-SKOLEMIZED-EXISTS-VARIABLES (VECTOR OF SKOLEM)) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION COLLECT-SKOLEMIZED-EXISTS-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES?"
    "(DEFUN (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? BOOLEAN) ((PROPOSITION PROPOSITION) (RESULT (LIST OF SKOLEM))))"
    (CL:FUNCTION HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES?) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-FORALL-PROPOSITION"
    "(DEFUN (BUILD-FORALL-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-FORALL-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "VERIFY-FORALL-PROPOSITIONS"
    "(DEFUN VERIFY-FORALL-PROPOSITIONS ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION VERIFY-FORALL-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT"
    "(DEFUN (MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT OBJECT) ((ARG1 OBJECT) (ARG2 OBJECT)))"
    (CL:FUNCTION MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-IMPLIES-PROPOSITION"
    "(DEFUN (CREATE-IMPLIES-PROPOSITION PROPOSITION) ((TAIL OBJECT) (HEAD OBJECT)))"
    (CL:FUNCTION CREATE-IMPLIES-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-IMPLIES-PROPOSITION"
    "(DEFUN (BUILD-IMPLIES-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-IMPLIES-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-DUPLICATE-FUNCTION-PROPOSITION"
    "(DEFUN (FIND-DUPLICATE-FUNCTION-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION FIND-DUPLICATE-FUNCTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWRAP-WRAPPED-TYPE"
    "(DEFUN (UNWRAP-WRAPPED-TYPE TYPE) ((TYPE TYPE)))"
    (CL:FUNCTION UNWRAP-WRAPPED-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "BEGIN-CREATING-FUNCTION-PROPOSITION"
    "(DEFUN (BEGIN-CREATING-FUNCTION-PROPOSITION PROPOSITION) ((SURROGATE GENERALIZED-SYMBOL) (INPUTARGUMENTS CONS)))"
    (CL:FUNCTION BEGIN-CREATING-FUNCTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FINISH-CREATING-FUNCTION-PROPOSITION"
    "(DEFUN (FINISH-CREATING-FUNCTION-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION FINISH-CREATING-FUNCTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-OR-CREATE-FUNCTION-PROPOSITION"
    "(DEFUN (FIND-OR-CREATE-FUNCTION-PROPOSITION PROPOSITION) ((PREDICATE GENERALIZED-SYMBOL) (INPUTARGUMENTS CONS)))"
    (CL:FUNCTION FIND-OR-CREATE-FUNCTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-FUNCTION-PROPOSITION"
    "(DEFUN (CREATE-FUNCTION-PROPOSITION PROPOSITION) ((PREDICATE GENERALIZED-SYMBOL) (INPUTARGUMENTS CONS)))"
    (CL:FUNCTION CREATE-FUNCTION-PROPOSITION) NULL)))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS12 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "EVALUATE-FUNCTION-TERM"
    "(DEFUN (EVALUATE-FUNCTION-TERM OBJECT) ((TREE CONS)))"
    (CL:FUNCTION EVALUATE-FUNCTION-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "EXTENSIONAL-INDIVIDUAL?"
    "(DEFUN (EXTENSIONAL-INDIVIDUAL? BOOLEAN) ((INDIVIDUAL OBJECT)))"
    (CL:FUNCTION EXTENSIONAL-INDIVIDUAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "FUNCTION-WITH-DEFINED-VALUE?"
    "(DEFUN (FUNCTION-WITH-DEFINED-VALUE? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION FUNCTION-WITH-DEFINED-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-ENUMERATED-SET"
    "(DEFUN (CREATE-ENUMERATED-SET SKOLEM) ((SET LIST)))"
    (CL:FUNCTION CREATE-ENUMERATED-SET) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-LOGICAL-LIST"
    "(DEFUN (CREATE-LOGICAL-LIST SKOLEM) ((LIST LIST)))"
    (CL:FUNCTION CREATE-LOGICAL-LIST) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGICAL-COLLECTION?"
    "(DEFUN (LOGICAL-COLLECTION? BOOLEAN) ((SELF OBJECT)))"
    (CL:FUNCTION LOGICAL-COLLECTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "SKOLEM-DEFINED-BY-OPERATOR?"
    "(DEFUN (SKOLEM-DEFINED-BY-OPERATOR? BOOLEAN) ((SELF OBJECT) (OPERATOR SURROGATE)) :GLOBALLY-INLINE? TRUE (TYPECASE SELF (SKOLEM (LET ((DEFININGPROPOSITION (DEFINING-PROPOSITION SELF))) (RETURN (AND (DEFINED? DEFININGPROPOSITION) (EQL? (OPERATOR DEFININGPROPOSITION) OPERATOR))))) (OTHERWISE (RETURN FALSE))))"
    (CL:FUNCTION SKOLEM-DEFINED-BY-OPERATOR?) NULL)
   (DEFINE-FUNCTION-OBJECT "ENUMERATED-SET?"
    "(DEFUN (ENUMERATED-SET? BOOLEAN) ((SELF OBJECT)))"
    (CL:FUNCTION ENUMERATED-SET?) NULL)
   (DEFINE-FUNCTION-OBJECT "ENUMERATED-LIST?"
    "(DEFUN (ENUMERATED-LIST? BOOLEAN) ((SELF OBJECT)))"
    (CL:FUNCTION ENUMERATED-LIST?) NULL)
   (DEFINE-FUNCTION-OBJECT "CANONICALIZE-PROPOSITION-TREE"
    "(DEFUN (CANONICALIZE-PROPOSITION-TREE OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION CANONICALIZE-PROPOSITION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "ERASE-PROPOSITION"
    "(DEFUN ERASE-PROPOSITION ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION ERASE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-EQUIVALENCE-PROPOSITION"
    "(DEFUN (UPDATE-EQUIVALENCE-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION UPDATE-EQUIVALENCE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "SKOLEMIZE-EXISTS-PROPOSITION"
    "(DEFUN (SKOLEMIZE-EXISTS-PROPOSITION PROPOSITION) ((EXISTSPROPOSITION PROPOSITION)))"
    (CL:FUNCTION SKOLEMIZE-EXISTS-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-UPDATE-TOP-LEVEL-PROPOSITION"
    "(DEFUN (HELP-UPDATE-TOP-LEVEL-PROPOSITION (CONS OF PROPOSITION)) ((PROPOSITION PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION HELP-UPDATE-TOP-LEVEL-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "INVERT-UPDATE-MODE"
    "(DEFUN (INVERT-UPDATE-MODE KEYWORD) ((UPDATEMODE KEYWORD)))"
    (CL:FUNCTION INVERT-UPDATE-MODE) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFAULTIFY-UPDATE-MODE"
    "(DEFUN (DEFAULTIFY-UPDATE-MODE KEYWORD) ((UPDATEMODE KEYWORD)))"
    (CL:FUNCTION DEFAULTIFY-UPDATE-MODE) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-TOP-LEVEL-PROPOSITION"
    "(DEFUN (UPDATE-TOP-LEVEL-PROPOSITION (CONS OF PROPOSITION)) ((TREE OBJECT) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION UPDATE-TOP-LEVEL-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "STANDARDIZE-PROPOSITION-TREE"
    "(DEFUN (STANDARDIZE-PROPOSITION-TREE OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION STANDARDIZE-PROPOSITION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-PROPOSITION"
    "(DEFUN (UPDATE-PROPOSITION (CONS OF PROPOSITION)) ((TREE OBJECT) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION UPDATE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-TOP-LEVEL-TERM"
    "(DEFUN (BUILD-TOP-LEVEL-TERM OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION BUILD-TOP-LEVEL-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "CONCEIVE-TERM"
    "(DEFUN (CONCEIVE-TERM OBJECT) ((TREE OBJECT)) :DOCUMENTATION \"`tree' is a term expression (a string or an s-expression),
or is a class reference (a symbol or surrogate).  Return a (possibly 
newly-conceived) term representing the internalized representation of that term.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? TRUE :LISP-MACRO? FALSE)"
    (CL:FUNCTION CONCEIVE-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "CONCEIVE-SENTENCE"
    "(DEFUN (CONCEIVE-SENTENCE OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION CONCEIVE-SENTENCE) NULL)
   (DEFINE-FUNCTION-OBJECT "CONCEIVE-FORMULA"
    "(DEFUN (CONCEIVE-FORMULA OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION CONCEIVE-FORMULA) NULL)
   (DEFINE-FUNCTION-OBJECT "SMART-UPDATE-PROPOSITION"
    "(DEFUN (SMART-UPDATE-PROPOSITION OBJECT) ((TREE OBJECT) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION SMART-UPDATE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT"
    "(DEFUN (ASSERT OBJECT) ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Assert the truth of `proposition'.  Return the asserted proposition object.
KIF example:  \\\"(assert (happy Fred))\\\" asserts that Fred is indeed happy.
Note that for this assertion to succeed, the relation `happy' must already
be defined.  If the constant `Fred' has not yet been created, it is
automatically created as a side-effect of calling `assert'.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %ASSERT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRESUME"
    "(DEFUN (PRESUME OBJECT) ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Presume the default truth of `proposition'.  Return the presumed
proposition object.  KIF example:  \\\"(presume (happy Fred))\\\" states that Fred
is most probably happy.  Note, that for this to succeed, the relation
`happy' must already be defined (see `assert').\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %PRESUME) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRACT"
    "(DEFUN (RETRACT OBJECT) ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Retract the truth of `proposition'.  Return the retracted proposition
object.  KIF example:  \\\"(retract (happy Fred))\\\" retracts that Fred is
happy.  Note that for this assertion to succeed, the relation `happy' must already
be defined.  If the constant `Fred' has not yet been created, it is
automatically created as a side-effect of calling `retract'.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %RETRACT) NULL)
   (DEFINE-FUNCTION-OBJECT "DENY"
    "(DEFUN (DENY OBJECT) ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Assert the falsity of `proposition'.  Return the asserted proposition
object.  KIF example:  \\\"(deny (happy Fred))\\\" asserts that Fred is not happy,
which could have been done equivalently by \\\"(assert (not (happy Fred)))\\\".
Note, that for this to succeed, the relation `happy' must already be defined
(see `assert').\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %DENY) NULL)
   (DEFINE-FUNCTION-OBJECT "CONCEIVE"
    "(DEFUN (CONCEIVE OBJECT) ((FORMULA PARSE-TREE)) :DOCUMENTATION \"Guess whether 'formula' represents a term or a sentence/proposition.
If we are not sure, assume its a proposition.
If its, a term, return its internal representation.  If a proposition,
construct a proposition for 'formula' without asserting its truth value.
Return the conceived proposition object.  KIF example: \\\"(conceive (happy Fred))\\\"
builds the proposition expressing that Fred is happy without explictly asserting
or denying it.  Note, that for this to succeed, the relation `happy' must already
be defined (see `assert').  If the logic constant `Fred' has not yet been
created, it is automatically created as a side-effect of calling `conceive'.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %CONCEIVE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNASSERT"
    "(DEFUN (UNASSERT OBJECT) ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Retract the truth, falsity or inconsistency of `proposition'.  This is a
more general version of `retract' that also handles falsity.  For example, if
we assert the proposition \\\"(not (sad Fred))\\\", and then execute the statement
\\\"(unassert (sad Fred))\\\", the truth value of the proposition \\\"(sad Fred)\\\"
will be set to UNKNOWN.  If we had called `retract' in place of `unassert',
the proposition \\\"(sad Fred)\\\" would remain set to FALSE.   Note that for this
unassertion to succeed, the logic constant `Fred' and the relation `sad' must
already be defined.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %UNASSERT) NULL)
   (DEFINE-FUNCTION-OBJECT "UNASSERT-PROPOSITION"
    "(DEFUN UNASSERT-PROPOSITION ((SELF PROPOSITION)) :DOCUMENTATION \"Retract the truth, falsity or inconsistency of the proposition `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNASSERT-PROPOSITION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DELETED? BOOLEAN) ((SELF PROPOSITION)))"
    (CL:FUNCTION DELETED?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DELETED?-SETTER BOOLEAN) ((SELF PROPOSITION) (VALUE BOOLEAN)))"
    (CL:FUNCTION DELETED?-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "DELETED-PROPOSITION?"
    "(DEFUN (DELETED-PROPOSITION? BOOLEAN) ((SELF PROPOSITION)))"
    (CL:FUNCTION DELETED-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-PROPOSITION"
    "(DEFUN (DESTROY-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION)) :DOCUMENTATION \"Retract and destroy the proposition 'proposition'.
Recursively destroy all propositions that reference 'proposition'.
Also, destroy all satellite propositions of 'proposition'.\")"
    (CL:FUNCTION DESTROY-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-LOGIC-INSTANCE"
    "(DEFUN DESTROY-LOGIC-INSTANCE ((SELF OBJECT)))"
    (CL:FUNCTION DESTROY-LOGIC-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-TERM"
    "(DEFUN DESTROY-TERM ((SELF LOGIC-OBJECT)) :DOCUMENTATION \"Destroy all propositions that reference 'self',
and mark it as 'deleted?', thereby making it invisible within class
extensions.  Unlink descriptions from native relations.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DESTROY-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-INSTANCE"
    "(DEFUN DESTROY-INSTANCE ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Destroy all propositions that reference 'self',
and mark it as 'deleted?', thereby making it invisible within class
extensions.\")" (CL:FUNCTION DESTROY-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-OBJECT"
    "(DEFUN DESTROY-OBJECT ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Destroy `self' which can be a term or a proposition.  Destroy all
propositions that reference 'self' and mark it as 'deleted?' (thereby
making it invisible within class extensions).\")"
    (CL:FUNCTION DESTROY-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY"
    "(DEFUN (DESTROY OBJECT) ((OBJECTSPEC PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Find an object or proposition as specified by `objectSpec', and destroy all
propositions and indices that reference it.  `objectSpec' must be a name or
a parse tree that evaluates to a proposition.  Return the deleted object, or
NULL if no matching object was found.\")" (CL:FUNCTION %DESTROY) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATION-IN-MODULE?"
    "(DEFUN (RELATION-IN-MODULE? BOOLEAN) ((SELF NAMED-DESCRIPTION)))"
    (CL:FUNCTION RELATION-IN-MODULE?) NULL)
   (DEFINE-FUNCTION-OBJECT "INTRODUCE-MODULE"
    "(DEFUN INTRODUCE-MODULE ((MODULE MODULE)) :PUBLIC? TRUE)"
    (CL:FUNCTION INTRODUCE-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-LOGIC-MODULE-HOOK"
    "(DEFUN CLEAR-LOGIC-MODULE-HOOK ((MODULE MODULE)))"
    (CL:FUNCTION CLEAR-LOGIC-MODULE-HOOK) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-INSTANCES"
    "(DEFUN CLEAR-INSTANCES (|&REST| (NAME NAME)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Destroy all instances belonging to module `name' or any of its children.
Leave meta-objects, e.g., concepts and relations, alone.
If no `name' is supplied, the current module will be cleared after
confirming with the user.\")" (CL:FUNCTION %CLEAR-INSTANCES)
    (CL:FUNCTION CLEAR-INSTANCES-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "DO-CLEAR-INSTANCES"
    "(DEFUN DO-CLEAR-INSTANCES ((MODULE MODULE)) :DOCUMENTATION \"Function version of `clear-instances' that evaluates its argument.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DO-CLEAR-INSTANCES) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-LOGIC-CONTEXT-HOOK"
    "(DEFUN DESTROY-LOGIC-CONTEXT-HOOK ((SELF CONTEXT)))"
    (CL:FUNCTION DESTROY-LOGIC-CONTEXT-HOOK) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-CACHES"
    "(DEFUN CLEAR-CACHES () :DOCUMENTATION \"Clear all query and memoization caches.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION CLEAR-CACHES) NULL)
   (DEFINE-FUNCTION-OBJECT "RESET-POWERLOOM"
    "(DEFUN RESET-POWERLOOM () :DOCUMENTATION \"Reset PowerLoom to its initial state.
CAUTION: This will destroy all loaded knowledge bases and might break other
loaded STELLA systems if they do reference PowerLoom symbols in their code.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION RESET-POWERLOOM) NULL)
   (DEFINE-FUNCTION-OBJECT "CONS-LESS-THAN?"
    "(DEFUN (CONS-LESS-THAN? BOOLEAN) ((O1 CONS) (O2 CONS)))"
    (CL:FUNCTION CONS-LESS-THAN?) NULL)
   (DEFINE-FUNCTION-OBJECT "SAFE-STRING-LESS?"
    "(DEFUN (SAFE-STRING-LESS? BOOLEAN) ((S1 STRING) (S2 STRING)))"
    (CL:FUNCTION SAFE-STRING-LESS?) NULL)
   (DEFINE-FUNCTION-OBJECT "SAFE-QUANTITY-LESS?"
    "(DEFUN (SAFE-QUANTITY-LESS? BOOLEAN) ((Q1 QUANTITY) (O2 OBJECT)))"
    (CL:FUNCTION SAFE-QUANTITY-LESS?) NULL)
   (DEFINE-FUNCTION-OBJECT "SAFE-QUANTITY-GREATER-EQUAL?"
    "(DEFUN (SAFE-QUANTITY-GREATER-EQUAL? BOOLEAN) ((Q1 QUANTITY) (O2 OBJECT)))"
    (CL:FUNCTION SAFE-QUANTITY-GREATER-EQUAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "OBJECT-NAME-LESS-THAN?"
    "(DEFUN (OBJECT-NAME-LESS-THAN? BOOLEAN) ((O1 LOGIC-OBJECT) (O2 LOGIC-OBJECT)))"
    (CL:FUNCTION OBJECT-NAME-LESS-THAN?) NULL)
   (DEFINE-FUNCTION-OBJECT "MODULE-NAME-LESS-THAN?"
    "(DEFUN (MODULE-NAME-LESS-THAN? BOOLEAN) ((M1 CONTEXT) (M2 CONTEXT)))"
    (CL:FUNCTION MODULE-NAME-LESS-THAN?) NULL)
   (DEFINE-FUNCTION-OBJECT "PROPOSITION-LESS-THAN?"
    "(DEFUN (PROPOSITION-LESS-THAN? BOOLEAN) ((P1 PROPOSITION) (P2 PROPOSITION)))"
    (CL:FUNCTION PROPOSITION-LESS-THAN?) NULL)
   (DEFINE-FUNCTION-OBJECT "PROPOSITION-HEAD-SORT-STRING"
    "(DEFUN (PROPOSITION-HEAD-SORT-STRING STRING) ((P PROPOSITION)))"
    (CL:FUNCTION PROPOSITION-HEAD-SORT-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "OBJECT-SORT-STRING"
    "(DEFUN (OBJECT-SORT-STRING STRING) ((O OBJECT)))"
    (CL:FUNCTION OBJECT-SORT-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGIC-FORM-LESS?"
    "(DEFUN (LOGIC-FORM-LESS? BOOLEAN) ((O1 OBJECT) (O2 OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"A sorting predicate for objects `o1' and `o2' that can appear in logical
forms.  Performs a combined numeric and lexocographic sort that accounts
for lists, collections and propositions.  Numbers precede all other values,
`null' follows all other values.\")" (CL:FUNCTION LOGIC-FORM-LESS?)
    NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-PROPOSITIONS"
    "(DEFUN STARTUP-PROPOSITIONS () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-PROPOSITIONS) NULL)
   (CL:LET*
    ((FUNCTION
      (LOOKUP-FUNCTION SYM-PROPOSITIONS-LOGIC-STARTUP-PROPOSITIONS)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
     SYM-PROPOSITIONS-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupPropositions") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-PROPOSITIONS ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-PROPOSITIONS1) (HELP-STARTUP-PROPOSITIONS2)
    (HELP-STARTUP-PROPOSITIONS3) (HELP-STARTUP-PROPOSITIONS4)
    (HELP-STARTUP-PROPOSITIONS5))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (HELP-STARTUP-PROPOSITIONS6))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (HELP-STARTUP-PROPOSITIONS7))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (HELP-STARTUP-PROPOSITIONS8) (HELP-STARTUP-PROPOSITIONS9)
    (HELP-STARTUP-PROPOSITIONS10) (HELP-STARTUP-PROPOSITIONS11)
    (HELP-STARTUP-PROPOSITIONS12))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ZERO-VARIABLES-VECTOR VARIABLES-VECTOR (NEW VARIABLES-VECTOR :ARRAY-SIZE 0) :DOCUMENTATION \"Save space by structure-sharing zero-length variable vectors.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PARTIAL-SUPPORT-COUNTER* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *OPERATOR-NAME-TO-SURROGATE-TABLE* (PROPERTY-LIST OF KEYWORD SURROGATE) (NEW PROPERTY-LIST :THE-PLIST (BQUOTE (:AND /PL-KERNEL-KB/@AND :OR /PL-KERNEL-KB/@OR :NOT /PL-KERNEL-KB/@NOT :FORALL /PL-KERNEL-KB/@FORALL :EXISTS /PL-KERNEL-KB/@EXISTS :EQUIVALENT /PL-KERNEL-KB/@EQUIVALENT :FAIL /PL-KERNEL-KB/@FAIL :COLLECT-INTO /PL-KERNEL-KB/@COLLECT-INTO :IMPLIES /PL-KERNEL-KB/@SUBSET-OF))) :DOCUMENTATION \"Maps names of KIF operators to relational surrogates.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOGIC-MODULE* MODULE (GET-STELLA-MODULE \"LOGIC\" TRUE) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PL-KERNEL-MODULE* MODULE (GET-STELLA-MODULE \"PL-KERNEL\" TRUE) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *NOW-TIMESTAMP* TIMESTAMP 0 :DOCUMENTATION \"The NOW time stamp is incremented whenever a series
of one or more updates is followed by a query.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LAST-KB-ACTION* KEYWORD :UPDATE-PROPOSITION :DOCUMENTATION \"Records whether the last KB access was a query or
an update.  Used to determine when to increment the NOW time stamp
counter.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL BOTTOM LOGIC-OBJECT NULL :PUBLIC? TRUE :DOCUMENTATION \"The undefined individual.  Denotes the non-existence of
an individual in whatever slot it occupies.\")")
    (CL:SETQ BOTTOM (CREATE-SKOLEM NULL SYM-PROPOSITIONS-LOGIC-BOTTOM))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EVALUATIONMODE* KEYWORD :EXTENSIONAL-ASSERTION :DOCUMENTATION \"Indicates the context for evaluating a proposition.  One
of :DESCRIPTION, :INTENSIONAL-ASSERTION, or :EXTENSIONAL-ASSERTION.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CLIPPINGENABLED?* BOOLEAN TRUE :DOCUMENTATION \"When enabled, slot-value assertions can be retracted
by later conflicting assertions.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *NATURALDEDUCTIONMODE?* BOOLEAN TRUE :DOCUMENTATION \"When enabled, blocks normalizations that significantly
change the behavior of inference rules.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CONTEXT-DEPENDENT-SEARCH-MODE?* BOOLEAN FALSE :DOCUMENTATION \"Signals that we are performing search across multiple
contexts.  Used to disable retraction from collections, since that increases
the overhead of the context mechanism.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *COMPUTEDQUERY?* BOOLEAN FALSE :DOCUMENTATION \"Used to signal 'ground-value-of' that it can
call 'bound-to' safely.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SKOLEM-ID-COUNTER* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *VARIABLEIDCOUNTER* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *FREESKOLEMS* CONS NULL :DOCUMENTATION \"Cons-list of top-level existentially-quantified skolems.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT TRUE-TRUTH-VALUE TRUTH-VALUE (NEW TRUTH-VALUE :POLARITY :TRUE :STRENGTH :STRICT :POSITIVE-SCORE 1.0) :DOCUMENTATION \"Value representing TRUE.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT FALSE-TRUTH-VALUE TRUTH-VALUE (NEW TRUTH-VALUE :POLARITY :FALSE :STRENGTH :STRICT :POSITIVE-SCORE -1.0) :DOCUMENTATION \"Value representing FALSE.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT DEFAULT-TRUE-TRUTH-VALUE TRUTH-VALUE (NEW TRUTH-VALUE :POLARITY :TRUE :STRENGTH :DEFAULT :POSITIVE-SCORE 0.8) :DOCUMENTATION \"Value representing DEFAULT-TRUE.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT DEFAULT-FALSE-TRUTH-VALUE TRUTH-VALUE (NEW TRUTH-VALUE :POLARITY :FALSE :STRENGTH :DEFAULT :POSITIVE-SCORE -0.8) :DOCUMENTATION \"Value representing DEFAULT-FALSE.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT UNKNOWN-TRUTH-VALUE TRUTH-VALUE (NEW TRUTH-VALUE :POLARITY :UNKNOWN) :DOCUMENTATION \"Value representing UNKNOWN.  Needed for those cases
where we need a non-NULL truth value to represents UNKNOWN.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT INCONSISTENT-TRUTH-VALUE TRUTH-VALUE (NEW TRUTH-VALUE :POLARITY :INCONSISTENT :STRENGTH :STRICT) :DOCUMENTATION \"Value representing a contradiction.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *SUPPRESSUNTYPEDTYPEERROR?* BOOLEAN FALSE :DOCUMENTATION \"Used by 'safe-logical-type' to ask for a type
without signalling an error if none exists.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EQUIVALENCE-COLLECTIONS?* BOOLEAN TRUE :DOCUMENTATION \"Experiment with equality reasoning on collections.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT TRUE-PROPOSITION PROPOSITION (NEW PROPOSITION :KIND :CONSTANT :OPERATOR @TRUE :ARGUMENTS (NEW ARGUMENTS-VECTOR :ARRAY-SIZE 0) :TRUTH-VALUE TRUE-TRUTH-VALUE))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT FALSE-PROPOSITION PROPOSITION (NEW PROPOSITION :KIND :CONSTANT :OPERATOR @FALSE :ARGUMENTS (NEW ARGUMENTS-VECTOR :ARRAY-SIZE 0) :TRUTH-VALUE FALSE-TRUTH-VALUE))")
    (CL:SETF (%SURROGATE-VALUE SGT-PROPOSITIONS-STELLA-TRUE)
     TRUE-PROPOSITION)
    (CL:SETF (%SURROGATE-VALUE SGT-PROPOSITIONS-STELLA-FALSE)
     FALSE-PROPOSITION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ANONYMOUS-VARIABLE-NAME SYMBOL (QUOTE ?) :DOCUMENTATION \"Variables with name 'ANONYMOUS-VARIABLE-NAME' are considered
anonymous, and are not assumed to be identical to any other variable also named
'ANONYMOUS-VARIABLE-NAME'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MISSING-KEY-VALUE-LIST* KEY-VALUE-LIST (NEW KEY-VALUE-LIST) :DOCUMENTATION \"Represents a key-value list that should never be used.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *AUTOMATICINSTANCETABLE* (KEY-VALUE-LIST OF SYMBOL LOGIC-OBJECT) *MISSING-KEY-VALUE-LIST* :DOCUMENTATION \"Used by 'evaluate-automatic-instance' to
record current bindings of automatic instance symbols.\")")
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-CREATE
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (ADD-HOOK *REDEFINE-RELATION-HOOKS*
     SYM-PROPOSITIONS-LOGIC-TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DEFAULTCREATIONTYPE* SURROGATE NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *STRUCTURED-OBJECTS-INDEX* (KEY-VALUE-MAP OF INTEGER-WRAPPER (LIST OF CONTEXT-SENSITIVE-OBJECT)) (NEW KEY-VALUE-MAP) :DOCUMENTATION \"Contains a table of propositions and descriptions, indexed by a
structure hash code which might be shared by different objects.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DONT-CHECK-FOR-DUPLICATE-PROPOSITIONS?* BOOLEAN FALSE :DOCUMENTATION \"If TRUE never check for the existence of duplicate
propositions when building a new proposition.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *VISITEDUNFASTENEDDEFININGPROPOSITIONS* LIST NULL :DOCUMENTATION \"Used by 'recursively-fasten-down-propositions'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *AUTO-COERCE-PROPOSITIONAL-ARGUMENTS?* BOOLEAN FALSE :DOCUMENTATION \"If TRUE, automatically coerce propositional arguments of a
proposition, even if the corresponding argument type of the hosting relation
doesn't indicate that.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TYPE-CHECK-POLICY* KEYWORD :AUTOMATICALLY-FIX-TYPE-VIOLATIONS :DOCUMENTATION \"Three policies are implemented:
   :AUTOMATICALLY-FIX-TYPE-VIOLATIONS asserts missing types to fix type
       violations (default),
   :REPORT-TYPE-VIOLATIONS complains about missing or incorrect types,
   :SIGNAL-TYPE-VIOLATIONS throws exception for missing or incorrect types, and
   :IGNORE-TYPE-VIOLATIONS which disables all type checking.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TYPECHECKMODE* KEYWORD :POST-TYPE-VIOLATIONS :DOCUMENTATION \"Controls the behavior of the type-checking
routines in the event that a type-check fails.  Options are:
  :POST-TYPE-VIOLATIONS              push offending proposition onto queue,
  :REPORT-TYPE-VIOLATIONS            print occasions of failed type checks,
  :SIGNAL-TYPE-VIOLATIONS            throw exception for failed type checks,
  :AUTOMATICALLY-FIX-TYPE-VIOLATIONS assert missing types on propositions, and
  :IGNORE-TYPE-VIOLATIONS            don't perform any type checking at all.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CHECK-TYPES-AGENDA* (KEY-VALUE-LIST OF PROPOSITION CHECK-TYPES-RECORD) (NEW KEY-VALUE-LIST) :DOCUMENTATION \"List of propositions that have failed a type check,
but might pass once finalization is complete.\")")
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-STELLA-ASSERT
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-PRESUME
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-STELLA-ASSERT
     KWD-PROPOSITIONS-CPP KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-STELLA-RETRACT
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-DENY
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-STELLA-CONCEIVE
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-UNASSERT
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-DESTROY
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (ADD-HOOK *DEFINE-MODULE-HOOKS*
     SYM-PROPOSITIONS-LOGIC-INTRODUCE-MODULE)
    (ADD-HOOK *CLEAR-MODULE-HOOKS*
     SYM-PROPOSITIONS-LOGIC-CLEAR-LOGIC-MODULE-HOOK)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-CLEAR-INSTANCES
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (ADD-HOOK *DESTROY-CONTEXT-HOOKS*
     SYM-PROPOSITIONS-LOGIC-DESTROY-LOGIC-CONTEXT-HOOK))))
