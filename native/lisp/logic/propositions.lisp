;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997-2000              | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PROPOSITIONS-INDEX NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-INSTANCES-INDEX NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-BACKLINKS-INDEX NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS-LIST NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DEPENDENT-ISA-PROPOSITIONS-LIST NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PREDICATE-PROPOSITIONS-TABLE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DEPENDENT-DESCRIPTIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-ALL-SURROGATE-VALUE-INVERSES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-BAD? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-ROOT-TYPE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-VARIABLE-VALUE-INVERSE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-SURROGATE-VALUE-INVERSE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-CS-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-DELETED-OBJECT? NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-SKOLEM NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SKOLEM-TYPE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SKOLEM-NAME NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-VARIABLE-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DEFINING-PROPOSITION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-BOUND-TO-OFFSET NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-OBJECT-VECTOR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-ARGUMENTS-VECTOR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-VARIABLES-VECTOR NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDEX NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-FORWARD-GOAL NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-MASTER-RULE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-QUERY-BODY NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-INPUT-BINDINGS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CACHE-ID NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CONSEQUENT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDICES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DEFERRED-CONTRAPOSITIVES? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-INTERNAL-VARIABLES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-QUERY-PATTERNS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-RELATIVE-COMPLEMENT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-NATIVE-RELATION-BACK-POINTER NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-DOCUMENTATION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-RELATION-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-TERM-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-IO-VARIABLE-NAMES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-IO-VARIABLE-TYPES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-EXTENSION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PARTIAL-MATCH-SCORE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SET-OF-SUPPORT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-TIMESTAMP NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-TRUTH-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-POSITIVE-SCORE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-PARTIAL-SUPPORT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-FACT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-AXIOM NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SCORE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-ID NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-ARGUMENT-SCORES NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-VARIABLE-TYPE? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SATELLITE-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-UNFASTENED? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-WEIGHT-DELTA NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SUPPORT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-KIND NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-TRUTH-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-ARGUMENTS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-OPERATOR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-RELATIONREF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-WEIGHT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-INTEGER-LOGIC-WRAPPER NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS-INDEX NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-FLOAT-LOGIC-WRAPPER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-STRING-LOGIC-WRAPPER NULL)
(CL:DEFVAR KWD-PROPOSITIONS-AND NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-AND NULL)
(CL:DEFVAR KWD-PROPOSITIONS-OR NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-OR NULL)
(CL:DEFVAR KWD-PROPOSITIONS-NOT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-NOT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-FORALL NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-FORALL NULL)
(CL:DEFVAR KWD-PROPOSITIONS-EXISTS NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-EXISTS NULL)
(CL:DEFVAR KWD-PROPOSITIONS-EQUIVALENT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-EQUIVALENT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-FAIL NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-FAIL NULL)
(CL:DEFVAR KWD-PROPOSITIONS-COLLECT-INTO NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-COLLECT-INTO NULL)
(CL:DEFVAR KWD-PROPOSITIONS-IMPLIES NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-FUNCTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-PREDICATE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-ISA NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DESCRIPTIVE? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-CODE-ONLY? NULL)
(CL:DEFVAR KWD-PROPOSITIONS-ERROR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-PROPOSITIONS-INTERNAL NULL)
(CL:DEFVAR KWD-PROPOSITIONS-PAGING NULL)
(CL:DEFVAR KWD-PROPOSITIONS-CONTEXT-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-INSTANCES-INTERNAL NULL)
(CL:DEFVAR KWD-PROPOSITIONS-CONTEXT-INSTANCES NULL)
(CL:DEFVAR KWD-PROPOSITIONS-UPDATE-PROPOSITION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-EXECUTE-QUERY NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-BOTTOM NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-CLASS NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-LITERAL NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-BOOLEAN NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-CLASS NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-FUNCTION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-VARIABLE-ARITY NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-COLLECTION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION-COMPUTATION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-DESCRIPTION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-RETRACT-TRUE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-FUNCTION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-ISA NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-TRUE-DEMON NULL)
(CL:DEFVAR KWD-PROPOSITIONS-PREDICATE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-FALSE-DEMON NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-THING NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-UNKNOWN-DEMON NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-MASTER-PROPOSITION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-ASSERT-TRUE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-PRESUME-TRUE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-ASSERT-FALSE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-PRESUME-FALSE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-RETRACT-FALSE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-CONSTANT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-ASSERT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-RETRACT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-CONCEIVE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-HIDDEN-RELATION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-HIDDEN-INSTANCE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-KB-UPDATE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-META-KB-UPDATE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-STORAGE-SLOT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-SURROGATE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-RELATION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-WARNING NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-META-INFERENCE-CACHE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-IOTA? NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-SET NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-SET NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CONFLICTING-DEFAULT-VALUES NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-TRUE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-FALSE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SETOFALL NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-THE-ONLY NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-KAPPA NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CREATE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-CONS NULL)
(CL:DEFVAR KWD-PROPOSITIONS-INTENSIONAL-ASSERTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-? NULL)
(CL:DEFVAR KWD-PROPOSITIONS-COMMON-LISP NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-CLASS-EXTENSION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-SUBRELATION-LINK? NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-MEMBER-OF NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-STRING-WRAPPER NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CONSTANT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-TRUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-FALSE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-= NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-AND NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-OR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-NOT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PL-KERNEL-KB-MEMBER-OF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-IMPLIES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-EXISTS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-FORALL NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-FAIL NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-COLLECT-INTO NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-ABOUT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-SLOT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DIRECTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-FORWARD NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-BACKWARD NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-FORWARD-ONLY? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-BACKWARD-ONLY? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-SETOF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-LISTOF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-EQUIVALENT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-POLYMORPHIC NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PL-KERNEL-KB-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PL-KERNEL-KB-CUT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-VALUE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-QUANTITY NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-DATE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-FLOAT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-AUTOMATICALLY-FIX-TYPE-VIOLATIONS NULL)
(CL:DEFVAR KWD-PROPOSITIONS-POST-TYPE-VIOLATIONS NULL)
(CL:DEFVAR KWD-PROPOSITIONS-REPORT-TYPE-VIOLATIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-ASSERTED-BY-TYPE-CHECKER? NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-CHECK-TYPES-RECORD NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PARENT-PROPOSITION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PARENT-DESCRIPTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-MODULE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-TOTAL NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-LISTOF NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PL-KERNEL-KB-LIST NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-FALS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-SOME NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CONFIDENCE-LEVEL NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-DEFAULT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-LAMBDA NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PL-KERNEL-KB-LISTOF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-BAGOF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-ASSERT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-PRESUME NULL)
(CL:DEFVAR KWD-PROPOSITIONS-CPP NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-RETRACT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DENY NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CONCEIVE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-UNASSERT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-DELETED NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-MODULE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-INTRODUCE-MODULE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-PROTECT-SURROGATES? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CLEAR-LOGIC-MODULE-HOOK NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-CLEAR-INSTANCES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-MONOTONIC? NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STELLA-WORLD NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-DESTROY-CONTEXT-HOOK NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOGIC-STARTUP-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *STRINGIFIED-DESCRIPTION-INDEX*
  *KIF-SENTENCE-OPERATORS* *INHIBITRELATIONFINALIZATION?*
  *DESCRIPTIONUNDERCONSTRUCTION* *UNFINALIZED-RELATIONS*
  *LOGICVARIABLETABLE* STANDARD-ERROR *TERMUNDERCONSTRUCTION*
  *DONTUSEDEFAULTKNOWLEDGE?* *QUERYITERATOR* STANDARD-WARNING
  *SUPPRESSNONLOGICOBJECTWARNING?* TRUE-TRUTH-VALUE FALSE-TRUTH-VALUE
  DEFAULT-TRUE-TRUTH-VALUE DEFAULT-FALSE-TRUTH-VALUE
  *DEFERINGDEFAULTFORWARDINFERENCES?* STANDARD-OUTPUT
  *INVISIBLEASSERTION?* *MODULE* EOL *PRINTREADABLY?* NULL-FLOAT-WRAPPER
  NIL-NON-PAGING-INDEX NIL-PAGING-INDEX *LOADINGREGENERABLEOBJECTS?*
  TRUE-WRAPPER FALSE-WRAPPER NIL-LIST *CONTEXT*))

;;; (DEFCLASS BACKLINKS-INDEX ...)

(CL:DEFCLASS BACKLINKS-INDEX (STANDARD-OBJECT)
  ((DEPENDENT-PROPOSITIONS-LIST :ALLOCATION :INSTANCE :ACCESSOR
    %DEPENDENT-PROPOSITIONS-LIST)
   (DEPENDENT-ISA-PROPOSITIONS-LIST :ALLOCATION :INSTANCE :ACCESSOR
    %DEPENDENT-ISA-PROPOSITIONS-LIST)
   (PREDICATE-PROPOSITIONS-TABLE :ALLOCATION :INSTANCE :ACCESSOR
    %PREDICATE-PROPOSITIONS-TABLE))
  (:DOCUMENTATION
   "Contains several types of indices pointing at dependent propositions."))

(CL:DEFUN NEW-BACKLINKS-INDEX ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE BACKLINKS-INDEX)))
   (CL:SETF (%PREDICATE-PROPOSITIONS-TABLE SELF) NULL)
   (CL:SETF (%DEPENDENT-ISA-PROPOSITIONS-LIST SELF) NULL)
   (CL:SETF (%DEPENDENT-PROPOSITIONS-LIST SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF BACKLINKS-INDEX))
  SGT-PROPOSITIONS-LOGIC-BACKLINKS-INDEX)

(CL:DEFUN ACCESS-BACKLINKS-INDEX-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS-LIST)
    (CL:IF SETVALUE? (CL:SETF (%DEPENDENT-PROPOSITIONS-LIST SELF) VALUE)
     (CL:SETQ VALUE (%DEPENDENT-PROPOSITIONS-LIST SELF))))
   ((CL:EQ SLOTNAME
     SYM-PROPOSITIONS-LOGIC-DEPENDENT-ISA-PROPOSITIONS-LIST)
    (CL:IF SETVALUE?
     (CL:SETF (%DEPENDENT-ISA-PROPOSITIONS-LIST SELF) VALUE)
     (CL:SETQ VALUE (%DEPENDENT-ISA-PROPOSITIONS-LIST SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-PREDICATE-PROPOSITIONS-TABLE)
    (CL:IF SETVALUE? (CL:SETF (%PREDICATE-PROPOSITIONS-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%PREDICATE-PROPOSITIONS-TABLE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFCLASS LOGIC-OBJECT ...)

(CL:DEFCLASS LOGIC-OBJECT (CONTEXT-SENSITIVE-OBJECT)
  ((ROOT-TYPE :ALLOCATION :INSTANCE :ACCESSOR %ROOT-TYPE)
   (VARIABLE-VALUE-INVERSE :ALLOCATION :INSTANCE :ACCESSOR
    %VARIABLE-VALUE-INVERSE)
   (EQUIVALENT-VALUE :ALLOCATION :INSTANCE :ACCESSOR %EQUIVALENT-VALUE)
   (SURROGATE-VALUE-INVERSE :ALLOCATION :INSTANCE :ACCESSOR
    %SURROGATE-VALUE-INVERSE)
   (DYNAMIC-SLOTS :ALLOCATION :INSTANCE :ACCESSOR %DYNAMIC-SLOTS)
   (DEPENDENT-PROPOSITIONS-INDEX :ALLOCATION :INSTANCE :ACCESSOR
    %DEPENDENT-PROPOSITIONS-INDEX))
  (:DOCUMENTATION
   "Object with propositions, and possibly a variable value."))

(CL:DEFUN NEW-LOGIC-OBJECT ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE LOGIC-OBJECT)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL)
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%HOME-CONTEXT SELF) *CONTEXT*)
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%EQUIVALENT-VALUE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%ROOT-TYPE SELF) NULL) (LOG-LOGIC-OBJECT SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LOGIC-OBJECT))
  SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)

(CL:DEFMETHOD DEPENDENT-DESCRIPTIONS ((SELF LOGIC-OBJECT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-DEPENDENT-DESCRIPTIONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

(CL:DEFMETHOD VARIABLE-VALUE-INVERSE ((SELF LOGIC-OBJECT))
  (CL:LET*
   ((ANSWER
     (ACCESS-IN-CONTEXT (%VARIABLE-VALUE-INVERSE SELF)
      (%HOME-CONTEXT SELF) FALSE)))
   (CL:IF (CL:EQ ANSWER NULL) NIL ANSWER)))

(CL:DEFMETHOD ALL-SURROGATE-VALUE-INVERSES ((SELF LOGIC-OBJECT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-ALL-SURROGATE-VALUE-INVERSES NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

(CL:DEFMETHOD BAD? ((SELF LOGIC-OBJECT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-STELLA-BAD? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:IF FALSE TRUE-WRAPPER FALSE-WRAPPER)
    ANSWER)))

(CL:DEFUN ACCESS-LOGIC-OBJECT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-ROOT-TYPE)
    (CL:IF SETVALUE? (CL:SETF (%ROOT-TYPE SELF) VALUE)
     (CL:SETQ VALUE (%ROOT-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-DEPENDENT-DESCRIPTIONS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-DEPENDENT-DESCRIPTIONS VALUE NULL)
     (CL:SETQ VALUE (DEPENDENT-DESCRIPTIONS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-VARIABLE-VALUE-INVERSE)
    (CL:IF SETVALUE?
     (CL:LET*
      ((OBJECT-000 SELF) (VALUE-000 VALUE)
       (OLD-VALUE-000 (%VARIABLE-VALUE-INVERSE OBJECT-000))
       (NEW-VALUE-000
        (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
         (%HOME-CONTEXT OBJECT-000) FALSE)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-000) NEW-VALUE-000)))
     (CL:SETQ VALUE (VARIABLE-VALUE-INVERSE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE)
    (CL:IF SETVALUE?
     (CL:LET*
      ((OBJECT-001 SELF) (VALUE-001 VALUE)
       (OLD-VALUE-001 (%EQUIVALENT-VALUE OBJECT-001))
       (NEW-VALUE-001
        (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001
         (%HOME-CONTEXT OBJECT-001) FALSE)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%EQUIVALENT-VALUE OBJECT-001) NEW-VALUE-001)))
     (CL:SETQ VALUE
      (ACCESS-IN-CONTEXT (%EQUIVALENT-VALUE SELF) (%HOME-CONTEXT SELF)
       FALSE))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-SURROGATE-VALUE-INVERSE)
    (CL:IF SETVALUE? (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) VALUE)
     (CL:SETQ VALUE (%SURROGATE-VALUE-INVERSE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-ALL-SURROGATE-VALUE-INVERSES)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-ALL-SURROGATE-VALUE-INVERSES VALUE NULL)
     (CL:SETQ VALUE (ALL-SURROGATE-VALUE-INVERSES SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

(CL:DEFMETHOD DELETED? ((SELF LOGIC-OBJECT))
  (CL:LET*
   ((DELETED?
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-STELLA-DELETED-OBJECT? NULL)))
   (CL:IF (CL:NOT (CL:EQ DELETED? NULL))
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN DELETED?) FALSE)))

(CL:DEFMETHOD DELETED?-SETTER ((SELF LOGIC-OBJECT) VALUE)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-PROPOSITIONS-STELLA-DELETED-OBJECT?
   (CL:IF VALUE TRUE-WRAPPER FALSE-WRAPPER) NULL)
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF LOGIC-OBJECT) STREAM)
  (PRINT-TOP-LEVEL-OBJECT SELF STREAM))

;;; (DEFUN LOG-LOGIC-OBJECT ...)

(CL:DEFUN LOG-LOGIC-OBJECT (SELF)
  (CL:WHEN
   (CL:OR (DESCRIPTION-MODE?)
    (ISA? SELF SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE))
   (CL:RETURN-FROM LOG-LOGIC-OBJECT))
  (CL:WHEN *LOADINGREGENERABLEOBJECTS?*
   (LOG-TO-SECONDARY-STORAGE-MANAGER SELF))
  (CL:WHEN (CL:NOT *LOADINGREGENERABLEOBJECTS?*)
   (PUSH (LOCALLY-CONCEIVED-INSTANCES *CONTEXT*) SELF)))

;;; (DEFCLASS SKOLEM ...)

(CL:DEFCLASS SKOLEM (LOGIC-OBJECT)
  ((SKOLEM-NAME :ALLOCATION :INSTANCE :ACCESSOR %SKOLEM-NAME)
   (VARIABLE-VALUE :ALLOCATION :INSTANCE :ACCESSOR %VARIABLE-VALUE)
   (DEFINING-PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR
    %DEFINING-PROPOSITION))
  (:DOCUMENTATION
   "Object whose identity and type are not fixed at creation time.
Potentially unifiable with any other object."))

(CL:DEFUN NEW-SKOLEM ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SKOLEM)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL)
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%HOME-CONTEXT SELF) *CONTEXT*)
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%EQUIVALENT-VALUE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%DEFINING-PROPOSITION SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE SELF) NULL)
   (CL:SETF (%SKOLEM-NAME SELF) NULL) (CL:SETF (%ROOT-TYPE SELF) NULL)
   (LOG-LOGIC-OBJECT SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SKOLEM))
  SGT-PROPOSITIONS-LOGIC-SKOLEM)

(CL:DEFUN ACCESS-SKOLEM-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-SKOLEM-TYPE)
    (CL:IF SETVALUE? (CL:SETF (%ROOT-TYPE SELF) VALUE)
     (CL:SETQ VALUE (%ROOT-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-SKOLEM-NAME)
    (CL:IF SETVALUE? (CL:SETF (%SKOLEM-NAME SELF) VALUE)
     (CL:SETQ VALUE (%SKOLEM-NAME SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-VARIABLE-VALUE)
    (CL:IF SETVALUE?
     (CL:LET*
      ((OBJECT-000 SELF) (VALUE-000 VALUE)
       (OLD-VALUE-000 (%VARIABLE-VALUE OBJECT-000))
       (NEW-VALUE-000
        (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
         (%HOME-CONTEXT OBJECT-000) FALSE)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%VARIABLE-VALUE OBJECT-000) NEW-VALUE-000)))
     (CL:SETQ VALUE
      (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SELF) (%HOME-CONTEXT SELF)
       FALSE))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-DEFINING-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%DEFINING-PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%DEFINING-PROPOSITION SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFCLASS PATTERN-VARIABLE ...)

(CL:DEFCLASS PATTERN-VARIABLE (SKOLEM)
  ((BOUND-TO-OFFSET :ALLOCATION :INSTANCE :ACCESSOR %BOUND-TO-OFFSET))
  (:DOCUMENTATION "A variable in a logical expression."))

(CL:DEFUN NEW-PATTERN-VARIABLE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PATTERN-VARIABLE)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL)
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%HOME-CONTEXT SELF) *CONTEXT*)
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%EQUIVALENT-VALUE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%DEFINING-PROPOSITION SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE SELF) NULL)
   (CL:SETF (%SKOLEM-NAME SELF) NULL) (CL:SETF (%ROOT-TYPE SELF) NULL)
   (CL:SETF (%BOUND-TO-OFFSET SELF) NULL-INTEGER) (LOG-LOGIC-OBJECT SELF)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PATTERN-VARIABLE))
  SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)

(CL:DEFUN ACCESS-PATTERN-VARIABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-BOUND-TO-OFFSET)
    (CL:IF SETVALUE?
     (CL:SETF (%BOUND-TO-OFFSET SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%BOUND-TO-OFFSET SELF)))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFCONSTANT ZERO-VARIABLES-VECTOR ...)

(CL:DEFVAR ZERO-VARIABLES-VECTOR NULL
  "Save space by structure-sharing zero-length variable vectors.")

;;; (DEFCLASS FORWARD-CHAINING-INDEX ...)

(CL:DEFCLASS FORWARD-CHAINING-INDEX (STANDARD-OBJECT)
  ((FORWARD-GOAL :ALLOCATION :INSTANCE :ACCESSOR %FORWARD-GOAL)
   (MASTER-RULE :ALLOCATION :INSTANCE :ACCESSOR %MASTER-RULE)
   (IO-VARIABLES :ALLOCATION :INSTANCE :ACCESSOR %IO-VARIABLES)
   (QUERY-BODY :ALLOCATION :INSTANCE :ACCESSOR %QUERY-BODY)
   (INPUT-BINDINGS :ALLOCATION :INSTANCE :ACCESSOR %INPUT-BINDINGS)
   (CACHE-ID :ALLOCATION :INSTANCE :ACCESSOR %CACHE-ID)
   (CONSEQUENT :ALLOCATION :INSTANCE :ACCESSOR %CONSEQUENT)))

(CL:DEFUN NEW-FORWARD-CHAINING-INDEX ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE FORWARD-CHAINING-INDEX)))
   (CL:SETF (%CONSEQUENT SELF) NULL) (CL:SETF (%CACHE-ID SELF) NULL)
   (CL:SETF (%INPUT-BINDINGS SELF) NULL) (CL:SETF (%QUERY-BODY SELF) NULL)
   (CL:SETF (%IO-VARIABLES SELF) NULL) (CL:SETF (%MASTER-RULE SELF) NULL)
   (CL:SETF (%FORWARD-GOAL SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FORWARD-CHAINING-INDEX))
  SGT-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDEX)

(CL:DEFUN ACCESS-FORWARD-CHAINING-INDEX-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-FORWARD-GOAL)
    (CL:IF SETVALUE? (CL:SETF (%FORWARD-GOAL SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-GOAL SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-MASTER-RULE)
    (CL:IF SETVALUE? (CL:SETF (%MASTER-RULE SELF) VALUE)
     (CL:SETQ VALUE (%MASTER-RULE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-IO-VARIABLES)
    (CL:IF SETVALUE? (CL:SETF (%IO-VARIABLES SELF) VALUE)
     (CL:SETQ VALUE (%IO-VARIABLES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-QUERY-BODY)
    (CL:IF SETVALUE? (CL:SETF (%QUERY-BODY SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-BODY SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-INPUT-BINDINGS)
    (CL:IF SETVALUE? (CL:SETF (%INPUT-BINDINGS SELF) VALUE)
     (CL:SETQ VALUE (%INPUT-BINDINGS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-CACHE-ID)
    (CL:IF SETVALUE? (CL:SETF (%CACHE-ID SELF) VALUE)
     (CL:SETQ VALUE (%CACHE-ID SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-CONSEQUENT)
    (CL:IF SETVALUE? (CL:SETF (%CONSEQUENT SELF) VALUE)
     (CL:SETQ VALUE (%CONSEQUENT SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFCLASS DESCRIPTION ...)

(CL:DEFCLASS DESCRIPTION (LOGIC-OBJECT)
  ((PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR %PROPOSITION)
   (IO-VARIABLES :ALLOCATION :INSTANCE :ACCESSOR %IO-VARIABLES)
   (INTERNAL-VARIABLES :ALLOCATION :INSTANCE :ACCESSOR
    %INTERNAL-VARIABLES)
   (QUERY-PATTERNS :ALLOCATION :INSTANCE :ACCESSOR %QUERY-PATTERNS)))

(CL:DEFUN NEW-DESCRIPTION ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE DESCRIPTION)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL)
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%HOME-CONTEXT SELF) *CONTEXT*)
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%EQUIVALENT-VALUE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%ROOT-TYPE SELF) NULL) (CL:SETF (%QUERY-PATTERNS SELF) NULL)
   (CL:SETF (%INTERNAL-VARIABLES SELF) ZERO-VARIABLES-VECTOR)
   (CL:SETF (%IO-VARIABLES SELF) NULL) (CL:SETF (%PROPOSITION SELF) NULL)
   (LOG-LOGIC-OBJECT SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DESCRIPTION))
  SGT-PROPOSITIONS-LOGIC-DESCRIPTION)

(CL:DEFMETHOD REPRESENTATIVE ((SELF DESCRIPTION))
  (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IO-VARIABLES SELF))) 0))

(CL:DEFMETHOD NATIVE-RELATION ((SELF DESCRIPTION))
  NULL)

(CL:DEFMETHOD DESCRIPTION-EXTENSION ((SELF DESCRIPTION))
  NIL-PAGING-INDEX)

(CL:DEFMETHOD FORWARD-CHAINING-INDICES ((SELF DESCRIPTION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDICES NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

(CL:DEFMETHOD DEFERRED-CONTRAPOSITIVES? ((SELF DESCRIPTION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-DEFERRED-CONTRAPOSITIVES? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:IF FALSE TRUE-WRAPPER FALSE-WRAPPER)
    ANSWER)))

(CL:DEFUN ACCESS-DESCRIPTION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-IO-VARIABLES)
    (CL:IF SETVALUE? (CL:SETF (%IO-VARIABLES SELF) VALUE)
     (CL:SETQ VALUE (%IO-VARIABLES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-INTERNAL-VARIABLES)
    (CL:IF SETVALUE? (CL:SETF (%INTERNAL-VARIABLES SELF) VALUE)
     (CL:SETQ VALUE (%INTERNAL-VARIABLES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-QUERY-PATTERNS)
    (CL:IF SETVALUE? (CL:SETF (%QUERY-PATTERNS SELF) VALUE)
     (CL:SETQ VALUE (%QUERY-PATTERNS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDICES)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDICES VALUE NULL)
     (CL:SETQ VALUE (FORWARD-CHAINING-INDICES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-DEFERRED-CONTRAPOSITIVES?)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-DEFERRED-CONTRAPOSITIVES? VALUE NULL)
     (CL:SETQ VALUE (DEFERRED-CONTRAPOSITIVES? SELF))))
   (CL:T
    (CL:COND
     ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-RELATIVE-COMPLEMENT)
      (CL:SETQ SLOTNAME SYM-PROPOSITIONS-LOGIC-COMPLEMENT-DESCRIPTION))
     (CL:T))
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFCLASS NAMED-DESCRIPTION ...)

(CL:DEFCLASS NAMED-DESCRIPTION (DESCRIPTION)
  ((DOCUMENTATION :ALLOCATION :INSTANCE :ACCESSOR %DOCUMENTATION)
   (RELATION-STRINGIFIED-SOURCE :ALLOCATION :INSTANCE :ACCESSOR
    %RELATION-STRINGIFIED-SOURCE)
   (IO-VARIABLE-NAMES :ALLOCATION :INSTANCE :ACCESSOR %IO-VARIABLE-NAMES)
   (IO-VARIABLE-TYPES :ALLOCATION :INSTANCE :ACCESSOR %IO-VARIABLE-TYPES)
   (EXTENSION :ALLOCATION :INSTANCE :ACCESSOR %EXTENSION)))

(CL:DEFUN NEW-NAMED-DESCRIPTION ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE NAMED-DESCRIPTION)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL)
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%HOME-CONTEXT SELF) *CONTEXT*)
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%EQUIVALENT-VALUE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%ROOT-TYPE SELF) NULL) (CL:SETF (%QUERY-PATTERNS SELF) NULL)
   (CL:SETF (%INTERNAL-VARIABLES SELF) ZERO-VARIABLES-VECTOR)
   (CL:SETF (%IO-VARIABLES SELF) NULL) (CL:SETF (%PROPOSITION SELF) NULL)
   (CL:SETF (%EXTENSION SELF) NULL)
   (CL:SETF (%IO-VARIABLE-TYPES SELF) NULL)
   (CL:SETF (%IO-VARIABLE-NAMES SELF) NULL)
   (CL:SETF (%RELATION-STRINGIFIED-SOURCE SELF) STELLA::NULL-STRING)
   (CL:SETF (%DOCUMENTATION SELF) STELLA::NULL-STRING)
   (LOG-LOGIC-OBJECT SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF NAMED-DESCRIPTION))
  SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)

(CL:DEFMETHOD NATIVE-RELATION ((SELF NAMED-DESCRIPTION))
  (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-PROPOSITIONS-LOGIC-NATIVE-RELATION-BACK-POINTER NULL))

(CL:DEFMETHOD NATIVE-RELATION-SETTER ((SELF NAMED-DESCRIPTION) VALUE)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-PROPOSITIONS-LOGIC-NATIVE-RELATION-BACK-POINTER VALUE NULL))

(CL:DEFMETHOD DESCRIPTION-EXTENSION ((SELF NAMED-DESCRIPTION))
  (CL:LET* ((V-007 (%EXTENSION SELF)))
   (CL:WHEN (CL:EQ V-007 NULL) (CL:SETQ V-007 NIL-PAGING-INDEX))
   (CL:LET* ((VALUE-000 V-007)) VALUE-000)))

(CL:DEFUN ACCESS-NAMED-DESCRIPTION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-DOCUMENTATION)
    (CL:IF SETVALUE?
     (CL:SETF (%DOCUMENTATION SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%DOCUMENTATION SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-RELATION-STRINGIFIED-SOURCE)
    (CL:IF SETVALUE?
     (CL:SETF (%RELATION-STRINGIFIED-SOURCE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%RELATION-STRINGIFIED-SOURCE SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-TERM-STRINGIFIED-SOURCE)
    (CL:IF SETVALUE?
     (CL:SETF (%RELATION-STRINGIFIED-SOURCE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%RELATION-STRINGIFIED-SOURCE SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-IO-VARIABLE-NAMES)
    (CL:IF SETVALUE? (CL:SETF (%IO-VARIABLE-NAMES SELF) VALUE)
     (CL:SETQ VALUE (%IO-VARIABLE-NAMES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-IO-VARIABLE-TYPES)
    (CL:IF SETVALUE? (CL:SETF (%IO-VARIABLE-TYPES SELF) VALUE)
     (CL:SETQ VALUE (%IO-VARIABLE-TYPES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-EXTENSION)
    (CL:IF SETVALUE? (CL:SETF (%EXTENSION SELF) VALUE)
     (CL:SETQ VALUE (%EXTENSION SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFCLASS TRUTH-VALUE ...)

(CL:DEFCLASS TRUTH-VALUE (LOGIC-OBJECT)
  ((POSITIVE-SCORE :ALLOCATION :INSTANCE :ACCESSOR %POSITIVE-SCORE)))

(CL:DEFUN NEW-TRUTH-VALUE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRUTH-VALUE)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) NULL)
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%HOME-CONTEXT SELF) *CONTEXT*)
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%EQUIVALENT-VALUE SELF) NULL)
   (CL:SETF (%VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%ROOT-TYPE SELF) NULL) (CL:SETF (%POSITIVE-SCORE SELF) 0.0d0)
   (LOG-LOGIC-OBJECT SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRUTH-VALUE))
  SGT-PROPOSITIONS-LOGIC-TRUTH-VALUE)

(CL:DEFUN ACCESS-TRUTH-VALUE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-POSITIVE-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%POSITIVE-SCORE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%POSITIVE-SCORE SELF)))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFCLASS PARTIAL-SUPPORT ...)

(CL:DEFCLASS PARTIAL-SUPPORT (STANDARD-OBJECT)
  ((FACT :ALLOCATION :INSTANCE :ACCESSOR %FACT)
   (AXIOM :ALLOCATION :INSTANCE :ACCESSOR %AXIOM)
   (SCORE :ALLOCATION :INSTANCE :ACCESSOR %SCORE)
   (ID :ALLOCATION :INSTANCE :ACCESSOR %ID)
   (ARGUMENT-SCORES :ALLOCATION :INSTANCE :ACCESSOR %ARGUMENT-SCORES)))

(CL:DEFUN NEW-PARTIAL-SUPPORT ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PARTIAL-SUPPORT)))
   (CL:SETF (%ARGUMENT-SCORES SELF) NULL)
   (CL:SETF (%ID SELF) NULL-INTEGER) (CL:SETF (%SCORE SELF) NULL-FLOAT)
   (CL:SETF (%AXIOM SELF) NULL) (CL:SETF (%FACT SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PARTIAL-SUPPORT))
  SGT-PROPOSITIONS-LOGIC-PARTIAL-SUPPORT)

(CL:DEFUN ACCESS-PARTIAL-SUPPORT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-FACT)
    (CL:IF SETVALUE? (CL:SETF (%FACT SELF) VALUE)
     (CL:SETQ VALUE (%FACT SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-AXIOM)
    (CL:IF SETVALUE? (CL:SETF (%AXIOM SELF) VALUE)
     (CL:SETQ VALUE (%AXIOM SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-SCORE)
    (CL:IF SETVALUE? (CL:SETF (%SCORE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-ID)
    (CL:IF SETVALUE? (CL:SETF (%ID SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%ID SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-ARGUMENT-SCORES)
    (CL:IF SETVALUE? (CL:SETF (%ARGUMENT-SCORES SELF) VALUE)
     (CL:SETQ VALUE (%ARGUMENT-SCORES SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFGLOBAL *PARTIAL-SUPPORT-COUNTER* ...)

(CL:PROGN (CL:DEFVAR *PARTIAL-SUPPORT-COUNTER* 0) (CL:DECLAIM (CL:TYPE CL:FIXNUM *PARTIAL-SUPPORT-COUNTER*)))

;;; (DEFCLASS PROPOSITION ...)

(CL:DEFCLASS PROPOSITION (CONTEXT-SENSITIVE-OBJECT)
  ((KIND :ALLOCATION :INSTANCE :ACCESSOR %KIND)
   (TRUTH-VALUE :ALLOCATION :INSTANCE :ACCESSOR %TRUTH-VALUE)
   (ARGUMENTS :ALLOCATION :INSTANCE :ACCESSOR %ARGUMENTS)
   (OPERATOR :ALLOCATION :INSTANCE :ACCESSOR %OPERATOR)
   (DEPENDENT-PROPOSITIONS :ALLOCATION :INSTANCE :ACCESSOR
    %DEPENDENT-PROPOSITIONS)
   (WEIGHT :ALLOCATION :INSTANCE :ACCESSOR %WEIGHT)
   (DYNAMIC-SLOTS :ALLOCATION :INSTANCE :ACCESSOR %DYNAMIC-SLOTS))
  (:DOCUMENTATION ""))

(CL:DEFUN NEW-PROPOSITION ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PROPOSITION)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%HOME-CONTEXT SELF) *CONTEXT*)
   (CL:SETF (%WEIGHT SELF) NULL-FLOAT)
   (CL:SETF (%DEPENDENT-PROPOSITIONS SELF) NIL-NON-PAGING-INDEX)
   (CL:SETF (%OPERATOR SELF) NULL) (CL:SETF (%ARGUMENTS SELF) NULL)
   (CL:SETF (%TRUTH-VALUE SELF) NULL) (CL:SETF (%KIND SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PROPOSITION))
  SGT-PROPOSITIONS-LOGIC-PROPOSITION)

(CL:DEFMETHOD VARIABLE-TYPE? ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-VARIABLE-TYPE? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:IF FALSE TRUE-WRAPPER FALSE-WRAPPER)
    ANSWER)))

(CL:DEFMETHOD SATELLITE-PROPOSITIONS ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-SATELLITE-PROPOSITIONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

(CL:DEFMETHOD UNFASTENED? ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-UNFASTENED? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:IF FALSE TRUE-WRAPPER FALSE-WRAPPER)
    ANSWER)))

(CL:DEFMETHOD WEIGHT-DELTA ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-PROPOSITIONS-LOGIC-WEIGHT-DELTA NULL-FLOAT-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT ANSWER))
   (CL:IF (CL:= ANSWER NULL-FLOAT) 0.0d0 ANSWER)))

(CL:DEFMETHOD SUPPORT ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-SUPPORT NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL ANSWER)))

(CL:DEFMETHOD BAD? ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-STELLA-BAD? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:IF FALSE TRUE-WRAPPER FALSE-WRAPPER)
    ANSWER)))

(CL:DEFUN ACCESS-PROPOSITION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-KIND)
    (CL:IF SETVALUE? (CL:SETF (%KIND SELF) VALUE)
     (CL:SETQ VALUE (%KIND SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-TRUTH-VALUE)
    (CL:IF SETVALUE?
     (CL:LET*
      ((OBJECT-000 SELF) (VALUE-000 VALUE)
       (OLD-VALUE-000 (%TRUTH-VALUE OBJECT-000))
       (NEW-VALUE-000
        (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
         (%HOME-CONTEXT OBJECT-000) FALSE)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%TRUTH-VALUE OBJECT-000) NEW-VALUE-000)))
     (CL:SETQ VALUE
      (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF)
       FALSE))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-ARGUMENTS)
    (CL:IF SETVALUE? (CL:SETF (%ARGUMENTS SELF) VALUE)
     (CL:SETQ VALUE (%ARGUMENTS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-OPERATOR)
    (CL:IF SETVALUE? (CL:SETF (%OPERATOR SELF) VALUE)
     (CL:SETQ VALUE (%OPERATOR SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-RELATIONREF)
    (CL:IF SETVALUE? (CL:SETF (%OPERATOR SELF) VALUE)
     (CL:SETQ VALUE (%OPERATOR SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS)
    (CL:IF SETVALUE? (CL:SETF (%DEPENDENT-PROPOSITIONS SELF) VALUE)
     (CL:SETQ VALUE (%DEPENDENT-PROPOSITIONS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-VARIABLE-TYPE?)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-VARIABLE-TYPE? VALUE NULL)
     (CL:SETQ VALUE (VARIABLE-TYPE? SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-SATELLITE-PROPOSITIONS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-SATELLITE-PROPOSITIONS VALUE NULL)
     (CL:SETQ VALUE (SATELLITE-PROPOSITIONS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-UNFASTENED?)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-UNFASTENED? VALUE NULL)
     (CL:SETQ VALUE (UNFASTENED? SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-WEIGHT)
    (CL:IF SETVALUE? (CL:SETF (%WEIGHT SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%WEIGHT SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-WEIGHT-DELTA)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-WEIGHT-DELTA
      (WRAP-FLOAT (%WRAPPER-VALUE VALUE)) NULL-FLOAT-WRAPPER)
     (CL:SETQ VALUE (WRAP-FLOAT (WEIGHT-DELTA SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-SUPPORT)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-SUPPORT VALUE NULL)
     (CL:SETQ VALUE (SUPPORT SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF PROPOSITION) STREAM)
  (PRINT-TOP-LEVEL-OBJECT SELF STREAM))

;;; (DEFCLASS INTEGER-LOGIC-WRAPPER ...)

(CL:DEFCLASS INTEGER-LOGIC-WRAPPER (INTEGER-WRAPPER)
  ((DEPENDENT-PROPOSITIONS-INDEX :ALLOCATION :INSTANCE :ACCESSOR
    %DEPENDENT-PROPOSITIONS-INDEX)))

(CL:DEFUN NEW-INTEGER-LOGIC-WRAPPER (WRAPPER-VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM WRAPPER-VALUE))
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INTEGER-LOGIC-WRAPPER)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) (NEW-BACKLINKS-INDEX))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INTEGER-LOGIC-WRAPPER))
  SGT-PROPOSITIONS-LOGIC-INTEGER-LOGIC-WRAPPER)

(CL:DEFUN ACCESS-INTEGER-LOGIC-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS-INDEX)
    (CL:IF SETVALUE? (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) VALUE)
     (CL:SETQ VALUE (%DEPENDENT-PROPOSITIONS-INDEX SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF INTEGER-LOGIC-WRAPPER) STREAM)
  (CL:IF *PRINTREADABLY?* (%%PRINT-STREAM STREAM (%WRAPPER-VALUE SELF))
   (%%PRINT-STREAM STREAM "|W|" (%WRAPPER-VALUE SELF))))

;;; (DEFCLASS FLOAT-LOGIC-WRAPPER ...)

(CL:DEFCLASS FLOAT-LOGIC-WRAPPER (FLOAT-WRAPPER)
  ((DEPENDENT-PROPOSITIONS-INDEX :ALLOCATION :INSTANCE :ACCESSOR
    %DEPENDENT-PROPOSITIONS-INDEX)))

(CL:DEFUN NEW-FLOAT-LOGIC-WRAPPER (WRAPPER-VALUE)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT WRAPPER-VALUE))
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE FLOAT-LOGIC-WRAPPER)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) (NEW-BACKLINKS-INDEX))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FLOAT-LOGIC-WRAPPER))
  SGT-PROPOSITIONS-LOGIC-FLOAT-LOGIC-WRAPPER)

(CL:DEFUN ACCESS-FLOAT-LOGIC-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS-INDEX)
    (CL:IF SETVALUE? (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) VALUE)
     (CL:SETQ VALUE (%DEPENDENT-PROPOSITIONS-INDEX SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF FLOAT-LOGIC-WRAPPER) STREAM)
  (CL:IF *PRINTREADABLY?* (%%PRINT-STREAM STREAM (%WRAPPER-VALUE SELF))
   (%%PRINT-STREAM STREAM "|W|" (%WRAPPER-VALUE SELF))))

;;; (DEFCLASS STRING-LOGIC-WRAPPER ...)

(CL:DEFCLASS STRING-LOGIC-WRAPPER (STRING-WRAPPER)
  ((DEPENDENT-PROPOSITIONS-INDEX :ALLOCATION :INSTANCE :ACCESSOR
    %DEPENDENT-PROPOSITIONS-INDEX)))

(CL:DEFUN NEW-STRING-LOGIC-WRAPPER (WRAPPER-VALUE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING WRAPPER-VALUE))
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STRING-LOGIC-WRAPPER)))
   (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) (NEW-BACKLINKS-INDEX))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STRING-LOGIC-WRAPPER))
  SGT-PROPOSITIONS-LOGIC-STRING-LOGIC-WRAPPER)

(CL:DEFUN ACCESS-STRING-LOGIC-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS-INDEX)
    (CL:IF SETVALUE? (CL:SETF (%DEPENDENT-PROPOSITIONS-INDEX SELF) VALUE)
     (CL:SETQ VALUE (%DEPENDENT-PROPOSITIONS-INDEX SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF STRING-LOGIC-WRAPPER) STREAM)
  (CL:IF *PRINTREADABLY?* (%%PRINT-STREAM STREAM (%WRAPPER-VALUE SELF))
   (%%PRINT-STREAM STREAM "|W|" (%WRAPPER-VALUE SELF))))

;;; (DEFGLOBAL *OPERATOR-NAME-TO-SURROGATE-TABLE* ...)

(CL:DEFVAR *OPERATOR-NAME-TO-SURROGATE-TABLE* NULL
  "Maps names of KIF operators to relational surrogates.")

;;; (DEFUN (CREATE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN CREATE-PROPOSITION (KIND ARGUMENTCOUNT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARGUMENTCOUNT))
  (ENFORCE-CODE-ONLY)
  (CL:LET* ((PROPOSITION (NEW-PROPOSITION)))
   (CL:SETF (%ARGUMENTS PROPOSITION) (NEW-VECTOR ARGUMENTCOUNT))
   (CL:SETF (%KIND PROPOSITION) (INTERN-KEYWORD (%SYMBOL-NAME KIND)))
   (CL:COND
    ((CL:OR (CL:EQ KIND SYM-PROPOSITIONS-STELLA-FUNCTION)
      (CL:EQ KIND SYM-PROPOSITIONS-STELLA-PREDICATE)
      (CL:EQ KIND SYM-PROPOSITIONS-STELLA-ISA)))
    (CL:T
     (CL:SETF (%OPERATOR PROPOSITION)
      (LOOKUP *OPERATOR-NAME-TO-SURROGATE-TABLE* (%KIND PROPOSITION)))))
   (CL:WHEN (DESCRIPTION-MODE?)
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
     SYM-PROPOSITIONS-LOGIC-DESCRIPTIVE?
     (CL:IF TRUE TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
    SYM-PROPOSITIONS-LOGIC-UNFASTENED? TRUE-WRAPPER NULL)
   PROPOSITION))

;;; (DEFUN ENFORCE-CODE-ONLY ...)

(CL:DEFUN ENFORCE-CODE-ONLY ()
  (CL:WHEN
   (%WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *MODULE*)
     SYM-PROPOSITIONS-STELLA-CODE-ONLY? FALSE-WRAPPER))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "ERROR: Can't create a relation, instance or proposition in module:"
      EOL "       `" (%MODULE-NAME *MODULE*) "'" EOL
      "    because it is marked as 'code-only?'" EOL "." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))))

;;; (DEFGLOBAL *LOGIC-MODULE* ...)

(CL:DEFVAR *LOGIC-MODULE* NULL)

;;; (DEFGLOBAL *PL-KERNEL-MODULE* ...)

(CL:DEFVAR *PL-KERNEL-MODULE* NULL)

;;; (DEFUN (LOGIC-MODULE? BOOLEAN) ...)

(CL:DEFUN LOGIC-MODULE? (SELF)
  "Return TRUE if 'self' is a logic module, implying
that relations defined within it define a knowledge base.  A module
is a logic module iff it inherits the module 'PL-KERNEL'."
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:IF (CL:EQ SELF *PL-KERNEL-MODULE*) (CL:SETQ TEST-VALUE-000 TRUE)
    (CL:PROGN
     (CL:LET* ((FOUND?-000 FALSE))
      (CL:LET*
       ((M NULL) (ITER-000 (%THE-CONS-LIST (%PARENT-MODULES SELF))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:PROGN (CL:SETQ M (%%VALUE ITER-000))
         (CL:SETQ ITER-000 (%%REST ITER-000)))
        (CL:WHEN (LOGIC-MODULE? M) (CL:SETQ FOUND?-000 TRUE)
         (CL:RETURN))))
      (CL:SETQ TEST-VALUE-000 FOUND?-000))
     (CL:WHEN (CL:NOT TEST-VALUE-000)
      (CL:LET* ((FOUND?-001 FALSE))
       (CL:LET* ((M NULL) (ITER-001 (%THE-CONS-LIST (%USES SELF))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:PROGN (CL:SETQ M (%%VALUE ITER-001))
          (CL:SETQ ITER-001 (%%REST ITER-001)))
         (CL:WHEN (LOGIC-MODULE? M) (CL:SETQ FOUND?-001 TRUE)
          (CL:RETURN))))
       (CL:SETQ TEST-VALUE-000 FOUND?-001)))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (LOCALLY-CONCEIVED-PROPOSITIONS PROPOSITIONS-INDEX) ...)

(CL:DEFUN LOCALLY-CONCEIVED-PROPOSITIONS (SELF)
  (CL:LET*
   ((PROPOSITIONS
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-PROPOSITIONS-INTERNAL
      NULL)))
   (CL:WHEN (CL:EQ PROPOSITIONS NULL)
    (CL:SETQ PROPOSITIONS
     (CREATE-SEQUENCE-INDEX KWD-PROPOSITIONS-PAGING
      (LIST* KWD-PROPOSITIONS-CONTEXT-PROPOSITIONS SELF NIL)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-PROPOSITIONS-INTERNAL
     PROPOSITIONS NULL))
   PROPOSITIONS))

;;; (DEFUN LOCALLY-CONCEIVED-PROPOSITIONS-SETTER ...)

(CL:DEFUN LOCALLY-CONCEIVED-PROPOSITIONS-SETTER (SELF VALUE)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-PROPOSITIONS-INTERNAL VALUE
   NULL))

;;; (DEFUN (LOCALLY-CONCEIVED-INSTANCES INSTANCES-INDEX) ...)

(CL:DEFUN LOCALLY-CONCEIVED-INSTANCES (SELF)
  (CL:LET*
   ((INSTANCES
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-INSTANCES-INTERNAL NULL)))
   (CL:WHEN (CL:EQ INSTANCES NULL)
    (CL:SETQ INSTANCES
     (CREATE-SEQUENCE-INDEX KWD-PROPOSITIONS-PAGING
      (LIST* KWD-PROPOSITIONS-CONTEXT-INSTANCES SELF NIL)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-INSTANCES-INTERNAL INSTANCES
     NULL))
   INSTANCES))

;;; (DEFUN LOCALLY-CONCEIVED-INSTANCES-SETTER ...)

(CL:DEFUN LOCALLY-CONCEIVED-INSTANCES-SETTER (SELF VALUE)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-INSTANCES-INTERNAL VALUE NULL))

;;; (DEFGLOBAL *NOW-TIMESTAMP* ...)

(CL:PROGN (CL:DEFVAR *NOW-TIMESTAMP* 0 "The NOW time stamp is incremented whenever a series
of one or more updates is followed by a query.") (CL:DECLAIM (CL:TYPE CL:FIXNUM *NOW-TIMESTAMP*)))

;;; (DEFUN INCREMENT-NOW-TIMESTAMP ...)

(CL:DEFUN INCREMENT-NOW-TIMESTAMP ()
  (CL:SETQ *NOW-TIMESTAMP* (CL:1+ *NOW-TIMESTAMP*)))

;;; (DEFUN (GET-NOW-TIMESTAMP TIMESTAMP) ...)

(CL:DEFUN GET-NOW-TIMESTAMP ()
  *NOW-TIMESTAMP*)

;;; (DEFGLOBAL *LAST-KB-ACTION* ...)

(CL:DEFVAR *LAST-KB-ACTION* NULL
  "Records whether the last KB access was a query or
an update.  Used to determine when to increment the NOW time stamp
counter.")

;;; (DEFUN UPDATE-NOW-TIMESTAMP ...)

(CL:DEFUN UPDATE-NOW-TIMESTAMP (KBACTION)
  (CL:WHEN (CL:EQ KBACTION *LAST-KB-ACTION*)
   (CL:RETURN-FROM UPDATE-NOW-TIMESTAMP))
  (CL:COND
   ((CL:EQ KBACTION KWD-PROPOSITIONS-UPDATE-PROPOSITION)
    (CL:WHEN
     (CL:OR (DESCRIPTION-MODE?) (CL:NOT (CL:EQ *MODULE* *CONTEXT*))
      *INVISIBLEASSERTION?*)
     (CL:RETURN-FROM UPDATE-NOW-TIMESTAMP))
    (INCREMENT-NOW-TIMESTAMP))
   ((CL:EQ KBACTION KWD-PROPOSITIONS-EXECUTE-QUERY))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KBACTION
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:SETQ *LAST-KB-ACTION* KBACTION))

;;; (DEFGLOBAL BOTTOM ...)

(CL:DEFVAR BOTTOM NULL
  "The undefined individual.  Denotes the non-existence of
an individual in whatever slot it occupies.")

;;; (DEFUN (BOTTOM? BOOLEAN) ...)

(CL:DEFUN BOTTOM? (SELF)
  "Return TRUE if 'self' is the undefined individual BOTTOM."
  (CL:EQ SELF BOTTOM))

;;; (DEFUN (SUBRELATION-OF? BOOLEAN) ...)

(CL:DEFUN SUBRELATION-OF? (DESC1 DESC2)
  (CL:LET* ((*REVERSEPOLARITY?* FALSE))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (RELATION-IMPLIES-RELATION? DESC1 DESC2)))

;;; (DEFUN (LOGICAL-SUBTYPE-OF? BOOLEAN) ...)

(CL:DEFUN LOGICAL-SUBTYPE-OF? (TYPE1 TYPE2)
  (CL:LET*
   ((DESC1 (GET-DESCRIPTION TYPE1)) (DESC2 (GET-DESCRIPTION TYPE2)))
   (CL:WHEN (CL:OR (CL:EQ DESC1 NULL) (CL:EQ DESC2 NULL))
    (CL:RETURN-FROM LOGICAL-SUBTYPE-OF? FALSE))
   (SUBRELATION-OF? DESC1 DESC2)))

;;; (DEFUN (LITERAL-TYPE? BOOLEAN) ...)

(CL:DEFUN LITERAL-TYPE? (TYPE)
  (CL:LET* ((VALUE (%SURROGATE-VALUE TYPE)))
   (CL:AND (ISA? VALUE SGT-PROPOSITIONS-STELLA-CLASS)
    (CL:OR (SUBTYPE-OF? TYPE SGT-PROPOSITIONS-STELLA-LITERAL)
     (SUBTYPE-OF? TYPE SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER)))))

;;; (DEFUN (BOOLEAN-TYPE? BOOLEAN) ...)

(CL:DEFUN BOOLEAN-TYPE? (SELF)
  (CL:OR (CL:EQ SELF SGT-PROPOSITIONS-STELLA-BOOLEAN)
   (CL:EQ SELF SGT-PROPOSITIONS-STELLA-BOOLEAN-WRAPPER)))

;;; (DEFUN (CLASS-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN CLASS-DESCRIPTION? (SELF)
  (TEST-ISA? SELF SGT-PROPOSITIONS-PL-KERNEL-KB-CLASS))

;;; (DEFUN (FUNCTION-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN FUNCTION-DESCRIPTION? (SELF)
  (TEST-ISA? SELF SGT-PROPOSITIONS-PL-KERNEL-KB-FUNCTION))

;;; (DEFUN (VARIABLE-ARITY? BOOLEAN) ...)

(CL:DEFUN VARIABLE-ARITY? (SELF)
  (TEST-PROPERTY? SELF SGT-PROPOSITIONS-PL-KERNEL-KB-VARIABLE-ARITY))

;;; (DEFMETHOD (ARITY INTEGER) ...)

(CL:DEFMETHOD ARITY ((SELF NAMED-DESCRIPTION))
  (CL:IF (VARIABLE-ARITY? SELF) -1 (LENGTH (%IO-VARIABLE-TYPES SELF))))

;;; (DEFMETHOD (ARITY INTEGER) ...)

(CL:DEFMETHOD ARITY ((SELF DESCRIPTION))
  (LENGTH (%IO-VARIABLES SELF)))

;;; (DEFUN (MONADIC? BOOLEAN) ...)

(CL:DEFUN MONADIC? (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
     (CL:PROGN (CL:= (ARITY SELF) 1)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-COLLECTION)
     (CL:PROGN TRUE))
    (CL:T FALSE))))

;;; (DEFUN (COMPUTED-RELATION? BOOLEAN) ...)

(CL:DEFUN COMPUTED-RELATION? (DESCRIPTION)
  (CL:OR
   (CL:AND (CL:NOT (CL:EQ (NATIVE-RELATION DESCRIPTION) NULL))
    (CL:NOT (%ABSTRACT? (NATIVE-RELATION DESCRIPTION))))
   (CL:NOT
    (CL:EQ
     (ACCESS-BINARY-VALUE DESCRIPTION
      SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION-COMPUTATION)
     NULL))))

;;; (DEFUN (LAST-ARGUMENT OBJECT) ...)

(CL:DEFUN LAST-ARGUMENT (PROPOSITION)
  (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
   (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS PROPOSITION))))))

;;; (DEFSPECIAL *EVALUATIONMODE* ...)

(CL:DEFVAR *EVALUATIONMODE* NULL
  "Indicates the context for evaluating a proposition.  One
of :DESCRIPTION, :INTENSIONAL-ASSERTION, or :EXTENSIONAL-ASSERTION.")

;;; (DEFUN (DESCRIPTION-MODE? BOOLEAN) ...)

(CL:DEFUN DESCRIPTION-MODE? ()
  (CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-DESCRIPTION))

;;; (DEFSPECIAL *CLIPPINGENABLED?* ...)

(CL:DEFVAR *CLIPPINGENABLED?* TRUE
  "When enabled, slot-value assertions can be retracted
by later conflicting assertions.")

;;; (DEFSPECIAL *NATURALDEDUCTIONMODE?* ...)

(CL:DEFVAR *NATURALDEDUCTIONMODE?* TRUE
  "When enabled, blocks normalizations that significantly
change the behavior of inference rules.")

;;; (DEFUN (NATURAL-DEDUCTION-MODE? BOOLEAN) ...)

(CL:DEFUN NATURAL-DEDUCTION-MODE? ()
  "True if normalization is governed by natural
deduction semantics."
  *NATURALDEDUCTIONMODE?*)

;;; (DEFGLOBAL *CONTEXT-DEPENDENT-SEARCH-MODE?* ...)

(CL:DEFVAR *CONTEXT-DEPENDENT-SEARCH-MODE?* FALSE
  "Signals that we are performing search across multiple
contexts.  Used to disable retraction from collections, since that increases
the overhead of the context mechanism.")

;;; (DEFUN (CONTEXT-DEPENDENT-SEARCH-MODE? BOOLEAN) ...)

(CL:DEFUN CONTEXT-DEPENDENT-SEARCH-MODE? ()
  *CONTEXT-DEPENDENT-SEARCH-MODE?*)

;;; (DEFUN LOG-NEWLY-CONCEIVED-PROPOSITION ...)

(CL:DEFUN LOG-NEWLY-CONCEIVED-PROPOSITION (SELF PROPOSITION)
  (CL:LET* ((FOUND?-000 FALSE))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:WHEN (ISA? ARG SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
      (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
   (CL:WHEN FOUND?-000
    (CL:WARN "LOGGED QUESTIONABLE CONCEPTION: ~%   `~A'~%" PROPOSITION)))
  (INSERT (LOCALLY-CONCEIVED-PROPOSITIONS SELF) PROPOSITION))

;;; (DEFUN CLIP-OR-CLASH-WITH-OLD-PREDICATE-VALUE ...)

(CL:DEFUN CLIP-OR-CLASH-WITH-OLD-PREDICATE-VALUE (PROPOSITION)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS PROPOSITION))
    (COUNTMINUSTWO (CL:- (LENGTH ARGUMENTS) 2)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COUNTMINUSTWO))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALL-TRUE-DEPENDENT-PROPOSITIONS
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0)
       (%OPERATOR PROPOSITION) FALSE)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:LET* ((ALWAYS?-000 TRUE))
      (CL:LET*
       ((I NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-000 COUNTMINUSTWO)
        (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 UPPER-BOUND-000 I))
       (CL:LOOP WHILE
        (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)) DO
        (CL:PROGN (CL:SETQ I ITER-001)
         (CL:SETQ ITER-001 (CL:1+ ITER-001)))
        (CL:WHEN
         (CL:NOT
          (EQL?
           (VALUE-OF
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) I))
           (VALUE-OF
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
             I))))
         (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
      (CL:WHEN ALWAYS?-000
       (CL:COND
        ((EQL?
          (VALUE-OF
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
            (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS P))))))
          (VALUE-OF (LAST ARGUMENTS))))
        ((CL:AND *CLIPPINGENABLED?* (WORLD-STATE? *CONTEXT*))
         (DEASSIGN-TRUTH-VALUE P KWD-PROPOSITIONS-RETRACT-TRUE))
        (CL:T
         (SIGNAL-UNIFICATION-CLASH
          (VALUE-OF
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
            (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS P))))))
          (VALUE-OF (LAST ARGUMENTS)))))))))))

;;; (DEFUN RUN-TRUTH-CHANGE-DEMON ...)

(CL:DEFUN RUN-TRUTH-CHANGE-DEMON (PROPOSITION TRUTHCHANGERELATION)
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION (%OPERATOR PROPOSITION)))
    (DEMONCOMPUTATION
     (ACCESS-BINARY-VALUE DESCRIPTION TRUTHCHANGERELATION)))
   (CL:WHEN (CL:NOT (CL:EQ DEMONCOMPUTATION NULL))
    (CL:LET*
     ((FUNCTIONCODE (FUNCTION-CODE-FROM-PROCEDURE DEMONCOMPUTATION)))
     (CL:WHEN (CL:NOT (CL:EQ FUNCTIONCODE NULL))
      (CL:FUNCALL FUNCTIONCODE PROPOSITION))))))

;;; (DEFUN RUN-GOES-TRUE-DEMONS ...)

(CL:DEFUN RUN-GOES-TRUE-DEMONS (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-ISA))
     (RUN-TRUTH-CHANGE-DEMON PROPOSITION
      SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-TRUE-DEMON))
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-PREDICATE)
     (CL:LET* ((DESCRIPTION (GET-DESCRIPTION (%OPERATOR PROPOSITION))))
      (CL:WHEN (SINGLE-VALUED-TERM? DESCRIPTION)
       (CLIP-OR-CLASH-WITH-OLD-PREDICATE-VALUE PROPOSITION)))
     (RUN-TRUTH-CHANGE-DEMON PROPOSITION
      SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-TRUE-DEMON))
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-IMPLIES)
     (CL:WHEN
      (CL:OR
       (CL:NOT
        (ISA?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          0)
         SGT-PROPOSITIONS-LOGIC-DESCRIPTION))
       (CL:NOT
        (ISA?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          1)
         SGT-PROPOSITIONS-LOGIC-DESCRIPTION)))
      (CL:RETURN-FROM RUN-GOES-TRUE-DEMONS))
     (CL:WHEN (CL:NOT (DESCRIPTION-MODE?))
      (ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 0)
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        1)))
     (REVISE-EQUIVALENCES PROPOSITION TRUE)
     (CL:WHEN (CL:EQ *MODULE* *CONTEXT*) (BUMP-INFERABLE-TIMESTAMP))
     (FLUSH-INFERABLE-DIRECT-SUBDESCRIPTIONS-CACHE PROPOSITION))
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FORALL)
     (CL:WHEN (CL:EQ (SATELLITE-PROPOSITIONS PROPOSITION) NIL-LIST)
      (DERIVE-SATELLITE-RULES PROPOSITION))
     (CL:LET*
      ((P NULL)
       (ITER-000 (%THE-CONS-LIST (SATELLITE-PROPOSITIONS PROPOSITION))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ P (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (ASSIGN-TRUTH-VALUE P TRUE-WRAPPER)))
     (BUMP-INFERABLE-TIMESTAMP))
    (CL:T)))
  NULL)

;;; (DEFUN RUN-GOES-FALSE-DEMONS ...)

(CL:DEFUN RUN-GOES-FALSE-DEMONS (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-ISA)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-PREDICATE))
     (RUN-TRUTH-CHANGE-DEMON PROPOSITION
      SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-FALSE-DEMON))
    (CL:T)))
  NULL)

;;; (DEFUN RUN-GOES-UNKNOWN-DEMONS ...)

(CL:DEFUN RUN-GOES-UNKNOWN-DEMONS (PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-ISA)
     (CL:LET*
      ((ARGUMENT
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         0)))
      (CL:COND
       ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARGUMENT)
         SGT-PROPOSITIONS-LOGIC-SKOLEM)
        (CL:PROGN
         (CL:LET* ((SKOLEMTYPE (%ROOT-TYPE ARGUMENT)))
          (CL:WHEN
           (CL:AND (CL:EQ SKOLEMTYPE (%OPERATOR PROPOSITION))
            (CL:NOT (CL:EQ SKOLEMTYPE SGT-PROPOSITIONS-STELLA-THING)))
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
            "Can't retract skolem type of `" ARGUMENT "' equaling `"
            (%SYMBOL-NAME SKOLEMTYPE) "'." EOL EOL)))))
       (CL:T)))
     (RUN-TRUTH-CHANGE-DEMON PROPOSITION
      SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-UNKNOWN-DEMON))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FUNCTION))
     (RUN-TRUTH-CHANGE-DEMON PROPOSITION
      SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-UNKNOWN-DEMON))
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-IMPLIES)
     (DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 0)
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 1))
     (REVISE-EQUIVALENCES PROPOSITION FALSE)
     (CL:LET*
      ((P
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
         SYM-PROPOSITIONS-LOGIC-MASTER-PROPOSITION NULL)))
      (CL:WHEN (CL:AND (CL:NOT (CL:EQ P NULL)) (TRUE? P))
       (DEASSIGN-TRUTH-VALUE P KWD-PROPOSITIONS-RETRACT-TRUE))))
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FORALL)
     (CL:LET*
      ((P NULL)
       (ITER-000 (%THE-CONS-LIST (SATELLITE-PROPOSITIONS PROPOSITION))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ P (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (DEASSIGN-TRUTH-VALUE P KWD-PROPOSITIONS-RETRACT-TRUE))))
    (CL:T)))
  NULL)

;;; (DEFUN UPDATE-LINKS-AND-TIMESTAMPS ...)

(CL:DEFUN UPDATE-LINKS-AND-TIMESTAMPS (PROPOSITION UPDATEMODE)
  (CL:WHEN (CL:EQ PROPOSITION NULL)
   (CL:RETURN-FROM UPDATE-LINKS-AND-TIMESTAMPS))
  (UPDATE-NOW-TIMESTAMP KWD-PROPOSITIONS-UPDATE-PROPOSITION)
  (CL:COND
   ((CL:OR (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
     (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-TRUE))
    (RUN-GOES-TRUE-DEMONS PROPOSITION))
   ((CL:OR (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
     (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-FALSE))
    (RUN-GOES-FALSE-DEMONS PROPOSITION))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
    (RUN-GOES-UNKNOWN-DEMONS PROPOSITION))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-FALSE)
    (RUN-GOES-UNKNOWN-DEMONS PROPOSITION))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" UPDATEMODE
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN ASSIGN-TRUTH-VALUE ...)

(CL:DEFUN ASSIGN-TRUTH-VALUE (SELF TRUTHVALUE)
  (CL:LET*
   ((OLDTRUTHVALUE
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) FALSE))
    (NEWTRUTHVALUE NULL))
   (CL:COND
    ((CL:EQ TRUTHVALUE TRUE-WRAPPER)
     (CL:SETQ NEWTRUTHVALUE TRUE-TRUTH-VALUE))
    ((CL:EQ TRUTHVALUE FALSE-WRAPPER)
     (CL:SETQ NEWTRUTHVALUE FALSE-TRUTH-VALUE))
    (CL:T (CL:SETQ NEWTRUTHVALUE TRUTHVALUE)))
   (CL:COND ((CL:EQ OLDTRUTHVALUE NEWTRUTHVALUE))
    ((CL:NOT (CL:EQ OLDTRUTHVALUE NULL))
     (CL:COND
      ((CL:EQ NEWTRUTHVALUE TRUE-TRUTH-VALUE)
       (CL:COND
        ((CL:EQ OLDTRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
         (CL:LET*
          ((OBJECT-000 SELF) (VALUE-000 NULL)
           (OLD-VALUE-001 (%TRUTH-VALUE OBJECT-000))
           (NEW-VALUE-000
            (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-000
             (%HOME-CONTEXT OBJECT-000) FALSE)))
          (CL:WHEN
           (CL:NOT
            (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
             (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
              SGT-PROPOSITIONS-STELLA-CS-VALUE)))
           (CL:SETF (%TRUTH-VALUE OBJECT-000) NEW-VALUE-000)))
         (ASSIGN-TRUTH-VALUE SELF NEWTRUTHVALUE))
        ((CL:EQ OLDTRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE)
         (DEASSIGN-TRUTH-VALUE SELF KWD-PROPOSITIONS-RETRACT-FALSE)
         (ASSIGN-TRUTH-VALUE SELF NEWTRUTHVALUE))
        ((CL:EQ OLDTRUTHVALUE FALSE-TRUTH-VALUE)
         (SIGNAL-TRUTH-VALUE-CLASH SELF))))
      ((CL:EQ NEWTRUTHVALUE FALSE-TRUTH-VALUE)
       (CL:COND
        ((CL:EQ OLDTRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE)
         (CL:LET*
          ((OBJECT-001 SELF) (VALUE-001 NULL)
           (OLD-VALUE-002 (%TRUTH-VALUE OBJECT-001))
           (NEW-VALUE-001
            (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-001
             (%HOME-CONTEXT OBJECT-001) FALSE)))
          (CL:WHEN
           (CL:NOT
            (CL:AND (CL:NOT (CL:EQ OLD-VALUE-002 NULL))
             (CL:EQ (PRIMARY-TYPE OLD-VALUE-002)
              SGT-PROPOSITIONS-STELLA-CS-VALUE)))
           (CL:SETF (%TRUTH-VALUE OBJECT-001) NEW-VALUE-001)))
         (ASSIGN-TRUTH-VALUE SELF NEWTRUTHVALUE))
        ((CL:EQ OLDTRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
         (DEASSIGN-TRUTH-VALUE SELF KWD-PROPOSITIONS-RETRACT-TRUE)
         (ASSIGN-TRUTH-VALUE SELF NEWTRUTHVALUE))
        ((CL:EQ OLDTRUTHVALUE TRUE-TRUTH-VALUE)
         (SIGNAL-TRUTH-VALUE-CLASH SELF))))
      ((CL:EQ NEWTRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
       (CL:COND
        (*DEFERINGDEFAULTFORWARDINFERENCES?*
         (DEFERRED-DEFAULT-PROPOSITIONS-SETTER *CONTEXT*
          (CONS SELF (DEFERRED-DEFAULT-PROPOSITIONS *CONTEXT*)))
         NULL)
        ((CL:OR (CL:EQ OLDTRUTHVALUE TRUE-TRUTH-VALUE)
          (CL:EQ OLDTRUTHVALUE FALSE-TRUTH-VALUE)))
        ((CL:EQ OLDTRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE)
         (DEASSIGN-TRUTH-VALUE SELF KWD-PROPOSITIONS-RETRACT-FALSE))))
      ((CL:EQ NEWTRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE)
       (CL:COND
        (*DEFERINGDEFAULTFORWARDINFERENCES?*
         (DEFERRED-DEFAULT-PROPOSITIONS-SETTER *CONTEXT*
          (CONS SELF (DEFERRED-DEFAULT-PROPOSITIONS *CONTEXT*)))
         NULL)
        ((CL:OR (CL:EQ OLDTRUTHVALUE FALSE-TRUTH-VALUE)
          (CL:EQ OLDTRUTHVALUE TRUE-TRUTH-VALUE)))
        ((CL:EQ OLDTRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
         (DEASSIGN-TRUTH-VALUE SELF KWD-PROPOSITIONS-RETRACT-TRUE))))
      (CL:T (SIGNAL-TRUTH-VALUE-CLASH SELF))))
    ((CL:EQ (%KIND SELF) KWD-PROPOSITIONS-FUNCTION)
     (CL:LET*
      ((OBJECT-002 SELF) (VALUE-002 TRUE-TRUTH-VALUE)
       (OLD-VALUE-003 (%TRUTH-VALUE OBJECT-002))
       (NEW-VALUE-002
        (UPDATE-IN-CONTEXT OLD-VALUE-003 VALUE-002
         (%HOME-CONTEXT OBJECT-002) FALSE)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-003 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-003)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%TRUTH-VALUE OBJECT-002) NEW-VALUE-002))))
    ((CL:AND (DESCRIPTION-MODE?)
      (CL:EQ (%KIND SELF) KWD-PROPOSITIONS-CONSTANT)))
    (CL:T
     (CL:LET*
      ((OBJECT-003 SELF) (VALUE-003 NEWTRUTHVALUE)
       (OLD-VALUE-004 (%TRUTH-VALUE OBJECT-003))
       (NEW-VALUE-003
        (UPDATE-IN-CONTEXT OLD-VALUE-004 VALUE-003
         (%HOME-CONTEXT OBJECT-003) FALSE)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-004 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-004)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%TRUTH-VALUE OBJECT-003) NEW-VALUE-003)))
     (HANDLE-OUT-OF-DATE-INFERENCE-CACHE KWD-PROPOSITIONS-ASSERT SELF)
     (CL:COND
      ((CL:EQ NEWTRUTHVALUE TRUE-TRUTH-VALUE)
       (UPDATE-LINKS-AND-TIMESTAMPS SELF KWD-PROPOSITIONS-ASSERT-TRUE))
      ((CL:EQ NEWTRUTHVALUE FALSE-TRUTH-VALUE)
       (UPDATE-LINKS-AND-TIMESTAMPS SELF KWD-PROPOSITIONS-ASSERT-FALSE))
      ((CL:EQ NEWTRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
       (UPDATE-LINKS-AND-TIMESTAMPS SELF KWD-PROPOSITIONS-PRESUME-TRUE))
      ((CL:EQ NEWTRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE)
       (UPDATE-LINKS-AND-TIMESTAMPS SELF KWD-PROPOSITIONS-PRESUME-FALSE)))
     (REACT-TO-KB-UPDATE *CONTEXT* SELF)))))

;;; (DEFUN DEASSIGN-TRUTH-VALUE ...)

(CL:DEFUN DEASSIGN-TRUTH-VALUE (SELF UPDATEMODE)
  (CL:LET*
   ((OBJECT-000 SELF) (VALUE-000 NULL)
    (OLD-VALUE-000 (%TRUTH-VALUE OBJECT-000))
    (NEW-VALUE-000
     (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000 (%HOME-CONTEXT OBJECT-000)
      FALSE)))
   (CL:WHEN
    (CL:NOT
     (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
      (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
       SGT-PROPOSITIONS-STELLA-CS-VALUE)))
    (CL:SETF (%TRUTH-VALUE OBJECT-000) NEW-VALUE-000)))
  (HANDLE-OUT-OF-DATE-INFERENCE-CACHE KWD-PROPOSITIONS-RETRACT SELF)
  (UPDATE-LINKS-AND-TIMESTAMPS SELF UPDATEMODE))

;;; (DEFUN UPDATE-PROPOSITION-TRUTH-VALUE ...)

(CL:DEFUN UPDATE-PROPOSITION-TRUTH-VALUE (SELF UPDATEMODE)
  (CL:COND
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
    (ASSIGN-TRUTH-VALUE SELF TRUE-WRAPPER))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
    (ASSIGN-TRUTH-VALUE SELF FALSE-WRAPPER))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-TRUE)
    (ASSIGN-TRUTH-VALUE SELF DEFAULT-TRUE-TRUTH-VALUE))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-FALSE)
    (ASSIGN-TRUTH-VALUE SELF DEFAULT-FALSE-TRUTH-VALUE))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
    (CL:WHEN
     (CL:AND (TRUE? SELF)
      (CL:NOT (CL:EQ (%KIND SELF) KWD-PROPOSITIONS-FUNCTION)))
     (DEASSIGN-TRUTH-VALUE SELF UPDATEMODE)))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-FALSE)
    (CL:WHEN (FALSE? SELF) (DEASSIGN-TRUTH-VALUE SELF UPDATEMODE)))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-CONCEIVE))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" UPDATEMODE
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN ASSIGN-PROPOSITION-WEIGHT ...)

(CL:DEFUN ASSIGN-PROPOSITION-WEIGHT (SELF WEIGHT)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT WEIGHT))
  (CL:LET*
   ((TV
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) FALSE)))
   (CL:COND ((CL:= WEIGHT 1.0d0) (ASSIGN-TRUTH-VALUE SELF TRUE-WRAPPER))
    ((CL:= WEIGHT 0.0d0) (ASSIGN-TRUTH-VALUE SELF FALSE-WRAPPER))
    ((CL:OR (CL:EQ TV TRUE-TRUTH-VALUE) (CL:EQ TV FALSE-TRUTH-VALUE)
      (CL:EQ TV NULL))
     (CL:LET* ((SELF-000 (NEW-TRUTH-VALUE)))
      (CL:SETF (%POSITIVE-SCORE SELF-000) WEIGHT)
      (CL:LET*
       ((OBJECT-000 SELF) (VALUE-000 SELF-000)
        (OLD-VALUE-001 (%TRUTH-VALUE OBJECT-000))
        (NEW-VALUE-000
         (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-000
          (%HOME-CONTEXT OBJECT-000) FALSE)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
           SGT-PROPOSITIONS-STELLA-CS-VALUE)))
        (CL:SETF (%TRUTH-VALUE OBJECT-000) NEW-VALUE-000)))))
    (CL:T
     (CL:SETF
      (%POSITIVE-SCORE
       (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) FALSE))
      WEIGHT)))))

;;; (DEFUN (TICKLE-CONTEXT CONTEXT) ...)

(CL:DEFUN TICKLE-CONTEXT ()
  (CL:LET*
   ((DESCRIPTION
     (GET-DESCRIPTION SGT-PROPOSITIONS-PL-KERNEL-KB-HIDDEN-RELATION)))
   (ASSERT-PROPERTY DESCRIPTION
    SGT-PROPOSITIONS-PL-KERNEL-KB-HIDDEN-RELATION)
   (UPDATE-PROPERTY DESCRIPTION
    SGT-PROPOSITIONS-PL-KERNEL-KB-HIDDEN-RELATION
    KWD-PROPOSITIONS-RETRACT-TRUE)
   *CONTEXT*))

;;; (DEFUN (TICKLE-INSTANCES CONTEXT) ...)

(CL:DEFUN TICKLE-INSTANCES ()
  (CL:LET* ((V-009 (GET-INSTANCE (WRAP-STRING "HIDDEN-INSTANCE"))))
   (CL:WHEN (CL:EQ V-009 NULL)
    (CL:SETQ V-009
     (CREATE-LOGIC-INSTANCE SGT-PROPOSITIONS-LOGIC-HIDDEN-INSTANCE NULL)))
   (CL:LET* ((INSTANCE V-009))
    (ASSERT-PROPERTY INSTANCE
     SGT-PROPOSITIONS-PL-KERNEL-KB-HIDDEN-RELATION)
    (UPDATE-PROPERTY INSTANCE
     SGT-PROPOSITIONS-PL-KERNEL-KB-HIDDEN-RELATION
     KWD-PROPOSITIONS-RETRACT-TRUE)
    *CONTEXT*)))

;;; (DEFUN REACT-TO-SKOLEM-VALUE-UPDATE ...)

(CL:DEFUN REACT-TO-SKOLEM-VALUE-UPDATE (SKOLEM OLDVALUE NEWVALUE TOPLEVELUPDATE?)
  (CL:LET* ((PROPOSITION (%DEFINING-PROPOSITION SKOLEM)))
   (CL:WHEN
    (CL:AND TOPLEVELUPDATE? (NATIVE-SLOT-PROPOSITION? PROPOSITION))
    (CL:LET*
     ((SLOT (NATIVE-RELATION (GET-DESCRIPTION (%OPERATOR PROPOSITION))))
      (NATIVEFIRSTARGVALUE
       (VALUE-OF
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         0))))
     (CL:IF (CL:NOT (CL:EQ NEWVALUE NULL))
      (ASSIGN-NATIVE-SLOT-VALUE NATIVEFIRSTARGVALUE SLOT NEWVALUE)
      (DROP-NATIVE-SLOT-VALUE NATIVEFIRSTARGVALUE SLOT OLDVALUE))))
   (CL:WHEN (CL:NOT (EQL? OLDVALUE NEWVALUE))
    (BUMP-MEMOIZATION-TIMESTAMP KWD-PROPOSITIONS-KB-UPDATE)
    (CL:WHEN
     (CL:OR
      (CL:AND (CL:NOT (CL:EQ NEWVALUE NULL))
       (ISA? NEWVALUE SGT-PROPOSITIONS-LOGIC-DESCRIPTION))
      (META-PROPOSITION? PROPOSITION))
     (BUMP-MEMOIZATION-TIMESTAMP KWD-PROPOSITIONS-META-KB-UPDATE))
    (UPDATE-NOW-TIMESTAMP KWD-PROPOSITIONS-UPDATE-PROPOSITION))))

;;; (DEFUN (NATIVE-SLOT-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN NATIVE-SLOT-PROPOSITION? (SELF)
  (CL:LET* ((ARGUMENTS (%ARGUMENTS SELF)))
   (CL:WHEN (CL:= (CL:THE CL:FIXNUM (LENGTH ARGUMENTS)) 0)
    (CL:RETURN-FROM NATIVE-SLOT-PROPOSITION? FALSE))
   (CL:LET*
    ((FIRSTARG
      (CL:IF
       (CL:NOT
        (CL:EQ
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0)
         NULL))
       (VALUE-OF
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0))
       NULL)))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ FIRSTARG NULL))
      (ISA? FIRSTARG SGT-PROPOSITIONS-STELLA-THING))
     (CL:LET* ((DESCRIPTION (GET-DESCRIPTION (%OPERATOR SELF))))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ (NATIVE-RELATION DESCRIPTION) NULL))
        (ISA? (NATIVE-RELATION DESCRIPTION)
         SGT-PROPOSITIONS-STELLA-STORAGE-SLOT))
       (CL:RETURN-FROM NATIVE-SLOT-PROPOSITION? TRUE))))
    FALSE)))

;;; (DEFUN (UPDATE-NATIVE-SLOT-PROPOSITION (CONS OF PROPOSITION)) ...)

(CL:DEFUN UPDATE-NATIVE-SLOT-PROPOSITION (PROPOSITION UPDATEMODE)
  (CL:LET*
   ((SLOT
     (NATIVE-RELATION (SURROGATE-TO-DESCRIPTION (%OPERATOR PROPOSITION))))
    (OBJECT
     (VALUE-OF
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (VALUE
     (VALUE-OF
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       1))))
   (CL:COND
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
     (CL:WHEN *CLIPPINGENABLED?* (CLEAR-NATIVE-SLOT-VALUE OBJECT SLOT))
     (ASSIGN-NATIVE-SLOT-VALUE OBJECT SLOT VALUE))
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
     (DROP-NATIVE-SLOT-VALUE OBJECT SLOT VALUE))
    (CL:T
     (CL:WARN
      "Illegal update to native slot value.  Mode:  `~A'~%   Proposition:  `~A'~%"
      UPDATEMODE PROPOSITION)))
   NIL))

;;; (DEFUN ASSIGN-NATIVE-SLOT-VALUE ...)

(CL:DEFUN ASSIGN-NATIVE-SLOT-VALUE (SELF SLOT VALUE)
  (CL:WHEN (SKOLEM? VALUE) (CL:RETURN-FROM ASSIGN-NATIVE-SLOT-VALUE))
  (CL:LET* ((OLDVALUE (READ-SLOT-VALUE SELF SLOT)))
   (CL:WHEN (EQL? OLDVALUE VALUE)
    (CL:RETURN-FROM ASSIGN-NATIVE-SLOT-VALUE))
   (CL:WHEN (CL:NOT (CL:EQ OLDVALUE NULL))
    (SIGNAL-UNIFICATION-CLASH OLDVALUE VALUE))
   (PUT-SLOT-VALUE SELF SLOT VALUE)))

;;; (DEFUN CLEAR-NATIVE-SLOT-VALUE ...)

(CL:DEFUN CLEAR-NATIVE-SLOT-VALUE (OBJECT SLOT)
  (PUT-SLOT-VALUE OBJECT SLOT NULL))

;;; (DEFUN DROP-NATIVE-SLOT-VALUE ...)

(CL:DEFUN DROP-NATIVE-SLOT-VALUE (SELF SLOT VALUE)
  (CL:LET* ((OLDVALUE (READ-SLOT-VALUE SELF SLOT)))
   (CL:WHEN (EQL? VALUE OLDVALUE) (CLEAR-NATIVE-SLOT-VALUE SELF SLOT))))

;;; (DEFUN (LOOKUP-SLOTREF-ON-INSTANCE SURROGATE) ...)

(CL:DEFUN LOOKUP-SLOTREF-ON-INSTANCE (TERM SLOTNAME)
  (CL:LET* ((TERMTYPE NULL)) (CL:SETQ TERMTYPE (SAFE-LOGICAL-TYPE TERM))
   (CL:WHEN (CL:EQ TERMTYPE NULL)
    (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE NULL))
   (CL:WHEN
    (CL:OR (CL:EQ (%SURROGATE-VALUE TERMTYPE) NULL)
     (CL:NOT
      (ISA? (%SURROGATE-VALUE TERMTYPE) SGT-PROPOSITIONS-STELLA-CLASS))
     (CL:EQ TERMTYPE SGT-PROPOSITIONS-STELLA-THING))
    (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE NULL))
   (CL:WHEN (CL:NOT (CL:EQ (LOOKUP-FUNCTION SLOTNAME) NULL))
    (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE NULL))
   (CL:LET* ((SURROGATE (LOOKUP-SLOTREF TERMTYPE SLOTNAME)))
    (CL:WHEN (CL:NOT (CL:EQ SURROGATE NULL))
     (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE SURROGATE))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM)
       SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
      (CL:PROGN
       (CL:LET*
        ((PROP NULL)
         (ITER-000
          (ALLOCATE-ITERATOR
           (UNFILTERED-DEPENDENT-ISA-PROPOSITIONS TERM))))
        (CL:LOOP WHILE (NEXT? ITER-000) DO
         (CL:SETQ PROP (%VALUE ITER-000))
         (CL:WHEN (CL:EQ (%KIND PROP) KWD-PROPOSITIONS-ISA)
          (CL:SETQ SURROGATE (LOOKUP-SLOTREF (%OPERATOR PROP) SLOTNAME))
          (CL:WHEN (CL:NOT (CL:EQ SURROGATE NULL))
           (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE SURROGATE)))))))
     (CL:T))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM) SGT-PROPOSITIONS-LOGIC-SKOLEM)
      (CL:PROGN
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ (%DEFINING-PROPOSITION TERM) NULL))
         (ISA? (%OPERATOR (%DEFINING-PROPOSITION TERM))
          SGT-PROPOSITIONS-STELLA-SURROGATE))
        (CL:LET*
         ((DESCRIPTION
           (GET-DESCRIPTION (%OPERATOR (%DEFINING-PROPOSITION TERM)))))
         (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
          (CL:SETQ TERMTYPE (LAST (%IO-VARIABLE-TYPES DESCRIPTION)))
          (CL:SETQ SURROGATE (LOOKUP-SLOTREF TERMTYPE SLOTNAME))
          (CL:WHEN (CL:NOT (CL:EQ SURROGATE NULL))
           (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE SURROGATE)))))))
     (CL:T))
    NULL)))

;;; (DEFUN (UNBOUND? BOOLEAN) ...)

(CL:DEFUN UNBOUND? (SKOLEM)
  (CL:EQ
   (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SKOLEM) (%HOME-CONTEXT SKOLEM)
    FALSE)
   NULL))

;;; (DEFUN (VALUE-OF OBJECT) ...)

(CL:DEFUN VALUE-OF (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:IF
       (CL:EQ
        (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SELF) (%HOME-CONTEXT SELF)
         FALSE)
        NULL)
       SELF
       (VALUE-OF
        (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SELF) (%HOME-CONTEXT SELF)
         FALSE)))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (SURROGATE.VALUE-OF SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-RELATION)
     (CL:PROGN (RELATION.VALUE-OF SELF)))
    (CL:T SELF))))

;;; (DEFUN (SURROGATE.VALUE-OF OBJECT) ...)

(CL:DEFUN SURROGATE.VALUE-OF (SELF)
  (CL:LET* ((VALUE (%SURROGATE-VALUE SELF)))
   (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (VALUE-OF VALUE)
    (CL:PROGN
     (CL:WHEN (DOTTED-STRING? (%SYMBOL-NAME SELF))
      (CL:LET* ((SLOT (STRING-TO-SLOT (%SYMBOL-NAME SELF))))
       (CL:WHEN (CL:NOT (CL:EQ SLOT NULL))
        (CL:RETURN-FROM SURROGATE.VALUE-OF (VALUE-OF SLOT)))))
     (CL:WHEN (CL:NOT *SUPPRESSNONLOGICOBJECTWARNING?*)
      (SIGNAL-UNDEFINED-TERM (WRAP-STRING (%SYMBOL-NAME SELF))))
     NULL))))

;;; (DEFUN (RELATION.VALUE-OF DESCRIPTION) ...)

(CL:DEFUN RELATION.VALUE-OF (SELF)
  (CL:LET*
   ((DESCRIPTION
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL)))
   (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:RETURN-FROM RELATION.VALUE-OF DESCRIPTION))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
      SGT-PROPOSITIONS-STELLA-RELATION)
     (CL:PROGN (CL:SETQ DESCRIPTION (GET-DESCRIPTION SELF))))
    (CL:T))
   (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:RETURN-FROM RELATION.VALUE-OF DESCRIPTION))
   (CL:WHEN (CL:NOT *SUPPRESSNONLOGICOBJECTWARNING?*)
    (CL:LET* ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING)
      "WARNING: value-of: encountered missing description on class or relation "
      (NAME SELF) EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
      KWD-PROPOSITIONS-WARNING)))
   NULL))

;;; (DEFUN (EQUIVALENT-VALUE-OF OBJECT) ...)

(CL:DEFUN EQUIVALENT-VALUE-OF (SELF)
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM EQUIVALENT-VALUE-OF NULL))
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
    (CL:PROGN
     (CL:IF
      (CL:NOT
       (CL:EQ
        (ACCESS-IN-CONTEXT (%EQUIVALENT-VALUE SELF) (%HOME-CONTEXT SELF)
         FALSE)
        NULL))
      (EQUIVALENT-VALUE-OF
       (ACCESS-IN-CONTEXT (%EQUIVALENT-VALUE SELF) (%HOME-CONTEXT SELF)
        FALSE))
      SELF)))
   (CL:T SELF)))

;;; (DEFSPECIAL *COMPUTEDQUERY?* ...)

(CL:DEFVAR *COMPUTEDQUERY?* FALSE
  "Used to signal 'ground-value-of' that it can
call 'bound-to' safely.")

;;; (DEFUN (GROUND-VALUE-OF OBJECT) ...)

(CL:DEFUN GROUND-VALUE-OF (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN
      (CL:LET* ((VALUE NULL))
       (CL:WHEN
        (CL:AND (DEFINED? (%BOUND-TO-OFFSET SELF)) *COMPUTEDQUERY?*)
        (CL:SETQ VALUE
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY
            (%VARIABLE-BINDINGS
             (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
          (CL:THE CL:FIXNUM (%BOUND-TO-OFFSET SELF)))))
       (CL:WHEN (CL:EQ VALUE NULL)
        (CL:SETQ VALUE
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SELF) (%HOME-CONTEXT SELF)
          FALSE)))
       (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (GROUND-VALUE-OF VALUE) NULL))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET*
       ((VALUE
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SELF) (%HOME-CONTEXT SELF)
          FALSE)))
       (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (GROUND-VALUE-OF VALUE) NULL))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((VALUE (%SURROGATE-VALUE SELF)))
       (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (GROUND-VALUE-OF VALUE) NULL))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-RELATION)
     (CL:PROGN
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL)))
    (CL:T SELF))))

;;; (DEFUN (SKOLEM? BOOLEAN) ...)

(CL:DEFUN SKOLEM? (SELF)
  (CL:AND (CL:NOT (CL:EQ SELF NULL))
   (ISA? SELF SGT-PROPOSITIONS-LOGIC-SKOLEM)))

;;; (DEFUN (VARIABLE? BOOLEAN) ...)

(CL:DEFUN VARIABLE? (SELF)
  (ISA? SELF SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE))

;;; (DEFUN (NATIVE-VALUE? BOOLEAN) ...)

(CL:DEFUN NATIVE-VALUE? (SELF)
  (CL:IF (CL:NOT (CL:EQ SELF NULL))
   (CL:NOT (ISA? SELF SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)) FALSE))

;;; (DEFUN (NATIVE-VALUE-OF OBJECT) ...)

(CL:DEFUN NATIVE-VALUE-OF (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN
      (CL:LET* ((VALUE (GROUND-VALUE-OF SELF)))
       (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (NATIVE-VALUE-OF VALUE) NULL))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET*
       ((VALUE
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SELF) (%HOME-CONTEXT SELF)
          FALSE)))
       (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (NATIVE-VALUE-OF VALUE) NULL))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN NULL))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((VALUE (%SURROGATE-VALUE SELF)))
       (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (NATIVE-VALUE-OF VALUE) NULL))))
    (CL:T SELF))))

;;; (DEFUN (INNERMOST-VARIABLE-OF PATTERN-VARIABLE) ...)

(CL:DEFUN INNERMOST-VARIABLE-OF (SELF)
  (CL:LOOP
   (CL:LET* ((TIGHTESTVARIABLE SELF) (VALUE NULL))
    (CL:LOOP
     (CL:SETQ VALUE
      (ACCESS-IN-CONTEXT (%VARIABLE-VALUE TIGHTESTVARIABLE)
       (%HOME-CONTEXT TIGHTESTVARIABLE) FALSE))
     (CL:IF (CL:AND (CL:NOT (CL:EQ VALUE NULL)) (VARIABLE? VALUE))
      (CL:SETQ TIGHTESTVARIABLE VALUE)
      (CL:RETURN-FROM INNERMOST-VARIABLE-OF TIGHTESTVARIABLE))))))

;;; (DEFUN (INNERMOST-OF OBJECT) ...)

(CL:DEFUN INNERMOST-OF (SELF)
  (CL:IF (DESCRIPTION-MODE?)
   (CL:LET* ((NEXTVALUE SELF) (TIGHTESTVARIABLE NULL) (EQUIVALENT NULL))
    (CL:LOOP
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NEXTVALUE)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
        (CL:PROGN
         (CL:SETQ EQUIVALENT
          (ACCESS-IN-CONTEXT (%VARIABLE-VALUE NEXTVALUE)
           (%HOME-CONTEXT NEXTVALUE) FALSE))
         (CL:WHEN (CL:EQ EQUIVALENT NULL)
          (CL:RETURN-FROM INNERMOST-OF NEXTVALUE))
         (CL:SETQ TIGHTESTVARIABLE NEXTVALUE)))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
        (CL:PROGN (CL:RETURN-FROM INNERMOST-OF NEXTVALUE)))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
        (CL:PROGN (CL:RETURN-FROM INNERMOST-OF TIGHTESTVARIABLE)))
       ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
        (CL:PROGN (CL:RETURN-FROM INNERMOST-OF NEXTVALUE)))
       (CL:T (CL:RETURN-FROM INNERMOST-OF NEXTVALUE))))
     (CL:SETQ NEXTVALUE EQUIVALENT)))
   (CL:LET* ((TIGHTESTVALUE SELF) (EQUIVALENT NULL))
    (CL:LOOP
     (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE TIGHTESTVALUE)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-001 SGT-PROPOSITIONS-LOGIC-SKOLEM)
        (CL:PROGN
         (CL:WHEN
          (CL:EQ
           (ACCESS-IN-CONTEXT (%VARIABLE-VALUE TIGHTESTVALUE)
            (%HOME-CONTEXT TIGHTESTVALUE) FALSE)
           NULL)
          (CL:RETURN-FROM INNERMOST-OF TIGHTESTVALUE))
         (CL:SETQ EQUIVALENT
          (ACCESS-IN-CONTEXT (%VARIABLE-VALUE TIGHTESTVALUE)
           (%HOME-CONTEXT TIGHTESTVALUE) FALSE))))
       ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
        (CL:PROGN
         (CL:WHEN (CL:EQ (%SURROGATE-VALUE TIGHTESTVALUE) NULL)
          (CL:RETURN-FROM INNERMOST-OF TIGHTESTVALUE))
         (CL:SETQ EQUIVALENT (%SURROGATE-VALUE TIGHTESTVALUE))))
       (CL:T (CL:RETURN-FROM INNERMOST-OF TIGHTESTVALUE))))
     (CL:SETQ TIGHTESTVALUE EQUIVALENT)))))

;;; (DEFGLOBAL *SKOLEM-ID-COUNTER* ...)

(CL:PROGN (CL:DEFVAR *SKOLEM-ID-COUNTER* 0) (CL:DECLAIM (CL:TYPE CL:FIXNUM *SKOLEM-ID-COUNTER*)))

;;; (DEFSPECIAL *VARIABLEIDCOUNTER* ...)

(CL:PROGN (CL:DEFVAR *VARIABLEIDCOUNTER* 0) (CL:DECLAIM (CL:TYPE CL:FIXNUM *VARIABLEIDCOUNTER*)))

;;; (DEFUN (YIELD-ANONYMOUS-SKOLEM-NAME SYMBOL) ...)

(CL:DEFUN YIELD-ANONYMOUS-SKOLEM-NAME (VARIABLE?)
  (CL:LET*
   ((SUFFIX
     (CL:IF VARIABLE?
      (INTEGER-TO-STRING
       (CL:SETQ *VARIABLEIDCOUNTER* (CL:1+ *VARIABLEIDCOUNTER*)))
      (INTEGER-TO-STRING
       (CL:SETQ *SKOLEM-ID-COUNTER* (CL:1+ *SKOLEM-ID-COUNTER*))))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SUFFIX))
   (INTERN-SYMBOL
    (CONCATENATE (CL:IF VARIABLE? "?V" "SK")
     (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LENGTH SUFFIX)) 1) "0" "")
     SUFFIX))))

;;; (DEFSPECIAL *FREESKOLEMS* ...)

(CL:DEFVAR *FREESKOLEMS* NULL
  "Cons-list of top-level existentially-quantified skolems.")

;;; (DEFUN (HELP-CREATE-SKOLEM SKOLEM) ...)

(CL:DEFUN HELP-CREATE-SKOLEM (SELF TYPE NAME ASSERTISA?)
  (CL:SETQ TYPE (UNWRAP-WRAPPED-TYPE TYPE))
  (CL:WHEN (CL:EQ NAME NULL)
   (CL:SETQ NAME (YIELD-ANONYMOUS-SKOLEM-NAME (VARIABLE? SELF))))
  (CL:SETF (%SKOLEM-NAME SELF) NAME)
  (CL:WHEN (CL:AND ASSERTISA? (CL:NOT (CL:EQ TYPE NULL)))
   (ASSERT-ISA-PROPOSITION SELF TYPE))
  SELF)

;;; (DEFUN (CREATE-SKOLEM SKOLEM) ...)

(CL:DEFUN CREATE-SKOLEM (TYPE NAME)
  (CL:LET* ((SKOLEM (NEW-SKOLEM)))
   (CL:WHEN (CL:NOT (CL:EQ *FREESKOLEMS* NULL))
    (CL:SETQ *FREESKOLEMS* (CONS SKOLEM *FREESKOLEMS*)))
   (HELP-CREATE-SKOLEM SKOLEM TYPE NAME TRUE) SKOLEM))

;;; (DEFUN (CREATE-VARIABLE PATTERN-VARIABLE) ...)

(CL:DEFUN CREATE-VARIABLE (TYPE NAME ASSERTISA?)
  (CL:LET* ((EVALUATIONMODE *EVALUATIONMODE*))
   (CL:LET* ((*EVALUATIONMODE* EVALUATIONMODE))
    (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
    (CL:WHEN (CL:AND ASSERTISA? (CL:NOT (DESCRIPTION-MODE?)))
     (CL:SETQ *EVALUATIONMODE* KWD-PROPOSITIONS-DESCRIPTION))
    (HELP-CREATE-SKOLEM (NEW-PATTERN-VARIABLE) TYPE NAME ASSERTISA?))))

;;; (DEFUN (CREATE-VARIABLE-OR-SKOLEM SKOLEM) ...)

(CL:DEFUN CREATE-VARIABLE-OR-SKOLEM (TYPE NAME)
  (CL:IF (DESCRIPTION-MODE?) (CREATE-VARIABLE TYPE NAME FALSE)
   (CL:LET* ((SKOLEM (NEW-SKOLEM)))
    (CL:LET* ((*INVISIBLEASSERTION?* TRUE))
     (CL:DECLARE (CL:SPECIAL *INVISIBLEASSERTION?*))
     (HELP-CREATE-SKOLEM SKOLEM TYPE NAME FALSE))
    SKOLEM)))

;;; (DEFCONSTANT TRUE-TRUTH-VALUE ...)

(CL:DEFVAR TRUE-TRUTH-VALUE NULL
  "Value representing TRUE.")

;;; (DEFCONSTANT FALSE-TRUTH-VALUE ...)

(CL:DEFVAR FALSE-TRUTH-VALUE NULL
  "Value representing FALSE.")

;;; (DEFCONSTANT DEFAULT-TRUE-TRUTH-VALUE ...)

(CL:DEFVAR DEFAULT-TRUE-TRUTH-VALUE NULL
  "Value representing DEFAULT-TRUE.")

;;; (DEFCONSTANT DEFAULT-FALSE-TRUTH-VALUE ...)

(CL:DEFVAR DEFAULT-FALSE-TRUTH-VALUE NULL
  "Value representing DEFAULT-FALSE.")

;;; (DEFUN (TRUE? BOOLEAN) ...)

(CL:DEFUN TRUE? (SELF)
  (CL:LET*
   ((TRUTHVALUE
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) FALSE)))
   (CL:COND
    ((CL:EQ TRUTHVALUE TRUE-TRUTH-VALUE) (CL:RETURN-FROM TRUE? TRUE))
    ((CL:EQ TRUTHVALUE DEFAULT-TRUE-TRUTH-VALUE)
     (CL:WHEN (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)
      (CL:WHEN (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:SETF (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*) TRUE))
      (CL:RETURN-FROM TRUE? TRUE)))
    ((CL:AND (CL:NOT (CL:EQ TRUTHVALUE NULL))
      (CL:> (%POSITIVE-SCORE TRUTHVALUE) 0.0d0))
     (CL:RETURN-FROM TRUE? TRUE)))
   FALSE))

;;; (DEFUN (FALSE? BOOLEAN) ...)

(CL:DEFUN FALSE? (SELF)
  (CL:LET*
   ((TRUTHVALUE
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) FALSE)))
   (CL:COND
    ((CL:EQ TRUTHVALUE FALSE-TRUTH-VALUE) (CL:RETURN-FROM FALSE? TRUE))
    ((CL:EQ TRUTHVALUE DEFAULT-FALSE-TRUTH-VALUE)
     (CL:WHEN (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*)
      (CL:WHEN (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:SETF (%LATEST-TOUCHED-DEFAULT? *QUERYITERATOR*) TRUE))
      (CL:RETURN-FROM FALSE? TRUE)))
    ((CL:AND (CL:NOT (CL:EQ TRUTHVALUE NULL))
      (CL:= (%POSITIVE-SCORE TRUTHVALUE) 0.0d0))
     (CL:RETURN-FROM FALSE? TRUE)))
   FALSE))

;;; (DEFUN (UNKNOWN? BOOLEAN) ...)

(CL:DEFUN UNKNOWN? (SELF)
  (CL:OR
   (CL:EQ
    (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) FALSE)
    NULL)
   (CL:AND
    (CL:NOT
     (CL:EQ
      (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) FALSE)
      TRUE-TRUTH-VALUE))
    (CL:NOT
     (CL:EQ
      (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) FALSE)
      FALSE-TRUTH-VALUE))
    (CL:OR *DONTUSEDEFAULTKNOWLEDGE?*
     (CL:AND
      (CL:NOT
       (CL:EQ
        (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) FALSE)
        DEFAULT-TRUE-TRUTH-VALUE))
      (CL:NOT
       (CL:EQ
        (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) FALSE)
        DEFAULT-FALSE-TRUTH-VALUE)))))))

;;; (DEFUN (DEFAULT-TRUE? BOOLEAN) ...)

(CL:DEFUN DEFAULT-TRUE? (SELF)
  (CL:EQ
   (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) FALSE)
   DEFAULT-TRUE-TRUTH-VALUE))

;;; (DEFUN (DEFAULT-FALSE? BOOLEAN) ...)

(CL:DEFUN DEFAULT-FALSE? (SELF)
  (CL:EQ
   (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF) FALSE)
   DEFAULT-FALSE-TRUTH-VALUE))

;;; (DEFUN (DEFAULTIFY-TRUTH-VALUE TRUTH-VALUE) ...)

(CL:DEFUN DEFAULTIFY-TRUTH-VALUE (TRUE? BYDEFAULT?)
  (CL:IF TRUE?
   (CL:IF BYDEFAULT? DEFAULT-TRUE-TRUTH-VALUE TRUE-TRUTH-VALUE)
   (CL:IF BYDEFAULT? DEFAULT-FALSE-TRUTH-VALUE FALSE-TRUTH-VALUE)))

;;; (DEFUN (INVERT-TRUTH-VALUE TRUTH-VALUE) ...)

(CL:DEFUN INVERT-TRUTH-VALUE (SELF)
  (CL:COND ((CL:EQ SELF TRUE-TRUTH-VALUE) FALSE-TRUTH-VALUE)
   ((CL:EQ SELF DEFAULT-TRUE-TRUTH-VALUE) DEFAULT-FALSE-TRUTH-VALUE)
   ((CL:EQ SELF FALSE-TRUTH-VALUE) TRUE-TRUTH-VALUE)
   ((CL:EQ SELF DEFAULT-FALSE-TRUTH-VALUE) DEFAULT-TRUE-TRUTH-VALUE)
   (CL:T (CL:WARN "Don't know how to invert truth value: `~A'~%" SELF)
    NULL)))

;;; (DEFUN SIGNAL-UNIFICATION-CLASH ...)

(CL:DEFUN SIGNAL-UNIFICATION-CLASH (TERM1 TERM2)
  (CL:IF (CL:AND (CL:NOT (CL:EQ TERM1 NULL)) (CL:NOT (CL:EQ TERM2 NULL)))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TERM1
     "' clashes with `" TERM2 "'")
    (CL:ERROR (NEW-CLASH (THE-STRING-READER STREAM-000))))
   (CL:ERROR (NEW-CLASH "Unification clash."))))

;;; (DEFUN SIGNAL-VARIABLE-VALUE-CLASH ...)

(CL:DEFUN SIGNAL-VARIABLE-VALUE-CLASH (SKOLEM VALUE1 VALUE2)
  (CL:IF
   (CL:AND (CL:NOT (CL:EQ VALUE1 NULL)) (CL:NOT (CL:EQ VALUE2 NULL)))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Skolem `" SKOLEM
     "' is equated with multiple values:" EOL "   `" VALUE1 "' and `"
     VALUE2 "'.")
    (CL:ERROR (NEW-CLASH (THE-STRING-READER STREAM-000))))
   (CL:ERROR (NEW-CLASH "Variable value clash."))))

;;; (DEFUN SIGNAL-TRUTH-VALUE-CLASH ...)

(CL:DEFUN SIGNAL-TRUTH-VALUE-CLASH (PROPOSITION)
  (CL:COND
   ((CL:EQ *CONTEXT*
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *MODULE*)
      SYM-PROPOSITIONS-LOGIC-META-INFERENCE-CACHE NULL))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "Derived both TRUE and FALSE for the proposition `" PROPOSITION "'."
      EOL "   Clash occurred in the meta inference cache for module `"
      *MODULE* "'.")
     (CL:ERROR (NEW-CLASH (THE-STRING-READER STREAM-000)))))
   ((CL:EQ *CONTEXT*
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *MODULE*)
      SYM-PROPOSITIONS-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE NULL))
    (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
      "Derived both TRUE and FALSE for the proposition `" PROPOSITION "'."
      EOL "   Clash occurred in the default inference cache for module `"
      *MODULE* "'.")
     (CL:ERROR (NEW-CLASH (THE-STRING-READER STREAM-001)))))
   ((CL:EQ *CONTEXT* *MODULE*)
    (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002)
      "Derived both TRUE and FALSE for the proposition `" PROPOSITION "'."
      EOL "   Clash occurred in module `" *MODULE* "'.")
     (CL:ERROR (NEW-CLASH (THE-STRING-READER STREAM-002)))))
   (CL:T
    (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-003)
      "Derived both TRUE and FALSE for the proposition `" PROPOSITION "'."
      EOL "   Clash occurred in the world `" *CONTEXT* "' in module `"
      *MODULE* "'.")
     (CL:ERROR (NEW-CLASH (THE-STRING-READER STREAM-003)))))))

;;; (DEFUN (LOGICAL-TYPE TYPE) ...)

(CL:DEFUN LOGICAL-TYPE (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:COND
       ((CL:AND (MONADIC? SELF)
         (%WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
           SYM-PROPOSITIONS-LOGIC-IOTA? FALSE-WRAPPER)))
        (%ROOT-TYPE (REPRESENTATIVE SELF)))
       ((CL:AND (MONADIC? SELF)
         (CL:NOT
          (CL:EQ
           (%ROOT-TYPE
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IO-VARIABLES SELF)))
             0))
           NULL))
         (CLASS-DESCRIPTION?
          (SURROGATE-TO-DESCRIPTION
           (%ROOT-TYPE
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IO-VARIABLES SELF)))
             0)))))
        SGT-PROPOSITIONS-PL-KERNEL-KB-CLASS)
       (CL:T SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN
      (CL:LET* ((TYPE (%ROOT-TYPE SELF)))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ TYPE NULL))
         (CL:NOT (CL:EQ TYPE SGT-PROPOSITIONS-STELLA-THING)))
        (CL:RETURN-FROM LOGICAL-TYPE TYPE)))
      (CL:LET*
       ((P NULL)
        (ITER-000
         (ALLOCATE-ITERATOR
          (UNFILTERED-DEPENDENT-ISA-PROPOSITIONS SELF))))
       (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
        (CL:WHEN
         (CL:AND (CL:EQ (%KIND P) KWD-PROPOSITIONS-ISA)
          (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? P)))
         (CL:RETURN-FROM LOGICAL-TYPE (%OPERATOR P)))))
      SGT-PROPOSITIONS-STELLA-THING))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:IF (CL:NOT (CL:EQ (%ROOT-TYPE SELF) NULL)) (%ROOT-TYPE SELF)
       SGT-PROPOSITIONS-STELLA-THING)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN SGT-PROPOSITIONS-STELLA-THING))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER)
     (CL:PROGN (WRAPPER-VALUE-TYPE SELF)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF
       (CL:AND (CL:NOT (CL:EQ (%SURROGATE-VALUE SELF) NULL))
        (CL:NOT (CL:EQ (%SURROGATE-VALUE SELF) BOTTOM)))
       (LOGICAL-TYPE (%SURROGATE-VALUE SELF))
       SGT-PROPOSITIONS-STELLA-THING)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-SET)
     (CL:PROGN SGT-PROPOSITIONS-PL-KERNEL-KB-SET))
    (CL:T (PRIMARY-TYPE SELF)))))

;;; (DEFSPECIAL *SUPPRESSUNTYPEDTYPEERROR?* ...)

(CL:DEFVAR *SUPPRESSUNTYPEDTYPEERROR?* FALSE
  "Used by 'safe-logical-type' to ask for a type
without signalling an error if none exists.")

;;; (DEFUN (SAFE-LOGICAL-TYPE TYPE) ...)

(CL:DEFUN SAFE-LOGICAL-TYPE (SELF)
  (CL:LET* ((*SUPPRESSUNTYPEDTYPEERROR?* TRUE))
   (CL:DECLARE (CL:SPECIAL *SUPPRESSUNTYPEDTYPEERROR?*))
   (LOGICAL-TYPE SELF)))

;;; (DEFUN (CLASS-LOGICAL-TYPE TYPE) ...)

(CL:DEFUN CLASS-LOGICAL-TYPE (SELF)
  (%CLASS-TYPE SELF))

;;; (DEFUN UNIFY-TYPES ...)

(CL:DEFUN UNIFY-TYPES (TERM1 TERM2)
  (CL:LET* ((TYPE1 (LOGICAL-TYPE TERM1)) (TYPE2 (LOGICAL-TYPE TERM2)))
   (CL:COND
    ((CL:OR (CL:EQ TYPE1 TYPE2)
      (CL:OR (LOGICAL-SUBTYPE-OF? TYPE1 TYPE2)
       (LOGICAL-SUBTYPE-OF? TYPE2 TYPE1))))
    ((CL:EQ TYPE1 SGT-PROPOSITIONS-STELLA-THING)
     (CL:WHEN (ISA? TERM1 SGT-PROPOSITIONS-LOGIC-SKOLEM))
     (CL:SETF (%ROOT-TYPE TERM1) TYPE2))
    ((CL:EQ TYPE2 SGT-PROPOSITIONS-STELLA-THING)
     (CL:WHEN (ISA? TERM2 SGT-PROPOSITIONS-LOGIC-SKOLEM)
      (CL:SETF (%ROOT-TYPE TERM2) TYPE1)))
    (CL:T (CL:WHEN (BOTTOM? TERM2) (CL:RETURN-FROM UNIFY-TYPES))
     (SIGNAL-UNIFICATION-CLASH TERM1 TERM2)))))

;;; (DEFUN UNIFY-SKOLEM-AND-VALUE ...)

(CL:DEFUN UNIFY-SKOLEM-AND-VALUE (SKOLEM VALUE)
  (CL:LET*
   ((PROP NULL)
    (ITER-000
     (ALLOCATE-ITERATOR (UNFILTERED-DEPENDENT-PROPOSITIONS SKOLEM NULL))))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PROP (%VALUE ITER-000))
    (EVALUATE-PROPOSITION PROP))))

;;; (DEFUN BIND-SKOLEM-TO-VALUE ...)

(CL:DEFUN BIND-SKOLEM-TO-VALUE (FROMSKOLEM TOVALUE TOPLEVELUPDATE?)
  (CL:LET*
   ((TYPEISOK? FALSE) (TYPE (%ROOT-TYPE FROMSKOLEM))
    (EQUATINGPROPOSITION NULL))
   (CL:WHEN (SKOLEM? TOVALUE)
    (CL:SETQ EQUATINGPROPOSITION
     (FIND-EQUATING-PROPOSITION TOVALUE FROMSKOLEM))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ EQUATINGPROPOSITION NULL))
      (DEFAULT-TRUE? EQUATINGPROPOSITION))
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
        "ERROR: Equating two skolems `" FROMSKOLEM "' and `" TOVALUE
        "' by default is not yet supported." EOL "." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
      (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))))
   (CL:MULTIPLE-VALUE-SETQ (TYPEISOK? TOVALUE)
    (CHECK-TYPE? TOVALUE TYPE TRUE))
   (CL:WHEN (CL:NOT TYPEISOK?)
    (CL:SETQ EQUATINGPROPOSITION
     (FIND-EQUATING-PROPOSITION TOVALUE FROMSKOLEM))
    (CL:COND
     ((CL:EQ EQUATINGPROPOSITION NULL)
      (CL:LET* ((*TERMUNDERCONSTRUCTION* *TERMUNDERCONSTRUCTION*))
       (CL:DECLARE (CL:SPECIAL *TERMUNDERCONSTRUCTION*))
       (CL:WHEN (CL:EQ *TERMUNDERCONSTRUCTION* NULL)
        (CL:SETQ *TERMUNDERCONSTRUCTION*
         (%DEFINING-PROPOSITION FROMSKOLEM)))
       (CL:LET* ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING)
         "WARNING: Type check violation: Assigned value `" TOVALUE "'" EOL
         "   to skolem with type `" TYPE "'." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
         KWD-PROPOSITIONS-WARNING))))
     (CL:T (VERIFY-ARGUMENT-TYPES-AND-COUNT EQUATINGPROPOSITION)))))
  (CL:LET*
   ((OBJECT-000 FROMSKOLEM) (VALUE-000 TOVALUE)
    (OLD-VALUE-000 (%VARIABLE-VALUE OBJECT-000))
    (NEW-VALUE-000
     (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000 (%HOME-CONTEXT OBJECT-000)
      FALSE)))
   (CL:WHEN
    (CL:NOT
     (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
      (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
       SGT-PROPOSITIONS-STELLA-CS-VALUE)))
    (CL:SETF (%VARIABLE-VALUE OBJECT-000) NEW-VALUE-000)))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TOVALUE)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET*
       ((EQUIVALENTSKOLEM
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE TOVALUE)
          (%HOME-CONTEXT TOVALUE) FALSE)))
       (CL:LOOP (CL:WHEN (CL:EQ EQUIVALENTSKOLEM NULL) (CL:RETURN))
        (CL:COND
         ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE EQUIVALENTSKOLEM)
           SGT-PROPOSITIONS-LOGIC-SKOLEM)
          (CL:PROGN
           (CL:WHEN (CL:EQ EQUIVALENTSKOLEM TOVALUE)
            (CL:LET*
             ((OBJECT-001 FROMSKOLEM) (VALUE-001 NULL)
              (OLD-VALUE-002 (%VARIABLE-VALUE OBJECT-001))
              (NEW-VALUE-001
               (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-001
                (%HOME-CONTEXT OBJECT-001) FALSE)))
             (CL:WHEN
              (CL:NOT
               (CL:AND (CL:NOT (CL:EQ OLD-VALUE-002 NULL))
                (CL:EQ (PRIMARY-TYPE OLD-VALUE-002)
                 SGT-PROPOSITIONS-STELLA-CS-VALUE)))
              (CL:SETF (%VARIABLE-VALUE OBJECT-001) NEW-VALUE-001)))
            (CL:RETURN-FROM BIND-SKOLEM-TO-VALUE))
           (CL:SETQ EQUIVALENTSKOLEM
            (ACCESS-IN-CONTEXT (%VARIABLE-VALUE EQUIVALENTSKOLEM)
             (%HOME-CONTEXT EQUIVALENTSKOLEM) FALSE))))
         (CL:T (CL:RETURN)))))
      (CL:LET*
       ((OBJECT-002 TOVALUE)
        (VALUE-002 (CONS FROMSKOLEM (VARIABLE-VALUE-INVERSE TOVALUE)))
        (OLD-VALUE-004 (%VARIABLE-VALUE-INVERSE OBJECT-002))
        (NEW-VALUE-002
         (UPDATE-IN-CONTEXT OLD-VALUE-004 VALUE-002
          (%HOME-CONTEXT OBJECT-002) FALSE)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-004 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-004)
           SGT-PROPOSITIONS-STELLA-CS-VALUE)))
        (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-002) NEW-VALUE-002)))
      (CL:WHEN (CL:EQ (%ROOT-TYPE TOVALUE) NULL)
       (CL:SETF (%ROOT-TYPE TOVALUE) (%ROOT-TYPE FROMSKOLEM)))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:LET*
       ((OBJECT-003 TOVALUE)
        (VALUE-003 (CONS FROMSKOLEM (VARIABLE-VALUE-INVERSE TOVALUE)))
        (OLD-VALUE-005 (%VARIABLE-VALUE-INVERSE OBJECT-003))
        (NEW-VALUE-003
         (UPDATE-IN-CONTEXT OLD-VALUE-005 VALUE-003
          (%HOME-CONTEXT OBJECT-003) FALSE)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-005 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-005)
           SGT-PROPOSITIONS-STELLA-CS-VALUE)))
        (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-003) NEW-VALUE-003)))))
    (CL:T
     (CL:LET* ((PROPOSITION (%DEFINING-PROPOSITION FROMSKOLEM)))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ PROPOSITION NULL))
        (REWRAP-ITH-ARGUMENT? TOVALUE PROPOSITION
         (LENGTH (%ARGUMENTS PROPOSITION))))
       (CL:LET*
        ((OBJECT-004 FROMSKOLEM) (VALUE-004 (REWRAP-ARGUMENT TOVALUE))
         (OLD-VALUE-006 (%VARIABLE-VALUE OBJECT-004))
         (NEW-VALUE-004
          (UPDATE-IN-CONTEXT OLD-VALUE-006 VALUE-004
           (%HOME-CONTEXT OBJECT-004) FALSE)))
        (CL:WHEN
         (CL:NOT
          (CL:AND (CL:NOT (CL:EQ OLD-VALUE-006 NULL))
           (CL:EQ (PRIMARY-TYPE OLD-VALUE-006)
            SGT-PROPOSITIONS-STELLA-CS-VALUE)))
         (CL:SETF (%VARIABLE-VALUE OBJECT-004) NEW-VALUE-004))))))))
  (HANDLE-OUT-OF-DATE-INFERENCE-CACHE KWD-PROPOSITIONS-ASSERT
   (%DEFINING-PROPOSITION FROMSKOLEM))
  (REACT-TO-KB-UPDATE *CONTEXT* FROMSKOLEM)
  (CL:WHEN (CL:NOT (SKOLEM? TOVALUE))
   (CL:WHEN (CL:NOT (CL:EQ (%DEFINING-PROPOSITION FROMSKOLEM) NULL))
    (REACT-TO-SKOLEM-VALUE-UPDATE FROMSKOLEM NULL TOVALUE
     TOPLEVELUPDATE?))))

;;; (DEFUN UNBIND-SKOLEM-VALUE ...)

(CL:DEFUN UNBIND-SKOLEM-VALUE (SKOLEM TOPLEVELUPDATE?)
  (CL:LET*
   ((OLDVALUE (VALUE-OF SKOLEM))
    (DEFININGPROP (%DEFINING-PROPOSITION SKOLEM))
    (EQUATINGPROP (FIND-EQUATING-PROPOSITION OLDVALUE SKOLEM)))
   (CL:LET*
    ((OBJECT-000 SKOLEM) (VALUE-000 NULL)
     (OLD-VALUE-000 (%VARIABLE-VALUE OBJECT-000))
     (NEW-VALUE-000
      (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
       (%HOME-CONTEXT OBJECT-000) FALSE)))
    (CL:WHEN
     (CL:NOT
      (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
       (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
        SGT-PROPOSITIONS-STELLA-CS-VALUE)))
     (CL:SETF (%VARIABLE-VALUE OBJECT-000) NEW-VALUE-000)))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE OLDVALUE)
      SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:IF (CL:EQ (%%VALUE (VARIABLE-VALUE-INVERSE OLDVALUE)) SKOLEM)
       (CL:LET*
        ((OBJECT-001 OLDVALUE)
         (VALUE-001 (%%REST (VARIABLE-VALUE-INVERSE OLDVALUE)))
         (OLD-VALUE-001 (%VARIABLE-VALUE-INVERSE OBJECT-001))
         (NEW-VALUE-001
          (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001
           (%HOME-CONTEXT OBJECT-001) FALSE)))
        (CL:WHEN
         (CL:NOT
          (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
           (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
            SGT-PROPOSITIONS-STELLA-CS-VALUE)))
         (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-001) NEW-VALUE-001)))
       (CL:LET*
        ((OBJECT-002 OLDVALUE)
         (VALUE-002
          (REMOVE (COPY-CONS-LIST (VARIABLE-VALUE-INVERSE OLDVALUE))
           SKOLEM))
         (OLD-VALUE-002 (%VARIABLE-VALUE-INVERSE OBJECT-002))
         (NEW-VALUE-002
          (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-002
           (%HOME-CONTEXT OBJECT-002) FALSE)))
        (CL:WHEN
         (CL:NOT
          (CL:AND (CL:NOT (CL:EQ OLD-VALUE-002 NULL))
           (CL:EQ (PRIMARY-TYPE OLD-VALUE-002)
            SGT-PROPOSITIONS-STELLA-CS-VALUE)))
         (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-002) NEW-VALUE-002))))))
    (CL:T))
   (CL:COND
    ((CL:NOT (CL:EQ EQUATINGPROP NULL))
     (UPDATE-PROPOSITION-TRUTH-VALUE EQUATINGPROP
      KWD-PROPOSITIONS-RETRACT-TRUE)
     (HANDLE-OUT-OF-DATE-INFERENCE-CACHE KWD-PROPOSITIONS-RETRACT
      EQUATINGPROP))
    (CL:T
     (HANDLE-OUT-OF-DATE-INFERENCE-CACHE KWD-PROPOSITIONS-RETRACT
      DEFININGPROP)))
   (CL:WHEN (CL:NOT (CL:EQ DEFININGPROP NULL))
    (REACT-TO-SKOLEM-VALUE-UPDATE SKOLEM OLDVALUE NULL TOPLEVELUPDATE?))))

;;; (DEFUN CONSTRAIN-AS-SUBSET ...)

(CL:DEFUN CONSTRAIN-AS-SUBSET (SET1 SET2)
  (CL:WHEN (CL:> (LENGTH SET1) (LENGTH SET2))
   (SIGNAL-UNIFICATION-CLASH SET1 SET2))
  (CL:LET* ((COPY1 NIL) (COPY2 NIL))
   (CL:LET* ((I2 NULL) (ITER-000 (ALLOCATE-ITERATOR SET2)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ I2 (%VALUE ITER-000))
     (CL:SETQ COPY2 (CONS I2 COPY2))))
   (CL:LET* ((I1 NULL) (ITER-001 (ALLOCATE-ITERATOR SET1)))
    (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ I1 (%VALUE ITER-001))
     (CL:IF (MEMBER? COPY2 I1) (CL:SETQ COPY2 (REMOVE COPY2 I1))
      (CL:SETQ COPY1 (CONS I1 COPY1)))))
   (CL:WHEN (CL:EQ COPY1 NIL) (CL:RETURN-FROM CONSTRAIN-AS-SUBSET))
   (CL:WHEN (CL:= (LENGTH COPY2) 1)
    (CL:LET* ((ITEM1 (%%VALUE COPY1)) (ITEM2 (%%VALUE COPY2)))
     (EQUATE-VALUES ITEM1 ITEM2) (CL:RETURN-FROM CONSTRAIN-AS-SUBSET)))
   (CL:LET* ((SKOLEMCOUNT1 0) (SKOLEMCOUNT2 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM SKOLEMCOUNT1 SKOLEMCOUNT2))
    (CL:LET* ((I1 NULL) (ITER-002 COPY1))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:PROGN (CL:SETQ I1 (%%VALUE ITER-002))
       (CL:SETQ ITER-002 (%%REST ITER-002)))
      (CL:WHEN (SKOLEM? I1) (CL:SETQ SKOLEMCOUNT1 (CL:1+ SKOLEMCOUNT1)))))
    (CL:LET* ((I2 NULL) (ITER-003 COPY2))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
      (CL:PROGN (CL:SETQ I2 (%%VALUE ITER-003))
       (CL:SETQ ITER-003 (%%REST ITER-003)))
      (CL:WHEN (SKOLEM? I2) (CL:SETQ SKOLEMCOUNT2 (CL:1+ SKOLEMCOUNT2)))))
    (CL:WHEN (CL:= (CL:+ SKOLEMCOUNT1 SKOLEMCOUNT2) 0)
     (SIGNAL-UNIFICATION-CLASH SET1 SET2)))))

;;; (DEFUN EQUATE-COLLECTIONS ...)

(CL:DEFUN EQUATE-COLLECTIONS (COL1 COL2)
  (CL:WHEN (CL:AND (ORDERED? COL1) (ORDERED? COL2))
   (CL:LET*
    ((I2 NULL) (I1 NULL) (ITER-000 (ALLOCATE-ITERATOR COL1))
     (ITER-001 (ALLOCATE-ITERATOR COL2)))
    (CL:LOOP WHILE (CL:AND (NEXT? ITER-000) (NEXT? ITER-001)) DO
     (CL:SETQ I1 (%VALUE ITER-000)) (CL:SETQ I2 (%VALUE ITER-001))
     (EQUATE-VALUES I1 I2)))
   (CL:RETURN-FROM EQUATE-COLLECTIONS))
  (CL:WHEN (CL:AND (NO-DUPLICATES? COL1) (NO-DUPLICATES? COL2))
   (CONSTRAIN-AS-SUBSET COL1 COL2) (CONSTRAIN-AS-SUBSET COL2 COL1)))

;;; (DEFUN EQUATE-VALUES ...)

(CL:DEFUN EQUATE-VALUES (TERM1 TERM2)
  (CL:COND ((EQL? TERM1 TERM2))
   ((SKOLEM? TERM1) (BIND-SKOLEM-TO-VALUE TERM1 TERM2 FALSE))
   ((SKOLEM? TERM2) (BIND-SKOLEM-TO-VALUE TERM2 TERM1 FALSE))
   ((CL:AND (COLLECTION? TERM1) (COLLECTION? TERM2))
    (EQUATE-COLLECTIONS TERM1 TERM2))
   (CL:T (SIGNAL-UNIFICATION-CLASH TERM1 TERM2))))

(CL:DEFMETHOD CONFLICTING-DEFAULT-VALUES ((SELF SKOLEM))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-CONFLICTING-DEFAULT-VALUES NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL ANSWER)))

;;; (DEFUN (UNEQUATE-CONFLICTING-DEFAULT-VALUES? BOOLEAN) ...)

(CL:DEFUN UNEQUATE-CONFLICTING-DEFAULT-VALUES? (NEWEQUATINGPROP)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS NEWEQUATINGPROP))
    (FIRSTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0))
    (FIRSTARGISSKOLEM? (SKOLEM? FIRSTARG))
    (FIRSTARGVALUE (INNERMOST-OF FIRSTARG))
    (SECONDARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1))
    (SECONDARGISSKOLEM? (SKOLEM? SECONDARG))
    (SECONDARGVALUE (INNERMOST-OF SECONDARG))
    (NEWISDEFAULT? (DEFAULT-TRUE? NEWEQUATINGPROP)) (NEWTRUTHVALUE NULL)
    (EQUATINGPROP NULL))
   (CL:COND
    ((EQL? FIRSTARGVALUE SECONDARGVALUE)
     (CL:RETURN-FROM UNEQUATE-CONFLICTING-DEFAULT-VALUES? TRUE))
    ((SKOLEM? FIRSTARGVALUE)
     (CL:IF
      (CL:OR (CL:EQ (CONFLICTING-DEFAULT-VALUES FIRSTARGVALUE) NIL)
       (CL:NOT NEWISDEFAULT?))
      (CL:RETURN-FROM UNEQUATE-CONFLICTING-DEFAULT-VALUES? TRUE)
      (CL:RETURN-FROM UNEQUATE-CONFLICTING-DEFAULT-VALUES? FALSE)))
    ((SKOLEM? SECONDARGVALUE)
     (CL:IF
      (CL:OR (CL:EQ (CONFLICTING-DEFAULT-VALUES SECONDARGVALUE) NIL)
       (CL:NOT NEWISDEFAULT?))
      (CL:RETURN-FROM UNEQUATE-CONFLICTING-DEFAULT-VALUES? TRUE)
      (CL:RETURN-FROM UNEQUATE-CONFLICTING-DEFAULT-VALUES? FALSE))))
   (CL:WHEN (CL:AND FIRSTARGISSKOLEM? SECONDARGISSKOLEM? NEWISDEFAULT?)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "ERROR: Equating two skolems `" FIRSTARG "' and `" SECONDARG
       "' by default is not yet supported." EOL "." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
     (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   (CL:SETQ NEWTRUTHVALUE (%TRUTH-VALUE NEWEQUATINGPROP))
   (CL:SETF (%TRUTH-VALUE NEWEQUATINGPROP) NULL)
   (CL:WHEN FIRSTARGISSKOLEM?
    (CL:LET* ((*DONTUSEDEFAULTKNOWLEDGE?* TRUE))
     (CL:DECLARE (CL:SPECIAL *DONTUSEDEFAULTKNOWLEDGE?*))
     (CL:SETQ EQUATINGPROP
      (FIND-EQUATING-PROPOSITION FIRSTARGVALUE FIRSTARG)))
    (CL:WHEN (CL:EQ EQUATINGPROP NULL)
     (CL:SETQ EQUATINGPROP
      (FIND-EQUATING-PROPOSITION FIRSTARGVALUE FIRSTARG))
     (CL:LOOP WHILE (CL:NOT (EQL? (VALUE-OF FIRSTARG) FIRSTARGVALUE)) DO
      (CL:SETQ FIRSTARG (VALUE-OF FIRSTARG)))
     (CL:LET* ((SKOLEM FIRSTARG))
      (CL:LET*
       ((OBJECT-000 SKOLEM) (VALUE-000 NULL)
        (OLD-VALUE-001 (%VARIABLE-VALUE OBJECT-000))
        (NEW-VALUE-000
         (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-000
          (%HOME-CONTEXT OBJECT-000) FALSE)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
           SGT-PROPOSITIONS-STELLA-CS-VALUE)))
        (CL:SETF (%VARIABLE-VALUE OBJECT-000) NEW-VALUE-000)))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SKOLEM)
       SYM-PROPOSITIONS-LOGIC-CONFLICTING-DEFAULT-VALUES
       (CONS EQUATINGPROP (CONFLICTING-DEFAULT-VALUES SKOLEM)) NULL)
      (CL:WHEN NEWISDEFAULT?
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SKOLEM)
        SYM-PROPOSITIONS-LOGIC-CONFLICTING-DEFAULT-VALUES
        (CONS NEWEQUATINGPROP (CONFLICTING-DEFAULT-VALUES SKOLEM))
        NULL)))))
   (CL:WHEN SECONDARGISSKOLEM?
    (CL:LET* ((*DONTUSEDEFAULTKNOWLEDGE?* TRUE))
     (CL:DECLARE (CL:SPECIAL *DONTUSEDEFAULTKNOWLEDGE?*))
     (CL:SETQ EQUATINGPROP
      (FIND-EQUATING-PROPOSITION SECONDARGVALUE SECONDARG)))
    (CL:WHEN (CL:EQ EQUATINGPROP NULL)
     (CL:SETQ EQUATINGPROP
      (FIND-EQUATING-PROPOSITION FIRSTARGVALUE FIRSTARG))
     (CL:LOOP WHILE (CL:NOT (EQL? (VALUE-OF SECONDARG) SECONDARGVALUE)) DO
      (CL:SETQ SECONDARG (VALUE-OF SECONDARG)))
     (CL:LET* ((SKOLEM SECONDARG))
      (CL:LET*
       ((OBJECT-001 SKOLEM) (VALUE-001 NULL)
        (OLD-VALUE-002 (%VARIABLE-VALUE OBJECT-001))
        (NEW-VALUE-001
         (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-001
          (%HOME-CONTEXT OBJECT-001) FALSE)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-002 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-002)
           SGT-PROPOSITIONS-STELLA-CS-VALUE)))
        (CL:SETF (%VARIABLE-VALUE OBJECT-001) NEW-VALUE-001)))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SKOLEM)
       SYM-PROPOSITIONS-LOGIC-CONFLICTING-DEFAULT-VALUES
       (CONS EQUATINGPROP (CONFLICTING-DEFAULT-VALUES SKOLEM)) NULL)
      (CL:WHEN NEWISDEFAULT?
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SKOLEM)
        SYM-PROPOSITIONS-LOGIC-CONFLICTING-DEFAULT-VALUES
        (CONS NEWEQUATINGPROP (CONFLICTING-DEFAULT-VALUES SKOLEM))
        NULL)))))
   (CL:SETF (%TRUTH-VALUE NEWEQUATINGPROP) NEWTRUTHVALUE)
   (CL:OR (CL:AND (CL:NOT FIRSTARGISSKOLEM?) (CL:NOT SECONDARGISSKOLEM?))
    (CL:NOT NEWISDEFAULT?))))

;;; (DEFUN (UNEQUATE-VALUES? BOOLEAN) ...)

(CL:DEFUN UNEQUATE-VALUES? (TERM1 TERM2)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM1) SGT-PROPOSITIONS-LOGIC-SKOLEM)
    (CL:PROGN
     (CL:WHEN
      (EQL?
       (ACCESS-IN-CONTEXT (%VARIABLE-VALUE TERM1) (%HOME-CONTEXT TERM1)
        FALSE)
       TERM2)
      (UNBIND-SKOLEM-VALUE TERM1 FALSE)
      (CL:RETURN-FROM UNEQUATE-VALUES? TRUE))))
   (CL:T))
  FALSE)

;;; (DEFUN BIND-TO-EQUIVALENT-VALUE ...)

(CL:DEFUN BIND-TO-EQUIVALENT-VALUE (FROM TO)
  (CL:WHEN (CL:EQ FROM TO) (CL:RETURN-FROM BIND-TO-EQUIVALENT-VALUE))
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE FROM) SGT-PROPOSITIONS-LOGIC-SKOLEM)
    (CL:PROGN
     (CL:LET*
      ((OBJECT-000 FROM) (VALUE-000 TO)
       (OLD-VALUE-000 (%VARIABLE-VALUE OBJECT-000))
       (NEW-VALUE-000
        (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
         (%HOME-CONTEXT OBJECT-000) FALSE)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%VARIABLE-VALUE OBJECT-000) NEW-VALUE-000)))))
   (CL:T
    (CL:WHEN
     (CL:EQ
      (ACCESS-IN-CONTEXT (%EQUIVALENT-VALUE FROM) (%HOME-CONTEXT FROM)
       FALSE)
      TO)
     (CL:RETURN-FROM BIND-TO-EQUIVALENT-VALUE))
    (CL:LET*
     ((OBJECT-001 FROM) (VALUE-001 TO)
      (OLD-VALUE-002 (%EQUIVALENT-VALUE OBJECT-001))
      (NEW-VALUE-001
       (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-001
        (%HOME-CONTEXT OBJECT-001) FALSE)))
     (CL:WHEN
      (CL:NOT
       (CL:AND (CL:NOT (CL:EQ OLD-VALUE-002 NULL))
        (CL:EQ (PRIMARY-TYPE OLD-VALUE-002)
         SGT-PROPOSITIONS-STELLA-CS-VALUE)))
      (CL:SETF (%EQUIVALENT-VALUE OBJECT-001) NEW-VALUE-001)))))
  (CL:LET*
   ((OBJECT-002 TO) (VALUE-002 (CONS FROM (VARIABLE-VALUE-INVERSE FROM)))
    (OLD-VALUE-003 (%VARIABLE-VALUE-INVERSE OBJECT-002))
    (NEW-VALUE-002
     (UPDATE-IN-CONTEXT OLD-VALUE-003 VALUE-002 (%HOME-CONTEXT OBJECT-002)
      FALSE)))
   (CL:WHEN
    (CL:NOT
     (CL:AND (CL:NOT (CL:EQ OLD-VALUE-003 NULL))
      (CL:EQ (PRIMARY-TYPE OLD-VALUE-003)
       SGT-PROPOSITIONS-STELLA-CS-VALUE)))
    (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-002) NEW-VALUE-002))))

;;; (DEFUN UNBIND-EQUIVALENT-VALUE ...)

(CL:DEFUN UNBIND-EQUIVALENT-VALUE (SELF)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF) SGT-PROPOSITIONS-LOGIC-SKOLEM)
    (CL:PROGN (UNBIND-SKOLEM-VALUE SELF FALSE)))
   (CL:T
    (CL:LET* ((OLDVALUE (VALUE-OF SELF)))
     (CL:LET*
      ((OBJECT-000 SELF) (VALUE-000 NULL)
       (OLD-VALUE-000 (%EQUIVALENT-VALUE OBJECT-000))
       (NEW-VALUE-000
        (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
         (%HOME-CONTEXT OBJECT-000) FALSE)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%EQUIVALENT-VALUE OBJECT-000) NEW-VALUE-000)))
     (CL:IF (CL:EQ (%%VALUE (VARIABLE-VALUE-INVERSE OLDVALUE)) SELF)
      (CL:LET*
       ((OBJECT-001 OLDVALUE)
        (VALUE-001 (%%REST (VARIABLE-VALUE-INVERSE OLDVALUE)))
        (OLD-VALUE-001 (%VARIABLE-VALUE-INVERSE OBJECT-001))
        (NEW-VALUE-001
         (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001
          (%HOME-CONTEXT OBJECT-001) FALSE)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
           SGT-PROPOSITIONS-STELLA-CS-VALUE)))
        (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-001) NEW-VALUE-001)))
      (CL:LET*
       ((OBJECT-002 OLDVALUE)
        (VALUE-002
         (REMOVE (COPY-CONS-LIST (VARIABLE-VALUE-INVERSE OLDVALUE)) SELF))
        (OLD-VALUE-002 (%VARIABLE-VALUE-INVERSE OBJECT-002))
        (NEW-VALUE-002
         (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-002
          (%HOME-CONTEXT OBJECT-002) FALSE)))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (CL:EQ OLD-VALUE-002 NULL))
          (CL:EQ (PRIMARY-TYPE OLD-VALUE-002)
           SGT-PROPOSITIONS-STELLA-CS-VALUE)))
        (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-002) NEW-VALUE-002)))))
    (HANDLE-OUT-OF-DATE-INFERENCE-CACHE KWD-PROPOSITIONS-RETRACT NULL))))

;;; (DEFUN (EQUIVALENT-COLLECTION-PRIORITY INTEGER) ...)

(CL:DEFUN EQUIVALENT-COLLECTION-PRIORITY (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN 1))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
     (CL:PROGN 2))
    (CL:T 0))))

;;; (DEFGLOBAL *EQUIVALENCE-COLLECTIONS?* ...)

(CL:DEFVAR *EQUIVALENCE-COLLECTIONS?* TRUE
  "Experiment with equality reasoning on collections.")

;;; (DEFUN EQUIVALENCE-COLLECTIONS ...)

(CL:DEFUN EQUIVALENCE-COLLECTIONS (COLLECTION1 COLLECTION2)
  (CL:WHEN (CL:NOT *EQUIVALENCE-COLLECTIONS?*)
   (CL:RETURN-FROM EQUIVALENCE-COLLECTIONS))
  (CL:LET*
   ((VALUE1 (EQUIVALENT-VALUE-OF (VALUE-OF COLLECTION1)))
    (VALUE2 (EQUIVALENT-VALUE-OF (VALUE-OF COLLECTION2))))
   (CL:IF
    (CL:> (EQUIVALENT-COLLECTION-PRIORITY VALUE1)
     (EQUIVALENT-COLLECTION-PRIORITY VALUE2))
    (BIND-TO-EQUIVALENT-VALUE VALUE2 VALUE1)
    (BIND-TO-EQUIVALENT-VALUE VALUE1 VALUE2))))

;;; (DEFUN REVISE-EQUIVALENCES ...)

(CL:DEFUN REVISE-EQUIVALENCES (PROPOSITION GOESTRUE?)
  (CL:LET*
   ((ARG1
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 0))
    (ARG2
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 1)))
   (CL:COND
    (GOESTRUE?
     (CL:WHEN
      (CL:AND (DESCRIPTION-IMPLIES-DESCRIPTION? ARG1 ARG2)
       (DESCRIPTION-IMPLIES-DESCRIPTION? ARG2 ARG1))
      (EQUIVALENCE-COLLECTIONS ARG1 ARG2)))
    ((CL:OR
      (CL:NOT
       (CL:EQ
        (ACCESS-IN-CONTEXT (%EQUIVALENT-VALUE ARG1) (%HOME-CONTEXT ARG1)
         FALSE)
        NULL))
      (CL:NOT
       (CL:EQ
        (ACCESS-IN-CONTEXT (%EQUIVALENT-VALUE ARG2) (%HOME-CONTEXT ARG2)
         FALSE)
        NULL)))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "DIDN'T FINISH 'revise-equivalences' YET. DON'T KNOW HOW" EOL
      "   TO REMOVE AN 'equivalent-value' LINK" EOL))
    ((CL:OR
      (CL:AND (ISA? ARG1 SGT-PROPOSITIONS-LOGIC-SKOLEM)
       (CL:NOT
        (CL:EQ
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE ARG1) (%HOME-CONTEXT ARG1)
          FALSE)
         NULL)))
      (CL:AND (ISA? ARG2 SGT-PROPOSITIONS-LOGIC-SKOLEM)
       (CL:NOT
        (CL:EQ
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE ARG2) (%HOME-CONTEXT ARG2)
          FALSE)
         NULL))))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "DIDN'T FINISH 'revise-equivalences' YET. DON'T KNOW HOW" EOL
      "   TO REMOVE AN 'equivalent-value' LINK" EOL)))))

;;; (DEFUN (FIND-EQUATING-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FIND-EQUATING-PROPOSITION (DIRECTOBJECT INDIRECTOBJECT)
  (CL:LET*
   ((INDIRECTOBJECTVALUE (VALUE-OF INDIRECTOBJECT))
    (BACKLINKEDINDIRECTOBJECT INDIRECTOBJECTVALUE))
   (CL:WHEN
    (CL:NOT
     (ISA? BACKLINKEDINDIRECTOBJECT SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT))
    (CL:SETQ BACKLINKEDINDIRECTOBJECT INDIRECTOBJECT)
    (CL:LOOP WHILE
     (CL:NOT
      (EQL? (VALUE-OF BACKLINKEDINDIRECTOBJECT) INDIRECTOBJECTVALUE))
     DO
     (CL:SETQ BACKLINKEDINDIRECTOBJECT
      (VALUE-OF BACKLINKEDINDIRECTOBJECT))))
   (CL:LET* ((VALUE-000 NULL))
    (CL:LET*
     ((PROP NULL)
      (ITER-000
       (CL:IF (DESCRIPTION-MODE?)
        (ALLOCATE-ITERATOR
         (UNFILTERED-DEPENDENT-PROPOSITIONS BACKLINKEDINDIRECTOBJECT
          SGT-PROPOSITIONS-PL-KERNEL-KB-EQUIVALENT))
        (ALL-TRUE-DEPENDENT-PROPOSITIONS BACKLINKEDINDIRECTOBJECT
         SGT-PROPOSITIONS-PL-KERNEL-KB-EQUIVALENT FALSE))))
     (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PROP (%VALUE ITER-000))
      (CL:WHEN
       (CL:AND
        (CL:EQ (%OPERATOR PROP) SGT-PROPOSITIONS-PL-KERNEL-KB-EQUIVALENT)
        (CL:OR
         (CL:AND
          (EQL?
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP))) 0)
           DIRECTOBJECT)
          (EQL?
           (VALUE-OF
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP))) 1))
           INDIRECTOBJECTVALUE))
         (CL:AND
          (EQL?
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP))) 1)
           DIRECTOBJECT)
          (EQL?
           (VALUE-OF
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP))) 0))
           INDIRECTOBJECTVALUE))))
       (CL:SETQ VALUE-000 PROP) (CL:RETURN))))
    (CL:LET* ((VALUE-001 VALUE-000)) VALUE-001))))

;;; (DEFCONSTANT TRUE-PROPOSITION ...)

(CL:DEFVAR TRUE-PROPOSITION NULL)

;;; (DEFCONSTANT FALSE-PROPOSITION ...)

(CL:DEFVAR FALSE-PROPOSITION NULL)

;;; (DEFUN (EVALUATE-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-TERM (SELF)
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER)
     (CL:PROGN (EVALUATE-LITERAL-WRAPPER-TERM SELF)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
     (CL:PROGN (EVALUATE-SURROGATE-TERM SELF)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
     (CL:PROGN (EVALUATE-SYMBOL-TERM SELF)))
    ((CL:EQ TEST-VALUE-001 SGT-PROPOSITIONS-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 (%%VALUE SELF)))
       (CL:COND
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-SETOFALL)
          (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-THE-ONLY)
          (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-KAPPA))
         (EVALUATE-LOGIC-OBJECT-TERM
          (EVALUATE-DESCRIPTION-TERM SELF TRUE)))
        ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-CREATE)
         (EVALUATE-CREATE-TERM SELF))
        (CL:T (EVALUATE-FUNCTION-TERM SELF))))))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN (EVALUATE-LOGIC-OBJECT-TERM SELF)))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-PROPOSITIONS-STELLA-THING)
     (CL:PROGN SELF))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "Can't evaluate the term `" SELF "'")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (EVALUATE-LITERAL-WRAPPER-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-LITERAL-WRAPPER-TERM (SELF)
  (PERMANENTIFY SELF))

;;; (DEFUN (EVALUATE-SURROGATE-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-SURROGATE-TERM (SELF)
  (CL:COND
   ((CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION)
    (CL:LET* ((VALUE (%SURROGATE-VALUE SELF)))
     (CL:COND
      ((CL:NOT (CL:EQ VALUE NULL))
       (CL:COND
        ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE VALUE)
          SGT-PROPOSITIONS-STELLA-RELATION)
         (CL:PROGN (GET-DESCRIPTION SELF)))
        (CL:T VALUE)))
      (CL:T (CL:SETQ SELF (COERCE-TO-BOUND-OR-LOCAL-SURROGATE SELF))
       (CREATE-LOGIC-INSTANCE SELF NULL) (%SURROGATE-VALUE SELF)))))
   ((CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-DESCRIPTION)
    (CL:LET* ((SURROGATEVALUE (%SURROGATE-VALUE SELF)))
     (CL:COND
      ((CL:EQ SURROGATEVALUE NULL)
       (CL:SETQ SELF (COERCE-TO-BOUND-OR-LOCAL-SURROGATE SELF))
       (CREATE-LOGIC-INSTANCE SELF NULL) SELF)
      ((ISA? SURROGATEVALUE SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER)
       SURROGATEVALUE)
      (CL:T SELF))))
   ((CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-INTENSIONAL-ASSERTION)
    (CL:LET*
     ((DIRECTVALUE (%SURROGATE-VALUE SELF)) (INTENSIONALSKOLEM NULL))
     (CL:WHEN (SKOLEM? DIRECTVALUE)
      (CL:RETURN-FROM EVALUATE-SURROGATE-TERM DIRECTVALUE))
     (CL:SETQ INTENSIONALSKOLEM
      (CREATE-SKOLEM
       (CL:IF (CL:NOT (CL:EQ DIRECTVALUE NULL))
        (LOGICAL-TYPE (VALUE-OF DIRECTVALUE)) NULL)
       NULL))
     (CL:SETF (%SURROGATE-VALUE SELF) INTENSIONALSKOLEM)
     (BIND-SKOLEM-TO-VALUE INTENSIONALSKOLEM DIRECTVALUE FALSE)
     INTENSIONALSKOLEM))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" *EVALUATIONMODE*
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (EVALUATE-LOGIC-OBJECT-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-LOGIC-OBJECT-TERM (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:WHEN (CL:NOT (DESCRIPTION-MODE?))
       (CL:RETURN-FROM EVALUATE-LOGIC-OBJECT-TERM SELF))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:WHEN (DESCRIPTION-MODE?)
       (CL:LET* ((NAME (%SURROGATE-VALUE-INVERSE SELF)))
        (CL:WHEN (CL:NOT (CL:EQ NAME NULL))
         (CL:RETURN-FROM EVALUATE-LOGIC-OBJECT-TERM NAME))))
      (CL:RETURN-FROM EVALUATE-LOGIC-OBJECT-TERM SELF)))
    (CL:T
     (CL:IF (DESCRIPTION-MODE?)
      (CL:LET* ((NAME (%SURROGATE-VALUE-INVERSE SELF)))
       (CL:WHEN (CL:NOT (CL:EQ NAME NULL))
        (CL:RETURN-FROM EVALUATE-LOGIC-OBJECT-TERM NAME)))
      (CL:RETURN-FROM EVALUATE-LOGIC-OBJECT-TERM SELF)))))
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (CL:LET* ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
     "ERROR: Illegal LOGIC-OBJECT term: `" SELF "'." EOL)
    (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
   (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))

;;; (DEFCONSTANT ANONYMOUS-VARIABLE-NAME ...)

(CL:DEFVAR ANONYMOUS-VARIABLE-NAME NULL
  "Variables with name 'ANONYMOUS-VARIABLE-NAME' are considered
anonymous, and are not assumed to be identical to any other variable also named
'ANONYMOUS-VARIABLE-NAME'.")

;;; (DEFUN (ANONYMOUS-VARIABLE? BOOLEAN) ...)

(CL:DEFUN ANONYMOUS-VARIABLE? (SELF)
  (CL:AND (CL:EQ (%SKOLEM-NAME SELF) ANONYMOUS-VARIABLE-NAME)
   (VARIABLE? SELF)))

;;; (DEFUN (EVALUATE-SYMBOL-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-SYMBOL-TERM (SELF)
  (CL:LET* ((VALUE (LOOKUP-LOGIC-VARIABLE-BINDING SELF)))
   (CL:COND ((CL:NOT (CL:EQ VALUE NULL)) VALUE)
    ((CL:EQ SELF ANONYMOUS-VARIABLE-NAME)
     (CREATE-VARIABLE NULL ANONYMOUS-VARIABLE-NAME FALSE))
    ((QUESTION-MARK-SYMBOL? SELF)
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
        "ERROR: Reference to undeclared variable: `" SELF "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
      (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
    ((AUTOMATIC-INSTANCE-SYMBOL? SELF) (EVALUATE-AUTOMATIC-INSTANCE SELF))
    (CL:T (CL:SETQ VALUE (%SURROGATE-VALUE (SYMBOL-TO-SURROGATE SELF)))
     (CL:IF (CL:NOT (CL:EQ VALUE NULL)) VALUE
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
         "ERROR: Reference to undeclared symbol: `" SELF "'." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-PROPOSITIONS-ERROR))
       (CL:ERROR
        (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001)))))))))

;;; (DEFGLOBAL *MISSING-KEY-VALUE-LIST* ...)

(CL:DEFVAR *MISSING-KEY-VALUE-LIST* NULL
  "Represents a key-value list that should never be used.")

;;; (DEFSPECIAL *AUTOMATICINSTANCETABLE* ...)

(CL:DEFVAR *AUTOMATICINSTANCETABLE* NULL
  "Used by 'evaluate-automatic-instance' to
record current bindings of automatic instance symbols.")

;;; (DEFUN (EVALUATE-AUTOMATIC-INSTANCE OBJECT) ...)

(CL:DEFUN EVALUATE-AUTOMATIC-INSTANCE (NAME)
  (CL:WHEN (CL:EQ *AUTOMATICINSTANCETABLE* *MISSING-KEY-VALUE-LIST*)
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "ERROR: Automatic instance `" NAME "' found outside" EOL
      "   the scope of an assertion.." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:LET*
   ((INSTANCE
     (CL:IF (CL:NOT (CL:EQ *AUTOMATICINSTANCETABLE* NULL))
      (LOOKUP *AUTOMATICINSTANCETABLE* NAME) NULL)))
   (CL:WHEN (CL:EQ INSTANCE NULL)
    (CL:LET*
     ((SURROGATE
       (STRING-TO-SURROGATE
        (%SYMBOL-NAME
         (GENSYM (SUBSEQUENCE (%SYMBOL-NAME NAME) 1 NULL-INTEGER))))))
     (CL:SETQ INSTANCE (CREATE-LOGIC-INSTANCE SURROGATE NULL))
     (CL:WHEN (CL:EQ *AUTOMATICINSTANCETABLE* NULL)
      (CL:SETQ *AUTOMATICINSTANCETABLE* (NEW-KEY-VALUE-LIST)))
     (INSERT-AT *AUTOMATICINSTANCETABLE* NAME INSTANCE)))
   INSTANCE))

;;; (DEFUN SIGNAL-UNDEFINED-TERM ...)

(CL:DEFUN SIGNAL-UNDEFINED-TERM (TERM)
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (CL:LET* ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
     "ERROR: Reference to undefined term: `" TERM "'." EOL)
    (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
   (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))

;;; (DEFUN SIGNAL-UNTYPED-TERM ...)

(CL:DEFUN SIGNAL-UNTYPED-TERM (TERM)
  (CL:WHEN (CL:NOT *SUPPRESSUNTYPEDTYPEERROR?*)
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "ERROR: Need a type for the untyped term: `" TERM "'." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))))

;;; (DEFUN (EVALUATE-CREATE-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-CREATE-TERM (TERM)
  (CL:LET*
   ((NAMESYMBOL (%%VALUE (%%REST TERM)))
    (NAME
     (CL:IF (CL:NOT (CL:EQ NAMESYMBOL NULL))
      (SYMBOL-TO-SURROGATE NAMESYMBOL) NULL))
    (TYPESYMBOL (%%VALUE (%%REST (%%REST TERM))))
    (TYPE
     (CL:IF (CL:NOT (CL:EQ TYPESYMBOL NULL))
      (SYMBOL-TO-SURROGATE TYPESYMBOL) NULL))
    (TERM NULL))
   (CL:HANDLER-CASE (CL:SETQ TERM (CREATE-LOGIC-INSTANCE NAME TYPE))
    (LOGIC-EXCEPTION (E)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
      (EXCEPTION-MESSAGE E))))
   TERM))

;;; (DEFUN (CREATE OBJECT) ...)

(CL:DEFUN %CREATE (NAME TYPE)
  "Create a logic object with name 'name' and return it.
If `type' is also supplied, assert that the object belongs to that type."
  (CL:LET*
   ((CREATETREE
     (LIST* SYM-PROPOSITIONS-LOGIC-CREATE NAME (CONCATENATE TYPE NIL)))
    (RESULT (EVALUATE-CREATE-TERM CREATETREE)))
   RESULT))

(CL:DEFUN CREATE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%CREATE (%%VALUE ARGUMENTS) (%%REST ARGUMENTS)))

(CL:DEFMACRO CREATE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Create a logic object with name 'name' and return it.
If `type' is also supplied, assert that the object belongs to that type."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/CREATE)) (CL:MACRO-FUNCTION (CL:QUOTE CREATE)))

;;; (DEFUN UPDATE-SKOLEM-TYPE ...)

(CL:DEFUN UPDATE-SKOLEM-TYPE (SELF TYPE)
  (CL:LET* ((OLDTYPE (%ROOT-TYPE SELF)))
   (CL:WHEN
    (CL:OR (CL:EQ OLDTYPE NULL) (LOGICAL-SUBTYPE-OF? TYPE OLDTYPE))
    (CL:SETF (%ROOT-TYPE SELF) TYPE))))

;;; (DEFUN UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS ...)

(CL:DEFUN UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS (SELF)
  (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-ISA)
     (CL:LET*
      ((OBJECT
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
         0)))
      (CL:WHEN (ISA? OBJECT SGT-PROPOSITIONS-LOGIC-SKOLEM)
       (UPDATE-SKOLEM-TYPE OBJECT (%OPERATOR SELF)))))
    ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-AND)
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:PROGN
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
       (UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS ARG))))
    (CL:T))))

;;; (DEFUN (DESCRIPTION-EXTENSION< BOOLEAN) ...)

(CL:DEFUN DESCRIPTION-EXTENSION< (DESC1 DESC2)
  (< (ESTIMATED-LENGTH (DESCRIPTION-EXTENSION DESC1))
   (ESTIMATED-LENGTH (DESCRIPTION-EXTENSION DESC2))))

;;; (DEFUN PRINT-EXTENSION-SIZES ...)

(CL:DEFUN PRINT-EXTENSION-SIZES (MODULE SIZECUTOFF)
  "Print the extension sizes of concepts visible in `module'.
If `module' is NULL the current module is used.  Do not report extensions
with size less than `sizeCutoff' (default is 10)."
  (CL:DECLARE (CL:TYPE CL:FIXNUM SIZECUTOFF))
  (CL:WHEN (NULL? SIZECUTOFF) (CL:SETQ SIZECUTOFF 10))
  (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE *MODULE*))
  (CL:LET* ((DESCRIPTIONS (NEW-LIST)) (SIZE STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SIZE))
   (CL:LET*
    ((D NULL) (ITER-000 (ALL-NAMED-DESCRIPTIONS MODULE FALSE))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ D (%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ (%EXTENSION D) NULL))
       (CL:>= (ESTIMATED-LENGTH (%EXTENSION D)) SIZECUTOFF))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS D NIL))
        (CL:IF (CL:EQ (%THE-CONS-LIST DESCRIPTIONS) NIL)
         (CL:SETF (%THE-CONS-LIST DESCRIPTIONS) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST DESCRIPTIONS)
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS D NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (SORT DESCRIPTIONS (CL:FUNCTION DESCRIPTION-EXTENSION<))
   (CL:LET*
    ((DESC NULL) (ITER-001 (%THE-CONS-LIST (REVERSE DESCRIPTIONS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ DESC (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (CL:SETQ SIZE
      (INTEGER-TO-STRING (ESTIMATED-LENGTH (%EXTENSION DESC))))
     (CL:SETQ SIZE
      (CONCATENATE
       (MAKE-STRING (CL:- 8 (CL:THE CL:FIXNUM (CL:LENGTH SIZE))) #\ )
       SIZE))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) SIZE " : "
      (DESCRIPTION-NAME DESC) EOL)))))

;;; (DEFUN TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK ...)

(CL:DEFUN TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK (RELATIONSLIST)
  (CL:LET*
   ((OLDRELATION (FIRST RELATIONSLIST))
    (NEWRELATION (SECOND RELATIONSLIST))
    (OLDDESCRIPTION
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OLDRELATION)
      SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL))
    (NEWDESCRIPTION
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWRELATION)
      SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL)))
   (CL:WHEN (CL:NOT (CL:EQ OLDDESCRIPTION NULL))
    (RETRACT-RELATION-AXIOMS OLDDESCRIPTION)
    (CL:IF (CL:NOT (CL:EQ NEWDESCRIPTION NULL))
     (CL:PROGN
      (TRANSFER-PROPOSITIONS-AND-BACKLINKS
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OLDRELATION)
        SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL)
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWRELATION)
        SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL))
      (DESTROY-INSTANCE OLDDESCRIPTION))
     (CL:PROGN
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWRELATION)
       SYM-PROPOSITIONS-LOGIC-DESCRIPTION OLDDESCRIPTION NULL)
      (NATIVE-RELATION-SETTER OLDDESCRIPTION NEWRELATION)
      (FINALIZE-SUPERRELATION-LINKS NEWRELATION)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OLDRELATION)
     SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL NULL))
   (CL:COND
    ((SUBTYPE-OF-CLASS? (SAFE-PRIMARY-TYPE OLDRELATION))
     (CL:PROGN
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWRELATION)
       SYM-PROPOSITIONS-STELLA-CLASS-EXTENSION
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OLDRELATION)
        SYM-PROPOSITIONS-STELLA-CLASS-EXTENSION NULL)
       NULL)
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OLDRELATION)
       SYM-PROPOSITIONS-STELLA-CLASS-EXTENSION NULL NULL)))
    (CL:T))))

;;; (DEFUN RETRACT-RELATION-AXIOMS ...)

(CL:DEFUN RETRACT-RELATION-AXIOMS (OLDRELATION)
  (CL:LET*
   ((ORIGINATEDPROPOSITIONS
     (DECLARATION-ORIGINATED-PROPOSITIONS OLDRELATION)))
   (CL:WHEN (CL:NOT (CL:EQ ORIGINATEDPROPOSITIONS NULL))
    (CL:LET*
     ((PROPOSITION NULL)
      (ITER-000 (%THE-CONS-LIST ORIGINATEDPROPOSITIONS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:PROGN (CL:SETQ PROPOSITION (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (UNASSERT-FACT PROPOSITION))))))

;;; (DEFUN (ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION PROPOSITION) ...)

(CL:DEFUN ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION (SUB SUPER DONTUPDATE?)
  (CL:LET* ((IMPLIESPROP (CREATE-IMPLIES-PROPOSITION SUB SUPER)))
   (CL:SETQ IMPLIESPROP (FASTEN-DOWN-ONE-PROPOSITION IMPLIESPROP FALSE))
   (CL:WHEN (CL:NOT DONTUPDATE?)
    (UPDATE-PROPOSITION-TRUTH-VALUE IMPLIESPROP
     KWD-PROPOSITIONS-ASSERT-TRUE))
   IMPLIESPROP))

;;; (DEFUN (ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS PROPOSITION) ...)

(CL:DEFUN ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS (SUB SUPER)
  (CL:LET*
   ((IMPLIESPROP (ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION SUB SUPER TRUE)))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS IMPLIESPROP)
    SYM-PROPOSITIONS-LOGIC-SUBRELATION-LINK?
    (CL:IF TRUE TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
   (UPDATE-PROPOSITION-TRUTH-VALUE IMPLIESPROP
    KWD-PROPOSITIONS-ASSERT-TRUE)
   (LINK-RELATION-ORIGINATED-PROPOSITION SUB IMPLIESPROP) IMPLIESPROP))

;;; (DEFUN FINALIZE-SUPERRELATION-LINKS ...)

(CL:DEFUN FINALIZE-SUPERRELATION-LINKS (SELF)
  (CL:LET* ((SUBDESCRIPTION (GET-DESCRIPTION SELF)))
   (CL:LET*
    ((*EVALUATIONMODE* KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION)
     (*FILLINGCONSTRAINTPROPAGATIONQUEUES?* FALSE))
    (CL:DECLARE
     (CL:SPECIAL *EVALUATIONMODE* *FILLINGCONSTRAINTPROPAGATIONQUEUES?*))
    (CL:LET*
     ((*MODULE* (%HOME-CONTEXT SUBDESCRIPTION)) (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CL:LET* ((SUPER NULL) (ITER-000 (DIRECT-SUPERRELATIONS SELF)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ SUPER (%VALUE ITER-000))
       (CL:WHEN
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SUPER)
           SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL)
          NULL))
        (ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS SUBDESCRIPTION
         (GET-DESCRIPTION SUPER)))))))))

;;; (DEFUN (UPDATE-ISA-PROPOSITION PROPOSITION) ...)

(CL:DEFUN UPDATE-ISA-PROPOSITION (SELF TYPE UPDATEMODE)
  (CL:LET* ((VALUE-000 NULL))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALLOCATE-ITERATOR (UNFILTERED-DEPENDENT-ISA-PROPOSITIONS SELF))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%OPERATOR P) TYPE) (CL:SETQ VALUE-000 P)
      (CL:RETURN))))
   (CL:LET* ((ISAPROPOSITION VALUE-000))
    (CL:WHEN (CL:EQ ISAPROPOSITION NULL)
     (CL:SETQ ISAPROPOSITION
      (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-ISA 1))
     (CL:SETF (%OPERATOR ISAPROPOSITION) TYPE)
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS ISAPROPOSITION))) (VALUE SELF)
       (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (FASTEN-DOWN-ONE-PROPOSITION ISAPROPOSITION TRUE))
    (UPDATE-PROPOSITION-TRUTH-VALUE ISAPROPOSITION UPDATEMODE)
    ISAPROPOSITION)))

;;; (DEFUN (ASSERT-ISA-PROPOSITION PROPOSITION) ...)

(CL:DEFUN ASSERT-ISA-PROPOSITION (SELF TYPE)
  (CL:IF (CL:NOT (CL:EQ TYPE NULL))
   (UPDATE-ISA-PROPOSITION SELF TYPE KWD-PROPOSITIONS-ASSERT-TRUE) NULL))

;;; (DEFUN (UPDATE-PROPERTY PROPOSITION) ...)

(CL:DEFUN UPDATE-PROPERTY (SELF SURROGATE UPDATEMODE)
  (CL:LET* ((VALUE-000 NULL))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALLOCATE-ITERATOR
       (UNFILTERED-DEPENDENT-PROPOSITIONS SELF SURROGATE))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:EQ (%OPERATOR P) SURROGATE)
       (CL:= (LENGTH (%ARGUMENTS P)) 1))
      (CL:SETQ VALUE-000 P) (CL:RETURN))))
   (CL:LET* ((PROPERTYPROPOSITION VALUE-000))
    (CL:WHEN
     (CL:OR (CL:EQ SURROGATE NULL)
      (CL:EQ (%SURROGATE-VALUE SURROGATE) NULL))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Error: Property "
      SURROGATE " is not defined." EOL)
     (CL:RETURN-FROM UPDATE-PROPERTY NULL))
    (CL:WHEN (CL:EQ PROPERTYPROPOSITION NULL)
     (CL:SETQ PROPERTYPROPOSITION
      (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-PREDICATE 1))
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS PROPERTYPROPOSITION))) (VALUE SELF)
       (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETF (%OPERATOR PROPERTYPROPOSITION) SURROGATE)
     (FASTEN-DOWN-ONE-PROPOSITION PROPERTYPROPOSITION TRUE))
    (UPDATE-PROPOSITION-TRUTH-VALUE PROPERTYPROPOSITION UPDATEMODE)
    PROPERTYPROPOSITION)))

;;; (DEFUN (ASSERT-PROPERTY PROPOSITION) ...)

(CL:DEFUN ASSERT-PROPERTY (INSTANCE PROPERTY)
  (UPDATE-PROPERTY INSTANCE PROPERTY KWD-PROPOSITIONS-ASSERT-TRUE))

;;; (DEFUN (UPDATE-TUPLE PROPOSITION) ...)

(CL:DEFUN UPDATE-TUPLE (RELATION ARGUMENTS UPDATEMODE)
  (CL:LET* ((DESCRIPTION (GET-DESCRIPTION RELATION)) (PROPOSITION NULL))
   (CL:COND
    ((FUNCTION-DESCRIPTION? DESCRIPTION)
     (CL:LET*
      ((DEFININGPROPOSITION
        (FIND-OR-CREATE-FUNCTION-PROPOSITION RELATION
         (CONSIFY (BUT-LAST ARGUMENTS)))))
      (CL:SETQ PROPOSITION
       (UPDATE-EQUIVALENCE-PROPOSITION
        (CREATE-EQUIVALENCE-PROPOSITION
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY (%ARGUMENTS DEFININGPROPOSITION)))
          (CL:THE CL:FIXNUM
           (CL:1- (LENGTH (%ARGUMENTS DEFININGPROPOSITION)))))
         (LAST ARGUMENTS))
        UPDATEMODE))
      (CL:WHEN (CL:EQ PROPOSITION NULL)
       (CL:RETURN-FROM UPDATE-TUPLE DEFININGPROPOSITION))))
    ((CLASS-DESCRIPTION? DESCRIPTION)
     (CL:RETURN-FROM UPDATE-TUPLE
      (UPDATE-ISA-PROPOSITION (%%VALUE ARGUMENTS) RELATION UPDATEMODE)))
    (CL:T
     (CL:SETQ PROPOSITION
      (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-PREDICATE
       (LENGTH ARGUMENTS)))
     (CL:SETF (%OPERATOR PROPOSITION) RELATION)
     (CL:LET*
      ((I NULL-INTEGER) (ARG NULL) (ITER-000 ARGUMENTS) (ITER-001 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
       (CL:LET
        ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION))) (VALUE ARG)
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))))))
   (CL:SETQ PROPOSITION (FASTEN-DOWN-ONE-PROPOSITION PROPOSITION FALSE))
   (UPDATE-PROPOSITION-TRUTH-VALUE PROPOSITION UPDATEMODE) PROPOSITION))

;;; (DEFUN (ASSERT-TUPLE PROPOSITION) ...)

(CL:DEFUN ASSERT-TUPLE (RELATION ARGUMENTS)
  (UPDATE-TUPLE RELATION ARGUMENTS KWD-PROPOSITIONS-ASSERT-TRUE))

;;; (DEFUN (UPDATE-BINARY-VALUE PROPOSITION) ...)

(CL:DEFUN UPDATE-BINARY-VALUE (RELATION SELF VALUE UPDATEMODE)
  (CL:LET* ((*CLIPPINGENABLED?* TRUE))
   (CL:DECLARE (CL:SPECIAL *CLIPPINGENABLED?*))
   (CL:IF (FUNCTION-DESCRIPTION? (GET-DESCRIPTION RELATION))
    (CL:LET* ((VALUE-000 NULL))
     (CL:LET*
      ((P NULL)
       (ITER-000
        (ALLOCATE-ITERATOR
         (UNFILTERED-DEPENDENT-PROPOSITIONS SELF RELATION))))
      (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
       (CL:WHEN (CL:EQ (%OPERATOR P) RELATION) (CL:SETQ VALUE-000 P)
        (CL:RETURN))))
     (CL:LET* ((PROPOSITION VALUE-000))
      (CL:WHEN (CL:OR (CL:EQ PROPOSITION NULL) (SKOLEM? VALUE))
       (CL:RETURN-FROM UPDATE-BINARY-VALUE
        (UPDATE-TUPLE RELATION (CONS-LIST SELF VALUE) UPDATEMODE)))
      (CL:LET*
       ((SKOLEMOUTPUT
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS PROPOSITION)))))))
       (CL:COND
        ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
         (CL:COND ((CLIP-VALUE? SKOLEMOUTPUT VALUE))
          (CL:T
           (EQUATE-VALUES (VALUE-OF SKOLEMOUTPUT) (VALUE-OF VALUE)))))
        ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
         (UNEQUATE-VALUES? SKOLEMOUTPUT VALUE))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" UPDATEMODE
           "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
       PROPOSITION)))
    (UPDATE-TUPLE RELATION (CONS-LIST SELF VALUE) UPDATEMODE))))

;;; (DEFUN (ASSERT-BINARY-VALUE PROPOSITION) ...)

(CL:DEFUN ASSERT-BINARY-VALUE (RELATION SELF VALUE)
  (UPDATE-BINARY-VALUE RELATION SELF VALUE KWD-PROPOSITIONS-ASSERT-TRUE))

;;; (DEFUN (RETRACT-BINARY-VALUE PROPOSITION) ...)

(CL:DEFUN RETRACT-BINARY-VALUE (RELATION SELF VALUE)
  (UPDATE-BINARY-VALUE RELATION SELF VALUE KWD-PROPOSITIONS-RETRACT-TRUE))

;;; (DEFUN (ASSERT-MEMBER-OF-PROPOSITION PROPOSITION) ...)

(CL:DEFUN ASSERT-MEMBER-OF-PROPOSITION (SELF COLLECTION)
  (CL:WHEN (CL:EQ COLLECTION NULL)
   (CL:RETURN-FROM ASSERT-MEMBER-OF-PROPOSITION NULL))
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE COLLECTION)
     SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
    (CL:PROGN
     (CL:WHEN
      (CL:EQ (%SURROGATE-VALUE-INVERSE COLLECTION)
       SGT-PROPOSITIONS-STELLA-THING)
      (CL:RETURN-FROM ASSERT-MEMBER-OF-PROPOSITION NULL))
     (ASSERT-ISA-PROPOSITION SELF (%SURROGATE-VALUE-INVERSE COLLECTION))))
   (CL:T
    (ASSERT-TUPLE SGT-PROPOSITIONS-PL-KERNEL-KB-MEMBER-OF
     (CONS-LIST SELF COLLECTION)))))

;;; (DEFSPECIAL *DEFAULTCREATIONTYPE* ...)

(CL:DEFVAR *DEFAULTCREATIONTYPE* NULL)

;;; (DEFUN (CREATE-LOGIC-INSTANCE OBJECT) ...)

(CL:DEFUN CREATE-LOGIC-INSTANCE (NAME TYPE)
  (ENFORCE-CODE-ONLY)
  (CL:WHEN (CL:EQ TYPE NULL) (CL:SETQ TYPE *DEFAULTCREATIONTYPE*))
  (CL:LET*
   ((DESCRIPTION
     (CL:IF (CL:NOT (CL:EQ TYPE NULL)) (GET-DESCRIPTION TYPE) NULL))
    (NATIVECLASS NULL) (NEWOBJECT NULL))
   (CL:WHEN (CL:AND (CL:NOT (CL:EQ TYPE NULL)) (CL:EQ DESCRIPTION NULL))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "Can't create an instance of the undefined class `"
     (%SYMBOL-NAME TYPE) "'" EOL EOL)
    (CL:RETURN-FROM CREATE-LOGIC-INSTANCE NULL))
   (CL:IF (CL:EQ DESCRIPTION NULL) (CL:SETQ NEWOBJECT (NEW-LOGIC-OBJECT))
    (CL:PROGN
     (CL:WHEN (CL:NOT (CLASS-DESCRIPTION? DESCRIPTION))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "Can't create an instance of a relation: `" (%SYMBOL-NAME TYPE) "'"
       EOL)
      (CL:RETURN-FROM CREATE-LOGIC-INSTANCE NULL))
     (CL:SETQ NATIVECLASS (NATIVE-RELATION DESCRIPTION))
     (CL:COND
      ((CL:OR (CL:EQ NATIVECLASS NULL) (%ABSTRACT? NATIVECLASS))
       (CL:SETQ NEWOBJECT (NEW-LOGIC-OBJECT)))
      ((SUBTYPE-OF? (%CLASS-TYPE NATIVECLASS)
        SGT-PROPOSITIONS-STELLA-THING)
       (CL:SETQ NEWOBJECT (CREATE-OBJECT TYPE)))
      (CL:T
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
        "Can't create an instance of the class `" (%SYMBOL-NAME TYPE) "'"
        EOL "   because it doesn't inherit the class 'THING'." EOL)
       (CL:RETURN-FROM CREATE-LOGIC-INSTANCE NULL)))))
   (CL:WHEN (CL:NOT (CL:EQ NAME NULL))
    (CL:WHEN (CL:NOT (CL:EQ (%SURROGATE-VALUE NAME) NULL))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "Redefining the surrogate " (%SYMBOL-NAME NAME)
      " will cause the existing" EOL "   object named "
      (%SYMBOL-NAME NAME) " to be destroyed. ")
     (CL:WHEN (CL:NOT (Y-OR-N? "Do it? "))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "Returning existing object:" EOL)
      (CL:RETURN-FROM CREATE-LOGIC-INSTANCE (%SURROGATE-VALUE NAME)))
     (DESTROY-INSTANCE (%SURROGATE-VALUE NAME)))
    (CL:SETF (%SURROGATE-VALUE NAME) NEWOBJECT)
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NEWOBJECT)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
       (CL:PROGN (CL:SETF (%SURROGATE-VALUE-INVERSE NEWOBJECT) NAME)))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-THING)
       (CL:PROGN (CL:SETF (%SURROGATE-VALUE-INVERSE NEWOBJECT) NAME)))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
   NEWOBJECT))

;;; (DEFGLOBAL *STRINGIFIED-PROPOSITION-INDEX* ...)

(CL:DEFVAR *STRINGIFIED-PROPOSITION-INDEX* NULL
  "Contains a table of propositions, indexed by their
stringifications.  Tricky: Propositions in two
different modules could have the same stringification but be different.")

;;; (DEFUN (FIND-EXACT-DUPLICATE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FIND-EXACT-DUPLICATE-PROPOSITION (SELF)
  (CL:LET*
   ((STRINGIFICATION (STRINGIFY SELF))
    (BUCKET (LOOKUP *STRINGIFIED-PROPOSITION-INDEX* STRINGIFICATION)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFICATION))
   (CL:WHEN (CL:EQ BUCKET NULL)
    (INSERT-AT *STRINGIFIED-PROPOSITION-INDEX* STRINGIFICATION
     (LIST SELF))
    (CL:RETURN-FROM FIND-EXACT-DUPLICATE-PROPOSITION NULL))
   (REMOVE-IF BUCKET (CL:FUNCTION DELETED-PROPOSITION?))
   (CL:LET* ((P NULL) (ITER-000 (%THE-CONS-LIST BUCKET)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ P (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:LET* ((MAPPING (NEW-KEY-VALUE-LIST)))
      (CL:LET*
       ((V2 NULL) (V1 NULL)
        (VECTOR-000
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
          SYM-PROPOSITIONS-LOGIC-IO-VARIABLES NULL))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
        (VECTOR-001
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS P)
          SYM-PROPOSITIONS-LOGIC-IO-VARIABLES NULL))
        (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
        DO
        (CL:PROGN
         (CL:SETQ V1
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
        (CL:PROGN
         (CL:SETQ V2
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
           INDEX-001))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
        (INSERT-AT MAPPING V1 V2)))
      (CL:WHEN
       (CL:AND (EQUIVALENT-PROPOSITIONS? SELF P MAPPING)
        (CL:OR (CL:EQ (%HOME-CONTEXT SELF) (%HOME-CONTEXT P))
         (MEMB? (%ALL-SUPER-CONTEXTS (%HOME-CONTEXT SELF))
          (%HOME-CONTEXT P))))
       (CL:RETURN-FROM FIND-EXACT-DUPLICATE-PROPOSITION P)))))
   (PUSH BUCKET SELF) NULL))

;;; (DEFUN (FIND-DUPLICATE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FIND-DUPLICATE-PROPOSITION (SELF)
  (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FORALL)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-EXISTS))
     (CL:WHEN (CL:NOT (DESCRIPTION-MODE?))
      (CL:RETURN-FROM FIND-DUPLICATE-PROPOSITION
       (FIND-EXACT-DUPLICATE-PROPOSITION SELF))))
    (CL:T)))
  (CL:LET* ((VALUE-000 NULL))
   (CL:LET*
    ((P NULL)
     (ITER-000 (ALLOCATE-ITERATOR (FIND-SIMILAR-PROPOSITIONS SELF))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (EQUIVALENT-PROPOSITIONS? SELF P NULL)
       (CL:OR (CL:EQ (%HOME-CONTEXT SELF) (%HOME-CONTEXT P))
        (MEMB? (%ALL-SUPER-CONTEXTS (%HOME-CONTEXT SELF))
         (%HOME-CONTEXT P))))
      (CL:SETQ VALUE-000 P) (CL:RETURN))))
   (CL:LET* ((VALUE-001 VALUE-000)) VALUE-001)))

;;; (DEFUN (FASTEN-DOWN-ONE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FASTEN-DOWN-ONE-PROPOSITION (SELF DONT-CHECK-FOR-DUPLICATES)
  (CL:WHEN (NATIVE-SLOT-PROPOSITION? SELF)
   (CL:RETURN-FROM FASTEN-DOWN-ONE-PROPOSITION SELF))
  (SURROGATIFY-DISCOURAGED-ARGUMENTS SELF)
  (CL:LET* ((DUPLICATE NULL))
   (CL:WHEN (CL:NOT DONT-CHECK-FOR-DUPLICATES)
    (CL:SETQ DUPLICATE (FIND-DUPLICATE-PROPOSITION SELF)))
   (CL:IF (CL:NOT (CL:EQ DUPLICATE NULL)) DUPLICATE
    (CL:PROGN
     (CL:WHEN
      (CL:NOT
       (CL:OR
        (%WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
          SYM-PROPOSITIONS-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
        (DESCRIPTION-MODE?)))
      (CL:WHEN *LOADINGREGENERABLEOBJECTS?*
       (LOG-TO-SECONDARY-STORAGE-MANAGER SELF))
      (CL:WHEN (CL:NOT *LOADINGREGENERABLEOBJECTS?*)
       (LOG-NEWLY-CONCEIVED-PROPOSITION *MODULE* SELF)))
     (REWRAP-PROPOSITION-ARGUMENTS SELF)
     (CL:WHEN (CL:NOT *LOADINGREGENERABLEOBJECTS?*)
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:PROGN
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
        (ADD-DEPENDENT-PROPOSITION-LINK ARG SELF))))
     (UPDATE-DESCRIPTION-EXTENSION SELF)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPOSITIONS-LOGIC-UNFASTENED? NULL NULL)
     (EVALUATE-NEW-PROPOSITION SELF) SELF))))

;;; (DEFSPECIAL *VISITEDUNFASTENEDDEFININGPROPOSITIONS* ...)

(CL:DEFVAR *VISITEDUNFASTENEDDEFININGPROPOSITIONS* NULL
  "Used by 'recursively-fasten-down-propositions'.")

;;; (DEFUN (HELP-FASTEN-DOWN-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN HELP-FASTEN-DOWN-PROPOSITIONS (SELF DONT-CHECK-FOR-DUPLICATES)
  (CL:LET*
   ((I NULL-INTEGER) (ARG NULL) (VECTOR-000 (%ARGUMENTS SELF))
    (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (ITER-000 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-000 I))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:PROGN
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
    (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
       (CL:PROGN
        (CL:WHEN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (UNFASTENED? ARG))
         (CL:LET
          ((SELF (%THE-ARRAY (%ARGUMENTS SELF)))
           (VALUE
            (HELP-FASTEN-DOWN-PROPOSITIONS ARG DONT-CHECK-FOR-DUPLICATES))
           (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE)))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
       (CL:PROGN
        (CL:LET* ((DEFININGPROP (%DEFINING-PROPOSITION ARG)))
         (CL:WHEN
          (CL:AND (CL:NOT (CL:EQ DEFININGPROP NULL))
           (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (UNFASTENED? DEFININGPROP))
           (CL:NOT
            (MEMBER? *VISITEDUNFASTENEDDEFININGPROPOSITIONS*
             DEFININGPROP)))
          (INSERT *VISITEDUNFASTENEDDEFININGPROPOSITIONS* DEFININGPROP)
          (HELP-FASTEN-DOWN-PROPOSITIONS DEFININGPROP
           DONT-CHECK-FOR-DUPLICATES)))))
      (CL:T)))))
  (FASTEN-DOWN-ONE-PROPOSITION SELF DONT-CHECK-FOR-DUPLICATES))

;;; (DEFUN (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN RECURSIVELY-FASTEN-DOWN-PROPOSITIONS (SELF DONT-CHECK-FOR-DUPLICATES)
  (CL:WHEN (CL:NOT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (UNFASTENED? SELF)))
   (CL:RETURN-FROM RECURSIVELY-FASTEN-DOWN-PROPOSITIONS SELF))
  (CL:LET* ((*VISITEDUNFASTENEDDEFININGPROPOSITIONS* (LIST)))
   (CL:DECLARE (CL:SPECIAL *VISITEDUNFASTENEDDEFININGPROPOSITIONS*))
   (HELP-FASTEN-DOWN-PROPOSITIONS SELF DONT-CHECK-FOR-DUPLICATES)))

;;; (DEFUN UNFASTEN-PROPOSITION ...)

(CL:DEFUN UNFASTEN-PROPOSITION (PROPOSITION)
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:PROGN
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
    (REMOVE-DEPENDENT-PROPOSITION-LINK ARG PROPOSITION)))
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
   SYM-PROPOSITIONS-LOGIC-UNFASTENED? TRUE-WRAPPER NULL))

;;; (DEFUN INSTANTIATE-UNDEFINED-SURROGATES ...)

(CL:DEFUN INSTANTIATE-UNDEFINED-SURROGATES (SELF)
  (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-AND)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-OR)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-NOT)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-EXISTS))
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:PROGN
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
       (INSTANTIATE-UNDEFINED-SURROGATES ARG))))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-ISA))
     (CL:LET*
      ((ARG NULL) (VECTOR-001 (%ARGUMENTS SELF)) (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:PROGN
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (CL:COND
        ((SUBTYPE-OF-SURROGATE? (SAFE-PRIMARY-TYPE ARG))
         (CL:PROGN
          (CL:WHEN (CL:EQ (%SURROGATE-VALUE ARG) NULL)
           (CL:SETF (%SURROGATE-VALUE ARG)
            (CREATE-LOGIC-INSTANCE ARG NULL)))))
        (CL:T)))))
    (CL:T))))

;;; (DEFUN (BUILD-TOP-LEVEL-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-TOP-LEVEL-PROPOSITION (TREE TRUEASSERTION?)
  (CL:WHEN (ISA? TREE SGT-PROPOSITIONS-STELLA-STRING-WRAPPER)
   (CL:RETURN-FROM BUILD-TOP-LEVEL-PROPOSITION
    (BUILD-TOP-LEVEL-PROPOSITION
     (READ-S-EXPRESSION-FROM-STRING (%WRAPPER-VALUE TREE))
     TRUEASSERTION?)))
  (CL:LET* ((PROPOSITION NULL) (LOGICVARIABLETABLE *LOGICVARIABLETABLE*))
   (CL:LET*
    ((*LOGICVARIABLETABLE*
      (CL:IF (CL:NOT (CL:EQ LOGICVARIABLETABLE NULL)) LOGICVARIABLETABLE
       NIL))
     (*VARIABLEIDCOUNTER* *VARIABLEIDCOUNTER*)
     (*TERMUNDERCONSTRUCTION* TREE))
    (CL:DECLARE
     (CL:SPECIAL *LOGICVARIABLETABLE* *VARIABLEIDCOUNTER*
      *TERMUNDERCONSTRUCTION*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *VARIABLEIDCOUNTER*))
    (CL:SETQ PROPOSITION (BUILD-PROPOSITION TREE))
    (CL:WHEN (CL:NOT (CL:EQ PROPOSITION NULL))
     (NORMALIZE-PROPOSITION PROPOSITION)
     (CL:WHEN
      (CL:NOT
       (CL:EQ (COLLECT-UNRESOLVED-SLOT-REFERENCES PROPOSITION) NIL))
      (CL:WHEN TRUEASSERTION?
       (UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS PROPOSITION))
      (RESOLVE-UNRESOLVED-SLOT-REFERENCES PROPOSITION))
     (CL:WHEN
      (CL:AND TRUEASSERTION?
       (CL:EQ (%KIND PROPOSITION) KWD-PROPOSITIONS-EXISTS)
       (CL:NOT (DESCRIPTION-MODE?)))
      (INSTANTIATE-UNDEFINED-SURROGATES PROPOSITION))
     (CL:SETQ PROPOSITION
      (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS PROPOSITION FALSE))))
   PROPOSITION))

;;; (DEFUN (BUILD-PROPOSITION OBJECT) ...)

(CL:DEFUN BUILD-PROPOSITION (TREE)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-CONS)
     (CL:PROGN (CONS.BUILD-PROPOSITION TREE)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (SURROGATE.BUILD-PROPOSITION TREE)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN (SYMBOL.BUILD-PROPOSITION TREE)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
        "ERROR: Illegal logical sentence: `" TREE "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
      (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (SURROGATE.BUILD-PROPOSITION PROPOSITION) ...)

(CL:DEFUN SURROGATE.BUILD-PROPOSITION (SELF)
  (CL:LET* ((VALUE (%SURROGATE-VALUE SELF)) (PROPOSITION NULL))
   (CL:IF (CL:NOT (CL:EQ VALUE NULL))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE VALUE)
       SGT-PROPOSITIONS-LOGIC-PROPOSITION)
      (CL:PROGN (CL:SETQ PROPOSITION VALUE)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "ERROR: Expected `"
         (%SYMBOL-NAME SELF) "' to have type proposition." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
       (CL:ERROR
        (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))))
    (CL:PROGN
     (CL:SETQ PROPOSITION
      (CREATE-PROPOSITION SYM-PROPOSITIONS-LOGIC-CONSTANT 0))
     (CL:SETF (%OPERATOR PROPOSITION) SELF)
     (CL:SETF (%SURROGATE-VALUE SELF) PROPOSITION)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-STELLA-SURROGATE-VALUE-INVERSE SELF NULL)))
   PROPOSITION))

;;; (DEFUN (SYMBOL.BUILD-PROPOSITION OBJECT) ...)

(CL:DEFUN SYMBOL.BUILD-PROPOSITION (SYMBOL)
  (CL:LET* ((PROPOSITION NULL))
   (CL:COND
    ((CL:EQ SYMBOL SYM-PROPOSITIONS-STELLA-TRUE)
     (CL:SETQ PROPOSITION TRUE-PROPOSITION))
    ((CL:EQ SYMBOL SYM-PROPOSITIONS-STELLA-FALSE)
     (CL:SETQ PROPOSITION FALSE-PROPOSITION))
    (CL:T
     (CL:RETURN-FROM SYMBOL.BUILD-PROPOSITION
      (EVALUATE-SYMBOL-TERM SYMBOL))))
   PROPOSITION))

;;; (DEFUN (CONS.BUILD-PROPOSITION PROPOSITION) ...)

(CL:DEFUN CONS.BUILD-PROPOSITION (TREE)
  (CL:LET* ((PROPOSITION NULL))
   (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-=)
      (CL:SETQ PROPOSITION (BUILD-EQUIVALENCE-PROPOSITION TREE)))
     ((CL:OR (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-AND)
       (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-OR)
       (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-NOT))
      (CL:SETQ PROPOSITION (BUILD-AND-OR-NOT-PROPOSITION TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-ISA)
      (CL:SETQ PROPOSITION (BUILD-ISA-PROPOSITION TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-PL-KERNEL-KB-MEMBER-OF)
      (CL:SETQ PROPOSITION (BUILD-MEMBER-OF-PROPOSITION TREE)))
     ((CL:OR (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-IMPLIES)
       (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF))
      (CL:SETQ PROPOSITION (BUILD-IMPLIES-PROPOSITION TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-EXISTS)
      (CL:SETQ PROPOSITION (BUILD-EXISTS-PROPOSITION TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-FORALL)
      (CL:SETQ PROPOSITION (BUILD-FORALL-PROPOSITION TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-FAIL)
      (CL:SETQ PROPOSITION (BUILD-FAIL-PROPOSITION TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-COLLECT-INTO)
      (CL:SETQ PROPOSITION (BUILD-COLLECT-INTO-PROPOSITION TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-ABOUT)
      (CL:SETQ PROPOSITION (BUILD-DECORATED-PROPOSITION TREE)))
     (CL:T (CL:SETQ PROPOSITION (BUILD-PREDICATE-PROPOSITION TREE)))))
   (CL:WHEN (CL:EQ PROPOSITION NULL)
    (CL:RETURN-FROM CONS.BUILD-PROPOSITION NULL))
   (CL:WHEN (CONTAINS-NESTED-ARGUMENT? PROPOSITION)
    (CL:SETQ PROPOSITION (FLATTEN-NESTED-FUNCTION-ARGUMENTS PROPOSITION)))
   PROPOSITION))

;;; (DEFUN VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS ...)

(CL:DEFUN VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS (TREE CORRECTNUMBER)
  (CL:DECLARE (CL:TYPE CL:FIXNUM CORRECTNUMBER))
  (CL:WHEN (CL:NOT (CL:= (LENGTH (%%REST TREE)) CORRECTNUMBER))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "ERROR: Wrong number of arguments in proposition: `" TREE "'" EOL
      "   Expected `" CORRECTNUMBER "' arguments.." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
    (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))))

;;; (DEFMETHOD (DESCRIPTION-SURROGATE TYPE) ...)

(CL:DEFMETHOD DESCRIPTION-SURROGATE ((SELF DESCRIPTION))
  (CL:LET* ((NATIVERELATION (NATIVE-RELATION SELF)))
   (CL:WHEN (CL:NOT (CL:EQ NATIVERELATION NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NATIVERELATION)))
     (CL:COND
      ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
       (CL:PROGN
        (CL:RETURN-FROM DESCRIPTION-SURROGATE
         (CLASS-LOGICAL-TYPE NATIVERELATION))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-SLOT)
       (CL:PROGN
        (CL:RETURN-FROM DESCRIPTION-SURROGATE
         (%SLOT-SLOTREF NATIVERELATION))))
      (CL:T))))
   NULL))

;;; (DEFUN (BUILD-ISA-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-ISA-PROPOSITION (TREE)
  (VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS TREE 2)
  (CL:LET*
   ((PROPOSITION (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-ISA 1))
    (TYPE NULL) (SYMBOL (%%VALUE (%%REST (%%REST TREE)))))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SYMBOL)))
    (CL:COND
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ TYPE SYMBOL)))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ TYPE (SYMBOL-TO-SURROGATE SYMBOL))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
         "ERROR: Illegal token where symbol expected: `" SYMBOL "'." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
       (CL:ERROR
        (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))))
   (CL:LET* ((CLASS (GET-DESCRIPTION TYPE)))
    (CL:WHEN (CL:EQ CLASS NULL)
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
        "ERROR: No class is associated with the term `"
        (%SYMBOL-NAME TYPE) "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-PROPOSITIONS-ERROR))
      (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001)))))
    (CL:WHEN (CL:NOT (CLASS-DESCRIPTION? CLASS))
     (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "ERROR: Term `"
        (%SYMBOL-NAME TYPE) "' found where class expected.." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-002 KWD-PROPOSITIONS-ERROR))
      (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-002))))))
   (CL:SETF (%OPERATOR PROPOSITION) TYPE)
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
     (VALUE (EVALUATE-TYPED-ARGUMENT (%%VALUE (%%REST TREE)) TYPE))
     (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   PROPOSITION))

;;; (DEFUN (BUILD-MEMBER-OF-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-MEMBER-OF-PROPOSITION (TREE)
  (VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS TREE 2)
  (CL:LET* ((COLLECTIONREF (%%VALUE (%%REST (%%REST TREE)))))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE COLLECTIONREF)))
    (CL:COND
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN
       (CL:WHEN
        (CL:NOT (CL:EQ (GET-STELLA-CLASS COLLECTIONREF FALSE) NULL))
        (CL:RETURN-FROM BUILD-MEMBER-OF-PROPOSITION
         (BUILD-ISA-PROPOSITION TREE)))))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN
       (CL:WHEN
        (CL:NOT (CL:EQ (GET-STELLA-CLASS COLLECTIONREF FALSE) NULL))
        (CL:RETURN-FROM BUILD-MEMBER-OF-PROPOSITION
         (BUILD-ISA-PROPOSITION TREE)))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
      (CL:PROGN
       (CL:WHEN
        (CL:AND (NAMED-DESCRIPTION? COLLECTIONREF)
         (CLASS-DESCRIPTION? COLLECTIONREF))
        (CL:RETURN-FROM BUILD-MEMBER-OF-PROPOSITION
         (BUILD-ISA-PROPOSITION
          (LIST* SYM-PROPOSITIONS-STELLA-ISA (%%VALUE (%%REST TREE))
           (CONS (DESCRIPTION-SURROGATE COLLECTIONREF) NIL)))))))
     (CL:T))))
  (BUILD-PREDICATE-PROPOSITION TREE))

;;; (DEFUN (MEMBER-OF-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN MEMBER-OF-PROPOSITION? (PROPOSITION)
  (CL:EQ (%OPERATOR PROPOSITION) SGT-PROPOSITIONS-PL-KERNEL-KB-MEMBER-OF))

;;; (DEFUN (SUBSET-OF-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN SUBSET-OF-PROPOSITION? (PROPOSITION)
  (CL:EQ (%OPERATOR PROPOSITION) SGT-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF))

;;; (DEFUN (EXTRACT-DECORATION OBJECT OBJECT) ...)

(CL:DEFUN EXTRACT-DECORATION (TREE OPTION)
  (CL:LET* ((VALUE NULL))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-PROPOSITIONS-STELLA-CONS)
     (CL:PROGN
      (CL:WHEN (CL:EQ (%%VALUE TREE) SYM-PROPOSITIONS-LOGIC-ABOUT)
       (CL:LET*
        ((OPTIONSANDVALUES (%%REST (%%REST TREE)))
         (FOUNDMATCHINGOPTION? FALSE))
        (CL:LET* ((IT (ALLOCATE-ITERATOR OPTIONSANDVALUES)))
         (CL:LOOP WHILE (NEXT? IT) DO
          (CL:LET* ((PAIR (%VALUE IT)))
           (CL:WHEN (CL:EQ (%%VALUE PAIR) OPTION)
            (CL:SETQ VALUE (%%VALUE (%%REST PAIR))) (VALUE-SETTER IT NULL)
            (CL:SETQ FOUNDMATCHINGOPTION? TRUE) (CL:RETURN)))))
        (CL:WHEN FOUNDMATCHINGOPTION?
         (CL:SETF (%%REST (%%REST TREE)) (REMOVE OPTIONSANDVALUES NULL))
         (CL:WHEN (CL:EQ (%%REST (%%REST TREE)) NIL)
          (CL:RETURN-FROM EXTRACT-DECORATION
           (CL:VALUES (%%VALUE (%%REST TREE)) VALUE))))))))
    (CL:T))
   (CL:VALUES TREE VALUE)))

;;; (DEFUN (BUILD-DECORATED-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-DECORATED-PROPOSITION (TREE)
  (CL:LET*
   ((PROP (BUILD-PROPOSITION (%%VALUE (%%REST TREE))))
    (DECORATIONS (%%REST (%%REST TREE))))
   (CL:LET* ((PAIR NULL) (ITER-000 DECORATIONS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ PAIR (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:COND
      ((CL:EQ (SAFE-PRIMARY-TYPE PAIR) SGT-PROPOSITIONS-STELLA-CONS)
       (CL:PROGN
        (CL:LET* ((OPTION (%%VALUE PAIR)) (VALUE (%%VALUE (%%REST PAIR))))
         (CL:LET* ((TEST-VALUE-000 OPTION))
          (CL:COND
           ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-DIRECTION)
            (CL:LET* ((TEST-VALUE-001 VALUE))
             (CL:COND
              ((CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-LOGIC-FORWARD)
               (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
                SYM-PROPOSITIONS-LOGIC-FORWARD-ONLY?
                (CL:IF TRUE TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
              ((CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-LOGIC-BACKWARD)
               (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
                SYM-PROPOSITIONS-LOGIC-BACKWARD-ONLY?
                (CL:IF TRUE TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER))
              (CL:T
               (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
                (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
                 TEST-VALUE-001 "' is not a valid case option")
                (CL:ERROR
                 (NEW-STELLA-EXCEPTION
                  (THE-STRING-READER STREAM-000))))))))
           ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-WEIGHT)
            (ASSIGN-PROPOSITION-WEIGHT PROP (%WRAPPER-VALUE VALUE)))
           (CL:T
            (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
             "Skipping unrecognized decoration option: " OPTION EOL)))))))
      (CL:T
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
        "Skipping illegal decoration clause: " PAIR EOL)))))
   PROP))

;;; (DEFUN (FUNCTION-INDUCED-EXISTS? BOOLEAN) ...)

(CL:DEFUN FUNCTION-INDUCED-EXISTS? (PROPOSITION)
  (CL:WHEN (CL:EQ (%KIND PROPOSITION) KWD-PROPOSITIONS-EXISTS)
   (CL:LET*
    ((FIRSTARGUMENT
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (CL:WHEN
     (CL:AND (ISA? FIRSTARGUMENT SGT-PROPOSITIONS-LOGIC-PROPOSITION)
      (CL:EQ (%KIND FIRSTARGUMENT) KWD-PROPOSITIONS-AND))
     (CL:LET*
      ((EXISTSVARIABLES
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
         SYM-PROPOSITIONS-LOGIC-IO-VARIABLES NULL))
       (ANDPROP FIRSTARGUMENT) (ANDARGUMENTS (%ARGUMENTS ANDPROP))
       (NONFUNCTIONSCOUNT 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM NONFUNCTIONSCOUNT))
      (CL:LET* ((ALWAYS?-000 TRUE))
       (CL:LET*
        ((VARIABLE NULL) (VECTOR-000 EXISTSVARIABLES) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:PROGN
          (CL:SETQ VARIABLE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
         (CL:LET* ((TEST-VALUE-000 FALSE))
          (CL:LET* ((FOUND?-000 FALSE))
           (CL:LET*
            ((ARG NULL) (VECTOR-001 ANDARGUMENTS) (INDEX-001 0)
             (LENGTH-001 (LENGTH VECTOR-001)))
            (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
            (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
             (CL:PROGN
              (CL:SETQ ARG
               (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
                INDEX-001))
              (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
             (CL:WHEN
              (CL:AND (CL:EQ (%KIND ARG) KWD-PROPOSITIONS-FUNCTION)
               (CL:EQ (LAST (%ARGUMENTS ARG)) VARIABLE))
              (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
           (CL:SETQ TEST-VALUE-000 FOUND?-000))
          (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
          (CL:WHEN TEST-VALUE-000 (CL:SETQ ALWAYS?-000 FALSE)
           (CL:RETURN)))))
       (CL:WHEN ALWAYS?-000
        (CL:LET*
         ((ARG NULL) (VECTOR-002 ANDARGUMENTS) (INDEX-002 0)
          (LENGTH-002 (LENGTH VECTOR-002)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
         (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
          (CL:PROGN
           (CL:SETQ ARG
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-002))
             INDEX-002))
           (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
          (CL:WHEN
           (CL:AND (CL:NOT (CL:EQ (%KIND ARG) KWD-PROPOSITIONS-FUNCTION))
            (CL:NOT
             (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? ARG))))
           (CL:SETQ NONFUNCTIONSCOUNT (CL:1+ NONFUNCTIONSCOUNT)))))
        (CL:RETURN-FROM FUNCTION-INDUCED-EXISTS?
         (CL:= NONFUNCTIONSCOUNT 1))))))))
  FALSE)

;;; (DEFUN (PREDICATE-OF-FUNCTION-INDUCED-EXISTS PROPOSITION) ...)

(CL:DEFUN PREDICATE-OF-FUNCTION-INDUCED-EXISTS (EXISTSPROPOSITION)
  (CL:LET* ((VALUE-000 NULL))
   (CL:LET*
    ((ARG NULL)
     (VECTOR-000
      (%ARGUMENTS
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%THE-ARRAY (%ARGUMENTS EXISTSPROPOSITION)))
        0)))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ (%KIND ARG) KWD-PROPOSITIONS-FUNCTION))
       (CL:NOT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? ARG))))
      (CL:SETQ VALUE-000 ARG) (CL:RETURN))))
   (CL:LET* ((VALUE-001 VALUE-000)) VALUE-001)))

;;; (DEFUN (EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS PROPOSITION) ...)

(CL:DEFUN EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS (EXISTSPROPOSITION)
  (INVERT-PROPOSITION
   (PREDICATE-OF-FUNCTION-INDUCED-EXISTS EXISTSPROPOSITION))
  EXISTSPROPOSITION)

;;; (DEFUN (BUILD-AND-OR-NOT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-AND-OR-NOT-PROPOSITION (TREE)
  (CL:LET*
   ((TERM NULL) (ARGUMENTS NIL) (PROPOSITION NULL) (ARGUMENTSVECTOR NULL))
   (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-AND)
      (CL:LET* ((ARG NULL) (ITER-000 (%%REST TREE)) (COLLECT-000 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-000))
         (CL:SETQ ITER-000 (%%REST ITER-000)))
        (CL:LET* () (CL:SETQ TERM (BUILD-PROPOSITION ARG))
         (CL:WHEN (CL:NOT (CL:EQ TERM NULL))
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS TERM NIL))
            (CL:IF (CL:EQ ARGUMENTS NIL) (CL:SETQ ARGUMENTS COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST ARGUMENTS COLLECT-000)))
           (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS TERM NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))))
     ((CL:OR (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-OR)
       (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-NOT))
      (CL:LET* ((ARG NULL) (ITER-001 (%%REST TREE)) (COLLECT-001 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-001))
         (CL:SETQ ITER-001 (%%REST ITER-001)))
        (CL:LET* () (CL:SETQ TERM (BUILD-PROPOSITION ARG))
         (CL:WHEN (CL:NOT (CL:EQ TERM NULL))
          (CL:IF (CL:EQ COLLECT-001 NULL)
           (CL:PROGN (CL:SETQ COLLECT-001 (CONS TERM NIL))
            (CL:IF (CL:EQ ARGUMENTS NIL) (CL:SETQ ARGUMENTS COLLECT-001)
             (ADD-CONS-TO-END-OF-CONS-LIST ARGUMENTS COLLECT-001)))
           (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS TERM NIL))
            (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:WHEN (CL:EQ ARGUMENTS NIL)
    (CL:RETURN-FROM BUILD-AND-OR-NOT-PROPOSITION NULL))
   (CL:WHEN
    (CL:AND (CL:EQ (%%VALUE TREE) SYM-PROPOSITIONS-STELLA-NOT)
     (FUNCTION-INDUCED-EXISTS? (%%VALUE ARGUMENTS)))
    (CL:RETURN-FROM BUILD-AND-OR-NOT-PROPOSITION
     (EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS (%%VALUE ARGUMENTS))))
   (CL:SETQ PROPOSITION
    (CREATE-PROPOSITION (%%VALUE TREE) (LENGTH ARGUMENTS)))
   (CL:SETQ ARGUMENTSVECTOR (%ARGUMENTS PROPOSITION))
   (CL:LET*
    ((I NULL-INTEGER) (ARG NULL) (ITER-002 ARGUMENTS) (ITER-003 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-003 I))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-002))
      (CL:SETQ ITER-002 (%%REST ITER-002)))
     (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
     (CL:LET
      ((SELF (%THE-ARRAY ARGUMENTSVECTOR)) (VALUE ARG) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   PROPOSITION))

;;; (DEFUN (FUNCTIONAL-TERM? BOOLEAN) ...)

(CL:DEFUN FUNCTIONAL-TERM? (TERM)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TERM) SGT-PROPOSITIONS-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((TEST-VALUE-000 (%%VALUE TERM)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-SETOFALL)
         (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-THE-ONLY)
         (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-SETOF)
         (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-LISTOF)
         (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-KAPPA))
        FALSE)
       (CL:T TRUE)))))
   (CL:T FALSE)))

;;; (DEFUN (CLIP-VALUE? BOOLEAN) ...)

(CL:DEFUN CLIP-VALUE? (TERM1 TERM2)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM1) SGT-PROPOSITIONS-LOGIC-SKOLEM)
    (CL:PROGN
     (CL:LET* ((VALUE1 (VALUE-OF TERM1)))
      (CL:WHEN (EQL? VALUE1 TERM2) (CL:RETURN-FROM CLIP-VALUE? TRUE))
      (CL:WHEN
       (CL:AND (CL:NOT (SKOLEM? VALUE1))
        (CL:NOT (CL:EQ (%DEFINING-PROPOSITION TERM1) NULL))
        *CLIPPINGENABLED?*)
       (UNBIND-SKOLEM-VALUE TERM1 TRUE)
       (BIND-SKOLEM-TO-VALUE TERM1 (VALUE-OF TERM2) TRUE)
       (CL:RETURN-FROM CLIP-VALUE? TRUE)))))
   (CL:T))
  FALSE)

;;; (DEFUN (CREATE-EQUIVALENCE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN CREATE-EQUIVALENCE-PROPOSITION (TERM1 TERM2)
  (CL:LET*
   ((PROPOSITION (CREATE-PROPOSITION SYM-PROPOSITIONS-LOGIC-EQUIVALENT 2))
    (ARGUMENTSVECTOR (%ARGUMENTS PROPOSITION)))
   (CL:LET
    ((SELF (%THE-ARRAY ARGUMENTSVECTOR)) (VALUE TERM1) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY ARGUMENTSVECTOR)) (VALUE TERM2) (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   PROPOSITION))

;;; (DEFUN (BUILD-EQUIVALENCE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-EQUIVALENCE-PROPOSITION (TREE)
  (CL:CASE (LENGTH TREE)
   (3
    (CREATE-EQUIVALENCE-PROPOSITION
     (EVALUATE-TERM (%%VALUE (%%REST TREE)))
     (EVALUATE-TERM (%%VALUE (%%REST (%%REST TREE))))))
   ((1 2)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "ERROR: Missing argument/s in `=' proposition.." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
     (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   (CL:OTHERWISE
    (BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS (%%REST TREE) NIL))))

;;; (DEFUN (BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS (REMAININGTERMS EQUIVALENCES)
  (CL:WHEN (CL:EQ (%%REST REMAININGTERMS) NIL)
   (CL:RETURN-FROM BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS
    (CONJOIN-PROPOSITIONS EQUIVALENCES)))
  (CL:SETQ EQUIVALENCES
   (CONS
    (BUILD-EQUIVALENCE-PROPOSITION
     (LIST* SYM-PROPOSITIONS-STELLA-= (%%VALUE REMAININGTERMS)
      (CONS (%%VALUE (%%REST REMAININGTERMS)) NIL)))
    EQUIVALENCES))
  (BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS (%%REST REMAININGTERMS)
   EQUIVALENCES))

;;; (DEFUN (BUILD-FAIL-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-FAIL-PROPOSITION (TREE)
  (CL:LET*
   ((PROPOSITION (CREATE-PROPOSITION SYM-PROPOSITIONS-LOGIC-FAIL 1))
    (ARGUMENT (BUILD-PROPOSITION (%%VALUE (%%REST TREE)))))
   (CL:WHEN (CL:EQ ARGUMENT NULL)
    (CL:RETURN-FROM BUILD-FAIL-PROPOSITION NULL))
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION))) (VALUE ARGUMENT)
     (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   PROPOSITION))

;;; (DEFUN (BUILD-COLLECT-INTO-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-COLLECT-INTO-PROPOSITION (TREE)
  (CL:LET*
   ((PROPOSITION
     (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-COLLECT-INTO 2))
    (ARGUMENTSVECTOR (%ARGUMENTS PROPOSITION)))
   (CL:LET
    ((SELF (%THE-ARRAY ARGUMENTSVECTOR))
     (VALUE (EVALUATE-TERM (%%VALUE (%%REST TREE)))) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY ARGUMENTSVECTOR))
     (VALUE (EVALUATE-TERM (%%VALUE (%%REST (%%REST TREE)))))
     (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   PROPOSITION))

;;; (DEFUN (HOLDS-OPERATOR? BOOLEAN) ...)

(CL:DEFUN HOLDS-OPERATOR? (OPERATOR)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OPERATOR)))
   (CL:COND
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:OR (CL:EQ OPERATOR SYM-PROPOSITIONS-PL-KERNEL-KB-HOLDS)
       (CL:NOT (CL:EQ (LOOKUP-LOGIC-VARIABLE-BINDING OPERATOR) NULL)))))
    ((CL:EQ TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-CONS) (CL:PROGN TRUE))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN VERIFY-EVALUABLE-OPERATOR ...)

(CL:DEFUN VERIFY-EVALUABLE-OPERATOR (OPERATOR KIND)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE OPERATOR)
     SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
    (CL:PROGN
     (CL:COND
      ((CL:EQ KIND KWD-PROPOSITIONS-PREDICATE)
       (CL:SETF (%ROOT-TYPE OPERATOR)
        SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION))
      ((CL:EQ KIND KWD-PROPOSITIONS-FUNCTION)
       (CL:SETF (%ROOT-TYPE OPERATOR)
        SGT-PROPOSITIONS-PL-KERNEL-KB-FUNCTION))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KIND
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
   (CL:T)))

;;; (DEFUN (BUILD-HOLDS-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-HOLDS-PROPOSITION (TREE)
  (CL:LET*
   ((OPERATOREXPRESSION (%%VALUE TREE))
    (EXPLICITHOLDS?
     (CL:EQ OPERATOREXPRESSION SYM-PROPOSITIONS-PL-KERNEL-KB-HOLDS))
    (ARGCOUNT (LENGTH (%%REST TREE)))
    (PROPOSITION
     (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-PREDICATE
      (CL:IF EXPLICITHOLDS? ARGCOUNT (CL:1+ ARGCOUNT)))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARGCOUNT))
   (CL:SETF (%OPERATOR PROPOSITION) SGT-PROPOSITIONS-PL-KERNEL-KB-HOLDS)
   (CL:WHEN EXPLICITHOLDS?
    (CL:LET*
     ((I NULL-INTEGER) (ARG NULL) (ITER-000 (%%REST TREE)) (ITER-001 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
      (CL:LET
       ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        (VALUE
         (CL:IF (CL:= I 0)
          (EVALUATE-FIRST-ARGUMENT ARG
           SYM-PROPOSITIONS-PL-KERNEL-KB-HOLDS)
          (EVALUATE-TERM ARG)))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))))
    (CL:RETURN-FROM BUILD-HOLDS-PROPOSITION PROPOSITION))
   (CL:LET* ((OPERATOR NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OPERATOREXPRESSION)))
     (CL:COND
      ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
       (CL:PROGN
        (CL:SETQ OPERATOR
         (LOOKUP-LOGIC-VARIABLE-BINDING OPERATOREXPRESSION))))
      ((CL:EQ TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-CONS)
       (CL:PROGN
        (CL:SETQ OPERATOR
         (EVALUATE-FIRST-ARGUMENT OPERATOREXPRESSION
          SYM-PROPOSITIONS-PL-KERNEL-KB-HOLDS))))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (VERIFY-EVALUABLE-OPERATOR OPERATOR KWD-PROPOSITIONS-PREDICATE)
    (CL:LET
     ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION))) (VALUE OPERATOR)
      (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET*
     ((I NULL-INTEGER) (ARG NULL) (ITER-002 (%%REST TREE)) (ITER-003 1))
     (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-003 I))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-002))
       (CL:SETQ ITER-002 (%%REST ITER-002)))
      (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
      (CL:LET
       ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        (VALUE (EVALUATE-TERM ARG)) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))))
    PROPOSITION)))

;;; (DEFUN (MOST-GENERAL-EQUIVALENT-SLOTREF SURROGATE) ...)

(CL:DEFUN MOST-GENERAL-EQUIVALENT-SLOTREF (SURROGATE)
  (CL:LET* ((SLOT (%SURROGATE-VALUE SURROGATE)))
   (CL:WHEN (CL:EQ SLOT NULL)
    (CL:RETURN-FROM MOST-GENERAL-EQUIVALENT-SLOTREF NULL))
   (CL:WHEN (CL:NOT (CL:EQ (%SLOT-DIRECT-EQUIVALENT SLOT) NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ (%SLOT-DIRECT-EQUIVALENT SLOT) NULL)) DO
     (CL:SETQ SLOT (%SLOT-DIRECT-EQUIVALENT SLOT)))
    (CL:WHEN (CL:EQ (%SLOT-SLOTREF SLOT) NULL)
     (LOOKUP-SLOTREF (%SLOT-OWNER SLOT) (%SLOT-NAME SLOT))))
   (%SLOT-SLOTREF SLOT)))

;;; (DEFUN (NON-POLYMORPHIC-PREDICATE? BOOLEAN) ...)

(CL:DEFUN NON-POLYMORPHIC-PREDICATE? (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:LET* ((RELATION (NATIVE-RELATION SELF)))
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ RELATION NULL))
         (POLYMORPHIC-RELATION? RELATION))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:NOT
       (TEST-ISA? SELF SGT-PROPOSITIONS-PL-KERNEL-KB-POLYMORPHIC))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (EVALUATE-PREDICATE LOGIC-OBJECT) ...)

(CL:DEFUN EVALUATE-PREDICATE (NAME FIRSTARGUMENT)
  (CL:LET* ((SURROGATE NULL) (PREDICATEVALUE NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NAME)))
    (CL:COND
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ SURROGATE (SYMBOL-TO-SURROGATE NAME))))
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ SURROGATE NAME)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:SETQ PREDICATEVALUE (GET-DESCRIPTION SURROGATE))
   (CL:IF (CL:NOT (CL:EQ PREDICATEVALUE NULL))
    (CL:RETURN-FROM EVALUATE-PREDICATE PREDICATEVALUE)
    (CL:PROGN (CL:SETQ PREDICATEVALUE (%SURROGATE-VALUE SURROGATE))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ PREDICATEVALUE NULL))
       (TEST-ISA? PREDICATEVALUE SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION)
       (NON-POLYMORPHIC-PREDICATE? PREDICATEVALUE))
      (CL:RETURN-FROM EVALUATE-PREDICATE PREDICATEVALUE))))
   (CL:WHEN (CL:NOT (CL:EQ FIRSTARGUMENT NULL))
    (CL:LET*
     ((FIRSTARGVALUE (VALUE-OF FIRSTARGUMENT))
      (SYMBOL (SURROGATE-TO-SYMBOL SURROGATE)))
     (CL:WHEN (CL:EQ FIRSTARGVALUE NULL)
      (SIGNAL-UNDEFINED-TERM FIRSTARGUMENT))
     (CL:SETQ SURROGATE (LOOKUP-SLOTREF-ON-INSTANCE FIRSTARGVALUE SYMBOL))
     (CL:WHEN (CL:NOT (CL:EQ SURROGATE NULL))
      (CL:RETURN-FROM EVALUATE-PREDICATE
       (GET-DESCRIPTION (MOST-GENERAL-EQUIVALENT-SLOTREF SURROGATE))))))
   NULL))

;;; (DEFUN (EVALUATE-TYPED-ARGUMENT OBJECT) ...)

(CL:DEFUN EVALUATE-TYPED-ARGUMENT (ARGUMENT TYPE)
  (CL:COND
   ((CL:EQ TYPE SGT-PROPOSITIONS-LOGIC-PROPOSITION)
    (BUILD-PROPOSITION ARGUMENT))
   ((CL:NOT (CL:EQ TYPE NULL))
    (CL:LET* ((*DEFAULTCREATIONTYPE* TYPE))
     (CL:DECLARE (CL:SPECIAL *DEFAULTCREATIONTYPE*))
     (EVALUATE-TERM ARGUMENT)))
   (CL:T (EVALUATE-TERM ARGUMENT))))

;;; (DEFUN (EVALUATE-FIRST-ARGUMENT OBJECT) ...)

(CL:DEFUN EVALUATE-FIRST-ARGUMENT (ARGUMENT RELATIONNAME)
  (CL:LET*
   ((PREDICATEVALUE (EVALUATE-PREDICATE RELATIONNAME NULL)) (TYPE NULL)
    (FIRSTARGUMENT NULL))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ PREDICATEVALUE NULL))
     (ISA? PREDICATEVALUE SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION))
    (CL:SETQ TYPE (FIRST (%IO-VARIABLE-TYPES PREDICATEVALUE))))
   (CL:SETQ FIRSTARGUMENT (EVALUATE-TYPED-ARGUMENT ARGUMENT TYPE))
   (CL:COND
    ((CL:OR (CL:EQ RELATIONNAME SYM-PROPOSITIONS-PL-KERNEL-KB-VALUE)
      (CL:EQ RELATIONNAME SYM-PROPOSITIONS-PL-KERNEL-KB-HOLDS))
     (CL:WHEN (CL:AND (DESCRIPTION-MODE?) (VARIABLE? FIRSTARGUMENT))
      (CL:LET* ((FNPROP (%DEFINING-PROPOSITION FIRSTARGUMENT)))
       (CL:LET* ((TEST-VALUE-000 FALSE))
        (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ FNPROP NULL)))
        (CL:WHEN TEST-VALUE-000
         (CL:LET* ((FOUND?-000 FALSE))
          (CL:LET*
           ((I NULL-INTEGER) (ARG NULL) (VECTOR-000 (%ARGUMENTS FNPROP))
            (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (ITER-000 1)
            (UPPER-BOUND-000 (CL:1- (LENGTH (%ARGUMENTS FNPROP)))))
           (CL:DECLARE
            (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-000
             UPPER-BOUND-000 I))
           (CL:LOOP WHILE
            (CL:AND (CL:< INDEX-000 LENGTH-000)
             (CL:<= ITER-000 UPPER-BOUND-000))
            DO
            (CL:PROGN
             (CL:SETQ ARG
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
               INDEX-000))
             (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
            (CL:PROGN (CL:SETQ I ITER-000)
             (CL:SETQ ITER-000 (CL:1+ ITER-000)))
            (CL:WHEN (VARIABLE? ARG) (CL:SETQ FOUND?-000 TRUE)
             (CL:RETURN))))
          (CL:SETQ TEST-VALUE-000 FOUND?-000))
         (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000)))
        (CL:WHEN TEST-VALUE-000
         (CL:LET*
          ((*EVALUATIONMODE* KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION))
          (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
          (CL:SETQ FIRSTARGUMENT
           (EVALUATE-TYPED-ARGUMENT ARGUMENT TYPE))))))))
    (CL:T))
   (CL:WHEN (CL:EQ FIRSTARGUMENT NULL) (SIGNAL-UNDEFINED-TERM ARGUMENT))
   (CL:LET* ((*SUPPRESSNONLOGICOBJECTWARNING?* TRUE))
    (CL:DECLARE (CL:SPECIAL *SUPPRESSNONLOGICOBJECTWARNING?*))
    (CL:WHEN (CL:EQ (VALUE-OF FIRSTARGUMENT) BOTTOM)
     (SIGNAL-UNDEFINED-TERM FIRSTARGUMENT)))
   FIRSTARGUMENT))

;;; (DEFUN (EVALUATE-REMAINING-ARGUMENTS CONS) ...)

(CL:DEFUN EVALUATE-REMAINING-ARGUMENTS (PREDICATEVALUE ARGUMENTS)
  (CL:LET* ((EVALUATEDARGUMENTS NIL))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ PREDICATEVALUE NULL))
     (ISA? PREDICATEVALUE SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION))
    (CL:LET* ((VARIABLETYPES (%IO-VARIABLE-TYPES PREDICATEVALUE)))
     (CL:LET* ((TYPE NULL) (ITER-000 (REST VARIABLETYPES)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ TYPE (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:LET* ((HEAD-000 (%%VALUE ARGUMENTS)))
        (CL:SETQ ARGUMENTS (%%REST ARGUMENTS))
        (CL:LET* ((ARG HEAD-000))
         (CL:WHEN (CL:NOT (CL:EQ ARG NULL))
          (CL:SETQ EVALUATEDARGUMENTS
           (CONS (EVALUATE-TYPED-ARGUMENT ARG TYPE)
            EVALUATEDARGUMENTS)))))))
     (CL:LET* ((ARG NULL) (ITER-001 ARGUMENTS))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-001))
        (CL:SETQ ITER-001 (%%REST ITER-001)))
       (CL:SETQ EVALUATEDARGUMENTS
        (CONS (EVALUATE-TYPED-ARGUMENT ARG (LAST VARIABLETYPES))
         EVALUATEDARGUMENTS))))
     (REVERSE EVALUATEDARGUMENTS))
    (CL:PROGN
     (CL:LET* ((ARG NULL) (ITER-002 ARGUMENTS) (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-002))
        (CL:SETQ ITER-002 (%%REST ITER-002)))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS (EVALUATE-TERM ARG) NIL))
         (CL:IF (CL:EQ EVALUATEDARGUMENTS NIL)
          (CL:SETQ EVALUATEDARGUMENTS COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST EVALUATEDARGUMENTS COLLECT-000)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-000) (CONS (EVALUATE-TERM ARG) NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
     EVALUATEDARGUMENTS))))

;;; (DEFUN (CLASS-OPERATOR? BOOLEAN) ...)

(CL:DEFUN CLASS-OPERATOR? (OPERATOR)
  (CL:LET* ((DESCRIPTION (GET-DESCRIPTION OPERATOR)))
   (CL:AND (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CLASS-DESCRIPTION? DESCRIPTION))))

;;; (DEFUN (BUILD-PREDICATE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-PREDICATE-PROPOSITION (TREE)
  (CL:WHEN
   (CL:AND (CL:= (LENGTH TREE) 2) (CLASS-OPERATOR? (%%VALUE TREE)))
   (CL:RETURN-FROM BUILD-PREDICATE-PROPOSITION
    (BUILD-ISA-PROPOSITION
     (LIST* SYM-PROPOSITIONS-STELLA-ISA (%%VALUE (%%REST TREE))
      (CONS (%%VALUE TREE) NIL)))))
  (CL:WHEN (HOLDS-OPERATOR? (%%VALUE TREE))
   (CL:RETURN-FROM BUILD-PREDICATE-PROPOSITION
    (BUILD-HOLDS-PROPOSITION TREE)))
  (CL:LET*
   ((PREDICATENAME (%%VALUE TREE))
    (PROPOSITION
     (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-PREDICATE
      (LENGTH (%%REST TREE))))
    (FIRSTARGUMENT NULL) (PREDICATEVALUE NULL))
   (CL:COND
    ((CL:EQ (%%REST TREE) NIL)
     (CL:IF (CL:EQ PREDICATENAME SYM-PROPOSITIONS-PL-KERNEL-KB-CUT) NULL
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Predicate `"
       PREDICATENAME "' applied to zero arguments." EOL)))
    (CL:T
     (CL:SETQ FIRSTARGUMENT
      (EVALUATE-FIRST-ARGUMENT (%%VALUE (%%REST TREE)) PREDICATENAME))
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION))) (VALUE FIRSTARGUMENT)
       (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:SETQ PREDICATEVALUE
    (EVALUATE-PREDICATE PREDICATENAME FIRSTARGUMENT))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ PREDICATEVALUE NULL))
     (FUNCTION? PREDICATEVALUE))
    (CL:IF (DESCRIPTION-MODE?)
     (CL:SETF (%KIND PROPOSITION) KWD-PROPOSITIONS-FUNCTION)
     (CL:LET*
      ((LASTARGINDEX (CL:1- (LENGTH TREE)))
       (RESULTARGUMENT (NTH TREE LASTARGINDEX)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM LASTARGINDEX))
      (NTH-SETTER TREE NULL LASTARGINDEX)
      (CL:SETQ TREE (REMOVE TREE NULL))
      (CL:RETURN-FROM BUILD-PREDICATE-PROPOSITION
       (BUILD-PROPOSITION
        (LIST* SYM-PROPOSITIONS-STELLA-= TREE
         (CONS RESULTARGUMENT NIL)))))))
   (CL:LET*
    ((I NULL-INTEGER) (ARG NULL)
     (ITER-000
      (EVALUATE-REMAINING-ARGUMENTS PREDICATEVALUE
       (%%REST (%%REST TREE))))
     (ITER-001 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION))) (VALUE ARG)
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (CL:SETF (%OPERATOR PROPOSITION)
    (CL:IF (CL:NOT (CL:EQ PREDICATEVALUE NULL))
     (%SURROGATE-VALUE-INVERSE PREDICATEVALUE) PREDICATENAME))
   (CL:WHEN
    (CL:EQ (%OPERATOR PROPOSITION) SGT-PROPOSITIONS-PL-KERNEL-KB-VALUE)
    (CL:SETQ PROPOSITION (NORMALIZE-VALUE-FUNCTION PROPOSITION)))
   (VERIFY-ARGUMENT-TYPES-AND-COUNT PROPOSITION) PROPOSITION))

;;; (DEFUN (CHECK-TYPE? BOOLEAN OBJECT) ...)

(CL:DEFUN CHECK-TYPE? (SELF TYPE SHALLOW?)
  (CL:WHEN
   (CL:OR (CL:EQ TYPE NULL) (CL:EQ TYPE SGT-PROPOSITIONS-STELLA-THING))
   (CL:RETURN-FROM CHECK-TYPE? (CL:VALUES TRUE SELF)))
  (CL:LET* ((TYPEISOK? TRUE))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
      (CL:PROGN))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER)
      (CL:PROGN
       (CL:IF (ISA? (%SURROGATE-VALUE TYPE) SGT-PROPOSITIONS-STELLA-CLASS)
        (CL:SETQ TYPEISOK? (SUBTYPE-OF? (LOGICAL-TYPE SELF) TYPE))
        (CL:SETQ TYPEISOK? FALSE))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
      (CL:PROGN
       (CL:IF (ISA? (%SURROGATE-VALUE TYPE) SGT-PROPOSITIONS-STELLA-CLASS)
        (CL:SETQ TYPEISOK? (SUBTYPE-OF? (LOGICAL-TYPE SELF) TYPE))
        (CL:SETQ TYPEISOK? FALSE))))
     (CL:T
      (CL:SETQ TYPEISOK?
       (CL:OR (TEST-ISA? SELF TYPE)
        (LOGICAL-SUBTYPE-OF? (LOGICAL-TYPE SELF) TYPE))))))
   (CL:WHEN TYPEISOK? (CL:RETURN-FROM CHECK-TYPE? (CL:VALUES TRUE SELF)))
   (CL:LET* ((SUBSTITUTEDVALUE (COERCE-INCOMPATIBLE-VALUE SELF TYPE)))
    (CL:WHEN (CL:NOT (CL:EQ SUBSTITUTEDVALUE NULL))
     (CL:RETURN-FROM CHECK-TYPE? (CL:VALUES TRUE SUBSTITUTEDVALUE))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
     (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
    (CL:RETURN-FROM CHECK-TYPE? (CL:VALUES TRUE SELF)))
   (CL:VALUES FALSE SELF)))

;;; (DEFUN (COERCE-INCOMPATIBLE-VALUE OBJECT) ...)

(CL:DEFUN COERCE-INCOMPATIBLE-VALUE (VALUE TYPE)
  (CL:LET* ((SUBSTITUTEVALUE NULL))
   (CL:COND
    ((RELATIONREF-SPECIALIZES-RELATIONREF? TYPE
      SGT-PROPOSITIONS-PL-KERNEL-KB-QUANTITY)
     (CL:RETURN-FROM COERCE-INCOMPATIBLE-VALUE
      (COERCE-QUANTITY VALUE TYPE)))
    ((RELATIONREF-SPECIALIZES-RELATIONREF? TYPE
      SGT-PROPOSITIONS-PL-KERNEL-KB-DATE)
     (CL:RETURN-FROM COERCE-INCOMPATIBLE-VALUE (COERCE-DATE VALUE TYPE))))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? (SAFE-PRIMARY-TYPE VALUE))
     (CL:PROGN
      (CL:WHEN (CL:EQ TYPE SGT-PROPOSITIONS-STELLA-FLOAT)
       (CL:LET*
        ((INTVALUE (%WRAPPER-VALUE VALUE))
         (FLOATVALUE (CL:* INTVALUE 1.0d0)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INTVALUE)
         (CL:TYPE CL:DOUBLE-FLOAT FLOATVALUE))
        (CL:SETQ SUBSTITUTEVALUE (WRAP-FLOAT FLOATVALUE))))))
    (CL:T))
   SUBSTITUTEVALUE))

;;; (DEFUN (COERCE-QUANTITY OBJECT) ...)

(CL:DEFUN COERCE-QUANTITY (VALUE QUANTITYTYPEREF)
  VALUE)

;;; (DEFUN (COERCE-DATE OBJECT) ...)

(CL:DEFUN COERCE-DATE (VALUE DATETYPEREF)
  VALUE)

;;; (DEFUN (UNFINALIZED-RELATION? BOOLEAN) ...)

(CL:DEFUN UNFINALIZED-RELATION? (RELATION)
  (CL:OR (MEMBER? *UNFINALIZED-RELATIONS* RELATION)
   (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (BAD? RELATION))))

;;; (DEFGLOBAL *TYPE-CHECK-POLICY* ...)

(CL:DEFVAR *TYPE-CHECK-POLICY* NULL
  "Two policies are implemented:
   :AUTOMATICALLY-FIX-TYPE-VIOLATIONS 
       'asserts missing types to fix type violations' (default)
   :REPORT-TYPE-VIOLATIONS
       'complain about missing types'")

;;; (DEFSPECIAL *TYPECHECKMODE* ...)

(CL:DEFVAR *TYPECHECKMODE* NULL
  "Controls the behavior of the type-checking
routines in the event that a type-check fails.  Options are:
  :POST-TYPE-VIOLATIONS               'push offending proposition onto queue'
  :REPORT-TYPE-VIOLATIONS             'print occasions of failed type checks'
  :AUTOMATICALLY-FIX-TYPE-VIOLATIONS  'assert missing types on propositions'")

;;; (DEFUN VERIFY-ONE-ARGUMENT-TYPE ...)

(CL:DEFUN VERIFY-ONE-ARGUMENT-TYPE (ARG TYPE PROPOSITION DESCRIPTION)
  (CL:WHEN (CL:EQ (%SURROGATE-VALUE TYPE) NULL)
   (CL:RETURN-FROM VERIFY-ONE-ARGUMENT-TYPE))
  (CL:LET*
   ((ARGVALUE (VALUE-OF ARG)) (TYPEISOK? FALSE) (SUBSTITUTEVALUE NULL))
   (CL:MULTIPLE-VALUE-SETQ (TYPEISOK? SUBSTITUTEVALUE)
    (CHECK-TYPE? ARGVALUE TYPE FALSE))
   (CL:COND
    ((CL:NOT (EQL? ARGVALUE SUBSTITUTEVALUE))
     (CL:LET*
      ((I NULL-INTEGER) (T NULL) (ARGTOO NULL)
       (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000))
       (ITER-000 (%THE-CONS-LIST (%IO-VARIABLE-TYPES DESCRIPTION)))
       (ITER-001 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-001 I))
      (CL:LOOP WHILE
       (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:NOT (CL:EQ ITER-000 NIL)))
       DO
       (CL:PROGN
        (CL:SETQ ARGTOO
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
       (CL:PROGN (CL:SETQ T (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
       (CL:WHEN (CL:AND (EQL? ARGTOO ARG) (CL:EQ T TYPE))
        (CL:LET
         ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          (VALUE SUBSTITUTEVALUE) (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))))))
    ((CL:NOT TYPEISOK?)
     (HANDLE-ARGUMENT-TYPE-VIOLATION PROPOSITION ARG TYPE)))))

;;; (DEFUN VERIFY-ARGUMENT-TYPES-AND-COUNT ...)

(CL:DEFUN VERIFY-ARGUMENT-TYPES-AND-COUNT (PROPOSITION)
  (CL:WHEN
   (CL:OR (CL:NOT (WORLD-STATE? *CONTEXT*))
    (CL:NOT
     (ISA? (%OPERATOR PROPOSITION) SGT-PROPOSITIONS-STELLA-SURROGATE)))
   (CL:RETURN-FROM VERIFY-ARGUMENT-TYPES-AND-COUNT))
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION (%OPERATOR PROPOSITION)))
    (ARGUMENTCOUNT (LENGTH (%ARGUMENTS PROPOSITION))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARGUMENTCOUNT))
   (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-FUNCTION)
       (CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-ISA))
      (CL:WHEN (CL:EQ DESCRIPTION NULL)
       (CL:RETURN-FROM VERIFY-ARGUMENT-TYPES-AND-COUNT))
      (CL:LET*
       ((ARITY (ARITY DESCRIPTION))
        (VARIABLEARITY? (CL:NOT (CL:> ARITY 0)))
        (FUNCTION? (CL:EQ (%KIND PROPOSITION) KWD-PROPOSITIONS-FUNCTION)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
       (CL:WHEN
        (CL:AND (CL:NOT VARIABLEARITY?)
         (CL:NOT (CL:= ARGUMENTCOUNT ARITY)))
        (HANDLE-ARITY-VIOLATION PROPOSITION ARITY))
       (CL:LET*
        ((TYPE NULL) (ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION))
         (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
         (I
          (INTERVAL 1
           (CL:IF (CL:AND VARIABLEARITY? FUNCTION?) (CL:1- ARGUMENTCOUNT)
            ARGUMENTCOUNT)))
         (ITER-000 (ALL-DOMAIN-TYPES DESCRIPTION)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE
         (CL:AND (CL:< INDEX-000 LENGTH-000) (NEXT? I) (NEXT? ITER-000))
         DO
         (CL:PROGN
          (CL:SETQ ARG
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
         (CL:SETQ TYPE (%VALUE ITER-000))
         (CL:WHEN
          (CL:AND (CL:NOT (CL:EQ TYPE NULL))
           (CL:NOT (CL:EQ TYPE SGT-PROPOSITIONS-STELLA-THING))
           (CL:NOT (CL:EQ ARG NULL)))
          (VERIFY-ONE-ARGUMENT-TYPE ARG TYPE PROPOSITION DESCRIPTION))))
       (CL:WHEN FUNCTION?
        (VERIFY-ONE-ARGUMENT-TYPE (LAST (%ARGUMENTS PROPOSITION))
         (LAST (%IO-VARIABLE-TYPES DESCRIPTION)) PROPOSITION
         DESCRIPTION))))
     ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-EQUIVALENT)
      (CL:LET*
       ((ARG1
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          0))
        (ARG2
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          1))
        (REQUIREDTYPE NULL) (CONSTRAININGARG NULL) (OFFENDINGARG NULL)
        (TYPEISOK? FALSE) (SUBSTITUTEVALUE NULL))
       (CL:SETQ REQUIREDTYPE (SAFE-LOGICAL-TYPE ARG2))
       (CL:MULTIPLE-VALUE-SETQ (TYPEISOK? SUBSTITUTEVALUE)
        (CHECK-TYPE? ARG1 REQUIREDTYPE FALSE))
       (CL:COND
        ((CL:NOT (EQL? ARG1 SUBSTITUTEVALUE))
         (CL:LET
          ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
           (VALUE SUBSTITUTEVALUE) (POSITION 0))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:RETURN-FROM VERIFY-ARGUMENT-TYPES-AND-COUNT))
        ((CL:NOT TYPEISOK?) (CL:SETQ CONSTRAININGARG ARG2)
         (CL:SETQ OFFENDINGARG ARG1)))
       (CL:WHEN TYPEISOK? (CL:SETQ REQUIREDTYPE (SAFE-LOGICAL-TYPE ARG1))
        (CL:MULTIPLE-VALUE-SETQ (TYPEISOK? SUBSTITUTEVALUE)
         (CHECK-TYPE? ARG2 REQUIREDTYPE FALSE))
        (CL:COND
         ((CL:NOT (EQL? ARG2 SUBSTITUTEVALUE))
          (CL:LET
           ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
            (VALUE SUBSTITUTEVALUE) (POSITION 1))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SETF (CL:AREF SELF POSITION) VALUE))
          (CL:RETURN-FROM VERIFY-ARGUMENT-TYPES-AND-COUNT))
         ((CL:NOT TYPEISOK?) (CL:SETQ CONSTRAININGARG ARG1)
          (CL:SETQ OFFENDINGARG ARG2))))
       (CL:WHEN (CL:NOT TYPEISOK?)
        (CL:LET* ((*TERMUNDERCONSTRUCTION* *TERMUNDERCONSTRUCTION*))
         (CL:DECLARE (CL:SPECIAL *TERMUNDERCONSTRUCTION*))
         (CL:WHEN
          (CL:AND (CL:EQ *TERMUNDERCONSTRUCTION* NULL)
           (SKOLEM? CONSTRAININGARG))
          (CL:SETQ *TERMUNDERCONSTRUCTION*
           (%DEFINING-PROPOSITION CONSTRAININGARG)))
         (HANDLE-ARGUMENT-TYPE-VIOLATION PROPOSITION OFFENDINGARG
          REQUIREDTYPE)))))
     (CL:T)))))

;;; (DEFUN HANDLE-ARGUMENT-TYPE-VIOLATION ...)

(CL:DEFUN HANDLE-ARGUMENT-TYPE-VIOLATION (PROPOSITION ARG REQUIREDTYPE)
  (CL:COND
   ((CL:EQ *TYPECHECKMODE* KWD-PROPOSITIONS-POST-TYPE-VIOLATIONS)
    (POST-TO-CHECK-TYPES-AGENDA PROPOSITION))
   ((CL:EQ *TYPECHECKMODE* KWD-PROPOSITIONS-REPORT-TYPE-VIOLATIONS)
    (CL:LET* ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING)
      "WARNING: Type check violation on argument `" ARG "' in proposition"
      EOL "   " PROPOSITION "." EOL "   Argument must have type `"
      (%SYMBOL-NAME REQUIREDTYPE) "'." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STANDARD-WARNING
      KWD-PROPOSITIONS-WARNING)))
   ((CL:EQ *TYPECHECKMODE*
     KWD-PROPOSITIONS-AUTOMATICALLY-FIX-TYPE-VIOLATIONS)
    (CL:LET* ((ISAPROPOSITION (ASSERT-ISA-PROPOSITION ARG REQUIREDTYPE)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ISAPROPOSITION)
      SYM-PROPOSITIONS-LOGIC-ASSERTED-BY-TYPE-CHECKER?
      (CL:IF TRUE TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" *TYPECHECKMODE*
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN HANDLE-ARITY-VIOLATION ...)

(CL:DEFUN HANDLE-ARITY-VIOLATION (PROPOSITION REQUIREDARITY)
  (CL:DECLARE (CL:TYPE CL:FIXNUM REQUIREDARITY))
  (CL:COND
   ((CL:EQ *TYPECHECKMODE* KWD-PROPOSITIONS-POST-TYPE-VIOLATIONS)
    (POST-TO-CHECK-TYPES-AGENDA PROPOSITION))
   ((CL:OR (CL:EQ *TYPECHECKMODE* KWD-PROPOSITIONS-REPORT-TYPE-VIOLATIONS)
     (CL:EQ *TYPECHECKMODE*
      KWD-PROPOSITIONS-AUTOMATICALLY-FIX-TYPE-VIOLATIONS))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "ERROR: Too `"
       (CL:IF (CL:> (LENGTH (%ARGUMENTS PROPOSITION)) REQUIREDARITY)
        "many" "few")
       "' arguments in the proposition" EOL "   `"
       (GENERATE-TERM PROPOSITION) "'" EOL "   Expected `" REQUIREDARITY
       "' argument(s).." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
     (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   (CL:T
    (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" *TYPECHECKMODE*
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))

;;; (DEFCLASS CHECK-TYPES-RECORD ...)

(CL:DEFCLASS CHECK-TYPES-RECORD (STANDARD-OBJECT)
  ((PARENT-PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR
    %PARENT-PROPOSITION)
   (PARENT-DESCRIPTION :ALLOCATION :INSTANCE :ACCESSOR
    %PARENT-DESCRIPTION)
   (MODULE :ALLOCATION :INSTANCE :ACCESSOR %MODULE)))

(CL:DEFUN NEW-CHECK-TYPES-RECORD ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CHECK-TYPES-RECORD)))
   (CL:SETF (%MODULE SELF) NULL) (CL:SETF (%PARENT-DESCRIPTION SELF) NULL)
   (CL:SETF (%PARENT-PROPOSITION SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CHECK-TYPES-RECORD))
  SGT-PROPOSITIONS-LOGIC-CHECK-TYPES-RECORD)

(CL:DEFUN ACCESS-CHECK-TYPES-RECORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-PARENT-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%PARENT-PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%PARENT-PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-LOGIC-PARENT-DESCRIPTION)
    (CL:IF SETVALUE? (CL:SETF (%PARENT-DESCRIPTION SELF) VALUE)
     (CL:SETQ VALUE (%PARENT-DESCRIPTION SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-STELLA-MODULE)
    (CL:IF SETVALUE? (CL:SETF (%MODULE SELF) VALUE)
     (CL:SETQ VALUE (%MODULE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFGLOBAL *CHECK-TYPES-AGENDA* ...)

(CL:DEFVAR *CHECK-TYPES-AGENDA* NULL
  "List of propositions that have failed a type check,
but might pass once finalization is complete.")

;;; (DEFUN POST-TO-CHECK-TYPES-AGENDA ...)

(CL:DEFUN POST-TO-CHECK-TYPES-AGENDA (SELF)
  (CL:LET* ((SELF-000 (NEW-CHECK-TYPES-RECORD)))
   (CL:SETF (%PARENT-PROPOSITION SELF-000) *TERMUNDERCONSTRUCTION*)
   (CL:SETF (%PARENT-DESCRIPTION SELF-000) *DESCRIPTIONUNDERCONSTRUCTION*)
   (CL:SETF (%MODULE SELF-000) *MODULE*)
   (INSERT-AT *CHECK-TYPES-AGENDA* SELF SELF-000)))

;;; (DEFUN PROCESS-CHECK-TYPES-AGENDA ...)

(CL:DEFUN PROCESS-CHECK-TYPES-AGENDA ()
  (CL:WHEN
   (CL:OR (EMPTY? *CHECK-TYPES-AGENDA*) *INHIBITRELATIONFINALIZATION?*)
   (CL:RETURN-FROM PROCESS-CHECK-TYPES-AGENDA))
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
   "Processing check-types agenda..." EOL)
  (CL:LET* ((AGENDA (REVERSE *CHECK-TYPES-AGENDA*)))
   (CL:SETQ *CHECK-TYPES-AGENDA* (NEW-KEY-VALUE-LIST))
   (CL:LET*
    ((RECORD NULL) (PROPOSITION NULL) (ITER-000 (%THE-KV-LIST AGENDA)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
     (CL:SETQ PROPOSITION (%KEY ITER-000))
     (CL:PROGN (CL:SETQ RECORD (%VALUE ITER-000))
      (CL:SETQ ITER-000 (%REST ITER-000)))
     (CL:TAGBODY
      (CL:WHEN (CL:NOT (DELETED? PROPOSITION))
       (CL:LET*
        ((*TYPECHECKMODE*
          (CL:IF
           (%WRAPPER-VALUE
            (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
             SYM-PROPOSITIONS-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
           KWD-PROPOSITIONS-REPORT-TYPE-VIOLATIONS *TYPE-CHECK-POLICY*))
         (*TERMUNDERCONSTRUCTION* (%PARENT-PROPOSITION RECORD))
         (*DESCRIPTIONUNDERCONSTRUCTION* (%PARENT-DESCRIPTION RECORD)))
        (CL:DECLARE
         (CL:SPECIAL *TYPECHECKMODE* *TERMUNDERCONSTRUCTION*
          *DESCRIPTIONUNDERCONSTRUCTION*))
        (CL:WHEN
         (CL:OR (DELETED? PROPOSITION)
          (CL:AND (CL:NOT (CL:EQ *TERMUNDERCONSTRUCTION* NULL))
           (DELETED? *TERMUNDERCONSTRUCTION*))
          (CL:AND (CL:NOT (CL:EQ *DESCRIPTIONUNDERCONSTRUCTION* NULL))
           (DELETED? *DESCRIPTIONUNDERCONSTRUCTION*)))
         (CL:GO :CONTINUE))
        (CL:HANDLER-CASE
         (CL:LET* ((*MODULE* (%MODULE RECORD)) (*CONTEXT* *MODULE*))
          (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
          (VERIFY-ARGUMENT-TYPES-AND-COUNT PROPOSITION))
         (LOGIC-EXCEPTION (E)
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
           (EXCEPTION-MESSAGE E))))))
      :CONTINUE)))))

;;; (DEFUN (BUILD-EXISTS-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-EXISTS-PROPOSITION (TREE)
  (CL:LET* ((VARIABLES NULL) (PROPOSITION NULL) (UNUSED NULL))
   (CL:MULTIPLE-VALUE-SETQ (VARIABLES PROPOSITION UNUSED)
    (BUILD-QUANTIFIED-PROPOSITION TREE TRUE))
   (CL:SETQ UNUSED UNUSED)
   (CL:LET*
    ((EXISTSPROP (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-EXISTS 1)))
    (CL:SETF (%KIND EXISTSPROP) KWD-PROPOSITIONS-EXISTS)
    (CL:LET
     ((SELF (%THE-ARRAY (%ARGUMENTS EXISTSPROP))) (VALUE PROPOSITION)
      (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS EXISTSPROP)
     SYM-PROPOSITIONS-LOGIC-IO-VARIABLES
     (COPY-CONS-LIST-TO-VARIABLES-VECTOR VARIABLES) NULL)
    EXISTSPROP)))

;;; (DEFUN (TOP-LEVEL-EXISTS-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN TOP-LEVEL-EXISTS-PROPOSITION? (PROPOSITION)
  (CL:AND (CL:NOT (UNKNOWN? PROPOSITION))
   (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? PROPOSITION NULL)))

;;; (DEFUN (COLLECT-SKOLEMIZED-EXISTS-VARIABLES (VECTOR OF SKOLEM)) ...)

(CL:DEFUN COLLECT-SKOLEMIZED-EXISTS-VARIABLES (PROPOSITION)
  (CL:LET* ((SKOLEMS (NEW-LIST)) (RESULT NULL))
   (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? PROPOSITION SKOLEMS)
   (CL:IF (EMPTY? SKOLEMS) (CL:SETQ RESULT ZERO-VARIABLES-VECTOR)
    (CL:SETQ RESULT (NEW-VECTOR (LENGTH SKOLEMS))))
   (CL:LET*
    ((I NULL-INTEGER) (SKOLEM NULL) (ITER-000 (%THE-CONS-LIST SKOLEMS))
     (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ SKOLEM (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:LET ((SELF (%THE-ARRAY RESULT)) (VALUE SKOLEM) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   (FREE SKOLEMS) RESULT))

;;; (DEFUN (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? BOOLEAN) ...)

(CL:DEFUN HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? (PROPOSITION RESULT)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS PROPOSITION))
    (ARGUMENTCOUNT (LENGTH ARGUMENTS)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARGUMENTCOUNT))
   (CL:WHEN (CL:EQ (%KIND PROPOSITION) KWD-PROPOSITIONS-FUNCTION)
    (CL:SETQ ARGUMENTCOUNT (CL:1- ARGUMENTCOUNT)))
   (CL:LET*
    ((I NULL-INTEGER) (ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (ITER-000 1)
     (UPPER-BOUND-000 ARGUMENTCOUNT)
     (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-000 UPPER-BOUND-000 I))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000)
      (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)))
     DO
     (CL:PROGN
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:SETQ I I)
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PROPOSITION)
        (CL:PROGN
         (CL:WHEN
          (CL:AND (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? ARG RESULT)
           (CL:EQ RESULT NULL))
          (CL:RETURN-FROM HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES?
           TRUE))))
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
        (CL:PROGN))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
        (CL:PROGN
         (CL:LET* ((FOUND?-000 FALSE))
          (CL:LET*
           ((PROP NULL)
            (ITER-001
             (ALLOCATE-ITERATOR
              (UNFILTERED-DEPENDENT-ISA-PROPOSITIONS ARG))))
           (CL:LOOP WHILE (NEXT? ITER-001) DO
            (CL:SETQ PROP (%VALUE ITER-001))
            (CL:WHEN
             (CL:AND (CL:EQ (%KIND PROP) KWD-PROPOSITIONS-ISA)
              (TRUE? PROP)
              (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? PROP)))
             (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
          (CL:WHEN FOUND?-000
           (CL:IF (CL:NOT (CL:EQ RESULT NULL)) (INSERT-NEW RESULT ARG)
            (CL:RETURN-FROM HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES?
             TRUE))))))
       (CL:T)))))
   (CL:IF (CL:NOT (CL:EQ RESULT NULL)) (NON-EMPTY? RESULT) FALSE)))

;;; (DEFUN (BUILD-FORALL-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-FORALL-PROPOSITION (TREE)
  (CL:LET*
   ((FORALLPROP (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-FORALL 2)))
   (CL:LET* ((VARIABLES NULL) (ANTECEDENT NULL) (CONSEQUENT NULL))
    (CL:MULTIPLE-VALUE-SETQ (VARIABLES ANTECEDENT CONSEQUENT)
     (BUILD-QUANTIFIED-PROPOSITION TREE TRUE))
    (CL:SETF (%KIND FORALLPROP) KWD-PROPOSITIONS-FORALL)
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FORALLPROP)
     SYM-PROPOSITIONS-LOGIC-IO-VARIABLES
     (COPY-CONS-LIST-TO-VARIABLES-VECTOR VARIABLES) NULL)
    (CL:LET
     ((SELF (%THE-ARRAY (%ARGUMENTS FORALLPROP)))
      (VALUE
       (CL:IF (CL:NOT (CL:EQ ANTECEDENT NULL)) ANTECEDENT
        TRUE-PROPOSITION))
      (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET
     ((SELF (%THE-ARRAY (%ARGUMENTS FORALLPROP))) (VALUE CONSEQUENT)
      (POSITION 1))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE)))
   FORALLPROP))

;;; (DEFUN (MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT OBJECT) ...)

(CL:DEFUN MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT (ARG1 ARG2)
  (CL:WHEN (CL:OR (SKOLEM? ARG2) (DESCRIPTION-MODE?))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARG1)
      SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:WHEN (CL:NOT (CL:EQ (DESCRIPTION-SURROGATE ARG1) NULL))
       (CL:RETURN-FROM MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT
        (DESCRIPTION-SURROGATE ARG1)))))
    (CL:T)))
  ARG1)

;;; (DEFUN (CREATE-IMPLIES-PROPOSITION PROPOSITION) ...)

(CL:DEFUN CREATE-IMPLIES-PROPOSITION (TAIL HEAD)
  (CL:LET*
   ((IMPLIESPROP (CREATE-PROPOSITION SYM-PROPOSITIONS-LOGIC-IMPLIES 2)))
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS IMPLIESPROP)))
     (VALUE (MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT TAIL HEAD)) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS IMPLIESPROP)))
     (VALUE (MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT HEAD TAIL)) (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (VERIFY-ARGUMENT-TYPES-AND-COUNT IMPLIESPROP) IMPLIESPROP))

;;; (DEFUN (BUILD-IMPLIES-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-IMPLIES-PROPOSITION (TREE)
  (VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS TREE 2)
  (CL:LET*
   ((TAILARG (EVALUATE-TERM (%%VALUE (%%REST TREE))))
    (HEADARG (EVALUATE-TERM (%%VALUE (%%REST (%%REST TREE))))))
   (CREATE-IMPLIES-PROPOSITION TAILARG HEADARG)))

;;; (DEFUN (FIND-DUPLICATE-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FIND-DUPLICATE-FUNCTION-PROPOSITION (PROPOSITION)
  (CL:LET*
   ((SURROGATE (%OPERATOR PROPOSITION))
    (ARGUMENTS (%ARGUMENTS PROPOSITION)))
   (CL:WHEN (CL:NOT (ISA? SURROGATE SGT-PROPOSITIONS-STELLA-SURROGATE))
    (CL:RETURN-FROM FIND-DUPLICATE-FUNCTION-PROPOSITION NULL))
   (CL:LET* ((VALUE-000 NULL))
    (CL:LET*
     ((P NULL)
      (ITER-000
       (ALLOCATE-ITERATOR (FIND-SIMILAR-PROPOSITIONS PROPOSITION))))
     (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
      (CL:LET* ((TEST-VALUE-000 FALSE))
       (CL:SETQ TEST-VALUE-000 (CL:EQ (%OPERATOR P) SURROGATE))
       (CL:WHEN TEST-VALUE-000
        (CL:LET* ((ALWAYS?-000 TRUE))
         (CL:LET*
          ((ARG2 NULL) (ARG1 NULL) (ITER-001 (BUT-LAST ARGUMENTS))
           (VECTOR-000 (%ARGUMENTS P)) (INDEX-000 0)
           (LENGTH-000 (LENGTH VECTOR-000)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
          (CL:LOOP WHILE
           (CL:AND (NEXT? ITER-001) (CL:< INDEX-000 LENGTH-000)) DO
           (CL:SETQ ARG1 (%VALUE ITER-001))
           (CL:PROGN
            (CL:SETQ ARG2
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
              INDEX-000))
            (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
           (CL:WHEN (CL:NOT (EQL? (VALUE-OF ARG1) (VALUE-OF ARG2)))
            (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
         (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
        (CL:WHEN TEST-VALUE-000
         (CL:SETQ TEST-VALUE-000
          (CL:AND (CL:= (LENGTH ARGUMENTS) (LENGTH (%ARGUMENTS P)))
           (CL:OR (CL:EQ (%HOME-CONTEXT PROPOSITION) (%HOME-CONTEXT P))
            (MEMB? (%ALL-SUPER-CONTEXTS (%HOME-CONTEXT PROPOSITION))
             (%HOME-CONTEXT P)))))))
       (CL:WHEN TEST-VALUE-000 (CL:SETQ VALUE-000 P) (CL:RETURN)))))
    (CL:LET* ((VALUE-001 VALUE-000)) VALUE-001))))

;;; (DEFUN (UNWRAP-WRAPPED-TYPE TYPE) ...)

(CL:DEFUN UNWRAP-WRAPPED-TYPE (TYPE)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ TYPE NULL))
    (CL:NOT (CL:EQ (%SURROGATE-VALUE TYPE) NULL))
    (ISA? (%SURROGATE-VALUE TYPE) SGT-PROPOSITIONS-STELLA-CLASS)
    (SUBTYPE-OF? TYPE SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER))
   (CL:SETQ TYPE (WRAPPED-TYPE-TO-TYPE TYPE)))
  TYPE)

;;; (DEFUN (BEGIN-CREATING-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BEGIN-CREATING-FUNCTION-PROPOSITION (SURROGATE INPUTARGUMENTS)
  (CL:LET*
   ((ARGCOUNT (CL:1+ (LENGTH INPUTARGUMENTS)))
    (PROPOSITION
     (CREATE-PROPOSITION SYM-PROPOSITIONS-STELLA-FUNCTION ARGCOUNT)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARGCOUNT))
   (CL:SETF (%OPERATOR PROPOSITION) SURROGATE)
   (CL:LET*
    ((I NULL-INTEGER) (ARG NULL) (ITER-000 INPUTARGUMENTS) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-001 I))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION))) (VALUE ARG)
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))))
   PROPOSITION))

;;; (DEFUN (FINISH-CREATING-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FINISH-CREATING-FUNCTION-PROPOSITION (PROPOSITION)
  (CL:LET*
   ((ARGCOUNT (LENGTH (%ARGUMENTS PROPOSITION)))
    (DESCRIPTION (GET-DESCRIPTION (%OPERATOR PROPOSITION))) (TYPE NULL)
    (SKOLEM NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARGCOUNT))
   (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:SETQ TYPE
     (UNWRAP-WRAPPED-TYPE (LAST (%IO-VARIABLE-TYPES DESCRIPTION)))))
   (CL:LET*
    ((*CONTEXT* (%HOME-CONTEXT PROPOSITION))
     (*MODULE* (%BASE-MODULE *CONTEXT*)))
    (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
    (CL:SETQ SKOLEM (CREATE-VARIABLE-OR-SKOLEM TYPE NULL)))
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION))) (VALUE SKOLEM)
     (POSITION (CL:1- ARGCOUNT)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%DEFINING-PROPOSITION SKOLEM) PROPOSITION)
   (CL:WHEN (CL:NOT (CL:EQ TYPE NULL)) (UPDATE-SKOLEM-TYPE SKOLEM TYPE))
   (CL:WHEN
    (CL:EQ (%OPERATOR PROPOSITION) SGT-PROPOSITIONS-PL-KERNEL-KB-VALUE)
    (CL:SETQ PROPOSITION (NORMALIZE-VALUE-FUNCTION PROPOSITION)))
   (VERIFY-ARGUMENT-TYPES-AND-COUNT PROPOSITION)
   (CL:WHEN
    (ISA? (%OPERATOR PROPOSITION) SGT-PROPOSITIONS-STELLA-SURROGATE)
    (FASTEN-DOWN-ONE-PROPOSITION PROPOSITION TRUE))
   PROPOSITION))

;;; (DEFUN (FIND-OR-CREATE-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FIND-OR-CREATE-FUNCTION-PROPOSITION (PREDICATE INPUTARGUMENTS)
  (CL:LET*
   ((PROPOSITION
     (BEGIN-CREATING-FUNCTION-PROPOSITION PREDICATE INPUTARGUMENTS))
    (DUPLICATE
     (CL:IF (CL:NOT (DESCRIPTION-MODE?))
      (FIND-DUPLICATE-FUNCTION-PROPOSITION PROPOSITION) NULL)))
   (CL:WHEN (CL:NOT (CL:EQ DUPLICATE NULL))
    (CL:RETURN-FROM FIND-OR-CREATE-FUNCTION-PROPOSITION DUPLICATE))
   (FINISH-CREATING-FUNCTION-PROPOSITION PROPOSITION)))

;;; (DEFUN (CREATE-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN CREATE-FUNCTION-PROPOSITION (PREDICATE INPUTARGUMENTS)
  (CL:LET*
   ((PROPOSITION
     (BEGIN-CREATING-FUNCTION-PROPOSITION PREDICATE INPUTARGUMENTS)))
   (FINISH-CREATING-FUNCTION-PROPOSITION PROPOSITION)))

;;; (DEFUN (EVALUATE-FUNCTION-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-FUNCTION-TERM (TREE)
  (CL:LET*
   ((NAME (%%VALUE TREE))
    (FIRSTARGUMENT (EVALUATE-FIRST-ARGUMENT (%%VALUE (%%REST TREE)) NAME))
    (PREDICATEVALUE (EVALUATE-PREDICATE NAME FIRSTARGUMENT))
    (INPUTARGUMENTS
     (EVALUATE-REMAINING-ARGUMENTS PREDICATEVALUE
      (%%REST (%%REST TREE)))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ PREDICATEVALUE NULL))
     (ISA? PREDICATEVALUE SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
     (CL:NOT (FUNCTION-DESCRIPTION? PREDICATEVALUE)))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "ERROR: Relation `"
       (DESCRIPTION-NAME PREDICATEVALUE) "' found in function position.."
       EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
     (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   (CL:SETQ INPUTARGUMENTS (CONS FIRSTARGUMENT INPUTARGUMENTS))
   (CL:LET*
    ((FUNCTIONPROPOSITION
      (FIND-OR-CREATE-FUNCTION-PROPOSITION
       (CL:IF (CL:NOT (CL:EQ PREDICATEVALUE NULL))
        (%SURROGATE-VALUE-INVERSE PREDICATEVALUE) NAME)
       INPUTARGUMENTS)))
    (CL:WHEN
     (CL:AND (SYMBOL? (%OPERATOR FUNCTIONPROPOSITION))
      (CL:NOT (DESCRIPTION-MODE?)))
     (COMPLAIN-ABOUT-UNDECLARED-REFERENCE FUNCTIONPROPOSITION)
     (CREATE-DUMMY-RELATION FUNCTIONPROPOSITION))
    (CL:AREF
     (CL:THE CL:SIMPLE-VECTOR
      (%THE-ARRAY (%ARGUMENTS FUNCTIONPROPOSITION)))
     (CL:THE CL:FIXNUM
      (CL:1- (LENGTH (%ARGUMENTS FUNCTIONPROPOSITION))))))))

;;; (DEFUN (EXTENSIONAL-INDIVIDUAL? BOOLEAN) ...)

(CL:DEFUN EXTENSIONAL-INDIVIDUAL? (INDIVIDUAL)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE INDIVIDUAL)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN FALSE))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET* ((DEFININGPROPOSITION (%DEFINING-PROPOSITION INDIVIDUAL)))
       (CL:LET* ((FOUND?-000 FALSE))
        (CL:LET*
         ((PROP NULL)
          (ITER-000
           (ALLOCATE-ITERATOR
            (UNFILTERED-DEPENDENT-PROPOSITIONS INDIVIDUAL NULL))))
         (CL:LOOP WHILE (NEXT? ITER-000) DO
          (CL:SETQ PROP (%VALUE ITER-000))
          (CL:WHEN
           (CL:AND (CL:NOT (CL:EQ PROP DEFININGPROPOSITION))
            (TRUE-PROPOSITION? PROP))
           (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
        (CL:WHEN FOUND?-000
         (CL:RETURN-FROM EXTENSIONAL-INDIVIDUAL? TRUE))))
      (CL:LET* ((FOUND?-001 FALSE))
       (CL:LET* ((SK NULL) (ITER-001 (VARIABLE-VALUE-INVERSE INDIVIDUAL)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:PROGN (CL:SETQ SK (%%VALUE ITER-001))
          (CL:SETQ ITER-001 (%%REST ITER-001)))
         (CL:WHEN (EXTENSIONAL-INDIVIDUAL? SK) (CL:SETQ FOUND?-001 TRUE)
          (CL:RETURN))))
       (CL:LET* ((VALUE-000 FOUND?-001)) VALUE-000))))
    (CL:T TRUE))))

;;; (DEFUN (FUNCTION-WITH-DEFINED-VALUE? BOOLEAN) ...)

(CL:DEFUN FUNCTION-WITH-DEFINED-VALUE? (PROPOSITION)
  (CL:WHEN (CL:NOT (CL:EQ (%KIND PROPOSITION) KWD-PROPOSITIONS-FUNCTION))
   (CL:RETURN-FROM FUNCTION-WITH-DEFINED-VALUE? FALSE))
  (CL:LET*
   ((LASTARGUMENT (LAST (%ARGUMENTS PROPOSITION)))
    (RESULT?
     (CL:OR
      (TEST-PROPERTY? (GET-DESCRIPTION (%OPERATOR PROPOSITION))
       SGT-PROPOSITIONS-PL-KERNEL-KB-TOTAL)
      (EXTENSIONAL-INDIVIDUAL? (VALUE-OF LASTARGUMENT)))))
   (CL:WHEN (CL:AND RESULT? (CL:NOT (WORLD-STATE? *CONTEXT*)))
    (ASSIGN-TRUTH-VALUE PROPOSITION TRUE-WRAPPER)
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE LASTARGUMENT)
       SGT-PROPOSITIONS-LOGIC-SKOLEM)
      (CL:PROGN
       (CL:WHEN (CL:NOT (CL:EQ (%ROOT-TYPE LASTARGUMENT) NULL))
        (CL:LET*
         ((*EVALUATIONMODE* KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION)
          (*INVISIBLEASSERTION?* TRUE))
         (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE* *INVISIBLEASSERTION?*))
         (ASSERT-ISA-PROPOSITION LASTARGUMENT
          (%ROOT-TYPE LASTARGUMENT))))))
     (CL:T)))
   RESULT?))

;;; (DEFUN (CREATE-LOGICAL-LIST SKOLEM) ...)

(CL:DEFUN CREATE-LOGICAL-LIST (LIST)
  (CL:LET*
   ((LISTPROP
     (BEGIN-CREATING-FUNCTION-PROPOSITION
      SGT-PROPOSITIONS-PL-KERNEL-KB-LISTOF (%THE-CONS-LIST LIST)))
    (SKOLEM (CREATE-SKOLEM SGT-PROPOSITIONS-PL-KERNEL-KB-LIST NULL)))
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS LISTPROP))) (VALUE SKOLEM)
     (POSITION (LENGTH LIST)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%DEFINING-PROPOSITION SKOLEM) LISTPROP)
   (ADD-DEPENDENT-PROPOSITION-LINK SKOLEM LISTPROP)
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS LISTPROP)
    SYM-PROPOSITIONS-LOGIC-UNFASTENED? NULL NULL)
   SKOLEM))

;;; (DEFUN (LOGICAL-LIST? BOOLEAN) ...)

(CL:DEFUN LOGICAL-LIST? (SELF)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF) SGT-PROPOSITIONS-LOGIC-SKOLEM)
    (CL:PROGN
     (CL:LET* ((DEFININGPROPOSITION (%DEFINING-PROPOSITION SELF)))
      (CL:AND (CL:NOT (CL:EQ DEFININGPROPOSITION NULL))
       (COLLECTIONOF-PROPOSITION? DEFININGPROPOSITION)))))
   (CL:T FALSE)))

;;; (DEFUN (REMOVE-TRUE-AND-FALSE OBJECT BOOLEAN) ...)

(CL:DEFUN REMOVE-TRUE-AND-FALSE (TREE)
  (CL:LET*
   ((T SYM-PROPOSITIONS-STELLA-TRUE) (F SYM-PROPOSITIONS-STELLA-FALSE))
   (CL:LET* ((TEST-VALUE-000 FALSE))
    (CL:LET* ((FOUND?-000 FALSE))
     (CL:LET* ((ARG NULL) (ITER-000 (%%REST TREE)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:WHEN (CL:OR (CL:EQ ARG T) (CL:EQ ARG F))
        (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
     (CL:SETQ TEST-VALUE-000 FOUND?-000))
    (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
    (CL:WHEN TEST-VALUE-000
     (CL:RETURN-FROM REMOVE-TRUE-AND-FALSE (CL:VALUES TREE FALSE))))
   (CL:LET* ((TEST-VALUE-001 (%%VALUE TREE)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-STELLA-AND)
      (CL:SETF (%%REST TREE) (REMOVE (%%REST TREE) T))
      (CL:LET* ((FOUND?-001 FALSE))
       (CL:LET* ((ARG NULL) (ITER-001 (%%REST TREE)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-001))
          (CL:SETQ ITER-001 (%%REST ITER-001)))
         (CL:WHEN (CL:EQ ARG F) (CL:SETQ FOUND?-001 TRUE) (CL:RETURN))))
       (CL:WHEN FOUND?-001
        (CL:RETURN-FROM REMOVE-TRUE-AND-FALSE
         (CL:VALUES SYM-PROPOSITIONS-STELLA-FALSE TRUE)))))
     ((CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-STELLA-OR)
      (CL:SETF (%%REST TREE) (REMOVE (%%REST TREE) F))
      (CL:LET* ((FOUND?-002 FALSE))
       (CL:LET* ((ARG NULL) (ITER-002 (%%REST TREE)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
         (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-002))
          (CL:SETQ ITER-002 (%%REST ITER-002)))
         (CL:WHEN (CL:EQ ARG T) (CL:SETQ FOUND?-002 TRUE) (CL:RETURN))))
       (CL:WHEN FOUND?-002
        (CL:RETURN-FROM REMOVE-TRUE-AND-FALSE
         (CL:VALUES SYM-PROPOSITIONS-STELLA-TRUE TRUE)))))
     ((CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-STELLA-NOT)
      (CL:LET* ((TEST-VALUE-002 (%%VALUE (%%REST TREE))))
       (CL:COND
        ((CL:EQ TEST-VALUE-002 SYM-PROPOSITIONS-STELLA-TRUE)
         (CL:RETURN-FROM REMOVE-TRUE-AND-FALSE
          (CL:VALUES SYM-PROPOSITIONS-STELLA-FALSE TRUE)))
        ((CL:EQ TEST-VALUE-002 SYM-PROPOSITIONS-STELLA-FALSE)
         (CL:RETURN-FROM REMOVE-TRUE-AND-FALSE
          (CL:VALUES SYM-PROPOSITIONS-STELLA-TRUE FALSE)))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-002
           "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
     (CL:T
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" TEST-VALUE-001
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
   (CL:VALUES (CANONICALIZE-PROPOSITION-TREE TREE) TRUE)))

;;; (DEFUN (FLATTEN-NESTED-OPERATORS OBJECT BOOLEAN) ...)

(CL:DEFUN FLATTEN-NESTED-OPERATORS (TREE)
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:LET* ((FOUND?-000 FALSE))
    (CL:LET* ((ARG NULL) (ITER-000 (%%REST TREE)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (CL:WHEN (CL:AND (CONS? ARG) (EQL? (%%VALUE ARG) (%%VALUE TREE)))
       (CL:SETQ FOUND?-000 TRUE) (CL:RETURN))))
    (CL:SETQ TEST-VALUE-000 FOUND?-000))
   (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
   (CL:WHEN TEST-VALUE-000
    (CL:RETURN-FROM FLATTEN-NESTED-OPERATORS (CL:VALUES TREE FALSE))))
  (CL:LET* ((TARGETOPERATOR (%%VALUE TREE)) (TAIL (%%REST TREE)))
   (CL:LOOP
    (CL:WHEN
     (CL:AND (CONS? (%%VALUE TAIL))
      (CL:EQ (%%VALUE (%%VALUE TAIL)) TARGETOPERATOR))
     (CL:LET* ((NESTEDARGS (%%REST (%%VALUE TAIL))))
      (CL:COND
       ((CL:EQ NESTEDARGS NIL)
        (CL:COND
         ((CL:EQ TARGETOPERATOR SYM-PROPOSITIONS-STELLA-AND)
          (CL:SETF (%%VALUE TAIL) SYM-PROPOSITIONS-STELLA-TRUE))
         ((CL:EQ TARGETOPERATOR SYM-PROPOSITIONS-STELLA-OR)
          (CL:SETF (%%VALUE TAIL) SYM-PROPOSITIONS-LOGIC-FALS))
         (CL:T
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TARGETOPERATOR
            "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
       ((CL:EQ (%%REST NESTEDARGS) NIL)
        (CL:SETF (%%VALUE TAIL) (%%VALUE NESTEDARGS)))
       (CL:T (CL:SETF (%%VALUE TAIL) (%%VALUE NESTEDARGS))
        (CL:SETF (%%REST (LAST-CONS NESTEDARGS)) (%%REST TAIL))
        (CL:SETF (%%REST TAIL) (%%REST NESTEDARGS))))))
    (CL:SETQ TAIL (%%REST TAIL)) (CL:WHEN (CL:EQ TAIL NIL) (CL:RETURN)))
   (CL:VALUES (CANONICALIZE-PROPOSITION-TREE TREE) TRUE)))

;;; (DEFUN (CANONICALIZE-AND-OR-TREE OBJECT) ...)

(CL:DEFUN CANONICALIZE-AND-OR-TREE (TREE)
  (CL:LET*
   ((OPERATOR (%%VALUE TREE)) (ARGCOUNT (LENGTH (%%REST TREE)))
    (CANONICAL? FALSE) (RESULTTREE NULL) (ARG NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARGCOUNT))
   (CL:MULTIPLE-VALUE-SETQ (RESULTTREE CANONICAL?)
    (REMOVE-TRUE-AND-FALSE TREE))
   (CL:IF CANONICAL? (CL:RETURN-FROM CANONICALIZE-AND-OR-TREE RESULTTREE)
    (CL:SETQ TREE RESULTTREE))
   (CL:COND
    ((CL:> ARGCOUNT 1)
     (CL:MULTIPLE-VALUE-SETQ (RESULTTREE CANONICAL?)
      (FLATTEN-NESTED-OPERATORS TREE))
     RESULTTREE)
    ((CL:= ARGCOUNT 1) (CL:SETQ ARG (%%VALUE (%%REST TREE)))
     (CANONICALIZE-PROPOSITION-TREE ARG))
    (CL:T
     (CL:COND
      ((CL:EQ OPERATOR SYM-PROPOSITIONS-STELLA-AND)
       SYM-PROPOSITIONS-STELLA-TRUE)
      ((CL:EQ OPERATOR SYM-PROPOSITIONS-STELLA-OR)
       SYM-PROPOSITIONS-STELLA-FALSE)
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" OPERATOR
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))))

;;; (DEFUN (CANONICALIZE-NEGATION-TREE OBJECT) ...)

(CL:DEFUN CANONICALIZE-NEGATION-TREE (TREE)
  (CL:LET*
   ((ARGUMENT (%%VALUE (%%REST TREE)))
    (NESTEDOPERATOR (%%VALUE ARGUMENT)))
   (CL:COND
    ((CL:EQ NESTEDOPERATOR SYM-PROPOSITIONS-STELLA-NOT)
     (CL:RETURN-FROM CANONICALIZE-NEGATION-TREE
      (CANONICALIZE-PROPOSITION-TREE (%%VALUE (%%REST ARGUMENT)))))
    ((CL:OR (CL:EQ NESTEDOPERATOR SYM-PROPOSITIONS-STELLA-AND)
      (CL:EQ NESTEDOPERATOR SYM-PROPOSITIONS-STELLA-OR))
     (CL:LET* ((IT (ALLOCATE-ITERATOR (%%REST ARGUMENT))))
      (CL:LOOP WHILE (NEXT? IT) DO
       (VALUE-SETTER IT
        (LIST* SYM-PROPOSITIONS-STELLA-NOT (%VALUE IT) NIL))))
     (CL:COND
      ((CL:EQ NESTEDOPERATOR SYM-PROPOSITIONS-STELLA-AND)
       (FIRST-SETTER ARGUMENT SYM-PROPOSITIONS-STELLA-OR))
      ((CL:EQ NESTEDOPERATOR SYM-PROPOSITIONS-STELLA-OR)
       (FIRST-SETTER ARGUMENT SYM-PROPOSITIONS-STELLA-AND))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" NESTEDOPERATOR
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    ((CL:EQ NESTEDOPERATOR SYM-PROPOSITIONS-STELLA-EXISTS)
     (CL:LET* ((WHERECLAUSE (%%VALUE (%%REST (%%REST ARGUMENT)))))
      (CL:RETURN-FROM CANONICALIZE-NEGATION-TREE
       (CANONICALIZE-PROPOSITION-TREE
        (LIST* SYM-PROPOSITIONS-STELLA-FORALL (%%VALUE (%%REST ARGUMENT))
         (LIST* SYM-PROPOSITIONS-STELLA-TRUE
          (LIST* SYM-PROPOSITIONS-STELLA-NOT WHERECLAUSE NIL) NIL))))))
    ((CL:EQ NESTEDOPERATOR SYM-PROPOSITIONS-STELLA-FORALL)
     (CL:LET*
      ((WHERECLAUSE (%%VALUE (%%REST (%%REST ARGUMENT))))
       (ALWAYSCLAUSE (FOURTH ARGUMENT)))
      (CL:RETURN-FROM CANONICALIZE-NEGATION-TREE
       (CANONICALIZE-PROPOSITION-TREE
        (LIST* SYM-PROPOSITIONS-STELLA-EXISTS (%%VALUE (%%REST ARGUMENT))
         (CONS
          (LIST* SYM-PROPOSITIONS-STELLA-AND WHERECLAUSE
           (CONS (LIST* SYM-PROPOSITIONS-STELLA-NOT ALWAYSCLAUSE NIL)
            NIL))
          NIL))))))
    (CL:T (CL:RETURN-FROM CANONICALIZE-NEGATION-TREE TREE)))
   (CANONICALIZE-PROPOSITION-TREE ARGUMENT)))

;;; (DEFUN (QUANTIFIER-SYMBOL? BOOLEAN) ...)

(CL:DEFUN QUANTIFIER-SYMBOL? (SELF)
  (CL:OR (CL:EQ SELF SYM-PROPOSITIONS-STELLA-EXISTS)
   (CL:EQ SELF SYM-PROPOSITIONS-STELLA-FORALL)
   (CL:EQ SELF SYM-PROPOSITIONS-LOGIC-SETOFALL)
   (CL:EQ SELF SYM-PROPOSITIONS-LOGIC-THE-ONLY)
   (CL:EQ SELF SYM-PROPOSITIONS-LOGIC-KAPPA)
   (CL:EQ SELF SYM-PROPOSITIONS-STELLA-SOME)))

;;; (DEFUN (ALL-VARIABLES-GOAL? BOOLEAN) ...)

(CL:DEFUN ALL-VARIABLES-GOAL? (TREE)
  (CL:WHEN (CL:NOT (CONS? TREE))
   (CL:RETURN-FROM ALL-VARIABLES-GOAL? FALSE))
  (CL:LET* ((GOAL TREE) (OPERATOR (%%VALUE GOAL)))
   (CL:LET* ((TEST-VALUE-000 FALSE))
    (CL:SETQ TEST-VALUE-000 (SYMBOL? OPERATOR))
    (CL:WHEN TEST-VALUE-000
     (CL:SETQ TEST-VALUE-000
      (CL:NOT (MEMBER? *KIF-SENTENCE-OPERATORS* OPERATOR)))
     (CL:WHEN TEST-VALUE-000
      (CL:LET* ((ALWAYS?-000 TRUE))
       (CL:LET* ((ARG NULL) (ITER-000 (%%REST GOAL)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:PROGN (CL:SETQ ARG (%%VALUE ITER-000))
          (CL:SETQ ITER-000 (%%REST ITER-000)))
         (CL:WHEN (CL:NOT (QUESTION-MARK-SYMBOL? ARG))
          (CL:SETQ ALWAYS?-000 FALSE) (CL:RETURN))))
       (CL:SETQ TEST-VALUE-000 ALWAYS?-000))))
    (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000))))

;;; (DEFUN (EQUAL-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN EQUAL-ARGUMENTS? (GOAL1 GOAL2)
  (CL:LET* ((TEST-VALUE-000 FALSE))
   (CL:LET* ((ALWAYS?-000 TRUE))
    (CL:LET*
     ((ARG2 NULL) (ARG1 NULL) (ITER-000 (%%REST GOAL1))
      (ITER-001 (%%REST GOAL2)))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:NOT (CL:EQ ITER-001 NIL)))
      DO
      (CL:PROGN (CL:SETQ ARG1 (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (CL:PROGN (CL:SETQ ARG2 (%%VALUE ITER-001))
       (CL:SETQ ITER-001 (%%REST ITER-001)))
      (CL:WHEN (CL:NOT (EQL? ARG1 ARG2)) (CL:SETQ ALWAYS?-000 FALSE)
       (CL:RETURN))))
    (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000 (CL:= (LENGTH GOAL1) (LENGTH GOAL2))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (EXPLODE-FORALL-TREE CONS) ...)

(CL:DEFUN EXPLODE-FORALL-TREE (TREE)
  (CL:LET*
   ((ANTECEDENT (%%VALUE (%%REST (%%REST TREE))))
    (CONSEQUENT (FOURTH TREE)))
   (CL:WHEN
    (CL:OR (CL:NOT (ALL-VARIABLES-GOAL? ANTECEDENT))
     (CL:NOT (CONS? CONSEQUENT))
     (CL:NOT (CL:EQ (%%VALUE CONSEQUENT) SYM-PROPOSITIONS-STELLA-AND)))
    (CL:RETURN-FROM EXPLODE-FORALL-TREE TREE))
   (CL:LET* ((ANTECEDENTGOAL ANTECEDENT) (CONJUNCTS (%%REST CONSEQUENT)))
    (CL:LET* ((V-029 NIL))
     (CL:LET* ((GOAL NULL) (ITER-000 CONJUNCTS) (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ GOAL (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (CL:WHEN
        (CL:AND (ALL-VARIABLES-GOAL? GOAL)
         (EQUAL-ARGUMENTS? GOAL ANTECEDENTGOAL))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS GOAL NIL))
          (CL:IF (CL:EQ V-029 NIL) (CL:SETQ V-029 COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST V-029 COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS GOAL NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
     (CL:LET*
      ((MATCHINGGOALS V-029)
       (OTHERGOALS (DIFFERENCE CONJUNCTS MATCHINGGOALS)) (RULES NIL))
      (CL:WHEN (CL:EQ MATCHINGGOALS NIL)
       (CL:RETURN-FROM EXPLODE-FORALL-TREE TREE))
      (CL:LET* ((G NULL) (ITER-001 MATCHINGGOALS))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:PROGN (CL:SETQ G (%%VALUE ITER-001))
         (CL:SETQ ITER-001 (%%REST ITER-001)))
        (CL:SETQ RULES
         (CONS
          (COPY-CONS-TREE
           (LIST* SYM-PROPOSITIONS-STELLA-FORALL (%%VALUE (%%REST TREE))
            (CONS ANTECEDENTGOAL (CONS G NIL))))
          RULES))))
      (CL:WHEN (CL:NOT (CL:EQ OTHERGOALS NIL))
       (CL:SETQ RULES
        (CONS
         (LIST* SYM-PROPOSITIONS-STELLA-FORALL (%%VALUE (%%REST TREE))
          (CONS ANTECEDENTGOAL
           (CONS
            (CONS SYM-PROPOSITIONS-STELLA-AND
             (CONCATENATE OTHERGOALS NIL))
            NIL)))
         RULES)))
      (CANONICALIZE-PROPOSITION-TREE
       (CONS SYM-PROPOSITIONS-STELLA-AND (CONCATENATE RULES NIL))))))))

;;; (DEFUN (CANONICALIZE-QUANTIFICATION-TREE CONS) ...)

(CL:DEFUN CANONICALIZE-QUANTIFICATION-TREE (TREE)
  (CL:LET*
   ((WHERECLAUSE (%%VALUE (%%REST (%%REST TREE))))
    (ALWAYSCLAUSE (FOURTH TREE)))
   (CL:IF (CL:NOT (CL:EQ WHERECLAUSE NULL))
    (THIRD-SETTER TREE (CANONICALIZE-PROPOSITION-TREE WHERECLAUSE))
    (CONCATENATE TREE (CONS SYM-PROPOSITIONS-STELLA-TRUE NIL)))
   (CL:WHEN (CL:NOT (CL:EQ ALWAYSCLAUSE NULL))
    (FOURTH-SETTER TREE (CANONICALIZE-PROPOSITION-TREE ALWAYSCLAUSE)))
   (CL:COND
    ((CL:EQ (%%VALUE TREE) SYM-PROPOSITIONS-STELLA-FORALL)
     (EXPLODE-FORALL-TREE TREE))
    (CL:T TREE))))

;;; (DEFUN (CONS.CANONICALIZE-PROPOSITION-TREE OBJECT) ...)

(CL:DEFUN CONS.CANONICALIZE-PROPOSITION-TREE (TREE)
  (CL:LET* ((OPERATOR (%%VALUE TREE)))
   (CL:WHEN (QUANTIFIER-SYMBOL? OPERATOR)
    (CL:RETURN-FROM CONS.CANONICALIZE-PROPOSITION-TREE
     (CANONICALIZE-QUANTIFICATION-TREE TREE)))
   (CL:LET* ((IT (ALLOCATE-ITERATOR (%%REST TREE))))
    (CL:LOOP WHILE (NEXT? IT) DO
     (VALUE-SETTER IT (CANONICALIZE-PROPOSITION-TREE (%VALUE IT)))))
   (CL:COND
    ((CL:OR (CL:EQ OPERATOR SYM-PROPOSITIONS-STELLA-AND)
      (CL:EQ OPERATOR SYM-PROPOSITIONS-STELLA-OR))
     (CL:RETURN-FROM CONS.CANONICALIZE-PROPOSITION-TREE
      (CANONICALIZE-AND-OR-TREE TREE)))
    ((CL:EQ OPERATOR SYM-PROPOSITIONS-STELLA-NOT)
     (CL:LET* ((ARG (%%VALUE (%%REST TREE))))
      (CL:WHEN (CONS? ARG)
       (CL:RETURN-FROM CONS.CANONICALIZE-PROPOSITION-TREE
        (CANONICALIZE-NEGATION-TREE TREE)))
      (CL:LET* ((TEST-VALUE-000 ARG))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-TRUE)
         (CL:RETURN-FROM CONS.CANONICALIZE-PROPOSITION-TREE
          SGT-PROPOSITIONS-STELLA-FALSE))
        ((CL:EQ TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-FALSE)
         (CL:RETURN-FROM CONS.CANONICALIZE-PROPOSITION-TREE
          SGT-PROPOSITIONS-STELLA-TRUE))
        (CL:T
         (CL:RETURN-FROM CONS.CANONICALIZE-PROPOSITION-TREE TREE))))))
    (CL:T))
   TREE))

;;; (DEFUN (CANONICALIZE-PROPOSITION-TREE OBJECT) ...)

(CL:DEFUN CANONICALIZE-PROPOSITION-TREE (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-PROPOSITIONS-STELLA-CONS)
    (CL:PROGN (CONS.CANONICALIZE-PROPOSITION-TREE TREE)))
   (CL:T TREE)))

;;; (DEFUN ERASE-PROPOSITION ...)

(CL:DEFUN ERASE-PROPOSITION (PROPOSITION)
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:PROGN
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
    (CL:WHEN (CL:NOT (CL:EQ ARG NULL))
     (REMOVE-DEPENDENT-PROPOSITION-LINK ARG PROPOSITION))))
  (FREE (%ARGUMENTS PROPOSITION))
  (CL:SETF (%ARGUMENTS PROPOSITION) NULL)
  (DELETED?-SETTER PROPOSITION TRUE))

;;; (DEFUN (UPDATE-EQUIVALENCE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN UPDATE-EQUIVALENCE-PROPOSITION (PROPOSITION UPDATEMODE)
  (CL:LET*
   ((TERM1
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 0))
    (TERM2
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 1)))
   (CL:WHEN (CL:AND (SKOLEM? TERM1) (SKOLEM? TERM2))
    (CL:WHEN (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-TRUE)
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
        "ERROR: Equating two skolems by default is not yet supported." EOL
        "." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PROPOSITIONS-ERROR))
      (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
    (CL:RETURN-FROM UPDATE-EQUIVALENCE-PROPOSITION PROPOSITION))
   (CL:COND
    ((CL:OR (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
      (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-TRUE))
     (UPDATE-PROPOSITION-TRUTH-VALUE PROPOSITION UPDATEMODE)
     (CL:COND ((CLIP-VALUE? TERM1 TERM2)) ((CLIP-VALUE? TERM2 TERM1))
      (CL:T (EQUATE-VALUES (VALUE-OF TERM1) (VALUE-OF TERM2)))))
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
     (CL:COND ((UNEQUATE-VALUES? TERM1 TERM2))
      ((UNEQUATE-VALUES? TERM2 TERM1))))
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-CONCEIVE)
     (CL:RETURN-FROM UPDATE-EQUIVALENCE-PROPOSITION PROPOSITION))
    (CL:T
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" UPDATEMODE
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))
   (CL:WHEN
    (CL:AND (FUNCTION-OUTPUT-SKOLEM? TERM1)
     (CL:NOT (FUNCTION-OUTPUT-SKOLEM? TERM2)))
    (CL:RETURN-FROM UPDATE-EQUIVALENCE-PROPOSITION
     (%DEFINING-PROPOSITION TERM1)))
   (CL:WHEN
    (CL:AND (FUNCTION-OUTPUT-SKOLEM? TERM2)
     (CL:NOT (FUNCTION-OUTPUT-SKOLEM? TERM1)))
    (CL:RETURN-FROM UPDATE-EQUIVALENCE-PROPOSITION
     (%DEFINING-PROPOSITION TERM2)))
   NULL))

;;; (DEFUN (SKOLEMIZE-EXISTS-PROPOSITION PROPOSITION) ...)

(CL:DEFUN SKOLEMIZE-EXISTS-PROPOSITION (EXISTSPROPOSITION)
  (CL:LET* ((MAPPING (NEW-KEY-VALUE-LIST)) (SKOLEMIZEDPROPOSITION NULL))
   (CL:LET*
    ((VAR NULL)
     (VECTOR-000
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS EXISTSPROPOSITION)
       SYM-PROPOSITIONS-LOGIC-IO-VARIABLES NULL))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ VAR
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CREATE-SKOLEM-FOR-UNMAPPED-VARIABLE VAR MAPPING)))
   (CL:SETQ SKOLEMIZEDPROPOSITION
    (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS
     (INHERIT-PROPOSITION
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%THE-ARRAY (%ARGUMENTS EXISTSPROPOSITION)))
       0)
      MAPPING)
     FALSE))
   (ERASE-PROPOSITION EXISTSPROPOSITION) SKOLEMIZEDPROPOSITION))

;;; (DEFUN (HELP-UPDATE-TOP-LEVEL-PROPOSITION (CONS OF PROPOSITION)) ...)

(CL:DEFUN HELP-UPDATE-TOP-LEVEL-PROPOSITION (PROPOSITION UPDATEMODE)
  (CL:WHEN (CL:EQ PROPOSITION NULL)
   (CL:RETURN-FROM HELP-UPDATE-TOP-LEVEL-PROPOSITION NULL))
  (CL:WHEN (NATIVE-SLOT-PROPOSITION? PROPOSITION)
   (CL:RETURN-FROM HELP-UPDATE-TOP-LEVEL-PROPOSITION
    (UPDATE-NATIVE-SLOT-PROPOSITION PROPOSITION UPDATEMODE)))
  (CL:LET* ((*CONTEXT* (GET-TOP-LEVEL-UPDATE-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *CONTEXT*))
   (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-AND)
      (CL:LET* ((PROPOSITIONS NIL))
       (CL:LET*
        ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:PROGN
          (CL:SETQ ARG
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
         (CL:LET*
          ((P NULL)
           (ITER-000 (HELP-UPDATE-TOP-LEVEL-PROPOSITION ARG UPDATEMODE))
           (COLLECT-000 NULL))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
           (CL:PROGN (CL:SETQ P (%%VALUE ITER-000))
            (CL:SETQ ITER-000 (%%REST ITER-000)))
           (CL:IF (CL:EQ COLLECT-000 NULL)
            (CL:PROGN (CL:SETQ COLLECT-000 (CONS P NIL))
             (CL:IF (CL:EQ PROPOSITIONS NIL)
              (CL:SETQ PROPOSITIONS COLLECT-000)
              (ADD-CONS-TO-END-OF-CONS-LIST PROPOSITIONS COLLECT-000)))
            (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS P NIL))
             (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))))
       (ERASE-PROPOSITION PROPOSITION)
       (CL:RETURN-FROM HELP-UPDATE-TOP-LEVEL-PROPOSITION PROPOSITIONS)))
     ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-EQUIVALENT)
      (CL:SETQ PROPOSITION
       (UPDATE-EQUIVALENCE-PROPOSITION PROPOSITION UPDATEMODE))
      (CL:WHEN (CL:EQ PROPOSITION NULL)
       (CL:RETURN-FROM HELP-UPDATE-TOP-LEVEL-PROPOSITION NULL)))
     ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-NOT)
      (CL:LET*
       ((ARGUMENT
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          0)))
       (CL:COND
        ((CL:OR (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
          (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
          (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-TRUE)
          (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-FALSE)
          (CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
          (CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-FALSE))
         (UPDATE-PROPOSITION-TRUTH-VALUE ARGUMENT
          (INVERT-UPDATE-MODE UPDATEMODE))
         (ERASE-PROPOSITION PROPOSITION)
         (CL:RETURN-FROM HELP-UPDATE-TOP-LEVEL-PROPOSITION
          (CONS-LIST ARGUMENT)))
        (CL:T))))
     ((CL:EQ TEST-VALUE-000 KWD-PROPOSITIONS-EXISTS)
      (CL:RETURN-FROM HELP-UPDATE-TOP-LEVEL-PROPOSITION
       (HELP-UPDATE-TOP-LEVEL-PROPOSITION
        (SKOLEMIZE-EXISTS-PROPOSITION PROPOSITION) UPDATEMODE)))
     (CL:T)))
   (CL:WHEN (CL:NOT (CL:EQ (%KIND PROPOSITION) KWD-PROPOSITIONS-FUNCTION))
    (UPDATE-PROPOSITION-TRUTH-VALUE PROPOSITION UPDATEMODE))
   (CONS-LIST PROPOSITION)))

;;; (DEFUN (INVERT-UPDATE-MODE KEYWORD) ...)

(CL:DEFUN INVERT-UPDATE-MODE (UPDATEMODE)
  (CL:COND
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
    KWD-PROPOSITIONS-ASSERT-FALSE)
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-TRUE)
    KWD-PROPOSITIONS-PRESUME-FALSE)
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
    KWD-PROPOSITIONS-RETRACT-FALSE)
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
    KWD-PROPOSITIONS-ASSERT-TRUE)
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-FALSE)
    KWD-PROPOSITIONS-PRESUME-TRUE)
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-FALSE)
    KWD-PROPOSITIONS-RETRACT-TRUE)
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" UPDATEMODE
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (UPDATE-TOP-LEVEL-PROPOSITION (CONS OF PROPOSITION)) ...)

(CL:DEFUN UPDATE-TOP-LEVEL-PROPOSITION (TREE UPDATEMODE)
  (CL:LET* ((CONFIDENCELEVEL NULL))
   (CL:LET* ((VALUE-000 NULL) (VALUE-001 NULL))
    (CL:MULTIPLE-VALUE-SETQ (VALUE-000 VALUE-001)
     (EXTRACT-DECORATION TREE SYM-PROPOSITIONS-LOGIC-CONFIDENCE-LEVEL))
    (CL:PROGN (CL:SETQ TREE VALUE-000)
     (CL:SETQ CONFIDENCELEVEL VALUE-001)))
   (CL:WHEN (CL:EQ CONFIDENCELEVEL SYM-PROPOSITIONS-STELLA-DEFAULT)
    (CL:COND
     ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
      (CL:SETQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-TRUE))
     ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
      (CL:SETQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-FALSE))
     (CL:T))))
  (CL:COND
   ((CL:OR (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
     (CL:EQ UPDATEMODE KWD-PROPOSITIONS-PRESUME-FALSE)
     (CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-FALSE))
    (CL:SETQ TREE (LIST* SYM-PROPOSITIONS-STELLA-NOT TREE NIL))
    (CL:SETQ UPDATEMODE (INVERT-UPDATE-MODE UPDATEMODE)))
   (CL:T))
  (CL:COND
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
    (CL:LET* ((*AUTOMATICINSTANCETABLE* NULL))
     (CL:DECLARE (CL:SPECIAL *AUTOMATICINSTANCETABLE*))
     (HELP-UPDATE-TOP-LEVEL-PROPOSITION
      (BUILD-TOP-LEVEL-PROPOSITION TREE TRUE) UPDATEMODE)))
   (CL:T
    (HELP-UPDATE-TOP-LEVEL-PROPOSITION
     (BUILD-TOP-LEVEL-PROPOSITION TREE FALSE) UPDATEMODE))))

;;; (DEFUN (UPDATE-PROPOSITION (CONS OF PROPOSITION)) ...)

(CL:DEFUN UPDATE-PROPOSITION (TREE UPDATEMODE)
  (CL:HANDLER-CASE
   (CL:COND
    ((SUBTYPE-OF-STRING? (SAFE-PRIMARY-TYPE TREE))
     (CL:PROGN
      (CL:RETURN-FROM UPDATE-PROPOSITION
       (UPDATE-PROPOSITION
        (READ-S-EXPRESSION-FROM-STRING (%WRAPPER-VALUE TREE))
        UPDATEMODE))))
    (CL:T
     (CL:LET* ((STANDARDIZEDTREE NULL) (PROPOSITIONS NULL))
      (CL:SETQ STANDARDIZEDTREE (STANDARDIZE-LOGICAL-PARSE-TREE TREE))
      (CL:WHEN (CONS? STANDARDIZEDTREE)
       (CL:SETQ STANDARDIZEDTREE
        (CANONICALIZE-PROPOSITION-TREE STANDARDIZEDTREE)))
      (CL:LET* ((*INHIBITRELATIONFINALIZATION?* TRUE))
       (CL:DECLARE (CL:SPECIAL *INHIBITRELATIONFINALIZATION?*))
       (CL:SETQ PROPOSITIONS
        (UPDATE-TOP-LEVEL-PROPOSITION STANDARDIZEDTREE UPDATEMODE)))
      (CL:RETURN-FROM UPDATE-PROPOSITION PROPOSITIONS))))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E)))
   (READ-EXCEPTION (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))))
  NULL)

;;; (DEFUN (BUILD-TOP-LEVEL-TERM OBJECT) ...)

(CL:DEFUN BUILD-TOP-LEVEL-TERM (TREE)
  (CL:LET* ((TERM NULL))
   (CL:LET*
    ((*LOGICVARIABLETABLE* NIL) (*VARIABLEIDCOUNTER* 0)
     (*TERMUNDERCONSTRUCTION* TREE))
    (CL:DECLARE
     (CL:SPECIAL *LOGICVARIABLETABLE* *VARIABLEIDCOUNTER*
      *TERMUNDERCONSTRUCTION*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *VARIABLEIDCOUNTER*))
    (CL:COND
     ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-PROPOSITIONS-STELLA-CONS)
      (CL:PROGN
       (CL:WHEN
        (MEMBER?
         (GET-QUOTED-TREE
          "((FORALL EXISTS IMPLIES AND OR NOT) \"/LOGIC\")" "/LOGIC")
         (%%VALUE TREE))
        (CL:WARN "Sentence where term expected: `~A'~%" TREE)
        (CL:RETURN-FROM BUILD-TOP-LEVEL-TERM NULL))))
     (CL:T))
    (CL:SETQ TERM (EVALUATE-TERM TREE)))
   TERM))

;;; (DEFUN (CONCEIVE-TERM OBJECT) ...)

(CL:DEFUN CONCEIVE-TERM (TREE)
  "tree' is a term expression (a string or an s-expression),
or is a class reference (a symbol or surrogate).  Return a (possibly 
newly-conceived) term representing the internalized representation of that term."
  (CL:HANDLER-CASE
   (CL:COND
    ((SUBTYPE-OF-STRING? (SAFE-PRIMARY-TYPE TREE))
     (CL:PROGN
      (CL:RETURN-FROM CONCEIVE-TERM
       (CONCEIVE-TERM
        (READ-S-EXPRESSION-FROM-STRING (%WRAPPER-VALUE TREE))))))
    (CL:T
     (CL:LET* ((STANDARDIZEDTREE NULL) (OPERATOR NULL) (TERM NULL))
      (CL:SETQ STANDARDIZEDTREE (STANDARDIZE-LOGICAL-PARSE-TREE TREE))
      (CL:WHEN (CONS? STANDARDIZEDTREE)
       (CL:SETQ STANDARDIZEDTREE
        (CANONICALIZE-PROPOSITION-TREE STANDARDIZEDTREE))
       (CL:WHEN (CONS? STANDARDIZEDTREE)
        (CL:SETQ OPERATOR (%%VALUE STANDARDIZEDTREE))))
      (CL:IF
       (CL:AND (CL:NOT (CL:EQ OPERATOR NULL))
        (CL:NOT (CL:EQ (GET-RELATION OPERATOR) NULL))
        (CL:NOT (FUNCTION? (GET-RELATION OPERATOR))))
       (CL:SETQ TERM (CONCEIVE-SENTENCE TREE))
       (CL:SETQ TERM (BUILD-TOP-LEVEL-TERM STANDARDIZEDTREE)))
      (CL:RETURN-FROM CONCEIVE-TERM TERM))))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E)))
   (READ-EXCEPTION (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))))
  NULL)

;;; (DEFUN (CONCEIVE-SENTENCE OBJECT) ...)

(CL:DEFUN CONCEIVE-SENTENCE (TREE)
  (CL:COND
   ((SUBTYPE-OF-STRING? (SAFE-PRIMARY-TYPE TREE))
    (CL:PROGN
     (CONCEIVE-SENTENCE
      (READ-S-EXPRESSION-FROM-STRING (%WRAPPER-VALUE TREE)))))
   (CL:T (SMART-UPDATE-PROPOSITION TREE KWD-PROPOSITIONS-CONCEIVE))))

;;; (DEFUN (CONCEIVE-FORMULA OBJECT) ...)

(CL:DEFUN CONCEIVE-FORMULA (TREE)
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((SUBTYPE-OF-STRING? TEST-VALUE-001)
     (CL:PROGN
      (CONCEIVE-FORMULA
       (READ-S-EXPRESSION-FROM-STRING (%WRAPPER-VALUE TREE)))))
    ((CL:EQ TEST-VALUE-001 SGT-PROPOSITIONS-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
       (CL:COND
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-KAPPA)
          (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-LAMBDA)
          (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-SETOFALL)
          (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-STELLA-SETOF)
          (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-PL-KERNEL-KB-LISTOF)
          (CL:EQ TEST-VALUE-000 SYM-PROPOSITIONS-LOGIC-BAGOF))
         (CONCEIVE-TERM TREE))
        (CL:T (CONCEIVE-SENTENCE TREE))))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001) (CL:PROGN (CONCEIVE-TERM TREE)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
     (CL:PROGN (CONCEIVE-TERM (SURROGATE-TO-SYMBOL TREE))))
    (CL:T (CONCEIVE-SENTENCE TREE)))))

;;; (DEFUN (SMART-UPDATE-PROPOSITION OBJECT) ...)

(CL:DEFUN SMART-UPDATE-PROPOSITION (TREE UPDATEMODE)
  (CL:LET* ((PROPOSITIONS (UPDATE-PROPOSITION TREE UPDATEMODE)))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ PROPOSITIONS NULL))
     (CL:EQ (%%REST PROPOSITIONS) NIL))
    (%%VALUE PROPOSITIONS) PROPOSITIONS)))

;;; (DEFUN (ASSERT OBJECT) ...)

(CL:DEFUN %ASSERT (PROPOSITION)
  "Assert the truth of `proposition'.  Return the asserted proposition object.
KIF example:  `(assert (happy Fred))' asserts that Fred is indeed happy.
Note, that for this assertion to succeed, the logic constant `Fred' must
already be defined, e.g., as a side-effect of a type assertion such as
`(assert (Person Fred))', and the relation (or slot) `happy' must be defined
on objects of `Fred's type, e.g., on the class `Person'."
  (SMART-UPDATE-PROPOSITION PROPOSITION KWD-PROPOSITIONS-ASSERT-TRUE))

(CL:DEFMACRO ASSERT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Assert the truth of `proposition'.  Return the asserted proposition object.
KIF example:  `(assert (happy Fred))' asserts that Fred is indeed happy.
Note, that for this assertion to succeed, the logic constant `Fred' must
already be defined, e.g., as a side-effect of a type assertion such as
`(assert (Person Fred))', and the relation (or slot) `happy' must be defined
on objects of `Fred's type, e.g., on the class `Person'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/ASSERT)) (CL:MACRO-FUNCTION (CL:QUOTE ASSERT)))

;;; (DEFUN (PRESUME OBJECT) ...)

(CL:DEFUN %PRESUME (PROPOSITION)
  "Presume the default truth of `proposition'.  Return the presumed
proposition object.  KIF example:  `(presume (happy Fred))' states that Fred
is most probably happy.  Note, that for this to succeed, the logic constant
`Fred' and the relation (or slot) `happy' must already be defined (see
`assert')."
  (SMART-UPDATE-PROPOSITION PROPOSITION KWD-PROPOSITIONS-PRESUME-TRUE))

(CL:DEFMACRO PRESUME (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Presume the default truth of `proposition'.  Return the presumed
proposition object.  KIF example:  `(presume (happy Fred))' states that Fred
is most probably happy.  Note, that for this to succeed, the logic constant
`Fred' and the relation (or slot) `happy' must already be defined (see
`assert')."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/PRESUME)) (CL:MACRO-FUNCTION (CL:QUOTE PRESUME)))

;;; (DEFUN (RETRACT OBJECT) ...)

(CL:DEFUN %RETRACT (PROPOSITION)
  "Retract the truth of `proposition'.  Return the retracted proposition
object.  KIF example:  `(retract (happy Fred))' retracts that Fred is
happy.  Note, that for this to succeed, the logic constant `Fred' and the
relation (or slot) `happy' must already be defined (see `assert')."
  (SMART-UPDATE-PROPOSITION PROPOSITION KWD-PROPOSITIONS-RETRACT-TRUE))

(CL:DEFMACRO RETRACT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Retract the truth of `proposition'.  Return the retracted proposition
object.  KIF example:  `(retract (happy Fred))' retracts that Fred is
happy.  Note, that for this to succeed, the logic constant `Fred' and the
relation (or slot) `happy' must already be defined (see `assert')."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/RETRACT)) (CL:MACRO-FUNCTION (CL:QUOTE RETRACT)))

;;; (DEFUN (DENY OBJECT) ...)

(CL:DEFUN %DENY (PROPOSITION)
  "Assert the falsity of `proposition'.  Return the asserted proposition
object.  KIF example:  `(deny (happy Fred))' asserts that Fred is not happy,
which could have been done equivalently by `(assert (not (happy Fred)))'.
Note, that for this to succeed, the logic constant `Fred' and the
relation (or slot) `happy' must already be defined (see `assert')."
  (SMART-UPDATE-PROPOSITION PROPOSITION KWD-PROPOSITIONS-ASSERT-FALSE))

(CL:DEFMACRO DENY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Assert the falsity of `proposition'.  Return the asserted proposition
object.  KIF example:  `(deny (happy Fred))' asserts that Fred is not happy,
which could have been done equivalently by `(assert (not (happy Fred)))'.
Note, that for this to succeed, the logic constant `Fred' and the
relation (or slot) `happy' must already be defined (see `assert')."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/DENY)) (CL:MACRO-FUNCTION (CL:QUOTE DENY)))

;;; (DEFUN (CONCEIVE OBJECT) ...)

(CL:DEFUN %CONCEIVE (FORMULA)
  "Guess whether 'formula' represents a term or a sentence/proposition.
If we are not sure, assume its a proposition.
If its, a term, return its internal representation.  If a proposition,
Build 'formula' without asserting its truth value.  Return the
conceived proposition object.  KIF example: `(conceive (happy Fred))' builds
the proposition expressing that Fred is happy without explictly asserting or
denying it.  Note, that for this to succeed, the logic constant `Fred' and
the relation (or slot) `happy' must already be defined (see `assert')."
  (CONCEIVE-FORMULA FORMULA))

(CL:DEFMACRO CONCEIVE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Guess whether 'formula' represents a term or a sentence/proposition.
If we are not sure, assume its a proposition.
If its, a term, return its internal representation.  If a proposition,
Build 'formula' without asserting its truth value.  Return the
conceived proposition object.  KIF example: `(conceive (happy Fred))' builds
the proposition expressing that Fred is happy without explictly asserting or
denying it.  Note, that for this to succeed, the logic constant `Fred' and
the relation (or slot) `happy' must already be defined (see `assert')."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/CONCEIVE)) (CL:MACRO-FUNCTION (CL:QUOTE CONCEIVE)))

;;; (DEFUN UNASSERT ...)

(CL:DEFUN %UNASSERT (PROPOSITION)
  "Retract the truth or falsity of `proposition'.  This is a more general
version of `retract' that also handles falsity."
  (UNASSERT-FACT (BUILD-TOP-LEVEL-PROPOSITION PROPOSITION FALSE)))

(CL:DEFMACRO UNASSERT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Retract the truth or falsity of `proposition'.  This is a more general
version of `retract' that also handles falsity."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/UNASSERT)) (CL:MACRO-FUNCTION (CL:QUOTE UNASSERT)))

;;; (DEFUN UNASSERT-FACT ...)

(CL:DEFUN UNASSERT-FACT (SELF)
  "Retract the truth or falsity of the proposition 'self'"
  (CL:WHEN (CL:NOT (CL:EQ SELF NULL))
   (CL:COND
    ((CL:EQ (%KIND SELF) KWD-PROPOSITIONS-FUNCTION)
     (CL:LET*
      ((OUTPUTSKOLEM
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
         (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS SELF)))))))
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (ACCESS-IN-CONTEXT (%VARIABLE-VALUE OUTPUTSKOLEM)
          (%HOME-CONTEXT OUTPUTSKOLEM) FALSE)
         NULL))
       (UNEQUATE-VALUES? OUTPUTSKOLEM
        (ACCESS-IN-CONTEXT (%VARIABLE-VALUE OUTPUTSKOLEM)
         (%HOME-CONTEXT OUTPUTSKOLEM) FALSE)))))
    ((TRUE? SELF)
     (UPDATE-PROPOSITION-TRUTH-VALUE SELF KWD-PROPOSITIONS-RETRACT-TRUE))
    ((FALSE? SELF)
     (UPDATE-PROPOSITION-TRUTH-VALUE SELF
      KWD-PROPOSITIONS-RETRACT-FALSE)))))

;;; (DEFMETHOD (DELETED? BOOLEAN) ...)

(CL:DEFMETHOD DELETED? ((SELF PROPOSITION))
  (DELETED-PROPOSITION? SELF))

;;; (DEFMETHOD (DELETED?-SETTER BOOLEAN) ...)

(CL:DEFMETHOD DELETED?-SETTER ((SELF PROPOSITION) VALUE)
  (CL:WHEN VALUE (CL:SETF (%KIND SELF) KWD-PROPOSITIONS-DELETED))
  VALUE)

;;; (DEFUN (DELETED-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN DELETED-PROPOSITION? (SELF)
  (CL:WHEN (CL:EQ (%KIND SELF) KWD-PROPOSITIONS-DELETED)
   (CL:RETURN-FROM DELETED-PROPOSITION? TRUE))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ (%HOME-CONTEXT SELF) NULL))
    (DELETED? (%HOME-CONTEXT SELF)))
   (CL:SETF (%HOME-CONTEXT SELF) NULL) (DESTROY-PROPOSITION SELF)
   (CL:RETURN-FROM DELETED-PROPOSITION? TRUE))
  FALSE)

;;; (DEFUN (DESTROY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN DESTROY-PROPOSITION (PROPOSITION)
  "Retract and destroy the proposition 'proposition'.
Recursively destroy all propositions that reference 'proposition'.
Also, destroy all satellite propositions of 'proposition'."
  (CL:WHEN (DELETED? PROPOSITION)
   (CL:RETURN-FROM DESTROY-PROPOSITION PROPOSITION))
  (DELETED?-SETTER PROPOSITION TRUE)
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-STELLA-SURROGATE-VALUE-INVERSE NULL)
     NULL))
   (CL:SETF
    (%SURROGATE-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-STELLA-SURROGATE-VALUE-INVERSE NULL))
    NULL))
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:PROGN
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
    (CL:WHEN (CL:AND (CL:NOT (CL:EQ ARG NULL)) (CL:NOT (DELETED? ARG)))
     (CL:WHEN
      (CL:AND (SKOLEM? ARG)
       (CL:EQ (%DEFINING-PROPOSITION ARG) PROPOSITION))
      (DESTROY-TERM ARG))
     (REMOVE-DEPENDENT-PROPOSITION-LINK ARG PROPOSITION))))
  (CL:LET*
   ((DEP NULL)
    (ITER-000
     (ALLOCATE-ITERATOR (COPY (%DEPENDENT-PROPOSITIONS PROPOSITION)))))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ DEP (%VALUE ITER-000))
    (DESTROY-PROPOSITION DEP)))
  (CL:LET*
   ((SATELLITE NULL)
    (ITER-001
     (%THE-CONS-LIST (COPY (SATELLITE-PROPOSITIONS PROPOSITION)))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:PROGN (CL:SETQ SATELLITE (%%VALUE ITER-001))
     (CL:SETQ ITER-001 (%%REST ITER-001)))
    (DESTROY-PROPOSITION SATELLITE)))
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-LOGIC-MASTER-PROPOSITION NULL)
     NULL))
   (REMOVE
    (SATELLITE-PROPOSITIONS
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
      SYM-PROPOSITIONS-LOGIC-MASTER-PROPOSITION NULL))
    PROPOSITION))
  (CL:WHEN (CL:NOT (CL:EQ (%HOME-CONTEXT PROPOSITION) NULL))
   (HANDLE-OUT-OF-DATE-INFERENCE-CACHE KWD-PROPOSITIONS-RETRACT
    PROPOSITION))
  (CL:SETF (%DEPENDENT-PROPOSITIONS PROPOSITION) NULL)
  (CL:SETF (%OPERATOR PROPOSITION) NULL)
  (CL:SETF (%ARGUMENTS PROPOSITION) NULL)
  (CL:SETF (%HOME-CONTEXT PROPOSITION) NULL)
  (CL:SETF (%TRUTH-VALUE PROPOSITION) NULL)
  (CL:SETF (%DYNAMIC-SLOTS PROPOSITION) NULL)
  PROPOSITION)

;;; (DEFUN DESTROY-LOGIC-INSTANCE ...)

(CL:DEFUN DESTROY-LOGIC-INSTANCE (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:WHEN (CL:OR (CL:EQ SELF NULL) (DELETED? SELF))
       (CL:RETURN-FROM DESTROY-LOGIC-INSTANCE))
      (DELETED?-SETTER SELF TRUE)
      (CL:LET* ((SURROGATE (%SURROGATE-VALUE-INVERSE SELF)))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ SURROGATE NULL))
         (CL:EQ (%SURROGATE-VALUE SURROGATE) SELF))
        (CL:SETF (%SURROGATE-VALUE SURROGATE) NULL)))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-THING)
     (CL:PROGN
      (CL:WHEN (CL:OR (CL:EQ SELF NULL) (DELETED? SELF))
       (CL:RETURN-FROM DESTROY-LOGIC-INSTANCE))
      (DELETED?-SETTER SELF TRUE)
      (CL:LET* ((SURROGATE (%SURROGATE-VALUE-INVERSE SELF)))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ SURROGATE NULL))
         (CL:EQ (%SURROGATE-VALUE SURROGATE) SELF))
        (CL:SETF (%SURROGATE-VALUE SURROGATE) NULL)))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
  (CL:LET*
   ((P NULL)
    (ITER-000
     (ALLOCATE-ITERATOR (UNFILTERED-DEPENDENT-PROPOSITIONS SELF NULL))))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
    (DESTROY-PROPOSITION P)))
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
    (CL:PROGN
     (CL:LET* ((EQUIVALENT NULL) (ITER-001 (VARIABLE-VALUE-INVERSE SELF)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:PROGN (CL:SETQ EQUIVALENT (%%VALUE ITER-001))
        (CL:SETQ ITER-001 (%%REST ITER-001)))
       (CL:WHEN (CL:NOT (DELETED? EQUIVALENT))
        (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE EQUIVALENT)))
         (CL:COND
          ((SUBTYPE-OF? TEST-VALUE-001 SGT-PROPOSITIONS-LOGIC-SKOLEM)
           (CL:PROGN
            (CL:LET*
             ((OBJECT-000 EQUIVALENT) (VALUE-000 NULL)
              (OLD-VALUE-000 (%VARIABLE-VALUE OBJECT-000))
              (NEW-VALUE-000
               (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000
                (%HOME-CONTEXT OBJECT-000) FALSE)))
             (CL:WHEN
              (CL:NOT
               (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
                (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
                 SGT-PROPOSITIONS-STELLA-CS-VALUE)))
              (CL:SETF (%VARIABLE-VALUE OBJECT-000) NEW-VALUE-000)))))
          ((SUBTYPE-OF? TEST-VALUE-001
            SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
           (CL:PROGN
            (CL:LET*
             ((OBJECT-001 EQUIVALENT) (VALUE-001 NULL)
              (OLD-VALUE-001 (%EQUIVALENT-VALUE OBJECT-001))
              (NEW-VALUE-001
               (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001
                (%HOME-CONTEXT OBJECT-001) FALSE)))
             (CL:WHEN
              (CL:NOT
               (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
                (CL:EQ (PRIMARY-TYPE OLD-VALUE-001)
                 SGT-PROPOSITIONS-STELLA-CS-VALUE)))
              (CL:SETF (%EQUIVALENT-VALUE OBJECT-001) NEW-VALUE-001)))))
          (CL:T
           (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
            (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" TEST-VALUE-001
             "' is not a valid case option")
            (CL:ERROR
             (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))))
     (CL:LET*
      ((OBJECT-002 SELF) (VALUE-002 NULL)
       (OLD-VALUE-002 (%VARIABLE-VALUE-INVERSE OBJECT-002))
       (NEW-VALUE-002
        (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-002
         (%HOME-CONTEXT OBJECT-002) FALSE)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-002 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-002)
          SGT-PROPOSITIONS-STELLA-CS-VALUE)))
       (CL:SETF (%VARIABLE-VALUE-INVERSE OBJECT-002) NEW-VALUE-002)))))
   (CL:T)))

;;; (DEFUN DESTROY-TERM ...)

(CL:DEFUN DESTROY-TERM (SELF)
  "Destroy all propositions that reference 'self',
and mark it as 'deleted?', thereby making it invisible within class
extensions.  Unlink descriptions from native relations."
  (CL:WHEN (CL:OR (CL:EQ SELF NULL) (DELETED? SELF))
   (CL:RETURN-FROM DESTROY-TERM))
  (DESTROY-LOGIC-INSTANCE SELF)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-PROPOSITIONS-LOGIC-DESCRIPTION)
    (CL:PROGN
     (CL:COND
      ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
        SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION)
       (CL:PROGN
        (CL:LET* ((NATIVERELATION (NATIVE-RELATION SELF)))
         (NATIVE-RELATION-SETTER SELF NULL)
         (CL:WHEN (CL:NOT (CL:EQ NATIVERELATION NULL))
          (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NATIVERELATION)
           SYM-PROPOSITIONS-LOGIC-DESCRIPTION NULL NULL))
         (CL:WHEN (CL:NOT (CL:EQ (%EXTENSION SELF) NULL))
          (CL:SETF (%EXTENSION SELF) NULL)))))
      (CL:T))
     (CL:LET*
      ((COMPLEMENT
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-PROPOSITIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL)))
      (CL:WHEN (CL:NOT (CL:EQ COMPLEMENT NULL))
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS COMPLEMENT)
        SYM-PROPOSITIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL NULL)
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
        SYM-PROPOSITIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL NULL)))
     (REMOVE-ALL-DEPENDENT-PROPOSITION-LINKS SELF)
     (CL:SETF (%IO-VARIABLES SELF) NULL)
     (CL:SETF (%INTERNAL-VARIABLES SELF) NULL)
     (CL:SETF (%ROOT-TYPE SELF) NULL) (CL:SETF (%PROPOSITION SELF) NULL)
     (CL:SETF (%HOME-CONTEXT SELF) NULL)))
   (CL:T))
  (CLEAR (%DYNAMIC-SLOTS SELF))
  (DELETED?-SETTER SELF TRUE))

;;; (DEFUN DESTROY-INSTANCE ...)

(CL:DEFUN DESTROY-INSTANCE (SELF)
  "Destroy all propositions that reference 'self',
and mark it as 'deleted?', thereby making it invisible within class
extensions."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN (DESTROY-TERM SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPOSITIONS-STELLA-THING)
     (CL:PROGN (DESTROY-LOGIC-INSTANCE SELF)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (RELATION-IN-MODULE? BOOLEAN) ...)

(CL:DEFUN RELATION-IN-MODULE? (SELF)
  (CL:EQ (%HOME-CONTEXT SELF) *MODULE*))

;;; (DEFUN INTRODUCE-MODULE ...)

(CL:DEFUN INTRODUCE-MODULE (MODULE)
  (CL:SETF (%SURROGATE-VALUE-INVERSE MODULE) NULL)
  (CL:LET*
   ((*CONTEXT* *PL-KERNEL-MODULE*) (*MODULE* (%BASE-MODULE *CONTEXT*)))
   (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
   (CL:WHEN (CL:EQ (%SURROGATE-VALUE-INVERSE MODULE) NULL)
    (CL:LET* ((SUCCESS? FALSE) (UNUSED NULL) (SURROGATE NULL))
     (CL:MULTIPLE-VALUE-SETQ (SUCCESS? UNUSED SURROGATE)
      (BIND-TO-SURROGATE? MODULE (NAME MODULE) TRUE TRUE))
     (CL:WHEN SUCCESS?
      (CL:SETF (%SURROGATE-VALUE-INVERSE MODULE) SURROGATE))))
   (ASSERT-ISA-PROPOSITION MODULE SGT-PROPOSITIONS-STELLA-MODULE)))

;;; (DEFUN CLEAR-LOGIC-MODULE-HOOK ...)

(CL:DEFUN CLEAR-LOGIC-MODULE-HOOK (MODULE)
  (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (DESTROY-INFERENCE-CACHES MODULE) (FLUSH-INLINE-QUERY-CACHES)
   (CL:LET*
    ((TERM NULL)
     (ITER-000 (%THE-CONS-LIST (LISTIFY (ALL-TERMS MODULE TRUE)))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:PROGN (CL:SETQ TERM (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (DESTROY-INSTANCE TERM)))
   (CL:LET* ((PROPOSITION NULL) (ITER-001 (ALL-PROPOSITIONS MODULE TRUE)))
    (CL:LOOP WHILE (NEXT? ITER-001) DO
     (CL:SETQ PROPOSITION (%VALUE ITER-001))
     (DESTROY-PROPOSITION PROPOSITION)))
   (REMOVE-DELETED-MEMBERS (LOCALLY-CONCEIVED-PROPOSITIONS MODULE))
   (REMOVE-IF *UNFINALIZED-RELATIONS* (CL:FUNCTION RELATION-IN-MODULE?))
   (CLEANUP-ALL-DESCRIPTION-EXTENSIONS) (CLEAN-UP-PAGING-STORAGE MODULE)
   (CLEAR-MEMOIZATION-TABLES KWD-PROPOSITIONS-KB-UPDATE)
   (CLEAR-MEMOIZATION-TABLES KWD-PROPOSITIONS-META-KB-UPDATE)
   (CL:WHEN
    (CL:NOT
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS MODULE)
       SYM-PROPOSITIONS-STELLA-PROTECT-SURROGATES? FALSE-WRAPPER)))
    (CL:SETQ *STRINGIFIED-PROPOSITION-INDEX* (NEW-STRING-HASH-TABLE))
    (CL:SETQ *STRINGIFIED-DESCRIPTION-INDEX* (NEW-STRING-HASH-TABLE)))))

;;; (DEFUN CLEAR-INSTANCES ...)

(CL:DEFUN %CLEAR-INSTANCES (NAME)
  "Destroy all instances belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user."
  (CL:LET*
   ((OPTIONALNAME NAME)
    (MODULE (COERCE-TO-MODULE (%%VALUE OPTIONALNAME) TRUE)))
   (CL:WHEN (CL:NOT (CL:EQ MODULE NULL))
    (CL:WHEN
     (CL:OR (CL:NOT (CL:EQ OPTIONALNAME NIL))
      (Y-OR-N?
       (CONCATENATE "Really clear instances of module "
        (CONCATENATE (%MODULE-FULL-NAME MODULE) "? "))))
     (DO-CLEAR-INSTANCES MODULE)))))

(CL:DEFUN CLEAR-INSTANCES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%CLEAR-INSTANCES ARGUMENTS))

(CL:DEFMACRO CLEAR-INSTANCES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Destroy all instances belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/CLEAR-INSTANCES)) (CL:MACRO-FUNCTION (CL:QUOTE CLEAR-INSTANCES)))

;;; (DEFUN DO-CLEAR-INSTANCES ...)

(CL:DEFUN DO-CLEAR-INSTANCES (MODULE)
  "Function version of `clear-instances' that evaluates its argument."
  (CL:LET*
   ((CHILD NULL) (ITER-000 (%THE-CONS-LIST (%CHILD-CONTEXTS MODULE))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:PROGN (CL:SETQ CHILD (%%VALUE ITER-000))
     (CL:SETQ ITER-000 (%%REST ITER-000)))
    (CL:WHEN (ISA? CHILD SGT-PROPOSITIONS-STELLA-MODULE)
     (DO-CLEAR-INSTANCES CHILD))))
  (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (DESTROY-INFERENCE-CACHES MODULE)
   (CL:LET* ((INSTANCE NULL) (ITER-001 (ALL-INSTANCES MODULE TRUE)))
    (CL:LOOP WHILE (NEXT? ITER-001) DO
     (CL:SETQ INSTANCE (%VALUE ITER-001)) (DESTROY-INSTANCE INSTANCE)))
   (REMOVE-DELETED-MEMBERS (LOCALLY-CONCEIVED-PROPOSITIONS MODULE))))

;;; (DEFUN DESTROY-CONTEXT-HOOK ...)

(CL:DEFUN DESTROY-CONTEXT-HOOK (SELF)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-PROPOSITIONS-LOGIC-MONOTONIC?
   (CL:IF FALSE TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
  (CL:LET* ((*CONTEXT* SELF) (*MODULE* (%BASE-MODULE *CONTEXT*)))
   (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
   (CL:LET*
    ((I NULL)
     (ITER-000 (ALLOCATE-ITERATOR (LOCALLY-CONCEIVED-INSTANCES SELF))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ I (%VALUE ITER-000))
     (DESTROY-TERM I))))
  (CL:WHEN (ISA? SELF SGT-PROPOSITIONS-STELLA-WORLD)
   (UNLINK-INFERENCE-CACHE SELF)))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS1 ()
  (CL:PROGN
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PROPOSITIONS-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITIONS-INDEX" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-INSTANCES-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INSTANCES-INDEX" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-BACKLINKS-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKLINKS-INDEX" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPENDENT-PROPOSITIONS-LIST" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DEPENDENT-ISA-PROPOSITIONS-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPENDENT-ISA-PROPOSITIONS-LIST" NULL
     0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PREDICATE-PROPOSITIONS-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE-PROPOSITIONS-TABLE" NULL
     0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DEPENDENT-DESCRIPTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPENDENT-DESCRIPTIONS" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-ALL-SURROGATE-VALUE-INVERSES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-SURROGATE-VALUE-INVERSES" NULL
     0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-BAD?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BAD?"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-ROOT-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-TYPE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-VARIABLE-VALUE-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-VALUE-INVERSE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-EQUIVALENT-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT-VALUE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-SURROGATE-VALUE-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE-INVERSE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-CS-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CS-VALUE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-DELETED-OBJECT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DELETED-OBJECT?"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SKOLEM-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM-TYPE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SKOLEM-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM-NAME" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-VARIABLE-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-VALUE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DEFINING-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINING-PROPOSITION" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-BOUND-TO-OFFSET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOUND-TO-OFFSET" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-OBJECT-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-VECTOR" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-ARGUMENTS-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS-VECTOR" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-VARIABLES-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLES-VECTOR" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-CHAINING-INDEX" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-FORWARD-GOAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-GOAL" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-MASTER-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-RULE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-QUERY-BODY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-BODY" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-INPUT-BINDINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-BINDINGS" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CACHE-ID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHE-ID" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CONSEQUENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSEQUENT" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-FORWARD-CHAINING-INDICES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-CHAINING-INDICES" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DEFERRED-CONTRAPOSITIVES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFERRED-CONTRAPOSITIVES?" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-INTERNAL-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERNAL-VARIABLES" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-QUERY-PATTERNS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-PATTERNS" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-RELATIVE-COMPLEMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATIVE-COMPLEMENT" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-COMPLEMENT-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT-DESCRIPTION" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-NATIVE-RELATION-BACK-POINTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-RELATION-BACK-POINTER" NULL
     0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-RELATION-STRINGIFIED-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-STRINGIFIED-SOURCE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-TERM-STRINGIFIED-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TERM-STRINGIFIED-SOURCE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-IO-VARIABLE-NAMES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLE-NAMES" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-IO-VARIABLE-TYPES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLE-TYPES" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-EXTENSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PARTIAL-MATCH-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL-MATCH-SCORE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SET-OF-SUPPORT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-OF-SUPPORT" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMESTAMP" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-POSITIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITIVE-SCORE" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-PARTIAL-SUPPORT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL-SUPPORT" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-FACT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FACT" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-AXIOM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AXIOM" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCORE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-ID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ID" NULL 0))))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS2 ()
  (CL:PROGN
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-ARGUMENT-SCORES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-SCORES" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-VARIABLE-TYPE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE?" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SATELLITE-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SATELLITE-PROPOSITIONS" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-UNFASTENED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNFASTENED?" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-WEIGHT-DELTA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WEIGHT-DELTA" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SUPPORT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPPORT" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-KIND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KIND" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-OPERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPERATOR"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-RELATIONREF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATIONREF" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPENDENT-PROPOSITIONS" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-WEIGHT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WEIGHT" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-INTEGER-LOGIC-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-LOGIC-WRAPPER" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DEPENDENT-PROPOSITIONS-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPENDENT-PROPOSITIONS-INDEX" NULL
     0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-FLOAT-LOGIC-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT-LOGIC-WRAPPER" NULL 1))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-STRING-LOGIC-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-LOGIC-WRAPPER" NULL 1))
   (CL:SETQ KWD-PROPOSITIONS-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ KWD-PROPOSITIONS-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ KWD-PROPOSITIONS-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ KWD-PROPOSITIONS-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ KWD-PROPOSITIONS-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ KWD-PROPOSITIONS-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ KWD-PROPOSITIONS-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ KWD-PROPOSITIONS-COLLECT-INTO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-INTO" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-COLLECT-INTO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-INTO"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ KWD-PROPOSITIONS-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DESCRIPTIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTIVE?" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-CODE-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CODE-ONLY?"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ KWD-PROPOSITIONS-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-PROPOSITIONS-INTERNAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "LOCALLY-CONCEIVED-PROPOSITIONS-INTERNAL" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-PAGING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PAGING" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-CONTEXT-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-PROPOSITIONS" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-LOCALLY-CONCEIVED-INSTANCES-INTERNAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOCALLY-CONCEIVED-INSTANCES-INTERNAL"
     NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-CONTEXT-INSTANCES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-INSTANCES" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-UPDATE-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UPDATE-PROPOSITION" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-EXECUTE-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXECUTE-QUERY" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-BOTTOM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOTTOM" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-LITERAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-LITERAL-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-BOOLEAN-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-VARIABLE-ARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-ARITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION-COMPUTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-COMPUTATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS3 ()
  (CL:PROGN
   (CL:SETQ KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIONAL-ASSERTION" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-RETRACT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-TRUE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-TRUE-DEMON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOES-TRUE-DEMON"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ KWD-PROPOSITIONS-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-FALSE-DEMON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOES-FALSE-DEMON"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-GOES-UNKNOWN-DEMON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOES-UNKNOWN-DEMON"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-MASTER-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-ASSERT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-PRESUME-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRESUME-TRUE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-ASSERT-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-FALSE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-PRESUME-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRESUME-FALSE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-RETRACT-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-FALSE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-ASSERT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-RETRACT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-CONCEIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEIVE" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-HIDDEN-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HIDDEN-RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-HIDDEN-INSTANCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HIDDEN-INSTANCE" NULL 1))
   (CL:SETQ KWD-PROPOSITIONS-KB-UPDATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KB-UPDATE" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-META-KB-UPDATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-KB-UPDATE" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-STORAGE-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-WARNING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARNING" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-META-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-INFERENCE-CACHE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-MAINTAINED-INFERENCE-CACHE"
     NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-IOTA?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IOTA?" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CONFLICTING-DEFAULT-VALUES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONFLICTING-DEFAULT-VALUES" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SETOFALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOFALL" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-THE-ONLY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-ONLY" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-KAPPA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CREATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CREATE" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ KWD-PROPOSITIONS-INTENSIONAL-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTENSIONAL-ASSERTION" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?" (GET-STELLA-MODULE "/STELLA" TRUE)
     0))
   (CL:SETQ KWD-PROPOSITIONS-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-CLASS-EXTENSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-EXTENSION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ
    SYM-PROPOSITIONS-LOGIC-TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-SUBRELATION-LINK?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBRELATION-LINK?" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=" (GET-STELLA-MODULE "/STELLA" TRUE)
     0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-PL-KERNEL-KB-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 0))))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS4 ()
  (CL:PROGN
   (CL:SETQ SYM-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-COLLECT-INTO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-INTO"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-ABOUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABOUT" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DIRECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTION" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-FORWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-BACKWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-FORWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-ONLY?" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-BACKWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD-ONLY?" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-SETOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOF"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-LISTOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISTOF" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 0))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-POLYMORPHIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POLYMORPHIC"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SYM-PROPOSITIONS-PL-KERNEL-KB-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-PL-KERNEL-KB-CUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CUT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 0))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-QUANTITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUANTITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-DATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DATE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ KWD-PROPOSITIONS-AUTOMATICALLY-FIX-TYPE-VIOLATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AUTOMATICALLY-FIX-TYPE-VIOLATIONS"
     NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-POST-TYPE-VIOLATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POST-TYPE-VIOLATIONS" NULL 2))
   (CL:SETQ KWD-PROPOSITIONS-REPORT-TYPE-VIOLATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REPORT-TYPE-VIOLATIONS" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-ASSERTED-BY-TYPE-CHECKER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERTED-BY-TYPE-CHECKER?" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-LOGIC-CHECK-TYPES-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHECK-TYPES-RECORD" NULL 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PARENT-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT-PROPOSITION" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PARENT-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT-DESCRIPTION" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-TOTAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOTAL"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-LISTOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISTOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SGT-PROPOSITIONS-PL-KERNEL-KB-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-FALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALS" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-SOME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SOME"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CONFIDENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONFIDENCE-LEVEL" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-DEFAULT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULT"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-LAMBDA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LAMBDA" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-PL-KERNEL-KB-LISTOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISTOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-BAGOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BAGOF" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-ASSERT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-PRESUME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRESUME" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-CPP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-RETRACT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DENY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DENY" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CONCEIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEIVE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-UNASSERT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNASSERT" NULL 0))
   (CL:SETQ KWD-PROPOSITIONS-DELETED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DELETED" NULL 2))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-INTRODUCE-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTRODUCE-MODULE" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-PROTECT-SURROGATES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROTECT-SURROGATES?"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CLEAR-LOGIC-MODULE-HOOK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEAR-LOGIC-MODULE-HOOK" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-CLEAR-INSTANCES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEAR-INSTANCES" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-MONOTONIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MONOTONIC?" NULL 0))
   (CL:SETQ SGT-PROPOSITIONS-STELLA-WORLD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-DESTROY-CONTEXT-HOOK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESTROY-CONTEXT-HOOK" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-LOGIC-STARTUP-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-PROPOSITIONS" NULL 0))
   (CL:SETQ SYM-PROPOSITIONS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS5 ()
  (CL:PROGN (CL:SETQ ZERO-VARIABLES-VECTOR (NEW-VECTOR 0))
   (CL:LET* ((SELF-008 (NEW-PROPERTY-LIST)))
    (CL:SETF (%THE-PLIST SELF-008)
     (LIST* KWD-PROPOSITIONS-AND SGT-PROPOSITIONS-PL-KERNEL-KB-AND
      KWD-PROPOSITIONS-OR SGT-PROPOSITIONS-PL-KERNEL-KB-OR
      KWD-PROPOSITIONS-NOT SGT-PROPOSITIONS-PL-KERNEL-KB-NOT
      KWD-PROPOSITIONS-FORALL SGT-PROPOSITIONS-PL-KERNEL-KB-FORALL
      KWD-PROPOSITIONS-EXISTS SGT-PROPOSITIONS-PL-KERNEL-KB-EXISTS
      KWD-PROPOSITIONS-EQUIVALENT SGT-PROPOSITIONS-PL-KERNEL-KB-EQUIVALENT
      KWD-PROPOSITIONS-FAIL SGT-PROPOSITIONS-PL-KERNEL-KB-FAIL
      KWD-PROPOSITIONS-COLLECT-INTO
      SGT-PROPOSITIONS-PL-KERNEL-KB-COLLECT-INTO KWD-PROPOSITIONS-IMPLIES
      SGT-PROPOSITIONS-PL-KERNEL-KB-SUBSET-OF NIL))
    (CL:SETQ *OPERATOR-NAME-TO-SURROGATE-TABLE* SELF-008))
   (CL:SETQ *LOGIC-MODULE* (GET-STELLA-MODULE "LOGIC" TRUE))
   (CL:SETQ *PL-KERNEL-MODULE* (GET-STELLA-MODULE "PL-KERNEL" TRUE))
   (CL:SETQ *LAST-KB-ACTION* KWD-PROPOSITIONS-UPDATE-PROPOSITION)
   (CL:SETQ *EVALUATIONMODE* KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION)
   (CL:SETQ TRUE-TRUTH-VALUE (NEW-TRUTH-VALUE))
   (CL:SETQ FALSE-TRUTH-VALUE (NEW-TRUTH-VALUE))
   (CL:SETQ DEFAULT-TRUE-TRUTH-VALUE (NEW-TRUTH-VALUE))
   (CL:SETQ DEFAULT-FALSE-TRUTH-VALUE (NEW-TRUTH-VALUE))
   (CL:LET* ((SELF-014 (NEW-PROPOSITION)))
    (CL:SETF (%KIND SELF-014) KWD-PROPOSITIONS-CONSTANT)
    (CL:SETF (%OPERATOR SELF-014) SGT-PROPOSITIONS-STELLA-TRUE)
    (CL:SETF (%ARGUMENTS SELF-014) (NEW-VECTOR 0))
    (CL:LET*
     ((OBJECT-016 SELF-014) (VALUE-017 TRUE-TRUTH-VALUE)
      (OLD-VALUE-018 (%TRUTH-VALUE OBJECT-016))
      (NEW-VALUE-019
       (UPDATE-IN-CONTEXT OLD-VALUE-018 VALUE-017
        (%HOME-CONTEXT OBJECT-016) FALSE)))
     (CL:WHEN
      (CL:NOT
       (CL:AND (CL:NOT (CL:EQ OLD-VALUE-018 NULL))
        (CL:EQ (PRIMARY-TYPE OLD-VALUE-018)
         SGT-PROPOSITIONS-STELLA-CS-VALUE)))
      (CL:SETF (%TRUTH-VALUE OBJECT-016) NEW-VALUE-019)))
    (CL:SETQ TRUE-PROPOSITION SELF-014))
   (CL:LET* ((SELF-020 (NEW-PROPOSITION)))
    (CL:SETF (%KIND SELF-020) KWD-PROPOSITIONS-CONSTANT)
    (CL:SETF (%OPERATOR SELF-020) SGT-PROPOSITIONS-STELLA-FALSE)
    (CL:SETF (%ARGUMENTS SELF-020) (NEW-VECTOR 0))
    (CL:LET*
     ((OBJECT-022 SELF-020) (VALUE-023 FALSE-TRUTH-VALUE)
      (OLD-VALUE-024 (%TRUTH-VALUE OBJECT-022))
      (NEW-VALUE-025
       (UPDATE-IN-CONTEXT OLD-VALUE-024 VALUE-023
        (%HOME-CONTEXT OBJECT-022) FALSE)))
     (CL:WHEN
      (CL:NOT
       (CL:AND (CL:NOT (CL:EQ OLD-VALUE-024 NULL))
        (CL:EQ (PRIMARY-TYPE OLD-VALUE-024)
         SGT-PROPOSITIONS-STELLA-CS-VALUE)))
      (CL:SETF (%TRUTH-VALUE OBJECT-022) NEW-VALUE-025)))
    (CL:SETQ FALSE-PROPOSITION SELF-020))
   (CL:SETQ ANONYMOUS-VARIABLE-NAME SYM-PROPOSITIONS-STELLA-?)
   (CL:SETQ *MISSING-KEY-VALUE-LIST* (NEW-KEY-VALUE-LIST))
   (CL:SETQ *AUTOMATICINSTANCETABLE* *MISSING-KEY-VALUE-LIST*)
   (CL:SETQ *STRINGIFIED-PROPOSITION-INDEX* (NEW-STRING-HASH-TABLE))
   (CL:SETQ *TYPE-CHECK-POLICY*
    KWD-PROPOSITIONS-AUTOMATICALLY-FIX-TYPE-VIOLATIONS)
   (CL:SETQ *TYPECHECKMODE* KWD-PROPOSITIONS-POST-TYPE-VIOLATIONS)
   (CL:SETQ *CHECK-TYPES-AGENDA* (NEW-KEY-VALUE-LIST))))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS6 ()
  (CL:PROGN
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE PROPOSITIONS-INDEX (SEQUENCE-INDEX OF PROPOSITION))")
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE INSTANCES-INDEX (SEQUENCE-INDEX OF LOGIC-OBJECT))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "BACKLINKS-INDEX"
       "(DEFCLASS BACKLINKS-INDEX (STANDARD-OBJECT) :DOCUMENTATION \"Contains several types of indices pointing at dependent propositions.\" :SLOTS ((DEPENDENT-PROPOSITIONS-LIST :TYPE PROPOSITIONS-INDEX) (DEPENDENT-ISA-PROPOSITIONS-LIST :TYPE PROPOSITIONS-INDEX) (PREDICATE-PROPOSITIONS-TABLE :TYPE (HASH-TABLE OF SURROGATE PROPOSITIONS-INDEX))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-BACKLINKS-INDEX))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-BACKLINKS-INDEX-SLOT-VALUE)))
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "BACKLINKS-MIXIN"
    "(DEFCLASS BACKLINKS-MIXIN () :DOCUMENTATION \"Inherited by objects that point back at propositions that reference
them.\" :SLOTS ((DEPENDENT-PROPOSITIONS-INDEX :TYPE BACKLINKS-INDEX)) :MIXIN? TRUE)")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "LOGIC-OBJECT"
       "(DEFCLASS LOGIC-OBJECT (CONTEXT-SENSITIVE-OBJECT DYNAMIC-SLOTS-MIXIN BACKLINKS-MIXIN) :DOCUMENTATION \"Object with propositions, and possibly a variable value.\" :PUBLIC-SLOTS ((ROOT-TYPE :TYPE TYPE) (DEPENDENT-DESCRIPTIONS :TYPE (LIST OF DESCRIPTION) :ALLOCATION :DYNAMIC) (VARIABLE-VALUE-INVERSE :TYPE (CONS OF LOGIC-OBJECT) :DEFAULT NIL :CONTEXT-SENSITIVE? TRUE) (EQUIVALENT-VALUE :TYPE DESCRIPTION :CONTEXT-SENSITIVE? TRUE) (SURROGATE-VALUE-INVERSE :TYPE SURROGATE) (ALL-SURROGATE-VALUE-INVERSES :TYPE (LIST OF SURROGATE) :ALLOCATION :DYNAMIC) (UNDECLARED? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (HYPOTHESIZED-INSTANCE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC)) :PRINT-FORM (PRINT-TOP-LEVEL-OBJECT SELF STREAM) :INITIALIZER LOG-LOGIC-OBJECT)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-LOGIC-OBJECT))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-LOGIC-OBJECT-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SKOLEM"
       "(DEFCLASS SKOLEM (LOGIC-OBJECT) :DOCUMENTATION \"Object whose identity and type are not fixed at creation time.
Potentially unifiable with any other object.\" :PUBLIC-SLOTS ((SKOLEM-TYPE :RENAMES ROOT-TYPE) (SKOLEM-NAME :TYPE SYMBOL) (VARIABLE-VALUE :TYPE OBJECT :CONTEXT-SENSITIVE? TRUE) (DEFINING-PROPOSITION :TYPE PROPOSITION)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-SKOLEM))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-SKOLEM-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PATTERN-VARIABLE"
       "(DEFCLASS PATTERN-VARIABLE (SKOLEM) :DOCUMENTATION \"A variable in a logical expression.\" :SLOTS ((BOUND-TO-OFFSET :TYPE INTEGER) (ORIGINAL-SKOLEM-NAME :TYPE SYMBOL :ALLOCATION :DYNAMIC)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PATTERN-VARIABLE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PATTERN-VARIABLE-SLOT-VALUE)))
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE OBJECT-VECTOR (VECTOR OF OBJECT))")
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE ARGUMENTS-VECTOR OBJECT-VECTOR)")
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE VARIABLES-VECTOR (VECTOR OF PATTERN-VARIABLE))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FORWARD-CHAINING-INDEX"
       "(DEFCLASS FORWARD-CHAINING-INDEX (STANDARD-OBJECT) :SLOTS ((FORWARD-GOAL :TYPE PROPOSITION) (MASTER-RULE :TYPE PROPOSITION) (IO-VARIABLES :TYPE CONS) (QUERY-BODY :TYPE CONS) (INPUT-BINDINGS :TYPE CONS) (CACHE-ID :TYPE SYMBOL) (CONSEQUENT :TYPE DESCRIPTION)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-FORWARD-CHAINING-INDEX))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-FORWARD-CHAINING-INDEX-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "DESCRIPTION"
       "(DEFCLASS DESCRIPTION (LOGIC-OBJECT) :PUBLIC-SLOTS ((PROPOSITION :TYPE PROPOSITION) (IO-VARIABLES :TYPE VARIABLES-VECTOR) (INTERNAL-VARIABLES :TYPE VARIABLES-VECTOR :INITIALLY ZERO-VARIABLES-VECTOR) (EXTERNAL-VARIABLES :TYPE VARIABLES-VECTOR :ALLOCATION :DYNAMIC) (QUERY-PATTERNS :TYPE (KEY-VALUE-LIST OF BOOLEAN-VECTOR DESCRIPTION)) (COMPLEMENT-DESCRIPTION :TYPE DESCRIPTION :ALLOCATION :DYNAMIC) (RELATIVE-COMPLEMENT :RENAMES COMPLEMENT-DESCRIPTION) (TAXONOMY-NODE :TYPE TAXONOMY-NODE :ALLOCATION :DYNAMIC) (IOTA? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (DONT-OPTIMIZE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (FORWARD-CHAINING-INDICES :TYPE (LIST OF FORWARD-CHAINING-INDEX) :ALLOCATION :DYNAMIC) (RULES-WITH-DEFERRED-SATELLITES :TYPE PROPOSITIONS-INDEX :ALLOCATION :DYNAMIC) (DEFERRED-CONTRAPOSITIVES? :TYPE BOOLEAN-WRAPPER :ALLOCATION :DYNAMIC :DEFAULT FALSE)) :METHODS ((REPRESENTATIVE ((SELF DESCRIPTION)) :TYPE PATTERN-VARIABLE (RETURN (FIRST (IO-VARIABLES SELF)))) (NATIVE-RELATION ((SELF DESCRIPTION)) :TYPE RELATION (RETURN NULL)) (DESCRIPTION-EXTENSION ((SELF DESCRIPTION)) :TYPE PROPOSITIONS-INDEX (RETURN NIL-PAGING-INDEX))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-DESCRIPTION))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-DESCRIPTION-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NAMED-DESCRIPTION"
       "(DEFCLASS NAMED-DESCRIPTION (DESCRIPTION) :PUBLIC-SLOTS ((DOCUMENTATION :TYPE STRING) (RELATION-STRINGIFIED-SOURCE :TYPE STRING) (TERM-STRINGIFIED-SOURCE :RENAMES RELATION-STRINGIFIED-SOURCE) (IO-VARIABLE-NAMES :TYPE (LIST OF SYMBOL)) (IO-VARIABLE-TYPES :TYPE (LIST OF TYPE)) (EXTENSION :TYPE PROPOSITIONS-INDEX) (NATIVE-RELATION-BACK-POINTER :TYPE RELATION :ALLOCATION :DYNAMIC) (CHECK-FOR-CACHED-GOALS? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (INVERSE-DESCRIPTION :TYPE NAMED-DESCRIPTION :ALLOCATION :DYNAMIC)) :METHODS ((NATIVE-RELATION ((SELF NAMED-DESCRIPTION)) :TYPE RELATION (RETURN (NATIVE-RELATION-BACK-POINTER SELF))) (NATIVE-RELATION-SETTER ((SELF NAMED-DESCRIPTION) (VALUE RELATION)) (SETF (NATIVE-RELATION-BACK-POINTER SELF) VALUE)) (DESCRIPTION-EXTENSION ((SELF NAMED-DESCRIPTION)) :TYPE PROPOSITIONS-INDEX (RETURN (EITHER (EXTENSION SELF) NIL-PAGING-INDEX)))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-NAMED-DESCRIPTION))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-NAMED-DESCRIPTION-SLOT-VALUE)))
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE PARTIAL-MATCH-SCORE FLOAT)")
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE SET-OF-SUPPORT LIST)")
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE TIMESTAMP INTEGER)")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TRUTH-VALUE"
       "(DEFCLASS TRUTH-VALUE (LOGIC-OBJECT) :PUBLIC-SLOTS ((POSITIVE-SCORE :TYPE PARTIAL-MATCH-SCORE :INITIALLY 0.0)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-TRUTH-VALUE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-TRUTH-VALUE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PARTIAL-SUPPORT"
       "(DEFCLASS PARTIAL-SUPPORT (STANDARD-OBJECT) :PUBLIC-SLOTS ((FACT :TYPE PROPOSITION) (AXIOM :TYPE PROPOSITION) (SCORE :TYPE FLOAT) (ID :TYPE INTEGER) (ARGUMENT-SCORES :TYPE (CONS OF FLOAT-WRAPPER))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PARTIAL-SUPPORT))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PARTIAL-SUPPORT-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PROPOSITION"
       "(DEFCLASS PROPOSITION (CONTEXT-SENSITIVE-OBJECT DYNAMIC-SLOTS-MIXIN BACKLINKS-MIXIN) :DOCUMENTATION \"\" :PUBLIC-SLOTS ((KIND :TYPE KEYWORD) (TRUTH-VALUE :TYPE TRUTH-VALUE :CONTEXT-SENSITIVE? TRUE) (ARGUMENTS :TYPE VECTOR) (OPERATOR :TYPE GENERALIZED-SYMBOL) (RELATIONREF :TYPE SURROGATE :RENAMES OPERATOR) (DEPENDENT-PROPOSITIONS :TYPE (NON-PAGING-INDEX OF PROPOSITION) :INITIALLY NIL-NON-PAGING-INDEX) (SURROGATE-VALUE-INVERSE :TYPE SURROGATE :ALLOCATION :DYNAMIC) (IO-VARIABLES :TYPE VARIABLES-VECTOR :ALLOCATION :DYNAMIC) (VARIABLE-TYPE? :TYPE BOOLEAN-WRAPPER :ALLOCATION :DYNAMIC :DEFAULT FALSE) (ASSERTED-BY-TYPE-CHECKER? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (DESCRIPTIVE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (SUBRELATION-LINK? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (SUBSUMPTION-LINK? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (SATELLITE-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :ALLOCATION :DYNAMIC) (MASTER-PROPOSITION :TYPE PROPOSITION :ALLOCATION :DYNAMIC) (DONT-OPTIMIZE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (FORWARD-ONLY? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (BACKWARD-ONLY? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (NATURAL? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (TERM-STRINGIFIED-SOURCE :TYPE STRING-WRAPPER :ALLOCATION :DYNAMIC) (UNFASTENED? :TYPE BOOLEAN-WRAPPER :ALLOCATION :DYNAMIC :DEFAULT FALSE) (WEIGHT :TYPE FLOAT) (NEURAL-NETWORK :TYPE PROPOSITION-NEURAL-NETWORK :ALLOCATION :DYNAMIC) (WEIGHT-DELTA :TYPE FLOAT :DEFAULT 0.0 :ALLOCATION :DYNAMIC) (MATCH-SCORE :TYPE FLOAT :ALLOCATION :DYNAMIC) (SUPPORT :TYPE (CONS OF PARTIAL-SUPPORT) :ALLOCATION :DYNAMIC)) :PRINT-FORM (PRINT-TOP-LEVEL-OBJECT SELF STREAM))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PROPOSITION))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PROPOSITION-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INTEGER-LOGIC-WRAPPER"
       "(DEFCLASS INTEGER-LOGIC-WRAPPER (INTEGER-WRAPPER BACKLINKS-MIXIN) :SLOTS ((DEPENDENT-PROPOSITIONS-INDEX :INITIALLY (NEW BACKLINKS-INDEX))) :PRINT-FORM (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM (WRAPPER-VALUE SELF)) (PRINT-NATIVE-STREAM STREAM \"|W|\" (WRAPPER-VALUE SELF))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-INTEGER-LOGIC-WRAPPER))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-INTEGER-LOGIC-WRAPPER-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FLOAT-LOGIC-WRAPPER"
       "(DEFCLASS FLOAT-LOGIC-WRAPPER (FLOAT-WRAPPER BACKLINKS-MIXIN) :SLOTS ((DEPENDENT-PROPOSITIONS-INDEX :INITIALLY (NEW BACKLINKS-INDEX))) :PRINT-FORM (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM (WRAPPER-VALUE SELF)) (PRINT-NATIVE-STREAM STREAM \"|W|\" (WRAPPER-VALUE SELF))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-FLOAT-LOGIC-WRAPPER))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-FLOAT-LOGIC-WRAPPER-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STRING-LOGIC-WRAPPER"
       "(DEFCLASS STRING-LOGIC-WRAPPER (STRING-WRAPPER BACKLINKS-MIXIN) :SLOTS ((DEPENDENT-PROPOSITIONS-INDEX :INITIALLY (NEW BACKLINKS-INDEX))) :PRINT-FORM (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM (WRAPPER-VALUE SELF)) (PRINT-NATIVE-STREAM STREAM \"|W|\" (WRAPPER-VALUE SELF))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-STRING-LOGIC-WRAPPER))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-STRING-LOGIC-WRAPPER-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CHECK-TYPES-RECORD"
       "(DEFCLASS CHECK-TYPES-RECORD (STANDARD-OBJECT) :SLOTS ((PARENT-PROPOSITION :TYPE OBJECT) (PARENT-DESCRIPTION :TYPE DESCRIPTION) (MODULE :TYPE MODULE)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-CHECK-TYPES-RECORD))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-CHECK-TYPES-RECORD-SLOT-VALUE)))))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS7 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "LOG-LOGIC-OBJECT"
    "(DEFUN LOG-LOGIC-OBJECT ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION LOG-LOGIC-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-PROPOSITION"
    "(DEFUN (CREATE-PROPOSITION PROPOSITION) ((KIND SYMBOL) (ARGUMENTCOUNT INTEGER)))"
    (CL:FUNCTION CREATE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "ENFORCE-CODE-ONLY"
    "(DEFUN ENFORCE-CODE-ONLY ())" (CL:FUNCTION ENFORCE-CODE-ONLY) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT CONTEXT MONOTONIC? :TYPE BOOLEAN :PUBLIC? TRUE :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT WORLD TRUTH-MAINTAINED? :TYPE BOOLEAN :PUBLIC? TRUE :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT WORLD UP-TO-DATE-INFERENCES? :TYPE BOOLEAN :PUBLIC? TRUE :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "LOGIC-MODULE?"
    "(DEFUN (LOGIC-MODULE? BOOLEAN) ((SELF MODULE)) :DOCUMENTATION \"Return TRUE if 'self' is a logic module, implying
that relations defined within it define a knowledge base.  A module
is a logic module iff it inherits the module 'PL-KERNEL'.\")"
    (CL:FUNCTION LOGIC-MODULE?) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT MODULE LOCALLY-CONCEIVED-PROPOSITIONS-INTERNAL :TYPE PROPOSITIONS-INDEX :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "LOCALLY-CONCEIVED-PROPOSITIONS"
    "(DEFUN (LOCALLY-CONCEIVED-PROPOSITIONS PROPOSITIONS-INDEX) ((SELF MODULE)))"
    (CL:FUNCTION LOCALLY-CONCEIVED-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "LOCALLY-CONCEIVED-PROPOSITIONS-SETTER"
    "(DEFUN LOCALLY-CONCEIVED-PROPOSITIONS-SETTER ((SELF MODULE) (VALUE PROPOSITIONS-INDEX)))"
    (CL:FUNCTION LOCALLY-CONCEIVED-PROPOSITIONS-SETTER) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT CONTEXT LOCALLY-CONCEIVED-INSTANCES-INTERNAL :TYPE INSTANCES-INDEX :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "LOCALLY-CONCEIVED-INSTANCES"
    "(DEFUN (LOCALLY-CONCEIVED-INSTANCES INSTANCES-INDEX) ((SELF CONTEXT)))"
    (CL:FUNCTION LOCALLY-CONCEIVED-INSTANCES) NULL)
   (DEFINE-FUNCTION-OBJECT "LOCALLY-CONCEIVED-INSTANCES-SETTER"
    "(DEFUN LOCALLY-CONCEIVED-INSTANCES-SETTER ((SELF CONTEXT) (VALUE INSTANCES-INDEX)))"
    (CL:FUNCTION LOCALLY-CONCEIVED-INSTANCES-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "INCREMENT-NOW-TIMESTAMP"
    "(DEFUN INCREMENT-NOW-TIMESTAMP ())"
    (CL:FUNCTION INCREMENT-NOW-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-NOW-TIMESTAMP"
    "(DEFUN (GET-NOW-TIMESTAMP TIMESTAMP) ())"
    (CL:FUNCTION GET-NOW-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-NOW-TIMESTAMP"
    "(DEFUN UPDATE-NOW-TIMESTAMP ((KBACTION KEYWORD)))"
    (CL:FUNCTION UPDATE-NOW-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "BOTTOM?"
    "(DEFUN (BOTTOM? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'self' is the undefined individual BOTTOM.\")"
    (CL:FUNCTION BOTTOM?) NULL)
   (DEFINE-FUNCTION-OBJECT "SUBRELATION-OF?"
    "(DEFUN (SUBRELATION-OF? BOOLEAN) ((DESC1 NAMED-DESCRIPTION) (DESC2 NAMED-DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION SUBRELATION-OF?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGICAL-SUBTYPE-OF?"
    "(DEFUN (LOGICAL-SUBTYPE-OF? BOOLEAN) ((TYPE1 SURROGATE) (TYPE2 SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION LOGICAL-SUBTYPE-OF?) NULL)
   (DEFINE-FUNCTION-OBJECT "LITERAL-TYPE?"
    "(DEFUN (LITERAL-TYPE? BOOLEAN) ((TYPE SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION LITERAL-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT "BOOLEAN-TYPE?"
    "(DEFUN (BOOLEAN-TYPE? BOOLEAN) ((SELF TYPE)) :PUBLIC? TRUE)"
    (CL:FUNCTION BOOLEAN-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS-DESCRIPTION?"
    "(DEFUN (CLASS-DESCRIPTION? BOOLEAN) ((SELF NAMED-DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION CLASS-DESCRIPTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "FUNCTION-DESCRIPTION?"
    "(DEFUN (FUNCTION-DESCRIPTION? BOOLEAN) ((SELF NAMED-DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION FUNCTION-DESCRIPTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "VARIABLE-ARITY?"
    "(DEFUN (VARIABLE-ARITY? BOOLEAN) ((SELF DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION VARIABLE-ARITY?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ARITY INTEGER) ((SELF NAMED-DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION ARITY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ARITY INTEGER) ((SELF DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION ARITY) NULL)
   (DEFINE-FUNCTION-OBJECT "MONADIC?"
    "(DEFUN (MONADIC? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION MONADIC?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTED-RELATION?"
    "(DEFUN (COMPUTED-RELATION? BOOLEAN) ((DESCRIPTION NAMED-DESCRIPTION)) :PUBLIC? TRUE)"
    (CL:FUNCTION COMPUTED-RELATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "LAST-ARGUMENT"
    "(DEFUN (LAST-ARGUMENT OBJECT) ((PROPOSITION PROPOSITION)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH (ARGUMENTS PROPOSITION) (1- (LENGTH (ARGUMENTS PROPOSITION))))))"
    (CL:FUNCTION LAST-ARGUMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "DESCRIPTION-MODE?"
    "(DEFUN (DESCRIPTION-MODE? BOOLEAN) ())"
    (CL:FUNCTION DESCRIPTION-MODE?) NULL)
   (DEFINE-FUNCTION-OBJECT "NATURAL-DEDUCTION-MODE?"
    "(DEFUN (NATURAL-DEDUCTION-MODE? BOOLEAN) () :DOCUMENTATION \"True if normalization is governed by natural
deduction semantics.\")" (CL:FUNCTION NATURAL-DEDUCTION-MODE?) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTEXT-DEPENDENT-SEARCH-MODE?"
    "(DEFUN (CONTEXT-DEPENDENT-SEARCH-MODE? BOOLEAN) ())"
    (CL:FUNCTION CONTEXT-DEPENDENT-SEARCH-MODE?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOG-NEWLY-CONCEIVED-PROPOSITION"
    "(DEFUN LOG-NEWLY-CONCEIVED-PROPOSITION ((SELF MODULE) (PROPOSITION PROPOSITION)))"
    (CL:FUNCTION LOG-NEWLY-CONCEIVED-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "CLIP-OR-CLASH-WITH-OLD-PREDICATE-VALUE"
    "(DEFUN CLIP-OR-CLASH-WITH-OLD-PREDICATE-VALUE ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION CLIP-OR-CLASH-WITH-OLD-PREDICATE-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-TRUTH-CHANGE-DEMON"
    "(DEFUN RUN-TRUTH-CHANGE-DEMON ((PROPOSITION PROPOSITION) (TRUTHCHANGERELATION SURROGATE)))"
    (CL:FUNCTION RUN-TRUTH-CHANGE-DEMON) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-GOES-TRUE-DEMONS"
    "(DEFUN RUN-GOES-TRUE-DEMONS ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION RUN-GOES-TRUE-DEMONS) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-GOES-FALSE-DEMONS"
    "(DEFUN RUN-GOES-FALSE-DEMONS ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION RUN-GOES-FALSE-DEMONS) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-GOES-UNKNOWN-DEMONS"
    "(DEFUN RUN-GOES-UNKNOWN-DEMONS ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION RUN-GOES-UNKNOWN-DEMONS) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-LINKS-AND-TIMESTAMPS"
    "(DEFUN UPDATE-LINKS-AND-TIMESTAMPS ((PROPOSITION PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION UPDATE-LINKS-AND-TIMESTAMPS) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSIGN-TRUTH-VALUE"
    "(DEFUN ASSIGN-TRUTH-VALUE ((SELF PROPOSITION) (TRUTHVALUE OBJECT)))"
    (CL:FUNCTION ASSIGN-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "DEASSIGN-TRUTH-VALUE"
    "(DEFUN DEASSIGN-TRUTH-VALUE ((SELF PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION DEASSIGN-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-PROPOSITION-TRUTH-VALUE"
    "(DEFUN UPDATE-PROPOSITION-TRUTH-VALUE ((SELF PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION UPDATE-PROPOSITION-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSIGN-PROPOSITION-WEIGHT"
    "(DEFUN ASSIGN-PROPOSITION-WEIGHT ((SELF PROPOSITION) (WEIGHT PARTIAL-MATCH-SCORE)))"
    (CL:FUNCTION ASSIGN-PROPOSITION-WEIGHT) NULL)
   (DEFINE-FUNCTION-OBJECT "TICKLE-CONTEXT"
    "(DEFUN (TICKLE-CONTEXT CONTEXT) ())" (CL:FUNCTION TICKLE-CONTEXT)
    NULL)
   (DEFINE-FUNCTION-OBJECT "TICKLE-INSTANCES"
    "(DEFUN (TICKLE-INSTANCES CONTEXT) ())" (CL:FUNCTION TICKLE-INSTANCES)
    NULL)
   (DEFINE-FUNCTION-OBJECT "REACT-TO-SKOLEM-VALUE-UPDATE"
    "(DEFUN REACT-TO-SKOLEM-VALUE-UPDATE ((SKOLEM SKOLEM) (OLDVALUE OBJECT) (NEWVALUE OBJECT) (TOPLEVELUPDATE? BOOLEAN)))"
    (CL:FUNCTION REACT-TO-SKOLEM-VALUE-UPDATE) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-SLOT-PROPOSITION?"
    "(DEFUN (NATIVE-SLOT-PROPOSITION? BOOLEAN) ((SELF PROPOSITION)))"
    (CL:FUNCTION NATIVE-SLOT-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-NATIVE-SLOT-PROPOSITION"
    "(DEFUN (UPDATE-NATIVE-SLOT-PROPOSITION (CONS OF PROPOSITION)) ((PROPOSITION PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION UPDATE-NATIVE-SLOT-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSIGN-NATIVE-SLOT-VALUE"
    "(DEFUN ASSIGN-NATIVE-SLOT-VALUE ((SELF THING) (SLOT STORAGE-SLOT) (VALUE OBJECT)))"
    (CL:FUNCTION ASSIGN-NATIVE-SLOT-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-NATIVE-SLOT-VALUE"
    "(DEFUN CLEAR-NATIVE-SLOT-VALUE ((OBJECT THING) (SLOT STORAGE-SLOT)))"
    (CL:FUNCTION CLEAR-NATIVE-SLOT-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "DROP-NATIVE-SLOT-VALUE"
    "(DEFUN DROP-NATIVE-SLOT-VALUE ((SELF THING) (SLOT STORAGE-SLOT) (VALUE OBJECT)))"
    (CL:FUNCTION DROP-NATIVE-SLOT-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-SLOTREF-ON-INSTANCE"
    "(DEFUN (LOOKUP-SLOTREF-ON-INSTANCE SURROGATE) ((TERM OBJECT) (SLOTNAME SYMBOL)))"
    (CL:FUNCTION LOOKUP-SLOTREF-ON-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNBOUND?"
    "(DEFUN (UNBOUND? BOOLEAN) ((SKOLEM SKOLEM)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NULL? (VARIABLE-VALUE SKOLEM))))"
    (CL:FUNCTION UNBOUND?) NULL)
   (DEFINE-FUNCTION-OBJECT "VALUE-OF"
    "(DEFUN (VALUE-OF OBJECT) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION VALUE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "SURROGATE.VALUE-OF"
    "(DEFUN (SURROGATE.VALUE-OF OBJECT) ((SELF SURROGATE)))"
    (CL:FUNCTION SURROGATE.VALUE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATION.VALUE-OF"
    "(DEFUN (RELATION.VALUE-OF DESCRIPTION) ((SELF RELATION)))"
    (CL:FUNCTION RELATION.VALUE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-VALUE-OF"
    "(DEFUN (EQUIVALENT-VALUE-OF OBJECT) ((SELF OBJECT)))"
    (CL:FUNCTION EQUIVALENT-VALUE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "GROUND-VALUE-OF"
    "(DEFUN (GROUND-VALUE-OF OBJECT) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION GROUND-VALUE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "SKOLEM?"
    "(DEFUN (SKOLEM? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION SKOLEM?) NULL)
   (DEFINE-FUNCTION-OBJECT "VARIABLE?"
    "(DEFUN (VARIABLE? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION VARIABLE?) NULL)))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS8 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "NATIVE-VALUE?"
    "(DEFUN (NATIVE-VALUE? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION NATIVE-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-VALUE-OF"
    "(DEFUN (NATIVE-VALUE-OF OBJECT) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION NATIVE-VALUE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "INNERMOST-VARIABLE-OF"
    "(DEFUN (INNERMOST-VARIABLE-OF PATTERN-VARIABLE) ((SELF PATTERN-VARIABLE)))"
    (CL:FUNCTION INNERMOST-VARIABLE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "INNERMOST-OF"
    "(DEFUN (INNERMOST-OF OBJECT) ((SELF OBJECT)))"
    (CL:FUNCTION INNERMOST-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-ANONYMOUS-SKOLEM-NAME"
    "(DEFUN (YIELD-ANONYMOUS-SKOLEM-NAME SYMBOL) ((VARIABLE? BOOLEAN)))"
    (CL:FUNCTION YIELD-ANONYMOUS-SKOLEM-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-CREATE-SKOLEM"
    "(DEFUN (HELP-CREATE-SKOLEM SKOLEM) ((SELF SKOLEM) (TYPE TYPE) (NAME SYMBOL) (ASSERTISA? BOOLEAN)))"
    (CL:FUNCTION HELP-CREATE-SKOLEM) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-SKOLEM"
    "(DEFUN (CREATE-SKOLEM SKOLEM) ((TYPE TYPE) (NAME SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-SKOLEM) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-VARIABLE"
    "(DEFUN (CREATE-VARIABLE PATTERN-VARIABLE) ((TYPE TYPE) (NAME SYMBOL) (ASSERTISA? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-VARIABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-VARIABLE-OR-SKOLEM"
    "(DEFUN (CREATE-VARIABLE-OR-SKOLEM SKOLEM) ((TYPE TYPE) (NAME SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-VARIABLE-OR-SKOLEM) NULL)
   (DEFINE-FUNCTION-OBJECT "TRUE?"
    "(DEFUN (TRUE? BOOLEAN) ((SELF PROPOSITION)) :PUBLIC? TRUE)"
    (CL:FUNCTION TRUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "FALSE?"
    "(DEFUN (FALSE? BOOLEAN) ((SELF PROPOSITION)) :PUBLIC? TRUE)"
    (CL:FUNCTION FALSE?) NULL)
   (DEFINE-FUNCTION-OBJECT "UNKNOWN?"
    "(DEFUN (UNKNOWN? BOOLEAN) ((SELF PROPOSITION)) :PUBLIC? TRUE)"
    (CL:FUNCTION UNKNOWN?) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFAULT-TRUE?"
    "(DEFUN (DEFAULT-TRUE? BOOLEAN) ((SELF PROPOSITION)) :PUBLIC? TRUE)"
    (CL:FUNCTION DEFAULT-TRUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFAULT-FALSE?"
    "(DEFUN (DEFAULT-FALSE? BOOLEAN) ((SELF PROPOSITION)) :PUBLIC? TRUE)"
    (CL:FUNCTION DEFAULT-FALSE?) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFAULTIFY-TRUTH-VALUE"
    "(DEFUN (DEFAULTIFY-TRUTH-VALUE TRUTH-VALUE) ((TRUE? BOOLEAN) (BYDEFAULT? BOOLEAN)))"
    (CL:FUNCTION DEFAULTIFY-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "INVERT-TRUTH-VALUE"
    "(DEFUN (INVERT-TRUTH-VALUE TRUTH-VALUE) ((SELF TRUTH-VALUE)) :PUBLIC? TRUE)"
    (CL:FUNCTION INVERT-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-UNIFICATION-CLASH"
    "(DEFUN SIGNAL-UNIFICATION-CLASH ((TERM1 OBJECT) (TERM2 OBJECT)))"
    (CL:FUNCTION SIGNAL-UNIFICATION-CLASH) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-VARIABLE-VALUE-CLASH"
    "(DEFUN SIGNAL-VARIABLE-VALUE-CLASH ((SKOLEM SKOLEM) (VALUE1 OBJECT) (VALUE2 OBJECT)))"
    (CL:FUNCTION SIGNAL-VARIABLE-VALUE-CLASH) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-TRUTH-VALUE-CLASH"
    "(DEFUN SIGNAL-TRUTH-VALUE-CLASH ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION SIGNAL-TRUTH-VALUE-CLASH) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGICAL-TYPE"
    "(DEFUN (LOGICAL-TYPE TYPE) ((SELF OBJECT)))"
    (CL:FUNCTION LOGICAL-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "SAFE-LOGICAL-TYPE"
    "(DEFUN (SAFE-LOGICAL-TYPE TYPE) ((SELF OBJECT)))"
    (CL:FUNCTION SAFE-LOGICAL-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS-LOGICAL-TYPE"
    "(DEFUN (CLASS-LOGICAL-TYPE TYPE) ((SELF CLASS)))"
    (CL:FUNCTION CLASS-LOGICAL-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNIFY-TYPES"
    "(DEFUN UNIFY-TYPES ((TERM1 SKOLEM) (TERM2 OBJECT)))"
    (CL:FUNCTION UNIFY-TYPES) NULL)
   (DEFINE-FUNCTION-OBJECT "UNIFY-SKOLEM-AND-VALUE"
    "(DEFUN UNIFY-SKOLEM-AND-VALUE ((SKOLEM SKOLEM) (VALUE OBJECT)))"
    (CL:FUNCTION UNIFY-SKOLEM-AND-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "BIND-SKOLEM-TO-VALUE"
    "(DEFUN BIND-SKOLEM-TO-VALUE ((FROMSKOLEM SKOLEM) (TOVALUE OBJECT) (TOPLEVELUPDATE? BOOLEAN)))"
    (CL:FUNCTION BIND-SKOLEM-TO-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNBIND-SKOLEM-VALUE"
    "(DEFUN UNBIND-SKOLEM-VALUE ((SKOLEM SKOLEM) (TOPLEVELUPDATE? BOOLEAN)))"
    (CL:FUNCTION UNBIND-SKOLEM-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "CONSTRAIN-AS-SUBSET"
    "(DEFUN CONSTRAIN-AS-SUBSET ((SET1 COLLECTION) (SET2 COLLECTION)))"
    (CL:FUNCTION CONSTRAIN-AS-SUBSET) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUATE-COLLECTIONS"
    "(DEFUN EQUATE-COLLECTIONS ((COL1 COLLECTION) (COL2 COLLECTION)))"
    (CL:FUNCTION EQUATE-COLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUATE-VALUES"
    "(DEFUN EQUATE-VALUES ((TERM1 OBJECT) (TERM2 OBJECT)))"
    (CL:FUNCTION EQUATE-VALUES) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT SKOLEM CONFLICTING-DEFAULT-VALUES :TYPE (CONS OF PROPOSITION) :DEFAULT NIL :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "UNEQUATE-CONFLICTING-DEFAULT-VALUES?"
    "(DEFUN (UNEQUATE-CONFLICTING-DEFAULT-VALUES? BOOLEAN) ((NEWEQUATINGPROP PROPOSITION)))"
    (CL:FUNCTION UNEQUATE-CONFLICTING-DEFAULT-VALUES?) NULL)
   (DEFINE-FUNCTION-OBJECT "UNEQUATE-VALUES?"
    "(DEFUN (UNEQUATE-VALUES? BOOLEAN) ((TERM1 OBJECT) (TERM2 OBJECT)))"
    (CL:FUNCTION UNEQUATE-VALUES?) NULL)
   (DEFINE-FUNCTION-OBJECT "BIND-TO-EQUIVALENT-VALUE"
    "(DEFUN BIND-TO-EQUIVALENT-VALUE ((FROM LOGIC-OBJECT) (TO DESCRIPTION)))"
    (CL:FUNCTION BIND-TO-EQUIVALENT-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNBIND-EQUIVALENT-VALUE"
    "(DEFUN UNBIND-EQUIVALENT-VALUE ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION UNBIND-EQUIVALENT-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENT-COLLECTION-PRIORITY"
    "(DEFUN (EQUIVALENT-COLLECTION-PRIORITY INTEGER) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION EQUIVALENT-COLLECTION-PRIORITY) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUIVALENCE-COLLECTIONS"
    "(DEFUN EQUIVALENCE-COLLECTIONS ((COLLECTION1 LOGIC-OBJECT) (COLLECTION2 LOGIC-OBJECT)))"
    (CL:FUNCTION EQUIVALENCE-COLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "REVISE-EQUIVALENCES"
    "(DEFUN REVISE-EQUIVALENCES ((PROPOSITION PROPOSITION) (GOESTRUE? BOOLEAN)))"
    (CL:FUNCTION REVISE-EQUIVALENCES) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-EQUATING-PROPOSITION"
    "(DEFUN (FIND-EQUATING-PROPOSITION PROPOSITION) ((DIRECTOBJECT OBJECT) (INDIRECTOBJECT LOGIC-OBJECT)))"
    (CL:FUNCTION FIND-EQUATING-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-TERM"
    "(DEFUN (EVALUATE-TERM OBJECT) ((SELF OBJECT)))"
    (CL:FUNCTION EVALUATE-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-LITERAL-WRAPPER-TERM"
    "(DEFUN (EVALUATE-LITERAL-WRAPPER-TERM OBJECT) ((SELF LITERAL-WRAPPER)))"
    (CL:FUNCTION EVALUATE-LITERAL-WRAPPER-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-SURROGATE-TERM"
    "(DEFUN (EVALUATE-SURROGATE-TERM OBJECT) ((SELF SURROGATE)))"
    (CL:FUNCTION EVALUATE-SURROGATE-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-LOGIC-OBJECT-TERM"
    "(DEFUN (EVALUATE-LOGIC-OBJECT-TERM OBJECT) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION EVALUATE-LOGIC-OBJECT-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "ANONYMOUS-VARIABLE?"
    "(DEFUN (ANONYMOUS-VARIABLE? BOOLEAN) ((SELF SKOLEM)))"
    (CL:FUNCTION ANONYMOUS-VARIABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-SYMBOL-TERM"
    "(DEFUN (EVALUATE-SYMBOL-TERM OBJECT) ((SELF SYMBOL)))"
    (CL:FUNCTION EVALUATE-SYMBOL-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-AUTOMATIC-INSTANCE"
    "(DEFUN (EVALUATE-AUTOMATIC-INSTANCE OBJECT) ((NAME SYMBOL)))"
    (CL:FUNCTION EVALUATE-AUTOMATIC-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-UNDEFINED-TERM"
    "(DEFUN SIGNAL-UNDEFINED-TERM ((TERM OBJECT)))"
    (CL:FUNCTION SIGNAL-UNDEFINED-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-UNTYPED-TERM"
    "(DEFUN SIGNAL-UNTYPED-TERM ((TERM OBJECT)))"
    (CL:FUNCTION SIGNAL-UNTYPED-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-CREATE-TERM"
    "(DEFUN (EVALUATE-CREATE-TERM OBJECT) ((TERM CONS)))"
    (CL:FUNCTION EVALUATE-CREATE-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE"
    "(DEFUN (CREATE OBJECT) ((NAME GENERALIZED-SYMBOL) |&REST| (TYPE GENERALIZED-SYMBOL)) :DOCUMENTATION \"Create a logic object with name 'name' and return it.
If `type' is also supplied, assert that the object belongs to that type.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %CREATE) (CL:FUNCTION CREATE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "UPDATE-SKOLEM-TYPE"
    "(DEFUN UPDATE-SKOLEM-TYPE ((SELF SKOLEM) (TYPE TYPE)))"
    (CL:FUNCTION UPDATE-SKOLEM-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS"
    "(DEFUN UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS ((SELF PROPOSITION)))"
    (CL:FUNCTION UPDATE-SKOLEM-TYPE-FROM-ISA-ASSERTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "DESCRIPTION-EXTENSION<"
    "(DEFUN (DESCRIPTION-EXTENSION< BOOLEAN) ((DESC1 DESCRIPTION) (DESC2 DESCRIPTION)))"
    (CL:FUNCTION DESCRIPTION-EXTENSION<) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-EXTENSION-SIZES"
    "(DEFUN PRINT-EXTENSION-SIZES ((MODULE MODULE) (SIZECUTOFF INTEGER)) :DOCUMENTATION \"Print the extension sizes of concepts visible in `module'.
If `module' is NULL the current module is used.  Do not report extensions
with size less than `sizeCutoff' (default is 10).\" :PUBLIC? TRUE)"
    (CL:FUNCTION PRINT-EXTENSION-SIZES) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK"
    "(DEFUN TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK ((RELATIONSLIST (LIST OF RELATION))))"
    (CL:FUNCTION TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRACT-RELATION-AXIOMS"
    "(DEFUN RETRACT-RELATION-AXIOMS ((OLDRELATION NAMED-DESCRIPTION)))"
    (CL:FUNCTION RETRACT-RELATION-AXIOMS) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION"
    "(DEFUN (ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION PROPOSITION) ((SUB DESCRIPTION) (SUPER DESCRIPTION) (DONTUPDATE? BOOLEAN)))"
    (CL:FUNCTION ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS"
    "(DEFUN (ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS PROPOSITION) ((SUB NAMED-DESCRIPTION) (SUPER NAMED-DESCRIPTION)))"
    (CL:FUNCTION ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-SUPERRELATION-LINKS"
    "(DEFUN FINALIZE-SUPERRELATION-LINKS ((SELF RELATION)))"
    (CL:FUNCTION FINALIZE-SUPERRELATION-LINKS) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-ISA-PROPOSITION"
    "(DEFUN (UPDATE-ISA-PROPOSITION PROPOSITION) ((SELF OBJECT) (TYPE TYPE) (UPDATEMODE KEYWORD)) :PUBLIC? TRUE)"
    (CL:FUNCTION UPDATE-ISA-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-ISA-PROPOSITION"
    "(DEFUN (ASSERT-ISA-PROPOSITION PROPOSITION) ((SELF OBJECT) (TYPE TYPE)) :PUBLIC? TRUE)"
    (CL:FUNCTION ASSERT-ISA-PROPOSITION) NULL)))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS9 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "UPDATE-PROPERTY"
    "(DEFUN (UPDATE-PROPERTY PROPOSITION) ((SELF LOGIC-OBJECT) (SURROGATE SURROGATE) (UPDATEMODE KEYWORD)) :PUBLIC? TRUE)"
    (CL:FUNCTION UPDATE-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-PROPERTY"
    "(DEFUN (ASSERT-PROPERTY PROPOSITION) ((INSTANCE LOGIC-OBJECT) (PROPERTY SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION ASSERT-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-TUPLE"
    "(DEFUN (UPDATE-TUPLE PROPOSITION) ((RELATION SURROGATE) (ARGUMENTS (CONS OF OBJECT)) (UPDATEMODE KEYWORD)) :PUBLIC? TRUE)"
    (CL:FUNCTION UPDATE-TUPLE) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-TUPLE"
    "(DEFUN (ASSERT-TUPLE PROPOSITION) ((RELATION SURROGATE) (ARGUMENTS (CONS OF OBJECT))) :PUBLIC? TRUE)"
    (CL:FUNCTION ASSERT-TUPLE) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-BINARY-VALUE"
    "(DEFUN (UPDATE-BINARY-VALUE PROPOSITION) ((RELATION SURROGATE) (SELF OBJECT) (VALUE OBJECT) (UPDATEMODE KEYWORD)) :PUBLIC? TRUE)"
    (CL:FUNCTION UPDATE-BINARY-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-BINARY-VALUE"
    "(DEFUN (ASSERT-BINARY-VALUE PROPOSITION) ((RELATION SURROGATE) (SELF OBJECT) (VALUE OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION ASSERT-BINARY-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRACT-BINARY-VALUE"
    "(DEFUN (RETRACT-BINARY-VALUE PROPOSITION) ((RELATION SURROGATE) (SELF OBJECT) (VALUE OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION RETRACT-BINARY-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT-MEMBER-OF-PROPOSITION"
    "(DEFUN (ASSERT-MEMBER-OF-PROPOSITION PROPOSITION) ((SELF OBJECT) (COLLECTION OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION ASSERT-MEMBER-OF-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-LOGIC-INSTANCE"
    "(DEFUN (CREATE-LOGIC-INSTANCE OBJECT) ((NAME SURROGATE) (TYPE SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-LOGIC-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-EXACT-DUPLICATE-PROPOSITION"
    "(DEFUN (FIND-EXACT-DUPLICATE-PROPOSITION PROPOSITION) ((SELF PROPOSITION)))"
    (CL:FUNCTION FIND-EXACT-DUPLICATE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-DUPLICATE-PROPOSITION"
    "(DEFUN (FIND-DUPLICATE-PROPOSITION PROPOSITION) ((SELF PROPOSITION)))"
    (CL:FUNCTION FIND-DUPLICATE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FASTEN-DOWN-ONE-PROPOSITION"
    "(DEFUN (FASTEN-DOWN-ONE-PROPOSITION PROPOSITION) ((SELF PROPOSITION) (DONT-CHECK-FOR-DUPLICATES BOOLEAN)))"
    (CL:FUNCTION FASTEN-DOWN-ONE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-FASTEN-DOWN-PROPOSITIONS"
    "(DEFUN (HELP-FASTEN-DOWN-PROPOSITIONS PROPOSITION) ((SELF PROPOSITION) (DONT-CHECK-FOR-DUPLICATES BOOLEAN)))"
    (CL:FUNCTION HELP-FASTEN-DOWN-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "RECURSIVELY-FASTEN-DOWN-PROPOSITIONS"
    "(DEFUN (RECURSIVELY-FASTEN-DOWN-PROPOSITIONS PROPOSITION) ((SELF PROPOSITION) (DONT-CHECK-FOR-DUPLICATES BOOLEAN)))"
    (CL:FUNCTION RECURSIVELY-FASTEN-DOWN-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "UNFASTEN-PROPOSITION"
    "(DEFUN UNFASTEN-PROPOSITION ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION UNFASTEN-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "INSTANTIATE-UNDEFINED-SURROGATES"
    "(DEFUN INSTANTIATE-UNDEFINED-SURROGATES ((SELF PROPOSITION)))"
    (CL:FUNCTION INSTANTIATE-UNDEFINED-SURROGATES) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-TOP-LEVEL-PROPOSITION"
    "(DEFUN (BUILD-TOP-LEVEL-PROPOSITION PROPOSITION) ((TREE OBJECT) (TRUEASSERTION? BOOLEAN)))"
    (CL:FUNCTION BUILD-TOP-LEVEL-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-PROPOSITION"
    "(DEFUN (BUILD-PROPOSITION OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION BUILD-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "SURROGATE.BUILD-PROPOSITION"
    "(DEFUN (SURROGATE.BUILD-PROPOSITION PROPOSITION) ((SELF SURROGATE)))"
    (CL:FUNCTION SURROGATE.BUILD-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "SYMBOL.BUILD-PROPOSITION"
    "(DEFUN (SYMBOL.BUILD-PROPOSITION OBJECT) ((SYMBOL SYMBOL)))"
    (CL:FUNCTION SYMBOL.BUILD-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "CONS.BUILD-PROPOSITION"
    "(DEFUN (CONS.BUILD-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION CONS.BUILD-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS"
    "(DEFUN VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS ((TREE CONS) (CORRECTNUMBER INTEGER)))"
    (CL:FUNCTION VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DESCRIPTION-SURROGATE TYPE) ((SELF DESCRIPTION)))"
    (CL:FUNCTION DESCRIPTION-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-ISA-PROPOSITION"
    "(DEFUN (BUILD-ISA-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-ISA-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-MEMBER-OF-PROPOSITION"
    "(DEFUN (BUILD-MEMBER-OF-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-MEMBER-OF-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "MEMBER-OF-PROPOSITION?"
    "(DEFUN (MEMBER-OF-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)) :GLOBALLY-INLINE? TRUE (RETURN (EQL? (OPERATOR PROPOSITION) /PL-KERNEL-KB/@MEMBER-OF)))"
    (CL:FUNCTION MEMBER-OF-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "SUBSET-OF-PROPOSITION?"
    "(DEFUN (SUBSET-OF-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)) :GLOBALLY-INLINE? TRUE (RETURN (EQL? (OPERATOR PROPOSITION) /PL-KERNEL-KB/@SUBSET-OF)))"
    (CL:FUNCTION SUBSET-OF-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXTRACT-DECORATION"
    "(DEFUN (EXTRACT-DECORATION OBJECT OBJECT) ((TREE OBJECT) (OPTION SYMBOL)))"
    (CL:FUNCTION EXTRACT-DECORATION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-DECORATED-PROPOSITION"
    "(DEFUN (BUILD-DECORATED-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-DECORATED-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FUNCTION-INDUCED-EXISTS?"
    "(DEFUN (FUNCTION-INDUCED-EXISTS? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION FUNCTION-INDUCED-EXISTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "PREDICATE-OF-FUNCTION-INDUCED-EXISTS"
    "(DEFUN (PREDICATE-OF-FUNCTION-INDUCED-EXISTS PROPOSITION) ((EXISTSPROPOSITION PROPOSITION)))"
    (CL:FUNCTION PREDICATE-OF-FUNCTION-INDUCED-EXISTS) NULL)
   (DEFINE-FUNCTION-OBJECT "EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS"
    "(DEFUN (EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS PROPOSITION) ((EXISTSPROPOSITION PROPOSITION)))"
    (CL:FUNCTION EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-AND-OR-NOT-PROPOSITION"
    "(DEFUN (BUILD-AND-OR-NOT-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-AND-OR-NOT-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FUNCTIONAL-TERM?"
    "(DEFUN (FUNCTIONAL-TERM? BOOLEAN) ((TERM OBJECT)))"
    (CL:FUNCTION FUNCTIONAL-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLIP-VALUE?"
    "(DEFUN (CLIP-VALUE? BOOLEAN) ((TERM1 OBJECT) (TERM2 OBJECT)))"
    (CL:FUNCTION CLIP-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-EQUIVALENCE-PROPOSITION"
    "(DEFUN (CREATE-EQUIVALENCE-PROPOSITION PROPOSITION) ((TERM1 OBJECT) (TERM2 OBJECT)))"
    (CL:FUNCTION CREATE-EQUIVALENCE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-EQUIVALENCE-PROPOSITION"
    "(DEFUN (BUILD-EQUIVALENCE-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-EQUIVALENCE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS"
    "(DEFUN (BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS PROPOSITION) ((REMAININGTERMS CONS) (EQUIVALENCES (CONS OF PROPOSITION))))"
    (CL:FUNCTION BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-FAIL-PROPOSITION"
    "(DEFUN (BUILD-FAIL-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-FAIL-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-COLLECT-INTO-PROPOSITION"
    "(DEFUN (BUILD-COLLECT-INTO-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-COLLECT-INTO-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "HOLDS-OPERATOR?"
    "(DEFUN (HOLDS-OPERATOR? BOOLEAN) ((OPERATOR OBJECT)))"
    (CL:FUNCTION HOLDS-OPERATOR?) NULL)
   (DEFINE-FUNCTION-OBJECT "VERIFY-EVALUABLE-OPERATOR"
    "(DEFUN VERIFY-EVALUABLE-OPERATOR ((OPERATOR OBJECT) (KIND KEYWORD)))"
    (CL:FUNCTION VERIFY-EVALUABLE-OPERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-HOLDS-PROPOSITION"
    "(DEFUN (BUILD-HOLDS-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-HOLDS-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "MOST-GENERAL-EQUIVALENT-SLOTREF"
    "(DEFUN (MOST-GENERAL-EQUIVALENT-SLOTREF SURROGATE) ((SURROGATE SURROGATE)))"
    (CL:FUNCTION MOST-GENERAL-EQUIVALENT-SLOTREF) NULL)
   (DEFINE-FUNCTION-OBJECT "NON-POLYMORPHIC-PREDICATE?"
    "(DEFUN (NON-POLYMORPHIC-PREDICATE? BOOLEAN) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION NON-POLYMORPHIC-PREDICATE?) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-PREDICATE"
    "(DEFUN (EVALUATE-PREDICATE LOGIC-OBJECT) ((NAME GENERALIZED-SYMBOL) (FIRSTARGUMENT OBJECT)))"
    (CL:FUNCTION EVALUATE-PREDICATE) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-TYPED-ARGUMENT"
    "(DEFUN (EVALUATE-TYPED-ARGUMENT OBJECT) ((ARGUMENT OBJECT) (TYPE SURROGATE)))"
    (CL:FUNCTION EVALUATE-TYPED-ARGUMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-FIRST-ARGUMENT"
    "(DEFUN (EVALUATE-FIRST-ARGUMENT OBJECT) ((ARGUMENT OBJECT) (RELATIONNAME SYMBOL)))"
    (CL:FUNCTION EVALUATE-FIRST-ARGUMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-REMAINING-ARGUMENTS"
    "(DEFUN (EVALUATE-REMAINING-ARGUMENTS CONS) ((PREDICATEVALUE LOGIC-OBJECT) (ARGUMENTS CONS)))"
    (CL:FUNCTION EVALUATE-REMAINING-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS-OPERATOR?"
    "(DEFUN (CLASS-OPERATOR? BOOLEAN) ((OPERATOR GENERALIZED-SYMBOL)))"
    (CL:FUNCTION CLASS-OPERATOR?) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-PREDICATE-PROPOSITION"
    "(DEFUN (BUILD-PREDICATE-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-PREDICATE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "CHECK-TYPE?"
    "(DEFUN (CHECK-TYPE? BOOLEAN OBJECT) ((SELF OBJECT) (TYPE SURROGATE) (SHALLOW? BOOLEAN)))"
    (CL:FUNCTION CHECK-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-INCOMPATIBLE-VALUE"
    "(DEFUN (COERCE-INCOMPATIBLE-VALUE OBJECT) ((VALUE OBJECT) (TYPE SURROGATE)))"
    (CL:FUNCTION COERCE-INCOMPATIBLE-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-QUANTITY"
    "(DEFUN (COERCE-QUANTITY OBJECT) ((VALUE OBJECT) (QUANTITYTYPEREF SURROGATE)))"
    (CL:FUNCTION COERCE-QUANTITY) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-DATE"
    "(DEFUN (COERCE-DATE OBJECT) ((VALUE OBJECT) (DATETYPEREF SURROGATE)))"
    (CL:FUNCTION COERCE-DATE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNFINALIZED-RELATION?"
    "(DEFUN (UNFINALIZED-RELATION? BOOLEAN) ((RELATION DESCRIPTION)))"
    (CL:FUNCTION UNFINALIZED-RELATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "VERIFY-ONE-ARGUMENT-TYPE"
    "(DEFUN VERIFY-ONE-ARGUMENT-TYPE ((ARG OBJECT) (TYPE SURROGATE) (PROPOSITION PROPOSITION) (DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION VERIFY-ONE-ARGUMENT-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "VERIFY-ARGUMENT-TYPES-AND-COUNT"
    "(DEFUN VERIFY-ARGUMENT-TYPES-AND-COUNT ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION VERIFY-ARGUMENT-TYPES-AND-COUNT) NULL)
   (DEFINE-FUNCTION-OBJECT "HANDLE-ARGUMENT-TYPE-VIOLATION"
    "(DEFUN HANDLE-ARGUMENT-TYPE-VIOLATION ((PROPOSITION PROPOSITION) (ARG OBJECT) (REQUIREDTYPE SURROGATE)))"
    (CL:FUNCTION HANDLE-ARGUMENT-TYPE-VIOLATION) NULL)
   (DEFINE-FUNCTION-OBJECT "HANDLE-ARITY-VIOLATION"
    "(DEFUN HANDLE-ARITY-VIOLATION ((PROPOSITION PROPOSITION) (REQUIREDARITY INTEGER)))"
    (CL:FUNCTION HANDLE-ARITY-VIOLATION) NULL)))

(CL:DEFUN HELP-STARTUP-PROPOSITIONS10 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "POST-TO-CHECK-TYPES-AGENDA"
    "(DEFUN POST-TO-CHECK-TYPES-AGENDA ((SELF PROPOSITION)))"
    (CL:FUNCTION POST-TO-CHECK-TYPES-AGENDA) NULL)
   (DEFINE-FUNCTION-OBJECT "PROCESS-CHECK-TYPES-AGENDA"
    "(DEFUN PROCESS-CHECK-TYPES-AGENDA ())"
    (CL:FUNCTION PROCESS-CHECK-TYPES-AGENDA) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-EXISTS-PROPOSITION"
    "(DEFUN (BUILD-EXISTS-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-EXISTS-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "TOP-LEVEL-EXISTS-PROPOSITION?"
    "(DEFUN (TOP-LEVEL-EXISTS-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION TOP-LEVEL-EXISTS-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-SKOLEMIZED-EXISTS-VARIABLES"
    "(DEFUN (COLLECT-SKOLEMIZED-EXISTS-VARIABLES (VECTOR OF SKOLEM)) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION COLLECT-SKOLEMIZED-EXISTS-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES?"
    "(DEFUN (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? BOOLEAN) ((PROPOSITION PROPOSITION) (RESULT (LIST OF SKOLEM))))"
    (CL:FUNCTION HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES?) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-FORALL-PROPOSITION"
    "(DEFUN (BUILD-FORALL-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-FORALL-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT"
    "(DEFUN (MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT OBJECT) ((ARG1 OBJECT) (ARG2 OBJECT)))"
    (CL:FUNCTION MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-IMPLIES-PROPOSITION"
    "(DEFUN (CREATE-IMPLIES-PROPOSITION PROPOSITION) ((TAIL OBJECT) (HEAD OBJECT)))"
    (CL:FUNCTION CREATE-IMPLIES-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-IMPLIES-PROPOSITION"
    "(DEFUN (BUILD-IMPLIES-PROPOSITION PROPOSITION) ((TREE CONS)))"
    (CL:FUNCTION BUILD-IMPLIES-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-DUPLICATE-FUNCTION-PROPOSITION"
    "(DEFUN (FIND-DUPLICATE-FUNCTION-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION FIND-DUPLICATE-FUNCTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWRAP-WRAPPED-TYPE"
    "(DEFUN (UNWRAP-WRAPPED-TYPE TYPE) ((TYPE TYPE)))"
    (CL:FUNCTION UNWRAP-WRAPPED-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "BEGIN-CREATING-FUNCTION-PROPOSITION"
    "(DEFUN (BEGIN-CREATING-FUNCTION-PROPOSITION PROPOSITION) ((SURROGATE GENERALIZED-SYMBOL) (INPUTARGUMENTS CONS)))"
    (CL:FUNCTION BEGIN-CREATING-FUNCTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FINISH-CREATING-FUNCTION-PROPOSITION"
    "(DEFUN (FINISH-CREATING-FUNCTION-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION FINISH-CREATING-FUNCTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-OR-CREATE-FUNCTION-PROPOSITION"
    "(DEFUN (FIND-OR-CREATE-FUNCTION-PROPOSITION PROPOSITION) ((PREDICATE GENERALIZED-SYMBOL) (INPUTARGUMENTS CONS)))"
    (CL:FUNCTION FIND-OR-CREATE-FUNCTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-FUNCTION-PROPOSITION"
    "(DEFUN (CREATE-FUNCTION-PROPOSITION PROPOSITION) ((PREDICATE GENERALIZED-SYMBOL) (INPUTARGUMENTS CONS)))"
    (CL:FUNCTION CREATE-FUNCTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-FUNCTION-TERM"
    "(DEFUN (EVALUATE-FUNCTION-TERM OBJECT) ((TREE CONS)))"
    (CL:FUNCTION EVALUATE-FUNCTION-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "EXTENSIONAL-INDIVIDUAL?"
    "(DEFUN (EXTENSIONAL-INDIVIDUAL? BOOLEAN) ((INDIVIDUAL OBJECT)))"
    (CL:FUNCTION EXTENSIONAL-INDIVIDUAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "FUNCTION-WITH-DEFINED-VALUE?"
    "(DEFUN (FUNCTION-WITH-DEFINED-VALUE? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION FUNCTION-WITH-DEFINED-VALUE?) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-LOGICAL-LIST"
    "(DEFUN (CREATE-LOGICAL-LIST SKOLEM) ((LIST LIST)))"
    (CL:FUNCTION CREATE-LOGICAL-LIST) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGICAL-LIST?"
    "(DEFUN (LOGICAL-LIST? BOOLEAN) ((SELF OBJECT)))"
    (CL:FUNCTION LOGICAL-LIST?) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-TRUE-AND-FALSE"
    "(DEFUN (REMOVE-TRUE-AND-FALSE OBJECT BOOLEAN) ((TREE CONS)))"
    (CL:FUNCTION REMOVE-TRUE-AND-FALSE) NULL)
   (DEFINE-FUNCTION-OBJECT "FLATTEN-NESTED-OPERATORS"
    "(DEFUN (FLATTEN-NESTED-OPERATORS OBJECT BOOLEAN) ((TREE CONS)))"
    (CL:FUNCTION FLATTEN-NESTED-OPERATORS) NULL)
   (DEFINE-FUNCTION-OBJECT "CANONICALIZE-AND-OR-TREE"
    "(DEFUN (CANONICALIZE-AND-OR-TREE OBJECT) ((TREE CONS)))"
    (CL:FUNCTION CANONICALIZE-AND-OR-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CANONICALIZE-NEGATION-TREE"
    "(DEFUN (CANONICALIZE-NEGATION-TREE OBJECT) ((TREE CONS)))"
    (CL:FUNCTION CANONICALIZE-NEGATION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "QUANTIFIER-SYMBOL?"
    "(DEFUN (QUANTIFIER-SYMBOL? BOOLEAN) ((SELF SYMBOL)))"
    (CL:FUNCTION QUANTIFIER-SYMBOL?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-VARIABLES-GOAL?"
    "(DEFUN (ALL-VARIABLES-GOAL? BOOLEAN) ((TREE OBJECT)))"
    (CL:FUNCTION ALL-VARIABLES-GOAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUAL-ARGUMENTS?"
    "(DEFUN (EQUAL-ARGUMENTS? BOOLEAN) ((GOAL1 CONS) (GOAL2 CONS)))"
    (CL:FUNCTION EQUAL-ARGUMENTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPLODE-FORALL-TREE"
    "(DEFUN (EXPLODE-FORALL-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION EXPLODE-FORALL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CANONICALIZE-QUANTIFICATION-TREE"
    "(DEFUN (CANONICALIZE-QUANTIFICATION-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CANONICALIZE-QUANTIFICATION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CONS.CANONICALIZE-PROPOSITION-TREE"
    "(DEFUN (CONS.CANONICALIZE-PROPOSITION-TREE OBJECT) ((TREE CONS)))"
    (CL:FUNCTION CONS.CANONICALIZE-PROPOSITION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CANONICALIZE-PROPOSITION-TREE"
    "(DEFUN (CANONICALIZE-PROPOSITION-TREE OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION CANONICALIZE-PROPOSITION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "ERASE-PROPOSITION"
    "(DEFUN ERASE-PROPOSITION ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION ERASE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-EQUIVALENCE-PROPOSITION"
    "(DEFUN (UPDATE-EQUIVALENCE-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION UPDATE-EQUIVALENCE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "SKOLEMIZE-EXISTS-PROPOSITION"
    "(DEFUN (SKOLEMIZE-EXISTS-PROPOSITION PROPOSITION) ((EXISTSPROPOSITION PROPOSITION)))"
    (CL:FUNCTION SKOLEMIZE-EXISTS-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-UPDATE-TOP-LEVEL-PROPOSITION"
    "(DEFUN (HELP-UPDATE-TOP-LEVEL-PROPOSITION (CONS OF PROPOSITION)) ((PROPOSITION PROPOSITION) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION HELP-UPDATE-TOP-LEVEL-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "INVERT-UPDATE-MODE"
    "(DEFUN (INVERT-UPDATE-MODE KEYWORD) ((UPDATEMODE KEYWORD)))"
    (CL:FUNCTION INVERT-UPDATE-MODE) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-TOP-LEVEL-PROPOSITION"
    "(DEFUN (UPDATE-TOP-LEVEL-PROPOSITION (CONS OF PROPOSITION)) ((TREE OBJECT) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION UPDATE-TOP-LEVEL-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-PROPOSITION"
    "(DEFUN (UPDATE-PROPOSITION (CONS OF PROPOSITION)) ((TREE OBJECT) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION UPDATE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-TOP-LEVEL-TERM"
    "(DEFUN (BUILD-TOP-LEVEL-TERM OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION BUILD-TOP-LEVEL-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "CONCEIVE-TERM"
    "(DEFUN (CONCEIVE-TERM OBJECT) ((TREE OBJECT)) :DOCUMENTATION \"tree' is a term expression (a string or an s-expression),
or is a class reference (a symbol or surrogate).  Return a (possibly 
newly-conceived) term representing the internalized representation of that term.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CONCEIVE-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "CONCEIVE-SENTENCE"
    "(DEFUN (CONCEIVE-SENTENCE OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION CONCEIVE-SENTENCE) NULL)
   (DEFINE-FUNCTION-OBJECT "CONCEIVE-FORMULA"
    "(DEFUN (CONCEIVE-FORMULA OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION CONCEIVE-FORMULA) NULL)
   (DEFINE-FUNCTION-OBJECT "SMART-UPDATE-PROPOSITION"
    "(DEFUN (SMART-UPDATE-PROPOSITION OBJECT) ((TREE OBJECT) (UPDATEMODE KEYWORD)))"
    (CL:FUNCTION SMART-UPDATE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "ASSERT"
    "(DEFUN (ASSERT OBJECT) ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Assert the truth of `proposition'.  Return the asserted proposition object.
KIF example:  `(assert (happy Fred))' asserts that Fred is indeed happy.
Note, that for this assertion to succeed, the logic constant `Fred' must
already be defined, e.g., as a side-effect of a type assertion such as
`(assert (Person Fred))', and the relation (or slot) `happy' must be defined
on objects of `Fred's type, e.g., on the class `Person'.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %ASSERT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRESUME"
    "(DEFUN (PRESUME OBJECT) ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Presume the default truth of `proposition'.  Return the presumed
proposition object.  KIF example:  `(presume (happy Fred))' states that Fred
is most probably happy.  Note, that for this to succeed, the logic constant
`Fred' and the relation (or slot) `happy' must already be defined (see
`assert').\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %PRESUME) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRACT"
    "(DEFUN (RETRACT OBJECT) ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Retract the truth of `proposition'.  Return the retracted proposition
object.  KIF example:  `(retract (happy Fred))' retracts that Fred is
happy.  Note, that for this to succeed, the logic constant `Fred' and the
relation (or slot) `happy' must already be defined (see `assert').\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %RETRACT) NULL)
   (DEFINE-FUNCTION-OBJECT "DENY"
    "(DEFUN (DENY OBJECT) ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Assert the falsity of `proposition'.  Return the asserted proposition
object.  KIF example:  `(deny (happy Fred))' asserts that Fred is not happy,
which could have been done equivalently by `(assert (not (happy Fred)))'.
Note, that for this to succeed, the logic constant `Fred' and the
relation (or slot) `happy' must already be defined (see `assert').\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %DENY) NULL)
   (DEFINE-FUNCTION-OBJECT "CONCEIVE"
    "(DEFUN (CONCEIVE OBJECT) ((FORMULA PARSE-TREE)) :DOCUMENTATION \"Guess whether 'formula' represents a term or a sentence/proposition.
If we are not sure, assume its a proposition.
If its, a term, return its internal representation.  If a proposition,
Build 'formula' without asserting its truth value.  Return the
conceived proposition object.  KIF example: `(conceive (happy Fred))' builds
the proposition expressing that Fred is happy without explictly asserting or
denying it.  Note, that for this to succeed, the logic constant `Fred' and
the relation (or slot) `happy' must already be defined (see `assert').\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %CONCEIVE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNASSERT"
    "(DEFUN UNASSERT ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Retract the truth or falsity of `proposition'.  This is a more general
version of `retract' that also handles falsity.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %UNASSERT) NULL)
   (DEFINE-FUNCTION-OBJECT "UNASSERT-FACT"
    "(DEFUN UNASSERT-FACT ((SELF PROPOSITION)) :DOCUMENTATION \"Retract the truth or falsity of the proposition 'self'\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNASSERT-FACT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DELETED? BOOLEAN) ((SELF PROPOSITION)))"
    (CL:FUNCTION DELETED?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DELETED?-SETTER BOOLEAN) ((SELF PROPOSITION) (VALUE BOOLEAN)))"
    (CL:FUNCTION DELETED?-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "DELETED-PROPOSITION?"
    "(DEFUN (DELETED-PROPOSITION? BOOLEAN) ((SELF PROPOSITION)))"
    (CL:FUNCTION DELETED-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-PROPOSITION"
    "(DEFUN (DESTROY-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION)) :DOCUMENTATION \"Retract and destroy the proposition 'proposition'.
Recursively destroy all propositions that reference 'proposition'.
Also, destroy all satellite propositions of 'proposition'.\")"
    (CL:FUNCTION DESTROY-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-LOGIC-INSTANCE"
    "(DEFUN DESTROY-LOGIC-INSTANCE ((SELF OBJECT)))"
    (CL:FUNCTION DESTROY-LOGIC-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-TERM"
    "(DEFUN DESTROY-TERM ((SELF LOGIC-OBJECT)) :DOCUMENTATION \"Destroy all propositions that reference 'self',
and mark it as 'deleted?', thereby making it invisible within class
extensions.  Unlink descriptions from native relations.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DESTROY-TERM) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-INSTANCE"
    "(DEFUN DESTROY-INSTANCE ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Destroy all propositions that reference 'self',
and mark it as 'deleted?', thereby making it invisible within class
extensions.\")" (CL:FUNCTION DESTROY-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATION-IN-MODULE?"
    "(DEFUN (RELATION-IN-MODULE? BOOLEAN) ((SELF NAMED-DESCRIPTION)))"
    (CL:FUNCTION RELATION-IN-MODULE?) NULL)
   (DEFINE-FUNCTION-OBJECT "INTRODUCE-MODULE"
    "(DEFUN INTRODUCE-MODULE ((MODULE MODULE)) :PUBLIC? TRUE)"
    (CL:FUNCTION INTRODUCE-MODULE) NULL)))

(CL:DEFUN STARTUP-PROPOSITIONS ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-PROPOSITIONS1)
    (HELP-STARTUP-PROPOSITIONS2) (HELP-STARTUP-PROPOSITIONS3)
    (HELP-STARTUP-PROPOSITIONS4))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4) (HELP-STARTUP-PROPOSITIONS5))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5) (HELP-STARTUP-PROPOSITIONS6))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-PROPOSITIONS7)
    (HELP-STARTUP-PROPOSITIONS8) (HELP-STARTUP-PROPOSITIONS9)
    (HELP-STARTUP-PROPOSITIONS10)
    (DEFINE-FUNCTION-OBJECT "CLEAR-LOGIC-MODULE-HOOK"
     "(DEFUN CLEAR-LOGIC-MODULE-HOOK ((MODULE MODULE)))"
     (CL:FUNCTION CLEAR-LOGIC-MODULE-HOOK) NULL)
    (DEFINE-FUNCTION-OBJECT "CLEAR-INSTANCES"
     "(DEFUN CLEAR-INSTANCES (|&REST| (NAME NAME)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Destroy all instances belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user.\")" (CL:FUNCTION %CLEAR-INSTANCES)
     (CL:FUNCTION CLEAR-INSTANCES-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "DO-CLEAR-INSTANCES"
     "(DEFUN DO-CLEAR-INSTANCES ((MODULE MODULE)) :DOCUMENTATION \"Function version of `clear-instances' that evaluates its argument.\" :PUBLIC? TRUE)"
     (CL:FUNCTION DO-CLEAR-INSTANCES) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTROY-CONTEXT-HOOK"
     "(DEFUN DESTROY-CONTEXT-HOOK ((SELF CONTEXT)))"
     (CL:FUNCTION DESTROY-CONTEXT-HOOK) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-PROPOSITIONS"
     "(DEFUN STARTUP-PROPOSITIONS () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-PROPOSITIONS) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-PROPOSITIONS-LOGIC-STARTUP-PROPOSITIONS)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-PROPOSITIONS-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "Startup-Propositions") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ZERO-VARIABLES-VECTOR VARIABLES-VECTOR (NEW VARIABLES-VECTOR :ARRAY-SIZE 0) :DOCUMENTATION \"Save space by structure-sharing zero-length variable vectors.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PARTIAL-SUPPORT-COUNTER* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *OPERATOR-NAME-TO-SURROGATE-TABLE* (PROPERTY-LIST OF KEYWORD SURROGATE) (NEW PROPERTY-LIST :THE-PLIST (BQUOTE (:AND /PL-KERNEL-KB/@AND :OR /PL-KERNEL-KB/@OR :NOT /PL-KERNEL-KB/@NOT :FORALL /PL-KERNEL-KB/@FORALL :EXISTS /PL-KERNEL-KB/@EXISTS :EQUIVALENT /PL-KERNEL-KB/@EQUIVALENT :FAIL /PL-KERNEL-KB/@FAIL :COLLECT-INTO /PL-KERNEL-KB/@COLLECT-INTO :IMPLIES /PL-KERNEL-KB/@SUBSET-OF))) :DOCUMENTATION \"Maps names of KIF operators to relational surrogates.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOGIC-MODULE* MODULE (GET-STELLA-MODULE \"LOGIC\" TRUE) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PL-KERNEL-MODULE* MODULE (GET-STELLA-MODULE \"PL-KERNEL\" TRUE) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *NOW-TIMESTAMP* TIMESTAMP 0 :DOCUMENTATION \"The NOW time stamp is incremented whenever a series
of one or more updates is followed by a query.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LAST-KB-ACTION* KEYWORD :UPDATE-PROPOSITION :DOCUMENTATION \"Records whether the last KB access was a query or
an update.  Used to determine when to increment the NOW time stamp
counter.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL BOTTOM LOGIC-OBJECT NULL :PUBLIC? TRUE :DOCUMENTATION \"The undefined individual.  Denotes the non-existence of
an individual in whatever slot it occupies.\")")
    (CL:SETQ BOTTOM (CREATE-SKOLEM NULL SYM-PROPOSITIONS-LOGIC-BOTTOM))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EVALUATIONMODE* KEYWORD :EXTENSIONAL-ASSERTION :DOCUMENTATION \"Indicates the context for evaluating a proposition.  One
of :DESCRIPTION, :INTENSIONAL-ASSERTION, or :EXTENSIONAL-ASSERTION.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CLIPPINGENABLED?* BOOLEAN TRUE :DOCUMENTATION \"When enabled, slot-value assertions can be retracted
by later conflicting assertions.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *NATURALDEDUCTIONMODE?* BOOLEAN TRUE :DOCUMENTATION \"When enabled, blocks normalizations that significantly
change the behavior of inference rules.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CONTEXT-DEPENDENT-SEARCH-MODE?* BOOLEAN FALSE :DOCUMENTATION \"Signals that we are performing search across multiple
contexts.  Used to disable retraction from collections, since that increases
the overhead of the context mechanism.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *COMPUTEDQUERY?* BOOLEAN FALSE :DOCUMENTATION \"Used to signal 'ground-value-of' that it can
call 'bound-to' safely.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SKOLEM-ID-COUNTER* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *VARIABLEIDCOUNTER* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *FREESKOLEMS* CONS NULL :DOCUMENTATION \"Cons-list of top-level existentially-quantified skolems.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT TRUE-TRUTH-VALUE TRUTH-VALUE (NEW TRUTH-VALUE) :DOCUMENTATION \"Value representing TRUE.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT FALSE-TRUTH-VALUE TRUTH-VALUE (NEW TRUTH-VALUE) :DOCUMENTATION \"Value representing FALSE.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT DEFAULT-TRUE-TRUTH-VALUE TRUTH-VALUE (NEW TRUTH-VALUE) :DOCUMENTATION \"Value representing DEFAULT-TRUE.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT DEFAULT-FALSE-TRUTH-VALUE TRUTH-VALUE (NEW TRUTH-VALUE) :DOCUMENTATION \"Value representing DEFAULT-FALSE.\")")
    (CL:SETF (%POSITIVE-SCORE TRUE-TRUTH-VALUE) 1.0d0)
    (CL:SETF (%POSITIVE-SCORE DEFAULT-TRUE-TRUTH-VALUE) 0.99d0)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *SUPPRESSUNTYPEDTYPEERROR?* BOOLEAN FALSE :DOCUMENTATION \"Used by 'safe-logical-type' to ask for a type
without signalling an error if none exists.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EQUIVALENCE-COLLECTIONS?* BOOLEAN TRUE :DOCUMENTATION \"Experiment with equality reasoning on collections.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT TRUE-PROPOSITION PROPOSITION (NEW PROPOSITION :KIND :CONSTANT :OPERATOR @TRUE :ARGUMENTS (NEW ARGUMENTS-VECTOR :ARRAY-SIZE 0) :TRUTH-VALUE TRUE-TRUTH-VALUE))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT FALSE-PROPOSITION PROPOSITION (NEW PROPOSITION :KIND :CONSTANT :OPERATOR @FALSE :ARGUMENTS (NEW ARGUMENTS-VECTOR :ARRAY-SIZE 0) :TRUTH-VALUE FALSE-TRUTH-VALUE))")
    (CL:SETF (%SURROGATE-VALUE SGT-PROPOSITIONS-STELLA-TRUE)
     TRUE-PROPOSITION)
    (CL:SETF (%SURROGATE-VALUE SGT-PROPOSITIONS-STELLA-FALSE)
     FALSE-PROPOSITION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ANONYMOUS-VARIABLE-NAME SYMBOL (QUOTE ?) :DOCUMENTATION \"Variables with name 'ANONYMOUS-VARIABLE-NAME' are considered
anonymous, and are not assumed to be identical to any other variable also named
'ANONYMOUS-VARIABLE-NAME'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MISSING-KEY-VALUE-LIST* KEY-VALUE-LIST (NEW KEY-VALUE-LIST) :DOCUMENTATION \"Represents a key-value list that should never be used.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *AUTOMATICINSTANCETABLE* (KEY-VALUE-LIST OF SYMBOL LOGIC-OBJECT) *MISSING-KEY-VALUE-LIST* :DOCUMENTATION \"Used by 'evaluate-automatic-instance' to
record current bindings of automatic instance symbols.\")")
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-CREATE
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (ADD-HOOK *REDEFINE-RELATION-HOOKS*
     SYM-PROPOSITIONS-LOGIC-TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DEFAULTCREATIONTYPE* SURROGATE NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *STRINGIFIED-PROPOSITION-INDEX* (STRING-HASH-TABLE OF STRING LIST) (NEW STRING-HASH-TABLE) :DOCUMENTATION \"Contains a table of propositions, indexed by their
stringifications.  Tricky: Propositions in two
different modules could have the same stringification but be different.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *VISITEDUNFASTENEDDEFININGPROPOSITIONS* LIST NULL :DOCUMENTATION \"Used by 'recursively-fasten-down-propositions'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TYPE-CHECK-POLICY* KEYWORD :AUTOMATICALLY-FIX-TYPE-VIOLATIONS :DOCUMENTATION \"Two policies are implemented:
   :AUTOMATICALLY-FIX-TYPE-VIOLATIONS 
       'asserts missing types to fix type violations' (default)
   :REPORT-TYPE-VIOLATIONS
       'complain about missing types'\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TYPECHECKMODE* KEYWORD :POST-TYPE-VIOLATIONS :DOCUMENTATION \"Controls the behavior of the type-checking
routines in the event that a type-check fails.  Options are:
  :POST-TYPE-VIOLATIONS               'push offending proposition onto queue'
  :REPORT-TYPE-VIOLATIONS             'print occasions of failed type checks'
  :AUTOMATICALLY-FIX-TYPE-VIOLATIONS  'assert missing types on propositions'\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CHECK-TYPES-AGENDA* (KEY-VALUE-LIST OF PROPOSITION CHECK-TYPES-RECORD) (NEW KEY-VALUE-LIST) :DOCUMENTATION \"List of propositions that have failed a type check,
but might pass once finalization is complete.\")")
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-ASSERT
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-PRESUME
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-ASSERT
     KWD-PROPOSITIONS-CPP KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-RETRACT
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-DENY
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-CONCEIVE
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-UNASSERT
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (ADD-HOOK *DEFINE-MODULE-HOOKS*
     SYM-PROPOSITIONS-LOGIC-INTRODUCE-MODULE)
    (ADD-HOOK *CLEAR-MODULE-HOOKS*
     SYM-PROPOSITIONS-LOGIC-CLEAR-LOGIC-MODULE-HOOK)
    (REGISTER-NATIVE-NAME SYM-PROPOSITIONS-LOGIC-CLEAR-INSTANCES
     KWD-PROPOSITIONS-COMMON-LISP KWD-PROPOSITIONS-FUNCTION)
    (ADD-HOOK *DESTROY-CONTEXT-HOOKS*
     SYM-PROPOSITIONS-LOGIC-DESTROY-CONTEXT-HOOK))))
