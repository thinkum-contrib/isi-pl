;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; kif-out.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-KIF-OUT-KIF NULL)
(CL:DEFVAR KWD-KIF-OUT-STELLA NULL)
(CL:DEFVAR KWD-KIF-OUT-PREFIX-STELLA NULL)
(CL:DEFVAR KWD-KIF-OUT-SQL NULL)
(CL:DEFVAR SGT-KIF-OUT-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-KIF-OUT-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-KIF-OUT-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-KIF-OUT-LOGIC-SKOLEM NULL)
(CL:DEFVAR SGT-KIF-OUT-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-KIF-OUT-STELLA-COLLECTION NULL)
(CL:DEFVAR SGT-KIF-OUT-LOGIC-LOGIC-THING NULL)
(CL:DEFVAR SGT-KIF-OUT-STELLA-THING NULL)
(CL:DEFVAR KWD-KIF-OUT-ISA NULL)
(CL:DEFVAR KWD-KIF-OUT-REALISTIC NULL)
(CL:DEFVAR KWD-KIF-OUT-ORIGINAL NULL)
(CL:DEFVAR KWD-KIF-OUT-UNESCAPED NULL)
(CL:DEFVAR KWD-KIF-OUT-ESCAPED NULL)
(CL:DEFVAR KWD-KIF-OUT-COMPLEX-ESCAPED NULL)
(CL:DEFVAR SGT-KIF-OUT-STELLA-FALSE NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-NOT NULL)
(CL:DEFVAR KWD-KIF-OUT-AND NULL)
(CL:DEFVAR KWD-KIF-OUT-OR NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-AND NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-OR NULL)
(CL:DEFVAR KWD-KIF-OUT-NOT NULL)
(CL:DEFVAR KWD-KIF-OUT-EQUIVALENT NULL)
(CL:DEFVAR KWD-KIF-OUT-PREDICATE NULL)
(CL:DEFVAR KWD-KIF-OUT-FUNCTION NULL)
(CL:DEFVAR KWD-KIF-OUT-IMPLIES NULL)
(CL:DEFVAR KWD-KIF-OUT-FORALL NULL)
(CL:DEFVAR KWD-KIF-OUT-EXISTS NULL)
(CL:DEFVAR KWD-KIF-OUT-CONSTANT NULL)
(CL:DEFVAR KWD-KIF-OUT-CONTAINED-BY NULL)
(CL:DEFVAR KWD-KIF-OUT-DELETED NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-FORWARD-ONLY? NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-<= NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-FORALL NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-EXISTS NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-SETOF NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-LISTOF NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-COMPLEMENT-DESCRIPTION NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-KAPPA NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-=> NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-=>> NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-BACKWARD-ONLY? NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-<<= NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-<~ NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-~> NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-<<~ NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-~>> NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-HIDDEN-RELATION NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-MASTER-PROPOSITION NULL)
(CL:DEFVAR SGT-KIF-OUT-STELLA-LITERAL-WRAPPER NULL)
(CL:DEFVAR KWD-KIF-OUT-TERSE NULL)
(CL:DEFVAR KWD-KIF-OUT-VERBOSE NULL)
(CL:DEFVAR KWD-KIF-OUT-SOURCE NULL)
(CL:DEFVAR KWD-KIF-OUT-SLOTS NULL)
(CL:DEFVAR KWD-KIF-OUT-PUBLIC-SLOTS NULL)
(CL:DEFVAR KWD-KIF-OUT-METHODS NULL)
(CL:DEFVAR KWD-KIF-OUT-PUBLIC-METHODS NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-PRESUME NULL)
(CL:DEFVAR SYM-KIF-OUT-STELLA-ASSERT NULL)
(CL:DEFVAR SYM-KIF-OUT-STELLA-SURROGATE-VALUE-INVERSE NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-DEFRULE NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-IN-DIALECT NULL)
(CL:DEFVAR SGT-KIF-OUT-STELLA-OUTPUT-STREAM NULL)
(CL:DEFVAR SGT-KIF-OUT-LOGIC-OBJECT-STORE NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-UNDECLARED? NULL)
(CL:DEFVAR SGT-KIF-OUT-STELLA-RELATION NULL)
(CL:DEFVAR SGT-KIF-OUT-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SYM-KIF-OUT-STELLA-SAVE-MODULE NULL)
(CL:DEFVAR KWD-KIF-OUT-COMMON-LISP NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-STARTUP-KIF-OUT NULL)
(CL:DEFVAR SYM-KIF-OUT-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* DEFAULT-TRUE-TRUTH-VALUE
  DEFAULT-FALSE-TRUTH-VALUE NIL TRUE-WRAPPER ZERO-VARIABLES-VECTOR
  FALSE-WRAPPER *PRINTFUNCTIONSASRELATIONS?* *PRINTREADABLY?* EOL
  *CURRENTJUSTIFICATION* *PRINTMODE* STANDARD-OUTPUT *LOGIC-DIALECT*
  NULL-INTEGER *MODULE*))

;;; (DEFSPECIAL *PRETTYPRINTLOGICALFORMS?* ...)

(CL:DEFVAR *PRETTYPRINTLOGICALFORMS?* CL:NIL
  "Controls whether logical forms print on single lines
(unformatted) or multi-line indented.")

;;; (DEFSPECIAL *PRETTYPRINTKIF?* ...)

(CL:DEFVAR *PRETTYPRINTKIF?* CL:NIL
  "Controls whether KIF expressions print on single lines
(unformatted) or multi-line indented.")

;;; (DEFSPECIAL *PRINTLOGICALFORMSTREAM* ...)

(CL:DEFVAR *PRINTLOGICALFORMSTREAM* NULL
  "Eliminates necessity of passing stream argument
throughout 'print-logical-form' functions.")

;;; (DEFSPECIAL *DOWNCASEOPERATORS?* ...)

(CL:DEFVAR *DOWNCASEOPERATORS?* CL:NIL
  "Controls whether down-casing happens during logical
form printing (leading to lots more string garbage).")

;;; (DEFGLOBAL *LOGIC-DIALECT-PRINT-FUNCTIONS* ...)

(CL:DEFVAR *LOGIC-DIALECT-PRINT-FUNCTIONS* NULL
  "Table to allow extension of the logical form printing code
by associating keywords with print functions.  Should have values added only
via the associated function REGISTER-LOGIC-DIALECT-PRINT-FUNCTION.")

;;; (DEFUN REGISTER-LOGIC-DIALECT-PRINT-FUNCTION ...)

(CL:DEFUN REGISTER-LOGIC-DIALECT-PRINT-FUNCTION (DIALECT FN)
  "Register `fn' as a logic-object print function for `dialect'.
Each function should have the signature `((self OBJECT) (stream OUTPUT-STREAM))'.
Any return values will be ignored."
  (INSERT-AT *LOGIC-DIALECT-PRINT-FUNCTIONS* DIALECT FN))

;;; (DEFUN (MAYBE-DOWNCASE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  MAYBE-DOWNCASE))
(CL:DEFUN MAYBE-DOWNCASE (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:WHEN (CL:NOT (%MODULE.CASE-SENSITIVE? *MODULE*))
   (CL:WHEN *DOWNCASEOPERATORS?*
    (CL:RETURN-FROM MAYBE-DOWNCASE (STRING-DOWNCASE STRING)))
   (CL:COND
    ((STRING-EQL? STRING "FORALL")
     (CL:RETURN-FROM MAYBE-DOWNCASE "forall"))
    ((STRING-EQL? STRING "EXISTS")
     (CL:RETURN-FROM MAYBE-DOWNCASE "exists"))
    ((STRING-EQL? STRING "THE") (CL:RETURN-FROM MAYBE-DOWNCASE "the"))
    ((STRING-EQL? STRING "AND") (CL:RETURN-FROM MAYBE-DOWNCASE "and"))
    ((STRING-EQL? STRING "OR") (CL:RETURN-FROM MAYBE-DOWNCASE "or"))
    ((STRING-EQL? STRING "NOT") (CL:RETURN-FROM MAYBE-DOWNCASE "not"))
    ((STRING-EQL? STRING "KAPPA")
     (CL:RETURN-FROM MAYBE-DOWNCASE "kappa"))
    ((STRING-EQL? STRING "SUBSET-OF")
     (CL:RETURN-FROM MAYBE-DOWNCASE "subset-of"))
    (CL:T)))
  STRING)

;;; (DEFSPECIAL *INDENTCOUNTER* ...)

(CL:DEFVAR *INDENTCOUNTER* 0
  "The number of spaces prepended during printing a logical form.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))

;;; (DEFGLOBAL *INDENT-QUANTUM* ...)

(CL:DEFVAR *INDENT-QUANTUM* 3
  "The number of spaces added by a call to 'increase-indent'.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *INDENT-QUANTUM*))

;;; (DEFUN INCREASE-INDENT ...)

(CL:DEFUN INCREASE-INDENT (INDENT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
  #+MCL
  (CL:CHECK-TYPE INDENT CL:FIXNUM)
  (CL:WHEN (NULL? INDENT) (CL:SETQ INDENT *INDENT-QUANTUM*))
  (CL:SETQ *INDENTCOUNTER* (CL:+ *INDENTCOUNTER* INDENT)))

;;; (DEFUN DECREASE-INDENT ...)

(CL:DEFUN DECREASE-INDENT (INDENT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
  #+MCL
  (CL:CHECK-TYPE INDENT CL:FIXNUM)
  (CL:WHEN (NULL? INDENT) (CL:SETQ INDENT *INDENT-QUANTUM*))
  (CL:SETQ *INDENTCOUNTER* (CL:- *INDENTCOUNTER* INDENT)))

;;; (DEFUN PRINT-INDENT ...)

(CL:DEFUN PRINT-INDENT (STREAM INDENT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
  #+MCL
  (CL:CHECK-TYPE INDENT CL:FIXNUM)
  (CL:WHEN (NULL? INDENT) (CL:SETQ INDENT *INDENTCOUNTER*))
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 INDENT)
    (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
   (CL:LOOP WHILE
    (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
    (CL:SETQ I ITER-000) (CL:SETQ I I)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")
    (CL:SETQ ITER-000 (CL:1+ ITER-000)))))

;;; (DEFUN PRINT-LOGICAL-FORM-IN-DIALECT ...)

(CL:DEFUN PRINT-LOGICAL-FORM-IN-DIALECT (SELF DIALECT STREAM)
  "Produce a stringified version of a logical representation
of 'self' and write it to the stream 'stream'.  Use the dialect 'dialect',
or use the current dialect if 'dialect' is NULL."
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:RETURN-FROM PRINT-LOGICAL-FORM-IN-DIALECT))
  (CL:WHEN (CL:EQ DIALECT NULL) (CL:SETQ DIALECT *LOGIC-DIALECT*))
  (CL:COND ((CL:EQ DIALECT KWD-KIF-OUT-KIF) (PRINT-AS-KIF SELF STREAM))
   ((CL:OR (CL:EQ DIALECT KWD-KIF-OUT-STELLA)
     (CL:EQ DIALECT KWD-KIF-OUT-PREFIX-STELLA))
    (PRINT-AS-KIF SELF STREAM))
   ((CL:EQ DIALECT KWD-KIF-OUT-SQL))
   (CL:T
    (CL:LET* ((FN (LOOKUP *LOGIC-DIALECT-PRINT-FUNCTIONS* DIALECT)))
     (CL:IF (CL:NOT (CL:EQ FN NULL))
      (CL:FUNCALL (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE FN) SELF
       STREAM)
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "Unknown dialect for printing logic forms: `" DIALECT "'")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN PRINT-LOGICAL-FORM ...)

(CL:DEFUN PRINT-LOGICAL-FORM (FORM STREAM)
  "Print the logical form `form' to `stream' according to
the current setting of `*logic-dialect*'.  Pretty-printing is controlled
by the current setting of `*prettyPrintLogicalForms?*'."
  (PRINT-LOGICAL-FORM-IN-DIALECT FORM *LOGIC-DIALECT* STREAM))

;;; (DEFUN PRETTY-PRINT-LOGICAL-FORM ...)

(CL:DEFUN PRETTY-PRINT-LOGICAL-FORM (FORM STREAM)
  "Pretty-print the logical form `form' to `stream' according
to the current setting of `*logic-dialect*'."
  (CL:LET* ((*PRETTYPRINTLOGICALFORMS?* CL:T))
   (CL:DECLARE (CL:SPECIAL *PRETTYPRINTLOGICALFORMS?*))
   (PRINT-LOGICAL-FORM-IN-DIALECT FORM *LOGIC-DIALECT* STREAM)))

;;; (DEFUN PRINT-UNFORMATTED-LOGICAL-FORM ...)

(CL:DEFUN PRINT-UNFORMATTED-LOGICAL-FORM (FORM STREAM)
  "Print the logical form `form' to `stream' according to
the current setting of `*logic-dialect*'.  Pretty-printing is explicitly
forced to be turned off."
  (CL:LET* ((*PRETTYPRINTLOGICALFORMS?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *PRETTYPRINTLOGICALFORMS?*))
   (PRINT-LOGICAL-FORM-IN-DIALECT FORM *LOGIC-DIALECT* STREAM)))

;;; (DEFUN PRINT-FORMULA ...)

(CL:DEFUN PRINT-FORMULA (FORMULA INDENT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
  #+MCL
  (CL:CHECK-TYPE INDENT CL:FIXNUM)
  (CL:LET* ((*INDENTCOUNTER* INDENT))
   (CL:DECLARE (CL:SPECIAL *INDENTCOUNTER*))
   (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
   (PRINT-UNFORMATTED-LOGICAL-FORM FORMULA STANDARD-OUTPUT)))

;;; (DEFUN PRINT-AS-KIF ...)

(CL:DEFUN PRINT-AS-KIF (SELF STREAM)
  (CL:LET* ((CURRENTINDENTCOUNTER *INDENTCOUNTER*))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURRENTINDENTCOUNTER))
   (CL:LET*
    ((*INDENTCOUNTER* CURRENTINDENTCOUNTER)
     (*PRINTLOGICALFORMSTREAM* STREAM)
     (*PRETTYPRINTKIF?* *PRETTYPRINTLOGICALFORMS?*))
    (CL:DECLARE
     (CL:SPECIAL *INDENTCOUNTER* *PRINTLOGICALFORMSTREAM*
      *PRETTYPRINTKIF?*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
    (PRINT-AS-KIF-INTERNAL SELF))))

;;; (DEFUN PRINT-AS-KIF-INTERNAL ...)

(CL:DEFUN PRINT-AS-KIF-INTERNAL (SELF)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:WHEN (CL:EQ SELF NULL)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "NULL")
    (CL:RETURN-FROM PRINT-AS-KIF-INTERNAL))
   (CL:WHEN (DELETED? SELF)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "DeLeTeD")
    (CL:RETURN-FROM PRINT-AS-KIF-INTERNAL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-PROPOSITION)
      (CL:PROGN (PRINT-KIF-PROPOSITION SELF)))
     ((SUBTYPE-OF-WRAPPER? TEST-VALUE-000)
      (CL:PROGN (PRINT-KIF-WRAPPER SELF)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-DESCRIPTION)
      (CL:PROGN (PRINT-KIF-DESCRIPTION SELF)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-PATTERN-VARIABLE)
      (CL:PROGN (PRINT-KIF-VARIABLE SELF)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-SKOLEM)
      (CL:PROGN (PRINT-KIF-SKOLEM SELF CL:NIL)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-LOGIC-OBJECT)
      (CL:PROGN (PRINT-KIF-LOGIC-OBJECT SELF)))
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        (STRINGIFIED-SURROGATE SELF))))
     ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) SELF)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-STELLA-COLLECTION)
      (CL:PROGN (PRINT-KIF-STELLA-COLLECTION SELF)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-LOGIC-THING)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        (GENERATE-TERM SELF))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-STELLA-THING)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) SELF)))
     (CL:T
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       "|Illegal Logical Form|: " SELF))))))

;;; (DEFUN (VISIBLE-ARGUMENT? BOOLEAN) ...)

(CL:DEFUN VISIBLE-ARGUMENT? (SELF)
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM VISIBLE-ARGUMENT? CL:T))
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
     SGT-KIF-OUT-LOGIC-PROPOSITION)
    (CL:PROGN
     (CL:WHEN
      (CL:AND (CL:EQ (%PROPOSITION.KIND SELF) KWD-KIF-OUT-ISA)
       (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? SELF)))
      (CL:WHEN (CL:NOT (CL:EQ *CURRENTJUSTIFICATION* NULL))
       (CL:RETURN-FROM VISIBLE-ARGUMENT? CL:T))
      (CL:COND
       ((CL:OR (CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC)
         (CL:EQ *PRINTMODE* KWD-KIF-OUT-ORIGINAL))
        (CL:RETURN-FROM VISIBLE-ARGUMENT? CL:NIL))
       (CL:T)))))
   (CL:T))
  CL:T)

;;; (DEFUN (VISIBLE-ARGUMENTS-COUNT INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) VISIBLE-ARGUMENTS-COUNT))
(CL:DEFUN VISIBLE-ARGUMENTS-COUNT (ARGUMENTS)
  (CL:LET* ((COUNT 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:WHEN (VISIBLE-ARGUMENT? ARG) (CL:SETQ COUNT (CL:1+ COUNT)))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   COUNT))

;;; (DEFUN PRINT-KIF-ARGUMENTS ...)

(CL:DEFUN PRINT-KIF-ARGUMENTS (ARGUMENTS SEPARATELINES? OMITLASTARGUMENT?)
  (CL:WHEN (CL:EQ ARGUMENTS NULL) (CL:RETURN-FROM PRINT-KIF-ARGUMENTS))
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (ARGUMENTSITERATOR
     (CL:IF OMITLASTARGUMENT? (BUT-LAST ARGUMENTS)
      (ALLOCATE-ITERATOR ARGUMENTS)))
    (VISIBLEARGCOUNT (VISIBLE-ARGUMENTS-COUNT ARGUMENTS)) (ARGINDEX 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM VISIBLEARGCOUNT ARGINDEX))
   (CL:WHEN
    (CL:AND OMITLASTARGUMENT? (VISIBLE-ARGUMENT? (LAST ARGUMENTS)))
    (CL:SETQ VISIBLEARGCOUNT (CL:1- VISIBLEARGCOUNT)))
   (CL:LET* ((ARG NULL) (ITER-000 ARGUMENTSITERATOR))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ ARG (%ITERATOR.VALUE ITER-000))
     (CL:WHEN (CL:OR (VISIBLE-ARGUMENT? ARG) (CL:= VISIBLEARGCOUNT 0))
      (CL:SETQ ARGINDEX (CL:1+ ARGINDEX))
      (CL:WHEN (CL:> ARGINDEX 1)
       (CL:COND
        ((CL:AND SEPARATELINES? *PRETTYPRINTKIF?*)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
         (PRINT-INDENT STREAM NULL-INTEGER))
        (CL:T
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " "))))
      (PRINT-AS-KIF-INTERNAL ARG))))))

;;; (DEFUN PRINT-KIF-OPERATOR-WITH-ARGUMENTS ...)

(CL:DEFUN PRINT-KIF-OPERATOR-WITH-ARGUMENTS (OPERATOR ARGUMENTS SEPARATELINES? OMITLASTARGUMENT?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OPERATOR))
  #+MCL
  (CL:CHECK-TYPE OPERATOR CL:SIMPLE-STRING)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(" OPERATOR
    (CL:IF (CL:> (LENGTH ARGUMENTS) 0) " " ""))
   (INCREASE-INDENT (CL:+ (CL:THE CL:FIXNUM (CL:LENGTH OPERATOR)) 2))
   (PRINT-KIF-ARGUMENTS ARGUMENTS SEPARATELINES? OMITLASTARGUMENT?)
   (DECREASE-INDENT (CL:+ (CL:THE CL:FIXNUM (CL:LENGTH OPERATOR)) 2))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))

;;; (DEFUN (STRINGIFIED-SURROGATE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) STRINGIFIED-SURROGATE))
(CL:DEFUN STRINGIFIED-SURROGATE (OPERATOR)
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION OPERATOR))
    (STRING STELLA::NULL-STRING)
    (VISIBLE?
     (CL:EQ OPERATOR
      (LOOKUP-SURROGATE-IN-MODULE (%SURROGATE.SYMBOL-NAME OPERATOR)
       *MODULE* CL:NIL))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
   (CL:IF (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:SETQ STRING
     (%SYMBOL.SYMBOL-NAME
      (INTERNAL-STELLA-OPERATOR-TO-KIF
       (SURROGATE-TO-SYMBOL OPERATOR))))
    (CL:SETQ STRING (%SURROGATE.SYMBOL-NAME OPERATOR)))
   (CL:WHEN
    (CL:AND (CL:OR *PRINTREADABLY?* (CL:NOT VISIBLE?))
     (CL:OR (CL:EQ DESCRIPTION NULL)
      (CL:NOT
       (CL:EQL
        (CL:LET ((SELF STRING) (POSITION 0))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION)))
        #\())))
    (CL:LET*
     ((TEST-VALUE-000
       (COMPUTE-SYMBOL-ESCAPE-CODE STRING
        (%MODULE.CASE-SENSITIVE? *MODULE*))))
     (CL:COND
      ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-UNESCAPED)
       (CL:SETQ STRING (MAYBE-DOWNCASE STRING)))
      ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-ESCAPED)
       (CL:SETQ STRING (CONCATENATE "|" STRING "|")))
      ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-COMPLEX-ESCAPED)
       (CL:SETQ STRING (REPLACE-SUBSTRINGS STRING "\\\\" "\\"))
       (CL:SETQ STRING (REPLACE-SUBSTRINGS STRING "\\|" "|"))
       (CL:SETQ STRING (CONCATENATE "|" STRING "|")))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
         TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
   (CL:IF
    (CL:EQ OPERATOR
     (LOOKUP-SURROGATE-IN-MODULE (%SURROGATE.SYMBOL-NAME OPERATOR)
      *MODULE* CL:NIL))
    STRING
    (COMPUTE-FULL-NAME STRING (%SURROGATE.HOME-CONTEXT OPERATOR)))))

;;; (DEFUN (STRINGIFIED-KIF-OPERATOR STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  STRINGIFIED-KIF-OPERATOR))
(CL:DEFUN STRINGIFIED-KIF-OPERATOR (SELF)
  (CL:LET* ((OPERATOR (%PROPOSITION.OPERATOR SELF)))
   (CL:WHEN (CL:EQ OPERATOR NULL)
    (CL:RETURN-FROM STRINGIFIED-KIF-OPERATOR "NULL"))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OPERATOR)))
    (CL:COND
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN (STRINGIFIED-SURROGATE OPERATOR)))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN (MAYBE-DOWNCASE (%SYMBOL.SYMBOL-NAME OPERATOR))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFSPECIAL *TOPLEVELPRINTKIFPROPOSITION?* ...)

(CL:DEFVAR *TOPLEVELPRINTKIFPROPOSITION?* CL:T)

;;; (DEFUN PRINT-KIF-PROPOSITION ...)

(CL:DEFUN PRINT-KIF-PROPOSITION (SELF)
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM PRINT-KIF-PROPOSITION))
  (CL:LET*
   ((TOPLEVEL? *TOPLEVELPRINTKIFPROPOSITION?*)
    (STREAM *PRINTLOGICALFORMSTREAM*)
    (PRINTEXPLICITNEGATION?
     (CL:AND TOPLEVEL? (CL:OR (FALSE? SELF) (DEFAULT-FALSE? SELF))
      (CL:NOT
       (CL:EQ (%PROPOSITION.OPERATOR SELF)
        SGT-KIF-OUT-STELLA-FALSE)))))
   (CL:LET* ((*TOPLEVELPRINTKIFPROPOSITION?* CL:NIL))
    (CL:DECLARE (CL:SPECIAL *TOPLEVELPRINTKIFPROPOSITION?*))
    (CL:WHEN PRINTEXPLICITNEGATION?
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
      (STRINGIFIED-SURROGATE SGT-KIF-OUT-PL-KERNEL-KB-NOT) " ")
     (INCREASE-INDENT 5))
    (CL:IF
     (CL:AND
      (CL:OR (CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC)
       (CL:EQ *PRINTMODE* KWD-KIF-OUT-ORIGINAL))
      TOPLEVEL? (TOP-LEVEL-EXISTS-PROPOSITION? SELF))
     (PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION SELF)
     (HELP-PRINT-KIF-PROPOSITION SELF))
    (CL:WHEN PRINTEXPLICITNEGATION?
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")
     (DECREASE-INDENT 5)))))

;;; (DEFUN HELP-PRINT-KIF-PROPOSITION ...)

(CL:DEFUN HELP-PRINT-KIF-PROPOSITION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*) (OPERATOR STELLA::NULL-STRING)
    (SEPARATELINES? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OPERATOR))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-KIF-OUT-AND)
       (CL:EQ TEST-VALUE-000 KWD-KIF-OUT-OR))
      (CL:IF (CL:EQ (%PROPOSITION.KIND SELF) KWD-KIF-OUT-AND)
       (CL:SETQ OPERATOR
        (STRINGIFIED-SURROGATE SGT-KIF-OUT-PL-KERNEL-KB-AND))
       (CL:SETQ OPERATOR
        (STRINGIFIED-SURROGATE SGT-KIF-OUT-PL-KERNEL-KB-OR)))
      (CL:SETQ SEPARATELINES? CL:T)
      (CL:WHEN
       (CL:= (VISIBLE-ARGUMENTS-COUNT (%PROPOSITION.ARGUMENTS SELF)) 1)
       (CL:COND
        ((CL:OR (CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC)
          (CL:EQ *PRINTMODE* KWD-KIF-OUT-ORIGINAL))
         (PRINT-KIF-ARGUMENTS (%PROPOSITION.ARGUMENTS SELF) CL:NIL
          CL:NIL)
         (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))
        (CL:T))))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-NOT)
      (CL:SETQ OPERATOR
       (STRINGIFIED-SURROGATE SGT-KIF-OUT-PL-KERNEL-KB-NOT)))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-EQUIVALENT)
      (CL:SETQ OPERATOR "="))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-KIF-OUT-ISA)
       (CL:EQ TEST-VALUE-000 KWD-KIF-OUT-PREDICATE))
      (CL:SETQ OPERATOR (STRINGIFIED-KIF-OPERATOR SELF)))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-FUNCTION)
      (CL:IF *PRINTFUNCTIONSASRELATIONS?*
       (CL:SETQ OPERATOR (STRINGIFIED-KIF-OPERATOR SELF))
       (CL:PROGN (PRINT-KIF-FUNCTION-PROPOSITION SELF)
        (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-IMPLIES)
      (PRINT-KIF-IMPLIES-PROPOSITION SELF)
      (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-KIF-OUT-FORALL)
       (CL:EQ TEST-VALUE-000 KWD-KIF-OUT-EXISTS))
      (PRINT-KIF-QUANTIFICATION SELF)
      (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-CONSTANT)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (%SURROGATE.SYMBOL-NAME (%PROPOSITION.OPERATOR SELF)))
      (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-CONTAINED-BY)
      (CL:SETQ OPERATOR ":CONTAINED-BY"))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-DELETED)
      (CL:SETQ OPERATOR ":DELETED"))
     (CL:T
      (CL:SETQ OPERATOR
       (%KEYWORD.SYMBOL-NAME (%PROPOSITION.KIND SELF))))))
   (PRINT-KIF-OPERATOR-WITH-ARGUMENTS OPERATOR
    (%PROPOSITION.ARGUMENTS SELF) SEPARATELINES? CL:NIL)))

;;; (DEFUN PRINT-KIF-FUNCTION-PROPOSITION ...)

(CL:DEFUN PRINT-KIF-FUNCTION-PROPOSITION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (DOWNCASEDNAME (STRINGIFIED-KIF-OPERATOR SELF))
    (LASTARGUMENT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      (CL:THE CL:FIXNUM
       (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS SELF)))))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DOWNCASEDNAME))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(= ")
   (PRINT-KIF-OPERATOR-WITH-ARGUMENTS DOWNCASEDNAME
    (%PROPOSITION.ARGUMENTS SELF) CL:NIL CL:T)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")
   (CL:WHEN (CL:NOT (CL:EQ LASTARGUMENT NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE LASTARGUMENT)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-PATTERN-VARIABLE)
       (CL:PROGN (PRINT-KIF-VARIABLE LASTARGUMENT)))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-SKOLEM)
       (CL:PROGN (PRINT-KIF-SKOLEM LASTARGUMENT CL:T)))
      (CL:T (PRINT-AS-KIF-INTERNAL LASTARGUMENT)))))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))

;;; (DEFUN PRINT-KIF-FUNCTION-EXPRESSION ...)

(CL:DEFUN PRINT-KIF-FUNCTION-EXPRESSION (SELF)
  (CL:LET* ((DOWNCASEDNAME (STRINGIFIED-KIF-OPERATOR SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DOWNCASEDNAME))
   (PRINT-KIF-OPERATOR-WITH-ARGUMENTS DOWNCASEDNAME
    (%PROPOSITION.ARGUMENTS SELF) CL:NIL CL:T)))

;;; (DEFUN PRINT-KIF-IMPLIES-PROPOSITION ...)

(CL:DEFUN PRINT-KIF-IMPLIES-PROPOSITION (SELF)
  (CL:LET*
   ((TAILARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      0))
    (HEADARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      1)))
   (CL:IF
    (CL:AND (ISA? HEADARG SGT-KIF-OUT-LOGIC-DESCRIPTION)
     (ISA? TAILARG SGT-KIF-OUT-LOGIC-DESCRIPTION))
    (PRINT-DESCRIPTIONS-AS-KIF-RULE HEADARG TAILARG SELF CL:NIL)
    (PRINT-KIF-OPERATOR-WITH-ARGUMENTS "subset-of"
     (%PROPOSITION.ARGUMENTS SELF) CL:T CL:NIL))))

;;; (DEFUN PRINT-KIF-QUANTIFIED-VARIABLES ...)

(CL:DEFUN PRINT-KIF-QUANTIFIED-VARIABLES (VARIABLES INCLUDETYPES?)
  (CL:WHEN (CL:EQ VARIABLES NULL)
   (CL:RETURN-FROM PRINT-KIF-QUANTIFIED-VARIABLES))
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(")
   (CL:LET*
    ((VBL NULL) (VECTOR-000 VARIABLES) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ VBL
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:LET*
      ((PRINTTYPE?
        (CL:AND INCLUDETYPES?
         (CL:NOT
          (CL:EQ (LOGICAL-TYPE VBL) SGT-KIF-OUT-STELLA-THING)))))
      (CL:WHEN PRINTTYPE?
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VBL)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000
          SGT-KIF-OUT-LOGIC-PATTERN-VARIABLE)
         (CL:PROGN (PRINT-QUANTIFIED-VARIABLE VBL STREAM)))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-SKOLEM)
         (CL:PROGN (PRINT-VALUE-OF-CHAIN VBL STREAM VBL)))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
           TEST-VALUE-000 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
      (CL:WHEN PRINTTYPE?
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " "
        (%SURROGATE.SYMBOL-NAME (LOGICAL-TYPE VBL)) ")"))
      (CL:WHEN (CL:< I (LENGTH VARIABLES))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))

;;; (DEFUN PRINT-KIF-QUANTIFICATION ...)

(CL:DEFUN PRINT-KIF-QUANTIFICATION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (TAIL
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      0))
    (HEAD
     (CL:IF (CL:= (LENGTH (%PROPOSITION.ARGUMENTS SELF)) 2)
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
       1)
      NULL))
    (IMPLICATION? (CL:NOT (CL:EQ HEAD NULL)))
    (IMPLICATIONOPERATOR
     (CL:IF IMPLICATION?
      (CHOOSE-IMPLICATION-OPERATOR SELF
       (%BOOLEAN-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
         SYM-KIF-OUT-LOGIC-FORWARD-ONLY? FALSE-WRAPPER)))
      NULL)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ IMPLICATIONOPERATOR NULL))
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
       SYM-KIF-OUT-LOGIC-FORWARD-ONLY? FALSE-WRAPPER))
     (CL:NOT (CL:EQ IMPLICATIONOPERATOR SGT-KIF-OUT-PL-KERNEL-KB-<=)))
    (CL:LET* ((TEMP TAIL)) (CL:SETQ TAIL HEAD) (CL:SETQ HEAD TEMP)))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-FORALL)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
       (STRINGIFIED-SURROGATE SGT-KIF-OUT-PL-KERNEL-KB-FORALL) " "))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-EXISTS)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
       (STRINGIFIED-SURROGATE SGT-KIF-OUT-PL-KERNEL-KB-EXISTS) " "))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (PRINT-KIF-QUANTIFIED-VARIABLES
    (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
     SYM-KIF-OUT-LOGIC-IO-VARIABLES NULL)
    CL:NIL)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
   (INCREASE-INDENT NULL-INTEGER) (PRINT-INDENT STREAM NULL-INTEGER)
   (CL:WHEN IMPLICATION?
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
     (STRINGIFIED-SURROGATE IMPLICATIONOPERATOR) " ")
    (INCREASE-INDENT
     (CL:+
      (CL:THE CL:FIXNUM
       (CL:LENGTH
        (CL:THE CL:SIMPLE-STRING
         (%SURROGATE.SYMBOL-NAME IMPLICATIONOPERATOR))))
      2))
    (PRINT-KIF-PROPOSITION HEAD)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
    (PRINT-INDENT STREAM NULL-INTEGER))
   (PRINT-KIF-PROPOSITION TAIL)
   (CL:WHEN IMPLICATION?
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")
    (DECREASE-INDENT
     (CL:+
      (CL:THE CL:FIXNUM
       (CL:LENGTH
        (CL:THE CL:SIMPLE-STRING
         (%SURROGATE.SYMBOL-NAME IMPLICATIONOPERATOR))))
      2)))
   (DECREASE-INDENT NULL-INTEGER)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))

;;; (DEFUN PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION ...)

(CL:DEFUN PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION (SELF)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
    (STRINGIFIED-SURROGATE SGT-KIF-OUT-PL-KERNEL-KB-EXISTS) " ")
   (PRINT-KIF-QUANTIFIED-VARIABLES
    (COLLECT-SKOLEMIZED-EXISTS-VARIABLES SELF) CL:NIL)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
   (INCREASE-INDENT NULL-INTEGER) (PRINT-INDENT STREAM NULL-INTEGER)
   (PRINT-KIF-PROPOSITION SELF) (DECREASE-INDENT NULL-INTEGER)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))

;;; (DEFUN PRINT-KIF-WRAPPER ...)

(CL:DEFUN PRINT-KIF-WRAPPER (SELF)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        (%INTEGER-WRAPPER.WRAPPER-VALUE SELF))))
     ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        (%FLOAT-WRAPPER.WRAPPER-VALUE SELF))))
     ((SUBTYPE-OF-BOOLEAN? TEST-VALUE-000)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        (%BOOLEAN-WRAPPER.WRAPPER-VALUE SELF))))
     ((SUBTYPE-OF-STRING? TEST-VALUE-000)
      (CL:PROGN
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) SELF))))
     ((SUBTYPE-OF-CHARACTER? TEST-VALUE-000)
      (CL:PROGN
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) SELF))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN PRINT-KIF-LOGIC-OBJECT ...)

(CL:DEFUN PRINT-KIF-LOGIC-OBJECT (SELF)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:IF
    (CL:NOT (CL:EQ (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE SELF) NULL))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
     (STRINGIFIED-SURROGATE
      (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE SELF)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
     "Unnamed_Object"))))

;;; (DEFUN PRINT-KIF-SKOLEM ...)

(CL:DEFUN PRINT-KIF-SKOLEM (SELF SUPPRESSDEFININGPROPOSITION?)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:COND
    (SUPPRESSDEFININGPROPOSITION? (PRINT-SKOLEM SELF STREAM CL:NIL))
    ((CL:NOT (CL:EQ (%SKOLEM.DEFINING-PROPOSITION SELF) NULL))
     (PRINT-KIF-FUNCTION-EXPRESSION
      (%SKOLEM.DEFINING-PROPOSITION SELF)))
    (CL:T (PRINT-SKOLEM SELF STREAM CL:NIL)))))

;;; (DEFUN PRINT-KIF-VARIABLE ...)

(CL:DEFUN PRINT-KIF-VARIABLE (SELF)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (PRINT-VARIABLE SELF STREAM)))

;;; (DEFUN PRINT-KIF-STELLA-COLLECTION ...)

(CL:DEFUN PRINT-KIF-STELLA-COLLECTION (SELF)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
    (CL:IF (NO-DUPLICATES? SELF)
     (STRINGIFIED-SURROGATE SGT-KIF-OUT-PL-KERNEL-KB-SETOF)
     (STRINGIFIED-SURROGATE SGT-KIF-OUT-PL-KERNEL-KB-LISTOF)))
   (CL:LET* ((M NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ M (%ITERATOR.VALUE ITER-000))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")
     (PRINT-AS-KIF-INTERNAL M)))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))

;;; (DEFUN PRINT-KIF-DESCRIPTION ...)

(CL:DEFUN PRINT-KIF-DESCRIPTION (SELF)
  (CL:LET* ((*QUERYITERATOR* NULL))
   (CL:DECLARE (CL:SPECIAL *QUERYITERATOR*))
   (CL:LET*
    ((STREAM *PRINTLOGICALFORMSTREAM*)
     (COMPLEMENT
      (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
       SYM-KIF-OUT-LOGIC-COMPLEMENT-DESCRIPTION NULL)))
    (CL:COND
     ((CL:NOT (CL:EQ (%DESCRIPTION.SURROGATE-VALUE-INVERSE SELF) NULL))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (STRINGIFIED-SURROGATE
        (%DESCRIPTION.SURROGATE-VALUE-INVERSE SELF))))
     ((CL:AND (CL:NOT (CL:EQ COMPLEMENT NULL))
       (CL:NOT
        (CL:EQ (%DESCRIPTION.SURROGATE-VALUE-INVERSE COMPLEMENT) NULL))
       (CL:NOT
        (CL:OR (CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC)
         (CL:EQ *PRINTMODE* KWD-KIF-OUT-ORIGINAL))))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "not-"
       (STRINGIFIED-SURROGATE
        (%DESCRIPTION.SURROGATE-VALUE-INVERSE COMPLEMENT))))
     (CL:T
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
       (STRINGIFIED-SURROGATE SGT-KIF-OUT-PL-KERNEL-KB-KAPPA) " ")
      (PRINT-KIF-QUANTIFIED-VARIABLES (%DESCRIPTION.IO-VARIABLES SELF)
       CL:T)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")
      (PRINT-KIF-DESCRIPTION-PROPOSITION SELF CL:NIL)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")"))))))

;;; (DEFUN PRINT-KIF-DESCRIPTION-PROPOSITION ...)

(CL:DEFUN PRINT-KIF-DESCRIPTION-PROPOSITION (SELF INVERT?)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (EXISTENTIALS
     (CL:IF
      (CL:> (%VECTOR.ARRAY-SIZE (%DESCRIPTION.INTERNAL-VARIABLES SELF))
       0)
      (COPY-CONS-LIST-TO-VARIABLES-VECTOR
       (TOP-LEVEL-EXISTENTIAL-VARIABLES SELF))
      ZERO-VARIABLES-VECTOR)))
   (CL:WHEN INVERT?
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
     (STRINGIFIED-SURROGATE SGT-KIF-OUT-PL-KERNEL-KB-NOT) " ")
    (INCREASE-INDENT 4))
   (CL:WHEN (CL:> (%VECTOR.ARRAY-SIZE EXISTENTIALS) 0)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
     (STRINGIFIED-SURROGATE SGT-KIF-OUT-PL-KERNEL-KB-EXISTS) " ")
    (PRINT-KIF-QUANTIFIED-VARIABLES EXISTENTIALS CL:NIL)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
    (INCREASE-INDENT NULL-INTEGER) (PRINT-INDENT STREAM NULL-INTEGER))
   (PRINT-AS-KIF-INTERNAL (%DESCRIPTION.PROPOSITION SELF))
   (CL:WHEN (CL:> (%VECTOR.ARRAY-SIZE EXISTENTIALS) 0)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")
    (DECREASE-INDENT NULL-INTEGER))
   (CL:WHEN INVERT?
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")
    (DECREASE-INDENT 4))))

;;; (DEFUN (CHOOSE-IMPLICATION-OPERATOR SURROGATE) ...)

(CL:DEFUN CHOOSE-IMPLICATION-OPERATOR (RULE FORWARD?)
  (CL:LET*
   ((OPERATORPREFIX
     (CL:IF FORWARD? SGT-KIF-OUT-PL-KERNEL-KB-=>
      SGT-KIF-OUT-PL-KERNEL-KB-<=)))
   (CL:COND ((CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC))
    ((CL:AND FORWARD?
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS RULE)
        SYM-KIF-OUT-LOGIC-FORWARD-ONLY? FALSE-WRAPPER)))
     (CL:SETQ OPERATORPREFIX SGT-KIF-OUT-PL-KERNEL-KB-=>>))
    ((CL:AND
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS RULE)
        SYM-KIF-OUT-LOGIC-BACKWARD-ONLY? FALSE-WRAPPER))
      (CL:NOT FORWARD?))
     (CL:SETQ OPERATORPREFIX SGT-KIF-OUT-PL-KERNEL-KB-<<=)))
   (CL:WHEN
    (CL:AND (DEFAULT-TRUE? RULE)
     (CL:NOT (CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC)))
    (CL:COND
     ((CL:EQ OPERATORPREFIX SGT-KIF-OUT-PL-KERNEL-KB-<=)
      (CL:SETQ OPERATORPREFIX SGT-KIF-OUT-PL-KERNEL-KB-<~))
     ((CL:EQ OPERATORPREFIX SGT-KIF-OUT-PL-KERNEL-KB-=>)
      (CL:SETQ OPERATORPREFIX SGT-KIF-OUT-PL-KERNEL-KB-~>))
     ((CL:EQ OPERATORPREFIX SGT-KIF-OUT-PL-KERNEL-KB-<<=)
      (CL:SETQ OPERATORPREFIX SGT-KIF-OUT-PL-KERNEL-KB-<<~))
     ((CL:EQ OPERATORPREFIX SGT-KIF-OUT-PL-KERNEL-KB-=>>)
      (CL:SETQ OPERATORPREFIX SGT-KIF-OUT-PL-KERNEL-KB-~>>))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" OPERATORPREFIX "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   OPERATORPREFIX))

;;; (DEFUN (CREATE-SKOLEM-MAPPING-TABLE ENTITY-MAPPING) ...)

(CL:DEFUN CREATE-SKOLEM-MAPPING-TABLE (OLDVARS NEWVARS)
  (CL:LET* ((MAPPING NULL))
   (CL:LET*
    ((OLDVAR NULL) (VECTOR-000 OLDVARS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (NEWVAR NULL)
     (VECTOR-001 NEWVARS) (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
     DO
     (CL:SETQ OLDVAR
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ NEWVAR
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
       INDEX-001))
     (CL:WHEN
      (CL:NOT
       (CL:EQ (%PATTERN-VARIABLE.SKOLEM-NAME OLDVAR)
        (%PATTERN-VARIABLE.SKOLEM-NAME NEWVAR)))
      (CL:WHEN (CL:EQ MAPPING NULL)
       (CL:SETQ MAPPING (NEW-KEY-VALUE-LIST)))
      (INSERT-AT MAPPING OLDVAR NEWVAR))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
   MAPPING))

;;; (DEFUN PRINT-DESCRIPTIONS-AS-KIF-RULE ...)

(CL:DEFUN PRINT-DESCRIPTIONS-AS-KIF-RULE (HEAD TAIL RULE REVERSEPOLARITY?)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (FORWARDARROW?
     (CL:AND
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS RULE)
        SYM-KIF-OUT-LOGIC-FORWARD-ONLY? FALSE-WRAPPER))
      (CL:NOT REVERSEPOLARITY?)))
    (REVERSEARGUMENTS? (CL:OR FORWARDARROW? REVERSEPOLARITY?))
    (MAPHEADVARIABLES? (NAMED-DESCRIPTION? HEAD))
    (CURRENTINDENTCOUNTER *INDENTCOUNTER*)
    (OPERATORPREFIX (CHOOSE-IMPLICATION-OPERATOR RULE FORWARDARROW?))
    (OPERATORPREFIXINDENT
     (CL:+ 2
      (CL:THE CL:FIXNUM
       (CL:LENGTH
        (CL:THE CL:SIMPLE-STRING
         (%SURROGATE.SYMBOL-NAME OPERATORPREFIX)))))))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM CURRENTINDENTCOUNTER OPERATORPREFIXINDENT))
   (CL:WHEN (CL:OR (DELETED? HEAD) (DELETED? TAIL))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
     "(=> <DeLeTeD ArGuMeNt(S)>)")
    (CL:RETURN-FROM PRINT-DESCRIPTIONS-AS-KIF-RULE))
   (CL:WHEN REVERSEARGUMENTS?
    (CL:LET* ((TEMP HEAD)) (CL:SETQ HEAD TAIL) (CL:SETQ TAIL TEMP))
    (CL:SETQ MAPHEADVARIABLES? (CL:NOT MAPHEADVARIABLES?)))
   (CL:LET* ((*INDENTCOUNTER* CURRENTINDENTCOUNTER))
    (CL:DECLARE (CL:SPECIAL *INDENTCOUNTER*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
     (STRINGIFIED-SURROGATE SGT-KIF-OUT-PL-KERNEL-KB-FORALL) " ")
    (PRINT-KIF-QUANTIFIED-VARIABLES
     (CL:IF MAPHEADVARIABLES? (%DESCRIPTION.IO-VARIABLES TAIL)
      (%DESCRIPTION.IO-VARIABLES HEAD))
     CL:NIL)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
    (INCREASE-INDENT NULL-INTEGER) (PRINT-INDENT STREAM NULL-INTEGER)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
     (STRINGIFIED-SURROGATE OPERATORPREFIX) " ")
    (INCREASE-INDENT OPERATORPREFIXINDENT)
    (CL:LET*
     ((*SKOLEMNAMEMAPPINGTABLE*
       (CL:IF MAPHEADVARIABLES?
        (CREATE-SKOLEM-MAPPING-TABLE (%DESCRIPTION.IO-VARIABLES HEAD)
         (%DESCRIPTION.IO-VARIABLES TAIL))
        NULL)))
     (CL:DECLARE (CL:SPECIAL *SKOLEMNAMEMAPPINGTABLE*))
     (PRINT-KIF-DESCRIPTION-PROPOSITION HEAD REVERSEPOLARITY?))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
    (PRINT-INDENT STREAM NULL-INTEGER)
    (CL:LET*
     ((*SKOLEMNAMEMAPPINGTABLE*
       (CL:IF (CL:NOT MAPHEADVARIABLES?)
        (CREATE-SKOLEM-MAPPING-TABLE (%DESCRIPTION.IO-VARIABLES TAIL)
         (%DESCRIPTION.IO-VARIABLES HEAD))
        NULL)))
     (CL:DECLARE (CL:SPECIAL *SKOLEMNAMEMAPPINGTABLE*))
     (PRINT-KIF-DESCRIPTION-PROPOSITION TAIL REVERSEPOLARITY?))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "))")
    (DECREASE-INDENT OPERATORPREFIXINDENT)
    (DECREASE-INDENT NULL-INTEGER))))

;;; (DEFSPECIAL *EXCLUDEDPROPOSITIONS* ...)

(CL:DEFVAR *EXCLUDEDPROPOSITIONS* NULL
  "List of propositions that shouldn't be saved by `save-module'.")

;;; (DEFUN EXCLUDE-ORIGINATED-PROPOSITIONS ...)

(CL:DEFUN EXCLUDE-ORIGINATED-PROPOSITIONS ()
  (CL:LET* ((D NULL) (ITER-000 (ALL-NAMED-DESCRIPTIONS NULL CL:NIL)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ D (%ITERATOR.VALUE ITER-000))
    (CL:LET*
     ((PROP NULL)
      (ITER-001 (%LIST.THE-CONS-LIST (ORIGINATED-PROPOSITIONS D))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ PROP (%%VALUE ITER-001))
      (INSERT-AT *EXCLUDEDPROPOSITIONS* PROP TRUE-WRAPPER)
      (CL:SETQ ITER-001 (%%REST ITER-001))))))
  (CL:LET*
   ((P NULL)
    (ITER-002
     (ALLOCATE-ITERATOR (LOCALLY-CONCEIVED-PROPOSITIONS *MODULE*))))
   (CL:LOOP WHILE (NEXT? ITER-002) DO
    (CL:SETQ P (%ITERATOR.VALUE ITER-002))
    (CL:WHEN (CL:NOT (CL:EQ (OBJECT-SURROGATE P) NULL))
     (CL:LET*
      ((PROP NULL)
       (ITER-003 (%LIST.THE-CONS-LIST (ORIGINATED-PROPOSITIONS P))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
       (CL:SETQ PROP (%%VALUE ITER-003))
       (INSERT-AT *EXCLUDEDPROPOSITIONS* PROP TRUE-WRAPPER)
       (CL:SETQ ITER-003 (%%REST ITER-003))))))))

;;; (DEFUN (FUNCTION-OUTPUT-SKOLEM? BOOLEAN) ...)

(CL:DEFUN FUNCTION-OUTPUT-SKOLEM? (SELF)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF) SGT-KIF-OUT-LOGIC-SKOLEM)
    (CL:PROGN
     (CL:IF (CL:NOT (CL:EQ (%SKOLEM.DEFINING-PROPOSITION SELF) NULL))
      CL:T CL:NIL)))
   (CL:T CL:NIL)))

;;; (DEFUN (HIDDEN-RELATION? BOOLEAN) ...)

(CL:DEFUN HIDDEN-RELATION? (RELATION-REF)
  (NEXT?
   (ALL-TRUE-DEPENDENT-PROPOSITIONS
    (%SURROGATE.SURROGATE-VALUE RELATION-REF)
    SGT-KIF-OUT-PL-KERNEL-KB-HIDDEN-RELATION CL:NIL)))

;;; (DEFUN (EXCLUDED-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN EXCLUDED-PROPOSITION? (PROPOSITION)
  (CL:WHEN
   (CL:OR (UNKNOWN? PROPOSITION)
    (CL:NOT (CL:EQ (LOOKUP *EXCLUDEDPROPOSITIONS* PROPOSITION) NULL))
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
       SYM-KIF-OUT-LOGIC-MASTER-PROPOSITION NULL)
      NULL)))
   (CL:RETURN-FROM EXCLUDED-PROPOSITION? CL:T))
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-ISA)
     (CL:WHEN
      (CL:OR
       (ISA?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
         0)
        SGT-KIF-OUT-STELLA-LITERAL-WRAPPER)
       (FUNCTION-OUTPUT-SKOLEM?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
         0))
       (HIDDEN-RELATION? (%PROPOSITION.OPERATOR PROPOSITION)))
      (CL:RETURN-FROM EXCLUDED-PROPOSITION? CL:T)))
    ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-FUNCTION)
     (CL:LET* ((LASTARG (LAST (%PROPOSITION.ARGUMENTS PROPOSITION))))
      (CL:WHEN
       (CL:OR
        (CL:AND (SKOLEM? LASTARG) (EQL? (VALUE-OF LASTARG) LASTARG)
         (CL:NOT (TOP-LEVEL-EXISTS-PROPOSITION? PROPOSITION)))
        (HIDDEN-RELATION? (%PROPOSITION.OPERATOR PROPOSITION)))
       (CL:RETURN-FROM EXCLUDED-PROPOSITION? CL:T))))
    ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-PREDICATE)
     (CL:WHEN (HIDDEN-RELATION? (%PROPOSITION.OPERATOR PROPOSITION))
      (CL:RETURN-FROM EXCLUDED-PROPOSITION? CL:T)))
    (CL:T)))
  CL:NIL)

;;; (DEFUN PRETTY-PRINT-NAMED-DESCRIPTION ...)

(CL:DEFUN PRETTY-PRINT-NAMED-DESCRIPTION (SELF STREAM)
  (PRETTY-PRINT-RELATION-DEFINITION-TREE
   (READ-S-EXPRESSION-FROM-STRING (STRINGIFIED-SOURCE SELF)) STREAM))

;;; (DEFMETHOD DESCRIBE-OBJECT ...)

(CL:DEFMETHOD DESCRIBE-OBJECT ((SELF NAMED-DESCRIPTION) STREAM MODE)
  "Prints a description of 'self' to stream 'stream'.  'mode'
can be :terse, :verbose, or :source.  Used by `describe'."
  (CL:COND
   ((CL:EQ MODE KWD-KIF-OUT-TERSE) (DESCRIBE-TERSELY SELF STREAM))
   ((CL:OR (CL:EQ MODE KWD-KIF-OUT-VERBOSE)
     (CL:EQ MODE KWD-KIF-OUT-SOURCE))
    (PRETTY-PRINT-NAMED-DESCRIPTION SELF STREAM))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" MODE "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (STELLA-RELATION-STRINGIFIED-SOURCE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  STELLA-RELATION-STRINGIFIED-SOURCE))
(CL:DEFUN STELLA-RELATION-STRINGIFIED-SOURCE (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
     (CL:PROGN (%CLASS.CLASS-STRINGIFIED-SOURCE SELF)))
    ((SUBTYPE-OF-METHOD-SLOT? TEST-VALUE-000)
     (CL:PROGN (%METHOD-SLOT.METHOD-STRINGIFIED-SOURCE SELF)))
    (CL:T STELLA::NULL-STRING))))

;;; (DEFUN PRETTY-PRINT-RELATION-DEFINITION ...)

(CL:DEFUN PRETTY-PRINT-RELATION-DEFINITION (SELF STREAM)
  (CL:LET*
   ((DEFINITIONSTRING (STELLA-RELATION-STRINGIFIED-SOURCE SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DEFINITIONSTRING))
   (CL:WHEN (CL:NOT (CL:EQ DEFINITIONSTRING STELLA::NULL-STRING))
    (PRETTY-PRINT-RELATION-DEFINITION-TREE
     (READ-S-EXPRESSION-FROM-STRING DEFINITIONSTRING) STREAM))))

;;; (DEFUN PRETTY-PRINT-RELATION-DEFINITION-TREE ...)

(CL:DEFUN PRETTY-PRINT-RELATION-DEFINITION-TREE (TREE STREAM)
  (HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE TREE STREAM 0 2 CL:T)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL))

;;; (DEFUN HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE ...)

(CL:DEFUN HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE (TREE STREAM STARTINDENT KEYINDENT FORCEFIRSTKEYONSEPARATELINE?)
  (CL:DECLARE (CL:TYPE CL:FIXNUM STARTINDENT KEYINDENT))
  #+MCL
  (CL:CHECK-TYPE STARTINDENT CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE KEYINDENT CL:FIXNUM)
  (CL:LET* ((*PRINTREADABLY?* CL:T) (*PRINTPRETTY?* CL:T))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?* *PRINTPRETTY?*))
   (CL:LET* ((VALUE-000 NULL))
    (CL:LET* ((ELEMENT NULL) (ITER-000 TREE))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ ELEMENT (%%VALUE ITER-000))
      (CL:WHEN (KEYWORD? ELEMENT) (CL:SETQ VALUE-000 ELEMENT)
       (CL:RETURN))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:LET* ((NOFHEADERELEMENTS (POSITION TREE VALUE-000 0)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM NOFHEADERELEMENTS))
     (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
      (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000)
       (EXTRACT-OPTIONS TREE NULL))
      (CL:LET* ((OPTIONS SELF-000) (KEYLENGTH NULL-INTEGER))
       (CL:DECLARE (CL:TYPE CL:FIXNUM KEYLENGTH))
       (CL:WHEN (NULL? NOFHEADERELEMENTS)
        (CL:SETQ NOFHEADERELEMENTS (LENGTH TREE)))
       (CL:SETQ FORCEFIRSTKEYONSEPARATELINE?
        (CL:OR FORCEFIRSTKEYONSEPARATELINE? (CL:> (LENGTH OPTIONS) 1)))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(")
       (CL:LET*
        ((ELEMENT NULL) (ITER-001 TREE) (I NULL-INTEGER) (ITER-002 1)
         (UPPER-BOUND-000 NOFHEADERELEMENTS)
         (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-000))
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ ITER-001 NIL))
          (CL:OR UNBOUNDED?-000 (CL:<= ITER-002 UPPER-BOUND-000)))
         DO (CL:SETQ ELEMENT (%%VALUE ITER-001)) (CL:SETQ I ITER-002)
         (CL:WHEN (CL:> I 1)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " "))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ELEMENT)
         (CL:SETQ ITER-001 (%%REST ITER-001))
         (CL:SETQ ITER-002 (CL:1+ ITER-002))))
       (CL:LET*
        ((KEY NULL) (VALUE NULL)
         (ITER-003 (%PROPERTY-LIST.THE-PLIST OPTIONS)) (I NULL-INTEGER)
         (ITER-004 1))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-004))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
         (CL:SETQ KEY (%%VALUE ITER-003))
         (CL:SETQ VALUE (%%VALUE (%%REST ITER-003)))
         (CL:SETQ I ITER-004)
         (CL:COND
          ((CL:AND (CL:= I 1) (CL:NOT FORCEFIRSTKEYONSEPARATELINE?))
           (CL:WHEN (CL:> NOFHEADERELEMENTS 0)
            (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
             " ")))
          (CL:T
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
           (PRINT-INDENT STREAM (CL:+ STARTINDENT KEYINDENT))))
         (CL:COND
          ((SUBTYPE-OF-KEYWORD? (SAFE-PRIMARY-TYPE KEY))
           (CL:PROGN
            (CL:SETQ KEYLENGTH
             (CL:1+
              (CL:THE CL:FIXNUM
               (CL:LENGTH
                (CL:THE CL:SIMPLE-STRING
                 (%KEYWORD.SYMBOL-NAME KEY))))))
            (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ":"
             (%KEYWORD.SYMBOL-NAME KEY))))
          (CL:T (CL:SETQ KEYLENGTH 4)
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) KEY)))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")
         (CL:COND
          ((CL:AND
            (CL:OR (CL:EQ KEY KWD-KIF-OUT-SLOTS)
             (CL:EQ KEY KWD-KIF-OUT-PUBLIC-SLOTS)
             (CL:EQ KEY KWD-KIF-OUT-METHODS)
             (CL:EQ KEY KWD-KIF-OUT-PUBLIC-METHODS))
            (CONS? VALUE))
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(")
           (CL:LET*
            ((ELEMENT NULL) (ITER-005 VALUE) (I NULL-INTEGER)
             (ITER-006 1))
            (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-006))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
             (CL:SETQ ELEMENT (%%VALUE ITER-005)) (CL:SETQ I ITER-006)
             (CL:WHEN (CL:> I 1)
              (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
               EOL)
              (PRINT-INDENT STREAM
               (CL:+ KEYINDENT (CL:+ KEYLENGTH 2))))
             (CL:IF (CONS? ELEMENT)
              (HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE ELEMENT
               STREAM
               (CL:+ STARTINDENT (CL:+ KEYINDENT (CL:+ KEYLENGTH 2)))
               KEYINDENT CL:NIL)
              (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
               VALUE))
             (CL:SETQ ITER-005 (%%REST ITER-005))
             (CL:SETQ ITER-006 (CL:1+ ITER-006))))
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")"))
          (CL:T
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
            VALUE)))
         (CL:SETQ ITER-003 (%%REST (%%REST ITER-003)))
         (CL:SETQ ITER-004 (CL:1+ ITER-004))))
       (CL:LET*
        ((ELEMENT NULL) (ITER-007 (NTH-REST TREE NOFHEADERELEMENTS)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-007 NIL)) DO
         (CL:SETQ ELEMENT (%%VALUE ITER-007))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
         (PRINT-INDENT STREAM KEYINDENT)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ELEMENT)
         (CL:SETQ ITER-007 (%%REST ITER-007))))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")
       (FREE OPTIONS)))))))

;;; (DEFUN PRETTY-PRINT-ASSERTION ...)

(CL:DEFUN PRETTY-PRINT-ASSERTION (PROPOSITION STREAM)
  (CL:LET*
   ((OPERATOR
     (CL:IF
      (DEFAULT-TRUTH-VALUE?
       (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE PROPOSITION)
        (%PROPOSITION.HOME-CONTEXT PROPOSITION) CL:NIL))
      SYM-KIF-OUT-LOGIC-PRESUME SYM-KIF-OUT-STELLA-ASSERT))
    (NAME
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
      SYM-KIF-OUT-STELLA-SURROGATE-VALUE-INVERSE NULL)))
   (CL:WHEN (CL:NOT (CL:EQ NAME NULL))
    (PRETTY-PRINT-NAMED-RULE NAME STREAM)
    (CL:RETURN-FROM PRETTY-PRINT-ASSERTION))
   (CL:LET*
    ((*PRINTMODE* KWD-KIF-OUT-ORIGINAL)
     (*PRINTLOGICALFORMSTREAM* STREAM) (*INDENTCOUNTER* 8))
    (CL:DECLARE
     (CL:SPECIAL *PRINTMODE* *PRINTLOGICALFORMSTREAM* *INDENTCOUNTER*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(" OPERATOR
     " ")
    (PRETTY-PRINT-LOGICAL-FORM PROPOSITION STREAM)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")" EOL))))

;;; (DEFUN PRETTY-PRINT-NAMED-RULE ...)

(CL:DEFUN PRETTY-PRINT-NAMED-RULE (RULENAME STREAM)
  (CL:LET*
   ((OPERATOR SYM-KIF-OUT-LOGIC-DEFRULE)
    (PROPOSITION (%SURROGATE.SURROGATE-VALUE RULENAME)))
   (CL:LET*
    ((*PRINTMODE* KWD-KIF-OUT-ORIGINAL)
     (*PRINTLOGICALFORMSTREAM* STREAM) (*INDENTCOUNTER* 2))
    (CL:DECLARE
     (CL:SPECIAL *PRINTMODE* *PRINTLOGICALFORMSTREAM* *INDENTCOUNTER*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(" OPERATOR
     " "
     (INTERN-SYMBOL-IN-MODULE (%SURROGATE.SYMBOL-NAME RULENAME)
      (%SURROGATE.HOME-CONTEXT RULENAME) CL:T)
     EOL)
    (PRINT-INDENT STREAM NULL-INTEGER)
    (PRETTY-PRINT-LOGICAL-FORM PROPOSITION STREAM)
    (CL:LET*
     ((PROP NULL)
      (ITER-000
       (%LIST.THE-CONS-LIST (ORIGINATED-PROPOSITIONS PROPOSITION))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ PROP (%%VALUE ITER-000))
      (CL:TAGBODY
       (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROP)))
        (CL:COND
         ((CL:OR (CL:EQ TEST-VALUE-000 KWD-KIF-OUT-PREDICATE)
           (CL:EQ TEST-VALUE-000 KWD-KIF-OUT-FUNCTION))
          (CL:WHEN
           (CL:AND (CL:= (LENGTH (%PROPOSITION.ARGUMENTS PROP)) 2)
            (CL:EQ
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROP)))
              0)
             PROPOSITION))
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL
            "  " (KEYWORDIFY (%PROPOSITION.OPERATOR PROP)) " ")
           (PRETTY-PRINT-LOGICAL-FORM
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROP)))
             1)
            STREAM)
           (CL:GO :CONTINUE)))
         (CL:T)))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL
        "  :AXIOMS ")
       (PRETTY-PRINT-LOGICAL-FORM PROP STREAM) :CONTINUE)
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")" EOL))))

;;; (DEFGLOBAL *BUILT-IN-MODULE-NAMES* ...)

(CL:DEFVAR *BUILT-IN-MODULE-NAMES* NULL)

;;; (DEFUN PRINT-MODULE-FILE-HEADER ...)

(CL:DEFUN PRINT-MODULE-FILE-HEADER (MODULE STREAM)
  (CL-OUTPUT-FILE-HEADER STREAM STELLA::NULL-STRING CL:NIL)
  (CL:WHEN
   (CL:NOT
    (MEMBER? *BUILT-IN-MODULE-NAMES* (WRAP-STRING (NAME MODULE))))
   (PRINT-DEFINITION MODULE STREAM))
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(IN-MODULE \""
   (%MODULE.MODULE-FULL-NAME MODULE) "\")" EOL EOL "("
   SYM-KIF-OUT-LOGIC-IN-DIALECT " " *LOGIC-DIALECT* ")" EOL EOL))

;;; (DEFUN PRINT-MODULE-FILE-TRAILER ...)

(CL:DEFUN PRINT-MODULE-FILE-TRAILER (MODULE STREAM)
  (CL:PROGN (CL:SETQ MODULE MODULE) (CL:SETQ STREAM STREAM)))

;;; (DEFMETHOD STORE-NATIVE-RELATION ...)

(CL:DEFMETHOD STORE-NATIVE-RELATION ((STORE OBJECT-STORE) RELATION)
  (CL:SETQ RELATION RELATION)
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "store-native-relation: not implemented on `" STORE "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD STORE-RELATION ...)

(CL:DEFMETHOD STORE-RELATION ((STORE OBJECT-STORE) RELATION)
  (CL:SETQ RELATION RELATION)
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "store-relation: not implemented on `" STORE "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD STORE-ASSERTION ...)

(CL:DEFMETHOD STORE-ASSERTION ((STORE OBJECT-STORE) PROPOSITION)
  (CL:SETQ PROPOSITION PROPOSITION)
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "store-proposition: not implemented on `" STORE "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD STORE-MODULE-HEADER ...)

(CL:DEFMETHOD STORE-MODULE-HEADER ((STORE OBJECT-STORE) MODULE)
  (CL:SETQ MODULE MODULE)
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "store-module-header: not implemented on `" STORE "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD STORE-MODULE-TRAILER ...)

(CL:DEFMETHOD STORE-MODULE-TRAILER ((STORE OBJECT-STORE) MODULE)
  (CL:PROGN (CL:SETQ STORE STORE) (CL:SETQ MODULE MODULE)))

;;; (DEFMETHOD CLEAR-OBJECT-STORE ...)

(CL:DEFMETHOD CLEAR-OBJECT-STORE ((STORE OBJECT-STORE))
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "clear-object-store: not implemented on `" STORE "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFUN SAVE-OBJECT ...)

(CL:DEFUN SAVE-OBJECT (OBJECT STORE)
  (CL:LET* ((TEST-VALUE-003 (SAFE-PRIMARY-TYPE OBJECT)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-003 SGT-KIF-OUT-STELLA-RELATION)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE STORE)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-STELLA-OUTPUT-STREAM)
         (CL:PROGN (PRETTY-PRINT-RELATION-DEFINITION OBJECT STORE)))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-OBJECT-STORE)
         (CL:PROGN (STORE-NATIVE-RELATION STORE OBJECT)))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
           TEST-VALUE-000 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))
    ((SUBTYPE-OF? TEST-VALUE-003 SGT-KIF-OUT-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:WHEN
       (%BOOLEAN-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%NAMED-DESCRIPTION.DYNAMIC-SLOTS OBJECT)
         SYM-KIF-OUT-LOGIC-UNDECLARED? FALSE-WRAPPER))
       (CL:RETURN-FROM SAVE-OBJECT))
      (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE STORE)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-001 SGT-KIF-OUT-STELLA-OUTPUT-STREAM)
         (CL:PROGN (PRETTY-PRINT-NAMED-DESCRIPTION OBJECT STORE)))
        ((SUBTYPE-OF? TEST-VALUE-001 SGT-KIF-OUT-LOGIC-OBJECT-STORE)
         (CL:PROGN (STORE-RELATION STORE OBJECT)))
        (CL:T
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
           TEST-VALUE-001 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))))
    ((SUBTYPE-OF? TEST-VALUE-003 SGT-KIF-OUT-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE STORE)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-002 SGT-KIF-OUT-STELLA-OUTPUT-STREAM)
         (CL:PROGN (PRETTY-PRINT-ASSERTION OBJECT STORE)))
        ((SUBTYPE-OF? TEST-VALUE-002 SGT-KIF-OUT-LOGIC-OBJECT-STORE)
         (CL:PROGN (STORE-ASSERTION STORE OBJECT)))
        (CL:T
         (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002) "`"
           TEST-VALUE-002 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))))))
    (CL:T
     (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003)
       "save-object: Don't know how to save `" OBJECT "' to `" STORE
       "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-003))))))))

;;; (DEFUN DO-SAVE-MODULE ...)

(CL:DEFUN DO-SAVE-MODULE (MODULE STORE)
  "Save `module' to the persistent store `store' which can
either be an output stream or a persistent OBJECT-STORE."
  (CL:LET* ((*PRINTREADABLY?* CL:T))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE STORE)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-STELLA-OUTPUT-STREAM)
       (CL:PROGN (PRINT-MODULE-FILE-HEADER MODULE STORE)))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-OBJECT-STORE)
       (CL:PROGN (STORE-MODULE-HEADER STORE MODULE)))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
         TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (CL:LET*
     ((DESCRIPTION NULL)
      (ITER-000 (ALL-NAMED-DESCRIPTIONS MODULE CL:T)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ DESCRIPTION (%ITERATOR.VALUE ITER-000))
      (CL:IF
       (CL:AND (CLASS-DESCRIPTION? DESCRIPTION)
        (CL:NOT (CL:EQ (NATIVE-RELATION DESCRIPTION) NULL)))
       (CL:LET* ((CLASS (NATIVE-RELATION DESCRIPTION)))
        (SAVE-OBJECT CLASS STORE)
        (CL:LET*
         ((SLOT NULL)
          (ITER-001
           (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS CLASS))))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ SLOT (%%VALUE ITER-001))
          (CL:WHEN
           (CL:NOT
            (CL:EQ (STELLA-RELATION-STRINGIFIED-SOURCE SLOT)
             STELLA::NULL-STRING))
           (SAVE-OBJECT SLOT STORE))
          (CL:SETQ ITER-001 (%%REST ITER-001)))))
       (SAVE-OBJECT DESCRIPTION STORE))))
    (CL:LET* ((FUNCTION NULL) (ITER-002 (ALL-FUNCTIONS MODULE CL:T)))
     (CL:LOOP WHILE (NEXT? ITER-002) DO
      (CL:SETQ FUNCTION (%ITERATOR.VALUE ITER-002))
      (CL:WHEN
       (CL:NOT
        (CL:EQ (STELLA-RELATION-STRINGIFIED-SOURCE FUNCTION)
         STELLA::NULL-STRING))
       (SAVE-OBJECT FUNCTION STORE))))
    (CL:LET* ((*EXCLUDEDPROPOSITIONS* (NEW-HASH-TABLE)))
     (CL:DECLARE (CL:SPECIAL *EXCLUDEDPROPOSITIONS*))
     (EXCLUDE-ORIGINATED-PROPOSITIONS)
     (CL:LET* ((REVERSEDPROPOSITIONS NIL))
      (CL:LET*
       ((P NULL)
        (ITER-003
         (ALLOCATE-ITERATOR (LOCALLY-CONCEIVED-PROPOSITIONS MODULE))))
       (CL:LOOP WHILE (NEXT? ITER-003) DO
        (CL:SETQ P (%ITERATOR.VALUE ITER-003))
        (CL:WHEN (CL:NOT (EXCLUDED-PROPOSITION? P))
         (CL:SETQ REVERSEDPROPOSITIONS
          (CONS P REVERSEDPROPOSITIONS)))))
      (CL:LET* ((P NULL) (ITER-004 REVERSEDPROPOSITIONS))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
        (CL:SETQ P (%%VALUE ITER-004)) (SAVE-OBJECT P STORE)
        (CL:SETQ ITER-004 (%%REST ITER-004))))))
    (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE STORE)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-001 SGT-KIF-OUT-STELLA-OUTPUT-STREAM)
       (CL:PROGN (PRINT-MODULE-FILE-TRAILER MODULE STORE)))
      ((SUBTYPE-OF? TEST-VALUE-001 SGT-KIF-OUT-LOGIC-OBJECT-STORE)
       (CL:PROGN (STORE-MODULE-TRAILER STORE MODULE)))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
         TEST-VALUE-001 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))))

;;; (DEFUN SAVE-MODULE ...)

(CL:DEFUN %SAVE-MODULE (NAME FILE)
  "Save all definitions and assertions of module `name' to `file'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
  #+MCL
  (CL:CHECK-TYPE FILE CL:SIMPLE-STRING)
  (CL:LET* ((MODULE (COERCE-TO-MODULE NAME CL:T)))
   (CL:WHEN (CL:NOT (CL:EQ MODULE NULL))
    (CL:LET* ((STREAM NULL))
     (CL:UNWIND-PROTECT
      (CL:PROGN (CL:SETQ STREAM (OPEN-OUTPUT-FILE FILE))
       (DO-SAVE-MODULE MODULE STREAM))
      (CL:WHEN (CL:NOT (CL:EQ STREAM NULL)) (FREE STREAM)))))))

(CL:DEFUN SAVE-MODULE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SAVE-MODULE (%%VALUE ARGUMENTS)
   (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO SAVE-MODULE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Save all definitions and assertions of module `name' to `file'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/SAVE-MODULE|)) (CL:MACRO-FUNCTION (CL:QUOTE SAVE-MODULE)))

(CL:DEFUN HELP-STARTUP-KIF-OUT1 ()
  (CL:PROGN
   (CL:SETQ KWD-KIF-OUT-KIF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KIF" NULL 2))
   (CL:SETQ KWD-KIF-OUT-STELLA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA" NULL 2))
   (CL:SETQ KWD-KIF-OUT-PREFIX-STELLA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREFIX-STELLA" NULL 2))
   (CL:SETQ KWD-KIF-OUT-SQL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SQL" NULL 2))
   (CL:SETQ SGT-KIF-OUT-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SGT-KIF-OUT-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SGT-KIF-OUT-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-KIF-OUT-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SGT-KIF-OUT-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SGT-KIF-OUT-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-LOGIC-LOGIC-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-THING" NULL 1))
   (CL:SETQ SGT-KIF-OUT-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-KIF-OUT-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ KWD-KIF-OUT-REALISTIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REALISTIC" NULL 2))
   (CL:SETQ KWD-KIF-OUT-ORIGINAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ORIGINAL" NULL 2))
   (CL:SETQ KWD-KIF-OUT-UNESCAPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNESCAPED" NULL 2))
   (CL:SETQ KWD-KIF-OUT-ESCAPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPED" NULL 2))
   (CL:SETQ KWD-KIF-OUT-COMPLEX-ESCAPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEX-ESCAPED" NULL 2))
   (CL:SETQ SGT-KIF-OUT-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-KIF-OUT-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-KIF-OUT-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-KIF-OUT-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-KIF-OUT-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ KWD-KIF-OUT-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-KIF-OUT-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-KIF-OUT-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ KWD-KIF-OUT-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ KWD-KIF-OUT-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ KWD-KIF-OUT-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 2))
   (CL:SETQ KWD-KIF-OUT-CONTAINED-BY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTAINED-BY" NULL 2))
   (CL:SETQ KWD-KIF-OUT-DELETED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DELETED" NULL 2))
   (CL:SETQ SYM-KIF-OUT-LOGIC-FORWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-ONLY?" NULL 0))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-<=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<="
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-KIF-OUT-LOGIC-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-SETOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-LISTOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISTOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-KIF-OUT-LOGIC-COMPLEMENT-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT-DESCRIPTION" NULL 0))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-KAPPA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-=>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=>"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-=>>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=>>"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-KIF-OUT-LOGIC-BACKWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD-ONLY?" NULL 0))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-<<=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<<="
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-<~
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<~"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-~>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "~>"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-<<~
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<<~"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-~>>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "~>>"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-HIDDEN-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HIDDEN-RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-KIF-OUT-LOGIC-MASTER-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
   (CL:SETQ SGT-KIF-OUT-STELLA-LITERAL-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-KIF-OUT-TERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TERSE" NULL 2))
   (CL:SETQ KWD-KIF-OUT-VERBOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBOSE" NULL 2))
   (CL:SETQ KWD-KIF-OUT-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SOURCE" NULL 2))
   (CL:SETQ KWD-KIF-OUT-SLOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTS" NULL 2))
   (CL:SETQ KWD-KIF-OUT-PUBLIC-SLOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC-SLOTS" NULL 2))
   (CL:SETQ KWD-KIF-OUT-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHODS" NULL 2))))

(CL:DEFUN HELP-STARTUP-KIF-OUT2 ()
  (CL:PROGN
   (CL:SETQ KWD-KIF-OUT-PUBLIC-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC-METHODS" NULL 2))
   (CL:SETQ SYM-KIF-OUT-LOGIC-PRESUME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRESUME" NULL 0))
   (CL:SETQ SYM-KIF-OUT-STELLA-ASSERT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-OUT-STELLA-SURROGATE-VALUE-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE-INVERSE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-KIF-OUT-LOGIC-DEFRULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFRULE" NULL 0))
   (CL:SETQ SYM-KIF-OUT-LOGIC-IN-DIALECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN-DIALECT" NULL 0))
   (CL:SETQ SGT-KIF-OUT-STELLA-OUTPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-STREAM"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-LOGIC-OBJECT-STORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-STORE" NULL 1))
   (CL:SETQ SYM-KIF-OUT-LOGIC-UNDECLARED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNDECLARED?" NULL 0))
   (CL:SETQ SGT-KIF-OUT-STELLA-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-KIF-OUT-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SYM-KIF-OUT-STELLA-SAVE-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVE-MODULE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-KIF-OUT-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-KIF-OUT-LOGIC-STARTUP-KIF-OUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-KIF-OUT" NULL 0))
   (CL:SETQ SYM-KIF-OUT-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-KIF-OUT3 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "REGISTER-LOGIC-DIALECT-PRINT-FUNCTION"
    "(DEFUN REGISTER-LOGIC-DIALECT-PRINT-FUNCTION ((DIALECT KEYWORD) (FN FUNCTION-CODE-WRAPPER)) :DOCUMENTATION \"Register `fn' as a logic-object print function for `dialect'.
Each function should have the signature `((self OBJECT) (stream OUTPUT-STREAM))'.
Any return values will be ignored.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REGISTER-LOGIC-DIALECT-PRINT-FUNCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "MAYBE-DOWNCASE"
    "(DEFUN (MAYBE-DOWNCASE STRING) ((STRING STRING)))"
    (CL:FUNCTION MAYBE-DOWNCASE) NULL)
   (DEFINE-FUNCTION-OBJECT "INCREASE-INDENT"
    "(DEFUN INCREASE-INDENT ((INDENT INTEGER)))"
    (CL:FUNCTION INCREASE-INDENT) NULL)
   (DEFINE-FUNCTION-OBJECT "DECREASE-INDENT"
    "(DEFUN DECREASE-INDENT ((INDENT INTEGER)))"
    (CL:FUNCTION DECREASE-INDENT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-INDENT"
    "(DEFUN PRINT-INDENT ((STREAM OUTPUT-STREAM) (INDENT INTEGER)))"
    (CL:FUNCTION PRINT-INDENT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-LOGICAL-FORM-IN-DIALECT"
    "(DEFUN PRINT-LOGICAL-FORM-IN-DIALECT ((SELF OBJECT) (DIALECT KEYWORD) (STREAM OUTPUT-STREAM)) :PUBLIC? TRUE :DOCUMENTATION \"Produce a stringified version of a logical representation
of 'self' and write it to the stream 'stream'.  Use the dialect 'dialect',
or use the current dialect if 'dialect' is NULL.\")"
    (CL:FUNCTION PRINT-LOGICAL-FORM-IN-DIALECT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-LOGICAL-FORM"
    "(DEFUN PRINT-LOGICAL-FORM ((FORM OBJECT) (STREAM OUTPUT-STREAM)) :PUBLIC? TRUE :DOCUMENTATION \"Print the logical form `form' to `stream' according to
the current setting of `*logic-dialect*'.  Pretty-printing is controlled
by the current setting of `*prettyPrintLogicalForms?*'.\")"
    (CL:FUNCTION PRINT-LOGICAL-FORM) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-LOGICAL-FORM"
    "(DEFUN PRETTY-PRINT-LOGICAL-FORM ((FORM OBJECT) (STREAM OUTPUT-STREAM)) :PUBLIC? TRUE :DOCUMENTATION \"Pretty-print the logical form `form' to `stream' according
to the current setting of `*logic-dialect*'.\")"
    (CL:FUNCTION PRETTY-PRINT-LOGICAL-FORM) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-UNFORMATTED-LOGICAL-FORM"
    "(DEFUN PRINT-UNFORMATTED-LOGICAL-FORM ((FORM OBJECT) (STREAM OUTPUT-STREAM)) :PUBLIC? TRUE :DOCUMENTATION \"Print the logical form `form' to `stream' according to
the current setting of `*logic-dialect*'.  Pretty-printing is explicitly
forced to be turned off.\")"
    (CL:FUNCTION PRINT-UNFORMATTED-LOGICAL-FORM) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-FORMULA"
    "(DEFUN PRINT-FORMULA ((FORMULA OBJECT) (INDENT INTEGER)))"
    (CL:FUNCTION PRINT-FORMULA) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-AS-KIF"
    "(DEFUN PRINT-AS-KIF ((SELF OBJECT) (STREAM OUTPUT-STREAM)) :PUBLIC? TRUE)"
    (CL:FUNCTION PRINT-AS-KIF) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-AS-KIF-INTERNAL"
    "(DEFUN PRINT-AS-KIF-INTERNAL ((SELF OBJECT)))"
    (CL:FUNCTION PRINT-AS-KIF-INTERNAL) NULL)
   (DEFINE-FUNCTION-OBJECT "VISIBLE-ARGUMENT?"
    "(DEFUN (VISIBLE-ARGUMENT? BOOLEAN) ((SELF OBJECT)))"
    (CL:FUNCTION VISIBLE-ARGUMENT?) NULL)
   (DEFINE-FUNCTION-OBJECT "VISIBLE-ARGUMENTS-COUNT"
    "(DEFUN (VISIBLE-ARGUMENTS-COUNT INTEGER) ((ARGUMENTS ARGUMENTS-VECTOR)))"
    (CL:FUNCTION VISIBLE-ARGUMENTS-COUNT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-ARGUMENTS"
    "(DEFUN PRINT-KIF-ARGUMENTS ((ARGUMENTS ARGUMENTS-VECTOR) (SEPARATELINES? BOOLEAN) (OMITLASTARGUMENT? BOOLEAN)))"
    (CL:FUNCTION PRINT-KIF-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-OPERATOR-WITH-ARGUMENTS"
    "(DEFUN PRINT-KIF-OPERATOR-WITH-ARGUMENTS ((OPERATOR STRING) (ARGUMENTS ARGUMENTS-VECTOR) (SEPARATELINES? BOOLEAN) (OMITLASTARGUMENT? BOOLEAN)))"
    (CL:FUNCTION PRINT-KIF-OPERATOR-WITH-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "STRINGIFIED-SURROGATE"
    "(DEFUN (STRINGIFIED-SURROGATE STRING) ((OPERATOR SURROGATE)))"
    (CL:FUNCTION STRINGIFIED-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "STRINGIFIED-KIF-OPERATOR"
    "(DEFUN (STRINGIFIED-KIF-OPERATOR STRING) ((SELF PROPOSITION)))"
    (CL:FUNCTION STRINGIFIED-KIF-OPERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-PROPOSITION"
    "(DEFUN PRINT-KIF-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION PRINT-KIF-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-PRINT-KIF-PROPOSITION"
    "(DEFUN HELP-PRINT-KIF-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION HELP-PRINT-KIF-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-FUNCTION-PROPOSITION"
    "(DEFUN PRINT-KIF-FUNCTION-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION PRINT-KIF-FUNCTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-FUNCTION-EXPRESSION"
    "(DEFUN PRINT-KIF-FUNCTION-EXPRESSION ((SELF PROPOSITION)))"
    (CL:FUNCTION PRINT-KIF-FUNCTION-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-IMPLIES-PROPOSITION"
    "(DEFUN PRINT-KIF-IMPLIES-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION PRINT-KIF-IMPLIES-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-QUANTIFIED-VARIABLES"
    "(DEFUN PRINT-KIF-QUANTIFIED-VARIABLES ((VARIABLES (VECTOR OF SKOLEM)) (INCLUDETYPES? BOOLEAN)))"
    (CL:FUNCTION PRINT-KIF-QUANTIFIED-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-QUANTIFICATION"
    "(DEFUN PRINT-KIF-QUANTIFICATION ((SELF PROPOSITION)))"
    (CL:FUNCTION PRINT-KIF-QUANTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION"
    "(DEFUN PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-WRAPPER"
    "(DEFUN PRINT-KIF-WRAPPER ((SELF LITERAL-WRAPPER)))"
    (CL:FUNCTION PRINT-KIF-WRAPPER) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-LOGIC-OBJECT"
    "(DEFUN PRINT-KIF-LOGIC-OBJECT ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION PRINT-KIF-LOGIC-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-SKOLEM"
    "(DEFUN PRINT-KIF-SKOLEM ((SELF SKOLEM) (SUPPRESSDEFININGPROPOSITION? BOOLEAN)))"
    (CL:FUNCTION PRINT-KIF-SKOLEM) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-VARIABLE"
    "(DEFUN PRINT-KIF-VARIABLE ((SELF PATTERN-VARIABLE)))"
    (CL:FUNCTION PRINT-KIF-VARIABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-STELLA-COLLECTION"
    "(DEFUN PRINT-KIF-STELLA-COLLECTION ((SELF COLLECTION)))"
    (CL:FUNCTION PRINT-KIF-STELLA-COLLECTION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-DESCRIPTION"
    "(DEFUN PRINT-KIF-DESCRIPTION ((SELF DESCRIPTION)))"
    (CL:FUNCTION PRINT-KIF-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-DESCRIPTION-PROPOSITION"
    "(DEFUN PRINT-KIF-DESCRIPTION-PROPOSITION ((SELF DESCRIPTION) (INVERT? BOOLEAN)))"
    (CL:FUNCTION PRINT-KIF-DESCRIPTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "CHOOSE-IMPLICATION-OPERATOR"
    "(DEFUN (CHOOSE-IMPLICATION-OPERATOR SURROGATE) ((RULE PROPOSITION) (FORWARD? BOOLEAN)))"
    (CL:FUNCTION CHOOSE-IMPLICATION-OPERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-SKOLEM-MAPPING-TABLE"
    "(DEFUN (CREATE-SKOLEM-MAPPING-TABLE ENTITY-MAPPING) ((OLDVARS VARIABLES-VECTOR) (NEWVARS VARIABLES-VECTOR)))"
    (CL:FUNCTION CREATE-SKOLEM-MAPPING-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-DESCRIPTIONS-AS-KIF-RULE"
    "(DEFUN PRINT-DESCRIPTIONS-AS-KIF-RULE ((HEAD DESCRIPTION) (TAIL DESCRIPTION) (RULE PROPOSITION) (REVERSEPOLARITY? BOOLEAN)))"
    (CL:FUNCTION PRINT-DESCRIPTIONS-AS-KIF-RULE) NULL)
   (DEFINE-FUNCTION-OBJECT "EXCLUDE-ORIGINATED-PROPOSITIONS"
    "(DEFUN EXCLUDE-ORIGINATED-PROPOSITIONS ())"
    (CL:FUNCTION EXCLUDE-ORIGINATED-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "FUNCTION-OUTPUT-SKOLEM?"
    "(DEFUN (FUNCTION-OUTPUT-SKOLEM? BOOLEAN) ((SELF OBJECT)))"
    (CL:FUNCTION FUNCTION-OUTPUT-SKOLEM?) NULL)
   (DEFINE-FUNCTION-OBJECT "HIDDEN-RELATION?"
    "(DEFUN (HIDDEN-RELATION? BOOLEAN) ((RELATION-REF SURROGATE)))"
    (CL:FUNCTION HIDDEN-RELATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXCLUDED-PROPOSITION?"
    "(DEFUN (EXCLUDED-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION EXCLUDED-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-NAMED-DESCRIPTION"
    "(DEFUN PRETTY-PRINT-NAMED-DESCRIPTION ((SELF NAMED-DESCRIPTION) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-NAMED-DESCRIPTION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD DESCRIBE-OBJECT ((SELF NAMED-DESCRIPTION) (STREAM OUTPUT-STREAM) (MODE KEYWORD)) :DOCUMENTATION \"Prints a description of 'self' to stream 'stream'.  'mode'
can be :terse, :verbose, or :source.  Used by `describe'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DESCRIBE-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-RELATION-STRINGIFIED-SOURCE"
    "(DEFUN (STELLA-RELATION-STRINGIFIED-SOURCE STRING) ((SELF RELATION)))"
    (CL:FUNCTION STELLA-RELATION-STRINGIFIED-SOURCE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-RELATION-DEFINITION"
    "(DEFUN PRETTY-PRINT-RELATION-DEFINITION ((SELF RELATION) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-RELATION-DEFINITION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-RELATION-DEFINITION-TREE"
    "(DEFUN PRETTY-PRINT-RELATION-DEFINITION-TREE ((TREE CONS) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-RELATION-DEFINITION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE"
    "(DEFUN HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE ((TREE CONS) (STREAM OUTPUT-STREAM) (STARTINDENT INTEGER) (KEYINDENT INTEGER) (FORCEFIRSTKEYONSEPARATELINE? BOOLEAN)))"
    (CL:FUNCTION HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-ASSERTION"
    "(DEFUN PRETTY-PRINT-ASSERTION ((PROPOSITION PROPOSITION) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-ASSERTION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-NAMED-RULE"
    "(DEFUN PRETTY-PRINT-NAMED-RULE ((RULENAME SURROGATE) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-NAMED-RULE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-MODULE-FILE-HEADER"
    "(DEFUN PRINT-MODULE-FILE-HEADER ((MODULE MODULE) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-MODULE-FILE-HEADER) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-MODULE-FILE-TRAILER"
    "(DEFUN PRINT-MODULE-FILE-TRAILER ((MODULE MODULE) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-MODULE-FILE-TRAILER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD STORE-NATIVE-RELATION ((STORE OBJECT-STORE) (RELATION RELATION)))"
    (CL:FUNCTION STORE-NATIVE-RELATION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD STORE-RELATION ((STORE OBJECT-STORE) (RELATION NAMED-DESCRIPTION)))"
    (CL:FUNCTION STORE-RELATION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD STORE-ASSERTION ((STORE OBJECT-STORE) (PROPOSITION PROPOSITION)))"
    (CL:FUNCTION STORE-ASSERTION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD STORE-MODULE-HEADER ((STORE OBJECT-STORE) (MODULE MODULE)))"
    (CL:FUNCTION STORE-MODULE-HEADER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD STORE-MODULE-TRAILER ((STORE OBJECT-STORE) (MODULE MODULE)))"
    (CL:FUNCTION STORE-MODULE-TRAILER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR-OBJECT-STORE ((STORE OBJECT-STORE)))"
    (CL:FUNCTION CLEAR-OBJECT-STORE) NULL)
   (DEFINE-FUNCTION-OBJECT "SAVE-OBJECT"
    "(DEFUN SAVE-OBJECT ((OBJECT OBJECT) (STORE OBJECT)))"
    (CL:FUNCTION SAVE-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "DO-SAVE-MODULE"
    "(DEFUN DO-SAVE-MODULE ((MODULE MODULE) (STORE OBJECT)) :DOCUMENTATION \"Save `module' to the persistent store `store' which can
either be an output stream or a persistent OBJECT-STORE.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DO-SAVE-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "SAVE-MODULE"
    "(DEFUN SAVE-MODULE ((NAME NAME) (FILE STRING)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Save all definitions and assertions of module `name' to `file'.\")"
    (CL:FUNCTION %SAVE-MODULE)
    (CL:FUNCTION SAVE-MODULE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "STARTUP-KIF-OUT"
    "(DEFUN STARTUP-KIF-OUT () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-KIF-OUT) NULL)
   (CL:LET*
    ((FUNCTION (LOOKUP-FUNCTION SYM-KIF-OUT-LOGIC-STARTUP-KIF-OUT)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-KIF-OUT-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupKifOut") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-KIF-OUT ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-KIF-OUT1)
    (HELP-STARTUP-KIF-OUT2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *LOGIC-DIALECT-PRINT-FUNCTIONS* (NEW-KEY-VALUE-LIST))
    (CL:SETQ *BUILT-IN-MODULE-NAMES*
     (GET-QUOTED-TREE
      "((\"PL-USER\" \"PL-KERNEL-KB\" \"PLI\" \"LOOM-API\" \"CYC-FRAME-ONTOLOGY\" \"KIF-FRAME-ONTOLOGY\" \"IDL-THEORY\" \"IDL-USER-THEORY\" \"LOGIC\" \"STELLA\" \"COMMON-LISP\") \"/LOGIC\")"
      "/LOGIC")))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-KIF-OUT3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PRETTYPRINTLOGICALFORMS?* BOOLEAN FALSE :PUBLIC? TRUE :DOCUMENTATION \"Controls whether logical forms print on single lines
(unformatted) or multi-line indented.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PRETTYPRINTKIF?* BOOLEAN FALSE :PUBLIC? TRUE :DOCUMENTATION \"Controls whether KIF expressions print on single lines
(unformatted) or multi-line indented.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PRINTLOGICALFORMSTREAM* OUTPUT-STREAM NULL :PUBLIC? TRUE :DOCUMENTATION \"Eliminates necessity of passing stream argument
throughout 'print-logical-form' functions.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DOWNCASEOPERATORS?* BOOLEAN FALSE :PUBLIC? TRUE :DOCUMENTATION \"Controls whether down-casing happens during logical
form printing (leading to lots more string garbage).\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOGIC-DIALECT-PRINT-FUNCTIONS* (KEY-VALUE-LIST OF KEYWORD FUNCTION-CODE-WRAPPER) (NEW (KEY-VALUE-LIST OF KEYWORD FUNCTION-CODE-WRAPPER)) :DOCUMENTATION \"Table to allow extension of the logical form printing code
by associating keywords with print functions.  Should have values added only
via the associated function REGISTER-LOGIC-DIALECT-PRINT-FUNCTION.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *INDENTCOUNTER* INTEGER 0 :PUBLIC? TRUE :DOCUMENTATION \"The number of spaces prepended during printing a logical form.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INDENT-QUANTUM* INTEGER 3 :PUBLIC? TRUE :DOCUMENTATION \"The number of spaces added by a call to 'increase-indent'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TOPLEVELPRINTKIFPROPOSITION?* BOOLEAN TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EXCLUDEDPROPOSITIONS* (HASH-TABLE OF PROPOSITION BOOLEAN-WRAPPER) NULL :PUBLIC? TRUE :DOCUMENTATION \"List of propositions that shouldn't be saved by `save-module'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *BUILT-IN-MODULE-NAMES* (CONS OF STRING-WRAPPER) (QUOTE (\"PL-USER\" \"PL-KERNEL-KB\" \"PLI\" \"LOOM-API\" \"CYC-FRAME-ONTOLOGY\" \"KIF-FRAME-ONTOLOGY\" \"IDL-THEORY\" \"IDL-USER-THEORY\" \"LOGIC\" \"STELLA\" \"COMMON-LISP\")))")
    (REGISTER-NATIVE-NAME SYM-KIF-OUT-STELLA-SAVE-MODULE
     KWD-KIF-OUT-COMMON-LISP KWD-KIF-OUT-FUNCTION))))
