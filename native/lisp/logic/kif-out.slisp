;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997-2000              | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-KIF-OUT-KIF NULL)
(CL:DEFVAR KWD-KIF-OUT-STELLA NULL)
(CL:DEFVAR KWD-KIF-OUT-PREFIX-STELLA NULL)
(CL:DEFVAR KWD-KIF-OUT-SQL NULL)
(CL:DEFVAR SGT-KIF-OUT-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-KIF-OUT-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-KIF-OUT-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-KIF-OUT-LOGIC-SKOLEM NULL)
(CL:DEFVAR SGT-KIF-OUT-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-KIF-OUT-STELLA-COLLECTION NULL)
(CL:DEFVAR SGT-KIF-OUT-STELLA-THING NULL)
(CL:DEFVAR KWD-KIF-OUT-ISA NULL)
(CL:DEFVAR KWD-KIF-OUT-REALISTIC NULL)
(CL:DEFVAR KWD-KIF-OUT-ORIGINAL NULL)
(CL:DEFVAR KWD-KIF-OUT-AND NULL)
(CL:DEFVAR KWD-KIF-OUT-OR NULL)
(CL:DEFVAR KWD-KIF-OUT-NOT NULL)
(CL:DEFVAR KWD-KIF-OUT-EQUIVALENT NULL)
(CL:DEFVAR KWD-KIF-OUT-PREDICATE NULL)
(CL:DEFVAR KWD-KIF-OUT-FUNCTION NULL)
(CL:DEFVAR KWD-KIF-OUT-IMPLIES NULL)
(CL:DEFVAR KWD-KIF-OUT-FORALL NULL)
(CL:DEFVAR KWD-KIF-OUT-EXISTS NULL)
(CL:DEFVAR KWD-KIF-OUT-CONSTANT NULL)
(CL:DEFVAR KWD-KIF-OUT-CONTAINED-BY NULL)
(CL:DEFVAR KWD-KIF-OUT-DELETED NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-FORWARD-ONLY? NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-COMPLEMENT-DESCRIPTION NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-?X NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-?Y NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-?Z NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-BACKWARD-ONLY? NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-MASTER-PROPOSITION NULL)
(CL:DEFVAR SGT-KIF-OUT-STELLA-LITERAL-WRAPPER NULL)
(CL:DEFVAR SGT-KIF-OUT-PL-KERNEL-KB-CLOSED NULL)
(CL:DEFVAR KWD-KIF-OUT-TERSE NULL)
(CL:DEFVAR KWD-KIF-OUT-VERBOSE NULL)
(CL:DEFVAR KWD-KIF-OUT-SOURCE NULL)
(CL:DEFVAR KWD-KIF-OUT-SLOTS NULL)
(CL:DEFVAR KWD-KIF-OUT-PUBLIC-SLOTS NULL)
(CL:DEFVAR KWD-KIF-OUT-METHODS NULL)
(CL:DEFVAR KWD-KIF-OUT-PUBLIC-METHODS NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-ASSERT NULL)
(CL:DEFVAR SYM-KIF-OUT-STELLA-SURROGATE-VALUE-INVERSE NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-DEFRULE NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-SAVE-MODULE NULL)
(CL:DEFVAR KWD-KIF-OUT-COMMON-LISP NULL)
(CL:DEFVAR SYM-KIF-OUT-LOGIC-STARTUP-KIF-OUT NULL)
(CL:DEFVAR SYM-KIF-OUT-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* TRUE-WRAPPER *REVERSEPOLARITY?*
  SYSTEM-DEFINED-ARGUMENT-NAMES FALSE-WRAPPER *PRINTFUNCTIONSASRELATIONS?*
  EOL *PROPOSITIONRECORDBINDINGS* *PRINTMODE* STANDARD-OUTPUT
  *LOGIC-DIALECT*))

;;; (DEFSPECIAL *PRETTYPRINTLOGICALFORMS?* ...)

(CL:DEFVAR *PRETTYPRINTLOGICALFORMS?* FALSE
  "Controls whether logical forms print on single lines
(unformatted) or multi-line indented.")

;;; (DEFSPECIAL *PRETTYPRINTKIF?* ...)

(CL:DEFVAR *PRETTYPRINTKIF?* FALSE
  "Controls whether KIF expressions print on single lines
(unformatted) or multi-line indented.")

;;; (DEFSPECIAL *PRINTLOGICALFORMSTREAM* ...)

(CL:DEFVAR *PRINTLOGICALFORMSTREAM* NULL
  "Eliminates necessity of passing stream argument
throughout 'print-logical-form' functions.")

;;; (DEFSPECIAL *DOWNCASEOPERATORS?* ...)

(CL:DEFVAR *DOWNCASEOPERATORS?* FALSE
  "Controls whether down-casing happens during logical
form printing (leading to lots more string garbage).")

;;; (DEFUN (MAYBE-DOWNCASE STRING) ...)

(CL:DEFUN MAYBE-DOWNCASE (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  (CL:IF *DOWNCASEOPERATORS?* (STRING-DOWNCASE STRING) STRING))

;;; (DEFSPECIAL *INDENTCOUNTER* ...)

(CL:PROGN (CL:DEFVAR *INDENTCOUNTER* 0 "The number of spaces prepended during printing a logical form.") (CL:DECLAIM (CL:TYPE CL:FIXNUM *INDENTCOUNTER*)))

;;; (DEFGLOBAL *INDENT-QUANTUM* ...)

(CL:PROGN (CL:DEFVAR *INDENT-QUANTUM* 3 "The number of spaces added by a call to 'increase-indent'.") (CL:DECLAIM (CL:TYPE CL:FIXNUM *INDENT-QUANTUM*)))

;;; (DEFUN INCREASE-INDENT ...)

(CL:DEFUN INCREASE-INDENT (INDENT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
  (CL:WHEN (NULL? INDENT) (CL:SETQ INDENT *INDENT-QUANTUM*))
  (CL:SETQ *INDENTCOUNTER* (CL:+ *INDENTCOUNTER* INDENT)))

;;; (DEFUN DECREASE-INDENT ...)

(CL:DEFUN DECREASE-INDENT (INDENT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
  (CL:WHEN (NULL? INDENT) (CL:SETQ INDENT *INDENT-QUANTUM*))
  (CL:SETQ *INDENTCOUNTER* (CL:- *INDENTCOUNTER* INDENT)))

;;; (DEFUN PRINT-INDENT ...)

(CL:DEFUN PRINT-INDENT (STREAM INDENT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
  (CL:WHEN (NULL? INDENT) (CL:SETQ INDENT *INDENTCOUNTER*))
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 INDENT)
    (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-000 UPPER-BOUND-000 I))
   (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000))
    DO (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
    (CL:SETQ I I)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " "))))

;;; (DEFUN PRINT-LOGICAL-FORM-IN-DIALECT ...)

(CL:DEFUN PRINT-LOGICAL-FORM-IN-DIALECT (SELF DIALECT STREAM)
  "Produce a stringified version of a logical representation
of 'self' and write it to the stream 'stream'.  Use the dialect 'dialect',
or use the current dialect if 'dialect' is NULL."
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:RETURN-FROM PRINT-LOGICAL-FORM-IN-DIALECT))
  (CL:WHEN (CL:EQ DIALECT NULL) (CL:SETQ DIALECT *LOGIC-DIALECT*))
  (CL:LET* ((CURRENTINDENTCOUNTER *INDENTCOUNTER*))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURRENTINDENTCOUNTER))
   (CL:LET*
    ((*PRINTLOGICALFORMSTREAM* STREAM)
     (*INDENTCOUNTER* CURRENTINDENTCOUNTER))
    (CL:DECLARE (CL:SPECIAL *PRINTLOGICALFORMSTREAM* *INDENTCOUNTER*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
    (CL:COND
     ((CL:EQ DIALECT KWD-KIF-OUT-KIF)
      (CL:LET* ((*PRETTYPRINTKIF?* *PRETTYPRINTLOGICALFORMS?*))
       (CL:DECLARE (CL:SPECIAL *PRETTYPRINTKIF?*)) (PRINT-AS-KIF SELF)))
     ((CL:OR (CL:EQ DIALECT KWD-KIF-OUT-STELLA)
       (CL:EQ DIALECT KWD-KIF-OUT-PREFIX-STELLA))
      (PRINT-AS-KIF SELF))
     ((CL:EQ DIALECT KWD-KIF-OUT-SQL))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" DIALECT "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN PRINT-LOGICAL-FORM ...)

(CL:DEFUN PRINT-LOGICAL-FORM (FORM STREAM)
  "Print the logical form `form' to `stream' according to
the current setting of `*logic-dialect*'.  Pretty-printing is controlled
by the current setting of `*prettyPrintLogicalForms?*'."
  (PRINT-LOGICAL-FORM-IN-DIALECT FORM *LOGIC-DIALECT* STREAM))

;;; (DEFUN PRETTY-PRINT-LOGICAL-FORM ...)

(CL:DEFUN PRETTY-PRINT-LOGICAL-FORM (FORM STREAM)
  "Pretty-print the logical form `form' to `stream' according
to the current setting of `*logic-dialect*'."
  (CL:LET* ((*PRETTYPRINTLOGICALFORMS?* TRUE))
   (CL:DECLARE (CL:SPECIAL *PRETTYPRINTLOGICALFORMS?*))
   (PRINT-LOGICAL-FORM-IN-DIALECT FORM *LOGIC-DIALECT* STREAM)))

;;; (DEFUN PRINT-UNFORMATTED-LOGICAL-FORM ...)

(CL:DEFUN PRINT-UNFORMATTED-LOGICAL-FORM (FORM STREAM)
  "Print the logical form `form' to `stream' according to
the current setting of `*logic-dialect*'.  Pretty-printing is explicitly
forced to be turned off."
  (CL:LET* ((*PRETTYPRINTLOGICALFORMS?* FALSE))
   (CL:DECLARE (CL:SPECIAL *PRETTYPRINTLOGICALFORMS?*))
   (PRINT-LOGICAL-FORM-IN-DIALECT FORM *LOGIC-DIALECT* STREAM)))

;;; (DEFUN PRINT-FORMULA ...)

(CL:DEFUN PRINT-FORMULA (FORMULA INDENT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
  (CL:LET* ((*INDENTCOUNTER* INDENT))
   (CL:DECLARE (CL:SPECIAL *INDENTCOUNTER*))
   (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
   (PRINT-UNFORMATTED-LOGICAL-FORM FORMULA STANDARD-OUTPUT)))

;;; (DEFUN PRINT-AS-KIF ...)

(CL:DEFUN PRINT-AS-KIF (SELF)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:WHEN (CL:EQ SELF NULL)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "NULL")
    (CL:RETURN-FROM PRINT-AS-KIF))
   (CL:WHEN (DELETED? SELF)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "DeLeTeD")
    (CL:RETURN-FROM PRINT-AS-KIF))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-PROPOSITION)
      (CL:PROGN (PRINT-KIF-PROPOSITION SELF)))
     ((SUBTYPE-OF-WRAPPER? TEST-VALUE-000)
      (CL:PROGN (PRINT-KIF-WRAPPER SELF)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-DESCRIPTION)
      (CL:PROGN (PRINT-KIF-DESCRIPTION SELF)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-PATTERN-VARIABLE)
      (CL:PROGN (PRINT-KIF-VARIABLE SELF)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-SKOLEM)
      (CL:PROGN (PRINT-KIF-SKOLEM SELF FALSE)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-LOGIC-OBJECT)
      (CL:PROGN (PRINT-KIF-LOGIC-OBJECT SELF)))
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        (%SURROGATE.SYMBOL-NAME SELF))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-STELLA-COLLECTION)
      (CL:PROGN (PRINT-KIF-STELLA-COLLECTION SELF)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-STELLA-THING)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) SELF)))
     (CL:T
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       "|Illegal Logical Form|: " SELF))))))

;;; (DEFUN (VISIBLE-ARGUMENT? BOOLEAN) ...)

(CL:DEFUN VISIBLE-ARGUMENT? (SELF)
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM VISIBLE-ARGUMENT? TRUE))
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF) SGT-KIF-OUT-LOGIC-PROPOSITION)
    (CL:PROGN
     (CL:WHEN
      (CL:AND (CL:EQ (%PROPOSITION.KIND SELF) KWD-KIF-OUT-ISA)
       (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? SELF)))
      (CL:WHEN (CL:NOT (CL:EQ *PROPOSITIONRECORDBINDINGS* NULL))
       (CL:RETURN-FROM VISIBLE-ARGUMENT? TRUE))
      (CL:COND
       ((CL:OR (CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC)
         (CL:EQ *PRINTMODE* KWD-KIF-OUT-ORIGINAL))
        (CL:RETURN-FROM VISIBLE-ARGUMENT? FALSE))
       (CL:T)))))
   (CL:T))
  TRUE)

;;; (DEFUN (VISIBLE-ARGUMENTS-COUNT INTEGER) ...)

(CL:DEFUN VISIBLE-ARGUMENTS-COUNT (ARGUMENTS)
  (CL:LET* ((COUNT 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:WHEN (VISIBLE-ARGUMENT? ARG) (CL:SETQ COUNT (CL:1+ COUNT)))))
   COUNT))

;;; (DEFUN PRINT-KIF-ARGUMENTS ...)

(CL:DEFUN PRINT-KIF-ARGUMENTS (ARGUMENTS SEPARATELINES? OMITLASTARGUMENT?)
  (CL:WHEN (CL:EQ ARGUMENTS NULL) (CL:RETURN-FROM PRINT-KIF-ARGUMENTS))
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (ARGUMENTSITERATOR
     (CL:IF OMITLASTARGUMENT? (BUT-LAST ARGUMENTS)
      (ALLOCATE-ITERATOR ARGUMENTS)))
    (VISIBLEARGCOUNT (VISIBLE-ARGUMENTS-COUNT ARGUMENTS)) (ARGINDEX 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM VISIBLEARGCOUNT ARGINDEX))
   (CL:WHEN
    (CL:AND OMITLASTARGUMENT? (VISIBLE-ARGUMENT? (LAST ARGUMENTS)))
    (CL:SETQ VISIBLEARGCOUNT (CL:1- VISIBLEARGCOUNT)))
   (CL:LET* ((ARG NULL) (ITER-000 ARGUMENTSITERATOR))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ ARG (%ITERATOR.VALUE ITER-000))
     (CL:WHEN (CL:OR (VISIBLE-ARGUMENT? ARG) (CL:= VISIBLEARGCOUNT 0))
      (CL:SETQ ARGINDEX (CL:1+ ARGINDEX))
      (CL:WHEN (CL:> ARGINDEX 1)
       (CL:COND
        ((CL:AND SEPARATELINES? *PRETTYPRINTKIF?*)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
         (PRINT-INDENT STREAM NULL-INTEGER))
        (CL:T
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " "))))
      (PRINT-AS-KIF ARG))))))

;;; (DEFUN PRINT-KIF-OPERATOR-WITH-ARGUMENTS ...)

(CL:DEFUN PRINT-KIF-OPERATOR-WITH-ARGUMENTS (OPERATOR ARGUMENTS SEPARATELINES? OMITLASTARGUMENT?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OPERATOR))
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(" OPERATOR " ")
   (INCREASE-INDENT (CL:+ (CL:THE CL:FIXNUM (CL:LENGTH OPERATOR)) 2))
   (PRINT-KIF-ARGUMENTS ARGUMENTS SEPARATELINES? OMITLASTARGUMENT?)
   (DECREASE-INDENT (CL:+ (CL:THE CL:FIXNUM (CL:LENGTH OPERATOR)) 2))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))

;;; (DEFUN (STRINGIFIED-SURROGATE STRING) ...)

(CL:DEFUN STRINGIFIED-SURROGATE (OPERATOR)
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION OPERATOR)) (STRING STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
   (CL:IF (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:SETQ STRING
     (MAYBE-DOWNCASE
      (%SYMBOL.SYMBOL-NAME
       (INTERNAL-STELLA-OPERATOR-TO-KIF (SURROGATE-TO-SYMBOL OPERATOR)))))
    (CL:SETQ STRING (MAYBE-DOWNCASE (%SURROGATE.SYMBOL-NAME OPERATOR))))
   (CL:WHEN
    (CL:NOT
     (CL:EQ OPERATOR
      (LOOKUP-SURROGATE (%SURROGATE.SYMBOL-NAME OPERATOR))))
    (CL:SETQ STRING
     (COMPUTE-FULL-NAME STRING (%SURROGATE.HOME-CONTEXT OPERATOR))))
   STRING))

;;; (DEFUN (STRINGIFIED-KIF-OPERATOR STRING) ...)

(CL:DEFUN STRINGIFIED-KIF-OPERATOR (SELF)
  (CL:LET* ((OPERATOR (%PROPOSITION.OPERATOR SELF)))
   (CL:WHEN (CL:EQ OPERATOR NULL)
    (CL:RETURN-FROM STRINGIFIED-KIF-OPERATOR "NULL"))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OPERATOR)))
    (CL:COND
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN (STRINGIFIED-SURROGATE OPERATOR)))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN (MAYBE-DOWNCASE (%SYMBOL.SYMBOL-NAME OPERATOR))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFSPECIAL *TOPLEVELPRINTKIFPROPOSITION?* ...)

(CL:DEFVAR *TOPLEVELPRINTKIFPROPOSITION?* TRUE)

;;; (DEFUN PRINT-KIF-PROPOSITION ...)

(CL:DEFUN PRINT-KIF-PROPOSITION (SELF)
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM PRINT-KIF-PROPOSITION))
  (CL:LET*
   ((TOPLEVEL? *TOPLEVELPRINTKIFPROPOSITION?*)
    (STREAM *PRINTLOGICALFORMSTREAM*)
    (PRINTEXPLICITNEGATION?
     (CL:AND TOPLEVEL? (CL:OR (FALSE? SELF) (DEFAULT-FALSE? SELF)))))
   (CL:LET* ((*TOPLEVELPRINTKIFPROPOSITION?* FALSE))
    (CL:DECLARE (CL:SPECIAL *TOPLEVELPRINTKIFPROPOSITION?*))
    (CL:WHEN PRINTEXPLICITNEGATION?
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(not ")
     (INCREASE-INDENT 5))
    (CL:IF
     (CL:AND
      (CL:OR (CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC)
       (CL:EQ *PRINTMODE* KWD-KIF-OUT-ORIGINAL))
      TOPLEVEL? (TOP-LEVEL-EXISTS-PROPOSITION? SELF))
     (PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION SELF)
     (HELP-PRINT-KIF-PROPOSITION SELF))
    (CL:WHEN PRINTEXPLICITNEGATION?
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")
     (DECREASE-INDENT 5)))))

;;; (DEFUN HELP-PRINT-KIF-PROPOSITION ...)

(CL:DEFUN HELP-PRINT-KIF-PROPOSITION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*) (OPERATOR STELLA::NULL-STRING)
    (SEPARATELINES? FALSE))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OPERATOR))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-KIF-OUT-AND)
       (CL:EQ TEST-VALUE-000 KWD-KIF-OUT-OR))
      (CL:IF (CL:EQ (%PROPOSITION.KIND SELF) KWD-KIF-OUT-AND)
       (CL:SETQ OPERATOR "and") (CL:SETQ OPERATOR "or"))
      (CL:SETQ SEPARATELINES? TRUE)
      (CL:WHEN
       (CL:= (VISIBLE-ARGUMENTS-COUNT (%PROPOSITION.ARGUMENTS SELF)) 1)
       (CL:COND
        ((CL:OR (CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC)
          (CL:EQ *PRINTMODE* KWD-KIF-OUT-ORIGINAL))
         (PRINT-KIF-ARGUMENTS (%PROPOSITION.ARGUMENTS SELF) FALSE FALSE)
         (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))
        (CL:T))))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-NOT) (CL:SETQ OPERATOR "not"))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-EQUIVALENT)
      (CL:SETQ OPERATOR "="))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-KIF-OUT-ISA)
       (CL:EQ TEST-VALUE-000 KWD-KIF-OUT-PREDICATE))
      (CL:SETQ OPERATOR (STRINGIFIED-KIF-OPERATOR SELF)))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-FUNCTION)
      (CL:IF *PRINTFUNCTIONSASRELATIONS?*
       (CL:SETQ OPERATOR (STRINGIFIED-KIF-OPERATOR SELF))
       (CL:PROGN (PRINT-KIF-FUNCTION-PROPOSITION SELF)
        (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-IMPLIES)
      (PRINT-KIF-IMPLIES-PROPOSITION SELF)
      (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-KIF-OUT-FORALL)
       (CL:EQ TEST-VALUE-000 KWD-KIF-OUT-EXISTS))
      (PRINT-KIF-QUANTIFICATION SELF)
      (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-CONSTANT)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (%SURROGATE.SYMBOL-NAME (%PROPOSITION.OPERATOR SELF)))
      (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-CONTAINED-BY)
      (CL:SETQ OPERATOR ":CONTAINED-BY"))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-DELETED)
      (CL:SETQ OPERATOR ":DELETED"))
     (CL:T
      (CL:SETQ OPERATOR
       (%KEYWORD.SYMBOL-NAME (%PROPOSITION.KIND SELF))))))
   (PRINT-KIF-OPERATOR-WITH-ARGUMENTS OPERATOR
    (%PROPOSITION.ARGUMENTS SELF) SEPARATELINES? FALSE)))

;;; (DEFUN PRINT-KIF-FUNCTION-PROPOSITION ...)

(CL:DEFUN PRINT-KIF-FUNCTION-PROPOSITION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (DOWNCASEDNAME (STRINGIFIED-KIF-OPERATOR SELF))
    (LASTARGUMENT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      (CL:THE CL:FIXNUM (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS SELF)))))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DOWNCASEDNAME))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(= ")
   (PRINT-KIF-OPERATOR-WITH-ARGUMENTS DOWNCASEDNAME
    (%PROPOSITION.ARGUMENTS SELF) FALSE TRUE)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")
   (CL:WHEN (CL:NOT (CL:EQ LASTARGUMENT NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE LASTARGUMENT)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-PATTERN-VARIABLE)
       (CL:PROGN (PRINT-KIF-VARIABLE LASTARGUMENT)))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-SKOLEM)
       (CL:PROGN (PRINT-KIF-SKOLEM LASTARGUMENT TRUE)))
      (CL:T (PRINT-AS-KIF LASTARGUMENT)))))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))

;;; (DEFUN PRINT-KIF-FUNCTION-EXPRESSION ...)

(CL:DEFUN PRINT-KIF-FUNCTION-EXPRESSION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (DOWNCASEDNAME (STRINGIFIED-KIF-OPERATOR SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DOWNCASEDNAME))
   (PRINT-KIF-OPERATOR-WITH-ARGUMENTS DOWNCASEDNAME
    (%PROPOSITION.ARGUMENTS SELF) FALSE TRUE)))

;;; (DEFUN PRINT-KIF-IMPLIES-PROPOSITION ...)

(CL:DEFUN PRINT-KIF-IMPLIES-PROPOSITION (SELF)
  (CL:LET*
   ((TAILARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      0))
    (HEADARG
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      1)))
   (CL:IF
    (CL:AND (ISA? HEADARG SGT-KIF-OUT-LOGIC-DESCRIPTION)
     (ISA? TAILARG SGT-KIF-OUT-LOGIC-DESCRIPTION))
    (PRINT-DESCRIPTIONS-AS-KIF-RULE HEADARG TAILARG SELF)
    (PRINT-KIF-OPERATOR-WITH-ARGUMENTS "subset-of"
     (%PROPOSITION.ARGUMENTS SELF) TRUE FALSE))))

;;; (DEFUN PRINT-KIF-QUANTIFIED-VARIABLES ...)

(CL:DEFUN PRINT-KIF-QUANTIFIED-VARIABLES (VARIABLES INCLUDETYPES?)
  (CL:WHEN (CL:EQ VARIABLES NULL)
   (CL:RETURN-FROM PRINT-KIF-QUANTIFIED-VARIABLES))
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(")
   (CL:LET*
    ((I NULL-INTEGER) (VBL NULL) (VECTOR-000 VARIABLES) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (ITER-000 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 ITER-000 I))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:PROGN
      (CL:SETQ VBL
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
     (CL:PROGN (CL:SETQ I ITER-000) (CL:SETQ ITER-000 (CL:1+ ITER-000)))
     (CL:LET*
      ((PRINTTYPE?
        (CL:AND INCLUDETYPES?
         (CL:NOT (CL:EQ (LOGICAL-TYPE VBL) SGT-KIF-OUT-STELLA-THING)))))
      (CL:WHEN PRINTTYPE?
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VBL)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-PATTERN-VARIABLE)
         (CL:PROGN (PRINT-QUANTIFIED-VARIABLE VBL STREAM)))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-KIF-OUT-LOGIC-SKOLEM)
         (CL:PROGN (PRINT-VALUE-OF-CHAIN VBL STREAM VBL)))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
           "`" TEST-VALUE-000 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
      (CL:WHEN PRINTTYPE?
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " "
        (%SURROGATE.SYMBOL-NAME (LOGICAL-TYPE VBL)) ")"))
      (CL:WHEN (CL:< I (LENGTH VARIABLES))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")))))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))

;;; (DEFUN PRINT-KIF-QUANTIFICATION ...)

(CL:DEFUN PRINT-KIF-QUANTIFICATION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (TAIL
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
      0))
    (HEAD
     (CL:IF (CL:= (LENGTH (%PROPOSITION.ARGUMENTS SELF)) 2)
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS SELF)))
       1)
      NULL))
    (IMPLICATION? (CL:NOT (CL:EQ HEAD NULL)))
    (IMPLICATIONOPERATOR
     (CL:IF IMPLICATION?
      (CHOOSE-IMPLICATION-OPERATOR SELF
       (%BOOLEAN-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
         SYM-KIF-OUT-LOGIC-FORWARD-ONLY? FALSE-WRAPPER)))
      STELLA::NULL-STRING)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING IMPLICATIONOPERATOR))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ IMPLICATIONOPERATOR STELLA::NULL-STRING))
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
       SYM-KIF-OUT-LOGIC-FORWARD-ONLY? FALSE-WRAPPER))
     (CL:NOT (STRING-EQL? IMPLICATIONOPERATOR "<=")))
    (CL:LET* ((TEMP TAIL)) (CL:SETQ TAIL HEAD) (CL:SETQ HEAD TEMP)))
   (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND SELF)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-FORALL)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(forall "))
     ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-EXISTS)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(exists "))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (PRINT-KIF-QUANTIFIED-VARIABLES
    (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS SELF)
     SYM-KIF-OUT-LOGIC-IO-VARIABLES NULL)
    FALSE)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
   (INCREASE-INDENT NULL-INTEGER) (PRINT-INDENT STREAM NULL-INTEGER)
   (CL:WHEN IMPLICATION?
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
     IMPLICATIONOPERATOR " ")
    (INCREASE-INDENT 4) (PRINT-KIF-PROPOSITION HEAD)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
    (PRINT-INDENT STREAM NULL-INTEGER))
   (PRINT-KIF-PROPOSITION TAIL)
   (CL:WHEN IMPLICATION?
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")
    (DECREASE-INDENT 4))
   (DECREASE-INDENT NULL-INTEGER)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))

;;; (DEFUN PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION ...)

(CL:DEFUN PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION (SELF)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(exists ")
   (PRINT-KIF-QUANTIFIED-VARIABLES
    (COLLECT-SKOLEMIZED-EXISTS-VARIABLES SELF) FALSE)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
   (INCREASE-INDENT NULL-INTEGER) (PRINT-INDENT STREAM NULL-INTEGER)
   (PRINT-KIF-PROPOSITION SELF) (DECREASE-INDENT NULL-INTEGER)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))

;;; (DEFUN PRINT-KIF-WRAPPER ...)

(CL:DEFUN PRINT-KIF-WRAPPER (SELF)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        (%INTEGER-WRAPPER.WRAPPER-VALUE SELF))))
     ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        (%FLOAT-WRAPPER.WRAPPER-VALUE SELF))))
     ((SUBTYPE-OF-BOOLEAN? TEST-VALUE-000)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        (%BOOLEAN-WRAPPER.WRAPPER-VALUE SELF))))
     ((SUBTYPE-OF-STRING? TEST-VALUE-000)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "\""
        (%STRING-WRAPPER.WRAPPER-VALUE SELF) "\"")))
     ((SUBTYPE-OF-CHARACTER? TEST-VALUE-000)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        (%CHARACTER-WRAPPER.WRAPPER-VALUE SELF))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN PRINT-KIF-LOGIC-OBJECT ...)

(CL:DEFUN PRINT-KIF-LOGIC-OBJECT (SELF)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:IF
    (CL:NOT (CL:EQ (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE SELF) NULL))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
     (STRINGIFIED-SURROGATE (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE SELF)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
     "Unnamed_Object"))))

;;; (DEFUN PRINT-KIF-SKOLEM ...)

(CL:DEFUN PRINT-KIF-SKOLEM (SELF SUPPRESSDEFININGPROPOSITION?)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:COND
    (SUPPRESSDEFININGPROPOSITION? (PRINT-SKOLEM SELF STREAM FALSE))
    ((CL:NOT (CL:EQ (%SKOLEM.DEFINING-PROPOSITION SELF) NULL))
     (PRINT-KIF-FUNCTION-EXPRESSION (%SKOLEM.DEFINING-PROPOSITION SELF)))
    (CL:T (PRINT-SKOLEM SELF STREAM FALSE)))))

;;; (DEFUN PRINT-KIF-VARIABLE ...)

(CL:DEFUN PRINT-KIF-VARIABLE (SELF)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (PRINT-VARIABLE SELF STREAM)))

;;; (DEFUN PRINT-KIF-STELLA-COLLECTION ...)

(CL:DEFUN PRINT-KIF-STELLA-COLLECTION (SELF)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
    (CL:IF (NO-DUPLICATES? SELF) "SETOF" "LISTOF"))
   (CL:LET* ((M NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ M (%ITERATOR.VALUE ITER-000))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")
     (PRINT-AS-KIF M)))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))

;;; (DEFUN PRINT-KIF-DESCRIPTION ...)

(CL:DEFUN PRINT-KIF-DESCRIPTION (SELF)
  (CL:LET* ((*QUERYITERATOR* NULL))
   (CL:DECLARE (CL:SPECIAL *QUERYITERATOR*))
   (CL:LET*
    ((STREAM *PRINTLOGICALFORMSTREAM*)
     (COMPLEMENT
      (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS SELF)
       SYM-KIF-OUT-LOGIC-COMPLEMENT-DESCRIPTION NULL)))
    (CL:COND
     ((CL:NOT (CL:EQ (%DESCRIPTION.SURROGATE-VALUE-INVERSE SELF) NULL))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (STRINGIFIED-SURROGATE
        (%DESCRIPTION.SURROGATE-VALUE-INVERSE SELF))))
     ((CL:AND (CL:NOT (CL:EQ COMPLEMENT NULL))
       (CL:NOT
        (CL:EQ (%DESCRIPTION.SURROGATE-VALUE-INVERSE COMPLEMENT) NULL))
       (CL:NOT
        (CL:OR (CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC)
         (CL:EQ *PRINTMODE* KWD-KIF-OUT-ORIGINAL))))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "not-"
       (STRINGIFIED-SURROGATE
        (%DESCRIPTION.SURROGATE-VALUE-INVERSE COMPLEMENT))))
     (CL:T
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(kappa ")
      (PRINT-KIF-QUANTIFIED-VARIABLES (%DESCRIPTION.IO-VARIABLES SELF)
       TRUE)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")
      (PRINT-AS-KIF (%DESCRIPTION.PROPOSITION SELF))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")"))))))

;;; (DEFCONSTANT FAKE-VARIABLES ...)

(CL:DEFVAR FAKE-VARIABLES NULL
  "Used by 'print-descriptions-as-kif-rule' when there aren't
any real variables to print.")

;;; (DEFCONSTANT REUSABLE-SKOLEM-MAPPING-TABLE ...)

(CL:DEFVAR REUSABLE-SKOLEM-MAPPING-TABLE NULL
  "Stores reusable key-value list for use by
'print-descriptions-as-kif-rule'.")

;;; (DEFUN PRINT-DESCRIPTION-BODY ...)

(CL:DEFUN PRINT-DESCRIPTION-BODY (DESCRIPTION)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:COND
    ((CL:EQ (%DESCRIPTION.PROPOSITION DESCRIPTION) NULL)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(")
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
      (STRINGIFIED-SURROGATE
       (%DESCRIPTION.SURROGATE-VALUE-INVERSE DESCRIPTION)))
     (CL:LET*
      ((NAME NULL)
       (ITER-000
        (%LIST.THE-CONS-LIST
         (%NAMED-DESCRIPTION.IO-VARIABLE-NAMES DESCRIPTION))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:PROGN (CL:SETQ NAME (%%VALUE ITER-000))
        (CL:SETQ ITER-000 (%%REST ITER-000)))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " " NAME)))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")"))
    (CL:T (PRINT-KIF-PROPOSITION (%DESCRIPTION.PROPOSITION DESCRIPTION))))))

;;; (DEFUN PRINT-NAMED-DESCRIPTIONS-AS-KIF-RULE ...)

(CL:DEFUN PRINT-NAMED-DESCRIPTIONS-AS-KIF-RULE (HEAD TAIL OPERATORPREFIX)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OPERATORPREFIX))
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*) (VARIABLES NIL))
   (CL:LET*
    ((V NULL) (ITER-000 SYSTEM-DEFINED-ARGUMENT-NAMES)
     (I (INTERVAL 1 (ARITY HEAD))) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (NEXT? I)) DO
     (CL:PROGN (CL:SETQ V (%%VALUE ITER-000))
      (CL:SETQ ITER-000 (%%REST ITER-000)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS V NIL))
       (CL:IF (CL:EQ VARIABLES NIL) (CL:SETQ VARIABLES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST VARIABLES COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS V NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(forall ("
    (%%VALUE VARIABLES))
   (CL:LET* ((V NULL) (ITER-001 (%%REST VARIABLES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:PROGN (CL:SETQ V (%%VALUE ITER-001))
      (CL:SETQ ITER-001 (%%REST ITER-001)))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " " V)))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ") ("
    OPERATORPREFIX " (" (DESCRIPTION-NAME HEAD))
   (CL:LET* ((V NULL) (ITER-002 VARIABLES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:PROGN (CL:SETQ V (%%VALUE ITER-002))
      (CL:SETQ ITER-002 (%%REST ITER-002)))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " " V)))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ") ("
    (DESCRIPTION-NAME TAIL))
   (CL:LET* ((V NULL) (ITER-003 VARIABLES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
     (CL:PROGN (CL:SETQ V (%%VALUE ITER-003))
      (CL:SETQ ITER-003 (%%REST ITER-003)))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " " V)))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "))")))

;;; (DEFUN (CHOOSE-IMPLICATION-OPERATOR STRING) ...)

(CL:DEFUN CHOOSE-IMPLICATION-OPERATOR (RULE FORWARD?)
  (CL:LET* ((OPERATORPREFIX "<="))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OPERATORPREFIX))
   (CL:COND
    ((CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC)
     (CL:SETQ OPERATORPREFIX (CL:IF FORWARD? "=>" "<=")))
    ((CL:AND FORWARD?
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS RULE)
        SYM-KIF-OUT-LOGIC-FORWARD-ONLY? FALSE-WRAPPER)))
     (CL:SETQ OPERATORPREFIX "=>>"))
    ((CL:AND
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS RULE)
        SYM-KIF-OUT-LOGIC-BACKWARD-ONLY? FALSE-WRAPPER))
      (CL:NOT FORWARD?))
     (CL:SETQ OPERATORPREFIX "<<=")))
   (CL:WHEN
    (CL:AND (DEFAULT-TRUE? RULE)
     (CL:NOT (CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC)))
    (CL:COND
     ((STRING-EQL? OPERATORPREFIX "<=") (CL:SETQ OPERATORPREFIX "<~"))
     ((STRING-EQL? OPERATORPREFIX "=>") (CL:SETQ OPERATORPREFIX "~>"))
     ((STRING-EQL? OPERATORPREFIX "<<=") (CL:SETQ OPERATORPREFIX "<<~"))
     ((STRING-EQL? OPERATORPREFIX "=>>") (CL:SETQ OPERATORPREFIX "~>>"))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" OPERATORPREFIX "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   OPERATORPREFIX))

;;; (DEFUN PRINT-DESCRIPTIONS-AS-KIF-RULE ...)

(CL:DEFUN PRINT-DESCRIPTIONS-AS-KIF-RULE (HEAD TAIL RULE)
  (CL:LOOP WHILE
   (CL:< (LENGTH REUSABLE-SKOLEM-MAPPING-TABLE) (ARITY TAIL)) DO
   (CL:LET* ((SELF-000 (NEW-KV-CONS)))
    (CL:SETF (%KV-CONS.REST SELF-000)
     (%KEY-VALUE-LIST.THE-KV-LIST REUSABLE-SKOLEM-MAPPING-TABLE))
    (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST REUSABLE-SKOLEM-MAPPING-TABLE)
     SELF-000)))
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*) (HEADVARIABLES NULL)
    (TAILVARIABLES NULL)
    (FORWARDRULE?
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS RULE)
       SYM-KIF-OUT-LOGIC-FORWARD-ONLY? FALSE-WRAPPER)))
    (CURRENTINDENTCOUNTER *INDENTCOUNTER*)
    (OPERATORPREFIX (CHOOSE-IMPLICATION-OPERATOR RULE FORWARDRULE?)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURRENTINDENTCOUNTER)
    (CL:TYPE CL:SIMPLE-STRING OPERATORPREFIX))
   (CL:WHEN (CL:OR (DELETED? HEAD) (DELETED? TAIL))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
     "(=> <DeLeTeD ArGuMeNt(S)>)")
    (CL:RETURN-FROM PRINT-DESCRIPTIONS-AS-KIF-RULE))
   (CL:WHEN FORWARDRULE?
    (CL:LET* ((TEMP HEAD)) (CL:SETQ HEAD TAIL) (CL:SETQ TAIL TEMP)))
   (CL:WHEN
    (CL:AND (CL:EQ (%DESCRIPTION.PROPOSITION TAIL) NULL)
     (CL:EQ (%DESCRIPTION.PROPOSITION HEAD) NULL))
    (PRINT-NAMED-DESCRIPTIONS-AS-KIF-RULE HEAD TAIL OPERATORPREFIX)
    (CL:RETURN-FROM PRINT-DESCRIPTIONS-AS-KIF-RULE))
   (CL:SETQ HEADVARIABLES (%DESCRIPTION.IO-VARIABLES HEAD))
   (CL:SETQ TAILVARIABLES (%DESCRIPTION.IO-VARIABLES TAIL))
   (CL:COND
    ((CL:EQ (%DESCRIPTION.PROPOSITION TAIL) NULL)
     (CL:SETQ TAILVARIABLES HEADVARIABLES))
    ((CL:EQ (%DESCRIPTION.PROPOSITION HEAD) NULL)
     (CL:SETQ HEADVARIABLES TAILVARIABLES)))
   (CL:LET* ((*INDENTCOUNTER* CURRENTINDENTCOUNTER))
    (CL:DECLARE (CL:SPECIAL *INDENTCOUNTER*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
    (CL:LET*
     ((HEADVBL NULL) (TAILVBL NULL) (VECTOR-000 TAILVARIABLES)
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
      (VECTOR-001 HEADVARIABLES) (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001))
      (IT (ALLOCATE-ITERATOR REUSABLE-SKOLEM-MAPPING-TABLE)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)
       (NEXT? IT))
      DO
      (CL:PROGN
       (CL:SETQ TAILVBL
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))
      (CL:PROGN
       (CL:SETQ HEADVBL
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (KEY-SETTER IT HEADVBL) (VALUE-SETTER IT TAILVBL)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(forall ")
    (PRINT-KIF-QUANTIFIED-VARIABLES TAILVARIABLES FALSE)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
    (INCREASE-INDENT NULL-INTEGER) (PRINT-INDENT STREAM NULL-INTEGER)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
     OPERATORPREFIX " ")
    (INCREASE-INDENT 4)
    (CL:LET* ((*SKOLEMNAMEMAPPINGTABLE* REUSABLE-SKOLEM-MAPPING-TABLE))
     (CL:DECLARE (CL:SPECIAL *SKOLEMNAMEMAPPINGTABLE*))
     (CL:LET*
      ((EXISTENTIALS
        (COPY-CONS-LIST-TO-VARIABLES-VECTOR
         (TOP-LEVEL-EXISTENTIAL-VARIABLES HEAD))))
      (CL:WHEN *REVERSEPOLARITY?*
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(not "))
      (CL:WHEN (CL:> (%VECTOR.ARRAY-SIZE EXISTENTIALS) 0)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(exists ")
       (PRINT-KIF-QUANTIFIED-VARIABLES EXISTENTIALS FALSE)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
       (INCREASE-INDENT NULL-INTEGER) (PRINT-INDENT STREAM NULL-INTEGER)))
     (PRINT-DESCRIPTION-BODY HEAD)
     (CL:WHEN
      (CL:> (%VECTOR.ARRAY-SIZE (%DESCRIPTION.INTERNAL-VARIABLES HEAD)) 0)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")
      (DECREASE-INDENT NULL-INTEGER))
     (CL:WHEN *REVERSEPOLARITY?*
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))
    (CL:SETF
     (%KV-CONS.VALUE
      (%KEY-VALUE-LIST.THE-KV-LIST REUSABLE-SKOLEM-MAPPING-TABLE))
     NULL)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
    (CL:LET*
     ((EXISTENTIALS
       (COPY-CONS-LIST-TO-VARIABLES-VECTOR
        (TOP-LEVEL-EXISTENTIAL-VARIABLES TAIL))))
     (PRINT-INDENT STREAM NULL-INTEGER)
     (CL:WHEN *REVERSEPOLARITY?*
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(not "))
     (CL:WHEN (CL:> (%VECTOR.ARRAY-SIZE EXISTENTIALS) 0)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(exists ")
      (PRINT-KIF-QUANTIFIED-VARIABLES EXISTENTIALS FALSE)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
      (INCREASE-INDENT NULL-INTEGER) (PRINT-INDENT STREAM NULL-INTEGER)))
    (PRINT-DESCRIPTION-BODY TAIL)
    (CL:WHEN
     (CL:> (%VECTOR.ARRAY-SIZE (%DESCRIPTION.INTERNAL-VARIABLES TAIL)) 0)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")
     (DECREASE-INDENT NULL-INTEGER))
    (CL:WHEN *REVERSEPOLARITY?*
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")"))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "))"))))

;;; (DEFSPECIAL *EXCLUDEDPROPOSITIONS* ...)

(CL:DEFVAR *EXCLUDEDPROPOSITIONS* NULL
  "List of propositions that shouldn't be saved by `save-module'.")

;;; (DEFUN EXCLUDE-DECLARATION-ORIGINATED-PROPOSITIONS ...)

(CL:DEFUN EXCLUDE-DECLARATION-ORIGINATED-PROPOSITIONS ()
  (CL:LET* ((D NULL) (ITER-000 (ALL-NAMED-DESCRIPTIONS NULL FALSE)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ D (%ITERATOR.VALUE ITER-000))
    (CL:LET*
     ((PROP NULL)
      (ITER-001
       (%LIST.THE-CONS-LIST (DECLARATION-ORIGINATED-PROPOSITIONS D))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:PROGN (CL:SETQ PROP (%%VALUE ITER-001))
       (CL:SETQ ITER-001 (%%REST ITER-001)))
      (INSERT-AT *EXCLUDEDPROPOSITIONS* PROP TRUE-WRAPPER))))))

;;; (DEFUN (FUNCTION-OUTPUT-SKOLEM? BOOLEAN) ...)

(CL:DEFUN FUNCTION-OUTPUT-SKOLEM? (SELF)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF) SGT-KIF-OUT-LOGIC-SKOLEM)
    (CL:PROGN
     (CL:IF (CL:NOT (CL:EQ (%SKOLEM.DEFINING-PROPOSITION SELF) NULL)) TRUE
      FALSE)))
   (CL:T FALSE)))

;;; (DEFUN (EXCLUDED-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN EXCLUDED-PROPOSITION? (PROPOSITION)
  (CL:WHEN
   (CL:OR (UNKNOWN? PROPOSITION)
    (CL:NOT (CL:EQ (LOOKUP *EXCLUDEDPROPOSITIONS* PROPOSITION) NULL))
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
       SYM-KIF-OUT-LOGIC-MASTER-PROPOSITION NULL)
      NULL)))
   (CL:RETURN-FROM EXCLUDED-PROPOSITION? TRUE))
  (CL:LET* ((TEST-VALUE-000 (%PROPOSITION.KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-ISA)
     (CL:WHEN
      (CL:OR
       (ISA?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
         0)
        SGT-KIF-OUT-STELLA-LITERAL-WRAPPER)
       (FUNCTION-OUTPUT-SKOLEM?
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
         0)))
      (CL:RETURN-FROM EXCLUDED-PROPOSITION? TRUE)))
    ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-FUNCTION)
     (CL:LET* ((LASTARG (LAST (%PROPOSITION.ARGUMENTS PROPOSITION))))
      (CL:WHEN
       (CL:AND (SKOLEM? LASTARG) (EQL? (VALUE-OF LASTARG) LASTARG)
        (CL:NOT (TOP-LEVEL-EXISTS-PROPOSITION? PROPOSITION)))
       (CL:RETURN-FROM EXCLUDED-PROPOSITION? TRUE))))
    ((CL:EQ TEST-VALUE-000 KWD-KIF-OUT-PREDICATE)
     (CL:WHEN
      (CL:AND
       (CL:EQ (%PROPOSITION.OPERATOR PROPOSITION)
        SGT-KIF-OUT-PL-KERNEL-KB-CLOSED)
       FALSE)
      (CL:RETURN-FROM EXCLUDED-PROPOSITION? TRUE)))
    (CL:T)))
  FALSE)

;;; (DEFUN PRETTY-PRINT-NAMED-DESCRIPTION ...)

(CL:DEFUN PRETTY-PRINT-NAMED-DESCRIPTION (SELF STREAM)
  (PRETTY-PRINT-RELATION-DEFINITION-TREE
   (READ-S-EXPRESSION-FROM-STRING
    (%NAMED-DESCRIPTION.RELATION-STRINGIFIED-SOURCE SELF))
   STREAM))

;;; (DEFMETHOD DESCRIBE-OBJECT ...)

(CL:DEFMETHOD DESCRIBE-OBJECT ((SELF NAMED-DESCRIPTION) STREAM MODE)
  "Prints a description of 'self' to stream 'stream'.  'mode'
can be :terse, :verbose, or :source.  Used by `describe'."
  (CL:COND ((CL:EQ MODE KWD-KIF-OUT-TERSE) (DESCRIBE-TERSELY SELF STREAM))
   ((CL:OR (CL:EQ MODE KWD-KIF-OUT-VERBOSE)
     (CL:EQ MODE KWD-KIF-OUT-SOURCE))
    (PRETTY-PRINT-NAMED-DESCRIPTION SELF STREAM))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      MODE "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (STELLA-RELATION-STRINGIFIED-SOURCE STRING) ...)

(CL:DEFUN STELLA-RELATION-STRINGIFIED-SOURCE (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
     (CL:PROGN (%CLASS.CLASS-STRINGIFIED-SOURCE SELF)))
    ((SUBTYPE-OF-METHOD-SLOT? TEST-VALUE-000)
     (CL:PROGN (%METHOD-SLOT.METHOD-STRINGIFIED-SOURCE SELF)))
    (CL:T STELLA::NULL-STRING))))

;;; (DEFUN PRETTY-PRINT-RELATION-DEFINITION ...)

(CL:DEFUN PRETTY-PRINT-RELATION-DEFINITION (SELF STREAM)
  (CL:LET* ((DEFINITIONSTRING (STELLA-RELATION-STRINGIFIED-SOURCE SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DEFINITIONSTRING))
   (CL:WHEN (CL:NOT (CL:EQ DEFINITIONSTRING STELLA::NULL-STRING))
    (PRETTY-PRINT-RELATION-DEFINITION-TREE
     (READ-S-EXPRESSION-FROM-STRING DEFINITIONSTRING) STREAM))))

;;; (DEFUN PRETTY-PRINT-RELATION-DEFINITION-TREE ...)

(CL:DEFUN PRETTY-PRINT-RELATION-DEFINITION-TREE (TREE STREAM)
  (HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE TREE STREAM 0 2 TRUE)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL))

;;; (DEFUN HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE ...)

(CL:DEFUN HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE (TREE STREAM STARTINDENT KEYINDENT FORCEFIRSTKEYONSEPARATELINE?)
  (CL:DECLARE (CL:TYPE CL:FIXNUM STARTINDENT KEYINDENT))
  (CL:LET* ((*PRINTREADABLY?* TRUE) (*PRINTPRETTY?* TRUE))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?* *PRINTPRETTY?*))
   (CL:LET* ((VALUE-000 NULL))
    (CL:LET* ((ELEMENT NULL) (ITER-000 TREE))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:PROGN (CL:SETQ ELEMENT (%%VALUE ITER-000))
       (CL:SETQ ITER-000 (%%REST ITER-000)))
      (CL:WHEN (KEYWORD? ELEMENT) (CL:SETQ VALUE-000 ELEMENT)
       (CL:RETURN))))
    (CL:LET* ((NOFHEADERELEMENTS (POSITION TREE VALUE-000 0)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM NOFHEADERELEMENTS))
     (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
      (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000)
       (EXTRACT-OPTIONS TREE NULL))
      (CL:LET* ((OPTIONS SELF-000) (KEYLENGTH NULL-INTEGER))
       (CL:DECLARE (CL:TYPE CL:FIXNUM KEYLENGTH))
       (CL:WHEN (NULL? NOFHEADERELEMENTS)
        (CL:SETQ NOFHEADERELEMENTS (LENGTH TREE)))
       (CL:SETQ FORCEFIRSTKEYONSEPARATELINE?
        (CL:OR FORCEFIRSTKEYONSEPARATELINE? (CL:> (LENGTH OPTIONS) 1)))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(")
       (CL:LET*
        ((I NULL-INTEGER) (ELEMENT NULL) (ITER-001 TREE) (ITER-002 1)
         (UPPER-BOUND-000 NOFHEADERELEMENTS)
         (UNBOUNDED?-000 (NULL? UPPER-BOUND-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-002 UPPER-BOUND-000 I))
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ ITER-001 NIL))
          (CL:OR UNBOUNDED?-000 (CL:<= ITER-002 UPPER-BOUND-000)))
         DO
         (CL:PROGN (CL:SETQ ELEMENT (%%VALUE ITER-001))
          (CL:SETQ ITER-001 (%%REST ITER-001)))
         (CL:PROGN (CL:SETQ I ITER-002)
          (CL:SETQ ITER-002 (CL:1+ ITER-002)))
         (CL:WHEN (CL:> I 1)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " "))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ELEMENT)))
       (CL:LET*
        ((I NULL-INTEGER) (VALUE NULL) (KEY NULL)
         (ITER-003 (%PROPERTY-LIST.THE-PLIST OPTIONS)) (ITER-004 1))
        (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-004 I))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
         (CL:SETQ KEY (%%VALUE ITER-003))
         (CL:PROGN (CL:SETQ VALUE (%%VALUE (%%REST ITER-003)))
          (CL:SETQ ITER-003 (%%REST (%%REST ITER-003))))
         (CL:PROGN (CL:SETQ I ITER-004)
          (CL:SETQ ITER-004 (CL:1+ ITER-004)))
         (CL:COND
          ((CL:AND (CL:= I 1) (CL:NOT FORCEFIRSTKEYONSEPARATELINE?))
           (CL:WHEN (CL:> NOFHEADERELEMENTS 0)
            (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")))
          (CL:T (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
           (PRINT-INDENT STREAM (CL:+ STARTINDENT KEYINDENT))))
         (CL:COND
          ((SUBTYPE-OF-KEYWORD? (SAFE-PRIMARY-TYPE KEY))
           (CL:PROGN
            (CL:SETQ KEYLENGTH
             (CL:1+
              (CL:THE CL:FIXNUM
               (CL:LENGTH
                (CL:THE CL:SIMPLE-STRING (%KEYWORD.SYMBOL-NAME KEY))))))
            (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ":"
             (STRING-DOWNCASE (%KEYWORD.SYMBOL-NAME KEY)))))
          (CL:T (CL:SETQ KEYLENGTH 4)
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) KEY)))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")
         (CL:COND
          ((CL:AND
            (CL:OR (CL:EQ KEY KWD-KIF-OUT-SLOTS)
             (CL:EQ KEY KWD-KIF-OUT-PUBLIC-SLOTS)
             (CL:EQ KEY KWD-KIF-OUT-METHODS)
             (CL:EQ KEY KWD-KIF-OUT-PUBLIC-METHODS))
            (CONS? VALUE))
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(")
           (CL:LET*
            ((I NULL-INTEGER) (ELEMENT NULL) (ITER-005 VALUE)
             (ITER-006 1))
            (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-006 I))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
             (CL:PROGN (CL:SETQ ELEMENT (%%VALUE ITER-005))
              (CL:SETQ ITER-005 (%%REST ITER-005)))
             (CL:PROGN (CL:SETQ I ITER-006)
              (CL:SETQ ITER-006 (CL:1+ ITER-006)))
             (CL:WHEN (CL:> I 1)
              (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
              (PRINT-INDENT STREAM (CL:+ KEYINDENT (CL:+ KEYLENGTH 2))))
             (CL:IF (CONS? ELEMENT)
              (HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE ELEMENT STREAM
               (CL:+ STARTINDENT (CL:+ KEYINDENT (CL:+ KEYLENGTH 2)))
               KEYINDENT FALSE)
              (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
               VALUE))))
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")"))
          (CL:T
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
            VALUE)))))
       (CL:LET*
        ((ELEMENT NULL) (ITER-007 (NTH-REST TREE NOFHEADERELEMENTS)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-007 NIL)) DO
         (CL:PROGN (CL:SETQ ELEMENT (%%VALUE ITER-007))
          (CL:SETQ ITER-007 (%%REST ITER-007)))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
         (PRINT-INDENT STREAM KEYINDENT)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ELEMENT)))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")
       (FREE OPTIONS)))))))

;;; (DEFUN PRETTY-PRINT-ASSERTION ...)

(CL:DEFUN PRETTY-PRINT-ASSERTION (PROPOSITION STREAM)
  (CL:LET*
   ((OPERATOR SYM-KIF-OUT-LOGIC-ASSERT)
    (NAME
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
      SYM-KIF-OUT-STELLA-SURROGATE-VALUE-INVERSE NULL)))
   (CL:WHEN (CL:NOT (CL:EQ NAME NULL))
    (PRETTY-PRINT-NAMED-RULE NAME STREAM)
    (CL:RETURN-FROM PRETTY-PRINT-ASSERTION))
   (CL:LET*
    ((*PRINTMODE* KWD-KIF-OUT-ORIGINAL) (*PRINTLOGICALFORMSTREAM* STREAM)
     (*INDENTCOUNTER* 8))
    (CL:DECLARE
     (CL:SPECIAL *PRINTMODE* *PRINTLOGICALFORMSTREAM* *INDENTCOUNTER*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(" OPERATOR
     " ")
    (PRETTY-PRINT-LOGICAL-FORM PROPOSITION STREAM)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")" EOL))))

;;; (DEFUN PRETTY-PRINT-NAMED-RULE ...)

(CL:DEFUN PRETTY-PRINT-NAMED-RULE (RULENAME STREAM)
  (CL:LET*
   ((OPERATOR SYM-KIF-OUT-LOGIC-DEFRULE)
    (PROPOSITION (%SURROGATE.SURROGATE-VALUE RULENAME)))
   (CL:LET*
    ((*PRINTMODE* KWD-KIF-OUT-ORIGINAL) (*PRINTLOGICALFORMSTREAM* STREAM)
     (*INDENTCOUNTER* 2))
    (CL:DECLARE
     (CL:SPECIAL *PRINTMODE* *PRINTLOGICALFORMSTREAM* *INDENTCOUNTER*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(" OPERATOR " "
     (TYPE-TO-SYMBOL RULENAME) EOL)
    (PRINT-INDENT STREAM NULL-INTEGER)
    (PRETTY-PRINT-LOGICAL-FORM PROPOSITION STREAM)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")" EOL))))

;;; (DEFUN DO-SAVE-MODULE ...)

(CL:DEFUN DO-SAVE-MODULE (MODULE FILE)
  "Save `module' to `file'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
  (CL:LET* ((STREAM (NEW-OUTPUT-FILE-STREAM FILE)))
   (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL-OUTPUT-FILE-HEADER STREAM FILE) (PRINT-DEFINITION MODULE STREAM)
    (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM STREAM) EOL)
    (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM STREAM)
     "(in-module \"" (%MODULE.MODULE-FULL-NAME MODULE) "\")" EOL EOL
     "(in-dialect " *LOGIC-DIALECT* ")" EOL EOL)
    (CL:LET*
     ((DESCRIPTION NULL) (ITER-000 (ALL-NAMED-DESCRIPTIONS MODULE TRUE)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ DESCRIPTION (%ITERATOR.VALUE ITER-000))
      (CL:IF
       (CL:AND (CLASS-DESCRIPTION? DESCRIPTION)
        (CL:NOT (CL:EQ (NATIVE-RELATION DESCRIPTION) NULL)))
       (CL:LET* ((CLASS (NATIVE-RELATION DESCRIPTION)))
        (PRETTY-PRINT-RELATION-DEFINITION CLASS STREAM)
        (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM STREAM) EOL)
        (CL:LET*
         ((SLOT NULL)
          (ITER-001
           (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS CLASS))))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:PROGN (CL:SETQ SLOT (%%VALUE ITER-001))
           (CL:SETQ ITER-001 (%%REST ITER-001)))
          (CL:WHEN
           (CL:NOT
            (CL:EQ (STELLA-RELATION-STRINGIFIED-SOURCE SLOT)
             STELLA::NULL-STRING))
           (PRETTY-PRINT-RELATION-DEFINITION SLOT STREAM)
           (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM STREAM)
            EOL)))))
       (PRETTY-PRINT-NAMED-DESCRIPTION DESCRIPTION STREAM))))
    (CL:LET* ((FUNCTION NULL) (ITER-002 (ALL-FUNCTIONS MODULE TRUE)))
     (CL:LOOP WHILE (NEXT? ITER-002) DO
      (CL:SETQ FUNCTION (%ITERATOR.VALUE ITER-002))
      (CL:WHEN
       (CL:NOT
        (CL:EQ (STELLA-RELATION-STRINGIFIED-SOURCE FUNCTION)
         STELLA::NULL-STRING))
       (PRETTY-PRINT-RELATION-DEFINITION FUNCTION STREAM)
       (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM STREAM) EOL))))
    (CL:LET* ((*EXCLUDEDPROPOSITIONS* (NEW-HASH-TABLE)))
     (CL:DECLARE (CL:SPECIAL *EXCLUDEDPROPOSITIONS*))
     (EXCLUDE-DECLARATION-ORIGINATED-PROPOSITIONS)
     (CL:LET* ((REVERSEDPROPOSITIONS NIL))
      (CL:LET*
       ((P NULL)
        (ITER-003
         (ALLOCATE-ITERATOR (LOCALLY-CONCEIVED-PROPOSITIONS MODULE))))
       (CL:LOOP WHILE (NEXT? ITER-003) DO
        (CL:SETQ P (%ITERATOR.VALUE ITER-003))
        (CL:WHEN (CL:NOT (EXCLUDED-PROPOSITION? P))
         (CL:SETQ REVERSEDPROPOSITIONS (CONS P REVERSEDPROPOSITIONS)))))
      (CL:LET* ((P NULL) (ITER-004 REVERSEDPROPOSITIONS))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
        (CL:PROGN (CL:SETQ P (%%VALUE ITER-004))
         (CL:SETQ ITER-004 (%%REST ITER-004)))
        (PRETTY-PRINT-ASSERTION P STREAM)
        (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM STREAM)
         EOL)))))
    (FREE STREAM))))

;;; (DEFUN SAVE-MODULE ...)

(CL:DEFUN %SAVE-MODULE (NAME FILE)
  "Save all definitions and assertions of module `name' to `file'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
  (CL:LET* ((MODULE (COERCE-TO-MODULE NAME TRUE)))
   (CL:WHEN (CL:NOT (CL:EQ MODULE NULL)) (DO-SAVE-MODULE MODULE FILE))))

(CL:DEFUN SAVE-MODULE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SAVE-MODULE (%%VALUE ARGUMENTS)
   (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO SAVE-MODULE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Save all definitions and assertions of module `name' to `file'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/SAVE-MODULE)) (CL:MACRO-FUNCTION (CL:QUOTE SAVE-MODULE)))

(CL:DEFUN HELP-STARTUP-KIF-OUT1 ()
  (CL:PROGN
   (CL:SETQ KWD-KIF-OUT-KIF (INTERN-RIGID-SYMBOL-WRT-MODULE "KIF" NULL 2))
   (CL:SETQ KWD-KIF-OUT-STELLA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA" NULL 2))
   (CL:SETQ KWD-KIF-OUT-PREFIX-STELLA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREFIX-STELLA" NULL 2))
   (CL:SETQ KWD-KIF-OUT-SQL (INTERN-RIGID-SYMBOL-WRT-MODULE "SQL" NULL 2))
   (CL:SETQ SGT-KIF-OUT-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SGT-KIF-OUT-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SGT-KIF-OUT-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-KIF-OUT-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SGT-KIF-OUT-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SGT-KIF-OUT-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-KIF-OUT-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ KWD-KIF-OUT-ISA (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ KWD-KIF-OUT-REALISTIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REALISTIC" NULL 2))
   (CL:SETQ KWD-KIF-OUT-ORIGINAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ORIGINAL" NULL 2))
   (CL:SETQ KWD-KIF-OUT-AND (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-KIF-OUT-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-KIF-OUT-NOT (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-KIF-OUT-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ KWD-KIF-OUT-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-KIF-OUT-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-KIF-OUT-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ KWD-KIF-OUT-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ KWD-KIF-OUT-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ KWD-KIF-OUT-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 2))
   (CL:SETQ KWD-KIF-OUT-CONTAINED-BY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTAINED-BY" NULL 2))
   (CL:SETQ KWD-KIF-OUT-DELETED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DELETED" NULL 2))
   (CL:SETQ SYM-KIF-OUT-LOGIC-FORWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-ONLY?" NULL 0))
   (CL:SETQ SYM-KIF-OUT-LOGIC-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
   (CL:SETQ SYM-KIF-OUT-LOGIC-COMPLEMENT-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT-DESCRIPTION" NULL 0))
   (CL:SETQ SYM-KIF-OUT-LOGIC-?X
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X" NULL 0))
   (CL:SETQ SYM-KIF-OUT-LOGIC-?Y
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?Y" NULL 0))
   (CL:SETQ SYM-KIF-OUT-LOGIC-?Z
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?Z" NULL 0))
   (CL:SETQ SYM-KIF-OUT-LOGIC-BACKWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD-ONLY?" NULL 0))
   (CL:SETQ SYM-KIF-OUT-LOGIC-MASTER-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
   (CL:SETQ SGT-KIF-OUT-STELLA-LITERAL-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" TRUE) 1))
   (CL:SETQ SGT-KIF-OUT-PL-KERNEL-KB-CLOSED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" TRUE) 1))
   (CL:SETQ KWD-KIF-OUT-TERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TERSE" NULL 2))
   (CL:SETQ KWD-KIF-OUT-VERBOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBOSE" NULL 2))
   (CL:SETQ KWD-KIF-OUT-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SOURCE" NULL 2))
   (CL:SETQ KWD-KIF-OUT-SLOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTS" NULL 2))
   (CL:SETQ KWD-KIF-OUT-PUBLIC-SLOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC-SLOTS" NULL 2))
   (CL:SETQ KWD-KIF-OUT-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHODS" NULL 2))
   (CL:SETQ KWD-KIF-OUT-PUBLIC-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC-METHODS" NULL 2))
   (CL:SETQ SYM-KIF-OUT-LOGIC-ASSERT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT" NULL 0))
   (CL:SETQ SYM-KIF-OUT-STELLA-SURROGATE-VALUE-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE-INVERSE"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))
   (CL:SETQ SYM-KIF-OUT-LOGIC-DEFRULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFRULE" NULL 0))
   (CL:SETQ SYM-KIF-OUT-LOGIC-SAVE-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVE-MODULE" NULL 0))
   (CL:SETQ KWD-KIF-OUT-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-KIF-OUT-LOGIC-STARTUP-KIF-OUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-KIF-OUT" NULL 0))
   (CL:SETQ SYM-KIF-OUT-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" TRUE) 0))))

(CL:DEFUN HELP-STARTUP-KIF-OUT2 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "MAYBE-DOWNCASE"
    "(DEFUN (MAYBE-DOWNCASE STRING) ((STRING STRING)))"
    (CL:FUNCTION MAYBE-DOWNCASE) NULL)
   (DEFINE-FUNCTION-OBJECT "INCREASE-INDENT"
    "(DEFUN INCREASE-INDENT ((INDENT INTEGER)))"
    (CL:FUNCTION INCREASE-INDENT) NULL)
   (DEFINE-FUNCTION-OBJECT "DECREASE-INDENT"
    "(DEFUN DECREASE-INDENT ((INDENT INTEGER)))"
    (CL:FUNCTION DECREASE-INDENT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-INDENT"
    "(DEFUN PRINT-INDENT ((STREAM OUTPUT-STREAM) (INDENT INTEGER)))"
    (CL:FUNCTION PRINT-INDENT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-LOGICAL-FORM-IN-DIALECT"
    "(DEFUN PRINT-LOGICAL-FORM-IN-DIALECT ((SELF OBJECT) (DIALECT KEYWORD) (STREAM OUTPUT-STREAM)) :PUBLIC? TRUE :DOCUMENTATION \"Produce a stringified version of a logical representation
of 'self' and write it to the stream 'stream'.  Use the dialect 'dialect',
or use the current dialect if 'dialect' is NULL.\")"
    (CL:FUNCTION PRINT-LOGICAL-FORM-IN-DIALECT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-LOGICAL-FORM"
    "(DEFUN PRINT-LOGICAL-FORM ((FORM OBJECT) (STREAM OUTPUT-STREAM)) :PUBLIC? TRUE :DOCUMENTATION \"Print the logical form `form' to `stream' according to
the current setting of `*logic-dialect*'.  Pretty-printing is controlled
by the current setting of `*prettyPrintLogicalForms?*'.\")"
    (CL:FUNCTION PRINT-LOGICAL-FORM) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-LOGICAL-FORM"
    "(DEFUN PRETTY-PRINT-LOGICAL-FORM ((FORM OBJECT) (STREAM OUTPUT-STREAM)) :PUBLIC? TRUE :DOCUMENTATION \"Pretty-print the logical form `form' to `stream' according
to the current setting of `*logic-dialect*'.\")"
    (CL:FUNCTION PRETTY-PRINT-LOGICAL-FORM) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-UNFORMATTED-LOGICAL-FORM"
    "(DEFUN PRINT-UNFORMATTED-LOGICAL-FORM ((FORM OBJECT) (STREAM OUTPUT-STREAM)) :PUBLIC? TRUE :DOCUMENTATION \"Print the logical form `form' to `stream' according to
the current setting of `*logic-dialect*'.  Pretty-printing is explicitly
forced to be turned off.\")" (CL:FUNCTION PRINT-UNFORMATTED-LOGICAL-FORM)
    NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-FORMULA"
    "(DEFUN PRINT-FORMULA ((FORMULA OBJECT) (INDENT INTEGER)))"
    (CL:FUNCTION PRINT-FORMULA) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-AS-KIF"
    "(DEFUN PRINT-AS-KIF ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION PRINT-AS-KIF) NULL)
   (DEFINE-FUNCTION-OBJECT "VISIBLE-ARGUMENT?"
    "(DEFUN (VISIBLE-ARGUMENT? BOOLEAN) ((SELF OBJECT)))"
    (CL:FUNCTION VISIBLE-ARGUMENT?) NULL)
   (DEFINE-FUNCTION-OBJECT "VISIBLE-ARGUMENTS-COUNT"
    "(DEFUN (VISIBLE-ARGUMENTS-COUNT INTEGER) ((ARGUMENTS ARGUMENTS-VECTOR)))"
    (CL:FUNCTION VISIBLE-ARGUMENTS-COUNT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-ARGUMENTS"
    "(DEFUN PRINT-KIF-ARGUMENTS ((ARGUMENTS ARGUMENTS-VECTOR) (SEPARATELINES? BOOLEAN) (OMITLASTARGUMENT? BOOLEAN)))"
    (CL:FUNCTION PRINT-KIF-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-OPERATOR-WITH-ARGUMENTS"
    "(DEFUN PRINT-KIF-OPERATOR-WITH-ARGUMENTS ((OPERATOR STRING) (ARGUMENTS ARGUMENTS-VECTOR) (SEPARATELINES? BOOLEAN) (OMITLASTARGUMENT? BOOLEAN)))"
    (CL:FUNCTION PRINT-KIF-OPERATOR-WITH-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "STRINGIFIED-SURROGATE"
    "(DEFUN (STRINGIFIED-SURROGATE STRING) ((OPERATOR SURROGATE)))"
    (CL:FUNCTION STRINGIFIED-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "STRINGIFIED-KIF-OPERATOR"
    "(DEFUN (STRINGIFIED-KIF-OPERATOR STRING) ((SELF PROPOSITION)))"
    (CL:FUNCTION STRINGIFIED-KIF-OPERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-PROPOSITION"
    "(DEFUN PRINT-KIF-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION PRINT-KIF-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-PRINT-KIF-PROPOSITION"
    "(DEFUN HELP-PRINT-KIF-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION HELP-PRINT-KIF-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-FUNCTION-PROPOSITION"
    "(DEFUN PRINT-KIF-FUNCTION-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION PRINT-KIF-FUNCTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-FUNCTION-EXPRESSION"
    "(DEFUN PRINT-KIF-FUNCTION-EXPRESSION ((SELF PROPOSITION)))"
    (CL:FUNCTION PRINT-KIF-FUNCTION-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-IMPLIES-PROPOSITION"
    "(DEFUN PRINT-KIF-IMPLIES-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION PRINT-KIF-IMPLIES-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-QUANTIFIED-VARIABLES"
    "(DEFUN PRINT-KIF-QUANTIFIED-VARIABLES ((VARIABLES (VECTOR OF SKOLEM)) (INCLUDETYPES? BOOLEAN)))"
    (CL:FUNCTION PRINT-KIF-QUANTIFIED-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-QUANTIFICATION"
    "(DEFUN PRINT-KIF-QUANTIFICATION ((SELF PROPOSITION)))"
    (CL:FUNCTION PRINT-KIF-QUANTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION"
    "(DEFUN PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-WRAPPER"
    "(DEFUN PRINT-KIF-WRAPPER ((SELF LITERAL-WRAPPER)))"
    (CL:FUNCTION PRINT-KIF-WRAPPER) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-LOGIC-OBJECT"
    "(DEFUN PRINT-KIF-LOGIC-OBJECT ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION PRINT-KIF-LOGIC-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-SKOLEM"
    "(DEFUN PRINT-KIF-SKOLEM ((SELF SKOLEM) (SUPPRESSDEFININGPROPOSITION? BOOLEAN)))"
    (CL:FUNCTION PRINT-KIF-SKOLEM) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-VARIABLE"
    "(DEFUN PRINT-KIF-VARIABLE ((SELF PATTERN-VARIABLE)))"
    (CL:FUNCTION PRINT-KIF-VARIABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-STELLA-COLLECTION"
    "(DEFUN PRINT-KIF-STELLA-COLLECTION ((SELF COLLECTION)))"
    (CL:FUNCTION PRINT-KIF-STELLA-COLLECTION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KIF-DESCRIPTION"
    "(DEFUN PRINT-KIF-DESCRIPTION ((SELF DESCRIPTION)))"
    (CL:FUNCTION PRINT-KIF-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-DESCRIPTION-BODY"
    "(DEFUN PRINT-DESCRIPTION-BODY ((DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION PRINT-DESCRIPTION-BODY) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-NAMED-DESCRIPTIONS-AS-KIF-RULE"
    "(DEFUN PRINT-NAMED-DESCRIPTIONS-AS-KIF-RULE ((HEAD NAMED-DESCRIPTION) (TAIL NAMED-DESCRIPTION) (OPERATORPREFIX STRING)))"
    (CL:FUNCTION PRINT-NAMED-DESCRIPTIONS-AS-KIF-RULE) NULL)
   (DEFINE-FUNCTION-OBJECT "CHOOSE-IMPLICATION-OPERATOR"
    "(DEFUN (CHOOSE-IMPLICATION-OPERATOR STRING) ((RULE PROPOSITION) (FORWARD? BOOLEAN)))"
    (CL:FUNCTION CHOOSE-IMPLICATION-OPERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-DESCRIPTIONS-AS-KIF-RULE"
    "(DEFUN PRINT-DESCRIPTIONS-AS-KIF-RULE ((HEAD DESCRIPTION) (TAIL DESCRIPTION) (RULE PROPOSITION)))"
    (CL:FUNCTION PRINT-DESCRIPTIONS-AS-KIF-RULE) NULL)
   (DEFINE-FUNCTION-OBJECT "EXCLUDE-DECLARATION-ORIGINATED-PROPOSITIONS"
    "(DEFUN EXCLUDE-DECLARATION-ORIGINATED-PROPOSITIONS ())"
    (CL:FUNCTION EXCLUDE-DECLARATION-ORIGINATED-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "FUNCTION-OUTPUT-SKOLEM?"
    "(DEFUN (FUNCTION-OUTPUT-SKOLEM? BOOLEAN) ((SELF OBJECT)))"
    (CL:FUNCTION FUNCTION-OUTPUT-SKOLEM?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXCLUDED-PROPOSITION?"
    "(DEFUN (EXCLUDED-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION EXCLUDED-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-NAMED-DESCRIPTION"
    "(DEFUN PRETTY-PRINT-NAMED-DESCRIPTION ((SELF NAMED-DESCRIPTION) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-NAMED-DESCRIPTION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD DESCRIBE-OBJECT ((SELF NAMED-DESCRIPTION) (STREAM OUTPUT-STREAM) (MODE KEYWORD)) :DOCUMENTATION \"Prints a description of 'self' to stream 'stream'.  'mode'
can be :terse, :verbose, or :source.  Used by `describe'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DESCRIBE-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-RELATION-STRINGIFIED-SOURCE"
    "(DEFUN (STELLA-RELATION-STRINGIFIED-SOURCE STRING) ((SELF RELATION)))"
    (CL:FUNCTION STELLA-RELATION-STRINGIFIED-SOURCE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-RELATION-DEFINITION"
    "(DEFUN PRETTY-PRINT-RELATION-DEFINITION ((SELF RELATION) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-RELATION-DEFINITION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-RELATION-DEFINITION-TREE"
    "(DEFUN PRETTY-PRINT-RELATION-DEFINITION-TREE ((TREE CONS) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-RELATION-DEFINITION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE"
    "(DEFUN HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE ((TREE CONS) (STREAM OUTPUT-STREAM) (STARTINDENT INTEGER) (KEYINDENT INTEGER) (FORCEFIRSTKEYONSEPARATELINE? BOOLEAN)))"
    (CL:FUNCTION HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-ASSERTION"
    "(DEFUN PRETTY-PRINT-ASSERTION ((PROPOSITION PROPOSITION) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-ASSERTION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-NAMED-RULE"
    "(DEFUN PRETTY-PRINT-NAMED-RULE ((RULENAME SURROGATE) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-NAMED-RULE) NULL)
   (DEFINE-FUNCTION-OBJECT "DO-SAVE-MODULE"
    "(DEFUN DO-SAVE-MODULE ((MODULE MODULE) (FILE STRING)) :DOCUMENTATION \"Save `module' to `file'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DO-SAVE-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "SAVE-MODULE"
    "(DEFUN SAVE-MODULE ((NAME NAME) (FILE STRING)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Save all definitions and assertions of module `name' to `file'.\")"
    (CL:FUNCTION %SAVE-MODULE)
    (CL:FUNCTION SAVE-MODULE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "STARTUP-KIF-OUT"
    "(DEFUN STARTUP-KIF-OUT () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-KIF-OUT) NULL)
   (CL:LET*
    ((FUNCTION (LOOKUP-FUNCTION SYM-KIF-OUT-LOGIC-STARTUP-KIF-OUT)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-KIF-OUT-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "Startup-Kif-Out") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-KIF-OUT ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-KIF-OUT1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ FAKE-VARIABLES (NEW-VECTOR 3))
    (CL:SETQ REUSABLE-SKOLEM-MAPPING-TABLE (NEW-KEY-VALUE-LIST)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-KIF-OUT2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PRETTYPRINTLOGICALFORMS?* BOOLEAN FALSE :PUBLIC? TRUE :DOCUMENTATION \"Controls whether logical forms print on single lines
(unformatted) or multi-line indented.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PRETTYPRINTKIF?* BOOLEAN FALSE :PUBLIC? TRUE :DOCUMENTATION \"Controls whether KIF expressions print on single lines
(unformatted) or multi-line indented.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PRINTLOGICALFORMSTREAM* OUTPUT-STREAM NULL :PUBLIC? TRUE :DOCUMENTATION \"Eliminates necessity of passing stream argument
throughout 'print-logical-form' functions.\" :PUBLIC? FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DOWNCASEOPERATORS?* BOOLEAN FALSE :PUBLIC? TRUE :DOCUMENTATION \"Controls whether down-casing happens during logical
form printing (leading to lots more string garbage).\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *INDENTCOUNTER* INTEGER 0 :PUBLIC? TRUE :DOCUMENTATION \"The number of spaces prepended during printing a logical form.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INDENT-QUANTUM* INTEGER 3 :PUBLIC? TRUE :DOCUMENTATION \"The number of spaces added by a call to 'increase-indent'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TOPLEVELPRINTKIFPROPOSITION?* BOOLEAN TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT FAKE-VARIABLES VARIABLES-VECTOR (NEW VARIABLES-VECTOR :ARRAY-SIZE 3) :DOCUMENTATION \"Used by 'print-descriptions-as-kif-rule' when there aren't
any real variables to print.\")")
    (CL:LET*
     ((I NULL-INTEGER) (NAME NULL)
      (ITER-071
       (LIST* SYM-KIF-OUT-LOGIC-?X SYM-KIF-OUT-LOGIC-?Y
        SYM-KIF-OUT-LOGIC-?Z NIL))
      (ITER-072 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM ITER-072 I))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-071 NIL)) DO
      (CL:PROGN (CL:SETQ NAME (%%VALUE ITER-071))
       (CL:SETQ ITER-071 (%%REST ITER-071)))
      (CL:PROGN (CL:SETQ I ITER-072) (CL:SETQ ITER-072 (CL:1+ ITER-072)))
      (CL:LET* ((SELF-073 (NEW-PATTERN-VARIABLE)))
       (CL:SETF (%PATTERN-VARIABLE.SKOLEM-NAME SELF-073) NAME)
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY FAKE-VARIABLES)) (VALUE SELF-073)
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE)))))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT REUSABLE-SKOLEM-MAPPING-TABLE (KEY-VALUE-LIST OF SKOLEM SKOLEM) (NEW KEY-VALUE-LIST) :DOCUMENTATION \"Stores reusable key-value list for use by
'print-descriptions-as-kif-rule'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EXCLUDEDPROPOSITIONS* (HASH-TABLE OF PROPOSITION BOOLEAN-WRAPPER) NULL :PUBLIC? TRUE :DOCUMENTATION \"List of propositions that shouldn't be saved by `save-module'.\")")
    (REGISTER-NATIVE-NAME SYM-KIF-OUT-LOGIC-SAVE-MODULE
     KWD-KIF-OUT-COMMON-LISP KWD-KIF-OUT-FUNCTION))))
