;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; specialize.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-SPECIALIZE-LOGIC-ABSTRACT-PROPOSITIONS-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-SELECTION-PATTERN NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-PROPOSITION-CURSOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-EQUIVALENTS-STACK NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-TRUE-PROPOSITIONS-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-TRUTH-VALUE NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-SPECIALIZING-PROPOSITIONS-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-SPECIALIZING-RELATIONS NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-DESCRIPTION-EXTENSION-ITERATOR NULL)
(CL:DEFVAR KWD-SPECIALIZE-RELATION NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR KWD-SPECIALIZE-DEPENDENTS NULL)
(CL:DEFVAR KWD-SPECIALIZE-ISA NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-PROPOSITION NULL)
(CL:DEFVAR KWD-SPECIALIZE-FUNCTION NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-F-TEST-PROPERTY?-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-SPECIALIZE-STELLA-THING NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-CLASS NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-RELATION NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-FUNCTION NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-COLLECTION NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-SET NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-001 NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-F-ACCESS-BINARY-VALUE-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-COLLECTIONOF NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-TRANSITIVE-CLOSURE-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-ALLOCATE-ADJACENCY-ITERATOR-FUNCTION NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-FILTER? NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-ADJACENCY-ITERATOR-STACK NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-BEEN-THERE-LIST NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-SUPPORTED-CLOSURE-ITERATOR NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-DIRECTLY-LINKED-OBJECTS-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-INVERSE? NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-ROOT-TRUTH-VALUE NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-SUBSET-OF NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-F-ALL-SUPERCOLLECTIONS-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-MEMBER-OF NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-F-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-SPECIALIZE-STELLA-CONS NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SGT-SPECIALIZE-STELLA-NUMBER NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-SKOLEM NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-CLASHING-PROPOSITIONS-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-REFERENCE-PROPOSITION NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SYM-SPECIALIZE-STELLA-TAXONOMY-NODE NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-STARTUP-SPECIALIZE NULL)
(CL:DEFVAR SYM-SPECIALIZE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* *DONTUSEDEFAULTKNOWLEDGE?*
  *CONTEXT* *MEMOIZATION-ENABLED?* MEMOIZED-NULL-VALUE TRUE-WRAPPER
  FALSE-WRAPPER NULL-INTEGER *CYC-KLUDGES-ENABLED?* *QUERYITERATOR*
  NIL-PAGING-INDEX NIL-NON-PAGING-INDEX *REVERSEPOLARITY?*
  TRUE-TRUTH-VALUE NIL))

(CL:DEFUN NEW-ABSTRACT-PROPOSITIONS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-ABSTRACT-PROPOSITIONS-ITERATOR))
   (CL:SETF (%ABSTRACT-PROPOSITIONS-ITERATOR.FIRST-ITERATION? SELF)
    CL:T)
   (CL:SETF (%ABSTRACT-PROPOSITIONS-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%ABSTRACT-PROPOSITIONS-ITERATOR.EQUIVALENTS-STACK SELF)
    NULL)
   (CL:SETF (%ABSTRACT-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR SELF)
    NULL)
   (CL:SETF (%ABSTRACT-PROPOSITIONS-ITERATOR.SELECTION-PATTERN SELF)
    NULL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ABSTRACT-PROPOSITIONS-ITERATOR))
  SGT-SPECIALIZE-LOGIC-ABSTRACT-PROPOSITIONS-ITERATOR)

(CL:DEFUN ACCESS-ABSTRACT-PROPOSITIONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-SELECTION-PATTERN)
    (CL:IF SETVALUE?
     (CL:SETF (%ABSTRACT-PROPOSITIONS-ITERATOR.SELECTION-PATTERN SELF)
      VALUE)
     (CL:SETQ VALUE
      (%ABSTRACT-PROPOSITIONS-ITERATOR.SELECTION-PATTERN SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-PROPOSITION-CURSOR)
    (CL:IF SETVALUE?
     (CL:SETF (%ABSTRACT-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR SELF)
      VALUE)
     (CL:SETQ VALUE
      (%ABSTRACT-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-EQUIVALENTS-STACK)
    (CL:IF SETVALUE?
     (CL:SETF (%ABSTRACT-PROPOSITIONS-ITERATOR.EQUIVALENTS-STACK SELF)
      VALUE)
     (CL:SETQ VALUE
      (%ABSTRACT-PROPOSITIONS-ITERATOR.EQUIVALENTS-STACK SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFUN NEW-TRUE-PROPOSITIONS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-TRUE-PROPOSITIONS-ITERATOR))
   (CL:SETF (%TRUE-PROPOSITIONS-ITERATOR.FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%TRUE-PROPOSITIONS-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%TRUE-PROPOSITIONS-ITERATOR.EQUIVALENTS-STACK SELF) NULL)
   (CL:SETF (%TRUE-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR SELF) NULL)
   (CL:SETF (%TRUE-PROPOSITIONS-ITERATOR.SELECTION-PATTERN SELF) NULL)
   (CL:SETF (%TRUE-PROPOSITIONS-ITERATOR.TRUTH-VALUE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRUE-PROPOSITIONS-ITERATOR))
  SGT-SPECIALIZE-LOGIC-TRUE-PROPOSITIONS-ITERATOR)

(CL:DEFUN ACCESS-TRUE-PROPOSITIONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-TRUTH-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%TRUE-PROPOSITIONS-ITERATOR.TRUTH-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%TRUE-PROPOSITIONS-ITERATOR.TRUTH-VALUE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFUN NEW-SPECIALIZING-PROPOSITIONS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-SPECIALIZING-PROPOSITIONS-ITERATOR))
   (CL:SETF (%SPECIALIZING-PROPOSITIONS-ITERATOR.FIRST-ITERATION? SELF)
    CL:T)
   (CL:SETF (%SPECIALIZING-PROPOSITIONS-ITERATOR.VALUE SELF) NULL)
   (CL:SETF
    (%SPECIALIZING-PROPOSITIONS-ITERATOR.EQUIVALENTS-STACK SELF) NULL)
   (CL:SETF
    (%SPECIALIZING-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR SELF) NULL)
   (CL:SETF
    (%SPECIALIZING-PROPOSITIONS-ITERATOR.SELECTION-PATTERN SELF) NULL)
   (CL:SETF (%SPECIALIZING-PROPOSITIONS-ITERATOR.TRUTH-VALUE SELF)
    NULL)
   (CL:SETF
    (%SPECIALIZING-PROPOSITIONS-ITERATOR.SPECIALIZING-RELATIONS SELF)
    NULL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SPECIALIZING-PROPOSITIONS-ITERATOR))
  SGT-SPECIALIZE-LOGIC-SPECIALIZING-PROPOSITIONS-ITERATOR)

(CL:DEFUN ACCESS-SPECIALIZING-PROPOSITIONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-SPECIALIZING-RELATIONS)
    (CL:IF SETVALUE?
     (CL:SETF
      (%SPECIALIZING-PROPOSITIONS-ITERATOR.SPECIALIZING-RELATIONS SELF)
      VALUE)
     (CL:SETQ VALUE
      (%SPECIALIZING-PROPOSITIONS-ITERATOR.SPECIALIZING-RELATIONS
       SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (PROPOSITIONS-ITERATOR-TRUTH-VALUE TRUTH-VALUE) ...)

(CL:DEFUN PROPOSITIONS-ITERATOR-TRUTH-VALUE (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-SPECIALIZE-LOGIC-TRUE-PROPOSITIONS-ITERATOR)
     (CL:PROGN (%TRUE-PROPOSITIONS-ITERATOR.TRUTH-VALUE SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-SPECIALIZE-LOGIC-DESCRIPTION-EXTENSION-ITERATOR)
     (CL:PROGN (%DESCRIPTION-EXTENSION-ITERATOR.TRUTH-VALUE SELF)))
    (CL:T NULL))))

;;; (DEFUN (NEXT-EQUIVALENT-SELECTION-PATTERN CONS) ...)

(CL:DEFUN NEXT-EQUIVALENT-SELECTION-PATTERN (SELF)
  (CL:LET*
   ((PATTERN (%ABSTRACT-PROPOSITIONS-ITERATOR.SELECTION-PATTERN SELF))
    (KEYWITHEQUIVALENTS NULL)
    (EQUIVALENTSSTACK
     (%ABSTRACT-PROPOSITIONS-ITERATOR.EQUIVALENTS-STACK SELF))
    (NEWSKOLEM NULL) (EQUIVALENTSKOLEMS NULL))
   (CL:WHEN (CL:EQ EQUIVALENTSSTACK NULL)
    (CL:SETQ KEYWITHEQUIVALENTS
     (FIND-SELECTION-KEY-WITH-EQUIVALENTS PATTERN))
    (CL:WHEN (CL:NOT (CL:EQ KEYWITHEQUIVALENTS NULL))
     (CL:SETQ EQUIVALENTSKOLEMS
      (VARIABLE-VALUE-INVERSE KEYWITHEQUIVALENTS))
     (CL:SETQ EQUIVALENTSSTACK (CONS EQUIVALENTSKOLEMS NIL))))
   (CL:WHEN (CL:EQ EQUIVALENTSSTACK NULL)
    (CL:SETF (%ABSTRACT-PROPOSITIONS-ITERATOR.EQUIVALENTS-STACK SELF)
     NIL)
    (CL:RETURN-FROM NEXT-EQUIVALENT-SELECTION-PATTERN NULL))
   (CL:WHEN (CL:EQ EQUIVALENTSSTACK NIL)
    (CL:RETURN-FROM NEXT-EQUIVALENT-SELECTION-PATTERN NULL))
   (CL:SETQ EQUIVALENTSKOLEMS (%%VALUE EQUIVALENTSSTACK))
   (CL:SETQ NEWSKOLEM (%%VALUE EQUIVALENTSKOLEMS))
   (FIRST-SETTER EQUIVALENTSSTACK (%%REST EQUIVALENTSKOLEMS))
   (CL:WHEN (CL:EQ (%%VALUE EQUIVALENTSSTACK) NIL)
    (CL:SETQ EQUIVALENTSSTACK (%%REST EQUIVALENTSSTACK)))
   (CL:WHEN (CL:NOT (CL:EQ (VARIABLE-VALUE-INVERSE NEWSKOLEM) NIL))
    (CL:SETQ EQUIVALENTSSTACK
     (CONS (VARIABLE-VALUE-INVERSE NEWSKOLEM) EQUIVALENTSSTACK)))
   (CL:SETF (%ABSTRACT-PROPOSITIONS-ITERATOR.EQUIVALENTS-STACK SELF)
    EQUIVALENTSSTACK)
   (CL:WHEN (CL:EQ KEYWITHEQUIVALENTS NULL)
    (CL:SETQ KEYWITHEQUIVALENTS
     (FIND-SELECTION-KEY-WITH-EQUIVALENTS PATTERN)))
   (SUBSTITUTE-CONS-TREE (COPY-CONS-TREE PATTERN) NEWSKOLEM
    KEYWITHEQUIVALENTS)))

;;; (DEFUN (PROPOSITION-TRUTH-VALUE TRUTH-VALUE) ...)

(CL:DEFUN PROPOSITION-TRUTH-VALUE (PROPOSITION)
  (CL:LET*
   ((TRUTHVALUE
     (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE PROPOSITION)
      (%PROPOSITION.HOME-CONTEXT PROPOSITION) CL:NIL)))
   (CL:IF (CL:NOT (CL:EQ TRUTHVALUE NULL)) TRUTHVALUE
    (CL:IF
     (CL:AND (CL:NOT *REVERSEPOLARITY?*)
      (FUNCTION-WITH-DEFINED-VALUE? PROPOSITION))
     TRUE-TRUTH-VALUE NULL))))

;;; (DEFUN (TRUE-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN TRUE-PROPOSITION? (PROPOSITION)
  (CL:AND (CL:NOT (DELETED? PROPOSITION))
   (CL:IF *REVERSEPOLARITY?* (FALSE? PROPOSITION)
    (CL:OR (TRUE? PROPOSITION)
     (FUNCTION-WITH-DEFINED-VALUE? PROPOSITION)))))

;;; (DEFUN (TRUE-PROPOSITIONS-ITERATOR.NEXT? BOOLEAN) ...)

(CL:DEFUN TRUE-PROPOSITIONS-ITERATOR.NEXT? (SELF)
  (CL:LET*
   ((CURSOR (%TRUE-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR SELF))
    (PROPOSITION NULL))
   (CL:WHEN (CL:EQ CURSOR NULL)
    (CL:RETURN-FROM TRUE-PROPOSITIONS-ITERATOR.NEXT? CL:NIL))
   (CL:LOOP
    (CL:TAGBODY
     (CL:COND
      ((NEXT? CURSOR) (CL:SETQ PROPOSITION (%ITERATOR.VALUE CURSOR)))
      (CL:T
       (CL:LET* ((PATTERN (NEXT-EQUIVALENT-SELECTION-PATTERN SELF)))
        (CL:COND
         ((CL:NOT (CL:EQ PATTERN NULL))
          (CL:SETQ CURSOR
           (ALLOCATE-ITERATOR (SELECT-PROPOSITIONS PATTERN)))
          (CL:SETF
           (%TRUE-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR SELF)
           CURSOR)
          (CL:GO :CONTINUE))
         (CL:T
          (CL:SETF
           (%TRUE-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR SELF) NULL)
          (CL:RETURN-FROM TRUE-PROPOSITIONS-ITERATOR.NEXT? CL:NIL))))))
     (CL:WHEN
      (CL:AND (CL:NOT (DELETED? PROPOSITION))
       (CL:IF *REVERSEPOLARITY?* (FALSE? PROPOSITION)
        (CL:OR (TRUE? PROPOSITION)
         (FUNCTION-WITH-DEFINED-VALUE? PROPOSITION))))
      (CL:SETF (%TRUE-PROPOSITIONS-ITERATOR.VALUE SELF) PROPOSITION)
      (CL:SETF (%TRUE-PROPOSITIONS-ITERATOR.TRUTH-VALUE SELF)
       (PROPOSITION-TRUTH-VALUE PROPOSITION))
      (CL:RETURN-FROM TRUE-PROPOSITIONS-ITERATOR.NEXT? CL:T))
     :CONTINUE))))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF TRUE-PROPOSITIONS-ITERATOR))
  (TRUE-PROPOSITIONS-ITERATOR.NEXT? SELF))

;;; (DEFUN (SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT? BOOLEAN) ...)

(CL:DEFUN SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT? (SELF)
  (CL:LET*
   ((SPECIALIZINGRELATIONS
     (%SPECIALIZING-PROPOSITIONS-ITERATOR.SPECIALIZING-RELATIONS
      SELF)))
   (CL:LOOP
    (CL:WHEN (TRUE-PROPOSITIONS-ITERATOR.NEXT? SELF)
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ SPECIALIZINGRELATIONS NULL))
       (CL:NOT (CL:EQ SPECIALIZINGRELATIONS NIL)))
      (CL:SETF (%SPECIALIZING-PROPOSITIONS-ITERATOR.TRUTH-VALUE SELF)
       (CONJOIN-TRUTH-VALUES
        (%SPECIALIZING-PROPOSITIONS-ITERATOR.TRUTH-VALUE SELF)
        (%%VALUE (%%REST (%%VALUE SPECIALIZINGRELATIONS))))))
     (CL:SETF
      (%SPECIALIZING-PROPOSITIONS-ITERATOR.SPECIALIZING-RELATIONS SELF)
      SPECIALIZINGRELATIONS)
     (CL:RETURN-FROM SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT? CL:T))
    (CL:IF (CL:EQ SPECIALIZINGRELATIONS NULL)
     (CL:COND
      ((CL:EQ
        (%%VALUE
         (%SPECIALIZING-PROPOSITIONS-ITERATOR.SELECTION-PATTERN SELF))
        KWD-SPECIALIZE-RELATION)
       (CL:LET*
        ((RELATIONDESCRIPTION
          (SURROGATE-TO-DESCRIPTION
           (%%VALUE
            (%%REST
             (%%REST
              (%SPECIALIZING-PROPOSITIONS-ITERATOR.SELECTION-PATTERN
               SELF)))))))
        (CL:IF (CL:NOT (CL:EQ RELATIONDESCRIPTION NULL))
         (CL:SETQ SPECIALIZINGRELATIONS
          (ALL-SUPPORTED-NAMED-SUBCOLLECTIONS RELATIONDESCRIPTION))
         (CL:SETQ SPECIALIZINGRELATIONS NIL))))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "Illegal selection pattern in `" SELF "'")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
     (CL:SETQ SPECIALIZINGRELATIONS (%%REST SPECIALIZINGRELATIONS)))
    (CL:WHEN (CL:EQ SPECIALIZINGRELATIONS NIL)
     (CL:SETF (%SPECIALIZING-PROPOSITIONS-ITERATOR.VALUE SELF) NULL)
     (CL:RETURN-FROM SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT? CL:NIL))
    (FIRST-SETTER
     (%%REST
      (%%REST
       (%SPECIALIZING-PROPOSITIONS-ITERATOR.SELECTION-PATTERN SELF)))
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (%%VALUE (%%VALUE SPECIALIZINGRELATIONS))))
    (CL:SETF
     (%SPECIALIZING-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR SELF)
     (ALLOCATE-ITERATOR
      (SELECT-PROPOSITIONS
       (%SPECIALIZING-PROPOSITIONS-ITERATOR.SELECTION-PATTERN SELF))))
    (CL:SETF
     (%SPECIALIZING-PROPOSITIONS-ITERATOR.EQUIVALENTS-STACK SELF)
     NULL))))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF SPECIALIZING-PROPOSITIONS-ITERATOR))
  (SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT? SELF))

;;; (DEFCONSTANT EMPTY-PROPOSITIONS-ITERATOR ...)

(CL:DEFVAR EMPTY-PROPOSITIONS-ITERATOR NULL
  "This iterator returns no values whenever its called.")

;;; (DEFUN (EMPTY-PROPOSITIONS-INDEX? BOOLEAN) ...)

(CL:DEFUN EMPTY-PROPOSITIONS-INDEX? (INDEX PRIMARYKEY SPECIALIZE?)
  (CL:WHEN
   (CL:AND (CL:NOT SPECIALIZE?)
    (CL:OR (CL:EQ INDEX NIL-PAGING-INDEX)
     (CL:EQ INDEX NIL-NON-PAGING-INDEX)))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE PRIMARYKEY)
      SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:WHEN (CL:EQ (VARIABLE-VALUE-INVERSE PRIMARYKEY) NIL)
       (CL:RETURN-FROM EMPTY-PROPOSITIONS-INDEX? CL:T))))
    (CL:T (CL:RETURN-FROM EMPTY-PROPOSITIONS-INDEX? CL:T))))
  CL:NIL)

;;; (DEFUN (ALL-TRUE-DEPENDENT-PROPOSITIONS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-TRUE-DEPENDENT-PROPOSITIONS (SELF RELATION SPECIALIZE?)
  (CL:WHEN
   (CL:NOT (CL:OR (CL:NOT (CL:EQ RELATION NULL)) (CL:NOT SPECIALIZE?)))
   (CL:ERROR
    "Safety violation: INTERNAL-ERROR: Expected defined relation argument"))
  (CL:LET*
   ((PATTERN
     (CL:IF (CL:NOT (CL:EQ RELATION NULL))
      (CONS KWD-SPECIALIZE-RELATION
       (CONS (CL:IF (CL:EQ NIL NULL) NIL NIL)
        (CONS RELATION (CONS (VALUE-OF SELF) NIL))))
      (CONS KWD-SPECIALIZE-DEPENDENTS
       (CONS (CL:IF (CL:EQ NIL NULL) NIL NIL)
        (CONS (VALUE-OF SELF) NIL)))))
    (INDEX (SELECT-PROPOSITIONS PATTERN)) (ITERATOR NULL))
   (CL:WHEN (EMPTY-PROPOSITIONS-INDEX? INDEX SELF SPECIALIZE?)
    (CL:RETURN-FROM ALL-TRUE-DEPENDENT-PROPOSITIONS
     EMPTY-PROPOSITIONS-ITERATOR))
   (CL:SETQ ITERATOR
    (CL:IF SPECIALIZE? (NEW-SPECIALIZING-PROPOSITIONS-ITERATOR)
     (NEW-TRUE-PROPOSITIONS-ITERATOR)))
   (CL:SETF (%TRUE-PROPOSITIONS-ITERATOR.SELECTION-PATTERN ITERATOR)
    PATTERN)
   (CL:SETF (%TRUE-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR ITERATOR)
    (ALLOCATE-ITERATOR INDEX))
   ITERATOR))

;;; (DEFUN (ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS (SELF)
  (CL:LET*
   ((PATTERN
     (CONS KWD-SPECIALIZE-ISA
      (CONS (CL:IF (CL:EQ NIL NULL) NIL NIL)
       (CONS (VALUE-OF SELF) NIL))))
    (INDEX (SELECT-PROPOSITIONS PATTERN)))
   (CL:IF (EMPTY-PROPOSITIONS-INDEX? INDEX SELF CL:NIL)
    EMPTY-PROPOSITIONS-ITERATOR
    (CL:LET* ((SELF-000 (NEW-TRUE-PROPOSITIONS-ITERATOR)))
     (CL:SETF (%TRUE-PROPOSITIONS-ITERATOR.SELECTION-PATTERN SELF-000)
      PATTERN)
     (CL:SETF (%TRUE-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR SELF-000)
      (ALLOCATE-ITERATOR INDEX))
     (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))))

;;; (DEFUN (ARGUMENTS-UNIFY-WITH-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN ARGUMENTS-UNIFY-WITH-ARGUMENTS? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:LET*
   ((PATTERNRECORD
     (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))
    (UBSTACKOFFSET
     (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))
    (SUCCESS? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:LET* ((ALWAYS?-000 CL:T))
     (CL:LET*
      ((SUPERARG NULL)
       (VECTOR-000 (%PROPOSITION.ARGUMENTS REFERENCEPROPOSITION))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (SUBARG NULL)
       (VECTOR-001 (%PROPOSITION.ARGUMENTS SUBPROPOSITION))
       (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:DECLARE
       (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
      (CL:LOOP WHILE
       (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
       DO
       (CL:SETQ SUPERARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ SUBARG
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (NULL-INSTANCE? SUBARG))
          (BIND-ARGUMENT-TO-VALUE? SUPERARG (VALUE-OF SUBARG) CL:NIL)))
        (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
     (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
    (CL:WHEN TEST-VALUE-000
     (CL:SETQ TEST-VALUE-000
      (CL:= (LENGTH (%PROPOSITION.ARGUMENTS REFERENCEPROPOSITION))
       (LENGTH (%PROPOSITION.ARGUMENTS SUBPROPOSITION)))))
    (CL:SETQ SUCCESS? TEST-VALUE-000))
   (CL:WHEN (CL:NOT SUCCESS?)
    (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD
     (CL:1+ UBSTACKOFFSET)))
   SUCCESS?))

;;; (DEFUN (ARGUMENTS-EQUAL-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN ARGUMENTS-EQUAL-ARGUMENTS? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:LET* ((ALWAYS?-000 CL:T))
    (CL:LET*
     ((SUPERARG NULL)
      (VECTOR-000 (%PROPOSITION.ARGUMENTS REFERENCEPROPOSITION))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (SUBARG NULL)
      (VECTOR-001 (%PROPOSITION.ARGUMENTS SUBPROPOSITION))
      (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
      DO
      (CL:SETQ SUPERARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ SUBARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
        INDEX-001))
      (CL:WHEN (CL:NOT (EQL? (VALUE-OF SUPERARG) (VALUE-OF SUBARG)))
       (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
    (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000
     (CL:= (LENGTH (%PROPOSITION.ARGUMENTS REFERENCEPROPOSITION))
      (LENGTH (%PROPOSITION.ARGUMENTS SUBPROPOSITION)))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (ARGUMENTS-MATCH-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN ARGUMENTS-MATCH-ARGUMENTS? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:IF (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
   (ARGUMENTS-UNIFY-WITH-ARGUMENTS? SUBPROPOSITION
    REFERENCEPROPOSITION)
   (ARGUMENTS-EQUAL-ARGUMENTS? SUBPROPOSITION REFERENCEPROPOSITION)))

;;; (DEFUN (PREFIX-ARGUMENTS-EQUAL-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN PREFIX-ARGUMENTS-EQUAL-ARGUMENTS? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:LET* ((ALWAYS?-000 CL:T))
    (CL:LET*
     ((SUPERARG NULL)
      (VECTOR-000 (%PROPOSITION.ARGUMENTS REFERENCEPROPOSITION))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (SUBARG NULL)
      (VECTOR-001 (%PROPOSITION.ARGUMENTS SUBPROPOSITION))
      (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001))
      DO
      (CL:SETQ SUPERARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:SETQ SUBARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
        INDEX-001))
      (CL:WHEN (CL:NOT (EQL? (VALUE-OF SUPERARG) (VALUE-OF SUBARG)))
       (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
    (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (ALL-MATCHING-PROPOSITIONS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-MATCHING-PROPOSITIONS (SELF)
  (CL:LET* ((BACKLINKEDARGUMENT NULL) (NOMATCHINGPROPOSITIONS? CL:NIL))
   (CL:MULTIPLE-VALUE-SETQ (BACKLINKEDARGUMENT NOMATCHINGPROPOSITIONS?)
    (SELECT-ARGUMENT-WITH-BACKLINKS SELF))
   (CL:WHEN NOMATCHINGPROPOSITIONS?
    (CL:RETURN-FROM ALL-MATCHING-PROPOSITIONS
     EMPTY-PROPOSITIONS-ITERATOR))
   (CL:WHEN (CL:EQ BACKLINKEDARGUMENT NULL)
    (CL:WHEN *CYC-KLUDGES-ENABLED?*
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:LET* ((FOUND?-000 CL:NIL))
       (CL:LET*
        ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS SELF))
         (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ ARG
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:WHEN (CL:NOT (CL:EQ (ARGUMENT-BOUND-TO ARG) NULL))
          (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
       (CL:SETQ TEST-VALUE-000 FOUND?-000))
      (CL:WHEN TEST-VALUE-000
       (CL:SETQ TEST-VALUE-000
        (>
         (DYNAMICALLY-ESTIMATE-EXTENSION-SIZE
          (GET-DESCRIPTION (%PROPOSITION.OPERATOR SELF)))
         500)))
      (CL:WHEN TEST-VALUE-000
       (CL:RETURN-FROM ALL-MATCHING-PROPOSITIONS
        EMPTY-PROPOSITIONS-ITERATOR))))
    (CL:RETURN-FROM ALL-MATCHING-PROPOSITIONS
     (ALL-MATCHING-EXTENSION-MEMBERS SELF CL:T)))
   (CL:LET* ((PATTERNARGS NIL) (BINDING NULL))
    (CL:LET*
     ((ARG NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS SELF))
      (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001))
      (COLLECT-000 NULL))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
     (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
      (CL:SETQ ARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
        INDEX-001))
      (CL:SETQ BINDING (ARGUMENT-BOUND-TO ARG))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ BINDING NULL))
        (ISA? BINDING SGT-SPECIALIZE-LOGIC-PROPOSITION)
        (CL:NOT (ALL-ARGUMENTS-BOUND? BINDING)))
       (CL:SETQ BINDING NULL))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS (VALUE-OF BINDING) NIL))
        (CL:IF (CL:EQ PATTERNARGS NIL)
         (CL:SETQ PATTERNARGS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST PATTERNARGS COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000) (CONS (VALUE-OF BINDING) NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
    (CL:IF (CL:EQ (%%REST PATTERNARGS) NIL)
     (ALL-TRUE-DEPENDENT-PROPOSITIONS BACKLINKEDARGUMENT
      (%PROPOSITION.OPERATOR SELF) CL:T)
     (CL:LET*
      ((PATTERN
        (CONS KWD-SPECIALIZE-RELATION
         (CONS (CL:IF (CL:EQ NIL NULL) NIL NIL)
          (CONS (%PROPOSITION.OPERATOR SELF) PATTERNARGS)))))
      (CL:LET* ((SELF-000 (NEW-SPECIALIZING-PROPOSITIONS-ITERATOR)))
       (CL:SETF
        (%SPECIALIZING-PROPOSITIONS-ITERATOR.SELECTION-PATTERN
         SELF-000)
        PATTERN)
       (CL:SETF
        (%SPECIALIZING-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR
         SELF-000)
        (ALLOCATE-ITERATOR (SELECT-PROPOSITIONS PATTERN)))
       (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))))))

;;; (DEFUN (ALL-PROPOSITIONS-MATCHING-ARGUMENTS (CONS OF PROPOSITION)) ...)

(CL:DEFUN ALL-PROPOSITIONS-MATCHING-ARGUMENTS (ARGUMENTS RELATION SPECIALIZE?)
  (CL:LET*
   ((BACKLINKEDINSTANCE
     (SELECT-INSTANCE-WITH-BACKLINKS ARGUMENTS RELATION)))
   (CL:WHEN (CL:EQ BACKLINKEDINSTANCE NULL)
    (CL:RETURN-FROM ALL-PROPOSITIONS-MATCHING-ARGUMENTS NIL))
   (CL:LET* ((VALUE-000 NIL))
    (CL:LET*
     ((PROP NULL)
      (ITER-000
       (ALL-TRUE-DEPENDENT-PROPOSITIONS BACKLINKEDINSTANCE RELATION
        SPECIALIZE?))
      (COLLECT-000 NULL))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ PROP (%ITERATOR.VALUE ITER-000))
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET*
        ((A1 NULL) (ITER-001 ARGUMENTS) (I NULL-INTEGER) (ITER-002 0))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ A1 (%%VALUE ITER-001)) (CL:SETQ I ITER-002)
         (CL:WHEN
          (CL:NOT
           (EQL? (VALUE-OF A1)
            (VALUE-OF
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROP)))
              I))))
          (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
         (CL:SETQ ITER-001 (%%REST ITER-001))
         (CL:SETQ ITER-002 (CL:1+ ITER-002))))
       (CL:WHEN ALWAYS?-000
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS PROP NIL))
          (CL:IF (CL:EQ VALUE-000 NIL) (CL:SETQ VALUE-000 COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST VALUE-000 COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS PROP NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))))
    (CL:LET* ((VALUE-001 VALUE-000)) VALUE-001))))

;;; (DEFUN (ALL-DEFINING-PROPOSITIONS (CONS OF PROPOSITION)) ...)

(CL:DEFUN ALL-DEFINING-PROPOSITIONS (OUTPUTARGUMENT RELATION SPECIALIZE?)
  (CL:LET* ((*REVERSEPOLARITY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (CL:LET*
    ((RESULT NIL) (OUTPUTARGUMENTVALUE (VALUE-OF OUTPUTARGUMENT)))
    (CL:LET*
     ((PROP NULL)
      (ITER-000
       (ALL-TRUE-DEPENDENT-PROPOSITIONS OUTPUTARGUMENTVALUE RELATION
        SPECIALIZE?))
      (COLLECT-000 NULL))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ PROP (%ITERATOR.VALUE ITER-000))
      (CL:WHEN
       (CL:AND (CL:EQ (%PROPOSITION.KIND PROP) KWD-SPECIALIZE-FUNCTION)
        (EQL?
         (VALUE-OF
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROP)))
           (CL:THE CL:FIXNUM
            (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS PROP))))))
         OUTPUTARGUMENTVALUE))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS PROP NIL))
         (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS PROP NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
    RESULT)))

;;; (DEFUN (HELP-MEMOIZE-TEST-PROPERTY? BOOLEAN) ...)

(CL:DEFUN HELP-MEMOIZE-TEST-PROPERTY? (SELF RELATION)
  (CL:LET*
   ((*REVERSEPOLARITY?* CL:NIL)
    (*CONTEXT* (GET-PROPERTY-TEST-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?* *CONTEXT*))
   (CL:IF
    (CL:AND (ISA? SELF SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT)
     (CL:EQ (VARIABLE-VALUE-INVERSE SELF) NIL))
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((P NULL)
       (ITER-000
        (ALLOCATE-ITERATOR
         (UNFILTERED-DEPENDENT-PROPOSITIONS SELF RELATION))))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ P (%ITERATOR.VALUE ITER-000))
       (CL:WHEN
        (CL:AND (CL:EQ (%PROPOSITION.OPERATOR P) RELATION)
         (CL:AND (CL:NOT (DELETED? P))
          (CL:IF *REVERSEPOLARITY?* (FALSE? P)
           (CL:OR (TRUE? P) (FUNCTION-WITH-DEFINED-VALUE? P)))))
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))))
     (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000))
    (NEXT? (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF RELATION CL:NIL)))))

;;; (DEFUN (TEST-PROPERTY? BOOLEAN) ...)

(CL:DEFUN TEST-PROPERTY? (SELF RELATION)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
    (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE.SURROGATE-VALUE
      SGT-SPECIALIZE-LOGIC-F-TEST-PROPERTY?-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-SPECIALIZE-LOGIC-F-TEST-PROPERTY?-MEMO-TABLE-000
      "(:MAX-VALUES 500 :TIMESTAMPS (:KB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE.SURROGATE-VALUE
       SGT-SPECIALIZE-LOGIC-F-TEST-PROPERTY?-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF RELATION *CONTEXT*
      MEMOIZED-NULL-VALUE 6))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (CL:IF (HELP-MEMOIZE-TEST-PROPERTY? SELF RELATION) TRUE-WRAPPER
       FALSE-WRAPPER))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE-000))))

;;; (DEFUN (HELP-MEMOIZE-TEST-ISA? BOOLEAN) ...)

(CL:DEFUN HELP-MEMOIZE-TEST-ISA? (MEMBER TYPE)
  (CL:LET*
   ((*REVERSEPOLARITY?* CL:NIL)
    (*CONTEXT* (GET-PROPERTY-TEST-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?* *CONTEXT*))
   (CL:LET* ((FOUND?-000 CL:NIL))
    (CL:LET*
     ((PROP NULL)
      (ITER-000 (ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS MEMBER)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ PROP (%ITERATOR.VALUE ITER-000))
      (CL:WHEN
       (RELATIONREF-SPECIALIZES-RELATIONREF?
        (%PROPOSITION.OPERATOR PROP) TYPE)
       (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))))
    (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000))))

;;; (DEFUN (TEST-ISA? BOOLEAN) ...)

(CL:DEFUN TEST-ISA? (MEMBER TYPE)
  (CL:COND ((CL:EQ TYPE SGT-SPECIALIZE-STELLA-THING) CL:T)
   ((CL:OR (CL:EQ TYPE SGT-SPECIALIZE-PL-KERNEL-KB-CLASS)
     (CL:EQ TYPE SGT-SPECIALIZE-PL-KERNEL-KB-RELATION)
     (CL:EQ TYPE SGT-SPECIALIZE-PL-KERNEL-KB-FUNCTION)
     (CL:EQ TYPE SGT-SPECIALIZE-PL-KERNEL-KB-COLLECTION)
     (CL:EQ TYPE SGT-SPECIALIZE-PL-KERNEL-KB-SET))
    (CL:LET*
     ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
      (MEMOIZED-VALUE-000 NULL))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETQ MEMO-TABLE-000
       (%SURROGATE.SURROGATE-VALUE
        SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-000))
      (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
       (INITIALIZE-MEMOIZATION-TABLE
        SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-000
        "(:MAX-VALUES 1000 :TIMESTAMPS (:META-KB-UPDATE))")
       (CL:SETQ MEMO-TABLE-000
        (%SURROGATE.SURROGATE-VALUE
         SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-000)))
      (CL:SETQ MEMOIZED-ENTRY-000
       (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 MEMBER TYPE *CONTEXT*
        MEMOIZED-NULL-VALUE 6))
      (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
     (CL:COND
      ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
       (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
        (CL:SETQ MEMOIZED-VALUE-000 NULL)))
      (CL:T
       (CL:SETQ MEMOIZED-VALUE-000
        (CL:IF (HELP-MEMOIZE-TEST-ISA? MEMBER TYPE) TRUE-WRAPPER
         FALSE-WRAPPER))
       (CL:WHEN *MEMOIZATION-ENABLED?*
        (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
         (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
          MEMOIZED-VALUE-000)))))
     (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE-000))))
   (CL:T
    (CL:LET*
     ((MEMO-TABLE-001 NULL) (MEMOIZED-ENTRY-001 NULL)
      (MEMOIZED-VALUE-001 NULL))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETQ MEMO-TABLE-001
       (%SURROGATE.SURROGATE-VALUE
        SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-001))
      (CL:WHEN (CL:EQ MEMO-TABLE-001 NULL)
       (INITIALIZE-MEMOIZATION-TABLE
        SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-001
        "(:MAX-VALUES 1000 :TIMESTAMPS (:KB-UPDATE))")
       (CL:SETQ MEMO-TABLE-001
        (%SURROGATE.SURROGATE-VALUE
         SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-001)))
      (CL:SETQ MEMOIZED-ENTRY-001
       (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-001 MEMBER TYPE *CONTEXT*
        MEMOIZED-NULL-VALUE 6))
      (CL:SETQ MEMOIZED-VALUE-001 (%%VALUE MEMOIZED-ENTRY-001)))
     (CL:COND
      ((CL:NOT (CL:EQ MEMOIZED-VALUE-001 NULL))
       (CL:WHEN (CL:EQ MEMOIZED-VALUE-001 MEMOIZED-NULL-VALUE)
        (CL:SETQ MEMOIZED-VALUE-001 NULL)))
      (CL:T
       (CL:SETQ MEMOIZED-VALUE-001
        (CL:IF (HELP-MEMOIZE-TEST-ISA? MEMBER TYPE) TRUE-WRAPPER
         FALSE-WRAPPER))
       (CL:WHEN *MEMOIZATION-ENABLED?*
        (CL:SETF (%%VALUE MEMOIZED-ENTRY-001)
         (CL:IF (CL:EQ MEMOIZED-VALUE-001 NULL) MEMOIZED-NULL-VALUE
          MEMOIZED-VALUE-001)))))
     (CL:LET* ((VALUE-001 MEMOIZED-VALUE-001))
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE-001))))))

;;; (DEFUN (HELP-MEMOIZE-ACCESS-BINARY-VALUE OBJECT) ...)

(CL:DEFUN HELP-MEMOIZE-ACCESS-BINARY-VALUE (SELF RELATION)
  (CL:LET*
   ((*REVERSEPOLARITY?* CL:NIL)
    (*CONTEXT* (GET-PROPERTY-TEST-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?* *CONTEXT*))
   (CL:LET*
    ((RESULT NULL)
     (ITERATOR (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF RELATION CL:NIL))
     (PROPOSITION NULL))
    (CL:LOOP WHILE (NEXT? ITERATOR) DO
     (CL:SETQ PROPOSITION (%ITERATOR.VALUE ITERATOR))
     (CL:WHEN
      (EQL?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
        0)
       SELF)
      (CL:SETQ RESULT
       (VALUE-OF
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
         1)))
      (CL:RETURN-FROM HELP-MEMOIZE-ACCESS-BINARY-VALUE RESULT)))
    NULL)))

;;; (DEFUN (ACCESS-BINARY-VALUE OBJECT) ...)

(CL:DEFUN ACCESS-BINARY-VALUE (SELF RELATION)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
    (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE.SURROGATE-VALUE
      SGT-SPECIALIZE-LOGIC-F-ACCESS-BINARY-VALUE-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-SPECIALIZE-LOGIC-F-ACCESS-BINARY-VALUE-MEMO-TABLE-000
      "(:MAX-VALUES 1000 :TIMESTAMPS (:KB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE.SURROGATE-VALUE
       SGT-SPECIALIZE-LOGIC-F-ACCESS-BINARY-VALUE-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF RELATION *CONTEXT*
      MEMOIZED-NULL-VALUE 6))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (HELP-MEMOIZE-ACCESS-BINARY-VALUE SELF RELATION))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000)) VALUE-000)))

;;; (DEFUN (TEST-COLLECTIONOF-MEMBER-OF? BOOLEAN) ...)

(CL:DEFUN TEST-COLLECTIONOF-MEMBER-OF? (MEMBER TYPE)
  (CL:LET*
   ((*REVERSEPOLARITY?* CL:NIL)
    (*CONTEXT* (GET-PROPERTY-TEST-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?* *CONTEXT*))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALL-TRUE-DEPENDENT-PROPOSITIONS MEMBER
       SGT-SPECIALIZE-PL-KERNEL-KB-COLLECTIONOF CL:T)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ P (%ITERATOR.VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:NOT (DELETED? P))
       (CL:IF *REVERSEPOLARITY?* (FALSE? P)
        (CL:OR (TRUE? P) (FUNCTION-WITH-DEFINED-VALUE? P))))
      (CL:LET* ((COLLECTION (LAST (%PROPOSITION.ARGUMENTS P))))
       (CL:WHEN
        (CL:AND (CL:NOT (EQL? MEMBER COLLECTION))
         (COLLECTION-IMPLIES-COLLECTION? COLLECTION
          (SURROGATE-TO-DESCRIPTION TYPE)))
        (CL:RETURN-FROM TEST-COLLECTIONOF-MEMBER-OF? CL:T))))))
   CL:NIL))

(CL:DEFUN NEW-TRANSITIVE-CLOSURE-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-TRANSITIVE-CLOSURE-ITERATOR))
   (CL:SETF (%TRANSITIVE-CLOSURE-ITERATOR.FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%TRANSITIVE-CLOSURE-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%TRANSITIVE-CLOSURE-ITERATOR.BEEN-THERE-LIST SELF) NULL)
   (CL:SETF
    (%TRANSITIVE-CLOSURE-ITERATOR.ADJACENCY-ITERATOR-STACK SELF) NIL)
   (CL:SETF (%TRANSITIVE-CLOSURE-ITERATOR.FILTER? SELF) NULL)
   (CL:SETF
    (%TRANSITIVE-CLOSURE-ITERATOR.ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
     SELF)
    NULL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSITIVE-CLOSURE-ITERATOR))
  SGT-SPECIALIZE-LOGIC-TRANSITIVE-CLOSURE-ITERATOR)

(CL:DEFUN ACCESS-TRANSITIVE-CLOSURE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME
     SYM-SPECIALIZE-LOGIC-ALLOCATE-ADJACENCY-ITERATOR-FUNCTION)
    (CL:IF SETVALUE?
     (CL:SETF
      (%TRANSITIVE-CLOSURE-ITERATOR.ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
       SELF)
      (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FUNCTION-CODE
       (%TRANSITIVE-CLOSURE-ITERATOR.ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
        SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-FILTER?)
    (CL:IF SETVALUE?
     (CL:SETF (%TRANSITIVE-CLOSURE-ITERATOR.FILTER? SELF)
      (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FUNCTION-CODE
       (%TRANSITIVE-CLOSURE-ITERATOR.FILTER? SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-ADJACENCY-ITERATOR-STACK)
    (CL:IF SETVALUE?
     (CL:SETF
      (%TRANSITIVE-CLOSURE-ITERATOR.ADJACENCY-ITERATOR-STACK SELF)
      VALUE)
     (CL:SETQ VALUE
      (%TRANSITIVE-CLOSURE-ITERATOR.ADJACENCY-ITERATOR-STACK SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-BEEN-THERE-LIST)
    (CL:IF SETVALUE?
     (CL:SETF (%TRANSITIVE-CLOSURE-ITERATOR.BEEN-THERE-LIST SELF)
      VALUE)
     (CL:SETQ VALUE
      (%TRANSITIVE-CLOSURE-ITERATOR.BEEN-THERE-LIST SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (TRANSITIVE-CLOSURE-ITERATOR.NEXT? BOOLEAN) ...)

(CL:DEFUN TRANSITIVE-CLOSURE-ITERATOR.NEXT? (SELF)
  (CL:LET*
   ((NODE (%TRANSITIVE-CLOSURE-ITERATOR.VALUE SELF))
    (ADJACENCYITERATOR
     (CL:FUNCALL
      (%TRANSITIVE-CLOSURE-ITERATOR.ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
       SELF)
      NODE)))
   (CL:IF (CL:NOT (CL:EQ ADJACENCYITERATOR NULL))
    (CL:SETF
     (%TRANSITIVE-CLOSURE-ITERATOR.ADJACENCY-ITERATOR-STACK SELF)
     (CONS ADJACENCYITERATOR
      (%TRANSITIVE-CLOSURE-ITERATOR.ADJACENCY-ITERATOR-STACK SELF)))
    (CL:PROGN
     (CL:SETQ ADJACENCYITERATOR
      (%%VALUE
       (%TRANSITIVE-CLOSURE-ITERATOR.ADJACENCY-ITERATOR-STACK SELF)))
     (CL:WHEN (CL:EQ ADJACENCYITERATOR NULL)
      (CL:RETURN-FROM TRANSITIVE-CLOSURE-ITERATOR.NEXT? CL:NIL))))
   (CL:LOOP
    (CL:LOOP WHILE (CL:NOT (NEXT? ADJACENCYITERATOR)) DO
     (CL:SETF
      (%TRANSITIVE-CLOSURE-ITERATOR.ADJACENCY-ITERATOR-STACK SELF)
      (%%REST
       (%TRANSITIVE-CLOSURE-ITERATOR.ADJACENCY-ITERATOR-STACK SELF)))
     (CL:SETQ ADJACENCYITERATOR
      (%%VALUE
       (%TRANSITIVE-CLOSURE-ITERATOR.ADJACENCY-ITERATOR-STACK SELF)))
     (CL:WHEN (CL:EQ ADJACENCYITERATOR NULL)
      (CL:RETURN-FROM TRANSITIVE-CLOSURE-ITERATOR.NEXT? CL:NIL)))
    (CL:SETQ NODE (%ITERATOR.VALUE ADJACENCYITERATOR))
    (CL:WHEN
     (CL:AND
      (CL:NOT
       (MEMBER? (%TRANSITIVE-CLOSURE-ITERATOR.BEEN-THERE-LIST SELF)
        NODE))
      (CL:OR (CL:EQ (%TRANSITIVE-CLOSURE-ITERATOR.FILTER? SELF) NULL)
       (CL:FUNCALL (%TRANSITIVE-CLOSURE-ITERATOR.FILTER? SELF) NODE)))
     (CL:SETF (%TRANSITIVE-CLOSURE-ITERATOR.BEEN-THERE-LIST SELF)
      (CONS NODE (%TRANSITIVE-CLOSURE-ITERATOR.BEEN-THERE-LIST SELF)))
     (CL:SETF (%TRANSITIVE-CLOSURE-ITERATOR.VALUE SELF) NODE)
     (CL:RETURN-FROM TRANSITIVE-CLOSURE-ITERATOR.NEXT? CL:T)))))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF TRANSITIVE-CLOSURE-ITERATOR))
  (TRANSITIVE-CLOSURE-ITERATOR.NEXT? SELF))

;;; (DEFUN (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR ITERATOR) ...)

(CL:DEFUN ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR (STARTNODE ALLOCATEADJACENCYITERATOR FILTERFUNCTION)
  "Return an iterator that generates the transitive
closure of applying iterators generated by 'allocateAdjacencyIterator'
to 'startNode'.  If 'filterFunction' is non-null, that function is applied
as a filter to each node generated (nodes filtered out still generate
descendants, but they don't get returned)."
  (CL:LET* ((ITERATOR (NEW-TRANSITIVE-CLOSURE-ITERATOR)))
   (CL:SETF (%TRANSITIVE-CLOSURE-ITERATOR.VALUE ITERATOR) STARTNODE)
   (CL:SETF (%TRANSITIVE-CLOSURE-ITERATOR.BEEN-THERE-LIST ITERATOR)
    NIL)
   (CL:SETF
    (%TRANSITIVE-CLOSURE-ITERATOR.ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
     ITERATOR)
    ALLOCATEADJACENCYITERATOR)
   (CL:SETF (%TRANSITIVE-CLOSURE-ITERATOR.FILTER? ITERATOR)
    FILTERFUNCTION)
   ITERATOR))

(CL:DEFUN NEW-SUPPORTED-CLOSURE-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-SUPPORTED-CLOSURE-ITERATOR))
   (CL:SETF (%SUPPORTED-CLOSURE-ITERATOR.FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%SUPPORTED-CLOSURE-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%SUPPORTED-CLOSURE-ITERATOR.BEEN-THERE-LIST SELF) NULL)
   (CL:SETF (%SUPPORTED-CLOSURE-ITERATOR.FILTER? SELF) NULL)
   (CL:SETF
    (%SUPPORTED-CLOSURE-ITERATOR.ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
     SELF)
    NULL)
   (CL:SETF (%SUPPORTED-CLOSURE-ITERATOR.ADJACENCY-ITERATOR-STACK SELF)
    NIL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SUPPORTED-CLOSURE-ITERATOR))
  SGT-SPECIALIZE-LOGIC-SUPPORTED-CLOSURE-ITERATOR)

(CL:DEFUN ACCESS-SUPPORTED-CLOSURE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-ADJACENCY-ITERATOR-STACK)
    (CL:IF SETVALUE?
     (CL:SETF
      (%SUPPORTED-CLOSURE-ITERATOR.ADJACENCY-ITERATOR-STACK SELF)
      VALUE)
     (CL:SETQ VALUE
      (%SUPPORTED-CLOSURE-ITERATOR.ADJACENCY-ITERATOR-STACK SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (ALLOCATE-SUPPORTED-CLOSURE-ITERATOR SUPPORTED-CLOSURE-ITERATOR) ...)

(CL:DEFUN ALLOCATE-SUPPORTED-CLOSURE-ITERATOR (STARTNODE ALLOCATEADJACENCYITERATOR FILTERFUNCTION)
  "Similar to `allocate-transitive-closure-iterator' (which see),
but return a SUPPORTED-CLOSURE-ITERATOR instead."
  (CL:LET* ((ITERATOR (NEW-SUPPORTED-CLOSURE-ITERATOR)))
   (CL:SETF (%SUPPORTED-CLOSURE-ITERATOR.VALUE ITERATOR) STARTNODE)
   (CL:SETF (%SUPPORTED-CLOSURE-ITERATOR.BEEN-THERE-LIST ITERATOR) NIL)
   (CL:SETF
    (%SUPPORTED-CLOSURE-ITERATOR.ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
     ITERATOR)
    ALLOCATEADJACENCYITERATOR)
   (CL:SETF (%SUPPORTED-CLOSURE-ITERATOR.FILTER? ITERATOR)
    FILTERFUNCTION)
   ITERATOR))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF SUPPORTED-CLOSURE-ITERATOR))
  (CL:COND
   ((TRANSITIVE-CLOSURE-ITERATOR.NEXT? SELF)
    (CL:SETF (%SUPPORTED-CLOSURE-ITERATOR.VALUE SELF)
     (CONS (%SUPPORTED-CLOSURE-ITERATOR.VALUE SELF)
      (CONS
       (%TRUE-PROPOSITIONS-ITERATOR.TRUTH-VALUE
        (%%VALUE
         (%SUPPORTED-CLOSURE-ITERATOR.ADJACENCY-ITERATOR-STACK SELF)))
       NIL)))
    CL:T)
   (CL:T CL:NIL)))

(CL:DEFUN NEW-DIRECTLY-LINKED-OBJECTS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-DIRECTLY-LINKED-OBJECTS-ITERATOR))
   (CL:SETF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.FIRST-ITERATION? SELF)
    CL:T)
   (CL:SETF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.EQUIVALENTS-STACK SELF)
    NULL)
   (CL:SETF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.PROPOSITION-CURSOR SELF)
    NULL)
   (CL:SETF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.SELECTION-PATTERN SELF)
    NULL)
   (CL:SETF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.TRUTH-VALUE SELF) NULL)
   (CL:SETF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.ROOT-TRUTH-VALUE SELF)
    TRUE-TRUTH-VALUE)
   (CL:SETF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.INVERSE? SELF) CL:NIL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DIRECTLY-LINKED-OBJECTS-ITERATOR))
  SGT-SPECIALIZE-LOGIC-DIRECTLY-LINKED-OBJECTS-ITERATOR)

(CL:DEFUN ACCESS-DIRECTLY-LINKED-OBJECTS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-INVERSE?)
    (CL:IF SETVALUE?
     (CL:SETF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.INVERSE? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.INVERSE? SELF)
       TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-ROOT-TRUTH-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.ROOT-TRUTH-VALUE SELF)
      VALUE)
     (CL:SETQ VALUE
      (%DIRECTLY-LINKED-OBJECTS-ITERATOR.ROOT-TRUTH-VALUE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF DIRECTLY-LINKED-OBJECTS-ITERATOR))
  (CL:LET* ((PROPOSITION NULL))
   (CL:LET* ((*REVERSEPOLARITY?* CL:NIL))
    (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
    (CL:WHEN (TRUE-PROPOSITIONS-ITERATOR.NEXT? SELF)
     (CL:SETQ PROPOSITION
      (%DIRECTLY-LINKED-OBJECTS-ITERATOR.VALUE SELF))
     (CL:SETF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.VALUE SELF)
      (VALUE-OF
       (CL:IF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.INVERSE? SELF)
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
         0)
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS PROPOSITION)))
         1))))
     (CL:SETF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.TRUTH-VALUE SELF)
      (CONJOIN-TRUTH-VALUES
       (%DIRECTLY-LINKED-OBJECTS-ITERATOR.TRUTH-VALUE SELF)
       (%DIRECTLY-LINKED-OBJECTS-ITERATOR.ROOT-TRUTH-VALUE SELF)))
     (CL:RETURN-FROM NEXT? CL:T))
    (CL:SETF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.VALUE SELF) NULL)
    CL:NIL)))

;;; (DEFUN (ALL-DIRECTLY-LINKED-OBJECTS ITERATOR) ...)

(CL:DEFUN ALL-DIRECTLY-LINKED-OBJECTS (SELF RELATION INVERSE?)
  (CL:LET*
   ((PATTERN
     (CL:IF INVERSE?
      (MAKE-RELATION-PATTERN-2 RELATION NULL (VALUE-OF SELF))
      (MAKE-RELATION-PATTERN-2 RELATION (VALUE-OF SELF) NULL)))
    (INDEX (SELECT-PROPOSITIONS PATTERN)))
   (CL:WHEN (EMPTY-PROPOSITIONS-INDEX? INDEX SELF CL:NIL)
    (CL:RETURN-FROM ALL-DIRECTLY-LINKED-OBJECTS
     EMPTY-PROPOSITIONS-ITERATOR))
   (CL:LET* ((SELF-000 (NEW-DIRECTLY-LINKED-OBJECTS-ITERATOR)))
    (CL:SETF
     (%DIRECTLY-LINKED-OBJECTS-ITERATOR.SELECTION-PATTERN SELF-000)
     PATTERN)
    (CL:SETF
     (%DIRECTLY-LINKED-OBJECTS-ITERATOR.PROPOSITION-CURSOR SELF-000)
     (ALLOCATE-ITERATOR INDEX))
    (CL:SETF (%DIRECTLY-LINKED-OBJECTS-ITERATOR.INVERSE? SELF-000)
     INVERSE?)
    (CL:LET* ((VALUE-000 SELF-000)) VALUE-000))))

;;; (DEFUN (ALL-DIRECT-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-SUPERCOLLECTIONS (SELF PERFORMFILTERING?)
  (CL:WHEN (ISA? SELF SGT-SPECIALIZE-LOGIC-DESCRIPTION)
   (DERIVE-DEFERRED-SATELLITE-RULES SELF))
  (CL:LET*
   ((DIRECTLYLINKEDOBJECTS
     (ALL-DIRECTLY-LINKED-OBJECTS SELF
      SGT-SPECIALIZE-PL-KERNEL-KB-SUBSET-OF *REVERSEPOLARITY?*)))
   (CL:WHEN (CL:NOT PERFORMFILTERING?)
    (CL:RETURN-FROM ALL-DIRECT-SUPERCOLLECTIONS DIRECTLYLINKEDOBJECTS))
   (CL:LET*
    ((DIRECTSUPERS NIL)
     (EQUIVALENTS (ALL-EQUIVALENT-COLLECTIONS SELF CL:T)))
    (CL:IF (CL:NOT (CL:EQ (%%REST EQUIVALENTS) NIL))
     (CL:LET* ((E NULL) (ITER-000 EQUIVALENTS))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ E (%%VALUE ITER-000))
       (CL:LET*
        ((PARENT NULL)
         (ITER-001 (ALL-DIRECT-SUPERCOLLECTIONS E CL:NIL)))
        (CL:LOOP WHILE (NEXT? ITER-001) DO
         (CL:SETQ PARENT (%ITERATOR.VALUE ITER-001))
         (CL:WHEN
          (CL:AND (CL:NOT (MEMBER? EQUIVALENTS PARENT))
           (CL:NOT (MEMBER? DIRECTSUPERS PARENT)))
          (CL:SETQ DIRECTSUPERS (CONS PARENT DIRECTSUPERS)))))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:SETQ DIRECTSUPERS (CONSIFY DIRECTLYLINKEDOBJECTS)))
    (ALLOCATE-ITERATOR (MOST-SPECIFIC-COLLECTIONS DIRECTSUPERS)))))

;;; (DEFUN (ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS (SELF)
  (ALL-DIRECT-SUPERCOLLECTIONS SELF CL:NIL))

;;; (DEFUN (ALL-DIRECT-SUBCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-SUBCOLLECTIONS (SELF PERFORMFILTERING?)
  (CL:WHEN (ISA? SELF SGT-SPECIALIZE-LOGIC-DESCRIPTION)
   (DERIVE-DEFERRED-SATELLITE-RULES SELF))
  (CL:LET*
   ((DIRECTLYLINKEDOBJECTS
     (ALL-DIRECTLY-LINKED-OBJECTS SELF
      SGT-SPECIALIZE-PL-KERNEL-KB-SUBSET-OF
      (CL:NOT *REVERSEPOLARITY?*))))
   (CL:WHEN (CL:NOT PERFORMFILTERING?)
    (CL:RETURN-FROM ALL-DIRECT-SUBCOLLECTIONS DIRECTLYLINKEDOBJECTS))
   (CL:LET*
    ((DIRECTSUBS NIL)
     (EQUIVALENTS (ALL-EQUIVALENT-COLLECTIONS SELF CL:T)))
    (CL:IF (CL:NOT (CL:EQ (%%REST EQUIVALENTS) NIL))
     (CL:LET* ((E NULL) (ITER-000 EQUIVALENTS))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ E (%%VALUE ITER-000))
       (CL:LET*
        ((CHILD NULL) (ITER-001 (ALL-DIRECT-SUBCOLLECTIONS E CL:NIL)))
        (CL:LOOP WHILE (NEXT? ITER-001) DO
         (CL:SETQ CHILD (%ITERATOR.VALUE ITER-001))
         (CL:WHEN
          (CL:AND (CL:NOT (MEMBER? EQUIVALENTS CHILD))
           (CL:NOT (MEMBER? DIRECTSUBS CHILD)))
          (CL:SETQ DIRECTSUBS (CONS CHILD DIRECTSUBS)))))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:SETQ DIRECTSUBS (CONSIFY DIRECTLYLINKEDOBJECTS)))
    (ALLOCATE-ITERATOR (MOST-GENERAL-COLLECTIONS DIRECTSUBS)))))

;;; (DEFUN (ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS (SELF)
  (ALL-DIRECT-SUBCOLLECTIONS SELF CL:NIL))

;;; (DEFUN (ALL-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-SUPERCOLLECTIONS (SELF)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
    (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE.SURROGATE-VALUE
      SGT-SPECIALIZE-LOGIC-F-ALL-SUPERCOLLECTIONS-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-SPECIALIZE-LOGIC-F-ALL-SUPERCOLLECTIONS-MEMO-TABLE-000
      "(:MAX-VALUES 1000 :TIMESTAMPS (:META-KB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE.SURROGATE-VALUE
       SGT-SPECIALIZE-LOGIC-F-ALL-SUPERCOLLECTIONS-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF *CONTEXT*
      (CL:IF *REVERSEPOLARITY?* TRUE-WRAPPER FALSE-WRAPPER)
      MEMOIZED-NULL-VALUE -1))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (NEW-MEMOIZABLE-ITERATOR
       (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR SELF
        (CL:FUNCTION ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS)
        NULL)))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 (CLONE-MEMOIZED-ITERATOR MEMOIZED-VALUE-000)))
    VALUE-000)))

;;; (DEFUN (ALL-SUBCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-SUBCOLLECTIONS (SELF)
  (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR SELF
   (CL:FUNCTION ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS) NULL))

;;; (DEFUN (ALL-ISA-COLLECTIONS (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-ISA-COLLECTIONS (SELF)
  (CL:LET* ((COLLECTIONS NIL))
   (CL:LET*
    ((P NULL)
     (ITER-000 (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF NULL CL:NIL)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ P (%ITERATOR.VALUE ITER-000))
     (CL:WHEN (CL:EQ (%PROPOSITION.KIND P) KWD-SPECIALIZE-ISA)
      (CL:SETQ COLLECTIONS
       (CONS (GET-DESCRIPTION (%PROPOSITION.OPERATOR P))
        COLLECTIONS)))))
   (CL:LET*
    ((P NULL)
     (ITER-001
      (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF
       SGT-SPECIALIZE-PL-KERNEL-KB-MEMBER-OF CL:NIL)))
    (CL:LOOP WHILE (NEXT? ITER-001) DO
     (CL:SETQ P (%ITERATOR.VALUE ITER-001))
     (CL:SETQ COLLECTIONS
      (CONS
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS P)))
        1)
       COLLECTIONS))))
   COLLECTIONS))

;;; (DEFUN (ALL-SUPPORTED-NAMED-SUBCOLLECTIONS (CONS OF CONS)) ...)

(CL:DEFUN ALL-SUPPORTED-NAMED-SUBCOLLECTIONS (SELF)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
    (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE.SURROGATE-VALUE
      SGT-SPECIALIZE-LOGIC-F-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-SPECIALIZE-LOGIC-F-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS-MEMO-TABLE-000
      "(:MAX-VALUES 1000 :TIMESTAMPS (:META-KB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE.SURROGATE-VALUE
       SGT-SPECIALIZE-LOGIC-F-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF
      (CL:IF (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*) TRUE-WRAPPER
       FALSE-WRAPPER)
      *CONTEXT* (CL:IF *REVERSEPOLARITY?* TRUE-WRAPPER FALSE-WRAPPER)
      -1))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (HELP-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS SELF))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000)) VALUE-000)))

;;; (DEFUN (ALL-DIRECTLY-LINKED-SUBCOLLECTIONS TRUE-PROPOSITIONS-ITERATOR) ...)

(CL:DEFUN ALL-DIRECTLY-LINKED-SUBCOLLECTIONS (SELF)
  (CL:LET* ((OBJECT NULL) (TRUTHVALUE NULL) (ITERATOR NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SGT-SPECIALIZE-STELLA-CONS)
      (CL:PROGN (CL:SETQ OBJECT (%%VALUE SELF))
       (CL:SETQ TRUTHVALUE (%%VALUE (%%REST SELF)))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT)
      (CL:PROGN (CL:SETQ OBJECT SELF)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:WHEN (ISA? OBJECT SGT-SPECIALIZE-LOGIC-DESCRIPTION)
    (DERIVE-DEFERRED-SATELLITE-RULES OBJECT))
   (CL:SETQ ITERATOR
    (ALL-DIRECTLY-LINKED-OBJECTS OBJECT
     SGT-SPECIALIZE-PL-KERNEL-KB-SUBSET-OF
     (CL:NOT *REVERSEPOLARITY?*)))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ITERATOR)
      SGT-SPECIALIZE-LOGIC-DIRECTLY-LINKED-OBJECTS-ITERATOR)
     (CL:PROGN
      (CL:WHEN (CL:NOT (CL:EQ TRUTHVALUE NULL))
       (CL:SETF
        (%DIRECTLY-LINKED-OBJECTS-ITERATOR.ROOT-TRUTH-VALUE ITERATOR)
        TRUTHVALUE))
      ITERATOR))
    (CL:T NULL))))

;;; (DEFUN (HELP-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS (CONS OF CONS)) ...)

(CL:DEFUN HELP-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS (SELF)
  (CL:LET*
   ((SUBCOLLECTIONS NIL)
    (CLOSUREITERATOR
     (ALLOCATE-SUPPORTED-CLOSURE-ITERATOR
      (CONS SELF (CONS TRUE-TRUTH-VALUE NIL))
      (CL:FUNCTION ALL-DIRECTLY-LINKED-SUBCOLLECTIONS) NULL)))
   (CL:LET* ((SUB NULL) (ITER-000 CLOSUREITERATOR) (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ SUB (%SUPPORTED-CLOSURE-ITERATOR.VALUE ITER-000))
     (CL:WHEN
      (CL:AND
       (ISA? (%%VALUE SUB) SGT-SPECIALIZE-LOGIC-NAMED-DESCRIPTION)
       (CL:NOT (CL:EQ (%%VALUE SUB) SELF)))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS SUB NIL))
        (CL:IF (CL:EQ SUBCOLLECTIONS NIL)
         (CL:SETQ SUBCOLLECTIONS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST SUBCOLLECTIONS COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS SUB NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   SUBCOLLECTIONS))

;;; (DEFUN (VALUE-CLASHES-WITH-SKOLEM? BOOLEAN) ...)

(CL:DEFUN VALUE-CLASHES-WITH-SKOLEM? (SKOLEM VALUE)
  (CL:LET* ((TYPE (%SKOLEM.SKOLEM-TYPE SKOLEM)))
   (CL:COND ((CL:EQ TYPE NULL) CL:NIL)
    ((CL:NOT
      (CL:OR
       (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
        (CL:NOT
         (CL:EQ
          (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
          NULL)))
       (CHECK-STRICT-TYPE? VALUE TYPE CL:T)))
     CL:T)
    ((CL:AND (LITERAL-TYPE? TYPE)
      (LOGICAL-SUBTYPE-OF? TYPE SGT-SPECIALIZE-STELLA-NUMBER))
     (CL:NOT
      (|/PL-KERNEL-KB/SATISFIES-INTERVAL-BOUNDS?| SKOLEM VALUE)))
    (CL:T CL:NIL))))

;;; (DEFUN (CLASHES-WITH-FUNCTION-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN CLASHES-WITH-FUNCTION-PROPOSITION? (NEXTPROPOSITION REFERENCEPROPOSITION)
  (CL:LET* ((ALWAYS?-000 CL:T))
   (CL:LET*
    ((SUPERARG NULL)
     (ITER-000
      (BUT-LAST (%PROPOSITION.ARGUMENTS REFERENCEPROPOSITION)))
     (SUBARG NULL)
     (ITER-001 (BUT-LAST (%PROPOSITION.ARGUMENTS NEXTPROPOSITION))))
    (CL:LOOP WHILE (CL:AND (NEXT? ITER-000) (NEXT? ITER-001)) DO
     (CL:SETQ SUPERARG (%ITERATOR.VALUE ITER-000))
     (CL:SETQ SUBARG (%ITERATOR.VALUE ITER-001))
     (CL:WHEN
      (CL:NOT (EQL? (ARGUMENT-BOUND-TO SUPERARG) (VALUE-OF SUBARG)))
      (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))))
   (CL:WHEN ALWAYS?-000
    (CL:LET*
     ((LASTSUPERVALUE
       (ARGUMENT-BOUND-TO
        (LAST (%PROPOSITION.ARGUMENTS REFERENCEPROPOSITION))))
      (LASTSUBVALUE
       (VALUE-OF (LAST (%PROPOSITION.ARGUMENTS NEXTPROPOSITION)))))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ LASTSUPERVALUE NULL))
       (CL:NOT (CL:EQ LASTSUBVALUE NULL)))
      (CL:IF (ISA? LASTSUBVALUE SGT-SPECIALIZE-LOGIC-SKOLEM)
       (CL:IF (ISA? LASTSUPERVALUE SGT-SPECIALIZE-LOGIC-SKOLEM)
        (CL:RETURN-FROM CLASHES-WITH-FUNCTION-PROPOSITION? CL:NIL)
        (CL:RETURN-FROM CLASHES-WITH-FUNCTION-PROPOSITION?
         (VALUE-CLASHES-WITH-SKOLEM? LASTSUBVALUE LASTSUPERVALUE)))
       (CL:IF (ISA? LASTSUPERVALUE SGT-SPECIALIZE-LOGIC-SKOLEM)
        (CL:RETURN-FROM CLASHES-WITH-FUNCTION-PROPOSITION?
         (VALUE-CLASHES-WITH-SKOLEM? LASTSUPERVALUE LASTSUBVALUE))
        (CL:RETURN-FROM CLASHES-WITH-FUNCTION-PROPOSITION?
         (CL:NOT (EQL? LASTSUPERVALUE LASTSUBVALUE)))))))))
  CL:NIL)

(CL:DEFUN NEW-CLASHING-PROPOSITIONS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-CLASHING-PROPOSITIONS-ITERATOR))
   (CL:SETF (%CLASHING-PROPOSITIONS-ITERATOR.FIRST-ITERATION? SELF)
    CL:T)
   (CL:SETF (%CLASHING-PROPOSITIONS-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%CLASHING-PROPOSITIONS-ITERATOR.EQUIVALENTS-STACK SELF)
    NULL)
   (CL:SETF (%CLASHING-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR SELF)
    NULL)
   (CL:SETF (%CLASHING-PROPOSITIONS-ITERATOR.SELECTION-PATTERN SELF)
    NULL)
   (CL:SETF (%CLASHING-PROPOSITIONS-ITERATOR.TRUTH-VALUE SELF) NULL)
   (CL:SETF
    (%CLASHING-PROPOSITIONS-ITERATOR.REFERENCE-PROPOSITION SELF) NULL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CLASHING-PROPOSITIONS-ITERATOR))
  SGT-SPECIALIZE-LOGIC-CLASHING-PROPOSITIONS-ITERATOR)

(CL:DEFUN ACCESS-CLASHING-PROPOSITIONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-REFERENCE-PROPOSITION)
    (CL:IF SETVALUE?
     (CL:SETF
      (%CLASHING-PROPOSITIONS-ITERATOR.REFERENCE-PROPOSITION SELF)
      VALUE)
     (CL:SETQ VALUE
      (%CLASHING-PROPOSITIONS-ITERATOR.REFERENCE-PROPOSITION SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF CLASHING-PROPOSITIONS-ITERATOR))
  (CL:LET*
   ((REFERENCEPROP
     (%CLASHING-PROPOSITIONS-ITERATOR.REFERENCE-PROPOSITION SELF)))
   (CL:LOOP WHILE (TRUE-PROPOSITIONS-ITERATOR.NEXT? SELF) DO
    (CL:WHEN
     (CLASHES-WITH-FUNCTION-PROPOSITION?
      (%CLASHING-PROPOSITIONS-ITERATOR.VALUE SELF) REFERENCEPROP)
     (CL:RETURN-FROM NEXT? CL:T)))
   (CL:SETF (%CLASHING-PROPOSITIONS-ITERATOR.VALUE SELF) NULL) CL:NIL))

;;; (DEFUN (ALL-CLASHING-PROPOSITIONS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-CLASHING-PROPOSITIONS (SELF)
  (CL:LET*
   ((ARGUMENTS (%PROPOSITION.ARGUMENTS SELF))
    (LASTARG (LAST ARGUMENTS)) (BACKLINKEDARG NULL))
   (LAST-SETTER ARGUMENTS NULL)
   (CL:SETQ BACKLINKEDARG (SELECT-ARGUMENT-WITH-BACKLINKS SELF))
   (LAST-SETTER ARGUMENTS LASTARG)
   (CL:WHEN (CL:EQ BACKLINKEDARG NULL)
    (CL:RETURN-FROM ALL-CLASHING-PROPOSITIONS
     EMPTY-PROPOSITIONS-ITERATOR))
   (CL:LET*
    ((PATTERN
      (CONS KWD-SPECIALIZE-RELATION
       (CONS (CL:IF (CL:EQ NIL NULL) NIL NIL)
        (CONS (%PROPOSITION.OPERATOR SELF)
         (CONS (VALUE-OF BACKLINKEDARG) NIL)))))
     (INDEX (SELECT-PROPOSITIONS PATTERN)))
    (CL:WHEN (EMPTY-PROPOSITIONS-INDEX? INDEX BACKLINKEDARG CL:NIL)
     (CL:RETURN-FROM ALL-CLASHING-PROPOSITIONS
      EMPTY-PROPOSITIONS-ITERATOR))
    (CL:LET* ((SELF-000 (NEW-CLASHING-PROPOSITIONS-ITERATOR)))
     (CL:SETF
      (%CLASHING-PROPOSITIONS-ITERATOR.SELECTION-PATTERN SELF-000)
      PATTERN)
     (CL:SETF
      (%CLASHING-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR SELF-000)
      (ALLOCATE-ITERATOR INDEX))
     (CL:SETF
      (%CLASHING-PROPOSITIONS-ITERATOR.REFERENCE-PROPOSITION SELF-000)
      SELF)
     (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))))

;;; (DEFGLOBAL *IMPLICATION-SUBSUMPTION-GRAPH* ...)

(CL:DEFVAR *IMPLICATION-SUBSUMPTION-GRAPH* NULL)

;;; (DEFUN (RELATIONS-WITH-DESCRIPTIONS (LIST OF RELATION)) ...)

(CL:DEFUN RELATIONS-WITH-DESCRIPTIONS ()
  (CL:LET* ((RESULT (NEW-LIST)))
   (CL:LET*
    ((CLASS NULL) (ITER-000 (ALL-CLASSES NULL CL:NIL))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ CLASS (%ITERATOR.VALUE ITER-000))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
         SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL)
        NULL))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS CLASS NIL))
        (CL:IF (CL:EQ (%LIST.THE-CONS-LIST RESULT) NIL)
         (CL:SETF (%LIST.THE-CONS-LIST RESULT) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST RESULT)
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS CLASS NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:LET*
    ((SLOT NULL) (ITER-001 (ALL-SLOTS NULL CL:NIL)) (COLLECT-001 NULL))
    (CL:LOOP WHILE (NEXT? ITER-001) DO
     (CL:SETQ SLOT (%ITERATOR.VALUE ITER-001))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SLOT)
         SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL)
        NULL))
      (CL:IF (CL:EQ COLLECT-001 NULL)
       (CL:PROGN (CL:SETQ COLLECT-001 (CONS SLOT NIL))
        (CL:IF (CL:EQ (%LIST.THE-CONS-LIST RESULT) NIL)
         (CL:SETF (%LIST.THE-CONS-LIST RESULT) COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST RESULT)
          COLLECT-001)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS SLOT NIL))
        (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))))
   RESULT))

;;; (DEFUN BUILD-SUBSUMPTION-TAXONOMY-GRAPH ...)

(CL:DEFUN BUILD-SUBSUMPTION-TAXONOMY-GRAPH ()
  (CL:LET* ((RELATIONSWITHDESCRIPTIONS (RELATIONS-WITH-DESCRIPTIONS)))
   (CL:LET*
    ((R NULL)
     (ITER-000 (%LIST.THE-CONS-LIST RELATIONSWITHDESCRIPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ R (%%VALUE ITER-000))
     (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
      (DYNAMIC-SLOT-VALUE (%RELATION.DYNAMIC-SLOTS R)
       SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL)
      NULL)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((R NULL)
     (ITER-001 (%LIST.THE-CONS-LIST RELATIONSWITHDESCRIPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ R (%%VALUE ITER-001))
     (CL:LET* ((SUPER NULL) (ITER-002 (DIRECT-SUPERRELATIONS R)))
      (CL:LOOP WHILE (NEXT? ITER-002) DO
       (CL:SETQ SUPER (%ITERATOR.VALUE ITER-002))
       (CL:WHEN (MEMBER? RELATIONSWITHDESCRIPTIONS SUPER)
        (CREATE-TAXONOMY-LINK *IMPLICATION-SUBSUMPTION-GRAPH*
         (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
          (DYNAMIC-SLOT-VALUE (%RELATION.DYNAMIC-SLOTS SUPER)
           SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL))
         (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
          (DYNAMIC-SLOT-VALUE (%RELATION.DYNAMIC-SLOTS R)
           SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL))))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))))

;;; (DEFUN CLEAR-IMPLICATION-SUBSUMPTION-GRAPH ...)

(CL:DEFUN CLEAR-IMPLICATION-SUBSUMPTION-GRAPH ()
  (CL:LET*
   ((R NULL)
    (ITER-000 (%LIST.THE-CONS-LIST (RELATIONS-WITH-DESCRIPTIONS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ R (%%VALUE ITER-000))
    (SET-DYNAMIC-SLOT-VALUE
     (%NAMED-DESCRIPTION.DYNAMIC-SLOTS
      (DYNAMIC-SLOT-VALUE (%RELATION.DYNAMIC-SLOTS R)
       SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL))
     SYM-SPECIALIZE-STELLA-TAXONOMY-NODE NULL NULL)
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH ...)

(CL:DEFUN INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH ()
  (CLEAR-IMPLICATION-SUBSUMPTION-GRAPH)
  (CL:SETQ *IMPLICATION-SUBSUMPTION-GRAPH* (NEW-TAXONOMY-GRAPH))
  (FINALIZE-TAXONOMY-GRAPH *IMPLICATION-SUBSUMPTION-GRAPH*))

;;; (DEFUN (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ...)

(CL:DEFUN FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE (DESCRIPTION)
  (DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
   SYM-SPECIALIZE-STELLA-TAXONOMY-NODE NULL))

;;; (DEFUN (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ...)

(CL:DEFUN CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE (DESCRIPTION PARENTNODE)
  (CL:LET*
   ((NODE
     (CREATE-TAXONOMY-NODE *IMPLICATION-SUBSUMPTION-GRAPH* PARENTNODE
      DESCRIPTION (CL:EQ PARENTNODE NULL))))
   (LINK-TAXONOMY-NODES *IMPLICATION-SUBSUMPTION-GRAPH* PARENTNODE
    NODE)
   (SET-DYNAMIC-SLOT-VALUE (%DESCRIPTION.DYNAMIC-SLOTS DESCRIPTION)
    SYM-SPECIALIZE-STELLA-TAXONOMY-NODE NODE NULL)
   NODE))

;;; (DEFUN (FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ...)

(CL:DEFUN FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE (DESCRIPTION)
  (CL:LET*
   ((RESULT
     (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE DESCRIPTION)))
   (CL:WHEN (CL:NOT (CL:EQ RESULT NULL))
    (CL:RETURN-FROM
     FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE RESULT))
   (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE DESCRIPTION NULL)))

;;; (DEFUN (CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS DESCRIPTION) ...)

(CL:DEFUN CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS (SELF)
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:RETURN-FROM CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS
    NULL))
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION SELF))
    (TAXONOMYNODE
     (FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
      DESCRIPTION)))
   (CL:LET* ((SUPER NULL) (ITER-000 (DIRECT-SUPERRELATIONS SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ SUPER (%ITERATOR.VALUE ITER-000))
     (CL:LET*
      ((SUPERDESCRIPTION
        (CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS SUPER))
       (SUPERTAXONOMYNODE
        (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
         SUPERDESCRIPTION)))
      (CREATE-TAXONOMY-LINK *IMPLICATION-SUBSUMPTION-GRAPH*
       SUPERTAXONOMYNODE TAXONOMYNODE))))
   DESCRIPTION))

;;; (DEFUN ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK ...)

(CL:DEFUN ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK (TAILDESCRIPTION HEADDESCRIPTION)
  NULL)

;;; (DEFUN DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK ...)

(CL:DEFUN DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK (TAILDESCRIPTION HEADDESCRIPTION)
  (CL:PROGN (CL:SETQ HEADDESCRIPTION HEADDESCRIPTION)
   (CL:SETQ TAILDESCRIPTION TAILDESCRIPTION))
  NULL)

;;; (DEFUN (TAXONOMY-IMPLIES-OR-IS-SUBSUMED? BOOLEAN) ...)

(CL:DEFUN TAXONOMY-IMPLIES-OR-IS-SUBSUMED? (PREMISE CONCLUSION)
  (CL:LET*
   ((PREMISEDESCRIPTION
     (DYNAMIC-SLOT-VALUE (%RELATION.DYNAMIC-SLOTS PREMISE)
      SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL))
    (CONCLUSIONDESCRIPTION NULL))
   (CL:WHEN
    (CL:OR (CL:EQ PREMISEDESCRIPTION NULL)
     (CL:EQ
      (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
       PREMISEDESCRIPTION)
      NULL))
    (CL:SETQ PREMISEDESCRIPTION
     (CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS PREMISE)))
   (CL:SETQ CONCLUSIONDESCRIPTION
    (DYNAMIC-SLOT-VALUE (%RELATION.DYNAMIC-SLOTS CONCLUSION)
     SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL))
   (CL:WHEN (CL:EQ CONCLUSIONDESCRIPTION NULL)
    (CL:RETURN-FROM TAXONOMY-IMPLIES-OR-IS-SUBSUMED? CL:NIL))
   (CL:WHEN
    (CL:EQ
     (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
      CONCLUSIONDESCRIPTION)
     NULL)
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "'taxonomy-implies-or-is-subsumed?' conclusionDescription should have taxonomy-node")))
   (TAXONOMY-SUBNODE-OF?
    (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE PREMISEDESCRIPTION)
    (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
     CONCLUSIONDESCRIPTION))))

(CL:DEFUN HELP-STARTUP-SPECIALIZE1 ()
  (CL:PROGN
   (CL:SETQ SGT-SPECIALIZE-LOGIC-ABSTRACT-PROPOSITIONS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT-PROPOSITIONS-ITERATOR"
     NULL 1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-SELECTION-PATTERN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SELECTION-PATTERN" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-PROPOSITION-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION-CURSOR" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-EQUIVALENTS-STACK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENTS-STACK" NULL 0))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-TRUE-PROPOSITIONS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE-PROPOSITIONS-ITERATOR" NULL
     1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 0))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-SPECIALIZING-PROPOSITIONS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "SPECIALIZING-PROPOSITIONS-ITERATOR" NULL 1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-SPECIALIZING-RELATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIALIZING-RELATIONS" NULL 0))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-DESCRIPTION-EXTENSION-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION-EXTENSION-ITERATOR"
     NULL 1))
   (CL:SETQ KWD-SPECIALIZE-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION" NULL 2))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ KWD-SPECIALIZE-DEPENDENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPENDENTS" NULL 2))
   (CL:SETQ KWD-SPECIALIZE-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ KWD-SPECIALIZE-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-F-TEST-PROPERTY?-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-TEST-PROPERTY?-MEMO-TABLE-000"
     NULL 1))
   (CL:SETQ SGT-SPECIALIZE-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-TEST-ISA?-MEMO-TABLE-000" NULL
     1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-001
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-TEST-ISA?-MEMO-TABLE-001" NULL
     1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-F-ACCESS-BINARY-VALUE-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-ACCESS-BINARY-VALUE-MEMO-TABLE-000" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-COLLECTIONOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTIONOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-TRANSITIVE-CLOSURE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSITIVE-CLOSURE-ITERATOR" NULL
     1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "ALLOCATE-ADJACENCY-ITERATOR-FUNCTION" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-FILTER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILTER?" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-ADJACENCY-ITERATOR-STACK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADJACENCY-ITERATOR-STACK" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-BEEN-THERE-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BEEN-THERE-LIST" NULL 0))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-SUPPORTED-CLOSURE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPPORTED-CLOSURE-ITERATOR" NULL
     1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-DIRECTLY-LINKED-OBJECTS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTLY-LINKED-OBJECTS-ITERATOR"
     NULL 1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-INVERSE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INVERSE?" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-ROOT-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-TRUTH-VALUE" NULL 0))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-SUBSET-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-F-ALL-SUPERCOLLECTIONS-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-ALL-SUPERCOLLECTIONS-MEMO-TABLE-000" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ
    SGT-SPECIALIZE-LOGIC-F-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS-MEMO-TABLE-000" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-STELLA-NUMBER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-CLASHING-PROPOSITIONS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASHING-PROPOSITIONS-ITERATOR"
     NULL 1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-REFERENCE-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFERENCE-PROPOSITION" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-STELLA-TAXONOMY-NODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TAXONOMY-NODE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-STARTUP-SPECIALIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-SPECIALIZE" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-SPECIALIZE2 ()
  (CL:PROGN
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "ABSTRACT-PROPOSITIONS-ITERATOR"
       "(DEFCLASS ABSTRACT-PROPOSITIONS-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator class that can generate sets of propositions matching
its `selection-pattern'.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((SELECTION-PATTERN :TYPE SELECTION-PATTERN) (PROPOSITION-CURSOR :TYPE (ITERATOR OF PROPOSITION)) (EQUIVALENTS-STACK :TYPE CONS :INITIALLY NULL)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-ABSTRACT-PROPOSITIONS-ITERATOR))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-ABSTRACT-PROPOSITIONS-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "TRUE-PROPOSITIONS-ITERATOR"
       "(DEFCLASS TRUE-PROPOSITIONS-ITERATOR (ABSTRACT-PROPOSITIONS-ITERATOR) :DOCUMENTATION \"Iterator class that can generate sets of true propositions
matching its `selection-pattern'.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((TRUTH-VALUE :TYPE TRUTH-VALUE :DOCUMENTATION \"Truth-value of the most recently generated proposition (or
projected argument thereof).  This truth value is not necessarily the strictest
and might have involved defaults.\")))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-TRUE-PROPOSITIONS-ITERATOR))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-TRUE-PROPOSITIONS-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "SPECIALIZING-PROPOSITIONS-ITERATOR"
       "(DEFCLASS SPECIALIZING-PROPOSITIONS-ITERATOR (TRUE-PROPOSITIONS-ITERATOR) :DOCUMENTATION \"Iterator class that can generate sets of true propositions
matching its `selection-pattern' or a more specific pattern that substitutes
one of the relations in `specializing-relations'.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((SPECIALIZING-RELATIONS :TYPE (CONS OF CONS) :INITIALLY NULL)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-SPECIALIZING-PROPOSITIONS-ITERATOR))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION
      ACCESS-SPECIALIZING-PROPOSITIONS-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "TRANSITIVE-CLOSURE-ITERATOR"
       "(DEFCLASS TRANSITIVE-CLOSURE-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator that visits all nodes reachable using an
embedded adjacency function.\" :SLOTS ((ALLOCATE-ADJACENCY-ITERATOR-FUNCTION :TYPE FUNCTION-CODE) (FILTER? :TYPE FUNCTION-CODE) (ADJACENCY-ITERATOR-STACK :TYPE (CONS OF ITERATOR) :INITIALLY NIL) (BEEN-THERE-LIST :TYPE CONS)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-TRANSITIVE-CLOSURE-ITERATOR))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-TRANSITIVE-CLOSURE-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "SUPPORTED-CLOSURE-ITERATOR"
       "(DEFCLASS SUPPORTED-CLOSURE-ITERATOR (TRANSITIVE-CLOSURE-ITERATOR) :DOCUMENTATION \"Iterator that visits all objects reachable via true link propositions
generated by an embedded link proposition iterator.  Each new object reached
is represented as an `(<object> <truth-value>)' pair, where <truth-value> is
the cumulative truth value of the links followed from the start to reach it.
The embedded `allocate-adjacency-iterator-function' needs to be able to take
an `(<object> <truth-value>)' pair as an argument which is different than the
requirement for TRANSITIVE-CLOSURE-ITERATOR's.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((ADJACENCY-ITERATOR-STACK :TYPE (CONS OF TRUE-PROPOSITIONS-ITERATOR))))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-SUPPORTED-CLOSURE-ITERATOR))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-SUPPORTED-CLOSURE-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "DIRECTLY-LINKED-OBJECTS-ITERATOR"
       "(DEFCLASS DIRECTLY-LINKED-OBJECTS-ITERATOR (TRUE-PROPOSITIONS-ITERATOR) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((INVERSE? :TYPE BOOLEAN) (ROOT-TRUTH-VALUE :TYPE TRUTH-VALUE :INITIALLY TRUE-TRUTH-VALUE)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-DIRECTLY-LINKED-OBJECTS-ITERATOR))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-DIRECTLY-LINKED-OBJECTS-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "CLASHING-PROPOSITIONS-ITERATOR"
       "(DEFCLASS CLASHING-PROPOSITIONS-ITERATOR (TRUE-PROPOSITIONS-ITERATOR) :PARAMETERS ((ANY-VALUE :TYPE PROPOSITION)) :SLOTS ((REFERENCE-PROPOSITION :TYPE PROPOSITION)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-CLASHING-PROPOSITIONS-ITERATOR))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-CLASHING-PROPOSITIONS-ITERATOR-SLOT-VALUE)))))

(CL:DEFUN HELP-STARTUP-SPECIALIZE3 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "PROPOSITIONS-ITERATOR-TRUTH-VALUE"
    "(DEFUN (PROPOSITIONS-ITERATOR-TRUTH-VALUE TRUTH-VALUE) ((SELF (ITERATOR OF PROPOSITION))))"
    (CL:FUNCTION PROPOSITIONS-ITERATOR-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "NEXT-EQUIVALENT-SELECTION-PATTERN"
    "(DEFUN (NEXT-EQUIVALENT-SELECTION-PATTERN CONS) ((SELF ABSTRACT-PROPOSITIONS-ITERATOR)))"
    (CL:FUNCTION NEXT-EQUIVALENT-SELECTION-PATTERN) NULL)
   (DEFINE-FUNCTION-OBJECT "PROPOSITION-TRUTH-VALUE"
    "(DEFUN (PROPOSITION-TRUTH-VALUE TRUTH-VALUE) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION PROPOSITION-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "TRUE-PROPOSITION?"
    "(DEFUN (TRUE-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (AND (NOT (DELETED? PROPOSITION)) (CHOOSE *REVERSEPOLARITY?* (FALSE? PROPOSITION) (OR (TRUE? PROPOSITION) (FUNCTION-WITH-DEFINED-VALUE? PROPOSITION))))))"
    (CL:FUNCTION TRUE-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRUE-PROPOSITIONS-ITERATOR.NEXT?"
    "(DEFUN (TRUE-PROPOSITIONS-ITERATOR.NEXT? BOOLEAN) ((SELF TRUE-PROPOSITIONS-ITERATOR)) :PUBLIC? TRUE)"
    (CL:FUNCTION TRUE-PROPOSITIONS-ITERATOR.NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF TRUE-PROPOSITIONS-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT?"
    "(DEFUN (SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT? BOOLEAN) ((SELF SPECIALIZING-PROPOSITIONS-ITERATOR)))"
    (CL:FUNCTION SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF SPECIALIZING-PROPOSITIONS-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "EMPTY-PROPOSITIONS-INDEX?"
    "(DEFUN (EMPTY-PROPOSITIONS-INDEX? BOOLEAN) ((INDEX PROPOSITIONS-INDEX) (PRIMARYKEY OBJECT) (SPECIALIZE? BOOLEAN)))"
    (CL:FUNCTION EMPTY-PROPOSITIONS-INDEX?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-TRUE-DEPENDENT-PROPOSITIONS"
    "(DEFUN (ALL-TRUE-DEPENDENT-PROPOSITIONS (ITERATOR OF PROPOSITION)) ((SELF OBJECT) (RELATION SURROGATE) (SPECIALIZE? BOOLEAN)))"
    (CL:FUNCTION ALL-TRUE-DEPENDENT-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS"
    "(DEFUN (ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS (ITERATOR OF PROPOSITION)) ((SELF OBJECT)))"
    (CL:FUNCTION ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ARGUMENTS-UNIFY-WITH-ARGUMENTS?"
    "(DEFUN (ARGUMENTS-UNIFY-WITH-ARGUMENTS? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
    (CL:FUNCTION ARGUMENTS-UNIFY-WITH-ARGUMENTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "ARGUMENTS-EQUAL-ARGUMENTS?"
    "(DEFUN (ARGUMENTS-EQUAL-ARGUMENTS? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
    (CL:FUNCTION ARGUMENTS-EQUAL-ARGUMENTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "ARGUMENTS-MATCH-ARGUMENTS?"
    "(DEFUN (ARGUMENTS-MATCH-ARGUMENTS? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
    (CL:FUNCTION ARGUMENTS-MATCH-ARGUMENTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "PREFIX-ARGUMENTS-EQUAL-ARGUMENTS?"
    "(DEFUN (PREFIX-ARGUMENTS-EQUAL-ARGUMENTS? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
    (CL:FUNCTION PREFIX-ARGUMENTS-EQUAL-ARGUMENTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-MATCHING-PROPOSITIONS"
    "(DEFUN (ALL-MATCHING-PROPOSITIONS (ITERATOR OF PROPOSITION)) ((SELF PROPOSITION)))"
    (CL:FUNCTION ALL-MATCHING-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-PROPOSITIONS-MATCHING-ARGUMENTS"
    "(DEFUN (ALL-PROPOSITIONS-MATCHING-ARGUMENTS (CONS OF PROPOSITION)) ((ARGUMENTS CONS) (RELATION SURROGATE) (SPECIALIZE? BOOLEAN)))"
    (CL:FUNCTION ALL-PROPOSITIONS-MATCHING-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DEFINING-PROPOSITIONS"
    "(DEFUN (ALL-DEFINING-PROPOSITIONS (CONS OF PROPOSITION)) ((OUTPUTARGUMENT OBJECT) (RELATION SURROGATE) (SPECIALIZE? BOOLEAN)))"
    (CL:FUNCTION ALL-DEFINING-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-MEMOIZE-TEST-PROPERTY?"
    "(DEFUN (HELP-MEMOIZE-TEST-PROPERTY? BOOLEAN) ((SELF OBJECT) (RELATION SURROGATE)))"
    (CL:FUNCTION HELP-MEMOIZE-TEST-PROPERTY?) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-PROPERTY?"
    "(DEFUN (TEST-PROPERTY? BOOLEAN) ((SELF OBJECT) (RELATION SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION TEST-PROPERTY?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-MEMOIZE-TEST-ISA?"
    "(DEFUN (HELP-MEMOIZE-TEST-ISA? BOOLEAN) ((MEMBER OBJECT) (TYPE SURROGATE)))"
    (CL:FUNCTION HELP-MEMOIZE-TEST-ISA?) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-ISA?"
    "(DEFUN (TEST-ISA? BOOLEAN) ((MEMBER OBJECT) (TYPE SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION TEST-ISA?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-MEMOIZE-ACCESS-BINARY-VALUE"
    "(DEFUN (HELP-MEMOIZE-ACCESS-BINARY-VALUE OBJECT) ((SELF OBJECT) (RELATION SURROGATE)))"
    (CL:FUNCTION HELP-MEMOIZE-ACCESS-BINARY-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "ACCESS-BINARY-VALUE"
    "(DEFUN (ACCESS-BINARY-VALUE OBJECT) ((SELF OBJECT) (RELATION SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION ACCESS-BINARY-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-COLLECTIONOF-MEMBER-OF?"
    "(DEFUN (TEST-COLLECTIONOF-MEMBER-OF? BOOLEAN) ((MEMBER OBJECT) (TYPE SURROGATE)))"
    (CL:FUNCTION TEST-COLLECTIONOF-MEMBER-OF?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSITIVE-CLOSURE-ITERATOR.NEXT?"
    "(DEFUN (TRANSITIVE-CLOSURE-ITERATOR.NEXT? BOOLEAN) ((SELF TRANSITIVE-CLOSURE-ITERATOR)))"
    (CL:FUNCTION TRANSITIVE-CLOSURE-ITERATOR.NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF TRANSITIVE-CLOSURE-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR"
    "(DEFUN (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR ITERATOR) ((STARTNODE OBJECT) (ALLOCATEADJACENCYITERATOR FUNCTION-CODE) (FILTERFUNCTION FUNCTION-CODE)) :DOCUMENTATION \"Return an iterator that generates the transitive
closure of applying iterators generated by 'allocateAdjacencyIterator'
to 'startNode'.  If 'filterFunction' is non-null, that function is applied
as a filter to each node generated (nodes filtered out still generate
descendants, but they don't get returned).\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "ALLOCATE-SUPPORTED-CLOSURE-ITERATOR"
    "(DEFUN (ALLOCATE-SUPPORTED-CLOSURE-ITERATOR SUPPORTED-CLOSURE-ITERATOR) ((STARTNODE CONS) (ALLOCATEADJACENCYITERATOR FUNCTION-CODE) (FILTERFUNCTION FUNCTION-CODE)) :DOCUMENTATION \"Similar to `allocate-transitive-closure-iterator' (which see),
but return a SUPPORTED-CLOSURE-ITERATOR instead.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALLOCATE-SUPPORTED-CLOSURE-ITERATOR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF SUPPORTED-CLOSURE-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF DIRECTLY-LINKED-OBJECTS-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DIRECTLY-LINKED-OBJECTS"
    "(DEFUN (ALL-DIRECTLY-LINKED-OBJECTS ITERATOR) ((SELF OBJECT) (RELATION SURROGATE) (INVERSE? BOOLEAN)))"
    (CL:FUNCTION ALL-DIRECTLY-LINKED-OBJECTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DIRECT-SUPERCOLLECTIONS"
    "(DEFUN (ALL-DIRECT-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT) (PERFORMFILTERING? BOOLEAN)))"
    (CL:FUNCTION ALL-DIRECT-SUPERCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT
    "ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS"
    "(DEFUN (ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DIRECT-SUBCOLLECTIONS"
    "(DEFUN (ALL-DIRECT-SUBCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT) (PERFORMFILTERING? BOOLEAN)))"
    (CL:FUNCTION ALL-DIRECT-SUBCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS"
    "(DEFUN (ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SUPERCOLLECTIONS"
    "(DEFUN (ALL-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION ALL-SUPERCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SUBCOLLECTIONS"
    "(DEFUN (ALL-SUBCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION ALL-SUBCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-ISA-COLLECTIONS"
    "(DEFUN (ALL-ISA-COLLECTIONS (CONS OF LOGIC-OBJECT)) ((SELF OBJECT)))"
    (CL:FUNCTION ALL-ISA-COLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SUPPORTED-NAMED-SUBCOLLECTIONS"
    "(DEFUN (ALL-SUPPORTED-NAMED-SUBCOLLECTIONS (CONS OF CONS)) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION ALL-SUPPORTED-NAMED-SUBCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DIRECTLY-LINKED-SUBCOLLECTIONS"
    "(DEFUN (ALL-DIRECTLY-LINKED-SUBCOLLECTIONS TRUE-PROPOSITIONS-ITERATOR) ((SELF OBJECT)))"
    (CL:FUNCTION ALL-DIRECTLY-LINKED-SUBCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS"
    "(DEFUN (HELP-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS (CONS OF CONS)) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION HELP-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "VALUE-CLASHES-WITH-SKOLEM?"
    "(DEFUN (VALUE-CLASHES-WITH-SKOLEM? BOOLEAN) ((SKOLEM SKOLEM) (VALUE OBJECT)))"
    (CL:FUNCTION VALUE-CLASHES-WITH-SKOLEM?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASHES-WITH-FUNCTION-PROPOSITION?"
    "(DEFUN (CLASHES-WITH-FUNCTION-PROPOSITION? BOOLEAN) ((NEXTPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
    (CL:FUNCTION CLASHES-WITH-FUNCTION-PROPOSITION?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF CLASHING-PROPOSITIONS-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-CLASHING-PROPOSITIONS"
    "(DEFUN (ALL-CLASHING-PROPOSITIONS (ITERATOR OF PROPOSITION)) ((SELF PROPOSITION)))"
    (CL:FUNCTION ALL-CLASHING-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATIONS-WITH-DESCRIPTIONS"
    "(DEFUN (RELATIONS-WITH-DESCRIPTIONS (LIST OF RELATION)) ())"
    (CL:FUNCTION RELATIONS-WITH-DESCRIPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-SUBSUMPTION-TAXONOMY-GRAPH"
    "(DEFUN BUILD-SUBSUMPTION-TAXONOMY-GRAPH ())"
    (CL:FUNCTION BUILD-SUBSUMPTION-TAXONOMY-GRAPH) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-IMPLICATION-SUBSUMPTION-GRAPH"
    "(DEFUN CLEAR-IMPLICATION-SUBSUMPTION-GRAPH ())"
    (CL:FUNCTION CLEAR-IMPLICATION-SUBSUMPTION-GRAPH) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH"
    "(DEFUN INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH ())"
    (CL:FUNCTION INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH) NULL)
   (DEFINE-FUNCTION-OBJECT
    "FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE"
    "(DEFUN (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ((DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE) NULL)
   (DEFINE-FUNCTION-OBJECT
    "CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE"
    "(DEFUN (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ((DESCRIPTION DESCRIPTION) (PARENTNODE TAXONOMY-NODE)))"
    (CL:FUNCTION CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE) NULL)
   (DEFINE-FUNCTION-OBJECT
    "FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE"
    "(DEFUN (FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ((DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION
     FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE)
    NULL)
   (DEFINE-FUNCTION-OBJECT
    "CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS"
    "(DEFUN (CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS DESCRIPTION) ((SELF RELATION)))"
    (CL:FUNCTION CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS)
    NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK"
    "(DEFUN ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK ((TAILDESCRIPTION DESCRIPTION) (HEADDESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK) NULL)
   (DEFINE-FUNCTION-OBJECT "DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK"
    "(DEFUN DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK ((TAILDESCRIPTION DESCRIPTION) (HEADDESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK) NULL)
   (DEFINE-FUNCTION-OBJECT "TAXONOMY-IMPLIES-OR-IS-SUBSUMED?"
    "(DEFUN (TAXONOMY-IMPLIES-OR-IS-SUBSUMED? BOOLEAN) ((PREMISE RELATION) (CONCLUSION RELATION)))"
    (CL:FUNCTION TAXONOMY-IMPLIES-OR-IS-SUBSUMED?) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-SPECIALIZE"
    "(DEFUN STARTUP-SPECIALIZE () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-SPECIALIZE) NULL)
   (CL:LET*
    ((FUNCTION
      (LOOKUP-FUNCTION SYM-SPECIALIZE-LOGIC-STARTUP-SPECIALIZE)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-SPECIALIZE-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupSpecialize") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-SPECIALIZE ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-SPECIALIZE1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ EMPTY-PROPOSITIONS-ITERATOR
     (NEW-TRUE-PROPOSITIONS-ITERATOR)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5) (HELP-STARTUP-SPECIALIZE2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-SPECIALIZE3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT EMPTY-PROPOSITIONS-ITERATOR (ITERATOR OF PROPOSITION) (NEW TRUE-PROPOSITIONS-ITERATOR) :DOCUMENTATION \"This iterator returns no values whenever its called.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *IMPLICATION-SUBSUMPTION-GRAPH* TAXONOMY-GRAPH NULL)")
    (INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH))))
