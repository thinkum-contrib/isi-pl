;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; units.lisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 2001-2006      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-UNITS-UTILITIES-RATIO NULL)
(CL:DEFVAR SYM-UNITS-UTILITIES-NUMERATOR NULL)
(CL:DEFVAR SYM-UNITS-UTILITIES-DENOMINATOR NULL)
(CL:DEFVAR KWD-UNITS-START NULL)
(CL:DEFVAR SYM-UNITS-STELLA-* NULL)
(CL:DEFVAR KWD-UNITS-INTEGER NULL)
(CL:DEFVAR KWD-UNITS-DELIMITER NULL)
(CL:DEFVAR KWD-UNITS-FRACTION NULL)
(CL:DEFVAR KWD-UNITS-UNIT NULL)
(CL:DEFVAR KWD-UNITS-EOF NULL)
(CL:DEFVAR KWD-UNITS-OTHERWISE NULL)
(CL:DEFVAR KWD-UNITS-ERROR NULL)
(CL:DEFVAR KWD-UNITS-INCLUDE NULL)
(CL:DEFVAR SGT-UNITS-UTILITIES-MEASURE NULL)
(CL:DEFVAR SYM-UNITS-UTILITIES-BASE-UNIT NULL)
(CL:DEFVAR SYM-UNITS-UTILITIES-SCALE NULL)
(CL:DEFVAR SYM-UNITS-UTILITIES-PRIME-ID NULL)
(CL:DEFVAR SYM-UNITS-STELLA-NAME NULL)
(CL:DEFVAR KWD-UNITS-PRESERVE NULL)
(CL:DEFVAR SGT-UNITS-UTILITIES-DIM-NUMBER NULL)
(CL:DEFVAR SYM-UNITS-UTILITIES-PID NULL)
(CL:DEFVAR SYM-UNITS-UTILITIES-MAGNITUDE NULL)
(CL:DEFVAR SYM-UNITS-UTILITIES-PREFERRED-UNITS NULL)
(CL:DEFVAR KWD-UNITS-DIGIT NULL)
(CL:DEFVAR SGT-UNITS-STELLA-TIME-DURATION NULL)
(CL:DEFVAR SYM-UNITS-UTILITIES-SHOW-MEASURE NULL)
(CL:DEFVAR KWD-UNITS-COMMON-LISP NULL)
(CL:DEFVAR KWD-UNITS-FUNCTION NULL)
(CL:DEFVAR SYM-UNITS-UTILITIES-STARTUP-UNITS NULL)
(CL:DEFVAR SYM-UNITS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* STANDARD-OUTPUT EOL
  NULL-CHARACTER *CHARACTER-TYPE-TABLE* NULL-FLOAT NIL NULL-INTEGER))

;;; (DEFGLOBAL *PRIME-NUMBERS* ...)

(CL:DEFVAR *PRIME-NUMBERS* NULL)

;;; (DEFGLOBAL *CURRENT-PRIME-INDEX* ...)

(CL:DEFVAR *CURRENT-PRIME-INDEX* -1)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *CURRENT-PRIME-INDEX*))

;;; (DEFGLOBAL *PRIME-TO-MEASURE-TABLE* ...)

(CL:DEFVAR *PRIME-TO-MEASURE-TABLE* NULL)

;;; (DEFGLOBAL *PRIME-TO-BASE-MEASURE-TABLE* ...)

(CL:DEFVAR *PRIME-TO-BASE-MEASURE-TABLE* NULL)

;;; (DEFGLOBAL *NAME-TO-MEASURE-TABLE* ...)

(CL:DEFVAR *NAME-TO-MEASURE-TABLE* NULL)

;;; (DEFGLOBAL *UNIT-TO-MEASURE-TABLE* ...)

(CL:DEFVAR *UNIT-TO-MEASURE-TABLE* NULL)

;;; (DEFGLOBAL *ALL-MEASURES* ...)

(CL:DEFVAR *ALL-MEASURES* NULL)

;;; (DEFGLOBAL *BASE-MEASURES* ...)

(CL:DEFVAR *BASE-MEASURES* NULL)

;;; (DEFUN (NEXT-PRIME-ID INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION () CL:FIXNUM) NEXT-PRIME-ID))
(CL:DEFUN NEXT-PRIME-ID ()
  (CL:SETQ *CURRENT-PRIME-INDEX* (CL:1+ *CURRENT-PRIME-INDEX*))
  (%WRAPPER-VALUE (NTH *PRIME-NUMBERS* *CURRENT-PRIME-INDEX*)))

;;; (DEFCLASS INCOMPATIBLE-UNITS-EXCEPTION ...)

(CL:DEFINE-CONDITION INCOMPATIBLE-UNITS-EXCEPTION (INCOMPATIBLE-QUANTITY-EXCEPTION)
  ())

(CL:DEFUN NEW-INCOMPATIBLE-UNITS-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE INCOMPATIBLE-UNITS-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   SELF))

;;; (DEFGLOBAL *RATIO-ONE* ...)

(CL:DEFVAR *RATIO-ONE* NULL)

;;; (DEFCLASS RATIO ...)

(CL:DEFCLASS RATIO (QUANTITY)
  ((NUMERATOR :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %NUMERATOR)
   (DENOMINATOR :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %DENOMINATOR)))

(CL:DEFUN NEW-RATIO (NUMERATOR DENOMINATOR)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NUMERATOR DENOMINATOR))
  #+MCL
  (CL:CHECK-TYPE NUMERATOR CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE DENOMINATOR CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE RATIO)))
   (CL:SETF (%NUMERATOR SELF) NUMERATOR)
   (CL:SETF (%DENOMINATOR SELF) DENOMINATOR) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF RATIO))
  SGT-UNITS-UTILITIES-RATIO)

(CL:DEFUN ACCESS-RATIO-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-UNITS-UTILITIES-NUMERATOR)
    (CL:IF SETVALUE? (CL:SETF (%NUMERATOR SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%NUMERATOR SELF)))))
   ((CL:EQ SLOTNAME SYM-UNITS-UTILITIES-DENOMINATOR)
    (CL:IF SETVALUE?
     (CL:SETF (%DENOMINATOR SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%DENOMINATOR SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF RATIO) STREAM)
  (%%PRINT-STREAM STREAM (%NUMERATOR SELF) "/" (%DENOMINATOR SELF)))

;;; (DEFUN (MAKE-RATIO RATIO) ...)

(CL:DEFUN MAKE-RATIO (NUM DENOM)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NUM DENOM))
  #+MCL
  (CL:CHECK-TYPE NUM CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE DENOM CL:FIXNUM)
  (CL:LET* ((THEGCD (GCD NUM DENOM)) (N 0) (D 0) (NEGATIVE? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM THEGCD N D))
   (CL:IF (CL:< NUM 0)
    (CL:PROGN
     (CL:SETQ N
      (CL:TRUNCATE (CL:/ (CL:FLOAT (CL:- 0 NUM) 0.0d0) THEGCD)))
     (CL:SETQ NEGATIVE? CL:T))
    (CL:SETQ N (CL:TRUNCATE (CL:/ (CL:FLOAT NUM 0.0d0) THEGCD))))
   (CL:IF (CL:< DENOM 0)
    (CL:PROGN
     (CL:SETQ D
      (CL:TRUNCATE (CL:/ (CL:FLOAT (CL:- 0 DENOM) 0.0d0) THEGCD)))
     (CL:SETQ NEGATIVE? (CL:NOT NEGATIVE?)))
    (CL:SETQ D (CL:TRUNCATE (CL:/ (CL:FLOAT DENOM 0.0d0) THEGCD))))
   (CL:WHEN NEGATIVE? (CL:SETQ N (CL:- 0 N))) (NEW-RATIO N D)))

;;; (DEFMETHOD (HASH-CODE INTEGER) ...)

(CL:DEFMETHOD HASH-CODE ((SELF RATIO))
  (CL:THE CL:FIXNUM
   (CL:LOGIOR (CL:THE CL:FIXNUM (%NUMERATOR SELF))
    (CL:THE CL:FIXNUM
     (CL:ASH (CL:THE CL:FIXNUM (%DENOMINATOR SELF)) 10)))))

;;; (DEFMETHOD (COERCE-TO RATIO) ...)

(CL:DEFMETHOD COERCE-TO ((X RATIO) Y)
  "Coerces `y' to be a compatible type with `x'.
If this isn't possible, an exception is thrown.  The exception
will be either INCOMPATIBLE-QUANTITY-EXCEPTION or 
INCOMPATIBLE-UNITS-EXCEPTION."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE Y)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-UNITS-UTILITIES-RATIO)
     (CL:PROGN Y))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN (MAKE-RATIO (%WRAPPER-VALUE Y) 1)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Can't convert `" Y
       "' to a RATIO")
      (CL:ERROR
       (NEW-INCOMPATIBLE-QUANTITY-EXCEPTION
        (THE-STRING-READER STREAM-000))))))))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X RATIO) Y)
  (CL:AND (CL:NOT (CL:EQ Y NULL))
   (CL:EQ (PRIMARY-TYPE Y) SGT-UNITS-UTILITIES-RATIO)
   (CL:= (%NUMERATOR X) (%NUMERATOR Y))
   (CL:= (%DENOMINATOR X) (%DENOMINATOR Y))))

;;; (DEFMETHOD (LESS? BOOLEAN) ...)

(CL:DEFMETHOD LESS? ((X RATIO) Y)
  "Computes `x' < `y'"
  (CL:LET* ((Y-RATIO (COERCE-TO X Y)))
   (< (CL:* (%NUMERATOR X) (%DENOMINATOR Y-RATIO))
    (CL:* (%NUMERATOR Y-RATIO) (%DENOMINATOR X)))))

;;; (DEFMETHOD (LESS-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD LESS-EQUAL? ((X RATIO) Y)
  "Computes `x' <= `y'"
  (CL:LET* ((Y-RATIO (COERCE-TO X Y)))
   (<= (CL:* (%NUMERATOR X) (%DENOMINATOR Y-RATIO))
    (CL:* (%NUMERATOR Y-RATIO) (%DENOMINATOR X)))))

;;; (DEFMETHOD (GREATER-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD GREATER-EQUAL? ((X RATIO) Y)
  "Computes `x' >= `y'"
  (CL:LET* ((Y-RATIO (COERCE-TO X Y)))
   (>= (CL:* (%NUMERATOR X) (%DENOMINATOR Y-RATIO))
    (CL:* (%NUMERATOR Y-RATIO) (%DENOMINATOR X)))))

;;; (DEFMETHOD (GREATER? BOOLEAN) ...)

(CL:DEFMETHOD GREATER? ((X RATIO) Y)
  "Computes `x' > `y'"
  (CL:LET* ((Y-RATIO (COERCE-TO X Y)))
   (> (CL:* (%NUMERATOR X) (%DENOMINATOR Y-RATIO))
    (CL:* (%NUMERATOR Y-RATIO) (%DENOMINATOR X)))))

;;; (DEFMETHOD (ADD RATIO) ...)

(CL:DEFMETHOD ADD ((X RATIO) Y)
  (MAKE-RATIO
   (CL:+ (CL:* (%NUMERATOR X) (%DENOMINATOR Y))
    (CL:* (%NUMERATOR Y) (%DENOMINATOR X)))
   (CL:* (%DENOMINATOR X) (%DENOMINATOR Y))))

;;; (DEFMETHOD (SUBTRACT RATIO) ...)

(CL:DEFMETHOD SUBTRACT ((X RATIO) Y)
  (MAKE-RATIO
   (CL:- (CL:* (%NUMERATOR X) (%DENOMINATOR Y))
    (CL:* (%NUMERATOR Y) (%DENOMINATOR X)))
   (CL:* (%DENOMINATOR X) (%DENOMINATOR Y))))

;;; (DEFMETHOD (MULTIPLY RATIO) ...)

(CL:DEFMETHOD MULTIPLY ((X RATIO) Y)
  (MAKE-RATIO (CL:* (%NUMERATOR X) (%NUMERATOR Y))
   (CL:* (%DENOMINATOR X) (%DENOMINATOR Y))))

;;; (DEFMETHOD (DIVIDE RATIO) ...)

(CL:DEFMETHOD DIVIDE ((X RATIO) Y)
  (MAKE-RATIO (CL:* (%NUMERATOR X) (%DENOMINATOR Y))
   (CL:* (%DENOMINATOR X) (%NUMERATOR Y))))

;;; (DEFMETHOD (NEGATE RATIO) ...)

(CL:DEFMETHOD NEGATE ((X RATIO))
  (NEW-RATIO (CL:- 0 (%NUMERATOR X)) (%DENOMINATOR X)))

;;; (DEFMETHOD (INVERT RATIO) ...)

(CL:DEFMETHOD INVERT ((X RATIO))
  (NEW-RATIO (%DENOMINATOR X) (%NUMERATOR X)))

;;; (DEFUN (IPOWER INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:FIXNUM CL:FIXNUM) CL:FIXNUM) IPOWER))
(CL:DEFUN IPOWER (X EXP)
  (CL:DECLARE (CL:TYPE CL:FIXNUM X EXP))
  #+MCL
  (CL:CHECK-TYPE X CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE EXP CL:FIXNUM)
  (CL:IF (CL:< EXP 0)
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
     "Illegal negative exponent: `" EXP "'")
    (CL:ERROR
     (NEW-BAD-ARGUMENT-EXCEPTION (THE-STRING-READER STREAM-000))))
   (CL:LET* ((RESULT 1)) (CL:DECLARE (CL:TYPE CL:FIXNUM RESULT))
    (CL:LOOP WHILE (CL:>= (CL:SETQ EXP (CL:1- EXP)) 0) DO
     (CL:SETQ RESULT (CL:* RESULT X)))
    RESULT)))

;;; (DEFMETHOD (EXPONENTIATE RATIO) ...)

(CL:DEFMETHOD EXPONENTIATE ((X RATIO) Y)
  (CL:DECLARE (CL:TYPE CL:FIXNUM Y))
  #+MCL
  (CL:CHECK-TYPE Y CL:FIXNUM)
  (CL:IF (CL:< Y 0)
   (NEW-RATIO (IPOWER (%DENOMINATOR X) (CL:- 0 Y))
    (IPOWER (%NUMERATOR X) (CL:- 0 Y)))
   (NEW-RATIO (IPOWER (%NUMERATOR X) Y) (IPOWER (%DENOMINATOR X) Y))))

;;; (DEFGLOBAL *UNIT-TOKENIZER-TABLE-DEFINITION* ...)

(CL:DEFVAR *UNIT-TOKENIZER-TABLE-DEFINITION* NULL)

;;; (DEFGLOBAL *UNIT-TOKENIZER-TABLE* ...)

(CL:DEFVAR *UNIT-TOKENIZER-TABLE* NULL)

;;; (DEFCLASS MEASURE ...)

(CL:DEFCLASS MEASURE (STANDARD-OBJECT)
  ((BASE-UNIT :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %BASE-UNIT)
   (SCALE :ALLOCATION :INSTANCE :ACCESSOR %SCALE)
   (PRIME-ID :ALLOCATION :INSTANCE :ACCESSOR %PRIME-ID)
   (NAME :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %NAME)))

(CL:DEFUN NEW-MEASURE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE MEASURE)))
   (CL:SETF (%NAME SELF) STELLA::NULL-STRING)
   (CL:SETF (%PRIME-ID SELF) NULL)
   (CL:SETF (%SCALE SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%BASE-UNIT SELF) STELLA::NULL-STRING) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF MEASURE))
  SGT-UNITS-UTILITIES-MEASURE)

(CL:DEFUN ACCESS-MEASURE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-UNITS-UTILITIES-BASE-UNIT)
    (CL:IF SETVALUE? (CL:SETF (%BASE-UNIT SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%BASE-UNIT SELF)))))
   ((CL:EQ SLOTNAME SYM-UNITS-UTILITIES-SCALE)
    (CL:IF SETVALUE? (CL:SETF (%SCALE SELF) VALUE)
     (CL:SETQ VALUE (%SCALE SELF))))
   ((CL:EQ SLOTNAME SYM-UNITS-UTILITIES-PRIME-ID)
    (CL:IF SETVALUE? (CL:SETF (%PRIME-ID SELF) VALUE)
     (CL:SETQ VALUE (%PRIME-ID SELF))))
   ((CL:EQ SLOTNAME SYM-UNITS-STELLA-NAME)
    (CL:IF SETVALUE? (CL:SETF (%NAME SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%NAME SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF MEASURE) STREAM)
  (%%PRINT-STREAM STREAM "<Measure " (%NAME SELF) "(" (%BASE-UNIT SELF)
   ")>"))

;;; (DEFUN RESET-MEASURES ...)

(CL:DEFUN RESET-MEASURES ()
  (CL:SETQ *CURRENT-PRIME-INDEX* -1)
  (CL:SETQ *PRIME-TO-MEASURE-TABLE* (NEW-STELLA-HASH-TABLE))
  (CL:SETQ *PRIME-TO-BASE-MEASURE-TABLE* (NEW-INTEGER-HASH-TABLE))
  (CL:SETQ *NAME-TO-MEASURE-TABLE* (NEW-STRING-HASH-TABLE))
  (CL:SETQ *UNIT-TO-MEASURE-TABLE* (NEW-STRING-HASH-TABLE))
  (CL:SETQ *ALL-MEASURES* NIL)
  (CL:SETQ *BASE-MEASURES* NIL))

;;; (DEFMETHOD SETUP-INDICES ...)

(CL:DEFMETHOD SETUP-INDICES ((M MEASURE))
  (CL:SETQ *ALL-MEASURES*
   (CL:IF (MEMBER? *ALL-MEASURES* M) *ALL-MEASURES*
    (CONS M *ALL-MEASURES*)))
  (INSERT-AT *PRIME-TO-MEASURE-TABLE* (%PRIME-ID M) M)
  (INSERT-AT *NAME-TO-MEASURE-TABLE* (%NAME M) M)
  (INSERT-AT *UNIT-TO-MEASURE-TABLE* (%BASE-UNIT M) M))

;;; (DEFMETHOD (BASE-MEASURE? BOOLEAN) ...)

(CL:DEFMETHOD BASE-MEASURE? ((M MEASURE))
  "Returns `true' if `m' is a base measure."
  (MEMBER? *BASE-MEASURES* M))

;;; (DEFUN (DEFINE-BASE-MEASURE MEASURE) ...)

(CL:DEFUN DEFINE-BASE-MEASURE (MEASURE-NAME MEASURE-BASE-UNIT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MEASURE-NAME MEASURE-BASE-UNIT))
  #+MCL
  (CL:CHECK-TYPE MEASURE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MEASURE-BASE-UNIT CL:SIMPLE-STRING)
  (CL:LET* ((PRIME (NEXT-PRIME-ID)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM PRIME))
   (CL:LET* ((SELF-000 (NEW-MEASURE)))
    (CL:SETF (%NAME SELF-000) MEASURE-NAME)
    (CL:SETF (%BASE-UNIT SELF-000) MEASURE-BASE-UNIT)
    (CL:SETF (%PRIME-ID SELF-000) (MAKE-RATIO PRIME 1))
    (CL:LET* ((M SELF-000))
     (INSERT-AT (%SCALE M) (WRAP-STRING MEASURE-BASE-UNIT)
      (WRAP-FLOAT 1.0d0))
     (INSERT-AT *PRIME-TO-BASE-MEASURE-TABLE* PRIME M)
     (CL:SETQ *BASE-MEASURES*
      (CL:IF (MEMBER? *BASE-MEASURES* M) *BASE-MEASURES*
       (CONS M *BASE-MEASURES*)))
     (SETUP-INDICES M) M))))

;;; (DEFUN (DEFINE-DERIVED-MEASURE MEASURE) ...)

(CL:DEFUN DEFINE-DERIVED-MEASURE (MEASURE-NAME MEASURE-BASE-UNIT DEFINITION)
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING MEASURE-NAME MEASURE-BASE-UNIT DEFINITION))
  #+MCL
  (CL:CHECK-TYPE MEASURE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MEASURE-BASE-UNIT CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE DEFINITION CL:SIMPLE-STRING)
  (CL:LET* ((SCALE-FACTOR NULL-FLOAT) (ID NULL))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCALE-FACTOR))
   (CL:MULTIPLE-VALUE-SETQ (SCALE-FACTOR ID)
    (UNIT-TO-SCALE-FACTOR-AND-ID DEFINITION))
   (CL:LET* ((SELF-000 (NEW-MEASURE)))
    (CL:SETF (%NAME SELF-000) MEASURE-NAME)
    (CL:SETF (%BASE-UNIT SELF-000) MEASURE-BASE-UNIT)
    (CL:SETF (%PRIME-ID SELF-000) ID)
    (CL:LET* ((M SELF-000))
     (INSERT-AT (%SCALE M) (WRAP-STRING MEASURE-BASE-UNIT)
      (WRAP-FLOAT SCALE-FACTOR))
     (SETUP-INDICES M) M))))

;;; (DEFUN (DEFINE-DIMENSIONLESS-MEASURE MEASURE) ...)

(CL:DEFUN DEFINE-DIMENSIONLESS-MEASURE ()
  (CL:LET* ((SELF-000 (NEW-MEASURE)))
   (CL:SETF (%NAME SELF-000) "Dimensionless")
   (CL:SETF (%BASE-UNIT SELF-000) "")
   (CL:SETF (%PRIME-ID SELF-000) *RATIO-ONE*)
   (CL:LET* ((M SELF-000))
    (INSERT-AT (%SCALE M) (WRAP-STRING "") (WRAP-FLOAT 1.0d0))
    (CL:SETQ *BASE-MEASURES*
     (CL:IF (MEMBER? *BASE-MEASURES* M) *BASE-MEASURES*
      (CONS M *BASE-MEASURES*)))
    (SETUP-INDICES M) M)))

;;; (DEFMETHOD ADD-UNIT ...)

(CL:DEFMETHOD ADD-UNIT ((SELF MEASURE) UNIT-NAME SCALE-FACTOR DEFINITION)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING UNIT-NAME DEFINITION)
   (CL:TYPE CL:DOUBLE-FLOAT SCALE-FACTOR))
  #+MCL
  (CL:CHECK-TYPE UNIT-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SCALE-FACTOR CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE DEFINITION CL:SIMPLE-STRING)
  (CL:LET* ((DEFINITION-FACTOR NULL-FLOAT) (ID NULL))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT DEFINITION-FACTOR))
   (CL:MULTIPLE-VALUE-SETQ (DEFINITION-FACTOR ID)
    (UNIT-TO-SCALE-FACTOR-AND-ID DEFINITION))
   (CL:IF (EQL? ID (%PRIME-ID SELF))
    (CL:PROGN
     (INSERT-AT (%SCALE SELF) (WRAP-STRING UNIT-NAME)
      (WRAP-FLOAT (CL:* SCALE-FACTOR DEFINITION-FACTOR)))
     (INSERT-AT *UNIT-TO-MEASURE-TABLE* UNIT-NAME SELF))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Unit `" UNIT-NAME
      "' has a definition `" DEFINITION
      "' that is not compatible with Measure `" (%NAME SELF) "'")
     (CL:ERROR
      (NEW-INCOMPATIBLE-UNITS-EXCEPTION
       (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (LOOKUP-MEASURE MEASURE) ...)

(CL:DEFUN LOOKUP-MEASURE (NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (LOOKUP *NAME-TO-MEASURE-TABLE* NAME))

;;; (DEFMETHOD (GET-UNITS (LIST OF STRING-WRAPPER)) ...)

(CL:DEFMETHOD GET-UNITS ((SELF MEASURE))
  (CL:LET* ((RESULT (NEW-LIST)))
   (CL:LET*
    ((KEY NULL) (UNUSED NULL)
     (ITER-000 (ALLOCATE-ITERATOR (%SCALE SELF))) (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ KEY (%KEY ITER-000))
     (CL:SETQ UNUSED (%VALUE ITER-000)) (CL:SETQ UNUSED UNUSED)
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS KEY NIL))
       (CL:IF (CL:EQ (%THE-CONS-LIST RESULT) NIL)
        (CL:SETF (%THE-CONS-LIST RESULT) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST RESULT)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS KEY NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   RESULT))

;;; (DEFUN (UNIT-TO-SCALE-FACTOR-AND-ID FLOAT RATIO) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:SIMPLE-STRING) (CL:VALUES CL:DOUBLE-FLOAT CL:T))
  UNIT-TO-SCALE-FACTOR-AND-ID))
(CL:DEFUN UNIT-TO-SCALE-FACTOR-AND-ID (DEFINITION)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DEFINITION))
  #+MCL
  (CL:CHECK-TYPE DEFINITION CL:SIMPLE-STRING)
  (CL:LET*
   ((SCALE-FACTOR 1.0d0) (ID *RATIO-ONE*) (FACTOR NULL-FLOAT)
    (PID NULL) (INVERT? CL:NIL) (ONE-UNIT STELLA::NULL-STRING)
    (EXPONENT-VALUE NULL-INTEGER) (M NULL) (SCALED? CL:T))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCALE-FACTOR FACTOR)
    (CL:TYPE CL:SIMPLE-STRING ONE-UNIT)
    (CL:TYPE CL:FIXNUM EXPONENT-VALUE))
   (CL:LET*
    ((TOK_TABLE_ *UNIT-TOKENIZER-TABLE*)
     (TOK_TRANSITIONS_ (%TRANSITIONS TOK_TABLE_))
     (TOK_STATENAMES_ (%THE-ARRAY (%STATE-NAMES TOK_TABLE_)))
     (TOK_TOKENSTART_ -1) (TOK_ENDOFTOKENS?_ CL:NIL)
     (TOK_STREAMSTATE_ NULL)
     (TOK_BUFFER_
      (CL:LET ((STRING DEFINITION))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING)) STRING))
     (TOK_STATE_ 1) (TOK_NEXTSTATE_ TOK_STATE_) (TOK_CURSOR_ 0)
     (TOK_SIZE_ (CL:THE CL:FIXNUM (CL:LENGTH DEFINITION)))
     (TOK_END_ TOK_SIZE_))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TOK_TRANSITIONS_)
     (CL:TYPE CL:SIMPLE-VECTOR TOK_STATENAMES_)
     (CL:TYPE CL:FIXNUM TOK_TOKENSTART_ TOK_STATE_ TOK_NEXTSTATE_
      TOK_CURSOR_ TOK_SIZE_ TOK_END_))
    (CL:PROGN (CL:SETQ TOK_STATENAMES_ TOK_STATENAMES_)
     (CL:SETQ TOK_ENDOFTOKENS?_ TOK_ENDOFTOKENS?_))
    (CL:SETQ TOK_STREAMSTATE_ TOK_STREAMSTATE_)
    (CL:LOOP
     (CL:PROGN (CL:SETQ TOK_TOKENSTART_ -1)
      (CL:LOOP
       (CL:WHEN (CL:= TOK_CURSOR_ TOK_END_)
        (CL:COND
         ((CL:= TOK_NEXTSTATE_ -1) (CL:SETQ TOK_ENDOFTOKENS?_ CL:T))
         ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%THE-ARRAY (%LEGAL-EOF-STATES TOK_TABLE_)))
            TOK_STATE_))
          (CL:SETQ TOK_NEXTSTATE_ -1)
          (CL:WHEN (CL:= TOK_TOKENSTART_ -1)
           (CL:SETQ TOK_ENDOFTOKENS?_ CL:T)))
         (CL:T (CL:SETQ TOK_STATE_ 0) (CL:SETQ TOK_NEXTSTATE_ -1)))
        (CL:RETURN))
       (CL:SETQ TOK_NEXTSTATE_
        (CL:THE CL:FIXNUM
         (CL:CHAR-CODE
          (CL:LET
           ((SELF TOK_TRANSITIONS_)
            (POSITION
             (CL:THE CL:FIXNUM
              (CL:LOGIOR (CL:THE CL:FIXNUM (CL:ASH TOK_STATE_ 8))
               (CL:THE CL:FIXNUM
                (CL:CHAR-CODE
                 (CL:LET ((BUFFER TOK_BUFFER_) (POSITION TOK_CURSOR_))
                  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
                  (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
                   (CL:THE CL:FIXNUM POSITION)))))))))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION))))))
       (CL:COND
        ((CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 128)) 0)
         (CL:SETQ TOK_STATE_ TOK_NEXTSTATE_)
         (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
        ((CL:= TOK_TOKENSTART_ -1)
         (CL:WHEN
          (CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 64)) 0)
          (CL:SETQ TOK_TOKENSTART_ TOK_CURSOR_))
         (CL:SETQ TOK_STATE_
          (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 63)))
         (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
        (CL:T (CL:RETURN)))))
     (CL:WHEN TOK_ENDOFTOKENS?_ (CL:RETURN))
     (CL:LET* ((TEST-VALUE-000 (CL:AREF TOK_STATENAMES_ TOK_STATE_)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 KWD-UNITS-UNIT)
        (CL:SETQ ONE-UNIT
         (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
          TOK_CURSOR_ TOK_SIZE_ CL:NIL))
        (CL:SETQ M (LOOKUP *UNIT-TO-MEASURE-TABLE* ONE-UNIT))
        (CL:WHEN (CL:EQ M NULL)
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
           "Unrecognized unit: `" DEFINITION "'")
          (CL:ERROR
           (NEW-BAD-ARGUMENT-EXCEPTION
            (THE-STRING-READER STREAM-000)))))
        (CL:SETQ FACTOR
         (%WRAPPER-VALUE (LOOKUP (%SCALE M) (WRAP-STRING ONE-UNIT))))
        (CL:SETQ PID (%PRIME-ID M)) (CL:SETQ SCALED? CL:NIL))
       ((CL:EQ TEST-VALUE-000 KWD-UNITS-INTEGER)
        (CL:SETQ EXPONENT-VALUE
         (STRING-TO-INTEGER
          (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
           TOK_CURSOR_ TOK_SIZE_ CL:NIL)))
        (CL:WHEN INVERT?
         (CL:SETQ EXPONENT-VALUE (CL:- 0 EXPONENT-VALUE)))
        (CL:SETQ FACTOR
         (CL:THE CL:DOUBLE-FLOAT
          (CL:EXPT FACTOR
           (CL:THE CL:DOUBLE-FLOAT (CL:FLOAT EXPONENT-VALUE 0.0d0)))))
        (CL:SETQ PID (EXPONENTIATE PID EXPONENT-VALUE))
        (CL:SETQ SCALE-FACTOR (CL:* SCALE-FACTOR FACTOR))
        (CL:SETQ ID (MULTIPLY ID PID)) (CL:SETQ SCALED? CL:T))
       ((CL:EQ TEST-VALUE-000 KWD-UNITS-FRACTION)
        (CL:WHEN (CL:NOT SCALED?)
         (CL:SETQ SCALE-FACTOR (CL:* SCALE-FACTOR FACTOR))
         (CL:SETQ ID (MULTIPLY ID PID)) (CL:SETQ SCALED? CL:T))
        (CL:IF INVERT?
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
           "Multiple / signs in units expression is not allowed: `"
           DEFINITION "'")
          (CL:ERROR
           (NEW-BAD-ARGUMENT-EXCEPTION
            (THE-STRING-READER STREAM-001))))
         (CL:SETQ INVERT? CL:T)))
       ((CL:EQ TEST-VALUE-000 KWD-UNITS-ERROR)
        (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002)
          "Error in units expression:  Not legal syntax: `" DEFINITION
          "'")
         (CL:ERROR
          (NEW-BAD-ARGUMENT-EXCEPTION
           (THE-STRING-READER STREAM-002)))))
       ((CL:EQ TEST-VALUE-000 KWD-UNITS-DELIMITER)
        (CL:IF INVERT?
         (CL:PROGN (CL:SETQ SCALE-FACTOR (CL:/ SCALE-FACTOR FACTOR))
          (CL:SETQ ID (DIVIDE ID PID)))
         (CL:PROGN (CL:SETQ SCALE-FACTOR (CL:* SCALE-FACTOR FACTOR))
          (CL:SETQ ID (MULTIPLY ID PID))))
        (CL:SETQ SCALED? CL:T))
       (CL:T
        (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-003) "`" TEST-VALUE-000
          "' is not a valid case option")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-003)))))))))
   (CL:WHEN (CL:NOT SCALED?)
    (CL:IF INVERT?
     (CL:PROGN (CL:SETQ SCALE-FACTOR (CL:/ SCALE-FACTOR FACTOR))
      (CL:SETQ ID (DIVIDE ID PID)))
     (CL:PROGN (CL:SETQ SCALE-FACTOR (CL:* SCALE-FACTOR FACTOR))
      (CL:SETQ ID (MULTIPLY ID PID)))))
   (CL:VALUES SCALE-FACTOR ID)))

;;; (DEFUN (COMPUTE-MEASURES-FOR-INTEGER (CONS OF MEASURE)) ...)

(CL:DEFUN COMPUTE-MEASURES-FOR-INTEGER (VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM VALUE))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:FIXNUM)
  (CL:LET* ((MEASURES NIL) (P 1)) (CL:DECLARE (CL:TYPE CL:FIXNUM P))
   (CL:LET* ((PRIME NULL) (ITER-000 *PRIME-NUMBERS*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PRIME (%%VALUE ITER-000))
     (CL:SETQ P (%WRAPPER-VALUE PRIME))
     (CL:LOOP WHILE (CL:= (CL:THE CL:FIXNUM (CL:REM VALUE P)) 0) DO
      (CL:SETQ VALUE (CL:TRUNCATE (CL:/ (CL:FLOAT VALUE 0.0d0) P)))
      (CL:SETQ MEASURES
       (CONS (LOOKUP *PRIME-TO-BASE-MEASURE-TABLE* P) MEASURES)))
     (CL:WHEN (CL:< VALUE P) (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (REVERSE MEASURES)))

;;; (DEFUN (COMPUTE-MEASURES-FOR-PRIME-ID (CONS OF MEASURE) (CONS OF MEASURE)) ...)

(CL:DEFUN COMPUTE-MEASURES-FOR-PRIME-ID (PID)
  "Returns two CONSes of Measure objects for the prime ID `pid'"
  (CL:VALUES (COMPUTE-MEASURES-FOR-INTEGER (%NUMERATOR PID))
   (COMPUTE-MEASURES-FOR-INTEGER (%DENOMINATOR PID))))

;;; (DEFUN (COMPUTE-UNITS-FOR-INTEGER STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:FIXNUM CL:T) CL:SIMPLE-STRING)
  COMPUTE-UNITS-FOR-INTEGER))
(CL:DEFUN COMPUTE-UNITS-FOR-INTEGER (VALUE NEGATE-EXPONENT?)
  (CL:DECLARE (CL:TYPE CL:FIXNUM VALUE))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:FIXNUM)
  (CL:LET*
   ((BUFFER (MAKE-RAW-MUTABLE-STRING 128)) (I 0) (P 1) (E 0)
    (PREVIOUS-NO-EXPONENT? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING BUFFER)
    (CL:TYPE CL:FIXNUM I P E))
   (CL:LET* ((PRIME NULL) (ITER-000 *PRIME-NUMBERS*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PRIME (%%VALUE ITER-000)) (CL:SETQ E 0)
     (CL:SETQ P (%WRAPPER-VALUE PRIME))
     (CL:LOOP WHILE (CL:= (CL:THE CL:FIXNUM (CL:REM VALUE P)) 0) DO
      (CL:SETQ VALUE (CL:TRUNCATE (CL:/ (CL:FLOAT VALUE 0.0d0) P)))
      (CL:SETQ E (CL:1+ E)))
     (CL:WHEN (CL:> E 0)
      (CL:WHEN PREVIOUS-NO-EXPONENT?
       (CL:LET ((SELF BUFFER) (CH #\.) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (SETF
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))
         (CL:THE CL:CHARACTER CH)))
       (CL:SETQ I (CL:1+ I)))
      (CL:SETQ I
       (INSERT-STRING
        (%BASE-UNIT (LOOKUP *PRIME-TO-BASE-MEASURE-TABLE* P)) 0
        NULL-INTEGER BUFFER I KWD-UNITS-PRESERVE))
      (CL:COND
       (NEGATE-EXPONENT?
        (CL:SETQ I
         (INSERT-STRING (INTEGER-TO-STRING (CL:- 0 E)) 0 NULL-INTEGER
          BUFFER I KWD-UNITS-PRESERVE))
        (CL:SETQ PREVIOUS-NO-EXPONENT? CL:NIL))
       ((CL:> E 1)
        (CL:SETQ I
         (INSERT-STRING (INTEGER-TO-STRING E) 0 NULL-INTEGER BUFFER I
          KWD-UNITS-PRESERVE))
        (CL:SETQ PREVIOUS-NO-EXPONENT? CL:NIL))
       (CL:T (CL:SETQ PREVIOUS-NO-EXPONENT? CL:T))))
     (CL:WHEN (CL:< VALUE P) (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (SUBSEQUENCE BUFFER 0 I)))

;;; (DEFUN (COMPUTE-UNITS-FOR-PRIME-ID STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  COMPUTE-UNITS-FOR-PRIME-ID))
(CL:DEFUN COMPUTE-UNITS-FOR-PRIME-ID (PID)
  (CL:LET*
   ((NUMERATOR-STRING
     (COMPUTE-UNITS-FOR-INTEGER (%NUMERATOR PID) CL:NIL))
    (DENOMINATOR-STRING
     (COMPUTE-UNITS-FOR-INTEGER (%DENOMINATOR PID) CL:NIL)))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING NUMERATOR-STRING DENOMINATOR-STRING))
   (CL:IF (STRING-EQL? DENOMINATOR-STRING "") NUMERATOR-STRING
    (CONCATENATE NUMERATOR-STRING "/" DENOMINATOR-STRING))))

;;; (DEFCLASS DIM-NUMBER ...)

(CL:DEFCLASS DIM-NUMBER (QUANTITY)
  ((PID :ALLOCATION :INSTANCE :ACCESSOR %PID)
   (MAGNITUDE :TYPE CL:DOUBLE-FLOAT :INITFORM NULL-FLOAT :ALLOCATION
    :INSTANCE :ACCESSOR %MAGNITUDE)
   (PREFERRED-UNITS :TYPE CL:SIMPLE-STRING :INITFORM
    STELLA::NULL-STRING :ALLOCATION :INSTANCE :ACCESSOR
    %PREFERRED-UNITS)))

(CL:DEFUN NEW-DIM-NUMBER (PID MAGNITUDE)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT MAGNITUDE))
  #+MCL
  (CL:CHECK-TYPE MAGNITUDE CL:DOUBLE-FLOAT)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE DIM-NUMBER)))
   (CL:SETF (%PID SELF) PID) (CL:SETF (%MAGNITUDE SELF) MAGNITUDE)
   (CL:SETF (%PREFERRED-UNITS SELF) STELLA::NULL-STRING) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DIM-NUMBER))
  SGT-UNITS-UTILITIES-DIM-NUMBER)

(CL:DEFUN ACCESS-DIM-NUMBER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-UNITS-UTILITIES-PID)
    (CL:IF SETVALUE? (CL:SETF (%PID SELF) VALUE)
     (CL:SETQ VALUE (%PID SELF))))
   ((CL:EQ SLOTNAME SYM-UNITS-UTILITIES-MAGNITUDE)
    (CL:IF SETVALUE? (CL:SETF (%MAGNITUDE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%MAGNITUDE SELF)))))
   ((CL:EQ SLOTNAME SYM-UNITS-UTILITIES-PREFERRED-UNITS)
    (CL:IF SETVALUE?
     (CL:SETF (%PREFERRED-UNITS SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%PREFERRED-UNITS SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF DIM-NUMBER) STREAM)
  (%%PRINT-STREAM STREAM "<" (GET-MAGNITUDE SELF (GET-UNIT SELF))
   (GET-UNIT SELF) ">"))

;;; (DEFUN (MAKE-DIM-NUMBER DIM-NUMBER) ...)

(CL:DEFUN MAKE-DIM-NUMBER (MAGNITUDE UNITS)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT MAGNITUDE)
   (CL:TYPE CL:SIMPLE-STRING UNITS))
  #+MCL
  (CL:CHECK-TYPE MAGNITUDE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE UNITS CL:SIMPLE-STRING)
  (CL:LET* ((SCALE-FACTOR NULL-FLOAT) (ID NULL))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCALE-FACTOR))
   (CL:MULTIPLE-VALUE-SETQ (SCALE-FACTOR ID)
    (UNIT-TO-SCALE-FACTOR-AND-ID UNITS))
   (CL:LET*
    ((SELF-000 (NEW-DIM-NUMBER ID (CL:* MAGNITUDE SCALE-FACTOR))))
    (CL:SETF (%PREFERRED-UNITS SELF-000) UNITS)
    (CL:LET* ((VALUE-000 SELF-000)) VALUE-000))))

;;; (DEFUN (PARSE-DIM-NUMBER DIM-NUMBER) ...)

(CL:DEFUN PARSE-DIM-NUMBER (INPUT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING INPUT))
  #+MCL
  (CL:CHECK-TYPE INPUT CL:SIMPLE-STRING)
  (CL:LET*
   ((CURRENT-CHARACTER NULL-CHARACTER) (LAST-CHARACTER #\ )
    (SIGN-ALLOWED? CL:T) (DECIMAL-SEEN? CL:NIL)
    (LEN (CL:THE CL:FIXNUM (CL:LENGTH INPUT))) (INDEX 0)
    (MAGNITUDE NULL-FLOAT))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LEN INDEX)
    (CL:TYPE CL:DOUBLE-FLOAT MAGNITUDE))
   (CL:LOOP WHILE (CL:< INDEX LEN) DO
    (CL:SETQ CURRENT-CHARACTER
     (CL:LET ((SELF INPUT) (POSITION INDEX))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION))))
    (CL:COND
     ((CL:OR (CL:EQL CURRENT-CHARACTER #\+)
       (CL:EQL CURRENT-CHARACTER #\-))
      (CL:WHEN (CL:NOT SIGN-ALLOWED?)
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
         "Bad number format (sign in bad place): `" INPUT "'")
        (CL:ERROR
         (NEW-BAD-ARGUMENT-EXCEPTION (THE-STRING-READER STREAM-000)))))
      (CL:SETQ SIGN-ALLOWED? CL:NIL))
     ((CL:EQL CURRENT-CHARACTER #\.)
      (CL:WHEN DECIMAL-SEEN?
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
         "Bad number format (too many decimals): `" INPUT "'")
        (CL:ERROR
         (NEW-BAD-ARGUMENT-EXCEPTION (THE-STRING-READER STREAM-001)))))
      (CL:SETQ DECIMAL-SEEN? CL:T) (CL:SETQ SIGN-ALLOWED? CL:NIL))
     ((CL:EQ
       (CL:AREF *CHARACTER-TYPE-TABLE*
        (CL:THE CL:FIXNUM (CL:CHAR-CODE CURRENT-CHARACTER)))
       KWD-UNITS-DIGIT)
      (CL:SETQ SIGN-ALLOWED? CL:NIL))
     ((CL:OR (CL:EQL CURRENT-CHARACTER #\e)
       (CL:EQL CURRENT-CHARACTER #\E))
      (CL:IF
       (CL:EQ
        (CL:AREF *CHARACTER-TYPE-TABLE*
         (CL:THE CL:FIXNUM (CL:CHAR-CODE LAST-CHARACTER)))
        KWD-UNITS-DIGIT)
       (CL:SETQ SIGN-ALLOWED? CL:T) (CL:RETURN)))
     (CL:T
      (CL:WHEN
       (CL:OR (CL:EQL LAST-CHARACTER #\e) (CL:EQL LAST-CHARACTER #\E))
       (CL:SETQ INDEX (CL:1- INDEX)))
      (CL:RETURN)))
    (CL:SETQ LAST-CHARACTER CURRENT-CHARACTER)
    (CL:SETQ INDEX (CL:1+ INDEX)))
   (CL:HANDLER-CASE
    (CL:SETQ MAGNITUDE (STRING-TO-FLOAT (SUBSEQUENCE INPUT 0 INDEX)))
    (CL:CONDITION ()
     (CL:HANDLER-CASE
      (CL:SETQ MAGNITUDE
       (CL:FLOAT (STRING-TO-INTEGER (SUBSEQUENCE INPUT 0 INDEX))
        0.0d0))
      (CL:CONDITION ()
       (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002)
         "Bad number format: `" INPUT "'")
        (CL:ERROR
         (NEW-BAD-ARGUMENT-EXCEPTION
          (THE-STRING-READER STREAM-002))))))))
   (MAKE-DIM-NUMBER MAGNITUDE (SUBSEQUENCE INPUT INDEX LEN))))

;;; (DEFMETHOD (COERCE-TO DIM-NUMBER) ...)

(CL:DEFMETHOD COERCE-TO ((X DIM-NUMBER) Y)
  "Coerces `y' to be a compatible type with `x'.
If this isn't possible, an exception is thrown.  The exception
will be either INCOMPATIBLE-QUANTITY-EXCEPTION or 
INCOMPATIBLE-UNITS-EXCEPTION."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE Y)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-UNITS-UTILITIES-DIM-NUMBER)
     (CL:PROGN Y))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-UNITS-STELLA-TIME-DURATION)
     (CL:PROGN (TIME-DURATION-TO-DIM Y)))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (MAKE-DIM-NUMBER (CL:FLOAT (%WRAPPER-VALUE Y) 0.0d0) "")))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN (MAKE-DIM-NUMBER (%WRAPPER-VALUE Y) "")))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Can't convert `" Y
       "' to a DIM-NUMBER")
      (CL:ERROR
       (NEW-INCOMPATIBLE-QUANTITY-EXCEPTION
        (THE-STRING-READER STREAM-000))))))))

;;; (DEFMETHOD (GET-MAGNITUDE FLOAT) ...)

(CL:DEFMETHOD GET-MAGNITUDE ((SELF DIM-NUMBER) UNITS)
  "Returns the magnitude of the dim number in the given units."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING UNITS))
  #+MCL
  (CL:CHECK-TYPE UNITS CL:SIMPLE-STRING)
  (CL:LET* ((SCALE-FACTOR NULL-FLOAT) (ID NULL))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCALE-FACTOR))
   (CL:MULTIPLE-VALUE-SETQ (SCALE-FACTOR ID)
    (UNIT-TO-SCALE-FACTOR-AND-ID UNITS))
   (CL:IF (EQL? ID (%PID SELF)) (CL:/ (%MAGNITUDE SELF) SCALE-FACTOR)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Unit `" UNITS
      "' is not compatible with `" (GET-UNIT SELF) "'")
     (CL:ERROR
      (NEW-INCOMPATIBLE-UNITS-EXCEPTION
       (THE-STRING-READER STREAM-000)))))))

;;; (DEFMETHOD (GET-UNIT STRING) ...)

(CL:DEFMETHOD GET-UNIT ((SELF DIM-NUMBER))
  "Returns the units for the dim number.  This will return the
preferred output units if they exist, otherwise the base units. (see `get-base-unit')"
  (CL:LET* ((UNITS (%PREFERRED-UNITS SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING UNITS))
   (CL:IF (CL:NOT (CL:EQ UNITS STELLA::NULL-STRING)) UNITS
    (GET-BASE-UNIT SELF))))

;;; (DEFMETHOD (GET-BASE-UNIT STRING) ...)

(CL:DEFMETHOD GET-BASE-UNIT ((SELF DIM-NUMBER))
  "Returns the base units for the dim number."
  (CL:LET* ((MEASURE (LOOKUP *PRIME-TO-MEASURE-TABLE* (%PID SELF))))
   (CL:IF (CL:NOT (CL:EQ MEASURE NULL)) (%BASE-UNIT MEASURE)
    (COMPUTE-UNITS-FOR-PRIME-ID (%PID SELF)))))

;;; (DEFMETHOD (GET-MEASURE MEASURE) ...)

(CL:DEFMETHOD GET-MEASURE ((SELF DIM-NUMBER))
  "Returns the measure for the dim number, if one is defined."
  (LOOKUP *PRIME-TO-MEASURE-TABLE* (%PID SELF)))

;;; (DEFMETHOD (GET-BASE-MEASURES (CONS OF MEASURE) (CONS OF MEASURE)) ...)

(CL:DEFMETHOD GET-BASE-MEASURES ((SELF DIM-NUMBER))
  "Returns cons of the base measures for the numerator and denominator
of `self'."
  (COMPUTE-MEASURES-FOR-PRIME-ID (%PID SELF)))

;;; (DEFMETHOD (FORMAT-DIM-NUMBER STRING) ...)

(CL:DEFMETHOD FORMAT-DIM-NUMBER ((X DIM-NUMBER) UNITS DECIMALS)
  "Returns a string representation of `x' in `units' with `decimals' digits."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING UNITS)
   (CL:TYPE CL:FIXNUM DECIMALS))
  #+MCL
  (CL:CHECK-TYPE UNITS CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE DECIMALS CL:FIXNUM)
  (CL:WHEN (CL:EQ UNITS STELLA::NULL-STRING)
   (CL:SETQ UNITS (GET-UNIT X)))
  (CL:IF (DEFINED? DECIMALS)
   (CONCATENATE (FORMAT-FLOAT (GET-MAGNITUDE X UNITS) DECIMALS) UNITS)
   (CONCATENATE (FLOAT-TO-STRING (GET-MAGNITUDE X UNITS)) UNITS)))

;;; (DEFUN (COMPATIBLE-UNITS? BOOLEAN) ...)

(CL:DEFUN COMPATIBLE-UNITS? (X Y)
  "Returns TRUE if the units of `x' and `y' are compatible."
  (OBJECT-EQL? (%PID X) (%PID Y)))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X DIM-NUMBER) Y)
  (CL:AND (CL:NOT (CL:EQ Y NULL))
   (CL:EQ (PRIMARY-TYPE Y) SGT-UNITS-UTILITIES-DIM-NUMBER)
   (OBJECT-EQL? (%PID X) (%PID Y)) (CL:= (%MAGNITUDE X) (%MAGNITUDE Y))))

;;; (DEFMETHOD (HASH-CODE INTEGER) ...)

(CL:DEFMETHOD HASH-CODE ((SELF DIM-NUMBER))
  (CL:THE CL:FIXNUM
   (CL:LOGXOR
    (CL:THE CL:FIXNUM
     (CL:SXHASH (CL:THE CL:DOUBLE-FLOAT (%MAGNITUDE SELF))))
    (CL:THE CL:FIXNUM (HASH-CODE (%PID SELF))))))

;;; (DEFMETHOD (SIGNUM INTEGER) ...)

(CL:DEFMETHOD SIGNUM ((X DIM-NUMBER))
  "Computes the signum of `x':  -1 if negative, 0 if zero, 1 if positive"
  (CL:COND ((CL:> (%MAGNITUDE X) 0.0d0) 1)
   ((CL:= (%MAGNITUDE X) 0.0d0) 0) (CL:T -1)))

;;; (DEFMETHOD (ADD DIM-NUMBER) ...)

(CL:DEFMETHOD ADD ((X DIM-NUMBER) Y)
  "Computes `x' + `y'"
  (CL:IF (OBJECT-EQL? (%PID X) (%PID Y))
   (NEW-DIM-NUMBER (%PID X) (CL:+ (%MAGNITUDE X) (%MAGNITUDE Y)))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Can't add `" X
     "' and `" Y "' because of incompatible units")
    (CL:ERROR
     (NEW-INCOMPATIBLE-UNITS-EXCEPTION
      (THE-STRING-READER STREAM-000))))))

;;; (DEFMETHOD (SUBTRACT DIM-NUMBER) ...)

(CL:DEFMETHOD SUBTRACT ((X DIM-NUMBER) Y)
  "Computes `x' - `y'"
  (CL:IF (OBJECT-EQL? (%PID X) (%PID Y))
   (NEW-DIM-NUMBER (%PID X) (CL:- (%MAGNITUDE X) (%MAGNITUDE Y)))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Can't subtract `" Y
     "' from `" X "' because of incompatible units")
    (CL:ERROR
     (NEW-INCOMPATIBLE-UNITS-EXCEPTION
      (THE-STRING-READER STREAM-000))))))

;;; (DEFMETHOD (MULTIPLY DIM-NUMBER) ...)

(CL:DEFMETHOD MULTIPLY ((X DIM-NUMBER) Y)
  "Computes `x' * `y'"
  (NEW-DIM-NUMBER (MULTIPLY (%PID X) (%PID Y))
   (CL:* (%MAGNITUDE X) (%MAGNITUDE Y))))

;;; (DEFMETHOD (DIVIDE DIM-NUMBER) ...)

(CL:DEFMETHOD DIVIDE ((X DIM-NUMBER) Y)
  "Computes `x' / `y'"
  (NEW-DIM-NUMBER (DIVIDE (%PID X) (%PID Y))
   (CL:/ (%MAGNITUDE X) (%MAGNITUDE Y))))

;;; (DEFMETHOD (MODULUS DIM-NUMBER) ...)

(CL:DEFMETHOD MODULUS ((X DIM-NUMBER) Y)
  "Computes the modulus of `x' and `y'.  `x' and `y' must be compatible
units, and the result has the preferred units of `x'."
  (CL:IF (OBJECT-EQL? (%PID X) (%PID Y))
   (CL:LET* ((QUOTIENT (CL:/ (%MAGNITUDE X) (%MAGNITUDE Y))))
    (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT QUOTIENT))
    (CL:LET*
     ((SELF-000
       (NEW-DIM-NUMBER (%PID X)
        (CL:* (CL:- QUOTIENT (FLOOR QUOTIENT)) (%MAGNITUDE Y)))))
     (CL:SETF (%PREFERRED-UNITS SELF-000) (%PREFERRED-UNITS X))
     (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
     "Can't perform modulus on `" X "' and `" Y
     "' because of incompatible units")
    (CL:ERROR
     (NEW-INCOMPATIBLE-UNITS-EXCEPTION
      (THE-STRING-READER STREAM-000))))))

;;; (DEFMETHOD (NEGATE DIM-NUMBER) ...)

(CL:DEFMETHOD NEGATE ((X DIM-NUMBER))
  "Computes - `x'"
  (CL:LET*
   ((SELF-000 (NEW-DIM-NUMBER (%PID X) (CL:- 0 (%MAGNITUDE X)))))
   (CL:SETF (%PREFERRED-UNITS SELF-000) (%PREFERRED-UNITS X))
   (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))

;;; (DEFMETHOD (INVERT DIM-NUMBER) ...)

(CL:DEFMETHOD INVERT ((X DIM-NUMBER))
  "Computes  1 / `x'"
  (NEW-DIM-NUMBER (INVERT (%PID X)) (CL:/ 1 (%MAGNITUDE X))))

;;; (DEFMETHOD (ABSOLUTE-VALUE DIM-NUMBER) ...)

(CL:DEFMETHOD ABSOLUTE-VALUE ((X DIM-NUMBER))
  "Computes  abs(`x')"
  (CL:IF (CL:< (%MAGNITUDE X) 0.0d0) (NEGATE X) X))

;;; (DEFMETHOD (SQUARE-ROOT DIM-NUMBER) ...)

(CL:DEFMETHOD SQUARE-ROOT ((X DIM-NUMBER))
  "Computes the positive square root of x, assuming the units are perfect squares"
  (CL:LET*
   ((NUMERATOR-ROOT
     (CL:THE CL:DOUBLE-FLOAT
      (CL:SQRT
       (CL:THE CL:DOUBLE-FLOAT
        (CL:FLOAT (%NUMERATOR (%PID X)) 0.0d0)))))
    (INTEGER-NUMERATOR-ROOT (FLOOR NUMERATOR-ROOT))
    (DENOMINATOR-ROOT
     (CL:THE CL:DOUBLE-FLOAT
      (CL:SQRT
       (CL:THE CL:DOUBLE-FLOAT
        (CL:FLOAT (%DENOMINATOR (%PID X)) 0.0d0)))))
    (INTEGER-DENOMINATOR-ROOT (FLOOR DENOMINATOR-ROOT)))
   (CL:DECLARE
    (CL:TYPE CL:DOUBLE-FLOAT NUMERATOR-ROOT DENOMINATOR-ROOT)
    (CL:TYPE CL:FIXNUM INTEGER-NUMERATOR-ROOT
     INTEGER-DENOMINATOR-ROOT))
   (CL:IF
    (CL:AND
     (CL:= NUMERATOR-ROOT (CL:FLOAT INTEGER-NUMERATOR-ROOT 0.0d0))
     (CL:= DENOMINATOR-ROOT (CL:FLOAT INTEGER-DENOMINATOR-ROOT 0.0d0)))
    (NEW-DIM-NUMBER
     (MAKE-RATIO INTEGER-NUMERATOR-ROOT INTEGER-DENOMINATOR-ROOT)
     (CL:THE CL:DOUBLE-FLOAT
      (CL:SQRT (CL:THE CL:DOUBLE-FLOAT (%MAGNITUDE X)))))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "Attempt to take square root of `" X
      "'  when the units are not a perfect square")
     (CL:ERROR
      (NEW-BAD-ARGUMENT-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFMETHOD (EXPONENTIATE DIM-NUMBER) ...)

(CL:DEFMETHOD EXPONENTIATE ((X DIM-NUMBER) Y)
  "Computes `x' ^ `y'"
  (CL:DECLARE (CL:TYPE CL:FIXNUM Y))
  #+MCL
  (CL:CHECK-TYPE Y CL:FIXNUM)
  (NEW-DIM-NUMBER (EXPONENTIATE (%PID X) Y)
   (CL:THE CL:DOUBLE-FLOAT
    (CL:EXPT (CL:THE CL:DOUBLE-FLOAT (%MAGNITUDE X))
     (CL:THE CL:DOUBLE-FLOAT (CL:FLOAT Y 0.0d0))))))

;;; (DEFMETHOD (LESS? BOOLEAN) ...)

(CL:DEFMETHOD LESS? ((X DIM-NUMBER) Y)
  "Computes `x' < `y'"
  (CL:LET* ((Y-DIM (COERCE-TO X Y)))
   (CL:IF (OBJECT-EQL? (%PID X) (%PID Y-DIM))
    (< (%MAGNITUDE X) (%MAGNITUDE Y-DIM))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Can't compare `" X
      "' and `" Y-DIM "' because of incompatible units")
     (CL:ERROR
      (NEW-INCOMPATIBLE-UNITS-EXCEPTION
       (THE-STRING-READER STREAM-000)))))))

;;; (DEFMETHOD (LESS-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD LESS-EQUAL? ((X DIM-NUMBER) Y)
  "Computes `x' <= `y'"
  (CL:LET* ((Y-DIM (COERCE-TO X Y)))
   (CL:IF (OBJECT-EQL? (%PID X) (%PID Y-DIM))
    (<= (%MAGNITUDE X) (%MAGNITUDE Y-DIM))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Can't compare `" X
      "' and `" Y-DIM "' because of incompatible units")
     (CL:ERROR
      (NEW-INCOMPATIBLE-UNITS-EXCEPTION
       (THE-STRING-READER STREAM-000)))))))

;;; (DEFMETHOD (GREATER-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD GREATER-EQUAL? ((X DIM-NUMBER) Y)
  "Computes `x' >= `y'"
  (CL:LET* ((Y-DIM (COERCE-TO X Y)))
   (CL:IF (OBJECT-EQL? (%PID X) (%PID Y-DIM))
    (>= (%MAGNITUDE X) (%MAGNITUDE Y-DIM))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Can't compare `" X
      "' and `" Y-DIM "' because of incompatible units")
     (CL:ERROR
      (NEW-INCOMPATIBLE-UNITS-EXCEPTION
       (THE-STRING-READER STREAM-000)))))))

;;; (DEFMETHOD (GREATER? BOOLEAN) ...)

(CL:DEFMETHOD GREATER? ((X DIM-NUMBER) Y)
  "Computes `x' > `y'"
  (CL:LET* ((Y-DIM (COERCE-TO X Y)))
   (CL:IF (OBJECT-EQL? (%PID X) (%PID Y-DIM))
    (> (%MAGNITUDE X) (%MAGNITUDE Y-DIM))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Can't compare `" X
      "' and `" Y-DIM "' because of incompatible units")
     (CL:ERROR
      (NEW-INCOMPATIBLE-UNITS-EXCEPTION
       (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (DIM-TO-TIME-DURATION TIME-DURATION) ...)

(CL:DEFUN DIM-TO-TIME-DURATION (TIME-VALUE)
  "Converts the dimensioned number `time-value' to its
equivalent value as a `time-duration' object.  If `time-value' is not
of the appropriate units, an `incompatible-units-exception' is thrown."
  (CL:LET* ((DAYS (FLOOR (GET-MAGNITUDE TIME-VALUE "days"))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM DAYS))
   (MAKE-TIME-DURATION DAYS
    (FLOOR
     (GET-MAGNITUDE
      (SUBTRACT TIME-VALUE
       (MAKE-DIM-NUMBER (CL:FLOAT DAYS 0.0d0) "days"))
      "ms")))))

;;; (DEFUN (TIME-DURATION-TO-DIM DIM-NUMBER) ...)

(CL:DEFUN TIME-DURATION-TO-DIM (DURATION)
  "Converts the time duration `duration' to its
equivalent value as dimensioned number.  The default time unit
will be used."
  (ADD (MAKE-DIM-NUMBER (CL:FLOAT (%DAYS DURATION) 0.0d0) "days")
   (MAKE-DIM-NUMBER (CL:FLOAT (%MILLIS DURATION) 0.0d0) "ms")))

;;; (DEFUN (DMS-TO-DEGREES DIM-NUMBER) ...)

(CL:DEFUN DMS-TO-DEGREES (L)
  "Converts a (Degree Minute Second) to decimal degrees."
  (CL:LET* ((DEGREES (%%VALUE L)))
   (CL:LET* ((VALUE NULL) (ITER-000 (%%REST L)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ VALUE (%%VALUE ITER-000))
     (CL:SETQ DEGREES (ADD DEGREES VALUE))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   DEGREES))

;;; (DEFUN (DEGREES-TO-DMS (CONS OF DIM-NUMBER)) ...)

(CL:DEFUN DEGREES-TO-DMS (D)
  "Convert decimal degrees to a list of (Degree Minute Second)
where Degree and Minute are integer-valued."
  (CL:LET*
   ((DEGREE-MAGNITUDE (TRUNCATE (GET-MAGNITUDE D "deg")))
    (DEGREE-VALUE
     (MAKE-DIM-NUMBER (CL:FLOAT DEGREE-MAGNITUDE 0.0d0) "deg"))
    (MINUTE-MAGNITUDE
     (TRUNCATE (GET-MAGNITUDE (SUBTRACT D DEGREE-VALUE) "arcmin")))
    (MINUTE-VALUE
     (MAKE-DIM-NUMBER (CL:FLOAT MINUTE-MAGNITUDE 0.0d0) "arcmin"))
    (SECOND-MAGNITUDE
     (TRUNCATE
      (GET-MAGNITUDE (SUBTRACT (SUBTRACT D DEGREE-VALUE) MINUTE-VALUE)
       "arcsec"))))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM DEGREE-MAGNITUDE MINUTE-MAGNITUDE
     SECOND-MAGNITUDE))
   (CONS-LIST DEGREE-VALUE MINUTE-VALUE
    (MAKE-DIM-NUMBER (CL:FLOAT SECOND-MAGNITUDE 0.0d0) "arcsec"))))

;;; (DEFUN (HMS-TO-HOURS DIM-NUMBER) ...)

(CL:DEFUN HMS-TO-HOURS (L)
  "Converts a (Hour Minute Second) to decimal hours"
  (CL:LET* ((HOURS (%%VALUE L)))
   (CL:LET* ((VALUE NULL) (ITER-000 (%%REST L)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ VALUE (%%VALUE ITER-000))
     (CL:SETQ HOURS (ADD HOURS VALUE))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   HOURS))

;;; (DEFUN (HOURS-TO-HMS (CONS OF DIM-NUMBER)) ...)

(CL:DEFUN HOURS-TO-HMS (D)
  "Convert decimal hours to a list of (Hour Minute Second)
where Hour and Minute are integer-valued."
  (CL:LET*
   ((HOUR-MAGNITUDE (TRUNCATE (GET-MAGNITUDE D "hr")))
    (HOUR-VALUE (MAKE-DIM-NUMBER (CL:FLOAT HOUR-MAGNITUDE 0.0d0) "hr"))
    (MINUTE-MAGNITUDE
     (TRUNCATE (GET-MAGNITUDE (SUBTRACT D HOUR-VALUE) "min")))
    (MINUTE-VALUE
     (MAKE-DIM-NUMBER (CL:FLOAT MINUTE-MAGNITUDE 0.0d0) "min"))
    (SECOND-MAGNITUDE
     (TRUNCATE
      (GET-MAGNITUDE (SUBTRACT (SUBTRACT D HOUR-VALUE) MINUTE-VALUE)
       "s"))))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM HOUR-MAGNITUDE MINUTE-MAGNITUDE
     SECOND-MAGNITUDE))
   (CONS-LIST HOUR-VALUE MINUTE-VALUE
    (MAKE-DIM-NUMBER (CL:FLOAT SECOND-MAGNITUDE 0.0d0) "s"))))

;;; (DEFUN SHOW-MEASURES ...)

(CL:DEFUN SHOW-MEASURES ()
  "Print all defined measures."
  (CL:LET* ((M NULL) (ITER-000 *ALL-MEASURES*))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ M (%%VALUE ITER-000))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) (%NAME M)
     "   base-unit=" (%BASE-UNIT M) "   prime-id=" (%PRIME-ID M)
     (CL:IF (BASE-MEASURE? M) "   BASE" "   DERIVED") EOL)
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN SHOW-MEASURE ...)

(CL:DEFUN %SHOW-MEASURE (MEASURE-NAME)
  "Print all units and scale factors for measure `measure-name'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MEASURE-NAME))
  #+MCL
  (CL:CHECK-TYPE MEASURE-NAME CL:SIMPLE-STRING)
  (CL:LET* ((M (LOOKUP *NAME-TO-MEASURE-TABLE* MEASURE-NAME)))
   (CL:IF (CL:NOT (CL:EQ M NULL))
    (CL:LET* ((THE-SCALE (%SCALE M)))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) MEASURE-NAME
      "   base-unit=" (%BASE-UNIT M) "   prime-id=" (%PRIME-ID M)
      (CL:IF (BASE-MEASURE? M) "   BASE" "   DERIVED") EOL)
     (CL:LET* ((U NULL) (ITER-000 (%THE-CONS-LIST (GET-UNITS M))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ U (%%VALUE ITER-000))
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "  "
        (UNWRAP-STRING U) "   factor="
        (UNWRAP-FLOAT (LOOKUP THE-SCALE U)) EOL)
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "No measure with name `" MEASURE-NAME "' found." EOL))))

(CL:DEFUN SHOW-MEASURE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SHOW-MEASURE (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SHOW-MEASURE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Print all units and scale factors for measure `measure-name'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/UTILITIES/SHOW-MEASURE|)) (CL:MACRO-FUNCTION (CL:QUOTE SHOW-MEASURE)))

(CL:DEFUN HELP-STARTUP-UNITS1 ()
  (CL:PROGN
   (CL:SETQ SGT-UNITS-UTILITIES-RATIO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RATIO" NULL 1))
   (CL:SETQ SYM-UNITS-UTILITIES-NUMERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMERATOR" NULL 0))
   (CL:SETQ SYM-UNITS-UTILITIES-DENOMINATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DENOMINATOR" NULL 0))
   (CL:SETQ KWD-UNITS-START
    (INTERN-RIGID-SYMBOL-WRT-MODULE "START" NULL 2))
   (CL:SETQ SYM-UNITS-STELLA-*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-UNITS-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER" NULL 2))
   (CL:SETQ KWD-UNITS-DELIMITER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DELIMITER" NULL 2))
   (CL:SETQ KWD-UNITS-FRACTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FRACTION" NULL 2))
   (CL:SETQ KWD-UNITS-UNIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNIT" NULL 2))
   (CL:SETQ KWD-UNITS-EOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EOF" NULL 2))
   (CL:SETQ KWD-UNITS-OTHERWISE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHERWISE" NULL 2))
   (CL:SETQ KWD-UNITS-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ KWD-UNITS-INCLUDE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INCLUDE" NULL 2))
   (CL:SETQ SGT-UNITS-UTILITIES-MEASURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEASURE" NULL 1))
   (CL:SETQ SYM-UNITS-UTILITIES-BASE-UNIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BASE-UNIT" NULL 0))
   (CL:SETQ SYM-UNITS-UTILITIES-SCALE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCALE" NULL 0))
   (CL:SETQ SYM-UNITS-UTILITIES-PRIME-ID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIME-ID" NULL 0))
   (CL:SETQ SYM-UNITS-STELLA-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-UNITS-PRESERVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRESERVE" NULL 2))
   (CL:SETQ SGT-UNITS-UTILITIES-DIM-NUMBER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIM-NUMBER" NULL 1))
   (CL:SETQ SYM-UNITS-UTILITIES-PID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PID" NULL 0))
   (CL:SETQ SYM-UNITS-UTILITIES-MAGNITUDE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAGNITUDE" NULL 0))
   (CL:SETQ SYM-UNITS-UTILITIES-PREFERRED-UNITS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREFERRED-UNITS" NULL 0))
   (CL:SETQ KWD-UNITS-DIGIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIGIT" NULL 2))
   (CL:SETQ SGT-UNITS-STELLA-TIME-DURATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIME-DURATION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-UNITS-UTILITIES-SHOW-MEASURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHOW-MEASURE" NULL 0))
   (CL:SETQ KWD-UNITS-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-UNITS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-UNITS-UTILITIES-STARTUP-UNITS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-UNITS" NULL 0))
   (CL:SETQ SYM-UNITS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-UNITS2 ()
  (CL:PROGN
   (CL:SETQ *PRIME-NUMBERS*
    (GET-QUOTED-TREE
     "((2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97) \"/UTILITIES\")"
     "/UTILITIES"))
   (CL:SETQ *PRIME-TO-MEASURE-TABLE* (NEW-STELLA-HASH-TABLE))
   (CL:SETQ *PRIME-TO-BASE-MEASURE-TABLE* (NEW-INTEGER-HASH-TABLE))
   (CL:SETQ *NAME-TO-MEASURE-TABLE* (NEW-STRING-HASH-TABLE))
   (CL:SETQ *UNIT-TO-MEASURE-TABLE* (NEW-STRING-HASH-TABLE))
   (CL:SETQ *ALL-MEASURES* NIL) (CL:SETQ *BASE-MEASURES* NIL)
   (CL:SETQ *RATIO-ONE* (NEW-RATIO 1 1))
   (CL:SETQ *UNIT-TOKENIZER-TABLE-DEFINITION*
    (LIST*
     (LIST* KWD-UNITS-START SYM-UNITS-STELLA-*
      (WRAP-STRING "-+0123456789") KWD-UNITS-INTEGER SYM-UNITS-STELLA-*
      (WRAP-STRING ".") KWD-UNITS-DELIMITER SYM-UNITS-STELLA-*
      (WRAP-STRING "/") KWD-UNITS-FRACTION SYM-UNITS-STELLA-*
      (WRAP-STRING
       "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ%")
      KWD-UNITS-UNIT KWD-UNITS-EOF KWD-UNITS-EOF KWD-UNITS-OTHERWISE
      KWD-UNITS-ERROR NIL)
     (LIST* KWD-UNITS-UNIT SYM-UNITS-STELLA-*
      (WRAP-STRING "-+0123456789") KWD-UNITS-INTEGER SYM-UNITS-STELLA-*
      (WRAP-STRING ".") KWD-UNITS-DELIMITER SYM-UNITS-STELLA-*
      (WRAP-STRING "/") KWD-UNITS-FRACTION
      (WRAP-STRING
       "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ%")
      KWD-UNITS-UNIT KWD-UNITS-EOF KWD-UNITS-EOF KWD-UNITS-OTHERWISE
      KWD-UNITS-ERROR NIL)
     (LIST* KWD-UNITS-INTEGER (WRAP-STRING "-+0123456789")
      KWD-UNITS-INTEGER SYM-UNITS-STELLA-* (WRAP-STRING ".")
      KWD-UNITS-DELIMITER SYM-UNITS-STELLA-* (WRAP-STRING "/")
      KWD-UNITS-FRACTION SYM-UNITS-STELLA-*
      (WRAP-STRING
       "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ%")
      KWD-UNITS-UNIT KWD-UNITS-EOF KWD-UNITS-EOF KWD-UNITS-OTHERWISE
      KWD-UNITS-ERROR NIL)
     (LIST* KWD-UNITS-FRACTION KWD-UNITS-INCLUDE KWD-UNITS-START NIL)
     (LIST* KWD-UNITS-DELIMITER KWD-UNITS-INCLUDE KWD-UNITS-START NIL)
     (LIST* KWD-UNITS-ERROR KWD-UNITS-INCLUDE KWD-UNITS-START NIL)
     NIL))))

(CL:DEFUN HELP-STARTUP-UNITS3 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "NEXT-PRIME-ID"
    "(DEFUN (NEXT-PRIME-ID INTEGER) () :PUBLIC? FALSE)"
    (CL:FUNCTION NEXT-PRIME-ID) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-RATIO"
    "(DEFUN (MAKE-RATIO RATIO) ((NUM INTEGER) (DENOM INTEGER)) :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION MAKE-RATIO) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (HASH-CODE INTEGER) ((SELF RATIO)) :PUBLIC? TRUE)"
    (CL:FUNCTION HASH-CODE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COERCE-TO RATIO) ((X RATIO) (Y OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Coerces `y' to be a compatible type with `x'.
If this isn't possible, an exception is thrown.  The exception
will be either INCOMPATIBLE-QUANTITY-EXCEPTION or 
INCOMPATIBLE-UNITS-EXCEPTION.\")" (CL:FUNCTION COERCE-TO) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X RATIO) (Y OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LESS? BOOLEAN) ((X RATIO) (Y OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Computes `x' < `y'\")"
    (CL:FUNCTION LESS?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LESS-EQUAL? BOOLEAN) ((X RATIO) (Y OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Computes `x' <= `y'\")"
    (CL:FUNCTION LESS-EQUAL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GREATER-EQUAL? BOOLEAN) ((X RATIO) (Y OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Computes `x' >= `y'\")"
    (CL:FUNCTION GREATER-EQUAL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GREATER? BOOLEAN) ((X RATIO) (Y OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Computes `x' > `y'\")"
    (CL:FUNCTION GREATER?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ADD RATIO) ((X RATIO) (Y RATIO)) :PUBLIC? TRUE)"
    (CL:FUNCTION ADD) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBTRACT RATIO) ((X RATIO) (Y RATIO)) :PUBLIC? TRUE)"
    (CL:FUNCTION SUBTRACT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MULTIPLY RATIO) ((X RATIO) (Y RATIO)) :PUBLIC? TRUE)"
    (CL:FUNCTION MULTIPLY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DIVIDE RATIO) ((X RATIO) (Y RATIO)) :PUBLIC? TRUE)"
    (CL:FUNCTION DIVIDE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEGATE RATIO) ((X RATIO)) :PUBLIC? TRUE)"
    (CL:FUNCTION NEGATE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (INVERT RATIO) ((X RATIO)) :PUBLIC? TRUE)"
    (CL:FUNCTION INVERT) NULL)
   (DEFINE-FUNCTION-OBJECT "IPOWER"
    "(DEFUN (IPOWER INTEGER) ((X INTEGER) (EXP INTEGER)))"
    (CL:FUNCTION IPOWER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EXPONENTIATE RATIO) ((X RATIO) (Y INTEGER)) :PUBLIC? TRUE)"
    (CL:FUNCTION EXPONENTIATE) NULL)
   (DEFINE-FUNCTION-OBJECT "RESET-MEASURES"
    "(DEFUN RESET-MEASURES () :PUBLIC? TRUE)"
    (CL:FUNCTION RESET-MEASURES) NULL)
   (DEFINE-METHOD-OBJECT "(DEFMETHOD SETUP-INDICES ((M MEASURE)))"
    (CL:FUNCTION SETUP-INDICES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (BASE-MEASURE? BOOLEAN) ((M MEASURE)) :PUBLIC? TRUE :DOCUMENTATION \"Returns `true' if `m' is a base measure.\")"
    (CL:FUNCTION BASE-MEASURE?) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-BASE-MEASURE"
    "(DEFUN (DEFINE-BASE-MEASURE MEASURE) ((MEASURE-NAME STRING) (MEASURE-BASE-UNIT STRING)) :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION DEFINE-BASE-MEASURE) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-DERIVED-MEASURE"
    "(DEFUN (DEFINE-DERIVED-MEASURE MEASURE) ((MEASURE-NAME STRING) (MEASURE-BASE-UNIT STRING) (DEFINITION STRING)) :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION DEFINE-DERIVED-MEASURE) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-DIMENSIONLESS-MEASURE"
    "(DEFUN (DEFINE-DIMENSIONLESS-MEASURE MEASURE) () :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION DEFINE-DIMENSIONLESS-MEASURE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD ADD-UNIT ((SELF MEASURE) (UNIT-NAME STRING) (SCALE-FACTOR FLOAT) (DEFINITION STRING)))"
    (CL:FUNCTION ADD-UNIT) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-MEASURE"
    "(DEFUN (LOOKUP-MEASURE MEASURE) ((NAME STRING)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :CONSTRUCTOR? TRUE (RETURN (LOOKUP *NAME-TO-MEASURE-TABLE* NAME)))"
    (CL:FUNCTION LOOKUP-MEASURE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GET-UNITS (LIST OF STRING-WRAPPER)) ((SELF MEASURE)) :PUBLIC? TRUE)"
    (CL:FUNCTION GET-UNITS) NULL)
   (DEFINE-FUNCTION-OBJECT "UNIT-TO-SCALE-FACTOR-AND-ID"
    "(DEFUN (UNIT-TO-SCALE-FACTOR-AND-ID FLOAT RATIO) ((DEFINITION STRING)))"
    (CL:FUNCTION UNIT-TO-SCALE-FACTOR-AND-ID) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-MEASURES-FOR-INTEGER"
    "(DEFUN (COMPUTE-MEASURES-FOR-INTEGER (CONS OF MEASURE)) ((VALUE INTEGER)))"
    (CL:FUNCTION COMPUTE-MEASURES-FOR-INTEGER) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-MEASURES-FOR-PRIME-ID"
    "(DEFUN (COMPUTE-MEASURES-FOR-PRIME-ID (CONS OF MEASURE) (CONS OF MEASURE)) ((PID RATIO)) :PUBLIC? TRUE :DOCUMENTATION \"Returns two CONSes of Measure objects for the prime ID `pid'\")"
    (CL:FUNCTION COMPUTE-MEASURES-FOR-PRIME-ID) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-UNITS-FOR-INTEGER"
    "(DEFUN (COMPUTE-UNITS-FOR-INTEGER STRING) ((VALUE INTEGER) (NEGATE-EXPONENT? BOOLEAN)))"
    (CL:FUNCTION COMPUTE-UNITS-FOR-INTEGER) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-UNITS-FOR-PRIME-ID"
    "(DEFUN (COMPUTE-UNITS-FOR-PRIME-ID STRING) ((PID RATIO)))"
    (CL:FUNCTION COMPUTE-UNITS-FOR-PRIME-ID) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-DIM-NUMBER"
    "(DEFUN (MAKE-DIM-NUMBER DIM-NUMBER) ((MAGNITUDE FLOAT) (UNITS STRING)) :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION MAKE-DIM-NUMBER) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-DIM-NUMBER"
    "(DEFUN (PARSE-DIM-NUMBER DIM-NUMBER) ((INPUT STRING)) :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION PARSE-DIM-NUMBER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COERCE-TO DIM-NUMBER) ((X DIM-NUMBER) (Y OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Coerces `y' to be a compatible type with `x'.
If this isn't possible, an exception is thrown.  The exception
will be either INCOMPATIBLE-QUANTITY-EXCEPTION or 
INCOMPATIBLE-UNITS-EXCEPTION.\")" (CL:FUNCTION COERCE-TO) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GET-MAGNITUDE FLOAT) ((SELF DIM-NUMBER) (UNITS STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the magnitude of the dim number in the given units.\")"
    (CL:FUNCTION GET-MAGNITUDE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GET-UNIT STRING) ((SELF DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the units for the dim number.  This will return the
preferred output units if they exist, otherwise the base units. (see `get-base-unit')\")"
    (CL:FUNCTION GET-UNIT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GET-BASE-UNIT STRING) ((SELF DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the base units for the dim number.\")"
    (CL:FUNCTION GET-BASE-UNIT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GET-MEASURE MEASURE) ((SELF DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the measure for the dim number, if one is defined.\")"
    (CL:FUNCTION GET-MEASURE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GET-BASE-MEASURES (CONS OF MEASURE) (CONS OF MEASURE)) ((SELF DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Returns cons of the base measures for the numerator and denominator
of `self'.\")" (CL:FUNCTION GET-BASE-MEASURES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FORMAT-DIM-NUMBER STRING) ((X DIM-NUMBER) (UNITS STRING) (DECIMALS INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Returns a string representation of `x' in `units' with `decimals' digits.\")"
    (CL:FUNCTION FORMAT-DIM-NUMBER) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPATIBLE-UNITS?"
    "(DEFUN (COMPATIBLE-UNITS? BOOLEAN) ((X DIM-NUMBER) (Y DIM-NUMBER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Returns TRUE if the units of `x' and `y' are compatible.\" (RETURN (OBJECT-EQL? (PID X) (PID Y))))"
    (CL:FUNCTION COMPATIBLE-UNITS?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X DIM-NUMBER) (Y OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (HASH-CODE INTEGER) ((SELF DIM-NUMBER)) :PUBLIC? TRUE)"
    (CL:FUNCTION HASH-CODE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SIGNUM INTEGER) ((X DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Computes the signum of `x':  -1 if negative, 0 if zero, 1 if positive\")"
    (CL:FUNCTION SIGNUM) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ADD DIM-NUMBER) ((X DIM-NUMBER) (Y DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Computes `x' + `y'\")"
    (CL:FUNCTION ADD) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBTRACT DIM-NUMBER) ((X DIM-NUMBER) (Y DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Computes `x' - `y'\")"
    (CL:FUNCTION SUBTRACT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MULTIPLY DIM-NUMBER) ((X DIM-NUMBER) (Y DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Computes `x' * `y'\")"
    (CL:FUNCTION MULTIPLY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DIVIDE DIM-NUMBER) ((X DIM-NUMBER) (Y DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Computes `x' / `y'\")"
    (CL:FUNCTION DIVIDE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MODULUS DIM-NUMBER) ((X DIM-NUMBER) (Y DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Computes the modulus of `x' and `y'.  `x' and `y' must be compatible
units, and the result has the preferred units of `x'.\")"
    (CL:FUNCTION MODULUS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEGATE DIM-NUMBER) ((X DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Computes - `x'\")"
    (CL:FUNCTION NEGATE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (INVERT DIM-NUMBER) ((X DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Computes  1 / `x'\")"
    (CL:FUNCTION INVERT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ABSOLUTE-VALUE DIM-NUMBER) ((X DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Computes  abs(`x')\")"
    (CL:FUNCTION ABSOLUTE-VALUE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SQUARE-ROOT DIM-NUMBER) ((X DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Computes the positive square root of x, assuming the units are perfect squares\")"
    (CL:FUNCTION SQUARE-ROOT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EXPONENTIATE DIM-NUMBER) ((X DIM-NUMBER) (Y INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Computes `x' ^ `y'\")"
    (CL:FUNCTION EXPONENTIATE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LESS? BOOLEAN) ((X DIM-NUMBER) (Y OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Computes `x' < `y'\")"
    (CL:FUNCTION LESS?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LESS-EQUAL? BOOLEAN) ((X DIM-NUMBER) (Y OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Computes `x' <= `y'\")"
    (CL:FUNCTION LESS-EQUAL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GREATER-EQUAL? BOOLEAN) ((X DIM-NUMBER) (Y OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Computes `x' >= `y'\")"
    (CL:FUNCTION GREATER-EQUAL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GREATER? BOOLEAN) ((X DIM-NUMBER) (Y OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Computes `x' > `y'\")"
    (CL:FUNCTION GREATER?) NULL)
   (DEFINE-FUNCTION-OBJECT "DIM-TO-TIME-DURATION"
    "(DEFUN (DIM-TO-TIME-DURATION TIME-DURATION) ((TIME-VALUE DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Converts the dimensioned number `time-value' to its
equivalent value as a `time-duration' object.  If `time-value' is not
of the appropriate units, an `incompatible-units-exception' is thrown.\")"
    (CL:FUNCTION DIM-TO-TIME-DURATION) NULL)
   (DEFINE-FUNCTION-OBJECT "TIME-DURATION-TO-DIM"
    "(DEFUN (TIME-DURATION-TO-DIM DIM-NUMBER) ((DURATION TIME-DURATION)) :PUBLIC? TRUE :DOCUMENTATION \"Converts the time duration `duration' to its
equivalent value as dimensioned number.  The default time unit
will be used.\")" (CL:FUNCTION TIME-DURATION-TO-DIM) NULL)))

(CL:DEFUN STARTUP-UNITS ()
  (CL:LET*
   ((*MODULE*
     (GET-STELLA-MODULE "/UTILITIES" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-UNITS1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4) (HELP-STARTUP-UNITS2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "INCOMPATIBLE-UNITS-EXCEPTION"
        "(DEFCLASS INCOMPATIBLE-UNITS-EXCEPTION (INCOMPATIBLE-QUANTITY-EXCEPTION) :PUBLIC? TRUE)")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INCOMPATIBLE-UNITS-EXCEPTION)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "RATIO"
        "(DEFCLASS RATIO (QUANTITY) :PUBLIC? TRUE :PUBLIC-SLOTS ((NUMERATOR :TYPE INTEGER :REQUIRED? TRUE) (DENOMINATOR :TYPE INTEGER :REQUIRED? TRUE)) :PRINT-FORM (PRINT-STREAM STREAM (NUMERATOR SELF) \"/\" (DENOMINATOR SELF)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-RATIO))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-RATIO-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "MEASURE"
        "(DEFCLASS MEASURE (STANDARD-OBJECT) :PUBLIC? TRUE :PUBLIC-SLOTS ((BASE-UNIT :TYPE STRING) (SCALE :TYPE (KEY-VALUE-LIST OF STRING-WRAPPER FLOAT-WRAPPER) :INITIALLY (NEW KEY-VALUE-LIST)) (PRIME-ID :TYPE RATIO) (NAME :TYPE STRING)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"<Measure \" (NAME SELF) \"(\" (BASE-UNIT SELF) \")>\"))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-MEASURE))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-MEASURE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "DIM-NUMBER"
        "(DEFCLASS DIM-NUMBER (QUANTITY) :PUBLIC? TRUE :PUBLIC-SLOTS ((PID :TYPE RATIO :REQUIRED? TRUE) (MAGNITUDE :TYPE FLOAT :REQUIRED? TRUE) (PREFERRED-UNITS :TYPE STRING :INITIALLY NULL)) :PRINT-FORM (PRINT-STREAM STREAM \"<\" (GET-MAGNITUDE SELF (GET-UNIT SELF)) (GET-UNIT SELF) \">\"))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-DIM-NUMBER))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-DIM-NUMBER-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-UNITS3)
    (DEFINE-FUNCTION-OBJECT "DMS-TO-DEGREES"
     "(DEFUN (DMS-TO-DEGREES DIM-NUMBER) ((L (CONS OF DIM-NUMBER))) :PUBLIC? TRUE :DOCUMENTATION \"Converts a (Degree Minute Second) to decimal degrees.\")"
     (CL:FUNCTION DMS-TO-DEGREES) NULL)
    (DEFINE-FUNCTION-OBJECT "DEGREES-TO-DMS"
     "(DEFUN (DEGREES-TO-DMS (CONS OF DIM-NUMBER)) ((D DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Convert decimal degrees to a list of (Degree Minute Second)
where Degree and Minute are integer-valued.\")"
     (CL:FUNCTION DEGREES-TO-DMS) NULL)
    (DEFINE-FUNCTION-OBJECT "HMS-TO-HOURS"
     "(DEFUN (HMS-TO-HOURS DIM-NUMBER) ((L (CONS OF DIM-NUMBER))) :PUBLIC? TRUE :DOCUMENTATION \"Converts a (Hour Minute Second) to decimal hours\")"
     (CL:FUNCTION HMS-TO-HOURS) NULL)
    (DEFINE-FUNCTION-OBJECT "HOURS-TO-HMS"
     "(DEFUN (HOURS-TO-HMS (CONS OF DIM-NUMBER)) ((D DIM-NUMBER)) :PUBLIC? TRUE :DOCUMENTATION \"Convert decimal hours to a list of (Hour Minute Second)
where Hour and Minute are integer-valued.\")"
     (CL:FUNCTION HOURS-TO-HMS) NULL)
    (DEFINE-FUNCTION-OBJECT "SHOW-MEASURES"
     "(DEFUN SHOW-MEASURES () :PUBLIC? TRUE :COMMAND? TRUE :DOCUMENTATION \"Print all defined measures.\")"
     (CL:FUNCTION SHOW-MEASURES) NULL)
    (DEFINE-FUNCTION-OBJECT "SHOW-MEASURE"
     "(DEFUN SHOW-MEASURE ((MEASURE-NAME STRING)) :PUBLIC? TRUE :COMMAND? TRUE :DOCUMENTATION \"Print all units and scale factors for measure `measure-name'.\")"
     (CL:FUNCTION %SHOW-MEASURE)
     (CL:FUNCTION SHOW-MEASURE-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "STARTUP-UNITS"
     "(DEFUN STARTUP-UNITS () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-UNITS) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-UNITS-UTILITIES-STARTUP-UNITS)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-UNITS-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupUnits") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PRIME-NUMBERS* (CONS OF INTEGER-WRAPPER) (QUOTE (2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)) :PUBLIC? FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CURRENT-PRIME-INDEX* INTEGER -1 :PUBLIC? FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PRIME-TO-MEASURE-TABLE* (STELLA-HASH-TABLE OF RATIO MEASURE) (NEW STELLA-HASH-TABLE) :PUBLIC? FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PRIME-TO-BASE-MEASURE-TABLE* (INTEGER-HASH-TABLE OF INTEGER MEASURE) (NEW INTEGER-HASH-TABLE) :PUBLIC? FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *NAME-TO-MEASURE-TABLE* (STRING-HASH-TABLE OF STRING MEASURE) (NEW STRING-HASH-TABLE) :PUBLIC? FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *UNIT-TO-MEASURE-TABLE* (STRING-HASH-TABLE OF STRING MEASURE) (NEW STRING-HASH-TABLE) :PUBLIC? FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ALL-MEASURES* (CONS OF MEASURE) NIL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *BASE-MEASURES* (CONS OF MEASURE) NIL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *RATIO-ONE* RATIO (NEW RATIO :NUMERATOR 1 :DENOMINATOR 1) :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *UNIT-TOKENIZER-TABLE-DEFINITION* CONS (BQUOTE ((:START * \"-+0123456789\" :INTEGER * \".\" :DELIMITER * \"/\" :FRACTION * \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ%\" :UNIT :EOF :EOF :OTHERWISE :ERROR) (:UNIT * \"-+0123456789\" :INTEGER * \".\" :DELIMITER * \"/\" :FRACTION \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ%\" :UNIT :EOF :EOF :OTHERWISE :ERROR) (:INTEGER \"-+0123456789\" :INTEGER * \".\" :DELIMITER * \"/\" :FRACTION * \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ%\" :UNIT :EOF :EOF :OTHERWISE :ERROR) (:FRACTION :INCLUDE :START) (:DELIMITER :INCLUDE :START) (:ERROR :INCLUDE :START))))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *UNIT-TOKENIZER-TABLE* TOKENIZER-TABLE NULL)")
    (CL:SETQ *UNIT-TOKENIZER-TABLE*
     (PARSE-TOKENIZER-DEFINITION *UNIT-TOKENIZER-TABLE-DEFINITION*))
    (REGISTER-NATIVE-NAME SYM-UNITS-UTILITIES-SHOW-MEASURE
     KWD-UNITS-COMMON-LISP KWD-UNITS-FUNCTION)
    (RESET-MEASURES) (INITIALIZE-UNIT-DEFINITIONS))))
