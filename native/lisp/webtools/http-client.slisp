;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; http-client.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 2003-2012      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-HTTP-CLIENT-MAC NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-HTTP-HTTP-HEADERS NULL)
(CL:DEFVAR SGT-HTTP-CLIENT-STELLA-FILE-INPUT-STREAM NULL)
(CL:DEFVAR SGT-HTTP-CLIENT-STELLA-INPUT-STREAM NULL)
(CL:DEFVAR KWD-HTTP-CLIENT-POST NULL)
(CL:DEFVAR KWD-HTTP-CLIENT-GET NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-STELLA-LET NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-STELLA-INPUT-STREAM NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-STELLA-NULL NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-STELLA-UNWIND-PROTECT NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-STELLA-PROGN NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-STELLA-SETQ NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-HTTP-OPEN-URL-STREAM NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-STELLA-WHEN NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-STELLA-DEFINED? NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-STELLA-CLOSE-STREAM NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-HTTP-DOWNLOAD-URL NULL)
(CL:DEFVAR KWD-HTTP-CLIENT-COMMON-LISP NULL)
(CL:DEFVAR KWD-HTTP-CLIENT-FUNCTION NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-HTTP-DOWNLOAD-URL-TO-STRING NULL)
(CL:DEFVAR KWD-HTTP-CLIENT-METHOD NULL)
(CL:DEFVAR KWD-HTTP-CLIENT-HEADERS NULL)
(CL:DEFVAR KWD-HTTP-CLIENT-CONTENT NULL)
(CL:DEFVAR SGT-HTTP-CLIENT-HTTP-HTTP-HEADERS NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-HTTP-DO-HTTP-REQUEST NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-HTTP-STARTUP-HTTP-CLIENT NULL)
(CL:DEFVAR SYM-HTTP-CLIENT-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* NIL STANDARD-OUTPUT
  NULL-CHARACTER NULL-INTEGER))

;;; (DEFUN (DECOMPOSE-INTERNET-URL STRING STRING STRING STRING STRING STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:SIMPLE-STRING)
   (CL:VALUES CL:SIMPLE-STRING CL:SIMPLE-STRING CL:SIMPLE-STRING
    CL:SIMPLE-STRING CL:SIMPLE-STRING CL:SIMPLE-STRING
    CL:SIMPLE-STRING))
  DECOMPOSE-INTERNET-URL))
(CL:DEFUN DECOMPOSE-INTERNET-URL (URL)
  "Takes an internet style URL and returns the components of
that URL as specified below.  Missing elements return the empty string \"\".
  PROTOCOL USERNAME:PASSWORD DOMAIN PORT PATH QUERY FRAGMENT

  o Protocol.  The access protocol.

       Those schemes which refer to internet protocols mostly have a
       common syntax for the rest of the object name. This starts with a
       double slash '//' to indicate its presence, and continues until
       the following slash '/':

  o An optional user name, if required (as it is with a few FTP servers).
    The password, if present, follows the user name, separated from it by a colon;
    the user name and optional password are followed by a commercial at sign '@'. 
  o The internet domain name of the host
  o The port number, if it is not the default number for the protocol,
    is given in decimal notation after a colon.
  o Path The path is a hierarchical representation of a particular path. It may 
    define details of how the client should communicate with the server, including
    information to be passed transparently to the server without any processing by
    the client.
    The path is interpreted in a manner dependent on the scheme being used.
    Generally, the reserved slash '/' character (ASCII 2F hex) denotes a level in a
    hierarchical structure, the higher level part to the left of the slash.
  o Query is the part of the hierarchical information following a '?' character.
  o Fragment is the part of the hierarchical information following a '#' character.

References:  http://www.gbiv.com/protocols/uri/rfc/rfc3986.html"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING URL))
  #+MCL
  (CL:CHECK-TYPE URL CL:SIMPLE-STRING)
  (CL:LET*
   ((FIELD-START 0)
    (FIELD-END (STRING-SEARCH URL (MAKE-STRING 1 #\:) 0)) (PROTOCOL "")
    (USER-INFORMATION "") (DOMAIN-NAME "") (PORT-NUMBER "") (PATH "")
    (QUERY "") (FRAGMENT ""))
   (CL:DECLARE (CL:TYPE CL:FIXNUM FIELD-START FIELD-END)
    (CL:TYPE CL:SIMPLE-STRING PROTOCOL USER-INFORMATION DOMAIN-NAME
     PORT-NUMBER PATH QUERY FRAGMENT))
   (CL:WHEN (CL:NOT (CL:= FIELD-END NULL-INTEGER))
    (CL:SETQ PROTOCOL (SUBSEQUENCE URL 0 FIELD-END))
    (CL:IF (CL:= FIELD-END (STRING-SEARCH URL "://" FIELD-END))
     (CL:SETQ FIELD-END (CL:+ FIELD-END 3))
     (CL:SETQ FIELD-END (CL:1+ FIELD-END)))
    (CL:SETQ FIELD-START FIELD-END)
    (CL:SETQ FIELD-END (POSITION URL #\/ FIELD-START))
    (CL:SETQ DOMAIN-NAME (SUBSEQUENCE URL FIELD-START FIELD-END))
    (CL:SETQ FIELD-START FIELD-END))
   (CL:SETQ FIELD-END (POSITION URL #\? FIELD-START))
   (CL:IF (CL:NOT (CL:= FIELD-END NULL-INTEGER))
    (CL:PROGN (CL:SETQ PATH (SUBSEQUENCE URL FIELD-START FIELD-END))
     (CL:SETQ FIELD-START (CL:1+ FIELD-END))
     (CL:SETQ FIELD-END (POSITION URL #\# FIELD-START))
     (CL:IF (CL:NOT (CL:= FIELD-END NULL-INTEGER))
      (CL:PROGN (CL:SETQ QUERY (SUBSEQUENCE URL FIELD-START FIELD-END))
       (CL:SETQ FIELD-START (CL:1+ FIELD-END))
       (CL:SETQ FRAGMENT (SUBSEQUENCE URL FIELD-START NULL-INTEGER)))
      (CL:SETQ QUERY (SUBSEQUENCE URL FIELD-START NULL-INTEGER))))
    (CL:PROGN (CL:SETQ FIELD-END (POSITION URL #\# FIELD-START))
     (CL:IF (CL:NOT (CL:= FIELD-END NULL-INTEGER))
      (CL:PROGN (CL:SETQ PATH (SUBSEQUENCE URL FIELD-START FIELD-END))
       (CL:SETQ FIELD-START (CL:1+ FIELD-END))
       (CL:SETQ FRAGMENT (SUBSEQUENCE URL FIELD-START NULL-INTEGER)))
      (CL:SETQ PATH (SUBSEQUENCE URL FIELD-START NULL-INTEGER)))))
   (CL:SETQ FIELD-END (POSITION DOMAIN-NAME #\@ 0))
   (CL:WHEN (CL:NOT (CL:= FIELD-END NULL-INTEGER))
    (CL:SETQ USER-INFORMATION (SUBSEQUENCE DOMAIN-NAME 0 FIELD-END))
    (CL:SETQ DOMAIN-NAME
     (SUBSEQUENCE DOMAIN-NAME (CL:1+ FIELD-END) NULL-INTEGER)))
   (CL:SETQ FIELD-START (POSITION DOMAIN-NAME #\: 0))
   (CL:WHEN (CL:NOT (CL:= FIELD-START NULL-INTEGER))
    (CL:SETQ PORT-NUMBER
     (SUBSEQUENCE DOMAIN-NAME (CL:1+ FIELD-START) NULL-INTEGER))
    (CL:SETQ DOMAIN-NAME (SUBSEQUENCE DOMAIN-NAME 0 FIELD-START)))
   (CL:VALUES PROTOCOL USER-INFORMATION DOMAIN-NAME PORT-NUMBER PATH
    QUERY FRAGMENT)))

;;; (DEFUN (COMPOSE-INTERNET-URL STRING) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION
   (CL:SIMPLE-STRING CL:SIMPLE-STRING CL:SIMPLE-STRING CL:FIXNUM
    CL:SIMPLE-STRING CL:SIMPLE-STRING CL:SIMPLE-STRING)
   CL:SIMPLE-STRING)
  COMPOSE-INTERNET-URL))
(CL:DEFUN COMPOSE-INTERNET-URL (PROTOCOL USERINFO HOST PORT PATH QUERY FRAGMENT)
  "The inverse to `decompose-internet-url'.  Builds a URL string from the supplied
components.  Undefined portions can be supplied as NULL or the empty string."
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING PROTOCOL USERINFO HOST PATH QUERY
    FRAGMENT)
   (CL:TYPE CL:FIXNUM PORT))
  #+MCL
  (CL:CHECK-TYPE PROTOCOL CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE USERINFO CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PORT CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE PATH CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE QUERY CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE FRAGMENT CL:SIMPLE-STRING)
  (CL:LET* ((URL (NEW-OUTPUT-STRING-STREAM)))
   (CL:WHEN (CL:NOT (BLANK-STRING? PROTOCOL))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) PROTOCOL
     "://"))
   (CL:WHEN (CL:NOT (BLANK-STRING? USERINFO))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) USERINFO
     "@"))
   (CL:WHEN (CL:NOT (BLANK-STRING? HOST))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) HOST))
   (CL:WHEN (CL:NOT (CL:= PORT NULL-INTEGER))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) ":"
     PORT))
   (CL:WHEN (CL:NOT (BLANK-STRING? PATH))
    (CL:IF (STARTS-WITH? PATH "/" 0)
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) PATH)
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) "/"
      PATH)))
   (CL:WHEN (CL:NOT (BLANK-STRING? QUERY))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) "?"
     QUERY))
   (CL:WHEN (CL:NOT (BLANK-STRING? FRAGMENT))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) "#"
     FRAGMENT))
   (THE-STRING-READER URL)))

;;; (DEFUN (URL-PATH-TO-FILENAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  URL-PATH-TO-FILENAME))
(CL:DEFUN URL-PATH-TO-FILENAME (PATH)
  "Transform a URL `path' into a valid native filename for the local OS."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATH))
  #+MCL
  (CL:CHECK-TYPE PATH CL:SIMPLE-STRING)
  (CL:LET* ((SEPARATOR (DIRECTORY-SEPARATOR)))
   (CL:IF (CL:EQL SEPARATOR #\/) (UNESCAPE-URL-STRING PATH)
    (CL:PROGN
     (CL:SETQ PATH
      (UNESCAPE-URL-STRING (SUBSTITUTE PATH SEPARATOR #\/)))
     (CL:WHEN
      (CL:AND (CL:EQ (OPERATING-SYSTEM) KWD-HTTP-CLIENT-MAC)
       (CL:EQL
        (CL:LET ((SELF PATH) (POSITION 0))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION)))
        SEPARATOR))
      (CL:SETQ PATH (SUBSEQUENCE PATH 1 NULL-INTEGER)))
     PATH))))

(CL:DEFUN NEW-HTTP-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE HTTP-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:SETF (%ERROR-CODE SELF) NULL-INTEGER) SELF))

;;; (DEFCONSTANT HTTP-DEFAULT-PORT ...)

(CL:DEFVAR HTTP-DEFAULT-PORT 80)
(CL:DECLAIM (CL:TYPE CL:FIXNUM HTTP-DEFAULT-PORT))

;;; (DEFUN (HANDLE-HTTP-HEADER-FIRST-LINE STRING INTEGER STRING) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:SIMPLE-STRING CL:T)
   (CL:VALUES CL:SIMPLE-STRING CL:FIXNUM CL:SIMPLE-STRING))
  HANDLE-HTTP-HEADER-FIRST-LINE))
(CL:DEFUN HANDLE-HTTP-HEADER-FIRST-LINE (LINE FIELDS)
  "Handles the first line of an http header.  
Returns version, response code, response message.  The first
line is inserted into `fields' fields with the empty string key \"\"
This is a low-level utility routine that can be used to build custom
message parsing code."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LINE))
  #+MCL
  (CL:CHECK-TYPE LINE CL:SIMPLE-STRING)
  (CL:LET*
   ((SPACE1 (POSITION LINE #\  0))
    (SPACE2
     (CL:IF (CL:= SPACE1 NULL-INTEGER) NULL-INTEGER
      (POSITION LINE #\  (CL:1+ SPACE1)))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SPACE1 SPACE2))
   (CL:WHEN (CL:= SPACE2 NULL-INTEGER)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Malformed header line: `" LINE "'")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
   (INSERT-AT FIELDS (WRAP-STRING "") (WRAP-STRING LINE))
   (CL:VALUES (SUBSEQUENCE LINE 0 SPACE1)
    (CL:TRUNCATE
     (STRING-TO-INTEGER (SUBSEQUENCE LINE (CL:1+ SPACE1) SPACE2)))
    (SUBSEQUENCE LINE (CL:1+ SPACE2) NULL-INTEGER))))

;;; (DEFUN HANDLE-HTTP-HEADER-OTHER-LINE ...)

(CL:DEFUN HANDLE-HTTP-HEADER-OTHER-LINE (LINE FIELDS)
  "Handles header lines other than the first one.
Each such line is inserted into `fields' as keyword value pairs.
This is a low-level utility routine that can be used to build custom
message parsing code."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LINE))
  #+MCL
  (CL:CHECK-TYPE LINE CL:SIMPLE-STRING)
  (CL:LET* ((COLON-POSITION (POSITION LINE #\: 0)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COLON-POSITION))
   (CL:IF (CL:= COLON-POSITION NULL-INTEGER)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Bad header seen: `" LINE "'")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))
    (INSERT-AT FIELDS (WRAP-STRING (SUBSEQUENCE LINE 0 COLON-POSITION))
     (WRAP-STRING
      (SUBSEQUENCE LINE (CL:+ COLON-POSITION 2) NULL-INTEGER))))))

;;; (DEFUN (READ-HTTP-HEADER-LINE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) READ-HTTP-HEADER-LINE))
(CL:DEFUN READ-HTTP-HEADER-LINE (STREAM)
  (CL:LET*
   ((LINE (NATIVE-READ-LINE STREAM))
    (LENGTH (CL:THE CL:FIXNUM (CL:LENGTH LINE)))
    (NEXTCHAR NULL-CHARACTER))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LINE)
    (CL:TYPE CL:FIXNUM LENGTH))
   (CL:WHEN (CL:EQ LINE STELLA::NULL-STRING)
    (CL:RETURN-FROM READ-HTTP-HEADER-LINE STELLA::NULL-STRING))
   (CL:WHEN
    (CL:AND (CL:> LENGTH 0)
     (CL:EQL
      (CL:LET ((SELF LINE) (POSITION (CL:1- LENGTH)))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION)))
      #\Return))
    (CL:RETURN-FROM READ-HTTP-HEADER-LINE
     (SUBSEQUENCE LINE 0 (CL:1- LENGTH))))
   (CL:SETQ NEXTCHAR (READ-CHARACTER STREAM))
   (CL:COND ((CL:EQL NEXTCHAR #\Linefeed))
    (CL:T (UNREAD-CHARACTER NEXTCHAR STREAM)))
   LINE))

;;; (DEFUN (READ-HTTP-HEADER INTEGER STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:T CL:T)
   (CL:VALUES CL:FIXNUM CL:SIMPLE-STRING CL:SIMPLE-STRING))
  READ-HTTP-HEADER))
(CL:DEFUN READ-HTTP-HEADER (STREAM FIELDS)
  "Reads the HTTP header from `stream', parses the header fields
and stores the results in `fields'.  The first line of the response will be
stored in `fields' with the empty string \"\" as the key.  Other values will
have the header name as the key.  The first return value is the response code
of the HTTP request.  A response of 200 indicates success.  Other common
responses are 404 (page not found).  The second return value is the message
associated with the code.  The third return value is the version information.
If the stream ends before a valid header is read, then `null' is returned for
all values."
  (CL:LET*
   ((VERSION-STRING STELLA::NULL-STRING) (RESPONSE-CODE NULL-INTEGER)
    (RESPONSE-MESSAGE STELLA::NULL-STRING))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING VERSION-STRING RESPONSE-MESSAGE)
    (CL:TYPE CL:FIXNUM RESPONSE-CODE))
   (CL:MULTIPLE-VALUE-SETQ
    (VERSION-STRING RESPONSE-CODE RESPONSE-MESSAGE)
    (HANDLE-HTTP-HEADER-FIRST-LINE (READ-HTTP-HEADER-LINE STREAM)
     FIELDS))
   (CL:LET* ((LINE STELLA::NULL-STRING))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LINE))
    (CL:LOOP (CL:SETQ LINE (READ-HTTP-HEADER-LINE STREAM))
     (CL:COND ((STRING-EQL? LINE "") (CL:RETURN))
      ((CL:EQ LINE STELLA::NULL-STRING) (CL:RETURN))
      (CL:T (HANDLE-HTTP-HEADER-OTHER-LINE LINE FIELDS))))
    (CL:VALUES RESPONSE-CODE RESPONSE-MESSAGE VERSION-STRING))))

;;; (DEFUN (GET-CONTENT-AND-LENGTH OBJECT LONG-INTEGER) ...)

(CL:DEFUN GET-CONTENT-AND-LENGTH (CONTENT)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE CONTENT)))
   (CL:COND
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (CL:VALUES CONTENT
       (CL:TRUNCATE
        (CL:THE CL:FIXNUM
         (CL:LENGTH
          (CL:THE CL:SIMPLE-STRING (UNWRAP-STRING CONTENT))))))))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-HTTP-CLIENT-STELLA-FILE-INPUT-STREAM)
     (CL:PROGN
      (CL:VALUES CONTENT
       (FILE-LENGTH (%INPUT-FILE-STREAM.FILENAME CONTENT)))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-HTTP-CLIENT-STELLA-INPUT-STREAM)
     (CL:PROGN
      (CL:LET* ((CONTENTSTRING (STREAM-TO-STRING CONTENT)))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING CONTENTSTRING))
       (CL:VALUES (WRAP-STRING CONTENTSTRING)
        (CL:TRUNCATE (CL:THE CL:FIXNUM (CL:LENGTH CONTENTSTRING)))))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN WRITE-HTTP-REQUEST ...)

(CL:DEFUN WRITE-HTTP-REQUEST (STREAM METHOD HOST URL-PATH HEADERS CONTENT)
  "Send `content' as an HTTP 1.0 request on `stream' using `method'.
The request is sent to `url-path' at `host'.  The `stream' must be a TCP-stream
that is connected to `host' at the appropriate port.  `content' can be a string or
an input stream to read from."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST URL-PATH))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE URL-PATH CL:SIMPLE-STRING)
  (CL:LET* ((CONTENTLENGTH 0))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
    (%KEYWORD.SYMBOL-NAME METHOD) " " URL-PATH " HTTP/1.0
")
   (CL:WHEN (CL:NOT (CL:EQ HOST STELLA::NULL-STRING))
    (CL:WHEN (CL:EQ HEADERS NULL)
     (CL:SETQ HEADERS (NEW-KEY-VALUE-LIST)))
    (INSERT-AT HEADERS (WRAP-STRING "Host") (WRAP-STRING HOST)))
   (CL:WHEN (CL:NOT (CL:EQ CONTENT NULL))
    (CL:MULTIPLE-VALUE-SETQ (CONTENT CONTENTLENGTH)
     (GET-CONTENT-AND-LENGTH CONTENT))
    (CL:WHEN (CL:EQ HEADERS NULL)
     (CL:SETQ HEADERS (NEW-KEY-VALUE-LIST)))
    (INSERT-AT HEADERS (WRAP-STRING "Content-Length")
     (WRAP-STRING (INTEGER-TO-STRING CONTENTLENGTH))))
   (CL:WHEN (CL:NOT (CL:EQ HEADERS NULL))
    (CL:LET*
     ((KEY NULL) (VALUE NULL)
      (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST HEADERS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
      (CL:SETQ KEY (%KV-CONS.KEY ITER-000))
      (CL:SETQ VALUE (%KV-CONS.VALUE ITER-000))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (UNWRAP-STRING KEY) ": " (UNWRAP-STRING VALUE) "
")
      (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000)))))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
    "Connection: close
")
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "
")
   (CL:WHEN (CL:NOT (CL:EQ CONTENT NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE CONTENT)))
     (CL:COND
      ((SUBTYPE-OF-STRING? TEST-VALUE-000)
       (CL:PROGN
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
         (UNWRAP-STRING CONTENT))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-HTTP-CLIENT-STELLA-INPUT-STREAM)
       (CL:PROGN (COPY-STREAM-TO-STREAM CONTENT STREAM)))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
         TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
   (FLUSH-OUTPUT STREAM)))

;;; (DEFUN (HTTP-POST-DATA INPUT-STREAM) ...)

(CL:DEFUN HTTP-POST-DATA (HOST PORT URL-PATH HEADERS CONTENT)
  "Posts `content' as data to `url-path' on `host' and `port'.
`content' can be a string or an input stream to read from.  The port value for
standard http servers is 80.  Returns the body of the reply message as a stream,
if successful.  Otherwise an HTTP-EXCEPTION is signaled."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST URL-PATH)
   (CL:TYPE CL:FIXNUM PORT))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PORT CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE URL-PATH CL:SIMPLE-STRING)
  (CL:LET* ((RETURN-HEADERS (NEW-KEY-VALUE-LIST)))
   (CL:LET* ((*PRINTREADABLY?* CL:NIL))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (CL:LET* ((IN NULL) (OUT NULL))
     (CL:MULTIPLE-VALUE-SETQ (IN OUT) (OPEN-NETWORK-STREAM HOST PORT))
     (WRITE-HTTP-REQUEST OUT KWD-HTTP-CLIENT-POST HOST URL-PATH HEADERS
      CONTENT)
     (CL:LET*
      ((RETURN-CODE NULL-INTEGER) (RETURN-MESSAGE STELLA::NULL-STRING)
       (VERSION STELLA::NULL-STRING))
      (CL:DECLARE (CL:TYPE CL:FIXNUM RETURN-CODE)
       (CL:TYPE CL:SIMPLE-STRING RETURN-MESSAGE VERSION))
      (CL:MULTIPLE-VALUE-SETQ (RETURN-CODE RETURN-MESSAGE VERSION)
       (READ-HTTP-HEADER IN RETURN-HEADERS))
      (CL:SETQ VERSION VERSION)
      (CL:COND ((HTTP-SUCCESS-RESPONSE-CODE? RETURN-CODE) IN)
       (CL:T
        (CL:LET* ((SELF-001 (NEW-HTTP-EXCEPTION RETURN-MESSAGE)))
         (CL:SETF (%ERROR-CODE SELF-001) RETURN-CODE)
         (CL:LET* ((EX SELF-001))
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
           "http-post-data: code=" RETURN-CODE ", message="
           RETURN-MESSAGE ", version=" VERSION)
          (CLOSE-STREAM IN) (CLOSE-STREAM OUT) (CL:ERROR EX))))))))))

;;; (DEFUN (HTTP-POST-DATA-TO-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:SIMPLE-STRING CL:FIXNUM CL:SIMPLE-STRING CL:T CL:T)
   CL:SIMPLE-STRING)
  HTTP-POST-DATA-TO-STRING))
(CL:DEFUN HTTP-POST-DATA-TO-STRING (HOST PORT URL-PATH HEADERS CONTENT)
  "Just like `http-post-data' (which see) but returns the reply as a string.
CAUTION: String conversion will not do the right thing for binary data in Java."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST URL-PATH)
   (CL:TYPE CL:FIXNUM PORT))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PORT CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE URL-PATH CL:SIMPLE-STRING)
  (CL:LET*
   ((STREAM (HTTP-POST-DATA HOST PORT URL-PATH HEADERS CONTENT))
    (DATA (STREAM-TO-STRING STREAM)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DATA)) (CLOSE-STREAM STREAM)
   DATA))

;;; (DEFUN (HTTP-GET-DATA INPUT-STREAM) ...)

(CL:DEFUN HTTP-GET-DATA (HOST PORT URL-PATH RETURN-HEADERS)
  "Accesses the data described by `url-path' on `host' and `port'.
The port value for standard http servers is 80.  If successful, returns the body
of the web message as a stream.  The headers from the reply message will be set
in `return-headers' if not null'.  If an error occurs an HTTP-EXCEPTION is signaled."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST URL-PATH)
   (CL:TYPE CL:FIXNUM PORT))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PORT CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE URL-PATH CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ RETURN-HEADERS NULL)
   (CL:SETQ RETURN-HEADERS (NEW-KEY-VALUE-LIST)))
  (CL:LET* ((*PRINTREADABLY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (CL:LET* ((IN NULL) (OUT NULL))
    (CL:MULTIPLE-VALUE-SETQ (IN OUT) (OPEN-NETWORK-STREAM HOST PORT))
    (WRITE-HTTP-REQUEST OUT KWD-HTTP-CLIENT-GET HOST URL-PATH NULL
     NULL)
    (CL:LET*
     ((RETURN-CODE NULL-INTEGER) (RETURN-MESSAGE STELLA::NULL-STRING)
      (VERSION STELLA::NULL-STRING))
     (CL:DECLARE (CL:TYPE CL:FIXNUM RETURN-CODE)
      (CL:TYPE CL:SIMPLE-STRING RETURN-MESSAGE VERSION))
     (CL:MULTIPLE-VALUE-SETQ (RETURN-CODE RETURN-MESSAGE VERSION)
      (READ-HTTP-HEADER IN RETURN-HEADERS))
     (CL:SETQ VERSION VERSION)
     (CL:COND ((HTTP-SUCCESS-RESPONSE-CODE? RETURN-CODE) IN)
      (CL:T
       (CL:LET* ((SELF-001 (NEW-HTTP-EXCEPTION RETURN-MESSAGE)))
        (CL:SETF (%ERROR-CODE SELF-001) RETURN-CODE)
        (CL:LET* ((EX SELF-001))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "http-get-data: code=" RETURN-CODE ", message="
          RETURN-MESSAGE ", version=" VERSION)
         (CLOSE-STREAM IN) (CLOSE-STREAM OUT) (CL:ERROR EX)))))))))

;;; (DEFUN (HTTP-GET-DATA-TO-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:SIMPLE-STRING CL:FIXNUM CL:SIMPLE-STRING CL:T)
   CL:SIMPLE-STRING)
  HTTP-GET-DATA-TO-STRING))
(CL:DEFUN HTTP-GET-DATA-TO-STRING (HOST PORT URL-PATH RETURN-HEADERS)
  "Just like `http-get-data' (which see) but returns the result as a string.
CAUTION: String conversion will not do the right thing for binary data in Java."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST URL-PATH)
   (CL:TYPE CL:FIXNUM PORT))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PORT CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE URL-PATH CL:SIMPLE-STRING)
  (CL:LET*
   ((STREAM (HTTP-GET-DATA HOST PORT URL-PATH RETURN-HEADERS))
    (DATA (STREAM-TO-STRING STREAM)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DATA)) (CLOSE-STREAM STREAM)
   DATA))

;;; (DEFUN (OPEN-URL-STREAM INPUT-STREAM) ...)

(CL:DEFUN OPEN-URL-STREAM (URL)
  "Opens an input stream to `url'.
Currently only http: with no user name or password and file: urls on the local
host with absolute pathnames are supported."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING URL))
  #+MCL
  (CL:CHECK-TYPE URL CL:SIMPLE-STRING)
  (CL:LET*
   ((PROTOCOL STELLA::NULL-STRING) (USER-INFO STELLA::NULL-STRING)
    (HOST STELLA::NULL-STRING) (PORT STELLA::NULL-STRING)
    (PATH STELLA::NULL-STRING) (QUERY STELLA::NULL-STRING)
    (FRAGMENT STELLA::NULL-STRING))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING PROTOCOL USER-INFO HOST PORT PATH QUERY
     FRAGMENT))
   (CL:MULTIPLE-VALUE-SETQ
    (PROTOCOL USER-INFO HOST PORT PATH QUERY FRAGMENT)
    (DECOMPOSE-INTERNET-URL URL))
   (CL:LET* ((TEST-VALUE-000 (STRING-DOWNCASE PROTOCOL)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEST-VALUE-000))
    (CL:COND
     ((STRING-EQL? TEST-VALUE-000 "http")
      (CL:COND
       ((CL:NOT (STRING-EQL? USER-INFO ""))
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
          "open-url-stream: only URLs without user information are supported: `"
          URL "'")
         (CL:ERROR
          (NEW-BAD-ARGUMENT-EXCEPTION
           (THE-STRING-READER STREAM-000)))))
       (CL:T
        (CL:LET*
         ((THEPORT HTTP-DEFAULT-PORT)
          (THEPATH
           (COMPOSE-INTERNET-URL "" "" "" NULL-INTEGER PATH QUERY
            FRAGMENT)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM THEPORT)
          (CL:TYPE CL:SIMPLE-STRING THEPATH))
         (CL:WHEN (CL:NOT (BLANK-STRING? PORT))
          (CL:SETQ THEPORT (CL:TRUNCATE (STRING-TO-INTEGER PORT))))
         (HTTP-GET-DATA HOST THEPORT THEPATH NULL)))))
     ((STRING-EQL? TEST-VALUE-000 "file")
      (CL:COND
       ((CL:NOT (STRING-EQL? USER-INFO ""))
        (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
          "open-url-stream: only URLs without user information are supported: `"
          URL "'")
         (CL:ERROR
          (NEW-BAD-ARGUMENT-EXCEPTION
           (THE-STRING-READER STREAM-001)))))
       ((CL:OR (BLANK-STRING? HOST) (STRING-EQL? HOST "localhost"))
        (NEW-INPUT-FILE-STREAM (URL-PATH-TO-FILENAME PATH)))
       (CL:T
        (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
          "open-url-stream: only absolute file URLs on the local host are supported: `"
          URL "'")
         (CL:ERROR
          (NEW-BAD-ARGUMENT-EXCEPTION
           (THE-STRING-READER STREAM-002)))))))
     (CL:T
      (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003)
        "open-url-stream: only http and file URLs are supported: `" URL
        "'")
       (CL:ERROR
        (NEW-BAD-ARGUMENT-EXCEPTION
         (THE-STRING-READER STREAM-003)))))))))

;;; (DEFMACRO WITH-INPUT-URL ...)

(CL:DEFUN WITH-INPUT-URL (BINDING BODY)
  "Sets up an unwind-protected form which opens a URL for
input and closes it afterwards.  The stream for reading is bound to the
variable provided in the macro form.
Syntax is `(WITH-INPUT-URL (var url) body+)'."
  (CL:LET* ((VAR (%%VALUE BINDING)))
   (LIST* SYM-HTTP-CLIENT-STELLA-LET
    (CONS
     (CONS VAR
      (LIST* SYM-HTTP-CLIENT-STELLA-INPUT-STREAM
       SYM-HTTP-CLIENT-STELLA-NULL NIL))
     NIL)
    (LIST* SYM-HTTP-CLIENT-STELLA-UNWIND-PROTECT
     (LIST* SYM-HTTP-CLIENT-STELLA-PROGN
      (LIST* SYM-HTTP-CLIENT-STELLA-SETQ VAR
       (CONS
        (LIST* SYM-HTTP-CLIENT-HTTP-OPEN-URL-STREAM
         (%%VALUE (%%REST BINDING)) NIL)
        NIL))
      (CONCATENATE BODY NIL))
     (LIST* SYM-HTTP-CLIENT-STELLA-WHEN
      (LIST* SYM-HTTP-CLIENT-STELLA-DEFINED? VAR NIL)
      (LIST* SYM-HTTP-CLIENT-STELLA-CLOSE-STREAM VAR NIL) NIL)
     NIL)
    NIL)))

;;; (DEFUN DOWNLOAD-URL ...)

(CL:DEFUN %DOWNLOAD-URL (URL FILE)
  "Download the data at `url' and save it to `file'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING URL FILE))
  #+MCL
  (CL:CHECK-TYPE URL CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE FILE CL:SIMPLE-STRING)
  (CL:LET* ((OUT NULL))
   (CL:UNWIND-PROTECT
    (CL:PROGN (CL:SETQ OUT (OPEN-OUTPUT-FILE FILE))
     (COPY-STREAM-TO-STREAM (OPEN-URL-STREAM URL) OUT))
    (CL:WHEN (CL:NOT (CL:EQ OUT NULL)) (FREE OUT)))))

(CL:DEFUN DOWNLOAD-URL-EVALUATOR-WRAPPER (ARGUMENTS)
  (%DOWNLOAD-URL (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))
   (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO DOWNLOAD-URL (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Download the data at `url' and save it to `file'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/HTTP/DOWNLOAD-URL|)) (CL:MACRO-FUNCTION (CL:QUOTE DOWNLOAD-URL)))

;;; (DEFUN (DOWNLOAD-URL-TO-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  %DOWNLOAD-URL-TO-STRING))
(CL:DEFUN %DOWNLOAD-URL-TO-STRING (URL)
  "Download the data at `url' and return it as a string.
CAUTION: String conversion will not do the right thing for binary data in Java."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING URL))
  #+MCL
  (CL:CHECK-TYPE URL CL:SIMPLE-STRING)
  (STREAM-TO-STRING (OPEN-URL-STREAM URL)))

(CL:DEFUN DOWNLOAD-URL-TO-STRING-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (%DOWNLOAD-URL-TO-STRING
      (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:IF (CL:NOT (CL:EQ RESULT STELLA::NULL-STRING))
    (WRAP-STRING RESULT) NULL)))

(CL:DEFMACRO DOWNLOAD-URL-TO-STRING (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Download the data at `url' and return it as a string.
CAUTION: String conversion will not do the right thing for binary data in Java."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/HTTP/DOWNLOAD-URL-TO-STRING|)) (CL:MACRO-FUNCTION (CL:QUOTE DOWNLOAD-URL-TO-STRING)))

;;; (DEFUN (DO-HTTP-REQUEST STRING) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:SIMPLE-STRING CL:&REST CL:T) CL:SIMPLE-STRING)
  %DO-HTTP-REQUEST))
(CL:DEFUN %DO-HTTP-REQUEST (URI OPTIONS)
  "Send an http request to `uri' and return a string representing the result."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING URI))
  #+MCL
  (CL:CHECK-TYPE URI CL:SIMPLE-STRING)
  (CL:LET*
   ((PROPLIST
     (VET-OPTIONS OPTIONS
      (GET-QUOTED-TREE "((:METHOD :HEADERS :CONTENT) \"/HTTP\")"
       "/HTTP")))
    (METHOD
     (LOOKUP-WITH-DEFAULT PROPLIST KWD-HTTP-CLIENT-METHOD
      KWD-HTTP-CLIENT-GET))
    (HEADERS (LOOKUP PROPLIST KWD-HTTP-CLIENT-HEADERS))
    (CONTENT (LOOKUP PROPLIST KWD-HTTP-CLIENT-CONTENT)))
   (CL:WHEN (CL:NOT (CL:EQ HEADERS NULL))
    (CL:WHEN
     (CL:NOT
      (ISA? HEADERS
       (TYPE-SPEC-TO-BASE-TYPE
        (REAL-TYPE-SPECIFIER SGT-HTTP-CLIENT-HTTP-HTTP-HEADERS))))
     (CL:LET* ((HTTPHEADERS (NEW-KEY-VALUE-LIST)))
      (CL:LET*
       ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR HEADERS)))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ KEY (%DICTIONARY-ITERATOR.KEY ITER-000))
        (CL:SETQ VALUE (%DICTIONARY-ITERATOR.VALUE ITER-000))
        (INSERT-AT HTTPHEADERS KEY VALUE)))
      (CL:SETQ HEADERS HTTPHEADERS))))
   (CL:LET*
    ((PROTOCOL STELLA::NULL-STRING) (USER-INFO STELLA::NULL-STRING)
     (HOST STELLA::NULL-STRING) (PORT STELLA::NULL-STRING)
     (PATH STELLA::NULL-STRING) (QUERY STELLA::NULL-STRING)
     (FRAGMENT STELLA::NULL-STRING))
    (CL:DECLARE
     (CL:TYPE CL:SIMPLE-STRING PROTOCOL USER-INFO HOST PORT PATH QUERY
      FRAGMENT))
    (CL:MULTIPLE-VALUE-SETQ
     (PROTOCOL USER-INFO HOST PORT PATH QUERY FRAGMENT)
     (DECOMPOSE-INTERNET-URL URI))
    (CL:SETQ USER-INFO USER-INFO)
    (CL:WHEN (CL:NOT (STRING-EQUAL? PROTOCOL "http"))
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "do-http-request: unsupported protocol: `" PROTOCOL "'")
      (CL:ERROR
       (NEW-BAD-ARGUMENT-EXCEPTION (THE-STRING-READER STREAM-000)))))
    (CL:LET*
     ((THEPORT HTTP-DEFAULT-PORT)
      (THEPATH
       (COMPOSE-INTERNET-URL "" "" "" NULL-INTEGER PATH QUERY
        FRAGMENT)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM THEPORT)
      (CL:TYPE CL:SIMPLE-STRING THEPATH))
     (CL:WHEN (CL:NOT (BLANK-STRING? PORT))
      (CL:SETQ THEPORT (CL:TRUNCATE (STRING-TO-INTEGER PORT))))
     (CL:COND
      ((CL:EQ METHOD KWD-HTTP-CLIENT-GET)
       (HTTP-GET-DATA-TO-STRING HOST THEPORT THEPATH HEADERS))
      ((CL:EQ METHOD KWD-HTTP-CLIENT-POST)
       (HTTP-POST-DATA-TO-STRING HOST THEPORT THEPATH HEADERS CONTENT))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
         "do-http-request: unsupported method: `" METHOD "'")
        (CL:ERROR
         (NEW-BAD-ARGUMENT-EXCEPTION
          (THE-STRING-READER STREAM-001))))))))))

(CL:DEFUN DO-HTTP-REQUEST-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (%DO-HTTP-REQUEST
      (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))
      (%%REST ARGUMENTS))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:IF (CL:NOT (CL:EQ RESULT STELLA::NULL-STRING))
    (WRAP-STRING RESULT) NULL)))

(CL:DEFMACRO DO-HTTP-REQUEST (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Send an http request to `uri' and return a string representing the result."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/HTTP/DO-HTTP-REQUEST|)) (CL:MACRO-FUNCTION (CL:QUOTE DO-HTTP-REQUEST)))

(CL:DEFUN STARTUP-HTTP-CLIENT ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/HTTP" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (CL:SETQ KWD-HTTP-CLIENT-MAC
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MAC" NULL 2))
    (CL:SETQ SYM-HTTP-CLIENT-HTTP-HTTP-HEADERS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "HTTP-HEADERS" NULL 0))
    (CL:SETQ SGT-HTTP-CLIENT-STELLA-FILE-INPUT-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FILE-INPUT-STREAM"
      (GET-STELLA-MODULE "/STELLA" CL:T) 1))
    (CL:SETQ SGT-HTTP-CLIENT-STELLA-INPUT-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-STREAM"
      (GET-STELLA-MODULE "/STELLA" CL:T) 1))
    (CL:SETQ KWD-HTTP-CLIENT-POST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "POST" NULL 2))
    (CL:SETQ KWD-HTTP-CLIENT-GET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GET" NULL 2))
    (CL:SETQ SYM-HTTP-CLIENT-STELLA-LET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LET"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0))
    (CL:SETQ SYM-HTTP-CLIENT-STELLA-INPUT-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-STREAM"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0))
    (CL:SETQ SYM-HTTP-CLIENT-STELLA-NULL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0))
    (CL:SETQ SYM-HTTP-CLIENT-STELLA-UNWIND-PROTECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNWIND-PROTECT"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0))
    (CL:SETQ SYM-HTTP-CLIENT-STELLA-PROGN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROGN"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0))
    (CL:SETQ SYM-HTTP-CLIENT-STELLA-SETQ
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0))
    (CL:SETQ SYM-HTTP-CLIENT-HTTP-OPEN-URL-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-URL-STREAM" NULL 0))
    (CL:SETQ SYM-HTTP-CLIENT-STELLA-WHEN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0))
    (CL:SETQ SYM-HTTP-CLIENT-STELLA-DEFINED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0))
    (CL:SETQ SYM-HTTP-CLIENT-STELLA-CLOSE-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSE-STREAM"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0))
    (CL:SETQ SYM-HTTP-CLIENT-HTTP-DOWNLOAD-URL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWNLOAD-URL" NULL 0))
    (CL:SETQ KWD-HTTP-CLIENT-COMMON-LISP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
    (CL:SETQ KWD-HTTP-CLIENT-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ SYM-HTTP-CLIENT-HTTP-DOWNLOAD-URL-TO-STRING
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWNLOAD-URL-TO-STRING" NULL 0))
    (CL:SETQ KWD-HTTP-CLIENT-METHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD" NULL 2))
    (CL:SETQ KWD-HTTP-CLIENT-HEADERS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "HEADERS" NULL 2))
    (CL:SETQ KWD-HTTP-CLIENT-CONTENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTENT" NULL 2))
    (CL:SETQ SGT-HTTP-CLIENT-HTTP-HTTP-HEADERS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "HTTP-HEADERS" NULL 1))
    (CL:SETQ SYM-HTTP-CLIENT-HTTP-DO-HTTP-REQUEST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DO-HTTP-REQUEST" NULL 0))
    (CL:SETQ SYM-HTTP-CLIENT-HTTP-STARTUP-HTTP-CLIENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-HTTP-CLIENT" NULL 0))
    (CL:SETQ SYM-HTTP-CLIENT-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE HTTP-HEADERS (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER))")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "HTTP-EXCEPTION"
        "(DEFCLASS HTTP-EXCEPTION (READ-EXCEPTION) :PUBLIC-SLOTS ((ERROR-CODE :TYPE INTEGER)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-HTTP-EXCEPTION))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "DECOMPOSE-INTERNET-URL"
     "(DEFUN (DECOMPOSE-INTERNET-URL STRING STRING STRING STRING STRING STRING STRING) ((URL STRING)) :DOCUMENTATION \"Takes an internet style URL and returns the components of
that URL as specified below.  Missing elements return the empty string \\\"\\\".
  PROTOCOL USERNAME:PASSWORD DOMAIN PORT PATH QUERY FRAGMENT

  o Protocol.  The access protocol.

       Those schemes which refer to internet protocols mostly have a
       common syntax for the rest of the object name. This starts with a
       double slash '//' to indicate its presence, and continues until
       the following slash '/':

  o An optional user name, if required (as it is with a few FTP servers).
    The password, if present, follows the user name, separated from it by a colon;
    the user name and optional password are followed by a commercial at sign '@'. 
  o The internet domain name of the host
  o The port number, if it is not the default number for the protocol,
    is given in decimal notation after a colon.
  o Path The path is a hierarchical representation of a particular path. It may 
    define details of how the client should communicate with the server, including
    information to be passed transparently to the server without any processing by
    the client.
    The path is interpreted in a manner dependent on the scheme being used.
    Generally, the reserved slash '/' character (ASCII 2F hex) denotes a level in a
    hierarchical structure, the higher level part to the left of the slash.
  o Query is the part of the hierarchical information following a '?' character.
  o Fragment is the part of the hierarchical information following a '#' character.

References:  http://www.gbiv.com/protocols/uri/rfc/rfc3986.html\" :PUBLIC? TRUE)"
     (CL:FUNCTION DECOMPOSE-INTERNET-URL) NULL)
    (DEFINE-FUNCTION-OBJECT "COMPOSE-INTERNET-URL"
     "(DEFUN (COMPOSE-INTERNET-URL STRING) ((PROTOCOL STRING) (USERINFO STRING) (HOST STRING) (PORT INTEGER) (PATH STRING) (QUERY STRING) (FRAGMENT STRING)) :DOCUMENTATION \"The inverse to `decompose-internet-url'.  Builds a URL string from the supplied
components.  Undefined portions can be supplied as NULL or the empty string.\" :PUBLIC? TRUE)"
     (CL:FUNCTION COMPOSE-INTERNET-URL) NULL)
    (DEFINE-FUNCTION-OBJECT "URL-PATH-TO-FILENAME"
     "(DEFUN (URL-PATH-TO-FILENAME STRING) ((PATH STRING)) :DOCUMENTATION \"Transform a URL `path' into a valid native filename for the local OS.\" :PUBLIC? TRUE)"
     (CL:FUNCTION URL-PATH-TO-FILENAME) NULL)
    (DEFINE-FUNCTION-OBJECT "HANDLE-HTTP-HEADER-FIRST-LINE"
     "(DEFUN (HANDLE-HTTP-HEADER-FIRST-LINE STRING INTEGER STRING) ((LINE STRING) (FIELDS HTTP-HEADERS)) :DOCUMENTATION \"Handles the first line of an http header.  
Returns version, response code, response message.  The first
line is inserted into `fields' fields with the empty string key \\\"\\\"
This is a low-level utility routine that can be used to build custom
message parsing code.\" :PUBLIC? TRUE)"
     (CL:FUNCTION HANDLE-HTTP-HEADER-FIRST-LINE) NULL)
    (DEFINE-FUNCTION-OBJECT "HANDLE-HTTP-HEADER-OTHER-LINE"
     "(DEFUN HANDLE-HTTP-HEADER-OTHER-LINE ((LINE STRING) (FIELDS HTTP-HEADERS)) :DOCUMENTATION \"Handles header lines other than the first one.
Each such line is inserted into `fields' as keyword value pairs.
This is a low-level utility routine that can be used to build custom
message parsing code.\" :PUBLIC? TRUE)"
     (CL:FUNCTION HANDLE-HTTP-HEADER-OTHER-LINE) NULL)
    (DEFINE-FUNCTION-OBJECT "READ-HTTP-HEADER-LINE"
     "(DEFUN (READ-HTTP-HEADER-LINE STRING) ((STREAM INPUT-STREAM)))"
     (CL:FUNCTION READ-HTTP-HEADER-LINE) NULL)
    (DEFINE-FUNCTION-OBJECT "READ-HTTP-HEADER"
     "(DEFUN (READ-HTTP-HEADER INTEGER STRING STRING) ((STREAM INPUT-STREAM) (FIELDS HTTP-HEADERS)) :DOCUMENTATION \"Reads the HTTP header from `stream', parses the header fields
and stores the results in `fields'.  The first line of the response will be
stored in `fields' with the empty string \\\"\\\" as the key.  Other values will
have the header name as the key.  The first return value is the response code
of the HTTP request.  A response of 200 indicates success.  Other common
responses are 404 (page not found).  The second return value is the message
associated with the code.  The third return value is the version information.
If the stream ends before a valid header is read, then `null' is returned for
all values.\" :PUBLIC? TRUE)" (CL:FUNCTION READ-HTTP-HEADER) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-CONTENT-AND-LENGTH"
     "(DEFUN (GET-CONTENT-AND-LENGTH OBJECT LONG-INTEGER) ((CONTENT OBJECT)))"
     (CL:FUNCTION GET-CONTENT-AND-LENGTH) NULL)
    (DEFINE-FUNCTION-OBJECT "WRITE-HTTP-REQUEST"
     "(DEFUN WRITE-HTTP-REQUEST ((STREAM OUTPUT-STREAM) (METHOD KEYWORD) (HOST STRING) (URL-PATH STRING) (HEADERS HTTP-HEADERS) (CONTENT OBJECT)) :DOCUMENTATION \"Send `content' as an HTTP 1.0 request on `stream' using `method'.
The request is sent to `url-path' at `host'.  The `stream' must be a TCP-stream
that is connected to `host' at the appropriate port.  `content' can be a string or
an input stream to read from.\" :PUBLIC? TRUE)"
     (CL:FUNCTION WRITE-HTTP-REQUEST) NULL)
    (DEFINE-FUNCTION-OBJECT "HTTP-POST-DATA"
     "(DEFUN (HTTP-POST-DATA INPUT-STREAM) ((HOST STRING) (PORT INTEGER) (URL-PATH STRING) (HEADERS HTTP-HEADERS) (CONTENT OBJECT)) :DOCUMENTATION \"Posts `content' as data to `url-path' on `host' and `port'.
`content' can be a string or an input stream to read from.  The port value for
standard http servers is 80.  Returns the body of the reply message as a stream,
if successful.  Otherwise an HTTP-EXCEPTION is signaled.\" :PUBLIC? TRUE)"
     (CL:FUNCTION HTTP-POST-DATA) NULL)
    (DEFINE-FUNCTION-OBJECT "HTTP-POST-DATA-TO-STRING"
     "(DEFUN (HTTP-POST-DATA-TO-STRING STRING) ((HOST STRING) (PORT INTEGER) (URL-PATH STRING) (HEADERS HTTP-HEADERS) (CONTENT OBJECT)) :DOCUMENTATION \"Just like `http-post-data' (which see) but returns the reply as a string.
CAUTION: String conversion will not do the right thing for binary data in Java.\" :PUBLIC? TRUE)"
     (CL:FUNCTION HTTP-POST-DATA-TO-STRING) NULL)
    (DEFINE-FUNCTION-OBJECT "HTTP-GET-DATA"
     "(DEFUN (HTTP-GET-DATA INPUT-STREAM) ((HOST STRING) (PORT INTEGER) (URL-PATH STRING) (RETURN-HEADERS HTTP-HEADERS)) :DOCUMENTATION \"Accesses the data described by `url-path' on `host' and `port'.
The port value for standard http servers is 80.  If successful, returns the body
of the web message as a stream.  The headers from the reply message will be set
in `return-headers' if not null'.  If an error occurs an HTTP-EXCEPTION is signaled.\" :PUBLIC? TRUE)"
     (CL:FUNCTION HTTP-GET-DATA) NULL)
    (DEFINE-FUNCTION-OBJECT "HTTP-GET-DATA-TO-STRING"
     "(DEFUN (HTTP-GET-DATA-TO-STRING STRING) ((HOST STRING) (PORT INTEGER) (URL-PATH STRING) (RETURN-HEADERS HTTP-HEADERS)) :DOCUMENTATION \"Just like `http-get-data' (which see) but returns the result as a string.
CAUTION: String conversion will not do the right thing for binary data in Java.\" :PUBLIC? TRUE)"
     (CL:FUNCTION HTTP-GET-DATA-TO-STRING) NULL)
    (DEFINE-FUNCTION-OBJECT "OPEN-URL-STREAM"
     "(DEFUN (OPEN-URL-STREAM INPUT-STREAM) ((URL STRING)) :DOCUMENTATION \"Opens an input stream to `url'.
Currently only http: with no user name or password and file: urls on the local
host with absolute pathnames are supported.\" :PUBLIC? TRUE)"
     (CL:FUNCTION OPEN-URL-STREAM) NULL)
    (DEFINE-FUNCTION-OBJECT "WITH-INPUT-URL"
     "(DEFUN WITH-INPUT-URL ((BINDING CONS) |&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :DOCUMENTATION \"Sets up an unwind-protected form which opens a URL for
input and closes it afterwards.  The stream for reading is bound to the
variable provided in the macro form.
Syntax is `(WITH-INPUT-URL (var url) body+)'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION WITH-INPUT-URL) NULL)
    (DEFINE-FUNCTION-OBJECT "DOWNLOAD-URL"
     "(DEFUN DOWNLOAD-URL ((URL STRING) (FILE STRING)) :DOCUMENTATION \"Download the data at `url' and save it to `file'.\" :PUBLIC? TRUE :COMMAND? TRUE)"
     (CL:FUNCTION %DOWNLOAD-URL)
     (CL:FUNCTION DOWNLOAD-URL-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "DOWNLOAD-URL-TO-STRING"
     "(DEFUN (DOWNLOAD-URL-TO-STRING STRING) ((URL STRING)) :DOCUMENTATION \"Download the data at `url' and return it as a string.
CAUTION: String conversion will not do the right thing for binary data in Java.\" :PUBLIC? TRUE :COMMAND? TRUE)"
     (CL:FUNCTION %DOWNLOAD-URL-TO-STRING)
     (CL:FUNCTION DOWNLOAD-URL-TO-STRING-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "DO-HTTP-REQUEST"
     "(DEFUN (DO-HTTP-REQUEST STRING) ((URI STRING) |&REST| (OPTIONS OBJECT)) :DOCUMENTATION \"Send an http request to `uri' and return a string representing the result.\" :PUBLIC? TRUE :COMMAND? TRUE)"
     (CL:FUNCTION %DO-HTTP-REQUEST)
     (CL:FUNCTION DO-HTTP-REQUEST-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "STARTUP-HTTP-CLIENT"
     "(DEFUN STARTUP-HTTP-CLIENT () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-HTTP-CLIENT) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-HTTP-CLIENT-HTTP-STARTUP-HTTP-CLIENT)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-HTTP-CLIENT-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupHttpClient") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "HTTP")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT HTTP-DEFAULT-PORT INTEGER 80)")
    (REGISTER-NATIVE-NAME SYM-HTTP-CLIENT-HTTP-DOWNLOAD-URL
     KWD-HTTP-CLIENT-COMMON-LISP KWD-HTTP-CLIENT-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-HTTP-CLIENT-HTTP-DOWNLOAD-URL-TO-STRING
     KWD-HTTP-CLIENT-COMMON-LISP KWD-HTTP-CLIENT-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-HTTP-CLIENT-HTTP-DO-HTTP-REQUEST
     KWD-HTTP-CLIENT-COMMON-LISP KWD-HTTP-CLIENT-FUNCTION))))
