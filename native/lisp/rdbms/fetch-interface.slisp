;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; fetch-interface.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2014      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-FETCH-INTERFACE-RDBMS-RUN-FETCH-QUERY NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-STELLA-CONS NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-STELLA-XML-ELEMENT NULL)
(CL:DEFVAR KWD-FETCH-INTERFACE-ERROR NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-RDBMS-HOST NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-RDBMS-PORT NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-RDBMS-TASK-ID NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-RDBMS-SUBTASK-ID NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-RDBMS-DB-NAME NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-RDBMS-F-FETCH-EDB-QUERY-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-LOGIC-QUERY-ITERATOR NULL)
(CL:DEFVAR SYM-FETCH-INTERFACE-LOGIC-?X NULL)
(CL:DEFVAR SYM-FETCH-INTERFACE-RDBMS-STARTUP-FETCH-INTERFACE NULL)
(CL:DEFVAR SYM-FETCH-INTERFACE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* NULL-STRING-WRAPPER *MODULE* *POWERLOOM-LOCK* *CONTEXT* *REVERSEPOLARITY?*
  *MEMOIZATION-ENABLED?* TRUE-WRAPPER FALSE-WRAPPER MEMOIZED-NULL-VALUE NULL-INTEGER EOL NIL))

;;; (DEFUN (RUN-FETCH-QUERY OBJECT) ...)

(CL:DEFUN RUN-FETCH-QUERY (HOST PORT QUERY-ID TASK-ID SUBTASK-ID DATABASE PARAMETERS)
  "Runs a Fetch query specifying the parameters given.
Returns an object representing the returned XML-encoded answer from
the server."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST QUERY-ID TASK-ID SUBTASK-ID DATABASE PARAMETERS) (CL:TYPE CL:FIXNUM PORT))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PORT CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE QUERY-ID CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE TASK-ID CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SUBTASK-ID CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE DATABASE CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PARAMETERS CL:SIMPLE-STRING)
  (CL:LET* ((*PRINTREADABLY?* CL:NIL)) (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (CL:LET* ((URL (NEW-OUTPUT-STRING-STREAM)) (REPLY NULL))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) "/agent/runner?plan=")
    (WRITE-HTML-ESCAPING-URL-SPECIAL-CHARACTERS (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) QUERY-ID)
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) "&TaskID=")
    (WRITE-HTML-ESCAPING-URL-SPECIAL-CHARACTERS (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) TASK-ID)
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) "-")
    (WRITE-HTML-ESCAPING-URL-SPECIAL-CHARACTERS (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) SUBTASK-ID)
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) "&Database=")
    (WRITE-HTML-ESCAPING-URL-SPECIAL-CHARACTERS (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) DATABASE)
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) "&")
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) PARAMETERS)
    (CL:SETQ REPLY
     (CL:FUNCALL (AUTOLOAD "HTTP/HTTP-GET-DATA" "webtools" SGT-FETCH-INTERFACE-RDBMS-RUN-FETCH-QUERY CL:T) HOST PORT
      (THE-STRING-READER URL) NULL))
    (CL:LET* ((EXP NULL) (ITER-000 (XML-EXPRESSIONS REPLY NULL)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ EXP (%XML-EXPRESSION-ITERATOR.VALUE ITER-000))
      (CL:WHEN
       (CL:AND (ISA? EXP SGT-FETCH-INTERFACE-STELLA-CONS) (ISA? (%%VALUE EXP) SGT-FETCH-INTERFACE-STELLA-XML-ELEMENT))
       (CL:LET* ((ITEM-000 (%%VALUE EXP)))
        (CL:COND
         ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "PlanExecution")
           (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000) STELLA::NULL-STRING))
          (CL:RETURN-FROM RUN-FETCH-QUERY EXP))
         ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "Error")
           (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000) STELLA::NULL-STRING))
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
            (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST (%%REST EXP)))) "'")
           (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
         (CL:T))))))
    (CL:ERROR (NEW-STELLA-EXCEPTION "Fetch Query Error: No answer element found.")))))

;;; (DEFUN (NORMALIZE-FETCH-QUERY-ARGUMENTS STRING (CONS OF STRING-WRAPPER) PROPERTY-LIST) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T CL:T) (CL:VALUES CL:SIMPLE-STRING CL:T CL:T)) NORMALIZE-FETCH-QUERY-ARGUMENTS))
(CL:DEFUN NORMALIZE-FETCH-QUERY-ARGUMENTS (PROPOSITION ARGUMENTS)
  (CL:WHEN (CL:NOT (STRING? ARGUMENTS))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T)) (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "PARSING ERROR: Fetch-EDB-query: illegal pattern arguments: `" ARGUMENTS "'." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-FETCH-INTERFACE-ERROR))
    (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:LET*
   ((ARGS (READ-S-EXPRESSION-FROM-STRING (%STRING-WRAPPER.WRAPPER-VALUE ARGUMENTS))) (CURSOR NULL)
    (QUERYID STELLA::NULL-STRING) (OUTPUTARGS NIL) (PARAMETERS NIL) (PARAMETERVALUE NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUERYID))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE ARGS) SGT-FETCH-INTERFACE-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 CL:NIL))
       (CL:SETQ TEST-VALUE-000
        (CL:OR
         (CL:AND (CONS? (%%VALUE ARGS))
          (CL:LET ((X (LENGTH ARGS))) (CL:DECLARE (CL:TYPE CL:FIXNUM X)) (CL:NOT (CL:LOGBITP 0 X))))
         (CL:AND (CL:NOT (CONS? (%%VALUE ARGS))) (CL:LOGBITP 0 (CL:THE CL:FIXNUM (LENGTH ARGS))))))
       (CL:WHEN TEST-VALUE-000
        (CL:LET* ((ALWAYS?-000 CL:T))
         (CL:LET* ((ARG NULL) (ITER-000 (%%REST ARGS)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO (CL:SETQ ARG (%%VALUE ITER-000))
           (CL:WHEN (CONS? ARG) (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN)) (CL:SETQ ITER-000 (%%REST ITER-000))))
         (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
       (CL:WHEN (CL:NOT TEST-VALUE-000)
        (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((*PRINTREADABLY?* CL:T)) (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
           "PARSING ERROR: Fetch-EDB-query: illegal pattern arguments: `" ARGUMENTS "'." EOL)
          (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-FETCH-INTERFACE-ERROR))
         (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-001))))))
      (CL:SETQ CURSOR ARGS)
      (CL:COND
       ((CONS? (%%VALUE CURSOR))
        (CL:LET* ((OUTARG NULL) (ITER-001 (%%VALUE CURSOR)) (COLLECT-000 NULL))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO (CL:SETQ OUTARG (%%VALUE ITER-001))
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS (WRAP-STRING (COERCE-TO-STRING OUTARG)) NIL))
            (CL:IF (CL:EQ OUTPUTARGS NIL) (CL:SETQ OUTPUTARGS COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST OUTPUTARGS COLLECT-000)))
           (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS (WRAP-STRING (COERCE-TO-STRING OUTARG)) NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
          (CL:SETQ ITER-001 (%%REST ITER-001))))
        (CL:SETQ CURSOR (%%REST CURSOR)))
       (CL:T (CL:SETQ OUTPUTARGS (GET-TABLE-COLUMN-NAMES (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION))))
        (CL:WHEN (CL:EQ OUTPUTARGS NULL)
         (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
          (CL:LET* ((*PRINTREADABLY?* CL:T)) (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
            "PARSING ERROR: Fetch-EDB-query: missing output arg/column specifications for: `"
            (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION)) "'." EOL)
           (HELP-SIGNAL-PROPOSITION-ERROR STREAM-002 KWD-FETCH-INTERFACE-ERROR))
          (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-002)))))))
      (CL:SETQ QUERYID (COERCE-TO-STRING (%%VALUE CURSOR))) (CL:SETQ CURSOR (%%REST CURSOR))
      (CL:SETQ PARAMETERS CURSOR)
      (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
       (FIRST-SETTER CURSOR (WRAP-STRING (COERCE-TO-STRING (%%VALUE CURSOR))))
       (CL:SETQ PARAMETERVALUE (%%VALUE (%%REST CURSOR)))
       (CL:COND
        ((QUESTION-MARK-SYMBOL? PARAMETERVALUE)
         (CL:LET* ((VALUE-000 NULL))
          (CL:LET*
           ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION)) (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
            (VAR NULL)
            (ITER-002
             (%LIST.THE-CONS-LIST
              (%NAMED-DESCRIPTION.IO-VARIABLE-NAMES (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION))))))
           (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
           (CL:LOOP WHILE (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:NOT (CL:EQ ITER-002 NIL))) DO
            (CL:SETQ ARG (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000)) INDEX-000))
            (CL:SETQ VAR (%%VALUE ITER-002)) (CL:WHEN (CL:EQ VAR PARAMETERVALUE) (CL:SETQ VALUE-000 ARG) (CL:RETURN))
            (CL:SETQ INDEX-000 (CL:1+ INDEX-000)) (CL:SETQ ITER-002 (%%REST ITER-002))))
          (CL:SETQ PARAMETERVALUE VALUE-000))
         (CL:WHEN (CL:EQ PARAMETERVALUE NULL)
          (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
           (CL:LET* ((*PRINTREADABLY?* CL:T)) (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003)
             "PARSING ERROR: Fetch-EDB-query: non-existent input variable: `" (%%VALUE (%%REST CURSOR)) "'." EOL)
            (HELP-SIGNAL-PROPOSITION-ERROR STREAM-003 KWD-FETCH-INTERFACE-ERROR))
           (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-003)))))
         (FIRST-SETTER (%%REST CURSOR) PARAMETERVALUE))
        (CL:T (FIRST-SETTER (%%REST CURSOR) (WRAP-STRING (COERCE-TO-STRING PARAMETERVALUE)))))
       (CL:SETQ CURSOR (%%REST (%%REST CURSOR))))))
    (CL:T
     (CL:LET* ((STREAM-004 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T)) (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-004)
        "PARSING ERROR: Fetch-EDB-query: illegal pattern arguments: `" ARGUMENTS "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-004 KWD-FETCH-INTERFACE-ERROR))
      (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-004))))))
   (CL:LET* ((SELF-010 (NEW-PROPERTY-LIST))) (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-010) PARAMETERS)
    (CL:LET* ((VALUE-001 SELF-010)) (CL:VALUES QUERYID OUTPUTARGS VALUE-001)))))

;;; (DEFUN (HELP-MEMOIZE-FETCH-EDB-QUERY (ITERATOR OF CONS)) ...)

(CL:DEFUN HELP-MEMOIZE-FETCH-EDB-QUERY (PROPOSITION DATABASE ARGUMENTS)
  (CL:LET*
   ((QUERYID STELLA::NULL-STRING) (OUTPUTARGS NIL) (PARAMETERS NULL)
    (RELATION (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION))) (PARAMS (NEW-OUTPUT-STRING-STREAM)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUERYID))
   (CL:MULTIPLE-VALUE-SETQ (QUERYID OUTPUTARGS PARAMETERS) (NORMALIZE-FETCH-QUERY-ARGUMENTS PROPOSITION ARGUMENTS))
   (CL:LET* ((KEY NULL) (VALUE NULL) (ITER-000 (%PROPERTY-LIST.THE-PLIST PARAMETERS)) (I NULL-INTEGER) (ITER-001 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO (CL:SETQ KEY (%%VALUE ITER-000))
     (CL:SETQ VALUE (%%VALUE (%%REST ITER-000))) (CL:SETQ I ITER-001)
     (CL:WHEN (CL:OR (CL:EQ KEY NULL) (CL:EQ VALUE NULL)) (CL:RETURN-FROM HELP-MEMOIZE-FETCH-EDB-QUERY NULL))
     (CL:WHEN (CL:> I 1) (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM PARAMS) "&"))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM PARAMS) (UNWRAP-STRING KEY))
     (CL:SETQ VALUE (ARGUMENT-BOUND-TO VALUE))
     (CL:WHEN (CL:EQ VALUE NULL) (CL:RETURN-FROM HELP-MEMOIZE-FETCH-EDB-QUERY NULL))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM PARAMS) "=" (COERCE-POWERLOOM-OBJECT-TO-STRING VALUE NULL))
     (CL:SETQ ITER-000 (%%REST (%%REST ITER-000))) (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:LET* ((TEMP-000 (UNWRAP-STRING (ACCESS-BINARY-VALUE DATABASE SGT-FETCH-INTERFACE-RDBMS-HOST))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEMP-000))
    (CL:LET* ((TEMP-001 (UNWRAP-INTEGER (ACCESS-BINARY-VALUE DATABASE SGT-FETCH-INTERFACE-RDBMS-PORT))))
     (CL:DECLARE (CL:TYPE CL:FIXNUM TEMP-001))
     (CL:LET* ((TEMP-002 (UNWRAP-STRING (ACCESS-BINARY-VALUE DATABASE SGT-FETCH-INTERFACE-RDBMS-TASK-ID))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEMP-002))
      (CL:LET* ((TEMP-003 (UNWRAP-STRING (ACCESS-BINARY-VALUE DATABASE SGT-FETCH-INTERFACE-RDBMS-SUBTASK-ID))))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEMP-003))
       (CL:LET* ((TEMP-004 (UNWRAP-STRING (ACCESS-BINARY-VALUE DATABASE SGT-FETCH-INTERFACE-RDBMS-DB-NAME))))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEMP-004))
        (CL:LET*
         ((VALUE-000
           (ALLOCATE-ITERATOR
            (PARSE-FETCH-XML-ANSWER
             (RUN-FETCH-QUERY (CL:IF (CL:NOT (CL:EQ TEMP-000 STELLA::NULL-STRING)) TEMP-000 "pegasus2.isi.edu")
              (CL:IF (CL:NOT (CL:= TEMP-001 NULL-INTEGER)) TEMP-001 8080) QUERYID
              (CL:IF (CL:NOT (CL:EQ TEMP-002 STELLA::NULL-STRING)) TEMP-002 "TASK")
              (CL:IF (CL:NOT (CL:EQ TEMP-003 STELLA::NULL-STRING)) TEMP-003 "SUBTASK")
              (CL:IF (CL:NOT (CL:EQ TEMP-004 STELLA::NULL-STRING)) TEMP-004 "EELD-DATABASE")
              (THE-STRING-READER PARAMS))
             RELATION OUTPUTARGS))))
         VALUE-000))))))))

;;; (DEFUN (FETCH-EDB-QUERY (ITERATOR OF CONS)) ...)

(CL:DEFUN FETCH-EDB-QUERY (PROPOSITION DATABASE ARGUMENTS)
  (CHECK-FOR-EXTERNAL-DB-UPDATES PROPOSITION DATABASE)
  (CL:LET* ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000 (%SURROGATE.SURROGATE-VALUE SGT-FETCH-INTERFACE-RDBMS-F-FETCH-EDB-QUERY-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE SGT-FETCH-INTERFACE-RDBMS-F-FETCH-EDB-QUERY-MEMO-TABLE-000
      "(:MAX-VALUES 10000 :TIMESTAMPS (:META-KB-UPDATE :EXTERNAL-DB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000 (%SURROGATE.SURROGATE-VALUE SGT-FETCH-INTERFACE-RDBMS-F-FETCH-EDB-QUERY-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 (GET-QUERY-PATTERN-MEMOIZATION-KEY PROPOSITION) *CONTEXT*
      (CL:IF *REVERSEPOLARITY?* TRUE-WRAPPER FALSE-WRAPPER) MEMOIZED-NULL-VALUE 6))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE) (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (NEW-MEMOIZABLE-ITERATOR (HELP-MEMOIZE-FETCH-EDB-QUERY PROPOSITION DATABASE ARGUMENTS)))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 (CLONE-MEMOIZED-ITERATOR MEMOIZED-VALUE-000))) VALUE-000)))

;;; (DEFUN (PARSE-FETCH-XML-ANSWER (CONS OF CONS)) ...)

(CL:DEFUN PARSE-FETCH-XML-ANSWER (XMLANSWER RELATION OUTPUTCOLUMNS)
  (CL:LET* ((TUPLES NIL))
   (CL:WHEN
    (CL:NOT
     (CL:AND (ISA? (%%VALUE XMLANSWER) SGT-FETCH-INTERFACE-STELLA-XML-ELEMENT)
      (CL:AND (STRING-EQL? (%XML-ELEMENT.NAME (%%VALUE XMLANSWER)) "PlanExecution")
       (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI (%%VALUE XMLANSWER)) STELLA::NULL-STRING))))
    (CL:WARN "Fetch-EDB-query Error: Didn't find a Fetch Answer in `~A'" XMLANSWER)
    (CL:RETURN-FROM PARSE-FETCH-XML-ANSWER NIL))
   (CL:LET* ((ANSWER NULL) (ITER-000 (%%REST (%%REST XMLANSWER))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO (CL:SETQ ANSWER (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (ISA? ANSWER SGT-FETCH-INTERFACE-STELLA-CONS)
       (ISA? (%%VALUE ANSWER) SGT-FETCH-INTERFACE-STELLA-XML-ELEMENT))
      (CL:LET* ((ITEM-000 (%%VALUE ANSWER)))
       (CL:COND
        ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "OBJECT")
          (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000) STELLA::NULL-STRING))
         (CL:SETQ TUPLES (CONS (PARSE-ONE-FETCH-XML-OBJECT (%%REST (%%REST ANSWER)) RELATION OUTPUTCOLUMNS) TUPLES)))
        ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "Error")
          (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000) STELLA::NULL-STRING))
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
           (UNWRAP-STRING (%%VALUE (%%REST (%%REST ANSWER)))) "'")
          (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
        ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "ERROR")
          (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000) STELLA::NULL-STRING))
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
           (UNWRAP-STRING (%%VALUE (%%REST (%%REST ANSWER)))) "'")
          (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (REVERSE TUPLES)))

;;; (DEFUN (PARSE-ONE-FETCH-XML-OBJECT CONS) ...)

(CL:DEFUN PARSE-ONE-FETCH-XML-OBJECT (OBJECT RELATION OUTPUTCOLUMNS)
  (CL:LET* ((TUPLE NIL))
   (CL:LET* ((COLUMN NULL) (ITER-000 OUTPUTCOLUMNS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO (CL:SETQ COLUMN (%%VALUE ITER-000))
     (CL:LET* ((ITEM NULL) (ITER-001 OBJECT))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO (CL:SETQ ITEM (%%VALUE ITER-001))
       (CL:WHEN (EQL-TO-STRING? COLUMN (%XML-ELEMENT.NAME (%%VALUE ITEM)))
        (CL:SETQ TUPLE (CONS (%%VALUE (%%REST (%%REST ITEM))) TUPLE))
        (CL:WHEN (CL:NOT (CL:EQ (%%REST (%%REST (%%REST ITEM))) NIL)) (CL:WARN "Extra elements found in `~A'" ITEM)))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ TUPLE (REVERSE TUPLE)) (COERCE-VALUES TUPLE (GET-RELATION-TABLE-INFO RELATION))))

;;; (DEFUN START-FETCH-EDB-GATEWAY ...)

(CL:DEFUN START-FETCH-EDB-GATEWAY (PORT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM PORT))
  #+MCL
  (CL:CHECK-TYPE PORT CL:FIXNUM)
  (CL:LET*
   ((LISPFORMS "#+:aserve
    (CL:progn
      (CL:defun handle-fetch-query (request entity)
        (net.aserve:with-http-response (request entity)
          (net.aserve:with-http-body (request entity)
            (CL:case (net.aserve:request-method request)
              (:get
               (CL:let ((query (net.aserve:request-query request
                                                         :uri CL:t
                                                         :post CL:nil))
                        (keys (stella::new-key-value-list)))
                 (CL:loop for (key . value) in query
                     do (stella::insert-at
                         keys
                         (stella::wrap-string (CL:string key))
                         (stella::wrap-string value)))
                 (evaluate-fetch-query
                  keys (net.aserve:request-reply-stream request))))
              (CL:t
               (CL:format (net.aserve:request-reply-stream request) 
                          \"Error occurred:<BR>~%Unhandled request method ~S\"
                          (net.aserve:request-method request)))))))
      (CL:defun start-fetch-EDB-servlet (port)
        (CL:compile 'handle-fetch-query)
        (net.aserve:publish :path \"/ploom/fetch-EDB-query\"
                            :content-type \"text/html\"
                            :function 'handle-fetch-query)
        (net.aserve:start :port port)))
    #-:aserve ()"))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LISPFORMS)) #+:allegro
       (CL:progn
         (CL:require :aserve)
         (CL:pushnew :aserve CL:*features*)
         (CL:eval (CL:read-from-string lispForms))
         (start-fetch-EDB-servlet port))))

;;; (DEFUN EVALUATE-FETCH-QUERY ...)

(CL:DEFUN EVALUATE-FETCH-QUERY (KEYS OUT)
  (CL:HANDLER-CASE
   (CL:LET* ((TEMP-000 (GET-STELLA-MODULE "EELD-EDB" CL:NIL)))
    (CL:LET* ((MDL-000 (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 *MODULE*)) (CXT-000 MDL-000))
     (CL:WHEN (CL:EQ MDL-000 NULL) (CL:SETQ MDL-000 *MODULE*) (CL:SETQ CXT-000 *CONTEXT*))
     (CL:LET* ((*MODULE* MDL-000) (*CONTEXT* CXT-000)) (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (WITH-PROCESS-LOCK *POWERLOOM-LOCK*
       (CL:LET*
        ((SECONDARYDBNAME (LOOKUP KEYS (WRAP-STRING "sdatabase")))
         (FETCHDB (%GET (COPY-CONS-TREE (WRAP-STRING "fetch-edb")) NIL)) (TASKID (LOOKUP KEYS (WRAP-STRING "task")))
         (SUBTASKID (LOOKUP KEYS (WRAP-STRING "subtask"))) (COMMAND (LOOKUP KEYS (WRAP-STRING "command")))
         (RESULT NULL))
        (CL:LET* ((SELF-000 (NEW-OUTPUT-STREAM))) (CL:SETF (%OUTPUT-STREAM.NATIVE-STREAM SELF-000) OUT)
         (CL:LET* ((WRAPPEDOUT SELF-000))
          (CL:WHEN (CL:NOT (CL:EQ FETCHDB NULL))
           (CL:WHEN (CL:NOT (CL:EQ SECONDARYDBNAME NULL))
            (PLI::ASSERT-NARY-PROPOSITION
             (CONS (GET-RELATION SGT-FETCH-INTERFACE-RDBMS-DB-NAME) (CONS FETCHDB (CONS SECONDARYDBNAME NIL))) NULL
             NULL))
           (CL:WHEN (CL:NOT (CL:EQ TASKID NULL))
            (PLI::ASSERT-NARY-PROPOSITION
             (CONS (GET-RELATION SGT-FETCH-INTERFACE-RDBMS-TASK-ID) (CONS FETCHDB (CONS TASKID NIL))) NULL NULL))
           (CL:WHEN (CL:NOT (CL:EQ SUBTASKID NULL))
            (PLI::ASSERT-NARY-PROPOSITION
             (CONS (GET-RELATION SGT-FETCH-INTERFACE-RDBMS-SUBTASK-ID) (CONS FETCHDB (CONS SUBTASKID NIL))) NULL
             NULL)))
          (CL:SETQ RESULT
           (EVALUATE-LOGIC-COMMAND (READ-S-EXPRESSION-FROM-STRING (%STRING-WRAPPER.WRAPPER-VALUE COMMAND)) CL:T))
          (CL:COND
           ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE RESULT) SGT-FETCH-INTERFACE-LOGIC-QUERY-ITERATOR)
            (CL:PROGN
             (CL:LET* ((SOLUTION NULL) (ITER-000 (ALLOCATE-ITERATOR (%QUERY-ITERATOR.SOLUTIONS RESULT))))
              (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ SOLUTION (%DICTIONARY-ITERATOR.VALUE ITER-000))
               (CL:LET*
                ((ELT NULL) (VECTOR-000 (%QUERY-SOLUTION.BINDINGS SOLUTION)) (INDEX-000 0)
                 (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-001 0))
                (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-001))
                (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
                 (CL:SETQ ELT (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000)) INDEX-000))
                 (CL:SETQ I ITER-001) (CL:WHEN (CL:> I 0) (%%PRINT-STREAM OUT " ")) (PRINT-LOGICAL-FORM ELT WRAPPEDOUT)
                 (CL:SETQ INDEX-000 (CL:1+ INDEX-000)) (CL:SETQ ITER-001 (CL:1+ ITER-001))))
               (%%PRINT-STREAM OUT "<br>")))))
           (CL:T (WRITE-HTML-QUOTING-SPECIAL-CHARACTERS OUT (STRINGIFY RESULT)))))))))))
   (CL:CONDITION (E) (%%PRINT-STREAM OUT "ERROR: " (EXCEPTION-MESSAGE E)))))

;;; (DEFUN (BUILD-ONE-TABLE-ASSERTION CONS) ...)

(CL:DEFUN BUILD-ONE-TABLE-ASSERTION (TABLE-RELATION TUPLE DB-MODULE)
  (CL:LET* ((ASSERTION NIL) (COLNO -1)) (CL:DECLARE (CL:TYPE CL:FIXNUM COLNO))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (ARITY TABLE-RELATION))
     (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO (CL:SETQ I ITER-000)
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS NULL-STRING-WRAPPER NIL))
       (CL:IF (CL:EQ ASSERTION NIL) (CL:SETQ ASSERTION COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST ASSERTION COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS NULL-STRING-WRAPPER NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET* ((ITEM NULL) (ITER-001 TUPLE))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO (CL:SETQ ITEM (%%VALUE ITER-001))
     (CL:SETQ COLNO (GET-TABLE-COLUMN-INDEX TABLE-RELATION (%XML-ELEMENT.NAME (%%VALUE ITEM)) DB-MODULE))
     (CL:IF (CL:< COLNO 0) (CL:WARN "Couldn't find column number for `~A' on relation `~A'" ITEM TABLE-RELATION)
      (NTH-SETTER ASSERTION (%%VALUE (%%REST (%%REST ITEM))) COLNO))
     (CL:WHEN (CL:NOT (CL:EQ (%%REST (%%REST (%%REST ITEM))) NIL)) (CL:WARN "Extra elements found in `~A'" ITEM))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET* ((ITEM NULL) (ITER-002 (%%REST ASSERTION)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO (CL:SETQ ITEM (%%VALUE ITER-002))
     (CL:WHEN (CL:EQ (UNWRAP-STRING ITEM) STELLA::NULL-STRING)
      (CL:WARN "Some table relation values not set: `~A'" ASSERTION) (CL:RETURN))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (CL:SETF (%%REST ASSERTION) (COERCE-VALUES (%%REST ASSERTION) (GET-RELATION-TABLE-INFO TABLE-RELATION)))
   (NTH-SETTER ASSERTION TABLE-RELATION 0) ASSERTION))

;;; (DEFUN (GENERATE-TABLE-ASSERTIONS (CONS OF CONS)) ...)

(CL:DEFUN GENERATE-TABLE-ASSERTIONS (TABLE-NAME XML-ANSWER MODULE DB-MODULE)
  "Takes a Stella-parsed, XML-encoded `xml-answer' from Fetch based on
the database table `table-name' and uses it to generate an assertion
for an appropriate relation for inclusion in `module'.  The database
meta information is found in `db-module'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TABLE-NAME))
  #+MCL
  (CL:CHECK-TYPE TABLE-NAME CL:SIMPLE-STRING)
  (CL:LET* ((TABLE-RELATION (GET-TABLE-RELATION TABLE-NAME DB-MODULE)) (ASSERTIONS NIL))
   (CL:WHEN
    (CL:NOT
     (CL:AND (ISA? (%%VALUE XML-ANSWER) SGT-FETCH-INTERFACE-STELLA-XML-ELEMENT)
      (CL:AND (STRING-EQL? (%XML-ELEMENT.NAME (%%VALUE XML-ANSWER)) "PlanExecution")
       (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI (%%VALUE XML-ANSWER)) STELLA::NULL-STRING))))
    (CL:WARN "Didn't find a Fetch Answer in `~A'" XML-ANSWER) (CL:RETURN-FROM GENERATE-TABLE-ASSERTIONS NIL))
   (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*)) (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:LET* ((ANSWER NULL) (ITER-000 (%%REST (%%REST XML-ANSWER))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO (CL:SETQ ANSWER (%%VALUE ITER-000))
      (CL:WHEN
       (CL:AND (ISA? ANSWER SGT-FETCH-INTERFACE-STELLA-CONS)
        (ISA? (%%VALUE ANSWER) SGT-FETCH-INTERFACE-STELLA-XML-ELEMENT))
       (CL:LET* ((ITEM-000 (%%VALUE ANSWER)))
        (CL:COND
         ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "OBJECT")
           (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000) STELLA::NULL-STRING))
          (CL:SETQ ASSERTIONS
           (CONS (BUILD-ONE-TABLE-ASSERTION TABLE-RELATION (%%REST (%%REST ANSWER)) DB-MODULE) ASSERTIONS)))
         ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "Error")
           (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000) STELLA::NULL-STRING))
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
            (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST (%%REST ANSWER)))) "'")
           (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
         ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "ERROR")
           (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000) STELLA::NULL-STRING))
          (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
            (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST (%%REST ANSWER)))) "'")
           (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))
   ASSERTIONS))

;;; (DEFUN (LOOKUP-STRING-VALUE STRING) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:T) CL:SIMPLE-STRING) LOOKUP-STRING-VALUE))
(CL:DEFUN LOOKUP-STRING-VALUE (RELATION INSTANCE MOD)
  (CL:LET*
   ((ITER
     (PLI::RETRIEVE
      (LIST* (WRAP-INTEGER 1) (CONS (OBJECT-NAME RELATION) (CONS INSTANCE (CONS SYM-FETCH-INTERFACE-LOGIC-?X NIL)))
       NIL)
      MOD NULL)))
   (CL:IF (NEXT? ITER) (%STRING-WRAPPER.WRAPPER-VALUE (PLI::%PL-ITERATOR.VALUE ITER)) STELLA::NULL-STRING)))

;;; (DEFUN (FETCH-QUERY-ASSERTIONS (CONS OF CONS)) ...)

(CL:DEFUN FETCH-QUERY-ASSERTIONS (HOST PORT FETCH-QUERY TASK-ID SUBTASK-ID DATABASE PARAMETER-VALUE TARGET-MODULE DB-MODULE)
  "Runs a `fetch-query' using `task-id'; `subtask-id',`database'
and specifying a single additional `parameter-value'.  The connection
is made to a remote http query server running on `host' port number `port'.
Returns a set of assertions for `target-module' using the information in `db-module'
to find the appropriate relations."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST TASK-ID SUBTASK-ID DATABASE PARAMETER-VALUE) (CL:TYPE CL:FIXNUM PORT))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PORT CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE TASK-ID CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SUBTASK-ID CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE DATABASE CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PARAMETER-VALUE CL:SIMPLE-STRING)
  (CL:LET*
   ((DB-TABLE (LOOKUP-STRING-VALUE (PLI::GET-RELATION "QUERY-TABLE-NAME" DB-MODULE NULL) FETCH-QUERY DB-MODULE))
    (PARAMETER-NAME
     (LOOKUP-STRING-VALUE (PLI::GET-RELATION "QUERY-PARAMETER-NAME" DB-MODULE NULL) FETCH-QUERY DB-MODULE))
    (FETCH-ANSWER
     (RUN-FETCH-QUERY HOST PORT (%SYMBOL.SYMBOL-NAME (OBJECT-NAME FETCH-QUERY)) TASK-ID SUBTASK-ID DATABASE
      (CONCATENATE PARAMETER-NAME "=" PARAMETER-VALUE))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DB-TABLE PARAMETER-NAME))
   (GENERATE-TABLE-ASSERTIONS DB-TABLE FETCH-ANSWER TARGET-MODULE DB-MODULE)))

(CL:DEFUN STARTUP-FETCH-INTERFACE ()
  (CL:LET* ((*MODULE* (GET-STELLA-MODULE "/RDBMS" (> *STARTUP-TIME-PHASE* 1))) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (CL:SETQ SGT-FETCH-INTERFACE-RDBMS-RUN-FETCH-QUERY (INTERN-RIGID-SYMBOL-WRT-MODULE "RUN-FETCH-QUERY" NULL 1))
    (CL:SETQ SGT-FETCH-INTERFACE-STELLA-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-STELLA-MODULE "/STELLA" CL:T) 1))
    (CL:SETQ SGT-FETCH-INTERFACE-STELLA-XML-ELEMENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-ELEMENT" (GET-STELLA-MODULE "/STELLA" CL:T) 1))
    (CL:SETQ KWD-FETCH-INTERFACE-ERROR (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
    (CL:SETQ SGT-FETCH-INTERFACE-RDBMS-HOST (INTERN-RIGID-SYMBOL-WRT-MODULE "HOST" NULL 1))
    (CL:SETQ SGT-FETCH-INTERFACE-RDBMS-PORT (INTERN-RIGID-SYMBOL-WRT-MODULE "PORT" NULL 1))
    (CL:SETQ SGT-FETCH-INTERFACE-RDBMS-TASK-ID (INTERN-RIGID-SYMBOL-WRT-MODULE "TASK-ID" NULL 1))
    (CL:SETQ SGT-FETCH-INTERFACE-RDBMS-SUBTASK-ID (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTASK-ID" NULL 1))
    (CL:SETQ SGT-FETCH-INTERFACE-RDBMS-DB-NAME (INTERN-RIGID-SYMBOL-WRT-MODULE "DB-NAME" NULL 1))
    (CL:SETQ SGT-FETCH-INTERFACE-RDBMS-F-FETCH-EDB-QUERY-MEMO-TABLE-000
     (INTERN-RIGID-SYMBOL-WRT-MODULE "F-FETCH-EDB-QUERY-MEMO-TABLE-000" NULL 1))
    (CL:SETQ SGT-FETCH-INTERFACE-LOGIC-QUERY-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-ITERATOR" (GET-STELLA-MODULE "/LOGIC" CL:T) 1))
    (CL:SETQ SYM-FETCH-INTERFACE-LOGIC-?X (INTERN-RIGID-SYMBOL-WRT-MODULE "?X" (GET-STELLA-MODULE "/LOGIC" CL:T) 0))
    (CL:SETQ SYM-FETCH-INTERFACE-RDBMS-STARTUP-FETCH-INTERFACE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-FETCH-INTERFACE" NULL 0))
    (CL:SETQ SYM-FETCH-INTERFACE-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" (GET-STELLA-MODULE "/STELLA" CL:T) 0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "RUN-FETCH-QUERY"
     "(DEFUN (RUN-FETCH-QUERY OBJECT) ((HOST STRING) (PORT INTEGER) (QUERY-ID STRING) (TASK-ID STRING) (SUBTASK-ID STRING) (DATABASE STRING) (PARAMETERS STRING)) :DOCUMENTATION \"Runs a Fetch query specifying the parameters given.
Returns an object representing the returned XML-encoded answer from
the server.\" :PUBLIC? TRUE)" (CL:FUNCTION RUN-FETCH-QUERY) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-FETCH-QUERY-ARGUMENTS"
     "(DEFUN (NORMALIZE-FETCH-QUERY-ARGUMENTS STRING (CONS OF STRING-WRAPPER) PROPERTY-LIST) ((PROPOSITION PROPOSITION) (ARGUMENTS OBJECT)))"
     (CL:FUNCTION NORMALIZE-FETCH-QUERY-ARGUMENTS) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-MEMOIZE-FETCH-EDB-QUERY"
     "(DEFUN (HELP-MEMOIZE-FETCH-EDB-QUERY (ITERATOR OF CONS)) ((PROPOSITION PROPOSITION) (DATABASE LOGIC-OBJECT) (ARGUMENTS OBJECT)))"
     (CL:FUNCTION HELP-MEMOIZE-FETCH-EDB-QUERY) NULL)
    (DEFINE-FUNCTION-OBJECT "FETCH-EDB-QUERY"
     "(DEFUN (FETCH-EDB-QUERY (ITERATOR OF CONS)) ((PROPOSITION PROPOSITION) (DATABASE LOGIC-OBJECT) (ARGUMENTS OBJECT)))"
     (CL:FUNCTION FETCH-EDB-QUERY) NULL)
    (DEFINE-FUNCTION-OBJECT "PARSE-FETCH-XML-ANSWER"
     "(DEFUN (PARSE-FETCH-XML-ANSWER (CONS OF CONS)) ((XMLANSWER CONS) (RELATION NAMED-DESCRIPTION) (OUTPUTCOLUMNS (CONS OF STRING-WRAPPER))))"
     (CL:FUNCTION PARSE-FETCH-XML-ANSWER) NULL)
    (DEFINE-FUNCTION-OBJECT "PARSE-ONE-FETCH-XML-OBJECT"
     "(DEFUN (PARSE-ONE-FETCH-XML-OBJECT CONS) ((OBJECT CONS) (RELATION NAMED-DESCRIPTION) (OUTPUTCOLUMNS (CONS OF STRING-WRAPPER))))"
     (CL:FUNCTION PARSE-ONE-FETCH-XML-OBJECT) NULL)
    (DEFINE-FUNCTION-OBJECT "START-FETCH-EDB-GATEWAY" "(DEFUN START-FETCH-EDB-GATEWAY ((PORT INTEGER)))"
     (CL:FUNCTION START-FETCH-EDB-GATEWAY) NULL)
    (DEFINE-FUNCTION-OBJECT "EVALUATE-FETCH-QUERY"
     "(DEFUN EVALUATE-FETCH-QUERY ((KEYS KEY-VALUE-LIST) (OUT NATIVE-OUTPUT-STREAM)))"
     (CL:FUNCTION EVALUATE-FETCH-QUERY) NULL)
    (DEFINE-FUNCTION-OBJECT "BUILD-ONE-TABLE-ASSERTION"
     "(DEFUN (BUILD-ONE-TABLE-ASSERTION CONS) ((TABLE-RELATION NAMED-DESCRIPTION) (TUPLE CONS) (DB-MODULE MODULE)))"
     (CL:FUNCTION BUILD-ONE-TABLE-ASSERTION) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-TABLE-ASSERTIONS"
     "(DEFUN (GENERATE-TABLE-ASSERTIONS (CONS OF CONS)) ((TABLE-NAME STRING) (XML-ANSWER CONS) (MODULE MODULE) (DB-MODULE MODULE)) :DOCUMENTATION \"Takes a Stella-parsed, XML-encoded `xml-answer' from Fetch based on
the database table `table-name' and uses it to generate an assertion
for an appropriate relation for inclusion in `module'.  The database
meta information is found in `db-module'.\")" (CL:FUNCTION GENERATE-TABLE-ASSERTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-STRING-VALUE"
     "(DEFUN (LOOKUP-STRING-VALUE STRING) ((RELATION NAMED-DESCRIPTION) (INSTANCE LOGIC-OBJECT) (MOD MODULE)))"
     (CL:FUNCTION LOOKUP-STRING-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "FETCH-QUERY-ASSERTIONS"
     "(DEFUN (FETCH-QUERY-ASSERTIONS (CONS OF CONS)) ((HOST STRING) (PORT INTEGER) (FETCH-QUERY LOGIC-OBJECT) (TASK-ID STRING) (SUBTASK-ID STRING) (DATABASE STRING) (PARAMETER-VALUE STRING) (TARGET-MODULE MODULE) (DB-MODULE MODULE)) :PUBLIC? TRUE :DOCUMENTATION \"Runs a `fetch-query' using `task-id'; `subtask-id',`database'
and specifying a single additional `parameter-value'.  The connection
is made to a remote http query server running on `host' port number `port'.
Returns a set of assertions for `target-module' using the information in `db-module'
to find the appropriate relations.\")" (CL:FUNCTION FETCH-QUERY-ASSERTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-FETCH-INTERFACE" "(DEFUN STARTUP-FETCH-INTERFACE () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-FETCH-INTERFACE) NULL)
    (CL:LET* ((FUNCTION (LOOKUP-FUNCTION SYM-FETCH-INTERFACE-RDBMS-STARTUP-FETCH-INTERFACE)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION) SYM-FETCH-INTERFACE-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupFetchInterface") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS) (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9) (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "RDBMS"))))))
