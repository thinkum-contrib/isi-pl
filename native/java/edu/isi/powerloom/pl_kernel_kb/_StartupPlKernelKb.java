//  -*- Mode: Java -*-
//
// _StartupPlKernelKb.java

/*
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2006      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
*/

package edu.isi.powerloom.pl_kernel_kb;

import edu.isi.stella.javalib.Native;
import edu.isi.stella.javalib.StellaSpecialVariable;
import edu.isi.powerloom.logic.*;
import edu.isi.stella.*;

public class _StartupPlKernelKb {
  public static void startupPlKernelKb() {
    { Object old$Module$000 = Stella.$MODULE$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Stella.$MODULE$, Stella.getStellaModule("/PL-KERNEL-KB", Stella.$STARTUP_TIME_PHASE$ > 1));
        Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
        if (Stella.currentStartupTimePhaseP(2)) {
          PlKernelKb.SYM_PL_KERNEL_KB_STARTUP_PL_KERNEL_KB = ((Symbol)(Stella.internRigidSymbolWrtModule("STARTUP-PL-KERNEL-KB", null, 0)));
        }
        if (Stella.currentStartupTimePhaseP(6)) {
          Stella.finalizeClasses();
        }
        if (Stella.currentStartupTimePhaseP(7)) {
          Stella.defineFunctionObject("INITIALIZE-KERNEL-KB", "(DEFUN INITIALIZE-KERNEL-KB () :DOCUMENTATION \"Bootstrap the PowerLoom built-in kernel KB.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.powerloom.pl_kernel_kb.PlKernelKb", "initializeKernelKb", new java.lang.Class [] {}), null);
          Stella.defineFunctionObject("STARTUP-PL-KERNEL-KB", "(DEFUN STARTUP-PL-KERNEL-KB () :PUBLIC? TRUE)", Native.find_java_method("edu.isi.powerloom.pl_kernel_kb._StartupPlKernelKb", "startupPlKernelKb", new java.lang.Class [] {}), null);
          { MethodSlot function = Symbol.lookupFunction(PlKernelKb.SYM_PL_KERNEL_KB_STARTUP_PL_KERNEL_KB);

            KeyValueList.setDynamicSlotValue(function.dynamicSlots, Logic.SYM_STELLA_METHOD_STARTUP_CLASSNAME, StringWrapper.wrapString("_StartupPlKernelKb"), Stella.NULL_STRING_WRAPPER);
          }
        }
        if (Stella.currentStartupTimePhaseP(8)) {
          Stella.finalizeSlots();
          Stella.cleanupUnfinalizedClasses();
        }
        if (Stella.currentStartupTimePhaseP(9)) {
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL *PL-KERNEL-KB-DEFINITIONS* CONS NULL)");
          PlKernelKb.$PL_KERNEL_KB_DEFINITIONS$ = Stella.getQuotedTree("(((DEFCONCEPT CONCEPT (?X RELATION) :DOCUMENTATION \"The class of reified unary relations.  The Powerloom\nnotion of `concept' corresponds to the object-oriented notion of `class'.\nFrom a logic standpoint, the notion of a concept is hard to distinguish\nfrom the notion of `unary relation'.  The conceptual distinction is\nbest illustrated in the domain of linguistics, where concepts are\nidentified with collective nouns while unary relations are identified\nwith adjectives.  For example, `Rock' is a concept, while `rocky' is a\nunary relation.\" :AXIOMS (AND (SYNONYM CONCEPT CLASS) (CLOSED CONCEPT))) (DEFCONCEPT RELATION (?X SET) :DOCUMENTATION \"The class of relations.  This includes all concepts and\nall functions.\" :AXIOMS (CLOSED RELATION)) (DEFCONCEPT FUNCTION (?R RELATION) :DOCUMENTATION \"A relation is a function if its last argument\nis a function of its first n-1 arguments, i.e., if it is a single-valued\nrelation.  Functions explicitly declared as such differ from relations\nin that they may appear syntactically as a term applied to n-1 arguments.\nFor example, to express the sentence \\\"two plus two equals four\\\", because\n`+' is a function we can write `(= (+ 2 2) 4)'.  The same sentence written\nin relational syntax would look like `(+ 2 2 4)'.  If a relation is\nintroduced using the `defrelation' syntax and also declared to be\nsingle-valued, the functional syntax does not apply; only the explicit\nuse of `deffunction' sanctions the use of that syntax.\" :AXIOMS (CLOSED FUNCTION)) (DEFCONCEPT AGGREGATE (?A) :DOCUMENTATION \"?a is an aggregate\") (DEFCONCEPT COLLECTION (?C AGGREGATE) :DOCUMENTATION \"The class of all collections.  This includes all sets,\nlists, concepts, and relations.\" :AXIOMS (ABSTRACT COLLECTION)) (DEFCONCEPT DUPLICATE-FREE-COLLECTION (?C COLLECTION) :DOCUMENTATION \"?c is free of duplicates\" :=>> (DUPLICATE-FREE ?C)) (DEFCONCEPT SET (?S DUPLICATE-FREE-COLLECTION) :DOCUMENTATION \"This class denotes the mathematical notion of a 'set';\na collection that has no duplicates.\") (DEFCONCEPT NUMERIC-SET (?S COLLECTION) :DOCUMENTATION \"?s is a set of numbers\" :AXIOMS (ABSTRACT NUMERIC-SET)) (DEFCONCEPT LIST (?L COLLECTION) :DOCUMENTATION \"A list is an ordered collection of elements.  The range\nof the function `listof' consists of elements of type `List'.\" :=>> (ORDERED ?L)) (DEFCONCEPT GROUP (?C DUPLICATE-FREE-COLLECTION) :DOCUMENTATION \"?c is a group\") (DEFCONCEPT STUFF (?S AGGREGATE) :DOCUMENTATION \"?s is stuff\") (DEFCONCEPT SCALAR (?X) :DOCUMENTATION \"The class of scalar quantities.\") (ASSERT (SUBSET-OF NUMBER SCALAR)) (DEFCONCEPT SCALAR-INTERVAL (?X SCALAR) :DOCUMENTATION \"An interval of scalar quantities. \") (ASSERT (SUBSET-OF INTEGER-INTERVAL SCALAR-INTERVAL)) (DEFRELATION PHRASE (?R (?S STRING)) :DOCUMENTATION \"A phrase is a variablized sentence, a template, that\nis used to express individual axiomatic facts as natural language\nsentences.  By convention, a phrase contains one or more occurrences\nof each variable in a relation or concept definition, it does not\nbegin with a capital letter, and it has no concluding period.\nSystematic attachment of phrases to relations can be leveraged by\ntools that generate natural language paraphrases of logic sentences.\" :PHRASE \"?r has phrase ?s\") (DEFRELATION LEXEME (?R (?S STRING)) :DOCUMENTATION \"?s is a lexeme for the relation or individual ?r.\nA relation or individual ?r can have zero or more lexemes, words that are\nnatural langage equivalents of a logical constant.  The same lexeme may be\nattached to more than one constant.\") (DEFRELATION COMMENT (?X (?S STRING)) :DOCUMENTATION \"?s is a comment attached to ?x.  Comments are\na generalization of other annotations such as `documentation' and\n`issue' strings.\") (DEFRELATION DOCUMENTATION (?X (?S STRING)) :DOCUMENTATION \"?s is a documentation string attached to ?x.  Some\nof the PowerLoom text processing tools look for documentation strings and \nimport them into documents.\" :=> (COMMENT ?X ?S)) (DEFRELATION ISSUE (?X (?S STRING)) :DOCUMENTATION \"?s is an issue attached to ?x.  An issue string \nnormally comments on a topic that has not been resolved to everyone's\nsatisfaction.\" :=> (COMMENT ?X ?S)) (DEFRELATION EXAMPLE ((?R RELATION) ?E) :DOCUMENTATION \"?e is an example of (the use of) ?r.\") (DEFRELATION IMAGE-URL (?X (?URL STRING)) :DOCUMENTATION \"?url is a URL pointing to an image illustrating ?x.\nThe Ontosaurus browser looks for `image-url' values attached to\nobjects it is presenting, and displays them prominently, thereby spiffing\nup its displays.\") (DEFRELATION RELATION-SPECIALIST ((?R RELATION) (?SP COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names a 'specialist' (a function) that evaluates an (atomic) relation\nproposition during query processing.  This defines an extensible\nmeans for computing with the control stack.  The function is passed\na CONTROL-FRAME that contains the proposition, and returns a keyword\n:FINAL-SUCCESS, :CONTINUING-SUCCESS, :FAILURE, or :TERMINAL-FAILURE\nthat controls the result of the computation.\" :AXIOMS (SINGLE-VALUED RELATION-SPECIALIST)) (DEFRELATION RELATION-EVALUATOR ((?R RELATION) (?EV COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names an 'evaluator' (a function) that evaluates an (atomic) relation\nproposition during constraint propagation.  This defines an extensible\nmeans for computing using auxiliary data structures.  The function is passed\na proposition for evaluation which might update the proposition, generate\nadditional assertions or trigger further evaluations.  Evaluators have to\ncheck the truth-value of the passed-in proposition and perform their actions\naccordingly.  An evaluated proposition might be true, false or even unknown\nin case the propositon was just newly constructed.\" :AXIOMS (SINGLE-VALUED RELATION-EVALUATOR)) (DEFRELATION RELATION-COMPUTATION ((?R RELATION) (?COMPUTATION COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names a 'computation' (a function) that evaluates an (atomic) relation\nproposition during query processing.  The function is passed a proposition\nfor evaluation for which all arguments are bound.  The function\nreturns a BOOLEAN if it represents a predicate, or some sort of value\nif it is a function.\" :=>> (RELATION-SPECIALIST ?R COMPUTATION-SPECIALIST) :AXIOMS (SINGLE-VALUED RELATION-COMPUTATION)) (DEFRELATION RELATION-CONSTRAINT ((?R RELATION) (?COMPUTATION COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names a 'computation' (a function) that evaluates an (atomic) relation\nproposition during query processing.  The function is passed a proposition\nfor evaluation for which at most one argument is unbound.  The function\nreturns a BOOLEAN if it represents a predicate, or some sort of value\nif it is a function.  If all arguments are bound the function computes whether\nthe constraint holds.  If all but one argument is bound and the unbound\nargument is a pattern variable then the missing value is computed.\" :=>> (RELATION-SPECIALIST ?R CONSTRAINT-SPECIALIST) :AXIOMS (SINGLE-VALUED RELATION-CONSTRAINT)) (DEFRELATION HANDLES-REVERSE-POLARITY ((?CP COMPUTED-PROCEDURE)) :DOCUMENTATION \"Very specialized PowerLoom predicate.  Indicates that a computed procedure\nused as a relation specialist is programmed to handle reverse\npolarity (*reversePolarity?*).\") (DEFRELATION UPDATE-PROPOSITION-DEMON ((?R RELATION) (?COMPUTATION COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names a 'computation' (a function) that is attached (logically)\nto ?r  Each time a proposition with predicate ?r has its truth\nvalue updated (even redundantly), the function is applied to that\nproposition.\" :AXIOMS (SINGLE-VALUED UPDATE-PROPOSITION-DEMON)) (DEFRELATION GOES-TRUE-DEMON ((?R RELATION) (?COMPUTATION COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names a 'computation' (a function) that is attached (logically)\nto ?r  Each time a proposition with predicate ?r becomes\ntrue, the function is applied to that proposition.\" :AXIOMS (SINGLE-VALUED GOES-TRUE-DEMON)) (DEFRELATION GOES-UNKNOWN-DEMON ((?R RELATION) (?COMPUTATION COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names a 'computation' (a function) that is attached (logically)\nto ?r  Each time a proposition with predicate ?r becomes\nunknown, the function is applied to that proposition.\" :AXIOMS (SINGLE-VALUED GOES-UNKNOWN-DEMON)) (DEFRELATION GOES-FALSE-DEMON ((?R RELATION) (?COMPUTATION COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names a 'computation' (a function) that is attached (logically)\nto ?r  Each time a proposition with predicate ?r becomes\nfalse, the function is applied to that proposition.\" :AXIOMS (SINGLE-VALUED GOES-FALSE-DEMON)) (DEFRELATION SYNONYM (?TERM ?SYNONYM) :PHRASE \"?synonym is a synonym for ?term\" :DOCUMENTATION \"Assert that `?synonym' is a synonym of `?term'.  This\ncauses all references to `?synonym' to be interpreted as references\nto `?term'.  Retraction eliminates a synonym relation.\") (ASSERT (AND (GOES-TRUE-DEMON SYNONYM ASSERT-SYNONYM-DEMON) (GOES-UNKNOWN-DEMON SYNONYM RETRACT-SYNONYM-DEMON))) (DEFFUNCTION COLLECTIONOF (?M) :-> (?C COLLECTION) :DOCUMENTATION \"Abstract function existing to subsume 'SETOF'\nand 'LISTOF'.\" :AXIOMS (VARIABLE-ARITY COLLECTIONOF)) (DEFFUNCTION SETOF (?M) :-> (?C SET) :DOCUMENTATION \"Term-forming function that defines an enumerated set\nconsisting of all function arguments.  `setof' is like `listof' except\nthat it removes duplicate values.\" :AXIOMS (AND (SUBSET-OF SETOF COLLECTIONOF) (VARIABLE-ARITY SETOF) (TOTAL SETOF))) (DEFFUNCTION LISTOF (?M) :-> (?C LIST) :DOCUMENTATION \"Term-forming function that defines an ordered list\nconsisting of all function arguments.  Within logical expressions\n`listof' is most commonly used in conjunction with the `member-of'\npredicate.  For example the query\n	 \n  (retrieve ?x (member-of ?x (listof a b c)))\n	\nreturns the constants `a', `b', and `c' on successive iterations.\" :AXIOMS (AND (SUBSET-OF LISTOF COLLECTIONOF) (VARIABLE-ARITY LISTOF) (TOTAL LISTOF))) (DEFRELATION HOLDS ((?RELATION RELATION) ?ARGUMENTS) :DOCUMENTATION \"True if the tuple '?arguments' is a member of the\nrelation '?relation'.  `holds' is a variable arity predicate that takes\na relation as its first argument, and zero or more additional arguments.\nIt returns values equivalent to a subgoal that has the first argument\nas a predicate and the remaining arguments shifted one place to the left.\nFor `holds' to succeed, the (first) relation argument must be bound --\nPowerLoom will NOT cycle through all relations searching for ones that\npermit the proof to succeed.  However, users can obtain the same effect\nif they choose by using other second-order predicates to generate\nrelation bindings.  For example, the query\n	 \n   (retrieve all ?x (and (Relation ?r)\n                         (holds ?r Fred ?x)))\n	\nretrieves all constants for which there is some binary relation that\nrelates `Fred' to that relation.\" :AXIOMS (AND (VARIABLE-ARITY HOLDS) (RELATION-SPECIALIST HOLDS HOLDS-SPECIALIST))) (DEFFUNCTION VALUE ((?FUNCTION FUNCTION) ?ARGUMENTS) :-> ?VALUE :DOCUMENTATION \"True if applying '?function' to '?arguments'\nyields the value '?value'.  The `value' predicate is the analog\nof `holds', except that it applies to functions instead of relations.\" :AXIOMS (AND (VARIABLE-ARITY VALUE) (RELATION-SPECIALIST VALUE VALUE-SPECIALIST))) (DEFRELATION IST ((?CONTEXT CONTEXT) (?P PROPOSITION)) :DOCUMENTATION \"True if proposition '?p' is true in context '?context'.\nThe `IST' (is true) relation allows one to evaluate a query or rule in more\nthan one context.  A common use of `IST' is in defining 'lifting axioms'\nthat import knowledge from one context to another.  For example, below is\na rule that accesses a `patient-record' relation in a module called\n`Medical-Kb', 'lifts-out' the `age' column, and imports it into a\n`has-age' relation in the current context.\n	 \n  (<= (has-age ?person ?age)\n      (and (has-ssn ?person ?ssn)\n           (exists (?1 ?2 ?3 ?4)\n              (ist Medical-Kb (patient-record ?ssn ?1 ?2 ?age ?3 ?4)))))\n	\n\" :AXIOMS (AND (RELATION-SPECIALIST IST IST-SPECIALIST) (HANDLES-REVERSE-POLARITY IST-SPECIALIST))) (DEFRELATION CUT (?ARGUMENTS) :DOCUMENTATION \"Prolog-like CUT.  Succeeds the first time and\nthen fails.  Side-effect:  Locally disables query optimization.\" :AXIOMS (AND (VARIABLE-ARITY CUT) (RELATION-SPECIALIST CUT CUT-SPECIALIST))) (DEFRELATION BOUND-VARIABLES (?ARGUMENTS) :DOCUMENTATION \"True if all arguments are bound.  The `bound-variables'\npredicate is used as a performance enhancer, to prevent other predicates\nfrom backchaining excessively while searching for bindings of certain of\ntheir arguments. Purists will shun the use of this predicate, but some rules\nare inherently inefficient without the addition of some kind of control logic.\nBecause evaluation of the `bound-variables' predicate evaluation of\npredicates being 'guarded', using this predicate has the side-effect\nof locally disabling query optimization.  (See `collect-into-set' for\nan example that uses `bound-variables'.\" :AXIOMS (AND (VARIABLE-ARITY BOUND-VARIABLES) (HANDLES-REVERSE-POLARITY BOUND-VARIABLES-SPECIALIST) (RELATION-SPECIALIST BOUND-VARIABLES BOUND-VARIABLES-SPECIALIST))) (DEFRELATION FORK ((?TEST PROPOSITION) (?THEN PROPOSITION) (?ELSE PROPOSITION)) :DOCUMENTATION \"Fail-based conditional.  If ?test succeeds, evaluates\n?then; otherwise evaluates ?else.\" :AXIOMS (RELATION-SPECIALIST FORK FORK-SPECIALIST)) (DEFRELATION QUERY ((?PROP PROPOSITION) ?OPTIONS) :DOCUMENTATION \"EXPERIMENTAL search-control relation that allows one to prove\nor retrieve bindings for ?prop with modified search control ?options.  The list\nof accepted ?options is currently the same as are legal for a top-level `ask'\nor `retrieve' query.  The special option value :INHERIT inherits the option\nvalue from the parent or top-level query.  The option pair :INHERIT :ALL\ninherits all parent options which can then be further modified by additional\nindividual option specifications.  At most how many solutions will be generated\nis controlled by the :HOW-MANY option (just like in the top level `retrieve').\nThe default is 1 which is again the same as for `retrieve' but different from\nhow normal subgoals behave (those behave in a lazy all solutions mode).\nThe reason for this is that for partial match subqueries, solutions need to be\ngenerated eagerly, therefore, a default of generating all solutions is not\ndesirable.\" :VARIABLE-ARITY TRUE :RELATION-SPECIALIST QUERY-SPECIALIST) (DEFRELATION HIDDEN-RELATION ((?R RELATION)) :DOCUMENTATION \"Indicates that ?r is used like an internal data\nstructure; not for user consumption.\") (DEFFUNCTION OBSERVED-CARDINALITY-OF ((?R RELATION)) :-> (?CARD INTEGER) :DOCUMENTATION \"Used by PowerLoom to record the sizes of class\nand relation extensions.  Only filled if the relation extension was\ndirectly accessed by some query.\" :AXIOMS (HIDDEN-RELATION OBSERVED-CARDINALITY-OF)) (DEFRELATION POLYMORPHIC ((?R RELATION)) :DOCUMENTATION \"True if ?r' supports polymorphism.\") (DEFRELATION INSTANCE-OF ((?X THING) (?C COLLECTION)) :DOCUMENTATION \"True if ?x is an instance of ?c.  Can\nbe used to generate concept values of ?c, given an instance ?x.\" :AXIOMS (RELATION-SPECIALIST INSTANCE-OF INSTANCE-OF-SPECIALIST)) (DEFRELATION TYPE-OF ((?C COLLECTION) (?X THING)) :DOCUMENTATION \"True if ?x is a member of the concept ?c.\" :<<=>> (INSTANCE-OF ?X ?C) :AXIOMS (INVERSE INSTANCE-OF TYPE-OF)) (DEFRELATION SUBSET-OF ((?SUB COLLECTION) (?SUPER COLLECTION)) :DOCUMENTATION \"True if ?sub is a subset of ?super.  For performance\nreasons, the `subset-of' predicate refuses to search for bindings if\nboth of its variables are unbound.  Implementation note: `subset-of' \nis treated specially internally to PowerLoom, and hence Powerloom does not\npermit the augmentation of `subset-of' with additional inference rules.\nIn otherwords, `subset-of' behaves semantically like an operator instead\nof a relation.\" :AXIOMS (RELATION-SPECIALIST SUBSET-OF SUBSET-OF-SPECIALIST)) (DEFRELATION MEMBER-OF ((?X THING) (?C COLLECTION)) :DOCUMENTATION \"TRUE if ?x is a member of collection ?c.  A common use\nof `member-of' is for binding a variable to successive members in a list\nor set (see `listof' and `setof').\" :AXIOMS (AND (RELATION-SPECIALIST MEMBER-OF MEMBER-OF-SPECIALIST) (HANDLES-REVERSE-POLARITY MEMBER-OF-SPECIALIST) (RELATION-EVALUATOR MEMBER-OF MEMBER-OF-EVALUATOR))) (DEFRELATION PORTION-OF ((?X AGGREGATE) (?Y AGGREGATE)) :PHRASE \"?x is a portion of (a piece of) ?y\" :AXIOMS ((TRANSITIVE PORTION-OF))) (DEFRELATION DOMAIN ((?R RELATION) (?D COLLECTION)) :DOCUMENTATION \"True if for any tuple `T' that satifies ?r, the first\nargument of `T' necessarily belongs to the concept ?d.  `domain' exists\nfor convenience only and is defined in terms of `nth-domain'.  `domain'\nassertions should be avoided, since they create redundant `nth-domain'\npropositions (use `nth-domain' directly).\" :<<=>> (NTH-DOMAIN ?R 0 ?D) :=>> (=>> (HOLDS ?R ?I ?V) (HOLDS ?D ?I))) (DEFRELATION RANGE ((?R RELATION) (?RNG COLLECTION)) :DOCUMENTATION \"True if for any tuple 'T' that satifies ?r, the last\nargument of 'T' necessarily belongs to the concept ?rng.  `range' exists\nfor convenience only and is defined in terms of `nth-domain'.  `range'\nassertions should be avoided, since they create redundant `nth-domain'\npropositions (use `nth-domain' directly).\" :<<= (AND (> (ARITY ?R) 1) (NTH-DOMAIN ?R (- (ARITY ?R) 1) ?RNG)) :=>> (NTH-DOMAIN ?R (- (ARITY ?R) 1) ?RNG) :=>> (=>> (HOLDS ?R ?I ?V) (HOLDS ?RNG ?V))) (DEFRELATION NTH-DOMAIN ((?R RELATION) (?I INTEGER) (?D COLLECTION)) :DOCUMENTATION \"True if the nth value for a tuple T satisfying\n?r must belong to the concept ?d.  Argument counting starts at zero.\" :AXIOMS (<<= (NTH-DOMAIN ?R 0 ?R) (CONCEPT ?R))) (DEFRELATION CLOSED ((?C COLLECTION)) :PHRASE \"?c is closed\" :DOCUMENTATION \"The collection ?c is closed if all of its members are known.\nAsserting that a relation is closed makes certain computations easier.\nFor example, suppose that the relation `happy' is closed,\nimplying that all things that are happy will be asserted as such.\nTo prove `(not (happy Fred))', PowerLoom can use a negation-as-failure \nproof strategy which returns TRUE if `Fred' cannot be proved to be happy.\nAlso, if the relation `children' is closed, then a value for the expression\n`(range-max-cardinality children Fred)' can be inferred merely by\ncounting the number of fillers of the `children' role on `Fred'.\" :AXIOMS (AND (HANDLES-REVERSE-POLARITY CLOSED-SPECIALIST) (RELATION-SPECIALIST CLOSED CLOSED-SPECIALIST))) (DEFRELATION EMPTY ((?C COLLECTION)) :DOCUMENTATION \"The collection ?c is empty if it has no members.  Note\nthat for collections possessing open-world semantics, (e.g., most concepts)\nthe fact that the collection has no known members does not necessarily\nimply that it is empty.\" :AXIOMS (AND (RELATION-SPECIALIST EMPTY EMPTY-SPECIALIST) (COMPUTED EMPTY))) (DEFRELATION SINGLE-VALUED ((?C RELATION)) :DOCUMENTATION \"The relation ?c is single-valued if the value of its\nlast argument is a function of all other arguments.  All functions\nare single-valued (see `function').\" :AXIOMS (AND (HANDLES-REVERSE-POLARITY SINGLE-VALUED-SPECIALIST) (RELATION-SPECIALIST SINGLE-VALUED SINGLE-VALUED-SPECIALIST))) (DEFRELATION COMPUTED ((?C RELATION)) :DOCUMENTATION \"?c is computed if it can be evaluated only if all of\nits input arguments are bound (or all of them if it is a relation).\nConsidered by the query optimizer when looking for generators.\") (DEFFUNCTION THE-ROLESET ((?R RELATION) ?I) :-> (?RS SET) :DOCUMENTATION \"Function that defines a mapping from a relation\nand instance to the skolem that (intensionally) denotes the\ncorresponding set of role fillers.\") (DEFFUNCTION FILLERS ((?R RELATION) ?I) :-> (?MEMBERS SET) :DOCUMENTATION \"Given a relation ?r and instance ?i, returns\na set of known fillers of ?r applied to ?i.  IMPORTANT: this also collects\nintensional fillers such as skolems that might be identical extensionally.\" :<<= (AND (BOUND-VARIABLES ?R ?I) (COLLECT-INTO-SET (SETOFALL ?V (HOLDS ?R ?I ?V)) ?MEMBERS)) :AXIOMS (COMPUTED FILLERS)) (DEFFUNCTION CARDINALITY ((?C SET)) :-> (?CARD INTEGER) :DOCUMENTATION \"Function that returns the cardinality of a set.\" :<<= (AND (CLOSED ?C) (LENGTH-OF-LIST (COLLECT-INTO-SET ?C) ?CARD))) (DEFCONCEPT FRAME-PREDICATE ((?C RELATION)) :DOCUMENTATION \"A frame predicate is a second-order relation that\nis used to describe constraints on the set of fillers for a binary\nrelation applied to an instance.  Examples of frame predicates are\n`range-cardinality', `range-type', and `numeric-minimum'.  Frame predicates\nare typically used to capture the kinds of relations manipulated\nby description logic systems such as USC/ISI's Loom system.\") (DEFRELATION RANGE-TYPE ((?R RELATION) ?I (?TYPE COLLECTION)) :DOCUMENTATION \"Relation that specifies a type/range of the relation ?r applied to ?i.\nMultiple range types may be asserted for a single pair <?r,?i>.  Technically,\na retrieval of types for a given pair should include all supertypes\n(superconcepts) of any type that is produced, but for utility's sake,\nonly asserted or directly inferrable types are returned.\" :AXIOMS (=>> (AND (RANGE-TYPE ?R ?I ?TYPE) (FAIL (NTH-DOMAIN ?R 1 ?TYPE))) (FORALL ?V (=>> (HOLDS ?R ?I ?V) (HOLDS ?TYPE ?V)))) :<<=>> (SUBSET-OF (THE-ROLESET ?R ?I) ?TYPE) :<<= (AND (BOUND-VARIABLES ?R ?I ?TYPE) (FORK (AND (SINGLE-VALUED ?R) (EXISTS ?V (HOLDS ?R ?I ?V))) (EXISTS ?V (AND (HOLDS ?R ?I ?V) (HOLDS ?TYPE ?V))) (OR (AND (OR (CLOSED ?R) (CLOSED (THE-ROLESET ?R ?I))) (FORALL ?V (=> (HOLDS ?R ?I ?V) (HOLDS ?TYPE ?V)))) (EXISTS (?SUPERR ?SUPERVT) (AND (SUBSET-OF ?R ?SUPERR) (RANGE-TYPE ?SUPERR ?I ?SUPERVT) (SUBSET-OF ?SUPERVT ?TYPE)))))) :COMPUTED TRUE :FRAME-PREDICATE TRUE :RELATION-SPECIALIST RANGE-TYPE-SPECIALIST) (DEFRELATION RANGE-CARDINALITY-LOWER-BOUND ((?R RELATION) ?I (?LB INTEGER)) :DOCUMENTATION \"Relation that specifies a lower bound on the cardinality \nof the set of fillers of the relation ?r applied to ?i.  The difference\nbetween `range-cardinality-lower-bound' and `range-min-cardinality' is\nsubtle but significant.   Suppose we state that nine is a lower bound\non the number of planets in the solar system, and then ask if eight is\n(also) a lower bound:\n	 \n   (assert (range-cardinality-lower-bound hasPlanets SolarSystem 9))\n   (ask (range-cardinality-lower-bound hasPlanets SolarSystem 8))  ==> TRUE\n	\nPowerLoom will return TRUE.  However if we ask if the minimum cardinality\nof the solar system's planets is eight, we get back UNKNOWN\n	 \n   (ask (range-min-cardinality hasPlanets SolarSystem 8)) ==> UNKNOWN\n	\nbecause eight is not the tightest lower bound.\" :AXIOMS (<<= (RANGE-CARDINALITY-LOWER-BOUND ?R ?I ?LB) (AND (BOUND-VARIABLES ?R ?I ?LB) (=< ?LB (RANGE-MIN-CARDINALITY ?R ?I)))) :AXIOMS (=>> (RANGE-CARDINALITY-LOWER-BOUND ?R ?I ?LB) (>= (CARDINALITY (THE-ROLESET ?R ?I)) ?LB)) :AXIOMS (AND (FRAME-PREDICATE RANGE-CARDINALITY-LOWER-BOUND) (RELATION-SPECIALIST RANGE-CARDINALITY-LOWER-BOUND RANGE-MIN-CARDINALITY-SPECIALIST) (HANDLES-REVERSE-POLARITY RANGE-MIN-CARDINALITY-SPECIALIST))) (DEFRELATION RANGE-CARDINALITY-UPPER-BOUND ((?R RELATION) ?I (?UB INTEGER)) :DOCUMENTATION \"Relation that specifies an upper bound on the cardinality \nof the set of fillers of the relation ?r applied to ?i. (see the discussion\nfor `range-cardinality-lower-bound').\" :AXIOMS (<<= (RANGE-CARDINALITY-UPPER-BOUND ?R ?I ?UB) (AND (BOUND-VARIABLES ?R ?I ?UB) (>= ?UB (RANGE-MAX-CARDINALITY ?R ?I)))) :AXIOMS (=>> (RANGE-CARDINALITY-UPPER-BOUND ?R ?I ?UB) (=< (CARDINALITY (THE-ROLESET ?R ?I)) ?UB)) :AXIOMS (AND (FRAME-PREDICATE RANGE-CARDINALITY-UPPER-BOUND) (RELATION-SPECIALIST RANGE-CARDINALITY-UPPER-BOUND RANGE-MAX-CARDINALITY-SPECIALIST) (HANDLES-REVERSE-POLARITY RANGE-MAX-CARDINALITY-SPECIALIST))) (DEFFUNCTION RANGE-CARDINALITY ((?R RELATION) ?I) :-> (?CARD INTEGER) :DOCUMENTATION \"Function that returns the cardinality of the set\nof fillers of the relation ?r applied to ?i.  The cardinality function\nreturns a value only when the relations `range-min-cardinality' and\n`range-max-cardinality' compute identical values, i.e., when the\nbest lower and upper bounds on the cardinality are equal.  Each of\nthese bounding functions employs a variety of rules to try and\ncompute a tight bound.\" :<=> (AND (RANGE-MIN-CARDINALITY ?R ?I ?CARD) (RANGE-MAX-CARDINALITY ?R ?I ?CARD)) :AXIOMS (=>> (RANGE-CARDINALITY ?R ?I ?CARD) (= (CARDINALITY (THE-ROLESET ?R ?I)) ?CARD)) :AXIOMS (AND (FRAME-PREDICATE RANGE-CARDINALITY) (COMPUTED RANGE-CARDINALITY))) (DEFFUNCTION RANGE-MIN-CARDINALITY ((?R RELATION) ?I) :-> (?MINCARD INTEGER) :DOCUMENTATION \"Returns the strictest computable lower bound on the\ncardinality of the set of fillers of the relation ?r applied to ?i.\n(see the discussion for `range-cardinality-lower-bound').\" :<<= (OR (AND (SINGLE-VALUED ?R) (EXISTS ?V (HOLDS ?R ?I ?V)) (= ?MINCARD 1)) (MAXIMUM-VALUE (COLLECT-INTO-SET (SETOFALL ?M (OR (>= (CARDINALITY (THE-ROLESET ?R ?I)) ?M) (= ?M 0) (LENGTH-OF-LIST (FILLERS ?R ?I) ?M) (EXISTS ?SUBR (AND (SUBSET-OF ?SUBR ?R) (>= (CARDINALITY (THE-ROLESET ?SUBR ?I)) ?M)))))) ?MINCARD)) :AXIOMS (AND (FRAME-PREDICATE RANGE-MIN-CARDINALITY))) (DEFFUNCTION RANGE-MAX-CARDINALITY ((?R RELATION) ?I) :-> (?MAXCARD INTEGER) :DOCUMENTATION \"Returns the strictest computable upper bound on the\ncardinality of the set of fillers of the relation ?r applied to ?i.\n(see the discussion for `range-cardinality-lower-bound').\" :<<= (OR (AND (SINGLE-VALUED ?R) (EXISTS ?V (HOLDS ?R ?I ?V)) (= ?MAXCARD 1)) (MINIMUM-VALUE (COLLECT-INTO-SET (SETOFALL ?M (OR (=< (CARDINALITY (THE-ROLESET ?R ?I)) ?M) (AND (SINGLE-VALUED ?R) (= ?M 1)) (AND (EMPTY (THE-ROLESET ?R ?I)) (= ?M 0)) (AND (CLOSED ?R) (RANGE-MIN-CARDINALITY ?R ?I ?M)) (EXISTS ?SUPERR (AND (SUBSET-OF ?R ?SUPERR) (=< (CARDINALITY (THE-ROLESET ?SUPERR ?I)) ?M)))))) ?MAXCARD)) :AXIOMS (AND (FRAME-PREDICATE RANGE-MAX-CARDINALITY) (=> (EXISTS (?MIN) (AND (RANGE-MIN-CARDINALITY ?R ?I ?MIN) (> ?MIN ?MAX))) (NOT (RANGE-MAX-CARDINALITY ?R ?I ?MAX))))) (DEFFUNCTION QUALIFIED-RANGE-MIN-CARDINALITY ((?R RELATION) ?I (?Q COLLECTION)) :-> (?CARD INTEGER) :DOCUMENTATION \"Function that returns the minimum cardinality of the set of\nfillers of type ?q of the relation ?r applied to ?i.  NOT YET IMPLEMENTED.\" :AXIOMS (AND (FRAME-PREDICATE QUALIFIED-RANGE-MIN-CARDINALITY) (COMPUTED QUALIFIED-RANGE-MIN-CARDINALITY))) (DEFFUNCTION QUALIFIED-RANGE-MAX-CARDINALITY ((?R RELATION) ?I (?Q COLLECTION)) :-> (?CARD INTEGER) :DOCUMENTATION \"Function that returns the maximum cardinality of the set of\nfillers of type ?q of the relation ?r applied to ?i.  NOT YET IMPLEMENTED.\" :AXIOMS (AND (FRAME-PREDICATE QUALIFIED-RANGE-MAX-CARDINALITY) (COMPUTED QUALIFIED-RANGE-MAX-CARDINALITY))) (DEFFUNCTION QUALIFIED-RANGE-CARDINALITY ((?R RELATION) ?I (?Q COLLECTION)) :-> (?CARD INTEGER) :DOCUMENTATION \"Function that returns the cardinality of the set of\nfillers of type ?q of the relation ?r applied to ?i.  The cardinality function\nreturns a value only when the relations `qualified-range-min-cardinality' and\n`qualified-range-max-cardinality' compute identical values, i.e., when the\nbest lower and upper bounds on the cardinality are equal.  Each of\nthese bounding functions employs a variety of rules to try and\ncompute a tight bound.  NOT YET IMPLEMENTED.\" :AXIOMS (AND (FRAME-PREDICATE QUALIFIED-RANGE-CARDINALITY) (COMPUTED QUALIFIED-RANGE-CARDINALITY))) (DEFFUNCTION NUMERIC-INTERVAL ((?X NUMERIC-SET)) :-> (?INTERVAL INTEGER-INTERVAL) :DOCUMENTATION \"Function that returns an interval representing\nthe range of allowable numeric values for its members.\" :=>> (SCALAR-INTERVAL ?INTERVAL)) (DEFRELATION NUMERIC-MINIMUM ((?R RELATION) ?I (?N NUMBER)) :DOCUMENTATION \"Relation that specifies a lower bound '?n' on any numeric\nvalue that can belong to the set of fillers of the relation ?r applied to ?i.\" :<<=>> (>= (INTERVAL-LOWER-BOUND (NUMERIC-INTERVAL (THE-ROLESET ?R ?I))) ?N) :AXIOMS (FRAME-PREDICATE NUMERIC-MINIMUM)) (DEFRELATION NUMERIC-MAXIMUM ((?R RELATION) ?I (?N NUMBER)) :DOCUMENTATION \"Relation that specifies an upper bound '?n' on any numeric\nvalue that can belong to the set of fillers of the relation ?r applied to ?i.\" :<<=>> (=< (INTERVAL-UPPER-BOUND (NUMERIC-INTERVAL (THE-ROLESET ?R ?I))) ?N) :AXIOMS (FRAME-PREDICATE NUMERIC-MAXIMUM)) (DEFFUNCTION INTERVAL-CACHE-OF (?X) :-> (?B INTERVAL-CACHE) :DOCUMENTATION \"Binds an instance ?x of type NUMBER or QUANTITY to a \nstructure that records its tightest lower and upper bounds.\" :AXIOMS (HIDDEN-RELATION INTERVAL-CACHE-OF)) (DEFRELATION DIRECT-SUBRELATION ((?R RELATION) (?SUB RELATION)) :DOCUMENTATION \"True iff ?sub is a direct subrelation of ?r; written\nin set notation, ?sub < ?r, and there is no ?s such that ?sub < ?s < ?r.\nThis relation will generate bindings for at most one unbound argument.\" :AXIOMS (RELATION-SPECIALIST DIRECT-SUBRELATION RELATION-HIERARCHY-SPECIALIST)) (DEFRELATION DIRECT-SUPERRELATION ((?R RELATION) (?SUPER RELATION)) :DOCUMENTATION \"True iff ?super is a direct superrelation of ?r;\nin set notation, ?super > ?r, and there is no ?s such that ?super > ?s > ?r.\nThis relation will generate bindings for at most one unbound argument.\" :AXIOMS (AND (INVERSE DIRECT-SUPERRELATION DIRECT-SUBRELATION) (RELATION-SPECIALIST DIRECT-SUPERRELATION RELATION-HIERARCHY-SPECIALIST))) (DEFRELATION SUBRELATION ((?R RELATION) (?SUB RELATION)) :DOCUMENTATION \"True iff ?sub is a subrelation of ?r; written in set\nnotation, ?sub =< ?r.  This relation will generate bindings for at most\none unbound argument.\" :AXIOMS (RELATION-SPECIALIST SUBRELATION RELATION-HIERARCHY-SPECIALIST)) (DEFRELATION SUPERRELATION ((?R RELATION) (?SUPER RELATION)) :DOCUMENTATION \"True iff ?super is a superrelation of ?r; written in set\nnotation, ?super >= ?r.  This relation will generate bindings for at most\none unbound argument.\" :AXIOMS (AND (INVERSE SUPERRELATION SUBRELATION) (RELATION-SPECIALIST SUPERRELATION RELATION-HIERARCHY-SPECIALIST))) (DEFRELATION PROPER-SUBRELATION ((?R RELATION) (?SUB RELATION)) :DOCUMENTATION \"True iff ?sub is a proper subrelation of ?r; written in\nset notation, ?sub < ?r.  This relation will generate bindings for at most\none unbound argument.\" :AXIOMS (RELATION-SPECIALIST PROPER-SUBRELATION RELATION-HIERARCHY-SPECIALIST)) (DEFRELATION PROPER-SUPERRELATION ((?R RELATION) (?SUPER RELATION)) :DOCUMENTATION \"True iff ?super is a proper superrelation of ?r; written in\nset notation, ?super > ?r.  This relation will generate bindings for at most\none unbound argument.\" :AXIOMS (AND (INVERSE PROPER-SUPERRELATION PROPER-SUBRELATION) (RELATION-SPECIALIST PROPER-SUPERRELATION RELATION-HIERARCHY-SPECIALIST))) (DEFRELATION EQUIVALENT-RELATION ((?R RELATION) (?EQUIV RELATION)) :DOCUMENTATION \"True if ?r is equivalent to ?equiv; written in set notation,\n?r = ?equiv.  This relation will generate bindings for at most one unbound\nargument.\" :AXIOMS (RELATION-SPECIALIST EQUIVALENT-RELATION RELATION-HIERARCHY-SPECIALIST)) (DEFFUNCTION UNION-OF ((?S1 COLLECTION) (?S2 COLLECTION)) :-> (?UNION SET) :DOCUMENTATION \"True if the union of the collections ?s1 and ?s2\nequals ?union.\") (DEFFUNCTION + ((?X NUMBER) (?Y NUMBER)) :-> (?Z NUMBER) :DOCUMENTATION \"Function that adds two numbers.\") (ASSERT (AND (COMPUTED +) (RELATION-CONSTRAINT + PLUS-CONSTRAINT) (RELATION-SPECIALIST + CONSTRAINT-SPECIALIST))) (DEFFUNCTION - ((?X NUMBER) (?Y NUMBER)) :-> (?Z NUMBER) :DOCUMENTATION \"Function that subtracts two numbers.\") (ASSERT (AND (COMPUTED -) (RELATION-CONSTRAINT - MINUS-CONSTRAINT) (RELATION-SPECIALIST - CONSTRAINT-SPECIALIST))) (DEFFUNCTION * ((?X NUMBER) (?Y NUMBER)) :-> (?Z NUMBER) :DOCUMENTATION \"Function that multiplies two numbers.\") (ASSERT (AND (COMPUTED *) (RELATION-CONSTRAINT * TIMES-CONSTRAINT) (RELATION-SPECIALIST * CONSTRAINT-SPECIALIST))) (DEFFUNCTION / ((?X NUMBER) (?Y NUMBER)) :-> (?Z NUMBER) :DOCUMENTATION \"Function that divides two numbers.\") (ASSERT (AND (COMPUTED /) (RELATION-CONSTRAINT / DIVIDE-CONSTRAINT) (RELATION-SPECIALIST / CONSTRAINT-SPECIALIST))) (DEFFUNCTION SQRT ((?X NUMBER)) :-> (?Y NUMBER) :DOCUMENTATION \"Function that returns the positive square root:\n?y = sqrt(?x).  For positive and negative roots see relation SQUARE-ROOT\" :AXIOMS (AND (COMPUTED SQRT) (RELATION-CONSTRAINT SQRT SQRT-CONSTRAINT) (RELATION-SPECIALIST SQRT CONSTRAINT-SPECIALIST))) (DEFRELATION SQUARE-ROOT ((?X NUMBER) (?Y NUMBER)) :DOCUMENTATION \"Relation that returns the positive and negative square roots:\n?y = sqrt(?x).  For positive roots only see function SQRT.\" :AXIOMS (AND (COMPUTED SQUARE-ROOT) (RELATION-SPECIALIST SQUARE-ROOT SQUARE-ROOT-SPECIALIST))) (DEFRELATION ABSOLUTE-VALUE ((?X NUMBER) (?Y NUMBER)) :DOCUMENTATION \"Relation that computes ?y = abs(?x).  If ?x is unbound,\nthen both positive and negative values of ?y will be returned.\" :AXIOMS (AND (COMPUTED ABSOLUTE-VALUE) (RELATION-SPECIALIST ABSOLUTE-VALUE ABSOLUTE-VALUE-SPECIALIST))) (DEFRELATION NEGATE ((?X NUMBER) (?Y NUMBER)) :DOCUMENTATION \"Relation that computes ?y = - ?x.\" :AXIOMS (AND (COMPUTED NEGATE) (RELATION-CONSTRAINT NEGATE NEGATE-CONSTRAINT) (RELATION-SPECIALIST NEGATE CONSTRAINT-SPECIALIST))) (ASSERT (HANDLES-REVERSE-POLARITY INEQUALITY-SPECIALIST)) (DEFRELATION INEQUALITY (?X ?Y) :DOCUMENTATION \"Abstract superrelation of inequality relations.\" :<<= (=< ?X ?Y) :<<= (>= ?X ?Y) :AXIOMS (ABSTRACT INEQUALITY)) (DEFRELATION < (?X ?Y) :DOCUMENTATION \"True if ?x < ?y.\" :<<= (EXISTS ?Z (AND (< ?X ?Z) (=< ?Z ?Y))) :<<= (EXISTS ?Z (AND (=< ?X ?Z) (< ?Z ?Y)))) (ASSERT (AND (COMPUTED <) (RELATION-SPECIALIST < INEQUALITY-SPECIALIST) (RELATION-EVALUATOR < INEQUALITY-EVALUATOR))) (DEFRELATION =< (?X ?Y) :DOCUMENTATION \"True if ?x <= ?y.\" :<<= (EXISTS ?Z (AND (=< ?X ?Z) (=< ?Z ?Y))) :<<= (< ?X ?Y)) (ASSERT (AND (COMPUTED =<) (RELATION-SPECIALIST =< INEQUALITY-SPECIALIST) (RELATION-EVALUATOR =< INEQUALITY-EVALUATOR))) (DEFRELATION > (?X ?Y) :DOCUMENTATION \"True if ?x > ?y.\" :<<=>> (< ?Y ?X)) (ASSERT (AND (COMPUTED >) (RELATION-SPECIALIST > INEQUALITY-SPECIALIST) (RELATION-EVALUATOR > INEQUALITY-EVALUATOR))) (DEFRELATION >= (?X ?Y) :DOCUMENTATION \"True if ?x >= ?y.\" :<<=>> (=< ?Y ?X) :<<= (> ?X ?Y)) (ASSERT (AND (COMPUTED >=) (RELATION-SPECIALIST >= INEQUALITY-SPECIALIST) (RELATION-EVALUATOR >= INEQUALITY-EVALUATOR))) (DEFFUNCTION COLLECT-INTO-SET ((?C COLLECTION)) :-> (?L SET) :DOCUMENTATION \"Infer as many members of ?c as possible and\ncollect them into a set ?l.  For example, here is a rule\nused to compute bindings for the `fillers' predicate:\n	 \n  (<= (fillers ?r ?i ?v)\n      (and (bound-variables ?r ?i)\n           (collect-into-set (setofall ?v (holds ?r ?i ?v)) ?members)))\n	\nWhen `?r' and `?i' are bound, the term `(setofall ?v (holds ?r ?i ?v))'\nevaluates to a unary relation satisfied for each filler of the relation\nin `?r' applied to the instance in `?i'.  `collect-into-set' causes\nthe extension of this (dynamically-defined) unary relation to be\ncomputed.  Note the use of `bound-variables' to screen out unbound\nvariables before they are passed to the `setofall' predicate.\" :AXIOMS (RELATION-SPECIALIST COLLECT-INTO-SET COLLECT-INTO-SET-SPECIALIST)) (DEFRELATION LENGTH-OF-LIST ((?L COLLECTION) (?LENGTH INTEGER)) :DOCUMENTATION \"Computes the length of the list or set ?l.\" :AXIOMS (AND (COMPUTED LENGTH-OF-LIST) (RELATION-SPECIALIST LENGTH-OF-LIST LENGTH-OF-LIST-SPECIALIST) (SINGLE-VALUED LENGTH-OF-LIST))) (DEFRELATION MINIMUM-VALUE ((?L COLLECTION) (?MIN NUMBER)) :DOCUMENTATION \"Binds ?min to the minimum of the numbers in the list ?l.\" :AXIOMS (AND (RELATION-SPECIALIST MINIMUM-VALUE MINIMUM-OF-NUMBERS-SPECIALIST) (SINGLE-VALUED MINIMUM-VALUE))) (DEFRELATION MAXIMUM-VALUE ((?L COLLECTION) (?MAX NUMBER)) :DOCUMENTATION \"Binds ?max to the maximum of the numbers in the list ?l.\" :AXIOMS (AND (RELATION-SPECIALIST MAXIMUM-VALUE MAXIMUM-OF-NUMBERS-SPECIALIST) (SINGLE-VALUED MAXIMUM-VALUE))) (DEFRELATION SUM ((?L COLLECTION) (?SUM NUMBER)) :DOCUMENTATION \"Binds ?sum to the sum of the numbers in the list ?l.\" :AXIOMS (AND (RELATION-SPECIALIST SUM SUM-OF-NUMBERS-SPECIALIST) (SINGLE-VALUED SUM))) (DEFFUNCTION PROJECT-COLUMN ((?I INTEGER) (?C COLLECTION)) :-> (?L LIST) :DOCUMENTATION \"Project elements in column ?i (zero-based) of the tuples\nof ?c and collect them into a list ?l. \" :AXIOMS (RELATION-SPECIALIST PROJECT-COLUMN PROJECT-COLUMN-SPECIALIST)) (DEFRELATION MEAN-VALUE ((?L COLLECTION) (?MEAN NUMBER)) :DOCUMENTATION \"Binds ?mean to the mean of the numbers in ?l.\" :AXIOMS (AND (COMPUTED MEAN-VALUE) (RELATION-SPECIALIST MEAN-VALUE MEAN-OF-NUMBERS-SPECIALIST) (SINGLE-VALUED MEAN-VALUE))) (DEFRELATION MEDIAN-VALUE ((?L COLLECTION) (?MEDIAN NUMBER)) :DOCUMENTATION \"Binds ?median to the median of the numbers in ?l.\" :AXIOMS (AND (COMPUTED MEDIAN-VALUE) (RELATION-SPECIALIST MEDIAN-VALUE MEDIAN-OF-NUMBERS-SPECIALIST) (SINGLE-VALUED MEDIAN-VALUE))) (DEFRELATION STANDARD-DEVIATION ((?L COLLECTION) (?SD NUMBER)) :DOCUMENTATION \"Binds ?sd to the standard deviation of the numbers in ?l.\" :AXIOMS (AND (COMPUTED STANDARD-DEVIATION) (RELATION-SPECIALIST STANDARD-DEVIATION STANDARD-DEVIATION-SPECIALIST) (SINGLE-VALUED STANDARD-DEVIATION))) (DEFRELATION VARIANCE ((?L COLLECTION) (?VARIANCE NUMBER)) :DOCUMENTATION \"Binds ?variance to the variance of the numbers in ?l.\" :AXIOMS (AND (COMPUTED VARIANCE) (RELATION-SPECIALIST VARIANCE VARIANCE-SPECIALIST) (SINGLE-VALUED VARIANCE))) (DEFFUNCTION STRING-CONCATENATE ((?X1 STRING) (?X2 STRING)) :-> (?X3 STRING) :DOCUMENTATION \"Concatenate strings ?x1 and ?x2 and bind ?x3 to the result.\" :AXIOMS (AND (COMPUTED STRING-CONCATENATE) (RELATION-CONSTRAINT STRING-CONCATENATE CONCATENATE-CONSTRAINT) (RELATION-SPECIALIST STRING-CONCATENATE CONSTRAINT-SPECIALIST))) (DEFFUNCTION SUBSTRING ((?S STRING) (?START INTEGER) (?END INTEGER)) :-> (?SUB STRING) :DOCUMENTATION \"Generate the substring of ?s starting at position ?start\n(zero-based), ending just before position ?end and bind ?sub to the result.\nThis is the PowerLoom equivalent to the STELLA method `subsequence'.  In\naddition, this function can be used to locate substrings in strings by\nsupplying values for ?s and ?sub and allowing ?start and ?end to be\nbound by the function specialist.  In other words,\n      (retrieve all (?start ?end) (substring \\\"foo\\\" ?start ?end \\\"o\\\"))\n ==>  ?start = 1, ?end = 2,\n      ?start = 2, ?end = 3.\" :AXIOMS (AND (COMPUTED SUBSTRING) (RELATION-SPECIALIST SUBSTRING SUBSEQUENCE-SPECIALIST))) (DEFFUNCTION STRING-MATCH ((?PATTERN STRING) (?OBJECT THING) (?START INTEGER) (?END INTEGER)) :-> (?MATCH-POSITION INTEGER) :DOCUMENTATION \"Match ?pattern against ?object between ?start and ?end\n(zero-based), and return the position of the first match or fail if no\nmatch exists.  Supplying -1 for ?end indicates the end of ?object.  ?object\ncan be a named logic object or a string.  ?pattern will eventually allow\nsupport regular expressions, currently it only handles string literals.\nApart from doing to-string coercion on ?object this is somewhat redundant,\nsince `substring' can generate ?start/?end pairs if its string and\nsubstring arguments are bound.\" :AXIOMS (AND (COMPUTED STRING-MATCH) (RELATION-COMPUTATION STRING-MATCH STRING-MATCH-COMPUTATION) (RELATION-SPECIALIST STRING-MATCH COMPUTATION-SPECIALIST))) (DEFFUNCTION LENGTH ((?X THING)) :-> (?Z INTEGER) :DOCUMENTATION \"Function that returns the length of a string or a logical list.\nNOT YET IMPLEMENTED FOR LISTS.\" :AXIOMS (AND (COMPUTED LENGTH) (RELATION-COMPUTATION LENGTH LENGTH-COMPUTATION) (RELATION-SPECIALIST LENGTH COMPUTATION-SPECIALIST))) (ASSERT (COMPUTED-PROCEDURE COMPUTATION-SPECIALIST)) (ASSERT (HANDLES-REVERSE-POLARITY COMPUTATION-SPECIALIST)) (ASSERT (COMPUTED-PROCEDURE CONSTRAINT-SPECIALIST)) (ASSERT (HANDLES-REVERSE-POLARITY CONSTRAINT-SPECIALIST)) (DEFFUNCTION OBJECT-NAME (?X) :-> (?C STRING) :DOCUMENTATION \"The name of the object ?X as a string.  This is just the\nname, with module prefixes NOT included.\" :AXIOMS (AND (COMPUTED OBJECT-NAME) (RELATION-COMPUTATION OBJECT-NAME OBJECT-NAME-COMPUTATION) (RELATION-SPECIALIST OBJECT-NAME COMPUTATION-SPECIALIST))) (DEFFUNCTION NAME-TO-OBJECT ((?N STRING)) :-> ?O :DOCUMENTATION \"Find or create the PowerLoom logic object ?o named by\nthe name ?n in the current module.  We are interpreting the name ?n literally\nhere, i.e., it is not a print name as assumed by PLI functions and an object\nwith exactly that name will be looked up or created.  We are intentionally\nusing a separate function here (instead of folding this into `object-name'),\nsince we might want to be able to look for an object with a certain name\nbut not create one if it doesn't exist.\" :AXIOMS (AND (COMPUTED NAME-TO-OBJECT) (RELATION-COMPUTATION NAME-TO-OBJECT NAME-TO-OBJECT-COMPUTATION) (RELATION-SPECIALIST NAME-TO-OBJECT COMPUTATION-SPECIALIST))) (DEFFUNCTION ARITY ((?R RELATION)) :-> (?ARITY INTEGER) :DOCUMENTATION \"The number of arguments/domains of the relation '?r'.\") (ASSERT (AND (COMPUTED ARITY) (RELATION-SPECIALIST ARITY ARITY-SPECIALIST) (HANDLES-REVERSE-POLARITY ARITY-SPECIALIST))) (DEFRELATION VARIABLE-ARITY ((?R RELATION)) :DOCUMENTATION \"Asserts that the relation ?r can take a variable\nnumber of arguments.\" :AXIOMS (CLOSED VARIABLE-ARITY)) (DEFCONCEPT BINARY-RELATION (?R RELATION) :DOCUMENTATION \"The class of binary relations.\" :<<=>> (AND (RELATION ?R) (ARITY ?R 2))) (DEFFUNCTION INVERSE ((?R BINARY-RELATION)) :-> ?INVERSERELATION :DOCUMENTATION \"Function that returns the inverse relation for ?r.\nPERFORMANCE NOTE: for best results there should be only one `(inverse R I)'\nassertion per relation pair `R' and `I'.  In that case `R' is viewed as the\ncanonical relation and `I' simply provides a different access mechanism to\nthe canonical relation.  In a logic-based KR paradigm inverse relations are\nredundant and do not add anything that couldn't be represented or queried\nwithout them, however, sometimes they can provide some extra convenience for\nusers.  Asserting `(inverse I R)' also will not cause an error but can degrade\nbackward inference performance due to the extra redundant rule that gets\ngenerated.  If domain rules will be written in terms of both `R' and `I' (as\nopposed to only `R'), `(inverse I R)' should be asserted also to get full\ninferential connectivity between the two relations.\" :=>> (BINARY-RELATION ?INVERSERELATION) :=>> (<<=>> (HOLDS ?INVERSERELATION ?Y ?X) (HOLDS ?R ?X ?Y)) :AXIOMS (SYMMETRIC INVERSE)) (DEFRELATION DUPLICATE-FREE ((?C COLLECTION)) :DOCUMENTATION \"?c is duplicate-free if no two members\ndenote the same object.\") (DEFRELATION DIFFERENT (?X ?Y) :DOCUMENTATION \"True if no two arguments are the same.  This is equivalent to\n`(duplicate-free (list-of ?x ?y ...))' but without the need to generate a\ncollection object.  The main use for this is to state and test pairwise\ninequalities between N entities without having to generate O(N**2) statements.\" :VARIABLE-ARITY TRUE :COMPUTED TRUE :RELATION-SPECIALIST DIFFERENT-SPECIALIST) (DEFRELATION ORDERED ((?C COLLECTION)) :DOCUMENTATION \"?c is ordered if the ordering of its\nmembers is significant.  Lists are ordered, while sets are not.\") (DEFRELATION COMMUTATIVE ((?R RELATION)) :DOCUMENTATION \"A relation ?r is commutative if its truth value is\ninvariant with any permutation of its arguments.\" :=>> (=> (BINARY-RELATION ?R) (SYMMETRIC ?R))) (DEFRELATION REFLEXIVE ((?R RELATION)) :DOCUMENTATION \"A binary relation ?r is reflexive if it is always true when\nboth of its arguments are identical.\" :=>> (BINARY-RELATION ?R) :<=> (NOT (IRREFLEXIVE ?R)) :<= (AND (BINARY-RELATION ?R) (FORALL ?X (HOLDS ?R ?X ?X))) :=> (RELATION-SPECIALIST ?R REFLEXIVE-RELATION-SPECIALIST) :AXIOMS (HANDLES-REVERSE-POLARITY REFLEXIVE-RELATION-SPECIALIST)) (DEFRELATION IRREFLEXIVE ((?R RELATION)) :DOCUMENTATION \"A binary relation ?r is irreflexive if it is false when both\nof its arguments are identical.\" :=>> (BINARY-RELATION ?R) :<=> (NOT (REFLEXIVE ?R)) :<= (AND (BINARY-RELATION ?R) (FORALL ?X (NOT (HOLDS ?R ?X ?X)))) :=> (RELATION-SPECIALIST ?R IRREFLEXIVE-RELATION-SPECIALIST) :AXIOMS (HANDLES-REVERSE-POLARITY IRREFLEXIVE-RELATION-SPECIALIST)) (DEFRELATION SYMMETRIC ((?R RELATION)) :DOCUMENTATION \"A binary relation ?r is symmetric if it is commutative.\" :=>> (BINARY-RELATION ?R) :=>> (COMMUTATIVE ?R) :=>> (FORALL (?X ?Y) (<<= (HOLDS ?R ?X ?Y) (HOLDS ?R ?Y ?X))) :<=> (NOT (ANTISYMMETRIC ?R))) (DEFRELATION ANTISYMMETRIC ((?R RELATION)) :DOCUMENTATION \"A binary relation ?r is antisymmetric if whenever (?r ?x ?y)\nis true (?r ?y ?x) is false unless ?x equals ?y.\" :=>> (BINARY-RELATION ?R) :<=> (NOT (SYMMETRIC ?R)) :=> (FORALL (?X ?Y) (=> (AND (HOLDS ?R ?X ?Y) (NOT (= ?X ?Y))) (NOT (?R ?Y ?X))))) (DEFRELATION TRANSITIVE ((?R RELATION)) :DOCUMENTATION \"A binary relation ?r is transitive if (?r ?x ?y)\nand (?r ?y ?z) implies that (?r ?x ?z).  Note that functions cannot\nbe transitive, since their single-valuedness would not allow multiple\ndifferent values such as (?r ?x ?y) and (?r ?x ?z) due to the Unique\nNames Assumption made by PowerLoom.\" :=>> (AND (BINARY-RELATION ?R) (NOT (FUNCTION ?R))) :=>> (=> (AND (BINARY-RELATION ?R) (?R ?X ?Y) (?R ?Y ?Z)) (?R ?X ?Z))) (DEFRELATION TOTAL ((?R FUNCTION)) :DOCUMENTATION \"True if the function '?r' is defined for all\ncombinations of inputs.  By default, functions are not assumed to\nbe total (unlike Prolog, which 'does' make such an assumption.\nFor example, if we define a two-argument function `foo' and then retrieve\nits value applied to some random instances `a' and `b', we get nothing\nback:\n	 \n   (deffunction foo (?x ?y) :-> ?z)\n   (retrieve ?x (= ?x (foo a b)))\n	\nHowever, if we assert that `foo' is total, then we get a skolem back\nwhen we execute the same retrieve:\n	 \n   (assert (total foo))\n   (retrieve ?x (= ?x (foo a b)))\n	\n\") (DEFRELATION ABSTRACT ((?R RELATION)) :DOCUMENTATION \"True if there are no direct assertions made\nto the relation ?r.\") (DEFFUNCTION CONCEPT-PROTOTYPE ((?C CONCEPT)) :-> ?I :DOCUMENTATION \"Function that, given a concept, returns a prototypical\ninstance that inherits all constraints that apply to any concept member,\nand has no additional constraints.\" :AXIOMS (AND (RELATION-SPECIALIST CONCEPT-PROTOTYPE CONCEPT-PROTOTYPE-SPECIALIST) (TOTAL CONCEPT-PROTOTYPE)) :SYNONYM CLASS-PROTOTYPE) (DEFRULE \"'Instance-of' chained with 'subset-of' rule\" (<= (INSTANCE-OF ?X ?C2) (AND (BOUND-VARIABLES ?C2) (INSTANCE-OF ?X ?C1) (SUBSET-OF ?C1 ?C2)))) (DEFRULE \"'Not instance-of' rule\" (<= (NOT (INSTANCE-OF ?X ?C)) (AND (COLLECTION ?C) (CLOSED ?C) (FAIL (INSTANCE-OF ?X ?C))))) (DEFRULE \"Forward 'instance-of' rule\" (=> (INSTANCE-OF ?X ?C) (AND (CONCEPT ?C) (HOLDS ?C ?X))) :FORWARD? TRUE) (DEFCONCEPT USER-THING (?X) :DOCUMENTATION \"The class of user-defined things.\") (DEFRELATION CASE-MATCH ((?X THING) (?Y THING))) (DEFRULE CASE-MATCH-RULE (FORALL ((?X THING) (?Y THING)) (=> (= ?X ?Y) (CASE-MATCH ?X ?Y)))) (DEFRELATION SOFT-EQ ((?X THING) (?Y THING))) (DEFRULE SOFT-EQ-RULE (FORALL ((?X THING) (?Y THING)) (=> (= ?X ?Y) (SOFT-EQ ?X ?Y)))) (DEFFUNCTION CONTEXT-OF (?X) :-> (?C CONTEXT) :AXIOMS (AND (COMPUTED CONTEXT-OF) (RELATION-COMPUTATION CONTEXT-OF CONTEXT-OF-COMPUTATION) (RELATION-SPECIALIST CONTEXT-OF COMPUTATION-SPECIALIST))) (DEFRELATION DISJOINT ((?C1 COLLECTION) (?C2 COLLECTION)) :DOCUMENTATION \"True if the intersection of ?c1 and ?c2 is empty.\" :IRREFLEXIVE TRUE :<<= (CHEAP-DISJOINT ?C1 ?C2)) (DEFRELATION MUTUALLY-DISJOINT-COLLECTION ((?S SET)) :DOCUMENTATION \"True if the members of ?s are pair-wise disjoint.  Used\nmost often to expresse disjointness constraints between concepts.  For\nexample\n	 \n   (mutually-disjoint-collection (setof MAN WOMAN))\n	\nstates that the concepts MAN and WOMAN are disjoint.\n\" :=>> (=> (AND (MEMBER-OF ?C1 ?S) (MEMBER-OF ?C2 ?S) (NOT (= ?C1 ?C2))) (DISJOINT ?C1 ?C2))) (DEFRELATION COVERING ((?C COLLECTION) (?COVER SET)) :DOCUMENTATION \"True if ?c is a subset of the union of all\ncollections in the set ?cover (see `disjoint-covering').\") (DEFRELATION DISJOINT-COVERING ((?C COLLECTION) (?DISJOINTCOVER SET)) :DOCUMENTATION \"True if ?c is covered by the collections in ?disjointCover\nand if the member sets in ?disjointCover are mutually-disjoint.  For\nexample the concepts `Igneous-Rock', `Metamorphic-Rock', and\n`Sedimentary-Rock' together form a disjoint covering of the concept `Rock'.\" :<<= (AND (COVERING ?C ?DISJOINTCOVER) (MUTUALLY-DISJOINT-COLLECTION ?DISJOINTCOVER))) (DEFRELATION CHEAP-DISJOINT ((?C1 COLLECTION) (?C2 COLLECTION)) :DOCUMENTATION \"Find proof of disjointness without using refutation.\" :<<= (AND (HAS-PARTITION-MEMBERSHIP ?C1) (HAS-PARTITION-MEMBERSHIP ?C2) (EXISTS (?PROPOSITION ?PARTITION1 ?PARTITION2) (AND (PARTITION-MEMBERSHIP ?C1 ?PROPOSITION ?PARTITION1) (PARTITION-MEMBERSHIP ?C2 ?PROPOSITION ?PARTITION2) (NOT (= ?PARTITION1 ?PARTITION2)))))) (DEFRELATION REFUTATION-DISJOINT ((?C1 COLLECTION) (?C2 COLLECTION)) :DOCUMENTATION \"Assume that an instance belongs to both ?c1 and ?c2\nand look for a clash.\" :AXIOMS (RELATION-SPECIALIST REFUTATION-DISJOINT REFUTATION-DISJOINT-SPECIALIST)) (DEFRELATION HAS-PARTITION-MEMBERSHIP ((?C COLLECTION)) :DOCUMENTATION \"TRUE if one or more PARTITION-MEMBERSHIP tuples\nexist with ?c as the first argument.  FALSE if none exists.\nUnknown if a derivation of PARTITION-MEMBERSHIP tuples has not\noccurred.  A specialist for this relation creates PARTITION-MEMBERSHIP\ntuples as a side-effect of querying this predicate.\" :AXIOMS (AND (HIDDEN-RELATION HAS-PARTITION-MEMBERSHIP) (RELATION-SPECIALIST HAS-PARTITION-MEMBERSHIP HAS-PARTITION-MEMBERSHIP-SPECIALIST))) (DEFRELATION PARTITION-MEMBERSHIP ((?C COLLECTION) (?PROPOSITION PROPOSITION) (?PARTITION COLLECTION)) :DOCUMENTATION \"Caches the fact that ?partition is a partition of\na mutually-disjoint collection, and that ?c is a subset of ?partition.\nUsed to support rapid computation of pairwise disjointness.\" :AXIOMS (HIDDEN-RELATION PARTITION-MEMBERSHIP))) \"/PL-KERNEL-KB\")", "/PL-KERNEL-KB");
          PlKernelKb.initializeKernelKb();
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Stella.$MODULE$.set(old$Module$000);
      }
    }
  }

}
