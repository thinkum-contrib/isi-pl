//  -*- Mode: Java -*-
//
// _StartupPlKernelKb.java

/*
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2017      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
*/

package edu.isi.powerloom.pl_kernel_kb;

import edu.isi.stella.javalib.Native;
import edu.isi.stella.javalib.StellaSpecialVariable;
import edu.isi.powerloom.logic.*;
import edu.isi.stella.*;

public class _StartupPlKernelKb {
  public static void startupPlKernelKb() {
    { Object old$Module$000 = Stella.$MODULE$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Stella.$MODULE$, Stella.getStellaModule("/PL-KERNEL-KB", Stella.$STARTUP_TIME_PHASE$ > 1));
        Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
        if (Stella.currentStartupTimePhaseP(2)) {
          PlKernelKb.SYM_PL_KERNEL_KB_STARTUP_PL_KERNEL_KB = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("STARTUP-PL-KERNEL-KB", null, 0)));
        }
        if (Stella.currentStartupTimePhaseP(6)) {
          Stella.finalizeClasses();
        }
        if (Stella.currentStartupTimePhaseP(7)) {
          Stella.defineFunctionObject("INITIALIZE-KERNEL-KB", "(DEFUN INITIALIZE-KERNEL-KB () :DOCUMENTATION \"Bootstrap the PowerLoom built-in kernel KB.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.powerloom.pl_kernel_kb.PlKernelKb", "initializeKernelKb", new java.lang.Class [] {}), null);
          Stella.defineFunctionObject("STARTUP-PL-KERNEL-KB", "(DEFUN STARTUP-PL-KERNEL-KB () :PUBLIC? TRUE)", Native.find_java_method("edu.isi.powerloom.pl_kernel_kb._StartupPlKernelKb", "startupPlKernelKb", new java.lang.Class [] {}), null);
          { MethodSlot function = Symbol.lookupFunction(PlKernelKb.SYM_PL_KERNEL_KB_STARTUP_PL_KERNEL_KB);

            KeyValueList.setDynamicSlotValue(function.dynamicSlots, Logic.SYM_STELLA_METHOD_STARTUP_CLASSNAME, StringWrapper.wrapString("_StartupPlKernelKb"), Stella.NULL_STRING_WRAPPER);
          }
        }
        if (Stella.currentStartupTimePhaseP(8)) {
          Stella.finalizeSlots();
          Stella.cleanupUnfinalizedClasses();
        }
        if (Stella.currentStartupTimePhaseP(9)) {
          Stella_Object.inModule(((StringWrapper)(Stella_Object.copyConsTree(StringWrapper.wrapString("PL-KERNEL")))));
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL *PL-KERNEL-KB-DEFINITIONS* CONS NULL)");
          PlKernelKb.$PL_KERNEL_KB_DEFINITIONS$ = Stella.getQuotedTree(new String().concat("(((DEFCONCEPT CONCEPT (?X RELATION) :DOCUMENTATION \"The class of reified unary relations.  The Powerloom\nnotion of `concept' corresponds to the object-oriented notion of `class'.\nFrom a logic standpoint, the notion of a concept is hard to distinguish\nfrom the notion of `unary relation'.  The conceptual distinction is\nbest illustrated in the domain of linguistics, where concepts are\nidentified with collective nouns while unary relations are identified\nwith adjectives.  For example, `Rock' is a concept, while `rocky' is a\nunary relation.\" :AXIOMS (AND (SYNONYM CONCEPT CLASS) (CLOSED CONCEPT))) (DEFCONCEPT RELATION (?X SET) :DOCUMENTATION \"The class of relations.  This includes all concepts and\nall functions.\" :AXIOMS (CLOSED RELATION)) (DEFCONCEPT FUNCTION (?R RELATION) :DOCUMENTATION \"A relation is a function if its last argument\nis a function of its first n-1 arguments, i.e., if it is a single-valued\nrelation.  Functions explicitly declared as such differ from relations\nin that they may appear syntactically as a term applied to n-1 arguments.\nFor example, to express the sentence \\\"two plus two equals four\\\", because\n`+' is a function we can write `(= (+ 2 2) 4)'.  The same sentence written\nin relational syntax would look like `(+ 2 2 4)'.  If a relation is\nintroduced using the `defrelation' syntax and also declared to be\nsingle-valued, the functional syntax does not apply; only the explicit\nuse of `deffunction' sanctions the use of that syntax.\" :AXIOMS (CLOSED FUNCTION)) (DEFCONCEPT AGGREGATE (?A) :DOCUMENTATION \"?a is an aggregate\") (DEFCONCEPT COLLECTION (?C AGGREGATE) :DOCUMENTATION \"The class of all collections.  This includes all sets,\nlists, concepts, and relations.\" :AXIOMS (ABSTRACT COLLECTION)) (DEFCONCEPT DUPLICATE-FREE-COLLECTION (?C COLLECTION) :DOCUMENTATION \"?c is free of duplicates\" :=>> (DUPLICATE-FREE ?C)) (DEFCONCEPT SET (?S DUPLICATE-FREE-COLLECTION) :DOCUMENTATION \"This class denotes the mathematical notion of a 'set';\na collection that has no duplicates.\") (DEFCONCEPT NUMERIC-SET (?S COLLECTION) :DOCUMENTATION \"?s is a set of numbers\" :AXIOMS (ABSTRACT NUMERIC-SET)) (DEFCONCEPT LIST (?L COLLECTION) :DOCUMENTATION \"A list is an ordered collection of elements.  The range\nof the function `listof' consists of elements of type `List'.\" :=>> (ORDERED ?L)) (DEFCONCEPT GROUP (?C DUPLICATE-FREE-COLLECTION) :DOCUMENTATION \"?c is a group\") (DEFCONCEPT STUFF (?S AGGREGATE) :DOCUMENTATION \"?s is stuff\") (DEFCONCEPT SCALAR (?X) :DOCUMENTATION \"The class of scalar quantities.\") (ASSERT (SUBSET-OF NUMBER SCALAR)) (DEFCONCEPT SCALAR-INTERVAL (?X SCALAR) :DOCUMENTATION \"An interval of scalar quantities. \") (ASSERT (SUBSET-OF INTEGER-INTERVAL SCALAR-INTERVAL)) (DEFRELATION PHRASE (?R (?S STRING)) :DOCUMENTATION \"A phrase is a variablized sentence, a template, that\nis used to express individual axiomatic facts as natural language\nsentences.  By convention, a phrase contains one or more occurrences\nof each variable in a relation or concept definition, it does not\nbegin with a capital letter, and it has no concluding period.\nSystematic attachment of phrases to relations can be leveraged by\ntools that generate natural language paraphrases of logic sentences.\" :PHRASE \"?r has phrase ?s\") (DEFRELATION LEXEME (?R (?S STRING)) :DOCUMENTATION \"?s is a lexeme for the relation or individual ?r.\nA relation or individual ?r can have zero or more lexemes, words that are\nnatural langage equivalents of a logical constant.  The same lexeme may be\nattached to more than one constant.\") (DEFRELATION COMMENT (?X (?S STRING)) :DOCUMENTATION \"?s is a comment attached to ?x.  Comments are\na generalization of other annotations such as `documentation' and\n`issue' strings.\") (DEFRELATION DOCUMENTATION (?X (?S STRING)) :DOCUMENTATION \"?s is a documentation string attached to ?x.  Some\nof the PowerLoom text processing tools look for documentation strings and \nimport them into documents.\" :=> (COMMENT ?X ?S)) (DEFRELATION ISSUE (?X (?S STRING)) :DOCUMENTATION \"?s is an issue attached to ?x.  An issue string \nnormally comments on a topic that has not been resolved to everyone's\nsatisfaction.\" :=> (COMMENT ?X ?S)) (DEFRELATION EXAMPLE ((?R RELATION) ?E) :DOCUMENTATION \"?e is an example of (the use of) ?r.\") (DEFRELATION IMAGE-URL (?X (?URL STRING)) :DOCUMENTATION \"?url is a URL pointing to an image illustrating ?x.\nThe Ontosaurus browser looks for `image-url' values attached to\nobjects it is presenting, and displays them prominently, thereby spiffing\nup its displays.\") (DEFRELATION RELATION-SPECIALIST ((?R RELATION) (?SP COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names a 'specialist' (a function) that evaluates an (atomic) relation\nproposition during query processing.  This defines an extensible\nmeans for computing with the control stack.  The function is passed\na CONTROL-FRAME that contains the proposition, and returns a keyword\n:FINAL-SUCCESS, :CONTINUING-SUCCESS, :FAILURE, or :TERMINAL-FAILURE\nthat controls the result of the computation.\" :AXIOMS (SINGLE-VALUED RELATION-SPECIALIST)) (DEFRELATION RELATION-EVALUATOR ((?R RELATION) (?EV COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names an 'evaluator' (a function) that evaluates an (atomic) relation\nproposition during constraint propagation.  This defines an extensible\nmeans for computing using auxiliary data structures.  The function is passed\na proposition for evaluation which might update the proposition, generate\nadditional assertions or trigger further evaluations.  Evaluators have to\ncheck the truth-value of the passed-in proposition and perform their actions\naccordingly.  An evaluated proposition might be true, false or even unknown\nin case the propositon was just newly constructed.\" :AXIOMS (SINGLE-VALUED RELATION-EVALUATOR)) (DEFRELATION RELATION-COMPUTATION ((?R RELATION) (?COMPUTATION COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names a 'computation' (a function) that evaluates an (atomic) relation\nproposition during query processing.  The function is passed a proposition\nfor evaluation for which all arguments are bound.  The function\nreturns a BOOLEAN if it represents a predicate, or some sort of value\nif it is a function.\" :=>> (RELATION-SPECIALIST ?R COMPUTATION-SPECIALIST) :AXIOMS (SINGLE-VALUED RELATION-COMPUTATION)) (DEFRELATION RELATION-CONSTRAINT ((?R RELATION) (?COMPUTATION COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names a 'computation' (a function) that evaluates an (atomic) relation\nproposition during query processing.  The function is passed a proposition\nfor evaluation for which at most one argument is unbound.  The function\nreturns a BOOLEAN if it represents a predicate, or some sort of value\nif it is a function.  If all arguments are bound the function computes whether\nthe constraint holds.  If all but one argument is bound and the unbound\nargument is a pattern variable then the missing value is computed.\" :=>> (RELATION-SPECIALIST ?R CONSTRAINT-SPECIALIST) :AXIOMS (SINGLE-VALUED RELATION-CONSTRAINT)) (DEFRELATION HANDLES-REVERSE-POLARITY ((?CP COMPUTED-PROCEDURE)) :DOCUMENTATION \"Very specialized PowerLoom predicate.  Indicates that a computed procedure\nused as a relation specialist is programmed to handle reverse\npolarity (*reversePolarity?*).\") (DEFRELATION UPDATE-PROPOSITION-DEMON ((?R RELATION) (?COMPUTATION COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names a 'computation' (a function) that is attached (logically)\nto ?r  Each time a proposition with predicate ?r has its truth\nvalue updated (even redundantly), the function is applied to that\nproposition.\" :AXIOMS (SINGLE-VALUED UPDATE-PROPOSITION-DEMON)) (DEFRELATION GOES-TRUE-DEMON ((?R RELATION) (?COMPUTATION COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names a 'computation' (a function) that is attached (logically)\nto ?r  Each time a proposition with predicate ?r becomes\ntrue, the function is applied to that proposition.\" :AXIOMS (SINGLE-VALUED GOES-TRUE-DEMON)) (DEFRELATION GOES-UNKNOWN-DEMON ((?R RELATION) (?COMPUTATION COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names a 'computation' (a function) that is attached (logically)\nto ?r  Each time a proposition with predicate ?r becomes\nunknown, the function is applied to that proposition.\" :AXIOMS (SINGLE-VALUED GOES-UNKNOWN-DEMON)) (DEFRELATION GOES-FALSE-DEMON ((?R RELATION) (?COMPUTATION COMPUTED-PROCEDURE)) :DOCUMENTATION \"Names a 'computation' (a function) that is attached (logically)\nto ?r  Each time a proposition with predicate ?r becomes\nfalse, the function is applied to that proposition.\" :AXIOMS (SINGLE-VALUED GOES-FALSE-DEMON)) (DEFRELATION SYNONYM (?TERM ?SYNONYM) :PHRASE \"?synonym is a synonym for ?term\" :DOCUMENTATION \"Assert that `?synonym' is a synonym of `?term'.  This\ncauses all references to `?synonym' to be interpreted as references\nto `?term'.  Retraction eliminates a synonym relation.\") (ASSERT (AND (GOES-TRUE-DEMON SYNONYM ASSERT-SYNONYM-DEMON) (GOES-UNKNOWN-DEMON SYNONYM RETRACT-SYNONYM-DEMON))) (DEFCONCEPT SKOLEM-FUNCTION (?X FUNCTION) :DOCUMENTATION \"Skolem function meta class to annotate user-defined skolem\nfunctions.  Using this is generally not necessary given the generic `skolem-fn'\ndefinitiont below.\" :=>> (TOTAL ?X)) (DEFFUNCTION SKOLEM-FN (?ID ?ARGS ?SK) :DOCUMENTATION \"A generic skolem function that can be instantiated into\na unique skolem function term by providing an appropriately unique ?id.\n?args are the universally quantfied arguments relative to which we postulate\nthe existence of ?sk.  For example, to represent the rule `every person\nhas a mother' we could write:\n  (=> (and (person ?x) (skolem-fn $skfn ?x ?m)) (mother ?x ?m)).\nNote the use of the automatic instance `$skfn' to uniquely identify this\nskolem function term.  Any other unique ID could have been used as well.\" :VARIABLE-ARITY TRUE :TOTAL TRUE) (DEFFUNCTION COLLECTIONOF (?M) :-> (?C COLLECTION) :DOCUMENTATION \"Abstract function existing to subsume 'SETOF'\nand 'LISTOF'.\" :AXIOMS (VARIABLE-ARITY COLLECTIONOF)) (DEFFUNCTION SETOF (?M) :-> (?C SET) :DOCUMENTATION \"Term-forming function that defines an enumerated set\nconsisting of all function arguments.  `setof' is like `listof' except\nthat it removes duplicate values.\" :SUBSET-OF COLLECTIONOF :VARIABLE-ARITY TRUE :TOTAL TRUE :CLOSED TRUE) (DEFFUNCTION LISTOF (?M) :-> (?C LIST) :DOCUMENTATION \"Term-forming function that defines an ordered list\nconsisting of all function arguments.  Within logical expressions\n`listof' is most commonly used in conjunction with the `member-of'\npredicate.  For example the query\n	 \n  (retrieve ?x (member-of ?x (listof a b c)))\n	\nreturns the constants `a', `b', and `c' on successive iterations.\" :SUBSET-OF COLLECTIONOF :VARIABLE-ARITY TRUE :TOTAL TRUE :CLOSED TRUE) (DEFRELATION HOLDS ((?RELATION RELATION) ?ARGUMENTS) :DOCUMENTATION \"True if the tuple '?arguments' is a member of the\nrelation '?relation'.  `holds' is a variable arity predicate that takes\na relation as its first argument, and zero or more additional arguments.\nIt returns values equivalent to a subgoal that has the first argument\nas a predicate and the remaining arguments shifted one place to the left.\nFor `holds' to succeed, the (first) relation argument must be bound --\nPowerLoom will NOT cycle through all relations searching for ones that\npermit the proof to succeed.  However, users can obtain the same effect\nif they choose by using other second-order predicates to generate\nrelation bindings.  For example, the query\n	 \n   (retrieve all ?x (and (Relation ?r)\n                         (holds ?r Fred ?x)))\n	\nretrieves all constants for which there is some binary relation that\nrelates `Fred' to that relation.\" :AXIOMS (AND (VARIABLE-ARITY HOLDS) (RELATION-SPECIALIST HOLDS HOLDS-SPECIALIST))) (DEFFUNCTION VALUE ((?FUNCTION FUNCTION) ?ARGUMENTS) :-> ?VALUE :DOCUMENTATION \"True if applying '?function' to '?arguments'\nyields the value '?value'.  The `value' predicate is the analog\nof `holds', except that it applies to functions instead of relations.\" :VARIABLE-ARITY TRUE :RELATION-SPECIALIST HOLDS-SPECIALIST) (DEFFUNCTION TOTAL-VALUE ((?FUNCTION FUNCTION) ?ARGUMENTS) :-> ?VALUE :DOCUMENTATION \"Identical to `value' but treats ?function as a total function even if\nit isn't.  For the case where ?function and all its inputs are bound and no existing\nvalue could be found for the unbound ?value argument, a skolem term will be created and\nbound to ?value.  This is useful sometimes to create function terms on the fly in queries\nfor functions where it isn't generally warranted to mark them as total.\" :VARIABLE-ARITY TRUE :RELATION-SPECIALIST TOTAL-VALUE-SPECIALIST) (DEFRELATION IST ((?CONTEXT CONTEXT) (?P PROPOSITION)) :DOCUMENTATION \"True if proposition '?p' is true in context '?context'.\nThe `IST' (is true) relation allows one to evaluate a query or rule in more\nthan one context.  A common use of `IST' is in defining 'lifting axioms'\nthat import knowledge from one context to another.  For example, below is\na rule that accesses a `patient-record' relation in a module called\n`Medical-Kb', 'lifts-out' the `age' column, and imports it into a\n`has-age' relation in the current context.\n	 \n  (<= (has-age ?person ?age)\n      (and (has-ssn ?person ?ssn)\n           (exists (?1 ?2 ?3 ?4)\n              (ist Medical-Kb (patient-record ?ssn ?1 ?2 ?age ?3 ?4)))))\n	\n\" :AXIOMS (AND (RELATION-SPECIALIST IST IST-SPECIALIST) (HANDLES-REVERSE-POLARITY IST-SPECIALIST))) (DEFRELATION INCOHERENT ((?CONTEXT CONTEXT) (?P PROPOSITION)) :DOCUMENTATION \"True if proposition ?p is inconsistent or otherwise\nincoherent in ?context.  This is a system-asserted relation that is\nused when inconsistencies are detected during forward inference.  The\nmain purpose of this relation is to allow one to find inconsistent propositions\nvia queries and/or to attach a goes-true-demon in case special-purpose handling\nof contradictions is needed.\") (DEFFUNCTION PROPOSITION-RELATION ((?P PROPOSITION) (?OP RELATION)) :DOCUMENTATION \"Return the predicate operator ?op of ?p.\" :COMPUTED TRUE :RELATION-SPECIALIST COMPUTATION-SPECIALIST :RELATION-COMPUTATION PROPOSITION-RELATION-COMPUTATION) (DEFFUNCTION PROPOSITION-ARGUMENT ((?P PROPOSITION) (?I INTEGER) ?ARG) :DOCUMENTATION \"Return the ?i-th ?arg of ?p (zero-based).\" :COMPUTED TRUE :RELATION-SPECIALIST COMPUTATION-SPECIALIST :RELATION-COMPUTATION PROPOSITION-ARGUMENT-COMPUTATION) (DEFFUNCTION PROPOSITION-ARGUMENTS ((?P PROPOSITION) (?ARGS LIST)) :DOCUMENTATION \"Return all arguments of ?p as a list ?args.\" :COMPUTED TRUE :RELATION-SPECIALIST COMPUTATION-SPECIALIST :RELATION-COMPUTATION PROPOSITION-ARGUMENTS-COMPUTATION) (DEFFUNCTION PROPOSITION-ARITY ((?P PROPOSITION) (?ARITY INTEGER)) :DOCUMENTATION \"Return the number of arguments in ?p.\" :COMPUTED TRUE :RELATION-SPECIALIST COMPUTATION-SPECIALIST :RELATION-COMPUTATION PROPOSITION-ARITY-COMPUTATION) (DEFFUNCTION TERM-RELATION (?TERM (?OP RELATION)) :DOCUMENTATION \"Return the function operator ?op defining this function ?term.\" :COMPUTED TRUE :RELATION-SPECIALIST COMPUTATION-SPECIALIST :RELATION-COMPUTATION PROPOSITION-RELATION-COMPUTATION) (DEFFUNCTION TERM-ARGUMENT (?TERM (?I INTEGER) ?ARG) :DOCUMENTATION \"Return the ?i-th ?arg defining this function ?term (zero-based).\" :COMPUTED TRUE :RELATION-SPECIALIST COMPUTATION-SPECIALIST :RELATION-COMPUTATION PROPOSITION-ARGUMENT-COMPUTATION) (DEFFUNCTION TERM-ARGUMENTS (?TERM (?ARGS LIST)) :DOCUMENTATION \"Return all arguments defining this function ?term as a list ?args.\" :COMPUTED TRUE :RELATION-SPECIALIST COMPUTATION-SPECIALIST :RELATION-COMPUTATION PROPOSITION-ARGUMENTS-COMPUTATION) (DEFFUNCTION TERM-ARITY (?TERM (?ARITY INTEGER)) :DOCUMENTATION \"Return the number of arguments defining this function ?term.\" :COMPUTED TRUE :RELATION-SPECIALIST COMPUTATION-SPECIALIST :RELATION-COMPUTATION PROPOSITION-ARITY-COMPUTATION) (DEFRELATION CUT (?ARGUMENTS) :DOCUMENTATION \"Prolog-like CUT.  Succeeds the first time and\nthen fails.  Side-effect:  Locally disables query optimization.\" :AXIOMS (AND (VARIABLE-ARITY CUT) (RELATION-SPECIALIST CUT CUT-SPECIALIST))) (DEFRELATION BOUND-VARIABLES (?ARGUMENTS) :DOCUMENTATION \"True if all arguments are bound.  The `bound-variables'\npredicate is used as a performance enhancer, to prevent other predicates\nfrom backchaining excessively while searching for bindings of certain of\ntheir arguments. Purists will shun the use of this predicate, but some rules\nare inherently inefficient without the addition of some kind of control logic.\nBecause evaluation of the `bound-variables' predicate evaluation of\npredicates being 'guarded', using this predicate has the side-effect\nof locally disabling query optimization.  (See `collect-into-set' for\nan example that uses `bound-variables'.\" :AXIOMS (AND (VARIABLE-ARITY BOUND-VARIABLES) (HANDLES-REVERSE-POLARITY BOUND-VARIABLES-SPECIALIST) (RELATION-SPECIALIST BOUND-VARIABLES BOUND-VARIABLES-SPECIALIST))) (DEFRELATION FORK ((?TEST PROPOSITION) (?THEN PROPOSITION) (?ELSE PROPOSITION)) :DOCUMENTATION \"Fail-based conditional.  If ?test succeeds, evaluates\n?then; otherwise evaluates ?else.\" :AXIOMS (RELATION-SPECIALIST FORK FORK-SPECIALIST)) (DEFRELATION QUERY ((?PROP PROPOSITION) ?OPTIONS) :DOCUMENTATION \"Search-control relation that allows one to prove or\nretrieve bindings for ?prop with modified search control ?options.  The list\nof accepted ?options is currently the same as are legal for a top-level `ask'\nor `retrieve' query.  The special option value :INHERIT inherits the option\nvalue from the parent or top-level query.  The option pair :INHERIT :ALL\ninherits all parent options which can then be further modified by additional\nindividual option specifications.  At most how many solutions will be generated\nis controlled by the :HOW-MANY option (just like in the top level `retrieve').\nThe default is 1 which is again the same as for `retrieve' but different from\nhow normal subgoals behave (those behave in a lazy all solutions mode).\nThe reason for this is that for partial match subqueries, solutions need to be\ngenerated eagerly, therefore, a default of generating all solutions is not\ndesirable.\" :VARIABLE-ARITY TRUE :RELATION-SPECIALIST QUERY-SPECIALIST) (DEFRELATION ASSERTION-QUERY ((?PROP PROPOSITION)) :DOCUMENTATION \"Query ?prop with :inference-level set to :assertion.\nEquivalent to `(query ?prop :inference-level :assertion)' but more efficient.\" :RELATION-SPECIALIST LEVELED-QUERY-SPECIALIST) (DEFRELATION SHALLOW-QUERY ((?PROP PROPOSITION)) :DOCUMENTATION \"Query ?prop with :inference-level set to :shallow.\nEquivalent to `(query ?prop :inference-level :shallow)' but more efficient.\" :RELATION-SPECIALIST LEVELED-QUERY-SPECIALIST) (DEFRELATION SUBSUMPTION-QUERY ((?PROP PROPOSITION)) :DOCUMENTATION \"Query ?prop with :inference-level set to :subsumption.\nEquivalent to `(query ?prop :inference-level :subsumption)' but more efficient.\" :RELATION-SPECIALIST LEVELED-QUERY-SPECIALIST) (DEFRELATION BACKTRACKING-QUERY ((?PROP PROPOSITION)) :DOCUMENTATION \"Query ?prop with :inference-level set to :backtracking.\nEquivalent to `(query ?prop :inference-level :backtracking)' but more efficient.\" :RELATION-SPECIALIST LEVELED-QUERY-SPECIALIST) (DEFRELATION NORMAL-QUERY ((?PROP PROPOSITION)) :DOCUMENTATION \"Query ?prop with :inference-level set to :normal.\nEquivalent to `(query ?prop :inference-level :normal)' but more efficient.\" :RELATION-SPECIALIST LEVELED-QUERY-SPECIALIST) (DEFRELATION REFUTATION-QUERY ((?PROP PROPOSITION)) :DOCUMENTATION \"Query ?prop with :inference-level set to :refutation.\nEquivalent to `(query ?prop :inference-level :refutation)' but more efficient.\" :RELATION-SPECIALIST LEVELED-QUERY-SPECIALIST) (DEFRELATION HIDDEN-RELATION ((?R RELATION)) :DOCUMENTATION \"Indicates that ?r is used like an internal data\nstructure; not for user consumption.\") (DEFFUNCTION OBSERVED-CARDINALITY-OF ((?R RELATION)) :-> (?CARD INTEGER) :DOCUMENTATION \"Used by PowerLoom to record the sizes of class\nand relation extensions.  Only filled if the relation extension was\ndirectly accessed by some query.\" :AXIOMS (HIDDEN-RELATION OBSERVED-CARDINALITY-OF)) (DEFRELATION POLYMORPHIC ((?R RELATION)) :DOCUMENTATION \"True if ?r' supports polymorphism.\") (DEFRELATION INSTANCE-OF ((?X THING) (?C COLLECTION)) :DOCUMENTATION \"True if ?x is an instance of ?c.  Can\nbe used to generate concept values of ?c, given an instance ?x.\" :AXIOMS (RELATION-SPECIALIST INSTANCE-OF INSTANCE-OF-SPECIALIST)) (DEFRELATION DIRECT-INSTANCE-OF ((?X THING) (?C COLLECTION)) :DOCUMENTATION \"True if ?x is a direct instance of ?c which means that ?c is a most specific type of ?x.\nBUGGY, USE AT YOUR OWN RISK.  Currently this implements a mixture of asserted instance\nand direct instance semantics.\" :AXIOMS (RELATION-SPECIALIST DIRECT-INSTANCE-OF DIRECT-INSTANCE-OF-SPECIALIST)) (DEFRELATION TYPE-OF ((?C COLLECTION) (?X THING)) :DOCUMENTATION \"True if ?x is a member of the concept ?c.\" :INVERSE INSTANCE-OF) (DEFRELATION SUBSET-OF ((?SUB COLLECTION) (?SUPER COLLECTION)) :DOCUMENTATION \"True if ?sub is a subset of ?super.  For performance\nreasons, the `subset-of' predicate refuses to search for bindings if\nboth of its variables are unbound.  Implementation note: `subset-of' \nis treated specially internally to PowerLoom, and hence Powerloom does not\npermit the augmentation of `subset-of' with additional inference rules.\nIn otherwords, `subset-of' behaves semantically like an operator instead\nof a relation.\" :AXIOMS (RELATION-SPECIALIST SUBSET-OF SUBSET-OF-SPECIALIST)) (DEFRELATION MEMBER-OF ((?X THING) (?C COLLECTION)) :DOCUMENTATION \"TRUE if ?x is a member of collection ?c.  A common use\nof `member-of' is for binding a variable to successive members in a list\nor set (see `listof' and `setof').\" :AXIOMS (AND (RELATION-SPECIALIST MEMBER-OF MEMBER-OF-SPECIALIST) (HANDLES-REVERSE-POLARITY MEMBER-OF-SPECIALIST) (RELATION-EVALUATOR MEMBER-OF MEMBER-OF-EVALUATOR))) (DEFRELATION PORTION-OF ((?X AGGREGATE) (?Y AGGREGATE)) :PHRASE \"?x is a portion of (a piece of) ?y\" :AXIOMS ((TRANSITIVE PORTION-OF))) (DEFRELATION DOMAIN ((?R RELATION) (?D COLLECTION)) :DOCUMENTATION \"True if for any tuple `T' that satifies ?r, the first\nargument of `T' necessarily belongs to the concept ?d.  `domain' exists\nfor convenience only and is defined in terms of `nth-domain'.  `domain'\nassertions should be avoided, since they create redundant `nth-domain'\npropositions (use `nth-domain' directly).\" :<<=>> (NTH-DOMAIN ?R 0 ?D) :=>> (=>> (HOLDS ?R ?I ?V) (HOLDS ?D ?I))) (DEFRELATION RANGE ((?R RELATION) (?RNG COLLECTION)) :DOCUMENTATION \"True if for any tuple 'T' that satifies ?r, the last\nargument of 'T' necessarily belongs to the concept ?rng.  `range' exists\nfor convenience only and is defined in terms of `nth-domain'.  `range'\nassertions should be avoided, since they create redundant `nth-domain'\npropositions (use `nth-domain' directly).\" :<<= (AND (> (ARITY ?R) 1) (NTH-DOMAIN ?R (- (ARITY ?R) 1) ?RNG)) :=>> (NTH-DOMAIN ?R (- (ARITY ?R) 1) ?RNG) :=>> (=>> (HOLDS ?R ?I ?V) (HOLDS ?RNG ?V))) (DEFRELATION NTH-DOMAIN ((?R RELATION) (?I INTEGER) (?D COLLECTION)) :DOCUMENTATION \"True if the nth value for a tuple T satisfying\n?r must belong to the concept ?d.  Argument counting starts at zero.\" :AXIOMS (<<= (NTH-DOMAIN ?R 0 ?R) (CONCEPT ?R))) (DEFRELATION CLOSED ((?C COLLECTION)) :PHRASE \"?c is closed\" :DOCUMENTATION \"The collection ?c is closed if all of its members are known.\nAsserting that a relation is closed makes certain computations easier.\nFor example, suppose that the relation `happy' is closed,\nimplying that all things that are happy will be asserted as such.\nTo prove `(not (happy Fred))', PowerLoom can use a negation-as-failure \nproof strategy which returns TRUE if `Fred' cannot be proved to be happy.\nAlso, if the relation `children' is closed, then a value for the expression\n`(range-max-cardinality children Fred)' can be inferred merely by\ncounting the number of fillers of the `children' role on `Fred'.\" :RELATION-SPECIALIST CLOSED-SPECIALIST :AXIOMS (HANDLES-REVERSE-POLARITY CLOSED-SPECIALIST)) (DEFRELATION EMPTY ((?C COLLECTION)) :DOCUMENTATION \"The collection ?c is empty if it has no members.  Note\nthat for collections possessing open-world semantics, (e.g., most concepts)\nthe fact that the collection has no known members does not necessarily\nimply that it is empty.\" :AXIOMS (AND (RELATION-SPECIALIST EMPTY EMPTY-SPECIALIST) (COMPUTED EMPTY))) (DEFRELATION SINGLE-VALUED ((?C RELATION)) :DOCUMENTATION \"The relation ?c is single-valued if the value of its\nlast argument is a function of all other arguments.  All functions\nare single-valued (see `function').\" :AXIOMS (AND (HANDLES-REVERSE-POLARITY SINGLE-VALUED-SPECIALIST) (RELATION-SPECIALIST SINGLE-VALUED SINGLE-VALUED-SPECIALIST))) (DEFRELATION COMPUTED ((?C RELATION)) :DOCUMENTATION \"?c is computed if it can be evaluated only if all of\nits input arguments are bound (or all of them if it is a relation).\nConsidered by the query optimizer when looking for generators.\") (DEFFUNCTION THE-ROLESET ((?R RELATION) ?I) :-> (?RS SET) :DOCUMENTATION \"Function that defines a mapping from a relation\nand instance to the skolem that (intensionally) denotes the\ncorresponding set of role fillers.\") (DEFFUNCTION FILLERS ((?R RELATION) ?I) :-> (?MEMBERS SET) :DOCUMENTATION \"Given a relation ?r and instance ?i, returns\na set of known fillers of ?r applied to ?i.  IMPORTANT: this also collects\nintensional fillers such as skolems that might be identical extensionally.\" :<<= (AND (BOUND-VARIABLES ?R ?I) (COLLECT-INTO-SET (SETOFALL ?V (HOLDS ?R ?I ?V)) ?MEMBERS)) :AXIOMS (COMPUTED FILLERS)) (DEFFUNCTION FILLER ((?R RELATION) ?I) :-> ?V :DOCUMENTATION \"Special-purpose version of `fillers' which accesses the single\nfiller ?v for the single-valued relation ?r applied to ?i.  This is primarily useful\nto enable a functional notation to access the value of a single-valued relation that\nis not a function.\" :<<= (AND (BOUND-VARIABLES ?R ?I) (SINGLE-VALUED ?R) (HOLDS ?R ?I ?V)) :COMPUTED TRUE) (DEFFUNCTION CARDINALITY ((?C SET)) :-> (?CARD INTEGER) :DOCUMENTATION \"Function that returns the cardinality of a set.\" :<<= (AND (CLOSED ?C) (LENGTH (COLLECT-INTO-SET ?C) ?CARD))) (DEFCONCEPT FRAME-PREDICATE ((?C RELATION)) :DOCUMENTATION \"A frame predicate is a second-order relation that\nis used to describe constraints on the set of fillers for a binary\nrelation applied to an instance.  Examples of frame predicates are\n`range-cardinality', `range-type', and `numeric-inclusive-minimum'.\nFrame predicates are typically used to capture the kinds of relations\nmanipulated by description logics such as USC/ISI's Loom and W3C's OWL.\") (DEFRELATION RANGE-TYPE ((?R RELATION) ?I (?TYPE COLLECTION)) :DOCUMENTATION \"Relation that specifies a type/range of the relation ?r applied to ?i.\nMultiple range types may be asserted for a single pair <?r,?i>.  Technically,\na retrieval of types for a given pair should include all supertypes\n(superconcepts) of any type that is produced, but for utility's sake,\nonly asserted or directly inferrable types are returned.\" :AXIOMS (=>> (AND (RANGE-TYPE ?R ?I ?TYPE) (FAIL (NTH-DOMAIN ?R 1 ?TYPE))) (FORALL ?V (=>> (HOLDS ?R ?I ?V) (HOLDS ?TYPE ?V)))) :<<=>> (SUBSET-OF (THE-ROLESET ?R ?I) ?TYPE) :<<= (AND (BOUND-VARIABLES ?R ?I ?TYPE) (FORK (AND (SINGLE-VALUED ?R) (EXISTS ?V (HOLDS ?R ?I ?V))) (EXISTS ?V (AND (HOLDS ?R ?I ?V) (HOLDS ?TYPE ?V))) (OR (AND (OR (CLOSED ?R) (CLOSED (THE-ROLESET ?R ?I))) (FORALL ?V (=> (HOLDS ?R ?I ?V) (HOLDS ?TYPE ?V)))) (EXISTS (?SUPERR ?SUPERVT) (AND (SUBSET-OF ?R ?SUPERR) (RANGE-TYPE ?SUPERR ?I ?SUPERVT) (SUBSET-OF ?SUPERVT ?TYPE)))))) :COMPUTED TRUE :FRAME-PREDICATE TRUE :RELATION-SPECIALIST RANGE-TYPE-SPECIALIST) (DEFRELATION RANGE-CARDINALITY-LOWER-BOUND ((?R RELATION) ?I (?LB INTEGER)) :DOCUMENTATION \"Relation that specifies a lower bound on the cardinality \nof the set of fillers of the relation ?r applied to ?i.  The difference\nbetween `range-cardinality-lower-bound' and `range-min-cardinality' is\nsubtle but significant.   Suppose we state that nine is a lower bound\non the number of planets in the solar system, and then ask if eight is\n(also) a lower bound:\n	 \n   (assert (range-cardinality-lower-bound hasPlanets SolarSystem 9))\n   (ask (range-cardinality-lower-bound hasPlanets SolarSystem 8))  ==> TRUE\n	\nPowerLoom will return TRUE.  However if we ask if the minimum cardinality\nof the solar system's planets is eight, we get back UNKNOWN\n	 \n   (ask (range-min-cardinality hasPlanets SolarSystem 8)) ==> UNKNOWN\n	\nbecause eight is not the tightest lower bound.\" :AXIOMS (<<= (RANGE-CARDINALITY-LOWER-BOUND ?R ?I ?LB) (AND (BOUND-VARIABLES ?R ?I ?LB) (=< ?LB (RANGE-MIN-CARDINALITY ?R ?I)))) :AXIOMS (=>> (RANGE-CARDINALITY-LOWER-BOUND ?R ?I ?LB) (>= (CARDINALITY (THE-ROLESET ?R ?I)) ?LB)) :AXIOMS (AND (FRAME-PREDICATE RANGE-CARDINALITY-LOWER-BOUND) (RELATION-SPECIALIST RANGE-CARDINALITY-LOWER-BOUND RANGE-MIN-CARDINALITY-SPECIALIST) (HANDLES-REVERSE-POLARITY RANGE-MIN-CARDINALITY-SPECIALIST))) (DEFRELATION RANGE-CARDINALITY-UPPER-BOUND ((?R RELATION) ?I (?UB INTEGER)) :DOCUMENTATION \"Relation that specifies an upper bound on the cardinality \nof the set of fillers of the relation ?r applied to ?i. (see the discussion\nfor `range-cardinality-lower-bound').\" :AXIOMS (<<= (RANGE-CARDINALITY-UPPER-BOUND ?R ?I ?UB) (AND (BOUND-VARIABLES ?R ?I ?UB) (>= ?UB (RANGE-MAX-CARDINALITY ?R ?I)))) :AXIOMS (=>> (RANGE-CARDINALITY-UPPER-BOUND ?R ?I ?UB) (=< (CARDINALITY (THE-ROLESET ?R ?I)) ?UB)) :AXIOMS (AND (FRAME-PREDICATE RANGE-CARDINALITY-UPPER-BOUND) (RELATION-SPECIALIST RANGE-CARDINALITY-UPPER-BOUND RANGE-MAX-CARDINALITY-SPECIALIST) (HANDLES-REVERSE-POLARITY RANGE-MAX-CARDINALITY-SPECIALIST))) (DEFFUNCTION RANGE-CARDINALITY ((?R RELATION) ?I) :-> (?CARD INTEGER) :DOCUMENTATION \"Function that returns the cardinality of the set\nof fillers of the relation ?r applied to ?i.  The cardinality function\nreturns a value only when the relations `range-min-cardinality' and\n`range-max-cardinality' compute identical values, i.e., when the\nbest lower and upper bounds on the cardinality are equal.  Each of\nthese bounding functions employs a variety of rules to try and\ncompute a tight bound.\" :<=> (AND (RANGE-MIN-CARDINALITY ?R ?I ?CARD) (RANGE-MAX-CARDINALITY ?R ?I ?CARD)) :AXIOMS (=>> (RANGE-CARDINALITY ?R ?I ?CARD) (= (CARDINALITY (THE-ROLESET ?R ?I)) ?CARD)) :AXIOMS (AND (FRAME-PREDICATE RANGE-CARDINALITY) (COMPUTED RANGE-CARDINALITY))) (DEFFUNCTION RANGE-MIN-CARDINALITY ((?R RELATION) ?I) :-> (?MINCARD INTEGER) :DOCUMENTATION \"Returns the strictest computable lower bound on the\ncardinality of the set of fillers of the relation ?r applied to ?i.\n(see the discussion for `range-cardinality-lower-bound').\" :<<= (OR (AND (SINGLE-VALUED ?R) (EXISTS ?V (HOLDS ?R ?I ?V)) (= ?MINCARD 1)) (MAXIMUM-VALUE (COLLECT-INTO-SET (SETOFALL ?M (OR (>= (CARDINALITY (THE-ROLESET ?R ?I)) ?M) (= ?M 0) (LENGTH (FILLERS ?R ?I) ?M) (EXISTS ?SUBR (AND (SUBSET-OF ?SUBR ?R) (>= (CARDINALITY (THE-ROLESET ?SUBR ?I)) ?M)))))) ?MINCARD)) :AXIOMS (AND (FRAME-PREDICATE RANGE-MIN-CARDINALITY))) (DEFFUNCTION RANGE-MAX-CARDINALITY ((?R RELATION) ?I) :-> (?MAXCARD INTEGER) :DOCUMENTATION \"Returns the strictest computable upper bound on the\ncardinality of the set of fillers of the relation ?r applied to ?i.\n(see the discussion for `range-cardinality-lower-bound').\" :<<= (OR (AND (SINGLE-VALUED ?R) (EXISTS ?V (HOLDS ?R ?I ?V)) (= ?MAXCARD 1)) (MINIMUM-VALUE (COLLECT-INTO-SET (SETOFALL ?M (OR (=< (CARDINALITY (THE-ROLESET ?R ?I)) ?M) (AND (SINGLE-VALUED ?R) (= ?M 1)) (AND (EMPTY (THE-ROLESET ?R ?I)) (= ?M 0)) (AND (CLOSED ?R) (RANGE-MIN-CARDINALITY ?R ?I ?M)) (EXISTS ?SUPERR (AND (SUBSET-OF ?R ?SUPERR) (=< (CARDINALITY (THE-ROLESET ?SUPERR ?I)) ?M)))))) ?MAXCARD)) :AXIOMS (AND (FRAME-PREDICATE RANGE-MAX-CARDINALITY) (=> (EXISTS (?MIN) (AND (RANGE-MIN-CARDINALITY ?R ?I ?MIN) (> ?MIN ?MAX))) (NOT (RANGE-MAX-CARDINALITY ?R ?I ?MAX))))) (DEFRELATION QUALIFIED-RANGE-CARDINALITY-LOWER-BOUND ((?R RELATION) ?I (?Q COLLECTION) (?LB INTEGER)) :DOCUMENTATION \"Lower bound on range cardinality for qualified cardinality restrictions.  Like `range-cardinality-lower-bound'.  NOT IMPLEMENTED YET!\") (DEFRELATION QUALIFIED-RANGE-CARDINALITY-UPPER-BOUND ((?R RELATION) ?I (?Q COLLECTION) (?UB INTEGER)) :DOCUMENTATION \"Upper bound on range cardinality for qualified cardinality restrictions.  Like `range-cardinality-upper-bound'.  NOT IMPLEMENTED YET!\") (DEFFUNCTION QUALIFIED-RANGE-MIN-CARDINALITY ((?R RELATION) ?I (?Q COLLECTION)) :-> (?CARD INTEGER) :DOCUMENTATION \"Function that returns the minimum cardinality of the set of\nfillers of type ?q of the relation ?r applied to ?i.  NOT YET IMPLEMENTED.\" :AXIOMS (AND (FRAME-PREDICATE QUALIFIED-RANGE-MIN-CARDINALITY) (COMPUTED QUALIFIED-RANGE-MIN-CARDINALITY))) (DEFFUNCTION QUALIFIED-RANGE-MAX-CARDINALITY ((?R RELATION) ?I (?Q COLLECTION)) :-> (?CARD INTEGER) :DOCUMENTATION \"Function that returns the maximum cardinality of the set of\nfillers of type ?q of the relation ?r applied to ?i.  NOT YET IMPLEMENTED.\" :AXIOMS (AND (FRAME-PREDICATE QUALIFIED-RANGE-MAX-CARDINALITY) (COMPUTED QUALIFIED-RANGE-MAX-CARDINALITY))) (DEFFUNCTION QUALIFIED-RANGE-CARDINALITY ((?R RELATION) ?I (?Q COLLECTION)) :-> (?CARD INTEGER) :DOCUMENTATION \"Function that returns the cardinality of the set of\nfillers of type ?q of the relation ?r applied to ?i.  The cardinality function\nreturns a value only when the relations `qualified-range-min-cardinality' and\n`qualified-range-max-cardinality' compute identical values, i.e., when the\nbest lower and upper bounds on the cardinality are equal.  Each of\nthese bounding functions employs a variety of rules to try and\ncompute a tight bound.  NOT YET IMPLEMENTED.\" :AXIOMS (AND (FRAME-PREDICATE QUALIFIED-RANGE-CARDINALITY) (COMPUTED QUALIFIED-RANGE-CARDINALITY))) (DEFFUNCTION NUMERIC-INTERVAL ((?X NUMERIC-SET)) :-> (?INTERVAL INTEGER-INTERVAL) :DOCUMENTATION \"Function that returns an interval representing\nthe range of allowable numeric values for its members.\" :=>> (SCALAR-INTERVAL ?INTERVAL)) (DEFFUNCTION INTERVAL-CACHE-OF (?X) :-> (?B INTERVAL-CACHE) :DOCUMENTATION \"Binds an instance ?x of type NUMBER or QUANTITY to a \nstructure that records its tightest lower and upper bounds.\" :AXIOMS (HIDDEN-RELATION INTERVAL-CACHE-OF)) (DEFRELATION NUMERIC-MINIMUM ((?R RELATION) ?I (?N NUMBER)) :DOCUMENTATION \"Relation that specifies a lower bound '?n' on any numeric\nvalue that can belong to the set of fillers of the relation ?r applied to ?i.\" :<<=>> (>= (INTERVAL-LOWER-BOUND (NUMERIC-INTERVAL (THE-ROLESET ?R ?I))) ?N) :AXIOMS (FRAME-PREDICATE NUMERIC-MINIMUM)) (DEFRELATION NUMERIC-MAXIMUM ((?R RELATION) ?I (?N NUMBER)) :DOCUMENTATION \"Relation that specifies an upper bound '?n' on any numeric\nvalue that can belong to the set of fillers of the relation ?r applied to ?i.\" :<<=>> (=< (INTERVAL-UPPER-BOUND (NUMERIC-INTERVAL (THE-ROLESET ?R ?I))) ?N) :AXIOMS (FRAME-PREDICATE NUMERIC-MAXIMUM)) (DEFRELATION DIRECT-SUBRELATION ((?R RELATION) (?SUB RELATION)) :DOCUMENTATION \"True iff ?sub is a direct subrelation of ?r; written\nin set notation, ?sub < ?r, and there is no ?s such that ?sub < ?s < ?r.\nThis relation will generate bindings for at most one unbound argument.\" :AXIOMS (RELATION-SPECIALIST DIRECT-SUBRELATION RELATION-HIERARCHY-SPECIALIST)) (DEFRELATION DIRECT-SUPERRELATION ((?R RELATION) (?SUPER RELATION)) :DOCUMENTATION \"True iff ?super is a direct superrelation of ?r;\nin set notation, ?super > ?r, and there is no ?s such that ?super > ?s > ?r.\nThis relation will generate bindings for at most one unbound argument.\" :AXIOMS (AND (INVERSE DIRECT-SUPERRELATION DIRECT-SUBRELATION) (RELATION-SPECIALIST DIRECT-SUPERRELATION RELATION-HIERARCHY-SPECIALIST))) (DEFRELATION SUBRELATION ((?R RELATION) (?SUB RELATION)) :DOCUMENTATION \"True iff ?sub is a subrelation of ?r; written in set\nnotation, ?sub =< ?r.  This relation will generate bindings for at most\none unbound argument.\" :AXIOMS (RELATION-SPECIALIST SUBRELATION RELATION-HIERARCHY-SPECIALIST)) (DEFRELATION SUPERRELATION ((?R RELATION) (?SUPER RELATION)) :DOCUMENTATION \"True iff ?super is a superrelation of ?r; written in set\nnotation, ?super >= ?r.  This relation will generate bindings for at most\none unbound argument.\" :AXIOMS (AND (INVERSE SUPERRELATION SUBRELATION) (RELATION-SPECIALIST SUPERRELATION RELATION-HIERARCHY-SPECIALIST))) (DEFRELATION PROPER-SUBRELATION ((?R RELATION) (?SUB RELATION)) :DOCUMENTATION \"True iff ?sub is a proper subrelation of ?r; written in\nset notation, ?sub < ?r.  This relation will generate bindings for at most\none unbound argument.\" :AXIOMS (RELATION-SPECIALIST PROPER-SUBRELATION RELATION-HIERARCHY-SPECIALIST)) (DEFRELATION PROPER-SUPERRELATION ((?R RELATION) (?SUPER RELATION)) :DOCUMENTATION \"True iff ?super is a proper superrelation of ?r; written in\nset notation, ?super > ?r.  This relation will generate bindings for at most\none unbound argument.\" :AXIOMS (AND (INVERSE PROPER-SUPERRELATION PROPER-SUBRELATION) (RELATION-SPECIALIST PROPER-SUPERRELATION RELATION-HIERARCHY-SPECIALIST))) (DEFRELATION EQUIVALENT-RELATION ((?R RELATION) (?EQUIV RELATION)) :DOCUMENTATION \"True if ?r is equivalent to ?equiv; written in set notation,\n?r = ?equiv.  This relation will generate bindings for at most one unbound\nargument.\" :AXIOMS (RELATION-SPECIALIST EQUIVALENT-RELATION RELATION-HIERARCHY-SPECIALIST)) (DEFFUNCTION UNION-OF ((?S1 COLLECTION) (?S2 COLLECTION)) :-> (?UNION SET) :DOCUMENTATION \"True if the union of the collections ?s1 and ?s2\nequals ?union.\") (DEFFUNCTION + ((?X NUMBER) (?Y NUMBER)) :-> (?Z NUMBER) :DOCUMENTATION \"Function that adds two numbers.\") (ASSERT (AND (COMPUTED +) (RELATION-CONSTRAINT + PLUS-CONSTRAINT) (RELATION-SPECIALIST + CONSTRAINT-SPECIALIST))) (DEFFUNCTION - ((?X NUMBER) (?Y NUMBER)) :-> (?Z NUMBER) :DOCUMENTATION \"Function that subtracts two numbers.\") (ASSERT (AND (COMPUTED -) (RELATION-CONSTRAINT - MINUS-CONSTRAINT) (RELATION-SPECIALIST - CONSTRAINT-SPECIALIST))) (DEFFUNCTION * ((?X NUMBER) (?Y NUMBER)) :-> (?Z NUMBER) :DOCUMENTATION \"Function that multiplies two numbers.\") (ASSERT (AND (COMPUTED *) (RELATION-CONSTRAINT * TIMES-CONSTRAINT) (RELATION-SPECIALIST * CONSTRAINT-SPECIALIST))) (DEFFUNCTION / ((?X NUMBER) (?Y NUMBER)) :-> (?Z NUMBER) :DOCUMENTATION \"Function that divides two numbers.\") (ASSERT (AND (COMPUTED /) (RELATION-CONSTRAINT / DIVIDE-CONSTRAINT) (RELATION-SPECIALIST / CONSTRAINT-SPECIALIST))) (DEFFUNCTION SQRT ((?X NUMBER)) :-> (?Y NUMBER) :DOCUMENTATION \"Function that returns the positive square root:\n?y = sqrt(?x).  For positive and negative roots see relation SQUARE-ROOT\" :AXIOMS (AND (COMPUTED SQRT) (RELATION-CONSTRAINT SQRT SQRT-CONSTRAINT) (RELATION-SPECIALIST SQRT CONSTRAINT-SPECIALIST))) (DEFRELATION SQUARE-ROOT ((?X NUMBER) (?Y NUMBER)) :DOCUMENTATION \"Relation that returns the positive and negative square roots:\n?y = sqrt(?x).  For positive roots only see function SQRT.\" :AXIOMS (AND (COMPUTED SQUARE-ROOT) (RELATION-SPECIALIST SQUARE-ROOT SQUARE-ROOT-SPECIALIST))) (DEFFUNCTION ABSOLUTE-VALUE ((?X NUMBER) (?Y NUMBER)) :DOCUMENTATION \"Relation that computes ?y = abs(?x).  If ?x is unbound,\nthen ?x will get both positive and negative values of the \nmagnitude of ?y.\" :AXIOMS (AND (COMPUTED ABSOLUTE-VALUE) (RELATION-SPECIALIST ABSOLUTE-VALUE ABSOLUTE-VALUE-SPECIALIST))) (DEFFUNCTION NEGATE ((?X NUMBER) (?Y NUMBER)) :DOCUMENTATION \"Relation that computes ?y = - ?x.\" :AXIOMS (AND (COMPUTED NEGATE) (RELATION-CONSTRAINT NEGATE NEGATE-CONSTRAINT) (RELATION-SPECIALIST NEGATE CONSTRAINT-SPECIALIST))) (DEFFUNCTION FLOOR ((?X NUMBER) (?Y INTEGER)) :DOCUMENTATION \"Compute the biggest integer ?y <= ?x.\" :RELATION-SPECIALIST COMPUTATION-SPECIALIST :RELATION-COMPUTATION FLOOR-COMPUTATION) (DEFFUNCTION CEILING ((?X NUMBER) (?Y INTEGER)) :DOCUMENTATION \"Compute the smallest integer ?y >= ?x.\" :RELATION-SPECIALIST COMPUTATION-SPECIALIST :RELATION-COMPUTATION CEILING-COMPUTATION) (DEFFUNCTION LOG ((?X NUMBER) (?LOG NUMBER)) :DOCUMENTATION \"Compute the natural logarithm (base e) of ?x.\" :RELATION-CONSTRAINT LOG-CONSTRAINT :RELATION-SPECIALIST CONSTRAINT-SPECIALIST) (DEFFUNCTION LOG10 ((?X NUMBER) (?LOG NUMBER)) :DOCUMENTATION \"Compute the base-10 logarithm of ?x.\" :RELATION-CONSTRAINT LOG10-CONSTRAINT :RELATION-SPECIALIST CONSTRAINT-SPECIALIST) (DEFFUNCTION EXP ((?X NUMBER) (?Y NUMBER)) :DOCUMENTATION \"Compute ?y = e to the power ?x.\" :RELATION-CONSTRAINT EXP-CONSTRAINT :RELATION-SPECIALIST CONSTRAINT-SPECIALIST) (DEFFUNCTION EXPT ((?X NUMBER) (?N NUMBER) (?Y NUMBER)) :DOCUMENTATION \"Compute ?y = ?x to the power ?n.\" :RELATION-COMPUTATION EXPT-COMPUTATION) (ASSERT (HANDLES-REVERSE-POLARITY INEQUALITY-SPECIALIST)) (DEFRELATION INEQUALITY (?X ?Y) :DOCUMENTATION \"Abstract superrelation of inequality relations.\" :<<= (=< ?X ?Y) :<<= (>= ?X ?Y) :AXIOMS (ABSTRACT INEQUALITY)) (DEFRELATION < (?X ?Y) :DOCUMENTATION \"True if ?x < ?y.\" :<<= (EXISTS ?Z (AND (< ?X ?Z) (=< ?Z ?Y))) :<<= (EXISTS ?Z (AND (=< ?X ?Z) (< ?Z ?Y)))) (ASSERT (AND (COMPUTED <) (RELATION-SPECIALIST < INEQUALITY-SPECIALIST) (RELATION-EVALUATOR < INEQUALITY-EVALUATOR))) (DEFRELATION =< (?X ?Y) :DOCUMENTATION \"True if ?x <= ?y.\" :<<= (EXISTS ?Z (AND (=< ?X ?Z) (=< ?Z ?Y))) :<<= (< ?X ?Y)) (ASSERT (AND (COMPUTED =<) (RELATION-SPECIALIST =< INEQUALITY-SPECIALIST) (RELATION-EVALUATOR =< INEQUALITY-EVALUATOR))) (DEFRELATION > (?X ?Y) :DOCUMENTATION \"True if ?x > ?y.\" :<<=>> (< ?Y ?X)) (ASSERT (AND (COMPUTED >) (RELATION-SPECIALIST > INEQUALITY-SPECIALIST) (RELATION-EVALUATOR > INEQUALITY-EVALUATOR))) (DEFRELATION >= (?X ?Y) :DOCUMENTATION \"True if ?x >= ?y.\" :<<=>> (=< ?Y ?X) :<<= (> ?X ?Y)) (ASSERT (AND (COMPUTED >=) (RELATION-SPECIALIST >= INEQUALITY-SPECIALIST) (RELATION-EVALUATOR >= INEQUALITY-EVALUATOR))) (DEFFUNCTION COLLECT-INTO-SET ((?C COLLECTION)) :-> (?L SET) :DOCUMENTATION \"Infer as many members of ?c as possible and\ncollect them into a set ?l.  For example, here is a rule\nused to compute bindings for the `fillers' predicate:\n	 \n  (<= (fillers ?r ?i ?members)\n      (and (bound-variables ?r ?i)\n           (collect-into-set (setofall ?v (holds ?r ?i ?v)) ?members)))\n	\nWhen `?r' and `?i' are bound, the term `(setofall ?v (holds ?r ?i ?v))'\nevaluates to a unary relation satisfied for each filler of the relation\nin `?r' applied to the instance in `?i'.  `collect-into-set' causes\nthe extension of this (dynamically-defined) unary relation to be\ncomputed.  Note the use of `bound-variables' to screen out unbound\nvariables before they are passed to the `setofall' term.\" :RELATION-SPECIALIST COLLECT-MEMBERS-SPECIALIST) (DEFFUNCTION COLLECT-INTO-LIST ((?C COLLECTION)) :-> (?L LIST) :DOCUMENTATION \"Infer as many members of ?c as possible and\ncollect them into a list ?l.  This is similar to `collect-into-set'\nbut collects members in the order they are encountered.  If a member\nis derived multiple times, all occurrences are kept.  This is\nuseful, for example, to collect and then sum up number-valued\nattributes of objects.\" :RELATION-SPECIALIST COLLECT-MEMBERS-SPECIALIST) (DEFFUNCTION COLLECT-INTO-ORDERED-SET ((?C COLLECTION)) :-> (?L LIST) :DOCUMENTATION \"This is similar to `collect-into-list', but if a\nmember is derived multiple times, only the first occurrence is kept\n- hence, the name, even though ordered sets are represented as lists.\" :RELATION-SPECIALIST COLLECT-MEMBERS-SPECIALIST) (DEFFUNCTION COLLECT-INTO-ASCENDING-SET ((?C COLLECTION) (?SORTBY RELATION) (?ORDEREDSET LIST)) :DOCUMENTATION \"Collect elements of ?c into an ascending ?orderedSet where the position of each\nelement is determined by the value computed for it by the ?sortBy relation.  Ordering is done via\nsorting (as opposed to using a comparison relation) similar to the :sort-by option to the `retrieve'\ncommand.  If ?sortBy is not single-valued, the position of an element is determined by its largest\n?sortBy value.  Note that, similar to other `collect-into-...' functions, ?c can be a named concept,\na `setofall' or an enumerated collection, and ?sortBy can be a named relation or a `kappa'.\" :<<= (COLLECT-INTO-ORDERED-SET (SETOFALL (?ELEMENT) (EXISTS ?VALUE (QUERY (AND (FAIL (BOUND-VARIABLES ?VALUE)) (MEMBER-OF ?ELEMENT ?C) (HOLDS ?SORTBY ?ELEMENT ?VALUE)) :HOW-MANY :ALL :SORT-BY :VALUES-ASCENDING :MAXIMUM-DEPTH :INHERIT))) ?ORDEREDSET) :COMPUTED TRUE) (DEFFUNCTION COLLECT-INTO-DESCENDING-SET ((?C COLLECTION) (?SORTBY RELATION) (?ORDEREDSET LIST)) :DOCUMENTATION \"Collect elements of ?c into a descending ?orderedSet where the position of each\nelement is determined by the value computed for it by the ?sortBy relation.  Ordering is done via\nsorting (as opposed to using a comparison relation) similar to the :sort-by option to the `retrieve'\ncommand.  If ?sortBy is not single-valued, the position of an element is determined by its largest\n?sortBy value.  Note that, similar to other `collect-into-...' functions, ?c can be a named concept,\na `setofall' or an enumerated collection, and ?sortBy can be a named relation or a `kappa'.\" :<<= (COLLECT-INTO-ORDERED-SET (SETOFALL (?ELEMENT) (EXISTS ?VALUE (QUERY (AND (FAIL (BOUND-VARIABLES ?VALUE)) (MEMBER-OF ?ELEMENT ?C) (HOLDS ?SORTBY ?ELEMENT ?VALUE)) :HOW-MANY :ALL :SORT-BY :VALUES-DESCENDING :MAXIMUM-DEPTH :INHERIT))) ?ORDEREDSET) :COMPUTED TRUE) (DEFRELATION MINIMUM-ELEMENT ((?C COLLECTION) (?SORTBY RELATION) ?ELEMENT) :DOCUMENTATION \"Find those ?element(s) of ?c with the minimum ?sortBy value, for example,\n`(retrieve (minimum-element relation arity ?x))' (see also `collect-into-ascending-set').\" :<<= (EXISTS (?ORDEREDSET ?FIRSTELEMENT ?MINVALUE) (AND (COLLECT-INTO-ASCENDING-SET ?C ?SORTBY ?ORDEREDSET) (NTH-ELEMENT ?ORDEREDSET 0 ?FIRSTELEMENT) (FORK (SINGLE-VALUED ?SORTBY) (HOLDS ?SORTBY ?FIRSTELEMENT ?MINVALUE) (AND (QUERY (HOLDS ?SORTBY ?FIRSTELEMENT ?MINVALUE) :HOW-MANY :ALL :SORT-BY :VALUES-ASCENDING :MAXIMUM-DEPTH :INHERIT) (CUT))) (MEMBER-OF ?ELEMENT ?ORDEREDSET) (HOLDS ?SORTBY ?ELEMENT ?MINVALUE))) :COMPUTED TRUE) (DEFRELATION MAXIMUM-ELEMENT ((?C COLLECTION) (?SORTBY RELATION) ?ELEMENT) :DOCUMENTATION \"Find those ?element(s) of ?c with the maximum ?sortBy value, for example,\n`(retrieve (maximum-element relation arity ?x))' (see also `collect-into-descending-set').\" :<<= (EXISTS (?ORDEREDSET ?FIRSTELEMENT ?MAXVALUE) (AND (COLLECT-INTO-DESCENDING-SET ?C ?SORTBY ?ORDEREDSET) (NTH-ELEMENT ?ORDEREDSET 0 ?FIRSTELEMENT) (FORK (SINGLE-VALUED ?SORTBY) (HOLDS ?SORTBY ?FIRSTELEMENT ?MAXVALUE) (AND (QUERY (HOLDS ?SORTBY ?FIRSTELEMENT ?MAXVALUE) :HOW-MANY :ALL :SORT-BY :VALUES-DESCENDING :MAXIMUM-DEPTH :INHERIT) (CUT))) (MEMBER-OF ?ELEMENT ?ORDEREDSET) (HOLDS ?SORTBY ?ELEMENT ?MAXVALUE))) :COMPUTED TRUE) (DEFFUNCTION NTH-ELEMENT ((?L COLLECTION) (?N INTEGER) (?E THING)) :DOCUMENTATION \"Return the ?n-th element ?e of ?l (zero-based).\nCount from end of the list if ?n is negative.  If ?n is unbound\nand ?e is bound, this computes the position of ?e.  If both are\nunbound, collection elements and their respective positions will\nbe enumerated.\" :RELATION-SPECIALIST NTH-ELEMENT-SPECIALIST :CLOSED TRUE) (DEFFUNCTION FIRST-ELEMENT ((?L COLLECTION) (?E THING)) :DOCUMENTATION \"Return the first element ?e of ?l.\" :COMPUTED TRUE :<<=>> (NTH-ELEMENT ?L 0 ?E) :CLOSED TRUE) (DEFFUNCTION SECOND-ELEMENT ((?L COLLECTION) (?E THING)) :DOCUMENTATION \"Return the second element ?e of ?l.\" :COMPUTED TRUE :<<=>> (NTH-ELEMENT ?L 1 ?E) :CLOSED TRUE) (DEFFUNCTION THIRD-ELEMENT ((?L COLLECTION) (?E THING)) :DOCUMENTATION \"Return the third element ?e of ?l.\" :COMPUTED TRUE :<<=>> (NTH-ELEMENT ?L 2 ?E) :CLOSED TRUE) (DEFFUNCTION FOURTH-ELEMENT ((?L COLLECTION) (?E THING)) :DOCUMENTATION \"Return the fourth element ?e of ?l.\" :COMPUTED TRUE :<<=>> (NTH-ELEMENT ?L 3 ?E) :CLOSED TRUE) (DEFFUNCTION FIFTH-ELEMENT ((?L COLLECTION) (?E THING)) :DOCUMENTATION \"Return the fifth element ?e of ?l.\" :COMPUTED TRUE :<<=>> (NTH-ELEMENT ?L 4 ?E) :CLOSED TRUE) (DEFFUNCTION NTH-HEAD ((?L LIST) (?N INTEGER) (?H LIST)) :DOCUMENTATION \"Return the ?n head elements ?h of ?l.\nCount from end of the list if ?n is negative.\" :COMPUTED TRUE :RELATION-SPECIALIST COMPUTATION-SPECIALIST :RELATION-COMPUTATION NTH-HEAD-COMPUTATION :CLOSED TRUE) (DEFFUNCTION NTH-REST ((?L LIST) (?N INTEGER) (?R LIST)) :DOCUMENTATION \"Return the ?n-th rest ?r of ?l (zero-based).\nCount from end of the list if ?n is negative.\" :COMPUTED TRUE :RELATION-SPECIALIST COMPUTATION-SPECIALIST :RELATION-COMPUTATION NTH-REST-COMPUTATION :CLOSED TRUE) (DEFFUNCTION INSERT-ELEMENT ((?L LIST) (?N INTEGER) (?E THING) (?R LIST)) :DOCUMENTATION \"Add ?e at position ?n (zero-based) to ?l to construct ?r\n (shifts the remaining elements right).  Count from end of the list and shift\nleft if ?n is  negative such that -1 inserts at the end of the list, -2 second\nto last, etc.\" :COMPUTED TRUE :RELATION-SPECIALIST COMPUTATION-SPECIALIST :RELATION-COMPUTATION INSERT-ELEMENT-COMPUTATION :CLOSED TRUE) (DEFFUNCTION LIST-CONCATENATE ((?X COLLECTION) (?Y COLLECTION) (?R LIST)) :DOCUMENTATION \"Concatenate lists ?x and ?y into ?r.  If ?x and/or ?y\nare not lists but sets or more general collections, the order of the\nelements in the result list ?r will be arbitrary.\" :<<= (COLLECT-INTO-LIST (SETOFALL ?E (OR (MEMBER-OF ?E ?X) (MEMBER-OF ?E ?Y))) ?R) :COMPUTED TRUE :CLOSED TRUE) (DEFRELATION MINIMUM-VALUE ((?L COLLECTION) (?MIN NUMBER)) :DOCUMENTATION \"Binds ?min to the minimum of the numbers in the list ?l.\" :AXIOMS (AND (RELATION-SPECIALIST MINIMUM-VALUE MINIMUM-OF-NUMBERS-SPECIALIST) (SINGLE-VALUED MINIMUM-VALUE)) :CLOSED TRUE) (DEFRELATION MAXIMUM-VALUE ((?L COLLECTION) (?MAX NUMBER)) :DOCUMENTATION \"Binds ?max to the maximum of the numbers in the list ?l.\" :AXIOMS (AND (RELATION-SPECIALIST MAXIMUM-VALUE MAXIMUM-OF-NUMBERS-SPECIALIST) (SINGLE-VALUED MAXIMUM-VALUE)) :CLOSED TRUE) (DEFRELATION SUM ((?L COLLECTION) (?SUM NUMBER)) :DOCUMENTATION \"Binds ?sum to the sum of the numbers in the list ?l.\" :AXIOMS (AND (RELATION-SPECIALIST SUM SUM-OF-NUMBERS-SPECIALIST) (SINGLE-VALUED SUM)) :CLOSED TRUE) (DEFFUNCTION PROJECT-COLUMN ((?I INTEGER) (?C COLLECTION)) :-> (?L LIST) :DOCUMENTATION \"Project elements in column ?i (zero-based) of the tuples\nof ?c and collect them into a list ?l. \" :AXIOMS (RELATION-SPECIALIST PROJECT-COLUMN PROJECT-COLUMN-SPECIALIST) :CLOSED TRUE) (DEFRELATION MEAN-VALUE ((?L COLLECTION) (?MEAN NUMBER)) :DOCUMENTATION \"Binds ?mean to the mean of the numbers in ?l.\" :AXIOMS (AND (COMPUTED MEAN-VALUE) (RELATION-SPECIALIST MEAN-VALUE MEAN-OF-NUMBERS-SPECIALIST) (SINGLE-VALUED MEAN-VALUE)) :CLOSED TRUE) (DEFRELATION MEDIAN-VALUE ((?L COLLECTION) (?MEDIAN NUMBER)) :DOCUMENTATION \"Binds ?median to the median of the numbers in ?l.\" :AXIOMS (AND (COMPUTED MEDIAN-VALUE) (RELATION-SPECIALIST MEDIAN-VALUE MEDIAN-OF-NUMBERS-SPECIALIST) (SINGLE-VALUED MEDIAN-VALUE)) :CLOSED TRUE) (DEFRELATION STANDARD-DEVIATION ((?L COLLECTION) (?SD NUMBER)) :DOCUMENTATION \"Binds ?sd to the standard deviation of the numbers in ?l.\" :AXIOMS (AND (COMPUTED STANDARD-DEVIATION) (RELATION-SPECIALIST STANDARD-DEVIATION STANDARD-DEVIATION-SPECIALIST) (SINGLE-VALUED STANDARD-DEVIATION)) :CLOSED TRUE) (DEFRELATION VARIANCE ((?L COLLECTION) (?VARIANCE NUMBER)) :DOCUMENTATION \"Binds ?variance to the variance of the numbers in ?l.\" :AXIOMS (AND (COMPUTED VARIANCE) (RELATION-SPECIALIST VARIANCE VARIANCE-SPECIALIST) (SINGLE-VALUED VARIANCE)) :CLOSED TRUE) (DEFFUNCTION STRING-CONCATENATE ((?X THING) (?Y THING)) :-> (?Z STRING) :DOCUMENTATION \"Concatenate ?x and zero or more strings ?y (variable arity)\nand bind ?z to the result.  Coerces any type argument to a string if necessary.\" :VARIABLE-ARITY TRUE :COMPUTED TRUE :RELATION-SPECIALIST COMPUTATION-SPECIALIST :RELATION-COMPUTATION STRING-CONCATENATE-COMPUTATION :CLOSED TRUE) (DEFFUNCTION SUBSTRING ((?S THING) (?START INTEGER) (?END INTEGER)) :-> (?SUB THING) :DOCUMENTATION \"Generate the substring ?sub of ?s starting at position ?start (zero-based)\nand ending just before position ?end.  This is the PowerLoom equivalent to the STELLA method\n`subsequence'.  Supplying -1 for ?end indicates the end of ?s, -2 is one character from the\nend, etc.  If ?s and/or ?sub are not strings, they will be coerced first if possible.  This\nfunction supports any binding pattern where at most one input is unbound (except for ?s), or\nwhere both ?start and ?end are unbound in which case it can locate all occurrences of the\n?sub string in ?s.  For example:\n	 \n      (retrieve all (?start ?end) (substring \\\"foo\\\" ?start ?end \\\"o\\\"))\n   ==>  ?start = 1, ?end = 2,\n        ?start = 2, ?end = 3\n	\nAdditional examples can be found in the test suite.\" :AXIOMS (AND (COMPUTED SUBSTRING) (RELATION-SPECIALIST SUBSTRING SUBSEQUENCE-SPECIALIST)) :CLOSED TRUE) (DEFFUNCTION STRING-MATCH ((?PATTERN STRING) (?OBJECT THING) (?START INTEGER) (?END INTEGER)) :-> (?MATCH-POSITION INTEGER) :DOCUMENTATION \"Match ?pattern against ?object between ?start and ?end (zero-based),\nand return the position of the first match or fail if no match exists.  Supplying -1 for\n?end indicates the end of ?object, -2 is one character from the end, etc.  ?object can be\na named logic object or a string.  ?pattern will eventually support regular expressions,\ncurrently it only handles string literals.  Apart from doing to-string coercion on ?object\nthis is somewhat redundant, since `substring' can generate ?start/?end pairs if its string\nand substring arguments are bound.\" :AXIOMS (AND (COMPUTED STRING-MATCH) (RELATION-COMPUTATION STRING-MATCH STRING-MATCH-COMPUTATION) (RELATION-SPECIALIST STRING-MATCH COMPUTATION-SPECIALIST)) :CLOSED TRUE) (DEFFUNCTION STRING-MATCH-IGNORE-CASE ((?PATTERN STRING) (?OBJECT THING) (?START INTEGER) (?END INTEGER)) :-> (?MATCH-POSITION INTEGER) :DOCUMENTATION \"Case-insensitive version of `string-match' (which see).\" :AXIOMS (AND (COMPUTED STRING-MATCH-IGNORE-CASE) (RELATION-COMPUTATION STRING-MATCH-IGNORE-CASE STRING-MATCH-IGNORE-CASE-COMPUTATION) (RELATION-SPECIALIST STRING-MATCH-IGNORE-CASE COMPUTATION-SPECIALIST)) :CLOSED TRUE) (DEFFUNCTION STRING-UPCASE ((?OBJECT THING) (?START INTEGER) (?END INTEGER)) :-> (?UPCASED-STRING STRING) :DOCUMENTATION \"Upcase all characers of ?object between ?start and ?end and return the result.\nSupplying -1 for ?end indicates the end of ?object, -2 is one character from the end, etc.  ?object can be\na named logic object or a string.  Note that this function can also be used to test whether a string or\none of its subsequences is all uppercase by binding ?upcased-string to ?object.\" :COMPUTED TRUE :RELATION-COMPUTATION STRING-UPCASE-COMPUTATION :RELATION-SPECIALIST COMPUTATION-SPECIALIST :CLOSED TRUE) (DEFFUNCTION STRING-DOWNCASE ((?OBJECT THING) (?START INTEGER) (?END INTEGER)) :-> (?DOWNCASED-STRING STRING) :DOCUMENTATION \"Downcase all characers of ?object between ?start and ?end and return the result.\nSupplying -1 for ?end indicates the end of ?object, -2 is one character from the end, etc.  ?object can be\na named logic object or a string.  Note that this function can also be used to test whether a string or\none of its subsequences is all lowercase by binding ?downcased-string to ?object.\" :COMPUTED TRUE :RELATION-COMPUTATION STRING-DOWNCASE-COMPUTATION :RELATION-SPECIALIST COMPUTATION-SPECIALIST :CLOSED TRUE) (DEFFUNCTION STRING-CAPITALIZE ((?OBJECT THING) (?START INTEGER) (?END INTEGER)) :-> (?CAPITALIZED-STRING STRING) :DOCUMENTATION \"Capitalize the substring of ?object between ?start and ?end and return the result.\nThe first letter in the substring will be made uppercase and all others will be made lowercase.\nSupplying -1 for ?end indicates the end of ?object, -2 is one character from the end, etc.  ?object can be\na named logic object or a string.  Note that this function can also be used to test whether a string or\none of its subsequences is capitalized by binding ?capitalized-string to ?object.\" :COMPUTED TRUE :RELATION-COMPUTATION STRING-CAPITALIZE-COMPUTATION :RELATION-SPECIALIST COMPUTATION-SPECIALIST :CLOSED TRUE) (DEFFUNCTION STRING-REPLACE ((?OBJECT THING) (?FROM STRING) (?TO STRING) (?START INTEGER) (?END INTEGER)) :-> (?RESULT STRING) :DOCUMENTATION \"Replace all occurrances of ?from in ?object between ?start and ?end with ?to and return\nthe ?result. Supplying -1 for ?end indicates the end of ?object, -2 is one character from the end, etc.\n?object can be a named logic object or a string.\" :COMPUTED TRUE :RELATION-COMPUTATION STRING-REPLACE-COMPUTATION :RELATION-SPECIALIST COMPUTATION-SPECIALIST :CLOSED TRUE) (DEFFUNCTION STRING-COMPARE ((?O1 THING) (?O2 THING) (?START1 INTEGER) (?END1 INTEGER) (?START2 INTEGER) (?END2 INTEGER)) :-> (?RESULT INTEGER) :DOCUMENTATION \"Perform a lexicographic comparison between ?o1 and ?o2 within their respective substrings\n?start1 to ?end1 and ?start2 to ?end2.  The ?result will be -1 if ?o1 comes before ?o2, 0 if they are equal,\nand 1 if ?o2 comes before ?o1.  Both ?o1 and ?o2 can be a named logic object or a string.\" :COMPUTED TRUE :RELATION-COMPUTATION STRING-COMPARE-COMPUTATION :RELATION-SPECIALIST COMPUTATION-SPECIALIST :CLOSED TRUE) (DEFFUNCTION STRING-COMPARE-IGNORE-CASE ((?O1 THING) (?O2 THING) (?START1 INTEGER) (?END1 INTEGER) (?START2 INTEGER) (?END2 INTEGER)) :-> (?RESULT INTEGER) :DOCUMENTATION \"Just like `string-compare' (which see) but ignores case.\" :COMPUTED TRUE :RELATION-COMPUTATION STRING-COMPARE-IGNORE-CASE-COMPUTATION :RELATION-SPECIALIST COMPUTATION-SPECIALIST :CLOSED TRUE) (DEFFUNCTION STRING-TO-NUMBER ((?OBJECT THING) (?START INTEGER) (?END INTEGER)) :-> (?NUMBER NUMBER) :DOCUMENTATION \"If the part of ?object between ?start and ?end names a decimal number such as an integer\nor float, convert it (that part) into the number it names.  Supplying -1 for ?end indicates the end of ?object,\n-2 is one character from the end, etc.  ?object can be a named logic object or a string.\" :COMPUTED TRUE :RELATION-COMPUTATION STRING-TO-NUMBER-COMPUTATION :RELATION-SPECIALIST COMPUTATION-SPECIALIST :CLOSED TRUE) (DEFFUNCTION LENGTH ((?X THING)) :-> (?Z INTEGER) :DOCUMENTATION \"Function that returns the length of a string or a logical list.\" :AXIOMS (AND (COMPUTED LENGTH) (RELATION-COMPUTATION LENGTH LENGTH-COMPUTATION) (RELATION-SPECIALIST LENGTH COMPUTATION-SPECIALIST)) :SYNONYM LENGTH-OF-LIST) (ASSERT (COMPUTED-PROCEDURE COMPUTATION-SPECIALIST)) (ASSERT (HANDLES-REVERSE-POLARITY COMPUTATION-SPECIALIST)) (ASSERT (COMPUTED-PROCEDURE CONSTRAINT-SPECIALIST)) (ASSERT (HANDLES-REVERSE-POLARITY CONSTRAINT-SPECIALIST)) (DEFFUNCTION OBJECT-NAME (?X) :-> (?C STRING) :DOCUMENTATION \"The name of the object ?X as a string.  This is just the\nname, with module prefixes NOT included.\" :COMPUTED TRUE :RELATION-COMPUTATION OBJECT-NAME-COMPUTATION :RELATION-SPECIALIST COMPUTATION-SPECIALIST) (DEFFUNCTION OBJECT-PRINT-NAME (?X) :-> (?C STRING) :DOCUMENTATION \"The print name of the object ?X as a string relative to the\ncurrent module.  This will include module prefixes as well as escape characters\nif necessary.\" :COMPUTED TRUE :RELATION-COMPUTATION OBJECT-PRINT-NAME-COMPUTATION :RELATION-SPECIALIST COMPUTATION-SPECIALIST) (DEFFUNCTION NAME-TO-OBJECT (?N) :-> ?O :DOCUMENTATION \"Find or create the PowerLoom logic object ?o named by\nthe name ?n in the current module.  We are interpreting the name ?n literally\nhere, i.e., it is not a print name as assumed by PLI functions and an object\nwith exactly that name will be looked up or created.  If ?n is not a string,\nthis will coerce it to a string first.  We are intentionally\nusing a separate function here (instead of folding this into `object-name'),\nsince we might want to be able to look for an object with a certain name\nbut not create one if it doesn't exist.\" :COMPUTED TRUE :RELATION-COMPUTATION NAME-TO-OBJECT-COMPUTATION :RELATION-SPECIALIST COMPUTATION-SPECIALIST) (DEFFUNCTION PRINT-NAME-TO-OBJECT (?N) :-> ?O :DOCUMENTATION \"Find or create the PowerLoom logic object ?o named by\nthe print name ?n in the current module.  This is just like `name-to-object'\nbut interprets ?n as a possibly qualified print name with escape characters.\nNote that this will simply fail when given a name with incorrect read syntax\nor a non-existing module.\" :COMPUTED TRUE :RELATION-COMPUTATION PRINT-NAME-TO-OBJECT-COMPUTATION :RELATION-SPECIALIST COMPUTATION-SPECIALIST) (DEFFUNCTION ARITY ((?R RELATION)) :-> (?ARITY INTEGER) :DOCUMENTATION \"The number of arguments/domains of the relation '?r'.\") (ASSERT (AND (COMPUTED ARITY) (RELATION-SPECIALIST ARITY ARITY-SPECIALIST) (HANDLES-REVERSE-POLARITY ARITY-SPECIALIST))) (DEFRELATION VARIABLE-ARITY ((?R RELATION)) :DOCUMENTATION \"Asserts that the relation ?r can take a variable\nnumber of arguments.\" :AXIOMS (CLOSED VARIABLE-ARITY)) (DEFCONCEPT BINARY-RELATION (?R RELATION) :DOCUMENTATION \"The class of binary relations.\" :<<=>> (AND (RELATION ?R) (ARITY ?R 2))) (DEFFUNCTION INVERSE ((?R BINARY-RELATION)) :-> ?INVERSERELATION :DOCUMENTATION \"Function that returns the inverse relation for ?r.\nPERFORMANCE NOTE: for best results there should be only one `(inverse R I)'\nassertion per relation pair `R' and `I'.  In that case `R' is viewed as the\ncanonical relation and `I' simply provides a different access mechanism to\nthe canonical relation.  In a logic-based KR paradigm inverse relations are\nredundant and do not add anything that couldn't be represented or queried\nwithout them, however, sometimes they can provide some extra convenience for\nusers.  Asserting `(inverse I R)' also will not cause an error but can degrade\nbackward inference performance due to the extra redundant rule that gets\ngenerated.  If domain rules will be written in terms of both `R' and `I' (as\nopposed to only `R'), `(inverse I R)' should be asserted also to get full\ninferential connectivity between the two relations.\" :=>> (BINARY-RELATION ?INVERSERELATION) :=>> (<<=>> (HOLDS ?INVERSERELATION ?Y ?X) (HOLDS ?R ?X ?Y)) :AXIOMS (SYMMETRIC INVERSE)) (DEFRELATION DUPLICATE-FREE ((?C COLLECTION)) :DOCUMENTATION \"?c is duplicate-free if no two members\ndenote the same object.\") (DEFRELATION DIFFERENT (?X ?Y) :DOCUMENTATION \"True if no two arguments are the same.  This is equivalent to\n`(duplicate-free (list-of ?x ?y ...))' but without the need to generate a\ncollection object.  The main use for this is to state and test pairwise\ninequalities between N entities without having to generate O(N**2) statements.\" :VARIABLE-ARITY TRUE :COMPUTED TRUE :RELATION-SPECIALIST DIFFERENT-SPECIALIST :AXIOMS (HANDLES-REVERSE-POLARITY DIFFERENT-SPECIALIST)) (DEFRELATION ORDERED ((?C COLLECTION)) :DOCUMENTATION \"?c is ordered if the ordering of its\nmembers is significant.  Lists are ordered, while sets are not.\") (DEFRELATION COMMUTATIVE ((?R RELATION)) :DOCUMENTATION \"A relation ?r is commutative if its truth value is\ninvariant with any permutation of its arguments.\" :AXIOMS (=>> (AND (COMMUTATIVE ?R) (= (ARITY ?R) 2)) (SYMMETRIC ?R))) (DEFRELATION REFLEXIVE ((?R RELATION)) :DOCUMENTATION \"A binary relation ?r is reflexive if it is always true when\nboth of its arguments are identical.\" :=>> (BINARY-RELATION ?R) :=> (NOT (IRREFLEXIVE ?R)) :<= (AND (BINARY-RELATION ?R) (FORALL ?X (HOLDS ?R ?X ?X))) :=> (RELATION-SPECIALIST ?R REFLEXIVE-RELATION-SPECIALIST) :AXIOMS (HANDLES-REVERSE-POLARITY REFLEXIVE-RELATION-SPECIALIST)) (DEFRELATION IRREFLEXIVE ((?R RELATION)) :DOCUMENTATION \"A binary relation ?r is irreflexive if it is false when both\nof its arguments are identical.\" :=>> (BINARY-RELATION ?R) :=> (NOT (REFLEXIVE ?R)) :<= (AND (BINARY-RELATION ?R) (FORALL ?X (NOT (HOLDS ?R ?X ?X)))) :=> (RELATION-SPECIALIST ?R IRREFLEXIVE-RELATION-SPECIALIST) :AXIOMS (HANDLES-REVERSE-POLARITY IRREFLEXIVE-RELATION-SPECIALIST)) (DEFRELATION SYMMETRIC ((?R RELATION)) :DOCUMENTATION \"A binary relation ?r is symmetric if it is commutative.\" :=>> (BINARY-RELATION ?R) :=>> (COMMUTATIVE ?R) :=>> (FORALL (?X ?Y) (<<= (HOLDS ?R ?X ?Y) (HOLDS ?R ?Y ?X))) :=> (NOT (ANTISYMMETRIC ?R))) (DEFRELATION ANTISYMMETRIC ((?R RELATION)) :DOCUMENTATION \"A binary relation ?r is antisymmetric if whenever (?r ?x ?y)\nis true (?r ?y ?x) is false unless ?x equals ?y.\" :=>> (BINARY-RELATION ?R) :=> (NOT (SYMMETRIC ?R)) :=> (FORALL (?X ?Y) (=> (AND (HOLDS ?R ?X ?Y) (NOT (= ?X ?Y))) (NOT (?R ?Y ?X))))) (DEFRELATION TRANSITIVE ((?R RELATION)) :DOCUMENTATION \"A binary relation ?r is transitive if (?r ?x ?y)\nand (?r ?y ?z) implies that (?r ?x ?z).  Note that functions cannot\nbe transitive, since their single-valuedness would not allow multiple\ndifferent values such as (?r ?x ?y) and (?r ?x ?z) due to the Unique\nNames Assumption made by PowerLoom.\" :=>> (AND (BINARY-RELATION ?R) (NOT (FUNCTION ?R))) :=>> (=> (AND (BINARY-RELATION ?R) (?R ?X ?Y) (?R ?Y ?Z)) (?R ?X ?Z))) (DEFRELATION TOTAL ((?R FUNCTION)) :DOCUMENTATION \"True if the function '?r' is defined for all\ncombinations of inputs.  By default, functions are not assumed to\nbe total (unlike Prolog, which 'does' make such an assumption.\nFo").concat("r example, if we define a two-argument function `foo' and then retrieve\nits value applied to some random instances `a' and `b', we get nothing\nback:\n	 \n   (deffunction foo (?x ?y) :-> ?z)\n   (retrieve ?x (= ?x (foo a b)))\n	\nHowever, if we assert that `foo' is total, then we get a skolem back\nwhen we execute the same retrieve:\n	 \n   (assert (total foo))\n   (retrieve ?x (= ?x (foo a b)))\n	\n\") (DEFRELATION ABSTRACT ((?R RELATION)) :DOCUMENTATION \"True if there are no direct assertions made\nto the relation ?r.\") (DEFFUNCTION CONCEPT-PROTOTYPE ((?C CONCEPT)) :-> ?I :DOCUMENTATION \"Function that, given a concept, returns a prototypical\ninstance that inherits all constraints that apply to any concept member,\nand has no additional constraints.\" :RELATION-SPECIALIST CONCEPT-PROTOTYPE-SPECIALIST :TOTAL TRUE :CLOSED TRUE :SYNONYM CLASS-PROTOTYPE) (DEFRULE \"'Not instance-of' rule\" (<= (NOT (INSTANCE-OF ?X ?C)) (AND (COLLECTION ?C) (CLOSED ?C) (FAIL (INSTANCE-OF ?X ?C))))) (DEFRULE \"Forward 'instance-of' rule\" (=> (INSTANCE-OF ?X ?C) (AND (CONCEPT ?C) (HOLDS ?C ?X))) :FORWARD? TRUE) (DEFCONCEPT USER-THING (?X) :DOCUMENTATION \"The class of user-defined things.\") (DEFRELATION CASE-MATCH ((?X THING) (?Y THING))) (DEFRULE CASE-MATCH-RULE (FORALL ((?X THING) (?Y THING)) (=> (= ?X ?Y) (CASE-MATCH ?X ?Y)))) (DEFRELATION SOFT-EQ ((?X THING) (?Y THING))) (DEFRULE SOFT-EQ-RULE (FORALL ((?X THING) (?Y THING)) (=> (= ?X ?Y) (SOFT-EQ ?X ?Y)))) (DEFFUNCTION CONTEXT-OF (?X) :-> (?C CONTEXT) :AXIOMS (AND (COMPUTED CONTEXT-OF) (RELATION-COMPUTATION CONTEXT-OF CONTEXT-OF-COMPUTATION) (RELATION-SPECIALIST CONTEXT-OF COMPUTATION-SPECIALIST))) (DEFRELATION DISJOINT ((?C1 COLLECTION) (?C2 COLLECTION)) :DOCUMENTATION \"True if the intersection of ?c1 and ?c2 is empty.\" :IRREFLEXIVE TRUE :<<= (CHEAP-DISJOINT ?C1 ?C2)) (DEFRELATION MUTUALLY-DISJOINT-COLLECTION ((?S SET)) :DOCUMENTATION \"True if the members of ?s are pair-wise disjoint.  Used\nmost often to expresse disjointness constraints between concepts.  For\nexample\n	 \n   (mutually-disjoint-collection (setof MAN WOMAN))\n	\nstates that the concepts MAN and WOMAN are disjoint.\n\" :=>> (=> (AND (MEMBER-OF ?C1 ?S) (MEMBER-OF ?C2 ?S) (NOT (= ?C1 ?C2))) (DISJOINT ?C1 ?C2))) (DEFRELATION COVERING ((?C COLLECTION) (?COVER SET)) :DOCUMENTATION \"True if ?c is a subset of the union of all\ncollections in the set ?cover (see `disjoint-covering').\") (DEFRELATION DISJOINT-COVERING ((?C COLLECTION) (?DISJOINTCOVER SET)) :DOCUMENTATION \"True if ?c is covered by the collections in ?disjointCover\nand if the member sets in ?disjointCover are mutually-disjoint.  For\nexample the concepts `Igneous-Rock', `Metamorphic-Rock', and\n`Sedimentary-Rock' together form a disjoint covering of the concept `Rock'.\" :<<= (AND (COVERING ?C ?DISJOINTCOVER) (MUTUALLY-DISJOINT-COLLECTION ?DISJOINTCOVER))) (DEFRELATION CHEAP-DISJOINT ((?C1 COLLECTION) (?C2 COLLECTION)) :DOCUMENTATION \"Find proof of disjointness without using refutation.\" :<<= (AND (HAS-PARTITION-MEMBERSHIP ?C1) (HAS-PARTITION-MEMBERSHIP ?C2) (EXISTS (?PROPOSITION ?PARTITION1 ?PARTITION2) (AND (PARTITION-MEMBERSHIP ?C1 ?PROPOSITION ?PARTITION1) (PARTITION-MEMBERSHIP ?C2 ?PROPOSITION ?PARTITION2) (NOT (= ?PARTITION1 ?PARTITION2)))))) (DEFRELATION REFUTATION-DISJOINT ((?C1 COLLECTION) (?C2 COLLECTION)) :DOCUMENTATION \"Assume that an instance belongs to both ?c1 and ?c2\nand look for a clash.\" :AXIOMS (RELATION-SPECIALIST REFUTATION-DISJOINT REFUTATION-DISJOINT-SPECIALIST)) (DEFRELATION HAS-PARTITION-MEMBERSHIP ((?C COLLECTION)) :DOCUMENTATION \"TRUE if one or more PARTITION-MEMBERSHIP tuples\nexist with ?c as the first argument.  FALSE if none exists.\nUnknown if a derivation of PARTITION-MEMBERSHIP tuples has not\noccurred.  A specialist for this relation creates PARTITION-MEMBERSHIP\ntuples as a side-effect of querying this predicate.\" :AXIOMS (AND (HIDDEN-RELATION HAS-PARTITION-MEMBERSHIP) (RELATION-SPECIALIST HAS-PARTITION-MEMBERSHIP HAS-PARTITION-MEMBERSHIP-SPECIALIST))) (DEFRELATION PARTITION-MEMBERSHIP ((?C COLLECTION) (?PROPOSITION PROPOSITION) (?PARTITION COLLECTION)) :DOCUMENTATION \"Caches the fact that ?partition is a partition of\na mutually-disjoint collection, and that ?c is a subset of ?partition.\nUsed to support rapid computation of pairwise disjointness.\" :AXIOMS (HIDDEN-RELATION PARTITION-MEMBERSHIP))) \"/PL-KERNEL-KB\")"), "/PL-KERNEL-KB");
          PlKernelKb.initializeKernelKb();
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Stella.$MODULE$.set(old$Module$000);
      }
    }
  }

}
