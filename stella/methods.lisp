;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-METHODS-SURROGATE NULL)
(CL:DEFVAR SGT-METHODS-PARAMETRIC-TYPE-SPECIFIER NULL)
(CL:DEFVAR SGT-METHODS-ANCHORED-TYPE-SPECIFIER NULL)
(CL:DEFVAR SGT-METHODS-OBJECT NULL)
(CL:DEFVAR SGT-METHODS-VOID NULL)
(CL:DEFVAR SYM-METHODS-LIKE NULL)
(CL:DEFVAR SYM-METHODS-SIZE NULL)
(CL:DEFVAR SYM-METHODS-OF NULL)
(CL:DEFVAR SYM-METHODS-SELF NULL)
(CL:DEFVAR SYM-METHODS-IN NULL)
(CL:DEFVAR SYM-METHODS-OUT NULL)
(CL:DEFVAR SYM-METHODS-INOUT NULL)
(CL:DEFVAR SYM-METHODS-METHOD-PARAMETER-DIRECTIONS NULL)
(CL:DEFVAR SYM-METHODS-ARGUMENT-LIST NULL)
(CL:DEFVAR SYM-METHODS-&REST NULL)
(CL:DEFVAR SYM-METHODS-METHOD-VARIABLE-ARGUMENTS? NULL)
(CL:DEFVAR SYM-METHODS-&BODY NULL)
(CL:DEFVAR SYM-METHODS-METHOD-BODY-ARGUMENT? NULL)
(CL:DEFVAR SGT-METHODS-UNKNOWN NULL)
(CL:DEFVAR KWD-METHODS-TYPE NULL)
(CL:DEFVAR KWD-METHODS-RETURN-TYPES NULL)
(CL:DEFVAR SYM-METHODS-SLOT-TYPE-SPECIFIER NULL)
(CL:DEFVAR KWD-METHODS-PUBLIC? NULL)
(CL:DEFVAR KWD-METHODS-NATIVE? NULL)
(CL:DEFVAR SYM-METHODS-METHOD-NATIVE? NULL)
(CL:DEFVAR KWD-METHODS-GLOBALLY-INLINE? NULL)
(CL:DEFVAR SYM-METHODS-METHOD-GLOBALLY-INLINE? NULL)
(CL:DEFVAR KWD-METHODS-INLINE NULL)
(CL:DEFVAR SYM-METHODS-METHOD-INLINED-FUNCTIONS NULL)
(CL:DEFVAR KWD-METHODS-AUXILIARY? NULL)
(CL:DEFVAR SYM-METHODS-SLOT-AUXILIARY? NULL)
(CL:DEFVAR KWD-METHODS-DOCUMENTATION NULL)
(CL:DEFVAR SYM-METHODS-DOCUMENTATION NULL)
(CL:DEFVAR KWD-METHODS-RETURNS NULL)
(CL:DEFVAR KWD-METHODS-STORAGE-SLOT NULL)
(CL:DEFVAR SYM-METHODS-STORAGE-SLOT NULL)
(CL:DEFVAR KWD-METHODS-INHERITS-THROUGH NULL)
(CL:DEFVAR SYM-METHODS-METHOD-INHERITS-THROUGH NULL)
(CL:DEFVAR KWD-METHODS-PROPERTIES NULL)
(CL:DEFVAR SYM-METHODS-PROPERTIES NULL)
(CL:DEFVAR KWD-METHODS-META-ATTRIBUTES NULL)
(CL:DEFVAR SYM-METHODS-META-ATTRIBUTES NULL)
(CL:DEFVAR KWD-METHODS-COMMAND? NULL)
(CL:DEFVAR SYM-METHODS-METHOD-COMMAND? NULL)
(CL:DEFVAR KWD-METHODS-LISP-MACRO? NULL)
(CL:DEFVAR SYM-METHODS-METHOD-LISP-MACRO? NULL)
(CL:DEFVAR KWD-METHODS-EVALUATE-ARGUMENTS? NULL)
(CL:DEFVAR SYM-METHODS-METHOD-EVALUATE-ARGUMENTS? NULL)
(CL:DEFVAR SYM-METHODS-CONCATENATE NULL)
(CL:DEFVAR SYM-METHODS-NULL NULL)
(CL:DEFVAR SYM-METHODS-DEFINE-METHOD-FROM-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SGT-METHODS-BOOLEAN NULL)
(CL:DEFVAR SYM-METHODS-SUPER-CLASSES NULL)
(CL:DEFVAR SYM-METHODS-EQUIVALENT-SLOT NULL)
(CL:DEFVAR SYM-METHODS-CLASS-ALL-SUPER-CLASSES NULL)
(CL:DEFVAR SYM-METHODS-SLOT-DIRECT-EQUIVALENT NULL)
(CL:DEFVAR SYM-METHODS-LET NULL)
(CL:DEFVAR SYM-METHODS-CURSOR NULL)
(CL:DEFVAR SYM-METHODS-VALUE NULL)
(CL:DEFVAR SYM-METHODS-SLOT-VALUE NULL)
(CL:DEFVAR SYM-METHODS-LOOP NULL)
(CL:DEFVAR SYM-METHODS-WHEN NULL)
(CL:DEFVAR SYM-METHODS-RETURN NULL)
(CL:DEFVAR SYM-METHODS-SETQ NULL)
(CL:DEFVAR SYM-METHODS-IF NULL)
(CL:DEFVAR SYM-METHODS-DEFINED? NULL)
(CL:DEFVAR SGT-METHODS-COLLECTION NULL)
(CL:DEFVAR SGT-METHODS-CONS NULL)
(CL:DEFVAR SYM-METHODS-FIRST NULL)
(CL:DEFVAR SYM-METHODS-VARIABLE-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-METHODS-DEFSPECIAL NULL)
(CL:DEFVAR SYM-METHODS-DEFCONSTANT NULL)
(CL:DEFVAR KWD-METHODS-UNBOUND-SPECIAL-VARIABLE NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *STELLA-MODULE*
  *MODULE*
  SYMBOL-SYM
  *REDEFINE-RELATION-HOOKS*
  NULL-STRING-WRAPPER
  STANDARD-OUTPUT
  EOL
  NULL-BOOLEAN-WRAPPER
  *TRANSIENTOBJECTS?*))

;;; (DEFUN (APPLY OBJECT) ...)

(CL:DEFUN APPLY (CODE ARGUMENTS)
  "Apply `code' to `arguments', returning a value of type
OBJECT."
  (CL:CASE
   (LENGTH ARGUMENTS)
   (0 (CL:RETURN-FROM APPLY (CL:FUNCALL CODE)))
   (1 (CL:RETURN-FROM APPLY (CL:FUNCALL CODE (FIRST ARGUMENTS))))
   (2
    (CL:RETURN-FROM
     APPLY
     (CL:FUNCALL CODE (FIRST ARGUMENTS) (SECOND ARGUMENTS))))
   (3
    (CL:RETURN-FROM
     APPLY
     (CL:FUNCALL
      CODE
      (FIRST ARGUMENTS)
      (SECOND ARGUMENTS)
      (NTH ARGUMENTS 2))))
   (4
    (CL:RETURN-FROM
     APPLY
     (CL:FUNCALL
      CODE
      (FIRST ARGUMENTS)
      (SECOND ARGUMENTS)
      (NTH ARGUMENTS 2)
      (NTH ARGUMENTS 3))))
   (5
    (CL:RETURN-FROM
     APPLY
     (CL:FUNCALL
      CODE
      (FIRST ARGUMENTS)
      (SECOND ARGUMENTS)
      (NTH ARGUMENTS 2)
      (NTH ARGUMENTS 3)
      (NTH ARGUMENTS 4))))
   (CL:OTHERWISE
    (CL:ERROR "Too many function arguments in `apply'.  Max is 5.")))
  :VOID)

;;; (DEFUN (MAKE-PARAMETRIC-TYPE-SPECIFIER PARAMETRIC-TYPE-SPECIFIER) ...)

(CL:DEFUN MAKE-PARAMETRIC-TYPE-SPECIFIER ()
  "Return a transient or permanent instance of
'PARAMETRIC-TYPE-SPECIFIER'."
  (CL:LET*
   ((TYPESPEC NULL))
   (CL:COND
    ((CL:EQ *TRANSIENTOBJECTS?* 1)
     (CL:SETQ TYPESPEC (NEW-TRANSIENT-TYPE-SPECIFIER))
     (FREE
      (CLSYS-SVAL
       PARAMETRIC-TYPE-SPECIFIER
       SPECIFIER-PARAMETER-TYPES
       TYPESPEC)))
    (CL:T
     (CL:SETQ
      TYPESPEC
      (CL:MAKE-INSTANCE (CL:QUOTE PARAMETRIC-TYPE-SPECIFIER)))))
   (CL:RETURN-FROM MAKE-PARAMETRIC-TYPE-SPECIFIER TYPESPEC))
  :VOID)

;;; (DEFUN (TERMINATE-TRANSIENT-TYPE-SPECIFIER? BOOLEAN) ...)

(CL:DEFUN TERMINATE-TRANSIENT-TYPE-SPECIFIER? (SELF)
  (FREE (CLSYS-SVAL TRANSIENT-TYPE-SPECIFIER SPECIFIER-PARAMETER-TYPES SELF))
  (CL:RETURN-FROM TERMINATE-TRANSIENT-TYPE-SPECIFIER? TRUE)
  :VOID)

;;; (DEFUN (DEFINED-TYPE? BOOLEAN) ...)

(CL:DEFUN DEFINED-TYPE? (TYPE)
  (CL:LET*
   ((VALUE (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE)) (VALUETYPE NULL))
   (CL:WHEN
    (CL:NOT (CL:EQ VALUE NULL))
    (CL:SETQ VALUETYPE (PRIMARY-TYPE VALUE))
    (CL:RETURN-FROM
     DEFINED-TYPE?
     (CL:IF
      (CL:OR
       (CL:EQ SGT-METHODS-SURROGATE VALUETYPE)
       (CL:EQ SGT-METHODS-PARAMETRIC-TYPE-SPECIFIER VALUETYPE)
       (CL:EQ SGT-METHODS-ANCHORED-TYPE-SPECIFIER VALUETYPE))
      TRUE
      FALSE)))
   (CL:RETURN-FROM DEFINED-TYPE? FALSE))
  :VOID)

;;; (DEFUN (REAL-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFUN REAL-TYPE-SPECIFIER (TYPE)
  (CL:LET*
   ((VALUE (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE)))
   (CL:IF
    (CL:EQ (DEFINED-TYPE? TYPE) 1)
    (CL:IF
     (CL:EQ (TYPE? VALUE) 1)
     (CL:RETURN-FROM REAL-TYPE-SPECIFIER (REAL-TYPE-SPECIFIER VALUE))
     (CL:RETURN-FROM REAL-TYPE-SPECIFIER VALUE))
    (CL:RETURN-FROM REAL-TYPE-SPECIFIER TYPE)))
  :VOID)

;;; (DEFUN (CANONICAL-TYPE TYPE) ...)

(CL:DEFUN CANONICAL-TYPE (TYPE)
  (CL:LET*
   ((CLASS (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE)))
   (CL:IF
    (CL:NOT (CL:EQ CLASS NULL))
    (CL:RETURN-FROM CANONICAL-TYPE (CLSYS-SVAL CLASS CLASS-TYPE CLASS))
    (CL:RETURN-FROM CANONICAL-TYPE TYPE)))
  :VOID)

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE SURROGATE))
  (CL:RETURN-FROM YIELD-TYPE-SPECIFIER (REAL-TYPE-SPECIFIER TYPESPECTREE))
  :VOID)

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE SYMBOL))
  (CL:RETURN-FROM
   YIELD-TYPE-SPECIFIER
   (REAL-TYPE-SPECIFIER (TYPIFY TYPESPECTREE)))
  :VOID)

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE PARAMETRIC-TYPE-SPECIFIER))
  (CL:RETURN-FROM YIELD-TYPE-SPECIFIER TYPESPECTREE)
  :VOID)

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE ANCHORED-TYPE-SPECIFIER))
  (CL:RETURN-FROM YIELD-TYPE-SPECIFIER TYPESPECTREE)
  :VOID)

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE OBJECT))
  (CL:CERROR "Continue anyway? " "Illegal type specification `~A'" TYPESPECTREE)
  (CL:RETURN-FROM YIELD-TYPE-SPECIFIER SGT-METHODS-OBJECT)
  :VOID)

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE CONS))
  (CL:COND
   ((CL:EQ TYPESPECTREE NIL)
    (CL:RETURN-FROM YIELD-TYPE-SPECIFIER SGT-METHODS-VOID))
   ((CL:EQ (CLSYS-SVAL CONS VALUE TYPESPECTREE) SYM-METHODS-LIKE)
    (CL:RETURN-FROM
     YIELD-TYPE-SPECIFIER
     (YIELD-ANCHORED-TYPE-SPECIFIER TYPESPECTREE)))
   (CL:T
    (CL:RETURN-FROM
     YIELD-TYPE-SPECIFIER
     (YIELD-PARAMETRIC-TYPE-SPECIFIER TYPESPECTREE))))
  :VOID)

;;; (DEFUN (YIELD-PARAMETRIC-TYPE-SPECIFIER PARAMETRIC-TYPE-SPECIFIER) ...)

(CL:DEFUN YIELD-PARAMETRIC-TYPE-SPECIFIER (TYPESPECTREE)
  (CL:LET*
   ((TYPESPEC (NEW-PARAMETRIC-TYPE-SPECIFIER)))
   (CL:LET*
    ((CONS-001 (CLSYS-SVAL CONS VALUE TYPESPECTREE)))
    (CL:SETQ TYPESPECTREE (CLSYS-SVAL CONS REST TYPESPECTREE))
    (CL:LET*
     ((BASETYPE CONS-001))
     (CL:LET*
      ((CONS-002 (CLSYS-SVAL CONS VALUE TYPESPECTREE)))
      (CL:SETQ TYPESPECTREE (CLSYS-SVAL CONS REST TYPESPECTREE))
      (CL:LET*
       ((OPERATOR CONS-002) (SIZE NULL))
       (CL:SETF
        (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE TYPESPEC)
        (VERIFY-TYPE (TYPIFY BASETYPE)))
       (CL:WHEN
        (CL:EQ OPERATOR SYM-METHODS-SIZE)
        (CL:LET*
         ((CONS-003 (CLSYS-SVAL CONS VALUE TYPESPECTREE)))
         (CL:SETQ TYPESPECTREE (CLSYS-SVAL CONS REST TYPESPECTREE))
         (CL:SETQ SIZE CONS-003))
        (CL:SETF
         (CLSYS-SVAL
          PARAMETRIC-TYPE-SPECIFIER
          SPECIFIER-SEQUENCE-SIZE
          TYPESPEC)
         (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE SIZE))
        (CL:LET*
         ((CONS-004 (CLSYS-SVAL CONS VALUE TYPESPECTREE)))
         (CL:SETQ TYPESPECTREE (CLSYS-SVAL CONS REST TYPESPECTREE))
         (CL:SETQ OPERATOR CONS-004)))
       (CL:WHEN
        (CL:NOT (CL:EQ OPERATOR SYM-METHODS-OF))
        (CL:CERROR "Continue anyway? " "Bad type specifier `~A'" TYPESPECTREE)
        (CL:RETURN-FROM YIELD-PARAMETRIC-TYPE-SPECIFIER NULL))
       (CL:LET*
        ((P NULL)
         (ITER-001 TYPESPECTREE)
         (INTO-001
          (CLSYS-SVAL
           PARAMETRIC-TYPE-SPECIFIER
           SPECIFIER-PARAMETER-TYPES
           TYPESPEC))
         (COLLECT-001 NULL))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-001 NIL))
         DO
         (CL:PROGN
          (CL:SETQ P (CLSYS-SVAL CONS VALUE ITER-001))
          (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
         (CL:IF
          (CL:EQ COLLECT-001 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-001 (PERMANENT-CONS (YIELD-TYPE-SPECIFIER P) NIL))
           (CL:IF
            (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST INTO-001) NIL)
            (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST INTO-001) COLLECT-001)
            (ADD-CONS-TO-END-OF-CONS-LIST
             (CLSYS-SVAL LIST THE-CONS-LIST INTO-001)
             COLLECT-001)))
          (CL:PROGN
           (CL:SETF
            (CLSYS-SVAL CONS REST COLLECT-001)
            (PERMANENT-CONS (YIELD-TYPE-SPECIFIER P) NIL))
           (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
       (CL:RETURN-FROM YIELD-PARAMETRIC-TYPE-SPECIFIER TYPESPEC))))))
  :VOID)

;;; (DEFUN (YIELD-ANCHORED-TYPE-SPECIFIER ANCHORED-TYPE-SPECIFIER) ...)

(CL:DEFUN YIELD-ANCHORED-TYPE-SPECIFIER (TYPESPECTREE)
  (CL:LET*
   ((TYPESPEC (NEW-ANCHORED-TYPE-SPECIFIER))
    (LIKEARGUMENT (SECOND TYPESPECTREE)))
   (CL:WHEN
    (CL:NOT (CL:EQ LIKEARGUMENT SYM-METHODS-SELF))
    (CL:SETF
     (CLSYS-SVAL ANCHORED-TYPE-SPECIFIER SPECIFIER-PARAMETER-NAME TYPESPEC)
     (PERMANENTIFY (FIRST LIKEARGUMENT))))
   (CL:RETURN-FROM YIELD-ANCHORED-TYPE-SPECIFIER TYPESPEC))
  :VOID)

;;; (DEFUN INCORPORATE-INPUT-PARAMETERS ...)

(CL:DEFUN INCORPORATE-INPUT-PARAMETERS (METHOD PARAMETERS)
  (CL:WHEN (CL:EQ PARAMETERS NIL) (CL:RETURN-FROM INCORPORATE-INPUT-PARAMETERS))
  (CL:LET*
   ((NAME NULL) (TS NULL) (DIRECTION NULL) (VARIABLEARGS? FALSE))
   (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-PARAMETER-NAMES METHOD) (NEW-LIST))
   (CL:SETF
    (CLSYS-SVAL METHOD-SLOT METHOD-PARAMETER-TYPE-SPECIFIERS METHOD)
    (NEW-LIST))
   (CL:LET*
    ((P NULL) (ITER-001 PARAMETERS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ P (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:TAGBODY
      (CL:LET*
       ((P-001 P))
       (CL:COND
        ((CL:EQ (CONS? P) 1)
         (CL:LET*
          ((P NULL))
          (CL:SETQ P P-001)
          (CL:CASE
           (LENGTH P)
           (2 (CL:SETQ DIRECTION SYM-METHODS-IN))
           (3
            (CL:COND
             ((CL:OR
               (CL:EQ (FIRST P) SYM-METHODS-IN)
               (CL:EQ (FIRST P) SYM-METHODS-OUT)
               (CL:EQ (FIRST P) SYM-METHODS-INOUT))
              (CL:SETQ DIRECTION (FIRST P))
              (CL:WHEN
               (CL:EQ (NULL-LIST? (METHOD-PARAMETER-DIRECTIONS METHOD)) 1)
               (SET-DYNAMIC-SLOT-VALUE
                METHOD
                SYM-METHODS-METHOD-PARAMETER-DIRECTIONS
                (NEW-LIST)
                NULL)
               (CL:LET*
                ((PAR NULL) (ITER-002 PARAMETERS))
                (CL:LOOP
                 WHILE
                 (CL:NOT (CL:EQ ITER-002 NIL))
                 DO
                 (CL:PROGN
                  (CL:SETQ PAR (CLSYS-SVAL CONS VALUE ITER-002))
                  (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
                 (CL:IF
                  (CL:EQ PAR P)
                  (CL:RETURN)
                  (INSERT
                   (METHOD-PARAMETER-DIRECTIONS METHOD)
                   SYM-METHODS-IN))))))
             (CL:T
              (CL:LET*
               ((*PRINTREADABLY?* TRUE))
               (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
               (SIGNAL-TRANSLATION-ERROR)
               (CL:WHEN
                (CL:EQ (SUPPRESS-WARNINGS?) 0)
                (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
                (CL:LET
                 ((%%STREAM
                   (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
                 (CL:TERPRI %%STREAM)
                 (CL:FORCE-OUTPUT %%STREAM)
                 (CL:WRITE-STRING
                  " Illegal direction for method parameter: `"
                  %%STREAM)
                 (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE P) %%STREAM)
                 (CL:WRITE-STRING "'." %%STREAM)
                 (CL:TERPRI %%STREAM)
                 (CL:FORCE-OUTPUT %%STREAM))))
              (CL:SETQ DIRECTION SYM-METHODS-IN)))
            (CL:SETQ P (CLSYS-SVAL CONS REST P)))
           (CL:OTHERWISE
            (CL:LET*
             ((*PRINTREADABLY?* TRUE))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-ERROR)
             (CL:WHEN
              (CL:EQ (SUPPRESS-WARNINGS?) 0)
              (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
              (CL:LET
               ((%%STREAM
                 (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
               (CL:TERPRI %%STREAM)
               (CL:FORCE-OUTPUT %%STREAM)
               (CL:WRITE-STRING " Illegal method parameter: `" %%STREAM)
               (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE P) %%STREAM)
               (CL:WRITE-STRING "'." %%STREAM)
               (CL:TERPRI %%STREAM)
               (CL:FORCE-OUTPUT %%STREAM))))
            (CL:GO :CONTINUE)))
          (CL:IF
           (CL:EQ VARIABLEARGS? 1)
           (CL:LET*
            ((VARARGTYPE
              (LIST*
               SYM-METHODS-ARGUMENT-LIST
               SYM-METHODS-OF
               (SECOND P)
               NIL)))
            (CL:SETQ NAME (FIRST P))
            (CL:SETQ TS (YIELD-TYPE-SPECIFIER VARARGTYPE))
            (FREE-CONS-LIST VARARGTYPE))
           (CL:PROGN
            (CL:WHEN
             (CL:NOT
              (CL:AND
               (CL:EQ (SYMBOL? (FIRST P)) 1)
               (CL:OR
                (CL:EQ (SYMBOL? (SECOND P)) 1)
                (CL:EQ (SURROGATE? (SECOND P)) 1)
                (CL:EQ (CONS? (SECOND P)) 1))))
             (CL:LET*
              ((*PRINTREADABLY?* TRUE))
              (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
              (SIGNAL-TRANSLATION-ERROR)
              (CL:WHEN
               (CL:EQ (SUPPRESS-WARNINGS?) 0)
               (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
               (CL:LET
                ((%%STREAM
                  (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
                (CL:TERPRI %%STREAM)
                (CL:FORCE-OUTPUT %%STREAM)
                (CL:WRITE-STRING " Illegal method parameter: `" %%STREAM)
                (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE P) %%STREAM)
                (CL:WRITE-STRING "'." %%STREAM)
                (CL:TERPRI %%STREAM)
                (CL:FORCE-OUTPUT %%STREAM))))
             (CL:GO :CONTINUE))
            (CL:SETQ NAME (FIRST P))
            (CL:SETQ TS (YIELD-TYPE-SPECIFIER (SECOND P)))))))
        ((CL:EQ (SYMBOL? P) 1)
         (CL:LET*
          ((P NULL))
          (CL:SETQ P P-001)
          (CL:COND
           ((CL:EQ P SYM-METHODS-&REST)
            (SET-DYNAMIC-SLOT-VALUE
             METHOD
             SYM-METHODS-METHOD-VARIABLE-ARGUMENTS?
             (WRAP-BOOLEAN TRUE)
             NULL-BOOLEAN-WRAPPER)
            (CL:SETQ VARIABLEARGS? TRUE)
            (CL:GO :CONTINUE))
           ((CL:EQ P SYM-METHODS-&BODY)
            (SET-DYNAMIC-SLOT-VALUE
             METHOD
             SYM-METHODS-METHOD-BODY-ARGUMENT?
             (WRAP-BOOLEAN TRUE)
             NULL-BOOLEAN-WRAPPER)
            (CL:GO :CONTINUE))
           (CL:T
            (CL:LET*
             ((*PRINTREADABLY?* TRUE))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-ERROR)
             (CL:WHEN
              (CL:EQ (SUPPRESS-WARNINGS?) 0)
              (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
              (CL:LET
               ((%%STREAM
                 (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
               (CL:TERPRI %%STREAM)
               (CL:FORCE-OUTPUT %%STREAM)
               (CL:WRITE-STRING
                " Untyped parameter in parameter list: `"
                %%STREAM)
               (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE PARAMETERS) %%STREAM)
               (CL:WRITE-STRING "'." %%STREAM)
               (CL:TERPRI %%STREAM)
               (CL:FORCE-OUTPUT %%STREAM))))
            (CL:SETQ NAME P)
            (CL:SETQ TS SGT-METHODS-UNKNOWN)))))
        (CL:T
         (CL:LET*
          ((*PRINTREADABLY?* TRUE))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN
           (CL:EQ (SUPPRESS-WARNINGS?) 0)
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
           (CL:LET
            ((%%STREAM
              (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM)
            (CL:WRITE-STRING " Illegal parameter list: `" %%STREAM)
            (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE PARAMETERS) %%STREAM)
            (CL:WRITE-STRING "'." %%STREAM)
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM))))
         (CL:GO :CONTINUE))))
      (INSERT (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD) TS)
      (INSERT (METHOD-PARAMETER-NAMES METHOD) (PERMANENTIFY NAME))
      (CL:WHEN
       (CL:EQ (DEFINED-LIST? (METHOD-PARAMETER-DIRECTIONS METHOD)) 1)
       (INSERT (METHOD-PARAMETER-DIRECTIONS METHOD) DIRECTION))
      :CONTINUE)))
   (REVERSE (METHOD-PARAMETER-NAMES METHOD))
   (REVERSE (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))
   (REVERSE (METHOD-PARAMETER-DIRECTIONS METHOD)))
  :VOID)

;;; (DEFUN INCORPORATE-FIRST-INPUT-PARAMETER ...)

(CL:DEFUN INCORPORATE-FIRST-INPUT-PARAMETER (METHOD)
  (CL:LET*
   ((PARAMETERTYPESPECS (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))
    (FIRSTARGTYPE (FIRST PARAMETERTYPESPECS)))
   (CL:WHEN
    (CL:EQ (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? METHOD) 0)
    (CL:COND
     ((CL:EQ (EMPTY? PARAMETERTYPESPECS) 1)
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN
        (CL:EQ (SUPPRESS-WARNINGS?) 0)
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING
          " Method has no input parameters, converting it into a function."
          %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))))
      (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? METHOD) TRUE)
      (CL:RETURN-FROM INCORPORATE-FIRST-INPUT-PARAMETER))
     ((CL:AND
       (CL:NOT (CL:EQ FIRSTARGTYPE NULL))
       (CL:EQ (TYPE? FIRSTARGTYPE) 0))
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN
        (CL:EQ (SUPPRESS-WARNINGS?) 0)
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING
          " Illegal complex argument type for the first method parameter: "
          %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING "   `" %%STREAM)
         (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE FIRSTARGTYPE) %%STREAM)
         (CL:WRITE-STRING "'." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))))
      (CL:WHEN
       (CL:EQ (ANCHORED-TYPE-SPECIFIER? FIRSTARGTYPE) 1)
       (FIRST-SETTER
        (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD)
        SGT-METHODS-UNKNOWN)
       (CL:SETQ FIRSTARGTYPE SGT-METHODS-UNKNOWN)))))
   (CL:SETF
    (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD)
    (CL:IF
     (CL:NOT (CL:EQ FIRSTARGTYPE NULL))
     (TYPE-SPEC-TO-BASE-TYPE FIRSTARGTYPE)
     NULL)))
  :VOID)

;;; (DEFUN (DEFINE-STELLA-METHOD-SLOT METHOD-SLOT) ...)

(CL:DEFUN DEFINE-STELLA-METHOD-SLOT (INPUTNAME RETURNTYPES FUNCTION? INPUTPARAMETERS OPTIONS METHODBODY)
  "Define a new Stella method object (a slot), and attach it
to the class identified by the first parameter in 'inputParameters'.
Storage note: Copies 'options', but attaches to 'inputParameters' and
'methodBody'."
  (CL:SETQ METHODBODY METHODBODY)
  (CL:LET*
   ((NEWMETHOD (NEW-METHOD-SLOT)) (NAME (PERMANENTIFY INPUTNAME)))
   (CL:SETF (CLSYS-SVAL METHOD-SLOT SLOT-NAME NEWMETHOD) NAME)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? NEWMETHOD) FUNCTION?)
   (INCORPORATE-INPUT-PARAMETERS NEWMETHOD INPUTPARAMETERS)
   (INCORPORATE-FIRST-INPUT-PARAMETER NEWMETHOD)
   (CL:WHEN
    (CL:EQ RETURNTYPES NIL)
    (CL:COND
     ((CL:NOT (CL:EQ (LOOKUP OPTIONS KWD-METHODS-TYPE) NULL))
      (CL:SETQ
       RETURNTYPES
       (LOCAL-CONS (LOOKUP OPTIONS KWD-METHODS-TYPE) NIL)))
     ((CL:NOT (CL:EQ (LOOKUP OPTIONS KWD-METHODS-RETURN-TYPES) NULL))
      (CL:SETQ
       RETURNTYPES
       (LOCAL-CONS (LOOKUP OPTIONS KWD-METHODS-RETURN-TYPES) NIL)))))
   (CL:LET*
    ((TYPESPEC
      (CL:IF
       (CL:EQ RETURNTYPES NIL)
       SGT-METHODS-VOID
       (YIELD-TYPE-SPECIFIER (FIRST RETURNTYPES)))))
    (CL:IF
     (CL:EQ (TYPE? TYPESPEC) 1)
     (CL:SETF (CLSYS-SVAL METHOD-SLOT SLOT-BASE-TYPE NEWMETHOD) TYPESPEC)
     (SET-DYNAMIC-SLOT-VALUE
      NEWMETHOD
      SYM-METHODS-SLOT-TYPE-SPECIFIER
      TYPESPEC
      NULL)))
   (CL:WHEN
    (CL:NOT (CL:EQ RETURNTYPES NIL))
    (CL:SETF
     (CLSYS-SVAL METHOD-SLOT METHOD-RETURN-TYPE-SPECIFIERS NEWMETHOD)
     (NEW-LIST)))
   (CL:LET*
    ((TS NULL)
     (ITER-001 RETURNTYPES)
     (INTO-001 (METHOD-RETURN-TYPE-SPECIFIERS NEWMETHOD))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ TS (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (PERMANENT-CONS (YIELD-TYPE-SPECIFIER TS) NIL))
       (CL:IF
        (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST INTO-001) NIL)
        (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST INTO-001) COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST
         (CLSYS-SVAL LIST THE-CONS-LIST INTO-001)
         COLLECT-001)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-001)
        (PERMANENT-CONS (YIELD-TYPE-SPECIFIER TS) NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:LET*
    ((VALUE NULL) (KEY NULL) (ITER-002 (ALLOCATE-ITERATOR OPTIONS)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-002) 1)
     DO
     (CL:SETQ KEY (CLSYS-SVAL KV-LIST-ITERATOR KEY ITER-002))
     (CL:PROGN (CL:SETQ VALUE (CLSYS-SVAL KV-LIST-ITERATOR VALUE ITER-002)))
     (CL:LET*
      ((TEST-VALUE-001 KEY))
      (CL:COND
       ((CL:EQ TEST-VALUE-001 KWD-METHODS-PUBLIC?)
        (CL:SETF
         (CLSYS-SVAL METHOD-SLOT SLOT-PUBLIC? NEWMETHOD)
         (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE)))
       ((CL:EQ TEST-VALUE-001 KWD-METHODS-NATIVE?)
        (SET-DYNAMIC-SLOT-VALUE
         NEWMETHOD
         SYM-METHODS-METHOD-NATIVE?
         (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
         NULL-BOOLEAN-WRAPPER))
       ((CL:EQ TEST-VALUE-001 KWD-METHODS-GLOBALLY-INLINE?)
        (SET-DYNAMIC-SLOT-VALUE
         NEWMETHOD
         SYM-METHODS-METHOD-GLOBALLY-INLINE?
         (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
         NULL-BOOLEAN-WRAPPER))
       ((CL:EQ TEST-VALUE-001 KWD-METHODS-INLINE)
        (CL:WHEN
         (CL:EQ (EMPTY? (METHOD-INLINED-FUNCTIONS NEWMETHOD)) 1)
         (SET-DYNAMIC-SLOT-VALUE
          NEWMETHOD
          SYM-METHODS-METHOD-INLINED-FUNCTIONS
          (NEW-LIST)
          NULL))
        (CL:LET*
         ((VALUE-001 VALUE))
         (CL:COND
          ((CL:EQ (CONS? VALUE) 1)
           (CL:LET*
            ((VALUE NULL))
            (CL:SETQ VALUE VALUE-001)
            (CL:LET*
             ((FNNAME NULL) (ITER-003 VALUE))
             (CL:LOOP
              WHILE
              (CL:NOT (CL:EQ ITER-003 NIL))
              DO
              (CL:PROGN
               (CL:SETQ FNNAME (CLSYS-SVAL CONS VALUE ITER-003))
               (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
              (INSERT (METHOD-INLINED-FUNCTIONS NEWMETHOD) FNNAME)))))
          ((CL:EQ (SYMBOL? VALUE) 1)
           (CL:LET*
            ((VALUE NULL))
            (CL:SETQ VALUE VALUE-001)
            (INSERT (METHOD-INLINED-FUNCTIONS NEWMETHOD) VALUE)))
          (CL:T (CL:WARN "Illegal :inline argument: `~A'" VALUE)))))
       ((CL:EQ TEST-VALUE-001 KWD-METHODS-AUXILIARY?)
        (SET-DYNAMIC-SLOT-VALUE
         NEWMETHOD
         SYM-METHODS-SLOT-AUXILIARY?
         (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
         NULL-BOOLEAN-WRAPPER))
       ((CL:EQ TEST-VALUE-001 KWD-METHODS-DOCUMENTATION)
        (SET-DYNAMIC-SLOT-VALUE
         NEWMETHOD
         SYM-METHODS-DOCUMENTATION
         (WRAP-STRING (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
         NULL-STRING-WRAPPER))
       ((CL:OR
         (CL:EQ TEST-VALUE-001 KWD-METHODS-TYPE)
         (CL:EQ TEST-VALUE-001 KWD-METHODS-RETURNS))
        NULL)
       ((CL:EQ TEST-VALUE-001 KWD-METHODS-STORAGE-SLOT)
        (SET-DYNAMIC-SLOT-VALUE
         NEWMETHOD
         SYM-METHODS-STORAGE-SLOT
         (PERMANENTIFY VALUE)
         NULL))
       ((CL:EQ TEST-VALUE-001 KWD-METHODS-INHERITS-THROUGH)
        (SET-DYNAMIC-SLOT-VALUE
         NEWMETHOD
         SYM-METHODS-METHOD-INHERITS-THROUGH
         (PERMANENTIFY VALUE)
         NULL))
       ((CL:EQ TEST-VALUE-001 KWD-METHODS-PROPERTIES)
        (SET-DYNAMIC-SLOT-VALUE NEWMETHOD SYM-METHODS-PROPERTIES VALUE NULL))
       ((CL:EQ TEST-VALUE-001 KWD-METHODS-META-ATTRIBUTES)
        (SET-DYNAMIC-SLOT-VALUE
         NEWMETHOD
         SYM-METHODS-META-ATTRIBUTES
         VALUE
         NULL))
       ((CL:EQ TEST-VALUE-001 KWD-METHODS-COMMAND?)
        (SET-DYNAMIC-SLOT-VALUE
         NEWMETHOD
         SYM-METHODS-METHOD-COMMAND?
         (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
         NULL-BOOLEAN-WRAPPER))
       ((CL:EQ TEST-VALUE-001 KWD-METHODS-LISP-MACRO?)
        (SET-DYNAMIC-SLOT-VALUE
         NEWMETHOD
         SYM-METHODS-METHOD-LISP-MACRO?
         (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
         NULL-BOOLEAN-WRAPPER))
       ((CL:EQ TEST-VALUE-001 KWD-METHODS-EVALUATE-ARGUMENTS?)
        (SET-DYNAMIC-SLOT-VALUE
         NEWMETHOD
         SYM-METHODS-METHOD-EVALUATE-ARGUMENTS?
         (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
         NULL-BOOLEAN-WRAPPER))
       (CL:T
        (CL:WHEN
         (CL:EQ (RUN-OPTION-HANDLER? NEWMETHOD KEY VALUE) 0)
         (CL:LET*
          ((*PRINTREADABLY?* TRUE))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-WARNING)
          (CL:WHEN
           (CL:EQ (SUPPRESS-WARNINGS?) 0)
           (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
           (CL:LET
            ((%%STREAM
              (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM)
            (CL:WRITE-STRING " Skipping invalid method option `" %%STREAM)
            (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE KEY) %%STREAM)
            (CL:WRITE-STRING "'" %%STREAM)
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM)
            (CL:WRITE-STRING "in the definition of method `" %%STREAM)
            (PRINT-OBJECT
             (CLSYS-SVAL METHOD-SLOT SLOT-OWNER NEWMETHOD)
             %%STREAM)
            (CL:WRITE-STRING "'.`" %%STREAM)
            (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE NAME) %%STREAM)
            (CL:WRITE-STRING "'." %%STREAM)
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM))))))))))
   (CL:RETURN-FROM DEFINE-STELLA-METHOD-SLOT NEWMETHOD))
  :VOID)

;;; (DEFUN (ATTACH-METHOD-SLOT-TO-OWNER METHOD-SLOT) ...)

(CL:DEFUN ATTACH-METHOD-SLOT-TO-OWNER (NEWMETHOD)
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? NEWMETHOD) 1)
   (CL:RETURN-FROM ATTACH-METHOD-SLOT-TO-OWNER (ATTACH-FUNCTION NEWMETHOD)))
  (CL:WHEN
   (CL:EQ
    (CLSYS-SVAL
     SURROGATE
     SURROGATE-VALUE
     (CLSYS-SVAL METHOD-SLOT SLOT-OWNER NEWMETHOD))
    NULL)
   (CL:RETURN-FROM ATTACH-METHOD-SLOT-TO-OWNER NEWMETHOD))
  (CL:RETURN-FROM ATTACH-METHOD-SLOT-TO-OWNER (ATTACH-SLOT-TO-OWNER NEWMETHOD))
  :VOID)

;;; (DEFGLOBAL *MAXIMUM-STRING-CONSTANT-SIZE* ...)

(CL:DEFVAR *MAXIMUM-STRING-CONSTANT-SIZE* 4000
  "Maximum size for a string constant in the target language.")

;;; (DEFUN (YIELD-STRING-CONSTANT-TREE OBJECT) ...)

(CL:DEFUN YIELD-STRING-CONSTANT-TREE (STRING)
  (CL:LET*
   ((LENGTH (LENGTH STRING)) (CHUNKS NIL) (START 0) (STRINGTREE NULL))
   (CL:WHEN
    (CL:<= LENGTH *MAXIMUM-STRING-CONSTANT-SIZE*)
    (CL:RETURN-FROM YIELD-STRING-CONSTANT-TREE (WRAP-LITERAL STRING)))
   (CL:LOOP
    WHILE
    (CL:< (CL:+ START *MAXIMUM-STRING-CONSTANT-SIZE*) LENGTH)
    DO
    (CL:SETQ
     CHUNKS
     (CONS
      (WRAP-LITERAL
       (SUBSEQUENCE STRING START (CL:+ START *MAXIMUM-STRING-CONSTANT-SIZE*)))
      CHUNKS))
    (CL:SETQ START (CL:+ START *MAXIMUM-STRING-CONSTANT-SIZE*)))
   (CL:WHEN
    (CL:< START LENGTH)
    (CL:SETQ
     CHUNKS
     (CONS (WRAP-LITERAL (SUBSEQUENCE STRING START LENGTH)) CHUNKS)))
   (CL:SETQ STRINGTREE (FIRST CHUNKS))
   (CL:LET*
    ((CHUNK NULL) (ITER-001 (CLSYS-SVAL CONS REST CHUNKS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ CHUNK (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:SETQ
      STRINGTREE
      (LIST* SYM-METHODS-CONCATENATE CHUNK (CONS STRINGTREE NIL)))))
   (FREE-CONS-LIST CHUNKS)
   (CL:RETURN-FROM YIELD-STRING-CONSTANT-TREE STRINGTREE))
  :VOID)

;;; (DEFUN (YIELD-DEFINE-STELLA-METHOD CONS) ...)

(CL:DEFUN YIELD-DEFINE-STELLA-METHOD (METHOD)
  "Return a cons tree that (when evaluated) constructs a Stella method
object and attaches it to its owner class."
  ()
  (CL:LET*
   ((WRAPPEDCLASSNAME
     (CL:IF
      (CL:NOT (CL:EQ (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD) NULL))
      (WRAP-LITERAL
       (CLSYS-SVAL
        SURROGATE
        SYMBOL-NAME
        (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD)))
      SYM-METHODS-NULL)))
   (CL:RETURN-FROM
    YIELD-DEFINE-STELLA-METHOD
    (LIST*
     SYM-METHODS-DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     (WRAP-LITERAL (NAME METHOD))
     (CONS
      WRAPPEDCLASSNAME
      (CONS
       (YIELD-STRING-CONSTANT-TREE
        (CLSYS-SVAL METHOD-SLOT METHOD-STRINGIFIED-SOURCE METHOD))
       NIL)))))
  :VOID)

;;; (DEFUN (YIELD-CLASS-PARAMETER-TYPES (CONS OF TYPE)) ...)

(CL:DEFUN YIELD-CLASS-PARAMETER-TYPES (CLASS)
  (CL:LET*
   ((TYPES NIL))
   (CL:LET*
    ((PNAME NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST (PARAMETERS CLASS)))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ PNAME (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ
        COLLECT-001
        (CONS (CLSYS-SVAL SLOT SLOT-BASE-TYPE (LOOKUP-SLOT CLASS PNAME)) NIL))
       (CL:IF
        (CL:EQ TYPES NIL)
        (CL:SETQ TYPES COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST TYPES COLLECT-001)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-001)
        (CONS (CLSYS-SVAL SLOT SLOT-BASE-TYPE (LOOKUP-SLOT CLASS PNAME)) NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:RETURN-FROM YIELD-CLASS-PARAMETER-TYPES TYPES))
  :VOID)

;;; (DEFUN (OPTIMISTIC-SUBTYPE-OF? BOOLEAN) ...)

(CL:DEFUN OPTIMISTIC-SUBTYPE-OF? (SUBTYPE SUPERTYPE)
  (CL:IF
   (CL:AND
    (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUBTYPE) NULL))
    (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPERTYPE) NULL))
    (CL:EQ
     (CLSYS-SVAL
      CLASS
      CLASS-FINALIZED?
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUBTYPE))
     1))
   (CL:RETURN-FROM OPTIMISTIC-SUBTYPE-OF? (SUBTYPE-OF? SUBTYPE SUPERTYPE))
   (CL:RETURN-FROM OPTIMISTIC-SUBTYPE-OF? TRUE))
  :VOID)

;;; (DEFUN WARN-OF-PARAMETER-MISMATCH ...)

(CL:DEFUN WARN-OF-PARAMETER-MISMATCH (SELF MESSAGE)
  (CL:LET*
   ((INHERITEDTYPES
     (YIELD-CLASS-PARAMETER-TYPES
      (CLSYS-SVAL
       SURROGATE
       SURROGATE-VALUE
       (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE SELF)))))
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (CL:WARN
     "`~A'~%Type `~A' takes parameters of type ~%`~A' but was modified by a list of types `~A'"
     MESSAGE
     (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE SELF)
     INHERITEDTYPES
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-PARAMETER-TYPES SELF)))
    (FREE-CONS-LIST INHERITEDTYPES)))
  :VOID)

;;; (DEFUN (VALIDATE-TYPE-SPECIFIER TYPE) ...)

(CL:DEFUN VALIDATE-TYPE-SPECIFIER (SELF ANCHORCLASS SKIPANCHOREDTYPE?)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (PARAMETRIC-TYPE-SPECIFIER? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:EQ
        (CLSYS-SVAL
         SURROGATE
         SURROGATE-VALUE
         (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE SELF))
        NULL)
       (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER SGT-METHODS-UNKNOWN))
      (CL:LET*
       ((PARAMETERDIFFERENTIAL
         (CL:-
          (LENGTH
           (CLSYS-SVAL
            PARAMETRIC-TYPE-SPECIFIER
            SPECIFIER-PARAMETER-TYPES
            SELF))
          (LENGTH
           (PARAMETERS
            (CLSYS-SVAL
             SURROGATE
             SURROGATE-VALUE
             (CLSYS-SVAL
              PARAMETRIC-TYPE-SPECIFIER
              SPECIFIER-BASE-TYPE
              SELF)))))))
       (CL:COND
        ((CL:> PARAMETERDIFFERENTIAL 0)
         (WARN-OF-PARAMETER-MISMATCH
          SELF
          "Too many parameters in type specification."))
        ((CL:< PARAMETERDIFFERENTIAL 0)
         (WARN-OF-PARAMETER-MISMATCH
          SELF
          "Not enough parameters in type specification."))
        (CL:T
         (CL:LET*
          ((BASECLASS
            (CLSYS-SVAL
             SURROGATE
             SURROGATE-VALUE
             (TYPE-SPEC-TO-BASE-TYPE SELF))))
          (CL:WHEN
           (CL:EQ (CLSYS-SVAL CLASS CLASS-SLOTS-FINALIZED? BASECLASS) 1)
           (CL:LET*
            ((INHERITEDTYPES (YIELD-CLASS-PARAMETER-TYPES BASECLASS)))
            (CL:LET*
             ((SUBTYPESPEC NULL)
              (SUPERTYPE NULL)
              (ITER-001 INHERITEDTYPES)
              (ITER-002
               (CLSYS-SVAL
                LIST
                THE-CONS-LIST
                (CLSYS-SVAL
                 PARAMETRIC-TYPE-SPECIFIER
                 SPECIFIER-PARAMETER-TYPES
                 SELF))))
             (CL:LOOP
              WHILE
              (CL:AND
               (CL:NOT (CL:EQ ITER-001 NIL))
               (CL:NOT (CL:EQ ITER-002 NIL)))
              DO
              (CL:PROGN
               (CL:SETQ SUPERTYPE (CLSYS-SVAL CONS VALUE ITER-001))
               (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
              (CL:PROGN
               (CL:SETQ SUBTYPESPEC (CLSYS-SVAL CONS VALUE ITER-002))
               (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
              (CL:WHEN
               (CL:AND
                (CL:EQ (ANCHORED-TYPE-SPECIFIER? SUBTYPESPEC) 0)
                (CL:EQ
                 (OPTIMISTIC-SUBTYPE-OF?
                  (TYPE-SPEC-TO-BASE-TYPE SUBTYPESPEC)
                  SUPERTYPE)
                 0))
               (WARN-OF-PARAMETER-MISMATCH
                SELF
                "Parameteric subtype(s) don't specialize supertype(s)"))))
            (FREE-CONS-LIST INHERITEDTYPES))))))
       (CL:RETURN-FROM
        VALIDATE-TYPE-SPECIFIER
        (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE SELF)))))
    ((CL:EQ (ANCHORED-TYPE-SPECIFIER? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:EQ SKIPANCHOREDTYPE? 1)
       (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER NULL))
      (CL:WHEN
       (CL:EQ ANCHORCLASS NULL)
       (CL:WARN
        "Illegal use of anchored type for function that has no first
argument (and hence nothing to anchor onto).")
       (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER NULL))
      (CL:LET*
       ((SLOTNAME
         (CLSYS-SVAL ANCHORED-TYPE-SPECIFIER SPECIFIER-PARAMETER-NAME SELF))
        (ANCHORSLOT NULL))
       (CL:WHEN
        (CL:EQ SLOTNAME NULL)
        (CL:RETURN-FROM
         VALIDATE-TYPE-SPECIFIER
         (CLSYS-SVAL CLASS CLASS-TYPE ANCHORCLASS)))
       (CL:LET*
        ()
        (CL:SETQ ANCHORSLOT (LOOKUP-SLOT ANCHORCLASS SLOTNAME))
        (CL:WHEN
         (CL:EQ ANCHORSLOT NULL)
         (CL:CERROR
          "Continue anyway? "
          "Can't find a slot named `~A' on the class `~A'"
          SLOTNAME
          (CLASS-NAME ANCHORCLASS))))
       (CL:RETURN-FROM
        VALIDATE-TYPE-SPECIFIER
        (CLSYS-SVAL SLOT SLOT-BASE-TYPE ANCHORSLOT)))))
    ((CL:EQ (TYPE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER SELF)))
    (CL:T (CL:ERROR "validate-type-specifier: Not defined on `~A'" SELF))))
  :VOID)

;;; (DEFUN (SYNTHESIZE-METHOD-BODY CONS) ...)

(CL:DEFUN SYNTHESIZE-METHOD-BODY (METHOD)
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-METHODS-BOOLEAN) NULL)
   (CL:RETURN-FROM SYNTHESIZE-METHOD-BODY NIL))
  (CL:LET*
   ((STORAGESLOTNAME
     (DYNAMIC-SLOT-VALUE METHOD SYM-METHODS-STORAGE-SLOT NULL))
    (INHERITANCESLOTNAME
     (DYNAMIC-SLOT-VALUE METHOD SYM-METHODS-METHOD-INHERITS-THROUGH NULL))
    (STORAGESLOT NULL)
    (INHERITANCESLOT NULL)
    (DEFAULTVALUE NULL))
   (CL:COND
    ((CL:EQ INHERITANCESLOTNAME SYM-METHODS-SUPER-CLASSES)
     (CL:SETQ INHERITANCESLOTNAME SYM-METHODS-CLASS-ALL-SUPER-CLASSES))
    ((CL:EQ INHERITANCESLOTNAME SYM-METHODS-EQUIVALENT-SLOT)
     (CL:SETQ INHERITANCESLOTNAME SYM-METHODS-SLOT-DIRECT-EQUIVALENT))
    (CL:T NULL))
   (CL:SETQ
    STORAGESLOT
    (SAFE-LOOKUP-SLOT
     (CLSYS-SVAL
      SURROGATE
      SURROGATE-VALUE
      (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD))
     STORAGESLOTNAME))
   (CL:WHEN
    (CL:EQ STORAGESLOT NULL)
    (CL:WARN
     ":storage-slot references non-existent slot `~A' on the class `~A'"
     STORAGESLOTNAME
     (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD))
    (CL:RETURN-FROM SYNTHESIZE-METHOD-BODY NIL))
   (CL:SETQ
    INHERITANCESLOT
    (SAFE-LOOKUP-SLOT
     (CLSYS-SVAL
      SURROGATE
      SURROGATE-VALUE
      (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD))
     INHERITANCESLOTNAME))
   (CL:WHEN
    (CL:EQ INHERITANCESLOT NULL)
    (CL:WARN
     ":inherits-through references non-existent slot `~A' on the class `~A'"
     INHERITANCESLOTNAME
     (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD))
    (CL:RETURN-FROM SYNTHESIZE-METHOD-BODY NIL))
   (CL:SETQ DEFAULTVALUE (SYSTEM-DEFAULT-VALUE STORAGESLOT))
   (CL:RETURN-FROM
    SYNTHESIZE-METHOD-BODY
    (CONS
     (LIST*
      SYM-METHODS-LET
      (LIST*
       (LIST* SYM-METHODS-CURSOR SYM-METHODS-SELF NIL)
       (LIST*
        SYM-METHODS-VALUE
        (LIST* SYM-METHODS-SLOT-VALUE SYM-METHODS-CURSOR STORAGESLOTNAME NIL)
        NIL)
       NIL)
      (LIST*
       SYM-METHODS-LOOP
       (CONS
        SYM-METHODS-WHEN
        (CONCATENATE
         (CL:IF
          (CL:EQ (SUBTYPE-OF? (TYPE STORAGESLOT) SGT-METHODS-BOOLEAN) 1)
          (CONS SYM-METHODS-VALUE NIL)
          (CONS (LIST* SYM-METHODS-DEFINED? SYM-METHODS-VALUE NIL) NIL))
         (CONS (LIST* SYM-METHODS-RETURN SYM-METHODS-VALUE NIL) NIL)))
       (LIST*
        SYM-METHODS-SETQ
        SYM-METHODS-CURSOR
        (CL:IF
         (CL:OR
          (CL:EQ
           (SUBTYPE-OF? (TYPE INHERITANCESLOT) SGT-METHODS-COLLECTION)
           1)
          (CL:EQ (SUBTYPE-OF? (TYPE INHERITANCESLOT) SGT-METHODS-CONS) 1))
         (LIST*
          SYM-METHODS-FIRST
          (CONS INHERITANCESLOTNAME (CONS SYM-METHODS-CURSOR NIL))
          NIL)
         (CONS INHERITANCESLOTNAME (CONS SYM-METHODS-CURSOR NIL)))
        NIL)
       (LIST*
        SYM-METHODS-IF
        (LIST* SYM-METHODS-DEFINED? SYM-METHODS-CURSOR NIL)
        (LIST*
         SYM-METHODS-SETQ
         SYM-METHODS-VALUE
         (LIST* SYM-METHODS-SLOT-VALUE SYM-METHODS-CURSOR STORAGESLOTNAME NIL)
         NIL)
        (LIST*
         SYM-METHODS-RETURN
         (CL:IF
          (CL:NOT (CL:EQ DEFAULTVALUE NULL))
          DEFAULTVALUE
          SYM-METHODS-NULL)
         NIL)
        NIL)
       NIL)
      NIL)
     NIL)))
  :VOID)

;;; (DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ...)

(CL:DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ((SELF METHOD-SLOT))
  (CL:LET*
   ((OWNERCLASS
     (CL:IF
      (CL:NOT (CL:EQ (CLSYS-SVAL METHOD-SLOT SLOT-OWNER SELF) NULL))
      (CLSYS-SVAL
       SURROGATE
       SURROGATE-VALUE
       (CLSYS-SVAL METHOD-SLOT SLOT-OWNER SELF))
      NULL)))
   (CL:LET*
    ((TS NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (METHOD-PARAMETER-TYPE-SPECIFIERS SELF))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ TS (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (VALIDATE-TYPE-SPECIFIER TS OWNERCLASS FALSE)))
   (CL:WHEN
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE SELF SYM-METHODS-SLOT-TYPE-SPECIFIER NULL)
      NULL))
    (CL:SETF
     (CLSYS-SVAL METHOD-SLOT SLOT-BASE-TYPE SELF)
     (VALIDATE-TYPE-SPECIFIER
      (DYNAMIC-SLOT-VALUE SELF SYM-METHODS-SLOT-TYPE-SPECIFIER NULL)
      OWNERCLASS
      FALSE)))
   (CL:LET*
    ((TS NULL) (ITER-002 (REST (METHOD-RETURN-TYPE-SPECIFIERS SELF))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ TS (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (VALIDATE-TYPE-SPECIFIER TS OWNERCLASS FALSE))))
  :VOID)

;;; (DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ...)

(CL:DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ((SELF METHOD-SLOT))
  NULL
  :VOID)

;;; (DEFMETHOD UNFINALIZE-LOCAL-SLOT ...)

(CL:DEFMETHOD UNFINALIZE-LOCAL-SLOT ((SELF METHOD-SLOT))
  NULL
  :VOID)

;;; (DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ...)

(CL:DEFMETHOD METHOD-ARGUMENT-COUNT ((SELF SLOT))
  (CL:ERROR "method-argument-count: Not defined on `~A'" SELF)
  (CL:RETURN-FROM METHOD-ARGUMENT-COUNT NULL-INTEGER)
  :VOID)

;;; (DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ...)

(CL:DEFMETHOD METHOD-ARGUMENT-COUNT ((SELF STORAGE-SLOT))
  (CL:RETURN-FROM METHOD-ARGUMENT-COUNT 1)
  :VOID)

;;; (DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ...)

(CL:DEFMETHOD METHOD-ARGUMENT-COUNT ((SELF METHOD-SLOT))
  (CL:RETURN-FROM METHOD-ARGUMENT-COUNT (LENGTH (METHOD-PARAMETER-NAMES SELF)))
  :VOID)

;;; (DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ...)

(CL:DEFMETHOD METHOD-ARGUMENT-COUNT ((SELF TABLE))
  (CL:RETURN-FROM
   METHOD-ARGUMENT-COUNT
   (CL:1- (LENGTH (CLSYS-SVAL TABLE TUPLE-DOMAINS SELF))))
  :VOID)

;;; (DEFMETHOD (METHOD-VARIABLE-ARGUMENTS? BOOLEAN) ...)

(CL:DEFMETHOD METHOD-VARIABLE-ARGUMENTS? ((SELF STORAGE-SLOT))
  (CL:RETURN-FROM METHOD-VARIABLE-ARGUMENTS? FALSE)
  :VOID)

;;; (DEFMETHOD (METHOD-BODY-ARGUMENT? BOOLEAN) ...)

(CL:DEFMETHOD METHOD-BODY-ARGUMENT? ((SELF STORAGE-SLOT))
  (CL:RETURN-FROM METHOD-BODY-ARGUMENT? FALSE)
  :VOID)

;;; (DEFMETHOD (ARITY INTEGER) ...)

(CL:DEFMETHOD ARITY ((SELF STORAGE-SLOT))
  (CL:RETURN-FROM ARITY 2)
  :VOID)

;;; (DEFMETHOD (ARITY INTEGER) ...)

(CL:DEFMETHOD ARITY ((SELF METHOD-SLOT))
  (CL:LET*
   ((RETURNTYPECOUNT (LENGTH (METHOD-RETURN-TYPE-SPECIFIERS SELF)))
    (RESULT
     (CL:+ (LENGTH (METHOD-PARAMETER-TYPE-SPECIFIERS SELF)) RETURNTYPECOUNT)))
   (CL:CASE
    RETURNTYPECOUNT
    (1
     (CL:IF
      (CL:EQ (FIRST (METHOD-RETURN-TYPE-SPECIFIERS SELF)) SGT-METHODS-BOOLEAN)
      (CL:RETURN-FROM ARITY (CL:1- RESULT))
      (CL:RETURN-FROM ARITY RESULT)))
    (0 (CL:RETURN-FROM ARITY RESULT))
    (CL:OTHERWISE
     (CL:IF
      (CL:EQ (LAST (METHOD-RETURN-TYPE-SPECIFIERS SELF)) SGT-METHODS-BOOLEAN)
      (CL:RETURN-FROM ARITY (CL:1- RESULT))
      (CL:RETURN-FROM ARITY RESULT)))))
  :VOID)

;;; (DEFMETHOD (ARITY INTEGER) ...)

(CL:DEFMETHOD ARITY ((SELF TABLE))
  (CL:RETURN-FROM ARITY (LENGTH (CLSYS-SVAL TABLE TUPLE-DOMAINS SELF)))
  :VOID)

;;; (DEFUN (TYPE-SPEC-TO-BASE-TYPE TYPE) ...)

(CL:DEFUN TYPE-SPEC-TO-BASE-TYPE (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TYPE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM TYPE-SPEC-TO-BASE-TYPE SELF)))
    ((CL:EQ (PARAMETRIC-TYPE-SPECIFIER? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       TYPE-SPEC-TO-BASE-TYPE
       (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE SELF))))
    (CL:T (CL:ERROR "type-spec-to-base-type: Not defined on `~A'" SELF))))
  :VOID)

;;; (DEFUN (TYPE-SPEC-TO-CLASS CLASS) ...)

(CL:DEFUN TYPE-SPEC-TO-CLASS (SELF)
  (CL:RETURN-FROM
   TYPE-SPEC-TO-CLASS
   (CLSYS-SVAL SURROGATE SURROGATE-VALUE (TYPE-SPEC-TO-BASE-TYPE SELF)))
  :VOID)

;;; (DEFUN (COMPATIBLE-PARAMETER-TYPES? BOOLEAN) ...)

(CL:DEFUN COMPATIBLE-PARAMETER-TYPES? (SUBTYPE SUPERTYPE)
  (CL:WHEN
   (CL:OR (CL:EQ (TYPE? SUBTYPE) 1) (CL:EQ (TYPE? SUPERTYPE) 1))
   (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? TRUE))
  (CL:LET*
   ((SUBCLASS NULL) (SUPERCLASS NULL))
   (CL:LET*
    ((SUBTYPE-001 SUBTYPE))
    (CL:COND
     ((CL:EQ (TYPE? SUBTYPE) 1)
      (CL:LET*
       ((SUBTYPE NULL))
       (CL:SETQ SUBTYPE SUBTYPE-001)
       (CL:SETQ SUBCLASS (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUBTYPE))))
     ((CL:EQ (PARAMETRIC-TYPE-SPECIFIER? SUBTYPE) 1)
      (CL:LET*
       ((SUBTYPE NULL))
       (CL:SETQ SUBTYPE SUBTYPE-001)
       (CL:SETQ
        SUBCLASS
        (CLSYS-SVAL
         SURROGATE
         SURROGATE-VALUE
         (CLSYS-SVAL
          PARAMETRIC-TYPE-SPECIFIER
          SPECIFIER-BASE-TYPE
          SUBTYPE)))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" SUBTYPE))))
   (CL:LET*
    ((SUPERTYPE-001 SUPERTYPE))
    (CL:COND
     ((CL:EQ (TYPE? SUPERTYPE) 1)
      (CL:LET*
       ((SUPERTYPE NULL))
       (CL:SETQ SUPERTYPE SUPERTYPE-001)
       (CL:SETQ SUPERCLASS (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPERTYPE))))
     ((CL:EQ (PARAMETRIC-TYPE-SPECIFIER? SUPERTYPE) 1)
      (CL:LET*
       ((SUPERTYPE NULL))
       (CL:SETQ SUPERTYPE SUPERTYPE-001)
       (CL:SETQ
        SUPERCLASS
        (CLSYS-SVAL
         SURROGATE
         SURROGATE-VALUE
         (CLSYS-SVAL
          PARAMETRIC-TYPE-SPECIFIER
          SPECIFIER-BASE-TYPE
          SUPERTYPE)))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" SUPERTYPE))))
   (CL:LET*
    ((SUPPAR NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST (PARAMETERS SUPERCLASS))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUPPAR (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:LET*
      ((TEST-VALUE-001 FALSE))
      (CL:LET*
       ((FOUND?-001 FALSE))
       (CL:LET*
        ((SUBPAR NULL)
         (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST (PARAMETERS SUBCLASS))))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-002 NIL))
         DO
         (CL:PROGN
          (CL:SETQ SUBPAR (CLSYS-SVAL CONS VALUE ITER-002))
          (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
         (CL:WHEN
          (CL:EQ SUPPAR SUBPAR)
          (CL:SETQ FOUND?-001 TRUE)
          (CL:RETURN))))
       (CL:SETQ TEST-VALUE-001 FOUND?-001))
      (CL:WHEN
       (CL:EQ TEST-VALUE-001 1)
       (CL:SETQ
        TEST-VALUE-001
        (SUB-TYPE-SPEC-OF?
         (EXTRACT-PARAMETER-TYPE SUBTYPE SUPPAR)
         (EXTRACT-PARAMETER-TYPE SUPERTYPE SUPPAR))))
      (CL:WHEN
       (CL:EQ TEST-VALUE-001 0)
       (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? FALSE)))))
   (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? TRUE))
  :VOID)

;;; (DEFUN (SUB-TYPE-SPEC-OF? BOOLEAN) ...)

(CL:DEFUN SUB-TYPE-SPEC-OF? (SUBTYPE SUPERTYPE)
  (CL:WHEN (CL:EQ SUBTYPE SUPERTYPE) (CL:RETURN-FROM SUB-TYPE-SPEC-OF? TRUE))
  (CL:LET*
   ((SUBTYPE-001 SUBTYPE))
   (CL:COND
    ((CL:EQ (TYPE? SUBTYPE) 1)
     (CL:LET*
      ((SUBTYPE NULL))
      (CL:SETQ SUBTYPE SUBTYPE-001)
      (CL:LET*
       ((SUPERTYPE-001 SUPERTYPE))
       (CL:COND
        ((CL:EQ (TYPE? SUPERTYPE) 1)
         (CL:LET*
          ((SUPERTYPE NULL))
          (CL:SETQ SUPERTYPE SUPERTYPE-001)
          (CL:RETURN-FROM
           SUB-TYPE-SPEC-OF?
           (CL:IF
            (CL:AND
             (CL:EQ (SUBTYPE-OF? SUBTYPE SUPERTYPE) 1)
             (CL:EQ (COMPATIBLE-PARAMETER-TYPES? SUBTYPE SUPERTYPE) 1))
            TRUE
            FALSE))))
        ((CL:EQ (PARAMETRIC-TYPE-SPECIFIER? SUPERTYPE) 1)
         (CL:LET*
          ((SUPERTYPE NULL))
          (CL:SETQ SUPERTYPE SUPERTYPE-001)
          (CL:RETURN-FROM
           SUB-TYPE-SPEC-OF?
           (CL:IF
            (CL:AND
             (CL:EQ
              (SUBTYPE-OF?
               SUBTYPE
               (CLSYS-SVAL
                PARAMETRIC-TYPE-SPECIFIER
                SPECIFIER-BASE-TYPE
                SUPERTYPE))
              1)
             (CL:EQ (COMPATIBLE-PARAMETER-TYPES? SUBTYPE SUPERTYPE) 1))
            TRUE
            FALSE))))
        (CL:T (CL:RETURN-FROM SUB-TYPE-SPEC-OF? FALSE))))))
    ((CL:EQ (PARAMETRIC-TYPE-SPECIFIER? SUBTYPE) 1)
     (CL:LET*
      ((SUBTYPE NULL))
      (CL:SETQ SUBTYPE SUBTYPE-001)
      (CL:LET*
       ((SUPERTYPE-002 SUPERTYPE))
       (CL:COND
        ((CL:EQ (TYPE? SUPERTYPE) 1)
         (CL:LET*
          ((SUPERTYPE NULL))
          (CL:SETQ SUPERTYPE SUPERTYPE-002)
          (CL:RETURN-FROM
           SUB-TYPE-SPEC-OF?
           (CL:IF
            (CL:AND
             (CL:EQ
              (SUBTYPE-OF?
               (CLSYS-SVAL
                PARAMETRIC-TYPE-SPECIFIER
                SPECIFIER-BASE-TYPE
                SUBTYPE)
               SUPERTYPE)
              1)
             (CL:EQ (COMPATIBLE-PARAMETER-TYPES? SUBTYPE SUPERTYPE) 1))
            TRUE
            FALSE))))
        ((CL:EQ (PARAMETRIC-TYPE-SPECIFIER? SUPERTYPE) 1)
         (CL:LET*
          ((SUPERTYPE NULL))
          (CL:SETQ SUPERTYPE SUPERTYPE-002)
          (CL:RETURN-FROM
           SUB-TYPE-SPEC-OF?
           (CL:IF
            (CL:AND
             (CL:EQ
              (SUBTYPE-OF?
               (CLSYS-SVAL
                PARAMETRIC-TYPE-SPECIFIER
                SPECIFIER-BASE-TYPE
                SUBTYPE)
               (CLSYS-SVAL
                PARAMETRIC-TYPE-SPECIFIER
                SPECIFIER-BASE-TYPE
                SUPERTYPE))
              1)
             (CL:EQ (COMPATIBLE-PARAMETER-TYPES? SUBTYPE SUPERTYPE) 1))
            TRUE
            FALSE))))
        (CL:T (CL:ERROR "`~A' is not a valid case option" SUPERTYPE))))))
    ((CL:EQ (ANCHORED-TYPE-SPECIFIER? SUBTYPE) 1)
     (CL:LET*
      ((SUBTYPE NULL))
      (CL:SETQ SUBTYPE SUBTYPE-001)
      (CL:RETURN-FROM
       SUB-TYPE-SPEC-OF?
       (CL:IF
        (CL:AND
         (CL:EQ (ANCHORED-TYPE-SPECIFIER? SUPERTYPE) 1)
         (CL:EQ
          (CLSYS-SVAL
           ANCHORED-TYPE-SPECIFIER
           SPECIFIER-PARAMETER-NAME
           SUBTYPE)
          (CLSYS-SVAL
           ANCHORED-TYPE-SPECIFIER
           SPECIFIER-PARAMETER-NAME
           SUPERTYPE)))
        TRUE
        FALSE))))
    (CL:T (CL:ERROR "sub-type-spec-of?: Not defined on `~A'" SUBTYPE))))
  :VOID)

;;; (DEFUN (VOID? BOOLEAN) ...)

(CL:DEFUN VOID? (TYPE)
  (CL:RETURN-FROM VOID? (EQ? TYPE SGT-METHODS-VOID))
  :VOID)

;;; (DEFUN (EXTRACT-PARAMETER-TYPE TYPE-SPEC BOOLEAN) ...)

(CL:DEFUN EXTRACT-PARAMETER-TYPE (SELF PARAMETER)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TYPE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((SLOT
         (LOOKUP-SLOT (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) PARAMETER)))
       (CL:IF
        (CL:NOT (CL:EQ SLOT NULL))
        (CL:RETURN-FROM EXTRACT-PARAMETER-TYPE (CL:VALUES (TYPE SLOT) TRUE))
        (CL:RETURN-FROM
         EXTRACT-PARAMETER-TYPE
         (CL:VALUES SGT-METHODS-OBJECT FALSE))))))
    ((CL:EQ (PARAMETRIC-TYPE-SPECIFIER? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((PTYPE NULL)
        (PNAME NULL)
        (ITER-001
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (PARAMETERS
           (CLSYS-SVAL
            SURROGATE
            SURROGATE-VALUE
            (CLSYS-SVAL
             PARAMETRIC-TYPE-SPECIFIER
             SPECIFIER-BASE-TYPE
             SELF)))))
        (ITER-002
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (CLSYS-SVAL
           PARAMETRIC-TYPE-SPECIFIER
           SPECIFIER-PARAMETER-TYPES
           SELF))))
       (CL:LOOP
        WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL)))
        DO
        (CL:PROGN
         (CL:SETQ PNAME (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:PROGN
         (CL:SETQ PTYPE (CLSYS-SVAL CONS VALUE ITER-002))
         (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
        (CL:WHEN
         (CL:EQ PNAME PARAMETER)
         (CL:RETURN-FROM EXTRACT-PARAMETER-TYPE (CL:VALUES PTYPE TRUE)))))
      (CL:RETURN-FROM
       EXTRACT-PARAMETER-TYPE
       (CL:VALUES SGT-METHODS-OBJECT FALSE))))
    (CL:T (CL:ERROR "extract-parameter-type: Not defined on `~A'" SELF))))
  :VOID)

;;; (DEFUN (COMPUTE-ANCHORED-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFUN COMPUTE-ANCHORED-TYPE-SPEC (OWNERTYPE RELTYPE)
  (CL:LET*
   ((OWNERTYPE-001 OWNERTYPE))
   (CL:COND
    ((CL:EQ (TYPE? OWNERTYPE) 1)
     (CL:LET*
      ((OWNERTYPE NULL))
      (CL:SETQ OWNERTYPE OWNERTYPE-001)
      (CL:WHEN
       (CL:EQ
        (CLSYS-SVAL ANCHORED-TYPE-SPECIFIER SPECIFIER-PARAMETER-NAME RELTYPE)
        NULL)
       (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC OWNERTYPE))
      (CL:LET*
       ((SLOT
         (LOOKUP-SLOT
          (CLSYS-SVAL SURROGATE SURROGATE-VALUE OWNERTYPE)
          (CLSYS-SVAL
           ANCHORED-TYPE-SPECIFIER
           SPECIFIER-PARAMETER-NAME
           RELTYPE))))
       (CL:RETURN-FROM
        COMPUTE-ANCHORED-TYPE-SPEC
        (CLSYS-SVAL SLOT SLOT-BASE-TYPE SLOT)))))
    ((CL:EQ (PARAMETRIC-TYPE-SPECIFIER? OWNERTYPE) 1)
     (CL:LET*
      ((OWNERTYPE NULL))
      (CL:SETQ OWNERTYPE OWNERTYPE-001)
      (CL:WHEN
       (CL:EQ
        (CLSYS-SVAL ANCHORED-TYPE-SPECIFIER SPECIFIER-PARAMETER-NAME RELTYPE)
        NULL)
       (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC OWNERTYPE))
      (CL:LET*
       ((PTYPE NULL)
        (PNAME NULL)
        (ITER-001
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (PARAMETERS
           (CLSYS-SVAL
            SURROGATE
            SURROGATE-VALUE
            (CLSYS-SVAL
             PARAMETRIC-TYPE-SPECIFIER
             SPECIFIER-BASE-TYPE
             OWNERTYPE)))))
        (ITER-002
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (CLSYS-SVAL
           PARAMETRIC-TYPE-SPECIFIER
           SPECIFIER-PARAMETER-TYPES
           OWNERTYPE))))
       (CL:LOOP
        WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL)))
        DO
        (CL:PROGN
         (CL:SETQ PNAME (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:PROGN
         (CL:SETQ PTYPE (CLSYS-SVAL CONS VALUE ITER-002))
         (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
        (CL:WHEN
         (CL:EQ
          PNAME
          (CLSYS-SVAL
           ANCHORED-TYPE-SPECIFIER
           SPECIFIER-PARAMETER-NAME
           RELTYPE))
         (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC PTYPE))))
      (CL:RETURN-FROM
       COMPUTE-ANCHORED-TYPE-SPEC
       (COMPUTE-ANCHORED-TYPE-SPEC
        (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE OWNERTYPE)
        RELTYPE))))
    (CL:T
     (CL:ERROR "compute-anchored-type-spec: Not defined on `~A'" OWNERTYPE))))
  :VOID)

;;; (DEFUN (COMPUTE-RELATIVE-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFUN COMPUTE-RELATIVE-TYPE-SPEC (RELATIVETYPE OWNERTYPE)
  (CL:LET*
   ((RELATIVETYPE-001 RELATIVETYPE))
   (CL:COND
    ((CL:EQ (PARAMETRIC-TYPE-SPECIFIER? RELATIVETYPE) 1)
     (CL:LET*
      ((RELATIVETYPE NULL))
      (CL:SETQ RELATIVETYPE RELATIVETYPE-001)
      (CL:LET*
       ((ALWAYS?-001 TRUE))
       (CL:LET*
        ((TS NULL)
         (ITER-001
          (CLSYS-SVAL
           LIST
           THE-CONS-LIST
           (CLSYS-SVAL
            PARAMETRIC-TYPE-SPECIFIER
            SPECIFIER-PARAMETER-TYPES
            RELATIVETYPE))))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-001 NIL))
         DO
         (CL:PROGN
          (CL:SETQ TS (CLSYS-SVAL CONS VALUE ITER-001))
          (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
         (CL:WHEN
          (CL:EQ (TYPE? TS) 0)
          (CL:SETQ ALWAYS?-001 FALSE)
          (CL:RETURN))))
       (CL:WHEN
        (CL:EQ ALWAYS?-001 1)
        (CL:RETURN-FROM COMPUTE-RELATIVE-TYPE-SPEC RELATIVETYPE)))
      (CL:LET*
       ((TYPESLIST (NEW-LIST))
        (RELATIVETS NULL)
        (FOUNDRELATIVISTICTYPE? FALSE))
       (CL:LET*
        ((TS NULL)
         (ITER-002
          (CLSYS-SVAL
           LIST
           THE-CONS-LIST
           (CLSYS-SVAL
            PARAMETRIC-TYPE-SPECIFIER
            SPECIFIER-PARAMETER-TYPES
            RELATIVETYPE)))
         (COLLECT-001 NULL))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-002 NIL))
         DO
         (CL:PROGN
          (CL:SETQ TS (CLSYS-SVAL CONS VALUE ITER-002))
          (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
         (CL:SETQ RELATIVETS (COMPUTE-RELATIVE-TYPE-SPEC TS OWNERTYPE))
         (CL:WHEN
          (CL:NOT (CL:EQ RELATIVETS TS))
          (CL:SETQ FOUNDRELATIVISTICTYPE? TRUE))
         (CL:IF
          (CL:EQ COLLECT-001 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-001 (PERMANENT-CONS RELATIVETS NIL))
           (CL:IF
            (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST TYPESLIST) NIL)
            (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST TYPESLIST) COLLECT-001)
            (ADD-CONS-TO-END-OF-CONS-LIST
             (CLSYS-SVAL LIST THE-CONS-LIST TYPESLIST)
             COLLECT-001)))
          (CL:PROGN
           (CL:SETF
            (CLSYS-SVAL CONS REST COLLECT-001)
            (PERMANENT-CONS RELATIVETS NIL))
           (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
       (CL:IF
        (CL:EQ FOUNDRELATIVISTICTYPE? 1)
        (CL:LET*
         ((NEWTS (NEW-TRANSIENT-TYPE-SPECIFIER)))
         (CL:SETF
          (CLSYS-SVAL TRANSIENT-TYPE-SPECIFIER SPECIFIER-BASE-TYPE NEWTS)
          (CLSYS-SVAL
           PARAMETRIC-TYPE-SPECIFIER
           SPECIFIER-BASE-TYPE
           RELATIVETYPE))
         (CL:SETF
          (CLSYS-SVAL
           TRANSIENT-TYPE-SPECIFIER
           SPECIFIER-PARAMETER-TYPES
           NEWTS)
          TYPESLIST)
         (CL:RETURN-FROM COMPUTE-RELATIVE-TYPE-SPEC NEWTS))
        (CL:PROGN
         (FREE TYPESLIST)
         (CL:RETURN-FROM COMPUTE-RELATIVE-TYPE-SPEC RELATIVETYPE))))))
    ((CL:EQ (ANCHORED-TYPE-SPECIFIER? RELATIVETYPE) 1)
     (CL:LET*
      ((RELATIVETYPE NULL))
      (CL:SETQ RELATIVETYPE RELATIVETYPE-001)
      (CL:RETURN-FROM
       COMPUTE-RELATIVE-TYPE-SPEC
       (COMPUTE-ANCHORED-TYPE-SPEC OWNERTYPE RELATIVETYPE))))
    ((CL:EQ (TYPE? RELATIVETYPE) 1)
     (CL:LET*
      ((RELATIVETYPE NULL))
      (CL:SETQ RELATIVETYPE RELATIVETYPE-001)
      (CL:RETURN-FROM COMPUTE-RELATIVE-TYPE-SPEC RELATIVETYPE)))
    (CL:T
     (CL:ERROR
      "compute-relative-type-spec: Not defined on `~A'"
      RELATIVETYPE))))
  :VOID)

;;; (DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFMETHOD COMPUTE-RETURN-TYPE-SPEC ((SELF SLOT) FIRSTARGTYPE)
  (CL:SETQ FIRSTARGTYPE FIRSTARGTYPE)
  (CL:ERROR "compute-return-type-spec: Not defined on `~A'" SELF)
  (CL:RETURN-FROM COMPUTE-RETURN-TYPE-SPEC NULL)
  :VOID)

;;; (DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFMETHOD COMPUTE-RETURN-TYPE-SPEC ((SELF METHOD-SLOT) FIRSTARGTYPE)
  (CL:IF
   (CL:EQ (DYNAMIC-SLOT-VALUE SELF SYM-METHODS-SLOT-TYPE-SPECIFIER NULL) NULL)
   (CL:RETURN-FROM
    COMPUTE-RETURN-TYPE-SPEC
    (CLSYS-SVAL METHOD-SLOT SLOT-BASE-TYPE SELF))
   (CL:RETURN-FROM
    COMPUTE-RETURN-TYPE-SPEC
    (COMPUTE-RELATIVE-TYPE-SPEC
     (DYNAMIC-SLOT-VALUE SELF SYM-METHODS-SLOT-TYPE-SPECIFIER NULL)
     FIRSTARGTYPE)))
  :VOID)

;;; (DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFMETHOD COMPUTE-RETURN-TYPE-SPEC ((SELF STORAGE-SLOT) FIRSTARGTYPE)
  (CL:IF
   (CL:EQ (DYNAMIC-SLOT-VALUE SELF SYM-METHODS-SLOT-TYPE-SPECIFIER NULL) NULL)
   (CL:RETURN-FROM COMPUTE-RETURN-TYPE-SPEC (TYPE SELF))
   (CL:RETURN-FROM
    COMPUTE-RETURN-TYPE-SPEC
    (COMPUTE-RELATIVE-TYPE-SPEC
     (DYNAMIC-SLOT-VALUE SELF SYM-METHODS-SLOT-TYPE-SPECIFIER NULL)
     FIRSTARGTYPE)))
  :VOID)

;;; (DEFUN (YIELD-TYPE-SPEC-TREE OBJECT) ...)

(CL:DEFUN YIELD-TYPE-SPEC-TREE (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TYPE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM YIELD-TYPE-SPEC-TREE (TYPE-TO-SYMBOL SELF))))
    ((CL:EQ (PARAMETRIC-TYPE-SPECIFIER? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((LISTOFTYPES NIL))
       (CL:LET*
        ((TS NULL)
         (ITER-001
          (CLSYS-SVAL
           LIST
           THE-CONS-LIST
           (CLSYS-SVAL
            PARAMETRIC-TYPE-SPECIFIER
            SPECIFIER-PARAMETER-TYPES
            SELF)))
         (COLLECT-001 NULL))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-001 NIL))
         DO
         (CL:PROGN
          (CL:SETQ TS (CLSYS-SVAL CONS VALUE ITER-001))
          (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
         (CL:IF
          (CL:EQ COLLECT-001 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-001 (CONS (YIELD-TYPE-SPEC-TREE TS) NIL))
           (CL:IF
            (CL:EQ LISTOFTYPES NIL)
            (CL:SETQ LISTOFTYPES COLLECT-001)
            (ADD-CONS-TO-END-OF-CONS-LIST LISTOFTYPES COLLECT-001)))
          (CL:PROGN
           (CL:SETF
            (CLSYS-SVAL CONS REST COLLECT-001)
            (CONS (YIELD-TYPE-SPEC-TREE TS) NIL))
           (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
       (CL:RETURN-FROM
        YIELD-TYPE-SPEC-TREE
        (CONS
         (TYPE-TO-SYMBOL
          (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE SELF))
         (CONCATENATE
          (CL:IF
           (CL:EQ
            (DEFINED?
             (CLSYS-SVAL
              PARAMETRIC-TYPE-SPECIFIER
              SPECIFIER-SEQUENCE-SIZE
              SELF))
            1)
           (LIST*
            SYM-METHODS-SIZE
            (WRAP-LITERAL
             (CLSYS-SVAL
              PARAMETRIC-TYPE-SPECIFIER
              SPECIFIER-SEQUENCE-SIZE
              SELF))
            NIL)
           NIL)
          (CONS SYM-METHODS-OF (CONCATENATE LISTOFTYPES NIL))))))))
    ((CL:EQ (ANCHORED-TYPE-SPECIFIER? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:IF
       (CL:NOT
        (CL:EQ
         (CLSYS-SVAL ANCHORED-TYPE-SPECIFIER SPECIFIER-PARAMETER-NAME SELF)
         NULL))
       (CL:RETURN-FROM
        YIELD-TYPE-SPEC-TREE
        (LIST*
         SYM-METHODS-LIKE
         (CONS
          (CLSYS-SVAL ANCHORED-TYPE-SPECIFIER SPECIFIER-PARAMETER-NAME SELF)
          (CONS SYM-METHODS-SELF NIL))
         NIL))
       (CL:RETURN-FROM
        YIELD-TYPE-SPEC-TREE
        (LIST* SYM-METHODS-LIKE SYM-METHODS-SELF NIL)))))
    (CL:T (CL:ERROR "validate-type-specifier: Not defined on `~A'" SELF))))
  :VOID)

;;; (DEFGLOBAL *FUNCTION-LOOKUP-TABLE* ...)

(CL:DEFVAR *FUNCTION-LOOKUP-TABLE* NULL
  "Lookup table for functions.")

;;; (DEFUN (ATTACH-FUNCTION METHOD-SLOT) ...)

(CL:DEFUN ATTACH-FUNCTION (NEWFUNCTION)
  (CL:LET*
   ((NAME (CLSYS-SVAL METHOD-SLOT SLOT-NAME NEWFUNCTION))
    (OLDFUNCTION (LOOKUP *FUNCTION-LOOKUP-TABLE* NAME)))
   (INSERT-AT *FUNCTION-LOOKUP-TABLE* NAME NEWFUNCTION)
   (UNREGISTER-SLOT-NAME NEWFUNCTION)
   (FINALIZE-SLOT-TYPE-COMPUTATIONS NEWFUNCTION)
   (CL:WHEN
    (CL:NOT (CL:EQ OLDFUNCTION NULL))
    (RUN-HOOKS *REDEFINE-RELATION-HOOKS* (LIST OLDFUNCTION NEWFUNCTION))
    (FREE OLDFUNCTION))
   (CL:RETURN-FROM ATTACH-FUNCTION NEWFUNCTION))
  :VOID)

;;; (DEFMETHOD (LOOKUP-FUNCTION FUNCTION) ...)

(CL:DEFMETHOD LOOKUP-FUNCTION ((NAME CL:STRING))
  "Return a function with name 'name'.  Scan all
visible symbols looking for one that has a function defined for it."
  (CL:LET*
   ((FUNCTION NULL) (SYMBOL NULL))
   (CL:LET*
    ((MODULE NULL) (ITER-001 (VISIBLE-MODULES *MODULE*)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ MODULE (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:LET*
      ((TEST-VALUE-001 FALSE))
      (CL:LET*
       ()
       (CL:SETQ SYMBOL (LOOKUP-RIGID-SYMBOL-LOCALLY NAME MODULE SYMBOL-SYM))
       (CL:SETQ TEST-VALUE-001 (DEFINED? SYMBOL)))
      (CL:WHEN
       (CL:EQ TEST-VALUE-001 1)
       (CL:LET*
        ()
        (CL:SETQ FUNCTION (LOOKUP *FUNCTION-LOOKUP-TABLE* SYMBOL))
        (CL:SETQ TEST-VALUE-001 (DEFINED? FUNCTION))))
      (CL:WHEN
       (CL:EQ TEST-VALUE-001 1)
       (CL:RETURN-FROM LOOKUP-FUNCTION FUNCTION)))))
   (CL:RETURN-FROM LOOKUP-FUNCTION NULL))
  :VOID)

;;; (DEFMETHOD (LOOKUP-FUNCTION FUNCTION) ...)

(CL:DEFMETHOD LOOKUP-FUNCTION ((FUNCTIONSYMBOL SYMBOL))
  "Return the function defined for 'functionSymbol', if
one exists."
  (CL:RETURN-FROM
   LOOKUP-FUNCTION
   (LOOKUP *FUNCTION-LOOKUP-TABLE* (SOFT-PERMANENTIFY FUNCTIONSYMBOL)))
  :VOID)

;;; (DEFUN (LOOKUP-FUNCTION-OR-STELLA-FUNCTION FUNCTION) ...)

(CL:DEFUN LOOKUP-FUNCTION-OR-STELLA-FUNCTION (FUNCTIONSYMBOL)
  (CL:SETQ FUNCTIONSYMBOL (SOFT-PERMANENTIFY FUNCTIONSYMBOL))
  (CL:LET*
   ((ENTRY (LOOKUP *FUNCTION-LOOKUP-TABLE* FUNCTIONSYMBOL)))
   (CL:RETURN-FROM LOOKUP-FUNCTION-OR-STELLA-FUNCTION ENTRY))
  :VOID)

;;; (DEFUN DESTROY-FUNCTION ...)

(CL:DEFUN DESTROY-FUNCTION (FUNCTION)
  (CL:LET*
   ((FUNCTIONNAME (CLSYS-SVAL METHOD-SLOT SLOT-NAME FUNCTION))
    (SLOTREF (CLSYS-SVAL METHOD-SLOT SLOT-SLOTREF FUNCTION))
    (REALFUNCTION (LOOKUP-FUNCTION FUNCTIONNAME)))
   (CL:WHEN
    (CL:EQ FUNCTION REALFUNCTION)
    (REMOVE-AT *FUNCTION-LOOKUP-TABLE* FUNCTIONNAME))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ SLOTREF NULL))
     (CL:EQ FUNCTION (CLSYS-SVAL SURROGATE SURROGATE-VALUE SLOTREF)))
    (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SLOTREF) NULL))
   (DELETED?-SETTER FUNCTION TRUE)
   (FREE FUNCTION))
  :VOID)

;;; (DEFGLOBAL *GLOBAL-VARIABLE-LOOKUP-TABLE* ...)

(CL:DEFVAR *GLOBAL-VARIABLE-LOOKUP-TABLE* NULL
  "Lookup table for global variables.")

;;; (DEFUN (INTERN-GLOBAL-VARIABLE GLOBAL-VARIABLE) ...)

(CL:DEFUN INTERN-GLOBAL-VARIABLE (GLOBAL)
  (CL:LET*
   ((NAME (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME GLOBAL))
    (OLDGLOBAL (LOOKUP-GLOBAL-VARIABLE NAME)))
   (CL:WHEN
    (CL:NOT (CL:EQ OLDGLOBAL NULL))
    (CL:COND
     ((CL:EQ
       (STRING-EQL?
        (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-STRINGIFIED-SOURCE GLOBAL)
        (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-STRINGIFIED-SOURCE OLDGLOBAL))
       1)
      (FREE GLOBAL)
      (CL:RETURN-FROM INTERN-GLOBAL-VARIABLE OLDGLOBAL))
     (CL:T
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "Redefining the global variable `" %%STREAM)
       (PRINT-OBJECT
        (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME GLOBAL)
        %%STREAM)
       (CL:WRITE-STRING "'" %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (FREE OLDGLOBAL))))
   (INSERT-AT *GLOBAL-VARIABLE-LOOKUP-TABLE* NAME GLOBAL)
   (CL:RETURN-FROM INTERN-GLOBAL-VARIABLE GLOBAL))
  :VOID)

;;; (DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ...)

(CL:DEFMETHOD LOOKUP-GLOBAL-VARIABLE ((SELF GENERALIZED-SYMBOL))
  "Return a global variable with name 'self'."
  (CL:RETURN-FROM
   LOOKUP-GLOBAL-VARIABLE
   (LOOKUP *GLOBAL-VARIABLE-LOOKUP-TABLE* SELF))
  :VOID)

;;; (DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ...)

(CL:DEFMETHOD LOOKUP-GLOBAL-VARIABLE ((SELF SURROGATE))
  "Return a global variable with name 'self'."
  (CL:LET*
   ((SYMBOL
     (LOOKUP-RIGID-SYMBOL-WRT-MODULE
      (CLSYS-SVAL SURROGATE SYMBOL-NAME SELF)
      (CLSYS-SVAL SURROGATE HOME-CONTEXT SELF)
      SYMBOL-SYM)))
   (CL:IF
    (CL:NOT (CL:EQ SYMBOL NULL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE (LOOKUP-GLOBAL-VARIABLE SYMBOL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE NULL)))
  :VOID)

;;; (DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ...)

(CL:DEFMETHOD LOOKUP-GLOBAL-VARIABLE ((SELF CL:STRING))
  "Return a global variable with name 'self'."
  (CL:LET*
   ((SYMBOL (LOOKUP-SYMBOL SELF)))
   (CL:IF
    (CL:NOT (CL:EQ SYMBOL NULL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE (LOOKUP-GLOBAL-VARIABLE SYMBOL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE NULL)))
  :VOID)

;;; (DEFUN (LOOKUP-GLOBAL-VARIABLE-TYPE TYPE-SPEC) ...)

(CL:DEFUN LOOKUP-GLOBAL-VARIABLE-TYPE (NAME)
  (CL:LET*
   ((GLOBAL (LOOKUP-GLOBAL-VARIABLE NAME)))
   (CL:WHEN
    (CL:NOT (CL:EQ GLOBAL NULL))
    (CL:IF
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE GLOBAL SYM-METHODS-VARIABLE-TYPE-SPECIFIER NULL)
       NULL))
     (CL:RETURN-FROM
      LOOKUP-GLOBAL-VARIABLE-TYPE
      (DYNAMIC-SLOT-VALUE GLOBAL SYM-METHODS-VARIABLE-TYPE-SPECIFIER NULL))
     (CL:RETURN-FROM
      LOOKUP-GLOBAL-VARIABLE-TYPE
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-TYPE GLOBAL))))
   (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE-TYPE NULL))
  :VOID)

;;; (DEFUN (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE GLOBAL-VARIABLE OBJECT) ...)

(CL:DEFUN DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE (TREE STRINGIFIEDSOURCE)
  (CL:LET*
   ((TYPETREE (THIRD TREE))
    (INITIALVALUETREE (FOURTH TREE))
    (OPTIONSTREE (NTH-REST TREE 4))
    (SPECIAL? (EQ? (FIRST TREE) SYM-METHODS-DEFSPECIAL))
    (CONSTANT? (EQ? (FIRST TREE) SYM-METHODS-DEFCONSTANT))
    (NOINITIALVALUE? FALSE)
    (GLOBAL (NEW-GLOBAL-VARIABLE))
    (INTERNEDGLOBAL NULL))
   (CL:WHEN
    (CL:OR
     (CL:<= (LENGTH TREE) 3)
     (CL:AND
      (CL:EQ
       (MEMBER?
        (GET-QUOTED-TREE
         "((:DOCUMENTATION :PUBLIC? :AUXILIARY?) \"/STELLA\")"
         "/STELLA")
        INITIALVALUETREE)
       1)
      (CL:EQ (ODD? (LENGTH OPTIONSTREE)) 1)))
    (CL:SETQ NOINITIALVALUE? TRUE)
    (CL:SETQ
     INITIALVALUETREE
     (CL:IF (CL:EQ SPECIAL? 1) KWD-METHODS-UNBOUND-SPECIAL-VARIABLE NULL))
    (CL:SETQ OPTIONSTREE (NTH-REST TREE 3)))
   (CL:SETF
    (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME GLOBAL)
    (PERMANENTIFY (SECOND TREE)))
   (CL:SETF
    (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-STRINGIFIED-SOURCE GLOBAL)
    STRINGIFIEDSOURCE)
   (CL:SETQ INTERNEDGLOBAL (INTERN-GLOBAL-VARIABLE GLOBAL))
   (CL:WHEN
    (CL:AND (CL:EQ NOINITIALVALUE? 1) (CL:EQ SPECIAL? 0))
    (CL:IF
     (CL:EQ CONSTANT? 1)
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " Missing value in constant declaration." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING
         " Missing initial value in variable declaration."
         %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)))))
    (CL:RETURN-FROM
     DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE
     (CL:VALUES INTERNEDGLOBAL INITIALVALUETREE)))
   (CL:WHEN
    (CL:NOT (CL:EQ GLOBAL INTERNEDGLOBAL))
    (CL:RETURN-FROM
     DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE
     (CL:VALUES INTERNEDGLOBAL INITIALVALUETREE)))
   (CL:SETQ TYPETREE (YIELD-TYPE-SPECIFIER TYPETREE))
   (VALIDATE-TYPE-SPECIFIER TYPETREE NULL TRUE)
   (CL:IF
    (CL:EQ (TYPE? TYPETREE) 1)
    (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-TYPE GLOBAL) TYPETREE)
    (CL:PROGN
     (SET-DYNAMIC-SLOT-VALUE
      GLOBAL
      SYM-METHODS-VARIABLE-TYPE-SPECIFIER
      TYPETREE
      NULL)
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-TYPE GLOBAL)
      (TYPE-SPEC-TO-BASE-TYPE TYPETREE))))
   (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SPECIAL? GLOBAL) SPECIAL?)
   (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-CONSTANT? GLOBAL) CONSTANT?)
   (CL:WHEN
    (CL:NOT (CL:EQ OPTIONSTREE NIL))
    (CL:LET*
     ((OPTIONS (NEW-PROPERTY-LIST)))
     (CL:SETF (CLSYS-SVAL PROPERTY-LIST THE-PLIST OPTIONS) OPTIONSTREE)
     (CL:LET*
      ((VALUE NULL)
       (KEY NULL)
       (ITER-001 (CLSYS-SVAL PROPERTY-LIST THE-PLIST OPTIONS)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:SETQ KEY (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:PROGN
        (CL:SETQ
         VALUE
         (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST ITER-001)))
        (CL:SETQ
         ITER-001
         (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST ITER-001))))
       (CL:LET*
        ((TEST-VALUE-001 KEY))
        (CL:COND
         ((CL:EQ TEST-VALUE-001 KWD-METHODS-DOCUMENTATION)
          (CL:SETF
           (CLSYS-SVAL GLOBAL-VARIABLE DOCUMENTATION GLOBAL)
           (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE)))
         ((CL:EQ TEST-VALUE-001 KWD-METHODS-PUBLIC?)
          (CL:SETF
           (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-PUBLIC? GLOBAL)
           (CLSYS-SVAL
            BOOLEAN-WRAPPER
            WRAPPER-VALUE
            (SYMBOL-TO-WRAPPED-BOOLEAN VALUE))))
         ((CL:EQ TEST-VALUE-001 KWD-METHODS-AUXILIARY?)
          (CL:SETF
           (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-AUXILIARY? GLOBAL)
           (CLSYS-SVAL
            BOOLEAN-WRAPPER
            WRAPPER-VALUE
            (SYMBOL-TO-WRAPPED-BOOLEAN VALUE))))
         (CL:T
          (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))))
     (CL:SETF (CLSYS-SVAL PROPERTY-LIST THE-PLIST OPTIONS) NULL)))
   (CL:RETURN-FROM
    DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE
    (CL:VALUES GLOBAL INITIALVALUETREE)))
  :VOID)

;;; (DEFUN DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE ...)

(CL:DEFUN DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE (STRINGIFIEDSOURCE)
  (CL:LET*
   ((PARSETREE NULL))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* TRUE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:SETQ PARSETREE (UNSTRINGIFY STRINGIFIEDSOURCE)))
   (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE PARSETREE STRINGIFIEDSOURCE)
   (FREE-PARSE-TREE PARSETREE))
  :VOID)

;;; (DEFUN (GET-GLOBAL-VALUE OBJECT) ...)

(CL:DEFUN GET-GLOBAL-VALUE (SELF)
  "Return the (possibly-wrapped) value of the global
variable for the surrogate 'self'."
  (CL:RETURN-FROM
   GET-GLOBAL-VALUE
   (CL:FUNCALL
    (CLSYS-SVAL
     GLOBAL-VARIABLE
     VARIABLE-GET-VALUE-CODE
     (LOOKUP-GLOBAL-VARIABLE SELF))))
  :VOID)

;;; (DEFUN (SET-GLOBAL-VALUE OBJECT) ...)

(CL:DEFUN SET-GLOBAL-VALUE (SELF VALUE)
  "Set the value of the global variable for the surrogate
'self' to 'value'."
  (CL:RETURN-FROM
   SET-GLOBAL-VALUE
   (CL:FUNCALL
    (CLSYS-SVAL
     GLOBAL-VARIABLE
     VARIABLE-SET-VALUE-CODE
     (LOOKUP-GLOBAL-VARIABLE SELF))
    VALUE))
  :VOID)

;;; (DEFUN DESTROY-VARIABLE ...)

(CL:DEFUN DESTROY-VARIABLE (VARIABLE)
  (CL:LET*
   ((VARIABLENAME (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME VARIABLE))
    (REALVARIABLE (LOOKUP-GLOBAL-VARIABLE VARIABLENAME)))
   (CL:WHEN
    (CL:EQ VARIABLE REALVARIABLE)
    (REMOVE-AT *GLOBAL-VARIABLE-LOOKUP-TABLE* VARIABLENAME))
   (DELETED?-SETTER VARIABLE TRUE)
   (FREE VARIABLE))
  :VOID)

;;; (DEFUN (DEFINE-STELLA-TYPE-FROM-PARSE-TREE TYPE) ...)

(CL:DEFUN DEFINE-STELLA-TYPE-FROM-PARSE-TREE (TREE)
  (CL:LET*
   ((TYPENAME (SECOND TREE))
    (TYPEDEFINITION (YIELD-TYPE-SPECIFIER (THIRD TREE)))
    (TYPE NULL))
   (CL:LET*
    ((TYPENAME-001 TYPENAME))
    (CL:COND
     ((CL:EQ (SYMBOL? TYPENAME) 1)
      (CL:LET*
       ((TYPENAME NULL))
       (CL:SETQ TYPENAME TYPENAME-001)
       (CL:SETQ TYPE (TYPIFY TYPENAME))
       (CL:WHEN
        (CL:AND
         (CL:EQ (DEFINED-TYPE? TYPE) 0)
         (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE) NULL)))
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN
          (CL:EQ (SUPPRESS-WARNINGS?) 0)
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING " Cannot define type `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TYPENAME) %%STREAM)
           (CL:WRITE-STRING "', since `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TYPE) %%STREAM)
           (CL:WRITE-STRING "'" %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING "   already points to `" %%STREAM)
           (PRINT-OBJECT (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE) %%STREAM)
           (CL:WRITE-STRING "'." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))))
        (CL:RETURN-FROM DEFINE-STELLA-TYPE-FROM-PARSE-TREE NULL))
       (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE) TYPEDEFINITION)
       (CL:RETURN-FROM DEFINE-STELLA-TYPE-FROM-PARSE-TREE TYPE)))
     (CL:T
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN
        (CL:EQ (SUPPRESS-WARNINGS?) 0)
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING " Illegal type name: `" %%STREAM)
         (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TYPENAME) %%STREAM)
         (CL:WRITE-STRING "'." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))))
      (CL:RETURN-FROM DEFINE-STELLA-TYPE-FROM-PARSE-TREE NULL)))))
  :VOID)

;;; (DEFUN DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE ...)

(CL:DEFUN DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE (STRINGIFIEDSOURCE)
  (CL:LET*
   ((PARSETREE NULL))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* TRUE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:SETQ PARSETREE (UNSTRINGIFY STRINGIFIEDSOURCE)))
   (DEFINE-STELLA-TYPE-FROM-PARSE-TREE PARSETREE)
   (FREE-PARSE-TREE PARSETREE))
  :VOID)

(CL:DEFUN STARTUP-METHODS ()
  (CL:LET*
   ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SGT-METHODS-SURROGATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE" NULL 1))
    (CL:SETQ
     SGT-METHODS-PARAMETRIC-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARAMETRIC-TYPE-SPECIFIER" NULL 1))
    (CL:SETQ
     SGT-METHODS-ANCHORED-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ANCHORED-TYPE-SPECIFIER" NULL 1))
    (CL:SETQ
     SGT-METHODS-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 1))
    (CL:SETQ SGT-METHODS-VOID (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" NULL 1))
    (CL:SETQ SYM-METHODS-LIKE (INTERN-RIGID-SYMBOL-WRT-MODULE "LIKE" NULL 0))
    (CL:SETQ SYM-METHODS-SIZE (INTERN-RIGID-SYMBOL-WRT-MODULE "SIZE" NULL 0))
    (CL:SETQ SYM-METHODS-OF (INTERN-RIGID-SYMBOL-WRT-MODULE "OF" NULL 0))
    (CL:SETQ SYM-METHODS-SELF (INTERN-RIGID-SYMBOL-WRT-MODULE "SELF" NULL 0))
    (CL:SETQ SYM-METHODS-IN (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 0))
    (CL:SETQ SYM-METHODS-OUT (INTERN-RIGID-SYMBOL-WRT-MODULE "OUT" NULL 0))
    (CL:SETQ
     SYM-METHODS-INOUT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INOUT" NULL 0))
    (CL:SETQ
     SYM-METHODS-METHOD-PARAMETER-DIRECTIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-PARAMETER-DIRECTIONS" NULL 0))
    (CL:SETQ
     SYM-METHODS-ARGUMENT-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-LIST" NULL 0))
    (CL:SETQ
     SYM-METHODS-&REST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "&REST" NULL 0))
    (CL:SETQ
     SYM-METHODS-METHOD-VARIABLE-ARGUMENTS?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-VARIABLE-ARGUMENTS?" NULL 0))
    (CL:SETQ
     SYM-METHODS-&BODY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "&BODY" NULL 0))
    (CL:SETQ
     SYM-METHODS-METHOD-BODY-ARGUMENT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-BODY-ARGUMENT?" NULL 0))
    (CL:SETQ
     SGT-METHODS-UNKNOWN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" NULL 1))
    (CL:SETQ KWD-METHODS-TYPE (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 2))
    (CL:SETQ
     KWD-METHODS-RETURN-TYPES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN-TYPES" NULL 2))
    (CL:SETQ
     SYM-METHODS-SLOT-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-TYPE-SPECIFIER" NULL 0))
    (CL:SETQ
     KWD-METHODS-PUBLIC?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC?" NULL 2))
    (CL:SETQ
     KWD-METHODS-NATIVE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE?" NULL 2))
    (CL:SETQ
     SYM-METHODS-METHOD-NATIVE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-NATIVE?" NULL 0))
    (CL:SETQ
     KWD-METHODS-GLOBALLY-INLINE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBALLY-INLINE?" NULL 2))
    (CL:SETQ
     SYM-METHODS-METHOD-GLOBALLY-INLINE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-GLOBALLY-INLINE?" NULL 0))
    (CL:SETQ
     KWD-METHODS-INLINE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE" NULL 2))
    (CL:SETQ
     SYM-METHODS-METHOD-INLINED-FUNCTIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-INLINED-FUNCTIONS" NULL 0))
    (CL:SETQ
     KWD-METHODS-AUXILIARY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AUXILIARY?" NULL 2))
    (CL:SETQ
     SYM-METHODS-SLOT-AUXILIARY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-AUXILIARY?" NULL 0))
    (CL:SETQ
     KWD-METHODS-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
    (CL:SETQ
     SYM-METHODS-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
    (CL:SETQ
     KWD-METHODS-RETURNS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURNS" NULL 2))
    (CL:SETQ
     KWD-METHODS-STORAGE-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 2))
    (CL:SETQ
     SYM-METHODS-STORAGE-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 0))
    (CL:SETQ
     KWD-METHODS-INHERITS-THROUGH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INHERITS-THROUGH" NULL 2))
    (CL:SETQ
     SYM-METHODS-METHOD-INHERITS-THROUGH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-INHERITS-THROUGH" NULL 0))
    (CL:SETQ
     KWD-METHODS-PROPERTIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTIES" NULL 2))
    (CL:SETQ
     SYM-METHODS-PROPERTIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTIES" NULL 0))
    (CL:SETQ
     KWD-METHODS-META-ATTRIBUTES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "META-ATTRIBUTES" NULL 2))
    (CL:SETQ
     SYM-METHODS-META-ATTRIBUTES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "META-ATTRIBUTES" NULL 0))
    (CL:SETQ
     KWD-METHODS-COMMAND?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMAND?" NULL 2))
    (CL:SETQ
     SYM-METHODS-METHOD-COMMAND?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-COMMAND?" NULL 0))
    (CL:SETQ
     KWD-METHODS-LISP-MACRO?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-MACRO?" NULL 2))
    (CL:SETQ
     SYM-METHODS-METHOD-LISP-MACRO?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-LISP-MACRO?" NULL 0))
    (CL:SETQ
     KWD-METHODS-EVALUATE-ARGUMENTS?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATE-ARGUMENTS?" NULL 2))
    (CL:SETQ
     SYM-METHODS-METHOD-EVALUATE-ARGUMENTS?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-EVALUATE-ARGUMENTS?" NULL 0))
    (CL:SETQ
     SYM-METHODS-CONCATENATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCATENATE" NULL 0))
    (CL:SETQ SYM-METHODS-NULL (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
    (CL:SETQ
     SYM-METHODS-DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "DEFINE-METHOD-FROM-STRINGIFIED-SOURCE"
      NULL
      0))
    (CL:SETQ
     SGT-METHODS-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
    (CL:SETQ
     SYM-METHODS-SUPER-CLASSES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPER-CLASSES" NULL 0))
    (CL:SETQ
     SYM-METHODS-EQUIVALENT-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT-SLOT" NULL 0))
    (CL:SETQ
     SYM-METHODS-CLASS-ALL-SUPER-CLASSES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-ALL-SUPER-CLASSES" NULL 0))
    (CL:SETQ
     SYM-METHODS-SLOT-DIRECT-EQUIVALENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DIRECT-EQUIVALENT" NULL 0))
    (CL:SETQ SYM-METHODS-LET (INTERN-RIGID-SYMBOL-WRT-MODULE "LET" NULL 0))
    (CL:SETQ
     SYM-METHODS-CURSOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CURSOR" NULL 0))
    (CL:SETQ
     SYM-METHODS-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
    (CL:SETQ
     SYM-METHODS-SLOT-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-VALUE" NULL 0))
    (CL:SETQ SYM-METHODS-LOOP (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOP" NULL 0))
    (CL:SETQ SYM-METHODS-WHEN (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN" NULL 0))
    (CL:SETQ
     SYM-METHODS-RETURN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN" NULL 0))
    (CL:SETQ SYM-METHODS-SETQ (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
    (CL:SETQ SYM-METHODS-IF (INTERN-RIGID-SYMBOL-WRT-MODULE "IF" NULL 0))
    (CL:SETQ
     SYM-METHODS-DEFINED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?" NULL 0))
    (CL:SETQ
     SGT-METHODS-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION" NULL 1))
    (CL:SETQ SGT-METHODS-CONS (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
    (CL:SETQ
     SYM-METHODS-FIRST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FIRST" NULL 0))
    (CL:SETQ
     SYM-METHODS-VARIABLE-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE-SPECIFIER" NULL 0))
    (CL:SETQ
     SYM-METHODS-DEFSPECIAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFSPECIAL" NULL 0))
    (CL:SETQ
     SYM-METHODS-DEFCONSTANT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFCONSTANT" NULL 0))
    (CL:SETQ
     KWD-METHODS-UNBOUND-SPECIAL-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBOUND-SPECIAL-VARIABLE" NULL 2)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:SETQ *FUNCTION-LOOKUP-TABLE* (NEW-HASH-TABLE))
    (CL:SETQ *GLOBAL-VARIABLE-LOOKUP-TABLE* (NEW-HASH-TABLE)))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "APPLY"
        "FUNCTION-CODE"
        "(DEFUN (APPLY OBJECT) ((CODE FUNCTION-CODE) (ARGUMENTS (CONS OF OBJECT))) :DOCUMENTATION \"Apply `code' to `arguments', returning a value of type
OBJECT.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION APPLY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MAKE-PARAMETRIC-TYPE-SPECIFIER"
        NULL
        "(DEFUN (MAKE-PARAMETRIC-TYPE-SPECIFIER PARAMETRIC-TYPE-SPECIFIER) () :DOCUMENTATION \"Return a transient or permanent instance of
'PARAMETRIC-TYPE-SPECIFIER'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MAKE-PARAMETRIC-TYPE-SPECIFIER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TERMINATE-TRANSIENT-TYPE-SPECIFIER?"
        "TRANSIENT-TYPE-SPECIFIER"
        "(DEFUN (TERMINATE-TRANSIENT-TYPE-SPECIFIER? BOOLEAN) ((SELF TRANSIENT-TYPE-SPECIFIER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TERMINATE-TRANSIENT-TYPE-SPECIFIER?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFINED-TYPE?"
        "TYPE"
        "(DEFUN (DEFINED-TYPE? BOOLEAN) ((TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFINED-TYPE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REAL-TYPE-SPECIFIER"
        "TYPE"
        "(DEFUN (REAL-TYPE-SPECIFIER TYPE-SPEC) ((TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REAL-TYPE-SPECIFIER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CANONICAL-TYPE"
        "TYPE"
        "(DEFUN (CANONICAL-TYPE TYPE) ((TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CANONICAL-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-TYPE-SPECIFIER"
        "SURROGATE"
        "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION YIELD-TYPE-SPECIFIER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-TYPE-SPECIFIER"
        "SYMBOL"
        "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION YIELD-TYPE-SPECIFIER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-TYPE-SPECIFIER"
        "PARAMETRIC-TYPE-SPECIFIER"
        "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE PARAMETRIC-TYPE-SPECIFIER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION YIELD-TYPE-SPECIFIER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-TYPE-SPECIFIER"
        "ANCHORED-TYPE-SPECIFIER"
        "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE ANCHORED-TYPE-SPECIFIER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION YIELD-TYPE-SPECIFIER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-TYPE-SPECIFIER"
        "OBJECT"
        "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION YIELD-TYPE-SPECIFIER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-TYPE-SPECIFIER"
        "CONS"
        "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION YIELD-TYPE-SPECIFIER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-PARAMETRIC-TYPE-SPECIFIER"
        "CONS"
        "(DEFUN (YIELD-PARAMETRIC-TYPE-SPECIFIER PARAMETRIC-TYPE-SPECIFIER) ((TYPESPECTREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-PARAMETRIC-TYPE-SPECIFIER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-ANCHORED-TYPE-SPECIFIER"
        "CONS"
        "(DEFUN (YIELD-ANCHORED-TYPE-SPECIFIER ANCHORED-TYPE-SPECIFIER) ((TYPESPECTREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-ANCHORED-TYPE-SPECIFIER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INCORPORATE-INPUT-PARAMETERS"
        "METHOD-SLOT"
        "(DEFUN INCORPORATE-INPUT-PARAMETERS ((METHOD METHOD-SLOT) (PARAMETERS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INCORPORATE-INPUT-PARAMETERS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INCORPORATE-FIRST-INPUT-PARAMETER"
        "METHOD-SLOT"
        "(DEFUN INCORPORATE-FIRST-INPUT-PARAMETER ((METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INCORPORATE-FIRST-INPUT-PARAMETER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFINE-STELLA-METHOD-SLOT"
        "SYMBOL"
        "(DEFUN (DEFINE-STELLA-METHOD-SLOT METHOD-SLOT) ((INPUTNAME SYMBOL) (RETURNTYPES CONS) (FUNCTION? BOOLEAN) (INPUTPARAMETERS CONS) (OPTIONS KEYWORD-KEY-VALUE-LIST) (METHODBODY CONS)) :DOCUMENTATION \"Define a new Stella method object (a slot), and attach it
to the class identified by the first parameter in 'inputParameters'.
Storage note: Copies 'options', but attaches to 'inputParameters' and
'methodBody'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFINE-STELLA-METHOD-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ATTACH-METHOD-SLOT-TO-OWNER"
        "METHOD-SLOT"
        "(DEFUN (ATTACH-METHOD-SLOT-TO-OWNER METHOD-SLOT) ((NEWMETHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ATTACH-METHOD-SLOT-TO-OWNER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-STRING-CONSTANT-TREE"
        "STRING"
        "(DEFUN (YIELD-STRING-CONSTANT-TREE OBJECT) ((STRING STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-STRING-CONSTANT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-DEFINE-STELLA-METHOD"
        "METHOD-SLOT"
        "(DEFUN (YIELD-DEFINE-STELLA-METHOD CONS) ((METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-DEFINE-STELLA-METHOD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-CLASS-PARAMETER-TYPES"
        "CLASS"
        "(DEFUN (YIELD-CLASS-PARAMETER-TYPES (CONS OF TYPE)) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-CLASS-PARAMETER-TYPES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "OPTIMISTIC-SUBTYPE-OF?"
        "TYPE"
        "(DEFUN (OPTIMISTIC-SUBTYPE-OF? BOOLEAN) ((SUBTYPE TYPE) (SUPERTYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION OPTIMISTIC-SUBTYPE-OF?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WARN-OF-PARAMETER-MISMATCH"
        "PARAMETRIC-TYPE-SPECIFIER"
        "(DEFUN WARN-OF-PARAMETER-MISMATCH ((SELF PARAMETRIC-TYPE-SPECIFIER) (MESSAGE STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WARN-OF-PARAMETER-MISMATCH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VALIDATE-TYPE-SPECIFIER"
        "TYPE-SPEC"
        "(DEFUN (VALIDATE-TYPE-SPECIFIER TYPE) ((SELF TYPE-SPEC) (ANCHORCLASS CLASS) (SKIPANCHOREDTYPE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VALIDATE-TYPE-SPECIFIER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SYNTHESIZE-METHOD-BODY"
        "METHOD-SLOT"
        "(DEFUN (SYNTHESIZE-METHOD-BODY CONS) ((METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SYNTHESIZE-METHOD-BODY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-SLOT-TYPE-COMPUTATIONS"
        "METHOD-SLOT"
        "(DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ((SELF METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FINALIZE-SLOT-TYPE-COMPUTATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-FINALIZE-LOCAL-SLOT"
        "METHOD-SLOT"
        "(DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ((SELF METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION HELP-FINALIZE-LOCAL-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNFINALIZE-LOCAL-SLOT"
        "METHOD-SLOT"
        "(DEFMETHOD UNFINALIZE-LOCAL-SLOT ((SELF METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION UNFINALIZE-LOCAL-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "METHOD-ARGUMENT-COUNT"
        "SLOT"
        "(DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION METHOD-ARGUMENT-COUNT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "METHOD-ARGUMENT-COUNT"
        "STORAGE-SLOT"
        "(DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ((SELF STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION METHOD-ARGUMENT-COUNT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "METHOD-ARGUMENT-COUNT"
        "METHOD-SLOT"
        "(DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ((SELF METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION METHOD-ARGUMENT-COUNT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "METHOD-ARGUMENT-COUNT"
        "TABLE"
        "(DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ((SELF TABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION METHOD-ARGUMENT-COUNT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "METHOD-VARIABLE-ARGUMENTS?"
        "STORAGE-SLOT"
        "(DEFMETHOD (METHOD-VARIABLE-ARGUMENTS? BOOLEAN) ((SELF STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION METHOD-VARIABLE-ARGUMENTS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "METHOD-BODY-ARGUMENT?"
        "STORAGE-SLOT"
        "(DEFMETHOD (METHOD-BODY-ARGUMENT? BOOLEAN) ((SELF STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION METHOD-BODY-ARGUMENT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ARITY"
        "STORAGE-SLOT"
        "(DEFMETHOD (ARITY INTEGER) ((SELF STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ARITY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ARITY"
        "METHOD-SLOT"
        "(DEFMETHOD (ARITY INTEGER) ((SELF METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ARITY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ARITY"
        "TABLE"
        "(DEFMETHOD (ARITY INTEGER) ((SELF TABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ARITY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TYPE-SPEC-TO-BASE-TYPE"
        "TYPE-SPEC"
        "(DEFUN (TYPE-SPEC-TO-BASE-TYPE TYPE) ((SELF TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TYPE-SPEC-TO-BASE-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TYPE-SPEC-TO-CLASS"
        "TYPE-SPEC"
        "(DEFUN (TYPE-SPEC-TO-CLASS CLASS) ((SELF TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TYPE-SPEC-TO-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPATIBLE-PARAMETER-TYPES?"
        "TYPE-SPEC"
        "(DEFUN (COMPATIBLE-PARAMETER-TYPES? BOOLEAN) ((SUBTYPE TYPE-SPEC) (SUPERTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPATIBLE-PARAMETER-TYPES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUB-TYPE-SPEC-OF?"
        "TYPE-SPEC"
        "(DEFUN (SUB-TYPE-SPEC-OF? BOOLEAN) ((SUBTYPE TYPE-SPEC) (SUPERTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SUB-TYPE-SPEC-OF?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VOID?"
        "TYPE-SPEC"
        "(DEFUN (VOID? BOOLEAN) ((TYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VOID?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXTRACT-PARAMETER-TYPE"
        "TYPE-SPEC"
        "(DEFUN (EXTRACT-PARAMETER-TYPE TYPE-SPEC BOOLEAN) ((SELF TYPE-SPEC) (PARAMETER SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXTRACT-PARAMETER-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-ANCHORED-TYPE-SPEC"
        "TYPE-SPEC"
        "(DEFUN (COMPUTE-ANCHORED-TYPE-SPEC TYPE-SPEC) ((OWNERTYPE TYPE-SPEC) (RELTYPE ANCHORED-TYPE-SPECIFIER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-ANCHORED-TYPE-SPEC)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-RELATIVE-TYPE-SPEC"
        "TYPE-SPEC"
        "(DEFUN (COMPUTE-RELATIVE-TYPE-SPEC TYPE-SPEC) ((RELATIVETYPE TYPE-SPEC) (OWNERTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-RELATIVE-TYPE-SPEC)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-RETURN-TYPE-SPEC"
        "SLOT"
        "(DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ((SELF SLOT) (FIRSTARGTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION COMPUTE-RETURN-TYPE-SPEC)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-RETURN-TYPE-SPEC"
        "METHOD-SLOT"
        "(DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ((SELF METHOD-SLOT) (FIRSTARGTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION COMPUTE-RETURN-TYPE-SPEC)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-RETURN-TYPE-SPEC"
        "STORAGE-SLOT"
        "(DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ((SELF STORAGE-SLOT) (FIRSTARGTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION COMPUTE-RETURN-TYPE-SPEC)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-TYPE-SPEC-TREE"
        "TYPE-SPEC"
        "(DEFUN (YIELD-TYPE-SPEC-TREE OBJECT) ((SELF TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-TYPE-SPEC-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ATTACH-FUNCTION"
        "METHOD-SLOT"
        "(DEFUN (ATTACH-FUNCTION METHOD-SLOT) ((NEWFUNCTION METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ATTACH-FUNCTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-FUNCTION"
        "STRING"
        "(DEFMETHOD (LOOKUP-FUNCTION FUNCTION) ((NAME STRING)) :DOCUMENTATION \"Return a function with name 'name'.  Scan all
visible symbols looking for one that has a function defined for it.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOOKUP-FUNCTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-FUNCTION"
        "SYMBOL"
        "(DEFMETHOD (LOOKUP-FUNCTION FUNCTION) ((FUNCTIONSYMBOL SYMBOL)) :DOCUMENTATION \"Return the function defined for 'functionSymbol', if
one exists.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOOKUP-FUNCTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-FUNCTION-OR-STELLA-FUNCTION"
        "SYMBOL"
        "(DEFUN (LOOKUP-FUNCTION-OR-STELLA-FUNCTION FUNCTION) ((FUNCTIONSYMBOL SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-FUNCTION-OR-STELLA-FUNCTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-FUNCTION"
        "METHOD-SLOT"
        "(DEFUN DESTROY-FUNCTION ((FUNCTION METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESTROY-FUNCTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INTERN-GLOBAL-VARIABLE"
        "GLOBAL-VARIABLE"
        "(DEFUN (INTERN-GLOBAL-VARIABLE GLOBAL-VARIABLE) ((GLOBAL GLOBAL-VARIABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INTERN-GLOBAL-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-GLOBAL-VARIABLE"
        "GENERALIZED-SYMBOL"
        "(DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ((SELF GENERALIZED-SYMBOL)) :DOCUMENTATION \"Return a global variable with name 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-GLOBAL-VARIABLE"
        "SURROGATE"
        "(DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ((SELF SURROGATE)) :DOCUMENTATION \"Return a global variable with name 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-GLOBAL-VARIABLE"
        "STRING"
        "(DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ((SELF STRING)) :DOCUMENTATION \"Return a global variable with name 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-GLOBAL-VARIABLE-TYPE"
        "SYMBOL"
        "(DEFUN (LOOKUP-GLOBAL-VARIABLE-TYPE TYPE-SPEC) ((NAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE"
        "CONS"
        "(DEFUN (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE GLOBAL-VARIABLE OBJECT) ((TREE CONS) (STRINGIFIEDSOURCE STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE"
        "STRING"
        "(DEFUN DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE ((STRINGIFIEDSOURCE STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-GLOBAL-VALUE"
        "SURROGATE"
        "(DEFUN (GET-GLOBAL-VALUE OBJECT) ((SELF SURROGATE)) :DOCUMENTATION \"Return the (possibly-wrapped) value of the global
variable for the surrogate 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-GLOBAL-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SET-GLOBAL-VALUE"
        "SURROGATE"
        "(DEFUN (SET-GLOBAL-VALUE OBJECT) ((SELF SURROGATE) (VALUE OBJECT)) :DOCUMENTATION \"Set the value of the global variable for the surrogate
'self' to 'value'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SET-GLOBAL-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-VARIABLE"
        "GLOBAL-VARIABLE"
        "(DEFUN DESTROY-VARIABLE ((VARIABLE GLOBAL-VARIABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESTROY-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFINE-STELLA-TYPE-FROM-PARSE-TREE"
        "CONS"
        "(DEFUN (DEFINE-STELLA-TYPE-FROM-PARSE-TREE TYPE) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFINE-STELLA-TYPE-FROM-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE"
        "STRING"
        "(DEFUN DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE ((STRINGIFIEDSOURCE STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-METHODS"
     NULL
     "(DEFUN STARTUP-METHODS ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAXIMUM-STRING-CONSTANT-SIZE* INTEGER 4000 :DOCUMENTATION \"Maximum size for a string constant in the target language.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *FUNCTION-LOOKUP-TABLE* (HASH-TABLE OF SYMBOL FUNCTION) (NEW (HASH-TABLE OF SYMBOL FUNCTION)) :DOCUMENTATION \"Lookup table for functions.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *GLOBAL-VARIABLE-LOOKUP-TABLE* (HASH-TABLE OF SYMBOL GLOBAL-VARIABLE) (NEW (HASH-TABLE OF SYMBOL GLOBAL-VARIABLE)) :DOCUMENTATION \"Lookup table for global variables.\")")))
  :VOID)
