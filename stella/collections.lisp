;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-COLLECTIONS-COLLECTION NULL)
(CL:DEFVAR SGT-COLLECTIONS-ABSTRACT-ITERATOR NULL)
(CL:DEFVAR SYM-COLLECTIONS-VALUE NULL)
(CL:DEFVAR SYM-COLLECTIONS-VALUE-SETTER NULL)
(CL:DEFVAR SYM-COLLECTIONS-SLOT-WRITER NULL)

;;; Forward declarations:

(CL:DECLAIM (CL:SPECIAL *STELLA-MODULE* *MODULE*))

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF COLLECTION) OBJECT)
  "Return TRUE iff 'object' is a member of the collection 'self'."
  (CL:LET*
   ((I NULL) (ITER-001 (ALLOCATE-ITERATOR SELF)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITER-001) 1)
    DO
    (CL:PROGN (CL:SETQ I (CLSYS-SVAL ITERATOR VALUE ITER-001)))
    (CL:WHEN (CL:EQ (EQL? I OBJECT) 1) (CL:RETURN-FROM MEMBER? TRUE))))
  (CL:RETURN-FROM MEMBER? FALSE)
  :VOID)

;;; (DEFUN (COLLECTION? BOOLEAN) ...)

(CL:DEFUN COLLECTION? (SELF)
  "Return TRUE if 'self' is a native collection."
  (CL:RETURN-FROM COLLECTION? (ISA? SELF SGT-COLLECTIONS-COLLECTION))
  :VOID)

;;; (DEFMETHOD (NO-DUPLICATES? BOOLEAN) ...)

(CL:DEFMETHOD NO-DUPLICATES? ((SELF COLLECTION))
  "Return TRUE if the collection 'self' forbids duplicate values."
  (CL:RETURN-FROM NO-DUPLICATES? FALSE)
  :VOID)

;;; (DEFMETHOD (NO-DUPLICATES? BOOLEAN) ...)

(CL:DEFMETHOD NO-DUPLICATES? ((SELF SET))
  (CL:RETURN-FROM NO-DUPLICATES? TRUE)
  :VOID)

;;; (DEFMETHOD (ORDERED? BOOLEAN) ...)

(CL:DEFMETHOD ORDERED? ((SELF COLLECTION))
  "Return TRUE if the collection 'self' is ordered."
  (CL:RETURN-FROM ORDERED? FALSE)
  :VOID)

;;; (DEFMETHOD (ORDERED? BOOLEAN) ...)

(CL:DEFMETHOD ORDERED? ((SELF SEQUENCE))
  (CL:RETURN-FROM ORDERED? TRUE)
  :VOID)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF SET))
  "Return TRUE if the set 'self' has no members."
  (CL:RETURN-FROM EMPTY? (EQ? (CLSYS-SVAL SET THE-CONS-LIST SELF) NIL))
  :VOID)

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF SET))
  "Return TRUE if the set 'self' has at least one member."
  (CL:RETURN-FROM
   NON-EMPTY?
   (CL:IF (CL:NOT (CL:EQ (CLSYS-SVAL SET THE-CONS-LIST SELF) NIL)) TRUE FALSE))
  :VOID)

;;; (DEFUN (TERMINATE-SET? BOOLEAN) ...)

(CL:DEFUN TERMINATE-SET? (SELF)
  (CL:LET*
   ((CONS (CLSYS-SVAL SET THE-CONS-LIST SELF)) (REST NULL))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CONS NIL))
    DO
    (CL:SETQ REST (CLSYS-SVAL CONS REST CONS))
    (FREE CONS)
    (CL:SETQ CONS REST))
   (CL:SETF (CLSYS-SVAL SET THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM TERMINATE-SET? TRUE))
  :VOID)

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF SET) OBJECT)
  "Return TRUE iff 'object' is a member of the set 'self'.
Uses an 'eql?' test."
  (CL:LET*
   ((I NULL) (ITER-001 (CLSYS-SVAL SET THE-CONS-LIST SELF)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ I (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN (CL:EQ (EQL? I OBJECT) 1) (CL:RETURN-FROM MEMBER? TRUE))))
  (CL:RETURN-FROM MEMBER? FALSE)
  :VOID)

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF SET) VALUE)
  "Add 'value' to the set 'self'.  First checks for duplicate."
  (CL:WHEN
   (CL:EQ (MEMBER? SELF VALUE) 0)
   (CL:SETF
    (CLSYS-SVAL SET THE-CONS-LIST SELF)
    (PERMANENT-CONS VALUE (CLSYS-SVAL SET THE-CONS-LIST SELF))))
  :VOID)

;;; (DEFMETHOD (REMOVE SET) ...)

(CL:DEFMETHOD REMOVE ((SELF SET) VALUE)
  "Remove all entries in 'self' that match 'value'."
  (CL:SETF
   (CLSYS-SVAL SET THE-CONS-LIST SELF)
   (REMOVE (CLSYS-SVAL SET THE-CONS-LIST SELF) VALUE))
  (CL:RETURN-FROM REMOVE SELF)
  :VOID)

;;; (DEFMETHOD (REVERSE SET) ...)

(CL:DEFMETHOD REVERSE ((SELF SET))
  (CL:SETF
   (CLSYS-SVAL SET THE-CONS-LIST SELF)
   (REVERSE (CLSYS-SVAL SET THE-CONS-LIST SELF)))
  (CL:RETURN-FROM REVERSE SELF)
  :VOID)

;;; (DEFMETHOD (COPY (SET OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD COPY ((SELF SET))
  "Return a copy of the set 'self'.  The conses in the copy are
freshly allocated."
  (CL:LET*
   ((COPY (CREATE-OBJECT (PRIMARY-TYPE SELF))))
   (CL:SETF
    (CLSYS-SVAL SET THE-CONS-LIST COPY)
    (PERMANENT-COPY-CONS-LIST (CLSYS-SVAL SET THE-CONS-LIST SELF)))
   (CL:RETURN-FROM COPY COPY))
  :VOID)

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF SET))
  "Make 'self' an empty set."
  (FREE-CONS-LIST (CLSYS-SVAL SET THE-CONS-LIST SELF))
  (CL:SETF (CLSYS-SVAL SET THE-CONS-LIST SELF) NIL)
  :VOID)

;;; (DEFMETHOD (ALLOCATE-ITERATOR (SET-ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF SET))
  (CL:LET*
   ((ITERATOR (NEW-SET-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-CURSOR ITERATOR)
    (CLSYS-SVAL SET THE-CONS-LIST SELF))
   (CL:SETF (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-COLLECTION ITERATOR) SELF)
   (CL:SETF (CLSYS-SVAL SET-ITERATOR FIRST-ITERATION? ITERATOR) TRUE)
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR))
  :VOID)

;;; (DEFUN (TERMINATE-SET-ITERATOR? BOOLEAN) ...)

(CL:DEFUN TERMINATE-SET-ITERATOR? (SELF)
  (CL:SETF (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-CURSOR SELF) NIL)
  (CL:SETF (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-COLLECTION SELF) NULL)
  (CL:RETURN-FROM TERMINATE-SET-ITERATOR? TRUE)
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF SET-ITERATOR))
  (CL:IF
   (CL:EQ (CLSYS-SVAL SET-ITERATOR FIRST-ITERATION? SELF) 1)
   (CL:PROGN
    (CL:SETF (CLSYS-SVAL SET-ITERATOR FIRST-ITERATION? SELF) FALSE)
    (CL:SETF
     (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-CURSOR SELF)
     (CLSYS-SVAL
      SET
      THE-CONS-LIST
      (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-COLLECTION SELF))))
   (CL:SETF
    (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-CURSOR SELF)
    (CLSYS-SVAL CONS REST (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-CURSOR SELF))))
  (CL:SETF
   (CLSYS-SVAL SET-ITERATOR VALUE SELF)
   (CLSYS-SVAL CONS VALUE (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-CURSOR SELF)))
  (CL:RETURN-FROM
   NEXT?
   (CL:IF
    (CL:NOT (CL:EQ (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-CURSOR SELF) NIL))
    TRUE
    FALSE))
  :VOID)

;;; (DEFMETHOD (VALUE-SETTER OBJECT) ...)

(CL:DEFMETHOD VALUE-SETTER ((SELF SET-ITERATOR) VALUE)
  (CL:SETF
   (CLSYS-SVAL CONS VALUE (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-CURSOR SELF))
   VALUE)
  (CL:RETURN-FROM VALUE-SETTER VALUE)
  :VOID)

(CL:DEFUN STARTUP-COLLECTIONS ()
  (CL:LET*
   ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SGT-COLLECTIONS-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION" NULL 1))
    (CL:SETQ
     SGT-COLLECTIONS-ABSTRACT-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT-ITERATOR" NULL 1))
    (CL:SETQ
     SYM-COLLECTIONS-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
    (CL:SETQ
     SYM-COLLECTIONS-VALUE-SETTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE-SETTER" NULL 0))
    (CL:SETQ
     SYM-COLLECTIONS-SLOT-WRITER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-WRITER" NULL 0)))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MEMBER?"
        "COLLECTION"
        "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF COLLECTION) (OBJECT (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE iff 'object' is a member of the collection 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MEMBER?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECTION?"
        "OBJECT"
        "(DEFUN (COLLECTION? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'self' is a native collection.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECTION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NO-DUPLICATES?"
        "COLLECTION"
        "(DEFMETHOD (NO-DUPLICATES? BOOLEAN) ((SELF COLLECTION)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the collection 'self' forbids duplicate values.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NO-DUPLICATES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NO-DUPLICATES?"
        "SET"
        "(DEFMETHOD (NO-DUPLICATES? BOOLEAN) ((SELF SET)) :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NO-DUPLICATES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ORDERED?"
        "COLLECTION"
        "(DEFMETHOD (ORDERED? BOOLEAN) ((SELF COLLECTION)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the collection 'self' is ordered.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ORDERED?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ORDERED?"
        "SEQUENCE"
        "(DEFMETHOD (ORDERED? BOOLEAN) ((SELF SEQUENCE)) :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ORDERED?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EMPTY?"
        "SET"
        "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF SET)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the set 'self' has no members.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NON-EMPTY?"
        "SET"
        "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF SET)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the set 'self' has at least one member.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NON-EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TERMINATE-SET?"
        "SET"
        "(DEFUN (TERMINATE-SET? BOOLEAN) ((SELF SET)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TERMINATE-SET?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MEMBER?"
        "SET"
        "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF SET) (OBJECT (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Return TRUE iff 'object' is a member of the set 'self'.
Uses an 'eql?' test.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MEMBER?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT"
        "SET"
        "(DEFMETHOD INSERT ((SELF SET) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Add 'value' to the set 'self'.  First checks for duplicate.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE"
        "SET"
        "(DEFMETHOD (REMOVE SET) ((SELF SET) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Remove all entries in 'self' that match 'value'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REMOVE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REVERSE"
        "SET"
        "(DEFMETHOD (REVERSE SET) ((SELF SET)) :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REVERSE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY"
        "SET"
        "(DEFMETHOD (COPY (SET OF (LIKE (ANY-VALUE SELF)))) ((SELF SET)) :PUBLIC? TRUE :DOCUMENTATION \"Return a copy of the set 'self'.  The conses in the copy are
freshly allocated.\")")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION COPY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR"
        "SET"
        "(DEFMETHOD CLEAR ((SELF SET)) :PUBLIC? TRUE :DOCUMENTATION \"Make 'self' an empty set.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CLEAR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-ITERATOR"
        "SET"
        "(DEFMETHOD (ALLOCATE-ITERATOR (SET-ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF SET)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ALLOCATE-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TERMINATE-SET-ITERATOR?"
        "SET-ITERATOR"
        "(DEFUN (TERMINATE-SET-ITERATOR? BOOLEAN) ((SELF SET-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TERMINATE-SET-ITERATOR?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "SET-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF SET-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VALUE-SETTER"
        "SET-ITERATOR"
        "(DEFMETHOD (VALUE-SETTER OBJECT) ((SELF SET-ITERATOR) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION VALUE-SETTER)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-COLLECTIONS"
     NULL
     "(DEFUN STARTUP-COLLECTIONS ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (SET-DYNAMIC-SLOT-VALUE
     (LOOKUP-SLOT
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-COLLECTIONS-ABSTRACT-ITERATOR)
      SYM-COLLECTIONS-VALUE)
     SYM-COLLECTIONS-SLOT-WRITER
     SYM-COLLECTIONS-VALUE-SETTER
     NULL)))
  :VOID)
