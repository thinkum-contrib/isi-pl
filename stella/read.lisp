;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-READ-SYMBOL NULL)
(CL:DEFVAR KWD-READ-COMMON-LISP-SYMBOL NULL)
(CL:DEFVAR KWD-READ-INTEGER NULL)
(CL:DEFVAR KWD-READ-FLOAT NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *STELLA-MODULE*
  *MODULE*
  STANDARD-OUTPUT
  STANDARD-INPUT
  EOL
  *STELLA-ATOM-DELIMITERS*))

;;; (DEFSPECIAL *INPUTECHOSTREAM* ...)

(CL:DEFVAR *INPUTECHOSTREAM* NULL
  "If non-NULL, characters read with 'read-next-character' will
be echoed to the stream bound to '*inputEchoStream*'.")

;;; (DEFGLOBAL *UNREAD-LAST-CHARACTER?* ...)

(CL:DEFVAR *UNREAD-LAST-CHARACTER?* FALSE)

;;; (DEFUN (READ-NEXT-CHARACTER CHARACTER BOOLEAN) ...)

(CL:DEFUN READ-NEXT-CHARACTER (STREAM)
  (CL:LET*
   ((CHAR NULL-CHARACTER) (EOF? FALSE))
   (CL:MULTIPLE-VALUE-SETQ (CHAR EOF?) (READ-CHARACTER STREAM))
   (CL:WHEN
    (CL:NOT
     (CL:OR
      (CL:EQ *INPUTECHOSTREAM* NULL)
      (CL:EQ *UNREAD-LAST-CHARACTER?* 1)))
    (CL:PRINC CHAR *INPUTECHOSTREAM*))
   (CL:SETQ *UNREAD-LAST-CHARACTER?* FALSE)
   (CL:RETURN-FROM READ-NEXT-CHARACTER (CL:VALUES CHAR EOF?)))
  :VOID)

;;; (DEFUN UNREAD-LAST-CHARACTER ...)

(CL:DEFUN UNREAD-LAST-CHARACTER (CHAR STREAM)
  (CL:WHEN
   (CL:NOT (CL:EQ *INPUTECHOSTREAM* NULL))
   (CL:SETQ *UNREAD-LAST-CHARACTER?* TRUE))
  (UNREAD-CHARACTER CHAR STREAM)
  :VOID)

;;; (DEFUN (READ-NEXT-SIGNIFICANT-CHARACTER CHARACTER BOOLEAN) ...)

(CL:DEFUN READ-NEXT-SIGNIFICANT-CHARACTER (STREAM)
  (CL:LET*
   ((CHAR NULL-CHARACTER) (EOF? FALSE))
   (CL:LOOP
    (CL:MULTIPLE-VALUE-SETQ (CHAR EOF?) (READ-NEXT-CHARACTER STREAM))
    (CL:IF
     (CL:EQ EOF? 1)
     (CL:RETURN-FROM
      READ-NEXT-SIGNIFICANT-CHARACTER
      (CL:VALUES NULL-CHARACTER TRUE))
     (CL:CASE
      CHAR
      ((#\  #\Tab #\Newline))
      (#\;
       (CL:LOOP
        (CL:MULTIPLE-VALUE-SETQ (CHAR EOF?) (READ-NEXT-CHARACTER STREAM))
        (CL:IF
         (CL:EQ EOF? 1)
         (CL:RETURN-FROM
          READ-NEXT-SIGNIFICANT-CHARACTER
          (CL:VALUES NULL-CHARACTER TRUE))
         (CL:WHEN (CL:EQL CHAR #\Newline) (CL:RETURN)))))
      (CL:OTHERWISE
       (CL:RETURN-FROM
        READ-NEXT-SIGNIFICANT-CHARACTER
        (CL:VALUES CHAR FALSE)))))))
  :VOID)

;;; (DEFUN (EAT-NEXT-CHARACTER-IF-WHITESPACE BOOLEAN) ...)

(CL:DEFUN EAT-NEXT-CHARACTER-IF-WHITESPACE (STREAM)
  (CL:LET*
   ((CHAR NULL-CHARACTER) (EOF? FALSE))
   (CL:MULTIPLE-VALUE-SETQ (CHAR EOF?) (READ-NEXT-CHARACTER STREAM))
   (CL:SETQ CHAR CHAR)
   (CL:IF
    (CL:EQ EOF? 1)
    (CL:RETURN-FROM EAT-NEXT-CHARACTER-IF-WHITESPACE TRUE)
    (CL:CASE
     CHAR
     ((#\  #\Tab #\Newline)
      (CL:RETURN-FROM EAT-NEXT-CHARACTER-IF-WHITESPACE FALSE))
     (CL:OTHERWISE
      (UNREAD-LAST-CHARACTER CHAR STREAM)
      (CL:RETURN-FROM EAT-NEXT-CHARACTER-IF-WHITESPACE FALSE)))))
  :VOID)

;;; (DEFCONSTANT READ-BUFFER-SIZE ...)

(CL:DEFVAR READ-BUFFER-SIZE NULL-INTEGER)

;;; (DEFGLOBAL *READ-BUFFER* ...)

(CL:DEFVAR *READ-BUFFER* NULL)

;;; (DEFUN (READ-DELIMITED-STRING STRING BOOLEAN) ...)

(CL:DEFUN READ-DELIMITED-STRING (STREAM DELIMITERS EATDELIMITER?)
  (CL:LET*
   ((FILLPOINTER 0) (STRING NULL) (CHAR NULL-CHARACTER) (EOF? FALSE))
   (CL:LOOP
    (CL:MULTIPLE-VALUE-SETQ (CHAR EOF?) (READ-NEXT-CHARACTER STREAM))
    (CL:COND
     ((CL:OR (CL:EQ EOF? 1) (CL:EQ (MEMBER? DELIMITERS CHAR) 1))
      (CL:WHEN
       (CL:NOT (CL:OR (CL:EQ EOF? 1) (CL:EQ EATDELIMITER? 1)))
       (UNREAD-LAST-CHARACTER CHAR STREAM))
      (CL:SETQ STRING (MAKE-STRING FILLPOINTER NULL-CHARACTER))
      (CL:LET*
       ((I NULL) (ITER-001 0) (UPPER-BOUND-001 (CL:1- FILLPOINTER)))
       (CL:LOOP
        WHILE
        (CL:<= ITER-001 UPPER-BOUND-001)
        DO
        (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
        (CL:SETF (CL:CHAR STRING I) (CL:CHAR *READ-BUFFER* I))))
      (CL:RETURN-FROM READ-DELIMITED-STRING (CL:VALUES STRING EOF?)))
     (CL:T
      (CL:WHEN
       (CL:EQL CHAR #\\)
       (CL:MULTIPLE-VALUE-SETQ (CHAR EOF?) (READ-NEXT-CHARACTER STREAM))
       (CL:WHEN
        (CL:EQ EOF? 1)
        (CL:RETURN-FROM READ-DELIMITED-STRING (CL:VALUES NULL TRUE))))
      (CL:WHEN
       (CL:= FILLPOINTER READ-BUFFER-SIZE)
       (CL:ERROR "Read-buffer overflow, atom or string too long"))
      (CL:SETF (CL:CHAR *READ-BUFFER* FILLPOINTER) CHAR)
      (CL:SETQ FILLPOINTER (CL:1+ FILLPOINTER))))))
  :VOID)

;;; (DEFUN (READ-STELLA-EXP OBJECT BOOLEAN) ...)

(CL:DEFUN READ-STELLA-EXP (STREAM)
  (CL:LET*
   ((CHAR NULL-CHARACTER) (EOF? FALSE))
   (CL:MULTIPLE-VALUE-SETQ
    (CHAR EOF?)
    (READ-NEXT-SIGNIFICANT-CHARACTER STREAM))
   (CL:WHEN
    (CL:EQ EOF? 1)
    (CL:RETURN-FROM READ-STELLA-EXP (CL:VALUES NULL TRUE)))
   (CL:CASE
    CHAR
    (#\( (CL:RETURN-FROM READ-STELLA-EXP (READ-STELLA-LIST STREAM)))
    (#\) (CL:ERROR "Extra right parenthesis encountered"))
    (#\" (CL:RETURN-FROM READ-STELLA-EXP (READ-STELLA-STRING STREAM)))
    (#\# (CL:RETURN-FROM READ-STELLA-EXP (READ-STELLA-HASH-SYNTAX STREAM)))
    (#\|
     (CL:RETURN-FROM
      READ-STELLA-EXP
      (READ-FULLY-ESCAPED-STELLA-SYMBOL STREAM)))
    (CL:OTHERWISE
     (CL:WHEN
      (CL:EQL CHAR #\\)
      (CL:MULTIPLE-VALUE-SETQ (CHAR EOF?) (READ-NEXT-CHARACTER STREAM))
      (CL:WHEN
       (CL:EQ EOF? 1)
       (CL:RETURN-FROM READ-STELLA-EXP (CL:VALUES NULL TRUE))))
     (UNREAD-LAST-CHARACTER CHAR STREAM)
     (CL:RETURN-FROM READ-STELLA-EXP (READ-STELLA-ATOM STREAM)))))
  :VOID)

;;; (DEFUN (READ-STELLA-LIST CONS BOOLEAN) ...)

(CL:DEFUN READ-STELLA-LIST (STREAM)
  (CL:LET*
   ((CHAR NULL-CHARACTER) (EOF? FALSE) (LIST NIL) (OBJECT NULL))
   (CL:LOOP
    (CL:MULTIPLE-VALUE-SETQ
     (CHAR EOF?)
     (READ-NEXT-SIGNIFICANT-CHARACTER STREAM))
    (CL:WHEN (CL:EQ EOF? 1) (CL:ERROR "EOF encountered before end of list"))
    (CL:WHEN
     (CL:EQL CHAR #\))
     (CL:RETURN-FROM READ-STELLA-LIST (CL:VALUES (REVERSE LIST) FALSE)))
    (UNREAD-LAST-CHARACTER CHAR STREAM)
    (CL:MULTIPLE-VALUE-SETQ (OBJECT EOF?) (READ-STELLA-EXP STREAM))
    (CL:IF
     (CL:EQ EOF? 1)
     (CL:RETURN-FROM READ-STELLA-LIST (CL:VALUES NULL TRUE))
     (CL:SETQ LIST (CONS OBJECT LIST)))))
  :VOID)

;;; (DEFUN (READ-STELLA-STRING STRING-WRAPPER BOOLEAN) ...)

(CL:DEFUN READ-STELLA-STRING (STREAM)
  (CL:LET*
   ((STRING NULL) (EOF? FALSE))
   (CL:MULTIPLE-VALUE-SETQ
    (STRING EOF?)
    (READ-DELIMITED-STRING STREAM "\"" TRUE))
   (CL:WHEN
    (CL:EQ EOF? 1)
    (CL:ERROR "EOF encountered before end of string")
    (CL:RETURN-FROM READ-STELLA-STRING (CL:VALUES NULL TRUE)))
   (CL:RETURN-FROM READ-STELLA-STRING (CL:VALUES (WRAP-LITERAL STRING) FALSE)))
  :VOID)

;;; (DEFUN (READ-FULLY-ESCAPED-STELLA-SYMBOL GENERALIZED-SYMBOL BOOLEAN) ...)

(CL:DEFUN READ-FULLY-ESCAPED-STELLA-SYMBOL (STREAM)
  (CL:LET*
   ((STRING NULL) (EOF? FALSE))
   (CL:MULTIPLE-VALUE-SETQ
    (STRING EOF?)
    (READ-DELIMITED-STRING STREAM "|" TRUE))
   (CL:WHEN
    (CL:EQ EOF? 1)
    (CL:ERROR "EOF encountered before end of fully escaped symbol")
    (CL:RETURN-FROM READ-FULLY-ESCAPED-STELLA-SYMBOL (CL:VALUES NULL TRUE)))
   (CL:RETURN-FROM
    READ-FULLY-ESCAPED-STELLA-SYMBOL
    (CL:VALUES (INTERN-GENERALIZED-SYMBOL STRING) FALSE)))
  :VOID)

;;; (DEFUN (READ-STELLA-HASH-SYNTAX OBJECT BOOLEAN) ...)

(CL:DEFUN READ-STELLA-HASH-SYNTAX (STREAM)
  (CL:LET*
   ((CHAR NULL-CHARACTER) (EOF? FALSE))
   (CL:MULTIPLE-VALUE-SETQ (CHAR EOF?) (READ-NEXT-CHARACTER STREAM))
   (CL:WHEN
    (CL:EQ EOF? 1)
    (CL:ERROR "EOF encountered before end of #-syntax"))
   (CL:CASE
    CHAR
    (#\\
     (CL:RETURN-FROM
      READ-STELLA-HASH-SYNTAX
      (READ-STELLA-CHARACTER-CONSTANT STREAM)))
    (#\|
     (SKIP-PARENTHESIZED-COMMENT STREAM)
     (CL:RETURN-FROM READ-STELLA-HASH-SYNTAX (READ-STELLA-EXP STREAM)))
    (CL:OTHERWISE (CL:ERROR "Illegal #-syntax sub-character `~A'" CHAR))))
  :VOID)

;;; (DEFUN (READ-STELLA-CHARACTER-CONSTANT CHARACTER-WRAPPER BOOLEAN) ...)

(CL:DEFUN READ-STELLA-CHARACTER-CONSTANT (STREAM)
  (CL:LET*
   ((CHAR NULL-CHARACTER) (STRING NULL) (EOF? FALSE))
   (CL:MULTIPLE-VALUE-SETQ (CHAR EOF?) (READ-NEXT-CHARACTER STREAM))
   (CL:WHEN
    (CL:EQ EOF? 1)
    (CL:ERROR "EOF encountered before end of character constant"))
   (CL:WHEN
    (CL:EQ (MEMBER? "sSnNbBtTrRpP" CHAR) 1)
    (UNREAD-LAST-CHARACTER CHAR STREAM)
    (CL:MULTIPLE-VALUE-SETQ
     (STRING EOF?)
     (READ-DELIMITED-STRING STREAM *STELLA-ATOM-DELIMITERS* FALSE))
    (CL:WHEN
     (CL:> (LENGTH STRING) 1)
     (CL:LET*
      ((I NULL) (ITER-001 0) (UPPER-BOUND-001 (CL:1- (LENGTH STRING))))
      (CL:LOOP
       WHILE
       (CL:<= ITER-001 UPPER-BOUND-001)
       DO
       (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
       (CL:SETF (CL:CHAR STRING I) (DOWNCASE-CHARACTER (CL:CHAR STRING I)))))
     (CL:COND
      ((CL:EQ (STRING-EQL? STRING "space") 1) (CL:SETQ CHAR #\ ))
      ((CL:EQ (STRING-EQL? STRING "newline") 1) (CL:SETQ CHAR #\Newline))
      ((CL:EQ (STRING-EQL? STRING "backspace") 1) (CL:SETQ CHAR #\Backspace))
      ((CL:EQ (STRING-EQL? STRING "tab") 1) (CL:SETQ CHAR #\Tab))
      ((CL:EQ (STRING-EQL? STRING "return") 1) (CL:SETQ CHAR #\Return))
      ((CL:EQ (STRING-EQL? STRING "page") 1) (CL:SETQ CHAR #\Page))
      (CL:T (CL:ERROR "Illegal character constant: '#\\`~A''" STRING)))))
   (CL:RETURN-FROM
    READ-STELLA-CHARACTER-CONSTANT
    (CL:VALUES (WRAP-LITERAL CHAR) EOF?)))
  :VOID)

;;; (DEFUN SKIP-PARENTHESIZED-COMMENT ...)

(CL:DEFUN SKIP-PARENTHESIZED-COMMENT (STREAM)
  (CL:LET*
   ((CHAR NULL-CHARACTER) (EOF? FALSE) (ESCAPE? FALSE) (STATE 0))
   (CL:LOOP
    (CL:MULTIPLE-VALUE-SETQ (CHAR EOF?) (READ-NEXT-CHARACTER STREAM))
    (CL:WHEN
     (CL:EQ EOF? 1)
     (CL:ERROR "EOF encountered before end of parenthesized comment"))
    (CL:CASE
     CHAR
     (#\\
      (CL:SETQ ESCAPE? (CL:IF (CL:EQ ESCAPE? 0) TRUE FALSE))
      (CL:SETQ STATE 0))
     (#\| (CL:WHEN (CL:EQ ESCAPE? 0) (CL:SETQ STATE (CL:1+ STATE))))
     (#\# (CL:WHEN (CL:EQ ESCAPE? 0) (CL:SETQ STATE (CL:1+ STATE))))
     (CL:OTHERWISE (CL:SETQ ESCAPE? FALSE) (CL:SETQ STATE 0)))
    (CL:WHEN (CL:= STATE 2) (CL:RETURN-FROM SKIP-PARENTHESIZED-COMMENT))))
  :VOID)

;;; (DEFGLOBAL *STELLA-ATOM-DELIMITERS* ...)

(CL:DEFVAR *STELLA-ATOM-DELIMITERS* NULL)

;;; (DEFUN (READ-STELLA-ATOM OBJECT BOOLEAN) ...)

(CL:DEFUN READ-STELLA-ATOM (STREAM)
  (CL:LET*
   ((ATOM NULL) (EOF? FALSE))
   (CL:MULTIPLE-VALUE-SETQ
    (ATOM EOF?)
    (READ-DELIMITED-STRING STREAM *STELLA-ATOM-DELIMITERS* FALSE))
   (CL:LET*
    ((TEST-VALUE-001 (CLASSIFY-STELLA-ATOM ATOM)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-READ-SYMBOL)
      (CL:RETURN-FROM
       READ-STELLA-ATOM
       (CL:VALUES (INTERN-GENERALIZED-SYMBOL ATOM) EOF?)))
     ((CL:EQ TEST-VALUE-001 KWD-READ-COMMON-LISP-SYMBOL)
      (CL:RETURN-FROM
       READ-STELLA-ATOM
       (CL:VALUES
        (INTERN-COMMON-LISP-SYMBOL (COMMON-LISP-SYMBOL-NAME ATOM))
        EOF?)))
     ((CL:EQ TEST-VALUE-001 KWD-READ-INTEGER)
      (CL:RETURN-FROM
       READ-STELLA-ATOM
       (CL:VALUES (WRAP-LITERAL (STRING-TO-INTEGER ATOM)) EOF?)))
     ((CL:EQ TEST-VALUE-001 KWD-READ-FLOAT)
      (CL:RETURN-FROM
       READ-STELLA-ATOM
       (CL:VALUES (WRAP-LITERAL (STRING-TO-FLOAT ATOM)) EOF?)))
     (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001)))))
  :VOID)

;;; (DEFUN (DIGIT-CHARACTER? BOOLEAN) ...)

(CL:DEFUN DIGIT-CHARACTER? (CHAR)
  (CL:RETURN-FROM DIGIT-CHARACTER? (MEMBER? "0123456789" CHAR))
  :VOID)

;;; (DEFUN (CLASSIFY-STELLA-ATOM KEYWORD) ...)

(CL:DEFUN CLASSIFY-STELLA-ATOM (ATOM)
  (CL:LET*
   ((COULDBEINTEGER? TRUE) (COULDBEFLOAT? TRUE) (LENGTH (LENGTH ATOM)))
   (CL:WHEN
    (CL:= LENGTH 0)
    (CL:RETURN-FROM CLASSIFY-STELLA-ATOM KWD-READ-SYMBOL))
   (CL:LET*
    ((I NULL) (ITER-001 0) (UPPER-BOUND-001 (CL:1- LENGTH)))
    (CL:LOOP
     WHILE
     (CL:<= ITER-001 UPPER-BOUND-001)
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:CASE
      (CL:CHAR ATOM I)
      ((#\+ #\- #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))
      ((#\. #\e #\E) (CL:SETQ COULDBEINTEGER? FALSE))
      (CL:OTHERWISE
       (CL:SETQ COULDBEINTEGER? FALSE)
       (CL:SETQ COULDBEFLOAT? FALSE)
       (CL:RETURN)))))
   (CL:WHEN
    (CL:AND
     (CL:EQ COULDBEINTEGER? 1)
     (CL:EQ (STRING-REPRESENTS-INTEGER? ATOM) 1))
    (CL:RETURN-FROM CLASSIFY-STELLA-ATOM KWD-READ-INTEGER))
   (CL:WHEN
    (CL:AND (CL:EQ COULDBEFLOAT? 1) (CL:EQ (STRING-REPRESENTS-FLOAT? ATOM) 1))
    (CL:RETURN-FROM CLASSIFY-STELLA-ATOM KWD-READ-FLOAT))
   (CL:WHEN
    (CL:AND
     (CL:EQ (MEMBER? ATOM #\:) 1)
     (CL:EQ (STRING-REPRESENTS-COMMON-LISP-SYMBOL? ATOM) 1))
    (CL:RETURN-FROM CLASSIFY-STELLA-ATOM KWD-READ-COMMON-LISP-SYMBOL))
   (CL:RETURN-FROM CLASSIFY-STELLA-ATOM KWD-READ-SYMBOL))
  :VOID)

;;; (DEFUN (STRING-REPRESENTS-INTEGER? BOOLEAN) ...)

(CL:DEFUN STRING-REPRESENTS-INTEGER? (STRING)
  (CL:LET*
   ((START 0) (LENGTH (LENGTH STRING)))
   (CL:WHEN (CL:= LENGTH 0) (CL:RETURN-FROM STRING-REPRESENTS-INTEGER? FALSE))
   (CL:WHEN (CL:EQ (MEMBER? "+-" (CL:CHAR STRING 0)) 1) (CL:SETQ START 1))
   (CL:LET*
    ((TEST-VALUE-001 FALSE))
    (CL:SETQ TEST-VALUE-001 (> LENGTH START))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:LET*
      ((ALWAYS?-001 TRUE))
      (CL:LET*
       ((I NULL) (ITER-001 START) (UPPER-BOUND-001 (CL:1- LENGTH)))
       (CL:LOOP
        WHILE
        (CL:<= ITER-001 UPPER-BOUND-001)
        DO
        (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
        (CL:WHEN
         (CL:EQ (DIGIT-CHARACTER? (CL:CHAR STRING I)) 0)
         (CL:SETQ ALWAYS?-001 FALSE)
         (CL:RETURN))))
      (CL:SETQ TEST-VALUE-001 ALWAYS?-001)))
    (CL:LET*
     ((VALUE-001 TEST-VALUE-001))
     (CL:RETURN-FROM STRING-REPRESENTS-INTEGER? VALUE-001))))
  :VOID)

;;; (DEFUN (STRING-REPRESENTS-FLOAT? BOOLEAN) ...)

(CL:DEFUN STRING-REPRESENTS-FLOAT? (STRING)
  (CL:LET*
   ((I 0)
    (LENGTH (LENGTH STRING))
    (HAVEINTEGRALPART? FALSE)
    (HAVEFRACTION? FALSE))
   (CL:WHEN (CL:= LENGTH 0) (CL:RETURN-FROM STRING-REPRESENTS-FLOAT? FALSE))
   (CL:WHEN (CL:EQ (MEMBER? "+-" (CL:CHAR STRING 0)) 1) (CL:SETQ I 1))
   (CL:LOOP
    WHILE
    (CL:AND (CL:< I LENGTH) (CL:EQ (DIGIT-CHARACTER? (CL:CHAR STRING I)) 1))
    DO
    (CL:SETQ HAVEINTEGRALPART? TRUE)
    (CL:SETQ I (CL:1+ I)))
   (CL:WHEN (CL:>= I LENGTH) (CL:RETURN-FROM STRING-REPRESENTS-FLOAT? FALSE))
   (CL:WHEN
    (CL:EQL (CL:CHAR STRING I) #\.)
    (CL:SETQ I (CL:1+ I))
    (CL:LOOP
     WHILE
     (CL:AND (CL:< I LENGTH) (CL:EQ (DIGIT-CHARACTER? (CL:CHAR STRING I)) 1))
     DO
     (CL:SETQ HAVEFRACTION? TRUE)
     (CL:SETQ I (CL:1+ I)))
    (CL:WHEN
     (CL:>= I LENGTH)
     (CL:RETURN-FROM STRING-REPRESENTS-FLOAT? HAVEFRACTION?)))
   (CL:WHEN
    (CL:AND
     (CL:EQ (MEMBER? "eE" (CL:CHAR STRING I)) 1)
     (CL:OR (CL:EQ HAVEINTEGRALPART? 1) (CL:EQ HAVEFRACTION? 1)))
    (CL:SETQ I (CL:1+ I))
    (CL:WHEN (CL:>= I LENGTH) (CL:RETURN-FROM STRING-REPRESENTS-FLOAT? FALSE))
    (CL:WHEN
     (CL:EQ (MEMBER? "+-" (CL:CHAR STRING I)) 1)
     (CL:SETQ I (CL:1+ I)))
    (CL:WHEN (CL:>= I LENGTH) (CL:RETURN-FROM STRING-REPRESENTS-FLOAT? FALSE))
    (CL:LOOP
     WHILE
     (CL:AND (CL:< I LENGTH) (CL:EQ (DIGIT-CHARACTER? (CL:CHAR STRING I)) 1))
     DO
     (CL:SETQ I (CL:1+ I)))
    (CL:WHEN (CL:>= I LENGTH) (CL:RETURN-FROM STRING-REPRESENTS-FLOAT? TRUE)))
   (CL:RETURN-FROM STRING-REPRESENTS-FLOAT? FALSE))
  :VOID)

;;; (DEFUN (STRING-REPRESENTS-COMMON-LISP-SYMBOL? BOOLEAN) ...)

(CL:DEFUN STRING-REPRESENTS-COMMON-LISP-SYMBOL? (STRING)
  (CL:RETURN-FROM
   STRING-REPRESENTS-COMMON-LISP-SYMBOL?
   (CL:IF
    (CL:AND
     (CL:>= (LENGTH STRING) 4)
     (CL:EQ (MEMBER? "cC" (CL:CHAR STRING 0)) 1)
     (CL:EQ (MEMBER? "lL" (CL:CHAR STRING 1)) 1)
     (CL:EQL (CL:CHAR STRING 2) #\:))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (COMMON-LISP-SYMBOL-NAME STRING) ...)

(CL:DEFUN COMMON-LISP-SYMBOL-NAME (QUALIFIEDNAME)
  (CL:RETURN-FROM
   COMMON-LISP-SYMBOL-NAME
   (SUBSEQUENCE
    QUALIFIEDNAME
    (CL:IF (CL:EQL (CL:CHAR QUALIFIEDNAME 3) #\:) 4 3)
    (LENGTH QUALIFIEDNAME)))
  :VOID)

;;; (DEFUN (READ-STELLA-EXPRESSION OBJECT BOOLEAN) ...)

(CL:DEFUN READ-STELLA-EXPRESSION (STREAM)
  "Read one Stella s-expression (parse-tree) from 'stream'.
Return TRUE as the second value on EOF.  This is the Stella implementation
of 'read-s-expression' (which uses the native LISP or YACC/BISON reader)."
  (CL:LET*
   ((*TRANSIENTOBJECTS?* TRUE))
   (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
   (CL:LET*
    ((OBJECT NULL) (EOF? FALSE))
    (CL:MULTIPLE-VALUE-SETQ (OBJECT EOF?) (READ-STELLA-EXP STREAM))
    (CL:WHEN
     (CL:EQ EOF? 0)
     (CL:SETQ EOF? (EAT-NEXT-CHARACTER-IF-WHITESPACE STREAM)))
    (CL:RETURN-FROM READ-STELLA-EXPRESSION (CL:VALUES OBJECT EOF?))))
  :VOID)

;;; (DEFUN (YES-OR-NO? BOOLEAN) ...)

(CL:DEFUN YES-OR-NO? (MESSAGE)
  "Read a line of input from STANDARD-INPUT and return TRUE
if the input was `yes' or FALSE if the input was `no'.  Loop until either
`yes' or `no' was entered.  If 'message' is non-NULL prompt with it before
the input is read."
  (CL:LET*
   ((INPUT NULL))
   (CL:LOOP
    (CL:WHEN
     (CL:NOT (CL:EQ MESSAGE NULL))
     (CL:WRITE-STRING
      MESSAGE
      (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:SETQ
     INPUT
     (STRING-UPCASE
      (READ-LINE (CLSYS-SVAL INPUT-STREAM NATIVE-STREAM STANDARD-INPUT))))
    (CL:WHEN
     (CL:EQ (STRING-EQL? INPUT "YES") 1)
     (CL:RETURN-FROM YES-OR-NO? TRUE))
    (CL:WHEN
     (CL:EQ (STRING-EQL? INPUT "NO") 1)
     (CL:RETURN-FROM YES-OR-NO? FALSE))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "Type `yes' for yes or `no' for no." %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))))
  :VOID)

;;; (DEFUN (Y-OR-N? BOOLEAN) ...)

(CL:DEFUN Y-OR-N? (MESSAGE)
  "Read a line of input from STANDARD-INPUT and return TRUE
if the input was `y' or FALSE if the input was `n'.  Loop until either
`y' or `n' was entered.  If 'message' is non-NULL prompt with it before
the input is read."
  (CL:LET*
   ((INPUT NULL))
   (CL:LOOP
    (CL:WHEN
     (CL:NOT (CL:EQ MESSAGE NULL))
     (CL:WRITE-STRING
      MESSAGE
      (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:SETQ
     INPUT
     (READ-LINE (CLSYS-SVAL INPUT-STREAM NATIVE-STREAM STANDARD-INPUT)))
    (CL:WHEN
     (CL:> (LENGTH INPUT) 0)
     (CL:CASE
      (CL:CHAR INPUT 0)
      ((#\y #\Y) (CL:RETURN-FROM Y-OR-N? TRUE))
      ((#\n #\N) (CL:RETURN-FROM Y-OR-N? FALSE))
      (CL:OTHERWISE NULL)))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "Type `y' for yes or `n' for no." %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))))
  :VOID)

(CL:DEFUN STARTUP-READ ()
  (CL:LET*
   ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ KWD-READ-SYMBOL (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" NULL 2))
    (CL:SETQ
     KWD-READ-COMMON-LISP-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP-SYMBOL" NULL 2))
    (CL:SETQ
     KWD-READ-INTEGER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER" NULL 2))
    (CL:SETQ KWD-READ-FLOAT (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT" NULL 2)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:SETQ READ-BUFFER-SIZE (CL:* 16 1024))
    (CL:SETQ *READ-BUFFER* (MAKE-STRING READ-BUFFER-SIZE NULL-CHARACTER))
    (CL:SETQ *STELLA-ATOM-DELIMITERS* (COPY "     ()\"|#;")))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-NEXT-CHARACTER"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (READ-NEXT-CHARACTER CHARACTER BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-NEXT-CHARACTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNREAD-LAST-CHARACTER"
        "CHARACTER"
        "(DEFUN UNREAD-LAST-CHARACTER ((CHAR CHARACTER) (STREAM NATIVE-INPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNREAD-LAST-CHARACTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-NEXT-SIGNIFICANT-CHARACTER"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (READ-NEXT-SIGNIFICANT-CHARACTER CHARACTER BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-NEXT-SIGNIFICANT-CHARACTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EAT-NEXT-CHARACTER-IF-WHITESPACE"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (EAT-NEXT-CHARACTER-IF-WHITESPACE BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EAT-NEXT-CHARACTER-IF-WHITESPACE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-DELIMITED-STRING"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (READ-DELIMITED-STRING STRING BOOLEAN) ((STREAM NATIVE-INPUT-STREAM) (DELIMITERS STRING) (EATDELIMITER? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-DELIMITED-STRING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-STELLA-EXP"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (READ-STELLA-EXP OBJECT BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-STELLA-EXP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-STELLA-LIST"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (READ-STELLA-LIST CONS BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-STELLA-LIST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-STELLA-STRING"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (READ-STELLA-STRING STRING-WRAPPER BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-STELLA-STRING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-FULLY-ESCAPED-STELLA-SYMBOL"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (READ-FULLY-ESCAPED-STELLA-SYMBOL GENERALIZED-SYMBOL BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-FULLY-ESCAPED-STELLA-SYMBOL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-STELLA-HASH-SYNTAX"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (READ-STELLA-HASH-SYNTAX OBJECT BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-STELLA-HASH-SYNTAX)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-STELLA-CHARACTER-CONSTANT"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (READ-STELLA-CHARACTER-CONSTANT CHARACTER-WRAPPER BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-STELLA-CHARACTER-CONSTANT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SKIP-PARENTHESIZED-COMMENT"
        "NATIVE-INPUT-STREAM"
        "(DEFUN SKIP-PARENTHESIZED-COMMENT ((STREAM NATIVE-INPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SKIP-PARENTHESIZED-COMMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-STELLA-ATOM"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (READ-STELLA-ATOM OBJECT BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-STELLA-ATOM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DIGIT-CHARACTER?"
        "CHARACTER"
        "(DEFUN (DIGIT-CHARACTER? BOOLEAN) ((CHAR CHARACTER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DIGIT-CHARACTER?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASSIFY-STELLA-ATOM"
        "STRING"
        "(DEFUN (CLASSIFY-STELLA-ATOM KEYWORD) ((ATOM STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASSIFY-STELLA-ATOM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING-REPRESENTS-INTEGER?"
        "STRING"
        "(DEFUN (STRING-REPRESENTS-INTEGER? BOOLEAN) ((STRING STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING-REPRESENTS-INTEGER?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING-REPRESENTS-FLOAT?"
        "STRING"
        "(DEFUN (STRING-REPRESENTS-FLOAT? BOOLEAN) ((STRING STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING-REPRESENTS-FLOAT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING-REPRESENTS-COMMON-LISP-SYMBOL?"
        "STRING"
        "(DEFUN (STRING-REPRESENTS-COMMON-LISP-SYMBOL? BOOLEAN) ((STRING STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING-REPRESENTS-COMMON-LISP-SYMBOL?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMMON-LISP-SYMBOL-NAME"
        "STRING"
        "(DEFUN (COMMON-LISP-SYMBOL-NAME STRING) ((QUALIFIEDNAME STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMMON-LISP-SYMBOL-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-STELLA-EXPRESSION"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (READ-STELLA-EXPRESSION OBJECT BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)) :DOCUMENTATION \"Read one Stella s-expression (parse-tree) from 'stream'.
Return TRUE as the second value on EOF.  This is the Stella implementation
of 'read-s-expression' (which uses the native LISP or YACC/BISON reader).\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-STELLA-EXPRESSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YES-OR-NO?"
        "STRING"
        "(DEFUN (YES-OR-NO? BOOLEAN) ((MESSAGE STRING)) :DOCUMENTATION \"Read a line of input from STANDARD-INPUT and return TRUE
if the input was `yes' or FALSE if the input was `no'.  Loop until either
`yes' or `no' was entered.  If 'message' is non-NULL prompt with it before
the input is read.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YES-OR-NO?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "Y-OR-N?"
        "STRING"
        "(DEFUN (Y-OR-N? BOOLEAN) ((MESSAGE STRING)) :DOCUMENTATION \"Read a line of input from STANDARD-INPUT and return TRUE
if the input was `y' or FALSE if the input was `n'.  Loop until either
`y' or `n' was entered.  If 'message' is non-NULL prompt with it before
the input is read.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION Y-OR-N?)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-READ"
     NULL
     "(DEFUN STARTUP-READ ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *INPUTECHOSTREAM* NATIVE-OUTPUT-STREAM NULL :DOCUMENTATION \"If non-NULL, characters read with 'read-next-character' will
be echoed to the stream bound to '*inputEchoStream*'.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *UNREAD-LAST-CHARACTER?* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT READ-BUFFER-SIZE INTEGER (* 16 1024))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *READ-BUFFER* STRING (MAKE-STRING READ-BUFFER-SIZE NULL))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *STELLA-ATOM-DELIMITERS* STRING (COPY \"     ()\\\"|#;\"))")
    (CL:SETF (CL:CHAR *STELLA-ATOM-DELIMITERS* 0) #\ )
    (CL:SETF (CL:CHAR *STELLA-ATOM-DELIMITERS* 1) #\Tab)
    (CL:SETF (CL:CHAR *STELLA-ATOM-DELIMITERS* 2) #\Newline)
    (CL:SETF (CL:CHAR *STELLA-ATOM-DELIMITERS* 3) #\Return)
    (CL:SETF (CL:CHAR *STELLA-ATOM-DELIMITERS* 4) #\Page)))
  :VOID)
