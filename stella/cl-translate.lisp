;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-CL-TRANSLATE-SYS-CALL-FUNCTION NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-SYS-CALL-METHOD NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-KEY-VALUE-LIST NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-+ NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-- NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-* NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-/ NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-EQ? NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-< NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-<= NULL)
(CL:DEFVAR SYM-CL-TRANSLATE->= NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-> NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-= NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-!/= NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-USE-COMMON-LISP-STRUCTS NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-USE-COMMON-LISP-VECTOR-STRUCTS NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-VOID NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-VOID-SYS NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-TYPED-SYS NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-BAD-SYS NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-SETQ NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-SYS-SLOT-VALUE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-SYS-SLOT-VALUE-SETTER NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-PROGN NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-LOOP NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-SYS-FOREACH NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-LET NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STARTUP-TIME-PROGN NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-SPECIAL NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-CAST NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-SAFE-CAST NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-RETURN NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-BREAK NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-CONTINUE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-WHILE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-IF NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-CHOOSE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-WHEN NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-UNLESS NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-AND NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-OR NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-NOT NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-COND NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-CASE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-MAKE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-SYS-NEW NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-MV-SETQ NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-QUOTE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-SYS-CALL-FUNCTION-CODE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-SYS-CALL-METHOD-CODE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-THE-CODE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-PRINT-STREAM NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-PRINT-NATIVE-STREAM NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-VERBATIM NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-INLINE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-IGNORE NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-CONTINUE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-GET-KWD NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-GET-SGT NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-CLSYS-SVAL NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-NTH NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-NTH-SETTER NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-NULL? NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-DEFINED? NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-NORMAL-CALL NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-OBJECT NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-NON-OBJECT-METHOD NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-PRINT-OBJECT NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-OBJECT-METHOD NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-COMMON-LISP NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-FUNCTION NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-CLSYS-CALL NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-NULL NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STRING NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-VECTOR NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-THE-ARRAY NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-DO NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-EVAL-WHEN NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-PRIMARY-TYPE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-NIL? NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-EMPTY? NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-NON-EMPTY? NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-LITERAL NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-NUMBER NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-BOOLEAN NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-CODE NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-CONS NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-NIL NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-OTHERWISE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-TRUE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-FALSE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-CLASS-CL-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-CLSYS-MAKE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-%%STREAM NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-WARN NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-ERROR NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-CONTINUABLE-ERROR NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-GLOBAL-VARIABLE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-CLASS NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-METHOD NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-MACRO NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-PRINT-METHOD NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-TYPE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-CLSYS-SELF NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-CLSYS-DUMMY NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-DOCUMENTATION NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-SELF NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-*CLSYS-SELF* NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-VOID NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-EMBEDDED NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-INSTANCE NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-ALLOCATION NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-DOCUMENTATION NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-ACCESSOR NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-CLASS-CL-STRUCT-SLOTS NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-CONC-NAME NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-CONSTRUCTOR NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-INCLUDE NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-UNBOUND-SPECIAL-VARIABLE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STREAM NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *STELLA-MODULE*
  STANDARD-OUTPUT
  ONE-WRAPPER
  NULL-STRING-WRAPPER
  *CURRENTTRANSLATIONUNIT*
  *SAFETY*
  *STARTUP-TIME-PHASE*
  *UNFINALIZED-CLASSES*
  EOL
  *COMMON-LISP-MODULE*
  *MODULE*
  *CURRENT-ENVIRONMENT-FEATURES*))

;;; (DEFUN (DESTRUCTURE-CALL-TREE SYMBOL TYPE CONS) ...)

(CL:DEFUN DESTRUCTURE-CALL-TREE (TREE)
  (CL:LET*
   ((TEST-VALUE-001 (FIRST TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-SYS-CALL-FUNCTION)
     (CL:RETURN-FROM
      DESTRUCTURE-CALL-TREE
      (CL:VALUES
       (SECOND TREE)
       NULL
       (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))))
    ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-SYS-CALL-METHOD)
     (CL:RETURN-FROM
      DESTRUCTURE-CALL-TREE
      (CL:VALUES
       (THIRD TREE)
       (SECOND TREE)
       (CLSYS-SVAL
        CONS
        REST
        (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))))
    (CL:T
     (CL:RETURN-FROM
      DESTRUCTURE-CALL-TREE
      (CL:VALUES (FIRST TREE) NULL (CLSYS-SVAL CONS REST TREE))))))
  :VOID)

;;; (DEFGLOBAL *CL-OPERATOR-TABLE* ...)

(CL:DEFVAR *CL-OPERATOR-TABLE* NULL
  "Mapping from STELLA operators to Common-Lisp operators.")

;;; (DEFUN (USE-CL-STRUCTS? BOOLEAN) ...)

(CL:DEFUN USE-CL-STRUCTS? ()
  (CL:RETURN-FROM
   USE-CL-STRUCTS?
   (MEMBER?
    *CURRENT-ENVIRONMENT-FEATURES*
    KWD-CL-TRANSLATE-USE-COMMON-LISP-STRUCTS))
  :VOID)

;;; (DEFUN (USE-VECTOR-STRUCTS? BOOLEAN) ...)

(CL:DEFUN USE-VECTOR-STRUCTS? ()
  (CL:RETURN-FROM
   USE-VECTOR-STRUCTS?
   (MEMBER?
    *CURRENT-ENVIRONMENT-FEATURES*
    KWD-CL-TRANSLATE-USE-COMMON-LISP-VECTOR-STRUCTS))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-LIST-OF-TREES CONS) ...)

(CL:DEFUN CL-TRANSLATE-LIST-OF-TREES (TREES)
  (CL:LET*
   ((CURSOR TREES))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:SETF
     (CLSYS-SVAL CONS VALUE CURSOR)
     (CL-TRANSLATE-A-TREE (CLSYS-SVAL CONS VALUE CURSOR)))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (CL:RETURN-FROM CL-TRANSLATE-LIST-OF-TREES TREES))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-VOID-SYS CONS) ...)

(CL:DEFUN CL-TRANSLATE-VOID-SYS (TREE)
  (CL:LET*
   ((OTREE (CL-TRANSLATE-A-TREE (SECOND TREE))))
   (FREE-CONS TREE)
   (CL:RETURN-FROM CL-TRANSLATE-VOID-SYS OTREE))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-TYPED-SYS OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-TYPED-SYS (TREE)
  (CL:LET*
   ((OTREE (CL-TRANSLATE-A-TREE (SECOND TREE))))
   (FREE-TRANSIENT-TYPE-SPEC (THIRD TREE))
   (FREE-CONS TREE)
   (CL:RETURN-FROM CL-TRANSLATE-TYPED-SYS OTREE))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-BAD-SYS OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-BAD-SYS (TREE)
  (CL:LET*
   ((RETURNTYPE (THIRD TREE)))
   (FREE-CONS TREE)
   (CL:IF
    (CL:EQ RETURNTYPE SGT-CL-TRANSLATE-VOID)
    (CL:RETURN-FROM CL-TRANSLATE-BAD-SYS (YIELD-ILLEGAL-STATEMENT-TREE))
    (CL:RETURN-FROM CL-TRANSLATE-BAD-SYS (YIELD-ILLEGAL-EXPRESSION-TREE))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-A-TREE OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-A-TREE (TREE)
  (CL:RETURN-FROM CL-TRANSLATE-A-TREE (HELP-CL-TRANSLATE-A-TREE TREE))
  :VOID)

;;; (DEFUN (HELP-CL-TRANSLATE-A-TREE OBJECT) ...)

(CL:DEFUN HELP-CL-TRANSLATE-A-TREE (TREE)
  (CL:WHEN (CL:EQ TREE NULL) (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE))
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:WHEN
       (CL:EQ TREE NIL)
       (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE))
      (CL:LET*
       ((TEST-VALUE-001 (FIRST TREE)))
       (CL:COND
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-VOID-SYS)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-VOID-SYS TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-TYPED-SYS)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-TYPED-SYS TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-BAD-SYS)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-BAD-SYS TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-SETQ)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-SETQ-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-SYS-SLOT-VALUE)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-FIXED-SLOT-VALUE-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-SYS-SLOT-VALUE-SETTER)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-FIXED-SLOT-VALUE-SETTER-TREE TREE)))
        ((CL:OR
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-SYS-CALL-METHOD)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-SYS-CALL-FUNCTION))
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-CALL-METHOD-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-PROGN)
         (CL:SETF
          (CLSYS-SVAL CONS VALUE TREE)
          (INTERN-COMMON-LISP-SYMBOL "PROGN"))
         (CL:SETF
          (CLSYS-SVAL CONS REST TREE)
          (CL-TRANSLATE-LIST-OF-TREES (CLSYS-SVAL CONS REST TREE)))
         (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-LOOP)
         (CL:SETF
          (CLSYS-SVAL CONS VALUE TREE)
          (INTERN-COMMON-LISP-SYMBOL "LOOP"))
         (CL:SETF
          (CLSYS-SVAL CONS REST TREE)
          (MAYBE-WRAP-WITH-CONTINUE-LABEL
           (CL-TRANSLATE-LIST-OF-TREES (CLSYS-SVAL CONS REST TREE))))
         (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-SYS-FOREACH)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-FOREACH-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-LET)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-LET-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-STARTUP-TIME-PROGN)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-STARTUP-TIME-PROGN-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-SPECIAL)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-SPECIAL-TREE TREE)))
        ((CL:OR
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-CAST)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-SAFE-CAST))
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-CAST-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-RETURN)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-RETURN-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-BREAK)
         (FIRST-SETTER TREE (INTERN-COMMON-LISP-SYMBOL "RETURN"))
         (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-CONTINUE)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (LIST*
           (INTERN-COMMON-LISP-SYMBOL "GO")
           KWD-CL-TRANSLATE-CONTINUE
           NIL)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-WHILE)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-WHILE-TREE TREE)))
        ((CL:OR
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-IF)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-CHOOSE)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-WHEN)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-UNLESS))
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-CONDITIONAL-TREE TREE)))
        ((CL:OR
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-AND)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-OR)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-NOT))
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-BOOLEAN-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-COND)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-COND-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-CASE)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-CASE-TREE TREE)))
        ((CL:OR
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-EQ?)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE->)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE->=)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-<)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-<=))
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-OPERATOR-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-MAKE)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-MAKE-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-SYS-NEW)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-NEW-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-MV-SETQ)
         (FIRST-SETTER TREE (INTERN-COMMON-LISP-SYMBOL "MULTIPLE-VALUE-SETQ"))
         (THIRD-SETTER TREE (CL-TRANSLATE-A-TREE (THIRD TREE)))
         (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-QUOTE)
         (FIRST-SETTER TREE (INTERN-COMMON-LISP-SYMBOL "QUOTE"))
         (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE))
        ((CL:OR
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-SYS-CALL-FUNCTION-CODE)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-SYS-CALL-METHOD-CODE))
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-CALL-FUNCTION-CODE-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-THE-CODE)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-THE-CODE-TREE TREE)))
        ((CL:OR
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-PRINT-STREAM)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-PRINT-NATIVE-STREAM))
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-PRINT-STREAM-TREE TREE)))
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-VERBATIM)
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-VERBATIM-TREE TREE)))
        ((CL:OR
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-INLINE)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-IGNORE))
         (CL:RETURN-FROM
          HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-INLINE-TREE TREE)))
        (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))))
    (CL:T
     (CL:RETURN-FROM
      HELP-CL-TRANSLATE-A-TREE
      (CL-TRANSLATE-ATOMIC-TREE TREE)))))
  :VOID)

;;; (DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ...)

(CL:DEFMETHOD CL-TRANSLATE-ATOMIC-TREE ((TREE OBJECT))
  (CL:RETURN-FROM CL-TRANSLATE-ATOMIC-TREE TREE)
  :VOID)

;;; (DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ...)

(CL:DEFMETHOD CL-TRANSLATE-ATOMIC-TREE ((TREE SYMBOL))
  (CL:IF
   (CL:NOT (CL:EQ (LOOKUP-GLOBAL-VARIABLE TREE) NULL))
   (CL:RETURN-FROM CL-TRANSLATE-ATOMIC-TREE (CL-TRANSLATE-GLOBAL-SYMBOL TREE))
   (CL:LET*
    ((SYMBOLMODULE (CLSYS-SVAL SYMBOL HOME-CONTEXT TREE)))
    (CL:IF
     (CL:OR (CL:EQ SYMBOLMODULE NULL) (CL:EQ SYMBOLMODULE *MODULE*))
     (CL:RETURN-FROM CL-TRANSLATE-ATOMIC-TREE TREE)
     (CL:RETURN-FROM
      CL-TRANSLATE-ATOMIC-TREE
      (NEW-VERBATIM-STRING-WRAPPER (CLSYS-SVAL SYMBOL SYMBOL-NAME TREE))))))
  :VOID)

;;; (DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ...)

(CL:DEFMETHOD CL-TRANSLATE-ATOMIC-TREE ((TREE KEYWORD))
  (CL:IF
   (CL:EQ (USE-HARDCODED-SYMBOLS?) 1)
   (CL:LET*
    ((OFFSET (WRAP-LITERAL (CLSYS-SVAL KEYWORD SYMBOL-ID (KEYWORDIFY TREE)))))
    (CL:RETURN-FROM
     CL-TRANSLATE-ATOMIC-TREE
     (LIST* SYM-CL-TRANSLATE-GET-KWD OFFSET NIL)))
   (CL:RETURN-FROM
    CL-TRANSLATE-ATOMIC-TREE
    (CL-TRANSLATE-GLOBAL-SYMBOL (YIELD-SYMBOL-CONSTANT-NAME TREE))))
  :VOID)

;;; (DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ...)

(CL:DEFMETHOD CL-TRANSLATE-ATOMIC-TREE ((TREE SURROGATE))
  (CL:IF
   (CL:EQ (USE-HARDCODED-SYMBOLS?) 1)
   (CL:LET*
    ((OFFSET (WRAP-LITERAL (CLSYS-SVAL SURROGATE SYMBOL-ID TREE))))
    (CL:RETURN-FROM
     CL-TRANSLATE-ATOMIC-TREE
     (LIST* SYM-CL-TRANSLATE-GET-SGT OFFSET NIL)))
   (CL:RETURN-FROM
    CL-TRANSLATE-ATOMIC-TREE
    (CL-TRANSLATE-GLOBAL-SYMBOL (YIELD-SYMBOL-CONSTANT-NAME TREE))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-GLOBAL-SYMBOL OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-GLOBAL-SYMBOL (SYMBOL)
  (CL:LET*
   ((SYMBOLMODULE (CLSYS-SVAL SYMBOL HOME-CONTEXT SYMBOL)))
   (CL:WHEN
    (CL:EQ SYMBOLMODULE *COMMON-LISP-MODULE*)
    (CL:RETURN-FROM CL-TRANSLATE-GLOBAL-SYMBOL SYMBOL))
   (CL:WHEN (CL:EQ SYMBOLMODULE NULL) (CL:SETQ SYMBOLMODULE *MODULE*))
   (CL:RETURN-FROM
    CL-TRANSLATE-GLOBAL-SYMBOL
    (YIELD-GLOBAL-LISP-SYMBOL
     SYMBOLMODULE
     (CLSYS-SVAL SYMBOL SYMBOL-NAME SYMBOL))))
  :VOID)

;;; (DEFUN (YIELD-GLOBAL-LISP-SYMBOL OBJECT) ...)

(CL:DEFUN YIELD-GLOBAL-LISP-SYMBOL (SYMBOLMODULE SYMBOLNAME)
  (CL:LET*
   ((LISPSYMBOLPACKAGE
     (CL:IF
      (CL:OR
       (CL:EQ SYMBOLMODULE NULL)
       (CL:EQ SYMBOLMODULE *MODULE*)
       (CL:EQ
        (STRING-EQL? (NATIVE-PACKAGE SYMBOLMODULE) (NATIVE-PACKAGE *MODULE*))
        1))
      NULL
      (NATIVE-PACKAGE SYMBOLMODULE)))
    (LISPSYMBOLNAME
     (CL:IF
      (CL:NOT
       (CL:EQ (CLSYS-SVAL MODULE MODULE-NATIVE-PACKAGE SYMBOLMODULE) NULL))
      SYMBOLNAME
      (COMPUTE-FULL-NAME SYMBOLNAME SYMBOLMODULE))))
   (CL:WHEN
    (CL:EQ (CLSYS-SVAL MODULE CASE-SENSITIVE? SYMBOLMODULE) 1)
    (CL:SETQ
     LISPSYMBOLNAME
     (CONCATENATE "|" (CONCATENATE LISPSYMBOLNAME "|"))))
   (CL:IF
    (CL:EQ LISPSYMBOLPACKAGE NULL)
    (CL:RETURN-FROM
     YIELD-GLOBAL-LISP-SYMBOL
     (NEW-VERBATIM-STRING-WRAPPER LISPSYMBOLNAME))
    (CL:RETURN-FROM
     YIELD-GLOBAL-LISP-SYMBOL
     (NEW-VERBATIM-STRING-WRAPPER
      (CONCATENATE LISPSYMBOLPACKAGE (CONCATENATE "::" LISPSYMBOLNAME))))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-SETQ-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-SETQ-TREE (TREE)
  (FIRST-SETTER TREE (INTERN-COMMON-LISP-SYMBOL "SETQ"))
  (SECOND-SETTER TREE (CL-TRANSLATE-A-TREE (SECOND TREE)))
  (THIRD-SETTER TREE (CL-TRANSLATE-A-TREE (THIRD TREE)))
  (CL:RETURN-FROM CL-TRANSLATE-SETQ-TREE TREE)
  :VOID)

;;; (DEFUN (YIELD-STRUCT-SLOT-ACCESSOR-NAME OBJECT) ...)

(CL:DEFUN YIELD-STRUCT-SLOT-ACCESSOR-NAME (CLASSTYPE SLOTNAME)
  (CL:RETURN-FROM
   YIELD-STRUCT-SLOT-ACCESSOR-NAME
   (YIELD-GLOBAL-LISP-SYMBOL
    (CLSYS-SVAL SURROGATE HOME-CONTEXT CLASSTYPE)
    (CONCATENATE
     (CLSYS-SVAL SURROGATE SYMBOL-NAME CLASSTYPE)
     (CONCATENATE "..." (CLSYS-SVAL SYMBOL SYMBOL-NAME SLOTNAME)))))
  :VOID)

;;; (DEFUN (YIELD-CLOS-SLOT-ACCESSOR-NAME OBJECT) ...)

(CL:DEFUN YIELD-CLOS-SLOT-ACCESSOR-NAME (SLOTNAME)
  (CL:RETURN-FROM
   YIELD-CLOS-SLOT-ACCESSOR-NAME
   (YIELD-GLOBAL-LISP-SYMBOL
    (CLSYS-SVAL SYMBOL HOME-CONTEXT SLOTNAME)
    (CONCATENATE (CLSYS-SVAL SYMBOL SYMBOL-NAME SLOTNAME) "...OF")))
  :VOID)

;;; (DEFUN (YIELD-SLOT-VALUE-READER-TREE CONS) ...)

(CL:DEFUN YIELD-SLOT-VALUE-READER-TREE (SLOTNAME OBJECTREF OBJECTTYPE)
  (CL:IF
   (CL:EQ (USE-CL-STRUCTS?) 1)
   (CL:IF
    (CL:EQ (USE-VECTOR-STRUCTS?) 1)
    (CL:RETURN-FROM
     YIELD-SLOT-VALUE-READER-TREE
     (CONS
      (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-CLSYS-SVAL)
      (CONS
       (WRAP-LITERAL (CL-STRUCT-SLOT-OFFSET SLOTNAME OBJECTTYPE))
       (CONS
        (CL-TRANSLATE-GLOBAL-SYMBOL (TYPE-TO-SYMBOL OBJECTTYPE))
        (CONS (CL-TRANSLATE-GLOBAL-SYMBOL SLOTNAME) (CONS OBJECTREF NIL))))))
    (CL:RETURN-FROM
     YIELD-SLOT-VALUE-READER-TREE
     (CONS
      (YIELD-STRUCT-SLOT-ACCESSOR-NAME OBJECTTYPE SLOTNAME)
      (CONS OBJECTREF NIL))))
   (CL:RETURN-FROM
    YIELD-SLOT-VALUE-READER-TREE
    (CONS
     (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-CLSYS-SVAL)
     (CONS
      (CL-TRANSLATE-GLOBAL-SYMBOL (TYPE-TO-SYMBOL OBJECTTYPE))
      (CONS (CL-TRANSLATE-GLOBAL-SYMBOL SLOTNAME) (CONS OBJECTREF NIL))))))
  :VOID)

;;; (DEFUN (YIELD-SLOT-VALUE-WRITER-TREE CONS) ...)

(CL:DEFUN YIELD-SLOT-VALUE-WRITER-TREE (SLOTNAME OBJECTREF OBJECTTYPE VALUEREF)
  (CL:RETURN-FROM
   YIELD-SLOT-VALUE-WRITER-TREE
   (LIST*
    (INTERN-COMMON-LISP-SYMBOL "SETF")
    (YIELD-SLOT-VALUE-READER-TREE SLOTNAME OBJECTREF OBJECTTYPE)
    (CONS VALUEREF NIL)))
  :VOID)

;;; (DEFUN (TRUE-SLOT-NAME SYMBOL) ...)

(CL:DEFUN TRUE-SLOT-NAME (SLOTNAME TYPE)
  (CL:RETURN-FROM
   TRUE-SLOT-NAME
   (CLSYS-SVAL
    STORAGE-SLOT
    SLOT-NAME
    (CANONICAL-SLOT
     (LOOKUP-SLOT (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE) SLOTNAME))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-FIXED-SLOT-VALUE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-FIXED-SLOT-VALUE-TREE (TREE)
  (CL:LET*
   ((OBJTYPE (SECOND TREE))
    (SLOTNAME (TRUE-SLOT-NAME (THIRD TREE) OBJTYPE))
    (OBJREF (CL-TRANSLATE-A-TREE (FOURTH TREE)))
    (OTREE (YIELD-SLOT-VALUE-READER-TREE SLOTNAME OBJREF OBJTYPE)))
   (FREE-CONS-LIST TREE)
   (CL:RETURN-FROM CL-TRANSLATE-FIXED-SLOT-VALUE-TREE OTREE))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-FIXED-SLOT-VALUE-SETTER-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-FIXED-SLOT-VALUE-SETTER-TREE (TREE)
  (CL:LET*
   ((OBJTYPE (SECOND TREE))
    (SLOTNAME (TRUE-SLOT-NAME (THIRD TREE) OBJTYPE))
    (OBJREF (CL-TRANSLATE-A-TREE (FOURTH TREE)))
    (VALUEREF (CL-TRANSLATE-A-TREE (FIFTH TREE)))
    (OTREE (YIELD-SLOT-VALUE-WRITER-TREE SLOTNAME OBJREF OBJTYPE VALUEREF)))
   (FREE-CONS-LIST TREE)
   (CL:RETURN-FROM CL-TRANSLATE-FIXED-SLOT-VALUE-SETTER-TREE OTREE))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-CALL-METHOD-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-CALL-METHOD-TREE (TREE)
  (CL:LET*
   ((OPERATOR NULL) (OWNER NULL) (ARGUMENTS NULL))
   (CL:MULTIPLE-VALUE-SETQ
    (OPERATOR OWNER ARGUMENTS)
    (DESTRUCTURE-CALL-TREE TREE))
   (CL:SETQ OWNER OWNER)
   (CL:WHEN
    (CL:OR
     (CL:EQ OPERATOR SYM-CL-TRANSLATE-NTH)
     (CL:EQ OPERATOR SYM-CL-TRANSLATE-NTH-SETTER))
    (CL:RETURN-FROM
     CL-TRANSLATE-CALL-METHOD-TREE
     (CL-TRANSLATE-NTH-TREE TREE)))
   (CL:WHEN
    (CL:NOT (CL:EQ (LOOKUP *CL-OPERATOR-TABLE* OPERATOR) NULL))
    (CL:RETURN-FROM
     CL-TRANSLATE-CALL-METHOD-TREE
     (CL-TRANSLATE-OPERATOR-TREE TREE)))
   (CL:RETURN-FROM
    CL-TRANSLATE-CALL-METHOD-TREE
    (CL-TRANSLATE-NORMAL-CALL-METHOD-TREE OPERATOR OWNER ARGUMENTS)))
  :VOID)

;;; (DEFUN (METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS SYMBOL) ...)

(CL:DEFUN METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS (SLOTNAME OWNER FUNCTION?)
  (CL:WHEN
   (CL:OR
    (CL:EQ FUNCTION? 1)
    (CL:EQ OWNER NULL)
    (CL:EQ SLOTNAME SYM-CL-TRANSLATE-NULL?)
    (CL:EQ SLOTNAME SYM-CL-TRANSLATE-DEFINED?)
    (CL:EQ (SYMBOL-COMMON-LISP? SLOTNAME) 1)
    (CL:EQ (USE-CL-STRUCTS?) 0)
    (CL:EQ (USE-VECTOR-STRUCTS?) 0))
   (CL:RETURN-FROM
    METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS
    SYM-CL-TRANSLATE-NORMAL-CALL))
  (CL:IF
   (CL:EQ (SUBTYPE-OF? OWNER SGT-CL-TRANSLATE-OBJECT) 0)
   (CL:RETURN-FROM
    METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS
    SYM-CL-TRANSLATE-NON-OBJECT-METHOD)
   (CL:IF
    (CL:EQ SLOTNAME SYM-CL-TRANSLATE-PRINT-OBJECT)
    (CL:RETURN-FROM
     METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS
     SYM-CL-TRANSLATE-PRINT-OBJECT)
    (CL:RETURN-FROM
     METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS
     SYM-CL-TRANSLATE-OBJECT-METHOD)))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-NORMAL-CALL-METHOD-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-NORMAL-CALL-METHOD-TREE (OPERATOR OWNER ARGUMENTS)
  (CL:LET*
   ((TRANSLATEDOPERATOR
     (CL-TRANSLATE-GLOBAL-SYMBOL
      (YIELD-RENAMED-NAME-IF-NATIVE
       OPERATOR
       KWD-CL-TRANSLATE-COMMON-LISP
       KWD-CL-TRANSLATE-FUNCTION))))
   (CL:LET*
    ((TEST-VALUE-001
      (METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS OPERATOR OWNER (NULL? OWNER))))
    (CL:COND
     ((CL:OR
       (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-OBJECT-METHOD)
       (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-PRINT-OBJECT))
      (CL:RETURN-FROM
       CL-TRANSLATE-NORMAL-CALL-METHOD-TREE
       (CONS
        (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-CLSYS-CALL)
        (CONS
         TRANSLATEDOPERATOR
         (CONCATENATE (CL-TRANSLATE-LIST-OF-TREES ARGUMENTS) NIL)))))
     ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-NON-OBJECT-METHOD)
      (CL:RETURN-FROM
       CL-TRANSLATE-NORMAL-CALL-METHOD-TREE
       (CONS
        TRANSLATEDOPERATOR
        (CONS
         (CL-TRANSLATE-A-TREE (FIRST ARGUMENTS))
         (CONS
          SYM-CL-TRANSLATE-NULL
          (CONCATENATE
           (CL-TRANSLATE-LIST-OF-TREES (CLSYS-SVAL CONS REST ARGUMENTS))
           NIL))))))
     (CL:T
      (CL:RETURN-FROM
       CL-TRANSLATE-NORMAL-CALL-METHOD-TREE
       (CONS
        TRANSLATEDOPERATOR
        (CONCATENATE (CL-TRANSLATE-LIST-OF-TREES ARGUMENTS) NIL)))))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-NTH-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-NTH-TREE (TREE)
  (CL:LET*
   ((OPERATOR NULL) (OWNER NULL) (ARGUMENTS NULL))
   (CL:MULTIPLE-VALUE-SETQ
    (OPERATOR OWNER ARGUMENTS)
    (DESTRUCTURE-CALL-TREE TREE))
   (CL:LET*
    ((SETTER? (EQ? OPERATOR SYM-CL-TRANSLATE-NTH-SETTER))
     (COLLECTION (FIRST ARGUMENTS))
     (POSITION (LAST ARGUMENTS))
     (VALUE (CL:IF (CL:EQ SETTER? 1) (SECOND ARGUMENTS) NULL)))
    (CL:COND
     ((CL:OR
       (CL:EQ OWNER SGT-CL-TRANSLATE-STRING)
       (CL:EQ OWNER SGT-CL-TRANSLATE-VECTOR))
      (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "CHAR"))
      (CL:WHEN
       (CL:EQ OWNER SGT-CL-TRANSLATE-VECTOR)
       (CL:SETQ
        COLLECTION
        (LIST*
         SYM-CL-TRANSLATE-SYS-SLOT-VALUE
         SGT-CL-TRANSLATE-VECTOR
         SYM-CL-TRANSLATE-THE-ARRAY
         COLLECTION
         NIL))
       (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "AREF")))
      (CL:SETQ
       TREE
       (CONS
        OPERATOR
        (CONS
         (CL-TRANSLATE-A-TREE COLLECTION)
         (CONS (CL-TRANSLATE-A-TREE POSITION) NIL))))
      (CL:WHEN
       (CL:EQ SETTER? 1)
       (CL:SETQ
        TREE
        (LIST*
         (INTERN-COMMON-LISP-SYMBOL "SETF")
         TREE
         (CONS (CL-TRANSLATE-A-TREE VALUE) NIL))))
      (CL:RETURN-FROM CL-TRANSLATE-NTH-TREE TREE))
     (CL:T NULL))
    (CL:RETURN-FROM
     CL-TRANSLATE-NTH-TREE
     (CL-TRANSLATE-NORMAL-CALL-METHOD-TREE OPERATOR OWNER ARGUMENTS))))
  :VOID)

;;; (DEFUN (DUPLICATE-CURSOR-VARIABLE? BOOLEAN) ...)

(CL:DEFUN DUPLICATE-CURSOR-VARIABLE? (VARIABLE ITERATORBINDINGS)
  (CL:LET*
   ((FOUND?-001 FALSE))
   (CL:LET*
    ((IB NULL) (ITER-001 ITERATORBINDINGS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ IB (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:EQ (FIRST IB) VARIABLE)
      (CL:SETQ FOUND?-001 TRUE)
      (CL:RETURN))))
   (CL:LET*
    ((VALUE-001 FOUND?-001))
    (CL:RETURN-FROM DUPLICATE-CURSOR-VARIABLE? VALUE-001)))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-FOREACH-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-FOREACH-TREE (TREE)
  (CL:LET*
   ((ITERATORBINDINGS (SECOND TREE))
    (CURSORBINDINGS (THIRD TREE))
    (CONTINUATIONTEST (CL-TRANSLATE-BOOLEAN-TEST (FOURTH TREE) FALSE))
    (BODY (CL-TRANSLATE-LIST-OF-TREES (NTH-REST TREE 4)))
    (DECLARATIONS NIL)
    (NEXTASSIGNMENTS NIL)
    (ITERATORCONSTRUCTOR NULL))
   (NTH-REST-SETTER TREE NIL 4)
   (FREE-CONS-LIST TREE)
   (CL:LET*
    ((BINDING NULL) (ITER-001 ITERATORBINDINGS) (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ BINDING (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:SETQ ITERATORCONSTRUCTOR (CL-TRANSLATE-A-TREE (THIRD BINDING)))
     (THIRD-SETTER BINDING NULL)
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ
        COLLECT-001
        (CONS
         (CONS
          (CL-TRANSLATE-ATOMIC-TREE (FIRST BINDING))
          (CONS ITERATORCONSTRUCTOR NIL))
         NIL))
       (CL:IF
        (CL:EQ DECLARATIONS NIL)
        (CL:SETQ DECLARATIONS COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST DECLARATIONS COLLECT-001)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-001)
        (CONS
         (CONS
          (CL-TRANSLATE-ATOMIC-TREE (FIRST BINDING))
          (CONS ITERATORCONSTRUCTOR NIL))
         NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:LET*
    ((BINDING NULL) (ITER-002 CURSORBINDINGS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ BINDING (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:SETQ
      NEXTASSIGNMENTS
      (CONS (CL-TRANSLATE-A-TREE (THIRD BINDING)) NEXTASSIGNMENTS))
     (THIRD-SETTER BINDING NULL)
     (CL:WHEN
      (CL:EQ (DUPLICATE-CURSOR-VARIABLE? (FIRST BINDING) ITERATORBINDINGS) 0)
      (CL:SETQ
       DECLARATIONS
       (CONS
        (CONS
         (CL-TRANSLATE-ATOMIC-TREE (FIRST BINDING))
         (CONS (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-NULL) NIL))
        DECLARATIONS)))))
   (FREE-CONS-TREE ITERATORBINDINGS)
   (FREE-CONS-TREE CURSORBINDINGS)
   (CL:RETURN-FROM
    CL-TRANSLATE-FOREACH-TREE
    (LIST*
     (INTERN-COMMON-LISP-SYMBOL "LET*")
     DECLARATIONS
     (CONS
      (LIST*
       (INTERN-COMMON-LISP-SYMBOL "LOOP")
       SYM-CL-TRANSLATE-WHILE
       CONTINUATIONTEST
       (CONS
        SYM-CL-TRANSLATE-DO
        (CONCATENATE
         (REVERSE NEXTASSIGNMENTS)
         (CONCATENATE (MAYBE-WRAP-WITH-CONTINUE-LABEL BODY) NIL))))
      NIL))))
  :VOID)

;;; (DEFUN (MAYBE-WRAP-WITH-CONTINUE-LABEL CONS) ...)

(CL:DEFUN MAYBE-WRAP-WITH-CONTINUE-LABEL (TRANSLATEDLOOPBODY)
  (CL:IF
   (CL:EQ (SEARCH-CONS-TREE? TRANSLATEDLOOPBODY KWD-CL-TRANSLATE-CONTINUE) 1)
   (CL:RETURN-FROM
    MAYBE-WRAP-WITH-CONTINUE-LABEL
    (CONS
     (CONS
      (INTERN-COMMON-LISP-SYMBOL "TAGBODY")
      (CONCATENATE TRANSLATEDLOOPBODY (CONS KWD-CL-TRANSLATE-CONTINUE NIL)))
     NIL))
   (CL:RETURN-FROM MAYBE-WRAP-WITH-CONTINUE-LABEL TRANSLATEDLOOPBODY))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-LET-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-LET-TREE (TREE)
  (CL:LET*
   ((ODECLARATIONS NIL))
   (CL:LET*
    ((D NULL) (ITER-001 (SECOND TREE)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ D (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (FREE-TRANSIENT-TYPE-SPEC (SECOND D))
     (CL:SETQ
      ODECLARATIONS
      (CONS
       (CONS
        (CL-TRANSLATE-ATOMIC-TREE (FIRST D))
        (CONS (CL-TRANSLATE-A-TREE (THIRD D)) NIL))
       ODECLARATIONS))
     (FREE-CONS-LIST D)))
   (FREE-CONS-LIST (SECOND TREE))
   (FIRST-SETTER TREE (INTERN-COMMON-LISP-SYMBOL "LET*"))
   (SECOND-SETTER TREE (REVERSE ODECLARATIONS))
   (CL:SETF
    (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))
    (CL-TRANSLATE-LIST-OF-TREES
     (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))
   (CL:RETURN-FROM CL-TRANSLATE-LET-TREE TREE))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-SPECIAL-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-SPECIAL-TREE (TREE)
  (CL:LET*
   ((TRANSLATEDTREE (CL-TRANSLATE-LET-TREE TREE)) (SPECIALVARS NIL))
   (CL:LET*
    ((DECL NULL) (ITER-001 (SECOND TREE)) (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ DECL (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (CONS (FIRST DECL) NIL))
       (CL:IF
        (CL:EQ SPECIALVARS NIL)
        (CL:SETQ SPECIALVARS COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST SPECIALVARS COLLECT-001)))
      (CL:PROGN
       (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS (FIRST DECL) NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:SETF
    (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TRANSLATEDTREE))
    (CONS
     (LIST*
      (INTERN-COMMON-LISP-SYMBOL "DECLARE")
      (CONS
       (INTERN-COMMON-LISP-SYMBOL "SPECIAL")
       (CONCATENATE SPECIALVARS NIL))
      NIL)
     (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TRANSLATEDTREE))))
   (CL:RETURN-FROM CL-TRANSLATE-SPECIAL-TREE TRANSLATEDTREE))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-STARTUP-TIME-PROGN-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-STARTUP-TIME-PROGN-TREE (TREE)
  (CL:SETF (CLSYS-SVAL CONS VALUE TREE) (INTERN-COMMON-LISP-SYMBOL "PROGN"))
  (CL:SETF
   (CLSYS-SVAL CONS REST TREE)
   (CL-TRANSLATE-LIST-OF-TREES (CLSYS-SVAL CONS REST TREE)))
  (CL:RETURN-FROM
   CL-TRANSLATE-STARTUP-TIME-PROGN-TREE
   (LIST*
    SYM-CL-TRANSLATE-EVAL-WHEN
    (LIST*
     (INTERN-COMMON-LISP-SYMBOL "LOAD")
     (INTERN-COMMON-LISP-SYMBOL "EVAL")
     NIL)
    TREE
    NIL))
  :VOID)

;;; (DEFUN (CAST OBJECT) ...)

(CL:DEFUN CAST (VALUE TYPE)
  "Perform a run-time type check, and then return 'value'."
  (CL:WHEN
   (CL:AND
    (CL:>= *SAFETY* 2)
    (CL:= *STARTUP-TIME-PHASE* 999)
    (CL:EQ (EMPTY? *UNFINALIZED-CLASSES*) 1))
   ()
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ VALUE NULL)) (CL:EQ (ISA? VALUE TYPE) 0))
    (CL:ERROR
     "Run-time casting violation.  The value: ~%`~A'~% is not of type `~A'."
     VALUE
     TYPE)))
  (CL:RETURN-FROM CAST VALUE)
  :VOID)

;;; (DEFUN (CL-TRANSLATE-CAST-TREE OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-CAST-TREE (TREE)
  (CL:LET*
   ((EXPRESSION (SECOND TREE)) (TYPE (THIRD TREE)))
   (SECOND-SETTER TREE (CL-TRANSLATE-A-TREE EXPRESSION))
   (THIRD-SETTER TREE (CL-TRANSLATE-A-TREE TYPE))
   (CL:WHEN
    (CL:OR
     (CL:< *SAFETY* 2)
     (CL:EQ (FIRST TREE) SYM-CL-TRANSLATE-SAFE-CAST)
     (CL:EQ
      (SAFE-LOOKUP-SLOT (TYPE-TO-CLASS TYPE) SYM-CL-TRANSLATE-PRIMARY-TYPE)
      NULL))
    (CL:SETQ EXPRESSION (SECOND TREE))
    (SECOND-SETTER TREE NIL)
    (FREE-CONS-TREE TREE)
    (CL:RETURN-FROM CL-TRANSLATE-CAST-TREE EXPRESSION))
   (FIRST-SETTER TREE (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-CAST))
   (CL:RETURN-FROM CL-TRANSLATE-CAST-TREE TREE))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-RETURN-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-RETURN-TREE (TREE)
  (CL:LET*
   ((RETURNVALUES (CL-TRANSLATE-LIST-OF-TREES (CLSYS-SVAL CONS REST TREE))))
   (CL:WHEN
    (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST RETURNVALUES) NIL))
    (CL:SETQ
     RETURNVALUES
     (CONS
      (CONS
       (INTERN-COMMON-LISP-SYMBOL "VALUES")
       (CONCATENATE RETURNVALUES NIL))
      NIL)))
   (FREE-CONS TREE)
   (CL:RETURN-FROM
    CL-TRANSLATE-RETURN-TREE
    (LIST*
     (INTERN-COMMON-LISP-SYMBOL "RETURN-FROM")
     (CL-TRANSLATE-GLOBAL-SYMBOL
      (YIELD-RENAMED-NAME-IF-NATIVE
       (CLSYS-SVAL
        METHOD-SLOT
        SLOT-NAME
        (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT *CURRENTTRANSLATIONUNIT*))
       KWD-CL-TRANSLATE-COMMON-LISP
       KWD-CL-TRANSLATE-FUNCTION))
     (CONCATENATE RETURNVALUES NIL))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-BOOLEAN-TEST CONS) ...)

(CL:DEFUN CL-TRANSLATE-BOOLEAN-TEST (TREE INVERT?)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:LET*
       ((TEST-VALUE-001 (FIRST TREE)))
       (CL:COND
        ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-NOT)
         (CL:LET*
          ((POSTREE (SECOND TREE)))
          (FREE-CONS-LIST TREE)
          (CL:RETURN-FROM
           CL-TRANSLATE-BOOLEAN-TEST
           (CL-TRANSLATE-BOOLEAN-TEST
            POSTREE
            (CL:IF (CL:EQ INVERT? 0) TRUE FALSE)))))
        ((CL:OR
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-AND)
          (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-OR))
         (CL:LET*
          ((CURSOR (CLSYS-SVAL CONS REST TREE)))
          (CL:LOOP
           WHILE
           (CL:NOT (CL:EQ CURSOR NIL))
           DO
           (CL:SETF
            (CLSYS-SVAL CONS VALUE CURSOR)
            (CL-TRANSLATE-BOOLEAN-TEST (CLSYS-SVAL CONS VALUE CURSOR) FALSE))
           (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR))))
         (CL:IF
          (CL:EQ (FIRST TREE) SYM-CL-TRANSLATE-AND)
          (FIRST-SETTER TREE (INTERN-COMMON-LISP-SYMBOL "AND"))
          (FIRST-SETTER TREE (INTERN-COMMON-LISP-SYMBOL "OR")))
         (CL:WHEN
          (CL:EQ INVERT? 1)
          (CL:SETQ TREE (LIST* (INTERN-COMMON-LISP-SYMBOL "NOT") TREE NIL)))
         (CL:RETURN-FROM CL-TRANSLATE-BOOLEAN-TEST TREE))
        (CL:T NULL)))))
    (CL:T NULL)))
  (CL:RETURN-FROM
   CL-TRANSLATE-BOOLEAN-TEST
   (CL-TRANSLATE-PLAIN-BOOLEAN-TEST TREE INVERT?))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-PLAIN-BOOLEAN-TEST CONS) ...)

(CL:DEFUN CL-TRANSLATE-PLAIN-BOOLEAN-TEST (TREE INVERT?)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:LET*
       ((OPERATOR NULL) (OWNER NULL) (ARGUMENTS NULL))
       (CL:MULTIPLE-VALUE-SETQ
        (OPERATOR OWNER ARGUMENTS)
        (DESTRUCTURE-CALL-TREE TREE))
       (CL:COND
        ((CL:OR
          (CL:EQ OPERATOR SYM-CL-TRANSLATE-<)
          (CL:EQ OPERATOR SYM-CL-TRANSLATE-<=)
          (CL:EQ OPERATOR SYM-CL-TRANSLATE-=)
          (CL:EQ OPERATOR SYM-CL-TRANSLATE->=)
          (CL:EQ OPERATOR SYM-CL-TRANSLATE->))
         (CL:WHEN
          (CL:EQ INVERT? 1)
          (CL:COND
           ((CL:EQ OPERATOR SYM-CL-TRANSLATE-<)
            (CL:SETQ OPERATOR SYM-CL-TRANSLATE->=))
           ((CL:EQ OPERATOR SYM-CL-TRANSLATE-<=)
            (CL:SETQ OPERATOR SYM-CL-TRANSLATE->))
           ((CL:EQ OPERATOR SYM-CL-TRANSLATE-=)
            (CL:SETQ OPERATOR SYM-CL-TRANSLATE-!/=))
           ((CL:EQ OPERATOR SYM-CL-TRANSLATE->=)
            (CL:SETQ OPERATOR SYM-CL-TRANSLATE-<))
           ((CL:EQ OPERATOR SYM-CL-TRANSLATE->)
            (CL:SETQ OPERATOR SYM-CL-TRANSLATE-<=))
           (CL:T (CL:ERROR "`~A' is not a valid case option" OPERATOR))))
         (CL:RETURN-FROM
          CL-TRANSLATE-PLAIN-BOOLEAN-TEST
          (CONS
           (LOOKUP *CL-OPERATOR-TABLE* OPERATOR)
           (CONCATENATE (CL-TRANSLATE-LIST-OF-TREES ARGUMENTS) NIL))))
        ((CL:EQ OPERATOR SYM-CL-TRANSLATE-EQ?)
         (CL:LET*
          ((ARGTYPE1 (WALKED-EXPRESSION-TYPE (FIRST ARGUMENTS)))
           (ARGTYPE2 (WALKED-EXPRESSION-TYPE (SECOND ARGUMENTS))))
          (CL:IF
           (CL:AND
            (CL:EQ (SUB-TYPE-SPEC-OF? ARGTYPE1 SGT-CL-TRANSLATE-LITERAL) 1)
            (CL:EQ (SUB-TYPE-SPEC-OF? ARGTYPE2 SGT-CL-TRANSLATE-LITERAL) 1))
           (CL:COND
            ((CL:EQ ARGTYPE1 SGT-CL-TRANSLATE-STRING)
             (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "EQ")))
            ((CL:OR
              (CL:EQ (SUB-TYPE-SPEC-OF? ARGTYPE1 SGT-CL-TRANSLATE-NUMBER) 1)
              (CL:EQ (SUB-TYPE-SPEC-OF? ARGTYPE1 SGT-CL-TRANSLATE-BOOLEAN) 1))
             (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "=")))
            (CL:T (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "EQL"))))
           (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "EQ")))
          (CL:SETQ TREE (CL-TRANSLATE-A-TREE TREE))
          (FIRST-SETTER TREE OPERATOR)
          (CL:IF
           (CL:EQ INVERT? 1)
           (CL:RETURN-FROM
            CL-TRANSLATE-PLAIN-BOOLEAN-TEST
            (LIST* (INTERN-COMMON-LISP-SYMBOL "NOT") TREE NIL))
           (CL:RETURN-FROM CL-TRANSLATE-PLAIN-BOOLEAN-TEST TREE))))
        ((CL:OR
          (CL:EQ OPERATOR SYM-CL-TRANSLATE-NULL?)
          (CL:EQ OPERATOR SYM-CL-TRANSLATE-DEFINED?))
         (CL:COND
          ((CL:OR
            (CL:EQ OWNER SGT-CL-TRANSLATE-OBJECT)
            (CL:EQ OWNER SGT-CL-TRANSLATE-STRING)
            (CL:EQ OWNER SGT-CL-TRANSLATE-CODE))
           (CL:SETQ
            TREE
            (LIST*
             (INTERN-COMMON-LISP-SYMBOL "EQ")
             (CL-TRANSLATE-A-TREE (FIRST ARGUMENTS))
             (CONS SYM-CL-TRANSLATE-NULL NIL)))
           (CL:IF
            (CL:OR
             (CL:AND
              (CL:EQ INVERT? 1)
              (CL:EQ OPERATOR SYM-CL-TRANSLATE-NULL?))
             (CL:AND
              (CL:EQ INVERT? 0)
              (CL:EQ OPERATOR SYM-CL-TRANSLATE-DEFINED?)))
            (CL:RETURN-FROM
             CL-TRANSLATE-PLAIN-BOOLEAN-TEST
             (LIST* (INTERN-COMMON-LISP-SYMBOL "NOT") TREE NIL))
            (CL:RETURN-FROM CL-TRANSLATE-PLAIN-BOOLEAN-TEST TREE)))
          (CL:T NULL)))
        ((CL:OR
          (CL:EQ OPERATOR SYM-CL-TRANSLATE-NIL?)
          (CL:EQ OPERATOR SYM-CL-TRANSLATE-EMPTY?)
          (CL:EQ OPERATOR SYM-CL-TRANSLATE-NON-EMPTY?))
         (CL:WHEN
          (CL:OR
           (CL:EQ OPERATOR SYM-CL-TRANSLATE-NIL?)
           (CL:EQ OWNER SGT-CL-TRANSLATE-CONS))
          (CL:SETQ
           TREE
           (LIST*
            (INTERN-COMMON-LISP-SYMBOL "EQ")
            (CL-TRANSLATE-A-TREE (FIRST ARGUMENTS))
            (CONS SYM-CL-TRANSLATE-NIL NIL)))
          (CL:IF
           (CL:OR
            (CL:AND
             (CL:EQ INVERT? 1)
             (CL:OR
              (CL:EQ OPERATOR SYM-CL-TRANSLATE-NIL?)
              (CL:EQ OPERATOR SYM-CL-TRANSLATE-EMPTY?)))
            (CL:AND
             (CL:EQ INVERT? 0)
             (CL:EQ OPERATOR SYM-CL-TRANSLATE-NON-EMPTY?)))
           (CL:RETURN-FROM
            CL-TRANSLATE-PLAIN-BOOLEAN-TEST
            (LIST* (INTERN-COMMON-LISP-SYMBOL "NOT") TREE NIL))
           (CL:RETURN-FROM CL-TRANSLATE-PLAIN-BOOLEAN-TEST TREE))))
        (CL:T NULL)))))
    (CL:T NULL)))
  (CL:SETQ TREE (CL-TRANSLATE-A-TREE TREE))
  (CL:IF
   (CL:EQ INVERT? 1)
   (CL:RETURN-FROM
    CL-TRANSLATE-PLAIN-BOOLEAN-TEST
    (LIST* (INTERN-COMMON-LISP-SYMBOL "EQ") TREE (CONS (WRAP-LITERAL 0) NIL)))
   (CL:RETURN-FROM
    CL-TRANSLATE-PLAIN-BOOLEAN-TEST
    (LIST* (INTERN-COMMON-LISP-SYMBOL "EQ") TREE (CONS (WRAP-LITERAL 1) NIL))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-WHILE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-WHILE-TREE (TREE)
  (CL:LET*
   ((TEST (CL-TRANSLATE-BOOLEAN-TEST (SECOND TREE) FALSE))
    (BODY
     (CL-TRANSLATE-LIST-OF-TREES
      (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))))
   (CL:SETF (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)) NIL)
   (FREE-CONS-LIST TREE)
   (CL:RETURN-FROM
    CL-TRANSLATE-WHILE-TREE
    (CL:IF
     (CL:EQ BODY NIL)
     (LIST*
      (INTERN-COMMON-LISP-SYMBOL "LOOP")
      SYM-CL-TRANSLATE-WHILE
      TEST
      NIL)
     (LIST*
      (INTERN-COMMON-LISP-SYMBOL "LOOP")
      SYM-CL-TRANSLATE-WHILE
      TEST
      (CONS
       SYM-CL-TRANSLATE-DO
       (CONCATENATE (MAYBE-WRAP-WITH-CONTINUE-LABEL BODY) NIL))))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-CONDITIONAL-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-CONDITIONAL-TREE (TREE)
  (CL:LET*
   ((OPERATOR (FIRST TREE))
    (TEST (SECOND TREE))
    (BODY
     (CL-TRANSLATE-LIST-OF-TREES
      (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))))
   (CL:SETF (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)) NIL)
   (FREE-CONS-LIST TREE)
   (CL:COND
    ((CL:OR
      (CL:EQ OPERATOR SYM-CL-TRANSLATE-IF)
      (CL:EQ OPERATOR SYM-CL-TRANSLATE-CHOOSE))
     (CL:RETURN-FROM
      CL-TRANSLATE-CONDITIONAL-TREE
      (LIST*
       (INTERN-COMMON-LISP-SYMBOL "IF")
       (CL-TRANSLATE-BOOLEAN-TEST TEST FALSE)
       (CONCATENATE BODY NIL))))
    ((CL:EQ OPERATOR SYM-CL-TRANSLATE-WHEN)
     (CL:RETURN-FROM
      CL-TRANSLATE-CONDITIONAL-TREE
      (LIST*
       (INTERN-COMMON-LISP-SYMBOL "WHEN")
       (CL-TRANSLATE-BOOLEAN-TEST TEST FALSE)
       (CONCATENATE BODY NIL))))
    ((CL:EQ OPERATOR SYM-CL-TRANSLATE-UNLESS)
     (CL:RETURN-FROM
      CL-TRANSLATE-CONDITIONAL-TREE
      (LIST*
       (INTERN-COMMON-LISP-SYMBOL "WHEN")
       (CL-TRANSLATE-BOOLEAN-TEST TEST TRUE)
       (CONCATENATE BODY NIL))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" OPERATOR))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-COND-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-COND-TREE (TREE)
  (CL:LET*
   ((CONDITION NULL) (ITER-001 (CLSYS-SVAL CONS REST TREE)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ CONDITION (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:IF
     (CL:EQ (CLSYS-SVAL CONS VALUE CONDITION) SYM-CL-TRANSLATE-OTHERWISE)
     (CL:SETF
      (CLSYS-SVAL CONS VALUE CONDITION)
      (INTERN-COMMON-LISP-SYMBOL "T"))
     (CL:SETF
      (CLSYS-SVAL CONS VALUE CONDITION)
      (CL-TRANSLATE-BOOLEAN-TEST (CLSYS-SVAL CONS VALUE CONDITION) FALSE)))
    (CL:SETF
     (CLSYS-SVAL CONS REST CONDITION)
     (CL-TRANSLATE-LIST-OF-TREES (CLSYS-SVAL CONS REST CONDITION)))))
  (CL:SETF (CLSYS-SVAL CONS VALUE TREE) (INTERN-COMMON-LISP-SYMBOL "COND"))
  (CL:RETURN-FROM CL-TRANSLATE-COND-TREE TREE)
  :VOID)

;;; (DEFUN (CL-TRANSLATE-CASE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-CASE-TREE (TREE)
  (CL:LET*
   ((OTHERWISE? FALSE))
   (SECOND-SETTER TREE (CL-TRANSLATE-A-TREE (SECOND TREE)))
   (CL:LET*
    ((COND NULL)
     (ITER-001 (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ COND (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:COND
      ((CL:EQ (FIRST COND) SYM-CL-TRANSLATE-OTHERWISE)
       (CL:SETQ OTHERWISE? TRUE)
       (FIRST-SETTER COND (INTERN-COMMON-LISP-SYMBOL "OTHERWISE")))
      ((CL:EQ (CONS? (FIRST COND)) 1)
       (FIRST-SETTER COND (CL-TRANSLATE-LIST-OF-TREES (FIRST COND))))
      (CL:T (FIRST-SETTER COND (CL-TRANSLATE-A-TREE (FIRST COND)))))
     (CL:SETF
      (CLSYS-SVAL CONS REST COND)
      (CL-TRANSLATE-LIST-OF-TREES (CLSYS-SVAL CONS REST COND)))))
   (FIRST-SETTER
    TREE
    (CL:IF
     (CL:EQ OTHERWISE? 1)
     (INTERN-COMMON-LISP-SYMBOL "CASE")
     (INTERN-COMMON-LISP-SYMBOL "ECASE")))
   (CL:RETURN-FROM CL-TRANSLATE-CASE-TREE TREE))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-BOOLEAN-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-BOOLEAN-TREE (TREE)
  (CL:SETQ TREE (CL-TRANSLATE-BOOLEAN-TEST TREE FALSE))
  (CL:RETURN-FROM
   CL-TRANSLATE-BOOLEAN-TREE
   (LIST*
    (INTERN-COMMON-LISP-SYMBOL "IF")
    TREE
    (LIST* SYM-CL-TRANSLATE-TRUE SYM-CL-TRANSLATE-FALSE NIL)))
  :VOID)

;;; (DEFUN (CLASS-TO-NATIVE-SYMBOL SYMBOL) ...)

(CL:DEFUN CLASS-TO-NATIVE-SYMBOL (CLASS)
  (CL:IF
   (CL:NOT
    (CL:EQ
     (CLSYS-SVAL
      STRING-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CL-TRANSLATE-CLASS-CL-NATIVE-TYPE
       NULL-STRING-WRAPPER))
     NULL))
   (CL:RETURN-FROM
    CLASS-TO-NATIVE-SYMBOL
    (INTERN-COMMON-LISP-SYMBOL
     (CLSYS-SVAL
      STRING-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CL-TRANSLATE-CLASS-CL-NATIVE-TYPE
       NULL-STRING-WRAPPER))))
   (CL:RETURN-FROM CLASS-TO-NATIVE-SYMBOL (CLASS-SYMBOL CLASS)))
  :VOID)

;;; (DEFUN (YIELD-STRUCT-CONSTRUCTOR-NAME OBJECT) ...)

(CL:DEFUN YIELD-STRUCT-CONSTRUCTOR-NAME (CLASS)
  (CL:RETURN-FROM
   YIELD-STRUCT-CONSTRUCTOR-NAME
   (YIELD-GLOBAL-LISP-SYMBOL
    (CLSYS-SVAL SURROGATE HOME-CONTEXT (CLSYS-SVAL CLASS CLASS-TYPE CLASS))
    (CONCATENATE
     "MAKE..."
     (CLSYS-SVAL SYMBOL SYMBOL-NAME (CLASS-TO-NATIVE-SYMBOL CLASS)))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-MAKE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-MAKE-TREE (TREE)
  (CL:LET*
   ((CLASS (CLSYS-SVAL SURROGATE SURROGATE-VALUE (TYPIFY (SECOND TREE))))
    (CLASSSYMBOL (CL-TRANSLATE-GLOBAL-SYMBOL (CLASS-TO-NATIVE-SYMBOL CLASS)))
    (OTREE NULL))
   (CL:IF
    (CL:EQ (USE-CL-STRUCTS?) 1)
    (CL:IF
     (CL:EQ (USE-VECTOR-STRUCTS?) 1)
     (CL:SETQ
      OTREE
      (CONS
       (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-CLSYS-MAKE)
       (CONS
        CLASSSYMBOL
        (CONS (WRAP-LITERAL (CL:1+ (LENGTH (CL-STRUCT-SLOTS CLASS)))) NIL))))
     (CL:SETQ OTREE (CONS (YIELD-STRUCT-CONSTRUCTOR-NAME CLASS) NIL)))
    (CL:SETQ
     OTREE
     (LIST*
      (INTERN-COMMON-LISP-SYMBOL "MAKE-INSTANCE")
      (LIST* (INTERN-COMMON-LISP-SYMBOL "QUOTE") CLASSSYMBOL NIL)
      NIL)))
   (FREE-CONS-LIST TREE)
   (CL:RETURN-FROM CL-TRANSLATE-MAKE-TREE OTREE))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-NEW-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-NEW-TREE (TREE)
  (CL:LET*
   ((TYPESPEC (SECOND TREE))
    (CONSTRUCTORNAME
     (CL-TRANSLATE-GLOBAL-SYMBOL
      (YIELD-CONSTRUCTOR-NAME
       (GET-CLASS
        (CL:IF
         (CL:EQ (TYPE? TYPESPEC) 1)
         TYPESPEC
         (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE TYPESPEC))
        TRUE))))
    (REQUIREDARGREFS
     (CL-TRANSLATE-LIST-OF-TREES
      (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))))
   (FREE-CONS (CLSYS-SVAL CONS REST TREE))
   (FREE-CONS TREE)
   (CL:RETURN-FROM
    CL-TRANSLATE-NEW-TREE
    (CONS CONSTRUCTORNAME (CONCATENATE REQUIREDARGREFS NIL))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-OPERATOR-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-OPERATOR-TREE (TREE)
  (CL:LET*
   ((OPERATOR NULL) (OWNER NULL) (ARGUMENTS NULL))
   (CL:MULTIPLE-VALUE-SETQ
    (OPERATOR OWNER ARGUMENTS)
    (DESTRUCTURE-CALL-TREE TREE))
   (CL:SETQ OWNER OWNER)
   (CL:COND
    ((CL:OR
      (CL:EQ OPERATOR SYM-CL-TRANSLATE-+)
      (CL:EQ OPERATOR SYM-CL-TRANSLATE--))
     (CL:WHEN
      (CL:AND
       (CL:= (LENGTH ARGUMENTS) 2)
       (CL:EQ (MEMBER? ARGUMENTS ONE-WRAPPER) 1))
      (CL:IF
       (CL:EQ (EQL? (FIRST ARGUMENTS) ONE-WRAPPER) 1)
       (CL:SETQ ARGUMENTS (CLSYS-SVAL CONS REST ARGUMENTS))
       (CL:SETF (CLSYS-SVAL CONS REST ARGUMENTS) NIL))
      (CL:IF
       (CL:EQ OPERATOR SYM-CL-TRANSLATE-+)
       (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "1+"))
       (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "1-")))))
    (CL:T NULL))
   (CL:COND
    ((CL:OR
      (CL:EQ OPERATOR SYM-CL-TRANSLATE-+)
      (CL:EQ OPERATOR SYM-CL-TRANSLATE--)
      (CL:EQ OPERATOR SYM-CL-TRANSLATE-*)
      (CL:EQ OPERATOR SYM-CL-TRANSLATE-/))
     (CL:SETQ OPERATOR (LOOKUP *CL-OPERATOR-TABLE* OPERATOR)))
    (CL:T NULL))
   (CL:RETURN-FROM
    CL-TRANSLATE-OPERATOR-TREE
    (CONS
     (CL-TRANSLATE-GLOBAL-SYMBOL OPERATOR)
     (CONCATENATE (CL-TRANSLATE-LIST-OF-TREES ARGUMENTS) NIL))))
  :VOID)

;;; (DEFUN (YIELD-FORMAT-ARGUMENTS CONS) ...)

(CL:DEFUN YIELD-FORMAT-ARGUMENTS (TREE)
  (CL:LET*
   ((FORMATSTRING "") (FORMATARGUMENTS NIL))
   (CL:SETF
    (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))
    (REVERSE (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))
   (CL:LET*
    ((ARG NULL) (ITER-001 (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:COND
      ((CL:EQ (STRING? ARG) 1)
       (CL:SETQ
        FORMATSTRING
        (CONCATENATE
         (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE ARG)
         FORMATSTRING)))
      ((CL:EQ ARG EOL) (CL:SETQ FORMATSTRING (CONCATENATE "~%" FORMATSTRING)))
      (CL:T
       (CL:SETQ FORMATSTRING (CONCATENATE "~A" FORMATSTRING))
       (CL:SETQ
        FORMATARGUMENTS
        (CONS (CL-TRANSLATE-A-TREE ARG) FORMATARGUMENTS))))))
   (CL:SETQ
    FORMATARGUMENTS
    (CONS (WRAP-LITERAL FORMATSTRING) FORMATARGUMENTS))
   (FREE-CONS-LIST TREE)
   (CL:RETURN-FROM YIELD-FORMAT-ARGUMENTS FORMATARGUMENTS))
  :VOID)

;;; (DEFUN (YIELD-PRINT-TREE CONS) ...)

(CL:DEFUN YIELD-PRINT-TREE (TREE)
  (CL:LET*
   ((STREAM (SECOND TREE))
    (ARGUMENTS (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
    (ARGUMENTTYPE NULL)
    (PRINTOPERATOR NULL)
    (COMPOUNDEDSTRING NULL)
    (PRINTFORMS NIL))
   (CL:SETQ STREAM (CL-TRANSLATE-A-TREE STREAM))
   (CL:LET*
    ((ARG NULL) (ITER-001 ARGUMENTS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:TAGBODY
      (CL:COND
       ((CL:EQ ARG EOL)
        (CL:SETQ
         PRINTFORMS
         (CONS
          (LIST*
           (INTERN-COMMON-LISP-SYMBOL "TERPRI")
           SYM-CL-TRANSLATE-%%STREAM
           NIL)
          PRINTFORMS))
        (CL:SETQ
         PRINTFORMS
         (CONS
          (LIST*
           (INTERN-COMMON-LISP-SYMBOL "FORCE-OUTPUT")
           SYM-CL-TRANSLATE-%%STREAM
           NIL)
          PRINTFORMS))
        (CL:SETQ COMPOUNDEDSTRING NULL))
       (CL:T
        (CL:SETQ
         ARGUMENTTYPE
         (TYPE-SPEC-TO-BASE-TYPE (WALKED-EXPRESSION-TYPE ARG)))
        (CL:COND
         ((CL:EQ ARGUMENTTYPE SGT-CL-TRANSLATE-STRING)
          (CL:SETQ PRINTOPERATOR (INTERN-COMMON-LISP-SYMBOL "WRITE-STRING")))
         (CL:T
          (CL:IF
           (CL:EQ (SUBTYPE-OF? ARGUMENTTYPE SGT-CL-TRANSLATE-OBJECT) 1)
           (CL:SETQ PRINTOPERATOR SYM-CL-TRANSLATE-PRINT-OBJECT)
           (CL:SETQ PRINTOPERATOR (INTERN-COMMON-LISP-SYMBOL "PRINC")))))
        (CL:LET*
         ((ARG-001 ARG))
         (CL:COND
          ((CL:EQ (STRING? ARG) 1)
           (CL:LET*
            ((ARG NULL))
            (CL:SETQ ARG ARG-001)
            (CL:WHEN
             (CL:NOT (CL:EQ COMPOUNDEDSTRING NULL))
             (CL:SETQ
              COMPOUNDEDSTRING
              (CONCATENATE
               COMPOUNDEDSTRING
               (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE ARG)))
             (SECOND-SETTER
              (FIRST PRINTFORMS)
              (WRAP-LITERAL COMPOUNDEDSTRING))
             (CL:GO :CONTINUE))
            (CL:SETQ
             COMPOUNDEDSTRING
             (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE ARG))))
          (CL:T (CL:SETQ COMPOUNDEDSTRING NULL))))
        (CL:LET*
         ((TEST-VALUE-001
           (METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS
            PRINTOPERATOR
            ARGUMENTTYPE
            (CL:IF
             (CL:NOT (CL:EQ PRINTOPERATOR SYM-CL-TRANSLATE-PRINT-OBJECT))
             TRUE
             FALSE))))
         (CL:COND
          ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-PRINT-OBJECT)
           (CL:SETQ
            PRINTFORMS
            (CONS
             (CL-TRANSLATE-NORMAL-CALL-METHOD-TREE
              SYM-CL-TRANSLATE-PRINT-OBJECT
              ARGUMENTTYPE
              (CONS ARG (CONS SYM-CL-TRANSLATE-%%STREAM NIL)))
             PRINTFORMS)))
          (CL:T
           (CL:SETQ
            PRINTFORMS
            (CONS
             (CONS
              PRINTOPERATOR
              (CONS
               (CL-TRANSLATE-A-TREE ARG)
               (CONS SYM-CL-TRANSLATE-%%STREAM NIL)))
             PRINTFORMS)))))))
      :CONTINUE)))
   (CL:SETQ PRINTFORMS (REVERSE PRINTFORMS))
   (CL:COND
    ((CL:AND (CL:EQ (CONS? STREAM) 1) (CL:> (LENGTH PRINTFORMS) 1))
     (CL:SETQ
      PRINTFORMS
      (LIST*
       (INTERN-COMMON-LISP-SYMBOL "LET")
       (CONS (LIST* SYM-CL-TRANSLATE-%%STREAM STREAM NIL) NIL)
       (CONCATENATE PRINTFORMS NIL))))
    (CL:T
     (CL:LET*
      ((PRINTFORM NULL) (ITER-002 PRINTFORMS))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-002 NIL))
       DO
       (CL:PROGN
        (CL:SETQ PRINTFORM (CLSYS-SVAL CONS VALUE ITER-002))
        (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
       (CL:SETF (CLSYS-SVAL CONS VALUE (LAST-CONS PRINTFORM)) STREAM)))
     (CL:IF
      (CL:> (LENGTH PRINTFORMS) 1)
      (CL:SETQ
       PRINTFORMS
       (CONS
        (INTERN-COMMON-LISP-SYMBOL "PROGN")
        (CONCATENATE PRINTFORMS NIL)))
      (CL:SETQ PRINTFORMS (FIRST PRINTFORMS)))))
   (FREE-CONS-LIST TREE)
   (CL:RETURN-FROM YIELD-PRINT-TREE PRINTFORMS))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-PRINT-STREAM-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-PRINT-STREAM-TREE (TREE)
  (CL:LET*
   ((STREAM (SECOND TREE)))
   (CL:COND
    ((CL:EQ STREAM KWD-CL-TRANSLATE-WARN)
     (CL:RETURN-FROM
      CL-TRANSLATE-PRINT-STREAM-TREE
      (CONS
       (INTERN-COMMON-LISP-SYMBOL "WARN")
       (CONCATENATE (YIELD-FORMAT-ARGUMENTS TREE) NIL))))
    ((CL:EQ STREAM KWD-CL-TRANSLATE-ERROR)
     (CL:RETURN-FROM
      CL-TRANSLATE-PRINT-STREAM-TREE
      (CONS
       (INTERN-COMMON-LISP-SYMBOL "ERROR")
       (CONCATENATE (YIELD-FORMAT-ARGUMENTS TREE) NIL))))
    ((CL:EQ STREAM KWD-CL-TRANSLATE-CONTINUABLE-ERROR)
     (CL:RETURN-FROM
      CL-TRANSLATE-PRINT-STREAM-TREE
      (LIST*
       (INTERN-COMMON-LISP-SYMBOL "CERROR")
       (WRAP-LITERAL "Continue anyway? ")
       (CONCATENATE (YIELD-FORMAT-ARGUMENTS TREE) NIL))))
    (CL:T
     (CL:RETURN-FROM CL-TRANSLATE-PRINT-STREAM-TREE (YIELD-PRINT-TREE TREE)))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-CALL-FUNCTION-CODE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-CALL-FUNCTION-CODE-TREE (TREE)
  (CL:LET*
   ((OTREE (CLSYS-SVAL CONS REST TREE)))
   (FREE-PARSE-TREE (SECOND TREE))
   (FREE-CONS TREE)
   (CL:SETF
    (CLSYS-SVAL CONS REST OTREE)
    (CL-TRANSLATE-LIST-OF-TREES (CLSYS-SVAL CONS REST OTREE)))
   (FIRST-SETTER OTREE (INTERN-COMMON-LISP-SYMBOL "FUNCALL"))
   (CL:RETURN-FROM CL-TRANSLATE-CALL-FUNCTION-CODE-TREE OTREE))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-THE-CODE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-THE-CODE-TREE (TREE)
  (CL:LET*
   ((NAME
     (CL:IF
      (CL:EQ (SECOND TREE) KWD-CL-TRANSLATE-FUNCTION)
      (THIRD TREE)
      (FOURTH TREE))))
   (FREE-CONS-LIST TREE)
   (CL:RETURN-FROM
    CL-TRANSLATE-THE-CODE-TREE
    (LIST*
     (INTERN-COMMON-LISP-SYMBOL "FUNCTION")
     (CL-TRANSLATE-GLOBAL-SYMBOL
      (YIELD-RENAMED-NAME-IF-NATIVE
       NAME
       KWD-CL-TRANSLATE-COMMON-LISP
       KWD-CL-TRANSLATE-FUNCTION))
     NIL)))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-VERBATIM-TREE OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-VERBATIM-TREE (TREE)
  (CL:LET*
   ((CURSOR (CLSYS-SVAL CONS REST TREE)) (VERBATIMCODE NULL))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL CONS VALUE CURSOR) KWD-CL-TRANSLATE-COMMON-LISP)
     (CL:SETQ
      VERBATIMCODE
      (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST CURSOR)))
     (CL:SETF (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST CURSOR)) NULL)
     (CL:RETURN))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST CURSOR))))
   (FREE-CONS-TREE TREE)
   (CL:RETURN-FROM CL-TRANSLATE-VERBATIM-TREE VERBATIMCODE))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-INLINE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-INLINE-TREE (TREE)
  (CL:LET*
   ((OPERATOR (FIRST TREE))
    (BODY (CL-TRANSLATE-LIST-OF-TREES (CLSYS-SVAL CONS REST TREE))))
   (FREE-CONS TREE)
   (CL:COND
    ((CL:EQ OPERATOR SYM-CL-TRANSLATE-INLINE)
     (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "INLINE")))
    ((CL:EQ OPERATOR SYM-CL-TRANSLATE-IGNORE)
     (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "IGNORE")))
    (CL:T (CL:ERROR "`~A' is not a valid case option" OPERATOR)))
   (CL:RETURN-FROM
    CL-TRANSLATE-INLINE-TREE
    (LIST*
     (INTERN-COMMON-LISP-SYMBOL "DECLARE")
     (CONS OPERATOR (CONCATENATE BODY NIL))
     NIL)))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-UNIT OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-UNIT (UNIT)
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL TRANSLATION-UNIT CATEGORY UNIT)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-GLOBAL-VARIABLE)
     (CL:RETURN-FROM
      CL-TRANSLATE-UNIT
      (CL-TRANSLATE-DEFINE-GLOBAL-VARIABLE-UNIT UNIT)))
    ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-CLASS)
     (CL:RETURN-FROM
      CL-TRANSLATE-UNIT
      (CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT UNIT)))
    ((CL:OR
      (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-METHOD)
      (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-MACRO))
     (CL:RETURN-FROM
      CL-TRANSLATE-UNIT
      (CL-TRANSLATE-DEFINE-METHOD-UNIT UNIT)))
    ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-PRINT-METHOD)
     (CL:RETURN-FROM CL-TRANSLATE-UNIT (CL-TRANSLATE-DEFPRINT-UNIT UNIT)))
    ((CL:OR
      (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-STARTUP-TIME-PROGN)
      (CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-VERBATIM))
     (CL:RETURN-FROM
      CL-TRANSLATE-UNIT
      (CL-TRANSLATE-A-TREE (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT))))
    ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-TYPE)
     (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CATEGORY UNIT) NULL)
     (CL:RETURN-FROM CL-TRANSLATE-UNIT NIL))
    (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-METHOD-PARAMETERS CONS) ...)

(CL:DEFUN CL-TRANSLATE-METHOD-PARAMETERS (METHOD)
  (CL:LET*
   ((FUNCTION? (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? METHOD))
    (OTREE NIL)
    (FIRSTPARAMETERTYPE NULL))
   (CL:LET*
    ((I NULL)
     (PTYPE NULL)
     (PARAMETER NULL)
     (ITER-001
      (CLSYS-SVAL LIST THE-CONS-LIST (METHOD-PARAMETER-NAMES METHOD)))
     (ITER-002
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD)))
     (ITER-003 1))
    (CL:LOOP
     WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL)))
     DO
     (CL:PROGN
      (CL:SETQ PARAMETER (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:PROGN
      (CL:SETQ PTYPE (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
     (CL:COND
      ((CL:AND (CL:EQ FUNCTION? 0) (CL:= I 1))
       (CL:SETQ
        FIRSTPARAMETERTYPE
        (CL-TRANSLATE-GLOBAL-SYMBOL
         (CLASS-TO-NATIVE-SYMBOL
          (TYPE-TO-CLASS (TYPE-SPEC-TO-BASE-TYPE PTYPE)))))
       (CL:LET*
        ((TEST-VALUE-001
          (METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS
           (CLSYS-SVAL METHOD-SLOT SLOT-NAME METHOD)
           (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD)
           FUNCTION?)))
        (CL:COND
         ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-OBJECT-METHOD)
          (CL:SETQ
           OTREE
           (CONS
            (LIST* SYM-CL-TRANSLATE-CLSYS-SELF FIRSTPARAMETERTYPE NIL)
            OTREE))
          (CL:SETQ OTREE (CONS PARAMETER OTREE)))
         ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-NON-OBJECT-METHOD)
          (CL:SETQ
           OTREE
           (CONS (CONS PARAMETER (CONS FIRSTPARAMETERTYPE NIL)) OTREE))
          (CL:SETQ OTREE (CONS SYM-CL-TRANSLATE-CLSYS-DUMMY OTREE)))
         (CL:T
          (CL:SETQ
           OTREE
           (CONS (CONS PARAMETER (CONS FIRSTPARAMETERTYPE NIL)) OTREE))))))
      (CL:T (CL:SETQ OTREE (CONS PARAMETER OTREE))))))
   (CL:WHEN
    (CL:AND
     (CL:EQ (METHOD-VARIABLE-ARGUMENTS? METHOD) 1)
     (CL:EQ (PASS-VARIABLE-ARGUMENTS-AS-LIST? METHOD) 0))
    (CL:SETF
     (CLSYS-SVAL CONS REST OTREE)
     (CONS
      (INTERN-COMMON-LISP-SYMBOL "&REST")
      (CONCATENATE (CLSYS-SVAL CONS REST OTREE) NIL))))
   (CL:RETURN-FROM CL-TRANSLATE-METHOD-PARAMETERS (REVERSE OTREE)))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-DEFINE-METHOD-UNIT CONS) ...)

(CL:DEFUN CL-TRANSLATE-DEFINE-METHOD-UNIT (UNIT)
  (CL:LET*
   ((METHOD (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT))
    (METHODNAME (CLSYS-SVAL METHOD-SLOT SLOT-NAME METHOD))
    (DOCUMENTATION
     (CLSYS-SVAL
      STRING-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       METHOD
       SYM-CL-TRANSLATE-DOCUMENTATION
       NULL-STRING-WRAPPER)))
    (FUNCTION? (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? METHOD))
    (BODYTREE (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT))
    (EXTRATREES NIL)
    (OTREE NIL))
   (CL:LET*
    ((TEST-VALUE-001
      (METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS
       METHODNAME
       (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD)
       FUNCTION?)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-PRINT-OBJECT)
      (CL:SETQ
       EXTRATREES
       (CONS
        (LIST*
         SYM-CL-TRANSLATE-SETQ
         SYM-CL-TRANSLATE-SELF
         (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-*CLSYS-SELF*)
         NIL)
        NIL)))
     ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-NON-OBJECT-METHOD)
      (CL:SETQ
       EXTRATREES
       (CONS
        (LIST*
         (INTERN-COMMON-LISP-SYMBOL "DECLARE")
         (LIST*
          (INTERN-COMMON-LISP-SYMBOL "IGNORE")
          SYM-CL-TRANSLATE-CLSYS-DUMMY
          NIL)
         NIL)
        NIL)))
     (CL:T NULL)))
   (CL:SETQ
    OTREE
    (CONS
     (CL:IF
      (CL:EQ FUNCTION? 1)
      (INTERN-COMMON-LISP-SYMBOL "DEFUN")
      (INTERN-COMMON-LISP-SYMBOL "DEFMETHOD"))
     (CONS
      (CL-TRANSLATE-GLOBAL-SYMBOL
       (YIELD-RENAMED-NAME-IF-NATIVE
        METHODNAME
        KWD-CL-TRANSLATE-COMMON-LISP
        KWD-CL-TRANSLATE-FUNCTION))
      (CONS
       (CL-TRANSLATE-METHOD-PARAMETERS METHOD)
       (CONCATENATE
        (CL:IF
         (CL:NOT (CL:EQ DOCUMENTATION NULL))
         (CONS (WRAP-LITERAL DOCUMENTATION) NIL)
         NIL)
        (CONCATENATE
         EXTRATREES
         (CONCATENATE
          (CL-TRANSLATE-LIST-OF-TREES BODYTREE)
          (CONS KWD-CL-TRANSLATE-VOID NIL))))))))
   (CL:WHEN (CL:EQ (METHOD-AUXILIARY? METHOD) 1) (FREE METHOD))
   (CL:RETURN-FROM CL-TRANSLATE-DEFINE-METHOD-UNIT OTREE))
  :VOID)

;;; (DEFUN (YIELD-CLOS-SLOT-TREE CONS) ...)

(CL:DEFUN YIELD-CLOS-SLOT-TREE (SLOT)
  (CL:LET*
   ((SLOTNAME
     (TRUE-SLOT-NAME
      (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT)
      (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SLOT)))
    (ALLOCATION (ALLOCATION SLOT))
    (ALLOCATIONFORM NIL)
    (DOCUMENTATION
     (CLSYS-SVAL
      STRING-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SLOT
       SYM-CL-TRANSLATE-DOCUMENTATION
       NULL-STRING-WRAPPER)))
    (DOCUMENTATIONFORM NIL))
   (CL:COND
    ((CL:EQ ALLOCATION KWD-CL-TRANSLATE-EMBEDDED)
     (CL:SETQ ALLOCATION KWD-CL-TRANSLATE-INSTANCE))
    (CL:T NULL))
   (CL:WHEN
    (CL:NOT (CL:EQ ALLOCATION NULL))
    (CL:SETQ
     ALLOCATIONFORM
     (LIST* KWD-CL-TRANSLATE-ALLOCATION ALLOCATION NIL)))
   (CL:WHEN
    (CL:NOT (CL:EQ DOCUMENTATION NULL))
    (CL:SETQ
     DOCUMENTATIONFORM
     (LIST* KWD-CL-TRANSLATE-DOCUMENTATION (WRAP-LITERAL DOCUMENTATION) NIL)))
   (CL:RETURN-FROM
    YIELD-CLOS-SLOT-TREE
    (CONS
     (CL-TRANSLATE-GLOBAL-SYMBOL SLOTNAME)
     (CONCATENATE
      DOCUMENTATIONFORM
      (CONCATENATE
       ALLOCATIONFORM
       (LIST*
        KWD-CL-TRANSLATE-ACCESSOR
        (YIELD-CLOS-SLOT-ACCESSOR-NAME SLOTNAME)
        NIL))))))
  :VOID)

;;; (DEFUN (YIELD-CLOS-CLASS-TREE CONS) ...)

(CL:DEFUN YIELD-CLOS-CLASS-TREE (CLASS)
  (CL:LET*
   ((DIRECTSUPERS NIL)
    (CLOSSLOTDEFS NIL)
    (DOCUMENTATION
     (CLSYS-SVAL
      STRING-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CL-TRANSLATE-DOCUMENTATION
       NULL-STRING-WRAPPER))))
   (CL:LET*
    ((SUPER NULL) (ITER-001 (CLASS-NATIVE-SUPERS CLASS)) (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ SUPER (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ
        COLLECT-001
        (CONS (CL-TRANSLATE-GLOBAL-SYMBOL (TYPE-TO-SYMBOL SUPER)) NIL))
       (CL:IF
        (CL:EQ DIRECTSUPERS NIL)
        (CL:SETQ DIRECTSUPERS COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST DIRECTSUPERS COLLECT-001)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-001)
        (CONS (CL-TRANSLATE-GLOBAL-SYMBOL (TYPE-TO-SYMBOL SUPER)) NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:LET*
    ((SLOT NULL) (ITER-002 (CLASS-SLOTS CLASS)) (COLLECT-002 NULL))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-002) 1)
     DO
     (CL:PROGN (CL:SETQ SLOT (CLSYS-SVAL ITERATOR VALUE ITER-002)))
     (CL:TAGBODY
      (CL:WHEN
       (CL:AND (CL:EQ (STORAGE-SLOT? SLOT) 1) (CL:EQ (NATIVE-SLOT? SLOT) 1))
       (CL:WHEN
        (CL:NOT (CL:EQ (NATIVE-SLOT-HOME SLOT CLASS) CLASS))
        (CL:WHEN
         (CL:AND
          (CL:NOT (CL:EQ (CLSYS-SVAL SLOT SLOT-BASE-TYPE SLOT) NULL))
          (CL:EQ
           (CLSYS-SVAL
            SURROGATE
            SURROGATE-VALUE
            (CLSYS-SVAL SLOT SLOT-BASE-TYPE SLOT))
           NULL))
         (CL:WARN
          "Can't generate a native slot named `~A' for the class `~A'~% because the slot's :type `~A' is undefined."
          (CLSYS-SVAL SLOT SLOT-NAME SLOT)
          (CLASS-NAME CLASS)
          (CLSYS-SVAL SLOT SLOT-BASE-TYPE SLOT)))
        (CL:GO :CONTINUE))
       (CL:IF
        (CL:EQ COLLECT-002 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-002 (CONS (YIELD-CLOS-SLOT-TREE SLOT) NIL))
         (CL:IF
          (CL:EQ CLOSSLOTDEFS NIL)
          (CL:SETQ CLOSSLOTDEFS COLLECT-002)
          (ADD-CONS-TO-END-OF-CONS-LIST CLOSSLOTDEFS COLLECT-002)))
        (CL:PROGN
         (CL:SETF
          (CLSYS-SVAL CONS REST COLLECT-002)
          (CONS (YIELD-CLOS-SLOT-TREE SLOT) NIL))
         (CL:SETQ COLLECT-002 (CLSYS-SVAL CONS REST COLLECT-002)))))
      :CONTINUE)))
   (CL:RETURN-FROM
    YIELD-CLOS-CLASS-TREE
    (LIST*
     (INTERN-COMMON-LISP-SYMBOL "DEFCLASS")
     (CL-TRANSLATE-GLOBAL-SYMBOL (CLASS-SYMBOL CLASS))
     (CONS
      DIRECTSUPERS
      (CONS
       CLOSSLOTDEFS
       (CONCATENATE
        (CL:IF
         (CL:NOT (CL:EQ DOCUMENTATION NULL))
         (CONS
          (LIST*
           KWD-CL-TRANSLATE-DOCUMENTATION
           (WRAP-LITERAL DOCUMENTATION)
           NIL)
          NIL)
         NIL)
        NIL))))))
  :VOID)

;;; (DEFUN (COMPUTE-CL-STRUCT-SLOTS (LIST OF STORAGE-SLOT)) ...)

(CL:DEFUN COMPUTE-CL-STRUCT-SLOTS (CLASS)
  (CL:LET*
   ((VALUE-001 NULL))
   (CL:LET*
    ((SUPER NULL) (ITER-001 (CLASS-NATIVE-SUPERS CLASS)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ SUPER (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:WHEN
      (CL:EQ
       (CLSYS-SVAL CLASS MIXIN? (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPER))
       0)
      (CL:SETQ VALUE-001 SUPER)
      (CL:RETURN))))
   (CL:LET*
    ((REALSUPER VALUE-001)
     (RESULT
      (CL:IF
       (CL:NOT (CL:EQ REALSUPER NULL))
       (COMPUTE-CL-STRUCT-SLOTS
        (CLSYS-SVAL SURROGATE SURROGATE-VALUE REALSUPER))
       NULL)))
    (CL:WHEN (CL:EQ RESULT NULL) (CL:SETQ RESULT (NEW-LIST)))
    (CL:LET*
     ((SUPER NULL) (ITER-002 (CLASS-NATIVE-SUPERS CLASS)))
     (CL:LOOP
      WHILE
      (CL:EQ (NEXT? ITER-002) 1)
      DO
      (CL:PROGN (CL:SETQ SUPER (CLSYS-SVAL ITERATOR VALUE ITER-002)))
      (CL:WHEN
       (CL:NOT (CL:EQ SUPER REALSUPER))
       (CL:LET*
        ((SLOT NULL)
         (ITER-003 (CLASS-SLOTS (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPER)))
         (COLLECT-001 NULL))
        (CL:LOOP
         WHILE
         (CL:EQ (NEXT? ITER-003) 1)
         DO
         (CL:PROGN (CL:SETQ SLOT (CLSYS-SVAL ITERATOR VALUE ITER-003)))
         (CL:WHEN
          (CL:AND
           (CL:EQ (STORAGE-SLOT? SLOT) 1)
           (CL:EQ (NATIVE-SLOT? SLOT) 1))
          (CL:IF
           (CL:EQ COLLECT-001 NULL)
           (CL:PROGN
            (CL:SETQ COLLECT-001 (PERMANENT-CONS SLOT NIL))
            (CL:IF
             (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST RESULT) NIL)
             (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST RESULT) COLLECT-001)
             (ADD-CONS-TO-END-OF-CONS-LIST
              (CLSYS-SVAL LIST THE-CONS-LIST RESULT)
              COLLECT-001)))
           (CL:PROGN
            (CL:SETF
             (CLSYS-SVAL CONS REST COLLECT-001)
             (PERMANENT-CONS SLOT NIL))
            (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))))))
    (CL:LET*
     ((SLOT NULL)
      (ITER-004
       (CLSYS-SVAL
        LIST
        THE-CONS-LIST
        (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS CLASS)))
      (COLLECT-002 NULL))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-004 NIL))
      DO
      (CL:PROGN
       (CL:SETQ SLOT (CLSYS-SVAL CONS VALUE ITER-004))
       (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
      (CL:WHEN
       (CL:AND (CL:EQ (STORAGE-SLOT? SLOT) 1) (CL:EQ (NATIVE-SLOT? SLOT) 1))
       (CL:IF
        (CL:EQ COLLECT-002 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-002 (PERMANENT-CONS SLOT NIL))
         (CL:IF
          (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST RESULT) NIL)
          (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST RESULT) COLLECT-002)
          (ADD-CONS-TO-END-OF-CONS-LIST
           (CLSYS-SVAL LIST THE-CONS-LIST RESULT)
           COLLECT-002)))
        (CL:PROGN
         (CL:SETF
          (CLSYS-SVAL CONS REST COLLECT-002)
          (PERMANENT-CONS SLOT NIL))
         (CL:SETQ COLLECT-002 (CLSYS-SVAL CONS REST COLLECT-002)))))))
    (CL:RETURN-FROM COMPUTE-CL-STRUCT-SLOTS RESULT)))
  :VOID)

;;; (DEFUN (CL-STRUCT-SLOTS (LIST OF STORAGE-SLOT)) ...)

(CL:DEFUN CL-STRUCT-SLOTS (CLASS)
  (CL:LET*
   ((SLOTS (CLASS-CL-STRUCT-SLOTS CLASS)))
   (CL:IF
    (CL:EQ (DEFINED-LIST? SLOTS) 1)
    (CL:RETURN-FROM CL-STRUCT-SLOTS SLOTS)
    (CL:RETURN-FROM
     CL-STRUCT-SLOTS
     (SET-DYNAMIC-SLOT-VALUE
      CLASS
      SYM-CL-TRANSLATE-CLASS-CL-STRUCT-SLOTS
      (COMPUTE-CL-STRUCT-SLOTS CLASS)
      NULL))))
  :VOID)

;;; (DEFUN (CL-STRUCT-SLOT-OFFSET INTEGER) ...)

(CL:DEFUN CL-STRUCT-SLOT-OFFSET (SLOTNAME CLASSTYPE)
  (CL:LET*
   ((SLOTS (CL-STRUCT-SLOTS (CLSYS-SVAL SURROGATE SURROGATE-VALUE CLASSTYPE)))
    (OFFSET 1))
   (CL:LET*
    ((SLOT NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST SLOTS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SLOT (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT) SLOTNAME)
      (CL:RETURN-FROM CL-STRUCT-SLOT-OFFSET OFFSET)
      (CL:SETQ OFFSET (CL:1+ OFFSET)))))
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING " Can't find slot `" %%STREAM)
      (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE SLOTNAME) %%STREAM)
      (CL:WRITE-STRING "' on CL-struct class `" %%STREAM)
      (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE CLASSTYPE) %%STREAM)
      (CL:WRITE-STRING "'." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))))
   (CL:RETURN-FROM CL-STRUCT-SLOT-OFFSET NULL-INTEGER))
  :VOID)

;;; (DEFUN (YIELD-STRUCT-SLOT-TREES CONS) ...)

(CL:DEFUN YIELD-STRUCT-SLOT-TREES (CLASS)
  (CL:LET*
   ((STRUCTSLOTDEFS NIL))
   (CL:LET*
    ((SLOT NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST (CL-STRUCT-SLOTS CLASS)))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SLOT (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:TAGBODY
      (CL:WHEN
       (CL:NOT (CL:EQ (MIXIN-SLOT-HOME SLOT CLASS) CLASS))
       (CL:WHEN
        (CL:AND
         (CL:NOT (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SLOT) NULL))
         (CL:EQ
          (CLSYS-SVAL
           SURROGATE
           SURROGATE-VALUE
           (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SLOT))
          NULL))
        (CL:WARN
         "Can't generate a native slot named `~A' for the class `~A'~% because the slot's :type `~A' is undefined."
         (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT)
         (CLASS-NAME CLASS)
         (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SLOT)))
       (CL:GO :CONTINUE))
      (CL:IF
       (CL:EQ COLLECT-001 NULL)
       (CL:PROGN
        (CL:SETQ
         COLLECT-001
         (CONS
          (CONS
           (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT)
           (CONS SYM-CL-TRANSLATE-NULL NIL))
          NIL))
        (CL:IF
         (CL:EQ STRUCTSLOTDEFS NIL)
         (CL:SETQ STRUCTSLOTDEFS COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST STRUCTSLOTDEFS COLLECT-001)))
       (CL:PROGN
        (CL:SETF
         (CLSYS-SVAL CONS REST COLLECT-001)
         (CONS
          (CONS
           (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT)
           (CONS SYM-CL-TRANSLATE-NULL NIL))
          NIL))
        (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))
      :CONTINUE)))
   (CL:RETURN-FROM YIELD-STRUCT-SLOT-TREES STRUCTSLOTDEFS))
  :VOID)

;;; (DEFUN (YIELD-STRUCT-TREE CONS) ...)

(CL:DEFUN YIELD-STRUCT-TREE (CLASS)
  (CL:LET*
   ((VALUE-001 NULL))
   (CL:LET*
    ((SUPER NULL) (ITER-001 (CLASS-NATIVE-SUPERS CLASS)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ SUPER (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:WHEN
      (CL:EQ
       (CLSYS-SVAL CLASS MIXIN? (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPER))
       0)
      (CL:SETQ VALUE-001 SUPER)
      (CL:RETURN))))
   (CL:LET*
    ((SUPER VALUE-001)
     (DOCUMENTATION
      (CLSYS-SVAL
       STRING-WRAPPER
       WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE
        CLASS
        SYM-CL-TRANSLATE-DOCUMENTATION
        NULL-STRING-WRAPPER))))
    (CL:RETURN-FROM
     YIELD-STRUCT-TREE
     (LIST*
      (INTERN-COMMON-LISP-SYMBOL "DEFSTRUCT")
      (CONS
       (CL-TRANSLATE-GLOBAL-SYMBOL (CLASS-SYMBOL CLASS))
       (LIST*
        (LIST*
         KWD-CL-TRANSLATE-CONC-NAME
         (YIELD-GLOBAL-LISP-SYMBOL
          (CLSYS-SVAL
           SURROGATE
           HOME-CONTEXT
           (CLSYS-SVAL CLASS CLASS-TYPE CLASS))
          (CONCATENATE (CLASS-NAME CLASS) "..."))
         NIL)
        (LIST*
         KWD-CL-TRANSLATE-CONSTRUCTOR
         (YIELD-STRUCT-CONSTRUCTOR-NAME CLASS)
         (CONS NIL NIL))
        (CONCATENATE
         (CL:IF
          (CL:NOT (CL:EQ SUPER NULL))
          (CONS
           (LIST*
            KWD-CL-TRANSLATE-INCLUDE
            (CL-TRANSLATE-GLOBAL-SYMBOL (TYPE-TO-SYMBOL SUPER))
            NIL)
           NIL)
          NIL)
         NIL)))
      (CONCATENATE
       (CL:IF
        (CL:NOT (CL:EQ DOCUMENTATION NULL))
        (CONS (WRAP-LITERAL DOCUMENTATION) NIL)
        NIL)
       (CONCATENATE (YIELD-STRUCT-SLOT-TREES CLASS) NIL))))))
  :VOID)

;;; (DEFUN (YIELD-VECTOR-STRUCT-NAME OBJECT) ...)

(CL:DEFUN YIELD-VECTOR-STRUCT-NAME (CLASS)
  (CL:RETURN-FROM
   YIELD-VECTOR-STRUCT-NAME
   (YIELD-GLOBAL-LISP-SYMBOL
    (CLSYS-SVAL SURROGATE HOME-CONTEXT (CLSYS-SVAL CLASS CLASS-TYPE CLASS))
    (CONCATENATE "CLSYS-" (CLASS-NAME CLASS))))
  :VOID)

;;; (DEFUN (YIELD-VECTOR-STRUCT-TREE CONS) ...)

(CL:DEFUN YIELD-VECTOR-STRUCT-TREE (CLASS)
  (CL:LET*
   ((VALUE-001 NULL))
   (CL:LET*
    ((SUPER NULL) (ITER-001 (CLASS-NATIVE-SUPERS CLASS)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ SUPER (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:WHEN
      (CL:EQ
       (CLSYS-SVAL CLASS MIXIN? (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPER))
       0)
      (CL:SETQ VALUE-001 SUPER)
      (CL:RETURN))))
   (CL:LET*
    ((SUPER VALUE-001)
     (DOCUMENTATION
      (CLSYS-SVAL
       STRING-WRAPPER
       WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE
        CLASS
        SYM-CL-TRANSLATE-DOCUMENTATION
        NULL-STRING-WRAPPER))))
    (CL:RETURN-FROM
     YIELD-VECTOR-STRUCT-TREE
     (LIST*
      (INTERN-COMMON-LISP-SYMBOL "DEFCLASS")
      (CL-TRANSLATE-GLOBAL-SYMBOL (CLASS-SYMBOL CLASS))
      (CONS
       (CL:IF
        (CL:NOT (CL:EQ SUPER NULL))
        (CONS (CL-TRANSLATE-GLOBAL-SYMBOL (TYPE-TO-SYMBOL SUPER)) NIL)
        NIL)
       (CONS
        NIL
        (CONCATENATE
         (CL:IF
          (CL:NOT (CL:EQ DOCUMENTATION NULL))
          (CONS
           (LIST*
            KWD-CL-TRANSLATE-DOCUMENTATION
            (WRAP-LITERAL DOCUMENTATION)
            NIL)
           NIL)
          NIL)
         NIL)))))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT CONS) ...)

(CL:DEFUN CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT (UNIT)
  (CL:LET*
   ((CLASS (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT)))
   (CL:IF
    (CL:EQ (USE-CL-STRUCTS?) 1)
    (CL:IF
     (CL:EQ (USE-VECTOR-STRUCTS?) 1)
     (CL:RETURN-FROM
      CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT
      (YIELD-VECTOR-STRUCT-TREE CLASS))
     (CL:RETURN-FROM
      CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT
      (YIELD-STRUCT-TREE CLASS)))
    (CL:RETURN-FROM
     CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT
     (YIELD-CLOS-CLASS-TREE CLASS))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-DEFINE-GLOBAL-VARIABLE-UNIT CONS) ...)

(CL:DEFUN CL-TRANSLATE-DEFINE-GLOBAL-VARIABLE-UNIT (UNIT)
  (CL:LET*
   ((GLOBAL (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT))
    (NAME
     (CL-TRANSLATE-GLOBAL-SYMBOL
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME GLOBAL)))
    (DOCUMENTATION (CLSYS-SVAL GLOBAL-VARIABLE DOCUMENTATION GLOBAL))
    (UNBOUNDSPECIAL?
     (CL:IF
      (CL:AND
       (CL:EQ (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SPECIAL? GLOBAL) 1)
       (CL:EQ
        (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT)
        KWD-CL-TRANSLATE-UNBOUND-SPECIAL-VARIABLE))
      TRUE
      FALSE))
    (INITIALVALUETREE
     (CL-TRANSLATE-A-TREE (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT)))
    (OPERATOR (INTERN-COMMON-LISP-SYMBOL "DEFVAR")))
   (CL:WHEN
    (CL:AND
     (CL:EQ (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-CONSTANT? GLOBAL) 1)
     (CL:EQ FALSE 1))
    (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "DEFCONSTANT")))
   (CL:RETURN-FROM
    CL-TRANSLATE-DEFINE-GLOBAL-VARIABLE-UNIT
    (CL:IF
     (CL:EQ UNBOUNDSPECIAL? 1)
     (LIST* (INTERN-COMMON-LISP-SYMBOL "DEFVAR") NAME NIL)
     (CONS
      OPERATOR
      (CONS
       NAME
       (CONS
        INITIALVALUETREE
        (CONCATENATE
         (CL:IF
          (CL:NOT (CL:EQ DOCUMENTATION NULL))
          (CONS (WRAP-LITERAL DOCUMENTATION) NIL)
          NIL)
         NIL)))))))
  :VOID)

;;; (DEFUN (CL-TRANSLATE-DEFPRINT-UNIT CONS) ...)

(CL:DEFUN CL-TRANSLATE-DEFPRINT-UNIT (UNIT)
  (CL:LET*
   ((CLASS (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT))
    (BODY (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT))
    (EXTRATREES NIL))
   (CL:LET*
    ((TEST-VALUE-001
      (METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS
       SYM-CL-TRANSLATE-PRINT-OBJECT
       (CLSYS-SVAL CLASS CLASS-TYPE CLASS)
       FALSE)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 SYM-CL-TRANSLATE-PRINT-OBJECT)
      (CL:SETQ
       EXTRATREES
       (CONS
        (LIST*
         SYM-CL-TRANSLATE-SETQ
         SYM-CL-TRANSLATE-SELF
         (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-*CLSYS-SELF*)
         NIL)
        NIL)))
     (CL:T NULL)))
   (CL:RETURN-FROM
    CL-TRANSLATE-DEFPRINT-UNIT
    (LIST*
     (INTERN-COMMON-LISP-SYMBOL "DEFMETHOD")
     SYM-CL-TRANSLATE-PRINT-OBJECT
     (LIST*
      (LIST* SYM-CL-TRANSLATE-SELF (CLASS-SYMBOL CLASS) NIL)
      SYM-CL-TRANSLATE-STREAM
      NIL)
     (CONCATENATE EXTRATREES (CONS (CL-TRANSLATE-A-TREE BODY) NIL)))))
  :VOID)

(CL:DEFUN STARTUP-CL-TRANSLATE ()
  (CL:WHEN
   (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 0) 1)
   (CL:WHEN
    (CLSYS-USE-VECTOR-STRUCTS-P)
    (CL:DEFMETHOD
     PRINT-OBJECT
     :AROUND
     ((SELF CL:VECTOR) STREAM)
     (CL:IF
      (CLSYS-VECTOR-STRUCT-P SELF)
      (CLSYS-PRINT-VECTOR-STRUCT SELF STREAM)
      (CL:CALL-NEXT-METHOD)))))
  (CL:LET*
   ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SYM-CL-TRANSLATE-SYS-CALL-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-FUNCTION" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-SYS-CALL-METHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-METHOD" NULL 0))
    (CL:SETQ
     SGT-CL-TRANSLATE-KEY-VALUE-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-VALUE-LIST" NULL 1))
    (CL:SETQ SYM-CL-TRANSLATE-+ (INTERN-RIGID-SYMBOL-WRT-MODULE "+" NULL 0))
    (CL:SETQ SYM-CL-TRANSLATE-- (INTERN-RIGID-SYMBOL-WRT-MODULE "-" NULL 0))
    (CL:SETQ SYM-CL-TRANSLATE-* (INTERN-RIGID-SYMBOL-WRT-MODULE "*" NULL 0))
    (CL:SETQ SYM-CL-TRANSLATE-/ (INTERN-RIGID-SYMBOL-WRT-MODULE "/" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-EQ?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EQ?" NULL 0))
    (CL:SETQ SYM-CL-TRANSLATE-< (INTERN-RIGID-SYMBOL-WRT-MODULE "<" NULL 0))
    (CL:SETQ SYM-CL-TRANSLATE-<= (INTERN-RIGID-SYMBOL-WRT-MODULE "<=" NULL 0))
    (CL:SETQ SYM-CL-TRANSLATE->= (INTERN-RIGID-SYMBOL-WRT-MODULE ">=" NULL 0))
    (CL:SETQ SYM-CL-TRANSLATE-> (INTERN-RIGID-SYMBOL-WRT-MODULE ">" NULL 0))
    (CL:SETQ SYM-CL-TRANSLATE-= (INTERN-RIGID-SYMBOL-WRT-MODULE "=" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-!/=
     (INTERN-RIGID-SYMBOL-WRT-MODULE "!/=" NULL 0))
    (CL:SETQ
     KWD-CL-TRANSLATE-USE-COMMON-LISP-STRUCTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-STRUCTS" NULL 2))
    (CL:SETQ
     KWD-CL-TRANSLATE-USE-COMMON-LISP-VECTOR-STRUCTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-VECTOR-STRUCTS" NULL 2))
    (CL:SETQ
     SGT-CL-TRANSLATE-VOID
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" NULL 1))
    (CL:SETQ
     SYM-CL-TRANSLATE-VOID-SYS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID-SYS" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-TYPED-SYS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPED-SYS" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-BAD-SYS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BAD-SYS" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-SETQ
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-SYS-SLOT-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-SLOT-VALUE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-SYS-SLOT-VALUE-SETTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-SLOT-VALUE-SETTER" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-PROGN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROGN" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-LOOP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOP" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-SYS-FOREACH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-FOREACH" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-LET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LET" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-STARTUP-TIME-PROGN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-TIME-PROGN" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-SPECIAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIAL" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-CAST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CAST" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-SAFE-CAST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SAFE-CAST" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-RETURN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-BREAK
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BREAK" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-CONTINUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-WHILE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WHILE" NULL 0))
    (CL:SETQ SYM-CL-TRANSLATE-IF (INTERN-RIGID-SYMBOL-WRT-MODULE "IF" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-CHOOSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CHOOSE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-WHEN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-UNLESS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNLESS" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-AND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 0))
    (CL:SETQ SYM-CL-TRANSLATE-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-NOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-COND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COND" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-CASE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CASE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-MAKE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MAKE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-SYS-NEW
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-NEW" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-MV-SETQ
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MV-SETQ" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-QUOTE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "QUOTE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-SYS-CALL-FUNCTION-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-FUNCTION-CODE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-SYS-CALL-METHOD-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-METHOD-CODE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-THE-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-CODE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-PRINT-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-STREAM" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-PRINT-NATIVE-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-NATIVE-STREAM" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-VERBATIM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBATIM" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-INLINE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-IGNORE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IGNORE" NULL 0))
    (CL:SETQ
     KWD-CL-TRANSLATE-CONTINUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUE" NULL 2))
    (CL:SETQ
     SYM-CL-TRANSLATE-GET-KWD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-KWD" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-GET-SGT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-SGT" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-CLSYS-SVAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLSYS-SVAL" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-NTH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NTH" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-NTH-SETTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NTH-SETTER" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-NULL?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL?" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-DEFINED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-NORMAL-CALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NORMAL-CALL" NULL 0))
    (CL:SETQ
     SGT-CL-TRANSLATE-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 1))
    (CL:SETQ
     SYM-CL-TRANSLATE-NON-OBJECT-METHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NON-OBJECT-METHOD" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-PRINT-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-OBJECT" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-OBJECT-METHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-METHOD" NULL 0))
    (CL:SETQ
     KWD-CL-TRANSLATE-COMMON-LISP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
    (CL:SETQ
     KWD-CL-TRANSLATE-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     SYM-CL-TRANSLATE-CLSYS-CALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLSYS-CALL" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-NULL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
    (CL:SETQ
     SGT-CL-TRANSLATE-STRING
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 1))
    (CL:SETQ
     SGT-CL-TRANSLATE-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" NULL 1))
    (CL:SETQ
     SYM-CL-TRANSLATE-THE-ARRAY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-ARRAY" NULL 0))
    (CL:SETQ SYM-CL-TRANSLATE-DO (INTERN-RIGID-SYMBOL-WRT-MODULE "DO" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-EVAL-WHEN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EVAL-WHEN" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-PRIMARY-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMARY-TYPE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-NIL?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NIL?" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-EMPTY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EMPTY?" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-NON-EMPTY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NON-EMPTY?" NULL 0))
    (CL:SETQ
     SGT-CL-TRANSLATE-LITERAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL" NULL 1))
    (CL:SETQ
     SGT-CL-TRANSLATE-NUMBER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER" NULL 1))
    (CL:SETQ
     SGT-CL-TRANSLATE-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
    (CL:SETQ
     SGT-CL-TRANSLATE-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CODE" NULL 1))
    (CL:SETQ
     SGT-CL-TRANSLATE-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
    (CL:SETQ
     SYM-CL-TRANSLATE-NIL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NIL" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-OTHERWISE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHERWISE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-TRUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-FALSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-CLASS-CL-NATIVE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CL-NATIVE-TYPE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-CLSYS-MAKE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLSYS-MAKE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-%%STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "%%STREAM" NULL 0))
    (CL:SETQ
     KWD-CL-TRANSLATE-WARN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN" NULL 2))
    (CL:SETQ
     KWD-CL-TRANSLATE-ERROR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
    (CL:SETQ
     KWD-CL-TRANSLATE-CONTINUABLE-ERROR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUABLE-ERROR" NULL 2))
    (CL:SETQ
     SYM-CL-TRANSLATE-GLOBAL-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBAL-VARIABLE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-METHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-MACRO
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MACRO" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-PRINT-METHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-METHOD" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-CLSYS-SELF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLSYS-SELF" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-CLSYS-DUMMY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLSYS-DUMMY" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-SELF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SELF" NULL 0))
    (CL:SETQ
     SYM-CL-TRANSLATE-*CLSYS-SELF*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*CLSYS-SELF*" NULL 0))
    (CL:SETQ
     KWD-CL-TRANSLATE-VOID
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" NULL 2))
    (CL:SETQ
     KWD-CL-TRANSLATE-EMBEDDED
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EMBEDDED" NULL 2))
    (CL:SETQ
     KWD-CL-TRANSLATE-INSTANCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INSTANCE" NULL 2))
    (CL:SETQ
     KWD-CL-TRANSLATE-ALLOCATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOCATION" NULL 2))
    (CL:SETQ
     KWD-CL-TRANSLATE-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
    (CL:SETQ
     KWD-CL-TRANSLATE-ACCESSOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ACCESSOR" NULL 2))
    (CL:SETQ
     SYM-CL-TRANSLATE-CLASS-CL-STRUCT-SLOTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CL-STRUCT-SLOTS" NULL 0))
    (CL:SETQ
     KWD-CL-TRANSLATE-CONC-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONC-NAME" NULL 2))
    (CL:SETQ
     KWD-CL-TRANSLATE-CONSTRUCTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTRUCTOR" NULL 2))
    (CL:SETQ
     KWD-CL-TRANSLATE-INCLUDE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INCLUDE" NULL 2))
    (CL:SETQ
     KWD-CL-TRANSLATE-UNBOUND-SPECIAL-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBOUND-SPECIAL-VARIABLE" NULL 2))
    (CL:SETQ
     SYM-CL-TRANSLATE-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STREAM" NULL 0)))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTRUCTURE-CALL-TREE"
        "CONS"
        "(DEFUN (DESTRUCTURE-CALL-TREE SYMBOL TYPE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESTRUCTURE-CALL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "USE-CL-STRUCTS?"
        NULL
        "(DEFUN (USE-CL-STRUCTS? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION USE-CL-STRUCTS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "USE-VECTOR-STRUCTS?"
        NULL
        "(DEFUN (USE-VECTOR-STRUCTS? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION USE-VECTOR-STRUCTS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-LIST-OF-TREES"
        "CONS"
        "(DEFUN (CL-TRANSLATE-LIST-OF-TREES CONS) ((TREES CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-LIST-OF-TREES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-VOID-SYS"
        "CONS"
        "(DEFUN (CL-TRANSLATE-VOID-SYS CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-VOID-SYS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-TYPED-SYS"
        "CONS"
        "(DEFUN (CL-TRANSLATE-TYPED-SYS OBJECT) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-TYPED-SYS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-BAD-SYS"
        "CONS"
        "(DEFUN (CL-TRANSLATE-BAD-SYS OBJECT) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-BAD-SYS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-A-TREE"
        "OBJECT"
        "(DEFUN (CL-TRANSLATE-A-TREE OBJECT) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-A-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-CL-TRANSLATE-A-TREE"
        "OBJECT"
        "(DEFUN (HELP-CL-TRANSLATE-A-TREE OBJECT) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-CL-TRANSLATE-A-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-ATOMIC-TREE"
        "OBJECT"
        "(DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-ATOMIC-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-ATOMIC-TREE"
        "SYMBOL"
        "(DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ((TREE SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-ATOMIC-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-ATOMIC-TREE"
        "KEYWORD"
        "(DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ((TREE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-ATOMIC-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-ATOMIC-TREE"
        "SURROGATE"
        "(DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ((TREE SURROGATE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-ATOMIC-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-GLOBAL-SYMBOL"
        "SYMBOL"
        "(DEFUN (CL-TRANSLATE-GLOBAL-SYMBOL OBJECT) ((SYMBOL SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-GLOBAL-SYMBOL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-GLOBAL-LISP-SYMBOL"
        "MODULE"
        "(DEFUN (YIELD-GLOBAL-LISP-SYMBOL OBJECT) ((SYMBOLMODULE MODULE) (SYMBOLNAME STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-GLOBAL-LISP-SYMBOL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-SETQ-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-SETQ-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-SETQ-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-STRUCT-SLOT-ACCESSOR-NAME"
        "TYPE"
        "(DEFUN (YIELD-STRUCT-SLOT-ACCESSOR-NAME OBJECT) ((CLASSTYPE TYPE) (SLOTNAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-STRUCT-SLOT-ACCESSOR-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-CLOS-SLOT-ACCESSOR-NAME"
        "SYMBOL"
        "(DEFUN (YIELD-CLOS-SLOT-ACCESSOR-NAME OBJECT) ((SLOTNAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-CLOS-SLOT-ACCESSOR-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-SLOT-VALUE-READER-TREE"
        "SYMBOL"
        "(DEFUN (YIELD-SLOT-VALUE-READER-TREE CONS) ((SLOTNAME SYMBOL) (OBJECTREF OBJECT) (OBJECTTYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-SLOT-VALUE-READER-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-SLOT-VALUE-WRITER-TREE"
        "SYMBOL"
        "(DEFUN (YIELD-SLOT-VALUE-WRITER-TREE CONS) ((SLOTNAME SYMBOL) (OBJECTREF OBJECT) (OBJECTTYPE TYPE) (VALUEREF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-SLOT-VALUE-WRITER-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRUE-SLOT-NAME"
        "SYMBOL"
        "(DEFUN (TRUE-SLOT-NAME SYMBOL) ((SLOTNAME SYMBOL) (TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRUE-SLOT-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-FIXED-SLOT-VALUE-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-FIXED-SLOT-VALUE-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-FIXED-SLOT-VALUE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-FIXED-SLOT-VALUE-SETTER-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-FIXED-SLOT-VALUE-SETTER-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-FIXED-SLOT-VALUE-SETTER-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-CALL-METHOD-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-CALL-METHOD-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-CALL-METHOD-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS"
        "SYMBOL"
        "(DEFUN (METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS SYMBOL) ((SLOTNAME SYMBOL) (OWNER TYPE) (FUNCTION? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-NORMAL-CALL-METHOD-TREE"
        "SYMBOL"
        "(DEFUN (CL-TRANSLATE-NORMAL-CALL-METHOD-TREE CONS) ((OPERATOR SYMBOL) (OWNER TYPE) (ARGUMENTS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-NORMAL-CALL-METHOD-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-NTH-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-NTH-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-NTH-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DUPLICATE-CURSOR-VARIABLE?"
        "SYMBOL"
        "(DEFUN (DUPLICATE-CURSOR-VARIABLE? BOOLEAN) ((VARIABLE SYMBOL) (ITERATORBINDINGS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DUPLICATE-CURSOR-VARIABLE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-FOREACH-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-FOREACH-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-FOREACH-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MAYBE-WRAP-WITH-CONTINUE-LABEL"
        "CONS"
        "(DEFUN (MAYBE-WRAP-WITH-CONTINUE-LABEL CONS) ((TRANSLATEDLOOPBODY CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MAYBE-WRAP-WITH-CONTINUE-LABEL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-LET-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-LET-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-LET-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-SPECIAL-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-SPECIAL-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-SPECIAL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-STARTUP-TIME-PROGN-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-STARTUP-TIME-PROGN-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-STARTUP-TIME-PROGN-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CAST"
        "OBJECT"
        "(DEFUN (CAST OBJECT) ((VALUE OBJECT) (TYPE TYPE)) :DOCUMENTATION \"Perform a run-time type check, and then return 'value'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CAST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-CAST-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-CAST-TREE OBJECT) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-CAST-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-RETURN-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-RETURN-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-RETURN-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-BOOLEAN-TEST"
        "OBJECT"
        "(DEFUN (CL-TRANSLATE-BOOLEAN-TEST CONS) ((TREE OBJECT) (INVERT? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-BOOLEAN-TEST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-PLAIN-BOOLEAN-TEST"
        "OBJECT"
        "(DEFUN (CL-TRANSLATE-PLAIN-BOOLEAN-TEST CONS) ((TREE OBJECT) (INVERT? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-PLAIN-BOOLEAN-TEST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-WHILE-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-WHILE-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-WHILE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-CONDITIONAL-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-CONDITIONAL-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-CONDITIONAL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-COND-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-COND-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-COND-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-CASE-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-CASE-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-CASE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-BOOLEAN-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-BOOLEAN-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-BOOLEAN-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASS-TO-NATIVE-SYMBOL"
        "CLASS"
        "(DEFUN (CLASS-TO-NATIVE-SYMBOL SYMBOL) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASS-TO-NATIVE-SYMBOL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-STRUCT-CONSTRUCTOR-NAME"
        "CLASS"
        "(DEFUN (YIELD-STRUCT-CONSTRUCTOR-NAME OBJECT) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-STRUCT-CONSTRUCTOR-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-MAKE-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-MAKE-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-MAKE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-NEW-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-NEW-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-NEW-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-OPERATOR-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-OPERATOR-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-OPERATOR-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-FORMAT-ARGUMENTS"
        "CONS"
        "(DEFUN (YIELD-FORMAT-ARGUMENTS CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-FORMAT-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-PRINT-TREE"
        "CONS"
        "(DEFUN (YIELD-PRINT-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-PRINT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-PRINT-STREAM-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-PRINT-STREAM-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-PRINT-STREAM-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-CALL-FUNCTION-CODE-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-CALL-FUNCTION-CODE-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-CALL-FUNCTION-CODE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-THE-CODE-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-THE-CODE-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-THE-CODE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-VERBATIM-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-VERBATIM-TREE OBJECT) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-VERBATIM-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-INLINE-TREE"
        "CONS"
        "(DEFUN (CL-TRANSLATE-INLINE-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-INLINE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN (CL-TRANSLATE-UNIT OBJECT) ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-METHOD-PARAMETERS"
        "METHOD-SLOT"
        "(DEFUN (CL-TRANSLATE-METHOD-PARAMETERS CONS) ((METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-METHOD-PARAMETERS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-DEFINE-METHOD-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN (CL-TRANSLATE-DEFINE-METHOD-UNIT CONS) ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-DEFINE-METHOD-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-CLOS-SLOT-TREE"
        "STORAGE-SLOT"
        "(DEFUN (YIELD-CLOS-SLOT-TREE CONS) ((SLOT STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-CLOS-SLOT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-CLOS-CLASS-TREE"
        "CLASS"
        "(DEFUN (YIELD-CLOS-CLASS-TREE CONS) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-CLOS-CLASS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-CL-STRUCT-SLOTS"
        "CLASS"
        "(DEFUN (COMPUTE-CL-STRUCT-SLOTS (LIST OF STORAGE-SLOT)) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-CL-STRUCT-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-STRUCT-SLOTS"
        "CLASS"
        "(DEFUN (CL-STRUCT-SLOTS (LIST OF STORAGE-SLOT)) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-STRUCT-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-STRUCT-SLOT-OFFSET"
        "SYMBOL"
        "(DEFUN (CL-STRUCT-SLOT-OFFSET INTEGER) ((SLOTNAME SYMBOL) (CLASSTYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-STRUCT-SLOT-OFFSET)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-STRUCT-SLOT-TREES"
        "CLASS"
        "(DEFUN (YIELD-STRUCT-SLOT-TREES CONS) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-STRUCT-SLOT-TREES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-STRUCT-TREE"
        "CLASS"
        "(DEFUN (YIELD-STRUCT-TREE CONS) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-STRUCT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-VECTOR-STRUCT-NAME"
        "CLASS"
        "(DEFUN (YIELD-VECTOR-STRUCT-NAME OBJECT) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-VECTOR-STRUCT-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-VECTOR-STRUCT-TREE"
        "CLASS"
        "(DEFUN (YIELD-VECTOR-STRUCT-TREE CONS) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-VECTOR-STRUCT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN (CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT CONS) ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-DEFINE-GLOBAL-VARIABLE-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN (CL-TRANSLATE-DEFINE-GLOBAL-VARIABLE-UNIT CONS) ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-DEFINE-GLOBAL-VARIABLE-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CL-TRANSLATE-DEFPRINT-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN (CL-TRANSLATE-DEFPRINT-UNIT CONS) ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CL-TRANSLATE-DEFPRINT-UNIT)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-CL-TRANSLATE"
     NULL
     "(DEFUN STARTUP-CL-TRANSLATE ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CL-OPERATOR-TABLE* KEY-VALUE-LIST NULL :DOCUMENTATION \"Mapping from STELLA operators to Common-Lisp operators.\")")
    (CL:SETQ
     *CL-OPERATOR-TABLE*
     (DICTIONARY
      SGT-CL-TRANSLATE-KEY-VALUE-LIST
      SYM-CL-TRANSLATE-+
      (INTERN-COMMON-LISP-SYMBOL "+")
      SYM-CL-TRANSLATE--
      (INTERN-COMMON-LISP-SYMBOL "-")
      SYM-CL-TRANSLATE-*
      (INTERN-COMMON-LISP-SYMBOL "*")
      SYM-CL-TRANSLATE-/
      (INTERN-COMMON-LISP-SYMBOL "/")
      SYM-CL-TRANSLATE-EQ?
      (INTERN-COMMON-LISP-SYMBOL "EQL")
      SYM-CL-TRANSLATE-<
      (INTERN-COMMON-LISP-SYMBOL "<")
      SYM-CL-TRANSLATE-<=
      (INTERN-COMMON-LISP-SYMBOL "<=")
      SYM-CL-TRANSLATE->=
      (INTERN-COMMON-LISP-SYMBOL ">=")
      SYM-CL-TRANSLATE->
      (INTERN-COMMON-LISP-SYMBOL ">")
      SYM-CL-TRANSLATE-=
      (INTERN-COMMON-LISP-SYMBOL "=")
      SYM-CL-TRANSLATE-!/=
      (INTERN-COMMON-LISP-SYMBOL "/=")))
    (CL:WHEN
     (CLSYS-USE-STRUCTS-P)
     (ENABLE-ENVIRONMENT-FEATURE (INTERN-KEYWORD "USE-COMMON-LISP-STRUCTS"))
     (CL:WHEN
      (CLSYS-USE-VECTOR-STRUCTS-P)
      (ENABLE-ENVIRONMENT-FEATURE
       (INTERN-KEYWORD "USE-COMMON-LISP-VECTOR-STRUCTS"))))))
  :VOID)
