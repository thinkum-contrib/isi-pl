;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-LISTS-ABSTRACT-DICTIONARY-ITERATOR NULL)
(CL:DEFVAR SYM-LISTS-KEY NULL)
(CL:DEFVAR SYM-LISTS-KEY-SETTER NULL)
(CL:DEFVAR SYM-LISTS-SLOT-WRITER NULL)
(CL:DEFVAR SGT-LISTS-ABSTRACT-ITERATOR NULL)
(CL:DEFVAR SYM-LISTS-VALUE NULL)
(CL:DEFVAR SYM-LISTS-VALUE-SETTER NULL)
(CL:DEFVAR SYM-LISTS-DELETED-OBJECT? NULL)
(CL:DEFVAR SGT-LISTS-LIST NULL)
(CL:DEFVAR SGT-LISTS-KEY-VALUE-LIST NULL)
(CL:DEFVAR SGT-LISTS-PROPERTY-LIST NULL)

;;; Forward declarations:

(CL:DECLAIM (CL:SPECIAL *STELLA-MODULE* *MODULE* NULL-BOOLEAN-WRAPPER))

;;; (DEFGLOBAL NIL-LIST ...)

(CL:DEFVAR NIL-LIST NULL)

;;; (DEFUN (DEFINED-LIST? BOOLEAN) ...)

(CL:DEFUN DEFINED-LIST? (SELF)
  "Return TRUE unless 'self' is NULL or the 'NIL-LIST'."
  (CL:RETURN-FROM
   DEFINED-LIST?
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ SELF NIL-LIST)) (CL:NOT (CL:EQ SELF NULL)))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (NULL-LIST? BOOLEAN) ...)

(CL:DEFUN NULL-LIST? (SELF)
  "Return TRUE iff 'self' is NULL or the 'NIL-LIST'."
  (CL:RETURN-FROM
   NULL-LIST?
   (CL:IF (CL:OR (CL:EQ SELF NIL-LIST) (CL:EQ SELF NULL)) TRUE FALSE))
  :VOID)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF LIST))
  "Return TRUE if the list 'self' has no members."
  (CL:RETURN-FROM EMPTY? (EMPTY? (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF LIST))
  "Return TRUE if the list 'self' has at least one member."
  (CL:RETURN-FROM NON-EMPTY? (NON-EMPTY? (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFUN (TERMINATE-LIST? BOOLEAN) ...)

(CL:DEFUN TERMINATE-LIST? (SELF)
  (CL:WHEN
   (CL:EQ SELF NIL-LIST)
   (CL:WHEN
    (CL:EQ SELF NIL-LIST)
    (CL:ERROR "Safety violation: Attempt to free NIL-LIST."))
   (CL:RETURN-FROM TERMINATE-LIST? FALSE))
  (CL:LET*
   ((CONS (CLSYS-SVAL LIST THE-CONS-LIST SELF)) (REST NULL))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CONS NIL))
    DO
    (CL:SETQ REST (CLSYS-SVAL CONS REST CONS))
    (FREE CONS)
    (CL:SETQ CONS REST))
   (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM TERMINATE-LIST? TRUE))
  :VOID)

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF LIST) OBJECT)
  "Return TRUE iff 'object' is a member of the list 'self'.
 Uses an 'eql?' test."
  (CL:LET*
   ((I NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ I (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN (CL:EQ (EQL? I OBJECT) 1) (CL:RETURN-FROM MEMBER? TRUE))))
  (CL:RETURN-FROM MEMBER? FALSE)
  :VOID)

;;; (DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIRST ((SELF LIST))
  "Return the first item in the list 'self', or NULL if empty."
  (CL:LET*
   ((CONS (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
   (CL:RETURN-FROM
    FIRST
    (CL:IF (CL:NOT (CL:EQ CONS NIL)) (CLSYS-SVAL CONS VALUE CONS) NULL)))
  :VOID)

;;; (DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD SECOND ((SELF LIST))
  "Return the second item in the list 'self', or NULL if empty."
  (CL:RETURN-FROM SECOND (SECOND (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD THIRD ((SELF LIST))
  "Return the third item in the list 'self', or NULL if empty."
  (CL:RETURN-FROM THIRD (THIRD (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FOURTH ((SELF LIST))
  "Return the fourth item in the list 'self', or NULL if empty."
  (CL:RETURN-FROM FOURTH (FOURTH (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIFTH ((SELF LIST))
  "Return the fifth item in the list 'self', or NULL if empty."
  (CL:RETURN-FROM FIFTH (FIFTH (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH ((SELF LIST) POSITION)
  "Return the nth item in the list 'self', or NULL if empty."
  (CL:RETURN-FROM NTH (NTH (CLSYS-SVAL LIST THE-CONS-LIST SELF) POSITION))
  :VOID)

;;; (DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LAST ((SELF LIST))
  "Return the last element of 'self'."
  (CL:RETURN-FROM LAST (LAST (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFMETHOD (REST (CONS OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD REST ((SELF LIST))
  "Return a cons list of all but the first item in the list 'self'."
  (CL:RETURN-FROM
   REST
   (CLSYS-SVAL CONS REST (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFMETHOD (FIRST-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIRST-SETTER ((SELF LIST) VALUE)
  (CL:RETURN-FROM
   FIRST-SETTER
   (FIRST-SETTER (CLSYS-SVAL LIST THE-CONS-LIST SELF) VALUE))
  :VOID)

;;; (DEFMETHOD (SECOND-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD SECOND-SETTER ((SELF LIST) VALUE)
  (CL:RETURN-FROM
   SECOND-SETTER
   (SECOND-SETTER (CLSYS-SVAL LIST THE-CONS-LIST SELF) VALUE))
  :VOID)

;;; (DEFMETHOD (THIRD-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD THIRD-SETTER ((SELF LIST) VALUE)
  (CL:RETURN-FROM
   THIRD-SETTER
   (THIRD-SETTER (CLSYS-SVAL LIST THE-CONS-LIST SELF) VALUE))
  :VOID)

;;; (DEFMETHOD (FOURTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FOURTH-SETTER ((SELF LIST) VALUE)
  (CL:RETURN-FROM
   FOURTH-SETTER
   (FOURTH-SETTER (CLSYS-SVAL LIST THE-CONS-LIST SELF) VALUE))
  :VOID)

;;; (DEFMETHOD (FIFTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIFTH-SETTER ((SELF LIST) VALUE)
  (CL:RETURN-FROM
   FIFTH-SETTER
   (FIFTH-SETTER (CLSYS-SVAL LIST THE-CONS-LIST SELF) VALUE))
  :VOID)

;;; (DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH-SETTER ((SELF LIST) VALUE POSITION)
  (CL:RETURN-FROM
   NTH-SETTER
   (NTH-SETTER (CLSYS-SVAL LIST THE-CONS-LIST SELF) VALUE POSITION))
  :VOID)

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF LIST))
  (CL:DECLARE (CL:INLINE LENGTH))
  (CL:RETURN-FROM LENGTH (LENGTH (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFMETHOD (POSITION INTEGER) ...)

(CL:DEFMETHOD POSITION ((SELF LIST) OBJECT START)
  "Return the position of 'object' within the list
'self' (counting from zero); or return NULL if 'object' does not occur within 
'self' (uses an 'eql?' test).  If 'start' was supplied as non-NULL, only 
consider the sublist starting at 'start', however, the returned position 
will always be relative to the entire list."
  (CL:RETURN-FROM
   POSITION
   (POSITION (CLSYS-SVAL LIST THE-CONS-LIST SELF) OBJECT START))
  :VOID)

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF LIST) VALUE)
  "Add 'value' to the front of the list 'self'."
  (CL:WHEN
   (CL:EQ SELF NIL-LIST)
   (CL:ERROR "Safety violation: Attempt to insert into NIL-LIST."))
  (CL:SETF
   (CLSYS-SVAL LIST THE-CONS-LIST SELF)
   (PERMANENT-CONS VALUE (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFMETHOD PUSH ...)

(CL:DEFMETHOD PUSH ((SELF LIST) VALUE)
  "Add 'value' to the front of the list 'self'."
  (CL:WHEN
   (CL:EQ SELF NIL-LIST)
   (CL:ERROR "Safety violation: Attempt to insert into NIL-LIST."))
  (CL:SETF
   (CLSYS-SVAL LIST THE-CONS-LIST SELF)
   (PERMANENT-CONS VALUE (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFMETHOD INSERT-NEW ...)

(CL:DEFMETHOD INSERT-NEW ((SELF LIST) VALUE)
  "Add 'value' to the front of the list 'self' unless its 
already a member."
  (CL:WHEN
   (CL:EQ SELF NIL-LIST)
   (CL:ERROR "Safety violation: Attempt to insert into NIL-LIST."))
  (CL:WHEN
   (CL:EQ (MEMBER? (CLSYS-SVAL LIST THE-CONS-LIST SELF) VALUE) 0)
   (CL:SETF
    (CLSYS-SVAL LIST THE-CONS-LIST SELF)
    (PERMANENT-CONS VALUE (CLSYS-SVAL LIST THE-CONS-LIST SELF))))
  :VOID)

;;; (DEFMETHOD INSERT-LAST ...)

(CL:DEFMETHOD INSERT-LAST ((SELF LIST) VALUE)
  "Insert 'value' as the last entry in the list 'self'."
  (CL:WHEN
   (CL:EQ SELF NIL-LIST)
   (CL:ERROR "Safety violation: Attempt to insert into NIL-LIST."))
  (CL:LET*
   ((CURSOR (CLSYS-SVAL LIST THE-CONS-LIST SELF))
    (LASTCONS (PERMANENT-CONS VALUE NIL)))
   (CL:IF
    (CL:EQ CURSOR NIL)
    (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST SELF) LASTCONS)
    (CL:PROGN
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST CURSOR) NIL))
      DO
      (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
     (CL:SETF (CLSYS-SVAL CONS REST CURSOR) LASTCONS))))
  :VOID)

;;; (DEFMETHOD (REMOVE LIST) ...)

(CL:DEFMETHOD REMOVE ((SELF LIST) VALUE)
  "Remove all entries in 'self' that match 'value'."
  (CL:SETF
   (CLSYS-SVAL LIST THE-CONS-LIST SELF)
   (REMOVE (CLSYS-SVAL LIST THE-CONS-LIST SELF) VALUE))
  (CL:RETURN-FROM REMOVE SELF)
  :VOID)

;;; (DEFMETHOD (REMOVE-IF LIST) ...)

(CL:DEFMETHOD REMOVE-IF ((SELF LIST) TEST?)
  "Remove all members of the list 'self' for which 'test?'
evaluates to TRUE.  'test' takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns 'self'."
  (CL:LET*
   ((CURSOR (CLSYS-SVAL LIST THE-CONS-LIST SELF)) (TRAILER NULL))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:IF
     (CL:AND
      (CL:EQ (CL:FUNCALL TEST? (CLSYS-SVAL CONS VALUE CURSOR)) 1)
      (CL:NOT (CL:EQ TRAILER NULL)))
     (CL:PROGN
      (CL:SETF (CLSYS-SVAL CONS REST TRAILER) (CLSYS-SVAL CONS REST CURSOR))
      (FREE-CONS CURSOR)
      (CL:SETQ CURSOR (CLSYS-SVAL CONS REST TRAILER)))
     (CL:PROGN
      (CL:SETQ TRAILER CURSOR)
      (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))))
   (CL:SETQ CURSOR (CLSYS-SVAL LIST THE-CONS-LIST SELF))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ CURSOR NIL))
     (CL:EQ (CL:FUNCALL TEST? (CLSYS-SVAL CONS VALUE CURSOR)) 1))
    (CL:SETF
     (CLSYS-SVAL LIST THE-CONS-LIST SELF)
     (CLSYS-SVAL CONS REST CURSOR))
    (FREE-CONS CURSOR))
   (CL:RETURN-FROM REMOVE-IF SELF))
  :VOID)

;;; (DEFMETHOD (REMOVE-DUPLICATES (LIKE SELF)) ...)

(CL:DEFMETHOD REMOVE-DUPLICATES ((SELF LIST))
  "Return 'self' with duplicates removed.  Preserves the
original order of the remaining members."
  (CL:WHEN
   (CL:NOT (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST SELF) NIL))
   (REMOVE-DUPLICATES (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  (CL:RETURN-FROM REMOVE-DUPLICATES SELF)
  :VOID)

;;; (DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD POP ((SELF LIST))
  "Remove and return the first element in the list 'self'.
Return NULL if the list is empty."
  (CL:LET*
   ((CONS (CLSYS-SVAL LIST THE-CONS-LIST SELF)) (VALUE NULL))
   (CL:WHEN (CL:EQ CONS NIL) (CL:RETURN-FROM POP NULL))
   (CL:SETQ VALUE (CLSYS-SVAL CONS VALUE CONS))
   (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST SELF) (CLSYS-SVAL CONS REST CONS))
   (FREE-CONS CONS)
   (CL:RETURN-FROM POP VALUE))
  :VOID)

;;; (DEFMETHOD (REVERSE (LIKE SELF)) ...)

(CL:DEFMETHOD REVERSE ((SELF LIST))
  "Reverse the members of 'self' (in place)."
  (CL:SETF
   (CLSYS-SVAL LIST THE-CONS-LIST SELF)
   (REVERSE (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  (CL:RETURN-FROM REVERSE SELF)
  :VOID)

;;; (DEFMETHOD (SUBSTITUTE (LIKE SELF)) ...)

(CL:DEFMETHOD SUBSTITUTE ((SELF LIST) INVALUE OUTVALUE)
  "Destructively replace each appearance of 'outValue' by
'inValue' in the list 'self'."
  (CL:SETF
   (CLSYS-SVAL LIST THE-CONS-LIST SELF)
   (SUBSTITUTE (CLSYS-SVAL LIST THE-CONS-LIST SELF) INVALUE OUTVALUE))
  (CL:RETURN-FROM SUBSTITUTE SELF)
  :VOID)

;;; (DEFMETHOD (CONCATENATE (LIKE SELF)) ...)

(CL:DEFMETHOD CONCATENATE ((SELF LIST) LIST2)
  "Copy 'list2' onto the end of the list 'self'.
The operation is destructive wrt 'self', but leaves 'list2' intact."
  (CL:WHEN (CL:EQ (EMPTY? LIST2) 1) (CL:RETURN-FROM CONCATENATE SELF))
  (CL:LET*
   ((COPY2 (PERMANENT-COPY-CONS-LIST (CLSYS-SVAL LIST THE-CONS-LIST LIST2))))
   (CL:IF
    (CL:EQ (EMPTY? SELF) 1)
    (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST SELF) COPY2)
    (CONCATENATE (CLSYS-SVAL LIST THE-CONS-LIST SELF) COPY2))
   (CL:RETURN-FROM CONCATENATE SELF))
  :VOID)

;;; (DEFMETHOD (PREPEND (LIKE SELF)) ...)

(CL:DEFMETHOD PREPEND ((SELF LIST) LIST2)
  "Copy 'list2' onto the front of the list 'self'.
The operation is destructive wrt 'self', but leaves 'list2' intact."
  (CL:WHEN (CL:EQ (EMPTY? LIST2) 1) (CL:RETURN-FROM PREPEND SELF))
  (CL:SETF
   (CLSYS-SVAL LIST THE-CONS-LIST SELF)
   (CONCATENATE
    (PERMANENT-COPY-CONS-LIST (CLSYS-SVAL LIST THE-CONS-LIST LIST2))
    (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  (CL:RETURN-FROM PREPEND SELF)
  :VOID)

;;; (DEFMETHOD (COPY (LIST OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD COPY ((SELF LIST))
  "Return a copy of the list 'self'.  The conses in the copy are
freshly allocated."
  (CL:LET*
   ((COPY (CREATE-OBJECT (PRIMARY-TYPE SELF))))
   (CL:SETF
    (CLSYS-SVAL LIST THE-CONS-LIST COPY)
    (PERMANENT-COPY-CONS-LIST (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
   (CL:RETURN-FROM COPY COPY))
  :VOID)

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF LIST))
  "Make 'self' an empty list."
  (FREE-CONS-LIST (CLSYS-SVAL LIST THE-CONS-LIST SELF))
  (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST SELF) NIL)
  :VOID)

;;; (DEFMETHOD (SORT (LIST OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD SORT ((SELF LIST) PREDICATE)
  "Perform a stable, destructive sort of 'self' according to
'predicate', and return the result.  If 'predicate' has a '<' semantics, the
result will be in ascending order.  If 'predicate' is NULL, a suitable
'<' predicate is chosen depending on the first element of 'self', and it 
is assumed that all elements of 'self' have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT)."
  (CL:SETF
   (CLSYS-SVAL LIST THE-CONS-LIST SELF)
   (SORT (CLSYS-SVAL LIST THE-CONS-LIST SELF) PREDICATE))
  (CL:RETURN-FROM SORT SELF)
  :VOID)

;;; (DEFMETHOD (ALLOCATE-ITERATOR (LIST-ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF LIST))
  (CL:LET*
   ((ITERATOR (NEW-LIST-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-CURSOR ITERATOR)
    (CLSYS-SVAL LIST THE-CONS-LIST SELF))
   (CL:SETF (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-COLLECTION ITERATOR) SELF)
   (CL:SETF (CLSYS-SVAL LIST-ITERATOR FIRST-ITERATION? ITERATOR) TRUE)
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR))
  :VOID)

;;; (DEFUN (TERMINATE-LIST-ITERATOR? BOOLEAN) ...)

(CL:DEFUN TERMINATE-LIST-ITERATOR? (SELF)
  (CL:SETF (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-CURSOR SELF) NIL)
  (CL:SETF (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-COLLECTION SELF) NULL)
  (CL:RETURN-FROM TERMINATE-LIST-ITERATOR? TRUE)
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF LIST-ITERATOR))
  (CL:IF
   (CL:EQ (CLSYS-SVAL LIST-ITERATOR FIRST-ITERATION? SELF) 1)
   (CL:PROGN
    (CL:SETF (CLSYS-SVAL LIST-ITERATOR FIRST-ITERATION? SELF) FALSE)
    (CL:SETF
     (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-CURSOR SELF)
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-COLLECTION SELF))))
   (CL:SETF
    (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-CURSOR SELF)
    (CLSYS-SVAL
     CONS
     REST
     (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-CURSOR SELF))))
  (CL:SETF
   (CLSYS-SVAL LIST-ITERATOR VALUE SELF)
   (CLSYS-SVAL CONS VALUE (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-CURSOR SELF)))
  (CL:RETURN-FROM
   NEXT?
   (CL:IF
    (CL:NOT (CL:EQ (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-CURSOR SELF) NIL))
    TRUE
    FALSE))
  :VOID)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF LIST-ITERATOR))
  (CL:RETURN-FROM
   EMPTY?
   (NIL?
    (CLSYS-SVAL
     LIST
     THE-CONS-LIST
     (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-COLLECTION SELF))))
  :VOID)

;;; (DEFMETHOD (KEY-SETTER OBJECT) ...)

(CL:DEFMETHOD KEY-SETTER ((SELF KV-LIST-ITERATOR) KEY)
  (CL:SETF
   (CLSYS-SVAL
    KV-CONS
    KEY
    (CLSYS-SVAL KV-LIST-ITERATOR KV-LIST-ITERATOR-CURSOR SELF))
   KEY)
  (CL:RETURN-FROM KEY-SETTER KEY)
  :VOID)

;;; (DEFMETHOD (VALUE-SETTER OBJECT) ...)

(CL:DEFMETHOD VALUE-SETTER ((SELF LIST-ITERATOR) VALUE)
  (CL:SETF
   (CLSYS-SVAL
    CONS
    VALUE
    (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-CURSOR SELF))
   VALUE)
  (CL:RETURN-FROM VALUE-SETTER VALUE)
  :VOID)

;;; (DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD BUT-LAST ((SELF LIST))
  "Generate all but the last element of the list 'self'."
  (CL:RETURN-FROM BUT-LAST (BUT-LAST (CLSYS-SVAL LIST THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFMETHOD (DELETED? BOOLEAN) ...)

(CL:DEFMETHOD DELETED? ((SELF OBJECT))
  "Default 'deleted?' method returns FALSE.  Objects
that inherit the mixin DYNAMIC-SLOTS-MIXIN also inherit the
dynamically-allocated slot 'deleted?'."
  (CL:RETURN-FROM DELETED? FALSE)
  :VOID)

;;; (DEFMETHOD (DELETED? BOOLEAN) ...)

(CL:DEFMETHOD DELETED? ((SELF DYNAMIC-SLOTS-MIXIN))
  (CL:LET*
   ((DELETED?
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-LISTS-DELETED-OBJECT?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (DEFINED? DELETED?) 1)
    (CL:RETURN-FROM DELETED? DELETED?)
    (CL:RETURN-FROM DELETED? FALSE)))
  :VOID)

;;; (DEFMETHOD (DELETED?-SETTER BOOLEAN) ...)

(CL:DEFMETHOD DELETED?-SETTER ((SELF DYNAMIC-SLOTS-MIXIN) VALUE)
  (SET-DYNAMIC-SLOT-VALUE
   SELF
   SYM-LISTS-DELETED-OBJECT?
   (WRAP-BOOLEAN VALUE)
   NULL-BOOLEAN-WRAPPER)
  (CL:RETURN-FROM DELETED?-SETTER VALUE)
  :VOID)

;;; (DEFMETHOD (DELETED? BOOLEAN) ...)

(CL:DEFMETHOD DELETED? ((SELF MAPPABLE-OBJECT))
  (CL:LET*
   ((DELETED?
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-LISTS-DELETED-OBJECT?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (DEFINED? DELETED?) 1)
    (CL:RETURN-FROM DELETED? DELETED?)
    (CL:RETURN-FROM DELETED? FALSE)))
  :VOID)

;;; (DEFMETHOD (DELETED?-SETTER BOOLEAN) ...)

(CL:DEFMETHOD DELETED?-SETTER ((SELF MAPPABLE-OBJECT) VALUE)
  (SET-DYNAMIC-SLOT-VALUE
   SELF
   SYM-LISTS-DELETED-OBJECT?
   (WRAP-BOOLEAN VALUE)
   NULL-BOOLEAN-WRAPPER)
  (CL:RETURN-FROM DELETED?-SETTER VALUE)
  :VOID)

;;; (DEFMETHOD REMOVE-DELETED-MEMBERS ...)

(CL:DEFMETHOD REMOVE-DELETED-MEMBERS ((SELF LIST))
  (CL:LET*
   ((CURSOR (CLSYS-SVAL LIST THE-CONS-LIST SELF)) (TRAILER NULL))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:IF
     (CL:AND
      (CL:EQ (DELETED? (CLSYS-SVAL CONS VALUE CURSOR)) 1)
      (CL:NOT (CL:EQ TRAILER NULL)))
     (CL:PROGN
      (CL:SETF (CLSYS-SVAL CONS REST TRAILER) (CLSYS-SVAL CONS REST CURSOR))
      (FREE-CONS CURSOR)
      (CL:SETQ CURSOR (CLSYS-SVAL CONS REST TRAILER)))
     (CL:PROGN
      (CL:SETQ TRAILER CURSOR)
      (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))))
   (CL:SETQ CURSOR (CLSYS-SVAL LIST THE-CONS-LIST SELF))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ CURSOR NIL))
     (CL:EQ (DELETED? (CLSYS-SVAL CONS VALUE CURSOR)) 1))
    (CL:SETF
     (CLSYS-SVAL LIST THE-CONS-LIST SELF)
     (CLSYS-SVAL CONS REST CURSOR))
    (FREE-CONS CURSOR)))
  :VOID)

;;; (DEFMETHOD INITIALIZE-OBJECT ...)

(CL:DEFMETHOD INITIALIZE-OBJECT ((SELF PROPERTY-LIST))
  (CL:SETF (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF) NIL)
  :VOID)

;;; (DEFUN (SEARCH-PLIST OBJECT) ...)

(CL:DEFUN SEARCH-PLIST (PLIST KEY)
  (CL:LOOP
   WHILE
   (CL:NOT (CL:EQ PLIST NIL))
   DO
   (CL:WHEN
    (CL:EQ (EQL? (CLSYS-SVAL CONS VALUE PLIST) KEY) 1)
    (CL:RETURN-FROM
     SEARCH-PLIST
     (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST PLIST))))
   (CL:SETQ PLIST (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST PLIST))))
  (CL:RETURN-FROM SEARCH-PLIST NULL)
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF PROPERTY-LIST) KEY)
  (CL:DECLARE (CL:INLINE SEARCH-PLIST))
  (CL:RETURN-FROM
   LOOKUP
   (SEARCH-PLIST (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF) KEY))
  :VOID)

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF PROPERTY-LIST))
  (CL:LET*
   ((CURSOR (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF)) (LENGTH 0))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:SETQ LENGTH (CL:1+ LENGTH))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST CURSOR))))
   (CL:RETURN-FROM LENGTH LENGTH))
  :VOID)

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF PROPERTY-LIST) KEY VALUE)
  "Insert the entry <`key', `value'> into the property list `self'.
If a previous entry existed with key `key', that entry is replaced."
  (CL:LET*
   ((CURSOR (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:WHEN
     (CL:EQ (EQL? (CLSYS-SVAL CONS VALUE CURSOR) KEY) 1)
     (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR))
     (CL:SETF (CLSYS-SVAL CONS VALUE CURSOR) VALUE)
     (CL:RETURN-FROM INSERT-AT))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST CURSOR))))
   (CL:SETF
    (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF)
    (PERMANENT-CONS
     KEY
     (PERMANENT-CONS VALUE (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF)))))
  :VOID)

;;; (DEFMETHOD (REMOVE-AT OBJECT) ...)

(CL:DEFMETHOD REMOVE-AT ((SELF PROPERTY-LIST) KEY)
  "Remove the entry that matches the key `key'.  Return the
value of the matching entry, or NULL if there is no matching entry.  Assumes that at
most one entry matches `key'."
  (CL:LET*
   ((CURSOR (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF))
    (PREVIOUSCONS NULL)
    (VALUE NULL))
   (CL:WHEN
    (CL:NOT (CL:EQ CURSOR NIL))
    (CL:WHEN
     (CL:EQ (EQL? (CLSYS-SVAL CONS VALUE CURSOR) KEY) 1)
     (CL:SETF
      (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF)
      (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST CURSOR)))
     (CL:SETQ VALUE (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST CURSOR)))
     (FREE-CONS (CLSYS-SVAL CONS REST CURSOR))
     (FREE-CONS CURSOR)
     (CL:RETURN-FROM REMOVE-AT VALUE))
    (CL:SETQ PREVIOUSCONS (CLSYS-SVAL CONS REST CURSOR))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST PREVIOUSCONS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ CURSOR NIL))
     DO
     (CL:WHEN
      (CL:EQ (EQL? (CLSYS-SVAL CONS VALUE CURSOR) KEY) 1)
      (CL:SETF
       (CLSYS-SVAL CONS REST PREVIOUSCONS)
       (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST CURSOR)))
      (CL:SETQ VALUE (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST CURSOR)))
      (FREE-CONS (CLSYS-SVAL CONS REST CURSOR))
      (FREE-CONS CURSOR)
      (CL:RETURN-FROM REMOVE-AT VALUE))
     (CL:SETQ PREVIOUSCONS (CLSYS-SVAL CONS REST CURSOR))
     (CL:SETQ CURSOR (CLSYS-SVAL CONS REST PREVIOUSCONS))))
   (CL:RETURN-FROM REMOVE-AT NULL))
  :VOID)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF PROPERTY-LIST))
  (CL:RETURN-FROM EMPTY? (EMPTY? (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF)))
  :VOID)

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF PROPERTY-LIST))
  (CL:RETURN-FROM
   NON-EMPTY?
   (NON-EMPTY? (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF)))
  :VOID)

;;; (DEFMETHOD (COPY (LIKE SELF)) ...)

(CL:DEFMETHOD COPY ((SELF PROPERTY-LIST))
  "Return a copy of the list `self'.  The conses in the copy are
freshly allocated."
  (CL:LET*
   ((COPY (CREATE-OBJECT (PRIMARY-TYPE SELF))))
   (CL:SETF
    (CLSYS-SVAL PROPERTY-LIST THE-PLIST COPY)
    (PERMANENT-COPY-CONS-LIST (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF)))
   (CL:RETURN-FROM COPY COPY))
  :VOID)

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF PROPERTY-LIST))
  "Make `self' an empty property list."
  (FREE-CONS-LIST (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF))
  (CL:SETF (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF) NIL)
  :VOID)

;;; (DEFMETHOD (ALLOCATE-ITERATOR PROPERTY-LIST-ITERATOR) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF PROPERTY-LIST))
  (CL:LET*
   ((ITERATOR (NEW-PROPERTY-LIST-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL PROPERTY-LIST-ITERATOR PLIST-ITERATOR-CURSOR ITERATOR)
    (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF))
   (CL:SETF
    (CLSYS-SVAL PROPERTY-LIST-ITERATOR PLIST-ITERATOR-COLLECTION ITERATOR)
    SELF)
   (CL:SETF
    (CLSYS-SVAL PROPERTY-LIST-ITERATOR FIRST-ITERATION? ITERATOR)
    TRUE)
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR))
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF PROPERTY-LIST-ITERATOR))
  (CL:IF
   (CL:EQ (CLSYS-SVAL PROPERTY-LIST-ITERATOR FIRST-ITERATION? SELF) 1)
   (CL:SETF (CLSYS-SVAL PROPERTY-LIST-ITERATOR FIRST-ITERATION? SELF) FALSE)
   (CL:SETF
    (CLSYS-SVAL PROPERTY-LIST-ITERATOR PLIST-ITERATOR-CURSOR SELF)
    (CLSYS-SVAL
     CONS
     REST
     (CLSYS-SVAL
      CONS
      REST
      (CLSYS-SVAL PROPERTY-LIST-ITERATOR PLIST-ITERATOR-CURSOR SELF)))))
  (CL:LET*
   ((REMAININGPLIST
     (CLSYS-SVAL PROPERTY-LIST-ITERATOR PLIST-ITERATOR-CURSOR SELF)))
   (CL:WHEN
    (CL:NOT (CL:EQ REMAININGPLIST NIL))
    (CL:SETF
     (CLSYS-SVAL PROPERTY-LIST-ITERATOR KEY SELF)
     (CLSYS-SVAL CONS VALUE REMAININGPLIST))
    (CL:SETF
     (CLSYS-SVAL PROPERTY-LIST-ITERATOR VALUE SELF)
     (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST REMAININGPLIST)))
    (CL:RETURN-FROM NEXT? TRUE))
   (CL:RETURN-FROM NEXT? FALSE))
  :VOID)

;;; (DEFMETHOD (VALUE-SETTER OBJECT) ...)

(CL:DEFMETHOD VALUE-SETTER ((SELF PROPERTY-LIST-ITERATOR) VALUE)
  (CL:SETF
   (CLSYS-SVAL
    CONS
    VALUE
    (CLSYS-SVAL
     CONS
     REST
     (CLSYS-SVAL PROPERTY-LIST-ITERATOR PLIST-ITERATOR-CURSOR SELF)))
   VALUE)
  (CL:RETURN-FROM VALUE-SETTER VALUE)
  :VOID)

;;; (DEFMETHOD (KEY-SETTER OBJECT) ...)

(CL:DEFMETHOD KEY-SETTER ((SELF PROPERTY-LIST-ITERATOR) KEY)
  (CL:SETF
   (CLSYS-SVAL
    CONS
    VALUE
    (CLSYS-SVAL PROPERTY-LIST-ITERATOR PLIST-ITERATOR-CURSOR SELF))
   KEY)
  (CL:RETURN-FROM KEY-SETTER KEY)
  :VOID)

;;; (DEFUN (KV-CONS KV-CONS) ...)

(CL:DEFUN KV-CONS (KEY VALUE REST)
  "Create, fill-in, and return a new KV-CONS."
  (CL:LET*
   ((NEWKVC (NEW-KV-CONS)))
   (CL:SETF (CLSYS-SVAL KV-CONS KEY NEWKVC) KEY)
   (CL:SETF (CLSYS-SVAL KV-CONS VALUE NEWKVC) VALUE)
   (CL:SETF (CLSYS-SVAL KV-CONS REST NEWKVC) REST)
   (CL:RETURN-FROM KV-CONS NEWKVC))
  :VOID)

;;; (DEFUN FREE-KV-CONS ...)

(CL:DEFUN FREE-KV-CONS (KVCONS)
  (FREE KVCONS)
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF KEY-VALUE-LIST) KEY)
  (CL:LET*
   ((CURSOR (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NULL))
    DO
    (CL:WHEN
     (CL:EQ (EQL? (CLSYS-SVAL KV-CONS KEY CURSOR) KEY) 1)
     (CL:RETURN-FROM LOOKUP (CLSYS-SVAL KV-CONS VALUE CURSOR)))
    (CL:SETQ CURSOR (CLSYS-SVAL KV-CONS REST CURSOR)))
   (CL:RETURN-FROM LOOKUP NULL))
  :VOID)

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF KEY-VALUE-LIST))
  (CL:LET*
   ((LENGTH 0) (CURSOR (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NULL))
    DO
    (CL:SETQ LENGTH (CL:1+ LENGTH))
    (CL:SETQ CURSOR (CLSYS-SVAL KV-CONS REST CURSOR)))
   (CL:RETURN-FROM LENGTH LENGTH))
  :VOID)

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF KEY-VALUE-LIST) KEY VALUE)
  "Insert the entry <'key', 'value'> into the association
'self'. If a previous entry existed with key 'key', that entry is replaced."
  (CL:LET*
   ((CURSOR (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NULL))
    DO
    (CL:WHEN
     (CL:EQ (EQL? (CLSYS-SVAL KV-CONS KEY CURSOR) KEY) 1)
     (CL:SETF (CLSYS-SVAL KV-CONS VALUE CURSOR) VALUE)
     (CL:RETURN-FROM INSERT-AT))
    (CL:SETQ CURSOR (CLSYS-SVAL KV-CONS REST CURSOR)))
   (CL:SETF
    (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)
    (KV-CONS KEY VALUE (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF))))
  :VOID)

;;; (DEFMETHOD (REMOVE-AT OBJECT) ...)

(CL:DEFMETHOD REMOVE-AT ((SELF KEY-VALUE-LIST) KEY)
  "Remove the entry that matches the key 'key'.
Return the value of the matching entry, or NULL if there is no matching entry.
Assumes that at most one entry matches 'key'."
  (CL:LET*
   ((CURSOR (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF))
    (PREVIOUSCURSOR NULL)
    (VALUE NULL))
   (CL:WHEN
    (CL:NOT (CL:EQ CURSOR NULL))
    (CL:WHEN
     (CL:EQ (EQL? (CLSYS-SVAL KV-CONS KEY CURSOR) KEY) 1)
     (CL:SETF
      (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)
      (CLSYS-SVAL KV-CONS REST CURSOR))
     (CL:SETQ VALUE (CLSYS-SVAL KV-CONS VALUE CURSOR))
     (FREE-KV-CONS CURSOR)
     (CL:RETURN-FROM REMOVE-AT VALUE))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ (CLSYS-SVAL KV-CONS REST CURSOR) NULL))
     DO
     (CL:SETQ PREVIOUSCURSOR CURSOR)
     (CL:SETQ CURSOR (CLSYS-SVAL KV-CONS REST CURSOR))
     (CL:WHEN
      (CL:EQ (EQL? (CLSYS-SVAL KV-CONS KEY CURSOR) KEY) 1)
      (CL:SETF
       (CLSYS-SVAL KV-CONS REST PREVIOUSCURSOR)
       (CLSYS-SVAL KV-CONS REST CURSOR))
      (CL:SETQ VALUE (CLSYS-SVAL KV-CONS VALUE CURSOR))
      (FREE-KV-CONS CURSOR)
      (CL:RETURN-FROM REMOVE-AT VALUE))))
   (CL:RETURN-FROM REMOVE-AT NULL))
  :VOID)

;;; (DEFMETHOD INSERT-ENTRY ...)

(CL:DEFMETHOD INSERT-ENTRY ((SELF KEY-VALUE-LIST) KEY VALUE)
  "Insert an entry <'key','value'> to 'self' unless an identical
entry already exists.  This can generate duplicate entries for 'key'."
  (CL:LET*
   ((FOUND?-001 FALSE))
   (CL:LET*
    ((V NULL)
     (K NULL)
     (ITER-001 (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NULL))
     DO
     (CL:SETQ K (CLSYS-SVAL KV-CONS KEY ITER-001))
     (CL:PROGN
      (CL:SETQ V (CLSYS-SVAL KV-CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL KV-CONS REST ITER-001)))
     (CL:WHEN
      (CL:AND (CL:EQ K KEY) (CL:EQ V VALUE))
      (CL:SETQ FOUND?-001 TRUE)
      (CL:RETURN))))
   (CL:WHEN
    (CL:EQ FOUND?-001 0)
    (CL:SETF
     (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)
     (KV-CONS KEY VALUE (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)))))
  :VOID)

;;; (DEFMETHOD REMOVE-ENTRY ...)

(CL:DEFMETHOD REMOVE-ENTRY ((SELF KEY-VALUE-LIST) KEY VALUE)
  "Remove the entry that matches <'key','value'>.
Assumes that more than one entry can match 'key'."
  (CL:LET*
   ((CURSOR (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF))
    (PREVIOUSCURSOR NULL))
   (CL:WHEN
    (CL:NOT (CL:EQ CURSOR NULL))
    (CL:WHEN
     (CL:AND
      (CL:EQ (EQL? (CLSYS-SVAL KV-CONS KEY CURSOR) KEY) 1)
      (CL:EQ (EQL? (CLSYS-SVAL KV-CONS VALUE CURSOR) VALUE) 1))
     (CL:SETF
      (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)
      (CLSYS-SVAL KV-CONS REST CURSOR))
     (FREE-KV-CONS CURSOR)
     (CL:RETURN-FROM REMOVE-ENTRY))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ (CLSYS-SVAL KV-CONS REST CURSOR) NULL))
     DO
     (CL:SETQ PREVIOUSCURSOR CURSOR)
     (CL:SETQ CURSOR (CLSYS-SVAL KV-CONS REST CURSOR))
     (CL:WHEN
      (CL:AND
       (CL:EQ (EQL? (CLSYS-SVAL KV-CONS KEY CURSOR) KEY) 1)
       (CL:EQ (EQL? (CLSYS-SVAL KV-CONS VALUE CURSOR) VALUE) 1))
      (CL:SETF
       (CLSYS-SVAL KV-CONS REST PREVIOUSCURSOR)
       (CLSYS-SVAL KV-CONS REST CURSOR))
      (FREE-KV-CONS CURSOR)
      (CL:RETURN-FROM REMOVE-ENTRY)))))
  :VOID)

;;; (DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD POP ((SELF KEY-VALUE-LIST))
  "Remove and return the first element of the kv-list 'self'.
Return NULL if the list is empty."
  (CL:WHEN (CL:EQ (EMPTY? SELF) 1) (CL:RETURN-FROM POP NULL))
  (CL:LET*
   ((CONS (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)) (VALUE NULL))
   (CL:SETQ VALUE (CLSYS-SVAL KV-CONS VALUE CONS))
   (CL:SETF
    (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)
    (CLSYS-SVAL KV-CONS REST CONS))
   (FREE-KV-CONS CONS)
   (CL:RETURN-FROM POP VALUE))
  :VOID)

;;; (DEFMETHOD (REVERSE (LIKE SELF)) ...)

(CL:DEFMETHOD REVERSE ((SELF KEY-VALUE-LIST))
  "Destructively reverse the members of the list 'self'."
  (CL:LET*
   ((REVERSEDLIST (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF))
    (REMAININGLIST NULL)
    (TEMP NULL))
   (CL:WHEN (CL:EQ REVERSEDLIST NULL) (CL:RETURN-FROM REVERSE SELF))
   (CL:SETQ REMAININGLIST (CLSYS-SVAL KV-CONS REST REVERSEDLIST))
   (CL:WHEN (CL:EQ REMAININGLIST NULL) (CL:RETURN-FROM REVERSE SELF))
   (CL:SETF (CLSYS-SVAL KV-CONS REST REVERSEDLIST) NULL)
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ REMAININGLIST NULL))
    DO
    (CL:SETQ TEMP REMAININGLIST)
    (CL:SETQ REMAININGLIST (CLSYS-SVAL KV-CONS REST REMAININGLIST))
    (CL:SETF (CLSYS-SVAL KV-CONS REST TEMP) REVERSEDLIST)
    (CL:SETQ REVERSEDLIST TEMP))
   (CL:SETF (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF) REVERSEDLIST)
   (CL:RETURN-FROM REVERSE SELF))
  :VOID)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF KEY-VALUE-LIST))
  (CL:RETURN-FROM EMPTY? (NULL? (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)))
  :VOID)

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF KEY-VALUE-LIST))
  (CL:RETURN-FROM
   NON-EMPTY?
   (DEFINED? (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)))
  :VOID)

;;; (DEFUN (COPY-KV-CONS-LIST KV-CONS) ...)

(CL:DEFUN COPY-KV-CONS-LIST (KVCONSLIST)
  "Return a copy of the cons list 'consList'."
  (CL:WHEN (CL:EQ KVCONSLIST NULL) (CL:RETURN-FROM COPY-KV-CONS-LIST NULL))
  (CL:LET*
   ((NEWKVCONSLIST (NEW-KV-CONS))
    (NEXTKVCONS NEWKVCONSLIST)
    (COPYFROMKVCONS NULL)
    (PREVIOUSKVCONS NULL))
   (CL:SETF
    (CLSYS-SVAL KV-CONS KEY NEXTKVCONS)
    (CLSYS-SVAL KV-CONS KEY KVCONSLIST))
   (CL:SETF
    (CLSYS-SVAL KV-CONS VALUE NEXTKVCONS)
    (CLSYS-SVAL KV-CONS VALUE KVCONSLIST))
   (CL:SETQ COPYFROMKVCONS (CLSYS-SVAL KV-CONS REST KVCONSLIST))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ COPYFROMKVCONS NULL))
    DO
    (CL:SETQ PREVIOUSKVCONS NEXTKVCONS)
    (CL:SETQ NEXTKVCONS (NEW-KV-CONS))
    (CL:SETF (CLSYS-SVAL KV-CONS REST PREVIOUSKVCONS) NEXTKVCONS)
    (CL:SETF
     (CLSYS-SVAL KV-CONS KEY NEXTKVCONS)
     (CLSYS-SVAL KV-CONS KEY COPYFROMKVCONS))
    (CL:SETF
     (CLSYS-SVAL KV-CONS VALUE NEXTKVCONS)
     (CLSYS-SVAL KV-CONS VALUE COPYFROMKVCONS))
    (CL:SETQ COPYFROMKVCONS (CLSYS-SVAL KV-CONS REST COPYFROMKVCONS)))
   (CL:SETF (CLSYS-SVAL KV-CONS REST NEXTKVCONS) NULL)
   (CL:RETURN-FROM COPY-KV-CONS-LIST NEWKVCONSLIST))
  :VOID)

;;; (DEFMETHOD (COPY (LIKE SELF)) ...)

(CL:DEFMETHOD COPY ((SELF KEY-VALUE-LIST))
  "Return a copy of the kv-list 'self'.  The kv-conses in
the copy are freshly allocated."
  (CL:LET*
   ((COPY (NEW-KEY-VALUE-LIST)))
   (CL:SETF
    (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST COPY)
    (COPY-KV-CONS-LIST (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)))
   (CL:RETURN-FROM COPY COPY))
  :VOID)

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF KEY-VALUE-LIST))
  "Make 'self' an empty dictionary."
  (CL:LET*
   ((NEXT (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)) (CURRENT NULL))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ NEXT NULL))
    DO
    (CL:SETQ CURRENT NEXT)
    (CL:SETQ NEXT (CLSYS-SVAL KV-CONS REST NEXT))
    (FREE-KV-CONS CURRENT))
   (CL:SETF (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF) NULL))
  :VOID)

;;; (DEFMETHOD (ALLOCATE-ITERATOR KV-LIST-ITERATOR) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF KEY-VALUE-LIST))
  (CL:LET*
   ((ITERATOR (NEW-KV-LIST-ITERATOR)))
   (CL:SETF (CLSYS-SVAL KV-LIST-ITERATOR THE-KV-LIST ITERATOR) SELF)
   (CL:SETF
    (CLSYS-SVAL KV-LIST-ITERATOR KV-LIST-ITERATOR-CURSOR ITERATOR)
    (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF))
   (CL:SETF (CLSYS-SVAL KV-LIST-ITERATOR FIRST-ITERATION? ITERATOR) TRUE)
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR))
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF KV-LIST-ITERATOR))
  (CL:IF
   (CL:EQ (CLSYS-SVAL KV-LIST-ITERATOR FIRST-ITERATION? SELF) 1)
   (CL:SETF (CLSYS-SVAL KV-LIST-ITERATOR FIRST-ITERATION? SELF) FALSE)
   (CL:SETF
    (CLSYS-SVAL KV-LIST-ITERATOR KV-LIST-ITERATOR-CURSOR SELF)
    (CLSYS-SVAL
     KV-CONS
     REST
     (CLSYS-SVAL KV-LIST-ITERATOR KV-LIST-ITERATOR-CURSOR SELF))))
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL KV-LIST-ITERATOR KV-LIST-ITERATOR-CURSOR SELF) NULL)
   (CL:RETURN-FROM NEXT? FALSE))
  (CL:SETF
   (CLSYS-SVAL KV-LIST-ITERATOR KEY SELF)
   (CLSYS-SVAL
    KV-CONS
    KEY
    (CLSYS-SVAL KV-LIST-ITERATOR KV-LIST-ITERATOR-CURSOR SELF)))
  (CL:SETF
   (CLSYS-SVAL KV-LIST-ITERATOR VALUE SELF)
   (CLSYS-SVAL
    KV-CONS
    VALUE
    (CLSYS-SVAL KV-LIST-ITERATOR KV-LIST-ITERATOR-CURSOR SELF)))
  (CL:RETURN-FROM NEXT? TRUE)
  :VOID)

;;; (DEFMETHOD (VALUE-SETTER OBJECT) ...)

(CL:DEFMETHOD VALUE-SETTER ((SELF KV-LIST-ITERATOR) VALUE)
  (CL:SETF
   (CLSYS-SVAL
    KV-CONS
    VALUE
    (CLSYS-SVAL KV-LIST-ITERATOR KV-LIST-ITERATOR-CURSOR SELF))
   VALUE)
  (CL:RETURN-FROM VALUE-SETTER VALUE)
  :VOID)

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF SEQUENCE) VALUE)
  "Return TRUE if 'value' is a member of the sequence 'self'."
  (CL:LET*
   ((M NULL) (ITER-001 (ALLOCATE-ITERATOR SELF)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITER-001) 1)
    DO
    (CL:PROGN (CL:SETQ M (CLSYS-SVAL ITERATOR VALUE ITER-001)))
    (CL:WHEN (CL:EQ (EQL? M VALUE) 1) (CL:RETURN-FROM MEMBER? TRUE))))
  (CL:RETURN-FROM MEMBER? FALSE)
  :VOID)

;;; (DEFUN (LIST LIST) ...)

(CL:DEFUN LIST (CL:&REST VALUES)
  "Return a list containing 'values', in order."
  (CL:LET*
   ((LIST (NEW-LIST)))
   (CL:LET*
    ((V NULL) (ITER-001 (ALLOCATE-ITERATOR VALUES)) (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ V (CLSYS-SVAL LISP-CONS-ITERATOR VALUE ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (PERMANENT-CONS V NIL))
       (CL:IF
        (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST LIST) NIL)
        (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST LIST) COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST
         (CLSYS-SVAL LIST THE-CONS-LIST LIST)
         COLLECT-001)))
      (CL:PROGN
       (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (PERMANENT-CONS V NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:RETURN-FROM LIST LIST))
  :VOID)

;;; (DEFUN (SEQUENCE (SEQUENCE OF OBJECT)) ...)

(CL:DEFUN SEQUENCE (COLLECTIONTYPE CL:&REST VALUES)
  "Return a sequence containing 'values', in order."
  (CL:LET*
   ((SEQUENCE (CREATE-OBJECT COLLECTIONTYPE)))
   (CL:LET*
    ((I NULL) (ITER-001 (ALLOCATE-ITERATOR VALUES)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ I (CLSYS-SVAL LISP-CONS-ITERATOR VALUE ITER-001)))
     (CL:LET*
      ((SEQUENCE-001 SEQUENCE))
      (CL:COND
       ((CL:EQ (TAXONOMY-ISA? SEQUENCE SGT-LISTS-LIST) 1)
        (CL:LET*
         ((SEQUENCE NULL))
         (CL:SETQ SEQUENCE SEQUENCE-001)
         (INSERT-LAST SEQUENCE I)))
       (CL:T
        (CL:ERROR
         "sequence: Don't know how to 'insert-last' into a `~A'"
         COLLECTIONTYPE))))))
   (CL:RETURN-FROM SEQUENCE SEQUENCE))
  :VOID)

;;; (DEFUN (DICTIONARY (DICTIONARY OF OBJECT OBJECT)) ...)

(CL:DEFUN DICTIONARY (COLLECTIONTYPE CL:&REST ALTERNATINGKEYSANDVALUES)
  "Return a dictionary containing 'values', in order."
  (CL:LET*
   ((DICTIONARY (CREATE-OBJECT COLLECTIONTYPE))
    (KEY NULL)
    (VALUE NULL)
    (COPY NIL)
    (CURSOR NULL))
   (CL:LET*
    ((ITEM NULL)
     (ITER-001 (ALLOCATE-ITERATOR ALTERNATINGKEYSANDVALUES))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ ITEM (CLSYS-SVAL LISP-CONS-ITERATOR VALUE ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (CONS ITEM NIL))
       (CL:IF
        (CL:EQ COPY NIL)
        (CL:SETQ COPY COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST COPY COLLECT-001)))
      (CL:PROGN
       (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS ITEM NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:SETQ CURSOR COPY)
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:SETQ KEY (FIRST CURSOR))
    (CL:SETQ VALUE (SECOND CURSOR))
    (CL:LET*
     ((DICTIONARY-001 DICTIONARY))
     (CL:COND
      ((CL:EQ (TAXONOMY-ISA? DICTIONARY SGT-LISTS-KEY-VALUE-LIST) 1)
       (CL:LET*
        ((DICTIONARY NULL))
        (CL:SETQ DICTIONARY DICTIONARY-001)
        (INSERT-AT DICTIONARY KEY VALUE)))
      ((CL:EQ (TAXONOMY-ISA? DICTIONARY SGT-LISTS-PROPERTY-LIST) 1)
       (CL:LET*
        ((DICTIONARY NULL))
        (CL:SETQ DICTIONARY DICTIONARY-001)
        (INSERT-AT DICTIONARY KEY VALUE)))
      (CL:T
       (CL:ERROR
        "dictionary: Don't know how to 'insert-at' into a `~A'"
        COLLECTIONTYPE))))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST CURSOR))))
   (FREE-CONS-LIST COPY)
   (CL:RETURN-FROM DICTIONARY DICTIONARY))
  :VOID)

;;; (DEFMETHOD (LISTIFY LIST) ...)

(CL:DEFMETHOD LISTIFY ((SELF ITERATOR))
  "Return a list of elements generated by 'self'."
  (CL:LET*
   ((LIST (NEW-LIST)))
   (CL:LET*
    ((VALUE NULL) (ITER-001 SELF))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ VALUE (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (PUSH LIST VALUE)))
   (CL:RETURN-FROM LISTIFY (REVERSE LIST)))
  :VOID)

;;; (DEFUN PRINT-KEY-VALUE-LIST ...)

(CL:DEFUN PRINT-KEY-VALUE-LIST (SELF STREAM)
  (CL:WRITE-STRING "(" STREAM)
  (CL:LET*
   ((CURSOR (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF)) (POSITION 1))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NULL))
    DO
    (CL:WHEN (CL:> POSITION 5) (CL:WRITE-STRING " ..." STREAM) (CL:RETURN))
    (PRINT-OBJECT CURSOR STREAM)
    (CL:SETQ CURSOR (CLSYS-SVAL KV-CONS REST CURSOR))
    (CL:SETQ POSITION (CL:1+ POSITION)))
   (CL:WRITE-STRING ")" STREAM))
  :VOID)

;;; (DEFUN PRINT-CONS-LIST ...)

(CL:DEFUN PRINT-CONS-LIST (LIST STREAM)
  (CL:IF
   (CL:EQ LIST NIL)
   (CL:WRITE-STRING "|i|()" STREAM)
   (CL:LET*
    ((I 0) (LIMIT 9))
    (CL:PROGN
     (CL:WRITE-STRING "|i|(" STREAM)
     (PRINT-OBJECT (FIRST LIST) STREAM))
    (CL:LET*
     ((ITEM NULL) (ITER-001 (CLSYS-SVAL CONS REST LIST)))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ ITEM (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:PROGN (CL:WRITE-STRING " " STREAM) (PRINT-OBJECT ITEM STREAM))
      (CL:SETQ I (CL:1+ I))
      (CL:WHEN (CL:> I LIMIT) (CL:RETURN))))
    (CL:IF
     (CL:<= I LIMIT)
     (CL:WRITE-STRING ")" STREAM)
     (CL:WRITE-STRING " ...)" STREAM))))
  :VOID)

(CL:DEFUN STARTUP-LISTS ()
  (CL:WHEN
   (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 0) 1)
   (CL:WHEN
    (CL:EQ NIL-LIST NULL)
    (CL:SETQ NIL-LIST (CL:MAKE-INSTANCE (CL:QUOTE LIST))))
   (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST NIL-LIST) NIL))
  (CL:LET*
   ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SGT-LISTS-ABSTRACT-DICTIONARY-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT-DICTIONARY-ITERATOR" NULL 1))
    (CL:SETQ SYM-LISTS-KEY (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY" NULL 0))
    (CL:SETQ
     SYM-LISTS-KEY-SETTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-SETTER" NULL 0))
    (CL:SETQ
     SYM-LISTS-SLOT-WRITER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-WRITER" NULL 0))
    (CL:SETQ
     SGT-LISTS-ABSTRACT-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT-ITERATOR" NULL 1))
    (CL:SETQ SYM-LISTS-VALUE (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
    (CL:SETQ
     SYM-LISTS-VALUE-SETTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE-SETTER" NULL 0))
    (CL:SETQ
     SYM-LISTS-DELETED-OBJECT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DELETED-OBJECT?" NULL 0))
    (CL:SETQ SGT-LISTS-LIST (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" NULL 1))
    (CL:SETQ
     SGT-LISTS-KEY-VALUE-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-VALUE-LIST" NULL 1))
    (CL:SETQ
     SGT-LISTS-PROPERTY-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTY-LIST" NULL 1)))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFINED-LIST?"
        "LIST"
        "(DEFUN (DEFINED-LIST? BOOLEAN) ((SELF LIST)) :DOCUMENTATION \"Return TRUE unless 'self' is NULL or the 'NIL-LIST'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFINED-LIST?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NULL-LIST?"
        "LIST"
        "(DEFUN (NULL-LIST? BOOLEAN) ((SELF LIST)) :DOCUMENTATION \"Return TRUE iff 'self' is NULL or the 'NIL-LIST'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NULL-LIST?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EMPTY?"
        "LIST"
        "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF LIST)) :DOCUMENTATION \"Return TRUE if the list 'self' has no members.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NON-EMPTY?"
        "LIST"
        "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF LIST)) :DOCUMENTATION \"Return TRUE if the list 'self' has at least one member.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NON-EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TERMINATE-LIST?"
        "LIST"
        "(DEFUN (TERMINATE-LIST? BOOLEAN) ((SELF LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TERMINATE-LIST?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MEMBER?"
        "LIST"
        "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF LIST) (OBJECT (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Return TRUE iff 'object' is a member of the list 'self'.
 Uses an 'eql?' test.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MEMBER?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIRST"
        "LIST"
        "(DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Return the first item in the list 'self', or NULL if empty.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FIRST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SECOND"
        "LIST"
        "(DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Return the second item in the list 'self', or NULL if empty.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SECOND)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "THIRD"
        "LIST"
        "(DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Return the third item in the list 'self', or NULL if empty.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION THIRD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FOURTH"
        "LIST"
        "(DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Return the fourth item in the list 'self', or NULL if empty.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FOURTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIFTH"
        "LIST"
        "(DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Return the fifth item in the list 'self', or NULL if empty.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FIFTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NTH"
        "LIST"
        "(DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ((SELF LIST) (POSITION INTEGER)) :DOCUMENTATION \"Return the nth item in the list 'self', or NULL if empty.\")")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION NTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LAST"
        "LIST"
        "(DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Return the last element of 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION LAST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REST"
        "LIST"
        "(DEFMETHOD (REST (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST)) :DOCUMENTATION \"Return a cons list of all but the first item in the list 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION REST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIRST-SETTER"
        "LIST"
        "(DEFMETHOD (FIRST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF LIST) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FIRST-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SECOND-SETTER"
        "LIST"
        "(DEFMETHOD (SECOND-SETTER (LIKE (ANY-VALUE SELF))) ((SELF LIST) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SECOND-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "THIRD-SETTER"
        "LIST"
        "(DEFMETHOD (THIRD-SETTER (LIKE (ANY-VALUE SELF))) ((SELF LIST) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION THIRD-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FOURTH-SETTER"
        "LIST"
        "(DEFMETHOD (FOURTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF LIST) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FOURTH-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIFTH-SETTER"
        "LIST"
        "(DEFMETHOD (FIFTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF LIST) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FIFTH-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NTH-SETTER"
        "LIST"
        "(DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF LIST) (VALUE OBJECT) (POSITION INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NTH-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LENGTH"
        "LIST"
        "(DEFMETHOD (LENGTH INTEGER) ((SELF LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LENGTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POSITION"
        "LIST"
        "(DEFMETHOD (POSITION INTEGER) ((SELF LIST) (OBJECT OBJECT) (START INTEGER)) :DOCUMENTATION \"Return the position of 'object' within the list
'self' (counting from zero); or return NULL if 'object' does not occur within 
'self' (uses an 'eql?' test).  If 'start' was supplied as non-NULL, only 
consider the sublist starting at 'start', however, the returned position 
will always be relative to the entire list.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION POSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT"
        "LIST"
        "(DEFMETHOD INSERT ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Add 'value' to the front of the list 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PUSH"
        "LIST"
        "(DEFMETHOD PUSH ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Add 'value' to the front of the list 'self'.\")")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION PUSH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-NEW"
        "LIST"
        "(DEFMETHOD INSERT-NEW ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Add 'value' to the front of the list 'self' unless its 
already a member.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT-NEW)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-LAST"
        "LIST"
        "(DEFMETHOD INSERT-LAST ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Insert 'value' as the last entry in the list 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT-LAST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE"
        "LIST"
        "(DEFMETHOD (REMOVE LIST) ((SELF LIST) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Remove all entries in 'self' that match 'value'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REMOVE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-IF"
        "LIST"
        "(DEFMETHOD (REMOVE-IF LIST) ((SELF LIST) (TEST? FUNCTION-CODE)) :PUBLIC? TRUE :DOCUMENTATION \"Remove all members of the list 'self' for which 'test?'
evaluates to TRUE.  'test' takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REMOVE-IF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-DUPLICATES"
        "LIST"
        "(DEFMETHOD (REMOVE-DUPLICATES (LIKE SELF)) ((SELF LIST)) :DOCUMENTATION \"Return 'self' with duplicates removed.  Preserves the
original order of the remaining members.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REMOVE-DUPLICATES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POP"
        "LIST"
        "(DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ((SELF LIST)) :DOCUMENTATION \"Remove and return the first element in the list 'self'.
Return NULL if the list is empty.\")")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION POP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REVERSE"
        "LIST"
        "(DEFMETHOD (REVERSE (LIKE SELF)) ((SELF LIST)) :DOCUMENTATION \"Reverse the members of 'self' (in place).\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REVERSE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBSTITUTE"
        "LIST"
        "(DEFMETHOD (SUBSTITUTE (LIKE SELF)) ((SELF LIST) (INVALUE OBJECT) (OUTVALUE OBJECT)) :DOCUMENTATION \"Destructively replace each appearance of 'outValue' by
'inValue' in the list 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SUBSTITUTE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONCATENATE"
        "LIST"
        "(DEFMETHOD (CONCATENATE (LIKE SELF)) ((SELF LIST) (LIST2 LIST)) :DOCUMENTATION \"Copy 'list2' onto the end of the list 'self'.
The operation is destructive wrt 'self', but leaves 'list2' intact.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CONCATENATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PREPEND"
        "LIST"
        "(DEFMETHOD (PREPEND (LIKE SELF)) ((SELF LIST) (LIST2 LIST)) :DOCUMENTATION \"Copy 'list2' onto the front of the list 'self'.
The operation is destructive wrt 'self', but leaves 'list2' intact.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PREPEND)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY"
        "LIST"
        "(DEFMETHOD (COPY (LIST OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST)) :DOCUMENTATION \"Return a copy of the list 'self'.  The conses in the copy are
freshly allocated.\")")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION COPY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR"
        "LIST"
        "(DEFMETHOD CLEAR ((SELF LIST)) :DOCUMENTATION \"Make 'self' an empty list.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CLEAR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SORT"
        "LIST"
        "(DEFMETHOD (SORT (LIST OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST) (PREDICATE FUNCTION-CODE)) :PUBLIC? TRUE :DOCUMENTATION \"Perform a stable, destructive sort of 'self' according to
'predicate', and return the result.  If 'predicate' has a '<' semantics, the
result will be in ascending order.  If 'predicate' is NULL, a suitable
'<' predicate is chosen depending on the first element of 'self', and it 
is assumed that all elements of 'self' have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT).\")")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION SORT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-ITERATOR"
        "LIST"
        "(DEFMETHOD (ALLOCATE-ITERATOR (LIST-ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ALLOCATE-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TERMINATE-LIST-ITERATOR?"
        "LIST-ITERATOR"
        "(DEFUN (TERMINATE-LIST-ITERATOR? BOOLEAN) ((SELF LIST-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TERMINATE-LIST-ITERATOR?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "LIST-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF LIST-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EMPTY?"
        "LIST-ITERATOR"
        "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF LIST-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KEY-SETTER"
        "KV-LIST-ITERATOR"
        "(DEFMETHOD (KEY-SETTER OBJECT) ((SELF KV-LIST-ITERATOR) (KEY OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION KEY-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VALUE-SETTER"
        "LIST-ITERATOR"
        "(DEFMETHOD (VALUE-SETTER OBJECT) ((SELF LIST-ITERATOR) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION VALUE-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUT-LAST"
        "LIST"
        "(DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST)) :DOCUMENTATION \"Generate all but the last element of the list 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION BUT-LAST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DELETED?"
        "OBJECT"
        "(DEFMETHOD (DELETED? BOOLEAN) ((SELF OBJECT)) :DOCUMENTATION \"Default 'deleted?' method returns FALSE.  Objects
that inherit the mixin DYNAMIC-SLOTS-MIXIN also inherit the
dynamically-allocated slot 'deleted?'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DELETED?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DELETED?"
        "DYNAMIC-SLOTS-MIXIN"
        "(DEFMETHOD (DELETED? BOOLEAN) ((SELF DYNAMIC-SLOTS-MIXIN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DELETED?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DELETED?-SETTER"
        "DYNAMIC-SLOTS-MIXIN"
        "(DEFMETHOD (DELETED?-SETTER BOOLEAN) ((SELF DYNAMIC-SLOTS-MIXIN) (VALUE BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DELETED?-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DELETED?"
        "MAPPABLE-OBJECT"
        "(DEFMETHOD (DELETED? BOOLEAN) ((SELF MAPPABLE-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DELETED?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DELETED?-SETTER"
        "MAPPABLE-OBJECT"
        "(DEFMETHOD (DELETED?-SETTER BOOLEAN) ((SELF MAPPABLE-OBJECT) (VALUE BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DELETED?-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-DELETED-MEMBERS"
        "LIST"
        "(DEFMETHOD REMOVE-DELETED-MEMBERS ((SELF LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REMOVE-DELETED-MEMBERS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INITIALIZE-OBJECT"
        "PROPERTY-LIST"
        "(DEFMETHOD INITIALIZE-OBJECT ((SELF PROPERTY-LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INITIALIZE-OBJECT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SEARCH-PLIST"
        "CONS"
        "(DEFUN (SEARCH-PLIST OBJECT) ((PLIST CONS) (KEY OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SEARCH-PLIST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP"
        "PROPERTY-LIST"
        "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF PROPERTY-LIST) (KEY (LIKE (ANY-KEY SELF)))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOOKUP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LENGTH"
        "PROPERTY-LIST"
        "(DEFMETHOD (LENGTH INTEGER) ((SELF PROPERTY-LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LENGTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-AT"
        "PROPERTY-LIST"
        "(DEFMETHOD INSERT-AT ((SELF PROPERTY-LIST) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Insert the entry <`key', `value'> into the property list `self'.
If a previous entry existed with key `key', that entry is replaced.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-AT"
        "PROPERTY-LIST"
        "(DEFMETHOD (REMOVE-AT OBJECT) ((SELF PROPERTY-LIST) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Remove the entry that matches the key `key'.  Return the
value of the matching entry, or NULL if there is no matching entry.  Assumes that at
most one entry matches `key'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REMOVE-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EMPTY?"
        "PROPERTY-LIST"
        "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF PROPERTY-LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NON-EMPTY?"
        "PROPERTY-LIST"
        "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF PROPERTY-LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NON-EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY"
        "PROPERTY-LIST"
        "(DEFMETHOD (COPY (LIKE SELF)) ((SELF PROPERTY-LIST)) :DOCUMENTATION \"Return a copy of the list `self'.  The conses in the copy are
freshly allocated.\")")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION COPY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR"
        "PROPERTY-LIST"
        "(DEFMETHOD CLEAR ((SELF PROPERTY-LIST)) :DOCUMENTATION \"Make `self' an empty property list.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CLEAR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-ITERATOR"
        "PROPERTY-LIST"
        "(DEFMETHOD (ALLOCATE-ITERATOR PROPERTY-LIST-ITERATOR) ((SELF PROPERTY-LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ALLOCATE-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "PROPERTY-LIST-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF PROPERTY-LIST-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VALUE-SETTER"
        "PROPERTY-LIST-ITERATOR"
        "(DEFMETHOD (VALUE-SETTER OBJECT) ((SELF PROPERTY-LIST-ITERATOR) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION VALUE-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KEY-SETTER"
        "PROPERTY-LIST-ITERATOR"
        "(DEFMETHOD (KEY-SETTER OBJECT) ((SELF PROPERTY-LIST-ITERATOR) (KEY OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION KEY-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KV-CONS"
        "OBJECT"
        "(DEFUN (KV-CONS KV-CONS) ((KEY OBJECT) (VALUE OBJECT) (REST KV-CONS)) :DOCUMENTATION \"Create, fill-in, and return a new KV-CONS.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KV-CONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-KV-CONS"
        "KV-CONS"
        "(DEFUN FREE-KV-CONS ((KVCONS KV-CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FREE-KV-CONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP"
        "KEY-VALUE-LIST"
        "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF KEY-VALUE-LIST) (KEY (LIKE (ANY-KEY SELF)))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOOKUP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LENGTH"
        "KEY-VALUE-LIST"
        "(DEFMETHOD (LENGTH INTEGER) ((SELF KEY-VALUE-LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LENGTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-AT"
        "KEY-VALUE-LIST"
        "(DEFMETHOD INSERT-AT ((SELF KEY-VALUE-LIST) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Insert the entry <'key', 'value'> into the association
'self'. If a previous entry existed with key 'key', that entry is replaced.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-AT"
        "KEY-VALUE-LIST"
        "(DEFMETHOD (REMOVE-AT OBJECT) ((SELF KEY-VALUE-LIST) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Remove the entry that matches the key 'key'.
Return the value of the matching entry, or NULL if there is no matching entry.
Assumes that at most one entry matches 'key'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REMOVE-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-ENTRY"
        "KEY-VALUE-LIST"
        "(DEFMETHOD INSERT-ENTRY ((SELF KEY-VALUE-LIST) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Insert an entry <'key','value'> to 'self' unless an identical
entry already exists.  This can generate duplicate entries for 'key'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT-ENTRY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-ENTRY"
        "KEY-VALUE-LIST"
        "(DEFMETHOD REMOVE-ENTRY ((SELF KEY-VALUE-LIST) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Remove the entry that matches <'key','value'>.
Assumes that more than one entry can match 'key'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REMOVE-ENTRY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POP"
        "KEY-VALUE-LIST"
        "(DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ((SELF KEY-VALUE-LIST)) :DOCUMENTATION \"Remove and return the first element of the kv-list 'self'.
Return NULL if the list is empty.\")")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION POP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REVERSE"
        "KEY-VALUE-LIST"
        "(DEFMETHOD (REVERSE (LIKE SELF)) ((SELF KEY-VALUE-LIST)) :DOCUMENTATION \"Destructively reverse the members of the list 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REVERSE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EMPTY?"
        "KEY-VALUE-LIST"
        "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF KEY-VALUE-LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NON-EMPTY?"
        "KEY-VALUE-LIST"
        "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF KEY-VALUE-LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NON-EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY-KV-CONS-LIST"
        "KV-CONS"
        "(DEFUN (COPY-KV-CONS-LIST KV-CONS) ((KVCONSLIST KV-CONS)) :DOCUMENTATION \"Return a copy of the cons list 'consList'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COPY-KV-CONS-LIST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY"
        "KEY-VALUE-LIST"
        "(DEFMETHOD (COPY (LIKE SELF)) ((SELF KEY-VALUE-LIST)) :DOCUMENTATION \"Return a copy of the kv-list 'self'.  The kv-conses in
the copy are freshly allocated.\")")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION COPY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR"
        "KEY-VALUE-LIST"
        "(DEFMETHOD CLEAR ((SELF KEY-VALUE-LIST)) :DOCUMENTATION \"Make 'self' an empty dictionary.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CLEAR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-ITERATOR"
        "KEY-VALUE-LIST"
        "(DEFMETHOD (ALLOCATE-ITERATOR KV-LIST-ITERATOR) ((SELF KEY-VALUE-LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ALLOCATE-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "KV-LIST-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF KV-LIST-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VALUE-SETTER"
        "KV-LIST-ITERATOR"
        "(DEFMETHOD (VALUE-SETTER OBJECT) ((SELF KV-LIST-ITERATOR) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION VALUE-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MEMBER?"
        "SEQUENCE"
        "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF SEQUENCE) (VALUE OBJECT)) :DOCUMENTATION \"Return TRUE if 'value' is a member of the sequence 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MEMBER?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LIST"
        "ARGUMENT-LIST"
        "(DEFUN (LIST LIST) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a list containing 'values', in order.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LIST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SEQUENCE"
        "TYPE"
        "(DEFUN (SEQUENCE (SEQUENCE OF OBJECT)) ((COLLECTIONTYPE TYPE) |&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a sequence containing 'values', in order.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SEQUENCE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DICTIONARY"
        "TYPE"
        "(DEFUN (DICTIONARY (DICTIONARY OF OBJECT OBJECT)) ((COLLECTIONTYPE TYPE) |&REST| (ALTERNATINGKEYSANDVALUES OBJECT)) :DOCUMENTATION \"Return a dictionary containing 'values', in order.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DICTIONARY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LISTIFY"
        "ITERATOR"
        "(DEFMETHOD (LISTIFY LIST) ((SELF ITERATOR)) :DOCUMENTATION \"Return a list of elements generated by 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LISTIFY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KEY-VALUE-LIST"
        "KEY-VALUE-LIST"
        "(DEFUN PRINT-KEY-VALUE-LIST ((SELF KEY-VALUE-LIST) (STREAM NATIVE-OUTPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KEY-VALUE-LIST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-CONS-LIST"
        "CONS"
        "(DEFUN PRINT-CONS-LIST ((LIST CONS) (STREAM NATIVE-OUTPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-CONS-LIST)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-LISTS"
     NULL
     "(DEFUN STARTUP-LISTS ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NIL-LIST LIST NULL)")
    (SET-DYNAMIC-SLOT-VALUE
     (LOOKUP-SLOT
      (CLSYS-SVAL
       SURROGATE
       SURROGATE-VALUE
       SGT-LISTS-ABSTRACT-DICTIONARY-ITERATOR)
      SYM-LISTS-KEY)
     SYM-LISTS-SLOT-WRITER
     SYM-LISTS-KEY-SETTER
     NULL)
    (SET-DYNAMIC-SLOT-VALUE
     (LOOKUP-SLOT
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-LISTS-ABSTRACT-ITERATOR)
      SYM-LISTS-VALUE)
     SYM-LISTS-SLOT-WRITER
     SYM-LISTS-VALUE-SETTER
     NULL)
    (SET-DYNAMIC-SLOT-VALUE
     (LOOKUP-SLOT
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-LISTS-ABSTRACT-ITERATOR)
      SYM-LISTS-VALUE)
     SYM-LISTS-SLOT-WRITER
     SYM-LISTS-VALUE-SETTER
     NULL)
    (SET-DYNAMIC-SLOT-VALUE
     (LOOKUP-SLOT
      (CLSYS-SVAL
       SURROGATE
       SURROGATE-VALUE
       SGT-LISTS-ABSTRACT-DICTIONARY-ITERATOR)
      SYM-LISTS-KEY)
     SYM-LISTS-SLOT-WRITER
     SYM-LISTS-KEY-SETTER
     NULL)
    (SET-DYNAMIC-SLOT-VALUE
     (LOOKUP-SLOT
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-LISTS-ABSTRACT-ITERATOR)
      SYM-LISTS-VALUE)
     SYM-LISTS-SLOT-WRITER
     SYM-LISTS-VALUE-SETTER
     NULL)))
  :VOID)
