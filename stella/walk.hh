// walk.hh

/*--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------*/

// Class headers:
class Translation_Unit;

// Function signatures:
void display_environment_features();
void enable_environment_feature(int features, ...);
void disable_environment_feature(int features, ...);
void reset_environment_features();
Object* trace_if_expander(Keyword* keyword, Cons* body);
boolean trace_keywordP(Keyword* keyword);
List* add_trace(Cons* keywords);
List* add_trace_evaluator_wrapper(Cons* arguments);
List* drop_trace(Cons* keywords);
List* drop_trace_evaluator_wrapper(Cons* arguments);
void clear_trace();
char* name_quoted_tree(Cons* tree);
Cons* get_quoted_tree(char* treename, char* modulename);
Translation_Unit* new_translation_unit();
Object* access_translation_unit_slot_value(Translation_Unit* self, Symbol* slotname, Object* value, boolean setvalueP);
boolean terminate_translation_unitP(Translation_Unit* self);
void print_translation_unit(Translation_Unit* self, ostream* stream);
List* read_OtranslationunitsO();
List* write_OtranslationunitsO(List* value);
Translation_Unit* read_OcurrenttranslationunitO();
Translation_Unit* write_OcurrenttranslationunitO(Translation_Unit* value);
Keyword* read_OtranslationphaseO();
Keyword* write_OtranslationphaseO(Keyword* value);
int read_OtranslationverbositylevelO();
int write_OtranslationverbositylevelO(int value);
boolean read_OusehardcodedsymbolsPO();
boolean write_OusehardcodedsymbolsPO(boolean value);
boolean use_hardcoded_symbolsP();
boolean use_bootstrap_translatorP();
Keyword* toggle_translators();
boolean translate_to_common_lispP();
boolean translate_to_single_inheritance_languageP();
Keyword* toggle_output_language();
boolean declaration_operatorP(Symbol* renamed_Operator);
boolean declaration_treeP(Cons* tree);
char* create_annotation(Cons* top_level_tree);
void walk_top_level_tree(Cons* tree, boolean createannotationP);
Object* walk_top_level_expression(Object* tree);
void walk_phase_one_unit(Translation_Unit* unit);
void walk_auxiliary_tree(Cons* tree);
Translation_Unit* help_walk_auxiliary_tree(Cons* tree, boolean finalizeP);
void walk_all_phase_one_units(Symbol* startupfnname);
void translate_all_units();
Cons* combine_translated_trees();
Object* translate_walked_tree(Object* codetree);
Key_Value_List* read_OlocalvariabletypetableO();
Key_Value_List* write_OlocalvariabletypetableO(Key_Value_List* value);
Method_Slot* read_OmethodbeingwalkedO();
Method_Slot* write_OmethodbeingwalkedO(Method_Slot* value);
boolean read_OfoundreturnPO();
boolean write_OfoundreturnPO(boolean value);
Standard_Object* read_OtargettypeO();
Standard_Object* write_OtargettypeO(Standard_Object* value);
Key_Value_List* read_OlocalgensymtableO();
Key_Value_List* write_OlocalgensymtableO(Key_Value_List* value);
Keyword* translator_output_language();
Keyword* set_translator_output_language(Keyword* newlanguage);
int read_OtranslationerrorsO();
int write_OtranslationerrorsO(int value);
int read_OtranslationwarningsO();
int write_OtranslationwarningsO(int value);
void reset_translation_errors();
void signal_translation_error();
void signal_translation_warning();
boolean read_OignoretranslationerrorsPO();
boolean write_OignoretranslationerrorsPO(boolean value);
boolean ignore_translation_errorsP();
boolean translation_errorsP();
void summarize_translation_errors();
void print_error_context(char* prefix, Output_Stream* stream);
void push_variable_binding(Symbol* variable, Standard_Object* type);
void pop_variable_binding();
Standard_Object* lookup_variable_type(Symbol* variablename);
void register_reference_to_global_variable(Symbol* variablename);
Symbol* local_gensym(char* prefix);
void free_transient_type_spec(Standard_Object* self);
boolean suppress_warningsP();
boolean bad_argument_rangeP(Cons* tree, int minarity, int maxarity);
boolean bad_argument_countP(Cons* tree, int arity);
Cons* yield_illegal_statement_tree();
Object* yield_illegal_expression_tree();
Cons* walk_dont_call_me_tree(Object* tree, Standard_Object* returntype, Standard_Object*& return1);
boolean illegal_treeP(Object* tree);
boolean native_class_method_inliningP();
Object* prognify(Cons* trees);
Object* optimize_progn(Cons* progn_tree);
Cons* tree_to_trees(Object* tree);
Surrogate* wrapped_type_to_type(Surrogate* self);
Surrogate* wrapper_value_type(Wrapper* self);
Symbol* lookup_coersion_method(Surrogate* sourcetype, Surrogate* targettype, Object* expression);
boolean translating_codeP();
Surrogate* verify_type(Surrogate* self);
boolean safe_subtype_ofP(Surrogate* subtype, Surrogate* supertype);
void warn_about_unknown_source_type(Object* tree);
Object* coerce_a_tree(Object* tree, Standard_Object* sourcetype, Standard_Object* targettype, Standard_Object*& return1);
Object* help_coerce_a_tree(Object* tree, Standard_Object* sourcetype, Standard_Object* targettype, boolean testonlyP, Standard_Object*& return1, boolean& return2);
boolean coercibleP(Object* tree, Standard_Object* sourcetype, Standard_Object* targettype);
boolean walking_expressionP();
Object* walk_expression_tree(Object* exptree, Standard_Object* targettype, Symbol* operatorname, boolean vrletisokP, Standard_Object*& return1);
Object* walk_without_type_tree(Object* tree);
Cons* walk_list_of_trees(Cons* trees);
Object* walk_statement(Object* tree, boolean warnonatomP);
Cons* eliminate_vrlet_statement(Cons* tree);
Cons* sys_tree(Object* tree, Standard_Object* typespec, Standard_Object*& return1);
Standard_Object* walked_expression_type(Object* tree);
boolean need_identical_method_signaturesP();
Standard_Object* compute_most_general_return_type(Method_Slot* method, Standard_Object* returntype);
Standard_Object* compute_real_slot_type(Storage_Slot* slot, Standard_Object* firstargtype, Standard_Object* returntype);
Object* sys_tree_if_needed(Slot* slot, Object* tree, Standard_Object* firstargtype, Standard_Object* returntype, Standard_Object*& return1);
Surrogate* target_language_type(Object* tree);
Cons* set_target_language_type(Cons* systree, Surrogate* type, Standard_Object*& return1);
Cons* delete_null_statements(Cons* trees);
Object* walk_a_tree(Object* tree, Standard_Object*& return1);
Object* help_walk_a_tree(Object* tree, Standard_Object*& return1);
Cons* walk_a_cons_tree(Cons* tree, Standard_Object*& return1);
char* read_OcurrentfileO();
char* write_OcurrentfileO(char* value);
boolean incremental_translationP();
Symbol* yield_symbol_constant_name(Generalized_Symbol* symbol);
Symbol* create_startup_symbol(Generalized_Symbol* symbol);
void register_symbol(Generalized_Symbol* symbol);
void clear_symbol_registry();
Cons* yield_hardcoded_intern_registered_symbols_tree();
Surrogate* lookup_constant_symbol(Symbol* self);
boolean constant_symbolP(Symbol* symbol);
Symbol* walk_constant_symbol(Symbol* self, Surrogate*& return1);
boolean vrlet_expressionP(Object* tree);
boolean procedural_expressionP(Object* tree);
boolean substitute_once(Object* expression, Object* newtree, Object* oldtree);
Cons* transform_vrlet_expression(Cons* statement, Cons* vrexpression, Standard_Object*& return1);
Cons* help_transform_boolean_procedural_expression(Object* expression, Symbol* testvariable);
Cons* transform_boolean_procedural_expression(Cons* statement, Cons* vrexpression, Standard_Object*& return1);
Cons* percolate_out_boolean_vrlet_expressions(Cons* booleanexpression);
Cons* transform_procedural_expression(Cons* statement, Cons* vrexpression, Standard_Object* type, Standard_Object*& return1);
Cons* percolate_out_vrlet_expression(Cons* statement, Cons* vrexpression, Standard_Object* type, Standard_Object*& return1);
Cons* walk_setq_tree(Cons* tree, Standard_Object*& return1);
Cons* yield_fixed_slot_value_setter_tree(Slot* slot, Object* objectref, Object* valuetree);
Cons* walk_setf_tree(Cons* tree, Standard_Object*& return1);
Cons* yield_dynamic_slot_value_tree(Storage_Slot* slot, Object* objectref, Standard_Object* returntype);
Cons* yield_dynamic_slot_value_setter_tree(Storage_Slot* slot, Object* objectref, Object* valueref, Standard_Object* returntype);
Cons* yield_native_slot_value_tree(Storage_Slot* slot, Object* objectref, Standard_Object* objecttype);
Cons* yield_context_sensitive_slot_value_tree(Storage_Slot* slot, Object* objectref, Standard_Object* returntype, Cons* csoptions, Standard_Object*& return1);
Cons* yield_slot_value_tree(Storage_Slot* slot, Object* objectref, Standard_Object* objecttype, Standard_Object* returntype, Cons* csoptions, Standard_Object*& return1);
Cons* walk_slot_value_tree(Cons* tree, Standard_Object*& return1);
Cons* yield_native_slot_value_setter_tree(Storage_Slot* slot, Object* objectref, Standard_Object* objecttype, Object* valueref);
Cons* yield_context_sensitive_slot_value_setter_tree(Storage_Slot* slot, Object* objectref, Object* valueref, Standard_Object* returntype, Cons* csoptions, Standard_Object*& return1);
Cons* yield_slot_value_setter_tree(Storage_Slot* slot, Object* objectref, Standard_Object* objecttype, Object* valueref, Standard_Object* returntype, Cons* csoptions, Standard_Object*& return1);
Cons* walk_slot_value_setter_tree(Cons* tree, Standard_Object*& return1);
Standard_Object* safe_yield_type_specifier(Object* typetree);
Cons* walk_a_declaration(Symbol* variable, Object* typetree, Object* value, boolean inputparameterP);
Cons* walk_variable_declarations(Cons* declarations);
Cons* transform_let_with_procedural_expression(Cons* tree);
void pop_local_variable_bindings(Cons* declarations);
Cons* walk_let_tree(Cons* tree, Standard_Object*& return1);
Key_Value_List* read_OspecialvariablestackO();
Key_Value_List* write_OspecialvariablestackO(Key_Value_List* value);
boolean read_OspecialsenabledPO();
boolean write_OspecialsenabledPO(boolean value);
int read_OnofspecialsatloopentryO();
int write_OnofspecialsatloopentryO(int value);
Keyword* special_implementation_style();
void push_special(Symbol* variable, Symbol* oldvaluevariable);
void pop_special();
Symbol* lookup_old_value_variable(Symbol* variable);
boolean need_to_unbind_specialsP();
Cons* yield_special_unbind_tree(int nofbindings);
Cons* yield_return_special_unbind_tree();
Cons* yield_loop_exit_special_unbind_tree();
Cons* walk_special_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_cl_special_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_save_and_restore_special_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_protected_save_and_restore_special_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_cast_tree(Cons* tree, Standard_Object*& return1);
boolean values_treeP(Object* tree);
Cons* walk_values_tree(Cons* tree, Standard_Object*& return1);
Object* walk_mv_expression_tree(Object* tree, List* targettypes, Symbol* renamed_Operator, Cons*& return1, List*& return2);
List* listify_type_spec(Standard_Object* typespec);
Slot* slot_from_expression_tree(Cons* tree);
Object* walk_mv_tree(Object* tree, Cons*& return1, List*& return2);
Cons* walk_mv_values_tree(Cons* tree, Cons*& return1, List*& return2);
Object* coerce_mv_tree(Object* tree, Symbol* renamed_Operator, List* sourcetypes, List* targettypes, Cons*& return1, List*& return2);
Cons* walk_return_and_unbind_specials(Cons* tree, Standard_Object*& return1);
Cons* walk_return_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_mv_setq_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_mv_bind_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_loop_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_loop_exit_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_while_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_conditional_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_choose_tree(Cons* tree, Standard_Object*& return1);
Object* walk_boolean_tree(Cons* tree, Standard_Object*& return1);
boolean and_or_not_treeP(Object* tree);
Object* help_walk_boolean_tree(Cons* tree);
Cons* walk_cond_tree(Cons* tree, Standard_Object*& return1);
Cons* cond_tree_to_if_tree(Cons* tree);
Object* yield_hardcoded_case_symbol_id_or_ids(Object* casetest);
Cons* walk_hardcoded_symbol_case_tree(Cons* tree, Standard_Object*& return1);
Cons* yield_cond_test(Object* casetest, Symbol* testvariable, Symbol* equalitytest);
Object* yield_cond_test_or_tests(Object* casetest, Symbol* testvariable, Symbol* equalitytest);
Cons* walk_non_built_in_case_tree(Cons* tree, Symbol* equalitytest, Standard_Object*& return1);
Cons* walk_case_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_typecase_tree(Cons* tree, Standard_Object*& return1);
Cons* finish_walking_eql_tree(Cons* tree, Surrogate* type1, Surrogate* type2, Standard_Object*& return1);
Cons* finish_walking_equal_tree(Cons* tree, Surrogate* type1, Surrogate* type2, Standard_Object*& return1);
Object* walk_equality_tree(Cons* tree, Standard_Object*& return1);
Surrogate* more_general_numeric_type(Surrogate* type1, Surrogate* type2);
Cons* yield_arithmetic_operator_call_tree(Symbol* renamed_Operator, Cons* operands);
Cons* yield_nested_arithmetic_operator_call_tree(Symbol* renamed_Operator, Cons* operands);
Object* walk_arithmetic_tree(Cons* tree, Surrogate*& return1);
Object* walk_quoted_tree(Cons* tree, Standard_Object*& return1);
Object* walk_bquote_tree(Cons* tree, Standard_Object*& return1);
Object* expand_macro(Cons* tree);
Object* walk_macro_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_print_stream_tree(Cons* tree, Standard_Object*& return1);
boolean warn_about_undefined_methodsP();
boolean warn_about_missing_methodsP();
Cons* walk_undefined_slot_tree(Cons* tree, Standard_Object* firstargtype, boolean warnP, Surrogate*& return1);
Cons* walk_slot_on_abstract_type_tree(Cons* tree, Surrogate* abstracttype, Standard_Object*& return1);
Method_Slot* find_prototype_method(Symbol* methodname, Surrogate* abstracttype);
int compatible_real_methods(Method_Slot* prototypemethod, Surrogate* abstracttype, int& return1, boolean& return2);
Cons* yield_listified_variable_arguments(Cons* walkedargs, Standard_Object* targettype, boolean wrapargsP);
Cons* walk_variable_arguments(Cons* arguments, Method_Slot* method);
Cons* quote_arguments(Method_Slot* method, Cons* arguments);
Standard_Object* walk_first_argument_to_function(Method_Slot* fnslot, Cons* tree);
Object* walk_call_slot_tree(Cons* tree, Standard_Object*& return1);
Cons* yield_synthesized_method_body(Translation_Unit* unit);
boolean pass_variable_arguments_as_listP(Method_Slot* method);
void toggle_variable_arguments_type(Method_Slot* method);
Standard_Object* variable_arguments_type(Method_Slot* method);
Cons* walk_method_object(Translation_Unit* unit);
void walk_defmethod_tree(Cons* tree);
Cons* yield_initialize_slot_writer(Method_Slot* method);
void walk_method_unit(Translation_Unit* unit);
Cons* walk_sys_call_tree(Cons* tree, Standard_Object*& return1);
void walk_defclass_tree(Cons* tree);
Cons* yield_initialize_hardwired_slots(Class* renamed_Class);
Object* yield_initial_value_expression(Storage_Slot* slot);
Cons* yield_constructor_attachment(Class* renamed_Class, Symbol* classref);
void clear_slot_accessor_methods(Storage_Slot* slot);
void register_slot_accessor_method(Storage_Slot* slot, Method_Slot* method);
void create_accessor_units_for_slot(Storage_Slot* slot, Class* renamed_Class, boolean nativeaccessorsP, boolean signaturesonlyP);
void create_accessor_units_for_mixin_slot(Storage_Slot* slot, Class* renamed_Class);
void create_slot_accessor_units(Class* renamed_Class);
void create_inline_method_units(Class* renamed_Class);
void create_defprint_unit(Class* renamed_Class);
void walk_class_unit(Translation_Unit* unit);
void create_finalization_units();
void walk_defslot_tree(Cons* tree);
void walk_slot_unit(Translation_Unit* unit);
Method_Slot* lookup_macro(Symbol* name);
void store_macro(Symbol* name, Symbol* expandername, cpp_function_code expandercode);
Symbol* yield_macro_expander_function_name(Symbol* macroname);
void walk_defmacro_tree(Cons* tree);
void walk_macro_unit(Translation_Unit* unit);
void walk_defglobal_tree(Cons* tree);
void walk_global_unit(Translation_Unit* unit);
void walk_deftype_tree(Cons* tree);
void walk_type_unit(Translation_Unit* unit);
void walk_startup_time_progn_tree(Cons* tree);
Keyword* extract_startup_time_phase(Cons* tree);
void walk_startup_time_progn_unit(Translation_Unit* unit);
Cons* combine_startup_function_units();
void create_startup_function_unit(Symbol* startupfnname);
boolean dont_generate_startup_codeP();
void remove_all_startup_time_progn_units();
boolean use_stella_exceptionsP();
boolean read_OpendingexceptionhandlerPO();
boolean write_OpendingexceptionhandlerPO(boolean value);
void signal(Exception* exception);
void resignal();
Cons* walk_exception_case_tree(Cons* tree, Standard_Object*& return1);
boolean lexically_visible_exception_caseP();
Cons* yield_protected_statement_tree(Object* tree, boolean unwindprotectP);
Cons* yield_exception_handler_tree(Cons* tree);
void walk_verbatim_definition_tree(Cons* tree);
void walk_verbatim_unit(Translation_Unit* unit);
Object* walk_verbatim_tree(Cons* tree, Standard_Object*& return1);
void walk_defmodule_tree(Cons* tree);
void walk_module_unit(Translation_Unit* unit);
Cons* extract_required_argument_values(Class* renamed_Class, Property_List* slotnamesandvalues);
Cons* yield_new_arguments_tree(Cons* keywordsandvalues, Class* renamed_Class, Symbol* selfvariable, Cons*& return1);
Cons* walk_new_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_make_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_funcall_tree(Cons* tree, Standard_Object*& return1);
Cons* walk_the_code_tree(Cons* tree, Standard_Object*& return1);
Cons* de_uglify_arguments(Cons* uglyarguments);
Object* de_uglify_parse_tree(Object* tree);
void register_native_name(Symbol* name, Keyword* language, Keyword* category);
boolean native_nameP(Symbol* name, Keyword* language, Keyword* category);
Symbol* yield_renamed_name_if_native(Symbol* name, Keyword* language, Keyword* category);
boolean method_needs_lisp_macroP(Method_Slot* method);
Cons* yield_lisp_macro_trees(Symbol* name, Method_Slot* method, Cons*& return1);
void create_lisp_macro_units(Symbol* name, Method_Slot* method);
boolean commandP(Method_Slot* method);
Method_Slot* lookup_command(Symbol* name);
boolean method_must_be_evaluableP(Method_Slot* method);
boolean method_needs_evaluator_wrapperP(Method_Slot* method);
Symbol* yield_evaluator_wrapper_name(Symbol* methodname);
Object* yield_argument_access_tree(Symbol* argumentsvariable, int index, boolean restargumentP);
Cons* yield_evaluator_wrapper_tree(Method_Slot* method);
void create_evaluator_wrapper_unit(Method_Slot* method);
boolean read_OevaluationerrorPO();
boolean write_OevaluationerrorPO(boolean value);
void reset_evaluation_error();
void signal_evaluation_error();
boolean evaluation_errorP();
Object* read_OevaluationtreeO();
Object* write_OevaluationtreeO(Object* value);
Object* read_OevaluationparenttreeO();
Object* write_OevaluationparenttreeO(Object* value);
void print_evaluation_error_context(char* prefix, Output_Stream* stream);
Object* evaluate(Object* expression, Standard_Object*& return1, boolean& return2);
Object* evaluate_string(char* expression, Standard_Object*& return1, boolean& return2);
Object* try_to_evaluate(Object* tree, Standard_Object*& return1, boolean& return2);
Object* evaluate_cons_tree(Cons* tree, Standard_Object*& return1);
Object* evaluate_argument_tree(Object* tree, boolean evaluateP, Standard_Object*& return1);
Object* evaluate_atomic_tree(Object* tree, Standard_Object*& return1);
Object* coerce_evaluated_tree(Object* tree, Object* sourcetree, Standard_Object* sourcetype, Standard_Object* targettype, boolean evaluateP, Standard_Object*& return1);
void startup_walk();

// Global declarations:
extern List* oAVAILABLE_ENVIRONMENT_FEATURESo;
extern Keyword* KWD_WALK_WARN_ABOUT_UNDEFINED_METHODS;
extern Keyword* KWD_WALK_SUPPRESS_WARNINGS;
extern Keyword* KWD_WALK_USE_BOOTSTRAP_TRANSLATOR;
extern Keyword* KWD_WALK_WARN_ABOUT_MISSING_METHODS;
extern Keyword* KWD_WALK_USE_HARDCODED_SYMBOLS;
extern Keyword* KWD_WALK_USE_COMMON_LISP_STRUCTS;
extern Keyword* KWD_WALK_USE_COMMON_LISP_VECTOR_STRUCTS;
extern Keyword* KWD_WALK_USE_CPP_GARBAGE_COLLECTOR;
extern Keyword* KWD_WALK_TRANSLATE_WITH_COPYRIGHT_HEADER;
extern List* oCURRENT_ENVIRONMENT_FEATURESo;
extern List* oDEFAULT_ENVIRONMENT_FEATURESo;
extern List* oTRACED_KEYWORDSo;
extern Symbol* SYM_WALK_WHEN;
extern Symbol* SYM_WALK_AND;
extern Symbol* SYM_WALK_DEFINEDp;
extern Symbol* SYM_WALK_oTRACED_KEYWORDSo;
extern Symbol* SYM_WALK_MEMBERp;
extern Symbol* SYM_WALK_PRINT;
extern Symbol* SYM_WALK_TRACE_IF;
extern Symbol* SYM_WALK_TRACE_IF_EXPANDER;
extern Symbol* SYM_WALK_EVALUATOR_WRAPPER_CODE;
extern String_Hash_Table* oQUOTATION_TABLEo;
extern Translation_Unit* oRECYCLED_TRANSLATION_UNIT_So;
extern Symbol* SYM_WALK_THE_OBJECT;
extern Symbol* SYM_WALK_CATEGORY;
extern Symbol* SYM_WALK_ANNOTATION;
extern Symbol* SYM_WALK_AUXILIARYp;
extern Symbol* SYM_WALK_CODE_REGISTER;
extern Symbol* SYM_WALK_TRANSLATION;
extern Symbol* SYM_WALK_REFERENCED_GLOBALS;
extern Surrogate* SGT_WALK_TRANSLATION_UNIT;
extern Symbol* SYM_WALK_CLASS;
extern Symbol* SYM_WALK_METHOD;
extern Symbol* SYM_WALK_MACRO;
extern Symbol* SYM_WALK_GLOBAL_VARIABLE;
extern List* oTRANSLATIONUNITSo;
extern Symbol* SYM_WALK_oTRANSLATIONUNITSo;
extern Translation_Unit* oCURRENTTRANSLATIONUNITo;
extern Symbol* SYM_WALK_oCURRENTTRANSLATIONUNITo;
extern Keyword* oTRANSLATIONPHASEo;
extern Symbol* SYM_WALK_oTRANSLATIONPHASEo;
extern int oTRANSLATIONVERBOSITYLEVELo;
extern Symbol* SYM_WALK_oTRANSLATIONVERBOSITYLEVELo;
extern boolean oUSEHARDCODEDSYMBOLSpo;
extern Symbol* SYM_WALK_oUSEHARDCODEDSYMBOLSpo;
extern Keyword* KWD_WALK_REAL;
extern Keyword* KWD_WALK_BOOTSTRAP;
extern Keyword* KWD_WALK_COMMON_LISP;
extern Keyword* KWD_WALK_JAVA;
extern Keyword* KWD_WALK_CPP;
extern Symbol* SYM_WALK_PROGN;
extern Symbol* SYM_WALK_DEFCLASS;
extern Symbol* SYM_WALK_DEFSLOT;
extern Symbol* SYM_WALK_DEFMETHOD;
extern Symbol* SYM_WALK_DEFUN;
extern Symbol* SYM_WALK_DEFOPERATOR;
extern Symbol* SYM_WALK_DEFGLOBAL;
extern Symbol* SYM_WALK_DEFSPECIAL;
extern Symbol* SYM_WALK_DEFCONSTANT;
extern Symbol* SYM_WALK_DEFTYPE;
extern Symbol* SYM_WALK_DEFMODULE;
extern Symbol* SYM_WALK_DEFMACRO;
extern Symbol* SYM_WALK_STARTUP_TIME_PROGN;
extern Symbol* SYM_WALK_VERBATIM;
extern Symbol* SYM_WALK_MODULE;
extern Symbol* SYM_WALK_TYPE;
extern Symbol* SYM_WALK_PRINT_METHOD;
extern Symbol* SYM_WALK_SLOT;
extern Keyword* KWD_WALK_IDL;
extern Keyword* KWD_WALK_CPP_STANDALONE;
extern Key_Value_List* oLOCALVARIABLETYPETABLEo;
extern Symbol* SYM_WALK_oLOCALVARIABLETYPETABLEo;
extern Method_Slot* oMETHODBEINGWALKEDo;
extern Symbol* SYM_WALK_oMETHODBEINGWALKEDo;
extern boolean oFOUNDRETURNpo;
extern Symbol* SYM_WALK_oFOUNDRETURNpo;
extern Standard_Object* oTARGETTYPEo;
extern Surrogate* SGT_WALK_VOID;
extern Symbol* SYM_WALK_oTARGETTYPEo;
extern Key_Value_List* oLOCALGENSYMTABLEo;
extern Symbol* SYM_WALK_oLOCALGENSYMTABLEo;
extern int oTRANSLATIONERRORSo;
extern Symbol* SYM_WALK_oTRANSLATIONERRORSo;
extern int oTRANSLATIONWARNINGSo;
extern Symbol* SYM_WALK_oTRANSLATIONWARNINGSo;
extern boolean oIGNORETRANSLATIONERRORSpo;
extern Symbol* SYM_WALK_oIGNORETRANSLATIONERRORSpo;
extern Keyword* KWD_WALK_DEFINE;
extern Keyword* KWD_WALK_FINALIZE;
extern Keyword* KWD_WALK_WALK;
extern Keyword* KWD_WALK_TRANSLATE;
extern Surrogate* SGT_WALK_GLOBAL_VARIABLE;
extern Surrogate* SGT_WALK_TYPE_SPEC;
extern Surrogate* SGT_WALK_MODULE;
extern Surrogate* SGT_WALK_UNINITIALIZED;
extern Surrogate* SGT_WALK_UNKNOWN;
extern Symbol* SYM_WALK_NULL;
extern Symbol* SYM_WALK_ERROR;
extern Symbol* SYM_WALK_EOL;
extern Symbol* SYM_WALK_ILLEGAL_EXPRESSION_FLAGGED_BY_THE_TRANSLATOR;
extern Symbol* SYM_WALK_BAD_SYS;
extern Cons* oWRAPPED_TYPE_TABLEo;
extern Surrogate* SGT_WALK_INTEGER_WRAPPER;
extern Surrogate* SGT_WALK_INTEGER;
extern Surrogate* SGT_WALK_TRANSIENT_INTEGER_WRAPPER;
extern Surrogate* SGT_WALK_FLOAT_WRAPPER;
extern Surrogate* SGT_WALK_FLOAT;
extern Surrogate* SGT_WALK_TRANSIENT_FLOAT_WRAPPER;
extern Surrogate* SGT_WALK_NUMBER_WRAPPER;
extern Surrogate* SGT_WALK_NUMBER;
extern Surrogate* SGT_WALK_STRING_WRAPPER;
extern Surrogate* SGT_WALK_STRING;
extern Surrogate* SGT_WALK_TRANSIENT_STRING_WRAPPER;
extern Surrogate* SGT_WALK_CHARACTER_WRAPPER;
extern Surrogate* SGT_WALK_CHARACTER;
extern Surrogate* SGT_WALK_TRANSIENT_CHARACTER_WRAPPER;
extern Surrogate* SGT_WALK_BOOLEAN_WRAPPER;
extern Surrogate* SGT_WALK_BOOLEAN;
extern Surrogate* SGT_WALK_FUNCTION_CODE_WRAPPER;
extern Surrogate* SGT_WALK_FUNCTION_CODE;
extern Surrogate* SGT_WALK_TRANSIENT_FUNCTION_CODE_WRAPPER;
extern Surrogate* SGT_WALK_METHOD_CODE_WRAPPER;
extern Surrogate* SGT_WALK_METHOD_CODE;
extern Surrogate* SGT_WALK_TRANSIENT_METHOD_CODE_WRAPPER;
extern Surrogate* SGT_WALK_OBJECT;
extern Cons* oCOERSION_TABLEo;
extern Symbol* SYM_WALK_WRAP_BOOLEAN;
extern Symbol* SYM_WALK_WRAP_LITERAL;
extern Symbol* SYM_WALK_INTEGER_TO_BOOLEAN_WRAPPER;
extern Symbol* SYM_WALK_INTEGER_TO_BOOLEAN;
extern Surrogate* SGT_WALK_SYMBOL;
extern Symbol* SYM_WALK_INTERN_SYMBOL;
extern Symbol* SYM_WALK_SYMBOL_NAME;
extern Symbol* SYM_WALK_WRAPPER_VALUE;
extern Surrogate* SGT_WALK_SURROGATE;
extern Surrogate* SGT_WALK_CLASS;
extern Symbol* SYM_WALK_SURROGATE_VALUE;
extern Surrogate* SGT_WALK_INPUT_STREAM;
extern Surrogate* SGT_WALK_NATIVE_INPUT_STREAM;
extern Symbol* SYM_WALK_NATIVE_STREAM;
extern Surrogate* SGT_WALK_OUTPUT_STREAM;
extern Surrogate* SGT_WALK_NATIVE_OUTPUT_STREAM;
extern Symbol* SYM_WALK_IDENTITY;
extern Surrogate* SGT_WALK_SINGLE_FLOAT;
extern Surrogate* SGT_WALK_DOUBLE_FLOAT;
extern Surrogate* SGT_WALK_SHORT_INTEGER;
extern Surrogate* SGT_WALK_LONG_INTEGER;
extern Surrogate* SGT_WALK_UNSIGNED_SHORT_INTEGER;
extern Surrogate* SGT_WALK_UNSIGNED_LONG_INTEGER;
extern Symbol* SYM_WALK_VRLET;
extern Symbol* SYM_WALK_SYS_CALL_METHOD;
extern Symbol* SYM_WALK_SYS_CALL_FUNCTION;
extern Symbol* SYM_WALK_SAFE_CAST;
extern Symbol* SYM_WALK_CAST;
extern Surrogate* SGT_WALK_NON_OBJECT;
extern Surrogate* SGT_WALK_WRAPPER;
extern Symbol* SYM_WALK_LET;
extern Symbol* SYM_WALK_VOID_SYS;
extern Symbol* SYM_WALK_TYPED_SYS;
extern Symbol* SYM_WALK_SLOT_TYPE_SPECIFIER;
extern Surrogate* SGT_WALK_CONS;
extern Symbol* SYM_WALK_SYS_FOREACH;
extern Symbol* SYM_WALK_SETQ;
extern Symbol* SYM_WALK_SETF;
extern Symbol* SYM_WALK_SLOT_VALUE;
extern Symbol* SYM_WALK_SLOT_VALUE_SETTER;
extern Symbol* SYM_WALK_LOOP;
extern Symbol* SYM_WALK_VALUES;
extern Symbol* SYM_WALK_SPECIAL;
extern Symbol* SYM_WALK_SYS_SPECIAL;
extern Symbol* SYM_WALK_RETURN;
extern Symbol* SYM_WALK_MV_SETQ;
extern Symbol* SYM_WALK_MV_BIND;
extern Symbol* SYM_WALK_BREAK;
extern Symbol* SYM_WALK_CONTINUE;
extern Symbol* SYM_WALK_WHILE;
extern Symbol* SYM_WALK_FOREACH;
extern Symbol* SYM_WALK_EXISTS;
extern Symbol* SYM_WALK_FORALL;
extern Symbol* SYM_WALK_SOME;
extern Symbol* SYM_WALK_SETOF;
extern Symbol* SYM_WALK_SET_OF;
extern Symbol* SYM_WALK_SELECT;
extern Symbol* SYM_WALK_IF;
extern Symbol* SYM_WALK_UNLESS;
extern Symbol* SYM_WALK_CHOOSE;
extern Symbol* SYM_WALK_OR;
extern Symbol* SYM_WALK_NOT;
extern Symbol* SYM_WALK_COND;
extern Symbol* SYM_WALK_CASE;
extern Symbol* SYM_WALK_TYPECASE;
extern Symbol* SYM_WALK_EQp;
extern Symbol* SYM_WALK_EQLp;
extern Symbol* SYM_WALK_e;
extern Symbol* SYM_WALK_i;
extern Symbol* SYM_WALK__;
extern Symbol* SYM_WALK_o;
extern Symbol* SYM_WALK_s;
extern Symbol* SYM_WALK_QUOTE;
extern Symbol* SYM_WALK_BQUOTE;
extern Symbol* SYM_WALK_PRINT_STREAM;
extern Symbol* SYM_WALK_PRINT_NATIVE_STREAM;
extern Symbol* SYM_WALK_NEW;
extern Symbol* SYM_WALK_ALLOCATE;
extern Symbol* SYM_WALK_LOCAL_NEW;
extern Symbol* SYM_WALK_MAKE;
extern Symbol* SYM_WALK_FUNCALL;
extern Symbol* SYM_WALK_SYS_CALL_FUNCTION_CODE;
extern Symbol* SYM_WALK_SYS_CALL_METHOD_CODE;
extern Symbol* SYM_WALK_THE_CODE;
extern Symbol* SYM_WALK_EXCEPTION_CASE;
extern Symbol* SYM_WALK_INLINE;
extern Symbol* SYM_WALK_SYS_SLOT_VALUE;
extern Symbol* SYM_WALK_SYS_SLOT_VALUE_SETTER;
extern Symbol* SYM_WALK_SYS_CALL_METHOD_SETTER;
extern Symbol* SYM_WALK_SYS_NEW;
extern Hash_Table* oSYMBOL_REGISTRYo;
extern List* oSYMBOL_SETo;
extern char* oCURRENTFILEo;
extern Symbol* SYM_WALK_oCURRENTFILEo;
extern Keyword* KWD_WALK_SYMBOLS;
extern Symbol* SYM_WALK_INTERN_RIGID_SYMBOL_WRT_MODULE;
extern Symbol* SYM_WALK_GET_MODULE;
extern Symbol* SYM_WALK_TRUE;
extern Symbol* SYM_WALK_INTERN_SYMBOL_AT;
extern Symbol* SYM_WALK_INTERN_SURROGATE_AT;
extern Symbol* SYM_WALK_INTERN_KEYWORD_AT;
extern Symbol* SYM_WALK_FALSE;
extern Symbol* SYM_WALK_NIL;
extern Symbol* SYM_WALK_NULL_BOOLEAN;
extern Symbol* SYM_WALK_NULL_INTEGER;
extern Symbol* SYM_WALK_NULL_FLOAT;
extern Surrogate* SGT_WALK_KEYWORD;
extern Keyword* KWD_WALK_PLACE_WHERE_VRLET_WAS;
extern Keyword* KWD_WALK_PLACE_WHERE_LAST_EXPRESSION_WAS;
extern Keyword* KWD_WALK_DYNAMIC;
extern Symbol* SYM_WALK_IT;
extern Symbol* SYM_WALK_ON;
extern Symbol* SYM_WALK_DYNAMIC_SLOTS;
extern Symbol* SYM_WALK_WHERE;
extern Symbol* SYM_WALK_KEY;
extern Symbol* SYM_WALK_DO;
extern Symbol* SYM_WALK_WRAPPEDVALUE;
extern Symbol* SYM_WALK_VALUE;
extern Keyword* KWD_WALK_BIT;
extern Symbol* SYM_WALK_DYNAMICSLOTS;
extern Symbol* SYM_WALK_NEWVALUE;
extern Symbol* SYM_WALK_FOUNDMATCHINGENTRYp;
extern Symbol* SYM_WALK_THE_KV_LIST;
extern Symbol* SYM_WALK_KV_CONS;
extern Symbol* SYM_WALK_OLDVALUE;
extern Keyword* KWD_WALK_CONTEXT_SENSITIVEp;
extern Keyword* KWD_WALK_DONT_INHERITp;
extern Symbol* SYM_WALK_ACCESS_IN_CONTEXT;
extern Keyword* KWD_WALK_COPY_TO_CHILDRENp;
extern Symbol* SYM_WALK_UPDATE_IN_CONTEXT;
extern Symbol* SYM_WALK_CS_VALUEp;
extern Symbol* SYM_WALK_VARIABLE_DECLARATION;
extern Symbol* SYM_WALK_ILLEGAL_VARIABLE;
extern Key_Value_List* oSPECIALVARIABLESTACKo;
extern Symbol* SYM_WALK_oSPECIALVARIABLESTACKo;
extern boolean oSPECIALSENABLEDpo;
extern Symbol* SYM_WALK_oSPECIALSENABLEDpo;
extern int oNOFSPECIALSATLOOPENTRYo;
extern Symbol* SYM_WALK_oNOFSPECIALSATLOOPENTRYo;
extern Keyword* KWD_WALK_SAVE_AND_RESTORE;
extern Symbol* SYM_WALK_EXCEPTION;
extern Symbol* SYM_WALK_RESIGNAL;
extern Surrogate* SGT_WALK_METHOD_SLOT;
extern Symbol* SYM_WALK_OTHERWISE;
extern Symbol* SYM_WALK_SYMBOL_ID;
extern Symbol* SYM_WALK_GENERALIZED_SYMBOL;
extern Cons* oTYPE_PREDICATE_TABLEo;
extern Symbol* SYM_WALK_BOOLEANp;
extern Symbol* SYM_WALK_INTEGERp;
extern Symbol* SYM_WALK_FLOATp;
extern Symbol* SYM_WALK_STRINGp;
extern Symbol* SYM_WALK_CHARACTERp;
extern Symbol* SYM_WALK_WRAPPERp;
extern Surrogate* SGT_WALK_VERBATIM_STRING_WRAPPER;
extern Symbol* SYM_WALK_VERBATIM_STRINGp;
extern Symbol* SYM_WALK_SURROGATEp;
extern Surrogate* SGT_WALK_TYPE;
extern Symbol* SYM_WALK_TYPEp;
extern Symbol* SYM_WALK_SYMBOLp;
extern Surrogate* SGT_WALK_TRANSIENT_SYMBOL;
extern Symbol* SYM_WALK_TRANSIENT_SYMBOLp;
extern Symbol* SYM_WALK_KEYWORDp;
extern Symbol* SYM_WALK_CONSp;
extern Symbol* SYM_WALK_CLASSp;
extern Surrogate* SGT_WALK_STORAGE_SLOT;
extern Symbol* SYM_WALK_STORAGE_SLOTp;
extern Symbol* SYM_WALK_METHOD_SLOTp;
extern Surrogate* SGT_WALK_ANCHORED_TYPE_SPECIFIER;
extern Symbol* SYM_WALK_ANCHORED_TYPE_SPECIFIERp;
extern Surrogate* SGT_WALK_PARAMETRIC_TYPE_SPECIFIER;
extern Symbol* SYM_WALK_PARAMETRIC_TYPE_SPECIFIERp;
extern Symbol* SYM_WALK_ISAp;
extern Symbol* SYM_WALK_TAXONOMY_ISAp;
extern Symbol* SYM_WALK_STRING_EQLp;
extern Surrogate* SGT_WALK_STANDARD_OBJECT;
extern Surrogate* SGT_WALK_LITERAL;
extern Symbol* SYM_WALK_EQL_TO_BOOLEANp;
extern Symbol* SYM_WALK_EQL_TO_INTEGERp;
extern Symbol* SYM_WALK_EQL_TO_FLOATp;
extern Symbol* SYM_WALK_EQL_TO_STRINGp;
extern List* oNUMERIC_TYPE_HIERARCHYo;
extern Symbol* SYM_WALK_GET_QUOTED_TREE;
extern Keyword* KWD_WALK_WARN;
extern Keyword* KWD_WALK_ERROR;
extern Keyword* KWD_WALK_CONTINUABLE_ERROR;
extern Symbol* SYM_WALK_CONS;
extern Symbol* SYM_WALK_CONS_LIST;
extern Symbol* SYM_WALK_GET_SYM;
extern Symbol* SYM_WALK_GET_SGT;
extern Symbol* SYM_WALK_GET_KWD;
extern Surrogate* SGT_WALK_ARGUMENT_LIST;
extern Symbol* SYM_WALK_ANY_VALUE;
extern Symbol* SYM_WALK_METHOD_INHERITS_THROUGH;
extern Keyword* KWD_WALK_FUNCTION;
extern Symbol* SYM_WALK_SLOT_WRITER;
extern Symbol* SYM_WALK_LOOKUP_SLOT;
extern Symbol* SYM_WALK_TYPE_CLASS;
extern Symbol* SYM_WALK_STORAGE_SLOT;
extern Keyword* KWD_WALK_METHODS;
extern Symbol* SYM_WALK_FUNCTION_CODE;
extern Symbol* SYM_WALK_METHOD_CODE;
extern Keyword* KWD_WALK_METHOD;
extern Keyword* KWD_WALK_CLASS;
extern Keyword* KWD_WALK_EMBEDDED;
extern Symbol* SYM_WALK_CLASS_CONSTRUCTOR_CODE;
extern Symbol* SYM_WALK_SLOT_ACCESSOR_METHODS;
extern Symbol* SYM_WALK_PRINT_FORM;
extern Symbol* SYM_WALK_PRINT_OBJECT;
extern Symbol* SYM_WALK_SELF;
extern Symbol* SYM_WALK_STREAM;
extern Symbol* SYM_WALK_NATIVE_OUTPUT_STREAM;
extern Keyword* KWD_WALK_CLASSES;
extern Keyword* KWD_WALK_FINALIZE_CLASSES;
extern Symbol* SYM_WALK_FINALIZE_CLASSES;
extern Keyword* KWD_WALK_FINALIZE_METHODS;
extern Symbol* SYM_WALK_FINALIZE_SLOTS;
extern Symbol* SYM_WALK_CLEANUP_UNFINALIZED_CLASSES;
extern Symbol* SYM_WALK_DEFINE_EXTERNAL_SLOT_FROM_STRINGIFIED_SOURCE;
extern Hash_Table* oMACRO_TABLEo;
extern Symbol* SYM_WALK_OBJECT;
extern Symbol* SYM_WALK_METHOD_LISP_MACROp;
extern Symbol* SYM_WALK_STORE_MACRO;
extern Keyword* KWD_WALK_UNBOUND_SPECIAL_VARIABLE;
extern Keyword* KWD_WALK_GLOBALS;
extern Symbol* SYM_WALK_VARIABLE_TYPE_SPECIFIER;
extern Symbol* SYM_WALK_DEFINE_STELLA_GLOBAL_VARIABLE_FROM_STRINGIFIED_SOURCE;
extern Symbol* SYM_WALK_GLOBAL;
extern Symbol* SYM_WALK_LOOKUP_GLOBAL_VARIABLE;
extern Symbol* SYM_WALK_VARIABLE_GET_VALUE_CODE;
extern Symbol* SYM_WALK_VARIABLE_SET_VALUE_CODE;
extern Symbol* SYM_WALK_DEFINE_STELLA_TYPE_FROM_STRINGIFIED_SOURCE;
extern Keyword* KWD_WALK_FINAL;
extern Symbol* SYM_WALK_CURRENT_STARTUP_TIME_PHASEp;
extern Keyword* KWD_WALK_MODULES;
extern Symbol* SYM_WALK_WITHIN_MODULE;
extern Symbol* SYM_WALK_oSTELLA_MODULEo;
extern Keyword* KWD_WALK_AUXILIARYp;
extern jump_buffer oEXCEPTIONHANDLERADDRESSo;
extern boolean oPENDINGEXCEPTIONHANDLERpo;
extern Symbol* SYM_WALK_oPENDINGEXCEPTIONHANDLERpo;
extern Exception* oEXCEPTIONo;
extern Surrogate* oEXCEPTION_TYPEo;
extern Symbol* SYM_WALK_oEXCEPTIONHANDLERADDRESSo;
extern Symbol* SYM_WALK_oEXCEPTIONo;
extern Symbol* SYM_WALK_SETUP_LONG_JUMPp;
extern Surrogate* SGT_WALK_EXCEPTION;
extern Symbol* SYM_WALK_SUBTYPE_OFp;
extern Symbol* SYM_WALK_oEXCEPTION_TYPEo;
extern Keyword* KWD_WALK_OTHERWISE;
extern Surrogate* SGT_WALK_CODE;
extern Symbol* SYM_WALK_MAIN;
extern Surrogate* SGT_WALK_COMPOUND_TYPE_SPECIFIER;
extern Hash_Table* oNATIVE_NAME_TABLEo;
extern Symbol* SYM_WALK_DOCUMENTATION;
extern Symbol* SYM_WALK_EXPRESSION;
extern Symbol* SYM_WALK_IGNORE;
extern Symbol* SYM_WALK_INCREMENTALLY_TRANSLATE;
extern Symbol* SYM_WALK_REGISTER_NATIVE_NAME;
extern Symbol* SYM_WALK_REST;
extern Symbol* SYM_WALK_NTH_REST;
extern Symbol* SYM_WALK_NTH;
extern Symbol* SYM_WALK_ARGUMENTS;
extern Symbol* SYM_WALK_RESULT;
extern Symbol* SYM_WALK_METHOD_EVALUATE_ARGUMENTSp;
extern Symbol* SYM_WALK_METHOD_VARIABLE_ARGUMENTSp;
extern boolean oEVALUATIONERRORpo;
extern Symbol* SYM_WALK_oEVALUATIONERRORpo;
extern Object* oEVALUATIONTREEo;
extern Symbol* SYM_WALK_oEVALUATIONTREEo;
extern Object* oEVALUATIONPARENTTREEo;
extern Symbol* SYM_WALK_oEVALUATIONPARENTTREEo;

class Translation_Unit : public Standard_Object {
public:
  Object* the_object;
  Symbol* category;
  char* annotation;
  boolean auxiliaryP;
  Object* code_register;
  Object* translation;
  List* referenced_globals;
public:
  virtual void print_object(ostream* stream);
  virtual void free();
  virtual Surrogate* primary_type();
};

