;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-MODULES-DESTROY NULL)
(CL:DEFVAR SGT-MODULES-MODULE NULL)
(CL:DEFVAR SYM-MODULES-NAME NULL)
(CL:DEFVAR SYM-MODULES-*SHADOWEDSURROGATES* NULL)
(CL:DEFVAR SYM-MODULES-SHADOWED-SURROGATES NULL)
(CL:DEFVAR KWD-MODULES-INCLUDES NULL)
(CL:DEFVAR KWD-MODULES-USES NULL)
(CL:DEFVAR KWD-MODULES-SHADOW NULL)
(CL:DEFVAR KWD-MODULES-DOCUMENTATION NULL)
(CL:DEFVAR KWD-MODULES-CASE-SENSITIVE? NULL)
(CL:DEFVAR SYM-MODULES-TRUE NULL)
(CL:DEFVAR KWD-MODULES-PACKAGE NULL)
(CL:DEFVAR KWD-MODULES-REQUIRES NULL)
(CL:DEFVAR KWD-MODULES-DIRECTORY-FILE NULL)
(CL:DEFVAR KWD-MODULES-CODE-FILES NULL)
(CL:DEFVAR KWD-MODULES-DEFINITIONS-FILE NULL)
(CL:DEFVAR KWD-MODULES-PRESERVE NULL)
(CL:DEFVAR KWD-MODULES-CLEAR NULL)
(CL:DEFVAR KWD-MODULES-PREORDER NULL)
(CL:DEFVAR SGT-MODULES-WORLD NULL)
(CL:DEFVAR SYM-MODULES-DEFINE-MODULE-FROM-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-MODULES-DEFMODULE NULL)
(CL:DEFVAR KWD-MODULES-COMMON-LISP NULL)
(CL:DEFVAR KWD-MODULES-FUNCTION NULL)
(CL:DEFVAR SYM-MODULES-EVALUATOR-WRAPPER-CODE NULL)
(CL:DEFVAR SYM-MODULES-WORLD-NAME NULL)
(CL:DEFVAR KWD-MODULES-POSTORDER NULL)
(CL:DEFVAR KWD-MODULES-INORDER NULL)
(CL:DEFVAR SYM-MODULES-CLEARABLE? NULL)
(CL:DEFVAR SYM-MODULES-CLEAR-MODULE NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *CLEAR-MODULE-HOOKS*
  NULL-STRING-WRAPPER
  *CONTEXT-NUMBER-COUNTER*
  STANDARD-OUTPUT
  EOL
  *CHANGE-MODULE-HOOKS*
  *STELLA-MODULE*
  SYMBOL-SYM
  SURROGATE-SYM
  MODULE-SEPARATOR-CHARACTER
  *ROOT-MODULE*
  *MODULE*
  *CONTEXT*))

;;; (DEFGLOBAL *SUBCONTEXT-REVISION-POLICY* ...)

(CL:DEFVAR *SUBCONTEXT-REVISION-POLICY* NULL
  "Controls actions reflexive transitive closure of
   subcontexts when a context is revised.
   Values are ':destroy' -- destroy subcontexts;
   ':clear' -- clear contents of subcontexts;
   ':preserve' -- don't disturb subcontexts.")

;;; (DEFMETHOD (PARENT-CONTEXTS (ITERATOR OF CONTEXT)) ...)

(CL:DEFMETHOD PARENT-CONTEXTS ((SELF CONTEXT))
  (CL:RETURN-FROM PARENT-CONTEXTS NULL)
  :VOID)

;;; (DEFMETHOD (PARENT-CONTEXTS (ITERATOR OF CONTEXT)) ...)

(CL:DEFMETHOD PARENT-CONTEXTS ((SELF MODULE))
  (CL:RETURN-FROM
   PARENT-CONTEXTS
   (ALLOCATE-ITERATOR (CLSYS-SVAL MODULE PARENT-MODULES SELF)))
  :VOID)

;;; (DEFMETHOD (PARENT-CONTEXTS (ITERATOR OF CONTEXT)) ...)

(CL:DEFMETHOD PARENT-CONTEXTS ((SELF WORLD))
  (CL:RETURN-FROM
   PARENT-CONTEXTS
   (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR
    (CONS (CLSYS-SVAL WORLD PARENT-CONTEXT SELF) NIL)))
  :VOID)

;;; (DEFUN (COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME CONTEXT INTEGER) ...)

(CL:DEFUN COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME (PATHNAME MODULE? SYMBOLNAME?)
  (CL:LET*
   ((CONTEXT
     (CL:IF
      (CL:EQL (CL:CHAR PATHNAME 0) MODULE-SEPARATOR-CHARACTER)
      *ROOT-MODULE*
      (CL:IF (CL:EQ MODULE? 1) *MODULE* *CONTEXT*)))
    (COMPONENTEND (CL:IF (CL:EQ CONTEXT *ROOT-MODULE*) 0 -1))
    (COMPONENTSTART NULL-INTEGER)
    (LASTCHARPOS (CL:1- (LENGTH PATHNAME))))
   (CL:LOOP
    WHILE
    (CL:< COMPONENTEND LASTCHARPOS)
    DO
    (CL:TAGBODY
     (CL:SETQ COMPONENTSTART (CL:1+ COMPONENTEND))
     (CL:SETQ COMPONENTEND COMPONENTSTART)
     (CL:LET*
      ((I NULL)
       (ITER-001 COMPONENTSTART)
       (UPPER-BOUND-001 LASTCHARPOS)
       (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
      (CL:LOOP
       WHILE
       (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
       DO
       (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
       (CL:IF
        (CL:OR
         (CL:NOT (CL:EQL (CL:CHAR PATHNAME I) MODULE-SEPARATOR-CHARACTER))
         (CL:EQ (ESCAPED-CHARACTER? PATHNAME I) 1))
        (CL:SETQ COMPONENTEND (CL:1+ COMPONENTEND))
        (CL:RETURN))))
     (CL:WHEN
      (CL:AND (CL:EQ SYMBOLNAME? 1) (CL:> COMPONENTEND LASTCHARPOS))
      (CL:RETURN-FROM
       COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME
       (CL:VALUES CONTEXT COMPONENTSTART)))
     (CL:WHEN
      (CL:NOT (CL:EQ CONTEXT NULL))
      (CL:COND
       ((CL:= COMPONENTSTART COMPONENTEND) (CL:GO :CONTINUE))
       ((CL:EQ (COMPONENT-MATCH? ".." PATHNAME COMPONENTSTART COMPONENTEND) 1)
        (CL:WHEN
         (CL:EQ (EMPTY? (PARENT-CONTEXTS CONTEXT)) 0)
         (CL:SETQ
          CONTEXT
          (CL:IF
           (CL:EQ MODULE? 1)
           (PARENT-MODULE CONTEXT)
           (POP (PARENT-CONTEXTS CONTEXT))))))
       ((CL:EQ (COMPONENT-MATCH? "." PATHNAME COMPONENTSTART COMPONENTEND) 1)
        NULL)
       (CL:T
        (CL:LET*
         ((VALUE-001 NULL))
         (CL:LET*
          ((CHILD NULL)
           (ITER-002
            (CLSYS-SVAL
             LIST
             THE-CONS-LIST
             (CLSYS-SVAL CONTEXT CHILD-CONTEXTS CONTEXT))))
          (CL:LOOP
           WHILE
           (CL:NOT (CL:EQ ITER-002 NIL))
           DO
           (CL:PROGN
            (CL:SETQ CHILD (CLSYS-SVAL CONS VALUE ITER-002))
            (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
           (CL:WHEN
            (CL:AND
             (CL:OR
              (CL:EQ MODULE? 0)
              (CL:EQ (ISA? CHILD SGT-MODULES-MODULE) 1))
             (CL:EQ
              (COMPONENT-MATCH?
               (CL:IF
                (CL:EQ MODULE? 1)
                (CLSYS-SVAL MODULE MODULE-NAME CHILD)
                (CONTEXT-NAME CHILD))
               PATHNAME
               COMPONENTSTART
               COMPONENTEND)
              1))
            (CL:SETQ VALUE-001 CHILD)
            (CL:RETURN))))
         (CL:SETQ CONTEXT VALUE-001))
        (CL:WHEN
         (CL:OR
          (CL:EQ CONTEXT NULL)
          (CL:AND
           (CL:EQ MODULE? 1)
           (CL:EQ (ISA? CONTEXT SGT-MODULES-MODULE) 0)))
         (CL:WHEN
          (CL:EQ MODULE? 0)
          (CL:WARN
           "Bad path name.  Context named `~A' not found."
           PATHNAME))))))
     :CONTINUE))
   (CL:RETURN-FROM
    COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME
    (CL:VALUES CONTEXT NULL-INTEGER)))
  :VOID)

;;; (DEFUN (COMPONENT-MATCH? BOOLEAN) ...)

(CL:DEFUN COMPONENT-MATCH? (COMPONENT STRING START END)
  (CL:LET*
   ((TEST-VALUE-001 FALSE))
   (CL:SETQ TEST-VALUE-001 (EQ? (LENGTH COMPONENT) (CL:- END START)))
   (CL:WHEN
    (CL:EQ TEST-VALUE-001 1)
    (CL:LET*
     ((ALWAYS?-001 TRUE))
     (CL:LET*
      ((I NULL)
       (CHAR NULL)
       (VECTOR-001 COMPONENT)
       (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001))
       (ITER-001 START))
      (CL:LOOP
       WHILE
       (CL:< INDEX-001 LENGTH-001)
       DO
       (CL:PROGN
        (CL:SETQ CHAR (CL:CHAR VECTOR-001 INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
       (CL:WHEN
        (CL:NOT (CL:EQL CHAR (CL:CHAR STRING I)))
        (CL:SETQ ALWAYS?-001 FALSE)
        (CL:RETURN))))
     (CL:SETQ TEST-VALUE-001 ALWAYS?-001)))
   (CL:LET*
    ((VALUE-001 TEST-VALUE-001))
    (CL:RETURN-FROM COMPONENT-MATCH? VALUE-001)))
  :VOID)

;;; (DEFUN (COMPUTE-MODULE-AND-BARE-NAME MODULE STRING) ...)

(CL:DEFUN COMPUTE-MODULE-AND-BARE-NAME (NAME)
  (CL:LET*
   ((MODULE NULL) (BARENAMESTART NULL-INTEGER))
   (CL:MULTIPLE-VALUE-SETQ
    (MODULE BARENAMESTART)
    (COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME NAME TRUE TRUE))
   (CL:RETURN-FROM
    COMPUTE-MODULE-AND-BARE-NAME
    (CL:VALUES
     MODULE
     (CL:IF
      (CL:EQ (DEFINED? BARENAMESTART) 1)
      (SUBSEQUENCE NAME BARENAMESTART NULL-INTEGER)
      NULL))))
  :VOID)

;;; (DEFUN (INTERN-QUALIFIED-NAME GENERALIZED-SYMBOL) ...)

(CL:DEFUN INTERN-QUALIFIED-NAME (NAME)
  (CL:LET*
   ((MODULE NULL) (BARENAME NULL))
   (CL:MULTIPLE-VALUE-SETQ
    (MODULE BARENAME)
    (COMPUTE-MODULE-AND-BARE-NAME NAME))
   (CL:WHEN (CL:EQ MODULE NULL) (CL:RETURN-FROM INTERN-QUALIFIED-NAME NULL))
   (CL:WHEN
    (CL:EQ (STRING-EQL? BARENAME "") 1)
    (CL:IF
     (CL:OR (CL:EQ MODULE *MODULE*) (CL:EQ MODULE *ROOT-MODULE*))
     (CL:RETURN-FROM
      INTERN-QUALIFIED-NAME
      (INTERN-RIGID-SYMBOL-WRT-MODULE "/" *STELLA-MODULE* SYMBOL-SYM))
     (CL:PROGN
      (CL:WARN "Empty symbol name encountered")
      (CL:RETURN-FROM INTERN-QUALIFIED-NAME NULL))))
   (CL:IF
    (CL:EQ (SURROGATE-NAME? BARENAME) 1)
    (CL:RETURN-FROM
     INTERN-QUALIFIED-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      (SUBSEQUENCE BARENAME 1 NULL-INTEGER)
      MODULE
      SURROGATE-SYM))
    (CL:RETURN-FROM
     INTERN-QUALIFIED-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE BARENAME MODULE SYMBOL-SYM))))
  :VOID)

;;; (DEFUN (GET-CONTEXT CONTEXT) ...)

(CL:DEFUN GET-CONTEXT (PATHNAME WARN?)
  "Return the context located at 'pathName', or NULL
if no such context exists.  If 'warn?' is TRUE, print a warning
message if no context is found."
  (CL:LET*
   ((CONTEXT NULL))
   (CL:IF
    (CL:EQ (QUALIFIED-NAME? PATHNAME) 1)
    (CL:SETQ
     CONTEXT
     (COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME PATHNAME FALSE FALSE))
    (CL:PROGN
     (CL:LET*
      ((VALUE-001 NULL))
      (CL:LET*
       ((CHILD NULL)
        (ITER-001
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (CLSYS-SVAL CONTEXT CHILD-CONTEXTS *CONTEXT*))))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ CHILD (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:WHEN
         (CL:AND
          (CL:NOT (CL:EQ (CONTEXT-NAME CHILD) NULL))
          (CL:EQ (STRING-EQL? (CONTEXT-NAME CHILD) PATHNAME) 1))
         (CL:SETQ VALUE-001 CHILD)
         (CL:RETURN))))
      (CL:SETQ CONTEXT VALUE-001))
     (CL:WHEN
      (CL:EQ CONTEXT NULL)
      (CL:WHEN
       (CL:EQ (STRING-EQL? (CONTEXT-NAME *CONTEXT*) PATHNAME) 1)
       (CL:RETURN-FROM GET-CONTEXT *CONTEXT*))
      (CL:WHEN
       (CL:EQ (STRING-EQL? (CONTEXT-NAME *MODULE*) PATHNAME) 1)
       (CL:RETURN-FROM GET-CONTEXT *MODULE*)))))
   (CL:WHEN
    (CL:AND (CL:EQ CONTEXT NULL) (CL:EQ WARN? 1))
    (CL:WARN "Can't find a context located at `~A'." PATHNAME))
   (CL:RETURN-FROM GET-CONTEXT CONTEXT))
  :VOID)

;;; (DEFMETHOD (SCAN-FOR-MODULE MODULE) ...)

(CL:DEFMETHOD SCAN-FOR-MODULE ((NAME CL:STRING) VANTAGEPOINT)
  (CL:WHEN
   (CL:EQ (STRING-EQL? (CONTEXT-NAME VANTAGEPOINT) NAME) 1)
   (CL:RETURN-FROM SCAN-FOR-MODULE VANTAGEPOINT))
  (CL:LET*
   ((SUPER NULL)
    (ITER-001 (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS VANTAGEPOINT)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ SUPER (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:EQ (STRING-EQL? (CONTEXT-NAME SUPER) NAME) 1)
     (CL:RETURN-FROM SCAN-FOR-MODULE SUPER))))
  (CL:LET*
   ((CARDINAL NULL)
    (ITER-002
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL MODULE CHILD-CONTEXTS *ROOT-MODULE*))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-002 NIL))
    DO
    (CL:PROGN
     (CL:SETQ CARDINAL (CLSYS-SVAL CONS VALUE ITER-002))
     (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
    (CL:WHEN
     (CL:EQ (STRING-EQL? (CONTEXT-NAME CARDINAL) NAME) 1)
     (CL:RETURN-FROM SCAN-FOR-MODULE CARDINAL))))
  (CL:RETURN-FROM SCAN-FOR-MODULE NULL)
  :VOID)

;;; (DEFMETHOD (GET-MODULE MODULE) ...)

(CL:DEFMETHOD GET-MODULE ((PATHNAME CL:STRING) WARN?)
  "Return the module located at 'pathName', or NULL
if no such module exists.  The search looks at ancestors and top-most
 (cardinal) modules.  If 'warn?' is TRUE, print a warning
message if no module is found."
  (CL:WHEN
   (CL:EQ
    (STRING-EQL? PATHNAME (CLSYS-SVAL MODULE MODULE-FULL-NAME *MODULE*))
    1)
   (CL:RETURN-FROM GET-MODULE *MODULE*))
  (CL:LET*
   ((MODULE NULL))
   (CL:IF
    (CL:EQ (QUALIFIED-NAME? PATHNAME) 1)
    (CL:SETQ
     MODULE
     (COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME PATHNAME TRUE FALSE))
    (CL:SETQ MODULE (SCAN-FOR-MODULE PATHNAME *MODULE*)))
   (CL:WHEN
    (CL:AND (CL:EQ MODULE NULL) (CL:EQ WARN? 1))
    (CL:WARN "Can't find a module located at `~A'." PATHNAME))
   (CL:RETURN-FROM GET-MODULE MODULE))
  :VOID)

;;; (DEFUN (COERCE-TO-MODULE-NAME STRING) ...)

(CL:DEFUN COERCE-TO-MODULE-NAME (NAMESPEC WARN?)
  (CL:LET*
   ((NAMESPEC-001 NAMESPEC))
   (CL:COND
    ((CL:EQ (STRING? NAMESPEC) 1)
     (CL:LET*
      ((NAMESPEC NULL))
      (CL:SETQ NAMESPEC NAMESPEC-001)
      (CL:RETURN-FROM
       COERCE-TO-MODULE-NAME
       (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE NAMESPEC))))
    ((CL:EQ (KEYWORD? NAMESPEC) 1)
     (CL:LET*
      ((NAMESPEC NULL))
      (CL:SETQ NAMESPEC NAMESPEC-001)
      (CL:RETURN-FROM
       COERCE-TO-MODULE-NAME
       (CLSYS-SVAL KEYWORD SYMBOL-NAME NAMESPEC))))
    ((CL:EQ (SYMBOL? NAMESPEC) 1)
     (CL:LET*
      ((NAMESPEC NULL))
      (CL:SETQ NAMESPEC NAMESPEC-001)
      (CL:LET*
       ((MODULE (CLSYS-SVAL SYMBOL HOME-CONTEXT NAMESPEC)))
       (CL:COND
        ((CL:EQ MODULE NULL)
         (CL:RETURN-FROM
          COERCE-TO-MODULE-NAME
          (CLSYS-SVAL SYMBOL SYMBOL-NAME NAMESPEC)))
        ((CL:EQ MODULE *ROOT-MODULE*)
         (CL:RETURN-FROM
          COERCE-TO-MODULE-NAME
          (CONCATENATE "/" (CLSYS-SVAL SYMBOL SYMBOL-NAME NAMESPEC))))
        (CL:T
         (CL:RETURN-FROM COERCE-TO-MODULE-NAME (VISIBLE-NAME NAMESPEC)))))))
    ((CL:EQ (SURROGATE? NAMESPEC) 1)
     (CL:LET*
      ((NAMESPEC NULL))
      (CL:SETQ NAMESPEC NAMESPEC-001)
      (CL:LET*
       ((MODULE (CLSYS-SVAL SURROGATE HOME-CONTEXT NAMESPEC)))
       (CL:COND
        ((CL:EQ MODULE NULL)
         (CL:RETURN-FROM
          COERCE-TO-MODULE-NAME
          (CLSYS-SVAL SURROGATE SYMBOL-NAME NAMESPEC)))
        ((CL:EQ MODULE *ROOT-MODULE*)
         (CL:RETURN-FROM
          COERCE-TO-MODULE-NAME
          (CONCATENATE "/" (CLSYS-SVAL SURROGATE SYMBOL-NAME NAMESPEC))))
        (CL:T
         (CL:RETURN-FROM COERCE-TO-MODULE-NAME (VISIBLE-NAME NAMESPEC)))))))
    (CL:T
     (CL:WHEN (CL:EQ WARN? 1) (CL:WARN "Illegal module name: `~A'" NAMESPEC))
     (CL:RETURN-FROM COERCE-TO-MODULE-NAME NULL))))
  :VOID)

;;; (DEFUN (COERCE-TO-MODULE MODULE) ...)

(CL:DEFUN COERCE-TO-MODULE (OBJECT WARN?)
  (CL:WHEN (CL:EQ OBJECT NULL) (CL:RETURN-FROM COERCE-TO-MODULE *MODULE*))
  (CL:LET*
   ((OBJECT-001 OBJECT))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? OBJECT SGT-MODULES-MODULE) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:RETURN-FROM COERCE-TO-MODULE OBJECT)))
    (CL:T
     (CL:LET*
      ((MODULENAME (COERCE-TO-MODULE-NAME OBJECT WARN?)) (MODULE NULL))
      (CL:WHEN
       (CL:NOT (CL:EQ MODULENAME NULL))
       (CL:WHEN
        (CL:EQ (QUALIFIED-NAME? MODULENAME) 1)
        (CL:RETURN-FROM COERCE-TO-MODULE (GET-MODULE MODULENAME WARN?)))
       (CL:LET*
        ()
        (CL:SETQ MODULE (GET-MODULE (CONCATENATE "./" MODULENAME) FALSE))
        (CL:IF
         (CL:NOT (CL:EQ MODULE NULL))
         (CL:RETURN-FROM COERCE-TO-MODULE MODULE)
         (CL:RETURN-FROM COERCE-TO-MODULE (GET-MODULE MODULENAME WARN?)))))
      (CL:RETURN-FROM COERCE-TO-MODULE NULL)))))
  :VOID)

;;; (DEFUN (FIND-OR-CREATE-MODULE MODULE) ...)

(CL:DEFUN FIND-OR-CREATE-MODULE (PATHNAME)
  "Return a module located at `pathname' if one exists,
  otherwise create one"
  (CL:LET*
   ((MODULE (GET-MODULE PATHNAME FALSE)))
   (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE (DEFINE-MODULE PATHNAME NIL)))
   (CL:RETURN-FROM FIND-OR-CREATE-MODULE MODULE))
  :VOID)

;;; (DEFUN (CHANGE-CURRENT-MODULE MODULE) ...)

(CL:DEFUN CHANGE-CURRENT-MODULE (MODULE)
  (CL:SETQ *MODULE* MODULE)
  (CL:SETQ *CONTEXT* MODULE)
  (RUN-HOOKS *CHANGE-MODULE-HOOKS* MODULE)
  (CL:RETURN-FROM CHANGE-CURRENT-MODULE MODULE)
  :VOID)

;;; (DEFUN (CHANGE-CURRENT-CONTEXT CONTEXT) ...)

(CL:DEFUN CHANGE-CURRENT-CONTEXT (CONTEXT)
  (CL:WHEN
   (CL:NOT (CL:EQ (CLSYS-SVAL CONTEXT BASE-MODULE CONTEXT) *MODULE*))
   (CHANGE-CURRENT-MODULE (CLSYS-SVAL CONTEXT BASE-MODULE CONTEXT)))
  (CL:SETQ *CONTEXT* CONTEXT)
  (CL:RETURN-FROM CHANGE-CURRENT-CONTEXT CONTEXT)
  :VOID)

;;; (DEFMETHOD (CHANGE-CONTEXT CONTEXT) ...)

(CL:DEFMETHOD CHANGE-CONTEXT ((CONTEXT CONTEXT))
  "Change the current context to be the context
'context'."
  (CL:IF
   (CL:EQ CONTEXT *CONTEXT*)
   (CL:RETURN-FROM CHANGE-CONTEXT CONTEXT)
   (CL:RETURN-FROM CHANGE-CONTEXT (CHANGE-CURRENT-CONTEXT CONTEXT)))
  :VOID)

;;; (DEFMETHOD (CHANGE-CONTEXT CONTEXT) ...)

(CL:DEFMETHOD CHANGE-CONTEXT ((CONTEXTNAME CL:STRING))
  "Change the current context to be the context named
'contextName'."
  (CL:LET*
   ((CONTEXT (GET-CONTEXT CONTEXTNAME TRUE)))
   (CL:IF
    (CL:EQ CONTEXT NULL)
    (CL:RETURN-FROM CHANGE-CONTEXT *CONTEXT*)
    (CL:RETURN-FROM CHANGE-CONTEXT (CHANGE-CURRENT-CONTEXT CONTEXT))))
  :VOID)

;;; (DEFMETHOD (CHANGE-MODULE MODULE) ...)

(CL:DEFMETHOD CHANGE-MODULE ((MODULE MODULE))
  "Change the current module to be the module
'module'."
  (CL:RETURN-FROM CHANGE-MODULE (CHANGE-CURRENT-MODULE MODULE))
  :VOID)

;;; (DEFMETHOD (CHANGE-MODULE MODULE) ...)

(CL:DEFMETHOD CHANGE-MODULE ((MODULENAME CL:STRING))
  "Change the current module to be the module named
'moduleName'."
  (CL:LET*
   ((MODULE (GET-MODULE MODULENAME TRUE)))
   (CL:IF
    (CL:EQ MODULE NULL)
    (CL:RETURN-FROM CHANGE-MODULE *MODULE*)
    (CL:RETURN-FROM CHANGE-MODULE (CHANGE-CURRENT-MODULE MODULE))))
  :VOID)

;;; (DEFMETHOD (MULTIPLE-PARENTS? BOOLEAN) ...)

(CL:DEFMETHOD MULTIPLE-PARENTS? ((MODULE MODULE))
  "Return TRUE if 'module' has more than one parent."
  (CL:RETURN-FROM
   MULTIPLE-PARENTS?
   (NON-EMPTY? (REST (CLSYS-SVAL MODULE PARENT-MODULES MODULE))))
  :VOID)

;;; (DEFUN NORMALIZE-PARENT-MODULES ...)

(CL:DEFUN NORMALIZE-PARENT-MODULES (SELF)
  (CL:WHEN
   (CL:EQ (MULTIPLE-PARENTS? SELF) 0)
   (CL:RETURN-FROM NORMALIZE-PARENT-MODULES))
  (CL:LET*
   ((PARENTS (CLSYS-SVAL MODULE PARENT-MODULES SELF)))
   (CL:LET*
    ((SUPERMODULE NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST PARENTS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUPERMODULE (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:LET*
      ((OTHERSUPERMODULE NULL)
       (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST PARENTS)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-002 NIL))
       DO
       (CL:PROGN
        (CL:SETQ OTHERSUPERMODULE (CLSYS-SVAL CONS VALUE ITER-002))
        (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
       (CL:WHEN
        (CL:NOT (CL:EQ OTHERSUPERMODULE SUPERMODULE))
        (CL:WHEN
         (CL:EQ
          (MEMBER?
           (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS SUPERMODULE)
           OTHERSUPERMODULE)
          1)
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:WRITE-STRING
           "Bad list of parents defined for module `"
           %%STREAM)
          (CL:WRITE-STRING (CONTEXT-NAME SELF) %%STREAM)
          (CL:WRITE-STRING "'." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:WRITE-STRING "  The module `" %%STREAM)
          (CL:WRITE-STRING (CONTEXT-NAME OTHERSUPERMODULE) %%STREAM)
          (CL:WRITE-STRING "' is not a direct ancestor." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))
         (REMOVE PARENTS OTHERSUPERMODULE)))))))
   (CL:WHEN
    (CL:AND
     (CL:EQ (MULTIPLE-PARENTS? SELF) 1)
     (CL:EQ (ISA? SELF SGT-MODULES-MODULE) 1))
    (CL:WARN "Module `~A' has multiple parents." (CONTEXT-NAME SELF))))
  :VOID)

;;; (DEFUN INHERIT-SUPERCONTEXTS ...)

(CL:DEFUN INHERIT-SUPERCONTEXTS (MODULE)
  (CL:LET*
   ((*TRANSIENTOBJECTS?* FALSE))
   (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
   (CL:WHEN
    (CL:EQ (MULTIPLE-PARENTS? MODULE) 0)
    (CL:LET*
     ((ONLYPARENT (FIRST (CLSYS-SVAL MODULE PARENT-MODULES MODULE))))
     (CL:WHEN
      (CL:NOT (CL:EQ ONLYPARENT NULL))
      (CL:SETF
       (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS MODULE)
       (CONS ONLYPARENT (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS ONLYPARENT)))
      (CL:RETURN-FROM INHERIT-SUPERCONTEXTS))))
   (CL:LET*
    ((ALLSUPERCONTEXTS NIL) (SUBLIST NULL))
    (NORMALIZE-PARENT-MODULES MODULE)
    (REVERSE (CLSYS-SVAL MODULE PARENT-MODULES MODULE))
    (CL:LET*
     ((PARENT NULL)
      (ITER-001
       (CLSYS-SVAL
        LIST
        THE-CONS-LIST
        (CLSYS-SVAL MODULE PARENT-MODULES MODULE))))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ PARENT (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:SETQ SUBLIST NIL)
      (CL:LET*
       ((ANCESTOR NULL)
        (ITER-002 (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS PARENT))
        (COLLECT-001 NULL))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-002 NIL))
        DO
        (CL:PROGN
         (CL:SETQ ANCESTOR (CLSYS-SVAL CONS VALUE ITER-002))
         (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
        (CL:WHEN
         (CL:EQ (MEMBER? ALLSUPERCONTEXTS ANCESTOR) 0)
         (CL:IF
          (CL:EQ COLLECT-001 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-001 (CONS ANCESTOR NIL))
           (CL:IF
            (CL:EQ SUBLIST NIL)
            (CL:SETQ SUBLIST COLLECT-001)
            (ADD-CONS-TO-END-OF-CONS-LIST SUBLIST COLLECT-001)))
          (CL:PROGN
           (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS ANCESTOR NIL))
           (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001)))))))
      (CL:SETQ SUBLIST (CONS PARENT SUBLIST))
      (CL:SETQ ALLSUPERCONTEXTS (CONCATENATE SUBLIST ALLSUPERCONTEXTS))))
    (CL:SETF (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS MODULE) ALLSUPERCONTEXTS)
    (REVERSE (CLSYS-SVAL MODULE PARENT-MODULES MODULE))))
  :VOID)

;;; (DEFUN UNINHERIT-SUPERCONTEXTS ...)

(CL:DEFUN UNINHERIT-SUPERCONTEXTS (MODULE)
  (CL:COND
   ((CL:EQ (MULTIPLE-PARENTS? MODULE) 1)
    (FREE-CONS-LIST (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS MODULE)))
   ((CL:NOT (CL:EQ (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS MODULE) NIL))
    (FREE-CONS (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS MODULE))))
  (CL:SETF (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS MODULE) NIL)
  :VOID)

;;; (DEFUN INHERIT-USED-MODULES ...)

(CL:DEFUN INHERIT-USED-MODULES (MODULE)
  (CL:LET*
   ((USEES (CLSYS-SVAL MODULE USES MODULE)))
   (CL:COND
    ((CL:EQ (EMPTY? USEES) 1)
     (CL:COND
      ((CL:EQ (EMPTY? (CLSYS-SVAL MODULE PARENT-MODULES MODULE)) 1)
       (PUSH USEES *STELLA-MODULE*)
       (INSERT-NEW (CLSYS-SVAL MODULE USED-BY *STELLA-MODULE*) MODULE))
      (CL:T
       (CL:LET*
        ((PARENT NULL)
         (ITER-001
          (CLSYS-SVAL
           LIST
           THE-CONS-LIST
           (CLSYS-SVAL MODULE PARENT-MODULES MODULE))))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-001 NIL))
         DO
         (CL:PROGN
          (CL:SETQ PARENT (CLSYS-SVAL CONS VALUE ITER-001))
          (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
         (CL:LET*
          ((PARENTUSEES NULL)
           (ITER-002
            (CLSYS-SVAL LIST THE-CONS-LIST (CLSYS-SVAL MODULE USES PARENT))))
          (CL:LOOP
           WHILE
           (CL:NOT (CL:EQ ITER-002 NIL))
           DO
           (CL:PROGN
            (CL:SETQ PARENTUSEES (CLSYS-SVAL CONS VALUE ITER-002))
            (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
           (INSERT-NEW USEES PARENTUSEES)
           (INSERT-NEW (CLSYS-SVAL MODULE USED-BY PARENTUSEES) MODULE)))))
       (REVERSE USEES))))
    ((CL:EQ (MEMBER? USEES MODULE) 1) (REMOVE USEES MODULE))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN UNINHERIT-USED-MODULES ...)

(CL:DEFUN UNINHERIT-USED-MODULES (MODULE)
  (CL:LET*
   ((USEES (CLSYS-SVAL MODULE USES MODULE)))
   (CL:COND
    ((CL:EQ (EMPTY? USEES) 1) (PUSH USEES MODULE))
    ((CL:EQ
      (NULL?
       (STRING-SEARCH
        (CLSYS-SVAL MODULE STRINGIFIED-OPTIONS MODULE)
        ":USES "
        0))
      1)
     (CL:LET*
      ((USEE NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST USEES)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ USEE (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (REMOVE (CLSYS-SVAL MODULE USED-BY USEE) MODULE)))
     (CLEAR USEES))))
  :VOID)

;;; (DEFSPECIAL *SHADOWEDSURROGATES* ...)

(CL:DEFVAR *SHADOWEDSURROGATES* NULL
  "Holds list of symbols representing surrogates
to be shadowed during module finalization.")

(CL:DEFUN READ-*SHADOWEDSURROGATES* ()
  (CL:RETURN-FROM READ-*SHADOWEDSURROGATES* *SHADOWEDSURROGATES*)
  :VOID)

(CL:DEFUN WRITE-*SHADOWEDSURROGATES* (VALUE)
  (CL:SETQ *SHADOWEDSURROGATES* VALUE)
  (CL:RETURN-FROM WRITE-*SHADOWEDSURROGATES* VALUE)
  :VOID)

;;; (DEFUN FINALIZE-MODULE ...)

(CL:DEFUN FINALIZE-MODULE (SELF)
  (INHERIT-SUPERCONTEXTS SELF)
  (INHERIT-USED-MODULES SELF)
  (CL:SETQ *CONTEXT-NUMBER-COUNTER* (CL:+ *CONTEXT-NUMBER-COUNTER* 2))
  (CL:SETF (CLSYS-SVAL MODULE CONTEXT-NUMBER SELF) *CONTEXT-NUMBER-COUNTER*)
  (CL:SETF
   (CLSYS-SVAL MODULE CARDINAL-MODULE SELF)
   (CL:IF
    (CL:EQ (PARENT-MODULE SELF) NULL)
    SELF
    (CLSYS-SVAL MODULE CARDINAL-MODULE (PARENT-MODULE SELF))))
  (CL:SETF
   (CLSYS-SVAL MODULE SYMBOL-OFFSET-TABLE SELF)
   (NEW-STRING-TO-INTEGER-HASH-TABLE))
  (CL:SETF
   (CLSYS-SVAL MODULE SURROGATE-OFFSET-TABLE SELF)
   (NEW-STRING-TO-INTEGER-HASH-TABLE))
  (CL:WHEN
   (CL:EQ (CARDINAL-MODULE? SELF) 1)
   (CL:SETF
    (CLSYS-SVAL MODULE INDEXICAL-OFFSET-TABLE SELF)
    (NEW-STRING-TO-INTEGER-HASH-TABLE)))
  (CL:WHEN
   (CL:NOT (CL:EQ *SHADOWEDSURROGATES* NIL))
   (SET-DYNAMIC-SLOT-VALUE
    SELF
    SYM-MODULES-SHADOWED-SURROGATES
    (NEW-LIST)
    NULL)
   (CL:LET*
    ((*MODULE* SELF))
    (CL:DECLARE (CL:SPECIAL *MODULE*))
    (CL:LET*
     ((SYM NULL) (ITER-001 *SHADOWEDSURROGATES*))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ SYM (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (INSERT-LAST
       (SHADOWED-SURROGATES SELF)
       (SHADOW-SURROGATE (CLSYS-SVAL SYMBOL SYMBOL-NAME SYM)))))))
  :VOID)

;;; (DEFUN FINALIZE-WORLD ...)

(CL:DEFUN FINALIZE-WORLD (SELF)
  (CL:LET*
   ((PARENTCONTEXT (CLSYS-SVAL WORLD PARENT-CONTEXT SELF)))
   (CL:SETF
    (CLSYS-SVAL WORLD ALL-SUPER-CONTEXTS SELF)
    (CONS
     PARENTCONTEXT
     (CLSYS-SVAL CONTEXT ALL-SUPER-CONTEXTS PARENTCONTEXT)))
   (CL:SETQ *CONTEXT-NUMBER-COUNTER* (CL:+ *CONTEXT-NUMBER-COUNTER* 2))
   (CL:SETF (CLSYS-SVAL WORLD CONTEXT-NUMBER SELF) *CONTEXT-NUMBER-COUNTER*))
  :VOID)

;;; (DEFMETHOD UNFINALIZE-MODULE ...)

(CL:DEFMETHOD UNFINALIZE-MODULE ((SELF MODULE))
  (UNINHERIT-SUPERCONTEXTS SELF)
  (UNINHERIT-USED-MODULES SELF)
  (CL:IF
   (CL:EQ (CARDINAL-MODULE? SELF) 1)
   (REMOVE (CLSYS-SVAL MODULE CHILD-CONTEXTS *ROOT-MODULE*) SELF)
   (CL:LET*
    ((PARENT NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL MODULE PARENT-MODULES SELF))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ PARENT (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (REMOVE (CLSYS-SVAL MODULE CHILD-CONTEXTS PARENT) SELF))))
  (CLEAR (CLSYS-SVAL MODULE PARENT-MODULES SELF))
  (CL:SETF
   (CLSYS-SVAL MODULE CONTEXT-NUMBER SELF)
   (CL:1- (CLSYS-SVAL MODULE CONTEXT-NUMBER SELF)))
  (CL:SETF (CLSYS-SVAL MODULE MODULE-FULL-NAME SELF) NULL)
  :VOID)

;;; (DEFMETHOD UNFINALIZE-WORLD ...)

(CL:DEFMETHOD UNFINALIZE-WORLD ((SELF WORLD))
  (FREE-CONS (CLSYS-SVAL WORLD ALL-SUPER-CONTEXTS SELF))
  (REMOVE
   (CLSYS-SVAL CONTEXT CHILD-CONTEXTS (CLSYS-SVAL WORLD PARENT-CONTEXT SELF))
   SELF)
  (CL:SETF
   (CLSYS-SVAL WORLD CONTEXT-NUMBER SELF)
   (CL:1- (CLSYS-SVAL WORLD CONTEXT-NUMBER SELF)))
  (CL:SETF (CLSYS-SVAL WORLD ALL-SUPER-CONTEXTS SELF) NULL)
  (CL:SETF (CLSYS-SVAL WORLD PARENT-CONTEXT SELF) NULL)
  :VOID)

;;; (DEFUN DESTROY-MODULE ...)

(CL:DEFUN DESTROY-MODULE (SELF)
  "Destroy the module 'self', and recursively destroy
all contexts that inherit 'self'."
  (CL:WHEN
   (CL:OR (CL:EQ SELF *ROOT-MODULE*) (CL:EQ SELF *STELLA-MODULE*))
   (CL:WARN "Can't destroy the root module or the STELLA module.")
   (CL:RETURN-FROM DESTROY-MODULE))
  (CL:LET*
   ((CHILD NULL)
    (ITER-001
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (COPY (CLSYS-SVAL MODULE CHILD-CONTEXTS SELF)))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ CHILD (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (DESTROY-CONTEXT CHILD)))
  (CL:LET*
   ((PARENTMODULE (PARENT-MODULE SELF)))
   (CL:WHEN
    (CL:EQ PARENTMODULE NULL)
    (CL:SETQ PARENTMODULE (CLSYS-SVAL MODULE CARDINAL-MODULE SELF)))
   (CL:WHEN (CL:EQ PARENTMODULE NULL) (CL:SETQ PARENTMODULE *STELLA-MODULE*))
   (UNFINALIZE-MODULE SELF)
   (CL:WHEN (CL:EQ SELF *MODULE*) (CHANGE-MODULE PARENTMODULE)))
  :VOID)

;;; (DEFUN DESTROY-WORLD ...)

(CL:DEFUN DESTROY-WORLD (SELF)
  (CL:WHEN
   (CL:EQ (NON-EMPTY? (CLSYS-SVAL WORLD CHILD-CONTEXTS SELF)) 1)
   (CL:LET*
    ((CHILD NULL)
     (ITER-001
      (CLSYS-SVAL LIST THE-CONS-LIST (CLSYS-SVAL WORLD CHILD-CONTEXTS SELF))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ CHILD (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (DESTROY-WORLD CHILD))))
  (UNFINALIZE-WORLD SELF)
  (CL:WHEN
   (CL:EQ SELF *CONTEXT*)
   (CL:SETQ *CONTEXT* (CLSYS-SVAL WORLD PARENT-CONTEXT SELF)))
  :VOID)

;;; (DEFMETHOD DESTROY-CONTEXT ...)

(CL:DEFMETHOD DESTROY-CONTEXT ((SELF MODULE))
  "Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'."
  (DESTROY-MODULE SELF)
  :VOID)

;;; (DEFMETHOD DESTROY-CONTEXT ...)

(CL:DEFMETHOD DESTROY-CONTEXT ((SELF WORLD))
  "Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'."
  (DESTROY-WORLD SELF)
  :VOID)

;;; (DEFMETHOD DESTROY-CONTEXT ...)

(CL:DEFMETHOD DESTROY-CONTEXT ((SELF CL:STRING))
  "Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'."
  (CL:LET*
   ((CONTEXT (GET-CONTEXT SELF TRUE)))
   (CL:WHEN (CL:NOT (CL:EQ CONTEXT NULL)) (DESTROY-CONTEXT CONTEXT)))
  :VOID)

;;; (DEFMETHOD DESTROY-CONTEXT ...)

(CL:DEFMETHOD DESTROY-CONTEXT ((SELF CONTEXT))
  "Make the translator happy."
  NULL
  :VOID)

;;; (DEFUN LINK-TO-PARENT-MODULE ...)

(CL:DEFUN LINK-TO-PARENT-MODULE (SELF PARENT INSERT-FIRST?)
  (CL:WHEN
   (CL:NOT (CL:EQ PARENT *ROOT-MODULE*))
   (CL:IF
    (CL:EQ INSERT-FIRST? 1)
    (INSERT (CLSYS-SVAL MODULE PARENT-MODULES SELF) PARENT)
    (INSERT-LAST (CLSYS-SVAL MODULE PARENT-MODULES SELF) PARENT)))
  (INSERT (CLSYS-SVAL MODULE CHILD-CONTEXTS PARENT) SELF)
  :VOID)

;;; (DEFUN INCORPORATE-MODULE-NAME ...)

(CL:DEFUN INCORPORATE-MODULE-NAME (MODULE NAME)
  (CL:LET*
   ((PARENTMODULE NULL) (BARENAME NULL))
   (CL:IF
    (CL:EQ (QUALIFIED-NAME? NAME) 1)
    (CL:PROGN
     (CL:MULTIPLE-VALUE-SETQ
      (PARENTMODULE BARENAME)
      (COMPUTE-MODULE-AND-BARE-NAME NAME))
     (CL:WHEN
      (CL:EQ PARENTMODULE NULL)
      (CL:WARN
       "Bad path name:  `~A' when defining the module `~A'"
       NAME
       BARENAME)
      (CL:RETURN-FROM INCORPORATE-MODULE-NAME))
     (LINK-TO-PARENT-MODULE MODULE PARENTMODULE TRUE))
    (CL:PROGN
     (CL:SETQ PARENTMODULE (FIRST (CLSYS-SVAL MODULE PARENT-MODULES MODULE)))
     (CL:WHEN (CL:EQ PARENTMODULE NULL) (CL:SETQ PARENTMODULE *ROOT-MODULE*))
     (CL:SETQ BARENAME NAME)))
   (CL:SETF (CLSYS-SVAL MODULE MODULE-NAME MODULE) BARENAME)
   (CL:SETF
    (CLSYS-SVAL MODULE MODULE-FULL-NAME MODULE)
    (COMPUTE-FULL-NAME "" MODULE)))
  :VOID)

;;; (DEFUN INCORPORATE-INCLUDES-MODULES ...)

(CL:DEFUN INCORPORATE-INCLUDES-MODULES (MODULE INCLUDEES)
  (CL:LET*
   ((INCLUDEES-001 INCLUDEES))
   (CL:COND
    ((CL:EQ (CONS? INCLUDEES) 1)
     (CL:LET*
      ((INCLUDEES NULL))
      (CL:SETQ INCLUDEES INCLUDEES-001)
      (CL:LET*
       ((NAME NULL) (ITER-001 INCLUDEES))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ NAME (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (INCORPORATE-INCLUDES-MODULES MODULE NAME)))))
    ((CL:EQ (STRING? INCLUDEES) 1)
     (CL:LET*
      ((INCLUDEES NULL))
      (CL:SETQ INCLUDEES INCLUDEES-001)
      (CL:LET*
       ((INCLUDEEMODULE
         (GET-MODULE
          (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE INCLUDEES)
          TRUE)))
       (CL:WHEN
        (CL:NOT (CL:EQ INCLUDEEMODULE NULL))
        (INSERT-LAST (CLSYS-SVAL MODULE PARENT-MODULES MODULE) INCLUDEEMODULE)
        (INSERT (CLSYS-SVAL MODULE CHILD-CONTEXTS INCLUDEEMODULE) MODULE)))))
    ((CL:EQ (SYMBOL? INCLUDEES) 1)
     (CL:LET*
      ((INCLUDEES NULL))
      (CL:SETQ INCLUDEES INCLUDEES-001)
      (CL:LET*
       ((INCLUDEEMODULE
         (GET-MODULE (CLSYS-SVAL SYMBOL SYMBOL-NAME INCLUDEES) TRUE)))
       (CL:WHEN
        (CL:NOT (CL:EQ INCLUDEEMODULE NULL))
        (INSERT-LAST (CLSYS-SVAL MODULE PARENT-MODULES MODULE) INCLUDEEMODULE)
        (INSERT (CLSYS-SVAL MODULE CHILD-CONTEXTS INCLUDEEMODULE) MODULE)))))
    (CL:T
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " Illegal argument to ':includes' option`" %%STREAM)
        (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE INCLUDEES) %%STREAM)
        (CL:WRITE-STRING "'." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)))))))
  :VOID)

;;; (DEFUN INCORPORATE-USES-MODULES ...)

(CL:DEFUN INCORPORATE-USES-MODULES (MODULE USEES)
  (CL:LET*
   ((USEES-001 USEES))
   (CL:COND
    ((CL:EQ (CONS? USEES) 1)
     (CL:LET*
      ((USEES NULL))
      (CL:SETQ USEES USEES-001)
      (CL:LET*
       ((NAME NULL) (ITER-001 USEES))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ NAME (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (INCORPORATE-USES-MODULES MODULE NAME)))
      (CL:WHEN
       (CL:EQ (EMPTY? (CLSYS-SVAL MODULE USES MODULE)) 1)
       (INSERT (CLSYS-SVAL MODULE USES MODULE) MODULE))))
    ((CL:EQ (STRING? USEES) 1)
     (CL:LET*
      ((USEES NULL))
      (CL:SETQ USEES USEES-001)
      (CL:LET*
       ((USEEMODULE
         (GET-MODULE (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE USEES) TRUE)))
       (CL:WHEN
        (CL:NOT (CL:EQ USEEMODULE NULL))
        (INSERT-LAST (CLSYS-SVAL MODULE USES MODULE) USEEMODULE)
        (INSERT (CLSYS-SVAL MODULE USED-BY USEEMODULE) MODULE)))))
    (CL:T
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " Illegal argument to ':uses' option ." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)))))))
  :VOID)

;;; (DEFUN INCORPORATE-MODULE-OPTIONS ...)

(CL:DEFUN INCORPORATE-MODULE-OPTIONS (SELF OPTIONS)
  (CL:LET*
   ((SELF-001 (NEW-PROPERTY-LIST)))
   (CL:SETF (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF-001) OPTIONS)
   (CL:LET*
    ((PLIST SELF-001))
    (CL:LET*
     ((VALUE NULL)
      (KEY NULL)
      (ITER-001 (CLSYS-SVAL PROPERTY-LIST THE-PLIST PLIST)))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:SETQ KEY (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:PROGN
       (CL:SETQ VALUE (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST ITER-001)))
       (CL:SETQ
        ITER-001
        (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST ITER-001))))
      (CL:LET*
       ((TEST-VALUE-001 KEY))
       (CL:COND
        ((CL:EQ TEST-VALUE-001 KWD-MODULES-INCLUDES)
         (INCORPORATE-INCLUDES-MODULES SELF VALUE))
        ((CL:EQ TEST-VALUE-001 KWD-MODULES-USES)
         (INCORPORATE-USES-MODULES SELF VALUE))
        ((CL:EQ TEST-VALUE-001 KWD-MODULES-SHADOW)
         (CL:SETQ *SHADOWEDSURROGATES* VALUE))
        (CL:T
         (CL:SETQ VALUE (PERMANENT-COPY VALUE))
         (CL:LET*
          ((TEST-VALUE-002 KEY))
          (CL:COND
           ((CL:EQ TEST-VALUE-002 KWD-MODULES-DOCUMENTATION)
            (CL:SETF
             (CLSYS-SVAL MODULE DOCUMENTATION SELF)
             (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE)))
           ((CL:EQ TEST-VALUE-002 KWD-MODULES-CASE-SENSITIVE?)
            (CL:SETF
             (CLSYS-SVAL MODULE CASE-SENSITIVE? SELF)
             (EQ? VALUE SYM-MODULES-TRUE)))
           ((CL:EQ TEST-VALUE-002 KWD-MODULES-PACKAGE)
            (CL:SETF
             (CLSYS-SVAL MODULE MODULE-NATIVE-PACKAGE SELF)
             (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE)))
           ((CL:EQ TEST-VALUE-002 KWD-MODULES-REQUIRES)
            (CL:SETF (CLSYS-SVAL MODULE REQUIRES SELF) VALUE))
           ((CL:EQ TEST-VALUE-002 KWD-MODULES-DIRECTORY-FILE)
            (CL:SETF
             (CLSYS-SVAL MODULE DIRECTORY-FILE SELF)
             (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE)))
           ((CL:EQ TEST-VALUE-002 KWD-MODULES-CODE-FILES)
            (CL:SETF (CLSYS-SVAL MODULE CODE-FILES SELF) VALUE))
           ((CL:EQ TEST-VALUE-002 KWD-MODULES-DEFINITIONS-FILE)
            (CL:SETF
             (CLSYS-SVAL MODULE DEFINITIONS-FILE SELF)
             (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE)))
           (CL:T
            (CL:WHEN
             (CL:EQ (RUN-OPTION-HANDLER? SELF KEY VALUE) 0)
             (CL:LET*
              ((*PRINTREADABLY?* TRUE))
              (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
              (SIGNAL-TRANSLATION-WARNING)
              (CL:WHEN
               (CL:EQ (SUPPRESS-WARNINGS?) 0)
               (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
               (CL:LET
                ((%%STREAM
                  (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
                (CL:TERPRI %%STREAM)
                (CL:FORCE-OUTPUT %%STREAM)
                (CL:WRITE-STRING
                 " Skipping invalid module option: `"
                 %%STREAM)
                (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE KEY) %%STREAM)
                (CL:WRITE-STRING "'." %%STREAM)
                (CL:TERPRI %%STREAM)
                (CL:FORCE-OUTPUT %%STREAM)))))))))))))
    (FREE PLIST)))
  :VOID)

;;; (DEFUN UNDEFINE-MODULE ...)

(CL:DEFUN UNDEFINE-MODULE (OLDMODULE NEWMODULE)
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "Redefining the module `" %%STREAM)
   (CL:WRITE-STRING (CONTEXT-NAME OLDMODULE) %%STREAM)
   (CL:WRITE-STRING "'" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  (CL:COND
   ((CL:EQ *SUBCONTEXT-REVISION-POLICY* KWD-MODULES-DESTROY)
    (DESTROY-CONTEXT OLDMODULE)
    (CL:RETURN-FROM UNDEFINE-MODULE))
   ((CL:EQ *SUBCONTEXT-REVISION-POLICY* KWD-MODULES-PRESERVE) NULL)
   ((CL:EQ *SUBCONTEXT-REVISION-POLICY* KWD-MODULES-CLEAR)
    (CL:LET*
     ((C NULL) (ITER-001 (ALL-SUBCONTEXTS OLDMODULE KWD-MODULES-PREORDER)))
     (CL:LOOP
      WHILE
      (CL:EQ (NEXT? ITER-001) 1)
      DO
      (CL:PROGN (CL:SETQ C (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE ITER-001)))
      (CLEAR-CONTEXT C))))
   (CL:T
    (CL:ERROR "`~A' is not a valid case option" *SUBCONTEXT-REVISION-POLICY*)))
  (CL:LET*
   ((P NULL)
    (ITER-002
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL MODULE PARENT-MODULES OLDMODULE))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-002 NIL))
    DO
    (CL:PROGN
     (CL:SETQ P (CLSYS-SVAL CONS VALUE ITER-002))
     (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
    (REMOVE (CLSYS-SVAL MODULE CHILD-CONTEXTS P) OLDMODULE)))
  (CL:LET*
   ((C NULL)
    (ITER-003
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL MODULE CHILD-CONTEXTS OLDMODULE))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-003 NIL))
    DO
    (CL:PROGN
     (CL:SETQ C (CLSYS-SVAL CONS VALUE ITER-003))
     (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
    (CL:LET*
     ((C-001 C))
     (CL:COND
      ((CL:EQ (TAXONOMY-ISA? C SGT-MODULES-MODULE) 1)
       (CL:LET*
        ((C NULL))
        (CL:SETQ C C-001)
        (SUBSTITUTE
         (CLSYS-SVAL LIST THE-CONS-LIST (CLSYS-SVAL MODULE PARENT-MODULES C))
         NEWMODULE
         OLDMODULE)))
      ((CL:EQ (TAXONOMY-ISA? C SGT-MODULES-WORLD) 1)
       (CL:LET*
        ((C NULL))
        (CL:SETQ C C-001)
        (CL:SETF (CLSYS-SVAL WORLD PARENT-CONTEXT C) NEWMODULE)))
      (CL:T (CL:ERROR "`~A' is not a valid case option" C))))))
  (CL:SETF
   (CLSYS-SVAL
    LIST
    THE-CONS-LIST
    (CLSYS-SVAL MODULE CHILD-CONTEXTS NEWMODULE))
   (CLSYS-SVAL LIST THE-CONS-LIST (CLSYS-SVAL MODULE CHILD-CONTEXTS OLDMODULE)))
  (CL:SETF
   (CLSYS-SVAL
    LIST
    THE-CONS-LIST
    (CLSYS-SVAL MODULE CHILD-CONTEXTS OLDMODULE))
   NIL)
  (FREE OLDMODULE)
  :VOID)

;;; (DEFUN (DEFINE-MODULE MODULE) ...)

(CL:DEFUN DEFINE-MODULE (NAME OPTIONS)
  "Define or redefine a module named 'name' having the
options 'options'.  Return the new module."
  (CL:LET*
   ((*SHADOWEDSURROGATES* NIL))
   (CL:DECLARE (CL:SPECIAL *SHADOWEDSURROGATES*))
   (CL:LET*
    ((MODULE NULL) (STRINGIFIEDOPTIONS (STRINGIFY OPTIONS)) (OLDMODULE NULL))
    (CL:SETQ OLDMODULE (GET-MODULE NAME FALSE))
    (CL:WHEN
     (CL:AND
      (CL:NOT (CL:EQ OLDMODULE NULL))
      (CL:EQ
       (STRING-EQL?
        STRINGIFIEDOPTIONS
        (CLSYS-SVAL MODULE STRINGIFIED-OPTIONS OLDMODULE))
       1))
     (CL:RETURN-FROM DEFINE-MODULE OLDMODULE))
    (CL:SETQ MODULE (NEW-MODULE))
    (CL:WHEN
     (CL:NOT (CL:EQ OLDMODULE NULL))
     (UNDEFINE-MODULE OLDMODULE MODULE))
    (CL:SETF
     (CLSYS-SVAL MODULE STRINGIFIED-OPTIONS MODULE)
     STRINGIFIEDOPTIONS)
    (INCORPORATE-MODULE-OPTIONS MODULE OPTIONS)
    (INCORPORATE-MODULE-NAME MODULE NAME)
    (CL:SETF (CLSYS-SVAL MODULE BASE-MODULE MODULE) MODULE)
    (CL:LET*
     ((PARENT NULL)
      (ITER-001
       (CLSYS-SVAL
        LIST
        THE-CONS-LIST
        (CLSYS-SVAL MODULE PARENT-MODULES MODULE))))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ PARENT (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:LET*
       ()
       (CL:LET*
        ((VALUE-001 NULL))
        (CL:LET*
         ((CHILD NULL)
          (ITER-002
           (CLSYS-SVAL
            LIST
            THE-CONS-LIST
            (CLSYS-SVAL MODULE CHILD-CONTEXTS PARENT))))
         (CL:LOOP
          WHILE
          (CL:NOT (CL:EQ ITER-002 NIL))
          DO
          (CL:PROGN
           (CL:SETQ CHILD (CLSYS-SVAL CONS VALUE ITER-002))
           (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
          (CL:WHEN
           (CL:AND
            (CL:NOT (CL:EQ CHILD MODULE))
            (CL:EQ (ISA? CHILD SGT-MODULES-MODULE) 1)
            (CL:EQ
             (STRING-EQL?
              (CLSYS-SVAL MODULE MODULE-FULL-NAME CHILD)
              (CLSYS-SVAL MODULE MODULE-FULL-NAME MODULE))
             1))
           (CL:SETQ VALUE-001 CHILD)
           (CL:RETURN))))
        (CL:SETQ OLDMODULE VALUE-001))
       (CL:WHEN
        (CL:NOT (CL:EQ OLDMODULE NULL))
        (UNDEFINE-MODULE OLDMODULE MODULE)
        (CL:RETURN)))))
    (FINALIZE-MODULE MODULE)
    (CL:RETURN-FROM DEFINE-MODULE MODULE)))
  :VOID)

;;; (DEFUN (DEFINE-MODULE-FROM-STRINGIFIED-SOURCE MODULE) ...)

(CL:DEFUN DEFINE-MODULE-FROM-STRINGIFIED-SOURCE (NAME STRINGIFIEDOPTIONS)
  (CL:RETURN-FROM
   DEFINE-MODULE-FROM-STRINGIFIED-SOURCE
   (DEFINE-MODULE NAME (UNSTRINGIFY STRINGIFIEDOPTIONS)))
  :VOID)

;;; (DEFUN (YIELD-DEFINE-MODULE CONS) ...)

(CL:DEFUN YIELD-DEFINE-MODULE (MODULE)
  "Return a cons tree that (when evaluated) constructs a Stella module
object."
  ()
  (CL:RETURN-FROM
   YIELD-DEFINE-MODULE
   (LIST*
    SYM-MODULES-DEFINE-MODULE-FROM-STRINGIFIED-SOURCE
    (WRAP-LITERAL (CLSYS-SVAL MODULE MODULE-FULL-NAME MODULE))
    (CONS
     (YIELD-STRING-CONSTANT-TREE
      (CLSYS-SVAL MODULE STRINGIFIED-OPTIONS MODULE))
     NIL)))
  :VOID)

;;; (DEFUN DEFMODULE ...)

(CL:DEFUN %%DEFMODULE (NAME OPTIONS)
  "Define (or redefine) a module named `name'.
The accepted syntax is:
	 
  (defmodule <module-name>
     [:documentation <docstring>]
     [:includes {<module-name> | (<module-name>*)}]
     [:uses {<module-name> | (<module-name>*)}]
     [:package <package-name-string>]
     [:case-sensitive? {TRUE | FALSE}]
     [:shadow (<symbol>*)])
     [<other-options>*])
	
`name' can be a string or a symbol.  The list of modules specified in the
`:includes' option plus (if supplied) the parent in the path used for `name'
become the new module's parents.  If no `:uses' option was supplied, the
new module will use the `STELLA' module by default, otherwise, it will use
the set of specified modules.  `:package' specifies the name of a native
package or name space in which symbols of the module should be allocated
when they get translated into a native language such as Lisp or C++.
By default, Lisp symbols are allocated in the `STELLA' package, and C++ names
are translated without any prefixes.  If `:case-sensitive?' is supplied
as TRUE, symbols in the module will be interned case-sensitively, otherwise
(the default), they will be converted to uppercase before they get interned.
Modules can shadow definitions of functions and classes inherited from
parents or used modules.  Shadowing is done automatically, but generates
a warning unless the shadowed type or function name is listed in the
`:shadow' option of the module definition.  CAUTION: The implementation of
shadowing is still somewhat fragile.

Examples:
	 
  (defmodule \"/PL-USER\"
    :uses (\"LOGIC\" \"STELLA\")
    :package \"PL-USER\")

  (defmodule /PL-USER/GENEALOGY)
	
Modules include objects from other modules via two separate mechanisms:
(1) they inherit from their parents specified via the `:includes' option
and/or a fully qualified module name, and (2) they inherit from used
modules specified via the `:uses' option.  The main difference between
the two mechanisms is that inheritance from parents is transitive, while
uses-links are only followed one level deep.  I.e., a module A that uses
B will see all objects of B (and any of B's parents) but not see anything
from modules used by B.  Another difference is that only objects declared
as public can be inherited via uses-links (this is not yet enforced).
Note that - contrary to Lisp - there are separate name spaces for classes,
functions, and variables.  For example, a module could inherit the class
`CONS' from the `STELLA' module, but shadow the function of the same name.
CAUTION: The implementation of this semantics has not yet been fully
completed."
  (CL:LET*
   ((MODULENAME (COERCE-TO-MODULE-NAME NAME TRUE)))
   (CL:WHEN
    (CL:NOT (CL:EQ MODULENAME NULL))
    (DEFINE-MODULE MODULENAME OPTIONS)))
  :VOID)

(CL:DEFUN DEFMODULE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%%DEFMODULE
   (CLSYS-SVAL CONS VALUE ARGUMENTS)
   (CLSYS-SVAL CONS REST ARGUMENTS))
  :VOID)

(CL:DEFMACRO DEFMODULE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define (or redefine) a module named `name'.
The accepted syntax is:
	 
  (defmodule <module-name>
     [:documentation <docstring>]
     [:includes {<module-name> | (<module-name>*)}]
     [:uses {<module-name> | (<module-name>*)}]
     [:package <package-name-string>]
     [:case-sensitive? {TRUE | FALSE}]
     [:shadow (<symbol>*)])
     [<other-options>*])
	
`name' can be a string or a symbol.  The list of modules specified in the
`:includes' option plus (if supplied) the parent in the path used for `name'
become the new module's parents.  If no `:uses' option was supplied, the
new module will use the `STELLA' module by default, otherwise, it will use
the set of specified modules.  `:package' specifies the name of a native
package or name space in which symbols of the module should be allocated
when they get translated into a native language such as Lisp or C++.
By default, Lisp symbols are allocated in the `STELLA' package, and C++ names
are translated without any prefixes.  If `:case-sensitive?' is supplied
as TRUE, symbols in the module will be interned case-sensitively, otherwise
(the default), they will be converted to uppercase before they get interned.
Modules can shadow definitions of functions and classes inherited from
parents or used modules.  Shadowing is done automatically, but generates
a warning unless the shadowed type or function name is listed in the
`:shadow' option of the module definition.  CAUTION: The implementation of
shadowing is still somewhat fragile.

Examples:
	 
  (defmodule \"/PL-USER\"
    :uses (\"LOGIC\" \"STELLA\")
    :package \"PL-USER\")

  (defmodule /PL-USER/GENEALOGY)
	
Modules include objects from other modules via two separate mechanisms:
(1) they inherit from their parents specified via the `:includes' option
and/or a fully qualified module name, and (2) they inherit from used
modules specified via the `:uses' option.  The main difference between
the two mechanisms is that inheritance from parents is transitive, while
uses-links are only followed one level deep.  I.e., a module A that uses
B will see all objects of B (and any of B's parents) but not see anything
from modules used by B.  Another difference is that only objects declared
as public can be inherited via uses-links (this is not yet enforced).
Note that - contrary to Lisp - there are separate name spaces for classes,
functions, and variables.  For example, a module could inherit the class
`CONS' from the `STELLA' module, but shadow the function of the same name.
CAUTION: The implementation of this semantics has not yet been fully
completed."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /STELLA/DEFMODULE)) (CL:MACRO-FUNCTION (CL:QUOTE DEFMODULE)))

;;; (DEFUN (CREATE-WORLD WORLD) ...)

(CL:DEFUN CREATE-WORLD (PARENTCONTEXT NAME)
  "Create a new world below the world or module 'parentContext'.
Optionally, specify a name."
  (CL:LET*
   ((WORLD (NEW-WORLD)))
   (CL:WHEN
    (CL:NOT (CL:EQ NAME NULL))
    (SET-DYNAMIC-SLOT-VALUE
     WORLD
     SYM-MODULES-WORLD-NAME
     (WRAP-STRING NAME)
     NULL-STRING-WRAPPER)
    (CL:LET*
     ((FOUND?-001 FALSE))
     (CL:LET*
      ((SIBLING NULL)
       (ITER-001
        (CLSYS-SVAL
         LIST
         THE-CONS-LIST
         (CLSYS-SVAL CONTEXT CHILD-CONTEXTS PARENTCONTEXT))))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ SIBLING (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (CL:WHEN
        (CL:EQ (STRING-EQL? (CONTEXT-NAME SIBLING) NAME) 1)
        (CL:SETQ FOUND?-001 TRUE)
        (CL:RETURN))))
     (CL:WHEN
      (CL:EQ FOUND?-001 1)
      (CL:WARN
       "Can't create a world named `~A' because a sibling already has that name."
       NAME)
      (CL:RETURN-FROM CREATE-WORLD NULL))))
   (CL:SETF (CLSYS-SVAL WORLD PARENT-CONTEXT WORLD) PARENTCONTEXT)
   (INSERT (CLSYS-SVAL CONTEXT CHILD-CONTEXTS PARENTCONTEXT) WORLD)
   (CL:SETF
    (CLSYS-SVAL WORLD BASE-MODULE WORLD)
    (CLSYS-SVAL CONTEXT BASE-MODULE PARENTCONTEXT))
   (FINALIZE-WORLD WORLD)
   (CL:RETURN-FROM CREATE-WORLD WORLD))
  :VOID)

;;; (DEFUN (PUSH-WORLD WORLD) ...)

(CL:DEFUN PUSH-WORLD ()
  "Spawn a new world that is a child of the current context,
and change the current context to the new world."
  (CL:RETURN-FROM PUSH-WORLD (CL:SETQ *CONTEXT* (CREATE-WORLD *CONTEXT* NULL)))
  :VOID)

;;; (DEFUN (POP-WORLD CONTEXT) ...)

(CL:DEFUN POP-WORLD ()
  "Destroy the current world and change the current
context to be its parent.  Return the current context. Nothing happens
if there is no current world."
  (CL:WHEN
   (CL:NOT (CL:EQ *CONTEXT* *MODULE*))
   (CL:LET*
    ((WORLD *CONTEXT*))
    (CL:SETQ *CONTEXT* (CLSYS-SVAL WORLD PARENT-CONTEXT WORLD))
    (DESTROY-WORLD WORLD)))
  (CL:RETURN-FROM POP-WORLD *CONTEXT*)
  :VOID)

;;; (DEFUN (ALL-SUBCONTEXTS (ALL-PURPOSE-ITERATOR OF CONTEXT)) ...)

(CL:DEFUN ALL-SUBCONTEXTS (CONTEXT TRAVERSAL)
  "Return an iterator that generates all subcontexts of
'self' (not including 'self') in the order specified by 'traversal' (one
of :preorder, :inorder, or :postorder)."
  (CL:LET*
   ((CONTEXTSITERATOR (NEW-ALL-PURPOSE-ITERATOR)) (SUBCONTEXTS NIL))
   (CL:LET*
    ((CHILD NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL CONTEXT CHILD-CONTEXTS CONTEXT)))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ CHILD (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (CONS CHILD NIL))
       (CL:IF
        (CL:EQ SUBCONTEXTS NIL)
        (CL:SETQ SUBCONTEXTS COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST SUBCONTEXTS COLLECT-001)))
      (CL:PROGN
       (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS CHILD NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:WHEN
    (CL:EQ TRAVERSAL KWD-MODULES-POSTORDER)
    (CL:SETQ SUBCONTEXTS (REVERSE SUBCONTEXTS)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST CONTEXTSITERATOR)
    SUBCONTEXTS)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT CONTEXTSITERATOR)
    TRAVERSAL)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE CONTEXTSITERATOR)
    (CL:FUNCTION ALL-SUBCONTEXTS-NEXT?))
   (CL:RETURN-FROM ALL-SUBCONTEXTS CONTEXTSITERATOR))
  :VOID)

;;; (DEFUN (ALL-SUBCONTEXTS-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-SUBCONTEXTS-NEXT? (SELF)
  (CL:LET*
   ((TRAVERSAL (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF))
    (REMAININGCONTEXTS
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))
    (THISCONTEXT NULL)
    (SUBCONTEXTS NIL))
   (CL:WHEN
    (CL:EQ REMAININGCONTEXTS NIL)
    (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) NULL)
    (CL:RETURN-FROM ALL-SUBCONTEXTS-NEXT? FALSE))
   (CL:SETQ THISCONTEXT (FIRST REMAININGCONTEXTS))
   (CL:LET*
    ((HEADCONS REMAININGCONTEXTS))
    (CL:SETQ REMAININGCONTEXTS (CLSYS-SVAL CONS REST REMAININGCONTEXTS))
    (FREE-CONS HEADCONS))
   (CL:LET*
    ((CHILD NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL CONTEXT CHILD-CONTEXTS THISCONTEXT)))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ CHILD (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:OR
       (CL:EQ (POP (PARENT-CONTEXTS CHILD)) THISCONTEXT)
       (CL:EQ (EMPTY? (PARENT-CONTEXTS CHILD)) 1))
      (CL:IF
       (CL:EQ COLLECT-001 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-001 (CONS CHILD NIL))
        (CL:IF
         (CL:EQ SUBCONTEXTS NIL)
         (CL:SETQ SUBCONTEXTS COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST SUBCONTEXTS COLLECT-001)))
       (CL:PROGN
        (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS CHILD NIL))
        (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001)))))))
   (CL:IF
    (CL:EQ SUBCONTEXTS NIL)
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
     REMAININGCONTEXTS)
    (CL:COND
     ((CL:EQ TRAVERSAL KWD-MODULES-PREORDER)
      (CL:SETF
       (CLSYS-SVAL CONS REST (LAST-CONS SUBCONTEXTS))
       REMAININGCONTEXTS)
      (CL:SETF
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
       SUBCONTEXTS))
     ((CL:EQ TRAVERSAL KWD-MODULES-POSTORDER)
      (CL:SETQ SUBCONTEXTS (REVERSE SUBCONTEXTS))
      (CL:SETF
       (CLSYS-SVAL CONS REST (LAST-CONS SUBCONTEXTS))
       REMAININGCONTEXTS)
      (CL:SETF
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
       SUBCONTEXTS))
     ((CL:EQ TRAVERSAL KWD-MODULES-INORDER)
      (CL:COND
       ((CL:EQ REMAININGCONTEXTS NIL)
        (CL:SETF
         (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
         SUBCONTEXTS))
       (CL:T
        (CL:SETF
         (CLSYS-SVAL CONS REST (LAST-CONS REMAININGCONTEXTS))
         SUBCONTEXTS)
        (CL:SETF
         (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
         REMAININGCONTEXTS))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" TRAVERSAL))))
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) THISCONTEXT)
   (CL:RETURN-FROM ALL-SUBCONTEXTS-NEXT? TRUE))
  :VOID)

;;; (DEFUN (ALL-CONTEXTS (ITERATOR OF CONTEXT)) ...)

(CL:DEFUN ALL-CONTEXTS ()
  "Return an iterator that generates all contexts."
  (CL:LET*
   ((ITERATOR (ALL-SUBCONTEXTS *ROOT-MODULE* KWD-MODULES-PREORDER)))
   (FREE-CONS-LIST
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST ITERATOR))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST ITERATOR)
    (CONS *ROOT-MODULE* NIL))
   (CL:RETURN-FROM ALL-CONTEXTS ITERATOR))
  :VOID)

;;; (DEFUN (FILTER-MODULE? BOOLEAN) ...)

(CL:DEFUN FILTER-MODULE? (SELF ITERATOR)
  (CL:RETURN-FROM FILTER-MODULE? (EQ? (PRIMARY-TYPE SELF) SGT-MODULES-MODULE))
  :VOID)

;;; (DEFUN (ALL-MODULES (ITERATOR OF MODULE)) ...)

(CL:DEFUN ALL-MODULES ()
  "Return an iterator that generates all modules."
  (CL:LET*
   ((CONTEXTSITERATOR (ALL-CONTEXTS)) (ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR FIRST-ITERATION? ITERATOR) TRUE)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR ITERATOR)
    CONTEXTSITERATOR)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION FILTERED-NESTED-ITERATOR-NEXT?))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-MODULE?))
   (CL:RETURN-FROM ALL-MODULES ITERATOR))
  :VOID)

;;; (DEFUN (VISIBLE-MODULES (ITERATOR OF MODULE)) ...)

(CL:DEFUN VISIBLE-MODULES (FROM)
  "Return an iterator that generates all modules visible from module `from'.
The generated modules are generated from most- to least-specific and 
will start with the module `from'."
  (CL:LET*
   ((VISIBLEMODULES NIL))
   (CL:WHEN (CL:EQ FROM NULL) (CL:SETQ FROM *MODULE*))
   (CL:SETQ VISIBLEMODULES (CONS FROM VISIBLEMODULES))
   (CL:LET*
    ((SUPER NULL) (ITER-001 (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS FROM)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUPER (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:SETQ VISIBLEMODULES (CONS SUPER VISIBLEMODULES))))
   (CL:LET*
    ((USEE NULL)
     (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST (CLSYS-SVAL MODULE USES FROM))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ USEE (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:SETQ VISIBLEMODULES (CONS USEE VISIBLEMODULES))
     (CL:LET*
      ((USEESUPER NULL)
       (ITER-003 (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS USEE)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-003 NIL))
       DO
       (CL:PROGN
        (CL:SETQ USEESUPER (CLSYS-SVAL CONS VALUE ITER-003))
        (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
       (CL:WHEN
        (CL:EQ (MEMB? VISIBLEMODULES USEESUPER) 0)
        (CL:SETQ VISIBLEMODULES (CONS USEESUPER VISIBLEMODULES)))))))
   (CL:RETURN-FROM
    VISIBLE-MODULES
    (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR (REVERSE VISIBLEMODULES))))
  :VOID)

;;; (DEFUN (CARDINAL-MODULE? BOOLEAN) ...)

(CL:DEFUN CARDINAL-MODULE? (SELF)
  (CL:RETURN-FROM
   CARDINAL-MODULE?
   (EQ? (CLSYS-SVAL MODULE CARDINAL-MODULE SELF) SELF))
  :VOID)

;;; (DEFUN (VISIBLE-FROM? BOOLEAN) ...)

(CL:DEFUN VISIBLE-FROM? (VIEWEDMODULE FROMMODULE)
  (CL:LET*
   ((TEST-VALUE-001 FALSE))
   (CL:IF
    (CL:EQ VIEWEDMODULE FROMMODULE)
    (CL:SETQ TEST-VALUE-001 TRUE)
    (CL:IF
     (CL:EQ
      (MEMBER? (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS FROMMODULE) VIEWEDMODULE)
      1)
     (CL:SETQ TEST-VALUE-001 TRUE)
     (CL:LET*
      ((FOUND?-001 FALSE))
      (CL:LET*
       ((USESMODULE NULL)
        (ITER-001
         (CLSYS-SVAL LIST THE-CONS-LIST (CLSYS-SVAL MODULE USES FROMMODULE))))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ USESMODULE (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:WHEN
         (CL:OR
          (CL:EQ VIEWEDMODULE USESMODULE)
          (CL:EQ
           (MEMBER?
            (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS USESMODULE)
            VIEWEDMODULE)
           1))
         (CL:SETQ FOUND?-001 TRUE)
         (CL:RETURN))))
      (CL:SETQ TEST-VALUE-001 FOUND?-001))))
   (CL:LET*
    ((VALUE-001 TEST-VALUE-001))
    (CL:RETURN-FROM VISIBLE-FROM? VALUE-001)))
  :VOID)

;;; (DEFUN CLEAR-ONE-CONTEXT ...)

(CL:DEFUN CLEAR-ONE-CONTEXT (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-MODULES-MODULE) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:EQ (CLEARABLE? SELF) 0)
       (CL:WARN
        "Module `~A' cannot be cleared!"
        (CLSYS-SVAL MODULE MODULE-FULL-NAME SELF))
       (CL:RETURN-FROM CLEAR-ONE-CONTEXT))
      (RUN-HOOKS *CLEAR-MODULE-HOOKS* SELF)
      (CL:LET*
       ((FUNCTION NULL) (ITER-001 (ALL-FUNCTIONS SELF TRUE)))
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? ITER-001) 1)
        DO
        (CL:PROGN (CL:SETQ FUNCTION (CLSYS-SVAL ITERATOR VALUE ITER-001)))
        (DESTROY-FUNCTION FUNCTION)))
      (CL:LET*
       ((VARIABLE NULL) (ITER-002 (ALL-VARIABLES SELF TRUE)))
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? ITER-002) 1)
        DO
        (CL:PROGN (CL:SETQ VARIABLE (CLSYS-SVAL ITERATOR VALUE ITER-002)))
        (DESTROY-VARIABLE VARIABLE)))
      (CL:LET*
       ((CLASS NULL) (ITER-003 (ALL-CLASSES SELF TRUE)))
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? ITER-003) 1)
        DO
        (CL:PROGN (CL:SETQ CLASS (CLSYS-SVAL ITERATOR VALUE ITER-003)))
        (DESTROY-CLASS CLASS)))
      (CL:LET*
       ((SYMBOL NULL) (ITER-004 (ALL-SYMBOLS SELF TRUE)))
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? ITER-004) 1)
        DO
        (CL:PROGN (CL:SETQ SYMBOL (CLSYS-SVAL ITERATOR VALUE ITER-004)))
        (UNINTERN-SYMBOL SYMBOL)))
      (CL:LET*
       ((SURROGATE NULL) (ITER-005 (ALL-SURROGATES SELF TRUE)))
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? ITER-005) 1)
        DO
        (CL:PROGN (CL:SETQ SURROGATE (CLSYS-SVAL ITERATOR VALUE ITER-005)))
        (UNINTERN-SURROGATE SURROGATE)))
      (CL:LET*
       ((*MODULE* SELF))
       (CL:DECLARE (CL:SPECIAL *MODULE*))
       (CL:LET*
        ((IT (ALLOCATE-ITERATOR (SHADOWED-SURROGATES SELF))))
        (CL:LOOP
         WHILE
         (CL:EQ (NEXT? IT) 1)
         DO
         (VALUE-SETTER
          IT
          (SHADOW-SURROGATE
           (CLSYS-SVAL
            SURROGATE
            SYMBOL-NAME
            (CLSYS-SVAL LIST-ITERATOR VALUE IT)))))))))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN CLEAR-CONTEXT ...)

(CL:DEFUN CLEAR-CONTEXT (SELF)
  "Destroy all objects belonging to 'self' or any of its subcontexts."
  (CL:LET*
   ((CHILD NULL)
    (ITER-001
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL CONTEXT CHILD-CONTEXTS SELF))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ CHILD (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CLEAR-CONTEXT CHILD)))
  (CLEAR-ONE-CONTEXT SELF)
  :VOID)

;;; (DEFUN CLEAR-MODULE ...)

(CL:DEFUN %%CLEAR-MODULE (NAME)
  "Destroy all objects belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing."
  (CL:LET*
   ((MODULE (COERCE-TO-MODULE (FIRST NAME) TRUE)))
   (CL:WHEN
    (CL:NOT (CL:EQ MODULE NULL))
    (CL:WHEN
     (CL:OR
      (CL:NOT (CL:EQ NAME NIL))
      (CL:EQ
       (Y-OR-N?
        (CONCATENATE
         "Really clear module "
         (CONCATENATE (CLSYS-SVAL MODULE MODULE-FULL-NAME MODULE) "? ")))
       1))
     (CLEAR-CONTEXT MODULE))))
  :VOID)

(CL:DEFUN CLEAR-MODULE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%%CLEAR-MODULE ARGUMENTS)
  :VOID)

(CL:DEFMACRO CLEAR-MODULE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Destroy all objects belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /STELLA/CLEAR-MODULE)) (CL:MACRO-FUNCTION (CL:QUOTE CLEAR-MODULE)))

(CL:DEFUN STARTUP-MODULES ()
  (CL:LET*
   ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     KWD-MODULES-DESTROY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESTROY" NULL 2))
    (CL:SETQ
     SGT-MODULES-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" NULL 1))
    (CL:SETQ SYM-MODULES-NAME (INTERN-RIGID-SYMBOL-WRT-MODULE "NAME" NULL 0))
    (CL:SETQ
     SYM-MODULES-*SHADOWEDSURROGATES*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*SHADOWEDSURROGATES*" NULL 0))
    (CL:SETQ
     SYM-MODULES-SHADOWED-SURROGATES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SHADOWED-SURROGATES" NULL 0))
    (CL:SETQ
     KWD-MODULES-INCLUDES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INCLUDES" NULL 2))
    (CL:SETQ KWD-MODULES-USES (INTERN-RIGID-SYMBOL-WRT-MODULE "USES" NULL 2))
    (CL:SETQ
     KWD-MODULES-SHADOW
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SHADOW" NULL 2))
    (CL:SETQ
     KWD-MODULES-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
    (CL:SETQ
     KWD-MODULES-CASE-SENSITIVE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CASE-SENSITIVE?" NULL 2))
    (CL:SETQ SYM-MODULES-TRUE (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
    (CL:SETQ
     KWD-MODULES-PACKAGE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PACKAGE" NULL 2))
    (CL:SETQ
     KWD-MODULES-REQUIRES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REQUIRES" NULL 2))
    (CL:SETQ
     KWD-MODULES-DIRECTORY-FILE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTORY-FILE" NULL 2))
    (CL:SETQ
     KWD-MODULES-CODE-FILES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CODE-FILES" NULL 2))
    (CL:SETQ
     KWD-MODULES-DEFINITIONS-FILE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINITIONS-FILE" NULL 2))
    (CL:SETQ
     KWD-MODULES-PRESERVE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRESERVE" NULL 2))
    (CL:SETQ
     KWD-MODULES-CLEAR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEAR" NULL 2))
    (CL:SETQ
     KWD-MODULES-PREORDER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PREORDER" NULL 2))
    (CL:SETQ
     SGT-MODULES-WORLD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD" NULL 1))
    (CL:SETQ
     SYM-MODULES-DEFINE-MODULE-FROM-STRINGIFIED-SOURCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "DEFINE-MODULE-FROM-STRINGIFIED-SOURCE"
      NULL
      0))
    (CL:SETQ
     SYM-MODULES-DEFMODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMODULE" NULL 0))
    (CL:SETQ
     KWD-MODULES-COMMON-LISP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
    (CL:SETQ
     KWD-MODULES-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     SYM-MODULES-EVALUATOR-WRAPPER-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATOR-WRAPPER-CODE" NULL 0))
    (CL:SETQ
     SYM-MODULES-WORLD-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD-NAME" NULL 0))
    (CL:SETQ
     KWD-MODULES-POSTORDER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "POSTORDER" NULL 2))
    (CL:SETQ
     KWD-MODULES-INORDER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INORDER" NULL 2))
    (CL:SETQ
     SYM-MODULES-CLEARABLE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEARABLE?" NULL 0))
    (CL:SETQ
     SYM-MODULES-CLEAR-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEAR-MODULE" NULL 0)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:SETQ *SUBCONTEXT-REVISION-POLICY* KWD-MODULES-DESTROY))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 5) 1)
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE "(DEFTYPE NAME OBJECT)"))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PARENT-CONTEXTS"
        "CONTEXT"
        "(DEFMETHOD (PARENT-CONTEXTS (ITERATOR OF CONTEXT)) ((SELF CONTEXT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PARENT-CONTEXTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PARENT-CONTEXTS"
        "MODULE"
        "(DEFMETHOD (PARENT-CONTEXTS (ITERATOR OF CONTEXT)) ((SELF MODULE)) :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PARENT-CONTEXTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PARENT-CONTEXTS"
        "WORLD"
        "(DEFMETHOD (PARENT-CONTEXTS (ITERATOR OF CONTEXT)) ((SELF WORLD)) :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PARENT-CONTEXTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME"
        "STRING"
        "(DEFUN (COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME CONTEXT INTEGER) ((PATHNAME STRING) (MODULE? BOOLEAN) (SYMBOLNAME? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPONENT-MATCH?"
        "STRING"
        "(DEFUN (COMPONENT-MATCH? BOOLEAN) ((COMPONENT STRING) (STRING STRING) (START INTEGER) (END INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPONENT-MATCH?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-MODULE-AND-BARE-NAME"
        "STRING"
        "(DEFUN (COMPUTE-MODULE-AND-BARE-NAME MODULE STRING) ((NAME STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-MODULE-AND-BARE-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INTERN-QUALIFIED-NAME"
        "STRING"
        "(DEFUN (INTERN-QUALIFIED-NAME GENERALIZED-SYMBOL) ((NAME STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INTERN-QUALIFIED-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-CONTEXT"
        "STRING"
        "(DEFUN (GET-CONTEXT CONTEXT) ((PATHNAME STRING) (WARN? BOOLEAN)) :DOCUMENTATION \"Return the context located at 'pathName', or NULL
if no such context exists.  If 'warn?' is TRUE, print a warning
message if no context is found.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SCAN-FOR-MODULE"
        "STRING"
        "(DEFMETHOD (SCAN-FOR-MODULE MODULE) ((NAME STRING) (VANTAGEPOINT MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SCAN-FOR-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-MODULE"
        "STRING"
        "(DEFMETHOD (GET-MODULE MODULE) ((PATHNAME STRING) (WARN? BOOLEAN)) :DOCUMENTATION \"Return the module located at 'pathName', or NULL
if no such module exists.  The search looks at ancestors and top-most
 (cardinal) modules.  If 'warn?' is TRUE, print a warning
message if no module is found.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COERCE-TO-MODULE-NAME"
        "OBJECT"
        "(DEFUN (COERCE-TO-MODULE-NAME STRING) ((NAMESPEC NAME) (WARN? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COERCE-TO-MODULE-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COERCE-TO-MODULE"
        "OBJECT"
        "(DEFUN (COERCE-TO-MODULE MODULE) ((OBJECT OBJECT) (WARN? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COERCE-TO-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-OR-CREATE-MODULE"
        "STRING"
        "(DEFUN (FIND-OR-CREATE-MODULE MODULE) ((PATHNAME STRING)) :DOCUMENTATION \"Return a module located at `pathname' if one exists,
  otherwise create one\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-OR-CREATE-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CHANGE-CURRENT-MODULE"
        "MODULE"
        "(DEFUN (CHANGE-CURRENT-MODULE MODULE) ((MODULE MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CHANGE-CURRENT-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CHANGE-CURRENT-CONTEXT"
        "CONTEXT"
        "(DEFUN (CHANGE-CURRENT-CONTEXT CONTEXT) ((CONTEXT CONTEXT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CHANGE-CURRENT-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CHANGE-CONTEXT"
        "CONTEXT"
        "(DEFMETHOD (CHANGE-CONTEXT CONTEXT) ((CONTEXT CONTEXT)) :DOCUMENTATION \"Change the current context to be the context
'context'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CHANGE-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CHANGE-CONTEXT"
        "STRING"
        "(DEFMETHOD (CHANGE-CONTEXT CONTEXT) ((CONTEXTNAME STRING)) :DOCUMENTATION \"Change the current context to be the context named
'contextName'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CHANGE-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CHANGE-MODULE"
        "MODULE"
        "(DEFMETHOD (CHANGE-MODULE MODULE) ((MODULE MODULE)) :DOCUMENTATION \"Change the current module to be the module
'module'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CHANGE-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CHANGE-MODULE"
        "STRING"
        "(DEFMETHOD (CHANGE-MODULE MODULE) ((MODULENAME STRING)) :DOCUMENTATION \"Change the current module to be the module named
'moduleName'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CHANGE-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MULTIPLE-PARENTS?"
        "MODULE"
        "(DEFMETHOD (MULTIPLE-PARENTS? BOOLEAN) ((MODULE MODULE)) :DOCUMENTATION \"Return TRUE if 'module' has more than one parent.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MULTIPLE-PARENTS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NORMALIZE-PARENT-MODULES"
        "MODULE"
        "(DEFUN NORMALIZE-PARENT-MODULES ((SELF MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NORMALIZE-PARENT-MODULES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-SUPERCONTEXTS"
        "MODULE"
        "(DEFUN INHERIT-SUPERCONTEXTS ((MODULE MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-SUPERCONTEXTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNINHERIT-SUPERCONTEXTS"
        "MODULE"
        "(DEFUN UNINHERIT-SUPERCONTEXTS ((MODULE MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNINHERIT-SUPERCONTEXTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-USED-MODULES"
        "MODULE"
        "(DEFUN INHERIT-USED-MODULES ((MODULE MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-USED-MODULES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNINHERIT-USED-MODULES"
        "MODULE"
        "(DEFUN UNINHERIT-USED-MODULES ((MODULE MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNINHERIT-USED-MODULES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-MODULE"
        "MODULE"
        "(DEFUN FINALIZE-MODULE ((SELF MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINALIZE-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-WORLD"
        "WORLD"
        "(DEFUN FINALIZE-WORLD ((SELF WORLD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINALIZE-WORLD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNFINALIZE-MODULE"
        "MODULE"
        "(DEFMETHOD UNFINALIZE-MODULE ((SELF MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION UNFINALIZE-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNFINALIZE-WORLD"
        "WORLD"
        "(DEFMETHOD UNFINALIZE-WORLD ((SELF WORLD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION UNFINALIZE-WORLD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-MODULE"
        "MODULE"
        "(DEFUN DESTROY-MODULE ((SELF MODULE)) :DOCUMENTATION \"Destroy the module 'self', and recursively destroy
all contexts that inherit 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESTROY-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-WORLD"
        "WORLD"
        "(DEFUN DESTROY-WORLD ((SELF WORLD)) :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESTROY-WORLD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-CONTEXT"
        "MODULE"
        "(DEFMETHOD DESTROY-CONTEXT ((SELF MODULE)) :DOCUMENTATION \"Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DESTROY-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-CONTEXT"
        "WORLD"
        "(DEFMETHOD DESTROY-CONTEXT ((SELF WORLD)) :DOCUMENTATION \"Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DESTROY-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-CONTEXT"
        "STRING"
        "(DEFMETHOD DESTROY-CONTEXT ((SELF STRING)) :DOCUMENTATION \"Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DESTROY-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-CONTEXT"
        "CONTEXT"
        "(DEFMETHOD DESTROY-CONTEXT ((SELF CONTEXT)) :DOCUMENTATION \"Make the translator happy.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DESTROY-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LINK-TO-PARENT-MODULE"
        "MODULE"
        "(DEFUN LINK-TO-PARENT-MODULE ((SELF MODULE) (PARENT MODULE) (INSERT-FIRST? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LINK-TO-PARENT-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INCORPORATE-MODULE-NAME"
        "MODULE"
        "(DEFUN INCORPORATE-MODULE-NAME ((MODULE MODULE) (NAME STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INCORPORATE-MODULE-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INCORPORATE-INCLUDES-MODULES"
        "MODULE"
        "(DEFUN INCORPORATE-INCLUDES-MODULES ((MODULE MODULE) (INCLUDEES OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INCORPORATE-INCLUDES-MODULES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INCORPORATE-USES-MODULES"
        "MODULE"
        "(DEFUN INCORPORATE-USES-MODULES ((MODULE MODULE) (USEES OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INCORPORATE-USES-MODULES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INCORPORATE-MODULE-OPTIONS"
        "MODULE"
        "(DEFUN INCORPORATE-MODULE-OPTIONS ((SELF MODULE) (OPTIONS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INCORPORATE-MODULE-OPTIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNDEFINE-MODULE"
        "MODULE"
        "(DEFUN UNDEFINE-MODULE ((OLDMODULE MODULE) (NEWMODULE MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNDEFINE-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFINE-MODULE"
        "STRING"
        "(DEFUN (DEFINE-MODULE MODULE) ((NAME STRING) (OPTIONS CONS)) :DOCUMENTATION \"Define or redefine a module named 'name' having the
options 'options'.  Return the new module.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFINE-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFINE-MODULE-FROM-STRINGIFIED-SOURCE"
        "STRING"
        "(DEFUN (DEFINE-MODULE-FROM-STRINGIFIED-SOURCE MODULE) ((NAME STRING) (STRINGIFIEDOPTIONS STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFINE-MODULE-FROM-STRINGIFIED-SOURCE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-DEFINE-MODULE"
        "MODULE"
        "(DEFUN (YIELD-DEFINE-MODULE CONS) ((MODULE MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-DEFINE-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFMODULE"
        "OBJECT"
        "(DEFUN DEFMODULE ((NAME NAME) |&REST| (OPTIONS OBJECT)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Define (or redefine) a module named `name'.
The accepted syntax is:
	 
  (defmodule <module-name>
     [:documentation <docstring>]
     [:includes {<module-name> | (<module-name>*)}]
     [:uses {<module-name> | (<module-name>*)}]
     [:package <package-name-string>]
     [:case-sensitive? {TRUE | FALSE}]
     [:shadow (<symbol>*)])
     [<other-options>*])
	
`name' can be a string or a symbol.  The list of modules specified in the
`:includes' option plus (if supplied) the parent in the path used for `name'
become the new module's parents.  If no `:uses' option was supplied, the
new module will use the `STELLA' module by default, otherwise, it will use
the set of specified modules.  `:package' specifies the name of a native
package or name space in which symbols of the module should be allocated
when they get translated into a native language such as Lisp or C++.
By default, Lisp symbols are allocated in the `STELLA' package, and C++ names
are translated without any prefixes.  If `:case-sensitive?' is supplied
as TRUE, symbols in the module will be interned case-sensitively, otherwise
(the default), they will be converted to uppercase before they get interned.
Modules can shadow definitions of functions and classes inherited from
parents or used modules.  Shadowing is done automatically, but generates
a warning unless the shadowed type or function name is listed in the
`:shadow' option of the module definition.  CAUTION: The implementation of
shadowing is still somewhat fragile.

Examples:
	 
  (defmodule \\\"/PL-USER\\\"
    :uses (\\\"LOGIC\\\" \\\"STELLA\\\")
    :package \\\"PL-USER\\\")

  (defmodule /PL-USER/GENEALOGY)
	
Modules include objects from other modules via two separate mechanisms:
(1) they inherit from their parents specified via the `:includes' option
and/or a fully qualified module name, and (2) they inherit from used
modules specified via the `:uses' option.  The main difference between
the two mechanisms is that inheritance from parents is transitive, while
uses-links are only followed one level deep.  I.e., a module A that uses
B will see all objects of B (and any of B's parents) but not see anything
from modules used by B.  Another difference is that only objects declared
as public can be inherited via uses-links (this is not yet enforced).
Note that - contrary to Lisp - there are separate name spaces for classes,
functions, and variables.  For example, a module could inherit the class
`CONS' from the `STELLA' module, but shadow the function of the same name.
CAUTION: The implementation of this semantics has not yet been fully
completed.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%DEFMODULE))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-MODULES-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION DEFMODULE-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "IN-MODULE"
     "OBJECT"
     "(DEFUN (IN-MODULE MODULE) ((NAME NAME)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :NATIVE? TRUE :DOCUMENTATION \"Change the current module to the module named `name'.\")")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-WORLD"
        "CONTEXT"
        "(DEFUN (CREATE-WORLD WORLD) ((PARENTCONTEXT CONTEXT) (NAME STRING)) :DOCUMENTATION \"Create a new world below the world or module 'parentContext'.
Optionally, specify a name.\" :PUBLIC? TRUE :INLINE FINALIZE-WORLD)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-WORLD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PUSH-WORLD"
        NULL
        "(DEFUN (PUSH-WORLD WORLD) () :DOCUMENTATION \"Spawn a new world that is a child of the current context,
and change the current context to the new world.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PUSH-WORLD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POP-WORLD"
        NULL
        "(DEFUN (POP-WORLD CONTEXT) () :DOCUMENTATION \"Destroy the current world and change the current
context to be its parent.  Return the current context. Nothing happens
if there is no current world.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION POP-WORLD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-SUBCONTEXTS"
        "CONTEXT"
        "(DEFUN (ALL-SUBCONTEXTS (ALL-PURPOSE-ITERATOR OF CONTEXT)) ((CONTEXT CONTEXT) (TRAVERSAL KEYWORD)) :DOCUMENTATION \"Return an iterator that generates all subcontexts of
'self' (not including 'self') in the order specified by 'traversal' (one
of :preorder, :inorder, or :postorder).\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-SUBCONTEXTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-SUBCONTEXTS-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (ALL-SUBCONTEXTS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-SUBCONTEXTS-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-CONTEXTS"
        NULL
        "(DEFUN (ALL-CONTEXTS (ITERATOR OF CONTEXT)) () :DOCUMENTATION \"Return an iterator that generates all contexts.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-CONTEXTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTER-MODULE?"
        "OBJECT"
        "(DEFUN (FILTER-MODULE? BOOLEAN) ((SELF OBJECT) (ITERATOR ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTER-MODULE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-MODULES"
        NULL
        "(DEFUN (ALL-MODULES (ITERATOR OF MODULE)) () :DOCUMENTATION \"Return an iterator that generates all modules.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-MODULES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VISIBLE-MODULES"
        "MODULE"
        "(DEFUN (VISIBLE-MODULES (ITERATOR OF MODULE)) ((FROM MODULE)) :DOCUMENTATION \"Return an iterator that generates all modules visible from module `from'.
The generated modules are generated from most- to least-specific and 
will start with the module `from'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VISIBLE-MODULES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CARDINAL-MODULE?"
        "MODULE"
        "(DEFUN (CARDINAL-MODULE? BOOLEAN) ((SELF MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CARDINAL-MODULE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VISIBLE-FROM?"
        "MODULE"
        "(DEFUN (VISIBLE-FROM? BOOLEAN) ((VIEWEDMODULE MODULE) (FROMMODULE MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VISIBLE-FROM?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR-ONE-CONTEXT"
        "CONTEXT"
        "(DEFUN CLEAR-ONE-CONTEXT ((SELF CONTEXT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLEAR-ONE-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR-CONTEXT"
        "CONTEXT"
        "(DEFUN CLEAR-CONTEXT ((SELF CONTEXT)) :DOCUMENTATION \"Destroy all objects belonging to 'self' or any of its subcontexts.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLEAR-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR-MODULE"
        "ARGUMENT-LIST"
        "(DEFUN CLEAR-MODULE (|&REST| (NAME NAME)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Destroy all objects belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%CLEAR-MODULE))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-MODULES-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION CLEAR-MODULE-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-MODULES"
     NULL
     "(DEFUN STARTUP-MODULES ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SUBCONTEXT-REVISION-POLICY* KEYWORD :DESTROY :DOCUMENTATION \"Controls actions reflexive transitive closure of
   subcontexts when a context is revised.
   Values are ':destroy' -- destroy subcontexts;
   ':clear' -- clear contents of subcontexts;
   ':preserve' -- don't disturb subcontexts.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *SHADOWEDSURROGATES* (CONS OF SYMBOL) NULL :DOCUMENTATION \"Holds list of symbols representing surrogates
to be shadowed during module finalization.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-MODULES-*SHADOWEDSURROGATES*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*SHADOWEDSURROGATES*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*SHADOWEDSURROGATES*)))
    (REGISTER-NATIVE-NAME
     SYM-MODULES-DEFMODULE
     KWD-MODULES-COMMON-LISP
     KWD-MODULES-FUNCTION)
    (SET-DYNAMIC-SLOT-VALUE
     *ROOT-MODULE*
     SYM-MODULES-CLEARABLE?
     (WRAP-BOOLEAN FALSE)
     NULL-BOOLEAN-WRAPPER)
    (SET-DYNAMIC-SLOT-VALUE
     *STELLA-MODULE*
     SYM-MODULES-CLEARABLE?
     (WRAP-BOOLEAN FALSE)
     NULL-BOOLEAN-WRAPPER)
    (SET-DYNAMIC-SLOT-VALUE
     *COMMON-LISP-MODULE*
     SYM-MODULES-CLEARABLE?
     (WRAP-BOOLEAN FALSE)
     NULL-BOOLEAN-WRAPPER)
    (REGISTER-NATIVE-NAME
     SYM-MODULES-CLEAR-MODULE
     KWD-MODULES-COMMON-LISP
     KWD-MODULES-FUNCTION)))
  :VOID)
