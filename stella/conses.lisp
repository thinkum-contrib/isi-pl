;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-CONSES-ABSTRACT-ITERATOR NULL)
(CL:DEFVAR SYM-CONSES-VALUE NULL)
(CL:DEFVAR SYM-CONSES-VALUE-SETTER NULL)
(CL:DEFVAR SYM-CONSES-SLOT-WRITER NULL)
(CL:DEFVAR SGT-CONSES-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SYM-CONSES-*PRINTPRETTY?* NULL)
(CL:DEFVAR SYM-CONSES-*PRINTREADABLY?* NULL)
(CL:DEFVAR SYM-CONSES-*PRINTPRETTYCODE?* NULL)
(CL:DEFVAR SYM-CONSES-*DEPTHEXCEEDED?* NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* STANDARD-OUTPUT EOL *TRANSIENTOBJECTS?*))

;;; (DEFGLOBAL NIL ...)

(CL:DEFVAR NIL NULL)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF CONS))
  "Return TRUE iff 'self' equals NIL."
  (CL:RETURN-FROM EMPTY? (EQ? SELF NIL))
  :VOID)

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF CONS))
  "Return TRUE iff 'self' is not equal to NIL."
  (CL:RETURN-FROM NON-EMPTY? (CL:IF (CL:NOT (CL:EQ SELF NIL)) TRUE FALSE))
  :VOID)

;;; (DEFUN (NIL? BOOLEAN) ...)

(CL:DEFUN NIL? (X)
  "Return TRUE iff 'x' equals NIL."
  (CL:RETURN-FROM NIL? (EQ? X NIL))
  :VOID)

;;; (DEFMETHOD FREE-CONS ...)

(CL:DEFMETHOD FREE-CONS ((SELF CONS))
  (CL:WHEN (CL:NOT (CL:EQ SELF NIL)) (FREE SELF))
  :VOID)

;;; (DEFUN FREE-CONS-LIST ...)

(CL:DEFUN FREE-CONS-LIST (SELF)
  (CL:WHEN (CL:EQ SELF NIL) (CL:RETURN-FROM FREE-CONS-LIST))
  (CL:LET*
   ((NEXT SELF) (CURRENT NULL))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ NEXT NIL))
    DO
    (CL:SETQ CURRENT NEXT)
    (CL:SETQ NEXT (CLSYS-SVAL CONS REST NEXT))
    (FREE-CONS CURRENT)))
  :VOID)

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF CONS))
  "Return the length of the CONS list 'self'.  CAUTION: Breaks if
'self' is not the head of a CONS list."
  (CL:LET*
   ((CONS SELF) (I 0))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CONS NIL))
    DO
    (CL:SETQ I (CL:1+ I))
    (CL:SETQ CONS (CLSYS-SVAL CONS REST CONS)))
   (CL:RETURN-FROM LENGTH I))
  :VOID)

;;; (DEFMETHOD (POSITION INTEGER) ...)

(CL:DEFMETHOD POSITION ((SELF CONS) OBJECT START)
  "Return the position of 'object' within the cons-list
'self' (counting from zero); or return NULL if 'object' does not occur within 
'self' (uses an 'eql?' test).  If 'start' was supplied as non-NULL, only 
consider the sublist starting at 'start', however, the returned position 
will always be relative to the entire list."
  (CL:WHEN (CL:EQ (NULL? START) 1) (CL:SETQ START 0))
  (CL:LET*
   ((POSITION NULL)
    (ELEMENT NULL)
    (ITER-001 (NTH-REST SELF START))
    (ITER-002 START))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ ELEMENT (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:PROGN (CL:SETQ POSITION ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
    (CL:WHEN
     (CL:EQ (EQL? ELEMENT OBJECT) 1)
     (CL:RETURN-FROM POSITION POSITION))))
  (CL:RETURN-FROM POSITION NULL-INTEGER)
  :VOID)

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF CONS) OBJECT)
  "Return TRUE iff 'object' is a member of the cons list
'self' (uses an 'eql?' test)."
  (CL:LET*
   ((I NULL) (ITER-001 SELF))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ I (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN (CL:EQ (EQL? I OBJECT) 1) (CL:RETURN-FROM MEMBER? TRUE))))
  (CL:RETURN-FROM MEMBER? FALSE)
  :VOID)

;;; (DEFMETHOD (MEMB? BOOLEAN) ...)

(CL:DEFMETHOD MEMB? ((SELF CONS) OBJECT)
  "Return TRUE iff 'object' is a member of the cons list
'self' (uses an 'eq?' test)."
  (CL:LET*
   ((I NULL) (ITER-001 SELF))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ I (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN (CL:EQ I OBJECT) (CL:RETURN-FROM MEMB? TRUE))))
  (CL:RETURN-FROM MEMB? FALSE)
  :VOID)

;;; (DEFUN (CONS CONS) ...)

(CL:DEFUN CONS (VALUE REST)
  "Return a cons record that points to 'value' and 'rest'."
  (CL:LET*
   ((CONS NULL))
   (CL:IF
    (CL:EQ *TRANSIENTOBJECTS?* 1)
    (CL:SETQ CONS (NEW-TRANSIENT-CONS))
    (CL:SETQ CONS (NEW-CONS)))
   (CL:SETF (CLSYS-SVAL CONS VALUE CONS) VALUE)
   (CL:SETF (CLSYS-SVAL CONS REST CONS) REST)
   (CL:RETURN-FROM CONS CONS))
  :VOID)

;;; (DEFUN (PERMANENT-CONS CONS) ...)

(CL:DEFUN PERMANENT-CONS (VALUE REST)
  "Return a permanent cons record that points to 'value' and 'rest'."
  (CL:LET*
   ((CONS NULL))
   (CL:SETQ CONS (NEW-CONS))
   (CL:SETF (CLSYS-SVAL CONS VALUE CONS) VALUE)
   (CL:SETF (CLSYS-SVAL CONS REST CONS) REST)
   (CL:RETURN-FROM PERMANENT-CONS CONS))
  :VOID)

;;; (DEFUN (LOCAL-CONS CONS) ...)

(CL:DEFUN LOCAL-CONS (VALUE REST)
  "Return local cons record that points to 'value' and 'rest'."
  (CL:RETURN-FROM LOCAL-CONS (CONS VALUE REST))
  :VOID)

;;; (DEFMETHOD (REMOVE CONS) ...)

(CL:DEFMETHOD REMOVE ((SELF CONS) VALUE)
  "Remove all entries in the cons list 'self' that match
'value'.  Unless the remaining list is NIL, insure that the cons that
heads the list is unchanged."
  (CL:LET*
   ((CONS SELF) (PREVIOUSCONS NULL) (MATCHINGCONS NULL))
   (CL:WHEN
    (CL:NOT (CL:EQ CONS NIL))
    (CL:WHEN
     (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST CONS) NIL))
     (CL:SETQ PREVIOUSCONS CONS)
     (CL:SETQ CONS (CLSYS-SVAL CONS REST CONS))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ CONS NIL))
      DO
      (CL:IF
       (CL:EQ (EQL? (CLSYS-SVAL CONS VALUE CONS) VALUE) 1)
       (CL:PROGN
        (CL:SETF
         (CLSYS-SVAL CONS REST PREVIOUSCONS)
         (CLSYS-SVAL CONS REST CONS))
        (CL:SETQ MATCHINGCONS CONS)
        (CL:SETQ CONS (CLSYS-SVAL CONS REST CONS))
        (FREE MATCHINGCONS))
       (CL:PROGN
        (CL:SETQ PREVIOUSCONS CONS)
        (CL:SETQ CONS (CLSYS-SVAL CONS REST CONS))))))
    (CL:WHEN
     (CL:EQ (EQL? (CLSYS-SVAL CONS VALUE SELF) VALUE) 1)
     (CL:WHEN
      (CL:EQ (CLSYS-SVAL CONS REST SELF) NIL)
      (FREE SELF)
      (CL:RETURN-FROM REMOVE NIL))
     (CL:SETQ CONS (CLSYS-SVAL CONS REST SELF))
     (CL:SETF (CLSYS-SVAL CONS VALUE SELF) (CLSYS-SVAL CONS VALUE CONS))
     (CL:SETF (CLSYS-SVAL CONS REST SELF) (CLSYS-SVAL CONS REST CONS))
     (FREE CONS)))
   (CL:RETURN-FROM REMOVE SELF))
  :VOID)

;;; (DEFMETHOD (REMOVE-DUPLICATES CONS) ...)

(CL:DEFMETHOD REMOVE-DUPLICATES ((SELF CONS))
  "Remove duplicates from the cons list 'self' and return
'self'. Removes all but the first occurrence of items in the list.
Preserves the original order of the remaining members.  Runs in quadratic
time."
  (CL:LET*
   ((CURSOR SELF) (REST NULL))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:SETQ REST (CLSYS-SVAL CONS REST CURSOR))
    (CL:WHEN
     (CL:EQ (MEMBER? REST (CLSYS-SVAL CONS VALUE CURSOR)) 1)
     (CL:SETQ REST (REMOVE REST (CLSYS-SVAL CONS VALUE CURSOR)))
     (CL:SETF (CLSYS-SVAL CONS REST CURSOR) REST))
    (CL:SETQ CURSOR REST))
   (CL:RETURN-FROM REMOVE-DUPLICATES SELF))
  :VOID)

;;; (DEFMETHOD (CONCATENATE CONS) ...)

(CL:DEFMETHOD CONCATENATE ((SELF CONS) LIST2)
  "Return a cons list consisting of the concatenation of 'self' and
'list2'.    The operation is destructive wrt 'self', but leaves 'list2'
intact.  CAUTION:  This operation results in structure sharing
of 'list2'; to avoid this, 'list2' should not be pointed to by anything
other than the tail of 'self'."
  (CL:WHEN (CL:EQ SELF NIL) (CL:RETURN-FROM CONCATENATE LIST2))
  (CL:WHEN (CL:EQ LIST2 NIL) (CL:RETURN-FROM CONCATENATE SELF))
  (CL:LET*
   ((CURSOR SELF))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST CURSOR) NIL))
    DO
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (CL:SETF (CLSYS-SVAL CONS REST CURSOR) LIST2)
   (CL:RETURN-FROM CONCATENATE SELF))
  :VOID)

;;; (DEFMETHOD (PREPEND CONS) ...)

(CL:DEFMETHOD PREPEND ((SELF CONS) LIST1)
  "Return a cons list consisting of the concatenation of
'list1' and 'self'.  A copy of 'list1' is prepended to 'self'.  This
operation results in structure sharing of 'self'; to avoid this, 'self'
should not be pointed to by anything other than the tail of the prepended
copy."
  (CL:WHEN (CL:EQ LIST1 NIL) (CL:RETURN-FROM PREPEND SELF))
  (CL:LET*
   ((COPY1 (COPY-CONS-LIST LIST1)))
   (CONCATENATE COPY1 SELF)
   (CL:RETURN-FROM PREPEND COPY1))
  :VOID)

;;; (DEFMETHOD (REVERSE (LIKE SELF)) ...)

(CL:DEFMETHOD REVERSE ((SELF CONS))
  "Destructively reverse the members of the cons list 'self'."
  (CL:WHEN (CL:EQ SELF NIL) (CL:RETURN-FROM REVERSE SELF))
  (CL:LET*
   ((REVERSEDCONSLIST SELF)
    (REMAININGCONSLIST (CLSYS-SVAL CONS REST REVERSEDCONSLIST))
    (DETACHEDCONS NULL))
   (CL:WHEN
    (CL:EQ REMAININGCONSLIST NIL)
    (CL:RETURN-FROM REVERSE REVERSEDCONSLIST))
   (CL:SETF (CLSYS-SVAL CONS REST REVERSEDCONSLIST) NIL)
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ REMAININGCONSLIST NIL))
    DO
    (CL:SETQ DETACHEDCONS REMAININGCONSLIST)
    (CL:SETQ REMAININGCONSLIST (CLSYS-SVAL CONS REST REMAININGCONSLIST))
    (CL:SETF (CLSYS-SVAL CONS REST DETACHEDCONS) REVERSEDCONSLIST)
    (CL:SETQ REVERSEDCONSLIST DETACHEDCONS))
   (CL:RETURN-FROM REVERSE REVERSEDCONSLIST))
  :VOID)

;;; (DEFMETHOD (SUBSTITUTE CONS) ...)

(CL:DEFMETHOD SUBSTITUTE ((SELF CONS) INVALUE OUTVALUE)
  "Destructively replace each appearance of 'outValue' by
'inValue' in the cons list 'self'."
  (CL:LET*
   ((CURSOR SELF))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:WHEN
     (CL:EQ (EQL? (CLSYS-SVAL CONS VALUE CURSOR) OUTVALUE) 1)
     (CL:SETF (CLSYS-SVAL CONS VALUE CURSOR) INVALUE))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (CL:RETURN-FROM SUBSTITUTE SELF))
  :VOID)

;;; (DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIRST ((SELF CONS))
  "Return the first element of 'self'.  The first element
of 'self' can be set with 'setf'.  Note that '(first NIL)' = NULL."
  (CL:RETURN-FROM FIRST (CLSYS-SVAL CONS VALUE SELF))
  :VOID)

;;; (DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD SECOND ((SELF CONS))
  "Return the second element of 'self'.  The second element
of 'self' can be set with 'setf'.  Note that '(second NIL)' = NULL."
  (CL:RETURN-FROM SECOND (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST SELF)))
  :VOID)

;;; (DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD THIRD ((SELF CONS))
  "Return the third element of 'self'.  The third element
of 'self' can be set with 'setf'.  Note that '(third NIL)' = NULL."
  (CL:RETURN-FROM
   THIRD
   (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST SELF))))
  :VOID)

;;; (DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FOURTH ((SELF CONS))
  "Return the fourth element of 'self'.  The fourth element
of 'self' can be set with 'setf'.  Note that '(fourth NIL)' = NULL."
  (CL:RETURN-FROM
   FOURTH
   (CLSYS-SVAL
    CONS
    VALUE
    (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST SELF)))))
  :VOID)

;;; (DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIFTH ((SELF CONS))
  "Return the fifth element of 'self'.  The fifth element
of 'self' can be set with 'setf'.  Note, that '(fifth NIL)' = NULL."
  (CL:RETURN-FROM
   FIFTH
   (CLSYS-SVAL
    CONS
    VALUE
    (CLSYS-SVAL
     CONS
     REST
     (CLSYS-SVAL
      CONS
      REST
      (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST SELF))))))
  :VOID)

;;; (DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH ((SELF CONS) POSITION)
  "Return the element of 'self' at 'position'.  The nth element
of 'self' can be set with 'setf'.  Note, that '(nth NIL <pos>)' = NULL."
  (CL:LET*
   ((I -1))
   (CL:LET*
    ((VALUE NULL) (ITER-001 SELF))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ VALUE (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:= (CL:SETQ I (CL:1+ I)) POSITION)
      (CL:RETURN-FROM NTH VALUE))))
   (CL:RETURN-FROM NTH NULL))
  :VOID)

;;; (DEFMETHOD (NTH-REST (LIKE SELF)) ...)

(CL:DEFMETHOD NTH-REST ((SELF CONS) POSITION)
  "Apply 'rest' 'position' times to 'self'."
  (CL:WHEN (CL:< POSITION 0) (CL:RETURN-FROM NTH-REST NULL))
  (CL:LET*
   ((CURSOR SELF))
   (CL:LET*
    ((I NULL)
     (ITER-001 1)
     (UPPER-BOUND-001 POSITION)
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
    (CL:LOOP
     WHILE
     (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR))
     (CL:WHEN (CL:EQ CURSOR NIL) (CL:RETURN-FROM NTH-REST NIL))))
   (CL:RETURN-FROM NTH-REST CURSOR))
  :VOID)

;;; (DEFUN (LAST-CONS (CONS OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFUN LAST-CONS (SELF)
  "Return the last cons of 'self'."
  (CL:LOOP
   WHILE
   (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST SELF) NIL))
   DO
   (CL:SETQ SELF (CLSYS-SVAL CONS REST SELF)))
  (CL:RETURN-FROM LAST-CONS SELF)
  :VOID)

;;; (DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LAST ((SELF CONS))
  "Return the last element of 'self'."
  (CL:RETURN-FROM LAST (CLSYS-SVAL CONS VALUE (LAST-CONS SELF)))
  :VOID)

;;; (DEFMETHOD (FIRST-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIRST-SETTER ((SELF CONS) VALUE)
  (CL:WHEN
   (CL:EQ SELF NIL)
   (CL:WARN "Can't apply first setter to empty list.")
   (CL:RETURN-FROM FIRST-SETTER NULL))
  (CL:RETURN-FROM FIRST-SETTER (CL:SETF (CLSYS-SVAL CONS VALUE SELF) VALUE))
  :VOID)

;;; (DEFMETHOD (SECOND-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD SECOND-SETTER ((SELF CONS) VALUE)
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL CONS REST SELF) NIL)
   (CL:WARN "'second setter' applied to too short cons list.")
   (CL:RETURN-FROM SECOND-SETTER NULL))
  (CL:RETURN-FROM
   SECOND-SETTER
   (CL:SETF (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST SELF)) VALUE))
  :VOID)

;;; (DEFMETHOD (THIRD-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD THIRD-SETTER ((SELF CONS) VALUE)
  (CL:LET*
   ((THIRDCONS (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST SELF))))
   (CL:IF
    (CL:NOT (CL:EQ THIRDCONS NIL))
    (CL:RETURN-FROM
     THIRD-SETTER
     (CL:SETF (CLSYS-SVAL CONS VALUE THIRDCONS) VALUE))
    (CL:PROGN
     (CL:WARN "'third setter' applied to too short cons list.")
     (CL:RETURN-FROM THIRD-SETTER NULL))))
  :VOID)

;;; (DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH-SETTER ((SELF CONS) VALUE POSITION)
  (CL:WHEN
   (CL:< POSITION 0)
   (CL:WARN "Can't apply nth setter to negative position `~A'." POSITION)
   (CL:RETURN-FROM NTH-SETTER NULL))
  (CL:LET*
   ((CURSOR SELF))
   (CL:LET*
    ((I NULL)
     (ITER-001 1)
     (UPPER-BOUND-001 POSITION)
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
    (CL:LOOP
     WHILE
     (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETQ I I)
     (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR))
     (CL:WHEN
      (CL:EQ CURSOR NIL)
      (CL:WARN "'nth setter' ran off end of cons list.")
      (CL:RETURN-FROM NTH-SETTER NULL))))
   (CL:SETF (CLSYS-SVAL CONS VALUE CURSOR) VALUE)
   (CL:RETURN-FROM NTH-SETTER VALUE))
  :VOID)

;;; (DEFMETHOD (FOURTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FOURTH-SETTER ((SELF CONS) VALUE)
  (CL:RETURN-FROM FOURTH-SETTER (NTH-SETTER SELF VALUE 3))
  :VOID)

;;; (DEFMETHOD (FIFTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIFTH-SETTER ((SELF CONS) VALUE)
  (CL:RETURN-FROM FIFTH-SETTER (NTH-SETTER SELF VALUE 4))
  :VOID)

;;; (DEFMETHOD (NTH-REST-SETTER OBJECT) ...)

(CL:DEFMETHOD NTH-REST-SETTER ((SELF CONS) VALUE POSITION)
  (CL:WHEN
   (CL:<= POSITION 0)
   (CL:WARN "Can't apply nth-rest setter to negative position `~A'." POSITION))
  (CL:LET*
   ((CURSOR SELF))
   (CL:LET*
    ((I NULL)
     (ITER-001 2)
     (UPPER-BOUND-001 POSITION)
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
    (CL:LOOP
     WHILE
     (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR))
     (CL:WHEN
      (CL:EQ CURSOR NIL)
      (CL:WARN "'nth-rest setter' ran off end of cons list.")
      (CL:RETURN-FROM NTH-REST-SETTER NULL))))
   (CL:SETF (CLSYS-SVAL CONS REST CURSOR) VALUE)
   (CL:RETURN-FROM NTH-REST-SETTER VALUE))
  :VOID)

;;; (DEFMETHOD (ALLOCATE-ITERATOR CONS-ITERATOR) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF CONS))
  (CL:LET*
   ((ITERATOR (NEW-CONS-ITERATOR)))
   (CL:SETF (CLSYS-SVAL CONS-ITERATOR CONS-ITERATOR-CURSOR ITERATOR) SELF)
   (CL:SETF (CLSYS-SVAL CONS-ITERATOR FIRST-ITERATION? ITERATOR) TRUE)
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR))
  :VOID)

;;; (DEFUN (TERMINATE-CONS-ITERATOR? BOOLEAN) ...)

(CL:DEFUN TERMINATE-CONS-ITERATOR? (SELF)
  (CL:SETF (CLSYS-SVAL CONS-ITERATOR CONS-ITERATOR-CURSOR SELF) NULL)
  (CL:RETURN-FROM TERMINATE-CONS-ITERATOR? TRUE)
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF CONS-ITERATOR))
  (CL:IF
   (CL:EQ (CLSYS-SVAL CONS-ITERATOR FIRST-ITERATION? SELF) 1)
   (CL:SETF (CLSYS-SVAL CONS-ITERATOR FIRST-ITERATION? SELF) FALSE)
   (CL:SETF
    (CLSYS-SVAL CONS-ITERATOR CONS-ITERATOR-CURSOR SELF)
    (CLSYS-SVAL
     CONS
     REST
     (CLSYS-SVAL CONS-ITERATOR CONS-ITERATOR-CURSOR SELF))))
  (CL:SETF
   (CLSYS-SVAL CONS-ITERATOR VALUE SELF)
   (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS-ITERATOR CONS-ITERATOR-CURSOR SELF)))
  (CL:RETURN-FROM
   NEXT?
   (NON-EMPTY? (CLSYS-SVAL CONS-ITERATOR CONS-ITERATOR-CURSOR SELF)))
  :VOID)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF CONS-ITERATOR))
  (CL:RETURN-FROM
   EMPTY?
   (NIL? (CLSYS-SVAL CONS-ITERATOR CONS-ITERATOR-CURSOR SELF)))
  :VOID)

;;; (DEFMETHOD (VALUE-SETTER OBJECT) ...)

(CL:DEFMETHOD VALUE-SETTER ((SELF CONS-ITERATOR) VALUE)
  (CL:RETURN-FROM
   VALUE-SETTER
   (CL:SETF
    (CLSYS-SVAL
     CONS
     VALUE
     (CLSYS-SVAL CONS-ITERATOR CONS-ITERATOR-CURSOR SELF))
    VALUE))
  :VOID)

;;; (DEFUN ADD-CONS-TO-END-OF-CONS-LIST ...)

(CL:DEFUN ADD-CONS-TO-END-OF-CONS-LIST (SELF LASTCONS)
  (CL:LOOP
   WHILE
   (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST SELF) NIL))
   DO
   (CL:SETQ SELF (CLSYS-SVAL CONS REST SELF)))
  (CL:SETF (CLSYS-SVAL CONS REST SELF) LASTCONS)
  :VOID)

;;; (DEFUN (BUT-LAST-NEXT? BOOLEAN) ...)

(CL:DEFUN BUT-LAST-NEXT? (SELF)
  (CL:IF
   (CL:EQ (CLSYS-SVAL ALL-PURPOSE-ITERATOR FIRST-ITERATION? SELF) 1)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR FIRST-ITERATION? SELF) FALSE)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
    (CLSYS-SVAL
     CONS
     REST
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))))
  (CL:WHEN
   (CL:EQ
    (CLSYS-SVAL
     CONS
     REST
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))
    NIL)
   (CL:RETURN-FROM BUT-LAST-NEXT? FALSE))
  (CL:SETF
   (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF)
   (CLSYS-SVAL
    CONS
    VALUE
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
  (CL:RETURN-FROM BUT-LAST-NEXT? TRUE)
  :VOID)

;;; (DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD BUT-LAST ((SELF CONS))
  "Generate all but the last element of the cons list 'self'."
  (CL:LET*
   ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST ITERATOR)
    SELF)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR FIRST-ITERATION? ITERATOR) TRUE)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION BUT-LAST-NEXT?))
   (CL:RETURN-FROM BUT-LAST ITERATOR))
  :VOID)

;;; (DEFMETHOD FREE-CONS ...)

(CL:DEFMETHOD FREE-CONS ((SELF TRANSIENT-CONS))
  (FREE SELF)
  :VOID)

;;; (DEFUN (TRANSIENT-CONS CONS) ...)

(CL:DEFUN TRANSIENT-CONS (VALUE REST)
  "Return a transient cons record that points to 'value' and
'rest'."
  (CL:LET*
   ((CONS (NEW-TRANSIENT-CONS)))
   (CL:SETF (CLSYS-SVAL TRANSIENT-CONS VALUE CONS) VALUE)
   (CL:SETF (CLSYS-SVAL TRANSIENT-CONS REST CONS) REST)
   (CL:RETURN-FROM TRANSIENT-CONS CONS))
  :VOID)

;;; (DEFUN (YIELD-CONS-LIST-OF CONS) ...)

(CL:DEFUN YIELD-CONS-LIST-OF (SELF)
  "If 'object' is a CONS, return it.  Otherwise, return
a singleton cons list containing it."
  (CL:RETURN-FROM
   YIELD-CONS-LIST-OF
   (CL:IF (CL:EQ (CONS? SELF) 1) SELF (CONS SELF NIL)))
  :VOID)

;;; (DEFUN (COPY-CONS-LIST (LIKE SELF)) ...)

(CL:DEFUN COPY-CONS-LIST (SELF)
  "Return a copy of the cons list 'self'."
  (CL:WHEN (CL:EQ SELF NIL) (CL:RETURN-FROM COPY-CONS-LIST NIL))
  (CL:LET*
   ((NEWCONSLIST (CONS (CLSYS-SVAL CONS VALUE SELF) NIL))
    (NEXTCONS NEWCONSLIST)
    (COPYFROMCONS NULL)
    (PREVIOUSCONS NULL))
   (CL:SETQ COPYFROMCONS (CLSYS-SVAL CONS REST SELF))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ COPYFROMCONS NIL))
    DO
    (CL:SETQ PREVIOUSCONS NEXTCONS)
    (CL:SETQ NEXTCONS (CONS (CLSYS-SVAL CONS VALUE COPYFROMCONS) NIL))
    (CL:SETF (CLSYS-SVAL CONS REST PREVIOUSCONS) NEXTCONS)
    (CL:SETQ COPYFROMCONS (CLSYS-SVAL CONS REST COPYFROMCONS)))
   (CL:RETURN-FROM COPY-CONS-LIST NEWCONSLIST))
  :VOID)

;;; (DEFUN (PERMANENT-COPY-CONS-LIST (LIKE SELF)) ...)

(CL:DEFUN PERMANENT-COPY-CONS-LIST (SELF)
  "Return a permanent copy of the cons list 'self'."
  (CL:WHEN (CL:EQ SELF NIL) (CL:RETURN-FROM PERMANENT-COPY-CONS-LIST NIL))
  (CL:LET*
   ((NEWCONSLIST (PERMANENT-CONS (CLSYS-SVAL CONS VALUE SELF) NIL))
    (NEXTCONS NEWCONSLIST)
    (COPYFROMCONS NULL)
    (PREVIOUSCONS NULL))
   (CL:SETQ COPYFROMCONS (CLSYS-SVAL CONS REST SELF))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ COPYFROMCONS NIL))
    DO
    (CL:SETQ PREVIOUSCONS NEXTCONS)
    (CL:SETQ
     NEXTCONS
     (PERMANENT-CONS (CLSYS-SVAL CONS VALUE COPYFROMCONS) NIL))
    (CL:SETF (CLSYS-SVAL CONS REST PREVIOUSCONS) NEXTCONS)
    (CL:SETQ COPYFROMCONS (CLSYS-SVAL CONS REST COPYFROMCONS)))
   (CL:RETURN-FROM PERMANENT-COPY-CONS-LIST NEWCONSLIST))
  :VOID)

;;; (DEFUN (CONS-LIST CONS) ...)

(CL:DEFUN CONS-LIST (CL:&REST VALUES)
  "Return a cons list containing 'values', in order."
  (CL:LET*
   ((LIST NIL))
   (CL:LET*
    ((V NULL) (ITER-001 (ALLOCATE-ITERATOR VALUES)) (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ V (CLSYS-SVAL LISP-CONS-ITERATOR VALUE ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (CONS V NIL))
       (CL:IF
        (CL:EQ LIST NIL)
        (CL:SETQ LIST COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST LIST COLLECT-001)))
      (CL:PROGN
       (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS V NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:RETURN-FROM CONS-LIST LIST))
  :VOID)

;;; (DEFUN (LIST* CONS) ...)

(CL:DEFUN LIST* (CL:&REST VALUES)
  "Return a list of conses that make up the list 'values',
terminated by the last value rather than by NIL.  Assumes that
at least one value is passed in."
  (CL:LET*
   ((HEADCONS NIL) (ANSWER NULL) (LASTCONS NULL))
   (CL:LET*
    ((V NULL) (ITER-001 (ALLOCATE-ITERATOR VALUES)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ V (CLSYS-SVAL LISP-CONS-ITERATOR VALUE ITER-001)))
     (CL:SETQ HEADCONS (CONS V HEADCONS))))
   (CL:SETQ ANSWER (REVERSE (CLSYS-SVAL CONS REST HEADCONS)))
   (CL:WHEN
    (CL:EQ ANSWER NIL)
    (CL:SETQ ANSWER (CLSYS-SVAL CONS VALUE HEADCONS))
    (FREE-CONS HEADCONS)
    (CL:RETURN-FROM LIST* ANSWER))
   (CL:SETQ LASTCONS ANSWER)
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST LASTCONS) NIL))
    DO
    (CL:SETQ LASTCONS (CLSYS-SVAL CONS REST LASTCONS)))
   (CL:SETF (CLSYS-SVAL CONS REST LASTCONS) (CLSYS-SVAL CONS VALUE HEADCONS))
   (FREE-CONS HEADCONS)
   (CL:RETURN-FROM LIST* ANSWER))
  :VOID)

;;; (DEFUN (APPEND CONS) ...)

(CL:DEFUN APPEND (CONSLIST1 CONSLIST2)
  "Return a transient cons list representing the concatenation
of 'consList1' and 'consList2'.  The concatenation is NOT destructive."
  (CL:COND
   ((CL:EQ CONSLIST1 NIL) (CL:RETURN-FROM APPEND CONSLIST2))
   ((CL:EQ CONSLIST2 NIL) (CL:RETURN-FROM APPEND CONSLIST1))
   (CL:T
    (CL:RETURN-FROM
     APPEND
     (CONS
      (CLSYS-SVAL CONS VALUE CONSLIST1)
      (APPEND (CLSYS-SVAL CONS REST CONSLIST1) CONSLIST2)))))
  :VOID)

;;; (DEFMETHOD (SORT (CONS OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD SORT ((SELF CONS) PREDICATE)
  "Perform a stable, destructive sort of 'self' according to
'predicate', and return the result.  If 'predicate' has a '<' semantics, the
result will be in ascending order.  It is not guaranteed that 'self' will
point to the beginning of the sorted result.  If 'predicate' is NULL, a
suitable '<' predicate is chosen depending on the first element of 'self',
and it is assumed that all elements of 'self' have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT)."
  (CL:WHEN
   (CL:EQ PREDICATE NULL)
   (CL:SETQ PREDICATE (CHOOSE-SORT-PREDICATE SELF)))
  (CL:RETURN-FROM SORT (HELP-SORT-CONS-LIST SELF (LENGTH SELF) PREDICATE))
  :VOID)

;;; (DEFUN (HELP-SORT-CONS-LIST CONS) ...)

(CL:DEFUN HELP-SORT-CONS-LIST (LIST LENGTH PREDICATE)
  (CL:WHEN (CL:< LENGTH 2) (CL:RETURN-FROM HELP-SORT-CONS-LIST LIST))
  (CL:LET*
   ((FRONTLENGTH (FLOOR (CL:/ LENGTH 2.0))) (TEMP LIST) (BACK NIL))
   (CL:LET*
    ((I NULL)
     (ITER-001 2)
     (UPPER-BOUND-001 FRONTLENGTH)
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
    (CL:LOOP
     WHILE
     (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETQ TEMP (CLSYS-SVAL CONS REST TEMP))))
   (CL:SETQ BACK (CLSYS-SVAL CONS REST TEMP))
   (CL:SETF (CLSYS-SVAL CONS REST TEMP) NIL)
   (CL:RETURN-FROM
    HELP-SORT-CONS-LIST
    (MERGE-CONS-LISTS
     (HELP-SORT-CONS-LIST LIST FRONTLENGTH PREDICATE)
     (HELP-SORT-CONS-LIST BACK (CL:- LENGTH FRONTLENGTH) PREDICATE)
     PREDICATE)))
  :VOID)

;;; (DEFUN (MERGE-CONS-LISTS CONS) ...)

(CL:DEFUN MERGE-CONS-LISTS (LIST1 LIST2 PREDICATE)
  (CL:LET*
   ((CURSOR1 LIST1) (CURSOR2 LIST2) (RESULT NIL) (TAIL NIL) (TEMP NIL))
   (CL:LOOP
    (CL:WHEN
     (CL:EQ CURSOR1 NIL)
     (CL:WHEN (CL:EQ TAIL NIL) (CL:RETURN-FROM MERGE-CONS-LISTS CURSOR2))
     (CL:SETF (CLSYS-SVAL CONS REST TAIL) CURSOR2)
     (CL:RETURN-FROM MERGE-CONS-LISTS RESULT))
    (CL:WHEN
     (CL:EQ CURSOR2 NIL)
     (CL:WHEN (CL:EQ TAIL NIL) (CL:RETURN-FROM MERGE-CONS-LISTS CURSOR1))
     (CL:SETF (CLSYS-SVAL CONS REST TAIL) CURSOR1)
     (CL:RETURN-FROM MERGE-CONS-LISTS RESULT))
    (CL:COND
     ((CL:EQ
       (CL:FUNCALL
        PREDICATE
        (CLSYS-SVAL CONS VALUE CURSOR2)
        (CLSYS-SVAL CONS VALUE CURSOR1))
       1)
      (CL:SETQ TEMP CURSOR2)
      (CL:SETQ CURSOR2 (CLSYS-SVAL CONS REST CURSOR2))
      (CL:SETQ LIST2 CURSOR2))
     (CL:T
      (CL:SETQ TEMP CURSOR1)
      (CL:SETQ CURSOR1 (CLSYS-SVAL CONS REST CURSOR1))
      (CL:SETQ LIST1 CURSOR1)))
    (CL:IF
     (CL:EQ TAIL NIL)
     (CL:SETQ RESULT TEMP)
     (CL:SETF (CLSYS-SVAL CONS REST TAIL) TEMP))
    (CL:SETQ TAIL TEMP)))
  :VOID)

;;; (DEFUN (GENERALIZED-SYMBOL-LESS-THAN? BOOLEAN) ...)

(CL:DEFUN GENERALIZED-SYMBOL-LESS-THAN? (X Y)
  (CL:RETURN-FROM
   GENERALIZED-SYMBOL-LESS-THAN?
   (STRING<
    (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-NAME X)
    (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-NAME Y)))
  :VOID)

;;; (DEFUN (WRAPPED-INTEGER-LESS-THAN? BOOLEAN) ...)

(CL:DEFUN WRAPPED-INTEGER-LESS-THAN? (X Y)
  (CL:RETURN-FROM
   WRAPPED-INTEGER-LESS-THAN?
   (<
    (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE X)
    (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE Y)))
  :VOID)

;;; (DEFUN (WRAPPED-FLOAT-LESS-THAN? BOOLEAN) ...)

(CL:DEFUN WRAPPED-FLOAT-LESS-THAN? (X Y)
  (CL:RETURN-FROM
   WRAPPED-FLOAT-LESS-THAN?
   (<
    (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE X)
    (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE Y)))
  :VOID)

;;; (DEFUN (WRAPPED-STRING-LESS-THAN? BOOLEAN) ...)

(CL:DEFUN WRAPPED-STRING-LESS-THAN? (X Y)
  (CL:RETURN-FROM
   WRAPPED-STRING-LESS-THAN?
   (STRING<
    (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE X)
    (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE Y)))
  :VOID)

;;; (DEFUN (CHOOSE-SORT-PREDICATE FUNCTION-CODE) ...)

(CL:DEFUN CHOOSE-SORT-PREDICATE (SELF)
  (CL:LET*
   ((FIRSTELEMENT (CLSYS-SVAL CONS VALUE SELF)))
   (CL:WHEN
    (CL:EQ FIRSTELEMENT NULL)
    (CL:RETURN-FROM CHOOSE-SORT-PREDICATE NULL))
   (CL:LET*
    ((FIRSTELEMENT-001 FIRSTELEMENT))
    (CL:COND
     ((CL:EQ (TAXONOMY-ISA? FIRSTELEMENT SGT-CONSES-GENERALIZED-SYMBOL) 1)
      (CL:LET*
       ((FIRSTELEMENT NULL))
       (CL:SETQ FIRSTELEMENT FIRSTELEMENT-001)
       (CL:RETURN-FROM
        CHOOSE-SORT-PREDICATE
        (CL:FUNCTION GENERALIZED-SYMBOL-LESS-THAN?))))
     ((CL:EQ (INTEGER? FIRSTELEMENT) 1)
      (CL:LET*
       ((FIRSTELEMENT NULL))
       (CL:SETQ FIRSTELEMENT FIRSTELEMENT-001)
       (CL:RETURN-FROM
        CHOOSE-SORT-PREDICATE
        (CL:FUNCTION WRAPPED-INTEGER-LESS-THAN?))))
     ((CL:EQ (FLOAT? FIRSTELEMENT) 1)
      (CL:LET*
       ((FIRSTELEMENT NULL))
       (CL:SETQ FIRSTELEMENT FIRSTELEMENT-001)
       (CL:RETURN-FROM
        CHOOSE-SORT-PREDICATE
        (CL:FUNCTION WRAPPED-FLOAT-LESS-THAN?))))
     ((CL:EQ (STRING? FIRSTELEMENT) 1)
      (CL:LET*
       ((FIRSTELEMENT NULL))
       (CL:SETQ FIRSTELEMENT FIRSTELEMENT-001)
       (CL:RETURN-FROM
        CHOOSE-SORT-PREDICATE
        (CL:FUNCTION WRAPPED-STRING-LESS-THAN?))))
     (CL:T
      (CL:ERROR
       "choose-sort-predicate: Don't know how to sort `~A's"
       (PRIMARY-TYPE FIRSTELEMENT))))))
  :VOID)

;;; (DEFUN (SEARCH-CONS-TREE? BOOLEAN) ...)

(CL:DEFUN SEARCH-CONS-TREE? (TREE VALUE)
  "Return TRUE iff the value 'value' is embedded within
the cons tree 'tree'.  Uses an 'eql?' test."
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:IF
       (CL:EQ TREE NIL)
       (CL:RETURN-FROM SEARCH-CONS-TREE? (NIL? VALUE))
       (CL:RETURN-FROM
        SEARCH-CONS-TREE?
        (CL:IF
         (CL:OR
          (CL:EQ (SEARCH-CONS-TREE? (CLSYS-SVAL CONS VALUE TREE) VALUE) 1)
          (CL:EQ (SEARCH-CONS-TREE? (CLSYS-SVAL CONS REST TREE) VALUE) 1))
         TRUE
         FALSE)))))
    (CL:T (CL:RETURN-FROM SEARCH-CONS-TREE? (EQL? TREE VALUE)))))
  :VOID)

;;; (DEFUN (COPY-CONS-TREE (LIKE SELF)) ...)

(CL:DEFUN COPY-CONS-TREE (SELF)
  "Return a copy of the cons tree 'self'."
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (CONS? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:IF
       (CL:EQ SELF NIL)
       (CL:RETURN-FROM COPY-CONS-TREE NIL)
       (CL:RETURN-FROM
        COPY-CONS-TREE
        (CONS
         (COPY-CONS-TREE (CLSYS-SVAL CONS VALUE SELF))
         (COPY-CONS-TREE (CLSYS-SVAL CONS REST SELF)))))))
    (CL:T (CL:RETURN-FROM COPY-CONS-TREE SELF))))
  :VOID)

;;; (DEFUN FREE-CONS-TREE ...)

(CL:DEFUN FREE-CONS-TREE (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (CONS? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:NOT (CL:EQ SELF NIL))
       (FREE-CONS-TREE (CLSYS-SVAL CONS VALUE SELF))
       (FREE-CONS-TREE (CLSYS-SVAL CONS REST SELF))
       (FREE-CONS SELF))))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN (EQUAL-CONS-TREES? BOOLEAN) ...)

(CL:DEFUN EQUAL-CONS-TREES? (TREE1 TREE2)
  "Return TRUE iff the cons trees 'tree1' and 'tree2' are
structurally equivalent.  Uses an 'eql?' test."
  (CL:IF
   (CL:EQ (EQL? TREE1 TREE2) 1)
   (CL:RETURN-FROM EQUAL-CONS-TREES? TRUE)
   (CL:LET*
    ((TREE1-001 TREE1))
    (CL:COND
     ((CL:EQ (CONS? TREE1) 1)
      (CL:LET*
       ((TREE1 NULL))
       (CL:SETQ TREE1 TREE1-001)
       (CL:LET*
        ((TREE2-001 TREE2))
        (CL:COND
         ((CL:EQ (CONS? TREE2) 1)
          (CL:LET*
           ((TREE2 NULL))
           (CL:SETQ TREE2 TREE2-001)
           (CL:RETURN-FROM
            EQUAL-CONS-TREES?
            (CL:IF
             (CL:AND
              (CL:EQ
               (EQUAL-CONS-TREES?
                (CLSYS-SVAL CONS VALUE TREE1)
                (CLSYS-SVAL CONS VALUE TREE2))
               1)
              (CL:EQ
               (EQUAL-CONS-TREES?
                (CLSYS-SVAL CONS REST TREE1)
                (CLSYS-SVAL CONS REST TREE2))
               1))
             TRUE
             FALSE))))
         (CL:T (CL:RETURN-FROM EQUAL-CONS-TREES? FALSE))))))
     (CL:T (CL:RETURN-FROM EQUAL-CONS-TREES? FALSE)))))
  :VOID)

;;; (DEFUN (SUBSTITUTE-CONS-TREE OBJECT) ...)

(CL:DEFUN SUBSTITUTE-CONS-TREE (TREE NEWVALUE OLDVALUE)
  "Destructively replace each appearance of 'oldValue' by
'newValue' in the cons tree 'tree'.  Return the tree.  Uses an 'eql?' test."
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:WHEN
       (CL:NOT (CL:EQ TREE NIL))
       (CL:IF
        (CL:EQ (EQL? (CLSYS-SVAL CONS VALUE TREE) OLDVALUE) 1)
        (CL:SETF (CLSYS-SVAL CONS VALUE TREE) NEWVALUE)
        (SUBSTITUTE-CONS-TREE (CLSYS-SVAL CONS VALUE TREE) NEWVALUE OLDVALUE))
       (SUBSTITUTE-CONS-TREE (CLSYS-SVAL CONS REST TREE) NEWVALUE OLDVALUE))))
    (CL:T NULL)))
  (CL:RETURN-FROM SUBSTITUTE-CONS-TREE TREE)
  :VOID)

;;; (DEFMETHOD FREE-PARSE-TREE ...)

(CL:DEFMETHOD FREE-PARSE-TREE ((SELF CONS))
  (CL:WHEN
   (CL:NOT (CL:EQ SELF NIL))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING
     "Permanent cons found while freeing parse tree:"
     %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (CL:IF
    (CL:< (TREE-SIZE SELF) 10)
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:WRITE-STRING "`" %%STREAM)
     (PRINT-OBJECT SELF %%STREAM)
     (CL:WRITE-STRING "'" %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "Tree size = `" %%STREAM)
     (CL:PRINC (TREE-SIZE SELF) %%STREAM)
     (CL:WRITE-STRING "'" %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))))
  :VOID)

;;; (DEFMETHOD FREE-PARSE-TREE ...)

(CL:DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-CONS))
  (CL:WHEN
   (CL:NOT (CL:EQ (CLSYS-SVAL TRANSIENT-CONS VALUE SELF) NULL))
   (FREE-PARSE-TREE (CLSYS-SVAL TRANSIENT-CONS VALUE SELF)))
  (FREE-PARSE-TREE (CLSYS-SVAL TRANSIENT-CONS REST SELF))
  (FREE-CONS SELF)
  :VOID)

;;; (DEFMETHOD FREE-PARSE-TREE ...)

(CL:DEFMETHOD FREE-PARSE-TREE ((SELF OBJECT))
  NULL
  :VOID)

;;; (DEFMETHOD FREE-PARSE-TREE ...)

(CL:DEFMETHOD FREE-PARSE-TREE ((SELF WRAPPER))
  NULL
  :VOID)

;;; (DEFMETHOD FREE-PARSE-TREE ...)

(CL:DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-INTEGER-WRAPPER))
  (FREE SELF)
  :VOID)

;;; (DEFMETHOD FREE-PARSE-TREE ...)

(CL:DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-FLOAT-WRAPPER))
  (FREE SELF)
  :VOID)

;;; (DEFMETHOD FREE-PARSE-TREE ...)

(CL:DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-STRING-WRAPPER))
  (FREE SELF)
  :VOID)

;;; (DEFMETHOD FREE-PARSE-TREE ...)

(CL:DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-CHARACTER-WRAPPER))
  (FREE SELF)
  :VOID)

;;; (DEFMETHOD FREE-PARSE-TREE ...)

(CL:DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-FUNCTION-CODE-WRAPPER))
  (FREE SELF)
  :VOID)

;;; (DEFMETHOD FREE-PARSE-TREE ...)

(CL:DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-METHOD-CODE-WRAPPER))
  (FREE SELF)
  :VOID)

;;; (DEFMETHOD FREE-PARSE-TREE ...)

(CL:DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-SYMBOL))
  (FREE SELF)
  :VOID)

;;; (DEFMETHOD FREE-PARSE-TREE ...)

(CL:DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-KEYWORD))
  (FREE SELF)
  :VOID)

;;; (DEFSPECIAL *PRINTPRETTY?* ...)

(CL:DEFVAR *PRINTPRETTY?* TRUE
  "If TRUE conses will be pretty printed.")

(CL:DEFUN READ-*PRINTPRETTY?* ()
  (CL:RETURN-FROM READ-*PRINTPRETTY?* *PRINTPRETTY?*)
  :VOID)

(CL:DEFUN WRITE-*PRINTPRETTY?* (VALUE)
  (CL:SETQ *PRINTPRETTY?* VALUE)
  (CL:RETURN-FROM WRITE-*PRINTPRETTY?* VALUE)
  :VOID)

;;; (DEFSPECIAL *PRINTREADABLY?* ...)

(CL:DEFVAR *PRINTREADABLY?* FALSE
  "If TRUE conses will be printed as readable Stella code.")

(CL:DEFUN READ-*PRINTREADABLY?* ()
  (CL:RETURN-FROM READ-*PRINTREADABLY?* *PRINTREADABLY?*)
  :VOID)

(CL:DEFUN WRITE-*PRINTREADABLY?* (VALUE)
  (CL:SETQ *PRINTREADABLY?* VALUE)
  (CL:RETURN-FROM WRITE-*PRINTREADABLY?* VALUE)
  :VOID)

;;; (DEFGLOBAL ELIPSIS ...)

(CL:DEFVAR ELIPSIS NULL
  "Generates an elipsis '...' when found in a
pretty-printed parse tree.")

;;; (DEFUN PRINT-CONS ...)

(CL:DEFUN PRINT-CONS (TREE STREAM LPAREN RPAREN)
  (CL:WHEN (CL:EQ *PRINTREADABLY?* 1) (CL:SETQ LPAREN "(") (CL:SETQ RPAREN ")"))
  (CL:WHEN
   (CL:EQ *PRINTPRETTY?* 1)
   (PPRINT-CONS TREE STREAM LPAREN RPAREN)
   (CL:RETURN-FROM PRINT-CONS))
  (CL:WRITE-STRING LPAREN STREAM)
  (CL:WHEN
   (CL:NOT (CL:EQ TREE NIL))
   (PRINT-OBJECT (CLSYS-SVAL CONS VALUE TREE) STREAM)
   (CL:LET*
    ((ELEMENT NULL) (ITER-001 (CLSYS-SVAL CONS REST TREE)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ELEMENT (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:PROGN (CL:WRITE-STRING " " STREAM) (PRINT-OBJECT ELEMENT STREAM)))))
  (CL:WRITE-STRING RPAREN STREAM)
  :VOID)

;;; (DEFUN PPRINT-CONS ...)

(CL:DEFUN PPRINT-CONS (TREE STREAM LPAREN RPAREN)
  (CL:PROGN
   (CL:WRITE-STRING LPAREN STREAM)
   (CL:PPRINT-LINEAR STREAM (CONS-LIST-TO-LISP-LIST TREE) CL-NIL)
   (CL:WRITE-STRING RPAREN STREAM))
  :VOID)

;;; (DEFSPECIAL *PRINTPRETTYCODE?* ...)

(CL:DEFVAR *PRINTPRETTYCODE?* TRUE
  "When TRUE pretty-print Stella and translated code.
Since (Lisp) pretty-printing is somewhat slow, turning this off speeds up
file translation, but it also makes translated output very unreadable.")

(CL:DEFUN READ-*PRINTPRETTYCODE?* ()
  (CL:RETURN-FROM READ-*PRINTPRETTYCODE?* *PRINTPRETTYCODE?*)
  :VOID)

(CL:DEFUN WRITE-*PRINTPRETTYCODE?* (VALUE)
  (CL:SETQ *PRINTPRETTYCODE?* VALUE)
  (CL:RETURN-FROM WRITE-*PRINTPRETTYCODE?* VALUE)
  :VOID)

;;; (DEFUN PRINT-STELLA-CODE ...)

(CL:DEFUN PRINT-STELLA-CODE (TREE STREAM)
  (CL:LET*
   ((*PRINTPRETTY?* *PRINTPRETTYCODE?*) (*PRINTREADABLY?* TRUE))
   (CL:DECLARE (CL:SPECIAL *PRINTPRETTY?* *PRINTREADABLY?*))
   (CL:PROGN
    (PRINT-OBJECT TREE STREAM)
    (CL:TERPRI STREAM)
    (CL:FORCE-OUTPUT STREAM)))
  :VOID)

;;; (DEFUN PRINT-STELLA-DEFINITION ...)

(CL:DEFUN PRINT-STELLA-DEFINITION (TREE STREAM)
  (CL:LET*
   ((*PRINTPRETTY?* *PRINTPRETTYCODE?*) (*PRINTREADABLY?* TRUE))
   (CL:DECLARE (CL:SPECIAL *PRINTPRETTY?* *PRINTREADABLY?*))
   (CL:LET*
    ((TREE-001 TREE))
    (CL:COND
     ((CL:EQ (CONS? TREE) 1)
      (CL:LET*
       ((TREE NULL))
       (CL:SETQ TREE TREE-001)
       (CL:COND
        ((CL:>= (LENGTH TREE) 3)
         (CL:SETQ *PRINTPRETTY?* FALSE)
         (CL:PROGN
          (CL:WRITE-STRING "(" STREAM)
          (PRINT-OBJECT (FIRST TREE) STREAM)
          (CL:WRITE-STRING " " STREAM)
          (PRINT-OBJECT (SECOND TREE) STREAM)
          (CL:WRITE-STRING " " STREAM)
          (PRINT-OBJECT (THIRD TREE) STREAM))
         (CL:SETQ *PRINTPRETTY?* *PRINTPRETTYCODE?*)
         (CL:LET*
          ((FORM NULL) (ITER-001 (NTH-REST TREE 3)))
          (CL:LOOP
           WHILE
           (CL:NOT (CL:EQ ITER-001 NIL))
           DO
           (CL:PROGN
            (CL:SETQ FORM (CLSYS-SVAL CONS VALUE ITER-001))
            (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
           (CL:PROGN
            (CL:TERPRI STREAM)
            (CL:FORCE-OUTPUT STREAM)
            (CL:WRITE-STRING "  " STREAM)
            (PRINT-OBJECT FORM STREAM))))
         (CL:WRITE-STRING ")" STREAM))
        (CL:T (PRINT-OBJECT TREE STREAM)))))
     (CL:T (PRINT-OBJECT TREE STREAM))))
   (CL:PROGN (CL:TERPRI STREAM) (CL:FORCE-OUTPUT STREAM)))
  :VOID)

;;; (DEFUN (TREE-SIZE INTEGER) ...)

(CL:DEFUN TREE-SIZE (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (CONS? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:IF
       (CL:EQ SELF NIL)
       (CL:RETURN-FROM TREE-SIZE 0)
       (CL:RETURN-FROM
        TREE-SIZE
        (CL:1+
         (CL:+
          (TREE-SIZE (CLSYS-SVAL CONS VALUE SELF))
          (TREE-SIZE (CLSYS-SVAL CONS REST SELF))))))))
    (CL:T (CL:RETURN-FROM TREE-SIZE 0))))
  :VOID)

;;; (DEFSPECIAL *DEPTHEXCEEDED?* ...)

(CL:DEFVAR *DEPTHEXCEEDED?* FALSE)

(CL:DEFUN READ-*DEPTHEXCEEDED?* ()
  (CL:RETURN-FROM READ-*DEPTHEXCEEDED?* *DEPTHEXCEEDED?*)
  :VOID)

(CL:DEFUN WRITE-*DEPTHEXCEEDED?* (VALUE)
  (CL:SETQ *DEPTHEXCEEDED?* VALUE)
  (CL:RETURN-FROM WRITE-*DEPTHEXCEEDED?* VALUE)
  :VOID)

;;; (DEFGLOBAL *DEPTHCUTOFF* ...)

(CL:DEFVAR *DEPTHCUTOFF* 33)

;;; (DEFUN (SAFELY-COMPUTE-TREE-SIZE INTEGER) ...)

(CL:DEFUN SAFELY-COMPUTE-TREE-SIZE (TREE DEPTHCOUNT CUTOFF)
  (CL:LET*
   ((COUNT 1) (VALUE NULL))
   (CL:WHEN
    (CL:> DEPTHCOUNT *DEPTHCUTOFF*)
    (CL:SETQ *DEPTHEXCEEDED?* TRUE)
    (CL:RETURN-FROM SAFELY-COMPUTE-TREE-SIZE 1))
   (CL:LOOP
    (CL:SETQ VALUE (CLSYS-SVAL CONS VALUE TREE))
    (CL:WHEN
     (CL:EQ (CONS? VALUE) 1)
     (CL:SETQ
      COUNT
      (CL:+
       COUNT
       (SAFELY-COMPUTE-TREE-SIZE
        (CLSYS-SVAL CONS VALUE TREE)
        (CL:1+ DEPTHCOUNT)
        CUTOFF))))
    (CL:WHEN
     (CL:OR
      (CL:EQ (CLSYS-SVAL CONS REST TREE) NULL)
      (CL:EQ (CLSYS-SVAL CONS REST TREE) NIL)
      (CL:> COUNT CUTOFF))
     (CL:RETURN-FROM SAFELY-COMPUTE-TREE-SIZE COUNT))
    (CL:SETQ TREE (CLSYS-SVAL CONS REST TREE))))
  :VOID)

;;; (DEFUN (SAFE-TREE-SIZE INTEGER STRING) ...)

(CL:DEFUN SAFE-TREE-SIZE (TREE)
  (CL:LET*
   ((*DEPTHEXCEEDED?* FALSE))
   (CL:DECLARE (CL:SPECIAL *DEPTHEXCEEDED?*))
   (CL:LET*
    ((CUTOFF 99) (SIZE (SAFELY-COMPUTE-TREE-SIZE TREE 0 CUTOFF)))
    (CL:RETURN-FROM
     SAFE-TREE-SIZE
     (CL:VALUES
      SIZE
      (CL:IF
       (CL:OR (CL:EQ *DEPTHEXCEEDED?* 1) (CL:>= SIZE CUTOFF))
       "CIRCULAR"
       "OK")))))
  :VOID)

(CL:DEFUN STARTUP-CONSES ()
  (CL:WHEN
   (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 0) 1)
   (CL:WHEN (CL:EQ NIL NULL) (CL:SETQ NIL (CL:MAKE-INSTANCE (CL:QUOTE CONS))))
   (CL:SETF (CLSYS-SVAL CONS VALUE NIL) NULL)
   (CL:SETF (CLSYS-SVAL CONS REST NIL) NIL))
  (CL:LET*
   ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SGT-CONSES-ABSTRACT-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT-ITERATOR" NULL 1))
    (CL:SETQ SYM-CONSES-VALUE (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
    (CL:SETQ
     SYM-CONSES-VALUE-SETTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE-SETTER" NULL 0))
    (CL:SETQ
     SYM-CONSES-SLOT-WRITER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-WRITER" NULL 0))
    (CL:SETQ
     SGT-CONSES-GENERALIZED-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL" NULL 1))
    (CL:SETQ
     SYM-CONSES-*PRINTPRETTY?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*PRINTPRETTY?*" NULL 0))
    (CL:SETQ
     SYM-CONSES-*PRINTREADABLY?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*PRINTREADABLY?*" NULL 0))
    (CL:SETQ
     SYM-CONSES-*PRINTPRETTYCODE?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*PRINTPRETTYCODE?*" NULL 0))
    (CL:SETQ
     SYM-CONSES-*DEPTHEXCEEDED?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*DEPTHEXCEEDED?*" NULL 0)))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EMPTY?"
        "CONS"
        "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF CONS)) :DOCUMENTATION \"Return TRUE iff 'self' equals NIL.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NON-EMPTY?"
        "CONS"
        "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF CONS)) :DOCUMENTATION \"Return TRUE iff 'self' is not equal to NIL.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NON-EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NIL?"
        "OBJECT"
        "(DEFUN (NIL? BOOLEAN) ((X OBJECT)) :DOCUMENTATION \"Return TRUE iff 'x' equals NIL.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NIL?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-CONS"
        "CONS"
        "(DEFMETHOD FREE-CONS ((SELF CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-CONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-CONS-LIST"
        "CONS"
        "(DEFUN FREE-CONS-LIST ((SELF CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FREE-CONS-LIST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LENGTH"
        "CONS"
        "(DEFMETHOD (LENGTH INTEGER) ((SELF CONS)) :DOCUMENTATION \"Return the length of the CONS list 'self'.  CAUTION: Breaks if
'self' is not the head of a CONS list.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LENGTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POSITION"
        "CONS"
        "(DEFMETHOD (POSITION INTEGER) ((SELF CONS) (OBJECT OBJECT) (START INTEGER)) :DOCUMENTATION \"Return the position of 'object' within the cons-list
'self' (counting from zero); or return NULL if 'object' does not occur within 
'self' (uses an 'eql?' test).  If 'start' was supplied as non-NULL, only 
consider the sublist starting at 'start', however, the returned position 
will always be relative to the entire list.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION POSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MEMBER?"
        "CONS"
        "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF CONS) (OBJECT OBJECT)) :DOCUMENTATION \"Return TRUE iff 'object' is a member of the cons list
'self' (uses an 'eql?' test).\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MEMBER?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MEMB?"
        "CONS"
        "(DEFMETHOD (MEMB? BOOLEAN) ((SELF CONS) (OBJECT OBJECT)) :DOCUMENTATION \"Return TRUE iff 'object' is a member of the cons list
'self' (uses an 'eq?' test).\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MEMB?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONS"
        "OBJECT"
        "(DEFUN (CONS CONS) ((VALUE OBJECT) (REST CONS)) :DOCUMENTATION \"Return a cons record that points to 'value' and 'rest'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PERMANENT-CONS"
        "OBJECT"
        "(DEFUN (PERMANENT-CONS CONS) ((VALUE OBJECT) (REST CONS)) :DOCUMENTATION \"Return a permanent cons record that points to 'value' and 'rest'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PERMANENT-CONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOCAL-CONS"
        "OBJECT"
        "(DEFUN (LOCAL-CONS CONS) ((VALUE OBJECT) (REST CONS)) :DOCUMENTATION \"Return local cons record that points to 'value' and 'rest'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOCAL-CONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE"
        "CONS"
        "(DEFMETHOD (REMOVE CONS) ((SELF CONS) (VALUE OBJECT)) :DOCUMENTATION \"Remove all entries in the cons list 'self' that match
'value'.  Unless the remaining list is NIL, insure that the cons that
heads the list is unchanged.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REMOVE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-DUPLICATES"
        "CONS"
        "(DEFMETHOD (REMOVE-DUPLICATES CONS) ((SELF CONS)) :DOCUMENTATION \"Remove duplicates from the cons list 'self' and return
'self'. Removes all but the first occurrence of items in the list.
Preserves the original order of the remaining members.  Runs in quadratic
time.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REMOVE-DUPLICATES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONCATENATE"
        "CONS"
        "(DEFMETHOD (CONCATENATE CONS) ((SELF CONS) (LIST2 CONS)) :DOCUMENTATION \"Return a cons list consisting of the concatenation of 'self' and
'list2'.    The operation is destructive wrt 'self', but leaves 'list2'
intact.  CAUTION:  This operation results in structure sharing
of 'list2'; to avoid this, 'list2' should not be pointed to by anything
other than the tail of 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CONCATENATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PREPEND"
        "CONS"
        "(DEFMETHOD (PREPEND CONS) ((SELF CONS) (LIST1 CONS)) :DOCUMENTATION \"Return a cons list consisting of the concatenation of
'list1' and 'self'.  A copy of 'list1' is prepended to 'self'.  This
operation results in structure sharing of 'self'; to avoid this, 'self'
should not be pointed to by anything other than the tail of the prepended
copy.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PREPEND)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REVERSE"
        "CONS"
        "(DEFMETHOD (REVERSE (LIKE SELF)) ((SELF CONS)) :DOCUMENTATION \"Destructively reverse the members of the cons list 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REVERSE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBSTITUTE"
        "CONS"
        "(DEFMETHOD (SUBSTITUTE CONS) ((SELF CONS) (INVALUE OBJECT) (OUTVALUE OBJECT)) :DOCUMENTATION \"Destructively replace each appearance of 'outValue' by
'inValue' in the cons list 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SUBSTITUTE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIRST"
        "CONS"
        "(DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ((SELF CONS)) :DOCUMENTATION \"Return the first element of 'self'.  The first element
of 'self' can be set with 'setf'.  Note that '(first NIL)' = NULL.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FIRST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SECOND"
        "CONS"
        "(DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ((SELF CONS)) :DOCUMENTATION \"Return the second element of 'self'.  The second element
of 'self' can be set with 'setf'.  Note that '(second NIL)' = NULL.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SECOND)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "THIRD"
        "CONS"
        "(DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ((SELF CONS)) :DOCUMENTATION \"Return the third element of 'self'.  The third element
of 'self' can be set with 'setf'.  Note that '(third NIL)' = NULL.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION THIRD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FOURTH"
        "CONS"
        "(DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ((SELF CONS)) :DOCUMENTATION \"Return the fourth element of 'self'.  The fourth element
of 'self' can be set with 'setf'.  Note that '(fourth NIL)' = NULL.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FOURTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIFTH"
        "CONS"
        "(DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ((SELF CONS)) :DOCUMENTATION \"Return the fifth element of 'self'.  The fifth element
of 'self' can be set with 'setf'.  Note, that '(fifth NIL)' = NULL.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FIFTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NTH"
        "CONS"
        "(DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ((SELF CONS) (POSITION INTEGER)) :DOCUMENTATION \"Return the element of 'self' at 'position'.  The nth element
of 'self' can be set with 'setf'.  Note, that '(nth NIL <pos>)' = NULL.\" :PUBLIC? TRUE)")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION NTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NTH-REST"
        "CONS"
        "(DEFMETHOD (NTH-REST (LIKE SELF)) ((SELF CONS) (POSITION INTEGER)) :DOCUMENTATION \"Apply 'rest' 'position' times to 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NTH-REST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LAST-CONS"
        "CONS"
        "(DEFUN (LAST-CONS (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF CONS)) :DOCUMENTATION \"Return the last cons of 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LAST-CONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LAST"
        "CONS"
        "(DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ((SELF CONS)) :DOCUMENTATION \"Return the last element of 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION LAST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIRST-SETTER"
        "CONS"
        "(DEFMETHOD (FIRST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF CONS) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FIRST-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SECOND-SETTER"
        "CONS"
        "(DEFMETHOD (SECOND-SETTER (LIKE (ANY-VALUE SELF))) ((SELF CONS) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SECOND-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "THIRD-SETTER"
        "CONS"
        "(DEFMETHOD (THIRD-SETTER (LIKE (ANY-VALUE SELF))) ((SELF CONS) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION THIRD-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NTH-SETTER"
        "CONS"
        "(DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF CONS) (VALUE OBJECT) (POSITION INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NTH-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FOURTH-SETTER"
        "CONS"
        "(DEFMETHOD (FOURTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF CONS) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FOURTH-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIFTH-SETTER"
        "CONS"
        "(DEFMETHOD (FIFTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF CONS) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FIFTH-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NTH-REST-SETTER"
        "CONS"
        "(DEFMETHOD (NTH-REST-SETTER OBJECT) ((SELF CONS) (VALUE OBJECT) (POSITION INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NTH-REST-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-ITERATOR"
        "CONS"
        "(DEFMETHOD (ALLOCATE-ITERATOR CONS-ITERATOR) ((SELF CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ALLOCATE-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TERMINATE-CONS-ITERATOR?"
        "CONS-ITERATOR"
        "(DEFUN (TERMINATE-CONS-ITERATOR? BOOLEAN) ((SELF CONS-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TERMINATE-CONS-ITERATOR?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "CONS-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF CONS-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EMPTY?"
        "CONS-ITERATOR"
        "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF CONS-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VALUE-SETTER"
        "CONS-ITERATOR"
        "(DEFMETHOD (VALUE-SETTER OBJECT) ((SELF CONS-ITERATOR) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION VALUE-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ADD-CONS-TO-END-OF-CONS-LIST"
        "CONS"
        "(DEFUN ADD-CONS-TO-END-OF-CONS-LIST ((SELF CONS) (LASTCONS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ADD-CONS-TO-END-OF-CONS-LIST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUT-LAST-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (BUT-LAST-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BUT-LAST-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUT-LAST"
        "CONS"
        "(DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF CONS)) :DOCUMENTATION \"Generate all but the last element of the cons list 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION BUT-LAST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-CONS"
        "TRANSIENT-CONS"
        "(DEFMETHOD FREE-CONS ((SELF TRANSIENT-CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-CONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSIENT-CONS"
        "OBJECT"
        "(DEFUN (TRANSIENT-CONS CONS) ((VALUE OBJECT) (REST OBJECT)) :DOCUMENTATION \"Return a transient cons record that points to 'value' and
'rest'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSIENT-CONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-CONS-LIST-OF"
        "OBJECT"
        "(DEFUN (YIELD-CONS-LIST-OF CONS) ((SELF OBJECT)) :DOCUMENTATION \"If 'object' is a CONS, return it.  Otherwise, return
a singleton cons list containing it.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-CONS-LIST-OF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY-CONS-LIST"
        "CONS"
        "(DEFUN (COPY-CONS-LIST (LIKE SELF)) ((SELF CONS)) :DOCUMENTATION \"Return a copy of the cons list 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COPY-CONS-LIST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PERMANENT-COPY-CONS-LIST"
        "CONS"
        "(DEFUN (PERMANENT-COPY-CONS-LIST (LIKE SELF)) ((SELF CONS)) :DOCUMENTATION \"Return a permanent copy of the cons list 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PERMANENT-COPY-CONS-LIST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONS-LIST"
        "ARGUMENT-LIST"
        "(DEFUN (CONS-LIST CONS) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a cons list containing 'values', in order.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONS-LIST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LIST*"
        "ARGUMENT-LIST"
        "(DEFUN (LIST* CONS) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a list of conses that make up the list 'values',
terminated by the last value rather than by NIL.  Assumes that
at least one value is passed in.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LIST*)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "APPEND"
        "CONS"
        "(DEFUN (APPEND CONS) ((CONSLIST1 CONS) (CONSLIST2 CONS)) :DOCUMENTATION \"Return a transient cons list representing the concatenation
of 'consList1' and 'consList2'.  The concatenation is NOT destructive.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION APPEND)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SORT"
        "CONS"
        "(DEFMETHOD (SORT (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF CONS) (PREDICATE FUNCTION-CODE)) :PUBLIC? TRUE :DOCUMENTATION \"Perform a stable, destructive sort of 'self' according to
'predicate', and return the result.  If 'predicate' has a '<' semantics, the
result will be in ascending order.  It is not guaranteed that 'self' will
point to the beginning of the sorted result.  If 'predicate' is NULL, a
suitable '<' predicate is chosen depending on the first element of 'self',
and it is assumed that all elements of 'self' have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT).\")")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION SORT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-SORT-CONS-LIST"
        "CONS"
        "(DEFUN (HELP-SORT-CONS-LIST CONS) ((LIST CONS) (LENGTH INTEGER) (PREDICATE FUNCTION-CODE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-SORT-CONS-LIST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MERGE-CONS-LISTS"
        "CONS"
        "(DEFUN (MERGE-CONS-LISTS CONS) ((LIST1 CONS) (LIST2 CONS) (PREDICATE FUNCTION-CODE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MERGE-CONS-LISTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GENERALIZED-SYMBOL-LESS-THAN?"
        "GENERALIZED-SYMBOL"
        "(DEFUN (GENERALIZED-SYMBOL-LESS-THAN? BOOLEAN) ((X GENERALIZED-SYMBOL) (Y GENERALIZED-SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GENERALIZED-SYMBOL-LESS-THAN?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WRAPPED-INTEGER-LESS-THAN?"
        "INTEGER-WRAPPER"
        "(DEFUN (WRAPPED-INTEGER-LESS-THAN? BOOLEAN) ((X INTEGER-WRAPPER) (Y INTEGER-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WRAPPED-INTEGER-LESS-THAN?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WRAPPED-FLOAT-LESS-THAN?"
        "FLOAT-WRAPPER"
        "(DEFUN (WRAPPED-FLOAT-LESS-THAN? BOOLEAN) ((X FLOAT-WRAPPER) (Y FLOAT-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WRAPPED-FLOAT-LESS-THAN?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WRAPPED-STRING-LESS-THAN?"
        "STRING-WRAPPER"
        "(DEFUN (WRAPPED-STRING-LESS-THAN? BOOLEAN) ((X STRING-WRAPPER) (Y STRING-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WRAPPED-STRING-LESS-THAN?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CHOOSE-SORT-PREDICATE"
        "CONS"
        "(DEFUN (CHOOSE-SORT-PREDICATE FUNCTION-CODE) ((SELF CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CHOOSE-SORT-PREDICATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SEARCH-CONS-TREE?"
        "OBJECT"
        "(DEFUN (SEARCH-CONS-TREE? BOOLEAN) ((TREE OBJECT) (VALUE OBJECT)) :DOCUMENTATION \"Return TRUE iff the value 'value' is embedded within
the cons tree 'tree'.  Uses an 'eql?' test.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SEARCH-CONS-TREE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY-CONS-TREE"
        "OBJECT"
        "(DEFUN (COPY-CONS-TREE (LIKE SELF)) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COPY-CONS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-CONS-TREE"
        "OBJECT"
        "(DEFUN FREE-CONS-TREE ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FREE-CONS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EQUAL-CONS-TREES?"
        "OBJECT"
        "(DEFUN (EQUAL-CONS-TREES? BOOLEAN) ((TREE1 OBJECT) (TREE2 OBJECT)) :DOCUMENTATION \"Return TRUE iff the cons trees 'tree1' and 'tree2' are
structurally equivalent.  Uses an 'eql?' test.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EQUAL-CONS-TREES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBSTITUTE-CONS-TREE"
        "OBJECT"
        "(DEFUN (SUBSTITUTE-CONS-TREE OBJECT) ((TREE OBJECT) (NEWVALUE OBJECT) (OLDVALUE OBJECT)) :DOCUMENTATION \"Destructively replace each appearance of 'oldValue' by
'newValue' in the cons tree 'tree'.  Return the tree.  Uses an 'eql?' test.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SUBSTITUTE-CONS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-PARSE-TREE"
        "CONS"
        "(DEFMETHOD FREE-PARSE-TREE ((SELF CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-PARSE-TREE"
        "TRANSIENT-CONS"
        "(DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-PARSE-TREE"
        "OBJECT"
        "(DEFMETHOD FREE-PARSE-TREE ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-PARSE-TREE"
        "WRAPPER"
        "(DEFMETHOD FREE-PARSE-TREE ((SELF WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-PARSE-TREE"
        "TRANSIENT-INTEGER-WRAPPER"
        "(DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-INTEGER-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-PARSE-TREE"
        "TRANSIENT-FLOAT-WRAPPER"
        "(DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-FLOAT-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-PARSE-TREE"
        "TRANSIENT-STRING-WRAPPER"
        "(DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-STRING-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-PARSE-TREE"
        "TRANSIENT-CHARACTER-WRAPPER"
        "(DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-CHARACTER-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-PARSE-TREE"
        "TRANSIENT-FUNCTION-CODE-WRAPPER"
        "(DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-FUNCTION-CODE-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-PARSE-TREE"
        "TRANSIENT-METHOD-CODE-WRAPPER"
        "(DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-METHOD-CODE-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-PARSE-TREE"
        "TRANSIENT-SYMBOL"
        "(DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-PARSE-TREE"
        "TRANSIENT-KEYWORD"
        "(DEFMETHOD FREE-PARSE-TREE ((SELF TRANSIENT-KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-CONS"
        "CONS"
        "(DEFUN PRINT-CONS ((TREE CONS) (STREAM NATIVE-OUTPUT-STREAM) (LPAREN STRING) (RPAREN STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-CONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PPRINT-CONS"
        "CONS"
        "(DEFUN PPRINT-CONS ((TREE CONS) (STREAM NATIVE-OUTPUT-STREAM) (LPAREN STRING) (RPAREN STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PPRINT-CONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-STELLA-CODE"
        "OBJECT"
        "(DEFUN PRINT-STELLA-CODE ((TREE OBJECT) (STREAM NATIVE-OUTPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-STELLA-CODE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-STELLA-DEFINITION"
        "OBJECT"
        "(DEFUN PRINT-STELLA-DEFINITION ((TREE OBJECT) (STREAM NATIVE-OUTPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-STELLA-DEFINITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TREE-SIZE"
        "OBJECT"
        "(DEFUN (TREE-SIZE INTEGER) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TREE-SIZE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SAFELY-COMPUTE-TREE-SIZE"
        "CONS"
        "(DEFUN (SAFELY-COMPUTE-TREE-SIZE INTEGER) ((TREE CONS) (DEPTHCOUNT INTEGER) (CUTOFF INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SAFELY-COMPUTE-TREE-SIZE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SAFE-TREE-SIZE"
        "CONS"
        "(DEFUN (SAFE-TREE-SIZE INTEGER STRING) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SAFE-TREE-SIZE)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-CONSES"
     NULL
     "(DEFUN STARTUP-CONSES ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NIL CONS NULL)")
    (SET-DYNAMIC-SLOT-VALUE
     (LOOKUP-SLOT
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-CONSES-ABSTRACT-ITERATOR)
      SYM-CONSES-VALUE)
     SYM-CONSES-SLOT-WRITER
     SYM-CONSES-VALUE-SETTER
     NULL)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PRINTPRETTY?* BOOLEAN TRUE :DOCUMENTATION \"If TRUE conses will be pretty printed.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-CONSES-*PRINTPRETTY?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*PRINTPRETTY?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*PRINTPRETTY?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PRINTREADABLY?* BOOLEAN FALSE :DOCUMENTATION \"If TRUE conses will be printed as readable Stella code.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-CONSES-*PRINTREADABLY?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*PRINTREADABLY?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*PRINTREADABLY?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL ELIPSIS SYMBOL NULL :DOCUMENTATION \"Generates an elipsis '...' when found in a
pretty-printed parse tree.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PRINTPRETTYCODE?* BOOLEAN TRUE :DOCUMENTATION \"When TRUE pretty-print Stella and translated code.
Since (Lisp) pretty-printing is somewhat slow, turning this off speeds up
file translation, but it also makes translated output very unreadable.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-CONSES-*PRINTPRETTYCODE?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*PRINTPRETTYCODE?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*PRINTPRETTYCODE?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DEPTHEXCEEDED?* BOOLEAN FALSE)")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-CONSES-*DEPTHEXCEEDED?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*DEPTHEXCEEDED?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*DEPTHEXCEEDED?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEPTHCUTOFF* INTEGER 33)")))
  :VOID)
