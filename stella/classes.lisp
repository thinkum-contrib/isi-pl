;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-CLASSES-CLASS NULL)
(CL:DEFVAR SYM-CLASSES-TRUE NULL)
(CL:DEFVAR SYM-CLASSES-FALSE NULL)
(CL:DEFVAR KWD-CLASSES-PARAMETERS NULL)
(CL:DEFVAR SYM-CLASSES-SLOT-TYPE-SPECIFIER NULL)
(CL:DEFVAR KWD-CLASSES-PUBLIC? NULL)
(CL:DEFVAR KWD-CLASSES-REQUIRED? NULL)
(CL:DEFVAR KWD-CLASSES-COMPONENT? NULL)
(CL:DEFVAR KWD-CLASSES-READ-ONLY? NULL)
(CL:DEFVAR KWD-CLASSES-ACTIVE? NULL)
(CL:DEFVAR SYM-CLASSES-STORED-ACTIVE? NULL)
(CL:DEFVAR KWD-CLASSES-CONTEXT-SENSITIVE? NULL)
(CL:DEFVAR KWD-CLASSES-HARDWIRED? NULL)
(CL:DEFVAR KWD-CLASSES-ABSTRACT? NULL)
(CL:DEFVAR KWD-CLASSES-ALLOCATION NULL)
(CL:DEFVAR KWD-CLASSES-CLASS NULL)
(CL:DEFVAR SYM-CLASSES-SLOT-ALLOCATION NULL)
(CL:DEFVAR KWD-CLASSES-INITIALLY NULL)
(CL:DEFVAR SYM-CLASSES-SLOT-INITIAL-VALUE NULL)
(CL:DEFVAR KWD-CLASSES-DEFAULT NULL)
(CL:DEFVAR SYM-CLASSES-SLOT-DEFAULT-EXPRESSION NULL)
(CL:DEFVAR KWD-CLASSES-READER NULL)
(CL:DEFVAR SYM-CLASSES-SLOT-READER NULL)
(CL:DEFVAR KWD-CLASSES-WRITER NULL)
(CL:DEFVAR SYM-CLASSES-SLOT-WRITER NULL)
(CL:DEFVAR KWD-CLASSES-INVERSE NULL)
(CL:DEFVAR SYM-CLASSES-SLOT-INVERSE NULL)
(CL:DEFVAR KWD-CLASSES-RENAMES NULL)
(CL:DEFVAR SYM-CLASSES-SLOT-RENAMES NULL)
(CL:DEFVAR KWD-CLASSES-DOCUMENTATION NULL)
(CL:DEFVAR SYM-CLASSES-DOCUMENTATION NULL)
(CL:DEFVAR KWD-CLASSES-PROPERTIES NULL)
(CL:DEFVAR SYM-CLASSES-PROPERTIES NULL)
(CL:DEFVAR KWD-CLASSES-META-ATTRIBUTES NULL)
(CL:DEFVAR SYM-CLASSES-META-ATTRIBUTES NULL)
(CL:DEFVAR KWD-CLASSES-OPTION-KEYWORD NULL)
(CL:DEFVAR SYM-CLASSES-SLOT-OPTION-KEYWORD NULL)
(CL:DEFVAR KWD-CLASSES-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-CLASSES-SLOT-OPTION-HANDLER NULL)
(CL:DEFVAR SGT-CLASSES-BOOLEAN NULL)
(CL:DEFVAR KWD-CLASSES-BIT NULL)
(CL:DEFVAR KWD-CLASSES-CL-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-CL-NATIVE-TYPE NULL)
(CL:DEFVAR KWD-CLASSES-CPP-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-CPP-NATIVE-TYPE NULL)
(CL:DEFVAR KWD-CLASSES-IDL-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-IDL-NATIVE-TYPE NULL)
(CL:DEFVAR KWD-CLASSES-JAVA-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-JAVA-NATIVE-TYPE NULL)
(CL:DEFVAR KWD-CLASSES-CL-STRUCT? NULL)
(CL:DEFVAR KWD-CLASSES-MIXIN? NULL)
(CL:DEFVAR KWD-CLASSES-RECYCLE-METHOD NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-RECYCLE-METHOD NULL)
(CL:DEFVAR KWD-CLASSES-EXTENSION NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-EXTENSION-NAME NULL)
(CL:DEFVAR KWD-CLASSES-CREATOR NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-CREATOR NULL)
(CL:DEFVAR KWD-CLASSES-INITIALIZER NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-INITIALIZER NULL)
(CL:DEFVAR KWD-CLASSES-TERMINATOR NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-TERMINATOR NULL)
(CL:DEFVAR KWD-CLASSES-DESTRUCTOR NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-DESTRUCTOR NULL)
(CL:DEFVAR KWD-CLASSES-INITIAL-VALUE NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-INITIAL-VALUE NULL)
(CL:DEFVAR KWD-CLASSES-PRINT-FORM NULL)
(CL:DEFVAR SYM-CLASSES-PRINT-FORM NULL)
(CL:DEFVAR KWD-CLASSES-EQUALITY-TEST NULL)
(CL:DEFVAR KWD-CLASSES-KEY NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-KEY NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-PARAMETERS NULL)
(CL:DEFVAR KWD-CLASSES-SYNONYMS NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-SYNONYMS NULL)
(CL:DEFVAR KWD-CLASSES-CHILDREN NULL)
(CL:DEFVAR SGT-CLASSES-METHOD-SLOT NULL)
(CL:DEFVAR SYM-CLASSES-SLOT-GUARD-DEMONS NULL)
(CL:DEFVAR SYM-CLASSES-SLOT-DEMONS NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-CONSTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-GUARD-CONSTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-DESTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-GUARD-DESTRUCTOR-DEMONS NULL)
(CL:DEFVAR SGT-CLASSES-ACTIVE-OBJECT NULL)
(CL:DEFVAR SGT-CLASSES-OBJECT NULL)
(CL:DEFVAR SGT-CLASSES-STANDARD-OBJECT NULL)
(CL:DEFVAR SYM-CLASSES-PRIMARY-TYPE NULL)
(CL:DEFVAR SYM-CLASSES-SELF NULL)
(CL:DEFVAR KWD-CLASSES-TYPE NULL)
(CL:DEFVAR SYM-CLASSES-TYPE NULL)
(CL:DEFVAR KWD-CLASSES-AUXILIARY? NULL)
(CL:DEFVAR SYM-CLASSES-RETURN NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-EXTENSION NULL)
(CL:DEFVAR SGT-CLASSES-SET NULL)
(CL:DEFVAR SGT-CLASSES-ACTIVE-SET NULL)
(CL:DEFVAR SGT-CLASSES-LIST NULL)
(CL:DEFVAR SGT-CLASSES-ACTIVE-LIST NULL)
(CL:DEFVAR SGT-CLASSES-UNKNOWN NULL)
(CL:DEFVAR SGT-CLASSES-COLLECTION NULL)
(CL:DEFVAR SGT-CLASSES-SET-MIXIN NULL)
(CL:DEFVAR SYM-CLASSES-INVERSE NULL)
(CL:DEFVAR SGT-CLASSES-DYNAMIC-SLOTS-MIXIN NULL)
(CL:DEFVAR KWD-CLASSES-INSTANCE NULL)
(CL:DEFVAR SGT-CLASSES-CONTEXT-SENSITIVE-OBJECT NULL)
(CL:DEFVAR SGT-CLASSES-VOID NULL)
(CL:DEFVAR KWD-CLASSES-DYNAMIC NULL)
(CL:DEFVAR SGT-CLASSES-TABLE NULL)
(CL:DEFVAR SYM-CLASSES-CLASS-REQUIRED-SLOT-NAMES NULL)
(CL:DEFVAR SGT-CLASSES-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SYM-CLASSES-PRINT-UNBOUND-SURROGATES NULL)
(CL:DEFVAR KWD-CLASSES-COMMON-LISP NULL)
(CL:DEFVAR KWD-CLASSES-FUNCTION NULL)
(CL:DEFVAR SYM-CLASSES-EVALUATOR-WRAPPER-CODE NULL)
(CL:DEFVAR SYM-CLASSES-ANY NULL)
(CL:DEFVAR SGT-CLASSES-ANY NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *STELLA-MODULE*
  *REDEFINE-RELATION-HOOKS*
  *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES*
  NULL-BOOLEAN-WRAPPER
  NULL-STRING-WRAPPER
  TRUE-WRAPPER
  FALSE-WRAPPER
  INDEXICAL-SYM
  SYMBOL-SYM
  STANDARD-OUTPUT
  EOL
  *MODULE*
  SURROGATE-SYM))

;;; (DEFUN (CLASS-NAME STRING) ...)

(CL:DEFUN CLASS-NAME (CLASS)
  (CL:RETURN-FROM
   CLASS-NAME
   (CLSYS-SVAL SURROGATE SYMBOL-NAME (CLSYS-SVAL CLASS CLASS-TYPE CLASS)))
  :VOID)

;;; (DEFUN (CLASS-SYMBOL SYMBOL) ...)

(CL:DEFUN CLASS-SYMBOL (CLASS)
  (CL:RETURN-FROM
   CLASS-SYMBOL
   (TYPE-TO-SYMBOL (CLSYS-SVAL CLASS CLASS-TYPE CLASS)))
  :VOID)

;;; (DEFUN (TYPE-TO-SYMBOL SYMBOL) ...)

(CL:DEFUN TYPE-TO-SYMBOL (TYPE)
  (CL:RETURN-FROM
   TYPE-TO-SYMBOL
   (INTERN-DERIVED-SYMBOL TYPE (CLSYS-SVAL SURROGATE SYMBOL-NAME TYPE)))
  :VOID)

;;; (DEFMETHOD (PRIMARY-CLASS CLASS) ...)

(CL:DEFMETHOD PRIMARY-CLASS ((SELF OBJECT))
  (CL:WHEN
   (CL:NOT (CL:EQ (PRIMARY-TYPE SELF) NULL))
   (CL:RETURN-FROM
    PRIMARY-CLASS
    (CLSYS-SVAL SURROGATE SURROGATE-VALUE (PRIMARY-TYPE SELF))))
  (CL:RETURN-FROM PRIMARY-CLASS NULL)
  :VOID)

;;; (DEFMETHOD (LOOKUP-CLASS CLASS) ...)

(CL:DEFMETHOD LOOKUP-CLASS ((NAME CL:STRING))
  "Return a class with name 'name'.  Scan all
visible surrogates looking for one that has a class defined for it."
  (CL:LET*
   ((CLASS NULL) (SURROGATE NULL))
   (CL:LET*
    ((MODULE NULL) (ITER-001 (VISIBLE-MODULES *MODULE*)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ MODULE (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:LET*
      ((TEST-VALUE-001 FALSE))
      (CL:LET*
       ()
       (CL:SETQ
        SURROGATE
        (LOOKUP-RIGID-SYMBOL-LOCALLY NAME MODULE SURROGATE-SYM))
       (CL:SETQ TEST-VALUE-001 (DEFINED? SURROGATE)))
      (CL:WHEN
       (CL:EQ TEST-VALUE-001 1)
       (CL:LET*
        ()
        (CL:SETQ CLASS (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE))
        (CL:SETQ TEST-VALUE-001 (DEFINED? CLASS)))
       (CL:WHEN
        (CL:EQ TEST-VALUE-001 1)
        (CL:SETQ TEST-VALUE-001 (ISA? CLASS SGT-CLASSES-CLASS))))
      (CL:WHEN
       (CL:EQ TEST-VALUE-001 1)
       (CL:RETURN-FROM LOOKUP-CLASS CLASS)))))
   (CL:RETURN-FROM LOOKUP-CLASS NULL))
  :VOID)

;;; (DEFMETHOD (LOOKUP-CLASS CLASS) ...)

(CL:DEFMETHOD LOOKUP-CLASS ((NAME SYMBOL))
  "Return a class with name 'name'.  Scan all
visible surrogates looking for one that has a class defined for it."
  (CL:LET*
   ((*MODULE* (CLSYS-SVAL SYMBOL HOME-CONTEXT NAME)))
   (CL:DECLARE (CL:SPECIAL *MODULE*))
   (CL:RETURN-FROM
    LOOKUP-CLASS
    (LOOKUP-CLASS (CLSYS-SVAL SYMBOL SYMBOL-NAME NAME))))
  :VOID)

;;; (DEFUN (TYPE-TO-CLASS CLASS) ...)

(CL:DEFUN TYPE-TO-CLASS (TYPE)
  (CL:RETURN-FROM TYPE-TO-CLASS (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE))
  :VOID)

;;; (DEFMETHOD (GET-CLASS CLASS) ...)

(CL:DEFMETHOD GET-CLASS ((CLASSNAME SURROGATE) ERROR?)
  "Return a class with name 'className'.  If none exists, break
if 'error?', else return NULL."
  (CL:LET*
   ((CLASS (CLSYS-SVAL SURROGATE SURROGATE-VALUE CLASSNAME)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ CLASS NULL)) (CL:EQ (CLASS? CLASS) 1))
    (CL:RETURN-FROM GET-CLASS CLASS))
   (CL:IF
    (CL:EQ ERROR? 1)
    (CL:CERROR "Continue anyway? " "Class `~A' does not exist." CLASSNAME)
    (CL:RETURN-FROM GET-CLASS NULL)))
  :VOID)

;;; (DEFMETHOD (GET-CLASS CLASS) ...)

(CL:DEFMETHOD GET-CLASS ((CLASSNAME CL:STRING) ERROR?)
  "Return a class with name 'className'.  If none exists, break
if 'error?', else return NULL."
  (CL:LET*
   ((TYPE (LOOKUP-SURROGATE CLASSNAME)))
   (CL:WHEN
    (CL:NOT (CL:EQ TYPE NULL))
    (CL:RETURN-FROM GET-CLASS (GET-CLASS TYPE ERROR?)))
   (CL:IF
    (CL:EQ ERROR? 1)
    (CL:CERROR "Continue anyway? " "Class `~A' does not exist." CLASSNAME)
    (CL:RETURN-FROM GET-CLASS NULL)))
  :VOID)

;;; (DEFMETHOD (GET-CLASS CLASS) ...)

(CL:DEFMETHOD GET-CLASS ((CLASSNAME SYMBOL) ERROR?)
  "Return a class with name 'className'.  If non exists, break
if 'error?', else return NULL."
  (CL:RETURN-FROM
   GET-CLASS
   (GET-CLASS (CLSYS-SVAL SYMBOL SYMBOL-NAME CLASSNAME) ERROR?))
  :VOID)

;;; (DEFGLOBAL *WARN-IF-REDEFINE?* ...)

(CL:DEFVAR *WARN-IF-REDEFINE?* TRUE
  "If set, warn about each redefinition.")

;;; (DEFUN (BIND-TO-SURROGATE? BOOLEAN OBJECT SURROGATE) ...)

(CL:DEFUN BIND-TO-SURROGATE? (SELF NAME CLIPOLDVALUE? WARNONFAILURE?)
  (CL:LET*
   ((OLDSURROGATE (LOOKUP-SURROGATE NAME))
    (OLDVALUE
     (CL:IF
      (CL:NOT (CL:EQ OLDSURROGATE NULL))
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE OLDSURROGATE)
      NULL))
    (SURROGATE (SHADOW-SURROGATE NAME))
    (OLDMODULE NULL))
   (CL:WHEN
    (CL:EQ OLDVALUE NULL)
    (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE) SELF)
    (CL:RETURN-FROM BIND-TO-SURROGATE? (CL:VALUES TRUE NULL SURROGATE)))
   (CL:WHEN
    (CL:EQ (EQL? OLDVALUE SELF) 1)
    (CL:RETURN-FROM BIND-TO-SURROGATE? (CL:VALUES TRUE NULL SURROGATE)))
   (CL:SETQ OLDMODULE (CLSYS-SVAL SURROGATE HOME-CONTEXT OLDSURROGATE))
   (CL:COND
    ((CL:NOT (CL:EQ OLDMODULE *MODULE*))
     (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE) SELF)
     (CL:WHEN
      (CL:EQ *WARN-IF-REDEFINE?* 1)
      (CL:WARN
       "Shadowing the `~A' named `~A'"
       (CLSYS-SVAL SURROGATE SYMBOL-NAME (PRIMARY-TYPE SELF))
       NAME)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING
        "CAUTION: Automatic shadowing can be dangerous, because forward "
        %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING
        "   references to a shadowed object may be bound to the now-shadowed "
        %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING
        "   object.  Suggestion: Explicitly shadow the name using"
        %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING "   DEFMODULE's `:shadow' option." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))
     (CL:RETURN-FROM BIND-TO-SURROGATE? (CL:VALUES TRUE NULL SURROGATE)))
    ((CL:EQ CLIPOLDVALUE? 1)
     (CL:WHEN
      (CL:EQ *WARN-IF-REDEFINE?* 1)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "Redefining the `" %%STREAM)
       (CL:WRITE-STRING
        (CLSYS-SVAL SURROGATE SYMBOL-NAME (PRIMARY-TYPE SELF))
        %%STREAM)
       (CL:WRITE-STRING "' named `" %%STREAM)
       (CL:WRITE-STRING NAME %%STREAM)
       (CL:WRITE-STRING "'" %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))
     (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE) SELF)
     (CL:WHEN
      (CL:NOT (CL:EQ (PRIMARY-TYPE SELF) (PRIMARY-TYPE OLDVALUE)))
      (CL:SETQ OLDVALUE NULL))
     (CL:RETURN-FROM BIND-TO-SURROGATE? (CL:VALUES TRUE OLDVALUE SURROGATE)))
    (CL:T
     (CL:WHEN
      (CL:EQ WARNONFAILURE? 1)
      (CL:WARN
       "Can't define the `~A' named `~A' in module `~A'~%   because it is already defined."
       (CLSYS-SVAL SURROGATE SYMBOL-NAME (PRIMARY-TYPE SELF))
       NAME
       *MODULE*))
     (CL:RETURN-FROM BIND-TO-SURROGATE? (CL:VALUES FALSE NULL SURROGATE)))))
  :VOID)

;;; (DEFMETHOD UNBIND-FROM-SURROGATE ...)

(CL:DEFMETHOD UNBIND-FROM-SURROGATE ((SELF CLASS))
  (CL:LET*
   ((SURROGATE (CLSYS-SVAL CLASS CLASS-TYPE SELF)))
   (CL:WHEN
    (CL:NOT (CL:EQ SURROGATE NULL))
    (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE) NULL)
    (CL:SETF (CLSYS-SVAL CLASS CLASS-TYPE SELF) NULL)))
  :VOID)

;;; (DEFUN (SHADOW-SYMBOL SYMBOL) ...)

(CL:DEFUN SHADOW-SYMBOL (NAME)
  (CL:RETURN-FROM
   SHADOW-SYMBOL
   (INTERN-RIGID-SYMBOL-LOCALLY NAME *MODULE* SYMBOL-SYM))
  :VOID)

;;; (DEFUN (SHADOW-SURROGATE SURROGATE) ...)

(CL:DEFUN SHADOW-SURROGATE (NAME)
  (SHADOW-SYMBOL NAME)
  (CL:RETURN-FROM
   SHADOW-SURROGATE
   (INTERN-RIGID-SYMBOL-LOCALLY NAME *MODULE* SURROGATE-SYM))
  :VOID)

;;; (DEFUN (BIND-TO-INDEXICAL? BOOLEAN OBJECT) ...)

(CL:DEFUN BIND-TO-INDEXICAL? (SELF NAME CLIPOLDVALUE? WARNONFAILURE?)
  (CL:LET*
   ((OLDINDEXICAL (LOOKUP-INDEXICAL NAME))
    (OLDVALUE
     (CL:IF
      (CL:NOT (CL:EQ OLDINDEXICAL NULL))
      (ACCESS-IN-CONTEXT
       (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE OLDINDEXICAL)
       OLDINDEXICAL
       FALSE)
      NULL))
    (INDEXICAL (SHADOW-INDEXICAL NAME))
    (OLDMODULE NULL))
   (CL:WHEN
    (CL:EQ OLDVALUE NULL)
    (CL:LET*
     ((OBJECT-001 INDEXICAL)
      (VALUE-001 SELF)
      (OLD-VALUE-002 (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE OBJECT-001))
      (NEW-VALUE-001
       (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-001 OBJECT-001 FALSE)))
     (CL:WHEN
      (CL:EQ (CS-VALUE? OLD-VALUE-002) 0)
      (CL:SETF
       (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE OBJECT-001)
       NEW-VALUE-001)))
    (CL:RETURN-FROM BIND-TO-INDEXICAL? (CL:VALUES TRUE NULL)))
   (CL:WHEN
    (CL:EQ (EQL? OLDVALUE SELF) 1)
    (CL:RETURN-FROM BIND-TO-INDEXICAL? (CL:VALUES TRUE NULL)))
   (CL:WHEN
    (CL:NOT (CL:EQ (PRIMARY-TYPE SELF) (PRIMARY-TYPE OLDVALUE)))
    (CL:WHEN
     (CL:EQ WARNONFAILURE? 1)
     (CL:WARN
      "Can't define the `~A' named `~A' in module `~A'~%   because it is already defined as a `~A'"
      (CLSYS-SVAL SURROGATE SYMBOL-NAME (PRIMARY-TYPE SELF))
      NAME
      *MODULE*
      (CLSYS-SVAL SURROGATE SYMBOL-NAME (PRIMARY-TYPE OLDVALUE))))
    (CL:RETURN-FROM BIND-TO-INDEXICAL? (CL:VALUES FALSE OLDVALUE)))
   (CL:SETQ
    OLDMODULE
    (CL:IF
     (CL:EQ OLDINDEXICAL INDEXICAL)
     (COMPUTE-NEAREST-CONTEXT
      (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE INDEXICAL)
      INDEXICAL
      *MODULE*)
     (CLSYS-SVAL INDEXICAL HOME-CONTEXT OLDINDEXICAL)))
   (CL:COND
    ((CL:NOT (CL:EQ OLDMODULE *MODULE*))
     (CL:LET*
      ((OBJECT-002 INDEXICAL)
       (VALUE-002 SELF)
       (OLD-VALUE-004 (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE OBJECT-002))
       (NEW-VALUE-002
        (UPDATE-IN-CONTEXT OLD-VALUE-004 VALUE-002 OBJECT-002 FALSE)))
      (CL:WHEN
       (CL:EQ (CS-VALUE? OLD-VALUE-004) 0)
       (CL:SETF
        (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE OBJECT-002)
        NEW-VALUE-002)))
     (CL:WHEN
      (CL:EQ *WARN-IF-REDEFINE?* 1)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "Shadowing the `" %%STREAM)
       (CL:WRITE-STRING
        (CLSYS-SVAL SURROGATE SYMBOL-NAME (PRIMARY-TYPE SELF))
        %%STREAM)
       (CL:WRITE-STRING "' named `" %%STREAM)
       (CL:WRITE-STRING NAME %%STREAM)
       (CL:WRITE-STRING "'" %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))
     (CL:RETURN-FROM BIND-TO-INDEXICAL? (CL:VALUES TRUE NULL)))
    ((CL:EQ CLIPOLDVALUE? 1)
     (CL:WHEN
      (CL:EQ *WARN-IF-REDEFINE?* 1)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "Redefining the `" %%STREAM)
       (CL:WRITE-STRING
        (CLSYS-SVAL SURROGATE SYMBOL-NAME (PRIMARY-TYPE SELF))
        %%STREAM)
       (CL:WRITE-STRING "' named `" %%STREAM)
       (CL:WRITE-STRING NAME %%STREAM)
       (CL:WRITE-STRING "'" %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))
     (CL:LET*
      ((OBJECT-003 INDEXICAL)
       (VALUE-003 SELF)
       (OLD-VALUE-005 (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE OBJECT-003))
       (NEW-VALUE-003
        (UPDATE-IN-CONTEXT OLD-VALUE-005 VALUE-003 OBJECT-003 FALSE)))
      (CL:WHEN
       (CL:EQ (CS-VALUE? OLD-VALUE-005) 0)
       (CL:SETF
        (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE OBJECT-003)
        NEW-VALUE-003)))
     (CL:RETURN-FROM BIND-TO-INDEXICAL? (CL:VALUES TRUE OLDVALUE)))
    (CL:T
     (CL:WHEN
      (CL:EQ WARNONFAILURE? 1)
      (CL:WARN
       "Can't define the `~A' named `~A' in module `~A'~%   because it is already defined."
       (CLSYS-SVAL SURROGATE SYMBOL-NAME (PRIMARY-TYPE SELF))
       NAME
       *MODULE*))
     (CL:RETURN-FROM BIND-TO-INDEXICAL? (CL:VALUES FALSE NULL)))))
  :VOID)

;;; (DEFUN (SHADOW-INDEXICAL INDEXICAL) ...)

(CL:DEFUN SHADOW-INDEXICAL (NAME)
  (CL:LET*
   ((INDEXICAL (LOOKUP-INDEXICAL NAME)))
   (CL:WHEN
    (CL:OR
     (CL:EQ INDEXICAL NULL)
     (CL:NOT (CL:EQ (CLSYS-SVAL INDEXICAL HOME-CONTEXT INDEXICAL) *MODULE*)))
    (CL:LET*
     ((ARRAY (SELECT-SYMBOL-ARRAY INDEXICAL-SYM))
      (OFFSET (NEXT-FREE-OFFSET ARRAY)))
     (CL:SETQ
      INDEXICAL
      (HELP-INTERN-GENERALIZED-SYMBOL
       NAME
       INDEXICAL-SYM
       ARRAY
       OFFSET
       *MODULE*))))
   (CL:LET*
    ((STOREDVALUE (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE INDEXICAL)))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (COMPUTE-NEAREST-CONTEXT STOREDVALUE INDEXICAL *MODULE*)
       *MODULE*))
     (CL:LET*
      ((OBJECT-001 INDEXICAL)
       (VALUE-001 NULL)
       (OLD-VALUE-002 (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE OBJECT-001))
       (NEW-VALUE-001
        (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-001 OBJECT-001 FALSE)))
      (CL:WHEN
       (CL:EQ (CS-VALUE? OLD-VALUE-002) 0)
       (CL:SETF
        (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE OBJECT-001)
        NEW-VALUE-001)))))
   (CL:RETURN-FROM SHADOW-INDEXICAL INDEXICAL))
  :VOID)

;;; (DEFUN (GET-CONSTRUCTOR FUNCTION-CODE) ...)

(CL:DEFUN GET-CONSTRUCTOR (CLASS WARN?)
  (CL:LET*
   ((CONSTRUCTOR (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)))
   (CL:WHEN
    (CL:NOT (CL:EQ CONSTRUCTOR NULL))
    (CL:RETURN-FROM GET-CONSTRUCTOR CONSTRUCTOR))
   (CL:WHEN
    (CL:EQ WARN? 1)
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL CLASS ABSTRACT? CLASS) 1)
     (CL:WARN
      "The abstract class `~A' cannot have a constructor."
      (CLASS-SYMBOL CLASS))
     (CL:RETURN-FROM GET-CONSTRUCTOR NULL))
    (CL:WARN
     "The `~A'class `~A' does not have a callable constructor."
     (CL:IF (CL:EQ (PRIVATE? CLASS) 1) "private " "")
     (CLASS-SYMBOL CLASS)))
   (CL:RETURN-FROM GET-CONSTRUCTOR NULL))
  :VOID)

;;; (DEFUN (CREATE-OBJECT OBJECT) ...)

(CL:DEFUN CREATE-OBJECT (TYPE CL:&REST ALTERNATINGSYMBOLSANDVALUES)
  "Flexible, user-friendly version of 'new'.
Return an instance of the class named with type 'type'.
Fill in values using 'alternatingKeywordsAndValues' and call the
initialization function, if one exists. Any arguments required by 'new'
for this type must be included.  'create' runs more slowly than 'new'."
  (CL:LET*
   ((CLASS (GET-CLASS TYPE TRUE))
    (CONSTRUCTORCODE (GET-CONSTRUCTOR CLASS TRUE))
    (OPTIONS NIL)
    (NEWOBJECT NULL)
    (CURSOR NULL))
   (CL:WHEN (CL:EQ CONSTRUCTORCODE NULL) (CL:RETURN-FROM CREATE-OBJECT NULL))
   (CL:WHEN
    (CL:EQ (NON-EMPTY? (CLASS-REQUIRED-SLOT-NAMES CLASS)) 1)
    (CL:WARN "Can't call 'create' on a class having required slots.")
    (CL:RETURN-FROM CREATE-OBJECT NULL))
   (CL:SETQ NEWOBJECT (CL:FUNCALL CONSTRUCTORCODE))
   (CL:LET*
    ((ITEM NULL)
     (ITER-001 (ALLOCATE-ITERATOR ALTERNATINGSYMBOLSANDVALUES))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ ITEM (CLSYS-SVAL LISP-CONS-ITERATOR VALUE ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (CONS ITEM NIL))
       (CL:IF
        (CL:EQ OPTIONS NIL)
        (CL:SETQ OPTIONS COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST OPTIONS COLLECT-001)))
      (CL:PROGN
       (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS ITEM NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:SETQ CURSOR OPTIONS)
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (PUT-SLOT-VALUE
     NEWOBJECT
     (CLSYS-SVAL CONS VALUE CURSOR)
     (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST CURSOR)))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST CURSOR))))
   (FREE-CONS-LIST OPTIONS)
   (CL:RETURN-FROM CREATE-OBJECT NEWOBJECT))
  :VOID)

;;; (DEFMETHOD FREE ...)

(CL:DEFMETHOD FREE ((SELF OBJECT))
  "Default method.  Deallocate storage for 'self'."
  (UNMAKE SELF)
  :VOID)

;;; (DEFMETHOD FREE ...)

(CL:DEFMETHOD FREE ((SELF ACTIVE-OBJECT))
  "Remove all pointers between 'self' and other objects,
and then deallocate the storage for self."
  "NOT YET IMPLEMENTED"
  (UNMAKE SELF)
  :VOID)

;;; (DEFUN (SYMBOL-TO-WRAPPED-BOOLEAN BOOLEAN-WRAPPER) ...)

(CL:DEFUN SYMBOL-TO-WRAPPED-BOOLEAN (OBJECT)
  (CL:LET*
   ((TEST-VALUE-001 OBJECT))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 SYM-CLASSES-TRUE)
     (CL:RETURN-FROM SYMBOL-TO-WRAPPED-BOOLEAN TRUE-WRAPPER))
    ((CL:EQ TEST-VALUE-001 SYM-CLASSES-FALSE)
     (CL:RETURN-FROM SYMBOL-TO-WRAPPED-BOOLEAN FALSE-WRAPPER))
    (CL:T (CL:ERROR "`~A' found where Boolean symbol expected." OBJECT))))
  :VOID)

;;; (DEFUN (DEFINE-STELLA-CLASS CLASS) ...)

(CL:DEFUN DEFINE-STELLA-CLASS (NAME SUPERS SLOTS OPTIONS)
  "Return a Stella class with name 'name'.
Caution:  If the class already exists, the Stella class object gets
redefined, but the native C++ class is not redefined."
  (CL:LET*
   ((CLASS (NEW-CLASS))
    (PARAMETERSLOTS (LOOKUP OPTIONS KWD-CLASSES-PARAMETERS))
    (OLDCLASS NULL)
    (SUCCESS? FALSE))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE HOME-CONTEXT NAME) *MODULE*))
     (CL:EQ
      (VISIBLE-FROM? (CLSYS-SVAL SURROGATE HOME-CONTEXT NAME) *MODULE*)
      0))
    (CL:WARN
     "Can't define a class named `~A' because the module ~%   `~A' is not visible from the current module `~A'.~%"
     NAME
     (CONTEXT-NAME (CLSYS-SVAL SURROGATE HOME-CONTEXT NAME))
     (CONTEXT-NAME *MODULE*))
    (CL:RETURN-FROM DEFINE-STELLA-CLASS NULL))
   (CL:LET*
    ((VALUE-001 FALSE) (VALUE-002 NULL) (VALUE-003 NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (VALUE-001 VALUE-002 VALUE-003)
     (BIND-TO-SURROGATE?
      CLASS
      (CLSYS-SVAL SURROGATE SYMBOL-NAME NAME)
      TRUE
      TRUE))
    (CL:PROGN
     (CL:SETQ SUCCESS? VALUE-001)
     (CL:SETQ OLDCLASS VALUE-002)
     (CL:SETQ NAME VALUE-003)))
   (CL:WHEN (CL:EQ SUCCESS? 0) (CL:RETURN-FROM DEFINE-STELLA-CLASS NULL))
   (CL:SETF (CLSYS-SVAL CLASS CLASS-TYPE CLASS) NAME)
   (CL:WHEN
    (CL:NOT (CL:EQ PARAMETERSLOTS NULL))
    (CL:LET*
     ((S NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST PARAMETERSLOTS)))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ S (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:SETF (CLSYS-SVAL SLOT ABSTRACT? S) TRUE)
      (INSERT-LAST SLOTS S))))
   (INITIALIZE-SLOT-AND-METHOD-CACHE CLASS)
   (CL:LET*
    ((S NULL)
     (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST SUPERS))
     (INTO-001 (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ S (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (PERMANENT-CONS S NIL))
       (CL:IF
        (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST INTO-001) NIL)
        (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST INTO-001) COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST
         (CLSYS-SVAL LIST THE-CONS-LIST INTO-001)
         COLLECT-001)))
      (CL:PROGN
       (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (PERMANENT-CONS S NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (INCORPORATE-CLASS-OPTIONS CLASS OPTIONS)
   (CL:LET*
    ((TEST-VALUE-001 FALSE))
    (CL:SETQ TEST-VALUE-001 (CL:IF (CL:EQ (PRIMITIVE? CLASS) 0) TRUE FALSE))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:LET*
      ((FOUND?-001 FALSE))
      (CL:LET*
       ((SLOT NULL) (ITER-003 (CLSYS-SVAL LIST THE-CONS-LIST SLOTS)))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-003 NIL))
        DO
        (CL:PROGN
         (CL:SETQ SLOT (CLSYS-SVAL CONS VALUE ITER-003))
         (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
        (CL:WHEN
         (CL:EQ (PRIMITIVE? SLOT) 1)
         (CL:SETQ FOUND?-001 TRUE)
         (CL:RETURN))))
      (CL:SETQ TEST-VALUE-001 FOUND?-001)))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:WARN
      "Defined class `~A' illegally specifies primitive slots."
      CLASS)))
   (CL:SETF (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS CLASS) SLOTS)
   (CL:WHEN
    (CL:NOT (CL:EQ OLDCLASS NULL))
    (UNDEFINE-OLD-CLASS OLDCLASS CLASS))
   (CL:LET*
    ((SLOT NULL) (ITER-004 (CLSYS-SVAL LIST THE-CONS-LIST SLOTS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-004 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SLOT (CLSYS-SVAL CONS VALUE ITER-004))
      (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
     (REGISTER-SLOT-NAME SLOT)))
   (REMEMBER-UNFINALIZED-CLASS CLASS TRUE)
   (CL:RETURN-FROM DEFINE-STELLA-CLASS CLASS))
  :VOID)

;;; (DEFUN (DEFINE-STELLA-SLOT SLOT) ...)

(CL:DEFUN DEFINE-STELLA-SLOT (NAME OWNER BASETYPE TYPESPECIFIER OPTIONS)
  (CL:LET*
   ((SLOT (NEW-STORAGE-SLOT)))
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT) NAME)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SLOT) OWNER)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SLOT) BASETYPE)
   (CL:WHEN
    (CL:NOT (CL:EQ TYPESPECIFIER NIL))
    (SET-DYNAMIC-SLOT-VALUE
     SLOT
     SYM-CLASSES-SLOT-TYPE-SPECIFIER
     (YIELD-TYPE-SPECIFIER TYPESPECIFIER)
     NULL))
   (CL:LET*
    ((VALUE NULL) (KEY NULL) (ITER-001 (ALLOCATE-ITERATOR OPTIONS)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:SETQ KEY (CLSYS-SVAL KV-LIST-ITERATOR KEY ITER-001))
     (CL:PROGN (CL:SETQ VALUE (CLSYS-SVAL KV-LIST-ITERATOR VALUE ITER-001)))
     (CL:COND
      ((CL:EQ KEY KWD-CLASSES-PUBLIC?)
       (CL:SETF
        (CLSYS-SVAL STORAGE-SLOT SLOT-PUBLIC? SLOT)
        (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE)))
      ((CL:EQ KEY KWD-CLASSES-REQUIRED?)
       (CL:SETF
        (CLSYS-SVAL STORAGE-SLOT SLOT-REQUIRED? SLOT)
        (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE)))
      ((CL:EQ KEY KWD-CLASSES-COMPONENT?)
       (CL:SETF
        (CLSYS-SVAL STORAGE-SLOT SLOT-COMPONENT? SLOT)
        (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE)))
      ((CL:EQ KEY KWD-CLASSES-READ-ONLY?)
       (CL:SETF
        (CLSYS-SVAL STORAGE-SLOT SLOT-READ-ONLY? SLOT)
        (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE)))
      ((CL:EQ KEY KWD-CLASSES-ACTIVE?)
       (SET-DYNAMIC-SLOT-VALUE
        SLOT
        SYM-CLASSES-STORED-ACTIVE?
        (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
        NULL-BOOLEAN-WRAPPER))
      ((CL:EQ KEY KWD-CLASSES-CONTEXT-SENSITIVE?)
       (CL:SETF
        (CLSYS-SVAL STORAGE-SLOT SLOT-CONTEXT-SENSITIVE? SLOT)
        (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE)))
      ((CL:EQ KEY KWD-CLASSES-HARDWIRED?)
       (CL:SETF
        (CLSYS-SVAL STORAGE-SLOT SLOT-HARDWIRED? SLOT)
        (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE)))
      ((CL:EQ KEY KWD-CLASSES-ABSTRACT?)
       (CL:SETF
        (CLSYS-SVAL STORAGE-SLOT ABSTRACT? SLOT)
        (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE)))
      ((CL:EQ KEY KWD-CLASSES-ALLOCATION)
       (CL:IF
        (CL:EQ VALUE KWD-CLASSES-CLASS)
        (CL:WARN
         "In definition of slot `~A': ':class' allocation is unsupported right now.~% Maybe use ':hardwired? TRUE' for read-only slots."
         SLOT)
        (SET-DYNAMIC-SLOT-VALUE SLOT SYM-CLASSES-SLOT-ALLOCATION VALUE NULL)))
      ((CL:EQ KEY KWD-CLASSES-INITIALLY)
       (SET-DYNAMIC-SLOT-VALUE
        SLOT
        SYM-CLASSES-SLOT-INITIAL-VALUE
        VALUE
        NULL))
      ((CL:EQ KEY KWD-CLASSES-DEFAULT)
       (SET-DYNAMIC-SLOT-VALUE
        SLOT
        SYM-CLASSES-SLOT-DEFAULT-EXPRESSION
        VALUE
        NULL))
      ((CL:EQ KEY KWD-CLASSES-READER)
       (SET-DYNAMIC-SLOT-VALUE SLOT SYM-CLASSES-SLOT-READER VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-WRITER)
       (SET-DYNAMIC-SLOT-VALUE SLOT SYM-CLASSES-SLOT-WRITER VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-INVERSE)
       (SET-DYNAMIC-SLOT-VALUE SLOT SYM-CLASSES-SLOT-INVERSE VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-RENAMES)
       (SET-DYNAMIC-SLOT-VALUE SLOT SYM-CLASSES-SLOT-RENAMES VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-DOCUMENTATION)
       (SET-DYNAMIC-SLOT-VALUE
        SLOT
        SYM-CLASSES-DOCUMENTATION
        (WRAP-STRING (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
        NULL-STRING-WRAPPER))
      ((CL:EQ KEY KWD-CLASSES-PROPERTIES)
       (SET-DYNAMIC-SLOT-VALUE SLOT SYM-CLASSES-PROPERTIES VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-META-ATTRIBUTES)
       (SET-DYNAMIC-SLOT-VALUE SLOT SYM-CLASSES-META-ATTRIBUTES VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-OPTION-KEYWORD)
       (SET-DYNAMIC-SLOT-VALUE
        SLOT
        SYM-CLASSES-SLOT-OPTION-KEYWORD
        VALUE
        NULL))
      ((CL:EQ KEY KWD-CLASSES-OPTION-HANDLER)
       (SET-DYNAMIC-SLOT-VALUE
        SLOT
        SYM-CLASSES-SLOT-OPTION-HANDLER
        VALUE
        NULL))
      (CL:T
       (CL:WHEN
        (CL:EQ (RUN-OPTION-HANDLER? SLOT KEY VALUE) 0)
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-WARNING)
         (CL:WHEN
          (CL:EQ (SUPPRESS-WARNINGS?) 0)
          (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING " Skipping invalid slot option `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE KEY) %%STREAM)
           (CL:WRITE-STRING "'" %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING "in the definition of slot `" %%STREAM)
           (PRINT-OBJECT (TYPE-TO-SYMBOL OWNER) %%STREAM)
           (CL:WRITE-STRING "'.`" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE NAME) %%STREAM)
           (CL:WRITE-STRING "'." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)))))))))
   (CL:WHEN
    (CL:AND
     (CL:EQ (SLOT-ALLOCATION SLOT) NULL)
     (CL:EQ BASETYPE SGT-CLASSES-BOOLEAN))
    (SET-DYNAMIC-SLOT-VALUE
     SLOT
     SYM-CLASSES-SLOT-ALLOCATION
     KWD-CLASSES-BIT
     NULL))
   (CL:RETURN-FROM DEFINE-STELLA-SLOT SLOT))
  :VOID)

;;; (DEFUN INCORPORATE-CLASS-OPTIONS ...)

(CL:DEFUN INCORPORATE-CLASS-OPTIONS (CLASS OPTIONS)
  (CL:LET*
   ((VALUE NULL) (KEY NULL) (ITER-001 (ALLOCATE-ITERATOR OPTIONS)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITER-001) 1)
    DO
    (CL:SETQ KEY (CLSYS-SVAL KV-LIST-ITERATOR KEY ITER-001))
    (CL:PROGN (CL:SETQ VALUE (CLSYS-SVAL KV-LIST-ITERATOR VALUE ITER-001)))
    (CL:COND
     ((CL:EQ KEY KWD-CLASSES-DOCUMENTATION)
      (SET-DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CLASSES-DOCUMENTATION
       (WRAP-STRING (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
       NULL-STRING-WRAPPER))
     ((CL:EQ KEY KWD-CLASSES-CL-NATIVE-TYPE)
      (SET-DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CLASSES-CLASS-CL-NATIVE-TYPE
       (WRAP-STRING (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
       NULL-STRING-WRAPPER))
     ((CL:EQ KEY KWD-CLASSES-CPP-NATIVE-TYPE)
      (SET-DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CLASSES-CLASS-CPP-NATIVE-TYPE
       (WRAP-STRING (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
       NULL-STRING-WRAPPER))
     ((CL:EQ KEY KWD-CLASSES-IDL-NATIVE-TYPE)
      (SET-DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CLASSES-CLASS-IDL-NATIVE-TYPE
       (WRAP-STRING (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
       NULL-STRING-WRAPPER))
     ((CL:EQ KEY KWD-CLASSES-JAVA-NATIVE-TYPE)
      (SET-DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CLASSES-CLASS-JAVA-NATIVE-TYPE
       (WRAP-STRING (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
       NULL-STRING-WRAPPER))
     ((CL:EQ KEY KWD-CLASSES-PUBLIC?)
      (CL:SETF
       (CLSYS-SVAL CLASS CLASS-PUBLIC? CLASS)
       (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE)))
     ((CL:EQ KEY KWD-CLASSES-ABSTRACT?)
      (CL:SETF
       (CLSYS-SVAL CLASS ABSTRACT? CLASS)
       (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE)))
     ((CL:EQ KEY KWD-CLASSES-ACTIVE?)
      (SET-DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CLASSES-STORED-ACTIVE?
       (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
       NULL-BOOLEAN-WRAPPER))
     ((CL:EQ KEY KWD-CLASSES-CL-STRUCT?)
      (CL:SETF
       (CLSYS-SVAL CLASS CL-STRUCT? CLASS)
       (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE)))
     ((CL:EQ KEY KWD-CLASSES-MIXIN?)
      (CL:SETF
       (CLSYS-SVAL CLASS MIXIN? CLASS)
       (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
      (CL:WHEN
       (CL:EQ (CLSYS-SVAL CLASS MIXIN? CLASS) 1)
       (CL:SETF (CLSYS-SVAL CLASS ABSTRACT? CLASS) TRUE)))
     ((CL:EQ KEY KWD-CLASSES-RECYCLE-METHOD)
      (SET-DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CLASSES-CLASS-RECYCLE-METHOD
       VALUE
       NULL))
     ((CL:EQ KEY KWD-CLASSES-EXTENSION)
      (SET-DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CLASSES-CLASS-EXTENSION-NAME
       VALUE
       NULL))
     ((CL:EQ KEY KWD-CLASSES-CREATOR)
      (SET-DYNAMIC-SLOT-VALUE CLASS SYM-CLASSES-CLASS-CREATOR VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-INITIALIZER)
      (SET-DYNAMIC-SLOT-VALUE CLASS SYM-CLASSES-CLASS-INITIALIZER VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-TERMINATOR)
      (SET-DYNAMIC-SLOT-VALUE CLASS SYM-CLASSES-CLASS-TERMINATOR VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-DESTRUCTOR)
      (SET-DYNAMIC-SLOT-VALUE CLASS SYM-CLASSES-CLASS-DESTRUCTOR VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-INITIAL-VALUE)
      (SET-DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CLASSES-CLASS-INITIAL-VALUE
       VALUE
       NULL))
     ((CL:EQ KEY KWD-CLASSES-PRINT-FORM)
      (SET-DYNAMIC-SLOT-VALUE CLASS SYM-CLASSES-PRINT-FORM VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-EQUALITY-TEST))
     ((CL:EQ KEY KWD-CLASSES-KEY)
      (SET-DYNAMIC-SLOT-VALUE CLASS SYM-CLASSES-CLASS-KEY (NEW-LIST) NULL)
      (CL:LET*
       ((SLOTNAME NULL)
        (ITER-002 VALUE)
        (INTO-001 (CLASS-KEY CLASS))
        (COLLECT-001 NULL))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-002 NIL))
        DO
        (CL:PROGN
         (CL:SETQ SLOTNAME (CLSYS-SVAL CONS VALUE ITER-002))
         (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
        (CL:IF
         (CL:EQ COLLECT-001 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-001 (PERMANENT-CONS SLOTNAME NIL))
          (CL:IF
           (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST INTO-001) NIL)
           (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST INTO-001) COLLECT-001)
           (ADD-CONS-TO-END-OF-CONS-LIST
            (CLSYS-SVAL LIST THE-CONS-LIST INTO-001)
            COLLECT-001)))
         (CL:PROGN
          (CL:SETF
           (CLSYS-SVAL CONS REST COLLECT-001)
           (PERMANENT-CONS SLOTNAME NIL))
          (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001)))))))
     ((CL:EQ KEY KWD-CLASSES-PARAMETERS)
      (SET-DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CLASSES-CLASS-PARAMETERS
       (NEW-LIST)
       NULL)
      (CL:LET*
       ((SLOT NULL)
        (ITER-003 (CLSYS-SVAL LIST THE-CONS-LIST VALUE))
        (INTO-002 (CLASS-PARAMETERS CLASS))
        (COLLECT-002 NULL))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-003 NIL))
        DO
        (CL:PROGN
         (CL:SETQ SLOT (CLSYS-SVAL CONS VALUE ITER-003))
         (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
        (CL:IF
         (CL:EQ COLLECT-002 NULL)
         (CL:PROGN
          (CL:SETQ
           COLLECT-002
           (PERMANENT-CONS (CLSYS-SVAL SLOT SLOT-NAME SLOT) NIL))
          (CL:IF
           (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST INTO-002) NIL)
           (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST INTO-002) COLLECT-002)
           (ADD-CONS-TO-END-OF-CONS-LIST
            (CLSYS-SVAL LIST THE-CONS-LIST INTO-002)
            COLLECT-002)))
         (CL:PROGN
          (CL:SETF
           (CLSYS-SVAL CONS REST COLLECT-002)
           (PERMANENT-CONS (CLSYS-SVAL SLOT SLOT-NAME SLOT) NIL))
          (CL:SETQ COLLECT-002 (CLSYS-SVAL CONS REST COLLECT-002)))))))
     ((CL:EQ KEY KWD-CLASSES-SYNONYMS)
      (SET-DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CLASSES-CLASS-SYNONYMS
       (NEW-LIST)
       NULL)
      (CL:LET*
       ((TYPE NULL)
        (ITER-004 VALUE)
        (INTO-003 (CLASS-SYNONYMS CLASS))
        (COLLECT-003 NULL))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-004 NIL))
        DO
        (CL:PROGN
         (CL:SETQ TYPE (CLSYS-SVAL CONS VALUE ITER-004))
         (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
        (CL:IF
         (CL:EQ COLLECT-003 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-003 (PERMANENT-CONS TYPE NIL))
          (CL:IF
           (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST INTO-003) NIL)
           (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST INTO-003) COLLECT-003)
           (ADD-CONS-TO-END-OF-CONS-LIST
            (CLSYS-SVAL LIST THE-CONS-LIST INTO-003)
            COLLECT-003)))
         (CL:PROGN
          (CL:SETF
           (CLSYS-SVAL CONS REST COLLECT-003)
           (PERMANENT-CONS TYPE NIL))
          (CL:SETQ COLLECT-003 (CLSYS-SVAL CONS REST COLLECT-003)))))))
     ((CL:EQ KEY KWD-CLASSES-PROPERTIES)
      (SET-DYNAMIC-SLOT-VALUE CLASS SYM-CLASSES-PROPERTIES VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-META-ATTRIBUTES)
      (SET-DYNAMIC-SLOT-VALUE CLASS SYM-CLASSES-META-ATTRIBUTES VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-CHILDREN)
      (CL:SETF (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS CLASS) VALUE)
      (PUSH *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES* CLASS))
     (CL:T
      (CL:WHEN
       (CL:EQ (RUN-OPTION-HANDLER? CLASS KEY VALUE) 0)
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-WARNING)
        (CL:WHEN
         (CL:EQ (SUPPRESS-WARNINGS?) 0)
         (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:WRITE-STRING " Skipping invalid class option `" %%STREAM)
          (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE KEY) %%STREAM)
          (CL:WRITE-STRING "'" %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:WRITE-STRING "in the definition of class `" %%STREAM)
          (PRINT-OBJECT (CLASS-SYMBOL CLASS) %%STREAM)
          (CL:WRITE-STRING "'." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)))))))))
  :VOID)

;;; (DEFUN (INLINE-METHOD? BOOLEAN) ...)

(CL:DEFUN INLINE-METHOD? (SLOT)
  (CL:RETURN-FROM
   INLINE-METHOD?
   (CL:IF
    (CL:AND
     (CL:EQ (CLSYS-SVAL SLOT SLOT-EXTERNAL? SLOT) 0)
     (CL:EQ (ISA? SLOT SGT-CLASSES-METHOD-SLOT) 1)
     (CL:EQ (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? SLOT) 0)
     (CL:EQ
      (STRING-EQL? (CLSYS-SVAL METHOD-SLOT METHOD-STRINGIFIED-SOURCE SLOT) "")
      0))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN TRANSFER-EXTERNAL-SLOT-TO-NEW-CLASS ...)

(CL:DEFUN TRANSFER-EXTERNAL-SLOT-TO-NEW-CLASS (EXTERNALSLOT NEWCLASS)
  (CL:LET*
   ((NEWCLASSSLOT
     (LOOKUP-LOCAL-SLOT NEWCLASS (CLSYS-SVAL SLOT SLOT-NAME EXTERNALSLOT))))
   (CL:COND
    ((CL:EQ NEWCLASSSLOT NULL)
     (INSERT (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS NEWCLASS) EXTERNALSLOT))
    ((CL:OR
      (CL:EQ (INLINE-METHOD? NEWCLASSSLOT) 1)
      (CL:NOT (CL:EQ (PRIMARY-TYPE NEWCLASSSLOT) (PRIMARY-TYPE EXTERNALSLOT)))
      (CL:EQ FALSE 1)))
    (CL:T
     (SUBSTITUTE
      (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS NEWCLASS)
      EXTERNALSLOT
      NEWCLASSSLOT)
     (FREE NEWCLASSSLOT))))
  :VOID)

;;; (DEFUN TRANSFER-DEMONS-FROM-OLDCLASS ...)

(CL:DEFUN TRANSFER-DEMONS-FROM-OLDCLASS (OLDCLASS NEWCLASS)
  (CL:LET*
   ((NEWSLOT NULL))
   (CL:LET*
    ((OLDSLOT NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS OLDCLASS))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ OLDSLOT (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:LET*
      ()
      (CL:SETQ
       NEWSLOT
       (LOOKUP-LOCAL-SLOT NEWCLASS (CLSYS-SVAL SLOT SLOT-NAME OLDSLOT)))
      (CL:WHEN
       (CL:NOT (CL:EQ NEWSLOT NULL))
       (CL:LET*
        ((OLDSLOT-001 OLDSLOT))
        (CL:COND
         ((CL:EQ (STORAGE-SLOT? OLDSLOT) 1)
          (CL:LET*
           ((OLDSLOT NULL))
           (CL:SETQ OLDSLOT OLDSLOT-001)
           (CL:LET*
            ((NEWSLOT-001 NEWSLOT))
            (CL:COND
             ((CL:EQ (STORAGE-SLOT? NEWSLOT) 1)
              (CL:LET*
               ((NEWSLOT NULL))
               (CL:SETQ NEWSLOT NEWSLOT-001)
               (SET-DYNAMIC-SLOT-VALUE
                NEWSLOT
                SYM-CLASSES-SLOT-GUARD-DEMONS
                (SLOT-GUARD-DEMONS OLDSLOT)
                NULL)
               (SET-DYNAMIC-SLOT-VALUE
                OLDSLOT
                SYM-CLASSES-SLOT-GUARD-DEMONS
                NULL
                NULL)
               (SET-DYNAMIC-SLOT-VALUE
                NEWSLOT
                SYM-CLASSES-SLOT-DEMONS
                (SLOT-DEMONS OLDSLOT)
                NULL)
               (SET-DYNAMIC-SLOT-VALUE
                OLDSLOT
                SYM-CLASSES-SLOT-DEMONS
                NULL
                NULL)))
             (CL:T NULL)))))
         (CL:T NULL))))))))
  (SET-DYNAMIC-SLOT-VALUE
   NEWCLASS
   SYM-CLASSES-CLASS-CONSTRUCTOR-DEMONS
   (CLASS-CONSTRUCTOR-DEMONS OLDCLASS)
   NULL)
  (SET-DYNAMIC-SLOT-VALUE
   OLDCLASS
   SYM-CLASSES-CLASS-CONSTRUCTOR-DEMONS
   NULL
   NULL)
  (SET-DYNAMIC-SLOT-VALUE
   NEWCLASS
   SYM-CLASSES-CLASS-GUARD-CONSTRUCTOR-DEMONS
   (CLASS-GUARD-CONSTRUCTOR-DEMONS OLDCLASS)
   NULL)
  (SET-DYNAMIC-SLOT-VALUE
   OLDCLASS
   SYM-CLASSES-CLASS-GUARD-CONSTRUCTOR-DEMONS
   NULL
   NULL)
  (SET-DYNAMIC-SLOT-VALUE
   NEWCLASS
   SYM-CLASSES-CLASS-DESTRUCTOR-DEMONS
   (CLASS-DESTRUCTOR-DEMONS OLDCLASS)
   NULL)
  (SET-DYNAMIC-SLOT-VALUE
   OLDCLASS
   SYM-CLASSES-CLASS-DESTRUCTOR-DEMONS
   NULL
   NULL)
  (SET-DYNAMIC-SLOT-VALUE
   NEWCLASS
   SYM-CLASSES-CLASS-GUARD-DESTRUCTOR-DEMONS
   (CLASS-GUARD-DESTRUCTOR-DEMONS OLDCLASS)
   NULL)
  (SET-DYNAMIC-SLOT-VALUE
   OLDCLASS
   SYM-CLASSES-CLASS-GUARD-DESTRUCTOR-DEMONS
   NULL
   NULL)
  :VOID)

;;; (DEFUN UNDEFINE-OLD-CLASS ...)

(CL:DEFUN UNDEFINE-OLD-CLASS (OLDCLASS NEWCLASS)
  (CL:LET*
   ((NEWSUBS
     (COPY-CONS-LIST
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS NEWCLASS)))))
   (UNFINALIZE-CLASS-AND-SUBCLASSES OLDCLASS)
   (FORGET-UNFINALIZED-CLASS OLDCLASS)
   (CL:LET*
    ((OLDSUB NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS OLDCLASS)))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ OLDSUB (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (CONS OLDSUB NIL))
       (CL:IF
        (CL:EQ NEWSUBS NIL)
        (CL:SETQ NEWSUBS COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST NEWSUBS COLLECT-001)))
      (CL:PROGN
       (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS OLDSUB NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CLEAR (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS NEWCLASS))
   (CL:SETF
    (CLSYS-SVAL
     LIST
     THE-CONS-LIST
     (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS NEWCLASS))
    (REMOVE-DUPLICATES NEWSUBS))
   (CLEAR (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS OLDCLASS)))
  (CL:LET*
   ((OLDSLOT NULL)
    (ITER-002
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS OLDCLASS))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-002 NIL))
    DO
    (CL:PROGN
     (CL:SETQ OLDSLOT (CLSYS-SVAL CONS VALUE ITER-002))
     (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL SLOT SLOT-EXTERNAL? OLDSLOT) 1)
     (TRANSFER-EXTERNAL-SLOT-TO-NEW-CLASS OLDSLOT NEWCLASS))))
  (CL:SETF
   (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE NEWCLASS)
   (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE OLDCLASS))
  (TRANSFER-DEMONS-FROM-OLDCLASS OLDCLASS NEWCLASS)
  (RUN-HOOKS *REDEFINE-RELATION-HOOKS* (LIST OLDCLASS NEWCLASS))
  (FREE OLDCLASS)
  :VOID)

;;; (DEFMETHOD DESTROY-CLASS ...)

(CL:DEFMETHOD DESTROY-CLASS ((SELF CLASS))
  "Destroy the Stella class 'self'.  
Unfinalize its subclasses (if it has any)."
  (CL:WHEN (CL:EQ (DELETED? SELF) 1) (CL:RETURN-FROM DESTROY-CLASS))
  (CL:WHEN
   (CL:EQ
    (CLSYS-SVAL SURROGATE HOME-CONTEXT (CLSYS-SVAL CLASS CLASS-TYPE SELF))
    *STELLA-MODULE*)
   (CL:WARN "Can't delete STELLA class `~A'." (CLASS-NAME SELF))
   (CL:RETURN-FROM DESTROY-CLASS))
  (DELETED?-SETTER SELF TRUE)
  (UNFINALIZE-CLASS-AND-SUBCLASSES SELF)
  (UNBIND-FROM-SURROGATE SELF)
  (FINALIZE-CLASSES-AND-SLOTS)
  (FREE SELF)
  :VOID)

;;; (DEFMETHOD DESTROY-CLASS ...)

(CL:DEFMETHOD DESTROY-CLASS ((SELF SURROGATE))
  (CL:LET*
   ((CLASS (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)))
   (CL:IF
    (CL:EQ CLASS NULL)
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "Can't destroy non-existent class `" %%STREAM)
     (PRINT-OBJECT SELF %%STREAM)
     (CL:WRITE-STRING "'." %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (DESTROY-CLASS CLASS)))
  :VOID)

;;; (DEFUN DESTROY-CLASS-AND-SUBCLASSES ...)

(CL:DEFUN DESTROY-CLASS-AND-SUBCLASSES (SELF)
  "Destroy the Stella class 'self' and all its subclasses."
  (CL:LET*
   ((SUBTYPE NULL)
    (ITER-001
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS SELF))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ SUBTYPE (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUBTYPE) NULL))
     (DESTROY-CLASS-AND-SUBCLASSES
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUBTYPE)))))
  (DESTROY-CLASS SELF)
  :VOID)

;;; (DEFMETHOD (PRIMITIVE? BOOLEAN) ...)

(CL:DEFMETHOD PRIMITIVE? ((SELF RELATION))
  "Return TRUE if 'self' is not a defined relation."
  (CL:RETURN-FROM PRIMITIVE? TRUE)
  :VOID)

;;; (DEFUN INSERT-PRIMITIVE-SUPER ...)

(CL:DEFUN INSERT-PRIMITIVE-SUPER (NEWSUPER SUPERS)
  (CL:LET*
   ((FOUND?-001 FALSE))
   (CL:LET*
    ((SUP NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST SUPERS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUP (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:EQ (SUBTYPE-OF? NEWSUPER SUP) 1)
      (CL:SETQ FOUND?-001 TRUE)
      (CL:RETURN))))
   (CL:WHEN
    (CL:EQ FOUND?-001 0)
    (CL:LET*
     ((SUBSUMEDSUPER NULL))
     (CL:LOOP
      (CL:LET*
       ()
       (CL:LET*
        ((VALUE-001 NULL))
        (CL:LET*
         ((SUP NULL) (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST SUPERS)))
         (CL:LOOP
          WHILE
          (CL:NOT (CL:EQ ITER-002 NIL))
          DO
          (CL:PROGN
           (CL:SETQ SUP (CLSYS-SVAL CONS VALUE ITER-002))
           (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
          (CL:WHEN
           (CL:EQ (SUBTYPE-OF? SUP NEWSUPER) 1)
           (CL:SETQ VALUE-001 SUP)
           (CL:RETURN))))
        (CL:SETQ SUBSUMEDSUPER VALUE-001))
       (CL:WHEN (CL:EQ SUBSUMEDSUPER NULL) (CL:RETURN)))
      (CL:SETQ SUPERS (REMOVE SUPERS SUBSUMEDSUPER)))
     (INSERT SUPERS NEWSUPER))))
  :VOID)

;;; (DEFUN COLLECT-MOST-SPECIFIC-PRIMITIVE-SUPERS ...)

(CL:DEFUN COLLECT-MOST-SPECIFIC-PRIMITIVE-SUPERS (CLASS SUPERS)
  (CL:LET*
   ((SUPER NULL)
    (ITER-001
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ SUPER (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:IF
     (CL:EQ (PRIMITIVE? (TYPE-TO-CLASS SUPER)) 1)
     (INSERT-PRIMITIVE-SUPER SUPER SUPERS)
     (COLLECT-MOST-SPECIFIC-PRIMITIVE-SUPERS (TYPE-TO-CLASS SUPER) SUPERS))))
  :VOID)

;;; (DEFUN (MOST-SPECIFIC-PRIMITIVE-SUPERS (LIST OF TYPE)) ...)

(CL:DEFUN MOST-SPECIFIC-PRIMITIVE-SUPERS (CLASS)
  (CL:LET*
   ((SUPERS (NEW-LIST)))
   (COLLECT-MOST-SPECIFIC-PRIMITIVE-SUPERS CLASS SUPERS)
   (CL:RETURN-FROM MOST-SPECIFIC-PRIMITIVE-SUPERS (REVERSE SUPERS)))
  :VOID)

;;; (DEFUN (CLASS-NATIVE-SUPERS (ITERATOR OF TYPE)) ...)

(CL:DEFUN CLASS-NATIVE-SUPERS (CLASS)
  (CL:LET*
   ((ALWAYS?-001 TRUE))
   (CL:LET*
    ((SUPER NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUPER (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:EQ (PRIMITIVE? (TYPE-TO-CLASS SUPER)) 0)
      (CL:SETQ ALWAYS?-001 FALSE)
      (CL:RETURN))))
   (CL:IF
    (CL:EQ ALWAYS?-001 1)
    (CL:RETURN-FROM
     CLASS-NATIVE-SUPERS
     (ALLOCATE-ITERATOR (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS)))
    (CL:RETURN-FROM
     CLASS-NATIVE-SUPERS
     (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR
      (MOST-SPECIFIC-PRIMITIVE-SUPERS CLASS)))))
  :VOID)

;;; (DEFGLOBAL *UNFINALIZED-CLASSES* ...)

(CL:DEFVAR *UNFINALIZED-CLASSES* NULL
  "List of classes whose class or slot inheritance is
currently unfinalized.")

;;; (DEFGLOBAL *NEWLY-UNFINALIZED-CLASSES?* ...)

(CL:DEFVAR *NEWLY-UNFINALIZED-CLASSES?* FALSE
  "Set to TRUE by 'remember-unfinalized-class'; set
to FALSE by 'cleanup-unfinalized-classes'.  Minimizes the time that
'finalize-classes' spends searching for classes to finalize.")

;;; (DEFGLOBAL *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES* ...)

(CL:DEFVAR *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES* NULL
  "List of classes defined with a :children option
which still have some of their children references unresolved.")

;;; (DEFUN REMEMBER-UNFINALIZED-CLASS ...)

(CL:DEFUN REMEMBER-UNFINALIZED-CLASS (CLASS FORCE?)
  (CL:WHEN
   (CL:OR
    (CL:EQ FORCE? 1)
    (CL:AND
     (CL:EQ (CLSYS-SVAL CLASS CLASS-FINALIZED? CLASS) 1)
     (CL:EQ (CLSYS-SVAL CLASS CLASS-SLOTS-FINALIZED? CLASS) 1)))
   (PUSH *UNFINALIZED-CLASSES* CLASS)
   (CL:SETQ *NEWLY-UNFINALIZED-CLASSES?* TRUE))
  :VOID)

;;; (DEFUN FORGET-UNFINALIZED-CLASS ...)

(CL:DEFUN FORGET-UNFINALIZED-CLASS (CLASS)
  (CL:WHEN
   (CL:NOT
    (CL:AND
     (CL:EQ (CLSYS-SVAL CLASS CLASS-FINALIZED? CLASS) 1)
     (CL:EQ (CLSYS-SVAL CLASS CLASS-SLOTS-FINALIZED? CLASS) 1)))
   (REMOVE *UNFINALIZED-CLASSES* CLASS))
  :VOID)

;;; (DEFUN FINALIZE-CLASSES ...)

(CL:DEFUN FINALIZE-CLASSES ()
  "Finalize all currently unfinalized classes."
  (CL:WHEN
   (CL:EQ *NEWLY-UNFINALIZED-CLASSES?* 0)
   (CL:RETURN-FROM FINALIZE-CLASSES))
  (CL:LET*
   ((HIERARCHYMIGHTHAVECHANGED? FALSE))
   (REMOVE-DELETED-MEMBERS *UNFINALIZED-CLASSES*)
   (RESOLVE-CHILDREN-REFERENCES)
   (CL:LET*
    ((CLASS NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST *UNFINALIZED-CLASSES*)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ CLASS (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:EQ (CLSYS-SVAL CLASS CLASS-FINALIZED? CLASS) 0)
      (FINALIZE-CLASS CLASS)
      (CL:SETQ HIERARCHYMIGHTHAVECHANGED? TRUE))))
   (CL:WHEN (CL:EQ HIERARCHYMIGHTHAVECHANGED? 1) (CREATE-CLASS-TAXONOMY)))
  :VOID)

;;; (DEFUN RESOLVE-CHILDREN-REFERENCES ...)

(CL:DEFUN RESOLVE-CHILDREN-REFERENCES ()
  (CL:WHEN
   (CL:OR
    (CL:EQ (EMPTY? *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES*) 1)
    (CL:EQ (EMPTY? *UNFINALIZED-CLASSES*) 1))
   (CL:RETURN-FROM RESOLVE-CHILDREN-REFERENCES))
  (CL:LET*
   ((UNRESOLVABLECLASSES NIL))
   (REMOVE-DELETED-MEMBERS *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES*)
   (CL:LET*
    ((CLASS NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES*)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ CLASS (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (ADD-DIRECT-SUBS-BACK-LINKS CLASS)
     (CL:LET*
      ((FOUND?-001 FALSE))
      (CL:LET*
       ((SUB NULL)
        (ITER-002
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS CLASS))))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-002 NIL))
        DO
        (CL:PROGN
         (CL:SETQ SUB (CLSYS-SVAL CONS VALUE ITER-002))
         (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
        (CL:WHEN
         (CL:EQ (TYPE-TO-CLASS SUB) NULL)
         (CL:SETQ FOUND?-001 TRUE)
         (CL:RETURN))))
      (CL:WHEN
       (CL:EQ FOUND?-001 1)
       (CL:SETQ UNRESOLVABLECLASSES (CONS CLASS UNRESOLVABLECLASSES))))))
   (CLEAR *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES*)
   (CL:SETF
    (CLSYS-SVAL
     LIST
     THE-CONS-LIST
     *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES*)
    UNRESOLVABLECLASSES))
  :VOID)

;;; (DEFUN FINALIZE-SLOTS ...)

(CL:DEFUN FINALIZE-SLOTS ()
  "Finalize all currently unfinalized slots."
  (CL:WHEN
   (CL:EQ *NEWLY-UNFINALIZED-CLASSES?* 0)
   (CL:RETURN-FROM FINALIZE-SLOTS))
  (CL:LET*
   ((CLASS NULL)
    (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST *UNFINALIZED-CLASSES*)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ CLASS (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:AND
      (CL:EQ (CLSYS-SVAL CLASS CLASS-FINALIZED? CLASS) 1)
      (CL:EQ (CLSYS-SVAL CLASS CLASS-SLOTS-FINALIZED? CLASS) 0))
     (FINALIZE-CLASS-SLOTS CLASS))))
  :VOID)

;;; (DEFUN CLEANUP-UNFINALIZED-CLASSES ...)

(CL:DEFUN CLEANUP-UNFINALIZED-CLASSES ()
  "Remove all finalized classes from '*unfinalized-classes*',
and set '*newly-unfinalized-classes?*' to FALSE."
  (CL:LET*
   ((UNFINALIZEDCLASSES NIL))
   (CL:LET*
    ((CLASS NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST *UNFINALIZED-CLASSES*))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ CLASS (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:OR
       (CL:EQ (CLSYS-SVAL CLASS CLASS-FINALIZED? CLASS) 0)
       (CL:EQ (CLSYS-SVAL CLASS CLASS-SLOTS-FINALIZED? CLASS) 0))
      (CL:IF
       (CL:EQ COLLECT-001 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-001 (CONS CLASS NIL))
        (CL:IF
         (CL:EQ UNFINALIZEDCLASSES NIL)
         (CL:SETQ UNFINALIZEDCLASSES COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST UNFINALIZEDCLASSES COLLECT-001)))
       (CL:PROGN
        (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS CLASS NIL))
        (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001)))))))
   (CLEAR *UNFINALIZED-CLASSES*)
   (CL:SETF
    (CLSYS-SVAL LIST THE-CONS-LIST *UNFINALIZED-CLASSES*)
    UNFINALIZEDCLASSES)
   (CL:SETQ *NEWLY-UNFINALIZED-CLASSES?* FALSE))
  :VOID)

;;; (DEFUN FINALIZE-CLASSES-AND-SLOTS ...)

(CL:DEFUN FINALIZE-CLASSES-AND-SLOTS ()
  "Finalize all currently unfinalized classes and slots."
  (FINALIZE-CLASSES)
  (FINALIZE-SLOTS)
  (CLEANUP-UNFINALIZED-CLASSES)
  :VOID)

;;; (DEFUN ACTIVATE-CLASS ...)

(CL:DEFUN ACTIVATE-CLASS (CLASS)
  (CL:LET*
   ((ACTIVEOBJECTCLASS (TYPE-TO-CLASS SGT-CLASSES-ACTIVE-OBJECT))
    (SUPERS (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS)))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ ACTIVEOBJECTCLASS NULL))
     (CL:EQ (SUBCLASS-OF? CLASS ACTIVEOBJECTCLASS) 1))
    (CL:RETURN-FROM ACTIVATE-CLASS))
   (CL:COND
    ((CL:= (LENGTH SUPERS) 0) (INSERT SUPERS SGT-CLASSES-ACTIVE-OBJECT))
    ((CL:AND
      (CL:= (LENGTH SUPERS) 1)
      (CL:OR
       (CL:EQ (FIRST SUPERS) SGT-CLASSES-OBJECT)
       (CL:EQ (FIRST SUPERS) SGT-CLASSES-STANDARD-OBJECT)))
     (REMOVE-DIRECT-SUPERS-BACK-LINKS CLASS)
     (CLEAR SUPERS)
     (INSERT SUPERS SGT-CLASSES-ACTIVE-OBJECT))
    (CL:T
     (SET-DYNAMIC-SLOT-VALUE
      CLASS
      SYM-CLASSES-STORED-ACTIVE?
      (WRAP-BOOLEAN FALSE)
      NULL-BOOLEAN-WRAPPER)
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE CLASS SYM-CLASSES-CLASS-EXTENSION-NAME NULL)
        NULL))
      (SET-DYNAMIC-SLOT-VALUE
       CLASS
       SYM-CLASSES-CLASS-EXTENSION-NAME
       NULL
       NULL))
     (CL:WARN
      "Cannot convert `~A' into an ACTIVE-OBJECT.~%You have to modify its superclasses by hand."
      CLASS)
     (CL:RETURN-FROM ACTIVATE-CLASS)))
   (ADD-DIRECT-SUPERS-BACK-LINKS CLASS)
   (INHERIT-SUPERCLASSES CLASS))
  :VOID)

;;; (DEFUN ADD-PRIMARY-TYPE ...)

(CL:DEFUN ADD-PRIMARY-TYPE (CLASS)
  (CL:LET*
   ((CLASSTYPE (CLSYS-SVAL CLASS CLASS-TYPE CLASS)) (SLOTTREE NULL))
   (CL:LET*
    ((TEST-VALUE-001 FALSE))
    (CL:SETQ
     TEST-VALUE-001
     (CL:IF (CL:EQ (CLSYS-SVAL CLASS ABSTRACT? CLASS) 0) TRUE FALSE))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:SETQ TEST-VALUE-001 (SUBTYPE-OF? CLASSTYPE SGT-CLASSES-OBJECT))
     (CL:WHEN
      (CL:EQ TEST-VALUE-001 1)
      (CL:LET*
       ((FOUND?-001 FALSE))
       (CL:LET*
        ((SLOT NULL)
         (ITER-001
          (CLSYS-SVAL
           LIST
           THE-CONS-LIST
           (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS CLASS))))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-001 NIL))
         DO
         (CL:PROGN
          (CL:SETQ SLOT (CLSYS-SVAL CONS VALUE ITER-001))
          (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
         (CL:WHEN
          (CL:EQ (CLSYS-SVAL SLOT SLOT-NAME SLOT) SYM-CLASSES-PRIMARY-TYPE)
          (CL:SETQ FOUND?-001 TRUE)
          (CL:RETURN))))
       (CL:SETQ TEST-VALUE-001 FOUND?-001))
      (CL:SETQ TEST-VALUE-001 (CL:IF (CL:EQ TEST-VALUE-001 0) TRUE FALSE))))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:LET*
      ((*TRANSIENTOBJECTS?* TRUE))
      (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
      (CL:SETQ
       SLOTTREE
       (LIST*
        (CONS (LIST* SYM-CLASSES-SELF (TYPE-TO-SYMBOL CLASSTYPE) NIL) NIL)
        KWD-CLASSES-TYPE
        SYM-CLASSES-TYPE
        KWD-CLASSES-AUXILIARY?
        SYM-CLASSES-TRUE
        (LIST* SYM-CLASSES-RETURN CLASSTYPE NIL)
        NIL)))
     (PUSH
      (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS CLASS)
      (DEFINE-INLINE-METHOD SYM-CLASSES-PRIMARY-TYPE SLOTTREE)))))
  :VOID)

;;; (DEFUN FINALIZE-ONE-CLASS ...)

(CL:DEFUN FINALIZE-ONE-CLASS (CLASS)
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE CLASS SYM-CLASSES-CLASS-EXTENSION-NAME NULL)
     NULL))
   (SET-DYNAMIC-SLOT-VALUE
    CLASS
    SYM-CLASSES-STORED-ACTIVE?
    (WRAP-BOOLEAN TRUE)
    NULL-BOOLEAN-WRAPPER))
  (ADD-DIRECT-SUPERS-BACK-LINKS CLASS)
  (INHERIT-SUPERCLASSES CLASS)
  (CL:WHEN
   (CL:AND
    (CL:EQ (DEFINED? (STORED-ACTIVE? CLASS)) 1)
    (CL:EQ (STORED-ACTIVE? CLASS) 1))
   (ACTIVATE-CLASS CLASS))
  (ADD-PRIMARY-TYPE CLASS)
  (CL:LET*
   ((ALIAS NULL)
    (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST (CLASS-SYNONYMS CLASS))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ ALIAS (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:IF
     (CL:AND
      (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE ALIAS) NULL))
      (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE ALIAS) CLASS))
      (CL:EQ
       (STRING-EQL?
        (CLASS-NAME (CLSYS-SVAL SURROGATE SURROGATE-VALUE ALIAS))
        (CLASS-NAME CLASS))
       0))
     (CL:WARN
      "Alias `~A' can't point to `~A' because it already points to ~%the class `~A'."
      (TYPE-TO-SYMBOL ALIAS)
      (CLASS-SYMBOL CLASS)
      (CLASS-SYMBOL (CLSYS-SVAL SURROGATE SURROGATE-VALUE ALIAS)))
     (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE ALIAS) CLASS))))
  (CL:WHEN
   (CL:AND
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE CLASS SYM-CLASSES-CLASS-EXTENSION-NAME NULL)
      NULL))
    (CL:EQ (DYNAMIC-SLOT-VALUE CLASS SYM-CLASSES-CLASS-EXTENSION NULL) NULL))
   (SET-DYNAMIC-SLOT-VALUE
    CLASS
    SYM-CLASSES-CLASS-EXTENSION
    (NEW-CLASS-EXTENSION)
    NULL))
  (CL:SETF (CLSYS-SVAL CLASS CLASS-FINALIZED? CLASS) TRUE)
  :VOID)

;;; (DEFUN (FINALIZE-CLASS BOOLEAN) ...)

(CL:DEFUN FINALIZE-CLASS (CLASS)
  (CL:RETURN-FROM FINALIZE-CLASS (HELP-FINALIZE-CLASS CLASS NULL))
  :VOID)

;;; (DEFUN (HELP-FINALIZE-CLASS BOOLEAN) ...)

(CL:DEFUN HELP-FINALIZE-CLASS (CLASS FINALIZEDPARENT)
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL CLASS CLASS-FINALIZED? CLASS) 1)
   (CL:RETURN-FROM HELP-FINALIZE-CLASS TRUE))
  (CL:LET*
   ((SUPER NULL)
    (ITER-001
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ SUPER (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:NOT (CL:EQ SUPER FINALIZEDPARENT))
     (CL:LET*
      ((SUPERCLASS (TYPE-TO-CLASS SUPER)))
      (CL:IF
       (CL:NOT (CL:EQ SUPERCLASS NULL))
       (CL:WHEN
        (CL:EQ (HELP-FINALIZE-CLASS SUPERCLASS NULL) 0)
        (CL:RETURN-FROM HELP-FINALIZE-CLASS FALSE))
       (CL:RETURN-FROM HELP-FINALIZE-CLASS FALSE))))))
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL CLASS CLASS-FINALIZED? CLASS) 0)
   (FINALIZE-ONE-CLASS CLASS)
   (CL:LET*
    ((SUB NULL)
     (ITER-002
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS CLASS))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUB (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:LET*
      ((SUBCLASS (TYPE-TO-CLASS SUB)))
      (CL:WHEN
       (CL:NOT (CL:EQ SUBCLASS NULL))
       (HELP-FINALIZE-CLASS SUBCLASS (CLSYS-SVAL CLASS CLASS-TYPE CLASS))))))
   (CL:RETURN-FROM HELP-FINALIZE-CLASS TRUE))
  :VOID)

;;; (DEFUN UNFINALIZE-CLASS-AND-SUBCLASSES ...)

(CL:DEFUN UNFINALIZE-CLASS-AND-SUBCLASSES (CLASS)
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL CLASS CLASS-FINALIZED? CLASS) 0)
   (CL:RETURN-FROM UNFINALIZE-CLASS-AND-SUBCLASSES))
  (REMOVE-DIRECT-SUPERS-BACK-LINKS CLASS)
  (CL:LET*
   ((SUBS (COPY (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS CLASS))))
   (CL:LET*
    ((SUBTYPE NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST SUBS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUBTYPE (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUBTYPE) NULL))
      (UNFINALIZE-CLASS-AND-SUBCLASSES
       (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUBTYPE)))))
   (FREE SUBS))
  (CL:LET*
   ((ALIAS NULL)
    (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST (CLASS-SYNONYMS CLASS))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-002 NIL))
    DO
    (CL:PROGN
     (CL:SETQ ALIAS (CLSYS-SVAL CONS VALUE ITER-002))
     (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE ALIAS) CLASS)
     (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE ALIAS) NULL))))
  (UNINHERIT-SUPERCLASSES CLASS)
  (UNFINALIZE-CLASS-SLOTS CLASS)
  (REMEMBER-UNFINALIZED-CLASS CLASS FALSE)
  (CL:SETF (CLSYS-SVAL CLASS CLASS-FINALIZED? CLASS) FALSE)
  :VOID)

;;; (DEFUN (ATTACH-SLOT-TO-OWNER SLOT) ...)

(CL:DEFUN ATTACH-SLOT-TO-OWNER (NEWSLOT)
  (CL:LET*
   ((NAME (CLSYS-SVAL SLOT SLOT-NAME NEWSLOT))
    (OWNERCLASS
     (CLSYS-SVAL
      SURROGATE
      SURROGATE-VALUE
      (CLSYS-SVAL SLOT SLOT-OWNER NEWSLOT)))
    (OLDSLOT (LOOKUP-LOCAL-SLOT OWNERCLASS NAME)))
   (CL:SETF (CLSYS-SVAL SLOT SLOT-EXTERNAL? NEWSLOT) TRUE)
   (REGISTER-SLOT-NAME NEWSLOT)
   (CL:COND
    ((CL:EQ OLDSLOT NULL)
     (INSERT (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS OWNERCLASS) NEWSLOT)
     (UNFINALIZE-CLASS-SLOTS OWNERCLASS)
     (CL:RETURN-FROM ATTACH-SLOT-TO-OWNER NEWSLOT))
    ((CL:EQ (LOCAL-SLOT? OLDSLOT OWNERCLASS) 0)
     (INSERT (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS OWNERCLASS) NEWSLOT)
     (UNFINALIZE-CLASS-SLOTS OWNERCLASS)
     (CL:RETURN-FROM ATTACH-SLOT-TO-OWNER NEWSLOT))
    ((CL:NOT (CL:EQ (PRIMARY-TYPE NEWSLOT) (PRIMARY-TYPE OLDSLOT)))
     (CL:WARN
      "Can't define a `~A' named `~A' on the class `~A'~%because it already has a `~A' with the same name."
      (PRIMARY-TYPE NEWSLOT)
      NAME
      (CLASS-NAME OWNERCLASS)
      (PRIMARY-TYPE OLDSLOT))
     (CL:RETURN-FROM ATTACH-SLOT-TO-OWNER NULL))
    (CL:T
     (SUBSTITUTE
      (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS OWNERCLASS)
      NEWSLOT
      OLDSLOT)
     (RUN-HOOKS *REDEFINE-RELATION-HOOKS* (LIST OLDSLOT NEWSLOT))
     (FREE OLDSLOT)
     (HELP-UNFINALIZE-CLASS-SLOTS OWNERCLASS)
     (CL:RETURN-FROM ATTACH-SLOT-TO-OWNER NEWSLOT))))
  :VOID)

;;; (DEFUN COMPUTE-SLOT-DIRECT-EQUIVALENT ...)

(CL:DEFUN COMPUTE-SLOT-DIRECT-EQUIVALENT (SELF)
  (CL:LET*
   ((CLASS
     (CLSYS-SVAL SURROGATE SURROGATE-VALUE (CLSYS-SVAL SLOT SLOT-OWNER SELF)))
    (SLOTNAME (CLSYS-SVAL SLOT SLOT-NAME SELF))
    (SLOTRENAMES (DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-RENAMES NULL))
    (RENAMESSLOT NULL))
   (CL:COND
    ((CL:NOT (CL:EQ SLOTRENAMES NULL))
     (CL:LET*
      ((VALUE-001 NULL))
      (CL:LET*
       ((S NULL) (ITER-001 (CLASS-SLOTS CLASS)))
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? ITER-001) 1)
        DO
        (CL:PROGN (CL:SETQ S (CLSYS-SVAL ITERATOR VALUE ITER-001)))
        (CL:WHEN
         (CL:EQ (CLSYS-SVAL SLOT SLOT-NAME S) SLOTRENAMES)
         (CL:SETQ VALUE-001 S)
         (CL:RETURN))))
      (CL:SETQ RENAMESSLOT VALUE-001))
     (CL:COND
      ((CL:NOT (CL:EQ RENAMESSLOT NULL))
       (CL:SETF (CLSYS-SVAL SLOT SLOT-DIRECT-EQUIVALENT SELF) RENAMESSLOT)
       (CL:SETF (CLSYS-SVAL SLOT SLOT-RENAMED? RENAMESSLOT) TRUE))
      (CL:T
       (CL:WARN
        "Slot `~A' renames a non-existent self: `~A'.~%Cancelling the renames option."
        SLOTNAME
        SLOTRENAMES)
       (SET-DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-RENAMES NULL NULL))))
    (CL:T
     (CL:LET*
      ((VALUE-002 NULL))
      (CL:LET*
       ((S NULL) (ITER-002 (CLASS-SLOTS CLASS)))
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? ITER-002) 1)
        DO
        (CL:PROGN (CL:SETQ S (CLSYS-SVAL ITERATOR VALUE ITER-002)))
        (CL:WHEN
         (CL:AND
          (CL:NOT (CL:EQ S SELF))
          (CL:EQ (CLSYS-SVAL SLOT SLOT-NAME S) SLOTNAME))
         (CL:SETQ VALUE-002 S)
         (CL:RETURN))))
      (CL:SETF (CLSYS-SVAL SLOT SLOT-DIRECT-EQUIVALENT SELF) VALUE-002)))))
  :VOID)

;;; (DEFUN CHECK-CONFORMANCE-OF-SLOT-SIGNATURE ...)

(CL:DEFUN CHECK-CONFORMANCE-OF-SLOT-SIGNATURE (SELF)
  (CL:LET*
   ((EQUIVALENTSLOT (CLSYS-SVAL SLOT SLOT-DIRECT-EQUIVALENT SELF)))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ EQUIVALENTSLOT NULL))
     (CL:EQ (CONFORMING-SIGNATURES? SELF EQUIVALENTSLOT) 0))
    (CL:WARN
     "The signature of slot `~A' does not conform to the~%   signature of the inherited slot `~A'"
     SELF
     EQUIVALENTSLOT)))
  :VOID)

;;; (DEFUN (COLLECTION-TO-ACTIVE-COLLECTION TYPE) ...)

(CL:DEFUN COLLECTION-TO-ACTIVE-COLLECTION (TYPE)
  (CL:COND
   ((CL:OR (CL:EQ TYPE SGT-CLASSES-SET) (CL:EQ TYPE SGT-CLASSES-ACTIVE-SET))
    (CL:RETURN-FROM COLLECTION-TO-ACTIVE-COLLECTION SGT-CLASSES-ACTIVE-SET))
   ((CL:OR (CL:EQ TYPE SGT-CLASSES-LIST) (CL:EQ TYPE SGT-CLASSES-ACTIVE-LIST))
    (CL:RETURN-FROM COLLECTION-TO-ACTIVE-COLLECTION SGT-CLASSES-ACTIVE-LIST))
   (CL:T (CL:RETURN-FROM COLLECTION-TO-ACTIVE-COLLECTION NULL)))
  :VOID)

;;; (DEFUN ACTIVATE-SLOT ...)

(CL:DEFUN ACTIVATE-SLOT (SELF)
  (CL:WHEN
   (CL:EQ (SINGLE-VALUED? SELF) 0)
   (CL:LET*
    ((ACTIVECOLLECTION
      (COLLECTION-TO-ACTIVE-COLLECTION
       (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SELF))))
    (CL:WHEN
     (CL:EQ ACTIVECOLLECTION NULL)
     (CL:WARN
      "No active collection defined for `~A'.~%   Cannot activate slot `~A'."
      (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SELF)
      SELF)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-CLASSES-STORED-ACTIVE?
      (WRAP-BOOLEAN FALSE)
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM ACTIVATE-SLOT))
    (CL:SETF
     (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SELF)
     (COLLECTION-TO-ACTIVE-COLLECTION
      (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SELF)))))
  (SET-DYNAMIC-SLOT-VALUE
   SELF
   SYM-CLASSES-STORED-ACTIVE?
   (WRAP-BOOLEAN TRUE)
   NULL-BOOLEAN-WRAPPER)
  :VOID)

;;; (DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ...)

(CL:DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ((SELF SLOT))
  NULL
  :VOID)

;;; (DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ...)

(CL:DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ((SELF STORAGE-SLOT))
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-TYPE-SPECIFIER NULL)
     NULL))
   (CL:SETF
    (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SELF)
    (VALIDATE-TYPE-SPECIFIER
     (DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-TYPE-SPECIFIER NULL)
     (CLSYS-SVAL
      SURROGATE
      SURROGATE-VALUE
      (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SELF))
     FALSE)))
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SELF) NULL)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SELF) (TYPE SELF)))
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SELF) NULL)
   (CL:WHEN
    (CL:EQ (CLSYS-SVAL STORAGE-SLOT ABSTRACT? SELF) 0)
    (CL:WARN "Missing type specification for the slot `~A'" SELF))
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SELF) SGT-CLASSES-UNKNOWN)
   (CL:RETURN-FROM FINALIZE-SLOT-TYPE-COMPUTATIONS))
  (CL:WHEN (CL:EQ (ACTIVE? SELF) 1) (ACTIVATE-SLOT SELF))
  :VOID)

;;; (DEFUN (MULTI-VALUED-SLOT-WITH-DUPLICATES? BOOLEAN) ...)

(CL:DEFUN MULTI-VALUED-SLOT-WITH-DUPLICATES? (SELF)
  (CL:RETURN-FROM
   MULTI-VALUED-SLOT-WITH-DUPLICATES?
   (CL:IF
    (CL:AND
     (CL:EQ (SUBTYPE-OF? (TYPE SELF) SGT-CLASSES-COLLECTION) 1)
     (CL:EQ (SUBTYPE-OF? (TYPE SELF) SGT-CLASSES-SET-MIXIN) 0))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN COMPUTE-SLOT-INVERSES ...)

(CL:DEFUN COMPUTE-SLOT-INVERSES (SELF)
  (CL:WHEN
   (CL:EQ (DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-INVERSE NULL) NULL)
   (CL:RETURN-FROM COMPUTE-SLOT-INVERSES))
  (CL:WHEN
   (CL:EQ (MULTI-VALUED-SLOT-WITH-DUPLICATES? SELF) 1)
   (CL:WARN
    "Can't define an inverse on slot `~A' because it allows duplicate values."
    SELF)
   (SET-DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-INVERSE NULL NULL)
   (CL:RETURN-FROM COMPUTE-SLOT-INVERSES))
  (CL:LET*
   ((INVERSECLASS (CLSYS-SVAL SURROGATE SURROGATE-VALUE (TYPE SELF)))
    (INVERSESLOT
     (SAFE-LOOKUP-SLOT
      INVERSECLASS
      (DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-INVERSE NULL))))
   (CL:WHEN
    (CL:NOT (CL:EQ INVERSESLOT NULL))
    (CL:WHEN
     (CL:EQ (MULTI-VALUED-SLOT-WITH-DUPLICATES? INVERSESLOT) 1)
     (CL:WARN
      "Can't define an inverse on slot `~A' because it allows duplicate values."
      INVERSESLOT)
     (SET-DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-INVERSE NULL NULL)
     (SET-DYNAMIC-SLOT-VALUE INVERSESLOT SYM-CLASSES-SLOT-INVERSE NULL NULL)
     (CL:RETURN-FROM COMPUTE-SLOT-INVERSES))
    (CL:WHEN
     (CL:EQ (ACTIVE? INVERSESLOT) 0)
     (SET-DYNAMIC-SLOT-VALUE
      INVERSESLOT
      SYM-CLASSES-SLOT-INVERSE
      (CLSYS-SVAL SLOT SLOT-NAME SELF)
      NULL)
     (FINALIZE-SLOT-TYPE-COMPUTATIONS INVERSESLOT))
    (SET-DYNAMIC-SLOT-VALUE INVERSESLOT SYM-CLASSES-INVERSE SELF NULL)
    (ATTACH-INVERSE-SLOT-DEMON SELF)
    (SET-DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-INVERSE INVERSESLOT NULL)
    (ATTACH-INVERSE-SLOT-DEMON INVERSESLOT)
    (CL:RETURN-FROM COMPUTE-SLOT-INVERSES))
   (CL:IF
    (CL:EQ INVERSECLASS NULL)
    (CL:WARN
     "Can't finalize inverse slot computation for slot `~A'~% because the class `~A' is not defined."
     SELF
     (TYPE SELF))
    (CL:WARN
     "Can't finalize inverse slot computation for slot `~A'~% because the inverse slot `~A' does not exist."
     SELF
     (DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-INVERSE NULL))))
  :VOID)

;;; (DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ...)

(CL:DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ((SELF SLOT))
  NULL
  :VOID)

;;; (DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ...)

(CL:DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ((SELF STORAGE-SLOT))
  (CL:LET*
   ((OWNER
     (CLSYS-SVAL
      SURROGATE
      SURROGATE-VALUE
      (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SELF))))
   (CL:WHEN
    (CL:AND
     (CL:EQ (DYNAMIC-SLOT? SELF) 1)
     (CL:EQ
      (SUBTYPE-OF?
       (CLSYS-SVAL CLASS CLASS-TYPE OWNER)
       SGT-CLASSES-DYNAMIC-SLOTS-MIXIN)
      0)
     (CL:EQ (CLSYS-SVAL CLASS ABSTRACT? OWNER) 0))
    (CL:WARN
     "Slot `~A' on the class `~A'~%   can't have :dynamic slot allocation because the class doesn't~%   inherit the class 'DYNAMIC-SLOTS-MIXIN'.  Resetting the~%   allocation to ':instance'."
     (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SELF)
     (CLASS-SYMBOL OWNER))
    (SET-DYNAMIC-SLOT-VALUE
     SELF
     SYM-CLASSES-SLOT-ALLOCATION
     KWD-CLASSES-INSTANCE
     NULL))
   (CL:WHEN
    (CL:NOT
     (CL:EQ (DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-RENAMES NULL) NULL))
    (CL:LET*
     ((RENAMESSLOT
       (SAFE-LOOKUP-SLOT
        OWNER
        (DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-RENAMES NULL))))
     (CL:COND
      ((CL:NOT (CL:EQ (PRIMARY-TYPE SELF) (PRIMARY-TYPE RENAMESSLOT)))
       (CL:WARN
        "Slot `~A' renames a slot of a different kind~%   (e.g., a storage slot renaming a method slot, or vice-versa).~%  Cancelling the renames option."
        (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SELF))
       (SET-DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-RENAMES NULL NULL))
      ((CL:NOT (CL:EQ (ALLOCATION SELF) (ALLOCATION RENAMESSLOT)))
       (CL:WARN
        "Slot `~A' renames a slot with a different~%   allocation.  Changing its allocation to `~A'."
        (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SELF)
        (ALLOCATION RENAMESSLOT))
       (SET-DYNAMIC-SLOT-VALUE
        SELF
        SYM-CLASSES-SLOT-ALLOCATION
        (ALLOCATION RENAMESSLOT)
        NULL)))))
   (CL:WHEN
    (CL:AND
     (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-CONTEXT-SENSITIVE? SELF) 1)
     (CL:EQ
      (SUBTYPE-OF?
       (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SELF)
       SGT-CLASSES-CONTEXT-SENSITIVE-OBJECT)
      0))
    (CL:ERROR
     "Class `~A' must inherit the class CONTEXT-SENSITIVE-OBJECT~%   because it contains the context sensitive slot `~A' ~%"
     (CLSYS-SVAL
      SURROGATE
      SYMBOL-NAME
      (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SELF))
     (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SELF))))
  :VOID)

;;; (DEFUN FINALIZE-LOCAL-SLOT ...)

(CL:DEFUN FINALIZE-LOCAL-SLOT (SELF)
  (COMPUTE-SLOT-DIRECT-EQUIVALENT SELF)
  (FINALIZE-SLOT-TYPE-COMPUTATIONS SELF)
  (CHECK-CONFORMANCE-OF-SLOT-SIGNATURE SELF)
  (COMPUTE-SLOT-INVERSES SELF)
  (HELP-FINALIZE-LOCAL-SLOT SELF)
  :VOID)

;;; (DEFMETHOD UNFINALIZE-LOCAL-SLOT ...)

(CL:DEFMETHOD UNFINALIZE-LOCAL-SLOT ((SELF SLOT))
  NULL
  :VOID)

;;; (DEFMETHOD UNFINALIZE-LOCAL-SLOT ...)

(CL:DEFMETHOD UNFINALIZE-LOCAL-SLOT ((SELF STORAGE-SLOT))
  NULL
  :VOID)

;;; (DEFUN FINALIZE-CLASS-SLOTS ...)

(CL:DEFUN FINALIZE-CLASS-SLOTS (CLASS)
  (CL:LET*
   ((SUPER NULL)
    (ITER-001
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ SUPER (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:EQ
      (CLSYS-SVAL
       CLASS
       CLASS-SLOTS-FINALIZED?
       (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPER))
      0)
     (FINALIZE-CLASS-SLOTS (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPER)))))
  (COMPUTE-REQUIRED-SLOT-NAMES CLASS)
  (CL:LET*
   ((CLASSTYPE (CLSYS-SVAL CLASS CLASS-TYPE CLASS)))
   (CL:LET*
    ((SLOT NULL)
     (ITER-002
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS CLASS))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SLOT (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (REGISTER-SLOT-NAME SLOT)
     (CL:SETF (CLSYS-SVAL SLOT SLOT-OWNER SLOT) CLASSTYPE))))
  (CL:LET*
   ((SLOT NULL)
    (ITER-003
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS CLASS))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-003 NIL))
    DO
    (CL:PROGN
     (CL:SETQ SLOT (CLSYS-SVAL CONS VALUE ITER-003))
     (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
    (FINALIZE-LOCAL-SLOT SLOT)))
  (CL:SETF (CLSYS-SVAL CLASS CLASS-SLOTS-FINALIZED? CLASS) TRUE)
  :VOID)

;;; (DEFUN UNFINALIZE-CLASS-SLOTS ...)

(CL:DEFUN UNFINALIZE-CLASS-SLOTS (CLASS)
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL CLASS CLASS-SLOTS-FINALIZED? CLASS) 0)
   (CL:RETURN-FROM UNFINALIZE-CLASS-SLOTS))
  (CL:LET*
   ((SUBTYPE NULL)
    (ITER-001
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS CLASS))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ SUBTYPE (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUBTYPE) NULL))
     (UNFINALIZE-CLASS-SLOTS (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUBTYPE)))))
  (HELP-UNFINALIZE-CLASS-SLOTS CLASS)
  :VOID)

;;; (DEFUN HELP-UNFINALIZE-CLASS-SLOTS ...)

(CL:DEFUN HELP-UNFINALIZE-CLASS-SLOTS (CLASS)
  (CLEAR-SLOT-AND-METHOD-CACHE CLASS)
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL CLASS CLASS-SLOTS-FINALIZED? CLASS) 0)
   (CL:RETURN-FROM HELP-UNFINALIZE-CLASS-SLOTS))
  (FREE-REQUIRED-SLOT-NAMES CLASS)
  (CL:LET*
   ((SLOT NULL)
    (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST (LOCAL-SLOTS CLASS))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ SLOT (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (UNFINALIZE-LOCAL-SLOT SLOT)))
  (REMEMBER-UNFINALIZED-CLASS CLASS FALSE)
  (CL:SETF (CLSYS-SVAL CLASS CLASS-SLOTS-FINALIZED? CLASS) FALSE)
  :VOID)

;;; (DEFMETHOD (MULTIPLE-PARENTS? BOOLEAN) ...)

(CL:DEFMETHOD MULTIPLE-PARENTS? ((CLASS CLASS))
  "Return TRUE if 'class' has more than one direct superclass."
  (CL:RETURN-FROM
   MULTIPLE-PARENTS?
   (NON-EMPTY? (REST (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS))))
  :VOID)

;;; (DEFUN ADD-DIRECT-SUPERS-BACK-LINKS ...)

(CL:DEFUN ADD-DIRECT-SUPERS-BACK-LINKS (CLASS)
  (CL:LET*
   ((DIRECTSUPERS (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS))
    (CLASSTYPE (CLSYS-SVAL CLASS CLASS-TYPE CLASS)))
   (REMOVE-DUPLICATES DIRECTSUPERS)
   (CL:LET*
    ((SUPERTYPE NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST DIRECTSUPERS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUPERTYPE (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPERTYPE) NULL))
      (CL:LET*
       ((SUPERCLASS (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPERTYPE)))
       (INSERT-NEW
        (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS SUPERCLASS)
        CLASSTYPE))))))
  :VOID)

;;; (DEFUN ADD-DIRECT-SUBS-BACK-LINKS ...)

(CL:DEFUN ADD-DIRECT-SUBS-BACK-LINKS (CLASS)
  (CL:LET*
   ((DIRECTSUBS (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS CLASS))
    (CLASSTYPE (CLSYS-SVAL CLASS CLASS-TYPE CLASS)))
   (REMOVE-DUPLICATES DIRECTSUBS)
   (CL:LET*
    ((SUBTYPE NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST DIRECTSUBS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUBTYPE (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUBTYPE) NULL))
      (CL:LET*
       ((SUBCLASS (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUBTYPE)))
       (CL:IF
        (CL:EQ (CLSYS-SVAL CLASS CLASS-FINALIZED? SUBCLASS) 1)
        (CL:WHEN
         (CL:EQ
          (MEMBER? (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES SUBCLASS) CLASS)
          0)
         (INSERT (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS SUBCLASS) CLASSTYPE)
         (UNFINALIZE-CLASS-AND-SUBCLASSES CLASS))
        (INSERT-NEW
         (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS SUBCLASS)
         CLASSTYPE)))))))
  :VOID)

;;; (DEFUN REMOVE-DIRECT-SUPERS-BACK-LINKS ...)

(CL:DEFUN REMOVE-DIRECT-SUPERS-BACK-LINKS (CLASS)
  (CL:LET*
   ((CLASSTYPE (CLSYS-SVAL CLASS CLASS-TYPE CLASS)))
   (CL:LET*
    ((SUPERTYPE NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUPERTYPE (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPERTYPE) NULL))
      (REMOVE
       (CLSYS-SVAL
        CLASS
        CLASS-DIRECT-SUBS
        (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPERTYPE))
       CLASSTYPE)))))
  :VOID)

;;; (DEFUN COLLECT-DIRECT-SUPER-CLASSES ...)

(CL:DEFUN COLLECT-DIRECT-SUPER-CLASSES (CLASS PARENTS)
  (CL:LET*
   ((DIRECTSUPERTYPES (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS))
    (NONDIRECTPARENTS (NEW-LIST)))
   (CL:LET*
    ((SUPERTYPE NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST DIRECTSUPERTYPES))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUPERTYPE (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPERTYPE) NULL))
      (CL:IF
       (CL:EQ COLLECT-001 NULL)
       (CL:PROGN
        (CL:SETQ
         COLLECT-001
         (PERMANENT-CONS
          (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPERTYPE)
          NIL))
        (CL:IF
         (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST PARENTS) NIL)
         (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST PARENTS) COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST
          (CLSYS-SVAL LIST THE-CONS-LIST PARENTS)
          COLLECT-001)))
       (CL:PROGN
        (CL:SETF
         (CLSYS-SVAL CONS REST COLLECT-001)
         (PERMANENT-CONS
          (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPERTYPE)
          NIL))
        (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001)))))))
   (CL:LET*
    ((SUPERCLASS NULL) (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST PARENTS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUPERCLASS (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:LET*
      ((OTHERSUPERCLASS NULL)
       (ITER-003 (CLSYS-SVAL LIST THE-CONS-LIST PARENTS)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-003 NIL))
       DO
       (CL:PROGN
        (CL:SETQ OTHERSUPERCLASS (CLSYS-SVAL CONS VALUE ITER-003))
        (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
       (CL:WHEN
        (CL:NOT (CL:EQ OTHERSUPERCLASS SUPERCLASS))
        (CL:WHEN
         (CL:EQ
          (MEMBER?
           (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES SUPERCLASS)
           OTHERSUPERCLASS)
          1)
         (INSERT NONDIRECTPARENTS OTHERSUPERCLASS)))))))
   (CL:LET*
    ((P NULL) (ITER-004 (CLSYS-SVAL LIST THE-CONS-LIST NONDIRECTPARENTS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-004 NIL))
     DO
     (CL:PROGN
      (CL:SETQ P (CLSYS-SVAL CONS VALUE ITER-004))
      (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
     (REMOVE PARENTS P)))
   (FREE NONDIRECTPARENTS))
  :VOID)

;;; (DEFUN INHERIT-SUPERCLASSES ...)

(CL:DEFUN INHERIT-SUPERCLASSES (CLASS)
  (CL:LET*
   ((PARENTCLASSES (NEW-LIST)))
   (COLLECT-DIRECT-SUPER-CLASSES CLASS PARENTCLASSES)
   (CL:WHEN
    (CL:EQ (MULTIPLE-PARENTS? CLASS) 0)
    (CL:LET*
     ((ONLYPARENT (FIRST PARENTCLASSES)))
     (CL:WHEN (CL:EQ ONLYPARENT NULL) (CL:RETURN-FROM INHERIT-SUPERCLASSES))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CLASS)
      (CONS ONLYPARENT (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES ONLYPARENT)))
     (CL:RETURN-FROM INHERIT-SUPERCLASSES)))
   (CL:SETQ PARENTCLASSES (REVERSE PARENTCLASSES))
   (CL:LET*
    ((ALLSUPERCLASSES NIL) (SUBLIST NULL))
    (CL:LET*
     ((PARENT NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST PARENTCLASSES)))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ PARENT (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:SETQ SUBLIST NIL)
      (CL:LET*
       ((ANCESTOR NULL)
        (ITER-002 (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES PARENT))
        (COLLECT-001 NULL))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-002 NIL))
        DO
        (CL:PROGN
         (CL:SETQ ANCESTOR (CLSYS-SVAL CONS VALUE ITER-002))
         (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
        (CL:WHEN
         (CL:EQ (MEMBER? ALLSUPERCLASSES ANCESTOR) 0)
         (CL:IF
          (CL:EQ COLLECT-001 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-001 (CONS ANCESTOR NIL))
           (CL:IF
            (CL:EQ SUBLIST NIL)
            (CL:SETQ SUBLIST COLLECT-001)
            (ADD-CONS-TO-END-OF-CONS-LIST SUBLIST COLLECT-001)))
          (CL:PROGN
           (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS ANCESTOR NIL))
           (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001)))))))
      (CL:SETQ SUBLIST (CONS PARENT SUBLIST))
      (CL:SETQ ALLSUPERCLASSES (CONCATENATE SUBLIST ALLSUPERCLASSES))))
    (CL:SETF (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CLASS) ALLSUPERCLASSES)))
  :VOID)

;;; (DEFUN UNINHERIT-SUPERCLASSES ...)

(CL:DEFUN UNINHERIT-SUPERCLASSES (CLASS)
  (CL:COND
   ((CL:EQ (MULTIPLE-PARENTS? CLASS) 1)
    (FREE-CONS-LIST (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CLASS)))
   ((CL:NOT (CL:EQ (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CLASS) NIL))
    (FREE-CONS (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CLASS))))
  (CL:SETF (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CLASS) NIL)
  :VOID)

;;; (DEFUN (SUBCLASS-OF? BOOLEAN) ...)

(CL:DEFUN SUBCLASS-OF? (SUBCLASS SUPERCLASS)
  "Return TRUE iff the class named 'subClass' is a subclass of the
class named 'superClass'."
  (CL:RETURN-FROM SUBCLASS-OF? (TAXONOMY-SUBCLASS-OF? SUBCLASS SUPERCLASS))
  :VOID)

;;; (DEFUN (SUBTYPE-OF? BOOLEAN) ...)

(CL:DEFUN SUBTYPE-OF? (SUBTYPE SUPERTYPE)
  "Return TRUE iff the class named 'subType' is a subclass 
of the class named 'superType'."
  (CL:DECLARE (CL:INLINE SUBCLASS-OF?))
  (CL:RETURN-FROM
   SUBTYPE-OF?
   (SUBCLASS-OF? (TYPE-TO-CLASS SUBTYPE) (TYPE-TO-CLASS SUPERTYPE)))
  :VOID)

;;; (DEFUN (ISA? BOOLEAN) ...)

(CL:DEFUN ISA? (OBJECT TYPE)
  "Return TRUE iff 'object' is an instance of the class named
'type'."
  (CL:RETURN-FROM ISA? (SUBTYPE-OF? (PRIMARY-TYPE OBJECT) TYPE))
  :VOID)

;;; (DEFUN (TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS CLASS) ...)

(CL:DEFUN TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS (CLASS1 CLASS2)
  "Return the most specific class that is a superclass of
both 'class1' and 'class2'.  If there is more than one, arbitrarily pick one.
If there is none, return NULL."
  (CL:WHEN
   (CL:EQ (SUBCLASS-OF? CLASS1 CLASS2) 1)
   (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS CLASS2))
  (CL:WHEN
   (CL:EQ (SUBCLASS-OF? CLASS2 CLASS1) 1)
   (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS CLASS1))
  (CL:LET*
   ((C NULL) (ITER-001 (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CLASS1)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ C (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:SETF (CLSYS-SVAL CLASS CLASS-MARKED? C) FALSE)))
  (CL:LET*
   ((C NULL) (ITER-002 (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CLASS2)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-002 NIL))
    DO
    (CL:PROGN
     (CL:SETQ C (CLSYS-SVAL CONS VALUE ITER-002))
     (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
    (CL:SETF (CLSYS-SVAL CLASS CLASS-MARKED? C) TRUE)))
  (CL:LET*
   ((C NULL) (ITER-003 (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CLASS1)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-003 NIL))
    DO
    (CL:PROGN
     (CL:SETQ C (CLSYS-SVAL CONS VALUE ITER-003))
     (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL CLASS CLASS-MARKED? C) 1)
     (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS C))))
  (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS NULL)
  :VOID)

;;; (DEFUN (TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE TYPE) ...)

(CL:DEFUN TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE (TYPE1 TYPE2)
  "Return the most specific type that is a supertype of
both 'type1' and 'type2'.  If there is more than one, arbitrarily pick one.
If there is none, return @VOID."
  (CL:LET*
   ((CLASS
     (TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE1)
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE2))))
   (CL:IF
    (CL:NOT (CL:EQ CLASS NULL))
    (CL:RETURN-FROM
     TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE
     (CLSYS-SVAL CLASS CLASS-TYPE CLASS))
    (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE SGT-CLASSES-VOID)))
  :VOID)

;;; (DEFUN INHERIT-SLOTS ...)

(CL:DEFUN INHERIT-SLOTS (CLASS)
  ()
  (CL:LET*
   ((SLOTS
     (COPY-CONS-LIST
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS CLASS)))))
   (CL:COND
    ((CL:EQ (EMPTY? (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS)) 1) NULL)
    ((CL:EQ (MULTIPLE-PARENTS? CLASS) 1)
     (CL:LET*
      ((SUPERTYPE NULL)
       (ITER-001
        (CLSYS-SVAL
         LIST
         THE-CONS-LIST
         (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS))))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ SUPERTYPE (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (CL:SETQ
        SLOTS
        (CONCATENATE
         SLOTS
         (COPY-CONS-LIST
          (CLSYS-SVAL
           CLASS
           CLASS-ALL-SLOTS
           (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPERTYPE)))))))
     (CL:SETQ SLOTS (REVERSE SLOTS))
     (REMOVE-DUPLICATES SLOTS)
     (CL:SETQ SLOTS (REVERSE SLOTS)))
    (CL:T
     (CL:LET*
      ((PARENTSLOTS
        (CLSYS-SVAL
         CLASS
         CLASS-ALL-SLOTS
         (CLSYS-SVAL
          SURROGATE
          SURROGATE-VALUE
          (FIRST (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS))))))
      (CL:SETQ SLOTS (CONCATENATE SLOTS PARENTSLOTS)))))
   (CL:SETF (CLSYS-SVAL CLASS CLASS-ALL-SLOTS CLASS) SLOTS))
  :VOID)

;;; (DEFUN (LOCAL-SLOT? BOOLEAN) ...)

(CL:DEFUN LOCAL-SLOT? (SLOT CLASS)
  (CL:RETURN-FROM
   LOCAL-SLOT?
   (EQ?
    (CLSYS-SVAL SURROGATE SURROGATE-VALUE (CLSYS-SVAL SLOT SLOT-OWNER SLOT))
    CLASS))
  :VOID)

;;; (DEFUN UNINHERIT-SLOTS ...)

(CL:DEFUN UNINHERIT-SLOTS (CLASS)
  (CL:LET*
   ((SLOTSCURSOR (CLSYS-SVAL CLASS CLASS-ALL-SLOTS CLASS)))
   (CL:WHEN
    (CL:NOT (CL:EQ SLOTSCURSOR NULL))
    (CL:WHEN
     (CL:EQ (MULTIPLE-PARENTS? CLASS) 0)
     (CL:LET*
      ((SLOT NULL) (ITER-001 (CLSYS-SVAL CLASS CLASS-ALL-SLOTS CLASS)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ SLOT (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (CL:IF
        (CL:AND
         (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST SLOTSCURSOR) NIL))
         (CL:EQ
          (LOCAL-SLOT? (FIRST (CLSYS-SVAL CONS REST SLOTSCURSOR)) CLASS)
          1))
        (CL:SETQ SLOTSCURSOR (CLSYS-SVAL CONS REST SLOTSCURSOR))
        (CL:RETURN))))
     (CL:SETF (CLSYS-SVAL CONS REST SLOTSCURSOR) NIL))
    (FREE-CONS-LIST (CLSYS-SVAL CLASS CLASS-ALL-SLOTS CLASS))
    (CL:SETF (CLSYS-SVAL CLASS CLASS-ALL-SLOTS CLASS) NULL)))
  :VOID)

;;; (DEFGLOBAL *SYMBOL-SLOT-OFFSET-COUNTER* ...)

(CL:DEFVAR *SYMBOL-SLOT-OFFSET-COUNTER* 0)

;;; (DEFGLOBAL *SLOT-CACHE-SIZE* ...)

(CL:DEFVAR *SLOT-CACHE-SIZE* 20)

;;; (DEFUN INITIALIZE-SLOT-AND-METHOD-CACHE ...)

(CL:DEFUN INITIALIZE-SLOT-AND-METHOD-CACHE (CLASS)
  (CL:SETF
   (CLSYS-SVAL CLASS CLASS-SLOT-AND-METHOD-CACHE CLASS)
   (NEW-VECTOR (CL:1+ *SLOT-CACHE-SIZE*)))
  :VOID)

;;; (DEFUN REGISTER-SLOT-NAME ...)

(CL:DEFUN REGISTER-SLOT-NAME (SLOT)
  "Register the name symbol of 'slot' as a slot name, and
initialize its 'symbol-slot-offset' so that it can be used by 'lookup-slot'."
  (CL:SETF
   (CLSYS-SVAL SYMBOL SYMBOL-SLOT-OFFSET (CLSYS-SVAL SLOT SLOT-NAME SLOT))
   0)
  :VOID)

;;; (DEFUN UNREGISTER-SLOT-NAME ...)

(CL:DEFUN UNREGISTER-SLOT-NAME (SLOT)
  "Unregister the name symbol of 'slot' as a slot name,
so that it can no longer be used by 'lookup-slot'."
  (CL:SETF
   (CLSYS-SVAL SYMBOL SYMBOL-SLOT-OFFSET (CLSYS-SVAL SLOT SLOT-NAME SLOT))
   NULL-INTEGER)
  :VOID)

;;; (DEFUN (REGISTERED-SLOT-NAME? BOOLEAN) ...)

(CL:DEFUN REGISTERED-SLOT-NAME? (SLOTNAME)
  "Return TRUE if 'slotName' is the name of some registered
slot in the system."
  (CL:RETURN-FROM
   REGISTERED-SLOT-NAME?
   (DEFINED? (CLSYS-SVAL SYMBOL SYMBOL-SLOT-OFFSET SLOTNAME)))
  :VOID)

;;; (DEFUN (LOOKUP-SLOT SLOT) ...)

(CL:DEFUN LOOKUP-SLOT (CLASS SLOTNAME)
  "Return a slot owned by the class 'class' with name 'slotName'."
  (CL:LET*
   ((CACHEDSLOT
     (CL:AREF
      (CLSYS-SVAL
       VECTOR
       THE-ARRAY
       (CLSYS-SVAL CLASS CLASS-SLOT-AND-METHOD-CACHE CLASS))
      (CLSYS-SVAL SYMBOL SYMBOL-SLOT-OFFSET SLOTNAME))))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ CACHEDSLOT NULL))
     (CL:EQ (CLSYS-SVAL SLOT SLOT-NAME CACHEDSLOT) SLOTNAME))
    (CL:RETURN-FROM LOOKUP-SLOT CACHEDSLOT))
   (CL:SETQ CACHEDSLOT NULL)
   (CL:LET*
    ((SLOT NULL) (ITER-001 (CLASS-SLOTS CLASS)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ SLOT (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:WHEN
      (CL:EQ (CLSYS-SVAL SLOT SLOT-NAME SLOT) SLOTNAME)
      (CL:SETQ CACHEDSLOT SLOT)
      (CL:RETURN))))
   (CL:WHEN (CL:EQ CACHEDSLOT NULL) (CL:RETURN-FROM LOOKUP-SLOT NULL))
   (CL:LET*
    ((NEWOFFSET (MOD (CL:1+ *SYMBOL-SLOT-OFFSET-COUNTER*) *SLOT-CACHE-SIZE*)))
    (CL:SETQ *SYMBOL-SLOT-OFFSET-COUNTER* NEWOFFSET)
    (CL:SETF (CLSYS-SVAL SYMBOL SYMBOL-SLOT-OFFSET SLOTNAME) NEWOFFSET)
    (INSERT-AT
     (CLSYS-SVAL CLASS CLASS-SLOT-AND-METHOD-CACHE CLASS)
     NEWOFFSET
     CACHEDSLOT)
    (INSERT-AT
     (CLSYS-SVAL CLASS CLASS-SLOT-AND-METHOD-CACHE CLASS)
     *SLOT-CACHE-SIZE*
     CACHEDSLOT)
    (CL:RETURN-FROM LOOKUP-SLOT CACHEDSLOT)))
  :VOID)

;;; (DEFUN (SAFE-LOOKUP-SLOT SLOT) ...)

(CL:DEFUN SAFE-LOOKUP-SLOT (CLASS SLOTNAME)
  "Verify that at least one slot has the name 'slotName',
and then call 'lookup-slot'."
  (CL:SETQ SLOTNAME (SOFT-PERMANENTIFY SLOTNAME))
  (CL:RETURN-FROM
   SAFE-LOOKUP-SLOT
   (CL:IF
    (CL:AND
     (CL:EQ (DEFINED? (CLSYS-SVAL SYMBOL SYMBOL-SLOT-OFFSET SLOTNAME)) 1)
     (CL:NOT (CL:EQ CLASS NULL)))
    (LOOKUP-SLOT CLASS SLOTNAME)
    NULL))
  :VOID)

;;; (DEFUN (LOOKUP-LOCAL-SLOT SLOT) ...)

(CL:DEFUN LOOKUP-LOCAL-SLOT (CLASS SLOTNAME)
  "Lookup a local slot with 'slotName' on 'class'."
  (CL:LET*
   ((SLOT NULL)
    (ITER-001
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS CLASS))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ SLOT (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL SLOT SLOT-NAME SLOT) SLOTNAME)
     (CL:RETURN-FROM LOOKUP-LOCAL-SLOT SLOT))))
  (CL:RETURN-FROM LOOKUP-LOCAL-SLOT NULL)
  :VOID)

;;; (DEFUN CLEAR-SLOT-AND-METHOD-CACHE ...)

(CL:DEFUN CLEAR-SLOT-AND-METHOD-CACHE (CLASS)
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (CL:AREF
      (CLSYS-SVAL
       VECTOR
       THE-ARRAY
       (CLSYS-SVAL CLASS CLASS-SLOT-AND-METHOD-CACHE CLASS))
      *SLOT-CACHE-SIZE*)
     NULL))
   (CLEAR (CLSYS-SVAL CLASS CLASS-SLOT-AND-METHOD-CACHE CLASS)))
  :VOID)

;;; (DEFUN (DYNAMIC-SLOT? BOOLEAN) ...)

(CL:DEFUN DYNAMIC-SLOT? (SLOT)
  (CL:RETURN-FROM DYNAMIC-SLOT? (EQ? (ALLOCATION SLOT) KWD-CLASSES-DYNAMIC))
  :VOID)

;;; (DEFUN ERASE-DYNAMIC-SLOT ...)

(CL:DEFUN ERASE-DYNAMIC-SLOT (SELF SLOTNAME)
  (REMOVE-AT (CLSYS-SVAL DYNAMIC-SLOTS-MIXIN DYNAMIC-SLOTS SELF) SLOTNAME)
  :VOID)

;;; (DEFUN RESIZE-SLOT-CACHES ...)

(CL:DEFUN RESIZE-SLOT-CACHES (SIZE)
  "Reset all slot caches to have size 'size'."
  (CL:SETQ *SLOT-CACHE-SIZE* SIZE)
  (CL:LET*
   ((C NULL) (ITER-001 (ALL-CLASSES NULL FALSE)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITER-001) 1)
    DO
    (CL:PROGN (CL:SETQ C (CLSYS-SVAL ITERATOR VALUE ITER-001)))
    (CL:SETF
     (CLSYS-SVAL CLASS CLASS-SLOT-AND-METHOD-CACHE C)
     (NEW-VECTOR SIZE))
    (CL:LET*
     ((S NULL) (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST (LOCAL-SLOTS C))))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-002 NIL))
      DO
      (CL:PROGN
       (CL:SETQ S (CLSYS-SVAL CONS VALUE ITER-002))
       (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
      (CL:SETF
       (CLSYS-SVAL SYMBOL SYMBOL-SLOT-OFFSET (CLSYS-SVAL SLOT SLOT-NAME S))
       0)))))
  :VOID)

;;; (DEFUN (GET-SLOT SLOT) ...)

(CL:DEFUN GET-SLOT (SELF SLOTNAME)
  "Return the slot named 'slotName' on the class
representing the type of 'self'."
  (CL:RETURN-FROM GET-SLOT (LOOKUP-SLOT (PRIMARY-CLASS SELF) SLOTNAME))
  :VOID)

;;; (DEFUN (CONFORMING-TYPE-SPEC? BOOLEAN) ...)

(CL:DEFUN CONFORMING-TYPE-SPEC? (SUBTYPESPEC SUPERTYPESPEC)
  (CL:RETURN-FROM
   CONFORMING-TYPE-SPEC?
   (CL:IF
    (CL:OR
     (CL:EQ SUBTYPESPEC NULL)
     (CL:EQ SUBTYPESPEC SGT-CLASSES-UNKNOWN)
     (CL:AND
      (CL:EQ (TYPE? SUBTYPESPEC) 1)
      (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUBTYPESPEC) NULL))
     (CL:EQ (ANCHORED-TYPE-SPECIFIER? SUBTYPESPEC) 1)
     (CL:EQ SUPERTYPESPEC NULL)
     (CL:EQ SUPERTYPESPEC SGT-CLASSES-UNKNOWN)
     (CL:AND
      (CL:EQ (TYPE? SUPERTYPESPEC) 1)
      (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPERTYPESPEC) NULL))
     (CL:EQ (ANCHORED-TYPE-SPECIFIER? SUPERTYPESPEC) 1)
     (CL:EQ (SUB-TYPE-SPEC-OF? SUBTYPESPEC SUPERTYPESPEC) 1))
    TRUE
    FALSE))
  :VOID)

;;; (DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ...)

(CL:DEFMETHOD CONFORMING-SIGNATURES? ((SELF SLOT) SUPERSLOT)
  (CL:SETQ SUPERSLOT SUPERSLOT)
  (CL:ERROR "conforming-signatures?: Not defined on `~A'" SELF)
  (CL:RETURN-FROM CONFORMING-SIGNATURES? FALSE)
  :VOID)

;;; (DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ...)

(CL:DEFMETHOD CONFORMING-SIGNATURES? ((SELF STORAGE-SLOT) SUPERSLOT)
  (CL:RETURN-FROM
   CONFORMING-SIGNATURES?
   (CL:IF
    (CL:AND
     (CL:EQ
      (CONFORMING-TYPE-SPEC?
       (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SELF)
       (TYPE SUPERSLOT))
      1)
     (CL:EQ
      (CONFORMING-TYPE-SPEC?
       (DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-TYPE-SPECIFIER NULL)
       (DYNAMIC-SLOT-VALUE SUPERSLOT SYM-CLASSES-SLOT-TYPE-SPECIFIER NULL))
      1)
     (CL:= (METHOD-ARGUMENT-COUNT SUPERSLOT) 1))
    TRUE
    FALSE))
  :VOID)

;;; (DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ...)

(CL:DEFMETHOD CONFORMING-SIGNATURES? ((SELF METHOD-SLOT) SUPERSLOT)
  (CL:WHEN
   (CL:AND
    (CL:EQ
     (CONFORMING-TYPE-SPEC?
      (CLSYS-SVAL METHOD-SLOT SLOT-BASE-TYPE SELF)
      (TYPE SUPERSLOT))
     1)
    (CL:EQ
     (CONFORMING-TYPE-SPEC?
      (DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-TYPE-SPECIFIER NULL)
      (DYNAMIC-SLOT-VALUE SUPERSLOT SYM-CLASSES-SLOT-TYPE-SPECIFIER NULL))
     1)
    (CL:= (METHOD-ARGUMENT-COUNT SELF) (METHOD-ARGUMENT-COUNT SUPERSLOT)))
   (CL:LET*
    ((SUPERSLOT-001 SUPERSLOT))
    (CL:COND
     ((CL:EQ (STORAGE-SLOT? SUPERSLOT) 1)
      (CL:LET*
       ((SUPERSLOT NULL))
       (CL:SETQ SUPERSLOT SUPERSLOT-001)
       (CL:RETURN-FROM
        CONFORMING-SIGNATURES?
        (EQ? (LENGTH (METHOD-RETURN-TYPE-SPECIFIERS SELF)) 1))))
     ((CL:EQ (METHOD-SLOT? SUPERSLOT) 1)
      (CL:LET*
       ((SUPERSLOT NULL))
       (CL:SETQ SUPERSLOT SUPERSLOT-001)
       (CL:LET*
        ((TEST-VALUE-001 FALSE))
        (CL:LET*
         ((ALWAYS?-001 TRUE))
         (CL:LET*
          ((TS2 NULL)
           (TS1 NULL)
           (ITER-001 (REST (METHOD-PARAMETER-TYPE-SPECIFIERS SELF)))
           (ITER-002 (REST (METHOD-PARAMETER-TYPE-SPECIFIERS SUPERSLOT))))
          (CL:LOOP
           WHILE
           (CL:AND
            (CL:NOT (CL:EQ ITER-001 NIL))
            (CL:NOT (CL:EQ ITER-002 NIL)))
           DO
           (CL:PROGN
            (CL:SETQ TS1 (CLSYS-SVAL CONS VALUE ITER-001))
            (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
           (CL:PROGN
            (CL:SETQ TS2 (CLSYS-SVAL CONS VALUE ITER-002))
            (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
           (CL:WHEN
            (CL:EQ (CONFORMING-TYPE-SPEC? TS2 TS1) 0)
            (CL:SETQ ALWAYS?-001 FALSE)
            (CL:RETURN))))
         (CL:SETQ TEST-VALUE-001 ALWAYS?-001))
        (CL:WHEN
         (CL:EQ TEST-VALUE-001 1)
         (CL:LET*
          ((ALWAYS?-002 TRUE))
          (CL:LET*
           ((TS2 NULL)
            (TS1 NULL)
            (ITER-003
             (CLSYS-SVAL
              LIST
              THE-CONS-LIST
              (METHOD-RETURN-TYPE-SPECIFIERS SELF)))
            (ITER-004
             (CLSYS-SVAL
              LIST
              THE-CONS-LIST
              (METHOD-RETURN-TYPE-SPECIFIERS SUPERSLOT))))
           (CL:LOOP
            WHILE
            (CL:AND
             (CL:NOT (CL:EQ ITER-003 NIL))
             (CL:NOT (CL:EQ ITER-004 NIL)))
            DO
            (CL:PROGN
             (CL:SETQ TS1 (CLSYS-SVAL CONS VALUE ITER-003))
             (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
            (CL:PROGN
             (CL:SETQ TS2 (CLSYS-SVAL CONS VALUE ITER-004))
             (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
            (CL:WHEN
             (CL:EQ (CONFORMING-TYPE-SPEC? TS1 TS2) 0)
             (CL:SETQ ALWAYS?-002 FALSE)
             (CL:RETURN))))
          (CL:SETQ TEST-VALUE-001 ALWAYS?-002)))
        (CL:LET*
         ((VALUE-001 TEST-VALUE-001))
         (CL:RETURN-FROM CONFORMING-SIGNATURES? VALUE-001)))))
     (CL:T NULL))))
  (CL:RETURN-FROM CONFORMING-SIGNATURES? FALSE)
  :VOID)

;;; (DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ...)

(CL:DEFMETHOD CONFORMING-SIGNATURES? ((SELF TABLE) SUPERSLOT)
  (CL:WHEN
   (CL:AND
    (CL:EQ
     (CONFORMING-TYPE-SPEC?
      (CLSYS-SVAL TABLE SLOT-BASE-TYPE SELF)
      (TYPE SUPERSLOT))
     1)
    (CL:EQ
     (CONFORMING-TYPE-SPEC?
      (DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-TYPE-SPECIFIER NULL)
      (DYNAMIC-SLOT-VALUE SUPERSLOT SYM-CLASSES-SLOT-TYPE-SPECIFIER NULL))
     1)
    (CL:= (METHOD-ARGUMENT-COUNT SELF) (METHOD-ARGUMENT-COUNT SUPERSLOT)))
   (CL:LET*
    ((SUPERSLOT-001 SUPERSLOT))
    (CL:COND
     ((CL:EQ (TAXONOMY-ISA? SUPERSLOT SGT-CLASSES-TABLE) 1)
      (CL:LET*
       ((SUPERSLOT NULL))
       (CL:SETQ SUPERSLOT SUPERSLOT-001)
       (CL:LET*
        ((ALWAYS?-001 TRUE))
        (CL:LET*
         ((TS2 NULL)
          (TS1 NULL)
          (ITER-001 (REST (CLSYS-SVAL TABLE TUPLE-DOMAINS SELF)))
          (ITER-002 (REST (CLSYS-SVAL TABLE TUPLE-DOMAINS SUPERSLOT))))
         (CL:LOOP
          WHILE
          (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL)))
          DO
          (CL:PROGN
           (CL:SETQ TS1 (CLSYS-SVAL CONS VALUE ITER-001))
           (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
          (CL:PROGN
           (CL:SETQ TS2 (CLSYS-SVAL CONS VALUE ITER-002))
           (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
          (CL:WHEN
           (CL:EQ (CONFORMING-TYPE-SPEC? TS2 TS1) 0)
           (CL:SETQ ALWAYS?-001 FALSE)
           (CL:RETURN))))
        (CL:LET*
         ((VALUE-001 ALWAYS?-001))
         (CL:RETURN-FROM CONFORMING-SIGNATURES? VALUE-001)))))
     (CL:T NULL))))
  (CL:RETURN-FROM CONFORMING-SIGNATURES? FALSE)
  :VOID)

;;; (DEFUN (IDENTICAL-SIGNATURES? BOOLEAN) ...)

(CL:DEFUN IDENTICAL-SIGNATURES? (METHOD1 METHOD2)
  (CL:LET*
   ((TEST-VALUE-001 FALSE))
   (CL:LET*
    ((ALWAYS?-001 TRUE))
    (CL:LET*
     ((TS2 NULL)
      (TS1 NULL)
      (ITER-001 (REST (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD1)))
      (ITER-002 (REST (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD2))))
     (CL:LOOP
      WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL)))
      DO
      (CL:PROGN
       (CL:SETQ TS1 (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:PROGN
       (CL:SETQ TS2 (CLSYS-SVAL CONS VALUE ITER-002))
       (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
      (CL:WHEN
       (CL:NOT
        (CL:AND
         (CL:EQ (SUB-TYPE-SPEC-OF? TS1 TS2) 1)
         (CL:EQ (SUB-TYPE-SPEC-OF? TS2 TS1) 1)))
       (CL:SETQ ALWAYS?-001 FALSE)
       (CL:RETURN))))
    (CL:SETQ TEST-VALUE-001 ALWAYS?-001))
   (CL:WHEN
    (CL:EQ TEST-VALUE-001 1)
    (CL:LET*
     ((ALWAYS?-002 TRUE))
     (CL:LET*
      ((TS2 NULL)
       (TS1 NULL)
       (ITER-003
        (CLSYS-SVAL
         LIST
         THE-CONS-LIST
         (METHOD-RETURN-TYPE-SPECIFIERS METHOD1)))
       (ITER-004
        (CLSYS-SVAL
         LIST
         THE-CONS-LIST
         (METHOD-RETURN-TYPE-SPECIFIERS METHOD2))))
      (CL:LOOP
       WHILE
       (CL:AND (CL:NOT (CL:EQ ITER-003 NIL)) (CL:NOT (CL:EQ ITER-004 NIL)))
       DO
       (CL:PROGN
        (CL:SETQ TS1 (CLSYS-SVAL CONS VALUE ITER-003))
        (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
       (CL:PROGN
        (CL:SETQ TS2 (CLSYS-SVAL CONS VALUE ITER-004))
        (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
       (CL:WHEN
        (CL:NOT
         (CL:AND
          (CL:EQ (SUB-TYPE-SPEC-OF? TS1 TS2) 1)
          (CL:EQ (SUB-TYPE-SPEC-OF? TS2 TS1) 1)))
        (CL:SETQ ALWAYS?-002 FALSE)
        (CL:RETURN))))
     (CL:SETQ TEST-VALUE-001 ALWAYS?-002)))
   (CL:LET*
    ((VALUE-001 TEST-VALUE-001))
    (CL:RETURN-FROM IDENTICAL-SIGNATURES? VALUE-001)))
  :VOID)

;;; (DEFUN COMPUTE-REQUIRED-SLOT-NAMES ...)

(CL:DEFUN COMPUTE-REQUIRED-SLOT-NAMES (CLASS)
  (CL:LET*
   ((SLOTNAMES (NEW-LIST)))
   (CL:LET*
    ((SLOT NULL) (ITER-001 (CLASS-SLOTS CLASS)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ SLOT (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:WHEN
      (CL:AND
       (CL:EQ (STORAGE-SLOT? SLOT) 1)
       (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-REQUIRED? SLOT) 1)
       (CL:EQ (MEMBER? SLOTNAMES (CLSYS-SVAL SLOT SLOT-NAME SLOT)) 0))
      (PUSH SLOTNAMES (CLSYS-SVAL SLOT SLOT-NAME SLOT)))))
   (CL:IF
    (CL:EQ (EMPTY? SLOTNAMES) 1)
    (FREE SLOTNAMES)
    (SET-DYNAMIC-SLOT-VALUE
     CLASS
     SYM-CLASSES-CLASS-REQUIRED-SLOT-NAMES
     (REVERSE SLOTNAMES)
     NULL)))
  :VOID)

;;; (DEFUN FREE-REQUIRED-SLOT-NAMES ...)

(CL:DEFUN FREE-REQUIRED-SLOT-NAMES (CLASS)
  (CL:WHEN
   (CL:EQ (NON-EMPTY? (CLASS-REQUIRED-SLOT-NAMES CLASS)) 1)
   (FREE (CLASS-REQUIRED-SLOT-NAMES CLASS))
   (SET-DYNAMIC-SLOT-VALUE
    CLASS
    SYM-CLASSES-CLASS-REQUIRED-SLOT-NAMES
    NULL
    NULL))
  :VOID)

;;; (DEFMETHOD (DYNAMIC-STORAGE? BOOLEAN) ...)

(CL:DEFMETHOD DYNAMIC-STORAGE? ((SELF STORAGE-SLOT))
  (CL:LET*
   ((ALLOCATION (ALLOCATION SELF)))
   (CL:RETURN-FROM
    DYNAMIC-STORAGE?
    (CL:IF
     (CL:OR
      (CL:EQ ALLOCATION KWD-CLASSES-DYNAMIC)
      (CL:EQ ALLOCATION KWD-CLASSES-BIT))
     TRUE
     FALSE)))
  :VOID)

;;; (DEFMETHOD (PRIVATE? BOOLEAN) ...)

(CL:DEFMETHOD PRIVATE? ((SELF RELATION))
  "Return TRUE if 'self' is not public."
  (CL:RETURN-FROM PRIVATE? (CL:IF (CL:EQ (PUBLIC? SELF) 0) TRUE FALSE))
  :VOID)

;;; (DEFMETHOD (PUBLIC? BOOLEAN) ...)

(CL:DEFMETHOD PUBLIC? ((SELF SLOT))
  "True if 'self' or one it its ancestors is marked public."
  (CL:RETURN-FROM
   PUBLIC?
   (CL:IF
    (CL:OR
     (CL:EQ (CLSYS-SVAL SLOT SLOT-PUBLIC? SELF) 1)
     (CL:AND
      (CL:NOT (CL:EQ (CLSYS-SVAL SLOT SLOT-DIRECT-EQUIVALENT SELF) NULL))
      (CL:EQ (PUBLIC? (CLSYS-SVAL SLOT SLOT-DIRECT-EQUIVALENT SELF)) 1)))
    TRUE
    FALSE))
  :VOID)

;;; (DEFMETHOD (PUBLIC-SLOTS (ITERATOR OF SLOT)) ...)

(CL:DEFMETHOD PUBLIC-SLOTS ((SELF CLASS))
  "Return an iterator over public slots of 'self'."
  (CL:LET*
   ((PUBLICSLOTS NIL) (ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:LET*
    ((SLOT NULL) (ITER-001 (CLASS-SLOTS SELF)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ SLOT (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:LET*
      ((TEST-VALUE-001 FALSE))
      (CL:SETQ TEST-VALUE-001 (CLSYS-SVAL SLOT SLOT-PUBLIC? SLOT))
      (CL:WHEN
       (CL:EQ TEST-VALUE-001 1)
       (CL:LET*
        ((FOUND?-001 FALSE))
        (CL:LET*
         ((PS NULL) (ITER-002 PUBLICSLOTS))
         (CL:LOOP
          WHILE
          (CL:NOT (CL:EQ ITER-002 NIL))
          DO
          (CL:PROGN
           (CL:SETQ PS (CLSYS-SVAL CONS VALUE ITER-002))
           (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
          (CL:WHEN
           (CL:EQ
            (CLSYS-SVAL SLOT SLOT-NAME PS)
            (CLSYS-SVAL SLOT SLOT-NAME SLOT))
           (CL:SETQ FOUND?-001 TRUE)
           (CL:RETURN))))
        (CL:SETQ TEST-VALUE-001 FOUND?-001))
       (CL:SETQ TEST-VALUE-001 (CL:IF (CL:EQ TEST-VALUE-001 0) TRUE FALSE)))
      (CL:WHEN
       (CL:EQ TEST-VALUE-001 1)
       (CL:SETQ PUBLICSLOTS (CONS SLOT PUBLICSLOTS))))))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION ITERATOR-CONS-LIST-NEXT?))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST ITERATOR)
    PUBLICSLOTS)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR FIRST-ITERATION? ITERATOR) TRUE)
   (CL:RETURN-FROM PUBLIC-SLOTS ITERATOR))
  :VOID)

;;; (DEFMETHOD (PUBLIC-SLOTS (ITERATOR OF SLOT)) ...)

(CL:DEFMETHOD PUBLIC-SLOTS ((SELF OBJECT))
  "Return an iterator over public slots of 'self'."
  (CL:RETURN-FROM PUBLIC-SLOTS (PUBLIC-SLOTS (PRIMARY-CLASS SELF)))
  :VOID)

;;; (DEFMETHOD (ALL-CLASS-SLOTS (ITERATOR OF SLOT)) ...)

(CL:DEFMETHOD ALL-CLASS-SLOTS ((SELF CLASS))
  (CL:LET*
   ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION ALL-CLASS-SLOTS-NEXT?))
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT ITERATOR) NIL)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST ITERATOR)
    (CONS (CLSYS-SVAL CLASS CLASS-TYPE SELF) NIL))
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR FIRST-ITERATION? ITERATOR) TRUE)
   (CL:RETURN-FROM ALL-CLASS-SLOTS ITERATOR))
  :VOID)

;;; (DEFUN (ALL-CLASS-SLOTS-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-CLASS-SLOTS-NEXT? (SELF)
  (CL:LET*
   ((CLASSES (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))
    (CLASS NULL)
    (LOCALSLOTS (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF)))
   (CL:COND
    ((CL:EQ LOCALSLOTS NIL)
     (CL:LOOP
      WHILE
      (CL:AND (CL:NOT (CL:EQ CLASSES NIL)) (CL:EQ LOCALSLOTS NIL))
      DO
      (CL:SETQ CLASS (TYPE-TO-CLASS (FIRST CLASSES)))
      (CL:LET*
       ((HEADCONS CLASSES))
       (CL:SETQ CLASSES (CLSYS-SVAL CONS REST CLASSES))
       (FREE-CONS HEADCONS))
      (CL:SETQ
       LOCALSLOTS
       (CLSYS-SVAL
        LIST
        THE-CONS-LIST
        (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS CLASS)))
      (CL:LET*
       ((SUPER NULL)
        (ITER-001
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS))))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ SUPER (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:SETQ CLASSES (CONS SUPER CLASSES)))))
     (CL:WHEN
      (CL:EQ CLASSES NIL)
      (CL:WHEN
       (CL:EQ LOCALSLOTS NIL)
       (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) NULL)
       (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF) NULL)
       (CL:RETURN-FROM ALL-CLASS-SLOTS-NEXT? FALSE)))
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
      CLASSES)
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF)
      (CLSYS-SVAL CONS VALUE LOCALSLOTS))
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF)
      (CLSYS-SVAL CONS REST LOCALSLOTS))
     (CL:RETURN-FROM ALL-CLASS-SLOTS-NEXT? TRUE))
    (CL:T
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF)
      (CLSYS-SVAL CONS VALUE LOCALSLOTS))
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF)
      (CLSYS-SVAL CONS REST LOCALSLOTS))
     (CL:RETURN-FROM ALL-CLASS-SLOTS-NEXT? TRUE))))
  :VOID)

;;; (DEFMETHOD (CLASS-SLOTS (ITERATOR OF SLOT)) ...)

(CL:DEFMETHOD CLASS-SLOTS ((SELF CLASS))
  (CL:RETURN-FROM CLASS-SLOTS (ALL-CLASS-SLOTS SELF))
  :VOID)

;;; (DEFMETHOD (LOCAL-SLOTS (LIST OF SLOT)) ...)

(CL:DEFMETHOD LOCAL-SLOTS ((SELF CLASS))
  (CL:RETURN-FROM LOCAL-SLOTS (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS SELF))
  :VOID)

;;; (DEFMETHOD (DIRECT-SUPER-CLASSES (ITERATOR OF CLASS)) ...)

(CL:DEFMETHOD DIRECT-SUPER-CLASSES ((SELF CLASS))
  "Returns an iterator that generates all direct
super classes of 'self'."
  (CL:RETURN-FROM
   DIRECT-SUPER-CLASSES
   (NEW-TYPES-TO-CLASSES-ITERATOR
    (CLSYS-SVAL
     LIST
     THE-CONS-LIST
     (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS SELF))))
  :VOID)

;;; (DEFMETHOD (SUPER-CLASSES (ITERATOR OF CLASS)) ...)

(CL:DEFMETHOD SUPER-CLASSES ((SELF CLASS))
  "Returns an iterator that generates all super classes
of 'self'.  Non-reflexive."
  (CL:LET*
   ((ITERATOR (NEW-LIST-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-CURSOR ITERATOR)
    (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES SELF))
   (CL:RETURN-FROM SUPER-CLASSES ITERATOR))
  :VOID)

;;; (DEFMETHOD (ACTIVE? BOOLEAN) ...)

(CL:DEFMETHOD ACTIVE? ((SLOT SLOT))
  (CL:RETURN-FROM
   ACTIVE?
   (CL:IF
    (CL:EQ (DEFINED? (STORED-ACTIVE? SLOT)) 1)
    (STORED-ACTIVE? SLOT)
    (CL:IF
     (CL:AND
      (CL:NOT
       (CL:EQ
        (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-CLASSES-COLLECTION)
        NULL))
      (CL:NOT
       (CL:EQ
        (CLSYS-SVAL
         SURROGATE
         SURROGATE-VALUE
         (CLSYS-SVAL SLOT SLOT-BASE-TYPE SLOT))
        NULL))
      (CL:NOT
       (CL:EQ
        (CLSYS-SVAL
         SURROGATE
         SURROGATE-VALUE
         (CLSYS-SVAL SLOT SLOT-OWNER SLOT))
        NULL))
      (CL:EQ (PRIMITIVE? SLOT) 1)
      (CL:OR
       (CL:NOT
        (CL:EQ (DYNAMIC-SLOT-VALUE SLOT SYM-CLASSES-SLOT-INVERSE NULL) NULL))
       (CL:AND
        (CL:NOT (CL:EQ (CLSYS-SVAL SLOT SLOT-DIRECT-EQUIVALENT SLOT) NULL))
        (CL:EQ (ACTIVE? (CLSYS-SVAL SLOT SLOT-DIRECT-EQUIVALENT SLOT)) 1))))
     TRUE
     FALSE)))
  :VOID)

;;; (DEFMETHOD (INITIAL-VALUE OBJECT) ...)

(CL:DEFMETHOD INITIAL-VALUE ((SELF STORAGE-SLOT))
  "Return an initial value for 'self', or NULL.  The
initial value can be defined by the slot itself, inherited from an
equivalent slot, or inherit from the :initial-value option for the 
class representing the type of 'self'."
  (CL:LET*
   ((SLOT SELF)
    (VALUE (DYNAMIC-SLOT-VALUE SLOT SYM-CLASSES-SLOT-INITIAL-VALUE NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM INITIAL-VALUE VALUE))
    (CL:SETQ SLOT (CLSYS-SVAL STORAGE-SLOT SLOT-DIRECT-EQUIVALENT SLOT))
    (CL:IF
     (CL:NOT (CL:EQ SLOT NULL))
     (CL:SETQ
      VALUE
      (DYNAMIC-SLOT-VALUE SLOT SYM-CLASSES-SLOT-INITIAL-VALUE NULL))
     (CL:RETURN)))
   (CL:RETURN-FROM
    INITIAL-VALUE
    (DYNAMIC-SLOT-VALUE
     (CLSYS-SVAL SURROGATE SURROGATE-VALUE (TYPE SELF))
     SYM-CLASSES-CLASS-INITIAL-VALUE
     NULL)))
  :VOID)

;;; (DEFMETHOD (SYSTEM-DEFAULT-VALUE OBJECT) ...)

(CL:DEFMETHOD SYSTEM-DEFAULT-VALUE ((SELF SLOT))
  "Return a default value expression, or if 'self'
has dynamic storage, an initial value expression."
  (CL:RETURN-FROM
   SYSTEM-DEFAULT-VALUE
   (DYNAMIC-SLOT-VALUE
    (CLSYS-SVAL SURROGATE SURROGATE-VALUE (TYPE SELF))
    SYM-CLASSES-CLASS-INITIAL-VALUE
    NULL))
  :VOID)

;;; (DEFMETHOD (SYSTEM-DEFAULT-VALUE OBJECT) ...)

(CL:DEFMETHOD SYSTEM-DEFAULT-VALUE ((SELF STORAGE-SLOT))
  "Return a default value expression, or if 'self'
has dynamic storage, an initial value expression."
  (CL:LET*
   ((VALUE (DEFAULT-FORM SELF)))
   (CL:COND
    ((CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM SYSTEM-DEFAULT-VALUE VALUE))
    ((CL:AND
      (CL:EQ (DYNAMIC-STORAGE? SELF) 1)
      (CL:NOT
       (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE (TYPE SELF)) NULL)))
     (CL:RETURN-FROM
      SYSTEM-DEFAULT-VALUE
      (DYNAMIC-SLOT-VALUE
       (CLSYS-SVAL SURROGATE SURROGATE-VALUE (TYPE SELF))
       SYM-CLASSES-CLASS-INITIAL-VALUE
       NULL)))
    (CL:T (CL:RETURN-FROM SYSTEM-DEFAULT-VALUE NULL))))
  :VOID)

;;; (DEFMETHOD (INITIALLY OBJECT) ...)

(CL:DEFMETHOD INITIALLY ((SELF STORAGE-SLOT))
  "Defines the value of a slot before it has been assigned
a value."
  (CL:LET*
   ((VALUE (DYNAMIC-SLOT-VALUE SELF SYM-CLASSES-SLOT-INITIAL-VALUE NULL)))
   (CL:COND
    ((CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM INITIALLY VALUE))
    ((CL:NOT
      (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-DIRECT-EQUIVALENT SELF) NULL))
     (CL:RETURN-FROM
      INITIALLY
      (INITIALLY (CLSYS-SVAL STORAGE-SLOT SLOT-DIRECT-EQUIVALENT SELF))))
    ((CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SELF) SGT-CLASSES-BOOLEAN)
     (CL:RETURN-FROM INITIALLY (PERMANENTIFY-FORM SYM-CLASSES-FALSE)))
    (CL:T (CL:RETURN-FROM INITIALLY NULL))))
  :VOID)

;;; (DEFUN REPAIR-SLOTS ...)

(CL:DEFUN REPAIR-SLOTS ()
  (CL:LET*
   ((TOP (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-CLASSES-OBJECT)))
   (UNFINALIZE-CLASS-SLOTS TOP)
   (FINALIZE-CLASSES-AND-SLOTS))
  :VOID)

;;; (DEFUN DISCONNECT-CLASSES ...)

(CL:DEFUN DISCONNECT-CLASSES ()
  (CL:LET*
   ((SURROGATE NULL) (ITER-001 (ALL-SURROGATES *MODULE* FALSE)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITER-001) 1)
    DO
    (CL:PROGN (CL:SETQ SURROGATE (CLSYS-SVAL ITERATOR VALUE ITER-001)))
    (CL:WHEN
     (CL:AND
      (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE) NULL))
      (CL:EQ (CLASS? (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE)) 1))
     (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE) NULL))))
  :VOID)

;;; (DEFUN (FILTER-UNBOUND-SURROGATE? BOOLEAN) ...)

(CL:DEFUN FILTER-UNBOUND-SURROGATE? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM
   FILTER-UNBOUND-SURROGATE?
   (CL:IF (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) NULL) TRUE FALSE))
  :VOID)

;;; (DEFUN (UNBOUND-SURROGATES (ITERATOR OF SURROGATE)) ...)

(CL:DEFUN UNBOUND-SURROGATES (MODULE LOCAL?)
  "Iterate over all unbound surrogates visible from 'module'.
Look at all modules if 'module' is NULL.  If 'local?', only consider
surrogates interned in 'module'."
  (CL:LET*
   ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR ITERATOR)
    (ALL-SURROGATES MODULE LOCAL?))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION FILTERED-NESTED-ITERATOR-NEXT?))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-UNBOUND-SURROGATE?))
   (CL:RETURN-FROM UNBOUND-SURROGATES ITERATOR))
  :VOID)

;;; (DEFUN (NAME-TO-STRING STRING) ...)

(CL:DEFUN NAME-TO-STRING (NAME)
  "Return the string represented by 'name'.  Return NULL
if 'name' is undefined or does not represent a string."
  (CL:WHEN
   (CL:NOT (CL:EQ NAME NULL))
   (CL:LET*
    ((NAME-001 NAME))
    (CL:COND
     ((CL:EQ (TAXONOMY-ISA? NAME SGT-CLASSES-GENERALIZED-SYMBOL) 1)
      (CL:LET*
       ((NAME NULL))
       (CL:SETQ NAME NAME-001)
       (CL:RETURN-FROM
        NAME-TO-STRING
        (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-NAME NAME))))
     ((CL:EQ (STRING? NAME) 1)
      (CL:LET*
       ((NAME NULL))
       (CL:SETQ NAME NAME-001)
       (CL:RETURN-FROM
        NAME-TO-STRING
        (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE NAME))))
     (CL:T NULL))))
  (CL:RETURN-FROM NAME-TO-STRING NULL)
  :VOID)

;;; (DEFUN PRINT-UNBOUND-SURROGATES ...)

(CL:DEFUN %%PRINT-UNBOUND-SURROGATES (ARGS)
  "Print all unbound surrogates visible from the module named by the first
argument (a symbol or string).  Look at all modules if no module name or
NULL was supplied.  If the second argument is TRUE, only consider
surrogates interned in the specified module."
  (CL:LET*
   ((NAME (NAME-TO-STRING (FIRST ARGS)))
    (MODULE (CL:IF (CL:NOT (CL:EQ NAME NULL)) (GET-MODULE NAME TRUE) NULL))
    (LOCAL? FALSE))
   (CL:WHEN (CL:EQ (SECOND ARGS) SYM-CLASSES-TRUE) (CL:SETQ LOCAL? TRUE))
   (CL:LET*
    ((SURROGATE NULL) (ITER-001 (UNBOUND-SURROGATES MODULE LOCAL?)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ SURROGATE (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (PRINT-OBJECT SURROGATE %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)))))
  :VOID)

(CL:DEFUN PRINT-UNBOUND-SURROGATES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%%PRINT-UNBOUND-SURROGATES ARGUMENTS)
  :VOID)

(CL:DEFMACRO PRINT-UNBOUND-SURROGATES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Print all unbound surrogates visible from the module named by the first
argument (a symbol or string).  Look at all modules if no module name or
NULL was supplied.  If the second argument is TRUE, only consider
surrogates interned in the specified module."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /STELLA/PRINT-UNBOUND-SURROGATES)) (CL:MACRO-FUNCTION (CL:QUOTE PRINT-UNBOUND-SURROGATES)))

;;; (DEFUN (ROOT-CLASS? BOOLEAN) ...)

(CL:DEFUN ROOT-CLASS? (CLASS)
  (CL:RETURN-FROM
   ROOT-CLASS?
   (CL:IF
    (CL:AND
     (CL:EQ (EMPTY? (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS)) 1)
     (CL:EQ (CLSYS-SVAL CLASS MIXIN? CLASS) 0))
    TRUE
    FALSE))
  :VOID)

;;; (DEFGLOBAL *CLASS-TAXONOMY-GRAPH* ...)

(CL:DEFVAR *CLASS-TAXONOMY-GRAPH* NULL)

;;; (DEFUN CLEAR-CLASS-TAXONOMY ...)

(CL:DEFUN CLEAR-CLASS-TAXONOMY ()
  (CL:LET*
   ((CLASS NULL) (ITER-001 (ALL-CLASSES NULL FALSE)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITER-001) 1)
    DO
    (CL:PROGN (CL:SETQ CLASS (CLSYS-SVAL ITERATOR VALUE ITER-001)))
    (CL:SETF (CLSYS-SVAL CLASS CLASS-TAXONOMY-NODE CLASS) NULL)))
  :VOID)

;;; (DEFUN HELP-CREATE-CLASS-TAXONOMY ...)

(CL:DEFUN HELP-CREATE-CLASS-TAXONOMY (CLASS PARENT)
  (CL:LET*
   ((MYNODE (CLSYS-SVAL CLASS CLASS-TAXONOMY-NODE CLASS)) (PARENTNODE NULL))
   (CL:WHEN
    (CL:NOT (CL:EQ PARENT NULL))
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL CLASS CLASS-TAXONOMY-NODE PARENT) NULL)
     (CL:ERROR
      "`help-create-class-taxonomy': parent should have taxonomy-node"))
    (CL:SETQ PARENTNODE (CLSYS-SVAL CLASS CLASS-TAXONOMY-NODE PARENT)))
   (CL:IF
    (CL:EQ MYNODE NULL)
    (CL:SETF
     (CLSYS-SVAL CLASS CLASS-TAXONOMY-NODE CLASS)
     (CREATE-AND-INTERN-NODE *CLASS-TAXONOMY-GRAPH* PARENTNODE CLASS))
    (LINK-NODES
     *CLASS-TAXONOMY-GRAPH*
     (CLSYS-SVAL CLASS CLASS-TAXONOMY-NODE PARENT)
     MYNODE))
   (CL:LET*
    ((CHILD NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS CLASS))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ CHILD (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (HELP-CREATE-CLASS-TAXONOMY
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE CHILD)
      CLASS))))
  :VOID)

;;; (DEFUN CREATE-CLASS-TAXONOMY ...)

(CL:DEFUN CREATE-CLASS-TAXONOMY ()
  (CL:SETQ *CLASS-TAXONOMY-GRAPH* (NEW-TAXONOMY-GRAPH))
  (CLEAR-CLASS-TAXONOMY)
  (CL:LET*
   ((CLASS NULL) (ITER-001 (ALL-CLASSES NULL FALSE)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITER-001) 1)
    DO
    (CL:PROGN (CL:SETQ CLASS (CLSYS-SVAL ITERATOR VALUE ITER-001)))
    (CL:WHEN
     (CL:OR
      (CL:EQ (ROOT-CLASS? CLASS) 1)
      (CL:EQ (CLSYS-SVAL CLASS MIXIN? CLASS) 1))
     (HELP-CREATE-CLASS-TAXONOMY CLASS NULL))))
  (CREATE-SPANNING-FOREST *CLASS-TAXONOMY-GRAPH*)
  :VOID)

;;; (DEFUN (TAXONOMY-SUBCLASS-OF? BOOLEAN) ...)

(CL:DEFUN TAXONOMY-SUBCLASS-OF? (SUBCLASS SUPERCLASS)
  (CL:WHEN
   (CL:EQ SUBCLASS SUPERCLASS)
   (CL:RETURN-FROM TAXONOMY-SUBCLASS-OF? TRUE))
  (CL:LET*
   ((SUBNODE (CLSYS-SVAL CLASS CLASS-TAXONOMY-NODE SUBCLASS))
    (SUPERNODE (CLSYS-SVAL CLASS CLASS-TAXONOMY-NODE SUPERCLASS))
    (SUBLABEL NULL-INTEGER))
   (CL:WHEN
    (CL:OR (CL:EQ SUBNODE NULL) (CL:EQ SUPERNODE NULL))
    (CL:RETURN-FROM
     TAXONOMY-SUBCLASS-OF?
     (MEMB? (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES SUBCLASS) SUPERCLASS)))
   (CL:SETQ SUBLABEL (CLSYS-SVAL TAXONOMY-NODE LABEL SUBNODE))
   (CL:WHEN
    (CL:AND
     (CL:>=
      SUBLABEL
      (CLSYS-SVAL TAXONOMY-NODE FIRST-INTERVAL-LOWER-BOUND SUPERNODE))
     (CL:<=
      SUBLABEL
      (CLSYS-SVAL TAXONOMY-NODE FIRST-INTERVAL-UPPER-BOUND SUPERNODE)))
    (CL:RETURN-FROM TAXONOMY-SUBCLASS-OF? TRUE))
   (CL:LET*
    ((INTERVAL NULL)
     (ITER-001 (CLSYS-SVAL TAXONOMY-NODE INTERVALS SUPERNODE)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ INTERVAL (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:AND
       (CL:>= SUBLABEL (CLSYS-SVAL INTERVAL LOWER-BOUND INTERVAL))
       (CL:<= SUBLABEL (CLSYS-SVAL INTERVAL UPPER-BOUND INTERVAL)))
      (CL:RETURN-FROM TAXONOMY-SUBCLASS-OF? TRUE))))
   (CL:RETURN-FROM TAXONOMY-SUBCLASS-OF? FALSE))
  :VOID)

;;; (DEFUN (FAST-TAXONOMY-SUBCLASS-OF? BOOLEAN) ...)

(CL:DEFUN FAST-TAXONOMY-SUBCLASS-OF? (SUBCLASS SUPERCLASS)
  (CL:LET*
   ((SUBNODE (CLSYS-SVAL CLASS CLASS-TAXONOMY-NODE SUBCLASS))
    (SUPERNODE (CLSYS-SVAL CLASS CLASS-TAXONOMY-NODE SUPERCLASS))
    (SUBLABEL (CLSYS-SVAL TAXONOMY-NODE LABEL SUBNODE)))
   (CL:IF
    (CL:AND
     (CL:>=
      SUBLABEL
      (CLSYS-SVAL TAXONOMY-NODE FIRST-INTERVAL-LOWER-BOUND SUPERNODE))
     (CL:<=
      SUBLABEL
      (CLSYS-SVAL TAXONOMY-NODE FIRST-INTERVAL-UPPER-BOUND SUPERNODE)))
    (CL:RETURN-FROM FAST-TAXONOMY-SUBCLASS-OF? TRUE)
    (CL:IF
     (CL:EQ (CLSYS-SVAL TAXONOMY-NODE INTERVALS SUPERNODE) NIL)
     (CL:RETURN-FROM FAST-TAXONOMY-SUBCLASS-OF? FALSE)
     (CL:LET*
      ((FOUND?-001 FALSE))
      (CL:LET*
       ((INTERVAL NULL)
        (ITER-001 (CLSYS-SVAL TAXONOMY-NODE INTERVALS SUPERNODE)))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ INTERVAL (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:WHEN
         (CL:AND
          (CL:>= SUBLABEL (CLSYS-SVAL INTERVAL LOWER-BOUND INTERVAL))
          (CL:<= SUBLABEL (CLSYS-SVAL INTERVAL UPPER-BOUND INTERVAL)))
         (CL:SETQ FOUND?-001 TRUE)
         (CL:RETURN))))
      (CL:LET*
       ((VALUE-001 FOUND?-001))
       (CL:RETURN-FROM FAST-TAXONOMY-SUBCLASS-OF? VALUE-001))))))
  :VOID)

;;; (DEFUN (TAXONOMY-ISA? BOOLEAN) ...)

(CL:DEFUN TAXONOMY-ISA? (OBJECT TYPE)
  "Return TRUE iff 'object' is an instance of the class named
'type'.  Assumes a fast class interval test can be used."
  (CL:RETURN-FROM
   TAXONOMY-ISA?
   (TAXONOMY-SUBCLASS-OF?
    (CLSYS-SVAL SURROGATE SURROGATE-VALUE (PRIMARY-TYPE OBJECT))
    (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE)))
  :VOID)

;;; (DEFUN (INTERN-SLOTREF SLOTREF) ...)

(CL:DEFUN INTERN-SLOTREF (CLASSNAME SLOTNAME)
  (CL:RETURN-FROM
   INTERN-SLOTREF
   (INTERN-SURROGATE (CONCATENATE CLASSNAME (CONCATENATE "." SLOTNAME))))
  :VOID)

;;; (DEFUN (LOOKUP-SLOTREF SLOTREF) ...)

(CL:DEFUN LOOKUP-SLOTREF (SELF SLOTNAME)
  (CL:SETQ SELF (REAL-TYPE-SPECIFIER SELF))
  (CL:LET*
   ((CLASS (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF))
    (SLOT NULL)
    (SLOTREF NULL))
   (CL:SETQ SLOT (LOOKUP-FUNCTION SLOTNAME))
   (CL:WHEN (CL:NOT (CL:EQ SLOT NULL)) (CL:SETQ SELF SGT-CLASSES-ANY))
   (CL:WHEN
    (CL:EQ SLOT NULL)
    (CL:SETQ SLOT (SAFE-LOOKUP-SLOT CLASS SLOTNAME)))
   (CL:COND
    ((CL:EQ SLOT NULL)
     (CL:WHEN
      (CL:NOT (CL:EQ CLASS NULL))
      (CL:RETURN-FROM LOOKUP-SLOTREF NULL)))
    (CL:T
     (CL:SETQ SELF (CLSYS-SVAL SLOT SLOT-OWNER SLOT))
     (CL:SETQ SLOTREF (CLSYS-SVAL SLOT SLOT-SLOTREF SLOT))))
   (CL:WHEN
    (CL:EQ SLOTREF NULL)
    (CL:LET*
     ((*MODULE*
       (CL:IF
        (CL:NOT (CL:EQ SLOT NULL))
        (HOME-MODULE SLOT)
        (CLSYS-SVAL SYMBOL HOME-CONTEXT (PERMANENTIFY SLOTNAME))))
      (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CL:SETQ
      SLOTREF
      (INTERN-SLOTREF
       (CLSYS-SVAL SURROGATE SYMBOL-NAME SELF)
       (CLSYS-SVAL SYMBOL SYMBOL-NAME SLOTNAME))))
    (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SLOTREF) SLOT)
    (CL:WHEN
     (CL:NOT (CL:EQ SLOT NULL))
     (CL:SETF (CLSYS-SVAL SLOT SLOT-SLOTREF SLOT) SLOTREF)))
   (CL:RETURN-FROM LOOKUP-SLOTREF SLOTREF))
  :VOID)

;;; (DEFUN (SLOT-SURROGATE? BOOLEAN) ...)

(CL:DEFUN SLOT-SURROGATE? (SELF)
  (CL:RETURN-FROM
   SLOT-SURROGATE?
   (DEFINED? (POSITION (CLSYS-SVAL SURROGATE SYMBOL-NAME SELF) #\. 0)))
  :VOID)

;;; (DEFUN (SLOTREF-TYPE TYPE) ...)

(CL:DEFUN SLOTREF-TYPE (SLOTREF)
  (CL:RETURN-FROM
   SLOTREF-TYPE
   (TYPE (CLSYS-SVAL SURROGATE SURROGATE-VALUE SLOTREF)))
  :VOID)

(CL:DEFUN STARTUP-CLASSES ()
  (CL:LET*
   ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SGT-CLASSES-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 1))
    (CL:SETQ SYM-CLASSES-TRUE (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
    (CL:SETQ
     SYM-CLASSES-FALSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
    (CL:SETQ
     KWD-CLASSES-PARAMETERS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARAMETERS" NULL 2))
    (CL:SETQ
     SYM-CLASSES-SLOT-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-TYPE-SPECIFIER" NULL 0))
    (CL:SETQ
     KWD-CLASSES-PUBLIC?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC?" NULL 2))
    (CL:SETQ
     KWD-CLASSES-REQUIRED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REQUIRED?" NULL 2))
    (CL:SETQ
     KWD-CLASSES-COMPONENT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPONENT?" NULL 2))
    (CL:SETQ
     KWD-CLASSES-READ-ONLY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "READ-ONLY?" NULL 2))
    (CL:SETQ
     KWD-CLASSES-ACTIVE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE?" NULL 2))
    (CL:SETQ
     SYM-CLASSES-STORED-ACTIVE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STORED-ACTIVE?" NULL 0))
    (CL:SETQ
     KWD-CLASSES-CONTEXT-SENSITIVE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-SENSITIVE?" NULL 2))
    (CL:SETQ
     KWD-CLASSES-HARDWIRED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "HARDWIRED?" NULL 2))
    (CL:SETQ
     KWD-CLASSES-ABSTRACT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT?" NULL 2))
    (CL:SETQ
     KWD-CLASSES-ALLOCATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOCATION" NULL 2))
    (CL:SETQ
     KWD-CLASSES-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 2))
    (CL:SETQ
     SYM-CLASSES-SLOT-ALLOCATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-ALLOCATION" NULL 0))
    (CL:SETQ
     KWD-CLASSES-INITIALLY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIALLY" NULL 2))
    (CL:SETQ
     SYM-CLASSES-SLOT-INITIAL-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-INITIAL-VALUE" NULL 0))
    (CL:SETQ
     KWD-CLASSES-DEFAULT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULT" NULL 2))
    (CL:SETQ
     SYM-CLASSES-SLOT-DEFAULT-EXPRESSION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DEFAULT-EXPRESSION" NULL 0))
    (CL:SETQ
     KWD-CLASSES-READER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "READER" NULL 2))
    (CL:SETQ
     SYM-CLASSES-SLOT-READER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-READER" NULL 0))
    (CL:SETQ
     KWD-CLASSES-WRITER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WRITER" NULL 2))
    (CL:SETQ
     SYM-CLASSES-SLOT-WRITER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-WRITER" NULL 0))
    (CL:SETQ
     KWD-CLASSES-INVERSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INVERSE" NULL 2))
    (CL:SETQ
     SYM-CLASSES-SLOT-INVERSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-INVERSE" NULL 0))
    (CL:SETQ
     KWD-CLASSES-RENAMES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RENAMES" NULL 2))
    (CL:SETQ
     SYM-CLASSES-SLOT-RENAMES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-RENAMES" NULL 0))
    (CL:SETQ
     KWD-CLASSES-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
    (CL:SETQ
     SYM-CLASSES-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
    (CL:SETQ
     KWD-CLASSES-PROPERTIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTIES" NULL 2))
    (CL:SETQ
     SYM-CLASSES-PROPERTIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTIES" NULL 0))
    (CL:SETQ
     KWD-CLASSES-META-ATTRIBUTES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "META-ATTRIBUTES" NULL 2))
    (CL:SETQ
     SYM-CLASSES-META-ATTRIBUTES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "META-ATTRIBUTES" NULL 0))
    (CL:SETQ
     KWD-CLASSES-OPTION-KEYWORD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTION-KEYWORD" NULL 2))
    (CL:SETQ
     SYM-CLASSES-SLOT-OPTION-KEYWORD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-OPTION-KEYWORD" NULL 0))
    (CL:SETQ
     KWD-CLASSES-OPTION-HANDLER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTION-HANDLER" NULL 2))
    (CL:SETQ
     SYM-CLASSES-SLOT-OPTION-HANDLER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-OPTION-HANDLER" NULL 0))
    (CL:SETQ
     SGT-CLASSES-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
    (CL:SETQ KWD-CLASSES-BIT (INTERN-RIGID-SYMBOL-WRT-MODULE "BIT" NULL 2))
    (CL:SETQ
     KWD-CLASSES-CL-NATIVE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CL-NATIVE-TYPE" NULL 2))
    (CL:SETQ
     SYM-CLASSES-CLASS-CL-NATIVE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CL-NATIVE-TYPE" NULL 0))
    (CL:SETQ
     KWD-CLASSES-CPP-NATIVE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-NATIVE-TYPE" NULL 2))
    (CL:SETQ
     SYM-CLASSES-CLASS-CPP-NATIVE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CPP-NATIVE-TYPE" NULL 0))
    (CL:SETQ
     KWD-CLASSES-IDL-NATIVE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IDL-NATIVE-TYPE" NULL 2))
    (CL:SETQ
     SYM-CLASSES-CLASS-IDL-NATIVE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-IDL-NATIVE-TYPE" NULL 0))
    (CL:SETQ
     KWD-CLASSES-JAVA-NATIVE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA-NATIVE-TYPE" NULL 2))
    (CL:SETQ
     SYM-CLASSES-CLASS-JAVA-NATIVE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-JAVA-NATIVE-TYPE" NULL 0))
    (CL:SETQ
     KWD-CLASSES-CL-STRUCT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CL-STRUCT?" NULL 2))
    (CL:SETQ
     KWD-CLASSES-MIXIN?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MIXIN?" NULL 2))
    (CL:SETQ
     KWD-CLASSES-RECYCLE-METHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RECYCLE-METHOD" NULL 2))
    (CL:SETQ
     SYM-CLASSES-CLASS-RECYCLE-METHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-RECYCLE-METHOD" NULL 0))
    (CL:SETQ
     KWD-CLASSES-EXTENSION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSION" NULL 2))
    (CL:SETQ
     SYM-CLASSES-CLASS-EXTENSION-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-EXTENSION-NAME" NULL 0))
    (CL:SETQ
     KWD-CLASSES-CREATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CREATOR" NULL 2))
    (CL:SETQ
     SYM-CLASSES-CLASS-CREATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CREATOR" NULL 0))
    (CL:SETQ
     KWD-CLASSES-INITIALIZER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIALIZER" NULL 2))
    (CL:SETQ
     SYM-CLASSES-CLASS-INITIALIZER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-INITIALIZER" NULL 0))
    (CL:SETQ
     KWD-CLASSES-TERMINATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TERMINATOR" NULL 2))
    (CL:SETQ
     SYM-CLASSES-CLASS-TERMINATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-TERMINATOR" NULL 0))
    (CL:SETQ
     KWD-CLASSES-DESTRUCTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESTRUCTOR" NULL 2))
    (CL:SETQ
     SYM-CLASSES-CLASS-DESTRUCTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DESTRUCTOR" NULL 0))
    (CL:SETQ
     KWD-CLASSES-INITIAL-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIAL-VALUE" NULL 2))
    (CL:SETQ
     SYM-CLASSES-CLASS-INITIAL-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-INITIAL-VALUE" NULL 0))
    (CL:SETQ
     KWD-CLASSES-PRINT-FORM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-FORM" NULL 2))
    (CL:SETQ
     SYM-CLASSES-PRINT-FORM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-FORM" NULL 0))
    (CL:SETQ
     KWD-CLASSES-EQUALITY-TEST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUALITY-TEST" NULL 2))
    (CL:SETQ KWD-CLASSES-KEY (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY" NULL 2))
    (CL:SETQ
     SYM-CLASSES-CLASS-KEY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-KEY" NULL 0))
    (CL:SETQ
     SYM-CLASSES-CLASS-PARAMETERS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-PARAMETERS" NULL 0))
    (CL:SETQ
     KWD-CLASSES-SYNONYMS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYNONYMS" NULL 2))
    (CL:SETQ
     SYM-CLASSES-CLASS-SYNONYMS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-SYNONYMS" NULL 0))
    (CL:SETQ
     KWD-CLASSES-CHILDREN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CHILDREN" NULL 2))
    (CL:SETQ
     SGT-CLASSES-METHOD-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SLOT" NULL 1))
    (CL:SETQ
     SYM-CLASSES-SLOT-GUARD-DEMONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-GUARD-DEMONS" NULL 0))
    (CL:SETQ
     SYM-CLASSES-SLOT-DEMONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DEMONS" NULL 0))
    (CL:SETQ
     SYM-CLASSES-CLASS-CONSTRUCTOR-DEMONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CONSTRUCTOR-DEMONS" NULL 0))
    (CL:SETQ
     SYM-CLASSES-CLASS-GUARD-CONSTRUCTOR-DEMONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-GUARD-CONSTRUCTOR-DEMONS" NULL 0))
    (CL:SETQ
     SYM-CLASSES-CLASS-DESTRUCTOR-DEMONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DESTRUCTOR-DEMONS" NULL 0))
    (CL:SETQ
     SYM-CLASSES-CLASS-GUARD-DESTRUCTOR-DEMONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-GUARD-DESTRUCTOR-DEMONS" NULL 0))
    (CL:SETQ
     SGT-CLASSES-ACTIVE-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-OBJECT" NULL 1))
    (CL:SETQ
     SGT-CLASSES-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 1))
    (CL:SETQ
     SGT-CLASSES-STANDARD-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STANDARD-OBJECT" NULL 1))
    (CL:SETQ
     SYM-CLASSES-PRIMARY-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMARY-TYPE" NULL 0))
    (CL:SETQ SYM-CLASSES-SELF (INTERN-RIGID-SYMBOL-WRT-MODULE "SELF" NULL 0))
    (CL:SETQ KWD-CLASSES-TYPE (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 2))
    (CL:SETQ SYM-CLASSES-TYPE (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 0))
    (CL:SETQ
     KWD-CLASSES-AUXILIARY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AUXILIARY?" NULL 2))
    (CL:SETQ
     SYM-CLASSES-RETURN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN" NULL 0))
    (CL:SETQ
     SYM-CLASSES-CLASS-EXTENSION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-EXTENSION" NULL 0))
    (CL:SETQ SGT-CLASSES-SET (INTERN-RIGID-SYMBOL-WRT-MODULE "SET" NULL 1))
    (CL:SETQ
     SGT-CLASSES-ACTIVE-SET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-SET" NULL 1))
    (CL:SETQ SGT-CLASSES-LIST (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" NULL 1))
    (CL:SETQ
     SGT-CLASSES-ACTIVE-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-LIST" NULL 1))
    (CL:SETQ
     SGT-CLASSES-UNKNOWN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" NULL 1))
    (CL:SETQ
     SGT-CLASSES-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION" NULL 1))
    (CL:SETQ
     SGT-CLASSES-SET-MIXIN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-MIXIN" NULL 1))
    (CL:SETQ
     SYM-CLASSES-INVERSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INVERSE" NULL 0))
    (CL:SETQ
     SGT-CLASSES-DYNAMIC-SLOTS-MIXIN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC-SLOTS-MIXIN" NULL 1))
    (CL:SETQ
     KWD-CLASSES-INSTANCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INSTANCE" NULL 2))
    (CL:SETQ
     SGT-CLASSES-CONTEXT-SENSITIVE-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-SENSITIVE-OBJECT" NULL 1))
    (CL:SETQ SGT-CLASSES-VOID (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" NULL 1))
    (CL:SETQ
     KWD-CLASSES-DYNAMIC
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC" NULL 2))
    (CL:SETQ
     SGT-CLASSES-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TABLE" NULL 1))
    (CL:SETQ
     SYM-CLASSES-CLASS-REQUIRED-SLOT-NAMES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-REQUIRED-SLOT-NAMES" NULL 0))
    (CL:SETQ
     SGT-CLASSES-GENERALIZED-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL" NULL 1))
    (CL:SETQ
     SYM-CLASSES-PRINT-UNBOUND-SURROGATES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-UNBOUND-SURROGATES" NULL 0))
    (CL:SETQ
     KWD-CLASSES-COMMON-LISP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
    (CL:SETQ
     KWD-CLASSES-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     SYM-CLASSES-EVALUATOR-WRAPPER-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATOR-WRAPPER-CODE" NULL 0))
    (CL:SETQ SYM-CLASSES-ANY (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY" NULL 0))
    (CL:SETQ SGT-CLASSES-ANY (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY" NULL 1)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:SETQ *UNFINALIZED-CLASSES* (NEW-LIST))
    (CL:SETQ *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES* (NEW-LIST)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 5) 1)
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE "(DEFTYPE ANY UNKNOWN)"))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASS-NAME"
        "CLASS"
        "(DEFUN (CLASS-NAME STRING) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASS-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASS-SYMBOL"
        "CLASS"
        "(DEFUN (CLASS-SYMBOL SYMBOL) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASS-SYMBOL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TYPE-TO-SYMBOL"
        "TYPE"
        "(DEFUN (TYPE-TO-SYMBOL SYMBOL) ((TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TYPE-TO-SYMBOL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRIMARY-CLASS"
        "OBJECT"
        "(DEFMETHOD (PRIMARY-CLASS CLASS) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PRIMARY-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-CLASS"
        "STRING"
        "(DEFMETHOD (LOOKUP-CLASS CLASS) ((NAME STRING)) :DOCUMENTATION \"Return a class with name 'name'.  Scan all
visible surrogates looking for one that has a class defined for it.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOOKUP-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-CLASS"
        "SYMBOL"
        "(DEFMETHOD (LOOKUP-CLASS CLASS) ((NAME SYMBOL)) :DOCUMENTATION \"Return a class with name 'name'.  Scan all
visible surrogates looking for one that has a class defined for it.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOOKUP-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TYPE-TO-CLASS"
        "TYPE"
        "(DEFUN (TYPE-TO-CLASS CLASS) ((TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TYPE-TO-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-CLASS"
        "SURROGATE"
        "(DEFMETHOD (GET-CLASS CLASS) ((CLASSNAME TYPE) (ERROR? BOOLEAN)) :DOCUMENTATION \"Return a class with name 'className'.  If none exists, break
if 'error?', else return NULL.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-CLASS"
        "STRING"
        "(DEFMETHOD (GET-CLASS CLASS) ((CLASSNAME STRING) (ERROR? BOOLEAN)) :DOCUMENTATION \"Return a class with name 'className'.  If none exists, break
if 'error?', else return NULL.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-CLASS"
        "SYMBOL"
        "(DEFMETHOD (GET-CLASS CLASS) ((CLASSNAME SYMBOL) (ERROR? BOOLEAN)) :DOCUMENTATION \"Return a class with name 'className'.  If non exists, break
if 'error?', else return NULL.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BIND-TO-SURROGATE?"
        "OBJECT"
        "(DEFUN (BIND-TO-SURROGATE? BOOLEAN OBJECT SURROGATE) ((SELF OBJECT) (NAME STRING) (CLIPOLDVALUE? BOOLEAN) (WARNONFAILURE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BIND-TO-SURROGATE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNBIND-FROM-SURROGATE"
        "CLASS"
        "(DEFMETHOD UNBIND-FROM-SURROGATE ((SELF CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION UNBIND-FROM-SURROGATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SHADOW-SYMBOL"
        "STRING"
        "(DEFUN (SHADOW-SYMBOL SYMBOL) ((NAME STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SHADOW-SYMBOL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SHADOW-SURROGATE"
        "STRING"
        "(DEFUN (SHADOW-SURROGATE SURROGATE) ((NAME STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SHADOW-SURROGATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BIND-TO-INDEXICAL?"
        "OBJECT"
        "(DEFUN (BIND-TO-INDEXICAL? BOOLEAN OBJECT) ((SELF OBJECT) (NAME STRING) (CLIPOLDVALUE? BOOLEAN) (WARNONFAILURE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BIND-TO-INDEXICAL?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SHADOW-INDEXICAL"
        "STRING"
        "(DEFUN (SHADOW-INDEXICAL INDEXICAL) ((NAME STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SHADOW-INDEXICAL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-CONSTRUCTOR"
        "CLASS"
        "(DEFUN (GET-CONSTRUCTOR FUNCTION-CODE) ((CLASS CLASS) (WARN? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-CONSTRUCTOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-OBJECT"
        "TYPE"
        "(DEFUN (CREATE-OBJECT OBJECT) ((TYPE TYPE) |&REST| (ALTERNATINGSYMBOLSANDVALUES OBJECT)) :DOCUMENTATION \"Flexible, user-friendly version of 'new'.
Return an instance of the class named with type 'type'.
Fill in values using 'alternatingKeywordsAndValues' and call the
initialization function, if one exists. Any arguments required by 'new'
for this type must be included.  'create' runs more slowly than 'new'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-OBJECT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE"
        "OBJECT"
        "(DEFMETHOD FREE ((SELF OBJECT)) :DOCUMENTATION \"Default method.  Deallocate storage for 'self'.\")")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION FREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE"
        "ACTIVE-OBJECT"
        "(DEFMETHOD FREE ((SELF ACTIVE-OBJECT)) :DOCUMENTATION \"Remove all pointers between 'self' and other objects,
and then deallocate the storage for self.\")")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION FREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SYMBOL-TO-WRAPPED-BOOLEAN"
        "OBJECT"
        "(DEFUN (SYMBOL-TO-WRAPPED-BOOLEAN BOOLEAN-WRAPPER) ((OBJECT OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SYMBOL-TO-WRAPPED-BOOLEAN)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFINE-STELLA-CLASS"
        "TYPE"
        "(DEFUN (DEFINE-STELLA-CLASS CLASS) ((NAME TYPE) (SUPERS (LIST OF TYPE)) (SLOTS (LIST OF SLOT)) (OPTIONS KEYWORD-KEY-VALUE-LIST)) :DOCUMENTATION \"Return a Stella class with name 'name'.
Caution:  If the class already exists, the Stella class object gets
redefined, but the native C++ class is not redefined.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFINE-STELLA-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFINE-STELLA-SLOT"
        "SYMBOL"
        "(DEFUN (DEFINE-STELLA-SLOT SLOT) ((NAME SYMBOL) (OWNER TYPE) (BASETYPE TYPE) (TYPESPECIFIER CONS) (OPTIONS KEYWORD-KEY-VALUE-LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFINE-STELLA-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INCORPORATE-CLASS-OPTIONS"
        "CLASS"
        "(DEFUN INCORPORATE-CLASS-OPTIONS ((CLASS CLASS) (OPTIONS KEYWORD-KEY-VALUE-LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INCORPORATE-CLASS-OPTIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INLINE-METHOD?"
        "SLOT"
        "(DEFUN (INLINE-METHOD? BOOLEAN) ((SLOT SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INLINE-METHOD?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSFER-EXTERNAL-SLOT-TO-NEW-CLASS"
        "SLOT"
        "(DEFUN TRANSFER-EXTERNAL-SLOT-TO-NEW-CLASS ((EXTERNALSLOT SLOT) (NEWCLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSFER-EXTERNAL-SLOT-TO-NEW-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSFER-DEMONS-FROM-OLDCLASS"
        "CLASS"
        "(DEFUN TRANSFER-DEMONS-FROM-OLDCLASS ((OLDCLASS CLASS) (NEWCLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSFER-DEMONS-FROM-OLDCLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNDEFINE-OLD-CLASS"
        "CLASS"
        "(DEFUN UNDEFINE-OLD-CLASS ((OLDCLASS CLASS) (NEWCLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNDEFINE-OLD-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-CLASS"
        "CLASS"
        "(DEFMETHOD DESTROY-CLASS ((SELF CLASS)) :DOCUMENTATION \"Destroy the Stella class 'self'.  
Unfinalize its subclasses (if it has any).\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DESTROY-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-CLASS"
        "SURROGATE"
        "(DEFMETHOD DESTROY-CLASS ((SELF TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DESTROY-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-CLASS-AND-SUBCLASSES"
        "CLASS"
        "(DEFUN DESTROY-CLASS-AND-SUBCLASSES ((SELF CLASS)) :DOCUMENTATION \"Destroy the Stella class 'self' and all its subclasses.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESTROY-CLASS-AND-SUBCLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRIMITIVE?"
        "RELATION"
        "(DEFMETHOD (PRIMITIVE? BOOLEAN) ((SELF RELATION)) :DOCUMENTATION \"Return TRUE if 'self' is not a defined relation.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PRIMITIVE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-PRIMITIVE-SUPER"
        "TYPE"
        "(DEFUN INSERT-PRIMITIVE-SUPER ((NEWSUPER TYPE) (SUPERS (LIST OF TYPE))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INSERT-PRIMITIVE-SUPER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECT-MOST-SPECIFIC-PRIMITIVE-SUPERS"
        "CLASS"
        "(DEFUN COLLECT-MOST-SPECIFIC-PRIMITIVE-SUPERS ((CLASS CLASS) (SUPERS (LIST OF TYPE))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECT-MOST-SPECIFIC-PRIMITIVE-SUPERS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MOST-SPECIFIC-PRIMITIVE-SUPERS"
        "CLASS"
        "(DEFUN (MOST-SPECIFIC-PRIMITIVE-SUPERS (LIST OF TYPE)) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MOST-SPECIFIC-PRIMITIVE-SUPERS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASS-NATIVE-SUPERS"
        "CLASS"
        "(DEFUN (CLASS-NATIVE-SUPERS (ITERATOR OF TYPE)) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASS-NATIVE-SUPERS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMEMBER-UNFINALIZED-CLASS"
        "CLASS"
        "(DEFUN REMEMBER-UNFINALIZED-CLASS ((CLASS CLASS) (FORCE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REMEMBER-UNFINALIZED-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FORGET-UNFINALIZED-CLASS"
        "CLASS"
        "(DEFUN FORGET-UNFINALIZED-CLASS ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FORGET-UNFINALIZED-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-CLASSES"
        NULL
        "(DEFUN FINALIZE-CLASSES () :DOCUMENTATION \"Finalize all currently unfinalized classes.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINALIZE-CLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RESOLVE-CHILDREN-REFERENCES"
        NULL
        "(DEFUN RESOLVE-CHILDREN-REFERENCES ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RESOLVE-CHILDREN-REFERENCES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-SLOTS"
        NULL
        "(DEFUN FINALIZE-SLOTS () :DOCUMENTATION \"Finalize all currently unfinalized slots.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINALIZE-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEANUP-UNFINALIZED-CLASSES"
        NULL
        "(DEFUN CLEANUP-UNFINALIZED-CLASSES () :DOCUMENTATION \"Remove all finalized classes from '*unfinalized-classes*',
and set '*newly-unfinalized-classes?*' to FALSE.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLEANUP-UNFINALIZED-CLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-CLASSES-AND-SLOTS"
        NULL
        "(DEFUN FINALIZE-CLASSES-AND-SLOTS () :DOCUMENTATION \"Finalize all currently unfinalized classes and slots.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINALIZE-CLASSES-AND-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ACTIVATE-CLASS"
        "CLASS"
        "(DEFUN ACTIVATE-CLASS ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ACTIVATE-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ADD-PRIMARY-TYPE"
        "CLASS"
        "(DEFUN ADD-PRIMARY-TYPE ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ADD-PRIMARY-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-ONE-CLASS"
        "CLASS"
        "(DEFUN FINALIZE-ONE-CLASS ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINALIZE-ONE-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-CLASS"
        "CLASS"
        "(DEFUN (FINALIZE-CLASS BOOLEAN) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINALIZE-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-FINALIZE-CLASS"
        "CLASS"
        "(DEFUN (HELP-FINALIZE-CLASS BOOLEAN) ((CLASS CLASS) (FINALIZEDPARENT TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-FINALIZE-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNFINALIZE-CLASS-AND-SUBCLASSES"
        "CLASS"
        "(DEFUN UNFINALIZE-CLASS-AND-SUBCLASSES ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNFINALIZE-CLASS-AND-SUBCLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ATTACH-SLOT-TO-OWNER"
        "SLOT"
        "(DEFUN (ATTACH-SLOT-TO-OWNER SLOT) ((NEWSLOT SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ATTACH-SLOT-TO-OWNER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-SLOT-DIRECT-EQUIVALENT"
        "SLOT"
        "(DEFUN COMPUTE-SLOT-DIRECT-EQUIVALENT ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-SLOT-DIRECT-EQUIVALENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CHECK-CONFORMANCE-OF-SLOT-SIGNATURE"
        "SLOT"
        "(DEFUN CHECK-CONFORMANCE-OF-SLOT-SIGNATURE ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CHECK-CONFORMANCE-OF-SLOT-SIGNATURE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECTION-TO-ACTIVE-COLLECTION"
        "TYPE"
        "(DEFUN (COLLECTION-TO-ACTIVE-COLLECTION TYPE) ((TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECTION-TO-ACTIVE-COLLECTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ACTIVATE-SLOT"
        "STORAGE-SLOT"
        "(DEFUN ACTIVATE-SLOT ((SELF STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ACTIVATE-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-SLOT-TYPE-COMPUTATIONS"
        "SLOT"
        "(DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FINALIZE-SLOT-TYPE-COMPUTATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-SLOT-TYPE-COMPUTATIONS"
        "STORAGE-SLOT"
        "(DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ((SELF STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FINALIZE-SLOT-TYPE-COMPUTATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MULTI-VALUED-SLOT-WITH-DUPLICATES?"
        "SLOT"
        "(DEFUN (MULTI-VALUED-SLOT-WITH-DUPLICATES? BOOLEAN) ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MULTI-VALUED-SLOT-WITH-DUPLICATES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-SLOT-INVERSES"
        "SLOT"
        "(DEFUN COMPUTE-SLOT-INVERSES ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-SLOT-INVERSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-FINALIZE-LOCAL-SLOT"
        "SLOT"
        "(DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION HELP-FINALIZE-LOCAL-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-FINALIZE-LOCAL-SLOT"
        "STORAGE-SLOT"
        "(DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ((SELF STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION HELP-FINALIZE-LOCAL-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-LOCAL-SLOT"
        "SLOT"
        "(DEFUN FINALIZE-LOCAL-SLOT ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINALIZE-LOCAL-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNFINALIZE-LOCAL-SLOT"
        "SLOT"
        "(DEFMETHOD UNFINALIZE-LOCAL-SLOT ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION UNFINALIZE-LOCAL-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNFINALIZE-LOCAL-SLOT"
        "STORAGE-SLOT"
        "(DEFMETHOD UNFINALIZE-LOCAL-SLOT ((SELF STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION UNFINALIZE-LOCAL-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-CLASS-SLOTS"
        "CLASS"
        "(DEFUN FINALIZE-CLASS-SLOTS ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINALIZE-CLASS-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNFINALIZE-CLASS-SLOTS"
        "CLASS"
        "(DEFUN UNFINALIZE-CLASS-SLOTS ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNFINALIZE-CLASS-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-UNFINALIZE-CLASS-SLOTS"
        "CLASS"
        "(DEFUN HELP-UNFINALIZE-CLASS-SLOTS ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-UNFINALIZE-CLASS-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MULTIPLE-PARENTS?"
        "CLASS"
        "(DEFMETHOD (MULTIPLE-PARENTS? BOOLEAN) ((CLASS CLASS)) :DOCUMENTATION \"Return TRUE if 'class' has more than one direct superclass.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MULTIPLE-PARENTS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ADD-DIRECT-SUPERS-BACK-LINKS"
        "CLASS"
        "(DEFUN ADD-DIRECT-SUPERS-BACK-LINKS ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ADD-DIRECT-SUPERS-BACK-LINKS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ADD-DIRECT-SUBS-BACK-LINKS"
        "CLASS"
        "(DEFUN ADD-DIRECT-SUBS-BACK-LINKS ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ADD-DIRECT-SUBS-BACK-LINKS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-DIRECT-SUPERS-BACK-LINKS"
        "CLASS"
        "(DEFUN REMOVE-DIRECT-SUPERS-BACK-LINKS ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REMOVE-DIRECT-SUPERS-BACK-LINKS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECT-DIRECT-SUPER-CLASSES"
        "CLASS"
        "(DEFUN COLLECT-DIRECT-SUPER-CLASSES ((CLASS CLASS) (PARENTS (LIST OF CLASS))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECT-DIRECT-SUPER-CLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-SUPERCLASSES"
        "CLASS"
        "(DEFUN INHERIT-SUPERCLASSES ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-SUPERCLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNINHERIT-SUPERCLASSES"
        "CLASS"
        "(DEFUN UNINHERIT-SUPERCLASSES ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNINHERIT-SUPERCLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBCLASS-OF?"
        "CLASS"
        "(DEFUN (SUBCLASS-OF? BOOLEAN) ((SUBCLASS CLASS) (SUPERCLASS CLASS)) :DOCUMENTATION \"Return TRUE iff the class named 'subClass' is a subclass of the
class named 'superClass'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SUBCLASS-OF?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBTYPE-OF?"
        "TYPE"
        "(DEFUN (SUBTYPE-OF? BOOLEAN) ((SUBTYPE TYPE) (SUPERTYPE TYPE)) :DOCUMENTATION \"Return TRUE iff the class named 'subType' is a subclass 
of the class named 'superType'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SUBTYPE-OF?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ISA?"
        "OBJECT"
        "(DEFUN (ISA? BOOLEAN) ((OBJECT OBJECT) (TYPE TYPE)) :DOCUMENTATION \"Return TRUE iff 'object' is an instance of the class named
'type'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ISA?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS"
        "CLASS"
        "(DEFUN (TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS CLASS) ((CLASS1 CLASS) (CLASS2 CLASS)) :DOCUMENTATION \"Return the most specific class that is a superclass of
both 'class1' and 'class2'.  If there is more than one, arbitrarily pick one.
If there is none, return NULL.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE"
        "TYPE"
        "(DEFUN (TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE TYPE) ((TYPE1 TYPE) (TYPE2 TYPE)) :DOCUMENTATION \"Return the most specific type that is a supertype of
both 'type1' and 'type2'.  If there is more than one, arbitrarily pick one.
If there is none, return @VOID.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-SLOTS"
        "CLASS"
        "(DEFUN INHERIT-SLOTS ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOCAL-SLOT?"
        "SLOT"
        "(DEFUN (LOCAL-SLOT? BOOLEAN) ((SLOT SLOT) (CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOCAL-SLOT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNINHERIT-SLOTS"
        "CLASS"
        "(DEFUN UNINHERIT-SLOTS ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNINHERIT-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INITIALIZE-SLOT-AND-METHOD-CACHE"
        "CLASS"
        "(DEFUN INITIALIZE-SLOT-AND-METHOD-CACHE ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INITIALIZE-SLOT-AND-METHOD-CACHE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REGISTER-SLOT-NAME"
        "SLOT"
        "(DEFUN REGISTER-SLOT-NAME ((SLOT SLOT)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Register the name symbol of 'slot' as a slot name, and
initialize its 'symbol-slot-offset' so that it can be used by 'lookup-slot'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REGISTER-SLOT-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNREGISTER-SLOT-NAME"
        "SLOT"
        "(DEFUN UNREGISTER-SLOT-NAME ((SLOT SLOT)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Unregister the name symbol of 'slot' as a slot name,
so that it can no longer be used by 'lookup-slot'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNREGISTER-SLOT-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REGISTERED-SLOT-NAME?"
        "SYMBOL"
        "(DEFUN (REGISTERED-SLOT-NAME? BOOLEAN) ((SLOTNAME SYMBOL)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'slotName' is the name of some registered
slot in the system.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REGISTERED-SLOT-NAME?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-SLOT"
        "CLASS"
        "(DEFUN (LOOKUP-SLOT SLOT) ((CLASS CLASS) (SLOTNAME SYMBOL)) :DOCUMENTATION \"Return a slot owned by the class 'class' with name 'slotName'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SAFE-LOOKUP-SLOT"
        "CLASS"
        "(DEFUN (SAFE-LOOKUP-SLOT SLOT) ((CLASS CLASS) (SLOTNAME SYMBOL)) :DOCUMENTATION \"Verify that at least one slot has the name 'slotName',
and then call 'lookup-slot'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SAFE-LOOKUP-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-LOCAL-SLOT"
        "CLASS"
        "(DEFUN (LOOKUP-LOCAL-SLOT SLOT) ((CLASS CLASS) (SLOTNAME SYMBOL)) :DOCUMENTATION \"Lookup a local slot with 'slotName' on 'class'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-LOCAL-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR-SLOT-AND-METHOD-CACHE"
        "CLASS"
        "(DEFUN CLEAR-SLOT-AND-METHOD-CACHE ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLEAR-SLOT-AND-METHOD-CACHE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DYNAMIC-SLOT?"
        "STORAGE-SLOT"
        "(DEFUN (DYNAMIC-SLOT? BOOLEAN) ((SLOT STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DYNAMIC-SLOT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ERASE-DYNAMIC-SLOT"
        "DYNAMIC-SLOTS-MIXIN"
        "(DEFUN ERASE-DYNAMIC-SLOT ((SELF DYNAMIC-SLOTS-MIXIN) (SLOTNAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ERASE-DYNAMIC-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RESIZE-SLOT-CACHES"
        "INTEGER"
        "(DEFUN RESIZE-SLOT-CACHES ((SIZE INTEGER)) :DOCUMENTATION \"Reset all slot caches to have size 'size'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RESIZE-SLOT-CACHES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-SLOT"
        "STANDARD-OBJECT"
        "(DEFUN (GET-SLOT SLOT) ((SELF STANDARD-OBJECT) (SLOTNAME SYMBOL)) :DOCUMENTATION \"Return the slot named 'slotName' on the class
representing the type of 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONFORMING-TYPE-SPEC?"
        "TYPE-SPEC"
        "(DEFUN (CONFORMING-TYPE-SPEC? BOOLEAN) ((SUBTYPESPEC TYPE-SPEC) (SUPERTYPESPEC TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONFORMING-TYPE-SPEC?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONFORMING-SIGNATURES?"
        "SLOT"
        "(DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ((SELF SLOT) (SUPERSLOT SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CONFORMING-SIGNATURES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONFORMING-SIGNATURES?"
        "STORAGE-SLOT"
        "(DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ((SELF STORAGE-SLOT) (SUPERSLOT SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CONFORMING-SIGNATURES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONFORMING-SIGNATURES?"
        "METHOD-SLOT"
        "(DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ((SELF METHOD-SLOT) (SUPERSLOT SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CONFORMING-SIGNATURES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONFORMING-SIGNATURES?"
        "TABLE"
        "(DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ((SELF TABLE) (SUPERSLOT SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CONFORMING-SIGNATURES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "IDENTICAL-SIGNATURES?"
        "METHOD-SLOT"
        "(DEFUN (IDENTICAL-SIGNATURES? BOOLEAN) ((METHOD1 METHOD-SLOT) (METHOD2 METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION IDENTICAL-SIGNATURES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-REQUIRED-SLOT-NAMES"
        "CLASS"
        "(DEFUN COMPUTE-REQUIRED-SLOT-NAMES ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-REQUIRED-SLOT-NAMES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-REQUIRED-SLOT-NAMES"
        "CLASS"
        "(DEFUN FREE-REQUIRED-SLOT-NAMES ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FREE-REQUIRED-SLOT-NAMES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DYNAMIC-STORAGE?"
        "STORAGE-SLOT"
        "(DEFMETHOD (DYNAMIC-STORAGE? BOOLEAN) ((SELF STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DYNAMIC-STORAGE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRIVATE?"
        "RELATION"
        "(DEFMETHOD (PRIVATE? BOOLEAN) ((SELF RELATION)) :DOCUMENTATION \"Return TRUE if 'self' is not public.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PRIVATE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PUBLIC?"
        "SLOT"
        "(DEFMETHOD (PUBLIC? BOOLEAN) ((SELF SLOT)) :DOCUMENTATION \"True if 'self' or one it its ancestors is marked public.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PUBLIC?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PUBLIC-SLOTS"
        "CLASS"
        "(DEFMETHOD (PUBLIC-SLOTS (ITERATOR OF SLOT)) ((SELF CLASS)) :DOCUMENTATION \"Return an iterator over public slots of 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PUBLIC-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PUBLIC-SLOTS"
        "OBJECT"
        "(DEFMETHOD (PUBLIC-SLOTS (ITERATOR OF SLOT)) ((SELF OBJECT)) :DOCUMENTATION \"Return an iterator over public slots of 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PUBLIC-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-CLASS-SLOTS"
        "CLASS"
        "(DEFMETHOD (ALL-CLASS-SLOTS (ITERATOR OF SLOT)) ((SELF CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ALL-CLASS-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-CLASS-SLOTS-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (ALL-CLASS-SLOTS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-CLASS-SLOTS-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASS-SLOTS"
        "CLASS"
        "(DEFMETHOD (CLASS-SLOTS (ITERATOR OF SLOT)) ((SELF CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CLASS-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOCAL-SLOTS"
        "CLASS"
        "(DEFMETHOD (LOCAL-SLOTS (LIST OF SLOT)) ((SELF CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOCAL-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DIRECT-SUPER-CLASSES"
        "CLASS"
        "(DEFMETHOD (DIRECT-SUPER-CLASSES (ITERATOR OF CLASS)) ((SELF CLASS)) :PUBLIC? TRUE :DOCUMENTATION \"Returns an iterator that generates all direct
super classes of 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DIRECT-SUPER-CLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUPER-CLASSES"
        "CLASS"
        "(DEFMETHOD (SUPER-CLASSES (ITERATOR OF CLASS)) ((SELF CLASS)) :PUBLIC? TRUE :DOCUMENTATION \"Returns an iterator that generates all super classes
of 'self'.  Non-reflexive.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SUPER-CLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ACTIVE?"
        "SLOT"
        "(DEFMETHOD (ACTIVE? BOOLEAN) ((SLOT SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ACTIVE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INITIAL-VALUE"
        "STORAGE-SLOT"
        "(DEFMETHOD (INITIAL-VALUE OBJECT) ((SELF STORAGE-SLOT)) :DOCUMENTATION \"Return an initial value for 'self', or NULL.  The
initial value can be defined by the slot itself, inherited from an
equivalent slot, or inherit from the :initial-value option for the 
class representing the type of 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INITIAL-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SYSTEM-DEFAULT-VALUE"
        "SLOT"
        "(DEFMETHOD (SYSTEM-DEFAULT-VALUE OBJECT) ((SELF SLOT)) :DOCUMENTATION \"Return a default value expression, or if 'self'
has dynamic storage, an initial value expression.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SYSTEM-DEFAULT-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SYSTEM-DEFAULT-VALUE"
        "STORAGE-SLOT"
        "(DEFMETHOD (SYSTEM-DEFAULT-VALUE OBJECT) ((SELF STORAGE-SLOT)) :DOCUMENTATION \"Return a default value expression, or if 'self'
has dynamic storage, an initial value expression.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SYSTEM-DEFAULT-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INITIALLY"
        "STORAGE-SLOT"
        "(DEFMETHOD (INITIALLY OBJECT) ((SELF STORAGE-SLOT)) :DOCUMENTATION \"Defines the value of a slot before it has been assigned
a value.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INITIALLY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REPAIR-SLOTS"
        NULL
        "(DEFUN REPAIR-SLOTS ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REPAIR-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DISCONNECT-CLASSES"
        NULL
        "(DEFUN DISCONNECT-CLASSES ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DISCONNECT-CLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTER-UNBOUND-SURROGATE?"
        "SURROGATE"
        "(DEFUN (FILTER-UNBOUND-SURROGATE? BOOLEAN) ((SELF SURROGATE) (ITERATOR ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTER-UNBOUND-SURROGATE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNBOUND-SURROGATES"
        "MODULE"
        "(DEFUN (UNBOUND-SURROGATES (ITERATOR OF SURROGATE)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Iterate over all unbound surrogates visible from 'module'.
Look at all modules if 'module' is NULL.  If 'local?', only consider
surrogates interned in 'module'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNBOUND-SURROGATES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NAME-TO-STRING"
        "OBJECT"
        "(DEFUN (NAME-TO-STRING STRING) ((NAME OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the string represented by 'name'.  Return NULL
if 'name' is undefined or does not represent a string.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NAME-TO-STRING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-UNBOUND-SURROGATES"
        "ARGUMENT-LIST"
        "(DEFUN PRINT-UNBOUND-SURROGATES (|&REST| (ARGS OBJECT)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Print all unbound surrogates visible from the module named by the first
argument (a symbol or string).  Look at all modules if no module name or
NULL was supplied.  If the second argument is TRUE, only consider
surrogates interned in the specified module.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%PRINT-UNBOUND-SURROGATES))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-CLASSES-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE
       (CL:FUNCTION PRINT-UNBOUND-SURROGATES-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ROOT-CLASS?"
        "CLASS"
        "(DEFUN (ROOT-CLASS? BOOLEAN) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ROOT-CLASS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR-CLASS-TAXONOMY"
        NULL
        "(DEFUN CLEAR-CLASS-TAXONOMY ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLEAR-CLASS-TAXONOMY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-CREATE-CLASS-TAXONOMY"
        "CLASS"
        "(DEFUN HELP-CREATE-CLASS-TAXONOMY ((CLASS CLASS) (PARENT CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-CREATE-CLASS-TAXONOMY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-CLASS-TAXONOMY"
        NULL
        "(DEFUN CREATE-CLASS-TAXONOMY ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-CLASS-TAXONOMY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TAXONOMY-SUBCLASS-OF?"
        "CLASS"
        "(DEFUN (TAXONOMY-SUBCLASS-OF? BOOLEAN) ((SUBCLASS CLASS) (SUPERCLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TAXONOMY-SUBCLASS-OF?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FAST-TAXONOMY-SUBCLASS-OF?"
        "CLASS"
        "(DEFUN (FAST-TAXONOMY-SUBCLASS-OF? BOOLEAN) ((SUBCLASS CLASS) (SUPERCLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FAST-TAXONOMY-SUBCLASS-OF?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TAXONOMY-ISA?"
        "OBJECT"
        "(DEFUN (TAXONOMY-ISA? BOOLEAN) ((OBJECT OBJECT) (TYPE TYPE)) :DOCUMENTATION \"Return TRUE iff 'object' is an instance of the class named
'type'.  Assumes a fast class interval test can be used.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TAXONOMY-ISA?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INTERN-SLOTREF"
        "STRING"
        "(DEFUN (INTERN-SLOTREF SLOTREF) ((CLASSNAME STRING) (SLOTNAME STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INTERN-SLOTREF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-SLOTREF"
        "TYPE"
        "(DEFUN (LOOKUP-SLOTREF SLOTREF) ((SELF TYPE) (SLOTNAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-SLOTREF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SLOT-SURROGATE?"
        "SURROGATE"
        "(DEFUN (SLOT-SURROGATE? BOOLEAN) ((SELF SURROGATE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SLOT-SURROGATE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SLOTREF-TYPE"
        "SLOTREF"
        "(DEFUN (SLOTREF-TYPE TYPE) ((SLOTREF SLOTREF)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SLOTREF-TYPE)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-CLASSES"
     NULL
     "(DEFUN STARTUP-CLASSES ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *WARN-IF-REDEFINE?* BOOLEAN TRUE :DOCUMENTATION \"If set, warn about each redefinition.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *UNFINALIZED-CLASSES* (LIST OF CLASS) (NEW LIST) :DOCUMENTATION \"List of classes whose class or slot inheritance is
currently unfinalized.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *NEWLY-UNFINALIZED-CLASSES?* BOOLEAN FALSE :DOCUMENTATION \"Set to TRUE by 'remember-unfinalized-class'; set
to FALSE by 'cleanup-unfinalized-classes'.  Minimizes the time that
'finalize-classes' spends searching for classes to finalize.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES* (LIST OF CLASS) (NEW LIST) :DOCUMENTATION \"List of classes defined with a :children option
which still have some of their children references unresolved.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SYMBOL-SLOT-OFFSET-COUNTER* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SLOT-CACHE-SIZE* INTEGER 20)")
    (REGISTER-NATIVE-NAME
     SYM-CLASSES-PRINT-UNBOUND-SURROGATES
     KWD-CLASSES-COMMON-LISP
     KWD-CLASSES-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CLASS-TAXONOMY-GRAPH* TAXONOMY-GRAPH NULL)")))
  :VOID)
