;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-WALK-WARN-ABOUT-UNDEFINED-METHODS NULL)
(CL:DEFVAR KWD-WALK-SUPPRESS-WARNINGS NULL)
(CL:DEFVAR KWD-WALK-USE-BOOTSTRAP-TRANSLATOR NULL)
(CL:DEFVAR KWD-WALK-WARN-ABOUT-MISSING-METHODS NULL)
(CL:DEFVAR KWD-WALK-USE-HARDCODED-SYMBOLS NULL)
(CL:DEFVAR KWD-WALK-USE-COMMON-LISP-STRUCTS NULL)
(CL:DEFVAR KWD-WALK-USE-COMMON-LISP-VECTOR-STRUCTS NULL)
(CL:DEFVAR KWD-WALK-USE-CPP-GARBAGE-COLLECTOR NULL)
(CL:DEFVAR KWD-WALK-TRANSLATE-WITH-COPYRIGHT-HEADER NULL)
(CL:DEFVAR SYM-WALK-WHEN NULL)
(CL:DEFVAR SYM-WALK-AND NULL)
(CL:DEFVAR SYM-WALK-DEFINED? NULL)
(CL:DEFVAR SYM-WALK-*TRACED-KEYWORDS* NULL)
(CL:DEFVAR SYM-WALK-MEMBER? NULL)
(CL:DEFVAR SYM-WALK-PRINT NULL)
(CL:DEFVAR SYM-WALK-TRACE-IF NULL)
(CL:DEFVAR SYM-WALK-TRACE-IF-EXPANDER NULL)
(CL:DEFVAR SYM-WALK-ADD-TRACE NULL)
(CL:DEFVAR KWD-WALK-COMMON-LISP NULL)
(CL:DEFVAR KWD-WALK-FUNCTION NULL)
(CL:DEFVAR SYM-WALK-EVALUATOR-WRAPPER-CODE NULL)
(CL:DEFVAR SYM-WALK-DROP-TRACE NULL)
(CL:DEFVAR *RECYCLED-TRANSLATION-UNIT-S* NULL)
(CL:DEFVAR SYM-WALK-THE-OBJECT NULL)
(CL:DEFVAR SYM-WALK-CATEGORY NULL)
(CL:DEFVAR SYM-WALK-ANNOTATION NULL)
(CL:DEFVAR SYM-WALK-AUXILIARY? NULL)
(CL:DEFVAR SYM-WALK-CODE-REGISTER NULL)
(CL:DEFVAR SYM-WALK-TRANSLATION NULL)
(CL:DEFVAR SYM-WALK-REFERENCED-GLOBALS NULL)
(CL:DEFVAR SGT-WALK-TRANSLATION-UNIT NULL)
(CL:DEFVAR SYM-WALK-CLASS NULL)
(CL:DEFVAR SYM-WALK-METHOD NULL)
(CL:DEFVAR SYM-WALK-MACRO NULL)
(CL:DEFVAR SYM-WALK-GLOBAL-VARIABLE NULL)
(CL:DEFVAR SYM-WALK-*TRANSLATIONUNITS* NULL)
(CL:DEFVAR SYM-WALK-*CURRENTTRANSLATIONUNIT* NULL)
(CL:DEFVAR SYM-WALK-*TRANSLATIONPHASE* NULL)
(CL:DEFVAR SYM-WALK-*TRANSLATIONVERBOSITYLEVEL* NULL)
(CL:DEFVAR SYM-WALK-*USEHARDCODEDSYMBOLS?* NULL)
(CL:DEFVAR KWD-WALK-REAL NULL)
(CL:DEFVAR KWD-WALK-BOOTSTRAP NULL)
(CL:DEFVAR KWD-WALK-JAVA NULL)
(CL:DEFVAR KWD-WALK-CPP NULL)
(CL:DEFVAR SYM-WALK-PROGN NULL)
(CL:DEFVAR SYM-WALK-DEFCLASS NULL)
(CL:DEFVAR SYM-WALK-DEFSLOT NULL)
(CL:DEFVAR SYM-WALK-DEFMETHOD NULL)
(CL:DEFVAR SYM-WALK-DEFUN NULL)
(CL:DEFVAR SYM-WALK-DEFOPERATOR NULL)
(CL:DEFVAR SYM-WALK-DEFGLOBAL NULL)
(CL:DEFVAR SYM-WALK-DEFSPECIAL NULL)
(CL:DEFVAR SYM-WALK-DEFCONSTANT NULL)
(CL:DEFVAR SYM-WALK-DEFTYPE NULL)
(CL:DEFVAR SYM-WALK-DEFMODULE NULL)
(CL:DEFVAR SYM-WALK-DEFMACRO NULL)
(CL:DEFVAR SYM-WALK-STARTUP-TIME-PROGN NULL)
(CL:DEFVAR SYM-WALK-VERBATIM NULL)
(CL:DEFVAR SYM-WALK-MODULE NULL)
(CL:DEFVAR SYM-WALK-TYPE NULL)
(CL:DEFVAR SYM-WALK-PRINT-METHOD NULL)
(CL:DEFVAR SYM-WALK-SLOT NULL)
(CL:DEFVAR KWD-WALK-IDL NULL)
(CL:DEFVAR KWD-WALK-CPP-STANDALONE NULL)
(CL:DEFVAR SYM-WALK-*LOCALVARIABLETYPETABLE* NULL)
(CL:DEFVAR SYM-WALK-*METHODBEINGWALKED* NULL)
(CL:DEFVAR SYM-WALK-*FOUNDRETURN?* NULL)
(CL:DEFVAR SGT-WALK-VOID NULL)
(CL:DEFVAR SYM-WALK-*TARGETTYPE* NULL)
(CL:DEFVAR SYM-WALK-*LOCALGENSYMTABLE* NULL)
(CL:DEFVAR SYM-WALK-*TRANSLATIONERRORS* NULL)
(CL:DEFVAR SYM-WALK-*TRANSLATIONWARNINGS* NULL)
(CL:DEFVAR SYM-WALK-*IGNORETRANSLATIONERRORS?* NULL)
(CL:DEFVAR KWD-WALK-DEFINE NULL)
(CL:DEFVAR KWD-WALK-FINALIZE NULL)
(CL:DEFVAR KWD-WALK-WALK NULL)
(CL:DEFVAR KWD-WALK-TRANSLATE NULL)
(CL:DEFVAR SGT-WALK-GLOBAL-VARIABLE NULL)
(CL:DEFVAR SGT-WALK-TYPE-SPEC NULL)
(CL:DEFVAR SGT-WALK-MODULE NULL)
(CL:DEFVAR SGT-WALK-UNINITIALIZED NULL)
(CL:DEFVAR SGT-WALK-UNKNOWN NULL)
(CL:DEFVAR SYM-WALK-NULL NULL)
(CL:DEFVAR SYM-WALK-ERROR NULL)
(CL:DEFVAR SYM-WALK-EOL NULL)
(CL:DEFVAR SYM-WALK-ILLEGAL-EXPRESSION-FLAGGED-BY-THE-TRANSLATOR NULL)
(CL:DEFVAR SYM-WALK-BAD-SYS NULL)
(CL:DEFVAR SGT-WALK-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-INTEGER NULL)
(CL:DEFVAR SGT-WALK-TRANSIENT-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-FLOAT-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-FLOAT NULL)
(CL:DEFVAR SGT-WALK-TRANSIENT-FLOAT-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-NUMBER-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-NUMBER NULL)
(CL:DEFVAR SGT-WALK-STRING-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-STRING NULL)
(CL:DEFVAR SGT-WALK-TRANSIENT-STRING-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-CHARACTER-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-CHARACTER NULL)
(CL:DEFVAR SGT-WALK-TRANSIENT-CHARACTER-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-BOOLEAN NULL)
(CL:DEFVAR SGT-WALK-FUNCTION-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-FUNCTION-CODE NULL)
(CL:DEFVAR SGT-WALK-TRANSIENT-FUNCTION-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-METHOD-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-METHOD-CODE NULL)
(CL:DEFVAR SGT-WALK-TRANSIENT-METHOD-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-OBJECT NULL)
(CL:DEFVAR SYM-WALK-WRAP-BOOLEAN NULL)
(CL:DEFVAR SYM-WALK-WRAP-LITERAL NULL)
(CL:DEFVAR SYM-WALK-INTEGER-TO-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SYM-WALK-INTEGER-TO-BOOLEAN NULL)
(CL:DEFVAR SGT-WALK-SYMBOL NULL)
(CL:DEFVAR SYM-WALK-INTERN-SYMBOL NULL)
(CL:DEFVAR SYM-WALK-SYMBOL-NAME NULL)
(CL:DEFVAR SYM-WALK-WRAPPER-VALUE NULL)
(CL:DEFVAR SGT-WALK-SURROGATE NULL)
(CL:DEFVAR SGT-WALK-CLASS NULL)
(CL:DEFVAR SYM-WALK-SURROGATE-VALUE NULL)
(CL:DEFVAR SGT-WALK-INPUT-STREAM NULL)
(CL:DEFVAR SGT-WALK-NATIVE-INPUT-STREAM NULL)
(CL:DEFVAR SYM-WALK-NATIVE-STREAM NULL)
(CL:DEFVAR SGT-WALK-OUTPUT-STREAM NULL)
(CL:DEFVAR SGT-WALK-NATIVE-OUTPUT-STREAM NULL)
(CL:DEFVAR SYM-WALK-IDENTITY NULL)
(CL:DEFVAR SGT-WALK-SINGLE-FLOAT NULL)
(CL:DEFVAR SGT-WALK-DOUBLE-FLOAT NULL)
(CL:DEFVAR SGT-WALK-SHORT-INTEGER NULL)
(CL:DEFVAR SGT-WALK-LONG-INTEGER NULL)
(CL:DEFVAR SGT-WALK-UNSIGNED-SHORT-INTEGER NULL)
(CL:DEFVAR SGT-WALK-UNSIGNED-LONG-INTEGER NULL)
(CL:DEFVAR SYM-WALK-VRLET NULL)
(CL:DEFVAR SYM-WALK-SYS-CALL-METHOD NULL)
(CL:DEFVAR SYM-WALK-SYS-CALL-FUNCTION NULL)
(CL:DEFVAR SYM-WALK-SAFE-CAST NULL)
(CL:DEFVAR SYM-WALK-CAST NULL)
(CL:DEFVAR SGT-WALK-NON-OBJECT NULL)
(CL:DEFVAR SGT-WALK-WRAPPER NULL)
(CL:DEFVAR SYM-WALK-LET NULL)
(CL:DEFVAR SYM-WALK-VOID-SYS NULL)
(CL:DEFVAR SYM-WALK-TYPED-SYS NULL)
(CL:DEFVAR SYM-WALK-SLOT-TYPE-SPECIFIER NULL)
(CL:DEFVAR SGT-WALK-CONS NULL)
(CL:DEFVAR SYM-WALK-SYS-FOREACH NULL)
(CL:DEFVAR SYM-WALK-SETQ NULL)
(CL:DEFVAR SYM-WALK-SETF NULL)
(CL:DEFVAR SYM-WALK-SLOT-VALUE NULL)
(CL:DEFVAR SYM-WALK-SLOT-VALUE-SETTER NULL)
(CL:DEFVAR SYM-WALK-LOOP NULL)
(CL:DEFVAR SYM-WALK-VALUES NULL)
(CL:DEFVAR SYM-WALK-SPECIAL NULL)
(CL:DEFVAR SYM-WALK-SYS-SPECIAL NULL)
(CL:DEFVAR SYM-WALK-RETURN NULL)
(CL:DEFVAR SYM-WALK-MV-SETQ NULL)
(CL:DEFVAR SYM-WALK-MV-BIND NULL)
(CL:DEFVAR SYM-WALK-BREAK NULL)
(CL:DEFVAR SYM-WALK-CONTINUE NULL)
(CL:DEFVAR SYM-WALK-WHILE NULL)
(CL:DEFVAR SYM-WALK-FOREACH NULL)
(CL:DEFVAR SYM-WALK-EXISTS NULL)
(CL:DEFVAR SYM-WALK-FORALL NULL)
(CL:DEFVAR SYM-WALK-SOME NULL)
(CL:DEFVAR SYM-WALK-SETOF NULL)
(CL:DEFVAR SYM-WALK-SET-OF NULL)
(CL:DEFVAR SYM-WALK-SELECT NULL)
(CL:DEFVAR SYM-WALK-IF NULL)
(CL:DEFVAR SYM-WALK-UNLESS NULL)
(CL:DEFVAR SYM-WALK-CHOOSE NULL)
(CL:DEFVAR SYM-WALK-OR NULL)
(CL:DEFVAR SYM-WALK-NOT NULL)
(CL:DEFVAR SYM-WALK-COND NULL)
(CL:DEFVAR SYM-WALK-CASE NULL)
(CL:DEFVAR SYM-WALK-TYPECASE NULL)
(CL:DEFVAR SYM-WALK-EQ? NULL)
(CL:DEFVAR SYM-WALK-EQL? NULL)
(CL:DEFVAR SYM-WALK-= NULL)
(CL:DEFVAR SYM-WALK-+ NULL)
(CL:DEFVAR SYM-WALK-- NULL)
(CL:DEFVAR SYM-WALK-* NULL)
(CL:DEFVAR SYM-WALK-/ NULL)
(CL:DEFVAR SYM-WALK-QUOTE NULL)
(CL:DEFVAR SYM-WALK-BQUOTE NULL)
(CL:DEFVAR SYM-WALK-PRINT-STREAM NULL)
(CL:DEFVAR SYM-WALK-PRINT-NATIVE-STREAM NULL)
(CL:DEFVAR SYM-WALK-NEW NULL)
(CL:DEFVAR SYM-WALK-ALLOCATE NULL)
(CL:DEFVAR SYM-WALK-LOCAL-NEW NULL)
(CL:DEFVAR SYM-WALK-MAKE NULL)
(CL:DEFVAR SYM-WALK-FUNCALL NULL)
(CL:DEFVAR SYM-WALK-SYS-CALL-FUNCTION-CODE NULL)
(CL:DEFVAR SYM-WALK-SYS-CALL-METHOD-CODE NULL)
(CL:DEFVAR SYM-WALK-THE-CODE NULL)
(CL:DEFVAR SYM-WALK-EXCEPTION-CASE NULL)
(CL:DEFVAR SYM-WALK-INLINE NULL)
(CL:DEFVAR SYM-WALK-SYS-SLOT-VALUE NULL)
(CL:DEFVAR SYM-WALK-SYS-SLOT-VALUE-SETTER NULL)
(CL:DEFVAR SYM-WALK-SYS-CALL-METHOD-SETTER NULL)
(CL:DEFVAR SYM-WALK-SYS-NEW NULL)
(CL:DEFVAR SYM-WALK-*CURRENTFILE* NULL)
(CL:DEFVAR KWD-WALK-SYMBOLS NULL)
(CL:DEFVAR SYM-WALK-INTERN-RIGID-SYMBOL-WRT-MODULE NULL)
(CL:DEFVAR SYM-WALK-GET-MODULE NULL)
(CL:DEFVAR SYM-WALK-TRUE NULL)
(CL:DEFVAR SYM-WALK-INTERN-SYMBOL-AT NULL)
(CL:DEFVAR SYM-WALK-INTERN-SURROGATE-AT NULL)
(CL:DEFVAR SYM-WALK-INTERN-KEYWORD-AT NULL)
(CL:DEFVAR SYM-WALK-FALSE NULL)
(CL:DEFVAR SYM-WALK-NIL NULL)
(CL:DEFVAR SYM-WALK-NULL-BOOLEAN NULL)
(CL:DEFVAR SYM-WALK-NULL-INTEGER NULL)
(CL:DEFVAR SYM-WALK-NULL-FLOAT NULL)
(CL:DEFVAR SGT-WALK-KEYWORD NULL)
(CL:DEFVAR KWD-WALK-PLACE-WHERE-VRLET-WAS NULL)
(CL:DEFVAR KWD-WALK-PLACE-WHERE-LAST-EXPRESSION-WAS NULL)
(CL:DEFVAR KWD-WALK-DYNAMIC NULL)
(CL:DEFVAR SYM-WALK-IT NULL)
(CL:DEFVAR SYM-WALK-ON NULL)
(CL:DEFVAR SYM-WALK-DYNAMIC-SLOTS NULL)
(CL:DEFVAR SYM-WALK-WHERE NULL)
(CL:DEFVAR SYM-WALK-KEY NULL)
(CL:DEFVAR SYM-WALK-DO NULL)
(CL:DEFVAR SYM-WALK-WRAPPEDVALUE NULL)
(CL:DEFVAR SYM-WALK-VALUE NULL)
(CL:DEFVAR KWD-WALK-BIT NULL)
(CL:DEFVAR SYM-WALK-DYNAMICSLOTS NULL)
(CL:DEFVAR SYM-WALK-NEWVALUE NULL)
(CL:DEFVAR SYM-WALK-FOUNDMATCHINGENTRY? NULL)
(CL:DEFVAR SYM-WALK-THE-KV-LIST NULL)
(CL:DEFVAR SYM-WALK-KV-CONS NULL)
(CL:DEFVAR SYM-WALK-OLDVALUE NULL)
(CL:DEFVAR KWD-WALK-CONTEXT-SENSITIVE? NULL)
(CL:DEFVAR KWD-WALK-DONT-INHERIT? NULL)
(CL:DEFVAR SYM-WALK-ACCESS-IN-CONTEXT NULL)
(CL:DEFVAR KWD-WALK-COPY-TO-CHILDREN? NULL)
(CL:DEFVAR SYM-WALK-UPDATE-IN-CONTEXT NULL)
(CL:DEFVAR SYM-WALK-CS-VALUE? NULL)
(CL:DEFVAR SYM-WALK-VARIABLE-DECLARATION NULL)
(CL:DEFVAR SYM-WALK-ILLEGAL-VARIABLE NULL)
(CL:DEFVAR SYM-WALK-*SPECIALVARIABLESTACK* NULL)
(CL:DEFVAR SYM-WALK-*SPECIALSENABLED?* NULL)
(CL:DEFVAR SYM-WALK-*NOFSPECIALSATLOOPENTRY* NULL)
(CL:DEFVAR KWD-WALK-SAVE-AND-RESTORE NULL)
(CL:DEFVAR SYM-WALK-EXCEPTION NULL)
(CL:DEFVAR SYM-WALK-RESIGNAL NULL)
(CL:DEFVAR SGT-WALK-METHOD-SLOT NULL)
(CL:DEFVAR SYM-WALK-OTHERWISE NULL)
(CL:DEFVAR SYM-WALK-SYMBOL-ID NULL)
(CL:DEFVAR SYM-WALK-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SYM-WALK-BOOLEAN? NULL)
(CL:DEFVAR SYM-WALK-INTEGER? NULL)
(CL:DEFVAR SYM-WALK-FLOAT? NULL)
(CL:DEFVAR SYM-WALK-STRING? NULL)
(CL:DEFVAR SYM-WALK-CHARACTER? NULL)
(CL:DEFVAR SYM-WALK-WRAPPER? NULL)
(CL:DEFVAR SGT-WALK-VERBATIM-STRING-WRAPPER NULL)
(CL:DEFVAR SYM-WALK-VERBATIM-STRING? NULL)
(CL:DEFVAR SYM-WALK-SURROGATE? NULL)
(CL:DEFVAR SGT-WALK-TYPE NULL)
(CL:DEFVAR SYM-WALK-TYPE? NULL)
(CL:DEFVAR SYM-WALK-SYMBOL? NULL)
(CL:DEFVAR SGT-WALK-TRANSIENT-SYMBOL NULL)
(CL:DEFVAR SYM-WALK-TRANSIENT-SYMBOL? NULL)
(CL:DEFVAR SYM-WALK-KEYWORD? NULL)
(CL:DEFVAR SYM-WALK-CONS? NULL)
(CL:DEFVAR SYM-WALK-CLASS? NULL)
(CL:DEFVAR SGT-WALK-STORAGE-SLOT NULL)
(CL:DEFVAR SYM-WALK-STORAGE-SLOT? NULL)
(CL:DEFVAR SYM-WALK-METHOD-SLOT? NULL)
(CL:DEFVAR SGT-WALK-ANCHORED-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-WALK-ANCHORED-TYPE-SPECIFIER? NULL)
(CL:DEFVAR SGT-WALK-PARAMETRIC-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-WALK-PARAMETRIC-TYPE-SPECIFIER? NULL)
(CL:DEFVAR SYM-WALK-ISA? NULL)
(CL:DEFVAR SYM-WALK-TAXONOMY-ISA? NULL)
(CL:DEFVAR SYM-WALK-STRING-EQL? NULL)
(CL:DEFVAR SGT-WALK-STANDARD-OBJECT NULL)
(CL:DEFVAR SGT-WALK-LITERAL NULL)
(CL:DEFVAR SYM-WALK-EQL-TO-BOOLEAN? NULL)
(CL:DEFVAR SYM-WALK-EQL-TO-INTEGER? NULL)
(CL:DEFVAR SYM-WALK-EQL-TO-FLOAT? NULL)
(CL:DEFVAR SYM-WALK-EQL-TO-STRING? NULL)
(CL:DEFVAR SYM-WALK-GET-QUOTED-TREE NULL)
(CL:DEFVAR KWD-WALK-WARN NULL)
(CL:DEFVAR KWD-WALK-ERROR NULL)
(CL:DEFVAR KWD-WALK-CONTINUABLE-ERROR NULL)
(CL:DEFVAR SYM-WALK-CONS NULL)
(CL:DEFVAR SYM-WALK-CONS-LIST NULL)
(CL:DEFVAR SYM-WALK-GET-SYM NULL)
(CL:DEFVAR SYM-WALK-GET-SGT NULL)
(CL:DEFVAR SYM-WALK-GET-KWD NULL)
(CL:DEFVAR SGT-WALK-ARGUMENT-LIST NULL)
(CL:DEFVAR SYM-WALK-ANY-VALUE NULL)
(CL:DEFVAR SYM-WALK-METHOD-INHERITS-THROUGH NULL)
(CL:DEFVAR SYM-WALK-SLOT-WRITER NULL)
(CL:DEFVAR SYM-WALK-LOOKUP-SLOT NULL)
(CL:DEFVAR SYM-WALK-TYPE-CLASS NULL)
(CL:DEFVAR SYM-WALK-STORAGE-SLOT NULL)
(CL:DEFVAR KWD-WALK-METHODS NULL)
(CL:DEFVAR SYM-WALK-FUNCTION-CODE NULL)
(CL:DEFVAR SYM-WALK-METHOD-CODE NULL)
(CL:DEFVAR KWD-WALK-METHOD NULL)
(CL:DEFVAR KWD-WALK-CLASS NULL)
(CL:DEFVAR KWD-WALK-EMBEDDED NULL)
(CL:DEFVAR SYM-WALK-CLASS-CONSTRUCTOR-CODE NULL)
(CL:DEFVAR SYM-WALK-SLOT-ACCESSOR-METHODS NULL)
(CL:DEFVAR SYM-WALK-PRINT-FORM NULL)
(CL:DEFVAR SYM-WALK-PRINT-OBJECT NULL)
(CL:DEFVAR SYM-WALK-SELF NULL)
(CL:DEFVAR SYM-WALK-STREAM NULL)
(CL:DEFVAR SYM-WALK-NATIVE-OUTPUT-STREAM NULL)
(CL:DEFVAR KWD-WALK-CLASSES NULL)
(CL:DEFVAR KWD-WALK-FINALIZE-CLASSES NULL)
(CL:DEFVAR SYM-WALK-FINALIZE-CLASSES NULL)
(CL:DEFVAR KWD-WALK-FINALIZE-METHODS NULL)
(CL:DEFVAR SYM-WALK-FINALIZE-SLOTS NULL)
(CL:DEFVAR SYM-WALK-CLEANUP-UNFINALIZED-CLASSES NULL)
(CL:DEFVAR SYM-WALK-DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-WALK-OBJECT NULL)
(CL:DEFVAR SYM-WALK-METHOD-LISP-MACRO? NULL)
(CL:DEFVAR SYM-WALK-STORE-MACRO NULL)
(CL:DEFVAR KWD-WALK-UNBOUND-SPECIAL-VARIABLE NULL)
(CL:DEFVAR KWD-WALK-GLOBALS NULL)
(CL:DEFVAR SYM-WALK-VARIABLE-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-WALK-DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-WALK-GLOBAL NULL)
(CL:DEFVAR SYM-WALK-LOOKUP-GLOBAL-VARIABLE NULL)
(CL:DEFVAR SYM-WALK-VARIABLE-GET-VALUE-CODE NULL)
(CL:DEFVAR SYM-WALK-VARIABLE-SET-VALUE-CODE NULL)
(CL:DEFVAR SYM-WALK-DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR KWD-WALK-FINAL NULL)
(CL:DEFVAR SYM-WALK-CURRENT-STARTUP-TIME-PHASE? NULL)
(CL:DEFVAR KWD-WALK-MODULES NULL)
(CL:DEFVAR SYM-WALK-WITHIN-MODULE NULL)
(CL:DEFVAR SYM-WALK-*STELLA-MODULE* NULL)
(CL:DEFVAR KWD-WALK-AUXILIARY? NULL)
(CL:DEFVAR SYM-WALK-*PENDINGEXCEPTIONHANDLER?* NULL)
(CL:DEFVAR SYM-WALK-*EXCEPTIONHANDLERADDRESS* NULL)
(CL:DEFVAR SYM-WALK-*EXCEPTION* NULL)
(CL:DEFVAR SYM-WALK-SETUP-LONG-JUMP? NULL)
(CL:DEFVAR SGT-WALK-EXCEPTION NULL)
(CL:DEFVAR SYM-WALK-SUBTYPE-OF? NULL)
(CL:DEFVAR SYM-WALK-*EXCEPTION-TYPE* NULL)
(CL:DEFVAR KWD-WALK-OTHERWISE NULL)
(CL:DEFVAR SGT-WALK-CODE NULL)
(CL:DEFVAR SYM-WALK-MAIN NULL)
(CL:DEFVAR SGT-WALK-COMPOUND-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-WALK-DOCUMENTATION NULL)
(CL:DEFVAR SYM-WALK-EXPRESSION NULL)
(CL:DEFVAR SYM-WALK-IGNORE NULL)
(CL:DEFVAR SYM-WALK-INCREMENTALLY-TRANSLATE NULL)
(CL:DEFVAR SYM-WALK-REGISTER-NATIVE-NAME NULL)
(CL:DEFVAR SYM-WALK-REST NULL)
(CL:DEFVAR SYM-WALK-NTH-REST NULL)
(CL:DEFVAR SYM-WALK-NTH NULL)
(CL:DEFVAR SYM-WALK-ARGUMENTS NULL)
(CL:DEFVAR SYM-WALK-RESULT NULL)
(CL:DEFVAR SYM-WALK-METHOD-EVALUATE-ARGUMENTS? NULL)
(CL:DEFVAR SYM-WALK-METHOD-VARIABLE-ARGUMENTS? NULL)
(CL:DEFVAR SYM-WALK-*EVALUATIONERROR?* NULL)
(CL:DEFVAR SYM-WALK-*EVALUATIONTREE* NULL)
(CL:DEFVAR SYM-WALK-*EVALUATIONPARENTTREE* NULL)
(CL:DEFVAR SYM-WALK-EVALUATE NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  NULL-INTEGER-WRAPPER
  NULL-FLOAT-WRAPPER
  NULL-FUNCTION-CODE-WRAPPER
  NULL-STRING-WRAPPER
  *STELLA-MODULE*
  *STARTUP-TIME-PHASES*
  NULL-BOOLEAN-WRAPPER
  TRUE-WRAPPER
  FALSE-WRAPPER
  *SAFETY*
  KEYWORD-SYM
  SURROGATE-SYM
  SYMBOL-SYM
  *TRANSLATOR-OUTPUT-LANGUAGE*
  *RECYCLED-TRANSLATION-UNIT-S*
  *MODULE*
  *CL-TRANSLATED-FILE-SUFFIX*
  STANDARD-OUTPUT
  EOL))

;;; (DEFGLOBAL *AVAILABLE-ENVIRONMENT-FEATURES* ...)

(CL:DEFVAR *AVAILABLE-ENVIRONMENT-FEATURES* NULL
  "List of Stella environment features.")

;;; (DEFGLOBAL *CURRENT-ENVIRONMENT-FEATURES* ...)

(CL:DEFVAR *CURRENT-ENVIRONMENT-FEATURES* NULL
  "List of currently enabled environment features.")

;;; (DEFGLOBAL *DEFAULT-ENVIRONMENT-FEATURES* ...)

(CL:DEFVAR *DEFAULT-ENVIRONMENT-FEATURES* NULL
  "List of features enabled upon call to
'reset-environment-features'.")

;;; (DEFUN DISPLAY-ENVIRONMENT-FEATURES ...)

(CL:DEFUN DISPLAY-ENVIRONMENT-FEATURES ()
  "Print a list of the currently enabled environment 
features and print a list of all Stella environment features."
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "CURRENTLY ENABLED ENVIRONMENT FEATURES:" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:WRITE-STRING "   " %%STREAM)
   (PRINT-OBJECT *CURRENT-ENVIRONMENT-FEATURES* %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:WRITE-STRING "AVAILABLE ENVIRONMENT FEATURES:" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:WRITE-STRING "   " %%STREAM)
   (PRINT-OBJECT *AVAILABLE-ENVIRONMENT-FEATURES* %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  :VOID)

;;; (DEFUN ENABLE-ENVIRONMENT-FEATURE ...)

(CL:DEFUN ENABLE-ENVIRONMENT-FEATURE (CL:&REST FEATURES)
  "Enable the environment feature(s) indicated by the
keywords in 'features'."
  (CL:LET*
   ((F NULL) (ITER-001 (ALLOCATE-ITERATOR FEATURES)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITER-001) 1)
    DO
    (CL:PROGN (CL:SETQ F (CLSYS-SVAL LISP-CONS-ITERATOR VALUE ITER-001)))
    (CL:COND
     ((CL:OR
       (CL:EQ F KWD-WALK-SUPPRESS-WARNINGS)
       (CL:EQ F KWD-WALK-WARN-ABOUT-UNDEFINED-METHODS)
       (CL:EQ F KWD-WALK-USE-BOOTSTRAP-TRANSLATOR)
       (CL:EQ F KWD-WALK-WARN-ABOUT-MISSING-METHODS)
       (CL:EQ F KWD-WALK-USE-HARDCODED-SYMBOLS)
       (CL:EQ F KWD-WALK-USE-COMMON-LISP-STRUCTS)
       (CL:EQ F KWD-WALK-USE-COMMON-LISP-VECTOR-STRUCTS)
       (CL:EQ F KWD-WALK-USE-CPP-GARBAGE-COLLECTOR)
       (CL:EQ F KWD-WALK-TRANSLATE-WITH-COPYRIGHT-HEADER))
      (CL:WHEN
       (CL:EQ (MEMBER? *CURRENT-ENVIRONMENT-FEATURES* F) 0)
       (INSERT *CURRENT-ENVIRONMENT-FEATURES* F)))
     (CL:T
      (CL:IF
       (CL:EQ (MEMBER? *AVAILABLE-ENVIRONMENT-FEATURES* F) 1)
       (CL:ERROR "Oops. Forgot to implement environment feature:  `~A'" F)
       (CL:WARN "Unrecognizable environment feature:  `~A'" F))))
    (CL:COND
     ((CL:EQ F KWD-WALK-USE-COMMON-LISP-STRUCTS)
      (REMOVE
       *CURRENT-ENVIRONMENT-FEATURES*
       KWD-WALK-USE-COMMON-LISP-VECTOR-STRUCTS)
      (CL:SETQ *CL-TRANSLATED-FILE-SUFFIX* ".slisp"))
     ((CL:EQ F KWD-WALK-USE-COMMON-LISP-VECTOR-STRUCTS)
      (CL:WHEN
       (CL:EQ
        (MEMBER?
         *CURRENT-ENVIRONMENT-FEATURES*
         KWD-WALK-USE-COMMON-LISP-STRUCTS)
        0)
       (INSERT
        *CURRENT-ENVIRONMENT-FEATURES*
        KWD-WALK-USE-COMMON-LISP-STRUCTS))
      (CL:SETQ *CL-TRANSLATED-FILE-SUFFIX* ".vslisp"))
     (CL:T NULL))))
  :VOID)

;;; (DEFUN DISABLE-ENVIRONMENT-FEATURE ...)

(CL:DEFUN DISABLE-ENVIRONMENT-FEATURE (CL:&REST FEATURES)
  "Disable the environment feature(s) indicated by the
keywords in 'features'."
  (CL:LET*
   ((F NULL) (ITER-001 (ALLOCATE-ITERATOR FEATURES)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITER-001) 1)
    DO
    (CL:PROGN (CL:SETQ F (CLSYS-SVAL LISP-CONS-ITERATOR VALUE ITER-001)))
    (CL:COND
     ((CL:OR
       (CL:EQ F KWD-WALK-SUPPRESS-WARNINGS)
       (CL:EQ F KWD-WALK-WARN-ABOUT-UNDEFINED-METHODS)
       (CL:EQ F KWD-WALK-USE-BOOTSTRAP-TRANSLATOR)
       (CL:EQ F KWD-WALK-WARN-ABOUT-MISSING-METHODS)
       (CL:EQ F KWD-WALK-USE-HARDCODED-SYMBOLS)
       (CL:EQ F KWD-WALK-USE-COMMON-LISP-STRUCTS)
       (CL:EQ F KWD-WALK-USE-COMMON-LISP-VECTOR-STRUCTS)
       (CL:EQ F KWD-WALK-USE-CPP-GARBAGE-COLLECTOR)
       (CL:EQ F KWD-WALK-TRANSLATE-WITH-COPYRIGHT-HEADER))
      (REMOVE *CURRENT-ENVIRONMENT-FEATURES* F))
     (CL:T
      (CL:IF
       (CL:EQ (MEMBER? *AVAILABLE-ENVIRONMENT-FEATURES* F) 1)
       (CL:ERROR "Oops. Forgot to implement environment feature:  `~A'" F)
       (CL:WARN "Unrecognizable environment feature:  `~A'" F))))
    (CL:COND
     ((CL:OR
       (CL:EQ F KWD-WALK-USE-COMMON-LISP-STRUCTS)
       (CL:EQ F KWD-WALK-USE-COMMON-LISP-VECTOR-STRUCTS))
      (REMOVE *CURRENT-ENVIRONMENT-FEATURES* KWD-WALK-USE-COMMON-LISP-STRUCTS)
      (REMOVE
       *CURRENT-ENVIRONMENT-FEATURES*
       KWD-WALK-USE-COMMON-LISP-VECTOR-STRUCTS)
      (CL:SETQ *CL-TRANSLATED-FILE-SUFFIX* ".lisp"))
     (CL:T NULL))))
  :VOID)

;;; (DEFUN RESET-ENVIRONMENT-FEATURES ...)

(CL:DEFUN RESET-ENVIRONMENT-FEATURES ()
  "Reset the current environment features to their default
settings."
  (CL:LET*
   ((F NULL)
    (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST *CURRENT-ENVIRONMENT-FEATURES*)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ F (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:EQ (MEMBER? *DEFAULT-ENVIRONMENT-FEATURES* F) 0)
     (DISABLE-ENVIRONMENT-FEATURE F))))
  (CL:LET*
   ((F NULL)
    (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST *DEFAULT-ENVIRONMENT-FEATURES*)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-002 NIL))
    DO
    (CL:PROGN
     (CL:SETQ F (CLSYS-SVAL CONS VALUE ITER-002))
     (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
    (CL:WHEN
     (CL:EQ (MEMBER? *CURRENT-ENVIRONMENT-FEATURES* F) 0)
     (ENABLE-ENVIRONMENT-FEATURE F))))
  :VOID)

;;; (DEFGLOBAL *TRACED-KEYWORDS* ...)

(CL:DEFVAR *TRACED-KEYWORDS* NULL)

;;; (DEFMACRO TRACE-IF ...)

(CL:DEFUN TRACE-IF-EXPANDER (KEYWORD BODY)
  (CL:RETURN-FROM
   TRACE-IF-EXPANDER
   (LIST*
    SYM-WALK-WHEN
    (LIST*
     SYM-WALK-AND
     (LIST* SYM-WALK-DEFINED? SYM-WALK-*TRACED-KEYWORDS* NIL)
     (LIST* SYM-WALK-MEMBER? SYM-WALK-*TRACED-KEYWORDS* KEYWORD NIL)
     NIL)
    (CONS SYM-WALK-PRINT (CONCATENATE (COPY-CONS-LIST BODY) NIL))
    NIL))
  :VOID)

;;; (DEFUN (TRACE-KEYWORD? BOOLEAN) ...)

(CL:DEFUN TRACE-KEYWORD? (KEYWORD)
  (CL:RETURN-FROM
   TRACE-KEYWORD?
   (CL:IF
    (CL:AND
     (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (CL:EQ (MEMBER? *TRACED-KEYWORDS* KEYWORD) 1))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (ADD-TRACE LIST) ...)

(CL:DEFUN %%ADD-TRACE (KEYWORDS)
  "Enable trace messages identified by any of the listed `keywords'.  After
calling `(add-trace <keyword>)' code guarded by `(trace-if <keyword> ...)'
will be executed when it is encountered."
  (CL:WHEN (CL:EQ *TRACED-KEYWORDS* NULL) (CL:SETQ *TRACED-KEYWORDS* (LIST)))
  (CL:LET*
   ((K NULL) (ITER-001 KEYWORDS))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ K (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (INSERT-NEW
     *TRACED-KEYWORDS*
     (KEYWORDIFY (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-NAME K)))))
  (CL:RETURN-FROM %%ADD-TRACE *TRACED-KEYWORDS*)
  :VOID)

(CL:DEFUN ADD-TRACE-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM ADD-TRACE-EVALUATOR-WRAPPER (%%ADD-TRACE ARGUMENTS))
  :VOID)

(CL:DEFMACRO ADD-TRACE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Enable trace messages identified by any of the listed `keywords'.  After
calling `(add-trace <keyword>)' code guarded by `(trace-if <keyword> ...)'
will be executed when it is encountered."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /STELLA/ADD-TRACE)) (CL:MACRO-FUNCTION (CL:QUOTE ADD-TRACE)))

;;; (DEFUN (DROP-TRACE LIST) ...)

(CL:DEFUN %%DROP-TRACE (KEYWORDS)
  "Disable trace messages identified by any of the listed `keywords'.  After
calling `(drop-trace <keyword>)' code guarded by `(trace-if <keyword> ...)'
will not be executed when it is encountered."
  (CL:WHEN
   (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
   (CL:LET*
    ((K NULL) (ITER-001 KEYWORDS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ K (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (REMOVE
      *TRACED-KEYWORDS*
      (KEYWORDIFY (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-NAME K)))))
   (CL:WHEN
    (CL:EQ (EMPTY? *TRACED-KEYWORDS*) 1)
    (CL:SETQ *TRACED-KEYWORDS* NULL)))
  (CL:RETURN-FROM %%DROP-TRACE *TRACED-KEYWORDS*)
  :VOID)

(CL:DEFUN DROP-TRACE-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM DROP-TRACE-EVALUATOR-WRAPPER (%%DROP-TRACE ARGUMENTS))
  :VOID)

(CL:DEFMACRO DROP-TRACE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Disable trace messages identified by any of the listed `keywords'.  After
calling `(drop-trace <keyword>)' code guarded by `(trace-if <keyword> ...)'
will not be executed when it is encountered."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /STELLA/DROP-TRACE)) (CL:MACRO-FUNCTION (CL:QUOTE DROP-TRACE)))

;;; (DEFUN CLEAR-TRACE ...)

(CL:DEFUN CLEAR-TRACE ()
  "Disable all tracing previously enabled with `add-trace'."
  (CLEAR *TRACED-KEYWORDS*)
  :VOID)

;;; (DEFGLOBAL *QUOTATION-TABLE* ...)

(CL:DEFVAR *QUOTATION-TABLE* NULL
  "Stores quoted cons trees.")

;;; (DEFUN (NAME-QUOTED-TREE STRING) ...)

(CL:DEFUN NAME-QUOTED-TREE (TREE)
  (CL:LET*
   ((NAMETREE
     (CONS
      TREE
      (CONS
       (WRAP-LITERAL (CLSYS-SVAL MODULE MODULE-FULL-NAME *MODULE*))
       NIL)))
    (NAME (STRINGIFY NAMETREE)))
   (FREE-CONS-LIST NAMETREE)
   (CL:RETURN-FROM NAME-QUOTED-TREE NAME))
  :VOID)

;;; (DEFUN (GET-QUOTED-TREE CONS) ...)

(CL:DEFUN GET-QUOTED-TREE (TREENAME MODULENAME)
  "Return the quoted tree with name 'treeName'."
  (CL:LET*
   ((QUOTEDTREE (LOOKUP *QUOTATION-TABLE* TREENAME)))
   (CL:WHEN
    (CL:NOT (CL:EQ QUOTEDTREE NULL))
    (CL:RETURN-FROM GET-QUOTED-TREE QUOTEDTREE))
   (CL:LET*
    ((*MODULE* (GET-MODULE MODULENAME TRUE)))
    (CL:DECLARE (CL:SPECIAL *MODULE*))
    (CL:LET*
     ((TREE (UNSTRINGIFY TREENAME)))
     (CL:SETQ QUOTEDTREE (PERMANENTIFY-FORM (FIRST TREE)))
     (FREE-PARSE-TREE TREE)
     (INSERT-AT *QUOTATION-TABLE* TREENAME QUOTEDTREE)
     (CL:RETURN-FROM GET-QUOTED-TREE QUOTEDTREE))))
  :VOID)

;;; (DEFCLASS TRANSLATION-UNIT ...)

(CL:DEFCLASS TRANSLATION-UNIT (STANDARD-OBJECT)
  ((THE-OBJECT :ALLOCATION :INSTANCE :ACCESSOR THE-OBJECT...OF)
   (CATEGORY :ALLOCATION :INSTANCE :ACCESSOR CATEGORY...OF)
   (ANNOTATION :ALLOCATION :INSTANCE :ACCESSOR ANNOTATION...OF)
   (AUXILIARY? :ALLOCATION :INSTANCE :ACCESSOR AUXILIARY?...OF)
   (CODE-REGISTER :ALLOCATION :INSTANCE :ACCESSOR CODE-REGISTER...OF)
   (TRANSLATION :ALLOCATION :INSTANCE :ACCESSOR TRANSLATION...OF)
   (REFERENCED-GLOBALS :ALLOCATION :INSTANCE :ACCESSOR REFERENCED-GLOBALS...OF)))

(CL:DEFUN NEW-TRANSLATION-UNIT ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF *RECYCLED-TRANSLATION-UNIT-S*)
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL))
     (CL:SETQ
      *RECYCLED-TRANSLATION-UNIT-S*
      (CLSYS-SVAL TRANSLATION-UNIT TRANSLATION SELF)))
    (CL:T (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRANSLATION-UNIT)))))
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT REFERENCED-GLOBALS SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT TRANSLATION SELF) NULL)
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER SELF) NULL)
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT AUXILIARY? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT ANNOTATION SELF) NULL)
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF) NULL)
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT SELF) NULL)
   (CL:RETURN-FROM NEW-TRANSLATION-UNIT SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF TRANSLATION-UNIT))
  (CL:WHEN
   (CL:NOT (CL:EQ (CLSYS-SVAL TRANSLATION-UNIT REFERENCED-GLOBALS SELF) NULL))
   (FREE (CLSYS-SVAL TRANSLATION-UNIT REFERENCED-GLOBALS SELF)))
  (CL:WHEN (CL:EQ (TERMINATE-TRANSLATION-UNIT? SELF) 0) (CL:RETURN-FROM FREE))
  (CL:SETF
   (CLSYS-SVAL TRANSLATION-UNIT TRANSLATION SELF)
   *RECYCLED-TRANSLATION-UNIT-S*)
  (CL:SETQ *RECYCLED-TRANSLATION-UNIT-S* SELF)
  :VOID)

(CL:DEFUN ACCESS-TRANSLATION-UNIT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-WALK-THE-OBJECT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TRANSLATION-UNIT-SLOT-VALUE
      (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT SELF))))
   ((CL:EQ SLOTNAME SYM-WALK-CATEGORY)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TRANSLATION-UNIT-SLOT-VALUE
      (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF))))
   ((CL:EQ SLOTNAME SYM-WALK-ANNOTATION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRANSLATION-UNIT ANNOTATION SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-TRANSLATION-UNIT-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL TRANSLATION-UNIT ANNOTATION SELF)))))
   ((CL:EQ SLOTNAME SYM-WALK-AUXILIARY?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRANSLATION-UNIT AUXILIARY? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-TRANSLATION-UNIT-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL TRANSLATION-UNIT AUXILIARY? SELF)))))
   ((CL:EQ SLOTNAME SYM-WALK-CODE-REGISTER)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TRANSLATION-UNIT-SLOT-VALUE
      (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER SELF))))
   ((CL:EQ SLOTNAME SYM-WALK-TRANSLATION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT TRANSLATION SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TRANSLATION-UNIT-SLOT-VALUE
      (CLSYS-SVAL TRANSLATION-UNIT TRANSLATION SELF))))
   ((CL:EQ SLOTNAME SYM-WALK-REFERENCED-GLOBALS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT REFERENCED-GLOBALS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TRANSLATION-UNIT-SLOT-VALUE
      (CLSYS-SVAL TRANSLATION-UNIT REFERENCED-GLOBALS SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-TRANSLATION-UNIT-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSLATION-UNIT))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-WALK-TRANSLATION-UNIT)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF TRANSLATION-UNIT) STREAM)
  (PRINT-TRANSLATION-UNIT SELF STREAM)
  :VOID)

;;; (DEFUN (TERMINATE-TRANSLATION-UNIT? BOOLEAN) ...)

(CL:DEFUN TERMINATE-TRANSLATION-UNIT? (SELF)
  (CL:LET*
   ((TRANSLATION (CLSYS-SVAL TRANSLATION-UNIT TRANSLATION SELF)))
   (CL:WHEN (CL:NOT (CL:EQ TRANSLATION NULL)) (FREE-PARSE-TREE TRANSLATION)))
  (CL:RETURN-FROM TERMINATE-TRANSLATION-UNIT? TRUE)
  :VOID)

;;; (DEFUN PRINT-TRANSLATION-UNIT ...)

(CL:DEFUN PRINT-TRANSLATION-UNIT (SELF STREAM)
  (CL:PROGN
   (CL:WRITE-STRING "|TU|[" STREAM)
   (PRINT-OBJECT (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF) STREAM))
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF)))
   (CL:COND
    ((CL:OR
      (CL:EQ TEST-VALUE-001 SYM-WALK-CLASS)
      (CL:EQ TEST-VALUE-001 SYM-WALK-METHOD)
      (CL:EQ TEST-VALUE-001 SYM-WALK-MACRO)
      (CL:EQ TEST-VALUE-001 SYM-WALK-GLOBAL-VARIABLE))
     (CL:PROGN
      (CL:WRITE-STRING " " STREAM)
      (PRINT-OBJECT (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT SELF) STREAM)))
    (CL:T NULL)))
  (CL:WRITE-STRING "]" STREAM)
  :VOID)

;;; (DEFSPECIAL *TRANSLATIONUNITS* ...)

(CL:DEFVAR *TRANSLATIONUNITS* NULL
  "List of objects representing partially walked
top-level definitions and auxiliary code.")

(CL:DEFUN READ-*TRANSLATIONUNITS* ()
  (CL:RETURN-FROM READ-*TRANSLATIONUNITS* *TRANSLATIONUNITS*)
  :VOID)

(CL:DEFUN WRITE-*TRANSLATIONUNITS* (VALUE)
  (CL:SETQ *TRANSLATIONUNITS* VALUE)
  (CL:RETURN-FROM WRITE-*TRANSLATIONUNITS* VALUE)
  :VOID)

;;; (DEFSPECIAL *CURRENTTRANSLATIONUNIT* ...)

(CL:DEFVAR *CURRENTTRANSLATIONUNIT* NULL
  "The translation unit currently operated on.")

(CL:DEFUN READ-*CURRENTTRANSLATIONUNIT* ()
  (CL:RETURN-FROM READ-*CURRENTTRANSLATIONUNIT* *CURRENTTRANSLATIONUNIT*)
  :VOID)

(CL:DEFUN WRITE-*CURRENTTRANSLATIONUNIT* (VALUE)
  (CL:SETQ *CURRENTTRANSLATIONUNIT* VALUE)
  (CL:RETURN-FROM WRITE-*CURRENTTRANSLATIONUNIT* VALUE)
  :VOID)

;;; (DEFSPECIAL *TRANSLATIONPHASE* ...)

(CL:DEFVAR *TRANSLATIONPHASE* NULL
  "Indicates the current translation phase which is one of
:DEFINE, :FINALIZE, :WALK, or :TRANSLATE.")

(CL:DEFUN READ-*TRANSLATIONPHASE* ()
  (CL:RETURN-FROM READ-*TRANSLATIONPHASE* *TRANSLATIONPHASE*)
  :VOID)

(CL:DEFUN WRITE-*TRANSLATIONPHASE* (VALUE)
  (CL:SETQ *TRANSLATIONPHASE* VALUE)
  (CL:RETURN-FROM WRITE-*TRANSLATIONPHASE* VALUE)
  :VOID)

;;; (DEFSPECIAL *TRANSLATIONVERBOSITYLEVEL* ...)

(CL:DEFVAR *TRANSLATIONVERBOSITYLEVEL* 1
  "The higher the level, the more progress annotations are
generated during the translation of Stella declarations.")

(CL:DEFUN READ-*TRANSLATIONVERBOSITYLEVEL* ()
  (CL:RETURN-FROM READ-*TRANSLATIONVERBOSITYLEVEL* *TRANSLATIONVERBOSITYLEVEL*)
  :VOID)

(CL:DEFUN WRITE-*TRANSLATIONVERBOSITYLEVEL* (VALUE)
  (CL:SETQ *TRANSLATIONVERBOSITYLEVEL* VALUE)
  (CL:RETURN-FROM WRITE-*TRANSLATIONVERBOSITYLEVEL* VALUE)
  :VOID)

;;; (DEFSPECIAL *USEHARDCODEDSYMBOLS?* ...)

(CL:DEFVAR *USEHARDCODEDSYMBOLS?* FALSE)

(CL:DEFUN READ-*USEHARDCODEDSYMBOLS?* ()
  (CL:RETURN-FROM READ-*USEHARDCODEDSYMBOLS?* *USEHARDCODEDSYMBOLS?*)
  :VOID)

(CL:DEFUN WRITE-*USEHARDCODEDSYMBOLS?* (VALUE)
  (CL:SETQ *USEHARDCODEDSYMBOLS?* VALUE)
  (CL:RETURN-FROM WRITE-*USEHARDCODEDSYMBOLS?* VALUE)
  :VOID)

;;; (DEFUN (USE-HARDCODED-SYMBOLS? BOOLEAN) ...)

(CL:DEFUN USE-HARDCODED-SYMBOLS? ()
  (CL:RETURN-FROM
   USE-HARDCODED-SYMBOLS?
   (CL:IF
    (CL:OR
     (CL:EQ
      (MEMBER? *CURRENT-ENVIRONMENT-FEATURES* KWD-WALK-USE-HARDCODED-SYMBOLS)
      1)
     (CL:EQ *USEHARDCODEDSYMBOLS?* 1))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (USE-BOOTSTRAP-TRANSLATOR? BOOLEAN) ...)

(CL:DEFUN USE-BOOTSTRAP-TRANSLATOR? ()
  (CL:RETURN-FROM
   USE-BOOTSTRAP-TRANSLATOR?
   (MEMBER? *CURRENT-ENVIRONMENT-FEATURES* KWD-WALK-USE-BOOTSTRAP-TRANSLATOR))
  :VOID)

;;; (DEFUN (TOGGLE-TRANSLATORS KEYWORD) ...)

(CL:DEFUN TOGGLE-TRANSLATORS ()
  "Switch between the bootstrap and real translators."
  (CL:IF
   (CL:EQ (USE-BOOTSTRAP-TRANSLATOR?) 1)
   (CL:PROGN
    (DISABLE-ENVIRONMENT-FEATURE KWD-WALK-USE-BOOTSTRAP-TRANSLATOR)
    (CL:RETURN-FROM TOGGLE-TRANSLATORS KWD-WALK-REAL))
   (CL:PROGN
    (ENABLE-ENVIRONMENT-FEATURE KWD-WALK-USE-BOOTSTRAP-TRANSLATOR)
    (CL:RETURN-FROM TOGGLE-TRANSLATORS KWD-WALK-BOOTSTRAP)))
  :VOID)

;;; (DEFUN (TRANSLATE-TO-COMMON-LISP? BOOLEAN) ...)

(CL:DEFUN TRANSLATE-TO-COMMON-LISP? ()
  "Return TRUE if current output language is Common-Lisp."
  (CL:RETURN-FROM
   TRANSLATE-TO-COMMON-LISP?
   (EQ? *TRANSLATOR-OUTPUT-LANGUAGE* KWD-WALK-COMMON-LISP))
  :VOID)

;;; (DEFUN (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE? BOOLEAN) ...)

(CL:DEFUN TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE? ()
  (CL:RETURN-FROM
   TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?
   (CL:IF
    (CL:OR
     (CL:EQ *TRANSLATOR-OUTPUT-LANGUAGE* KWD-WALK-JAVA)
     (CL:AND
      (CL:EQ *TRANSLATOR-OUTPUT-LANGUAGE* KWD-WALK-COMMON-LISP)
      (CL:EQ
       (MEMBER?
        *CURRENT-ENVIRONMENT-FEATURES*
        KWD-WALK-USE-COMMON-LISP-STRUCTS)
       1)))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (TOGGLE-OUTPUT-LANGUAGE KEYWORD) ...)

(CL:DEFUN TOGGLE-OUTPUT-LANGUAGE ()
  "Switch between Common Lisp and C++ as output languages."
  (CL:IF
   (CL:EQ (TRANSLATE-TO-COMMON-LISP?) 1)
   (CL:PROGN
    (CL:SETQ *TRANSLATOR-OUTPUT-LANGUAGE* KWD-WALK-CPP)
    (CL:RETURN-FROM TOGGLE-OUTPUT-LANGUAGE KWD-WALK-CPP))
   (CL:PROGN
    (CL:SETQ *TRANSLATOR-OUTPUT-LANGUAGE* KWD-WALK-COMMON-LISP)
    (CL:RETURN-FROM TOGGLE-OUTPUT-LANGUAGE KWD-WALK-COMMON-LISP)))
  :VOID)

;;; (DEFUN (DECLARATION-OPERATOR? BOOLEAN) ...)

(CL:DEFUN DECLARATION-OPERATOR? (OPERATOR)
  (CL:RETURN-FROM
   DECLARATION-OPERATOR?
   (MEMBER?
    (GET-QUOTED-TREE
     "((DEFCLASS DEFSLOT DEFMETHOD DEFUN DEFTYPE DEFGLOBAL DEFSPECIAL DEFCONSTANT DEFMACRO DEFMODULE STARTUP-TIME-PROGN) \"/STELLA\")"
     "/STELLA")
    OPERATOR))
  :VOID)

;;; (DEFUN (DECLARATION-TREE? BOOLEAN) ...)

(CL:DEFUN DECLARATION-TREE? (TREE)
  (CL:LET*
   ((OPERATOR (CLSYS-SVAL CONS VALUE TREE)))
   (CL:WHEN
    (CL:EQ (DECLARATION-OPERATOR? OPERATOR) 1)
    (CL:RETURN-FROM DECLARATION-TREE? TRUE))
   (CL:WHEN
    (CL:EQ OPERATOR SYM-WALK-PROGN)
    (CL:LET*
     ((FOUND?-001 FALSE))
     (CL:LET*
      ((SUBTREE NULL) (ITER-001 (CLSYS-SVAL CONS REST TREE)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ SUBTREE (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (CL:WHEN
        (CL:AND
         (CL:EQ (CONS? SUBTREE) 1)
         (CL:EQ (DECLARATION-TREE? SUBTREE) 1))
        (CL:SETQ FOUND?-001 TRUE)
        (CL:RETURN))))
     (CL:LET*
      ((VALUE-001 FOUND?-001))
      (CL:RETURN-FROM DECLARATION-TREE? VALUE-001))))
   (CL:WHEN
    (CL:NOT (CL:EQ (LOOKUP-MACRO OPERATOR) NULL))
    (CL:LET*
     ((*TRANSIENTOBJECTS?* TRUE))
     (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
     (CL:LET*
      ((EXPANSION (EXPAND-MACRO (COPY-CONS-LIST TREE))))
      (CL:COND
       ((CL:NOT (CL:EQ EXPANSION NULL))
        (CL:LET*
         ((EXPANSION-001 EXPANSION))
         (CL:COND
          ((CL:EQ (CONS? EXPANSION) 1)
           (CL:LET*
            ((EXPANSION NULL))
            (CL:SETQ EXPANSION EXPANSION-001)
            (CL:SETF
             (CLSYS-SVAL CONS VALUE TREE)
             (CLSYS-SVAL CONS VALUE EXPANSION))
            (CL:SETF
             (CLSYS-SVAL CONS REST TREE)
             (CLSYS-SVAL CONS REST EXPANSION))
            (CL:RETURN-FROM DECLARATION-TREE? (DECLARATION-TREE? TREE))))
          (CL:T (CL:RETURN-FROM DECLARATION-TREE? FALSE)))))
       (CL:T
        (CL:SETF (CLSYS-SVAL CONS VALUE TREE) SYM-WALK-PROGN)
        (CL:SETF (CLSYS-SVAL CONS REST TREE) NIL)
        (CL:RETURN-FROM DECLARATION-TREE? FALSE))))))
   (CL:RETURN-FROM DECLARATION-TREE? FALSE))
  :VOID)

;;; (DEFUN (CREATE-ANNOTATION STRING) ...)

(CL:DEFUN CREATE-ANNOTATION (TOP-LEVEL-TREE)
  (CL:RETURN-FROM
   CREATE-ANNOTATION
   (CONCATENATE
    "("
    (CONCATENATE
     (CLSYS-SVAL SYMBOL SYMBOL-NAME (FIRST TOP-LEVEL-TREE))
     (CONCATENATE
      " "
      (CONCATENATE (STRINGIFY (SECOND TOP-LEVEL-TREE)) " ...)")))))
  :VOID)

;;; (DEFUN WALK-TOP-LEVEL-TREE ...)

(CL:DEFUN WALK-TOP-LEVEL-TREE (TREE CREATEANNOTATION?)
  (CL:LET*
   ((*TRANSIENTOBJECTS?* TRUE))
   (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
   (CL:LET*
    ((*CURRENTTRANSLATIONUNIT* NULL))
    (CL:DECLARE (CL:SPECIAL *CURRENTTRANSLATIONUNIT*))
    (CL:LET*
     ((ANNOTATION NULL))
     (CL:WHEN
      (CL:EQ CREATEANNOTATION? 1)
      (CL:SETQ ANNOTATION (CREATE-ANNOTATION TREE))
      (CL:WHEN
       (CL:>= *TRANSLATIONVERBOSITYLEVEL* 2)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING "Defining `" %%STREAM)
        (CL:WRITE-STRING ANNOTATION %%STREAM)
        (CL:WRITE-STRING "'" %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     (CL:LET*
      ((TEST-VALUE-001 (FIRST TREE)))
      (CL:COND
       ((CL:EQ TEST-VALUE-001 SYM-WALK-DEFCLASS) (WALK-DEFCLASS-TREE TREE))
       ((CL:EQ TEST-VALUE-001 SYM-WALK-DEFSLOT) (WALK-DEFSLOT-TREE TREE))
       ((CL:OR
         (CL:EQ TEST-VALUE-001 SYM-WALK-DEFMETHOD)
         (CL:EQ TEST-VALUE-001 SYM-WALK-DEFUN)
         (CL:EQ TEST-VALUE-001 SYM-WALK-DEFOPERATOR))
        (CL:WHEN
         (CL:EQ (FIRST TREE) SYM-WALK-DEFOPERATOR)
         (FIRST-SETTER TREE SYM-WALK-DEFMETHOD))
        (WALK-DEFMETHOD-TREE TREE))
       ((CL:OR
         (CL:EQ TEST-VALUE-001 SYM-WALK-DEFGLOBAL)
         (CL:EQ TEST-VALUE-001 SYM-WALK-DEFSPECIAL)
         (CL:EQ TEST-VALUE-001 SYM-WALK-DEFCONSTANT))
        (WALK-DEFGLOBAL-TREE TREE))
       ((CL:EQ TEST-VALUE-001 SYM-WALK-DEFTYPE) (WALK-DEFTYPE-TREE TREE))
       ((CL:EQ TEST-VALUE-001 SYM-WALK-DEFMODULE) (WALK-DEFMODULE-TREE TREE))
       ((CL:EQ TEST-VALUE-001 SYM-WALK-DEFMACRO) (WALK-DEFMACRO-TREE TREE))
       ((CL:EQ TEST-VALUE-001 SYM-WALK-STARTUP-TIME-PROGN)
        (WALK-STARTUP-TIME-PROGN-TREE TREE))
       ((CL:EQ TEST-VALUE-001 SYM-WALK-VERBATIM)
        (WALK-VERBATIM-DEFINITION-TREE TREE))
       ((CL:EQ TEST-VALUE-001 SYM-WALK-PROGN)
        (CL:LET*
         ((FORM NULL) (ITER-001 (CLSYS-SVAL CONS REST TREE)))
         (CL:LOOP
          WHILE
          (CL:NOT (CL:EQ ITER-001 NIL))
          DO
          (CL:PROGN
           (CL:SETQ FORM (CLSYS-SVAL CONS VALUE ITER-001))
           (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
          (WALK-TOP-LEVEL-TREE FORM CREATEANNOTATION?)))
        (FREE-CONS-LIST TREE)
        (CL:RETURN-FROM WALK-TOP-LEVEL-TREE))
       (CL:T
        (CL:COND
         ((CL:NOT (CL:EQ (LOOKUP-MACRO (FIRST TREE)) NULL))
          (CL:LET*
           ((EXPANSION (EXPAND-MACRO TREE)))
           (CL:WHEN
            (CL:NOT (CL:EQ EXPANSION NULL))
            (WALK-TOP-LEVEL-TREE EXPANSION CREATEANNOTATION?))))
         (CL:T
          (CL:WHEN
           (CL:NOT
            (CL:OR
             (CL:EQ (INCREMENTAL-TRANSLATION?) 1)
             (CL:NOT (CL:EQ (LOOKUP-COMMAND (FIRST TREE)) NULL))))
           (CL:LET*
            ((*PRINTREADABLY?* TRUE))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-WARNING)
            (CL:WHEN
             (CL:EQ (SUPPRESS-WARNINGS?) 0)
             (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
             (CL:LET
              ((%%STREAM
                (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING " Illegal top-level statement:" %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING "   `" %%STREAM)
              (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
              (CL:WRITE-STRING "'" %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING
               " Wrapping it into a 'startup-time-progn'."
               %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)))))
          (CL:LET*
           ((*TRANSIENTOBJECTS?* TRUE))
           (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
           (CL:SETQ TREE (LIST* SYM-WALK-STARTUP-TIME-PROGN TREE NIL)))
          (WALK-TOP-LEVEL-TREE TREE FALSE)))
        (CL:RETURN-FROM WALK-TOP-LEVEL-TREE))))
     (CL:WHEN
      (CL:NOT (CL:EQ *CURRENTTRANSLATIONUNIT* NULL))
      (PUSH *TRANSLATIONUNITS* *CURRENTTRANSLATIONUNIT*)
      (CL:SETF
       (CLSYS-SVAL TRANSLATION-UNIT ANNOTATION *CURRENTTRANSLATIONUNIT*)
       ANNOTATION)))))
  :VOID)

;;; (DEFUN (WALK-TOP-LEVEL-EXPRESSION OBJECT) ...)

(CL:DEFUN WALK-TOP-LEVEL-EXPRESSION (TREE)
  (CL:LET*
   ((*LOCALVARIABLETYPETABLE* (NEW-KEY-VALUE-LIST)))
   (CL:DECLARE (CL:SPECIAL *LOCALVARIABLETYPETABLE*))
   (CL:LET*
    ((OTREE (WALK-WITHOUT-TYPE-TREE TREE)))
    (CL:WHEN
     (CL:EQ (VRLET-EXPRESSION? OTREE) 1)
     (CL:RETURN-FROM
      WALK-TOP-LEVEL-EXPRESSION
      (WALK-WITHOUT-TYPE-TREE (LIST* SYM-WALK-PROGN OTREE NIL))))
    (CL:RETURN-FROM WALK-TOP-LEVEL-EXPRESSION OTREE)))
  :VOID)

;;; (DEFUN WALK-PHASE-ONE-UNIT ...)

(CL:DEFUN WALK-PHASE-ONE-UNIT (UNIT)
  (CL:LET*
   ((*LOCALVARIABLETYPETABLE* (NEW-KEY-VALUE-LIST))
    (*CURRENTTRANSLATIONUNIT* UNIT))
   (CL:DECLARE (CL:SPECIAL *LOCALVARIABLETYPETABLE* *CURRENTTRANSLATIONUNIT*))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* TRUE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:LET*
     ((TEST-VALUE-001 (CLSYS-SVAL TRANSLATION-UNIT CATEGORY UNIT)))
     (CL:COND
      ((CL:EQ TEST-VALUE-001 SYM-WALK-GLOBAL-VARIABLE)
       (WALK-GLOBAL-UNIT UNIT))
      ((CL:EQ TEST-VALUE-001 SYM-WALK-MODULE) (WALK-MODULE-UNIT UNIT))
      ((CL:EQ TEST-VALUE-001 SYM-WALK-TYPE) (WALK-TYPE-UNIT UNIT))
      ((CL:OR
        (CL:EQ TEST-VALUE-001 SYM-WALK-METHOD)
        (CL:EQ TEST-VALUE-001 SYM-WALK-PRINT-METHOD))
       (WALK-METHOD-UNIT UNIT))
      ((CL:EQ TEST-VALUE-001 SYM-WALK-MACRO) (WALK-MACRO-UNIT UNIT))
      ((CL:EQ TEST-VALUE-001 SYM-WALK-CLASS) (WALK-CLASS-UNIT UNIT))
      ((CL:EQ TEST-VALUE-001 SYM-WALK-SLOT) (WALK-SLOT-UNIT UNIT))
      ((CL:EQ TEST-VALUE-001 SYM-WALK-STARTUP-TIME-PROGN)
       (WALK-STARTUP-TIME-PROGN-UNIT UNIT))
      ((CL:EQ TEST-VALUE-001 SYM-WALK-VERBATIM) (WALK-VERBATIM-UNIT UNIT))
      (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))))
  :VOID)

;;; (DEFUN WALK-AUXILIARY-TREE ...)

(CL:DEFUN WALK-AUXILIARY-TREE (TREE)
  (HELP-WALK-AUXILIARY-TREE TREE TRUE)
  :VOID)

;;; (DEFUN (HELP-WALK-AUXILIARY-TREE TRANSLATION-UNIT) ...)

(CL:DEFUN HELP-WALK-AUXILIARY-TREE (TREE FINALIZE?)
  (CL:WHEN
   (CL:EQ
    (MEMBER?
     (GET-QUOTED-TREE
      "((DEFCLASS DEFMETHOD DEFUN DEFMACRO DEFGLOBAL DEFSPECIAL DEFCONSTANT STARTUP-TIME-PROGN VERBATIM) \"/STELLA\")"
      "/STELLA")
     (FIRST TREE))
    0)
   (CL:ERROR "OOPS, illegal auxiliary statement:~%   `~A'" TREE))
  (WALK-TOP-LEVEL-TREE TREE FALSE)
  (CL:WHEN
   (CL:EQ FINALIZE? 1)
   (CL:LET*
    ((*TRANSIENTOBJECTS?* FALSE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (FINALIZE-CLASSES-AND-SLOTS)))
  (CL:LET*
   ((UNIT (POP *TRANSLATIONUNITS*)))
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT AUXILIARY? UNIT) TRUE)
   (WALK-PHASE-ONE-UNIT UNIT)
   (CL:RETURN-FROM HELP-WALK-AUXILIARY-TREE UNIT))
  :VOID)

;;; (DEFUN WALK-ALL-PHASE-ONE-UNITS ...)

(CL:DEFUN WALK-ALL-PHASE-ONE-UNITS (STARTUPFNNAME)
  (CL:LET*
   ((PHASEONEUNITS *TRANSLATIONUNITS*))
   (CL:SETQ *TRANSLATIONUNITS* (NEW-LIST))
   (CL:LET*
    ((UNIT NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST PHASEONEUNITS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ UNIT (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:AND
       (CL:>= *TRANSLATIONVERBOSITYLEVEL* 2)
       (CL:NOT (CL:EQ (CLSYS-SVAL TRANSLATION-UNIT ANNOTATION UNIT) NULL)))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "Walking `" %%STREAM)
       (CL:WRITE-STRING
        (CLSYS-SVAL TRANSLATION-UNIT ANNOTATION UNIT)
        %%STREAM)
       (CL:WRITE-STRING "'" %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))
     (WALK-PHASE-ONE-UNIT UNIT)))
   (CREATE-FINALIZATION-UNITS)
   (CREATE-STARTUP-FUNCTION-UNIT STARTUPFNNAME)
   (CLEAR PHASEONEUNITS)
   (REVERSE *TRANSLATIONUNITS*))
  :VOID)

;;; (DEFUN TRANSLATE-ALL-UNITS ...)

(CL:DEFUN TRANSLATE-ALL-UNITS ()
  (CL:LET*
   ((UNIT NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST *TRANSLATIONUNITS*)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ UNIT (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:LET*
     ((*CURRENTTRANSLATIONUNIT* UNIT))
     (CL:DECLARE (CL:SPECIAL *CURRENTTRANSLATIONUNIT*))
     (CL:WHEN
      (CL:AND
       (CL:>= *TRANSLATIONVERBOSITYLEVEL* 2)
       (CL:NOT (CL:EQ (CLSYS-SVAL TRANSLATION-UNIT ANNOTATION UNIT) NULL)))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "Translating `" %%STREAM)
       (CL:WRITE-STRING
        (CLSYS-SVAL TRANSLATION-UNIT ANNOTATION UNIT)
        %%STREAM)
       (CL:WRITE-STRING "'" %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))
     (CL:LET*
      ((TEST-VALUE-001 (TRANSLATOR-OUTPUT-LANGUAGE)))
      (CL:COND
       ((CL:EQ TEST-VALUE-001 KWD-WALK-COMMON-LISP)
        (CL:SETF
         (CLSYS-SVAL TRANSLATION-UNIT TRANSLATION UNIT)
         (CL-TRANSLATE-UNIT UNIT)))
       ((CL:EQ TEST-VALUE-001 KWD-WALK-IDL)
        (CL:SETF
         (CLSYS-SVAL TRANSLATION-UNIT TRANSLATION UNIT)
         (IDL-TRANSLATE-UNIT UNIT)))
       ((CL:EQ TEST-VALUE-001 KWD-WALK-JAVA)
        (CL:SETF
         (CLSYS-SVAL TRANSLATION-UNIT TRANSLATION UNIT)
         (JAVA-TRANSLATE-UNIT UNIT)))
       ((CL:OR
         (CL:EQ TEST-VALUE-001 KWD-WALK-CPP)
         (CL:EQ TEST-VALUE-001 KWD-WALK-CPP-STANDALONE))
        (CL:SETF
         (CLSYS-SVAL TRANSLATION-UNIT TRANSLATION UNIT)
         (CPP-TRANSLATE-UNIT UNIT)))
       (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001)))))))
  :VOID)

;;; (DEFUN (COMBINE-TRANSLATED-TREES CONS) ...)

(CL:DEFUN COMBINE-TRANSLATED-TREES ()
  (CL:LET*
   ((OTREE NIL))
   (CL:LET*
    ((UNIT NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST *TRANSLATIONUNITS*))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ UNIT (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ
        COLLECT-001
        (CONS (CLSYS-SVAL TRANSLATION-UNIT TRANSLATION UNIT) NIL))
       (CL:IF
        (CL:EQ OTREE NIL)
        (CL:SETQ OTREE COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST OTREE COLLECT-001)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-001)
        (CONS (CLSYS-SVAL TRANSLATION-UNIT TRANSLATION UNIT) NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:LET*
    ((TEST-VALUE-001 (TRANSLATOR-OUTPUT-LANGUAGE)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-WALK-COMMON-LISP)
      (CL:SETQ
       OTREE
       (CONS (INTERN-COMMON-LISP-SYMBOL "PROGN") (CONCATENATE OTREE NIL))))
     ((CL:OR
       (CL:EQ TEST-VALUE-001 KWD-WALK-CPP)
       (CL:EQ TEST-VALUE-001 KWD-WALK-CPP-STANDALONE)
       (CL:EQ TEST-VALUE-001 KWD-WALK-JAVA)
       (CL:EQ TEST-VALUE-001 KWD-WALK-IDL)))
     (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
   (CL:RETURN-FROM COMBINE-TRANSLATED-TREES OTREE))
  :VOID)

;;; (DEFUN (TRANSLATE-WALKED-TREE OBJECT) ...)

(CL:DEFUN TRANSLATE-WALKED-TREE (CODETREE)
  (CL:LET*
   ((TEST-VALUE-001 (TRANSLATOR-OUTPUT-LANGUAGE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-WALK-COMMON-LISP)
     (CL:RETURN-FROM TRANSLATE-WALKED-TREE (CL-TRANSLATE-A-TREE CODETREE)))
    ((CL:EQ TEST-VALUE-001 KWD-WALK-IDL)
     (CL:RETURN-FROM TRANSLATE-WALKED-TREE (IDL-TRANSLATE-A-TREE CODETREE)))
    ((CL:EQ TEST-VALUE-001 KWD-WALK-JAVA)
     (CL:RETURN-FROM TRANSLATE-WALKED-TREE (JAVA-TRANSLATE-A-TREE CODETREE)))
    ((CL:OR
      (CL:EQ TEST-VALUE-001 KWD-WALK-CPP)
      (CL:EQ TEST-VALUE-001 KWD-WALK-CPP-STANDALONE))
     (CL:RETURN-FROM TRANSLATE-WALKED-TREE (CPP-TRANSLATE-A-TREE CODETREE)))
    (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
  :VOID)

;;; (DEFSPECIAL *LOCALVARIABLETYPETABLE* ...)

(CL:DEFVAR *LOCALVARIABLETYPETABLE*)

(CL:DEFUN READ-*LOCALVARIABLETYPETABLE* ()
  (CL:RETURN-FROM READ-*LOCALVARIABLETYPETABLE* *LOCALVARIABLETYPETABLE*)
  :VOID)

(CL:DEFUN WRITE-*LOCALVARIABLETYPETABLE* (VALUE)
  (CL:SETQ *LOCALVARIABLETYPETABLE* VALUE)
  (CL:RETURN-FROM WRITE-*LOCALVARIABLETYPETABLE* VALUE)
  :VOID)

;;; (DEFSPECIAL *METHODBEINGWALKED* ...)

(CL:DEFVAR *METHODBEINGWALKED* NULL
  "Contains the method or function being walked, or else NULL.")

(CL:DEFUN READ-*METHODBEINGWALKED* ()
  (CL:RETURN-FROM READ-*METHODBEINGWALKED* *METHODBEINGWALKED*)
  :VOID)

(CL:DEFUN WRITE-*METHODBEINGWALKED* (VALUE)
  (CL:SETQ *METHODBEINGWALKED* VALUE)
  (CL:RETURN-FROM WRITE-*METHODBEINGWALKED* VALUE)
  :VOID)

;;; (DEFSPECIAL *FOUNDRETURN?* ...)

(CL:DEFVAR *FOUNDRETURN?* FALSE
  "Indicates that one or more return statements have been found
during the walk of the current method.")

(CL:DEFUN READ-*FOUNDRETURN?* ()
  (CL:RETURN-FROM READ-*FOUNDRETURN?* *FOUNDRETURN?*)
  :VOID)

(CL:DEFUN WRITE-*FOUNDRETURN?* (VALUE)
  (CL:SETQ *FOUNDRETURN?* VALUE)
  (CL:RETURN-FROM WRITE-*FOUNDRETURN?* VALUE)
  :VOID)

;;; (DEFSPECIAL *TARGETTYPE* ...)

(CL:DEFVAR *TARGETTYPE* NULL
  "Bound to the target type for an expression currently walked.
Used instead of an extra argument to 'walk-a-tree', since only a few types
of expressions need to know about their expected type (e.g., FUNCALL).")

(CL:DEFUN READ-*TARGETTYPE* ()
  (CL:RETURN-FROM READ-*TARGETTYPE* *TARGETTYPE*)
  :VOID)

(CL:DEFUN WRITE-*TARGETTYPE* (VALUE)
  (CL:SETQ *TARGETTYPE* VALUE)
  (CL:RETURN-FROM WRITE-*TARGETTYPE* VALUE)
  :VOID)

;;; (DEFSPECIAL *LOCALGENSYMTABLE* ...)

(CL:DEFVAR *LOCALGENSYMTABLE* NULL
  "Table that maps each prefix of a function-local gensym
to its own gensym counter.")

(CL:DEFUN READ-*LOCALGENSYMTABLE* ()
  (CL:RETURN-FROM READ-*LOCALGENSYMTABLE* *LOCALGENSYMTABLE*)
  :VOID)

(CL:DEFUN WRITE-*LOCALGENSYMTABLE* (VALUE)
  (CL:SETQ *LOCALGENSYMTABLE* VALUE)
  (CL:RETURN-FROM WRITE-*LOCALGENSYMTABLE* VALUE)
  :VOID)

;;; (DEFUN (TRANSLATOR-OUTPUT-LANGUAGE KEYWORD) ...)

(CL:DEFUN TRANSLATOR-OUTPUT-LANGUAGE ()
  (CL:RETURN-FROM TRANSLATOR-OUTPUT-LANGUAGE *TRANSLATOR-OUTPUT-LANGUAGE*)
  :VOID)

;;; (DEFUN (SET-TRANSLATOR-OUTPUT-LANGUAGE KEYWORD) ...)

(CL:DEFUN SET-TRANSLATOR-OUTPUT-LANGUAGE (NEWLANGUAGE)
  (CL:LET*
   ((OLDLANGUAGE (TRANSLATOR-OUTPUT-LANGUAGE)))
   (CL:WHEN
    (CL:EQ
     (MEMBER?
      (LIST*
       KWD-WALK-CPP
       KWD-WALK-CPP-STANDALONE
       KWD-WALK-COMMON-LISP
       KWD-WALK-JAVA
       KWD-WALK-IDL
       NIL)
      NEWLANGUAGE)
     0)
    (CL:WARN "`~A' is not a legal translation language" NEWLANGUAGE))
   (CL:SETQ *TRANSLATOR-OUTPUT-LANGUAGE* NEWLANGUAGE)
   (CL:RETURN-FROM SET-TRANSLATOR-OUTPUT-LANGUAGE OLDLANGUAGE))
  :VOID)

;;; (DEFSPECIAL *TRANSLATIONERRORS* ...)

(CL:DEFVAR *TRANSLATIONERRORS* 0)

(CL:DEFUN READ-*TRANSLATIONERRORS* ()
  (CL:RETURN-FROM READ-*TRANSLATIONERRORS* *TRANSLATIONERRORS*)
  :VOID)

(CL:DEFUN WRITE-*TRANSLATIONERRORS* (VALUE)
  (CL:SETQ *TRANSLATIONERRORS* VALUE)
  (CL:RETURN-FROM WRITE-*TRANSLATIONERRORS* VALUE)
  :VOID)

;;; (DEFSPECIAL *TRANSLATIONWARNINGS* ...)

(CL:DEFVAR *TRANSLATIONWARNINGS* 0)

(CL:DEFUN READ-*TRANSLATIONWARNINGS* ()
  (CL:RETURN-FROM READ-*TRANSLATIONWARNINGS* *TRANSLATIONWARNINGS*)
  :VOID)

(CL:DEFUN WRITE-*TRANSLATIONWARNINGS* (VALUE)
  (CL:SETQ *TRANSLATIONWARNINGS* VALUE)
  (CL:RETURN-FROM WRITE-*TRANSLATIONWARNINGS* VALUE)
  :VOID)

;;; (DEFUN RESET-TRANSLATION-ERRORS ...)

(CL:DEFUN RESET-TRANSLATION-ERRORS ()
  (CL:SETQ *TRANSLATIONERRORS* 0)
  (CL:SETQ *TRANSLATIONWARNINGS* 0)
  :VOID)

;;; (DEFUN SIGNAL-TRANSLATION-ERROR ...)

(CL:DEFUN SIGNAL-TRANSLATION-ERROR ()
  (CL:SETQ *TRANSLATIONERRORS* (CL:1+ *TRANSLATIONERRORS*))
  :VOID)

;;; (DEFUN SIGNAL-TRANSLATION-WARNING ...)

(CL:DEFUN SIGNAL-TRANSLATION-WARNING ()
  (CL:SETQ *TRANSLATIONWARNINGS* (CL:1+ *TRANSLATIONWARNINGS*))
  :VOID)

;;; (DEFSPECIAL *IGNORETRANSLATIONERRORS?* ...)

(CL:DEFVAR *IGNORETRANSLATIONERRORS?* TRUE
  "If TRUE all passes of a translation will always be performed
regardless of whether any errors were encountered.  Otherwise, translation
ends with the first pass that encountered an error.")

(CL:DEFUN READ-*IGNORETRANSLATIONERRORS?* ()
  (CL:RETURN-FROM READ-*IGNORETRANSLATIONERRORS?* *IGNORETRANSLATIONERRORS?*)
  :VOID)

(CL:DEFUN WRITE-*IGNORETRANSLATIONERRORS?* (VALUE)
  (CL:SETQ *IGNORETRANSLATIONERRORS?* VALUE)
  (CL:RETURN-FROM WRITE-*IGNORETRANSLATIONERRORS?* VALUE)
  :VOID)

;;; (DEFUN (IGNORE-TRANSLATION-ERRORS? BOOLEAN) ...)

(CL:DEFUN IGNORE-TRANSLATION-ERRORS? ()
  (CL:RETURN-FROM IGNORE-TRANSLATION-ERRORS? *IGNORETRANSLATIONERRORS?*)
  :VOID)

;;; (DEFUN (TRANSLATION-ERRORS? BOOLEAN) ...)

(CL:DEFUN TRANSLATION-ERRORS? ()
  (CL:RETURN-FROM
   TRANSLATION-ERRORS?
   (CL:IF
    (CL:AND
     (CL:> *TRANSLATIONERRORS* 0)
     (CL:EQ (IGNORE-TRANSLATION-ERRORS?) 0))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN SUMMARIZE-TRANSLATION-ERRORS ...)

(CL:DEFUN SUMMARIZE-TRANSLATION-ERRORS ()
  (CL:WHEN
   (CL:> *TRANSLATIONERRORS* 0)
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:PRINC *TRANSLATIONERRORS* %%STREAM)
    (CL:WRITE-STRING " error" %%STREAM))
   (CL:WHEN
    (CL:> *TRANSLATIONERRORS* 1)
    (CL:WRITE-STRING
     "s"
     (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))))
  (CL:WHEN
   (CL:> *TRANSLATIONWARNINGS* 0)
   (CL:WHEN
    (CL:> *TRANSLATIONERRORS* 0)
    (CL:WRITE-STRING
     ", "
     (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:PRINC *TRANSLATIONWARNINGS* %%STREAM)
    (CL:WRITE-STRING " warning" %%STREAM))
   (CL:WHEN
    (CL:> *TRANSLATIONWARNINGS* 1)
    (CL:WRITE-STRING
     "s"
     (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))))
  (CL:WHEN
   (CL:OR (CL:> *TRANSLATIONERRORS* 0) (CL:> *TRANSLATIONWARNINGS* 0))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "." %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM)))
  :VOID)

;;; (DEFUN PRINT-ERROR-CONTEXT ...)

(CL:DEFUN PRINT-ERROR-CONTEXT (PREFIX STREAM)
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
   (CL:WRITE-STRING PREFIX %%STREAM)
   (CL:WRITE-STRING "While " %%STREAM))
  (CL:COND
   ((CL:NOT (CL:EQ *TRANSLATIONPHASE* NULL))
    (CL:COND
     ((CL:EQ *TRANSLATIONPHASE* KWD-WALK-DEFINE)
      (CL:WRITE-STRING
       "defining "
       (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
     ((CL:EQ *TRANSLATIONPHASE* KWD-WALK-FINALIZE)
      (CL:WRITE-STRING
       "finalizing "
       (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
     ((CL:EQ *TRANSLATIONPHASE* KWD-WALK-WALK)
      (CL:WRITE-STRING
       "walking "
       (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
     ((CL:EQ *TRANSLATIONPHASE* KWD-WALK-TRANSLATE)
      (CL:WRITE-STRING
       "translating "
       (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
     (CL:T (CL:ERROR "`~A' is not a valid case option" *TRANSLATIONPHASE*))))
   (CL:T
    (CL:WRITE-STRING
     "processing "
     (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
  (CL:COND
   ((CL:NOT (CL:EQ *CURRENTTRANSLATIONUNIT* NULL))
    (CL:LET*
     ((OBJECT
       (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT *CURRENTTRANSLATIONUNIT*))
      (CATEGORY
       (CLSYS-SVAL TRANSLATION-UNIT CATEGORY *CURRENTTRANSLATIONUNIT*)))
     (CL:COND
      ((CL:EQ CATEGORY SYM-WALK-CLASS)
       (CL:WRITE-STRING
        "class "
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
       (CL:LET*
        ((OBJECT-001 OBJECT))
        (CL:COND
         ((CL:EQ (CLASS? OBJECT) 1)
          (CL:LET*
           ((OBJECT NULL))
           (CL:SETQ OBJECT OBJECT-001)
           (CL:WRITE-STRING
            (NAME OBJECT)
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
         (CL:T
          (PRINT-OBJECT
           OBJECT
           (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))))
      ((CL:EQ CATEGORY SYM-WALK-SLOT)
       (CL:WRITE-STRING
        "external slot "
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
       (CL:LET*
        ((OBJECT-002 OBJECT))
        (CL:COND
         ((CL:EQ (CONS? OBJECT) 1)
          (CL:LET*
           ((OBJECT NULL))
           (CL:SETQ OBJECT OBJECT-002)
           (CL:LET
            ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
            (PRINT-OBJECT (SECOND OBJECT) %%STREAM)
            (CL:WRITE-STRING "." %%STREAM)
            (PRINT-OBJECT (THIRD OBJECT) %%STREAM))))
         ((CL:EQ (STORAGE-SLOT? OBJECT) 1)
          (CL:LET*
           ((OBJECT NULL))
           (CL:SETQ OBJECT OBJECT-002)
           (CL:LET
            ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
            (PRINT-OBJECT
             (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER OBJECT)
             %%STREAM)
            (CL:WRITE-STRING "." %%STREAM)
            (CL:WRITE-STRING
             (CLSYS-SVAL
              SYMBOL
              SYMBOL-NAME
              (CLSYS-SVAL STORAGE-SLOT SLOT-NAME OBJECT))
             %%STREAM))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" OBJECT)))))
      ((CL:OR
        (CL:EQ CATEGORY SYM-WALK-METHOD)
        (CL:EQ CATEGORY SYM-WALK-PRINT-METHOD)
        (CL:EQ CATEGORY SYM-WALK-MACRO))
       (CL:LET*
        ((OBJECT-003 OBJECT))
        (CL:COND
         ((CL:EQ (METHOD-SLOT? OBJECT) 1)
          (CL:LET*
           ((OBJECT NULL))
           (CL:SETQ OBJECT OBJECT-003)
           (CL:WHEN
            (CL:EQ CATEGORY SYM-WALK-MACRO)
            (CL:WRITE-STRING
             "macro expander "
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
           (CL:COND
            ((CL:EQ (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? OBJECT) 1)
             (CL:LET
              ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
              (CL:WRITE-STRING "function " %%STREAM)
              (PRINT-OBJECT
               (CLSYS-SVAL METHOD-SLOT SLOT-NAME OBJECT)
               %%STREAM)))
            (CL:T
             (CL:LET
              ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
              (CL:WRITE-STRING "method " %%STREAM)
              (PRINT-OBJECT
               (CLSYS-SVAL METHOD-SLOT SLOT-OWNER OBJECT)
               %%STREAM)
              (CL:WRITE-STRING "." %%STREAM)
              (CL:WRITE-STRING
               (CLSYS-SVAL
                SYMBOL
                SYMBOL-NAME
                (CLSYS-SVAL METHOD-SLOT SLOT-NAME OBJECT))
               %%STREAM))))))
         ((CL:EQ (CONS? OBJECT) 1)
          (CL:LET*
           ((OBJECT NULL))
           (CL:SETQ OBJECT OBJECT-003)
           (CL:IF
            (CL:EQ (FIRST OBJECT) SYM-WALK-DEFUN)
            (CL:WRITE-STRING
             "function "
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
            (CL:WRITE-STRING
             "method "
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
           (PRINT-OBJECT
            (CL:IF
             (CL:EQ (CONS? (SECOND OBJECT)) 1)
             (FIRST (SECOND OBJECT))
             (SECOND OBJECT))
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" OBJECT)))))
      ((CL:EQ CATEGORY SYM-WALK-GLOBAL-VARIABLE)
       (CL:LET*
        ((OBJECT-004 OBJECT))
        (CL:COND
         ((CL:EQ (TAXONOMY-ISA? OBJECT SGT-WALK-GLOBAL-VARIABLE) 1)
          (CL:LET*
           ((OBJECT NULL))
           (CL:SETQ OBJECT OBJECT-004)
           (CL:IF
            (CL:EQ (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-CONSTANT? OBJECT) 1)
            (CL:WRITE-STRING
             "constant "
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
            (CL:IF
             (CL:EQ (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SPECIAL? OBJECT) 1)
             (CL:WRITE-STRING
              "special variable "
              (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
             (CL:WRITE-STRING
              "global variable "
              (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
           (PRINT-OBJECT
            (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME OBJECT)
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
         ((CL:EQ (CONS? OBJECT) 1)
          (CL:LET*
           ((OBJECT NULL))
           (CL:SETQ OBJECT OBJECT-004)
           (CL:LET
            ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
            (PRINT-OBJECT (FIRST OBJECT) %%STREAM)
            (CL:WRITE-STRING " " %%STREAM)
            (PRINT-OBJECT (SECOND OBJECT) %%STREAM))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" OBJECT)))))
      ((CL:EQ CATEGORY SYM-WALK-TYPE)
       (CL:WRITE-STRING
        "type "
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
       (CL:LET*
        ((OBJECT-005 OBJECT))
        (CL:COND
         ((CL:EQ (CONS? OBJECT) 1)
          (CL:LET*
           ((OBJECT NULL))
           (CL:SETQ OBJECT OBJECT-005)
           (PRINT-OBJECT
            (SECOND OBJECT)
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
         ((CL:EQ (TAXONOMY-ISA? OBJECT SGT-WALK-TYPE-SPEC) 1)
          (CL:LET*
           ((OBJECT NULL))
           (CL:SETQ OBJECT OBJECT-005)
           (PRINT-OBJECT
            (YIELD-TYPE-SPEC-TREE OBJECT)
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" OBJECT)))))
      ((CL:EQ CATEGORY SYM-WALK-MODULE)
       (CL:WRITE-STRING
        "module "
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
       (CL:LET*
        ((OBJECT-006 OBJECT))
        (CL:COND
         ((CL:EQ (TAXONOMY-ISA? OBJECT SGT-WALK-MODULE) 1)
          (CL:LET*
           ((OBJECT NULL))
           (CL:SETQ OBJECT OBJECT-006)
           (CL:WRITE-STRING
            (CLSYS-SVAL MODULE MODULE-NAME OBJECT)
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
         ((CL:EQ (CONS? OBJECT) 1)
          (CL:LET*
           ((OBJECT NULL))
           (CL:SETQ OBJECT OBJECT-006)
           (PRINT-OBJECT
            (SECOND OBJECT)
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" OBJECT)))))
      (CL:T
       (PRINT-OBJECT
        CATEGORY
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))))
   (CL:T
    (CL:WRITE-STRING
     "top-level statement"
     (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
  (CL:WRITE-STRING ":" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
  :VOID)

;;; (DEFUN PUSH-VARIABLE-BINDING ...)

(CL:DEFUN PUSH-VARIABLE-BINDING (VARIABLE TYPE)
  (CL:WHEN
   (CL:AND
    (CL:EQ (TYPE? TYPE) 1)
    (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE) NULL)
    (CL:NOT (CL:EQ TYPE SGT-WALK-UNINITIALIZED)))
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING " No class defined for type: `" %%STREAM)
      (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TYPE) %%STREAM)
      (CL:WRITE-STRING "'." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))))
   (CL:SETQ TYPE SGT-WALK-UNKNOWN))
  (CL:SETF
   (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST *LOCALVARIABLETYPETABLE*)
   (KV-CONS
    (SOFT-PERMANENTIFY VARIABLE)
    TYPE
    (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST *LOCALVARIABLETYPETABLE*)))
  :VOID)

;;; (DEFUN POP-VARIABLE-BINDING ...)

(CL:DEFUN POP-VARIABLE-BINDING ()
  (CL:LET*
   ((KVLIST (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST *LOCALVARIABLETYPETABLE*)))
   (CL:SETF
    (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST *LOCALVARIABLETYPETABLE*)
    (CLSYS-SVAL KV-CONS REST KVLIST))
   (FREE-KV-CONS KVLIST))
  :VOID)

;;; (DEFUN (LOOKUP-VARIABLE-TYPE TYPE-SPEC) ...)

(CL:DEFUN LOOKUP-VARIABLE-TYPE (VARIABLENAME)
  (CL:SETQ VARIABLENAME (SOFT-PERMANENTIFY VARIABLENAME))
  (CL:LET*
   ((TYPE (LOOKUP *LOCALVARIABLETYPETABLE* VARIABLENAME)))
   (CL:WHEN
    (CL:EQ TYPE NULL)
    (CL:WHEN
     (CL:EQ VARIABLENAME SYM-WALK-NULL)
     (CL:RETURN-FROM LOOKUP-VARIABLE-TYPE SGT-WALK-UNKNOWN))
    (CL:SETQ TYPE (LOOKUP-GLOBAL-VARIABLE-TYPE VARIABLENAME))
    (REGISTER-REFERENCE-TO-GLOBAL-VARIABLE VARIABLENAME))
   (CL:WHEN
    (CL:EQ TYPE NULL)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Undeclared variable `" %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE VARIABLENAME) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (CL:RETURN-FROM LOOKUP-VARIABLE-TYPE SGT-WALK-UNKNOWN))
   (CL:WHEN
    (CL:EQ TYPE SGT-WALK-UNINITIALIZED)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING
        " Reference to defined but uninitialized variable `"
        %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE VARIABLENAME) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (CL:RETURN-FROM LOOKUP-VARIABLE-TYPE SGT-WALK-UNKNOWN))
   (CL:RETURN-FROM LOOKUP-VARIABLE-TYPE TYPE))
  :VOID)

;;; (DEFUN REGISTER-REFERENCE-TO-GLOBAL-VARIABLE ...)

(CL:DEFUN REGISTER-REFERENCE-TO-GLOBAL-VARIABLE (VARIABLENAME)
  (CL:WHEN
   (CL:NOT (CL:EQ *CURRENTTRANSLATIONUNIT* NULL))
   (CL:LET*
    ((GLOBAL (LOOKUP-GLOBAL-VARIABLE VARIABLENAME))
     (REFERENCEDGLOBALS
      (CLSYS-SVAL
       TRANSLATION-UNIT
       REFERENCED-GLOBALS
       *CURRENTTRANSLATIONUNIT*)))
    (CL:WHEN
     (CL:AND
      (CL:NOT (CL:EQ GLOBAL NULL))
      (CL:EQ (MEMBER? REFERENCEDGLOBALS GLOBAL) 0))
     (INSERT REFERENCEDGLOBALS GLOBAL))))
  :VOID)

;;; (DEFUN (LOCAL-GENSYM SYMBOL) ...)

(CL:DEFUN LOCAL-GENSYM (PREFIX)
  (CL:WHEN
   (CL:EQ *LOCALGENSYMTABLE* NULL)
   (CL:RETURN-FROM LOCAL-GENSYM (GENSYM PREFIX)))
  (CL:LET*
   ((PREFIXSYMBOL (INTERN-TRANSIENT-SYMBOL PREFIX))
    (PREFIXCOUNTER (LOOKUP *LOCALGENSYMTABLE* PREFIXSYMBOL)))
   (CL:WHEN
    (CL:EQ PREFIXCOUNTER NULL)
    (CL:SETQ PREFIXCOUNTER (NEW-TRANSIENT-INTEGER-WRAPPER 0))
    (INSERT-AT *LOCALGENSYMTABLE* PREFIXSYMBOL PREFIXCOUNTER))
   (CL:SETF
    (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE PREFIXCOUNTER)
    (CL:1+ (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE PREFIXCOUNTER)))
   (CL:RETURN-FROM
    LOCAL-GENSYM
    (INTERN-TRANSIENT-SYMBOL
     (YIELD-GENSYM-NAME
      PREFIX
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE PREFIXCOUNTER)))))
  :VOID)

;;; (DEFUN FREE-TRANSIENT-TYPE-SPEC ...)

(CL:DEFUN FREE-TRANSIENT-TYPE-SPEC (SELF)
  (CL:SETQ SELF SELF)
  NULL
  :VOID)

;;; (DEFUN (SUPPRESS-WARNINGS? BOOLEAN) ...)

(CL:DEFUN SUPPRESS-WARNINGS? ()
  (CL:RETURN-FROM
   SUPPRESS-WARNINGS?
   (MEMBER? *CURRENT-ENVIRONMENT-FEATURES* KWD-WALK-SUPPRESS-WARNINGS))
  :VOID)

;;; (DEFUN (BAD-ARGUMENT-RANGE? BOOLEAN) ...)

(CL:DEFUN BAD-ARGUMENT-RANGE? (TREE MINARITY MAXARITY)
  (CL:LET*
   ((ARGNUM (CL:1- (LENGTH TREE))))
   (CL:COND
    ((CL:< ARGNUM MINARITY)
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " Missing arguments in the expression: " %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " `" %%STREAM)
        (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
        (CL:WRITE-STRING "'." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     (CL:RETURN-FROM BAD-ARGUMENT-RANGE? TRUE))
    ((CL:AND (CL:EQ (DEFINED? MAXARITY) 1) (CL:> ARGNUM MAXARITY))
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " Too many arguments in the expression: " %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " `" %%STREAM)
        (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
        (CL:WRITE-STRING "'." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     (CL:RETURN-FROM BAD-ARGUMENT-RANGE? TRUE))
    (CL:T (CL:RETURN-FROM BAD-ARGUMENT-RANGE? FALSE))))
  :VOID)

;;; (DEFUN (BAD-ARGUMENT-COUNT? BOOLEAN) ...)

(CL:DEFUN BAD-ARGUMENT-COUNT? (TREE ARITY)
  (CL:RETURN-FROM BAD-ARGUMENT-COUNT? (BAD-ARGUMENT-RANGE? TREE ARITY ARITY))
  :VOID)

;;; (DEFUN (YIELD-ILLEGAL-STATEMENT-TREE CONS) ...)

(CL:DEFUN YIELD-ILLEGAL-STATEMENT-TREE ()
  (CL:LET*
   ((*LOCALVARIABLETYPETABLE* (NEW-KEY-VALUE-LIST)))
   (CL:DECLARE (CL:SPECIAL *LOCALVARIABLETYPETABLE*))
   (CL:RETURN-FROM
    YIELD-ILLEGAL-STATEMENT-TREE
    (WALK-WITHOUT-TYPE-TREE
     (LIST*
      SYM-WALK-ERROR
      (WRAP-LITERAL
       "Attempt to execute illegal statement flagged by the translator")
      SYM-WALK-EOL
      (WRAP-LITERAL "    but not yet fixed.")
      NIL))))
  :VOID)

;;; (DEFUN (YIELD-ILLEGAL-EXPRESSION-TREE OBJECT) ...)

(CL:DEFUN YIELD-ILLEGAL-EXPRESSION-TREE ()
  (CL:RETURN-FROM
   YIELD-ILLEGAL-EXPRESSION-TREE
   SYM-WALK-ILLEGAL-EXPRESSION-FLAGGED-BY-THE-TRANSLATOR)
  :VOID)

;;; (DEFUN (WALK-DONT-CALL-ME-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-DONT-CALL-ME-TREE (TREE RETURNTYPE)
  (CL:RETURN-FROM
   WALK-DONT-CALL-ME-TREE
   (CL:VALUES
    (LIST*
     SYM-WALK-BAD-SYS
     TREE
     (CONS (TYPE-SPEC-TO-BASE-TYPE RETURNTYPE) NIL))
    RETURNTYPE))
  :VOID)

;;; (DEFUN (ILLEGAL-TREE? BOOLEAN) ...)

(CL:DEFUN ILLEGAL-TREE? (TREE)
  (CL:RETURN-FROM
   ILLEGAL-TREE?
   (CL:IF
    (CL:AND (CL:EQ (CONS? TREE) 1) (CL:EQ (FIRST TREE) SYM-WALK-BAD-SYS))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (NATIVE-CLASS-METHOD-INLINING? BOOLEAN) ...)

(CL:DEFUN NATIVE-CLASS-METHOD-INLINING? ()
  (CL:LET*
   ((TEST-VALUE-001 (TRANSLATOR-OUTPUT-LANGUAGE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-WALK-COMMON-LISP)
     (CL:RETURN-FROM NATIVE-CLASS-METHOD-INLINING? FALSE))
    ((CL:OR
      (CL:EQ TEST-VALUE-001 KWD-WALK-JAVA)
      (CL:EQ TEST-VALUE-001 KWD-WALK-CPP)
      (CL:EQ TEST-VALUE-001 KWD-WALK-CPP-STANDALONE)
      (CL:EQ TEST-VALUE-001 KWD-WALK-IDL))
     (CL:RETURN-FROM NATIVE-CLASS-METHOD-INLINING? TRUE))
    (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
  :VOID)

;;; (DEFUN (PROGNIFY OBJECT) ...)

(CL:DEFUN PROGNIFY (TREES)
  (CL:CASE
   (LENGTH TREES)
   (0 (CL:RETURN-FROM PROGNIFY NIL))
   (1
    (CL:LET*
     ((TREE (FIRST TREES)))
     (FIRST-SETTER TREES NULL)
     (FREE-PARSE-TREE TREES)
     (CL:RETURN-FROM PROGNIFY TREE)))
   (CL:OTHERWISE
    (CL:RETURN-FROM PROGNIFY (CONS SYM-WALK-PROGN (CONCATENATE TREES NIL)))))
  :VOID)

;;; (DEFUN (OPTIMIZE-PROGN OBJECT) ...)

(CL:DEFUN OPTIMIZE-PROGN (PROGN-TREE)
  (CL:CASE
   (LENGTH (CLSYS-SVAL CONS REST PROGN-TREE))
   (0 (FREE-PARSE-TREE PROGN-TREE) (CL:RETURN-FROM OPTIMIZE-PROGN NIL))
   (1
    (CL:LET*
     ((TREE (SECOND PROGN-TREE)))
     (SECOND-SETTER PROGN-TREE NULL)
     (FREE-PARSE-TREE PROGN-TREE)
     (CL:RETURN-FROM OPTIMIZE-PROGN TREE)))
   (CL:OTHERWISE (CL:RETURN-FROM OPTIMIZE-PROGN PROGN-TREE)))
  :VOID)

;;; (DEFUN (TREE-TO-TREES CONS) ...)

(CL:DEFUN TREE-TO-TREES (TREE)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:WHEN
       (CL:EQ (FIRST TREE) SYM-WALK-PROGN)
       (CL:RETURN-FROM TREE-TO-TREES (CLSYS-SVAL CONS REST TREE)))))
    (CL:T NULL)))
  (CL:RETURN-FROM TREE-TO-TREES (CONS TREE NIL))
  :VOID)

;;; (DEFGLOBAL *WRAPPED-TYPE-TABLE* ...)

(CL:DEFVAR *WRAPPED-TYPE-TABLE* NULL
  "Table of pairs used by 'wrapper-value-type' and
'type-to-wrapped-type'.")

;;; (DEFUN (WRAPPED-TYPE-TO-TYPE TYPE) ...)

(CL:DEFUN WRAPPED-TYPE-TO-TYPE (SELF)
  "Return the unwrapped type for the wrapped type 'self',
or 'self' if it is not a wrapped type."
  (CL:LET*
   ((ENTRY NULL) (ITER-001 *WRAPPED-TYPE-TABLE*))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ ENTRY (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:EQ (FIRST ENTRY) SELF)
     (CL:RETURN-FROM WRAPPED-TYPE-TO-TYPE (SECOND ENTRY)))))
  (CL:RETURN-FROM WRAPPED-TYPE-TO-TYPE SELF)
  :VOID)

;;; (DEFUN (WRAPPER-VALUE-TYPE TYPE) ...)

(CL:DEFUN WRAPPER-VALUE-TYPE (SELF)
  "Return the type of the value stored in the wrapper 'self'."
  (CL:LET*
   ((WRAPPERTYPE (PRIMARY-TYPE SELF))
    (VALUETYPE (WRAPPED-TYPE-TO-TYPE WRAPPERTYPE)))
   (CL:IF
    (CL:EQ VALUETYPE WRAPPERTYPE)
    (CL:ERROR "Missing *wrapped-type-table* entry")
    (CL:RETURN-FROM WRAPPER-VALUE-TYPE VALUETYPE)))
  :VOID)

;;; (DEFMETHOD (TYPE-TO-WRAPPED-TYPE TYPE) ...)

(CL:DEFMETHOD TYPE-TO-WRAPPED-TYPE ((SELF SURROGATE))
  "Return the wrapped type for the type 'self',
or 'self' if it is not a bare literal type."
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) NULL)
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING " Can't find a class named `" %%STREAM)
      (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE SELF) %%STREAM)
      (CL:WRITE-STRING "'." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)))))
  (CL:WHEN
   (CL:EQ (SUBTYPE-OF? SELF SGT-WALK-OBJECT) 1)
   (CL:RETURN-FROM TYPE-TO-WRAPPED-TYPE SELF))
  (CL:LET*
   ((ENTRY NULL) (ITER-001 *WRAPPED-TYPE-TABLE*))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ ENTRY (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:EQ (SECOND ENTRY) SELF)
     (CL:RETURN-FROM TYPE-TO-WRAPPED-TYPE (FIRST ENTRY)))))
  (CL:LET*
   ((REALTYPE
     (CLSYS-SVAL
      CLASS
      CLASS-TYPE
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF))))
   (CL:WHEN
    (CL:NOT (CL:EQ SELF REALTYPE))
    (CL:LET*
     ((ENTRY NULL) (ITER-002 *WRAPPED-TYPE-TABLE*))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-002 NIL))
      DO
      (CL:PROGN
       (CL:SETQ ENTRY (CLSYS-SVAL CONS VALUE ITER-002))
       (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
      (CL:WHEN
       (CL:EQ (SECOND ENTRY) REALTYPE)
       (CL:RETURN-FROM TYPE-TO-WRAPPED-TYPE (FIRST ENTRY)))))))
  (CL:RETURN-FROM TYPE-TO-WRAPPED-TYPE NULL)
  :VOID)

;;; (DEFGLOBAL *COERSION-TABLE* ...)

(CL:DEFVAR *COERSION-TABLE* NULL
  "Table of triples used by 'lookup-coersion-method' to
locate a coersion method.")

;;; (DEFUN (LOOKUP-COERSION-METHOD SYMBOL) ...)

(CL:DEFUN LOOKUP-COERSION-METHOD (SOURCETYPE TARGETTYPE EXPRESSION)
  (CL:SETQ EXPRESSION EXPRESSION)
  (CL:SETQ SOURCETYPE (CANONICAL-TYPE SOURCETYPE))
  (CL:LET*
   ((TRIPLE NULL) (ITER-001 *COERSION-TABLE*))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ TRIPLE (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:AND
      (CL:EQ SOURCETYPE (FIRST TRIPLE))
      (CL:EQ (SUBTYPE-OF? (SECOND TRIPLE) TARGETTYPE) 1))
     (CL:RETURN-FROM LOOKUP-COERSION-METHOD (THIRD TRIPLE)))))
  (CL:RETURN-FROM LOOKUP-COERSION-METHOD NULL)
  :VOID)

;;; (DEFUN (TRANSLATING-CODE? BOOLEAN) ...)

(CL:DEFUN TRANSLATING-CODE? ()
  (CL:RETURN-FROM
   TRANSLATING-CODE?
   (CL:IF
    (CL:OR
     (CL:EQ *TRANSLATIONPHASE* KWD-WALK-WALK)
     (CL:EQ *TRANSLATIONPHASE* KWD-WALK-TRANSLATE))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (VERIFY-TYPE TYPE) ...)

(CL:DEFUN VERIFY-TYPE (SELF)
  (CL:WHEN
   (CL:AND
    (CL:EQ (TRANSLATING-CODE?) 1)
    (CL:OR
     (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) NULL)
     (CL:EQ
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-WALK-UNKNOWN))))
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-WARNING)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING " Reference to undefined class `" %%STREAM)
      (CL:WRITE-STRING (CLSYS-SVAL SURROGATE SYMBOL-NAME SELF) %%STREAM)
      (CL:WRITE-STRING "'." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))))
   (CL:SETF
    (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)
    (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-WALK-UNKNOWN)))
  (CL:RETURN-FROM VERIFY-TYPE SELF)
  :VOID)

;;; (DEFUN (SAFE-SUBTYPE-OF? BOOLEAN) ...)

(CL:DEFUN SAFE-SUBTYPE-OF? (SUBTYPE SUPERTYPE)
  (VERIFY-TYPE SUBTYPE)
  (VERIFY-TYPE SUPERTYPE)
  (CL:RETURN-FROM SAFE-SUBTYPE-OF? (SUBTYPE-OF? SUBTYPE SUPERTYPE))
  :VOID)

;;; (DEFUN WARN-ABOUT-UNKNOWN-SOURCE-TYPE ...)

(CL:DEFUN WARN-ABOUT-UNKNOWN-SOURCE-TYPE (TREE)
  (CL:WHEN
   (CL:EQ (WARN-ABOUT-UNDEFINED-METHODS?) 1)
   (CL:LET*
    ((TREE-001 TREE))
    (CL:COND
     ((CL:EQ (SYMBOL? TREE) 1)
      (CL:LET*
       ((TREE NULL))
       (CL:SETQ TREE TREE-001)
       (CL:RETURN-FROM WARN-ABOUT-UNKNOWN-SOURCE-TYPE)))
     ((CL:EQ (CONS? TREE) 1)
      (CL:LET*
       ((TREE NULL))
       (CL:SETQ TREE TREE-001)
       (CL:LET*
        ((TEST-VALUE-001 (FIRST TREE)))
        (CL:COND
         ((CL:OR
           (CL:EQ TEST-VALUE-001 SYM-WALK-VERBATIM)
           (CL:EQ TEST-VALUE-001 SYM-WALK-VRLET))
          (CL:RETURN-FROM WARN-ABOUT-UNKNOWN-SOURCE-TYPE))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-SYS-CALL-METHOD)
          (CL:WHEN
           (CL:OR
            (CL:EQ (SYMBOL-COMMON-LISP? (THIRD TREE)) 1)
            (CL:EQ
             (SAFE-LOOKUP-SLOT
              (CLSYS-SVAL SURROGATE SURROGATE-VALUE (SECOND TREE))
              (THIRD TREE))
             NULL))
           (CL:RETURN-FROM WARN-ABOUT-UNKNOWN-SOURCE-TYPE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-SYS-CALL-FUNCTION)
          (CL:WHEN
           (CL:EQ
            (CLSYS-SVAL
             METHOD-SLOT
             SLOT-BASE-TYPE
             (LOOKUP-FUNCTION-OR-STELLA-FUNCTION (SECOND TREE)))
            SGT-WALK-UNKNOWN)
           (CL:RETURN-FROM WARN-ABOUT-UNKNOWN-SOURCE-TYPE)))
         (CL:T NULL)))))
     (CL:T
      (CL:WHEN
       (CL:EQ TREE NULL)
       (CL:RETURN-FROM WARN-ABOUT-UNKNOWN-SOURCE-TYPE)))))
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING " The expression" %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING "   `" %%STREAM)
      (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
      (CL:WRITE-STRING "'" %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING " has UNKNOWN type." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)))))
  :VOID)

;;; (DEFUN (COERCE-A-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN COERCE-A-TREE (TREE SOURCETYPE TARGETTYPE)
  (CL:LET*
   ((OTREE NULL) (OTYPE NULL) (COERCIBLE? FALSE))
   (CL:MULTIPLE-VALUE-SETQ
    (OTREE OTYPE COERCIBLE?)
    (HELP-COERCE-A-TREE TREE SOURCETYPE TARGETTYPE FALSE))
   (CL:WHEN
    (CL:EQ COERCIBLE? 0)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Type conflict: the expression:" %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING "   `" %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
       (CL:WRITE-STRING "'" %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " has type `" %%STREAM)
       (PRINT-OBJECT (YIELD-TYPE-SPEC-TREE SOURCETYPE) %%STREAM)
       (CL:WRITE-STRING "' but should have type `" %%STREAM)
       (PRINT-OBJECT (YIELD-TYPE-SPEC-TREE TARGETTYPE) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))))
   (CL:RETURN-FROM COERCE-A-TREE (CL:VALUES OTREE OTYPE)))
  :VOID)

;;; (DEFUN (HELP-COERCE-A-TREE OBJECT TYPE-SPEC BOOLEAN) ...)

(CL:DEFUN HELP-COERCE-A-TREE (TREE SOURCETYPE TARGETTYPE TESTONLY?)
  (CL:LET*
   ((COERSIONFUNCTION NULL)
    (REALSOURCETYPE (TARGET-LANGUAGE-TYPE TREE))
    (SOURCEBASETYPE (TYPE-SPEC-TO-BASE-TYPE SOURCETYPE))
    (TARGETBASETYPE (TYPE-SPEC-TO-BASE-TYPE TARGETTYPE)))
   (CL:WHEN
    (CL:EQ SOURCETYPE SGT-WALK-UNKNOWN)
    (WARN-ABOUT-UNKNOWN-SOURCE-TYPE TREE)
    (CL:IF
     (CL:AND (CL:EQ TREE SYM-WALK-NULL) (CL:NOT (CL:EQ TARGETBASETYPE NULL)))
     (CL:RETURN-FROM
      HELP-COERCE-A-TREE
      (CL:VALUES (TYPE-TO-NULL-VALUE-TREE TARGETBASETYPE) TARGETTYPE TRUE))
     (CL:RETURN-FROM HELP-COERCE-A-TREE (CL:VALUES TREE TARGETTYPE TRUE))))
   (CL:WHEN
    (CL:NOT (CL:EQ REALSOURCETYPE NULL))
    (SET-TARGET-LANGUAGE-TYPE TREE NULL)
    (CL:MULTIPLE-VALUE-SETQ
     (TREE SOURCETYPE)
     (COERCE-A-TREE TREE REALSOURCETYPE SOURCETYPE)))
   (CL:WHEN
    (CL:EQ TARGETTYPE SGT-WALK-UNKNOWN)
    (CL:RETURN-FROM HELP-COERCE-A-TREE (CL:VALUES TREE SOURCETYPE TRUE)))
   (CL:WHEN
    (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SOURCEBASETYPE) NULL)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " No class defined for type: `" %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE SOURCEBASETYPE) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (CL:RETURN-FROM HELP-COERCE-A-TREE (CL:VALUES TREE TARGETTYPE TRUE)))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ TARGETBASETYPE NULL))
     (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE TARGETBASETYPE) NULL))
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " No class defined for type: `" %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TARGETBASETYPE) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (CL:RETURN-FROM HELP-COERCE-A-TREE (CL:VALUES TREE SOURCETYPE TRUE)))
   (CL:WHEN
    (CL:EQ (SUB-TYPE-SPEC-OF? SOURCETYPE TARGETTYPE) 1)
    (CL:RETURN-FROM HELP-COERCE-A-TREE (CL:VALUES TREE SOURCETYPE TRUE)))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ TARGETBASETYPE NULL))
     (CL:EQ (COMPATIBLE-PARAMETER-TYPES? SOURCETYPE TARGETTYPE) 1))
    (CL:LET*
     ((TEST-VALUE-001 FALSE))
     (CL:SETQ TEST-VALUE-001 (TYPE? SOURCETYPE))
     (CL:WHEN
      (CL:EQ TEST-VALUE-001 1)
      (CL:LET*
       ()
       (CL:SETQ
        COERSIONFUNCTION
        (LOOKUP-COERSION-METHOD SOURCETYPE TARGETBASETYPE TREE))
       (CL:SETQ TEST-VALUE-001 (DEFINED? COERSIONFUNCTION))))
     (CL:WHEN
      (CL:EQ TEST-VALUE-001 1)
      (CL:IF
       (CL:EQ COERSIONFUNCTION SYM-WALK-IDENTITY)
       (CL:RETURN-FROM HELP-COERCE-A-TREE (CL:VALUES TREE TARGETTYPE TRUE))
       (CL:RETURN-FROM
        HELP-COERCE-A-TREE
        (CL:VALUES
         (CL:IF
          (CL:EQ TESTONLY? 1)
          TREE
          (WALK-WITHOUT-TYPE-TREE (CONS COERSIONFUNCTION (CONS TREE NIL))))
         TARGETTYPE
         TRUE)))))
    (CL:WHEN
     (CL:EQ (SUBTYPE-OF? TARGETBASETYPE SOURCEBASETYPE) 1)
     (CL:WHEN
      (CL:EQ TESTONLY? 1)
      (CL:RETURN-FROM HELP-COERCE-A-TREE (CL:VALUES TREE TARGETTYPE TRUE)))
     (CL:RETURN-FROM
      HELP-COERCE-A-TREE
      (CL:VALUES
       (WALK-WITHOUT-TYPE-TREE
        (CONS
         (CL:IF
          (CL:NOT (CL:EQ REALSOURCETYPE NULL))
          SYM-WALK-SAFE-CAST
          SYM-WALK-CAST)
         (CONS TREE (CONS TARGETBASETYPE NIL))))
       TARGETTYPE
       TRUE)))
    (CL:WHEN
     (CL:AND
      (CL:EQ (SUBTYPE-OF? TARGETBASETYPE SGT-WALK-NON-OBJECT) 1)
      (CL:AND
       (CL:EQ (TYPE? SOURCETYPE) 1)
       (CL:EQ (SUBTYPE-OF? SGT-WALK-WRAPPER SOURCETYPE) 1)))
     (CL:LET*
      ((WRAPPERTYPE (TYPE-TO-WRAPPED-TYPE TARGETBASETYPE)))
      (CL:WHEN
       (CL:NOT (CL:EQ WRAPPERTYPE NULL))
       (CL:WHEN
        (CL:EQ TESTONLY? 1)
        (CL:RETURN-FROM HELP-COERCE-A-TREE (CL:VALUES TREE TARGETTYPE TRUE)))
       (CL:SETQ
        COERSIONFUNCTION
        (LOOKUP-COERSION-METHOD WRAPPERTYPE TARGETBASETYPE TREE))
       (CL:WHEN
        (CL:NOT (CL:EQ COERSIONFUNCTION NULL))
        (CL:RETURN-FROM
         HELP-COERCE-A-TREE
         (CL:VALUES
          (WALK-WITHOUT-TYPE-TREE
           (CONS
            COERSIONFUNCTION
            (CONS (LIST* SYM-WALK-CAST TREE (CONS WRAPPERTYPE NIL)) NIL)))
          TARGETTYPE
          TRUE)))))))
   (CL:RETURN-FROM HELP-COERCE-A-TREE (CL:VALUES TREE SOURCETYPE FALSE)))
  :VOID)

;;; (DEFUN (COERCIBLE? BOOLEAN) ...)

(CL:DEFUN COERCIBLE? (TREE SOURCETYPE TARGETTYPE)
  (CL:LET*
   ((OTREE NULL) (OTYPE NULL) (COERCIBLE? FALSE))
   (CL:MULTIPLE-VALUE-SETQ
    (OTREE OTYPE COERCIBLE?)
    (HELP-COERCE-A-TREE TREE SOURCETYPE TARGETTYPE TRUE))
   (CL:RETURN-FROM COERCIBLE? COERCIBLE?))
  :VOID)

;;; (DEFUN (WALKING-EXPRESSION? BOOLEAN) ...)

(CL:DEFUN WALKING-EXPRESSION? ()
  (CL:RETURN-FROM
   WALKING-EXPRESSION?
   (CL:IF (CL:NOT (CL:EQ *TARGETTYPE* SGT-WALK-VOID)) TRUE FALSE))
  :VOID)

;;; (DEFUN (WALK-EXPRESSION-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-EXPRESSION-TREE (EXPTREE TARGETTYPE OPERATORNAME VRLETISOK?)
  (CL:LET*
   ((*TARGETTYPE*
     (CL:IF (CL:NOT (CL:EQ TARGETTYPE NULL)) TARGETTYPE SGT-WALK-UNKNOWN)))
   (CL:DECLARE (CL:SPECIAL *TARGETTYPE*))
   (CL:LET*
    ((OEXP NULL) (SOURCETYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ (OEXP SOURCETYPE) (WALK-A-TREE EXPTREE))
    (CL:WHEN
     (CL:EQ (VRLET-EXPRESSION? OEXP) 1)
     (CL:WHEN
      (CL:EQ VRLETISOK? 0)
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN
        (CL:EQ (SUPPRESS-WARNINGS?) 0)
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING
          " Illegal procedural expression as argument to `"
          %%STREAM)
         (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE OPERATORNAME) %%STREAM)
         (CL:WRITE-STRING "':" %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING "   `" %%STREAM)
         (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE EXPTREE) %%STREAM)
         (CL:WRITE-STRING "'." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)))))
     (CL:RETURN-FROM WALK-EXPRESSION-TREE (CL:VALUES OEXP SOURCETYPE)))
    (CL:WHEN
     (CL:AND (CL:EQ (VOID? SOURCETYPE) 1) (CL:EQ (VOID? TARGETTYPE) 0))
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " Illegal argument to `" %%STREAM)
        (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE OPERATORNAME) %%STREAM)
        (CL:WRITE-STRING "':" %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING "   `" %%STREAM)
        (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE OEXP) %%STREAM)
        (CL:WRITE-STRING "'" %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING
         "The argument must be an expression, not a statement."
         %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     (CL:RETURN-FROM WALK-EXPRESSION-TREE (CL:VALUES OEXP SOURCETYPE)))
    (CL:WHEN (CL:EQ SOURCETYPE NULL) (CL:SETQ SOURCETYPE SGT-WALK-UNKNOWN))
    (CL:WHEN (CL:EQ TARGETTYPE NULL) (CL:SETQ TARGETTYPE SOURCETYPE))
    (CL:RETURN-FROM
     WALK-EXPRESSION-TREE
     (COERCE-A-TREE OEXP SOURCETYPE TARGETTYPE))))
  :VOID)

;;; (DEFUN (WALK-WITHOUT-TYPE-TREE OBJECT) ...)

(CL:DEFUN WALK-WITHOUT-TYPE-TREE (TREE)
  (CL:LET*
   ((OTREE NULL) (UNUSEDTYPESPEC NULL))
   (CL:MULTIPLE-VALUE-SETQ (OTREE UNUSEDTYPESPEC) (WALK-A-TREE TREE))
   (FREE-TRANSIENT-TYPE-SPEC UNUSEDTYPESPEC)
   (CL:RETURN-FROM WALK-WITHOUT-TYPE-TREE OTREE))
  :VOID)

;;; (DEFUN (WALK-LIST-OF-TREES CONS) ...)

(CL:DEFUN WALK-LIST-OF-TREES (TREES)
  (CL:LET*
   ((CURSOR TREES))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:SETF
     (CLSYS-SVAL CONS VALUE CURSOR)
     (WALK-STATEMENT (CLSYS-SVAL CONS VALUE CURSOR) FALSE))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (CL:RETURN-FROM WALK-LIST-OF-TREES TREES))
  :VOID)

;;; (DEFUN (WALK-STATEMENT OBJECT) ...)

(CL:DEFUN WALK-STATEMENT (TREE WARNONATOM?)
  (CL:LET*
   ((OTREE NULL) (UNUSEDTYPESPEC NULL))
   (CL:MULTIPLE-VALUE-SETQ (OTREE UNUSEDTYPESPEC) (WALK-A-TREE TREE))
   (FREE-TRANSIENT-TYPE-SPEC UNUSEDTYPESPEC)
   (CL:LET*
    ((OTREE-001 OTREE))
    (CL:COND
     ((CL:EQ (CONS? OTREE) 1)
      (CL:LET*
       ((OTREE NULL))
       (CL:SETQ OTREE OTREE-001)
       (CL:WHEN
        (CL:EQ (FIRST OTREE) SYM-WALK-VRLET)
        (CL:SETQ OTREE (ELIMINATE-VRLET-STATEMENT OTREE)))))
     (CL:T
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ TREE SYM-WALK-NULL)) (CL:EQ WARNONATOM? 1))
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-WARNING)
        (CL:WHEN
         (CL:EQ (SUPPRESS-WARNINGS?) 0)
         (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:WRITE-STRING
           " Expression found where statement expected: `"
           %%STREAM)
          (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
          (CL:WRITE-STRING "'." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))))))))
   (CL:RETURN-FROM WALK-STATEMENT OTREE))
  :VOID)

;;; (DEFUN (ELIMINATE-VRLET-STATEMENT CONS) ...)

(CL:DEFUN ELIMINATE-VRLET-STATEMENT (TREE)
  (FIRST-SETTER TREE SYM-WALK-LET)
  (CL:LET*
   ((CURSOR TREE))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST CURSOR) NIL))
    DO
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (CL:WHEN
    (CL:EQ (CONS? (CLSYS-SVAL CONS VALUE CURSOR)) 1)
    (CL:RETURN-FROM ELIMINATE-VRLET-STATEMENT (WALK-A-TREE TREE)))
   (FREE-CONS-TREE (CLSYS-SVAL CONS VALUE CURSOR))
   (CL:SETF (CLSYS-SVAL CONS VALUE CURSOR) NULL))
  (DELETE-NULL-STATEMENTS TREE)
  (CL:RETURN-FROM ELIMINATE-VRLET-STATEMENT (WALK-A-TREE TREE))
  :VOID)

;;; (DEFUN (SYS-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN SYS-TREE (TREE TYPESPEC)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:LET*
       ((TEST-VALUE-001 (FIRST TREE)))
       (CL:COND
        ((CL:EQ TEST-VALUE-001 SYM-WALK-VOID-SYS)
         (CL:WHEN
          (CL:EQ (VOID? TYPESPEC) 1)
          (CL:RETURN-FROM SYS-TREE (CL:VALUES TREE TYPESPEC))))
        ((CL:EQ TEST-VALUE-001 SYM-WALK-TYPED-SYS)
         (CL:WHEN
          (CL:EQ (THIRD TREE) TYPESPEC)
          (CL:RETURN-FROM SYS-TREE (CL:VALUES TREE TYPESPEC))))
        (CL:T NULL)))))
    (CL:T NULL)))
  (CL:IF
   (CL:EQ (VOID? TYPESPEC) 1)
   (CL:RETURN-FROM
    SYS-TREE
    (CL:VALUES (LIST* SYM-WALK-VOID-SYS TREE NIL) SGT-WALK-VOID))
   (CL:RETURN-FROM
    SYS-TREE
    (CL:VALUES (LIST* SYM-WALK-TYPED-SYS TREE (CONS TYPESPEC NIL)) TYPESPEC)))
  :VOID)

;;; (DEFUN (WALKED-EXPRESSION-TYPE TYPE-SPEC) ...)

(CL:DEFUN WALKED-EXPRESSION-TYPE (TREE)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:WHEN
       (CL:EQ (FIRST TREE) SYM-WALK-TYPED-SYS)
       (CL:RETURN-FROM WALKED-EXPRESSION-TYPE (THIRD TREE)))))
    ((CL:EQ (WRAPPER? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:RETURN-FROM
       WALKED-EXPRESSION-TYPE
       (WRAPPED-TYPE-TO-TYPE (PRIMARY-TYPE TREE)))))
    (CL:T NULL)))
  (CL:RETURN-FROM WALKED-EXPRESSION-TYPE SGT-WALK-UNKNOWN)
  :VOID)

;;; (DEFUN (NEED-IDENTICAL-METHOD-SIGNATURES? BOOLEAN) ...)

(CL:DEFUN NEED-IDENTICAL-METHOD-SIGNATURES? ()
  (CL:LET*
   ((TEST-VALUE-001 (TRANSLATOR-OUTPUT-LANGUAGE)))
   (CL:COND
    ((CL:OR
      (CL:EQ TEST-VALUE-001 KWD-WALK-CPP)
      (CL:EQ TEST-VALUE-001 KWD-WALK-CPP-STANDALONE))
     (CL:RETURN-FROM NEED-IDENTICAL-METHOD-SIGNATURES? TRUE))
    (CL:T (CL:RETURN-FROM NEED-IDENTICAL-METHOD-SIGNATURES? FALSE))))
  :VOID)

;;; (DEFUN (COMPUTE-MOST-GENERAL-RETURN-TYPE TYPE-SPEC) ...)

(CL:DEFUN COMPUTE-MOST-GENERAL-RETURN-TYPE (METHOD RETURNTYPE)
  (CL:LET*
   ((MOSTGENERALRETURNTYPE RETURNTYPE) (MOSTGENERALMETHOD METHOD))
   (CL:LOOP
    WHILE
    (CL:NOT
     (CL:EQ
      (CLSYS-SVAL METHOD-SLOT SLOT-DIRECT-EQUIVALENT MOSTGENERALMETHOD)
      NULL))
    DO
    (CL:SETQ
     MOSTGENERALMETHOD
     (CLSYS-SVAL METHOD-SLOT SLOT-DIRECT-EQUIVALENT MOSTGENERALMETHOD))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (CLSYS-SVAL METHOD-SLOT SLOT-BASE-TYPE MOSTGENERALMETHOD)
       SGT-WALK-UNKNOWN))
     (CL:SETQ
      MOSTGENERALRETURNTYPE
      (CLSYS-SVAL METHOD-SLOT SLOT-BASE-TYPE MOSTGENERALMETHOD))))
   (CL:RETURN-FROM COMPUTE-MOST-GENERAL-RETURN-TYPE MOSTGENERALRETURNTYPE))
  :VOID)

;;; (DEFUN (COMPUTE-REAL-SLOT-TYPE TYPE-SPEC) ...)

(CL:DEFUN COMPUTE-REAL-SLOT-TYPE (SLOT FIRSTARGTYPE RETURNTYPE)
  (CL:LET*
   ((SLOTTYPE RETURNTYPE)
    (CANONICALSLOT (CANONICAL-SLOT SLOT))
    (NATIVESLOTHOME NULL))
   (CL:WHEN
    (CL:NOT (CL:EQ (TRANSLATOR-OUTPUT-LANGUAGE) KWD-WALK-COMMON-LISP))
    (CL:WHEN
     (CL:EQ (NATIVE-SLOT? CANONICALSLOT) 1)
     (CL:SETQ
      NATIVESLOTHOME
      (NATIVE-SLOT-HOME SLOT (TYPE-SPEC-TO-CLASS FIRSTARGTYPE))))
    (CL:IF
     (CL:NOT (CL:EQ NATIVESLOTHOME NULL))
     (CL:SETQ
      SLOTTYPE
      (TYPE-SPEC-TO-BASE-TYPE
       (COMPUTE-RETURN-TYPE-SPEC
        (LOOKUP-SLOT
         NATIVESLOTHOME
         (CLSYS-SVAL STORAGE-SLOT SLOT-NAME CANONICALSLOT))
        (CLSYS-SVAL CLASS CLASS-TYPE NATIVESLOTHOME))))
     (CL:SETQ
      SLOTTYPE
      (TYPE-SPEC-TO-BASE-TYPE
       (COMPUTE-RETURN-TYPE-SPEC
        SLOT
        (TYPE-SPEC-TO-BASE-TYPE FIRSTARGTYPE)))))
    (CL:WHEN
     (CL:EQ SLOTTYPE (TYPE-SPEC-TO-BASE-TYPE RETURNTYPE))
     (CL:SETQ SLOTTYPE RETURNTYPE)))
   (CL:WHEN
    (CL:NOT (CL:EQ SLOT CANONICALSLOT))
    (CL:SETQ SLOTTYPE (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE CANONICALSLOT)))
   (CL:RETURN-FROM COMPUTE-REAL-SLOT-TYPE SLOTTYPE))
  :VOID)

;;; (DEFUN (SYS-TREE-IF-NEEDED OBJECT TYPE-SPEC) ...)

(CL:DEFUN SYS-TREE-IF-NEEDED (SLOT TREE FIRSTARGTYPE RETURNTYPE)
  (CL:WHEN
   (CL:NOT (CL:EQ SLOT NULL))
   (CL:LET*
    ((SLOT-001 SLOT))
    (CL:COND
     ((CL:EQ (METHOD-SLOT? SLOT) 1)
      (CL:LET*
       ((SLOT NULL))
       (CL:SETQ SLOT SLOT-001)
       (CL:WHEN
        (CL:AND
         (CL:EQ (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? SLOT) 0)
         (CL:EQ (NEED-IDENTICAL-METHOD-SIGNATURES?) 1))
        (CL:LET*
         ((MOSTGENERALRETURNTYPE
           (COMPUTE-MOST-GENERAL-RETURN-TYPE SLOT RETURNTYPE)))
         (CL:WHEN
          (CL:NOT (CL:EQ RETURNTYPE MOSTGENERALRETURNTYPE))
          (CL:RETURN-FROM
           SYS-TREE-IF-NEEDED
           (SET-TARGET-LANGUAGE-TYPE
            (SYS-TREE TREE RETURNTYPE)
            MOSTGENERALRETURNTYPE)))))))
     ((CL:EQ (STORAGE-SLOT? SLOT) 1)
      (CL:LET*
       ((SLOT NULL))
       (CL:SETQ SLOT SLOT-001)
       (CL:LET*
        ((REALSLOTTYPE (COMPUTE-REAL-SLOT-TYPE SLOT FIRSTARGTYPE RETURNTYPE)))
        (CL:WHEN
         (CL:NOT (CL:EQ RETURNTYPE REALSLOTTYPE))
         (CL:RETURN-FROM
          SYS-TREE-IF-NEEDED
          (SET-TARGET-LANGUAGE-TYPE
           (SYS-TREE TREE RETURNTYPE)
           REALSLOTTYPE))))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" SLOT))))
   (CL:LET*
    ((SLOTTYPE (DYNAMIC-SLOT-VALUE SLOT SYM-WALK-SLOT-TYPE-SPECIFIER NULL)))
    (CL:LET*
     ((TEST-VALUE-001 FALSE))
     (CL:SETQ TEST-VALUE-001 (DEFINED? SLOTTYPE))
     (CL:WHEN
      (CL:EQ TEST-VALUE-001 1)
      (CL:IF
       (CL:EQ (ANCHORED-TYPE-SPECIFIER? SLOTTYPE) 1)
       (CL:SETQ TEST-VALUE-001 TRUE)
       (CL:LET*
        ((FOUND?-001 FALSE))
        (CL:LET*
         ((TS NULL)
          (ITER-001
           (CLSYS-SVAL
            LIST
            THE-CONS-LIST
            (CLSYS-SVAL
             PARAMETRIC-TYPE-SPECIFIER
             SPECIFIER-PARAMETER-TYPES
             SLOTTYPE))))
         (CL:LOOP
          WHILE
          (CL:NOT (CL:EQ ITER-001 NIL))
          DO
          (CL:PROGN
           (CL:SETQ TS (CLSYS-SVAL CONS VALUE ITER-001))
           (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
          (CL:WHEN
           (CL:EQ (ANCHORED-TYPE-SPECIFIER? TS) 1)
           (CL:SETQ FOUND?-001 TRUE)
           (CL:RETURN))))
        (CL:SETQ TEST-VALUE-001 FOUND?-001))))
     (CL:WHEN
      (CL:EQ TEST-VALUE-001 1)
      (CL:IF
       (CL:AND
        (CL:EQ (ANCHORED-TYPE-SPECIFIER? SLOTTYPE) 1)
        (CL:NOT (CL:EQ (TRANSLATOR-OUTPUT-LANGUAGE) KWD-WALK-COMMON-LISP)))
       (CL:RETURN-FROM
        SYS-TREE-IF-NEEDED
        (SET-TARGET-LANGUAGE-TYPE
         (SYS-TREE TREE RETURNTYPE)
         (CL:IF
          (CL:EQ (CLSYS-SVAL SLOT SLOT-BASE-TYPE SLOT) SGT-WALK-UNKNOWN)
          (TYPE-SPEC-TO-BASE-TYPE RETURNTYPE)
          (CLSYS-SVAL SLOT SLOT-BASE-TYPE SLOT))))
       (CL:RETURN-FROM SYS-TREE-IF-NEEDED (SYS-TREE TREE RETURNTYPE)))))))
  (CL:RETURN-FROM SYS-TREE-IF-NEEDED (CL:VALUES TREE RETURNTYPE))
  :VOID)

;;; (DEFUN (TARGET-LANGUAGE-TYPE TYPE) ...)

(CL:DEFUN TARGET-LANGUAGE-TYPE (TREE)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:WHEN
       (CL:AND (CL:EQ (FIRST TREE) SYM-WALK-TYPED-SYS) (CL:= (LENGTH TREE) 4))
       (CL:RETURN-FROM TARGET-LANGUAGE-TYPE (FOURTH TREE)))))
    (CL:T NULL)))
  (CL:RETURN-FROM TARGET-LANGUAGE-TYPE NULL)
  :VOID)

;;; (DEFUN (SET-TARGET-LANGUAGE-TYPE CONS TYPE-SPEC) ...)

(CL:DEFUN SET-TARGET-LANGUAGE-TYPE (SYSTREE TYPE)
  (CL:IF
   (CL:= (LENGTH SYSTREE) 4)
   (FOURTH-SETTER SYSTREE TYPE)
   (CL:SETF
    (CLSYS-SVAL
     CONS
     REST
     (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST SYSTREE)))
    (CONS-LIST TYPE)))
  (CL:RETURN-FROM SET-TARGET-LANGUAGE-TYPE (CL:VALUES SYSTREE (THIRD SYSTREE)))
  :VOID)

;;; (DEFUN (DELETE-NULL-STATEMENTS CONS) ...)

(CL:DEFUN DELETE-NULL-STATEMENTS (TREES)
  (CL:RETURN-FROM DELETE-NULL-STATEMENTS (REMOVE TREES NULL))
  :VOID)

;;; (DEFUN (WALK-A-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-A-TREE (TREE)
  (CL:RETURN-FROM WALK-A-TREE (HELP-WALK-A-TREE TREE))
  :VOID)

;;; (DEFUN (HELP-WALK-A-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN HELP-WALK-A-TREE (TREE)
  (CL:IF
   (CL:EQ TREE NULL)
   (CL:RETURN-FROM HELP-WALK-A-TREE (CL:VALUES NULL SGT-WALK-UNKNOWN))
   (CL:LET*
    ((TREE-001 TREE))
    (CL:COND
     ((CL:EQ (CONS? TREE) 1)
      (CL:LET*
       ((TREE NULL))
       (CL:SETQ TREE TREE-001)
       (CL:WHEN
        (CL:EQ TREE NIL)
        (CL:RETURN-FROM HELP-WALK-A-TREE (CL:VALUES NIL SGT-WALK-CONS)))
       (CL:WHEN
        (CL:EQ (CONS? (CLSYS-SVAL CONS VALUE TREE)) 1)
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN
          (CL:EQ (SUPPRESS-WARNINGS?) 0)
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING
            " Unimplemented or illegal parse tree: `"
            %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
           (CL:WRITE-STRING "'." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))))
        (CL:RETURN-FROM HELP-WALK-A-TREE (CL:VALUES TREE SGT-WALK-VOID)))
       (CL:WHEN
        (CL:EQ (CONS? (CLSYS-SVAL CONS REST TREE)) 0)
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN
          (CL:EQ (SUPPRESS-WARNINGS?) 0)
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING " Illegal dotted pair or list*." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))))
        (CL:RETURN-FROM HELP-WALK-A-TREE (CL:VALUES TREE SGT-WALK-VOID)))
       (CL:LET*
        ((TEST-VALUE-001 (FIRST TREE)))
        (CL:COND
         ((CL:EQ TEST-VALUE-001 SYM-WALK-VOID-SYS)
          (CL:RETURN-FROM HELP-WALK-A-TREE (CL:VALUES TREE SGT-WALK-VOID)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-TYPED-SYS)
          (CL:RETURN-FROM HELP-WALK-A-TREE (CL:VALUES TREE (THIRD TREE))))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-SYS-FOREACH)
          (CL:RETURN-FROM HELP-WALK-A-TREE (CL:VALUES TREE SGT-WALK-VOID)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-BAD-SYS)
          (CL:RETURN-FROM HELP-WALK-A-TREE (CL:VALUES TREE (THIRD TREE))))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-SETQ)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-SETQ-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-SETF)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-SETF-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-SLOT-VALUE)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-SLOT-VALUE-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-SLOT-VALUE-SETTER)
          (CL:RETURN-FROM
           HELP-WALK-A-TREE
           (WALK-SLOT-VALUE-SETTER-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-PROGN)
          (CL:SETF
           (CLSYS-SVAL CONS REST TREE)
           (WALK-LIST-OF-TREES
            (DELETE-NULL-STATEMENTS (CLSYS-SVAL CONS REST TREE))))
          (CL:RETURN-FROM HELP-WALK-A-TREE (SYS-TREE TREE SGT-WALK-VOID)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-LOOP)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-LOOP-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-LET)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-LET-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-VRLET)
          (CL:RETURN-FROM HELP-WALK-A-TREE (CL:VALUES TREE SGT-WALK-UNKNOWN)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-VALUES)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-VALUES-TREE TREE)))
         ((CL:OR
           (CL:EQ TEST-VALUE-001 SYM-WALK-SPECIAL)
           (CL:EQ TEST-VALUE-001 SYM-WALK-SYS-SPECIAL))
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-SPECIAL-TREE TREE)))
         ((CL:OR
           (CL:EQ TEST-VALUE-001 SYM-WALK-CAST)
           (CL:EQ TEST-VALUE-001 SYM-WALK-SAFE-CAST))
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-CAST-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-RETURN)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-RETURN-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-MV-SETQ)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-MV-SETQ-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-MV-BIND)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-MV-BIND-TREE TREE)))
         ((CL:OR
           (CL:EQ TEST-VALUE-001 SYM-WALK-BREAK)
           (CL:EQ TEST-VALUE-001 SYM-WALK-CONTINUE))
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-LOOP-EXIT-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-WHILE)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-WHILE-TREE TREE)))
         ((CL:OR
           (CL:EQ TEST-VALUE-001 SYM-WALK-FOREACH)
           (CL:EQ TEST-VALUE-001 SYM-WALK-EXISTS)
           (CL:EQ TEST-VALUE-001 SYM-WALK-FORALL)
           (CL:EQ TEST-VALUE-001 SYM-WALK-SOME)
           (CL:EQ TEST-VALUE-001 SYM-WALK-SETOF)
           (CL:EQ TEST-VALUE-001 SYM-WALK-SET-OF)
           (CL:EQ TEST-VALUE-001 SYM-WALK-SELECT))
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-FOREACH-TREE TREE)))
         ((CL:OR
           (CL:EQ TEST-VALUE-001 SYM-WALK-IF)
           (CL:EQ TEST-VALUE-001 SYM-WALK-WHEN)
           (CL:EQ TEST-VALUE-001 SYM-WALK-UNLESS))
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-CONDITIONAL-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-CHOOSE)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-CHOOSE-TREE TREE)))
         ((CL:OR
           (CL:EQ TEST-VALUE-001 SYM-WALK-AND)
           (CL:EQ TEST-VALUE-001 SYM-WALK-OR)
           (CL:EQ TEST-VALUE-001 SYM-WALK-NOT))
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-BOOLEAN-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-COND)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-COND-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-CASE)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-CASE-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-TYPECASE)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-TYPECASE-TREE TREE)))
         ((CL:OR
           (CL:EQ TEST-VALUE-001 SYM-WALK-EQ?)
           (CL:EQ TEST-VALUE-001 SYM-WALK-EQL?)
           (CL:EQ TEST-VALUE-001 SYM-WALK-=))
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-EQUALITY-TREE TREE)))
         ((CL:OR
           (CL:EQ TEST-VALUE-001 SYM-WALK-+)
           (CL:EQ TEST-VALUE-001 SYM-WALK--)
           (CL:EQ TEST-VALUE-001 SYM-WALK-*)
           (CL:EQ TEST-VALUE-001 SYM-WALK-/))
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-ARITHMETIC-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-QUOTE)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-QUOTED-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-BQUOTE)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-BQUOTE-TREE TREE)))
         ((CL:OR
           (CL:EQ TEST-VALUE-001 SYM-WALK-PRINT-STREAM)
           (CL:EQ TEST-VALUE-001 SYM-WALK-PRINT-NATIVE-STREAM))
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-PRINT-STREAM-TREE TREE)))
         ((CL:OR
           (CL:EQ TEST-VALUE-001 SYM-WALK-NEW)
           (CL:EQ TEST-VALUE-001 SYM-WALK-ALLOCATE)
           (CL:EQ TEST-VALUE-001 SYM-WALK-LOCAL-NEW))
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-NEW-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-MAKE)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-MAKE-TREE TREE)))
         ((CL:OR
           (CL:EQ TEST-VALUE-001 SYM-WALK-FUNCALL)
           (CL:EQ TEST-VALUE-001 SYM-WALK-SYS-CALL-FUNCTION-CODE)
           (CL:EQ TEST-VALUE-001 SYM-WALK-SYS-CALL-METHOD-CODE))
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-FUNCALL-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-THE-CODE)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-THE-CODE-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-EXCEPTION-CASE)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-EXCEPTION-CASE-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-VERBATIM)
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-VERBATIM-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-INLINE)
          (CL:RETURN-FROM HELP-WALK-A-TREE (CL:VALUES TREE SGT-WALK-VOID)))
         ((CL:OR
           (CL:EQ TEST-VALUE-001 SYM-WALK-SYS-SLOT-VALUE)
           (CL:EQ TEST-VALUE-001 SYM-WALK-SYS-SLOT-VALUE-SETTER)
           (CL:EQ TEST-VALUE-001 SYM-WALK-SYS-CALL-METHOD)
           (CL:EQ TEST-VALUE-001 SYM-WALK-SYS-CALL-METHOD-SETTER)
           (CL:EQ TEST-VALUE-001 SYM-WALK-SYS-CALL-FUNCTION))
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-SYS-CALL-TREE TREE)))
         ((CL:EQ TEST-VALUE-001 SYM-WALK-SYS-NEW)
          (CL:RETURN-FROM HELP-WALK-A-TREE (CL:VALUES TREE (SECOND TREE))))
         ((CL:OR
           (CL:EQ TEST-VALUE-001 SYM-WALK-DEFCLASS)
           (CL:EQ TEST-VALUE-001 SYM-WALK-DEFMETHOD)
           (CL:EQ TEST-VALUE-001 SYM-WALK-DEFUN)
           (CL:EQ TEST-VALUE-001 SYM-WALK-DEFMACRO)
           (CL:EQ TEST-VALUE-001 SYM-WALK-STARTUP-TIME-PROGN)
           (CL:EQ TEST-VALUE-001 SYM-WALK-DEFGLOBAL)
           (CL:EQ TEST-VALUE-001 SYM-WALK-DEFSPECIAL)
           (CL:EQ TEST-VALUE-001 SYM-WALK-DEFCONSTANT))
          (CL:LET*
           ((*PRINTREADABLY?* TRUE))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN
            (CL:EQ (SUPPRESS-WARNINGS?) 0)
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
            (CL:LET
             ((%%STREAM
               (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM)
             (CL:WRITE-STRING
              " Illegal declaration -- must appear as a top-level statement;"
              %%STREAM)
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM)
             (CL:WRITE-STRING
              "   not nested within other statements.."
              %%STREAM)
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM))))
          (FREE-CONS-TREE TREE)
          (CL:RETURN-FROM HELP-WALK-A-TREE (CL:VALUES NULL SGT-WALK-VOID)))
         (CL:T
          (CL:IF
           (CL:EQ (SYMBOL? (FIRST TREE)) 1)
           (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-CALL-SLOT-TREE TREE))
           (CL:PROGN
            (CL:LET*
             ((*PRINTREADABLY?* TRUE))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-ERROR)
             (CL:WHEN
              (CL:EQ (SUPPRESS-WARNINGS?) 0)
              (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
              (CL:LET
               ((%%STREAM
                 (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
               (CL:TERPRI %%STREAM)
               (CL:FORCE-OUTPUT %%STREAM)
               (CL:WRITE-STRING
                " Illegal expression where method name expected:"
                %%STREAM)
               (CL:TERPRI %%STREAM)
               (CL:FORCE-OUTPUT %%STREAM)
               (CL:WRITE-STRING "   `" %%STREAM)
               (PRINT-OBJECT (FIRST TREE) %%STREAM)
               (CL:WRITE-STRING "'." %%STREAM)
               (CL:TERPRI %%STREAM)
               (CL:FORCE-OUTPUT %%STREAM))))
            (CL:RETURN-FROM
             HELP-WALK-A-TREE
             (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))))))))
     (CL:T (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-ATOMIC-TREE TREE))))))
  :VOID)

;;; (DEFUN (WALK-A-CONS-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-A-CONS-TREE (TREE)
  (CL:LET*
   ((OTREE NULL) (OTYPE NULL))
   (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE) (WALK-A-TREE TREE))
   (CL:RETURN-FROM WALK-A-CONS-TREE (CL:VALUES OTREE OTYPE)))
  :VOID)

;;; (DEFGLOBAL *SYMBOL-REGISTRY* ...)

(CL:DEFVAR *SYMBOL-REGISTRY* NULL)

;;; (DEFGLOBAL *SYMBOL-SET* ...)

(CL:DEFVAR *SYMBOL-SET* NULL)

;;; (DEFSPECIAL *CURRENTFILE* ...)

(CL:DEFVAR *CURRENTFILE* NULL
  "Name of file that is currently being translated.
A NULL value indicates an incremental translation.")

(CL:DEFUN READ-*CURRENTFILE* ()
  (CL:RETURN-FROM READ-*CURRENTFILE* *CURRENTFILE*)
  :VOID)

(CL:DEFUN WRITE-*CURRENTFILE* (VALUE)
  (CL:SETQ *CURRENTFILE* VALUE)
  (CL:RETURN-FROM WRITE-*CURRENTFILE* VALUE)
  :VOID)

;;; (DEFUN (INCREMENTAL-TRANSLATION? BOOLEAN) ...)

(CL:DEFUN INCREMENTAL-TRANSLATION? ()
  (CL:RETURN-FROM INCREMENTAL-TRANSLATION? (NULL? *CURRENTFILE*))
  :VOID)

;;; (DEFUN (YIELD-SYMBOL-CONSTANT-NAME SYMBOL) ...)

(CL:DEFUN YIELD-SYMBOL-CONSTANT-NAME (SYMBOL)
  (CL:LET*
   ((PREFIX NULL)
    (FILENAME
     (CL:IF
      (CL:EQ (INCREMENTAL-TRANSLATION?) 1)
      ""
      (CONCATENATE "-" *CURRENTFILE*))))
   (CL:LET*
    ((SYMBOL-001 SYMBOL))
    (CL:COND
     ((CL:EQ (SYMBOL? SYMBOL) 1)
      (CL:LET*
       ((SYMBOL NULL))
       (CL:SETQ SYMBOL SYMBOL-001)
       (CL:SETQ PREFIX "SYM")))
     ((CL:EQ (SURROGATE? SYMBOL) 1)
      (CL:LET*
       ((SYMBOL NULL))
       (CL:SETQ SYMBOL SYMBOL-001)
       (CL:SETQ PREFIX "SGT")))
     ((CL:EQ (KEYWORD? SYMBOL) 1)
      (CL:LET*
       ((SYMBOL NULL))
       (CL:SETQ SYMBOL SYMBOL-001)
       (CL:SETQ PREFIX "KWD")))
     (CL:T (CL:ERROR "`~A' is not a valid case option" SYMBOL))))
   (CL:RETURN-FROM
    YIELD-SYMBOL-CONSTANT-NAME
    (INTERN-DERIVED-SYMBOL
     SYMBOL
     (CONCATENATE
      PREFIX
      (CONCATENATE
       FILENAME
       (CONCATENATE "-" (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-NAME SYMBOL)))))))
  :VOID)

;;; (DEFUN (CREATE-STARTUP-SYMBOL SYMBOL) ...)

(CL:DEFUN CREATE-STARTUP-SYMBOL (SYMBOL)
  (CL:LET*
   ((SYMBOLMODULE (CLSYS-SVAL GENERALIZED-SYMBOL HOME-CONTEXT SYMBOL))
    (SYMBOLCONSTANT (YIELD-SYMBOL-CONSTANT-NAME SYMBOL))
    (SYMBOLCONSTANTNAME (CLSYS-SVAL SYMBOL SYMBOL-NAME SYMBOLCONSTANT))
    (SYMBOLCONSTANTTYPETREE (YIELD-TYPE-SPEC-TREE (PRIMARY-TYPE SYMBOL)))
    (NATIVEPACKAGE (NATIVE-PACKAGE SYMBOLMODULE))
    (TREE NULL))
   (CL:WHEN
    (CL:EQ (INCREMENTAL-TRANSLATION?) 1)
    (CL:proclaim 
             `(CL:special ,(CL:intern symbolConstantName nativePackage))))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* TRUE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:SETQ
     TREE
     (LIST*
      SYM-WALK-DEFGLOBAL
      SYMBOLCONSTANT
      (CONS SYMBOLCONSTANTTYPETREE (CONS SYM-WALK-NULL NIL)))))
   (WALK-AUXILIARY-TREE TREE)
   (CL:LET*
    ((*TRANSIENTOBJECTS?* TRUE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:SETQ
     TREE
     (LIST*
      SYM-WALK-STARTUP-TIME-PROGN
      KWD-WALK-SYMBOLS
      (LIST*
       SYM-WALK-SETQ
       SYMBOLCONSTANT
       (CONS
        (LIST*
         SYM-WALK-SAFE-CAST
         (LIST*
          SYM-WALK-INTERN-RIGID-SYMBOL-WRT-MODULE
          (WRAP-LITERAL (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-NAME SYMBOL))
          (CONS
           (CL:IF
            (CL:OR (CL:EQ SYMBOLMODULE *MODULE*) (CL:EQ (KEYWORD? SYMBOL) 1))
            SYM-WALK-NULL
            (LIST*
             SYM-WALK-GET-MODULE
             (WRAP-LITERAL (CLSYS-SVAL MODULE MODULE-FULL-NAME SYMBOLMODULE))
             (CONS SYM-WALK-TRUE NIL)))
           (CONS
            (WRAP-LITERAL
             (CL:IF
              (CL:EQ (KEYWORD? SYMBOL) 1)
              KEYWORD-SYM
              (CL:IF (CL:EQ (SURROGATE? SYMBOL) 1) SURROGATE-SYM SYMBOL-SYM)))
            NIL)))
         SYMBOLCONSTANTTYPETREE
         NIL)
        NIL))
      NIL)))
   (WALK-AUXILIARY-TREE TREE)
   (CL:RETURN-FROM CREATE-STARTUP-SYMBOL SYMBOLCONSTANT))
  :VOID)

;;; (DEFUN REGISTER-SYMBOL ...)

(CL:DEFUN REGISTER-SYMBOL (SYMBOL)
  (CL:SETQ SYMBOL (PERMANENTIFY SYMBOL))
  (CL:WHEN
   (CL:EQ (LOOKUP *SYMBOL-REGISTRY* SYMBOL) NULL)
   (INSERT-AT *SYMBOL-REGISTRY* SYMBOL SYMBOL)
   (INSERT *SYMBOL-SET* SYMBOL)
   (CL:WHEN (CL:EQ (USE-HARDCODED-SYMBOLS?) 0) (CREATE-STARTUP-SYMBOL SYMBOL)))
  :VOID)

;;; (DEFUN CLEAR-SYMBOL-REGISTRY ...)

(CL:DEFUN CLEAR-SYMBOL-REGISTRY ()
  (CL:LET*
   ((SYMBOL NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST *SYMBOL-SET*)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ SYMBOL (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (REMOVE-AT *SYMBOL-REGISTRY* SYMBOL)))
  (CLEAR *SYMBOL-SET*)
  :VOID)

;;; (DEFUN (YIELD-HARDCODED-INTERN-REGISTERED-SYMBOLS-TREE CONS) ...)

(CL:DEFUN YIELD-HARDCODED-INTERN-REGISTERED-SYMBOLS-TREE ()
  (CL:LET*
   ((*TRANSIENTOBJECTS?* TRUE))
   (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
   (CL:LET*
    ((INTERNTREES (LIST* SYM-WALK-STARTUP-TIME-PROGN KWD-WALK-SYMBOLS NIL)))
    (CL:LET*
     ((SYMBOL NULL)
      (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST *SYMBOL-SET*))
      (COLLECT-001 NULL))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ SYMBOL (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:IF
       (CL:EQ COLLECT-001 NULL)
       (CL:PROGN
        (CL:SETQ
         COLLECT-001
         (CONS
          (CONS
           (CL:IF
            (CL:EQ (SYMBOL? SYMBOL) 1)
            SYM-WALK-INTERN-SYMBOL-AT
            (CL:IF
             (CL:EQ (SURROGATE? SYMBOL) 1)
             SYM-WALK-INTERN-SURROGATE-AT
             SYM-WALK-INTERN-KEYWORD-AT))
           (CONS
            (WRAP-LITERAL (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-NAME SYMBOL))
            (CONS
             (WRAP-LITERAL (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-ID SYMBOL))
             NIL)))
          NIL))
        (CL:IF
         (CL:EQ INTERNTREES NIL)
         (CL:SETQ INTERNTREES COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST INTERNTREES COLLECT-001)))
       (CL:PROGN
        (CL:SETF
         (CLSYS-SVAL CONS REST COLLECT-001)
         (CONS
          (CONS
           (CL:IF
            (CL:EQ (SYMBOL? SYMBOL) 1)
            SYM-WALK-INTERN-SYMBOL-AT
            (CL:IF
             (CL:EQ (SURROGATE? SYMBOL) 1)
             SYM-WALK-INTERN-SURROGATE-AT
             SYM-WALK-INTERN-KEYWORD-AT))
           (CONS
            (WRAP-LITERAL (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-NAME SYMBOL))
            (CONS
             (WRAP-LITERAL (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-ID SYMBOL))
             NIL)))
          NIL))
        (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
    (CL:RETURN-FROM
     YIELD-HARDCODED-INTERN-REGISTERED-SYMBOLS-TREE
     INTERNTREES)))
  :VOID)

;;; (DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFMETHOD WALK-ATOMIC-TREE ((SELF OBJECT))
  (CL:ERROR "walk-atomic-tree: Not defined on `~A'" SELF)
  (CL:RETURN-FROM WALK-ATOMIC-TREE (CL:VALUES NULL NULL))
  :VOID)

;;; (DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFMETHOD WALK-ATOMIC-TREE ((SELF WRAPPER))
  (CL:RETURN-FROM WALK-ATOMIC-TREE (CL:VALUES SELF (WRAPPER-VALUE-TYPE SELF)))
  :VOID)

;;; (DEFUN (LOOKUP-CONSTANT-SYMBOL TYPE) ...)

(CL:DEFUN LOOKUP-CONSTANT-SYMBOL (SELF)
  (CL:COND
   ((CL:OR (CL:EQ SELF SYM-WALK-TRUE) (CL:EQ SELF SYM-WALK-FALSE))
    (CL:RETURN-FROM LOOKUP-CONSTANT-SYMBOL SGT-WALK-BOOLEAN))
   ((CL:EQ SELF SYM-WALK-NIL)
    (CL:RETURN-FROM LOOKUP-CONSTANT-SYMBOL SGT-WALK-CONS))
   ((CL:EQ SELF SYM-WALK-NULL)
    (CL:RETURN-FROM LOOKUP-CONSTANT-SYMBOL SGT-WALK-UNKNOWN))
   ((CL:EQ SELF SYM-WALK-NULL-BOOLEAN)
    (CL:RETURN-FROM LOOKUP-CONSTANT-SYMBOL SGT-WALK-BOOLEAN))
   ((CL:EQ SELF SYM-WALK-NULL-INTEGER)
    (CL:RETURN-FROM LOOKUP-CONSTANT-SYMBOL SGT-WALK-INTEGER))
   ((CL:EQ SELF SYM-WALK-NULL-FLOAT)
    (CL:RETURN-FROM LOOKUP-CONSTANT-SYMBOL SGT-WALK-FLOAT))
   (CL:T (CL:RETURN-FROM LOOKUP-CONSTANT-SYMBOL NULL)))
  :VOID)

;;; (DEFUN (CONSTANT-SYMBOL? BOOLEAN) ...)

(CL:DEFUN CONSTANT-SYMBOL? (SYMBOL)
  (CL:RETURN-FROM CONSTANT-SYMBOL? (DEFINED? (LOOKUP-CONSTANT-SYMBOL SYMBOL)))
  :VOID)

;;; (DEFUN (WALK-CONSTANT-SYMBOL SYMBOL TYPE) ...)

(CL:DEFUN WALK-CONSTANT-SYMBOL (SELF)
  (CL:RETURN-FROM
   WALK-CONSTANT-SYMBOL
   (CL:VALUES SELF (LOOKUP-CONSTANT-SYMBOL SELF)))
  :VOID)

;;; (DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFMETHOD WALK-ATOMIC-TREE ((SELF SYMBOL))
  (CL:WHEN
   (CL:EQ (CONSTANT-SYMBOL? SELF) 1)
   (CL:RETURN-FROM WALK-ATOMIC-TREE (WALK-CONSTANT-SYMBOL SELF)))
  (CL:RETURN-FROM WALK-ATOMIC-TREE (CL:VALUES SELF (LOOKUP-VARIABLE-TYPE SELF)))
  :VOID)

;;; (DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFMETHOD WALK-ATOMIC-TREE ((SELF KEYWORD))
  (REGISTER-SYMBOL SELF)
  (CL:RETURN-FROM WALK-ATOMIC-TREE (CL:VALUES SELF SGT-WALK-KEYWORD))
  :VOID)

;;; (DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFMETHOD WALK-ATOMIC-TREE ((SELF SURROGATE))
  (REGISTER-SYMBOL SELF)
  (CL:RETURN-FROM WALK-ATOMIC-TREE (CL:VALUES SELF SGT-WALK-SURROGATE))
  :VOID)

;;; (DEFUN (VRLET-EXPRESSION? BOOLEAN) ...)

(CL:DEFUN VRLET-EXPRESSION? (TREE)
  (CL:RETURN-FROM
   VRLET-EXPRESSION?
   (CL:IF
    (CL:AND
     (CL:EQ (CONS? TREE) 1)
     (CL:EQ (CLSYS-SVAL CONS VALUE TREE) SYM-WALK-VRLET))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (PROCEDURAL-EXPRESSION? BOOLEAN) ...)

(CL:DEFUN PROCEDURAL-EXPRESSION? (TREE)
  (CL:LET*
   ((TEST-VALUE-001 FALSE))
   (CL:SETQ TEST-VALUE-001 (CONS? TREE))
   (CL:WHEN
    (CL:EQ TEST-VALUE-001 1)
    (CL:IF
     (CL:EQ (CLSYS-SVAL CONS VALUE TREE) SYM-WALK-VRLET)
     (CL:SETQ TEST-VALUE-001 TRUE)
     (CL:LET*
      ((FOUND?-001 FALSE))
      (CL:LET*
       ((TERM NULL) (ITER-001 (CLSYS-SVAL CONS REST TREE)))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ TERM (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:WHEN
         (CL:EQ (PROCEDURAL-EXPRESSION? TERM) 1)
         (CL:SETQ FOUND?-001 TRUE)
         (CL:RETURN))))
      (CL:SETQ TEST-VALUE-001 FOUND?-001))))
   (CL:LET*
    ((VALUE-001 TEST-VALUE-001))
    (CL:RETURN-FROM PROCEDURAL-EXPRESSION? VALUE-001)))
  :VOID)

;;; (DEFUN (SUBSTITUTE-ONCE BOOLEAN) ...)

(CL:DEFUN SUBSTITUTE-ONCE (EXPRESSION NEWTREE OLDTREE)
  (CL:LET*
   ((EXPRESSION-001 EXPRESSION))
   (CL:COND
    ((CL:EQ (CONS? EXPRESSION) 1)
     (CL:LET*
      ((EXPRESSION NULL))
      (CL:SETQ EXPRESSION EXPRESSION-001)
      (CL:WHEN
       (CL:NOT (CL:EQ EXPRESSION NIL))
       (CL:WHEN
        (CL:EQ (EQL? (CLSYS-SVAL CONS VALUE EXPRESSION) OLDTREE) 1)
        (CL:SETF (CLSYS-SVAL CONS VALUE EXPRESSION) NEWTREE)
        (CL:RETURN-FROM SUBSTITUTE-ONCE TRUE))
       (CL:RETURN-FROM
        SUBSTITUTE-ONCE
        (CL:IF
         (CL:OR
          (CL:EQ
           (SUBSTITUTE-ONCE
            (CLSYS-SVAL CONS VALUE EXPRESSION)
            NEWTREE
            OLDTREE)
           1)
          (CL:EQ
           (SUBSTITUTE-ONCE (CLSYS-SVAL CONS REST EXPRESSION) NEWTREE OLDTREE)
           1))
         TRUE
         FALSE)))))
    (CL:T NULL)))
  (CL:RETURN-FROM SUBSTITUTE-ONCE FALSE)
  :VOID)

;;; (DEFUN (TRANSFORM-VRLET-EXPRESSION CONS TYPE-SPEC) ...)

(CL:DEFUN TRANSFORM-VRLET-EXPRESSION (STATEMENT VREXPRESSION)
  ()
  (CL:LET*
   ((CURSOR NULL) (LASTSTATEMENT NULL))
   (SUBSTITUTE-ONCE STATEMENT KWD-WALK-PLACE-WHERE-VRLET-WAS VREXPRESSION)
   (CL:SETF (CLSYS-SVAL CONS VALUE VREXPRESSION) SYM-WALK-LET)
   (CL:SETQ CURSOR (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST VREXPRESSION)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL CONS REST CURSOR) NIL)
     (CL:SETQ LASTSTATEMENT (CLSYS-SVAL CONS VALUE CURSOR))
     (CL:SETF (CLSYS-SVAL CONS VALUE CURSOR) STATEMENT)
     (CL:RETURN))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (SUBSTITUTE-ONCE STATEMENT LASTSTATEMENT KWD-WALK-PLACE-WHERE-VRLET-WAS)
   (CL:RETURN-FROM TRANSFORM-VRLET-EXPRESSION (WALK-A-CONS-TREE VREXPRESSION)))
  :VOID)

;;; (DEFUN (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION CONS) ...)

(CL:DEFUN HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION (EXPRESSION TESTVARIABLE)
  (CL:WHEN
   (CL:OR
    (CL:EQ (CONS? EXPRESSION) 0)
    (CL:EQ (PROCEDURAL-EXPRESSION? EXPRESSION) 0))
   (CL:RETURN-FROM
    HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
    (CONS (LIST* SYM-WALK-SETQ TESTVARIABLE (CONS EXPRESSION NIL)) NIL)))
  (CL:LET*
   ((EXP EXPRESSION)
    (OPERATOR (CLSYS-SVAL CONS VALUE EXP))
    (FIRSTARG (SECOND EXP))
    (OTHERARGS (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST EXP))))
   (CL:SETF (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST EXP)) NIL)
   (FREE-CONS-LIST EXP)
   (CL:COND
    ((CL:EQ OPERATOR SYM-WALK-AND)
     (CL:COND
      ((CL:EQ OTHERARGS NIL)
       (CL:RETURN-FROM
        HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
        (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION FIRSTARG TESTVARIABLE)))
      ((CL:EQ (PROCEDURAL-EXPRESSION? FIRSTARG) 1)
       (CL:RETURN-FROM
        HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
        (CONCATENATE
         (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION FIRSTARG TESTVARIABLE)
         (CONS
          (LIST*
           SYM-WALK-WHEN
           TESTVARIABLE
           (CONCATENATE
            (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
             (CONS SYM-WALK-AND (CONCATENATE OTHERARGS NIL))
             TESTVARIABLE)
            NIL))
          NIL))))
      (CL:T
       (CL:RETURN-FROM
        HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
        (LIST*
         (LIST* SYM-WALK-SETQ TESTVARIABLE (CONS FIRSTARG NIL))
         (LIST*
          SYM-WALK-WHEN
          TESTVARIABLE
          (CONCATENATE
           (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
            (CONS SYM-WALK-AND (CONCATENATE OTHERARGS NIL))
            TESTVARIABLE)
           NIL))
         NIL)))))
    ((CL:EQ OPERATOR SYM-WALK-OR)
     (CL:COND
      ((CL:EQ OTHERARGS NIL)
       (CL:RETURN-FROM
        HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
        (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION FIRSTARG TESTVARIABLE)))
      ((CL:EQ (PROCEDURAL-EXPRESSION? FIRSTARG) 1)
       (CL:RETURN-FROM
        HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
        (CONCATENATE
         (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION FIRSTARG TESTVARIABLE)
         (CONS
          (LIST*
           SYM-WALK-WHEN
           (LIST* SYM-WALK-NOT TESTVARIABLE NIL)
           (CONCATENATE
            (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
             (CONS SYM-WALK-OR (CONCATENATE OTHERARGS NIL))
             TESTVARIABLE)
            NIL))
          NIL))))
      (CL:T
       (CL:LET*
        ((OTHERARGSTEST
          (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
           (CONS SYM-WALK-OR (CONCATENATE OTHERARGS NIL))
           TESTVARIABLE)))
        (CL:WHEN
         (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST OTHERARGSTEST) NIL))
         (CL:SETQ
          OTHERARGSTEST
          (CONS (CONS SYM-WALK-PROGN (CONCATENATE OTHERARGSTEST NIL)) NIL)))
        (CL:RETURN-FROM
         HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
         (CONS
          (LIST*
           SYM-WALK-IF
           FIRSTARG
           (CONS
            (LIST* SYM-WALK-SETQ TESTVARIABLE (CONS SYM-WALK-TRUE NIL))
            (CONCATENATE OTHERARGSTEST NIL)))
          NIL))))))
    ((CL:EQ OPERATOR SYM-WALK-NOT)
     (CL:RETURN-FROM
      HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
      (CONCATENATE
       (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION FIRSTARG TESTVARIABLE)
       (CONS
        (LIST*
         SYM-WALK-SETQ
         TESTVARIABLE
         (CONS (LIST* SYM-WALK-NOT TESTVARIABLE NIL) NIL))
        NIL))))
    ((CL:EQ OPERATOR SYM-WALK-VRLET)
     (CL:LET*
      ((CURSOR OTHERARGS))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST CURSOR) NIL))
       DO
       (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
      (CL:SETF
       (CLSYS-SVAL CONS VALUE CURSOR)
       (LIST*
        SYM-WALK-SETQ
        TESTVARIABLE
        (CONS (CLSYS-SVAL CONS VALUE CURSOR) NIL))))
     (CL:RETURN-FROM
      HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
      (CONS (LIST* SYM-WALK-LET FIRSTARG (CONCATENATE OTHERARGS NIL)) NIL)))
    (CL:T (CL:ERROR "`~A' is not a valid case option" OPERATOR))))
  :VOID)

;;; (DEFUN (TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION CONS TYPE-SPEC) ...)

(CL:DEFUN TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION (STATEMENT VREXPRESSION)
  (CL:WHEN
   (CL:EQ (FIRST VREXPRESSION) SYM-WALK-VRLET)
   (CL:RETURN-FROM
    TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
    (TRANSFORM-VRLET-EXPRESSION STATEMENT VREXPRESSION)))
  (CL:LET*
   ((TESTVARIABLE (LOCAL-GENSYM "TEST-VALUE")) (OTREE NULL))
   (SUBSTITUTE-ONCE STATEMENT TESTVARIABLE VREXPRESSION)
   (CL:SETQ
    OTREE
    (WALK-WITHOUT-TYPE-TREE
     (LIST*
      SYM-WALK-LET
      (CONS (CONS TESTVARIABLE (CONS SYM-WALK-FALSE NIL)) NIL)
      (CONCATENATE
       (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
        VREXPRESSION
        TESTVARIABLE)
       (CONS STATEMENT NIL)))))
   (CL:RETURN-FROM
    TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
    (CL:VALUES OTREE SGT-WALK-BOOLEAN)))
  :VOID)

;;; (DEFUN (PERCOLATE-OUT-BOOLEAN-VRLET-EXPRESSIONS CONS) ...)

(CL:DEFUN PERCOLATE-OUT-BOOLEAN-VRLET-EXPRESSIONS (BOOLEANEXPRESSION)
  (CL:LET*
   ((TESTVARIABLE (LOCAL-GENSYM "TEST-VALUE")) (OTREE NULL))
   (CL:SETQ
    OTREE
    (LIST*
     SYM-WALK-VRLET
     (CONS (CONS TESTVARIABLE (CONS SYM-WALK-FALSE NIL)) NIL)
     (CONCATENATE
      (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
       BOOLEANEXPRESSION
       TESTVARIABLE)
      (CONS TESTVARIABLE NIL))))
   (CL:RETURN-FROM PERCOLATE-OUT-BOOLEAN-VRLET-EXPRESSIONS OTREE))
  :VOID)

;;; (DEFUN (TRANSFORM-PROCEDURAL-EXPRESSION CONS TYPE-SPEC) ...)

(CL:DEFUN TRANSFORM-PROCEDURAL-EXPRESSION (STATEMENT VREXPRESSION TYPE)
  ()
  (CL:IF
   (CL:EQ (TYPE-SPEC-TO-BASE-TYPE TYPE) SGT-WALK-BOOLEAN)
   (CL:RETURN-FROM
    TRANSFORM-PROCEDURAL-EXPRESSION
    (TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION STATEMENT VREXPRESSION))
   (CL:RETURN-FROM
    TRANSFORM-PROCEDURAL-EXPRESSION
    (TRANSFORM-VRLET-EXPRESSION STATEMENT VREXPRESSION)))
  :VOID)

;;; (DEFUN (PERCOLATE-OUT-VRLET-EXPRESSION CONS TYPE-SPEC) ...)

(CL:DEFUN PERCOLATE-OUT-VRLET-EXPRESSION (STATEMENT VREXPRESSION TYPE)
  (CL:LET*
   ((LASTSTATEMENT NULL)
    (CURSOR (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST VREXPRESSION))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL CONS REST CURSOR) NIL)
     (CL:SETQ LASTSTATEMENT (CLSYS-SVAL CONS VALUE CURSOR))
     (CL:SETF
      (CLSYS-SVAL CONS VALUE CURSOR)
      KWD-WALK-PLACE-WHERE-LAST-EXPRESSION-WAS)
     (CL:RETURN))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (SUBSTITUTE-ONCE STATEMENT LASTSTATEMENT VREXPRESSION)
   (SUBSTITUTE-ONCE
    VREXPRESSION
    STATEMENT
    KWD-WALK-PLACE-WHERE-LAST-EXPRESSION-WAS)
   (CL:RETURN-FROM
    PERCOLATE-OUT-VRLET-EXPRESSION
    (CL:VALUES VREXPRESSION TYPE)))
  :VOID)

;;; (DEFUN (WALK-SETQ-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SETQ-TREE (TREE)
  (BAD-ARGUMENT-COUNT? TREE 2)
  (CL:LET*
   ((VARIABLE (SECOND TREE))
    (VALUE (THIRD TREE))
    (VARIABLETYPE NULL)
    (OVALUE NULL)
    (OTYPE NULL))
   (CL:WHEN
    (CL:EQ (SYMBOL? VARIABLE) 0)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING
        " Illegal first argument to 'setq'; should be a symbol: `"
        %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE VARIABLE) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (CL:RETURN-FROM
     WALK-SETQ-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
   (CL:SETQ VARIABLETYPE (LOOKUP-VARIABLE-TYPE VARIABLE))
   (CL:MULTIPLE-VALUE-SETQ
    (OVALUE OTYPE)
    (WALK-EXPRESSION-TREE VALUE VARIABLETYPE SYM-WALK-SETQ TRUE))
   (THIRD-SETTER TREE OVALUE)
   (CL:WHEN
    (CL:EQ (PROCEDURAL-EXPRESSION? OVALUE) 0)
    (CL:WHEN
     (CL:AND
      (CL:EQ (WALKING-EXPRESSION?) 1)
      (CL:NOT (CL:EQ (TRANSLATOR-OUTPUT-LANGUAGE) KWD-WALK-COMMON-LISP)))
     (CL:RETURN-FROM
      WALK-SETQ-TREE
      (SET-TARGET-LANGUAGE-TYPE
       (SYS-TREE TREE OTYPE)
       (TYPE-SPEC-TO-BASE-TYPE VARIABLETYPE))))
    (CL:RETURN-FROM WALK-SETQ-TREE (CL:VALUES TREE OTYPE)))
   (FREE-TRANSIENT-TYPE-SPEC OTYPE)
   (CL:RETURN-FROM
    WALK-SETQ-TREE
    (TRANSFORM-PROCEDURAL-EXPRESSION
     TREE
     OVALUE
     (CL:IF (CL:EQ OTYPE SGT-WALK-UNKNOWN) VARIABLETYPE OTYPE))))
  :VOID)

;;; (DEFUN (YIELD-FIXED-SLOT-VALUE-SETTER-TREE CONS) ...)

(CL:DEFUN YIELD-FIXED-SLOT-VALUE-SETTER-TREE (SLOT OBJECTREF VALUETREE)
  (CL:RETURN-FROM
   YIELD-FIXED-SLOT-VALUE-SETTER-TREE
   (LIST*
    SYM-WALK-SYS-SLOT-VALUE-SETTER
    (CLSYS-SVAL SLOT SLOT-OWNER SLOT)
    (CONS
     (CLSYS-SVAL SLOT SLOT-NAME SLOT)
     (CONS
      OBJECTREF
      (CONS
       (WALK-EXPRESSION-TREE
        VALUETREE
        (TYPE SLOT)
        SYM-WALK-SLOT-VALUE-SETTER
        FALSE)
       NIL)))))
  :VOID)

;;; (DEFUN (WALK-SETF-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SETF-TREE (TREE)
  (CL:LET*
   ((PLACE NULL))
   (CL:WHEN (CL:EQ (CONS? (SECOND TREE)) 1) (CL:SETQ PLACE (SECOND TREE)))
   (CL:WHEN
    (CL:NOT
     (CL:AND
      (CL:NOT (CL:EQ PLACE NULL))
      (CL:EQ (SYMBOL? (FIRST PLACE)) 1)
      (CL:>=
       (LENGTH PLACE)
       (CL:IF (CL:EQ (FIRST PLACE) SYM-WALK-SLOT-VALUE) 3 2))))
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING
        " Illegal place argument in 'setf' expression: `"
        %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (CL:RETURN-FROM
     WALK-SETF-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
   (CL:WHEN
    (CL:EQ (BAD-ARGUMENT-COUNT? TREE 2) 1)
    (CL:RETURN-FROM
     WALK-SETF-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
   (CL:LET*
    ((OBJECTREF NULL) (OBJECTTYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (OBJECTREF OBJECTTYPE)
     (WALK-A-TREE (SECOND PLACE)))
    (CL:SETQ OBJECTREF (COERCE-A-TREE OBJECTREF OBJECTTYPE OBJECTTYPE))
    (CL:LET*
     ((OBJECTCLASS (TYPE-SPEC-TO-CLASS OBJECTTYPE))
      (SLOTNAME (FIRST PLACE))
      (SLOT (SAFE-LOOKUP-SLOT OBJECTCLASS SLOTNAME))
      (SLOTTYPE NULL)
      (SETTERMETHOD NULL)
      (OTHERPLACEARGUMENTS
       (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST PLACE)))
      (OTREE NIL))
     (CL:WHEN
      (CL:NOT (CL:EQ SLOT NULL))
      (CL:SETQ SLOTTYPE (COMPUTE-RETURN-TYPE-SPEC SLOT OBJECTTYPE)))
     (CL:LET*
      ((VALUEREF NULL) (VALUETYPESPEC NULL))
      (CL:MULTIPLE-VALUE-SETQ
       (VALUEREF VALUETYPESPEC)
       (WALK-EXPRESSION-TREE (THIRD TREE) SLOTTYPE SYM-WALK-SETF TRUE))
      (CL:WHEN
       (CL:EQ (PROCEDURAL-EXPRESSION? VALUEREF) 1)
       (THIRD-SETTER TREE VALUEREF)
       (CL:LET*
        ((OTREE NULL) (OTYPESPEC NULL))
        (CL:MULTIPLE-VALUE-SETQ
         (OTREE OTYPESPEC)
         (TRANSFORM-PROCEDURAL-EXPRESSION TREE VALUEREF VALUETYPESPEC))
        (FREE-TRANSIENT-TYPE-SPEC VALUETYPESPEC)
        (CL:RETURN-FROM WALK-SETF-TREE (CL:VALUES OTREE OTYPESPEC))))
      (CL:SETF (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST PLACE)) NIL)
      (FREE-CONS-LIST PLACE)
      (FREE-CONS-LIST TREE)
      (FREE-TRANSIENT-TYPE-SPEC OBJECTTYPE)
      (CL:WHEN
       (CL:EQ SLOTNAME SYM-WALK-SLOT-VALUE)
       (CL:RETURN-FROM
        WALK-SETF-TREE
        (WALK-A-CONS-TREE
         (LIST*
          SYM-WALK-SLOT-VALUE-SETTER
          OBJECTREF
          (CONS VALUEREF (CONCATENATE OTHERPLACEARGUMENTS NIL))))))
      (CL:LET*
       ((SLOT-001 SLOT))
       (CL:COND
        ((CL:EQ (STORAGE-SLOT? SLOT) 1)
         (CL:LET*
          ((SLOT NULL))
          (CL:SETQ SLOT SLOT-001)
          (CL:SETQ
           SETTERMETHOD
           (CL:IF
            (CL:NOT (CL:EQ (WRITER SLOT) NULL))
            (SAFE-LOOKUP-SLOT OBJECTCLASS (WRITER SLOT))
            (SAFE-LOOKUP-SLOT
             OBJECTCLASS
             (YIELD-SETTER-METHOD-NAME SLOTNAME))))
          (CL:WHEN
           (CL:NOT (CL:EQ SETTERMETHOD NULL))
           (CL:RETURN-FROM
            WALK-SETF-TREE
            (WALK-A-CONS-TREE
             (CONS
              (CLSYS-SVAL METHOD-SLOT SLOT-NAME SETTERMETHOD)
              (CONS
               OBJECTREF
               (CONS VALUEREF (CONCATENATE OTHERPLACEARGUMENTS NIL)))))))
          (CL:WHEN
           (CL:EQ (SYSTEM-DEFINED-SLOT-WRITER? SLOT) 1)
           (CL:LET*
            ((VALUE-001 NULL) (VALUE-002 NULL))
            (CL:MULTIPLE-VALUE-SETQ
             (VALUE-001 VALUE-002)
             (SYS-TREE-IF-NEEDED
              SLOT
              (LIST*
               SYM-WALK-SYS-CALL-METHOD
               (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SLOT)
               (CONS
                (YIELD-SETTER-METHOD-NAME SLOTNAME)
                (CONS
                 OBJECTREF
                 (CONS
                  (WALK-EXPRESSION-TREE VALUEREF SLOTTYPE SYM-WALK-SETF FALSE)
                  NIL))))
              OBJECTTYPE
              SLOTTYPE))
            (CL:RETURN-FROM WALK-SETF-TREE (CL:VALUES VALUE-001 VALUE-002))))
          (CL:SETQ
           OTREE
           (YIELD-SLOT-VALUE-SETTER-TREE
            SLOT
            OBJECTREF
            OBJECTTYPE
            VALUEREF
            SLOTTYPE
            NULL))
          (CL:IF
           (CL:EQ (PROCEDURAL-EXPRESSION? OTREE) 1)
           (CL:RETURN-FROM WALK-SETF-TREE (CL:VALUES OTREE SLOTTYPE))
           (CL:LET*
            ((VALUE-003 NULL) (VALUE-004 NULL))
            (CL:MULTIPLE-VALUE-SETQ
             (VALUE-003 VALUE-004)
             (SYS-TREE-IF-NEEDED SLOT OTREE OBJECTTYPE SLOTTYPE))
            (CL:RETURN-FROM
             WALK-SETF-TREE
             (CL:VALUES VALUE-003 VALUE-004))))))
        (CL:T
         (CL:RETURN-FROM
          WALK-SETF-TREE
          (WALK-A-CONS-TREE
           (CONS
            (YIELD-SETTER-METHOD-NAME SLOTNAME)
            (CONS
             OBJECTREF
             (CONS VALUEREF (CONCATENATE OTHERPLACEARGUMENTS NIL)))))))))))))
  :VOID)

;;; (DEFUN (YIELD-DYNAMIC-SLOT-VALUE-TREE CONS) ...)

(CL:DEFUN YIELD-DYNAMIC-SLOT-VALUE-TREE (SLOT OBJECTREF RETURNTYPE)
  (CL:WHEN
   (CL:EQ (STANDARD-DYNAMIC-SLOT-ACCESS? SLOT) 1)
   (CL:RETURN-FROM
    YIELD-DYNAMIC-SLOT-VALUE-TREE
    (YIELD-STANDARD-DYNAMIC-SLOT-VALUE-TREE SLOT OBJECTREF RETURNTYPE)))
  (CL:LET*
   ((TEST-VALUE-001 (ALLOCATION SLOT)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-WALK-DYNAMIC)
     (CL:LET*
      ((ANSWERVAR (LOCAL-GENSYM "ANSWER")))
      (CL:RETURN-FROM
       YIELD-DYNAMIC-SLOT-VALUE-TREE
       (LIST*
        SYM-WALK-VRLET
        (CONS
         (CONS
          ANSWERVAR
          (CONS RETURNTYPE (CONS (TYPE-TO-NULL-VALUE-TREE (TYPE SLOT)) NIL)))
         NIL)
        (LIST*
         SYM-WALK-FOREACH
         SYM-WALK-IT
         SYM-WALK-ON
         (LIST* SYM-WALK-DYNAMIC-SLOTS OBJECTREF NIL)
         SYM-WALK-WHERE
         (LIST*
          SYM-WALK-EQ?
          (LIST* SYM-WALK-KEY SYM-WALK-IT NIL)
          (LIST* SYM-WALK-BQUOTE (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT) NIL)
          NIL)
         SYM-WALK-DO
         (CL:IF
          (CL:EQ (SLOT-VALUE-IS-BARE-LITERAL? SLOT) 1)
          (LIST*
           SYM-WALK-LET
           (CONS
            (LIST*
             SYM-WALK-WRAPPEDVALUE
             (TYPE-TO-WRAPPED-TYPE (TYPE SLOT))
             (CONS (LIST* SYM-WALK-VALUE SYM-WALK-IT NIL) NIL))
            NIL)
           (LIST*
            SYM-WALK-SETQ
            ANSWERVAR
            (CONS
             (LIST* SYM-WALK-WRAPPER-VALUE SYM-WALK-WRAPPEDVALUE NIL)
             NIL))
           NIL)
          (LIST*
           SYM-WALK-SETQ
           ANSWERVAR
           (CONS (LIST* SYM-WALK-VALUE SYM-WALK-IT NIL) NIL)))
         (CONS (CONS SYM-WALK-BREAK NIL) NIL))
        ANSWERVAR
        NIL))))
    ((CL:EQ TEST-VALUE-001 KWD-WALK-BIT)
     (CL:ERROR "Allocation :bit IS NOT YET IMPLEMENTED"))
    (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
  :VOID)

;;; (DEFUN (YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE CONS) ...)

(CL:DEFUN YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE (SLOT OBJECTREF VALUEREF RETURNTYPE)
  (CL:LET*
   ((SLOTNAME (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT)))
   (CL:WHEN
    (CL:EQ (STANDARD-DYNAMIC-SLOT-ACCESS? SLOT) 1)
    (CL:RETURN-FROM
     YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE
     (YIELD-STANDARD-DYNAMIC-SLOT-VALUE-SETTER-TREE
      SLOT
      OBJECTREF
      VALUEREF
      RETURNTYPE)))
   (CL:LET*
    ((TEST-VALUE-001 (ALLOCATION SLOT)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-WALK-DYNAMIC)
      (CL:RETURN-FROM
       YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE
       (LIST*
        SYM-WALK-VRLET
        (LIST*
         (LIST*
          SYM-WALK-DYNAMICSLOTS
          (LIST* SYM-WALK-DYNAMIC-SLOTS OBJECTREF NIL)
          NIL)
         (LIST* SYM-WALK-NEWVALUE VALUEREF NIL)
         (LIST* SYM-WALK-FOUNDMATCHINGENTRY? SYM-WALK-FALSE NIL)
         NIL)
        (LIST*
         SYM-WALK-FOREACH
         SYM-WALK-IT
         SYM-WALK-ON
         SYM-WALK-DYNAMICSLOTS
         SYM-WALK-WHERE
         (LIST*
          SYM-WALK-EQ?
          (LIST* SYM-WALK-KEY SYM-WALK-IT NIL)
          (LIST* SYM-WALK-BQUOTE SLOTNAME NIL)
          NIL)
         SYM-WALK-DO
         (CL:IF
          (CL:EQ (SLOT-VALUE-IS-BARE-LITERAL? SLOT) 1)
          (LIST*
           SYM-WALK-LET
           (CONS
            (LIST*
             SYM-WALK-OLDVALUE
             (TYPE-TO-SYMBOL (TYPE-TO-WRAPPED-TYPE (TYPE SLOT)))
             (CONS (LIST* SYM-WALK-VALUE SYM-WALK-IT NIL) NIL))
            NIL)
           (LIST*
            SYM-WALK-SETF
            (LIST* SYM-WALK-WRAPPER-VALUE SYM-WALK-OLDVALUE NIL)
            SYM-WALK-NEWVALUE
            NIL)
           NIL)
          (LIST*
           SYM-WALK-SETF
           (LIST* SYM-WALK-VALUE SYM-WALK-IT NIL)
           SYM-WALK-NEWVALUE
           NIL))
         (CONS
          (LIST* SYM-WALK-SETQ SYM-WALK-FOUNDMATCHINGENTRY? SYM-WALK-TRUE NIL)
          NIL))
        (LIST*
         SYM-WALK-WHEN
         (LIST*
          SYM-WALK-AND
          (LIST* SYM-WALK-NOT SYM-WALK-FOUNDMATCHINGENTRY? NIL)
          (LIST* SYM-WALK-DEFINED? SYM-WALK-NEWVALUE NIL)
          NIL)
         (LIST*
          SYM-WALK-SETF
          (LIST* SYM-WALK-THE-KV-LIST SYM-WALK-DYNAMICSLOTS NIL)
          (LIST*
           SYM-WALK-KV-CONS
           (LIST* SYM-WALK-BQUOTE SLOTNAME NIL)
           (CL:IF
            (CL:EQ (SLOT-VALUE-IS-BARE-LITERAL? SLOT) 1)
            (LIST* SYM-WALK-WRAP-LITERAL SYM-WALK-NEWVALUE NIL)
            SYM-WALK-NEWVALUE)
           (CONS (LIST* SYM-WALK-THE-KV-LIST SYM-WALK-DYNAMICSLOTS NIL) NIL))
          NIL)
         NIL)
        SYM-WALK-NEWVALUE
        NIL)))
     ((CL:EQ TEST-VALUE-001 KWD-WALK-BIT)
      (CL:ERROR "Allocation :bit IS NOT YET IMPLEMENTED"))
     (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001)))))
  :VOID)

;;; (DEFUN (YIELD-NATIVE-SLOT-VALUE-TREE CONS) ...)

(CL:DEFUN YIELD-NATIVE-SLOT-VALUE-TREE (SLOT OBJECTREF OBJECTTYPE)
  (CL:SETQ SLOT (CANONICAL-SLOT SLOT))
  (CL:LET*
   ((MIXINSLOT?
     (CLSYS-SVAL
      CLASS
      MIXIN?
      (CLSYS-SVAL
       SURROGATE
       SURROGATE-VALUE
       (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SLOT))))
    (OBJECTCLASS (TYPE-SPEC-TO-CLASS OBJECTTYPE)))
   (CL:WHEN
    (CL:AND
     (CL:EQ MIXINSLOT? 1)
     (CL:EQ (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?) 1))
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL CLASS MIXIN? OBJECTCLASS) 1)
     (CL:RETURN-FROM
      YIELD-NATIVE-SLOT-VALUE-TREE
      (SYS-TREE
       (LIST*
        SYM-WALK-SYS-CALL-METHOD
        SGT-WALK-OBJECT
        (YIELD-NATIVE-SLOT-READER-NAME SLOT)
        (CONS OBJECTREF NIL))
       (CL:IF
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE SLOT SYM-WALK-SLOT-TYPE-SPECIFIER NULL)
          NULL))
        (DYNAMIC-SLOT-VALUE SLOT SYM-WALK-SLOT-TYPE-SPECIFIER NULL)
        (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SLOT))))))
   (CL:IF
    (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-HARDWIRED? SLOT) 1)
    (CL:RETURN-FROM
     YIELD-NATIVE-SLOT-VALUE-TREE
     (LIST*
      SYM-WALK-SYS-CALL-METHOD
      (CLSYS-SVAL CLASS CLASS-TYPE OBJECTCLASS)
      (CONS (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT) (CONS OBJECTREF NIL))))
    (CL:RETURN-FROM
     YIELD-NATIVE-SLOT-VALUE-TREE
     (LIST*
      SYM-WALK-SYS-SLOT-VALUE
      (CLSYS-SVAL CLASS CLASS-TYPE OBJECTCLASS)
      (CONS (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT) (CONS OBJECTREF NIL))))))
  :VOID)

;;; (DEFUN (YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE (SLOT OBJECTREF RETURNTYPE CSOPTIONS)
  (CL:LET*
   ((CONTEXTSENSITIVE?
     (CL:IF
      (CL:NOT
       (CL:AND
        (CL:NOT (CL:EQ CSOPTIONS NULL))
        (CL:EQ
         (SEARCH-PLIST CSOPTIONS KWD-WALK-CONTEXT-SENSITIVE?)
         SYM-WALK-FALSE)))
      TRUE
      FALSE))
    (DONTINHERIT?
     (CL:IF
      (CL:AND
       (CL:NOT (CL:EQ CSOPTIONS NULL))
       (CL:EQ (SEARCH-PLIST CSOPTIONS KWD-WALK-DONT-INHERIT?) SYM-WALK-TRUE))
      SYM-WALK-TRUE
      SYM-WALK-FALSE))
    (OBJECTREFCOPY OBJECTREF)
    (ONCEONLYWRAPPER?
     (CL:IF
      (CL:AND (CL:EQ CONTEXTSENSITIVE? 1) (CL:EQ (CONS? OBJECTREF) 1))
      TRUE
      FALSE))
    (LITERALSLOT? (SLOT-VALUE-IS-BARE-LITERAL? SLOT))
    (REALBASETYPE (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SLOT))
    (REALTYPESPEC (DYNAMIC-SLOT-VALUE SLOT SYM-WALK-SLOT-TYPE-SPECIFIER NULL))
    (OLDVALUETREE NULL)
    (OLDVALUEREF (LOCAL-GENSYM "OLD-VALUE"))
    (ACCESSTREE NULL))
   (CL:COND
    ((CL:EQ ONCEONLYWRAPPER? 1)
     (CL:SETQ OBJECTREF (LOCAL-GENSYM "OBJECT"))
     (PUSH-VARIABLE-BINDING
      OBJECTREF
      (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SLOT)))
    (CL:T
     (CL:SETQ
      OBJECTREF
      (SYS-TREE
       (WALK-WITHOUT-TYPE-TREE OBJECTREF)
       (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SLOT)))))
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SLOT) SGT-WALK-OBJECT)
   (CL:WHEN
    (CL:NOT (CL:EQ REALTYPESPEC NULL))
    (SET-DYNAMIC-SLOT-VALUE SLOT SYM-WALK-SLOT-TYPE-SPECIFIER NULL NULL))
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-CONTEXT-SENSITIVE? SLOT) FALSE)
   (CL:SETQ
    OLDVALUETREE
    (SYS-TREE
     (WALK-WITHOUT-TYPE-TREE
      (LIST*
       SYM-WALK-SLOT-VALUE
       (CL:IF
        (CL:EQ CONTEXTSENSITIVE? 1)
        (COPY-CONS-TREE OBJECTREF)
        OBJECTREF)
       (CONS (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT) NIL)))
     SGT-WALK-OBJECT))
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SLOT) REALBASETYPE)
   (CL:WHEN
    (CL:NOT (CL:EQ REALTYPESPEC NULL))
    (SET-DYNAMIC-SLOT-VALUE
     SLOT
     SYM-WALK-SLOT-TYPE-SPECIFIER
     REALTYPESPEC
     NULL))
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-CONTEXT-SENSITIVE? SLOT) TRUE)
   (CL:WHEN
    (CL:EQ CONTEXTSENSITIVE? 0)
    (CL:RETURN-FROM
     YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE
     (CL:VALUES OLDVALUETREE SGT-WALK-OBJECT)))
   (CL:WHEN (CL:EQ ONCEONLYWRAPPER? 1) (POP-VARIABLE-BINDING))
   (CL:SETQ
    ACCESSTREE
    (LIST*
     SYM-WALK-SAFE-CAST
     (LIST*
      SYM-WALK-ACCESS-IN-CONTEXT
      (CL:IF (CL:EQ ONCEONLYWRAPPER? 1) OLDVALUEREF OLDVALUETREE)
      (CONS OBJECTREF (CONS DONTINHERIT? NIL)))
     (YIELD-TYPE-SPEC-TREE
      (CL:IF
       (CL:EQ LITERALSLOT? 1)
       (TYPE-TO-WRAPPED-TYPE (TYPE SLOT))
       RETURNTYPE))
     NIL))
   (CL:WHEN
    (CL:EQ LITERALSLOT? 1)
    (CL:SETQ ACCESSTREE (LIST* SYM-WALK-WRAPPER-VALUE ACCESSTREE NIL)))
   (CL:IF
    (CL:EQ ONCEONLYWRAPPER? 1)
    (CL:RETURN-FROM
     YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE
     (CL:VALUES
      (LIST*
       SYM-WALK-VRLET
       (LIST*
        (CONS OBJECTREF (CONS OBJECTREFCOPY NIL))
        (CONS OLDVALUEREF (CONS OLDVALUETREE NIL))
        NIL)
       ACCESSTREE
       NIL)
      RETURNTYPE))
    (CL:RETURN-FROM
     YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE
     (CL:VALUES (WALK-WITHOUT-TYPE-TREE ACCESSTREE) RETURNTYPE))))
  :VOID)

;;; (DEFUN (YIELD-SLOT-VALUE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN YIELD-SLOT-VALUE-TREE (SLOT OBJECTREF OBJECTTYPE RETURNTYPE CSOPTIONS)
  (CL:IF
   (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-CONTEXT-SENSITIVE? SLOT) 1)
   (CL:RETURN-FROM
    YIELD-SLOT-VALUE-TREE
    (YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE
     SLOT
     OBJECTREF
     RETURNTYPE
     CSOPTIONS))
   (CL:IF
    (CL:EQ (DYNAMIC-STORAGE? SLOT) 1)
    (CL:RETURN-FROM
     YIELD-SLOT-VALUE-TREE
     (CL:VALUES
      (WALK-WITHOUT-TYPE-TREE
       (YIELD-DYNAMIC-SLOT-VALUE-TREE SLOT OBJECTREF RETURNTYPE))
      RETURNTYPE))
    (CL:RETURN-FROM
     YIELD-SLOT-VALUE-TREE
     (CL:VALUES
      (YIELD-NATIVE-SLOT-VALUE-TREE SLOT OBJECTREF OBJECTTYPE)
      RETURNTYPE))))
  :VOID)

;;; (DEFUN (WALK-SLOT-VALUE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SLOT-VALUE-TREE (TREE)
  (CL:LET*
   ((OBJECTREF NULL) (OBJECTTYPE NULL))
   (CL:MULTIPLE-VALUE-SETQ (OBJECTREF OBJECTTYPE) (WALK-A-TREE (SECOND TREE)))
   (CL:LET*
    ((SLOTNAME (THIRD TREE))
     (CSOPTIONS (NTH-REST TREE 3))
     (OBJECTCLASS (TYPE-SPEC-TO-CLASS OBJECTTYPE))
     (SLOT (SAFE-LOOKUP-SLOT OBJECTCLASS SLOTNAME))
     (OTREE NULL)
     (OTYPE NULL))
    (CL:WHEN
     (CL:EQ SLOT NULL)
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " Can't read a non-existent slot `" %%STREAM)
        (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE SLOTNAME) %%STREAM)
        (CL:WRITE-STRING "'" %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING "   on the class `" %%STREAM)
        (CL:WRITE-STRING (CLASS-NAME OBJECTCLASS) %%STREAM)
        (CL:WRITE-STRING "'." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     (CL:RETURN-FROM
      WALK-SLOT-VALUE-TREE
      (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-UNKNOWN)))
    (CL:LET*
     ((SLOT-001 SLOT))
     (CL:COND
      ((CL:EQ (METHOD-SLOT? SLOT) 1)
       (CL:LET*
        ((SLOT NULL))
        (CL:SETQ SLOT SLOT-001)
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN
          (CL:EQ (SUPPRESS-WARNINGS?) 0)
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING " Can't read the method slot `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE SLOT) %%STREAM)
           (CL:WRITE-STRING "' by calling 'slot-value'." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))))))
      ((CL:EQ (STORAGE-SLOT? SLOT) 1)
       (CL:LET*
        ((SLOT NULL))
        (CL:SETQ SLOT SLOT-001)
        (CL:SETQ OTYPE (COMPUTE-RETURN-TYPE-SPEC SLOT OBJECTTYPE))
        (CL:MULTIPLE-VALUE-SETQ
         (OTREE OTYPE)
         (YIELD-SLOT-VALUE-TREE SLOT OBJECTREF OBJECTTYPE OTYPE CSOPTIONS))
        (FREE-CONS-LIST TREE)
        (CL:IF
         (CL:EQ (PROCEDURAL-EXPRESSION? OTREE) 1)
         (CL:RETURN-FROM WALK-SLOT-VALUE-TREE (CL:VALUES OTREE OTYPE))
         (CL:LET*
          ((VALUE-001 NULL) (VALUE-002 NULL))
          (CL:MULTIPLE-VALUE-SETQ
           (VALUE-001 VALUE-002)
           (SYS-TREE-IF-NEEDED SLOT OTREE OBJECTTYPE OTYPE))
          (CL:RETURN-FROM
           WALK-SLOT-VALUE-TREE
           (CL:VALUES VALUE-001 VALUE-002))))))
      (CL:T (CL:ERROR "`~A' is not a valid case option" SLOT))))))
  :VOID)

;;; (DEFUN (YIELD-NATIVE-SLOT-VALUE-SETTER-TREE CONS) ...)

(CL:DEFUN YIELD-NATIVE-SLOT-VALUE-SETTER-TREE (SLOT OBJECTREF OBJECTTYPE VALUEREF)
  (CL:SETQ SLOT (CANONICAL-SLOT SLOT))
  (CL:LET*
   ((MIXINSLOT?
     (CLSYS-SVAL
      CLASS
      MIXIN?
      (CLSYS-SVAL
       SURROGATE
       SURROGATE-VALUE
       (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SLOT))))
    (OBJECTCLASS (TYPE-SPEC-TO-CLASS OBJECTTYPE)))
   (CL:WHEN
    (CL:AND
     (CL:EQ MIXINSLOT? 1)
     (CL:EQ (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?) 1))
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL CLASS MIXIN? OBJECTCLASS) 1)
     (CL:RETURN-FROM
      YIELD-NATIVE-SLOT-VALUE-SETTER-TREE
      (SYS-TREE
       (LIST*
        SYM-WALK-SYS-CALL-METHOD
        SGT-WALK-OBJECT
        (YIELD-NATIVE-SLOT-READER-NAME SLOT)
        (CONS OBJECTREF (CONS VALUEREF NIL)))
       (CL:IF
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE SLOT SYM-WALK-SLOT-TYPE-SPECIFIER NULL)
          NULL))
        (DYNAMIC-SLOT-VALUE SLOT SYM-WALK-SLOT-TYPE-SPECIFIER NULL)
        (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SLOT))))))
   (CL:WHEN
    (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-HARDWIRED? SLOT) 1)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING
        " Can't set the value of the hardwired slot `"
        %%STREAM)
       (PRINT-OBJECT (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SLOT) %%STREAM)
       (CL:WRITE-STRING "'.`" %%STREAM)
       (PRINT-OBJECT (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (CL:RETURN-FROM
     YIELD-NATIVE-SLOT-VALUE-SETTER-TREE
     (WALK-DONT-CALL-ME-TREE
      NULL
      (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SLOT))))
   (CL:RETURN-FROM
    YIELD-NATIVE-SLOT-VALUE-SETTER-TREE
    (LIST*
     SYM-WALK-SYS-SLOT-VALUE-SETTER
     (CLSYS-SVAL CLASS CLASS-TYPE OBJECTCLASS)
     (CONS
      (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT)
      (CONS OBJECTREF (CONS VALUEREF NIL))))))
  :VOID)

;;; (DEFUN (YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE (SLOT OBJECTREF VALUEREF RETURNTYPE CSOPTIONS)
  (CL:LET*
   ((CONTEXTSENSITIVE?
     (CL:IF
      (CL:NOT
       (CL:AND
        (CL:NOT (CL:EQ CSOPTIONS NULL))
        (CL:EQ
         (SEARCH-PLIST CSOPTIONS KWD-WALK-CONTEXT-SENSITIVE?)
         SYM-WALK-FALSE)))
      TRUE
      FALSE))
    (COPYTOCHILDREN
     (CL:IF
      (CL:AND
       (CL:NOT (CL:EQ CSOPTIONS NULL))
       (CL:EQ
        (SEARCH-PLIST CSOPTIONS KWD-WALK-COPY-TO-CHILDREN?)
        SYM-WALK-TRUE))
      SYM-WALK-TRUE
      SYM-WALK-FALSE))
    (REALBASETYPE (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SLOT))
    (REALTYPESPEC (DYNAMIC-SLOT-VALUE SLOT SYM-WALK-SLOT-TYPE-SPECIFIER NULL))
    (OBJECTVAR NULL)
    (VALUEVAR NULL)
    (OLDVALUEVAR NULL)
    (NEWVALUEVAR NULL)
    (OLDVALUETREE NULL)
    (SETNEWVALUETREE NULL))
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SLOT) SGT-WALK-OBJECT)
   (CL:WHEN
    (CL:NOT (CL:EQ REALTYPESPEC NULL))
    (SET-DYNAMIC-SLOT-VALUE SLOT SYM-WALK-SLOT-TYPE-SPECIFIER NULL NULL))
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-CONTEXT-SENSITIVE? SLOT) FALSE)
   (CL:COND
    ((CL:EQ CONTEXTSENSITIVE? 1)
     (CL:SETQ OBJECTVAR (LOCAL-GENSYM "OBJECT"))
     (CL:SETQ VALUEVAR (LOCAL-GENSYM "VALUE"))
     (CL:SETQ OLDVALUEVAR (LOCAL-GENSYM "OLD-VALUE"))
     (CL:SETQ NEWVALUEVAR (LOCAL-GENSYM "NEW-VALUE"))
     (PUSH-VARIABLE-BINDING
      OBJECTVAR
      (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SLOT))
     (PUSH-VARIABLE-BINDING NEWVALUEVAR SGT-WALK-OBJECT)
     (CL:SETQ
      OLDVALUETREE
      (SYS-TREE
       (WALK-WITHOUT-TYPE-TREE
        (LIST*
         SYM-WALK-SLOT-VALUE
         OBJECTVAR
         (CONS (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT) NIL)))
       SGT-WALK-OBJECT))
     (CL:SETQ
      SETNEWVALUETREE
      (SYS-TREE
       (WALK-WITHOUT-TYPE-TREE
        (LIST*
         SYM-WALK-SETF
         (LIST*
          SYM-WALK-SLOT-VALUE
          OBJECTVAR
          (CONS (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT) NIL))
         NEWVALUEVAR
         NIL))
       SGT-WALK-OBJECT)))
    (CL:T
     (CL:SETQ
      SETNEWVALUETREE
      (SYS-TREE
       (WALK-WITHOUT-TYPE-TREE
        (LIST*
         SYM-WALK-SETF
         (LIST*
          SYM-WALK-SLOT-VALUE
          OBJECTREF
          (CONS (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SLOT) NIL))
         VALUEREF
         NIL))
       SGT-WALK-OBJECT))))
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SLOT) REALBASETYPE)
   (CL:WHEN
    (CL:NOT (CL:EQ REALTYPESPEC NULL))
    (SET-DYNAMIC-SLOT-VALUE
     SLOT
     SYM-WALK-SLOT-TYPE-SPECIFIER
     REALTYPESPEC
     NULL))
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-CONTEXT-SENSITIVE? SLOT) TRUE)
   (CL:WHEN
    (CL:EQ CONTEXTSENSITIVE? 0)
    (CL:RETURN-FROM
     YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE
     (CL:VALUES SETNEWVALUETREE SGT-WALK-OBJECT)))
   (POP-VARIABLE-BINDING)
   (POP-VARIABLE-BINDING)
   (CL:RETURN-FROM
    YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE
    (CL:VALUES
     (LIST*
      SYM-WALK-VRLET
      (LIST*
       (CONS OBJECTVAR (CONS OBJECTREF NIL))
       (CONS VALUEVAR (CONS REALBASETYPE (CONS VALUEREF NIL)))
       (CONS OLDVALUEVAR (CONS OLDVALUETREE NIL))
       (CONS
        NEWVALUEVAR
        (CONS
         (LIST*
          SYM-WALK-UPDATE-IN-CONTEXT
          OLDVALUEVAR
          (CONS VALUEVAR (CONS OBJECTVAR (CONS COPYTOCHILDREN NIL))))
         NIL))
       NIL)
      (LIST*
       SYM-WALK-WHEN
       (LIST* SYM-WALK-NOT (LIST* SYM-WALK-CS-VALUE? OLDVALUEVAR NIL) NIL)
       SETNEWVALUETREE
       NIL)
      VALUEVAR
      NIL)
     RETURNTYPE)))
  :VOID)

;;; (DEFUN (YIELD-SLOT-VALUE-SETTER-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN YIELD-SLOT-VALUE-SETTER-TREE (SLOT OBJECTREF OBJECTTYPE VALUEREF RETURNTYPE CSOPTIONS)
  (CL:IF
   (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-CONTEXT-SENSITIVE? SLOT) 1)
   (CL:RETURN-FROM
    YIELD-SLOT-VALUE-SETTER-TREE
    (YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE
     SLOT
     OBJECTREF
     VALUEREF
     RETURNTYPE
     CSOPTIONS))
   (CL:IF
    (CL:EQ (DYNAMIC-STORAGE? SLOT) 1)
    (CL:RETURN-FROM
     YIELD-SLOT-VALUE-SETTER-TREE
     (CL:VALUES
      (WALK-WITHOUT-TYPE-TREE
       (YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE
        SLOT
        OBJECTREF
        VALUEREF
        RETURNTYPE))
      RETURNTYPE))
    (CL:RETURN-FROM
     YIELD-SLOT-VALUE-SETTER-TREE
     (CL:VALUES
      (YIELD-NATIVE-SLOT-VALUE-SETTER-TREE SLOT OBJECTREF OBJECTTYPE VALUEREF)
      RETURNTYPE))))
  :VOID)

;;; (DEFUN (WALK-SLOT-VALUE-SETTER-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SLOT-VALUE-SETTER-TREE (TREE)
  (CL:LET*
   ((OBJECTREF NULL) (OBJECTTYPE NULL))
   (CL:MULTIPLE-VALUE-SETQ (OBJECTREF OBJECTTYPE) (WALK-A-TREE (SECOND TREE)))
   (CL:LET*
    ((SLOTNAME (FOURTH TREE))
     (CSOPTIONS (NTH-REST TREE 4))
     (OBJECTCLASS (TYPE-SPEC-TO-CLASS OBJECTTYPE))
     (SLOT (SAFE-LOOKUP-SLOT OBJECTCLASS SLOTNAME))
     (VALUEREF NULL)
     (OTREE NULL)
     (OTYPE NULL))
    (CL:WHEN
     (CL:EQ SLOT NULL)
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " Can't set a non-existent slot `" %%STREAM)
        (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE SLOTNAME) %%STREAM)
        (CL:WRITE-STRING "'" %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING "   on the class `" %%STREAM)
        (CL:WRITE-STRING (CLASS-NAME OBJECTCLASS) %%STREAM)
        (CL:WRITE-STRING "'." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     (CL:RETURN-FROM
      WALK-SLOT-VALUE-SETTER-TREE
      (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
    (CL:LET*
     ((SLOT-001 SLOT))
     (CL:COND
      ((CL:EQ (METHOD-SLOT? SLOT) 1)
       (CL:LET*
        ((SLOT NULL))
        (CL:SETQ SLOT SLOT-001)
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN
          (CL:EQ (SUPPRESS-WARNINGS?) 0)
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING " Can't set the method slot `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE SLOT) %%STREAM)
           (CL:WRITE-STRING "' by calling 'slot-value-setter'." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))))))
      ((CL:EQ (STORAGE-SLOT? SLOT) 1)
       (CL:LET*
        ((SLOT NULL))
        (CL:SETQ SLOT SLOT-001)
        (CL:SETQ OTYPE (COMPUTE-RETURN-TYPE-SPEC SLOT OBJECTTYPE))
        (CL:SETQ
         VALUEREF
         (WALK-EXPRESSION-TREE
          (THIRD TREE)
          OTYPE
          SYM-WALK-SLOT-VALUE-SETTER
          FALSE))
        (CL:MULTIPLE-VALUE-SETQ
         (OTREE OTYPE)
         (YIELD-SLOT-VALUE-SETTER-TREE
          SLOT
          OBJECTREF
          OBJECTTYPE
          VALUEREF
          OTYPE
          CSOPTIONS))
        (FREE-CONS-LIST TREE)
        (CL:IF
         (CL:EQ (PROCEDURAL-EXPRESSION? OTREE) 1)
         (CL:RETURN-FROM WALK-SLOT-VALUE-SETTER-TREE (CL:VALUES OTREE OTYPE))
         (CL:LET*
          ((VALUE-001 NULL) (VALUE-002 NULL))
          (CL:MULTIPLE-VALUE-SETQ
           (VALUE-001 VALUE-002)
           (SYS-TREE-IF-NEEDED SLOT OTREE OBJECTTYPE OTYPE))
          (CL:RETURN-FROM
           WALK-SLOT-VALUE-SETTER-TREE
           (CL:VALUES VALUE-001 VALUE-002))))))
      (CL:T (CL:ERROR "`~A' is not a valid case option" SLOT))))))
  :VOID)

;;; (DEFUN (SAFE-YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFUN SAFE-YIELD-TYPE-SPECIFIER (TYPETREE)
  (CL:IF
   (CL:NOT (CL:EQ TYPETREE NULL))
   (CL:LET*
    ((TYPESPEC (YIELD-TYPE-SPECIFIER TYPETREE)))
    (VALIDATE-TYPE-SPECIFIER TYPESPEC NULL TRUE)
    (CL:RETURN-FROM SAFE-YIELD-TYPE-SPECIFIER TYPESPEC))
   (CL:RETURN-FROM SAFE-YIELD-TYPE-SPECIFIER NULL))
  :VOID)

;;; (DEFUN (WALK-A-DECLARATION CONS) ...)

(CL:DEFUN WALK-A-DECLARATION (VARIABLE TYPETREE VALUE INPUTPARAMETER?)
  (CL:LET*
   ((SOURCETYPE NULL)
    (TARGETTYPE (SAFE-YIELD-TYPE-SPECIFIER TYPETREE))
    (METHODOWNERTYPE
     (CL:IF
      (CL:NOT (CL:EQ *METHODBEINGWALKED* NULL))
      (CLSYS-SVAL METHOD-SLOT SLOT-OWNER *METHODBEINGWALKED*)
      NULL))
    (OVALUE NULL))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ TARGETTYPE NULL))
     (CL:NOT (CL:EQ METHODOWNERTYPE NULL))
     (CL:EQ (VOID? METHODOWNERTYPE) 0))
    (CL:SETQ
     TARGETTYPE
     (COMPUTE-RELATIVE-TYPE-SPEC TARGETTYPE METHODOWNERTYPE)))
   (CL:WHEN
    (CL:EQ INPUTPARAMETER? 0)
    (PUSH-VARIABLE-BINDING VARIABLE SGT-WALK-UNINITIALIZED)
    (CL:MULTIPLE-VALUE-SETQ
     (OVALUE SOURCETYPE)
     (WALK-EXPRESSION-TREE
      VALUE
      TARGETTYPE
      SYM-WALK-VARIABLE-DECLARATION
      TRUE))
    (CL:WHEN (CL:EQ TARGETTYPE NULL) (CL:SETQ TARGETTYPE SOURCETYPE))
    (POP-VARIABLE-BINDING))
   (PUSH-VARIABLE-BINDING VARIABLE TARGETTYPE)
   (CL:IF
    (CL:EQ INPUTPARAMETER? 1)
    (CL:RETURN-FROM WALK-A-DECLARATION (CONS VARIABLE (CONS TARGETTYPE NIL)))
    (CL:RETURN-FROM
     WALK-A-DECLARATION
     (CONS VARIABLE (CONS TARGETTYPE (CONS OVALUE NIL))))))
  :VOID)

;;; (DEFUN (WALK-VARIABLE-DECLARATIONS CONS) ...)

(CL:DEFUN WALK-VARIABLE-DECLARATIONS (DECLARATIONS)
  (CL:LET*
   ((ODECLARATIONS NIL) (VARIABLE NULL))
   (CL:LET*
    ((DECL NULL) (ITER-001 DECLARATIONS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ DECL (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:LET*
      ((DECL-001 DECL))
      (CL:COND
       ((CL:EQ (CONS? DECL) 1)
        (CL:LET*
         ((DECL NULL))
         (CL:SETQ DECL DECL-001)
         (CL:COND
          ((CL:EQ (SYMBOL? (FIRST DECL)) 0)
           (CL:LET*
            ((*PRINTREADABLY?* TRUE))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-ERROR)
            (CL:WHEN
             (CL:EQ (SUPPRESS-WARNINGS?) 0)
             (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
             (CL:LET
              ((%%STREAM
                (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING
               " Illegal variable in `let' declaration: `"
               %%STREAM)
              (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE DECL) %%STREAM)
              (CL:WRITE-STRING "'." %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM))))
           (CL:SETQ VARIABLE SYM-WALK-ILLEGAL-VARIABLE))
          (CL:T
           (CL:SETQ VARIABLE (FIRST DECL))
           (CL:WHEN
            (CL:NOT (CL:EQ (LOOKUP-GLOBAL-VARIABLE VARIABLE) NULL))
            (CL:LET*
             ((*PRINTREADABLY?* TRUE))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-ERROR)
             (CL:WHEN
              (CL:EQ (SUPPRESS-WARNINGS?) 0)
              (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
              (CL:LET
               ((%%STREAM
                 (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
               (CL:TERPRI %%STREAM)
               (CL:FORCE-OUTPUT %%STREAM)
               (CL:WRITE-STRING
                " Illegal binding of global or special variable in `let' declaration:"
                %%STREAM)
               (CL:TERPRI %%STREAM)
               (CL:FORCE-OUTPUT %%STREAM)
               (CL:WRITE-STRING "    `" %%STREAM)
               (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE DECL) %%STREAM)
               (CL:WRITE-STRING "'." %%STREAM)
               (CL:TERPRI %%STREAM)
               (CL:FORCE-OUTPUT %%STREAM))))
            (CL:SETQ VARIABLE SYM-WALK-ILLEGAL-VARIABLE))))
         (CL:CASE
          (LENGTH DECL)
          (1
           (CL:LET*
            ((*PRINTREADABLY?* TRUE))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-ERROR)
            (CL:WHEN
             (CL:EQ (SUPPRESS-WARNINGS?) 0)
             (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
             (CL:LET
              ((%%STREAM
                (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING
               " Missing argument(s) in `let' declaration: `"
               %%STREAM)
              (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE DECL) %%STREAM)
              (CL:WRITE-STRING "'." %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)))))
          (2
           (CL:WHEN
            (CL:EQ (SECOND DECL) SYM-WALK-NULL)
            (CL:LET*
             ((*PRINTREADABLY?* TRUE))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-ERROR)
             (CL:WHEN
              (CL:EQ (SUPPRESS-WARNINGS?) 0)
              (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
              (CL:LET
               ((%%STREAM
                 (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
               (CL:TERPRI %%STREAM)
               (CL:FORCE-OUTPUT %%STREAM)
               (CL:WRITE-STRING
                " Missing type specifier in `let' declaration: `"
                %%STREAM)
               (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE DECL) %%STREAM)
               (CL:WRITE-STRING "'." %%STREAM)
               (CL:TERPRI %%STREAM)
               (CL:FORCE-OUTPUT %%STREAM)))))
           (CL:SETQ
            ODECLARATIONS
            (CONS
             (WALK-A-DECLARATION VARIABLE NULL (SECOND DECL) FALSE)
             ODECLARATIONS)))
          (3
           (CL:SETQ
            ODECLARATIONS
            (CONS
             (WALK-A-DECLARATION VARIABLE (SECOND DECL) (THIRD DECL) FALSE)
             ODECLARATIONS)))
          (CL:OTHERWISE
           (CL:LET*
            ((*PRINTREADABLY?* TRUE))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-ERROR)
            (CL:WHEN
             (CL:EQ (SUPPRESS-WARNINGS?) 0)
             (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
             (CL:LET
              ((%%STREAM
                (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING
               " Too many terms in `let' declaration:`"
               %%STREAM)
              (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE DECL) %%STREAM)
              (CL:WRITE-STRING "'." %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM))))))
         (FREE-CONS-LIST DECL)))
       (CL:T
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN
          (CL:EQ (SUPPRESS-WARNINGS?) 0)
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING " Illegal `let' declaration: `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE DECL) %%STREAM)
           (CL:WRITE-STRING "'." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)))))))))
   (FREE-CONS-LIST DECLARATIONS)
   (CL:RETURN-FROM WALK-VARIABLE-DECLARATIONS (REVERSE ODECLARATIONS)))
  :VOID)

;;; (DEFUN (TRANSFORM-LET-WITH-PROCEDURAL-EXPRESSION CONS) ...)

(CL:DEFUN TRANSFORM-LET-WITH-PROCEDURAL-EXPRESSION (TREE)
  (CL:LET*
   ((FIRSTDECLARATION (FIRST (SECOND TREE)))
    (TYPETREE (SECOND FIRSTDECLARATION))
    (TYPETREECONS (CLSYS-SVAL CONS REST FIRSTDECLARATION))
    (VRLETTREE (WALK-WITHOUT-TYPE-TREE (THIRD FIRSTDECLARATION))))
   (CL:WHEN
    (CL:EQ TYPETREE SGT-WALK-UNKNOWN)
    (CL:SETF
     (CLSYS-SVAL CONS REST FIRSTDECLARATION)
     (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST FIRSTDECLARATION)))
    (FREE-CONS TYPETREECONS))
   (CL:LET*
    ((OTREE NULL) (UNUSEDTYPESPEC NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (OTREE UNUSEDTYPESPEC)
     (TRANSFORM-PROCEDURAL-EXPRESSION TREE VRLETTREE TYPETREE))
    (CL:SETQ UNUSEDTYPESPEC UNUSEDTYPESPEC)
    (CL:RETURN-FROM TRANSFORM-LET-WITH-PROCEDURAL-EXPRESSION OTREE)))
  :VOID)

;;; (DEFUN POP-LOCAL-VARIABLE-BINDINGS ...)

(CL:DEFUN POP-LOCAL-VARIABLE-BINDINGS (DECLARATIONS)
  (CL:LET*
   ((D NULL) (ITER-001 DECLARATIONS))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ D (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:PROGN D)
    (POP-VARIABLE-BINDING)))
  :VOID)

;;; (DEFUN (WALK-LET-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-LET-TREE (TREE)
  (SECOND-SETTER TREE (WALK-VARIABLE-DECLARATIONS (SECOND TREE)))
  (CL:LET*
   ((TEST-VALUE-001 FALSE))
   (CL:LET*
    ((FOUND?-001 FALSE))
    (CL:LET*
     ((D NULL) (ITER-001 (SECOND TREE)))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ D (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:WHEN
       (CL:EQ (PROCEDURAL-EXPRESSION? (THIRD D)) 1)
       (CL:SETQ FOUND?-001 TRUE)
       (CL:RETURN))))
    (CL:SETQ TEST-VALUE-001 FOUND?-001))
   (CL:SETQ TEST-VALUE-001 (CL:IF (CL:EQ TEST-VALUE-001 0) TRUE FALSE))
   (CL:WHEN
    (CL:EQ TEST-VALUE-001 1)
    (CL:SETF
     (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))
     (WALK-LIST-OF-TREES (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))
    (POP-LOCAL-VARIABLE-BINDINGS (SECOND TREE))
    (CL:RETURN-FROM WALK-LET-TREE (SYS-TREE TREE SGT-WALK-VOID))))
  (POP-LOCAL-VARIABLE-BINDINGS (SECOND TREE))
  (CL:LET*
   ((ORIGINALDECLARATIONS (SECOND TREE))
    (LEADINGDECLARATIONS NIL)
    (TRAILINGDECLARATIONS NIL)
    (LEADING? TRUE))
   (CL:LET*
    ((D NULL) (ITER-002 ORIGINALDECLARATIONS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ D (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:WHEN
      (CL:EQ (PROCEDURAL-EXPRESSION? (THIRD D)) 1)
      (CL:SETQ LEADING? FALSE))
     (CL:COND
      ((CL:EQ LEADING? 1)
       (CL:SETQ LEADINGDECLARATIONS (CONS D LEADINGDECLARATIONS))
       (PUSH-VARIABLE-BINDING (FIRST D) (SECOND D)))
      (CL:T (CL:SETQ TRAILINGDECLARATIONS (CONS D TRAILINGDECLARATIONS))))))
   (CL:SETQ LEADINGDECLARATIONS (REVERSE LEADINGDECLARATIONS))
   (CL:SETQ TRAILINGDECLARATIONS (REVERSE TRAILINGDECLARATIONS))
   (SECOND-SETTER TREE TRAILINGDECLARATIONS)
   (FREE-CONS-LIST ORIGINALDECLARATIONS)
   (CL:SETQ TREE (TRANSFORM-LET-WITH-PROCEDURAL-EXPRESSION TREE))
   (CL:WHEN
    (CL:NOT (CL:EQ LEADINGDECLARATIONS NIL))
    (POP-LOCAL-VARIABLE-BINDINGS LEADINGDECLARATIONS)
    (CL:SETQ TREE (LIST* SYM-WALK-LET LEADINGDECLARATIONS (CONS TREE NIL))))
   (CL:RETURN-FROM WALK-LET-TREE (WALK-A-CONS-TREE TREE)))
  :VOID)

;;; (DEFSPECIAL *SPECIALVARIABLESTACK* ...)

(CL:DEFVAR *SPECIALVARIABLESTACK* NULL
  "Stack mirroring the current state of bound specials
with their associated old-value variables.")

(CL:DEFUN READ-*SPECIALVARIABLESTACK* ()
  (CL:RETURN-FROM READ-*SPECIALVARIABLESTACK* *SPECIALVARIABLESTACK*)
  :VOID)

(CL:DEFUN WRITE-*SPECIALVARIABLESTACK* (VALUE)
  (CL:SETQ *SPECIALVARIABLESTACK* VALUE)
  (CL:RETURN-FROM WRITE-*SPECIALVARIABLESTACK* VALUE)
  :VOID)

;;; (DEFSPECIAL *SPECIALSENABLED?* ...)

(CL:DEFVAR *SPECIALSENABLED?* TRUE
  "TRUE if using specials is enabled and legal.")

(CL:DEFUN READ-*SPECIALSENABLED?* ()
  (CL:RETURN-FROM READ-*SPECIALSENABLED?* *SPECIALSENABLED?*)
  :VOID)

(CL:DEFUN WRITE-*SPECIALSENABLED?* (VALUE)
  (CL:SETQ *SPECIALSENABLED?* VALUE)
  (CL:RETURN-FROM WRITE-*SPECIALSENABLED?* VALUE)
  :VOID)

;;; (DEFSPECIAL *NOFSPECIALSATLOOPENTRY* ...)

(CL:DEFVAR *NOFSPECIALSATLOOPENTRY* 0
  "Number of specials bound at the most recent entry
to a LOOP/WHILE/FOREACH construct.")

(CL:DEFUN READ-*NOFSPECIALSATLOOPENTRY* ()
  (CL:RETURN-FROM READ-*NOFSPECIALSATLOOPENTRY* *NOFSPECIALSATLOOPENTRY*)
  :VOID)

(CL:DEFUN WRITE-*NOFSPECIALSATLOOPENTRY* (VALUE)
  (CL:SETQ *NOFSPECIALSATLOOPENTRY* VALUE)
  (CL:RETURN-FROM WRITE-*NOFSPECIALSATLOOPENTRY* VALUE)
  :VOID)

;;; (DEFUN (SPECIAL-IMPLEMENTATION-STYLE KEYWORD) ...)

(CL:DEFUN SPECIAL-IMPLEMENTATION-STYLE ()
  (CL:LET*
   ((TEST-VALUE-001 (TRANSLATOR-OUTPUT-LANGUAGE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-WALK-COMMON-LISP)
     (CL:RETURN-FROM SPECIAL-IMPLEMENTATION-STYLE KWD-WALK-COMMON-LISP))
    (CL:T
     (CL:RETURN-FROM SPECIAL-IMPLEMENTATION-STYLE KWD-WALK-SAVE-AND-RESTORE))))
  :VOID)

;;; (DEFUN PUSH-SPECIAL ...)

(CL:DEFUN PUSH-SPECIAL (VARIABLE OLDVALUEVARIABLE)
  (CL:SETF
   (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST *SPECIALVARIABLESTACK*)
   (KV-CONS
    (SOFT-PERMANENTIFY VARIABLE)
    (SOFT-PERMANENTIFY OLDVALUEVARIABLE)
    (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST *SPECIALVARIABLESTACK*)))
  :VOID)

;;; (DEFUN POP-SPECIAL ...)

(CL:DEFUN POP-SPECIAL ()
  (CL:LET*
   ((KVLIST (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST *SPECIALVARIABLESTACK*)))
   (CL:SETF
    (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST *SPECIALVARIABLESTACK*)
    (CLSYS-SVAL KV-CONS REST KVLIST))
   (FREE-KV-CONS KVLIST))
  :VOID)

;;; (DEFUN (LOOKUP-OLD-VALUE-VARIABLE SYMBOL) ...)

(CL:DEFUN LOOKUP-OLD-VALUE-VARIABLE (VARIABLE)
  (CL:RETURN-FROM
   LOOKUP-OLD-VALUE-VARIABLE
   (LOOKUP *SPECIALVARIABLESTACK* VARIABLE))
  :VOID)

;;; (DEFUN (NEED-TO-UNBIND-SPECIALS? BOOLEAN) ...)

(CL:DEFUN NEED-TO-UNBIND-SPECIALS? ()
  (CL:RETURN-FROM
   NEED-TO-UNBIND-SPECIALS?
   (CL:IF
    (CL:AND
     (CL:EQ *SPECIALSENABLED?* 1)
     (CL:> (LENGTH *SPECIALVARIABLESTACK*) 0)
     (CL:EQ
      (MEMBER?
       (GET-QUOTED-TREE
        "((:COMMON-LISP :UNBIND-WITH-DESTRUCTORS) \"/STELLA\")"
        "/STELLA")
       (SPECIAL-IMPLEMENTATION-STYLE))
      0))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (YIELD-SPECIAL-UNBIND-TREE CONS) ...)

(CL:DEFUN YIELD-SPECIAL-UNBIND-TREE (NOFBINDINGS)
  (CL:LET*
   ((OTREE NIL))
   (CL:LET*
    ((TEST-VALUE-001 (SPECIAL-IMPLEMENTATION-STYLE)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-WALK-SAVE-AND-RESTORE)
      (CL:LET*
       ((OLDVALUEVARIABLE NULL)
        (VARIABLE NULL)
        (ITER-001
         (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST *SPECIALVARIABLESTACK*)))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NULL))
        DO
        (CL:SETQ VARIABLE (CLSYS-SVAL KV-CONS KEY ITER-001))
        (CL:PROGN
         (CL:SETQ OLDVALUEVARIABLE (CLSYS-SVAL KV-CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL KV-CONS REST ITER-001)))
        (CL:WHEN
         (CL:>= (CL:SETQ NOFBINDINGS (CL:1- NOFBINDINGS)) 0)
         (CL:LET*
          ((VALUE-001 NULL))
          (CL:LET*
           ((TREE NULL) (ITER-002 OTREE))
           (CL:LOOP
            WHILE
            (CL:NOT (CL:EQ ITER-002 NIL))
            DO
            (CL:PROGN
             (CL:SETQ TREE (CLSYS-SVAL CONS VALUE ITER-002))
             (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
            (CL:WHEN
             (CL:EQ (SECOND TREE) VARIABLE)
             (CL:SETQ VALUE-001 TREE)
             (CL:RETURN))))
          (CL:SETQ OTREE (REMOVE OTREE VALUE-001)))
         (CL:SETQ
          OTREE
          (CONS
           (LIST* SYM-WALK-SETQ VARIABLE (CONS OLDVALUEVARIABLE NIL))
           OTREE)))))
      (CL:RETURN-FROM YIELD-SPECIAL-UNBIND-TREE (PROGNIFY (REVERSE OTREE))))
     (CL:T (CL:RETURN-FROM YIELD-SPECIAL-UNBIND-TREE NULL)))))
  :VOID)

;;; (DEFUN (YIELD-RETURN-SPECIAL-UNBIND-TREE CONS) ...)

(CL:DEFUN YIELD-RETURN-SPECIAL-UNBIND-TREE ()
  (CL:RETURN-FROM
   YIELD-RETURN-SPECIAL-UNBIND-TREE
   (YIELD-SPECIAL-UNBIND-TREE (LENGTH *SPECIALVARIABLESTACK*)))
  :VOID)

;;; (DEFUN (YIELD-LOOP-EXIT-SPECIAL-UNBIND-TREE CONS) ...)

(CL:DEFUN YIELD-LOOP-EXIT-SPECIAL-UNBIND-TREE ()
  (CL:RETURN-FROM
   YIELD-LOOP-EXIT-SPECIAL-UNBIND-TREE
   (YIELD-SPECIAL-UNBIND-TREE
    (CL:- (LENGTH *SPECIALVARIABLESTACK*) *NOFSPECIALSATLOOPENTRY*)))
  :VOID)

;;; (DEFUN (WALK-SPECIAL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SPECIAL-TREE (TREE)
  (CL:WHEN
   (CL:EQ *SPECIALSENABLED?* 0)
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING
       " 'special' statement not legal in the current context: "
       %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING "`" %%STREAM)
      (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
      (CL:WRITE-STRING "'." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))))
   (CL:RETURN-FROM
    WALK-SPECIAL-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
  (CL:LET*
   ((TEST-VALUE-001 FALSE))
   (CL:IF
    (CL:< (LENGTH TREE) 2)
    (CL:SETQ TEST-VALUE-001 TRUE)
    (CL:IF
     (CL:EQ (CONS? (SECOND TREE)) 0)
     (CL:SETQ TEST-VALUE-001 TRUE)
     (CL:PROGN
      (CL:LET*
       ((ALWAYS?-001 TRUE))
       (CL:LET*
        ((BINDING NULL) (ITER-001 (SECOND TREE)))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-001 NIL))
         DO
         (CL:PROGN
          (CL:SETQ BINDING (CLSYS-SVAL CONS VALUE ITER-001))
          (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
         (CL:WHEN
          (CL:NOT
           (CL:AND
            (CL:EQ (CONS? BINDING) 1)
            (CL:EQ (SYMBOL? (FIRST BINDING)) 1)
            (CL:= (LENGTH BINDING) 2)))
          (CL:SETQ ALWAYS?-001 FALSE)
          (CL:RETURN))))
       (CL:SETQ TEST-VALUE-001 ALWAYS?-001))
      (CL:SETQ TEST-VALUE-001 (CL:IF (CL:EQ TEST-VALUE-001 0) TRUE FALSE)))))
   (CL:WHEN
    (CL:EQ TEST-VALUE-001 1)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Illegal 'special' statement: `" %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (CL:RETURN-FROM
     WALK-SPECIAL-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID))))
  (CL:WHEN
   (CL:= (LENGTH (SECOND TREE)) 0)
   (FIRST-SETTER TREE SYM-WALK-LET)
   (CL:RETURN-FROM WALK-SPECIAL-TREE (WALK-LET-TREE TREE)))
  (CL:LET*
   ((VARIABLE NULL))
   (CL:LET*
    ((BINDING NULL) (ITER-002 (SECOND TREE)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ BINDING (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:SETQ VARIABLE (LOOKUP-GLOBAL-VARIABLE (FIRST BINDING)))
     (CL:WHEN
      (CL:OR
       (CL:EQ VARIABLE NULL)
       (CL:EQ (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SPECIAL? VARIABLE) 0))
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN
        (CL:EQ (SUPPRESS-WARNINGS?) 0)
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING " Trying to bind non-special variable `" %%STREAM)
         (PRINT-OBJECT (FIRST BINDING) %%STREAM)
         (CL:WRITE-STRING "'" %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING " in 'special' statement." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))))))))
  (CL:LET*
   ((TEST-VALUE-002 (SPECIAL-IMPLEMENTATION-STYLE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-002 KWD-WALK-COMMON-LISP)
     (CL:RETURN-FROM WALK-SPECIAL-TREE (WALK-CL-SPECIAL-TREE TREE)))
    ((CL:EQ TEST-VALUE-002 KWD-WALK-SAVE-AND-RESTORE)
     (CL:RETURN-FROM
      WALK-SPECIAL-TREE
      (WALK-SAVE-AND-RESTORE-SPECIAL-TREE TREE)))
    (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-002))))
  :VOID)

;;; (DEFUN (WALK-CL-SPECIAL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-CL-SPECIAL-TREE (TREE)
  (CL:LET*
   ((BINDINGS (SECOND TREE))
    (BODY (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
    (VARIABLENAME NULL)
    (VARIABLETYPE NULL)
    (BINDVIASETQ? FALSE)
    (BINDVIASETQTREES NIL)
    (OTREE NULL))
   (CL:LET*
    ((BINDING NULL) (ITER-001 BINDINGS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ BINDING (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:SETQ VARIABLENAME (FIRST BINDING))
     (CL:SETQ VARIABLETYPE (LOOKUP-GLOBAL-VARIABLE-TYPE VARIABLENAME))
     (CL:COND
      ((CL:EQ BINDVIASETQ? 1)
       (CL:SETQ
        BINDVIASETQTREES
        (CONS
         (WALK-A-TREE
          (LIST* SYM-WALK-SETQ VARIABLENAME (CONS (SECOND BINDING) NIL)))
         BINDVIASETQTREES))
       (SECOND-SETTER BINDING VARIABLETYPE)
       (CL:SETF
        (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST BINDING))
        (CONS SYM-WALK-NULL NIL)))
      (CL:T
       (CL:SETQ
        OTREE
        (WALK-EXPRESSION-TREE
         (SECOND BINDING)
         VARIABLETYPE
         SYM-WALK-SPECIAL
         TRUE))
       (CL:WHEN
        (CL:EQ (PROCEDURAL-EXPRESSION? OTREE) 1)
        (CL:SETQ BINDVIASETQ? TRUE)
        (CL:SETQ
         BINDVIASETQTREES
         (CONS
          (WALK-A-TREE (LIST* SYM-WALK-SETQ VARIABLENAME (CONS OTREE NIL)))
          BINDVIASETQTREES))
        (CL:SETQ OTREE SYM-WALK-NULL))
       (SECOND-SETTER BINDING VARIABLETYPE)
       (CL:SETF
        (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST BINDING))
        (CONS OTREE NIL))))))
   (FIRST-SETTER TREE SYM-WALK-SPECIAL)
   (CL:SETF
    (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))
    (CONCATENATE (REVERSE BINDVIASETQTREES) (WALK-LIST-OF-TREES BODY)))
   (CL:RETURN-FROM WALK-CL-SPECIAL-TREE (SYS-TREE TREE SGT-WALK-VOID)))
  :VOID)

;;; (DEFUN (WALK-SAVE-AND-RESTORE-SPECIAL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SAVE-AND-RESTORE-SPECIAL-TREE (TREE)
  (CL:WHEN
   (CL:EQ (FIRST TREE) SYM-WALK-SPECIAL)
   (FIRST-SETTER TREE SYM-WALK-SYS-SPECIAL)
   (CL:RETURN-FROM
    WALK-SAVE-AND-RESTORE-SPECIAL-TREE
    (WALK-PROTECTED-SAVE-AND-RESTORE-SPECIAL-TREE TREE)))
  (CL:LET*
   ((BINDINGS (SECOND TREE))
    (BODY (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
    (VARIABLE NULL)
    (OLDVALUEVARIABLE NULL)
    (OLDVALUEBINDINGS NIL)
    (BINDTREES NIL)
    (UNBINDTREES NIL))
   (CL:LET*
    ((BINDING NULL) (ITER-001 BINDINGS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ BINDING (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:SETQ VARIABLE (FIRST BINDING))
     (CL:SETQ
      BINDTREES
      (CONS
       (LIST* SYM-WALK-SETQ VARIABLE (CONS (SECOND BINDING) NIL))
       BINDTREES))
     (CL:SETQ
      OLDVALUEVARIABLE
      (LOCAL-GENSYM
       (CONCATENATE "OLD-" (CLSYS-SVAL SYMBOL SYMBOL-NAME VARIABLE))))
     (PUSH-SPECIAL VARIABLE OLDVALUEVARIABLE)
     (CL:SETQ
      OLDVALUEBINDINGS
      (CONS (CONS OLDVALUEVARIABLE (CONS VARIABLE NIL)) OLDVALUEBINDINGS))
     (CL:SETQ
      UNBINDTREES
      (CONS
       (LIST* SYM-WALK-SETQ VARIABLE (CONS OLDVALUEVARIABLE NIL))
       UNBINDTREES))))
   (CL:SETQ
    TREE
    (WALK-A-TREE
     (LIST*
      SYM-WALK-LET
      (REVERSE OLDVALUEBINDINGS)
      (CONCATENATE
       (REVERSE BINDTREES)
       (CONCATENATE BODY (CONCATENATE UNBINDTREES NIL))))))
   (CL:LET*
    ((BINDING NULL) (ITER-002 BINDINGS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ BINDING (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:SETQ BINDING BINDING)
     (POP-SPECIAL)))
   (CL:RETURN-FROM
    WALK-SAVE-AND-RESTORE-SPECIAL-TREE
    (CL:VALUES TREE SGT-WALK-VOID)))
  :VOID)

;;; (DEFUN (WALK-PROTECTED-SAVE-AND-RESTORE-SPECIAL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-PROTECTED-SAVE-AND-RESTORE-SPECIAL-TREE (TREE)
  (CL:WHEN
   (CL:EQ (USE-STELLA-EXCEPTIONS?) 0)
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-WARNING)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING
       " Protection of special-unbinding via native exception handling"
       %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING " is not yet implemented." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)))))
  (CL:LET*
   ((SPECIALTREE (LIST* SYM-WALK-PROGN TREE NIL))
    (OLDVALUEBINDINGS NULL)
    (UNBINDTREES NIL))
   (CL:SETQ
    TREE
    (WALK-A-TREE (YIELD-PROTECTED-STATEMENT-TREE SPECIALTREE TRUE)))
   (CL:SETF
    (CLSYS-SVAL CONS REST SPECIALTREE)
    (CLSYS-SVAL CONS REST (SECOND (SECOND SPECIALTREE))))
   (CL:SETQ OLDVALUEBINDINGS (SECOND SPECIALTREE))
   (CL:SETF
    (CLSYS-SVAL CONS REST SPECIALTREE)
    (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST SPECIALTREE)))
   (CL:LET*
    ((BINDING NULL) (ITER-001 OLDVALUEBINDINGS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ BINDING (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:SETQ
      UNBINDTREES
      (CONS
       (LIST* SYM-WALK-SETQ (LAST BINDING) (CONS (FIRST BINDING) NIL))
       UNBINDTREES))))
   (CL:LET*
    ((VALUE-001 NULL) (VALUE-002 NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (VALUE-001 VALUE-002)
     (WALK-A-TREE
      (LIST*
       SYM-WALK-LET
       OLDVALUEBINDINGS
       (CONS
        TREE
        (CONS
         (YIELD-EXCEPTION-HANDLER-TREE
          (CONS
           (LIST*
            SYM-WALK-EXCEPTION
            NIL
            (CONCATENATE UNBINDTREES (CONS (CONS SYM-WALK-RESIGNAL NIL) NIL)))
           NIL))
         NIL)))))
    (CL:RETURN-FROM
     WALK-PROTECTED-SAVE-AND-RESTORE-SPECIAL-TREE
     (CL:VALUES VALUE-001 VALUE-002))))
  :VOID)

;;; (DEFUN (WALK-CAST-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-CAST-TREE (TREE)
  (BAD-ARGUMENT-COUNT? TREE 2)
  (CL:LET*
   ((TYPESPEC (YIELD-TYPE-SPECIFIER (THIRD TREE)))
    (BASETYPE (TYPE-SPEC-TO-BASE-TYPE TYPESPEC)))
   (SECOND-SETTER
    TREE
    (WALK-EXPRESSION-TREE (SECOND TREE) SGT-WALK-UNKNOWN SYM-WALK-CAST TRUE))
   (CL:WHEN
    (CL:EQ (VRLET-EXPRESSION? (SECOND TREE)) 1)
    (CL:RETURN-FROM
     WALK-CAST-TREE
     (PERCOLATE-OUT-VRLET-EXPRESSION TREE (SECOND TREE) TYPESPEC)))
   (THIRD-SETTER TREE BASETYPE)
   (CL:WHEN
    (CL:AND
     (CL:EQ (TRANSLATOR-OUTPUT-LANGUAGE) KWD-WALK-COMMON-LISP)
     (CL:EQ (FIRST TREE) SYM-WALK-CAST)
     (CL:>= *SAFETY* 2))
    (REGISTER-SYMBOL BASETYPE))
   (CL:WHEN
    (CL:NOT (CL:EQ TYPESPEC BASETYPE))
    (CL:SETQ TREE (SYS-TREE TREE TYPESPEC)))
   (CL:RETURN-FROM WALK-CAST-TREE (CL:VALUES TREE TYPESPEC)))
  :VOID)

;;; (DEFUN (VALUES-TREE? BOOLEAN) ...)

(CL:DEFUN VALUES-TREE? (TREE)
  (CL:RETURN-FROM
   VALUES-TREE?
   (CL:IF
    (CL:AND (CL:EQ (CONS? TREE) 1) (CL:EQ SYM-WALK-VALUES (FIRST TREE)))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (WALK-VALUES-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-VALUES-TREE (TREE)
  (CL:LET*
   ((OTREE NULL)
    (OTYPE NULL)
    (BINDTREE NIL)
    (VALUEVAR NULL)
    (HASPROCEDURALVALUE? FALSE))
   (CL:LET*
    ((IT (ALLOCATE-ITERATOR (CLSYS-SVAL CONS REST TREE))))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? IT) 1)
     DO
     (CL:MULTIPLE-VALUE-SETQ
      (OTREE OTYPE)
      (WALK-A-TREE (CLSYS-SVAL CONS-ITERATOR VALUE IT)))
     (CL:WHEN
      (CL:EQ (VRLET-EXPRESSION? OTREE) 1)
      (VALUE-SETTER IT OTREE)
      (CL:SETQ HASPROCEDURALVALUE? TRUE)
      (CL:RETURN))
     (CL:SETQ OTREE (SYS-TREE OTREE OTYPE))
     (CL:WHEN
      (CL:EQ (VOID? OTYPE) 1)
      (CL:SETQ OTREE (CONCATENATE OTREE (CONS SGT-WALK-VOID NIL))))
     (VALUE-SETTER IT OTREE)))
   (CL:WHEN
    (CL:EQ HASPROCEDURALVALUE? 0)
    (FIRST-SETTER TREE SYM-WALK-PROGN)
    (CL:RETURN-FROM WALK-VALUES-TREE (CL:VALUES TREE SGT-WALK-VOID)))
   (CL:LET*
    ((IT (ALLOCATE-ITERATOR (CLSYS-SVAL CONS REST TREE))))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? IT) 1)
     DO
     (CL:LET*
      ((VALUE (CLSYS-SVAL CONS-ITERATOR VALUE IT)))
      (CL:WHEN
       (CL:OR
        (CL:EQ (PROCEDURAL-EXPRESSION? VALUE) 1)
        (CL:EQ (CONS? (SECOND VALUE)) 1))
       (CL:SETQ VALUEVAR (LOCAL-GENSYM "VALUE"))
       (CL:SETQ
        BINDTREE
        (CONS
         (CONS
          VALUEVAR
          (CONS
           (CL:IF
            (CL:EQ (PROCEDURAL-EXPRESSION? VALUE) 1)
            VALUE
            (SECOND VALUE))
           NIL))
         BINDTREE))
       (CL:COND
        ((CL:EQ (PROCEDURAL-EXPRESSION? VALUE) 1)
         (VALUE-SETTER IT VALUEVAR)
         (CL:RETURN))
        (CL:T (SECOND-SETTER VALUE VALUEVAR)))))))
   (CL:RETURN-FROM
    WALK-VALUES-TREE
    (WALK-A-CONS-TREE (LIST* SYM-WALK-LET (REVERSE BINDTREE) (CONS TREE NIL)))))
  :VOID)

;;; (DEFUN (WALK-MV-EXPRESSION-TREE OBJECT CONS (LIST OF TYPE-SPEC)) ...)

(CL:DEFUN WALK-MV-EXPRESSION-TREE (TREE TARGETTYPES OPERATOR)
  (CL:LET*
   ((*TARGETTYPE*
     (CL:IF
      (CL:= (LENGTH TARGETTYPES) 1)
      (FIRST TARGETTYPES)
      SGT-WALK-UNKNOWN)))
   (CL:DECLARE (CL:SPECIAL *TARGETTYPE*))
   (CL:LET*
    ((OTREE NULL) (VALUESTREE NULL) (SOURCETYPES NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (OTREE VALUESTREE SOURCETYPES)
     (WALK-MV-TREE TREE))
    (CL:WHEN
     (CL:NOT (CL:= (LENGTH SOURCETYPES) (LENGTH TARGETTYPES)))
     (CL:IF
      (CL:AND
       (CL:= (LENGTH SOURCETYPES) 1)
       (CL:EQ SGT-WALK-UNKNOWN (FIRST SOURCETYPES)))
      (WARN-ABOUT-UNKNOWN-SOURCE-TYPE OTREE)
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN
        (CL:EQ (SUPPRESS-WARNINGS?) 0)
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING " `" %%STREAM)
         (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE OPERATOR) %%STREAM)
         (CL:WRITE-STRING "' operator expected `" %%STREAM)
         (CL:PRINC (LENGTH TARGETTYPES) %%STREAM)
         (CL:WRITE-STRING "' value(s) from `" %%STREAM)
         (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
         (CL:WRITE-STRING "'." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)))))
     (CL:RETURN-FROM
      WALK-MV-EXPRESSION-TREE
      (CL:VALUES OTREE VALUESTREE (COPY TARGETTYPES))))
    (CL:WHEN
     (CL:EQ (EMPTY? SOURCETYPES) 1)
     (CL:RETURN-FROM
      WALK-MV-EXPRESSION-TREE
      (CL:VALUES OTREE VALUESTREE SOURCETYPES)))
    (CL:IF
     (CL:NOT (CL:EQ VALUESTREE NULL))
     (CL:MULTIPLE-VALUE-SETQ
      (TREE VALUESTREE TARGETTYPES)
      (COERCE-MV-TREE VALUESTREE OPERATOR SOURCETYPES TARGETTYPES))
     (CL:MULTIPLE-VALUE-SETQ
      (OTREE VALUESTREE TARGETTYPES)
      (COERCE-MV-TREE OTREE OPERATOR SOURCETYPES TARGETTYPES)))
    (FREE SOURCETYPES)
    (CL:RETURN-FROM
     WALK-MV-EXPRESSION-TREE
     (CL:VALUES OTREE VALUESTREE TARGETTYPES))))
  :VOID)

;;; (DEFUN (LISTIFY-TYPE-SPEC (LIST OF TYPE-SPEC)) ...)

(CL:DEFUN LISTIFY-TYPE-SPEC (TYPESPEC)
  (CL:IF
   (CL:EQ (VOID? TYPESPEC) 1)
   (CL:RETURN-FROM LISTIFY-TYPE-SPEC (LIST))
   (CL:RETURN-FROM LISTIFY-TYPE-SPEC (LIST TYPESPEC)))
  :VOID)

;;; (DEFUN (SLOT-FROM-EXPRESSION-TREE SLOT) ...)

(CL:DEFUN SLOT-FROM-EXPRESSION-TREE (TREE)
  (CL:WHEN (CL:EQ SYM-WALK-TYPED-SYS (FIRST TREE)) (CL:SETQ TREE (SECOND TREE)))
  (CL:LET*
   ((TEST-VALUE-001 (FIRST TREE)))
   (CL:COND
    ((CL:OR
      (CL:EQ TEST-VALUE-001 SYM-WALK-SYS-SLOT-VALUE)
      (CL:EQ TEST-VALUE-001 SYM-WALK-SYS-CALL-METHOD)
      (CL:EQ TEST-VALUE-001 SYM-WALK-SYS-SLOT-VALUE-SETTER)
      (CL:EQ TEST-VALUE-001 SYM-WALK-SYS-CALL-METHOD-SETTER))
     (CL:RETURN-FROM
      SLOT-FROM-EXPRESSION-TREE
      (SAFE-LOOKUP-SLOT
       (CLSYS-SVAL SURROGATE SURROGATE-VALUE (SECOND TREE))
       (THIRD TREE))))
    ((CL:EQ TEST-VALUE-001 SYM-WALK-SYS-CALL-FUNCTION)
     (CL:LET*
      ((FUNCTION (LOOKUP-FUNCTION-OR-STELLA-FUNCTION (SECOND TREE))))
      (CL:WHEN
       (CL:AND
        (CL:NOT (CL:EQ FUNCTION NULL))
        (CL:EQ (ISA? FUNCTION SGT-WALK-METHOD-SLOT) 1))
       (CL:RETURN-FROM SLOT-FROM-EXPRESSION-TREE FUNCTION))))
    (CL:T (CL:RETURN-FROM SLOT-FROM-EXPRESSION-TREE NULL))))
  (CL:RETURN-FROM SLOT-FROM-EXPRESSION-TREE NULL)
  :VOID)

;;; (DEFUN (WALK-MV-TREE OBJECT CONS (LIST OF TYPE-SPEC)) ...)

(CL:DEFUN WALK-MV-TREE (TREE)
  (CL:LET*
   ((OTREE NULL) (OTYPE NULL) (SLOT NULL))
   (CL:WHEN
    (CL:EQ (VALUES-TREE? TREE) 1)
    (CL:RETURN-FROM WALK-MV-TREE (WALK-MV-VALUES-TREE TREE)))
   (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE) (WALK-A-TREE TREE))
   (CL:WHEN
    (CL:EQ (CONS? OTREE) 1)
    (CL:SETQ SLOT (SLOT-FROM-EXPRESSION-TREE OTREE)))
   (CL:WHEN
    (CL:NOT (CL:EQ SLOT NULL))
    (CL:LET*
     ((SLOT-001 SLOT))
     (CL:COND
      ((CL:EQ (METHOD-SLOT? SLOT) 1)
       (CL:LET*
        ((SLOT NULL))
        (CL:SETQ SLOT SLOT-001)
        (CL:RETURN-FROM
         WALK-MV-TREE
         (CL:VALUES OTREE NULL (COPY (METHOD-RETURN-TYPE-SPECIFIERS SLOT))))))
      (CL:T NULL))))
   (CL:RETURN-FROM
    WALK-MV-TREE
    (CL:VALUES OTREE NULL (LISTIFY-TYPE-SPEC OTYPE))))
  :VOID)

;;; (DEFUN (WALK-MV-VALUES-TREE CONS CONS (LIST OF TYPE-SPEC)) ...)

(CL:DEFUN WALK-MV-VALUES-TREE (TREE)
  (CL:WHEN
   (CL:= (LENGTH TREE) 1)
   (CL:RETURN-FROM
    WALK-MV-VALUES-TREE
    (CL:VALUES TREE TREE (LISTIFY-TYPE-SPEC SGT-WALK-VOID))))
  (CL:LET*
   ((OTREE NULL) (OTYPE NULL) (RETURNTYPES (NEW-LIST)) (TYPEDSYSTREE NULL))
   (CL:SETQ OTYPE OTYPE)
   (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE) (WALK-VALUES-TREE TREE))
   (FIRST-SETTER TREE SYM-WALK-VALUES)
   (CL:LET*
    ((IT (ALLOCATE-ITERATOR (CLSYS-SVAL CONS REST TREE))))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? IT) 1)
     DO
     (CL:SETQ TYPEDSYSTREE (CLSYS-SVAL CONS-ITERATOR VALUE IT))
     (PUSH RETURNTYPES (THIRD TYPEDSYSTREE))
     (CL:WHEN
      (CL:EQ SGT-WALK-UNKNOWN (THIRD TYPEDSYSTREE))
      (VALUE-SETTER IT (SECOND TYPEDSYSTREE))
      (FREE-CONS-LIST TYPEDSYSTREE))))
   (CL:RETURN-FROM
    WALK-MV-VALUES-TREE
    (CL:VALUES OTREE TREE (REVERSE RETURNTYPES))))
  :VOID)

;;; (DEFUN (COERCE-MV-TREE OBJECT CONS (LIST OF TYPE-SPEC)) ...)

(CL:DEFUN COERCE-MV-TREE (TREE OPERATOR SOURCETYPES TARGETTYPES)
  (CL:LET*
   ((VALUESTREE? (VALUES-TREE? TREE))
    (VALUESTREE NIL)
    (NEEDTEMPORARIES? FALSE)
    (SUCCESS? FALSE)
    (OTREE NULL)
    (OTYPE NULL)
    (RETURNTYPES (NEW-LIST)))
   (CL:COND
    ((CL:EQ VALUESTREE? 1) (CL:SETQ VALUESTREE TREE))
    (CL:T
     (CL:SETQ VALUESTREE (CONS SYM-WALK-VALUES NIL))
     (CL:LET*
      ((TYPE NULL)
       (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST SOURCETYPES))
       (COLLECT-001 NULL))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ TYPE (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (CL:IF
        (CL:EQ COLLECT-001 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-001 (CONS (SYS-TREE NULL TYPE) NIL))
         (CL:IF
          (CL:EQ VALUESTREE NIL)
          (CL:SETQ VALUESTREE COLLECT-001)
          (ADD-CONS-TO-END-OF-CONS-LIST VALUESTREE COLLECT-001)))
        (CL:PROGN
         (CL:SETF
          (CLSYS-SVAL CONS REST COLLECT-001)
          (CONS (SYS-TREE NULL TYPE) NIL))
         (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))))
   (CL:LET*
    ((I NULL)
     (SRCTS NULL)
     (TGTTS NULL)
     (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST TARGETTYPES))
     (ITER-003 (CLSYS-SVAL LIST THE-CONS-LIST SOURCETYPES))
     (ITER-004 1)
     (IT (ALLOCATE-ITERATOR (CLSYS-SVAL CONS REST VALUESTREE)))
     (COLLECT-002 NULL))
    (CL:LOOP
     WHILE
     (CL:AND
      (CL:NOT (CL:EQ ITER-002 NIL))
      (CL:NOT (CL:EQ ITER-003 NIL))
      (CL:EQ (NEXT? IT) 1))
     DO
     (CL:PROGN
      (CL:SETQ TGTTS (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:PROGN
      (CL:SETQ SRCTS (CLSYS-SVAL CONS VALUE ITER-003))
      (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
     (CL:PROGN (CL:SETQ I ITER-004) (CL:SETQ ITER-004 (CL:1+ ITER-004)))
     (CL:MULTIPLE-VALUE-SETQ
      (OTREE OTYPE SUCCESS?)
      (HELP-COERCE-A-TREE
       (CLSYS-SVAL CONS-ITERATOR VALUE IT)
       SRCTS
       TGTTS
       FALSE))
     (CL:WHEN
      (CL:EQ SUCCESS? 0)
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN
        (CL:EQ (SUPPRESS-WARNINGS?) 0)
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING " Type clash on argument `" %%STREAM)
         (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE (WRAP-LITERAL I)) %%STREAM)
         (CL:WRITE-STRING "' of `" %%STREAM)
         (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE OPERATOR) %%STREAM)
         (CL:WRITE-STRING "' operator." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING " `" %%STREAM)
         (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE SRCTS) %%STREAM)
         (CL:WRITE-STRING "' found where `" %%STREAM)
         (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TGTTS) %%STREAM)
         (CL:WRITE-STRING "' expected." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))))
      (CL:RETURN-FROM
       COERCE-MV-TREE
       (CL:VALUES
        TREE
        (CL:IF (CL:EQ VALUESTREE? 1) TREE NULL)
        (COPY TARGETTYPES))))
     (CL:WHEN
      (CL:OR
       (CL:EQ (EQL? OTREE (CLSYS-SVAL CONS-ITERATOR VALUE IT)) 0)
       (CL:AND
        (CL:> I 1)
        (CL:EQ VALUESTREE? 0)
        (CL:NOT (CL:EQ (TRANSLATOR-OUTPUT-LANGUAGE) KWD-WALK-COMMON-LISP))
        (CL:NOT (CL:EQ (TYPE-SPEC-TO-BASE-TYPE TGTTS) SGT-WALK-UNKNOWN))
        (CL:NOT
         (CL:EQ
          (TYPE-SPEC-TO-BASE-TYPE SRCTS)
          (TYPE-SPEC-TO-BASE-TYPE TGTTS)))))
      (CL:SETQ NEEDTEMPORARIES? TRUE))
     (VALUE-SETTER IT OTREE)
     (CL:IF
      (CL:EQ COLLECT-002 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-002 (PERMANENT-CONS OTYPE NIL))
       (CL:IF
        (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST RETURNTYPES) NIL)
        (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST RETURNTYPES) COLLECT-002)
        (ADD-CONS-TO-END-OF-CONS-LIST
         (CLSYS-SVAL LIST THE-CONS-LIST RETURNTYPES)
         COLLECT-002)))
      (CL:PROGN
       (CL:SETF (CLSYS-SVAL CONS REST COLLECT-002) (PERMANENT-CONS OTYPE NIL))
       (CL:SETQ COLLECT-002 (CLSYS-SVAL CONS REST COLLECT-002))))))
   (CL:WHEN
    (CL:EQ VALUESTREE? 1)
    (CL:RETURN-FROM COERCE-MV-TREE (CL:VALUES TREE TREE RETURNTYPES)))
   (FREE-PARSE-TREE VALUESTREE)
   (CL:WHEN
    (CL:EQ NEEDTEMPORARIES? 0)
    (CL:RETURN-FROM COERCE-MV-TREE (CL:VALUES TREE NULL RETURNTYPES)))
   (CL:SETQ VALUESTREE (CONS SYM-WALK-VALUES NIL))
   (CL:LET*
    ((I NULL)
     (ITER-005 1)
     (UPPER-BOUND-001 (LENGTH TARGETTYPES))
     (COLLECT-003 NULL))
    (CL:LOOP
     WHILE
     (CL:<= ITER-005 UPPER-BOUND-001)
     DO
     (CL:PROGN (CL:SETQ I ITER-005) (CL:SETQ ITER-005 (CL:1+ ITER-005)))
     (CL:IF
      (CL:EQ COLLECT-003 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-003 (CONS (LOCAL-GENSYM "VALUE") NIL))
       (CL:IF
        (CL:EQ VALUESTREE NIL)
        (CL:SETQ VALUESTREE COLLECT-003)
        (ADD-CONS-TO-END-OF-CONS-LIST VALUESTREE COLLECT-003)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-003)
        (CONS (LOCAL-GENSYM "VALUE") NIL))
       (CL:SETQ COLLECT-003 (CLSYS-SVAL CONS REST COLLECT-003))))))
   (CL:SETQ
    OTREE
    (WALK-WITHOUT-TYPE-TREE
     (LIST*
      SYM-WALK-MV-BIND
      (COPY-CONS-LIST (CLSYS-SVAL CONS REST VALUESTREE))
      (CONS TREE (CONS VALUESTREE NIL)))))
   (FIRST-SETTER
    VALUESTREE
    (GET-QUOTED-TREE "((VALUES) \"/STELLA\")" "/STELLA"))
   (CL:LET*
    ((TGTTS NULL)
     (SRCTS NULL)
     (IT (ALLOCATE-ITERATOR (CLSYS-SVAL CONS REST VALUESTREE)))
     (ITER-006 (CLSYS-SVAL LIST THE-CONS-LIST SOURCETYPES))
     (ITER-007 (CLSYS-SVAL LIST THE-CONS-LIST TARGETTYPES)))
    (CL:LOOP
     WHILE
     (CL:AND
      (CL:EQ (NEXT? IT) 1)
      (CL:NOT (CL:EQ ITER-006 NIL))
      (CL:NOT (CL:EQ ITER-007 NIL)))
     DO
     (CL:PROGN
      (CL:SETQ SRCTS (CLSYS-SVAL CONS VALUE ITER-006))
      (CL:SETQ ITER-006 (CLSYS-SVAL CONS REST ITER-006)))
     (CL:PROGN
      (CL:SETQ TGTTS (CLSYS-SVAL CONS VALUE ITER-007))
      (CL:SETQ ITER-007 (CLSYS-SVAL CONS REST ITER-007)))
     (VALUE-SETTER
      IT
      (COERCE-A-TREE (CLSYS-SVAL CONS-ITERATOR VALUE IT) SRCTS TGTTS))))
   (CL:RETURN-FROM COERCE-MV-TREE (CL:VALUES OTREE VALUESTREE RETURNTYPES)))
  :VOID)

;;; (DEFUN (WALK-RETURN-AND-UNBIND-SPECIALS CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-RETURN-AND-UNBIND-SPECIALS (TREE)
  (CL:LET*
   ((UNBINDTREE (YIELD-RETURN-SPECIAL-UNBIND-TREE))
    (VALUETREES (CLSYS-SVAL CONS REST TREE))
    (VALUEVARIABLES NIL)
    (VALUEBINDINGS NIL))
   (CL:LET*
    ((*SPECIALSENABLED?* FALSE))
    (CL:DECLARE (CL:SPECIAL *SPECIALSENABLED?*))
    (CL:WHEN
     (CL:= (LENGTH VALUETREES) 0)
     (CL:RETURN-FROM
      WALK-RETURN-AND-UNBIND-SPECIALS
      (WALK-A-CONS-TREE (LIST* SYM-WALK-PROGN UNBINDTREE (CONS TREE NIL)))))
    (CL:WHEN
     (CL:AND
      (CL:= (LENGTH VALUETREES) 1)
      (CL:NOT
       (CL:EQ
        (REST (METHOD-RETURN-TYPE-SPECIFIERS *METHODBEINGWALKED*))
        NIL)))
     (CL:LET*
      ((I NULL)
       (ITER-001 0)
       (UPPER-BOUND-001
        (CL:1- (LENGTH (METHOD-RETURN-TYPE-SPECIFIERS *METHODBEINGWALKED*))))
       (COLLECT-001 NULL))
      (CL:LOOP
       WHILE
       (CL:<= ITER-001 UPPER-BOUND-001)
       DO
       (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
       (CL:SETQ I I)
       (CL:IF
        (CL:EQ COLLECT-001 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-001 (CONS (LOCAL-GENSYM "RETURN-VALUE") NIL))
         (CL:IF
          (CL:EQ VALUEVARIABLES NIL)
          (CL:SETQ VALUEVARIABLES COLLECT-001)
          (ADD-CONS-TO-END-OF-CONS-LIST VALUEVARIABLES COLLECT-001)))
        (CL:PROGN
         (CL:SETF
          (CLSYS-SVAL CONS REST COLLECT-001)
          (CONS (LOCAL-GENSYM "RETURN-VALUE") NIL))
         (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
     (CL:SETF (CLSYS-SVAL CONS REST TREE) VALUEVARIABLES)
     (CL:RETURN-FROM
      WALK-RETURN-AND-UNBIND-SPECIALS
      (WALK-A-CONS-TREE
       (LIST*
        SYM-WALK-MV-BIND
        (COPY-CONS-LIST VALUEVARIABLES)
        (CONS
         (FIRST VALUETREES)
         (CONCATENATE (TREE-TO-TREES UNBINDTREE) (CONS TREE NIL)))))))
    (CL:LET*
     ((IT (ALLOCATE-ITERATOR VALUETREES)))
     (CL:LOOP
      WHILE
      (CL:EQ (NEXT? IT) 1)
      DO
      (CL:WHEN
       (CL:OR
        (CL:EQ (CONS? (CLSYS-SVAL CONS-ITERATOR VALUE IT)) 1)
        (CL:AND
         (CL:EQ (SYMBOL? (CLSYS-SVAL CONS-ITERATOR VALUE IT)) 1)
         (CL:NOT
          (CL:EQ
           (LOOKUP-OLD-VALUE-VARIABLE (CLSYS-SVAL CONS-ITERATOR VALUE IT))
           NULL))))
       (CL:SETQ
        VALUEBINDINGS
        (CONS
         (CONS
          (LOCAL-GENSYM "RETURN-VALUE")
          (CONS (CLSYS-SVAL CONS-ITERATOR VALUE IT) NIL))
         VALUEBINDINGS))
       (VALUE-SETTER IT (FIRST (FIRST VALUEBINDINGS))))))
    (CL:RETURN-FROM
     WALK-RETURN-AND-UNBIND-SPECIALS
     (WALK-A-CONS-TREE
      (LIST*
       SYM-WALK-LET
       (REVERSE VALUEBINDINGS)
       (CONCATENATE (TREE-TO-TREES UNBINDTREE) (CONS TREE NIL)))))))
  :VOID)

;;; (DEFUN (WALK-RETURN-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-RETURN-TREE (TREE)
  (CL:WHEN
   (CL:EQ *METHODBEINGWALKED* NULL)
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING
       " Return statement encountered outside of method or function definition."
       %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))))
   (CL:RETURN-FROM
    WALK-RETURN-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
  (CL:SETQ *FOUNDRETURN?* TRUE)
  (CL:WHEN
   (CL:EQ (NEED-TO-UNBIND-SPECIALS?) 1)
   (CL:RETURN-FROM WALK-RETURN-TREE (WALK-RETURN-AND-UNBIND-SPECIALS TREE)))
  (CL:LET*
   ((METHOD *METHODBEINGWALKED*) (TARGETTYPES (NEW-LIST)))
   (CL:LET*
    ((RTYPE NULL)
     (ITER-001
      (CLSYS-SVAL LIST THE-CONS-LIST (METHOD-RETURN-TYPE-SPECIFIERS METHOD)))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ RTYPE (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ
        COLLECT-001
        (PERMANENT-CONS
         (COMPUTE-RELATIVE-TYPE-SPEC
          RTYPE
          (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD))
         NIL))
       (CL:IF
        (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST TARGETTYPES) NIL)
        (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST TARGETTYPES) COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST
         (CLSYS-SVAL LIST THE-CONS-LIST TARGETTYPES)
         COLLECT-001)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-001)
        (PERMANENT-CONS
         (COMPUTE-RELATIVE-TYPE-SPEC
          RTYPE
          (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD))
         NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:LET*
    ((OTREE NULL) (VALUESTREE NULL) (VALUETYPES NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (OTREE VALUESTREE VALUETYPES)
     (WALK-MV-EXPRESSION-TREE
      (CL:IF
       (CL:AND
        (CL:= (LENGTH (CLSYS-SVAL CONS REST TREE)) 1)
        (CL:NOT (CL:EQ (REST TARGETTYPES) NIL)))
       (SECOND TREE)
       (CONS SYM-WALK-VALUES (CONCATENATE (CLSYS-SVAL CONS REST TREE) NIL)))
      TARGETTYPES
      SYM-WALK-RETURN))
    (FREE TARGETTYPES)
    (FREE VALUETYPES)
    (CL:WHEN
     (CL:EQ VALUESTREE NULL)
     (CL:WHEN
      (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST TREE) NIL))
      (SECOND-SETTER TREE OTREE))
     (CL:RETURN-FROM WALK-RETURN-TREE (CL:VALUES TREE SGT-WALK-VOID)))
    (FIRST-SETTER VALUESTREE SYM-WALK-RETURN)
    (FREE-CONS TREE)
    (CL:RETURN-FROM WALK-RETURN-TREE (CL:VALUES OTREE SGT-WALK-VOID))))
  :VOID)

;;; (DEFUN (WALK-MV-SETQ-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-MV-SETQ-TREE (TREE)
  (CL:LET*
   ((TEST-VALUE-001 FALSE))
   (CL:IF
    (CL:EQ (BAD-ARGUMENT-COUNT? TREE 2) 1)
    (CL:SETQ TEST-VALUE-001 TRUE)
    (CL:IF
     (CL:EQ (CONS? (SECOND TREE)) 0)
     (CL:SETQ TEST-VALUE-001 TRUE)
     (CL:PROGN
      (CL:LET*
       ((ALWAYS?-001 TRUE))
       (CL:LET*
        ((V NULL) (ITER-001 (SECOND TREE)))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-001 NIL))
         DO
         (CL:PROGN
          (CL:SETQ V (CLSYS-SVAL CONS VALUE ITER-001))
          (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
         (CL:WHEN
          (CL:EQ (SYMBOL? V) 0)
          (CL:SETQ ALWAYS?-001 FALSE)
          (CL:RETURN))))
       (CL:SETQ TEST-VALUE-001 ALWAYS?-001))
      (CL:SETQ TEST-VALUE-001 (CL:IF (CL:EQ TEST-VALUE-001 0) TRUE FALSE)))))
   (CL:WHEN
    (CL:EQ TEST-VALUE-001 1)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Illegal 'mv-setq' expression: `" %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (CL:RETURN-FROM
     WALK-MV-SETQ-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID))))
  (CL:LET*
   ((VARIABLES (SECOND TREE)) (TARGETTYPES (NEW-LIST)))
   (CL:LET*
    ((V NULL) (ITER-002 VARIABLES) (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ V (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (PERMANENT-CONS (LOOKUP-VARIABLE-TYPE V) NIL))
       (CL:IF
        (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST TARGETTYPES) NIL)
        (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST TARGETTYPES) COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST
         (CLSYS-SVAL LIST THE-CONS-LIST TARGETTYPES)
         COLLECT-001)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-001)
        (PERMANENT-CONS (LOOKUP-VARIABLE-TYPE V) NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:LET*
    ((OTREE NULL) (VALUESTREE NULL) (VALUETYPES NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (OTREE VALUESTREE VALUETYPES)
     (WALK-MV-EXPRESSION-TREE (THIRD TREE) TARGETTYPES SYM-WALK-MV-SETQ))
    (FREE VALUETYPES)
    (FREE TARGETTYPES)
    (CL:WHEN
     (CL:NOT (CL:EQ VALUESTREE NULL))
     (FIRST-SETTER VALUESTREE SYM-WALK-PROGN)
     (CL:LET*
      ((VAR NULL)
       (IT (ALLOCATE-ITERATOR (CLSYS-SVAL CONS REST VALUESTREE)))
       (ITER-003 VARIABLES))
      (CL:LOOP
       WHILE
       (CL:AND (CL:EQ (NEXT? IT) 1) (CL:NOT (CL:EQ ITER-003 NIL)))
       DO
       (CL:PROGN
        (CL:SETQ VAR (CLSYS-SVAL CONS VALUE ITER-003))
        (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
       (VALUE-SETTER
        IT
        (LIST*
         SYM-WALK-SETQ
         VAR
         (CONS (CLSYS-SVAL CONS-ITERATOR VALUE IT) NIL)))))
     (CL:SETF (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)) NIL)
     (FREE-PARSE-TREE TREE)
     (CL:RETURN-FROM WALK-MV-SETQ-TREE (CL:VALUES OTREE SGT-WALK-VOID)))
    (THIRD-SETTER TREE OTREE)
    (CL:RETURN-FROM WALK-MV-SETQ-TREE (CL:VALUES TREE SGT-WALK-VOID))))
  :VOID)

;;; (DEFUN (WALK-MV-BIND-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-MV-BIND-TREE (TREE)
  (CL:WHEN
   (CL:OR (CL:< (LENGTH TREE) 3) (CL:EQ (CONS? (SECOND TREE)) 0))
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING " Illegal 'mv-bind' expression: `" %%STREAM)
      (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
      (CL:WRITE-STRING "'." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))))
   (CL:RETURN-FROM
    WALK-MV-BIND-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
  (CL:LET*
   ((DECLARATIONS (SECOND TREE))
    (MVTREE (THIRD TREE))
    (BODY
     (CLSYS-SVAL
      CONS
      REST
      (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))
    (VARIABLES NIL)
    (DECL NULL)
    (TARGETTYPES (NEW-LIST)))
   (CL:LET*
    ((IT (ALLOCATE-ITERATOR DECLARATIONS)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? IT) 1)
     DO
     (CL:SETQ DECL (CLSYS-SVAL CONS-ITERATOR VALUE IT))
     (CL:LET*
      ((DECL-001 DECL))
      (CL:COND
       ((CL:EQ (CONS? DECL) 1)
        (CL:LET*
         ((DECL NULL))
         (CL:SETQ DECL DECL-001)
         (CL:WHEN
          (CL:NOT
           (CL:AND (CL:EQ (SYMBOL? (FIRST DECL)) 1) (CL:= (LENGTH DECL) 2)))
          (CL:LET*
           ((*PRINTREADABLY?* TRUE))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN
            (CL:EQ (SUPPRESS-WARNINGS?) 0)
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
            (CL:LET
             ((%%STREAM
               (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM)
             (CL:WRITE-STRING " Illegal variable declaration `" %%STREAM)
             (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE DECL) %%STREAM)
             (CL:WRITE-STRING "' in 'mv-bind' expression: `" %%STREAM)
             (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
             (CL:WRITE-STRING "'." %%STREAM)
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM))))
          (CL:RETURN-FROM
           WALK-MV-BIND-TREE
           (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
         (PUSH TARGETTYPES (YIELD-TYPE-SPECIFIER (SECOND DECL)))
         (CL:SETF
          (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST DECL))
          (CONS SYM-WALK-NULL NIL))
         (CL:SETQ VARIABLES (CONS (FIRST DECL) VARIABLES))))
       ((CL:EQ (SYMBOL? DECL) 1)
        (CL:LET*
         ((DECL NULL))
         (CL:SETQ DECL DECL-001)
         (PUSH TARGETTYPES SGT-WALK-UNKNOWN)
         (VALUE-SETTER
          IT
          (CONS DECL (LIST* SGT-WALK-UNKNOWN SYM-WALK-NULL NIL)))
         (CL:SETQ VARIABLES (CONS DECL VARIABLES))))
       (CL:T
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN
          (CL:EQ (SUPPRESS-WARNINGS?) 0)
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING " Illegal variable `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE DECL) %%STREAM)
           (CL:WRITE-STRING "' in 'mv-bind' expression: `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
           (CL:WRITE-STRING "'." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))))
        (CL:RETURN-FROM
         WALK-MV-BIND-TREE
         (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))))))
   (CL:SETQ VARIABLES (REVERSE VARIABLES))
   (CL:LET*
    ((VARIABLE NULL) (ITER-001 VARIABLES))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ VARIABLE (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (PUSH-VARIABLE-BINDING VARIABLE SGT-WALK-UNINITIALIZED)))
   (CL:LET*
    ((OMVTREE NULL) (VALUESTREE NULL) (VARIABLETYPES NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (OMVTREE VALUESTREE VARIABLETYPES)
     (WALK-MV-EXPRESSION-TREE MVTREE (REVERSE TARGETTYPES) SYM-WALK-MV-BIND))
    (CL:LET*
     ((VARIABLE NULL) (ITER-002 VARIABLES))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-002 NIL))
      DO
      (CL:PROGN
       (CL:SETQ VARIABLE (CLSYS-SVAL CONS VALUE ITER-002))
       (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
      (POP-VARIABLE-BINDING)))
    (FREE TARGETTYPES)
    (CL:SETF
     (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
     NIL)
    (FREE-CONS-LIST TREE)
    (CL:LET*
     ((TYPE NULL)
      (DECL NULL)
      (ITER-003 DECLARATIONS)
      (ITER-004 (CLSYS-SVAL LIST THE-CONS-LIST VARIABLETYPES)))
     (CL:LOOP
      WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-003 NIL)) (CL:NOT (CL:EQ ITER-004 NIL)))
      DO
      (CL:PROGN
       (CL:SETQ DECL (CLSYS-SVAL CONS VALUE ITER-003))
       (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
      (CL:PROGN
       (CL:SETQ TYPE (CLSYS-SVAL CONS VALUE ITER-004))
       (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
      (CL:WHEN
       (CL:EQ SGT-WALK-UNKNOWN (SECOND DECL))
       (SECOND-SETTER DECL TYPE))))
    (FREE VARIABLETYPES)
    (CL:COND
     ((CL:NOT (CL:EQ VALUESTREE NULL))
      (FIRST-SETTER VALUESTREE SYM-WALK-PROGN)
      (CL:LET*
       ((VAR NULL)
        (IT (ALLOCATE-ITERATOR (CLSYS-SVAL CONS REST VALUESTREE)))
        (ITER-005 VARIABLES))
       (CL:LOOP
        WHILE
        (CL:AND (CL:EQ (NEXT? IT) 1) (CL:NOT (CL:EQ ITER-005 NIL)))
        DO
        (CL:PROGN
         (CL:SETQ VAR (CLSYS-SVAL CONS VALUE ITER-005))
         (CL:SETQ ITER-005 (CLSYS-SVAL CONS REST ITER-005)))
        (VALUE-SETTER
         IT
         (LIST*
          SYM-WALK-SETQ
          VAR
          (CONS (CLSYS-SVAL CONS-ITERATOR VALUE IT) NIL)))))
      (CL:SETQ VALUESTREE OMVTREE))
     (CL:T
      (CL:SETQ
       VALUESTREE
       (LIST* SYM-WALK-MV-SETQ VARIABLES (CONS OMVTREE NIL)))))
    (CL:RETURN-FROM
     WALK-MV-BIND-TREE
     (WALK-A-CONS-TREE
      (LIST*
       SYM-WALK-LET
       DECLARATIONS
       (CONS VALUESTREE (CONCATENATE BODY NIL)))))))
  :VOID)

;;; (DEFUN (WALK-LOOP-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-LOOP-TREE (TREE)
  (CL:LET*
   ((*NOFSPECIALSATLOOPENTRY* (LENGTH *SPECIALVARIABLESTACK*)))
   (CL:DECLARE (CL:SPECIAL *NOFSPECIALSATLOOPENTRY*))
   (CL:SETF
    (CLSYS-SVAL CONS REST TREE)
    (WALK-LIST-OF-TREES (CLSYS-SVAL CONS REST TREE)))
   (CL:RETURN-FROM WALK-LOOP-TREE (SYS-TREE TREE SGT-WALK-VOID)))
  :VOID)

;;; (DEFUN (WALK-LOOP-EXIT-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-LOOP-EXIT-TREE (TREE)
  (BAD-ARGUMENT-COUNT? TREE 0)
  (CL:IF
   (CL:EQ (NEED-TO-UNBIND-SPECIALS?) 1)
   (CL:LET*
    ((UNBINDTREE (YIELD-LOOP-EXIT-SPECIAL-UNBIND-TREE)))
    (CL:LET*
     ((*SPECIALSENABLED?* FALSE))
     (CL:DECLARE (CL:SPECIAL *SPECIALSENABLED?*))
     (CL:RETURN-FROM
      WALK-LOOP-EXIT-TREE
      (WALK-A-CONS-TREE (LIST* SYM-WALK-PROGN UNBINDTREE (CONS TREE NIL))))))
   (CL:RETURN-FROM WALK-LOOP-EXIT-TREE (CL:VALUES TREE SGT-WALK-VOID)))
  :VOID)

;;; (DEFUN (WALK-WHILE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-WHILE-TREE (TREE)
  (CL:LET*
   ((*NOFSPECIALSATLOOPENTRY* (LENGTH *SPECIALVARIABLESTACK*)))
   (CL:DECLARE (CL:SPECIAL *NOFSPECIALSATLOOPENTRY*))
   (CL:LET*
    ((TEST
      (WALK-EXPRESSION-TREE
       (SECOND TREE)
       SGT-WALK-BOOLEAN
       SYM-WALK-WHILE
       TRUE))
     (BODY (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))
    (SECOND-SETTER TREE TEST)
    (CL:WHEN
     (CL:EQ (PROCEDURAL-EXPRESSION? TEST) 1)
     (CL:SETF (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)) NIL)
     (FREE-CONS-LIST TREE)
     (CL:RETURN-FROM
      WALK-WHILE-TREE
      (WALK-A-CONS-TREE
       (LIST*
        SYM-WALK-LOOP
        (LIST* SYM-WALK-UNLESS TEST (CONS (CONS SYM-WALK-BREAK NIL) NIL))
        (CONCATENATE BODY NIL)))))
    (CL:SETF
     (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))
     (WALK-LIST-OF-TREES (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))
    (CL:RETURN-FROM WALK-WHILE-TREE (CL:VALUES TREE SGT-WALK-VOID))))
  :VOID)

;;; (DEFUN (WALK-CONDITIONAL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-CONDITIONAL-TREE (TREE)
  (CL:LET*
   ((OPERATOR (FIRST TREE))
    (TEST
     (WALK-EXPRESSION-TREE (SECOND TREE) SGT-WALK-BOOLEAN OPERATOR TRUE)))
   (SECOND-SETTER TREE TEST)
   (CL:WHEN
    (CL:EQ (PROCEDURAL-EXPRESSION? TEST) 1)
    (CL:RETURN-FROM
     WALK-CONDITIONAL-TREE
     (CL:VALUES
      (TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION TREE TEST)
      SGT-WALK-VOID)))
   (CL:COND
    ((CL:EQ OPERATOR SYM-WALK-IF)
     (CL:WHEN
      (CL:EQ (BAD-ARGUMENT-COUNT? TREE 3) 1)
      (CL:RETURN-FROM
       WALK-CONDITIONAL-TREE
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
     (THIRD-SETTER TREE (WALK-STATEMENT (THIRD TREE) TRUE))
     (FOURTH-SETTER TREE (WALK-STATEMENT (FOURTH TREE) TRUE)))
    ((CL:OR (CL:EQ OPERATOR SYM-WALK-WHEN) (CL:EQ OPERATOR SYM-WALK-UNLESS))
     (CL:SETF
      (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))
      (WALK-LIST-OF-TREES
       (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" OPERATOR)))
   (CL:RETURN-FROM WALK-CONDITIONAL-TREE (CL:VALUES TREE SGT-WALK-VOID)))
  :VOID)

;;; (DEFUN (WALK-CHOOSE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-CHOOSE-TREE (TREE)
  (CL:LET*
   ((OPERATOR (FIRST TREE))
    (TEST (WALK-EXPRESSION-TREE (SECOND TREE) SGT-WALK-BOOLEAN OPERATOR TRUE))
    (TEMP NULL)
    (TYPE1 NULL)
    (TYPE2 NULL)
    (TYPE NULL))
   (SECOND-SETTER TREE TEST)
   (CL:WHEN
    (CL:EQ (VRLET-EXPRESSION? TEST) 1)
    (CL:RETURN-FROM
     WALK-CHOOSE-TREE
     (PERCOLATE-OUT-VRLET-EXPRESSION TREE TEST SGT-WALK-BOOLEAN)))
   (CL:WHEN
    (CL:EQ (BAD-ARGUMENT-COUNT? TREE 3) 1)
    (CL:RETURN-FROM
     WALK-CHOOSE-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-UNKNOWN)))
   (CL:MULTIPLE-VALUE-SETQ (TEMP TYPE1) (WALK-A-TREE (THIRD TREE)))
   (THIRD-SETTER TREE TEMP)
   (CL:MULTIPLE-VALUE-SETQ (TEMP TYPE2) (WALK-A-TREE (FOURTH TREE)))
   (FOURTH-SETTER TREE TEMP)
   (CL:COND
    ((CL:EQ TYPE1 SGT-WALK-UNKNOWN) (CL:SETQ TYPE TYPE2))
    ((CL:EQ TYPE2 SGT-WALK-UNKNOWN) (CL:SETQ TYPE TYPE1))
    (CL:T
     (CL:SETQ
      TYPE
      (TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE
       (TYPE-SPEC-TO-BASE-TYPE TYPE1)
       (TYPE-SPEC-TO-BASE-TYPE TYPE2)))))
   (CL:COND
    ((CL:EQ TYPE SGT-WALK-VOID)
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " Incompatible return types `" %%STREAM)
        (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TYPE1) %%STREAM)
        (CL:WRITE-STRING "' and `" %%STREAM)
        (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TYPE2) %%STREAM)
        (CL:WRITE-STRING "'" %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING "in 'choose' expression.." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)))))
    (CL:T
     (THIRD-SETTER TREE (COERCE-A-TREE (THIRD TREE) TYPE1 TYPE))
     (FOURTH-SETTER TREE (COERCE-A-TREE (FOURTH TREE) TYPE2 TYPE))))
   (CL:WHEN
    (CL:OR
     (CL:EQ (VRLET-EXPRESSION? (THIRD TREE)) 1)
     (CL:EQ (VRLET-EXPRESSION? (FOURTH TREE)) 1))
    (CL:LET*
     ((RESULTVARIABLE (LOCAL-GENSYM "CHOOSE-VALUE")))
     (CL:LET*
      ((VALUE-001 NULL) (VALUE-002 NULL))
      (CL:MULTIPLE-VALUE-SETQ
       (VALUE-001 VALUE-002)
       (WALK-A-TREE
        (LIST*
         SYM-WALK-VRLET
         (CONS (CONS RESULTVARIABLE (CONS TYPE (CONS SYM-WALK-NULL NIL))) NIL)
         (LIST*
          SYM-WALK-IF
          (SECOND TREE)
          (LIST*
           (LIST* SYM-WALK-SETQ RESULTVARIABLE (CONS (THIRD TREE) NIL))
           (LIST* SYM-WALK-SETQ RESULTVARIABLE (CONS (FOURTH TREE) NIL))
           NIL))
         RESULTVARIABLE
         NIL)))
      (CL:RETURN-FROM WALK-CHOOSE-TREE (CL:VALUES VALUE-001 VALUE-002)))))
   (THIRD-SETTER TREE (SYS-TREE (THIRD TREE) TYPE))
   (FOURTH-SETTER TREE (SYS-TREE (FOURTH TREE) TYPE))
   (CL:RETURN-FROM WALK-CHOOSE-TREE (CL:VALUES TREE TYPE)))
  :VOID)

;;; (DEFUN (WALK-BOOLEAN-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-BOOLEAN-TREE (TREE)
  (CL:LET*
   ((OTREE (HELP-WALK-BOOLEAN-TREE TREE)))
   (CL:WHEN
    (CL:EQ (PROCEDURAL-EXPRESSION? OTREE) 1)
    (CL:SETQ OTREE (PERCOLATE-OUT-BOOLEAN-VRLET-EXPRESSIONS OTREE)))
   (CL:RETURN-FROM WALK-BOOLEAN-TREE (CL:VALUES OTREE SGT-WALK-BOOLEAN)))
  :VOID)

;;; (DEFUN (AND-OR-NOT-TREE? BOOLEAN) ...)

(CL:DEFUN AND-OR-NOT-TREE? (TREE)
  (CL:IF
   (CL:EQ (CONS? TREE) 1)
   (CL:LET*
    ((TEST-VALUE-001 (CLSYS-SVAL CONS VALUE TREE)))
    (CL:COND
     ((CL:OR
       (CL:EQ TEST-VALUE-001 SYM-WALK-AND)
       (CL:EQ TEST-VALUE-001 SYM-WALK-OR)
       (CL:EQ TEST-VALUE-001 SYM-WALK-NOT))
      (CL:RETURN-FROM AND-OR-NOT-TREE? TRUE))
     (CL:T (CL:RETURN-FROM AND-OR-NOT-TREE? FALSE))))
   (CL:RETURN-FROM AND-OR-NOT-TREE? FALSE))
  :VOID)

;;; (DEFUN (HELP-WALK-BOOLEAN-TREE OBJECT) ...)

(CL:DEFUN HELP-WALK-BOOLEAN-TREE (TREE)
  (CL:LET*
   ((CURSOR (CLSYS-SVAL CONS REST TREE)) (TEMP NULL))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:SETF
     (CLSYS-SVAL CONS VALUE CURSOR)
     (CL:IF
      (CL:EQ (AND-OR-NOT-TREE? (CLSYS-SVAL CONS VALUE CURSOR)) 1)
      (HELP-WALK-BOOLEAN-TREE (CLSYS-SVAL CONS VALUE CURSOR))
      (WALK-EXPRESSION-TREE
       (CLSYS-SVAL CONS VALUE CURSOR)
       SGT-WALK-BOOLEAN
       (FIRST TREE)
       TRUE)))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (CL:LET*
    ((TEST-VALUE-001 (FIRST TREE)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 SYM-WALK-AND)
      (CL:WHEN
       (CL:EQ (CLSYS-SVAL CONS REST TREE) NIL)
       (FREE-CONS-LIST TREE)
       (CL:RETURN-FROM HELP-WALK-BOOLEAN-TREE TRUE-WRAPPER))
      (CL:WHEN
       (CL:EQ (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)) NIL)
       (CL:SETQ TEMP (SECOND TREE))
       (FREE-CONS-LIST TREE)
       (CL:RETURN-FROM HELP-WALK-BOOLEAN-TREE TEMP)))
     ((CL:EQ TEST-VALUE-001 SYM-WALK-OR)
      (CL:WHEN
       (CL:EQ (CLSYS-SVAL CONS REST TREE) NIL)
       (FREE-CONS-LIST TREE)
       (CL:RETURN-FROM HELP-WALK-BOOLEAN-TREE FALSE-WRAPPER))
      (CL:WHEN
       (CL:EQ (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)) NIL)
       (CL:SETQ TEMP (SECOND TREE))
       (FREE-CONS-LIST TREE)
       (CL:RETURN-FROM HELP-WALK-BOOLEAN-TREE TEMP)))
     ((CL:EQ TEST-VALUE-001 SYM-WALK-NOT)
      (CL:WHEN
       (CL:EQ (BAD-ARGUMENT-COUNT? TREE 1) 1)
       (CL:RETURN-FROM
        HELP-WALK-BOOLEAN-TREE
        (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-BOOLEAN))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
   (CL:RETURN-FROM HELP-WALK-BOOLEAN-TREE TREE))
  :VOID)

;;; (DEFUN (WALK-COND-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-COND-TREE (TREE)
  (CL:LET*
   ((CONDITION NULL) (ITER-001 (CLSYS-SVAL CONS REST TREE)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ CONDITION (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:LET*
     ((CONDITION-001 CONDITION))
     (CL:COND
      ((CL:EQ (CONS? CONDITION) 1)
       (CL:LET*
        ((CONDITION NULL))
        (CL:SETQ CONDITION CONDITION-001)
        (CL:WHEN
         (CL:NOT (CL:EQ (CLSYS-SVAL CONS VALUE CONDITION) SYM-WALK-OTHERWISE))
         (CL:SETF
          (CLSYS-SVAL CONS VALUE CONDITION)
          (WALK-EXPRESSION-TREE
           (CLSYS-SVAL CONS VALUE CONDITION)
           SGT-WALK-BOOLEAN
           SYM-WALK-COND
           TRUE))
         (CL:WHEN
          (CL:EQ (PROCEDURAL-EXPRESSION? (CLSYS-SVAL CONS VALUE CONDITION)) 1)
          (CL:RETURN-FROM
           WALK-COND-TREE
           (WALK-A-CONS-TREE (COND-TREE-TO-IF-TREE TREE)))))
        (CL:SETF
         (CLSYS-SVAL CONS REST CONDITION)
         (WALK-LIST-OF-TREES (CLSYS-SVAL CONS REST CONDITION)))))
      (CL:T
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN
         (CL:EQ (SUPPRESS-WARNINGS?) 0)
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:WRITE-STRING " Illegal condition in COND statement: `" %%STREAM)
          (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE CONDITION) %%STREAM)
          (CL:WRITE-STRING "'." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))))
       (CL:RETURN-FROM
        WALK-COND-TREE
        (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))))))
  (CL:RETURN-FROM WALK-COND-TREE (CL:VALUES TREE SGT-WALK-VOID))
  :VOID)

;;; (DEFUN (COND-TREE-TO-IF-TREE CONS) ...)

(CL:DEFUN COND-TREE-TO-IF-TREE (TREE)
  (CL:LET*
   ((FIRSTCONDITION (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST TREE)))
    (OTHERCONDITIONS (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
    (FIRSTTEST NULL))
   (CL:LET*
    ((FIRSTCONDITION-001 FIRSTCONDITION))
    (CL:COND
     ((CL:EQ (CONS? FIRSTCONDITION) 1)
      (CL:LET*
       ((FIRSTCONDITION NULL))
       (CL:SETQ FIRSTCONDITION FIRSTCONDITION-001)
       (CL:SETQ FIRSTTEST (CLSYS-SVAL CONS VALUE FIRSTCONDITION))
       (CL:COND
        ((CL:EQ FIRSTTEST SYM-WALK-OTHERWISE)
         (CL:COND
          ((CL:EQ OTHERCONDITIONS NIL)
           (FIRST-SETTER TREE SYM-WALK-PROGN)
           (CL:SETF
            (CLSYS-SVAL CONS REST TREE)
            (CLSYS-SVAL CONS REST FIRSTCONDITION))
           (CL:RETURN-FROM COND-TREE-TO-IF-TREE TREE))
          (CL:T
           (CL:SETF (CLSYS-SVAL CONS VALUE FIRSTCONDITION) SYM-WALK-TRUE)
           (CL:RETURN-FROM
            COND-TREE-TO-IF-TREE
            (COND-TREE-TO-IF-TREE TREE)))))
        ((CL:EQ OTHERCONDITIONS NIL)
         (FIRST-SETTER TREE SYM-WALK-WHEN)
         (CL:SETF (CLSYS-SVAL CONS REST TREE) FIRSTCONDITION)
         (CL:RETURN-FROM COND-TREE-TO-IF-TREE TREE))
        (CL:T
         (CL:SETF (CLSYS-SVAL CONS VALUE FIRSTCONDITION) SYM-WALK-PROGN)
         (SECOND-SETTER TREE SYM-WALK-COND)
         (CL:RETURN-FROM
          COND-TREE-TO-IF-TREE
          (LIST*
           SYM-WALK-IF
           FIRSTTEST
           (CONS
            FIRSTCONDITION
            (CONS
             (COND-TREE-TO-IF-TREE (CLSYS-SVAL CONS REST TREE))
             NIL))))))))
     (CL:T
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN
        (CL:EQ (SUPPRESS-WARNINGS?) 0)
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING " Illegal condition in COND statement: `" %%STREAM)
         (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE FIRSTCONDITION) %%STREAM)
         (CL:WRITE-STRING "'." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))))
      (CL:RETURN-FROM
       COND-TREE-TO-IF-TREE
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID))))))
  :VOID)

;;; (DEFUN (YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS OBJECT) ...)

(CL:DEFUN YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS (CASETEST)
  (CL:WHEN
   (CL:EQ CASETEST SYM-WALK-OTHERWISE)
   (CL:RETURN-FROM YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS CASETEST))
  (CL:LET*
   ((SYMBOL NULL))
   (CL:LET*
    ((CASETEST-001 CASETEST))
    (CL:COND
     ((CL:EQ (CONS? CASETEST) 1)
      (CL:LET*
       ((CASETEST NULL))
       (CL:SETQ CASETEST CASETEST-001)
       (CL:LET*
        ((IT (ALLOCATE-ITERATOR CASETEST)))
        (CL:LOOP
         WHILE
         (CL:EQ (NEXT? IT) 1)
         DO
         (CL:SETQ SYMBOL (CLSYS-SVAL CONS-ITERATOR VALUE IT))
         (CL:WHEN
          (CL:EQ (DEFINED? (CLSYS-SVAL SYMBOL SYMBOL-ID SYMBOL)) 0)
          (CL:SETQ
           SYMBOL
           (INTERN-PERMANENT-SYMBOL (CLSYS-SVAL SYMBOL SYMBOL-NAME SYMBOL))))
         (VALUE-SETTER IT (WRAP-LITERAL (CLSYS-SVAL SYMBOL SYMBOL-ID SYMBOL)))
         (REGISTER-SYMBOL SYMBOL)))
       (CL:RETURN-FROM YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS CASETEST)))
     ((CL:EQ (SYMBOL? CASETEST) 1)
      (CL:LET*
       ((CASETEST NULL))
       (CL:SETQ CASETEST CASETEST-001)
       (CL:SETQ SYMBOL CASETEST)
       (CL:WHEN
        (CL:EQ (DEFINED? (CLSYS-SVAL SYMBOL SYMBOL-ID SYMBOL)) 0)
        (CL:SETQ
         SYMBOL
         (INTERN-PERMANENT-SYMBOL (CLSYS-SVAL SYMBOL SYMBOL-NAME SYMBOL))))
       (REGISTER-SYMBOL CASETEST)
       (CL:RETURN-FROM
        YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS
        (WRAP-LITERAL (CLSYS-SVAL SYMBOL SYMBOL-ID SYMBOL)))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" CASETEST)))))
  :VOID)

;;; (DEFUN (WALK-HARDCODED-SYMBOL-CASE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-HARDCODED-SYMBOL-CASE-TREE (TREE)
  (SECOND-SETTER
   TREE
   (LIST*
    SYM-WALK-SYMBOL-ID
    (LIST* SYM-WALK-CAST (SECOND TREE) (CONS SYM-WALK-GENERALIZED-SYMBOL NIL))
    NIL))
  (CL:LET*
   ((COND NULL) (ITER-001 (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ COND (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (FIRST-SETTER COND (YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS (FIRST COND)))))
  (CL:RETURN-FROM WALK-HARDCODED-SYMBOL-CASE-TREE (WALK-CASE-TREE TREE))
  :VOID)

;;; (DEFGLOBAL *TYPE-PREDICATE-TABLE* ...)

(CL:DEFVAR *TYPE-PREDICATE-TABLE* NULL
  "Table of specialized type predicates for various types.
These predicates have to be used instead of 'isa?', since they also work
during bootstrap when only some class objects are defined.")

;;; (DEFUN (YIELD-COND-TEST CONS) ...)

(CL:DEFUN YIELD-COND-TEST (CASETEST TESTVARIABLE EQUALITYTEST)
  (CL:WHEN
   (CL:AND (CL:EQ (SYMBOL? CASETEST) 1) (CL:EQ (USE-HARDCODED-SYMBOLS?) 0))
   (REGISTER-SYMBOL CASETEST)
   (CL:SETQ
    CASETEST
    (LIST*
     SYM-WALK-TYPED-SYS
     (YIELD-SYMBOL-CONSTANT-NAME CASETEST)
     (CONS SGT-WALK-SYMBOL NIL))))
  (CL:WHEN
   (CL:EQ EQUALITYTEST SYM-WALK-ISA?)
   (CL:LET*
    ((PAIR NULL) (ITER-001 *TYPE-PREDICATE-TABLE*))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ PAIR (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:EQ (FIRST PAIR) CASETEST)
      (CL:RETURN-FROM
       YIELD-COND-TEST
       (CONS (SECOND PAIR) (CONS TESTVARIABLE NIL))))))
   (CL:WHEN
    (CL:EQ (SUBTYPE-OF? (TYPIFY CASETEST) SGT-WALK-OBJECT) 1)
    (CL:SETQ EQUALITYTEST SYM-WALK-TAXONOMY-ISA?)))
  (CL:RETURN-FROM
   YIELD-COND-TEST
   (CONS EQUALITYTEST (CONS TESTVARIABLE (CONS CASETEST NIL))))
  :VOID)

;;; (DEFUN (YIELD-COND-TEST-OR-TESTS OBJECT) ...)

(CL:DEFUN YIELD-COND-TEST-OR-TESTS (CASETEST TESTVARIABLE EQUALITYTEST)
  (CL:LET*
   ((CASETEST-001 CASETEST))
   (CL:COND
    ((CL:EQ (CONS? CASETEST) 1)
     (CL:LET*
      ((CASETEST NULL))
      (CL:SETQ CASETEST CASETEST-001)
      (CL:LET*
       ((IT (ALLOCATE-ITERATOR CASETEST)))
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? IT) 1)
        DO
        (VALUE-SETTER
         IT
         (YIELD-COND-TEST
          (CLSYS-SVAL CONS-ITERATOR VALUE IT)
          TESTVARIABLE
          EQUALITYTEST))))
      (CL:SETQ CASETEST (CONS SYM-WALK-OR CASETEST))
      (CL:RETURN-FROM YIELD-COND-TEST-OR-TESTS CASETEST)))
    (CL:T
     (CL:IF
      (CL:EQ CASETEST SYM-WALK-OTHERWISE)
      (CL:RETURN-FROM YIELD-COND-TEST-OR-TESTS CASETEST)
      (CL:RETURN-FROM
       YIELD-COND-TEST-OR-TESTS
       (YIELD-COND-TEST CASETEST TESTVARIABLE EQUALITYTEST))))))
  :VOID)

;;; (DEFUN (WALK-NON-BUILT-IN-CASE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-NON-BUILT-IN-CASE-TREE (TREE EQUALITYTEST)
  (CL:LET*
   ((TESTEXPRESSION (SECOND TREE))
    (TESTVARIABLE
     (CL:IF
      (CL:EQ (SYMBOL? (SECOND TREE)) 1)
      (SECOND TREE)
      (LOCAL-GENSYM "TEST-VALUE")))
    (OTHERWISE? FALSE)
    (CONDITIONS (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))
   (CL:LET*
    ((COND NULL) (ITER-001 CONDITIONS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ COND (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:EQ (FIRST COND) SYM-WALK-OTHERWISE)
      (CL:SETQ OTHERWISE? TRUE))
     (FIRST-SETTER
      COND
      (YIELD-COND-TEST-OR-TESTS (FIRST COND) TESTVARIABLE EQUALITYTEST))))
   (FREE-CONS (CLSYS-SVAL CONS REST TREE))
   (FREE-CONS TREE)
   (CL:WHEN
    (CL:EQ OTHERWISE? 0)
    (CL:SETQ
     CONDITIONS
     (CONCATENATE
      CONDITIONS
      (CONS
       (LIST*
        SYM-WALK-OTHERWISE
        (LIST*
         SYM-WALK-ERROR
         TESTVARIABLE
         (CONS (WRAP-LITERAL " is not a valid case option") NIL))
        NIL)
       NIL))))
   (CL:RETURN-FROM
    WALK-NON-BUILT-IN-CASE-TREE
    (WALK-A-CONS-TREE
     (CL:IF
      (CL:EQ TESTEXPRESSION TESTVARIABLE)
      (CONS SYM-WALK-COND (CONCATENATE CONDITIONS NIL))
      (LIST*
       SYM-WALK-LET
       (CONS (CONS TESTVARIABLE (CONS TESTEXPRESSION NIL)) NIL)
       (CONS SYM-WALK-COND (CONCATENATE CONDITIONS NIL))
       NIL)))))
  :VOID)

;;; (DEFUN (WALK-CASE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-CASE-TREE (TREE)
  (CL:LET*
   ((FIRSTTESTTREE
     (FIRST (FIRST (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))))
   (SECOND-SETTER TREE (WALK-WITHOUT-TYPE-TREE (SECOND TREE)))
   (CL:WHEN
    (CL:EQ (CONS? FIRSTTESTTREE) 1)
    (CL:SETQ FIRSTTESTTREE (FIRST FIRSTTESTTREE)))
   (CL:WHEN
    (CL:AND
     (CL:EQ (SYMBOL? FIRSTTESTTREE) 1)
     (CL:EQ (USE-HARDCODED-SYMBOLS?) 1))
    (CL:RETURN-FROM WALK-CASE-TREE (WALK-HARDCODED-SYMBOL-CASE-TREE TREE)))
   (CL:WHEN
    (CL:NOT
     (CL:OR
      (CL:EQ (INTEGER? FIRSTTESTTREE) 1)
      (CL:EQ (CHARACTER? FIRSTTESTTREE) 1)))
    (CL:RETURN-FROM
     WALK-CASE-TREE
     (WALK-NON-BUILT-IN-CASE-TREE
      TREE
      (CL:IF
       (CL:EQ (STRING? FIRSTTESTTREE) 1)
       SYM-WALK-STRING-EQL?
       SYM-WALK-EQL?))))
   (CL:LET*
    ((CURSOR (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
     (CONDITIONTREE NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ CURSOR NIL))
     DO
     (CL:SETQ CONDITIONTREE (CLSYS-SVAL CONS VALUE CURSOR))
     (CL:WHEN
      (CL:NOT (CL:EQ (FIRST CONDITIONTREE) SYM-WALK-OTHERWISE))
      (FIRST-SETTER
       CONDITIONTREE
       (CL:IF
        (CL:EQ (CONS? (FIRST CONDITIONTREE)) 1)
        (WALK-LIST-OF-TREES (FIRST CONDITIONTREE))
        (WALK-A-TREE (FIRST CONDITIONTREE)))))
     (CL:SETF
      (CLSYS-SVAL CONS REST CONDITIONTREE)
      (WALK-LIST-OF-TREES (CLSYS-SVAL CONS REST CONDITIONTREE)))
     (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
    (CL:RETURN-FROM WALK-CASE-TREE (CL:VALUES TREE SGT-WALK-VOID))))
  :VOID)

;;; (DEFUN (WALK-TYPECASE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-TYPECASE-TREE (TREE)
  (CL:LET*
   ((TESTTREE (SECOND TREE))
    (TESTVARIABLE NULL)
    (AUXVARIABLE NULL)
    (EXPANDEDCASES NIL)
    (NEEDCAST? FALSE))
   (CL:WHEN
    (CL:EQ (SYMBOL? TESTTREE) 1)
    (CL:SETQ TESTVARIABLE TESTTREE)
    (CL:SETQ
     AUXVARIABLE
     (LOCAL-GENSYM (CLSYS-SVAL SYMBOL SYMBOL-NAME TESTVARIABLE)))
    (CL:SETQ NEEDCAST? TRUE))
   (CL:WHEN
    (CL:EQ NEEDCAST? 1)
    (CL:LET*
     ((CASETREE NULL)
      (ITER-001 (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ CASETREE (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:LET*
       ((CASETREE-001 CASETREE))
       (CL:COND
        ((CL:EQ (CONS? CASETREE) 1)
         (CL:LET*
          ((CASETREE NULL))
          (CL:SETQ CASETREE CASETREE-001)
          (CL:LET*
           ((TYPETREE (FIRST CASETREE)))
           (CL:LET*
            ((TYPETREE-001 TYPETREE))
            (CL:COND
             ((CL:EQ (CONS? TYPETREE) 1)
              (CL:LET*
               ((TYPETREE NULL))
               (CL:SETQ TYPETREE TYPETREE-001)
               (FIRST-SETTER CASETREE (FIRST TYPETREE))
               (CL:SETQ EXPANDEDCASES (CONS CASETREE EXPANDEDCASES))
               (CL:LET*
                ((TYPE NULL) (ITER-002 (CLSYS-SVAL CONS REST TYPETREE)))
                (CL:LOOP
                 WHILE
                 (CL:NOT (CL:EQ ITER-002 NIL))
                 DO
                 (CL:PROGN
                  (CL:SETQ TYPE (CLSYS-SVAL CONS VALUE ITER-002))
                  (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
                 (CL:SETQ
                  EXPANDEDCASES
                  (CONS
                   (CONS
                    TYPE
                    (CONCATENATE
                     (COPY-CONS-TREE (CLSYS-SVAL CONS REST CASETREE))
                     NIL))
                   EXPANDEDCASES))))))
             (CL:T (CL:SETQ EXPANDEDCASES (CONS CASETREE EXPANDEDCASES))))))))
        (CL:T (CL:SETQ EXPANDEDCASES (CONS CASETREE EXPANDEDCASES)))))))
    (FREE-CONS-LIST (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
    (CL:SETF
     (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))
     (REVERSE EXPANDEDCASES)))
   (CL:LET*
    ((CASETREE NULL)
     (ITER-003 (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-003 NIL))
     DO
     (CL:PROGN
      (CL:SETQ CASETREE (CLSYS-SVAL CONS VALUE ITER-003))
      (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
     (CL:LET*
      ((CASETREE-002 CASETREE))
      (CL:COND
       ((CL:EQ (CONS? CASETREE) 1)
        (CL:LET*
         ((CASETREE NULL))
         (CL:SETQ CASETREE CASETREE-002)
         (CL:LET*
          ((TYPETREE (FIRST CASETREE)))
          (CL:LET*
           ((TYPETREE-002 TYPETREE))
           (CL:COND
            ((CL:EQ (SYMBOL? TYPETREE) 1)
             (CL:LET*
              ((TYPETREE NULL))
              (CL:SETQ TYPETREE TYPETREE-002)
              (CL:WHEN
               (CL:EQ
                (STRING-EQL?
                 (CLSYS-SVAL SYMBOL SYMBOL-NAME TYPETREE)
                 "OTHERWISE")
                0)
               (CL:LET*
                ((TYPE
                  (TYPE-SPEC-TO-BASE-TYPE (YIELD-TYPE-SPECIFIER TYPETREE))))
                (CL:WHEN
                 (CL:EQ (UNKNOWN-TYPE? TYPE) 1)
                 (CL:LET*
                  ((*PRINTREADABLY?* TRUE))
                  (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
                  (SIGNAL-TRANSLATION-ERROR)
                  (CL:WHEN
                   (CL:EQ (SUPPRESS-WARNINGS?) 0)
                   (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
                   (CL:LET
                    ((%%STREAM
                      (CLSYS-SVAL
                       OUTPUT-STREAM
                       NATIVE-STREAM
                       STANDARD-OUTPUT)))
                    (CL:TERPRI %%STREAM)
                    (CL:FORCE-OUTPUT %%STREAM)
                    (CL:WRITE-STRING
                     " Reference to undefined class in 'typecase': `"
                     %%STREAM)
                    (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TYPE) %%STREAM)
                    (CL:WRITE-STRING "'." %%STREAM)
                    (CL:TERPRI %%STREAM)
                    (CL:FORCE-OUTPUT %%STREAM))))
                 (CL:RETURN-FROM
                  WALK-TYPECASE-TREE
                  (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
                (FIRST-SETTER CASETREE TYPE)
                (CL:SETQ TYPE (TYPE-TO-WRAPPED-TYPE TYPE))
                (CL:WHEN
                 (CL:AND
                  (CL:EQ NEEDCAST? 1)
                  (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST CASETREE) NIL)))
                 (CL:SETF
                  (CLSYS-SVAL CONS REST CASETREE)
                  (CONS
                   (LIST*
                    SYM-WALK-LET
                    (CONS
                     (CONS TESTVARIABLE (CONS TYPE (CONS SYM-WALK-NULL NIL)))
                     NIL)
                    (LIST*
                     SYM-WALK-SETQ
                     TESTVARIABLE
                     (CONS
                      (LIST*
                       SYM-WALK-SAFE-CAST
                       AUXVARIABLE
                       (CONS (YIELD-TYPE-SPEC-TREE TYPE) NIL))
                      NIL))
                    (CONCATENATE (CLSYS-SVAL CONS REST CASETREE) NIL))
                   NIL)))))))
            ((CL:EQ (SURROGATE? TYPETREE) 1)
             (CL:LET*
              ((TYPETREE NULL))
              (CL:SETQ TYPETREE TYPETREE-002)
              (CL:WHEN
               (CL:EQ
                (STRING-EQL?
                 (CLSYS-SVAL SURROGATE SYMBOL-NAME TYPETREE)
                 "OTHERWISE")
                0)
               (CL:LET*
                ((TYPE
                  (TYPE-SPEC-TO-BASE-TYPE (YIELD-TYPE-SPECIFIER TYPETREE))))
                (CL:WHEN
                 (CL:EQ (UNKNOWN-TYPE? TYPE) 1)
                 (CL:LET*
                  ((*PRINTREADABLY?* TRUE))
                  (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
                  (SIGNAL-TRANSLATION-ERROR)
                  (CL:WHEN
                   (CL:EQ (SUPPRESS-WARNINGS?) 0)
                   (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
                   (CL:LET
                    ((%%STREAM
                      (CLSYS-SVAL
                       OUTPUT-STREAM
                       NATIVE-STREAM
                       STANDARD-OUTPUT)))
                    (CL:TERPRI %%STREAM)
                    (CL:FORCE-OUTPUT %%STREAM)
                    (CL:WRITE-STRING
                     " Reference to undefined class in 'typecase': `"
                     %%STREAM)
                    (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TYPE) %%STREAM)
                    (CL:WRITE-STRING "'." %%STREAM)
                    (CL:TERPRI %%STREAM)
                    (CL:FORCE-OUTPUT %%STREAM))))
                 (CL:RETURN-FROM
                  WALK-TYPECASE-TREE
                  (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
                (FIRST-SETTER CASETREE TYPE)
                (CL:SETQ TYPE (TYPE-TO-WRAPPED-TYPE TYPE))
                (CL:WHEN
                 (CL:AND
                  (CL:EQ NEEDCAST? 1)
                  (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST CASETREE) NIL)))
                 (CL:SETF
                  (CLSYS-SVAL CONS REST CASETREE)
                  (CONS
                   (LIST*
                    SYM-WALK-LET
                    (CONS
                     (CONS TESTVARIABLE (CONS TYPE (CONS SYM-WALK-NULL NIL)))
                     NIL)
                    (LIST*
                     SYM-WALK-SETQ
                     TESTVARIABLE
                     (CONS
                      (LIST*
                       SYM-WALK-SAFE-CAST
                       AUXVARIABLE
                       (CONS (YIELD-TYPE-SPEC-TREE TYPE) NIL))
                      NIL))
                    (CONCATENATE (CLSYS-SVAL CONS REST CASETREE) NIL))
                   NIL)))))))
            ((CL:EQ (CONS? TYPETREE) 1)
             (CL:LET*
              ((TYPETREE NULL))
              (CL:SETQ TYPETREE TYPETREE-002)
              (CL:LET*
               ((IT (ALLOCATE-ITERATOR TYPETREE)))
               (CL:LOOP
                WHILE
                (CL:EQ (NEXT? IT) 1)
                DO
                (CL:WHEN
                 (CL:EQ (CONS? (CLSYS-SVAL CONS-ITERATOR VALUE IT)) 1)
                 (CL:LET*
                  ((*PRINTREADABLY?* TRUE))
                  (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
                  (SIGNAL-TRANSLATION-ERROR)
                  (CL:WHEN
                   (CL:EQ (SUPPRESS-WARNINGS?) 0)
                   (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
                   (CL:LET
                    ((%%STREAM
                      (CLSYS-SVAL
                       OUTPUT-STREAM
                       NATIVE-STREAM
                       STANDARD-OUTPUT)))
                    (CL:TERPRI %%STREAM)
                    (CL:FORCE-OUTPUT %%STREAM)
                    (CL:WRITE-STRING
                     " Illegal type expression in 'typecase': `"
                     %%STREAM)
                    (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TYPETREE) %%STREAM)
                    (CL:WRITE-STRING "'." %%STREAM)
                    (CL:TERPRI %%STREAM)
                    (CL:FORCE-OUTPUT %%STREAM))))
                 (CL:RETURN-FROM
                  WALK-TYPECASE-TREE
                  (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
                (VALUE-SETTER
                 IT
                 (TYPE-SPEC-TO-BASE-TYPE
                  (YIELD-TYPE-SPECIFIER (CLSYS-SVAL CONS-ITERATOR VALUE IT))))
                (CL:WHEN
                 (CL:EQ (UNKNOWN-TYPE? (CLSYS-SVAL CONS-ITERATOR VALUE IT)) 1)
                 (CL:LET*
                  ((*PRINTREADABLY?* TRUE))
                  (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
                  (SIGNAL-TRANSLATION-ERROR)
                  (CL:WHEN
                   (CL:EQ (SUPPRESS-WARNINGS?) 0)
                   (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
                   (CL:LET
                    ((%%STREAM
                      (CLSYS-SVAL
                       OUTPUT-STREAM
                       NATIVE-STREAM
                       STANDARD-OUTPUT)))
                    (CL:TERPRI %%STREAM)
                    (CL:FORCE-OUTPUT %%STREAM)
                    (CL:WRITE-STRING
                     " Reference to undefined class in 'typecase': `"
                     %%STREAM)
                    (PRINT-OBJECT
                     (CLSYS-SVAL CONS-ITERATOR VALUE IT)
                     %%STREAM)
                    (CL:WRITE-STRING "'." %%STREAM)
                    (CL:TERPRI %%STREAM)
                    (CL:FORCE-OUTPUT %%STREAM))))
                 (CL:RETURN-FROM
                  WALK-TYPECASE-TREE
                  (WALK-DONT-CALL-ME-TREE
                   (CLSYS-SVAL CONS-ITERATOR VALUE IT)
                   SGT-WALK-VOID)))))))
            (CL:T
             (CL:LET*
              ((*PRINTREADABLY?* TRUE))
              (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
              (SIGNAL-TRANSLATION-ERROR)
              (CL:WHEN
               (CL:EQ (SUPPRESS-WARNINGS?) 0)
               (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
               (CL:LET
                ((%%STREAM
                  (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
                (CL:TERPRI %%STREAM)
                (CL:FORCE-OUTPUT %%STREAM)
                (CL:WRITE-STRING
                 " Illegal type expression in 'typecase': `"
                 %%STREAM)
                (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TYPETREE) %%STREAM)
                (CL:WRITE-STRING "'." %%STREAM)
                (CL:TERPRI %%STREAM)
                (CL:FORCE-OUTPUT %%STREAM))))
             (CL:RETURN-FROM
              WALK-TYPECASE-TREE
              (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID))))))))
       (CL:T
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN
          (CL:EQ (SUPPRESS-WARNINGS?) 0)
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING
            " Illegal case expression in 'typecase': `"
            %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE CASETREE) %%STREAM)
           (CL:WRITE-STRING "'." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))))
        (CL:RETURN-FROM
         WALK-TYPECASE-TREE
         (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))))))
   (FIRST-SETTER TREE SYM-WALK-CASE)
   (CL:WHEN
    (CL:EQ NEEDCAST? 1)
    (PUSH-VARIABLE-BINDING AUXVARIABLE (LOOKUP-VARIABLE-TYPE TESTVARIABLE))
    (CL:SETQ TREE (WALK-NON-BUILT-IN-CASE-TREE TREE SYM-WALK-ISA?))
    (POP-VARIABLE-BINDING)
    (CL:RETURN-FROM
     WALK-TYPECASE-TREE
     (WALK-A-CONS-TREE
      (LIST*
       SYM-WALK-LET
       (CONS (CONS AUXVARIABLE (CONS TESTVARIABLE NIL)) NIL)
       TREE
       NIL))))
   (CL:RETURN-FROM
    WALK-TYPECASE-TREE
    (WALK-NON-BUILT-IN-CASE-TREE TREE SYM-WALK-ISA?)))
  :VOID)

;;; (DEFUN (FINISH-WALKING-EQL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN FINISH-WALKING-EQL-TREE (TREE TYPE1 TYPE2)
  (CL:WHEN
   (CL:OR
    (CL:EQ (SUBTYPE-OF? TYPE1 SGT-WALK-STANDARD-OBJECT) 1)
    (CL:EQ (SUBTYPE-OF? TYPE2 SGT-WALK-STANDARD-OBJECT) 1)
    (CL:AND
     (CL:EQ (SUBTYPE-OF? TYPE1 SGT-WALK-OBJECT) 0)
     (CL:EQ (SUBTYPE-OF? TYPE1 SGT-WALK-LITERAL) 0))
    (CL:AND
     (CL:EQ (SUBTYPE-OF? TYPE2 SGT-WALK-OBJECT) 0)
     (CL:EQ (SUBTYPE-OF? TYPE2 SGT-WALK-LITERAL) 0)))
   (FIRST-SETTER TREE SYM-WALK-EQ?)
   (SECOND-SETTER TREE (SYS-TREE (SECOND TREE) TYPE1))
   (THIRD-SETTER TREE (SYS-TREE (THIRD TREE) TYPE2))
   (CL:RETURN-FROM FINISH-WALKING-EQL-TREE (CL:VALUES TREE SGT-WALK-BOOLEAN)))
  (CL:WHEN
   (CL:AND
    (CL:EQ (SUBTYPE-OF? TYPE1 SGT-WALK-LITERAL) 1)
    (CL:EQ (SUBTYPE-OF? TYPE2 SGT-WALK-LITERAL) 1))
   (CL:IF
    (CL:EQ TYPE1 SGT-WALK-STRING)
    (FIRST-SETTER TREE SYM-WALK-STRING-EQL?)
    (FIRST-SETTER TREE SYM-WALK-EQ?))
   (CL:RETURN-FROM FINISH-WALKING-EQL-TREE (WALK-A-CONS-TREE TREE)))
  (CL:WHEN
   (CL:AND
    (CL:EQ (SUBTYPE-OF? TYPE1 SGT-WALK-LITERAL) 0)
    (CL:EQ (SUBTYPE-OF? TYPE2 SGT-WALK-LITERAL) 0))
   (CL:LET*
    ((OTREE NULL) (OTYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE) (WALK-CALL-SLOT-TREE TREE))
    (CL:RETURN-FROM FINISH-WALKING-EQL-TREE (CL:VALUES OTREE OTYPE))))
  (CL:WHEN
   (CL:EQ (SUBTYPE-OF? TYPE2 SGT-WALK-LITERAL) 0)
   (CL:LET*
    ((TEMPARG (THIRD TREE)) (TEMPTYPE TYPE2))
    (THIRD-SETTER TREE (SECOND TREE))
    (SECOND-SETTER TREE TEMPARG)
    (CL:SETQ TYPE2 TYPE1)
    (CL:SETQ TYPE1 TEMPTYPE)))
  (CL:COND
   ((CL:EQ TYPE2 SGT-WALK-BOOLEAN)
    (FIRST-SETTER TREE SYM-WALK-EQL-TO-BOOLEAN?))
   ((CL:EQ TYPE2 SGT-WALK-INTEGER)
    (FIRST-SETTER TREE SYM-WALK-EQL-TO-INTEGER?))
   ((CL:EQ TYPE2 SGT-WALK-FLOAT) (FIRST-SETTER TREE SYM-WALK-EQL-TO-FLOAT?))
   ((CL:EQ TYPE2 SGT-WALK-STRING) (FIRST-SETTER TREE SYM-WALK-EQL-TO-STRING?))
   (CL:T (CL:ERROR "`~A' is not a valid case option" TYPE2)))
  (CL:RETURN-FROM
   FINISH-WALKING-EQL-TREE
   (CL:VALUES (WALK-WITHOUT-TYPE-TREE TREE) SGT-WALK-BOOLEAN))
  :VOID)

;;; (DEFUN (FINISH-WALKING-EQUAL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN FINISH-WALKING-EQUAL-TREE (TREE TYPE1 TYPE2)
  (CL:PROGN (CL:SETQ TREE TREE) (CL:SETQ TYPE1 TYPE1) (CL:SETQ TYPE2 TYPE2))
  (CL:LET*
   ((*PRINTREADABLY?* TRUE))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (SIGNAL-TRANSLATION-ERROR)
   (CL:WHEN
    (CL:EQ (SUPPRESS-WARNINGS?) 0)
    (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:WRITE-STRING
      " finish-walking-equal-tree: NOT YET IMPLEMENTED.."
      %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))))
  (CL:RETURN-FROM FINISH-WALKING-EQUAL-TREE (CL:VALUES NULL SGT-WALK-BOOLEAN))
  :VOID)

;;; (DEFUN (WALK-EQUALITY-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-EQUALITY-TREE (TREE)
  (CL:LET*
   ((ARG1 NULL) (ARG2 NULL) (TYPE1 NULL) (TYPE2 NULL))
   (CL:MULTIPLE-VALUE-SETQ (ARG1 TYPE1) (WALK-A-TREE (SECOND TREE)))
   (CL:MULTIPLE-VALUE-SETQ (ARG2 TYPE2) (WALK-A-TREE (THIRD TREE)))
   (SECOND-SETTER TREE ARG1)
   (THIRD-SETTER TREE ARG2)
   (CL:WHEN
    (CL:EQ (VRLET-EXPRESSION? ARG1) 1)
    (CL:RETURN-FROM
     WALK-EQUALITY-TREE
     (WALK-A-TREE
      (PERCOLATE-OUT-VRLET-EXPRESSION TREE ARG1 SGT-WALK-BOOLEAN))))
   (CL:WHEN
    (CL:EQ (VRLET-EXPRESSION? ARG2) 1)
    (CL:RETURN-FROM
     WALK-EQUALITY-TREE
     (WALK-A-TREE
      (PERCOLATE-OUT-VRLET-EXPRESSION TREE ARG2 SGT-WALK-BOOLEAN))))
   (CL:SETQ TYPE1 (TYPE-SPEC-TO-BASE-TYPE TYPE1))
   (CL:SETQ TYPE2 (TYPE-SPEC-TO-BASE-TYPE TYPE2))
   (CL:WHEN
    (CL:NOT
     (CL:OR
      (CL:EQ TYPE1 SGT-WALK-UNKNOWN)
      (CL:EQ TYPE2 SGT-WALK-UNKNOWN)
      (CL:EQ (SUBTYPE-OF? TYPE1 TYPE2) 1)
      (CL:EQ (SUBTYPE-OF? TYPE2 TYPE1) 1)))
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-WARNING)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING
        " This equality test will always fail due to disjoint argument types:"
        %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING "    `" %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))))
   (CL:LET*
    ((TEST-VALUE-001 (FIRST TREE)))
    (CL:COND
     ((CL:OR
       (CL:EQ TEST-VALUE-001 SYM-WALK-EQ?)
       (CL:EQ TEST-VALUE-001 SYM-WALK-=))
      (FIRST-SETTER TREE SYM-WALK-EQ?)
      (SECOND-SETTER TREE (SYS-TREE (SECOND TREE) TYPE1))
      (THIRD-SETTER TREE (SYS-TREE (THIRD TREE) TYPE2))
      (CL:RETURN-FROM WALK-EQUALITY-TREE (CL:VALUES TREE SGT-WALK-BOOLEAN)))
     ((CL:EQ TEST-VALUE-001 SYM-WALK-EQL?)
      (CL:RETURN-FROM
       WALK-EQUALITY-TREE
       (FINISH-WALKING-EQL-TREE TREE TYPE1 TYPE2)))
     (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001)))))
  :VOID)

;;; (DEFGLOBAL *NUMERIC-TYPE-HIERARCHY* ...)

(CL:DEFVAR *NUMERIC-TYPE-HIERARCHY* NULL)

;;; (DEFUN (MORE-GENERAL-NUMERIC-TYPE TYPE) ...)

(CL:DEFUN MORE-GENERAL-NUMERIC-TYPE (TYPE1 TYPE2)
  (CL:LET*
   ((POSITION1 (POSITION *NUMERIC-TYPE-HIERARCHY* TYPE1 0))
    (POSITION2 (POSITION *NUMERIC-TYPE-HIERARCHY* TYPE2 0)))
   (CL:WHEN
    (CL:OR (CL:EQ (NULL? POSITION1) 1) (CL:EQ (NULL? POSITION2) 1))
    (CL:RETURN-FROM MORE-GENERAL-NUMERIC-TYPE SGT-WALK-NUMBER))
   (CL:IF
    (CL:> POSITION1 POSITION2)
    (CL:RETURN-FROM MORE-GENERAL-NUMERIC-TYPE TYPE1)
    (CL:RETURN-FROM MORE-GENERAL-NUMERIC-TYPE TYPE2)))
  :VOID)

;;; (DEFUN (YIELD-ARITHMETIC-OPERATOR-CALL-TREE CONS) ...)

(CL:DEFUN YIELD-ARITHMETIC-OPERATOR-CALL-TREE (OPERATOR OPERANDS)
  (CL:RETURN-FROM
   YIELD-ARITHMETIC-OPERATOR-CALL-TREE
   (LIST*
    SYM-WALK-SYS-CALL-METHOD
    SGT-WALK-NUMBER
    OPERATOR
    (CONCATENATE OPERANDS NIL)))
  :VOID)

;;; (DEFUN (YIELD-NESTED-ARITHMETIC-OPERATOR-CALL-TREE CONS) ...)

(CL:DEFUN YIELD-NESTED-ARITHMETIC-OPERATOR-CALL-TREE (OPERATOR OPERANDS)
  (CL:LET*
   ((NOFOPERANDS (LENGTH OPERANDS))
    (PARENTHESIZEDTREE
     (YIELD-ARITHMETIC-OPERATOR-CALL-TREE
      OPERATOR
      (CONS-LIST (FIRST OPERANDS) (SECOND OPERANDS)))))
   (CL:LET*
    ((I NULL) (ITER-001 2) (UPPER-BOUND-001 (CL:1- NOFOPERANDS)))
    (CL:LOOP
     WHILE
     (CL:<= ITER-001 UPPER-BOUND-001)
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETQ
      PARENTHESIZEDTREE
      (YIELD-ARITHMETIC-OPERATOR-CALL-TREE
       OPERATOR
       (CONS-LIST PARENTHESIZEDTREE (NTH OPERANDS I))))))
   (CL:RETURN-FROM
    YIELD-NESTED-ARITHMETIC-OPERATOR-CALL-TREE
    PARENTHESIZEDTREE))
  :VOID)

;;; (DEFUN (WALK-ARITHMETIC-TREE OBJECT TYPE) ...)

(CL:DEFUN WALK-ARITHMETIC-TREE (TREE)
  (CL:LET*
   ((OPERATOR (FIRST TREE))
    (OPERANDS (CLSYS-SVAL CONS REST TREE))
    (NOFOPERANDS (LENGTH OPERANDS))
    (OPERAND NULL)
    (OPERANDTYPE NULL)
    (RETURNTYPE SGT-WALK-INTEGER))
   (CL:CASE
    NOFOPERANDS
    (0
     (CL:COND
      ((CL:EQ OPERATOR SYM-WALK-+)
       (CL:RETURN-FROM
        WALK-ARITHMETIC-TREE
        (CL:VALUES (WRAP-LITERAL 0) SGT-WALK-INTEGER)))
      ((CL:EQ OPERATOR SYM-WALK-*)
       (CL:RETURN-FROM
        WALK-ARITHMETIC-TREE
        (CL:VALUES (WRAP-LITERAL 1) SGT-WALK-INTEGER)))
      (CL:T
       (BAD-ARGUMENT-COUNT? TREE 1)
       (CL:LET*
        ((VALUE-001 NULL) (VALUE-002 NULL))
        (CL:MULTIPLE-VALUE-SETQ
         (VALUE-001 VALUE-002)
         (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-NUMBER))
        (CL:RETURN-FROM
         WALK-ARITHMETIC-TREE
         (CL:VALUES VALUE-001 VALUE-002))))))
    (1
     (CL:COND
      ((CL:OR (CL:EQ OPERATOR SYM-WALK-+) (CL:EQ OPERATOR SYM-WALK-*))
       (CL:LET*
        ((VALUE-003 NULL) (VALUE-004 NULL))
        (CL:MULTIPLE-VALUE-SETQ
         (VALUE-003 VALUE-004)
         (WALK-EXPRESSION-TREE
          (FIRST OPERANDS)
          SGT-WALK-NUMBER
          OPERATOR
          FALSE))
        (CL:RETURN-FROM
         WALK-ARITHMETIC-TREE
         (CL:VALUES VALUE-003 VALUE-004))))
      ((CL:OR (CL:EQ OPERATOR SYM-WALK--) (CL:EQ OPERATOR SYM-WALK-/))
       (CL:SETF (CLSYS-SVAL CONS REST OPERANDS) (CONS (FIRST OPERANDS) NIL))
       (FIRST-SETTER
        OPERANDS
        (CL:IF
         (CL:EQ OPERATOR SYM-WALK--)
         (WRAP-LITERAL 0)
         (WRAP-LITERAL 1))))
      (CL:T (CL:ERROR "`~A' is not a valid case option" OPERATOR))))
    (CL:OTHERWISE NULL))
   (CL:LET*
    ((IT (ALLOCATE-ITERATOR OPERANDS)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? IT) 1)
     DO
     (CL:MULTIPLE-VALUE-SETQ
      (OPERAND OPERANDTYPE)
      (WALK-EXPRESSION-TREE
       (CLSYS-SVAL CONS-ITERATOR VALUE IT)
       SGT-WALK-NUMBER
       OPERATOR
       FALSE))
     (CL:SETQ
      RETURNTYPE
      (MORE-GENERAL-NUMERIC-TYPE
       RETURNTYPE
       (TYPE-SPEC-TO-BASE-TYPE OPERANDTYPE)))
     (VALUE-SETTER IT OPERAND)))
   (CL:WHEN
    (CL:AND (CL:EQ OPERATOR SYM-WALK-/) (CL:EQ RETURNTYPE SGT-WALK-INTEGER))
    (CL:COND
     ((CL:EQ (WRAPPER? (FIRST OPERANDS)) 1)
      (FIRST-SETTER
       OPERANDS
       (WRAP-LITERAL
        (CL:*
         (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE (FIRST OPERANDS))
         1.0))))
     ((CL:EQ (WRAPPER? (SECOND OPERANDS)) 1)
      (SECOND-SETTER
       OPERANDS
       (WRAP-LITERAL
        (CL:*
         (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE (SECOND OPERANDS))
         1.0))))
     (CL:T
      (CL:SETQ
       OPERANDS
       (CONS
        (FIRST OPERANDS)
        (CONS
         (WRAP-LITERAL 1.0)
         (CONCATENATE (CLSYS-SVAL CONS REST OPERANDS) NIL))))
      (CL:SETQ NOFOPERANDS (CL:1+ NOFOPERANDS))))
    (CL:SETQ RETURNTYPE SGT-WALK-FLOAT))
   (CL:IF
    (CL:AND
     (CL:> NOFOPERANDS 2)
     (CL:NOT (CL:EQ (TRANSLATOR-OUTPUT-LANGUAGE) KWD-WALK-COMMON-LISP)))
    (CL:RETURN-FROM
     WALK-ARITHMETIC-TREE
     (CL:VALUES
      (YIELD-NESTED-ARITHMETIC-OPERATOR-CALL-TREE OPERATOR OPERANDS)
      RETURNTYPE))
    (CL:RETURN-FROM
     WALK-ARITHMETIC-TREE
     (CL:VALUES
      (YIELD-ARITHMETIC-OPERATOR-CALL-TREE OPERATOR OPERANDS)
      RETURNTYPE))))
  :VOID)

;;; (DEFUN (WALK-QUOTED-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-QUOTED-TREE (TREE)
  (CL:WHEN
   (CL:EQ (BAD-ARGUMENT-COUNT? TREE 1) 1)
   (CL:RETURN-FROM
    WALK-QUOTED-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-UNKNOWN)))
  (CL:LET*
   ((ARGUMENT (SECOND TREE))
    (QUOTEDLITERAL?
     (CL:IF
      (CL:OR (CL:EQ (CONS? ARGUMENT) 0) (CL:EQ ARGUMENT NIL))
      TRUE
      FALSE))
    (OBJECTNAME NULL))
   (CL:WHEN
    (CL:EQ QUOTEDLITERAL? 1)
    (CL:LET*
     ((OTREE NULL) (OTYPE NULL))
     (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE) (WALK-A-TREE (BQUOTIFY ARGUMENT)))
     (FREE-PARSE-TREE TREE)
     (CL:RETURN-FROM WALK-QUOTED-TREE (CL:VALUES OTREE OTYPE))))
   (CL:SETQ OBJECTNAME (NAME-QUOTED-TREE ARGUMENT))
   (FREE-PARSE-TREE TREE)
   (CL:RETURN-FROM
    WALK-QUOTED-TREE
    (WALK-A-TREE
     (LIST*
      SYM-WALK-GET-QUOTED-TREE
      (WRAP-LITERAL OBJECTNAME)
      (CONS
       (WRAP-LITERAL (CLSYS-SVAL MODULE MODULE-FULL-NAME *MODULE*))
       NIL)))))
  :VOID)

;;; (DEFUN (WALK-BQUOTE-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-BQUOTE-TREE (TREE)
  (CL:WHEN
   (CL:EQ (BAD-ARGUMENT-COUNT? TREE 1) 1)
   (CL:RETURN-FROM
    WALK-BQUOTE-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-UNKNOWN)))
  (CL:LET*
   ((OTREE NULL) (OTYPE NULL))
   (CL:MULTIPLE-VALUE-SETQ
    (OTREE OTYPE)
    (WALK-A-TREE (SIMPLIFY-BQUOTE-TREE (EXPAND-BQUOTE-TREE (SECOND TREE)))))
   (FREE-CONS-LIST TREE)
   (CL:RETURN-FROM WALK-BQUOTE-TREE (CL:VALUES OTREE OTYPE)))
  :VOID)

;;; (DEFUN (EXPAND-MACRO OBJECT) ...)

(CL:DEFUN EXPAND-MACRO (TREE)
  (CL:LET*
   ((MACRONAME (FIRST TREE))
    (EXPANDEROBJECT (LOOKUP-MACRO MACRONAME))
    (EXPANDERCODE (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE EXPANDEROBJECT))
    (ARGS (CLSYS-SVAL CONS REST TREE))
    (EXPANSION NULL))
   (CL:WHEN
    (CL:EQ EXPANDERCODE NULL)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Macro expander code for `" %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE MACRONAME) %%STREAM)
       (CL:WRITE-STRING "' is not available." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (CL:RETURN-FROM
     EXPAND-MACRO
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-UNKNOWN)))
   (CL:IF
    (CL:EQ (METHOD-BODY-ARGUMENT? EXPANDEROBJECT) 1)
    (CL:CASE
     (METHOD-ARGUMENT-COUNT EXPANDEROBJECT)
     (1
      (CL:SETQ EXPANSION (CL:FUNCALL EXPANDERCODE ARGS))
      (CL:SETF (CLSYS-SVAL CONS REST TREE) NIL))
     (2
      (CL:SETQ
       EXPANSION
       (CL:FUNCALL EXPANDERCODE (FIRST ARGS) (CLSYS-SVAL CONS REST ARGS)))
      (CL:SETF (CLSYS-SVAL CONS REST ARGS) NIL))
     (3
      (CL:SETQ
       EXPANSION
       (CL:FUNCALL
        EXPANDERCODE
        (FIRST ARGS)
        (SECOND ARGS)
        (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST ARGS))))
      (CL:SETF (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST ARGS)) NIL))
     (4
      (CL:SETQ
       EXPANSION
       (CL:FUNCALL
        EXPANDERCODE
        (FIRST ARGS)
        (SECOND ARGS)
        (NTH ARGS 2)
        (NTH-REST ARGS 2)))
      (NTH-REST-SETTER ARGS NIL 2))
     (5
      (CL:SETQ
       EXPANSION
       (CL:FUNCALL
        EXPANDERCODE
        (FIRST ARGS)
        (SECOND ARGS)
        (NTH ARGS 2)
        (NTH ARGS 3)
        (NTH-REST ARGS 3)))
      (NTH-REST-SETTER ARGS NIL 3))
     (CL:OTHERWISE
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN
        (CL:EQ (SUPPRESS-WARNINGS?) 0)
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING
          " Too many arguments in definition of macro `"
          %%STREAM)
         (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE MACRONAME) %%STREAM)
         (CL:WRITE-STRING "'." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))))
      (CL:RETURN-FROM
       EXPAND-MACRO
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-UNKNOWN))))
    (CL:SETQ EXPANSION (APPLY EXPANDERCODE (CLSYS-SVAL CONS REST TREE))))
   (FREE-CONS-LIST TREE)
   (CL:RETURN-FROM EXPAND-MACRO EXPANSION))
  :VOID)

;;; (DEFUN (WALK-MACRO-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-MACRO-TREE (TREE)
  (CL:RETURN-FROM WALK-MACRO-TREE (WALK-A-TREE (EXPAND-MACRO TREE)))
  :VOID)

;;; (DEFUN (WALK-PRINT-STREAM-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-PRINT-STREAM-TREE (TREE)
  (CL:WHEN
   (CL:<= (LENGTH TREE) 2)
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING " Missing arguments in print statement: `" %%STREAM)
      (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
      (CL:WRITE-STRING "'." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))))
   (CL:RETURN-FROM
    WALK-PRINT-STREAM-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
  (CL:LET*
   ((OPERATOR (FIRST TREE))
    (PRINTNATIVESTREAM? (EQ? OPERATOR SYM-WALK-PRINT-NATIVE-STREAM))
    (STREAMTREE (SECOND TREE))
    (OTREE NULL)
    (OTYPE NULL))
   (CL:COND
    ((CL:EQ (KEYWORD? STREAMTREE) 1)
     (CL:WHEN
      (CL:NOT
       (CL:OR
        (CL:EQ STREAMTREE KWD-WALK-WARN)
        (CL:EQ STREAMTREE KWD-WALK-ERROR)
        (CL:EQ STREAMTREE KWD-WALK-CONTINUABLE-ERROR)))
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN
        (CL:EQ (SUPPRESS-WARNINGS?) 0)
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING
          " Illegal stream argument in print statement: `"
          %%STREAM)
         (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
         (CL:WRITE-STRING "'." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))))
      (CL:RETURN-FROM
       WALK-PRINT-STREAM-TREE
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID))))
    (CL:T
     (CL:MULTIPLE-VALUE-SETQ
      (OTREE OTYPE)
      (WALK-EXPRESSION-TREE
       STREAMTREE
       (CL:IF
        (CL:EQ PRINTNATIVESTREAM? 1)
        SGT-WALK-NATIVE-OUTPUT-STREAM
        SGT-WALK-OUTPUT-STREAM)
       (FIRST TREE)
       FALSE))
     (CL:WHEN
      (CL:AND
       (CL:EQ PRINTNATIVESTREAM? 0)
       (CL:EQ (SUB-TYPE-SPEC-OF? OTYPE SGT-WALK-OUTPUT-STREAM) 1))
      (CL:SETQ OTREE (WALK-A-TREE (LIST* SYM-WALK-NATIVE-STREAM OTREE NIL))))
     (FIRST-SETTER TREE SYM-WALK-PRINT-NATIVE-STREAM)
     (SECOND-SETTER TREE OTREE)))
   (CL:LET*
    ((IT
      (ALLOCATE-ITERATOR (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? IT) 1)
     DO
     (CL:MULTIPLE-VALUE-SETQ
      (OTREE OTYPE)
      (WALK-EXPRESSION-TREE
       (CLSYS-SVAL CONS-ITERATOR VALUE IT)
       SGT-WALK-UNKNOWN
       OPERATOR
       FALSE))
     (VALUE-SETTER IT OTREE)
     (CL:WHEN
      (CL:NOT (CL:EQ OTREE SYM-WALK-EOL))
      (CL:LET*
       ((OTREE-001 OTREE))
       (CL:COND
        ((CL:EQ (STRING? OTREE) 1)
         (CL:LET* ((OTREE NULL)) (CL:SETQ OTREE OTREE-001) NULL))
        ((CL:EQ (INTEGER? OTREE) 1)
         (CL:LET*
          ((OTREE NULL))
          (CL:SETQ OTREE OTREE-001)
          (VALUE-SETTER IT (WRAP-LITERAL (STRINGIFY OTREE)))))
        ((CL:EQ (FLOAT? OTREE) 1)
         (CL:LET*
          ((OTREE NULL))
          (CL:SETQ OTREE OTREE-001)
          (VALUE-SETTER IT (WRAP-LITERAL (STRINGIFY OTREE)))))
        ((CL:EQ (CHARACTER? OTREE) 1)
         (CL:LET*
          ((OTREE NULL))
          (CL:SETQ OTREE OTREE-001)
          (VALUE-SETTER
           IT
           (WRAP-LITERAL
            (MAKE-STRING
             1
             (CLSYS-SVAL CHARACTER-WRAPPER WRAPPER-VALUE OTREE))))))
        (CL:T (VALUE-SETTER IT (SYS-TREE OTREE OTYPE))))))))
   (CL:RETURN-FROM WALK-PRINT-STREAM-TREE (CL:VALUES TREE SGT-WALK-VOID)))
  :VOID)

;;; (DEFUN (WARN-ABOUT-UNDEFINED-METHODS? BOOLEAN) ...)

(CL:DEFUN WARN-ABOUT-UNDEFINED-METHODS? ()
  (CL:RETURN-FROM
   WARN-ABOUT-UNDEFINED-METHODS?
   (MEMBER?
    *CURRENT-ENVIRONMENT-FEATURES*
    KWD-WALK-WARN-ABOUT-UNDEFINED-METHODS))
  :VOID)

;;; (DEFUN (WARN-ABOUT-MISSING-METHODS? BOOLEAN) ...)

(CL:DEFUN WARN-ABOUT-MISSING-METHODS? ()
  (CL:RETURN-FROM
   WARN-ABOUT-MISSING-METHODS?
   (CL:IF
    (CL:OR
     (CL:NOT (CL:EQ (TRANSLATOR-OUTPUT-LANGUAGE) KWD-WALK-COMMON-LISP))
     (CL:EQ
      (MEMBER?
       *CURRENT-ENVIRONMENT-FEATURES*
       KWD-WALK-WARN-ABOUT-MISSING-METHODS)
      1))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (WALK-UNDEFINED-SLOT-TREE CONS TYPE) ...)

(CL:DEFUN WALK-UNDEFINED-SLOT-TREE (TREE FIRSTARGTYPE WARN?)
  (CL:LET*
   ((CURSOR (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
    (TYPE (TYPE-SPEC-TO-BASE-TYPE FIRSTARGTYPE))
    (OPERATORNAME (FIRST TREE)))
   (FREE-TRANSIENT-TYPE-SPEC FIRSTARGTYPE)
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:SETF
     (CLSYS-SVAL CONS VALUE CURSOR)
     (WALK-EXPRESSION-TREE
      (CLSYS-SVAL CONS VALUE CURSOR)
      NULL
      OPERATORNAME
      TRUE))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (CL:WHEN
    (CL:AND (CL:EQ WARN? 1) (CL:EQ (SYMBOL-COMMON-LISP? OPERATORNAME) 0))
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING
        " Reference to undefined method or function named `"
        %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE OPERATORNAME) %%STREAM)
       (CL:WRITE-STRING "'" %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING "   in the expression:" %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING "   `" %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))))
   (CL:RETURN-FROM
    WALK-UNDEFINED-SLOT-TREE
    (CL:VALUES
     (LIST* SYM-WALK-SYS-CALL-METHOD TYPE (CONCATENATE TREE NIL))
     SGT-WALK-UNKNOWN)))
  :VOID)

;;; (DEFUN (WALK-SLOT-ON-ABSTRACT-TYPE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SLOT-ON-ABSTRACT-TYPE-TREE (TREE ABSTRACTTYPE)
  (CL:LET*
   ((METHODNAME (FIRST TREE))
    (PROTOTYPEMETHOD (FIND-PROTOTYPE-METHOD METHODNAME ABSTRACTTYPE))
    (UNDEFINEDMETHOD? TRUE)
    (OTREE NULL)
    (OTYPE NULL))
   (CL:WHEN
    (CL:NOT (CL:EQ PROTOTYPEMETHOD NULL))
    (CL:SETQ UNDEFINEDMETHOD? FALSE)
    (CL:WHEN
     (CL:EQ (WARN-ABOUT-MISSING-METHODS?) 1)
     (CL:LET*
      ((NOFSUBS NULL-INTEGER) (NOFMETHODS NULL-INTEGER) (COMPATIBLE? FALSE))
      (CL:MULTIPLE-VALUE-SETQ
       (NOFSUBS NOFMETHODS COMPATIBLE?)
       (COMPATIBLE-REAL-METHODS PROTOTYPEMETHOD ABSTRACTTYPE))
      (CL:COND
       ((CL:AND (CL:= NOFSUBS NOFMETHODS) (CL:EQ COMPATIBLE? 1))
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-WARNING)
         (CL:WHEN
          (CL:EQ (SUPPRESS-WARNINGS?) 0)
          (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING " Inferred the method `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE METHODNAME) %%STREAM)
           (CL:WRITE-STRING "' on the abstract" %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING "   type `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE ABSTRACTTYPE) %%STREAM)
           (CL:WRITE-STRING "', since `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE METHODNAME) %%STREAM)
           (CL:WRITE-STRING "' is implemented" %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING "   on all non-abstract subtypes of `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE ABSTRACTTYPE) %%STREAM)
           (CL:WRITE-STRING "'." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))))
        (SECOND-SETTER
         TREE
         (SYS-TREE
          (SECOND TREE)
          (CLSYS-SVAL METHOD-SLOT SLOT-OWNER PROTOTYPEMETHOD)))
        (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE) (WALK-CALL-SLOT-TREE TREE)))
       ((CL:= NOFSUBS NOFMETHODS)
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-WARNING)
         (CL:WHEN
          (CL:EQ (SUPPRESS-WARNINGS?) 0)
          (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING " Could not infer `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE METHODNAME) %%STREAM)
           (CL:WRITE-STRING "' on abstract type `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE ABSTRACTTYPE) %%STREAM)
           (CL:WRITE-STRING "'," %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING "   since the implementations of `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE METHODNAME) %%STREAM)
           (CL:WRITE-STRING "' on the non-abstract" %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING "   subtypes of `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE ABSTRACTTYPE) %%STREAM)
           (CL:WRITE-STRING "' are not all compatible." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)))))
       (CL:T
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-WARNING)
         (CL:WHEN
          (CL:EQ (SUPPRESS-WARNINGS?) 0)
          (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING " Could not infer `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE METHODNAME) %%STREAM)
           (CL:WRITE-STRING "' on abstract type `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE ABSTRACTTYPE) %%STREAM)
           (CL:WRITE-STRING "'," %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING "   since `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE METHODNAME) %%STREAM)
           (CL:WRITE-STRING "' is only implemented on `" %%STREAM)
           (PRINT-OBJECT
            (DE-UGLIFY-PARSE-TREE (WRAP-LITERAL NOFMETHODS))
            %%STREAM)
           (CL:WRITE-STRING "' of the `" %%STREAM)
           (PRINT-OBJECT
            (DE-UGLIFY-PARSE-TREE (WRAP-LITERAL NOFSUBS))
            %%STREAM)
           (CL:WRITE-STRING "'" %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING "   non-abstract subtypes of `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE ABSTRACTTYPE) %%STREAM)
           (CL:WRITE-STRING "'." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))))
        (CL:WHEN
         (CL:EQ COMPATIBLE? 0)
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:WRITE-STRING
           " Additionally, the method signatures are not compatible."
           %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))))))))
   (CL:IF
    (CL:EQ UNDEFINEDMETHOD? 1)
    (CL:MULTIPLE-VALUE-SETQ
     (OTREE OTYPE)
     (WALK-UNDEFINED-SLOT-TREE
      TREE
      ABSTRACTTYPE
      (WARN-ABOUT-UNDEFINED-METHODS?)))
    (CL:MULTIPLE-VALUE-SETQ
     (OTREE OTYPE)
     (WALK-UNDEFINED-SLOT-TREE TREE ABSTRACTTYPE FALSE)))
   (CL:RETURN-FROM WALK-SLOT-ON-ABSTRACT-TYPE-TREE (CL:VALUES OTREE OTYPE)))
  :VOID)

;;; (DEFUN (FIND-PROTOTYPE-METHOD METHOD-SLOT) ...)

(CL:DEFUN FIND-PROTOTYPE-METHOD (METHODNAME ABSTRACTTYPE)
  (CL:LET*
   ((METHOD NULL))
   (CL:LET*
    ((SUB NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL
        CLASS
        CLASS-DIRECT-SUBS
        (CLSYS-SVAL SURROGATE SURROGATE-VALUE ABSTRACTTYPE)))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUB (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUB) NULL))
      (CL:IF
       (CL:EQ
        (CLSYS-SVAL
         CLASS
         ABSTRACT?
         (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUB))
        1)
       (CL:SETQ METHOD (FIND-PROTOTYPE-METHOD METHODNAME SUB))
       (CL:SETQ
        METHOD
        (SAFE-LOOKUP-SLOT
         (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUB)
         METHODNAME)))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ METHOD NULL)) (CL:EQ (STORAGE-SLOT? METHOD) 0))
       (CL:RETURN-FROM FIND-PROTOTYPE-METHOD METHOD)))))
   (CL:RETURN-FROM FIND-PROTOTYPE-METHOD NULL))
  :VOID)

;;; (DEFUN (COMPATIBLE-REAL-METHODS INTEGER INTEGER BOOLEAN) ...)

(CL:DEFUN COMPATIBLE-REAL-METHODS (PROTOTYPEMETHOD ABSTRACTTYPE)
  (CL:LET*
   ((METHODNAME (CLSYS-SVAL METHOD-SLOT SLOT-NAME PROTOTYPEMETHOD))
    (NOFREALSUBTYPES 0)
    (NOFREALMETHODS 0)
    (COMPATIBLESIGNATURES? TRUE))
   (CL:LET*
    ((SUB NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL
        CLASS
        CLASS-DIRECT-SUBS
        (CLSYS-SVAL SURROGATE SURROGATE-VALUE ABSTRACTTYPE)))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUB (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:EQ
       (CLSYS-SVAL CLASS ABSTRACT? (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUB))
       1)
      (CL:LET*
       ((NOFSUBS NULL-INTEGER) (NOFMETHODS NULL-INTEGER) (COMPATIBLE? FALSE))
       (CL:MULTIPLE-VALUE-SETQ
        (NOFSUBS NOFMETHODS COMPATIBLE?)
        (COMPATIBLE-REAL-METHODS PROTOTYPEMETHOD SUB))
       (CL:SETQ NOFREALSUBTYPES (CL:+ NOFREALSUBTYPES NOFSUBS))
       (CL:SETQ NOFREALMETHODS (CL:+ NOFREALMETHODS NOFMETHODS))
       (CL:WHEN (CL:EQ COMPATIBLE? 0) (CL:SETQ COMPATIBLESIGNATURES? FALSE)))
      (CL:LET*
       ((THISMETHOD NULL))
       (CL:SETQ NOFREALSUBTYPES (CL:1+ NOFREALSUBTYPES))
       (CL:SETQ
        THISMETHOD
        (SAFE-LOOKUP-SLOT
         (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUB)
         METHODNAME))
       (CL:WHEN
        (CL:AND
         (CL:NOT (CL:EQ THISMETHOD NULL))
         (CL:EQ (STORAGE-SLOT? THISMETHOD) 0))
        (CL:SETQ NOFREALMETHODS (CL:1+ NOFREALMETHODS))
        (CL:WHEN
         (CL:EQ (IDENTICAL-SIGNATURES? PROTOTYPEMETHOD THISMETHOD) 0)
         (CL:SETQ COMPATIBLESIGNATURES? FALSE)))))))
   (CL:RETURN-FROM
    COMPATIBLE-REAL-METHODS
    (CL:VALUES NOFREALSUBTYPES NOFREALMETHODS COMPATIBLESIGNATURES?)))
  :VOID)

;;; (DEFMETHOD (FINISH-WALKING-CALL-SLOT-TREE CONS TYPE-SPEC) ...)

(CL:DEFMETHOD FINISH-WALKING-CALL-SLOT-TREE ((SELF SLOT) TREE FIRSTARGTYPE)
  (CL:PROGN (CL:SETQ TREE TREE) (CL:SETQ FIRSTARGTYPE FIRSTARGTYPE))
  (CL:ERROR "finish-walking-call-slot-tree: Not defined on `~A'" SELF)
  (CL:RETURN-FROM FINISH-WALKING-CALL-SLOT-TREE (CL:VALUES NULL NULL))
  :VOID)

;;; (DEFMETHOD (FINISH-WALKING-CALL-SLOT-TREE CONS TYPE-SPEC) ...)

(CL:DEFMETHOD FINISH-WALKING-CALL-SLOT-TREE ((SELF STORAGE-SLOT) TREE FIRSTARGTYPE)
  (CL:LET*
   ((OBJECTREF (SECOND TREE))
    (OTYPE (COMPUTE-RETURN-TYPE-SPEC SELF FIRSTARGTYPE)))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ (READER SELF) NULL))
     (CL:NOT
      (CL:EQ
       (SAFE-LOOKUP-SLOT (TYPE-SPEC-TO-CLASS FIRSTARGTYPE) (READER SELF))
       NULL)))
    (FREE-TRANSIENT-TYPE-SPEC FIRSTARGTYPE)
    (FIRST-SETTER TREE (READER SELF))
    (CL:RETURN-FROM FINISH-WALKING-CALL-SLOT-TREE (WALK-A-CONS-TREE TREE)))
   (FREE-CONS-LIST TREE)
   (CL:IF
    (CL:EQ (SYSTEM-DEFINED-SLOT-READER? SELF) 1)
    (CL:RETURN-FROM
     FINISH-WALKING-CALL-SLOT-TREE
     (CL:VALUES
      (LIST*
       SYM-WALK-SYS-CALL-METHOD
       (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SELF)
       (CONS (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SELF) (CONS OBJECTREF NIL)))
      OTYPE))
    (CL:RETURN-FROM
     FINISH-WALKING-CALL-SLOT-TREE
     (CL:VALUES
      (YIELD-SLOT-VALUE-TREE SELF OBJECTREF FIRSTARGTYPE OTYPE NULL)
      OTYPE))))
  :VOID)

;;; (DEFUN (YIELD-LISTIFIED-VARIABLE-ARGUMENTS CONS) ...)

(CL:DEFUN YIELD-LISTIFIED-VARIABLE-ARGUMENTS (WALKEDARGS TARGETTYPE WRAPARGS?)
  (CL:IF
   (CL:NOT (CL:EQ WALKEDARGS NIL))
   (CL:LET*
    ((LISTIFIEDARGS SYM-WALK-NIL))
    (CL:LET*
     ((IT (ALLOCATE-ITERATOR WALKEDARGS)))
     (CL:LOOP
      WHILE
      (CL:EQ (NEXT? IT) 1)
      DO
      (CL:LET*
       ((ARG (CLSYS-SVAL CONS-ITERATOR VALUE IT)))
       (CL:SETQ ARG (SYS-TREE ARG TARGETTYPE))
       (CL:WHEN
        (CL:EQ WRAPARGS? 1)
        (CL:SETQ
         ARG
         (CONS
          (CL:IF
           (CL:EQ TARGETTYPE SGT-WALK-BOOLEAN)
           SYM-WALK-WRAP-BOOLEAN
           SYM-WALK-WRAP-LITERAL)
          (CONS ARG NIL))))
       (VALUE-SETTER IT ARG))))
    (CL:LET*
     ((TEST-VALUE-001 (TRANSLATOR-OUTPUT-LANGUAGE)))
     (CL:COND
      ((CL:EQ TEST-VALUE-001 KWD-WALK-JAVA)
       (CL:LET*
        ((ARG NULL) (ITER-001 (REVERSE WALKEDARGS)))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-001 NIL))
         DO
         (CL:PROGN
          (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-001))
          (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
         (CL:SETQ
          LISTIFIEDARGS
          (LIST* SYM-WALK-CONS ARG (CONS LISTIFIEDARGS NIL))))))
      (CL:T
       (CL:SETQ
        LISTIFIEDARGS
        (LIST*
         SYM-WALK-CONS-LIST
         (CLSYS-SVAL CONS VALUE WALKEDARGS)
         (CONCATENATE (CLSYS-SVAL CONS REST WALKEDARGS) NIL))))))
    (CL:RETURN-FROM
     YIELD-LISTIFIED-VARIABLE-ARGUMENTS
     (WALK-WITHOUT-TYPE-TREE LISTIFIEDARGS)))
   (CL:RETURN-FROM YIELD-LISTIFIED-VARIABLE-ARGUMENTS (CONS SYM-WALK-NIL NIL)))
  :VOID)

;;; (DEFUN (WALK-VARIABLE-ARGUMENTS CONS) ...)

(CL:DEFUN WALK-VARIABLE-ARGUMENTS (ARGUMENTS METHOD)
  (TOGGLE-VARIABLE-ARGUMENTS-TYPE METHOD)
  (CL:LET*
   ((TARGETTYPE (VARIABLE-ARGUMENTS-TYPE METHOD))
    (LISTIFYARGS? (PASS-VARIABLE-ARGUMENTS-AS-LIST? METHOD))
    (WRAPARGS?
     (CL:IF
      (CL:AND
       (CL:EQ LISTIFYARGS? 1)
       (CL:EQ (SUB-TYPE-SPEC-OF? TARGETTYPE SGT-WALK-LITERAL) 1))
      TRUE
      FALSE))
    (CURSOR ARGUMENTS))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:SETF
     (CLSYS-SVAL CONS VALUE CURSOR)
     (WALK-EXPRESSION-TREE
      (CLSYS-SVAL CONS VALUE CURSOR)
      TARGETTYPE
      (CLSYS-SVAL METHOD-SLOT SLOT-NAME METHOD)
      FALSE))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (CL:WHEN
    (CL:EQ LISTIFYARGS? 1)
    (CL:LET*
     ((LISTIFIEDARGS
       (YIELD-LISTIFIED-VARIABLE-ARGUMENTS ARGUMENTS TARGETTYPE WRAPARGS?)))
     (CL:WHEN
      (CL:EQ ARGUMENTS NIL)
      (CL:RETURN-FROM WALK-VARIABLE-ARGUMENTS LISTIFIEDARGS))
     (CL:SETF (CLSYS-SVAL CONS VALUE ARGUMENTS) LISTIFIEDARGS)
     (CL:SETF (CLSYS-SVAL CONS REST ARGUMENTS) NIL)))
   (CL:RETURN-FROM WALK-VARIABLE-ARGUMENTS ARGUMENTS))
  :VOID)

;;; (DEFMETHOD (FINISH-WALKING-CALL-SLOT-TREE CONS TYPE-SPEC) ...)

(CL:DEFMETHOD FINISH-WALKING-CALL-SLOT-TREE ((SELF METHOD-SLOT) TREE FIRSTARGTYPE)
  (CL:LET*
   ((METHODNAME (CLSYS-SVAL METHOD-SLOT SLOT-NAME SELF))
    (OTYPESPEC (COMPUTE-RETURN-TYPE-SPEC SELF FIRSTARGTYPE))
    (OTREE NULL))
   (CL:LET*
    ((PTYPESPECS (METHOD-PARAMETER-TYPE-SPECIFIERS SELF))
     (NOFPARAMETERS (LENGTH PTYPESPECS))
     (CURSOR (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))
    (CL:LET*
     ((PINDEX NULL)
      (TARGETTS NULL)
      (ITER-001 (REST PTYPESPECS))
      (ITER-002 2)
      (UPPER-BOUND-001 NOFPARAMETERS)
      (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
     (CL:LOOP
      WHILE
      (CL:AND
       (CL:NOT (CL:EQ ITER-001 NIL))
       (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-002 UPPER-BOUND-001)))
      DO
      (CL:PROGN
       (CL:SETQ TARGETTS (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:PROGN (CL:SETQ PINDEX ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
      (CL:SETQ TARGETTS (COMPUTE-RELATIVE-TYPE-SPEC TARGETTS FIRSTARGTYPE))
      (CL:WHEN
       (CL:AND
        (CL:= PINDEX NOFPARAMETERS)
        (CL:EQ (METHOD-VARIABLE-ARGUMENTS? SELF) 1))
       (NTH-REST-SETTER TREE (WALK-VARIABLE-ARGUMENTS CURSOR SELF) PINDEX)
       (CL:RETURN))
      (CL:SETF
       (CLSYS-SVAL CONS VALUE CURSOR)
       (WALK-EXPRESSION-TREE
        (CLSYS-SVAL CONS VALUE CURSOR)
        TARGETTS
        METHODNAME
        TRUE))
      (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))))
   (FREE-TRANSIENT-TYPE-SPEC FIRSTARGTYPE)
   (CL:LET*
    ((ARG NULL) (ITER-003 (CLSYS-SVAL CONS REST TREE)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-003 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-003))
      (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
     (CL:WHEN
      (CL:EQ (VRLET-EXPRESSION? ARG) 1)
      (CL:RETURN-FROM
       FINISH-WALKING-CALL-SLOT-TREE
       (PERCOLATE-OUT-VRLET-EXPRESSION TREE ARG OTYPESPEC)))))
   (CL:IF
    (CL:EQ (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? SELF) 1)
    (CL:SETQ OTREE (CONS SYM-WALK-SYS-CALL-FUNCTION (CONCATENATE TREE NIL)))
    (CL:SETQ
     OTREE
     (LIST*
      SYM-WALK-SYS-CALL-METHOD
      (CLSYS-SVAL METHOD-SLOT SLOT-OWNER SELF)
      (CONCATENATE TREE NIL))))
   (CL:WHEN
    (CL:EQ (PROCEDURAL-EXPRESSION? (FIFTH TREE)) 1)
    (CL:LET*
     ((OUTGOINGTYPESPEC OTYPESPEC))
     (CL:MULTIPLE-VALUE-SETQ
      (OTREE OTYPESPEC)
      (TRANSFORM-PROCEDURAL-EXPRESSION OTREE (FIFTH TREE) OUTGOINGTYPESPEC))
     (FREE-TRANSIENT-TYPE-SPEC OUTGOINGTYPESPEC)))
   (CL:RETURN-FROM FINISH-WALKING-CALL-SLOT-TREE (CL:VALUES OTREE OTYPESPEC)))
  :VOID)

;;; (DEFUN (QUOTE-ARGUMENTS CONS) ...)

(CL:DEFUN QUOTE-ARGUMENTS (METHOD ARGUMENTS)
  (CL:LET*
   ((PTYPESPECS (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))
    (LASTPARAMETERINDEX (CL:1- (LENGTH PTYPESPECS)))
    (VARARGSTYPE
     (CL:IF
      (CL:EQ (METHOD-VARIABLE-ARGUMENTS? METHOD) 1)
      (VARIABLE-ARGUMENTS-TYPE METHOD)
      NULL))
    (PTYPE NULL))
   (CL:LET*
    ((ARGINDEX NULL) (IT (ALLOCATE-ITERATOR ARGUMENTS)) (ITER-001 0))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? IT) 1)
     DO
     (CL:PROGN
      (CL:SETQ ARGINDEX ITER-001)
      (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:TAGBODY
      (CL:WHEN
       (CL:NOT
        (CL:OR
         (CL:EQ (SURROGATE? (CLSYS-SVAL CONS-ITERATOR VALUE IT)) 1)
         (CL:EQ (KEYWORD? (CLSYS-SVAL CONS-ITERATOR VALUE IT)) 1)))
       (CL:IF
        (CL:AND
         (CL:>= ARGINDEX LASTPARAMETERINDEX)
         (CL:NOT (CL:EQ VARARGSTYPE NULL)))
        (CL:SETQ PTYPE VARARGSTYPE)
        (CL:SETQ PTYPE (NTH PTYPESPECS ARGINDEX)))
       (CL:WHEN
        (CL:OR
         (CL:EQ (CLSYS-SVAL CONS-ITERATOR VALUE IT) SYM-WALK-NULL)
         (CL:AND
          (CL:EQ PTYPE SGT-WALK-BOOLEAN)
          (CL:OR
           (CL:EQ (CLSYS-SVAL CONS-ITERATOR VALUE IT) SYM-WALK-TRUE)
           (CL:EQ (CLSYS-SVAL CONS-ITERATOR VALUE IT) SYM-WALK-FALSE)))
         (CL:AND
          (CL:EQ (WRAPPER? (CLSYS-SVAL CONS-ITERATOR VALUE IT)) 1)
          (CL:NOT (CL:EQ PTYPE NULL))
          (CL:EQ (SUB-TYPE-SPEC-OF? PTYPE SGT-WALK-LITERAL) 1)))
        (CL:GO :CONTINUE))
       (VALUE-SETTER
        IT
        (LIST* SYM-WALK-BQUOTE (CLSYS-SVAL CONS-ITERATOR VALUE IT) NIL)))
      :CONTINUE)))
   (CL:RETURN-FROM QUOTE-ARGUMENTS ARGUMENTS))
  :VOID)

;;; (DEFUN (WALK-FIRST-ARGUMENT-TO-FUNCTION TYPE-SPEC) ...)

(CL:DEFUN WALK-FIRST-ARGUMENT-TO-FUNCTION (FNSLOT TREE)
  (CL:LET*
   ((PTYPESPECS (METHOD-PARAMETER-TYPE-SPECIFIERS FNSLOT))
    (TARGETTS (FIRST PTYPESPECS)))
   (CL:WHEN
    (CL:EQ (METHOD-EVALUATE-ARGUMENTS? FNSLOT) 0)
    (CL:SETF
     (CLSYS-SVAL CONS REST TREE)
     (QUOTE-ARGUMENTS FNSLOT (CLSYS-SVAL CONS REST TREE))))
   (CL:WHEN
    (CL:AND
     (CL:EQ (METHOD-VARIABLE-ARGUMENTS? FNSLOT) 1)
     (CL:= (LENGTH PTYPESPECS) 1))
    (CL:SETF
     (CLSYS-SVAL CONS REST TREE)
     (WALK-VARIABLE-ARGUMENTS (CLSYS-SVAL CONS REST TREE) FNSLOT))
    (CL:RETURN-FROM WALK-FIRST-ARGUMENT-TO-FUNCTION SGT-WALK-UNKNOWN))
   (CL:WHEN
    (CL:OR
     (CL:EQ (CLSYS-SVAL CONS REST TREE) NIL)
     (CL:EQ (EMPTY? (METHOD-PARAMETER-TYPE-SPECIFIERS FNSLOT)) 1))
    (CL:RETURN-FROM WALK-FIRST-ARGUMENT-TO-FUNCTION SGT-WALK-UNKNOWN))
   (CL:LET*
    ((OTREE NULL) (OTYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (OTREE OTYPE)
     (WALK-EXPRESSION-TREE
      (SECOND TREE)
      TARGETTS
      (CLSYS-SVAL METHOD-SLOT SLOT-NAME FNSLOT)
      TRUE))
    (SECOND-SETTER TREE OTREE)
    (CL:LET*
     ((OTREE-001 OTREE))
     (CL:COND
      ((CL:EQ (INTEGER? OTREE) 1)
       (CL:LET*
        ((OTREE NULL))
        (CL:SETQ OTREE OTREE-001)
        (CL:LET*
         ((TEST-VALUE-001 (CLSYS-SVAL METHOD-SLOT SLOT-NAME FNSLOT)))
         (CL:COND
          ((CL:EQ TEST-VALUE-001 SYM-WALK-GET-SYM)
           (REGISTER-SYMBOL
            (GET-SYM-FROM-OFFSET
             (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE OTREE))))
          ((CL:EQ TEST-VALUE-001 SYM-WALK-GET-SGT)
           (REGISTER-SYMBOL
            (GET-SGT-FROM-OFFSET
             (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE OTREE))))
          ((CL:EQ TEST-VALUE-001 SYM-WALK-GET-KWD)
           (REGISTER-SYMBOL
            (GET-KWD-FROM-OFFSET
             (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE OTREE))))
          (CL:T NULL)))))
      (CL:T NULL)))
    (CL:RETURN-FROM WALK-FIRST-ARGUMENT-TO-FUNCTION OTYPE)))
  :VOID)

;;; (DEFUN (WALK-CALL-SLOT-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-CALL-SLOT-TREE (TREE)
  (CL:LET*
   ((SLOTNAME (FIRST TREE))
    (WALKEDFIRSTARG NULL)
    (FIRSTARGTYPE SGT-WALK-VOID)
    (FIRSTARGCLASS NULL)
    (ILLEGALFIRSTARG? FALSE)
    (PREVIOUSERRORS *TRANSLATIONERRORS*)
    (SLOT NULL))
   (CL:WHEN
    (CL:NOT (CL:EQ (LOOKUP-MACRO SLOTNAME) NULL))
    (CL:RETURN-FROM WALK-CALL-SLOT-TREE (WALK-MACRO-TREE TREE)))
   (CL:LET*
    ()
    (CL:SETQ SLOT (LOOKUP-FUNCTION-OR-STELLA-FUNCTION SLOTNAME))
    (CL:IF
     (CL:NOT (CL:EQ SLOT NULL))
     (CL:SETQ FIRSTARGTYPE (WALK-FIRST-ARGUMENT-TO-FUNCTION SLOT TREE))
     (CL:WHEN
      (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST TREE) NIL))
      (CL:MULTIPLE-VALUE-SETQ
       (WALKEDFIRSTARG FIRSTARGTYPE)
       (WALK-A-TREE (SECOND TREE)))
      (SECOND-SETTER
       TREE
       (COERCE-A-TREE WALKEDFIRSTARG FIRSTARGTYPE FIRSTARGTYPE))
      (CL:WHEN
       (CL:EQ (VOID? FIRSTARGTYPE) 1)
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN
         (CL:EQ (SUPPRESS-WARNINGS?) 0)
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:WRITE-STRING " First argument in call to `" %%STREAM)
          (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE SLOTNAME) %%STREAM)
          (CL:WRITE-STRING "' returns @VOID." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))))
       (CL:RETURN-FROM
        WALK-CALL-SLOT-TREE
        (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-UNKNOWN)))
      (CL:SETQ FIRSTARGCLASS (TYPE-SPEC-TO-CLASS FIRSTARGTYPE))
      (CL:SETQ SLOT (SAFE-LOOKUP-SLOT FIRSTARGCLASS SLOTNAME)))))
   (CL:SETQ ILLEGALFIRSTARG? (> *TRANSLATIONERRORS* PREVIOUSERRORS))
   (CL:WHEN
    (CL:EQ (VRLET-EXPRESSION? (SECOND TREE)) 1)
    (CL:RETURN-FROM
     WALK-CALL-SLOT-TREE
     (PERCOLATE-OUT-VRLET-EXPRESSION TREE (SECOND TREE) SGT-WALK-UNKNOWN)))
   (CL:WHEN
    (CL:EQ SLOT NULL)
    (CL:IF
     (CL:AND
      (CL:EQ (WARN-ABOUT-UNDEFINED-METHODS?) 1)
      (CL:NOT (CL:EQ FIRSTARGTYPE SGT-WALK-UNKNOWN))
      (CL:NOT (CL:EQ FIRSTARGCLASS NULL))
      (CL:EQ (CLSYS-SVAL CLASS ABSTRACT? FIRSTARGCLASS) 1))
     (CL:RETURN-FROM
      WALK-CALL-SLOT-TREE
      (WALK-SLOT-ON-ABSTRACT-TYPE-TREE
       TREE
       (TYPE-SPEC-TO-BASE-TYPE FIRSTARGTYPE)))
     (CL:RETURN-FROM
      WALK-CALL-SLOT-TREE
      (WALK-UNDEFINED-SLOT-TREE
       TREE
       (CL:IF (CL:EQ (VOID? FIRSTARGTYPE) 1) SGT-WALK-UNKNOWN FIRSTARGTYPE)
       (CL:IF
        (CL:AND
         (CL:EQ ILLEGALFIRSTARG? 0)
         (CL:EQ (WARN-ABOUT-UNDEFINED-METHODS?) 1))
        TRUE
        FALSE)))))
   (CL:LET*
    ((MINARGS (METHOD-ARGUMENT-COUNT SLOT)) (MAXARGS MINARGS))
    (CL:LET*
     ((SLOT-001 SLOT))
     (CL:COND
      ((CL:EQ (METHOD-SLOT? SLOT) 1)
       (CL:LET*
        ((SLOT NULL))
        (CL:SETQ SLOT SLOT-001)
        (CL:WHEN
         (CL:OR
          (CL:EQ (METHOD-VARIABLE-ARGUMENTS? SLOT) 1)
          (CL:EQ (METHOD-BODY-ARGUMENT? SLOT) 1))
         (CL:SETQ MINARGS (CL:1- MINARGS))
         (CL:SETQ MAXARGS NULL-INTEGER))))
      (CL:T NULL)))
    (CL:WHEN
     (CL:EQ (BAD-ARGUMENT-RANGE? TREE MINARGS MAXARGS) 1)
     (CL:RETURN-FROM
      WALK-CALL-SLOT-TREE
      (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-UNKNOWN))))
   (CL:LET*
    ((OTREE NULL) (OTYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (OTREE OTYPE)
     (FINISH-WALKING-CALL-SLOT-TREE SLOT TREE FIRSTARGTYPE))
    (CL:RETURN-FROM
     WALK-CALL-SLOT-TREE
     (SYS-TREE-IF-NEEDED SLOT OTREE FIRSTARGTYPE OTYPE))))
  :VOID)

;;; (DEFUN (YIELD-SYNTHESIZED-METHOD-BODY CONS) ...)

(CL:DEFUN YIELD-SYNTHESIZED-METHOD-BODY (UNIT)
  (CL:LET*
   ((METHOD (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT))
    (BODY (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT)))
   (CL:WHEN
    (CL:EQ (METHOD-PARAMETER-NAMES METHOD) NULL)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING
        " Missing parameters for :inherits-through method."
        %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))))
   (CL:COND
    ((CL:NOT (CL:EQ BODY NIL))
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING
         " Over-specified definition of :inherits-through method."
         %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     (CL:RETURN-FROM YIELD-SYNTHESIZED-METHOD-BODY BODY))
    (CL:T
     (CL:RETURN-FROM
      YIELD-SYNTHESIZED-METHOD-BODY
      (SYNTHESIZE-METHOD-BODY METHOD)))))
  :VOID)

;;; (DEFUN (PASS-VARIABLE-ARGUMENTS-AS-LIST? BOOLEAN) ...)

(CL:DEFUN PASS-VARIABLE-ARGUMENTS-AS-LIST? (METHOD)
  (CL:RETURN-FROM
   PASS-VARIABLE-ARGUMENTS-AS-LIST?
   (CL:IF
    (CL:OR
     (CL:EQ (METHOD-MUST-BE-EVALUABLE? METHOD) 1)
     (CL:EQ (TRANSLATOR-OUTPUT-LANGUAGE) KWD-WALK-JAVA))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN TOGGLE-VARIABLE-ARGUMENTS-TYPE ...)

(CL:DEFUN TOGGLE-VARIABLE-ARGUMENTS-TYPE (METHOD)
  (CL:LET*
   ((RVTYPE (LAST (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD)))
    (BASETYPE
     (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE RVTYPE))
    (PARAMETERTYPES
     (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-PARAMETER-TYPES RVTYPE))
    (LISTIFY? (PASS-VARIABLE-ARGUMENTS-AS-LIST? METHOD)))
   (CL:COND
    ((CL:EQ BASETYPE SGT-WALK-ARGUMENT-LIST)
     (CL:WHEN
      (CL:EQ LISTIFY? 1)
      (CL:SETF
       (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE RVTYPE)
       SGT-WALK-CONS)
      (CL:WHEN
       (CL:EQ (SUB-TYPE-SPEC-OF? (FIRST PARAMETERTYPES) SGT-WALK-LITERAL) 1)
       (PUSH
        PARAMETERTYPES
        (TYPE-TO-WRAPPED-TYPE
         (TYPE-SPEC-TO-BASE-TYPE
          (FIRST
           (CLSYS-SVAL
            PARAMETRIC-TYPE-SPECIFIER
            SPECIFIER-PARAMETER-TYPES
            RVTYPE))))))))
    ((CL:EQ BASETYPE SGT-WALK-CONS)
     (CL:WHEN
      (CL:EQ LISTIFY? 0)
      (CL:SETF
       (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE RVTYPE)
       SGT-WALK-ARGUMENT-LIST)
      (CL:WHEN (CL:= (LENGTH PARAMETERTYPES) 2) (POP PARAMETERTYPES))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" BASETYPE))))
  :VOID)

;;; (DEFUN (VARIABLE-ARGUMENTS-TYPE TYPE-SPEC) ...)

(CL:DEFUN VARIABLE-ARGUMENTS-TYPE (METHOD)
  (CL:LET*
   ((RVTYPE (LAST (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD)))
    (PARAMETERTYPES
     (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-PARAMETER-TYPES RVTYPE)))
   (CL:IF
    (CL:= (LENGTH PARAMETERTYPES) 2)
    (CL:RETURN-FROM
     VARIABLE-ARGUMENTS-TYPE
     (SECOND
      (CLSYS-SVAL
       PARAMETRIC-TYPE-SPECIFIER
       SPECIFIER-PARAMETER-TYPES
       RVTYPE)))
    (CL:RETURN-FROM
     VARIABLE-ARGUMENTS-TYPE
     (EXTRACT-PARAMETER-TYPE RVTYPE SYM-WALK-ANY-VALUE))))
  :VOID)

;;; (DEFUN (WALK-METHOD-OBJECT CONS) ...)

(CL:DEFUN WALK-METHOD-OBJECT (UNIT)
  (CL:LET*
   ((METHOD (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT))
    (BODY (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT)))
   (CL:LET*
    ((*LOCALVARIABLETYPETABLE* (NEW-KEY-VALUE-LIST))
     (*LOCALGENSYMTABLE* (NEW-KEY-VALUE-LIST))
     (*SPECIALVARIABLESTACK* (NEW-KEY-VALUE-LIST))
     (*METHODBEINGWALKED* METHOD)
     (*FOUNDRETURN?* FALSE))
    (CL:DECLARE
     (CL:SPECIAL
      *LOCALVARIABLETYPETABLE*
      *LOCALGENSYMTABLE*
      *SPECIALVARIABLESTACK*
      *METHODBEINGWALKED*
      *FOUNDRETURN?*))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE METHOD SYM-WALK-METHOD-INHERITS-THROUGH NULL)
       NULL))
     (CL:SETQ BODY (YIELD-SYNTHESIZED-METHOD-BODY UNIT)))
    (CL:LET*
     ((TYPESPEC NULL)
      (NAME NULL)
      (ITER-001
       (CLSYS-SVAL LIST THE-CONS-LIST (METHOD-PARAMETER-NAMES METHOD)))
      (ITER-002
       (CLSYS-SVAL
        LIST
        THE-CONS-LIST
        (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))))
     (CL:LOOP
      WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL)))
      DO
      (CL:PROGN
       (CL:SETQ NAME (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:PROGN
       (CL:SETQ TYPESPEC (CLSYS-SVAL CONS VALUE ITER-002))
       (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
      (WALK-A-DECLARATION NAME TYPESPEC NULL TRUE)))
    (CL:WHEN
     (CL:EQ (METHOD-VARIABLE-ARGUMENTS? METHOD) 1)
     (TOGGLE-VARIABLE-ARGUMENTS-TYPE METHOD))
    (CL:WHEN
     (CL:NOT (CL:EQ BODY NIL))
     (CL:SETQ BODY (WALK-LIST-OF-TREES BODY))
     (CL:WHEN
      (CL:AND
       (CL:EQ (VOID? (CLSYS-SVAL METHOD-SLOT SLOT-BASE-TYPE METHOD)) 0)
       (CL:EQ *FOUNDRETURN?* 0))
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN
        (CL:EQ (SUPPRESS-WARNINGS?) 0)
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING " Missing return statement." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))))))
    (FREE *LOCALVARIABLETYPETABLE*)
    (FREE *LOCALGENSYMTABLE*)
    (FREE *SPECIALVARIABLESTACK*)
    (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT) BODY)
    (CL:RETURN-FROM WALK-METHOD-OBJECT BODY)))
  :VOID)

;;; (DEFUN WALK-DEFMETHOD-TREE ...)

(CL:DEFUN WALK-DEFMETHOD-TREE (TREE)
  (CL:LET*
   ((METHOD NULL))
   (CL:LET*
    ((SELF-001 (NEW-TRANSLATION-UNIT)))
    (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF-001) SYM-WALK-METHOD)
    (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT SELF-001) TREE)
    (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-001))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* FALSE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:SETQ METHOD (DEFINE-METHOD-FROM-PARSE-TREE TREE)))
   (CL:COND
    ((CL:AND
      (CL:EQ (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? METHOD) 0)
      (CL:OR
       (CL:EQ (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD) NULL)
       (CL:EQ
        (CLSYS-SVAL
         SURROGATE
         SURROGATE-VALUE
         (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD))
        NULL)))
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " Can't define method `" %%STREAM)
        (PRINT-OBJECT (CLSYS-SVAL METHOD-SLOT SLOT-NAME METHOD) %%STREAM)
        (CL:WRITE-STRING "' on the non-existent class `" %%STREAM)
        (PRINT-OBJECT (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD) %%STREAM)
        (CL:WRITE-STRING "'." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     (FREE METHOD)
     (FREE *CURRENTTRANSLATIONUNIT*)
     (CL:SETQ *CURRENTTRANSLATIONUNIT* NULL))
    (CL:T
     (CL:SETF
      (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT *CURRENTTRANSLATIONUNIT*)
      METHOD)
     (CL:SETF
      (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER *CURRENTTRANSLATIONUNIT*)
      (NTH-REST TREE 3))
     (CL:WHEN
      (CL:EQ (METHOD-NEEDS-LISP-MACRO? METHOD) 1)
      (REGISTER-NATIVE-NAME
       (CLSYS-SVAL METHOD-SLOT SLOT-NAME METHOD)
       KWD-WALK-COMMON-LISP
       KWD-WALK-FUNCTION)))))
  :VOID)

;;; (DEFUN (YIELD-INITIALIZE-SLOT-WRITER CONS) ...)

(CL:DEFUN YIELD-INITIALIZE-SLOT-WRITER (METHOD)
  (CL:LET*
   ((SLOTNAME (CLSYS-SVAL METHOD-SLOT SLOT-NAME METHOD))
    (SLOTNAMESTRING (CLSYS-SVAL SYMBOL SYMBOL-NAME SLOTNAME))
    (SLOT NULL)
    (SETTERSTART -1))
   (CL:LOOP
    WHILE
    (CL:EQ
     (DEFINED? (STRING-SEARCH SLOTNAMESTRING "-SETTER" (CL:1+ SETTERSTART)))
     1)
    DO
    (CL:SETQ
     SETTERSTART
     (STRING-SEARCH SLOTNAMESTRING "-SETTER" (CL:1+ SETTERSTART))))
   (CL:WHEN
    (CL:> SETTERSTART 0)
    (CL:SETQ
     SLOTNAME
     (INTERN-DERIVED-SYMBOL
      SLOTNAME
      (SUBSEQUENCE SLOTNAMESTRING 0 SETTERSTART)))
    (CL:SETQ
     SLOT
     (SAFE-LOOKUP-SLOT
      (CLSYS-SVAL
       SURROGATE
       SURROGATE-VALUE
       (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD))
      SLOTNAME))
    (CL:WHEN
     (CL:AND
      (CL:EQ (STORAGE-SLOT? SLOT) 1)
      (CL:EQ
       (NULL?
        (STRING-SEARCH
         (CLSYS-SVAL
          CLASS
          CLASS-STRINGIFIED-SOURCE
          (CLSYS-SVAL
           SURROGATE
           SURROGATE-VALUE
           (CLSYS-SVAL SLOT SLOT-OWNER SLOT)))
         ":WRITER"
         0))
       1))
     (SET-DYNAMIC-SLOT-VALUE
      SLOT
      SYM-WALK-SLOT-WRITER
      (CLSYS-SVAL METHOD-SLOT SLOT-NAME METHOD)
      NULL)
     (CL:RETURN-FROM
      YIELD-INITIALIZE-SLOT-WRITER
      (CONS
       (LIST*
        SYM-WALK-SETF
        (LIST*
         SYM-WALK-SLOT-WRITER
         (LIST*
          SYM-WALK-CAST
          (LIST*
           SYM-WALK-LOOKUP-SLOT
           (LIST* SYM-WALK-TYPE-CLASS (CLSYS-SVAL SLOT SLOT-OWNER SLOT) NIL)
           (LIST* SYM-WALK-BQUOTE SLOTNAME NIL)
           NIL)
          SYM-WALK-STORAGE-SLOT
          NIL)
         NIL)
        (LIST* SYM-WALK-BQUOTE (CLSYS-SVAL METHOD-SLOT SLOT-NAME METHOD) NIL)
        NIL)
       NIL))))
   (CL:RETURN-FROM YIELD-INITIALIZE-SLOT-WRITER NIL))
  :VOID)

;;; (DEFUN WALK-METHOD-UNIT ...)

(CL:DEFUN WALK-METHOD-UNIT (UNIT)
  (CL:LET*
   ((*CURRENTTRANSLATIONUNIT* UNIT))
   (CL:DECLARE (CL:SPECIAL *CURRENTTRANSLATIONUNIT*))
   (CL:LET*
    ((METHOD (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT))
     (OWNER (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD))
     (NAME (CLSYS-SVAL METHOD-SLOT SLOT-NAME METHOD))
     (BODY (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT))
     (CREATEMETHODOBJECT? TRUE)
     (CREATEEVALUATORWRAPPER? FALSE))
    (CL:WHEN
     (CL:AND
      (CL:EQ (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? METHOD) 0)
      (CL:NOT (CL:EQ OWNER NULL))
      (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE OWNER) NULL))
      (CL:EQ
       (CLSYS-SVAL CLASS MIXIN? (CLSYS-SVAL SURROGATE SURROGATE-VALUE OWNER))
       1)
      (CL:EQ (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?) 1))
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING
         " Methods on mixin classes are currently not supported"
         %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " in single-inheritance target languages." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     (FREE UNIT)
     (CL:RETURN-FROM WALK-METHOD-UNIT))
    (CL:COND
     ((CL:AND
       (CL:EQ BODY NIL)
       (CL:EQ
        (DYNAMIC-SLOT-VALUE METHOD SYM-WALK-METHOD-INHERITS-THROUGH NULL)
        NULL))
      (WALK-METHOD-OBJECT UNIT)
      (CL:WHEN
       (CL:EQ (METHOD-NATIVE? METHOD) 0)
       (CL:SETQ CREATEMETHODOBJECT? FALSE)
       (CL:WHEN
        (CL:>= *TRANSLATIONVERBOSITYLEVEL* 3)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING "Forward declaration of `" %%STREAM)
         (PRINT-OBJECT METHOD %%STREAM)
         (CL:WRITE-STRING "'" %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))))
      (FREE UNIT))
     ((CL:OR
       (CL:EQ (METHOD-AUXILIARY? METHOD) 1)
       (CL:EQ (CLSYS-SVAL TRANSLATION-UNIT AUXILIARY? UNIT) 1))
      (CL:SETQ CREATEMETHODOBJECT? FALSE)
      (PUSH *TRANSLATIONUNITS* UNIT)
      (WALK-METHOD-OBJECT UNIT))
     (CL:T (PUSH *TRANSLATIONUNITS* UNIT) (WALK-METHOD-OBJECT UNIT)))
    (CL:WHEN
     (CL:EQ CREATEMETHODOBJECT? 1)
     (CL:WHEN
      (CL:AND (CL:EQ (METHOD-COMMAND? METHOD) 1) (CL:EQ (COMMAND? METHOD) 0))
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-WARNING)
       (CL:WHEN
        (CL:EQ (SUPPRESS-WARNINGS?) 0)
        (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING
          " Ignored :command? declaration.  Currently, only functions can be commands.."
          %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)))))
     (CL:WHEN
      (CL:EQ (METHOD-NEEDS-EVALUATOR-WRAPPER? METHOD) 1)
      (CL:SETQ CREATEEVALUATORWRAPPER? TRUE)
      (CREATE-EVALUATOR-WRAPPER-UNIT METHOD))
     (CL:WHEN
      (CL:EQ (METHOD-NEEDS-LISP-MACRO? METHOD) 1)
      (CREATE-LISP-MACRO-UNITS NAME METHOD))
     (CL:IF
      (CL:EQ (METHOD-NATIVE? METHOD) 1)
      (WALK-AUXILIARY-TREE
       (LIST*
        SYM-WALK-STARTUP-TIME-PROGN
        KWD-WALK-METHODS
        (YIELD-DEFINE-STELLA-METHOD METHOD)
        NIL))
      (WALK-AUXILIARY-TREE
       (LIST*
        SYM-WALK-STARTUP-TIME-PROGN
        KWD-WALK-METHODS
        (LIST*
         SYM-WALK-LET
         (CONS
          (LIST* SYM-WALK-METHOD (YIELD-DEFINE-STELLA-METHOD METHOD) NIL)
          NIL)
         (CL:IF
          (CL:EQ (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? METHOD) 1)
          (LIST*
           SYM-WALK-SETF
           (LIST* SYM-WALK-FUNCTION-CODE SYM-WALK-METHOD NIL)
           (LIST* SYM-WALK-THE-CODE KWD-WALK-FUNCTION NAME NIL)
           NIL)
          (LIST*
           SYM-WALK-SETF
           (LIST* SYM-WALK-METHOD-CODE SYM-WALK-METHOD NIL)
           (LIST*
            SYM-WALK-THE-CODE
            KWD-WALK-METHOD
            (CLSYS-SVAL METHOD-SLOT SLOT-OWNER METHOD)
            (CONS NAME NIL))
           NIL))
         (CONCATENATE
          (CL:IF
           (CL:EQ CREATEEVALUATORWRAPPER? 1)
           (CONS
            (LIST*
             SYM-WALK-SETF
             (LIST* SYM-WALK-EVALUATOR-WRAPPER-CODE SYM-WALK-METHOD NIL)
             (LIST*
              SYM-WALK-THE-CODE
              KWD-WALK-FUNCTION
              (YIELD-EVALUATOR-WRAPPER-NAME NAME)
              NIL)
             NIL)
            NIL)
           NIL)
          NIL))
        NIL)))
     (CL:LET*
      ((WRITERTREE (YIELD-INITIALIZE-SLOT-WRITER METHOD)))
      (CL:WHEN
       (CL:NOT (CL:EQ WRITERTREE NIL))
       (WALK-AUXILIARY-TREE
        (CONS SYM-WALK-STARTUP-TIME-PROGN (CONCATENATE WRITERTREE NIL))))))))
  :VOID)

;;; (DEFUN (WALK-SYS-CALL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SYS-CALL-TREE (TREE)
  (CL:LET*
   ((SLOT (SLOT-FROM-EXPRESSION-TREE TREE)) (SLOTTYPE SGT-WALK-UNKNOWN))
   (CL:WHEN
    (CL:NOT (CL:EQ SLOT NULL))
    (CL:SETQ
     SLOTTYPE
     (DYNAMIC-SLOT-VALUE SLOT SYM-WALK-SLOT-TYPE-SPECIFIER NULL))
    (CL:LET*
     ((TEST-VALUE-001 FALSE))
     (CL:SETQ TEST-VALUE-001 (DEFINED? SLOTTYPE))
     (CL:WHEN
      (CL:EQ TEST-VALUE-001 1)
      (CL:IF
       (CL:EQ (ANCHORED-TYPE-SPECIFIER? SLOTTYPE) 1)
       (CL:SETQ TEST-VALUE-001 TRUE)
       (CL:LET*
        ((FOUND?-001 FALSE))
        (CL:LET*
         ((TS NULL)
          (ITER-001
           (CLSYS-SVAL
            LIST
            THE-CONS-LIST
            (CLSYS-SVAL
             PARAMETRIC-TYPE-SPECIFIER
             SPECIFIER-PARAMETER-TYPES
             SLOTTYPE))))
         (CL:LOOP
          WHILE
          (CL:NOT (CL:EQ ITER-001 NIL))
          DO
          (CL:PROGN
           (CL:SETQ TS (CLSYS-SVAL CONS VALUE ITER-001))
           (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
          (CL:WHEN
           (CL:EQ (ANCHORED-TYPE-SPECIFIER? TS) 1)
           (CL:SETQ FOUND?-001 TRUE)
           (CL:RETURN))))
        (CL:SETQ TEST-VALUE-001 FOUND?-001))))
     (CL:WHEN
      (CL:EQ TEST-VALUE-001 1)
      (CL:ERROR
       "walk-sys-call-tree: OOPS, can't handle anchored slot types: `~A'"
       TREE)))
    (CL:WHEN (CL:EQ SLOTTYPE NULL) (CL:SETQ SLOTTYPE (TYPE SLOT))))
   (CL:RETURN-FROM WALK-SYS-CALL-TREE (CL:VALUES TREE SLOTTYPE)))
  :VOID)

;;; (DEFUN WALK-DEFCLASS-TREE ...)

(CL:DEFUN WALK-DEFCLASS-TREE (TREE)
  (CL:LET*
   ((SELF-001 (NEW-TRANSLATION-UNIT)))
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF-001) SYM-WALK-CLASS)
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT SELF-001) (SECOND TREE))
   (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-001))
  (CL:LET*
   ((*TRANSIENTOBJECTS?* FALSE))
   (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
   (CL:SETF
    (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT *CURRENTTRANSLATIONUNIT*)
    (DEFINE-CLASS-FROM-PARSE-TREE TREE))
   (CL:WHEN
    (CL:EQ
     (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT *CURRENTTRANSLATIONUNIT*)
     NULL)
    (FREE *CURRENTTRANSLATIONUNIT*)
    (CL:SETQ *CURRENTTRANSLATIONUNIT* NULL)))
  (FREE-PARSE-TREE TREE)
  :VOID)

;;; (DEFUN (YIELD-INITIALIZE-HARDWIRED-SLOTS CONS) ...)

(CL:DEFUN YIELD-INITIALIZE-HARDWIRED-SLOTS (CLASS)
  (CL:LET*
   ((HARDWIREDSLOTINITIALIZERS NIL))
   (CL:WHEN
    (CL:EQ (CREATE-NATIVE-CLASS? CLASS) 1)
    (CL:LET*
     ((SLOT NULL) (ITER-001 (CLASS-SLOTS CLASS)))
     (CL:LOOP
      WHILE
      (CL:EQ (NEXT? ITER-001) 1)
      DO
      (CL:PROGN (CL:SETQ SLOT (CLSYS-SVAL ITERATOR VALUE ITER-001)))
      (CL:LET*
       ((SLOT-001 SLOT))
       (CL:COND
        ((CL:EQ (STORAGE-SLOT? SLOT) 1)
         (CL:LET*
          ((SLOT NULL))
          (CL:SETQ SLOT SLOT-001)
          (CL:WHEN
           (CL:AND
            (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-HARDWIRED? SLOT) 1)
            (CL:NOT (CL:EQ (INITIAL-VALUE SLOT) NULL)))
           (CL:SETQ
            HARDWIREDSLOTINITIALIZERS
            (CONS
             (LIST*
              SYM-WALK-SETQ
              (YIELD-HARDWIRED-SLOT-VARIABLE SLOT)
              (CONS (INITIAL-VALUE SLOT) NIL))
             HARDWIREDSLOTINITIALIZERS)))))
        (CL:T NULL))))))
   (CL:RETURN-FROM YIELD-INITIALIZE-HARDWIRED-SLOTS HARDWIREDSLOTINITIALIZERS))
  :VOID)

;;; (DEFUN (YIELD-INITIAL-VALUE-EXPRESSION OBJECT) ...)

(CL:DEFUN YIELD-INITIAL-VALUE-EXPRESSION (SLOT)
  (CL:WHEN
   (CL:OR
    (CL:EQ (CLSYS-SVAL STORAGE-SLOT ABSTRACT? SLOT) 1)
    (CL:EQ (DYNAMIC-STORAGE? SLOT) 1)
    (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-HARDWIRED? SLOT) 1)
    (CL:EQ (ALLOCATION SLOT) KWD-WALK-CLASS))
   (CL:RETURN-FROM YIELD-INITIAL-VALUE-EXPRESSION NULL))
  (CL:LET*
   ((INITIALVALUEEXPRESSION (INITIALLY SLOT)))
   (CL:WHEN
    (CL:NOT (CL:EQ INITIALVALUEEXPRESSION NULL))
    (CL:RETURN-FROM
     YIELD-INITIAL-VALUE-EXPRESSION
     (TRANSIENTIFY-FORM INITIALVALUEEXPRESSION)))
   (CL:LET*
    ((TEST-VALUE-001 (TRANSLATOR-OUTPUT-LANGUAGE)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-WALK-COMMON-LISP)
      (CL:WHEN
       (CL:EQ (ALLOCATION SLOT) KWD-WALK-EMBEDDED)
       (CL:RETURN-FROM
        YIELD-INITIAL-VALUE-EXPRESSION
        (LIST* SYM-WALK-ALLOCATE (TYPE-TO-SYMBOL (TYPE SLOT)) NIL))))
     ((CL:OR
       (CL:EQ TEST-VALUE-001 KWD-WALK-JAVA)
       (CL:EQ TEST-VALUE-001 KWD-WALK-CPP)
       (CL:EQ TEST-VALUE-001 KWD-WALK-CPP-STANDALONE)
       (CL:EQ TEST-VALUE-001 KWD-WALK-IDL))
      (CL:WHEN
       (CL:EQ (ALLOCATION SLOT) KWD-WALK-EMBEDDED)
       (CL:RETURN-FROM
        YIELD-INITIAL-VALUE-EXPRESSION
        (LIST* SYM-WALK-ALLOCATE (TYPE-TO-SYMBOL (TYPE SLOT)) NIL))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
   (CL:RETURN-FROM
    YIELD-INITIAL-VALUE-EXPRESSION
    (TYPE-TO-NULL-VALUE-TREE (TYPE SLOT))))
  :VOID)

;;; (DEFUN (YIELD-CONSTRUCTOR-ATTACHMENT CONS) ...)

(CL:DEFUN YIELD-CONSTRUCTOR-ATTACHMENT (CLASS CLASSREF)
  (CL:IF
   (CL:AND
    (CL:EQ (CLSYS-SVAL CLASS ABSTRACT? CLASS) 0)
    (CL:EQ (CREATE-NATIVE-CLASS? CLASS) 1))
   (CL:LET*
    ((CONSTRUCTORFNCODE
      (LIST*
       SYM-WALK-THE-CODE
       KWD-WALK-FUNCTION
       (YIELD-CONSTRUCTOR-NAME CLASS)
       NIL)))
    (CL:RETURN-FROM
     YIELD-CONSTRUCTOR-ATTACHMENT
     (CONS
      (LIST*
       SYM-WALK-SETF
       (LIST* SYM-WALK-CLASS-CONSTRUCTOR-CODE CLASSREF NIL)
       CONSTRUCTORFNCODE
       NIL)
      NIL)))
   (CL:RETURN-FROM YIELD-CONSTRUCTOR-ATTACHMENT NIL))
  :VOID)

;;; (DEFUN CLEAR-SLOT-ACCESSOR-METHODS ...)

(CL:DEFUN CLEAR-SLOT-ACCESSOR-METHODS (SLOT)
  (CL:LET*
   ((ACCESSORS (SLOT-ACCESSOR-METHODS SLOT)))
   (CL:WHEN (CL:EQ (DEFINED-LIST? ACCESSORS) 1) (CLEAR ACCESSORS)))
  :VOID)

;;; (DEFUN REGISTER-SLOT-ACCESSOR-METHOD ...)

(CL:DEFUN REGISTER-SLOT-ACCESSOR-METHOD (SLOT METHOD)
  (CL:LET*
   ((ACCESSORS (SLOT-ACCESSOR-METHODS SLOT)))
   (CL:WHEN
    (CL:EQ (NULL-LIST? ACCESSORS) 1)
    (CL:SETQ ACCESSORS (NEW-LIST))
    (SET-DYNAMIC-SLOT-VALUE
     SLOT
     SYM-WALK-SLOT-ACCESSOR-METHODS
     ACCESSORS
     NULL))
   (PUSH ACCESSORS METHOD))
  :VOID)

;;; (DEFUN CREATE-ACCESSOR-UNITS-FOR-SLOT ...)

(CL:DEFUN CREATE-ACCESSOR-UNITS-FOR-SLOT (SLOT CLASS NATIVEACCESSORS? SIGNATURESONLY?)
  (CL:LET*
   ((METHODTREE NULL) (METHOD NULL))
   (CL:WHEN
    (CL:EQ (SYSTEM-DEFINED-SLOT-READER? SLOT) 1)
    (CL:SETQ METHODTREE (YIELD-SLOT-READER-TREE SLOT CLASS))
    (CL:IF
     (CL:EQ SIGNATURESONLY? 1)
     (CL:SETQ METHOD (DEFINE-METHOD-FROM-PARSE-TREE METHODTREE))
     (CL:SETQ
      METHOD
      (CLSYS-SVAL
       TRANSLATION-UNIT
       THE-OBJECT
       (HELP-WALK-AUXILIARY-TREE METHODTREE TRUE))))
    (FINALIZE-ACCESSOR-METHOD METHOD)
    (REGISTER-SLOT-ACCESSOR-METHOD SLOT METHOD))
   (CL:WHEN
    (CL:EQ (SYSTEM-DEFINED-SLOT-WRITER? SLOT) 1)
    (CL:SETQ METHODTREE (YIELD-SLOT-WRITER-TREE SLOT CLASS))
    (CL:IF
     (CL:EQ SIGNATURESONLY? 1)
     (CL:SETQ METHOD (DEFINE-METHOD-FROM-PARSE-TREE METHODTREE))
     (CL:SETQ
      METHOD
      (CLSYS-SVAL
       TRANSLATION-UNIT
       THE-OBJECT
       (HELP-WALK-AUXILIARY-TREE METHODTREE TRUE))))
    (FINALIZE-ACCESSOR-METHOD METHOD)
    (REGISTER-SLOT-ACCESSOR-METHOD SLOT METHOD))
   (CL:WHEN
    (CL:AND
     (CL:EQ NATIVEACCESSORS? 1)
     (CL:EQ (CLSYS-SVAL STORAGE-SLOT ABSTRACT? SLOT) 0))
    (CL:SETQ METHODTREE (YIELD-NATIVE-SLOT-READER-TREE SLOT CLASS))
    (CL:IF
     (CL:EQ SIGNATURESONLY? 1)
     (CL:SETQ METHOD (DEFINE-METHOD-FROM-PARSE-TREE METHODTREE))
     (CL:SETQ
      METHOD
      (CLSYS-SVAL
       TRANSLATION-UNIT
       THE-OBJECT
       (HELP-WALK-AUXILIARY-TREE METHODTREE TRUE))))
    (FINALIZE-ACCESSOR-METHOD METHOD)
    (REGISTER-SLOT-ACCESSOR-METHOD SLOT METHOD)
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-HARDWIRED? SLOT) 0)
     (CL:SETQ METHODTREE (YIELD-NATIVE-SLOT-WRITER-TREE SLOT CLASS))
     (CL:IF
      (CL:EQ SIGNATURESONLY? 1)
      (CL:SETQ METHOD (DEFINE-METHOD-FROM-PARSE-TREE METHODTREE))
      (CL:SETQ
       METHOD
       (CLSYS-SVAL
        TRANSLATION-UNIT
        THE-OBJECT
        (HELP-WALK-AUXILIARY-TREE METHODTREE TRUE))))
     (FINALIZE-ACCESSOR-METHOD METHOD)
     (REGISTER-SLOT-ACCESSOR-METHOD SLOT METHOD))))
  :VOID)

;;; (DEFUN CREATE-ACCESSOR-UNITS-FOR-MIXIN-SLOT ...)

(CL:DEFUN CREATE-ACCESSOR-UNITS-FOR-MIXIN-SLOT (SLOT CLASS)
  (CL:WHEN
   (CL:AND
    (CL:EQ (NATIVE-SLOT? SLOT) 1)
    (CL:EQ (NATIVE-SLOT-HOME SLOT CLASS) CLASS))
   (CREATE-ACCESSOR-UNITS-FOR-SLOT
    SLOT
    (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-WALK-OBJECT)
    TRUE
    FALSE))
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL STORAGE-SLOT SLOT-HARDWIRED? SLOT) 1)
   (CL:LET*
    ((READCODE NULL) (AUXILIARYCODE NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (READCODE AUXILIARYCODE)
     (YIELD-HARDWIRED-SLOT-READER-BODY SLOT))
    (CL:SETQ READCODE READCODE)
    (WALK-AUXILIARY-TREE AUXILIARYCODE))
   (CREATE-ACCESSOR-UNITS-FOR-SLOT
    SLOT
    (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-WALK-OBJECT)
    FALSE
    FALSE))
  :VOID)

;;; (DEFUN CREATE-SLOT-ACCESSOR-UNITS ...)

(CL:DEFUN CREATE-SLOT-ACCESSOR-UNITS (CLASS)
  (CL:LET*
   ((ELIMINATEMIXINSLOTS?
     (CL:IF
      (CL:AND
       (CL:EQ (CLSYS-SVAL CLASS MIXIN? CLASS) 1)
       (CL:EQ (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?) 1))
      TRUE
      FALSE)))
   (CL:LET*
    ((SLOT NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST (LOCAL-SLOTS CLASS))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SLOT (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:LET*
      ((SLOT-001 SLOT))
      (CL:COND
       ((CL:EQ (STORAGE-SLOT? SLOT) 1)
        (CL:LET*
         ((SLOT NULL))
         (CL:SETQ SLOT SLOT-001)
         (CLEAR-SLOT-ACCESSOR-METHODS SLOT)
         (CL:IF
          (CL:EQ ELIMINATEMIXINSLOTS? 1)
          (CREATE-ACCESSOR-UNITS-FOR-MIXIN-SLOT SLOT CLASS)
          (CREATE-ACCESSOR-UNITS-FOR-SLOT
           SLOT
           CLASS
           FALSE
           (CLSYS-SVAL STORAGE-SLOT SLOT-EXTERNAL? SLOT)))))
       (CL:T NULL)))))
   (CL:LET*
    ((TEST-VALUE-001 FALSE))
    (CL:SETQ TEST-VALUE-001 (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:LET*
      ((FOUND?-001 FALSE))
      (CL:LET*
       ((SUPER NULL)
        (ITER-002
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS))))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-002 NIL))
        DO
        (CL:PROGN
         (CL:SETQ SUPER (CLSYS-SVAL CONS VALUE ITER-002))
         (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
        (CL:WHEN
         (CL:EQ
          (CLSYS-SVAL
           CLASS
           MIXIN?
           (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPER))
          1)
         (CL:SETQ FOUND?-001 TRUE)
         (CL:RETURN))))
      (CL:SETQ TEST-VALUE-001 FOUND?-001)))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:LET*
      ((SLOT NULL) (ITER-003 (CLASS-SLOTS CLASS)))
      (CL:LOOP
       WHILE
       (CL:EQ (NEXT? ITER-003) 1)
       DO
       (CL:PROGN (CL:SETQ SLOT (CLSYS-SVAL ITERATOR VALUE ITER-003)))
       (CL:WHEN
        (CL:AND
         (CL:EQ (STORAGE-SLOT? SLOT) 1)
         (CL:EQ
          (CLSYS-SVAL
           CLASS
           MIXIN?
           (TYPE-TO-CLASS (CLSYS-SVAL SLOT SLOT-OWNER SLOT)))
          1)
         (CL:EQ (MIXIN-SLOT-HOME SLOT CLASS) CLASS))
        (CREATE-ACCESSOR-UNITS-FOR-SLOT
         SLOT
         CLASS
         TRUE
         (CLSYS-SVAL SLOT SLOT-EXTERNAL? SLOT)))))))
   (CREATE-GENERIC-SLOT-ACCESSOR-UNIT CLASS))
  :VOID)

;;; (DEFUN CREATE-INLINE-METHOD-UNITS ...)

(CL:DEFUN CREATE-INLINE-METHOD-UNITS (CLASS)
  (CL:LET*
   ((SLOT NULL)
    (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST (LOCAL-SLOTS CLASS))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ SLOT (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:EQ (INLINE-METHOD? SLOT) 1)
     (CL:LET*
      ((METHOD SLOT))
      (CL:LET*
       ((SELF-001 (NEW-TRANSLATION-UNIT)))
       (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT SELF-001) METHOD)
       (CL:SETF
        (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF-001)
        SYM-WALK-METHOD)
       (CL:SETF
        (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER SELF-001)
        (UNSTRINGIFY
         (CLSYS-SVAL METHOD-SLOT METHOD-STRINGIFIED-SOURCE METHOD)))
       (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT AUXILIARY? SELF-001) TRUE)
       (WALK-METHOD-UNIT SELF-001))))))
  :VOID)

;;; (DEFUN CREATE-DEFPRINT-UNIT ...)

(CL:DEFUN CREATE-DEFPRINT-UNIT (CLASS)
  (CL:WHEN
   (CL:NOT (CL:EQ (DYNAMIC-SLOT-VALUE CLASS SYM-WALK-PRINT-FORM NULL) NULL))
   (WALK-AUXILIARY-TREE
    (LIST*
     SYM-WALK-DEFMETHOD
     SYM-WALK-PRINT-OBJECT
     (LIST*
      (LIST* SYM-WALK-SELF (CLSYS-SVAL CLASS CLASS-TYPE CLASS) NIL)
      (LIST* SYM-WALK-STREAM SYM-WALK-NATIVE-OUTPUT-STREAM NIL)
      NIL)
     (TRANSIENTIFY-FORM (DYNAMIC-SLOT-VALUE CLASS SYM-WALK-PRINT-FORM NULL))
     NIL))
   (CL:LET*
    ((TEST-VALUE-001 FALSE))
    (CL:SETQ TEST-VALUE-001 (EQ? (TRANSLATOR-OUTPUT-LANGUAGE) KWD-WALK-CPP))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:LET*
      ((FOUND?-001 FALSE))
      (CL:LET*
       ((SUPER NULL)
        (ITER-001 (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CLASS)))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ SUPER (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:WHEN
         (CL:NOT
          (CL:EQ (DYNAMIC-SLOT-VALUE SUPER SYM-WALK-PRINT-FORM NULL) NULL))
         (CL:SETQ FOUND?-001 TRUE)
         (CL:RETURN))))
      (CL:SETQ TEST-VALUE-001 FOUND?-001))
     (CL:SETQ TEST-VALUE-001 (CL:IF (CL:EQ TEST-VALUE-001 0) TRUE FALSE)))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:LET*
      ((SELF-001 (NEW-TRANSLATION-UNIT)))
      (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT SELF-001) CLASS)
      (CL:SETF
       (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF-001)
       SYM-WALK-PRINT-METHOD)
      (CL:SETF
       (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER SELF-001)
       (LIST*
        SYM-WALK-SYS-CALL-METHOD
        (CLSYS-SVAL CLASS CLASS-TYPE CLASS)
        (LIST* SYM-WALK-PRINT-OBJECT SYM-WALK-SELF SYM-WALK-STREAM NIL)))
      (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT AUXILIARY? SELF-001) TRUE)
      (CL:LET* ((UNIT SELF-001)) (PUSH *TRANSLATIONUNITS* UNIT))))))
  :VOID)

;;; (DEFUN WALK-CLASS-UNIT ...)

(CL:DEFUN WALK-CLASS-UNIT (UNIT)
  (CL:LET*
   ((CLASS (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT))
    (STARTUPTIMECODE NULL))
   (CL:WHEN
    (CL:EQ (CLSYS-SVAL CLASS CLASS-FINALIZED? CLASS) 0)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Cannot translate class `" %%STREAM)
       (PRINT-OBJECT (CLASS-SYMBOL CLASS) %%STREAM)
       (CL:WRITE-STRING "', since it could not be finalized." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (FREE UNIT)
    (CL:RETURN-FROM WALK-CLASS-UNIT))
   (CL:WHEN
    (CL:EQ (CREATE-NATIVE-CLASS? CLASS) 1)
    (WARN-ABOUT-MULTIPLE-PARENTS CLASS)
    (WARN-ABOUT-NON-DIRECT-SUPERS CLASS)
    (CL:COND
     ((CL:AND
       (CL:EQ (CLSYS-SVAL CLASS MIXIN? CLASS) 1)
       (CL:EQ (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?) 1))
      (CREATE-SLOT-ACCESSOR-UNITS CLASS))
     (CL:T
      (PUSH *TRANSLATIONUNITS* UNIT)
      (CREATE-CONSTRUCTOR-AND-DESTRUCTOR-UNITS CLASS)
      (CREATE-SLOT-ACCESSOR-UNITS CLASS)
      (CREATE-INLINE-METHOD-UNITS CLASS))))
   (CREATE-DEFPRINT-UNIT CLASS)
   (CL:SETQ
    STARTUPTIMECODE
    (CONCATENATE
     (YIELD-INITIALIZE-HARDWIRED-SLOTS CLASS)
     (CONCATENATE
      (YIELD-CONSTRUCTOR-ATTACHMENT CLASS SYM-WALK-CLASS)
      (CONCATENATE
       (YIELD-GENERIC-SLOT-ACCESSOR-ATTACHMENT CLASS SYM-WALK-CLASS)
       NIL))))
   (WALK-AUXILIARY-TREE
    (CL:IF
     (CL:EQ STARTUPTIMECODE NIL)
     (LIST*
      SYM-WALK-STARTUP-TIME-PROGN
      KWD-WALK-CLASSES
      (YIELD-DEFINE-STELLA-CLASS CLASS)
      NIL)
     (LIST*
      SYM-WALK-STARTUP-TIME-PROGN
      KWD-WALK-CLASSES
      (LIST*
       SYM-WALK-LET
       (CONS (LIST* SYM-WALK-CLASS (YIELD-DEFINE-STELLA-CLASS CLASS) NIL) NIL)
       (CONCATENATE STARTUPTIMECODE NIL))
      NIL)))
   (CL:LET*
    ((SYNONYM NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST (CLASS-SYNONYMS CLASS))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SYNONYM (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (REGISTER-SYMBOL (TYPE-TO-SYMBOL SYNONYM)))))
  :VOID)

;;; (DEFUN CREATE-FINALIZATION-UNITS ...)

(CL:DEFUN CREATE-FINALIZATION-UNITS ()
  (CL:LET*
   ((*TRANSIENTOBJECTS?* TRUE))
   (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
   (WALK-AUXILIARY-TREE
    (LIST*
     SYM-WALK-STARTUP-TIME-PROGN
     KWD-WALK-FINALIZE-CLASSES
     (CONS SYM-WALK-FINALIZE-CLASSES NIL)
     NIL))
   (WALK-AUXILIARY-TREE
    (LIST*
     SYM-WALK-STARTUP-TIME-PROGN
     KWD-WALK-FINALIZE-METHODS
     (CONS SYM-WALK-FINALIZE-SLOTS NIL)
     (CONS SYM-WALK-CLEANUP-UNFINALIZED-CLASSES NIL)
     NIL)))
  :VOID)

;;; (DEFUN WALK-DEFSLOT-TREE ...)

(CL:DEFUN WALK-DEFSLOT-TREE (TREE)
  (CL:LET*
   ((SELF-001 (NEW-TRANSLATION-UNIT)))
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF-001) SYM-WALK-SLOT)
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT SELF-001) TREE)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-001))
  (CL:LET*
   ((SLOT NULL))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* FALSE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:SETQ SLOT (DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE TREE)))
   (CL:WHEN
    (CL:EQ SLOT NULL)
    (FREE *CURRENTTRANSLATIONUNIT*)
    (CL:SETQ *CURRENTTRANSLATIONUNIT* NULL)
    (CL:RETURN-FROM WALK-DEFSLOT-TREE))
   (CL:SETF
    (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT *CURRENTTRANSLATIONUNIT*)
    SLOT)
   (CL:SETF
    (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER *CURRENTTRANSLATIONUNIT*)
    TREE))
  :VOID)

;;; (DEFUN WALK-SLOT-UNIT ...)

(CL:DEFUN WALK-SLOT-UNIT (UNIT)
  (CL:LET*
   ((SLOT (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT))
    (OWNERCLASS
     (CLSYS-SVAL
      SURROGATE
      SURROGATE-VALUE
      (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SLOT)))
    (STRINGIFIEDDEFINITION
     (STRINGIFY (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT))))
   (CLEAR-SLOT-ACCESSOR-METHODS SLOT)
   (CREATE-ACCESSOR-UNITS-FOR-SLOT SLOT OWNERCLASS FALSE FALSE)
   (FREE UNIT)
   (WALK-AUXILIARY-TREE
    (LIST*
     SYM-WALK-STARTUP-TIME-PROGN
     KWD-WALK-METHODS
     (LIST*
      SYM-WALK-DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
      (WRAP-LITERAL STRINGIFIEDDEFINITION)
      NIL)
     NIL)))
  :VOID)

;;; (DEFGLOBAL *MACRO-TABLE* ...)

(CL:DEFVAR *MACRO-TABLE* NULL
  "Associates macro names with the name and code of
their expander function.")

;;; (DEFUN (LOOKUP-MACRO METHOD-SLOT) ...)

(CL:DEFUN LOOKUP-MACRO (NAME)
  (CL:LET*
   ((MACROINFO (LOOKUP *MACRO-TABLE* NAME)) (EXPANDERMETHOD NULL))
   (CL:WHEN
    (CL:NOT (CL:EQ MACROINFO NULL))
    (CL:SETQ
     EXPANDERMETHOD
     (LOOKUP-FUNCTION-OR-STELLA-FUNCTION (FIRST MACROINFO)))
    (CL:WHEN
     (CL:NOT (CL:EQ EXPANDERMETHOD NULL))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE EXPANDERMETHOD)
      (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE (SECOND MACROINFO)))
     (CL:RETURN-FROM LOOKUP-MACRO EXPANDERMETHOD)))
   (CL:RETURN-FROM LOOKUP-MACRO NULL))
  :VOID)

;;; (DEFUN STORE-MACRO ...)

(CL:DEFUN STORE-MACRO (NAME EXPANDERNAME EXPANDERCODE)
  (INSERT-AT
   *MACRO-TABLE*
   NAME
   (CONS-LIST EXPANDERNAME (WRAP-LITERAL EXPANDERCODE)))
  :VOID)

;;; (DEFUN (YIELD-MACRO-EXPANDER-FUNCTION-NAME SYMBOL) ...)

(CL:DEFUN YIELD-MACRO-EXPANDER-FUNCTION-NAME (MACRONAME)
  (CL:RETURN-FROM
   YIELD-MACRO-EXPANDER-FUNCTION-NAME
   (INTERN-DERIVED-SYMBOL
    MACRONAME
    (CONCATENATE (CLSYS-SVAL SYMBOL SYMBOL-NAME MACRONAME) "-EXPANDER")))
  :VOID)

;;; (DEFUN WALK-DEFMACRO-TREE ...)

(CL:DEFUN WALK-DEFMACRO-TREE (TREE)
  (CL:LET*
   ((NAME (SECOND TREE)))
   (CL:WHEN
    (CL:EQ (SYMBOL? NAME) 0)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Illegal macro name: `" %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE NAME) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))))
   (FIRST-SETTER TREE SYM-WALK-DEFUN)
   (SECOND-SETTER
    TREE
    (CONS
     (YIELD-MACRO-EXPANDER-FUNCTION-NAME NAME)
     (CONS SYM-WALK-OBJECT NIL)))
   (WALK-DEFMETHOD-TREE TREE)
   (CL:WHEN
    (CL:NOT (CL:EQ *CURRENTTRANSLATIONUNIT* NULL))
    (CL:SETF
     (CLSYS-SVAL TRANSLATION-UNIT CATEGORY *CURRENTTRANSLATIONUNIT*)
     SYM-WALK-MACRO)
    (SECOND-SETTER TREE NAME)
    (CL:SETF
     (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER *CURRENTTRANSLATIONUNIT*)
     TREE)))
  :VOID)

;;; (DEFUN WALK-MACRO-UNIT ...)

(CL:DEFUN WALK-MACRO-UNIT (UNIT)
  (CL:LET*
   ((DEFINITION (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT))
    (NAME (SECOND DEFINITION))
    (EXPANDERMETHOD (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT))
    (EXPANDERFNNAME (CLSYS-SVAL METHOD-SLOT SLOT-NAME EXPANDERMETHOD))
    (NEEDSLISPMACRO? (METHOD-NEEDS-LISP-MACRO? EXPANDERMETHOD)))
   (CL:WHEN
    (CL:EQ NEEDSLISPMACRO? 1)
    (CREATE-LISP-MACRO-UNITS NAME EXPANDERMETHOD)
    (SET-DYNAMIC-SLOT-VALUE
     EXPANDERMETHOD
     SYM-WALK-METHOD-LISP-MACRO?
     (WRAP-BOOLEAN FALSE)
     NULL-BOOLEAN-WRAPPER))
   (CL:SETF
    (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT)
    (NTH-REST DEFINITION 3))
   (WALK-METHOD-UNIT UNIT)
   (CL:WHEN
    (CL:EQ NEEDSLISPMACRO? 1)
    (SET-DYNAMIC-SLOT-VALUE
     EXPANDERMETHOD
     SYM-WALK-METHOD-LISP-MACRO?
     (WRAP-BOOLEAN TRUE)
     NULL-BOOLEAN-WRAPPER))
   (CL:WHEN
    (CL:> (METHOD-ARGUMENT-COUNT EXPANDERMETHOD) 5)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Too many arguments in macro definition." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))))
   (WALK-AUXILIARY-TREE
    (LIST*
     SYM-WALK-STARTUP-TIME-PROGN
     (LIST*
      SYM-WALK-STORE-MACRO
      (LIST* SYM-WALK-BQUOTE NAME NIL)
      (LIST* SYM-WALK-BQUOTE EXPANDERFNNAME NIL)
      (LIST* SYM-WALK-THE-CODE KWD-WALK-FUNCTION EXPANDERFNNAME NIL)
      NIL)
     NIL)))
  :VOID)

;;; (DEFUN WALK-DEFGLOBAL-TREE ...)

(CL:DEFUN WALK-DEFGLOBAL-TREE (TREE)
  (CL:LET*
   ((SELF-001 (NEW-TRANSLATION-UNIT)))
   (CL:SETF
    (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF-001)
    SYM-WALK-GLOBAL-VARIABLE)
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT SELF-001) TREE)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-001))
  (CL:WHEN
   (CL:< (LENGTH TREE) 3)
   (BAD-ARGUMENT-COUNT? TREE 3)
   (FREE *CURRENTTRANSLATIONUNIT*)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* NULL)
   (CL:RETURN-FROM WALK-DEFGLOBAL-TREE))
  (CL:LET*
   ((GLOBAL NULL) (INITIALVALUETREE NULL))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* FALSE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:MULTIPLE-VALUE-SETQ
     (GLOBAL INITIALVALUETREE)
     (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE TREE (STRINGIFY TREE))))
   (CL:SETF
    (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT *CURRENTTRANSLATIONUNIT*)
    GLOBAL)
   (CL:SETF
    (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER *CURRENTTRANSLATIONUNIT*)
    INITIALVALUETREE)
   (CL:SETF
    (CLSYS-SVAL TRANSLATION-UNIT AUXILIARY? *CURRENTTRANSLATIONUNIT*)
    (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-AUXILIARY? GLOBAL))
   (CL:WHEN (CL:> (LENGTH TREE) 3) (FOURTH-SETTER TREE NULL))
   (FREE-PARSE-TREE TREE))
  :VOID)

;;; (DEFUN WALK-GLOBAL-UNIT ...)

(CL:DEFUN WALK-GLOBAL-UNIT (UNIT)
  (CL:LET*
   ((GLOBAL (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT))
    (VARIABLENAME (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME GLOBAL))
    (INITIALVALUETREE (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT))
    (STRINGIFIEDSOURCE
     (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-STRINGIFIED-SOURCE GLOBAL))
    (ACTIVE?
     (CL:IF
      (CL:AND
       (CL:EQ (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SPECIAL? GLOBAL) 1)
       (CL:EQ
        (GENERICALLY-ACCESSIBLE-TYPE?
         (TYPE-SPEC-TO-BASE-TYPE
          (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-TYPE GLOBAL)))
        1))
      TRUE
      FALSE))
    (GETVARIABLEVALUEFN NULL)
    (SETVARIABLEVALUEFN NULL)
    (VARIABLETYPESPEC NULL))
   (PUSH *TRANSLATIONUNITS* UNIT)
   (CL:WHEN
    (CL:NOT (CL:EQ INITIALVALUETREE KWD-WALK-UNBOUND-SPECIAL-VARIABLE))
    (CL:COND
     ((CL:OR
       (CL:EQ (WRAPPER? INITIALVALUETREE) 1)
       (CL:AND
        (CL:EQ (SYMBOL? INITIALVALUETREE) 1)
        (CL:EQ (CONSTANT-SYMBOL? INITIALVALUETREE) 1))
       (CL:AND
        (CL:EQ (CONS? INITIALVALUETREE) 1)
        (CL:EQ (FIRST INITIALVALUETREE) SYM-WALK-VERBATIM)))
      (CL:SETQ
       INITIALVALUETREE
       (WALK-EXPRESSION-TREE
        INITIALVALUETREE
        (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-TYPE GLOBAL)
        (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME GLOBAL)
        TRUE)))
     (CL:T
      (WALK-AUXILIARY-TREE
       (LIST*
        SYM-WALK-STARTUP-TIME-PROGN
        KWD-WALK-GLOBALS
        (LIST*
         SYM-WALK-SETQ
         (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME GLOBAL)
         (CONS INITIALVALUETREE NIL))
        NIL))
      (CL:SETQ
       INITIALVALUETREE
       (TYPE-TO-NULL-VALUE-TREE
        (TYPE-SPEC-TO-BASE-TYPE
         (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-TYPE GLOBAL)))))))
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT) INITIALVALUETREE)
   (CL:WHEN
    (CL:EQ ACTIVE? 1)
    (CL:SETQ
     GETVARIABLEVALUEFN
     (INTERN-DERIVED-SYMBOL
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME GLOBAL)
      (CONCATENATE "READ-" (CLSYS-SVAL SYMBOL SYMBOL-NAME VARIABLENAME))))
    (CL:SETQ
     SETVARIABLEVALUEFN
     (INTERN-DERIVED-SYMBOL
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME GLOBAL)
      (CONCATENATE "WRITE-" (CLSYS-SVAL SYMBOL SYMBOL-NAME VARIABLENAME))))
    (CL:SETQ
     VARIABLETYPESPEC
     (CL:IF
      (CL:EQ
       (DYNAMIC-SLOT-VALUE GLOBAL SYM-WALK-VARIABLE-TYPE-SPECIFIER NULL)
       NULL)
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-TYPE GLOBAL)
      (DYNAMIC-SLOT-VALUE GLOBAL SYM-WALK-VARIABLE-TYPE-SPECIFIER NULL)))
    (WALK-AUXILIARY-TREE
     (LIST*
      SYM-WALK-DEFUN
      (CONS
       GETVARIABLEVALUEFN
       (CONS (YIELD-TYPE-SPEC-TREE VARIABLETYPESPEC) NIL))
      NIL
      (LIST* SYM-WALK-RETURN VARIABLENAME NIL)
      NIL))
    (WALK-AUXILIARY-TREE
     (LIST*
      SYM-WALK-DEFUN
      (CONS
       SETVARIABLEVALUEFN
       (CONS (YIELD-TYPE-SPEC-TREE VARIABLETYPESPEC) NIL))
      (CONS
       (LIST* SYM-WALK-VALUE (YIELD-TYPE-SPEC-TREE VARIABLETYPESPEC) NIL)
       NIL)
      (LIST* SYM-WALK-SETQ VARIABLENAME (CONS SYM-WALK-VALUE NIL))
      (LIST* SYM-WALK-RETURN SYM-WALK-VALUE NIL)
      NIL)))
   (CL:WHEN
    (CL:EQ (CLSYS-SVAL TRANSLATION-UNIT AUXILIARY? UNIT) 0)
    (WALK-AUXILIARY-TREE
     (LIST*
      SYM-WALK-STARTUP-TIME-PROGN
      (LIST*
       SYM-WALK-DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
       (WRAP-LITERAL STRINGIFIEDSOURCE)
       NIL)
      (CONCATENATE
       (CL:IF
        (CL:EQ ACTIVE? 1)
        (CONS
         (LIST*
          SYM-WALK-LET
          (CONS
           (LIST*
            SYM-WALK-GLOBAL
            (LIST*
             SYM-WALK-LOOKUP-GLOBAL-VARIABLE
             (LIST* SYM-WALK-QUOTE VARIABLENAME NIL)
             NIL)
            NIL)
           NIL)
          (LIST*
           SYM-WALK-SETF
           (LIST* SYM-WALK-VARIABLE-GET-VALUE-CODE SYM-WALK-GLOBAL NIL)
           (LIST* SYM-WALK-THE-CODE KWD-WALK-FUNCTION GETVARIABLEVALUEFN NIL)
           NIL)
          (LIST*
           SYM-WALK-SETF
           (LIST* SYM-WALK-VARIABLE-SET-VALUE-CODE SYM-WALK-GLOBAL NIL)
           (LIST* SYM-WALK-THE-CODE KWD-WALK-FUNCTION SETVARIABLEVALUEFN NIL)
           NIL)
          NIL)
         NIL)
        NIL)
       NIL)))))
  :VOID)

;;; (DEFUN WALK-DEFTYPE-TREE ...)

(CL:DEFUN WALK-DEFTYPE-TREE (TREE)
  (CL:LET*
   ((SELF-001 (NEW-TRANSLATION-UNIT)))
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF-001) SYM-WALK-TYPE)
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT SELF-001) TREE)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-001))
  (CL:WHEN
   (CL:< (LENGTH TREE) 3)
   (BAD-ARGUMENT-COUNT? TREE 3)
   (FREE *CURRENTTRANSLATIONUNIT*)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* NULL)
   (CL:RETURN-FROM WALK-DEFTYPE-TREE))
  (CL:LET*
   ((TYPE NULL))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* FALSE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:SETQ TYPE (DEFINE-STELLA-TYPE-FROM-PARSE-TREE TREE)))
   (CL:SETF
    (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT *CURRENTTRANSLATIONUNIT*)
    TYPE)
   (CL:SETF
    (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER *CURRENTTRANSLATIONUNIT*)
    TREE))
  :VOID)

;;; (DEFUN WALK-TYPE-UNIT ...)

(CL:DEFUN WALK-TYPE-UNIT (UNIT)
  (CL:LET*
   ((STRINGIFIEDDEFINITION
     (STRINGIFY (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT))))
   (PUSH *TRANSLATIONUNITS* UNIT)
   (WALK-AUXILIARY-TREE
    (LIST*
     SYM-WALK-STARTUP-TIME-PROGN
     KWD-WALK-CLASSES
     (LIST*
      SYM-WALK-DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
      (WRAP-LITERAL STRINGIFIEDDEFINITION)
      NIL)
     NIL))
   (REGISTER-SYMBOL
    (TYPE-TO-SYMBOL (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT))))
  :VOID)

;;; (DEFUN WALK-STARTUP-TIME-PROGN-TREE ...)

(CL:DEFUN WALK-STARTUP-TIME-PROGN-TREE (TREE)
  (CL:LET*
   ((SELF-001 (NEW-TRANSLATION-UNIT)))
   (CL:SETF
    (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF-001)
    SYM-WALK-STARTUP-TIME-PROGN)
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER SELF-001) TREE)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-001))
  :VOID)

;;; (DEFUN (EXTRACT-STARTUP-TIME-PHASE KEYWORD) ...)

(CL:DEFUN EXTRACT-STARTUP-TIME-PHASE (TREE)
  (CL:LET*
   ((STARTUPTIMEPHASE KWD-WALK-FINAL) (STARTUPTIMEPHASETREE NULL))
   (CL:WHEN
    (CL:AND
     (CL:>= (LENGTH TREE) 2)
     (CL:EQ (KEYWORD? (SECOND TREE)) 1)
     (CL:EQ (MEMBER? *STARTUP-TIME-PHASES* (SECOND TREE)) 1))
    (CL:SETQ STARTUPTIMEPHASE (SECOND TREE))
    (CL:SETQ STARTUPTIMEPHASETREE (CLSYS-SVAL CONS REST TREE))
    (CL:SETF
     (CLSYS-SVAL CONS REST TREE)
     (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
    (CL:SETF (CLSYS-SVAL CONS REST STARTUPTIMEPHASETREE) NIL)
    (FREE-CONS STARTUPTIMEPHASETREE))
   (CL:RETURN-FROM EXTRACT-STARTUP-TIME-PHASE STARTUPTIMEPHASE))
  :VOID)

;;; (DEFUN WALK-STARTUP-TIME-PROGN-UNIT ...)

(CL:DEFUN WALK-STARTUP-TIME-PROGN-UNIT (UNIT)
  (CL:LET*
   ((TREE (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT))
    (PHASE (EXTRACT-STARTUP-TIME-PHASE TREE)))
   (PUSH *TRANSLATIONUNITS* UNIT)
   (CL:SETF
    (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT)
    (WALK-LIST-OF-TREES (CLSYS-SVAL CONS REST TREE)))
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT) PHASE))
  :VOID)

;;; (DEFUN (COMBINE-STARTUP-FUNCTION-UNITS CONS) ...)

(CL:DEFUN COMBINE-STARTUP-FUNCTION-UNITS ()
  (CL:LET*
   ((EARLYSTARTUPTREES NIL)
    (STARTUPTREES NIL)
    (STARTUPPHASETREES NIL)
    (PLACEHOLDERUNIT NULL))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* TRUE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:LET*
     ((PHASE NULL)
      (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST *STARTUP-TIME-PHASES*)))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ PHASE (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:LET*
       ((IT (ALLOCATE-ITERATOR *TRANSLATIONUNITS*)))
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? IT) 1)
        DO
        (CL:LET*
         ((UNIT (CLSYS-SVAL LIST-ITERATOR VALUE IT)))
         (CL:WHEN
          (CL:AND
           (CL:EQ
            (CLSYS-SVAL TRANSLATION-UNIT CATEGORY UNIT)
            SYM-WALK-STARTUP-TIME-PROGN)
           (CL:EQ (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT) PHASE))
          (CL:SETQ
           STARTUPPHASETREES
           (CONCATENATE
            (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT)
            STARTUPPHASETREES))
          (CL:COND
           ((CL:NOT (CL:EQ PLACEHOLDERUNIT NULL))
            (FREE UNIT)
            (VALUE-SETTER IT PLACEHOLDERUNIT))
           (CL:T (CL:SETQ PLACEHOLDERUNIT UNIT)))))))
      (CL:WHEN
       (CL:NOT (CL:EQ STARTUPPHASETREES NIL))
       (CL:SETQ
        STARTUPPHASETREES
        (LIST*
         SYM-WALK-VOID-SYS
         (LIST*
          SYM-WALK-WHEN
          (LIST*
           SYM-WALK-SYS-CALL-FUNCTION
           SYM-WALK-CURRENT-STARTUP-TIME-PHASE?
           (WRAP-LITERAL (ENCODE-STARTUP-TIME-PHASE PHASE))
           NIL)
          (CONCATENATE STARTUPPHASETREES NIL))
         NIL))
       (CL:IF
        (CL:<=
         (ENCODE-STARTUP-TIME-PHASE PHASE)
         (ENCODE-STARTUP-TIME-PHASE KWD-WALK-MODULES))
        (CL:SETQ EARLYSTARTUPTREES (CONS STARTUPPHASETREES EARLYSTARTUPTREES))
        (CL:SETQ STARTUPTREES (CONS STARTUPPHASETREES STARTUPTREES)))
       (CL:SETQ STARTUPPHASETREES NIL))))
    (CL:WHEN
     (CL:NOT (CL:EQ STARTUPTREES NIL))
     (CL:SETQ
      STARTUPTREES
      (CONS
       (LIST*
        SYM-WALK-WITHIN-MODULE
        (CL:IF
         (CL:EQ *MODULE* *STELLA-MODULE*)
         SYM-WALK-*STELLA-MODULE*
         (LIST*
          SYM-WALK-GET-MODULE
          (WRAP-LITERAL (CLSYS-SVAL MODULE MODULE-FULL-NAME *MODULE*))
          (CONS SYM-WALK-TRUE NIL)))
        (CONCATENATE (REVERSE STARTUPTREES) NIL))
       NIL))))
   (CL:WHEN
    (CL:OR
     (CL:NOT (CL:EQ EARLYSTARTUPTREES NIL))
     (CL:NOT (CL:EQ STARTUPTREES NIL)))
    (CL:SETQ
     STARTUPTREES
     (CONCATENATE (REVERSE EARLYSTARTUPTREES) STARTUPTREES))
    (REMOVE *TRANSLATIONUNITS* PLACEHOLDERUNIT)
    (FREE PLACEHOLDERUNIT))
   (CL:RETURN-FROM COMBINE-STARTUP-FUNCTION-UNITS STARTUPTREES))
  :VOID)

;;; (DEFUN CREATE-STARTUP-FUNCTION-UNIT ...)

(CL:DEFUN CREATE-STARTUP-FUNCTION-UNIT (STARTUPFNNAME)
  (CL:LET*
   ((TREE NULL) (METHOD NULL))
   (CL:COND
    ((CL:EQ (DONT-GENERATE-STARTUP-CODE?) 1)
     (REMOVE-ALL-STARTUP-TIME-PROGN-UNITS))
    ((CL:NOT (CL:EQ STARTUPFNNAME NULL))
     (CL:LET*
      ((*TRANSIENTOBJECTS?* TRUE))
      (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
      (CL:SETQ
       TREE
       (LIST* SYM-WALK-DEFUN STARTUPFNNAME (LIST* NIL SYM-WALK-NULL NIL))))
     (CL:SETQ METHOD (DEFINE-METHOD-FROM-PARSE-TREE TREE))
     (CL:LET*
      ((*TRANSIENTOBJECTS?* TRUE))
      (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
      (CL:SETQ
       TREE
       (LIST*
        SYM-WALK-STARTUP-TIME-PROGN
        KWD-WALK-METHODS
        (YIELD-DEFINE-STELLA-METHOD METHOD)
        NIL)))
     (WALK-AUXILIARY-TREE TREE)
     (CL:LET*
      ((*TRANSIENTOBJECTS?* TRUE))
      (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
      (CL:SETQ
       TREE
       (LIST*
        SYM-WALK-DEFUN
        STARTUPFNNAME
        (LIST*
         NIL
         KWD-WALK-AUXILIARY?
         SYM-WALK-TRUE
         (CONCATENATE (COMBINE-STARTUP-FUNCTION-UNITS) NIL)))))
     (WALK-AUXILIARY-TREE TREE))
    (CL:T
     (CL:LET*
      ((*TRANSIENTOBJECTS?* TRUE))
      (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
      (CL:SETQ
       TREE
       (CONS
        SYM-WALK-STARTUP-TIME-PROGN
        (CONCATENATE (COMBINE-STARTUP-FUNCTION-UNITS) NIL))))
     (WALK-AUXILIARY-TREE TREE)
     (CL:LET*
      ((*TRANSIENTOBJECTS?* TRUE))
      (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
      (CL:SETQ
       TREE
       (CONS
        SYM-WALK-PROGN
        (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT (FIRST *TRANSLATIONUNITS*)))))
     (CL:SETF
      (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT (FIRST *TRANSLATIONUNITS*))
      TREE))))
  :VOID)

;;; (DEFUN (DONT-GENERATE-STARTUP-CODE? BOOLEAN) ...)

(CL:DEFUN DONT-GENERATE-STARTUP-CODE? ()
  (CL:RETURN-FROM
   DONT-GENERATE-STARTUP-CODE?
   (EQ? *TRANSLATOR-OUTPUT-LANGUAGE* KWD-WALK-CPP-STANDALONE))
  :VOID)

;;; (DEFUN REMOVE-ALL-STARTUP-TIME-PROGN-UNITS ...)

(CL:DEFUN REMOVE-ALL-STARTUP-TIME-PROGN-UNITS ()
  (CL:LET*
   ((PLACEHOLDERUNIT NULL))
   (CL:LET*
    ((IT (ALLOCATE-ITERATOR *TRANSLATIONUNITS*)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? IT) 1)
     DO
     (CL:WHEN
      (CL:EQ
       (CLSYS-SVAL
        TRANSLATION-UNIT
        CATEGORY
        (CLSYS-SVAL LIST-ITERATOR VALUE IT))
       SYM-WALK-STARTUP-TIME-PROGN)
      (CL:LET*
       ((UNIT (CLSYS-SVAL LIST-ITERATOR VALUE IT)))
       (FREE-PARSE-TREE (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT))
       (CL:IF
        (CL:EQ PLACEHOLDERUNIT NULL)
        (CL:SETQ PLACEHOLDERUNIT UNIT)
        (FREE UNIT))
       (VALUE-SETTER IT PLACEHOLDERUNIT)))))
   (REMOVE *TRANSLATIONUNITS* PLACEHOLDERUNIT)
   (FREE PLACEHOLDERUNIT))
  :VOID)

;;; (DEFUN (USE-STELLA-EXCEPTIONS? BOOLEAN) ...)

(CL:DEFUN USE-STELLA-EXCEPTIONS? ()
  (CL:RETURN-FROM USE-STELLA-EXCEPTIONS? TRUE)
  :VOID)

;;; (DEFSPECIAL *EXCEPTIONHANDLERADDRESS* ...)

(CL:DEFVAR *EXCEPTIONHANDLERADDRESS* :exception-handler
  "Points to the address of the most recently established
Stella exception handler.  For Common-Lisp this variable never gets rebound.")

;;; (DEFSPECIAL *PENDINGEXCEPTIONHANDLER?* ...)

(CL:DEFVAR *PENDINGEXCEPTIONHANDLER?* FALSE
  "TRUE if at least one exception handler is pending.")

(CL:DEFUN READ-*PENDINGEXCEPTIONHANDLER?* ()
  (CL:RETURN-FROM READ-*PENDINGEXCEPTIONHANDLER?* *PENDINGEXCEPTIONHANDLER?*)
  :VOID)

(CL:DEFUN WRITE-*PENDINGEXCEPTIONHANDLER?* (VALUE)
  (CL:SETQ *PENDINGEXCEPTIONHANDLER?* VALUE)
  (CL:RETURN-FROM WRITE-*PENDINGEXCEPTIONHANDLER?* VALUE)
  :VOID)

;;; (DEFGLOBAL *EXCEPTION* ...)

(CL:DEFVAR *EXCEPTION* NULL
  "The most recently signalled exception.")

;;; (DEFGLOBAL *EXCEPTION-TYPE* ...)

(CL:DEFVAR *EXCEPTION-TYPE* NULL
  "The type of the most recently signalled exception.")

;;; (DEFUN SIGNAL ...)

(CL:DEFUN SIGNAL (EXCEPTION)
  "Signal an 'exception'.  Signal an error if there is
no pending exception handler that can handle 'exception'."
  (CL:WHEN
   (CL:EQ *PENDINGEXCEPTIONHANDLER?* 0)
   (CL:ERROR "signal: No available handlers to handle `~A'" EXCEPTION))
  (CL:SETQ *EXCEPTION* EXCEPTION)
  (CL:SETQ *EXCEPTION-TYPE* (PRIMARY-TYPE EXCEPTION))
  (CL:THROW *EXCEPTIONHANDLERADDRESS* TRUE)
  NULL
  :VOID)

;;; (DEFUN RESIGNAL ...)

(CL:DEFUN RESIGNAL ()
  "Resignal the most recently re/signalled exception.
Signal an error if there is no pending exception handler that can handle it."
  (CL:WHEN
   (CL:EQ *PENDINGEXCEPTIONHANDLER?* 0)
   (CL:ERROR "signal: No available handlers to handle `~A'" *EXCEPTION*))
  (CL:THROW *EXCEPTIONHANDLERADDRESS* TRUE)
  NULL
  :VOID)

;;; (DEFUN (WALK-EXCEPTION-CASE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-EXCEPTION-CASE-TREE (TREE)
  (CL:WHEN
   (CL:<= (LENGTH TREE) 2)
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING " Missing handler(s) in 'exception-case': `" %%STREAM)
      (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
      (CL:WRITE-STRING "'." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))))
   (CL:RETURN-FROM
    WALK-EXCEPTION-CASE-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
  (CL:WHEN
   (CL:EQ (USE-STELLA-EXCEPTIONS?) 0)
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-WARNING)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING
       " Native exception handling is not yet implemented."
       %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)))))
  (CL:LET*
   ((PROTECTEDTREE (YIELD-PROTECTED-STATEMENT-TREE (SECOND TREE) FALSE))
    (HANDLERTREE
     (YIELD-EXCEPTION-HANDLER-TREE
      (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))))
   (CL:WHEN
    (CL:OR (CL:EQ PROTECTEDTREE NULL) (CL:EQ HANDLERTREE NULL))
    (CL:RETURN-FROM
     WALK-EXCEPTION-CASE-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-VOID)))
   (CL:RETURN-FROM
    WALK-EXCEPTION-CASE-TREE
    (CL:VALUES
     (WALK-A-TREE (LIST* SYM-WALK-PROGN PROTECTEDTREE (CONS HANDLERTREE NIL)))
     SGT-WALK-VOID)))
  :VOID)

;;; (DEFUN (LEXICALLY-VISIBLE-EXCEPTION-CASE? BOOLEAN) ...)

(CL:DEFUN LEXICALLY-VISIBLE-EXCEPTION-CASE? ()
  (CL:RETURN-FROM
   LEXICALLY-VISIBLE-EXCEPTION-CASE?
   (DEFINED? (LOOKUP-OLD-VALUE-VARIABLE SYM-WALK-*PENDINGEXCEPTIONHANDLER?*)))
  :VOID)

;;; (DEFUN (YIELD-PROTECTED-STATEMENT-TREE CONS) ...)

(CL:DEFUN YIELD-PROTECTED-STATEMENT-TREE (TREE UNWINDPROTECT?)
  (CL:LET*
   ((TEST-VALUE-001 (TRANSLATOR-OUTPUT-LANGUAGE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-WALK-COMMON-LISP)
     (CL:SETQ
      TREE
      (LIST*
       SYM-WALK-SYS-SPECIAL
       (CONS
        (LIST* SYM-WALK-*PENDINGEXCEPTIONHANDLER?* SYM-WALK-TRUE NIL)
        NIL)
       (LIST*
        (INTERN-COMMON-LISP-SYMBOL "CATCH")
        SYM-WALK-*EXCEPTIONHANDLERADDRESS*
        (LIST*
         SYM-WALK-PROGN
         TREE
         (CONS
          (LIST* SYM-WALK-SETQ SYM-WALK-*EXCEPTION* SYM-WALK-NULL NIL)
          NIL))
        NIL)
       NIL)))
    ((CL:EQ TEST-VALUE-001 KWD-WALK-CPP)
     (CL:IF
      (CL:EQ UNWINDPROTECT? 1)
      (CL:SETQ
       TREE
       (LIST*
        SYM-WALK-SYS-SPECIAL
        (CONS
         (LIST* SYM-WALK-*EXCEPTIONHANDLERADDRESS* SYM-WALK-NULL NIL)
         NIL)
        (LIST*
         SYM-WALK-WHEN
         (CL:IF
          (CL:EQ (LEXICALLY-VISIBLE-EXCEPTION-CASE?) 1)
          (LIST*
           SYM-WALK-SETUP-LONG-JUMP?
           SYM-WALK-*EXCEPTIONHANDLERADDRESS*
           NIL)
          (LIST*
           SYM-WALK-OR
           (LIST* SYM-WALK-NOT SYM-WALK-*PENDINGEXCEPTIONHANDLER?* NIL)
           (LIST*
            SYM-WALK-SETUP-LONG-JUMP?
            SYM-WALK-*EXCEPTIONHANDLERADDRESS*
            NIL)
           NIL))
         (CONS
          TREE
          (CONS
           (LIST* SYM-WALK-SETQ SYM-WALK-*EXCEPTION* SYM-WALK-NULL NIL)
           NIL)))
        NIL))
      (CL:SETQ
       TREE
       (LIST*
        SYM-WALK-SYS-SPECIAL
        (LIST*
         (LIST* SYM-WALK-*EXCEPTIONHANDLERADDRESS* SYM-WALK-NULL NIL)
         (LIST* SYM-WALK-*PENDINGEXCEPTIONHANDLER?* SYM-WALK-TRUE NIL)
         NIL)
        (LIST*
         SYM-WALK-WHEN
         (LIST*
          SYM-WALK-SETUP-LONG-JUMP?
          SYM-WALK-*EXCEPTIONHANDLERADDRESS*
          NIL)
         TREE
         (CONS
          (LIST* SYM-WALK-SETQ SYM-WALK-*EXCEPTION* SYM-WALK-NULL NIL)
          NIL))
        NIL))))
    (CL:T
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING
         " 'exception-case' not yet implemented for `"
         %%STREAM)
        (PRINT-OBJECT (TRANSLATOR-OUTPUT-LANGUAGE) %%STREAM)
        (CL:WRITE-STRING "'." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     (CL:RETURN-FROM YIELD-PROTECTED-STATEMENT-TREE NULL))))
  (CL:RETURN-FROM YIELD-PROTECTED-STATEMENT-TREE TREE)
  :VOID)

;;; (DEFUN (YIELD-EXCEPTION-HANDLER-TREE CONS) ...)

(CL:DEFUN YIELD-EXCEPTION-HANDLER-TREE (TREE)
  (CL:LET*
   ((CLAUSES NIL)
    (LASTCLAUSE (LAST TREE))
    (EXCEPTIONTYPE NULL)
    (EXCEPTIONVARIABLESPEC NULL)
    (EXCEPTIONVARIABLE NULL)
    (NOEXCEPTIONCLAUSE? FALSE)
    (NEEDRESIGNAL? TRUE))
   (CL:LET*
    ((CLAUSE NULL) (ITER-001 TREE))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ CLAUSE (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:LET*
      ((CLAUSE-001 CLAUSE))
      (CL:COND
       ((CL:EQ (CONS? CLAUSE) 1)
        (CL:LET*
         ((CLAUSE NULL))
         (CL:SETQ CLAUSE CLAUSE-001)
         (CL:WHEN
          (CL:< (LENGTH CLAUSE) 2)
          (CL:LET*
           ((*PRINTREADABLY?* TRUE))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN
            (CL:EQ (SUPPRESS-WARNINGS?) 0)
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
            (CL:LET
             ((%%STREAM
               (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM)
             (CL:WRITE-STRING " Illegal exception handler clause: `" %%STREAM)
             (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE CLAUSE) %%STREAM)
             (CL:WRITE-STRING "'." %%STREAM)
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM))))
          (CL:RETURN-FROM YIELD-EXCEPTION-HANDLER-TREE NULL))
         (CL:SETQ EXCEPTIONTYPE (FIRST CLAUSE))
         (CL:WHEN
          (CL:EQ FALSE 1)
          (CL:WHEN
           (CL:NOT (CL:EQ CLAUSE LASTCLAUSE))
           (CL:LET*
            ((*PRINTREADABLY?* TRUE))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-ERROR)
            (CL:WHEN
             (CL:EQ (SUPPRESS-WARNINGS?) 0)
             (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
             (CL:LET
              ((%%STREAM
                (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING
               " Premature 'no-exception' clause in 'exception-case'"
               %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING "    `" %%STREAM)
              (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE CLAUSE) %%STREAM)
              (CL:WRITE-STRING "'." %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM))))
           (CL:RETURN-FROM YIELD-EXCEPTION-HANDLER-TREE NULL))
          (FIRST-SETTER CLAUSE SYM-WALK-PROGN)
          (CL:SETQ NOEXCEPTIONCLAUSE? TRUE)
          (CL:RETURN))
         (CL:WHEN
          (CL:EQ (SYMBOL? EXCEPTIONTYPE) 0)
          (CL:LET*
           ((*PRINTREADABLY?* TRUE))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN
            (CL:EQ (SUPPRESS-WARNINGS?) 0)
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
            (CL:LET
             ((%%STREAM
               (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM)
             (CL:WRITE-STRING " Illegal exception type: `" %%STREAM)
             (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE EXCEPTIONTYPE) %%STREAM)
             (CL:WRITE-STRING "'." %%STREAM)
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM))))
          (CL:RETURN-FROM YIELD-EXCEPTION-HANDLER-TREE NULL))
         (CL:SETQ EXCEPTIONTYPE (TYPIFY EXCEPTIONTYPE))
         (CL:WHEN
          (CL:EQ (TYPE-TO-CLASS EXCEPTIONTYPE) NULL)
          (CL:LET*
           ((*PRINTREADABLY?* TRUE))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN
            (CL:EQ (SUPPRESS-WARNINGS?) 0)
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
            (CL:LET
             ((%%STREAM
               (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM)
             (CL:WRITE-STRING " Undefined exception type: `" %%STREAM)
             (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE EXCEPTIONTYPE) %%STREAM)
             (CL:WRITE-STRING "'." %%STREAM)
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM))))
          (CL:RETURN-FROM YIELD-EXCEPTION-HANDLER-TREE NULL))
         (CL:WHEN
          (CL:EQ (SUBTYPE-OF? EXCEPTIONTYPE SGT-WALK-EXCEPTION) 0)
          (CL:LET*
           ((*PRINTREADABLY?* TRUE))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN
            (CL:EQ (SUPPRESS-WARNINGS?) 0)
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
            (CL:LET
             ((%%STREAM
               (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM)
             (CL:WRITE-STRING " Exception type `" %%STREAM)
             (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE EXCEPTIONTYPE) %%STREAM)
             (CL:WRITE-STRING "' is not a subtype of EXCEPTION." %%STREAM)
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM))))
          (CL:RETURN-FROM YIELD-EXCEPTION-HANDLER-TREE NULL))
         (CL:SETQ EXCEPTIONVARIABLESPEC (SECOND CLAUSE))
         (CL:WHEN
          (CL:OR
           (CL:EQ (CONS? EXCEPTIONVARIABLESPEC) 0)
           (CL:> (LENGTH EXCEPTIONVARIABLESPEC) 1)
           (CL:AND
            (CL:= (LENGTH EXCEPTIONVARIABLESPEC) 1)
            (CL:EQ (SYMBOL? (FIRST EXCEPTIONVARIABLESPEC)) 0)))
          (CL:LET*
           ((*PRINTREADABLY?* TRUE))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN
            (CL:EQ (SUPPRESS-WARNINGS?) 0)
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
            (CL:LET
             ((%%STREAM
               (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM)
             (CL:WRITE-STRING
              " Illegal exception variable specification: `"
              %%STREAM)
             (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE CLAUSE) %%STREAM)
             (CL:WRITE-STRING "'." %%STREAM)
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM))))
          (CL:RETURN-FROM YIELD-EXCEPTION-HANDLER-TREE NULL))
         (CL:SETQ EXCEPTIONVARIABLE (FIRST EXCEPTIONVARIABLESPEC))
         (CL:SETQ CLAUSE (CLSYS-SVAL CONS REST CLAUSE))
         (CL:COND
          ((CL:EQ EXCEPTIONTYPE SGT-WALK-EXCEPTION)
           (CL:SETQ NEEDRESIGNAL? FALSE)
           (FIRST-SETTER CLAUSE SYM-WALK-TRUE))
          (CL:T
           (FIRST-SETTER
            CLAUSE
            (LIST*
             SYM-WALK-SUBTYPE-OF?
             SYM-WALK-*EXCEPTION-TYPE*
             EXCEPTIONTYPE
             NIL))))
         (CL:WHEN
          (CL:NOT (CL:EQ EXCEPTIONVARIABLE NULL))
          (CL:SETF
           (CLSYS-SVAL CONS REST CLAUSE)
           (CONS
            (LIST*
             SYM-WALK-LET
             (CONS
              (CONS
               EXCEPTIONVARIABLE
               (CONS EXCEPTIONTYPE (CONS SYM-WALK-*EXCEPTION* NIL)))
              NIL)
             (CONCATENATE (CLSYS-SVAL CONS REST CLAUSE) NIL))
            NIL)))
         (CL:SETQ CLAUSES (CONS CLAUSE CLAUSES))))
       (CL:T
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN
          (CL:EQ (SUPPRESS-WARNINGS?) 0)
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING " Illegal exception handler clause: `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
           (CL:WRITE-STRING "'." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))))
        (CL:RETURN-FROM YIELD-EXCEPTION-HANDLER-TREE NULL))))))
   (CL:SETQ
    CLAUSES
    (CONS
     SYM-WALK-COND
     (CONCATENATE
      (REVERSE CLAUSES)
      (CONCATENATE
       (CL:IF
        (CL:EQ NEEDRESIGNAL? 1)
        (CONS (LIST* SYM-WALK-OTHERWISE (CONS SYM-WALK-RESIGNAL NIL) NIL) NIL)
        NIL)
       NIL))))
   (CL:IF
    (CL:EQ NOEXCEPTIONCLAUSE? 1)
    (CL:RETURN-FROM
     YIELD-EXCEPTION-HANDLER-TREE
     (LIST*
      SYM-WALK-IF
      (LIST* SYM-WALK-DEFINED? SYM-WALK-*EXCEPTION* NIL)
      CLAUSES
      (CONS LASTCLAUSE NIL)))
    (CL:RETURN-FROM
     YIELD-EXCEPTION-HANDLER-TREE
     (LIST*
      SYM-WALK-WHEN
      (LIST* SYM-WALK-DEFINED? SYM-WALK-*EXCEPTION* NIL)
      CLAUSES
      NIL))))
  :VOID)

;;; (DEFUN WALK-VERBATIM-DEFINITION-TREE ...)

(CL:DEFUN WALK-VERBATIM-DEFINITION-TREE (TREE)
  (CL:LET*
   ((SELF-001 (NEW-TRANSLATION-UNIT)))
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF-001) SYM-WALK-VERBATIM)
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER SELF-001) TREE)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-001))
  :VOID)

;;; (DEFUN WALK-VERBATIM-UNIT ...)

(CL:DEFUN WALK-VERBATIM-UNIT (UNIT)
  (CL:SETF
   (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT)
   (WALK-A-TREE (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT)))
  (CL:COND
   ((CL:NOT (CL:EQ (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT) NULL))
    (PUSH *TRANSLATIONUNITS* UNIT)
    (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT) NULL))
   (CL:T
    (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CODE-REGISTER UNIT) NULL)
    (FREE UNIT)))
  :VOID)

;;; (DEFUN (WALK-VERBATIM-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-VERBATIM-TREE (TREE)
  (CL:LET*
   ((SELF-001 (NEW-PROPERTY-LIST)))
   (CL:SETF
    (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF-001)
    (CLSYS-SVAL CONS REST TREE))
   (CL:LET*
    ((OPTIONS SELF-001)
     (VERBATIMTREE (LOOKUP OPTIONS (TRANSLATOR-OUTPUT-LANGUAGE))))
    (CL:WHEN
     (CL:EQ VERBATIMTREE NULL)
     (CL:SETQ VERBATIMTREE (LOOKUP OPTIONS KWD-WALK-OTHERWISE))
     (CL:WHEN
      (CL:EQ VERBATIMTREE NULL)
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN
        (CL:EQ (SUPPRESS-WARNINGS?) 0)
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING " Verbatim statement has no `" %%STREAM)
         (PRINT-OBJECT (TRANSLATOR-OUTPUT-LANGUAGE) %%STREAM)
         (CL:WRITE-STRING "' option.." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))))
      (CL:RETURN-FROM WALK-VERBATIM-TREE (CL:VALUES NULL SGT-WALK-UNKNOWN)))
     (CL:WHEN
      (CL:NOT (CL:EQ VERBATIMTREE SYM-WALK-NULL))
      (CL:RETURN-FROM WALK-VERBATIM-TREE (WALK-A-TREE VERBATIMTREE))))
    (CL:WHEN
     (CL:EQ VERBATIMTREE SYM-WALK-NULL)
     (FREE-PARSE-TREE TREE)
     (CL:RETURN-FROM WALK-VERBATIM-TREE (CL:VALUES NULL SGT-WALK-UNKNOWN)))
    (CL:LET*
     ((VERBATIMTREE-001 VERBATIMTREE))
     (CL:COND
      ((CL:EQ (STRING? VERBATIMTREE) 1)
       (CL:LET*
        ((VERBATIMTREE NULL))
        (CL:SETQ VERBATIMTREE VERBATIMTREE-001)
        (INSERT-AT
         OPTIONS
         (TRANSLATOR-OUTPUT-LANGUAGE)
         (NEW-VERBATIM-STRING-WRAPPER
          (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VERBATIMTREE)))))
      (CL:T NULL)))
    (CL:RETURN-FROM WALK-VERBATIM-TREE (CL:VALUES TREE SGT-WALK-UNKNOWN))))
  :VOID)

;;; (DEFUN WALK-DEFMODULE-TREE ...)

(CL:DEFUN WALK-DEFMODULE-TREE (TREE)
  (CL:LET*
   ((SELF-001 (NEW-TRANSLATION-UNIT)))
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT CATEGORY SELF-001) SYM-WALK-MODULE)
   (CL:SETF (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT SELF-001) TREE)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-001))
  (CL:LET*
   ((MODULE NULL) (MODULENAME (COERCE-TO-MODULE-NAME (SECOND TREE) FALSE)))
   (CL:WHEN
    (CL:EQ MODULENAME NULL)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Illegal module name: `" %%STREAM)
       (PRINT-OBJECT (SECOND TREE) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (FREE *CURRENTTRANSLATIONUNIT*)
    (CL:SETQ *CURRENTTRANSLATIONUNIT* NULL)
    (CL:RETURN-FROM WALK-DEFMODULE-TREE))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* FALSE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:SETQ
     MODULE
     (DEFINE-MODULE
      MODULENAME
      (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))))
   (CL:SETF
    (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT *CURRENTTRANSLATIONUNIT*)
    MODULE)
   (CL:SETF (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)) NIL)
   (FREE-CONS-LIST TREE))
  :VOID)

;;; (DEFUN WALK-MODULE-UNIT ...)

(CL:DEFUN WALK-MODULE-UNIT (UNIT)
  (CL:LET*
   ((MODULE (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT)) (TREE NULL))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* TRUE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:SETQ
     TREE
     (LIST*
      SYM-WALK-STARTUP-TIME-PROGN
      KWD-WALK-MODULES
      (YIELD-DEFINE-MODULE MODULE)
      NIL)))
   (WALK-AUXILIARY-TREE TREE))
  :VOID)

;;; (DEFUN (EXTRACT-REQUIRED-ARGUMENT-VALUES CONS) ...)

(CL:DEFUN EXTRACT-REQUIRED-ARGUMENT-VALUES (CLASS SLOTNAMESANDVALUES)
  (CL:LET*
   ((REQUIREDVALUES NIL))
   (CL:LET*
    ((SNAME NULL)
     (ITER-001
      (CLSYS-SVAL LIST THE-CONS-LIST (CLASS-REQUIRED-SLOT-NAMES CLASS))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SNAME (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:LET*
      ((VALUEREF (LOOKUP SLOTNAMESANDVALUES SNAME)))
      (CL:IF
       (CL:NOT (CL:EQ VALUEREF NULL))
       (CL:PROGN
        (CL:SETQ
         REQUIREDVALUES
         (CONS
          (WALK-EXPRESSION-TREE
           VALUEREF
           (COMPUTE-RETURN-TYPE-SPEC (LOOKUP-SLOT CLASS SNAME) CLASS)
           SYM-WALK-NEW
           FALSE)
          REQUIREDVALUES))
        (REMOVE-AT SLOTNAMESANDVALUES SNAME))
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN
         (CL:EQ (SUPPRESS-WARNINGS?) 0)
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:WRITE-STRING " Missing required argument: `" %%STREAM)
          (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE SNAME) %%STREAM)
          (CL:WRITE-STRING "'." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))))))))
   (CL:RETURN-FROM EXTRACT-REQUIRED-ARGUMENT-VALUES (REVERSE REQUIREDVALUES)))
  :VOID)

;;; (DEFUN (YIELD-NEW-ARGUMENTS-TREE CONS CONS) ...)

(CL:DEFUN YIELD-NEW-ARGUMENTS-TREE (KEYWORDSANDVALUES CLASS SELFVARIABLE)
  (CL:WHEN
   (CL:EQ (ODD? (LENGTH KEYWORDSANDVALUES)) 1)
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING
       " Odd number of arguments in 'new' expression: `"
       %%STREAM)
      (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE KEYWORDSANDVALUES) %%STREAM)
      (CL:WRITE-STRING "'." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))))
   (CL:RETURN-FROM YIELD-NEW-ARGUMENTS-TREE (CL:VALUES NIL NIL)))
  (CL:LET*
   ((SELF-001 (NEW-PROPERTY-LIST)))
   (CL:SETF (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF-001) KEYWORDSANDVALUES)
   (CL:LET*
    ((PLIST SELF-001)
     (OTHERASSIGNMENTS NIL)
     (REQUIREDVALUES NULL)
     (SLOT NULL))
    (CL:LET*
     ((IT (ALLOCATE-ITERATOR PLIST)))
     (CL:LOOP
      WHILE
      (CL:EQ (NEXT? IT) 1)
      DO
      (KEY-SETTER
       IT
       (INTERN-SYMBOL
        (CLSYS-SVAL
         KEYWORD
         SYMBOL-NAME
         (CLSYS-SVAL PROPERTY-LIST-ITERATOR KEY IT))))))
    (CL:SETQ REQUIREDVALUES (EXTRACT-REQUIRED-ARGUMENT-VALUES CLASS PLIST))
    (CL:LET*
     ((VALUEREF NULL)
      (SLOTNAME NULL)
      (ITER-001 (CLSYS-SVAL PROPERTY-LIST THE-PLIST PLIST))
      (COLLECT-001 NULL))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:SETQ SLOTNAME (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:PROGN
       (CL:SETQ
        VALUEREF
        (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST ITER-001)))
       (CL:SETQ
        ITER-001
        (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST ITER-001))))
      (CL:SETQ SLOT (LOOKUP-SLOT CLASS SLOTNAME))
      (CL:WHEN
       (CL:EQ SLOT NULL)
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN
         (CL:EQ (SUPPRESS-WARNINGS?) 0)
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:WRITE-STRING " No such slot `" %%STREAM)
          (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE SLOTNAME) %%STREAM)
          (CL:WRITE-STRING "' on the class `" %%STREAM)
          (CL:WRITE-STRING (CLASS-NAME CLASS) %%STREAM)
          (CL:WRITE-STRING "'." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))))
       (CL:RETURN-FROM YIELD-NEW-ARGUMENTS-TREE (CL:VALUES NIL NIL)))
      (CL:WHEN
       (CL:EQ (STORAGE-SLOT? SLOT) 0)
       (CL:LET*
        ((METHOD SLOT))
        (CL:WHEN
         (CL:NOT
          (CL:EQ (DYNAMIC-SLOT-VALUE METHOD SYM-WALK-STORAGE-SLOT NULL) NULL))
         (CL:SETQ
          SLOT
          (LOOKUP-SLOT
           CLASS
           (DYNAMIC-SLOT-VALUE METHOD SYM-WALK-STORAGE-SLOT NULL))))))
      (CL:IF
       (CL:EQ COLLECT-001 NULL)
       (CL:PROGN
        (CL:SETQ
         COLLECT-001
         (CONS
          (LIST*
           SYM-WALK-SETF
           (CONS (CLSYS-SVAL SLOT SLOT-NAME SLOT) (CONS SELFVARIABLE NIL))
           VALUEREF
           NIL)
          NIL))
        (CL:IF
         (CL:EQ OTHERASSIGNMENTS NIL)
         (CL:SETQ OTHERASSIGNMENTS COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST OTHERASSIGNMENTS COLLECT-001)))
       (CL:PROGN
        (CL:SETF
         (CLSYS-SVAL CONS REST COLLECT-001)
         (CONS
          (LIST*
           SYM-WALK-SETF
           (CONS (CLSYS-SVAL SLOT SLOT-NAME SLOT) (CONS SELFVARIABLE NIL))
           VALUEREF
           NIL)
          NIL))
        (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
    (CL:RETURN-FROM
     YIELD-NEW-ARGUMENTS-TREE
     (CL:VALUES REQUIREDVALUES OTHERASSIGNMENTS))))
  :VOID)

;;; (DEFUN (WALK-NEW-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-NEW-TREE (TREE)
  (CL:LET*
   ((OPERATOR (FIRST TREE))
    (CLASSTREE (SECOND TREE))
    (BASECLASSNAME
     (CL:IF (CL:EQ (CONS? CLASSTREE) 1) (FIRST CLASSTREE) CLASSTREE))
    (KEYWORDARGUMENTS (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
    (SELFVARIABLE (LOCAL-GENSYM "SELF"))
    (CLASSTYPE NULL)
    (NEWTREE NULL))
   (CL:WHEN
    (CL:AND
     (CL:EQ (SYMBOL? BASECLASSNAME) 0)
     (CL:EQ (KEYWORD? BASECLASSNAME) 0))
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Illegal argument to `" %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE OPERATOR) %%STREAM)
       (CL:WRITE-STRING "' where symbol expected:  `" %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE BASECLASSNAME) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))))
   (CL:SETQ CLASSTYPE (YIELD-TYPE-SPECIFIER CLASSTREE))
   (FREE-CONS (CLSYS-SVAL CONS REST TREE))
   (FREE-CONS TREE)
   (CL:LET*
    ((REQUIREDARGS NULL) (OTHERASSIGNMENTS NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (REQUIREDARGS OTHERASSIGNMENTS)
     (YIELD-NEW-ARGUMENTS-TREE
      KEYWORDARGUMENTS
      (GET-CLASS
       (CL:IF
        (CL:EQ (TYPE? CLASSTYPE) 1)
        CLASSTYPE
        (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE CLASSTYPE))
       TRUE)
      SELFVARIABLE))
    (CL:SETQ
     NEWTREE
     (LIST* SYM-WALK-SYS-NEW CLASSTYPE (CONCATENATE REQUIREDARGS NIL)))
    (CL:IF
     (CL:EQ OTHERASSIGNMENTS NIL)
     (CL:RETURN-FROM WALK-NEW-TREE (CL:VALUES NEWTREE CLASSTYPE))
     (CL:RETURN-FROM
      WALK-NEW-TREE
      (CL:VALUES
       (LIST*
        SYM-WALK-VRLET
        (CONS (CONS SELFVARIABLE (CONS NEWTREE NIL)) NIL)
        (CONCATENATE OTHERASSIGNMENTS (CONS SELFVARIABLE NIL)))
       CLASSTYPE)))))
  :VOID)

;;; (DEFUN (WALK-MAKE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-MAKE-TREE (TREE)
  (CL:LET*
   ((CLASSNAME (SECOND TREE)) (TYPE NULL))
   (BAD-ARGUMENT-COUNT? TREE 1)
   (CL:COND
    ((CL:EQ (SYMBOL? CLASSNAME) 1) NULL)
    ((CL:EQ (TYPE? CLASSNAME) 1)
     (SECOND-SETTER TREE (TYPE-TO-SYMBOL CLASSNAME)))
    (CL:T
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " Bad argument to 'make':" %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING "   `" %%STREAM)
        (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE CLASSNAME) %%STREAM)
        (CL:WRITE-STRING "' found where symbol expected." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     (CL:RETURN-FROM
      WALK-MAKE-TREE
      (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-UNKNOWN))))
   (CL:SETQ TYPE (TYPIFY CLASSNAME))
   (CL:WHEN
    (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE) NULL)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Reference to undefined class `" %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE CLASSNAME) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (CL:RETURN-FROM
     WALK-MAKE-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-UNKNOWN)))
   (CL:RETURN-FROM WALK-MAKE-TREE (CL:VALUES TREE TYPE)))
  :VOID)

;;; (DEFUN (WALK-FUNCALL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-FUNCALL-TREE (TREE)
  (CL:WHEN
   (CL:OR
    (CL:EQ (FIRST TREE) SYM-WALK-SYS-CALL-FUNCTION-CODE)
    (CL:EQ (FIRST TREE) SYM-WALK-SYS-CALL-METHOD-CODE))
   (CL:RETURN-FROM
    WALK-FUNCALL-TREE
    (CL:VALUES TREE (FIRST (FIRST (SECOND TREE))))))
  (CL:LET*
   ((RETURNTYPE
     (CL:IF
      (CL:EQ *TARGETTYPE* SGT-WALK-UNKNOWN)
      SGT-WALK-VOID
      (TYPE-SPEC-TO-BASE-TYPE *TARGETTYPE*)))
    (SIGNATURE (CONS (CONS RETURNTYPE NIL) NIL)))
   (CL:LET*
    ((OTREE NULL) (OTYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (OTREE OTYPE)
     (WALK-EXPRESSION-TREE (SECOND TREE) SGT-WALK-CODE SYM-WALK-FUNCALL TRUE))
    (FIRST-SETTER
     TREE
     (CL:IF
      (CL:EQ OTYPE SGT-WALK-METHOD-CODE)
      SYM-WALK-SYS-CALL-METHOD-CODE
      SYM-WALK-SYS-CALL-FUNCTION-CODE))
    (SECOND-SETTER TREE OTREE))
   (CL:LET*
    ((IT
      (ALLOCATE-ITERATOR (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? IT) 1)
     DO
     (CL:LET*
      ((ARGTREE NULL) (ARGTYPE NULL))
      (CL:MULTIPLE-VALUE-SETQ
       (ARGTREE ARGTYPE)
       (WALK-A-TREE (CLSYS-SVAL CONS-ITERATOR VALUE IT)))
      (VALUE-SETTER IT ARGTREE)
      (CL:SETQ SIGNATURE (CONS (TYPE-SPEC-TO-BASE-TYPE ARGTYPE) SIGNATURE))
      (FREE-TRANSIENT-TYPE-SPEC ARGTYPE))))
   (CL:SETF
    (CLSYS-SVAL CONS REST TREE)
    (CONS (REVERSE SIGNATURE) (CLSYS-SVAL CONS REST TREE)))
   (CL:RETURN-FROM WALK-FUNCALL-TREE (CL:VALUES TREE RETURNTYPE)))
  :VOID)

;;; (DEFUN (WALK-THE-CODE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-THE-CODE-TREE (TREE)
  (CL:LET*
   ((TEST-VALUE-001 (SECOND TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-WALK-FUNCTION)
     (CL:WHEN
      (CL:EQ (BAD-ARGUMENT-COUNT? TREE 2) 1)
      (CL:RETURN-FROM
       WALK-THE-CODE-TREE
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-FUNCTION-CODE)))
     (CL:LET*
      ((TEST-VALUE-002 (TRANSLATOR-OUTPUT-LANGUAGE)))
      (CL:COND
       ((CL:OR
         (CL:EQ TEST-VALUE-002 KWD-WALK-CPP)
         (CL:EQ TEST-VALUE-002 KWD-WALK-CPP-STANDALONE))
        (CL:WHEN
         (CL:EQ (THIRD TREE) SYM-WALK-MAIN)
         (CL:LET*
          ((*PRINTREADABLY?* TRUE))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-WARNING)
          (CL:WHEN
           (CL:EQ (SUPPRESS-WARNINGS?) 0)
           (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
           (CL:LET
            ((%%STREAM
              (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM)
            (CL:WRITE-STRING
             " Cannot generate function pointer to main."
             %%STREAM)
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM))))
         (CL:LET*
          ((VALUE-001 NULL) (VALUE-002 NULL))
          (CL:MULTIPLE-VALUE-SETQ
           (VALUE-001 VALUE-002)
           (WALK-A-TREE
            (LIST* SYM-WALK-CAST SYM-WALK-NULL SYM-WALK-FUNCTION-CODE NIL)))
          (CL:RETURN-FROM
           WALK-THE-CODE-TREE
           (CL:VALUES VALUE-001 VALUE-002)))))
       (CL:T NULL)))
     (CL:RETURN-FROM
      WALK-THE-CODE-TREE
      (CL:VALUES TREE SGT-WALK-FUNCTION-CODE)))
    ((CL:EQ TEST-VALUE-001 KWD-WALK-METHOD)
     (CL:WHEN
      (CL:EQ (BAD-ARGUMENT-COUNT? TREE 3) 1)
      (CL:RETURN-FROM
       WALK-THE-CODE-TREE
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-METHOD-CODE)))
     (CL:LET*
      ((TYPE (TYPIFY (THIRD TREE))))
      (THIRD-SETTER TREE TYPE)
      (CL:IF
       (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE) NULL)
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN
         (CL:EQ (SUPPRESS-WARNINGS?) 0)
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:WRITE-STRING " No class defined for the type: `" %%STREAM)
          (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TYPE) %%STREAM)
          (CL:WRITE-STRING "'." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))))
       (CL:LET*
        ((TEST-VALUE-003 (TRANSLATOR-OUTPUT-LANGUAGE)))
        (CL:COND
         ((CL:OR
           (CL:EQ TEST-VALUE-003 KWD-WALK-CPP)
           (CL:EQ TEST-VALUE-003 KWD-WALK-CPP-STANDALONE))
          (CL:WHEN
           (CL:EQ (SUBTYPE-OF? TYPE SGT-WALK-LITERAL) 1)
           (CL:LET*
            ((*PRINTREADABLY?* TRUE))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-WARNING)
            (CL:WHEN
             (CL:EQ (SUPPRESS-WARNINGS?) 0)
             (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
             (CL:LET
              ((%%STREAM
                (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING
               " Cannot have methods on literals in `"
               %%STREAM)
              (PRINT-OBJECT (TRANSLATOR-OUTPUT-LANGUAGE) %%STREAM)
              (CL:WRITE-STRING "', hence, cannot generate" %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING " a method-code pointer for `" %%STREAM)
              (PRINT-OBJECT (THIRD TREE) %%STREAM)
              (CL:WRITE-STRING "'.`" %%STREAM)
              (PRINT-OBJECT (FOURTH TREE) %%STREAM)
              (CL:WRITE-STRING "'." %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM))))
           (CL:LET*
            ((VALUE-003 NULL) (VALUE-004 NULL))
            (CL:MULTIPLE-VALUE-SETQ
             (VALUE-003 VALUE-004)
             (WALK-A-TREE
              (LIST* SYM-WALK-CAST SYM-WALK-NULL SYM-WALK-METHOD-CODE NIL)))
            (CL:RETURN-FROM
             WALK-THE-CODE-TREE
             (CL:VALUES VALUE-003 VALUE-004))))
          (CL:WHEN
           (CL:EQ (SUBTYPE-OF? TYPE SGT-WALK-OBJECT) 0)
           (CL:LET*
            ((*PRINTREADABLY?* TRUE))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-WARNING)
            (CL:WHEN
             (CL:EQ (SUPPRESS-WARNINGS?) 0)
             (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
             (CL:LET
              ((%%STREAM
                (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING
               " Cannot store a method-code pointer for "
               %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING " `" %%STREAM)
              (PRINT-OBJECT (THIRD TREE) %%STREAM)
              (CL:WRITE-STRING "'.`" %%STREAM)
              (PRINT-OBJECT (FOURTH TREE) %%STREAM)
              (CL:WRITE-STRING "'" %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING
               " since it is not defined on a subtype of @OBJECT."
               %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM))))
           (CL:LET*
            ((VALUE-005 NULL) (VALUE-006 NULL))
            (CL:MULTIPLE-VALUE-SETQ
             (VALUE-005 VALUE-006)
             (WALK-A-TREE
              (LIST* SYM-WALK-CAST SYM-WALK-NULL SYM-WALK-METHOD-CODE NIL)))
            (CL:RETURN-FROM
             WALK-THE-CODE-TREE
             (CL:VALUES VALUE-005 VALUE-006)))))
         (CL:T NULL))))
      (CL:RETURN-FROM
       WALK-THE-CODE-TREE
       (CL:VALUES TREE SGT-WALK-METHOD-CODE))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
  :VOID)

;;; (DEFUN (DE-UGLIFY-ARGUMENTS CONS) ...)

(CL:DEFUN DE-UGLIFY-ARGUMENTS (UGLYARGUMENTS)
  (CL:LET*
   ((PRETTYARGUMENTS NIL))
   (CL:LET*
    ((ARG NULL) (ITER-001 UGLYARGUMENTS) (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (CONS (DE-UGLIFY-PARSE-TREE ARG) NIL))
       (CL:IF
        (CL:EQ PRETTYARGUMENTS NIL)
        (CL:SETQ PRETTYARGUMENTS COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST PRETTYARGUMENTS COLLECT-001)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-001)
        (CONS (DE-UGLIFY-PARSE-TREE ARG) NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:RETURN-FROM DE-UGLIFY-ARGUMENTS PRETTYARGUMENTS))
  :VOID)

;;; (DEFUN (DE-UGLIFY-PARSE-TREE OBJECT) ...)

(CL:DEFUN DE-UGLIFY-PARSE-TREE (TREE)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:LET*
       ((OPERATOR (FIRST TREE)))
       (CL:WHEN
        (CL:EQ (SYMBOL? OPERATOR) 0)
        (CL:RETURN-FROM DE-UGLIFY-PARSE-TREE (DE-UGLIFY-ARGUMENTS TREE)))
       (CL:COND
        ((CL:OR
          (CL:EQ OPERATOR SYM-WALK-SYS-SLOT-VALUE)
          (CL:EQ OPERATOR SYM-WALK-SYS-SLOT-VALUE-SETTER)
          (CL:EQ OPERATOR SYM-WALK-SYS-CALL-METHOD))
         (CL:RETURN-FROM
          DE-UGLIFY-PARSE-TREE
          (DE-UGLIFY-PARSE-TREE
           (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))))
        ((CL:EQ OPERATOR SYM-WALK-SYS-CALL-FUNCTION)
         (CL:RETURN-FROM
          DE-UGLIFY-PARSE-TREE
          (DE-UGLIFY-PARSE-TREE (CLSYS-SVAL CONS REST TREE))))
        ((CL:OR
          (CL:EQ OPERATOR SYM-WALK-TYPED-SYS)
          (CL:EQ OPERATOR SYM-WALK-VOID-SYS)
          (CL:EQ OPERATOR SYM-WALK-BAD-SYS))
         (CL:RETURN-FROM
          DE-UGLIFY-PARSE-TREE
          (DE-UGLIFY-PARSE-TREE (SECOND TREE))))
        ((CL:EQ OPERATOR SYM-WALK-GET-SYM)
         (CL:RETURN-FROM
          DE-UGLIFY-PARSE-TREE
          (GET-SYM-FROM-OFFSET
           (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE (SECOND TREE)))))
        (CL:T
         (CL:LET*
          ((PRETTYARGUMENTS NIL))
          (CL:LET*
           ((ARG NULL)
            (ITER-001 (CLSYS-SVAL CONS REST TREE))
            (COLLECT-001 NULL))
           (CL:LOOP
            WHILE
            (CL:NOT (CL:EQ ITER-001 NIL))
            DO
            (CL:PROGN
             (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-001))
             (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
            (CL:IF
             (CL:EQ COLLECT-001 NULL)
             (CL:PROGN
              (CL:SETQ COLLECT-001 (CONS (DE-UGLIFY-PARSE-TREE ARG) NIL))
              (CL:IF
               (CL:EQ PRETTYARGUMENTS NIL)
               (CL:SETQ PRETTYARGUMENTS COLLECT-001)
               (ADD-CONS-TO-END-OF-CONS-LIST PRETTYARGUMENTS COLLECT-001)))
             (CL:PROGN
              (CL:SETF
               (CLSYS-SVAL CONS REST COLLECT-001)
               (CONS (DE-UGLIFY-PARSE-TREE ARG) NIL))
              (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
          (CL:RETURN-FROM
           DE-UGLIFY-PARSE-TREE
           (CONS OPERATOR (CONCATENATE PRETTYARGUMENTS NIL)))))))))
    ((CL:EQ (TAXONOMY-ISA? TREE SGT-WALK-COMPOUND-TYPE-SPECIFIER) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:LET*
       ((*TRANSIENTOBJECTS?* TRUE))
       (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
       (CL:RETURN-FROM DE-UGLIFY-PARSE-TREE (YIELD-TYPE-SPEC-TREE TREE)))))
    (CL:T (CL:RETURN-FROM DE-UGLIFY-PARSE-TREE TREE))))
  :VOID)

;;; (DEFGLOBAL *NATIVE-NAME-TABLE* ...)

(CL:DEFVAR *NATIVE-NAME-TABLE* NULL)

;;; (DEFUN REGISTER-NATIVE-NAME ...)

(CL:DEFUN REGISTER-NATIVE-NAME (NAME LANGUAGE CATEGORY)
  (CL:LET*
   ((TABLEENTRY (LOOKUP *NATIVE-NAME-TABLE* NAME)) (CATEGORIES NULL))
   (CL:WHEN (CL:EQ TABLEENTRY NULL) (CL:SETQ TABLEENTRY (NEW-KEY-VALUE-LIST)))
   (CL:SETQ CATEGORIES (LOOKUP TABLEENTRY LANGUAGE))
   (CL:WHEN (CL:EQ CATEGORIES NULL) (CL:SETQ CATEGORIES (NEW-LIST)))
   (INSERT-NEW CATEGORIES CATEGORY)
   (INSERT-AT TABLEENTRY LANGUAGE CATEGORIES)
   (INSERT-AT *NATIVE-NAME-TABLE* NAME TABLEENTRY))
  :VOID)

;;; (DEFUN (NATIVE-NAME? BOOLEAN) ...)

(CL:DEFUN NATIVE-NAME? (NAME LANGUAGE CATEGORY)
  (CL:LET*
   ((TABLEENTRY (LOOKUP *NATIVE-NAME-TABLE* NAME)) (CATEGORIES NULL))
   (CL:WHEN (CL:EQ TABLEENTRY NULL) (CL:RETURN-FROM NATIVE-NAME? FALSE))
   (CL:SETQ CATEGORIES (LOOKUP TABLEENTRY LANGUAGE))
   (CL:IF
    (CL:EQ CATEGORIES NULL)
    (CL:RETURN-FROM NATIVE-NAME? FALSE)
    (CL:RETURN-FROM NATIVE-NAME? (MEMBER? CATEGORIES CATEGORY))))
  :VOID)

;;; (DEFUN (YIELD-RENAMED-NAME-IF-NATIVE SYMBOL) ...)

(CL:DEFUN YIELD-RENAMED-NAME-IF-NATIVE (NAME LANGUAGE CATEGORY)
  (CL:IF
   (CL:EQ (NATIVE-NAME? NAME LANGUAGE CATEGORY) 1)
   (CL:LET*
    ((NEWNAME NULL))
    (CL:COND
     ((CL:EQ LANGUAGE KWD-WALK-COMMON-LISP)
      (CL:SETQ
       NEWNAME
       (INTERN-DERIVED-SYMBOL
        NAME
        (CONCATENATE "%%" (CLSYS-SVAL SYMBOL SYMBOL-NAME NAME)))))
     (CL:T
      (CL:SETQ
       NEWNAME
       (INTERN-DERIVED-SYMBOL
        NAME
        (CONCATENATE (CLSYS-SVAL SYMBOL SYMBOL-NAME NAME) "_")))))
    (CL:RETURN-FROM
     YIELD-RENAMED-NAME-IF-NATIVE
     (YIELD-RENAMED-NAME-IF-NATIVE NEWNAME LANGUAGE CATEGORY)))
   (CL:RETURN-FROM YIELD-RENAMED-NAME-IF-NATIVE NAME))
  :VOID)

;;; (DEFUN (METHOD-NEEDS-LISP-MACRO? BOOLEAN) ...)

(CL:DEFUN METHOD-NEEDS-LISP-MACRO? (METHOD)
  (CL:IF
   (CL:AND
    (CL:EQ (TRANSLATE-TO-COMMON-LISP?) 1)
    (CL:EQ (NON-EMPTY? (METHOD-PARAMETER-NAMES METHOD)) 1))
   (CL:LET*
    ((LISPMACRO? (METHOD-LISP-MACRO? METHOD)))
    (CL:RETURN-FROM
     METHOD-NEEDS-LISP-MACRO?
     (CL:IF
      (CL:OR
       (CL:AND (CL:EQ (DEFINED? LISPMACRO?) 1) (CL:EQ LISPMACRO? 1))
       (CL:AND
        (CL:EQ (COMMAND? METHOD) 1)
        (CL:EQ (METHOD-NATIVE? METHOD) 0)
        (CL:OR (CL:EQ (NULL? LISPMACRO?) 1) (CL:EQ LISPMACRO? 1))))
      TRUE
      FALSE)))
   (CL:RETURN-FROM METHOD-NEEDS-LISP-MACRO? FALSE))
  :VOID)

;;; (DEFUN (YIELD-LISP-MACRO-TREES CONS CONS) ...)

(CL:DEFUN YIELD-LISP-MACRO-TREES (NAME METHOD)
  (CL:LET*
   ((MODULE
     (CL:IF
      (CL:NOT (CL:EQ (CLSYS-SVAL SYMBOL HOME-CONTEXT NAME) NULL))
      (CLSYS-SVAL SYMBOL HOME-CONTEXT NAME)
      *MODULE*))
    (TRANSLATEDNAME
     (YIELD-GLOBAL-LISP-SYMBOL MODULE (CLSYS-SVAL SYMBOL SYMBOL-NAME NAME)))
    (TRANSLATEDFULLNAME
     (YIELD-GLOBAL-LISP-SYMBOL
      MODULE
      (COMPUTE-FULL-NAME (CLSYS-SVAL SYMBOL SYMBOL-NAME NAME) MODULE)))
    (DOCUMENTATION
     (CLSYS-SVAL
      STRING-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       METHOD
       SYM-WALK-DOCUMENTATION
       NULL-STRING-WRAPPER))))
   (CL:RETURN-FROM
    YIELD-LISP-MACRO-TREES
    (CL:VALUES
     (LIST*
      SYM-WALK-VERBATIM
      KWD-WALK-COMMON-LISP
      (LIST*
       (INTERN-COMMON-LISP-SYMBOL "DEFMACRO")
       TRANSLATEDNAME
       (CONS
        (LIST*
         (INTERN-COMMON-LISP-SYMBOL "&WHOLE")
         SYM-WALK-EXPRESSION
         (INTERN-COMMON-LISP-SYMBOL "&REST")
         SYM-WALK-IGNORE
         NIL)
        (CONCATENATE
         (CL:IF
          (CL:NOT (CL:EQ DOCUMENTATION NULL))
          (CONS (WRAP-LITERAL DOCUMENTATION) NIL)
          NIL)
         (LIST*
          (LIST*
           (INTERN-COMMON-LISP-SYMBOL "DECLARE")
           (LIST* (INTERN-COMMON-LISP-SYMBOL "IGNORE") SYM-WALK-IGNORE NIL)
           NIL)
          (LIST*
           (INTERN-COMMON-LISP-SYMBOL "LET")
           (CONS
            (LIST*
             SYM-WALK-*IGNORETRANSLATIONERRORS?*
             (CL:IF (CL:EQ (COMMAND? METHOD) 1) SYM-WALK-FALSE SYM-WALK-TRUE)
             NIL)
            NIL)
           (LIST*
            SYM-WALK-INCREMENTALLY-TRANSLATE
            SYM-WALK-EXPRESSION
            SYM-WALK-FALSE
            NIL)
           NIL)
          NIL))))
      KWD-WALK-OTHERWISE
      SYM-WALK-NULL
      NIL)
     (LIST*
      SYM-WALK-VERBATIM
      KWD-WALK-COMMON-LISP
      (LIST*
       SYM-WALK-SETF
       (LIST*
        (INTERN-COMMON-LISP-SYMBOL "MACRO-FUNCTION")
        (LIST* (INTERN-COMMON-LISP-SYMBOL "QUOTE") TRANSLATEDFULLNAME NIL)
        NIL)
       (LIST*
        (INTERN-COMMON-LISP-SYMBOL "MACRO-FUNCTION")
        (LIST* (INTERN-COMMON-LISP-SYMBOL "QUOTE") TRANSLATEDNAME NIL)
        NIL)
       NIL)
      KWD-WALK-OTHERWISE
      SYM-WALK-NULL
      NIL))))
  :VOID)

;;; (DEFUN CREATE-LISP-MACRO-UNITS ...)

(CL:DEFUN CREATE-LISP-MACRO-UNITS (NAME METHOD)
  (CL:WHEN
   (CL:EQ NAME (CLSYS-SVAL METHOD-SLOT SLOT-NAME METHOD))
   (REGISTER-NATIVE-NAME NAME KWD-WALK-COMMON-LISP KWD-WALK-FUNCTION))
  (CL:LET*
   ((MACROTREE NULL) (ALIASDEFINITIONTREE NULL))
   (CL:MULTIPLE-VALUE-SETQ
    (MACROTREE ALIASDEFINITIONTREE)
    (YIELD-LISP-MACRO-TREES NAME METHOD))
   (WALK-AUXILIARY-TREE MACROTREE)
   (WALK-AUXILIARY-TREE ALIASDEFINITIONTREE))
  (CL:WHEN
   (CL:EQ NAME (CLSYS-SVAL METHOD-SLOT SLOT-NAME METHOD))
   (CL:LET*
    ((STARTUPTREE NIL))
    (CL:LET*
     ((*TRANSIENTOBJECTS?* TRUE))
     (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
     (CL:SETQ
      STARTUPTREE
      (LIST*
       SYM-WALK-STARTUP-TIME-PROGN
       (LIST*
        SYM-WALK-REGISTER-NATIVE-NAME
        (LIST* SYM-WALK-QUOTE NAME NIL)
        KWD-WALK-COMMON-LISP
        KWD-WALK-FUNCTION
        NIL)
       NIL)))
    (WALK-AUXILIARY-TREE STARTUPTREE)))
  :VOID)

;;; (DEFUN (COMMAND? BOOLEAN) ...)

(CL:DEFUN COMMAND? (METHOD)
  "Return TRUE if 'method' is an evaluable command."
  (CL:RETURN-FROM
   COMMAND?
   (CL:IF
    (CL:AND
     (CL:EQ (METHOD-COMMAND? METHOD) 1)
     (CL:EQ (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? METHOD) 1))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (LOOKUP-COMMAND METHOD-SLOT) ...)

(CL:DEFUN LOOKUP-COMMAND (NAME)
  "If 'name' names an evaluable command return its associated
command object;  otherwise, return NULL.  Currently, commands are not
polymorphic, i.e., they can only be implemented by functions."
  (CL:LET*
   ((FUNCTION (LOOKUP-FUNCTION NAME)))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ FUNCTION NULL)) (CL:EQ (COMMAND? FUNCTION) 1))
    (CL:RETURN-FROM LOOKUP-COMMAND FUNCTION)
    (CL:RETURN-FROM LOOKUP-COMMAND NULL)))
  :VOID)

;;; (DEFUN (METHOD-MUST-BE-EVALUABLE? BOOLEAN) ...)

(CL:DEFUN METHOD-MUST-BE-EVALUABLE? (METHOD)
  (CL:RETURN-FROM
   METHOD-MUST-BE-EVALUABLE?
   (CL:IF
    (CL:AND (CL:EQ (COMMAND? METHOD) 1) (CL:EQ (METHOD-NATIVE? METHOD) 0))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (METHOD-NEEDS-EVALUATOR-WRAPPER? BOOLEAN) ...)

(CL:DEFUN METHOD-NEEDS-EVALUATOR-WRAPPER? (METHOD)
  (CL:LET*
   ((TEST-VALUE-001 FALSE))
   (CL:SETQ TEST-VALUE-001 (METHOD-MUST-BE-EVALUABLE? METHOD))
   (CL:WHEN
    (CL:EQ TEST-VALUE-001 1)
    (CL:IF
     (CL:EQ (METHOD-VARIABLE-ARGUMENTS? METHOD) 1)
     (CL:SETQ TEST-VALUE-001 TRUE)
     (CL:IF
      (CL:> (LENGTH (METHOD-PARAMETER-NAMES METHOD)) 5)
      (CL:SETQ TEST-VALUE-001 TRUE)
      (CL:IF
       (CL:> (LENGTH (METHOD-RETURN-TYPE-SPECIFIERS METHOD)) 1)
       (CL:SETQ TEST-VALUE-001 TRUE)
       (CL:IF
        (CL:EQ (SUBTYPE-OF? (TYPE METHOD) SGT-WALK-LITERAL) 1)
        (CL:SETQ TEST-VALUE-001 TRUE)
        (CL:LET*
         ((FOUND?-001 FALSE))
         (CL:LET*
          ((TSPEC NULL)
           (ITER-001
            (CLSYS-SVAL
             LIST
             THE-CONS-LIST
             (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))))
          (CL:LOOP
           WHILE
           (CL:NOT (CL:EQ ITER-001 NIL))
           DO
           (CL:PROGN
            (CL:SETQ TSPEC (CLSYS-SVAL CONS VALUE ITER-001))
            (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
           (CL:WHEN
            (CL:EQ
             (SUBTYPE-OF? (TYPE-SPEC-TO-BASE-TYPE TSPEC) SGT-WALK-LITERAL)
             1)
            (CL:SETQ FOUND?-001 TRUE)
            (CL:RETURN))))
         (CL:SETQ TEST-VALUE-001 FOUND?-001)))))))
   (CL:LET*
    ((VALUE-001 TEST-VALUE-001))
    (CL:RETURN-FROM METHOD-NEEDS-EVALUATOR-WRAPPER? VALUE-001)))
  :VOID)

;;; (DEFUN (YIELD-EVALUATOR-WRAPPER-NAME SYMBOL) ...)

(CL:DEFUN YIELD-EVALUATOR-WRAPPER-NAME (METHODNAME)
  (CL:RETURN-FROM
   YIELD-EVALUATOR-WRAPPER-NAME
   (INTERN-DERIVED-SYMBOL
    METHODNAME
    (CONCATENATE
     (CLSYS-SVAL SYMBOL SYMBOL-NAME METHODNAME)
     "-EVALUATOR-WRAPPER")))
  :VOID)

;;; (DEFUN (YIELD-ARGUMENT-ACCESS-TREE OBJECT) ...)

(CL:DEFUN YIELD-ARGUMENT-ACCESS-TREE (ARGUMENTSVARIABLE INDEX RESTARGUMENT?)
  (CL:LET*
   ((LIMIT 5) (ACCESSTREE ARGUMENTSVARIABLE))
   (CL:IF
    (CL:<= INDEX LIMIT)
    (CL:LET*
     ((I NULL)
      (ITER-001 2)
      (UPPER-BOUND-001 INDEX)
      (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
     (CL:LOOP
      WHILE
      (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
      DO
      (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
      (CL:SETQ ACCESSTREE (LIST* SYM-WALK-REST ACCESSTREE NIL))))
    (CL:SETQ
     ACCESSTREE
     (LIST*
      SYM-WALK-NTH-REST
      ACCESSTREE
      (CONS (WRAP-LITERAL (CL:1- INDEX)) NIL))))
   (CL:WHEN
    (CL:EQ RESTARGUMENT? 0)
    (CL:IF
     (CL:<= INDEX LIMIT)
     (CL:SETQ ACCESSTREE (LIST* SYM-WALK-VALUE ACCESSTREE NIL))
     (CL:SETF (CLSYS-SVAL CONS VALUE ACCESSTREE) SYM-WALK-NTH)))
   (CL:RETURN-FROM YIELD-ARGUMENT-ACCESS-TREE ACCESSTREE))
  :VOID)

;;; (DEFUN (YIELD-EVALUATOR-WRAPPER-TREE CONS) ...)

(CL:DEFUN YIELD-EVALUATOR-WRAPPER-TREE (METHOD)
  (CL:LET*
   ((*TRANSIENTOBJECTS?* TRUE))
   (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
   (CL:LET*
    ((NAMETREE
      (YIELD-EVALUATOR-WRAPPER-NAME
       (CLSYS-SVAL METHOD-SLOT SLOT-NAME METHOD)))
     (CALLTREE (CONS (CLSYS-SVAL METHOD-SLOT SLOT-NAME METHOD) NIL))
     (PARAMETERTYPESPECS (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))
     (RESULTTYPE (TYPE METHOD))
     (NOFPARAMETERS (LENGTH PARAMETERTYPESPECS))
     (VARIABLEARGUMENTS? (METHOD-VARIABLE-ARGUMENTS? METHOD)))
    (CL:LET*
     ((INDEX NULL)
      (ITER-001 1)
      (UPPER-BOUND-001 NOFPARAMETERS)
      (UNBOUNDED?-001 (NULL? UPPER-BOUND-001))
      (COLLECT-001 NULL))
     (CL:LOOP
      WHILE
      (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
      DO
      (CL:PROGN (CL:SETQ INDEX ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
      (CL:IF
       (CL:EQ COLLECT-001 NULL)
       (CL:PROGN
        (CL:SETQ
         COLLECT-001
         (CONS
          (YIELD-ARGUMENT-ACCESS-TREE
           SYM-WALK-ARGUMENTS
           INDEX
           (CL:IF
            (CL:AND (CL:EQ VARIABLEARGUMENTS? 1) (CL:= INDEX NOFPARAMETERS))
            TRUE
            FALSE))
          NIL))
        (CL:IF
         (CL:EQ CALLTREE NIL)
         (CL:SETQ CALLTREE COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST CALLTREE COLLECT-001)))
       (CL:PROGN
        (CL:SETF
         (CLSYS-SVAL CONS REST COLLECT-001)
         (CONS
          (YIELD-ARGUMENT-ACCESS-TREE
           SYM-WALK-ARGUMENTS
           INDEX
           (CL:IF
            (CL:AND (CL:EQ VARIABLEARGUMENTS? 1) (CL:= INDEX NOFPARAMETERS))
            TRUE
            FALSE))
          NIL))
        (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
    (CL:LET*
     ((PTYPE NULL)
      (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST PARAMETERTYPESPECS))
      (IT (ALLOCATE-ITERATOR (CLSYS-SVAL CONS REST CALLTREE))))
     (CL:LOOP
      WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-002 NIL)) (CL:EQ (NEXT? IT) 1))
      DO
      (CL:PROGN
       (CL:SETQ PTYPE (CLSYS-SVAL CONS VALUE ITER-002))
       (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
      (CL:IF
       (CL:EQ (SUB-TYPE-SPEC-OF? PTYPE SGT-WALK-LITERAL) 1)
       (VALUE-SETTER
        IT
        (LIST*
         SYM-WALK-WRAPPER-VALUE
         (LIST*
          SYM-WALK-SAFE-CAST
          (CLSYS-SVAL CONS-ITERATOR VALUE IT)
          (CONS (TYPE-TO-WRAPPED-TYPE (TYPE-SPEC-TO-BASE-TYPE PTYPE)) NIL))
         NIL))
       (CL:WHEN
        (CL:NOT (CL:EQ PTYPE SGT-WALK-OBJECT))
        (VALUE-SETTER
         IT
         (LIST*
          SYM-WALK-SAFE-CAST
          (CLSYS-SVAL CONS-ITERATOR VALUE IT)
          (CONS (YIELD-TYPE-SPEC-TREE PTYPE) NIL)))))))
    (CL:COND
     ((CL:EQ (VOID? RESULTTYPE) 1) NULL)
     ((CL:EQ (SUBTYPE-OF? RESULTTYPE SGT-WALK-LITERAL) 1)
      (CL:SETQ
       NAMETREE
       (CONS NAMETREE (CONS (TYPE-TO-WRAPPED-TYPE RESULTTYPE) NIL)))
      (CL:SETQ
       CALLTREE
       (LIST*
        SYM-WALK-LET
        (CONS (LIST* SYM-WALK-RESULT CALLTREE NIL) NIL)
        (LIST*
         SYM-WALK-IF
         (LIST* SYM-WALK-DEFINED? SYM-WALK-RESULT NIL)
         (LIST*
          SYM-WALK-RETURN
          (CONS
           (CL:IF
            (CL:EQ (TYPE METHOD) SGT-WALK-BOOLEAN)
            SYM-WALK-WRAP-BOOLEAN
            SYM-WALK-WRAP-LITERAL)
           (CONS SYM-WALK-RESULT NIL))
          NIL)
         (LIST* SYM-WALK-RETURN SYM-WALK-NULL NIL)
         NIL)
        NIL)))
     (CL:T
      (CL:SETQ NAMETREE (CONS NAMETREE (CONS RESULTTYPE NIL)))
      (CL:SETQ CALLTREE (LIST* SYM-WALK-RETURN CALLTREE NIL))))
    (CL:RETURN-FROM
     YIELD-EVALUATOR-WRAPPER-TREE
     (LIST*
      SYM-WALK-DEFUN
      NAMETREE
      (LIST*
       (CONS (LIST* SYM-WALK-ARGUMENTS SYM-WALK-CONS NIL) NIL)
       KWD-WALK-AUXILIARY?
       SYM-WALK-TRUE
       CALLTREE
       NIL)))))
  :VOID)

;;; (DEFUN CREATE-EVALUATOR-WRAPPER-UNIT ...)

(CL:DEFUN CREATE-EVALUATOR-WRAPPER-UNIT (METHOD)
  (CL:LET*
   ((VARIABLEARGUMENTS? (METHOD-VARIABLE-ARGUMENTS? METHOD))
    (EVALUATEARGUMENTS? (METHOD-EVALUATE-ARGUMENTS? METHOD))
    (WRAPPERTREE (YIELD-EVALUATOR-WRAPPER-TREE METHOD)))
   (CL:WHEN
    (CL:> (LENGTH (METHOD-RETURN-TYPE-SPECIFIERS METHOD)) 1)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-WARNING)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING
        " During interpreted command evaluation only the"
        %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " first return value will be usable." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))))
   (CL:WHEN
    (CL:EQ EVALUATEARGUMENTS? 0)
    (SET-DYNAMIC-SLOT-VALUE
     METHOD
     SYM-WALK-METHOD-EVALUATE-ARGUMENTS?
     (WRAP-BOOLEAN TRUE)
     NULL-BOOLEAN-WRAPPER))
   (CL:WHEN
    (CL:EQ VARIABLEARGUMENTS? 1)
    (SET-DYNAMIC-SLOT-VALUE
     METHOD
     SYM-WALK-METHOD-VARIABLE-ARGUMENTS?
     (WRAP-BOOLEAN FALSE)
     NULL-BOOLEAN-WRAPPER))
   (WALK-AUXILIARY-TREE WRAPPERTREE)
   (CL:WHEN
    (CL:EQ EVALUATEARGUMENTS? 0)
    (SET-DYNAMIC-SLOT-VALUE
     METHOD
     SYM-WALK-METHOD-EVALUATE-ARGUMENTS?
     (WRAP-BOOLEAN FALSE)
     NULL-BOOLEAN-WRAPPER))
   (CL:WHEN
    (CL:EQ VARIABLEARGUMENTS? 1)
    (SET-DYNAMIC-SLOT-VALUE
     METHOD
     SYM-WALK-METHOD-VARIABLE-ARGUMENTS?
     (WRAP-BOOLEAN TRUE)
     NULL-BOOLEAN-WRAPPER)))
  :VOID)

;;; (DEFSPECIAL *EVALUATIONERROR?* ...)

(CL:DEFVAR *EVALUATIONERROR?* FALSE)

(CL:DEFUN READ-*EVALUATIONERROR?* ()
  (CL:RETURN-FROM READ-*EVALUATIONERROR?* *EVALUATIONERROR?*)
  :VOID)

(CL:DEFUN WRITE-*EVALUATIONERROR?* (VALUE)
  (CL:SETQ *EVALUATIONERROR?* VALUE)
  (CL:RETURN-FROM WRITE-*EVALUATIONERROR?* VALUE)
  :VOID)

;;; (DEFUN RESET-EVALUATION-ERROR ...)

(CL:DEFUN RESET-EVALUATION-ERROR ()
  "Reset the global evaluation error indicator."
  (CL:SETQ *EVALUATIONERROR?* FALSE)
  :VOID)

;;; (DEFUN SIGNAL-EVALUATION-ERROR ...)

(CL:DEFUN SIGNAL-EVALUATION-ERROR ()
  "Signal an evaluation error.  This is done automatically
by calling 'eval-error'."
  (CL:SETQ *EVALUATIONERROR?* TRUE)
  :VOID)

;;; (DEFUN (EVALUATION-ERROR? BOOLEAN) ...)

(CL:DEFUN EVALUATION-ERROR? ()
  "Return TRUE if the global evaluation error indicator is set."
  (CL:RETURN-FROM EVALUATION-ERROR? *EVALUATIONERROR?*)
  :VOID)

;;; (DEFSPECIAL *EVALUATIONTREE* ...)

(CL:DEFVAR *EVALUATIONTREE* NULL)

(CL:DEFUN READ-*EVALUATIONTREE* ()
  (CL:RETURN-FROM READ-*EVALUATIONTREE* *EVALUATIONTREE*)
  :VOID)

(CL:DEFUN WRITE-*EVALUATIONTREE* (VALUE)
  (CL:SETQ *EVALUATIONTREE* VALUE)
  (CL:RETURN-FROM WRITE-*EVALUATIONTREE* VALUE)
  :VOID)

;;; (DEFSPECIAL *EVALUATIONPARENTTREE* ...)

(CL:DEFVAR *EVALUATIONPARENTTREE* NULL)

(CL:DEFUN READ-*EVALUATIONPARENTTREE* ()
  (CL:RETURN-FROM READ-*EVALUATIONPARENTTREE* *EVALUATIONPARENTTREE*)
  :VOID)

(CL:DEFUN WRITE-*EVALUATIONPARENTTREE* (VALUE)
  (CL:SETQ *EVALUATIONPARENTTREE* VALUE)
  (CL:RETURN-FROM WRITE-*EVALUATIONPARENTTREE* VALUE)
  :VOID)

;;; (DEFUN PRINT-EVALUATION-ERROR-CONTEXT ...)

(CL:DEFUN PRINT-EVALUATION-ERROR-CONTEXT (PREFIX STREAM)
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
   (CL:WRITE-STRING PREFIX %%STREAM)
   (CL:WRITE-STRING "While evaluating '" %%STREAM)
   (PRINT-OBJECT *EVALUATIONTREE* %%STREAM))
  (CL:WHEN
   (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
    (CL:WRITE-STRING "' inside '" %%STREAM)
    (PRINT-OBJECT *EVALUATIONPARENTTREE* %%STREAM)))
  (CL:WRITE-STRING "':" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
  :VOID)

;;; (DEFUN (EVALUATE OBJECT TYPE-SPEC BOOLEAN) ...)

(CL:DEFUN %%EVALUATE (EXPRESSION)
  "Evaluate the expression `expression' and return the result.
Currently, only the evaluation of (possibly nested) commands and global
variables is supported.  The second return value indicates the actual type 
of the result (which might have been wrapped), and the third return value
indicates whether an error occurred during the evaluation."
  (RESET-EVALUATION-ERROR)
  (CL:LET*
   ((OTREE NULL) (OTYPE SGT-WALK-UNKNOWN))
   (CL:WHEN
    (CL:NOT (CL:EQ EXPRESSION NULL))
    (CL:LET*
     ((EXPRESSION-001 EXPRESSION))
     (CL:COND
      ((CL:EQ (CONS? EXPRESSION) 1)
       (CL:LET*
        ((EXPRESSION NULL))
        (CL:SETQ EXPRESSION EXPRESSION-001)
        (CL:MULTIPLE-VALUE-SETQ
         (OTREE OTYPE)
         (EVALUATE-CONS-TREE EXPRESSION))))
      (CL:T
       (CL:MULTIPLE-VALUE-SETQ
        (OTREE OTYPE)
        (EVALUATE-ATOMIC-TREE EXPRESSION))))))
   (CL:RETURN-FROM %%EVALUATE (CL:VALUES OTREE OTYPE (EVALUATION-ERROR?))))
  :VOID)

(CL:DEFMACRO EVALUATE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Evaluate the expression `expression' and return the result.
Currently, only the evaluation of (possibly nested) commands and global
variables is supported.  The second return value indicates the actual type 
of the result (which might have been wrapped), and the third return value
indicates whether an error occurred during the evaluation."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* TRUE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /STELLA/EVALUATE)) (CL:MACRO-FUNCTION (CL:QUOTE EVALUATE)))

;;; (DEFUN (EVALUATE-STRING OBJECT TYPE-SPEC BOOLEAN) ...)

(CL:DEFUN EVALUATE-STRING (EXPRESSION)
  "Evaluate the expression represented by `expression' and return the result.
This is equivalent to `(evaluate (unstringify expression))'."
  (CL:RETURN-FROM EVALUATE-STRING (%%EVALUATE (UNSTRINGIFY EXPRESSION)))
  :VOID)

;;; (DEFUN (TRY-TO-EVALUATE OBJECT TYPE-SPEC BOOLEAN) ...)

(CL:DEFUN TRY-TO-EVALUATE (TREE)
  "Variant of 'evaluate' that only evaluates 'tree' if it
represents an evaluable expression.  If it does not, 'tree' is returned
unmodified.  This can be used to implement commands with mixed argument
evaluation strategies."
  (RESET-EVALUATION-ERROR)
  (CL:LET*
   ((OTREE TREE) (OTYPE SGT-WALK-UNKNOWN))
   (CL:WHEN
    (CL:NOT (CL:EQ TREE NULL))
    (CL:LET*
     ((TREE-001 TREE))
     (CL:COND
      ((CL:EQ (CONS? TREE) 1)
       (CL:LET*
        ((TREE NULL))
        (CL:SETQ TREE TREE-001)
        (CL:IF
         (CL:AND
          (CL:EQ (SYMBOL? (CLSYS-SVAL CONS VALUE TREE)) 1)
          (CL:NOT (CL:EQ (LOOKUP-COMMAND (CLSYS-SVAL CONS VALUE TREE)) NULL)))
         (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE) (EVALUATE-CONS-TREE TREE))
         (CL:SETQ OTYPE (PRIMARY-TYPE TREE)))))
      (CL:T (CL:SETQ OTYPE (PRIMARY-TYPE TREE))))))
   (CL:RETURN-FROM TRY-TO-EVALUATE (CL:VALUES OTREE OTYPE (EVALUATION-ERROR?))))
  :VOID)

;;; (DEFUN (EVALUATE-CONS-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN EVALUATE-CONS-TREE (TREE)
  (CL:LET*
   ((*EVALUATIONPARENTTREE* *EVALUATIONTREE*) (*EVALUATIONTREE* TREE))
   (CL:DECLARE (CL:SPECIAL *EVALUATIONPARENTTREE* *EVALUATIONTREE*))
   (CL:LET*
    ((OPERATORNAME (CLSYS-SVAL CONS VALUE TREE))
     (ARGUMENTS (CLSYS-SVAL CONS REST TREE))
     (OPERATOR NULL))
    (CL:LET*
     ((OPERATORNAME-001 OPERATORNAME))
     (CL:COND
      ((CL:EQ (SYMBOL? OPERATORNAME) 1)
       (CL:LET*
        ((OPERATORNAME NULL))
        (CL:SETQ OPERATORNAME OPERATORNAME-001)
        (CL:COND
         ((CL:EQ OPERATORNAME SYM-WALK-QUOTE)
          (CL:WHEN
           (CL:= (LENGTH ARGUMENTS) 1)
           (CL:RETURN-FROM
            EVALUATE-CONS-TREE
            (CL:VALUES
             (CLSYS-SVAL CONS VALUE ARGUMENTS)
             (PRIMARY-TYPE (CLSYS-SVAL CONS VALUE ARGUMENTS)))))
          (CL:LET*
           ((*PRINTREADABLY?* TRUE))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-EVALUATION-ERROR)
           (PRINT-EVALUATION-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
           (CL:LET
            ((%%STREAM
              (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM)
            (CL:WRITE-STRING "   Illegal QUOTE expression." %%STREAM)
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM)))
          (CL:RETURN-FROM EVALUATE-CONS-TREE (CL:VALUES NULL NULL)))
         (CL:T
          (CL:LET*
           ((TEST-VALUE-001 FALSE))
           (CL:LET*
            ()
            (CL:SETQ OPERATOR (LOOKUP-COMMAND OPERATORNAME))
            (CL:SETQ TEST-VALUE-001 (DEFINED? OPERATOR)))
           (CL:SETQ
            TEST-VALUE-001
            (CL:IF (CL:EQ TEST-VALUE-001 0) TRUE FALSE))
           (CL:WHEN
            (CL:EQ TEST-VALUE-001 1)
            (CL:LET*
             ((*PRINTREADABLY?* TRUE))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-EVALUATION-ERROR)
             (PRINT-EVALUATION-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
             (CL:LET
              ((%%STREAM
                (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING "   Undefined operator: `" %%STREAM)
              (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE OPERATORNAME) %%STREAM)
              (CL:WRITE-STRING "'." %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)))
            (CL:RETURN-FROM EVALUATE-CONS-TREE (CL:VALUES NULL NULL))))))))
      (CL:T
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-EVALUATION-ERROR)
        (PRINT-EVALUATION-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING "   Illegal operator: `" %%STREAM)
         (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE OPERATORNAME) %%STREAM)
         (CL:WRITE-STRING "'." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)))
       (CL:RETURN-FROM EVALUATE-CONS-TREE (CL:VALUES NULL NULL)))))
    (CL:LET*
     ((EVALUATORWRAPPERCODE
       (CLSYS-SVAL
        FUNCTION-CODE-WRAPPER
        WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         OPERATOR
         SYM-WALK-EVALUATOR-WRAPPER-CODE
         NULL-FUNCTION-CODE-WRAPPER)))
      (EVALUATEARGS? (METHOD-EVALUATE-ARGUMENTS? OPERATOR))
      (VARIABLEARGS? (METHOD-VARIABLE-ARGUMENTS? OPERATOR))
      (PARAMETERTYPES (METHOD-PARAMETER-TYPE-SPECIFIERS OPERATOR))
      (NOFPARAMETERS (LENGTH PARAMETERTYPES))
      (NOFARGS (LENGTH ARGUMENTS))
      (MINARGS
       (CL:IF (CL:EQ VARIABLEARGS? 1) (CL:1- NOFPARAMETERS) NOFPARAMETERS))
      (MAXARGS (CL:IF (CL:EQ VARIABLEARGS? 1) NULL-INTEGER NOFPARAMETERS))
      (UNEVALUATEDARGS ARGUMENTS)
      (EVALUATEDARG NULL)
      (EVALUATEDARGTYPE NULL)
      (ARGINDEX 0)
      (RETURNTYPE (TYPE OPERATOR))
      (RESULT NULL))
     (CL:WHEN
      (CL:OR
       (CL:< NOFARGS MINARGS)
       (CL:AND (CL:EQ (DEFINED? MAXARGS) 1) (CL:> NOFARGS MAXARGS)))
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-EVALUATION-ERROR)
       (PRINT-EVALUATION-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING "   Wrong number of arguments." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)))
      (CL:RETURN-FROM EVALUATE-CONS-TREE (CL:VALUES NULL NULL)))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ UNEVALUATEDARGS NIL))
      DO
      (CL:MULTIPLE-VALUE-SETQ
       (EVALUATEDARG EVALUATEDARGTYPE)
       (EVALUATE-ARGUMENT-TREE
        (CLSYS-SVAL CONS VALUE UNEVALUATEDARGS)
        EVALUATEARGS?))
      (CL:WHEN
       (CL:EQ (EVALUATION-ERROR?) 1)
       (CL:RETURN-FROM EVALUATE-CONS-TREE (CL:VALUES NULL NULL)))
      (CL:MULTIPLE-VALUE-SETQ
       (EVALUATEDARG EVALUATEDARGTYPE)
       (COERCE-EVALUATED-TREE
        EVALUATEDARG
        (CLSYS-SVAL CONS VALUE UNEVALUATEDARGS)
        EVALUATEDARGTYPE
        (CL:IF
         (CL:>= ARGINDEX MINARGS)
         (VARIABLE-ARGUMENTS-TYPE OPERATOR)
         (NTH PARAMETERTYPES ARGINDEX))
        EVALUATEARGS?))
      (CL:WHEN
       (CL:EQ (EVALUATION-ERROR?) 1)
       (CL:RETURN-FROM EVALUATE-CONS-TREE (CL:VALUES NULL NULL)))
      (CL:SETF (CLSYS-SVAL CONS VALUE UNEVALUATEDARGS) EVALUATEDARG)
      (CL:SETQ UNEVALUATEDARGS (CLSYS-SVAL CONS REST UNEVALUATEDARGS))
      (CL:SETQ ARGINDEX (CL:1+ ARGINDEX)))
     (CL:IF
      (CL:NOT (CL:EQ EVALUATORWRAPPERCODE NULL))
      (CL:IF
       (CL:EQ (VOID? RETURNTYPE) 1)
       (CL:FUNCALL EVALUATORWRAPPERCODE ARGUMENTS)
       (CL:SETQ RESULT (CL:FUNCALL EVALUATORWRAPPERCODE ARGUMENTS)))
      (CL:IF
       (CL:EQ (VOID? RETURNTYPE) 1)
       (APPLY (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE OPERATOR) ARGUMENTS)
       (CL:SETQ
        RESULT
        (APPLY (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE OPERATOR) ARGUMENTS))))
     (CL:RETURN-FROM EVALUATE-CONS-TREE (CL:VALUES RESULT RETURNTYPE)))))
  :VOID)

;;; (DEFUN (EVALUATE-ARGUMENT-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN EVALUATE-ARGUMENT-TREE (TREE EVALUATE?)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:IF
       (CL:EQ EVALUATE? 1)
       (CL:RETURN-FROM EVALUATE-ARGUMENT-TREE (EVALUATE-CONS-TREE TREE))
       (CL:RETURN-FROM
        EVALUATE-ARGUMENT-TREE
        (CL:VALUES TREE SGT-WALK-CONS)))))
    ((CL:EQ (WRAPPER? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:RETURN-FROM
       EVALUATE-ARGUMENT-TREE
       (CL:VALUES TREE (WRAPPED-TYPE-TO-TYPE (PRIMARY-TYPE TREE))))))
    (CL:T
     (CL:IF
      (CL:EQ EVALUATE? 1)
      (CL:RETURN-FROM EVALUATE-ARGUMENT-TREE (EVALUATE-ATOMIC-TREE TREE))
      (CL:RETURN-FROM
       EVALUATE-ARGUMENT-TREE
       (CL:VALUES TREE (PRIMARY-TYPE TREE)))))))
  :VOID)

;;; (DEFUN (EVALUATE-ATOMIC-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN EVALUATE-ATOMIC-TREE (TREE)
  (CL:LET*
   ((*EVALUATIONPARENTTREE* *EVALUATIONTREE*) (*EVALUATIONTREE* TREE))
   (CL:DECLARE (CL:SPECIAL *EVALUATIONPARENTTREE* *EVALUATIONTREE*))
   (CL:LET*
    ((TREE-001 TREE))
    (CL:COND
     ((CL:EQ (SYMBOL? TREE) 1)
      (CL:LET*
       ((TREE NULL))
       (CL:SETQ TREE TREE-001)
       (CL:COND
        ((CL:EQ TREE SYM-WALK-NULL)
         (CL:RETURN-FROM
          EVALUATE-ATOMIC-TREE
          (CL:VALUES TREE SGT-WALK-UNKNOWN)))
        ((CL:EQ TREE SYM-WALK-TRUE)
         (CL:RETURN-FROM
          EVALUATE-ATOMIC-TREE
          (CL:VALUES TRUE-WRAPPER SGT-WALK-BOOLEAN)))
        ((CL:EQ TREE SYM-WALK-FALSE)
         (CL:RETURN-FROM
          EVALUATE-ATOMIC-TREE
          (CL:VALUES FALSE-WRAPPER SGT-WALK-BOOLEAN)))
        (CL:T
         (CL:LET*
          ((*PRINTREADABLY?* TRUE))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-EVALUATION-ERROR)
          (PRINT-EVALUATION-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING
            "   Variable evaluation not yet implemented."
            %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)))
         (CL:RETURN-FROM EVALUATE-ATOMIC-TREE (CL:VALUES NULL NULL))))))
     ((CL:EQ (SURROGATE? TREE) 1)
      (CL:LET*
       ((TREE NULL))
       (CL:SETQ TREE TREE-001)
       (CL:RETURN-FROM
        EVALUATE-ATOMIC-TREE
        (CL:VALUES TREE SGT-WALK-SURROGATE))))
     ((CL:EQ (KEYWORD? TREE) 1)
      (CL:LET*
       ((TREE NULL))
       (CL:SETQ TREE TREE-001)
       (CL:RETURN-FROM
        EVALUATE-ATOMIC-TREE
        (CL:VALUES TREE SGT-WALK-KEYWORD))))
     ((CL:EQ (WRAPPER? TREE) 1)
      (CL:LET*
       ((TREE NULL))
       (CL:SETQ TREE TREE-001)
       (CL:RETURN-FROM
        EVALUATE-ATOMIC-TREE
        (CL:VALUES TREE (WRAPPED-TYPE-TO-TYPE (PRIMARY-TYPE TREE))))))
     (CL:T
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-EVALUATION-ERROR)
       (PRINT-EVALUATION-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING "   Unknown atomic expression type: `" %%STREAM)
        (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TREE) %%STREAM)
        (CL:WRITE-STRING "'." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)))
      (CL:RETURN-FROM EVALUATE-ATOMIC-TREE (CL:VALUES NULL NULL))))))
  :VOID)

;;; (DEFUN (COERCE-EVALUATED-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN COERCE-EVALUATED-TREE (TREE SOURCETREE SOURCETYPE TARGETTYPE EVALUATE?)
  (CL:LET*
   ((*EVALUATIONPARENTTREE* *EVALUATIONTREE*) (*EVALUATIONTREE* SOURCETREE))
   (CL:DECLARE (CL:SPECIAL *EVALUATIONPARENTTREE* *EVALUATIONTREE*))
   (CL:LET*
    ((SOURCEBASETYPE (TYPE-SPEC-TO-BASE-TYPE SOURCETYPE))
     (TARGETBASETYPE (TYPE-SPEC-TO-BASE-TYPE TARGETTYPE)))
    (CL:WHEN
     (CL:EQ TREE SYM-WALK-NULL)
     (CL:COND
      ((CL:EQ TARGETTYPE SGT-WALK-INTEGER)
       (CL:RETURN-FROM
        COERCE-EVALUATED-TREE
        (CL:VALUES NULL-INTEGER-WRAPPER TARGETTYPE)))
      ((CL:EQ TARGETTYPE SGT-WALK-FLOAT)
       (CL:RETURN-FROM
        COERCE-EVALUATED-TREE
        (CL:VALUES NULL-FLOAT-WRAPPER TARGETTYPE)))
      ((CL:EQ TARGETTYPE SGT-WALK-STRING)
       (CL:RETURN-FROM
        COERCE-EVALUATED-TREE
        (CL:VALUES NULL-STRING-WRAPPER TARGETTYPE)))
      ((CL:EQ TARGETTYPE SGT-WALK-BOOLEAN)
       (CL:RETURN-FROM
        COERCE-EVALUATED-TREE
        (CL:VALUES FALSE-WRAPPER TARGETTYPE)))
      (CL:T
       (CL:RETURN-FROM COERCE-EVALUATED-TREE (CL:VALUES NULL TARGETTYPE)))))
    (CL:WHEN
     (CL:AND (CL:EQ TARGETTYPE SGT-WALK-BOOLEAN) (CL:EQ EVALUATE? 0))
     (CL:WHEN
      (CL:EQ TREE SYM-WALK-TRUE)
      (CL:RETURN-FROM
       COERCE-EVALUATED-TREE
       (CL:VALUES TRUE-WRAPPER TARGETTYPE)))
     (CL:WHEN
      (CL:EQ TREE SYM-WALK-FALSE)
      (CL:RETURN-FROM
       COERCE-EVALUATED-TREE
       (CL:VALUES FALSE-WRAPPER TARGETTYPE))))
    (CL:WHEN
     (CL:EQ (SUBTYPE-OF? SOURCEBASETYPE TARGETBASETYPE) 1)
     (CL:RETURN-FROM COERCE-EVALUATED-TREE (CL:VALUES TREE SOURCETYPE)))
    (CL:WHEN
     (CL:AND
      (CL:EQ EVALUATE? 0)
      (CL:EQ (SUBTYPE-OF? SOURCEBASETYPE SGT-WALK-LITERAL) 1)
      (CL:EQ
       (SUBTYPE-OF? (TYPE-TO-WRAPPED-TYPE SOURCEBASETYPE) TARGETBASETYPE)
       1))
     (CL:RETURN-FROM
      COERCE-EVALUATED-TREE
      (CL:VALUES TREE (TYPE-TO-WRAPPED-TYPE SOURCEBASETYPE))))
    (CL:WHEN
     (CL:AND
      (CL:EQ (SUBTYPE-OF? TARGETBASETYPE SGT-WALK-LITERAL) 1)
      (CL:EQ
       (SUBTYPE-OF? SOURCEBASETYPE (TYPE-TO-WRAPPED-TYPE TARGETBASETYPE))
       1))
     (CL:RETURN-FROM COERCE-EVALUATED-TREE (CL:VALUES TREE TARGETTYPE)))
    (CL:IF
     (CL:EQ (VOID? SOURCETYPE) 1)
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-EVALUATION-ERROR)
      (PRINT-EVALUATION-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING "   `" %%STREAM)
       (PRINT-OBJECT (CLSYS-SVAL CONS VALUE SOURCETREE) %%STREAM)
       (CL:WRITE-STRING "' does not return a value." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-EVALUATION-ERROR)
      (PRINT-EVALUATION-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING "   Type conflict: `" %%STREAM)
       (PRINT-OBJECT (YIELD-TYPE-SPEC-TREE SOURCETYPE) %%STREAM)
       (CL:WRITE-STRING "' found where `" %%STREAM)
       (PRINT-OBJECT (YIELD-TYPE-SPEC-TREE TARGETTYPE) %%STREAM)
       (CL:WRITE-STRING "' expected." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (CL:RETURN-FROM COERCE-EVALUATED-TREE (CL:VALUES NULL NULL))))
  :VOID)

(CL:DEFUN STARTUP-WALK ()
  (CL:WHEN
   (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 0) 1)
   (CL:SETQ *QUOTATION-TABLE* (NEW-STRING-HASH-TABLE)))
  (CL:LET*
   ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     KWD-WALK-WARN-ABOUT-UNDEFINED-METHODS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN-ABOUT-UNDEFINED-METHODS" NULL 2))
    (CL:SETQ
     KWD-WALK-SUPPRESS-WARNINGS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPPRESS-WARNINGS" NULL 2))
    (CL:SETQ
     KWD-WALK-USE-BOOTSTRAP-TRANSLATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-BOOTSTRAP-TRANSLATOR" NULL 2))
    (CL:SETQ
     KWD-WALK-WARN-ABOUT-MISSING-METHODS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN-ABOUT-MISSING-METHODS" NULL 2))
    (CL:SETQ
     KWD-WALK-USE-HARDCODED-SYMBOLS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-HARDCODED-SYMBOLS" NULL 2))
    (CL:SETQ
     KWD-WALK-USE-COMMON-LISP-STRUCTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-STRUCTS" NULL 2))
    (CL:SETQ
     KWD-WALK-USE-COMMON-LISP-VECTOR-STRUCTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-VECTOR-STRUCTS" NULL 2))
    (CL:SETQ
     KWD-WALK-USE-CPP-GARBAGE-COLLECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-CPP-GARBAGE-COLLECTOR" NULL 2))
    (CL:SETQ
     KWD-WALK-TRANSLATE-WITH-COPYRIGHT-HEADER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "TRANSLATE-WITH-COPYRIGHT-HEADER"
      NULL
      2))
    (CL:SETQ SYM-WALK-WHEN (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN" NULL 0))
    (CL:SETQ SYM-WALK-AND (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 0))
    (CL:SETQ
     SYM-WALK-DEFINED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?" NULL 0))
    (CL:SETQ
     SYM-WALK-*TRACED-KEYWORDS*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*TRACED-KEYWORDS*" NULL 0))
    (CL:SETQ
     SYM-WALK-MEMBER?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER?" NULL 0))
    (CL:SETQ SYM-WALK-PRINT (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT" NULL 0))
    (CL:SETQ
     SYM-WALK-TRACE-IF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRACE-IF" NULL 0))
    (CL:SETQ
     SYM-WALK-TRACE-IF-EXPANDER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRACE-IF-EXPANDER" NULL 0))
    (CL:SETQ
     SYM-WALK-ADD-TRACE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD-TRACE" NULL 0))
    (CL:SETQ
     KWD-WALK-COMMON-LISP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
    (CL:SETQ
     KWD-WALK-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     SYM-WALK-EVALUATOR-WRAPPER-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATOR-WRAPPER-CODE" NULL 0))
    (CL:SETQ
     SYM-WALK-DROP-TRACE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DROP-TRACE" NULL 0))
    (CL:SETQ
     SYM-WALK-THE-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-OBJECT" NULL 0))
    (CL:SETQ
     SYM-WALK-CATEGORY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CATEGORY" NULL 0))
    (CL:SETQ
     SYM-WALK-ANNOTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ANNOTATION" NULL 0))
    (CL:SETQ
     SYM-WALK-AUXILIARY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AUXILIARY?" NULL 0))
    (CL:SETQ
     SYM-WALK-CODE-REGISTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CODE-REGISTER" NULL 0))
    (CL:SETQ
     SYM-WALK-TRANSLATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSLATION" NULL 0))
    (CL:SETQ
     SYM-WALK-REFERENCED-GLOBALS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REFERENCED-GLOBALS" NULL 0))
    (CL:SETQ
     SGT-WALK-TRANSLATION-UNIT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSLATION-UNIT" NULL 1))
    (CL:SETQ SYM-WALK-CLASS (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 0))
    (CL:SETQ SYM-WALK-METHOD (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD" NULL 0))
    (CL:SETQ SYM-WALK-MACRO (INTERN-RIGID-SYMBOL-WRT-MODULE "MACRO" NULL 0))
    (CL:SETQ
     SYM-WALK-GLOBAL-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBAL-VARIABLE" NULL 0))
    (CL:SETQ
     SYM-WALK-*TRANSLATIONUNITS*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*TRANSLATIONUNITS*" NULL 0))
    (CL:SETQ
     SYM-WALK-*CURRENTTRANSLATIONUNIT*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*CURRENTTRANSLATIONUNIT*" NULL 0))
    (CL:SETQ
     SYM-WALK-*TRANSLATIONPHASE*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*TRANSLATIONPHASE*" NULL 0))
    (CL:SETQ
     SYM-WALK-*TRANSLATIONVERBOSITYLEVEL*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*TRANSLATIONVERBOSITYLEVEL*" NULL 0))
    (CL:SETQ
     SYM-WALK-*USEHARDCODEDSYMBOLS?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*USEHARDCODEDSYMBOLS?*" NULL 0))
    (CL:SETQ KWD-WALK-REAL (INTERN-RIGID-SYMBOL-WRT-MODULE "REAL" NULL 2))
    (CL:SETQ
     KWD-WALK-BOOTSTRAP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOTSTRAP" NULL 2))
    (CL:SETQ KWD-WALK-JAVA (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA" NULL 2))
    (CL:SETQ KWD-WALK-CPP (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
    (CL:SETQ SYM-WALK-PROGN (INTERN-RIGID-SYMBOL-WRT-MODULE "PROGN" NULL 0))
    (CL:SETQ
     SYM-WALK-DEFCLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFCLASS" NULL 0))
    (CL:SETQ
     SYM-WALK-DEFSLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFSLOT" NULL 0))
    (CL:SETQ
     SYM-WALK-DEFMETHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMETHOD" NULL 0))
    (CL:SETQ SYM-WALK-DEFUN (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFUN" NULL 0))
    (CL:SETQ
     SYM-WALK-DEFOPERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFOPERATOR" NULL 0))
    (CL:SETQ
     SYM-WALK-DEFGLOBAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFGLOBAL" NULL 0))
    (CL:SETQ
     SYM-WALK-DEFSPECIAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFSPECIAL" NULL 0))
    (CL:SETQ
     SYM-WALK-DEFCONSTANT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFCONSTANT" NULL 0))
    (CL:SETQ
     SYM-WALK-DEFTYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFTYPE" NULL 0))
    (CL:SETQ
     SYM-WALK-DEFMODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMODULE" NULL 0))
    (CL:SETQ
     SYM-WALK-DEFMACRO
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMACRO" NULL 0))
    (CL:SETQ
     SYM-WALK-STARTUP-TIME-PROGN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-TIME-PROGN" NULL 0))
    (CL:SETQ
     SYM-WALK-VERBATIM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBATIM" NULL 0))
    (CL:SETQ SYM-WALK-MODULE (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" NULL 0))
    (CL:SETQ SYM-WALK-TYPE (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 0))
    (CL:SETQ
     SYM-WALK-PRINT-METHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-METHOD" NULL 0))
    (CL:SETQ SYM-WALK-SLOT (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" NULL 0))
    (CL:SETQ KWD-WALK-IDL (INTERN-RIGID-SYMBOL-WRT-MODULE "IDL" NULL 2))
    (CL:SETQ
     KWD-WALK-CPP-STANDALONE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-STANDALONE" NULL 2))
    (CL:SETQ
     SYM-WALK-*LOCALVARIABLETYPETABLE*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*LOCALVARIABLETYPETABLE*" NULL 0))
    (CL:SETQ
     SYM-WALK-*METHODBEINGWALKED*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*METHODBEINGWALKED*" NULL 0))
    (CL:SETQ
     SYM-WALK-*FOUNDRETURN?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*FOUNDRETURN?*" NULL 0))
    (CL:SETQ SGT-WALK-VOID (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" NULL 1))
    (CL:SETQ
     SYM-WALK-*TARGETTYPE*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*TARGETTYPE*" NULL 0))
    (CL:SETQ
     SYM-WALK-*LOCALGENSYMTABLE*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*LOCALGENSYMTABLE*" NULL 0))
    (CL:SETQ
     SYM-WALK-*TRANSLATIONERRORS*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*TRANSLATIONERRORS*" NULL 0))
    (CL:SETQ
     SYM-WALK-*TRANSLATIONWARNINGS*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*TRANSLATIONWARNINGS*" NULL 0))
    (CL:SETQ
     SYM-WALK-*IGNORETRANSLATIONERRORS?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*IGNORETRANSLATIONERRORS?*" NULL 0))
    (CL:SETQ KWD-WALK-DEFINE (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE" NULL 2))
    (CL:SETQ
     KWD-WALK-FINALIZE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE" NULL 2))
    (CL:SETQ KWD-WALK-WALK (INTERN-RIGID-SYMBOL-WRT-MODULE "WALK" NULL 2))
    (CL:SETQ
     KWD-WALK-TRANSLATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSLATE" NULL 2))
    (CL:SETQ
     SGT-WALK-GLOBAL-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBAL-VARIABLE" NULL 1))
    (CL:SETQ
     SGT-WALK-TYPE-SPEC
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE-SPEC" NULL 1))
    (CL:SETQ SGT-WALK-MODULE (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" NULL 1))
    (CL:SETQ
     SGT-WALK-UNINITIALIZED
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNINITIALIZED" NULL 1))
    (CL:SETQ
     SGT-WALK-UNKNOWN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" NULL 1))
    (CL:SETQ SYM-WALK-NULL (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
    (CL:SETQ SYM-WALK-ERROR (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 0))
    (CL:SETQ SYM-WALK-EOL (INTERN-RIGID-SYMBOL-WRT-MODULE "EOL" NULL 0))
    (CL:SETQ
     SYM-WALK-ILLEGAL-EXPRESSION-FLAGGED-BY-THE-TRANSLATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "ILLEGAL-EXPRESSION-FLAGGED-BY-THE-TRANSLATOR"
      NULL
      0))
    (CL:SETQ
     SYM-WALK-BAD-SYS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BAD-SYS" NULL 0))
    (CL:SETQ
     SGT-WALK-INTEGER-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-WALK-INTEGER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER" NULL 1))
    (CL:SETQ
     SGT-WALK-TRANSIENT-INTEGER-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-INTEGER-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-WALK-FLOAT-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT-WRAPPER" NULL 1))
    (CL:SETQ SGT-WALK-FLOAT (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT" NULL 1))
    (CL:SETQ
     SGT-WALK-TRANSIENT-FLOAT-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-FLOAT-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-WALK-NUMBER-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER" NULL 1))
    (CL:SETQ SGT-WALK-NUMBER (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER" NULL 1))
    (CL:SETQ
     SGT-WALK-STRING-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-WRAPPER" NULL 1))
    (CL:SETQ SGT-WALK-STRING (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 1))
    (CL:SETQ
     SGT-WALK-TRANSIENT-STRING-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-STRING-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-WALK-CHARACTER-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-WALK-CHARACTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER" NULL 1))
    (CL:SETQ
     SGT-WALK-TRANSIENT-CHARACTER-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-CHARACTER-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-WALK-BOOLEAN-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-WALK-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
    (CL:SETQ
     SGT-WALK-FUNCTION-CODE-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-WALK-FUNCTION-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE" NULL 1))
    (CL:SETQ
     SGT-WALK-TRANSIENT-FUNCTION-CODE-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "TRANSIENT-FUNCTION-CODE-WRAPPER"
      NULL
      1))
    (CL:SETQ
     SGT-WALK-METHOD-CODE-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-WALK-METHOD-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE" NULL 1))
    (CL:SETQ
     SGT-WALK-TRANSIENT-METHOD-CODE-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-METHOD-CODE-WRAPPER" NULL 1))
    (CL:SETQ SGT-WALK-OBJECT (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 1))
    (CL:SETQ
     SYM-WALK-WRAP-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-BOOLEAN" NULL 0))
    (CL:SETQ
     SYM-WALK-WRAP-LITERAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-LITERAL" NULL 0))
    (CL:SETQ
     SYM-WALK-INTEGER-TO-BOOLEAN-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-TO-BOOLEAN-WRAPPER" NULL 0))
    (CL:SETQ
     SYM-WALK-INTEGER-TO-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-TO-BOOLEAN" NULL 0))
    (CL:SETQ SGT-WALK-SYMBOL (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" NULL 1))
    (CL:SETQ
     SYM-WALK-INTERN-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERN-SYMBOL" NULL 0))
    (CL:SETQ
     SYM-WALK-SYMBOL-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-NAME" NULL 0))
    (CL:SETQ
     SYM-WALK-WRAPPER-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAPPER-VALUE" NULL 0))
    (CL:SETQ
     SGT-WALK-SURROGATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE" NULL 1))
    (CL:SETQ SGT-WALK-CLASS (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 1))
    (CL:SETQ
     SYM-WALK-SURROGATE-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE" NULL 0))
    (CL:SETQ
     SGT-WALK-INPUT-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-STREAM" NULL 1))
    (CL:SETQ
     SGT-WALK-NATIVE-INPUT-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-INPUT-STREAM" NULL 1))
    (CL:SETQ
     SYM-WALK-NATIVE-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-STREAM" NULL 0))
    (CL:SETQ
     SGT-WALK-OUTPUT-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-STREAM" NULL 1))
    (CL:SETQ
     SGT-WALK-NATIVE-OUTPUT-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-OUTPUT-STREAM" NULL 1))
    (CL:SETQ
     SYM-WALK-IDENTITY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IDENTITY" NULL 0))
    (CL:SETQ
     SGT-WALK-SINGLE-FLOAT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SINGLE-FLOAT" NULL 1))
    (CL:SETQ
     SGT-WALK-DOUBLE-FLOAT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DOUBLE-FLOAT" NULL 1))
    (CL:SETQ
     SGT-WALK-SHORT-INTEGER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SHORT-INTEGER" NULL 1))
    (CL:SETQ
     SGT-WALK-LONG-INTEGER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LONG-INTEGER" NULL 1))
    (CL:SETQ
     SGT-WALK-UNSIGNED-SHORT-INTEGER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNSIGNED-SHORT-INTEGER" NULL 1))
    (CL:SETQ
     SGT-WALK-UNSIGNED-LONG-INTEGER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNSIGNED-LONG-INTEGER" NULL 1))
    (CL:SETQ SYM-WALK-VRLET (INTERN-RIGID-SYMBOL-WRT-MODULE "VRLET" NULL 0))
    (CL:SETQ
     SYM-WALK-SYS-CALL-METHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-METHOD" NULL 0))
    (CL:SETQ
     SYM-WALK-SYS-CALL-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-FUNCTION" NULL 0))
    (CL:SETQ
     SYM-WALK-SAFE-CAST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SAFE-CAST" NULL 0))
    (CL:SETQ SYM-WALK-CAST (INTERN-RIGID-SYMBOL-WRT-MODULE "CAST" NULL 0))
    (CL:SETQ
     SGT-WALK-NON-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NON-OBJECT" NULL 1))
    (CL:SETQ
     SGT-WALK-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAPPER" NULL 1))
    (CL:SETQ SYM-WALK-LET (INTERN-RIGID-SYMBOL-WRT-MODULE "LET" NULL 0))
    (CL:SETQ
     SYM-WALK-VOID-SYS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID-SYS" NULL 0))
    (CL:SETQ
     SYM-WALK-TYPED-SYS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPED-SYS" NULL 0))
    (CL:SETQ
     SYM-WALK-SLOT-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-TYPE-SPECIFIER" NULL 0))
    (CL:SETQ SGT-WALK-CONS (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
    (CL:SETQ
     SYM-WALK-SYS-FOREACH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-FOREACH" NULL 0))
    (CL:SETQ SYM-WALK-SETQ (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
    (CL:SETQ SYM-WALK-SETF (INTERN-RIGID-SYMBOL-WRT-MODULE "SETF" NULL 0))
    (CL:SETQ
     SYM-WALK-SLOT-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-VALUE" NULL 0))
    (CL:SETQ
     SYM-WALK-SLOT-VALUE-SETTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-VALUE-SETTER" NULL 0))
    (CL:SETQ SYM-WALK-LOOP (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOP" NULL 0))
    (CL:SETQ SYM-WALK-VALUES (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUES" NULL 0))
    (CL:SETQ
     SYM-WALK-SPECIAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIAL" NULL 0))
    (CL:SETQ
     SYM-WALK-SYS-SPECIAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-SPECIAL" NULL 0))
    (CL:SETQ SYM-WALK-RETURN (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN" NULL 0))
    (CL:SETQ
     SYM-WALK-MV-SETQ
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MV-SETQ" NULL 0))
    (CL:SETQ
     SYM-WALK-MV-BIND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MV-BIND" NULL 0))
    (CL:SETQ SYM-WALK-BREAK (INTERN-RIGID-SYMBOL-WRT-MODULE "BREAK" NULL 0))
    (CL:SETQ
     SYM-WALK-CONTINUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUE" NULL 0))
    (CL:SETQ SYM-WALK-WHILE (INTERN-RIGID-SYMBOL-WRT-MODULE "WHILE" NULL 0))
    (CL:SETQ
     SYM-WALK-FOREACH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FOREACH" NULL 0))
    (CL:SETQ SYM-WALK-EXISTS (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 0))
    (CL:SETQ SYM-WALK-FORALL (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 0))
    (CL:SETQ SYM-WALK-SOME (INTERN-RIGID-SYMBOL-WRT-MODULE "SOME" NULL 0))
    (CL:SETQ SYM-WALK-SETOF (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOF" NULL 0))
    (CL:SETQ SYM-WALK-SET-OF (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-OF" NULL 0))
    (CL:SETQ SYM-WALK-SELECT (INTERN-RIGID-SYMBOL-WRT-MODULE "SELECT" NULL 0))
    (CL:SETQ SYM-WALK-IF (INTERN-RIGID-SYMBOL-WRT-MODULE "IF" NULL 0))
    (CL:SETQ SYM-WALK-UNLESS (INTERN-RIGID-SYMBOL-WRT-MODULE "UNLESS" NULL 0))
    (CL:SETQ SYM-WALK-CHOOSE (INTERN-RIGID-SYMBOL-WRT-MODULE "CHOOSE" NULL 0))
    (CL:SETQ SYM-WALK-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 0))
    (CL:SETQ SYM-WALK-NOT (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 0))
    (CL:SETQ SYM-WALK-COND (INTERN-RIGID-SYMBOL-WRT-MODULE "COND" NULL 0))
    (CL:SETQ SYM-WALK-CASE (INTERN-RIGID-SYMBOL-WRT-MODULE "CASE" NULL 0))
    (CL:SETQ
     SYM-WALK-TYPECASE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPECASE" NULL 0))
    (CL:SETQ SYM-WALK-EQ? (INTERN-RIGID-SYMBOL-WRT-MODULE "EQ?" NULL 0))
    (CL:SETQ SYM-WALK-EQL? (INTERN-RIGID-SYMBOL-WRT-MODULE "EQL?" NULL 0))
    (CL:SETQ SYM-WALK-= (INTERN-RIGID-SYMBOL-WRT-MODULE "=" NULL 0))
    (CL:SETQ SYM-WALK-+ (INTERN-RIGID-SYMBOL-WRT-MODULE "+" NULL 0))
    (CL:SETQ SYM-WALK-- (INTERN-RIGID-SYMBOL-WRT-MODULE "-" NULL 0))
    (CL:SETQ SYM-WALK-* (INTERN-RIGID-SYMBOL-WRT-MODULE "*" NULL 0))
    (CL:SETQ SYM-WALK-/ (INTERN-RIGID-SYMBOL-WRT-MODULE "/" NULL 0))
    (CL:SETQ SYM-WALK-QUOTE (INTERN-RIGID-SYMBOL-WRT-MODULE "QUOTE" NULL 0))
    (CL:SETQ SYM-WALK-BQUOTE (INTERN-RIGID-SYMBOL-WRT-MODULE "BQUOTE" NULL 0))
    (CL:SETQ
     SYM-WALK-PRINT-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-STREAM" NULL 0))
    (CL:SETQ
     SYM-WALK-PRINT-NATIVE-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-NATIVE-STREAM" NULL 0))
    (CL:SETQ SYM-WALK-NEW (INTERN-RIGID-SYMBOL-WRT-MODULE "NEW" NULL 0))
    (CL:SETQ
     SYM-WALK-ALLOCATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOCATE" NULL 0))
    (CL:SETQ
     SYM-WALK-LOCAL-NEW
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOCAL-NEW" NULL 0))
    (CL:SETQ SYM-WALK-MAKE (INTERN-RIGID-SYMBOL-WRT-MODULE "MAKE" NULL 0))
    (CL:SETQ
     SYM-WALK-FUNCALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCALL" NULL 0))
    (CL:SETQ
     SYM-WALK-SYS-CALL-FUNCTION-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-FUNCTION-CODE" NULL 0))
    (CL:SETQ
     SYM-WALK-SYS-CALL-METHOD-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-METHOD-CODE" NULL 0))
    (CL:SETQ
     SYM-WALK-THE-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-CODE" NULL 0))
    (CL:SETQ
     SYM-WALK-EXCEPTION-CASE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXCEPTION-CASE" NULL 0))
    (CL:SETQ SYM-WALK-INLINE (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE" NULL 0))
    (CL:SETQ
     SYM-WALK-SYS-SLOT-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-SLOT-VALUE" NULL 0))
    (CL:SETQ
     SYM-WALK-SYS-SLOT-VALUE-SETTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-SLOT-VALUE-SETTER" NULL 0))
    (CL:SETQ
     SYM-WALK-SYS-CALL-METHOD-SETTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-METHOD-SETTER" NULL 0))
    (CL:SETQ
     SYM-WALK-SYS-NEW
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-NEW" NULL 0))
    (CL:SETQ
     SYM-WALK-*CURRENTFILE*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*CURRENTFILE*" NULL 0))
    (CL:SETQ
     KWD-WALK-SYMBOLS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOLS" NULL 2))
    (CL:SETQ
     SYM-WALK-INTERN-RIGID-SYMBOL-WRT-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERN-RIGID-SYMBOL-WRT-MODULE" NULL 0))
    (CL:SETQ
     SYM-WALK-GET-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-MODULE" NULL 0))
    (CL:SETQ SYM-WALK-TRUE (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
    (CL:SETQ
     SYM-WALK-INTERN-SYMBOL-AT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERN-SYMBOL-AT" NULL 0))
    (CL:SETQ
     SYM-WALK-INTERN-SURROGATE-AT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERN-SURROGATE-AT" NULL 0))
    (CL:SETQ
     SYM-WALK-INTERN-KEYWORD-AT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERN-KEYWORD-AT" NULL 0))
    (CL:SETQ SYM-WALK-FALSE (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
    (CL:SETQ SYM-WALK-NIL (INTERN-RIGID-SYMBOL-WRT-MODULE "NIL" NULL 0))
    (CL:SETQ
     SYM-WALK-NULL-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-BOOLEAN" NULL 0))
    (CL:SETQ
     SYM-WALK-NULL-INTEGER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-INTEGER" NULL 0))
    (CL:SETQ
     SYM-WALK-NULL-FLOAT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-FLOAT" NULL 0))
    (CL:SETQ
     SGT-WALK-KEYWORD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" NULL 1))
    (CL:SETQ
     KWD-WALK-PLACE-WHERE-VRLET-WAS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PLACE-WHERE-VRLET-WAS" NULL 2))
    (CL:SETQ
     KWD-WALK-PLACE-WHERE-LAST-EXPRESSION-WAS
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "PLACE-WHERE-LAST-EXPRESSION-WAS"
      NULL
      2))
    (CL:SETQ
     KWD-WALK-DYNAMIC
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC" NULL 2))
    (CL:SETQ SYM-WALK-IT (INTERN-RIGID-SYMBOL-WRT-MODULE "IT" NULL 0))
    (CL:SETQ SYM-WALK-ON (INTERN-RIGID-SYMBOL-WRT-MODULE "ON" NULL 0))
    (CL:SETQ
     SYM-WALK-DYNAMIC-SLOTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC-SLOTS" NULL 0))
    (CL:SETQ SYM-WALK-WHERE (INTERN-RIGID-SYMBOL-WRT-MODULE "WHERE" NULL 0))
    (CL:SETQ SYM-WALK-KEY (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY" NULL 0))
    (CL:SETQ SYM-WALK-DO (INTERN-RIGID-SYMBOL-WRT-MODULE "DO" NULL 0))
    (CL:SETQ
     SYM-WALK-WRAPPEDVALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAPPEDVALUE" NULL 0))
    (CL:SETQ SYM-WALK-VALUE (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
    (CL:SETQ KWD-WALK-BIT (INTERN-RIGID-SYMBOL-WRT-MODULE "BIT" NULL 2))
    (CL:SETQ
     SYM-WALK-DYNAMICSLOTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMICSLOTS" NULL 0))
    (CL:SETQ
     SYM-WALK-NEWVALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NEWVALUE" NULL 0))
    (CL:SETQ
     SYM-WALK-FOUNDMATCHINGENTRY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FOUNDMATCHINGENTRY?" NULL 0))
    (CL:SETQ
     SYM-WALK-THE-KV-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-KV-LIST" NULL 0))
    (CL:SETQ
     SYM-WALK-KV-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KV-CONS" NULL 0))
    (CL:SETQ
     SYM-WALK-OLDVALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OLDVALUE" NULL 0))
    (CL:SETQ
     KWD-WALK-CONTEXT-SENSITIVE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-SENSITIVE?" NULL 2))
    (CL:SETQ
     KWD-WALK-DONT-INHERIT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-INHERIT?" NULL 2))
    (CL:SETQ
     SYM-WALK-ACCESS-IN-CONTEXT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ACCESS-IN-CONTEXT" NULL 0))
    (CL:SETQ
     KWD-WALK-COPY-TO-CHILDREN?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COPY-TO-CHILDREN?" NULL 2))
    (CL:SETQ
     SYM-WALK-UPDATE-IN-CONTEXT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UPDATE-IN-CONTEXT" NULL 0))
    (CL:SETQ
     SYM-WALK-CS-VALUE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CS-VALUE?" NULL 0))
    (CL:SETQ
     SYM-WALK-VARIABLE-DECLARATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-DECLARATION" NULL 0))
    (CL:SETQ
     SYM-WALK-ILLEGAL-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ILLEGAL-VARIABLE" NULL 0))
    (CL:SETQ
     SYM-WALK-*SPECIALVARIABLESTACK*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*SPECIALVARIABLESTACK*" NULL 0))
    (CL:SETQ
     SYM-WALK-*SPECIALSENABLED?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*SPECIALSENABLED?*" NULL 0))
    (CL:SETQ
     SYM-WALK-*NOFSPECIALSATLOOPENTRY*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*NOFSPECIALSATLOOPENTRY*" NULL 0))
    (CL:SETQ
     KWD-WALK-SAVE-AND-RESTORE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVE-AND-RESTORE" NULL 2))
    (CL:SETQ
     SYM-WALK-EXCEPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXCEPTION" NULL 0))
    (CL:SETQ
     SYM-WALK-RESIGNAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RESIGNAL" NULL 0))
    (CL:SETQ
     SGT-WALK-METHOD-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SLOT" NULL 1))
    (CL:SETQ
     SYM-WALK-OTHERWISE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHERWISE" NULL 0))
    (CL:SETQ
     SYM-WALK-SYMBOL-ID
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-ID" NULL 0))
    (CL:SETQ
     SYM-WALK-GENERALIZED-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL" NULL 0))
    (CL:SETQ
     SYM-WALK-BOOLEAN?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN?" NULL 0))
    (CL:SETQ
     SYM-WALK-INTEGER?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER?" NULL 0))
    (CL:SETQ SYM-WALK-FLOAT? (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT?" NULL 0))
    (CL:SETQ
     SYM-WALK-STRING?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING?" NULL 0))
    (CL:SETQ
     SYM-WALK-CHARACTER?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER?" NULL 0))
    (CL:SETQ
     SYM-WALK-WRAPPER?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAPPER?" NULL 0))
    (CL:SETQ
     SGT-WALK-VERBATIM-STRING-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBATIM-STRING-WRAPPER" NULL 1))
    (CL:SETQ
     SYM-WALK-VERBATIM-STRING?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBATIM-STRING?" NULL 0))
    (CL:SETQ
     SYM-WALK-SURROGATE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE?" NULL 0))
    (CL:SETQ SGT-WALK-TYPE (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 1))
    (CL:SETQ SYM-WALK-TYPE? (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE?" NULL 0))
    (CL:SETQ
     SYM-WALK-SYMBOL?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL?" NULL 0))
    (CL:SETQ
     SGT-WALK-TRANSIENT-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-SYMBOL" NULL 1))
    (CL:SETQ
     SYM-WALK-TRANSIENT-SYMBOL?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-SYMBOL?" NULL 0))
    (CL:SETQ
     SYM-WALK-KEYWORD?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD?" NULL 0))
    (CL:SETQ SYM-WALK-CONS? (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS?" NULL 0))
    (CL:SETQ SYM-WALK-CLASS? (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS?" NULL 0))
    (CL:SETQ
     SGT-WALK-STORAGE-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 1))
    (CL:SETQ
     SYM-WALK-STORAGE-SLOT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT?" NULL 0))
    (CL:SETQ
     SYM-WALK-METHOD-SLOT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SLOT?" NULL 0))
    (CL:SETQ
     SGT-WALK-ANCHORED-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ANCHORED-TYPE-SPECIFIER" NULL 1))
    (CL:SETQ
     SYM-WALK-ANCHORED-TYPE-SPECIFIER?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ANCHORED-TYPE-SPECIFIER?" NULL 0))
    (CL:SETQ
     SGT-WALK-PARAMETRIC-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARAMETRIC-TYPE-SPECIFIER" NULL 1))
    (CL:SETQ
     SYM-WALK-PARAMETRIC-TYPE-SPECIFIER?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARAMETRIC-TYPE-SPECIFIER?" NULL 0))
    (CL:SETQ SYM-WALK-ISA? (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA?" NULL 0))
    (CL:SETQ
     SYM-WALK-TAXONOMY-ISA?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TAXONOMY-ISA?" NULL 0))
    (CL:SETQ
     SYM-WALK-STRING-EQL?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-EQL?" NULL 0))
    (CL:SETQ
     SGT-WALK-STANDARD-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STANDARD-OBJECT" NULL 1))
    (CL:SETQ
     SGT-WALK-LITERAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL" NULL 1))
    (CL:SETQ
     SYM-WALK-EQL-TO-BOOLEAN?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EQL-TO-BOOLEAN?" NULL 0))
    (CL:SETQ
     SYM-WALK-EQL-TO-INTEGER?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EQL-TO-INTEGER?" NULL 0))
    (CL:SETQ
     SYM-WALK-EQL-TO-FLOAT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EQL-TO-FLOAT?" NULL 0))
    (CL:SETQ
     SYM-WALK-EQL-TO-STRING?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EQL-TO-STRING?" NULL 0))
    (CL:SETQ
     SYM-WALK-GET-QUOTED-TREE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-QUOTED-TREE" NULL 0))
    (CL:SETQ KWD-WALK-WARN (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN" NULL 2))
    (CL:SETQ KWD-WALK-ERROR (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
    (CL:SETQ
     KWD-WALK-CONTINUABLE-ERROR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUABLE-ERROR" NULL 2))
    (CL:SETQ SYM-WALK-CONS (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 0))
    (CL:SETQ
     SYM-WALK-CONS-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS-LIST" NULL 0))
    (CL:SETQ
     SYM-WALK-GET-SYM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-SYM" NULL 0))
    (CL:SETQ
     SYM-WALK-GET-SGT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-SGT" NULL 0))
    (CL:SETQ
     SYM-WALK-GET-KWD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-KWD" NULL 0))
    (CL:SETQ
     SGT-WALK-ARGUMENT-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-LIST" NULL 1))
    (CL:SETQ
     SYM-WALK-ANY-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY-VALUE" NULL 0))
    (CL:SETQ
     SYM-WALK-METHOD-INHERITS-THROUGH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-INHERITS-THROUGH" NULL 0))
    (CL:SETQ
     SYM-WALK-SLOT-WRITER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-WRITER" NULL 0))
    (CL:SETQ
     SYM-WALK-LOOKUP-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP-SLOT" NULL 0))
    (CL:SETQ
     SYM-WALK-TYPE-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE-CLASS" NULL 0))
    (CL:SETQ
     SYM-WALK-STORAGE-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 0))
    (CL:SETQ
     KWD-WALK-METHODS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHODS" NULL 2))
    (CL:SETQ
     SYM-WALK-FUNCTION-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE" NULL 0))
    (CL:SETQ
     SYM-WALK-METHOD-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE" NULL 0))
    (CL:SETQ KWD-WALK-METHOD (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD" NULL 2))
    (CL:SETQ KWD-WALK-CLASS (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 2))
    (CL:SETQ
     KWD-WALK-EMBEDDED
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EMBEDDED" NULL 2))
    (CL:SETQ
     SYM-WALK-CLASS-CONSTRUCTOR-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CONSTRUCTOR-CODE" NULL 0))
    (CL:SETQ
     SYM-WALK-SLOT-ACCESSOR-METHODS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-ACCESSOR-METHODS" NULL 0))
    (CL:SETQ
     SYM-WALK-PRINT-FORM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-FORM" NULL 0))
    (CL:SETQ
     SYM-WALK-PRINT-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-OBJECT" NULL 0))
    (CL:SETQ SYM-WALK-SELF (INTERN-RIGID-SYMBOL-WRT-MODULE "SELF" NULL 0))
    (CL:SETQ SYM-WALK-STREAM (INTERN-RIGID-SYMBOL-WRT-MODULE "STREAM" NULL 0))
    (CL:SETQ
     SYM-WALK-NATIVE-OUTPUT-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-OUTPUT-STREAM" NULL 0))
    (CL:SETQ
     KWD-WALK-CLASSES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSES" NULL 2))
    (CL:SETQ
     KWD-WALK-FINALIZE-CLASSES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE-CLASSES" NULL 2))
    (CL:SETQ
     SYM-WALK-FINALIZE-CLASSES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE-CLASSES" NULL 0))
    (CL:SETQ
     KWD-WALK-FINALIZE-METHODS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE-METHODS" NULL 2))
    (CL:SETQ
     SYM-WALK-FINALIZE-SLOTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE-SLOTS" NULL 0))
    (CL:SETQ
     SYM-WALK-CLEANUP-UNFINALIZED-CLASSES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEANUP-UNFINALIZED-CLASSES" NULL 0))
    (CL:SETQ
     SYM-WALK-DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE"
      NULL
      0))
    (CL:SETQ SYM-WALK-OBJECT (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 0))
    (CL:SETQ
     SYM-WALK-METHOD-LISP-MACRO?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-LISP-MACRO?" NULL 0))
    (CL:SETQ
     SYM-WALK-STORE-MACRO
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STORE-MACRO" NULL 0))
    (CL:SETQ
     KWD-WALK-UNBOUND-SPECIAL-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBOUND-SPECIAL-VARIABLE" NULL 2))
    (CL:SETQ
     KWD-WALK-GLOBALS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBALS" NULL 2))
    (CL:SETQ
     SYM-WALK-VARIABLE-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE-SPECIFIER" NULL 0))
    (CL:SETQ
     SYM-WALK-DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE"
      NULL
      0))
    (CL:SETQ SYM-WALK-GLOBAL (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBAL" NULL 0))
    (CL:SETQ
     SYM-WALK-LOOKUP-GLOBAL-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP-GLOBAL-VARIABLE" NULL 0))
    (CL:SETQ
     SYM-WALK-VARIABLE-GET-VALUE-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-GET-VALUE-CODE" NULL 0))
    (CL:SETQ
     SYM-WALK-VARIABLE-SET-VALUE-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-SET-VALUE-CODE" NULL 0))
    (CL:SETQ
     SYM-WALK-DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE"
      NULL
      0))
    (CL:SETQ KWD-WALK-FINAL (INTERN-RIGID-SYMBOL-WRT-MODULE "FINAL" NULL 2))
    (CL:SETQ
     SYM-WALK-CURRENT-STARTUP-TIME-PHASE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-STARTUP-TIME-PHASE?" NULL 0))
    (CL:SETQ
     KWD-WALK-MODULES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULES" NULL 2))
    (CL:SETQ
     SYM-WALK-WITHIN-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WITHIN-MODULE" NULL 0))
    (CL:SETQ
     SYM-WALK-*STELLA-MODULE*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*STELLA-MODULE*" NULL 0))
    (CL:SETQ
     KWD-WALK-AUXILIARY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AUXILIARY?" NULL 2))
    (CL:SETQ
     SYM-WALK-*PENDINGEXCEPTIONHANDLER?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*PENDINGEXCEPTIONHANDLER?*" NULL 0))
    (CL:SETQ
     SYM-WALK-*EXCEPTIONHANDLERADDRESS*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*EXCEPTIONHANDLERADDRESS*" NULL 0))
    (CL:SETQ
     SYM-WALK-*EXCEPTION*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*EXCEPTION*" NULL 0))
    (CL:SETQ
     SYM-WALK-SETUP-LONG-JUMP?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SETUP-LONG-JUMP?" NULL 0))
    (CL:SETQ
     SGT-WALK-EXCEPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXCEPTION" NULL 1))
    (CL:SETQ
     SYM-WALK-SUBTYPE-OF?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF?" NULL 0))
    (CL:SETQ
     SYM-WALK-*EXCEPTION-TYPE*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*EXCEPTION-TYPE*" NULL 0))
    (CL:SETQ
     KWD-WALK-OTHERWISE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHERWISE" NULL 2))
    (CL:SETQ SGT-WALK-CODE (INTERN-RIGID-SYMBOL-WRT-MODULE "CODE" NULL 1))
    (CL:SETQ SYM-WALK-MAIN (INTERN-RIGID-SYMBOL-WRT-MODULE "MAIN" NULL 0))
    (CL:SETQ
     SGT-WALK-COMPOUND-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPOUND-TYPE-SPECIFIER" NULL 1))
    (CL:SETQ
     SYM-WALK-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
    (CL:SETQ
     SYM-WALK-EXPRESSION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXPRESSION" NULL 0))
    (CL:SETQ SYM-WALK-IGNORE (INTERN-RIGID-SYMBOL-WRT-MODULE "IGNORE" NULL 0))
    (CL:SETQ
     SYM-WALK-INCREMENTALLY-TRANSLATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INCREMENTALLY-TRANSLATE" NULL 0))
    (CL:SETQ
     SYM-WALK-REGISTER-NATIVE-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REGISTER-NATIVE-NAME" NULL 0))
    (CL:SETQ SYM-WALK-REST (INTERN-RIGID-SYMBOL-WRT-MODULE "REST" NULL 0))
    (CL:SETQ
     SYM-WALK-NTH-REST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NTH-REST" NULL 0))
    (CL:SETQ SYM-WALK-NTH (INTERN-RIGID-SYMBOL-WRT-MODULE "NTH" NULL 0))
    (CL:SETQ
     SYM-WALK-ARGUMENTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS" NULL 0))
    (CL:SETQ SYM-WALK-RESULT (INTERN-RIGID-SYMBOL-WRT-MODULE "RESULT" NULL 0))
    (CL:SETQ
     SYM-WALK-METHOD-EVALUATE-ARGUMENTS?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-EVALUATE-ARGUMENTS?" NULL 0))
    (CL:SETQ
     SYM-WALK-METHOD-VARIABLE-ARGUMENTS?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-VARIABLE-ARGUMENTS?" NULL 0))
    (CL:SETQ
     SYM-WALK-*EVALUATIONERROR?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*EVALUATIONERROR?*" NULL 0))
    (CL:SETQ
     SYM-WALK-*EVALUATIONTREE*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*EVALUATIONTREE*" NULL 0))
    (CL:SETQ
     SYM-WALK-*EVALUATIONPARENTTREE*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*EVALUATIONPARENTTREE*" NULL 0))
    (CL:SETQ
     SYM-WALK-EVALUATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATE" NULL 0)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:SETQ
     *AVAILABLE-ENVIRONMENT-FEATURES*
     (LIST
      KWD-WALK-WARN-ABOUT-UNDEFINED-METHODS
      KWD-WALK-SUPPRESS-WARNINGS
      KWD-WALK-USE-BOOTSTRAP-TRANSLATOR
      KWD-WALK-WARN-ABOUT-MISSING-METHODS
      KWD-WALK-USE-HARDCODED-SYMBOLS
      KWD-WALK-USE-COMMON-LISP-STRUCTS
      KWD-WALK-USE-COMMON-LISP-VECTOR-STRUCTS
      KWD-WALK-USE-CPP-GARBAGE-COLLECTOR
      KWD-WALK-TRANSLATE-WITH-COPYRIGHT-HEADER))
    (CL:SETQ *CURRENT-ENVIRONMENT-FEATURES* (NEW-LIST))
    (CL:SETQ
     *DEFAULT-ENVIRONMENT-FEATURES*
     (LIST
      KWD-WALK-WARN-ABOUT-UNDEFINED-METHODS
      KWD-WALK-WARN-ABOUT-MISSING-METHODS
      KWD-WALK-USE-CPP-GARBAGE-COLLECTOR))
    (RESET-ENVIRONMENT-FEATURES)
    (CL:SETQ *TARGETTYPE* SGT-WALK-VOID)
    (CL:SETQ
     *WRAPPED-TYPE-TABLE*
     (LIST*
      (LIST* SGT-WALK-INTEGER-WRAPPER SGT-WALK-INTEGER NIL)
      (LIST* SGT-WALK-TRANSIENT-INTEGER-WRAPPER SGT-WALK-INTEGER NIL)
      (LIST* SGT-WALK-FLOAT-WRAPPER SGT-WALK-FLOAT NIL)
      (LIST* SGT-WALK-TRANSIENT-FLOAT-WRAPPER SGT-WALK-FLOAT NIL)
      (LIST* SGT-WALK-NUMBER-WRAPPER SGT-WALK-NUMBER NIL)
      (LIST* SGT-WALK-STRING-WRAPPER SGT-WALK-STRING NIL)
      (LIST* SGT-WALK-TRANSIENT-STRING-WRAPPER SGT-WALK-STRING NIL)
      (LIST* SGT-WALK-CHARACTER-WRAPPER SGT-WALK-CHARACTER NIL)
      (LIST* SGT-WALK-TRANSIENT-CHARACTER-WRAPPER SGT-WALK-CHARACTER NIL)
      (LIST* SGT-WALK-BOOLEAN-WRAPPER SGT-WALK-BOOLEAN NIL)
      (LIST* SGT-WALK-FUNCTION-CODE-WRAPPER SGT-WALK-FUNCTION-CODE NIL)
      (LIST*
       SGT-WALK-TRANSIENT-FUNCTION-CODE-WRAPPER
       SGT-WALK-FUNCTION-CODE
       NIL)
      (LIST* SGT-WALK-METHOD-CODE-WRAPPER SGT-WALK-METHOD-CODE NIL)
      (LIST* SGT-WALK-TRANSIENT-METHOD-CODE-WRAPPER SGT-WALK-METHOD-CODE NIL)
      NIL))
    (CL:SETQ
     *COERSION-TABLE*
     (LIST*
      (LIST*
       SGT-WALK-BOOLEAN
       SGT-WALK-BOOLEAN-WRAPPER
       SYM-WALK-WRAP-BOOLEAN
       NIL)
      (LIST*
       SGT-WALK-INTEGER
       SGT-WALK-INTEGER-WRAPPER
       SYM-WALK-WRAP-LITERAL
       NIL)
      (LIST*
       SGT-WALK-INTEGER
       SGT-WALK-BOOLEAN-WRAPPER
       SYM-WALK-INTEGER-TO-BOOLEAN-WRAPPER
       NIL)
      (LIST*
       SGT-WALK-INTEGER
       SGT-WALK-BOOLEAN
       SYM-WALK-INTEGER-TO-BOOLEAN
       NIL)
      (LIST* SGT-WALK-FLOAT SGT-WALK-FLOAT-WRAPPER SYM-WALK-WRAP-LITERAL NIL)
      (LIST*
       SGT-WALK-STRING
       SGT-WALK-STRING-WRAPPER
       SYM-WALK-WRAP-LITERAL
       NIL)
      (LIST* SGT-WALK-STRING SGT-WALK-SYMBOL SYM-WALK-INTERN-SYMBOL NIL)
      (LIST*
       SGT-WALK-CHARACTER
       SGT-WALK-CHARACTER-WRAPPER
       SYM-WALK-WRAP-LITERAL
       NIL)
      (LIST*
       SGT-WALK-FUNCTION-CODE
       SGT-WALK-FUNCTION-CODE-WRAPPER
       SYM-WALK-WRAP-LITERAL
       NIL)
      (LIST*
       SGT-WALK-METHOD-CODE
       SGT-WALK-METHOD-CODE-WRAPPER
       SYM-WALK-WRAP-LITERAL
       NIL)
      (LIST* SGT-WALK-SYMBOL SGT-WALK-STRING SYM-WALK-SYMBOL-NAME NIL)
      (LIST*
       SGT-WALK-BOOLEAN-WRAPPER
       SGT-WALK-BOOLEAN
       SYM-WALK-WRAPPER-VALUE
       NIL)
      (LIST*
       SGT-WALK-INTEGER-WRAPPER
       SGT-WALK-INTEGER
       SYM-WALK-WRAPPER-VALUE
       NIL)
      (LIST* SGT-WALK-FLOAT-WRAPPER SGT-WALK-FLOAT SYM-WALK-WRAPPER-VALUE NIL)
      (LIST*
       SGT-WALK-STRING-WRAPPER
       SGT-WALK-STRING
       SYM-WALK-WRAPPER-VALUE
       NIL)
      (LIST*
       SGT-WALK-CHARACTER-WRAPPER
       SGT-WALK-CHARACTER
       SYM-WALK-WRAPPER-VALUE
       NIL)
      (LIST*
       SGT-WALK-FUNCTION-CODE-WRAPPER
       SGT-WALK-FUNCTION-CODE
       SYM-WALK-WRAPPER-VALUE
       NIL)
      (LIST*
       SGT-WALK-METHOD-CODE-WRAPPER
       SGT-WALK-METHOD-CODE
       SYM-WALK-WRAPPER-VALUE
       NIL)
      (LIST* SGT-WALK-SURROGATE SGT-WALK-CLASS SYM-WALK-SURROGATE-VALUE NIL)
      (LIST* SGT-WALK-SURROGATE SGT-WALK-MODULE SYM-WALK-SURROGATE-VALUE NIL)
      (LIST*
       SGT-WALK-INPUT-STREAM
       SGT-WALK-NATIVE-INPUT-STREAM
       SYM-WALK-NATIVE-STREAM
       NIL)
      (LIST*
       SGT-WALK-OUTPUT-STREAM
       SGT-WALK-NATIVE-OUTPUT-STREAM
       SYM-WALK-NATIVE-STREAM
       NIL)
      (LIST* SGT-WALK-NUMBER SGT-WALK-INTEGER SYM-WALK-IDENTITY NIL)
      (LIST* SGT-WALK-NUMBER SGT-WALK-FLOAT SYM-WALK-IDENTITY NIL)
      (LIST* SGT-WALK-INTEGER SGT-WALK-FLOAT SYM-WALK-IDENTITY NIL)
      (LIST* SGT-WALK-INTEGER SGT-WALK-SINGLE-FLOAT SYM-WALK-IDENTITY NIL)
      (LIST* SGT-WALK-FLOAT SGT-WALK-SINGLE-FLOAT SYM-WALK-IDENTITY NIL)
      (LIST* SGT-WALK-FLOAT SGT-WALK-DOUBLE-FLOAT SYM-WALK-IDENTITY NIL)
      (LIST* SGT-WALK-INTEGER SGT-WALK-SHORT-INTEGER SYM-WALK-IDENTITY NIL)
      (LIST* SGT-WALK-INTEGER SGT-WALK-LONG-INTEGER SYM-WALK-IDENTITY NIL)
      (LIST*
       SGT-WALK-INTEGER
       SGT-WALK-UNSIGNED-SHORT-INTEGER
       SYM-WALK-IDENTITY
       NIL)
      (LIST*
       SGT-WALK-INTEGER
       SGT-WALK-UNSIGNED-LONG-INTEGER
       SYM-WALK-IDENTITY
       NIL)
      NIL))
    (CL:SETQ *SYMBOL-REGISTRY* (NEW-HASH-TABLE))
    (CL:SETQ *SYMBOL-SET* (NEW-LIST))
    (CL:SETQ *SPECIALVARIABLESTACK* (NEW-KEY-VALUE-LIST))
    (CL:SETQ
     *TYPE-PREDICATE-TABLE*
     (LIST*
      (LIST* SGT-WALK-BOOLEAN SYM-WALK-BOOLEAN? NIL)
      (LIST* SGT-WALK-INTEGER SYM-WALK-INTEGER? NIL)
      (LIST* SGT-WALK-FLOAT SYM-WALK-FLOAT? NIL)
      (LIST* SGT-WALK-STRING SYM-WALK-STRING? NIL)
      (LIST* SGT-WALK-CHARACTER SYM-WALK-CHARACTER? NIL)
      (LIST* SGT-WALK-WRAPPER SYM-WALK-WRAPPER? NIL)
      (LIST* SGT-WALK-BOOLEAN-WRAPPER SYM-WALK-BOOLEAN? NIL)
      (LIST* SGT-WALK-INTEGER-WRAPPER SYM-WALK-INTEGER? NIL)
      (LIST* SGT-WALK-FLOAT-WRAPPER SYM-WALK-FLOAT? NIL)
      (LIST* SGT-WALK-STRING-WRAPPER SYM-WALK-STRING? NIL)
      (LIST* SGT-WALK-CHARACTER-WRAPPER SYM-WALK-CHARACTER? NIL)
      (LIST* SGT-WALK-VERBATIM-STRING-WRAPPER SYM-WALK-VERBATIM-STRING? NIL)
      (LIST* SGT-WALK-SURROGATE SYM-WALK-SURROGATE? NIL)
      (LIST* SGT-WALK-TYPE SYM-WALK-TYPE? NIL)
      (LIST* SGT-WALK-SYMBOL SYM-WALK-SYMBOL? NIL)
      (LIST* SGT-WALK-TRANSIENT-SYMBOL SYM-WALK-TRANSIENT-SYMBOL? NIL)
      (LIST* SGT-WALK-KEYWORD SYM-WALK-KEYWORD? NIL)
      (LIST* SGT-WALK-CONS SYM-WALK-CONS? NIL)
      (LIST* SGT-WALK-CLASS SYM-WALK-CLASS? NIL)
      (LIST* SGT-WALK-STORAGE-SLOT SYM-WALK-STORAGE-SLOT? NIL)
      (LIST* SGT-WALK-METHOD-SLOT SYM-WALK-METHOD-SLOT? NIL)
      (LIST*
       SGT-WALK-ANCHORED-TYPE-SPECIFIER
       SYM-WALK-ANCHORED-TYPE-SPECIFIER?
       NIL)
      (LIST*
       SGT-WALK-PARAMETRIC-TYPE-SPECIFIER
       SYM-WALK-PARAMETRIC-TYPE-SPECIFIER?
       NIL)
      NIL))
    (CL:SETQ
     *NUMERIC-TYPE-HIERARCHY*
     (LIST SGT-WALK-INTEGER SGT-WALK-FLOAT SGT-WALK-NUMBER))
    (CL:SETQ *MACRO-TABLE* (NEW-HASH-TABLE))
    (CL:SETQ *NATIVE-NAME-TABLE* (NEW-HASH-TABLE)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 5) 1)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRANSLATION-UNIT"
        "(DEFCLASS TRANSLATION-UNIT (STANDARD-OBJECT) :SLOTS ((THE-OBJECT :TYPE OBJECT) (CATEGORY :TYPE SYMBOL) (ANNOTATION :TYPE STRING) (AUXILIARY? :TYPE BOOLEAN) (CODE-REGISTER :TYPE OBJECT) (TRANSLATION :TYPE OBJECT) (REFERENCED-GLOBALS :TYPE (LIST OF GLOBAL-VARIABLE) :ALLOCATION :EMBEDDED :COMPONENT? TRUE)) :RECYCLE-METHOD :FREE-LIST :TERMINATOR TERMINATE-TRANSLATION-UNIT? :PRINT-FORM (PRINT-TRANSLATION-UNIT SELF STREAM))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRANSLATION-UNIT))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TRANSLATION-UNIT-SLOT-VALUE))))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DISPLAY-ENVIRONMENT-FEATURES"
        NULL
        "(DEFUN DISPLAY-ENVIRONMENT-FEATURES () :DOCUMENTATION \"Print a list of the currently enabled environment 
features and print a list of all Stella environment features.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DISPLAY-ENVIRONMENT-FEATURES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ENABLE-ENVIRONMENT-FEATURE"
        "ARGUMENT-LIST"
        "(DEFUN ENABLE-ENVIRONMENT-FEATURE (|&REST| (FEATURES KEYWORD)) :DOCUMENTATION \"Enable the environment feature(s) indicated by the
keywords in 'features'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ENABLE-ENVIRONMENT-FEATURE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DISABLE-ENVIRONMENT-FEATURE"
        "ARGUMENT-LIST"
        "(DEFUN DISABLE-ENVIRONMENT-FEATURE (|&REST| (FEATURES KEYWORD)) :DOCUMENTATION \"Disable the environment feature(s) indicated by the
keywords in 'features'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DISABLE-ENVIRONMENT-FEATURE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RESET-ENVIRONMENT-FEATURES"
        NULL
        "(DEFUN RESET-ENVIRONMENT-FEATURES () :DOCUMENTATION \"Reset the current environment features to their default
settings.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RESET-ENVIRONMENT-FEATURES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRACE-IF-EXPANDER"
        "KEYWORD"
        "(DEFUN (TRACE-IF-EXPANDER OBJECT) ((KEYWORD KEYWORD) |&BODY| (BODY CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRACE-IF-EXPANDER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRACE-KEYWORD?"
        "KEYWORD"
        "(DEFUN (TRACE-KEYWORD? BOOLEAN) ((KEYWORD KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRACE-KEYWORD?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ADD-TRACE"
        "ARGUMENT-LIST"
        "(DEFUN (ADD-TRACE LIST) (|&REST| (KEYWORDS GENERALIZED-SYMBOL)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Enable trace messages identified by any of the listed `keywords'.  After
calling `(add-trace <keyword>)' code guarded by `(trace-if <keyword> ...)'
will be executed when it is encountered.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%ADD-TRACE))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-WALK-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION ADD-TRACE-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DROP-TRACE"
        "ARGUMENT-LIST"
        "(DEFUN (DROP-TRACE LIST) (|&REST| (KEYWORDS GENERALIZED-SYMBOL)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Disable trace messages identified by any of the listed `keywords'.  After
calling `(drop-trace <keyword>)' code guarded by `(trace-if <keyword> ...)'
will not be executed when it is encountered.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%DROP-TRACE))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-WALK-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION DROP-TRACE-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR-TRACE"
        NULL
        "(DEFUN CLEAR-TRACE () :COMMAND? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Disable all tracing previously enabled with `add-trace'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLEAR-TRACE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NAME-QUOTED-TREE"
        "CONS"
        "(DEFUN (NAME-QUOTED-TREE STRING) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NAME-QUOTED-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-QUOTED-TREE"
        "STRING"
        "(DEFUN (GET-QUOTED-TREE CONS) ((TREENAME STRING) (MODULENAME STRING)) :DOCUMENTATION \"Return the quoted tree with name 'treeName'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-QUOTED-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TERMINATE-TRANSLATION-UNIT?"
        "TRANSLATION-UNIT"
        "(DEFUN (TERMINATE-TRANSLATION-UNIT? BOOLEAN) ((SELF TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TERMINATE-TRANSLATION-UNIT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-TRANSLATION-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN PRINT-TRANSLATION-UNIT ((SELF TRANSLATION-UNIT) (STREAM NATIVE-OUTPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-TRANSLATION-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "USE-HARDCODED-SYMBOLS?"
        NULL
        "(DEFUN (USE-HARDCODED-SYMBOLS? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION USE-HARDCODED-SYMBOLS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "USE-BOOTSTRAP-TRANSLATOR?"
        NULL
        "(DEFUN (USE-BOOTSTRAP-TRANSLATOR? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION USE-BOOTSTRAP-TRANSLATOR?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TOGGLE-TRANSLATORS"
        NULL
        "(DEFUN (TOGGLE-TRANSLATORS KEYWORD) () :DOCUMENTATION \"Switch between the bootstrap and real translators.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TOGGLE-TRANSLATORS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSLATE-TO-COMMON-LISP?"
        NULL
        "(DEFUN (TRANSLATE-TO-COMMON-LISP? BOOLEAN) () :DOCUMENTATION \"Return TRUE if current output language is Common-Lisp.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSLATE-TO-COMMON-LISP?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?"
        NULL
        "(DEFUN (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TOGGLE-OUTPUT-LANGUAGE"
        NULL
        "(DEFUN (TOGGLE-OUTPUT-LANGUAGE KEYWORD) () :DOCUMENTATION \"Switch between Common Lisp and C++ as output languages.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TOGGLE-OUTPUT-LANGUAGE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DECLARATION-OPERATOR?"
        "SYMBOL"
        "(DEFUN (DECLARATION-OPERATOR? BOOLEAN) ((OPERATOR SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DECLARATION-OPERATOR?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DECLARATION-TREE?"
        "CONS"
        "(DEFUN (DECLARATION-TREE? BOOLEAN) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DECLARATION-TREE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-ANNOTATION"
        "CONS"
        "(DEFUN (CREATE-ANNOTATION STRING) ((TOP-LEVEL-TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-ANNOTATION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-TOP-LEVEL-TREE"
        "CONS"
        "(DEFUN WALK-TOP-LEVEL-TREE ((TREE CONS) (CREATEANNOTATION? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-TOP-LEVEL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-TOP-LEVEL-EXPRESSION"
        "OBJECT"
        "(DEFUN (WALK-TOP-LEVEL-EXPRESSION OBJECT) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-TOP-LEVEL-EXPRESSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-PHASE-ONE-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN WALK-PHASE-ONE-UNIT ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-PHASE-ONE-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-AUXILIARY-TREE"
        "CONS"
        "(DEFUN WALK-AUXILIARY-TREE ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-AUXILIARY-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-WALK-AUXILIARY-TREE"
        "CONS"
        "(DEFUN (HELP-WALK-AUXILIARY-TREE TRANSLATION-UNIT) ((TREE CONS) (FINALIZE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-WALK-AUXILIARY-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-ALL-PHASE-ONE-UNITS"
        "SYMBOL"
        "(DEFUN WALK-ALL-PHASE-ONE-UNITS ((STARTUPFNNAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-ALL-PHASE-ONE-UNITS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSLATE-ALL-UNITS"
        NULL
        "(DEFUN TRANSLATE-ALL-UNITS ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSLATE-ALL-UNITS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMBINE-TRANSLATED-TREES"
        NULL
        "(DEFUN (COMBINE-TRANSLATED-TREES CONS) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMBINE-TRANSLATED-TREES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSLATE-WALKED-TREE"
        "OBJECT"
        "(DEFUN (TRANSLATE-WALKED-TREE OBJECT) ((CODETREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSLATE-WALKED-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSLATOR-OUTPUT-LANGUAGE"
        NULL
        "(DEFUN (TRANSLATOR-OUTPUT-LANGUAGE KEYWORD) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSLATOR-OUTPUT-LANGUAGE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SET-TRANSLATOR-OUTPUT-LANGUAGE"
        "KEYWORD"
        "(DEFUN (SET-TRANSLATOR-OUTPUT-LANGUAGE KEYWORD) ((NEWLANGUAGE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SET-TRANSLATOR-OUTPUT-LANGUAGE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RESET-TRANSLATION-ERRORS"
        NULL
        "(DEFUN RESET-TRANSLATION-ERRORS ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RESET-TRANSLATION-ERRORS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIGNAL-TRANSLATION-ERROR"
        NULL
        "(DEFUN SIGNAL-TRANSLATION-ERROR ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIGNAL-TRANSLATION-ERROR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIGNAL-TRANSLATION-WARNING"
        NULL
        "(DEFUN SIGNAL-TRANSLATION-WARNING ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIGNAL-TRANSLATION-WARNING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "IGNORE-TRANSLATION-ERRORS?"
        NULL
        "(DEFUN (IGNORE-TRANSLATION-ERRORS? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION IGNORE-TRANSLATION-ERRORS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSLATION-ERRORS?"
        NULL
        "(DEFUN (TRANSLATION-ERRORS? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSLATION-ERRORS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUMMARIZE-TRANSLATION-ERRORS"
        NULL
        "(DEFUN SUMMARIZE-TRANSLATION-ERRORS ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SUMMARIZE-TRANSLATION-ERRORS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-ERROR-CONTEXT"
        "STRING"
        "(DEFUN PRINT-ERROR-CONTEXT ((PREFIX STRING) (STREAM OUTPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-ERROR-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PUSH-VARIABLE-BINDING"
        "SYMBOL"
        "(DEFUN PUSH-VARIABLE-BINDING ((VARIABLE SYMBOL) (TYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PUSH-VARIABLE-BINDING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POP-VARIABLE-BINDING"
        NULL
        "(DEFUN POP-VARIABLE-BINDING ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION POP-VARIABLE-BINDING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-VARIABLE-TYPE"
        "SYMBOL"
        "(DEFUN (LOOKUP-VARIABLE-TYPE TYPE-SPEC) ((VARIABLENAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-VARIABLE-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REGISTER-REFERENCE-TO-GLOBAL-VARIABLE"
        "SYMBOL"
        "(DEFUN REGISTER-REFERENCE-TO-GLOBAL-VARIABLE ((VARIABLENAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REGISTER-REFERENCE-TO-GLOBAL-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOCAL-GENSYM"
        "STRING"
        "(DEFUN (LOCAL-GENSYM SYMBOL) ((PREFIX STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOCAL-GENSYM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-TRANSIENT-TYPE-SPEC"
        "TYPE-SPEC"
        "(DEFUN FREE-TRANSIENT-TYPE-SPEC ((SELF TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FREE-TRANSIENT-TYPE-SPEC)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUPPRESS-WARNINGS?"
        NULL
        "(DEFUN (SUPPRESS-WARNINGS? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SUPPRESS-WARNINGS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BAD-ARGUMENT-RANGE?"
        "CONS"
        "(DEFUN (BAD-ARGUMENT-RANGE? BOOLEAN) ((TREE CONS) (MINARITY INTEGER) (MAXARITY INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BAD-ARGUMENT-RANGE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BAD-ARGUMENT-COUNT?"
        "CONS"
        "(DEFUN (BAD-ARGUMENT-COUNT? BOOLEAN) ((TREE CONS) (ARITY INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BAD-ARGUMENT-COUNT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-ILLEGAL-STATEMENT-TREE"
        NULL
        "(DEFUN (YIELD-ILLEGAL-STATEMENT-TREE CONS) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-ILLEGAL-STATEMENT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-ILLEGAL-EXPRESSION-TREE"
        NULL
        "(DEFUN (YIELD-ILLEGAL-EXPRESSION-TREE OBJECT) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-ILLEGAL-EXPRESSION-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-DONT-CALL-ME-TREE"
        "OBJECT"
        "(DEFUN (WALK-DONT-CALL-ME-TREE CONS TYPE-SPEC) ((TREE OBJECT) (RETURNTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-DONT-CALL-ME-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ILLEGAL-TREE?"
        "OBJECT"
        "(DEFUN (ILLEGAL-TREE? BOOLEAN) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ILLEGAL-TREE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NATIVE-CLASS-METHOD-INLINING?"
        NULL
        "(DEFUN (NATIVE-CLASS-METHOD-INLINING? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NATIVE-CLASS-METHOD-INLINING?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PROGNIFY"
        "CONS"
        "(DEFUN (PROGNIFY OBJECT) ((TREES CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PROGNIFY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "OPTIMIZE-PROGN"
        "CONS"
        "(DEFUN (OPTIMIZE-PROGN OBJECT) ((PROGN-TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION OPTIMIZE-PROGN)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TREE-TO-TREES"
        "OBJECT"
        "(DEFUN (TREE-TO-TREES CONS) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TREE-TO-TREES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WRAPPED-TYPE-TO-TYPE"
        "TYPE"
        "(DEFUN (WRAPPED-TYPE-TO-TYPE TYPE) ((SELF TYPE)) :DOCUMENTATION \"Return the unwrapped type for the wrapped type 'self',
or 'self' if it is not a wrapped type.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WRAPPED-TYPE-TO-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WRAPPER-VALUE-TYPE"
        "WRAPPER"
        "(DEFUN (WRAPPER-VALUE-TYPE TYPE) ((SELF WRAPPER)) :DOCUMENTATION \"Return the type of the value stored in the wrapper 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WRAPPER-VALUE-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TYPE-TO-WRAPPED-TYPE"
        "SURROGATE"
        "(DEFMETHOD (TYPE-TO-WRAPPED-TYPE TYPE) ((SELF TYPE)) :DOCUMENTATION \"Return the wrapped type for the type 'self',
or 'self' if it is not a bare literal type.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION TYPE-TO-WRAPPED-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-COERSION-METHOD"
        "TYPE"
        "(DEFUN (LOOKUP-COERSION-METHOD SYMBOL) ((SOURCETYPE TYPE) (TARGETTYPE TYPE) (EXPRESSION OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-COERSION-METHOD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSLATING-CODE?"
        NULL
        "(DEFUN (TRANSLATING-CODE? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSLATING-CODE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VERIFY-TYPE"
        "TYPE"
        "(DEFUN (VERIFY-TYPE TYPE) ((SELF TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VERIFY-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SAFE-SUBTYPE-OF?"
        "TYPE"
        "(DEFUN (SAFE-SUBTYPE-OF? BOOLEAN) ((SUBTYPE TYPE) (SUPERTYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SAFE-SUBTYPE-OF?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WARN-ABOUT-UNKNOWN-SOURCE-TYPE"
        "OBJECT"
        "(DEFUN WARN-ABOUT-UNKNOWN-SOURCE-TYPE ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WARN-ABOUT-UNKNOWN-SOURCE-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COERCE-A-TREE"
        "OBJECT"
        "(DEFUN (COERCE-A-TREE OBJECT TYPE-SPEC) ((TREE OBJECT) (SOURCETYPE TYPE-SPEC) (TARGETTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COERCE-A-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-COERCE-A-TREE"
        "OBJECT"
        "(DEFUN (HELP-COERCE-A-TREE OBJECT TYPE-SPEC BOOLEAN) ((TREE OBJECT) (SOURCETYPE TYPE-SPEC) (TARGETTYPE TYPE-SPEC) (TESTONLY? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-COERCE-A-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COERCIBLE?"
        "OBJECT"
        "(DEFUN (COERCIBLE? BOOLEAN) ((TREE OBJECT) (SOURCETYPE TYPE-SPEC) (TARGETTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COERCIBLE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALKING-EXPRESSION?"
        NULL
        "(DEFUN (WALKING-EXPRESSION? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALKING-EXPRESSION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-EXPRESSION-TREE"
        "OBJECT"
        "(DEFUN (WALK-EXPRESSION-TREE OBJECT TYPE-SPEC) ((EXPTREE OBJECT) (TARGETTYPE TYPE-SPEC) (OPERATORNAME SYMBOL) (VRLETISOK? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-EXPRESSION-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-WITHOUT-TYPE-TREE"
        "OBJECT"
        "(DEFUN (WALK-WITHOUT-TYPE-TREE OBJECT) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-WITHOUT-TYPE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-LIST-OF-TREES"
        "CONS"
        "(DEFUN (WALK-LIST-OF-TREES CONS) ((TREES CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-LIST-OF-TREES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-STATEMENT"
        "OBJECT"
        "(DEFUN (WALK-STATEMENT OBJECT) ((TREE OBJECT) (WARNONATOM? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-STATEMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ELIMINATE-VRLET-STATEMENT"
        "CONS"
        "(DEFUN (ELIMINATE-VRLET-STATEMENT CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ELIMINATE-VRLET-STATEMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SYS-TREE"
        "OBJECT"
        "(DEFUN (SYS-TREE CONS TYPE-SPEC) ((TREE OBJECT) (TYPESPEC TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SYS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALKED-EXPRESSION-TYPE"
        "OBJECT"
        "(DEFUN (WALKED-EXPRESSION-TYPE TYPE-SPEC) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALKED-EXPRESSION-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEED-IDENTICAL-METHOD-SIGNATURES?"
        NULL
        "(DEFUN (NEED-IDENTICAL-METHOD-SIGNATURES? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NEED-IDENTICAL-METHOD-SIGNATURES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-MOST-GENERAL-RETURN-TYPE"
        "METHOD-SLOT"
        "(DEFUN (COMPUTE-MOST-GENERAL-RETURN-TYPE TYPE-SPEC) ((METHOD METHOD-SLOT) (RETURNTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-MOST-GENERAL-RETURN-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-REAL-SLOT-TYPE"
        "STORAGE-SLOT"
        "(DEFUN (COMPUTE-REAL-SLOT-TYPE TYPE-SPEC) ((SLOT STORAGE-SLOT) (FIRSTARGTYPE TYPE-SPEC) (RETURNTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-REAL-SLOT-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SYS-TREE-IF-NEEDED"
        "SLOT"
        "(DEFUN (SYS-TREE-IF-NEEDED OBJECT TYPE-SPEC) ((SLOT SLOT) (TREE OBJECT) (FIRSTARGTYPE TYPE-SPEC) (RETURNTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SYS-TREE-IF-NEEDED)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TARGET-LANGUAGE-TYPE"
        "OBJECT"
        "(DEFUN (TARGET-LANGUAGE-TYPE TYPE) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TARGET-LANGUAGE-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SET-TARGET-LANGUAGE-TYPE"
        "CONS"
        "(DEFUN (SET-TARGET-LANGUAGE-TYPE CONS TYPE-SPEC) ((SYSTREE CONS) (TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SET-TARGET-LANGUAGE-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DELETE-NULL-STATEMENTS"
        "CONS"
        "(DEFUN (DELETE-NULL-STATEMENTS CONS) ((TREES CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DELETE-NULL-STATEMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-A-TREE"
        "OBJECT"
        "(DEFUN (WALK-A-TREE OBJECT TYPE-SPEC) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-A-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-WALK-A-TREE"
        "OBJECT"
        "(DEFUN (HELP-WALK-A-TREE OBJECT TYPE-SPEC) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-WALK-A-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-A-CONS-TREE"
        "CONS"
        "(DEFUN (WALK-A-CONS-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-A-CONS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INCREMENTAL-TRANSLATION?"
        NULL
        "(DEFUN (INCREMENTAL-TRANSLATION? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INCREMENTAL-TRANSLATION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-SYMBOL-CONSTANT-NAME"
        "GENERALIZED-SYMBOL"
        "(DEFUN (YIELD-SYMBOL-CONSTANT-NAME SYMBOL) ((SYMBOL GENERALIZED-SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-SYMBOL-CONSTANT-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-STARTUP-SYMBOL"
        "GENERALIZED-SYMBOL"
        "(DEFUN (CREATE-STARTUP-SYMBOL SYMBOL) ((SYMBOL GENERALIZED-SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-STARTUP-SYMBOL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REGISTER-SYMBOL"
        "GENERALIZED-SYMBOL"
        "(DEFUN REGISTER-SYMBOL ((SYMBOL GENERALIZED-SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REGISTER-SYMBOL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR-SYMBOL-REGISTRY"
        NULL
        "(DEFUN CLEAR-SYMBOL-REGISTRY ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLEAR-SYMBOL-REGISTRY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-HARDCODED-INTERN-REGISTERED-SYMBOLS-TREE"
        NULL
        "(DEFUN (YIELD-HARDCODED-INTERN-REGISTERED-SYMBOLS-TREE CONS) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-HARDCODED-INTERN-REGISTERED-SYMBOLS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-ATOMIC-TREE"
        "OBJECT"
        "(DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION WALK-ATOMIC-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-ATOMIC-TREE"
        "WRAPPER"
        "(DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ((SELF WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION WALK-ATOMIC-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-CONSTANT-SYMBOL"
        "SYMBOL"
        "(DEFUN (LOOKUP-CONSTANT-SYMBOL TYPE) ((SELF SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-CONSTANT-SYMBOL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONSTANT-SYMBOL?"
        "SYMBOL"
        "(DEFUN (CONSTANT-SYMBOL? BOOLEAN) ((SYMBOL SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONSTANT-SYMBOL?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-CONSTANT-SYMBOL"
        "SYMBOL"
        "(DEFUN (WALK-CONSTANT-SYMBOL SYMBOL TYPE) ((SELF SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-CONSTANT-SYMBOL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-ATOMIC-TREE"
        "SYMBOL"
        "(DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ((SELF SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION WALK-ATOMIC-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-ATOMIC-TREE"
        "KEYWORD"
        "(DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ((SELF KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION WALK-ATOMIC-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-ATOMIC-TREE"
        "SURROGATE"
        "(DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ((SELF SURROGATE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION WALK-ATOMIC-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VRLET-EXPRESSION?"
        "OBJECT"
        "(DEFUN (VRLET-EXPRESSION? BOOLEAN) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VRLET-EXPRESSION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PROCEDURAL-EXPRESSION?"
        "OBJECT"
        "(DEFUN (PROCEDURAL-EXPRESSION? BOOLEAN) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PROCEDURAL-EXPRESSION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBSTITUTE-ONCE"
        "OBJECT"
        "(DEFUN (SUBSTITUTE-ONCE BOOLEAN) ((EXPRESSION OBJECT) (NEWTREE OBJECT) (OLDTREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SUBSTITUTE-ONCE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSFORM-VRLET-EXPRESSION"
        "CONS"
        "(DEFUN (TRANSFORM-VRLET-EXPRESSION CONS TYPE-SPEC) ((STATEMENT CONS) (VREXPRESSION CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSFORM-VRLET-EXPRESSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION"
        "OBJECT"
        "(DEFUN (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION CONS) ((EXPRESSION OBJECT) (TESTVARIABLE SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION"
        "CONS"
        "(DEFUN (TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION CONS TYPE-SPEC) ((STATEMENT CONS) (VREXPRESSION CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PERCOLATE-OUT-BOOLEAN-VRLET-EXPRESSIONS"
        "CONS"
        "(DEFUN (PERCOLATE-OUT-BOOLEAN-VRLET-EXPRESSIONS CONS) ((BOOLEANEXPRESSION CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PERCOLATE-OUT-BOOLEAN-VRLET-EXPRESSIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSFORM-PROCEDURAL-EXPRESSION"
        "CONS"
        "(DEFUN (TRANSFORM-PROCEDURAL-EXPRESSION CONS TYPE-SPEC) ((STATEMENT CONS) (VREXPRESSION CONS) (TYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSFORM-PROCEDURAL-EXPRESSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PERCOLATE-OUT-VRLET-EXPRESSION"
        "CONS"
        "(DEFUN (PERCOLATE-OUT-VRLET-EXPRESSION CONS TYPE-SPEC) ((STATEMENT CONS) (VREXPRESSION CONS) (TYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PERCOLATE-OUT-VRLET-EXPRESSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-SETQ-TREE"
        "CONS"
        "(DEFUN (WALK-SETQ-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-SETQ-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-FIXED-SLOT-VALUE-SETTER-TREE"
        "SLOT"
        "(DEFUN (YIELD-FIXED-SLOT-VALUE-SETTER-TREE CONS) ((SLOT SLOT) (OBJECTREF OBJECT) (VALUETREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-FIXED-SLOT-VALUE-SETTER-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-SETF-TREE"
        "CONS"
        "(DEFUN (WALK-SETF-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-SETF-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-DYNAMIC-SLOT-VALUE-TREE"
        "STORAGE-SLOT"
        "(DEFUN (YIELD-DYNAMIC-SLOT-VALUE-TREE CONS) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (RETURNTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-DYNAMIC-SLOT-VALUE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE"
        "STORAGE-SLOT"
        "(DEFUN (YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE CONS) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (VALUEREF OBJECT) (RETURNTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-NATIVE-SLOT-VALUE-TREE"
        "STORAGE-SLOT"
        "(DEFUN (YIELD-NATIVE-SLOT-VALUE-TREE CONS) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (OBJECTTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-NATIVE-SLOT-VALUE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE"
        "STORAGE-SLOT"
        "(DEFUN (YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE CONS TYPE-SPEC) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (RETURNTYPE TYPE-SPEC) (CSOPTIONS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-SLOT-VALUE-TREE"
        "STORAGE-SLOT"
        "(DEFUN (YIELD-SLOT-VALUE-TREE CONS TYPE-SPEC) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (OBJECTTYPE TYPE-SPEC) (RETURNTYPE TYPE-SPEC) (CSOPTIONS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-SLOT-VALUE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-SLOT-VALUE-TREE"
        "CONS"
        "(DEFUN (WALK-SLOT-VALUE-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-SLOT-VALUE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-NATIVE-SLOT-VALUE-SETTER-TREE"
        "STORAGE-SLOT"
        "(DEFUN (YIELD-NATIVE-SLOT-VALUE-SETTER-TREE CONS) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (OBJECTTYPE TYPE-SPEC) (VALUEREF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-NATIVE-SLOT-VALUE-SETTER-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE"
        "STORAGE-SLOT"
        "(DEFUN (YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE CONS TYPE-SPEC) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (VALUEREF OBJECT) (RETURNTYPE TYPE-SPEC) (CSOPTIONS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-SLOT-VALUE-SETTER-TREE"
        "STORAGE-SLOT"
        "(DEFUN (YIELD-SLOT-VALUE-SETTER-TREE CONS TYPE-SPEC) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (OBJECTTYPE TYPE-SPEC) (VALUEREF OBJECT) (RETURNTYPE TYPE-SPEC) (CSOPTIONS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-SLOT-VALUE-SETTER-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-SLOT-VALUE-SETTER-TREE"
        "CONS"
        "(DEFUN (WALK-SLOT-VALUE-SETTER-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-SLOT-VALUE-SETTER-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SAFE-YIELD-TYPE-SPECIFIER"
        "OBJECT"
        "(DEFUN (SAFE-YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPETREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SAFE-YIELD-TYPE-SPECIFIER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-A-DECLARATION"
        "SYMBOL"
        "(DEFUN (WALK-A-DECLARATION CONS) ((VARIABLE SYMBOL) (TYPETREE OBJECT) (VALUE OBJECT) (INPUTPARAMETER? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-A-DECLARATION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-VARIABLE-DECLARATIONS"
        "CONS"
        "(DEFUN (WALK-VARIABLE-DECLARATIONS CONS) ((DECLARATIONS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-VARIABLE-DECLARATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSFORM-LET-WITH-PROCEDURAL-EXPRESSION"
        "CONS"
        "(DEFUN (TRANSFORM-LET-WITH-PROCEDURAL-EXPRESSION CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSFORM-LET-WITH-PROCEDURAL-EXPRESSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POP-LOCAL-VARIABLE-BINDINGS"
        "CONS"
        "(DEFUN POP-LOCAL-VARIABLE-BINDINGS ((DECLARATIONS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION POP-LOCAL-VARIABLE-BINDINGS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-LET-TREE"
        "CONS"
        "(DEFUN (WALK-LET-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-LET-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SPECIAL-IMPLEMENTATION-STYLE"
        NULL
        "(DEFUN (SPECIAL-IMPLEMENTATION-STYLE KEYWORD) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SPECIAL-IMPLEMENTATION-STYLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PUSH-SPECIAL"
        "SYMBOL"
        "(DEFUN PUSH-SPECIAL ((VARIABLE SYMBOL) (OLDVALUEVARIABLE SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PUSH-SPECIAL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POP-SPECIAL"
        NULL
        "(DEFUN POP-SPECIAL ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION POP-SPECIAL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-OLD-VALUE-VARIABLE"
        "SYMBOL"
        "(DEFUN (LOOKUP-OLD-VALUE-VARIABLE SYMBOL) ((VARIABLE SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-OLD-VALUE-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEED-TO-UNBIND-SPECIALS?"
        NULL
        "(DEFUN (NEED-TO-UNBIND-SPECIALS? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NEED-TO-UNBIND-SPECIALS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-SPECIAL-UNBIND-TREE"
        "INTEGER"
        "(DEFUN (YIELD-SPECIAL-UNBIND-TREE CONS) ((NOFBINDINGS INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-SPECIAL-UNBIND-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-RETURN-SPECIAL-UNBIND-TREE"
        NULL
        "(DEFUN (YIELD-RETURN-SPECIAL-UNBIND-TREE CONS) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-RETURN-SPECIAL-UNBIND-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-LOOP-EXIT-SPECIAL-UNBIND-TREE"
        NULL
        "(DEFUN (YIELD-LOOP-EXIT-SPECIAL-UNBIND-TREE CONS) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-LOOP-EXIT-SPECIAL-UNBIND-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-SPECIAL-TREE"
        "CONS"
        "(DEFUN (WALK-SPECIAL-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-SPECIAL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-CL-SPECIAL-TREE"
        "CONS"
        "(DEFUN (WALK-CL-SPECIAL-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-CL-SPECIAL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-SAVE-AND-RESTORE-SPECIAL-TREE"
        "CONS"
        "(DEFUN (WALK-SAVE-AND-RESTORE-SPECIAL-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-SAVE-AND-RESTORE-SPECIAL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-PROTECTED-SAVE-AND-RESTORE-SPECIAL-TREE"
        "CONS"
        "(DEFUN (WALK-PROTECTED-SAVE-AND-RESTORE-SPECIAL-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-PROTECTED-SAVE-AND-RESTORE-SPECIAL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-CAST-TREE"
        "CONS"
        "(DEFUN (WALK-CAST-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-CAST-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VALUES-TREE?"
        "OBJECT"
        "(DEFUN (VALUES-TREE? BOOLEAN) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VALUES-TREE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-VALUES-TREE"
        "CONS"
        "(DEFUN (WALK-VALUES-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-VALUES-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-MV-EXPRESSION-TREE"
        "OBJECT"
        "(DEFUN (WALK-MV-EXPRESSION-TREE OBJECT CONS (LIST OF TYPE-SPEC)) ((TREE OBJECT) (TARGETTYPES (LIST OF TYPE-SPEC)) (OPERATOR SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-MV-EXPRESSION-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LISTIFY-TYPE-SPEC"
        "TYPE-SPEC"
        "(DEFUN (LISTIFY-TYPE-SPEC (LIST OF TYPE-SPEC)) ((TYPESPEC TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LISTIFY-TYPE-SPEC)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SLOT-FROM-EXPRESSION-TREE"
        "CONS"
        "(DEFUN (SLOT-FROM-EXPRESSION-TREE SLOT) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SLOT-FROM-EXPRESSION-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-MV-TREE"
        "OBJECT"
        "(DEFUN (WALK-MV-TREE OBJECT CONS (LIST OF TYPE-SPEC)) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-MV-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-MV-VALUES-TREE"
        "CONS"
        "(DEFUN (WALK-MV-VALUES-TREE CONS CONS (LIST OF TYPE-SPEC)) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-MV-VALUES-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COERCE-MV-TREE"
        "OBJECT"
        "(DEFUN (COERCE-MV-TREE OBJECT CONS (LIST OF TYPE-SPEC)) ((TREE OBJECT) (OPERATOR SYMBOL) (SOURCETYPES (LIST OF TYPE-SPEC)) (TARGETTYPES (LIST OF TYPE-SPEC))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COERCE-MV-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-RETURN-AND-UNBIND-SPECIALS"
        "CONS"
        "(DEFUN (WALK-RETURN-AND-UNBIND-SPECIALS CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-RETURN-AND-UNBIND-SPECIALS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-RETURN-TREE"
        "CONS"
        "(DEFUN (WALK-RETURN-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-RETURN-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-MV-SETQ-TREE"
        "CONS"
        "(DEFUN (WALK-MV-SETQ-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-MV-SETQ-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-MV-BIND-TREE"
        "CONS"
        "(DEFUN (WALK-MV-BIND-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-MV-BIND-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-LOOP-TREE"
        "CONS"
        "(DEFUN (WALK-LOOP-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-LOOP-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-LOOP-EXIT-TREE"
        "CONS"
        "(DEFUN (WALK-LOOP-EXIT-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-LOOP-EXIT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-WHILE-TREE"
        "CONS"
        "(DEFUN (WALK-WHILE-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-WHILE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-CONDITIONAL-TREE"
        "CONS"
        "(DEFUN (WALK-CONDITIONAL-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-CONDITIONAL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-CHOOSE-TREE"
        "CONS"
        "(DEFUN (WALK-CHOOSE-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-CHOOSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-BOOLEAN-TREE"
        "CONS"
        "(DEFUN (WALK-BOOLEAN-TREE OBJECT TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-BOOLEAN-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "AND-OR-NOT-TREE?"
        "OBJECT"
        "(DEFUN (AND-OR-NOT-TREE? BOOLEAN) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION AND-OR-NOT-TREE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-WALK-BOOLEAN-TREE"
        "CONS"
        "(DEFUN (HELP-WALK-BOOLEAN-TREE OBJECT) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-WALK-BOOLEAN-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-COND-TREE"
        "CONS"
        "(DEFUN (WALK-COND-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-COND-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COND-TREE-TO-IF-TREE"
        "CONS"
        "(DEFUN (COND-TREE-TO-IF-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COND-TREE-TO-IF-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS"
        "OBJECT"
        "(DEFUN (YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS OBJECT) ((CASETEST OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-HARDCODED-SYMBOL-CASE-TREE"
        "CONS"
        "(DEFUN (WALK-HARDCODED-SYMBOL-CASE-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-HARDCODED-SYMBOL-CASE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-COND-TEST"
        "OBJECT"
        "(DEFUN (YIELD-COND-TEST CONS) ((CASETEST OBJECT) (TESTVARIABLE SYMBOL) (EQUALITYTEST SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-COND-TEST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-COND-TEST-OR-TESTS"
        "OBJECT"
        "(DEFUN (YIELD-COND-TEST-OR-TESTS OBJECT) ((CASETEST OBJECT) (TESTVARIABLE SYMBOL) (EQUALITYTEST SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-COND-TEST-OR-TESTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-NON-BUILT-IN-CASE-TREE"
        "CONS"
        "(DEFUN (WALK-NON-BUILT-IN-CASE-TREE CONS TYPE-SPEC) ((TREE CONS) (EQUALITYTEST SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-NON-BUILT-IN-CASE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-CASE-TREE"
        "CONS"
        "(DEFUN (WALK-CASE-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-CASE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-TYPECASE-TREE"
        "CONS"
        "(DEFUN (WALK-TYPECASE-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-TYPECASE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINISH-WALKING-EQL-TREE"
        "CONS"
        "(DEFUN (FINISH-WALKING-EQL-TREE CONS TYPE-SPEC) ((TREE CONS) (TYPE1 TYPE) (TYPE2 TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINISH-WALKING-EQL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINISH-WALKING-EQUAL-TREE"
        "CONS"
        "(DEFUN (FINISH-WALKING-EQUAL-TREE CONS TYPE-SPEC) ((TREE CONS) (TYPE1 TYPE) (TYPE2 TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINISH-WALKING-EQUAL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-EQUALITY-TREE"
        "CONS"
        "(DEFUN (WALK-EQUALITY-TREE OBJECT TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-EQUALITY-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MORE-GENERAL-NUMERIC-TYPE"
        "TYPE"
        "(DEFUN (MORE-GENERAL-NUMERIC-TYPE TYPE) ((TYPE1 TYPE) (TYPE2 TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MORE-GENERAL-NUMERIC-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-ARITHMETIC-OPERATOR-CALL-TREE"
        "SYMBOL"
        "(DEFUN (YIELD-ARITHMETIC-OPERATOR-CALL-TREE CONS) ((OPERATOR SYMBOL) (OPERANDS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-ARITHMETIC-OPERATOR-CALL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-NESTED-ARITHMETIC-OPERATOR-CALL-TREE"
        "SYMBOL"
        "(DEFUN (YIELD-NESTED-ARITHMETIC-OPERATOR-CALL-TREE CONS) ((OPERATOR SYMBOL) (OPERANDS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-NESTED-ARITHMETIC-OPERATOR-CALL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-ARITHMETIC-TREE"
        "CONS"
        "(DEFUN (WALK-ARITHMETIC-TREE OBJECT TYPE) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-ARITHMETIC-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-QUOTED-TREE"
        "CONS"
        "(DEFUN (WALK-QUOTED-TREE OBJECT TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-QUOTED-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-BQUOTE-TREE"
        "CONS"
        "(DEFUN (WALK-BQUOTE-TREE OBJECT TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-BQUOTE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXPAND-MACRO"
        "CONS"
        "(DEFUN (EXPAND-MACRO OBJECT) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXPAND-MACRO)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-MACRO-TREE"
        "CONS"
        "(DEFUN (WALK-MACRO-TREE OBJECT TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-MACRO-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-PRINT-STREAM-TREE"
        "CONS"
        "(DEFUN (WALK-PRINT-STREAM-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-PRINT-STREAM-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WARN-ABOUT-UNDEFINED-METHODS?"
        NULL
        "(DEFUN (WARN-ABOUT-UNDEFINED-METHODS? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WARN-ABOUT-UNDEFINED-METHODS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WARN-ABOUT-MISSING-METHODS?"
        NULL
        "(DEFUN (WARN-ABOUT-MISSING-METHODS? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WARN-ABOUT-MISSING-METHODS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-UNDEFINED-SLOT-TREE"
        "CONS"
        "(DEFUN (WALK-UNDEFINED-SLOT-TREE CONS TYPE) ((TREE CONS) (FIRSTARGTYPE TYPE-SPEC) (WARN? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-UNDEFINED-SLOT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-SLOT-ON-ABSTRACT-TYPE-TREE"
        "CONS"
        "(DEFUN (WALK-SLOT-ON-ABSTRACT-TYPE-TREE CONS TYPE-SPEC) ((TREE CONS) (ABSTRACTTYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-SLOT-ON-ABSTRACT-TYPE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-PROTOTYPE-METHOD"
        "SYMBOL"
        "(DEFUN (FIND-PROTOTYPE-METHOD METHOD-SLOT) ((METHODNAME SYMBOL) (ABSTRACTTYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-PROTOTYPE-METHOD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPATIBLE-REAL-METHODS"
        "METHOD-SLOT"
        "(DEFUN (COMPATIBLE-REAL-METHODS INTEGER INTEGER BOOLEAN) ((PROTOTYPEMETHOD METHOD-SLOT) (ABSTRACTTYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPATIBLE-REAL-METHODS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINISH-WALKING-CALL-SLOT-TREE"
        "SLOT"
        "(DEFMETHOD (FINISH-WALKING-CALL-SLOT-TREE CONS TYPE-SPEC) ((SELF SLOT) (TREE CONS) (FIRSTARGTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FINISH-WALKING-CALL-SLOT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINISH-WALKING-CALL-SLOT-TREE"
        "STORAGE-SLOT"
        "(DEFMETHOD (FINISH-WALKING-CALL-SLOT-TREE CONS TYPE-SPEC) ((SELF STORAGE-SLOT) (TREE CONS) (FIRSTARGTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FINISH-WALKING-CALL-SLOT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-LISTIFIED-VARIABLE-ARGUMENTS"
        "CONS"
        "(DEFUN (YIELD-LISTIFIED-VARIABLE-ARGUMENTS CONS) ((WALKEDARGS CONS) (TARGETTYPE TYPE-SPEC) (WRAPARGS? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-LISTIFIED-VARIABLE-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-VARIABLE-ARGUMENTS"
        "CONS"
        "(DEFUN (WALK-VARIABLE-ARGUMENTS CONS) ((ARGUMENTS CONS) (METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-VARIABLE-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINISH-WALKING-CALL-SLOT-TREE"
        "METHOD-SLOT"
        "(DEFMETHOD (FINISH-WALKING-CALL-SLOT-TREE CONS TYPE-SPEC) ((SELF METHOD-SLOT) (TREE CONS) (FIRSTARGTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FINISH-WALKING-CALL-SLOT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "QUOTE-ARGUMENTS"
        "METHOD-SLOT"
        "(DEFUN (QUOTE-ARGUMENTS CONS) ((METHOD METHOD-SLOT) (ARGUMENTS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION QUOTE-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-FIRST-ARGUMENT-TO-FUNCTION"
        "METHOD-SLOT"
        "(DEFUN (WALK-FIRST-ARGUMENT-TO-FUNCTION TYPE-SPEC) ((FNSLOT METHOD-SLOT) (TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-FIRST-ARGUMENT-TO-FUNCTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-CALL-SLOT-TREE"
        "CONS"
        "(DEFUN (WALK-CALL-SLOT-TREE OBJECT TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-CALL-SLOT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-SYNTHESIZED-METHOD-BODY"
        "TRANSLATION-UNIT"
        "(DEFUN (YIELD-SYNTHESIZED-METHOD-BODY CONS) ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-SYNTHESIZED-METHOD-BODY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PASS-VARIABLE-ARGUMENTS-AS-LIST?"
        "METHOD-SLOT"
        "(DEFUN (PASS-VARIABLE-ARGUMENTS-AS-LIST? BOOLEAN) ((METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PASS-VARIABLE-ARGUMENTS-AS-LIST?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TOGGLE-VARIABLE-ARGUMENTS-TYPE"
        "METHOD-SLOT"
        "(DEFUN TOGGLE-VARIABLE-ARGUMENTS-TYPE ((METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TOGGLE-VARIABLE-ARGUMENTS-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VARIABLE-ARGUMENTS-TYPE"
        "METHOD-SLOT"
        "(DEFUN (VARIABLE-ARGUMENTS-TYPE TYPE-SPEC) ((METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VARIABLE-ARGUMENTS-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-METHOD-OBJECT"
        "TRANSLATION-UNIT"
        "(DEFUN (WALK-METHOD-OBJECT CONS) ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-METHOD-OBJECT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-DEFMETHOD-TREE"
        "CONS"
        "(DEFUN WALK-DEFMETHOD-TREE ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-DEFMETHOD-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-INITIALIZE-SLOT-WRITER"
        "METHOD-SLOT"
        "(DEFUN (YIELD-INITIALIZE-SLOT-WRITER CONS) ((METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-INITIALIZE-SLOT-WRITER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-METHOD-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN WALK-METHOD-UNIT ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-METHOD-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-SYS-CALL-TREE"
        "CONS"
        "(DEFUN (WALK-SYS-CALL-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-SYS-CALL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-DEFCLASS-TREE"
        "CONS"
        "(DEFUN WALK-DEFCLASS-TREE ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-DEFCLASS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-INITIALIZE-HARDWIRED-SLOTS"
        "CLASS"
        "(DEFUN (YIELD-INITIALIZE-HARDWIRED-SLOTS CONS) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-INITIALIZE-HARDWIRED-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-INITIAL-VALUE-EXPRESSION"
        "STORAGE-SLOT"
        "(DEFUN (YIELD-INITIAL-VALUE-EXPRESSION OBJECT) ((SLOT STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-INITIAL-VALUE-EXPRESSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-CONSTRUCTOR-ATTACHMENT"
        "CLASS"
        "(DEFUN (YIELD-CONSTRUCTOR-ATTACHMENT CONS) ((CLASS CLASS) (CLASSREF SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-CONSTRUCTOR-ATTACHMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR-SLOT-ACCESSOR-METHODS"
        "STORAGE-SLOT"
        "(DEFUN CLEAR-SLOT-ACCESSOR-METHODS ((SLOT STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLEAR-SLOT-ACCESSOR-METHODS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REGISTER-SLOT-ACCESSOR-METHOD"
        "STORAGE-SLOT"
        "(DEFUN REGISTER-SLOT-ACCESSOR-METHOD ((SLOT STORAGE-SLOT) (METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REGISTER-SLOT-ACCESSOR-METHOD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-ACCESSOR-UNITS-FOR-SLOT"
        "STORAGE-SLOT"
        "(DEFUN CREATE-ACCESSOR-UNITS-FOR-SLOT ((SLOT STORAGE-SLOT) (CLASS CLASS) (NATIVEACCESSORS? BOOLEAN) (SIGNATURESONLY? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-ACCESSOR-UNITS-FOR-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-ACCESSOR-UNITS-FOR-MIXIN-SLOT"
        "STORAGE-SLOT"
        "(DEFUN CREATE-ACCESSOR-UNITS-FOR-MIXIN-SLOT ((SLOT STORAGE-SLOT) (CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-ACCESSOR-UNITS-FOR-MIXIN-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-SLOT-ACCESSOR-UNITS"
        "CLASS"
        "(DEFUN CREATE-SLOT-ACCESSOR-UNITS ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-SLOT-ACCESSOR-UNITS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-INLINE-METHOD-UNITS"
        "CLASS"
        "(DEFUN CREATE-INLINE-METHOD-UNITS ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-INLINE-METHOD-UNITS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-DEFPRINT-UNIT"
        "CLASS"
        "(DEFUN CREATE-DEFPRINT-UNIT ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-DEFPRINT-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-CLASS-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN WALK-CLASS-UNIT ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-CLASS-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-FINALIZATION-UNITS"
        NULL
        "(DEFUN CREATE-FINALIZATION-UNITS ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-FINALIZATION-UNITS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-DEFSLOT-TREE"
        "CONS"
        "(DEFUN WALK-DEFSLOT-TREE ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-DEFSLOT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-SLOT-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN WALK-SLOT-UNIT ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-SLOT-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-MACRO"
        "SYMBOL"
        "(DEFUN (LOOKUP-MACRO METHOD-SLOT) ((NAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-MACRO)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STORE-MACRO"
        "SYMBOL"
        "(DEFUN STORE-MACRO ((NAME SYMBOL) (EXPANDERNAME SYMBOL) (EXPANDERCODE FUNCTION-CODE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STORE-MACRO)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-MACRO-EXPANDER-FUNCTION-NAME"
        "SYMBOL"
        "(DEFUN (YIELD-MACRO-EXPANDER-FUNCTION-NAME SYMBOL) ((MACRONAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-MACRO-EXPANDER-FUNCTION-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-DEFMACRO-TREE"
        "CONS"
        "(DEFUN WALK-DEFMACRO-TREE ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-DEFMACRO-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-MACRO-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN WALK-MACRO-UNIT ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-MACRO-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-DEFGLOBAL-TREE"
        "CONS"
        "(DEFUN WALK-DEFGLOBAL-TREE ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-DEFGLOBAL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-GLOBAL-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN WALK-GLOBAL-UNIT ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-GLOBAL-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-DEFTYPE-TREE"
        "CONS"
        "(DEFUN WALK-DEFTYPE-TREE ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-DEFTYPE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-TYPE-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN WALK-TYPE-UNIT ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-TYPE-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-STARTUP-TIME-PROGN-TREE"
        "CONS"
        "(DEFUN WALK-STARTUP-TIME-PROGN-TREE ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-STARTUP-TIME-PROGN-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXTRACT-STARTUP-TIME-PHASE"
        "CONS"
        "(DEFUN (EXTRACT-STARTUP-TIME-PHASE KEYWORD) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXTRACT-STARTUP-TIME-PHASE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-STARTUP-TIME-PROGN-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN WALK-STARTUP-TIME-PROGN-UNIT ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-STARTUP-TIME-PROGN-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMBINE-STARTUP-FUNCTION-UNITS"
        NULL
        "(DEFUN (COMBINE-STARTUP-FUNCTION-UNITS CONS) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMBINE-STARTUP-FUNCTION-UNITS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-STARTUP-FUNCTION-UNIT"
        "SYMBOL"
        "(DEFUN CREATE-STARTUP-FUNCTION-UNIT ((STARTUPFNNAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-STARTUP-FUNCTION-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DONT-GENERATE-STARTUP-CODE?"
        NULL
        "(DEFUN (DONT-GENERATE-STARTUP-CODE? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DONT-GENERATE-STARTUP-CODE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-ALL-STARTUP-TIME-PROGN-UNITS"
        NULL
        "(DEFUN REMOVE-ALL-STARTUP-TIME-PROGN-UNITS ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REMOVE-ALL-STARTUP-TIME-PROGN-UNITS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "USE-STELLA-EXCEPTIONS?"
        NULL
        "(DEFUN (USE-STELLA-EXCEPTIONS? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION USE-STELLA-EXCEPTIONS?)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "SETUP-LONG-JUMP?"
     "NATIVE-ENVIRONMENT-POINTER"
     "(DEFUN (SETUP-LONG-JUMP? BOOLEAN) ((ENVIRONMENT NATIVE-ENVIRONMENT-POINTER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "LONG-JUMP"
     "NATIVE-ENVIRONMENT-POINTER"
     "(DEFUN LONG-JUMP ((ENVIRONMENT NATIVE-ENVIRONMENT-POINTER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "CATCH"
     "NATIVE-ENVIRONMENT-POINTER"
     "(DEFUN (CL:CATCH BOOLEAN) ((TAG NATIVE-ENVIRONMENT-POINTER) (BODY VOID)) :NATIVE? TRUE)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIGNAL"
        "EXCEPTION"
        "(DEFUN SIGNAL ((EXCEPTION EXCEPTION)) :PUBLIC? TRUE :DOCUMENTATION \"Signal an 'exception'.  Signal an error if there is
no pending exception handler that can handle 'exception'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIGNAL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RESIGNAL"
        NULL
        "(DEFUN RESIGNAL () :PUBLIC? TRUE :DOCUMENTATION \"Resignal the most recently re/signalled exception.
Signal an error if there is no pending exception handler that can handle it.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RESIGNAL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-EXCEPTION-CASE-TREE"
        "CONS"
        "(DEFUN (WALK-EXCEPTION-CASE-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-EXCEPTION-CASE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LEXICALLY-VISIBLE-EXCEPTION-CASE?"
        NULL
        "(DEFUN (LEXICALLY-VISIBLE-EXCEPTION-CASE? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LEXICALLY-VISIBLE-EXCEPTION-CASE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-PROTECTED-STATEMENT-TREE"
        "OBJECT"
        "(DEFUN (YIELD-PROTECTED-STATEMENT-TREE CONS) ((TREE OBJECT) (UNWINDPROTECT? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-PROTECTED-STATEMENT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-EXCEPTION-HANDLER-TREE"
        "CONS"
        "(DEFUN (YIELD-EXCEPTION-HANDLER-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-EXCEPTION-HANDLER-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-VERBATIM-DEFINITION-TREE"
        "CONS"
        "(DEFUN WALK-VERBATIM-DEFINITION-TREE ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-VERBATIM-DEFINITION-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-VERBATIM-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN WALK-VERBATIM-UNIT ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-VERBATIM-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-VERBATIM-TREE"
        "CONS"
        "(DEFUN (WALK-VERBATIM-TREE OBJECT TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-VERBATIM-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-DEFMODULE-TREE"
        "CONS"
        "(DEFUN WALK-DEFMODULE-TREE ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-DEFMODULE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-MODULE-UNIT"
        "TRANSLATION-UNIT"
        "(DEFUN WALK-MODULE-UNIT ((UNIT TRANSLATION-UNIT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-MODULE-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXTRACT-REQUIRED-ARGUMENT-VALUES"
        "CLASS"
        "(DEFUN (EXTRACT-REQUIRED-ARGUMENT-VALUES CONS) ((CLASS CLASS) (SLOTNAMESANDVALUES PROPERTY-LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXTRACT-REQUIRED-ARGUMENT-VALUES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-NEW-ARGUMENTS-TREE"
        "CONS"
        "(DEFUN (YIELD-NEW-ARGUMENTS-TREE CONS CONS) ((KEYWORDSANDVALUES CONS) (CLASS CLASS) (SELFVARIABLE SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-NEW-ARGUMENTS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-NEW-TREE"
        "CONS"
        "(DEFUN (WALK-NEW-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-NEW-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-MAKE-TREE"
        "CONS"
        "(DEFUN (WALK-MAKE-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-MAKE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-FUNCALL-TREE"
        "CONS"
        "(DEFUN (WALK-FUNCALL-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-FUNCALL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-THE-CODE-TREE"
        "CONS"
        "(DEFUN (WALK-THE-CODE-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-THE-CODE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DE-UGLIFY-ARGUMENTS"
        "CONS"
        "(DEFUN (DE-UGLIFY-ARGUMENTS CONS) ((UGLYARGUMENTS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DE-UGLIFY-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DE-UGLIFY-PARSE-TREE"
        "OBJECT"
        "(DEFUN (DE-UGLIFY-PARSE-TREE OBJECT) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DE-UGLIFY-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REGISTER-NATIVE-NAME"
        "SYMBOL"
        "(DEFUN REGISTER-NATIVE-NAME ((NAME SYMBOL) (LANGUAGE KEYWORD) (CATEGORY KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REGISTER-NATIVE-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NATIVE-NAME?"
        "SYMBOL"
        "(DEFUN (NATIVE-NAME? BOOLEAN) ((NAME SYMBOL) (LANGUAGE KEYWORD) (CATEGORY KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NATIVE-NAME?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-RENAMED-NAME-IF-NATIVE"
        "SYMBOL"
        "(DEFUN (YIELD-RENAMED-NAME-IF-NATIVE SYMBOL) ((NAME SYMBOL) (LANGUAGE KEYWORD) (CATEGORY KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-RENAMED-NAME-IF-NATIVE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "METHOD-NEEDS-LISP-MACRO?"
        "METHOD-SLOT"
        "(DEFUN (METHOD-NEEDS-LISP-MACRO? BOOLEAN) ((METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION METHOD-NEEDS-LISP-MACRO?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-LISP-MACRO-TREES"
        "SYMBOL"
        "(DEFUN (YIELD-LISP-MACRO-TREES CONS CONS) ((NAME SYMBOL) (METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-LISP-MACRO-TREES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-LISP-MACRO-UNITS"
        "SYMBOL"
        "(DEFUN CREATE-LISP-MACRO-UNITS ((NAME SYMBOL) (METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-LISP-MACRO-UNITS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMMAND?"
        "METHOD-SLOT"
        "(DEFUN (COMMAND? BOOLEAN) ((METHOD METHOD-SLOT)) :DOCUMENTATION \"Return TRUE if 'method' is an evaluable command.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMMAND?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-COMMAND"
        "SYMBOL"
        "(DEFUN (LOOKUP-COMMAND METHOD-SLOT) ((NAME SYMBOL)) :DOCUMENTATION \"If 'name' names an evaluable command return its associated
command object;  otherwise, return NULL.  Currently, commands are not
polymorphic, i.e., they can only be implemented by functions.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-COMMAND)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "METHOD-MUST-BE-EVALUABLE?"
        "METHOD-SLOT"
        "(DEFUN (METHOD-MUST-BE-EVALUABLE? BOOLEAN) ((METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION METHOD-MUST-BE-EVALUABLE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "METHOD-NEEDS-EVALUATOR-WRAPPER?"
        "METHOD-SLOT"
        "(DEFUN (METHOD-NEEDS-EVALUATOR-WRAPPER? BOOLEAN) ((METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION METHOD-NEEDS-EVALUATOR-WRAPPER?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-EVALUATOR-WRAPPER-NAME"
        "SYMBOL"
        "(DEFUN (YIELD-EVALUATOR-WRAPPER-NAME SYMBOL) ((METHODNAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-EVALUATOR-WRAPPER-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-ARGUMENT-ACCESS-TREE"
        "SYMBOL"
        "(DEFUN (YIELD-ARGUMENT-ACCESS-TREE OBJECT) ((ARGUMENTSVARIABLE SYMBOL) (INDEX INTEGER) (RESTARGUMENT? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-ARGUMENT-ACCESS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-EVALUATOR-WRAPPER-TREE"
        "METHOD-SLOT"
        "(DEFUN (YIELD-EVALUATOR-WRAPPER-TREE CONS) ((METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-EVALUATOR-WRAPPER-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-EVALUATOR-WRAPPER-UNIT"
        "METHOD-SLOT"
        "(DEFUN CREATE-EVALUATOR-WRAPPER-UNIT ((METHOD METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-EVALUATOR-WRAPPER-UNIT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RESET-EVALUATION-ERROR"
        NULL
        "(DEFUN RESET-EVALUATION-ERROR () :DOCUMENTATION \"Reset the global evaluation error indicator.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RESET-EVALUATION-ERROR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIGNAL-EVALUATION-ERROR"
        NULL
        "(DEFUN SIGNAL-EVALUATION-ERROR () :DOCUMENTATION \"Signal an evaluation error.  This is done automatically
by calling 'eval-error'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIGNAL-EVALUATION-ERROR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATION-ERROR?"
        NULL
        "(DEFUN (EVALUATION-ERROR? BOOLEAN) () :DOCUMENTATION \"Return TRUE if the global evaluation error indicator is set.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATION-ERROR?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-EVALUATION-ERROR-CONTEXT"
        "STRING"
        "(DEFUN PRINT-EVALUATION-ERROR-CONTEXT ((PREFIX STRING) (STREAM OUTPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-EVALUATION-ERROR-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE"
        "OBJECT"
        "(DEFUN (EVALUATE OBJECT TYPE-SPEC BOOLEAN) ((EXPRESSION OBJECT)) :DOCUMENTATION \"Evaluate the expression `expression' and return the result.
Currently, only the evaluation of (possibly nested) commands and global
variables is supported.  The second return value indicates the actual type 
of the result (which might have been wrapped), and the third return value
indicates whether an error occurred during the evaluation.\" :LISP-MACRO? TRUE :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%EVALUATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-STRING"
        "STRING"
        "(DEFUN (EVALUATE-STRING OBJECT TYPE-SPEC BOOLEAN) ((EXPRESSION STRING)) :DOCUMENTATION \"Evaluate the expression represented by `expression' and return the result.
This is equivalent to `(evaluate (unstringify expression))'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-STRING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRY-TO-EVALUATE"
        "OBJECT"
        "(DEFUN (TRY-TO-EVALUATE OBJECT TYPE-SPEC BOOLEAN) ((TREE OBJECT)) :DOCUMENTATION \"Variant of 'evaluate' that only evaluates 'tree' if it
represents an evaluable expression.  If it does not, 'tree' is returned
unmodified.  This can be used to implement commands with mixed argument
evaluation strategies.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRY-TO-EVALUATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-CONS-TREE"
        "CONS"
        "(DEFUN (EVALUATE-CONS-TREE OBJECT TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-CONS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-ARGUMENT-TREE"
        "OBJECT"
        "(DEFUN (EVALUATE-ARGUMENT-TREE OBJECT TYPE-SPEC) ((TREE OBJECT) (EVALUATE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-ARGUMENT-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-ATOMIC-TREE"
        "OBJECT"
        "(DEFUN (EVALUATE-ATOMIC-TREE OBJECT TYPE-SPEC) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-ATOMIC-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COERCE-EVALUATED-TREE"
        "OBJECT"
        "(DEFUN (COERCE-EVALUATED-TREE OBJECT TYPE-SPEC) ((TREE OBJECT) (SOURCETREE OBJECT) (SOURCETYPE TYPE-SPEC) (TARGETTYPE TYPE-SPEC) (EVALUATE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COERCE-EVALUATED-TREE)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-WALK"
     NULL
     "(DEFUN STARTUP-WALK ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *AVAILABLE-ENVIRONMENT-FEATURES* (LIST OF KEYWORD) (CAST (LIST :WARN-ABOUT-UNDEFINED-METHODS :SUPPRESS-WARNINGS :USE-BOOTSTRAP-TRANSLATOR :WARN-ABOUT-MISSING-METHODS :USE-HARDCODED-SYMBOLS :USE-COMMON-LISP-STRUCTS :USE-COMMON-LISP-VECTOR-STRUCTS :USE-CPP-GARBAGE-COLLECTOR :TRANSLATE-WITH-COPYRIGHT-HEADER) (LIST OF KEYWORD)) :DOCUMENTATION \"List of Stella environment features.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CURRENT-ENVIRONMENT-FEATURES* (LIST OF KEYWORD) (NEW (LIST OF KEYWORD)) :DOCUMENTATION \"List of currently enabled environment features.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEFAULT-ENVIRONMENT-FEATURES* (LIST OF KEYWORD) (CAST (LIST :WARN-ABOUT-UNDEFINED-METHODS :WARN-ABOUT-MISSING-METHODS :USE-CPP-GARBAGE-COLLECTOR) (LIST OF KEYWORD)) :DOCUMENTATION \"List of features enabled upon call to
'reset-environment-features'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TRACED-KEYWORDS* (LIST OF KEYWORD) NULL)")
    (STORE-MACRO
     SYM-WALK-TRACE-IF
     SYM-WALK-TRACE-IF-EXPANDER
     (CL:FUNCTION TRACE-IF-EXPANDER))
    (REGISTER-NATIVE-NAME
     SYM-WALK-ADD-TRACE
     KWD-WALK-COMMON-LISP
     KWD-WALK-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-WALK-DROP-TRACE
     KWD-WALK-COMMON-LISP
     KWD-WALK-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *QUOTATION-TABLE* (STRING-HASH-TABLE OF STRING CONS) NULL :DOCUMENTATION \"Stores quoted cons trees.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TRANSLATIONUNITS* (LIST OF TRANSLATION-UNIT) NULL :DOCUMENTATION \"List of objects representing partially walked
top-level definitions and auxiliary code.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*TRANSLATIONUNITS*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*TRANSLATIONUNITS*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*TRANSLATIONUNITS*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CURRENTTRANSLATIONUNIT* TRANSLATION-UNIT NULL :DOCUMENTATION \"The translation unit currently operated on.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*CURRENTTRANSLATIONUNIT*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*CURRENTTRANSLATIONUNIT*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*CURRENTTRANSLATIONUNIT*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TRANSLATIONPHASE* KEYWORD NULL :DOCUMENTATION \"Indicates the current translation phase which is one of
:DEFINE, :FINALIZE, :WALK, or :TRANSLATE.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*TRANSLATIONPHASE*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*TRANSLATIONPHASE*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*TRANSLATIONPHASE*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TRANSLATIONVERBOSITYLEVEL* INTEGER 1 :DOCUMENTATION \"The higher the level, the more progress annotations are
generated during the translation of Stella declarations.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*TRANSLATIONVERBOSITYLEVEL*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*TRANSLATIONVERBOSITYLEVEL*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*TRANSLATIONVERBOSITYLEVEL*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *USEHARDCODEDSYMBOLS?* BOOLEAN FALSE)")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*USEHARDCODEDSYMBOLS?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*USEHARDCODEDSYMBOLS?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*USEHARDCODEDSYMBOLS?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *LOCALVARIABLETYPETABLE* (KEY-VALUE-LIST OF SYMBOL TYPE-SPEC) :UNBOUND-SPECIAL-VARIABLE :DOCUMENTATION \"Table mapping local variable names their declared types
(declared explicitly or implicitly).\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*LOCALVARIABLETYPETABLE*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*LOCALVARIABLETYPETABLE*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*LOCALVARIABLETYPETABLE*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *METHODBEINGWALKED* METHOD-SLOT NULL :DOCUMENTATION \"Contains the method or function being walked, or else NULL.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*METHODBEINGWALKED*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*METHODBEINGWALKED*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*METHODBEINGWALKED*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *FOUNDRETURN?* BOOLEAN FALSE :DOCUMENTATION \"Indicates that one or more return statements have been found
during the walk of the current method.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*FOUNDRETURN?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*FOUNDRETURN?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*FOUNDRETURN?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TARGETTYPE* TYPE-SPEC @VOID :DOCUMENTATION \"Bound to the target type for an expression currently walked.
Used instead of an extra argument to 'walk-a-tree', since only a few types
of expressions need to know about their expected type (e.g., FUNCALL).\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*TARGETTYPE*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*TARGETTYPE*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*TARGETTYPE*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *LOCALGENSYMTABLE* (KEY-VALUE-LIST OF SYMBOL INTEGER-WRAPPER) NULL :DOCUMENTATION \"Table that maps each prefix of a function-local gensym
to its own gensym counter.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*LOCALGENSYMTABLE*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*LOCALGENSYMTABLE*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*LOCALGENSYMTABLE*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TRANSLATIONERRORS* INTEGER 0)")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*TRANSLATIONERRORS*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*TRANSLATIONERRORS*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*TRANSLATIONERRORS*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TRANSLATIONWARNINGS* INTEGER 0)")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*TRANSLATIONWARNINGS*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*TRANSLATIONWARNINGS*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*TRANSLATIONWARNINGS*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *IGNORETRANSLATIONERRORS?* BOOLEAN TRUE :DOCUMENTATION \"If TRUE all passes of a translation will always be performed
regardless of whether any errors were encountered.  Otherwise, translation
ends with the first pass that encountered an error.\" :PUBLIC? TRUE)")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*IGNORETRANSLATIONERRORS?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*IGNORETRANSLATIONERRORS?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*IGNORETRANSLATIONERRORS?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *WRAPPED-TYPE-TABLE* (CONS OF CONS) (BQUOTE ((@INTEGER-WRAPPER @INTEGER) (@TRANSIENT-INTEGER-WRAPPER @INTEGER) (@FLOAT-WRAPPER @FLOAT) (@TRANSIENT-FLOAT-WRAPPER @FLOAT) (@NUMBER-WRAPPER @NUMBER) (@STRING-WRAPPER @STRING) (@TRANSIENT-STRING-WRAPPER @STRING) (@CHARACTER-WRAPPER @CHARACTER) (@TRANSIENT-CHARACTER-WRAPPER @CHARACTER) (@BOOLEAN-WRAPPER @BOOLEAN) (@FUNCTION-CODE-WRAPPER @FUNCTION-CODE) (@TRANSIENT-FUNCTION-CODE-WRAPPER @FUNCTION-CODE) (@METHOD-CODE-WRAPPER @METHOD-CODE) (@TRANSIENT-METHOD-CODE-WRAPPER @METHOD-CODE))) :DOCUMENTATION \"Table of pairs used by 'wrapper-value-type' and
'type-to-wrapped-type'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *COERSION-TABLE* (CONS OF CONS) (BQUOTE ((@BOOLEAN @BOOLEAN-WRAPPER WRAP-BOOLEAN) (@INTEGER @INTEGER-WRAPPER WRAP-LITERAL) (@INTEGER @BOOLEAN-WRAPPER INTEGER-TO-BOOLEAN-WRAPPER) (@INTEGER @BOOLEAN INTEGER-TO-BOOLEAN) (@FLOAT @FLOAT-WRAPPER WRAP-LITERAL) (@STRING @STRING-WRAPPER WRAP-LITERAL) (@STRING @SYMBOL INTERN-SYMBOL) (@CHARACTER @CHARACTER-WRAPPER WRAP-LITERAL) (@FUNCTION-CODE @FUNCTION-CODE-WRAPPER WRAP-LITERAL) (@METHOD-CODE @METHOD-CODE-WRAPPER WRAP-LITERAL) (@SYMBOL @STRING SYMBOL-NAME) (@BOOLEAN-WRAPPER @BOOLEAN WRAPPER-VALUE) (@INTEGER-WRAPPER @INTEGER WRAPPER-VALUE) (@FLOAT-WRAPPER @FLOAT WRAPPER-VALUE) (@STRING-WRAPPER @STRING WRAPPER-VALUE) (@CHARACTER-WRAPPER @CHARACTER WRAPPER-VALUE) (@FUNCTION-CODE-WRAPPER @FUNCTION-CODE WRAPPER-VALUE) (@METHOD-CODE-WRAPPER @METHOD-CODE WRAPPER-VALUE) (@SURROGATE @CLASS SURROGATE-VALUE) (@SURROGATE @MODULE SURROGATE-VALUE) (@INPUT-STREAM @NATIVE-INPUT-STREAM NATIVE-STREAM) (@OUTPUT-STREAM @NATIVE-OUTPUT-STREAM NATIVE-STREAM) (@NUMBER @INTEGER IDENTITY) (@NUMBER @FLOAT IDENTITY) (@INTEGER @FLOAT IDENTITY) (@INTEGER @SINGLE-FLOAT IDENTITY) (@FLOAT @SINGLE-FLOAT IDENTITY) (@FLOAT @DOUBLE-FLOAT IDENTITY) (@INTEGER @SHORT-INTEGER IDENTITY) (@INTEGER @LONG-INTEGER IDENTITY) (@INTEGER @UNSIGNED-SHORT-INTEGER IDENTITY) (@INTEGER @UNSIGNED-LONG-INTEGER IDENTITY))) :DOCUMENTATION \"Table of triples used by 'lookup-coersion-method' to
locate a coersion method.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SYMBOL-REGISTRY* (HASH-TABLE OF GENERALIZED-SYMBOL GENERALIZED-SYMBOL) (NEW (HASH-TABLE OF GENERALIZED-SYMBOL GENERALIZED-SYMBOL)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SYMBOL-SET* (LIST OF GENERALIZED-SYMBOL) (NEW (LIST OF GENERALIZED-SYMBOL)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CURRENTFILE* STRING NULL :DOCUMENTATION \"Name of file that is currently being translated.
A NULL value indicates an incremental translation.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*CURRENTFILE*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*CURRENTFILE*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*CURRENTFILE*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *SPECIALVARIABLESTACK* (KEY-VALUE-LIST OF SYMBOL SYMBOL) (NEW (KEY-VALUE-LIST OF SYMBOL SYMBOL)) :DOCUMENTATION \"Stack mirroring the current state of bound specials
with their associated old-value variables.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*SPECIALVARIABLESTACK*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*SPECIALVARIABLESTACK*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*SPECIALVARIABLESTACK*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *SPECIALSENABLED?* BOOLEAN TRUE :DOCUMENTATION \"TRUE if using specials is enabled and legal.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*SPECIALSENABLED?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*SPECIALSENABLED?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*SPECIALSENABLED?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *NOFSPECIALSATLOOPENTRY* INTEGER 0 :DOCUMENTATION \"Number of specials bound at the most recent entry
to a LOOP/WHILE/FOREACH construct.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*NOFSPECIALSATLOOPENTRY*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*NOFSPECIALSATLOOPENTRY*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*NOFSPECIALSATLOOPENTRY*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TYPE-PREDICATE-TABLE* (CONS OF CONS) (BQUOTE ((@BOOLEAN BOOLEAN?) (@INTEGER INTEGER?) (@FLOAT FLOAT?) (@STRING STRING?) (@CHARACTER CHARACTER?) (@WRAPPER WRAPPER?) (@BOOLEAN-WRAPPER BOOLEAN?) (@INTEGER-WRAPPER INTEGER?) (@FLOAT-WRAPPER FLOAT?) (@STRING-WRAPPER STRING?) (@CHARACTER-WRAPPER CHARACTER?) (@VERBATIM-STRING-WRAPPER VERBATIM-STRING?) (@SURROGATE SURROGATE?) (@TYPE TYPE?) (@SYMBOL SYMBOL?) (@TRANSIENT-SYMBOL TRANSIENT-SYMBOL?) (@KEYWORD KEYWORD?) (@CONS CONS?) (@CLASS CLASS?) (@STORAGE-SLOT STORAGE-SLOT?) (@METHOD-SLOT METHOD-SLOT?) (@ANCHORED-TYPE-SPECIFIER ANCHORED-TYPE-SPECIFIER?) (@PARAMETRIC-TYPE-SPECIFIER PARAMETRIC-TYPE-SPECIFIER?))) :DOCUMENTATION \"Table of specialized type predicates for various types.
These predicates have to be used instead of 'isa?', since they also work
during bootstrap when only some class objects are defined.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *NUMERIC-TYPE-HIERARCHY* (LIST OF TYPE) (LIST @INTEGER @FLOAT @NUMBER))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MACRO-TABLE* (HASH-TABLE OF SYMBOL CONS) (NEW (HASH-TABLE OF SYMBOL CONS)) :DOCUMENTATION \"Associates macro names with the name and code of
their expander function.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EXCEPTIONHANDLERADDRESS* NATIVE-ENVIRONMENT-POINTER (VERBATIM :COMMON-LISP \":exception-handler\" :CPP \"NULL\") :DOCUMENTATION \"Points to the address of the most recently established
Stella exception handler.  For Common-Lisp this variable never gets rebound.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PENDINGEXCEPTIONHANDLER?* BOOLEAN FALSE :DOCUMENTATION \"TRUE if at least one exception handler is pending.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*PENDINGEXCEPTIONHANDLER?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*PENDINGEXCEPTIONHANDLER?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*PENDINGEXCEPTIONHANDLER?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EXCEPTION* EXCEPTION NULL :DOCUMENTATION \"The most recently signalled exception.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EXCEPTION-TYPE* TYPE NULL :DOCUMENTATION \"The type of the most recently signalled exception.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *NATIVE-NAME-TABLE* (HASH-TABLE OF SYMBOL (KEY-VALUE-LIST OF KEYWORD LIST)) (NEW HASH-TABLE))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EVALUATIONERROR?* BOOLEAN FALSE)")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*EVALUATIONERROR?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*EVALUATIONERROR?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*EVALUATIONERROR?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EVALUATIONTREE* OBJECT NULL)")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*EVALUATIONTREE*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*EVALUATIONTREE*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*EVALUATIONTREE*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EVALUATIONPARENTTREE* OBJECT NULL)")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-WALK-*EVALUATIONPARENTTREE*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*EVALUATIONPARENTTREE*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*EVALUATIONPARENTTREE*)))
    (REGISTER-NATIVE-NAME
     SYM-WALK-EVALUATE
     KWD-WALK-COMMON-LISP
     KWD-WALK-FUNCTION)))
  :VOID)
