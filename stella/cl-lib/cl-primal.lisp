;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-CL-PRIMAL-INPUT-FILE-STREAM NULL)
(CL:DEFVAR SGT-CL-PRIMAL-OUTPUT-FILE-STREAM NULL)

;;; Forward declarations:

(CL:DECLAIM (CL:SPECIAL *STELLA-MODULE* *MODULE* *TRANSIENTOBJECTS?*))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFVAR NULL :NULL_VALUE)

;;; (DEFCONSTANT CL-NIL ...)

(CL:DEFVAR CL-NIL (CL:OR))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFMETHOD PRINT-OBJECT ((SELF (CL:EQL NULL)) STREAM)
  (CL:FORMAT STREAM "NULL"))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFMETHOD PRINT-OBJECT ((SELF (CL:EQL NULL-BOOLEAN)) STREAM)
  (CL:FORMAT STREAM "NULL-BOOLEAN"))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFMETHOD PRINT-OBJECT ((SELF (CL:EQL NULL-INTEGER)) STREAM)
  (CL:FORMAT STREAM "NULL-INTEGER"))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFMETHOD PRINT-OBJECT ((SELF (CL:EQL NULL-FLOAT)) STREAM)
  (CL:FORMAT STREAM "NULL-FLOAT"))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFUN FALSE-P (TEST)
  (CL:EQ TEST FALSE))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFUN TRUE-P (TEST)
  (CL:EQ TEST TRUE))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFUN CL-NIL? (TEST)
  (CL:IF TEST FALSE TRUE))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFUN NOT-CL-NIL? (TEST)
  (CL:IF TEST TRUE FALSE))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFMETHOD NULL? ((VALUE CL:T))
  (NOT-CL-NIL? (CL:EQ VALUE NULL)))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFMETHOD NULL? ((VALUE CL:INTEGER))
  (NOT-CL-NIL?
   (CL:OR
    (CL:NOT (CL:TYPEP VALUE (CL:QUOTE CL:FIXNUM)))
    (CL:EQ VALUE NULL-INTEGER)
    (CL:EQ VALUE NULL-BOOLEAN))))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFMETHOD NULL? ((VALUE CL:FLOAT))
  (NOT-CL-NIL? (CL:EQ VALUE NULL-FLOAT)))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFMETHOD NULL? ((VALUE CL:CHARACTER))
  (NOT-CL-NIL? (CL:EQ VALUE NULL-CHARACTER)))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFMETHOD DEFINED? ((VALUE CL:T))
  (CL-NIL? (CL:EQ VALUE NULL)))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFMETHOD DEFINED? ((VALUE CL:INTEGER))
  (CL-NIL?
   (CL:OR
    (CL:NOT (CL:TYPEP VALUE (CL:QUOTE CL:FIXNUM)))
    (CL:EQ VALUE NULL-INTEGER)
    (CL:EQ VALUE NULL-BOOLEAN))))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFMETHOD DEFINED? ((VALUE CL:FLOAT))
  (CL-NIL? (CL:EQ VALUE NULL-FLOAT)))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFMETHOD DEFINED? ((VALUE CL:CHARACTER))
  (CL-NIL? (CL:EQ VALUE NULL-CHARACTER)))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFUN EQ? (X Y)
  "Equality test equivalent to the C++ '==' and the Common Lisp 'EQL'."
  (CL:IF (CL:EQL X Y) TRUE FALSE))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFUN STRING-EQL? (X Y)
  (CL:IF (CL:EQUAL X Y) TRUE FALSE))

;;; (DEFUN (> BOOLEAN) ...)

(CL:DEFUN > (X Y)
  (CL:RETURN-FROM > (NOT-CL-NIL? (CL:> X Y)))
  :VOID)

;;; (DEFUN (>= BOOLEAN) ...)

(CL:DEFUN >= (X Y)
  (CL:RETURN-FROM >= (NOT-CL-NIL? (CL:>= X Y)))
  :VOID)

;;; (DEFUN (< BOOLEAN) ...)

(CL:DEFUN < (X Y)
  (CL:RETURN-FROM < (NOT-CL-NIL? (CL:< X Y)))
  :VOID)

;;; (DEFUN (<= BOOLEAN) ...)

(CL:DEFUN <= (X Y)
  (CL:RETURN-FROM <= (NOT-CL-NIL? (CL:<= X Y)))
  :VOID)

;;; (DEFUN (+ NUMBER) ...)

(CL:DEFUN + (X Y)
  (CL:RETURN-FROM + (CL:+ X Y))
  :VOID)

;;; (DEFUN (- NUMBER) ...)

(CL:DEFUN - (X Y)
  (CL:RETURN-FROM - (CL:- X Y))
  :VOID)

;;; (DEFUN (* NUMBER) ...)

(CL:DEFUN * (X Y)
  (CL:RETURN-FROM * (CL:* X Y))
  :VOID)

;;; (DEFUN (|/| NUMBER) ...)

(CL:DEFUN / (X Y)
  (CL:RETURN-FROM / (CL:/ X Y))
  :VOID)

;;; (DEFUN (ZERO? BOOLEAN) ...)

(CL:DEFUN ZERO? (X)
  (CL:RETURN-FROM ZERO? (NOT-CL-NIL? (CL:ZEROP X)))
  :VOID)

;;; (DEFUN (PLUS? BOOLEAN) ...)

(CL:DEFUN PLUS? (X)
  (CL:RETURN-FROM PLUS? (NOT-CL-NIL? (CL:PLUSP X)))
  :VOID)

;;; (DEFUN (EVEN? BOOLEAN) ...)

(CL:DEFUN EVEN? (X)
  (CL:RETURN-FROM EVEN? (NOT-CL-NIL? (CL:EVENP X)))
  :VOID)

;;; (DEFUN (ODD? BOOLEAN) ...)

(CL:DEFUN ODD? (X)
  (CL:RETURN-FROM ODD? (NOT-CL-NIL? (CL:ODDP X)))
  :VOID)

;;; (DEFUN (MOD INTEGER) ...)

(CL:DEFUN MOD (X MODULO)
  (CL:RETURN-FROM MOD (CL:MOD X MODULO))
  :VOID)

;;; (DEFUN (CEILING INTEGER) ...)

(CL:DEFUN CEILING (N)
  (CL:RETURN-FROM CEILING (CL:CEILING N))
  :VOID)

;;; (DEFUN (FLOOR INTEGER) ...)

(CL:DEFUN FLOOR (N)
  (CL:RETURN-FROM FLOOR (CL:FLOOR N))
  :VOID)

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFUN CHARACTER-CODE (CHAR)
  "Return the 8-bit ASCII code of 'char' as an integer."
  (CL:CHAR-CODE CHAR))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFUN CODE-CHARACTER (CODE)
  "Return the character encoded by 'code' (0 <= 'code' <= 255)."
  (CL:CODE-CHAR CODE))

;;; (DEFUN (MAKE-STRING STRING) ...)

(CL:DEFUN MAKE-STRING (SIZE INITIALELEMENT)
  "Return a string of 'size' characters.  If 'initialElement'
is defined, initialize all elements of the new string with it."
  (CL:IF
   (CL:EQ (DEFINED? INITIALELEMENT) 1)
   (CL:RETURN-FROM
    MAKE-STRING
    (CL:MAKE-STRING SIZE :INITIAL-ELEMENT INITIALELEMENT))
   (CL:RETURN-FROM MAKE-STRING (CL:MAKE-STRING SIZE)))
  :VOID)

;;; (DEFMETHOD (CONCATENATE STRING) ...)

(CL:DEFMETHOD CONCATENATE ((STRING1 CL:STRING) STRING2)
  "Return a string representing the concatenation of
'string1' and 'string2'."
  (CL:IF
   (CL:EQ *TRANSIENTOBJECTS?* 1)
   (CL:RETURN-FROM
    CONCATENATE
    (CL:CONCATENATE (CL:QUOTE CL:STRING) STRING1 STRING2))
   (CL:RETURN-FROM
    CONCATENATE
    (CL:CONCATENATE (CL:QUOTE CL:STRING) STRING1 STRING2)))
  :VOID)

;;; (DEFUN (PERMANENT-STRING-UPCASE STRING) ...)

(CL:DEFUN PERMANENT-STRING-UPCASE (STRING)
  "Return an upper-case copy of 'string' allocated
using the permanent string pool."
  (CL:RETURN-FROM PERMANENT-STRING-UPCASE (CL:STRING-UPCASE STRING))
  :VOID)

;;; (DEFUN (STRING-UPCASE STRING) ...)

(CL:DEFUN STRING-UPCASE (STRING)
  "Return an upper-case copy of 'string'."
  (CL:IF
   (CL:EQ *TRANSIENTOBJECTS?* 1)
   (CL:RETURN-FROM STRING-UPCASE (CL:STRING-UPCASE STRING))
   (CL:RETURN-FROM STRING-UPCASE (PERMANENT-STRING-UPCASE STRING)))
  :VOID)

;;; (DEFUN (STRING-DOWNCASE STRING) ...)

(CL:DEFUN STRING-DOWNCASE (STRING)
  "Return a lower-case copy of 'string'."
  (CL:RETURN-FROM STRING-DOWNCASE (CL:STRING-DOWNCASE STRING))
  :VOID)

;;; (DEFUN (STRING-CAPITALIZE STRING) ...)

(CL:DEFUN STRING-CAPITALIZE (STRING)
  "Return a capitalized version of 'string'."
  (CL:RETURN-FROM STRING-CAPITALIZE (CL:STRING-CAPITALIZE STRING))
  :VOID)

;;; (DEFMETHOD (COPY STRING) ...)

(CL:DEFMETHOD COPY ((STRING CL:STRING))
  "Return a copy of 'string'."
  (CL:IF
   (CL:EQ *TRANSIENTOBJECTS?* 1)
   (CL:RETURN-FROM COPY (CL:COPY-SEQ STRING))
   (CL:RETURN-FROM COPY (CL:COPY-SEQ STRING)))
  :VOID)

;;; (DEFMETHOD (SUBSTITUTE STRING) ...)

(CL:DEFMETHOD SUBSTITUTE ((SELF CL:STRING) NEWCHAR OLDCHAR)
  "Substitute all occurences of oldChar with newChar
in the string 'self'."
  (CL:RETURN-FROM SUBSTITUTE (CL:SUBSTITUTE NEWCHAR OLDCHAR SELF))
  :VOID)

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF CL:STRING) CHAR)
  (CL:RETURN-FROM MEMBER? (NOT-CL-NIL? (CL:FIND CHAR SELF)))
  :VOID)

;;; (DEFMETHOD (NTH CHARACTER) ...)

(CL:DEFMETHOD NTH ((SELF CL:STRING) POSITION)
  (CL:RETURN-FROM NTH (CL:CHAR SELF POSITION))
  :VOID)

;;; (DEFMETHOD (NTH-SETTER CHARACTER) ...)

(CL:DEFMETHOD NTH-SETTER ((SELF CL:STRING) CHAR POSITION)
  (CL:RETURN-FROM NTH-SETTER (SETF (CL:CHAR SELF POSITION) CHAR))
  :VOID)

;;; (DEFMETHOD (REST STRING) ...)

(CL:DEFMETHOD REST ((SELF CL:STRING))
  (CL:RETURN-FROM REST (CL:SUBSEQ SELF 1))
  :VOID)

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF CL:STRING))
  (CL:RETURN-FROM LENGTH (CL:LENGTH SELF))
  :VOID)

;;; (DEFMETHOD (POSITION INTEGER) ...)

(CL:DEFMETHOD POSITION ((STRING CL:STRING) CHARACTER START)
  "Return the position of 'character' within 'string' (counting
from zero); or return NULL if 'character' does not occur within 'string'.
If 'start' was supplied as non-NULL, only consider the substring starting
at 'start', however, the returned position will always be relative to the
entire string."
  (CL:LET*
   ((POSITION NULL-INTEGER))
   (CL:PROGN
    (SETQ POSITION (CL:POSITION CHARACTER STRING :START START))
    (CL:WHEN (CL:NULL POSITION) (SETQ POSITION NULL-INTEGER)))
   (CL:RETURN-FROM POSITION POSITION))
  :VOID)

;;; (DEFUN (STRING-SEARCH INTEGER) ...)

(CL:DEFUN STRING-SEARCH (STRING SUBSTRING START)
  "Return start position of the left-most occurrence right of
'start' of 'substring' in 'string'.  Return NULL if it is not a substring."
  (CL:LET*
   ((POSITION NULL-INTEGER))
   (CL:PROGN
    (SETQ POSITION (CL:SEARCH SUBSTRING STRING :START2 START))
    (CL:WHEN (CL:NULL POSITION) (SETQ POSITION NULL-INTEGER)))
   (CL:RETURN-FROM STRING-SEARCH POSITION))
  :VOID)

;;; (DEFMETHOD (SUBSEQUENCE STRING) ...)

(CL:DEFMETHOD SUBSEQUENCE ((STRING CL:STRING) START END)
  "Return a substring of 'string' beginning at position 'start'
and ending up to but not including position 'end', counting from zero.  An
'end' value of NULL stands for the rest of the string."
  (CL:WHEN (CL:EQL END NULL-INTEGER) (SETQ END CL-NIL))
  (CL:RETURN-FROM SUBSEQUENCE (CL:SUBSEQ STRING START END))
  :VOID)

;;; (DEFUN (STRINGIFY STRING) ...)

(CL:DEFUN STRINGIFY (EXPRESSION)
  (CL:LET*
   ((*PRINTPRETTY?* FALSE) (*PRINTREADABLY?* TRUE))
   (CL:DECLARE (CL:SPECIAL *PRINTPRETTY?* *PRINTREADABLY?*))
   (CL:RETURN-FROM STRINGIFY (CL:PRIN1-TO-STRING EXPRESSION)))
  :VOID)

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFVAR *STANDARD-READTABLE* (CL:COPY-READTABLE ()))

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFVAR *CASE-SENSITIVE-READTABLE* (CL:COPY-READTABLE ()))

;;; (VERBATIM :COMMON-LISP ...)

(CL:progn
    #+:ANSI-CL
    (CL:setf (CL:readtable-case *case-sensitive-readtable*) :preserve))

;;; (DEFUN (UNSTRINGIFY OBJECT) ...)

(CL:DEFUN UNSTRINGIFY (STRING)
  (CL:LET*
   ((*TRANSIENTOBJECTS?* TRUE))
   (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
   (CL:LET*
    ((CASESENSITIVE? (CLSYS-SVAL MODULE CASE-SENSITIVE? *MODULE*)))
    (CL:RETURN-FROM
     UNSTRINGIFY
     (STELLA-CODE-TO-CONS-TREE
      (CL:LET
       ((CL:*PACKAGE* (CL:FIND-PACKAGE "STELLA"))
        (*READTABLE*
         (CL:IF
          (TRUE-P CASESENSITIVE?)
          *CASE-SENSITIVE-READTABLE*
          *STANDARD-READTABLE*)))
       (CL:HANDLER-CASE
        (CL:READ-FROM-STRING STRING)
        (CL:STREAM-ERROR
         ()
         (CL:FORMAT CL:T ">> Unstringify: Parse error~%")
         (SIGNAL (NEW-READ-EXCEPTION)))
        (CL:ERROR
         (C)
         (CL:FORMAT CL:T "Unstringify: Caught unhandled exception ~A.~%" C)
         (SIGNAL (NEW-UNHANDLED-EXCEPTION)))))))))
  :VOID)

;;; (DEFUN (INTEGER-TO-STRING STRING) ...)

(CL:DEFUN INTEGER-TO-STRING (INTEGER)
  "Return a string representation of 'integer'."
  (CL:RETURN-FROM INTEGER-TO-STRING (CL:FORMAT CL-NIL "~A" INTEGER))
  :VOID)

;;; (DEFUN (FLOAT-TO-STRING STRING) ...)

(CL:DEFUN FLOAT-TO-STRING (FLOAT)
  "Return a string representation of 'float'."
  (CL:RETURN-FROM FLOAT-TO-STRING (CL:FORMAT CL-NIL "~A" FLOAT))
  :VOID)

;;; (DEFUN (STRING-TO-INTEGER INTEGER) ...)

(CL:DEFUN STRING-TO-INTEGER (STRING)
  "Convert the 'string' representation of an integer into an
integer and return the result."
  (CL:RETURN-FROM STRING-TO-INTEGER (CL:READ-FROM-STRING STRING))
  :VOID)

;;; (DEFUN (STRING-TO-FLOAT FLOAT) ...)

(CL:DEFUN STRING-TO-FLOAT (STRING)
  "Convert the 'string' representation of a float into a
float and return the result."
  (CL:RETURN-FROM STRING-TO-FLOAT (CL:READ-FROM-STRING STRING))
  :VOID)

;;; (DEFMETHOD FREE-HASH-TABLE-VALUES ...)

(CL:DEFMETHOD FREE-HASH-TABLE-VALUES ((SELF ABSTRACT-HASH-TABLE))
  "Call free on each value in the hash table 'self'."
  (CL:MAPHASH
   (CL:FUNCTION
    (CL:LAMBDA (KEY VALUE) (CL:DECLARE (CL:IGNORE KEY)) (FREE VALUE)))
   SELF)
  :VOID)

;;; (VERBATIM :COMMON-LISP ...)

(CL:defmacro get-hash-value (hashTable key)
     `(CL:gethash ,key ,hashTable))

;;; (DEFUN SET-HASH-VALUE ...)

(CL:DEFUN SET-HASH-VALUE (HASHTABLE KEY VALUE)
  (SETF (CL:GETHASH KEY HASHTABLE) VALUE)
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF ABSTRACT-HASH-TABLE))
  (CL:SETF
   (CLSYS-SVAL ABSTRACT-HASH-TABLE THE-HASH-TABLE SELF)
   (CL:MAKE-HASH-TABLE :TEST (CL:FUNCTION CL:EQL)))
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF HASH-TABLE) KEY)
  (CL:LET*
   ((VALUE (GET-HASH-VALUE (CLSYS-SVAL HASH-TABLE THE-HASH-TABLE SELF) KEY)))
   (CL:RETURN-FROM LOOKUP (CL:OR VALUE NULL)))
  :VOID)

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF HASH-TABLE) KEY VALUE)
  (SET-HASH-VALUE (CLSYS-SVAL HASH-TABLE THE-HASH-TABLE SELF) KEY VALUE)
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF HASH-TABLE) KEY)
  (SET-HASH-VALUE (CLSYS-SVAL HASH-TABLE THE-HASH-TABLE SELF) KEY NULL)
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF INTEGER-HASH-TABLE) KEY)
  (CL:LET*
   ((VALUE
     (GET-HASH-VALUE
      (CLSYS-SVAL INTEGER-HASH-TABLE THE-HASH-TABLE SELF)
      KEY)))
   (CL:RETURN-FROM LOOKUP (CL:OR VALUE NULL)))
  :VOID)

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF INTEGER-HASH-TABLE) KEY VALUE)
  (SET-HASH-VALUE (CLSYS-SVAL INTEGER-HASH-TABLE THE-HASH-TABLE SELF) KEY VALUE)
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF FLOAT-HASH-TABLE) KEY)
  (CL:LET*
   ((VALUE
     (GET-HASH-VALUE (CLSYS-SVAL FLOAT-HASH-TABLE THE-HASH-TABLE SELF) KEY)))
   (CL:RETURN-FROM LOOKUP (CL:OR VALUE NULL)))
  :VOID)

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF FLOAT-HASH-TABLE) KEY VALUE)
  (SET-HASH-VALUE (CLSYS-SVAL FLOAT-HASH-TABLE THE-HASH-TABLE SELF) KEY VALUE)
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-HASH-TABLE))
  (CL:SETF
   (CLSYS-SVAL STRING-HASH-TABLE THE-HASH-TABLE SELF)
   (CL:MAKE-HASH-TABLE :TEST (CL:FUNCTION CL:EQUAL)))
  :VOID)

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF STRING-HASH-TABLE) KEY)
  (CL:LET*
   ((VALUE
     (GET-HASH-VALUE (CLSYS-SVAL STRING-HASH-TABLE THE-HASH-TABLE SELF) KEY)))
   (CL:RETURN-FROM LOOKUP (CL:OR VALUE NULL)))
  :VOID)

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF STRING-HASH-TABLE) KEY VALUE)
  (SET-HASH-VALUE (CLSYS-SVAL STRING-HASH-TABLE THE-HASH-TABLE SELF) KEY VALUE)
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF STRING-HASH-TABLE) KEY)
  (CL:REMHASH KEY (CLSYS-SVAL STRING-HASH-TABLE THE-HASH-TABLE SELF))
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-TO-INTEGER-HASH-TABLE))
  (CL:SETF
   (CLSYS-SVAL STRING-TO-INTEGER-HASH-TABLE THE-HASH-TABLE SELF)
   (CL:MAKE-HASH-TABLE :TEST (CL:FUNCTION CL:EQUAL)))
  :VOID)

;;; (DEFMETHOD (LOOKUP INTEGER) ...)

(CL:DEFMETHOD LOOKUP ((SELF STRING-TO-INTEGER-HASH-TABLE) KEY)
  (CL:LET*
   ((VALUE
     (GET-HASH-VALUE
      (CLSYS-SVAL STRING-TO-INTEGER-HASH-TABLE THE-HASH-TABLE SELF)
      KEY)))
   (CL:RETURN-FROM
    LOOKUP
    (CL:IF (CL:EQ (NOT-CL-NIL? VALUE) 1) VALUE NULL-INTEGER)))
  :VOID)

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) KEY VALUE)
  (SET-HASH-VALUE
   (CLSYS-SVAL STRING-TO-INTEGER-HASH-TABLE THE-HASH-TABLE SELF)
   KEY
   VALUE)
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) KEY)
  (CL:REMHASH KEY (CLSYS-SVAL STRING-TO-INTEGER-HASH-TABLE THE-HASH-TABLE SELF))
  :VOID)

;;; (VERBATIM :COMMON-LISP ...)

(CL:DEFUN GET-ARRAY-VALUE (ARRAY OFFSET)
  (CL:AREF ARRAY OFFSET))

;;; (DEFUN SET-ARRAY-VALUE ...)

(CL:DEFUN SET-ARRAY-VALUE (ARRAY OFFSET VALUE)
  (SETF (CL:AREF ARRAY OFFSET) VALUE)
  :VOID)

;;; (DEFMETHOD INITIALIZE-VECTOR ...)

(CL:DEFMETHOD INITIALIZE-VECTOR ((SELF VECTOR))
  (CL:LET*
   ((INITIALSIZE (CLSYS-SVAL VECTOR ARRAY-SIZE SELF)))
   (CL:SETF
    (CLSYS-SVAL VECTOR THE-ARRAY SELF)
    (CL:MAKE-ARRAY INITIALSIZE :INITIAL-ELEMENT NULL)))
  :VOID)

;;; (DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIRST ((SELF VECTOR))
  (CL:RETURN-FROM FIRST (GET-ARRAY-VALUE (CLSYS-SVAL VECTOR THE-ARRAY SELF) 0))
  :VOID)

;;; (DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH ((SELF VECTOR) OFFSET)
  (CL:RETURN-FROM
   NTH
   (GET-ARRAY-VALUE (CLSYS-SVAL VECTOR THE-ARRAY SELF) OFFSET))
  :VOID)

;;; (DEFMETHOD (NTH-SETTER OBJECT) ...)

(CL:DEFMETHOD NTH-SETTER ((SELF VECTOR) VALUE POSITION)
  (INSERT-AT SELF POSITION VALUE)
  (CL:RETURN-FROM NTH-SETTER VALUE)
  :VOID)

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF VECTOR))
  (CL:RETURN-FROM LENGTH (CLSYS-SVAL VECTOR ARRAY-SIZE SELF))
  :VOID)

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF VECTOR) OBJECT)
  (CL:LET*
   ((ARRAY (CLSYS-SVAL VECTOR THE-ARRAY SELF)))
   (CL:LET*
    ((I NULL) (ITER-001 0) (UPPER-BOUND-001 (CL:1- (LENGTH SELF))))
    (CL:LOOP
     WHILE
     (CL:<= ITER-001 UPPER-BOUND-001)
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:WHEN
      (CL:EQ (GET-ARRAY-VALUE ARRAY I) OBJECT)
      (CL:RETURN-FROM MEMBER? TRUE))))
   (CL:RETURN-FROM MEMBER? FALSE))
  :VOID)

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF VECTOR) OFFSET VALUE)
  (CL:WHEN
   (CL:>= OFFSET (CLSYS-SVAL VECTOR ARRAY-SIZE SELF))
   (CL:ERROR "Out-of-bounds array access"))
  (SET-ARRAY-VALUE (CLSYS-SVAL VECTOR THE-ARRAY SELF) OFFSET VALUE)
  :VOID)

;;; (DEFUN RESIZE-VECTOR ...)

(CL:DEFUN RESIZE-VECTOR (SELF SIZE)
  (CL:LET*
   ((TOOSMALLARRAY (CLSYS-SVAL VECTOR THE-ARRAY SELF)) (BIGGERARRAY NULL))
   (CL:SETQ
    BIGGERARRAY
    (CL:MAKE-ARRAY SIZE :ADJUSTABLE CL:T :INITIAL-ELEMENT NULL))
   (CL:LET*
    ((I NULL)
     (ITER-001 0)
     (UPPER-BOUND-001 (CL:1- (CLSYS-SVAL VECTOR ARRAY-SIZE SELF))))
    (CL:LOOP
     WHILE
     (CL:<= ITER-001 UPPER-BOUND-001)
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (SET-ARRAY-VALUE BIGGERARRAY I (GET-ARRAY-VALUE TOOSMALLARRAY I))))
   (CL:SETF (CLSYS-SVAL VECTOR THE-ARRAY SELF) BIGGERARRAY)
   (CL:SETF (CLSYS-SVAL VECTOR ARRAY-SIZE SELF) SIZE))
  :VOID)

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF VECTOR))
  (CL:LET*
   ((I NULL)
    (ITER-001 0)
    (UPPER-BOUND-001 (CL:1- (CLSYS-SVAL VECTOR ARRAY-SIZE SELF))))
   (CL:LOOP
    WHILE
    (CL:<= ITER-001 UPPER-BOUND-001)
    DO
    (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
    (SET-ARRAY-VALUE (CLSYS-SVAL VECTOR THE-ARRAY SELF) I NULL)))
  :VOID)

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-VECTOR) OFFSET VALUE)
  (CL:WHEN
   (CL:>= OFFSET (CLSYS-SVAL EXTENSIBLE-VECTOR ARRAY-SIZE SELF))
   (CL:LET*
    ((SIZE (CLSYS-SVAL EXTENSIBLE-VECTOR ARRAY-SIZE SELF)))
    (CL:LOOP WHILE (CL:>= OFFSET SIZE) DO (CL:SETQ SIZE (CL:* 2 SIZE)))
    (RESIZE-VECTOR SELF SIZE)))
  (SET-ARRAY-VALUE (CLSYS-SVAL EXTENSIBLE-VECTOR THE-ARRAY SELF) OFFSET VALUE)
  :VOID)

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-SYMBOL-ARRAY) OFFSET VALUE)
  (CL:WHEN
   (CL:>= OFFSET (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY ARRAY-SIZE SELF))
   (CL:LET*
    ((SIZE (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY ARRAY-SIZE SELF)))
    (CL:LOOP WHILE (CL:>= OFFSET SIZE) DO (CL:SETQ SIZE (CL:* 2 SIZE)))
    (RESIZE-VECTOR SELF SIZE)))
  (SET-ARRAY-VALUE
   (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY THE-ARRAY SELF)
   OFFSET
   VALUE)
  (CL:WHEN
   (CL:> OFFSET (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY TOP-SYMBOL-OFFSET SELF))
   (CL:SETF (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY TOP-SYMBOL-OFFSET SELF) OFFSET))
  :VOID)

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF VECTOR-SEQUENCE) VALUE)
  "Append 'value' to the END of the sequence 'self'.  
Resize the array if necessary."
  (CL:LET*
   ((OLDLENGTH (CLSYS-SVAL VECTOR-SEQUENCE SEQUENCE-LENGTH SELF)))
   (CL:WHEN
    (CL:= OLDLENGTH (CLSYS-SVAL VECTOR-SEQUENCE ARRAY-SIZE SELF))
    (RESIZE-VECTOR
     SELF
     (CL:+
      (CLSYS-SVAL VECTOR-SEQUENCE ARRAY-SIZE SELF)
      (RESIZE-INCREMENT SELF))))
   (SET-ARRAY-VALUE
    (CLSYS-SVAL VECTOR-SEQUENCE THE-ARRAY SELF)
    OLDLENGTH
    VALUE)
   (CL:SETF
    (CLSYS-SVAL VECTOR-SEQUENCE SEQUENCE-LENGTH SELF)
    (CL:1+ OLDLENGTH)))
  :VOID)

;;; (DEFMETHOD (REMOVE VECTOR-SEQUENCE) ...)

(CL:DEFMETHOD REMOVE ((SELF VECTOR-SEQUENCE) VALUE)
  "Remove 'value' from the sequence 'self', and left shift
the values after it to close the gap."
  (CL:LET*
   ((ARRAY (CLSYS-SVAL VECTOR-SEQUENCE THE-ARRAY SELF))
    (FIRSTSHIFTOFFSET -1)
    (LASTSHIFTOFFSET
     (CL:1- (CLSYS-SVAL VECTOR-SEQUENCE SEQUENCE-LENGTH SELF))))
   (CL:LET*
    ((I NULL)
     (ITER-001 0)
     (UPPER-BOUND-001 LASTSHIFTOFFSET)
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
    (CL:LOOP
     WHILE
     (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:WHEN
      (CL:EQ (GET-ARRAY-VALUE ARRAY I) VALUE)
      (CL:SETQ FIRSTSHIFTOFFSET (CL:1+ I))
      (CL:RETURN))))
   (CL:WHEN (CL:= FIRSTSHIFTOFFSET -1) (CL:RETURN-FROM REMOVE SELF))
   (CL:WHEN
    (CL:<= FIRSTSHIFTOFFSET LASTSHIFTOFFSET)
    (CL:LET*
     ((J NULL)
      (ITER-002 FIRSTSHIFTOFFSET)
      (UPPER-BOUND-002 LASTSHIFTOFFSET)
      (UNBOUNDED?-002 (NULL? UPPER-BOUND-002)))
     (CL:LOOP
      WHILE
      (CL:OR (CL:EQ UNBOUNDED?-002 1) (CL:<= ITER-002 UPPER-BOUND-002))
      DO
      (CL:PROGN (CL:SETQ J ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
      (SET-ARRAY-VALUE ARRAY (CL:1- J) (GET-ARRAY-VALUE ARRAY J)))))
   (SET-ARRAY-VALUE ARRAY LASTSHIFTOFFSET NULL)
   (CL:SETF (CLSYS-SVAL VECTOR-SEQUENCE SEQUENCE-LENGTH SELF) LASTSHIFTOFFSET)
   (CL:RETURN-FROM REMOVE SELF))
  :VOID)

;;; (DEFMETHOD (ALLOCATE-ITERATOR LISP-CONS-ITERATOR) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF CL:CONS))
  "Return an iterator that iterates over a Common Lisp
cons list."
  (CL:LET*
   ((ITERATOR (NEW-LISP-CONS-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL LISP-CONS-ITERATOR CONS-ITERATOR-CURSOR ITERATOR)
    SELF)
   (CL:SETF (CLSYS-SVAL LISP-CONS-ITERATOR FIRST-ITERATION? ITERATOR) TRUE)
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR))
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF LISP-CONS-ITERATOR))
  (CL:IF
   (CL:EQ (CLSYS-SVAL LISP-CONS-ITERATOR FIRST-ITERATION? SELF) 1)
   (CL:SETF (CLSYS-SVAL LISP-CONS-ITERATOR FIRST-ITERATION? SELF) FALSE)
   (CL:SETF
    (CLSYS-SVAL LISP-CONS-ITERATOR CONS-ITERATOR-CURSOR SELF)
    (CL:CDR (CLSYS-SVAL LISP-CONS-ITERATOR CONS-ITERATOR-CURSOR SELF))))
  (CL:SETF
   (CLSYS-SVAL LISP-CONS-ITERATOR VALUE SELF)
   (CL:CAR (CLSYS-SVAL LISP-CONS-ITERATOR CONS-ITERATOR-CURSOR SELF)))
  (CL:RETURN-FROM
   NEXT?
   (CL:IF
    (CL:NOT
     (CL:EQ (CLSYS-SVAL LISP-CONS-ITERATOR CONS-ITERATOR-CURSOR SELF) CL-NIL))
    TRUE
    FALSE))
  :VOID)

;;; (DEFMETHOD (ALLOCATE-ITERATOR LISP-CONS-ITERATOR) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF CL:NULL))
  "Return an iterator that iterates over a Common Lisp
cons list.  Handles case of empty Common Lisp list."
  (CL:LET*
   ((ITERATOR (NEW-LISP-CONS-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL LISP-CONS-ITERATOR CONS-ITERATOR-CURSOR ITERATOR)
    SELF)
   (CL:SETF (CLSYS-SVAL LISP-CONS-ITERATOR FIRST-ITERATION? ITERATOR) TRUE)
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR))
  :VOID)

;;; (DEFUN UNMAKE ...)

(CL:DEFUN UNMAKE (SELF)
  (CL:SETQ SELF SELF)
  NULL
  :VOID)

;;; (DEFUN (STELLA-CODE-TO-CONS-TREE OBJECT) ...)

(CL:DEFUN STELLA-CODE-TO-CONS-TREE (STELLACODE)
  "Translate 'stellaCode' into a Stella parse tree
for which Lisp conses have been replaced by transient conses,
Lisp symbols have been replaced by transient symbols,
and literals have been replaced by wrapped literals."
  (CL:LET*
   ((*TRANSIENTOBJECTS?* TRUE))
   (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
   (CL:COND
    ((CL:EQ (CL-NIL? STELLACODE) 1)
     (CL:RETURN-FROM STELLA-CODE-TO-CONS-TREE NIL))
    ((CL:EQ (NOT-CL-NIL? (CL:CONSP STELLACODE)) 1)
     (CL:LET*
      ((CONSTREE NIL))
      (CL:LOOP
       FOR
       ELEMENT
       IN
       STELLACODE
       DO
       (SETQ CONSTREE (CONS (STELLA-CODE-TO-CONS-TREE ELEMENT) CONSTREE)))
      (CL:RETURN-FROM STELLA-CODE-TO-CONS-TREE (REVERSE CONSTREE))))
    ((CL:EQ (NOT-CL-NIL? (CL:SYMBOLP STELLACODE)) 1)
     (CL:LET*
      ((NAME (CL:SYMBOL-NAME STELLACODE)))
      (CL:WHEN
       (CL:EQ (NOT-CL-NIL? (CL:KEYWORDP STELLACODE)) 1)
       (CL:RETURN-FROM STELLA-CODE-TO-CONS-TREE (INTERN-KEYWORD NAME)))
      (CL:IF
       (CL:AND
        (CL:EQ
         (NOT-CL-NIL?
          (CL:EQL
           (CL:SYMBOL-PACKAGE STELLACODE)
           (CL:SYMBOL-PACKAGE (CL:QUOTE CL:EVAL))))
         1)
        (CL:NOT (CL:EQ (CL:FIND-SYMBOL NAME "STELLA") STELLACODE)))
       (CL:RETURN-FROM
        STELLA-CODE-TO-CONS-TREE
        (INTERN-COMMON-LISP-SYMBOL NAME))
       (CL:RETURN-FROM
        STELLA-CODE-TO-CONS-TREE
        (INTERN-GENERALIZED-SYMBOL NAME)))))
    ((CL:EQ (NOT-CL-NIL? (CL:INTEGERP STELLACODE)) 1)
     (CL:RETURN-FROM STELLA-CODE-TO-CONS-TREE (WRAP-LITERAL STELLACODE)))
    ((CL:EQ (NOT-CL-NIL? (CL:FLOATP STELLACODE)) 1)
     (CL:RETURN-FROM STELLA-CODE-TO-CONS-TREE (WRAP-LITERAL STELLACODE)))
    ((CL:EQ (NOT-CL-NIL? (CL:STRINGP STELLACODE)) 1)
     (CL:RETURN-FROM STELLA-CODE-TO-CONS-TREE (WRAP-LITERAL STELLACODE)))
    ((CL:EQ (NOT-CL-NIL? (CL:CHARACTERP STELLACODE)) 1)
     (CL:RETURN-FROM STELLA-CODE-TO-CONS-TREE (WRAP-LITERAL STELLACODE)))
    (CL:T (CL:RETURN-FROM STELLA-CODE-TO-CONS-TREE STELLACODE))))
  :VOID)

;;; (DEFUN (CONS-TREE-TO-LISP-CODE LISP-CODE) ...)

(CL:DEFUN CONS-TREE-TO-LISP-CODE (STELLATREE)
  (CL:WHEN
   (CL:EQ STELLATREE NULL)
   (CL:RETURN-FROM CONS-TREE-TO-LISP-CODE (CL:QUOTE NULL)))
  (CL:LET*
   ((STELLATREE-001 STELLATREE))
   (CL:COND
    ((CL:EQ (CONS? STELLATREE) 1)
     (CL:LET*
      ((STELLATREE NULL))
      (CL:SETQ STELLATREE STELLATREE-001)
      (CL:IF
       (CL:EQ STELLATREE NIL)
       (CL:RETURN-FROM CONS-TREE-TO-LISP-CODE CL-NIL)
       (CL:RETURN-FROM
        CONS-TREE-TO-LISP-CODE
        (CL:CONS
         (CONS-TREE-TO-LISP-CODE (CLSYS-SVAL CONS VALUE STELLATREE))
         (CONS-TREE-TO-LISP-CODE (CLSYS-SVAL CONS REST STELLATREE)))))))
    ((CL:EQ (KEYWORD? STELLATREE) 1)
     (CL:LET*
      ((STELLATREE NULL))
      (CL:SETQ STELLATREE STELLATREE-001)
      (CL:RETURN-FROM
       CONS-TREE-TO-LISP-CODE
       (CL:INTERN (CLSYS-SVAL KEYWORD SYMBOL-NAME STELLATREE) "KEYWORD"))))
    ((CL:EQ (SYMBOL? STELLATREE) 1)
     (CL:LET*
      ((STELLATREE NULL))
      (CL:SETQ STELLATREE STELLATREE-001)
      (CL:LET*
       ((NAME (CLSYS-SVAL SYMBOL SYMBOL-NAME STELLATREE)))
       (CL:WHEN
        (CL:EQ (CL:CHAR NAME 0) #\:)
        (CL:RETURN-FROM
         CONS-TREE-TO-LISP-CODE
         (CL:INTERN (CL:SUBSEQ NAME 1) "KEYWORD")))
       (CL:RETURN-FROM
        CONS-TREE-TO-LISP-CODE
        (CL:INTERN
         NAME
         (CL:IF
          (CL:EQ (SYMBOL-COMMON-LISP? STELLATREE) 1)
          "COMMON-LISP"
          "STELLA"))))))
    ((CL:EQ (SURROGATE? STELLATREE) 1)
     (CL:LET*
      ((STELLATREE NULL))
      (CL:SETQ STELLATREE STELLATREE-001)
      (CL:RETURN-FROM
       CONS-TREE-TO-LISP-CODE
       (CL:INTERN
        (CONCATENATE "@" (CLSYS-SVAL SURROGATE SYMBOL-NAME STELLATREE))
        "STELLA"))))
    ((CL:EQ (VERBATIM-STRING? STELLATREE) 1)
     (CL:LET*
      ((STELLATREE NULL))
      (CL:SETQ STELLATREE STELLATREE-001)
      (CL:LET*
       ((VERBATIMSTRING
         (CLSYS-SVAL VERBATIM-STRING-WRAPPER WRAPPER-VALUE STELLATREE))
        (PACKAGENAME (NATIVE-PACKAGE *MODULE*)))
       (CL:RETURN-FROM
        CONS-TREE-TO-LISP-CODE
        (CL:LET
         ((CL:*PACKAGE* (CL:FIND-PACKAGE PACKAGENAME)))
         (CL:READ-FROM-STRING VERBATIMSTRING))))))
    ((CL:EQ (INTEGER? STELLATREE) 1)
     (CL:LET*
      ((STELLATREE NULL))
      (CL:SETQ STELLATREE STELLATREE-001)
      (CL:RETURN-FROM
       CONS-TREE-TO-LISP-CODE
       (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE STELLATREE))))
    ((CL:EQ (FLOAT? STELLATREE) 1)
     (CL:LET*
      ((STELLATREE NULL))
      (CL:SETQ STELLATREE STELLATREE-001)
      (CL:RETURN-FROM
       CONS-TREE-TO-LISP-CODE
       (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE STELLATREE))))
    ((CL:EQ (STRING? STELLATREE) 1)
     (CL:LET*
      ((STELLATREE NULL))
      (CL:SETQ STELLATREE STELLATREE-001)
      (CL:RETURN-FROM
       CONS-TREE-TO-LISP-CODE
       (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE STELLATREE))))
    ((CL:EQ (CHARACTER? STELLATREE) 1)
     (CL:LET*
      ((STELLATREE NULL))
      (CL:SETQ STELLATREE STELLATREE-001)
      (CL:RETURN-FROM
       CONS-TREE-TO-LISP-CODE
       (CLSYS-SVAL CHARACTER-WRAPPER WRAPPER-VALUE STELLATREE))))
    ((CL:EQ (BOOLEAN? STELLATREE) 1)
     (CL:LET*
      ((STELLATREE NULL))
      (CL:SETQ STELLATREE STELLATREE-001)
      (CL:RETURN-FROM
       CONS-TREE-TO-LISP-CODE
       (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE STELLATREE))))
    (CL:T
     (CL:WARN
      "cons-tree-to-lisp-code: Don't know how to convert `~A' into LISP-CODE"
      STELLATREE)
     (CL:RETURN-FROM
      CONS-TREE-TO-LISP-CODE
      (CL:FORMAT CL-NIL "~s" STELLATREE)))))
  :VOID)

;;; (DEFUN (CONS-LIST-TO-LISP-LIST LISP-CODE) ...)

(CL:DEFUN CONS-LIST-TO-LISP-LIST (LIST)
  (CL:LET*
   ((LISPLIST CL-NIL))
   (CL:LET*
    ((ITEM NULL) (ITER-001 LIST))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ITEM (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:PUSH ITEM LISPLIST)))
   (CL:RETURN-FROM CONS-LIST-TO-LISP-LIST (CL:NREVERSE LISPLIST)))
  :VOID)

;;; (DEFUN (OPEN-NATIVE-STREAM? BOOLEAN) ...)

(CL:DEFUN OPEN-NATIVE-STREAM? (STREAM)
  (CL:LET*
   ((STREAM-001 STREAM))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? STREAM SGT-CL-PRIMAL-INPUT-FILE-STREAM) 1)
     (CL:LET*
      ((STREAM NULL))
      (CL:SETQ STREAM STREAM-001)
      (CL:LET*
       ((FILENAME (CLSYS-SVAL INPUT-FILE-STREAM FILENAME STREAM))
        (IFNOTEXISTSACTION
         (CL:INTERN
          (CLSYS-SVAL
           KEYWORD
           SYMBOL-NAME
           (CLSYS-SVAL INPUT-FILE-STREAM IF-NOT-EXISTS-ACTION STREAM))
          "KEYWORD")))
       (CL:SETF
        (CLSYS-SVAL INPUT-FILE-STREAM NATIVE-STREAM STREAM)
        (CL:OPEN
         FILENAME
         :DIRECTION
         :INPUT
         :IF-DOES-NOT-EXIST
         IFNOTEXISTSACTION))
       (CL:RETURN-FROM OPEN-NATIVE-STREAM? TRUE))))
    ((CL:EQ (TAXONOMY-ISA? STREAM SGT-CL-PRIMAL-OUTPUT-FILE-STREAM) 1)
     (CL:LET*
      ((STREAM NULL))
      (CL:SETQ STREAM STREAM-001)
      (CL:LET*
       ((FILENAME (CLSYS-SVAL OUTPUT-FILE-STREAM FILENAME STREAM))
        (IFEXISTSACTION
         (CL:INTERN
          (CLSYS-SVAL
           KEYWORD
           SYMBOL-NAME
           (CLSYS-SVAL OUTPUT-FILE-STREAM IF-EXISTS-ACTION STREAM))
          "KEYWORD")))
       (CL:SETF
        (CLSYS-SVAL OUTPUT-FILE-STREAM NATIVE-STREAM STREAM)
        (CL:OPEN FILENAME :DIRECTION :OUTPUT :IF-EXISTS IFEXISTSACTION))
       (CL:RETURN-FROM OPEN-NATIVE-STREAM? TRUE))))
    (CL:T (CL:RETURN-FROM OPEN-NATIVE-STREAM? FALSE))))
  :VOID)

;;; (DEFUN (CLOSE-NATIVE-STREAM? BOOLEAN) ...)

(CL:DEFUN CLOSE-NATIVE-STREAM? (STREAM)
  (CL:LET*
   ((STREAM-001 STREAM))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? STREAM SGT-CL-PRIMAL-INPUT-FILE-STREAM) 1)
     (CL:LET*
      ((STREAM NULL))
      (CL:SETQ STREAM STREAM-001)
      (CL:CLOSE (CLSYS-SVAL INPUT-FILE-STREAM NATIVE-STREAM STREAM))
      (CL:RETURN-FROM CLOSE-NATIVE-STREAM? TRUE)))
    ((CL:EQ (TAXONOMY-ISA? STREAM SGT-CL-PRIMAL-OUTPUT-FILE-STREAM) 1)
     (CL:LET*
      ((STREAM NULL))
      (CL:SETQ STREAM STREAM-001)
      (CL:CLOSE (CLSYS-SVAL OUTPUT-FILE-STREAM NATIVE-STREAM STREAM))
      (CL:RETURN-FROM CLOSE-NATIVE-STREAM? TRUE)))
    (CL:T (CL:RETURN-FROM CLOSE-NATIVE-STREAM? FALSE))))
  :VOID)

;;; (DEFUN (READ-S-EXPRESSION OBJECT BOOLEAN) ...)

(CL:DEFUN READ-S-EXPRESSION (STREAM)
  "Read one s-expression (parse-tree) from 'stream' using
the native Lisp or YACC/Bison reader.  On EOF the returned s-expression
will be NULL and the second return value will be TRUE."
  (CL:LET*
   ((EOFVALUE :EOF)
    (CASESENSITIVE? (CLSYS-SVAL MODULE CASE-SENSITIVE? *MODULE*))
    (INPUT
     (CL:LET
      ((CL:*PACKAGE* (CL:FIND-PACKAGE "STELLA"))
       (*READTABLE*
        (CL:IF
         (TRUE-P CASESENSITIVE?)
         *CASE-SENSITIVE-READTABLE*
         *STANDARD-READTABLE*)))
      (CL:READ STREAM CL-NIL EOFVALUE))))
   (CL:IF
    (CL:EQ INPUT EOFVALUE)
    (CL:RETURN-FROM READ-S-EXPRESSION (CL:VALUES NULL TRUE))
    (CL:RETURN-FROM
     READ-S-EXPRESSION
     (CL:VALUES (STELLA-CODE-TO-CONS-TREE INPUT) FALSE))))
  :VOID)

;;; (DEFUN (READ-LINE STRING BOOLEAN) ...)

(CL:DEFUN READ-LINE (STREAM)
  "Read one line from 'stream'.  On EOF the returned
string will be NULL and the second return value will be TRUE."
  (CL:LET*
   ((INPUT (CL:READ-LINE STREAM CL-NIL CL-NIL)))
   (CL:IF
    (CL:EQ (CL-NIL? INPUT) 1)
    (CL:RETURN-FROM READ-LINE (CL:VALUES NULL TRUE))
    (CL:RETURN-FROM READ-LINE (CL:VALUES INPUT FALSE))))
  :VOID)

;;; (DEFUN (READ-CHARACTER CHARACTER BOOLEAN) ...)

(CL:DEFUN READ-CHARACTER (STREAM)
  "Read one character from 'stream'.  On EOF the returned
character will be NULL and the second return value will be TRUE."
  (CL:LET*
   ((INPUT (CL:READ-CHAR STREAM CL-NIL CL-NIL)))
   (CL:IF
    (CL:EQ (CL-NIL? INPUT) 1)
    (CL:RETURN-FROM READ-CHARACTER (CL:VALUES NULL-CHARACTER TRUE))
    (CL:RETURN-FROM READ-CHARACTER (CL:VALUES INPUT FALSE))))
  :VOID)

;;; (DEFUN UNREAD-CHARACTER ...)

(CL:DEFUN UNREAD-CHARACTER (CHAR STREAM)
  "Unread 'char' from 'stream'.  'char' must be the same
character that was most recently read from 'stream'."
  (CL:UNREAD-CHAR CHAR STREAM)
  :VOID)

;;; (DEFUN (PROBE-FILE? BOOLEAN) ...)

(CL:DEFUN PROBE-FILE? (FILENAME)
  (CL:LET*
   ((RESULT (CL:PROBE-FILE FILENAME)))
   (CL:RETURN-FROM PROBE-FILE? (NOT-CL-NIL? RESULT)))
  :VOID)

;;; (DEFUN (FILE-WRITE-DATE INTEGER) ...)

(CL:DEFUN FILE-WRITE-DATE (FILENAME)
  (CL:LET*
   ((RESULT (CL:FILE-WRITE-DATE FILENAME)))
   (CL:IF
    (CL:EQ (NOT-CL-NIL? RESULT) 1)
    (CL:RETURN-FROM FILE-WRITE-DATE RESULT)
    (CL:RETURN-FROM FILE-WRITE-DATE NULL-INTEGER)))
  :VOID)

;;; (DEFUN (FILE-LENGTH INTEGER) ...)

(CL:DEFUN FILE-LENGTH (FILENAME)
  (CL:RETURN-FROM
   FILE-LENGTH
   (CL:WITH-OPEN-FILE
    (FSTREAM FILENAME :DIRECTION :INPUT)
    (CL:FILE-LENGTH FSTREAM)))
  :VOID)

;;; (DEFUN DELETE-FILE ...)

(CL:DEFUN DELETE-FILE (FILENAME)
  (CL:DELETE-FILE FILENAME)
  :VOID)

(CL:DEFUN STARTUP-CL-PRIMAL ()
  (CL:LET*
   ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SGT-CL-PRIMAL-INPUT-FILE-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-FILE-STREAM" NULL 1))
    (CL:SETQ
     SGT-CL-PRIMAL-OUTPUT-FILE-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-FILE-STREAM" NULL 1)))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        ">"
        "NUMBER"
        "(DEFUN (> BOOLEAN) ((X NUMBER) (Y NUMBER)))")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD) (CL:FUNCTION >)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        ">="
        "NUMBER"
        "(DEFUN (>= BOOLEAN) ((X NUMBER) (Y NUMBER)))")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD) (CL:FUNCTION >=)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "<"
        "NUMBER"
        "(DEFUN (< BOOLEAN) ((X NUMBER) (Y NUMBER)))")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD) (CL:FUNCTION <)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "<="
        "NUMBER"
        "(DEFUN (<= BOOLEAN) ((X NUMBER) (Y NUMBER)))")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD) (CL:FUNCTION <=)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "+"
        "NUMBER"
        "(DEFUN (+ NUMBER) ((X NUMBER) (Y NUMBER)))")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD) (CL:FUNCTION +)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "-"
        "NUMBER"
        "(DEFUN (- NUMBER) ((X NUMBER) (Y NUMBER)))")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD) (CL:FUNCTION -)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "*"
        "NUMBER"
        "(DEFUN (* NUMBER) ((X NUMBER) (Y NUMBER)))")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD) (CL:FUNCTION *)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "/"
        "NUMBER"
        "(DEFUN (|/| NUMBER) ((X NUMBER) (Y NUMBER)))")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD) (CL:FUNCTION /)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ZERO?"
        "INTEGER"
        "(DEFUN (ZERO? BOOLEAN) ((X INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ZERO?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PLUS?"
        "INTEGER"
        "(DEFUN (PLUS? BOOLEAN) ((X INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PLUS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVEN?"
        "INTEGER"
        "(DEFUN (EVEN? BOOLEAN) ((X INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVEN?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ODD?"
        "INTEGER"
        "(DEFUN (ODD? BOOLEAN) ((X INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ODD?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MOD"
        "INTEGER"
        "(DEFUN (MOD INTEGER) ((X INTEGER) (MODULO INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MOD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CEILING"
        "NUMBER"
        "(DEFUN (CEILING INTEGER) ((N NUMBER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CEILING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FLOOR"
        "NUMBER"
        "(DEFUN (FLOOR INTEGER) ((N NUMBER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FLOOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MAKE-STRING"
        "INTEGER"
        "(DEFUN (MAKE-STRING STRING) ((SIZE INTEGER) (INITIALELEMENT CHARACTER)) :DOCUMENTATION \"Return a string of 'size' characters.  If 'initialElement'
is defined, initialize all elements of the new string with it.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MAKE-STRING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONCATENATE"
        "STRING"
        "(DEFMETHOD (CONCATENATE STRING) ((STRING1 STRING) (STRING2 STRING)) :DOCUMENTATION \"Return a string representing the concatenation of
'string1' and 'string2'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CONCATENATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PERMANENT-STRING-UPCASE"
        "STRING"
        "(DEFUN (PERMANENT-STRING-UPCASE STRING) ((STRING STRING)) :DOCUMENTATION \"Return an upper-case copy of 'string' allocated
using the permanent string pool.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PERMANENT-STRING-UPCASE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING-UPCASE"
        "STRING"
        "(DEFUN (STRING-UPCASE STRING) ((STRING STRING)) :DOCUMENTATION \"Return an upper-case copy of 'string'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING-UPCASE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING-DOWNCASE"
        "STRING"
        "(DEFUN (STRING-DOWNCASE STRING) ((STRING STRING)) :DOCUMENTATION \"Return a lower-case copy of 'string'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING-DOWNCASE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING-CAPITALIZE"
        "STRING"
        "(DEFUN (STRING-CAPITALIZE STRING) ((STRING STRING)) :DOCUMENTATION \"Return a capitalized version of 'string'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING-CAPITALIZE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY"
        "STRING"
        "(DEFMETHOD (COPY STRING) ((STRING STRING)) :DOCUMENTATION \"Return a copy of 'string'.\")")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION COPY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBSTITUTE"
        "STRING"
        "(DEFMETHOD (SUBSTITUTE STRING) ((SELF STRING) (NEWCHAR CHARACTER) (OLDCHAR CHARACTER)) :DOCUMENTATION \"Substitute all occurences of oldChar with newChar
in the string 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SUBSTITUTE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MEMBER?"
        "STRING"
        "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF STRING) (CHAR CHARACTER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MEMBER?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NTH"
        "STRING"
        "(DEFMETHOD (NTH CHARACTER) ((SELF STRING) (POSITION INTEGER)))")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION NTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NTH-SETTER"
        "STRING"
        "(DEFMETHOD (NTH-SETTER CHARACTER) ((SELF STRING) (CHAR CHARACTER) (POSITION INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NTH-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REST"
        "STRING"
        "(DEFMETHOD (REST STRING) ((SELF STRING)))")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION REST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LENGTH"
        "STRING"
        "(DEFMETHOD (LENGTH INTEGER) ((SELF STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LENGTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POSITION"
        "STRING"
        "(DEFMETHOD (POSITION INTEGER) ((STRING STRING) (CHARACTER CHARACTER) (START INTEGER)) :DOCUMENTATION \"Return the position of 'character' within 'string' (counting
from zero); or return NULL if 'character' does not occur within 'string'.
If 'start' was supplied as non-NULL, only consider the substring starting
at 'start', however, the returned position will always be relative to the
entire string.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION POSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING-SEARCH"
        "STRING"
        "(DEFUN (STRING-SEARCH INTEGER) ((STRING STRING) (SUBSTRING STRING) (START INTEGER)) :DOCUMENTATION \"Return start position of the left-most occurrence right of
'start' of 'substring' in 'string'.  Return NULL if it is not a substring.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING-SEARCH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBSEQUENCE"
        "STRING"
        "(DEFMETHOD (SUBSEQUENCE STRING) ((STRING STRING) (START INTEGER) (END INTEGER)) :DOCUMENTATION \"Return a substring of 'string' beginning at position 'start'
and ending up to but not including position 'end', counting from zero.  An
'end' value of NULL stands for the rest of the string.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SUBSEQUENCE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRINGIFY"
        "OBJECT"
        "(DEFUN (STRINGIFY STRING) ((EXPRESSION OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRINGIFY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNSTRINGIFY"
        "STRING"
        "(DEFUN (UNSTRINGIFY OBJECT) ((STRING STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNSTRINGIFY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INTEGER-TO-STRING"
        "INTEGER"
        "(DEFUN (INTEGER-TO-STRING STRING) ((INTEGER INTEGER)) :DOCUMENTATION \"Return a string representation of 'integer'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INTEGER-TO-STRING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FLOAT-TO-STRING"
        "FLOAT"
        "(DEFUN (FLOAT-TO-STRING STRING) ((FLOAT FLOAT)) :DOCUMENTATION \"Return a string representation of 'float'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FLOAT-TO-STRING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING-TO-INTEGER"
        "STRING"
        "(DEFUN (STRING-TO-INTEGER INTEGER) ((STRING STRING)) :DOCUMENTATION \"Convert the 'string' representation of an integer into an
integer and return the result.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING-TO-INTEGER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING-TO-FLOAT"
        "STRING"
        "(DEFUN (STRING-TO-FLOAT FLOAT) ((STRING STRING)) :DOCUMENTATION \"Convert the 'string' representation of a float into a
float and return the result.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING-TO-FLOAT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-HASH-TABLE-VALUES"
        "ABSTRACT-HASH-TABLE"
        "(DEFMETHOD FREE-HASH-TABLE-VALUES ((SELF ABSTRACT-HASH-TABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FREE-HASH-TABLE-VALUES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SET-HASH-VALUE"
        "NATIVE-HASH-TABLE"
        "(DEFUN SET-HASH-VALUE ((HASHTABLE NATIVE-HASH-TABLE) (KEY UNKNOWN) (VALUE UNKNOWN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SET-HASH-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INITIALIZE-HASH-TABLE"
        "ABSTRACT-HASH-TABLE"
        "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF ABSTRACT-HASH-TABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INITIALIZE-HASH-TABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP"
        "HASH-TABLE"
        "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOOKUP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-AT"
        "HASH-TABLE"
        "(DEFMETHOD INSERT-AT ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-AT"
        "HASH-TABLE"
        "(DEFMETHOD REMOVE-AT ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REMOVE-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP"
        "INTEGER-HASH-TABLE"
        "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF INTEGER-HASH-TABLE) (KEY INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOOKUP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-AT"
        "INTEGER-HASH-TABLE"
        "(DEFMETHOD INSERT-AT ((SELF INTEGER-HASH-TABLE) (KEY INTEGER) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP"
        "FLOAT-HASH-TABLE"
        "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF FLOAT-HASH-TABLE) (KEY FLOAT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOOKUP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-AT"
        "FLOAT-HASH-TABLE"
        "(DEFMETHOD INSERT-AT ((SELF FLOAT-HASH-TABLE) (KEY FLOAT) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INITIALIZE-HASH-TABLE"
        "STRING-HASH-TABLE"
        "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-HASH-TABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INITIALIZE-HASH-TABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP"
        "STRING-HASH-TABLE"
        "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF STRING-HASH-TABLE) (KEY STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOOKUP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-AT"
        "STRING-HASH-TABLE"
        "(DEFMETHOD INSERT-AT ((SELF STRING-HASH-TABLE) (KEY STRING) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-AT"
        "STRING-HASH-TABLE"
        "(DEFMETHOD REMOVE-AT ((SELF STRING-HASH-TABLE) (KEY STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REMOVE-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INITIALIZE-HASH-TABLE"
        "STRING-TO-INTEGER-HASH-TABLE"
        "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-TO-INTEGER-HASH-TABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INITIALIZE-HASH-TABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP"
        "STRING-TO-INTEGER-HASH-TABLE"
        "(DEFMETHOD (LOOKUP INTEGER) ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOOKUP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-AT"
        "STRING-TO-INTEGER-HASH-TABLE"
        "(DEFMETHOD INSERT-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING) (VALUE INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-AT"
        "STRING-TO-INTEGER-HASH-TABLE"
        "(DEFMETHOD REMOVE-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REMOVE-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SET-ARRAY-VALUE"
        "UNKNOWN"
        "(DEFUN SET-ARRAY-VALUE ((ARRAY UNKNOWN) (OFFSET INTEGER) (VALUE UNKNOWN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SET-ARRAY-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INITIALIZE-VECTOR"
        "VECTOR"
        "(DEFMETHOD INITIALIZE-VECTOR ((SELF VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INITIALIZE-VECTOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIRST"
        "VECTOR"
        "(DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FIRST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NTH"
        "VECTOR"
        "(DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (OFFSET INTEGER)))")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION NTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NTH-SETTER"
        "VECTOR"
        "(DEFMETHOD (NTH-SETTER OBJECT) ((SELF VECTOR) (VALUE OBJECT) (POSITION INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NTH-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LENGTH"
        "VECTOR"
        "(DEFMETHOD (LENGTH INTEGER) ((SELF VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LENGTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MEMBER?"
        "VECTOR"
        "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF VECTOR) (OBJECT OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MEMBER?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-AT"
        "VECTOR"
        "(DEFMETHOD INSERT-AT ((SELF VECTOR) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RESIZE-VECTOR"
        "VECTOR"
        "(DEFUN RESIZE-VECTOR ((SELF VECTOR) (SIZE INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RESIZE-VECTOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR"
        "VECTOR"
        "(DEFMETHOD CLEAR ((SELF VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CLEAR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-AT"
        "EXTENSIBLE-VECTOR"
        "(DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-VECTOR) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-AT"
        "EXTENSIBLE-SYMBOL-ARRAY"
        "(DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-SYMBOL-ARRAY) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT"
        "VECTOR-SEQUENCE"
        "(DEFMETHOD INSERT ((SELF VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Append 'value' to the END of the sequence 'self'.  
Resize the array if necessary.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE"
        "VECTOR-SEQUENCE"
        "(DEFMETHOD (REMOVE VECTOR-SEQUENCE) ((SELF VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Remove 'value' from the sequence 'self', and left shift
the values after it to close the gap.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REMOVE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-ITERATOR"
        "LISP-CONS"
        "(DEFMETHOD (ALLOCATE-ITERATOR LISP-CONS-ITERATOR) ((SELF LISP-CONS)) :DOCUMENTATION \"Return an iterator that iterates over a Common Lisp
cons list.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ALLOCATE-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "LISP-CONS-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF LISP-CONS-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-ITERATOR"
        "LISP-NIL"
        "(DEFMETHOD (ALLOCATE-ITERATOR LISP-CONS-ITERATOR) ((SELF LISP-NIL)) :DOCUMENTATION \"Return an iterator that iterates over a Common Lisp
cons list.  Handles case of empty Common Lisp list.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ALLOCATE-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNMAKE"
        "UNKNOWN"
        "(DEFUN UNMAKE ((SELF UNKNOWN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNMAKE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STELLA-CODE-TO-CONS-TREE"
        "LISP-CODE"
        "(DEFUN (STELLA-CODE-TO-CONS-TREE OBJECT) ((STELLACODE LISP-CODE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STELLA-CODE-TO-CONS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONS-TREE-TO-LISP-CODE"
        "OBJECT"
        "(DEFUN (CONS-TREE-TO-LISP-CODE LISP-CODE) ((STELLATREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONS-TREE-TO-LISP-CODE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONS-LIST-TO-LISP-LIST"
        "CONS"
        "(DEFUN (CONS-LIST-TO-LISP-LIST LISP-CODE) ((LIST CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONS-LIST-TO-LISP-LIST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "OPEN-NATIVE-STREAM?"
        "STREAM"
        "(DEFUN (OPEN-NATIVE-STREAM? BOOLEAN) ((STREAM STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION OPEN-NATIVE-STREAM?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLOSE-NATIVE-STREAM?"
        "STREAM"
        "(DEFUN (CLOSE-NATIVE-STREAM? BOOLEAN) ((STREAM STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLOSE-NATIVE-STREAM?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-S-EXPRESSION"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (READ-S-EXPRESSION OBJECT BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)) :DOCUMENTATION \"Read one s-expression (parse-tree) from 'stream' using
the native Lisp or YACC/Bison reader.  On EOF the returned s-expression
will be NULL and the second return value will be TRUE.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-S-EXPRESSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-LINE"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (READ-LINE STRING BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)) :DOCUMENTATION \"Read one line from 'stream'.  On EOF the returned
string will be NULL and the second return value will be TRUE.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-LINE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-CHARACTER"
        "NATIVE-INPUT-STREAM"
        "(DEFUN (READ-CHARACTER CHARACTER BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)) :DOCUMENTATION \"Read one character from 'stream'.  On EOF the returned
character will be NULL and the second return value will be TRUE.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-CHARACTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNREAD-CHARACTER"
        "CHARACTER"
        "(DEFUN UNREAD-CHARACTER ((CHAR CHARACTER) (STREAM NATIVE-INPUT-STREAM)) :DOCUMENTATION \"Unread 'char' from 'stream'.  'char' must be the same
character that was most recently read from 'stream'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNREAD-CHARACTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PROBE-FILE?"
        "FILE-NAME"
        "(DEFUN (PROBE-FILE? BOOLEAN) ((FILENAME FILE-NAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PROBE-FILE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILE-WRITE-DATE"
        "FILE-NAME"
        "(DEFUN (FILE-WRITE-DATE INTEGER) ((FILENAME FILE-NAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILE-WRITE-DATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILE-LENGTH"
        "FILE-NAME"
        "(DEFUN (FILE-LENGTH INTEGER) ((FILENAME FILE-NAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILE-LENGTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DELETE-FILE"
        "FILE-NAME"
        "(DEFUN DELETE-FILE ((FILENAME FILE-NAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DELETE-FILE)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-CL-PRIMAL"
     NULL
     "(DEFUN STARTUP-CL-PRIMAL ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT CL-NIL LISP-CODE (VERBATIM :COMMON-LISP (CL:OR)))")))
  :VOID)
