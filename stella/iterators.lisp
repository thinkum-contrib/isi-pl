;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-ITERATORS-TABLE NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *STELLA-MODULE*
  *MODULE*
  *SURROGATE-ARRAY*
  *GLOBAL-VARIABLE-LOOKUP-TABLE*
  *FUNCTION-LOOKUP-TABLE*
  *SYMBOL-ARRAY*))

;;; (DEFMETHOD (ALLOCATE-ITERATOR (LIKE SELF)) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF ABSTRACT-ITERATOR))
  "Iterator objects return themselves when asked
for an iterator (they occupy the same position as a collection
within a 'foreach' statement)."
  (CL:RETURN-FROM ALLOCATE-ITERATOR SELF)
  :VOID)

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF ABSTRACT-ITERATOR))
  "Iterate over 'self', and count how many
items there are.  Bad idea if 'self' iterates over an infinite
collection, since in that case it will run forever.'"
  (CL:LET*
   ((COUNT 0))
   (CL:LET*
    ((I SELF))
    (CL:LOOP WHILE (CL:EQ (NEXT? I) 1) DO (CL:SETQ COUNT (CL:1+ COUNT))))
   (CL:RETURN-FROM LENGTH COUNT))
  :VOID)

;;; (DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD POP ((SELF ITERATOR))
  "Return the first item of the sequence represented by 'self',
or NULL if it is empty.  Destructively uses up the first iteration element."
  (CL:IF
   (CL:EQ (NEXT? SELF) 1)
   (CL:RETURN-FROM POP (CLSYS-SVAL ITERATOR VALUE SELF))
   (CL:RETURN-FROM POP NULL))
  :VOID)

;;; (DEFMETHOD (ADVANCE (LIKE SELF)) ...)

(CL:DEFMETHOD ADVANCE ((SELF ITERATOR) N)
  "Return 'self' after skipping over the first
'n' elements in the (remainder of the) iteration."
  (CL:LOOP
   WHILE
   (CL:AND (CL:> N 0) (CL:EQ (NEXT? SELF) 1))
   DO
   (CL:SETQ N (CL:1- N)))
  (CL:RETURN-FROM ADVANCE SELF)
  :VOID)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF ITERATOR))
  "Return TRUE if the sequence represented by 'self'
has no elements.  Side-effect free."
  (CL:ERROR "Missing 'empty?' method")
  (CL:RETURN-FROM EMPTY? FALSE)
  :VOID)

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF ITERATOR) VALUE)
  "Iterate over values of 'self', returning TRUE
if one of them is 'eql' to 'value."
  (CL:LET*
   ((M NULL) (ITER-001 SELF))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITER-001) 1)
    DO
    (CL:PROGN (CL:SETQ M (CLSYS-SVAL ITERATOR VALUE ITER-001)))
    (CL:WHEN (CL:EQ (EQL? M VALUE) 1) (CL:RETURN-FROM MEMBER? TRUE))))
  (CL:RETURN-FROM MEMBER? FALSE)
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF DESTRUCTIVE-LIST-ITERATOR))
  (CL:COND
   ((CL:EQ (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR FIRST-ITERATION? SELF) 1)
    (CL:SETF
     (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR FIRST-ITERATION? SELF)
     FALSE)
    (CL:SETF
     (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR LIST-ITERATOR-CURSOR SELF)
     (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR THE-CONS-LIST SELF)))
   (CL:T
    (CL:SETF
     (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR LIST-ITERATOR-CURSOR SELF)
     (CLSYS-SVAL
      CONS
      REST
      (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR LIST-ITERATOR-CURSOR SELF)))))
  (CL:SETF
   (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR VALUE SELF)
   (CLSYS-SVAL
    CONS
    VALUE
    (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR LIST-ITERATOR-CURSOR SELF)))
  (CL:RETURN-FROM
   NEXT?
   (NON-EMPTY?
    (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR LIST-ITERATOR-CURSOR SELF)))
  :VOID)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF DESTRUCTIVE-LIST-ITERATOR))
  (CL:RETURN-FROM
   EMPTY?
   (NIL? (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFUN (TERMINATE-DESTRUCTIVE-LIST-ITERATOR? BOOLEAN) ...)

(CL:DEFUN TERMINATE-DESTRUCTIVE-LIST-ITERATOR? (SELF)
  (FREE-CONS-LIST (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR THE-CONS-LIST SELF))
  (CL:SETF (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR THE-CONS-LIST SELF) NIL)
  (CL:RETURN-FROM TERMINATE-DESTRUCTIVE-LIST-ITERATOR? TRUE)
  :VOID)

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF DESTRUCTIVE-LIST-ITERATOR) VALUE)
  "Add 'value' to the front of the list 'self'."
  (CL:SETF
   (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR THE-CONS-LIST SELF)
   (CONS VALUE (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR THE-CONS-LIST SELF)))
  :VOID)

;;; (DEFMETHOD (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-DESTRUCTIVE-LIST-ITERATOR ((SELF CONS))
  (CL:LET*
   ((ITERATOR (NEW-DESTRUCTIVE-LIST-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR THE-CONS-LIST ITERATOR)
    SELF)
   (CL:SETF
    (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR LIST-ITERATOR-CURSOR ITERATOR)
    SELF)
   (CL:SETF
    (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR FIRST-ITERATION? ITERATOR)
    TRUE)
   (CL:RETURN-FROM ALLOCATE-DESTRUCTIVE-LIST-ITERATOR ITERATOR))
  :VOID)

;;; (DEFMETHOD (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-DESTRUCTIVE-LIST-ITERATOR ((SELF LIST))
  (CL:LET*
   ((ITERATOR
     (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR
      (CLSYS-SVAL LIST THE-CONS-LIST SELF))))
   (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST SELF) NIL)
   (FREE SELF)
   (CL:RETURN-FROM ALLOCATE-DESTRUCTIVE-LIST-ITERATOR ITERATOR))
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF ALL-PURPOSE-ITERATOR))
  "Apply the stored 'next?' function to 'self'."
  (CL:RETURN-FROM
   NEXT?
   (CL:FUNCALL (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE SELF) SELF))
  :VOID)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF ALL-PURPOSE-ITERATOR))
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-EMPTY-CODE SELF) NULL)
   (CL:ERROR "Missing 'empty?' method"))
  (CL:RETURN-FROM
   EMPTY?
   (CL:FUNCALL (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-EMPTY-CODE SELF)))
  :VOID)

;;; (DEFMETHOD (TERMINATE-ALL-PURPOSE-ITERATOR? BOOLEAN) ...)

(CL:DEFMETHOD TERMINATE-ALL-PURPOSE-ITERATOR? ((SELF ALL-PURPOSE-ITERATOR))
  (CL:WHEN
   (CL:NOT
    (CL:EQ (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF) NULL))
   (FREE-CONS-LIST (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF)
     NULL))
   (FREE (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF)))
  (CL:RETURN-FROM TERMINATE-ALL-PURPOSE-ITERATOR? TRUE)
  :VOID)

;;; (DEFUN (FILTERED-NESTED-ITERATOR-NEXT? BOOLEAN) ...)

(CL:DEFUN FILTERED-NESTED-ITERATOR-NEXT? (SELF)
  (CL:LET*
   ((NESTEDITERATOR
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))
    (VALUE NULL))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? NESTEDITERATOR) 1)
    DO
    (CL:SETQ VALUE (CLSYS-SVAL ITERATOR VALUE NESTEDITERATOR))
    (CL:WHEN
     (CL:EQ
      (CL:FUNCALL
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)
       VALUE
       SELF)
      1)
     (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) VALUE)
     (CL:RETURN-FROM FILTERED-NESTED-ITERATOR-NEXT? TRUE)))
   (CL:RETURN-FROM FILTERED-NESTED-ITERATOR-NEXT? FALSE))
  :VOID)

;;; (DEFUN (ITERATOR-CONS-LIST-NEXT? BOOLEAN) ...)

(CL:DEFUN ITERATOR-CONS-LIST-NEXT? (SELF)
  (CL:IF
   (CL:EQ (CLSYS-SVAL ALL-PURPOSE-ITERATOR FIRST-ITERATION? SELF) 1)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR FIRST-ITERATION? SELF) FALSE)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
    (CLSYS-SVAL
     CONS
     REST
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))))
  (CL:SETF
   (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF)
   (CLSYS-SVAL
    CONS
    VALUE
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
  (CL:RETURN-FROM
   ITERATOR-CONS-LIST-NEXT?
   (NON-EMPTY? (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
  :VOID)

;;; (DEFUN (ITERATOR-CONS-LIST-EMPTY? BOOLEAN) ...)

(CL:DEFUN ITERATOR-CONS-LIST-EMPTY? (SELF)
  (CL:RETURN-FROM
   ITERATOR-CONS-LIST-EMPTY?
   (EMPTY? (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
  :VOID)

;;; (DEFUN (FILTERED-CONCATENATED-ITERATOR-NEXT? BOOLEAN) ...)

(CL:DEFUN FILTERED-CONCATENATED-ITERATOR-NEXT? (SELF)
  (CL:LET*
   ((NESTEDITERATOR
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))
    (FILTERCODE (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF))
    (VALUE NULL))
   (CL:LOOP
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? NESTEDITERATOR) 1)
     DO
     (CL:SETQ VALUE (CLSYS-SVAL ITERATOR VALUE NESTEDITERATOR))
     (CL:WHEN
      (CL:EQ
       (CL:IF
        (CL:NOT (CL:EQ FILTERCODE NULL))
        (CL:FUNCALL FILTERCODE VALUE SELF)
        TRUE)
       1)
      (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) VALUE)
      (CL:RETURN-FROM FILTERED-CONCATENATED-ITERATOR-NEXT? TRUE)))
    (CL:SETQ
     NESTEDITERATOR
     (CLSYS-SVAL
      CONS
      VALUE
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
     (CLSYS-SVAL
      CONS
      REST
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
    (CL:IF
     (CL:EQ NESTEDITERATOR NULL)
     (CL:RETURN)
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF)
      NESTEDITERATOR)))
   (CL:RETURN-FROM FILTERED-CONCATENATED-ITERATOR-NEXT? FALSE))
  :VOID)

;;; (DEFMETHOD (CONCATENATE ALL-PURPOSE-ITERATOR) ...)

(CL:DEFMETHOD CONCATENATE ((ITERATOR1 ITERATOR) ITERATOR2)
  "Return an iterator that first generates all values of
`iterator1' and then those of `iterator2'.  The generated values can be
filtered by supplying a filter function to the resulting iterator."
  (CL:LET*
   ((SELF-001 (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF-001)
    ITERATOR1)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF-001)
    (CONS ITERATOR2 NIL))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE SELF-001)
    (CL:FUNCTION FILTERED-CONCATENATED-ITERATOR-NEXT?))
   (CL:LET* ((VALUE-001 SELF-001)) (CL:RETURN-FROM CONCATENATE VALUE-001)))
  :VOID)

;;; (DEFMETHOD INITIALIZE-INTEGER-INTERVAL-ITERATOR ...)

(CL:DEFMETHOD INITIALIZE-INTEGER-INTERVAL-ITERATOR ((SELF INTEGER-INTERVAL-ITERATOR))
  (CL:SETF
   (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF)
   (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR LOWER-BOUND SELF))
  (CL:SETF (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR FIRST-ITERATION? SELF) TRUE)
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF INTEGER-INTERVAL-ITERATOR))
  (CL:IF
   (CL:EQ (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR FIRST-ITERATION? SELF) 1)
   (CL:SETF
    (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR FIRST-ITERATION? SELF)
    FALSE)
   (CL:SETF
    (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF)
    (CL:1+ (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF))))
  (CL:LET*
   ((UPPERBOUND (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR UPPER-BOUND SELF)))
   (CL:SETF
    (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR VALUE SELF)
    (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF))
   (CL:RETURN-FROM
    NEXT?
    (CL:IF
     (CL:OR
      (CL:EQ (NULL? UPPERBOUND) 1)
      (CL:<=
       (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF)
       UPPERBOUND))
     TRUE
     FALSE)))
  :VOID)

;;; (DEFUN (INTERVAL INTEGER-INTERVAL-ITERATOR) ...)

(CL:DEFUN INTERVAL (LOWERBOUND UPPERBOUND)
  (CL:RETURN-FROM
   INTERVAL
   (NEW-INTEGER-INTERVAL-ITERATOR LOWERBOUND UPPERBOUND))
  :VOID)

;;; (DEFMETHOD (REVERSE REVERSE-INTEGER-INTERVAL-ITERATOR) ...)

(CL:DEFMETHOD REVERSE ((SELF INTEGER-INTERVAL-ITERATOR))
  (CL:RETURN-FROM
   REVERSE
   (REVERSE-INTERVAL
    (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR LOWER-BOUND SELF)
    (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR UPPER-BOUND SELF)))
  :VOID)

;;; (DEFUN INITIALIZE-REVERSE-INTEGER-INTERVAL-ITERATOR ...)

(CL:DEFUN INITIALIZE-REVERSE-INTEGER-INTERVAL-ITERATOR (SELF)
  (CL:SETF
   (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF)
   (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR UPPER-BOUND SELF))
  (CL:SETF
   (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR FIRST-ITERATION? SELF)
   TRUE)
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF REVERSE-INTEGER-INTERVAL-ITERATOR))
  (CL:IF
   (CL:EQ
    (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR FIRST-ITERATION? SELF)
    1)
   (CL:SETF
    (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR FIRST-ITERATION? SELF)
    FALSE)
   (CL:SETF
    (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF)
    (CL:1-
     (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF))))
  (CL:LET*
   ((LOWERBOUND
     (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR LOWER-BOUND SELF)))
   (CL:SETF
    (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR VALUE SELF)
    (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF))
   (CL:RETURN-FROM
    NEXT?
    (CL:IF
     (CL:OR
      (CL:EQ (NULL? LOWERBOUND) 1)
      (CL:>=
       (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF)
       LOWERBOUND))
     TRUE
     FALSE)))
  :VOID)

;;; (DEFUN (REVERSE-INTERVAL REVERSE-INTEGER-INTERVAL-ITERATOR) ...)

(CL:DEFUN REVERSE-INTERVAL (LOWERBOUND UPPERBOUND)
  "Create a reverse interval object."
  (CL:RETURN-FROM
   REVERSE-INTERVAL
   (NEW-REVERSE-INTEGER-INTERVAL-ITERATOR LOWERBOUND UPPERBOUND))
  :VOID)

;;; (DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF VECTOR))
  (CL:LET*
   ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT ITERATOR) SELF)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER ITERATOR) 0)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-INTEGER ITERATOR)
    (CLSYS-SVAL VECTOR ARRAY-SIZE SELF))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION VECTOR-NEXT?))
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR))
  :VOID)

;;; (DEFUN (VECTOR-NEXT? BOOLEAN) ...)

(CL:DEFUN VECTOR-NEXT? (SELF)
  (CL:LET*
   ((CURSOR (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF)))
   (CL:WHEN
    (CL:<
     CURSOR
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-INTEGER SELF))
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF)
     (CL:AREF
      (CLSYS-SVAL
       VECTOR
       THE-ARRAY
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF))
      CURSOR))
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF)
     (CL:1+ CURSOR))
    (CL:RETURN-FROM VECTOR-NEXT? TRUE))
   (CL:RETURN-FROM VECTOR-NEXT? FALSE))
  :VOID)

;;; (DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD BUT-LAST ((SELF VECTOR))
  "Generate all but the last element of the vector 'self'."
  (CL:LET*
   ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT ITERATOR) SELF)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER ITERATOR) 0)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-INTEGER ITERATOR)
    (CL:1- (CLSYS-SVAL VECTOR ARRAY-SIZE SELF)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION VECTOR-NEXT?))
   (CL:RETURN-FROM BUT-LAST ITERATOR))
  :VOID)

;;; (DEFMETHOD (ALLOCATE-ITERATOR STRING-ITERATOR) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF CL:STRING))
  (CL:LET*
   ((SELF-001 (NEW-STRING-ITERATOR)))
   (CL:SETF (CLSYS-SVAL STRING-ITERATOR THE-STRING SELF-001) SELF)
   (CL:LET*
    ((ITERATOR SELF-001))
    (CL:SETF (CLSYS-SVAL STRING-ITERATOR CURSOR ITERATOR) 0)
    (CL:SETF (CLSYS-SVAL STRING-ITERATOR END ITERATOR) (LENGTH SELF))
    (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR)))
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF STRING-ITERATOR))
  (CL:LET*
   ((POS (CLSYS-SVAL STRING-ITERATOR CURSOR SELF)))
   (CL:WHEN
    (CL:< POS (CLSYS-SVAL STRING-ITERATOR END SELF))
    (CL:SETF
     (CLSYS-SVAL STRING-ITERATOR VALUE SELF)
     (CL:CHAR (CLSYS-SVAL STRING-ITERATOR THE-STRING SELF) POS))
    (CL:SETF (CLSYS-SVAL STRING-ITERATOR CURSOR SELF) (CL:1+ POS))
    (CL:RETURN-FROM NEXT? TRUE))
   (CL:RETURN-FROM NEXT? FALSE))
  :VOID)

;;; (DEFUN (YIELD-MODULES-LIST (CONS OF MODULE)) ...)

(CL:DEFUN YIELD-MODULES-LIST (MODULE LOCAL?)
  (CL:LET*
   ((MODULESLIST NIL))
   (CL:WHEN
    (CL:NOT (CL:EQ MODULE NULL))
    (CL:IF
     (CL:EQ LOCAL? 1)
     (CL:SETQ MODULESLIST (CONS MODULE MODULESLIST))
     (CL:LET*
      ((MOD NULL) (ITER-001 (VISIBLE-MODULES MODULE)) (COLLECT-001 NULL))
      (CL:LOOP
       WHILE
       (CL:EQ (NEXT? ITER-001) 1)
       DO
       (CL:PROGN (CL:SETQ MOD (CLSYS-SVAL ITERATOR VALUE ITER-001)))
       (CL:IF
        (CL:EQ COLLECT-001 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-001 (CONS MOD NIL))
         (CL:IF
          (CL:EQ MODULESLIST NIL)
          (CL:SETQ MODULESLIST COLLECT-001)
          (ADD-CONS-TO-END-OF-CONS-LIST MODULESLIST COLLECT-001)))
        (CL:PROGN
         (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS MOD NIL))
         (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))))
   (CL:RETURN-FROM YIELD-MODULES-LIST MODULESLIST))
  :VOID)

;;; (DEFUN (ALLOCATE-ALL-META-OBJECTS-ITERATOR ITERATOR) ...)

(CL:DEFUN ALLOCATE-ALL-META-OBJECTS-ITERATOR (ARRAYSIZE NEXTCODE MODULE LOCAL?)
  (CL:LET*
   ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER ITERATOR) 0)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-INTEGER ITERATOR)
    ARRAYSIZE)
   (CL:LET*
    ((MODULESLIST NIL))
    (CL:WHEN
     (CL:NOT (CL:EQ MODULE NULL))
     (CL:IF
      (CL:EQ LOCAL? 1)
      (CL:SETQ MODULESLIST (CONS MODULE MODULESLIST))
      (CL:LET*
       ((MOD NULL) (ITER-001 (VISIBLE-MODULES MODULE)) (COLLECT-001 NULL))
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? ITER-001) 1)
        DO
        (CL:PROGN (CL:SETQ MOD (CLSYS-SVAL ITERATOR VALUE ITER-001)))
        (CL:IF
         (CL:EQ COLLECT-001 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-001 (CONS MOD NIL))
          (CL:IF
           (CL:EQ MODULESLIST NIL)
           (CL:SETQ MODULESLIST COLLECT-001)
           (ADD-CONS-TO-END-OF-CONS-LIST MODULESLIST COLLECT-001)))
         (CL:PROGN
          (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS MOD NIL))
          (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))))
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST ITERATOR)
     MODULESLIST))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE ITERATOR)
    NEXTCODE)
   (CL:RETURN-FROM ALLOCATE-ALL-META-OBJECTS-ITERATOR ITERATOR))
  :VOID)

;;; (DEFUN (ALL-SYMBOLS-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-SYMBOLS-NEXT? (SELF)
  (CL:LET*
   ((CURSOR (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF))
    (MODULES (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))
    (SYMBOL NULL))
   (CL:LOOP
    WHILE
    (CL:<
     CURSOR
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-INTEGER SELF))
    DO
    (CL:SETQ
     SYMBOL
     (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY *SYMBOL-ARRAY*) CURSOR))
    (CL:WHEN
     (CL:AND
      (CL:NOT (CL:EQ SYMBOL NULL))
      (CL:OR
       (CL:EQ MODULES NIL)
       (CL:EQ (MEMBER? MODULES (CLSYS-SVAL SYMBOL HOME-CONTEXT SYMBOL)) 1)))
     (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) SYMBOL)
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF)
      (CL:1+ CURSOR))
     (CL:RETURN-FROM ALL-SYMBOLS-NEXT? TRUE))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   (CL:RETURN-FROM ALL-SYMBOLS-NEXT? FALSE))
  :VOID)

;;; (DEFUN (ALL-SYMBOLS (ITERATOR OF SYMBOL)) ...)

(CL:DEFUN ALL-SYMBOLS (MODULE LOCAL?)
  "Iterate over all symbols visible from 'module'.
If 'local?', return only symbols interned in 'module'.
If 'module' is null, return all symbols interned everywhere."
  (CL:RETURN-FROM
   ALL-SYMBOLS
   (ALLOCATE-ALL-META-OBJECTS-ITERATOR
    (CL:1+
     (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY TOP-SYMBOL-OFFSET *SYMBOL-ARRAY*))
    (CL:FUNCTION ALL-SYMBOLS-NEXT?)
    MODULE
    LOCAL?))
  :VOID)

;;; (DEFUN (FILTER-PUBLIC-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-PUBLIC-SLOT? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM FILTER-PUBLIC-SLOT? (CLSYS-SVAL SLOT SLOT-PUBLIC? SELF))
  :VOID)

;;; (DEFUN (FILTER-PRIVATE-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-PRIVATE-SLOT? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM
   FILTER-PRIVATE-SLOT?
   (CL:IF (CL:EQ (CLSYS-SVAL SLOT SLOT-PUBLIC? SELF) 0) TRUE FALSE))
  :VOID)

;;; (DEFUN (FILTER-METHOD-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-METHOD-SLOT? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM FILTER-METHOD-SLOT? (METHOD-SLOT? SELF))
  :VOID)

;;; (DEFUN (FILTER-PUBLIC-METHOD-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-PUBLIC-METHOD-SLOT? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM
   FILTER-PUBLIC-METHOD-SLOT?
   (CL:IF
    (CL:AND
     (CL:EQ (CLSYS-SVAL SLOT SLOT-PUBLIC? SELF) 1)
     (CL:EQ (METHOD-SLOT? SELF) 1))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (FILTER-NON-EXTERNAL-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-NON-EXTERNAL-SLOT? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM
   FILTER-NON-EXTERNAL-SLOT?
   (CL:IF (CL:EQ (CLSYS-SVAL SLOT SLOT-EXTERNAL? SELF) 0) TRUE FALSE))
  :VOID)

;;; (DEFUN (FILTER-NON-PARAMETER-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-NON-PARAMETER-SLOT? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM
   FILTER-NON-PARAMETER-SLOT?
   (CL:IF
    (CL:EQ
     (MEMBER?
      (CLASS-PARAMETERS
       (CLSYS-SVAL
        SURROGATE
        SURROGATE-VALUE
        (CLSYS-SVAL SLOT SLOT-OWNER SELF)))
      (CLSYS-SVAL SLOT SLOT-NAME SELF))
     0)
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (FILTER-NON-AUXILIARY-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-NON-AUXILIARY-SLOT? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM
   FILTER-NON-AUXILIARY-SLOT?
   (CL:IF (CL:EQ (SLOT-AUXILIARY? SELF) 0) TRUE FALSE))
  :VOID)

;;; (DEFUN (FILTER-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-SLOT? (SELF ITERATOR)
  (CL:LET*
   ((ALWAYS?-001 TRUE))
   (CL:LET*
    ((FILTER NULL)
     (ITER-001 (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT ITERATOR)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ FILTER (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:EQ
       (CL:FUNCALL
        (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE FILTER)
        SELF
        ITERATOR)
       0)
      (CL:SETQ ALWAYS?-001 FALSE)
      (CL:RETURN))))
   (CL:LET* ((VALUE-001 ALWAYS?-001)) (CL:RETURN-FROM FILTER-SLOT? VALUE-001)))
  :VOID)

;;; (DEFUN (ALL-FUNCTIONS-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-FUNCTIONS-NEXT? (SELF)
  (CL:LET*
   ((CURSOR (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF))
    (MODULES (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))
    (SYMBOL NULL)
    (FUNCTION NULL))
   (CL:LOOP
    WHILE
    (CL:<
     CURSOR
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-INTEGER SELF))
    DO
    (CL:SETQ
     SYMBOL
     (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY *SYMBOL-ARRAY*) CURSOR))
    (CL:WHEN
     (CL:AND
      (CL:NOT (CL:EQ SYMBOL NULL))
      (CL:OR
       (CL:EQ MODULES NIL)
       (CL:EQ (MEMBER? MODULES (CLSYS-SVAL SYMBOL HOME-CONTEXT SYMBOL)) 1)))
     (CL:SETQ FUNCTION (LOOKUP *FUNCTION-LOOKUP-TABLE* SYMBOL))
     (CL:WHEN
      (CL:AND
       (CL:NOT (CL:EQ FUNCTION NULL))
       (CL:OR
        (CL:EQ
         (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)
         NULL)
        (CL:EQ
         (CL:FUNCALL
          (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)
          FUNCTION
          SELF)
         1)))
      (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) FUNCTION)
      (CL:SETF
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF)
       (CL:1+ CURSOR))
      (CL:RETURN-FROM ALL-FUNCTIONS-NEXT? TRUE)))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   (CL:RETURN-FROM ALL-FUNCTIONS-NEXT? FALSE))
  :VOID)

;;; (DEFUN (ALL-FUNCTIONS (ITERATOR OF FUNCTION)) ...)

(CL:DEFUN ALL-FUNCTIONS (MODULE LOCAL?)
  "Iterate over all functions visible from 'module'.
If 'local?', return only functions bound to symbols interned in 'module'.
If 'module' is null, return all functions defined everywhere."
  (CL:RETURN-FROM
   ALL-FUNCTIONS
   (ALLOCATE-ALL-META-OBJECTS-ITERATOR
    (CL:1+
     (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY TOP-SYMBOL-OFFSET *SYMBOL-ARRAY*))
    (CL:FUNCTION ALL-FUNCTIONS-NEXT?)
    MODULE
    LOCAL?))
  :VOID)

;;; (DEFUN (ALL-PUBLIC-FUNCTIONS (ITERATOR OF FUNCTION)) ...)

(CL:DEFUN ALL-PUBLIC-FUNCTIONS (MODULE LOCAL?)
  "Iterate over all functions visible from 'module'.
If 'local?', return only functions bound to symbols interned in 'module'.
If 'module' is null, return all functions defined everywhere."
  (CL:LET*
   ((ITERATOR (ALL-FUNCTIONS MODULE LOCAL?)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-PUBLIC-SLOT?))
   (CL:RETURN-FROM ALL-PUBLIC-FUNCTIONS ITERATOR))
  :VOID)

;;; (DEFUN (ALL-VARIABLES-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-VARIABLES-NEXT? (SELF)
  (CL:LET*
   ((CURSOR (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF))
    (MODULES (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))
    (SYMBOL NULL)
    (VARIABLE NULL))
   (CL:LOOP
    WHILE
    (CL:<
     CURSOR
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-INTEGER SELF))
    DO
    (CL:SETQ
     SYMBOL
     (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY *SYMBOL-ARRAY*) CURSOR))
    (CL:WHEN
     (CL:AND
      (CL:NOT (CL:EQ SYMBOL NULL))
      (CL:OR
       (CL:EQ MODULES NIL)
       (CL:EQ (MEMBER? MODULES (CLSYS-SVAL SYMBOL HOME-CONTEXT SYMBOL)) 1)))
     (CL:SETQ VARIABLE (LOOKUP *GLOBAL-VARIABLE-LOOKUP-TABLE* SYMBOL))
     (CL:WHEN
      (CL:AND
       (CL:NOT (CL:EQ VARIABLE NULL))
       (CL:OR
        (CL:EQ
         (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)
         NULL)
        (CL:EQ
         (CL:FUNCALL
          (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)
          VARIABLE
          SELF)
         1)))
      (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) VARIABLE)
      (CL:SETF
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF)
       (CL:1+ CURSOR))
      (CL:RETURN-FROM ALL-VARIABLES-NEXT? TRUE)))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   (CL:RETURN-FROM ALL-VARIABLES-NEXT? FALSE))
  :VOID)

;;; (DEFUN (ALL-VARIABLES (ITERATOR OF GLOBAL-VARIABLE)) ...)

(CL:DEFUN ALL-VARIABLES (MODULE LOCAL?)
  "Iterate over all variables visible from 'module'.
If 'local?', return only variables bound to symbols interned in 'module'.
If 'module' is null, return all variables defined everywhere."
  (CL:RETURN-FROM
   ALL-VARIABLES
   (ALLOCATE-ALL-META-OBJECTS-ITERATOR
    (CL:1+
     (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY TOP-SYMBOL-OFFSET *SYMBOL-ARRAY*))
    (CL:FUNCTION ALL-VARIABLES-NEXT?)
    MODULE
    LOCAL?))
  :VOID)

;;; (DEFUN (ALL-SURROGATES-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-SURROGATES-NEXT? (SELF)
  (CL:LET*
   ((CURSOR (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF))
    (MODULES (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))
    (SURROGATE NULL))
   (CL:LOOP
    WHILE
    (CL:<
     CURSOR
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-INTEGER SELF))
    DO
    (CL:SETQ
     SURROGATE
     (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY *SURROGATE-ARRAY*) CURSOR))
    (CL:WHEN
     (CL:AND
      (CL:NOT (CL:EQ SURROGATE NULL))
      (CL:OR
       (CL:EQ MODULES NIL)
       (CL:EQ
        (MEMBER? MODULES (CLSYS-SVAL SURROGATE HOME-CONTEXT SURROGATE))
        1)))
     (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) SURROGATE)
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF)
      (CL:1+ CURSOR))
     (CL:RETURN-FROM ALL-SURROGATES-NEXT? TRUE))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   (CL:RETURN-FROM ALL-SURROGATES-NEXT? FALSE))
  :VOID)

;;; (DEFUN (ALL-SURROGATES (ITERATOR OF SURROGATE)) ...)

(CL:DEFUN ALL-SURROGATES (MODULE LOCAL?)
  "Iterate over all surrogates visible from 'module'.
If 'local?', return only surrogates interned in 'module'.
If 'module' is null, return all surrogates interned everywhere."
  (CL:RETURN-FROM
   ALL-SURROGATES
   (ALLOCATE-ALL-META-OBJECTS-ITERATOR
    (CL:1+
     (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY TOP-SYMBOL-OFFSET *SURROGATE-ARRAY*))
    (CL:FUNCTION ALL-SURROGATES-NEXT?)
    MODULE
    LOCAL?))
  :VOID)

;;; (DEFUN (ALL-CLASSES-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-CLASSES-NEXT? (SELF)
  (CL:LET*
   ((CURSOR (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF))
    (MODULES (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))
    (SURROGATE NULL)
    (VALUE NULL))
   (CL:LOOP
    WHILE
    (CL:<
     CURSOR
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-INTEGER SELF))
    DO
    (CL:SETQ
     SURROGATE
     (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY *SURROGATE-ARRAY*) CURSOR))
    (CL:WHEN
     (CL:AND
      (CL:NOT (CL:EQ SURROGATE NULL))
      (CL:OR
       (CL:EQ MODULES NIL)
       (CL:EQ
        (MEMBER? MODULES (CLSYS-SVAL SURROGATE HOME-CONTEXT SURROGATE))
        1)))
     (CL:SETQ VALUE (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE))
     (CL:WHEN
      (CL:AND
       (CL:NOT (CL:EQ VALUE NULL))
       (CL:EQ (CLASS? VALUE) 1)
       (CL:EQ (CLSYS-SVAL CLASS CLASS-TYPE VALUE) SURROGATE))
      (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) VALUE)
      (CL:SETF
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF)
       (CL:1+ CURSOR))
      (CL:RETURN-FROM ALL-CLASSES-NEXT? TRUE)))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   (CL:RETURN-FROM ALL-CLASSES-NEXT? FALSE))
  :VOID)

;;; (DEFUN (ALL-CLASSES (ITERATOR OF CLASS)) ...)

(CL:DEFUN ALL-CLASSES (MODULE LOCAL?)
  "Iterate over all classes visible from 'module'.
If 'local?', return only classes interned in 'module'.
If 'module' is null, return all classes interned everywhere."
  (CL:RETURN-FROM
   ALL-CLASSES
   (ALLOCATE-ALL-META-OBJECTS-ITERATOR
    (CL:1+
     (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY TOP-SYMBOL-OFFSET *SURROGATE-ARRAY*))
    (CL:FUNCTION ALL-CLASSES-NEXT?)
    MODULE
    LOCAL?))
  :VOID)

;;; (DEFUN (SLOTS-NEXT? BOOLEAN) ...)

(CL:DEFUN SLOTS-NEXT? (SELF)
  (CL:LET*
   ((SLOT NULL))
   (CL:LOOP
    (CL:LOOP
     (CL:LET*
      ()
      (CL:SETQ
       SLOT
       (FIRST (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
      (CL:WHEN (CL:EQ SLOT NULL) (CL:RETURN)))
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
      (CLSYS-SVAL
       CONS
       REST
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
     (CL:WHEN
      (CL:OR
       (CL:EQ
        (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)
        NULL)
       (CL:EQ
        (CL:FUNCALL
         (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)
         SLOT
         SELF)
        1))
      (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) SLOT)
      (CL:RETURN-FROM SLOTS-NEXT? TRUE)))
    (CL:WHEN
     (CL:EQ
      (NEXT? (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))
      0)
     (CL:RETURN-FROM SLOTS-NEXT? FALSE))
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL
       CLASS
       CLASS-LOCAL-SLOTS
       (CLSYS-SVAL
        ITERATOR
        VALUE
        (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF)))))))
  :VOID)

;;; (DEFUN (ALL-SLOTS (ITERATOR OF SLOT)) ...)

(CL:DEFUN ALL-SLOTS (MODULE LOCAL?)
  "Iterate over all slots visible from 'module'.
If 'local?', return only methods interned in 'module'.
If 'module' is null, return all methods interned everywhere."
  (CL:LET*
   ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION SLOTS-NEXT?))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR ITERATOR)
    (ALL-CLASSES MODULE LOCAL?))
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST ITERATOR) NIL)
   (CL:RETURN-FROM ALL-SLOTS ITERATOR))
  :VOID)

;;; (DEFUN (ALL-METHODS (ITERATOR OF METHOD-SLOT)) ...)

(CL:DEFUN ALL-METHODS (MODULE LOCAL?)
  "Iterate over all methods visible from 'module'.
If 'local?', return only methods interned in 'module'.
If 'module' is null, return all methods interned everywhere."
  (CL:LET*
   ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION SLOTS-NEXT?))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR ITERATOR)
    (ALL-CLASSES MODULE LOCAL?))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-METHOD-SLOT?))
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST ITERATOR) NIL)
   (CL:RETURN-FROM ALL-METHODS ITERATOR))
  :VOID)

;;; (DEFUN (ALL-PUBLIC-METHODS (ITERATOR OF METHOD-SLOT)) ...)

(CL:DEFUN ALL-PUBLIC-METHODS (MODULE LOCAL?)
  "Iterate over all public methods visible from 'module'.
If 'local?', return only methods interned in 'module'.
If 'module' is null, return all methods interned everywhere."
  (CL:LET*
   ((ITERATOR (ALL-SLOTS MODULE LOCAL?)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-PUBLIC-METHOD-SLOT?))
   (CL:RETURN-FROM ALL-PUBLIC-METHODS ITERATOR))
  :VOID)

;;; (DEFUN (CLASS-METHODS-NEXT? BOOLEAN) ...)

(CL:DEFUN CLASS-METHODS-NEXT? (SELF)
  (CL:LET*
   ((SLOT NULL))
   (CL:LOOP
    (CL:LET*
     ()
     (CL:SETQ
      SLOT
      (FIRST (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
     (CL:WHEN (CL:EQ SLOT NULL) (CL:RETURN)))
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
     (CLSYS-SVAL
      CONS
      REST
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
    (CL:WHEN
     (CL:AND
      (CL:EQ (METHOD-SLOT? SLOT) 1)
      (CL:OR
       (CL:EQ
        (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)
        NULL)
       (CL:EQ
        (CL:FUNCALL
         (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)
         SLOT
         SELF)
        1)))
     (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) SLOT)
     (CL:RETURN-FROM CLASS-METHODS-NEXT? TRUE)))
   (CL:RETURN-FROM CLASS-METHODS-NEXT? FALSE))
  :VOID)

;;; (DEFUN (CLASS-METHODS (ITERATOR OF METHOD-SLOT)) ...)

(CL:DEFUN CLASS-METHODS (CLASS FILTERS)
  (CL:LET*
   ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION CLASS-METHODS-NEXT?))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST ITERATOR)
    (CLSYS-SVAL
     LIST
     THE-CONS-LIST
     (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS CLASS)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT ITERATOR)
    FILTERS)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-SLOT?))
   (CL:RETURN-FROM CLASS-METHODS ITERATOR))
  :VOID)

;;; (DEFUN (PUBLIC-CLASS-METHODS (ITERATOR OF METHOD-SLOT)) ...)

(CL:DEFUN PUBLIC-CLASS-METHODS (CLASS)
  "Iterate over all private methods attached to 'class'."
  (CL:RETURN-FROM
   PUBLIC-CLASS-METHODS
   (CLASS-METHODS
    CLASS
    (CONS
     (WRAP-LITERAL (CL:FUNCTION FILTER-PUBLIC-SLOT?))
     (CONS
      (WRAP-LITERAL (CL:FUNCTION FILTER-NON-EXTERNAL-SLOT?))
      (CONS (WRAP-LITERAL (CL:FUNCTION FILTER-NON-AUXILIARY-SLOT?)) NIL)))))
  :VOID)

;;; (DEFUN (PRIVATE-CLASS-METHODS (ITERATOR OF METHOD-SLOT)) ...)

(CL:DEFUN PRIVATE-CLASS-METHODS (CLASS)
  "Iterate over all private methods attached to 'class'."
  (CL:RETURN-FROM
   PRIVATE-CLASS-METHODS
   (CLASS-METHODS
    CLASS
    (CONS
     (WRAP-LITERAL (CL:FUNCTION FILTER-PRIVATE-SLOT?))
     (CONS
      (WRAP-LITERAL (CL:FUNCTION FILTER-NON-EXTERNAL-SLOT?))
      (CONS (WRAP-LITERAL (CL:FUNCTION FILTER-NON-AUXILIARY-SLOT?)) NIL)))))
  :VOID)

;;; (DEFUN (CLASS-STORAGE-SLOTS-NEXT? BOOLEAN) ...)

(CL:DEFUN CLASS-STORAGE-SLOTS-NEXT? (SELF)
  (CL:LET*
   ((SLOT NULL))
   (CL:LOOP
    (CL:LET*
     ()
     (CL:SETQ
      SLOT
      (FIRST (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
     (CL:WHEN (CL:EQ SLOT NULL) (CL:RETURN)))
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
     (CLSYS-SVAL
      CONS
      REST
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
    (CL:WHEN
     (CL:AND
      (CL:EQ (STORAGE-SLOT? SLOT) 1)
      (CL:OR
       (CL:EQ
        (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)
        NULL)
       (CL:EQ
        (CL:FUNCALL
         (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)
         SLOT
         SELF)
        1)))
     (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) SLOT)
     (CL:RETURN-FROM CLASS-STORAGE-SLOTS-NEXT? TRUE)))
   (CL:RETURN-FROM CLASS-STORAGE-SLOTS-NEXT? FALSE))
  :VOID)

;;; (DEFUN (CLASS-STORAGE-SLOTS (ITERATOR OF STORAGE-SLOT)) ...)

(CL:DEFUN CLASS-STORAGE-SLOTS (CLASS FILTERS)
  (CL:LET*
   ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION CLASS-STORAGE-SLOTS-NEXT?))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST ITERATOR)
    (CLSYS-SVAL
     LIST
     THE-CONS-LIST
     (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS CLASS)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT ITERATOR)
    FILTERS)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-SLOT?))
   (CL:RETURN-FROM CLASS-STORAGE-SLOTS ITERATOR))
  :VOID)

;;; (DEFUN (CLASS-TABLES-NEXT? BOOLEAN) ...)

(CL:DEFUN CLASS-TABLES-NEXT? (SELF)
  (CL:LET*
   ((SLOT NULL))
   (CL:LOOP
    (CL:LET*
     ()
     (CL:SETQ
      SLOT
      (FIRST (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
     (CL:WHEN (CL:EQ SLOT NULL) (CL:RETURN)))
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
     (CLSYS-SVAL
      CONS
      REST
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)))
    (CL:WHEN
     (CL:AND
      (CL:EQ (ISA? SLOT SGT-ITERATORS-TABLE) 1)
      (CL:OR
       (CL:EQ
        (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)
        NULL)
       (CL:EQ
        (CL:FUNCALL
         (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)
         SLOT
         SELF)
        1)))
     (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) SLOT)
     (CL:RETURN-FROM CLASS-TABLES-NEXT? TRUE)))
   (CL:RETURN-FROM CLASS-TABLES-NEXT? FALSE))
  :VOID)

;;; (DEFUN (CLASS-TABLES (ITERATOR OF TABLE)) ...)

(CL:DEFUN CLASS-TABLES (CLASS FILTERS)
  (CL:LET*
   ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION CLASS-TABLES-NEXT?))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST ITERATOR)
    (CLSYS-SVAL
     LIST
     THE-CONS-LIST
     (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS CLASS)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT ITERATOR)
    FILTERS)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-SLOT?))
   (CL:RETURN-FROM CLASS-TABLES ITERATOR))
  :VOID)

;;; (DEFUN (PUBLIC-CLASS-STORAGE-SLOTS (ITERATOR OF STORAGE-SLOT)) ...)

(CL:DEFUN PUBLIC-CLASS-STORAGE-SLOTS (CLASS)
  "Iterate over all public storage-slots attached to 'class'."
  (CL:RETURN-FROM
   PUBLIC-CLASS-STORAGE-SLOTS
   (CLASS-STORAGE-SLOTS
    CLASS
    (CONS
     (WRAP-LITERAL (CL:FUNCTION FILTER-PUBLIC-SLOT?))
     (CONS
      (WRAP-LITERAL (CL:FUNCTION FILTER-NON-PARAMETER-SLOT?))
      (CONS
       (WRAP-LITERAL (CL:FUNCTION FILTER-NON-EXTERNAL-SLOT?))
       (CONS (WRAP-LITERAL (CL:FUNCTION FILTER-NON-AUXILIARY-SLOT?)) NIL))))))
  :VOID)

;;; (DEFUN (PRIVATE-CLASS-STORAGE-SLOTS (ITERATOR OF STORAGE-SLOT)) ...)

(CL:DEFUN PRIVATE-CLASS-STORAGE-SLOTS (CLASS)
  "Iterate over all private storage-slots attached to 'class'."
  (CL:RETURN-FROM
   PRIVATE-CLASS-STORAGE-SLOTS
   (CLASS-STORAGE-SLOTS
    CLASS
    (CONS
     (WRAP-LITERAL (CL:FUNCTION FILTER-PRIVATE-SLOT?))
     (CONS
      (WRAP-LITERAL (CL:FUNCTION FILTER-NON-PARAMETER-SLOT?))
      (CONS
       (WRAP-LITERAL (CL:FUNCTION FILTER-NON-EXTERNAL-SLOT?))
       (CONS (WRAP-LITERAL (CL:FUNCTION FILTER-NON-AUXILIARY-SLOT?)) NIL))))))
  :VOID)

(CL:DEFUN STARTUP-ITERATORS ()
  (CL:LET*
   ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SGT-ITERATORS-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TABLE" NULL 1)))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-ITERATOR"
        "ABSTRACT-ITERATOR"
        "(DEFMETHOD (ALLOCATE-ITERATOR (LIKE SELF)) ((SELF ABSTRACT-ITERATOR)) :DOCUMENTATION \"Iterator objects return themselves when asked
for an iterator (they occupy the same position as a collection
within a 'foreach' statement).\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ALLOCATE-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LENGTH"
        "ABSTRACT-ITERATOR"
        "(DEFMETHOD (LENGTH INTEGER) ((SELF ABSTRACT-ITERATOR)) :DOCUMENTATION \"Iterate over 'self', and count how many
items there are.  Bad idea if 'self' iterates over an infinite
collection, since in that case it will run forever.'\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LENGTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POP"
        "ITERATOR"
        "(DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ((SELF ITERATOR)) :DOCUMENTATION \"Return the first item of the sequence represented by 'self',
or NULL if it is empty.  Destructively uses up the first iteration element.\" :PUBLIC? TRUE)")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION POP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ADVANCE"
        "ITERATOR"
        "(DEFMETHOD (ADVANCE (LIKE SELF)) ((SELF ITERATOR) (N INTEGER)) :DOCUMENTATION \"Return 'self' after skipping over the first
'n' elements in the (remainder of the) iteration.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ADVANCE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EMPTY?"
        "ITERATOR"
        "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF ITERATOR)) :DOCUMENTATION \"Return TRUE if the sequence represented by 'self'
has no elements.  Side-effect free.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MEMBER?"
        "ITERATOR"
        "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF ITERATOR) (VALUE OBJECT)) :DOCUMENTATION \"Iterate over values of 'self', returning TRUE
if one of them is 'eql' to 'value.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MEMBER?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "DESTRUCTIVE-LIST-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF DESTRUCTIVE-LIST-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EMPTY?"
        "DESTRUCTIVE-LIST-ITERATOR"
        "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF DESTRUCTIVE-LIST-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TERMINATE-DESTRUCTIVE-LIST-ITERATOR?"
        "DESTRUCTIVE-LIST-ITERATOR"
        "(DEFUN (TERMINATE-DESTRUCTIVE-LIST-ITERATOR? BOOLEAN) ((SELF DESTRUCTIVE-LIST-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TERMINATE-DESTRUCTIVE-LIST-ITERATOR?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT"
        "DESTRUCTIVE-LIST-ITERATOR"
        "(DEFMETHOD INSERT ((SELF DESTRUCTIVE-LIST-ITERATOR) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Add 'value' to the front of the list 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INSERT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-DESTRUCTIVE-LIST-ITERATOR"
        "CONS"
        "(DEFMETHOD (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ALLOCATE-DESTRUCTIVE-LIST-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-DESTRUCTIVE-LIST-ITERATOR"
        "LIST"
        "(DEFMETHOD (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ALLOCATE-DESTRUCTIVE-LIST-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)) :DOCUMENTATION \"Apply the stored 'next?' function to 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EMPTY?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TERMINATE-ALL-PURPOSE-ITERATOR?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFMETHOD (TERMINATE-ALL-PURPOSE-ITERATOR? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION TERMINATE-ALL-PURPOSE-ITERATOR?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTERED-NESTED-ITERATOR-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (FILTERED-NESTED-ITERATOR-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTERED-NESTED-ITERATOR-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ITERATOR-CONS-LIST-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (ITERATOR-CONS-LIST-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ITERATOR-CONS-LIST-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ITERATOR-CONS-LIST-EMPTY?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (ITERATOR-CONS-LIST-EMPTY? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ITERATOR-CONS-LIST-EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTERED-CONCATENATED-ITERATOR-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (FILTERED-CONCATENATED-ITERATOR-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTERED-CONCATENATED-ITERATOR-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONCATENATE"
        "ITERATOR"
        "(DEFMETHOD (CONCATENATE ALL-PURPOSE-ITERATOR) ((ITERATOR1 ITERATOR) (ITERATOR2 ITERATOR)) :DOCUMENTATION \"Return an iterator that first generates all values of
`iterator1' and then those of `iterator2'.  The generated values can be
filtered by supplying a filter function to the resulting iterator.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CONCATENATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INITIALIZE-INTEGER-INTERVAL-ITERATOR"
        "INTEGER-INTERVAL-ITERATOR"
        "(DEFMETHOD INITIALIZE-INTEGER-INTERVAL-ITERATOR ((SELF INTEGER-INTERVAL-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION INITIALIZE-INTEGER-INTERVAL-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "INTEGER-INTERVAL-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF INTEGER-INTERVAL-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INTERVAL"
        "INTEGER"
        "(DEFUN (INTERVAL INTEGER-INTERVAL-ITERATOR) ((LOWERBOUND INTEGER) (UPPERBOUND INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INTERVAL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REVERSE"
        "INTEGER-INTERVAL-ITERATOR"
        "(DEFMETHOD (REVERSE REVERSE-INTEGER-INTERVAL-ITERATOR) ((SELF INTEGER-INTERVAL-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REVERSE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INITIALIZE-REVERSE-INTEGER-INTERVAL-ITERATOR"
        "REVERSE-INTEGER-INTERVAL-ITERATOR"
        "(DEFUN INITIALIZE-REVERSE-INTEGER-INTERVAL-ITERATOR ((SELF REVERSE-INTEGER-INTERVAL-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INITIALIZE-REVERSE-INTEGER-INTERVAL-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "REVERSE-INTEGER-INTERVAL-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF REVERSE-INTEGER-INTERVAL-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REVERSE-INTERVAL"
        "INTEGER"
        "(DEFUN (REVERSE-INTERVAL REVERSE-INTEGER-INTERVAL-ITERATOR) ((LOWERBOUND INTEGER) (UPPERBOUND INTEGER)) :DOCUMENTATION \"Create a reverse interval object.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REVERSE-INTERVAL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-ITERATOR"
        "VECTOR"
        "(DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ALLOCATE-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VECTOR-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (VECTOR-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VECTOR-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUT-LAST"
        "VECTOR"
        "(DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)) :DOCUMENTATION \"Generate all but the last element of the vector 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION BUT-LAST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-ITERATOR"
        "STRING"
        "(DEFMETHOD (ALLOCATE-ITERATOR STRING-ITERATOR) ((SELF STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ALLOCATE-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "STRING-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF STRING-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-MODULES-LIST"
        "MODULE"
        "(DEFUN (YIELD-MODULES-LIST (CONS OF MODULE)) ((MODULE MODULE) (LOCAL? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-MODULES-LIST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-ALL-META-OBJECTS-ITERATOR"
        "INTEGER"
        "(DEFUN (ALLOCATE-ALL-META-OBJECTS-ITERATOR ITERATOR) ((ARRAYSIZE INTEGER) (NEXTCODE FUNCTION-CODE) (MODULE MODULE) (LOCAL? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALLOCATE-ALL-META-OBJECTS-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-SYMBOLS-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (ALL-SYMBOLS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-SYMBOLS-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-SYMBOLS"
        "MODULE"
        "(DEFUN (ALL-SYMBOLS (ITERATOR OF SYMBOL)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all symbols visible from 'module'.
If 'local?', return only symbols interned in 'module'.
If 'module' is null, return all symbols interned everywhere.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-SYMBOLS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTER-PUBLIC-SLOT?"
        "SLOT"
        "(DEFUN (FILTER-PUBLIC-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTER-PUBLIC-SLOT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTER-PRIVATE-SLOT?"
        "SLOT"
        "(DEFUN (FILTER-PRIVATE-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTER-PRIVATE-SLOT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTER-METHOD-SLOT?"
        "SLOT"
        "(DEFUN (FILTER-METHOD-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTER-METHOD-SLOT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTER-PUBLIC-METHOD-SLOT?"
        "SLOT"
        "(DEFUN (FILTER-PUBLIC-METHOD-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTER-PUBLIC-METHOD-SLOT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTER-NON-EXTERNAL-SLOT?"
        "SLOT"
        "(DEFUN (FILTER-NON-EXTERNAL-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTER-NON-EXTERNAL-SLOT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTER-NON-PARAMETER-SLOT?"
        "SLOT"
        "(DEFUN (FILTER-NON-PARAMETER-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTER-NON-PARAMETER-SLOT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTER-NON-AUXILIARY-SLOT?"
        "SLOT"
        "(DEFUN (FILTER-NON-AUXILIARY-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTER-NON-AUXILIARY-SLOT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTER-SLOT?"
        "SLOT"
        "(DEFUN (FILTER-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTER-SLOT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-FUNCTIONS-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (ALL-FUNCTIONS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-FUNCTIONS-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-FUNCTIONS"
        "MODULE"
        "(DEFUN (ALL-FUNCTIONS (ITERATOR OF FUNCTION)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all functions visible from 'module'.
If 'local?', return only functions bound to symbols interned in 'module'.
If 'module' is null, return all functions defined everywhere.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-FUNCTIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-PUBLIC-FUNCTIONS"
        "MODULE"
        "(DEFUN (ALL-PUBLIC-FUNCTIONS (ITERATOR OF FUNCTION)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all functions visible from 'module'.
If 'local?', return only functions bound to symbols interned in 'module'.
If 'module' is null, return all functions defined everywhere.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-PUBLIC-FUNCTIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-VARIABLES-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (ALL-VARIABLES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-VARIABLES-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-VARIABLES"
        "MODULE"
        "(DEFUN (ALL-VARIABLES (ITERATOR OF GLOBAL-VARIABLE)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all variables visible from 'module'.
If 'local?', return only variables bound to symbols interned in 'module'.
If 'module' is null, return all variables defined everywhere.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-VARIABLES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-SURROGATES-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (ALL-SURROGATES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-SURROGATES-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-SURROGATES"
        "MODULE"
        "(DEFUN (ALL-SURROGATES (ITERATOR OF SURROGATE)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all surrogates visible from 'module'.
If 'local?', return only surrogates interned in 'module'.
If 'module' is null, return all surrogates interned everywhere.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-SURROGATES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-CLASSES-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (ALL-CLASSES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-CLASSES-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-CLASSES"
        "MODULE"
        "(DEFUN (ALL-CLASSES (ITERATOR OF CLASS)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all classes visible from 'module'.
If 'local?', return only classes interned in 'module'.
If 'module' is null, return all classes interned everywhere.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-CLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SLOTS-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (SLOTS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SLOTS-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-SLOTS"
        "MODULE"
        "(DEFUN (ALL-SLOTS (ITERATOR OF SLOT)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all slots visible from 'module'.
If 'local?', return only methods interned in 'module'.
If 'module' is null, return all methods interned everywhere.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-METHODS"
        "MODULE"
        "(DEFUN (ALL-METHODS (ITERATOR OF METHOD-SLOT)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all methods visible from 'module'.
If 'local?', return only methods interned in 'module'.
If 'module' is null, return all methods interned everywhere.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-METHODS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-PUBLIC-METHODS"
        "MODULE"
        "(DEFUN (ALL-PUBLIC-METHODS (ITERATOR OF METHOD-SLOT)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all public methods visible from 'module'.
If 'local?', return only methods interned in 'module'.
If 'module' is null, return all methods interned everywhere.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-PUBLIC-METHODS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASS-METHODS-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (CLASS-METHODS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASS-METHODS-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASS-METHODS"
        "CLASS"
        "(DEFUN (CLASS-METHODS (ITERATOR OF METHOD-SLOT)) ((CLASS CLASS) (FILTERS (CONS OF FUNCTION-WRAPPER))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASS-METHODS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PUBLIC-CLASS-METHODS"
        "CLASS"
        "(DEFUN (PUBLIC-CLASS-METHODS (ITERATOR OF METHOD-SLOT)) ((CLASS CLASS)) :DOCUMENTATION \"Iterate over all private methods attached to 'class'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PUBLIC-CLASS-METHODS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRIVATE-CLASS-METHODS"
        "CLASS"
        "(DEFUN (PRIVATE-CLASS-METHODS (ITERATOR OF METHOD-SLOT)) ((CLASS CLASS)) :DOCUMENTATION \"Iterate over all private methods attached to 'class'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRIVATE-CLASS-METHODS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASS-STORAGE-SLOTS-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (CLASS-STORAGE-SLOTS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASS-STORAGE-SLOTS-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASS-STORAGE-SLOTS"
        "CLASS"
        "(DEFUN (CLASS-STORAGE-SLOTS (ITERATOR OF STORAGE-SLOT)) ((CLASS CLASS) (FILTERS (CONS OF FUNCTION-CODE-WRAPPER))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASS-STORAGE-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASS-TABLES-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (CLASS-TABLES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASS-TABLES-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASS-TABLES"
        "CLASS"
        "(DEFUN (CLASS-TABLES (ITERATOR OF TABLE)) ((CLASS CLASS) (FILTERS (CONS OF FUNCTION-CODE-WRAPPER))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASS-TABLES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PUBLIC-CLASS-STORAGE-SLOTS"
        "CLASS"
        "(DEFUN (PUBLIC-CLASS-STORAGE-SLOTS (ITERATOR OF STORAGE-SLOT)) ((CLASS CLASS)) :DOCUMENTATION \"Iterate over all public storage-slots attached to 'class'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PUBLIC-CLASS-STORAGE-SLOTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRIVATE-CLASS-STORAGE-SLOTS"
        "CLASS"
        "(DEFUN (PRIVATE-CLASS-STORAGE-SLOTS (ITERATOR OF STORAGE-SLOT)) ((CLASS CLASS)) :DOCUMENTATION \"Iterate over all private storage-slots attached to 'class'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRIVATE-CLASS-STORAGE-SLOTS)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-ITERATORS"
     NULL
     "(DEFUN STARTUP-ITERATORS ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES)))
  :VOID)
