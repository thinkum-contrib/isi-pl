;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-PRIMAL-FLOOR NULL)
(CL:DEFVAR KWD-PRIMAL-CPP NULL)
(CL:DEFVAR KWD-PRIMAL-FUNCTION NULL)
(CL:DEFVAR SYM-PRIMAL-*TRANSIENTOBJECTS?* NULL)

;;; Forward declarations:

(CL:DECLAIM (CL:SPECIAL *STELLA-MODULE* *MODULE*))

;;; (DEFCONSTANT TRUE ...)

(CL:DEFVAR TRUE 1)

;;; (DEFCONSTANT FALSE ...)

(CL:DEFVAR FALSE 0)

;;; (DEFCONSTANT NULL-BOOLEAN ...)

(CL:DEFVAR NULL-BOOLEAN CL:MOST-POSITIVE-FIXNUM)

;;; (DEFCONSTANT NULL-INTEGER ...)

(CL:DEFVAR NULL-INTEGER CL:MOST-NEGATIVE-FIXNUM)

;;; (DEFCONSTANT NULL-SHORT-INTEGER ...)

(CL:DEFVAR NULL-SHORT-INTEGER CL:MOST-NEGATIVE-FIXNUM)

;;; (DEFCONSTANT NULL-LONG-INTEGER ...)

(CL:DEFVAR NULL-LONG-INTEGER CL:MOST-NEGATIVE-FIXNUM)

;;; (DEFCONSTANT NULL-UNSIGNED-SHORT-INTEGER ...)

(CL:DEFVAR NULL-UNSIGNED-SHORT-INTEGER CL:MOST-NEGATIVE-FIXNUM)

;;; (DEFCONSTANT NULL-UNSIGNED-LONG-INTEGER ...)

(CL:DEFVAR NULL-UNSIGNED-LONG-INTEGER CL:MOST-NEGATIVE-FIXNUM)

;;; (DEFCONSTANT NULL-FLOAT ...)

(CL:DEFVAR NULL-FLOAT CL:MOST-NEGATIVE-DOUBLE-FLOAT)

;;; (DEFCONSTANT NULL-SINGLE-FLOAT ...)

(CL:DEFVAR NULL-SINGLE-FLOAT CL:MOST-NEGATIVE-SINGLE-FLOAT)

;;; (DEFCONSTANT NULL-DOUBLE-FLOAT ...)

(CL:DEFVAR NULL-DOUBLE-FLOAT NULL-FLOAT)

;;; (DEFCONSTANT NULL-CHARACTER ...)

(CL:DEFVAR NULL-CHARACTER (CL:CODE-CHAR 0))

;;; (DEFCONSTANT NULL-OCTET ...)

(CL:DEFVAR NULL-OCTET NULL-CHARACTER)

;;; (DEFUN (RANDOM INTEGER) ...)

(CL:DEFUN RANDOM (N)
  "Generate a random integer in the interval [0..n-1].
'n' must be <= 2^15."
  (CL:WHEN
   (CL:> N 32768)
   (CL:ERROR
    "random: Can only generate random numbers between 0 and (2^15)-1."))
  (CL:LET* ((RNUM (CL:RANDOM N))) (CL:RETURN-FROM RANDOM RNUM))
  :VOID)

;;; (DEFUN (MIN INTEGER) ...)

(CL:DEFUN MIN (X Y)
  "Return the minimum of `x' and `y'.  If either is NULL, return the other."
  (CL:WHEN (CL:EQ (NULL? X) 1) (CL:RETURN-FROM MIN Y))
  (CL:WHEN (CL:EQ (NULL? Y) 1) (CL:RETURN-FROM MIN X))
  (CL:RETURN-FROM MIN (CL:IF (CL:< X Y) X Y))
  :VOID)

;;; (DEFUN (MAX INTEGER) ...)

(CL:DEFUN MAX (X Y)
  "Return the maximum of `x' and `y'.  If either is NULL, return the other."
  (CL:WHEN (CL:EQ (NULL? X) 1) (CL:RETURN-FROM MAX Y))
  (CL:WHEN (CL:EQ (NULL? Y) 1) (CL:RETURN-FROM MAX X))
  (CL:RETURN-FROM MAX (CL:IF (CL:> X Y) X Y))
  :VOID)

;;; (DEFSPECIAL *TRANSIENTOBJECTS?* ...)

(CL:DEFVAR *TRANSIENTOBJECTS?* FALSE)

(CL:DEFUN READ-*TRANSIENTOBJECTS?* ()
  (CL:RETURN-FROM READ-*TRANSIENTOBJECTS?* *TRANSIENTOBJECTS?*)
  :VOID)

(CL:DEFUN WRITE-*TRANSIENTOBJECTS?* (VALUE)
  (CL:SETQ *TRANSIENTOBJECTS?* VALUE)
  (CL:RETURN-FROM WRITE-*TRANSIENTOBJECTS?* VALUE)
  :VOID)

;;; (DEFUN (STRING-COMPARE INTEGER) ...)

(CL:DEFUN STRING-COMPARE (X Y)
  "Compare 'x' and 'y' lexicographically, and return -1, 0, 
or 1, depending on whether 'x' is less than, equal, or greater than 'y'."
  (CL:LET*
   ((TEMP1 NULL-INTEGER) (TEMP2 NULL-INTEGER))
   (CL:LET*
    ((C2 NULL)
     (C1 NULL)
     (VECTOR-001 X)
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001))
     (VECTOR-002 Y)
     (INDEX-002 0)
     (LENGTH-002 (LENGTH VECTOR-002)))
    (CL:LOOP
     WHILE
     (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:< INDEX-002 LENGTH-002))
     DO
     (CL:PROGN
      (CL:SETQ C1 (CL:CHAR VECTOR-001 INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:PROGN
      (CL:SETQ C2 (CL:CHAR VECTOR-002 INDEX-002))
      (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
     (CL:SETQ TEMP1 (CHARACTER-CODE C1))
     (CL:SETQ TEMP2 (CHARACTER-CODE C2))
     (CL:WHEN (CL:< TEMP1 TEMP2) (CL:RETURN-FROM STRING-COMPARE -1))
     (CL:WHEN (CL:> TEMP1 TEMP2) (CL:RETURN-FROM STRING-COMPARE 1))))
   (CL:SETQ TEMP1 (LENGTH X))
   (CL:SETQ TEMP2 (LENGTH Y))
   (CL:IF
    (CL:= TEMP1 TEMP2)
    (CL:RETURN-FROM STRING-COMPARE 0)
    (CL:IF
     (CL:< TEMP1 TEMP2)
     (CL:RETURN-FROM STRING-COMPARE -1)
     (CL:RETURN-FROM STRING-COMPARE 1))))
  :VOID)

;;; (DEFUN (STRING< BOOLEAN) ...)

(CL:DEFUN STRING< (X Y)
  "Return TRUE if 'x' is lexicographically < 'y'."
  (CL:RETURN-FROM STRING< (EQ? (STRING-COMPARE X Y) -1))
  :VOID)

;;; (DEFUN (STRING<= BOOLEAN) ...)

(CL:DEFUN STRING<= (X Y)
  "Return TRUE if 'x' is lexicographically <= 'y'."
  (CL:RETURN-FROM STRING<= (<= (STRING-COMPARE X Y) 0))
  :VOID)

;;; (DEFUN (STRING>= BOOLEAN) ...)

(CL:DEFUN STRING>= (X Y)
  "Return TRUE if 'x' is lexicographically >= 'y'."
  (CL:RETURN-FROM STRING>= (>= (STRING-COMPARE X Y) 0))
  :VOID)

;;; (DEFUN (STRING> BOOLEAN) ...)

(CL:DEFUN STRING> (X Y)
  "Return TRUE if 'x' is lexicographically > 'y'."
  (CL:RETURN-FROM STRING> (EQ? (STRING-COMPARE X Y) 1))
  :VOID)

;;; (DEFMETHOD PRINT-VECTOR ...)

(CL:DEFMETHOD PRINT-VECTOR ((SELF VECTOR) STREAM)
  (CL:IF
   (CL:= (LENGTH SELF) 0)
   (CL:WRITE-STRING "|i|[]" STREAM)
   (CL:LET*
    ((I 0) (LIMIT 9))
    (CL:WRITE-STRING "|i|[" STREAM)
    (CL:LET*
     ((ELEMENT NULL)
      (VECTOR-001 SELF)
      (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:LOOP
      WHILE
      (CL:< INDEX-001 LENGTH-001)
      DO
      (CL:PROGN
       (CL:SETQ
        ELEMENT
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (PRINT-OBJECT ELEMENT STREAM)
      (CL:SETQ I (CL:1+ I))
      (CL:WHEN (CL:> I LIMIT) (CL:RETURN))
      (CL:WHEN (CL:< I (LENGTH SELF)) (CL:WRITE-STRING " " STREAM))))
    (CL:IF
     (CL:OR (CL:<= I LIMIT) (CL:= I (LENGTH SELF)))
     (CL:WRITE-STRING "]" STREAM)
     (CL:WRITE-STRING " ...]" STREAM))))
  :VOID)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF VECTOR))
  "Return TRUE if 'self' has length 0."
  (CL:RETURN-FROM EMPTY? (EQ? (LENGTH SELF) 0))
  :VOID)

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF VECTOR))
  "Return TRUE if 'self' has length > 0."
  (CL:RETURN-FROM NON-EMPTY? (> (LENGTH SELF) 0))
  :VOID)

;;; (DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD SECOND ((SELF VECTOR))
  (CL:RETURN-FROM SECOND (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY SELF) 1))
  :VOID)

;;; (DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD THIRD ((SELF VECTOR))
  (CL:RETURN-FROM THIRD (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY SELF) 2))
  :VOID)

;;; (DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FOURTH ((SELF VECTOR))
  (CL:RETURN-FROM FOURTH (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY SELF) 3))
  :VOID)

;;; (DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIFTH ((SELF VECTOR))
  (CL:RETURN-FROM FIFTH (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY SELF) 4))
  :VOID)

;;; (DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LAST ((SELF VECTOR))
  "Return the last item in the vector 'self'."
  (CL:RETURN-FROM
   LAST
   (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY SELF) (CL:1- (LENGTH SELF))))
  :VOID)

;;; (DEFMETHOD (LAST-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LAST-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM
   LAST-SETTER
   (CL:SETF
    (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY SELF) (CL:1- (LENGTH SELF)))
    VALUE))
  :VOID)

;;; (DEFMETHOD (COPY (VECTOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD COPY ((SELF VECTOR))
  "Return a copy of the vector 'self'."
  (CL:LET*
   ((COPY (NEW-VECTOR (CLSYS-SVAL VECTOR ARRAY-SIZE SELF))))
   (CL:LET*
    ((I NULL)
     (ITER-001 0)
     (UPPER-BOUND-001 (CL:1- (CLSYS-SVAL VECTOR ARRAY-SIZE SELF))))
    (CL:LOOP
     WHILE
     (CL:<= ITER-001 UPPER-BOUND-001)
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETF
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY COPY) I)
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY SELF) I))))
   (CL:RETURN-FROM COPY COPY))
  :VOID)

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF VECTOR-SEQUENCE))
  (CL:RETURN-FROM LENGTH (CLSYS-SVAL VECTOR-SEQUENCE SEQUENCE-LENGTH SELF))
  :VOID)

(CL:DEFUN STARTUP-PRIMAL ()
  (CL:LET*
   ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ SYM-PRIMAL-FLOOR (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOOR" NULL 0))
    (CL:SETQ KWD-PRIMAL-CPP (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
    (CL:SETQ
     KWD-PRIMAL-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     SYM-PRIMAL-*TRANSIENTOBJECTS?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*TRANSIENTOBJECTS?*" NULL 0)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:SETQ NULL-OCTET NULL-CHARACTER))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "NULL?"
     "UNKNOWN"
     "(DEFMETHOD (NULL? BOOLEAN) ((TEST UNKNOWN)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "NULL?"
     "OBJECT"
     "(DEFMETHOD (NULL? BOOLEAN) ((TEST OBJECT)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "NULL?"
     "STRING"
     "(DEFMETHOD (NULL? BOOLEAN) ((TEST STRING)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "NULL?"
     "CHARACTER"
     "(DEFMETHOD (NULL? BOOLEAN) ((TEST CHARACTER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "NULL?"
     "BOOLEAN"
     "(DEFMETHOD (NULL? BOOLEAN) ((TEST BOOLEAN)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "NULL?"
     "CODE"
     "(DEFMETHOD (NULL? BOOLEAN) ((TEST CODE)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "NULL?"
     "INTEGER"
     "(DEFMETHOD (NULL? BOOLEAN) ((TEST INTEGER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "NULL?"
     "FLOAT"
     "(DEFMETHOD (NULL? BOOLEAN) ((TEST FLOAT)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "DEFINED?"
     "UNKNOWN"
     "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST UNKNOWN)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "DEFINED?"
     "OBJECT"
     "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST OBJECT)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "DEFINED?"
     "STRING"
     "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST STRING)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "DEFINED?"
     "CHARACTER"
     "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST CHARACTER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "DEFINED?"
     "BOOLEAN"
     "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST BOOLEAN)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "DEFINED?"
     "CODE"
     "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST CODE)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "DEFINED?"
     "INTEGER"
     "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST INTEGER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "DEFINED?"
     "FLOAT"
     "(DEFMETHOD (DEFINED? BOOLEAN) ((TEST FLOAT)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     ">"
     "NUMBER"
     "(DEFUN (> BOOLEAN) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     ">="
     "NUMBER"
     "(DEFUN (>= BOOLEAN) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "<"
     "NUMBER"
     "(DEFUN (< BOOLEAN) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "<="
     "NUMBER"
     "(DEFUN (<= BOOLEAN) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "+"
     "NUMBER"
     "(DEFUN (+ NUMBER) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "-"
     "NUMBER"
     "(DEFUN (- NUMBER) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "*"
     "NUMBER"
     "(DEFUN (* NUMBER) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "/"
     "NUMBER"
     "(DEFUN (|/| NUMBER) ((X NUMBER) (Y NUMBER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "ZERO?"
     "INTEGER"
     "(DEFUN (ZERO? BOOLEAN) ((X INTEGER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "PLUS?"
     "INTEGER"
     "(DEFUN (PLUS? BOOLEAN) ((X INTEGER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "EVEN?"
     "INTEGER"
     "(DEFUN (EVEN? BOOLEAN) ((X INTEGER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "ODD?"
     "INTEGER"
     "(DEFUN (ODD? BOOLEAN) ((X INTEGER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "MOD"
     "INTEGER"
     "(DEFUN (MOD INTEGER) ((X INTEGER) (MODULO INTEGER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "CEILING"
     "NUMBER"
     "(DEFUN (CEILING INTEGER) ((N NUMBER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "FLOOR"
     "NUMBER"
     "(DEFUN (FLOOR INTEGER) ((N NUMBER)) :NATIVE? TRUE)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RANDOM"
        "INTEGER"
        "(DEFUN (RANDOM INTEGER) ((N INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Generate a random integer in the interval [0..n-1].
'n' must be <= 2^15.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RANDOM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MIN"
        "INTEGER"
        "(DEFUN (MIN INTEGER) ((X INTEGER) (Y INTEGER)) :DOCUMENTATION \"Return the minimum of `x' and `y'.  If either is NULL, return the other.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MIN)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MAX"
        "INTEGER"
        "(DEFUN (MAX INTEGER) ((X INTEGER) (Y INTEGER)) :DOCUMENTATION \"Return the maximum of `x' and `y'.  If either is NULL, return the other.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MAX)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "CHARACTER-CODE"
     "CHARACTER"
     "(DEFUN (CHARACTER-CODE INTEGER) ((CHAR CHARACTER)) :DOCUMENTATION \"Return the 8-bit ASCII code of 'char' as an integer.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "CODE-CHARACTER"
     "INTEGER"
     "(DEFUN (CODE-CHARACTER CHARACTER) ((CODE INTEGER)) :DOCUMENTATION \"Return the character encoded by 'code' (0 <= 'code' <= 255).\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STRING-EQL?"
     "STRING"
     "(DEFUN (STRING-EQL? BOOLEAN) ((X STRING) (Y STRING)) :NATIVE? TRUE)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING-COMPARE"
        "STRING"
        "(DEFUN (STRING-COMPARE INTEGER) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Compare 'x' and 'y' lexicographically, and return -1, 0, 
or 1, depending on whether 'x' is less than, equal, or greater than 'y'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING-COMPARE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING<"
        "STRING"
        "(DEFUN (STRING< BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically < 'y'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING<)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING<="
        "STRING"
        "(DEFUN (STRING<= BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically <= 'y'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING<=)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING>="
        "STRING"
        "(DEFUN (STRING>= BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically >= 'y'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING>=)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING>"
        "STRING"
        "(DEFUN (STRING> BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if 'x' is lexicographically > 'y'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING>)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "MAKE-STRING"
     "INTEGER"
     "(DEFUN (MAKE-STRING STRING) ((SIZE INTEGER) (INITIALELEMENT CHARACTER)) :DOCUMENTATION \"Return a string of 'size' characters.  If 'initialElement'
is defined, initialize all elements of the new string with it.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "CONCATENATE"
     "STRING"
     "(DEFMETHOD (CONCATENATE STRING) ((STRING1 STRING) (STRING2 STRING)) :DOCUMENTATION \"Return a string representing the concatenation of
'string1' and 'string2'.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "PERMANENT-STRING-UPCASE"
     "STRING"
     "(DEFUN (PERMANENT-STRING-UPCASE STRING) ((STRING STRING)) :DOCUMENTATION \"Return an upper-case copy of 'string' allocated
using the permanent string pool.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STRING-UPCASE"
     "STRING"
     "(DEFUN (STRING-UPCASE STRING) ((STRING STRING)) :DOCUMENTATION \"Return an upper-case copy of 'string'.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STRING-DOWNCASE"
     "STRING"
     "(DEFUN (STRING-DOWNCASE STRING) ((STRING STRING)) :DOCUMENTATION \"Return a lower-case copy of 'string'.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STRING-CAPITALIZE"
     "STRING"
     "(DEFUN (STRING-CAPITALIZE STRING) ((STRING STRING)) :DOCUMENTATION \"Return a capitalized version of 'string'.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "COPY"
     "STRING"
     "(DEFMETHOD (COPY STRING) ((STRING STRING)) :DOCUMENTATION \"Return a copy of 'string'.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "SUBSTITUTE"
     "STRING"
     "(DEFMETHOD (SUBSTITUTE STRING) ((SELF STRING) (NEWCHAR CHARACTER) (OLDCHAR CHARACTER)) :DOCUMENTATION \"Substitute all occurences of 'oldChar' with 'newChar'
in the string 'self'.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "INTEGER-TO-STRING"
     "INTEGER"
     "(DEFUN (INTEGER-TO-STRING STRING) ((INTEGER INTEGER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "MEMBER?"
     "STRING"
     "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF STRING) (CHAR CHARACTER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "NTH"
     "STRING"
     "(DEFMETHOD (NTH CHARACTER) ((SELF STRING) (POSITION INTEGER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "NTH-SETTER"
     "STRING"
     "(DEFMETHOD (NTH-SETTER CHARACTER) ((SELF STRING) (CHAR CHARACTER) (POSITION INTEGER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "REST"
     "STRING"
     "(DEFMETHOD (REST STRING) ((SELF STRING)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "LENGTH"
     "STRING"
     "(DEFMETHOD (LENGTH INTEGER) ((SELF STRING)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "POSITION"
     "STRING"
     "(DEFMETHOD (POSITION INTEGER) ((STRING STRING) (CHARACTER CHARACTER) (START INTEGER)) :DOCUMENTATION \"Return the position of 'character' within 'string' (counting
from zero); or return NULL if 'character' does not occur within 'string'.
If 'start' was supplied as non-NULL, only consider the substring starting
at 'start', however, the returned position will always be relative to the
entire string.\" :NATIVE? TRUE :PUBLIC? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STRING-SEARCH"
     "STRING"
     "(DEFUN (STRING-SEARCH INTEGER) ((STRING STRING) (SUBSTRING STRING) (START INTEGER)) :DOCUMENTATION \"Return start position of the left-most occurrence of
'substring' in 'string', beginning from 'start'.  Return NULL if it is not
a substring.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "SUBSEQUENCE"
     "STRING"
     "(DEFMETHOD (SUBSEQUENCE STRING) ((STRING STRING) (START INTEGER) (END INTEGER)) :DOCUMENTATION \"Return a substring of 'string' beginning at position 'start'
and ending up to but not including position 'end', counting from zero.  An
'end' value of NULL stands for the rest of the string.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STRINGIFY"
     "OBJECT"
     "(DEFUN (STRINGIFY STRING) ((EXPRESSION OBJECT)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "UNSTRINGIFY"
     "STRING"
     "(DEFUN (UNSTRINGIFY OBJECT) ((STRING STRING)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "FREE-HASH-TABLE-VALUES"
     "ABSTRACT-HASH-TABLE"
     "(DEFMETHOD FREE-HASH-TABLE-VALUES ((SELF ABSTRACT-HASH-TABLE)) :DOCUMENTATION \"Call free on each value in the hash table 'self'.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "INITIALIZE-HASH-TABLE"
     "ABSTRACT-HASH-TABLE"
     "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF ABSTRACT-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into 'self'.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "LOOKUP"
     "HASH-TABLE"
     "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "INSERT-AT"
     "HASH-TABLE"
     "(DEFMETHOD INSERT-AT ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "REMOVE-AT"
     "HASH-TABLE"
     "(DEFMETHOD REMOVE-AT ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "LOOKUP"
     "INTEGER-HASH-TABLE"
     "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF INTEGER-HASH-TABLE) (KEY INTEGER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "INSERT-AT"
     "INTEGER-HASH-TABLE"
     "(DEFMETHOD INSERT-AT ((SELF INTEGER-HASH-TABLE) (KEY INTEGER) (VALUE OBJECT)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "LOOKUP"
     "FLOAT-HASH-TABLE"
     "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF FLOAT-HASH-TABLE) (KEY FLOAT)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "INSERT-AT"
     "FLOAT-HASH-TABLE"
     "(DEFMETHOD INSERT-AT ((SELF FLOAT-HASH-TABLE) (KEY FLOAT) (VALUE OBJECT)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "INITIALIZE-HASH-TABLE"
     "STRING-HASH-TABLE"
     "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into 'self'.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "LOOKUP"
     "STRING-HASH-TABLE"
     "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF STRING-HASH-TABLE) (KEY STRING)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "INSERT-AT"
     "STRING-HASH-TABLE"
     "(DEFMETHOD INSERT-AT ((SELF STRING-HASH-TABLE) (KEY STRING) (VALUE OBJECT)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "REMOVE-AT"
     "STRING-HASH-TABLE"
     "(DEFMETHOD REMOVE-AT ((SELF STRING-HASH-TABLE) (KEY STRING)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "INITIALIZE-HASH-TABLE"
     "STRING-TO-INTEGER-HASH-TABLE"
     "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-TO-INTEGER-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into 'self'.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "LOOKUP"
     "STRING-TO-INTEGER-HASH-TABLE"
     "(DEFMETHOD (LOOKUP INTEGER) ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "INSERT-AT"
     "STRING-TO-INTEGER-HASH-TABLE"
     "(DEFMETHOD INSERT-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING) (VALUE INTEGER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "REMOVE-AT"
     "STRING-TO-INTEGER-HASH-TABLE"
     "(DEFMETHOD REMOVE-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "INITIALIZE-VECTOR"
     "VECTOR"
     "(DEFMETHOD INITIALIZE-VECTOR ((SELF VECTOR)) :NATIVE? TRUE)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-VECTOR"
        "VECTOR"
        "(DEFMETHOD PRINT-VECTOR ((SELF VECTOR) (STREAM NATIVE-OUTPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PRINT-VECTOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EMPTY?"
        "VECTOR"
        "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF VECTOR)) :DOCUMENTATION \"Return TRUE if 'self' has length 0.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NON-EMPTY?"
        "VECTOR"
        "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF VECTOR)) :DOCUMENTATION \"Return TRUE if 'self' has length > 0.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NON-EMPTY?)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "FIRST"
     "VECTOR"
     "(DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :NATIVE? TRUE)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SECOND"
        "VECTOR"
        "(DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SECOND)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "THIRD"
        "VECTOR"
        "(DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION THIRD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FOURTH"
        "VECTOR"
        "(DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FOURTH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIFTH"
        "VECTOR"
        "(DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FIFTH)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "NTH"
     "VECTOR"
     "(DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (OFFSET INTEGER)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "NTH-SETTER"
     "VECTOR"
     "(DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE OBJECT) (POSITION INTEGER)) :NATIVE? TRUE)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LAST"
        "VECTOR"
        "(DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :DOCUMENTATION \"Return the last item in the vector 'self'.\")")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION LAST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LAST-SETTER"
        "VECTOR"
        "(DEFMETHOD (LAST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LAST-SETTER)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "LENGTH"
     "VECTOR"
     "(DEFMETHOD (LENGTH INTEGER) ((SELF VECTOR)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "MEMBER?"
     "VECTOR"
     "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF VECTOR) (OBJECT OBJECT)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "INSERT-AT"
     "VECTOR"
     "(DEFMETHOD INSERT-AT ((SELF VECTOR) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "RESIZE-VECTOR"
     "VECTOR"
     "(DEFUN RESIZE-VECTOR ((SELF VECTOR) (SIZE INTEGER)) :DOCUMENTATION \"Increase the size of 'self' to 'size'.\" :NATIVE? TRUE)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY"
        "VECTOR"
        "(DEFMETHOD (COPY (VECTOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)) :DOCUMENTATION \"Return a copy of the vector 'self'.\" :PUBLIC? TRUE)")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION COPY)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "CLEAR"
     "VECTOR"
     "(DEFMETHOD CLEAR ((SELF VECTOR)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "INSERT-AT"
     "EXTENSIBLE-VECTOR"
     "(DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-VECTOR) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "INSERT-AT"
     "EXTENSIBLE-SYMBOL-ARRAY"
     "(DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-SYMBOL-ARRAY) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "INSERT"
     "VECTOR-SEQUENCE"
     "(DEFMETHOD INSERT ((SELF VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Append 'value' to the END of the sequence 'self'.  
Resize the array if necessary.\" :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "REMOVE"
     "VECTOR-SEQUENCE"
     "(DEFMETHOD (REMOVE VECTOR-SEQUENCE) ((SELF VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Remove 'value' from the sequence 'self', and left shift
the values after it to close the gap.\" :NATIVE? TRUE)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LENGTH"
        "VECTOR-SEQUENCE"
        "(DEFMETHOD (LENGTH INTEGER) ((SELF VECTOR-SEQUENCE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LENGTH)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "UNMAKE"
     "UNKNOWN"
     "(DEFUN UNMAKE ((SELF UNKNOWN)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "OPEN-NATIVE-STREAM?"
     "STREAM"
     "(DEFUN (OPEN-NATIVE-STREAM? BOOLEAN) ((STREAM STREAM)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "CLOSE-NATIVE-STREAM?"
     "STREAM"
     "(DEFUN (CLOSE-NATIVE-STREAM? BOOLEAN) ((STREAM STREAM)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "READ-S-EXPRESSION"
     "NATIVE-INPUT-STREAM"
     "(DEFUN (READ-S-EXPRESSION OBJECT BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "READ-LINE"
     "NATIVE-INPUT-STREAM"
     "(DEFUN (READ-LINE STRING BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "READ-CHARACTER"
     "NATIVE-INPUT-STREAM"
     "(DEFUN (READ-CHARACTER CHARACTER BOOLEAN) ((STREAM NATIVE-INPUT-STREAM)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "PROBE-FILE?"
     "FILE-NAME"
     "(DEFUN (PROBE-FILE? BOOLEAN) ((FILENAME FILE-NAME)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "FILE-WRITE-DATE"
     "FILE-NAME"
     "(DEFUN (FILE-WRITE-DATE INTEGER) ((FILENAME FILE-NAME)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "FILE-LENGTH"
     "FILE-NAME"
     "(DEFUN (FILE-LENGTH INTEGER) ((FILENAME FILE-NAME)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "DELETE-FILE"
     "FILE-NAME"
     "(DEFUN DELETE-FILE ((FILENAME FILE-NAME)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "ALLOCATE-ITERATOR"
     "LISP-CONS"
     "(DEFMETHOD (ALLOCATE-ITERATOR LISP-CONS-ITERATOR) ((SELF LISP-CONS)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "NEXT?"
     "LISP-CONS-ITERATOR"
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF LISP-CONS-ITERATOR)) :NATIVE? TRUE)")
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-PRIMAL"
     NULL
     "(DEFUN STARTUP-PRIMAL ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT TRUE BOOLEAN (VERBATIM :COMMON-LISP 1 :CPP \"1\"))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT FALSE BOOLEAN (VERBATIM :COMMON-LISP 0 :CPP \"0\"))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(defconstant NULL UNKNOWN NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-BOOLEAN BOOLEAN (VERBATIM :COMMON-LISP CL:MOST-POSITIVE-FIXNUM :CPP \"-1\"))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-INTEGER INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"1 << (sizeof (int) / sizeof (char) * 8 - 1)\"))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-SHORT-INTEGER SHORT-INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"1 << (sizeof (short int) / sizeof (char) * 8 - 1)\"))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-LONG-INTEGER LONG-INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"1 << (sizeof (long int) / sizeof (char) * 8 - 1)\"))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-UNSIGNED-SHORT-INTEGER UNSIGNED-SHORT-INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"(unsigned short int) -1\"))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-UNSIGNED-LONG-INTEGER UNSIGNED-LONG-INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"(unsigned long int) -1\"))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-FLOAT FLOAT (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-DOUBLE-FLOAT :CPP \"-HUGE_VAL /* IEEE infinity, defined in <math.h> */\"))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-SINGLE-FLOAT SINGLE-FLOAT (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-SINGLE-FLOAT :CPP \"-HUGE_VAL /* IEEE infinity, defined in <math.h> */\"))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-DOUBLE-FLOAT DOUBLE-FLOAT NULL-FLOAT)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-CHARACTER CHARACTER (VERBATIM :COMMON-LISP (CL:CODE-CHAR 0) :CPP \"'\\\\0'\"))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT NULL-OCTET CHARACTER NULL-CHARACTER)")
    (REGISTER-NATIVE-NAME SYM-PRIMAL-FLOOR KWD-PRIMAL-CPP KWD-PRIMAL-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TRANSIENTOBJECTS?* BOOLEAN FALSE)")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-PRIMAL-*TRANSIENTOBJECTS?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*TRANSIENTOBJECTS?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*TRANSIENTOBJECTS?*)))))
  :VOID)
