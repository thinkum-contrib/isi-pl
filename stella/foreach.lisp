;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-FOREACH-AS NULL)
(CL:DEFVAR SYM-FOREACH-COMMA NULL)
(CL:DEFVAR SYM-FOREACH-DO NULL)
(CL:DEFVAR SYM-FOREACH-COLLECT NULL)
(CL:DEFVAR SGT-FOREACH-VOID NULL)
(CL:DEFVAR SYM-FOREACH-WHERE NULL)
(CL:DEFVAR SYM-FOREACH-INTO NULL)
(CL:DEFVAR SYM-FOREACH-COLLECT-INTO NULL)
(CL:DEFVAR SYM-FOREACH-PREFIX-FOREACH NULL)
(CL:DEFVAR SYM-FOREACH-IN NULL)
(CL:DEFVAR SYM-FOREACH-X NULL)
(CL:DEFVAR SYM-FOREACH-NIL NULL)
(CL:DEFVAR SYM-FOREACH-FOREACH NULL)
(CL:DEFVAR SYM-FOREACH-EXISTS NULL)
(CL:DEFVAR SYM-FOREACH-FORALL NULL)
(CL:DEFVAR SYM-FOREACH-SOME NULL)
(CL:DEFVAR SYM-FOREACH-SETOF NULL)
(CL:DEFVAR SYM-FOREACH-SET-OF NULL)
(CL:DEFVAR SYM-FOREACH-INTERVAL NULL)
(CL:DEFVAR SGT-FOREACH-INTEGER-INTERVAL NULL)
(CL:DEFVAR SGT-FOREACH-ABSTRACT-ITERATOR NULL)
(CL:DEFVAR SYM-FOREACH-ALLOCATE-ITERATOR NULL)
(CL:DEFVAR SYM-FOREACH-FALSE NULL)
(CL:DEFVAR SGT-FOREACH-STRING NULL)
(CL:DEFVAR SGT-FOREACH-VECTOR NULL)
(CL:DEFVAR SGT-FOREACH-LIST NULL)
(CL:DEFVAR SGT-FOREACH-CONS NULL)
(CL:DEFVAR SYM-FOREACH-THE-CONS-LIST NULL)
(CL:DEFVAR SGT-FOREACH-KEY-VALUE-LIST NULL)
(CL:DEFVAR SGT-FOREACH-KV-CONS NULL)
(CL:DEFVAR SYM-FOREACH-THE-KV-LIST NULL)
(CL:DEFVAR SGT-FOREACH-PROPERTY-LIST NULL)
(CL:DEFVAR SYM-FOREACH-THE-PLIST NULL)
(CL:DEFVAR SYM-FOREACH-KEY NULL)
(CL:DEFVAR SYM-FOREACH-VALUE NULL)
(CL:DEFVAR SYM-FOREACH-SETQ NULL)
(CL:DEFVAR SYM-FOREACH-REST NULL)
(CL:DEFVAR SYM-FOREACH-NOT NULL)
(CL:DEFVAR SYM-FOREACH-NIL? NULL)
(CL:DEFVAR SYM-FOREACH-DEFINED? NULL)
(CL:DEFVAR SYM-FOREACH-NEXT? NULL)
(CL:DEFVAR SYM-FOREACH-PROGN NULL)
(CL:DEFVAR SYM-FOREACH-ANY-VALUE NULL)
(CL:DEFVAR SYM-FOREACH-ANY-KEY NULL)
(CL:DEFVAR SYM-FOREACH-NULL NULL)
(CL:DEFVAR SYM-FOREACH-NULL-INTEGER NULL)
(CL:DEFVAR SGT-FOREACH-NUMBER-WRAPPER NULL)
(CL:DEFVAR SGT-FOREACH-INTEGER NULL)
(CL:DEFVAR SGT-FOREACH-BOOLEAN NULL)
(CL:DEFVAR SYM-FOREACH-NULL? NULL)
(CL:DEFVAR SYM-FOREACH-++ NULL)
(CL:DEFVAR SYM-FOREACH-TRUE NULL)
(CL:DEFVAR SYM-FOREACH-<= NULL)
(CL:DEFVAR SYM-FOREACH-OR NULL)
(CL:DEFVAR SYM-FOREACH-LENGTH NULL)
(CL:DEFVAR SYM-FOREACH-NTH NULL)
(CL:DEFVAR SGT-FOREACH-CHARACTER NULL)
(CL:DEFVAR SYM-FOREACH-< NULL)
(CL:DEFVAR SYM-FOREACH-ON NULL)
(CL:DEFVAR SYM-FOREACH-AND NULL)
(CL:DEFVAR SYM-FOREACH-IF NULL)
(CL:DEFVAR SYM-FOREACH-PERMANENT-CONS NULL)
(CL:DEFVAR SYM-FOREACH-EMPTY? NULL)
(CL:DEFVAR SYM-FOREACH-SETF NULL)
(CL:DEFVAR SYM-FOREACH-ADD-CONS-TO-END-OF-CONS-LIST NULL)
(CL:DEFVAR SYM-FOREACH-CONS NULL)
(CL:DEFVAR SGT-FOREACH-UNKNOWN NULL)
(CL:DEFVAR SYM-FOREACH-COND NULL)
(CL:DEFVAR SYM-FOREACH-CONS? NULL)
(CL:DEFVAR SYM-FOREACH-OTHERWISE NULL)
(CL:DEFVAR SYM-FOREACH-WHEN NULL)
(CL:DEFVAR SYM-FOREACH-SYS-FOREACH NULL)
(CL:DEFVAR SYM-FOREACH-VRLET NULL)
(CL:DEFVAR SYM-FOREACH-BREAK NULL)
(CL:DEFVAR SYM-FOREACH-ALWAYS NULL)
(CL:DEFVAR SYM-FOREACH-DEFUN NULL)
(CL:DEFVAR SYM-FOREACH-BOOLEAN NULL)
(CL:DEFVAR SYM-FOREACH-SELF NULL)
(CL:DEFVAR SYM-FOREACH-ALL-PURPOSE-ITERATOR NULL)
(CL:DEFVAR SYM-FOREACH-LET NULL)
(CL:DEFVAR SYM-FOREACH-NESTEDITERATOR NULL)
(CL:DEFVAR SYM-FOREACH-ITERATOR-NESTED-ITERATOR NULL)
(CL:DEFVAR SYM-FOREACH-WHILE NULL)
(CL:DEFVAR SYM-FOREACH-RETURN NULL)
(CL:DEFVAR SYM-FOREACH-NEW NULL)
(CL:DEFVAR SYM-FOREACH-ITERATOR-NEXT-CODE NULL)
(CL:DEFVAR SYM-FOREACH-THE-CODE NULL)
(CL:DEFVAR KWD-FOREACH-FUNCTION NULL)
(CL:DEFVAR SGT-FOREACH-ALL-PURPOSE-ITERATOR NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *STELLA-MODULE*
  *MODULE*
  *SPECIALVARIABLESTACK*
  STANDARD-OUTPUT
  EOL))

;;; (DEFUN (EXTRACT-ONE-IN-CLAUSE CONS CONS) ...)

(CL:DEFUN EXTRACT-ONE-IN-CLAUSE (TAIL)
  (CL:LET*
   ((VARIABLE (FIRST TAIL)) (OPERATOR (SECOND TAIL)) (CLAUSE TAIL))
   (CL:WHEN
    (CL:NOT
     (CL:AND
      (CL:OR (CL:EQ (SYMBOL? VARIABLE) 1) (CL:EQ (CONS? VARIABLE) 1))
      (CL:EQ
       (MEMBER?
        (GET-QUOTED-TREE "((IN ON ISA) \"/STELLA\")" "/STELLA")
        OPERATOR)
       1)
      (CL:NOT (CL:EQ (THIRD TAIL) NULL))))
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING
        " Illegal syntax where 'IN', 'ON', or 'ISA' clause expected:"
        %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING "   `" %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE TAIL) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (CL:RETURN-FROM EXTRACT-ONE-IN-CLAUSE (CL:VALUES NULL NIL)))
   (FIRST-SETTER CLAUSE OPERATOR)
   (SECOND-SETTER CLAUSE VARIABLE)
   (CL:SETQ
    TAIL
    (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TAIL))))
   (CL:SETF
    (CLSYS-SVAL
     CONS
     REST
     (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST CLAUSE)))
    NIL)
   (CL:RETURN-FROM EXTRACT-ONE-IN-CLAUSE (CL:VALUES CLAUSE TAIL)))
  :VOID)

;;; (DEFUN (EXTRACT-ONE-GENERATOR-TERM CONS CONS) ...)

(CL:DEFUN EXTRACT-ONE-GENERATOR-TERM (TAIL)
  (CL:LET*
   ((INCLAUSE NULL) (RESIDUE NULL) (PARALLELTERMS NULL) (TEMP NULL))
   (CL:MULTIPLE-VALUE-SETQ (INCLAUSE RESIDUE) (EXTRACT-ONE-IN-CLAUSE TAIL))
   (CL:WHEN
    (CL:NOT (CL:EQ (FIRST RESIDUE) SYM-FOREACH-AS))
    (CL:RETURN-FROM EXTRACT-ONE-GENERATOR-TERM (CL:VALUES INCLAUSE RESIDUE)))
   (CL:SETQ PARALLELTERMS (CONS INCLAUSE (CONS SYM-FOREACH-AS NIL)))
   (CL:LOOP
    WHILE
    (CL:EQ (FIRST RESIDUE) SYM-FOREACH-AS)
    DO
    (CL:SETQ TEMP RESIDUE)
    (CL:SETQ RESIDUE (CLSYS-SVAL CONS REST RESIDUE))
    (FREE-CONS TEMP)
    (CL:MULTIPLE-VALUE-SETQ
     (INCLAUSE RESIDUE)
     (EXTRACT-ONE-IN-CLAUSE RESIDUE))
    (CL:SETQ PARALLELTERMS (CONS INCLAUSE PARALLELTERMS)))
   (CL:RETURN-FROM
    EXTRACT-ONE-GENERATOR-TERM
    (CL:VALUES (REVERSE PARALLELTERMS) RESIDUE)))
  :VOID)

;;; (DEFUN (EXTRACT-GENERATORS-CLAUSE CONS CONS) ...)

(CL:DEFUN EXTRACT-GENERATORS-CLAUSE (TAIL)
  (CL:LET*
   ((GENERATORTERM NULL) (RESIDUE NULL) (GENERATORSCLAUSE NULL))
   (CL:MULTIPLE-VALUE-SETQ
    (GENERATORTERM RESIDUE)
    (EXTRACT-ONE-GENERATOR-TERM TAIL))
   (CL:WHEN
    (CL:NOT (CL:EQ (FIRST RESIDUE) SYM-FOREACH-COMMA))
    (CL:RETURN-FROM
     EXTRACT-GENERATORS-CLAUSE
     (CL:VALUES GENERATORTERM RESIDUE)))
   (CL:SETQ
    GENERATORSCLAUSE
    (CONS GENERATORTERM (CONS SYM-FOREACH-COMMA NIL)))
   (CL:LOOP
    WHILE
    (CL:EQ (FIRST RESIDUE) SYM-FOREACH-COMMA)
    DO
    (CL:MULTIPLE-VALUE-SETQ
     (GENERATORTERM RESIDUE)
     (EXTRACT-ONE-GENERATOR-TERM (CLSYS-SVAL CONS REST RESIDUE)))
    (CL:SETQ GENERATORSCLAUSE (CONS GENERATORTERM GENERATORSCLAUSE)))
   (CL:RETURN-FROM
    EXTRACT-GENERATORS-CLAUSE
    (CL:VALUES (REVERSE GENERATORSCLAUSE) RESIDUE)))
  :VOID)

;;; (DEFUN (EXTRACT-OPTION-AND-RESIDUE OBJECT CONS) ...)

(CL:DEFUN EXTRACT-OPTION-AND-RESIDUE (OPTION TAIL)
  (CL:WHEN
   (CL:NOT (CL:EQ (FIRST TAIL) OPTION))
   (CL:RETURN-FROM EXTRACT-OPTION-AND-RESIDUE (CL:VALUES NULL TAIL)))
  (CL:LET*
   ((ARGUMENT NULL) (RESIDUE NULL))
   (CL:SETQ ARGUMENT (SECOND TAIL))
   (CL:SETQ RESIDUE (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TAIL)))
   (CL:SETF (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TAIL)) NIL)
   (FREE-CONS-LIST TAIL)
   (CL:RETURN-FROM EXTRACT-OPTION-AND-RESIDUE (CL:VALUES ARGUMENT RESIDUE)))
  :VOID)

;;; (DEFUN (EXTRACT-DO-CLAUSE CONS CONS) ...)

(CL:DEFUN EXTRACT-DO-CLAUSE (TAIL)
  (CL:WHEN
   (CL:NOT (CL:EQ (FIRST TAIL) SYM-FOREACH-DO))
   (CL:RETURN-FROM EXTRACT-DO-CLAUSE (CL:VALUES NULL TAIL)))
  (CL:LET*
   ((DOCLAUSE TAIL) (LASTDOCONS NULL))
   (CL:SETQ TAIL (CLSYS-SVAL CONS REST TAIL))
   (CL:LOOP
    WHILE
    (CL:AND
     (CL:NOT (CL:EQ TAIL NIL))
     (CL:NOT (CL:EQ (FIRST TAIL) SYM-FOREACH-COLLECT)))
    DO
    (CL:SETQ LASTDOCONS TAIL)
    (CL:SETQ TAIL (CLSYS-SVAL CONS REST TAIL)))
   (CL:IF
    (CL:EQ LASTDOCONS NULL)
    (CL:PROGN
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING " Missing arguments to DO separator." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     (CL:SETF
      (CLSYS-SVAL CONS REST DOCLAUSE)
      (CONS-LIST (WALK-DONT-CALL-ME-TREE NIL SGT-FOREACH-VOID))))
    (CL:SETF (CLSYS-SVAL CONS REST LASTDOCONS) NIL))
   (CL:RETURN-FROM EXTRACT-DO-CLAUSE (CL:VALUES DOCLAUSE TAIL)))
  :VOID)

;;; (DEFUN (FOREACH-TO-PREFIX-FOREACH-TREE CONS) ...)

(CL:DEFUN FOREACH-TO-PREFIX-FOREACH-TREE (FOREACHTREE)
  (CL:LET*
   ((GENERATORSCLAUSE NULL)
    (FILTERCLAUSE NULL)
    (DOCLAUSE NULL)
    (COLLECTCLAUSE NULL)
    (INTOCLAUSE NULL)
    (RESIDUE (CLSYS-SVAL CONS REST FOREACHTREE))
    (OTREE NULL))
   (FREE-CONS FOREACHTREE)
   (CL:MULTIPLE-VALUE-SETQ
    (GENERATORSCLAUSE RESIDUE)
    (EXTRACT-GENERATORS-CLAUSE RESIDUE))
   (CL:WHEN
    (CL:EQ GENERATORSCLAUSE NULL)
    (FREE-CONS-TREE RESIDUE)
    (CL:RETURN-FROM FOREACH-TO-PREFIX-FOREACH-TREE NULL))
   (CL:MULTIPLE-VALUE-SETQ
    (FILTERCLAUSE RESIDUE)
    (EXTRACT-OPTION-AND-RESIDUE SYM-FOREACH-WHERE RESIDUE))
   (CL:WHEN
    (CL:NOT (CL:EQ FILTERCLAUSE NULL))
    (CL:SETQ FILTERCLAUSE (LIST* SYM-FOREACH-WHERE FILTERCLAUSE NIL)))
   (CL:MULTIPLE-VALUE-SETQ (DOCLAUSE RESIDUE) (EXTRACT-DO-CLAUSE RESIDUE))
   (CL:MULTIPLE-VALUE-SETQ
    (COLLECTCLAUSE RESIDUE)
    (EXTRACT-OPTION-AND-RESIDUE SYM-FOREACH-COLLECT RESIDUE))
   (CL:MULTIPLE-VALUE-SETQ
    (INTOCLAUSE RESIDUE)
    (EXTRACT-OPTION-AND-RESIDUE SYM-FOREACH-INTO RESIDUE))
   (CL:WHEN
    (CL:OR
     (CL:NOT (CL:EQ COLLECTCLAUSE NULL))
     (CL:NOT (CL:EQ INTOCLAUSE NULL)))
    (CL:SETQ
     COLLECTCLAUSE
     (LIST* SYM-FOREACH-COLLECT-INTO COLLECTCLAUSE (CONS INTOCLAUSE NIL))))
   (CL:SETQ
    OTREE
    (LIST*
     SYM-FOREACH-PREFIX-FOREACH
     GENERATORSCLAUSE
     (CONCATENATE
      (CL:IF (CL:NOT (CL:EQ FILTERCLAUSE NULL)) (CONS FILTERCLAUSE NIL) NIL)
      (CONCATENATE
       (CL:IF (CL:NOT (CL:EQ DOCLAUSE NULL)) (CONS DOCLAUSE NIL) NIL)
       (CONCATENATE
        (CL:IF
         (CL:NOT (CL:EQ COLLECTCLAUSE NULL))
         (CONS COLLECTCLAUSE NIL)
         NIL)
        NIL)))))
   (CL:WHEN
    (CL:OR
     (CL:AND (CL:NOT (CL:EQ COLLECTCLAUSE NULL)) (CL:EQ INTOCLAUSE NULL))
     (CL:AND (CL:NOT (CL:EQ INTOCLAUSE NULL)) (CL:EQ COLLECTCLAUSE NULL)))
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Missing COLLECT or INTO clause in." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (FREE-CONS-TREE OTREE)
    (CL:RETURN-FROM FOREACH-TO-PREFIX-FOREACH-TREE NIL))
   (CL:WHEN
    (CL:NOT (CL:EQ RESIDUE NIL))
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING
        " Extra expressions at the end of foreach statement:."
        %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (FREE-CONS-TREE RESIDUE)
    (CL:RETURN-FROM
     FOREACH-TO-PREFIX-FOREACH-TREE
     (LIST*
      SYM-FOREACH-PREFIX-FOREACH
      (LIST* SYM-FOREACH-IN SYM-FOREACH-X SYM-FOREACH-NIL NIL)
      (LIST*
       SYM-FOREACH-DO
       (WALK-DONT-CALL-ME-TREE OTREE SGT-FOREACH-VOID)
       NIL)
      NIL)))
   (CL:RETURN-FROM FOREACH-TO-PREFIX-FOREACH-TREE OTREE))
  :VOID)

;;; (DEFUN (WALK-FOREACH-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-FOREACH-TREE (TREE)
  (CL:LET*
   ((*NOFSPECIALSATLOOPENTRY* (LENGTH *SPECIALVARIABLESTACK*)))
   (CL:DECLARE (CL:SPECIAL *NOFSPECIALSATLOOPENTRY*))
   (CL:LET*
    ((TEST-VALUE-001 (FIRST TREE)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 SYM-FOREACH-FOREACH)
      (CL:RETURN-FROM
       WALK-FOREACH-TREE
       (WALK-PREFIX-FOREACH-TREE (FOREACH-TO-PREFIX-FOREACH-TREE TREE))))
     ((CL:EQ TEST-VALUE-001 SYM-FOREACH-EXISTS)
      (CL:RETURN-FROM WALK-FOREACH-TREE (WALK-EXISTS-TREE TREE)))
     ((CL:EQ TEST-VALUE-001 SYM-FOREACH-FORALL)
      (CL:RETURN-FROM WALK-FOREACH-TREE (WALK-FORALL-TREE TREE)))
     ((CL:EQ TEST-VALUE-001 SYM-FOREACH-SOME)
      (CL:RETURN-FROM WALK-FOREACH-TREE (WALK-SOME-TREE TREE)))
     ((CL:OR
       (CL:EQ TEST-VALUE-001 SYM-FOREACH-SETOF)
       (CL:EQ TEST-VALUE-001 SYM-FOREACH-SET-OF))
      (CL:RETURN-FROM WALK-FOREACH-TREE (WALK-SETOF-TREE TREE)))
     (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001)))))
  :VOID)

;;; (DEFUN (WALK-COLLECTION-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-COLLECTION-TREE (TREE DONTOPTIMIZE?)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:WHEN
       (CL:AND
        (CL:EQ DONTOPTIMIZE? 0)
        (CL:EQ (FIRST TREE) SYM-FOREACH-INTERVAL)
        (CL:= (LENGTH TREE) 3))
       (CL:RETURN-FROM
        WALK-COLLECTION-TREE
        (CL:VALUES TREE SGT-FOREACH-INTEGER-INTERVAL)))))
    (CL:T NULL)))
  (CL:RETURN-FROM WALK-COLLECTION-TREE (WALK-A-TREE TREE))
  :VOID)

;;; (DEFUN (YIELD-IN-CURSOR-CLAUSES CONS CONS OBJECT) ...)

(CL:DEFUN YIELD-IN-CURSOR-CLAUSES (INTREE DONTOPTIMIZE?)
  (CL:LET*
   ((VARTREE (SECOND INTREE))
    (KEYVAR NULL)
    (VALUEVAR NULL)
    (COLLECTIONBASETYPE NULL))
   (CL:LET*
    ((COLLECTIONTREE NULL) (COLLECTIONTYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (COLLECTIONTREE COLLECTIONTYPE)
     (WALK-COLLECTION-TREE (THIRD INTREE) DONTOPTIMIZE?))
    (THIRD-SETTER INTREE NULL)
    (CL:SETQ COLLECTIONBASETYPE (TYPE-SPEC-TO-BASE-TYPE COLLECTIONTYPE))
    (CL:WHEN
     (CL:AND
      (CL:EQ DONTOPTIMIZE? 1)
      (CL:EQ
       (SAFE-SUBTYPE-OF? COLLECTIONBASETYPE SGT-FOREACH-ABSTRACT-ITERATOR)
       0))
     (CL:MULTIPLE-VALUE-SETQ
      (COLLECTIONTREE COLLECTIONTYPE)
      (WALK-COLLECTION-TREE
       (LIST* SYM-FOREACH-ALLOCATE-ITERATOR COLLECTIONTREE NIL)
       TRUE))
     (CL:SETQ COLLECTIONBASETYPE (TYPE-SPEC-TO-BASE-TYPE COLLECTIONTYPE)))
    (CL:LET*
     ((VARTREE-001 VARTREE))
     (CL:COND
      ((CL:EQ (CONS? VARTREE) 1)
       (CL:LET*
        ((VARTREE NULL))
        (CL:SETQ VARTREE VARTREE-001)
        (CL:WHEN
         (CL:NOT (CL:= (LENGTH VARTREE) 2))
         (CL:LET*
          ((*PRINTREADABLY?* TRUE))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN
           (CL:EQ (SUPPRESS-WARNINGS?) 0)
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
           (CL:LET
            ((%%STREAM
              (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM)
            (CL:WRITE-STRING
             " Illegal number of variables in IN clause: `"
             %%STREAM)
            (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE INTREE) %%STREAM)
            (CL:WRITE-STRING "'." %%STREAM)
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM))))
         (CL:RETURN-FROM
          YIELD-IN-CURSOR-CLAUSES
          (CL:VALUES NIL NIL SYM-FOREACH-FALSE)))
        (CL:SETQ KEYVAR (FIRST VARTREE))
        (CL:SETQ VALUEVAR (SECOND VARTREE))))
      (CL:T (CL:SETQ VALUEVAR VARTREE))))
    (CL:COND
     ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-INTEGER-INTERVAL)
      (CL:RETURN-FROM
       YIELD-IN-CURSOR-CLAUSES
       (YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL
        COLLECTIONTREE
        COLLECTIONTYPE
        KEYVAR
        VALUEVAR)))
     (CL:T
      (CL:IF
       (CL:OR
        (CL:EQ COLLECTIONBASETYPE SGT-FOREACH-STRING)
        (CL:EQ (SAFE-SUBTYPE-OF? COLLECTIONBASETYPE SGT-FOREACH-VECTOR) 1))
       (CL:RETURN-FROM
        YIELD-IN-CURSOR-CLAUSES
        (YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR
         COLLECTIONTREE
         COLLECTIONTYPE
         KEYVAR
         VALUEVAR))
       (CL:RETURN-FROM
        YIELD-IN-CURSOR-CLAUSES
        (YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION
         COLLECTIONTREE
         COLLECTIONTYPE
         KEYVAR
         VALUEVAR)))))))
  :VOID)

;;; (DEFUN (YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION CONS CONS OBJECT) ...)

(CL:DEFUN YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION (COLLECTIONTREE COLLECTIONTYPE KEYVAR VALUEVAR)
  (CL:LET*
   ((COLLECTIONBASETYPE (TYPE-SPEC-TO-BASE-TYPE COLLECTIONTYPE))
    (ITERATORVAR (LOCAL-GENSYM "ITER"))
    (ITERATORCLAUSES NIL)
    (VALUECLAUSES NIL)
    (CONTINUATIONTEST NULL)
    (KEYTREE NIL)
    (VALUETREE NIL)
    (BUMPTREES NIL))
   (CL:COND
    ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-LIST)
     (CL:SETQ
      ITERATORCLAUSES
      (CONS
       (CONS
        ITERATORVAR
        (LIST*
         SGT-FOREACH-CONS
         (LIST* SYM-FOREACH-THE-CONS-LIST COLLECTIONTREE NIL)
         NIL))
       NIL))
     (CL:SETQ COLLECTIONBASETYPE SGT-FOREACH-CONS))
    ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-KEY-VALUE-LIST)
     (CL:SETQ
      ITERATORCLAUSES
      (CONS
       (CONS
        ITERATORVAR
        (LIST*
         SGT-FOREACH-KV-CONS
         (LIST* SYM-FOREACH-THE-KV-LIST COLLECTIONTREE NIL)
         NIL))
       NIL))
     (CL:SETQ COLLECTIONBASETYPE SGT-FOREACH-KV-CONS))
    ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-PROPERTY-LIST)
     (CL:SETQ
      ITERATORCLAUSES
      (CONS
       (CONS
        ITERATORVAR
        (LIST*
         SGT-FOREACH-CONS
         (LIST* SYM-FOREACH-THE-PLIST COLLECTIONTREE NIL)
         NIL))
       NIL)))
    ((CL:OR
      (CL:EQ COLLECTIONBASETYPE SGT-FOREACH-CONS)
      (CL:EQ COLLECTIONBASETYPE SGT-FOREACH-KV-CONS))
     (CL:SETQ
      ITERATORCLAUSES
      (CONS
       (CONS ITERATORVAR (CONS COLLECTIONBASETYPE (CONS COLLECTIONTREE NIL)))
       NIL)))
    (CL:T
     (CL:WHEN
      (CL:EQ
       (SAFE-SUBTYPE-OF? COLLECTIONBASETYPE SGT-FOREACH-ABSTRACT-ITERATOR)
       0)
      (CL:SETQ
       COLLECTIONTREE
       (LIST* SYM-FOREACH-ALLOCATE-ITERATOR COLLECTIONTREE NIL)))
     (CL:SETQ
      ITERATORCLAUSES
      (CONS
       (CONS
        ITERATORVAR
        (LIST* SGT-FOREACH-ABSTRACT-ITERATOR COLLECTIONTREE NIL))
       NIL))
     (CL:SETQ COLLECTIONBASETYPE SGT-FOREACH-ABSTRACT-ITERATOR)))
   (CL:WHEN
    (CL:NOT (CL:EQ KEYVAR NULL))
    (CL:SETQ KEYTREE (LIST* SYM-FOREACH-KEY ITERATORVAR NIL)))
   (CL:SETQ VALUETREE (LIST* SYM-FOREACH-VALUE ITERATORVAR NIL))
   (CL:COND
    ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-CONS)
     (CL:SETQ
      BUMPTREES
      (CONS
       (LIST*
        SYM-FOREACH-SETQ
        ITERATORVAR
        (CONS (LIST* SYM-FOREACH-REST ITERATORVAR NIL) NIL))
       NIL))
     (CL:SETQ
      CONTINUATIONTEST
      (LIST* SYM-FOREACH-NOT (LIST* SYM-FOREACH-NIL? ITERATORVAR NIL) NIL)))
    ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-KV-CONS)
     (CL:SETQ
      BUMPTREES
      (CONS
       (LIST*
        SYM-FOREACH-SETQ
        ITERATORVAR
        (CONS (LIST* SYM-FOREACH-REST ITERATORVAR NIL) NIL))
       NIL))
     (CL:SETQ CONTINUATIONTEST (LIST* SYM-FOREACH-DEFINED? ITERATORVAR NIL)))
    ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-PROPERTY-LIST)
     (CL:WHEN
      (CL:NOT (CL:EQ KEYVAR NULL))
      (CL:SETQ KEYTREE (LIST* SYM-FOREACH-VALUE ITERATORVAR NIL)))
     (CL:SETQ
      VALUETREE
      (LIST* SYM-FOREACH-VALUE (LIST* SYM-FOREACH-REST ITERATORVAR NIL) NIL))
     (CL:SETQ
      BUMPTREES
      (CONS
       (LIST*
        SYM-FOREACH-SETQ
        ITERATORVAR
        (CONS
         (LIST* SYM-FOREACH-REST (LIST* SYM-FOREACH-REST ITERATORVAR NIL) NIL)
         NIL))
       NIL))
     (CL:SETQ
      CONTINUATIONTEST
      (LIST* SYM-FOREACH-NOT (LIST* SYM-FOREACH-NIL? ITERATORVAR NIL) NIL)))
    ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-ABSTRACT-ITERATOR)
     (CL:SETQ BUMPTREES NIL)
     (CL:SETQ CONTINUATIONTEST (LIST* SYM-FOREACH-NEXT? ITERATORVAR NIL)))
    (CL:T (CL:ERROR "`~A' is not a valid case option" COLLECTIONBASETYPE)))
   (CL:SETQ
    VALUECLAUSES
    (CONS
     (CONS
      VALUEVAR
      (CONS
       (EXTRACT-PARAMETER-TYPE COLLECTIONTYPE SYM-FOREACH-ANY-VALUE)
       (CONS
        (LIST*
         SYM-FOREACH-PROGN
         (LIST* SYM-FOREACH-SETQ VALUEVAR (CONS VALUETREE NIL))
         (CONCATENATE BUMPTREES NIL))
        NIL)))
     VALUECLAUSES))
   (CL:WHEN
    (CL:NOT (CL:EQ KEYVAR NULL))
    (CL:LET*
     ((KEYTYPE NULL) (PARAMETEREXISTS? FALSE))
     (CL:MULTIPLE-VALUE-SETQ
      (KEYTYPE PARAMETEREXISTS?)
      (EXTRACT-PARAMETER-TYPE COLLECTIONTYPE SYM-FOREACH-ANY-KEY))
     (CL:COND
      ((CL:EQ PARAMETEREXISTS? 1)
       (CL:SETQ
        VALUECLAUSES
        (CONS
         (CONS
          KEYVAR
          (CONS
           KEYTYPE
           (CONS (LIST* SYM-FOREACH-SETQ KEYVAR (CONS KEYTREE NIL)) NIL)))
         VALUECLAUSES)))
      (CL:T
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN
         (CL:EQ (SUPPRESS-WARNINGS?) 0)
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:WRITE-STRING
           " Illegal key variable specified for keyless collection `"
           %%STREAM)
          (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE COLLECTIONTYPE) %%STREAM)
          (CL:WRITE-STRING "'." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))))
       (CL:RETURN-FROM
        YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION
        (CL:VALUES NIL NIL SYM-FOREACH-FALSE))))))
   (CL:RETURN-FROM
    YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION
    (CL:VALUES ITERATORCLAUSES VALUECLAUSES CONTINUATIONTEST)))
  :VOID)

;;; (DEFUN (YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL CONS CONS OBJECT) ...)

(CL:DEFUN YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL (COLLECTIONTREE COLLECTIONTYPE KEYVAR VALUEVAR)
  (CL:SETQ COLLECTIONTYPE COLLECTIONTYPE)
  (CL:WHEN
   (CL:NOT (CL:EQ KEYVAR NULL))
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING
       " Illegal key variable specified for INTEGER-INTERVAL."
       %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))))
   (CL:RETURN-FROM
    YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL
    (CL:VALUES NIL NIL SYM-FOREACH-FALSE)))
  (CL:LET*
   ((UPPERBOUND (THIRD COLLECTIONTREE))
    (KNOWNUNBOUNDED?
     (CL:IF
      (CL:OR
       (CL:EQ UPPERBOUND SYM-FOREACH-NULL)
       (CL:EQ UPPERBOUND SYM-FOREACH-NULL-INTEGER))
      TRUE
      FALSE))
    (KNOWNBOUNDED?
     (CL:IF
      (CL:AND
       (CL:EQ KNOWNUNBOUNDED? 0)
       (CL:OR
        (CL:EQ (ISA? UPPERBOUND SGT-FOREACH-NUMBER-WRAPPER) 1)
        (CL:AND
         (CL:EQ (CONS? UPPERBOUND) 1)
         (CL:EQ
          (MEMBER?
           (GET-QUOTED-TREE
            "((+ - * |/| 1+ 1- ++ -- LENGTH) \"/STELLA\")"
            "/STELLA")
           (FIRST UPPERBOUND))
          1))))
      TRUE
      FALSE))
    (ITERATORVAR (LOCAL-GENSYM "ITER"))
    (UPPERBOUNDVAR
     (CL:IF (CL:EQ KNOWNUNBOUNDED? 1) NULL (LOCAL-GENSYM "UPPER-BOUND")))
    (UNBOUNDEDVAR
     (CL:IF
      (CL:OR (CL:EQ KNOWNUNBOUNDED? 1) (CL:EQ KNOWNBOUNDED? 1))
      NULL
      (LOCAL-GENSYM "UNBOUNDED?"))))
   (CL:RETURN-FROM
    YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL
    (CL:VALUES
     (CONS
      (CONS
       ITERATORVAR
       (LIST* SGT-FOREACH-INTEGER (SECOND COLLECTIONTREE) NIL))
      (CONCATENATE
       (CL:IF
        (CL:EQ KNOWNUNBOUNDED? 1)
        NIL
        (CONS
         (CONS UPPERBOUNDVAR (LIST* SGT-FOREACH-INTEGER UPPERBOUND NIL))
         NIL))
       (CONCATENATE
        (CL:IF
         (CL:OR (CL:EQ KNOWNUNBOUNDED? 1) (CL:EQ KNOWNBOUNDED? 1))
         NIL
         (CONS
          (CONS
           UNBOUNDEDVAR
           (LIST*
            SGT-FOREACH-BOOLEAN
            (LIST* SYM-FOREACH-NULL? UPPERBOUNDVAR NIL)
            NIL))
          NIL))
        NIL)))
     (CONS
      (CONS
       VALUEVAR
       (LIST*
        SGT-FOREACH-INTEGER
        (LIST*
         SYM-FOREACH-PROGN
         (LIST* SYM-FOREACH-SETQ VALUEVAR (CONS ITERATORVAR NIL))
         (LIST* SYM-FOREACH-++ ITERATORVAR NIL)
         NIL)
        NIL))
      NIL)
     (CL:IF
      (CL:EQ KNOWNUNBOUNDED? 1)
      SYM-FOREACH-TRUE
      (CL:IF
       (CL:EQ KNOWNBOUNDED? 1)
       (LIST* SYM-FOREACH-<= ITERATORVAR (CONS UPPERBOUNDVAR NIL))
       (LIST*
        SYM-FOREACH-OR
        UNBOUNDEDVAR
        (CONS
         (LIST* SYM-FOREACH-<= ITERATORVAR (CONS UPPERBOUNDVAR NIL))
         NIL)))))))
  :VOID)

;;; (DEFUN (YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR CONS CONS OBJECT) ...)

(CL:DEFUN YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR (COLLECTIONTREE COLLECTIONTYPE KEYVAR VALUEVAR)
  (CL:WHEN
   (CL:NOT (CL:EQ KEYVAR NULL))
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN
     (CL:EQ (SUPPRESS-WARNINGS?) 0)
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING " Illegal key variable specified for `" %%STREAM)
      (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE COLLECTIONTYPE) %%STREAM)
      (CL:WRITE-STRING "'." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))))
   (CL:RETURN-FROM
    YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR
    (CL:VALUES NIL NIL SYM-FOREACH-FALSE)))
  (CL:LET*
   ((VECTORVAR (LOCAL-GENSYM "VECTOR"))
    (INDEXVAR (LOCAL-GENSYM "INDEX"))
    (LENGTHVAR (LOCAL-GENSYM "LENGTH")))
   (CL:RETURN-FROM
    YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR
    (CL:VALUES
     (LIST*
      (CONS VECTORVAR (CONS COLLECTIONTYPE (CONS COLLECTIONTREE NIL)))
      (CONS INDEXVAR (LIST* SGT-FOREACH-INTEGER (WRAP-LITERAL 0) NIL))
      (CONS
       LENGTHVAR
       (LIST*
        SGT-FOREACH-INTEGER
        (LIST* SYM-FOREACH-LENGTH VECTORVAR NIL)
        NIL))
      NIL)
     (CONS
      (CONS
       VALUEVAR
       (CONS
        (CL:IF
         (CL:EQ COLLECTIONTYPE SGT-FOREACH-STRING)
         SGT-FOREACH-CHARACTER
         (EXTRACT-PARAMETER-TYPE COLLECTIONTYPE SYM-FOREACH-ANY-VALUE))
        (CONS
         (LIST*
          SYM-FOREACH-PROGN
          (LIST*
           SYM-FOREACH-SETQ
           VALUEVAR
           (CONS (LIST* SYM-FOREACH-NTH VECTORVAR (CONS INDEXVAR NIL)) NIL))
          (LIST* SYM-FOREACH-++ INDEXVAR NIL)
          NIL)
         NIL)))
      NIL)
     (LIST* SYM-FOREACH-< INDEXVAR (CONS LENGTHVAR NIL)))))
  :VOID)

;;; (DEFUN (YIELD-ON-CURSOR-CLAUSES CONS CONS OBJECT) ...)

(CL:DEFUN YIELD-ON-CURSOR-CLAUSES (ONTREE)
  (CL:LET*
   ((ITERATORVAR (SECOND ONTREE)))
   (CL:WHEN
    (CL:EQ (SYMBOL? ITERATORVAR) 0)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING
        " Illegal ON clause with non-atomic variable: `"
        %%STREAM)
       (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE ONTREE) %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))
    (CL:RETURN-FROM
     YIELD-ON-CURSOR-CLAUSES
     (CL:VALUES NIL NIL SYM-FOREACH-FALSE)))
   (CL:LET*
    ((COLLECTIONTREE NULL) (COLLECTIONTYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (COLLECTIONTREE COLLECTIONTYPE)
     (WALK-COLLECTION-TREE (THIRD ONTREE) TRUE))
    (THIRD-SETTER ONTREE NULL)
    (CL:WHEN
     (CL:EQ
      (SAFE-SUBTYPE-OF?
       (TYPE-SPEC-TO-BASE-TYPE COLLECTIONTYPE)
       SGT-FOREACH-ABSTRACT-ITERATOR)
      0)
     (CL:SETQ
      COLLECTIONTREE
      (LIST* SYM-FOREACH-ALLOCATE-ITERATOR COLLECTIONTREE NIL)))
    (CL:RETURN-FROM
     YIELD-ON-CURSOR-CLAUSES
     (CL:VALUES
      (CONS
       (CONS
        ITERATORVAR
        (LIST* SGT-FOREACH-ABSTRACT-ITERATOR COLLECTIONTREE NIL))
       NIL)
      NIL
      (LIST* SYM-FOREACH-NEXT? ITERATORVAR NIL)))))
  :VOID)

;;; (DEFUN (COLLECT-CURSOR-CLAUSES CONS CONS OBJECT) ...)

(CL:DEFUN COLLECT-CURSOR-CLAUSES (CURSORSTREE DONTOPTIMIZE?)
  (CL:LET*
   ((TEST-VALUE-001 (FIRST CURSORSTREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 SYM-FOREACH-IN)
     (CL:RETURN-FROM
      COLLECT-CURSOR-CLAUSES
      (YIELD-IN-CURSOR-CLAUSES CURSORSTREE DONTOPTIMIZE?)))
    ((CL:EQ TEST-VALUE-001 SYM-FOREACH-ON)
     (CL:RETURN-FROM
      COLLECT-CURSOR-CLAUSES
      (YIELD-ON-CURSOR-CLAUSES CURSORSTREE)))
    ((CL:EQ TEST-VALUE-001 SYM-FOREACH-AS)
     (CL:LET*
      ((ALLITERATORCLAUSES NIL) (ALLVALUECLAUSES NIL) (CONTINUATIONTESTS NIL))
      (CL:LET*
       ((CLAUSE NULL) (ITER-001 (CLSYS-SVAL CONS REST CURSORSTREE)))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ CLAUSE (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:LET*
         ((ITERATORCLAUSES NULL) (VALUECLAUSES NULL) (CONTINUATIONTEST NULL))
         (CL:MULTIPLE-VALUE-SETQ
          (ITERATORCLAUSES VALUECLAUSES CONTINUATIONTEST)
          (COLLECT-CURSOR-CLAUSES CLAUSE DONTOPTIMIZE?))
         (CL:SETQ
          ALLITERATORCLAUSES
          (CONCATENATE ALLITERATORCLAUSES ITERATORCLAUSES))
         (CL:SETQ ALLVALUECLAUSES (CONCATENATE ALLVALUECLAUSES VALUECLAUSES))
         (CL:SETQ
          CONTINUATIONTESTS
          (CONS CONTINUATIONTEST CONTINUATIONTESTS)))))
      (CL:RETURN-FROM
       COLLECT-CURSOR-CLAUSES
       (CL:VALUES
        ALLITERATORCLAUSES
        ALLVALUECLAUSES
        (CL:IF
         (CL:= (LENGTH CONTINUATIONTESTS) 1)
         (FIRST CONTINUATIONTESTS)
         (CONS
          SYM-FOREACH-AND
          (CONCATENATE
           (REMOVE (REVERSE CONTINUATIONTESTS) SYM-FOREACH-TRUE)
           NIL)))))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
  :VOID)

;;; (DEFUN (WALK-CURSORS-TREE CONS CONS OBJECT) ...)

(CL:DEFUN WALK-CURSORS-TREE (CURSORSTREE DONTOPTIMIZE?)
  (CL:LET*
   ((ITERATORCLAUSES NULL) (VALUECLAUSES NULL) (CONTINUATIONTEST NULL))
   (CL:MULTIPLE-VALUE-SETQ
    (ITERATORCLAUSES VALUECLAUSES CONTINUATIONTEST)
    (COLLECT-CURSOR-CLAUSES CURSORSTREE DONTOPTIMIZE?))
   (CL:LET*
    ((CLAUSE NULL) (ITER-001 ITERATORCLAUSES))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ CLAUSE (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:LET*
      ((ITERATORTREE NULL) (ITERATORTYPE NULL))
      (CL:MULTIPLE-VALUE-SETQ
       (ITERATORTREE ITERATORTYPE)
       (WALK-EXPRESSION-TREE
        (THIRD CLAUSE)
        (SECOND CLAUSE)
        SYM-FOREACH-FOREACH
        FALSE))
      (SECOND-SETTER CLAUSE ITERATORTYPE)
      (THIRD-SETTER
       CLAUSE
       (COERCE-A-TREE ITERATORTREE ITERATORTYPE ITERATORTYPE)))
     (PUSH-VARIABLE-BINDING
      (FIRST CLAUSE)
      (TYPE-SPEC-TO-BASE-TYPE (SECOND CLAUSE)))))
   (CL:LET*
    ((CLAUSE NULL) (ITER-002 VALUECLAUSES))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ CLAUSE (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (PUSH-VARIABLE-BINDING
      (FIRST CLAUSE)
      (TYPE-SPEC-TO-BASE-TYPE (SECOND CLAUSE)))
     (THIRD-SETTER CLAUSE (WALK-WITHOUT-TYPE-TREE (THIRD CLAUSE)))))
   (CL:SETQ CONTINUATIONTEST (WALK-WITHOUT-TYPE-TREE CONTINUATIONTEST))
   (CL:LET*
    ((I NULL)
     (ITER-003 1)
     (UPPER-BOUND-001 (CL:+ (LENGTH ITERATORCLAUSES) (LENGTH VALUECLAUSES))))
    (CL:LOOP
     WHILE
     (CL:<= ITER-003 UPPER-BOUND-001)
     DO
     (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
     (CL:SETQ I I)
     (POP-VARIABLE-BINDING)))
   (CL:RETURN-FROM
    WALK-CURSORS-TREE
    (CL:VALUES ITERATORCLAUSES VALUECLAUSES CONTINUATIONTEST)))
  :VOID)

;;; (DEFUN (YIELD-COLLECT-INTO-LIST-CODE CONS) ...)

(CL:DEFUN YIELD-COLLECT-INTO-LIST-CODE (COLLECTVARIABLE INTOVARIABLE COLLECTTREE)
  (CL:RETURN-FROM
   YIELD-COLLECT-INTO-LIST-CODE
   (CONS
    (LIST*
     SYM-FOREACH-IF
     (LIST* SYM-FOREACH-NULL? COLLECTVARIABLE NIL)
     (LIST*
      SYM-FOREACH-PROGN
      (LIST*
       SYM-FOREACH-SETQ
       COLLECTVARIABLE
       (CONS
        (LIST*
         SYM-FOREACH-PERMANENT-CONS
         COLLECTTREE
         (CONS SYM-FOREACH-NIL NIL))
        NIL))
      (LIST*
       SYM-FOREACH-IF
       (LIST*
        SYM-FOREACH-EMPTY?
        (LIST* SYM-FOREACH-THE-CONS-LIST INTOVARIABLE NIL)
        NIL)
       (LIST*
        SYM-FOREACH-SETF
        (LIST* SYM-FOREACH-THE-CONS-LIST INTOVARIABLE NIL)
        COLLECTVARIABLE
        NIL)
       (LIST*
        SYM-FOREACH-ADD-CONS-TO-END-OF-CONS-LIST
        (LIST* SYM-FOREACH-THE-CONS-LIST INTOVARIABLE NIL)
        COLLECTVARIABLE
        NIL)
       NIL)
      NIL)
     (LIST*
      SYM-FOREACH-PROGN
      (LIST*
       SYM-FOREACH-SETF
       (LIST* SYM-FOREACH-REST COLLECTVARIABLE NIL)
       (LIST*
        SYM-FOREACH-PERMANENT-CONS
        (COPY-CONS-TREE COLLECTTREE)
        (CONS SYM-FOREACH-NIL NIL))
       NIL)
      (LIST*
       SYM-FOREACH-SETQ
       COLLECTVARIABLE
       (CONS (LIST* SYM-FOREACH-REST COLLECTVARIABLE NIL) NIL))
      NIL)
     NIL)
    NIL))
  :VOID)

;;; (DEFUN (YIELD-COLLECT-INTO-CONS-CODE CONS) ...)

(CL:DEFUN YIELD-COLLECT-INTO-CONS-CODE (COLLECTVARIABLE INTOVARIABLE COLLECTTREE)
  (CL:RETURN-FROM
   YIELD-COLLECT-INTO-CONS-CODE
   (CONS
    (LIST*
     SYM-FOREACH-IF
     (LIST* SYM-FOREACH-NULL? COLLECTVARIABLE NIL)
     (LIST*
      SYM-FOREACH-PROGN
      (LIST*
       SYM-FOREACH-SETQ
       COLLECTVARIABLE
       (CONS
        (LIST* SYM-FOREACH-CONS COLLECTTREE (CONS SYM-FOREACH-NIL NIL))
        NIL))
      (LIST*
       SYM-FOREACH-IF
       (LIST* SYM-FOREACH-NIL? INTOVARIABLE NIL)
       (LIST* SYM-FOREACH-SETQ INTOVARIABLE (CONS COLLECTVARIABLE NIL))
       (LIST*
        SYM-FOREACH-ADD-CONS-TO-END-OF-CONS-LIST
        INTOVARIABLE
        (CONS COLLECTVARIABLE NIL))
       NIL)
      NIL)
     (LIST*
      SYM-FOREACH-PROGN
      (LIST*
       SYM-FOREACH-SETF
       (LIST* SYM-FOREACH-REST COLLECTVARIABLE NIL)
       (LIST*
        SYM-FOREACH-CONS
        (COPY-CONS-TREE COLLECTTREE)
        (CONS SYM-FOREACH-NIL NIL))
       NIL)
      (LIST*
       SYM-FOREACH-SETQ
       COLLECTVARIABLE
       (CONS (LIST* SYM-FOREACH-REST COLLECTVARIABLE NIL) NIL))
      NIL)
     NIL)
    NIL))
  :VOID)

;;; (DEFUN (YIELD-COLLECT-CODE CONS) ...)

(CL:DEFUN YIELD-COLLECT-CODE (COLLECTVARIABLE INTOVARIABLE COLLECTTREE)
  (CL:LET*
   ((INTOVARIABLETYPE
     (TYPE-SPEC-TO-BASE-TYPE (LOOKUP-VARIABLE-TYPE INTOVARIABLE))))
   (CL:COND
    ((CL:EQ (SUBTYPE-OF? INTOVARIABLETYPE SGT-FOREACH-LIST) 1)
     (CL:RETURN-FROM
      YIELD-COLLECT-CODE
      (YIELD-COLLECT-INTO-LIST-CODE
       COLLECTVARIABLE
       INTOVARIABLE
       COLLECTTREE)))
    ((CL:EQ (SUBTYPE-OF? INTOVARIABLETYPE SGT-FOREACH-CONS) 1)
     (CL:RETURN-FROM
      YIELD-COLLECT-CODE
      (YIELD-COLLECT-INTO-CONS-CODE
       COLLECTVARIABLE
       INTOVARIABLE
       COLLECTTREE)))
    ((CL:EQ INTOVARIABLETYPE SGT-FOREACH-UNKNOWN)
     (CL:RETURN-FROM
      YIELD-COLLECT-CODE
      (CONS
       (LIST*
        SYM-FOREACH-IF
        (LIST* SYM-FOREACH-NULL? COLLECTVARIABLE NIL)
        (LIST*
         SYM-FOREACH-PROGN
         (LIST*
          SYM-FOREACH-SETQ
          COLLECTVARIABLE
          (CONS
           (LIST* SYM-FOREACH-CONS COLLECTTREE (CONS SYM-FOREACH-NIL NIL))
           NIL))
         (LIST*
          SYM-FOREACH-COND
          (LIST*
           (LIST* SYM-FOREACH-NIL? INTOVARIABLE NIL)
           (LIST* SYM-FOREACH-SETQ INTOVARIABLE (CONS COLLECTVARIABLE NIL))
           NIL)
          (LIST*
           (LIST* SYM-FOREACH-CONS? INTOVARIABLE NIL)
           (LIST*
            SYM-FOREACH-ADD-CONS-TO-END-OF-CONS-LIST
            INTOVARIABLE
            (CONS COLLECTVARIABLE NIL))
           NIL)
          (LIST*
           SYM-FOREACH-OTHERWISE
           (LIST*
            SYM-FOREACH-IF
            (LIST*
             SYM-FOREACH-EMPTY?
             (LIST* SYM-FOREACH-THE-CONS-LIST INTOVARIABLE NIL)
             NIL)
            (LIST*
             SYM-FOREACH-SETF
             (LIST* SYM-FOREACH-THE-CONS-LIST INTOVARIABLE NIL)
             COLLECTVARIABLE
             NIL)
            (LIST*
             SYM-FOREACH-ADD-CONS-TO-END-OF-CONS-LIST
             (LIST* SYM-FOREACH-THE-CONS-LIST INTOVARIABLE NIL)
             COLLECTVARIABLE
             NIL)
            NIL)
           NIL)
          NIL)
         NIL)
        (LIST*
         SYM-FOREACH-PROGN
         (LIST*
          SYM-FOREACH-SETF
          (LIST* SYM-FOREACH-REST COLLECTVARIABLE NIL)
          (LIST*
           SYM-FOREACH-CONS
           (COPY-CONS-TREE COLLECTTREE)
           (CONS SYM-FOREACH-NIL NIL))
          NIL)
         (LIST*
          SYM-FOREACH-SETQ
          COLLECTVARIABLE
          (CONS (LIST* SYM-FOREACH-REST COLLECTVARIABLE NIL) NIL))
         NIL)
        NIL)
       NIL)))
    (CL:T
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN
       (CL:EQ (SUPPRESS-WARNINGS?) 0)
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING
         " Can't collect into a datatype other than LIST or CONS.."
         %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     (CL:RETURN-FROM
      YIELD-COLLECT-CODE
      (WALK-DONT-CALL-ME-TREE COLLECTTREE SGT-FOREACH-VOID)))))
  :VOID)

;;; (DEFUN (WALK-PREFIX-COLLECT-INTO-TREE CONS CONS) ...)

(CL:DEFUN WALK-PREFIX-COLLECT-INTO-TREE (COLLECTINTOTREE ITERATORS VALUEBINDINGS DOCODE)
  (CL:LET*
   ((COLLECTTREE (SECOND COLLECTINTOTREE))
    (INTOTREE (THIRD COLLECTINTOTREE))
    (COLLECTVARIABLE (LOCAL-GENSYM "COLLECT"))
    (COLLECTINTOBINDINGS
     (CONS
      (CONS COLLECTVARIABLE (LIST* SGT-FOREACH-CONS SYM-FOREACH-NULL NIL))
      NIL))
    (COLLECTCODE NULL)
    (INTOVARIABLE NULL)
    (INTOVARIABLETYPE NULL))
   (FREE-CONS-LIST COLLECTINTOTREE)
   (CL:IF
    (CL:EQ (SYMBOL? INTOTREE) 1)
    (CL:PROGN
     (CL:SETQ INTOVARIABLE INTOTREE)
     (CL:SETQ
      COLLECTCODE
      (YIELD-COLLECT-CODE COLLECTVARIABLE INTOVARIABLE COLLECTTREE)))
    (CL:PROGN
     (CL:LET*
      ((D NULL) (ITER-001 VALUEBINDINGS))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ D (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (PUSH-VARIABLE-BINDING (FIRST D) (SECOND D))))
     (CL:MULTIPLE-VALUE-SETQ
      (INTOTREE INTOVARIABLETYPE)
      (WALK-EXPRESSION-TREE INTOTREE NULL SYM-FOREACH-FOREACH FALSE))
     (CL:LET*
      ((D NULL) (ITER-002 VALUEBINDINGS))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-002 NIL))
       DO
       (CL:PROGN
        (CL:SETQ D (CLSYS-SVAL CONS VALUE ITER-002))
        (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
       (CL:PROGN D)
       (POP-VARIABLE-BINDING)))
     (CL:SETQ INTOVARIABLE (LOCAL-GENSYM "INTO"))
     (CL:SETQ
      COLLECTINTOBINDINGS
      (CONS
       (CONS-LIST INTOVARIABLE INTOVARIABLETYPE INTOTREE)
       COLLECTINTOBINDINGS))
     (PUSH-VARIABLE-BINDING INTOVARIABLE INTOVARIABLETYPE)
     (CL:SETQ
      COLLECTCODE
      (YIELD-COLLECT-CODE COLLECTVARIABLE INTOVARIABLE COLLECTTREE))
     (POP-VARIABLE-BINDING)))
   (CL:RETURN-FROM
    WALK-PREFIX-COLLECT-INTO-TREE
    (CL:VALUES
     (CONCATENATE ITERATORS COLLECTINTOBINDINGS)
     (CONCATENATE DOCODE COLLECTCODE))))
  :VOID)

;;; (DEFUN (WRAP-WHERE-TEST CONS) ...)

(CL:DEFUN WRAP-WHERE-TEST (WHERETEST ACTIONS)
  (CL:IF
   (CL:NOT (CL:EQ WHERETEST NULL))
   (CL:RETURN-FROM
    WRAP-WHERE-TEST
    (CONS (LIST* SYM-FOREACH-WHEN WHERETEST (CONCATENATE ACTIONS NIL)) NIL))
   (CL:RETURN-FROM WRAP-WHERE-TEST ACTIONS))
  :VOID)

;;; (DEFUN (WALK-PREFIX-FOREACH-BODY CONS) ...)

(CL:DEFUN WALK-PREFIX-FOREACH-BODY (ITERATORCLAUSES VALUECLAUSES WHERETEST DOACTIONS)
  (CL:LET*
   ((OTREE NULL))
   (CL:LET*
    ((C NULL) (ITER-001 ITERATORCLAUSES))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ C (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (PUSH-VARIABLE-BINDING (FIRST C) (SECOND C))))
   (CL:LET*
    ((C NULL) (ITER-002 VALUECLAUSES))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ C (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (PUSH-VARIABLE-BINDING (FIRST C) (SECOND C))))
   (CL:SETQ OTREE (WALK-LIST-OF-TREES (WRAP-WHERE-TEST WHERETEST DOACTIONS)))
   (CL:LET*
    ((C NULL) (ITER-003 VALUECLAUSES))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-003 NIL))
     DO
     (CL:PROGN
      (CL:SETQ C (CLSYS-SVAL CONS VALUE ITER-003))
      (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
     (CL:PROGN C)
     (POP-VARIABLE-BINDING)))
   (CL:LET*
    ((C NULL) (ITER-004 ITERATORCLAUSES))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-004 NIL))
     DO
     (CL:PROGN
      (CL:SETQ C (CLSYS-SVAL CONS VALUE ITER-004))
      (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
     (CL:PROGN C)
     (POP-VARIABLE-BINDING)))
   (CL:RETURN-FROM WALK-PREFIX-FOREACH-BODY OTREE))
  :VOID)

;;; (DEFUN (WALK-PREFIX-FOREACH-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-PREFIX-FOREACH-TREE (TREE)
  (CL:LET*
   ((TAIL NULL)
    (ITERATORCLAUSES NULL)
    (VALUECLAUSES NULL)
    (CONTINUATIONTEST NULL)
    (WHERETEST NULL)
    (DOACTIONS NIL))
   (CL:MULTIPLE-VALUE-SETQ
    (ITERATORCLAUSES VALUECLAUSES CONTINUATIONTEST)
    (WALK-CURSORS-TREE (SECOND TREE) FALSE))
   (SECOND-SETTER TREE NULL)
   (CL:SETQ TAIL (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
   (CL:WHEN
    (CL:EQ (FIRST (FIRST TAIL)) SYM-FOREACH-WHERE)
    (CL:SETQ WHERETEST (SECOND (FIRST TAIL)))
    (SECOND-SETTER (FIRST TAIL) NULL)
    (CL:SETQ TAIL (CLSYS-SVAL CONS REST TAIL)))
   (CL:WHEN
    (CL:EQ (FIRST (FIRST TAIL)) SYM-FOREACH-DO)
    (CL:SETQ DOACTIONS (CLSYS-SVAL CONS REST (FIRST TAIL)))
    (CL:SETF (CLSYS-SVAL CONS REST (FIRST TAIL)) NIL)
    (CL:SETQ TAIL (CLSYS-SVAL CONS REST TAIL)))
   (CL:WHEN
    (CL:NOT (CL:EQ TAIL NIL))
    (CL:MULTIPLE-VALUE-SETQ
     (ITERATORCLAUSES DOACTIONS)
     (WALK-PREFIX-COLLECT-INTO-TREE
      (FIRST TAIL)
      ITERATORCLAUSES
      VALUECLAUSES
      DOACTIONS))
    (FIRST-SETTER TAIL NULL))
   (FREE-CONS-TREE TREE)
   (CL:RETURN-FROM
    WALK-PREFIX-FOREACH-TREE
    (CL:VALUES
     (LIST*
      SYM-FOREACH-SYS-FOREACH
      ITERATORCLAUSES
      (CONS
       VALUECLAUSES
       (CONS
        CONTINUATIONTEST
        (CONCATENATE
         (WALK-PREFIX-FOREACH-BODY
          ITERATORCLAUSES
          VALUECLAUSES
          WHERETEST
          DOACTIONS)
         NIL))))
     SGT-FOREACH-VOID)))
  :VOID)

;;; (DEFUN (WALK-EXISTS-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-EXISTS-TREE (TREE)
  (CL:LET*
   ((FOUND? (LOCAL-GENSYM "FOUND?"))
    (OTREE
     (LIST*
      SYM-FOREACH-VRLET
      (CONS (CONS FOUND? (CONS SYM-FOREACH-FALSE NIL)) NIL)
      (CONS
       SYM-FOREACH-FOREACH
       (CONCATENATE
        (CLSYS-SVAL CONS REST TREE)
        (LIST*
         SYM-FOREACH-DO
         (LIST* SYM-FOREACH-SETQ FOUND? (CONS SYM-FOREACH-TRUE NIL))
         (CONS SYM-FOREACH-BREAK NIL)
         NIL)))
      FOUND?
      NIL)))
   (FREE-CONS TREE)
   (CL:RETURN-FROM WALK-EXISTS-TREE (WALK-A-CONS-TREE OTREE)))
  :VOID)

;;; (DEFUN (WALK-FORALL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-FORALL-TREE (TREE)
  (CL:LET*
   ((ALWAYS? (LOCAL-GENSYM "ALWAYS?"))
    (ITERATORSANDWHERE NIL)
    (ALWAYSTEST NIL)
    (PRECURSOR NIL)
    (CURSOR TREE))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:WHEN
     (CL:EQ (FIRST CURSOR) SYM-FOREACH-ALWAYS)
     (CL:SETQ ALWAYSTEST (FIRST (CLSYS-SVAL CONS REST CURSOR)))
     (FREE-CONS-LIST CURSOR)
     (CL:SETF (CLSYS-SVAL CONS REST PRECURSOR) NIL)
     (CL:RETURN))
    (CL:SETQ PRECURSOR CURSOR)
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (CL:SETQ ITERATORSANDWHERE (CLSYS-SVAL CONS REST TREE))
   (FREE-CONS TREE)
   (CL:RETURN-FROM
    WALK-FORALL-TREE
    (CL:VALUES
     (LIST*
      SYM-FOREACH-VRLET
      (CONS (CONS ALWAYS? (CONS SYM-FOREACH-TRUE NIL)) NIL)
      (CONS
       SYM-FOREACH-FOREACH
       (CONCATENATE
        ITERATORSANDWHERE
        (LIST*
         SYM-FOREACH-DO
         (LIST*
          SYM-FOREACH-WHEN
          (LIST* SYM-FOREACH-NOT ALWAYSTEST NIL)
          (LIST* SYM-FOREACH-SETQ ALWAYS? (CONS SYM-FOREACH-FALSE NIL))
          (CONS SYM-FOREACH-BREAK NIL)
          NIL)
         NIL)))
      ALWAYS?
      NIL)
     SGT-FOREACH-BOOLEAN)))
  :VOID)

;;; (DEFUN (WALK-SOME-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SOME-TREE (TREE)
  (CL:LET*
   ((VALUEVAR (LOCAL-GENSYM "VALUE"))
    (ITERATIONVAR (SECOND TREE))
    (OTREE NULL))
   (CL:LET*
    ((SEQUENCEREF NULL) (SEQUENCETYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (SEQUENCEREF SEQUENCETYPE)
     (WALK-A-TREE (FOURTH TREE)))
    (FOURTH-SETTER TREE SEQUENCEREF)
    (CL:SETQ
     OTREE
     (LIST*
      SYM-FOREACH-VRLET
      (CONS
       (CONS
        VALUEVAR
        (CONS
         (EXTRACT-PARAMETER-TYPE SEQUENCETYPE SYM-FOREACH-ANY-VALUE)
         (CONS SYM-FOREACH-NULL NIL)))
       NIL)
      (CONS
       SYM-FOREACH-FOREACH
       (CONCATENATE
        (CLSYS-SVAL CONS REST TREE)
        (LIST*
         SYM-FOREACH-DO
         (LIST* SYM-FOREACH-SETQ VALUEVAR (CONS ITERATIONVAR NIL))
         (CONS SYM-FOREACH-BREAK NIL)
         NIL)))
      VALUEVAR
      NIL))
    (FREE-CONS TREE)
    (CL:RETURN-FROM WALK-SOME-TREE (WALK-A-CONS-TREE OTREE))))
  :VOID)

;;; (DEFUN (EXTRACT-SETOF-NESTED-ITERATOR-TREE CONS) ...)

(CL:DEFUN EXTRACT-SETOF-NESTED-ITERATOR-TREE (ITERATORCLAUSES)
  (CL:LET*
   ((ITERCLAUSES ITERATORCLAUSES) (SUBTREE (THIRD (FIRST ITERCLAUSES))))
   (THIRD-SETTER (FIRST ITERCLAUSES) NULL)
   (CL:WHEN
    (CL:NOT (CL:EQ (CLSYS-SVAL CONS REST ITERCLAUSES) NIL))
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Too many iterators in 'setof' expression." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))))
   (FREE-CONS-TREE ITERCLAUSES)
   (CL:RETURN-FROM EXTRACT-SETOF-NESTED-ITERATOR-TREE SUBTREE))
  :VOID)

;;; (DEFUN (YIELD-SETOF-NEXT-FUNCTION-NAME SYMBOL) ...)

(CL:DEFUN YIELD-SETOF-NEXT-FUNCTION-NAME (VALUECLAUSES WHERETEST)
  (CL:LET*
   ((ONLYVALUECLAUSE (FIRST VALUECLAUSES))
    (VALUEVARIABLE (FIRST ONLYVALUECLAUSE))
    (VALUETYPE (SECOND ONLYVALUECLAUSE))
    (NEXTFUNCTIONNAME NULL))
   (FREE-CONS-TREE VALUECLAUSES)
   (CL:SETQ NEXTFUNCTIONNAME (GENSYM "SETOF-NEXT-P"))
   (WALK-AUXILIARY-TREE
    (LIST*
     SYM-FOREACH-DEFUN
     (CONS NEXTFUNCTIONNAME (CONS SYM-FOREACH-BOOLEAN NIL))
     (CONS (LIST* SYM-FOREACH-SELF SYM-FOREACH-ALL-PURPOSE-ITERATOR NIL) NIL)
     (LIST*
      SYM-FOREACH-LET
      (LIST*
       (LIST*
        SYM-FOREACH-NESTEDITERATOR
        (LIST* SYM-FOREACH-ITERATOR-NESTED-ITERATOR SYM-FOREACH-SELF NIL)
        NIL)
       (CONS VALUEVARIABLE (CONS VALUETYPE (CONS SYM-FOREACH-NULL NIL)))
       NIL)
      (LIST*
       SYM-FOREACH-WHILE
       (LIST* SYM-FOREACH-NEXT? SYM-FOREACH-NESTEDITERATOR NIL)
       (LIST*
        SYM-FOREACH-SETQ
        VALUEVARIABLE
        (CONS (LIST* SYM-FOREACH-VALUE SYM-FOREACH-NESTEDITERATOR NIL) NIL))
       (LIST*
        SYM-FOREACH-WHEN
        WHERETEST
        (LIST*
         (LIST*
          SYM-FOREACH-SETF
          (LIST* SYM-FOREACH-VALUE SYM-FOREACH-SELF NIL)
          VALUEVARIABLE
          NIL)
         (LIST* SYM-FOREACH-RETURN SYM-FOREACH-TRUE NIL)
         NIL))
       NIL)
      (LIST* SYM-FOREACH-RETURN SYM-FOREACH-FALSE NIL)
      NIL)
     NIL))
   (CL:RETURN-FROM YIELD-SETOF-NEXT-FUNCTION-NAME NEXTFUNCTIONNAME))
  :VOID)

;;; (DEFUN (WALK-SETOF-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SETOF-TREE (TREE)
  (CL:SETQ TREE (FOREACH-TO-PREFIX-FOREACH-TREE TREE))
  (CL:LET*
   ((ITERATORSSUBTREE (SECOND TREE))
    (ITERATORVARIABLE (LOCAL-GENSYM "ITER"))
    (TAIL NULL)
    (ITERATORCLAUSES NULL)
    (VALUECLAUSES NULL)
    (CONTINUATIONTEST NULL)
    (WHERETEST NULL))
   (SECOND-SETTER TREE NULL)
   (CL:WHEN
    (CL:EQ
     (MEMBER?
      (GET-QUOTED-TREE "((ON AS) \"/STELLA\")" "/STELLA")
      (FIRST ITERATORSSUBTREE))
     1)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Illegal reserved word `" %%STREAM)
       (PRINT-OBJECT (FIRST ITERATORSSUBTREE) %%STREAM)
       (CL:WRITE-STRING "' in 'setof' expression.." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))))
   (CL:MULTIPLE-VALUE-SETQ
    (ITERATORCLAUSES VALUECLAUSES CONTINUATIONTEST)
    (WALK-CURSORS-TREE ITERATORSSUBTREE TRUE))
   (CL:SETQ TAIL (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ TAIL NIL))
     (CL:EQ (FIRST (FIRST TAIL)) SYM-FOREACH-WHERE))
    (CL:SETQ WHERETEST (SECOND (FIRST TAIL)))
    (SECOND-SETTER (FIRST TAIL) NULL)
    (CL:SETQ TAIL (CLSYS-SVAL CONS REST TAIL)))
   (CL:WHEN
    (CL:NOT (CL:EQ TAIL NIL))
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN
      (CL:EQ (SUPPRESS-WARNINGS?) 0)
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING " Illegal 'setof' expression.  Syntax is " %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING
        "   (SETOF <iterators> WHERE <boolean expression>)."
        %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))))
   (FREE-CONS-TREE TREE)
   (CL:RETURN-FROM
    WALK-SETOF-TREE
    (CL:VALUES
     (LIST*
      SYM-FOREACH-VRLET
      (CONS
       (CONS
        ITERATORVARIABLE
        (CONS
         (LIST* SYM-FOREACH-NEW SYM-FOREACH-ALL-PURPOSE-ITERATOR NIL)
         NIL))
       NIL)
      (LIST*
       SYM-FOREACH-SETF
       (LIST* SYM-FOREACH-ITERATOR-NESTED-ITERATOR ITERATORVARIABLE NIL)
       (EXTRACT-SETOF-NESTED-ITERATOR-TREE ITERATORCLAUSES)
       NIL)
      (LIST*
       SYM-FOREACH-SETF
       (LIST* SYM-FOREACH-ITERATOR-NEXT-CODE ITERATORVARIABLE NIL)
       (LIST*
        SYM-FOREACH-THE-CODE
        KWD-FOREACH-FUNCTION
        (YIELD-SETOF-NEXT-FUNCTION-NAME VALUECLAUSES WHERETEST)
        NIL)
       NIL)
      ITERATORVARIABLE
      NIL)
     SGT-FOREACH-ALL-PURPOSE-ITERATOR)))
  :VOID)

(CL:DEFUN STARTUP-FOREACH ()
  (CL:LET*
   ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ SYM-FOREACH-AS (INTERN-RIGID-SYMBOL-WRT-MODULE "AS" NULL 0))
    (CL:SETQ
     SYM-FOREACH-COMMA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMA" NULL 0))
    (CL:SETQ SYM-FOREACH-DO (INTERN-RIGID-SYMBOL-WRT-MODULE "DO" NULL 0))
    (CL:SETQ
     SYM-FOREACH-COLLECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT" NULL 0))
    (CL:SETQ SGT-FOREACH-VOID (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" NULL 1))
    (CL:SETQ
     SYM-FOREACH-WHERE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WHERE" NULL 0))
    (CL:SETQ SYM-FOREACH-INTO (INTERN-RIGID-SYMBOL-WRT-MODULE "INTO" NULL 0))
    (CL:SETQ
     SYM-FOREACH-COLLECT-INTO
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-INTO" NULL 0))
    (CL:SETQ
     SYM-FOREACH-PREFIX-FOREACH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PREFIX-FOREACH" NULL 0))
    (CL:SETQ SYM-FOREACH-IN (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 0))
    (CL:SETQ SYM-FOREACH-X (INTERN-RIGID-SYMBOL-WRT-MODULE "X" NULL 0))
    (CL:SETQ SYM-FOREACH-NIL (INTERN-RIGID-SYMBOL-WRT-MODULE "NIL" NULL 0))
    (CL:SETQ
     SYM-FOREACH-FOREACH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FOREACH" NULL 0))
    (CL:SETQ
     SYM-FOREACH-EXISTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 0))
    (CL:SETQ
     SYM-FOREACH-FORALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 0))
    (CL:SETQ SYM-FOREACH-SOME (INTERN-RIGID-SYMBOL-WRT-MODULE "SOME" NULL 0))
    (CL:SETQ
     SYM-FOREACH-SETOF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOF" NULL 0))
    (CL:SETQ
     SYM-FOREACH-SET-OF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-OF" NULL 0))
    (CL:SETQ
     SYM-FOREACH-INTERVAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL" NULL 0))
    (CL:SETQ
     SGT-FOREACH-INTEGER-INTERVAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-INTERVAL" NULL 1))
    (CL:SETQ
     SGT-FOREACH-ABSTRACT-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT-ITERATOR" NULL 1))
    (CL:SETQ
     SYM-FOREACH-ALLOCATE-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOCATE-ITERATOR" NULL 0))
    (CL:SETQ
     SYM-FOREACH-FALSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
    (CL:SETQ
     SGT-FOREACH-STRING
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 1))
    (CL:SETQ
     SGT-FOREACH-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" NULL 1))
    (CL:SETQ SGT-FOREACH-LIST (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" NULL 1))
    (CL:SETQ SGT-FOREACH-CONS (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
    (CL:SETQ
     SYM-FOREACH-THE-CONS-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-CONS-LIST" NULL 0))
    (CL:SETQ
     SGT-FOREACH-KEY-VALUE-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-VALUE-LIST" NULL 1))
    (CL:SETQ
     SGT-FOREACH-KV-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KV-CONS" NULL 1))
    (CL:SETQ
     SYM-FOREACH-THE-KV-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-KV-LIST" NULL 0))
    (CL:SETQ
     SGT-FOREACH-PROPERTY-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTY-LIST" NULL 1))
    (CL:SETQ
     SYM-FOREACH-THE-PLIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-PLIST" NULL 0))
    (CL:SETQ SYM-FOREACH-KEY (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY" NULL 0))
    (CL:SETQ
     SYM-FOREACH-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
    (CL:SETQ SYM-FOREACH-SETQ (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
    (CL:SETQ SYM-FOREACH-REST (INTERN-RIGID-SYMBOL-WRT-MODULE "REST" NULL 0))
    (CL:SETQ SYM-FOREACH-NOT (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 0))
    (CL:SETQ SYM-FOREACH-NIL? (INTERN-RIGID-SYMBOL-WRT-MODULE "NIL?" NULL 0))
    (CL:SETQ
     SYM-FOREACH-DEFINED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?" NULL 0))
    (CL:SETQ
     SYM-FOREACH-NEXT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NEXT?" NULL 0))
    (CL:SETQ
     SYM-FOREACH-PROGN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROGN" NULL 0))
    (CL:SETQ
     SYM-FOREACH-ANY-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY-VALUE" NULL 0))
    (CL:SETQ
     SYM-FOREACH-ANY-KEY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY-KEY" NULL 0))
    (CL:SETQ SYM-FOREACH-NULL (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
    (CL:SETQ
     SYM-FOREACH-NULL-INTEGER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-INTEGER" NULL 0))
    (CL:SETQ
     SGT-FOREACH-NUMBER-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-FOREACH-INTEGER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER" NULL 1))
    (CL:SETQ
     SGT-FOREACH-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
    (CL:SETQ
     SYM-FOREACH-NULL?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL?" NULL 0))
    (CL:SETQ SYM-FOREACH-++ (INTERN-RIGID-SYMBOL-WRT-MODULE "++" NULL 0))
    (CL:SETQ SYM-FOREACH-TRUE (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
    (CL:SETQ SYM-FOREACH-<= (INTERN-RIGID-SYMBOL-WRT-MODULE "<=" NULL 0))
    (CL:SETQ SYM-FOREACH-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 0))
    (CL:SETQ
     SYM-FOREACH-LENGTH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LENGTH" NULL 0))
    (CL:SETQ SYM-FOREACH-NTH (INTERN-RIGID-SYMBOL-WRT-MODULE "NTH" NULL 0))
    (CL:SETQ
     SGT-FOREACH-CHARACTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER" NULL 1))
    (CL:SETQ SYM-FOREACH-< (INTERN-RIGID-SYMBOL-WRT-MODULE "<" NULL 0))
    (CL:SETQ SYM-FOREACH-ON (INTERN-RIGID-SYMBOL-WRT-MODULE "ON" NULL 0))
    (CL:SETQ SYM-FOREACH-AND (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 0))
    (CL:SETQ SYM-FOREACH-IF (INTERN-RIGID-SYMBOL-WRT-MODULE "IF" NULL 0))
    (CL:SETQ
     SYM-FOREACH-PERMANENT-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PERMANENT-CONS" NULL 0))
    (CL:SETQ
     SYM-FOREACH-EMPTY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EMPTY?" NULL 0))
    (CL:SETQ SYM-FOREACH-SETF (INTERN-RIGID-SYMBOL-WRT-MODULE "SETF" NULL 0))
    (CL:SETQ
     SYM-FOREACH-ADD-CONS-TO-END-OF-CONS-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD-CONS-TO-END-OF-CONS-LIST" NULL 0))
    (CL:SETQ SYM-FOREACH-CONS (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 0))
    (CL:SETQ
     SGT-FOREACH-UNKNOWN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" NULL 1))
    (CL:SETQ SYM-FOREACH-COND (INTERN-RIGID-SYMBOL-WRT-MODULE "COND" NULL 0))
    (CL:SETQ
     SYM-FOREACH-CONS?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS?" NULL 0))
    (CL:SETQ
     SYM-FOREACH-OTHERWISE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHERWISE" NULL 0))
    (CL:SETQ SYM-FOREACH-WHEN (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN" NULL 0))
    (CL:SETQ
     SYM-FOREACH-SYS-FOREACH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-FOREACH" NULL 0))
    (CL:SETQ
     SYM-FOREACH-VRLET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VRLET" NULL 0))
    (CL:SETQ
     SYM-FOREACH-BREAK
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BREAK" NULL 0))
    (CL:SETQ
     SYM-FOREACH-ALWAYS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALWAYS" NULL 0))
    (CL:SETQ
     SYM-FOREACH-DEFUN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFUN" NULL 0))
    (CL:SETQ
     SYM-FOREACH-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 0))
    (CL:SETQ SYM-FOREACH-SELF (INTERN-RIGID-SYMBOL-WRT-MODULE "SELF" NULL 0))
    (CL:SETQ
     SYM-FOREACH-ALL-PURPOSE-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-PURPOSE-ITERATOR" NULL 0))
    (CL:SETQ SYM-FOREACH-LET (INTERN-RIGID-SYMBOL-WRT-MODULE "LET" NULL 0))
    (CL:SETQ
     SYM-FOREACH-NESTEDITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NESTEDITERATOR" NULL 0))
    (CL:SETQ
     SYM-FOREACH-ITERATOR-NESTED-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-NESTED-ITERATOR" NULL 0))
    (CL:SETQ
     SYM-FOREACH-WHILE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WHILE" NULL 0))
    (CL:SETQ
     SYM-FOREACH-RETURN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN" NULL 0))
    (CL:SETQ SYM-FOREACH-NEW (INTERN-RIGID-SYMBOL-WRT-MODULE "NEW" NULL 0))
    (CL:SETQ
     SYM-FOREACH-ITERATOR-NEXT-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-NEXT-CODE" NULL 0))
    (CL:SETQ
     SYM-FOREACH-THE-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-CODE" NULL 0))
    (CL:SETQ
     KWD-FOREACH-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     SGT-FOREACH-ALL-PURPOSE-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-PURPOSE-ITERATOR" NULL 1)))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXTRACT-ONE-IN-CLAUSE"
        "CONS"
        "(DEFUN (EXTRACT-ONE-IN-CLAUSE CONS CONS) ((TAIL CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXTRACT-ONE-IN-CLAUSE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXTRACT-ONE-GENERATOR-TERM"
        "CONS"
        "(DEFUN (EXTRACT-ONE-GENERATOR-TERM CONS CONS) ((TAIL CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXTRACT-ONE-GENERATOR-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXTRACT-GENERATORS-CLAUSE"
        "CONS"
        "(DEFUN (EXTRACT-GENERATORS-CLAUSE CONS CONS) ((TAIL CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXTRACT-GENERATORS-CLAUSE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXTRACT-OPTION-AND-RESIDUE"
        "SYMBOL"
        "(DEFUN (EXTRACT-OPTION-AND-RESIDUE OBJECT CONS) ((OPTION SYMBOL) (TAIL CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXTRACT-OPTION-AND-RESIDUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXTRACT-DO-CLAUSE"
        "CONS"
        "(DEFUN (EXTRACT-DO-CLAUSE CONS CONS) ((TAIL CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXTRACT-DO-CLAUSE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FOREACH-TO-PREFIX-FOREACH-TREE"
        "CONS"
        "(DEFUN (FOREACH-TO-PREFIX-FOREACH-TREE CONS) ((FOREACHTREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FOREACH-TO-PREFIX-FOREACH-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-FOREACH-TREE"
        "CONS"
        "(DEFUN (WALK-FOREACH-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-FOREACH-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-COLLECTION-TREE"
        "OBJECT"
        "(DEFUN (WALK-COLLECTION-TREE OBJECT TYPE-SPEC) ((TREE OBJECT) (DONTOPTIMIZE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-COLLECTION-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-IN-CURSOR-CLAUSES"
        "CONS"
        "(DEFUN (YIELD-IN-CURSOR-CLAUSES CONS CONS OBJECT) ((INTREE CONS) (DONTOPTIMIZE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-IN-CURSOR-CLAUSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION"
        "OBJECT"
        "(DEFUN (YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION CONS CONS OBJECT) ((COLLECTIONTREE OBJECT) (COLLECTIONTYPE TYPE-SPEC) (KEYVAR SYMBOL) (VALUEVAR SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL"
        "CONS"
        "(DEFUN (YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL CONS CONS OBJECT) ((COLLECTIONTREE CONS) (COLLECTIONTYPE TYPE-SPEC) (KEYVAR SYMBOL) (VALUEVAR SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR"
        "OBJECT"
        "(DEFUN (YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR CONS CONS OBJECT) ((COLLECTIONTREE OBJECT) (COLLECTIONTYPE TYPE-SPEC) (KEYVAR SYMBOL) (VALUEVAR SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-ON-CURSOR-CLAUSES"
        "CONS"
        "(DEFUN (YIELD-ON-CURSOR-CLAUSES CONS CONS OBJECT) ((ONTREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-ON-CURSOR-CLAUSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECT-CURSOR-CLAUSES"
        "CONS"
        "(DEFUN (COLLECT-CURSOR-CLAUSES CONS CONS OBJECT) ((CURSORSTREE CONS) (DONTOPTIMIZE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECT-CURSOR-CLAUSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-CURSORS-TREE"
        "CONS"
        "(DEFUN (WALK-CURSORS-TREE CONS CONS OBJECT) ((CURSORSTREE CONS) (DONTOPTIMIZE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-CURSORS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-COLLECT-INTO-LIST-CODE"
        "SYMBOL"
        "(DEFUN (YIELD-COLLECT-INTO-LIST-CODE CONS) ((COLLECTVARIABLE SYMBOL) (INTOVARIABLE OBJECT) (COLLECTTREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-COLLECT-INTO-LIST-CODE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-COLLECT-INTO-CONS-CODE"
        "SYMBOL"
        "(DEFUN (YIELD-COLLECT-INTO-CONS-CODE CONS) ((COLLECTVARIABLE SYMBOL) (INTOVARIABLE OBJECT) (COLLECTTREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-COLLECT-INTO-CONS-CODE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-COLLECT-CODE"
        "SYMBOL"
        "(DEFUN (YIELD-COLLECT-CODE CONS) ((COLLECTVARIABLE SYMBOL) (INTOVARIABLE OBJECT) (COLLECTTREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-COLLECT-CODE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-PREFIX-COLLECT-INTO-TREE"
        "CONS"
        "(DEFUN (WALK-PREFIX-COLLECT-INTO-TREE CONS CONS) ((COLLECTINTOTREE CONS) (ITERATORS CONS) (VALUEBINDINGS CONS) (DOCODE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-PREFIX-COLLECT-INTO-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WRAP-WHERE-TEST"
        "OBJECT"
        "(DEFUN (WRAP-WHERE-TEST CONS) ((WHERETEST OBJECT) (ACTIONS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WRAP-WHERE-TEST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-PREFIX-FOREACH-BODY"
        "CONS"
        "(DEFUN (WALK-PREFIX-FOREACH-BODY CONS) ((ITERATORCLAUSES CONS) (VALUECLAUSES CONS) (WHERETEST CONS) (DOACTIONS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-PREFIX-FOREACH-BODY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-PREFIX-FOREACH-TREE"
        "CONS"
        "(DEFUN (WALK-PREFIX-FOREACH-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-PREFIX-FOREACH-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-EXISTS-TREE"
        "CONS"
        "(DEFUN (WALK-EXISTS-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-EXISTS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-FORALL-TREE"
        "CONS"
        "(DEFUN (WALK-FORALL-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-FORALL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-SOME-TREE"
        "CONS"
        "(DEFUN (WALK-SOME-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-SOME-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXTRACT-SETOF-NESTED-ITERATOR-TREE"
        "CONS"
        "(DEFUN (EXTRACT-SETOF-NESTED-ITERATOR-TREE CONS) ((ITERATORCLAUSES CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXTRACT-SETOF-NESTED-ITERATOR-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-SETOF-NEXT-FUNCTION-NAME"
        "CONS"
        "(DEFUN (YIELD-SETOF-NEXT-FUNCTION-NAME SYMBOL) ((VALUECLAUSES CONS) (WHERETEST CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-SETOF-NEXT-FUNCTION-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WALK-SETOF-TREE"
        "CONS"
        "(DEFUN (WALK-SETOF-TREE CONS TYPE-SPEC) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WALK-SETOF-TREE)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-FOREACH"
     NULL
     "(DEFUN STARTUP-FOREACH ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES)))
  :VOID)
