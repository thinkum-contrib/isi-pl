;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1996, 1997             | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-HIERARCHY-TYPE-SPEC NULL)
(CL:DEFVAR *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* FALSE)
(CL:DEFVAR SYM-HIERARCHY-REFERENCE-COUNT NULL)
(CL:DEFVAR SYM-HIERARCHY-BAD? NULL)
(CL:DEFVAR SYM-HIERARCHY-HOME-CONTEXT NULL)
(CL:DEFVAR SYM-HIERARCHY-FIRST-ITERATION? NULL)
(CL:DEFVAR SYM-HIERARCHY-OBJECT-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-CONS-ITERATOR-CURSOR NULL)
(CL:DEFVAR SGT-HIERARCHY-CONS-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-LIST-ITERATOR-CURSOR NULL)
(CL:DEFVAR SYM-HIERARCHY-LIST-ITERATOR-COLLECTION NULL)
(CL:DEFVAR SGT-HIERARCHY-LIST-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-THE-CONS-LIST NULL)
(CL:DEFVAR SGT-HIERARCHY-DESTRUCTIVE-LIST-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-SET-ITERATOR-CURSOR NULL)
(CL:DEFVAR SYM-HIERARCHY-SET-ITERATOR-COLLECTION NULL)
(CL:DEFVAR SGT-HIERARCHY-SET-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-KEY NULL)
(CL:DEFVAR SYM-HIERARCHY-ITERATOR-NEXT-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-ITERATOR-FILTER-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-ITERATOR-EMPTY-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-ITERATOR-NESTED-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-ITERATOR-OBJECT NULL)
(CL:DEFVAR SYM-HIERARCHY-ITERATOR-SECOND-OBJECT NULL)
(CL:DEFVAR SYM-HIERARCHY-ITERATOR-INTEGER NULL)
(CL:DEFVAR SYM-HIERARCHY-ITERATOR-SECOND-INTEGER NULL)
(CL:DEFVAR SYM-HIERARCHY-ITERATOR-CONS-LIST NULL)
(CL:DEFVAR SGT-HIERARCHY-ALL-PURPOSE-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-ITERATOR-CURSOR NULL)
(CL:DEFVAR SGT-HIERARCHY-TYPES-TO-CLASSES-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-OBJECT-DICTIONARY-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-PLIST-ITERATOR-CURSOR NULL)
(CL:DEFVAR SYM-HIERARCHY-PLIST-ITERATOR-COLLECTION NULL)
(CL:DEFVAR SGT-HIERARCHY-PROPERTY-LIST-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-THE-KV-LIST NULL)
(CL:DEFVAR SYM-HIERARCHY-KV-LIST-ITERATOR-CURSOR NULL)
(CL:DEFVAR SGT-HIERARCHY-KV-LIST-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-INTERVAL-CURSOR NULL)
(CL:DEFVAR SYM-HIERARCHY-LOWER-BOUND NULL)
(CL:DEFVAR SYM-HIERARCHY-UPPER-BOUND NULL)
(CL:DEFVAR SGT-HIERARCHY-INTEGER-INTERVAL-ITERATOR NULL)
(CL:DEFVAR SGT-HIERARCHY-REVERSE-INTEGER-INTERVAL-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-THE-STRING NULL)
(CL:DEFVAR SYM-HIERARCHY-CURSOR NULL)
(CL:DEFVAR SYM-HIERARCHY-END NULL)
(CL:DEFVAR SGT-HIERARCHY-STRING-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-OBJECT-COLLECTION NULL)
(CL:DEFVAR SYM-HIERARCHY-OBJECT-SEQUENCE NULL)
(CL:DEFVAR *RECYCLED-LIST-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-LIST NULL)
(CL:DEFVAR *RECYCLED-SET-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-SET NULL)
(CL:DEFVAR SGT-HIERARCHY-CLASS-EXTENSION NULL)
(CL:DEFVAR *RECYCLED-CONS-S* NULL)
(CL:DEFVAR SYM-HIERARCHY-VALUE NULL)
(CL:DEFVAR SYM-HIERARCHY-REST NULL)
(CL:DEFVAR SGT-HIERARCHY-CONS NULL)
(CL:DEFVAR *RECYCLED-TRANSIENT-CONS-S* NULL)
(CL:DEFVAR *ALL-TRANSIENT-CONS-S* NULL)
(CL:DEFVAR *UNUSED-TRANSIENT-CONS-S* NULL)
(CL:DEFVAR SYM-HIERARCHY-NEXT-SWEEP-LIST-OBJECT NULL)
(CL:DEFVAR SGT-HIERARCHY-TRANSIENT-CONS NULL)
(CL:DEFVAR SYM-HIERARCHY-OBJECT-TO-OBJECT-DICTIONARY NULL)
(CL:DEFVAR SYM-HIERARCHY-THE-PLIST NULL)
(CL:DEFVAR SGT-HIERARCHY-PROPERTY-LIST NULL)
(CL:DEFVAR SGT-HIERARCHY-KV-CONS NULL)
(CL:DEFVAR SGT-HIERARCHY-KEY-VALUE-LIST NULL)
(CL:DEFVAR SGT-HIERARCHY-HASH-TABLE NULL)
(CL:DEFVAR SYM-HIERARCHY-OBJECT-TO-OBJECT-HASH-TABLE NULL)
(CL:DEFVAR SGT-HIERARCHY-INTEGER-HASH-TABLE NULL)
(CL:DEFVAR SGT-HIERARCHY-FLOAT-HASH-TABLE NULL)
(CL:DEFVAR SGT-HIERARCHY-STRING-HASH-TABLE NULL)
(CL:DEFVAR SGT-HIERARCHY-STRING-TO-INTEGER-HASH-TABLE NULL)
(CL:DEFVAR SYM-HIERARCHY-ARRAY-SIZE NULL)
(CL:DEFVAR SGT-HIERARCHY-VECTOR NULL)
(CL:DEFVAR SGT-HIERARCHY-EXTENSIBLE-VECTOR NULL)
(CL:DEFVAR SYM-HIERARCHY-TOP-SYMBOL-OFFSET NULL)
(CL:DEFVAR SYM-HIERARCHY-POTENTIAL-FREE-SYMBOL-OFFSET NULL)
(CL:DEFVAR SGT-HIERARCHY-EXTENSIBLE-SYMBOL-ARRAY NULL)
(CL:DEFVAR *HARDWIRED-RESIZE-INCREMENT-ON-VECTOR-SEQUENCE* NULL-INTEGER)
(CL:DEFVAR SYM-HIERARCHY-RESIZE-INCREMENT NULL)
(CL:DEFVAR SYM-HIERARCHY-SEQUENCE-LENGTH NULL)
(CL:DEFVAR SYM-HIERARCHY-VSEQ NULL)
(CL:DEFVAR *HARDWIRED-RESIZE-INCREMENT-ON-SHORT-VECTOR-SEQUENCE* NULL-INTEGER)
(CL:DEFVAR SGT-HIERARCHY-SHORT-VECTOR-SEQUENCE NULL)
(CL:DEFVAR SYM-HIERARCHY-SVSEQ NULL)
(CL:DEFVAR SGT-HIERARCHY-BOOLEAN-VECTOR NULL)
(CL:DEFVAR SGT-HIERARCHY-INTEGER-VECTOR NULL)
(CL:DEFVAR SGT-HIERARCHY-ACTIVE-LIST NULL)
(CL:DEFVAR SGT-HIERARCHY-ACTIVE-SET NULL)
(CL:DEFVAR SYM-HIERARCHY-DEMON-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-DEMON-ACTION NULL)
(CL:DEFVAR SYM-HIERARCHY-DEMON-CLASS-REFS NULL)
(CL:DEFVAR SYM-HIERARCHY-DEMON-SLOT-REFS NULL)
(CL:DEFVAR SYM-HIERARCHY-DEMON-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-DEMON-METHOD NULL)
(CL:DEFVAR SYM-HIERARCHY-DEMON-DOCUMENTATION NULL)
(CL:DEFVAR SYM-HIERARCHY-DEMON-GUARD? NULL)
(CL:DEFVAR SYM-HIERARCHY-DEMON-ALL? NULL)
(CL:DEFVAR SYM-HIERARCHY-DEMON-INHERIT? NULL)
(CL:DEFVAR SGT-HIERARCHY-DEMON NULL)
(CL:DEFVAR SGT-HIERARCHY-LIST-OF-SLOT NULL)
(CL:DEFVAR SGT-HIERARCHY-LIST-OF-SYMBOL NULL)
(CL:DEFVAR SGT-HIERARCHY-LIST-OF-KEYWORD NULL)
(CL:DEFVAR SGT-HIERARCHY-LIST-OF-TYPE NULL)
(CL:DEFVAR SGT-HIERARCHY-KEYWORD-KEY-VALUE-LIST NULL)
(CL:DEFVAR SYM-HIERARCHY-SYMBOL-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-SYMBOL-ID NULL)
(CL:DEFVAR SYM-HIERARCHY-INTERNED-IN NULL)
(CL:DEFVAR SYM-HIERARCHY-SYMBOL-SLOT-OFFSET NULL)
(CL:DEFVAR SYM-HIERARCHY-SYMBOL-VALUE-AND-PLIST NULL)
(CL:DEFVAR SGT-HIERARCHY-SYMBOL NULL)
(CL:DEFVAR SYM-HIERARCHY-SURROGATE-VALUE NULL)
(CL:DEFVAR SYM-HIERARCHY-SURROGATE-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-TYPE-CLASS NULL)
(CL:DEFVAR SYM-HIERARCHY-TYPE-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOTREF-SLOT NULL)
(CL:DEFVAR SGT-HIERARCHY-SURROGATE NULL)
(CL:DEFVAR SYM-HIERARCHY-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOTREF NULL)
(CL:DEFVAR SYM-HIERARCHY-KEYWORD-NAME NULL)
(CL:DEFVAR SGT-HIERARCHY-KEYWORD NULL)
(CL:DEFVAR SYM-HIERARCHY-INDEXICAL-VALUE NULL)
(CL:DEFVAR SGT-HIERARCHY-INDEXICAL NULL)
(CL:DEFVAR SGT-HIERARCHY-TRANSIENT-SYMBOL NULL)
(CL:DEFVAR SGT-HIERARCHY-TRANSIENT-KEYWORD NULL)
(CL:DEFVAR SYM-HIERARCHY-PROJECTS-ONTO NULL)
(CL:DEFVAR SYM-HIERARCHY-PROJECTED-FROM NULL)
(CL:DEFVAR SYM-HIERARCHY-PROPERTIES NULL)
(CL:DEFVAR SYM-HIERARCHY-STORED-ACTIVE? NULL)
(CL:DEFVAR SYM-HIERARCHY-ABSTRACT? NULL)
(CL:DEFVAR *HARDWIRED-CLASS-ARITY-ON-CLASS* NULL-INTEGER)
(CL:DEFVAR SYM-HIERARCHY-CLASS-CL-STRUCT-SLOTS NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-RECYCLE-METHOD NULL)
(CL:DEFVAR KWD-HIERARCHY-NONE NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-PARAMETERS NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-REQUIRED-SLOT-NAMES NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-GUARD-CONSTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-CONSTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-GUARD-DESTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-DESTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-KEY NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-SYNONYMS NULL)
(CL:DEFVAR SYM-HIERARCHY-CL-STRUCT? NULL)
(CL:DEFVAR SYM-HIERARCHY-MIXIN? NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-ARITY NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-DIRECT-SUPERS NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-DIRECT-SUBS NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-ALL-SUPER-CLASSES NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-ALL-SLOTS NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-LOCAL-SLOTS NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-SLOT-AND-METHOD-CACHE NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-ABSTRACT? NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-MIXIN? NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-COLLECTION? NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-CL-STRUCT? NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-PUBLIC? NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-FINALIZED? NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-SLOTS-FINALIZED? NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-CONSTRUCTOR-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-SLOT-ACCESSOR-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-MARKED? NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-TAXONOMY-NODE NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-DOCUMENTATION NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-PRINT-FORM NULL)
(CL:DEFVAR SYM-HIERARCHY-DOCUMENTATION NULL)
(CL:DEFVAR SYM-HIERARCHY-PRINT-FORM NULL)
(CL:DEFVAR SGT-HIERARCHY-CLASS NULL)
(CL:DEFVAR SGT-HIERARCHY-ACTIVE-OBJECT NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-CREATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-INITIALIZER NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-TERMINATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-DESTRUCTOR NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-INITIAL-VALUE NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-EXTENSION NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-CL-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-CPP-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-CLASS-JAVA-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-DIRECT-EQUIVALENT NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-AUXILIARY? NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-DIRECT-SUPERS NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-DIRECT-SUBS NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-OWNER NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-BASE-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-SLOTREF NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-PUBLIC? NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-RENAMED? NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-EXTERNAL? NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-MARKED? NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-DOCUMENTATION NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-RENAMES NULL)
(CL:DEFVAR SGT-HIERARCHY-COLLECTION NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-CLOSURE-ASSUMPTION NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-ALLOCATION NULL)
(CL:DEFVAR KWD-HIERARCHY-INSTANCE NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-GUARD-DEMONS NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-DEMONS NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-ACCESSOR-METHODS NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-REQUIRED? NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-COMPONENT? NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-READ-ONLY? NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-HARDWIRED? NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-CONTEXT-SENSITIVE? NULL)
(CL:DEFVAR SGT-HIERARCHY-STORAGE-SLOT NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-DEFAULT-EXPRESSION NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-READER NULL)
(CL:DEFVAR SYM-HIERARCHY-SLOT-WRITER NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-PARAMETER-DIRECTIONS NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-VARIABLE-ARGUMENTS? NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-BODY-ARGUMENT? NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-NATIVE? NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-GLOBALLY-INLINE? NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-INLINED-FUNCTIONS NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-COMMAND? NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-EVALUATE-ARGUMENTS? NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-LISP-MACRO? NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-SETTER? NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-PARAMETER-NAMES NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-PARAMETER-TYPE-SPECIFIERS NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-RETURN-TYPE-SPECIFIERS NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-FUNCTION-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-FUNCTION? NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-AUXILIARY? NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-DOCUMENTATION NULL)
(CL:DEFVAR SYM-HIERARCHY-METHOD-STORAGE-SLOT NULL)
(CL:DEFVAR SYM-HIERARCHY-STORAGE-SLOT NULL)
(CL:DEFVAR SGT-HIERARCHY-METHOD-SLOT NULL)
(CL:DEFVAR SYM-HIERARCHY-FUNCTION NULL)
(CL:DEFVAR SYM-HIERARCHY-SPECIFIER-BASE-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-SPECIFIER-PARAMETER-TYPES NULL)
(CL:DEFVAR SYM-HIERARCHY-SPECIFIER-SEQUENCE-SIZE NULL)
(CL:DEFVAR SGT-HIERARCHY-PARAMETRIC-TYPE-SPECIFIER NULL)
(CL:DEFVAR *ALL-TRANSIENT-TYPE-SPECIFIER-S* NULL)
(CL:DEFVAR *UNUSED-TRANSIENT-TYPE-SPECIFIER-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-TRANSIENT-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-HIERARCHY-SPECIFIER-PARAMETER-NAME NULL)
(CL:DEFVAR SGT-HIERARCHY-ANCHORED-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-HIERARCHY-VARIABLE-ARITY? NULL)
(CL:DEFVAR SYM-HIERARCHY-TUPLE-DOMAINS NULL)
(CL:DEFVAR SGT-HIERARCHY-TABLE NULL)
(CL:DEFVAR SYM-HIERARCHY-VARIABLE-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-VARIABLE-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-VARIABLE-SPECIAL? NULL)
(CL:DEFVAR SYM-HIERARCHY-VARIABLE-CONSTANT? NULL)
(CL:DEFVAR SYM-HIERARCHY-VARIABLE-PUBLIC? NULL)
(CL:DEFVAR SYM-HIERARCHY-VARIABLE-AUXILIARY? NULL)
(CL:DEFVAR SYM-HIERARCHY-VARIABLE-GET-VALUE-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-VARIABLE-SET-VALUE-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-VARIABLE-VALUE-STACK NULL)
(CL:DEFVAR SYM-HIERARCHY-VARIABLE-DOCUMENTATION NULL)
(CL:DEFVAR SYM-HIERARCHY-VARIABLE-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SGT-HIERARCHY-GLOBAL-VARIABLE NULL)
(CL:DEFVAR SYM-HIERARCHY-QUOTATION-TABLE-OFFSET NULL)
(CL:DEFVAR SGT-HIERARCHY-QUOTED-EXPRESSION NULL)
(CL:DEFVAR SYM-HIERARCHY-CHILD-CONTEXTS NULL)
(CL:DEFVAR SYM-HIERARCHY-ALL-SUPER-CONTEXTS NULL)
(CL:DEFVAR SYM-HIERARCHY-BASE-MODULE NULL)
(CL:DEFVAR SYM-HIERARCHY-CONTEXT-NUMBER NULL)
(CL:DEFVAR SGT-HIERARCHY-MODULE NULL)
(CL:DEFVAR SGT-HIERARCHY-WORLD NULL)
(CL:DEFVAR SYM-HIERARCHY-WORLD-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-SHADOWED-SURROGATES NULL)
(CL:DEFVAR SYM-HIERARCHY-LOGIC-DIALECT NULL)
(CL:DEFVAR KWD-HIERARCHY-KIF NULL)
(CL:DEFVAR SYM-HIERARCHY-CLEARABLE? NULL)
(CL:DEFVAR SYM-HIERARCHY-PARENT-MODULES NULL)
(CL:DEFVAR SYM-HIERARCHY-REQUIRES NULL)
(CL:DEFVAR SYM-HIERARCHY-USES NULL)
(CL:DEFVAR SYM-HIERARCHY-USED-BY NULL)
(CL:DEFVAR SYM-HIERARCHY-MODULE-NATIVE-PACKAGE NULL)
(CL:DEFVAR SYM-HIERARCHY-DIRECTORY-FILE NULL)
(CL:DEFVAR SYM-HIERARCHY-CODE-FILES NULL)
(CL:DEFVAR SYM-HIERARCHY-DEFINITIONS-FILE NULL)
(CL:DEFVAR SYM-HIERARCHY-OPEN-WORLD-ASSUMPTION? NULL)
(CL:DEFVAR SYM-HIERARCHY-CASE-SENSITIVE? NULL)
(CL:DEFVAR SYM-HIERARCHY-MODULE-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-MODULE-FULL-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-MODULE-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-HIERARCHY-STRINGIFIED-OPTIONS NULL)
(CL:DEFVAR SYM-HIERARCHY-CARDINAL-MODULE NULL)
(CL:DEFVAR SYM-HIERARCHY-SYMBOL-OFFSET-TABLE NULL)
(CL:DEFVAR SYM-HIERARCHY-SURROGATE-OFFSET-TABLE NULL)
(CL:DEFVAR SYM-HIERARCHY-INDEXICAL-OFFSET-TABLE NULL)
(CL:DEFVAR SYM-HIERARCHY-ELABORATED-WORLD NULL)
(CL:DEFVAR SYM-HIERARCHY-PARENT-CONTEXT NULL)
(CL:DEFVAR SGT-HIERARCHY-CS-VALUE NULL)
(CL:DEFVAR SGT-HIERARCHY-INTERVAL NULL)
(CL:DEFVAR SYM-HIERARCHY-PARENTS NULL)
(CL:DEFVAR SYM-HIERARCHY-TREE-CHILDREN NULL)
(CL:DEFVAR SYM-HIERARCHY-CHILDREN NULL)
(CL:DEFVAR SYM-HIERARCHY-FIRST-INTERVAL-LOWER-BOUND NULL)
(CL:DEFVAR SYM-HIERARCHY-FIRST-INTERVAL-UPPER-BOUND NULL)
(CL:DEFVAR SYM-HIERARCHY-INITIAL-INTERVAL NULL)
(CL:DEFVAR SYM-HIERARCHY-INTERVALS NULL)
(CL:DEFVAR SYM-HIERARCHY-TOTAL-ANCESTORS NULL)
(CL:DEFVAR SYM-HIERARCHY-LABEL NULL)
(CL:DEFVAR SYM-HIERARCHY-NATIVE-OBJECT NULL)
(CL:DEFVAR SGT-HIERARCHY-TAXONOMY-NODE NULL)
(CL:DEFVAR SYM-HIERARCHY-INCREMENTAL-MODE? NULL)
(CL:DEFVAR SYM-HIERARCHY-RENUMBER-IF-OUT-OF-NUMBERS? NULL)
(CL:DEFVAR SYM-HIERARCHY-LARGEST-POSTORDER-NUMBER NULL)
(CL:DEFVAR SYM-HIERARCHY-ROOTS NULL)
(CL:DEFVAR SYM-HIERARCHY-BROKEN-LINKS NULL)
(CL:DEFVAR SGT-HIERARCHY-TAXONOMY-GRAPH NULL)
(CL:DEFVAR SGT-HIERARCHY-EXCEPTION NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-EXCEPTION NULL)
(CL:DEFVAR SGT-HIERARCHY-READ-EXCEPTION NULL)
(CL:DEFVAR SGT-HIERARCHY-UNHANDLED-EXCEPTION NULL)
(CL:DEFVAR SYM-HIERARCHY-FILE-NAME NULL)
(CL:DEFVAR *RECYCLED-INTEGER-WRAPPER-S* NULL)
(CL:DEFVAR SYM-HIERARCHY-WRAPPER-VALUE NULL)
(CL:DEFVAR SGT-HIERARCHY-INTEGER-WRAPPER NULL)
(CL:DEFVAR *RECYCLED-FLOAT-WRAPPER-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-FLOAT-WRAPPER NULL)
(CL:DEFVAR *RECYCLED-STRING-WRAPPER-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-STRING-WRAPPER NULL)
(CL:DEFVAR *RECYCLED-CHARACTER-WRAPPER-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-CHARACTER-WRAPPER NULL)
(CL:DEFVAR SGT-HIERARCHY-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SYM-HIERARCHY-NULL-BOOLEAN NULL)
(CL:DEFVAR SYM-HIERARCHY-TRUE NULL)
(CL:DEFVAR SYM-HIERARCHY-FALSE NULL)
(CL:DEFVAR *RECYCLED-FUNCTION-CODE-WRAPPER-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-FUNCTION-CODE-WRAPPER NULL)
(CL:DEFVAR *RECYCLED-METHOD-CODE-WRAPPER-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-METHOD-CODE-WRAPPER NULL)
(CL:DEFVAR *ALL-TRANSIENT-INTEGER-WRAPPER-S* NULL)
(CL:DEFVAR *UNUSED-TRANSIENT-INTEGER-WRAPPER-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-TRANSIENT-INTEGER-WRAPPER NULL)
(CL:DEFVAR *ALL-TRANSIENT-FLOAT-WRAPPER-S* NULL)
(CL:DEFVAR *UNUSED-TRANSIENT-FLOAT-WRAPPER-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-TRANSIENT-FLOAT-WRAPPER NULL)
(CL:DEFVAR *RECYCLED-TRANSIENT-STRING-WRAPPER-S* NULL)
(CL:DEFVAR *ALL-TRANSIENT-STRING-WRAPPER-S* NULL)
(CL:DEFVAR *UNUSED-TRANSIENT-STRING-WRAPPER-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-TRANSIENT-STRING-WRAPPER NULL)
(CL:DEFVAR *ALL-TRANSIENT-CHARACTER-WRAPPER-S* NULL)
(CL:DEFVAR *UNUSED-TRANSIENT-CHARACTER-WRAPPER-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-TRANSIENT-CHARACTER-WRAPPER NULL)
(CL:DEFVAR *ALL-TRANSIENT-FUNCTION-CODE-WRAPPER-S* NULL)
(CL:DEFVAR *UNUSED-TRANSIENT-FUNCTION-CODE-WRAPPER-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-TRANSIENT-FUNCTION-CODE-WRAPPER NULL)
(CL:DEFVAR *ALL-TRANSIENT-METHOD-CODE-WRAPPER-S* NULL)
(CL:DEFVAR *UNUSED-TRANSIENT-METHOD-CODE-WRAPPER-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-TRANSIENT-METHOD-CODE-WRAPPER NULL)
(CL:DEFVAR *ALL-VERBATIM-STRING-WRAPPER-S* NULL)
(CL:DEFVAR *UNUSED-VERBATIM-STRING-WRAPPER-S* NULL)
(CL:DEFVAR SGT-HIERARCHY-VERBATIM-STRING-WRAPPER NULL)
(CL:DEFVAR SYM-HIERARCHY-ARGUMENT-LIST NULL)
(CL:DEFVAR SGT-HIERARCHY-LISP-CONS-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STATE NULL)
(CL:DEFVAR SGT-HIERARCHY-OUTPUT-STREAM NULL)
(CL:DEFVAR SGT-HIERARCHY-INPUT-STREAM NULL)
(CL:DEFVAR KWD-HIERARCHY-SUPERSEDE NULL)
(CL:DEFVAR SYM-HIERARCHY-FILENAME NULL)
(CL:DEFVAR SYM-HIERARCHY-IF-EXISTS-ACTION NULL)
(CL:DEFVAR SGT-HIERARCHY-OUTPUT-FILE-STREAM NULL)
(CL:DEFVAR KWD-HIERARCHY-ERROR NULL)
(CL:DEFVAR SYM-HIERARCHY-IF-NOT-EXISTS-ACTION NULL)
(CL:DEFVAR SGT-HIERARCHY-INPUT-FILE-STREAM NULL)
(CL:DEFVAR SGT-HIERARCHY-OUTPUT-STRING-STREAM NULL)
(CL:DEFVAR SGT-HIERARCHY-INPUT-STRING-STREAM NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *STELLA-MODULE*
  *UNUSED-VERBATIM-STRING-WRAPPER-S*
  *ALL-VERBATIM-STRING-WRAPPER-S*
  *UNUSED-TRANSIENT-METHOD-CODE-WRAPPER-S*
  *ALL-TRANSIENT-METHOD-CODE-WRAPPER-S*
  *UNUSED-TRANSIENT-FUNCTION-CODE-WRAPPER-S*
  *ALL-TRANSIENT-FUNCTION-CODE-WRAPPER-S*
  *UNUSED-TRANSIENT-CHARACTER-WRAPPER-S*
  *ALL-TRANSIENT-CHARACTER-WRAPPER-S*
  *RECYCLED-TRANSIENT-STRING-WRAPPER-S*
  *UNUSED-TRANSIENT-STRING-WRAPPER-S*
  *ALL-TRANSIENT-STRING-WRAPPER-S*
  *UNUSED-TRANSIENT-FLOAT-WRAPPER-S*
  *ALL-TRANSIENT-FLOAT-WRAPPER-S*
  *UNUSED-TRANSIENT-INTEGER-WRAPPER-S*
  *ALL-TRANSIENT-INTEGER-WRAPPER-S*
  *RECYCLED-METHOD-CODE-WRAPPER-S*
  *RECYCLED-FUNCTION-CODE-WRAPPER-S*
  *RECYCLED-CHARACTER-WRAPPER-S*
  *RECYCLED-STRING-WRAPPER-S*
  *RECYCLED-FLOAT-WRAPPER-S*
  *PRINTREADABLY?*
  *RECYCLED-INTEGER-WRAPPER-S*
  *UNUSED-TRANSIENT-TYPE-SPECIFIER-S*
  *ALL-TRANSIENT-TYPE-SPECIFIER-S*
  NULL-STRING-WRAPPER
  *HARDWIRED-CLASS-ARITY-ON-CLASS*
  NIL-LIST
  *MODULE*
  *HARDWIRED-RESIZE-INCREMENT-ON-SHORT-VECTOR-SEQUENCE*
  *HARDWIRED-RESIZE-INCREMENT-ON-VECTOR-SEQUENCE*
  *RECYCLED-TRANSIENT-CONS-S*
  *UNUSED-TRANSIENT-CONS-S*
  *ALL-TRANSIENT-CONS-S*
  *RECYCLED-CONS-S*
  *RECYCLED-SET-S*
  *RECYCLED-LIST-S*
  NULL-BOOLEAN-WRAPPER
  *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN*))

;;; (DEFCLASS OBJECT ...)

(CL:DEFCLASS OBJECT ()
  ()
  (:DOCUMENTATION
   "A reflective object that can participate in dynamically-typed
contexts.  Either a STANDARD-OBJECT or a WRAPPER or a GENERIC-OBJECT.
Also, either an OBJECT-WITH-INHERITED-TYPE or an OBJECT-WITH-OWN-TYPE."))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF OBJECT))
  "Returns the primary type of 'self'.
Gets defined automatically for every non-abstract subclass of OBJECT."
  (CL:RETURN-FROM PRIMARY-TYPE NULL)
  :VOID)

(CL:DEFMETHOD INCREMENT-REFERENCE-COUNT ((SELF OBJECT))
  NULL
  :VOID)

(CL:DEFMETHOD DECREMENT-REFERENCE-COUNT ((SELF OBJECT))
  NULL
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF OBJECT) STREAM)
  (CL:PROGN
   (CL:WRITE-STRING "|i|" STREAM)
   (PRINT-OBJECT (PRIMARY-TYPE SELF) STREAM))
  :VOID)

;;; (DEFCLASS STANDARD-OBJECT ...)

(CL:DEFCLASS STANDARD-OBJECT (OBJECT)
  ()
  (:DOCUMENTATION
   "Object that used to find its type stored in a :class slot.
By reimplementing 'primary-type' as a method, the justification for this
class went away, but we'll keep it for now to keep things working."))

;;; (DEFCLASS TRANSIENT-MIXIN ...)

(CL:DEFCLASS TRANSIENT-MIXIN ()
  ()
  (:DOCUMENTATION
   "Transient objects are periodically swept back into a pool
of free objects.  A transient object should never be pointed at by a
permanent object."))

(CL:DEFMETHOD TRANSIENT? ((SELF TRANSIENT-MIXIN))
  (CL:RETURN-FROM TRANSIENT? *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN*)
  :VOID)

;;; (DEFCLASS REFERENCE-COUNT-OBJECT ...)

(CL:DEFCLASS REFERENCE-COUNT-OBJECT (OBJECT)
  ((REFERENCE-COUNT :ALLOCATION :INSTANCE :ACCESSOR REFERENCE-COUNT...OF))
  (:DOCUMENTATION
   "A reference count objects contains a slot 'reference-count' 
that is incremented whenever the object is assigned to a slot, and decremented
whenever it is deassigned from a slot."))

(CL:DEFUN ACCESS-REFERENCE-COUNT-OBJECT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-REFERENCE-COUNT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL REFERENCE-COUNT-OBJECT REFERENCE-COUNT SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-REFERENCE-COUNT-OBJECT-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL REFERENCE-COUNT-OBJECT REFERENCE-COUNT SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-REFERENCE-COUNT-OBJECT-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD INCREMENT-REFERENCE-COUNT ((SELF REFERENCE-COUNT-OBJECT))
  (CL:SETF
   (CLSYS-SVAL REFERENCE-COUNT-OBJECT REFERENCE-COUNT SELF)
   (CL:1+ (CLSYS-SVAL REFERENCE-COUNT-OBJECT REFERENCE-COUNT SELF)))
  :VOID)

(CL:DEFMETHOD DECREMENT-REFERENCE-COUNT ((SELF REFERENCE-COUNT-OBJECT))
  (CL:SETF
   (CLSYS-SVAL REFERENCE-COUNT-OBJECT REFERENCE-COUNT SELF)
   (CL:1- (CLSYS-SVAL REFERENCE-COUNT-OBJECT REFERENCE-COUNT SELF)))
  :VOID)

;;; (DEFCLASS DYNAMIC-SLOTS-MIXIN ...)

(CL:DEFCLASS DYNAMIC-SLOTS-MIXIN ()
  ((DYNAMIC-SLOTS :ALLOCATION :INSTANCE :ACCESSOR DYNAMIC-SLOTS...OF)
   (BITS :ALLOCATION :INSTANCE :ACCESSOR BITS...OF))
  (:DOCUMENTATION
   "For system use only.  Object that can store
slot values in non-preallocated storage."))

(CL:DEFMETHOD BAD? ((SELF DYNAMIC-SLOTS-MIXIN))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-BAD? NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM BAD? FALSE)
    (CL:RETURN-FROM BAD? ANSWER)))
  :VOID)

;;; (DEFCLASS CONTEXT-SENSITIVE-OBJECT ...)

(CL:DEFCLASS CONTEXT-SENSITIVE-OBJECT (STANDARD-OBJECT)
  ((HOME-CONTEXT :ALLOCATION :INSTANCE :ACCESSOR HOME-CONTEXT...OF))
  (:DOCUMENTATION
   "Context sensitive objects inherit a slot 'home-context'
that enables context-dependent access machinery to determine the
visibility of objects from modules."))

(CL:DEFUN ACCESS-CONTEXT-SENSITIVE-OBJECT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-HOME-CONTEXT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CONTEXT-SENSITIVE-OBJECT HOME-CONTEXT SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-CONTEXT-SENSITIVE-OBJECT-SLOT-VALUE
      (CLSYS-SVAL CONTEXT-SENSITIVE-OBJECT HOME-CONTEXT SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-CONTEXT-SENSITIVE-OBJECT-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD HOME-MODULE ((SELF CONTEXT-SENSITIVE-OBJECT))
  (CL:RETURN-FROM
   HOME-MODULE
   (CLSYS-SVAL CONTEXT-SENSITIVE-OBJECT HOME-CONTEXT SELF))
  :VOID)

;;; (DEFCLASS ACTIVE-OBJECT ...)

(CL:DEFCLASS ACTIVE-OBJECT (CONTEXT-SENSITIVE-OBJECT DYNAMIC-SLOTS-MIXIN)
  ()
  (:DOCUMENTATION
   "Active objects call class and slot triggers in response
to instance creation/destruction and slot updates.  They include internal
storage slots needed for class extensions, dynamic storage, and home context."))

(CL:DEFUN ACCESS-ACTIVE-OBJECT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL ACTIVE-OBJECT DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-ACTIVE-OBJECT-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL ACTIVE-OBJECT DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-ACTIVE-OBJECT-SLOT-VALUE VALUE))
  :VOID)

;;; (DEFCLASS ABSTRACT-ITERATOR ...)

(CL:DEFCLASS ABSTRACT-ITERATOR (STANDARD-OBJECT)
  ((FIRST-ITERATION? :ALLOCATION :INSTANCE :ACCESSOR FIRST-ITERATION?...OF))
  (:DOCUMENTATION
   "Instances of ABSTRACT-ITERATOR support iteration over collections."))

(CL:DEFUN ACCESS-ABSTRACT-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-FIRST-ITERATION?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL ABSTRACT-ITERATOR FIRST-ITERATION? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-ABSTRACT-ITERATOR-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL ABSTRACT-ITERATOR FIRST-ITERATION? SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-ABSTRACT-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD NEXT? ((SELF ABSTRACT-ITERATOR))
  (CL:RETURN-FROM NEXT? FALSE)
  :VOID)

;;; (DEFCLASS ITERATOR ...)

(CL:DEFCLASS ITERATOR (ABSTRACT-ITERATOR)
  ((VALUE :ALLOCATION :INSTANCE :ACCESSOR VALUE...OF))
  (:DOCUMENTATION
   "Instances of ITERATOR support iteration over 
collections of OBJECTs."))

;;; (DEFCLASS CONS-ITERATOR ...)

(CL:DEFCLASS CONS-ITERATOR (ITERATOR)
  ((CONS-ITERATOR-CURSOR
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CONS-ITERATOR-CURSOR...OF))
  (:DOCUMENTATION "Iterator class for the class CONS."))

(CL:DEFUN NEW-CONS-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CONS-ITERATOR)))
   (CL:SETF (CLSYS-SVAL CONS-ITERATOR FIRST-ITERATION? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL CONS-ITERATOR VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL CONS-ITERATOR CONS-ITERATOR-CURSOR SELF) NULL)
   (CL:RETURN-FROM NEW-CONS-ITERATOR SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF CONS-ITERATOR))
  (CL:WHEN (CL:EQ (TERMINATE-CONS-ITERATOR? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFUN ACCESS-CONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CONS-ITERATOR-CURSOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CONS-ITERATOR CONS-ITERATOR-CURSOR SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-CONS-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL CONS-ITERATOR CONS-ITERATOR-CURSOR SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-CONS-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CONS-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-CONS-ITERATOR)
  :VOID)

;;; (DEFCLASS LIST-ITERATOR ...)

(CL:DEFCLASS LIST-ITERATOR (ITERATOR)
  ((LIST-ITERATOR-CURSOR
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    LIST-ITERATOR-CURSOR...OF)
   (LIST-ITERATOR-COLLECTION
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    LIST-ITERATOR-COLLECTION...OF))
  (:DOCUMENTATION "Iterator class for the collection LIST."))

(CL:DEFUN NEW-LIST-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE LIST-ITERATOR)))
   (CL:SETF (CLSYS-SVAL LIST-ITERATOR FIRST-ITERATION? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL LIST-ITERATOR VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-COLLECTION SELF) NULL)
   (CL:SETF (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-CURSOR SELF) NULL)
   (CL:RETURN-FROM NEW-LIST-ITERATOR SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF LIST-ITERATOR))
  (CL:WHEN (CL:EQ (TERMINATE-LIST-ITERATOR? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFUN ACCESS-LIST-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-LIST-ITERATOR-CURSOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-CURSOR SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-LIST-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-CURSOR SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-LIST-ITERATOR-COLLECTION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-COLLECTION SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-LIST-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL LIST-ITERATOR LIST-ITERATOR-COLLECTION SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-LIST-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LIST-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-LIST-ITERATOR)
  :VOID)

;;; (DEFCLASS DESTRUCTIVE-LIST-ITERATOR ...)

(CL:DEFCLASS DESTRUCTIVE-LIST-ITERATOR (ITERATOR)
  ((THE-CONS-LIST :ALLOCATION :INSTANCE :ACCESSOR THE-CONS-LIST...OF)
   (LIST-ITERATOR-CURSOR
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    LIST-ITERATOR-CURSOR...OF))
  (:DOCUMENTATION
   "An iterator that contains a cons list.  Iterates over
the stored list, and destroys it when the iterator is free'd."))

(CL:DEFUN NEW-DESTRUCTIVE-LIST-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE DESTRUCTIVE-LIST-ITERATOR)))
   (CL:SETF (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR FIRST-ITERATION? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR VALUE SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR LIST-ITERATOR-CURSOR SELF)
    NULL)
   (CL:SETF (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM NEW-DESTRUCTIVE-LIST-ITERATOR SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF DESTRUCTIVE-LIST-ITERATOR))
  (CL:WHEN (CL:EQ (TERMINATE-DESTRUCTIVE-LIST-ITERATOR? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFUN ACCESS-DESTRUCTIVE-LIST-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-THE-CONS-LIST)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR THE-CONS-LIST SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-DESTRUCTIVE-LIST-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR THE-CONS-LIST SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-LIST-ITERATOR-CURSOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR LIST-ITERATOR-CURSOR SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-DESTRUCTIVE-LIST-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL DESTRUCTIVE-LIST-ITERATOR LIST-ITERATOR-CURSOR SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-DESTRUCTIVE-LIST-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DESTRUCTIVE-LIST-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-DESTRUCTIVE-LIST-ITERATOR)
  :VOID)

;;; (DEFCLASS SET-ITERATOR ...)

(CL:DEFCLASS SET-ITERATOR (ITERATOR)
  ((SET-ITERATOR-CURSOR
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SET-ITERATOR-CURSOR...OF)
   (SET-ITERATOR-COLLECTION
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SET-ITERATOR-COLLECTION...OF))
  (:DOCUMENTATION "Iterator class for the collection SET."))

(CL:DEFUN NEW-SET-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SET-ITERATOR)))
   (CL:SETF (CLSYS-SVAL SET-ITERATOR FIRST-ITERATION? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL SET-ITERATOR VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-COLLECTION SELF) NULL)
   (CL:SETF (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-CURSOR SELF) NULL)
   (CL:RETURN-FROM NEW-SET-ITERATOR SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF SET-ITERATOR))
  (CL:WHEN (CL:EQ (TERMINATE-SET-ITERATOR? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFUN ACCESS-SET-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SET-ITERATOR-CURSOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-CURSOR SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-SET-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-CURSOR SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SET-ITERATOR-COLLECTION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-COLLECTION SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-SET-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL SET-ITERATOR SET-ITERATOR-COLLECTION SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-SET-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SET-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-SET-ITERATOR)
  :VOID)

;;; (DEFCLASS ALL-PURPOSE-ITERATOR ...)

(CL:DEFCLASS ALL-PURPOSE-ITERATOR (ITERATOR)
  ((KEY :ALLOCATION :INSTANCE :ACCESSOR KEY...OF)
   (ITERATOR-NEXT-CODE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    ITERATOR-NEXT-CODE...OF)
   (ITERATOR-FILTER-CODE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    ITERATOR-FILTER-CODE...OF)
   (ITERATOR-EMPTY-CODE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    ITERATOR-EMPTY-CODE...OF)
   (ITERATOR-NESTED-ITERATOR
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    ITERATOR-NESTED-ITERATOR...OF)
   (ITERATOR-OBJECT :ALLOCATION :INSTANCE :ACCESSOR ITERATOR-OBJECT...OF)
   (ITERATOR-SECOND-OBJECT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    ITERATOR-SECOND-OBJECT...OF)
   (ITERATOR-INTEGER :ALLOCATION :INSTANCE :ACCESSOR ITERATOR-INTEGER...OF)
   (ITERATOR-SECOND-INTEGER
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    ITERATOR-SECOND-INTEGER...OF)
   (ITERATOR-CONS-LIST :ALLOCATION :INSTANCE :ACCESSOR ITERATOR-CONS-LIST...OF))
  (:DOCUMENTATION
   "The all-purpose iterator works by storing a 'next?'
function within itself during iterator allocation.  The method
'ALL-PURPOSE-ITERAOR.next?' funcalls the stored 'next?' function.
An assortment of storage slots are provided for constructing different
kinds of iterators."))

(CL:DEFUN NEW-ALL-PURPOSE-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE ALL-PURPOSE-ITERATOR)))
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR FIRST-ITERATION? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-INTEGER SELF)
    NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF)
    NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-OBJECT SELF)
    NULL)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF)
    NULL)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-EMPTY-CODE SELF) NULL)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF) NULL)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE SELF) NULL)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR KEY SELF) NULL)
   (CL:RETURN-FROM NEW-ALL-PURPOSE-ITERATOR SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF ALL-PURPOSE-ITERATOR))
  (CL:WHEN (CL:EQ (TERMINATE-ALL-PURPOSE-ITERATOR? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFUN ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-KEY)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR KEY SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR KEY SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ITERATOR-NEXT-CODE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE SELF)
      (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ITERATOR-FILTER-CODE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)
      (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ITERATOR-EMPTY-CODE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-EMPTY-CODE SELF)
      (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-EMPTY-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ITERATOR-NESTED-ITERATOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ITERATOR-OBJECT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ITERATOR-SECOND-OBJECT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-OBJECT SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-OBJECT SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ITERATOR-INTEGER)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ITERATOR-SECOND-INTEGER)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-INTEGER SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-INTEGER SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ITERATOR-CONS-LIST)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ALL-PURPOSE-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-ALL-PURPOSE-ITERATOR)
  :VOID)

;;; (DEFCLASS TYPES-TO-CLASSES-ITERATOR ...)

(CL:DEFCLASS TYPES-TO-CLASSES-ITERATOR (ITERATOR)
  ((ITERATOR-CURSOR :ALLOCATION :INSTANCE :ACCESSOR ITERATOR-CURSOR...OF))
  (:DOCUMENTATION
   "Iterator that returns a class for each type
in a cons list of types."))

(CL:DEFUN NEW-TYPES-TO-CLASSES-ITERATOR (ITERATOR-CURSOR)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TYPES-TO-CLASSES-ITERATOR)))
   (CL:SETF (CLSYS-SVAL TYPES-TO-CLASSES-ITERATOR FIRST-ITERATION? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL TYPES-TO-CLASSES-ITERATOR VALUE SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL TYPES-TO-CLASSES-ITERATOR ITERATOR-CURSOR SELF)
    ITERATOR-CURSOR)
   (CL:RETURN-FROM NEW-TYPES-TO-CLASSES-ITERATOR SELF))
  :VOID)

(CL:DEFUN ACCESS-TYPES-TO-CLASSES-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ITERATOR-CURSOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TYPES-TO-CLASSES-ITERATOR ITERATOR-CURSOR SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-TYPES-TO-CLASSES-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL TYPES-TO-CLASSES-ITERATOR ITERATOR-CURSOR SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-TYPES-TO-CLASSES-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TYPES-TO-CLASSES-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-TYPES-TO-CLASSES-ITERATOR)
  :VOID)

(CL:DEFMETHOD NEXT? ((SELF TYPES-TO-CLASSES-ITERATOR))
  (CL:IF
   (CL:EQ (CLSYS-SVAL TYPES-TO-CLASSES-ITERATOR FIRST-ITERATION? SELF) 1)
   (CL:SETF
    (CLSYS-SVAL TYPES-TO-CLASSES-ITERATOR FIRST-ITERATION? SELF)
    FALSE)
   (CL:SETF
    (CLSYS-SVAL TYPES-TO-CLASSES-ITERATOR ITERATOR-CURSOR SELF)
    (CLSYS-SVAL
     CONS
     REST
     (CLSYS-SVAL TYPES-TO-CLASSES-ITERATOR ITERATOR-CURSOR SELF))))
  (CL:COND
   ((CL:NOT
     (CL:EQ (CLSYS-SVAL TYPES-TO-CLASSES-ITERATOR ITERATOR-CURSOR SELF) NIL))
    (CL:SETF
     (CLSYS-SVAL TYPES-TO-CLASSES-ITERATOR VALUE SELF)
     (CLSYS-SVAL
      SURROGATE
      SURROGATE-VALUE
      (FIRST (CLSYS-SVAL TYPES-TO-CLASSES-ITERATOR ITERATOR-CURSOR SELF))))
    (CL:RETURN-FROM NEXT? TRUE))
   (CL:T (CL:RETURN-FROM NEXT? FALSE)))
  :VOID)

;;; (DEFCLASS ABSTRACT-DICTIONARY-ITERATOR ...)

(CL:DEFCLASS ABSTRACT-DICTIONARY-ITERATOR (ABSTRACT-ITERATOR)
  ()
  (:DOCUMENTATION
   "Instances of ABSTRACT-DICTIONARY-ITERATOR support iteration
over dictionaries."))

;;; (DEFCLASS DICTIONARY-ITERATOR ...)

(CL:DEFCLASS DICTIONARY-ITERATOR (ABSTRACT-DICTIONARY-ITERATOR)
  ((KEY :ALLOCATION :INSTANCE :ACCESSOR KEY...OF)
   (VALUE :ALLOCATION :INSTANCE :ACCESSOR VALUE...OF))
  (:DOCUMENTATION
   "Instances of DICTIONARY-ITERATOR support iteration
over dictionaries with keys and values of type OBJECT."))

;;; (DEFCLASS PROPERTY-LIST-ITERATOR ...)

(CL:DEFCLASS PROPERTY-LIST-ITERATOR (DICTIONARY-ITERATOR)
  ((PLIST-ITERATOR-CURSOR
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    PLIST-ITERATOR-CURSOR...OF)
   (PLIST-ITERATOR-COLLECTION
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    PLIST-ITERATOR-COLLECTION...OF))
  (:DOCUMENTATION "Iterator class for the collection PROPERTY-LIST."))

(CL:DEFUN NEW-PROPERTY-LIST-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PROPERTY-LIST-ITERATOR)))
   (CL:SETF (CLSYS-SVAL PROPERTY-LIST-ITERATOR FIRST-ITERATION? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL PROPERTY-LIST-ITERATOR VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL PROPERTY-LIST-ITERATOR KEY SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL PROPERTY-LIST-ITERATOR PLIST-ITERATOR-COLLECTION SELF)
    NULL)
   (CL:SETF
    (CLSYS-SVAL PROPERTY-LIST-ITERATOR PLIST-ITERATOR-CURSOR SELF)
    NULL)
   (CL:RETURN-FROM NEW-PROPERTY-LIST-ITERATOR SELF))
  :VOID)

(CL:DEFUN ACCESS-PROPERTY-LIST-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-PLIST-ITERATOR-CURSOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL PROPERTY-LIST-ITERATOR PLIST-ITERATOR-CURSOR SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-PROPERTY-LIST-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL PROPERTY-LIST-ITERATOR PLIST-ITERATOR-CURSOR SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-PLIST-ITERATOR-COLLECTION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL PROPERTY-LIST-ITERATOR PLIST-ITERATOR-COLLECTION SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-PROPERTY-LIST-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL PROPERTY-LIST-ITERATOR PLIST-ITERATOR-COLLECTION SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-PROPERTY-LIST-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PROPERTY-LIST-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-PROPERTY-LIST-ITERATOR)
  :VOID)

;;; (DEFCLASS KV-LIST-ITERATOR ...)

(CL:DEFCLASS KV-LIST-ITERATOR (DICTIONARY-ITERATOR)
  ((THE-KV-LIST :ALLOCATION :INSTANCE :ACCESSOR THE-KV-LIST...OF)
   (KV-LIST-ITERATOR-CURSOR
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    KV-LIST-ITERATOR-CURSOR...OF)))

(CL:DEFUN NEW-KV-LIST-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE KV-LIST-ITERATOR)))
   (CL:SETF (CLSYS-SVAL KV-LIST-ITERATOR FIRST-ITERATION? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL KV-LIST-ITERATOR VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL KV-LIST-ITERATOR KEY SELF) NULL)
   (CL:SETF (CLSYS-SVAL KV-LIST-ITERATOR KV-LIST-ITERATOR-CURSOR SELF) NULL)
   (CL:SETF (CLSYS-SVAL KV-LIST-ITERATOR THE-KV-LIST SELF) NULL)
   (CL:RETURN-FROM NEW-KV-LIST-ITERATOR SELF))
  :VOID)

(CL:DEFUN ACCESS-KV-LIST-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-THE-KV-LIST)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL KV-LIST-ITERATOR THE-KV-LIST SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-KV-LIST-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL KV-LIST-ITERATOR THE-KV-LIST SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-KV-LIST-ITERATOR-CURSOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL KV-LIST-ITERATOR KV-LIST-ITERATOR-CURSOR SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-KV-LIST-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL KV-LIST-ITERATOR KV-LIST-ITERATOR-CURSOR SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-KV-LIST-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF KV-LIST-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-KV-LIST-ITERATOR)
  :VOID)

;;; (DEFCLASS INTERVAL-ITERATOR ...)

(CL:DEFCLASS INTERVAL-ITERATOR (ABSTRACT-ITERATOR)
  ()
  (:DOCUMENTATION
   "An iterator that specifies a (possibly infinite) range of
values.  Supports 'member?' test as well as iteration methods."))

;;; (DEFCLASS INTEGER-INTERVAL-ITERATOR ...)

(CL:DEFCLASS INTEGER-INTERVAL-ITERATOR (INTERVAL-ITERATOR)
  ((INTERVAL-CURSOR :ALLOCATION :INSTANCE :ACCESSOR INTERVAL-CURSOR...OF)
   (LOWER-BOUND :ALLOCATION :INSTANCE :ACCESSOR LOWER-BOUND...OF)
   (UPPER-BOUND :ALLOCATION :INSTANCE :ACCESSOR UPPER-BOUND...OF)
   (VALUE :ALLOCATION :INSTANCE :ACCESSOR VALUE...OF)))

(CL:DEFUN NEW-INTEGER-INTERVAL-ITERATOR (LOWER-BOUND UPPER-BOUND)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INTEGER-INTERVAL-ITERATOR)))
   (CL:SETF (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR FIRST-ITERATION? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR VALUE SELF) NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF)
    NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR LOWER-BOUND SELF)
    LOWER-BOUND)
   (CL:SETF
    (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR UPPER-BOUND SELF)
    UPPER-BOUND)
   (INITIALIZE-INTEGER-INTERVAL-ITERATOR SELF)
   (CL:RETURN-FROM NEW-INTEGER-INTERVAL-ITERATOR SELF))
  :VOID)

(CL:DEFUN ACCESS-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-INTERVAL-CURSOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-LOWER-BOUND)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR LOWER-BOUND SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR LOWER-BOUND SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-UPPER-BOUND)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR UPPER-BOUND SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL INTEGER-INTERVAL-ITERATOR UPPER-BOUND SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INTEGER-INTERVAL-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-INTEGER-INTERVAL-ITERATOR)
  :VOID)

;;; (DEFCLASS REVERSE-INTEGER-INTERVAL-ITERATOR ...)

(CL:DEFCLASS REVERSE-INTEGER-INTERVAL-ITERATOR (INTERVAL-ITERATOR)
  ((INTERVAL-CURSOR :ALLOCATION :INSTANCE :ACCESSOR INTERVAL-CURSOR...OF)
   (LOWER-BOUND :ALLOCATION :INSTANCE :ACCESSOR LOWER-BOUND...OF)
   (UPPER-BOUND :ALLOCATION :INSTANCE :ACCESSOR UPPER-BOUND...OF)
   (VALUE :ALLOCATION :INSTANCE :ACCESSOR VALUE...OF)))

(CL:DEFUN NEW-REVERSE-INTEGER-INTERVAL-ITERATOR (LOWER-BOUND UPPER-BOUND)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ
    SELF
    (CL:MAKE-INSTANCE (CL:QUOTE REVERSE-INTEGER-INTERVAL-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR FIRST-ITERATION? SELF)
    TRUE)
   (CL:SETF
    (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR VALUE SELF)
    NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF)
    NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR LOWER-BOUND SELF)
    LOWER-BOUND)
   (CL:SETF
    (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR UPPER-BOUND SELF)
    UPPER-BOUND)
   (INITIALIZE-REVERSE-INTEGER-INTERVAL-ITERATOR SELF)
   (CL:RETURN-FROM NEW-REVERSE-INTEGER-INTERVAL-ITERATOR SELF))
  :VOID)

(CL:DEFUN ACCESS-REVERSE-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-INTERVAL-CURSOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-REVERSE-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR INTERVAL-CURSOR SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-LOWER-BOUND)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR LOWER-BOUND SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-REVERSE-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR LOWER-BOUND SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-UPPER-BOUND)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR UPPER-BOUND SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-REVERSE-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR UPPER-BOUND SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-REVERSE-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF REVERSE-INTEGER-INTERVAL-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-REVERSE-INTEGER-INTERVAL-ITERATOR)
  :VOID)

;;; (DEFCLASS STRING-ITERATOR ...)

(CL:DEFCLASS STRING-ITERATOR (ABSTRACT-ITERATOR)
  ((THE-STRING :ALLOCATION :INSTANCE :ACCESSOR THE-STRING...OF)
   (CURSOR :ALLOCATION :INSTANCE :ACCESSOR CURSOR...OF)
   (END :ALLOCATION :INSTANCE :ACCESSOR END...OF)
   (VALUE :ALLOCATION :INSTANCE :ACCESSOR VALUE...OF))
  (:DOCUMENTATION "Iterator that yields characters from a string."))

(CL:DEFUN NEW-STRING-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STRING-ITERATOR)))
   (CL:SETF (CLSYS-SVAL STRING-ITERATOR FIRST-ITERATION? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL STRING-ITERATOR VALUE SELF) NULL-CHARACTER)
   (CL:SETF (CLSYS-SVAL STRING-ITERATOR END SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL STRING-ITERATOR CURSOR SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL STRING-ITERATOR THE-STRING SELF) NULL)
   (CL:RETURN-FROM NEW-STRING-ITERATOR SELF))
  :VOID)

(CL:DEFUN ACCESS-STRING-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-THE-STRING)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL STRING-ITERATOR THE-STRING SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-STRING-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL STRING-ITERATOR THE-STRING SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CURSOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL STRING-ITERATOR CURSOR SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-STRING-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL STRING-ITERATOR CURSOR SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-END)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL STRING-ITERATOR END SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-STRING-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL STRING-ITERATOR END SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-STRING-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STRING-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STRING-ITERATOR)
  :VOID)

;;; (DEFCLASS ABSTRACT-COLLECTION ...)

(CL:DEFCLASS ABSTRACT-COLLECTION (STANDARD-OBJECT)
  ())

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF ABSTRACT-COLLECTION))
  (CL:RETURN-FROM ALLOCATE-ITERATOR NULL)
  :VOID)

(CL:DEFMETHOD LENGTH ((SELF ABSTRACT-COLLECTION))
  (CL:RETURN-FROM LENGTH NULL-INTEGER)
  :VOID)

;;; (DEFCLASS COLLECTION ...)

(CL:DEFCLASS COLLECTION (ABSTRACT-COLLECTION)
  ())

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF COLLECTION))
  (CL:RETURN-FROM ALLOCATE-ITERATOR NULL)
  :VOID)

(CL:DEFMETHOD LENGTH ((SELF COLLECTION))
  (CL:RETURN-FROM LENGTH NULL-INTEGER)
  :VOID)

(CL:DEFMETHOD INSERT ((SELF COLLECTION) VALUE)
  (CL:RETURN-FROM INSERT)
  :VOID)

(CL:DEFMETHOD REMOVE ((SELF COLLECTION) VALUE)
  (CL:RETURN-FROM REMOVE NULL)
  :VOID)

;;; (DEFCLASS SET-MIXIN ...)

(CL:DEFCLASS SET-MIXIN ()
  ()
  (:DOCUMENTATION
   "Users of this mixin check for duplicates inside of 
the method 'insert'."))

;;; (DEFCLASS SEQUENCE-MIXIN ...)

(CL:DEFCLASS SEQUENCE-MIXIN ()
  ())

;;; (DEFCLASS SEQUENCE ...)

(CL:DEFCLASS SEQUENCE (COLLECTION SEQUENCE-MIXIN)
  ())

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF SEQUENCE))
  (CL:RETURN-FROM ALLOCATE-ITERATOR NULL)
  :VOID)

(CL:DEFMETHOD LENGTH ((SEQUENCE SEQUENCE))
  (CL:RETURN-FROM LENGTH NULL-INTEGER)
  :VOID)

;;; (DEFCLASS LIST ...)

(CL:DEFCLASS LIST (SEQUENCE)
  ((THE-CONS-LIST :ALLOCATION :INSTANCE :ACCESSOR THE-CONS-LIST...OF)))

(CL:DEFUN NEW-LIST ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (POP *RECYCLED-LIST-S*))
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL)))
    (CL:T (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE LIST)))))
   (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM NEW-LIST SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF LIST))
  (CL:WHEN (CL:EQ (TERMINATE-LIST? SELF) 0) (CL:RETURN-FROM FREE))
  (PUSH *RECYCLED-LIST-S* SELF)
  :VOID)

(CL:DEFUN ACCESS-LIST-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-THE-CONS-LIST)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-LIST-SLOT-VALUE
      (CLSYS-SVAL LIST THE-CONS-LIST SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-LIST-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LIST))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-LIST)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF LIST) STREAM)
  (PRINT-CONS-LIST (CLSYS-SVAL LIST THE-CONS-LIST SELF) STREAM)
  :VOID)

;;; (DEFCLASS SET ...)

(CL:DEFCLASS SET (COLLECTION SET-MIXIN)
  ((THE-CONS-LIST :ALLOCATION :INSTANCE :ACCESSOR THE-CONS-LIST...OF)))

(CL:DEFUN NEW-SET ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (POP *RECYCLED-SET-S*))
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL)))
    (CL:T (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SET)))))
   (CL:SETF (CLSYS-SVAL SET THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM NEW-SET SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF SET))
  (CL:WHEN (CL:EQ (TERMINATE-SET? SELF) 0) (CL:RETURN-FROM FREE))
  (PUSH *RECYCLED-SET-S* SELF)
  :VOID)

(CL:DEFUN ACCESS-SET-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-THE-CONS-LIST)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL SET THE-CONS-LIST SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-SET-SLOT-VALUE
      (CLSYS-SVAL SET THE-CONS-LIST SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-SET-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SET))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-SET)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF SET) STREAM)
  (PRINT-CONS-LIST (CLSYS-SVAL SET THE-CONS-LIST SELF) STREAM)
  :VOID)

;;; (DEFCLASS CLASS-EXTENSION ...)

(CL:DEFCLASS CLASS-EXTENSION (LIST)
  ())

(CL:DEFUN NEW-CLASS-EXTENSION ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CLASS-EXTENSION)))
   (CL:SETF (CLSYS-SVAL CLASS-EXTENSION THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM NEW-CLASS-EXTENSION SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF CLASS-EXTENSION))
  (CL:WHEN (CL:EQ (TERMINATE-LIST? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CLASS-EXTENSION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-CLASS-EXTENSION)
  :VOID)

;;; (DEFCLASS CONS ...)

(CL:DEFCLASS CONS (STANDARD-OBJECT)
  ((VALUE :ALLOCATION :INSTANCE :ACCESSOR VALUE...OF)
   (REST :ALLOCATION :INSTANCE :ACCESSOR REST...OF)))

(CL:DEFUN NEW-CONS ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF *RECYCLED-CONS-S*)
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL))
     (CL:SETQ *RECYCLED-CONS-S* (CLSYS-SVAL CONS REST SELF)))
    (CL:T (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CONS)))))
   (CL:SETF (CLSYS-SVAL CONS REST SELF) NIL)
   (CL:SETF (CLSYS-SVAL CONS VALUE SELF) NULL)
   (CL:RETURN-FROM NEW-CONS SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF CONS))
  (CL:SETF (CLSYS-SVAL CONS REST SELF) *RECYCLED-CONS-S*)
  (CL:SETQ *RECYCLED-CONS-S* SELF)
  :VOID)

(CL:DEFUN ACCESS-CONS-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-VALUE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CONS VALUE SELF) VALUE)
     (CL:RETURN-FROM ACCESS-CONS-SLOT-VALUE (CLSYS-SVAL CONS VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-REST)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CONS REST SELF) VALUE)
     (CL:RETURN-FROM ACCESS-CONS-SLOT-VALUE (CLSYS-SVAL CONS REST SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-CONS-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CONS))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-CONS)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF CONS) STREAM)
  (PRINT-CONS SELF STREAM "{" "}")
  :VOID)

;;; (DEFCLASS TRANSIENT-CONS ...)

(CL:DEFCLASS TRANSIENT-CONS (CONS TRANSIENT-MIXIN)
  ((NEXT-SWEEP-LIST-OBJECT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    NEXT-SWEEP-LIST-OBJECT...OF)))

(CL:DEFUN NEW-TRANSIENT-CONS ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF *RECYCLED-TRANSIENT-CONS-S*)
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL))
     (CL:SETQ
      *RECYCLED-TRANSIENT-CONS-S*
      (CLSYS-SVAL TRANSIENT-CONS REST SELF)))
    ((CL:NOT (CL:EQ *UNUSED-TRANSIENT-CONS-S* NULL))
     (CL:SETQ SELF *UNUSED-TRANSIENT-CONS-S*)
     (CL:SETQ
      *UNUSED-TRANSIENT-CONS-S*
      (CLSYS-SVAL
       TRANSIENT-CONS
       NEXT-SWEEP-LIST-OBJECT
       *UNUSED-TRANSIENT-CONS-S*)))
    (CL:T
     (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRANSIENT-CONS)))
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-CONS NEXT-SWEEP-LIST-OBJECT SELF)
      *ALL-TRANSIENT-CONS-S*)
     (CL:SETQ *ALL-TRANSIENT-CONS-S* SELF)))
   (CL:SETF (CLSYS-SVAL TRANSIENT-CONS REST SELF) NIL)
   (CL:SETF (CLSYS-SVAL TRANSIENT-CONS VALUE SELF) NULL)
   (CL:RETURN-FROM NEW-TRANSIENT-CONS SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF TRANSIENT-CONS))
  (CL:SETF (CLSYS-SVAL TRANSIENT-CONS REST SELF) *RECYCLED-TRANSIENT-CONS-S*)
  (CL:SETQ *RECYCLED-TRANSIENT-CONS-S* SELF)
  :VOID)

(CL:DEFMETHOD SWEEP ((SELF TRANSIENT-CONS))
  (CL:SETQ *RECYCLED-TRANSIENT-CONS-S* NULL)
  (CL:SETQ *UNUSED-TRANSIENT-CONS-S* *ALL-TRANSIENT-CONS-S*)
  :VOID)

(CL:DEFUN ACCESS-TRANSIENT-CONS-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-NEXT-SWEEP-LIST-OBJECT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TRANSIENT-CONS NEXT-SWEEP-LIST-OBJECT SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TRANSIENT-CONS-SLOT-VALUE
      (CLSYS-SVAL TRANSIENT-CONS NEXT-SWEEP-LIST-OBJECT SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-TRANSIENT-CONS-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSIENT-CONS))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-TRANSIENT-CONS)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF TRANSIENT-CONS) STREAM)
  (PRINT-CONS SELF STREAM "[" "]")
  :VOID)

;;; (DEFCLASS ABSTRACT-DICTIONARY ...)

(CL:DEFCLASS ABSTRACT-DICTIONARY (ABSTRACT-COLLECTION)
  ())

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF ABSTRACT-DICTIONARY))
  (CL:RETURN-FROM ALLOCATE-ITERATOR NULL)
  :VOID)

;;; (DEFCLASS DICTIONARY ...)

(CL:DEFCLASS DICTIONARY (ABSTRACT-DICTIONARY)
  ())

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF DICTIONARY))
  (CL:RETURN-FROM ALLOCATE-ITERATOR NULL)
  :VOID)

;;; (DEFCLASS PROPERTY-LIST ...)

(CL:DEFCLASS PROPERTY-LIST (DICTIONARY)
  ((THE-PLIST :ALLOCATION :INSTANCE :ACCESSOR THE-PLIST...OF)))

(CL:DEFUN NEW-PROPERTY-LIST ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PROPERTY-LIST)))
   (CL:SETF (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF) NIL)
   (CL:RETURN-FROM NEW-PROPERTY-LIST SELF))
  :VOID)

(CL:DEFUN ACCESS-PROPERTY-LIST-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-THE-PLIST)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-PROPERTY-LIST-SLOT-VALUE
      (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-PROPERTY-LIST-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PROPERTY-LIST))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-PROPERTY-LIST)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF PROPERTY-LIST) STREAM)
  (PRINT-CONS-LIST (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF) STREAM)
  :VOID)

;;; (DEFCLASS KV-CONS ...)

(CL:DEFCLASS KV-CONS (STANDARD-OBJECT)
  ((KEY :ALLOCATION :INSTANCE :ACCESSOR KEY...OF)
   (VALUE :ALLOCATION :INSTANCE :ACCESSOR VALUE...OF)
   (REST :ALLOCATION :INSTANCE :ACCESSOR REST...OF)))

(CL:DEFUN NEW-KV-CONS ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE KV-CONS)))
   (CL:SETF (CLSYS-SVAL KV-CONS REST SELF) NULL)
   (CL:SETF (CLSYS-SVAL KV-CONS VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL KV-CONS KEY SELF) NULL)
   (CL:RETURN-FROM NEW-KV-CONS SELF))
  :VOID)

(CL:DEFUN ACCESS-KV-CONS-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-KEY)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL KV-CONS KEY SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-KV-CONS-SLOT-VALUE
      (CLSYS-SVAL KV-CONS KEY SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-VALUE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL KV-CONS VALUE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-KV-CONS-SLOT-VALUE
      (CLSYS-SVAL KV-CONS VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-REST)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL KV-CONS REST SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-KV-CONS-SLOT-VALUE
      (CLSYS-SVAL KV-CONS REST SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-KV-CONS-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF KV-CONS))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-KV-CONS)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF KV-CONS) STREAM)
  (CL:PROGN
   (CL:WRITE-STRING "<" STREAM)
   (PRINT-OBJECT (CLSYS-SVAL KV-CONS KEY SELF) STREAM)
   (CL:WRITE-STRING "," STREAM)
   (PRINT-OBJECT (CLSYS-SVAL KV-CONS VALUE SELF) STREAM)
   (CL:WRITE-STRING ">" STREAM))
  :VOID)

;;; (DEFCLASS KEY-VALUE-LIST ...)

(CL:DEFCLASS KEY-VALUE-LIST (DICTIONARY)
  ((THE-KV-LIST :ALLOCATION :INSTANCE :ACCESSOR THE-KV-LIST...OF)))

(CL:DEFUN NEW-KEY-VALUE-LIST ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE KEY-VALUE-LIST)))
   (CL:SETF (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF) NULL)
   (CL:RETURN-FROM NEW-KEY-VALUE-LIST SELF))
  :VOID)

(CL:DEFUN ACCESS-KEY-VALUE-LIST-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-THE-KV-LIST)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-KEY-VALUE-LIST-SLOT-VALUE
      (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-KEY-VALUE-LIST-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF KEY-VALUE-LIST))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-KEY-VALUE-LIST)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF KEY-VALUE-LIST) STREAM)
  (PRINT-KEY-VALUE-LIST SELF STREAM)
  :VOID)

;;; (DEFCLASS ABSTRACT-HASH-TABLE ...)

(CL:DEFCLASS ABSTRACT-HASH-TABLE (ABSTRACT-DICTIONARY)
  ((THE-HASH-TABLE :ALLOCATION :INSTANCE :ACCESSOR THE-HASH-TABLE...OF)))

;;; (DEFCLASS HASH-TABLE ...)

(CL:DEFCLASS HASH-TABLE (ABSTRACT-HASH-TABLE)
  ())

(CL:DEFUN NEW-HASH-TABLE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE HASH-TABLE)))
   (CL:SETF (CLSYS-SVAL HASH-TABLE THE-HASH-TABLE SELF) NULL)
   (INITIALIZE-HASH-TABLE SELF)
   (CL:RETURN-FROM NEW-HASH-TABLE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF HASH-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-HASH-TABLE)
  :VOID)

;;; (DEFCLASS INTEGER-HASH-TABLE ...)

(CL:DEFCLASS INTEGER-HASH-TABLE (ABSTRACT-HASH-TABLE)
  ())

(CL:DEFUN NEW-INTEGER-HASH-TABLE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INTEGER-HASH-TABLE)))
   (CL:SETF (CLSYS-SVAL INTEGER-HASH-TABLE THE-HASH-TABLE SELF) NULL)
   (INITIALIZE-HASH-TABLE SELF)
   (CL:RETURN-FROM NEW-INTEGER-HASH-TABLE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INTEGER-HASH-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-INTEGER-HASH-TABLE)
  :VOID)

;;; (DEFCLASS FLOAT-HASH-TABLE ...)

(CL:DEFCLASS FLOAT-HASH-TABLE (ABSTRACT-HASH-TABLE)
  ())

(CL:DEFUN NEW-FLOAT-HASH-TABLE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE FLOAT-HASH-TABLE)))
   (CL:SETF (CLSYS-SVAL FLOAT-HASH-TABLE THE-HASH-TABLE SELF) NULL)
   (INITIALIZE-HASH-TABLE SELF)
   (CL:RETURN-FROM NEW-FLOAT-HASH-TABLE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FLOAT-HASH-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-FLOAT-HASH-TABLE)
  :VOID)

;;; (DEFCLASS STRING-HASH-TABLE ...)

(CL:DEFCLASS STRING-HASH-TABLE (ABSTRACT-HASH-TABLE)
  ())

(CL:DEFUN NEW-STRING-HASH-TABLE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STRING-HASH-TABLE)))
   (CL:SETF (CLSYS-SVAL STRING-HASH-TABLE THE-HASH-TABLE SELF) NULL)
   (INITIALIZE-HASH-TABLE SELF)
   (CL:RETURN-FROM NEW-STRING-HASH-TABLE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STRING-HASH-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STRING-HASH-TABLE)
  :VOID)

;;; (DEFCLASS STRING-TO-INTEGER-HASH-TABLE ...)

(CL:DEFCLASS STRING-TO-INTEGER-HASH-TABLE (ABSTRACT-HASH-TABLE)
  ())

(CL:DEFUN NEW-STRING-TO-INTEGER-HASH-TABLE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STRING-TO-INTEGER-HASH-TABLE)))
   (CL:SETF
    (CLSYS-SVAL STRING-TO-INTEGER-HASH-TABLE THE-HASH-TABLE SELF)
    NULL)
   (INITIALIZE-HASH-TABLE SELF)
   (CL:RETURN-FROM NEW-STRING-TO-INTEGER-HASH-TABLE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STRING-TO-INTEGER-HASH-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STRING-TO-INTEGER-HASH-TABLE)
  :VOID)

;;; (DEFCLASS VECTOR ...)

(CL:DEFCLASS VECTOR (SEQUENCE)
  ((ARRAY-SIZE :ALLOCATION :INSTANCE :ACCESSOR ARRAY-SIZE...OF)
   (THE-ARRAY :ALLOCATION :INSTANCE :ACCESSOR THE-ARRAY...OF)))

(CL:DEFUN NEW-VECTOR (ARRAY-SIZE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE VECTOR)))
   (CL:SETF (CLSYS-SVAL VECTOR THE-ARRAY SELF) NULL)
   (CL:SETF (CLSYS-SVAL VECTOR ARRAY-SIZE SELF) ARRAY-SIZE)
   (INITIALIZE-VECTOR SELF)
   (CL:RETURN-FROM NEW-VECTOR SELF))
  :VOID)

(CL:DEFUN ACCESS-VECTOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ARRAY-SIZE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL VECTOR ARRAY-SIZE SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-VECTOR-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL VECTOR ARRAY-SIZE SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-VECTOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF VECTOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-VECTOR)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF VECTOR) STREAM)
  (PRINT-VECTOR SELF STREAM)
  :VOID)

;;; (DEFCLASS EXTENSIBLE-VECTOR ...)

(CL:DEFCLASS EXTENSIBLE-VECTOR (VECTOR)
  ())

(CL:DEFUN NEW-EXTENSIBLE-VECTOR (ARRAY-SIZE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE EXTENSIBLE-VECTOR)))
   (CL:SETF (CLSYS-SVAL EXTENSIBLE-VECTOR THE-ARRAY SELF) NULL)
   (CL:SETF (CLSYS-SVAL EXTENSIBLE-VECTOR ARRAY-SIZE SELF) ARRAY-SIZE)
   (INITIALIZE-VECTOR SELF)
   (CL:RETURN-FROM NEW-EXTENSIBLE-VECTOR SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF EXTENSIBLE-VECTOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-EXTENSIBLE-VECTOR)
  :VOID)

;;; (DEFCLASS EXTENSIBLE-SYMBOL-ARRAY ...)

(CL:DEFCLASS EXTENSIBLE-SYMBOL-ARRAY (EXTENSIBLE-VECTOR)
  ((TOP-SYMBOL-OFFSET :ALLOCATION :INSTANCE :ACCESSOR TOP-SYMBOL-OFFSET...OF)
   (POTENTIAL-FREE-SYMBOL-OFFSET
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    POTENTIAL-FREE-SYMBOL-OFFSET...OF))
  (:DOCUMENTATION
   "Self-extending array with methods for storing and
accessing symbols within it."))

(CL:DEFUN NEW-EXTENSIBLE-SYMBOL-ARRAY (ARRAY-SIZE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE EXTENSIBLE-SYMBOL-ARRAY)))
   (CL:SETF (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY THE-ARRAY SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY POTENTIAL-FREE-SYMBOL-OFFSET SELF)
    0)
   (CL:SETF (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY TOP-SYMBOL-OFFSET SELF) -1)
   (CL:SETF (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY ARRAY-SIZE SELF) ARRAY-SIZE)
   (INITIALIZE-VECTOR SELF)
   (CL:RETURN-FROM NEW-EXTENSIBLE-SYMBOL-ARRAY SELF))
  :VOID)

(CL:DEFUN ACCESS-EXTENSIBLE-SYMBOL-ARRAY-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-TOP-SYMBOL-OFFSET)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY TOP-SYMBOL-OFFSET SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-EXTENSIBLE-SYMBOL-ARRAY-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY TOP-SYMBOL-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-POTENTIAL-FREE-SYMBOL-OFFSET)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY POTENTIAL-FREE-SYMBOL-OFFSET SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-EXTENSIBLE-SYMBOL-ARRAY-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL
        EXTENSIBLE-SYMBOL-ARRAY
        POTENTIAL-FREE-SYMBOL-OFFSET
        SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-EXTENSIBLE-SYMBOL-ARRAY-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF EXTENSIBLE-SYMBOL-ARRAY))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-EXTENSIBLE-SYMBOL-ARRAY)
  :VOID)

;;; (DEFCLASS VECTOR-SEQUENCE ...)

(CL:DEFCLASS VECTOR-SEQUENCE (VECTOR)
  ((SEQUENCE-LENGTH :ALLOCATION :INSTANCE :ACCESSOR SEQUENCE-LENGTH...OF)))

(CL:DEFMETHOD RESIZE-INCREMENT ((SELF VECTOR-SEQUENCE))
  (CL:RETURN-FROM
   RESIZE-INCREMENT
   *HARDWIRED-RESIZE-INCREMENT-ON-VECTOR-SEQUENCE*)
  :VOID)

(CL:DEFUN ACCESS-VECTOR-SEQUENCE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-RESIZE-INCREMENT)
    (CL:RETURN-FROM
     ACCESS-VECTOR-SEQUENCE-SLOT-VALUE
     (WRAP-LITERAL (RESIZE-INCREMENT SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SEQUENCE-LENGTH)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL VECTOR-SEQUENCE SEQUENCE-LENGTH SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-VECTOR-SEQUENCE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL VECTOR-SEQUENCE SEQUENCE-LENGTH SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-VECTOR-SEQUENCE-SLOT-VALUE VALUE))
  :VOID)

;;; (DEFCLASS SHORT-VECTOR-SEQUENCE ...)

(CL:DEFCLASS SHORT-VECTOR-SEQUENCE (VECTOR-SEQUENCE)
  ())

(CL:DEFUN NEW-SHORT-VECTOR-SEQUENCE (ARRAY-SIZE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SHORT-VECTOR-SEQUENCE)))
   (CL:SETF (CLSYS-SVAL SHORT-VECTOR-SEQUENCE THE-ARRAY SELF) NULL)
   (CL:SETF (CLSYS-SVAL SHORT-VECTOR-SEQUENCE SEQUENCE-LENGTH SELF) 0)
   (CL:SETF (CLSYS-SVAL SHORT-VECTOR-SEQUENCE ARRAY-SIZE SELF) ARRAY-SIZE)
   (INITIALIZE-VECTOR SELF)
   (CL:RETURN-FROM NEW-SHORT-VECTOR-SEQUENCE SELF))
  :VOID)

(CL:DEFMETHOD RESIZE-INCREMENT ((SELF SHORT-VECTOR-SEQUENCE))
  (CL:RETURN-FROM
   RESIZE-INCREMENT
   *HARDWIRED-RESIZE-INCREMENT-ON-SHORT-VECTOR-SEQUENCE*)
  :VOID)

(CL:DEFUN ACCESS-SHORT-VECTOR-SEQUENCE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-RESIZE-INCREMENT)
    (CL:RETURN-FROM
     ACCESS-SHORT-VECTOR-SEQUENCE-SLOT-VALUE
     (WRAP-LITERAL (RESIZE-INCREMENT SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SEQUENCE-LENGTH)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SHORT-VECTOR-SEQUENCE SEQUENCE-LENGTH SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-SHORT-VECTOR-SEQUENCE-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL SHORT-VECTOR-SEQUENCE SEQUENCE-LENGTH SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-SHORT-VECTOR-SEQUENCE-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SHORT-VECTOR-SEQUENCE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-SHORT-VECTOR-SEQUENCE)
  :VOID)

;;; (DEFCLASS BOOLEAN-VECTOR ...)

(CL:DEFCLASS BOOLEAN-VECTOR (VECTOR)
  ())

(CL:DEFUN NEW-BOOLEAN-VECTOR (ARRAY-SIZE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE BOOLEAN-VECTOR)))
   (CL:SETF (CLSYS-SVAL BOOLEAN-VECTOR THE-ARRAY SELF) NULL)
   (CL:SETF (CLSYS-SVAL BOOLEAN-VECTOR ARRAY-SIZE SELF) ARRAY-SIZE)
   (INITIALIZE-VECTOR SELF)
   (CL:RETURN-FROM NEW-BOOLEAN-VECTOR SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF BOOLEAN-VECTOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-BOOLEAN-VECTOR)
  :VOID)

;;; (DEFCLASS INTEGER-VECTOR ...)

(CL:DEFCLASS INTEGER-VECTOR (VECTOR)
  ())

(CL:DEFUN NEW-INTEGER-VECTOR (ARRAY-SIZE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INTEGER-VECTOR)))
   (CL:SETF (CLSYS-SVAL INTEGER-VECTOR THE-ARRAY SELF) NULL)
   (CL:SETF (CLSYS-SVAL INTEGER-VECTOR ARRAY-SIZE SELF) ARRAY-SIZE)
   (INITIALIZE-VECTOR SELF)
   (CL:RETURN-FROM NEW-INTEGER-VECTOR SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INTEGER-VECTOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-INTEGER-VECTOR)
  :VOID)

;;; (DEFCLASS ACTIVE-COLLECTION-MIXIN ...)

(CL:DEFCLASS ACTIVE-COLLECTION-MIXIN ()
  ((ACTIVE-SLOT :ALLOCATION :INSTANCE :ACCESSOR ACTIVE-SLOT...OF)
   (OWNER-INSTANCE :ALLOCATION :INSTANCE :ACCESSOR OWNER-INSTANCE...OF))
  (:DOCUMENTATION
   "Mixin class that provides collection instances with a
backpointer to the instance slot they belong to."))

;;; (DEFCLASS ACTIVE-LIST ...)

(CL:DEFCLASS ACTIVE-LIST (LIST ACTIVE-COLLECTION-MIXIN)
  ())

(CL:DEFUN NEW-ACTIVE-LIST ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE ACTIVE-LIST)))
   (CL:SETF (CLSYS-SVAL ACTIVE-LIST THE-CONS-LIST SELF) NIL)
   (CL:SETF (CLSYS-SVAL ACTIVE-LIST OWNER-INSTANCE SELF) NULL)
   (CL:SETF (CLSYS-SVAL ACTIVE-LIST ACTIVE-SLOT SELF) NULL)
   (CL:RETURN-FROM NEW-ACTIVE-LIST SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF ACTIVE-LIST))
  (CL:WHEN (CL:EQ (TERMINATE-LIST? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ACTIVE-LIST))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-ACTIVE-LIST)
  :VOID)

;;; (DEFCLASS ACTIVE-SET ...)

(CL:DEFCLASS ACTIVE-SET (LIST SET-MIXIN ACTIVE-COLLECTION-MIXIN)
  ())

(CL:DEFUN NEW-ACTIVE-SET ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE ACTIVE-SET)))
   (CL:SETF (CLSYS-SVAL ACTIVE-SET THE-CONS-LIST SELF) NIL)
   (CL:SETF (CLSYS-SVAL ACTIVE-SET OWNER-INSTANCE SELF) NULL)
   (CL:SETF (CLSYS-SVAL ACTIVE-SET ACTIVE-SLOT SELF) NULL)
   (CL:RETURN-FROM NEW-ACTIVE-SET SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF ACTIVE-SET))
  (CL:WHEN (CL:EQ (TERMINATE-LIST? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ACTIVE-SET))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-ACTIVE-SET)
  :VOID)

;;; (DEFCLASS DEMON ...)

(CL:DEFCLASS DEMON (STANDARD-OBJECT)
  ((DEMON-NAME :ALLOCATION :INSTANCE :ACCESSOR DEMON-NAME...OF)
   (DEMON-ACTION :ALLOCATION :INSTANCE :ACCESSOR DEMON-ACTION...OF)
   (DEMON-CLASS-REFS :ALLOCATION :INSTANCE :ACCESSOR DEMON-CLASS-REFS...OF)
   (DEMON-SLOT-REFS :ALLOCATION :INSTANCE :ACCESSOR DEMON-SLOT-REFS...OF)
   (DEMON-CODE :ALLOCATION :INSTANCE :ACCESSOR DEMON-CODE...OF)
   (DEMON-METHOD :ALLOCATION :INSTANCE :ACCESSOR DEMON-METHOD...OF)
   (DEMON-DOCUMENTATION
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    DEMON-DOCUMENTATION...OF)
   (DEMON-GUARD? :ALLOCATION :INSTANCE :ACCESSOR DEMON-GUARD?...OF)
   (DEMON-ALL? :ALLOCATION :INSTANCE :ACCESSOR DEMON-ALL?...OF)
   (DEMON-INHERIT? :ALLOCATION :INSTANCE :ACCESSOR DEMON-INHERIT?...OF)))

(CL:DEFUN NEW-DEMON ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE DEMON)))
   (CL:SETF (CLSYS-SVAL DEMON DEMON-INHERIT? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL DEMON DEMON-ALL? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL DEMON DEMON-GUARD? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL DEMON DEMON-DOCUMENTATION SELF) NULL)
   (CL:SETF (CLSYS-SVAL DEMON DEMON-METHOD SELF) NULL)
   (CL:SETF (CLSYS-SVAL DEMON DEMON-CODE SELF) NULL)
   (CL:SETF (CLSYS-SVAL DEMON DEMON-SLOT-REFS SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL DEMON DEMON-CLASS-REFS SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL DEMON DEMON-ACTION SELF) NULL)
   (CL:SETF (CLSYS-SVAL DEMON DEMON-NAME SELF) NULL)
   (CL:RETURN-FROM NEW-DEMON SELF))
  :VOID)

(CL:DEFUN ACCESS-DEMON-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-DEMON-NAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DEMON DEMON-NAME SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-DEMON-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL DEMON DEMON-NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-DEMON-ACTION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL DEMON DEMON-ACTION SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-DEMON-SLOT-VALUE
      (CLSYS-SVAL DEMON DEMON-ACTION SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-DEMON-CLASS-REFS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL DEMON DEMON-CLASS-REFS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-DEMON-SLOT-VALUE
      (CLSYS-SVAL DEMON DEMON-CLASS-REFS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-DEMON-SLOT-REFS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL DEMON DEMON-SLOT-REFS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-DEMON-SLOT-VALUE
      (CLSYS-SVAL DEMON DEMON-SLOT-REFS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-DEMON-CODE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DEMON DEMON-CODE SELF)
      (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-DEMON-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL DEMON DEMON-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-DEMON-METHOD)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL DEMON DEMON-METHOD SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-DEMON-SLOT-VALUE
      (CLSYS-SVAL DEMON DEMON-METHOD SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-DEMON-DOCUMENTATION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DEMON DEMON-DOCUMENTATION SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-DEMON-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL DEMON DEMON-DOCUMENTATION SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-DEMON-GUARD?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DEMON DEMON-GUARD? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-DEMON-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL DEMON DEMON-GUARD? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-DEMON-ALL?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DEMON DEMON-ALL? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-DEMON-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL DEMON DEMON-ALL? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-DEMON-INHERIT?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DEMON DEMON-INHERIT? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-DEMON-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL DEMON DEMON-INHERIT? SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-DEMON-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DEMON))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-DEMON)
  :VOID)

;;; (DEFCLASS LIST-OF-SLOT ...)

(CL:DEFCLASS LIST-OF-SLOT (LIST)
  ())

(CL:DEFUN NEW-LIST-OF-SLOT ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE LIST-OF-SLOT)))
   (CL:SETF (CLSYS-SVAL LIST-OF-SLOT THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM NEW-LIST-OF-SLOT SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF LIST-OF-SLOT))
  (CL:WHEN (CL:EQ (TERMINATE-LIST? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LIST-OF-SLOT))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-LIST-OF-SLOT)
  :VOID)

;;; (DEFCLASS LIST-OF-SYMBOL ...)

(CL:DEFCLASS LIST-OF-SYMBOL (LIST)
  ())

(CL:DEFUN NEW-LIST-OF-SYMBOL ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE LIST-OF-SYMBOL)))
   (CL:SETF (CLSYS-SVAL LIST-OF-SYMBOL THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM NEW-LIST-OF-SYMBOL SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF LIST-OF-SYMBOL))
  (CL:WHEN (CL:EQ (TERMINATE-LIST? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LIST-OF-SYMBOL))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-LIST-OF-SYMBOL)
  :VOID)

;;; (DEFCLASS LIST-OF-KEYWORD ...)

(CL:DEFCLASS LIST-OF-KEYWORD (LIST)
  ())

(CL:DEFUN NEW-LIST-OF-KEYWORD ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE LIST-OF-KEYWORD)))
   (CL:SETF (CLSYS-SVAL LIST-OF-KEYWORD THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM NEW-LIST-OF-KEYWORD SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF LIST-OF-KEYWORD))
  (CL:WHEN (CL:EQ (TERMINATE-LIST? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LIST-OF-KEYWORD))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-LIST-OF-KEYWORD)
  :VOID)

;;; (DEFCLASS LIST-OF-TYPE ...)

(CL:DEFCLASS LIST-OF-TYPE (LIST)
  ())

(CL:DEFUN NEW-LIST-OF-TYPE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE LIST-OF-TYPE)))
   (CL:SETF (CLSYS-SVAL LIST-OF-TYPE THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM NEW-LIST-OF-TYPE SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF LIST-OF-TYPE))
  (CL:WHEN (CL:EQ (TERMINATE-LIST? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LIST-OF-TYPE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-LIST-OF-TYPE)
  :VOID)

;;; (DEFCLASS KEYWORD-KEY-VALUE-LIST ...)

(CL:DEFCLASS KEYWORD-KEY-VALUE-LIST (KEY-VALUE-LIST)
  ())

(CL:DEFUN NEW-KEYWORD-KEY-VALUE-LIST ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE KEYWORD-KEY-VALUE-LIST)))
   (CL:SETF (CLSYS-SVAL KEYWORD-KEY-VALUE-LIST THE-KV-LIST SELF) NULL)
   (CL:RETURN-FROM NEW-KEYWORD-KEY-VALUE-LIST SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF KEYWORD-KEY-VALUE-LIST))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-KEYWORD-KEY-VALUE-LIST)
  :VOID)

;;; (DEFCLASS GENERALIZED-SYMBOL ...)

(CL:DEFCLASS GENERALIZED-SYMBOL (CONTEXT-SENSITIVE-OBJECT)
  ((SYMBOL-NAME :ALLOCATION :INSTANCE :ACCESSOR SYMBOL-NAME...OF)
   (SYMBOL-ID :ALLOCATION :INSTANCE :ACCESSOR SYMBOL-ID...OF)))

(CL:DEFUN ACCESS-GENERALIZED-SYMBOL-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SYMBOL-NAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-NAME SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-GENERALIZED-SYMBOL-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SYMBOL-ID)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-ID SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-GENERALIZED-SYMBOL-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-ID SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-INTERNED-IN)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL GENERALIZED-SYMBOL HOME-CONTEXT SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-GENERALIZED-SYMBOL-SLOT-VALUE
      (CLSYS-SVAL GENERALIZED-SYMBOL HOME-CONTEXT SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-GENERALIZED-SYMBOL-SLOT-VALUE VALUE))
  :VOID)

;;; (DEFCLASS SYMBOL ...)

(CL:DEFCLASS SYMBOL (GENERALIZED-SYMBOL)
  ((SYMBOL-SLOT-OFFSET
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SYMBOL-SLOT-OFFSET...OF)
   (SYMBOL-VALUE-AND-PLIST
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SYMBOL-VALUE-AND-PLIST...OF)))

(CL:DEFUN NEW-SYMBOL (SYMBOL-NAME)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SYMBOL)))
   (CL:SETF (CLSYS-SVAL SYMBOL HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (CLSYS-SVAL SYMBOL SYMBOL-ID SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL SYMBOL SYMBOL-VALUE-AND-PLIST SELF) NIL)
   (CL:SETF (CLSYS-SVAL SYMBOL SYMBOL-SLOT-OFFSET SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL SYMBOL SYMBOL-NAME SELF) SYMBOL-NAME)
   (CL:RETURN-FROM NEW-SYMBOL SELF))
  :VOID)

(CL:DEFUN ACCESS-SYMBOL-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SYMBOL-SLOT-OFFSET)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SYMBOL SYMBOL-SLOT-OFFSET SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-SYMBOL-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL SYMBOL SYMBOL-SLOT-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SYMBOL-VALUE-AND-PLIST)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL SYMBOL SYMBOL-VALUE-AND-PLIST SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-SYMBOL-SLOT-VALUE
      (CLSYS-SVAL SYMBOL SYMBOL-VALUE-AND-PLIST SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-SYMBOL-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SYMBOL))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-SYMBOL)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF SYMBOL) STREAM)
  (PRINT-SYMBOL SELF STREAM)
  :VOID)

;;; (DEFCLASS SURROGATE ...)

(CL:DEFCLASS SURROGATE (GENERALIZED-SYMBOL)
  ((SURROGATE-VALUE :ALLOCATION :INSTANCE :ACCESSOR SURROGATE-VALUE...OF))
  (:DOCUMENTATION "Rigid surrogate."))

(CL:DEFUN NEW-SURROGATE (SYMBOL-NAME)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SURROGATE)))
   (CL:SETF (CLSYS-SVAL SURROGATE HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (CLSYS-SVAL SURROGATE SYMBOL-ID SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL SURROGATE SYMBOL-NAME SELF) SYMBOL-NAME)
   (CL:RETURN-FROM NEW-SURROGATE SELF))
  :VOID)

(CL:DEFUN ACCESS-SURROGATE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SURROGATE-VALUE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-SURROGATE-SLOT-VALUE
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SURROGATE-NAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SURROGATE SYMBOL-NAME SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-SURROGATE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL SURROGATE SYMBOL-NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-TYPE-CLASS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-SURROGATE-SLOT-VALUE
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-TYPE-NAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SURROGATE SYMBOL-NAME SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-SURROGATE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL SURROGATE SYMBOL-NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOTREF-SLOT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-SURROGATE-SLOT-VALUE
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-SURROGATE-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SURROGATE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-SURROGATE)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF SURROGATE) STREAM)
  (CL:WRITE-STRING (RELATIVE-NAME SELF) STREAM)
  :VOID)

;;; (DEFCLASS KEYWORD ...)

(CL:DEFCLASS KEYWORD (GENERALIZED-SYMBOL)
  ())

(CL:DEFUN NEW-KEYWORD (SYMBOL-NAME)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE KEYWORD)))
   (CL:SETF (CLSYS-SVAL KEYWORD HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (CLSYS-SVAL KEYWORD SYMBOL-ID SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL KEYWORD SYMBOL-NAME SELF) SYMBOL-NAME)
   (CL:RETURN-FROM NEW-KEYWORD SELF))
  :VOID)

(CL:DEFUN ACCESS-KEYWORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-KEYWORD-NAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL KEYWORD SYMBOL-NAME SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-KEYWORD-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL KEYWORD SYMBOL-NAME SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-KEYWORD-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF KEYWORD))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-KEYWORD)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF KEYWORD) STREAM)
  (CL:PROGN
   (CL:WRITE-STRING ":" STREAM)
   (CL:WRITE-STRING (CLSYS-SVAL KEYWORD SYMBOL-NAME SELF) STREAM))
  :VOID)

;;; (DEFCLASS INDEXICAL ...)

(CL:DEFCLASS INDEXICAL (GENERALIZED-SYMBOL)
  ((INDEXICAL-VALUE :ALLOCATION :INSTANCE :ACCESSOR INDEXICAL-VALUE...OF))
  (:DOCUMENTATION "Surrogate with context sensitive value."))

(CL:DEFUN NEW-INDEXICAL (SYMBOL-NAME)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INDEXICAL)))
   (CL:SETF (CLSYS-SVAL INDEXICAL HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (CLSYS-SVAL INDEXICAL SYMBOL-ID SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL INDEXICAL SYMBOL-NAME SELF) SYMBOL-NAME)
   (CL:RETURN-FROM NEW-INDEXICAL SELF))
  :VOID)

(CL:DEFUN ACCESS-INDEXICAL-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-INDEXICAL-VALUE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:LET*
      ((OBJECT-001 SELF)
       (VALUE-001 VALUE)
       (OLD-VALUE-001 (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE OBJECT-001))
       (NEW-VALUE-001
        (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001 OBJECT-001 FALSE)))
      (CL:WHEN
       (CL:EQ (CS-VALUE? OLD-VALUE-001) 0)
       (CL:SETF
        (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE OBJECT-001)
        NEW-VALUE-001)))
     (CL:RETURN-FROM
      ACCESS-INDEXICAL-SLOT-VALUE
      (ACCESS-IN-CONTEXT
       (CLSYS-SVAL INDEXICAL INDEXICAL-VALUE SELF)
       SELF
       FALSE))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-INDEXICAL-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INDEXICAL))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-INDEXICAL)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF INDEXICAL) STREAM)
  (CL:WRITE-STRING (RELATIVE-NAME SELF) STREAM)
  :VOID)

;;; (DEFCLASS TRANSIENT-SYMBOL ...)

(CL:DEFCLASS TRANSIENT-SYMBOL (SYMBOL TRANSIENT-MIXIN)
  ())

(CL:DEFUN NEW-TRANSIENT-SYMBOL (SYMBOL-NAME)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRANSIENT-SYMBOL)))
   (CL:SETF (CLSYS-SVAL TRANSIENT-SYMBOL HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (CLSYS-SVAL TRANSIENT-SYMBOL SYMBOL-ID SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL TRANSIENT-SYMBOL SYMBOL-VALUE-AND-PLIST SELF) NIL)
   (CL:SETF
    (CLSYS-SVAL TRANSIENT-SYMBOL SYMBOL-SLOT-OFFSET SELF)
    NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL TRANSIENT-SYMBOL SYMBOL-NAME SELF) SYMBOL-NAME)
   (CL:RETURN-FROM NEW-TRANSIENT-SYMBOL SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSIENT-SYMBOL))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-TRANSIENT-SYMBOL)
  :VOID)

;;; (DEFCLASS TRANSIENT-KEYWORD ...)

(CL:DEFCLASS TRANSIENT-KEYWORD (KEYWORD TRANSIENT-MIXIN)
  ())

(CL:DEFUN NEW-TRANSIENT-KEYWORD (SYMBOL-NAME)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRANSIENT-KEYWORD)))
   (CL:SETF (CLSYS-SVAL TRANSIENT-KEYWORD HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (CLSYS-SVAL TRANSIENT-KEYWORD SYMBOL-ID SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL TRANSIENT-KEYWORD SYMBOL-NAME SELF) SYMBOL-NAME)
   (CL:RETURN-FROM NEW-TRANSIENT-KEYWORD SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSIENT-KEYWORD))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-TRANSIENT-KEYWORD)
  :VOID)

;;; (DEFCLASS MAPPABLE-OBJECT ...)

(CL:DEFCLASS MAPPABLE-OBJECT (STANDARD-OBJECT DYNAMIC-SLOTS-MIXIN)
  ()
  (:DOCUMENTATION
   "The class MAPPABLE-OBJECT enables the definition of projections
from a Stella class, slot, global variable, etc. onto a corresponding native
entity."))

(CL:DEFMETHOD PROJECTS-ONTO ((SELF MAPPABLE-OBJECT))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-PROJECTS-ONTO NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM PROJECTS-ONTO NIL-LIST)
    (CL:RETURN-FROM PROJECTS-ONTO ANSWER)))
  :VOID)

(CL:DEFMETHOD PROJECTED-FROM ((SELF MAPPABLE-OBJECT))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-PROJECTED-FROM NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM PROJECTED-FROM NIL-LIST)
    (CL:RETURN-FROM PROJECTED-FROM ANSWER)))
  :VOID)

(CL:DEFUN ACCESS-MAPPABLE-OBJECT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-PROJECTS-ONTO)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-PROJECTS-ONTO VALUE NULL)
     (CL:RETURN-FROM ACCESS-MAPPABLE-OBJECT-SLOT-VALUE (PROJECTS-ONTO SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-PROJECTED-FROM)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-PROJECTED-FROM VALUE NULL)
     (CL:RETURN-FROM
      ACCESS-MAPPABLE-OBJECT-SLOT-VALUE
      (PROJECTED-FROM SELF))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL MAPPABLE-OBJECT DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-MAPPABLE-OBJECT-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL MAPPABLE-OBJECT DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-MAPPABLE-OBJECT-SLOT-VALUE VALUE))
  :VOID)

;;; (DEFCLASS RELATION ...)

(CL:DEFCLASS RELATION (MAPPABLE-OBJECT)
  ((ABSTRACT? :ALLOCATION :INSTANCE :ACCESSOR ABSTRACT?...OF)))

(CL:DEFMETHOD PROPERTIES ((SELF RELATION))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-PROPERTIES NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM PROPERTIES NIL-LIST)
    (CL:RETURN-FROM PROPERTIES ANSWER)))
  :VOID)

(CL:DEFMETHOD STORED-ACTIVE? ((SELF RELATION))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-HIERARCHY-STORED-ACTIVE?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM STORED-ACTIVE? NULL-BOOLEAN)
    (CL:RETURN-FROM STORED-ACTIVE? ANSWER)))
  :VOID)

(CL:DEFUN ACCESS-RELATION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ABSTRACT?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL RELATION ABSTRACT? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-RELATION-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL RELATION ABSTRACT? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-PROPERTIES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-PROPERTIES VALUE NULL)
     (CL:RETURN-FROM ACCESS-RELATION-SLOT-VALUE (PROPERTIES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STORED-ACTIVE?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-STORED-ACTIVE?
      (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-RELATION-SLOT-VALUE
      (WRAP-BOOLEAN (STORED-ACTIVE? SELF)))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL RELATION DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-RELATION-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL RELATION DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-RELATION-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD NAME ((SELF RELATION))
  (CL:RETURN-FROM NAME NULL)
  :VOID)

(CL:DEFMETHOD HOME-MODULE ((SELF RELATION))
  (CL:RETURN-FROM HOME-MODULE NULL)
  :VOID)

(CL:DEFMETHOD ARITY ((SELF RELATION))
  (CL:RETURN-FROM ARITY NULL-INTEGER)
  :VOID)

(CL:DEFMETHOD PUBLIC? ((SELF RELATION))
  (CL:RETURN-FROM PUBLIC? FALSE)
  :VOID)

(CL:DEFMETHOD DIRECT-SUPERS ((SELF RELATION))
  (CL:RETURN-FROM DIRECT-SUPERS NULL)
  :VOID)

(CL:DEFMETHOD ALL-SUPERS ((SELF RELATION))
  (CL:RETURN-FROM ALL-SUPERS NULL)
  :VOID)

(CL:DEFMETHOD SLOTS ((SELF RELATION))
  (CL:RETURN-FROM SLOTS NULL)
  :VOID)

;;; (DEFCLASS CLASS ...)

(CL:DEFCLASS CLASS (RELATION)
  ((CL-STRUCT? :ALLOCATION :INSTANCE :ACCESSOR CL-STRUCT?...OF)
   (MIXIN? :ALLOCATION :INSTANCE :ACCESSOR MIXIN?...OF)
   (CLASS-TYPE :ALLOCATION :INSTANCE :ACCESSOR CLASS-TYPE...OF)
   (CLASS-DIRECT-SUPERS
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CLASS-DIRECT-SUPERS...OF)
   (CLASS-DIRECT-SUBS :ALLOCATION :INSTANCE :ACCESSOR CLASS-DIRECT-SUBS...OF)
   (CLASS-ALL-SUPER-CLASSES
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CLASS-ALL-SUPER-CLASSES...OF)
   (CLASS-ALL-SLOTS :ALLOCATION :INSTANCE :ACCESSOR CLASS-ALL-SLOTS...OF)
   (CLASS-LOCAL-SLOTS :ALLOCATION :INSTANCE :ACCESSOR CLASS-LOCAL-SLOTS...OF)
   (CLASS-SLOT-AND-METHOD-CACHE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CLASS-SLOT-AND-METHOD-CACHE...OF)
   (CLASS-COLLECTION? :ALLOCATION :INSTANCE :ACCESSOR CLASS-COLLECTION?...OF)
   (CLASS-PUBLIC? :ALLOCATION :INSTANCE :ACCESSOR CLASS-PUBLIC?...OF)
   (CLASS-FINALIZED? :ALLOCATION :INSTANCE :ACCESSOR CLASS-FINALIZED?...OF)
   (CLASS-SLOTS-FINALIZED?
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CLASS-SLOTS-FINALIZED?...OF)
   (CLASS-STRINGIFIED-SOURCE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CLASS-STRINGIFIED-SOURCE...OF)
   (CLASS-CONSTRUCTOR-CODE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CLASS-CONSTRUCTOR-CODE...OF)
   (CLASS-SLOT-ACCESSOR-CODE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CLASS-SLOT-ACCESSOR-CODE...OF)
   (CLASS-MARKED? :ALLOCATION :INSTANCE :ACCESSOR CLASS-MARKED?...OF)
   (CLASS-TAXONOMY-NODE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CLASS-TAXONOMY-NODE...OF)))

(CL:DEFUN NEW-CLASS ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CLASS)))
   (CL:SETF (CLSYS-SVAL CLASS BITS SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL CLASS DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (CLSYS-SVAL CLASS CLASS-TAXONOMY-NODE SELF) NULL)
   (CL:SETF (CLSYS-SVAL CLASS CLASS-MARKED? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE SELF) NULL)
   (CL:SETF (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE SELF) NULL)
   (CL:SETF (CLSYS-SVAL CLASS CLASS-STRINGIFIED-SOURCE SELF) NULL)
   (CL:SETF (CLSYS-SVAL CLASS CLASS-SLOTS-FINALIZED? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL CLASS CLASS-FINALIZED? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL CLASS CLASS-PUBLIC? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL CLASS CL-STRUCT? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL CLASS CLASS-COLLECTION? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL CLASS MIXIN? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL CLASS ABSTRACT? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL CLASS CLASS-SLOT-AND-METHOD-CACHE SELF) NULL)
   (CL:SETF (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS SELF) NULL)
   (CL:SETF (CLSYS-SVAL CLASS CLASS-ALL-SLOTS SELF) NULL)
   (CL:SETF (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES SELF) NIL)
   (CL:SETF (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL CLASS CLASS-TYPE SELF) NULL)
   (CL:RETURN-FROM NEW-CLASS SELF))
  :VOID)

(CL:DEFMETHOD CLASS-ARITY ((SELF CLASS))
  (CL:RETURN-FROM CLASS-ARITY *HARDWIRED-CLASS-ARITY-ON-CLASS*)
  :VOID)

(CL:DEFMETHOD CLASS-CL-STRUCT-SLOTS ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-CLASS-CL-STRUCT-SLOTS NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-CL-STRUCT-SLOTS NIL-LIST)
    (CL:RETURN-FROM CLASS-CL-STRUCT-SLOTS ANSWER)))
  :VOID)

(CL:DEFMETHOD CLASS-RECYCLE-METHOD ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-CLASS-RECYCLE-METHOD NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-RECYCLE-METHOD KWD-HIERARCHY-NONE)
    (CL:RETURN-FROM CLASS-RECYCLE-METHOD ANSWER)))
  :VOID)

(CL:DEFMETHOD CLASS-PARAMETERS ((SELF CLASS))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-CLASS-PARAMETERS NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-PARAMETERS NIL-LIST)
    (CL:RETURN-FROM CLASS-PARAMETERS ANSWER)))
  :VOID)

(CL:DEFMETHOD CLASS-REQUIRED-SLOT-NAMES ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-CLASS-REQUIRED-SLOT-NAMES NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-REQUIRED-SLOT-NAMES NIL-LIST)
    (CL:RETURN-FROM CLASS-REQUIRED-SLOT-NAMES ANSWER)))
  :VOID)

(CL:DEFMETHOD CLASS-GUARD-CONSTRUCTOR-DEMONS ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-CLASS-GUARD-CONSTRUCTOR-DEMONS
      NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-GUARD-CONSTRUCTOR-DEMONS NIL-LIST)
    (CL:RETURN-FROM CLASS-GUARD-CONSTRUCTOR-DEMONS ANSWER)))
  :VOID)

(CL:DEFMETHOD CLASS-CONSTRUCTOR-DEMONS ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-CLASS-CONSTRUCTOR-DEMONS NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-CONSTRUCTOR-DEMONS NIL-LIST)
    (CL:RETURN-FROM CLASS-CONSTRUCTOR-DEMONS ANSWER)))
  :VOID)

(CL:DEFMETHOD CLASS-GUARD-DESTRUCTOR-DEMONS ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-CLASS-GUARD-DESTRUCTOR-DEMONS
      NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-GUARD-DESTRUCTOR-DEMONS NIL-LIST)
    (CL:RETURN-FROM CLASS-GUARD-DESTRUCTOR-DEMONS ANSWER)))
  :VOID)

(CL:DEFMETHOD CLASS-DESTRUCTOR-DEMONS ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-CLASS-DESTRUCTOR-DEMONS NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-DESTRUCTOR-DEMONS NIL-LIST)
    (CL:RETURN-FROM CLASS-DESTRUCTOR-DEMONS ANSWER)))
  :VOID)

(CL:DEFMETHOD CLASS-KEY ((SELF CLASS))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-CLASS-KEY NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-KEY NIL-LIST)
    (CL:RETURN-FROM CLASS-KEY ANSWER)))
  :VOID)

(CL:DEFMETHOD CLASS-SYNONYMS ((SELF CLASS))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-CLASS-SYNONYMS NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-SYNONYMS NIL-LIST)
    (CL:RETURN-FROM CLASS-SYNONYMS ANSWER)))
  :VOID)

(CL:DEFUN ACCESS-CLASS-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CL-STRUCT?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CLASS CL-STRUCT? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL CLASS CL-STRUCT? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-MIXIN?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CLASS MIXIN? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL CLASS MIXIN? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-TYPE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CLASS CLASS-TYPE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (CLSYS-SVAL CLASS CLASS-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-ARITY)
    (CL:RETURN-FROM
     ACCESS-CLASS-SLOT-VALUE
     (WRAP-LITERAL (CLASS-ARITY SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-DIRECT-SUPERS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-DIRECT-SUBS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-ALL-SUPER-CLASSES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-ALL-SLOTS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CLASS CLASS-ALL-SLOTS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (CLSYS-SVAL CLASS CLASS-ALL-SLOTS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-LOCAL-SLOTS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-SLOT-AND-METHOD-CACHE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CLASS CLASS-SLOT-AND-METHOD-CACHE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (CLSYS-SVAL CLASS CLASS-SLOT-AND-METHOD-CACHE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-ABSTRACT?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CLASS ABSTRACT? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL CLASS ABSTRACT? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-MIXIN?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CLASS MIXIN? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL CLASS MIXIN? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-COLLECTION?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-COLLECTION? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL CLASS CLASS-COLLECTION? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-CL-STRUCT?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CLASS CL-STRUCT? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL CLASS CL-STRUCT? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-CL-STRUCT-SLOTS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-CLASS-CL-STRUCT-SLOTS
      VALUE
      NULL)
     (CL:RETURN-FROM ACCESS-CLASS-SLOT-VALUE (CLASS-CL-STRUCT-SLOTS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-PUBLIC?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-PUBLIC? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL CLASS CLASS-PUBLIC? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-RECYCLE-METHOD)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-CLASS-RECYCLE-METHOD
      VALUE
      NULL)
     (CL:RETURN-FROM ACCESS-CLASS-SLOT-VALUE (CLASS-RECYCLE-METHOD SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-FINALIZED?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-FINALIZED? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL CLASS CLASS-FINALIZED? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-SLOTS-FINALIZED?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOTS-FINALIZED? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL CLASS CLASS-SLOTS-FINALIZED? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-STRINGIFIED-SOURCE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-STRINGIFIED-SOURCE SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL CLASS CLASS-STRINGIFIED-SOURCE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-PARAMETERS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-CLASS-PARAMETERS VALUE NULL)
     (CL:RETURN-FROM ACCESS-CLASS-SLOT-VALUE (CLASS-PARAMETERS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-CONSTRUCTOR-CODE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE SELF)
      (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-SLOT-ACCESSOR-CODE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE SELF)
      (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-REQUIRED-SLOT-NAMES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-CLASS-REQUIRED-SLOT-NAMES
      VALUE
      NULL)
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (CLASS-REQUIRED-SLOT-NAMES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-GUARD-CONSTRUCTOR-DEMONS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-CLASS-GUARD-CONSTRUCTOR-DEMONS
      VALUE
      NULL)
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (CLASS-GUARD-CONSTRUCTOR-DEMONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-CONSTRUCTOR-DEMONS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-CLASS-CONSTRUCTOR-DEMONS
      VALUE
      NULL)
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (CLASS-CONSTRUCTOR-DEMONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-GUARD-DESTRUCTOR-DEMONS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-CLASS-GUARD-DESTRUCTOR-DEMONS
      VALUE
      NULL)
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (CLASS-GUARD-DESTRUCTOR-DEMONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-DESTRUCTOR-DEMONS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-CLASS-DESTRUCTOR-DEMONS
      VALUE
      NULL)
     (CL:RETURN-FROM ACCESS-CLASS-SLOT-VALUE (CLASS-DESTRUCTOR-DEMONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-KEY)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-CLASS-KEY VALUE NULL)
     (CL:RETURN-FROM ACCESS-CLASS-SLOT-VALUE (CLASS-KEY SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-SYNONYMS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-CLASS-SYNONYMS VALUE NULL)
     (CL:RETURN-FROM ACCESS-CLASS-SLOT-VALUE (CLASS-SYNONYMS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-MARKED?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-MARKED? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL CLASS CLASS-MARKED? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-TAXONOMY-NODE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CLASS CLASS-TAXONOMY-NODE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (CLSYS-SVAL CLASS CLASS-TAXONOMY-NODE SELF))))
   (CL:T
    (CL:COND
     ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-DOCUMENTATION)
      (CL:SETQ SLOTNAME SYM-HIERARCHY-DOCUMENTATION))
     ((CL:EQ SLOTNAME SYM-HIERARCHY-CLASS-PRINT-FORM)
      (CL:SETQ SLOTNAME SYM-HIERARCHY-PRINT-FORM))
     (CL:T NULL))
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL CLASS DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-CLASS-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL CLASS DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-CLASS-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CLASS))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-CLASS)
  :VOID)

(CL:DEFMETHOD NAME ((SELF CLASS))
  (CL:RETURN-FROM
   NAME
   (CLSYS-SVAL SURROGATE SYMBOL-NAME (CLSYS-SVAL CLASS CLASS-TYPE SELF)))
  :VOID)

(CL:DEFMETHOD HOME-MODULE ((SELF CLASS))
  (CL:RETURN-FROM
   HOME-MODULE
   (CLSYS-SVAL SURROGATE HOME-CONTEXT (CLSYS-SVAL CLASS CLASS-TYPE SELF)))
  :VOID)

(CL:DEFMETHOD ARITY ((SELF CLASS))
  (CL:RETURN-FROM ARITY 1)
  :VOID)

(CL:DEFMETHOD PUBLIC? ((SELF CLASS))
  (CL:RETURN-FROM PUBLIC? (CLSYS-SVAL CLASS CLASS-PUBLIC? SELF))
  :VOID)

(CL:DEFMETHOD ACTIVE? ((SELF CLASS))
  (CL:RETURN-FROM
   ACTIVE?
   (CL:IF
    (CL:OR
     (CL:AND
      (CL:EQ (DEFINED? (STORED-ACTIVE? SELF)) 1)
      (CL:EQ (STORED-ACTIVE? SELF) 1))
     (CL:EQ
      (SUBTYPE-OF?
       (CLSYS-SVAL CLASS CLASS-TYPE SELF)
       SGT-HIERARCHY-ACTIVE-OBJECT)
      1))
    TRUE
    FALSE))
  :VOID)

(CL:DEFMETHOD CREATOR ((SELF CLASS))
  (CL:RETURN-FROM
   CREATOR
   (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-CLASS-CREATOR NULL))
  :VOID)

(CL:DEFMETHOD INITIALIZER ((SELF CLASS))
  (CL:LET*
   ((CURSOR SELF)
    (VALUE (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-CLASS-INITIALIZER NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM INITIALIZER VALUE))
    (CL:SETQ CURSOR (FIRST (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CURSOR)))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ
      VALUE
      (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-CLASS-INITIALIZER NULL))
     (CL:RETURN-FROM INITIALIZER NULL))))
  :VOID)

(CL:DEFMETHOD TERMINATOR ((SELF CLASS))
  (CL:LET*
   ((CURSOR SELF)
    (VALUE (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-CLASS-TERMINATOR NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM TERMINATOR VALUE))
    (CL:SETQ CURSOR (FIRST (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CURSOR)))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ
      VALUE
      (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-CLASS-TERMINATOR NULL))
     (CL:RETURN-FROM TERMINATOR NULL))))
  :VOID)

(CL:DEFMETHOD DESTRUCTOR ((SELF CLASS))
  (CL:RETURN-FROM
   DESTRUCTOR
   (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-CLASS-DESTRUCTOR NULL))
  :VOID)

(CL:DEFMETHOD REQUIRED-SLOTS ((SELF CLASS))
  "Returns a list of names of required slots for 'self'."
  (CL:RETURN-FROM REQUIRED-SLOTS (CLASS-REQUIRED-SLOT-NAMES SELF))
  :VOID)

(CL:DEFMETHOD PARAMETERS ((SELF CLASS))
  "Returns the list of parameters names of 'self'."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-CLASS-PARAMETERS NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM PARAMETERS VALUE))
    (CL:SETQ CURSOR (FIRST (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CURSOR)))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ
      VALUE
      (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-CLASS-PARAMETERS NULL))
     (CL:RETURN-FROM PARAMETERS NIL-LIST))))
  :VOID)

(CL:DEFMETHOD INITIAL-VALUE ((SELF CLASS))
  "Return an initial value for the class 'self'."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-CLASS-INITIAL-VALUE NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM INITIAL-VALUE VALUE))
    (CL:SETQ CURSOR (FIRST (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CURSOR)))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ
      VALUE
      (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-CLASS-INITIAL-VALUE NULL))
     (CL:RETURN-FROM INITIAL-VALUE NULL))))
  :VOID)

(CL:DEFMETHOD EXTENSION ((SELF CLASS))
  "Return the nearest class extension that records instances
of the class 'self'."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-CLASS-EXTENSION NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM EXTENSION VALUE))
    (CL:SETQ CURSOR (FIRST (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CURSOR)))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ
      VALUE
      (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-CLASS-EXTENSION NULL))
     (CL:RETURN-FROM EXTENSION NULL))))
  :VOID)

(CL:DEFMETHOD CL-NATIVE-TYPE ((SELF CLASS))
  (CL:RETURN-FROM
   CL-NATIVE-TYPE
   (CLSYS-SVAL
    STRING-WRAPPER
    WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE
     SELF
     SYM-HIERARCHY-CLASS-CL-NATIVE-TYPE
     NULL-STRING-WRAPPER)))
  :VOID)

(CL:DEFMETHOD CPP-NATIVE-TYPE ((SELF CLASS))
  (CL:RETURN-FROM
   CPP-NATIVE-TYPE
   (CLSYS-SVAL
    STRING-WRAPPER
    WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE
     SELF
     SYM-HIERARCHY-CLASS-CPP-NATIVE-TYPE
     NULL-STRING-WRAPPER)))
  :VOID)

(CL:DEFMETHOD IDL-NATIVE-TYPE ((SELF CLASS))
  (CL:RETURN-FROM
   IDL-NATIVE-TYPE
   (CLSYS-SVAL
    STRING-WRAPPER
    WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE
     SELF
     SYM-HIERARCHY-CLASS-CPP-NATIVE-TYPE
     NULL-STRING-WRAPPER)))
  :VOID)

(CL:DEFMETHOD JAVA-NATIVE-TYPE ((SELF CLASS))
  (CL:RETURN-FROM
   JAVA-NATIVE-TYPE
   (CLSYS-SVAL
    STRING-WRAPPER
    WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE
     SELF
     SYM-HIERARCHY-CLASS-JAVA-NATIVE-TYPE
     NULL-STRING-WRAPPER)))
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF CLASS) STREAM)
  (CL:PROGN
   (CL:WRITE-STRING "|C|" STREAM)
   (CL:WRITE-STRING
    (CL:IF
     (CL:NOT (CL:EQ (CLSYS-SVAL CLASS CLASS-TYPE SELF) NULL))
     (CLSYS-SVAL SURROGATE SYMBOL-NAME (CLSYS-SVAL CLASS CLASS-TYPE SELF))
     "??")
    STREAM))
  :VOID)

;;; (DEFCLASS POLYMORPHIC-RELATION ...)

(CL:DEFCLASS POLYMORPHIC-RELATION (RELATION)
  ((SLOT-DIRECT-EQUIVALENT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SLOT-DIRECT-EQUIVALENT...OF)))

(CL:DEFUN ACCESS-POLYMORPHIC-RELATION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-DIRECT-EQUIVALENT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL POLYMORPHIC-RELATION SLOT-DIRECT-EQUIVALENT SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-POLYMORPHIC-RELATION-SLOT-VALUE
      (CLSYS-SVAL POLYMORPHIC-RELATION SLOT-DIRECT-EQUIVALENT SELF))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL POLYMORPHIC-RELATION DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-POLYMORPHIC-RELATION-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL POLYMORPHIC-RELATION DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-POLYMORPHIC-RELATION-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD OWNER ((SELF POLYMORPHIC-RELATION))
  (CL:RETURN-FROM OWNER NULL)
  :VOID)

(CL:DEFMETHOD RENAMES ((SELF POLYMORPHIC-RELATION))
  (CL:RETURN-FROM RENAMES NULL)
  :VOID)

(CL:DEFMETHOD ACTIVE? ((SELF POLYMORPHIC-RELATION))
  "True if 'self' or a superslot of 'self' is marked active."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       CURSOR
       SYM-HIERARCHY-STORED-ACTIVE?
       NULL-BOOLEAN-WRAPPER))))
   (CL:LOOP
    (CL:WHEN (CL:EQ VALUE 1) (CL:RETURN-FROM ACTIVE? VALUE))
    (CL:SETQ
     CURSOR
     (CLSYS-SVAL POLYMORPHIC-RELATION SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ
      VALUE
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE
        CURSOR
        SYM-HIERARCHY-STORED-ACTIVE?
        NULL-BOOLEAN-WRAPPER)))
     (CL:RETURN-FROM ACTIVE? NULL-BOOLEAN))))
  :VOID)

;;; (DEFCLASS SLOT ...)

(CL:DEFCLASS SLOT (POLYMORPHIC-RELATION)
  ((SLOT-NAME :ALLOCATION :INSTANCE :ACCESSOR SLOT-NAME...OF)
   (SLOT-OWNER :ALLOCATION :INSTANCE :ACCESSOR SLOT-OWNER...OF)
   (SLOT-BASE-TYPE :ALLOCATION :INSTANCE :ACCESSOR SLOT-BASE-TYPE...OF)
   (SLOT-SLOTREF :ALLOCATION :INSTANCE :ACCESSOR SLOT-SLOTREF...OF)
   (SLOT-PUBLIC? :ALLOCATION :INSTANCE :ACCESSOR SLOT-PUBLIC?...OF)
   (SLOT-RENAMED? :ALLOCATION :INSTANCE :ACCESSOR SLOT-RENAMED?...OF)
   (SLOT-EXTERNAL? :ALLOCATION :INSTANCE :ACCESSOR SLOT-EXTERNAL?...OF)
   (SLOT-MARKED? :ALLOCATION :INSTANCE :ACCESSOR SLOT-MARKED?...OF)))

(CL:DEFMETHOD SLOT-AUXILIARY? ((SELF SLOT))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-HIERARCHY-SLOT-AUXILIARY?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM SLOT-AUXILIARY? FALSE)
    (CL:RETURN-FROM SLOT-AUXILIARY? ANSWER)))
  :VOID)

(CL:DEFMETHOD SLOT-DIRECT-SUPERS ((SELF SLOT))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-SLOT-DIRECT-SUPERS NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM SLOT-DIRECT-SUPERS NIL-LIST)
    (CL:RETURN-FROM SLOT-DIRECT-SUPERS ANSWER)))
  :VOID)

(CL:DEFMETHOD SLOT-DIRECT-SUBS ((SELF SLOT))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-SLOT-DIRECT-SUBS NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM SLOT-DIRECT-SUBS NIL-LIST)
    (CL:RETURN-FROM SLOT-DIRECT-SUBS ANSWER)))
  :VOID)

(CL:DEFUN ACCESS-SLOT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-NAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL SLOT SLOT-NAME SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-SLOT-SLOT-VALUE
      (CLSYS-SVAL SLOT SLOT-NAME SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-OWNER)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL SLOT SLOT-OWNER SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-SLOT-SLOT-VALUE
      (CLSYS-SVAL SLOT SLOT-OWNER SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-BASE-TYPE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL SLOT SLOT-BASE-TYPE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-SLOT-SLOT-VALUE
      (CLSYS-SVAL SLOT SLOT-BASE-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-SLOTREF)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL SLOT SLOT-SLOTREF SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-SLOT-SLOT-VALUE
      (CLSYS-SVAL SLOT SLOT-SLOTREF SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-PUBLIC?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SLOT SLOT-PUBLIC? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL SLOT SLOT-PUBLIC? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-RENAMED?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SLOT SLOT-RENAMED? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL SLOT SLOT-RENAMED? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-EXTERNAL?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SLOT SLOT-EXTERNAL? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL SLOT SLOT-EXTERNAL? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-MARKED?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SLOT SLOT-MARKED? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL SLOT SLOT-MARKED? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-AUXILIARY?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-SLOT-AUXILIARY?
      (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (SLOT-AUXILIARY? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-DIRECT-SUPERS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-SLOT-DIRECT-SUPERS VALUE NULL)
     (CL:RETURN-FROM ACCESS-SLOT-SLOT-VALUE (SLOT-DIRECT-SUPERS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-DIRECT-SUBS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-SLOT-DIRECT-SUBS VALUE NULL)
     (CL:RETURN-FROM ACCESS-SLOT-SLOT-VALUE (SLOT-DIRECT-SUBS SELF))))
   (CL:T
    (CL:COND
     ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-DOCUMENTATION)
      (CL:SETQ SLOTNAME SYM-HIERARCHY-DOCUMENTATION))
     (CL:T NULL))
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL SLOT DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-SLOT-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL SLOT DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-SLOT-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD NAME ((SELF SLOT))
  (CL:RETURN-FROM
   NAME
   (CLSYS-SVAL SYMBOL SYMBOL-NAME (CLSYS-SVAL SLOT SLOT-NAME SELF)))
  :VOID)

(CL:DEFMETHOD HOME-MODULE ((SELF SLOT))
  (CL:RETURN-FROM
   HOME-MODULE
   (CLSYS-SVAL SYMBOL HOME-CONTEXT (CLSYS-SVAL SLOT SLOT-NAME SELF)))
  :VOID)

(CL:DEFMETHOD TYPE ((SELF SLOT))
  "The type of a storage slot is its base type."
  (CL:LET*
   ((CURSOR SELF) (VALUE (CLSYS-SVAL SLOT SLOT-BASE-TYPE CURSOR)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM TYPE VALUE))
    (CL:SETQ CURSOR (CLSYS-SVAL SLOT SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE (CLSYS-SVAL SLOT SLOT-BASE-TYPE CURSOR))
     (CL:RETURN-FROM TYPE NULL))))
  :VOID)

(CL:DEFMETHOD TYPE-SPECIFIER ((SELF SLOT))
  "If 'self' has a complex type return its
type specifier, otherwise, return 'type' of 'self'."
  (CL:LET*
   ((TSPEC (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-SLOT-TYPE-SPECIFIER NULL)))
   (CL:RETURN-FROM
    TYPE-SPECIFIER
    (CL:IF (CL:NOT (CL:EQ TSPEC NULL)) TSPEC (TYPE SELF))))
  :VOID)

(CL:DEFMETHOD OWNER ((SELF SLOT))
  (CL:RETURN-FROM OWNER (CLSYS-SVAL SLOT SLOT-OWNER SELF))
  :VOID)

(CL:DEFMETHOD RENAMES ((SELF SLOT))
  (CL:RETURN-FROM
   RENAMES
   (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-SLOT-RENAMES NULL))
  :VOID)

(CL:DEFMETHOD SINGLE-VALUED? ((SELF SLOT))
  "True if slot values are not collections."
  (CL:RETURN-FROM
   SINGLE-VALUED?
   (CL:IF
    (CL:EQ
     (SUBTYPE-OF?
      (CLSYS-SVAL SLOT SLOT-BASE-TYPE SELF)
      SGT-HIERARCHY-COLLECTION)
     0)
    TRUE
    FALSE))
  :VOID)

(CL:DEFMETHOD CLOSURE-ASSUMPTION ((SELF SLOT))
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-SLOT-CLOSURE-ASSUMPTION NULL)))
   (CL:LOOP
    (CL:WHEN
     (CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM CLOSURE-ASSUMPTION VALUE))
    (CL:SETQ CURSOR (CLSYS-SVAL SLOT SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ
      VALUE
      (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-SLOT-CLOSURE-ASSUMPTION NULL))
     (CL:RETURN-FROM CLOSURE-ASSUMPTION NULL))))
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF SLOT) STREAM)
  (CL:PROGN
   (CL:WRITE-STRING "|S|" STREAM)
   (CL:WRITE-STRING
    (CLSYS-SVAL SURROGATE SYMBOL-NAME (CLSYS-SVAL SLOT SLOT-OWNER SELF))
    STREAM)
   (CL:WRITE-STRING "." STREAM)
   (CL:WRITE-STRING
    (CLSYS-SVAL SYMBOL SYMBOL-NAME (CLSYS-SVAL SLOT SLOT-NAME SELF))
    STREAM))
  :VOID)

;;; (DEFCLASS STORAGE-SLOT ...)

(CL:DEFCLASS STORAGE-SLOT (SLOT)
  ((SLOT-REQUIRED? :ALLOCATION :INSTANCE :ACCESSOR SLOT-REQUIRED?...OF)
   (SLOT-COMPONENT? :ALLOCATION :INSTANCE :ACCESSOR SLOT-COMPONENT?...OF)
   (SLOT-READ-ONLY? :ALLOCATION :INSTANCE :ACCESSOR SLOT-READ-ONLY?...OF)
   (SLOT-HARDWIRED? :ALLOCATION :INSTANCE :ACCESSOR SLOT-HARDWIRED?...OF)
   (SLOT-CONTEXT-SENSITIVE?
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SLOT-CONTEXT-SENSITIVE?...OF)))

(CL:DEFUN NEW-STORAGE-SLOT ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STORAGE-SLOT)))
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT BITS SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT ABSTRACT? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-DIRECT-EQUIVALENT SELF) NULL)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-MARKED? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-EXTERNAL? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-RENAMED? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-PUBLIC? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-SLOTREF SELF) NULL)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SELF) NULL)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SELF) NULL)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-NAME SELF) NULL)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-CONTEXT-SENSITIVE? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-HARDWIRED? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-READ-ONLY? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-COMPONENT? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL STORAGE-SLOT SLOT-REQUIRED? SELF) FALSE)
   (CL:RETURN-FROM NEW-STORAGE-SLOT SELF))
  :VOID)

(CL:DEFMETHOD SLOT-ALLOCATION ((SELF STORAGE-SLOT))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-SLOT-ALLOCATION NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM SLOT-ALLOCATION KWD-HIERARCHY-INSTANCE)
    (CL:RETURN-FROM SLOT-ALLOCATION ANSWER)))
  :VOID)

(CL:DEFMETHOD SLOT-GUARD-DEMONS ((SELF STORAGE-SLOT))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-SLOT-GUARD-DEMONS NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM SLOT-GUARD-DEMONS NIL-LIST)
    (CL:RETURN-FROM SLOT-GUARD-DEMONS ANSWER)))
  :VOID)

(CL:DEFMETHOD SLOT-DEMONS ((SELF STORAGE-SLOT))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-SLOT-DEMONS NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM SLOT-DEMONS NIL-LIST)
    (CL:RETURN-FROM SLOT-DEMONS ANSWER)))
  :VOID)

(CL:DEFMETHOD SLOT-ACCESSOR-METHODS ((SELF STORAGE-SLOT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-SLOT-ACCESSOR-METHODS NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM SLOT-ACCESSOR-METHODS NIL-LIST)
    (CL:RETURN-FROM SLOT-ACCESSOR-METHODS ANSWER)))
  :VOID)

(CL:DEFUN ACCESS-STORAGE-SLOT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-ALLOCATION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-SLOT-ALLOCATION VALUE NULL)
     (CL:RETURN-FROM ACCESS-STORAGE-SLOT-SLOT-VALUE (SLOT-ALLOCATION SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-GUARD-DEMONS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-SLOT-GUARD-DEMONS VALUE NULL)
     (CL:RETURN-FROM
      ACCESS-STORAGE-SLOT-SLOT-VALUE
      (SLOT-GUARD-DEMONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-DEMONS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-SLOT-DEMONS VALUE NULL)
     (CL:RETURN-FROM ACCESS-STORAGE-SLOT-SLOT-VALUE (SLOT-DEMONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-REQUIRED?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL STORAGE-SLOT SLOT-REQUIRED? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-STORAGE-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL STORAGE-SLOT SLOT-REQUIRED? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-COMPONENT?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL STORAGE-SLOT SLOT-COMPONENT? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-STORAGE-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL STORAGE-SLOT SLOT-COMPONENT? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-READ-ONLY?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL STORAGE-SLOT SLOT-READ-ONLY? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-STORAGE-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL STORAGE-SLOT SLOT-READ-ONLY? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-HARDWIRED?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL STORAGE-SLOT SLOT-HARDWIRED? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-STORAGE-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL STORAGE-SLOT SLOT-HARDWIRED? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-CONTEXT-SENSITIVE?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL STORAGE-SLOT SLOT-CONTEXT-SENSITIVE? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-STORAGE-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL STORAGE-SLOT SLOT-CONTEXT-SENSITIVE? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SLOT-ACCESSOR-METHODS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-SLOT-ACCESSOR-METHODS
      VALUE
      NULL)
     (CL:RETURN-FROM
      ACCESS-STORAGE-SLOT-SLOT-VALUE
      (SLOT-ACCESSOR-METHODS SELF))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL STORAGE-SLOT DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-STORAGE-SLOT-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL STORAGE-SLOT DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-STORAGE-SLOT-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STORAGE-SLOT))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STORAGE-SLOT)
  :VOID)

(CL:DEFMETHOD ALLOCATION ((SELF STORAGE-SLOT))
  "Return the most specific :allocation facet, or
:instance if all inherited values are NULL."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-SLOT-ALLOCATION NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM ALLOCATION VALUE))
    (CL:SETQ CURSOR (CLSYS-SVAL STORAGE-SLOT SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ
      VALUE
      (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-SLOT-ALLOCATION NULL))
     (CL:RETURN-FROM ALLOCATION KWD-HIERARCHY-INSTANCE))))
  :VOID)

(CL:DEFMETHOD DEFAULT-FORM ((SELF STORAGE-SLOT))
  "Returns the current value of default expression when the
slot has not been assigned a value."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-SLOT-DEFAULT-EXPRESSION NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM DEFAULT-FORM VALUE))
    (CL:SETQ CURSOR (CLSYS-SVAL STORAGE-SLOT SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ
      VALUE
      (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-SLOT-DEFAULT-EXPRESSION NULL))
     (CL:RETURN-FROM DEFAULT-FORM NULL))))
  :VOID)

(CL:DEFMETHOD REQUIRED? ((SELF STORAGE-SLOT))
  "True if a value must be assigned to this slot at
creation time."
  (CL:LET*
   ((CURSOR SELF) (VALUE (CLSYS-SVAL STORAGE-SLOT SLOT-REQUIRED? CURSOR)))
   (CL:LOOP
    (CL:WHEN (CL:EQ VALUE 1) (CL:RETURN-FROM REQUIRED? VALUE))
    (CL:SETQ CURSOR (CLSYS-SVAL STORAGE-SLOT SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE (CLSYS-SVAL STORAGE-SLOT SLOT-REQUIRED? CURSOR))
     (CL:RETURN-FROM REQUIRED? FALSE))))
  :VOID)

(CL:DEFMETHOD COMPONENT? ((SELF STORAGE-SLOT))
  "True if fillers of this slot are components of the
owner slot, and therefore should be deleted if the owner is deleted."
  (CL:LET*
   ((CURSOR SELF) (VALUE (CLSYS-SVAL STORAGE-SLOT SLOT-COMPONENT? CURSOR)))
   (CL:LOOP
    (CL:WHEN (CL:EQ VALUE 1) (CL:RETURN-FROM COMPONENT? VALUE))
    (CL:SETQ CURSOR (CLSYS-SVAL STORAGE-SLOT SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE (CLSYS-SVAL STORAGE-SLOT SLOT-COMPONENT? CURSOR))
     (CL:RETURN-FROM COMPONENT? FALSE))))
  :VOID)

(CL:DEFMETHOD READER ((SELF STORAGE-SLOT))
  "Name of a method called to read the value of the slot
'self'."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-SLOT-READER NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM READER VALUE))
    (CL:SETQ CURSOR (CLSYS-SVAL STORAGE-SLOT SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ
      VALUE
      (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-SLOT-READER NULL))
     (CL:RETURN-FROM READER NULL))))
  :VOID)

(CL:DEFMETHOD WRITER ((SELF STORAGE-SLOT))
  "Name of a method called to write the value of the slot
'self'."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-SLOT-WRITER NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM WRITER VALUE))
    (CL:SETQ CURSOR (CLSYS-SVAL STORAGE-SLOT SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ
      VALUE
      (DYNAMIC-SLOT-VALUE CURSOR SYM-HIERARCHY-SLOT-WRITER NULL))
     (CL:RETURN-FROM WRITER NULL))))
  :VOID)

;;; (DEFCLASS METHOD-SLOT ...)

(CL:DEFCLASS METHOD-SLOT (SLOT)
  ((METHOD-SETTER? :ALLOCATION :INSTANCE :ACCESSOR METHOD-SETTER?...OF)
   (METHOD-PARAMETER-NAMES
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    METHOD-PARAMETER-NAMES...OF)
   (METHOD-PARAMETER-TYPE-SPECIFIERS
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    METHOD-PARAMETER-TYPE-SPECIFIERS...OF)
   (METHOD-RETURN-TYPE-SPECIFIERS
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    METHOD-RETURN-TYPE-SPECIFIERS...OF)
   (METHOD-STRINGIFIED-SOURCE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    METHOD-STRINGIFIED-SOURCE...OF)
   (METHOD-CODE :ALLOCATION :INSTANCE :ACCESSOR METHOD-CODE...OF)
   (FUNCTION-CODE :ALLOCATION :INSTANCE :ACCESSOR FUNCTION-CODE...OF)
   (METHOD-FUNCTION? :ALLOCATION :INSTANCE :ACCESSOR METHOD-FUNCTION?...OF)))

(CL:DEFUN NEW-METHOD-SLOT ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE METHOD-SLOT)))
   (CL:SETF (CLSYS-SVAL METHOD-SLOT BITS SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (CLSYS-SVAL METHOD-SLOT ABSTRACT? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT SLOT-DIRECT-EQUIVALENT SELF) NULL)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT SLOT-MARKED? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT SLOT-EXTERNAL? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT SLOT-RENAMED? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT SLOT-PUBLIC? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT SLOT-SLOTREF SELF) NULL)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT SLOT-BASE-TYPE SELF) NULL)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT SLOT-OWNER SELF) NULL)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT SLOT-NAME SELF) NULL)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE SELF) NULL)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE SELF) NULL)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-STRINGIFIED-SOURCE SELF) NULL)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-RETURN-TYPE-SPECIFIERS SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL METHOD-SLOT METHOD-PARAMETER-TYPE-SPECIFIERS SELF)
    NULL)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-PARAMETER-NAMES SELF) NULL)
   (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-SETTER? SELF) FALSE)
   (CL:RETURN-FROM NEW-METHOD-SLOT SELF))
  :VOID)

(CL:DEFMETHOD METHOD-PARAMETER-NAMES ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER (CLSYS-SVAL METHOD-SLOT METHOD-PARAMETER-NAMES SELF)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM METHOD-PARAMETER-NAMES NIL-LIST)
    (CL:RETURN-FROM METHOD-PARAMETER-NAMES ANSWER)))
  :VOID)

(CL:DEFMETHOD METHOD-PARAMETER-TYPE-SPECIFIERS ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER (CLSYS-SVAL METHOD-SLOT METHOD-PARAMETER-TYPE-SPECIFIERS SELF)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM METHOD-PARAMETER-TYPE-SPECIFIERS NIL-LIST)
    (CL:RETURN-FROM METHOD-PARAMETER-TYPE-SPECIFIERS ANSWER)))
  :VOID)

(CL:DEFMETHOD METHOD-PARAMETER-DIRECTIONS ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-METHOD-PARAMETER-DIRECTIONS
      NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM METHOD-PARAMETER-DIRECTIONS NIL-LIST)
    (CL:RETURN-FROM METHOD-PARAMETER-DIRECTIONS ANSWER)))
  :VOID)

(CL:DEFMETHOD METHOD-RETURN-TYPE-SPECIFIERS ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER (CLSYS-SVAL METHOD-SLOT METHOD-RETURN-TYPE-SPECIFIERS SELF)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM METHOD-RETURN-TYPE-SPECIFIERS NIL-LIST)
    (CL:RETURN-FROM METHOD-RETURN-TYPE-SPECIFIERS ANSWER)))
  :VOID)

(CL:DEFMETHOD METHOD-VARIABLE-ARGUMENTS? ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-HIERARCHY-METHOD-VARIABLE-ARGUMENTS?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM METHOD-VARIABLE-ARGUMENTS? FALSE)
    (CL:RETURN-FROM METHOD-VARIABLE-ARGUMENTS? ANSWER)))
  :VOID)

(CL:DEFMETHOD METHOD-BODY-ARGUMENT? ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-HIERARCHY-METHOD-BODY-ARGUMENT?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM METHOD-BODY-ARGUMENT? FALSE)
    (CL:RETURN-FROM METHOD-BODY-ARGUMENT? ANSWER)))
  :VOID)

(CL:DEFMETHOD METHOD-AUXILIARY? ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-HIERARCHY-SLOT-AUXILIARY?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM METHOD-AUXILIARY? FALSE)
    (CL:RETURN-FROM METHOD-AUXILIARY? ANSWER)))
  :VOID)

(CL:DEFMETHOD METHOD-NATIVE? ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-HIERARCHY-METHOD-NATIVE?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM METHOD-NATIVE? FALSE)
    (CL:RETURN-FROM METHOD-NATIVE? ANSWER)))
  :VOID)

(CL:DEFMETHOD METHOD-GLOBALLY-INLINE? ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-HIERARCHY-METHOD-GLOBALLY-INLINE?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM METHOD-GLOBALLY-INLINE? FALSE)
    (CL:RETURN-FROM METHOD-GLOBALLY-INLINE? ANSWER)))
  :VOID)

(CL:DEFMETHOD METHOD-INLINED-FUNCTIONS ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-METHOD-INLINED-FUNCTIONS NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM METHOD-INLINED-FUNCTIONS NIL-LIST)
    (CL:RETURN-FROM METHOD-INLINED-FUNCTIONS ANSWER)))
  :VOID)

(CL:DEFMETHOD METHOD-COMMAND? ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-HIERARCHY-METHOD-COMMAND?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM METHOD-COMMAND? FALSE)
    (CL:RETURN-FROM METHOD-COMMAND? ANSWER)))
  :VOID)

(CL:DEFMETHOD METHOD-EVALUATE-ARGUMENTS? ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-HIERARCHY-METHOD-EVALUATE-ARGUMENTS?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM METHOD-EVALUATE-ARGUMENTS? TRUE)
    (CL:RETURN-FROM METHOD-EVALUATE-ARGUMENTS? ANSWER)))
  :VOID)

(CL:DEFMETHOD METHOD-LISP-MACRO? ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-HIERARCHY-METHOD-LISP-MACRO?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM METHOD-LISP-MACRO? NULL-BOOLEAN)
    (CL:RETURN-FROM METHOD-LISP-MACRO? ANSWER)))
  :VOID)

(CL:DEFUN ACCESS-METHOD-SLOT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-SETTER?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-SETTER? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL METHOD-SLOT METHOD-SETTER? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-PARAMETER-NAMES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-PARAMETER-NAMES SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (METHOD-PARAMETER-NAMES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-PARAMETER-TYPE-SPECIFIERS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-PARAMETER-TYPE-SPECIFIERS SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (METHOD-PARAMETER-TYPE-SPECIFIERS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-PARAMETER-DIRECTIONS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-METHOD-PARAMETER-DIRECTIONS
      VALUE
      NULL)
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (METHOD-PARAMETER-DIRECTIONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-RETURN-TYPE-SPECIFIERS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-RETURN-TYPE-SPECIFIERS SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (METHOD-RETURN-TYPE-SPECIFIERS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-STRINGIFIED-SOURCE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-STRINGIFIED-SOURCE SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL METHOD-SLOT METHOD-STRINGIFIED-SOURCE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-CODE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE SELF)
      (CLSYS-SVAL METHOD-CODE-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL METHOD-SLOT METHOD-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-FUNCTION-CODE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE SELF)
      (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-FUNCTION?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-VARIABLE-ARGUMENTS?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-METHOD-VARIABLE-ARGUMENTS?
      (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (METHOD-VARIABLE-ARGUMENTS? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-BODY-ARGUMENT?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-METHOD-BODY-ARGUMENT?
      (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (METHOD-BODY-ARGUMENT? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-AUXILIARY?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-SLOT-AUXILIARY?
      (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (METHOD-AUXILIARY? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-NATIVE?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-METHOD-NATIVE?
      (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (METHOD-NATIVE? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-GLOBALLY-INLINE?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-METHOD-GLOBALLY-INLINE?
      (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (METHOD-GLOBALLY-INLINE? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-INLINED-FUNCTIONS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-METHOD-INLINED-FUNCTIONS
      VALUE
      NULL)
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (METHOD-INLINED-FUNCTIONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-COMMAND?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-METHOD-COMMAND?
      (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (METHOD-COMMAND? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-EVALUATE-ARGUMENTS?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-METHOD-EVALUATE-ARGUMENTS?
      (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (METHOD-EVALUATE-ARGUMENTS? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-LISP-MACRO?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-METHOD-LISP-MACRO?
      (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (WRAP-BOOLEAN (METHOD-LISP-MACRO? SELF)))))
   (CL:T
    (CL:COND
     ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-DOCUMENTATION)
      (CL:SETQ SLOTNAME SYM-HIERARCHY-DOCUMENTATION))
     ((CL:EQ SLOTNAME SYM-HIERARCHY-METHOD-STORAGE-SLOT)
      (CL:SETQ SLOTNAME SYM-HIERARCHY-STORAGE-SLOT))
     (CL:T NULL))
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL METHOD-SLOT DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-METHOD-SLOT-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL METHOD-SLOT DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-METHOD-SLOT-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF METHOD-SLOT))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-METHOD-SLOT)
  :VOID)

(CL:DEFMETHOD SETTER? ((SELF METHOD-SLOT))
  (CL:RETURN-FROM SETTER? (CLSYS-SVAL METHOD-SLOT METHOD-SETTER? SELF))
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF METHOD-SLOT) STREAM)
  (CL:IF
   (CL:EQ (CLSYS-SVAL METHOD-SLOT METHOD-FUNCTION? SELF) 1)
   (CL:PROGN
    (CL:WRITE-STRING "|F|" STREAM)
    (CL:WRITE-STRING
     (CLSYS-SVAL SYMBOL SYMBOL-NAME (CLSYS-SVAL METHOD-SLOT SLOT-NAME SELF))
     STREAM))
   (CL:PROGN
    (CL:WRITE-STRING "|M|" STREAM)
    (CL:WRITE-STRING
     (CLSYS-SVAL
      SURROGATE
      SYMBOL-NAME
      (CLSYS-SVAL METHOD-SLOT SLOT-OWNER SELF))
     STREAM)
    (CL:WRITE-STRING "." STREAM)
    (CL:WRITE-STRING
     (CLSYS-SVAL SYMBOL SYMBOL-NAME (CLSYS-SVAL METHOD-SLOT SLOT-NAME SELF))
     STREAM)))
  :VOID)

;;; (DEFCLASS COMPOUND-TYPE-SPECIFIER ...)

(CL:DEFCLASS COMPOUND-TYPE-SPECIFIER (STANDARD-OBJECT)
  ())

(CL:DEFMETHOD PRINT-OBJECT ((SELF COMPOUND-TYPE-SPECIFIER) STREAM)
  (CL:PROGN
   (CL:WRITE-STRING "|TS|" STREAM)
   (PRINT-OBJECT (YIELD-TYPE-SPEC-TREE SELF) STREAM))
  :VOID)

;;; (DEFCLASS PARAMETRIC-TYPE-SPECIFIER ...)

(CL:DEFCLASS PARAMETRIC-TYPE-SPECIFIER (COMPOUND-TYPE-SPECIFIER)
  ((SPECIFIER-BASE-TYPE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SPECIFIER-BASE-TYPE...OF)
   (SPECIFIER-PARAMETER-TYPES
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SPECIFIER-PARAMETER-TYPES...OF)
   (SPECIFIER-SEQUENCE-SIZE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SPECIFIER-SEQUENCE-SIZE...OF)))

(CL:DEFUN NEW-PARAMETRIC-TYPE-SPECIFIER ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (MAKE-PARAMETRIC-TYPE-SPECIFIER))
   (CL:SETF
    (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-SEQUENCE-SIZE SELF)
    NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-PARAMETER-TYPES SELF)
    (NEW-LIST))
   (CL:SETF
    (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE SELF)
    NULL)
   (CL:RETURN-FROM NEW-PARAMETRIC-TYPE-SPECIFIER SELF))
  :VOID)

(CL:DEFUN ACCESS-PARAMETRIC-TYPE-SPECIFIER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SPECIFIER-BASE-TYPE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-PARAMETRIC-TYPE-SPECIFIER-SLOT-VALUE
      (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-BASE-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SPECIFIER-PARAMETER-TYPES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-PARAMETER-TYPES SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-PARAMETRIC-TYPE-SPECIFIER-SLOT-VALUE
      (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-PARAMETER-TYPES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SPECIFIER-SEQUENCE-SIZE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-SEQUENCE-SIZE SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-PARAMETRIC-TYPE-SPECIFIER-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL PARAMETRIC-TYPE-SPECIFIER SPECIFIER-SEQUENCE-SIZE SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-PARAMETRIC-TYPE-SPECIFIER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PARAMETRIC-TYPE-SPECIFIER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-PARAMETRIC-TYPE-SPECIFIER)
  :VOID)

;;; (DEFCLASS TRANSIENT-TYPE-SPECIFIER ...)

(CL:DEFCLASS TRANSIENT-TYPE-SPECIFIER (PARAMETRIC-TYPE-SPECIFIER TRANSIENT-MIXIN)
  ((NEXT-SWEEP-LIST-OBJECT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    NEXT-SWEEP-LIST-OBJECT...OF)))

(CL:DEFUN NEW-TRANSIENT-TYPE-SPECIFIER ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF *UNUSED-TRANSIENT-TYPE-SPECIFIER-S*)
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL))
     (CL:SETQ
      *UNUSED-TRANSIENT-TYPE-SPECIFIER-S*
      (CLSYS-SVAL
       TRANSIENT-TYPE-SPECIFIER
       NEXT-SWEEP-LIST-OBJECT
       *UNUSED-TRANSIENT-TYPE-SPECIFIER-S*))
     (TERMINATE-TRANSIENT-TYPE-SPECIFIER? SELF))
    (CL:T
     (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRANSIENT-TYPE-SPECIFIER)))
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-TYPE-SPECIFIER NEXT-SWEEP-LIST-OBJECT SELF)
      *ALL-TRANSIENT-TYPE-SPECIFIER-S*)
     (CL:SETQ *ALL-TRANSIENT-TYPE-SPECIFIER-S* SELF)))
   (CL:SETF
    (CLSYS-SVAL TRANSIENT-TYPE-SPECIFIER SPECIFIER-SEQUENCE-SIZE SELF)
    NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL TRANSIENT-TYPE-SPECIFIER SPECIFIER-PARAMETER-TYPES SELF)
    (NEW-LIST))
   (CL:SETF
    (CLSYS-SVAL TRANSIENT-TYPE-SPECIFIER SPECIFIER-BASE-TYPE SELF)
    NULL)
   (CL:RETURN-FROM NEW-TRANSIENT-TYPE-SPECIFIER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF TRANSIENT-TYPE-SPECIFIER))
  NULL
  :VOID)

(CL:DEFMETHOD SWEEP ((SELF TRANSIENT-TYPE-SPECIFIER))
  (CL:SETQ *UNUSED-TRANSIENT-TYPE-SPECIFIER-S* *ALL-TRANSIENT-TYPE-SPECIFIER-S*)
  :VOID)

(CL:DEFUN ACCESS-TRANSIENT-TYPE-SPECIFIER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-NEXT-SWEEP-LIST-OBJECT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-TYPE-SPECIFIER NEXT-SWEEP-LIST-OBJECT SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-TRANSIENT-TYPE-SPECIFIER-SLOT-VALUE
      (CLSYS-SVAL TRANSIENT-TYPE-SPECIFIER NEXT-SWEEP-LIST-OBJECT SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-TRANSIENT-TYPE-SPECIFIER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSIENT-TYPE-SPECIFIER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-TRANSIENT-TYPE-SPECIFIER)
  :VOID)

;;; (DEFCLASS ANCHORED-TYPE-SPECIFIER ...)

(CL:DEFCLASS ANCHORED-TYPE-SPECIFIER (COMPOUND-TYPE-SPECIFIER)
  ((SPECIFIER-PARAMETER-NAME
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SPECIFIER-PARAMETER-NAME...OF)))

(CL:DEFUN NEW-ANCHORED-TYPE-SPECIFIER ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE ANCHORED-TYPE-SPECIFIER)))
   (CL:SETF
    (CLSYS-SVAL ANCHORED-TYPE-SPECIFIER SPECIFIER-PARAMETER-NAME SELF)
    NULL)
   (CL:RETURN-FROM NEW-ANCHORED-TYPE-SPECIFIER SELF))
  :VOID)

(CL:DEFUN ACCESS-ANCHORED-TYPE-SPECIFIER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SPECIFIER-PARAMETER-NAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL ANCHORED-TYPE-SPECIFIER SPECIFIER-PARAMETER-NAME SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-ANCHORED-TYPE-SPECIFIER-SLOT-VALUE
      (CLSYS-SVAL ANCHORED-TYPE-SPECIFIER SPECIFIER-PARAMETER-NAME SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-ANCHORED-TYPE-SPECIFIER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ANCHORED-TYPE-SPECIFIER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-ANCHORED-TYPE-SPECIFIER)
  :VOID)

;;; (DEFCLASS TABLE ...)

(CL:DEFCLASS TABLE (SLOT)
  ((TUPLE-DOMAINS :ALLOCATION :INSTANCE :ACCESSOR TUPLE-DOMAINS...OF)))

(CL:DEFUN NEW-TABLE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TABLE)))
   (CL:SETF (CLSYS-SVAL TABLE BITS SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL TABLE DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (CLSYS-SVAL TABLE ABSTRACT? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL TABLE SLOT-DIRECT-EQUIVALENT SELF) NULL)
   (CL:SETF (CLSYS-SVAL TABLE SLOT-MARKED? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL TABLE SLOT-EXTERNAL? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL TABLE SLOT-RENAMED? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL TABLE SLOT-PUBLIC? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL TABLE SLOT-SLOTREF SELF) NULL)
   (CL:SETF (CLSYS-SVAL TABLE SLOT-BASE-TYPE SELF) NULL)
   (CL:SETF (CLSYS-SVAL TABLE SLOT-OWNER SELF) NULL)
   (CL:SETF (CLSYS-SVAL TABLE SLOT-NAME SELF) NULL)
   (CL:SETF (CLSYS-SVAL TABLE TUPLE-DOMAINS SELF) NULL)
   (CL:RETURN-FROM NEW-TABLE SELF))
  :VOID)

(CL:DEFMETHOD VARIABLE-ARITY? ((SELF TABLE))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-HIERARCHY-VARIABLE-ARITY?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM VARIABLE-ARITY? FALSE)
    (CL:RETURN-FROM VARIABLE-ARITY? ANSWER)))
  :VOID)

(CL:DEFUN ACCESS-TABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-TUPLE-DOMAINS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TABLE TUPLE-DOMAINS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TABLE-SLOT-VALUE
      (CLSYS-SVAL TABLE TUPLE-DOMAINS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-VARIABLE-ARITY?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-VARIABLE-ARITY?
      (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-TABLE-SLOT-VALUE
      (WRAP-BOOLEAN (VARIABLE-ARITY? SELF)))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL TABLE DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-TABLE-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL TABLE DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-TABLE-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-TABLE)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF TABLE) STREAM)
  (CL:PROGN
   (CL:WRITE-STRING "|T|" STREAM)
   (CL:WRITE-STRING
    (CLSYS-SVAL SYMBOL SYMBOL-NAME (CLSYS-SVAL TABLE SLOT-NAME SELF))
    STREAM))
  :VOID)

;;; (DEFCLASS GLOBAL-VARIABLE ...)

(CL:DEFCLASS GLOBAL-VARIABLE (MAPPABLE-OBJECT)
  ((DOCUMENTATION :ALLOCATION :INSTANCE :ACCESSOR DOCUMENTATION...OF)
   (VARIABLE-NAME :ALLOCATION :INSTANCE :ACCESSOR VARIABLE-NAME...OF)
   (VARIABLE-TYPE :ALLOCATION :INSTANCE :ACCESSOR VARIABLE-TYPE...OF)
   (VARIABLE-SPECIAL? :ALLOCATION :INSTANCE :ACCESSOR VARIABLE-SPECIAL?...OF)
   (VARIABLE-CONSTANT?
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    VARIABLE-CONSTANT?...OF)
   (VARIABLE-PUBLIC? :ALLOCATION :INSTANCE :ACCESSOR VARIABLE-PUBLIC?...OF)
   (VARIABLE-AUXILIARY?
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    VARIABLE-AUXILIARY?...OF)
   (VARIABLE-GET-VALUE-CODE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    VARIABLE-GET-VALUE-CODE...OF)
   (VARIABLE-SET-VALUE-CODE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    VARIABLE-SET-VALUE-CODE...OF)
   (VARIABLE-VALUE-STACK
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    VARIABLE-VALUE-STACK...OF)
   (VARIABLE-STRINGIFIED-SOURCE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    VARIABLE-STRINGIFIED-SOURCE...OF)))

(CL:DEFUN NEW-GLOBAL-VARIABLE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE GLOBAL-VARIABLE)))
   (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE BITS SELF) NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL GLOBAL-VARIABLE DYNAMIC-SLOTS SELF)
    (NEW-KEY-VALUE-LIST))
   (CL:SETF
    (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-STRINGIFIED-SOURCE SELF)
    NULL)
   (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE DOCUMENTATION SELF) NULL)
   (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-VALUE-STACK SELF) NULL)
   (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE SELF) NULL)
   (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE SELF) NULL)
   (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-AUXILIARY? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-PUBLIC? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-CONSTANT? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SPECIAL? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-TYPE SELF) NULL)
   (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME SELF) NULL)
   (CL:RETURN-FROM NEW-GLOBAL-VARIABLE SELF))
  :VOID)

(CL:DEFUN ACCESS-GLOBAL-VARIABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-DOCUMENTATION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE DOCUMENTATION SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-GLOBAL-VARIABLE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL GLOBAL-VARIABLE DOCUMENTATION SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-VARIABLE-NAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-GLOBAL-VARIABLE-SLOT-VALUE
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-VARIABLE-TYPE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-TYPE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-GLOBAL-VARIABLE-SLOT-VALUE
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-VARIABLE-SPECIAL?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SPECIAL? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-GLOBAL-VARIABLE-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SPECIAL? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-VARIABLE-CONSTANT?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-CONSTANT? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-GLOBAL-VARIABLE-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-CONSTANT? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-VARIABLE-PUBLIC?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-PUBLIC? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-GLOBAL-VARIABLE-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-PUBLIC? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-VARIABLE-AUXILIARY?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-AUXILIARY? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-GLOBAL-VARIABLE-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-AUXILIARY? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-VARIABLE-GET-VALUE-CODE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE SELF)
      (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-GLOBAL-VARIABLE-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-VARIABLE-SET-VALUE-CODE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE SELF)
      (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-GLOBAL-VARIABLE-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-VARIABLE-VALUE-STACK)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-VALUE-STACK SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-GLOBAL-VARIABLE-SLOT-VALUE
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-VALUE-STACK SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-VARIABLE-DOCUMENTATION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE DOCUMENTATION SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-GLOBAL-VARIABLE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL GLOBAL-VARIABLE DOCUMENTATION SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-VARIABLE-STRINGIFIED-SOURCE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-STRINGIFIED-SOURCE SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-GLOBAL-VARIABLE-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-STRINGIFIED-SOURCE SELF)))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL GLOBAL-VARIABLE DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-GLOBAL-VARIABLE-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL GLOBAL-VARIABLE DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-GLOBAL-VARIABLE-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF GLOBAL-VARIABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-GLOBAL-VARIABLE)
  :VOID)

(CL:DEFMETHOD NAME ((SELF GLOBAL-VARIABLE))
  (CL:RETURN-FROM
   NAME
   (CLSYS-SVAL
    SYMBOL
    SYMBOL-NAME
    (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-NAME SELF)))
  :VOID)

(CL:DEFMETHOD TYPE ((SELF GLOBAL-VARIABLE))
  (CL:RETURN-FROM TYPE (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-TYPE SELF))
  :VOID)

;;; (DEFCLASS QUOTED-EXPRESSION ...)

(CL:DEFCLASS QUOTED-EXPRESSION (STANDARD-OBJECT)
  ((QUOTATION-TABLE-OFFSET
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    QUOTATION-TABLE-OFFSET...OF)))

(CL:DEFUN NEW-QUOTED-EXPRESSION ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE QUOTED-EXPRESSION)))
   (CL:SETF
    (CLSYS-SVAL QUOTED-EXPRESSION QUOTATION-TABLE-OFFSET SELF)
    NULL-INTEGER)
   (CL:RETURN-FROM NEW-QUOTED-EXPRESSION SELF))
  :VOID)

(CL:DEFUN ACCESS-QUOTED-EXPRESSION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-QUOTATION-TABLE-OFFSET)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUOTED-EXPRESSION QUOTATION-TABLE-OFFSET SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-QUOTED-EXPRESSION-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL QUOTED-EXPRESSION QUOTATION-TABLE-OFFSET SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-QUOTED-EXPRESSION-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF QUOTED-EXPRESSION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-QUOTED-EXPRESSION)
  :VOID)

;;; (DEFCLASS VOID ...)

(CL:DEFCLASS VOID ()
  ())

;;; (DEFCLASS UNKNOWN ...)

(CL:DEFCLASS UNKNOWN ()
  ())

;;; (DEFCLASS CONTEXT ...)

(CL:DEFCLASS CONTEXT (STANDARD-OBJECT DYNAMIC-SLOTS-MIXIN)
  ((CHILD-CONTEXTS :ALLOCATION :INSTANCE :ACCESSOR CHILD-CONTEXTS...OF)
   (ALL-SUPER-CONTEXTS
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    ALL-SUPER-CONTEXTS...OF)
   (BASE-MODULE :ALLOCATION :INSTANCE :ACCESSOR BASE-MODULE...OF)
   (CONTEXT-NUMBER :ALLOCATION :INSTANCE :ACCESSOR CONTEXT-NUMBER...OF)))

(CL:DEFUN ACCESS-CONTEXT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CHILD-CONTEXTS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CONTEXT CHILD-CONTEXTS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-CONTEXT-SLOT-VALUE
      (CLSYS-SVAL CONTEXT CHILD-CONTEXTS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ALL-SUPER-CONTEXTS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CONTEXT ALL-SUPER-CONTEXTS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-CONTEXT-SLOT-VALUE
      (CLSYS-SVAL CONTEXT ALL-SUPER-CONTEXTS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-BASE-MODULE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL CONTEXT BASE-MODULE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-CONTEXT-SLOT-VALUE
      (CLSYS-SVAL CONTEXT BASE-MODULE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CONTEXT-NUMBER)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTEXT CONTEXT-NUMBER SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CONTEXT-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL CONTEXT CONTEXT-NUMBER SELF)))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL CONTEXT DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-CONTEXT-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL CONTEXT DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-CONTEXT-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD CONTEXT-NAME ((SELF CONTEXT))
  (CL:LET*
   ((AUX SELF))
   (CL:LET*
    ((AUX-001 AUX))
    (CL:COND
     ((CL:EQ (TAXONOMY-ISA? AUX SGT-HIERARCHY-MODULE) 1)
      (CL:LET*
       ((AUX NULL))
       (CL:SETQ AUX AUX-001)
       (CL:RETURN-FROM CONTEXT-NAME (CLSYS-SVAL MODULE MODULE-NAME AUX))))
     ((CL:EQ (TAXONOMY-ISA? AUX SGT-HIERARCHY-WORLD) 1)
      (CL:LET*
       ((AUX NULL))
       (CL:SETQ AUX AUX-001)
       (CL:RETURN-FROM
        CONTEXT-NAME
        (CLSYS-SVAL
         STRING-WRAPPER
         WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE
          AUX
          SYM-HIERARCHY-WORLD-NAME
          NULL-STRING-WRAPPER)))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" AUX)))))
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF CONTEXT) STREAM)
  (PRINT-CONTEXT SELF STREAM)
  :VOID)

;;; (DEFCLASS MODULE ...)

(CL:DEFCLASS MODULE (CONTEXT)
  ((PARENT-MODULES :ALLOCATION :INSTANCE :ACCESSOR PARENT-MODULES...OF)
   (DOCUMENTATION :ALLOCATION :INSTANCE :ACCESSOR DOCUMENTATION...OF)
   (REQUIRES :ALLOCATION :INSTANCE :ACCESSOR REQUIRES...OF)
   (USES :ALLOCATION :INSTANCE :ACCESSOR USES...OF)
   (USED-BY :ALLOCATION :INSTANCE :ACCESSOR USED-BY...OF)
   (MODULE-NATIVE-PACKAGE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    MODULE-NATIVE-PACKAGE...OF)
   (DIRECTORY-FILE :ALLOCATION :INSTANCE :ACCESSOR DIRECTORY-FILE...OF)
   (CODE-FILES :ALLOCATION :INSTANCE :ACCESSOR CODE-FILES...OF)
   (DEFINITIONS-FILE :ALLOCATION :INSTANCE :ACCESSOR DEFINITIONS-FILE...OF)
   (OPEN-WORLD-ASSUMPTION?
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    OPEN-WORLD-ASSUMPTION?...OF)
   (CASE-SENSITIVE? :ALLOCATION :INSTANCE :ACCESSOR CASE-SENSITIVE?...OF)
   (MODULE-NAME :ALLOCATION :INSTANCE :ACCESSOR MODULE-NAME...OF)
   (MODULE-FULL-NAME :ALLOCATION :INSTANCE :ACCESSOR MODULE-FULL-NAME...OF)
   (MODULE-STRINGIFIED-SOURCE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    MODULE-STRINGIFIED-SOURCE...OF)
   (STRINGIFIED-OPTIONS
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    STRINGIFIED-OPTIONS...OF)
   (CARDINAL-MODULE :ALLOCATION :INSTANCE :ACCESSOR CARDINAL-MODULE...OF)
   (SYMBOL-OFFSET-TABLE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SYMBOL-OFFSET-TABLE...OF)
   (SURROGATE-OFFSET-TABLE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SURROGATE-OFFSET-TABLE...OF)
   (INDEXICAL-OFFSET-TABLE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    INDEXICAL-OFFSET-TABLE...OF)
   (ELABORATED-WORLD :ALLOCATION :INSTANCE :ACCESSOR ELABORATED-WORLD...OF)))

(CL:DEFUN NEW-MODULE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE MODULE)))
   (CL:SETF (CLSYS-SVAL MODULE BITS SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL MODULE DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (CLSYS-SVAL MODULE CONTEXT-NUMBER SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL MODULE BASE-MODULE SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE ALL-SUPER-CONTEXTS SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE CHILD-CONTEXTS SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL MODULE ELABORATED-WORLD SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE INDEXICAL-OFFSET-TABLE SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE SURROGATE-OFFSET-TABLE SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE SYMBOL-OFFSET-TABLE SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE CARDINAL-MODULE SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE STRINGIFIED-OPTIONS SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE MODULE-STRINGIFIED-SOURCE SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE MODULE-FULL-NAME SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE MODULE-NAME SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE CASE-SENSITIVE? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL MODULE OPEN-WORLD-ASSUMPTION? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL MODULE DEFINITIONS-FILE SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE CODE-FILES SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL MODULE DIRECTORY-FILE SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE MODULE-NATIVE-PACKAGE SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE USED-BY SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL MODULE USES SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL MODULE REQUIRES SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE DOCUMENTATION SELF) NULL)
   (CL:SETF (CLSYS-SVAL MODULE PARENT-MODULES SELF) (NEW-LIST))
   (CL:RETURN-FROM NEW-MODULE SELF))
  :VOID)

(CL:DEFMETHOD SHADOWED-SURROGATES ((SELF MODULE))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-SHADOWED-SURROGATES NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM SHADOWED-SURROGATES NIL-LIST)
    (CL:RETURN-FROM SHADOWED-SURROGATES ANSWER)))
  :VOID)

(CL:DEFMETHOD MODULE-NATIVE-PACKAGE ((SELF MODULE))
  (CL:LET*
   ((ANSWER (CLSYS-SVAL MODULE MODULE-NATIVE-PACKAGE SELF)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM MODULE-NATIVE-PACKAGE "STELLA")
    (CL:RETURN-FROM MODULE-NATIVE-PACKAGE ANSWER)))
  :VOID)

(CL:DEFMETHOD LOGIC-DIALECT ((SELF MODULE))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-LOGIC-DIALECT NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM LOGIC-DIALECT KWD-HIERARCHY-KIF)
    (CL:RETURN-FROM LOGIC-DIALECT ANSWER)))
  :VOID)

(CL:DEFMETHOD CLEARABLE? ((SELF MODULE))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-HIERARCHY-CLEARABLE?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM CLEARABLE? TRUE)
    (CL:RETURN-FROM CLEARABLE? ANSWER)))
  :VOID)

(CL:DEFUN ACCESS-MODULE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-PARENT-MODULES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL MODULE PARENT-MODULES SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (CLSYS-SVAL MODULE PARENT-MODULES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-DOCUMENTATION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL MODULE DOCUMENTATION SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL MODULE DOCUMENTATION SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-REQUIRES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL MODULE REQUIRES SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (CLSYS-SVAL MODULE REQUIRES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-USES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL MODULE USES SELF) VALUE)
     (CL:RETURN-FROM ACCESS-MODULE-SLOT-VALUE (CLSYS-SVAL MODULE USES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-USED-BY)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL MODULE USED-BY SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (CLSYS-SVAL MODULE USED-BY SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SHADOWED-SURROGATES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-SHADOWED-SURROGATES
      VALUE
      NULL)
     (CL:RETURN-FROM ACCESS-MODULE-SLOT-VALUE (SHADOWED-SURROGATES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-MODULE-NATIVE-PACKAGE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL MODULE MODULE-NATIVE-PACKAGE SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (WRAP-LITERAL (MODULE-NATIVE-PACKAGE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-DIRECTORY-FILE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL MODULE DIRECTORY-FILE SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL MODULE DIRECTORY-FILE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CODE-FILES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL MODULE CODE-FILES SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (CLSYS-SVAL MODULE CODE-FILES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-DEFINITIONS-FILE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL MODULE DEFINITIONS-FILE SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL MODULE DEFINITIONS-FILE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-LOGIC-DIALECT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE SELF SYM-HIERARCHY-LOGIC-DIALECT VALUE NULL)
     (CL:RETURN-FROM ACCESS-MODULE-SLOT-VALUE (LOGIC-DIALECT SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-OPEN-WORLD-ASSUMPTION?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL MODULE OPEN-WORLD-ASSUMPTION? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL MODULE OPEN-WORLD-ASSUMPTION? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CASE-SENSITIVE?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL MODULE CASE-SENSITIVE? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL MODULE CASE-SENSITIVE? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CLEARABLE?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-HIERARCHY-CLEARABLE?
      (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (WRAP-BOOLEAN (CLEARABLE? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-MODULE-NAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL MODULE MODULE-NAME SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL MODULE MODULE-NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-MODULE-FULL-NAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL MODULE MODULE-FULL-NAME SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL MODULE MODULE-FULL-NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-MODULE-STRINGIFIED-SOURCE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL MODULE MODULE-STRINGIFIED-SOURCE SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL MODULE MODULE-STRINGIFIED-SOURCE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STRINGIFIED-OPTIONS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL MODULE STRINGIFIED-OPTIONS SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL MODULE STRINGIFIED-OPTIONS SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CARDINAL-MODULE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL MODULE CARDINAL-MODULE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (CLSYS-SVAL MODULE CARDINAL-MODULE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SYMBOL-OFFSET-TABLE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL MODULE SYMBOL-OFFSET-TABLE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (CLSYS-SVAL MODULE SYMBOL-OFFSET-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-SURROGATE-OFFSET-TABLE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL MODULE SURROGATE-OFFSET-TABLE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (CLSYS-SVAL MODULE SURROGATE-OFFSET-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-INDEXICAL-OFFSET-TABLE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL MODULE INDEXICAL-OFFSET-TABLE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (CLSYS-SVAL MODULE INDEXICAL-OFFSET-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ELABORATED-WORLD)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL MODULE ELABORATED-WORLD SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (CLSYS-SVAL MODULE ELABORATED-WORLD SELF))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL MODULE DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-MODULE-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL MODULE DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-MODULE-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF MODULE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-MODULE)
  :VOID)

(CL:DEFMETHOD NATIVE-PACKAGE ((SELF MODULE))
  (CL:LET*
   ((CURSOR SELF) (VALUE (CLSYS-SVAL MODULE MODULE-NATIVE-PACKAGE CURSOR)))
   (CL:LOOP
    (CL:WHEN
     (CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM NATIVE-PACKAGE VALUE))
    (CL:SETQ CURSOR (FIRST (CLSYS-SVAL MODULE PARENT-MODULES CURSOR)))
    (CL:IF
     (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE (CLSYS-SVAL MODULE MODULE-NATIVE-PACKAGE CURSOR))
     (CL:RETURN-FROM NATIVE-PACKAGE "STELLA"))))
  :VOID)

(CL:DEFMETHOD NAME ((SELF MODULE))
  (CL:RETURN-FROM NAME (CLSYS-SVAL MODULE MODULE-NAME SELF))
  :VOID)

(CL:DEFMETHOD PARENT-MODULE ((SELF MODULE))
  (CL:RETURN-FROM PARENT-MODULE (POP (PARENT-CONTEXTS SELF)))
  :VOID)

(CL:DEFMETHOD CLOSED-WORLD-ASSUMPTION? ((SELF MODULE))
  (CL:RETURN-FROM
   CLOSED-WORLD-ASSUMPTION?
   (CL:IF (CL:EQ (CLSYS-SVAL MODULE OPEN-WORLD-ASSUMPTION? SELF) 0) TRUE FALSE))
  :VOID)

;;; (DEFCLASS WORLD ...)

(CL:DEFCLASS WORLD (CONTEXT)
  ((PARENT-CONTEXT :ALLOCATION :INSTANCE :ACCESSOR PARENT-CONTEXT...OF)))

(CL:DEFUN NEW-WORLD ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE WORLD)))
   (CL:SETF (CLSYS-SVAL WORLD BITS SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL WORLD DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (CLSYS-SVAL WORLD CONTEXT-NUMBER SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL WORLD BASE-MODULE SELF) NULL)
   (CL:SETF (CLSYS-SVAL WORLD ALL-SUPER-CONTEXTS SELF) NULL)
   (CL:SETF (CLSYS-SVAL WORLD CHILD-CONTEXTS SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL WORLD PARENT-CONTEXT SELF) NULL)
   (CL:RETURN-FROM NEW-WORLD SELF))
  :VOID)

(CL:DEFUN ACCESS-WORLD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-PARENT-CONTEXT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL WORLD PARENT-CONTEXT SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-WORLD-SLOT-VALUE
      (CLSYS-SVAL WORLD PARENT-CONTEXT SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CHILD-CONTEXTS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL WORLD CHILD-CONTEXTS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-WORLD-SLOT-VALUE
      (CLSYS-SVAL WORLD CHILD-CONTEXTS SELF))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL WORLD DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-WORLD-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL WORLD DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-WORLD-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF WORLD))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-WORLD)
  :VOID)

;;; (DEFCLASS CS-VALUE ...)

(CL:DEFCLASS CS-VALUE (KEY-VALUE-LIST)
  ()
  (:DOCUMENTATION
   "Contextualized value.  Contains a sorted kv-cons list indexed
by context. The kv-cons list is never null.  Newer (higher numbered) contexts
appear first."))

(CL:DEFUN NEW-CS-VALUE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CS-VALUE)))
   (CL:SETF (CLSYS-SVAL CS-VALUE THE-KV-LIST SELF) NULL)
   (CL:RETURN-FROM NEW-CS-VALUE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CS-VALUE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-CS-VALUE)
  :VOID)

;;; (DEFCLASS INTERVAL ...)

(CL:DEFCLASS INTERVAL (STANDARD-OBJECT)
  ((LOWER-BOUND :ALLOCATION :INSTANCE :ACCESSOR LOWER-BOUND...OF)
   (UPPER-BOUND :ALLOCATION :INSTANCE :ACCESSOR UPPER-BOUND...OF)))

(CL:DEFUN NEW-INTERVAL ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INTERVAL)))
   (CL:SETF (CLSYS-SVAL INTERVAL UPPER-BOUND SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL INTERVAL LOWER-BOUND SELF) NULL-INTEGER)
   (CL:RETURN-FROM NEW-INTERVAL SELF))
  :VOID)

(CL:DEFUN ACCESS-INTERVAL-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-LOWER-BOUND)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL INTERVAL LOWER-BOUND SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-INTERVAL-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL INTERVAL LOWER-BOUND SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-UPPER-BOUND)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL INTERVAL UPPER-BOUND SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-INTERVAL-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL INTERVAL UPPER-BOUND SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-INTERVAL-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INTERVAL))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-INTERVAL)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF INTERVAL) STREAM)
  (CL:PROGN
   (CL:WRITE-STRING "[" STREAM)
   (CL:PRINC (CLSYS-SVAL INTERVAL LOWER-BOUND SELF) STREAM)
   (CL:WRITE-STRING "," STREAM)
   (CL:PRINC (CLSYS-SVAL INTERVAL UPPER-BOUND SELF) STREAM)
   (CL:WRITE-STRING "]" STREAM))
  :VOID)

;;; (DEFCLASS TAXONOMY-NODE ...)

(CL:DEFCLASS TAXONOMY-NODE (STANDARD-OBJECT)
  ((PARENTS :ALLOCATION :INSTANCE :ACCESSOR PARENTS...OF)
   (TREE-CHILDREN :ALLOCATION :INSTANCE :ACCESSOR TREE-CHILDREN...OF)
   (CHILDREN :ALLOCATION :INSTANCE :ACCESSOR CHILDREN...OF)
   (FIRST-INTERVAL-LOWER-BOUND
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    FIRST-INTERVAL-LOWER-BOUND...OF)
   (FIRST-INTERVAL-UPPER-BOUND
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    FIRST-INTERVAL-UPPER-BOUND...OF)
   (INITIAL-INTERVAL :ALLOCATION :INSTANCE :ACCESSOR INITIAL-INTERVAL...OF)
   (INTERVALS :ALLOCATION :INSTANCE :ACCESSOR INTERVALS...OF)
   (TOTAL-ANCESTORS :ALLOCATION :INSTANCE :ACCESSOR TOTAL-ANCESTORS...OF)
   (LABEL :ALLOCATION :INSTANCE :ACCESSOR LABEL...OF)
   (NATIVE-OBJECT :ALLOCATION :INSTANCE :ACCESSOR NATIVE-OBJECT...OF)))

(CL:DEFUN NEW-TAXONOMY-NODE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TAXONOMY-NODE)))
   (CL:SETF (CLSYS-SVAL TAXONOMY-NODE NATIVE-OBJECT SELF) NULL)
   (CL:SETF (CLSYS-SVAL TAXONOMY-NODE LABEL SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL TAXONOMY-NODE TOTAL-ANCESTORS SELF) 1)
   (CL:SETF (CLSYS-SVAL TAXONOMY-NODE INTERVALS SELF) NIL)
   (CL:SETF (CLSYS-SVAL TAXONOMY-NODE INITIAL-INTERVAL SELF) NULL)
   (CL:SETF (CLSYS-SVAL TAXONOMY-NODE FIRST-INTERVAL-UPPER-BOUND SELF) -1)
   (CL:SETF (CLSYS-SVAL TAXONOMY-NODE FIRST-INTERVAL-LOWER-BOUND SELF) -1)
   (CL:SETF (CLSYS-SVAL TAXONOMY-NODE CHILDREN SELF) NIL)
   (CL:SETF (CLSYS-SVAL TAXONOMY-NODE TREE-CHILDREN SELF) NIL)
   (CL:SETF (CLSYS-SVAL TAXONOMY-NODE PARENTS SELF) NIL)
   (CL:RETURN-FROM NEW-TAXONOMY-NODE SELF))
  :VOID)

(CL:DEFUN ACCESS-TAXONOMY-NODE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-PARENTS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TAXONOMY-NODE PARENTS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-NODE-SLOT-VALUE
      (CLSYS-SVAL TAXONOMY-NODE PARENTS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-TREE-CHILDREN)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TAXONOMY-NODE TREE-CHILDREN SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-NODE-SLOT-VALUE
      (CLSYS-SVAL TAXONOMY-NODE TREE-CHILDREN SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-CHILDREN)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TAXONOMY-NODE CHILDREN SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-NODE-SLOT-VALUE
      (CLSYS-SVAL TAXONOMY-NODE CHILDREN SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-FIRST-INTERVAL-LOWER-BOUND)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TAXONOMY-NODE FIRST-INTERVAL-LOWER-BOUND SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-NODE-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL TAXONOMY-NODE FIRST-INTERVAL-LOWER-BOUND SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-FIRST-INTERVAL-UPPER-BOUND)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TAXONOMY-NODE FIRST-INTERVAL-UPPER-BOUND SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-NODE-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL TAXONOMY-NODE FIRST-INTERVAL-UPPER-BOUND SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-INITIAL-INTERVAL)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TAXONOMY-NODE INITIAL-INTERVAL SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-NODE-SLOT-VALUE
      (CLSYS-SVAL TAXONOMY-NODE INITIAL-INTERVAL SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-INTERVALS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TAXONOMY-NODE INTERVALS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-NODE-SLOT-VALUE
      (CLSYS-SVAL TAXONOMY-NODE INTERVALS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-TOTAL-ANCESTORS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TAXONOMY-NODE TOTAL-ANCESTORS SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-NODE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL TAXONOMY-NODE TOTAL-ANCESTORS SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-LABEL)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TAXONOMY-NODE LABEL SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-NODE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL TAXONOMY-NODE LABEL SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-NATIVE-OBJECT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TAXONOMY-NODE NATIVE-OBJECT SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-NODE-SLOT-VALUE
      (CLSYS-SVAL TAXONOMY-NODE NATIVE-OBJECT SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-TAXONOMY-NODE-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TAXONOMY-NODE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-TAXONOMY-NODE)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF TAXONOMY-NODE) STREAM)
  (CL:PROGN
   (CL:WRITE-STRING "|TN|" STREAM)
   (CL:PRINC (CLSYS-SVAL TAXONOMY-NODE LABEL SELF) STREAM)
   (CL:WRITE-STRING " " STREAM)
   (PRINT-OBJECT (CLSYS-SVAL TAXONOMY-NODE INTERVALS SELF) STREAM)
   (CL:WRITE-STRING " " STREAM)
   (PRINT-OBJECT (CLSYS-SVAL TAXONOMY-NODE NATIVE-OBJECT SELF) STREAM))
  :VOID)

;;; (DEFCLASS TAXONOMY-GRAPH ...)

(CL:DEFCLASS TAXONOMY-GRAPH (STANDARD-OBJECT)
  ((INCREMENTAL-MODE? :ALLOCATION :INSTANCE :ACCESSOR INCREMENTAL-MODE?...OF)
   (RENUMBER-IF-OUT-OF-NUMBERS?
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    RENUMBER-IF-OUT-OF-NUMBERS?...OF)
   (LARGEST-POSTORDER-NUMBER
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    LARGEST-POSTORDER-NUMBER...OF)
   (ROOTS :ALLOCATION :INSTANCE :ACCESSOR ROOTS...OF)
   (BROKEN-LINKS :ALLOCATION :INSTANCE :ACCESSOR BROKEN-LINKS...OF)))

(CL:DEFUN NEW-TAXONOMY-GRAPH ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TAXONOMY-GRAPH)))
   (CL:SETF (CLSYS-SVAL TAXONOMY-GRAPH BROKEN-LINKS SELF) NIL)
   (CL:SETF (CLSYS-SVAL TAXONOMY-GRAPH ROOTS SELF) NIL)
   (CL:SETF
    (CLSYS-SVAL TAXONOMY-GRAPH LARGEST-POSTORDER-NUMBER SELF)
    NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL TAXONOMY-GRAPH RENUMBER-IF-OUT-OF-NUMBERS? SELF)
    FALSE)
   (CL:SETF (CLSYS-SVAL TAXONOMY-GRAPH INCREMENTAL-MODE? SELF) FALSE)
   (CL:RETURN-FROM NEW-TAXONOMY-GRAPH SELF))
  :VOID)

(CL:DEFUN ACCESS-TAXONOMY-GRAPH-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-INCREMENTAL-MODE?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TAXONOMY-GRAPH INCREMENTAL-MODE? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-GRAPH-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL TAXONOMY-GRAPH INCREMENTAL-MODE? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-RENUMBER-IF-OUT-OF-NUMBERS?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TAXONOMY-GRAPH RENUMBER-IF-OUT-OF-NUMBERS? SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-GRAPH-SLOT-VALUE
      (WRAP-BOOLEAN
       (CLSYS-SVAL TAXONOMY-GRAPH RENUMBER-IF-OUT-OF-NUMBERS? SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-LARGEST-POSTORDER-NUMBER)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TAXONOMY-GRAPH LARGEST-POSTORDER-NUMBER SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-GRAPH-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL TAXONOMY-GRAPH LARGEST-POSTORDER-NUMBER SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-ROOTS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TAXONOMY-GRAPH ROOTS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-GRAPH-SLOT-VALUE
      (CLSYS-SVAL TAXONOMY-GRAPH ROOTS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-BROKEN-LINKS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL TAXONOMY-GRAPH BROKEN-LINKS SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-TAXONOMY-GRAPH-SLOT-VALUE
      (CLSYS-SVAL TAXONOMY-GRAPH BROKEN-LINKS SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-TAXONOMY-GRAPH-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TAXONOMY-GRAPH))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-TAXONOMY-GRAPH)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF TAXONOMY-GRAPH) STREAM)
  (CL:PROGN
   (CL:WRITE-STRING "|TG|" STREAM)
   (PRINT-OBJECT (CLSYS-SVAL TAXONOMY-GRAPH ROOTS SELF) STREAM))
  :VOID)

;;; (DEFCLASS EXCEPTION ...)

(CL:DEFCLASS EXCEPTION (STANDARD-OBJECT)
  ())

(CL:DEFUN NEW-EXCEPTION ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE EXCEPTION)))
   (CL:RETURN-FROM NEW-EXCEPTION SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF EXCEPTION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-EXCEPTION)
  :VOID)

;;; (DEFCLASS STELLA-EXCEPTION ...)

(CL:DEFCLASS STELLA-EXCEPTION (EXCEPTION)
  ())

(CL:DEFUN NEW-STELLA-EXCEPTION ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STELLA-EXCEPTION)))
   (CL:RETURN-FROM NEW-STELLA-EXCEPTION SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STELLA-EXCEPTION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-EXCEPTION)
  :VOID)

;;; (DEFCLASS READ-EXCEPTION ...)

(CL:DEFCLASS READ-EXCEPTION (STELLA-EXCEPTION)
  ())

(CL:DEFUN NEW-READ-EXCEPTION ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE READ-EXCEPTION)))
   (CL:RETURN-FROM NEW-READ-EXCEPTION SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF READ-EXCEPTION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-READ-EXCEPTION)
  :VOID)

;;; (DEFCLASS UNHANDLED-EXCEPTION ...)

(CL:DEFCLASS UNHANDLED-EXCEPTION (EXCEPTION)
  ())

(CL:DEFUN NEW-UNHANDLED-EXCEPTION ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE UNHANDLED-EXCEPTION)))
   (CL:RETURN-FROM NEW-UNHANDLED-EXCEPTION SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF UNHANDLED-EXCEPTION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-UNHANDLED-EXCEPTION)
  :VOID)

;;; (DEFCLASS WRAPPER ...)

(CL:DEFCLASS WRAPPER (OBJECT)
  ())

;;; (DEFCLASS LITERAL-WRAPPER ...)

(CL:DEFCLASS LITERAL-WRAPPER (WRAPPER)
  ())

;;; (DEFCLASS NUMBER-WRAPPER ...)

(CL:DEFCLASS NUMBER-WRAPPER (LITERAL-WRAPPER)
  ())

;;; (DEFCLASS INTEGER-WRAPPER ...)

(CL:DEFCLASS INTEGER-WRAPPER (NUMBER-WRAPPER)
  ((WRAPPER-VALUE :ALLOCATION :INSTANCE :ACCESSOR WRAPPER-VALUE...OF)))

(CL:DEFUN NEW-INTEGER-WRAPPER (WRAPPER-VALUE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (POP *RECYCLED-INTEGER-WRAPPER-S*))
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL)))
    (CL:T (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INTEGER-WRAPPER)))))
   (CL:SETF (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-INTEGER-WRAPPER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF INTEGER-WRAPPER))
  (CL:WHEN (CL:EQ (TERMINATE-WRAPPER? SELF) 0) (CL:RETURN-FROM FREE))
  (PUSH *RECYCLED-INTEGER-WRAPPER-S* SELF)
  :VOID)

(CL:DEFUN ACCESS-INTEGER-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-WRAPPER-VALUE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE SELF)
      (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-INTEGER-WRAPPER-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-INTEGER-WRAPPER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INTEGER-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-INTEGER-WRAPPER)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF INTEGER-WRAPPER) STREAM)
  (CL:IF
   (CL:EQ *PRINTREADABLY?* 1)
   (CL:PRINC (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE SELF) STREAM)
   (CL:PROGN
    (CL:WRITE-STRING
     (CL:IF (CL:EQ (TRANSIENT-OBJECT? SELF) 1) "!L!" "|L|")
     STREAM)
    (CL:PRINC (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE SELF) STREAM)))
  :VOID)

;;; (DEFCLASS FLOAT-WRAPPER ...)

(CL:DEFCLASS FLOAT-WRAPPER (NUMBER-WRAPPER)
  ((WRAPPER-VALUE :ALLOCATION :INSTANCE :ACCESSOR WRAPPER-VALUE...OF)))

(CL:DEFUN NEW-FLOAT-WRAPPER (WRAPPER-VALUE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (POP *RECYCLED-FLOAT-WRAPPER-S*))
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL)))
    (CL:T (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE FLOAT-WRAPPER)))))
   (CL:SETF (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-FLOAT-WRAPPER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF FLOAT-WRAPPER))
  (CL:WHEN (CL:EQ (TERMINATE-WRAPPER? SELF) 0) (CL:RETURN-FROM FREE))
  (PUSH *RECYCLED-FLOAT-WRAPPER-S* SELF)
  :VOID)

(CL:DEFUN ACCESS-FLOAT-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-WRAPPER-VALUE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE SELF)
      (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-FLOAT-WRAPPER-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-FLOAT-WRAPPER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FLOAT-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-FLOAT-WRAPPER)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF FLOAT-WRAPPER) STREAM)
  (CL:IF
   (CL:EQ *PRINTREADABLY?* 1)
   (CL:PRINC (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE SELF) STREAM)
   (CL:PROGN
    (CL:WRITE-STRING
     (CL:IF (CL:EQ (TRANSIENT-OBJECT? SELF) 1) "!L!" "|L|")
     STREAM)
    (CL:PRINC (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE SELF) STREAM)))
  :VOID)

;;; (DEFCLASS STRING-WRAPPER ...)

(CL:DEFCLASS STRING-WRAPPER (LITERAL-WRAPPER)
  ((WRAPPER-VALUE :ALLOCATION :INSTANCE :ACCESSOR WRAPPER-VALUE...OF)))

(CL:DEFUN NEW-STRING-WRAPPER (WRAPPER-VALUE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (POP *RECYCLED-STRING-WRAPPER-S*))
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL)))
    (CL:T (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STRING-WRAPPER)))))
   (CL:SETF (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-STRING-WRAPPER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF STRING-WRAPPER))
  (CL:WHEN (CL:EQ (TERMINATE-WRAPPER? SELF) 0) (CL:RETURN-FROM FREE))
  (PUSH *RECYCLED-STRING-WRAPPER-S* SELF)
  :VOID)

(CL:DEFUN ACCESS-STRING-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-WRAPPER-VALUE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-STRING-WRAPPER-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-STRING-WRAPPER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STRING-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STRING-WRAPPER)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF STRING-WRAPPER) STREAM)
  (CL:LET*
   ((VALUE (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE SELF)))
   (CL:IF
    (CL:EQ *PRINTREADABLY?* 1)
    (PRINT-STRING-READABLY VALUE STREAM)
    (CL:IF
     (CL:NOT (CL:EQ VALUE NULL))
     (CL:PROGN
      (CL:WRITE-STRING
       (CL:IF (CL:EQ (TRANSIENT-OBJECT? SELF) 1) "!L!" "|L|")
       STREAM)
      (CL:WRITE-STRING "\"" STREAM)
      (CL:WRITE-STRING VALUE STREAM)
      (CL:WRITE-STRING "\"" STREAM))
     (CL:PROGN
      (CL:WRITE-STRING
       (CL:IF (CL:EQ (TRANSIENT-OBJECT? SELF) 1) "!L!" "|L|")
       STREAM)
      (CL:WRITE-STRING "NULL-STRING" STREAM)))))
  :VOID)

;;; (DEFCLASS CHARACTER-WRAPPER ...)

(CL:DEFCLASS CHARACTER-WRAPPER (LITERAL-WRAPPER)
  ((WRAPPER-VALUE :ALLOCATION :INSTANCE :ACCESSOR WRAPPER-VALUE...OF)))

(CL:DEFUN NEW-CHARACTER-WRAPPER (WRAPPER-VALUE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (POP *RECYCLED-CHARACTER-WRAPPER-S*))
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL)))
    (CL:T (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CHARACTER-WRAPPER)))))
   (CL:SETF (CLSYS-SVAL CHARACTER-WRAPPER WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-CHARACTER-WRAPPER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF CHARACTER-WRAPPER))
  (CL:WHEN (CL:EQ (TERMINATE-WRAPPER? SELF) 0) (CL:RETURN-FROM FREE))
  (PUSH *RECYCLED-CHARACTER-WRAPPER-S* SELF)
  :VOID)

(CL:DEFUN ACCESS-CHARACTER-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-WRAPPER-VALUE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CHARACTER-WRAPPER WRAPPER-VALUE SELF)
      (CLSYS-SVAL CHARACTER-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-CHARACTER-WRAPPER-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL CHARACTER-WRAPPER WRAPPER-VALUE SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-CHARACTER-WRAPPER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CHARACTER-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-CHARACTER-WRAPPER)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF CHARACTER-WRAPPER) STREAM)
  (CL:IF
   (CL:EQ *PRINTREADABLY?* 1)
   (PRINT-CHARACTER (CLSYS-SVAL CHARACTER-WRAPPER WRAPPER-VALUE SELF) STREAM)
   (CL:PROGN
    (CL:WRITE-STRING
     (CL:IF (CL:EQ (TRANSIENT-OBJECT? SELF) 1) "!L!" "|L|")
     STREAM)
    (PRINT-CHARACTER (CLSYS-SVAL CHARACTER-WRAPPER WRAPPER-VALUE SELF) STREAM)))
  :VOID)

;;; (DEFCLASS BOOLEAN-WRAPPER ...)

(CL:DEFCLASS BOOLEAN-WRAPPER (LITERAL-WRAPPER)
  ((WRAPPER-VALUE :ALLOCATION :INSTANCE :ACCESSOR WRAPPER-VALUE...OF)))

(CL:DEFUN NEW-BOOLEAN-WRAPPER (WRAPPER-VALUE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE BOOLEAN-WRAPPER)))
   (CL:SETF (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-BOOLEAN-WRAPPER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF BOOLEAN-WRAPPER))
  (CL:WHEN (CL:EQ (TERMINATE-WRAPPER? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFUN ACCESS-BOOLEAN-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-WRAPPER-VALUE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE SELF)
      (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-BOOLEAN-WRAPPER-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-BOOLEAN-WRAPPER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF BOOLEAN-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-BOOLEAN-WRAPPER)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF BOOLEAN-WRAPPER) STREAM)
  (CL:PROGN
   (CL:WRITE-STRING (CL:IF (CL:EQ *PRINTREADABLY?* 1) "" "|L|") STREAM)
   (PRINT-OBJECT
    (CL:IF
     (CL:EQ (NULL? (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE SELF)) 1)
     SYM-HIERARCHY-NULL-BOOLEAN
     (CL:IF
      (CL:EQ (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE SELF) 1)
      SYM-HIERARCHY-TRUE
      SYM-HIERARCHY-FALSE))
    STREAM))
  :VOID)

;;; (DEFCLASS CODE-WRAPPER ...)

(CL:DEFCLASS CODE-WRAPPER (WRAPPER)
  ())

;;; (DEFCLASS FUNCTION-CODE-WRAPPER ...)

(CL:DEFCLASS FUNCTION-CODE-WRAPPER (CODE-WRAPPER)
  ((WRAPPER-VALUE :ALLOCATION :INSTANCE :ACCESSOR WRAPPER-VALUE...OF)))

(CL:DEFUN NEW-FUNCTION-CODE-WRAPPER (WRAPPER-VALUE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (POP *RECYCLED-FUNCTION-CODE-WRAPPER-S*))
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL)))
    (CL:T (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE FUNCTION-CODE-WRAPPER)))))
   (CL:SETF
    (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE SELF)
    WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-FUNCTION-CODE-WRAPPER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF FUNCTION-CODE-WRAPPER))
  (CL:WHEN (CL:EQ (TERMINATE-WRAPPER? SELF) 0) (CL:RETURN-FROM FREE))
  (PUSH *RECYCLED-FUNCTION-CODE-WRAPPER-S* SELF)
  :VOID)

(CL:DEFUN ACCESS-FUNCTION-CODE-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-WRAPPER-VALUE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE SELF)
      (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-FUNCTION-CODE-WRAPPER-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL FUNCTION-CODE-WRAPPER WRAPPER-VALUE SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-FUNCTION-CODE-WRAPPER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FUNCTION-CODE-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-FUNCTION-CODE-WRAPPER)
  :VOID)

;;; (DEFCLASS METHOD-CODE-WRAPPER ...)

(CL:DEFCLASS METHOD-CODE-WRAPPER (CODE-WRAPPER)
  ((WRAPPER-VALUE :ALLOCATION :INSTANCE :ACCESSOR WRAPPER-VALUE...OF)))

(CL:DEFUN NEW-METHOD-CODE-WRAPPER (WRAPPER-VALUE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (POP *RECYCLED-METHOD-CODE-WRAPPER-S*))
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL)))
    (CL:T (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE METHOD-CODE-WRAPPER)))))
   (CL:SETF (CLSYS-SVAL METHOD-CODE-WRAPPER WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-METHOD-CODE-WRAPPER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF METHOD-CODE-WRAPPER))
  (CL:WHEN (CL:EQ (TERMINATE-WRAPPER? SELF) 0) (CL:RETURN-FROM FREE))
  (PUSH *RECYCLED-METHOD-CODE-WRAPPER-S* SELF)
  :VOID)

(CL:DEFUN ACCESS-METHOD-CODE-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-WRAPPER-VALUE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL METHOD-CODE-WRAPPER WRAPPER-VALUE SELF)
      (CLSYS-SVAL METHOD-CODE-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-METHOD-CODE-WRAPPER-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL METHOD-CODE-WRAPPER WRAPPER-VALUE SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-METHOD-CODE-WRAPPER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF METHOD-CODE-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-METHOD-CODE-WRAPPER)
  :VOID)

;;; (DEFCLASS TRANSIENT-INTEGER-WRAPPER ...)

(CL:DEFCLASS TRANSIENT-INTEGER-WRAPPER (INTEGER-WRAPPER TRANSIENT-MIXIN)
  ((NEXT-SWEEP-LIST-OBJECT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    NEXT-SWEEP-LIST-OBJECT...OF)))

(CL:DEFUN NEW-TRANSIENT-INTEGER-WRAPPER (WRAPPER-VALUE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF *UNUSED-TRANSIENT-INTEGER-WRAPPER-S*)
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL))
     (CL:SETQ
      *UNUSED-TRANSIENT-INTEGER-WRAPPER-S*
      (CLSYS-SVAL
       TRANSIENT-INTEGER-WRAPPER
       NEXT-SWEEP-LIST-OBJECT
       *UNUSED-TRANSIENT-INTEGER-WRAPPER-S*))
     (TERMINATE-WRAPPER? SELF))
    (CL:T
     (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRANSIENT-INTEGER-WRAPPER)))
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-INTEGER-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF)
      *ALL-TRANSIENT-INTEGER-WRAPPER-S*)
     (CL:SETQ *ALL-TRANSIENT-INTEGER-WRAPPER-S* SELF)))
   (CL:SETF
    (CLSYS-SVAL TRANSIENT-INTEGER-WRAPPER WRAPPER-VALUE SELF)
    WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-TRANSIENT-INTEGER-WRAPPER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF TRANSIENT-INTEGER-WRAPPER))
  NULL
  :VOID)

(CL:DEFMETHOD SWEEP ((SELF TRANSIENT-INTEGER-WRAPPER))
  (CL:SETQ
   *UNUSED-TRANSIENT-INTEGER-WRAPPER-S*
   *ALL-TRANSIENT-INTEGER-WRAPPER-S*)
  :VOID)

(CL:DEFUN ACCESS-TRANSIENT-INTEGER-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-NEXT-SWEEP-LIST-OBJECT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-INTEGER-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-TRANSIENT-INTEGER-WRAPPER-SLOT-VALUE
      (CLSYS-SVAL TRANSIENT-INTEGER-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-TRANSIENT-INTEGER-WRAPPER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSIENT-INTEGER-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-TRANSIENT-INTEGER-WRAPPER)
  :VOID)

;;; (DEFCLASS TRANSIENT-FLOAT-WRAPPER ...)

(CL:DEFCLASS TRANSIENT-FLOAT-WRAPPER (FLOAT-WRAPPER TRANSIENT-MIXIN)
  ((NEXT-SWEEP-LIST-OBJECT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    NEXT-SWEEP-LIST-OBJECT...OF)))

(CL:DEFUN NEW-TRANSIENT-FLOAT-WRAPPER (WRAPPER-VALUE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF *UNUSED-TRANSIENT-FLOAT-WRAPPER-S*)
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL))
     (CL:SETQ
      *UNUSED-TRANSIENT-FLOAT-WRAPPER-S*
      (CLSYS-SVAL
       TRANSIENT-FLOAT-WRAPPER
       NEXT-SWEEP-LIST-OBJECT
       *UNUSED-TRANSIENT-FLOAT-WRAPPER-S*))
     (TERMINATE-WRAPPER? SELF))
    (CL:T
     (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRANSIENT-FLOAT-WRAPPER)))
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-FLOAT-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF)
      *ALL-TRANSIENT-FLOAT-WRAPPER-S*)
     (CL:SETQ *ALL-TRANSIENT-FLOAT-WRAPPER-S* SELF)))
   (CL:SETF
    (CLSYS-SVAL TRANSIENT-FLOAT-WRAPPER WRAPPER-VALUE SELF)
    WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-TRANSIENT-FLOAT-WRAPPER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF TRANSIENT-FLOAT-WRAPPER))
  NULL
  :VOID)

(CL:DEFMETHOD SWEEP ((SELF TRANSIENT-FLOAT-WRAPPER))
  (CL:SETQ *UNUSED-TRANSIENT-FLOAT-WRAPPER-S* *ALL-TRANSIENT-FLOAT-WRAPPER-S*)
  :VOID)

(CL:DEFUN ACCESS-TRANSIENT-FLOAT-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-NEXT-SWEEP-LIST-OBJECT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-FLOAT-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-TRANSIENT-FLOAT-WRAPPER-SLOT-VALUE
      (CLSYS-SVAL TRANSIENT-FLOAT-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-TRANSIENT-FLOAT-WRAPPER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSIENT-FLOAT-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-TRANSIENT-FLOAT-WRAPPER)
  :VOID)

;;; (DEFCLASS TRANSIENT-STRING-WRAPPER ...)

(CL:DEFCLASS TRANSIENT-STRING-WRAPPER (STRING-WRAPPER TRANSIENT-MIXIN)
  ((NEXT-SWEEP-LIST-OBJECT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    NEXT-SWEEP-LIST-OBJECT...OF)))

(CL:DEFUN NEW-TRANSIENT-STRING-WRAPPER (WRAPPER-VALUE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (POP *RECYCLED-TRANSIENT-STRING-WRAPPER-S*))
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL)))
    ((CL:NOT (CL:EQ *UNUSED-TRANSIENT-STRING-WRAPPER-S* NULL))
     (CL:SETQ SELF *UNUSED-TRANSIENT-STRING-WRAPPER-S*)
     (CL:SETQ
      *UNUSED-TRANSIENT-STRING-WRAPPER-S*
      (CLSYS-SVAL
       TRANSIENT-STRING-WRAPPER
       NEXT-SWEEP-LIST-OBJECT
       *UNUSED-TRANSIENT-STRING-WRAPPER-S*))
     (TERMINATE-WRAPPER? SELF))
    (CL:T
     (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRANSIENT-STRING-WRAPPER)))
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-STRING-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF)
      *ALL-TRANSIENT-STRING-WRAPPER-S*)
     (CL:SETQ *ALL-TRANSIENT-STRING-WRAPPER-S* SELF)))
   (CL:SETF
    (CLSYS-SVAL TRANSIENT-STRING-WRAPPER WRAPPER-VALUE SELF)
    WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-TRANSIENT-STRING-WRAPPER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF TRANSIENT-STRING-WRAPPER))
  (TERMINATE-WRAPPER? SELF)
  (PUSH *RECYCLED-TRANSIENT-STRING-WRAPPER-S* SELF)
  :VOID)

(CL:DEFMETHOD SWEEP ((SELF TRANSIENT-STRING-WRAPPER))
  (CLEAR *RECYCLED-TRANSIENT-STRING-WRAPPER-S*)
  (CL:SETQ *UNUSED-TRANSIENT-STRING-WRAPPER-S* *ALL-TRANSIENT-STRING-WRAPPER-S*)
  :VOID)

(CL:DEFUN ACCESS-TRANSIENT-STRING-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-NEXT-SWEEP-LIST-OBJECT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-STRING-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-TRANSIENT-STRING-WRAPPER-SLOT-VALUE
      (CLSYS-SVAL TRANSIENT-STRING-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-TRANSIENT-STRING-WRAPPER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSIENT-STRING-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-TRANSIENT-STRING-WRAPPER)
  :VOID)

;;; (DEFCLASS TRANSIENT-CHARACTER-WRAPPER ...)

(CL:DEFCLASS TRANSIENT-CHARACTER-WRAPPER (CHARACTER-WRAPPER TRANSIENT-MIXIN)
  ((NEXT-SWEEP-LIST-OBJECT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    NEXT-SWEEP-LIST-OBJECT...OF)))

(CL:DEFUN NEW-TRANSIENT-CHARACTER-WRAPPER (WRAPPER-VALUE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF *UNUSED-TRANSIENT-CHARACTER-WRAPPER-S*)
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL))
     (CL:SETQ
      *UNUSED-TRANSIENT-CHARACTER-WRAPPER-S*
      (CLSYS-SVAL
       TRANSIENT-CHARACTER-WRAPPER
       NEXT-SWEEP-LIST-OBJECT
       *UNUSED-TRANSIENT-CHARACTER-WRAPPER-S*))
     (TERMINATE-WRAPPER? SELF))
    (CL:T
     (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRANSIENT-CHARACTER-WRAPPER)))
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-CHARACTER-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF)
      *ALL-TRANSIENT-CHARACTER-WRAPPER-S*)
     (CL:SETQ *ALL-TRANSIENT-CHARACTER-WRAPPER-S* SELF)))
   (CL:SETF
    (CLSYS-SVAL TRANSIENT-CHARACTER-WRAPPER WRAPPER-VALUE SELF)
    WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-TRANSIENT-CHARACTER-WRAPPER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF TRANSIENT-CHARACTER-WRAPPER))
  NULL
  :VOID)

(CL:DEFMETHOD SWEEP ((SELF TRANSIENT-CHARACTER-WRAPPER))
  (CL:SETQ
   *UNUSED-TRANSIENT-CHARACTER-WRAPPER-S*
   *ALL-TRANSIENT-CHARACTER-WRAPPER-S*)
  :VOID)

(CL:DEFUN ACCESS-TRANSIENT-CHARACTER-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-NEXT-SWEEP-LIST-OBJECT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-CHARACTER-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-TRANSIENT-CHARACTER-WRAPPER-SLOT-VALUE
      (CLSYS-SVAL TRANSIENT-CHARACTER-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-TRANSIENT-CHARACTER-WRAPPER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSIENT-CHARACTER-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-TRANSIENT-CHARACTER-WRAPPER)
  :VOID)

;;; (DEFCLASS TRANSIENT-FUNCTION-CODE-WRAPPER ...)

(CL:DEFCLASS TRANSIENT-FUNCTION-CODE-WRAPPER (FUNCTION-CODE-WRAPPER TRANSIENT-MIXIN)
  ((NEXT-SWEEP-LIST-OBJECT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    NEXT-SWEEP-LIST-OBJECT...OF)))

(CL:DEFUN NEW-TRANSIENT-FUNCTION-CODE-WRAPPER (WRAPPER-VALUE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF *UNUSED-TRANSIENT-FUNCTION-CODE-WRAPPER-S*)
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL))
     (CL:SETQ
      *UNUSED-TRANSIENT-FUNCTION-CODE-WRAPPER-S*
      (CLSYS-SVAL
       TRANSIENT-FUNCTION-CODE-WRAPPER
       NEXT-SWEEP-LIST-OBJECT
       *UNUSED-TRANSIENT-FUNCTION-CODE-WRAPPER-S*))
     (TERMINATE-WRAPPER? SELF))
    (CL:T
     (CL:SETQ
      SELF
      (CL:MAKE-INSTANCE (CL:QUOTE TRANSIENT-FUNCTION-CODE-WRAPPER)))
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-FUNCTION-CODE-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF)
      *ALL-TRANSIENT-FUNCTION-CODE-WRAPPER-S*)
     (CL:SETQ *ALL-TRANSIENT-FUNCTION-CODE-WRAPPER-S* SELF)))
   (CL:SETF
    (CLSYS-SVAL TRANSIENT-FUNCTION-CODE-WRAPPER WRAPPER-VALUE SELF)
    WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-TRANSIENT-FUNCTION-CODE-WRAPPER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF TRANSIENT-FUNCTION-CODE-WRAPPER))
  NULL
  :VOID)

(CL:DEFMETHOD SWEEP ((SELF TRANSIENT-FUNCTION-CODE-WRAPPER))
  (CL:SETQ
   *UNUSED-TRANSIENT-FUNCTION-CODE-WRAPPER-S*
   *ALL-TRANSIENT-FUNCTION-CODE-WRAPPER-S*)
  :VOID)

(CL:DEFUN ACCESS-TRANSIENT-FUNCTION-CODE-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-NEXT-SWEEP-LIST-OBJECT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-FUNCTION-CODE-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-TRANSIENT-FUNCTION-CODE-WRAPPER-SLOT-VALUE
      (CLSYS-SVAL
       TRANSIENT-FUNCTION-CODE-WRAPPER
       NEXT-SWEEP-LIST-OBJECT
       SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-TRANSIENT-FUNCTION-CODE-WRAPPER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSIENT-FUNCTION-CODE-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-TRANSIENT-FUNCTION-CODE-WRAPPER)
  :VOID)

;;; (DEFCLASS TRANSIENT-METHOD-CODE-WRAPPER ...)

(CL:DEFCLASS TRANSIENT-METHOD-CODE-WRAPPER (METHOD-CODE-WRAPPER TRANSIENT-MIXIN)
  ((NEXT-SWEEP-LIST-OBJECT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    NEXT-SWEEP-LIST-OBJECT...OF)))

(CL:DEFUN NEW-TRANSIENT-METHOD-CODE-WRAPPER (WRAPPER-VALUE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF *UNUSED-TRANSIENT-METHOD-CODE-WRAPPER-S*)
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL))
     (CL:SETQ
      *UNUSED-TRANSIENT-METHOD-CODE-WRAPPER-S*
      (CLSYS-SVAL
       TRANSIENT-METHOD-CODE-WRAPPER
       NEXT-SWEEP-LIST-OBJECT
       *UNUSED-TRANSIENT-METHOD-CODE-WRAPPER-S*))
     (TERMINATE-WRAPPER? SELF))
    (CL:T
     (CL:SETQ
      SELF
      (CL:MAKE-INSTANCE (CL:QUOTE TRANSIENT-METHOD-CODE-WRAPPER)))
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-METHOD-CODE-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF)
      *ALL-TRANSIENT-METHOD-CODE-WRAPPER-S*)
     (CL:SETQ *ALL-TRANSIENT-METHOD-CODE-WRAPPER-S* SELF)))
   (CL:SETF
    (CLSYS-SVAL TRANSIENT-METHOD-CODE-WRAPPER WRAPPER-VALUE SELF)
    WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-TRANSIENT-METHOD-CODE-WRAPPER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF TRANSIENT-METHOD-CODE-WRAPPER))
  NULL
  :VOID)

(CL:DEFMETHOD SWEEP ((SELF TRANSIENT-METHOD-CODE-WRAPPER))
  (CL:SETQ
   *UNUSED-TRANSIENT-METHOD-CODE-WRAPPER-S*
   *ALL-TRANSIENT-METHOD-CODE-WRAPPER-S*)
  :VOID)

(CL:DEFUN ACCESS-TRANSIENT-METHOD-CODE-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-NEXT-SWEEP-LIST-OBJECT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRANSIENT-METHOD-CODE-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-TRANSIENT-METHOD-CODE-WRAPPER-SLOT-VALUE
      (CLSYS-SVAL
       TRANSIENT-METHOD-CODE-WRAPPER
       NEXT-SWEEP-LIST-OBJECT
       SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-TRANSIENT-METHOD-CODE-WRAPPER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSIENT-METHOD-CODE-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-TRANSIENT-METHOD-CODE-WRAPPER)
  :VOID)

;;; (DEFCLASS VERBATIM-STRING-WRAPPER ...)

(CL:DEFCLASS VERBATIM-STRING-WRAPPER (TRANSIENT-STRING-WRAPPER)
  ()
  (:DOCUMENTATION "Wrapper class used to hold verbatim native code strings."))

(CL:DEFUN NEW-VERBATIM-STRING-WRAPPER (WRAPPER-VALUE)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF *UNUSED-VERBATIM-STRING-WRAPPER-S*)
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL))
     (CL:SETQ
      *UNUSED-VERBATIM-STRING-WRAPPER-S*
      (CLSYS-SVAL
       VERBATIM-STRING-WRAPPER
       NEXT-SWEEP-LIST-OBJECT
       *UNUSED-VERBATIM-STRING-WRAPPER-S*))
     (TERMINATE-WRAPPER? SELF))
    (CL:T
     (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE VERBATIM-STRING-WRAPPER)))
     (CL:SETF
      (CLSYS-SVAL VERBATIM-STRING-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF)
      *ALL-VERBATIM-STRING-WRAPPER-S*)
     (CL:SETQ *ALL-VERBATIM-STRING-WRAPPER-S* SELF)))
   (CL:SETF
    (CLSYS-SVAL VERBATIM-STRING-WRAPPER WRAPPER-VALUE SELF)
    WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-VERBATIM-STRING-WRAPPER SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF VERBATIM-STRING-WRAPPER))
  NULL
  :VOID)

(CL:DEFMETHOD SWEEP ((SELF VERBATIM-STRING-WRAPPER))
  (CL:SETQ *UNUSED-VERBATIM-STRING-WRAPPER-S* *ALL-VERBATIM-STRING-WRAPPER-S*)
  :VOID)

(CL:DEFUN ACCESS-VERBATIM-STRING-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-NEXT-SWEEP-LIST-OBJECT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL VERBATIM-STRING-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF)
      VALUE)
     (CL:RETURN-FROM
      ACCESS-VERBATIM-STRING-WRAPPER-SLOT-VALUE
      (CLSYS-SVAL VERBATIM-STRING-WRAPPER NEXT-SWEEP-LIST-OBJECT SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-VERBATIM-STRING-WRAPPER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF VERBATIM-STRING-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-VERBATIM-STRING-WRAPPER)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF VERBATIM-STRING-WRAPPER) STREAM)
  (CL:PROGN
   (CL:WRITE-STRING (CL:IF (CL:EQ *PRINTREADABLY?* 1) "" "!V!") STREAM)
   (CL:WRITE-STRING
    (CLSYS-SVAL VERBATIM-STRING-WRAPPER WRAPPER-VALUE SELF)
    STREAM))
  :VOID)

;;; (DEFCLASS LISP-CODE ...)

(CL:DEFCLASS LISP-CODE ()
  ()
  (:DOCUMENTATION
   "Used to indicate variables that input or output Common Lisp~
      structures."))

;;; (DEFCLASS LISP-CONS-ITERATOR ...)

(CL:DEFCLASS LISP-CONS-ITERATOR (ITERATOR)
  ((CONS-ITERATOR-CURSOR
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CONS-ITERATOR-CURSOR...OF)))

(CL:DEFUN NEW-LISP-CONS-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE LISP-CONS-ITERATOR)))
   (CL:SETF (CLSYS-SVAL LISP-CONS-ITERATOR FIRST-ITERATION? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL LISP-CONS-ITERATOR VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL LISP-CONS-ITERATOR CONS-ITERATOR-CURSOR SELF) NULL)
   (CL:RETURN-FROM NEW-LISP-CONS-ITERATOR SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LISP-CONS-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-LISP-CONS-ITERATOR)
  :VOID)

;;; (DEFCLASS STREAM ...)

(CL:DEFCLASS STREAM (STANDARD-OBJECT)
  ((STATE :ALLOCATION :INSTANCE :ACCESSOR STATE...OF)))

(CL:DEFUN ACCESS-STREAM-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STATE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL STREAM STATE SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-STREAM-SLOT-VALUE
      (CLSYS-SVAL STREAM STATE SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-STREAM-SLOT-VALUE VALUE))
  :VOID)

;;; (DEFCLASS OUTPUT-STREAM ...)

(CL:DEFCLASS OUTPUT-STREAM (STREAM)
  ((NATIVE-STREAM :ALLOCATION :INSTANCE :ACCESSOR NATIVE-STREAM...OF)))

(CL:DEFUN NEW-OUTPUT-STREAM ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE OUTPUT-STREAM)))
   (CL:SETF (CLSYS-SVAL OUTPUT-STREAM STATE SELF) NULL)
   (CL:SETF (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM SELF) NULL)
   (CL:RETURN-FROM NEW-OUTPUT-STREAM SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF OUTPUT-STREAM))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-OUTPUT-STREAM)
  :VOID)

;;; (DEFCLASS INPUT-STREAM ...)

(CL:DEFCLASS INPUT-STREAM (STREAM)
  ((NATIVE-STREAM :ALLOCATION :INSTANCE :ACCESSOR NATIVE-STREAM...OF)))

(CL:DEFUN NEW-INPUT-STREAM ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INPUT-STREAM)))
   (CL:SETF (CLSYS-SVAL INPUT-STREAM STATE SELF) NULL)
   (CL:SETF (CLSYS-SVAL INPUT-STREAM NATIVE-STREAM SELF) NULL)
   (CL:RETURN-FROM NEW-INPUT-STREAM SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INPUT-STREAM))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-INPUT-STREAM)
  :VOID)

;;; (DEFCLASS OUTPUT-FILE-STREAM ...)

(CL:DEFCLASS OUTPUT-FILE-STREAM (OUTPUT-STREAM)
  ((FILENAME :ALLOCATION :INSTANCE :ACCESSOR FILENAME...OF)
   (IF-EXISTS-ACTION :ALLOCATION :INSTANCE :ACCESSOR IF-EXISTS-ACTION...OF)))

(CL:DEFUN NEW-OUTPUT-FILE-STREAM (FILENAME)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE OUTPUT-FILE-STREAM)))
   (CL:SETF (CLSYS-SVAL OUTPUT-FILE-STREAM STATE SELF) NULL)
   (CL:SETF (CLSYS-SVAL OUTPUT-FILE-STREAM NATIVE-STREAM SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL OUTPUT-FILE-STREAM IF-EXISTS-ACTION SELF)
    KWD-HIERARCHY-SUPERSEDE)
   (CL:SETF (CLSYS-SVAL OUTPUT-FILE-STREAM FILENAME SELF) FILENAME)
   (INITIALIZE-FILE-STREAM SELF)
   (CL:RETURN-FROM NEW-OUTPUT-FILE-STREAM SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF OUTPUT-FILE-STREAM))
  (CL:WHEN (CL:EQ (TERMINATE-FILE-STREAM? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFUN ACCESS-OUTPUT-FILE-STREAM-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-FILENAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL OUTPUT-FILE-STREAM FILENAME SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-OUTPUT-FILE-STREAM-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL OUTPUT-FILE-STREAM FILENAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-IF-EXISTS-ACTION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL OUTPUT-FILE-STREAM IF-EXISTS-ACTION SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-OUTPUT-FILE-STREAM-SLOT-VALUE
      (CLSYS-SVAL OUTPUT-FILE-STREAM IF-EXISTS-ACTION SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-OUTPUT-FILE-STREAM-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF OUTPUT-FILE-STREAM))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-OUTPUT-FILE-STREAM)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF OUTPUT-FILE-STREAM) STREAM)
  (CL:PROGN
   (CL:WRITE-STRING "|OFS|'" STREAM)
   (CL:WRITE-STRING (CLSYS-SVAL OUTPUT-FILE-STREAM FILENAME SELF) STREAM)
   (CL:WRITE-STRING "'" STREAM))
  :VOID)

;;; (DEFCLASS INPUT-FILE-STREAM ...)

(CL:DEFCLASS INPUT-FILE-STREAM (INPUT-STREAM)
  ((FILENAME :ALLOCATION :INSTANCE :ACCESSOR FILENAME...OF)
   (IF-NOT-EXISTS-ACTION
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    IF-NOT-EXISTS-ACTION...OF)))

(CL:DEFUN NEW-INPUT-FILE-STREAM (FILENAME)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INPUT-FILE-STREAM)))
   (CL:SETF (CLSYS-SVAL INPUT-FILE-STREAM STATE SELF) NULL)
   (CL:SETF (CLSYS-SVAL INPUT-FILE-STREAM NATIVE-STREAM SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL INPUT-FILE-STREAM IF-NOT-EXISTS-ACTION SELF)
    KWD-HIERARCHY-ERROR)
   (CL:SETF (CLSYS-SVAL INPUT-FILE-STREAM FILENAME SELF) FILENAME)
   (INITIALIZE-FILE-STREAM SELF)
   (CL:RETURN-FROM NEW-INPUT-FILE-STREAM SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF INPUT-FILE-STREAM))
  (CL:WHEN (CL:EQ (TERMINATE-FILE-STREAM? SELF) 1) (UNMAKE SELF))
  :VOID)

(CL:DEFUN ACCESS-INPUT-FILE-STREAM-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-FILENAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL INPUT-FILE-STREAM FILENAME SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-INPUT-FILE-STREAM-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL INPUT-FILE-STREAM FILENAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-IF-NOT-EXISTS-ACTION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL INPUT-FILE-STREAM IF-NOT-EXISTS-ACTION SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-INPUT-FILE-STREAM-SLOT-VALUE
      (CLSYS-SVAL INPUT-FILE-STREAM IF-NOT-EXISTS-ACTION SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-INPUT-FILE-STREAM-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INPUT-FILE-STREAM))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-INPUT-FILE-STREAM)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF INPUT-FILE-STREAM) STREAM)
  (CL:PROGN
   (CL:WRITE-STRING "|IFS|'" STREAM)
   (CL:WRITE-STRING (CLSYS-SVAL INPUT-FILE-STREAM FILENAME SELF) STREAM)
   (CL:WRITE-STRING "'" STREAM))
  :VOID)

;;; (DEFCLASS OUTPUT-STRING-STREAM ...)

(CL:DEFCLASS OUTPUT-STRING-STREAM (OUTPUT-STREAM)
  ((THE-STRING :ALLOCATION :INSTANCE :ACCESSOR THE-STRING...OF)))

(CL:DEFUN NEW-OUTPUT-STRING-STREAM (THE-STRING)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE OUTPUT-STRING-STREAM)))
   (CL:SETF (CLSYS-SVAL OUTPUT-STRING-STREAM STATE SELF) NULL)
   (CL:SETF (CLSYS-SVAL OUTPUT-STRING-STREAM NATIVE-STREAM SELF) NULL)
   (CL:SETF (CLSYS-SVAL OUTPUT-STRING-STREAM THE-STRING SELF) THE-STRING)
   (CL:RETURN-FROM NEW-OUTPUT-STRING-STREAM SELF))
  :VOID)

(CL:DEFUN ACCESS-OUTPUT-STRING-STREAM-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-THE-STRING)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL OUTPUT-STRING-STREAM THE-STRING SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-OUTPUT-STRING-STREAM-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL OUTPUT-STRING-STREAM THE-STRING SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-OUTPUT-STRING-STREAM-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF OUTPUT-STRING-STREAM))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-OUTPUT-STRING-STREAM)
  :VOID)

;;; (DEFCLASS INPUT-STRING-STREAM ...)

(CL:DEFCLASS INPUT-STRING-STREAM (INPUT-STREAM)
  ((THE-STRING :ALLOCATION :INSTANCE :ACCESSOR THE-STRING...OF)))

(CL:DEFUN NEW-INPUT-STRING-STREAM (THE-STRING)
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INPUT-STRING-STREAM)))
   (CL:SETF (CLSYS-SVAL INPUT-STRING-STREAM STATE SELF) NULL)
   (CL:SETF (CLSYS-SVAL INPUT-STRING-STREAM NATIVE-STREAM SELF) NULL)
   (CL:SETF (CLSYS-SVAL INPUT-STRING-STREAM THE-STRING SELF) THE-STRING)
   (CL:RETURN-FROM NEW-INPUT-STRING-STREAM SELF))
  :VOID)

(CL:DEFUN ACCESS-INPUT-STRING-STREAM-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-THE-STRING)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL INPUT-STRING-STREAM THE-STRING SELF)
      (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE VALUE))
     (CL:RETURN-FROM
      ACCESS-INPUT-STRING-STREAM-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL INPUT-STRING-STREAM THE-STRING SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-INPUT-STRING-STREAM-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INPUT-STRING-STREAM))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-INPUT-STRING-STREAM)
  :VOID)

(CL:DEFUN STARTUP-HIERARCHY ()
  (CL:WHEN
   (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 0) 1)
   (CL:SETQ *RECYCLED-LIST-S* (MAKE-NON-RECYCLED-LIST))
   (CL:SETQ *RECYCLED-SET-S* (MAKE-NON-RECYCLED-LIST))
   (CL:SETQ *RECYCLED-INTEGER-WRAPPER-S* (MAKE-NON-RECYCLED-LIST))
   (CL:SETQ *RECYCLED-FLOAT-WRAPPER-S* (MAKE-NON-RECYCLED-LIST))
   (CL:SETQ *RECYCLED-STRING-WRAPPER-S* (MAKE-NON-RECYCLED-LIST))
   (CL:SETQ *RECYCLED-CHARACTER-WRAPPER-S* (MAKE-NON-RECYCLED-LIST))
   (CL:SETQ *RECYCLED-FUNCTION-CODE-WRAPPER-S* (MAKE-NON-RECYCLED-LIST))
   (CL:SETQ *RECYCLED-METHOD-CODE-WRAPPER-S* (MAKE-NON-RECYCLED-LIST))
   (CL:SETQ *RECYCLED-TRANSIENT-STRING-WRAPPER-S* (MAKE-NON-RECYCLED-LIST)))
  (CL:LET*
   ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SYM-HIERARCHY-TYPE-SPEC
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE-SPEC" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-REFERENCE-COUNT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REFERENCE-COUNT" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-BAD?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BAD?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-HOME-CONTEXT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "HOME-CONTEXT" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-FIRST-ITERATION?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FIRST-ITERATION?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-OBJECT-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-ITERATOR" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CONS-ITERATOR-CURSOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS-ITERATOR-CURSOR" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-CONS-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS-ITERATOR" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-LIST-ITERATOR-CURSOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-ITERATOR-CURSOR" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-LIST-ITERATOR-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-ITERATOR-COLLECTION" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-LIST-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-ITERATOR" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-THE-CONS-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-CONS-LIST" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-DESTRUCTIVE-LIST-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESTRUCTIVE-LIST-ITERATOR" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-SET-ITERATOR-CURSOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-ITERATOR-CURSOR" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SET-ITERATOR-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-ITERATOR-COLLECTION" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-SET-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-ITERATOR" NULL 1))
    (CL:SETQ SYM-HIERARCHY-KEY (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-ITERATOR-NEXT-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-NEXT-CODE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-ITERATOR-FILTER-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-FILTER-CODE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-ITERATOR-EMPTY-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-EMPTY-CODE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-ITERATOR-NESTED-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-NESTED-ITERATOR" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-ITERATOR-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-OBJECT" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-ITERATOR-SECOND-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-SECOND-OBJECT" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-ITERATOR-INTEGER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-INTEGER" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-ITERATOR-SECOND-INTEGER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-SECOND-INTEGER" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-ITERATOR-CONS-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-CONS-LIST" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-ALL-PURPOSE-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-PURPOSE-ITERATOR" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-ITERATOR-CURSOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-CURSOR" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-TYPES-TO-CLASSES-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPES-TO-CLASSES-ITERATOR" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-OBJECT-DICTIONARY-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-DICTIONARY-ITERATOR" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-PLIST-ITERATOR-CURSOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PLIST-ITERATOR-CURSOR" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-PLIST-ITERATOR-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PLIST-ITERATOR-COLLECTION" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-PROPERTY-LIST-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTY-LIST-ITERATOR" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-THE-KV-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-KV-LIST" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-KV-LIST-ITERATOR-CURSOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KV-LIST-ITERATOR-CURSOR" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-KV-LIST-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KV-LIST-ITERATOR" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-INTERVAL-CURSOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL-CURSOR" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-LOWER-BOUND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOWER-BOUND" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-UPPER-BOUND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UPPER-BOUND" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-INTEGER-INTERVAL-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-INTERVAL-ITERATOR" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-REVERSE-INTEGER-INTERVAL-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "REVERSE-INTEGER-INTERVAL-ITERATOR"
      NULL
      1))
    (CL:SETQ
     SYM-HIERARCHY-THE-STRING
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-STRING" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CURSOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CURSOR" NULL 0))
    (CL:SETQ SYM-HIERARCHY-END (INTERN-RIGID-SYMBOL-WRT-MODULE "END" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-STRING-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-ITERATOR" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-OBJECT-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-COLLECTION" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-OBJECT-SEQUENCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-SEQUENCE" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" NULL 1))
    (CL:SETQ SGT-HIERARCHY-SET (INTERN-RIGID-SYMBOL-WRT-MODULE "SET" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-CLASS-EXTENSION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-EXTENSION" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-REST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REST" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-NEXT-SWEEP-LIST-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NEXT-SWEEP-LIST-OBJECT" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-TRANSIENT-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-CONS" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-OBJECT-TO-OBJECT-DICTIONARY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-TO-OBJECT-DICTIONARY" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-THE-PLIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-PLIST" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-PROPERTY-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTY-LIST" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-KV-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KV-CONS" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-KEY-VALUE-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-VALUE-LIST" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-HASH-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "HASH-TABLE" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-OBJECT-TO-OBJECT-HASH-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-TO-OBJECT-HASH-TABLE" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-INTEGER-HASH-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-HASH-TABLE" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-FLOAT-HASH-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT-HASH-TABLE" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-STRING-HASH-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-HASH-TABLE" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-STRING-TO-INTEGER-HASH-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-TO-INTEGER-HASH-TABLE" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-ARRAY-SIZE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ARRAY-SIZE" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-EXTENSIBLE-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIBLE-VECTOR" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-TOP-SYMBOL-OFFSET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TOP-SYMBOL-OFFSET" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-POTENTIAL-FREE-SYMBOL-OFFSET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "POTENTIAL-FREE-SYMBOL-OFFSET" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-EXTENSIBLE-SYMBOL-ARRAY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIBLE-SYMBOL-ARRAY" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-RESIZE-INCREMENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RESIZE-INCREMENT" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SEQUENCE-LENGTH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SEQUENCE-LENGTH" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-VSEQ
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VSEQ" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-SHORT-VECTOR-SEQUENCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SHORT-VECTOR-SEQUENCE" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-SVSEQ
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SVSEQ" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-BOOLEAN-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-VECTOR" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-INTEGER-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-VECTOR" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-ACTIVE-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-LIST" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-ACTIVE-SET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-SET" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-DEMON-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-NAME" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-DEMON-ACTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-ACTION" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-DEMON-CLASS-REFS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-CLASS-REFS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-DEMON-SLOT-REFS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-SLOT-REFS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-DEMON-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-CODE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-DEMON-METHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-METHOD" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-DEMON-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-DOCUMENTATION" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-DEMON-GUARD?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-GUARD?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-DEMON-ALL?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-ALL?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-DEMON-INHERIT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-INHERIT?" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-DEMON
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-LIST-OF-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-OF-SLOT" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-LIST-OF-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-OF-SYMBOL" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-LIST-OF-KEYWORD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-OF-KEYWORD" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-LIST-OF-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-OF-TYPE" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-KEYWORD-KEY-VALUE-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD-KEY-VALUE-LIST" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-SYMBOL-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-NAME" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SYMBOL-ID
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-ID" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-INTERNED-IN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERNED-IN" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SYMBOL-SLOT-OFFSET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-SLOT-OFFSET" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SYMBOL-VALUE-AND-PLIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-VALUE-AND-PLIST" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-SURROGATE-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SURROGATE-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-NAME" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-TYPE-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE-CLASS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-TYPE-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE-NAME" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOTREF-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTREF-SLOT" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-SURROGATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOTREF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTREF" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-KEYWORD-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD-NAME" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-KEYWORD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-INDEXICAL-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INDEXICAL-VALUE" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-INDEXICAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INDEXICAL" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-TRANSIENT-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-SYMBOL" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-TRANSIENT-KEYWORD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-KEYWORD" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-PROJECTS-ONTO
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROJECTS-ONTO" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-PROJECTED-FROM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROJECTED-FROM" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-PROPERTIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTIES" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-STORED-ACTIVE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STORED-ACTIVE?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-ABSTRACT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-CL-STRUCT-SLOTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CL-STRUCT-SLOTS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-RECYCLE-METHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-RECYCLE-METHOD" NULL 0))
    (CL:SETQ
     KWD-HIERARCHY-NONE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NONE" NULL 2))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-PARAMETERS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-PARAMETERS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-REQUIRED-SLOT-NAMES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-REQUIRED-SLOT-NAMES" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-GUARD-CONSTRUCTOR-DEMONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-GUARD-CONSTRUCTOR-DEMONS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-CONSTRUCTOR-DEMONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CONSTRUCTOR-DEMONS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-GUARD-DESTRUCTOR-DEMONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-GUARD-DESTRUCTOR-DEMONS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-DESTRUCTOR-DEMONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DESTRUCTOR-DEMONS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-KEY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-KEY" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-SYNONYMS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-SYNONYMS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CL-STRUCT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CL-STRUCT?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-MIXIN?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MIXIN?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-TYPE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-ARITY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-ARITY" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-DIRECT-SUPERS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DIRECT-SUPERS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-DIRECT-SUBS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DIRECT-SUBS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-ALL-SUPER-CLASSES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-ALL-SUPER-CLASSES" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-ALL-SLOTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-ALL-SLOTS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-LOCAL-SLOTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-LOCAL-SLOTS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-SLOT-AND-METHOD-CACHE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-SLOT-AND-METHOD-CACHE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-ABSTRACT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-ABSTRACT?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-MIXIN?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-MIXIN?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-COLLECTION?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-COLLECTION?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-CL-STRUCT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CL-STRUCT?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-PUBLIC?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-PUBLIC?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-FINALIZED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-FINALIZED?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-SLOTS-FINALIZED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-SLOTS-FINALIZED?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-STRINGIFIED-SOURCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-STRINGIFIED-SOURCE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-CONSTRUCTOR-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CONSTRUCTOR-CODE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-SLOT-ACCESSOR-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-SLOT-ACCESSOR-CODE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-MARKED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-MARKED?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-TAXONOMY-NODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-TAXONOMY-NODE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DOCUMENTATION" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-PRINT-FORM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-PRINT-FORM" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-PRINT-FORM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-FORM" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-ACTIVE-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-OBJECT" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-CREATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CREATOR" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-INITIALIZER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-INITIALIZER" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-TERMINATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-TERMINATOR" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-DESTRUCTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DESTRUCTOR" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-INITIAL-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-INITIAL-VALUE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-EXTENSION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-EXTENSION" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-CL-NATIVE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CL-NATIVE-TYPE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-CPP-NATIVE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CPP-NATIVE-TYPE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CLASS-JAVA-NATIVE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-JAVA-NATIVE-TYPE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-DIRECT-EQUIVALENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DIRECT-EQUIVALENT" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-AUXILIARY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-AUXILIARY?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-DIRECT-SUPERS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DIRECT-SUPERS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-DIRECT-SUBS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DIRECT-SUBS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-NAME" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-OWNER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-OWNER" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-BASE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-BASE-TYPE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-SLOTREF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-SLOTREF" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-PUBLIC?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-PUBLIC?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-RENAMED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-RENAMED?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-EXTERNAL?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-EXTERNAL?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-MARKED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-MARKED?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DOCUMENTATION" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-TYPE-SPECIFIER" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-RENAMES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-RENAMES" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-CLOSURE-ASSUMPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-CLOSURE-ASSUMPTION" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-ALLOCATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-ALLOCATION" NULL 0))
    (CL:SETQ
     KWD-HIERARCHY-INSTANCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INSTANCE" NULL 2))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-GUARD-DEMONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-GUARD-DEMONS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-DEMONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DEMONS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-ACCESSOR-METHODS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-ACCESSOR-METHODS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-REQUIRED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-REQUIRED?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-COMPONENT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-COMPONENT?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-READ-ONLY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-READ-ONLY?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-HARDWIRED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-HARDWIRED?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-CONTEXT-SENSITIVE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-CONTEXT-SENSITIVE?" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-STORAGE-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-DEFAULT-EXPRESSION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DEFAULT-EXPRESSION" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-READER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-READER" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SLOT-WRITER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-WRITER" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-PARAMETER-DIRECTIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-PARAMETER-DIRECTIONS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-VARIABLE-ARGUMENTS?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-VARIABLE-ARGUMENTS?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-BODY-ARGUMENT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-BODY-ARGUMENT?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-NATIVE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-NATIVE?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-GLOBALLY-INLINE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-GLOBALLY-INLINE?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-INLINED-FUNCTIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-INLINED-FUNCTIONS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-COMMAND?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-COMMAND?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-EVALUATE-ARGUMENTS?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-EVALUATE-ARGUMENTS?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-LISP-MACRO?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-LISP-MACRO?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-SETTER?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SETTER?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-PARAMETER-NAMES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-PARAMETER-NAMES" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-PARAMETER-TYPE-SPECIFIERS
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "METHOD-PARAMETER-TYPE-SPECIFIERS"
      NULL
      0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-RETURN-TYPE-SPECIFIERS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-RETURN-TYPE-SPECIFIERS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-STRINGIFIED-SOURCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STRINGIFIED-SOURCE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-FUNCTION-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-FUNCTION?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-FUNCTION?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-AUXILIARY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-AUXILIARY?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-DOCUMENTATION" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-METHOD-STORAGE-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STORAGE-SLOT" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-STORAGE-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-METHOD-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SLOT" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SPECIFIER-BASE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIFIER-BASE-TYPE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SPECIFIER-PARAMETER-TYPES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIFIER-PARAMETER-TYPES" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SPECIFIER-SEQUENCE-SIZE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIFIER-SEQUENCE-SIZE" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-PARAMETRIC-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARAMETRIC-TYPE-SPECIFIER" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-TRANSIENT-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-TYPE-SPECIFIER" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-SPECIFIER-PARAMETER-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIFIER-PARAMETER-NAME" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-ANCHORED-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ANCHORED-TYPE-SPECIFIER" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-VARIABLE-ARITY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-ARITY?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-TUPLE-DOMAINS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TUPLE-DOMAINS" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TABLE" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-VARIABLE-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-NAME" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-VARIABLE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-VARIABLE-SPECIAL?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-SPECIAL?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-VARIABLE-CONSTANT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-CONSTANT?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-VARIABLE-PUBLIC?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-PUBLIC?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-VARIABLE-AUXILIARY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-AUXILIARY?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-VARIABLE-GET-VALUE-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-GET-VALUE-CODE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-VARIABLE-SET-VALUE-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-SET-VALUE-CODE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-VARIABLE-VALUE-STACK
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-VALUE-STACK" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-VARIABLE-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-DOCUMENTATION" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-VARIABLE-STRINGIFIED-SOURCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-STRINGIFIED-SOURCE" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-GLOBAL-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBAL-VARIABLE" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-QUOTATION-TABLE-OFFSET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "QUOTATION-TABLE-OFFSET" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-QUOTED-EXPRESSION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "QUOTED-EXPRESSION" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-CHILD-CONTEXTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CHILD-CONTEXTS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-ALL-SUPER-CONTEXTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-SUPER-CONTEXTS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-BASE-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BASE-MODULE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CONTEXT-NUMBER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-NUMBER" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-WORLD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-WORLD-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD-NAME" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SHADOWED-SURROGATES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SHADOWED-SURROGATES" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-LOGIC-DIALECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-DIALECT" NULL 0))
    (CL:SETQ KWD-HIERARCHY-KIF (INTERN-RIGID-SYMBOL-WRT-MODULE "KIF" NULL 2))
    (CL:SETQ
     SYM-HIERARCHY-CLEARABLE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEARABLE?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-PARENT-MODULES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT-MODULES" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-REQUIRES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REQUIRES" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-USES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "USES" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-USED-BY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "USED-BY" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-MODULE-NATIVE-PACKAGE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-NATIVE-PACKAGE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-DIRECTORY-FILE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTORY-FILE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CODE-FILES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CODE-FILES" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-DEFINITIONS-FILE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINITIONS-FILE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-OPEN-WORLD-ASSUMPTION?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-WORLD-ASSUMPTION?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CASE-SENSITIVE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CASE-SENSITIVE?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-MODULE-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-NAME" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-MODULE-FULL-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-FULL-NAME" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-MODULE-STRINGIFIED-SOURCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-STRINGIFIED-SOURCE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-STRINGIFIED-OPTIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRINGIFIED-OPTIONS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CARDINAL-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CARDINAL-MODULE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SYMBOL-OFFSET-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-OFFSET-TABLE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-SURROGATE-OFFSET-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-OFFSET-TABLE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-INDEXICAL-OFFSET-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INDEXICAL-OFFSET-TABLE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-ELABORATED-WORLD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ELABORATED-WORLD" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-PARENT-CONTEXT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT-CONTEXT" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-CS-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CS-VALUE" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-INTERVAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-PARENTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENTS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-TREE-CHILDREN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TREE-CHILDREN" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-CHILDREN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CHILDREN" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-FIRST-INTERVAL-LOWER-BOUND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FIRST-INTERVAL-LOWER-BOUND" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-FIRST-INTERVAL-UPPER-BOUND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FIRST-INTERVAL-UPPER-BOUND" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-INITIAL-INTERVAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIAL-INTERVAL" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-INTERVALS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVALS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-TOTAL-ANCESTORS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TOTAL-ANCESTORS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-LABEL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LABEL" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-NATIVE-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-OBJECT" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-TAXONOMY-NODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TAXONOMY-NODE" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-INCREMENTAL-MODE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INCREMENTAL-MODE?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-RENUMBER-IF-OUT-OF-NUMBERS?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RENUMBER-IF-OUT-OF-NUMBERS?" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-LARGEST-POSTORDER-NUMBER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LARGEST-POSTORDER-NUMBER" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-ROOTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOTS" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-BROKEN-LINKS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BROKEN-LINKS" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-TAXONOMY-GRAPH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TAXONOMY-GRAPH" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-EXCEPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXCEPTION" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-STELLA-EXCEPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA-EXCEPTION" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-READ-EXCEPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "READ-EXCEPTION" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-UNHANDLED-EXCEPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNHANDLED-EXCEPTION" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-FILE-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FILE-NAME" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-WRAPPER-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAPPER-VALUE" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-INTEGER-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-FLOAT-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-STRING-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-CHARACTER-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-BOOLEAN-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-WRAPPER" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-NULL-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-BOOLEAN" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-TRUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-FALSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-FUNCTION-CODE-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-METHOD-CODE-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-TRANSIENT-INTEGER-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-INTEGER-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-TRANSIENT-FLOAT-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-FLOAT-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-TRANSIENT-STRING-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-STRING-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-TRANSIENT-CHARACTER-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-CHARACTER-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-TRANSIENT-FUNCTION-CODE-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "TRANSIENT-FUNCTION-CODE-WRAPPER"
      NULL
      1))
    (CL:SETQ
     SGT-HIERARCHY-TRANSIENT-METHOD-CODE-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-METHOD-CODE-WRAPPER" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-VERBATIM-STRING-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBATIM-STRING-WRAPPER" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-ARGUMENT-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-LIST" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-LISP-CONS-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-CONS-ITERATOR" NULL 1))
    (CL:SETQ
     SYM-HIERARCHY-STATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STATE" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-OUTPUT-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-STREAM" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-INPUT-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-STREAM" NULL 1))
    (CL:SETQ
     KWD-HIERARCHY-SUPERSEDE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPERSEDE" NULL 2))
    (CL:SETQ
     SYM-HIERARCHY-FILENAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FILENAME" NULL 0))
    (CL:SETQ
     SYM-HIERARCHY-IF-EXISTS-ACTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IF-EXISTS-ACTION" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-OUTPUT-FILE-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-FILE-STREAM" NULL 1))
    (CL:SETQ
     KWD-HIERARCHY-ERROR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
    (CL:SETQ
     SYM-HIERARCHY-IF-NOT-EXISTS-ACTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IF-NOT-EXISTS-ACTION" NULL 0))
    (CL:SETQ
     SGT-HIERARCHY-INPUT-FILE-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-FILE-STREAM" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-OUTPUT-STRING-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-STRING-STREAM" NULL 1))
    (CL:SETQ
     SGT-HIERARCHY-INPUT-STRING-STREAM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-STRING-STREAM" NULL 1)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 5) 1)
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "OBJECT"
     "(DEFCLASS OBJECT () :DOCUMENTATION \"A reflective object that can participate in dynamically-typed
contexts.  Either a STANDARD-OBJECT or a WRAPPER or a GENERIC-OBJECT.
Also, either an OBJECT-WITH-INHERITED-TYPE or an OBJECT-WITH-OWN-TYPE.\" :PUBLIC-METHODS ((PRIMARY-TYPE ((SELF OBJECT)) :TYPE TYPE :DOCUMENTATION \"Returns the primary type of 'self'.
Gets defined automatically for every non-abstract subclass of OBJECT.\" (RETURN NULL))) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|i|\" (PRIMARY-TYPE SELF)) :METHODS ((INCREMENT-REFERENCE-COUNT ((SELF OBJECT)) NULL) (DECREMENT-REFERENCE-COUNT ((SELF OBJECT)) NULL)) :ABSTRACT? TRUE)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "SECOND-CLASS-OBJECT"
     "(DEFCLASS SECOND-CLASS-OBJECT () :DOCUMENTATION \"A C++ object, or a CLOS object pretending to be second class.
Not a first-class object, since it can't participate in dynamically-typed
contexts.\" :ABSTRACT? TRUE)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "NON-OBJECT"
     "(DEFCLASS NON-OBJECT () :DOCUMENTATION \"A data structure that cannot be a dispatch argument to
a (real) method, because its type is not accessible at run-time.\" :ABSTRACT? TRUE)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "STANDARD-OBJECT"
     "(DEFCLASS STANDARD-OBJECT (OBJECT) :DOCUMENTATION \"Object that used to find its type stored in a :class slot.
By reimplementing 'primary-type' as a method, the justification for this
class went away, but we'll keep it for now to keep things working.\" :ABSTRACT? TRUE :SYNONYMS (TYPE-SPEC))")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRANSIENT-MIXIN"
        "(DEFCLASS TRANSIENT-MIXIN () :DOCUMENTATION \"Transient objects are periodically swept back into a pool
of free objects.  A transient object should never be pointed at by a
permanent object.\" :MIXIN? TRUE :SLOTS ((TRANSIENT? :TYPE BOOLEAN :INITIALLY TRUE :HARDWIRED? TRUE)))")))
     (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* TRUE))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "REFERENCE-COUNT-OBJECT"
        "(DEFCLASS REFERENCE-COUNT-OBJECT (OBJECT) :DOCUMENTATION \"A reference count objects contains a slot 'reference-count' 
that is incremented whenever the object is assigned to a slot, and decremented
whenever it is deassigned from a slot.\" :ABSTRACT? TRUE :SLOTS ((REFERENCE-COUNT :TYPE INTEGER :INITIALLY 0)) :METHODS ((INCREMENT-REFERENCE-COUNT ((SELF REFERENCE-COUNT-OBJECT)) (SETF (REFERENCE-COUNT SELF) (+ (REFERENCE-COUNT SELF) 1))) (DECREMENT-REFERENCE-COUNT ((SELF REFERENCE-COUNT-OBJECT)) (SETF (REFERENCE-COUNT SELF) (- (REFERENCE-COUNT SELF) 1)))))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-REFERENCE-COUNT-OBJECT-SLOT-VALUE)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "DYNAMIC-SLOTS-MIXIN"
     "(DEFCLASS DYNAMIC-SLOTS-MIXIN () :SLOTS ((DYNAMIC-SLOTS :TYPE KEY-VALUE-LIST :ALLOCATION :EMBEDDED) (BITS :TYPE THIRTY-TWO-BIT-VECTOR) (BAD? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DOCUMENTATION \"Indicates that an object is in need of repair.\") (DELETED-OBJECT? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :READER DELETED? :WRITER DELETED?-SETTER :DOCUMENTATION \"Indicates that an object has been 
destroyed/deleted.  A deleted object is visible only if something broke
before it was fully excised from the network).\")) :DOCUMENTATION \"For system use only.  Object that can store
slot values in non-preallocated storage.\" :MIXIN? TRUE)")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "CONTEXT-SENSITIVE-OBJECT"
        "(DEFCLASS CONTEXT-SENSITIVE-OBJECT (STANDARD-OBJECT) :DOCUMENTATION \"Context sensitive objects inherit a slot 'home-context'
that enables context-dependent access machinery to determine the
visibility of objects from modules.\" :ABSTRACT? TRUE :SLOTS ((HOME-CONTEXT :TYPE CONTEXT :INITIALLY *MODULE*)) :METHODS ((HOME-MODULE ((SELF CONTEXT-SENSITIVE-OBJECT)) :TYPE MODULE :PUBLIC? TRUE (RETURN (HOME-CONTEXT SELF)))))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CONTEXT-SENSITIVE-OBJECT-SLOT-VALUE)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "ACTIVE-OBJECT"
     "(DEFCLASS ACTIVE-OBJECT (CONTEXT-SENSITIVE-OBJECT DYNAMIC-SLOTS-MIXIN) :DOCUMENTATION \"Active objects call class and slot triggers in response
to instance creation/destruction and slot updates.  They include internal
storage slots needed for class extensions, dynamic storage, and home context.\" :ABSTRACT? TRUE)")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "ABSTRACT-ITERATOR"
        "(DEFCLASS ABSTRACT-ITERATOR (STANDARD-OBJECT) :ABSTRACT? TRUE :DOCUMENTATION \"Instances of ABSTRACT-ITERATOR support iteration over collections.\" :PARAMETERS ((ANY-VALUE :TYPE UNKNOWN)) :PUBLIC-SLOTS ((VALUE :TYPE (LIKE (ANY-VALUE SELF)))) :PUBLIC-METHODS ((NEXT? ((SELF ABSTRACT-ITERATOR)) :TYPE BOOLEAN (RETURN NULL)) (LENGTH ((SELF ABSTRACT-ITERATOR)) :TYPE INTEGER)) :SLOTS ((FIRST-ITERATION? :TYPE BOOLEAN :INITIALLY TRUE)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-ABSTRACT-ITERATOR-SLOT-VALUE)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "ITERATOR"
     "(DEFCLASS ITERATOR (ABSTRACT-ITERATOR) :ABSTRACT? TRUE :DOCUMENTATION \"Instances of ITERATOR support iteration over 
collections of OBJECTs.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SYNONYMS (OBJECT-ITERATOR))")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "CONS-ITERATOR"
        "(DEFCLASS CONS-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator class for the class CONS.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((CONS-ITERATOR-CURSOR :TYPE CONS)) :TERMINATOR TERMINATE-CONS-ITERATOR?)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CONS-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CONS-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "LIST-ITERATOR"
        "(DEFCLASS LIST-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator class for the collection LIST.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((LIST-ITERATOR-CURSOR :TYPE CONS) (LIST-ITERATOR-COLLECTION :TYPE LIST)) :TERMINATOR TERMINATE-LIST-ITERATOR?)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-LIST-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-LIST-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "DESTRUCTIVE-LIST-ITERATOR"
        "(DEFCLASS DESTRUCTIVE-LIST-ITERATOR (ITERATOR) :DOCUMENTATION \"An iterator that contains a cons list.  Iterates over
the stored list, and destroys it when the iterator is free'd.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((THE-CONS-LIST :TYPE CONS :INITIALLY NIL) (LIST-ITERATOR-CURSOR :TYPE CONS)) :TERMINATOR TERMINATE-DESTRUCTIVE-LIST-ITERATOR?)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-DESTRUCTIVE-LIST-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-DESTRUCTIVE-LIST-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "SET-ITERATOR"
        "(DEFCLASS SET-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator class for the collection SET.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((SET-ITERATOR-CURSOR :TYPE CONS) (SET-ITERATOR-COLLECTION :TYPE SET)) :TERMINATOR TERMINATE-SET-ITERATOR?)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SET-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SET-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "ALL-PURPOSE-ITERATOR"
        "(DEFCLASS ALL-PURPOSE-ITERATOR (ITERATOR) :DOCUMENTATION \"The all-purpose iterator works by storing a 'next?'
function within itself during iterator allocation.  The method
'ALL-PURPOSE-ITERAOR.next?' funcalls the stored 'next?' function.
An assortment of storage slots are provided for constructing different
kinds of iterators.\" :PUBLIC-SLOTS ((KEY :TYPE OBJECT)) :SLOTS ((ITERATOR-NEXT-CODE :TYPE FUNCTION-CODE) (ITERATOR-FILTER-CODE :TYPE FUNCTION-CODE) (ITERATOR-EMPTY-CODE :TYPE FUNCTION-CODE) (ITERATOR-NESTED-ITERATOR :TYPE ITERATOR) (ITERATOR-OBJECT :TYPE OBJECT) (ITERATOR-SECOND-OBJECT :TYPE OBJECT) (ITERATOR-INTEGER :TYPE INTEGER) (ITERATOR-SECOND-INTEGER :TYPE INTEGER) (ITERATOR-CONS-LIST :TYPE CONS)) :TERMINATOR TERMINATE-ALL-PURPOSE-ITERATOR?)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-ALL-PURPOSE-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TYPES-TO-CLASSES-ITERATOR"
        "(DEFCLASS TYPES-TO-CLASSES-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator that returns a class for each type
in a cons list of types.\" :PARAMETERS ((ANY-VALUE :TYPE CLASS)) :SLOTS ((ITERATOR-CURSOR :TYPE (CONS OF TYPE) :REQUIRED? TRUE)) :METHODS ((NEXT? ((SELF TYPES-TO-CLASSES-ITERATOR)) :TYPE BOOLEAN (IF (FIRST-ITERATION? SELF) (SETF (FIRST-ITERATION? SELF) FALSE) (SETF (ITERATOR-CURSOR SELF) (REST (ITERATOR-CURSOR SELF)))) (COND ((NON-EMPTY? (ITERATOR-CURSOR SELF)) (SETF (VALUE SELF) (TYPE-CLASS (FIRST (ITERATOR-CURSOR SELF)))) (RETURN TRUE)) (OTHERWISE (RETURN FALSE))))))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TYPES-TO-CLASSES-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TYPES-TO-CLASSES-ITERATOR-SLOT-VALUE)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "ABSTRACT-DICTIONARY-ITERATOR"
     "(DEFCLASS ABSTRACT-DICTIONARY-ITERATOR (ABSTRACT-ITERATOR) :ABSTRACT? TRUE :DOCUMENTATION \"Instances of ABSTRACT-DICTIONARY-ITERATOR support iteration
over dictionaries.\" :PARAMETERS ((ANY-KEY :TYPE UNKNOWN) (ANY-VALUE :TYPE UNKNOWN)) :PUBLIC-SLOTS ((KEY :TYPE (LIKE (ANY-KEY SELF)))))")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "DICTIONARY-ITERATOR"
     "(DEFCLASS DICTIONARY-ITERATOR (ABSTRACT-DICTIONARY-ITERATOR) :ABSTRACT? TRUE :DOCUMENTATION \"Instances of DICTIONARY-ITERATOR support iteration
over dictionaries with keys and values of type OBJECT.\" :PARAMETERS ((ANY-KEY :TYPE OBJECT) (ANY-VALUE :TYPE OBJECT)) :SYNONYMS (OBJECT-DICTIONARY-ITERATOR))")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "PROPERTY-LIST-ITERATOR"
        "(DEFCLASS PROPERTY-LIST-ITERATOR (DICTIONARY-ITERATOR) :DOCUMENTATION \"Iterator class for the collection PROPERTY-LIST.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT) (ANY-KEY :TYPE OBJECT)) :SLOTS ((PLIST-ITERATOR-CURSOR :TYPE CONS) (PLIST-ITERATOR-COLLECTION :TYPE PROPERTY-LIST)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-PROPERTY-LIST-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-PROPERTY-LIST-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "KV-LIST-ITERATOR"
        "(DEFCLASS KV-LIST-ITERATOR (DICTIONARY-ITERATOR) :PARAMETERS ((ANY-VALUE :TYPE OBJECT) (ANY-KEY :TYPE OBJECT)) :SLOTS ((THE-KV-LIST :TYPE KEY-VALUE-LIST) (KV-LIST-ITERATOR-CURSOR :TYPE KV-CONS)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-KV-LIST-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-KV-LIST-ITERATOR-SLOT-VALUE)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "INTERVAL-ITERATOR"
     "(DEFCLASS INTERVAL-ITERATOR (ABSTRACT-ITERATOR) :ABSTRACT? TRUE :DOCUMENTATION \"An iterator that specifies a (possibly infinite) range of
values.  Supports 'member?' test as well as iteration methods.\" :SLOTS ((LOWER-BOUND :TYPE UNKNOWN :REQUIRED? TRUE) (UPPER-BOUND :TYPE UNKNOWN :REQUIRED? TRUE)))")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "INTEGER-INTERVAL-ITERATOR"
        "(DEFCLASS INTEGER-INTERVAL-ITERATOR (INTERVAL-ITERATOR) :PARAMETERS ((ANY-VALUE :TYPE INTEGER)) :SLOTS ((INTERVAL-CURSOR :TYPE INTEGER) (LOWER-BOUND :TYPE INTEGER :REQUIRED? TRUE) (UPPER-BOUND :TYPE INTEGER :REQUIRED? TRUE)) :INITIALIZER INITIALIZE-INTEGER-INTERVAL-ITERATOR)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INTEGER-INTERVAL-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "REVERSE-INTEGER-INTERVAL-ITERATOR"
        "(DEFCLASS REVERSE-INTEGER-INTERVAL-ITERATOR (INTERVAL-ITERATOR) :PARAMETERS ((ANY-VALUE :TYPE INTEGER)) :SLOTS ((INTERVAL-CURSOR :TYPE INTEGER) (LOWER-BOUND :TYPE INTEGER :REQUIRED? TRUE) (UPPER-BOUND :TYPE INTEGER :REQUIRED? TRUE)) :INITIALIZER INITIALIZE-REVERSE-INTEGER-INTERVAL-ITERATOR)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-REVERSE-INTEGER-INTERVAL-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-REVERSE-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "STRING-ITERATOR"
        "(DEFCLASS STRING-ITERATOR (ABSTRACT-ITERATOR) :DOCUMENTATION \"Iterator that yields characters from a string.\" :PARAMETERS ((ANY-VALUE :TYPE CHARACTER)) :SLOTS ((THE-STRING :TYPE STRING) (CURSOR :TYPE INTEGER) (END :TYPE INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-STRING-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-STRING-ITERATOR-SLOT-VALUE)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "ABSTRACT-COLLECTION"
     "(DEFCLASS ABSTRACT-COLLECTION (STANDARD-OBJECT) :PARAMETERS ((ANY-VALUE :TYPE UNKNOWN)) :PUBLIC-METHODS ((ALLOCATE-ITERATOR ((SELF ABSTRACT-COLLECTION)) :TYPE (ABSTRACT-ITERATOR OF (LIKE (ANY-VALUE SELF))) (RETURN NULL)) (LENGTH ((SELF ABSTRACT-COLLECTION)) :TYPE INTEGER (RETURN NULL)) (INSERT ((SELF ABSTRACT-COLLECTION) (VALUE (LIKE (ANY-VALUE SELF))))) (REMOVE ((SELF ABSTRACT-COLLECTION) (VALUE (LIKE (ANY-VALUE SELF)))) :TYPE ABSTRACT-COLLECTION)) :ABSTRACT? TRUE)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "COLLECTION"
     "(DEFCLASS COLLECTION (ABSTRACT-COLLECTION) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :PUBLIC-METHODS ((ALLOCATE-ITERATOR ((SELF COLLECTION)) :TYPE (ITERATOR OF (LIKE (ANY-VALUE SELF))) (RETURN NULL)) (LENGTH ((SELF COLLECTION)) :TYPE INTEGER (RETURN NULL)) (INSERT ((SELF COLLECTION) (VALUE (LIKE (ANY-VALUE SELF)))) (RETURN)) (REMOVE ((SELF COLLECTION) (VALUE (LIKE (ANY-VALUE SELF)))) :TYPE COLLECTION (RETURN NULL))) :SLOTS ((CLOSED :TYPE BOOLEAN :ABSTRACT? TRUE)) :ABSTRACT? TRUE :SYNONYMS (OBJECT-COLLECTION))")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "SET-MIXIN"
     "(DEFCLASS SET-MIXIN () :DOCUMENTATION \"Users of this mixin check for duplicates inside of 
the method 'insert'.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :MIXIN? TRUE)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "SEQUENCE-MIXIN"
     "(DEFCLASS SEQUENCE-MIXIN () :PARAMETERS ((ANY-VALUE :TYPE UNKNOWN)) :PUBLIC-METHODS ((FIRST ((SEQUENCE SEQUENCE-MIXIN)) :TYPE (LIKE (ANY-VALUE SELF))) (NTH ((SEQUENCE SEQUENCE-MIXIN) (POSITION INTEGER)) :TYPE (LIKE (ANY-VALUE SELF)))) :MIXIN? TRUE)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "SEQUENCE"
     "(DEFCLASS SEQUENCE (COLLECTION SEQUENCE-MIXIN) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :PUBLIC-METHODS ((ALLOCATE-ITERATOR ((SELF SEQUENCE)) :TYPE (ITERATOR OF (LIKE (ANY-VALUE SELF))) (RETURN NULL)) (LENGTH ((SEQUENCE SEQUENCE)) :TYPE INTEGER (RETURN NULL))) :ABSTRACT? TRUE :SYNONYMS (OBJECT-SEQUENCE))")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "LIST"
        "(DEFCLASS LIST (SEQUENCE) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((THE-CONS-LIST :TYPE (CONS OF (LIKE (ANY-VALUE SELF))) :INITIALLY NIL)) :RECYCLE-METHOD :FREE-LIST :TERMINATOR TERMINATE-LIST? :INITIAL-VALUE NIL-LIST :PRINT-FORM (PRINT-CONS-LIST (THE-CONS-LIST SELF) STREAM))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-LIST))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-LIST-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "SET"
        "(DEFCLASS SET (COLLECTION SET-MIXIN) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((THE-CONS-LIST :TYPE (CONS OF (LIKE (ANY-VALUE SELF))) :INITIALLY NIL)) :RECYCLE-METHOD :FREE-LIST :TERMINATOR TERMINATE-SET? :PRINT-FORM (PRINT-CONS-LIST (THE-CONS-LIST SELF) STREAM))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SET))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SET-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "CLASS-EXTENSION"
        "(DEFCLASS CLASS-EXTENSION (LIST) :PARAMETERS ((ANY-VALUE :TYPE ACTIVE-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CLASS-EXTENSION)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "CONS"
        "(DEFCLASS CONS (STANDARD-OBJECT) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :METHODS ((ALLOCATE-ITERATOR ((SELF CONS)) :TYPE (ITERATOR OF (LIKE (ANY-VALUE SELF))))) :SLOTS ((VALUE :TYPE (LIKE (ANY-VALUE SELF)) :PUBLIC? TRUE) (REST :TYPE (CONS OF (LIKE (ANY-VALUE SELF))) :PUBLIC? TRUE :INITIALLY NIL)) :RECYCLE-METHOD :FREE-LIST :INITIAL-VALUE NIL :PRINT-FORM (PRINT-CONS SELF STREAM \"{\" \"}\"))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CONS))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CONS-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRANSIENT-CONS"
        "(DEFCLASS TRANSIENT-CONS (CONS TRANSIENT-MIXIN) :RECYCLE-METHOD :FREE-AND-SWEEP-LIST :PRINT-FORM (PRINT-CONS SELF STREAM \"[\" \"]\"))")))
     (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* TRUE)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRANSIENT-CONS))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TRANSIENT-CONS-SLOT-VALUE)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "ABSTRACT-DICTIONARY"
     "(DEFCLASS ABSTRACT-DICTIONARY (ABSTRACT-COLLECTION) :PARAMETERS ((ANY-KEY :TYPE UNKNOWN) (ANY-VALUE :TYPE UNKNOWN)) :PUBLIC-METHODS ((LOOKUP ((SELF ABSTRACT-DICTIONARY) (KEY (LIKE (ANY-KEY SELF)))) :TYPE (LIKE (ANY-VALUE SELF))) (INSERT-AT ((SELF ABSTRACT-DICTIONARY) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))))) :METHODS ((ALLOCATE-ITERATOR ((SELF ABSTRACT-DICTIONARY)) :TYPE (ABSTRACT-DICTIONARY-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF))) (RETURN NULL))) :ABSTRACT? TRUE)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "DICTIONARY"
     "(DEFCLASS DICTIONARY (ABSTRACT-DICTIONARY) :PARAMETERS ((ANY-KEY :TYPE OBJECT) (ANY-VALUE :TYPE OBJECT)) :METHODS ((ALLOCATE-ITERATOR ((SELF DICTIONARY)) :TYPE (DICTIONARY-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF))) (RETURN NULL))) :ABSTRACT? TRUE :SYNONYMS (OBJECT-TO-OBJECT-DICTIONARY))")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "PROPERTY-LIST"
        "(DEFCLASS PROPERTY-LIST (DICTIONARY) :PARAMETERS ((ANY-KEY :TYPE OBJECT) (ANY-VALUE :TYPE OBJECT)) :SLOTS ((THE-PLIST :TYPE CONS :INITIALLY NIL)) :PRINT-FORM (PRINT-CONS-LIST (THE-PLIST SELF) STREAM))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-PROPERTY-LIST))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-PROPERTY-LIST-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "KV-CONS"
        "(DEFCLASS KV-CONS (STANDARD-OBJECT) :SLOTS ((KEY :TYPE OBJECT) (VALUE :TYPE OBJECT) (REST :TYPE KV-CONS)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"<\" (KEY SELF) \",\" (VALUE SELF) \">\"))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-KV-CONS))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-KV-CONS-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "KEY-VALUE-LIST"
        "(DEFCLASS KEY-VALUE-LIST (DICTIONARY) :PARAMETERS ((ANY-KEY :TYPE OBJECT) (ANY-VALUE :TYPE OBJECT)) :SLOTS ((THE-KV-LIST :TYPE KV-CONS)) :PRINT-FORM (PRINT-KEY-VALUE-LIST SELF STREAM))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-KEY-VALUE-LIST))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-KEY-VALUE-LIST-SLOT-VALUE)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "ABSTRACT-HASH-TABLE"
     "(DEFCLASS ABSTRACT-HASH-TABLE (ABSTRACT-DICTIONARY) :PARAMETERS ((ANY-KEY :TYPE UNKNOWN) (ANY-VALUE :TYPE UNKNOWN)) :SLOTS ((THE-HASH-TABLE :TYPE NATIVE-HASH-TABLE)) :INITIALIZER INITIALIZE-HASH-TABLE :ABSTRACT? TRUE)")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "HASH-TABLE"
        "(DEFCLASS HASH-TABLE (ABSTRACT-HASH-TABLE) :PARAMETERS ((ANY-KEY :TYPE OBJECT) (ANY-VALUE :TYPE OBJECT)) :INITIALIZER INITIALIZE-HASH-TABLE :SYNONYMS (OBJECT-TO-OBJECT-HASH-TABLE))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-HASH-TABLE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "INTEGER-HASH-TABLE"
        "(DEFCLASS INTEGER-HASH-TABLE (ABSTRACT-HASH-TABLE) :PARAMETERS ((ANY-KEY :TYPE INTEGER) (ANY-VALUE :TYPE OBJECT)) :INITIALIZER INITIALIZE-HASH-TABLE)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INTEGER-HASH-TABLE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "FLOAT-HASH-TABLE"
        "(DEFCLASS FLOAT-HASH-TABLE (ABSTRACT-HASH-TABLE) :PARAMETERS ((ANY-KEY :TYPE FLOAT) (ANY-VALUE :TYPE OBJECT)) :INITIALIZER INITIALIZE-HASH-TABLE)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-FLOAT-HASH-TABLE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "STRING-HASH-TABLE"
        "(DEFCLASS STRING-HASH-TABLE (ABSTRACT-HASH-TABLE) :PARAMETERS ((ANY-KEY :TYPE STRING) (ANY-VALUE :TYPE OBJECT)) :INITIALIZER INITIALIZE-HASH-TABLE)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-STRING-HASH-TABLE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "STRING-TO-INTEGER-HASH-TABLE"
        "(DEFCLASS STRING-TO-INTEGER-HASH-TABLE (ABSTRACT-HASH-TABLE) :PARAMETERS ((ANY-KEY :TYPE STRING) (ANY-VALUE :TYPE INTEGER)) :INITIALIZER INITIALIZE-HASH-TABLE)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-STRING-TO-INTEGER-HASH-TABLE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "VECTOR"
        "(DEFCLASS VECTOR (SEQUENCE) :PUBLIC-SLOTS ((ARRAY-SIZE :TYPE INTEGER :REQUIRED? TRUE)) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((THE-ARRAY :TYPE NATIVE-VECTOR)) :PRINT-FORM (PRINT-VECTOR SELF STREAM) :INITIALIZER INITIALIZE-VECTOR)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-VECTOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-VECTOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "EXTENSIBLE-VECTOR"
        "(DEFCLASS EXTENSIBLE-VECTOR (VECTOR) :INITIALIZER INITIALIZE-VECTOR)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-EXTENSIBLE-VECTOR)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "EXTENSIBLE-SYMBOL-ARRAY"
        "(DEFCLASS EXTENSIBLE-SYMBOL-ARRAY (EXTENSIBLE-VECTOR) :DOCUMENTATION \"Self-extending array with methods for storing and
accessing symbols within it.\" :SLOTS ((TOP-SYMBOL-OFFSET :TYPE INTEGER :INITIALLY -1) (POTENTIAL-FREE-SYMBOL-OFFSET :TYPE INTEGER :INITIALLY 0)) :INITIALIZER INITIALIZE-VECTOR)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-EXTENSIBLE-SYMBOL-ARRAY))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-EXTENSIBLE-SYMBOL-ARRAY-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "VECTOR-SEQUENCE"
        "(DEFCLASS VECTOR-SEQUENCE (VECTOR) :ABSTRACT? TRUE :SLOTS ((RESIZE-INCREMENT :TYPE INTEGER :HARDWIRED? TRUE :INITIALLY 100) (SEQUENCE-LENGTH :TYPE INTEGER)) :INITIALIZER INITIALIZE-VECTOR :SYNONYMS (VSEQ))")))
     (CL:SETQ *HARDWIRED-RESIZE-INCREMENT-ON-VECTOR-SEQUENCE* 100)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-VECTOR-SEQUENCE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "SHORT-VECTOR-SEQUENCE"
        "(DEFCLASS SHORT-VECTOR-SEQUENCE (VECTOR-SEQUENCE) :SLOTS ((RESIZE-INCREMENT :TYPE INTEGER :HARDWIRED? TRUE :INITIALLY 4) (SEQUENCE-LENGTH :TYPE INTEGER :INITIALLY 0)) :INITIALIZER INITIALIZE-VECTOR :SYNONYMS (SVSEQ))")))
     (CL:SETQ *HARDWIRED-RESIZE-INCREMENT-ON-VECTOR-SEQUENCE* 100)
     (CL:SETQ *HARDWIRED-RESIZE-INCREMENT-ON-SHORT-VECTOR-SEQUENCE* 4)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SHORT-VECTOR-SEQUENCE))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SHORT-VECTOR-SEQUENCE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "BOOLEAN-VECTOR"
        "(DEFCLASS BOOLEAN-VECTOR (VECTOR) :PARAMETERS ((ANY-VALUE :TYPE BOOLEAN-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-BOOLEAN-VECTOR)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "INTEGER-VECTOR"
        "(DEFCLASS INTEGER-VECTOR (VECTOR) :PARAMETERS ((ANY-VALUE :TYPE INTEGER-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INTEGER-VECTOR)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "ARRAY"
     "(DEFCLASS ARRAY (ABSTRACT-COLLECTION) :CL-NATIVE-TYPE \"ARRAY\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "NULL-TERMINATED-ARRAY"
     "(DEFCLASS NULL-TERMINATED-ARRAY (ARRAY) :PUBLIC-METHODS ((LENGTH ((SELF NULL-TERMINATED-ARRAY)) :TYPE INTEGER)) :CL-NATIVE-TYPE \"ARRAY\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "NATIVE-HASH-TABLE"
     "(DEFCLASS NATIVE-HASH-TABLE () :CPP-NATIVE-TYPE \"cpp_hash_table*\" :CL-NATIVE-TYPE \"HASH-TABLE\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "NATIVE-VECTOR"
     "(DEFCLASS NATIVE-VECTOR () :CPP-NATIVE-TYPE \"cpp_vector*\" :CL-NATIVE-TYPE \"VECTOR\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "ACTIVE-COLLECTION-MIXIN"
     "(DEFCLASS ACTIVE-COLLECTION-MIXIN () :DOCUMENTATION \"Mixin class that provides collection instances with a
backpointer to the instance slot they belong to.\" :MIXIN? TRUE :SLOTS ((ACTIVE-SLOT :TYPE STORAGE-SLOT) (OWNER-INSTANCE :TYPE STANDARD-OBJECT)))")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "ACTIVE-LIST"
        "(DEFCLASS ACTIVE-LIST (LIST ACTIVE-COLLECTION-MIXIN))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-ACTIVE-LIST)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "ACTIVE-SET"
        "(DEFCLASS ACTIVE-SET (LIST SET-MIXIN ACTIVE-COLLECTION-MIXIN))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-ACTIVE-SET)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "DEMON"
        "(DEFCLASS DEMON (STANDARD-OBJECT) :SLOTS ((DEMON-NAME :TYPE STRING) (DEMON-ACTION :TYPE KEYWORD) (DEMON-CLASS-REFS :TYPE (LIST OF TYPE) :ALLOCATION :EMBEDDED) (DEMON-SLOT-REFS :TYPE (LIST OF SYMBOL) :ALLOCATION :EMBEDDED) (DEMON-CODE :TYPE FUNCTION-CODE) (DEMON-METHOD :TYPE METHOD-SLOT) (DEMON-DOCUMENTATION :TYPE STRING) (DEMON-GUARD? :TYPE BOOLEAN) (DEMON-ALL? :TYPE BOOLEAN) (DEMON-INHERIT? :TYPE BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-DEMON))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-DEMON-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "LIST-OF-SLOT"
        "(DEFCLASS LIST-OF-SLOT (LIST) :PARAMETERS ((ANY-VALUE :TYPE SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-LIST-OF-SLOT)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "LIST-OF-SYMBOL"
        "(DEFCLASS LIST-OF-SYMBOL (LIST) :PARAMETERS ((ANY-VALUE :TYPE SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-LIST-OF-SYMBOL)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "LIST-OF-KEYWORD"
        "(DEFCLASS LIST-OF-KEYWORD (LIST) :PARAMETERS ((ANY-VALUE :TYPE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-LIST-OF-KEYWORD)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "LIST-OF-TYPE"
        "(DEFCLASS LIST-OF-TYPE (LIST) :PARAMETERS ((ANY-VALUE :TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-LIST-OF-TYPE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "KEYWORD-KEY-VALUE-LIST"
        "(DEFCLASS KEYWORD-KEY-VALUE-LIST (KEY-VALUE-LIST) :PARAMETERS ((ANY-KEY :TYPE KEYWORD) (ANY-VALUE :TYPE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-KEYWORD-KEY-VALUE-LIST)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "GENERALIZED-SYMBOL"
        "(DEFCLASS GENERALIZED-SYMBOL (CONTEXT-SENSITIVE-OBJECT) :SLOTS ((SYMBOL-NAME :TYPE STRING :REQUIRED? TRUE) (SYMBOL-ID :TYPE INTEGER) (INTERNED-IN :RENAMES HOME-CONTEXT :TYPE MODULE)) :ABSTRACT? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-GENERALIZED-SYMBOL-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "SYMBOL"
        "(DEFCLASS SYMBOL (GENERALIZED-SYMBOL) :SLOTS ((SYMBOL-SLOT-OFFSET :TYPE INTEGER) (SYMBOL-VALUE-AND-PLIST :TYPE CONS :INITIALLY NIL)) :PRINT-FORM (PRINT-SYMBOL SELF STREAM))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SYMBOL))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SYMBOL-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "SURROGATE"
        "(DEFCLASS SURROGATE (GENERALIZED-SYMBOL) :DOCUMENTATION \"Rigid surrogate.\" :SLOTS ((SURROGATE-VALUE :TYPE OBJECT) (SURROGATE-NAME :RENAMES SYMBOL-NAME) (TYPE-CLASS :RENAMES SURROGATE-VALUE :TYPE CLASS) (TYPE-NAME :RENAMES SYMBOL-NAME) (SLOTREF-SLOT :RENAMES SURROGATE-VALUE :TYPE SLOT)) :SYNONYMS (TYPE SLOTREF) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM (RELATIVE-NAME SELF)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SURROGATE))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SURROGATE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "KEYWORD"
        "(DEFCLASS KEYWORD (GENERALIZED-SYMBOL) :SLOTS ((KEYWORD-NAME :RENAMES SYMBOL-NAME)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \":\" (SYMBOL-NAME SELF)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-KEYWORD))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-KEYWORD-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "INDEXICAL"
        "(DEFCLASS INDEXICAL (GENERALIZED-SYMBOL) :DOCUMENTATION \"Surrogate with context sensitive value.\" :SLOTS ((INDEXICAL-VALUE :TYPE OBJECT :CONTEXT-SENSITIVE? TRUE)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM (RELATIVE-NAME SELF)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INDEXICAL))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-INDEXICAL-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRANSIENT-SYMBOL"
        "(DEFCLASS TRANSIENT-SYMBOL (SYMBOL TRANSIENT-MIXIN))")))
     (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* TRUE)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRANSIENT-SYMBOL)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRANSIENT-KEYWORD"
        "(DEFCLASS TRANSIENT-KEYWORD (KEYWORD TRANSIENT-MIXIN))")))
     (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* TRUE)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRANSIENT-KEYWORD)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "MAPPABLE-OBJECT"
        "(DEFCLASS MAPPABLE-OBJECT (STANDARD-OBJECT DYNAMIC-SLOTS-MIXIN) :DOCUMENTATION \"The class MAPPABLE-OBJECT enables the definition of projections
from a Stella class, slot, global variable, etc. onto a corresponding native
entity.\" :ABSTRACT? TRUE :PUBLIC-SLOTS ((PROJECTS-ONTO :TYPE (LIST OF SYMBOL) :ALLOCATION :DYNAMIC) (PROJECTED-FROM :TYPE (LIST OF SYMBOL) :ALLOCATION :DYNAMIC) (PROJECTION-TRANSFORM :TYPE SYMBOL :ALLOCATION :DYNAMIC :DOCUMENTATION \"Names a coersion function that translates
values retrieved from the 'from' entity to the 'projecting' entity.\")) :SLOTS ((NATIVE-NAME :TYPE STRING :ALLOCATION :DYNAMIC :DOCUMENTATION \"Used in cases when the native name cannot be
cast as a symbol (e.g., because it contains illegal characters).\")))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-MAPPABLE-OBJECT-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "RELATION"
        "(DEFCLASS RELATION (MAPPABLE-OBJECT) :ABSTRACT? TRUE :PUBLIC-SLOTS ((DOCUMENTATION :TYPE STRING :ALLOCATION :DYNAMIC) (ABSTRACT? :TYPE BOOLEAN :OPTION-KEYWORD :ABSTRACT?) (META-ATTRIBUTES :TYPE (KEY-VALUE-LIST OF GENERALIZED-SYMBOL OBJECT) :ALLOCATION :DYNAMIC :OPTION-KEYWORD :META-ATTRIBUTES) (PROPERTIES :TYPE (LIST OF GENERALIZED-SYMBOL) :ALLOCATION :DYNAMIC :OPTION-KEYWORD :PROPERTIES)) :PUBLIC-METHODS ((NAME ((SELF RELATION)) :TYPE STRING (RETURN NULL)) (HOME-MODULE ((SELF RELATION)) :TYPE MODULE (RETURN NULL)) (ARITY ((SELF RELATION)) :TYPE INTEGER (RETURN NULL)) (PUBLIC? ((SELF RELATION)) :TYPE BOOLEAN (RETURN NULL)) (DIRECT-SUPERS ((SELF RELATION)) :TYPE (LIST OF RELATION) (RETURN NULL)) (ALL-SUPERS ((SELF RELATION)) :TYPE (LIST OF RELATION) (RETURN NULL)) (SLOTS ((SELF RELATION)) :TYPE (ITERATOR OF SLOT) (RETURN NULL))) :SLOTS ((STORED-ACTIVE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT NULL-BOOLEAN :OPTION-KEYWORD :ACTIVE?)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-RELATION-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "CLASS"
        (CONCATENATE
         "(DEFCLASS CLASS (RELATION) :PUBLIC-SLOTS ((CL-STRUCT? :TYPE BOOLEAN :INITIALLY FALSE) (MIXIN? :TYPE BOOLEAN :INITIALLY FALSE) (PRINT-FORM :TYPE OBJECT :ALLOCATION :DYNAMIC :OPTION-KEYWORD :PRINT-FORM)) :PUBLIC-METHODS ((NAME ((SELF CLASS)) :TYPE STRING (RETURN (SYMBOL-NAME (CLASS-TYPE SELF)))) (HOME-MODULE ((SELF CLASS)) :TYPE MODULE (RETURN (INTERNED-IN (CLASS-TYPE SELF)))) (ARITY ((SELF CLASS)) :TYPE INTEGER (RETURN 1)) (PUBLIC? ((SELF CLASS)) :TYPE BOOLEAN :STORAGE-SLOT CLASS-PUBLIC? (RETURN (CLASS-PUBLIC? SELF))) (ACTIVE? ((SELF CLASS)) :TYPE BOOLEAN :STORAGE-SLOT STORED-ACTIVE? (RETURN (OR (AND (DEFINED? (STORED-ACTIVE? SELF)) (STORED-ACTIVE? SELF)) (SUBTYPE-OF? (CLASS-TYPE SELF) @ACTIVE-OBJECT)))) (CREATOR ((SELF CLASS)) :TYPE SYMBOL :STORAGE-SLOT CLASS-CREATOR (RETURN (CLASS-CREATOR SELF))) (INITIALIZER ((SELF CLASS)) :TYPE SYMBOL :STORAGE-SLOT CLASS-INITIALIZER :INHERITS-THROUGH SUPER-CLASSES) (TERMINATOR ((SELF CLASS)) :TYPE SYMBOL :STORAGE-SLOT CLASS-TERMINATOR :INHERITS-THROUGH SUPER-CLASSES) (DESTRUCTOR ((SELF CLASS)) :TYPE SYMBOL :STORAGE-SLOT CLASS-DESTRUCTOR (RETURN (CLASS-DESTRUCTOR SELF))) (REQUIRED-SLOTS ((SELF CLASS)) :TYPE (LIST OF SYMBOL) :DOCUMENTATION \"Returns a list of names of required slots for 'self'.\" (RETURN (CLASS-REQUIRED-SLOT-NAMES SELF))) (PARAMETERS ((SELF CLASS)) :TYPE (LIST OF SYMBOL) :DOCUMENTATION \"Returns the list of parameters names of 'self'.\" :STORAGE-SLOT CLASS-PARAMETERS :INHERITS-THROUGH SUPER-CLASSES) (INITIAL-VALUE ((SELF CLASS)) :TYPE OBJECT :DOCUMENTATION \"Return an initial value for the class 'self'.\" :STORAGE-SLOT CLASS-INITIAL-VALUE :INHERITS-THROUGH SUPER-CLASSES) (EXTENSION ((SELF CLASS)) :TYPE CLASS-EXTENSION :DOCUMENTATION \"Return the nearest class extension that records instances
of the class 'self'.\" :STORAGE-SLOT CLASS-EXTENSION :INHERITS-THROUGH SUPER-CLASSES) (CL-NATIVE-TYPE ((SELF CLASS)) :TYPE STRING :STORAGE-SLOT CLASS-CL-NATIVE-TYPE (RETURN (CLASS-CL-NATIVE-TYPE SELF))) (CPP-NATIVE-TYPE ((SELF CLASS)) :TYPE STRING :STORAGE-SLOT CLASS-CPP-NATIVE-TYPE (RETURN (CLASS-CPP-NATIVE-TYPE SELF))) (IDL-NATIVE-TYPE ((SELF CLASS)) :TYPE STRING :STORAGE-SLOT CLASS-IDL-NATIVE-TYPE (RETURN (CLASS-CPP-NATIVE-TYPE SELF))) (JAVA-NATIVE-TYPE ((SELF CLASS)) :TYPE STRING :STORAGE-SLOT CLASS-JAVA-NATIVE-TYPE (RETURN (CLASS-JAVA-NATIVE-TYPE SELF)))) :SLOTS ((CLASS-TYPE :TYPE TYPE) (CLASS-ARITY :TYPE INTEGER :INITIALLY 1 :HARDWIRED? TRUE) (CLASS-DIRECT-SUPERS :TYPE (LIST OF TYPE) :ALLOCATION :EMBEDDED) (CLASS-DIRECT-SUBS :TYPE (LIST OF TYPE) :ALLOCATION :EMBEDDED) (CLASS-ALL-SUPER-CLASSES :TYPE (CONS OF CLASS) :INITIALLY NIL) (CLASS-ALL-SLOTS :TYPE (CONS OF SLOT)) (CLASS-LOCAL-SLOTS :TYPE (LIST OF SLOT)) (CLASS-SLOT-AND-METHOD-CACHE :TYPE (VECTOR OF SLOT)) (CLASS-ABSTRACT? :TYPE BOOLEAN :INITIALLY FALSE :RENAMES ABSTRACT?) (CLASS-MIXIN? :TYPE BOOLEAN :INITIALLY FALSE :RENAMES MIXIN?) (CLASS-COLLECTION? :TYPE BOOLEAN :INITIALLY FALSE) (CLASS-CL-STRUCT? :TYPE BOOLEAN :INITIALLY FALSE :RENAMES CL-STRUCT?) (CLASS-CL-STRUCT-SLOTS :TYPE (LIST OF STORAGE-SLOT) :ALLOCATION :DYNAMIC) (CLASS-PUBLIC? :TYPE BOOLEAN :INITIALLY TRUE :OPTION-KEYWORD :PUBLIC?) (CLASS-RECYCLE-METHOD :TYPE KEYWORD :ALLOCATION :DYNAMIC :DEFAULT :NONE :OPTION-KEYWORD :RECYCLE-METHOD) (CLASS-FINALIZED? :TYPE BOOLEAN :INITIALLY FALSE) (CLASS-SLOTS-FINALIZED? :TYPE BOOLEAN :INITIALLY FALSE) (CLASS-STRINGIFIED-SOURCE :TYPE STRING) (CLASS-PARAMETERS :TYPE (LIST OF SYMBOL) :ALLOCATION :DYNAMIC :DEFAULT NIL-LIST :OPTION-KEYWORD :PARAMETERS) (CLASS-CONSTRUCTOR-CODE :TYPE FUNCTION-CODE) (CLASS-SLOT-ACCESSOR-CODE :TYPE FUNCTION-CODE) (CLASS-CREATOR :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :CREATOR) (CLASS-INITIALIZER :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :INITIALIZER) (CLASS-TERMINATOR :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :TERMINATOR) (CLASS-DESTRUCTOR :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :DESTRUCTOR) (CLASS-DOCUMENTATION :ALLOCATION :DYNAMIC :RENAMES DOCUMENTATION :OPTION-KEYWORD :DOCU"
         "MENTATION) (CLASS-EXTENSION-NAME :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :EXTENSION) (CLASS-EXTENSION :TYPE CLASS-EXTENSION :ALLOCATION :DYNAMIC) (CLASS-REQUIRED-SLOT-NAMES :TYPE (LIST OF SYMBOL) :ALLOCATION :DYNAMIC :DEFAULT NIL-LIST) (CLASS-GUARD-CONSTRUCTOR-DEMONS :TYPE (LIST OF DEMON) :ALLOCATION :DYNAMIC) (CLASS-CONSTRUCTOR-DEMONS :TYPE (LIST OF DEMON) :ALLOCATION :DYNAMIC) (CLASS-GUARD-DESTRUCTOR-DEMONS :TYPE (LIST OF DEMON) :ALLOCATION :DYNAMIC) (CLASS-DESTRUCTOR-DEMONS :TYPE (LIST OF DEMON) :ALLOCATION :DYNAMIC) (CLASS-INITIAL-VALUE :TYPE OBJECT :ALLOCATION :DYNAMIC :OPTION-KEYWORD :INITIAL-VALUE) (CLASS-PRINT-FORM :TYPE OBJECT :RENAMES PRINT-FORM :OPTION-KEYWORD :PRINT-FORM) (CLASS-KEY :TYPE (LIST OF SLOT) :ALLOCATION :DYNAMIC :DEFAULT NIL-LIST) (CLASS-SYNONYMS :TYPE (LIST OF TYPE) :ALLOCATION :DYNAMIC :DEFAULT NIL-LIST :OPTION-KEYWORD :SYNONYMS) (CLASS-IS-LINK :TYPE TYPE :ALLOCATION :DYNAMIC) (CLASS-INVERSE-IS-LINK :TYPE CLASS :ALLOCATION :DYNAMIC) (CLASS-CL-NATIVE-TYPE :TYPE STRING :ALLOCATION :DYNAMIC :OPTION-KEYWORD :CL-NATIVE-TYPE) (CLASS-CPP-NATIVE-TYPE :TYPE STRING :ALLOCATION :DYNAMIC :OPTION-KEYWORD :CPP-NATIVE-TYPE) (CLASS-JAVA-NATIVE-TYPE :TYPE STRING :ALLOCATION :DYNAMIC :OPTION-KEYWORD :JAVA-NATIVE-TYPE) (CLASS-IDL-NATIVE-TYPE :TYPE STRING :ALLOCATION :DYNAMIC :OPTION-KEYWORD :IDL-NATIVE-TYPE) (CLASS-MARKED? :TYPE BOOLEAN) (CLASS-PROTOTYPE :TYPE OBJECT :ALLOCATION :DYNAMIC) (CLASS-TAXONOMY-NODE :TYPE TAXONOMY-NODE)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|C|\" (CHOOSE (DEFINED? (CLASS-TYPE SELF)) (SYMBOL-NAME (CLASS-TYPE SELF)) \"??\")))"))))
     (CL:SETQ *HARDWIRED-CLASS-ARITY-ON-CLASS* 1)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CLASS))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CLASS-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "POLYMORPHIC-RELATION"
        "(DEFCLASS POLYMORPHIC-RELATION (RELATION) :ABSTRACT? TRUE :SLOTS ((SLOT-DIRECT-EQUIVALENT :TYPE SLOT)) :PUBLIC-METHODS ((OWNER ((SELF POLYMORPHIC-RELATION)) :TYPE TYPE (RETURN NULL)) (RENAMES ((SELF POLYMORPHIC-RELATION)) :TYPE SYMBOL (RETURN NULL)) (ACTIVE? ((SELF POLYMORPHIC-RELATION)) :TYPE BOOLEAN :STORAGE-SLOT STORED-ACTIVE? :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"True if 'self' or a superslot of 'self' is marked active.\")))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-POLYMORPHIC-RELATION-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "SLOT"
        "(DEFCLASS SLOT (POLYMORPHIC-RELATION) :ABSTRACT? TRUE :PUBLIC-METHODS ((NAME ((SELF SLOT)) :TYPE STRING (RETURN (SYMBOL-NAME (SLOT-NAME SELF)))) (HOME-MODULE ((SELF SLOT)) :TYPE MODULE (RETURN (INTERNED-IN (SLOT-NAME SELF)))) (TYPE ((SELF SLOT)) :TYPE TYPE :STORAGE-SLOT SLOT-BASE-TYPE :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"The type of a storage slot is its base type.\") (TYPE-SPECIFIER ((SELF SLOT)) :TYPE TYPE-SPEC :DOCUMENTATION \"If 'self' has a complex type return its
type specifier, otherwise, return 'type' of 'self'.\" (LET ((TSPEC (SLOT-TYPE-SPECIFIER SELF))) (RETURN (CHOOSE (DEFINED? TSPEC) TSPEC (TYPE SELF))))) (OWNER ((SELF SLOT)) :TYPE TYPE :STORAGE-SLOT SLOT-OWNER (RETURN (SLOT-OWNER SELF))) (RENAMES ((SELF SLOT)) :TYPE SYMBOL :STORAGE-SLOT SLOT-RENAMES (RETURN (SLOT-RENAMES SELF))) (SINGLE-VALUED? ((SELF SLOT)) :TYPE BOOLEAN :DOCUMENTATION \"True if slot values are not collections.\" (RETURN (NOT (SUBTYPE-OF? (SLOT-BASE-TYPE SELF) @COLLECTION)))) (CLOSURE-ASSUMPTION ((SELF SLOT)) :TYPE KEYWORD :STORAGE-SLOT SLOT-CLOSURE-ASSUMPTION :INHERITS-THROUGH EQUIVALENT-SLOT)) :PUBLIC-SLOTS ((INVERSE :TYPE SLOT :ALLOCATION :DYNAMIC)) :SLOTS ((SLOT-NAME :TYPE SYMBOL) (SLOT-OWNER :TYPE TYPE) (SLOT-BASE-TYPE :TYPE TYPE) (SLOT-TYPE-SPECIFIER :TYPE COMPOUND-TYPE-SPECIFIER :ALLOCATION :DYNAMIC) (SLOT-SLOTREF :TYPE SLOTREF) (SLOT-PUBLIC? :TYPE BOOLEAN :INITIALLY FALSE :OPTION-KEYWORD :PUBLIC?) (SLOT-INVERSE :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :INVERSE) (SLOT-RENAMES :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :RENAMES) (SLOT-RENAMED? :TYPE BOOLEAN :INITIALLY FALSE) (SLOT-DOCUMENTATION :TYPE STRING :ALLOCATION :DYNAMIC :RENAMES DOCUMENTATION :OPTION-KEYWORD :DOCUMENTATION) (SLOT-EXTERNAL? :TYPE BOOLEAN :INITIALLY FALSE) (SLOT-MARKED? :TYPE BOOLEAN) (SLOT-AUXILIARY? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :OPTION-KEYWORD :AUXILIARY?) (SLOT-DIRECT-SUPERS :TYPE (LIST OF SLOT) :ALLOCATION :DYNAMIC) (SLOT-DIRECT-SUBS :TYPE (LIST OF SLOT) :ALLOCATION :DYNAMIC) (SLOT-CLOSURE-ASSUMPTION :TYPE KEYWORD :ALLOCATION :DYNAMIC)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|S|\" (SYMBOL-NAME (SLOT-OWNER SELF)) \".\" (SYMBOL-NAME (SLOT-NAME SELF))))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SLOT-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "STORAGE-SLOT"
        "(DEFCLASS STORAGE-SLOT (SLOT) :PUBLIC-METHODS ((INITIALLY ((SELF STORAGE-SLOT)) :TYPE OBJECT) (ALLOCATION ((SELF STORAGE-SLOT)) :TYPE KEYWORD :STORAGE-SLOT SLOT-ALLOCATION :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"Return the most specific :allocation facet, or
:instance if all inherited values are NULL.\") (DEFAULT-FORM ((SELF STORAGE-SLOT)) :TYPE OBJECT :STORAGE-SLOT SLOT-DEFAULT-EXPRESSION :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"Returns the current value of default expression when the
slot has not been assigned a value.\") (REQUIRED? ((SELF STORAGE-SLOT)) :TYPE BOOLEAN :STORAGE-SLOT SLOT-REQUIRED? :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"True if a value must be assigned to this slot at
creation time.\") (COMPONENT? ((SELF STORAGE-SLOT)) :TYPE BOOLEAN :STORAGE-SLOT SLOT-COMPONENT? :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"True if fillers of this slot are components of the
owner slot, and therefore should be deleted if the owner is deleted.\") (READER ((SELF STORAGE-SLOT)) :TYPE SYMBOL :STORAGE-SLOT SLOT-READER :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"Name of a method called to read the value of the slot
'self'.\") (WRITER ((SELF STORAGE-SLOT)) :TYPE SYMBOL :STORAGE-SLOT SLOT-WRITER :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"Name of a method called to write the value of the slot
'self'.\")) :SLOTS ((SLOT-INITIAL-VALUE :TYPE OBJECT :ALLOCATION :DYNAMIC :OPTION-KEYWORD :INITIALLY) (SLOT-ALLOCATION :TYPE KEYWORD :ALLOCATION :DYNAMIC :DEFAULT :INSTANCE :OPTION-KEYWORD :ALLOCATION) (SLOT-DEFAULT-EXPRESSION :TYPE OBJECT :ALLOCATION :DYNAMIC :OPTION-KEYWORD :DEFAULT) (SLOT-GUARD-DEMONS :TYPE (LIST OF DEMON) :ALLOCATION :DYNAMIC) (SLOT-DEMONS :TYPE (LIST OF DEMON) :ALLOCATION :DYNAMIC) (SLOT-REQUIRED? :TYPE BOOLEAN :OPTION-KEYWORD :REQUIRED?) (SLOT-COMPONENT? :TYPE BOOLEAN :OPTION-KEYWORD :COMPONENT?) (SLOT-READ-ONLY? :TYPE BOOLEAN :OPTION-KEYWORD :READ-ONLY?) (SLOT-HARDWIRED? :TYPE BOOLEAN :OPTION-KEYWORD :HARDWIRED?) (SLOT-CONTEXT-SENSITIVE? :TYPE BOOLEAN :OPTION-KEYWORD :CONTEXT-SENSITIVE?) (SLOT-READER :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :READER) (SLOT-WRITER :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :WRITER) (SLOT-ACCESSOR-METHODS :TYPE (LIST OF METHOD-SLOT) :ALLOCATION :DYNAMIC) (SLOT-OPTION-KEYWORD :TYPE KEYWORD :ALLOCATION :DYNAMIC :OPTION-KEYWORD :OPTION-KEYWORD) (SLOT-OPTION-HANDLER :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :OPTION-HANDLER)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-STORAGE-SLOT))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-STORAGE-SLOT-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "METHOD-SLOT"
        "(DEFCLASS METHOD-SLOT (SLOT) :SYNONYMS (FUNCTION) :PUBLIC-SLOTS ((STORAGE-SLOT :TYPE SYMBOL :ALLOCATION :DYNAMIC)) :PUBLIC-METHODS ((SETTER? ((SELF METHOD-SLOT)) :TYPE BOOLEAN :STORAGE-SLOT METHOD-SETTER? (RETURN (METHOD-SETTER? SELF)))) :SLOTS ((METHOD-SETTER? :TYPE BOOLEAN) (METHOD-DOCUMENTATION :TYPE STRING :ALLOCATION :DYNAMIC :RENAMES DOCUMENTATION) (METHOD-PARAMETER-NAMES :TYPE (LIST OF SYMBOL) :DEFAULT NIL-LIST :COMPONENT? TRUE) (METHOD-PARAMETER-TYPE-SPECIFIERS :TYPE (LIST OF TYPE-SPEC) :DEFAULT NIL-LIST :COMPONENT? TRUE) (METHOD-PARAMETER-DIRECTIONS :TYPE (LIST OF SYMBOL) :DEFAULT NIL-LIST :COMPONENT? TRUE :ALLOCATION :DYNAMIC) (METHOD-RETURN-TYPE-SPECIFIERS :TYPE (LIST OF TYPE-SPEC) :DEFAULT NIL-LIST :COMPONENT? TRUE) (METHOD-STRINGIFIED-SOURCE :TYPE STRING) (METHOD-CODE :TYPE METHOD-CODE) (FUNCTION-CODE :TYPE FUNCTION-CODE) (METHOD-FUNCTION? :TYPE BOOLEAN) (METHOD-VARIABLE-ARGUMENTS? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT FALSE) (METHOD-BODY-ARGUMENT? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT FALSE) (METHOD-AUXILIARY? :RENAMES SLOT-AUXILIARY?) (METHOD-NATIVE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT FALSE) (METHOD-GLOBALLY-INLINE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT FALSE) (METHOD-INLINED-FUNCTIONS :TYPE (LIST OF SYMBOL) :ALLOCATION :DYNAMIC :DEFAULT NIL-LIST) (METHOD-STORAGE-SLOT :TYPE SYMBOL :ALLOCATION :DYNAMIC :RENAMES STORAGE-SLOT) (METHOD-INHERITS-THROUGH :TYPE SYMBOL :ALLOCATION :DYNAMIC) (METHOD-COMMAND? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT FALSE) (METHOD-EVALUATE-ARGUMENTS? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT TRUE) (METHOD-LISP-MACRO? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT NULL-BOOLEAN) (EVALUATOR-WRAPPER-CODE :TYPE FUNCTION-CODE :ALLOCATION :DYNAMIC)) :PRINT-FORM (IF (METHOD-FUNCTION? SELF) (PRINT-NATIVE-STREAM STREAM \"|F|\" (SYMBOL-NAME (SLOT-NAME SELF))) (PRINT-NATIVE-STREAM STREAM \"|M|\" (SYMBOL-NAME (SLOT-OWNER SELF)) \".\" (SYMBOL-NAME (SLOT-NAME SELF)))))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-METHOD-SLOT))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-METHOD-SLOT-SLOT-VALUE)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "COMPOUND-TYPE-SPECIFIER"
     "(DEFCLASS COMPOUND-TYPE-SPECIFIER (STANDARD-OBJECT) :ABSTRACT? TRUE :PUBLIC? FALSE :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|TS|\" (YIELD-TYPE-SPEC-TREE SELF)))")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "PARAMETRIC-TYPE-SPECIFIER"
        "(DEFCLASS PARAMETRIC-TYPE-SPECIFIER (COMPOUND-TYPE-SPECIFIER) :SLOTS ((SPECIFIER-BASE-TYPE :TYPE TYPE) (SPECIFIER-PARAMETER-TYPES :TYPE (LIST OF TYPE-SPEC) :ALLOCATION :EMBEDDED) (SPECIFIER-SEQUENCE-SIZE :TYPE INTEGER)) :CREATOR MAKE-PARAMETRIC-TYPE-SPECIFIER)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-PARAMETRIC-TYPE-SPECIFIER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-PARAMETRIC-TYPE-SPECIFIER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRANSIENT-TYPE-SPECIFIER"
        "(DEFCLASS TRANSIENT-TYPE-SPECIFIER (PARAMETRIC-TYPE-SPECIFIER TRANSIENT-MIXIN) :RECYCLE-METHOD :SWEEP-LIST :TERMINATOR TERMINATE-TRANSIENT-TYPE-SPECIFIER?)")))
     (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* TRUE)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRANSIENT-TYPE-SPECIFIER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TRANSIENT-TYPE-SPECIFIER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "ANCHORED-TYPE-SPECIFIER"
        "(DEFCLASS ANCHORED-TYPE-SPECIFIER (COMPOUND-TYPE-SPECIFIER) :SLOTS ((SPECIFIER-PARAMETER-NAME :TYPE SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-ANCHORED-TYPE-SPECIFIER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-ANCHORED-TYPE-SPECIFIER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TABLE"
        "(DEFCLASS TABLE (SLOT) :PARAMETERS ((ANY-VALUE :TYPE BOOLEAN)) :SLOTS ((TUPLE-DOMAINS :TYPE (LIST OF TYPE-SPEC)) (VARIABLE-ARITY? :TYPE BOOLEAN :ALLOCATION :DYNAMIC)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|T|\" (SYMBOL-NAME (SLOT-NAME SELF))))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TABLE))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TABLE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "GLOBAL-VARIABLE"
        "(DEFCLASS GLOBAL-VARIABLE (MAPPABLE-OBJECT) :PUBLIC-SLOTS ((DOCUMENTATION :TYPE STRING)) :PUBLIC-METHODS ((NAME ((SELF GLOBAL-VARIABLE)) :TYPE STRING (RETURN (SYMBOL-NAME (VARIABLE-NAME SELF)))) (TYPE ((SELF GLOBAL-VARIABLE)) :TYPE TYPE :STORAGE-SLOT VARIABLE-TYPE (RETURN (VARIABLE-TYPE SELF)))) :SLOTS ((VARIABLE-NAME :TYPE SYMBOL) (VARIABLE-TYPE :TYPE TYPE) (VARIABLE-TYPE-SPECIFIER :TYPE TYPE-SPEC :ALLOCATION :DYNAMIC) (VARIABLE-SPECIAL? :TYPE BOOLEAN) (VARIABLE-CONSTANT? :TYPE BOOLEAN) (VARIABLE-PUBLIC? :TYPE BOOLEAN) (VARIABLE-AUXILIARY? :TYPE BOOLEAN) (VARIABLE-GET-VALUE-CODE :TYPE FUNCTION-CODE) (VARIABLE-SET-VALUE-CODE :TYPE FUNCTION-CODE) (VARIABLE-VALUE-STACK :TYPE LIST) (VARIABLE-DOCUMENTATION :TYPE STRING :RENAMES DOCUMENTATION) (VARIABLE-STRINGIFIED-SOURCE :TYPE STRING)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-GLOBAL-VARIABLE))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-GLOBAL-VARIABLE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "QUOTED-EXPRESSION"
        "(DEFCLASS QUOTED-EXPRESSION (STANDARD-OBJECT) :SLOTS ((QUOTATION-TABLE-OFFSET :TYPE INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-QUOTED-EXPRESSION))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-QUOTED-EXPRESSION-SLOT-VALUE)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "VOID"
     "(DEFCLASS VOID () :ABSTRACT? TRUE :JAVA-NATIVE-TYPE \"void\" :IDL-NATIVE-TYPE \"void\" :CPP-NATIVE-TYPE \"void\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "UNKNOWN"
     "(DEFCLASS UNKNOWN () :ABSTRACT? TRUE :CPP-NATIVE-TYPE \"unknown\" :IDL-NATIVE-TYPE \"unknown\" :JAVA-NATIVE-TYPE \"unknown\" :SLOTS ((UNKNOWN-SLOT :TYPE UNKNOWN)))")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "CONTEXT"
        "(DEFCLASS CONTEXT (STANDARD-OBJECT DYNAMIC-SLOTS-MIXIN) :ABSTRACT? TRUE :SLOTS ((CHILD-CONTEXTS :TYPE (LIST OF CONTEXT) :ALLOCATION :EMBEDDED) (ALL-SUPER-CONTEXTS :TYPE (CONS OF CONTEXT)) (BASE-MODULE :TYPE MODULE) (CONTEXT-NUMBER :TYPE INTEGER)) :METHODS ((CONTEXT-NAME ((SELF CONTEXT)) :TYPE STRING (LET ((AUX SELF)) (TYPECASE AUX (MODULE (RETURN (MODULE-NAME AUX))) (WORLD (RETURN (WORLD-NAME AUX)))))) (PARENT-CONTEXTS ((SELF CONTEXT)) :TYPE (ITERATOR OF CONTEXT))) :PRINT-FORM (PRINT-CONTEXT SELF STREAM))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CONTEXT-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "MODULE"
        "(DEFCLASS MODULE (CONTEXT) :PUBLIC-METHODS ((NATIVE-PACKAGE ((SELF MODULE)) :TYPE STRING :STORAGE-SLOT MODULE-NATIVE-PACKAGE :INHERITS-THROUGH PARENT-MODULES)) :PUBLIC-SLOTS ((PARENT-MODULES :TYPE (LIST OF MODULE) :ALLOCATION :EMBEDDED) (DOCUMENTATION :TYPE STRING) (REQUIRES :TYPE (LIST OF MODULE)) (USES :TYPE (LIST OF MODULE) :ALLOCATION :EMBEDDED) (USED-BY :TYPE (LIST OF MODULE) :ALLOCATION :EMBEDDED) (SHADOWED-SURROGATES :TYPE (LIST OF SURROGATE) :ALLOCATION :DYNAMIC) (MODULE-NATIVE-PACKAGE :TYPE STRING :DEFAULT \"STELLA\") (DIRECTORY-FILE :TYPE FILE-NAME) (CODE-FILES :TYPE (LIST OF STRING-WRAPPER) :ALLOCATION :EMBEDDED) (DEFINITIONS-FILE :TYPE FILE-NAME) (LOGIC-DIALECT :TYPE KEYWORD :ALLOCATION :DYNAMIC :DEFAULT :KIF) (OPEN-WORLD-ASSUMPTION? :TYPE BOOLEAN :INITIALLY FALSE) (CASE-SENSITIVE? :TYPE BOOLEAN :INITIALLY FALSE) (CLEARABLE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT TRUE :OPTION-KEYWORD :CLEARABLE?)) :SLOTS ((MODULE-NAME :TYPE STRING :ALLOCATION :INSTANCE) (MODULE-FULL-NAME :TYPE STRING) (MODULE-STRINGIFIED-SOURCE :TYPE STRING) (STRINGIFIED-OPTIONS :TYPE STRING) (CARDINAL-MODULE :TYPE MODULE) (SYMBOL-OFFSET-TABLE :TYPE STRING-TO-INTEGER-HASH-TABLE) (SURROGATE-OFFSET-TABLE :TYPE STRING-TO-INTEGER-HASH-TABLE) (INDEXICAL-OFFSET-TABLE :TYPE STRING-TO-INTEGER-HASH-TABLE) (ELABORATED-WORLD :TYPE WORLD)) :PUBLIC-METHODS ((NAME ((SELF MODULE)) :TYPE STRING (RETURN (MODULE-NAME SELF))) (PARENT-MODULE ((SELF MODULE)) :TYPE MODULE (RETURN (POP (PARENT-CONTEXTS SELF)))) (CLOSED-WORLD-ASSUMPTION? ((SELF MODULE)) :TYPE BOOLEAN (RETURN (NOT (OPEN-WORLD-ASSUMPTION? SELF))))))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-MODULE))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-MODULE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "WORLD"
        "(DEFCLASS WORLD (CONTEXT) :SLOTS ((PARENT-CONTEXT :TYPE CONTEXT) (CHILD-CONTEXTS :TYPE (LIST OF WORLD) :ALLOCATION :EMBEDDED) (WORLD-NAME :TYPE STRING :ALLOCATION :DYNAMIC)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-WORLD))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-WORLD-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "CS-VALUE"
        "(DEFCLASS CS-VALUE (KEY-VALUE-LIST) :DOCUMENTATION \"Contextualized value.  Contains a sorted kv-cons list indexed
by context. The kv-cons list is never null.  Newer (higher numbered) contexts
appear first.\" :PARAMETERS ((ANY-KEY :TYPE CONTEXT) (ANY-VALUE :TYPE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CS-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "INTERVAL"
        "(DEFCLASS INTERVAL (STANDARD-OBJECT) :SLOTS ((LOWER-BOUND :TYPE INTEGER) (UPPER-BOUND :TYPE INTEGER)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"[\" (LOWER-BOUND SELF) \",\" (UPPER-BOUND SELF) \"]\"))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INTERVAL))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-INTERVAL-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TAXONOMY-NODE"
        "(DEFCLASS TAXONOMY-NODE (STANDARD-OBJECT) :SLOTS ((PARENTS :TYPE (CONS OF TAXONOMY-NODE) :INITIALLY NIL) (TREE-CHILDREN :TYPE (CONS OF TAXONOMY-NODE) :INITIALLY NIL) (CHILDREN :TYPE (CONS OF TAXONOMY-NODE) :INITIALLY NIL) (FIRST-INTERVAL-LOWER-BOUND :TYPE INTEGER :INITIALLY -1) (FIRST-INTERVAL-UPPER-BOUND :TYPE INTEGER :INITIALLY -1) (INITIAL-INTERVAL :TYPE INTERVAL) (INTERVALS :TYPE (CONS OF INTERVAL) :INITIALLY NIL) (TOTAL-ANCESTORS :TYPE INTEGER :INITIALLY 1) (LABEL :TYPE INTEGER) (NATIVE-OBJECT :TYPE OBJECT)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|TN|\" (LABEL SELF) \" \" (INTERVALS SELF) \" \" (NATIVE-OBJECT SELF)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TAXONOMY-NODE))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TAXONOMY-NODE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TAXONOMY-GRAPH"
        "(DEFCLASS TAXONOMY-GRAPH (STANDARD-OBJECT) :SLOTS ((INCREMENTAL-MODE? :TYPE BOOLEAN :INITIALLY FALSE) (RENUMBER-IF-OUT-OF-NUMBERS? :TYPE BOOLEAN :INITIALLY FALSE) (LARGEST-POSTORDER-NUMBER :TYPE INTEGER) (ROOTS :TYPE (CONS OF TAXONOMY-NODE) :INITIALLY NIL) (BROKEN-LINKS :TYPE (CONS OF (CONS OF TAXONOMY-NODE)) :INITIALLY NIL)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|TG|\" (ROOTS SELF)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TAXONOMY-GRAPH))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TAXONOMY-GRAPH-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "EXCEPTION"
        "(DEFCLASS EXCEPTION (STANDARD-OBJECT))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-EXCEPTION)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "NATIVE-ENVIRONMENT-POINTER"
     "(DEFCLASS NATIVE-ENVIRONMENT-POINTER () :CPP-NATIVE-TYPE \"jump_buffer\" :CL-NATIVE-TYPE \"KEYWORD\")")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "STELLA-EXCEPTION"
        "(DEFCLASS STELLA-EXCEPTION (EXCEPTION))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-STELLA-EXCEPTION)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "READ-EXCEPTION"
        "(DEFCLASS READ-EXCEPTION (STELLA-EXCEPTION))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-READ-EXCEPTION)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "UNHANDLED-EXCEPTION"
        "(DEFCLASS UNHANDLED-EXCEPTION (EXCEPTION))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-UNHANDLED-EXCEPTION)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "LITERAL"
     "(DEFCLASS LITERAL (NON-OBJECT) :ABSTRACT? TRUE)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "NUMBER"
     "(DEFCLASS NUMBER (LITERAL) :ABSTRACT? TRUE)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "INTEGER"
     "(DEFCLASS INTEGER (NUMBER) :CL-NATIVE-TYPE \"INTEGER\" :CPP-NATIVE-TYPE \"int\" :IDL-NATIVE-TYPE \"long\" :JAVA-NATIVE-TYPE \"int\" :INITIAL-VALUE NULL-INTEGER :EQUALITY-TEST EQL?)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "FLOAT"
     "(DEFCLASS FLOAT (NUMBER) :CL-NATIVE-TYPE \"FLOAT\" :CPP-NATIVE-TYPE \"double\" :IDL-NATIVE-TYPE \"double\" :JAVA-NATIVE-TYPE \"double\" :INITIAL-VALUE NULL-FLOAT :EQUALITY-TEST EQL?)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "STRING"
     "(DEFCLASS STRING (LITERAL) :SYNONYMS (FILE-NAME) :CL-NATIVE-TYPE \"STRING\" :IDL-NATIVE-TYPE \"string\" :JAVA-NATIVE-TYPE \"String\" :CPP-NATIVE-TYPE \"char*\" :EQUALITY-TEST STRING-EQL?)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "CHARACTER"
     "(DEFCLASS CHARACTER (LITERAL) :CL-NATIVE-TYPE \"CHARACTER\" :CPP-NATIVE-TYPE \"char\" :IDL-NATIVE-TYPE \"char\" :JAVA-NATIVE-TYPE \"char\" :INITIAL-VALUE NULL-CHARACTER)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "SHORT-INTEGER"
     "(DEFCLASS SHORT-INTEGER (INTEGER) :CL-NATIVE-TYPE \"INTEGER\" :CPP-NATIVE-TYPE \"short int\" :IDL-NATIVE-TYPE \"short int\" :INITIAL-VALUE NULL-SHORT-INTEGER :EQUALITY-TEST EQL?)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "LONG-INTEGER"
     "(DEFCLASS LONG-INTEGER (INTEGER) :CL-NATIVE-TYPE \"INTEGER\" :CPP-NATIVE-TYPE \"long int\" :IDL-NATIVE-TYPE \"long int\" :INITIAL-VALUE NULL-LONG-INTEGER :EQUALITY-TEST EQL?)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "UNSIGNED-SHORT-INTEGER"
     "(DEFCLASS UNSIGNED-SHORT-INTEGER (INTEGER) :CL-NATIVE-TYPE \"INTEGER\" :CPP-NATIVE-TYPE \"unsigned short int\" :IDL-NATIVE-TYPE \"unsigned short int\" :INITIAL-VALUE NULL-UNSIGNED-SHORT-INTEGER :EQUALITY-TEST EQL?)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "UNSIGNED-LONG-INTEGER"
     "(DEFCLASS UNSIGNED-LONG-INTEGER (INTEGER) :CL-NATIVE-TYPE \"INTEGER\" :IDL-NATIVE-TYPE \"unsigned long int\" :CPP-NATIVE-TYPE \"unsigned long int\" :INITIAL-VALUE NULL-UNSIGNED-LONG-INTEGER :EQUALITY-TEST EQL?)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "SINGLE-FLOAT"
     "(DEFCLASS SINGLE-FLOAT (FLOAT) :CL-NATIVE-TYPE \"FLOAT\" :JAVA-NATIVE-TYPE \"float\" :IDL-NATIVE-TYPE \"float\" :CPP-NATIVE-TYPE \"float\" :INITIAL-VALUE NULL-SINGLE-FLOAT :EQUALITY-TEST EQL?)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "DOUBLE-FLOAT"
     "(DEFCLASS DOUBLE-FLOAT (FLOAT) :CL-NATIVE-TYPE \"FLOAT\" :CPP-NATIVE-TYPE \"double\" :JAVA-NATIVE-TYPE \"double\" :IDL-NATIVE-TYPE \"double\" :INITIAL-VALUE NULL-DOUBLE-FLOAT :EQUALITY-TEST EQL?)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "BYTE"
     "(DEFCLASS BYTE (CHARACTER) :CL-NATIVE-TYPE \"CHARACTER\" :CPP-NATIVE-TYPE \"char\" :IDL-NATIVE-TYPE \"char\" :JAVA-NATIVE-TYPE \"char\" :INITIAL-VALUE NULL-BYTE :EQUALITY-TEST EQL?)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "OCTET"
     "(DEFCLASS OCTET (BYTE) :CL-NATIVE-TYPE \"FIXNUM\" :CPP-NATIVE-TYPE \"octet\" :IDL-NATIVE-TYPE \"octet\" :JAVA-NATIVE-TYPE \"octet\" :INITIAL-VALUE NULL-OCTET :EQUALITY-TEST EQL?)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "WRAPPER"
     "(DEFCLASS WRAPPER (OBJECT) :SLOTS ((WRAPPER-VALUE :TYPE UNKNOWN :REQUIRED? TRUE)) :KEY (WRAPPER-VALUE) :PUBLIC? FALSE :ABSTRACT? TRUE :TERMINATOR TERMINATE-WRAPPER?)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "LITERAL-WRAPPER"
     "(DEFCLASS LITERAL-WRAPPER (WRAPPER) :ABSTRACT? TRUE)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "NUMBER-WRAPPER"
     "(DEFCLASS NUMBER-WRAPPER (LITERAL-WRAPPER) :ABSTRACT? TRUE)")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "INTEGER-WRAPPER"
        "(DEFCLASS INTEGER-WRAPPER (NUMBER-WRAPPER) :SLOTS ((WRAPPER-VALUE :TYPE INTEGER)) :PRINT-FORM (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM (WRAPPER-VALUE SELF)) (PRINT-NATIVE-STREAM STREAM (CHOOSE (TRANSIENT-OBJECT? SELF) \"!L!\" \"|L|\") (WRAPPER-VALUE SELF))) :RECYCLE-METHOD :FREE-LIST)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INTEGER-WRAPPER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-INTEGER-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "FLOAT-WRAPPER"
        "(DEFCLASS FLOAT-WRAPPER (NUMBER-WRAPPER) :SLOTS ((WRAPPER-VALUE :TYPE FLOAT)) :PRINT-FORM (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM (WRAPPER-VALUE SELF)) (PRINT-NATIVE-STREAM STREAM (CHOOSE (TRANSIENT-OBJECT? SELF) \"!L!\" \"|L|\") (WRAPPER-VALUE SELF))) :RECYCLE-METHOD :FREE-LIST)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-FLOAT-WRAPPER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-FLOAT-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "STRING-WRAPPER"
        "(DEFCLASS STRING-WRAPPER (LITERAL-WRAPPER) :SLOTS ((WRAPPER-VALUE :TYPE STRING)) :PRINT-FORM (LET ((VALUE (WRAPPER-VALUE SELF))) (IF *PRINTREADABLY?* (PRINT-STRING-READABLY VALUE STREAM) (IF (DEFINED? VALUE) (PRINT-NATIVE-STREAM STREAM (CHOOSE (TRANSIENT-OBJECT? SELF) \"!L!\" \"|L|\") #\\\" VALUE #\\\") (PRINT-NATIVE-STREAM STREAM (CHOOSE (TRANSIENT-OBJECT? SELF) \"!L!\" \"|L|\") \"NULL-STRING\")))) :RECYCLE-METHOD :FREE-LIST)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-STRING-WRAPPER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-STRING-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "CHARACTER-WRAPPER"
        "(DEFCLASS CHARACTER-WRAPPER (LITERAL-WRAPPER) :SLOTS ((WRAPPER-VALUE :TYPE CHARACTER)) :PRINT-FORM (IF *PRINTREADABLY?* (PRINT-CHARACTER (WRAPPER-VALUE SELF) STREAM) (PROGN (PRINT-NATIVE-STREAM STREAM (CHOOSE (TRANSIENT-OBJECT? SELF) \"!L!\" \"|L|\")) (PRINT-CHARACTER (WRAPPER-VALUE SELF) STREAM))) :RECYCLE-METHOD :FREE-LIST)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CHARACTER-WRAPPER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CHARACTER-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "BOOLEAN-WRAPPER"
        "(DEFCLASS BOOLEAN-WRAPPER (LITERAL-WRAPPER) :SLOTS ((WRAPPER-VALUE :TYPE BOOLEAN :ALLOCATION :INSTANCE)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM (CHOOSE *PRINTREADABLY?* \"\" \"|L|\") (CHOOSE (NULL? (WRAPPER-VALUE SELF)) (QUOTE NULL-BOOLEAN) (CHOOSE (WRAPPER-VALUE SELF) (QUOTE TRUE) (QUOTE FALSE)))))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-BOOLEAN-WRAPPER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-BOOLEAN-WRAPPER-SLOT-VALUE)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "CODE-WRAPPER"
     "(DEFCLASS CODE-WRAPPER (WRAPPER) :ABSTRACT? TRUE)")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "FUNCTION-CODE-WRAPPER"
        "(DEFCLASS FUNCTION-CODE-WRAPPER (CODE-WRAPPER) :SLOTS ((WRAPPER-VALUE :TYPE FUNCTION-CODE)) :RECYCLE-METHOD :FREE-LIST)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-FUNCTION-CODE-WRAPPER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-FUNCTION-CODE-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "METHOD-CODE-WRAPPER"
        "(DEFCLASS METHOD-CODE-WRAPPER (CODE-WRAPPER) :SLOTS ((WRAPPER-VALUE :TYPE METHOD-CODE)) :RECYCLE-METHOD :FREE-LIST)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-METHOD-CODE-WRAPPER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-METHOD-CODE-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRANSIENT-INTEGER-WRAPPER"
        "(DEFCLASS TRANSIENT-INTEGER-WRAPPER (INTEGER-WRAPPER TRANSIENT-MIXIN) :RECYCLE-METHOD :SWEEP-LIST)")))
     (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* TRUE)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRANSIENT-INTEGER-WRAPPER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TRANSIENT-INTEGER-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRANSIENT-FLOAT-WRAPPER"
        "(DEFCLASS TRANSIENT-FLOAT-WRAPPER (FLOAT-WRAPPER TRANSIENT-MIXIN) :RECYCLE-METHOD :SWEEP-LIST)")))
     (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* TRUE)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRANSIENT-FLOAT-WRAPPER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TRANSIENT-FLOAT-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRANSIENT-STRING-WRAPPER"
        "(DEFCLASS TRANSIENT-STRING-WRAPPER (STRING-WRAPPER TRANSIENT-MIXIN) :RECYCLE-METHOD :FREE-AND-SWEEP-LIST)")))
     (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* TRUE)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRANSIENT-STRING-WRAPPER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TRANSIENT-STRING-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRANSIENT-CHARACTER-WRAPPER"
        "(DEFCLASS TRANSIENT-CHARACTER-WRAPPER (CHARACTER-WRAPPER TRANSIENT-MIXIN) :RECYCLE-METHOD :SWEEP-LIST)")))
     (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* TRUE)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRANSIENT-CHARACTER-WRAPPER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TRANSIENT-CHARACTER-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRANSIENT-FUNCTION-CODE-WRAPPER"
        "(DEFCLASS TRANSIENT-FUNCTION-CODE-WRAPPER (FUNCTION-CODE-WRAPPER TRANSIENT-MIXIN) :RECYCLE-METHOD :SWEEP-LIST)")))
     (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* TRUE)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRANSIENT-FUNCTION-CODE-WRAPPER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TRANSIENT-FUNCTION-CODE-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRANSIENT-METHOD-CODE-WRAPPER"
        "(DEFCLASS TRANSIENT-METHOD-CODE-WRAPPER (METHOD-CODE-WRAPPER TRANSIENT-MIXIN) :RECYCLE-METHOD :SWEEP-LIST)")))
     (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* TRUE)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRANSIENT-METHOD-CODE-WRAPPER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TRANSIENT-METHOD-CODE-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "VERBATIM-STRING-WRAPPER"
        "(DEFCLASS VERBATIM-STRING-WRAPPER (TRANSIENT-STRING-WRAPPER) :DOCUMENTATION \"Wrapper class used to hold verbatim native code strings.\" :RECYCLE-METHOD :SWEEP-LIST :PRINT-FORM (PRINT-NATIVE-STREAM STREAM (CHOOSE *PRINTREADABLY?* \"\" \"!V!\") (WRAPPER-VALUE SELF)))")))
     (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* TRUE)
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-VERBATIM-STRING-WRAPPER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-VERBATIM-STRING-WRAPPER-SLOT-VALUE)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "BOOLEAN"
     "(DEFCLASS BOOLEAN (LITERAL) :DOCUMENTATION \"Boolean type with values TRUE, FALSE and NULL-BOOLEAN.
Stored by default using a single bit, thereby eliminating the value
NULL-BOOLEAN.  Propagated within variables as an unsigned character.\" :INITIAL-VALUE FALSE :CL-NATIVE-TYPE \"FIXNUM\" :CPP-NATIVE-TYPE \"boolean\" :IDL-NATIVE-TYPE \"boolean\" :JAVA-NATIVE-TYPE \"boolean\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "FAT-BOOLEAN"
     "(DEFCLASS FAT-BOOLEAN (BOOLEAN) :DOCUMENTATION \"Boolean type stored in an unsigned character.  Values TRUE,
FALSE, and NULL-BOOLEAN.  Slot read/write is faster than for the one-bit
storage, but it uses a lot more space.\" :CPP-NATIVE-TYPE \"fat_boolean\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "ONE-BIT-BOOLEAN"
     "(DEFCLASS ONE-BIT-BOOLEAN (BOOLEAN) :DOCUMENTATION \"Space-saving representation of Boolean.  Eliminates the
value NULL-BOOLEAN and takes longer to read and write than FAT-BOOLEAN.\" :CPP-NATIVE-TYPE \"one_bit_boolean\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "CODE"
     "(DEFCLASS CODE (LITERAL) :ABSTRACT? TRUE)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "FUNCTION-CODE"
     "(DEFCLASS FUNCTION-CODE (CODE) :CL-NATIVE-TYPE \"FUNCTION\" :JAVA-NATIVE-TYPE \"java_function_code\" :CPP-NATIVE-TYPE \"cpp_function_code\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "METHOD-CODE"
     "(DEFCLASS METHOD-CODE (CODE) :CL-NATIVE-TYPE \"STANDARD-GENERIC-FUNCTION\" :JAVA-NATIVE-TYPE \"java_method_code\" :CPP-NATIVE-TYPE \"cpp_method_code\" :INITIAL-VALUE (SAFE-CAST NULL @METHOD-CODE))")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "LISP-CODE"
     "(DEFCLASS LISP-CODE () :ABSTRACT? TRUE :DOCUMENTATION \"Used to indicate variables that input or output Common Lisp~
      structures.\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "THIRTY-TWO-BIT-VECTOR"
     "(DEFCLASS THIRTY-TWO-BIT-VECTOR (INTEGER) :CL-NATIVE-TYPE \"FIXNUM\" :CPP-NATIVE-TYPE \"int\" :DOCUMENTATION \"Bit vector used to implement BOOLEAN slots.\" :INITIAL-VALUE NULL-INTEGER)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "LISP-CLASS"
     "(DEFCLASS LISP-CLASS (LISP-CODE) :CL-NATIVE-TYPE \"CLASS\" :CPP-NATIVE-TYPE \"cpp_class*\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "LISP-CONS"
     "(DEFCLASS LISP-CONS (LISP-CODE) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :CL-NATIVE-TYPE \"CONS\" :CPP-NATIVE-TYPE \"cpp_cons*\" :SYNONYMS (ARGUMENT-LIST))")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "LISP-NIL"
     "(DEFCLASS LISP-NIL (LISP-CONS) :CL-NATIVE-TYPE \"NULL\" :CPP-NATIVE-TYPE \"cpp_nil*\")")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "LISP-CONS-ITERATOR"
        "(DEFCLASS LISP-CONS-ITERATOR (ITERATOR) :SLOTS ((CONS-ITERATOR-CURSOR :TYPE LISP-CONS)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-LISP-CONS-ITERATOR)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "NATIVE-STREAM"
     "(DEFCLASS NATIVE-STREAM () :ABSTRACT? TRUE :CPP-NATIVE-TYPE \"ios*\" :CL-NATIVE-TYPE \"STREAM\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "NATIVE-OUTPUT-STREAM"
     "(DEFCLASS NATIVE-OUTPUT-STREAM (NATIVE-STREAM) :ABSTRACT? TRUE :CPP-NATIVE-TYPE \"ostream*\" :JAVA-NATIVE-TYPE \"PrintStream\" :CL-NATIVE-TYPE \"STREAM\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
     "NATIVE-INPUT-STREAM"
     "(DEFCLASS NATIVE-INPUT-STREAM (NATIVE-STREAM) :ABSTRACT? TRUE :CPP-NATIVE-TYPE \"istream*\" :CL-NATIVE-TYPE \"STREAM\")")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "STREAM"
        "(DEFCLASS STREAM (STANDARD-OBJECT) :ABSTRACT? TRUE :SLOTS ((STATE :TYPE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-STREAM-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "OUTPUT-STREAM"
        "(DEFCLASS OUTPUT-STREAM (STREAM) :SLOTS ((NATIVE-STREAM :TYPE NATIVE-OUTPUT-STREAM) (NATIVE-OUTPUT-STREAM :RENAMES NATIVE-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-OUTPUT-STREAM)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "INPUT-STREAM"
        "(DEFCLASS INPUT-STREAM (STREAM) :SLOTS ((NATIVE-STREAM :TYPE NATIVE-INPUT-STREAM) (NATIVE-INPUT-STREAM :RENAMES NATIVE-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INPUT-STREAM)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "OUTPUT-FILE-STREAM"
        "(DEFCLASS OUTPUT-FILE-STREAM (OUTPUT-STREAM) :SLOTS ((FILENAME :TYPE STRING :REQUIRED? TRUE) (IF-EXISTS-ACTION :TYPE KEYWORD :INITIALLY :SUPERSEDE)) :INITIALIZER INITIALIZE-FILE-STREAM :TERMINATOR TERMINATE-FILE-STREAM? :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|OFS|'\" (FILENAME SELF) \"'\"))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-OUTPUT-FILE-STREAM))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-OUTPUT-FILE-STREAM-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "INPUT-FILE-STREAM"
        "(DEFCLASS INPUT-FILE-STREAM (INPUT-STREAM) :SLOTS ((FILENAME :TYPE STRING :REQUIRED? TRUE) (IF-NOT-EXISTS-ACTION :TYPE KEYWORD :INITIALLY :ERROR)) :INITIALIZER INITIALIZE-FILE-STREAM :TERMINATOR TERMINATE-FILE-STREAM? :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|IFS|'\" (FILENAME SELF) \"'\"))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INPUT-FILE-STREAM))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-INPUT-FILE-STREAM-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "OUTPUT-STRING-STREAM"
        "(DEFCLASS OUTPUT-STRING-STREAM (OUTPUT-STREAM) :SLOTS ((THE-STRING :TYPE STRING :REQUIRED? TRUE)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-OUTPUT-STRING-STREAM))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-OUTPUT-STRING-STREAM-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "INPUT-STRING-STREAM"
        "(DEFCLASS INPUT-STRING-STREAM (INPUT-STREAM) :SLOTS ((THE-STRING :TYPE STRING :REQUIRED? TRUE)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INPUT-STRING-STREAM))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-INPUT-STRING-STREAM-SLOT-VALUE))))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-HIERARCHY"
     NULL
     "(DEFUN STARTUP-HIERARCHY ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES)))
  :VOID)
