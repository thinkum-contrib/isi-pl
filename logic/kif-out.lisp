;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997                   | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-KIF-OUT-LITERAL-WRAPPER NULL)
(CL:DEFVAR SGT-KIF-OUT-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-KIF-OUT-PROPOSITION NULL)
(CL:DEFVAR KWD-KIF-OUT-FUNCTION NULL)
(CL:DEFVAR SYM-KIF-OUT-DESCRIPTION NULL)
(CL:DEFVAR SGT-KIF-OUT-SLOT NULL)
(CL:DEFVAR SYM-KIF-OUT-ALL-FACTS-OF NULL)
(CL:DEFVAR KWD-KIF-OUT-COMMON-LISP NULL)
(CL:DEFVAR SGT-KIF-OUT-SKOLEM NULL)
(CL:DEFVAR SYM-KIF-OUT-RETRACT-FACTS-OF NULL)
(CL:DEFVAR SYM-KIF-OUT-*PRETTYPRINTLOGICALFORMS?* NULL)
(CL:DEFVAR SYM-KIF-OUT-*PRETTYPRINTKIF?* NULL)
(CL:DEFVAR SYM-KIF-OUT-*PRINTLOGICALFORMSTREAM* NULL)
(CL:DEFVAR SYM-KIF-OUT-*DOWNCASEOPERATORS?* NULL)
(CL:DEFVAR SYM-KIF-OUT-*INDENTCOUNTER* NULL)
(CL:DEFVAR KWD-KIF-OUT-KIF NULL)
(CL:DEFVAR KWD-KIF-OUT-STELLA NULL)
(CL:DEFVAR KWD-KIF-OUT-PREFIX-STELLA NULL)
(CL:DEFVAR KWD-KIF-OUT-SQL NULL)
(CL:DEFVAR SGT-KIF-OUT-DESCRIPTION NULL)
(CL:DEFVAR SGT-KIF-OUT-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-KIF-OUT-COLLECTION NULL)
(CL:DEFVAR KWD-KIF-OUT-IN NULL)
(CL:DEFVAR KWD-KIF-OUT-REALISTIC NULL)
(CL:DEFVAR KWD-KIF-OUT-ORIGINAL NULL)
(CL:DEFVAR SGT-KIF-OUT-SLOTREF NULL)
(CL:DEFVAR SYM-KIF-OUT-*TOPLEVELPRINTKIFPROPOSITION?* NULL)
(CL:DEFVAR KWD-KIF-OUT-AND NULL)
(CL:DEFVAR KWD-KIF-OUT-OR NULL)
(CL:DEFVAR KWD-KIF-OUT-NOT NULL)
(CL:DEFVAR KWD-KIF-OUT-EQUIVALENT NULL)
(CL:DEFVAR KWD-KIF-OUT-PREDICATE NULL)
(CL:DEFVAR KWD-KIF-OUT-IMPLIES NULL)
(CL:DEFVAR KWD-KIF-OUT-FORALL NULL)
(CL:DEFVAR KWD-KIF-OUT-EXISTS NULL)
(CL:DEFVAR KWD-KIF-OUT-CONSTANT NULL)
(CL:DEFVAR KWD-KIF-OUT-CONTAINED-BY NULL)
(CL:DEFVAR KWD-KIF-OUT-DELETED NULL)
(CL:DEFVAR SGT-KIF-OUT-TYPE NULL)
(CL:DEFVAR SYM-KIF-OUT-IO-VARIABLES NULL)
(CL:DEFVAR SYM-KIF-OUT-SURROGATE-VALUE-INVERSE NULL)
(CL:DEFVAR KWD-KIF-OUT-ENUMERATION NULL)
(CL:DEFVAR SGT-KIF-OUT-COLLECTION.ORDERED NULL)
(CL:DEFVAR SGT-KIF-OUT-COLLECTION.DUPLICATE-FREE NULL)
(CL:DEFVAR SYM-KIF-OUT-?X NULL)
(CL:DEFVAR SYM-KIF-OUT-?Y NULL)
(CL:DEFVAR SYM-KIF-OUT-?Z NULL)
(CL:DEFVAR SGT-KIF-OUT-SYMBOL NULL)
(CL:DEFVAR SYM-KIF-OUT-SKOLEM-NAME NULL)
(CL:DEFVAR SYM-KIF-OUT-*EXCLUDEDPROPOSITIONS* NULL)
(CL:DEFVAR SGT-KIF-OUT-CLASS NULL)
(CL:DEFVAR SYM-KIF-OUT-MASTER-PROPOSITION NULL)
(CL:DEFVAR SGT-KIF-OUT-COLLECTION.CLOSED NULL)
(CL:DEFVAR SYM-KIF-OUT-RELATION-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SGT-KIF-OUT-CONS NULL)
(CL:DEFVAR KWD-KIF-OUT-SLOTS NULL)
(CL:DEFVAR KWD-KIF-OUT-PUBLIC-SLOTS NULL)
(CL:DEFVAR KWD-KIF-OUT-METHODS NULL)
(CL:DEFVAR KWD-KIF-OUT-PUBLIC-METHODS NULL)
(CL:DEFVAR SYM-KIF-OUT-ASSERT NULL)
(CL:DEFVAR SYM-KIF-OUT-DEFRULE NULL)
(CL:DEFVAR SGT-KIF-OUT-FUNCTION NULL)
(CL:DEFVAR SYM-KIF-OUT-SAVE-MODULE NULL)
(CL:DEFVAR SYM-KIF-OUT-EVALUATOR-WRAPPER-CODE NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *MODULE*
  NULL-STRING-WRAPPER
  STANDARD-OUTPUT
  EOL
  *PRINTMODE*
  *LOGIC-DIALECT*))

;;; (DEFUN COLLECT-FUNCTION-PROPOSITION-FACTS ...)

(CL:DEFUN COLLECT-FUNCTION-PROPOSITION-FACTS (SELF FACTS BEENTHERE)
  (INSERT BEENTHERE SELF)
  (CL:LET*
   ((OUTPUTSKOLEM (LAST-ARGUMENT SELF))
    (VALUE (VALUE-OF OUTPUTSKOLEM))
    (HASASSERTEDVALUE?
     (CL:IF (CL:EQ (EQL? VALUE OUTPUTSKOLEM) 0) TRUE FALSE)))
   (CL:WHEN
    (CL:EQ HASASSERTEDVALUE? 1)
    (CL:WHEN (CL:EQ (MEMBER? FACTS SELF) 0) (INSERT FACTS SELF)))
   (CL:WHEN
    (CL:OR
     (CL:EQ HASASSERTEDVALUE? 0)
     (CL:AND
      (CL:EQ (NATIVE-VALUE? VALUE) 1)
      (CL:EQ (ISA? VALUE SGT-KIF-OUT-LITERAL-WRAPPER) 0)))
    (HELP-COLLECT-FACTS OUTPUTSKOLEM FACTS BEENTHERE)))
  :VOID)

;;; (DEFUN HELP-COLLECT-FACTS ...)

(CL:DEFUN HELP-COLLECT-FACTS (SELF FACTS BEENTHERE)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-KIF-OUT-LOGIC-OBJECT) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((P NULL)
        (ITER-001
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-ATTRIBUTE-PROPOSITIONS SELF))))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ
          P
          (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-KIF-OUT-PROPOSITION))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:WHEN
         (CL:EQ (MEMBER? BEENTHERE P) 0)
         (CL:IF
          (CL:EQ (CLSYS-SVAL PROPOSITION KIND P) KWD-KIF-OUT-FUNCTION)
          (COLLECT-FUNCTION-PROPOSITION-FACTS P FACTS BEENTHERE)
          (HELP-COLLECT-FACTS P FACTS BEENTHERE)))))
      (CL:LET*
       ((P NULL)
        (ITER-002
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS SELF))))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-002 NIL))
        DO
        (CL:PROGN
         (CL:SETQ
          P
          (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-KIF-OUT-PROPOSITION))
         (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
        (CL:WHEN
         (CL:EQ (MEMBER? BEENTHERE P) 0)
         (HELP-COLLECT-FACTS P FACTS BEENTHERE))))
      (CL:LET*
       ((EQUIVALENT NULL) (ITER-003 (VARIABLE-VALUE-INVERSE SELF)))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-003 NIL))
        DO
        (CL:PROGN
         (CL:SETQ
          EQUIVALENT
          (CAST (CLSYS-SVAL CONS VALUE ITER-003) SGT-KIF-OUT-LOGIC-OBJECT))
         (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
        (HELP-COLLECT-FACTS EQUIVALENT FACTS BEENTHERE)))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-KIF-OUT-PROPOSITION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (INSERT BEENTHERE SELF)
      (CL:WHEN (CL:EQ (UNKNOWN? SELF) 0) (INSERT FACTS SELF))
      (CL:LET*
       ((P NULL)
        (ITER-004
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (CLSYS-SVAL PROPOSITION DEPENDENT-PROPOSITIONS SELF))))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-004 NIL))
        DO
        (CL:PROGN
         (CL:SETQ
          P
          (CAST (CLSYS-SVAL CONS VALUE ITER-004) SGT-KIF-OUT-PROPOSITION))
         (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
        (CL:WHEN
         (CL:EQ (MEMBER? BEENTHERE P) 0)
         (HELP-COLLECT-FACTS P FACTS BEENTHERE))))))
    ((CL:EQ (SURROGATE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) NULL))
       (HELP-COLLECT-FACTS
        (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)
        FACTS
        BEENTHERE))))
    ((CL:EQ (CLASS? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:NOT
        (CL:EQ (DYNAMIC-SLOT-VALUE SELF SYM-KIF-OUT-DESCRIPTION NULL) NULL))
       (HELP-COLLECT-FACTS
        (DYNAMIC-SLOT-VALUE SELF SYM-KIF-OUT-DESCRIPTION NULL)
        FACTS
        BEENTHERE))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-KIF-OUT-SLOT) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:NOT
        (CL:EQ (DYNAMIC-SLOT-VALUE SELF SYM-KIF-OUT-DESCRIPTION NULL) NULL))
       (HELP-COLLECT-FACTS
        (DYNAMIC-SLOT-VALUE SELF SYM-KIF-OUT-DESCRIPTION NULL)
        FACTS
        BEENTHERE))))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN (ALL-FACTS-OF-OBJECT (LIST OF PROPOSITION)) ...)

(CL:DEFUN ALL-FACTS-OF-OBJECT (SELF)
  "Return a list of all definite (TRUE or FALSE) propositions
attached to `self'."
  (CL:LET*
   ((FACTS (NEW-LIST)) (BEENTHERE (NEW-LIST)))
   (HELP-COLLECT-FACTS SELF FACTS BEENTHERE)
   (FREE BEENTHERE)
   (CL:RETURN-FROM ALL-FACTS-OF-OBJECT FACTS))
  :VOID)

;;; (DEFUN (GET-LOGIC-OBJECT LOGIC-OBJECT) ...)

(CL:DEFUN GET-LOGIC-OBJECT (NAME)
  "Return the logic object named 'name'."
  (CL:LET*
   ((SURROGATE (LOOKUP-SURROGATE NAME)))
   (CL:WHEN
    (CL:NOT (CL:EQ SURROGATE NULL))
    (CL:RETURN-FROM
     GET-LOGIC-OBJECT
     (CAST
      (VALUE-OF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE))
      SGT-KIF-OUT-LOGIC-OBJECT))))
  :VOID)

;;; (DEFUN (ALL-FACTS-OF (LIST OF PROPOSITION)) ...)

(CL:DEFUN %%ALL-FACTS-OF (NAME)
  "Return a list of all definite (TRUE or FALSE) propositions
that reference the logic-object named `name'."
  (CL:LET*
   ((INSTANCE (COERCE-TO-INSTANCE NAME NULL)))
   (CL:IF
    (CL:NOT (CL:EQ INSTANCE NULL))
    (CL:RETURN-FROM %%ALL-FACTS-OF (ALL-FACTS-OF-OBJECT INSTANCE))
    (CL:RETURN-FROM %%ALL-FACTS-OF NULL)))
  :VOID)

(CL:DEFMACRO ALL-FACTS-OF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Return a list of all definite (TRUE or FALSE) propositions
that reference the logic-object named `name'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/ALL-FACTS-OF)) (CL:MACRO-FUNCTION (CL:QUOTE ALL-FACTS-OF)))

;;; (DEFUN RETRACT-FACTS-OF-OBJECT ...)

(CL:DEFUN RETRACT-FACTS-OF-OBJECT (SELF)
  "Retract all definite (TRUE or FALSE) propositions attached to `self'."
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM RETRACT-FACTS-OF-OBJECT))
  (CL:LET*
   ((P NULL)
    (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST (ALL-FACTS-OF-OBJECT SELF))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      P
      (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-KIF-OUT-PROPOSITION))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:TAGBODY
     (CL:LET*
      ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND P)))
      (CL:COND
       ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-FUNCTION)
        (CL:LET*
         ((SKOLEM
           (CAST
            (LAST (CLSYS-SVAL PROPOSITION ARGUMENTS P))
            SGT-KIF-OUT-SKOLEM)))
         (CL:WHEN (CL:EQ SKOLEM SELF) (CL:GO :CONTINUE))
         (CL:WHEN
          (CL:AND
           (CL:NOT (CL:EQ SKOLEM NULL))
           (CL:NOT
            (CL:EQ
             (ACCESS-IN-CONTEXT
              (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE SKOLEM)
              SKOLEM
              FALSE)
             NULL)))
          (UNASSERT-FACT P))
         (RETRACT-FACTS-OF-OBJECT SKOLEM)))
       (CL:T (UNASSERT-FACT P))))
     :CONTINUE)))
  :VOID)

;;; (DEFUN RETRACT-FACTS-OF ...)

(CL:DEFUN %%RETRACT-FACTS-OF (NAME)
  "Retract all definite (TRUE or FALSE) propositions
that reference the logic-object named `name'."
  (CL:LET*
   ((INSTANCE (COERCE-TO-INSTANCE NAME NULL)))
   (CL:WHEN (CL:NOT (CL:EQ INSTANCE NULL)) (RETRACT-FACTS-OF-OBJECT INSTANCE)))
  :VOID)

(CL:DEFMACRO RETRACT-FACTS-OF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Retract all definite (TRUE or FALSE) propositions
that reference the logic-object named `name'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/RETRACT-FACTS-OF)) (CL:MACRO-FUNCTION (CL:QUOTE RETRACT-FACTS-OF)))

;;; (DEFSPECIAL *PRETTYPRINTLOGICALFORMS?* ...)

(CL:DEFVAR *PRETTYPRINTLOGICALFORMS?* FALSE
  "Controls whether logical forms print on single lines
(unformatted) or multi-line indented.")

(CL:DEFUN READ-*PRETTYPRINTLOGICALFORMS?* ()
  (CL:RETURN-FROM READ-*PRETTYPRINTLOGICALFORMS?* *PRETTYPRINTLOGICALFORMS?*)
  :VOID)

(CL:DEFUN WRITE-*PRETTYPRINTLOGICALFORMS?* (VALUE)
  (CL:SETQ *PRETTYPRINTLOGICALFORMS?* VALUE)
  (CL:RETURN-FROM WRITE-*PRETTYPRINTLOGICALFORMS?* VALUE)
  :VOID)

;;; (DEFSPECIAL *PRETTYPRINTKIF?* ...)

(CL:DEFVAR *PRETTYPRINTKIF?* FALSE
  "Controls whether KIF expressions print on single lines
(unformatted) or multi-line indented.")

(CL:DEFUN READ-*PRETTYPRINTKIF?* ()
  (CL:RETURN-FROM READ-*PRETTYPRINTKIF?* *PRETTYPRINTKIF?*)
  :VOID)

(CL:DEFUN WRITE-*PRETTYPRINTKIF?* (VALUE)
  (CL:SETQ *PRETTYPRINTKIF?* VALUE)
  (CL:RETURN-FROM WRITE-*PRETTYPRINTKIF?* VALUE)
  :VOID)

;;; (DEFSPECIAL *PRINTLOGICALFORMSTREAM* ...)

(CL:DEFVAR *PRINTLOGICALFORMSTREAM* NULL
  "Eliminates necessity of passing stream argument
throughout 'print-logical-form' functions.")

(CL:DEFUN READ-*PRINTLOGICALFORMSTREAM* ()
  (CL:RETURN-FROM READ-*PRINTLOGICALFORMSTREAM* *PRINTLOGICALFORMSTREAM*)
  :VOID)

(CL:DEFUN WRITE-*PRINTLOGICALFORMSTREAM* (VALUE)
  (CL:SETQ *PRINTLOGICALFORMSTREAM* VALUE)
  (CL:RETURN-FROM WRITE-*PRINTLOGICALFORMSTREAM* VALUE)
  :VOID)

;;; (DEFSPECIAL *DOWNCASEOPERATORS?* ...)

(CL:DEFVAR *DOWNCASEOPERATORS?* FALSE
  "Controls whether down-casing happens during logical
form printing (leading to lots more string garbage).")

(CL:DEFUN READ-*DOWNCASEOPERATORS?* ()
  (CL:RETURN-FROM READ-*DOWNCASEOPERATORS?* *DOWNCASEOPERATORS?*)
  :VOID)

(CL:DEFUN WRITE-*DOWNCASEOPERATORS?* (VALUE)
  (CL:SETQ *DOWNCASEOPERATORS?* VALUE)
  (CL:RETURN-FROM WRITE-*DOWNCASEOPERATORS?* VALUE)
  :VOID)

;;; (DEFUN (MAYBE-DOWNCASE STRING) ...)

(CL:DEFUN MAYBE-DOWNCASE (STRING)
  (CL:IF
   (CL:EQ *DOWNCASEOPERATORS?* 1)
   (CL:RETURN-FROM MAYBE-DOWNCASE (STRING-DOWNCASE STRING))
   (CL:RETURN-FROM MAYBE-DOWNCASE STRING))
  :VOID)

;;; (DEFSPECIAL *INDENTCOUNTER* ...)

(CL:DEFVAR *INDENTCOUNTER* 0
  "The number of spaces prepended during printing a logical form.")

(CL:DEFUN READ-*INDENTCOUNTER* ()
  (CL:RETURN-FROM READ-*INDENTCOUNTER* *INDENTCOUNTER*)
  :VOID)

(CL:DEFUN WRITE-*INDENTCOUNTER* (VALUE)
  (CL:SETQ *INDENTCOUNTER* VALUE)
  (CL:RETURN-FROM WRITE-*INDENTCOUNTER* VALUE)
  :VOID)

;;; (DEFGLOBAL *INDENT-QUANTUM* ...)

(CL:DEFVAR *INDENT-QUANTUM* 3
  "The number of spaces added by a call to 'increase-indent'.")

;;; (DEFUN INCREASE-INDENT ...)

(CL:DEFUN INCREASE-INDENT (INDENT)
  (CL:WHEN (CL:EQ (NULL? INDENT) 1) (CL:SETQ INDENT *INDENT-QUANTUM*))
  (CL:SETQ *INDENTCOUNTER* (CL:+ *INDENTCOUNTER* INDENT))
  :VOID)

;;; (DEFUN DECREASE-INDENT ...)

(CL:DEFUN DECREASE-INDENT (INDENT)
  (CL:WHEN (CL:EQ (NULL? INDENT) 1) (CL:SETQ INDENT *INDENT-QUANTUM*))
  (CL:SETQ *INDENTCOUNTER* (CL:- *INDENTCOUNTER* INDENT))
  :VOID)

;;; (DEFUN PRINT-INDENT ...)

(CL:DEFUN PRINT-INDENT (STREAM INDENT)
  (CL:WHEN (CL:EQ (NULL? INDENT) 1) (CL:SETQ INDENT *INDENTCOUNTER*))
  (CL:LET*
   ((I NULL)
    (ITER-001 1)
    (UPPER-BOUND-001 INDENT)
    (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
   (CL:LOOP
    WHILE
    (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
    DO
    (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
    (CL:SETQ I I)
    (CL:WRITE-STRING " " (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
  :VOID)

;;; (DEFUN PRINT-LOGICAL-FORM-IN-DIALECT ...)

(CL:DEFUN PRINT-LOGICAL-FORM-IN-DIALECT (SELF DIALECT STREAM)
  "Produce a stringified version of a logical representation
of 'self' and write it to the stream 'stream'.  Use the dialect 'dialect',
or use the current dialect if 'dialect' is NULL."
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM PRINT-LOGICAL-FORM-IN-DIALECT))
  (CL:WHEN (CL:EQ DIALECT NULL) (CL:SETQ DIALECT *LOGIC-DIALECT*))
  (CL:LET*
   ((CURRENTINDENTCOUNTER *INDENTCOUNTER*))
   (CL:LET*
    ((*PRINTLOGICALFORMSTREAM* STREAM) (*INDENTCOUNTER* CURRENTINDENTCOUNTER))
    (CL:DECLARE (CL:SPECIAL *PRINTLOGICALFORMSTREAM* *INDENTCOUNTER*))
    (CL:COND
     ((CL:EQ DIALECT KWD-KIF-OUT-KIF)
      (CL:LET*
       ((*PRETTYPRINTKIF?* *PRETTYPRINTLOGICALFORMS?*))
       (CL:DECLARE (CL:SPECIAL *PRETTYPRINTKIF?*))
       (PRINT-AS-KIF SELF)))
     ((CL:OR
       (CL:EQ DIALECT KWD-KIF-OUT-STELLA)
       (CL:EQ DIALECT KWD-KIF-OUT-PREFIX-STELLA))
      "Not yet implemented"
      (PRINT-AS-KIF SELF))
     ((CL:EQ DIALECT KWD-KIF-OUT-SQL) "Not yet implemented")
     (CL:T (CL:ERROR "`~A' is not a valid case option" DIALECT)))))
  :VOID)

;;; (DEFUN PRINT-LOGICAL-FORM ...)

(CL:DEFUN PRINT-LOGICAL-FORM (FORM STREAM)
  "Print the logical form `form' to `stream' according to
the current setting of `*logic-dialect*'.  Pretty-printing is controlled
by the current setting of `*prettyPrintLogicalForms?*'."
  (PRINT-LOGICAL-FORM-IN-DIALECT FORM *LOGIC-DIALECT* STREAM)
  :VOID)

;;; (DEFUN PRETTY-PRINT-LOGICAL-FORM ...)

(CL:DEFUN PRETTY-PRINT-LOGICAL-FORM (FORM STREAM)
  "Pretty-print the logical form `form' to `stream' according
to the current setting of `*logic-dialect*'."
  (CL:LET*
   ((*PRETTYPRINTLOGICALFORMS?* TRUE))
   (CL:DECLARE (CL:SPECIAL *PRETTYPRINTLOGICALFORMS?*))
   (PRINT-LOGICAL-FORM-IN-DIALECT FORM *LOGIC-DIALECT* STREAM))
  :VOID)

;;; (DEFUN PRINT-UNFORMATTED-LOGICAL-FORM ...)

(CL:DEFUN PRINT-UNFORMATTED-LOGICAL-FORM (FORM STREAM)
  "Print the logical form `form' to `stream' according to
the current setting of `*logic-dialect*'.  Pretty-printing is explicitly
forced to be turned off."
  (CL:LET*
   ((*PRETTYPRINTLOGICALFORMS?* FALSE))
   (CL:DECLARE (CL:SPECIAL *PRETTYPRINTLOGICALFORMS?*))
   (PRINT-LOGICAL-FORM-IN-DIALECT FORM *LOGIC-DIALECT* STREAM))
  :VOID)

;;; (DEFUN PRINT-AS-KIF ...)

(CL:DEFUN PRINT-AS-KIF (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:WHEN
    (CL:EQ SELF NULL)
    (CL:WRITE-STRING "NULL" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
    (CL:RETURN-FROM PRINT-AS-KIF))
   (CL:LET*
    ((SELF-001 SELF))
    (CL:COND
     ((CL:EQ (TAXONOMY-ISA? SELF SGT-KIF-OUT-PROPOSITION) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (PRINT-KIF-PROPOSITION SELF)))
     ((CL:EQ (TAXONOMY-ISA? SELF SGT-KIF-OUT-LITERAL-WRAPPER) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (PRINT-KIF-LITERAL-WRAPPER SELF)))
     ((CL:EQ (TAXONOMY-ISA? SELF SGT-KIF-OUT-DESCRIPTION) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (PRINT-KIF-DESCRIPTION SELF)))
     ((CL:EQ (TAXONOMY-ISA? SELF SGT-KIF-OUT-PATTERN-VARIABLE) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (PRINT-KIF-VARIABLE SELF)))
     ((CL:EQ (TAXONOMY-ISA? SELF SGT-KIF-OUT-SKOLEM) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (PRINT-KIF-SKOLEM SELF FALSE)))
     ((CL:EQ (TAXONOMY-ISA? SELF SGT-KIF-OUT-LOGIC-OBJECT) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (PRINT-KIF-LOGIC-OBJECT SELF)))
     ((CL:EQ (SURROGATE? SELF) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:WRITE-STRING
        (CLSYS-SVAL SURROGATE SYMBOL-NAME SELF)
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
     ((CL:EQ (TAXONOMY-ISA? SELF SGT-KIF-OUT-COLLECTION) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (PRINT-KIF-ENUMERATION SELF)))
     (CL:T
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
       (CL:WRITE-STRING "|Illegal Logical Form|: " %%STREAM)
       (PRINT-OBJECT SELF %%STREAM))))))
  :VOID)

;;; (DEFUN (VISIBLE-ARGUMENT? BOOLEAN) ...)

(CL:DEFUN VISIBLE-ARGUMENT? (SELF)
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM VISIBLE-ARGUMENT? TRUE))
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-KIF-OUT-PROPOSITION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:AND
        (CL:EQ (CLSYS-SVAL PROPOSITION KIND SELF) KWD-KIF-OUT-IN)
        (CL:EQ (VARIABLE-TYPE? SELF) 1))
       (CL:COND
        ((CL:OR
          (CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC)
          (CL:EQ *PRINTMODE* KWD-KIF-OUT-ORIGINAL))
         (CL:RETURN-FROM VISIBLE-ARGUMENT? FALSE))
        (CL:T NULL)))))
    (CL:T NULL)))
  (CL:RETURN-FROM VISIBLE-ARGUMENT? TRUE)
  :VOID)

;;; (DEFUN (VISIBLE-ARGUMENTS-COUNT INTEGER) ...)

(CL:DEFUN VISIBLE-ARGUMENTS-COUNT (ARGUMENTS)
  (CL:LET*
   ((COUNT 0))
   (CL:LET*
    ((ARG NULL)
     (VECTOR-001 ARGUMENTS)
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       ARG
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:WHEN
      (CL:EQ (VISIBLE-ARGUMENT? ARG) 1)
      (CL:SETQ COUNT (CL:1+ COUNT)))))
   (CL:RETURN-FROM VISIBLE-ARGUMENTS-COUNT COUNT))
  :VOID)

;;; (DEFUN PRINT-KIF-ARGUMENTS ...)

(CL:DEFUN PRINT-KIF-ARGUMENTS (ARGUMENTS SEPARATELINES? OMITLASTARGUMENT?)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (ARGUMENTSITERATOR
     (CL:IF
      (CL:EQ OMITLASTARGUMENT? 1)
      (BUT-LAST ARGUMENTS)
      (ALLOCATE-ITERATOR ARGUMENTS)))
    (VISIBLEARGCOUNT (VISIBLE-ARGUMENTS-COUNT ARGUMENTS))
    (ARGINDEX 0))
   (CL:WHEN
    (CL:AND
     (CL:EQ OMITLASTARGUMENT? 1)
     (CL:EQ (VISIBLE-ARGUMENT? (LAST ARGUMENTS)) 1))
    (CL:SETQ VISIBLEARGCOUNT (CL:1- VISIBLEARGCOUNT)))
   (CL:LET*
    ((ARG NULL) (ITER-001 ARGUMENTSITERATOR))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ ARG (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:WHEN
      (CL:OR (CL:EQ (VISIBLE-ARGUMENT? ARG) 1) (CL:= VISIBLEARGCOUNT 0))
      (CL:SETQ ARGINDEX (CL:1+ ARGINDEX))
      (CL:WHEN
       (CL:> ARGINDEX 1)
       (CL:COND
        ((CL:AND (CL:EQ SEPARATELINES? 1) (CL:EQ *PRETTYPRINTKIF?* 1))
         (CL:LET
          ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))
         (PRINT-INDENT STREAM NULL-INTEGER))
        (CL:T
         (CL:WRITE-STRING
          " "
          (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))))
      (PRINT-AS-KIF ARG)))))
  :VOID)

;;; (DEFUN PRINT-KIF-OPERATOR-WITH-ARGUMENTS ...)

(CL:DEFUN PRINT-KIF-OPERATOR-WITH-ARGUMENTS (OPERATOR ARGUMENTS SEPARATELINES? OMITLASTARGUMENT?)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
    (CL:WRITE-STRING "(" %%STREAM)
    (CL:WRITE-STRING OPERATOR %%STREAM)
    (CL:WRITE-STRING " " %%STREAM))
   (INCREASE-INDENT (CL:+ (LENGTH OPERATOR) 2))
   (PRINT-KIF-ARGUMENTS ARGUMENTS SEPARATELINES? OMITLASTARGUMENT?)
   (DECREASE-INDENT (CL:+ (LENGTH OPERATOR) 2))
   (CL:WRITE-STRING ")" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
  :VOID)

;;; (DEFUN (STRINGIFIED-KIF-OPERATOR STRING) ...)

(CL:DEFUN STRINGIFIED-KIF-OPERATOR (SELF)
  (CL:RETURN-FROM
   STRINGIFIED-KIF-OPERATOR
   (MAYBE-DOWNCASE
    (CLSYS-SVAL
     SYMBOL
     SYMBOL-NAME
     (INTERNAL-STELLA-OPERATOR-TO-KIF
      (CLSYS-SVAL
       SLOT
       SLOT-NAME
       (CAST
        (CLSYS-SVAL
         SURROGATE
         SURROGATE-VALUE
         (CAST (CLSYS-SVAL PROPOSITION OPERATOR SELF) SGT-KIF-OUT-SLOTREF))
        SGT-KIF-OUT-SLOT))))))
  :VOID)

;;; (DEFSPECIAL *TOPLEVELPRINTKIFPROPOSITION?* ...)

(CL:DEFVAR *TOPLEVELPRINTKIFPROPOSITION?* TRUE)

(CL:DEFUN READ-*TOPLEVELPRINTKIFPROPOSITION?* ()
  (CL:RETURN-FROM
   READ-*TOPLEVELPRINTKIFPROPOSITION?*
   *TOPLEVELPRINTKIFPROPOSITION?*)
  :VOID)

(CL:DEFUN WRITE-*TOPLEVELPRINTKIFPROPOSITION?* (VALUE)
  (CL:SETQ *TOPLEVELPRINTKIFPROPOSITION?* VALUE)
  (CL:RETURN-FROM WRITE-*TOPLEVELPRINTKIFPROPOSITION?* VALUE)
  :VOID)

;;; (DEFUN PRINT-KIF-PROPOSITION ...)

(CL:DEFUN PRINT-KIF-PROPOSITION (SELF)
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM PRINT-KIF-PROPOSITION))
  (CL:LET*
   ((TOPLEVEL? *TOPLEVELPRINTKIFPROPOSITION?*)
    (STREAM *PRINTLOGICALFORMSTREAM*)
    (PRINTEXPLICITNEGATION?
     (CL:IF
      (CL:AND
       (CL:EQ TOPLEVEL? 1)
       (CL:EQ (FALSE? SELF) 1)
       (CL:EQ *PRINTMODE* KWD-KIF-OUT-ORIGINAL))
      TRUE
      FALSE)))
   (CL:LET*
    ((*TOPLEVELPRINTKIFPROPOSITION?* FALSE))
    (CL:DECLARE (CL:SPECIAL *TOPLEVELPRINTKIFPROPOSITION?*))
    (CL:WHEN
     (CL:EQ PRINTEXPLICITNEGATION? 1)
     (CL:WRITE-STRING "(not " (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
     (INCREASE-INDENT 5))
    (CL:IF
     (CL:AND
      (CL:OR
       (CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC)
       (CL:EQ *PRINTMODE* KWD-KIF-OUT-ORIGINAL))
      (CL:EQ TOPLEVEL? 1)
      (CL:EQ (TOP-LEVEL-EXISTS-PROPOSITION? SELF) 1))
     (PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION SELF)
     (HELP-PRINT-KIF-PROPOSITION SELF))
    (CL:WHEN
     (CL:EQ PRINTEXPLICITNEGATION? 1)
     (CL:WRITE-STRING ")" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
     (DECREASE-INDENT 5))))
  :VOID)

;;; (DEFUN HELP-PRINT-KIF-PROPOSITION ...)

(CL:DEFUN HELP-PRINT-KIF-PROPOSITION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*) (OPERATOR NULL) (SEPARATELINES? FALSE))
   (CL:LET*
    ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND SELF)))
    (CL:COND
     ((CL:OR
       (CL:EQ TEST-VALUE-001 KWD-KIF-OUT-AND)
       (CL:EQ TEST-VALUE-001 KWD-KIF-OUT-OR))
      (CL:IF
       (CL:EQ (CLSYS-SVAL PROPOSITION KIND SELF) KWD-KIF-OUT-AND)
       (CL:SETQ OPERATOR "and")
       (CL:SETQ OPERATOR "or"))
      (CL:SETQ SEPARATELINES? TRUE)
      (CL:WHEN
       (CL:=
        (VISIBLE-ARGUMENTS-COUNT (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
        1)
       (CL:COND
        ((CL:OR
          (CL:EQ *PRINTMODE* KWD-KIF-OUT-REALISTIC)
          (CL:EQ *PRINTMODE* KWD-KIF-OUT-ORIGINAL))
         (PRINT-KIF-ARGUMENTS
          (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)
          FALSE
          FALSE)
         (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))
        (CL:T NULL))))
     ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-NOT) (CL:SETQ OPERATOR "not"))
     ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-EQUIVALENT) (CL:SETQ OPERATOR "="))
     ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-PREDICATE)
      (CL:SETQ OPERATOR (STRINGIFIED-KIF-OPERATOR SELF)))
     ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-FUNCTION)
      (PRINT-KIF-FUNCTION-PROPOSITION SELF)
      (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))
     ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-IN)
      (PRINT-KIF-IN-PROPOSITION SELF)
      (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))
     ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-IMPLIES)
      (PRINT-KIF-IMPLIES-PROPOSITION SELF)
      (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))
     ((CL:OR
       (CL:EQ TEST-VALUE-001 KWD-KIF-OUT-FORALL)
       (CL:EQ TEST-VALUE-001 KWD-KIF-OUT-EXISTS))
      (PRINT-KIF-QUANTIFICATION SELF)
      (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))
     ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-CONSTANT)
      (CL:WRITE-STRING
       (CLSYS-SVAL
        SURROGATE
        SYMBOL-NAME
        (CAST (CLSYS-SVAL PROPOSITION OPERATOR SELF) SGT-KIF-OUT-SLOTREF))
       (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
      (CL:RETURN-FROM HELP-PRINT-KIF-PROPOSITION))
     ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-CONTAINED-BY)
      (CL:SETQ OPERATOR ":CONTAINED-BY"))
     ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-DELETED)
      (CL:SETQ OPERATOR ":DELETED"))
     (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
   (PRINT-KIF-OPERATOR-WITH-ARGUMENTS
    OPERATOR
    (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)
    SEPARATELINES?
    FALSE))
  :VOID)

;;; (DEFUN PRINT-KIF-FUNCTION-PROPOSITION ...)

(CL:DEFUN PRINT-KIF-FUNCTION-PROPOSITION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (DOWNCASEDNAME (STRINGIFIED-KIF-OPERATOR SELF))
    (LASTARGUMENT (LAST-ARGUMENT SELF)))
   (CL:WRITE-STRING "(= " (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
   (PRINT-KIF-OPERATOR-WITH-ARGUMENTS
    DOWNCASEDNAME
    (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)
    FALSE
    TRUE)
   (CL:WRITE-STRING " " (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
   (CL:LET*
    ((LASTARGUMENT-001 LASTARGUMENT))
    (CL:COND
     ((CL:EQ (TAXONOMY-ISA? LASTARGUMENT SGT-KIF-OUT-PATTERN-VARIABLE) 1)
      (CL:LET*
       ((LASTARGUMENT NULL))
       (CL:SETQ LASTARGUMENT LASTARGUMENT-001)
       (PRINT-KIF-VARIABLE LASTARGUMENT)))
     ((CL:EQ (TAXONOMY-ISA? LASTARGUMENT SGT-KIF-OUT-SKOLEM) 1)
      (CL:LET*
       ((LASTARGUMENT NULL))
       (CL:SETQ LASTARGUMENT LASTARGUMENT-001)
       (PRINT-KIF-SKOLEM LASTARGUMENT TRUE)))
     (CL:T (PRINT-AS-KIF LASTARGUMENT))))
   (CL:WRITE-STRING ")" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
  :VOID)

;;; (DEFUN PRINT-KIF-FUNCTION-EXPRESSION ...)

(CL:DEFUN PRINT-KIF-FUNCTION-EXPRESSION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (DOWNCASEDNAME (STRINGIFIED-KIF-OPERATOR SELF)))
   (PRINT-KIF-OPERATOR-WITH-ARGUMENTS
    DOWNCASEDNAME
    (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)
    FALSE
    TRUE))
  :VOID)

;;; (DEFUN PRINT-KIF-IN-PROPOSITION ...)

(CL:DEFUN PRINT-KIF-IN-PROPOSITION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (FIRSTARG
     (CL:AREF
      (CLSYS-SVAL VECTOR THE-ARRAY (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
      0))
    (SECONDARG
     (CL:AREF
      (CLSYS-SVAL VECTOR THE-ARRAY (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
      1))
    (PRINTASPROPERTY? FALSE))
   (CL:LET*
    ((SECONDARG-001 SECONDARG))
    (CL:COND
     ((CL:EQ (TAXONOMY-ISA? SECONDARG SGT-KIF-OUT-PATTERN-VARIABLE) 1)
      (CL:LET*
       ((SECONDARG NULL))
       (CL:SETQ SECONDARG SECONDARG-001)
       (CL:WHEN
        (CL:AND
         (CL:NOT (CL:EQ (BINDING-TO-CONSTANT SECONDARG) NULL))
         (CL:EQ (ISA? (BINDING-TO-CONSTANT SECONDARG) SGT-KIF-OUT-TYPE) 1))
        (CL:SETQ PRINTASPROPERTY? TRUE))))
     ((CL:EQ (TYPE? SECONDARG) 1)
      (CL:LET*
       ((SECONDARG NULL))
       (CL:SETQ SECONDARG SECONDARG-001)
       (CL:SETQ PRINTASPROPERTY? TRUE)))
     (CL:T NULL)))
   (CL:IF
    (CL:EQ PRINTASPROPERTY? 1)
    (CL:PROGN
     (CL:WRITE-STRING "(" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
     (PRINT-AS-KIF SECONDARG)
     (CL:WRITE-STRING " " (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
     (PRINT-AS-KIF FIRSTARG)
     (CL:WRITE-STRING ")" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
    (CL:PROGN
     (CL:WRITE-STRING
      "(member "
      (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
     (PRINT-AS-KIF FIRSTARG)
     (CL:WRITE-STRING " " (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
     (PRINT-AS-KIF SECONDARG)
     (CL:WRITE-STRING ")" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))))
  :VOID)

;;; (DEFUN PRINT-KIF-IMPLIES-PROPOSITION ...)

(CL:DEFUN PRINT-KIF-IMPLIES-PROPOSITION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (TAILARG
     (CL:AREF
      (CLSYS-SVAL VECTOR THE-ARRAY (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
      0))
    (HEADARG
     (CL:AREF
      (CLSYS-SVAL VECTOR THE-ARRAY (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
      1)))
   (CL:IF
    (CL:AND
     (CL:EQ (ISA? HEADARG SGT-KIF-OUT-DESCRIPTION) 1)
     (CL:EQ (ISA? TAILARG SGT-KIF-OUT-DESCRIPTION) 1))
    (PRINT-DESCRIPTIONS-AS-KIF-RULE
     (CAST HEADARG SGT-KIF-OUT-DESCRIPTION)
     (CAST TAILARG SGT-KIF-OUT-DESCRIPTION))
    (PRINT-KIF-OPERATOR-WITH-ARGUMENTS
     "subset"
     (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)
     TRUE
     FALSE)))
  :VOID)

;;; (DEFUN PRINT-KIF-QUANTIFIED-VARIABLES ...)

(CL:DEFUN PRINT-KIF-QUANTIFIED-VARIABLES (VARIABLES)
  (CL:WHEN
   (CL:EQ VARIABLES NULL)
   (CL:RETURN-FROM PRINT-KIF-QUANTIFIED-VARIABLES))
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:WRITE-STRING "(" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
   (CL:LET*
    ((I NULL)
     (VBL NULL)
     (VECTOR-001 VARIABLES)
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001))
     (ITER-001 1))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       VBL
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
        SGT-KIF-OUT-SKOLEM))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:WRITE-STRING "(" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
     (CL:LET*
      ((VBL-001 VBL))
      (CL:COND
       ((CL:EQ (TAXONOMY-ISA? VBL SGT-KIF-OUT-PATTERN-VARIABLE) 1)
        (CL:LET*
         ((VBL NULL))
         (CL:SETQ VBL VBL-001)
         (PRINT-QUANTIFIED-VARIABLE VBL STREAM)))
       ((CL:EQ (TAXONOMY-ISA? VBL SGT-KIF-OUT-SKOLEM) 1)
        (CL:LET*
         ((VBL NULL))
         (CL:SETQ VBL VBL-001)
         (PRINT-VALUE-OF-CHAIN VBL STREAM VBL)))
       (CL:T (CL:ERROR "`~A' is not a valid case option" VBL))))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
      (CL:WRITE-STRING " " %%STREAM)
      (CL:WRITE-STRING
       (CLSYS-SVAL SURROGATE SYMBOL-NAME (LOGICAL-TYPE VBL))
       %%STREAM)
      (CL:WRITE-STRING ")" %%STREAM))
     (CL:WHEN
      (CL:< I (LENGTH VARIABLES))
      (CL:WRITE-STRING " " (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))))
   (CL:WRITE-STRING ")" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
  :VOID)

;;; (DEFUN PRINT-KIF-QUANTIFICATION ...)

(CL:DEFUN PRINT-KIF-QUANTIFICATION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (TAIL
     (CAST
      (CL:AREF
       (CLSYS-SVAL VECTOR THE-ARRAY (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
       0)
      SGT-KIF-OUT-PROPOSITION))
    (HEAD
     (CAST
      (CL:IF
       (CL:= (LENGTH (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)) 2)
       (CL:AREF
        (CLSYS-SVAL VECTOR THE-ARRAY (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
        1)
       NULL)
      SGT-KIF-OUT-PROPOSITION)))
   (CL:LET*
    ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND SELF)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-FORALL)
      (CL:WRITE-STRING
       "(forall "
       (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
     ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-EXISTS)
      (CL:WRITE-STRING
       "(exists "
       (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
     (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
   (PRINT-KIF-QUANTIFIED-VARIABLES
    (DYNAMIC-SLOT-VALUE SELF SYM-KIF-OUT-IO-VARIABLES NULL))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (INCREASE-INDENT NULL-INTEGER)
   (PRINT-INDENT STREAM NULL-INTEGER)
   (PRINT-KIF-PROPOSITION TAIL)
   (CL:WHEN
    (CL:NOT (CL:EQ HEAD NULL))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (PRINT-INDENT STREAM NULL-INTEGER)
    (PRINT-KIF-PROPOSITION HEAD))
   (DECREASE-INDENT NULL-INTEGER)
   (CL:WRITE-STRING ")" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
  :VOID)

;;; (DEFUN PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION ...)

(CL:DEFUN PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:WRITE-STRING
    "(exists "
    (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
   (PRINT-KIF-QUANTIFIED-VARIABLES (COLLECT-SKOLEMIZED-EXISTS-VARIABLES SELF))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (INCREASE-INDENT NULL-INTEGER)
   (PRINT-INDENT STREAM NULL-INTEGER)
   (PRINT-KIF-PROPOSITION SELF)
   (DECREASE-INDENT NULL-INTEGER)
   (CL:WRITE-STRING ")" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
  :VOID)

;;; (DEFUN PRINT-KIF-LITERAL-WRAPPER ...)

(CL:DEFUN PRINT-KIF-LITERAL-WRAPPER (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:LET*
    ((SELF-001 SELF))
    (CL:COND
     ((CL:EQ (INTEGER? SELF) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:PRINC
        (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE SELF)
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
     ((CL:EQ (FLOAT? SELF) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:PRINC
        (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE SELF)
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
     ((CL:EQ (BOOLEAN? SELF) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:PRINC
        (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE SELF)
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
     ((CL:EQ (STRING? SELF) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:WRITE-STRING
        (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE SELF)
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
     ((CL:EQ (CHARACTER? SELF) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:PRINC
        (CLSYS-SVAL CHARACTER-WRAPPER WRAPPER-VALUE SELF)
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" SELF)))))
  :VOID)

;;; (DEFUN PRINT-KIF-LOGIC-OBJECT ...)

(CL:DEFUN PRINT-KIF-LOGIC-OBJECT (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:IF
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE SELF SYM-KIF-OUT-SURROGATE-VALUE-INVERSE NULL)
      NULL))
    (CL:WRITE-STRING
     (CLSYS-SVAL
      SURROGATE
      SYMBOL-NAME
      (DYNAMIC-SLOT-VALUE SELF SYM-KIF-OUT-SURROGATE-VALUE-INVERSE NULL))
     (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
    (CL:WRITE-STRING
     "Unnamed_Object"
     (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
  :VOID)

;;; (DEFUN PRINT-KIF-SKOLEM ...)

(CL:DEFUN PRINT-KIF-SKOLEM (SELF SUPPRESSDEFININGPROPOSITION?)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*)) (PRINT-SKOLEM SELF STREAM FALSE))
  :VOID)

;;; (DEFUN PRINT-KIF-VARIABLE ...)

(CL:DEFUN PRINT-KIF-VARIABLE (SELF)
  (CL:LET* ((STREAM *PRINTLOGICALFORMSTREAM*)) (PRINT-VARIABLE SELF STREAM))
  :VOID)

;;; (DEFUN PRINT-KIF-ENUMERATION ...)

(CL:DEFUN PRINT-KIF-ENUMERATION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
    (CL:WRITE-STRING "(" %%STREAM)
    (CL:WRITE-STRING
     (CL:IF (CL:EQ (NO-DUPLICATES? SELF) 1) "SETOF" "LISTOF")
     %%STREAM))
   (CL:LET*
    ((M NULL) (ITER-001 (ALLOCATE-ITERATOR SELF)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ M (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:WRITE-STRING " " (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
     (PRINT-AS-KIF M)))
   (CL:WRITE-STRING ")" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
  :VOID)

;;; (DEFUN PRINT-KIF-DESCRIPTION ...)

(CL:DEFUN PRINT-KIF-DESCRIPTION (SELF)
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*))
   (CL:COND
    ((CL:NOT (CL:EQ (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF) NULL))
     (PRINT-OBJECT
      (INTERNAL-STELLA-OPERATOR-TO-KIF (DESCRIPTION-NAME SELF))
      (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
    ((CL:EQ (CLSYS-SVAL DESCRIPTION KIND SELF) KWD-KIF-OUT-ENUMERATION)
     (CL:COND
      ((CL:EQ
        (EXISTS-PROPERTY-PROPOSITION? SELF SGT-KIF-OUT-COLLECTION.ORDERED)
        1)
       (CL:WRITE-STRING
        "(listof"
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
      ((CL:EQ
        (EXISTS-PROPERTY-PROPOSITION?
         SELF
         SGT-KIF-OUT-COLLECTION.DUPLICATE-FREE)
        1)
       (CL:WRITE-STRING
        "(setof"
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
      (CL:T
       (CL:WRITE-STRING
        "(bagof"
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
     (CL:LET*
      ((M NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST (EXTENSION SELF))))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ M (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (CL:WRITE-STRING
        " "
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
       (PRINT-AS-KIF M)))
     (CL:WRITE-STRING ")" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
    (CL:T
     (CL:WRITE-STRING
      "(kappa "
      (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
     (PRINT-KIF-QUANTIFIED-VARIABLES
      (CLSYS-SVAL DESCRIPTION IO-VARIABLES SELF))
     (CL:WRITE-STRING " " (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
     (PRINT-AS-KIF (CLSYS-SVAL DESCRIPTION PROPOSITION SELF))
     (CL:WRITE-STRING ")" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))))
  :VOID)

;;; (DEFCONSTANT FAKE-VARIABLES ...)

(CL:DEFVAR FAKE-VARIABLES NULL
  "Used by 'print-descriptions-as-kif-rule' when there aren't
any real variables to print.")

;;; (DEFCONSTANT REUSABLE-SKOLEM-MAPPING-TABLE ...)

(CL:DEFVAR REUSABLE-SKOLEM-MAPPING-TABLE NULL
  "Stores reusable key-value list for use by
'print-descriptions-as-kif-rule'.")

;;; (DEFUN PRINT-DESCRIPTIONS-AS-KIF-RULE ...)

(CL:DEFUN PRINT-DESCRIPTIONS-AS-KIF-RULE (HEAD TAIL)
  (CL:LOOP
   WHILE
   (CL:< (LENGTH REUSABLE-SKOLEM-MAPPING-TABLE) (ARITY TAIL))
   DO
   (CL:LET*
    ((SELF-001 (NEW-KV-CONS)))
    (CL:SETF
     (CLSYS-SVAL KV-CONS REST SELF-001)
     (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST REUSABLE-SKOLEM-MAPPING-TABLE))
    (CL:SETF
     (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST REUSABLE-SKOLEM-MAPPING-TABLE)
     SELF-001)))
  (CL:LET*
   ((STREAM *PRINTLOGICALFORMSTREAM*)
    (VARIABLES (CLSYS-SVAL DESCRIPTION IO-VARIABLES TAIL))
    (CURRENTINDENTCOUNTER *INDENTCOUNTER*))
   (CL:LET*
    ((*INDENTCOUNTER* CURRENTINDENTCOUNTER))
    (CL:DECLARE (CL:SPECIAL *INDENTCOUNTER*))
    (CL:LET*
     ((HEADVBL NULL)
      (TAILVBL NULL)
      (VECTOR-001 VARIABLES)
      (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001))
      (VECTOR-002 (CLSYS-SVAL DESCRIPTION IO-VARIABLES HEAD))
      (INDEX-002 0)
      (LENGTH-002 (LENGTH VECTOR-002))
      (IT (ALLOCATE-ITERATOR REUSABLE-SKOLEM-MAPPING-TABLE)))
     (CL:LOOP
      WHILE
      (CL:AND
       (CL:< INDEX-001 LENGTH-001)
       (CL:< INDEX-002 LENGTH-002)
       (CL:EQ (NEXT? IT) 1))
      DO
      (CL:PROGN
       (CL:SETQ
        TAILVBL
        (CAST
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
         SGT-KIF-OUT-PATTERN-VARIABLE))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (CL:PROGN
       (CL:SETQ
        HEADVBL
        (CAST
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002)
         SGT-KIF-OUT-PATTERN-VARIABLE))
       (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
      (KEY-SETTER IT HEADVBL)
      (VALUE-SETTER IT TAILVBL)))
    (CL:WRITE-STRING
     "(forall "
     (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
    (PRINT-KIF-QUANTIFIED-VARIABLES VARIABLES)
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (INCREASE-INDENT NULL-INTEGER)
    (PRINT-INDENT STREAM NULL-INTEGER)
    (CL:WRITE-STRING "(<= " (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
    (INCREASE-INDENT 4)
    (CL:LET*
     ((*SKOLEMNAMEMAPPINGTABLE* REUSABLE-SKOLEM-MAPPING-TABLE))
     (CL:DECLARE (CL:SPECIAL *SKOLEMNAMEMAPPINGTABLE*))
     (CL:WHEN
      (CL:EQ (NON-EMPTY? (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES HEAD)) 1)
      (CL:WRITE-STRING
       "(exists "
       (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
      (PRINT-KIF-QUANTIFIED-VARIABLES
       (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES HEAD))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (INCREASE-INDENT NULL-INTEGER)
      (PRINT-INDENT STREAM NULL-INTEGER))
     (PRINT-KIF-PROPOSITION (CLSYS-SVAL DESCRIPTION PROPOSITION HEAD))
     (CL:WHEN
      (CL:EQ (NON-EMPTY? (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES HEAD)) 1)
      (CL:WRITE-STRING ")" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
      (DECREASE-INDENT NULL-INTEGER)))
    (CL:SETF
     (CLSYS-SVAL
      KV-CONS
      VALUE
      (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST REUSABLE-SKOLEM-MAPPING-TABLE))
     NULL)
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CL:WHEN
     (CL:EQ (NON-EMPTY? (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES TAIL)) 1)
     (PRINT-INDENT STREAM NULL-INTEGER)
     (CL:WRITE-STRING
      "(exists "
      (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
     (PRINT-KIF-QUANTIFIED-VARIABLES
      (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES TAIL))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (INCREASE-INDENT NULL-INTEGER))
    (PRINT-INDENT STREAM NULL-INTEGER)
    (PRINT-KIF-PROPOSITION (CLSYS-SVAL DESCRIPTION PROPOSITION TAIL))
    (CL:WHEN
     (CL:EQ (NON-EMPTY? (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES TAIL)) 1)
     (CL:WRITE-STRING ")" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
     (DECREASE-INDENT NULL-INTEGER))
    (CL:WRITE-STRING "))" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
  :VOID)

;;; (DEFSPECIAL *EXCLUDEDPROPOSITIONS* ...)

(CL:DEFVAR *EXCLUDEDPROPOSITIONS* NULL
  "List of propositions that shouldn't be saved by `save-module'.")

(CL:DEFUN READ-*EXCLUDEDPROPOSITIONS* ()
  (CL:RETURN-FROM READ-*EXCLUDEDPROPOSITIONS* *EXCLUDEDPROPOSITIONS*)
  :VOID)

(CL:DEFUN WRITE-*EXCLUDEDPROPOSITIONS* (VALUE)
  (CL:SETQ *EXCLUDEDPROPOSITIONS* VALUE)
  (CL:RETURN-FROM WRITE-*EXCLUDEDPROPOSITIONS* VALUE)
  :VOID)

;;; (DEFUN EXCLUDE-RELATION-ORIGINATED-PROPOSITIONS ...)

(CL:DEFUN EXCLUDE-RELATION-ORIGINATED-PROPOSITIONS ()
  (CL:LET*
   ((CLASS NULL) (ITER-001 (ALL-CLASSES NULL FALSE)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITER-001) 1)
    DO
    (CL:PROGN
     (CL:SETQ
      CLASS
      (CAST (CLSYS-SVAL ITERATOR VALUE ITER-001) SGT-KIF-OUT-CLASS)))
    (CL:LET*
     ((PROP NULL)
      (ITER-002
       (CLSYS-SVAL
        LIST
        THE-CONS-LIST
        (RELATION-ORIGINATED-PROPOSITIONS CLASS))))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-002 NIL))
      DO
      (CL:PROGN
       (CL:SETQ
        PROP
        (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-KIF-OUT-PROPOSITION))
       (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
      (INSERT-AT *EXCLUDEDPROPOSITIONS* PROP (WRAP-BOOLEAN TRUE))))))
  :VOID)

;;; (DEFUN (EXCLUDED-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN EXCLUDED-PROPOSITION? (PROPOSITION)
  (CL:WHEN
   (CL:OR
    (CL:EQ (UNKNOWN? PROPOSITION) 1)
    (CL:NOT (CL:EQ (LOOKUP *EXCLUDEDPROPOSITIONS* PROPOSITION) NULL))
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE PROPOSITION SYM-KIF-OUT-MASTER-PROPOSITION NULL)
      NULL)))
   (CL:RETURN-FROM EXCLUDED-PROPOSITION? TRUE))
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-IN)
     (CL:WHEN
      (CL:OR
       (CL:EQ
        (ISA?
         (CL:AREF
          (CLSYS-SVAL
           VECTOR
           THE-ARRAY
           (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
          0)
         SGT-KIF-OUT-LITERAL-WRAPPER)
        1)
       (CL:EQ
        (FUNCTION-OUTPUT-SKOLEM?
         (CL:AREF
          (CLSYS-SVAL
           VECTOR
           THE-ARRAY
           (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
          0))
        1)
       (CL:EQ
        (ENUMERATED-CLASS?
         (CL:AREF
          (CLSYS-SVAL
           VECTOR
           THE-ARRAY
           (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
          1))
        1))
      (CL:RETURN-FROM EXCLUDED-PROPOSITION? TRUE)))
    ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-FUNCTION)
     (CL:LET*
      ((LASTARG (LAST (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))))
      (CL:WHEN
       (CL:AND
        (CL:EQ (SKOLEM? LASTARG) 1)
        (CL:EQ (EQL? (VALUE-OF LASTARG) LASTARG) 1)
        (CL:EQ (TOP-LEVEL-EXISTS-PROPOSITION? PROPOSITION) 0))
       (CL:RETURN-FROM EXCLUDED-PROPOSITION? TRUE))))
    ((CL:EQ TEST-VALUE-001 KWD-KIF-OUT-PREDICATE)
     (CL:WHEN
      (CL:AND
       (CL:EQ
        (CLSYS-SVAL PROPOSITION OPERATOR PROPOSITION)
        SGT-KIF-OUT-COLLECTION.CLOSED)
       (CL:EQ
        (ENUMERATED-CLASS?
         (CL:AREF
          (CLSYS-SVAL
           VECTOR
           THE-ARRAY
           (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
          0))
        1))
      (CL:RETURN-FROM EXCLUDED-PROPOSITION? TRUE)))
    (CL:T NULL)))
  (CL:RETURN-FROM EXCLUDED-PROPOSITION? FALSE)
  :VOID)

;;; (DEFUN (ENUMERATED-CLASS? BOOLEAN) ...)

(CL:DEFUN ENUMERATED-CLASS? (COLLECTION)
  (CL:SETQ COLLECTION (VALUE-OF COLLECTION))
  (CL:LET*
   ((COLLECTION-001 COLLECTION))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? COLLECTION SGT-KIF-OUT-DESCRIPTION) 1)
     (CL:LET*
      ((COLLECTION NULL))
      (CL:SETQ COLLECTION COLLECTION-001)
      (CL:WHEN
       (CL:AND
        (CL:EQ
         (CLSYS-SVAL DESCRIPTION KIND COLLECTION)
         KWD-KIF-OUT-ENUMERATION)
        (CL:NOT
         (CL:EQ (CLSYS-SVAL DESCRIPTION NATIVE-RELATION COLLECTION) NULL)))
       (CL:RETURN-FROM ENUMERATED-CLASS? TRUE))))
    (CL:T NULL)))
  (CL:RETURN-FROM ENUMERATED-CLASS? FALSE)
  :VOID)

;;; (DEFUN PRETTY-PRINT-RELATION-DEFINITION ...)

(CL:DEFUN PRETTY-PRINT-RELATION-DEFINITION (SELF STREAM)
  (CL:LET*
   ((DEFINITIONSTRING
     (CLSYS-SVAL
      STRING-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-KIF-OUT-RELATION-STRINGIFIED-SOURCE
       NULL-STRING-WRAPPER))))
   (CL:WHEN
    (CL:EQ DEFINITIONSTRING NULL)
    (CL:LET*
     ((SELF-001 SELF))
     (CL:COND
      ((CL:EQ (CLASS? SELF) 1)
       (CL:LET*
        ((SELF NULL))
        (CL:SETQ SELF SELF-001)
        (CL:SETQ
         DEFINITIONSTRING
         (CLSYS-SVAL CLASS CLASS-STRINGIFIED-SOURCE SELF))))
      (CL:T NULL))))
   (CL:WHEN
    (CL:NOT (CL:EQ DEFINITIONSTRING NULL))
    (PRETTY-PRINT-RELATION-DEFINITION-TREE
     (CAST (UNSTRINGIFY DEFINITIONSTRING) SGT-KIF-OUT-CONS)
     STREAM)))
  :VOID)

;;; (DEFUN PRETTY-PRINT-RELATION-DEFINITION-TREE ...)

(CL:DEFUN PRETTY-PRINT-RELATION-DEFINITION-TREE (TREE STREAM)
  (HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE TREE STREAM 0 2 TRUE)
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  (FREE-PARSE-TREE TREE)
  :VOID)

;;; (DEFUN HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE ...)

(CL:DEFUN HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE (TREE STREAM STARTINDENT KEYINDENT FORCEFIRSTKEYONSEPARATELINE?)
  (CL:LET*
   ((*PRINTREADABLY?* TRUE) (*PRINTPRETTY?* TRUE))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?* *PRINTPRETTY?*))
   (CL:LET*
    ((VALUE-001 NULL))
    (CL:LET*
     ((ELEMENT NULL) (ITER-001 TREE))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ ELEMENT (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:WHEN
       (CL:EQ (KEYWORD? ELEMENT) 1)
       (CL:SETQ VALUE-001 ELEMENT)
       (CL:RETURN))))
    (CL:LET*
     ((NOFHEADERELEMENTS (POSITION TREE VALUE-001 0)))
     (CL:LET*
      ((SELF-001 (NEW-PROPERTY-LIST)))
      (CL:SETF
       (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF-001)
       (EXTRACT-OPTIONS TREE NULL))
      (CL:LET*
       ((OPTIONS SELF-001) (KEYLENGTH NULL-INTEGER))
       (CL:WHEN
        (CL:EQ (NULL? NOFHEADERELEMENTS) 1)
        (CL:SETQ NOFHEADERELEMENTS (LENGTH TREE)))
       (CL:SETQ
        FORCEFIRSTKEYONSEPARATELINE?
        (CL:IF
         (CL:OR
          (CL:EQ FORCEFIRSTKEYONSEPARATELINE? 1)
          (CL:> (LENGTH OPTIONS) 1))
         TRUE
         FALSE))
       (CL:WRITE-STRING "(" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
       (CL:LET*
        ((I NULL)
         (ELEMENT NULL)
         (ITER-002 TREE)
         (ITER-003 1)
         (UPPER-BOUND-001 NOFHEADERELEMENTS)
         (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
        (CL:LOOP
         WHILE
         (CL:AND
          (CL:NOT (CL:EQ ITER-002 NIL))
          (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-003 UPPER-BOUND-001)))
         DO
         (CL:PROGN
          (CL:SETQ ELEMENT (CLSYS-SVAL CONS VALUE ITER-002))
          (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
         (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
         (CL:WHEN
          (CL:> I 1)
          (CL:WRITE-STRING
           " "
           (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
         (PRINT-OBJECT
          ELEMENT
          (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
       (CL:LET*
        ((I NULL)
         (VALUE NULL)
         (KEY NULL)
         (ITER-004 (CLSYS-SVAL PROPERTY-LIST THE-PLIST OPTIONS))
         (ITER-005 1))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-004 NIL))
         DO
         (CL:SETQ KEY (CLSYS-SVAL CONS VALUE ITER-004))
         (CL:PROGN
          (CL:SETQ
           VALUE
           (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST ITER-004)))
          (CL:SETQ
           ITER-004
           (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST ITER-004))))
         (CL:PROGN (CL:SETQ I ITER-005) (CL:SETQ ITER-005 (CL:1+ ITER-005)))
         (CL:COND
          ((CL:AND (CL:= I 1) (CL:EQ FORCEFIRSTKEYONSEPARATELINE? 0))
           (CL:WHEN
            (CL:> NOFHEADERELEMENTS 0)
            (CL:WRITE-STRING
             " "
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
          (CL:T
           (CL:LET
            ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM))
           (PRINT-INDENT STREAM (CL:+ STARTINDENT KEYINDENT))))
         (CL:LET*
          ((KEY-001 KEY))
          (CL:COND
           ((CL:EQ (KEYWORD? KEY) 1)
            (CL:LET*
             ((KEY NULL))
             (CL:SETQ KEY KEY-001)
             (CL:SETQ
              KEYLENGTH
              (CL:1+ (LENGTH (CLSYS-SVAL KEYWORD SYMBOL-NAME KEY))))
             (CL:LET
              ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
              (CL:WRITE-STRING ":" %%STREAM)
              (CL:WRITE-STRING
               (STRING-DOWNCASE (CLSYS-SVAL KEYWORD SYMBOL-NAME KEY))
               %%STREAM))))
           (CL:T
            (CL:SETQ KEYLENGTH 4)
            (PRINT-OBJECT
             KEY
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))))
         (CL:WRITE-STRING " " (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
         (CL:COND
          ((CL:AND
            (CL:OR
             (CL:EQ KEY KWD-KIF-OUT-SLOTS)
             (CL:EQ KEY KWD-KIF-OUT-PUBLIC-SLOTS)
             (CL:EQ KEY KWD-KIF-OUT-METHODS)
             (CL:EQ KEY KWD-KIF-OUT-PUBLIC-METHODS))
            (CL:EQ (CONS? VALUE) 1))
           (CL:WRITE-STRING
            "("
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
           (CL:LET*
            ((I NULL)
             (ELEMENT NULL)
             (ITER-006 (CAST VALUE SGT-KIF-OUT-CONS))
             (ITER-007 1))
            (CL:LOOP
             WHILE
             (CL:NOT (CL:EQ ITER-006 NIL))
             DO
             (CL:PROGN
              (CL:SETQ ELEMENT (CLSYS-SVAL CONS VALUE ITER-006))
              (CL:SETQ ITER-006 (CLSYS-SVAL CONS REST ITER-006)))
             (CL:PROGN
              (CL:SETQ I ITER-007)
              (CL:SETQ ITER-007 (CL:1+ ITER-007)))
             (CL:WHEN
              (CL:> I 1)
              (CL:LET
               ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
               (CL:TERPRI %%STREAM)
               (CL:FORCE-OUTPUT %%STREAM))
              (PRINT-INDENT STREAM (CL:+ KEYINDENT (CL:+ KEYLENGTH 2))))
             (CL:IF
              (CL:EQ (CONS? ELEMENT) 1)
              (HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE
               (CAST ELEMENT SGT-KIF-OUT-CONS)
               STREAM
               (CL:+ STARTINDENT (CL:+ KEYINDENT (CL:+ KEYLENGTH 2)))
               KEYINDENT
               FALSE)
              (PRINT-OBJECT
               VALUE
               (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))))
           (CL:WRITE-STRING
            ")"
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
          (CL:T
           (PRINT-OBJECT
            VALUE
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))))
       (CL:LET*
        ((ELEMENT NULL) (ITER-008 (NTH-REST TREE NOFHEADERELEMENTS)))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-008 NIL))
         DO
         (CL:PROGN
          (CL:SETQ ELEMENT (CLSYS-SVAL CONS VALUE ITER-008))
          (CL:SETQ ITER-008 (CLSYS-SVAL CONS REST ITER-008)))
         (CL:LET
          ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))
         (PRINT-INDENT STREAM KEYINDENT)
         (PRINT-OBJECT
          ELEMENT
          (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))))
       (CL:WRITE-STRING ")" (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM))
       (FREE OPTIONS))))))
  :VOID)

;;; (DEFUN PRETTY-PRINT-ASSERTION ...)

(CL:DEFUN PRETTY-PRINT-ASSERTION (PROPOSITION STREAM)
  (CL:LET*
   ((OPERATOR SYM-KIF-OUT-ASSERT)
    (NAME
     (DYNAMIC-SLOT-VALUE
      PROPOSITION
      SYM-KIF-OUT-SURROGATE-VALUE-INVERSE
      NULL)))
   (CL:WHEN
    (CL:NOT (CL:EQ NAME NULL))
    (PRETTY-PRINT-NAMED-RULE NAME STREAM)
    (CL:RETURN-FROM PRETTY-PRINT-ASSERTION))
   (CL:LET*
    ((*PRINTMODE* KWD-KIF-OUT-ORIGINAL)
     (*PRINTLOGICALFORMSTREAM* STREAM)
     (*INDENTCOUNTER* 8))
    (CL:DECLARE
     (CL:SPECIAL *PRINTMODE* *PRINTLOGICALFORMSTREAM* *INDENTCOUNTER*))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
     (CL:WRITE-STRING "(" %%STREAM)
     (PRINT-OBJECT OPERATOR %%STREAM)
     (CL:WRITE-STRING " " %%STREAM))
    (PRETTY-PRINT-LOGICAL-FORM PROPOSITION STREAM)
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
     (CL:WRITE-STRING ")" %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))))
  :VOID)

;;; (DEFUN PRETTY-PRINT-NAMED-RULE ...)

(CL:DEFUN PRETTY-PRINT-NAMED-RULE (RULENAME STREAM)
  (CL:LET*
   ((OPERATOR SYM-KIF-OUT-DEFRULE)
    (PROPOSITION
     (CAST
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE RULENAME)
      SGT-KIF-OUT-PROPOSITION)))
   (CL:LET*
    ((*PRINTMODE* KWD-KIF-OUT-ORIGINAL)
     (*PRINTLOGICALFORMSTREAM* STREAM)
     (*INDENTCOUNTER* 2))
    (CL:DECLARE
     (CL:SPECIAL *PRINTMODE* *PRINTLOGICALFORMSTREAM* *INDENTCOUNTER*))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
     (CL:WRITE-STRING "(" %%STREAM)
     (PRINT-OBJECT OPERATOR %%STREAM)
     (CL:WRITE-STRING " " %%STREAM)
     (PRINT-OBJECT (TYPE-TO-SYMBOL RULENAME) %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (PRINT-INDENT STREAM NULL-INTEGER)
    (PRETTY-PRINT-LOGICAL-FORM PROPOSITION STREAM)
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STREAM)))
     (CL:WRITE-STRING ")" %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))))
  :VOID)

;;; (DEFUN DO-SAVE-MODULE ...)

(CL:DEFUN DO-SAVE-MODULE (MODULE FILE)
  "Save `module' to `file'."
  (CL:LET*
   ((STREAM (NEW-OUTPUT-FILE-STREAM FILE)))
   (CL:LET*
    ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL-OUTPUT-FILE-HEADER STREAM "STELLA" FALSE FALSE)
    (PRINT-DEFINITION MODULE STREAM)
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-FILE-STREAM NATIVE-STREAM STREAM)))
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-FILE-STREAM NATIVE-STREAM STREAM)))
     (CL:WRITE-STRING "(in-module \"" %%STREAM)
     (CL:WRITE-STRING (CLSYS-SVAL MODULE MODULE-FULL-NAME MODULE) %%STREAM)
     (CL:WRITE-STRING "\")" %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:WRITE-STRING "(in-dialect " %%STREAM)
     (PRINT-OBJECT *LOGIC-DIALECT* %%STREAM)
     (CL:WRITE-STRING ")" %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CL:LET*
     ((CLASS NULL) (ITER-001 (ALL-CLASSES MODULE TRUE)))
     (CL:LOOP
      WHILE
      (CL:EQ (NEXT? ITER-001) 1)
      DO
      (CL:PROGN
       (CL:SETQ
        CLASS
        (CAST (CLSYS-SVAL ITERATOR VALUE ITER-001) SGT-KIF-OUT-CLASS)))
      (PRETTY-PRINT-RELATION-DEFINITION CLASS STREAM)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-FILE-STREAM NATIVE-STREAM STREAM)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:LET*
       ((SLOT NULL)
        (ITER-002
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (CLSYS-SVAL CLASS CLASS-LOCAL-SLOTS CLASS))))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-002 NIL))
        DO
        (CL:PROGN
         (CL:SETQ
          SLOT
          (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-KIF-OUT-SLOT))
         (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
        (CL:WHEN
         (CL:NOT
          (CL:EQ
           (CLSYS-SVAL
            STRING-WRAPPER
            WRAPPER-VALUE
            (DYNAMIC-SLOT-VALUE
             SLOT
             SYM-KIF-OUT-RELATION-STRINGIFIED-SOURCE
             NULL-STRING-WRAPPER))
           NULL))
         (PRETTY-PRINT-RELATION-DEFINITION SLOT STREAM)
         (CL:LET
          ((%%STREAM (CLSYS-SVAL OUTPUT-FILE-STREAM NATIVE-STREAM STREAM)))
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)))))))
    (CL:LET*
     ((FUNCTION NULL) (ITER-003 (ALL-FUNCTIONS MODULE TRUE)))
     (CL:LOOP
      WHILE
      (CL:EQ (NEXT? ITER-003) 1)
      DO
      (CL:PROGN
       (CL:SETQ
        FUNCTION
        (CAST (CLSYS-SVAL ITERATOR VALUE ITER-003) SGT-KIF-OUT-FUNCTION)))
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (CLSYS-SVAL
          STRING-WRAPPER
          WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE
           FUNCTION
           SYM-KIF-OUT-RELATION-STRINGIFIED-SOURCE
           NULL-STRING-WRAPPER))
         NULL))
       (PRETTY-PRINT-RELATION-DEFINITION FUNCTION STREAM)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-FILE-STREAM NATIVE-STREAM STREAM)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)))))
    (CL:LET*
     ((*EXCLUDEDPROPOSITIONS* (NEW-HASH-TABLE)))
     (CL:DECLARE (CL:SPECIAL *EXCLUDEDPROPOSITIONS*))
     (EXCLUDE-RELATION-ORIGINATED-PROPOSITIONS)
     (CL:LET*
      ((PROPOSITION NULL)
       (ITER-004
        (CLSYS-SVAL
         LIST
         THE-CONS-LIST
         (REVERSE (COPY (LOCALLY-CONCEIVED-PROPOSITIONS-GETTER MODULE))))))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-004 NIL))
       DO
       (CL:PROGN
        (CL:SETQ
         PROPOSITION
         (CAST (CLSYS-SVAL CONS VALUE ITER-004) SGT-KIF-OUT-PROPOSITION))
        (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
       (CL:WHEN
        (CL:EQ (EXCLUDED-PROPOSITION? PROPOSITION) 0)
        (PRETTY-PRINT-ASSERTION PROPOSITION STREAM)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-FILE-STREAM NATIVE-STREAM STREAM)))
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))))))
    (FREE STREAM)))
  :VOID)

;;; (DEFUN SAVE-MODULE ...)

(CL:DEFUN %%SAVE-MODULE (NAME FILE)
  "Save all definitions and assertions of module `name' to `file'."
  (CL:LET*
   ((MODULE (COERCE-TO-MODULE NAME TRUE)))
   (CL:WHEN (CL:NOT (CL:EQ MODULE NULL)) (DO-SAVE-MODULE MODULE FILE)))
  :VOID)

(CL:DEFUN SAVE-MODULE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%%SAVE-MODULE
   (CLSYS-SVAL CONS VALUE ARGUMENTS)
   (CLSYS-SVAL
    STRING-WRAPPER
    WRAPPER-VALUE
    (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST ARGUMENTS))))
  :VOID)

(CL:DEFMACRO SAVE-MODULE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Save all definitions and assertions of module `name' to `file'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/SAVE-MODULE)) (CL:MACRO-FUNCTION (CL:QUOTE SAVE-MODULE)))

(CL:DEFUN STARTUP-KIF-OUT ()
  (CL:LET*
   ((*MODULE* (GET-MODULE "/LOGIC" TRUE)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SGT-KIF-OUT-LITERAL-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "LITERAL-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-KIF-OUT-LOGIC-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
    (CL:SETQ
     SGT-KIF-OUT-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
    (CL:SETQ
     KWD-KIF-OUT-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     SYM-KIF-OUT-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
    (CL:SETQ
     SGT-KIF-OUT-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-KIF-OUT-ALL-FACTS-OF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-FACTS-OF" NULL 0))
    (CL:SETQ
     KWD-KIF-OUT-COMMON-LISP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
    (CL:SETQ
     SGT-KIF-OUT-SKOLEM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
    (CL:SETQ
     SYM-KIF-OUT-RETRACT-FACTS-OF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-FACTS-OF" NULL 0))
    (CL:SETQ
     SYM-KIF-OUT-*PRETTYPRINTLOGICALFORMS?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*PRETTYPRINTLOGICALFORMS?*" NULL 0))
    (CL:SETQ
     SYM-KIF-OUT-*PRETTYPRINTKIF?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*PRETTYPRINTKIF?*" NULL 0))
    (CL:SETQ
     SYM-KIF-OUT-*PRINTLOGICALFORMSTREAM*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*PRINTLOGICALFORMSTREAM*" NULL 0))
    (CL:SETQ
     SYM-KIF-OUT-*DOWNCASEOPERATORS?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*DOWNCASEOPERATORS?*" NULL 0))
    (CL:SETQ
     SYM-KIF-OUT-*INDENTCOUNTER*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*INDENTCOUNTER*" NULL 0))
    (CL:SETQ KWD-KIF-OUT-KIF (INTERN-RIGID-SYMBOL-WRT-MODULE "KIF" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-STELLA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-PREFIX-STELLA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PREFIX-STELLA" NULL 2))
    (CL:SETQ KWD-KIF-OUT-SQL (INTERN-RIGID-SYMBOL-WRT-MODULE "SQL" NULL 2))
    (CL:SETQ
     SGT-KIF-OUT-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
    (CL:SETQ
     SGT-KIF-OUT-PATTERN-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
    (CL:SETQ
     SGT-KIF-OUT-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "COLLECTION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ KWD-KIF-OUT-IN (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-REALISTIC
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REALISTIC" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-ORIGINAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ORIGINAL" NULL 2))
    (CL:SETQ
     SGT-KIF-OUT-SLOTREF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTREF" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-KIF-OUT-*TOPLEVELPRINTKIFPROPOSITION?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*TOPLEVELPRINTKIFPROPOSITION?*" NULL 0))
    (CL:SETQ KWD-KIF-OUT-AND (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
    (CL:SETQ KWD-KIF-OUT-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
    (CL:SETQ KWD-KIF-OUT-NOT (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-EQUIVALENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-PREDICATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-IMPLIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-FORALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-EXISTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-CONSTANT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-CONTAINED-BY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTAINED-BY" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-DELETED
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DELETED" NULL 2))
    (CL:SETQ
     SGT-KIF-OUT-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-KIF-OUT-IO-VARIABLES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
    (CL:SETQ
     SYM-KIF-OUT-SURROGATE-VALUE-INVERSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE-INVERSE" NULL 0))
    (CL:SETQ
     KWD-KIF-OUT-ENUMERATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ENUMERATION" NULL 2))
    (CL:SETQ
     SGT-KIF-OUT-COLLECTION.ORDERED
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION.ORDERED" NULL 1))
    (CL:SETQ
     SGT-KIF-OUT-COLLECTION.DUPLICATE-FREE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION.DUPLICATE-FREE" NULL 1))
    (CL:SETQ SYM-KIF-OUT-?X (INTERN-RIGID-SYMBOL-WRT-MODULE "?X" NULL 0))
    (CL:SETQ SYM-KIF-OUT-?Y (INTERN-RIGID-SYMBOL-WRT-MODULE "?Y" NULL 0))
    (CL:SETQ SYM-KIF-OUT-?Z (INTERN-RIGID-SYMBOL-WRT-MODULE "?Z" NULL 0))
    (CL:SETQ
     SGT-KIF-OUT-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-KIF-OUT-SKOLEM-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM-NAME" NULL 0))
    (CL:SETQ
     SYM-KIF-OUT-*EXCLUDEDPROPOSITIONS*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*EXCLUDEDPROPOSITIONS*" NULL 0))
    (CL:SETQ
     SGT-KIF-OUT-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-KIF-OUT-MASTER-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
    (CL:SETQ
     SGT-KIF-OUT-COLLECTION.CLOSED
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "COLLECTION.CLOSED"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-KIF-OUT-RELATION-STRINGIFIED-SOURCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-STRINGIFIED-SOURCE" NULL 0))
    (CL:SETQ
     SGT-KIF-OUT-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     KWD-KIF-OUT-SLOTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTS" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-PUBLIC-SLOTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC-SLOTS" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-METHODS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHODS" NULL 2))
    (CL:SETQ
     KWD-KIF-OUT-PUBLIC-METHODS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC-METHODS" NULL 2))
    (CL:SETQ
     SYM-KIF-OUT-ASSERT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT" NULL 0))
    (CL:SETQ
     SYM-KIF-OUT-DEFRULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFRULE" NULL 0))
    (CL:SETQ
     SGT-KIF-OUT-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "FUNCTION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-KIF-OUT-SAVE-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVE-MODULE" NULL 0))
    (CL:SETQ
     SYM-KIF-OUT-EVALUATOR-WRAPPER-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "EVALUATOR-WRAPPER-CODE"
      (GET-MODULE "/STELLA" TRUE)
      0)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:SETQ FAKE-VARIABLES (NEW-VECTOR 3))
    (CL:SETQ REUSABLE-SKOLEM-MAPPING-TABLE (NEW-KEY-VALUE-LIST)))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECT-FUNCTION-PROPOSITION-FACTS"
        "PROPOSITION"
        "(DEFUN COLLECT-FUNCTION-PROPOSITION-FACTS ((SELF PROPOSITION) (FACTS (LIST OF PROPOSITION)) (BEENTHERE (LIST OF PROPOSITION))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECT-FUNCTION-PROPOSITION-FACTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-COLLECT-FACTS"
        "OBJECT"
        "(DEFUN HELP-COLLECT-FACTS ((SELF OBJECT) (FACTS (LIST OF PROPOSITION)) (BEENTHERE (LIST OF PROPOSITION))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-COLLECT-FACTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-FACTS-OF-OBJECT"
        "LOGIC-OBJECT"
        "(DEFUN (ALL-FACTS-OF-OBJECT (LIST OF PROPOSITION)) ((SELF LOGIC-OBJECT)) :DOCUMENTATION \"Return a list of all definite (TRUE or FALSE) propositions
attached to `self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-FACTS-OF-OBJECT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-LOGIC-OBJECT"
        "STRING"
        "(DEFUN (GET-LOGIC-OBJECT LOGIC-OBJECT) ((NAME STRING)) :DOCUMENTATION \"Return the logic object named 'name'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-LOGIC-OBJECT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-FACTS-OF"
        "OBJECT"
        "(DEFUN (ALL-FACTS-OF (LIST OF PROPOSITION)) ((NAME NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Return a list of all definite (TRUE or FALSE) propositions
that reference the logic-object named `name'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%ALL-FACTS-OF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RETRACT-FACTS-OF-OBJECT"
        "LOGIC-OBJECT"
        "(DEFUN RETRACT-FACTS-OF-OBJECT ((SELF LOGIC-OBJECT)) :DOCUMENTATION \"Retract all definite (TRUE or FALSE) propositions attached to `self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RETRACT-FACTS-OF-OBJECT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RETRACT-FACTS-OF"
        "OBJECT"
        "(DEFUN RETRACT-FACTS-OF ((NAME NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Retract all definite (TRUE or FALSE) propositions
that reference the logic-object named `name'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%RETRACT-FACTS-OF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MAYBE-DOWNCASE"
        "STRING"
        "(DEFUN (MAYBE-DOWNCASE STRING) ((STRING STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MAYBE-DOWNCASE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INCREASE-INDENT"
        "INTEGER"
        "(DEFUN INCREASE-INDENT ((INDENT INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INCREASE-INDENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DECREASE-INDENT"
        "INTEGER"
        "(DEFUN DECREASE-INDENT ((INDENT INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DECREASE-INDENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-INDENT"
        "OUTPUT-STREAM"
        "(DEFUN PRINT-INDENT ((STREAM OUTPUT-STREAM) (INDENT INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-INDENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-LOGICAL-FORM-IN-DIALECT"
        "OBJECT"
        "(DEFUN PRINT-LOGICAL-FORM-IN-DIALECT ((SELF OBJECT) (DIALECT KEYWORD) (STREAM OUTPUT-STREAM)) :DOCUMENTATION \"Produce a stringified version of a logical representation
of 'self' and write it to the stream 'stream'.  Use the dialect 'dialect',
or use the current dialect if 'dialect' is NULL.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-LOGICAL-FORM-IN-DIALECT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-LOGICAL-FORM"
        "OBJECT"
        "(DEFUN PRINT-LOGICAL-FORM ((FORM OBJECT) (STREAM OUTPUT-STREAM)) :DOCUMENTATION \"Print the logical form `form' to `stream' according to
the current setting of `*logic-dialect*'.  Pretty-printing is controlled
by the current setting of `*prettyPrintLogicalForms?*'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-LOGICAL-FORM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRETTY-PRINT-LOGICAL-FORM"
        "OBJECT"
        "(DEFUN PRETTY-PRINT-LOGICAL-FORM ((FORM OBJECT) (STREAM OUTPUT-STREAM)) :DOCUMENTATION \"Pretty-print the logical form `form' to `stream' according
to the current setting of `*logic-dialect*'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRETTY-PRINT-LOGICAL-FORM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-UNFORMATTED-LOGICAL-FORM"
        "OBJECT"
        "(DEFUN PRINT-UNFORMATTED-LOGICAL-FORM ((FORM OBJECT) (STREAM OUTPUT-STREAM)) :DOCUMENTATION \"Print the logical form `form' to `stream' according to
the current setting of `*logic-dialect*'.  Pretty-printing is explicitly
forced to be turned off.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-UNFORMATTED-LOGICAL-FORM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-AS-KIF"
        "OBJECT"
        "(DEFUN PRINT-AS-KIF ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-AS-KIF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VISIBLE-ARGUMENT?"
        "OBJECT"
        "(DEFUN (VISIBLE-ARGUMENT? BOOLEAN) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VISIBLE-ARGUMENT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VISIBLE-ARGUMENTS-COUNT"
        "VECTOR"
        "(DEFUN (VISIBLE-ARGUMENTS-COUNT INTEGER) ((ARGUMENTS ARGUMENTS-VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VISIBLE-ARGUMENTS-COUNT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-ARGUMENTS"
        "VECTOR"
        "(DEFUN PRINT-KIF-ARGUMENTS ((ARGUMENTS ARGUMENTS-VECTOR) (SEPARATELINES? BOOLEAN) (OMITLASTARGUMENT? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-OPERATOR-WITH-ARGUMENTS"
        "STRING"
        "(DEFUN PRINT-KIF-OPERATOR-WITH-ARGUMENTS ((OPERATOR STRING) (ARGUMENTS ARGUMENTS-VECTOR) (SEPARATELINES? BOOLEAN) (OMITLASTARGUMENT? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-OPERATOR-WITH-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRINGIFIED-KIF-OPERATOR"
        "PROPOSITION"
        "(DEFUN (STRINGIFIED-KIF-OPERATOR STRING) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRINGIFIED-KIF-OPERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-PROPOSITION"
        "PROPOSITION"
        "(DEFUN PRINT-KIF-PROPOSITION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-PRINT-KIF-PROPOSITION"
        "PROPOSITION"
        "(DEFUN HELP-PRINT-KIF-PROPOSITION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-PRINT-KIF-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-FUNCTION-PROPOSITION"
        "PROPOSITION"
        "(DEFUN PRINT-KIF-FUNCTION-PROPOSITION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-FUNCTION-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-FUNCTION-EXPRESSION"
        "PROPOSITION"
        "(DEFUN PRINT-KIF-FUNCTION-EXPRESSION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-FUNCTION-EXPRESSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-IN-PROPOSITION"
        "PROPOSITION"
        "(DEFUN PRINT-KIF-IN-PROPOSITION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-IN-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-IMPLIES-PROPOSITION"
        "PROPOSITION"
        "(DEFUN PRINT-KIF-IMPLIES-PROPOSITION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-IMPLIES-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-QUANTIFIED-VARIABLES"
        "VECTOR"
        "(DEFUN PRINT-KIF-QUANTIFIED-VARIABLES ((VARIABLES (VECTOR OF SKOLEM))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-QUANTIFIED-VARIABLES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-QUANTIFICATION"
        "PROPOSITION"
        "(DEFUN PRINT-KIF-QUANTIFICATION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-QUANTIFICATION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION"
        "PROPOSITION"
        "(DEFUN PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-TOP-LEVEL-EXISTS-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-LITERAL-WRAPPER"
        "LITERAL-WRAPPER"
        "(DEFUN PRINT-KIF-LITERAL-WRAPPER ((SELF LITERAL-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-LITERAL-WRAPPER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-LOGIC-OBJECT"
        "LOGIC-OBJECT"
        "(DEFUN PRINT-KIF-LOGIC-OBJECT ((SELF LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-LOGIC-OBJECT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-SKOLEM"
        "SKOLEM"
        "(DEFUN PRINT-KIF-SKOLEM ((SELF SKOLEM) (SUPPRESSDEFININGPROPOSITION? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-SKOLEM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-VARIABLE"
        "PATTERN-VARIABLE"
        "(DEFUN PRINT-KIF-VARIABLE ((SELF PATTERN-VARIABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-ENUMERATION"
        "COLLECTION"
        "(DEFUN PRINT-KIF-ENUMERATION ((SELF COLLECTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-ENUMERATION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-KIF-DESCRIPTION"
        "DESCRIPTION"
        "(DEFUN PRINT-KIF-DESCRIPTION ((SELF DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-KIF-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-DESCRIPTIONS-AS-KIF-RULE"
        "DESCRIPTION"
        "(DEFUN PRINT-DESCRIPTIONS-AS-KIF-RULE ((HEAD DESCRIPTION) (TAIL DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-DESCRIPTIONS-AS-KIF-RULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXCLUDE-RELATION-ORIGINATED-PROPOSITIONS"
        NULL
        "(DEFUN EXCLUDE-RELATION-ORIGINATED-PROPOSITIONS ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXCLUDE-RELATION-ORIGINATED-PROPOSITIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXCLUDED-PROPOSITION?"
        "PROPOSITION"
        "(DEFUN (EXCLUDED-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXCLUDED-PROPOSITION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ENUMERATED-CLASS?"
        "OBJECT"
        "(DEFUN (ENUMERATED-CLASS? BOOLEAN) ((COLLECTION OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ENUMERATED-CLASS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRETTY-PRINT-RELATION-DEFINITION"
        "RELATION"
        "(DEFUN PRETTY-PRINT-RELATION-DEFINITION ((SELF RELATION) (STREAM OUTPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRETTY-PRINT-RELATION-DEFINITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRETTY-PRINT-RELATION-DEFINITION-TREE"
        "CONS"
        "(DEFUN PRETTY-PRINT-RELATION-DEFINITION-TREE ((TREE CONS) (STREAM OUTPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRETTY-PRINT-RELATION-DEFINITION-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE"
        "CONS"
        "(DEFUN HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE ((TREE CONS) (STREAM OUTPUT-STREAM) (STARTINDENT INTEGER) (KEYINDENT INTEGER) (FORCEFIRSTKEYONSEPARATELINE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-PRETTY-PRINT-RELATION-DEFINITION-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRETTY-PRINT-ASSERTION"
        "PROPOSITION"
        "(DEFUN PRETTY-PRINT-ASSERTION ((PROPOSITION PROPOSITION) (STREAM OUTPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRETTY-PRINT-ASSERTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRETTY-PRINT-NAMED-RULE"
        "SURROGATE"
        "(DEFUN PRETTY-PRINT-NAMED-RULE ((RULENAME SURROGATE) (STREAM OUTPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRETTY-PRINT-NAMED-RULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DO-SAVE-MODULE"
        "MODULE"
        "(DEFUN DO-SAVE-MODULE ((MODULE MODULE) (FILE STRING)) :DOCUMENTATION \"Save `module' to `file'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DO-SAVE-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SAVE-MODULE"
        "OBJECT"
        "(DEFUN SAVE-MODULE ((NAME NAME) (FILE STRING)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Save all definitions and assertions of module `name' to `file'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%SAVE-MODULE))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-KIF-OUT-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION SAVE-MODULE-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-KIF-OUT"
     NULL
     "(DEFUN STARTUP-KIF-OUT ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (REGISTER-NATIVE-NAME
     SYM-KIF-OUT-ALL-FACTS-OF
     KWD-KIF-OUT-COMMON-LISP
     KWD-KIF-OUT-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-KIF-OUT-RETRACT-FACTS-OF
     KWD-KIF-OUT-COMMON-LISP
     KWD-KIF-OUT-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PRETTYPRINTLOGICALFORMS?* BOOLEAN FALSE :DOCUMENTATION \"Controls whether logical forms print on single lines
(unformatted) or multi-line indented.\")")
    (CL:LET*
     ((GLOBAL
       (LOOKUP-GLOBAL-VARIABLE SYM-KIF-OUT-*PRETTYPRINTLOGICALFORMS?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*PRETTYPRINTLOGICALFORMS?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*PRETTYPRINTLOGICALFORMS?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PRETTYPRINTKIF?* BOOLEAN FALSE :DOCUMENTATION \"Controls whether KIF expressions print on single lines
(unformatted) or multi-line indented.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-KIF-OUT-*PRETTYPRINTKIF?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*PRETTYPRINTKIF?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*PRETTYPRINTKIF?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PRINTLOGICALFORMSTREAM* OUTPUT-STREAM NULL :DOCUMENTATION \"Eliminates necessity of passing stream argument
throughout 'print-logical-form' functions.\" :PUBLIC? FALSE)")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-KIF-OUT-*PRINTLOGICALFORMSTREAM*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*PRINTLOGICALFORMSTREAM*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*PRINTLOGICALFORMSTREAM*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DOWNCASEOPERATORS?* BOOLEAN FALSE :DOCUMENTATION \"Controls whether down-casing happens during logical
form printing (leading to lots more string garbage).\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-KIF-OUT-*DOWNCASEOPERATORS?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*DOWNCASEOPERATORS?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*DOWNCASEOPERATORS?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *INDENTCOUNTER* INTEGER 0 :DOCUMENTATION \"The number of spaces prepended during printing a logical form.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-KIF-OUT-*INDENTCOUNTER*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*INDENTCOUNTER*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*INDENTCOUNTER*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INDENT-QUANTUM* INTEGER 3 :DOCUMENTATION \"The number of spaces added by a call to 'increase-indent'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TOPLEVELPRINTKIFPROPOSITION?* BOOLEAN TRUE)")
    (CL:LET*
     ((GLOBAL
       (LOOKUP-GLOBAL-VARIABLE SYM-KIF-OUT-*TOPLEVELPRINTKIFPROPOSITION?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*TOPLEVELPRINTKIFPROPOSITION?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*TOPLEVELPRINTKIFPROPOSITION?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT FAKE-VARIABLES VARIABLES-VECTOR (NEW VARIABLES-VECTOR :ARRAY-SIZE 3) :DOCUMENTATION \"Used by 'print-descriptions-as-kif-rule' when there aren't
any real variables to print.\")")
    (CL:LET*
     ((I NULL)
      (NAME NULL)
      (ITER-068 (LIST* SYM-KIF-OUT-?X SYM-KIF-OUT-?Y SYM-KIF-OUT-?Z NIL))
      (ITER-069 0))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-068 NIL))
      DO
      (CL:PROGN
       (CL:SETQ NAME (CLSYS-SVAL CONS VALUE ITER-068))
       (CL:SETQ ITER-068 (CLSYS-SVAL CONS REST ITER-068)))
      (CL:PROGN (CL:SETQ I ITER-069) (CL:SETQ ITER-069 (CL:1+ ITER-069)))
      (CL:LET*
       ((SELF-070 (NEW-PATTERN-VARIABLE)))
       (SET-DYNAMIC-SLOT-VALUE
        SELF-070
        SYM-KIF-OUT-SKOLEM-NAME
        (CAST NAME SGT-KIF-OUT-SYMBOL)
        NULL)
       (CL:SETF
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY FAKE-VARIABLES) I)
        SELF-070))))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT REUSABLE-SKOLEM-MAPPING-TABLE (KEY-VALUE-LIST OF SKOLEM SKOLEM) (NEW KEY-VALUE-LIST) :DOCUMENTATION \"Stores reusable key-value list for use by
'print-descriptions-as-kif-rule'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EXCLUDEDPROPOSITIONS* (HASH-TABLE OF PROPOSITION BOOLEAN-WRAPPER) NULL :DOCUMENTATION \"List of propositions that shouldn't be saved by `save-module'.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-KIF-OUT-*EXCLUDEDPROPOSITIONS*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*EXCLUDEDPROPOSITIONS*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*EXCLUDEDPROPOSITIONS*)))
    (REGISTER-NATIVE-NAME
     SYM-KIF-OUT-SAVE-MODULE
     KWD-KIF-OUT-COMMON-LISP
     KWD-KIF-OUT-FUNCTION)))
  :VOID)
