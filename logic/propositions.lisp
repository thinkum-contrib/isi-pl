;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997                   | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-PROPOSITIONS-THIRTY-TWO-BIT-VECTOR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-ALL-ROOT-TYPES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-ALL-SURROGATE-VALUE-INVERSES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-ROOT-TYPE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-DEPENDENT-ATTRIBUTE-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-DEPENDENT-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-VARIABLE-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-VARIABLE-VALUE-INVERSE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-TYPE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LIST NULL)
(CL:DEFVAR SGT-PROPOSITIONS-CONS NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-OBJECT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-SKOLEM-TYPE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-NOT-BOTTOM? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-DEFINING-PROPOSITION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PROPOSITION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-SKOLEM NULL)
(CL:DEFVAR SYM-PROPOSITIONS-BOUND-TO-OFFSET NULL)
(CL:DEFVAR SGT-PROPOSITIONS-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-PATTERN-VARIABLE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-OBJECT-VECTOR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-ARGUMENTS-VECTOR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-VARIABLES-VECTOR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-EXTENSION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-IOTA? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PROPOSITION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-IO-VARIABLES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-INTERNAL-VARIABLES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-KIND NULL)
(CL:DEFVAR SYM-PROPOSITIONS-NATIVE-RELATION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-QUERY-PATTERNS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-REFERENCED-BY NULL)
(CL:DEFVAR SYM-PROPOSITIONS-TAXONOMY-NODE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-VECTOR NULL)
(CL:DEFVAR SGT-PROPOSITIONS-KEYWORD NULL)
(CL:DEFVAR SGT-PROPOSITIONS-RELATION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-KEY-VALUE-LIST NULL)
(CL:DEFVAR SGT-PROPOSITIONS-TAXONOMY-NODE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-DESCRIPTION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-SLOT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PARTIAL-MATCH-SCORE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-SET-OF-SUPPORT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-TIME-STAMP NULL)
(CL:DEFVAR SYM-PROPOSITIONS-POSITIVE-SCORE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-NEGATIVE-SCORE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-POSITIVE-SET-OF-SUPPORT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-NEGATIVE-SET-OF-SUPPORT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-FLOAT-WRAPPER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-TRUTH-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-VARIABLE-TYPE? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-SUBRELATION-LINK? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-SUBSUMPTION-LINK? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-SATELLITE-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-DONT-OPTIMIZE? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-FORWARD-ONLY? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-BACKWARD-ONLY? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-TRUTH-VALUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-ARGUMENTS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-OPERATOR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-SLOTREF NULL)
(CL:DEFVAR SGT-PROPOSITIONS-SLOTREF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-FUNCTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PREDICATE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-CONTEXT-ASSUMED-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-MONOTONIC? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-TRUTH-MAINTAINED? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-UP-TO-DATE-INFERENCES? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOCALLY-CONCEIVED-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOCALLY-BOUND-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LOCALLY-BOUND-SKOLEMS NULL)
(CL:DEFVAR KWD-PROPOSITIONS-UPDATE-PROPOSITION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-EXECUTE-QUERY NULL)
(CL:DEFVAR SYM-PROPOSITIONS-BOTTOM NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LITERAL-WRAPPER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LITERAL NULL)
(CL:DEFVAR KWD-PROPOSITIONS-OPEN-WORLD NULL)
(CL:DEFVAR KWD-PROPOSITIONS-CLOSED-WORLD NULL)
(CL:DEFVAR KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-*EVALUATIONMODE* NULL)
(CL:DEFVAR KWD-PROPOSITIONS-DESCRIPTION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-QUERY NULL)
(CL:DEFVAR KWD-PROPOSITIONS-CONCEIVE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-IMPLIES NULL)
(CL:DEFVAR KWD-PROPOSITIONS-RETRACT-TRUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-MASTER-PROPOSITION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-ASSERT-TRUE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-ASSERT-FALSE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-RETRACT-FALSE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-STRICT-INFERENCE-CACHE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-CONTEXT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-MODULE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-STRICT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-FUNCTION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-CONSTANT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STANDARD-OBJECT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STORAGE-SLOT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-DESCRIPTION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-PRIMITIVE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-COMPLEMENT-DESCRIPTION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-CLASS NULL)
(CL:DEFVAR KWD-PROPOSITIONS-IN NULL)
(CL:DEFVAR SGT-PROPOSITIONS-UNKNOWN NULL)
(CL:DEFVAR SYM-PROPOSITIONS-*FREESKOLEMS* NULL)
(CL:DEFVAR SYM-PROPOSITIONS-SKOLEM-NAME NULL)
(CL:DEFVAR SGT-PROPOSITIONS-COLLECTION NULL)
(CL:DEFVAR SGT-PROPOSITIONS-SEQUENCE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-SURROGATE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-AND NULL)
(CL:DEFVAR KWD-PROPOSITIONS-OR NULL)
(CL:DEFVAR SGT-PROPOSITIONS-TRUE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-FALSE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-PERMUTATION-TABLE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-NOT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-EQUIVALENT NULL)
(CL:DEFVAR KWD-PROPOSITIONS-PREDICATE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-TRAP-DOOR-SURROGATE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-SETOFALL NULL)
(CL:DEFVAR SYM-PROPOSITIONS-THE-ONLY NULL)
(CL:DEFVAR SYM-PROPOSITIONS-KAPPA NULL)
(CL:DEFVAR SYM-PROPOSITIONS-SETOF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-LISTOF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-CREATE NULL)
(CL:DEFVAR KWD-PROPOSITIONS-INTENSIONAL-ASSERTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-? NULL)
(CL:DEFVAR KWD-PROPOSITIONS-COMMON-LISP NULL)
(CL:DEFVAR SYM-PROPOSITIONS-EVALUATOR-WRAPPER-CODE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-NON-DISJOINTNESS-KLUDGE? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-CLASS-EXTENSION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK NULL)
(CL:DEFVAR SYM-PROPOSITIONS-IMPLIES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-RELATION-ORIGINATED-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-ISA NULL)
(CL:DEFVAR SYM-PROPOSITIONS-SURROGATE-VALUE-INVERSE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-*PROPOSITIONUNDERCONSTRUCTION* NULL)
(CL:DEFVAR SYM-PROPOSITIONS-*TOPLEVELPROPOSITIONS* NULL)
(CL:DEFVAR SGT-PROPOSITIONS-STRING-WRAPPER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-LOGIC-EXCEPTION NULL)
(CL:DEFVAR KWD-PROPOSITIONS-EXCEPTIONS NULL)
(CL:DEFVAR SGT-PROPOSITIONS-READ-EXCEPTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-CONSTANT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-TRUE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-FALSE NULL)
(CL:DEFVAR SGT-PROPOSITIONS-SYMBOL NULL)
(CL:DEFVAR SYM-PROPOSITIONS-= NULL)
(CL:DEFVAR SYM-PROPOSITIONS-AND NULL)
(CL:DEFVAR SYM-PROPOSITIONS-OR NULL)
(CL:DEFVAR SYM-PROPOSITIONS-NOT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-IN NULL)
(CL:DEFVAR SYM-PROPOSITIONS-SUBSET-OF NULL)
(CL:DEFVAR SYM-PROPOSITIONS-EXISTS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-FORALL NULL)
(CL:DEFVAR KWD-PROPOSITIONS-EXISTS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-EQUIVALENT NULL)
(CL:DEFVAR SGT-PROPOSITIONS-FUNCTION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-SECOND-ORDER NULL)
(CL:DEFVAR SGT-PROPOSITIONS-ANY NULL)
(CL:DEFVAR SGT-PROPOSITIONS-BOOLEAN NULL)
(CL:DEFVAR KWD-PROPOSITIONS-FORALL NULL)
(CL:DEFVAR SYM-PROPOSITIONS-ALWAYS NULL)
(CL:DEFVAR SYM-PROPOSITIONS-WHERE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-SOME NULL)
(CL:DEFVAR SYM-PROPOSITIONS-ASSERT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-RETRACT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-DENY NULL)
(CL:DEFVAR SYM-PROPOSITIONS-CONCEIVE NULL)
(CL:DEFVAR SYM-PROPOSITIONS-UNASSERT NULL)
(CL:DEFVAR SYM-PROPOSITIONS-DELETED-OBJECT? NULL)
(CL:DEFVAR KWD-PROPOSITIONS-DELETED NULL)
(CL:DEFVAR SYM-PROPOSITIONS-DEFINITION NULL)
(CL:DEFVAR SYM-PROPOSITIONS-CLEAR-LOGIC-MODULE-HOOK NULL)
(CL:DEFVAR SYM-PROPOSITIONS-CLEAR-INSTANCES NULL)
(CL:DEFVAR SYM-PROPOSITIONS-TOTAL? NULL)
(CL:DEFVAR SYM-PROPOSITIONS-INDEX-ON-VALUES? NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *LOGICVARIABLETABLE*
  *EXCEPTIONHANDLERADDRESS*
  *EXCEPTION*
  *EXCEPTION-TYPE*
  *TRACED-KEYWORDS*
  *THE-FAIL-EXCEPTION*
  *THE-CLASH-EXCEPTION*
  STANDARD-OUTPUT
  EOL
  *PROPOSITIONUNDERCONSTRUCTION*
  *THE-PROPOSITION-ERROR*
  TRUE-TRUTH-VALUE
  FALSE-TRUTH-VALUE
  *CONTEXT*
  NULL-BOOLEAN-WRAPPER
  NIL-LIST
  *MODULE*))

;;; (DEFCLASS LOGIC-OBJECT ...)

(CL:DEFCLASS LOGIC-OBJECT (CONTEXT-SENSITIVE-OBJECT DYNAMIC-SLOTS-MIXIN)
  ((ROOT-TYPE :ALLOCATION :INSTANCE :ACCESSOR ROOT-TYPE...OF)
   (DEPENDENT-ATTRIBUTE-PROPOSITIONS
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    DEPENDENT-ATTRIBUTE-PROPOSITIONS...OF)
   (DEPENDENT-PROPOSITIONS
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    DEPENDENT-PROPOSITIONS...OF)
   (VARIABLE-VALUE :ALLOCATION :INSTANCE :ACCESSOR VARIABLE-VALUE...OF)
   (VARIABLE-VALUE-INVERSE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    VARIABLE-VALUE-INVERSE...OF))
  (:DOCUMENTATION "Object with propositions, and possibly a variable value."))

(CL:DEFUN NEW-LOGIC-OBJECT ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE LOGIC-OBJECT)))
   (CL:SETF (CLSYS-SVAL LOGIC-OBJECT HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (CLSYS-SVAL LOGIC-OBJECT BITS SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL LOGIC-OBJECT DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS SELF) (NEW-LIST))
   (CL:SETF
    (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-ATTRIBUTE-PROPOSITIONS SELF)
    (NEW-LIST))
   (CL:SETF (CLSYS-SVAL LOGIC-OBJECT ROOT-TYPE SELF) NULL)
   (CL:RETURN-FROM NEW-LOGIC-OBJECT SELF))
  :VOID)

(CL:DEFMETHOD ALL-ROOT-TYPES ((SELF LOGIC-OBJECT))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-PROPOSITIONS-ALL-ROOT-TYPES NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM ALL-ROOT-TYPES NIL-LIST)
    (CL:RETURN-FROM ALL-ROOT-TYPES ANSWER)))
  :VOID)

(CL:DEFMETHOD VARIABLE-VALUE-INVERSE ((SELF LOGIC-OBJECT))
  (CL:LET*
   ((ANSWER
     (ACCESS-IN-CONTEXT
      (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE-INVERSE SELF)
      SELF
      FALSE)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM VARIABLE-VALUE-INVERSE NIL)
    (CL:RETURN-FROM VARIABLE-VALUE-INVERSE ANSWER)))
  :VOID)

(CL:DEFMETHOD ALL-SURROGATE-VALUE-INVERSES ((SELF LOGIC-OBJECT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-ALL-SURROGATE-VALUE-INVERSES
      NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM ALL-SURROGATE-VALUE-INVERSES NIL-LIST)
    (CL:RETURN-FROM ALL-SURROGATE-VALUE-INVERSES ANSWER)))
  :VOID)

(CL:DEFUN ACCESS-LOGIC-OBJECT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-ROOT-TYPE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL LOGIC-OBJECT ROOT-TYPE SELF)
      (CAST VALUE SGT-PROPOSITIONS-TYPE))
     (CL:RETURN-FROM
      ACCESS-LOGIC-OBJECT-SLOT-VALUE
      (CLSYS-SVAL LOGIC-OBJECT ROOT-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-ALL-ROOT-TYPES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-ALL-ROOT-TYPES
      (CAST VALUE SGT-PROPOSITIONS-LIST)
      NULL)
     (CL:RETURN-FROM ACCESS-LOGIC-OBJECT-SLOT-VALUE (ALL-ROOT-TYPES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-DEPENDENT-ATTRIBUTE-PROPOSITIONS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-ATTRIBUTE-PROPOSITIONS SELF)
      (CAST VALUE SGT-PROPOSITIONS-LIST))
     (CL:RETURN-FROM
      ACCESS-LOGIC-OBJECT-SLOT-VALUE
      (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-ATTRIBUTE-PROPOSITIONS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-DEPENDENT-PROPOSITIONS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS SELF)
      (CAST VALUE SGT-PROPOSITIONS-LIST))
     (CL:RETURN-FROM
      ACCESS-LOGIC-OBJECT-SLOT-VALUE
      (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-VARIABLE-VALUE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:LET*
      ((OBJECT-001 SELF)
       (VALUE-001 VALUE)
       (OLD-VALUE-001 (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OBJECT-001))
       (NEW-VALUE-001
        (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001 OBJECT-001 FALSE)))
      (CL:WHEN
       (CL:EQ (CS-VALUE? OLD-VALUE-001) 0)
       (CL:SETF
        (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OBJECT-001)
        NEW-VALUE-001)))
     (CL:RETURN-FROM
      ACCESS-LOGIC-OBJECT-SLOT-VALUE
      (ACCESS-IN-CONTEXT
       (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE SELF)
       SELF
       FALSE))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-VARIABLE-VALUE-INVERSE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:LET*
      ((OBJECT-002 SELF)
       (VALUE-002 (CAST VALUE SGT-PROPOSITIONS-CONS))
       (OLD-VALUE-003
        (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE-INVERSE OBJECT-002))
       (NEW-VALUE-002
        (UPDATE-IN-CONTEXT OLD-VALUE-003 VALUE-002 OBJECT-002 FALSE)))
      (CL:WHEN
       (CL:EQ (CS-VALUE? OLD-VALUE-003) 0)
       (CL:SETF
        (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE-INVERSE OBJECT-002)
        NEW-VALUE-002)))
     (CL:RETURN-FROM
      ACCESS-LOGIC-OBJECT-SLOT-VALUE
      (VARIABLE-VALUE-INVERSE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-ALL-SURROGATE-VALUE-INVERSES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-ALL-SURROGATE-VALUE-INVERSES
      (CAST VALUE SGT-PROPOSITIONS-LIST)
      NULL)
     (CL:RETURN-FROM
      ACCESS-LOGIC-OBJECT-SLOT-VALUE
      (ALL-SURROGATE-VALUE-INVERSES SELF))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL LOGIC-OBJECT DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-LOGIC-OBJECT-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL LOGIC-OBJECT DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-LOGIC-OBJECT-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LOGIC-OBJECT))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-PROPOSITIONS-LOGIC-OBJECT)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF LOGIC-OBJECT) STREAM)
  (PRINT-TOP-LEVEL-OBJECT SELF STREAM)
  :VOID)

;;; (DEFCLASS SKOLEM ...)

(CL:DEFCLASS SKOLEM (LOGIC-OBJECT)
  ((NOT-BOTTOM? :ALLOCATION :INSTANCE :ACCESSOR NOT-BOTTOM?...OF)
   (DEFINING-PROPOSITION
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    DEFINING-PROPOSITION...OF))
  (:DOCUMENTATION
   "Object whose identity and type are not fixed at creation time.
Potentially unifiable with any other object."))

(CL:DEFUN NEW-SKOLEM ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SKOLEM)))
   (CL:SETF (CLSYS-SVAL SKOLEM HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (CLSYS-SVAL SKOLEM BITS SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL SKOLEM DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (CLSYS-SVAL SKOLEM VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (CLSYS-SVAL SKOLEM VARIABLE-VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL SKOLEM DEPENDENT-PROPOSITIONS SELF) (NEW-LIST))
   (CL:SETF
    (CLSYS-SVAL SKOLEM DEPENDENT-ATTRIBUTE-PROPOSITIONS SELF)
    (NEW-LIST))
   (CL:SETF (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION SELF) NULL)
   (CL:SETF (CLSYS-SVAL SKOLEM NOT-BOTTOM? SELF) (WRAP-BOOLEAN FALSE))
   (CL:SETF (CLSYS-SVAL SKOLEM ROOT-TYPE SELF) NULL)
   (CL:RETURN-FROM NEW-SKOLEM SELF))
  :VOID)

(CL:DEFUN ACCESS-SKOLEM-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-SKOLEM-TYPE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SKOLEM ROOT-TYPE SELF)
      (CAST VALUE SGT-PROPOSITIONS-TYPE))
     (CL:RETURN-FROM
      ACCESS-SKOLEM-SLOT-VALUE
      (CLSYS-SVAL SKOLEM ROOT-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-NOT-BOTTOM?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:LET*
      ((OBJECT-001 SELF)
       (VALUE-001
        (CLSYS-SVAL
         BOOLEAN-WRAPPER
         WRAPPER-VALUE
         (CAST VALUE SGT-PROPOSITIONS-BOOLEAN-WRAPPER)))
       (OLD-VALUE-001 (CLSYS-SVAL SKOLEM NOT-BOTTOM? OBJECT-001))
       (NEW-VALUE-001
        (UPDATE-IN-CONTEXT
         OLD-VALUE-001
         (WRAP-BOOLEAN VALUE-001)
         OBJECT-001
         FALSE)))
      (CL:WHEN
       (CL:EQ (CS-VALUE? OLD-VALUE-001) 0)
       (CL:SETF (CLSYS-SVAL SKOLEM NOT-BOTTOM? OBJECT-001) NEW-VALUE-001)))
     (CL:RETURN-FROM
      ACCESS-SKOLEM-SLOT-VALUE
      (WRAP-BOOLEAN
       (CLSYS-SVAL
        BOOLEAN-WRAPPER
        WRAPPER-VALUE
        (ACCESS-IN-CONTEXT
         (CLSYS-SVAL SKOLEM NOT-BOTTOM? SELF)
         SELF
         FALSE))))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-DEFINING-PROPOSITION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION SELF)
      (CAST VALUE SGT-PROPOSITIONS-PROPOSITION))
     (CL:RETURN-FROM
      ACCESS-SKOLEM-SLOT-VALUE
      (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION SELF))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL SKOLEM DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-SKOLEM-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL SKOLEM DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN (CL:EQ SETVALUE? 1) (CL:RETURN-FROM ACCESS-SKOLEM-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SKOLEM))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-PROPOSITIONS-SKOLEM)
  :VOID)

;;; (DEFCLASS PATTERN-VARIABLE ...)

(CL:DEFCLASS PATTERN-VARIABLE (SKOLEM)
  ((BOUND-TO-OFFSET :ALLOCATION :INSTANCE :ACCESSOR BOUND-TO-OFFSET...OF)))

(CL:DEFUN NEW-PATTERN-VARIABLE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PATTERN-VARIABLE)))
   (CL:SETF (CLSYS-SVAL PATTERN-VARIABLE HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (CLSYS-SVAL PATTERN-VARIABLE BITS SELF) NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL PATTERN-VARIABLE DYNAMIC-SLOTS SELF)
    (NEW-KEY-VALUE-LIST))
   (CL:SETF (CLSYS-SVAL PATTERN-VARIABLE VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (CLSYS-SVAL PATTERN-VARIABLE VARIABLE-VALUE SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL PATTERN-VARIABLE DEPENDENT-PROPOSITIONS SELF)
    (NEW-LIST))
   (CL:SETF
    (CLSYS-SVAL PATTERN-VARIABLE DEPENDENT-ATTRIBUTE-PROPOSITIONS SELF)
    (NEW-LIST))
   (CL:SETF (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL PATTERN-VARIABLE NOT-BOTTOM? SELF)
    (WRAP-BOOLEAN FALSE))
   (CL:SETF (CLSYS-SVAL PATTERN-VARIABLE ROOT-TYPE SELF) NULL)
   (CL:SETF (CLSYS-SVAL PATTERN-VARIABLE BOUND-TO-OFFSET SELF) NULL-INTEGER)
   (CL:RETURN-FROM NEW-PATTERN-VARIABLE SELF))
  :VOID)

(CL:DEFUN ACCESS-PATTERN-VARIABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-BOUND-TO-OFFSET)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL PATTERN-VARIABLE BOUND-TO-OFFSET SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-PROPOSITIONS-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-PATTERN-VARIABLE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL PATTERN-VARIABLE BOUND-TO-OFFSET SELF)))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL PATTERN-VARIABLE DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-PATTERN-VARIABLE-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL PATTERN-VARIABLE DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-PATTERN-VARIABLE-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PATTERN-VARIABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-PROPOSITIONS-PATTERN-VARIABLE)
  :VOID)

(CL:DEFMETHOD BINDING-TO-CONSTANT ((SELF PATTERN-VARIABLE))
  (CL:RETURN-FROM
   BINDING-TO-CONSTANT
   (CL:IF
    (CL:EQ
     (NATIVE-VALUE?
      (ACCESS-IN-CONTEXT
       (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE SELF)
       SELF
       FALSE))
     1)
    (ACCESS-IN-CONTEXT
     (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE SELF)
     SELF
     FALSE)
    NULL))
  :VOID)

;;; (DEFCONSTANT ZERO-VARIABLES-VECTOR ...)

(CL:DEFVAR ZERO-VARIABLES-VECTOR NULL
  "Save space by structure-sharing zero-length variable vectors.")

;;; (DEFCLASS DESCRIPTION ...)

(CL:DEFCLASS DESCRIPTION (LOGIC-OBJECT)
  ((PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR PROPOSITION...OF)
   (IO-VARIABLES :ALLOCATION :INSTANCE :ACCESSOR IO-VARIABLES...OF)
   (INTERNAL-VARIABLES
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    INTERNAL-VARIABLES...OF)
   (KIND :ALLOCATION :INSTANCE :ACCESSOR KIND...OF)
   (NATIVE-RELATION :ALLOCATION :INSTANCE :ACCESSOR NATIVE-RELATION...OF)
   (QUERY-PATTERNS :ALLOCATION :INSTANCE :ACCESSOR QUERY-PATTERNS...OF)
   (REFERENCED-BY :ALLOCATION :INSTANCE :ACCESSOR REFERENCED-BY...OF)
   (TAXONOMY-NODE :ALLOCATION :INSTANCE :ACCESSOR TAXONOMY-NODE...OF)))

(CL:DEFUN NEW-DESCRIPTION ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE DESCRIPTION)))
   (CL:SETF (CLSYS-SVAL DESCRIPTION HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (CLSYS-SVAL DESCRIPTION BITS SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL DESCRIPTION DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (CLSYS-SVAL DESCRIPTION VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (CLSYS-SVAL DESCRIPTION VARIABLE-VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL DESCRIPTION DEPENDENT-PROPOSITIONS SELF) (NEW-LIST))
   (CL:SETF
    (CLSYS-SVAL DESCRIPTION DEPENDENT-ATTRIBUTE-PROPOSITIONS SELF)
    (NEW-LIST))
   (CL:SETF (CLSYS-SVAL DESCRIPTION ROOT-TYPE SELF) NULL)
   (CL:SETF (CLSYS-SVAL DESCRIPTION TAXONOMY-NODE SELF) NULL)
   (CL:SETF (CLSYS-SVAL DESCRIPTION REFERENCED-BY SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL DESCRIPTION QUERY-PATTERNS SELF) NULL)
   (CL:SETF (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF) NULL)
   (CL:SETF (CLSYS-SVAL DESCRIPTION KIND SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES SELF)
    ZERO-VARIABLES-VECTOR)
   (CL:SETF (CLSYS-SVAL DESCRIPTION IO-VARIABLES SELF) NULL)
   (CL:SETF (CLSYS-SVAL DESCRIPTION PROPOSITION SELF) NULL)
   (CL:RETURN-FROM NEW-DESCRIPTION SELF))
  :VOID)

(CL:DEFMETHOD EXTENSION ((SELF DESCRIPTION))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-PROPOSITIONS-EXTENSION NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM EXTENSION NIL-LIST)
    (CL:RETURN-FROM EXTENSION ANSWER)))
  :VOID)

(CL:DEFMETHOD IOTA? ((SELF DESCRIPTION))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE SELF SYM-PROPOSITIONS-IOTA? NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM IOTA? FALSE)
    (CL:RETURN-FROM IOTA? ANSWER)))
  :VOID)

(CL:DEFUN ACCESS-DESCRIPTION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-PROPOSITION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION PROPOSITION SELF)
      (CAST VALUE SGT-PROPOSITIONS-PROPOSITION))
     (CL:RETURN-FROM
      ACCESS-DESCRIPTION-SLOT-VALUE
      (CLSYS-SVAL DESCRIPTION PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-IO-VARIABLES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION IO-VARIABLES SELF)
      (CAST VALUE SGT-PROPOSITIONS-VECTOR))
     (CL:RETURN-FROM
      ACCESS-DESCRIPTION-SLOT-VALUE
      (CLSYS-SVAL DESCRIPTION IO-VARIABLES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-INTERNAL-VARIABLES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES SELF)
      (CAST VALUE SGT-PROPOSITIONS-VECTOR))
     (CL:RETURN-FROM
      ACCESS-DESCRIPTION-SLOT-VALUE
      (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-KIND)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION KIND SELF)
      (CAST VALUE SGT-PROPOSITIONS-KEYWORD))
     (CL:RETURN-FROM
      ACCESS-DESCRIPTION-SLOT-VALUE
      (CLSYS-SVAL DESCRIPTION KIND SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-NATIVE-RELATION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF)
      (CAST VALUE SGT-PROPOSITIONS-RELATION))
     (CL:RETURN-FROM
      ACCESS-DESCRIPTION-SLOT-VALUE
      (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-EXTENSION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-EXTENSION
      (CAST VALUE SGT-PROPOSITIONS-LIST)
      NULL)
     (CL:RETURN-FROM ACCESS-DESCRIPTION-SLOT-VALUE (EXTENSION SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-QUERY-PATTERNS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION QUERY-PATTERNS SELF)
      (CAST VALUE SGT-PROPOSITIONS-KEY-VALUE-LIST))
     (CL:RETURN-FROM
      ACCESS-DESCRIPTION-SLOT-VALUE
      (CLSYS-SVAL DESCRIPTION QUERY-PATTERNS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-REFERENCED-BY)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION REFERENCED-BY SELF)
      (CAST VALUE SGT-PROPOSITIONS-LIST))
     (CL:RETURN-FROM
      ACCESS-DESCRIPTION-SLOT-VALUE
      (CLSYS-SVAL DESCRIPTION REFERENCED-BY SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-TAXONOMY-NODE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION TAXONOMY-NODE SELF)
      (CAST VALUE SGT-PROPOSITIONS-TAXONOMY-NODE))
     (CL:RETURN-FROM
      ACCESS-DESCRIPTION-SLOT-VALUE
      (CLSYS-SVAL DESCRIPTION TAXONOMY-NODE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-IOTA?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-IOTA?
      (WRAP-BOOLEAN
       (CLSYS-SVAL
        BOOLEAN-WRAPPER
        WRAPPER-VALUE
        (CAST VALUE SGT-PROPOSITIONS-BOOLEAN-WRAPPER)))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-DESCRIPTION-SLOT-VALUE
      (WRAP-BOOLEAN (IOTA? SELF)))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL DESCRIPTION DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-DESCRIPTION-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL DESCRIPTION DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-DESCRIPTION-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DESCRIPTION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-PROPOSITIONS-DESCRIPTION)
  :VOID)

(CL:DEFMETHOD ARITY ((SELF DESCRIPTION))
  (CL:RETURN-FROM ARITY (LENGTH (CLSYS-SVAL DESCRIPTION IO-VARIABLES SELF)))
  :VOID)

(CL:DEFMETHOD REPRESENTATIVE ((SELF DESCRIPTION))
  (CL:RETURN-FROM
   REPRESENTATIVE
   (FIRST (CLSYS-SVAL DESCRIPTION IO-VARIABLES SELF)))
  :VOID)

(CL:DEFMETHOD RELATION? ((SELF DESCRIPTION))
  (CL:RETURN-FROM
   RELATION?
   (CL:IF
    (CL:AND
     (CL:NOT (CL:EQ (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF) NULL))
     (CL:EQ
      (ISA?
       (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF)
       SGT-PROPOSITIONS-SLOT)
      1)
     (CL:EQ
      (MEMBER?
       (GET-QUOTED-TREE
        "((/STELLA/@BOOLEAN /STELLA/@BOOLEAN-WRAPPER) \"/LOGIC\")"
        "/LOGIC")
       (CLSYS-SVAL
        SLOT
        SLOT-BASE-TYPE
        (CAST
         (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF)
         SGT-PROPOSITIONS-SLOT)))
      1))
    TRUE
    FALSE))
  :VOID)

(CL:DEFMETHOD FUNCTION? ((SELF DESCRIPTION))
  (CL:RETURN-FROM
   FUNCTION?
   (CL:IF
    (CL:AND
     (CL:NOT (CL:EQ (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF) NULL))
     (CL:EQ
      (ISA?
       (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF)
       SGT-PROPOSITIONS-SLOT)
      1)
     (CL:EQ
      (MEMBER?
       (GET-QUOTED-TREE
        "((/STELLA/@BOOLEAN /STELLA/@BOOLEAN-WRAPPER) \"/LOGIC\")"
        "/LOGIC")
       (CLSYS-SVAL
        SLOT
        SLOT-BASE-TYPE
        (CAST
         (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF)
         SGT-PROPOSITIONS-SLOT)))
      0))
    TRUE
    FALSE))
  :VOID)

(CL:DEFMETHOD DESCRIPTION-SURROGATE ((SELF DESCRIPTION))
  (CL:LET*
   ((NATIVERELATION (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF)))
   (CL:WHEN
    (CL:NOT (CL:EQ NATIVERELATION NULL))
    (CL:LET*
     ((NATIVERELATION-001 NATIVERELATION))
     (CL:COND
      ((CL:EQ (CLASS? NATIVERELATION) 1)
       (CL:LET*
        ((NATIVERELATION NULL))
        (CL:SETQ NATIVERELATION NATIVERELATION-001)
        (CL:RETURN-FROM
         DESCRIPTION-SURROGATE
         (CLSYS-SVAL CLASS CLASS-TYPE NATIVERELATION))))
      ((CL:EQ (TAXONOMY-ISA? NATIVERELATION SGT-PROPOSITIONS-SLOT) 1)
       (CL:LET*
        ((NATIVERELATION NULL))
        (CL:SETQ NATIVERELATION NATIVERELATION-001)
        (CL:RETURN-FROM
         DESCRIPTION-SURROGATE
         (CLSYS-SVAL SLOT SLOT-SLOTREF NATIVERELATION))))
      (CL:T NULL))))
   (CL:RETURN-FROM DESCRIPTION-SURROGATE NULL))
  :VOID)

;;; (DEFCLASS TRUTH-VALUE ...)

(CL:DEFCLASS TRUTH-VALUE (LOGIC-OBJECT)
  ((POSITIVE-SCORE :ALLOCATION :INSTANCE :ACCESSOR POSITIVE-SCORE...OF)
   (NEGATIVE-SCORE :ALLOCATION :INSTANCE :ACCESSOR NEGATIVE-SCORE...OF)
   (POSITIVE-SET-OF-SUPPORT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    POSITIVE-SET-OF-SUPPORT...OF)
   (NEGATIVE-SET-OF-SUPPORT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    NEGATIVE-SET-OF-SUPPORT...OF)
   (TIME-STAMP :ALLOCATION :INSTANCE :ACCESSOR TIME-STAMP...OF)))

(CL:DEFUN NEW-TRUTH-VALUE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRUTH-VALUE)))
   (CL:SETF (CLSYS-SVAL TRUTH-VALUE HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (CLSYS-SVAL TRUTH-VALUE BITS SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL TRUTH-VALUE DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (CLSYS-SVAL TRUTH-VALUE VARIABLE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (CLSYS-SVAL TRUTH-VALUE VARIABLE-VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL TRUTH-VALUE DEPENDENT-PROPOSITIONS SELF) (NEW-LIST))
   (CL:SETF
    (CLSYS-SVAL TRUTH-VALUE DEPENDENT-ATTRIBUTE-PROPOSITIONS SELF)
    (NEW-LIST))
   (CL:SETF (CLSYS-SVAL TRUTH-VALUE ROOT-TYPE SELF) NULL)
   (CL:SETF (CLSYS-SVAL TRUTH-VALUE TIME-STAMP SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL TRUTH-VALUE NEGATIVE-SET-OF-SUPPORT SELF) NULL)
   (CL:SETF (CLSYS-SVAL TRUTH-VALUE POSITIVE-SET-OF-SUPPORT SELF) NULL)
   (CL:SETF (CLSYS-SVAL TRUTH-VALUE NEGATIVE-SCORE SELF) 0.0)
   (CL:SETF (CLSYS-SVAL TRUTH-VALUE POSITIVE-SCORE SELF) 0.0)
   (CL:RETURN-FROM NEW-TRUTH-VALUE SELF))
  :VOID)

(CL:DEFUN ACCESS-TRUTH-VALUE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-POSITIVE-SCORE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRUTH-VALUE POSITIVE-SCORE SELF)
      (CLSYS-SVAL
       FLOAT-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-PROPOSITIONS-FLOAT-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-TRUTH-VALUE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL TRUTH-VALUE POSITIVE-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-NEGATIVE-SCORE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRUTH-VALUE NEGATIVE-SCORE SELF)
      (CLSYS-SVAL
       FLOAT-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-PROPOSITIONS-FLOAT-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-TRUTH-VALUE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL TRUTH-VALUE NEGATIVE-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-POSITIVE-SET-OF-SUPPORT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRUTH-VALUE POSITIVE-SET-OF-SUPPORT SELF)
      (CAST VALUE SGT-PROPOSITIONS-LIST))
     (CL:RETURN-FROM
      ACCESS-TRUTH-VALUE-SLOT-VALUE
      (CLSYS-SVAL TRUTH-VALUE POSITIVE-SET-OF-SUPPORT SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-NEGATIVE-SET-OF-SUPPORT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRUTH-VALUE NEGATIVE-SET-OF-SUPPORT SELF)
      (CAST VALUE SGT-PROPOSITIONS-LIST))
     (CL:RETURN-FROM
      ACCESS-TRUTH-VALUE-SLOT-VALUE
      (CLSYS-SVAL TRUTH-VALUE NEGATIVE-SET-OF-SUPPORT SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-TIME-STAMP)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRUTH-VALUE TIME-STAMP SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-PROPOSITIONS-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-TRUTH-VALUE-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL TRUTH-VALUE TIME-STAMP SELF)))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL TRUTH-VALUE DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-TRUTH-VALUE-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL TRUTH-VALUE DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-TRUTH-VALUE-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRUTH-VALUE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-PROPOSITIONS-TRUTH-VALUE)
  :VOID)

;;; (DEFCLASS PROPOSITION ...)

(CL:DEFCLASS PROPOSITION (CONTEXT-SENSITIVE-OBJECT DYNAMIC-SLOTS-MIXIN)
  ((KIND :ALLOCATION :INSTANCE :ACCESSOR KIND...OF)
   (TRUTH-VALUE :ALLOCATION :INSTANCE :ACCESSOR TRUTH-VALUE...OF)
   (ARGUMENTS :ALLOCATION :INSTANCE :ACCESSOR ARGUMENTS...OF)
   (OPERATOR :ALLOCATION :INSTANCE :ACCESSOR OPERATOR...OF)
   (DEPENDENT-PROPOSITIONS
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    DEPENDENT-PROPOSITIONS...OF))
  (:DOCUMENTATION ""))

(CL:DEFUN NEW-PROPOSITION ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PROPOSITION)))
   (CL:SETF (CLSYS-SVAL PROPOSITION HOME-CONTEXT SELF) *MODULE*)
   (CL:SETF (CLSYS-SVAL PROPOSITION BITS SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL PROPOSITION DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (CLSYS-SVAL PROPOSITION DEPENDENT-PROPOSITIONS SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL PROPOSITION OPERATOR SELF) NULL)
   (CL:SETF (CLSYS-SVAL PROPOSITION ARGUMENTS SELF) NULL)
   (CL:SETF (CLSYS-SVAL PROPOSITION TRUTH-VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL PROPOSITION KIND SELF) NULL)
   (CL:RETURN-FROM NEW-PROPOSITION SELF))
  :VOID)

(CL:DEFMETHOD VARIABLE-TYPE? ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-PROPOSITIONS-VARIABLE-TYPE?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM VARIABLE-TYPE? FALSE)
    (CL:RETURN-FROM VARIABLE-TYPE? ANSWER)))
  :VOID)

(CL:DEFMETHOD SUBRELATION-LINK? ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-PROPOSITIONS-SUBRELATION-LINK?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM SUBRELATION-LINK? FALSE)
    (CL:RETURN-FROM SUBRELATION-LINK? ANSWER)))
  :VOID)

(CL:DEFMETHOD SUBSUMPTION-LINK? ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-PROPOSITIONS-SUBSUMPTION-LINK?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM SUBSUMPTION-LINK? FALSE)
    (CL:RETURN-FROM SUBSUMPTION-LINK? ANSWER)))
  :VOID)

(CL:DEFMETHOD SATELLITE-PROPOSITIONS ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE SELF SYM-PROPOSITIONS-SATELLITE-PROPOSITIONS NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM SATELLITE-PROPOSITIONS NIL-LIST)
    (CL:RETURN-FROM SATELLITE-PROPOSITIONS ANSWER)))
  :VOID)

(CL:DEFMETHOD DONT-OPTIMIZE? ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-PROPOSITIONS-DONT-OPTIMIZE?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM DONT-OPTIMIZE? FALSE)
    (CL:RETURN-FROM DONT-OPTIMIZE? ANSWER)))
  :VOID)

(CL:DEFMETHOD FORWARD-ONLY? ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-PROPOSITIONS-FORWARD-ONLY?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM FORWARD-ONLY? FALSE)
    (CL:RETURN-FROM FORWARD-ONLY? ANSWER)))
  :VOID)

(CL:DEFMETHOD BACKWARD-ONLY? ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-PROPOSITIONS-BACKWARD-ONLY?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM BACKWARD-ONLY? FALSE)
    (CL:RETURN-FROM BACKWARD-ONLY? ANSWER)))
  :VOID)

(CL:DEFUN ACCESS-PROPOSITION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-KIND)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL PROPOSITION KIND SELF)
      (CAST VALUE SGT-PROPOSITIONS-KEYWORD))
     (CL:RETURN-FROM
      ACCESS-PROPOSITION-SLOT-VALUE
      (CLSYS-SVAL PROPOSITION KIND SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-TRUTH-VALUE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:LET*
      ((OBJECT-001 SELF)
       (VALUE-001 (CAST VALUE SGT-PROPOSITIONS-TRUTH-VALUE))
       (OLD-VALUE-001 (CLSYS-SVAL PROPOSITION TRUTH-VALUE OBJECT-001))
       (NEW-VALUE-001
        (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001 OBJECT-001 FALSE)))
      (CL:WHEN
       (CL:EQ (CS-VALUE? OLD-VALUE-001) 0)
       (CL:SETF
        (CLSYS-SVAL PROPOSITION TRUTH-VALUE OBJECT-001)
        NEW-VALUE-001)))
     (CL:RETURN-FROM
      ACCESS-PROPOSITION-SLOT-VALUE
      (ACCESS-IN-CONTEXT
       (CLSYS-SVAL PROPOSITION TRUTH-VALUE SELF)
       SELF
       FALSE))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-ARGUMENTS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)
      (CAST VALUE SGT-PROPOSITIONS-VECTOR))
     (CL:RETURN-FROM
      ACCESS-PROPOSITION-SLOT-VALUE
      (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-OPERATOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF (CLSYS-SVAL PROPOSITION OPERATOR SELF) VALUE)
     (CL:RETURN-FROM
      ACCESS-PROPOSITION-SLOT-VALUE
      (CLSYS-SVAL PROPOSITION OPERATOR SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-SLOTREF)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL PROPOSITION OPERATOR SELF)
      (CAST VALUE SGT-PROPOSITIONS-SLOTREF))
     (CL:RETURN-FROM
      ACCESS-PROPOSITION-SLOT-VALUE
      (CAST
       (CLSYS-SVAL PROPOSITION OPERATOR SELF)
       SGT-PROPOSITIONS-SLOTREF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-DEPENDENT-PROPOSITIONS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL PROPOSITION DEPENDENT-PROPOSITIONS SELF)
      (CAST VALUE SGT-PROPOSITIONS-LIST))
     (CL:RETURN-FROM
      ACCESS-PROPOSITION-SLOT-VALUE
      (CLSYS-SVAL PROPOSITION DEPENDENT-PROPOSITIONS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-VARIABLE-TYPE?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-VARIABLE-TYPE?
      (WRAP-BOOLEAN
       (CLSYS-SVAL
        BOOLEAN-WRAPPER
        WRAPPER-VALUE
        (CAST VALUE SGT-PROPOSITIONS-BOOLEAN-WRAPPER)))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-PROPOSITION-SLOT-VALUE
      (WRAP-BOOLEAN (VARIABLE-TYPE? SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-SUBRELATION-LINK?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-SUBRELATION-LINK?
      (WRAP-BOOLEAN
       (CLSYS-SVAL
        BOOLEAN-WRAPPER
        WRAPPER-VALUE
        (CAST VALUE SGT-PROPOSITIONS-BOOLEAN-WRAPPER)))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-PROPOSITION-SLOT-VALUE
      (WRAP-BOOLEAN (SUBRELATION-LINK? SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-SUBSUMPTION-LINK?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-SUBSUMPTION-LINK?
      (WRAP-BOOLEAN
       (CLSYS-SVAL
        BOOLEAN-WRAPPER
        WRAPPER-VALUE
        (CAST VALUE SGT-PROPOSITIONS-BOOLEAN-WRAPPER)))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-PROPOSITION-SLOT-VALUE
      (WRAP-BOOLEAN (SUBSUMPTION-LINK? SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-SATELLITE-PROPOSITIONS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-SATELLITE-PROPOSITIONS
      (CAST VALUE SGT-PROPOSITIONS-LIST)
      NULL)
     (CL:RETURN-FROM
      ACCESS-PROPOSITION-SLOT-VALUE
      (SATELLITE-PROPOSITIONS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-DONT-OPTIMIZE?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-DONT-OPTIMIZE?
      (WRAP-BOOLEAN
       (CLSYS-SVAL
        BOOLEAN-WRAPPER
        WRAPPER-VALUE
        (CAST VALUE SGT-PROPOSITIONS-BOOLEAN-WRAPPER)))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-PROPOSITION-SLOT-VALUE
      (WRAP-BOOLEAN (DONT-OPTIMIZE? SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-FORWARD-ONLY?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-FORWARD-ONLY?
      (WRAP-BOOLEAN
       (CLSYS-SVAL
        BOOLEAN-WRAPPER
        WRAPPER-VALUE
        (CAST VALUE SGT-PROPOSITIONS-BOOLEAN-WRAPPER)))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-PROPOSITION-SLOT-VALUE
      (WRAP-BOOLEAN (FORWARD-ONLY? SELF)))))
   ((CL:EQ SLOTNAME SYM-PROPOSITIONS-BACKWARD-ONLY?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-BACKWARD-ONLY?
      (WRAP-BOOLEAN
       (CLSYS-SVAL
        BOOLEAN-WRAPPER
        WRAPPER-VALUE
        (CAST VALUE SGT-PROPOSITIONS-BOOLEAN-WRAPPER)))
      NULL-BOOLEAN-WRAPPER)
     (CL:RETURN-FROM
      ACCESS-PROPOSITION-SLOT-VALUE
      (WRAP-BOOLEAN (BACKWARD-ONLY? SELF)))))
   (CL:T
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (HELP-SET-DYNAMIC-SLOT-VALUE
      (CLSYS-SVAL PROPOSITION DYNAMIC-SLOTS SELF)
      SLOTNAME
      VALUE)
     (CL:RETURN-FROM
      ACCESS-PROPOSITION-SLOT-VALUE
      (LOOKUP (CLSYS-SVAL PROPOSITION DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-PROPOSITION-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PROPOSITION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-PROPOSITIONS-PROPOSITION)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF PROPOSITION) STREAM)
  (PRINT-TOP-LEVEL-OBJECT SELF STREAM)
  :VOID)

;;; (DEFUN (CREATE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN CREATE-PROPOSITION (KIND ARGUMENTCOUNT)
  (CL:LET*
   ((PROPOSITION (NEW-PROPOSITION)))
   (CL:SETF
    (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION)
    (NEW-VECTOR ARGUMENTCOUNT))
   (CL:SETF
    (CLSYS-SVAL PROPOSITION KIND PROPOSITION)
    (INTERN-KEYWORD (CLSYS-SVAL SYMBOL SYMBOL-NAME KIND)))
   (CL:COND
    ((CL:OR
      (CL:EQ KIND SYM-PROPOSITIONS-FUNCTION)
      (CL:EQ KIND SYM-PROPOSITIONS-PREDICATE))
     NULL)
    (CL:T
     (CL:SETF
      (CLSYS-SVAL PROPOSITION OPERATOR PROPOSITION)
      (INTERN-SURROGATE (CLSYS-SVAL SYMBOL SYMBOL-NAME KIND)))))
   (CL:RETURN-FROM CREATE-PROPOSITION PROPOSITION))
  :VOID)

(CL:DEFMETHOD CONTEXT-ASSUMED-PROPOSITIONS ((SELF CONTEXT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-CONTEXT-ASSUMED-PROPOSITIONS
      NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CONTEXT-ASSUMED-PROPOSITIONS NIL-LIST)
    (CL:RETURN-FROM CONTEXT-ASSUMED-PROPOSITIONS ANSWER)))
  :VOID)

(CL:DEFMETHOD MONOTONIC? ((SELF WORLD))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-PROPOSITIONS-MONOTONIC?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM MONOTONIC? FALSE)
    (CL:RETURN-FROM MONOTONIC? ANSWER)))
  :VOID)

(CL:DEFMETHOD TRUTH-MAINTAINED? ((SELF WORLD))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-PROPOSITIONS-TRUTH-MAINTAINED?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM TRUTH-MAINTAINED? FALSE)
    (CL:RETURN-FROM TRUTH-MAINTAINED? ANSWER)))
  :VOID)

(CL:DEFMETHOD UP-TO-DATE-INFERENCES? ((SELF WORLD))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-PROPOSITIONS-UP-TO-DATE-INFERENCES?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM UP-TO-DATE-INFERENCES? FALSE)
    (CL:RETURN-FROM UP-TO-DATE-INFERENCES? ANSWER)))
  :VOID)

;;; (DEFMETHOD (LOCALLY-CONCEIVED-PROPOSITIONS-GETTER (LIST OF PROPOSITION)) ...)

(CL:DEFMETHOD LOCALLY-CONCEIVED-PROPOSITIONS-GETTER ((SELF MODULE))
  (CL:LET*
   ((PROPOSITIONS
     (DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-LOCALLY-CONCEIVED-PROPOSITIONS
      NULL)))
   (CL:WHEN
    (CL:EQ PROPOSITIONS NULL)
    (CL:SETQ PROPOSITIONS (LIST))
    (SET-DYNAMIC-SLOT-VALUE
     SELF
     SYM-PROPOSITIONS-LOCALLY-CONCEIVED-PROPOSITIONS
     PROPOSITIONS
     NULL))
   (CL:RETURN-FROM LOCALLY-CONCEIVED-PROPOSITIONS-GETTER PROPOSITIONS))
  :VOID)

;;; (DEFMETHOD (LOCALLY-BOUND-PROPOSITIONS-GETTER (LIST OF PROPOSITION)) ...)

(CL:DEFMETHOD LOCALLY-BOUND-PROPOSITIONS-GETTER ((SELF WORLD))
  (CL:LET*
   ((PROPOSITIONS
     (DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-LOCALLY-BOUND-PROPOSITIONS
      NULL)))
   (CL:WHEN
    (CL:EQ PROPOSITIONS NULL)
    (CL:SETQ PROPOSITIONS (LIST))
    (SET-DYNAMIC-SLOT-VALUE
     SELF
     SYM-PROPOSITIONS-LOCALLY-BOUND-PROPOSITIONS
     PROPOSITIONS
     NULL))
   (CL:RETURN-FROM LOCALLY-BOUND-PROPOSITIONS-GETTER PROPOSITIONS))
  :VOID)

;;; (DEFMETHOD (LOCALLY-BOUND-SKOLEMS-GETTER (LIST OF SKOLEM)) ...)

(CL:DEFMETHOD LOCALLY-BOUND-SKOLEMS-GETTER ((SELF WORLD))
  (CL:LET*
   ((PROPOSITIONS
     (DYNAMIC-SLOT-VALUE SELF SYM-PROPOSITIONS-LOCALLY-BOUND-SKOLEMS NULL)))
   (CL:WHEN
    (CL:EQ PROPOSITIONS NULL)
    (CL:SETQ PROPOSITIONS (LIST))
    (SET-DYNAMIC-SLOT-VALUE
     SELF
     SYM-PROPOSITIONS-LOCALLY-BOUND-SKOLEMS
     PROPOSITIONS
     NULL))
   (CL:RETURN-FROM LOCALLY-BOUND-SKOLEMS-GETTER PROPOSITIONS))
  :VOID)

;;; (DEFGLOBAL *NOW-TIME-STAMP* ...)

(CL:DEFVAR *NOW-TIME-STAMP* 0
  "The NOW time stamp is incremented whenever a series
of one or more updates is followed by a query.")

;;; (DEFUN INCREMENT-NOW-TIME-STAMP ...)

(CL:DEFUN INCREMENT-NOW-TIME-STAMP ()
  (CL:SETQ *NOW-TIME-STAMP* (CL:1+ *NOW-TIME-STAMP*))
  :VOID)

;;; (DEFUN (GET-NOW-TIME-STAMP TIME-STAMP) ...)

(CL:DEFUN GET-NOW-TIME-STAMP ()
  (CL:RETURN-FROM GET-NOW-TIME-STAMP *NOW-TIME-STAMP*)
  :VOID)

;;; (DEFGLOBAL *LAST-KB-ACTION* ...)

(CL:DEFVAR *LAST-KB-ACTION* NULL
  "Records whether the last KB access was a query or
an update.  Used to determine when to increment the NOW time stamp
counter.")

;;; (DEFUN UPDATE-NOW-TIME-STAMP ...)

(CL:DEFUN UPDATE-NOW-TIME-STAMP (KBACTION)
  (CL:WHEN
   (CL:EQ KBACTION *LAST-KB-ACTION*)
   (CL:RETURN-FROM UPDATE-NOW-TIME-STAMP))
  (CL:COND
   ((CL:EQ KBACTION KWD-PROPOSITIONS-UPDATE-PROPOSITION)
    (INCREMENT-NOW-TIME-STAMP))
   ((CL:EQ KBACTION KWD-PROPOSITIONS-EXECUTE-QUERY) NULL)
   (CL:T (CL:ERROR "`~A' is not a valid case option" KBACTION)))
  (CL:SETQ *LAST-KB-ACTION* KBACTION)
  :VOID)

;;; (DEFCONSTANT BOTTOM ...)

(CL:DEFVAR BOTTOM NULL
  "The undefined individual.  Denotes the non-existence of
an individual in whatever slot it occupies.")

;;; (DEFUN (BOTTOM? BOOLEAN) ...)

(CL:DEFUN BOTTOM? (SELF)
  "Return TRUE if 'self' is the undefined individual BOTTOM."
  (CL:RETURN-FROM BOTTOM? (EQ? SELF BOTTOM))
  :VOID)

;;; (DEFMETHOD (MONADIC? BOOLEAN) ...)

(CL:DEFMETHOD MONADIC? ((SELF LOGIC-OBJECT))
  (CL:RETURN-FROM MONADIC? FALSE)
  :VOID)

;;; (DEFMETHOD (MONADIC? BOOLEAN) ...)

(CL:DEFMETHOD MONADIC? ((SELF COLLECTION))
  (CL:RETURN-FROM MONADIC? TRUE)
  :VOID)

;;; (DEFMETHOD (MONADIC? BOOLEAN) ...)

(CL:DEFMETHOD MONADIC? ((SELF DESCRIPTION))
  (CL:RETURN-FROM MONADIC? (EQ? (ARITY SELF) 1))
  :VOID)

;;; (DEFUN (LOGIC-SLOT? BOOLEAN) ...)

(CL:DEFUN LOGIC-SLOT? (SLOT)
  (CL:RETURN-FROM LOGIC-SLOT? (CLSYS-SVAL SLOT ABSTRACT? SLOT))
  :VOID)

;;; (DEFUN (TYPE-HAS-BACKLINKS? BOOLEAN) ...)

(CL:DEFUN TYPE-HAS-BACKLINKS? (TYPE)
  (CL:RETURN-FROM
   TYPE-HAS-BACKLINKS?
   (CL:IF
    (CL:AND
     (CL:EQ (SUBTYPE-OF? TYPE SGT-PROPOSITIONS-LITERAL-WRAPPER) 0)
     (CL:EQ (SUBTYPE-OF? TYPE SGT-PROPOSITIONS-LITERAL) 0))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (NO-BACKLINKS? BOOLEAN) ...)

(CL:DEFUN NO-BACKLINKS? (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       NO-BACKLINKS?
       (CL:IF
        (CL:EQ (TYPE-HAS-BACKLINKS? (LOGICAL-TYPE SELF)) 0)
        TRUE
        FALSE))))
    (CL:T (CL:RETURN-FROM NO-BACKLINKS? TRUE))))
  :VOID)

;;; (DEFUN (LOGIC-OBJECT-PERMITS-BACKLINKS? BOOLEAN) ...)

(CL:DEFUN LOGIC-OBJECT-PERMITS-BACKLINKS? (OBJECT)
  (CL:LET*
   ((OBJECT-001 OBJECT))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? OBJECT SGT-PROPOSITIONS-SKOLEM) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:RETURN-FROM LOGIC-OBJECT-PERMITS-BACKLINKS? TRUE)))
    (CL:T
     (CL:RETURN-FROM
      LOGIC-OBJECT-PERMITS-BACKLINKS?
      (TYPE-HAS-BACKLINKS? (LOGICAL-TYPE OBJECT))))))
  :VOID)

;;; (DEFMETHOD (CLOSED? BOOLEAN) ...)

(CL:DEFMETHOD CLOSED? ((SELF SLOT))
  "Return TRUE if the closed world assumption applies to
a function or relation."
  (CL:RETURN-FROM
   CLOSED?
   (CL:IF
    (CL:EQ (CLOSED-WORLD-ASSUMPTION? *MODULE*) 1)
    (CL:IF
     (CL:NOT (CL:EQ (CLOSURE-ASSUMPTION SELF) KWD-PROPOSITIONS-OPEN-WORLD))
     TRUE
     FALSE)
    (EQ? (CLOSURE-ASSUMPTION SELF) KWD-PROPOSITIONS-CLOSED-WORLD)))
  :VOID)

;;; (DEFMETHOD (OPEN-WORLD? BOOLEAN) ...)

(CL:DEFMETHOD OPEN-WORLD? ((SELF SLOT))
  "Return TRUE if the closed world assumption does not
apply to a function or relation."
  (CL:RETURN-FROM OPEN-WORLD? (CL:IF (CL:EQ (CLOSED? SELF) 0) TRUE FALSE))
  :VOID)

;;; (DEFSPECIAL *EVALUATIONMODE* ...)

(CL:DEFVAR *EVALUATIONMODE* NULL
  "Indicates the context for evaluating a proposition.  One
of :DESCRIPTION, :QUERY, :INTENSIONAL-ASSERTION, or :EXTENSIONAL-ASSERTION.")

(CL:DEFUN READ-*EVALUATIONMODE* ()
  (CL:RETURN-FROM READ-*EVALUATIONMODE* *EVALUATIONMODE*)
  :VOID)

(CL:DEFUN WRITE-*EVALUATIONMODE* (VALUE)
  (CL:SETQ *EVALUATIONMODE* VALUE)
  (CL:RETURN-FROM WRITE-*EVALUATIONMODE* VALUE)
  :VOID)

;;; (DEFUN (DESCRIPTION-MODE? BOOLEAN) ...)

(CL:DEFUN DESCRIPTION-MODE? ()
  (CL:RETURN-FROM
   DESCRIPTION-MODE?
   (CL:IF
    (CL:OR
     (CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-DESCRIPTION)
     (CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-QUERY))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (CONCEIVING-UPDATE? BOOLEAN) ...)

(CL:DEFUN CONCEIVING-UPDATE? (UPDATEMODE)
  (CL:RETURN-FROM
   CONCEIVING-UPDATE?
   (CL:IF
    (CL:OR
     (CL:EQ UPDATEMODE NULL)
     (CL:EQ UPDATEMODE KWD-PROPOSITIONS-CONCEIVE))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (DESCRIPTIVE-UPDATE? BOOLEAN) ...)

(CL:DEFUN DESCRIPTIVE-UPDATE? (UPDATEMODE)
  (CL:RETURN-FROM
   DESCRIPTIVE-UPDATE?
   (CL:IF
    (CL:OR
     (CL:EQ (CONCEIVING-UPDATE? UPDATEMODE) 1)
     (CL:EQ (DESCRIPTION-MODE?) 1))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (PROPAGATE-CONSTRAINTS-INCREMENTALLY? BOOLEAN) ...)

(CL:DEFUN PROPAGATE-CONSTRAINTS-INCREMENTALLY? (SELF)
  (CL:RETURN-FROM
   PROPAGATE-CONSTRAINTS-INCREMENTALLY?
   (CL:IF
    (CL:OR (CL:EQ (MONOTONIC? SELF) 1) (CL:EQ (TRUTH-MAINTAINED? SELF) 1))
    TRUE
    FALSE))
  :VOID)

;;; (DEFGLOBAL *CLIPPING-ENABLED* ...)

(CL:DEFVAR *CLIPPING-ENABLED* TRUE
  "When enabled, slot-value assertions can be retracted
by later conflicting assertions.")

;;; (DEFGLOBAL *CONTEXT-DEPENDENT-SEARCH-MODE?* ...)

(CL:DEFVAR *CONTEXT-DEPENDENT-SEARCH-MODE?* FALSE
  "Signals that we are performing search across multiple
contexts.  Used to disable retraction from collections, since that increases
the overhead of the context mechanism.")

;;; (DEFUN (CONTEXT-DEPENDENT-SEARCH-MODE? BOOLEAN) ...)

(CL:DEFUN CONTEXT-DEPENDENT-SEARCH-MODE? ()
  (CL:RETURN-FROM
   CONTEXT-DEPENDENT-SEARCH-MODE?
   *CONTEXT-DEPENDENT-SEARCH-MODE?*)
  :VOID)

;;; (DEFUN LOG-NEWLY-CONCEIVED-PROPOSITION ...)

(CL:DEFUN LOG-NEWLY-CONCEIVED-PROPOSITION (SELF PROPOSITION)
  (INSERT (LOCALLY-CONCEIVED-PROPOSITIONS-GETTER SELF) PROPOSITION)
  :VOID)

;;; (DEFMETHOD LOG-NEWLY-BOUND-PROPOSITION ...)

(CL:DEFMETHOD LOG-NEWLY-BOUND-PROPOSITION ((SELF CONTEXT) PROPOSITION)
  (CL:SETQ PROPOSITION PROPOSITION)
  NULL
  :VOID)

;;; (DEFMETHOD LOG-NEWLY-BOUND-PROPOSITION ...)

(CL:DEFMETHOD LOG-NEWLY-BOUND-PROPOSITION ((SELF WORLD) PROPOSITION)
  (INSERT (LOCALLY-BOUND-PROPOSITIONS-GETTER SELF) PROPOSITION)
  :VOID)

;;; (DEFUN RUN-GOES-TRUE-DEMONS ...)

(CL:DEFUN RUN-GOES-TRUE-DEMONS (PROPOSITION)
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-PROPOSITIONS-IMPLIES)
     (CL:WHEN
      (CL:EQ (DESCRIPTION-MODE?) 0)
      (ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK
       (CAST
        (CL:AREF
         (CLSYS-SVAL
          VECTOR
          THE-ARRAY
          (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
         0)
        SGT-PROPOSITIONS-DESCRIPTION)
       (CAST
        (CL:AREF
         (CLSYS-SVAL
          VECTOR
          THE-ARRAY
          (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
         1)
        SGT-PROPOSITIONS-DESCRIPTION)))
     (CL:LET*
      ((P NULL)
       (ITER-001
        (CLSYS-SVAL LIST THE-CONS-LIST (SATELLITE-PROPOSITIONS PROPOSITION))))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ
         P
         (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-PROPOSITIONS-PROPOSITION))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (ASSIGN-TRUTH-VALUE P TRUE))))
    (CL:T NULL)))
  (CL:RETURN-FROM RUN-GOES-TRUE-DEMONS)
  :VOID)

;;; (DEFUN RUN-GOES-FALSE-DEMONS ...)

(CL:DEFUN RUN-GOES-FALSE-DEMONS (PROPOSITION)
  (CL:SETQ PROPOSITION PROPOSITION)
  (CL:RETURN-FROM RUN-GOES-FALSE-DEMONS)
  :VOID)

;;; (DEFUN RUN-GOES-UNKNOWN-DEMONS ...)

(CL:DEFUN RUN-GOES-UNKNOWN-DEMONS (PROPOSITION)
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-PROPOSITIONS-IMPLIES)
     (DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK
      (CAST
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
        0)
       SGT-PROPOSITIONS-DESCRIPTION)
      (CAST
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
        1)
       SGT-PROPOSITIONS-DESCRIPTION))
     (CL:LET*
      ((P NULL)
       (ITER-001
        (CLSYS-SVAL LIST THE-CONS-LIST (SATELLITE-PROPOSITIONS PROPOSITION))))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ
         P
         (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-PROPOSITIONS-PROPOSITION))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (DEASSIGN-TRUTH-VALUE P KWD-PROPOSITIONS-RETRACT-TRUE)))
     (CL:LET*
      ((P
        (DYNAMIC-SLOT-VALUE
         PROPOSITION
         SYM-PROPOSITIONS-MASTER-PROPOSITION
         NULL)))
      (CL:WHEN
       (CL:NOT (CL:EQ P NULL))
       (DEASSIGN-TRUTH-VALUE P KWD-PROPOSITIONS-RETRACT-TRUE))))
    (CL:T NULL)))
  (CL:RETURN-FROM RUN-GOES-UNKNOWN-DEMONS)
  :VOID)

;;; (DEFUN REACT-TO-PROPOSITION-UPDATE ...)

(CL:DEFUN REACT-TO-PROPOSITION-UPDATE (PROPOSITION UPDATEMODE)
  (CL:WHEN
   (CL:EQ PROPOSITION NULL)
   (CL:RETURN-FROM REACT-TO-PROPOSITION-UPDATE))
  (CL:WHEN
   (CL:EQ (DESCRIPTION-MODE?) 0)
   (UPDATE-NOW-TIME-STAMP KWD-PROPOSITIONS-UPDATE-PROPOSITION))
  (CL:COND
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
    (CL:WHEN
     (CL:EQ (DESCRIPTION-MODE?) 0)
     (LOG-NEWLY-BOUND-PROPOSITION *CONTEXT* PROPOSITION))
    (RUN-GOES-TRUE-DEMONS PROPOSITION))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
    (CL:WHEN
     (CL:EQ (DESCRIPTION-MODE?) 0)
     (LOG-NEWLY-BOUND-PROPOSITION *CONTEXT* PROPOSITION))
    (RUN-GOES-FALSE-DEMONS PROPOSITION))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
    (RUN-GOES-UNKNOWN-DEMONS PROPOSITION))
   ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-FALSE)
    (RUN-GOES-UNKNOWN-DEMONS PROPOSITION))
   (CL:T (CL:ERROR "`~A' is not a valid case option" UPDATEMODE)))
  :VOID)

;;; (DEFMETHOD PROPAGATE-KB-CONSTRAINTS ...)

(CL:DEFMETHOD PROPAGATE-KB-CONSTRAINTS ((SELF OBJECT) CONTEXT)
  (CL:SETQ CONTEXT CONTEXT)
  NULL
  :VOID)

;;; (DEFMETHOD PROPAGATE-KB-CONSTRAINTS ...)

(CL:DEFMETHOD PROPAGATE-KB-CONSTRAINTS ((SELF SKOLEM) CONTEXT)
  (CL:LET*
   ((ASSERTEDVALUE
     (ACCESS-IN-CONTEXT
      (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE SELF)
      SELF
      FALSE)))
   (CL:LET*
    ((*CONTEXT* CONTEXT))
    (CL:DECLARE (CL:SPECIAL *CONTEXT*))
    (CL:LET*
     ((DERIVEDVALUE (VALUE-OF SELF)))
     (CL:WHEN
      (CL:AND
       (CL:NOT (CL:EQ ASSERTEDVALUE NULL))
       (CL:EQ (EQL? ASSERTEDVALUE DERIVEDVALUE) 0))
      (EQUATE-VALUES (VALUE-OF ASSERTEDVALUE) DERIVEDVALUE)))))
  :VOID)

;;; (DEFMETHOD PROPAGATE-KB-CONSTRAINTS ...)

(CL:DEFMETHOD PROPAGATE-KB-CONSTRAINTS ((SELF PROPOSITION) CONTEXT)
  (CL:LET*
   ((PARENTTRUTHVALUE
     (ACCESS-IN-CONTEXT
      (CLSYS-SVAL PROPOSITION TRUTH-VALUE SELF)
      SELF
      FALSE)))
   (CL:LET*
    ((*CONTEXT* CONTEXT))
    (CL:DECLARE (CL:SPECIAL *CONTEXT*))
    (CL:WHEN
     (CL:AND
      (CL:NOT
       (CL:EQ
        PARENTTRUTHVALUE
        (ACCESS-IN-CONTEXT
         (CLSYS-SVAL PROPOSITION TRUTH-VALUE SELF)
         SELF
         FALSE)))
      (CL:NOT (CL:EQ PARENTTRUTHVALUE NULL)))
     (SIGNAL-TRUTH-VALUE-CLASH SELF))
    (EVALUATE-PROPOSITION SELF)
    (CL:LET*
     ((PROP NULL)
      (ITER-001
       (CLSYS-SVAL
        LIST
        THE-CONS-LIST
        (CLSYS-SVAL PROPOSITION DEPENDENT-PROPOSITIONS SELF))))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ
        PROP
        (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-PROPOSITIONS-PROPOSITION))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (EVALUATE-PROPOSITION PROP)))))
  :VOID)

;;; (DEFMETHOD REACT-TO-KB-UPDATE ...)

(CL:DEFMETHOD REACT-TO-KB-UPDATE ((SELF CONTEXT) OBJECT)
  (CL:SETQ OBJECT OBJECT)
  NULL
  :VOID)

;;; (DEFMETHOD REACT-TO-KB-UPDATE ...)

(CL:DEFMETHOD REACT-TO-KB-UPDATE ((SELF MODULE) OBJECT)
  (CL:WHEN
   (CL:EQ (DESCRIPTION-MODE?) 1)
   (PROPAGATE-KB-CONSTRAINTS OBJECT *CONTEXT*)
   (CL:RETURN-FROM REACT-TO-KB-UPDATE))
  (CL:LET*
   ((CACHE
     (DYNAMIC-SLOT-VALUE SELF SYM-PROPOSITIONS-STRICT-INFERENCE-CACHE NULL)))
   (CL:WHEN
    (CL:NOT (CL:EQ CACHE NULL))
    (CL:WHEN
     (CL:EQ (PROPAGATE-CONSTRAINTS-INCREMENTALLY? CACHE) 0)
     (CL:ERROR
      "Safety violation: INTERNAL ERROR: `react-to-kb-update' encountered bad cache state."))
    (PROPAGATE-KB-CONSTRAINTS OBJECT CACHE)
    (CL:LET*
     ((CHILD NULL)
      (ITER-001
       (CLSYS-SVAL
        LIST
        THE-CONS-LIST
        (CLSYS-SVAL MODULE CHILD-CONTEXTS SELF))))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ
        CHILD
        (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-PROPOSITIONS-CONTEXT))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:WHEN
       (CL:EQ (ISA? CHILD SGT-PROPOSITIONS-MODULE) 1)
       (CL:LET*
        ((CHILDCACHE
          (LOOKUP-INFERENCE-CACHE
           (CAST CHILD SGT-PROPOSITIONS-MODULE)
           KWD-PROPOSITIONS-STRICT)))
        (CL:WHEN
         (CL:NOT (CL:EQ CHILDCACHE NULL))
         (PROPAGATE-KB-CONSTRAINTS OBJECT CHILDCACHE))))))))
  :VOID)

;;; (DEFMETHOD REACT-TO-KB-UPDATE ...)

(CL:DEFMETHOD REACT-TO-KB-UPDATE ((SELF WORLD) OBJECT)
  (CL:WHEN
   (CL:EQ (PROPAGATE-CONSTRAINTS-INCREMENTALLY? SELF) 1)
   (PROPAGATE-KB-CONSTRAINTS OBJECT SELF))
  :VOID)

;;; (DEFUN ASSIGN-TRUTH-VALUE ...)

(CL:DEFUN ASSIGN-TRUTH-VALUE (SELF VALUE?)
  (CL:LET*
   ((OLDTRUTHVALUE
     (ACCESS-IN-CONTEXT (CLSYS-SVAL PROPOSITION TRUTH-VALUE SELF) SELF FALSE))
    (NEWTRUTHVALUE
     (CL:IF (CL:EQ VALUE? 1) TRUE-TRUTH-VALUE FALSE-TRUTH-VALUE)))
   (CL:COND
    ((CL:EQ OLDTRUTHVALUE NEWTRUTHVALUE) NULL)
    ((CL:NOT (CL:EQ OLDTRUTHVALUE NULL)) (SIGNAL-TRUTH-VALUE-CLASH SELF))
    ((CL:EQ (CLSYS-SVAL PROPOSITION KIND SELF) KWD-PROPOSITIONS-FUNCTION)
     (CL:LET*
      ((OBJECT-001 SELF)
       (VALUE-001 TRUE-TRUTH-VALUE)
       (OLD-VALUE-002 (CLSYS-SVAL PROPOSITION TRUTH-VALUE OBJECT-001))
       (NEW-VALUE-001
        (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-001 OBJECT-001 FALSE)))
      (CL:WHEN
       (CL:EQ (CS-VALUE? OLD-VALUE-002) 0)
       (CL:SETF
        (CLSYS-SVAL PROPOSITION TRUTH-VALUE OBJECT-001)
        NEW-VALUE-001))))
    ((CL:AND
      (CL:EQ (DESCRIPTION-MODE?) 1)
      (CL:EQ (CLSYS-SVAL PROPOSITION KIND SELF) KWD-PROPOSITIONS-CONSTANT))
     NULL)
    (CL:T
     (CL:LET*
      ((OBJECT-002 SELF)
       (VALUE-002 NEWTRUTHVALUE)
       (OLD-VALUE-003 (CLSYS-SVAL PROPOSITION TRUTH-VALUE OBJECT-002))
       (NEW-VALUE-002
        (UPDATE-IN-CONTEXT OLD-VALUE-003 VALUE-002 OBJECT-002 FALSE)))
      (CL:WHEN
       (CL:EQ (CS-VALUE? OLD-VALUE-003) 0)
       (CL:SETF
        (CLSYS-SVAL PROPOSITION TRUTH-VALUE OBJECT-002)
        NEW-VALUE-002)))
     (REACT-TO-PROPOSITION-UPDATE
      SELF
      (CL:IF
       (CL:EQ VALUE? 1)
       KWD-PROPOSITIONS-ASSERT-TRUE
       KWD-PROPOSITIONS-ASSERT-FALSE))
     (REACT-TO-KB-UPDATE *CONTEXT* SELF))))
  :VOID)

;;; (DEFUN DEASSIGN-TRUTH-VALUE ...)

(CL:DEFUN DEASSIGN-TRUTH-VALUE (SELF UPDATEMODE)
  (CL:LET*
   ((OBJECT-001 SELF)
    (VALUE-001 NULL)
    (OLD-VALUE-001 (CLSYS-SVAL PROPOSITION TRUTH-VALUE OBJECT-001))
    (NEW-VALUE-001
     (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001 OBJECT-001 FALSE)))
   (CL:WHEN
    (CL:EQ (CS-VALUE? OLD-VALUE-001) 0)
    (CL:SETF (CLSYS-SVAL PROPOSITION TRUTH-VALUE OBJECT-001) NEW-VALUE-001)))
  (CHECK-FOR-OUT-OF-DATE-INFERENCE-CACHE)
  (REACT-TO-PROPOSITION-UPDATE SELF UPDATEMODE)
  :VOID)

;;; (DEFUN UPDATE-PROPOSITION-TRUTH-VALUE ...)

(CL:DEFUN UPDATE-PROPOSITION-TRUTH-VALUE (SELF UPDATEMODE)
  (CL:LET*
   ((*CONTEXT* (GET-TOP-LEVEL-UPDATE-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *CONTEXT*))
   (CL:COND
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
     (ASSIGN-TRUTH-VALUE SELF TRUE))
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
     (ASSIGN-TRUTH-VALUE SELF FALSE))
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
     (CL:WHEN
      (CL:AND
       (CL:EQ (TRUE? SELF) 1)
       (CL:NOT
        (CL:EQ (CLSYS-SVAL PROPOSITION KIND SELF) KWD-PROPOSITIONS-FUNCTION)))
      (DEASSIGN-TRUTH-VALUE SELF UPDATEMODE)))
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-FALSE)
     (CL:WHEN (CL:EQ (FALSE? SELF) 1) (DEASSIGN-TRUTH-VALUE SELF UPDATEMODE)))
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-CONCEIVE) NULL)
    (CL:T (CL:ERROR "`~A' is not a valid case option" UPDATEMODE))))
  :VOID)

;;; (DEFUN RUN-SLOT-INFERENCE-DEMONS ...)

(CL:DEFUN RUN-SLOT-INFERENCE-DEMONS (SELF SLOT OLDVALUE NEWVALUE)
  (CL:PROGN
   (CL:SETQ SELF SELF)
   (CL:SETQ SLOT SLOT)
   (CL:SETQ OLDVALUE OLDVALUE)
   (CL:SETQ NEWVALUE NEWVALUE))
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
     (CL:LET* ((SELF NULL)) (CL:SETQ SELF SELF-001) "NOT YET IMPLEMENTED"))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN REACT-TO-ATTRIBUTE-PROPOSITION-UPDATE ...)

(CL:DEFUN REACT-TO-ATTRIBUTE-PROPOSITION-UPDATE (SKOLEM OLDVALUE NEWVALUE TOPLEVELUPDATE?)
  (CL:LET*
   ((PROPOSITION (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION SKOLEM))
    (ARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
    (SLOT
     (CAST
      (CLSYS-SVAL
       SURROGATE
       SURROGATE-VALUE
       (CAST
        (CLSYS-SVAL PROPOSITION OPERATOR PROPOSITION)
        SGT-PROPOSITIONS-SLOTREF))
      SGT-PROPOSITIONS-SLOT))
    (FIRSTARG (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0))
    (NATIVEFIRSTARGVALUE (NATIVE-VALUE-OF FIRSTARG)))
   (CL:WHEN
    (CL:AND
     (CL:EQ TOPLEVELUPDATE? 1)
     (CL:NOT (CL:EQ NATIVEFIRSTARGVALUE NULL))
     (CL:EQ (ATTRIBUTE-PROPOSITION? PROPOSITION) 1))
    (CL:IF
     (CL:NOT (CL:EQ NEWVALUE NULL))
     (ASSIGN-ATTRIBUTE-VALUE
      (CAST NATIVEFIRSTARGVALUE SGT-PROPOSITIONS-STANDARD-OBJECT)
      (CAST SLOT SGT-PROPOSITIONS-STORAGE-SLOT)
      NEWVALUE)
     (DROP-ATTRIBUTE-VALUE
      (CAST NATIVEFIRSTARGVALUE SGT-PROPOSITIONS-STANDARD-OBJECT)
      (CAST SLOT SGT-PROPOSITIONS-STORAGE-SLOT)
      OLDVALUE))))
  :VOID)

;;; (DEFUN (PRIMITIVE-SLOT? BOOLEAN) ...)

(CL:DEFUN PRIMITIVE-SLOT? (SLOT)
  (CL:RETURN-FROM
   PRIMITIVE-SLOT?
   (CL:IF
    (CL:OR
     (CL:EQ (DYNAMIC-SLOT-VALUE SLOT SYM-PROPOSITIONS-DESCRIPTION NULL) NULL)
     (CL:EQ
      (CLSYS-SVAL
       DESCRIPTION
       KIND
       (DYNAMIC-SLOT-VALUE SLOT SYM-PROPOSITIONS-DESCRIPTION NULL))
      KWD-PROPOSITIONS-PRIMITIVE))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (ATTRIBUTE-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN ATTRIBUTE-PROPOSITION? (PROPOSITION)
  (CL:LET*
   ((SLOT
     (CAST
      (CLSYS-SVAL
       SURROGATE
       SURROGATE-VALUE
       (CAST
        (CLSYS-SVAL PROPOSITION OPERATOR PROPOSITION)
        SGT-PROPOSITIONS-SLOTREF))
      SGT-PROPOSITIONS-SLOT)))
   (CL:RETURN-FROM
    ATTRIBUTE-PROPOSITION?
    (CL:IF
     (CL:AND
      (CL:NOT (CL:EQ SLOT NULL))
      (CL:EQ (ISA? SLOT SGT-PROPOSITIONS-STORAGE-SLOT) 1)
      (CL:EQ (PRIMITIVE-SLOT? SLOT) 1))
     TRUE
     FALSE)))
  :VOID)

;;; (DEFUN ADD-DEPENDENT-PROPOSITION-LINK ...)

(CL:DEFUN ADD-DEPENDENT-PROPOSITION-LINK (SELF PROPOSITION)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-PROPOSITION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:NOT
        (CL:EQ (CLSYS-SVAL PROPOSITION KIND SELF) KWD-PROPOSITIONS-CONSTANT))
       (INSERT-NEW
        (CLSYS-SVAL PROPOSITION DEPENDENT-PROPOSITIONS SELF)
        PROPOSITION))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-DESCRIPTION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:OR
        (CL:EQ (DESCRIPTION-MODE?) 0)
        (CL:AND
         (CL:EQ (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF) NULL)
         (CL:EQ
          (DYNAMIC-SLOT-VALUE
           SELF
           SYM-PROPOSITIONS-COMPLEMENT-DESCRIPTION
           NULL)
          NULL)))
       (CL:IF
        (CL:AND
         (CL:EQ
          SELF
          (CL:AREF
           (CLSYS-SVAL
            VECTOR
            THE-ARRAY
            (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
           0))
         (CL:EQ (ATTRIBUTE-PROPOSITION? PROPOSITION) 1))
        (ADD-DEPENDENT-ATTRIBUTE-LINK SELF PROPOSITION)
        (INSERT-NEW
         (CLSYS-SVAL DESCRIPTION DEPENDENT-PROPOSITIONS SELF)
         PROPOSITION)))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:EQ (LOGIC-OBJECT-PERMITS-BACKLINKS? SELF) 1)
       (CL:WHEN
        (CL:NOT
         (CL:OR
          (CL:EQ (ISA? SELF SGT-PROPOSITIONS-PATTERN-VARIABLE) 1)
          (CL:EQ (DESCRIPTION-MODE?) 0)))
        (CL:ERROR
         "Safety violation: INTERNAL ERROR: A LOGIC-OBJECT or SKOLEM should never be a proposition argument within a description."))
       (CL:IF
        (CL:AND
         (CL:EQ
          SELF
          (CL:AREF
           (CLSYS-SVAL
            VECTOR
            THE-ARRAY
            (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
           0))
         (CL:EQ (ATTRIBUTE-PROPOSITION? PROPOSITION) 1))
        (ADD-DEPENDENT-ATTRIBUTE-LINK SELF PROPOSITION)
        (CL:LET*
         ((COLLECTION (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS SELF)))
         (CL:WHEN
          (CL:EQ (MEMBER? COLLECTION PROPOSITION) 0)
          (INSERT COLLECTION PROPOSITION)))))))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN REMOVE-DEPENDENT-PROPOSITION-LINK ...)

(CL:DEFUN REMOVE-DEPENDENT-PROPOSITION-LINK (SELF PROPOSITION)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-PROPOSITION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (REMOVE
       (CLSYS-SVAL PROPOSITION DEPENDENT-PROPOSITIONS SELF)
       PROPOSITION)))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:IF
       (CL:AND
        (CL:EQ
         SELF
         (CL:AREF
          (CLSYS-SVAL
           VECTOR
           THE-ARRAY
           (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
          0))
        (CL:EQ (ATTRIBUTE-PROPOSITION? PROPOSITION) 1))
       (REMOVE-DEPENDENT-ATTRIBUTE-LINK SELF PROPOSITION)
       (REMOVE
        (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS SELF)
        PROPOSITION))))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN (SLOTREF-LESS-OR-EQUAL? BOOLEAN) ...)

(CL:DEFUN SLOTREF-LESS-OR-EQUAL? (SLOT1 SLOT2)
  (CL:RETURN-FROM
   SLOTREF-LESS-OR-EQUAL?
   (<=
    (CLSYS-SVAL SURROGATE SYMBOL-ID SLOT1)
    (CLSYS-SVAL SURROGATE SYMBOL-ID SLOT2)))
  :VOID)

;;; (DEFUN (SLOTREF-LESS-THAN? BOOLEAN) ...)

(CL:DEFUN SLOTREF-LESS-THAN? (SLOT1 SLOT2)
  (CL:RETURN-FROM
   SLOTREF-LESS-THAN?
   (<
    (CLSYS-SVAL SURROGATE SYMBOL-ID SLOT1)
    (CLSYS-SVAL SURROGATE SYMBOL-ID SLOT2)))
  :VOID)

;;; (DEFUN INSERT-SORTED-BY-SLOTREF ...)

(CL:DEFUN INSERT-SORTED-BY-SLOTREF (SELF PROPOSITION)
  (CL:LET*
   ((CURSOR (CLSYS-SVAL LIST THE-CONS-LIST SELF))
    (TRAILER NULL)
    (KEY
     (CAST
      (CLSYS-SVAL PROPOSITION OPERATOR PROPOSITION)
      SGT-PROPOSITIONS-SLOTREF))
    (SLOTREF NULL))
   (CL:WHEN
    (CL:EQ CURSOR NIL)
    (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST SELF) (CONS-LIST PROPOSITION))
    (CL:RETURN-FROM INSERT-SORTED-BY-SLOTREF))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:SETQ
     SLOTREF
     (CAST
      (CLSYS-SVAL PROPOSITION OPERATOR (CLSYS-SVAL CONS VALUE CURSOR))
      SGT-PROPOSITIONS-SLOTREF))
    (CL:WHEN
     (CL:EQ (SLOTREF-LESS-OR-EQUAL? KEY SLOTREF) 1)
     (CL:WHEN
      (CL:EQ KEY SLOTREF)
      (CL:SETF (CLSYS-SVAL CONS VALUE CURSOR) PROPOSITION)
      (CL:RETURN-FROM INSERT-SORTED-BY-SLOTREF))
     (CL:IF
      (CL:EQ TRAILER NULL)
      (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST SELF) (CONS PROPOSITION CURSOR))
      (CL:SETF (CLSYS-SVAL CONS REST TRAILER) (CONS PROPOSITION CURSOR)))
     (CL:RETURN-FROM INSERT-SORTED-BY-SLOTREF))
    (CL:SETQ TRAILER CURSOR)
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (CL:SETF (CLSYS-SVAL CONS REST TRAILER) (CONS-LIST PROPOSITION)))
  :VOID)

;;; (DEFUN ADD-DEPENDENT-ATTRIBUTE-LINK ...)

(CL:DEFUN ADD-DEPENDENT-ATTRIBUTE-LINK (OBJECT PROPOSITION)
  (INSERT-SORTED-BY-SLOTREF
   (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-ATTRIBUTE-PROPOSITIONS OBJECT)
   PROPOSITION)
  :VOID)

;;; (DEFUN REMOVE-DEPENDENT-ATTRIBUTE-LINK ...)

(CL:DEFUN REMOVE-DEPENDENT-ATTRIBUTE-LINK (OBJECT PROPOSITION)
  (REMOVE
   (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-ATTRIBUTE-PROPOSITIONS OBJECT)
   PROPOSITION)
  :VOID)

;;; (DEFUN SIGNAL-UNDEFINED-SLOT-VALUE-FAILURE ...)

(CL:DEFUN SIGNAL-UNDEFINED-SLOT-VALUE-FAILURE (OBJECT SLOTREF)
  (SIGNAL-FAIL)
  (CL:LET*
   ((*PRINTREADABLY?* TRUE))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "Error in logical expression." %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "   Null value for slot " %%STREAM)
    (PRINT-OBJECT SLOTREF %%STREAM)
    (CL:WRITE-STRING " applied to " %%STREAM)
    (PRINT-OBJECT OBJECT %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING
     "   Error occured while parsing the proposition: "
     %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "   " %%STREAM)
    (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (SIGNAL *THE-PROPOSITION-ERROR*))
  :VOID)

;;; (DEFUN ASSIGN-ATTRIBUTE-VALUE ...)

(CL:DEFUN ASSIGN-ATTRIBUTE-VALUE (SELF SLOT VALUE)
  (CL:WHEN (CL:EQ (SKOLEM? VALUE) 1) (CL:RETURN-FROM ASSIGN-ATTRIBUTE-VALUE))
  (CL:LET*
   ((OLDVALUE (READ-SLOT-VALUE SELF SLOT)))
   (CL:WHEN
    (CL:EQ (EQL? OLDVALUE VALUE) 1)
    (CL:RETURN-FROM ASSIGN-ATTRIBUTE-VALUE))
   (CL:WHEN
    (CL:NOT (CL:EQ OLDVALUE NULL))
    (SIGNAL-UNIFICATION-CLASH OLDVALUE VALUE))
   (PUT-SLOT-VALUE SELF SLOT VALUE))
  :VOID)

;;; (DEFUN CLEAR-ATTRIBUTE-VALUE ...)

(CL:DEFUN CLEAR-ATTRIBUTE-VALUE (OBJECT SLOT)
  (PUT-SLOT-VALUE OBJECT SLOT NULL)
  :VOID)

;;; (DEFUN DROP-ATTRIBUTE-VALUE ...)

(CL:DEFUN DROP-ATTRIBUTE-VALUE (SELF SLOT VALUE)
  (CL:LET*
   ((OLDVALUE (READ-SLOT-VALUE SELF SLOT)))
   (CL:WHEN (CL:EQ (EQL? VALUE OLDVALUE) 1) (CLEAR-ATTRIBUTE-VALUE SELF SLOT)))
  :VOID)

;;; (DEFUN (LOOKUP-SLOTREF-ON-INSTANCE SLOTREF) ...)

(CL:DEFUN LOOKUP-SLOTREF-ON-INSTANCE (TERM SLOTNAME)
  (CL:LET*
   ((TERMTYPE NULL))
   (CL:SETQ TERMTYPE (LOGICAL-TYPE TERM))
   (CL:WHEN
    (CL:EQ TERMTYPE NULL)
    (SIGNAL-UNDEFINED-TERM TERM)
    (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE NULL))
   (CL:WHEN
    (CL:EQ
     (CAST
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE TERMTYPE)
      SGT-PROPOSITIONS-CLASS)
     NULL)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING "Error in logical expression." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING "   Reference to undefined class named " %%STREAM)
      (CL:WRITE-STRING (CLSYS-SVAL SURROGATE SYMBOL-NAME TERMTYPE) %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING
       "   Error occured while parsing the proposition: "
       %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING "   " %%STREAM)
      (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (SIGNAL *THE-PROPOSITION-ERROR*))
    (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE NULL))
   (CL:WHEN
    (CL:EQ (SUBTYPE-OF? TERMTYPE SGT-PROPOSITIONS-LITERAL) 1)
    (CL:SETQ TERMTYPE (TYPE-TO-WRAPPED-TYPE TERMTYPE)))
   (CL:LET*
    ((SLOTREF (LOOKUP-SLOTREF TERMTYPE SLOTNAME)))
    (CL:WHEN
     (CL:NOT (CL:EQ SLOTREF NULL))
     (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE SLOTREF))
    (CL:LET*
     ((TERM-001 TERM))
     (CL:COND
      ((CL:EQ (TAXONOMY-ISA? TERM SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
       (CL:LET*
        ((TERM NULL))
        (CL:SETQ TERM TERM-001)
        (CL:LET*
         ((PROP NULL)
          (ITER-001
           (CLSYS-SVAL
            LIST
            THE-CONS-LIST
            (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS TERM))))
         (CL:LOOP
          WHILE
          (CL:NOT (CL:EQ ITER-001 NIL))
          DO
          (CL:PROGN
           (CL:SETQ
            PROP
            (CAST
             (CLSYS-SVAL CONS VALUE ITER-001)
             SGT-PROPOSITIONS-PROPOSITION))
           (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
          (CL:WHEN
           (CL:AND
            (CL:EQ (CLSYS-SVAL PROPOSITION KIND PROP) KWD-PROPOSITIONS-IN)
            (CL:EQ
             (TYPE?
              (CL:AREF
               (CLSYS-SVAL
                VECTOR
                THE-ARRAY
                (CLSYS-SVAL PROPOSITION ARGUMENTS PROP))
               1))
             1))
           (CL:SETQ
            SLOTREF
            (LOOKUP-SLOTREF
             (CAST
              (CL:AREF
               (CLSYS-SVAL
                VECTOR
                THE-ARRAY
                (CLSYS-SVAL PROPOSITION ARGUMENTS PROP))
               1)
              SGT-PROPOSITIONS-TYPE)
             SLOTNAME))
           (CL:WHEN
            (CL:NOT (CL:EQ SLOTREF NULL))
            (CL:RETURN-FROM LOOKUP-SLOTREF-ON-INSTANCE SLOTREF)))))))
      (CL:T NULL)))
    (CL:IF
     (CL:EQ (LOGICAL-TYPE TERM) SGT-PROPOSITIONS-UNKNOWN)
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "Error in logical expression." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "   Can't find a slot " %%STREAM)
       (PRINT-OBJECT SLOTNAME %%STREAM)
       (CL:WRITE-STRING " on the term " %%STREAM)
       (PRINT-OBJECT TERM %%STREAM)
       (CL:WRITE-STRING " because the " %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING "   type of " %%STREAM)
       (PRINT-OBJECT TERM %%STREAM)
       (CL:WRITE-STRING " is unknown." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING
        "   Error occured while parsing the proposition: "
        %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "   " %%STREAM)
       (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (SIGNAL *THE-PROPOSITION-ERROR*))
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "Error in logical expression." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "   Reference to undefined slot " %%STREAM)
       (CL:WRITE-STRING (CLSYS-SVAL SURROGATE SYMBOL-NAME TERMTYPE) %%STREAM)
       (CL:WRITE-STRING "." %%STREAM)
       (PRINT-OBJECT SLOTNAME %%STREAM)
       (CL:WRITE-STRING " applied to " %%STREAM)
       (PRINT-OBJECT TERM %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING
        "   Error occured while parsing the proposition: "
        %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "   " %%STREAM)
       (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (SIGNAL *THE-PROPOSITION-ERROR*)))))
  :VOID)

;;; (DEFMETHOD (APPLY-SLOT-TO-NATIVE-ARGUMENTS OBJECT) ...)

(CL:DEFMETHOD APPLY-SLOT-TO-NATIVE-ARGUMENTS ((SLOT SLOT) ARGUMENTS)
  (CL:SETQ ARGUMENTS ARGUMENTS)
  (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-ARGUMENTS BOTTOM)
  :VOID)

;;; (DEFMETHOD (APPLY-SLOT-TO-NATIVE-ARGUMENTS OBJECT) ...)

(CL:DEFMETHOD APPLY-SLOT-TO-NATIVE-ARGUMENTS ((SLOT STORAGE-SLOT) ARGUMENTS)
  (CL:WHEN
   (CL:EQ (LOGIC-SLOT? SLOT) 1)
   (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-ARGUMENTS BOTTOM))
  (CL:LET*
   ((FIRSTARG
     (NATIVE-VALUE-OF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0))))
   (CL:IF
    (CL:NOT (CL:EQ FIRSTARG NULL))
    (CL:RETURN-FROM
     APPLY-SLOT-TO-NATIVE-ARGUMENTS
     (READ-SLOT-VALUE (CAST FIRSTARG SGT-PROPOSITIONS-STANDARD-OBJECT) SLOT))
    (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-ARGUMENTS BOTTOM)))
  :VOID)

;;; (DEFMETHOD (APPLY-SLOT-TO-NATIVE-ARGUMENTS OBJECT) ...)

(CL:DEFMETHOD APPLY-SLOT-TO-NATIVE-ARGUMENTS ((SLOT METHOD-SLOT) ARGUMENTS)
  (CL:WHEN
   (CL:EQ (LOGIC-SLOT? SLOT) 1)
   (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-ARGUMENTS BOTTOM))
  (CL:LET*
   ((CODE (CLSYS-SVAL METHOD-SLOT METHOD-CODE SLOT)))
   (CL:CASE
    (METHOD-ARGUMENT-COUNT SLOT)
    (1
     (CL:LET*
      ((FIRSTARG
        (NATIVE-VALUE-OF
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0))))
      (CL:IF
       (CL:NOT (CL:EQ FIRSTARG NULL))
       (CL:RETURN-FROM
        APPLY-SLOT-TO-NATIVE-ARGUMENTS
        (CL:FUNCALL CODE FIRSTARG))
       (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-ARGUMENTS BOTTOM))))
    (2
     (CL:LET*
      ((FIRSTARG
        (NATIVE-VALUE-OF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0)))
       (SECONDARG
        (NATIVE-VALUE-OF
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 1))))
      (CL:IF
       (CL:AND (CL:NOT (CL:EQ FIRSTARG NULL)) (CL:NOT (CL:EQ SECONDARG NULL)))
       (CL:RETURN-FROM
        APPLY-SLOT-TO-NATIVE-ARGUMENTS
        (CL:FUNCALL CODE FIRSTARG SECONDARG))
       (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-ARGUMENTS BOTTOM))))
    (3
     (CL:LET*
      ((FIRSTARG
        (NATIVE-VALUE-OF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0)))
       (SECONDARG
        (NATIVE-VALUE-OF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 1)))
       (THIRDARG
        (NATIVE-VALUE-OF
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 2))))
      (CL:IF
       (CL:AND
        (CL:NOT (CL:EQ FIRSTARG NULL))
        (CL:NOT (CL:EQ SECONDARG NULL))
        (CL:NOT (CL:EQ THIRDARG NULL)))
       (CL:RETURN-FROM
        APPLY-SLOT-TO-NATIVE-ARGUMENTS
        (CL:FUNCALL CODE FIRSTARG SECONDARG THIRDARG))
       (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-ARGUMENTS BOTTOM))))
    (4
     (CL:LET*
      ((FIRSTARG
        (NATIVE-VALUE-OF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0)))
       (SECONDARG
        (NATIVE-VALUE-OF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 1)))
       (THIRDARG
        (NATIVE-VALUE-OF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 2)))
       (FOURTHARG
        (NATIVE-VALUE-OF
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 3))))
      (CL:IF
       (CL:AND
        (CL:NOT (CL:EQ FIRSTARG NULL))
        (CL:NOT (CL:EQ SECONDARG NULL))
        (CL:NOT (CL:EQ THIRDARG NULL))
        (CL:NOT (CL:EQ FOURTHARG NULL)))
       (CL:RETURN-FROM
        APPLY-SLOT-TO-NATIVE-ARGUMENTS
        (CL:FUNCALL CODE FIRSTARG SECONDARG THIRDARG FOURTHARG))
       (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-ARGUMENTS BOTTOM))))
    (5
     (CL:LET*
      ((FIRSTARG
        (NATIVE-VALUE-OF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0)))
       (SECONDARG
        (NATIVE-VALUE-OF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 1)))
       (THIRDARG
        (NATIVE-VALUE-OF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 2)))
       (FOURTHARG
        (NATIVE-VALUE-OF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 3)))
       (FIFTHARG
        (NATIVE-VALUE-OF
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 4))))
      (CL:IF
       (CL:AND
        (CL:NOT (CL:EQ FIRSTARG NULL))
        (CL:NOT (CL:EQ SECONDARG NULL))
        (CL:NOT (CL:EQ THIRDARG NULL))
        (CL:NOT (CL:EQ FOURTHARG NULL))
        (CL:NOT (CL:EQ FIFTHARG NULL)))
       (CL:RETURN-FROM
        APPLY-SLOT-TO-NATIVE-ARGUMENTS
        (CL:FUNCALL CODE FIRSTARG SECONDARG THIRDARG FOURTHARG FIFTHARG))
       (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-ARGUMENTS BOTTOM))))
    (CL:OTHERWISE
     (CL:WARN "Too many arguments in predication.  Max 5.  Slot is `~A'" SLOT)
     (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-ARGUMENTS BOTTOM))))
  :VOID)

;;; (DEFUN (UNBOUND? BOOLEAN) ...)

(CL:DEFUN UNBOUND? (SKOLEM)
  (CL:RETURN-FROM
   UNBOUND?
   (NULL?
    (ACCESS-IN-CONTEXT
     (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE SKOLEM)
     SKOLEM
     FALSE)))
  :VOID)

;;; (DEFMETHOD (VALUE-OF OBJECT) ...)

(CL:DEFMETHOD VALUE-OF ((SELF OBJECT))
  (CL:RETURN-FROM VALUE-OF SELF)
  :VOID)

;;; (DEFMETHOD (VALUE-OF OBJECT) ...)

(CL:DEFMETHOD VALUE-OF ((SELF SURROGATE))
  (CL:LET*
   ((VALUE (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)))
   (CL:IF
    (CL:NOT (CL:EQ VALUE NULL))
    (CL:RETURN-FROM VALUE-OF (VALUE-OF VALUE))
    (CL:PROGN
     (CL:WARN
      "Unbound surrogate: `~A'~%"
      (CLSYS-SVAL SURROGATE SYMBOL-NAME SELF))
     (CL:RETURN-FROM VALUE-OF NULL))))
  :VOID)

;;; (DEFMETHOD (VALUE-OF OBJECT) ...)

(CL:DEFMETHOD VALUE-OF ((SELF SKOLEM))
  (CL:IF
   (CL:EQ
    (ACCESS-IN-CONTEXT
     (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE SELF)
     SELF
     FALSE)
    NULL)
   (CL:RETURN-FROM VALUE-OF SELF)
   (CL:RETURN-FROM
    VALUE-OF
    (VALUE-OF
     (ACCESS-IN-CONTEXT
      (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE SELF)
      SELF
      FALSE))))
  :VOID)

;;; (DEFMETHOD (VALUE-OF OBJECT) ...)

(CL:DEFMETHOD VALUE-OF ((SELF RELATION))
  (CL:LET*
   ((DESCRIPTION (DYNAMIC-SLOT-VALUE SELF SYM-PROPOSITIONS-DESCRIPTION NULL)))
   (CL:WHEN
    (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:RETURN-FROM VALUE-OF DESCRIPTION))
   (CL:LET*
    ((SELF-001 SELF))
    (CL:COND
     ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-RELATION) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:SETQ DESCRIPTION (GET-DESCRIPTION SELF))))
     (CL:T NULL)))
   (CL:WHEN
    (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:RETURN-FROM VALUE-OF DESCRIPTION))
   (CL:WARN
    "VALUE-OF encountered missing description on class or relation `~A'"
    (NAME SELF))
   (CL:RETURN-FROM VALUE-OF NULL))
  :VOID)

;;; (DEFUN (SKOLEM? BOOLEAN) ...)

(CL:DEFUN SKOLEM? (SELF)
  (CL:RETURN-FROM SKOLEM? (ISA? SELF SGT-PROPOSITIONS-SKOLEM))
  :VOID)

;;; (DEFUN (VARIABLE? BOOLEAN) ...)

(CL:DEFUN VARIABLE? (SELF)
  (CL:RETURN-FROM VARIABLE? (ISA? SELF SGT-PROPOSITIONS-PATTERN-VARIABLE))
  :VOID)

;;; (DEFUN (NATIVE-VALUE? BOOLEAN) ...)

(CL:DEFUN NATIVE-VALUE? (SELF)
  (CL:IF
   (CL:NOT (CL:EQ SELF NULL))
   (CL:RETURN-FROM
    NATIVE-VALUE?
    (CL:IF (CL:EQ (ISA? SELF SGT-PROPOSITIONS-LOGIC-OBJECT) 0) TRUE FALSE))
   (CL:RETURN-FROM NATIVE-VALUE? FALSE))
  :VOID)

;;; (DEFUN (NATIVE-VALUE-OF OBJECT) ...)

(CL:DEFUN NATIVE-VALUE-OF (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-DESCRIPTION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       NATIVE-VALUE-OF
       (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-SKOLEM) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((VALUE
         (ACCESS-IN-CONTEXT
          (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE SELF)
          SELF
          FALSE)))
       (CL:IF
        (CL:NOT (CL:EQ VALUE NULL))
        (CL:RETURN-FROM NATIVE-VALUE-OF (NATIVE-VALUE-OF VALUE))
        (CL:RETURN-FROM NATIVE-VALUE-OF NULL)))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       NATIVE-VALUE-OF
       (ACCESS-IN-CONTEXT
        (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE SELF)
        SELF
        FALSE))))
    ((CL:EQ (SURROGATE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((VALUE (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)))
       (CL:IF
        (CL:NOT (CL:EQ VALUE NULL))
        (CL:RETURN-FROM NATIVE-VALUE-OF (NATIVE-VALUE-OF VALUE))
        (CL:RETURN-FROM NATIVE-VALUE-OF NULL)))))
    (CL:T (CL:RETURN-FROM NATIVE-VALUE-OF SELF))))
  :VOID)

;;; (DEFUN (EQUIVALENT-OF LOGIC-OBJECT) ...)

(CL:DEFUN EQUIVALENT-OF (SELF)
  (CL:LET*
   ((EQUIVALENT SELF) (VALUE NULL))
   (CL:LOOP
    (CL:SETQ
     VALUE
     (ACCESS-IN-CONTEXT
      (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE EQUIVALENT)
      EQUIVALENT
      FALSE))
    (CL:WHEN
     (CL:OR
      (CL:EQ VALUE NULL)
      (CL:EQ (ISA? VALUE SGT-PROPOSITIONS-LOGIC-OBJECT) 0))
     (CL:RETURN-FROM EQUIVALENT-OF EQUIVALENT))
    (CL:SETQ EQUIVALENT (CAST VALUE SGT-PROPOSITIONS-LOGIC-OBJECT))))
  :VOID)

;;; (DEFUN (INNERMOST-VARIABLE-OF PATTERN-VARIABLE) ...)

(CL:DEFUN INNERMOST-VARIABLE-OF (SELF)
  (CL:LOOP
   (CL:LET*
    ((TIGHTESTVARIABLE SELF) (VALUE NULL))
    (CL:LOOP
     (CL:SETQ
      VALUE
      (ACCESS-IN-CONTEXT
       (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE TIGHTESTVARIABLE)
       TIGHTESTVARIABLE
       FALSE))
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ VALUE NULL)) (CL:EQ (VARIABLE? VALUE) 1))
      (CL:SETQ
       TIGHTESTVARIABLE
       (CAST VALUE SGT-PROPOSITIONS-PATTERN-VARIABLE))
      (CL:RETURN-FROM INNERMOST-VARIABLE-OF TIGHTESTVARIABLE)))))
  :VOID)

;;; (DEFUN (INNERMOST-OF OBJECT) ...)

(CL:DEFUN INNERMOST-OF (SELF)
  (CL:IF
   (CL:EQ (DESCRIPTION-MODE?) 1)
   (CL:LET*
    ((NEXTVALUE SELF) (TIGHTESTVARIABLE NULL) (EQUIVALENT NULL))
    (CL:LOOP
     (CL:LET*
      ((NEXTVALUE-001 NEXTVALUE))
      (CL:COND
       ((CL:EQ (TAXONOMY-ISA? NEXTVALUE SGT-PROPOSITIONS-PATTERN-VARIABLE) 1)
        (CL:LET*
         ((NEXTVALUE NULL))
         (CL:SETQ NEXTVALUE NEXTVALUE-001)
         (CL:SETQ
          EQUIVALENT
          (ACCESS-IN-CONTEXT
           (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE NEXTVALUE)
           NEXTVALUE
           FALSE))
         (CL:WHEN
          (CL:EQ EQUIVALENT NULL)
          (CL:RETURN-FROM INNERMOST-OF NEXTVALUE))
         (CL:SETQ TIGHTESTVARIABLE NEXTVALUE)))
       ((CL:EQ (TAXONOMY-ISA? NEXTVALUE SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
        (CL:LET*
         ((NEXTVALUE NULL))
         (CL:SETQ NEXTVALUE NEXTVALUE-001)
         (CL:RETURN-FROM INNERMOST-OF TIGHTESTVARIABLE)))
       ((CL:EQ (SURROGATE? NEXTVALUE) 1)
        (CL:LET*
         ((NEXTVALUE NULL))
         (CL:SETQ NEXTVALUE NEXTVALUE-001)
         (CL:RETURN-FROM INNERMOST-OF NEXTVALUE)))
       (CL:T (CL:RETURN-FROM INNERMOST-OF NEXTVALUE))))
     (CL:SETQ NEXTVALUE EQUIVALENT)))
   (CL:LET*
    ((TIGHTESTVALUE SELF) (EQUIVALENT NULL))
    (CL:LOOP
     (CL:LET*
      ((TIGHTESTVALUE-001 TIGHTESTVALUE))
      (CL:COND
       ((CL:EQ (TAXONOMY-ISA? TIGHTESTVALUE SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
        (CL:LET*
         ((TIGHTESTVALUE NULL))
         (CL:SETQ TIGHTESTVALUE TIGHTESTVALUE-001)
         (CL:WHEN
          (CL:EQ
           (ACCESS-IN-CONTEXT
            (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE TIGHTESTVALUE)
            TIGHTESTVALUE
            FALSE)
           NULL)
          (CL:RETURN-FROM INNERMOST-OF TIGHTESTVALUE))
         (CL:SETQ
          EQUIVALENT
          (ACCESS-IN-CONTEXT
           (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE TIGHTESTVALUE)
           TIGHTESTVALUE
           FALSE))))
       ((CL:EQ (SURROGATE? TIGHTESTVALUE) 1)
        (CL:LET*
         ((TIGHTESTVALUE NULL))
         (CL:SETQ TIGHTESTVALUE TIGHTESTVALUE-001)
         (CL:WHEN
          (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE TIGHTESTVALUE) NULL)
          (CL:RETURN-FROM INNERMOST-OF TIGHTESTVALUE))
         (CL:SETQ
          EQUIVALENT
          (CLSYS-SVAL SURROGATE SURROGATE-VALUE TIGHTESTVALUE))))
       (CL:T (CL:RETURN-FROM INNERMOST-OF TIGHTESTVALUE))))
     (CL:SETQ TIGHTESTVALUE EQUIVALENT))))
  :VOID)

;;; (DEFUN (COMPUTE-FUNCTION-VALUE OBJECT) ...)

(CL:DEFUN COMPUTE-FUNCTION-VALUE (SELF)
  (CL:RETURN-FROM
   COMPUTE-FUNCTION-VALUE
   (APPLY-SLOT-TO-NATIVE-ARGUMENTS
    (CAST
     (CLSYS-SVAL
      SURROGATE
      SURROGATE-VALUE
      (CAST (CLSYS-SVAL PROPOSITION OPERATOR SELF) SGT-PROPOSITIONS-SLOTREF))
     SGT-PROPOSITIONS-SLOT)
    (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)))
  :VOID)

;;; (DEFUN (LAST-ARGUMENT OBJECT) ...)

(CL:DEFUN LAST-ARGUMENT (PROPOSITION)
  (CL:RETURN-FROM
   LAST-ARGUMENT
   (CL:AREF
    (CLSYS-SVAL
     VECTOR
     THE-ARRAY
     (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
    (CL:1- (LENGTH (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION)))))
  :VOID)

;;; (DEFUN (FUNCTION-VALUE OBJECT) ...)

(CL:DEFUN FUNCTION-VALUE (SELF)
  (CL:LET*
   ((OUTPUTVALUE (LAST-ARGUMENT SELF)))
   (CL:WHEN
    (CL:NOT (CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION))
    (CL:RETURN-FROM FUNCTION-VALUE OUTPUTVALUE))
   (CL:SETQ OUTPUTVALUE (VALUE-OF OUTPUTVALUE))
   (CL:WHEN
    (CL:EQ (SKOLEM? OUTPUTVALUE) 0)
    (CL:RETURN-FROM FUNCTION-VALUE OUTPUTVALUE))
   (CL:LET*
    ((COMPUTEDVALUE (COMPUTE-FUNCTION-VALUE SELF)))
    (CL:WHEN
     (CL:EQ (BOTTOM? COMPUTEDVALUE) 0)
     (BIND-SKOLEM-TO-VALUE
      (CAST OUTPUTVALUE SGT-PROPOSITIONS-SKOLEM)
      COMPUTEDVALUE
      FALSE)
     (CL:RETURN-FROM FUNCTION-VALUE COMPUTEDVALUE)))
   (CL:RETURN-FROM FUNCTION-VALUE OUTPUTVALUE))
  :VOID)

;;; (DEFUN (FUNCTION-REPRESENTATIVE OBJECT) ...)

(CL:DEFUN FUNCTION-REPRESENTATIVE (SELF)
  (CL:RETURN-FROM FUNCTION-REPRESENTATIVE (LAST-ARGUMENT SELF))
  :VOID)

;;; (DEFUN (COMPUTE-PREDICATE-VALUE BOOLEAN BOOLEAN) ...)

(CL:DEFUN COMPUTE-PREDICATE-VALUE (SELF)
  (CL:LET*
   ((VALUE NULL))
   (CL:SETQ
    VALUE
    (APPLY-SLOT-TO-NATIVE-ARGUMENTS
     (CAST
      (CLSYS-SVAL
       SURROGATE
       SURROGATE-VALUE
       (CAST (CLSYS-SVAL PROPOSITION OPERATOR SELF) SGT-PROPOSITIONS-SLOTREF))
      SGT-PROPOSITIONS-SLOT)
     (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)))
   (CL:IF
    (CL:EQ (BOTTOM? VALUE) 1)
    (CL:RETURN-FROM COMPUTE-PREDICATE-VALUE (CL:VALUES FALSE FALSE))
    (CL:RETURN-FROM
     COMPUTE-PREDICATE-VALUE
     (CL:VALUES
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-PROPOSITIONS-BOOLEAN-WRAPPER))
      TRUE))))
  :VOID)

;;; (DEFGLOBAL *SKOLEM-ID-COUNTER* ...)

(CL:DEFVAR *SKOLEM-ID-COUNTER* 0)

;;; (DEFUN (YIELD-ANONYMOUS-SKOLEM-NAME SYMBOL) ...)

(CL:DEFUN YIELD-ANONYMOUS-SKOLEM-NAME (VARIABLE?)
  (CL:SETQ *SKOLEM-ID-COUNTER* (CL:1+ *SKOLEM-ID-COUNTER*))
  (CL:RETURN-FROM
   YIELD-ANONYMOUS-SKOLEM-NAME
   (INTERN-SYMBOL
    (CONCATENATE
     (CL:IF (CL:EQ VARIABLE? 1) "?V" "SK")
     (INTEGER-TO-STRING *SKOLEM-ID-COUNTER*))))
  :VOID)

;;; (DEFSPECIAL *FREESKOLEMS* ...)

(CL:DEFVAR *FREESKOLEMS* NULL
  "Cons-list of top-level existentially-quantified skolems.")

(CL:DEFUN READ-*FREESKOLEMS* ()
  (CL:RETURN-FROM READ-*FREESKOLEMS* *FREESKOLEMS*)
  :VOID)

(CL:DEFUN WRITE-*FREESKOLEMS* (VALUE)
  (CL:SETQ *FREESKOLEMS* VALUE)
  (CL:RETURN-FROM WRITE-*FREESKOLEMS* VALUE)
  :VOID)

;;; (DEFUN (HELP-CREATE-SKOLEM SKOLEM) ...)

(CL:DEFUN HELP-CREATE-SKOLEM (SELF TYPE NAME ASSERTIN?)
  (CL:WHEN
   (CL:NOT
    (CL:OR
     (CL:EQ TYPE NULL)
     (CL:EQ (SUBTYPE-OF? TYPE SGT-PROPOSITIONS-LITERAL-WRAPPER) 0)))
   (CL:ERROR
    "Safety violation: INTERNAL ERROR: Need to copy unwrapping logic from `create-function-proposition' into `help-create-skolem'."))
  (CL:WHEN
   (CL:EQ NAME NULL)
   (CL:SETQ NAME (YIELD-ANONYMOUS-SKOLEM-NAME (VARIABLE? SELF))))
  (SET-DYNAMIC-SLOT-VALUE SELF SYM-PROPOSITIONS-SKOLEM-NAME NAME NULL)
  (CL:WHEN (CL:EQ ASSERTIN? 1) (ASSERT-ISA-PROPOSITION SELF TYPE))
  (CL:RETURN-FROM HELP-CREATE-SKOLEM SELF)
  :VOID)

;;; (DEFUN (CREATE-SKOLEM SKOLEM) ...)

(CL:DEFUN CREATE-SKOLEM (TYPE NAME)
  (CL:WHEN
   (CL:EQ (DESCRIPTION-MODE?) 1)
   (CL:ERROR
    "Safety violation: INTERNAL ERROR: Trying to create a skolem in description mode."))
  (CL:LET*
   ((SKOLEM (NEW-SKOLEM)))
   (CL:SETQ *FREESKOLEMS* (CONS SKOLEM *FREESKOLEMS*))
   (HELP-CREATE-SKOLEM SKOLEM TYPE NAME TRUE)
   (CL:RETURN-FROM CREATE-SKOLEM SKOLEM))
  :VOID)

;;; (DEFUN (CREATE-VARIABLE PATTERN-VARIABLE) ...)

(CL:DEFUN CREATE-VARIABLE (TYPE NAME ASSERTIN?)
  (CL:LET*
   ((EVALUATIONMODE *EVALUATIONMODE*))
   (CL:LET*
    ((*EVALUATIONMODE* EVALUATIONMODE))
    (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
    (CL:WHEN
     (CL:AND (CL:EQ ASSERTIN? 1) (CL:EQ (DESCRIPTION-MODE?) 0))
     (CL:SETQ *EVALUATIONMODE* KWD-PROPOSITIONS-DESCRIPTION))
    (CL:RETURN-FROM
     CREATE-VARIABLE
     (CAST
      (HELP-CREATE-SKOLEM (NEW-PATTERN-VARIABLE) TYPE NAME ASSERTIN?)
      SGT-PROPOSITIONS-PATTERN-VARIABLE))))
  :VOID)

;;; (DEFCONSTANT TRUE-TRUTH-VALUE ...)

(CL:DEFVAR TRUE-TRUTH-VALUE NULL
  "Value representing TRUE.")

;;; (DEFCONSTANT FALSE-TRUTH-VALUE ...)

(CL:DEFVAR FALSE-TRUTH-VALUE NULL
  "Value representing FALSE.")

;;; (DEFUN (TRUE? BOOLEAN) ...)

(CL:DEFUN TRUE? (SELF)
  (CL:RETURN-FROM
   TRUE?
   (EQ?
    (ACCESS-IN-CONTEXT (CLSYS-SVAL PROPOSITION TRUTH-VALUE SELF) SELF FALSE)
    TRUE-TRUTH-VALUE))
  :VOID)

;;; (DEFUN (FALSE? BOOLEAN) ...)

(CL:DEFUN FALSE? (SELF)
  (CL:RETURN-FROM
   FALSE?
   (EQ?
    (ACCESS-IN-CONTEXT (CLSYS-SVAL PROPOSITION TRUTH-VALUE SELF) SELF FALSE)
    FALSE-TRUTH-VALUE))
  :VOID)

;;; (DEFUN (UNKNOWN? BOOLEAN) ...)

(CL:DEFUN UNKNOWN? (SELF)
  (CL:RETURN-FROM
   UNKNOWN?
   (CL:IF
    (CL:OR
     (CL:EQ
      (ACCESS-IN-CONTEXT (CLSYS-SVAL PROPOSITION TRUTH-VALUE SELF) SELF FALSE)
      NULL)
     (CL:AND
      (CL:NOT
       (CL:EQ
        (ACCESS-IN-CONTEXT
         (CLSYS-SVAL PROPOSITION TRUTH-VALUE SELF)
         SELF
         FALSE)
        TRUE-TRUTH-VALUE))
      (CL:NOT
       (CL:EQ
        (ACCESS-IN-CONTEXT
         (CLSYS-SVAL PROPOSITION TRUTH-VALUE SELF)
         SELF
         FALSE)
        FALSE-TRUTH-VALUE))))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN SIGNAL-UNIFICATION-CLASH ...)

(CL:DEFUN SIGNAL-UNIFICATION-CLASH (TERM1 TERM2)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ TERM1 NULL)) (CL:NOT (CL:EQ TERM2 NULL)))
   (CL:WARN "`~A' clashes with `~A'" TERM1 TERM2))
  (SIGNAL *THE-CLASH-EXCEPTION*)
  :VOID)

;;; (DEFUN SIGNAL-VARIABLE-VALUE-CLASH ...)

(CL:DEFUN SIGNAL-VARIABLE-VALUE-CLASH (SKOLEM VALUE1 VALUE2)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ VALUE1 NULL)) (CL:NOT (CL:EQ VALUE2 NULL)))
   (CL:WARN
    "Skolem `~A' is equated with multiple values:~%   `~A' and `~A'."
    SKOLEM
    VALUE1
    VALUE2))
  (SIGNAL *THE-CLASH-EXCEPTION*)
  :VOID)

;;; (DEFUN SIGNAL-TRUTH-VALUE-CLASH ...)

(CL:DEFUN SIGNAL-TRUTH-VALUE-CLASH (PROPOSITION)
  (CL:WARN "Derived both TRUE and FALSE for the proposition `~A'" PROPOSITION)
  (SIGNAL *THE-CLASH-EXCEPTION*)
  :VOID)

;;; (DEFUN SIGNAL-FAIL ...)

(CL:DEFUN SIGNAL-FAIL ()
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "FAIL" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  (SIGNAL *THE-FAIL-EXCEPTION*)
  :VOID)

;;; (DEFUN (LOGICAL-TYPE TYPE) ...)

(CL:DEFUN LOGICAL-TYPE (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-DESCRIPTION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:IF
       (CL:EQ (MONADIC? SELF) 1)
       (CL:RETURN-FROM
        LOGICAL-TYPE
        (CL:IF
         (CL:EQ (IOTA? SELF) 1)
         (CLSYS-SVAL PATTERN-VARIABLE ROOT-TYPE (REPRESENTATIVE SELF))
         SGT-PROPOSITIONS-COLLECTION))
       (CL:RETURN-FROM
        LOGICAL-TYPE
        (CL:IF
         (CL:NOT (CL:EQ (CLSYS-SVAL DESCRIPTION ROOT-TYPE SELF) NULL))
         (CLSYS-SVAL DESCRIPTION ROOT-TYPE SELF)
         SGT-PROPOSITIONS-RELATION)))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-PATTERN-VARIABLE) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((P NULL)
        (ITER-001
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (CLSYS-SVAL PATTERN-VARIABLE DEPENDENT-PROPOSITIONS SELF))))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ
          P
          (CAST
           (CLSYS-SVAL CONS VALUE ITER-001)
           SGT-PROPOSITIONS-PROPOSITION))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:WHEN
         (CL:AND
          (CL:EQ (CLSYS-SVAL PROPOSITION KIND P) KWD-PROPOSITIONS-IN)
          (CL:EQ (VARIABLE-TYPE? P) 1))
         (CL:RETURN-FROM
          LOGICAL-TYPE
          (CAST
           (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS P))
           SGT-PROPOSITIONS-TYPE)))))
      (CL:RETURN-FROM
       LOGICAL-TYPE
       (CLSYS-SVAL PATTERN-VARIABLE ROOT-TYPE SELF))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM LOGICAL-TYPE (CLSYS-SVAL LOGIC-OBJECT ROOT-TYPE SELF))))
    ((CL:EQ (WRAPPER? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM LOGICAL-TYPE (WRAPPER-VALUE-TYPE SELF))))
    ((CL:EQ (SURROGATE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:IF
       (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) NULL))
       (CL:RETURN-FROM
        LOGICAL-TYPE
        (LOGICAL-TYPE (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)))
       (CL:RETURN-FROM LOGICAL-TYPE SGT-PROPOSITIONS-UNKNOWN))))
    (CL:T (CL:RETURN-FROM LOGICAL-TYPE (PRIMARY-TYPE SELF)))))
  :VOID)

;;; (DEFUN UNIFY-TYPES ...)

(CL:DEFUN UNIFY-TYPES (TERM1 TERM2)
  (CL:LET*
   ((TYPE1 (LOGICAL-TYPE TERM1)) (TYPE2 (LOGICAL-TYPE TERM2)))
   (CL:COND
    ((CL:OR
      (CL:EQ TYPE1 TYPE2)
      (CL:OR
       (CL:EQ (SUBTYPE-OF? TYPE1 TYPE2) 1)
       (CL:EQ (SUBTYPE-OF? TYPE2 TYPE1) 1))))
    ((CL:EQ TYPE1 SGT-PROPOSITIONS-UNKNOWN)
     (CL:WHEN (CL:EQ (ISA? TERM1 SGT-PROPOSITIONS-SKOLEM) 1))
     (CL:SETF
      (CLSYS-SVAL SKOLEM ROOT-TYPE (CAST TERM1 SGT-PROPOSITIONS-SKOLEM))
      TYPE2))
    ((CL:EQ TYPE2 SGT-PROPOSITIONS-UNKNOWN)
     (CL:WHEN
      (CL:EQ (ISA? TERM2 SGT-PROPOSITIONS-SKOLEM) 1)
      (CL:SETF
       (CLSYS-SVAL SKOLEM ROOT-TYPE (CAST TERM2 SGT-PROPOSITIONS-SKOLEM))
       TYPE1)))
    (CL:T
     (CL:WHEN
      (CL:AND
       (CL:EQ (BOTTOM? TERM2) 1)
       (CL:EQ
        (CLSYS-SVAL
         BOOLEAN-WRAPPER
         WRAPPER-VALUE
         (ACCESS-IN-CONTEXT
          (CLSYS-SVAL SKOLEM NOT-BOTTOM? TERM1)
          TERM1
          FALSE))
        0))
      (CL:RETURN-FROM UNIFY-TYPES))
     (SIGNAL-UNIFICATION-CLASH TERM1 TERM2))))
  :VOID)

;;; (DEFUN SCAN-FOR-ATTRIBUTES-CLASH ...)

(CL:DEFUN SCAN-FOR-ATTRIBUTES-CLASH (ATTRIBUTES1 ATTRIBUTES2)
  (CL:WHEN
   (CL:OR (CL:EQ (EMPTY? ATTRIBUTES1) 1) (CL:EQ (EMPTY? ATTRIBUTES2) 1))
   (CL:RETURN-FROM SCAN-FOR-ATTRIBUTES-CLASH))
  (CL:LET*
   ((CURSOR1 (CLSYS-SVAL LIST THE-CONS-LIST ATTRIBUTES1))
    (SLOTREF1
     (CAST
      (CLSYS-SVAL PROPOSITION OPERATOR (CLSYS-SVAL CONS VALUE CURSOR1))
      SGT-PROPOSITIONS-SLOTREF))
    (CURSOR2 (CLSYS-SVAL LIST THE-CONS-LIST ATTRIBUTES2))
    (SLOTREF2
     (CAST
      (CLSYS-SVAL PROPOSITION OPERATOR (CLSYS-SVAL CONS VALUE CURSOR2))
      SGT-PROPOSITIONS-SLOTREF)))
   (CL:LOOP
    (CL:IF
     (CL:EQ (SLOTREF-LESS-OR-EQUAL? SLOTREF1 SLOTREF2) 1)
     (CL:PROGN
      (CL:WHEN
       (CL:EQ SLOTREF1 SLOTREF2)
       (CL:LET*
        ((P1 (CLSYS-SVAL CONS VALUE CURSOR1))
         (V1 (FUNCTION-VALUE P1))
         (P2 (CLSYS-SVAL CONS VALUE CURSOR2))
         (V2 (FUNCTION-VALUE P2)))
        (CL:WHEN
         (CL:AND
          (CL:EQ (EQL? V1 V2) 0)
          (CL:EQ (SKOLEM? V1) 0)
          (CL:EQ (SKOLEM? V2) 0))
         (SIGNAL-UNIFICATION-CLASH V1 V2)
         (CL:RETURN-FROM SCAN-FOR-ATTRIBUTES-CLASH))))
      (CL:SETQ CURSOR1 (CLSYS-SVAL CONS REST CURSOR1))
      (CL:WHEN
       (CL:EQ CURSOR1 NULL)
       (CL:RETURN-FROM SCAN-FOR-ATTRIBUTES-CLASH))
      (CL:SETQ
       SLOTREF1
       (CAST
        (CLSYS-SVAL PROPOSITION OPERATOR (CLSYS-SVAL CONS VALUE CURSOR1))
        SGT-PROPOSITIONS-SLOTREF)))
     (CL:PROGN
      (CL:SETQ CURSOR2 (CLSYS-SVAL CONS REST CURSOR2))
      (CL:WHEN
       (CL:EQ CURSOR2 NULL)
       (CL:RETURN-FROM SCAN-FOR-ATTRIBUTES-CLASH))
      (CL:SETQ
       SLOTREF2
       (CAST
        (CLSYS-SVAL PROPOSITION OPERATOR (CLSYS-SVAL CONS VALUE CURSOR2))
        SGT-PROPOSITIONS-SLOTREF))))))
  :VOID)

;;; (DEFUN UNIFY-ATTRIBUTE-PROPOSITIONS ...)

(CL:DEFUN UNIFY-ATTRIBUTE-PROPOSITIONS (ATTRIBUTES1 ATTRIBUTES2)
  (CL:WHEN
   (CL:OR (CL:EQ (EMPTY? ATTRIBUTES1) 1) (CL:EQ (EMPTY? ATTRIBUTES2) 1))
   (CL:RETURN-FROM UNIFY-ATTRIBUTE-PROPOSITIONS))
  (CL:LET*
   ((CURSOR1 (CLSYS-SVAL LIST THE-CONS-LIST ATTRIBUTES1))
    (SLOTREF1
     (CAST
      (CLSYS-SVAL PROPOSITION OPERATOR (CLSYS-SVAL CONS VALUE CURSOR1))
      SGT-PROPOSITIONS-SLOTREF))
    (CURSOR2 (CLSYS-SVAL LIST THE-CONS-LIST ATTRIBUTES2))
    (SLOTREF2
     (CAST
      (CLSYS-SVAL PROPOSITION OPERATOR (CLSYS-SVAL CONS VALUE CURSOR2))
      SGT-PROPOSITIONS-SLOTREF)))
   (CL:LOOP
    (CL:IF
     (CL:EQ (SLOTREF-LESS-OR-EQUAL? SLOTREF1 SLOTREF2) 1)
     (CL:PROGN
      (CL:WHEN
       (CL:EQ SLOTREF1 SLOTREF2)
       (CL:LET*
        ((P1 (CLSYS-SVAL CONS VALUE CURSOR1))
         (P2 (CLSYS-SVAL CONS VALUE CURSOR2)))
        (EQUATE-VALUES (FUNCTION-VALUE P1) (FUNCTION-VALUE P2))))
      (CL:SETQ CURSOR1 (CLSYS-SVAL CONS REST CURSOR1))
      (CL:WHEN
       (CL:EQ CURSOR1 NULL)
       (CL:RETURN-FROM UNIFY-ATTRIBUTE-PROPOSITIONS))
      (CL:SETQ
       SLOTREF1
       (CAST
        (CLSYS-SVAL PROPOSITION OPERATOR (CLSYS-SVAL CONS VALUE CURSOR1))
        SGT-PROPOSITIONS-SLOTREF)))
     (CL:PROGN
      (CL:SETQ CURSOR2 (CLSYS-SVAL CONS REST CURSOR2))
      (CL:WHEN
       (CL:EQ CURSOR2 NULL)
       (CL:RETURN-FROM UNIFY-ATTRIBUTE-PROPOSITIONS))
      (CL:SETQ
       SLOTREF2
       (CAST
        (CLSYS-SVAL PROPOSITION OPERATOR (CLSYS-SVAL CONS VALUE CURSOR2))
        SGT-PROPOSITIONS-SLOTREF))))))
  :VOID)

;;; (DEFUN UNIFY-SKOLEM-AND-VALUE ...)

(CL:DEFUN UNIFY-SKOLEM-AND-VALUE (SKOLEM VALUE)
  (CL:LET*
   ((VALUE-001 VALUE))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? VALUE SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
     (CL:LET*
      ((VALUE NULL))
      (CL:SETQ VALUE VALUE-001)
      (UNIFY-ATTRIBUTE-PROPOSITIONS
       (CLSYS-SVAL SKOLEM DEPENDENT-ATTRIBUTE-PROPOSITIONS SKOLEM)
       (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-ATTRIBUTE-PROPOSITIONS VALUE))))
    (CL:T NULL)))
  (CL:LET*
   ((PROP NULL)
    (ITER-001
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL SKOLEM DEPENDENT-PROPOSITIONS SKOLEM))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      PROP
      (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-PROPOSITIONS-PROPOSITION))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (EVALUATE-PROPOSITION PROP)))
  :VOID)

;;; (DEFUN BIND-SKOLEM-TO-VALUE ...)

(CL:DEFUN BIND-SKOLEM-TO-VALUE (FROMSKOLEM TOVALUE TOPLEVELUPDATE?)
  (CL:WHEN
   (CL:EQ (UNBOUND? FROMSKOLEM) 0)
   (CL:ERROR
    "Safety violation: INTERNAL ERROR: Bound skolem passed to `bind-skolem-to-value'."))
  (CL:LET*
   ((OBJECT-001 FROMSKOLEM)
    (VALUE-001 TOVALUE)
    (OLD-VALUE-001 (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OBJECT-001))
    (NEW-VALUE-001
     (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001 OBJECT-001 FALSE)))
   (CL:WHEN
    (CL:EQ (CS-VALUE? OLD-VALUE-001) 0)
    (CL:SETF
     (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OBJECT-001)
     NEW-VALUE-001)))
  (CL:LET*
   ((TOVALUE-001 TOVALUE))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? TOVALUE SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
     (CL:LET*
      ((TOVALUE NULL))
      (CL:SETQ TOVALUE TOVALUE-001)
      (CL:WHEN
       (CL:EQ (LOGIC-OBJECT-PERMITS-BACKLINKS? TOVALUE) 1)
       (CL:WHEN
        (CL:EQ (SKOLEM? TOVALUE) 1)
        (CL:LET*
         ((EQUIVALENTSKOLEM
           (ACCESS-IN-CONTEXT
            (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE TOVALUE)
            TOVALUE
            FALSE)))
         (CL:LOOP
          (CL:WHEN (CL:EQ EQUIVALENTSKOLEM NULL) (CL:RETURN))
          (CL:LET*
           ((EQUIVALENTSKOLEM-001 EQUIVALENTSKOLEM))
           (CL:COND
            ((CL:EQ
              (TAXONOMY-ISA? EQUIVALENTSKOLEM SGT-PROPOSITIONS-SKOLEM)
              1)
             (CL:LET*
              ((EQUIVALENTSKOLEM NULL))
              (CL:SETQ EQUIVALENTSKOLEM EQUIVALENTSKOLEM-001)
              (CL:WHEN
               (CL:EQ EQUIVALENTSKOLEM TOVALUE)
               (CL:LET*
                ((OBJECT-002 FROMSKOLEM)
                 (VALUE-002 NULL)
                 (OLD-VALUE-003
                  (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OBJECT-002))
                 (NEW-VALUE-002
                  (UPDATE-IN-CONTEXT
                   OLD-VALUE-003
                   VALUE-002
                   OBJECT-002
                   FALSE)))
                (CL:WHEN
                 (CL:EQ (CS-VALUE? OLD-VALUE-003) 0)
                 (CL:SETF
                  (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OBJECT-002)
                  NEW-VALUE-002)))
               (CL:RETURN-FROM BIND-SKOLEM-TO-VALUE))
              (CL:SETQ
               EQUIVALENTSKOLEM
               (CAST
                (ACCESS-IN-CONTEXT
                 (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE EQUIVALENTSKOLEM)
                 EQUIVALENTSKOLEM
                 FALSE)
                SGT-PROPOSITIONS-SKOLEM))))
            (CL:T (CL:RETURN)))))))
       (CL:LET*
        ((OBJECT-003 TOVALUE)
         (VALUE-003 (CONS FROMSKOLEM (VARIABLE-VALUE-INVERSE TOVALUE)))
         (OLD-VALUE-005
          (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE-INVERSE OBJECT-003))
         (NEW-VALUE-003
          (UPDATE-IN-CONTEXT OLD-VALUE-005 VALUE-003 OBJECT-003 FALSE)))
        (CL:WHEN
         (CL:EQ (CS-VALUE? OLD-VALUE-005) 0)
         (CL:SETF
          (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE-INVERSE OBJECT-003)
          NEW-VALUE-003)))
       (CL:WHEN
        (CL:EQ (CLSYS-SVAL LOGIC-OBJECT ROOT-TYPE TOVALUE) NULL)
        (ASSERT-ISA-PROPOSITION
         TOVALUE
         (CLSYS-SVAL SKOLEM ROOT-TYPE FROMSKOLEM))))))
    (CL:T NULL)))
  (REACT-TO-KB-UPDATE *CONTEXT* FROMSKOLEM)
  (CL:WHEN
   (CL:EQ (SKOLEM? TOVALUE) 0)
   (CL:WHEN
    (CL:NOT (CL:EQ (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION FROMSKOLEM) NULL))
    (ASSIGN-TRUTH-VALUE
     (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION FROMSKOLEM)
     TRUE)
    (REACT-TO-ATTRIBUTE-PROPOSITION-UPDATE
     FROMSKOLEM
     NULL
     TOVALUE
     TOPLEVELUPDATE?)))
  :VOID)

;;; (DEFUN UNBIND-SKOLEM-VALUE ...)

(CL:DEFUN UNBIND-SKOLEM-VALUE (SKOLEM TOPLEVELUPDATE?)
  (CL:LET*
   ((OLDVALUE (VALUE-OF SKOLEM)))
   (CL:LET*
    ((OBJECT-001 SKOLEM)
     (VALUE-001 NULL)
     (OLD-VALUE-001 (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OBJECT-001))
     (NEW-VALUE-001
      (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001 OBJECT-001 FALSE)))
    (CL:WHEN
     (CL:EQ (CS-VALUE? OLD-VALUE-001) 0)
     (CL:SETF
      (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OBJECT-001)
      NEW-VALUE-001)))
   (CL:LET*
    ((OLDVALUE-001 OLDVALUE))
    (CL:COND
     ((CL:EQ (TAXONOMY-ISA? OLDVALUE SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
      (CL:LET*
       ((OLDVALUE NULL))
       (CL:SETQ OLDVALUE OLDVALUE-001)
       (CL:IF
        (CL:EQ (FIRST (VARIABLE-VALUE-INVERSE OLDVALUE)) SKOLEM)
        (CL:LET*
         ((OBJECT-002 OLDVALUE)
          (VALUE-002 (CLSYS-SVAL CONS REST (VARIABLE-VALUE-INVERSE OLDVALUE)))
          (OLD-VALUE-002
           (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE-INVERSE OBJECT-002))
          (NEW-VALUE-002
           (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-002 OBJECT-002 FALSE)))
         (CL:WHEN
          (CL:EQ (CS-VALUE? OLD-VALUE-002) 0)
          (CL:SETF
           (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE-INVERSE OBJECT-002)
           NEW-VALUE-002)))
        (CL:LET*
         ((OBJECT-003 OLDVALUE)
          (VALUE-003
           (REMOVE (COPY-CONS-LIST (VARIABLE-VALUE-INVERSE OLDVALUE)) SKOLEM))
          (OLD-VALUE-003
           (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE-INVERSE OBJECT-003))
          (NEW-VALUE-003
           (UPDATE-IN-CONTEXT OLD-VALUE-003 VALUE-003 OBJECT-003 FALSE)))
         (CL:WHEN
          (CL:EQ (CS-VALUE? OLD-VALUE-003) 0)
          (CL:SETF
           (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE-INVERSE OBJECT-003)
           NEW-VALUE-003))))))
     (CL:T NULL)))
   (CHECK-FOR-OUT-OF-DATE-INFERENCE-CACHE)
   (CL:WHEN
    (CL:NOT (CL:EQ (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION SKOLEM) NULL))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (CLSYS-SVAL
        PROPOSITION
        KIND
        (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION SKOLEM))
       KWD-PROPOSITIONS-FUNCTION))
     (CL:ERROR
      "Safety violation: INTERNAL ERROR: Skolem has illegal defining proposition."))
    (REACT-TO-ATTRIBUTE-PROPOSITION-UPDATE
     SKOLEM
     OLDVALUE
     NULL
     TOPLEVELUPDATE?)))
  :VOID)

;;; (DEFUN CONSTRAIN-AS-SUBSET ...)

(CL:DEFUN CONSTRAIN-AS-SUBSET (SET1 SET2)
  (CL:WHEN
   (CL:> (LENGTH SET1) (LENGTH SET2))
   (SIGNAL-UNIFICATION-CLASH SET1 SET2))
  (CL:LET*
   ((COPY1 NIL) (COPY2 NIL))
   (CL:LET*
    ((I2 NULL) (ITER-001 (ALLOCATE-ITERATOR SET2)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ I2 (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:SETQ COPY2 (CONS I2 COPY2))))
   (CL:LET*
    ((I1 NULL) (ITER-002 (ALLOCATE-ITERATOR SET1)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-002) 1)
     DO
     (CL:PROGN (CL:SETQ I1 (CLSYS-SVAL ITERATOR VALUE ITER-002)))
     (CL:IF
      (CL:EQ (MEMBER? COPY2 I1) 1)
      (CL:SETQ COPY2 (REMOVE COPY2 I1))
      (CL:SETQ COPY1 (CONS I1 COPY1)))))
   (CL:WHEN (CL:EQ COPY1 NIL) (CL:RETURN-FROM CONSTRAIN-AS-SUBSET))
   (CL:WHEN
    (CL:= (LENGTH COPY2) 1)
    (CL:LET*
     ((ITEM1 (FIRST COPY1)) (ITEM2 (FIRST COPY2)))
     (FREE-CONS-LIST COPY1)
     (FREE-CONS-LIST COPY2)
     (EQUATE-VALUES ITEM1 ITEM2)
     (CL:RETURN-FROM CONSTRAIN-AS-SUBSET)))
   (CL:LET*
    ((SKOLEMCOUNT1 0) (SKOLEMCOUNT2 0))
    (CL:LET*
     ((I1 NULL) (ITER-003 COPY1))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-003 NIL))
      DO
      (CL:PROGN
       (CL:SETQ I1 (CLSYS-SVAL CONS VALUE ITER-003))
       (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
      (CL:WHEN
       (CL:EQ (SKOLEM? I1) 1)
       (CL:SETQ SKOLEMCOUNT1 (CL:1+ SKOLEMCOUNT1)))))
    (CL:LET*
     ((I2 NULL) (ITER-004 COPY2))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-004 NIL))
      DO
      (CL:PROGN
       (CL:SETQ I2 (CLSYS-SVAL CONS VALUE ITER-004))
       (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
      (CL:WHEN
       (CL:EQ (SKOLEM? I2) 1)
       (CL:SETQ SKOLEMCOUNT2 (CL:1+ SKOLEMCOUNT2)))))
    (FREE-CONS-LIST COPY1)
    (FREE-CONS-LIST COPY2)
    (CL:WHEN
     (CL:EQ (CL:+ SKOLEMCOUNT1 SKOLEMCOUNT2) 0)
     (SIGNAL-UNIFICATION-CLASH SET1 SET2))))
  :VOID)

;;; (DEFUN EQUATE-COLLECTIONS ...)

(CL:DEFUN EQUATE-COLLECTIONS (COL1 COL2)
  (CL:WHEN
   (CL:AND (CL:EQ (ORDERED? COL1) 1) (CL:EQ (ORDERED? COL2) 1))
   (CL:LET*
    ((I2 NULL)
     (I1 NULL)
     (ITER-001 (ALLOCATE-ITERATOR COL1))
     (ITER-002 (ALLOCATE-ITERATOR COL2)))
    (CL:LOOP
     WHILE
     (CL:AND (CL:EQ (NEXT? ITER-001) 1) (CL:EQ (NEXT? ITER-002) 1))
     DO
     (CL:PROGN (CL:SETQ I1 (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:PROGN (CL:SETQ I2 (CLSYS-SVAL ITERATOR VALUE ITER-002)))
     (EQUATE-VALUES I1 I2)))
   (CL:RETURN-FROM EQUATE-COLLECTIONS))
  (CL:WHEN
   (CL:AND (CL:EQ (NO-DUPLICATES? COL1) 1) (CL:EQ (NO-DUPLICATES? COL2) 1))
   (CONSTRAIN-AS-SUBSET
    (CAST COL1 SGT-PROPOSITIONS-SEQUENCE)
    (CAST COL2 SGT-PROPOSITIONS-SEQUENCE))
   (CONSTRAIN-AS-SUBSET
    (CAST COL2 SGT-PROPOSITIONS-SEQUENCE)
    (CAST COL1 SGT-PROPOSITIONS-SEQUENCE)))
  :VOID)

;;; (DEFUN EQUATE-VALUES ...)

(CL:DEFUN EQUATE-VALUES (TERM1 TERM2)
  (CL:COND
   ((CL:EQ (SKOLEM? TERM1) 1)
    (BIND-SKOLEM-TO-VALUE (CAST TERM1 SGT-PROPOSITIONS-SKOLEM) TERM2 FALSE))
   ((CL:EQ (SKOLEM? TERM2) 1)
    (BIND-SKOLEM-TO-VALUE (CAST TERM2 SGT-PROPOSITIONS-SKOLEM) TERM1 FALSE))
   ((CL:AND (CL:EQ (COLLECTION? TERM1) 1) (CL:EQ (COLLECTION? TERM2) 1))
    (EQUATE-COLLECTIONS
     (CAST TERM1 SGT-PROPOSITIONS-COLLECTION)
     (CAST TERM2 SGT-PROPOSITIONS-COLLECTION)))
   (CL:T
    (CL:WHEN
     (CL:EQ (EQL? TERM1 TERM2) 0)
     (SIGNAL-UNIFICATION-CLASH TERM1 TERM2))))
  :VOID)

;;; (DEFUN (UNEQUATE-VALUES? BOOLEAN) ...)

(CL:DEFUN UNEQUATE-VALUES? (TERM1 TERM2)
  (CL:LET*
   ((TERM1-001 TERM1))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? TERM1 SGT-PROPOSITIONS-SKOLEM) 1)
     (CL:LET*
      ((TERM1 NULL))
      (CL:SETQ TERM1 TERM1-001)
      (CL:WHEN
       (CL:EQ
        (EQL?
         (ACCESS-IN-CONTEXT
          (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE TERM1)
          TERM1
          FALSE)
         TERM2)
        1)
       (UNBIND-SKOLEM-VALUE TERM1 FALSE)
       (CL:RETURN-FROM UNEQUATE-VALUES? TRUE))))
    (CL:T NULL)))
  (CL:RETURN-FROM UNEQUATE-VALUES? FALSE)
  :VOID)

;;; (DEFUN (DESCRIPTION-EQUALS-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN DESCRIPTION-EQUALS-DESCRIPTION? (ARG1 ARG2)
  (CL:RETURN-FROM
   DESCRIPTION-EQUALS-DESCRIPTION?
   (CL:IF
    (CL:AND
     (CL:EQ (SPECIALIZES? ARG1 ARG2) 1)
     (CL:EQ (SPECIALIZES? ARG2 ARG1) 1))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (ARGUMENT-EQUALS-ARGUMENT? BOOLEAN) ...)

(CL:DEFUN ARGUMENT-EQUALS-ARGUMENT? (ARG1 ARG2)
  (CL:WHEN
   (CL:EQ (ISA? ARG1 SGT-PROPOSITIONS-SURROGATE) 1)
   (CL:SETQ
    ARG1
    (CLSYS-SVAL
     SURROGATE
     SURROGATE-VALUE
     (CAST ARG1 SGT-PROPOSITIONS-SURROGATE))))
  (CL:WHEN
   (CL:EQ (ISA? ARG2 SGT-PROPOSITIONS-SURROGATE) 1)
   (CL:SETQ
    ARG2
    (CLSYS-SVAL
     SURROGATE
     SURROGATE-VALUE
     (CAST ARG2 SGT-PROPOSITIONS-SURROGATE))))
  (CL:WHEN
   (CL:EQ (EQL? ARG1 ARG2) 1)
   (CL:RETURN-FROM ARGUMENT-EQUALS-ARGUMENT? TRUE))
  (CL:WHEN
   (CL:AND
    (CL:EQ (ISA? ARG1 SGT-PROPOSITIONS-DESCRIPTION) 1)
    (CL:EQ (ISA? ARG2 SGT-PROPOSITIONS-DESCRIPTION) 1))
   (CL:RETURN-FROM
    ARGUMENT-EQUALS-ARGUMENT?
    (DESCRIPTION-EQUALS-DESCRIPTION? ARG1 ARG2)))
  (CL:RETURN-FROM ARGUMENT-EQUALS-ARGUMENT? FALSE)
  :VOID)

;;; (DEFUN (PROPOSITION-EQL? BOOLEAN) ...)

(CL:DEFUN PROPOSITION-EQL? (SELF OTHER)
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND SELF)))
   (CL:COND
    ((CL:OR
      (CL:EQ TEST-VALUE-001 KWD-PROPOSITIONS-AND)
      (CL:EQ TEST-VALUE-001 KWD-PROPOSITIONS-OR))
     (CL:RETURN-FROM
      PROPOSITION-EQL?
      (COMMUTATIVE-PROPOSITION-EQL? SELF OTHER)))
    (CL:T
     (CL:IF
      (CL:EQ SELF OTHER)
      (CL:RETURN-FROM PROPOSITION-EQL? TRUE)
      (CL:LET*
       ((TEST-VALUE-002 FALSE))
       (CL:SETQ
        TEST-VALUE-002
        (EQL?
         (CLSYS-SVAL PROPOSITION OPERATOR SELF)
         (CLSYS-SVAL PROPOSITION OPERATOR OTHER)))
       (CL:WHEN
        (CL:EQ TEST-VALUE-002 1)
        (CL:LET*
         ((ALWAYS?-001 TRUE))
         (CL:LET*
          ((ARG2 NULL)
           (ARG1 NULL)
           (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
           (INDEX-001 0)
           (LENGTH-001 (LENGTH VECTOR-001))
           (VECTOR-002 (CLSYS-SVAL PROPOSITION ARGUMENTS OTHER))
           (INDEX-002 0)
           (LENGTH-002 (LENGTH VECTOR-002)))
          (CL:LOOP
           WHILE
           (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:< INDEX-002 LENGTH-002))
           DO
           (CL:PROGN
            (CL:SETQ
             ARG1
             (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
            (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
           (CL:PROGN
            (CL:SETQ
             ARG2
             (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
            (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
           (CL:WHEN
            (CL:EQ (ARGUMENT-EQUALS-ARGUMENT? ARG1 ARG2) 0)
            (CL:SETQ ALWAYS?-001 FALSE)
            (CL:RETURN))))
         (CL:SETQ TEST-VALUE-002 ALWAYS?-001)))
       (CL:LET*
        ((VALUE-001 TEST-VALUE-002))
        (CL:RETURN-FROM PROPOSITION-EQL? VALUE-001)))))))
  :VOID)

;;; (DEFUN (COMMUTATIVE-PROPOSITION-EQL? BOOLEAN) ...)

(CL:DEFUN COMMUTATIVE-PROPOSITION-EQL? (SELF OTHER)
  (CL:IF
   (CL:EQ SELF OTHER)
   (CL:RETURN-FROM COMMUTATIVE-PROPOSITION-EQL? TRUE)
   (CL:LET*
    ((TEST-VALUE-001 FALSE))
    (CL:SETQ
     TEST-VALUE-001
     (EQL?
      (CLSYS-SVAL PROPOSITION OPERATOR SELF)
      (CLSYS-SVAL PROPOSITION OPERATOR OTHER)))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:SETQ
      TEST-VALUE-001
      (EQ?
       (LENGTH (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
       (LENGTH (CLSYS-SVAL PROPOSITION ARGUMENTS OTHER))))
     (CL:WHEN
      (CL:EQ TEST-VALUE-001 1)
      (CL:LET*
       ((ALWAYS?-001 TRUE))
       (CL:LET*
        ((ARG1 NULL)
         (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
         (INDEX-001 0)
         (LENGTH-001 (LENGTH VECTOR-001)))
        (CL:LOOP
         WHILE
         (CL:< INDEX-001 LENGTH-001)
         DO
         (CL:PROGN
          (CL:SETQ
           ARG1
           (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
          (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
         (CL:LET*
          ((TEST-VALUE-002 FALSE))
          (CL:LET*
           ((FOUND?-001 FALSE))
           (CL:LET*
            ((ARG2 NULL)
             (VECTOR-002 (CLSYS-SVAL PROPOSITION ARGUMENTS OTHER))
             (INDEX-002 0)
             (LENGTH-002 (LENGTH VECTOR-002)))
            (CL:LOOP
             WHILE
             (CL:< INDEX-002 LENGTH-002)
             DO
             (CL:PROGN
              (CL:SETQ
               ARG2
               (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
              (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
             (CL:WHEN
              (CL:EQ
               (PROPOSITION-EQL?
                (CAST ARG1 SGT-PROPOSITIONS-PROPOSITION)
                (CAST ARG2 SGT-PROPOSITIONS-PROPOSITION))
               1)
              (CL:SETQ FOUND?-001 TRUE)
              (CL:RETURN))))
           (CL:SETQ TEST-VALUE-002 FOUND?-001))
          (CL:SETQ TEST-VALUE-002 (CL:IF (CL:EQ TEST-VALUE-002 0) TRUE FALSE))
          (CL:WHEN
           (CL:EQ TEST-VALUE-002 1)
           (CL:SETQ ALWAYS?-001 FALSE)
           (CL:RETURN)))))
       (CL:SETQ TEST-VALUE-001 ALWAYS?-001))))
    (CL:LET*
     ((VALUE-001 TEST-VALUE-001))
     (CL:RETURN-FROM COMMUTATIVE-PROPOSITION-EQL? VALUE-001))))
  :VOID)

;;; (DEFUN (FIND-DEPENDENTS-OF-SOME-ARGUMENT (LIST OF PROPOSITION)) ...)

(CL:DEFUN FIND-DEPENDENTS-OF-SOME-ARGUMENT (SELF)
  (CL:LET*
   ((FIRSTARG? TRUE))
   (CL:LET*
    ((TERM NULL)
     (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       TERM
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:LET*
      ((TERM-001 TERM))
      (CL:COND
       ((CL:EQ (TAXONOMY-ISA? TERM SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
        (CL:LET*
         ((TERM NULL))
         (CL:SETQ TERM TERM-001)
         (CL:IF
          (CL:AND (CL:EQ FIRSTARG? 1) (CL:EQ (ATTRIBUTE-PROPOSITION? SELF) 1))
          (CL:RETURN-FROM
           FIND-DEPENDENTS-OF-SOME-ARGUMENT
           (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-ATTRIBUTE-PROPOSITIONS TERM))
          (CL:RETURN-FROM
           FIND-DEPENDENTS-OF-SOME-ARGUMENT
           (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS TERM)))))
       ((CL:EQ (TAXONOMY-ISA? TERM SGT-PROPOSITIONS-PROPOSITION) 1)
        (CL:LET*
         ((TERM NULL))
         (CL:SETQ TERM TERM-001)
         (CL:RETURN-FROM
          FIND-DEPENDENTS-OF-SOME-ARGUMENT
          (CLSYS-SVAL PROPOSITION DEPENDENT-PROPOSITIONS TERM))))
       (CL:T
        (CL:RETURN-FROM FIND-DEPENDENTS-OF-SOME-ARGUMENT NIL-LIST)
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:WRITE-STRING "Error in logical expression." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:WRITE-STRING "   In proposition: " %%STREAM)
          (PRINT-OBJECT SELF %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:WRITE-STRING
           "At least one argument to the proposition must be of type LOGIC-OBJECT
or PROPOSITION."
           %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:WRITE-STRING
           "   Error occured while parsing the proposition: "
           %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:WRITE-STRING "   " %%STREAM)
          (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))
         (SIGNAL *THE-PROPOSITION-ERROR*))
        (CL:RETURN-FROM FIND-DEPENDENTS-OF-SOME-ARGUMENT NULL))))
     (CL:SETQ FIRSTARG? FALSE)))
   (CL:RETURN-FROM FIND-DEPENDENTS-OF-SOME-ARGUMENT NIL-LIST))
  :VOID)

;;; (DEFUN (FIND-DUPLICATE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FIND-DUPLICATE-PROPOSITION (SELF)
  (CL:LET*
   ((VALUE-001 NULL))
   (CL:LET*
    ((P NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (FIND-DEPENDENTS-OF-SOME-ARGUMENT SELF))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       P
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-PROPOSITIONS-PROPOSITION))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:EQ (PROPOSITION-EQL? SELF P) 1)
      (CL:SETQ VALUE-001 P)
      (CL:RETURN))))
   (CL:LET*
    ((VALUE-002 VALUE-001))
    (CL:RETURN-FROM FIND-DUPLICATE-PROPOSITION VALUE-002)))
  :VOID)

;;; (DEFCONSTANT TRUE-PROPOSITION ...)

(CL:DEFVAR TRUE-PROPOSITION NULL)

;;; (DEFCONSTANT FALSE-PROPOSITION ...)

(CL:DEFVAR FALSE-PROPOSITION NULL)

;;; (DEFUN EVALUATE-AND-PROPOSITION ...)

(CL:DEFUN EVALUATE-AND-PROPOSITION (SELF)
  (CL:LET*
   ((ARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)))
   (CL:COND
    ((CL:EQ (TRUE? SELF) 1)
     (CL:LET*
      ((ARG NULL)
       (VECTOR-001 ARGUMENTS)
       (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:LOOP
       WHILE
       (CL:< INDEX-001 LENGTH-001)
       DO
       (CL:PROGN
        (CL:SETQ
         ARG
         (CAST
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
          SGT-PROPOSITIONS-PROPOSITION))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (ASSIGN-TRUTH-VALUE ARG TRUE))))
    ((CL:EQ (FALSE? SELF) 1)
     (CL:LET*
      ((ONLYUNBOUNDARG NULL))
      (CL:LET*
       ((ARG NULL)
        (VECTOR-002 ARGUMENTS)
        (INDEX-002 0)
        (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:LOOP
        WHILE
        (CL:< INDEX-002 LENGTH-002)
        DO
        (CL:PROGN
         (CL:SETQ
          ARG
          (CAST
           (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002)
           SGT-PROPOSITIONS-PROPOSITION))
         (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
        (CL:COND
         ((CL:EQ (FALSE? ARG) 1) (CL:RETURN-FROM EVALUATE-AND-PROPOSITION))
         ((CL:EQ (UNKNOWN? ARG) 1)
          (CL:WHEN
           (CL:NOT (CL:EQ ONLYUNBOUNDARG NULL))
           (CL:RETURN-FROM EVALUATE-AND-PROPOSITION))
          (CL:SETQ ONLYUNBOUNDARG ARG)))))
      (CL:IF
       (CL:NOT (CL:EQ ONLYUNBOUNDARG NULL))
       (ASSIGN-TRUTH-VALUE ONLYUNBOUNDARG FALSE)
       (ASSIGN-TRUTH-VALUE SELF TRUE))))
    (CL:T
     (CL:LET*
      ((UNBOUNDARG? FALSE))
      (CL:LET*
       ((ARG NULL)
        (VECTOR-003 ARGUMENTS)
        (INDEX-003 0)
        (LENGTH-003 (LENGTH VECTOR-003)))
       (CL:LOOP
        WHILE
        (CL:< INDEX-003 LENGTH-003)
        DO
        (CL:PROGN
         (CL:SETQ
          ARG
          (CAST
           (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-003) INDEX-003)
           SGT-PROPOSITIONS-PROPOSITION))
         (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))
        (CL:COND
         ((CL:EQ (FALSE? ARG) 1)
          (ASSIGN-TRUTH-VALUE SELF FALSE)
          (CL:RETURN-FROM EVALUATE-AND-PROPOSITION))
         ((CL:EQ (UNKNOWN? ARG) 1) (CL:SETQ UNBOUNDARG? TRUE)))))
      (CL:WHEN (CL:EQ UNBOUNDARG? 0) (ASSIGN-TRUTH-VALUE SELF TRUE))))))
  :VOID)

;;; (DEFUN EVALUATE-OR-PROPOSITION ...)

(CL:DEFUN EVALUATE-OR-PROPOSITION (SELF)
  (CL:LET*
   ((ARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)))
   (CL:COND
    ((CL:EQ (FALSE? SELF) 1)
     (CL:LET*
      ((ARG NULL)
       (VECTOR-001 ARGUMENTS)
       (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:LOOP
       WHILE
       (CL:< INDEX-001 LENGTH-001)
       DO
       (CL:PROGN
        (CL:SETQ
         ARG
         (CAST
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
          SGT-PROPOSITIONS-PROPOSITION))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (ASSIGN-TRUTH-VALUE ARG FALSE))))
    ((CL:EQ (TRUE? SELF) 1)
     (CL:LET*
      ((ONLYUNBOUNDARG NULL))
      (CL:LET*
       ((ARG NULL)
        (VECTOR-002 ARGUMENTS)
        (INDEX-002 0)
        (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:LOOP
        WHILE
        (CL:< INDEX-002 LENGTH-002)
        DO
        (CL:PROGN
         (CL:SETQ
          ARG
          (CAST
           (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002)
           SGT-PROPOSITIONS-PROPOSITION))
         (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
        (CL:COND
         ((CL:EQ (TRUE? ARG) 1) (CL:RETURN-FROM EVALUATE-OR-PROPOSITION))
         ((CL:EQ (UNKNOWN? ARG) 1)
          (CL:WHEN
           (CL:NOT (CL:EQ ONLYUNBOUNDARG NULL))
           (CL:RETURN-FROM EVALUATE-OR-PROPOSITION))
          (CL:SETQ ONLYUNBOUNDARG ARG)))))
      (CL:IF
       (CL:NOT (CL:EQ ONLYUNBOUNDARG NULL))
       (ASSIGN-TRUTH-VALUE ONLYUNBOUNDARG TRUE)
       (ASSIGN-TRUTH-VALUE SELF FALSE))))
    (CL:T
     (CL:LET*
      ((UNBOUNDARG? FALSE))
      (CL:LET*
       ((ARG NULL)
        (VECTOR-003 ARGUMENTS)
        (INDEX-003 0)
        (LENGTH-003 (LENGTH VECTOR-003)))
       (CL:LOOP
        WHILE
        (CL:< INDEX-003 LENGTH-003)
        DO
        (CL:PROGN
         (CL:SETQ
          ARG
          (CAST
           (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-003) INDEX-003)
           SGT-PROPOSITIONS-PROPOSITION))
         (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))
        (CL:COND
         ((CL:EQ (TRUE? ARG) 1)
          (ASSIGN-TRUTH-VALUE SELF TRUE)
          (CL:RETURN-FROM EVALUATE-OR-PROPOSITION))
         ((CL:EQ (UNKNOWN? ARG) 1) (CL:SETQ UNBOUNDARG? TRUE)))))
      (CL:WHEN (CL:EQ UNBOUNDARG? 0) (ASSIGN-TRUTH-VALUE SELF FALSE))))))
  :VOID)

;;; (DEFUN EVALUATE-NOT-PROPOSITION ...)

(CL:DEFUN EVALUATE-NOT-PROPOSITION (SELF)
  (CL:LET*
   ((ARGUMENT
     (CAST
      (CL:AREF
       (CLSYS-SVAL VECTOR THE-ARRAY (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
       0)
      SGT-PROPOSITIONS-PROPOSITION)))
   (CL:COND
    ((CL:EQ (TRUE? ARGUMENT) 1) (ASSIGN-TRUTH-VALUE SELF FALSE))
    ((CL:EQ (FALSE? ARGUMENT) 1) (ASSIGN-TRUTH-VALUE SELF TRUE))
    ((CL:EQ (TRUE? SELF) 1) (ASSIGN-TRUTH-VALUE ARGUMENT FALSE))
    ((CL:EQ (FALSE? SELF) 1) (ASSIGN-TRUTH-VALUE ARGUMENT TRUE))))
  :VOID)

;;; (DEFUN EVALUATE-EQUIVALENT-PROPOSITION ...)

(CL:DEFUN EVALUATE-EQUIVALENT-PROPOSITION (SELF)
  (CL:LET*
   ((ARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
    (FIRSTARG
     (INNERMOST-OF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0)))
    (SECONDARG
     (INNERMOST-OF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 1))))
   (CL:COND
    ((CL:EQ (TRUE? SELF) 1) (EQUATE-VALUES FIRSTARG SECONDARG))
    ((CL:EQ (EQL? FIRSTARG SECONDARG) 1) (ASSIGN-TRUTH-VALUE SELF TRUE))
    ((CL:AND (CL:EQ (SKOLEM? FIRSTARG) 0) (CL:EQ (SKOLEM? SECONDARG) 0))
     (ASSIGN-TRUTH-VALUE SELF FALSE))))
  :VOID)

;;; (DEFUN EVALUATE-FUNCTION-PROPOSITION ...)

(CL:DEFUN EVALUATE-FUNCTION-PROPOSITION (SELF)
  (CL:LET*
   ((COMPUTEDVALUE (COMPUTE-FUNCTION-VALUE SELF))
    (STOREDVALUE (VALUE-OF (LAST-ARGUMENT SELF))))
   (CL:WHEN
    (CL:AND
     (CL:EQ (EQL? COMPUTEDVALUE STOREDVALUE) 0)
     (CL:EQ (BOTTOM? COMPUTEDVALUE) 0))
    (EQUATE-VALUES COMPUTEDVALUE STOREDVALUE)))
  :VOID)

;;; (DEFMETHOD EVALUATE-SLOT-PERMUTATIONS ...)

(CL:DEFMETHOD EVALUATE-SLOT-PERMUTATIONS ((SELF SLOT) ARGUMENTS)
  (CL:SETQ ARGUMENTS ARGUMENTS)
  NULL
  :VOID)

;;; (DEFMETHOD EVALUATE-SLOT-PERMUTATIONS ...)

(CL:DEFMETHOD EVALUATE-SLOT-PERMUTATIONS ((SELF METHOD-SLOT) ORIGINALARGUMENTS)
  (CL:WHEN
   (CL:EQ
    (DYNAMIC-SLOT-VALUE SELF SYM-PROPOSITIONS-PERMUTATION-TABLE NULL)
    NULL)
   (CL:RETURN-FROM EVALUATE-SLOT-PERMUTATIONS))
  (CL:LET*
   ((LASTINDEX (CL:1- (LENGTH ORIGINALARGUMENTS))) (NONNATIVEARGCOUNT 0))
   (CL:LET*
    ((I NULL)
     (ITER-001 0)
     (UPPER-BOUND-001 LASTINDEX)
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
    (CL:LOOP
     WHILE
     (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:WHEN
      (CL:EQ
       (NATIVE-VALUE-OF
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ORIGINALARGUMENTS) I))
       NULL)
      (CL:SETQ NONNATIVEARGCOUNT (CL:1+ NONNATIVEARGCOUNT)))))
   (CL:WHEN
    (CL:> NONNATIVEARGCOUNT 1)
    (CL:RETURN-FROM EVALUATE-SLOT-PERMUTATIONS))
   (CL:LET*
    ((PERMUTEDARGUMENTS (NEW-VECTOR (CL:1+ LASTINDEX))) (COMPUTEDVALUE NULL))
    (CL:LET*
     ((PERMUTATIONSLOT NULL)
      (PERMUTATION NULL)
      (ITER-002
       (CLSYS-SVAL
        KEY-VALUE-LIST
        THE-KV-LIST
        (DYNAMIC-SLOT-VALUE SELF SYM-PROPOSITIONS-PERMUTATION-TABLE NULL))))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-002 NULL))
      DO
      (CL:SETQ
       PERMUTATION
       (CAST (CLSYS-SVAL KV-CONS KEY ITER-002) SGT-PROPOSITIONS-VECTOR))
      (CL:PROGN
       (CL:SETQ
        PERMUTATIONSLOT
        (CAST (CLSYS-SVAL KV-CONS VALUE ITER-002) SGT-PROPOSITIONS-SLOT))
       (CL:SETQ ITER-002 (CLSYS-SVAL KV-CONS REST ITER-002)))
      (CL:LET*
       ((I NULL)
        (ITER-003 0)
        (UPPER-BOUND-002 LASTINDEX)
        (UNBOUNDED?-002 (NULL? UPPER-BOUND-002)))
       (CL:LOOP
        WHILE
        (CL:OR (CL:EQ UNBOUNDED?-002 1) (CL:<= ITER-003 UPPER-BOUND-002))
        DO
        (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
        (CL:SETF
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY PERMUTEDARGUMENTS) I)
         (CL:AREF
          (CLSYS-SVAL VECTOR THE-ARRAY ORIGINALARGUMENTS)
          (CL:1-
           (CLSYS-SVAL
            INTEGER-WRAPPER
            WRAPPER-VALUE
            (CAST
             (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY PERMUTATION) I)
             SGT-PROPOSITIONS-INTEGER-WRAPPER)))))))
      (CL:SETQ
       COMPUTEDVALUE
       (APPLY-SLOT-TO-NATIVE-ARGUMENTS PERMUTATIONSLOT PERMUTEDARGUMENTS))
      (CL:WHEN
       (CL:EQ (BOTTOM? COMPUTEDVALUE) 0)
       (CL:LET*
        ((STOREDVALUE
          (VALUE-OF
           (CL:AREF
            (CLSYS-SVAL VECTOR THE-ARRAY PERMUTEDARGUMENTS)
            LASTINDEX))))
        (CL:WHEN
         (CL:EQ (EQL? COMPUTEDVALUE STOREDVALUE) 0)
         (EQUATE-VALUES COMPUTEDVALUE STOREDVALUE)))
       (CL:RETURN))))))
  :VOID)

;;; (DEFUN EVALUATE-PREDICATE-PROPOSITION ...)

(CL:DEFUN EVALUATE-PREDICATE-PROPOSITION (SELF)
  (CL:LET*
   ((RESULT FALSE) (KNOWN? FALSE))
   (CL:MULTIPLE-VALUE-SETQ (RESULT KNOWN?) (COMPUTE-PREDICATE-VALUE SELF))
   (CL:WHEN (CL:EQ KNOWN? 1) (ASSIGN-TRUTH-VALUE SELF RESULT)))
  :VOID)

;;; (DEFUN EVALUATE-PROPOSITION ...)

(CL:DEFUN EVALUATE-PROPOSITION (SELF)
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-PROPOSITIONS-AND)
     (EVALUATE-AND-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-001 KWD-PROPOSITIONS-OR)
     (EVALUATE-OR-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-001 KWD-PROPOSITIONS-NOT)
     (EVALUATE-NOT-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-001 KWD-PROPOSITIONS-EQUIVALENT)
     (EVALUATE-EQUIVALENT-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-001 KWD-PROPOSITIONS-FUNCTION)
     (EVALUATE-FUNCTION-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-001 KWD-PROPOSITIONS-PREDICATE)
     (EVALUATE-PREDICATE-PROPOSITION SELF))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN (EVALUATE-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-TERM (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-LITERAL-WRAPPER) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM EVALUATE-TERM (EVALUATE-WRAPPED-LITERAL-TERM SELF))))
    ((CL:EQ (SURROGATE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:IF
       (CL:EQ SELF SGT-PROPOSITIONS-TRAP-DOOR-SURROGATE)
       (CL:RETURN-FROM
        EVALUATE-TERM
        (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF))
       (CL:RETURN-FROM EVALUATE-TERM (EVALUATE-SURROGATE-TERM SELF)))))
    ((CL:EQ (SYMBOL? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM EVALUATE-TERM (EVALUATE-SYMBOL-TERM SELF))))
    ((CL:EQ (CONS? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((TEST-VALUE-001 (FIRST SELF)))
       (CL:COND
        ((CL:OR
          (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-SETOFALL)
          (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-THE-ONLY)
          (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-KAPPA))
         (CL:RETURN-FROM EVALUATE-TERM (EVALUATE-DESCRIPTION-TERM SELF TRUE)))
        ((CL:OR
          (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-SETOF)
          (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-LISTOF))
         (CL:RETURN-FROM EVALUATE-TERM (EVALUATE-SETOF-TERM SELF)))
        ((CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-CREATE)
         (CL:RETURN-FROM EVALUATE-TERM (EVALUATE-CREATE-TERM SELF)))
        (CL:T
         (CL:RETURN-FROM EVALUATE-TERM (EVALUATE-FUNCTION-TERM SELF)))))))
    (CL:T (CL:ERROR "Missing 'evaluate-term' method on `~A'" SELF))))
  :VOID)

;;; (DEFUN (EVALUATE-WRAPPED-LITERAL-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-WRAPPED-LITERAL-TERM (SELF)
  (CL:RETURN-FROM EVALUATE-WRAPPED-LITERAL-TERM (PERMANENTIFY SELF))
  :VOID)

;;; (DEFUN (EVALUATE-SURROGATE-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-SURROGATE-TERM (SELF)
  (CL:COND
   ((CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION)
    (CL:LET*
     ((VALUE (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)))
     (CL:WHEN
      (CL:EQ VALUE BOTTOM)
      (CL:SETQ VALUE NULL)
      (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) NULL))
     (CL:WHEN
      (CL:NOT (CL:EQ VALUE NULL))
      (CL:LET*
       ((VALUE-001 VALUE))
       (CL:COND
        ((CL:EQ (TAXONOMY-ISA? VALUE SGT-PROPOSITIONS-RELATION) 1)
         (CL:LET*
          ((VALUE NULL))
          (CL:SETQ VALUE VALUE-001)
          (CL:RETURN-FROM EVALUATE-SURROGATE-TERM (GET-DESCRIPTION SELF))))
        (CL:T (CL:RETURN-FROM EVALUATE-SURROGATE-TERM VALUE)))))
     (CREATE-LOGIC-OBJECT NULL SELF NULL)
     (CL:RETURN-FROM
      EVALUATE-SURROGATE-TERM
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF))))
   ((CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-QUERY)
    (CL:LET*
     ((SURROGATEVALUE (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)))
     (CL:COND
      ((CL:EQ SURROGATEVALUE NULL)
       (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) BOTTOM)
       (CL:RETURN-FROM EVALUATE-SURROGATE-TERM SELF))
      ((CL:EQ (ISA? SURROGATEVALUE SGT-PROPOSITIONS-LITERAL-WRAPPER) 1)
       (CL:RETURN-FROM EVALUATE-SURROGATE-TERM SURROGATEVALUE))
      (CL:T (CL:RETURN-FROM EVALUATE-SURROGATE-TERM SELF)))))
   ((CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-DESCRIPTION)
    (CL:LET*
     ((SURROGATEVALUE (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)))
     (CL:IF
      (CL:AND
       (CL:NOT (CL:EQ SURROGATEVALUE NULL))
       (CL:EQ (ISA? SURROGATEVALUE SGT-PROPOSITIONS-LITERAL-WRAPPER) 1))
      (CL:RETURN-FROM EVALUATE-SURROGATE-TERM SURROGATEVALUE)
      (CL:RETURN-FROM EVALUATE-SURROGATE-TERM SELF))))
   ((CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-INTENSIONAL-ASSERTION)
    (CL:LET*
     ((DIRECTVALUE (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF))
      (INTENSIONALSKOLEM NULL))
     (CL:WHEN
      (CL:EQ (SKOLEM? DIRECTVALUE) 1)
      (CL:RETURN-FROM EVALUATE-SURROGATE-TERM DIRECTVALUE))
     (CL:SETQ
      INTENSIONALSKOLEM
      (CREATE-SKOLEM
       (CL:IF
        (CL:NOT (CL:EQ DIRECTVALUE NULL))
        (LOGICAL-TYPE (VALUE-OF DIRECTVALUE))
        NULL)
       NULL))
     (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) INTENSIONALSKOLEM)
     (BIND-SKOLEM-TO-VALUE INTENSIONALSKOLEM DIRECTVALUE FALSE)
     (CL:RETURN-FROM EVALUATE-SURROGATE-TERM INTENSIONALSKOLEM)))
   (CL:T (CL:ERROR "`~A' is not a valid case option" *EVALUATIONMODE*)))
  :VOID)

;;; (DEFCONSTANT ANONYMOUS-VARIABLE-NAME ...)

(CL:DEFVAR ANONYMOUS-VARIABLE-NAME NULL
  "Variables with name 'ANONYMOUS-VARIABLE-NAME' are considered
anonymous, and are not assumed to be identical to any other variable also named
'ANONYMOUS-VARIABLE-NAME'.")

;;; (DEFUN (ANONYMOUS-VARIABLE? BOOLEAN) ...)

(CL:DEFUN ANONYMOUS-VARIABLE? (SELF)
  (CL:RETURN-FROM
   ANONYMOUS-VARIABLE?
   (CL:IF
    (CL:AND
     (CL:EQ
      (DYNAMIC-SLOT-VALUE SELF SYM-PROPOSITIONS-SKOLEM-NAME NULL)
      ANONYMOUS-VARIABLE-NAME)
     (CL:EQ (VARIABLE? SELF) 1))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (EVALUATE-SYMBOL-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-SYMBOL-TERM (SELF)
  (CL:LET*
   ((VALUE (LOOKUP-LOGIC-VARIABLE-BINDING SELF)))
   (CL:COND
    ((CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM EVALUATE-SYMBOL-TERM VALUE))
    ((CL:EQ SELF ANONYMOUS-VARIABLE-NAME)
     (CL:RETURN-FROM
      EVALUATE-SYMBOL-TERM
      (CREATE-VARIABLE NULL ANONYMOUS-VARIABLE-NAME FALSE)))
    (CL:T
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "Error in logical expression." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "   Reference to undeclared variable: " %%STREAM)
       (PRINT-OBJECT SELF %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING
        "   Error occured while parsing the proposition: "
        %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "   " %%STREAM)
       (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (SIGNAL *THE-PROPOSITION-ERROR*)))))
  :VOID)

;;; (DEFUN SIGNAL-UNDEFINED-TERM ...)

(CL:DEFUN SIGNAL-UNDEFINED-TERM (TERM)
  (CL:LET*
   ((*PRINTREADABLY?* TRUE))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "Error in logical expression." %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "   Undefined term: " %%STREAM)
    (PRINT-OBJECT TERM %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING
     "   Error occured while parsing the proposition: "
     %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "   " %%STREAM)
    (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (SIGNAL *THE-PROPOSITION-ERROR*))
  :VOID)

;;; (DEFUN (EVALUATE-SETOF-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-SETOF-TERM (TERM)
  (CL:LET*
   ((TEST-VALUE-001 (FIRST TERM)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-SETOF)
     (CL:LET*
      ((COLLECTION (NEW-SET)))
      (CL:LET*
       ((I NULL) (ITER-001 (CLSYS-SVAL CONS REST TERM)))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ I (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (INSERT COLLECTION (EVALUATE-TERM I))))
      (REVERSE COLLECTION)
      (CL:RETURN-FROM EVALUATE-SETOF-TERM COLLECTION)))
    ((CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-LISTOF)
     (CL:LET*
      ((COLLECTION (NEW-LIST)))
      (CL:LET*
       ((I NULL) (ITER-002 (CLSYS-SVAL CONS REST TERM)))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-002 NIL))
        DO
        (CL:PROGN
         (CL:SETQ I (CLSYS-SVAL CONS VALUE ITER-002))
         (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
        (INSERT COLLECTION (EVALUATE-TERM I))))
      (REVERSE COLLECTION)
      (CL:RETURN-FROM EVALUATE-SETOF-TERM COLLECTION)))
    (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
  :VOID)

;;; (DEFUN (EVALUATE-CREATE-TERM LOGIC-OBJECT) ...)

(CL:DEFUN EVALUATE-CREATE-TERM (TERM)
  (CL:LET*
   ((TYPE (SURROGATIFY (SECOND TERM)))
    (NAME (CL:IF (CL:> (LENGTH TERM) 2) (SURROGATIFY (THIRD TERM)) NULL)))
   (CL:RETURN-FROM EVALUATE-CREATE-TERM (CREATE-LOGIC-OBJECT TYPE NAME NULL)))
  :VOID)

;;; (DEFUN (CREATE LOGIC-OBJECT) ...)

(CL:DEFUN %%CREATE (TYPE NAME)
  "Create a logic object of logical type `type' and return it.
If `name' is also supplied, convert it into a surrogate and bind it to the 
newly created object."
  (CL:LET*
   ((CREATETREE (LIST* SYM-PROPOSITIONS-CREATE TYPE (CONCATENATE NAME NIL)))
    (RESULT (EVALUATE-CREATE-TERM CREATETREE)))
   (FREE-CONS-TREE CREATETREE)
   (CL:RETURN-FROM %%CREATE RESULT))
  :VOID)

(CL:DEFUN CREATE-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM
   CREATE-EVALUATOR-WRAPPER
   (%%CREATE
    (CLSYS-SVAL CONS VALUE ARGUMENTS)
    (CLSYS-SVAL CONS REST ARGUMENTS)))
  :VOID)

(CL:DEFMACRO CREATE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Create a logic object of logical type `type' and return it.
If `name' is also supplied, convert it into a surrogate and bind it to the 
newly created object."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/CREATE)) (CL:MACRO-FUNCTION (CL:QUOTE CREATE)))

;;; (DEFUN (LEFTMOST-CONCRETE-SUPERCLASS CLASS) ...)

(CL:DEFUN LEFTMOST-CONCRETE-SUPERCLASS (SELF)
  (CL:LET*
   ((ROOTCLASS SELF) (LEFTSUPERTYPE NULL) (LEFTSUPERCLASS NULL))
   (CL:LOOP
    (CL:SETQ
     LEFTSUPERTYPE
     (FIRST (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS ROOTCLASS)))
    (CL:WHEN
     (CL:EQ LEFTSUPERTYPE NULL)
     (CL:RETURN-FROM LEFTMOST-CONCRETE-SUPERCLASS ROOTCLASS))
    (CL:SETQ
     LEFTSUPERCLASS
     (CAST
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE LEFTSUPERTYPE)
      SGT-PROPOSITIONS-CLASS))
    (CL:WHEN
     (CL:AND
      (CL:EQ (CLSYS-SVAL CLASS ABSTRACT? LEFTSUPERCLASS) 1)
      (CL:EQ (PRIMITIVE? LEFTSUPERCLASS) 1))
     (CL:RETURN-FROM LEFTMOST-CONCRETE-SUPERCLASS ROOTCLASS))
    (CL:SETQ ROOTCLASS LEFTSUPERCLASS)))
  :VOID)

;;; (DEFUN (HAS-MULTIPLE-ROOT-CLASSES? BOOLEAN) ...)

(CL:DEFUN HAS-MULTIPLE-ROOT-CLASSES? (SELF)
  (CL:LET*
   ((ROOTCLASS SELF) (LEFTSUPERTYPE NULL) (SECONDSUPERTYPE NULL))
   (CL:LOOP
    (CL:SETQ
     LEFTSUPERTYPE
     (FIRST (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS ROOTCLASS)))
    (CL:WHEN
     (CL:OR
      (CL:EQ LEFTSUPERTYPE NULL)
      (CL:EQ
       (CLSYS-SVAL
        CLASS
        ABSTRACT?
        (CAST
         (CLSYS-SVAL SURROGATE SURROGATE-VALUE LEFTSUPERTYPE)
         SGT-PROPOSITIONS-CLASS))
       1))
     (CL:RETURN-FROM HAS-MULTIPLE-ROOT-CLASSES? FALSE))
    (CL:SETQ
     SECONDSUPERTYPE
     (FIRST (REST (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS ROOTCLASS))))
    (CL:WHEN
     (CL:AND
      (CL:NOT (CL:EQ SECONDSUPERTYPE NULL))
      (CL:EQ
       (CLSYS-SVAL
        CLASS
        ABSTRACT?
        (CAST
         (CLSYS-SVAL SURROGATE SURROGATE-VALUE SECONDSUPERTYPE)
         SGT-PROPOSITIONS-CLASS))
       0))
     (CL:RETURN-FROM HAS-MULTIPLE-ROOT-CLASSES? TRUE))
    (CL:SETQ
     ROOTCLASS
     (CAST
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE LEFTSUPERTYPE)
      SGT-PROPOSITIONS-CLASS))))
  :VOID)

;;; (DEFUN HELP-COLLECT-ROOT-CLASSES ...)

(CL:DEFUN HELP-COLLECT-ROOT-CLASSES (SELF ALLCLASSESLIST BEENTHERE)
  (CL:LET*
   ((DIRECTSUPERS (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS SELF)))
   (INSERT BEENTHERE SELF)
   (CL:WHEN
    (CL:EQ (EMPTY? DIRECTSUPERS) 1)
    (CL:RETURN-FROM HELP-COLLECT-ROOT-CLASSES))
   (CL:WHEN
    (CL:EQ
     (CLSYS-SVAL
      CLASS
      ABSTRACT?
      (CAST
       (CLSYS-SVAL SURROGATE SURROGATE-VALUE (FIRST DIRECTSUPERS))
       SGT-PROPOSITIONS-CLASS))
     1)
    (INSERT ALLCLASSESLIST SELF)
    (CL:RETURN-FROM HELP-COLLECT-ROOT-CLASSES))
   (CL:LET*
    ((SUPERTYPE NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST DIRECTSUPERS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       SUPERTYPE
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-PROPOSITIONS-TYPE))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:LET*
      ((SUPERCLASS
        (CAST
         (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPERTYPE)
         SGT-PROPOSITIONS-CLASS)))
      (CL:WHEN
       (CL:EQ (CLSYS-SVAL CLASS ABSTRACT? SUPERCLASS) 1)
       (CL:RETURN-FROM HELP-COLLECT-ROOT-CLASSES))
      (CL:WHEN
       (CL:EQ (MEMBER? BEENTHERE SUPERCLASS) 0)
       (HELP-COLLECT-ROOT-CLASSES SUPERCLASS ALLCLASSESLIST BEENTHERE))))))
  :VOID)

;;; (DEFUN (ALL-ROOT-CLASSES (ITERATOR OF CLASS)) ...)

(CL:DEFUN ALL-ROOT-CLASSES (SELF)
  (CL:LET*
   ((CLASSLIST NIL))
   (CL:WHEN
    (CL:EQ (NON-EMPTY? (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS SELF)) 1)
    (CL:IF
     (CL:EQ (HAS-MULTIPLE-ROOT-CLASSES? SELF) 1)
     (CL:LET*
      ((ALLCLASSESLIST (NEW-LIST)) (BEENTHERE (NEW-LIST)))
      (HELP-COLLECT-ROOT-CLASSES SELF ALLCLASSESLIST BEENTHERE)
      (FREE BEENTHERE)
      (CL:SETQ CLASSLIST (CLSYS-SVAL LIST THE-CONS-LIST ALLCLASSESLIST)))
     (CL:LET*
      ((SUPER (LEFTMOST-CONCRETE-SUPERCLASS SELF)))
      (CL:WHEN
       (CL:NOT (CL:EQ SUPER NULL))
       (CL:SETQ CLASSLIST (CONS SUPER NIL))))))
   (CL:LET*
    ((C NULL) (ITER-001 CLASSLIST))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       C
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-PROPOSITIONS-CLASS))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (SET-DYNAMIC-SLOT-VALUE
      C
      SYM-PROPOSITIONS-NON-DISJOINTNESS-KLUDGE?
      (WRAP-BOOLEAN TRUE)
      NULL)))
   (CL:RETURN-FROM
    ALL-ROOT-CLASSES
    (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR CLASSLIST)))
  :VOID)

;;; (DEFUN (GET-DESCRIPTION-EXTENSION (LIST OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-DESCRIPTION-EXTENSION (ROOTCLASS)
  (CL:LET*
   ((DESCRIPTION
     (DYNAMIC-SLOT-VALUE ROOTCLASS SYM-PROPOSITIONS-DESCRIPTION NULL))
    (EXTENSION NULL))
   (CL:WHEN
    (CL:EQ DESCRIPTION NULL)
    (CL:SETQ DESCRIPTION (GET-DESCRIPTION ROOTCLASS)))
   (CL:SETQ EXTENSION (EXTENSION DESCRIPTION))
   (CL:WHEN
    (CL:AND (CL:EQ (EMPTY? EXTENSION) 1) (CL:EQ EXTENSION NIL-LIST))
    (CL:SETQ EXTENSION (NEW-LIST))
    (SET-DYNAMIC-SLOT-VALUE
     DESCRIPTION
     SYM-PROPOSITIONS-EXTENSION
     EXTENSION
     NULL))
   (CL:RETURN-FROM GET-DESCRIPTION-EXTENSION EXTENSION))
  :VOID)

;;; (DEFUN (INDEXED-BY-LOGICAL-EXTENSIONS? BOOLEAN) ...)

(CL:DEFUN INDEXED-BY-LOGICAL-EXTENSIONS? (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-PATTERN-VARIABLE) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM INDEXED-BY-LOGICAL-EXTENSIONS? (SUBSUMPTION-MODE?))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-SKOLEM) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       INDEXED-BY-LOGICAL-EXTENSIONS?
       (NULL? (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION SELF)))))
    (CL:T (CL:RETURN-FROM INDEXED-BY-LOGICAL-EXTENSIONS? TRUE))))
  :VOID)

;;; (DEFMETHOD UPDATE-LOGICAL-CLASS-EXTENSION ...)

(CL:DEFMETHOD UPDATE-LOGICAL-CLASS-EXTENSION ((SELF LOGIC-OBJECT) TYPE)
  (CL:WHEN
   (CL:EQ (INDEXED-BY-LOGICAL-EXTENSIONS? SELF) 1)
   (INSERT
    (GET-DESCRIPTION-EXTENSION
     (CAST
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE)
      SGT-PROPOSITIONS-CLASS))
    SELF))
  :VOID)

;;; (DEFMETHOD UPDATE-LOGICAL-CLASS-EXTENSION ...)

(CL:DEFMETHOD UPDATE-LOGICAL-CLASS-EXTENSION ((SELF PATTERN-VARIABLE) TYPE)
  (CL:SETQ TYPE TYPE)
  NULL
  :VOID)

;;; (DEFUN HELP-UPDATE-ROOT-TYPES ...)

(CL:DEFUN HELP-UPDATE-ROOT-TYPES (SELF NEWROOTTYPE)
  (CL:WHEN
   (CL:EQ NEWROOTTYPE (CLSYS-SVAL LOGIC-OBJECT ROOT-TYPE SELF))
   (CL:RETURN-FROM HELP-UPDATE-ROOT-TYPES))
  (CL:LET*
   ((ROOTTYPE (CLSYS-SVAL LOGIC-OBJECT ROOT-TYPE SELF))
    (ALLROOTTYPES (ALL-ROOT-TYPES SELF)))
   (CL:COND
    ((CL:OR
      (CL:EQ
       (CLSYS-SVAL LOGIC-OBJECT ROOT-TYPE SELF)
       SGT-PROPOSITIONS-UNKNOWN)
      (CL:EQ (CLSYS-SVAL LOGIC-OBJECT ROOT-TYPE SELF) NULL))
     (CL:SETF (CLSYS-SVAL LOGIC-OBJECT ROOT-TYPE SELF) NEWROOTTYPE)
     (UPDATE-LOGICAL-CLASS-EXTENSION SELF NEWROOTTYPE))
    ((CL:EQ (EMPTY? ALLROOTTYPES) 1)
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-PROPOSITIONS-ALL-ROOT-TYPES
      (LIST ROOTTYPE NEWROOTTYPE)
      NULL)
     (UPDATE-LOGICAL-CLASS-EXTENSION SELF NEWROOTTYPE))
    ((CL:EQ (MEMBER? (ALL-ROOT-TYPES SELF) NEWROOTTYPE) 1) NULL)
    (CL:T
     (CL:LET*
      ((NEWALLROOTTYPES (COPY (ALL-ROOT-TYPES SELF))))
      (INSERT NEWALLROOTTYPES NEWROOTTYPE)
      (UPDATE-LOGICAL-CLASS-EXTENSION SELF NEWROOTTYPE)))))
  :VOID)

;;; (DEFUN UPDATE-ROOT-TYPES ...)

(CL:DEFUN UPDATE-ROOT-TYPES (SELF TYPE)
  (CL:LET*
   ((CLASS
     (CAST
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE)
      SGT-PROPOSITIONS-CLASS)))
   (CL:IF
    (CL:EQ (HAS-MULTIPLE-ROOT-CLASSES? CLASS) 1)
    (CL:LET*
     ((RC NULL) (ITER-001 (ALL-ROOT-CLASSES CLASS)))
     (CL:LOOP
      WHILE
      (CL:EQ (NEXT? ITER-001) 1)
      DO
      (CL:PROGN
       (CL:SETQ
        RC
        (CAST (CLSYS-SVAL ITERATOR VALUE ITER-001) SGT-PROPOSITIONS-CLASS)))
      (HELP-UPDATE-ROOT-TYPES SELF (CLSYS-SVAL CLASS CLASS-TYPE RC))))
    (HELP-UPDATE-ROOT-TYPES
     SELF
     (CLSYS-SVAL CLASS CLASS-TYPE (LEFTMOST-CONCRETE-SUPERCLASS CLASS)))))
  :VOID)

;;; (DEFUN TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK ...)

(CL:DEFUN TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK (RELATIONSLIST)
  (CL:LET*
   ((OLDRELATION (FIRST RELATIONSLIST))
    (NEWRELATION (SECOND RELATIONSLIST))
    (OLDDESCRIPTION
     (DYNAMIC-SLOT-VALUE OLDRELATION SYM-PROPOSITIONS-DESCRIPTION NULL))
    (NEWDESCRIPTION
     (DYNAMIC-SLOT-VALUE NEWRELATION SYM-PROPOSITIONS-DESCRIPTION NULL)))
   (CL:WHEN
    (CL:NOT (CL:EQ OLDDESCRIPTION NULL))
    (RETRACT-RELATION-AXIOMS OLDRELATION)
    (CL:IF
     (CL:NOT (CL:EQ NEWDESCRIPTION NULL))
     (CL:PROGN
      (CL:WHEN
       (CL:EQ OLDDESCRIPTION NEWDESCRIPTION)
       (CL:ERROR
        "Safety violation: INTERNAL ERROR: Redefined relation uses old description."))
      (TRANSFER-PROPOSITIONS-TO-LOGIC-OBJECT
       (DYNAMIC-SLOT-VALUE OLDRELATION SYM-PROPOSITIONS-DESCRIPTION NULL)
       (DYNAMIC-SLOT-VALUE NEWRELATION SYM-PROPOSITIONS-DESCRIPTION NULL))
      (DESTROY-INSTANCE OLDDESCRIPTION))
     (CL:PROGN
      (SET-DYNAMIC-SLOT-VALUE
       NEWRELATION
       SYM-PROPOSITIONS-DESCRIPTION
       OLDDESCRIPTION
       NULL)
      (CL:SETF
       (CLSYS-SVAL DESCRIPTION NATIVE-RELATION OLDDESCRIPTION)
       NEWRELATION)
      (FINALIZE-SUPERRELATION-LINKS NEWRELATION)))
    (SET-DYNAMIC-SLOT-VALUE
     OLDRELATION
     SYM-PROPOSITIONS-DESCRIPTION
     NULL
     NULL))
   (CL:LET*
    ((OLDRELATION-001 OLDRELATION))
    (CL:COND
     ((CL:EQ (CLASS? OLDRELATION) 1)
      (CL:LET*
       ((OLDRELATION NULL))
       (CL:SETQ OLDRELATION OLDRELATION-001)
       (SET-DYNAMIC-SLOT-VALUE
        (CAST NEWRELATION SGT-PROPOSITIONS-CLASS)
        SYM-PROPOSITIONS-CLASS-EXTENSION
        (DYNAMIC-SLOT-VALUE OLDRELATION SYM-PROPOSITIONS-CLASS-EXTENSION NULL)
        NULL)
       (SET-DYNAMIC-SLOT-VALUE
        OLDRELATION
        SYM-PROPOSITIONS-CLASS-EXTENSION
        NULL
        NULL)))
     (CL:T NULL))))
  :VOID)

;;; (DEFUN RETRACT-RELATION-AXIOMS ...)

(CL:DEFUN RETRACT-RELATION-AXIOMS (OLDRELATION)
  (CL:LET*
   ((ORIGINATEDPROPOSITIONS (RELATION-ORIGINATED-PROPOSITIONS OLDRELATION)))
   (CL:WHEN
    (CL:NOT (CL:EQ ORIGINATEDPROPOSITIONS NULL))
    (CL:LET*
     ((PROPOSITION NULL)
      (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST ORIGINATEDPROPOSITIONS)))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ
        PROPOSITION
        (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-PROPOSITIONS-PROPOSITION))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (UNASSERT-FACT PROPOSITION)))))
  :VOID)

;;; (DEFUN (ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION PROPOSITION) ...)

(CL:DEFUN ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION (SUB SUPER)
  (CL:LET*
   ((IMPLIESPROP (CREATE-PROPOSITION SYM-PROPOSITIONS-IMPLIES 2)))
   (CL:SETF
    (CL:AREF
     (CLSYS-SVAL
      VECTOR
      THE-ARRAY
      (CLSYS-SVAL PROPOSITION ARGUMENTS IMPLIESPROP))
     0)
    SUB)
   (CL:SETF
    (CL:AREF
     (CLSYS-SVAL
      VECTOR
      THE-ARRAY
      (CLSYS-SVAL PROPOSITION ARGUMENTS IMPLIESPROP))
     1)
    SUPER)
   (CL:SETQ IMPLIESPROP (FASTEN-DOWN-PROPOSITION IMPLIESPROP))
   (ASSIGN-TRUTH-VALUE IMPLIESPROP TRUE)
   (CL:RETURN-FROM ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION IMPLIESPROP))
  :VOID)

;;; (DEFUN (ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS PROPOSITION) ...)

(CL:DEFUN ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS (SUB SUPER)
  (CL:LET*
   ((IMPLIESPROP
     (ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION
      (GET-DESCRIPTION SUB)
      (GET-DESCRIPTION SUPER))))
   (SET-DYNAMIC-SLOT-VALUE
    IMPLIESPROP
    SYM-PROPOSITIONS-SUBRELATION-LINK?
    (WRAP-BOOLEAN TRUE)
    NULL-BOOLEAN-WRAPPER)
   (CL:WHEN
    (CL:EQ (NULL-LIST? (RELATION-ORIGINATED-PROPOSITIONS SUB)) 1)
    (SET-DYNAMIC-SLOT-VALUE
     SUB
     SYM-PROPOSITIONS-RELATION-ORIGINATED-PROPOSITIONS
     (NEW-LIST)
     NULL))
   (PUSH (RELATION-ORIGINATED-PROPOSITIONS SUB) IMPLIESPROP)
   (CL:RETURN-FROM ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS IMPLIESPROP))
  :VOID)

;;; (DEFUN FINALIZE-SUPERRELATION-LINKS ...)

(CL:DEFUN FINALIZE-SUPERRELATION-LINKS (SELF)
  (CL:LET*
   ((*EVALUATIONMODE* KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION))
   (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
   (CL:LET*
    ((*MODULE*
      (CAST
       (CLSYS-SVAL
        DESCRIPTION
        HOME-CONTEXT
        (DYNAMIC-SLOT-VALUE SELF SYM-PROPOSITIONS-DESCRIPTION NULL))
       SGT-PROPOSITIONS-MODULE))
     (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:LET*
     ((SUPER NULL) (ITER-001 (DIRECT-SUPERRELATIONS SELF)))
     (CL:LOOP
      WHILE
      (CL:EQ (NEXT? ITER-001) 1)
      DO
      (CL:PROGN
       (CL:SETQ
        SUPER
        (CAST
         (CLSYS-SVAL ITERATOR VALUE ITER-001)
         SGT-PROPOSITIONS-RELATION)))
      (GET-DESCRIPTION SUPER)
      (ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS SELF SUPER)))))
  :VOID)

;;; (DEFUN (VERIFY-LOGICAL-AND-NATIVE-TYPES TYPE) ...)

(CL:DEFUN VERIFY-LOGICAL-AND-NATIVE-TYPES (LOGICALTYPE NATIVETYPE)
  (CL:COND
   ((CL:AND
     (CL:NOT (CL:EQ LOGICALTYPE NULL))
     (CL:OR
      (CL:EQ NATIVETYPE NULL)
      (CL:AND
       (CL:EQ (SUBTYPE-OF? LOGICALTYPE NATIVETYPE) 1)
       (CL:NOT (CL:EQ LOGICALTYPE NATIVETYPE)))))
    (CL:LET*
     ((CLASS
       (CAST
        (CLSYS-SVAL SURROGATE SURROGATE-VALUE LOGICALTYPE)
        SGT-PROPOSITIONS-CLASS)))
     (CL:WHEN
      (CL:EQ CLASS NULL)
      (CL:RETURN-FROM VERIFY-LOGICAL-AND-NATIVE-TYPES NULL))
     (CL:WHEN
      (CL:EQ (CLSYS-SVAL CLASS ABSTRACT? CLASS) 1)
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING "Error in logical expression." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING "   Illegal creation type: " %%STREAM)
        (CL:WRITE-STRING
         (CLSYS-SVAL SURROGATE SYMBOL-NAME LOGICALTYPE)
         %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING
         "   The creation type of a logic object cannot be abstract."
         %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING
         "   Error occured while parsing the proposition: "
         %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING "   " %%STREAM)
        (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (SIGNAL *THE-PROPOSITION-ERROR*))
      (CL:RETURN-FROM VERIFY-LOGICAL-AND-NATIVE-TYPES NULL))
     (CL:RETURN-FROM VERIFY-LOGICAL-AND-NATIVE-TYPES LOGICALTYPE)))
   ((CL:OR
     (CL:EQ LOGICALTYPE NULL)
     (CL:EQ LOGICALTYPE NATIVETYPE)
     (CL:AND
      (CL:NOT (CL:EQ NATIVETYPE NULL))
      (CL:EQ (SUBTYPE-OF? NATIVETYPE LOGICALTYPE) 1)))
    (CL:RETURN-FROM VERIFY-LOGICAL-AND-NATIVE-TYPES NATIVETYPE))
   (CL:T
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING "Error in logical expression." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING
       "   Creation type error.  Attempt to bind a logic object of type "
       %%STREAM)
      (CL:WRITE-STRING
       (CLSYS-SVAL SURROGATE SYMBOL-NAME LOGICALTYPE)
       %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING "   to a native object of type " %%STREAM)
      (PRINT-OBJECT NATIVETYPE %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING
       "   Error occured while parsing the proposition: "
       %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING "   " %%STREAM)
      (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (SIGNAL *THE-PROPOSITION-ERROR*))
    (CL:RETURN-FROM VERIFY-LOGICAL-AND-NATIVE-TYPES NATIVETYPE)))
  :VOID)

;;; (DEFUN (UPDATE-ISA-PROPOSITION PROPOSITION) ...)

(CL:DEFUN UPDATE-ISA-PROPOSITION (SELF TYPE UPDATEMODE)
  (CL:WHEN
   (CL:EQ TYPE NULL)
   (CL:WHEN
    (CL:EQ (CLSYS-SVAL LOGIC-OBJECT ROOT-TYPE SELF) NULL)
    (CL:SETF
     (CLSYS-SVAL LOGIC-OBJECT ROOT-TYPE SELF)
     SGT-PROPOSITIONS-UNKNOWN))
   (CL:RETURN-FROM UPDATE-ISA-PROPOSITION NULL))
  (CL:LET*
   ((ISAPROPOSITIONTREE NULL) (PROPOSITION NULL))
   (CL:SETF
    (CLSYS-SVAL
     SURROGATE
     SURROGATE-VALUE
     SGT-PROPOSITIONS-TRAP-DOOR-SURROGATE)
    SELF)
   (CL:LET*
    ((*TRANSIENTOBJECTS?* TRUE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:SETQ
     ISAPROPOSITIONTREE
     (LIST*
      SYM-PROPOSITIONS-ISA
      SGT-PROPOSITIONS-TRAP-DOOR-SURROGATE
      TYPE
      NIL)))
   (CL:SETQ
    PROPOSITION
    (BUILD-TOP-LEVEL-PROPOSITION ISAPROPOSITIONTREE UPDATEMODE))
   (FREE-PARSE-TREE ISAPROPOSITIONTREE)
   (CL:RETURN-FROM UPDATE-ISA-PROPOSITION PROPOSITION))
  :VOID)

;;; (DEFUN (ASSERT-ISA-PROPOSITION PROPOSITION) ...)

(CL:DEFUN ASSERT-ISA-PROPOSITION (SELF TYPE)
  (CL:RETURN-FROM
   ASSERT-ISA-PROPOSITION
   (UPDATE-ISA-PROPOSITION SELF TYPE KWD-PROPOSITIONS-ASSERT-TRUE))
  :VOID)

;;; (DEFUN UPDATE-PROPERTY ...)

(CL:DEFUN UPDATE-PROPERTY (INSTANCE PROPERTY UPDATEMODE)
  (CL:SETF
   (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-PROPOSITIONS-TRAP-DOOR-SURROGATE)
   INSTANCE)
  (CL:LET*
   ((PROPOSITIONTREE NULL))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* TRUE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:SETQ
     PROPOSITIONTREE
     (CONS PROPERTY (CONS SGT-PROPOSITIONS-TRAP-DOOR-SURROGATE NIL))))
   (BUILD-TOP-LEVEL-PROPOSITION PROPOSITIONTREE UPDATEMODE)
   (FREE-PARSE-TREE PROPOSITIONTREE))
  :VOID)

;;; (DEFUN ASSERT-PROPERTY ...)

(CL:DEFUN ASSERT-PROPERTY (INSTANCE PROPERTY)
  (UPDATE-PROPERTY INSTANCE PROPERTY KWD-PROPOSITIONS-ASSERT-TRUE)
  :VOID)

;;; (DEFUN (CREATE-LOGIC-OBJECT LOGIC-OBJECT) ...)

(CL:DEFUN CREATE-LOGIC-OBJECT (TYPE NAME NATIVEVALUE)
  (CL:LET*
   ((OBJECT (NEW-LOGIC-OBJECT)) (NATIVETYPE NULL))
   (CL:WHEN
    (CL:NOT (CL:EQ NATIVEVALUE NULL))
    (CL:LET*
     ((OBJECT-001 OBJECT)
      (VALUE-001 NATIVEVALUE)
      (OLD-VALUE-001 (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OBJECT-001))
      (NEW-VALUE-001
       (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001 OBJECT-001 FALSE)))
     (CL:WHEN
      (CL:EQ (CS-VALUE? OLD-VALUE-001) 0)
      (CL:SETF
       (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OBJECT-001)
       NEW-VALUE-001)))
    (CL:SETQ NATIVETYPE (PRIMARY-TYPE NATIVEVALUE)))
   (CL:SETQ TYPE (VERIFY-LOGICAL-AND-NATIVE-TYPES TYPE NATIVETYPE))
   (ASSERT-ISA-PROPOSITION OBJECT TYPE)
   (CL:WHEN
    (CL:NOT (CL:EQ NAME NULL))
    (CL:WHEN
     (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE NAME) NULL))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING "Redefining the surrogate " %%STREAM)
      (CL:WRITE-STRING (CLSYS-SVAL SURROGATE SYMBOL-NAME NAME) %%STREAM)
      (CL:WRITE-STRING " will cause the existing" %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:WRITE-STRING "   object named " %%STREAM)
      (CL:WRITE-STRING (CLSYS-SVAL SURROGATE SYMBOL-NAME NAME) %%STREAM)
      (CL:WRITE-STRING " to be destroyed. " %%STREAM))
     (CL:WHEN
      (CL:EQ (Y-OR-N? "Do it? ") 0)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "Returning existing object:" %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:RETURN-FROM
       CREATE-LOGIC-OBJECT
       (CAST
        (CLSYS-SVAL SURROGATE SURROGATE-VALUE NAME)
        SGT-PROPOSITIONS-LOGIC-OBJECT)))
     (DESTROY-INSTANCE
      (CAST
       (CLSYS-SVAL SURROGATE SURROGATE-VALUE NAME)
       SGT-PROPOSITIONS-LOGIC-OBJECT)))
    (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE NAME) OBJECT)
    (SET-DYNAMIC-SLOT-VALUE
     OBJECT
     SYM-PROPOSITIONS-SURROGATE-VALUE-INVERSE
     NAME
     NULL))
   (CL:RETURN-FROM CREATE-LOGIC-OBJECT OBJECT))
  :VOID)

;;; (DEFSPECIAL *PROPOSITIONUNDERCONSTRUCTION* ...)

(CL:DEFVAR *PROPOSITIONUNDERCONSTRUCTION* NULL
  "Points to the parse tree which is the input to the
proposition being constructed.")

(CL:DEFUN READ-*PROPOSITIONUNDERCONSTRUCTION* ()
  (CL:RETURN-FROM
   READ-*PROPOSITIONUNDERCONSTRUCTION*
   *PROPOSITIONUNDERCONSTRUCTION*)
  :VOID)

(CL:DEFUN WRITE-*PROPOSITIONUNDERCONSTRUCTION* (VALUE)
  (CL:SETQ *PROPOSITIONUNDERCONSTRUCTION* VALUE)
  (CL:RETURN-FROM WRITE-*PROPOSITIONUNDERCONSTRUCTION* VALUE)
  :VOID)

;;; (DEFSPECIAL *TOPLEVELPROPOSITIONS* ...)

(CL:DEFVAR *TOPLEVELPROPOSITIONS* NULL
  "If non-NULL newly built top-level propositions are
pushed onto this list.")

(CL:DEFUN READ-*TOPLEVELPROPOSITIONS* ()
  (CL:RETURN-FROM READ-*TOPLEVELPROPOSITIONS* *TOPLEVELPROPOSITIONS*)
  :VOID)

(CL:DEFUN WRITE-*TOPLEVELPROPOSITIONS* (VALUE)
  (CL:SETQ *TOPLEVELPROPOSITIONS* VALUE)
  (CL:RETURN-FROM WRITE-*TOPLEVELPROPOSITIONS* VALUE)
  :VOID)

;;; (DEFUN (BUILD-TOP-LEVEL-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-TOP-LEVEL-PROPOSITION (TREE UPDATEMODE)
  (CL:WHEN
   (CL:EQ (ISA? TREE SGT-PROPOSITIONS-STRING-WRAPPER) 1)
   (CL:RETURN-FROM
    BUILD-TOP-LEVEL-PROPOSITION
    (BUILD-TOP-LEVEL-PROPOSITION
     (UNSTRINGIFY
      (CLSYS-SVAL
       STRING-WRAPPER
       WRAPPER-VALUE
       (CAST TREE SGT-PROPOSITIONS-STRING-WRAPPER)))
     UPDATEMODE)))
  (CL:LET*
   ((PROPOSITION NULL) (LOGICVARIABLETABLE *LOGICVARIABLETABLE*))
   (CL:LET*
    ((*LOGICVARIABLETABLE*
      (CL:IF (CL:NOT (CL:EQ LOGICVARIABLETABLE NULL)) LOGICVARIABLETABLE NIL))
     (*PROPOSITIONUNDERCONSTRUCTION* TREE))
    (CL:DECLARE
     (CL:SPECIAL *LOGICVARIABLETABLE* *PROPOSITIONUNDERCONSTRUCTION*))
    (CL:PROGN
     (CL:LET*
      ((*PENDINGEXCEPTIONHANDLER?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PENDINGEXCEPTIONHANDLER?*))
      (CL:CATCH
       *EXCEPTIONHANDLERADDRESS*
       (CL:PROGN
        (CL:SETQ PROPOSITION (BUILD-PROPOSITION TREE UPDATEMODE))
        (CL:SETQ *EXCEPTION* NULL))))
     (CL:WHEN
      (CL:NOT (CL:EQ *EXCEPTION* NULL))
      (CL:COND
       ((CL:EQ
         (SUBTYPE-OF? *EXCEPTION-TYPE* SGT-PROPOSITIONS-LOGIC-EXCEPTION)
         1)
        (CL:LET*
         ((E (CAST *EXCEPTION* SGT-PROPOSITIONS-LOGIC-EXCEPTION)))
         (CL:WHEN
          (CL:AND
           (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
           (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-PROPOSITIONS-EXCEPTIONS) 1))
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:WRITE-STRING "build-top-level-proposition: Caught " %%STREAM)
           (PRINT-OBJECT (PRIMARY-TYPE E) %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)))
         (CL:WHEN
          (CL:EQ *EVALUATIONMODE* KWD-PROPOSITIONS-QUERY)
          (SIGNAL E))))
       ((CL:EQ
         (SUBTYPE-OF? *EXCEPTION-TYPE* SGT-PROPOSITIONS-READ-EXCEPTION)
         1)
        (CL:WHEN
         (CL:AND
          (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
          (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-PROPOSITIONS-EXCEPTIONS) 1))
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:WRITE-STRING
           "build-top-level-proposition: Caught READ-EXCEPTION"
           %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))))
       ((CL:EQ TRUE 1)
        (CL:LET*
         ((E *EXCEPTION*))
         (CL:WARN
          "build-top-level-proposition: Caught `~A'~%"
          (PRIMARY-TYPE E)))))))
    (CL:WHEN
     (CL:EQ LOGICVARIABLETABLE NULL)
     (FREE-CONS-LIST *LOGICVARIABLETABLE*)))
   (CL:WHEN
    (CL:NOT (CL:EQ PROPOSITION NULL))
    (UPDATE-PROPOSITION-TRUTH-VALUE PROPOSITION UPDATEMODE)
    (CL:WHEN
     (CL:NOT (CL:EQ *TOPLEVELPROPOSITIONS* NULL))
     (CL:SETQ
      *TOPLEVELPROPOSITIONS*
      (CONS PROPOSITION *TOPLEVELPROPOSITIONS*))))
   (CL:RETURN-FROM BUILD-TOP-LEVEL-PROPOSITION PROPOSITION))
  :VOID)

;;; (DEFUN (FASTEN-DOWN-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FASTEN-DOWN-PROPOSITION (SELF)
  (CL:LET*
   ((DUPLICATE (FIND-DUPLICATE-PROPOSITION SELF)))
   (CL:IF
    (CL:NOT (CL:EQ DUPLICATE NULL))
    (CL:PROGN
     (CL:WHEN (CL:NOT (CL:EQ SELF DUPLICATE)) (FREE SELF))
     (CL:RETURN-FROM FASTEN-DOWN-PROPOSITION DUPLICATE))
    (CL:PROGN
     (CL:WHEN
      (CL:EQ (DESCRIPTION-MODE?) 0)
      (LOG-NEWLY-CONCEIVED-PROPOSITION *MODULE* SELF))
     (CL:LET*
      ((ARG NULL)
       (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
       (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:LOOP
       WHILE
       (CL:< INDEX-001 LENGTH-001)
       DO
       (CL:PROGN
        (CL:SETQ
         ARG
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (ADD-DEPENDENT-PROPOSITION-LINK ARG SELF)))
     (REACT-TO-KB-UPDATE *CONTEXT* SELF)
     (CL:RETURN-FROM FASTEN-DOWN-PROPOSITION SELF))))
  :VOID)

;;; (DEFUN (BUILD-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-PROPOSITION (TREE UPDATEMODE)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:RETURN-FROM
       BUILD-PROPOSITION
       (CONS.BUILD-PROPOSITION TREE UPDATEMODE))))
    ((CL:EQ (SURROGATE? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:RETURN-FROM
       BUILD-PROPOSITION
       (SURROGATE.BUILD-PROPOSITION TREE UPDATEMODE))))
    ((CL:EQ (SYMBOL? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:RETURN-FROM
       BUILD-PROPOSITION
       (SYMBOL.BUILD-PROPOSITION TREE UPDATEMODE))))
    (CL:T
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "Error in logical expression." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "   Illegal logical sentence: " %%STREAM)
       (PRINT-OBJECT TREE %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING
        "   Error occured while parsing the proposition: "
        %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "   " %%STREAM)
       (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (SIGNAL *THE-PROPOSITION-ERROR*)))))
  :VOID)

;;; (DEFUN (SURROGATE.BUILD-PROPOSITION PROPOSITION) ...)

(CL:DEFUN SURROGATE.BUILD-PROPOSITION (SELF UPDATEMODE)
  (CL:LET*
   ((VALUE (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)) (PROPOSITION NULL))
   (CL:WHEN
    (CL:EQ VALUE BOTTOM)
    (CL:SETQ VALUE NULL)
    (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) NULL))
   (CL:WHEN
    (CL:EQ UPDATEMODE NULL)
    (CL:SETQ UPDATEMODE KWD-PROPOSITIONS-CONCEIVE))
   (CL:IF
    (CL:NOT (CL:EQ VALUE NULL))
    (CL:LET*
     ((VALUE-001 VALUE))
     (CL:COND
      ((CL:EQ (TAXONOMY-ISA? VALUE SGT-PROPOSITIONS-PROPOSITION) 1)
       (CL:LET*
        ((VALUE NULL))
        (CL:SETQ VALUE VALUE-001)
        (CL:SETQ PROPOSITION VALUE)))
      (CL:T
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING "Error in logical expression." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING "   Expected " %%STREAM)
         (CL:WRITE-STRING (CLSYS-SVAL SURROGATE SYMBOL-NAME SELF) %%STREAM)
         (CL:WRITE-STRING " to have type proposition" %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING
          "   Error occured while parsing the proposition: "
          %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING "   " %%STREAM)
         (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))
        (SIGNAL *THE-PROPOSITION-ERROR*)))))
    (CL:COND
     ((CL:OR
       (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
       (CL:EQ UPDATEMODE KWD-PROPOSITIONS-CONCEIVE))
      (CL:SETQ PROPOSITION (CREATE-PROPOSITION SYM-PROPOSITIONS-CONSTANT 0))
      (CL:SETF (CLSYS-SVAL PROPOSITION OPERATOR PROPOSITION) SELF)
      (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) PROPOSITION)
      (SET-DYNAMIC-SLOT-VALUE
       PROPOSITION
       SYM-PROPOSITIONS-SURROGATE-VALUE-INVERSE
       SELF
       NULL))
     (CL:T
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING "Error in logical expression." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING "   Reference to undefined constant " %%STREAM)
        (CL:WRITE-STRING (CLSYS-SVAL SURROGATE SYMBOL-NAME SELF) %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING
         "   Error occured while parsing the proposition: "
         %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING "   " %%STREAM)
        (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (SIGNAL *THE-PROPOSITION-ERROR*)))))
   (CL:RETURN-FROM
    SURROGATE.BUILD-PROPOSITION
    (FASTEN-DOWN-PROPOSITION PROPOSITION)))
  :VOID)

;;; (DEFUN (SYMBOL.BUILD-PROPOSITION PROPOSITION) ...)

(CL:DEFUN SYMBOL.BUILD-PROPOSITION (SYMBOL UPDATEMODE)
  (CL:LET*
   ((PROPOSITION NULL))
   (CL:COND
    ((CL:EQ SYMBOL SYM-PROPOSITIONS-TRUE)
     (CL:IF
      (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
      (SIGNAL-TRUTH-VALUE-CLASH TRUE-PROPOSITION)
      (CL:SETQ PROPOSITION TRUE-PROPOSITION)))
    ((CL:EQ SYMBOL SYM-PROPOSITIONS-FALSE)
     (CL:IF
      (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
      (SIGNAL-TRUTH-VALUE-CLASH FALSE-PROPOSITION)
      (CL:SETQ PROPOSITION FALSE-PROPOSITION)))
    (CL:T "NOT YET IMPLEMENTED"))
   (CL:WHEN
    (CL:NOT (CL:EQ PROPOSITION NULL))
    (CL:WHEN
     (CL:NOT (CL:EQ *TOPLEVELPROPOSITIONS* NULL))
     (CL:SETQ
      *TOPLEVELPROPOSITIONS*
      (CONS PROPOSITION *TOPLEVELPROPOSITIONS*))))
   (CL:RETURN-FROM SYMBOL.BUILD-PROPOSITION PROPOSITION))
  :VOID)

;;; (DEFUN (CONS.BUILD-PROPOSITION PROPOSITION) ...)

(CL:DEFUN CONS.BUILD-PROPOSITION (TREE UPDATEMODE)
  (CL:LET*
   ((PROPOSITION NULL))
   (CL:WHEN
    (CL:EQ (ISA? (FIRST TREE) SGT-PROPOSITIONS-SYMBOL) 0)
    (CL:ERROR
     "Safety violation: INTERNAL ERROR: Illegal operator in proposition tree."))
   (CL:LET*
    ((TEST-VALUE-001 (FIRST TREE)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-=)
      (CL:SETQ PROPOSITION (BUILD-EQUIVALENCE-PROPOSITION TREE UPDATEMODE)))
     ((CL:OR
       (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-AND)
       (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-OR)
       (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-NOT))
      (CL:SETQ PROPOSITION (BUILD-AND-OR-NOT-PROPOSITION TREE UPDATEMODE)))
     ((CL:OR
       (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-IN)
       (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-ISA))
      (CL:SETQ PROPOSITION (BUILD-IN-PROPOSITION TREE UPDATEMODE)))
     ((CL:OR
       (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-IMPLIES)
       (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-SUBSET-OF))
      (CL:SETQ PROPOSITION (BUILD-IMPLIES-PROPOSITION TREE UPDATEMODE)))
     ((CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-EXISTS)
      (CL:SETQ PROPOSITION (BUILD-EXISTS-PROPOSITION TREE UPDATEMODE)))
     ((CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-FORALL)
      (CL:SETQ PROPOSITION (BUILD-FORALL-PROPOSITION TREE UPDATEMODE)))
     (CL:T (CL:SETQ PROPOSITION (BUILD-PREDICATE-PROPOSITION TREE)))))
   (CL:WHEN
    (CL:EQ PROPOSITION NULL)
    (CL:RETURN-FROM CONS.BUILD-PROPOSITION NULL))
   (CL:WHEN
    (CL:AND
     (CL:EQ (DESCRIPTIVE-UPDATE? UPDATEMODE) 1)
     (CL:EQ (CONTAINS-NESTED-ARGUMENT? PROPOSITION) 1))
    (CL:SETQ PROPOSITION (FASTEN-DOWN-PROPOSITION PROPOSITION))
    (CL:SETQ PROPOSITION (FLATTEN-NESTED-FUNCTION-ARGUMENTS PROPOSITION)))
   (CL:RETURN-FROM
    CONS.BUILD-PROPOSITION
    (FASTEN-DOWN-PROPOSITION PROPOSITION)))
  :VOID)

;;; (DEFUN VERIFY-COLLECTION-ARGUMENT ...)

(CL:DEFUN VERIFY-COLLECTION-ARGUMENT (SELF ORIGINAL)
  (CL:WHEN (CL:EQ ORIGINAL NULL) (CL:SETQ ORIGINAL SELF))
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:EQ (SUBTYPE-OF? (LOGICAL-TYPE SELF) SGT-PROPOSITIONS-COLLECTION) 0)
       (CL:IF
        (CL:EQ (BOTTOM? SELF) 1)
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:WRITE-STRING "Error in logical expression." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:WRITE-STRING "   The object " %%STREAM)
          (PRINT-OBJECT ORIGINAL %%STREAM)
          (CL:WRITE-STRING " is undefined." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:WRITE-STRING
           "   Error occured while parsing the proposition: "
           %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:WRITE-STRING "   " %%STREAM)
          (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))
         (SIGNAL *THE-PROPOSITION-ERROR*))
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (CL:WARN "The object `~A' is not a collection." ORIGINAL))))))
    ((CL:EQ (SURROGATE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:EQ
        (ISA?
         (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)
         SGT-PROPOSITIONS-RELATION)
        0)
       (VERIFY-COLLECTION-ARGUMENT (VALUE-OF SELF) SELF))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-COLLECTION) 1)
     (CL:LET* ((SELF NULL)) (CL:SETQ SELF SELF-001) NULL))
    (CL:T
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (CL:WARN "The object`~A' is not a collection." ORIGINAL)))))
  :VOID)

;;; (DEFUN VERIFY-RELATION-ARGUMENT ...)

(CL:DEFUN VERIFY-RELATION-ARGUMENT (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (CLASS? SELF) 1)
     (CL:LET* ((SELF NULL)) (CL:SETQ SELF SELF-001) NULL))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-RELATION) 1)
     (CL:LET* ((SELF NULL)) (CL:SETQ SELF SELF-001) NULL))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-DESCRIPTION) 1)
     (CL:LET* ((SELF NULL)) (CL:SETQ SELF SELF-001) NULL))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:NOT
        (CL:OR
         (CL:EQ (SUBTYPE-OF? (LOGICAL-TYPE SELF) SGT-PROPOSITIONS-RELATION) 1)
         (CL:EQ
          (SUBTYPE-OF? (LOGICAL-TYPE SELF) SGT-PROPOSITIONS-DESCRIPTION)
          1)))
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (CL:WARN "The object `~A' is not a relation." SELF)))))
    (CL:T
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (CL:WARN "The object`~A' is not a relation." SELF)))))
  :VOID)

;;; (DEFUN VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS ...)

(CL:DEFUN VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS (TREE CORRECTNUMBER)
  (CL:WHEN
   (CL:NOT (CL:EQ (LENGTH TREE) (CL:1+ CORRECTNUMBER)))
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "Error in logical expression." %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING
      "   Wrong number of arguments in proposition: "
      %%STREAM)
     (PRINT-OBJECT TREE %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING
      "   Error occured while parsing the proposition: "
      %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "   " %%STREAM)
     (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (SIGNAL *THE-PROPOSITION-ERROR*)))
  :VOID)

;;; (DEFUN (BUILD-IN-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-IN-PROPOSITION (TREE UPDATEMODE)
  (VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS TREE 2)
  (CL:WHEN
   (CL:EQ (FIRST TREE) SYM-PROPOSITIONS-ISA)
   (CL:LET*
    ((SYMBOL (THIRD TREE)))
    (CL:LET*
     ((SYMBOL-001 SYMBOL))
     (CL:COND
      ((CL:EQ (TYPE? SYMBOL) 1)
       (CL:LET*
        ((SYMBOL NULL))
        (CL:SETQ SYMBOL SYMBOL-001)
        (CL:WHEN
         (CL:EQ (GET-CLASS SYMBOL FALSE) NULL)
         (CL:LET*
          ((*PRINTREADABLY?* TRUE))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:WRITE-STRING "Error in logical expression." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:WRITE-STRING
            "   No class is associated with the symbol "
            %%STREAM)
           (PRINT-OBJECT SYMBOL %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:WRITE-STRING
            "   Error occured while parsing the proposition: "
            %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:WRITE-STRING "   " %%STREAM)
           (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))
          (SIGNAL *THE-PROPOSITION-ERROR*)))))
      ((CL:EQ (SYMBOL? SYMBOL) 1)
       (CL:LET*
        ((SYMBOL NULL))
        (CL:SETQ SYMBOL SYMBOL-001)
        (CL:WHEN
         (CL:EQ (GET-CLASS SYMBOL FALSE) NULL)
         (CL:LET*
          ((*PRINTREADABLY?* TRUE))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:WRITE-STRING "Error in logical expression." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:WRITE-STRING
            "   No class is associated with the symbol "
            %%STREAM)
           (PRINT-OBJECT SYMBOL %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:WRITE-STRING
            "   Error occured while parsing the proposition: "
            %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:WRITE-STRING "   " %%STREAM)
           (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))
          (SIGNAL *THE-PROPOSITION-ERROR*)))))
      (CL:T
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING "Error in logical expression." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING "   Illegal token where symbol expected: " %%STREAM)
         (PRINT-OBJECT SYMBOL %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING
          "   Error occured while parsing the proposition: "
          %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING "   " %%STREAM)
         (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))
        (SIGNAL *THE-PROPOSITION-ERROR*))
       (CL:RETURN-FROM BUILD-IN-PROPOSITION NULL))))
    (FIRST-SETTER TREE SYM-PROPOSITIONS-IN)
    (THIRD-SETTER TREE (SURROGATIFY SYMBOL))))
  (CL:LET*
   ((PROPOSITION (CREATE-PROPOSITION SYM-PROPOSITIONS-IN 2))
    (ARGUMENTSVECTOR (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
    (INDIVIDUAL (EVALUATE-TERM (SECOND TREE)))
    (COLLECTION (EVALUATE-TERM (THIRD TREE))))
   (VERIFY-COLLECTION-ARGUMENT COLLECTION NULL)
   (CL:SETF
    (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTSVECTOR) 0)
    INDIVIDUAL)
   (CL:SETF
    (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTSVECTOR) 1)
    COLLECTION)
   (CL:LET*
    ((COLLECTION-001 COLLECTION))
    (CL:COND
     ((CL:EQ (TAXONOMY-ISA? COLLECTION SGT-PROPOSITIONS-DESCRIPTION) 1)
      (CL:LET*
       ((COLLECTION NULL))
       (CL:SETQ COLLECTION COLLECTION-001)
       (CL:WHEN
        (CL:NOT (CL:EQ (DESCRIPTION-SURROGATE COLLECTION) NULL))
        (CL:SETF
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTSVECTOR) 1)
         (DESCRIPTION-SURROGATE COLLECTION)))))
     (CL:T NULL)))
   (CL:WHEN
    (CL:EQ (ISA? INDIVIDUAL SGT-PROPOSITIONS-LOGIC-OBJECT) 0)
    (CL:RETURN-FROM BUILD-IN-PROPOSITION PROPOSITION))
   (CL:WHEN
    (CL:EQ UPDATEMODE NULL)
    (UPDATE-ROOT-TYPES
     (CAST INDIVIDUAL SGT-PROPOSITIONS-LOGIC-OBJECT)
     (MEMBER-TYPE-FROM-COLLECTION COLLECTION))
    (CL:RETURN-FROM BUILD-IN-PROPOSITION PROPOSITION))
   (CL:COND
    ((CL:OR
      (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
      (CL:EQ UPDATEMODE KWD-PROPOSITIONS-CONCEIVE))
     (UPDATE-ROOT-TYPES
      (CAST INDIVIDUAL SGT-PROPOSITIONS-LOGIC-OBJECT)
      (MEMBER-TYPE-FROM-COLLECTION COLLECTION)))
    (CL:T NULL))
   (CL:RETURN-FROM BUILD-IN-PROPOSITION PROPOSITION))
  :VOID)

;;; (DEFUN (EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS PROPOSITION) ...)

(CL:DEFUN EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS (EXISTSPROPOSITION)
  (CL:LET*
   ((ANDPROP
     (CAST
      (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS EXISTSPROPOSITION))
      SGT-PROPOSITIONS-PROPOSITION))
    (ANDARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS ANDPROP)))
   (CL:LET*
    ((VALUE-001 NULL))
    (CL:LET*
     ((ARG NULL)
      (VECTOR-001 ANDARGUMENTS)
      (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:LOOP
      WHILE
      (CL:< INDEX-001 LENGTH-001)
      DO
      (CL:PROGN
       (CL:SETQ
        ARG
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (CLSYS-SVAL PROPOSITION KIND (CAST ARG SGT-PROPOSITIONS-PROPOSITION))
         KWD-PROPOSITIONS-FUNCTION))
       (CL:SETQ VALUE-001 ARG)
       (CL:RETURN))))
    (CL:LET*
     ((PREDICATEPROP VALUE-001))
     (CL:LET*
      ((TEST-VALUE-001 FALSE))
      (CL:SETQ TEST-VALUE-001 (EQ? (LENGTH ANDARGUMENTS) 2))
      (CL:WHEN
       (CL:EQ TEST-VALUE-001 1)
       (CL:LET*
        ((FOUND?-001 FALSE))
        (CL:LET*
         ((ARG NULL)
          (VECTOR-002 ANDARGUMENTS)
          (INDEX-002 0)
          (LENGTH-002 (LENGTH VECTOR-002)))
         (CL:LOOP
          WHILE
          (CL:< INDEX-002 LENGTH-002)
          DO
          (CL:PROGN
           (CL:SETQ
            ARG
            (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
           (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
          (CL:WHEN
           (CL:EQ
            (CLSYS-SVAL
             PROPOSITION
             KIND
             (CAST ARG SGT-PROPOSITIONS-PROPOSITION))
            KWD-PROPOSITIONS-FUNCTION)
           (CL:SETQ FOUND?-001 TRUE)
           (CL:RETURN))))
        (CL:SETQ TEST-VALUE-001 FOUND?-001)))
      (CL:SETQ TEST-VALUE-001 (CL:IF (CL:EQ TEST-VALUE-001 0) TRUE FALSE))
      (CL:WHEN
       (CL:EQ TEST-VALUE-001 1)
       (CL:ERROR
        "Safety violation: INTERNAL ERROR: `embed-negation-within-function-induced-exists' called with wrong kind of proposition.")))
     (INVERT-PROPOSITION (CAST PREDICATEPROP SGT-PROPOSITIONS-PROPOSITION))
     (CL:RETURN-FROM
      EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS
      EXISTSPROPOSITION))))
  :VOID)

;;; (DEFUN (BUILD-AND-OR-NOT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-AND-OR-NOT-PROPOSITION (TREE UPDATEMODE)
  (CL:LET*
   ((TERM NULL) (ARGUMENTS NIL) (PROPOSITION NULL) (ARGUMENTSVECTOR NULL))
   (CL:WHEN
    (CL:NOT
     (CL:OR
      (CL:EQ (CONCEIVING-UPDATE? UPDATEMODE) 1)
      (CL:EQ (DESCRIPTION-MODE?) 1)
      (CL:EQ (FIRST TREE) SYM-PROPOSITIONS-OR)
      (CL:AND
       (CL:EQ (FIRST TREE) SYM-PROPOSITIONS-AND)
       (CL:OR
        (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
        (CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-FALSE)))))
    (CL:ERROR
     "Safety violation: INTERNAL ERROR: `build-and-or-not-proposition' called with update mode `~A' which is illegal for `~A'."
     UPDATEMODE
     TREE))
   (CL:SETQ UPDATEMODE NULL)
   (CL:LET*
    ((ARG NULL) (ITER-001 (CLSYS-SVAL CONS REST TREE)) (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:LET*
      ()
      (CL:SETQ TERM (BUILD-PROPOSITION ARG UPDATEMODE))
      (CL:WHEN
       (CL:NOT (CL:EQ TERM NULL))
       (CL:IF
        (CL:EQ COLLECT-001 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-001 (CONS TERM NIL))
         (CL:IF
          (CL:EQ ARGUMENTS NIL)
          (CL:SETQ ARGUMENTS COLLECT-001)
          (ADD-CONS-TO-END-OF-CONS-LIST ARGUMENTS COLLECT-001)))
        (CL:PROGN
         (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS TERM NIL))
         (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))))
   (CL:WHEN
    (CL:EQ ARGUMENTS NIL)
    (CL:RETURN-FROM BUILD-AND-OR-NOT-PROPOSITION NULL))
   (CL:WHEN
    (CL:AND
     (CL:EQ (FIRST TREE) SYM-PROPOSITIONS-NOT)
     (CL:EQ
      (CLSYS-SVAL
       PROPOSITION
       KIND
       (CAST (FIRST ARGUMENTS) SGT-PROPOSITIONS-PROPOSITION))
      KWD-PROPOSITIONS-EXISTS))
    (CL:RETURN-FROM
     BUILD-AND-OR-NOT-PROPOSITION
     (EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS
      (CAST (FIRST ARGUMENTS) SGT-PROPOSITIONS-PROPOSITION))))
   (CL:SETQ
    PROPOSITION
    (CREATE-PROPOSITION
     (CAST (FIRST TREE) SGT-PROPOSITIONS-SYMBOL)
     (LENGTH ARGUMENTS)))
   (CL:SETQ ARGUMENTSVECTOR (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
   (CL:LET*
    ((I NULL) (ARG NULL) (ITER-002 ARGUMENTS) (ITER-003 0))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
     (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTSVECTOR) I) ARG)))
   (FREE-CONS-LIST ARGUMENTS)
   (CL:RETURN-FROM BUILD-AND-OR-NOT-PROPOSITION PROPOSITION))
  :VOID)

;;; (DEFUN (FUNCTIONAL-TERM? BOOLEAN) ...)

(CL:DEFUN FUNCTIONAL-TERM? (TERM)
  (CL:LET*
   ((TERM-001 TERM))
   (CL:COND
    ((CL:EQ (CONS? TERM) 1)
     (CL:LET*
      ((TERM NULL))
      (CL:SETQ TERM TERM-001)
      (CL:LET*
       ((TEST-VALUE-001 (FIRST TERM)))
       (CL:COND
        ((CL:OR
          (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-SETOFALL)
          (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-THE-ONLY)
          (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-SETOF)
          (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-LISTOF)
          (CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-KAPPA))
         (CL:RETURN-FROM FUNCTIONAL-TERM? FALSE))
        (CL:T (CL:RETURN-FROM FUNCTIONAL-TERM? TRUE))))))
    (CL:T (CL:RETURN-FROM FUNCTIONAL-TERM? FALSE))))
  :VOID)

;;; (DEFUN (CLIP-VALUE? BOOLEAN) ...)

(CL:DEFUN CLIP-VALUE? (TERM1 TERM2)
  (CL:LET*
   ((TERM1-001 TERM1))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? TERM1 SGT-PROPOSITIONS-SKOLEM) 1)
     (CL:LET*
      ((TERM1 NULL))
      (CL:SETQ TERM1 TERM1-001)
      (CL:LET*
       ((VALUE1 (VALUE-OF TERM1)))
       (CL:WHEN
        (CL:EQ (EQL? VALUE1 TERM2) 1)
        (CL:RETURN-FROM CLIP-VALUE? TRUE))
       (CL:WHEN
        (CL:AND
         (CL:EQ (SKOLEM? VALUE1) 0)
         (CL:NOT (CL:EQ (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION TERM1) NULL))
         (CL:EQ *CLIPPING-ENABLED* 1))
        (UNBIND-SKOLEM-VALUE TERM1 TRUE)
        (BIND-SKOLEM-TO-VALUE TERM1 (VALUE-OF TERM2) TRUE)
        (CL:RETURN-FROM CLIP-VALUE? TRUE)))))
    (CL:T NULL)))
  (CL:RETURN-FROM CLIP-VALUE? FALSE)
  :VOID)

;;; (DEFUN (FINISH-BUILDING-EQUIVALENCE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FINISH-BUILDING-EQUIVALENCE-PROPOSITION (TERM1 TERM2)
  (CL:LET*
   ((PROPOSITION (CREATE-PROPOSITION SYM-PROPOSITIONS-EQUIVALENT 2))
    (ARGUMENTSVECTOR (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION)))
   (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTSVECTOR) 0) TERM1)
   (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTSVECTOR) 1) TERM2)
   (CL:RETURN-FROM FINISH-BUILDING-EQUIVALENCE-PROPOSITION PROPOSITION))
  :VOID)

;;; (DEFUN (SUBSTITUTE-FUNCTION-FOR-EQUIVALENCE PROPOSITION) ...)

(CL:DEFUN SUBSTITUTE-FUNCTION-FOR-EQUIVALENCE (FUNCTIONVARIABLE TERM)
  (CL:LET*
   ((PROPOSITION
     (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION FUNCTIONVARIABLE)))
   (REMOVE-DEPENDENT-PROPOSITION-LINK FUNCTIONVARIABLE PROPOSITION)
   (FREE FUNCTIONVARIABLE)
   (LAST-SETTER (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION) TERM)
   (ADD-DEPENDENT-PROPOSITION-LINK TERM PROPOSITION)
   (CL:RETURN-FROM SUBSTITUTE-FUNCTION-FOR-EQUIVALENCE PROPOSITION))
  :VOID)

;;; (DEFUN (BUILD-EQUIVALENCE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-EQUIVALENCE-PROPOSITION (TREE UPDATEMODE)
  (CL:WHEN
   (CL:> (LENGTH TREE) 3)
   (CL:RETURN-FROM
    BUILD-EQUIVALENCE-PROPOSITION
    (BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS TREE UPDATEMODE)))
  (CL:LET*
   ((TERM1 (EVALUATE-TERM (SECOND TREE)))
    (TERM2 (EVALUATE-TERM (THIRD TREE))))
   (CL:WHEN
    (CL:EQ (EQL? TERM1 TERM2) 1)
    (CL:RETURN-FROM BUILD-EQUIVALENCE-PROPOSITION NULL))
   (CL:WHEN
    (CL:AND
     (CL:EQ (FUNCTION-OUTPUT-VARIABLE? TERM1) 1)
     (CL:EQ (FUNCTION-OUTPUT-VARIABLE? TERM2) 0))
    (CL:RETURN-FROM
     BUILD-EQUIVALENCE-PROPOSITION
     (SUBSTITUTE-FUNCTION-FOR-EQUIVALENCE
      (CAST TERM1 SGT-PROPOSITIONS-PATTERN-VARIABLE)
      TERM2)))
   (CL:WHEN
    (CL:AND
     (CL:EQ (FUNCTION-OUTPUT-VARIABLE? TERM2) 1)
     (CL:EQ (FUNCTION-OUTPUT-VARIABLE? TERM1) 0))
    (CL:RETURN-FROM
     BUILD-EQUIVALENCE-PROPOSITION
     (SUBSTITUTE-FUNCTION-FOR-EQUIVALENCE
      (CAST TERM2 SGT-PROPOSITIONS-PATTERN-VARIABLE)
      TERM1)))
   (CL:WHEN
    (CL:OR
     (CL:EQ (DESCRIPTIVE-UPDATE? UPDATEMODE) 1)
     (CL:AND (CL:EQ (SKOLEM? TERM1) 1) (CL:EQ (SKOLEM? TERM2) 1)))
    (CL:RETURN-FROM
     BUILD-EQUIVALENCE-PROPOSITION
     (FINISH-BUILDING-EQUIVALENCE-PROPOSITION TERM1 TERM2)))
   (CL:COND
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
     (CL:WHEN
      (CL:NOT
       (CL:OR
        (CL:EQ (CLIP-VALUE? TERM1 TERM2) 1)
        (CL:EQ (CLIP-VALUE? TERM2 TERM1) 1)))
      (EQUATE-VALUES (VALUE-OF TERM1) (VALUE-OF TERM2)))
     (CL:WHEN
      (CL:AND
       (CL:EQ (FUNCTION-OUTPUT-SKOLEM? TERM1) 1)
       (CL:EQ (FUNCTION-OUTPUT-SKOLEM? TERM2) 0))
      (CL:RETURN-FROM
       BUILD-EQUIVALENCE-PROPOSITION
       (CLSYS-SVAL
        SKOLEM
        DEFINING-PROPOSITION
        (CAST TERM1 SGT-PROPOSITIONS-SKOLEM))))
     (CL:WHEN
      (CL:AND
       (CL:EQ (FUNCTION-OUTPUT-SKOLEM? TERM2) 1)
       (CL:EQ (FUNCTION-OUTPUT-SKOLEM? TERM1) 0))
      (CL:RETURN-FROM
       BUILD-EQUIVALENCE-PROPOSITION
       (CLSYS-SVAL
        SKOLEM
        DEFINING-PROPOSITION
        (CAST TERM2 SGT-PROPOSITIONS-SKOLEM)))))
    ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
     (CL:WHEN
      (CL:OR
       (CL:EQ (UNEQUATE-VALUES? TERM1 TERM2) 1)
       (CL:EQ (UNEQUATE-VALUES? TERM2 TERM1) 1))
      NULL))
    (CL:T
     (CL:RETURN-FROM
      BUILD-EQUIVALENCE-PROPOSITION
      (FINISH-BUILDING-EQUIVALENCE-PROPOSITION TERM1 TERM2))))
   (CL:RETURN-FROM BUILD-EQUIVALENCE-PROPOSITION NULL))
  :VOID)

;;; (DEFUN (BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS (TREE UPDATEMODE)
  (CL:PROGN (CL:SETQ TREE TREE) (CL:SETQ UPDATEMODE UPDATEMODE))
  (CL:ERROR
   "build-conjunction-of-equality-propositions: Write me, I am a dummy!")
  (CL:RETURN-FROM BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS NULL)
  :VOID)

;;; (DEFUN (VERIFY-SECOND-ORDER-VARIABLE SKOLEM) ...)

(CL:DEFUN VERIFY-SECOND-ORDER-VARIABLE (VARIABLE KIND)
  (CL:COND
   ((CL:EQ KIND KWD-PROPOSITIONS-PREDICATE)
    (CL:SETF
     (CLSYS-SVAL SKOLEM ROOT-TYPE VARIABLE)
     SGT-PROPOSITIONS-RELATION))
   ((CL:EQ KIND KWD-PROPOSITIONS-FUNCTION)
    (CL:SETF
     (CLSYS-SVAL SKOLEM ROOT-TYPE VARIABLE)
     SGT-PROPOSITIONS-FUNCTION))
   (CL:T (CL:ERROR "`~A' is not a valid case option" KIND)))
  (CL:RETURN-FROM VERIFY-SECOND-ORDER-VARIABLE VARIABLE)
  :VOID)

;;; (DEFUN (BUILD-PREDICATE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-PREDICATE-PROPOSITION (TREE)
  (CL:LET*
   ((ARGCOUNT (LENGTH (CLSYS-SVAL CONS REST TREE)))
    (VARIABLEPREDICATE
     (LOOKUP-LOGIC-VARIABLE-BINDING
      (CAST (FIRST TREE) SGT-PROPOSITIONS-SYMBOL)))
    (SECONDORDER? (DEFINED? VARIABLEPREDICATE))
    (PROPOSITION
     (CREATE-PROPOSITION
      (CL:IF
       (CL:EQ SECONDORDER? 1)
       SYM-PROPOSITIONS-SECOND-ORDER
       SYM-PROPOSITIONS-PREDICATE)
      ARGCOUNT))
    (ARGUMENTSVECTOR (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
    (FIRSTARG (SECOND TREE)))
   FIRSTARG
   (CL:IF
    (CL:EQ SECONDORDER? 1)
    (CL:PROGN
     (CL:SETF
      (CLSYS-SVAL PROPOSITION OPERATOR PROPOSITION)
      (VERIFY-SECOND-ORDER-VARIABLE
       (CAST VARIABLEPREDICATE SGT-PROPOSITIONS-SKOLEM)
       KWD-PROPOSITIONS-PREDICATE))
     (CL:LET*
      ((I NULL)
       (ARG NULL)
       (ITER-001 (CLSYS-SVAL CONS REST TREE))
       (ITER-002 0))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
       (CL:SETF
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTSVECTOR) I)
        (EVALUATE-TERM ARG)))))
    (CL:LET*
     ((SLOT (LOOKUP-FUNCTION (CAST (FIRST TREE) SGT-PROPOSITIONS-SYMBOL)))
      (SLOTREF
       (CL:IF
        (CL:NOT (CL:EQ SLOT NULL))
        (LOOKUP-SLOTREF
         SGT-PROPOSITIONS-ANY
         (CLSYS-SVAL METHOD-SLOT SLOT-NAME SLOT))
        NULL))
      (FIRSTARGUMENT
       (CL:IF
        (CL:AND
         (CL:NOT (CL:EQ SLOTREF NULL))
         (CL:EQ
          (POP
           (SLOT-COLUMN-TYPES
            (CAST
             (CLSYS-SVAL SURROGATE SURROGATE-VALUE SLOTREF)
             SGT-PROPOSITIONS-SLOT)))
          SGT-PROPOSITIONS-PROPOSITION))
        (BUILD-PROPOSITION FIRSTARG KWD-PROPOSITIONS-CONCEIVE)
        (EVALUATE-TERM FIRSTARG))))
     (CL:SETF
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTSVECTOR) 0)
      FIRSTARGUMENT)
     (CL:WHEN
      (CL:EQ (VALUE-OF FIRSTARGUMENT) BOTTOM)
      (SIGNAL-UNDEFINED-TERM FIRSTARGUMENT))
     (CL:WHEN
      (CL:EQ SLOTREF NULL)
      (CL:SETQ
       SLOTREF
       (LOOKUP-SLOTREF-ON-INSTANCE
        (VALUE-OF FIRSTARGUMENT)
        (CAST (FIRST TREE) SGT-PROPOSITIONS-SYMBOL))))
     (CL:WHEN
      (CL:EQ SLOTREF NULL)
      (FREE PROPOSITION)
      (SIGNAL-UNDEFINED-TERM TREE))
     (CL:WHEN
      (CL:NOT
       (CL:OR
        (CL:EQ (SLOTREF-TYPE SLOTREF) SGT-PROPOSITIONS-BOOLEAN)
        (CL:EQ (SLOTREF-TYPE SLOTREF) SGT-PROPOSITIONS-BOOLEAN-WRAPPER)))
      (FREE PROPOSITION)
      (CL:LET*
       ((*PRINTREADABLY?* TRUE))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING "Error in logical expression." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING
         "   Function term encountered where predicate expected: "
         %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING "   " %%STREAM)
        (PRINT-OBJECT TREE %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING
         "   Error occured while parsing the proposition: "
         %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING "   " %%STREAM)
        (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (SIGNAL *THE-PROPOSITION-ERROR*)))
     (CL:SETF (CLSYS-SVAL PROPOSITION OPERATOR PROPOSITION) SLOTREF)
     (CL:LET*
      ((TYPE NULL)
       (I NULL)
       (ARG NULL)
       (ITER-003 (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
       (ITER-004 1)
       (ITER-005
        (ADVANCE
         (SLOT-COLUMN-TYPES
          (CAST
           (CLSYS-SVAL SURROGATE SURROGATE-VALUE SLOTREF)
           SGT-PROPOSITIONS-SLOT))
         1)))
      (CL:LOOP
       WHILE
       (CL:AND (CL:NOT (CL:EQ ITER-003 NIL)) (CL:EQ (NEXT? ITER-005) 1))
       DO
       (CL:PROGN
        (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-003))
        (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
       (CL:PROGN (CL:SETQ I ITER-004) (CL:SETQ ITER-004 (CL:1+ ITER-004)))
       (CL:PROGN
        (CL:SETQ
         TYPE
         (CAST (CLSYS-SVAL ITERATOR VALUE ITER-005) SGT-PROPOSITIONS-TYPE)))
       (CL:IF
        (CL:EQ TYPE SGT-PROPOSITIONS-PROPOSITION)
        (CL:SETF
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTSVECTOR) I)
         (BUILD-PROPOSITION ARG KWD-PROPOSITIONS-CONCEIVE))
        (CL:SETF
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTSVECTOR) I)
         (EVALUATE-TERM ARG)))))))
   (CL:RETURN-FROM BUILD-PREDICATE-PROPOSITION PROPOSITION))
  :VOID)

;;; (DEFUN (BUILD-EXISTS-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-EXISTS-PROPOSITION (TREE UPDATEMODE)
  (CL:LET*
   ((DESCRIPTIVE? (DESCRIPTIVE-UPDATE? UPDATEMODE)))
   (CL:WHEN
    (CL:EQ DESCRIPTIVE? 1)
    (CL:SETQ UPDATEMODE KWD-PROPOSITIONS-CONCEIVE))
   (CL:LET*
    ((VARIABLES NULL) (PROPOSITION NULL) (UNUSED NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (VARIABLES PROPOSITION UNUSED)
     (BUILD-QUANTIFIED-PROPOSITION TREE UPDATEMODE))
    (CL:SETQ UNUSED UNUSED)
    (CL:IF
     (CL:EQ DESCRIPTIVE? 1)
     (CL:LET*
      ((EXISTSPROP (CREATE-PROPOSITION SYM-PROPOSITIONS-EXISTS 1)))
      (CL:SETF
       (CLSYS-SVAL PROPOSITION KIND EXISTSPROP)
       KWD-PROPOSITIONS-EXISTS)
      (CL:SETF
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL PROPOSITION ARGUMENTS EXISTSPROP))
        0)
       PROPOSITION)
      (SET-DYNAMIC-SLOT-VALUE
       EXISTSPROP
       SYM-PROPOSITIONS-IO-VARIABLES
       (COPY-CONS-LIST-TO-VARIABLES-VECTOR VARIABLES)
       NULL)
      (FREE-CONS-LIST VARIABLES)
      (CL:RETURN-FROM BUILD-EXISTS-PROPOSITION EXISTSPROP))
     (CL:PROGN
      (FREE-CONS-LIST VARIABLES)
      (CL:RETURN-FROM BUILD-EXISTS-PROPOSITION PROPOSITION)))))
  :VOID)

;;; (DEFUN (TOP-LEVEL-EXISTS-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN TOP-LEVEL-EXISTS-PROPOSITION? (PROPOSITION)
  (CL:RETURN-FROM
   TOP-LEVEL-EXISTS-PROPOSITION?
   (CL:IF
    (CL:AND
     (CL:EQ (UNKNOWN? PROPOSITION) 0)
     (CL:EQ (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? PROPOSITION NULL) 1))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (COLLECT-SKOLEMIZED-EXISTS-VARIABLES (VECTOR OF SKOLEM)) ...)

(CL:DEFUN COLLECT-SKOLEMIZED-EXISTS-VARIABLES (PROPOSITION)
  (CL:LET*
   ((SKOLEMS (NEW-LIST)) (RESULT NULL))
   (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? PROPOSITION SKOLEMS)
   (CL:IF
    (CL:EQ (EMPTY? SKOLEMS) 1)
    (CL:SETQ RESULT ZERO-VARIABLES-VECTOR)
    (CL:SETQ RESULT (NEW-VECTOR (LENGTH SKOLEMS))))
   (CL:LET*
    ((I NULL)
     (SKOLEM NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST SKOLEMS))
     (ITER-002 0))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       SKOLEM
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-PROPOSITIONS-SKOLEM))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
     (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY RESULT) I) SKOLEM)))
   (FREE SKOLEMS)
   (CL:RETURN-FROM COLLECT-SKOLEMIZED-EXISTS-VARIABLES RESULT))
  :VOID)

;;; (DEFUN (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? BOOLEAN) ...)

(CL:DEFUN HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? (PROPOSITION RESULT)
  (CL:LET*
   ((ARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
    (ARGUMENTCOUNT (LENGTH ARGUMENTS)))
   (CL:WHEN
    (CL:EQ
     (CLSYS-SVAL PROPOSITION KIND PROPOSITION)
     KWD-PROPOSITIONS-FUNCTION)
    (CL:SETQ ARGUMENTCOUNT (CL:1- ARGUMENTCOUNT)))
   (CL:LET*
    ((I NULL)
     (ARG NULL)
     (VECTOR-001 ARGUMENTS)
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001))
     (ITER-001 1)
     (UPPER-BOUND-001 ARGUMENTCOUNT)
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
    (CL:LOOP
     WHILE
     (CL:AND
      (CL:< INDEX-001 LENGTH-001)
      (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001)))
     DO
     (CL:PROGN
      (CL:SETQ
       ARG
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETQ I I)
     (CL:LET*
      ((ARG-001 ARG))
      (CL:COND
       ((CL:EQ (TAXONOMY-ISA? ARG SGT-PROPOSITIONS-PROPOSITION) 1)
        (CL:LET*
         ((ARG NULL))
         (CL:SETQ ARG ARG-001)
         (CL:WHEN
          (CL:AND
           (CL:EQ (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? ARG RESULT) 1)
           (CL:EQ RESULT NULL))
          (CL:RETURN-FROM HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? TRUE))))
       ((CL:EQ (TAXONOMY-ISA? ARG SGT-PROPOSITIONS-PATTERN-VARIABLE) 1)
        (CL:LET* ((ARG NULL)) (CL:SETQ ARG ARG-001) NULL))
       ((CL:EQ (TAXONOMY-ISA? ARG SGT-PROPOSITIONS-SKOLEM) 1)
        (CL:LET*
         ((ARG NULL))
         (CL:SETQ ARG ARG-001)
         (CL:LET*
          ((FOUND?-001 FALSE))
          (CL:LET*
           ((PROP NULL)
            (ITER-002
             (CLSYS-SVAL
              LIST
              THE-CONS-LIST
              (CLSYS-SVAL SKOLEM DEPENDENT-PROPOSITIONS ARG))))
           (CL:LOOP
            WHILE
            (CL:NOT (CL:EQ ITER-002 NIL))
            DO
            (CL:PROGN
             (CL:SETQ
              PROP
              (CAST
               (CLSYS-SVAL CONS VALUE ITER-002)
               SGT-PROPOSITIONS-PROPOSITION))
             (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
            (CL:WHEN
             (CL:AND (CL:EQ (TRUE? PROP) 1) (CL:EQ (VARIABLE-TYPE? PROP) 1))
             (CL:SETQ FOUND?-001 TRUE)
             (CL:RETURN))))
          (CL:WHEN
           (CL:EQ FOUND?-001 1)
           (CL:IF
            (CL:NOT (CL:EQ RESULT NULL))
            (INSERT-NEW RESULT ARG)
            (CL:RETURN-FROM
             HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES?
             TRUE))))))
       (CL:T NULL)))))
   (CL:IF
    (CL:NOT (CL:EQ RESULT NULL))
    (CL:RETURN-FROM
     HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES?
     (NON-EMPTY? RESULT))
    (CL:RETURN-FROM HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? FALSE)))
  :VOID)

;;; (DEFUN (BUILD-FORALL-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-FORALL-PROPOSITION (TREE UPDATEMODE)
  (CL:LET*
   ((FORALLPROP (CREATE-PROPOSITION SYM-PROPOSITIONS-FORALL 2)))
   (CL:LET*
    ((*EVALUATIONMODE* KWD-PROPOSITIONS-QUERY))
    (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
    (CL:LET*
     ((VARIABLES NULL) (WHEREPROPOSITION NULL) (ALWAYSPROPOSITION NULL))
     (CL:MULTIPLE-VALUE-SETQ
      (VARIABLES WHEREPROPOSITION ALWAYSPROPOSITION)
      (BUILD-QUANTIFIED-PROPOSITION TREE KWD-PROPOSITIONS-CONCEIVE))
     (CL:SETF
      (CLSYS-SVAL PROPOSITION KIND FORALLPROP)
      KWD-PROPOSITIONS-FORALL)
     (SET-DYNAMIC-SLOT-VALUE
      FORALLPROP
      SYM-PROPOSITIONS-IO-VARIABLES
      (COPY-CONS-LIST-TO-VARIABLES-VECTOR VARIABLES)
      NULL)
     (FREE-CONS-LIST VARIABLES)
     (CL:SETF
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL PROPOSITION ARGUMENTS FORALLPROP))
       0)
      (CL:IF
       (CL:NOT (CL:EQ WHEREPROPOSITION NULL))
       WHEREPROPOSITION
       TRUE-PROPOSITION))
     (CL:SETF
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL PROPOSITION ARGUMENTS FORALLPROP))
       1)
      ALWAYSPROPOSITION)
     (NORMALIZE-FORALL-PROPOSITION FORALLPROP)))
   (CL:RETURN-FROM
    BUILD-FORALL-PROPOSITION
    (DERIVE-IMPLIES-PROPOSITIONS FORALLPROP UPDATEMODE)))
  :VOID)

;;; (DEFUN VERIFY-IMPLIES-ARGUMENT ...)

(CL:DEFUN VERIFY-IMPLIES-ARGUMENT (SELF OPERATOR)
  (CL:COND
   ((CL:EQ OPERATOR SYM-PROPOSITIONS-SUBSET-OF)
    (VERIFY-COLLECTION-ARGUMENT SELF NULL))
   ((CL:EQ OPERATOR SYM-PROPOSITIONS-IMPLIES) (VERIFY-RELATION-ARGUMENT SELF))
   (CL:T (CL:ERROR "`~A' is not a valid case option" OPERATOR)))
  :VOID)

;;; (DEFUN (BUILD-IMPLIES-PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-IMPLIES-PROPOSITION (TREE UPDATEMODE)
  (CL:SETQ UPDATEMODE UPDATEMODE)
  (VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS TREE 2)
  (CL:LET*
   ((TAILARG (EVALUATE-TERM (SECOND TREE)))
    (HEADARG (EVALUATE-TERM (THIRD TREE))))
   (VERIFY-IMPLIES-ARGUMENT
    HEADARG
    (CAST (FIRST TREE) SGT-PROPOSITIONS-SYMBOL))
   (VERIFY-IMPLIES-ARGUMENT
    TAILARG
    (CAST (FIRST TREE) SGT-PROPOSITIONS-SYMBOL))
   (CL:RETURN-FROM
    BUILD-IMPLIES-PROPOSITION
    (FINISH-BUILDING-IMPLIES-PROPOSITION HEADARG TAILARG NULL TRUE)))
  :VOID)

;;; (DEFUN (FIND-DUPLICATE-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FIND-DUPLICATE-FUNCTION-PROPOSITION (SLOTREF ARGUMENTS)
  (CL:LET*
   ((LOGICOBJARGUMENT NULL))
   (CL:LET*
    ((ARG NULL) (ITER-001 ARGUMENTS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:EQ (ISA? ARG SGT-PROPOSITIONS-LOGIC-OBJECT) 1)
      (CL:SETQ LOGICOBJARGUMENT (CAST ARG SGT-PROPOSITIONS-LOGIC-OBJECT))
      (CL:RETURN))))
   (CL:COND
    ((CL:EQ LOGICOBJARGUMENT NULL)
     (CL:RETURN-FROM FIND-DUPLICATE-FUNCTION-PROPOSITION NULL))
    ((CL:AND
      (CL:EQ LOGICOBJARGUMENT (FIRST ARGUMENTS))
      (CL:EQ (CLSYS-SVAL CONS REST ARGUMENTS) NIL))
     (CL:LET*
      ((VALUE-001 NULL))
      (CL:LET*
       ((PROP NULL)
        (ITER-002
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (CLSYS-SVAL
           LOGIC-OBJECT
           DEPENDENT-ATTRIBUTE-PROPOSITIONS
           LOGICOBJARGUMENT))))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-002 NIL))
        DO
        (CL:PROGN
         (CL:SETQ
          PROP
          (CAST
           (CLSYS-SVAL CONS VALUE ITER-002)
           SGT-PROPOSITIONS-PROPOSITION))
         (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
        (CL:WHEN
         (CL:EQ (CLSYS-SVAL PROPOSITION OPERATOR PROP) SLOTREF)
         (CL:SETQ VALUE-001 PROP)
         (CL:RETURN))))
      (CL:LET*
       ((VALUE-002 VALUE-001))
       (CL:RETURN-FROM FIND-DUPLICATE-FUNCTION-PROPOSITION VALUE-002))))
    (CL:T
     (CL:LET*
      ((P NULL)
       (ITER-003
        (CLSYS-SVAL
         LIST
         THE-CONS-LIST
         (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS LOGICOBJARGUMENT))))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-003 NIL))
       DO
       (CL:PROGN
        (CL:SETQ
         P
         (CAST (CLSYS-SVAL CONS VALUE ITER-003) SGT-PROPOSITIONS-PROPOSITION))
        (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
       (CL:LET*
        ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND P)))
        (CL:COND
         ((CL:EQ TEST-VALUE-001 KWD-PROPOSITIONS-FUNCTION)
          (CL:LET*
           ((TEST-VALUE-002 FALSE))
           (CL:SETQ
            TEST-VALUE-002
            (EQ? (CLSYS-SVAL PROPOSITION OPERATOR P) SLOTREF))
           (CL:WHEN
            (CL:EQ TEST-VALUE-002 1)
            (CL:LET*
             ((ALWAYS?-001 TRUE))
             (CL:LET*
              ((ARG2 NULL)
               (ARG1 NULL)
               (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS P))
               (INDEX-001 0)
               (LENGTH-001 (LENGTH VECTOR-001))
               (ITER-004 ARGUMENTS))
              (CL:LOOP
               WHILE
               (CL:AND
                (CL:< INDEX-001 LENGTH-001)
                (CL:NOT (CL:EQ ITER-004 NIL)))
               DO
               (CL:PROGN
                (CL:SETQ
                 ARG1
                 (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
                (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
               (CL:PROGN
                (CL:SETQ ARG2 (CLSYS-SVAL CONS VALUE ITER-004))
                (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
               (CL:WHEN
                (CL:EQ (EQL? ARG1 ARG2) 0)
                (CL:SETQ ALWAYS?-001 FALSE)
                (CL:RETURN))))
             (CL:SETQ TEST-VALUE-002 ALWAYS?-001))
            (CL:WHEN
             (CL:EQ TEST-VALUE-002 1)
             (CL:SETQ
              TEST-VALUE-002
              (EQ?
               (LENGTH ARGUMENTS)
               (LENGTH (CLSYS-SVAL PROPOSITION ARGUMENTS P))))))
           (CL:WHEN
            (CL:EQ TEST-VALUE-002 1)
            (CL:RETURN-FROM FIND-DUPLICATE-FUNCTION-PROPOSITION P))))
         (CL:T NULL)))))))
   (CL:RETURN-FROM FIND-DUPLICATE-FUNCTION-PROPOSITION NULL))
  :VOID)

;;; (DEFUN (CREATE-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN CREATE-FUNCTION-PROPOSITION (SLOTREF INPUTARGUMENTS)
  (CL:LET*
   ((ARGCOUNT (CL:1+ (LENGTH INPUTARGUMENTS)))
    (PROPOSITION (CREATE-PROPOSITION SYM-PROPOSITIONS-FUNCTION ARGCOUNT))
    (ARGUMENTSVECTOR (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
    (SLOT
     (CAST
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SLOTREF)
      SGT-PROPOSITIONS-SLOT))
    (TYPE (CLSYS-SVAL SLOT SLOT-BASE-TYPE SLOT))
    (SKOLEM NULL))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ TYPE NULL))
     (CL:EQ (SUBTYPE-OF? TYPE SGT-PROPOSITIONS-LITERAL-WRAPPER) 1))
    (CL:SETQ TYPE (WRAPPED-TYPE-TO-TYPE TYPE)))
   (CL:SETQ
    SKOLEM
    (CL:IF
     (CL:EQ (DESCRIPTION-MODE?) 1)
     (CREATE-VARIABLE TYPE NULL FALSE)
     (CREATE-SKOLEM TYPE NULL)))
   (UPDATE-ROOT-TYPES SKOLEM TYPE)
   (CL:SETF (CLSYS-SVAL PROPOSITION OPERATOR PROPOSITION) SLOTREF)
   (CL:LET*
    ((I NULL) (ARG NULL) (ITER-001 INPUTARGUMENTS) (ITER-002 0))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
     (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTSVECTOR) I) ARG)))
   (CL:SETF
    (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTSVECTOR) (CL:1- ARGCOUNT))
    SKOLEM)
   (CL:SETF (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION SKOLEM) PROPOSITION)
   (FASTEN-DOWN-PROPOSITION PROPOSITION)
   (CL:LET*
    ((TERM NULL)
     (VECTOR-001 ARGUMENTSVECTOR)
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       TERM
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (ADD-DEPENDENT-PROPOSITION-LINK TERM PROPOSITION)))
   (CL:RETURN-FROM CREATE-FUNCTION-PROPOSITION PROPOSITION))
  :VOID)

;;; (DEFUN (CREATE-SECOND-ORDER-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN CREATE-SECOND-ORDER-FUNCTION-PROPOSITION (VARIABLEFUNCTION INPUTARGUMENTS)
  (CL:LET*
   ((ARGCOUNT (CL:1+ (LENGTH INPUTARGUMENTS)))
    (PROPOSITION (CREATE-PROPOSITION SYM-PROPOSITIONS-FUNCTION ARGCOUNT))
    (ARGUMENTSVECTOR (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
    (VARIABLE (CREATE-VARIABLE SGT-PROPOSITIONS-UNKNOWN NULL FALSE)))
   (CL:SETF
    (CLSYS-SVAL PROPOSITION OPERATOR PROPOSITION)
    (VERIFY-SECOND-ORDER-VARIABLE
     (CAST VARIABLEFUNCTION SGT-PROPOSITIONS-SKOLEM)
     KWD-PROPOSITIONS-FUNCTION))
   (CL:LET*
    ((I NULL) (ARG NULL) (ITER-001 INPUTARGUMENTS) (ITER-002 0))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
     (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTSVECTOR) I) ARG)))
   (CL:SETF
    (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTSVECTOR) (CL:1- ARGCOUNT))
    VARIABLE)
   (CL:SETF
    (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION VARIABLE)
    PROPOSITION)
   (CL:LET*
    ((TERM NULL)
     (VECTOR-001 ARGUMENTSVECTOR)
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       TERM
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (ADD-DEPENDENT-PROPOSITION-LINK TERM PROPOSITION)))
   (CL:RETURN-FROM CREATE-SECOND-ORDER-FUNCTION-PROPOSITION PROPOSITION))
  :VOID)

;;; (DEFUN (FINISH-EVALUATING-FUNCTION-TERM OBJECT) ...)

(CL:DEFUN FINISH-EVALUATING-FUNCTION-TERM (SLOTREF INPUTARGUMENTS)
  (CL:LET*
   ((PROPOSITION NULL))
   (CL:WHEN
    (CL:EQ (DESCRIPTION-MODE?) 0)
    (CL:SETQ
     PROPOSITION
     (FIND-DUPLICATE-FUNCTION-PROPOSITION SLOTREF INPUTARGUMENTS)))
   (CL:WHEN
    (CL:EQ PROPOSITION NULL)
    (CL:SETQ PROPOSITION (CREATE-FUNCTION-PROPOSITION SLOTREF INPUTARGUMENTS))
    (REACT-TO-KB-UPDATE *CONTEXT* PROPOSITION))
   (CL:RETURN-FROM
    FINISH-EVALUATING-FUNCTION-TERM
    (FUNCTION-REPRESENTATIVE PROPOSITION)))
  :VOID)

;;; (DEFUN (EVALUATE-FUNCTION-TERM OBJECT) ...)

(CL:DEFUN EVALUATE-FUNCTION-TERM (TREE)
  (CL:LET*
   ((VARIABLEFUNCTION
     (LOOKUP-LOGIC-VARIABLE-BINDING
      (CAST (FIRST TREE) SGT-PROPOSITIONS-SYMBOL)))
    (SECONDORDER? (DEFINED? VARIABLEFUNCTION))
    (INPUTARGUMENTS NIL)
    (SLOTREF NULL))
   (CL:LET*
    ((ARG NULL) (ITER-001 (CLSYS-SVAL CONS REST TREE)) (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (CONS (EVALUATE-TERM ARG) NIL))
       (CL:IF
        (CL:EQ INPUTARGUMENTS NIL)
        (CL:SETQ INPUTARGUMENTS COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST INPUTARGUMENTS COLLECT-001)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-001)
        (CONS (EVALUATE-TERM ARG) NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:WHEN
    (CL:EQ SECONDORDER? 1)
    (CL:RETURN-FROM
     EVALUATE-FUNCTION-TERM
     (FUNCTION-VALUE
      (CREATE-SECOND-ORDER-FUNCTION-PROPOSITION
       VARIABLEFUNCTION
       INPUTARGUMENTS))))
   (CL:WHEN
    (CL:EQ (VALUE-OF (FIRST INPUTARGUMENTS)) BOTTOM)
    (SIGNAL-UNDEFINED-TERM (FIRST INPUTARGUMENTS)))
   (CL:SETQ
    SLOTREF
    (LOOKUP-SLOTREF-ON-INSTANCE
     (VALUE-OF (FIRST INPUTARGUMENTS))
     (CAST (FIRST TREE) SGT-PROPOSITIONS-SYMBOL)))
   (CL:WHEN (CL:EQ SLOTREF NULL) (SIGNAL-UNDEFINED-TERM TREE))
   (CL:RETURN-FROM
    EVALUATE-FUNCTION-TERM
    (FINISH-EVALUATING-FUNCTION-TERM SLOTREF INPUTARGUMENTS)))
  :VOID)

;;; (DEFUN (FUNCTION-OUTPUT-VARIABLE? BOOLEAN) ...)

(CL:DEFUN FUNCTION-OUTPUT-VARIABLE? (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-PATTERN-VARIABLE) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       FUNCTION-OUTPUT-VARIABLE?
       (CL:IF
        (CL:NOT
         (CL:EQ (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION SELF) NULL))
        TRUE
        FALSE))))
    (CL:T (CL:RETURN-FROM FUNCTION-OUTPUT-VARIABLE? FALSE))))
  :VOID)

;;; (DEFUN (FUNCTION-OUTPUT-SKOLEM? BOOLEAN) ...)

(CL:DEFUN FUNCTION-OUTPUT-SKOLEM? (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-PROPOSITIONS-SKOLEM) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       FUNCTION-OUTPUT-SKOLEM?
       (CL:IF
        (CL:NOT (CL:EQ (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION SELF) NULL))
        TRUE
        FALSE))))
    (CL:T (CL:RETURN-FROM FUNCTION-OUTPUT-SKOLEM? FALSE))))
  :VOID)

;;; (DEFUN (REMOVE-TRUE-AND-FALSE OBJECT BOOLEAN) ...)

(CL:DEFUN REMOVE-TRUE-AND-FALSE (TREE)
  (CL:LET*
   ((T SYM-PROPOSITIONS-TRUE) (F SYM-PROPOSITIONS-FALSE))
   (CL:LET*
    ((TEST-VALUE-001 FALSE))
    (CL:LET*
     ((FOUND?-001 FALSE))
     (CL:LET*
      ((ARG NULL) (ITER-001 (CLSYS-SVAL CONS REST TREE)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (CL:WHEN
        (CL:OR (CL:EQ ARG T) (CL:EQ ARG F))
        (CL:SETQ FOUND?-001 TRUE)
        (CL:RETURN))))
     (CL:SETQ TEST-VALUE-001 FOUND?-001))
    (CL:SETQ TEST-VALUE-001 (CL:IF (CL:EQ TEST-VALUE-001 0) TRUE FALSE))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:RETURN-FROM REMOVE-TRUE-AND-FALSE (CL:VALUES TREE FALSE))))
   (CL:LET*
    ((TEST-VALUE-002 (CAST (FIRST TREE) SGT-PROPOSITIONS-SYMBOL)))
    (CL:COND
     ((CL:EQ TEST-VALUE-002 SYM-PROPOSITIONS-AND)
      (CL:SETF
       (CLSYS-SVAL CONS REST TREE)
       (REMOVE (CLSYS-SVAL CONS REST TREE) T))
      (CL:LET*
       ((FOUND?-002 FALSE))
       (CL:LET*
        ((ARG NULL) (ITER-002 (CLSYS-SVAL CONS REST TREE)))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-002 NIL))
         DO
         (CL:PROGN
          (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-002))
          (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
         (CL:WHEN (CL:EQ ARG F) (CL:SETQ FOUND?-002 TRUE) (CL:RETURN))))
       (CL:WHEN
        (CL:EQ FOUND?-002 1)
        (FREE-CONS-TREE TREE)
        (CL:RETURN-FROM
         REMOVE-TRUE-AND-FALSE
         (CL:VALUES SYM-PROPOSITIONS-FALSE TRUE)))))
     ((CL:EQ TEST-VALUE-002 SYM-PROPOSITIONS-OR)
      (CL:SETF
       (CLSYS-SVAL CONS REST TREE)
       (REMOVE (CLSYS-SVAL CONS REST TREE) F))
      (CL:LET*
       ((FOUND?-003 FALSE))
       (CL:LET*
        ((ARG NULL) (ITER-003 (CLSYS-SVAL CONS REST TREE)))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-003 NIL))
         DO
         (CL:PROGN
          (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-003))
          (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
         (CL:WHEN (CL:EQ ARG T) (CL:SETQ FOUND?-003 TRUE) (CL:RETURN))))
       (CL:WHEN
        (CL:EQ FOUND?-003 1)
        (FREE-CONS-TREE TREE)
        (CL:RETURN-FROM
         REMOVE-TRUE-AND-FALSE
         (CL:VALUES SYM-PROPOSITIONS-TRUE TRUE)))))
     ((CL:EQ TEST-VALUE-002 SYM-PROPOSITIONS-NOT)
      (CL:LET*
       ((TEST-VALUE-003 (CAST (SECOND TREE) SGT-PROPOSITIONS-SYMBOL)))
       (CL:COND
        ((CL:EQ TEST-VALUE-003 SYM-PROPOSITIONS-TRUE)
         (FREE-CONS-TREE TREE)
         (CL:RETURN-FROM
          REMOVE-TRUE-AND-FALSE
          (CL:VALUES SYM-PROPOSITIONS-FALSE TRUE)))
        ((CL:EQ TEST-VALUE-003 SYM-PROPOSITIONS-FALSE)
         (FREE-CONS-TREE TREE)
         (CL:RETURN-FROM
          REMOVE-TRUE-AND-FALSE
          (CL:VALUES SYM-PROPOSITIONS-TRUE FALSE)))
        (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-003)))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-002))))
   (CL:RETURN-FROM
    REMOVE-TRUE-AND-FALSE
    (CL:VALUES (CANONICALIZE-PROPOSITION-TREE TREE) TRUE)))
  :VOID)

;;; (DEFUN (FLATTEN-NESTED-OPERATORS OBJECT BOOLEAN) ...)

(CL:DEFUN FLATTEN-NESTED-OPERATORS (TREE)
  (CL:LET*
   ((TEST-VALUE-001 FALSE))
   (CL:LET*
    ((FOUND?-001 FALSE))
    (CL:LET*
     ((ARG NULL) (ITER-001 (CLSYS-SVAL CONS REST TREE)))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:WHEN
       (CL:AND
        (CL:EQ (CONS? ARG) 1)
        (CL:EQ
         (EQL? (FIRST (CAST ARG SGT-PROPOSITIONS-CONS)) (FIRST TREE))
         1))
       (CL:SETQ FOUND?-001 TRUE)
       (CL:RETURN))))
    (CL:SETQ TEST-VALUE-001 FOUND?-001))
   (CL:SETQ TEST-VALUE-001 (CL:IF (CL:EQ TEST-VALUE-001 0) TRUE FALSE))
   (CL:WHEN
    (CL:EQ TEST-VALUE-001 1)
    (CL:RETURN-FROM FLATTEN-NESTED-OPERATORS (CL:VALUES TREE FALSE))))
  (CL:LET*
   ((TARGETOPERATOR (CAST (FIRST TREE) SGT-PROPOSITIONS-SYMBOL))
    (MATCHINGARG NULL))
   (CL:LET*
    ((ARG NULL) (ITER-002 (CLSYS-SVAL CONS REST TREE)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:WHEN
      (CL:AND
       (CL:EQ (CONS? ARG) 1)
       (CL:EQ (FIRST (CAST ARG SGT-PROPOSITIONS-CONS)) TARGETOPERATOR))
      (CL:SETQ MATCHINGARG (CAST ARG SGT-PROPOSITIONS-CONS))
      (CL:RETURN))))
   (CL:SETQ TREE (REMOVE TREE MATCHINGARG))
   (CL:LET*
    ((ARG NULL) (ITER-003 (CLSYS-SVAL CONS REST MATCHINGARG)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-003 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-003))
      (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
     (CL:SETF
      (CLSYS-SVAL CONS REST TREE)
      (CONS ARG (CLSYS-SVAL CONS REST TREE)))))
   (FREE-CONS-LIST MATCHINGARG)
   (CL:RETURN-FROM
    FLATTEN-NESTED-OPERATORS
    (CL:VALUES (CANONICALIZE-PROPOSITION-TREE TREE) TRUE)))
  :VOID)

;;; (DEFUN (CANONICALIZE-AND-OR-TREE OBJECT) ...)

(CL:DEFUN CANONICALIZE-AND-OR-TREE (TREE)
  (CL:LET*
   ((OPERATOR (CAST (FIRST TREE) SGT-PROPOSITIONS-SYMBOL))
    (ARGCOUNT (LENGTH (CLSYS-SVAL CONS REST TREE)))
    (CANONICAL? FALSE)
    (RESULTTREE NULL)
    (ARG NULL))
   (CL:MULTIPLE-VALUE-SETQ
    (RESULTTREE CANONICAL?)
    (REMOVE-TRUE-AND-FALSE TREE))
   (CL:IF
    (CL:EQ CANONICAL? 1)
    (CL:RETURN-FROM CANONICALIZE-AND-OR-TREE RESULTTREE)
    (CL:SETQ TREE (CAST RESULTTREE SGT-PROPOSITIONS-CONS)))
   (CL:COND
    ((CL:> ARGCOUNT 1)
     (CL:MULTIPLE-VALUE-SETQ
      (RESULTTREE CANONICAL?)
      (FLATTEN-NESTED-OPERATORS TREE))
     (CL:RETURN-FROM CANONICALIZE-AND-OR-TREE RESULTTREE))
    ((CL:= ARGCOUNT 1)
     (CL:SETQ ARG (SECOND TREE))
     (FREE-CONS-LIST TREE)
     (CL:RETURN-FROM
      CANONICALIZE-AND-OR-TREE
      (CANONICALIZE-PROPOSITION-TREE ARG)))
    (CL:T
     (FREE-CONS-LIST TREE)
     (CL:COND
      ((CL:EQ OPERATOR SYM-PROPOSITIONS-AND)
       (CL:RETURN-FROM CANONICALIZE-AND-OR-TREE SYM-PROPOSITIONS-TRUE))
      ((CL:EQ OPERATOR SYM-PROPOSITIONS-OR)
       (CL:RETURN-FROM CANONICALIZE-AND-OR-TREE SYM-PROPOSITIONS-FALSE))
      (CL:T (CL:ERROR "`~A' is not a valid case option" OPERATOR))))))
  :VOID)

;;; (DEFUN (CANONICALIZE-NEGATION-TREE OBJECT) ...)

(CL:DEFUN CANONICALIZE-NEGATION-TREE (TREE)
  (CL:LET*
   ((ARGUMENT (CAST (SECOND TREE) SGT-PROPOSITIONS-CONS))
    (NESTEDOPERATOR (CAST (FIRST ARGUMENT) SGT-PROPOSITIONS-SYMBOL)))
   (CL:COND
    ((CL:EQ NESTEDOPERATOR SYM-PROPOSITIONS-NOT)
     (FREE-CONS-LIST TREE)
     (CL:RETURN-FROM
      CANONICALIZE-NEGATION-TREE
      (CANONICALIZE-PROPOSITION-TREE (SECOND ARGUMENT))))
    ((CL:OR
      (CL:EQ NESTEDOPERATOR SYM-PROPOSITIONS-AND)
      (CL:EQ NESTEDOPERATOR SYM-PROPOSITIONS-OR))
     (CL:LET*
      ((IT (ALLOCATE-ITERATOR (CLSYS-SVAL CONS REST ARGUMENT))))
      (CL:LOOP
       WHILE
       (CL:EQ (NEXT? IT) 1)
       DO
       (VALUE-SETTER
        IT
        (LIST*
         SYM-PROPOSITIONS-NOT
         (CLSYS-SVAL CONS-ITERATOR VALUE IT)
         NIL))))
     (CL:COND
      ((CL:EQ NESTEDOPERATOR SYM-PROPOSITIONS-AND)
       (FIRST-SETTER ARGUMENT SYM-PROPOSITIONS-OR))
      ((CL:EQ NESTEDOPERATOR SYM-PROPOSITIONS-OR)
       (FIRST-SETTER ARGUMENT SYM-PROPOSITIONS-AND))
      (CL:T (CL:ERROR "`~A' is not a valid case option" NESTEDOPERATOR))))
    ((CL:EQ NESTEDOPERATOR SYM-PROPOSITIONS-EXISTS)
     (CL:LET*
      ((WHERECLAUSE (EXTRACT-WHERE-CLAUSE ARGUMENT)))
      (FIRST-SETTER ARGUMENT SYM-PROPOSITIONS-FORALL)
      (CL:SETF
       (CLSYS-SVAL CONS REST (LAST-CONS ARGUMENT))
       (CONS
        (LIST*
         SYM-PROPOSITIONS-ALWAYS
         (LIST* SYM-PROPOSITIONS-NOT WHERECLAUSE NIL)
         NIL)
        NIL))))
    ((CL:EQ NESTEDOPERATOR SYM-PROPOSITIONS-FORALL)
     (CL:LET*
      ((WHERECLAUSE (EXTRACT-WHERE-CLAUSE ARGUMENT))
       (ALWAYSCLAUSE (EXTRACT-ALWAYS-CLAUSE ARGUMENT)))
      (FIRST-SETTER ARGUMENT SYM-PROPOSITIONS-EXISTS)
      (CL:SETF
       (CLSYS-SVAL CONS REST (LAST-CONS ARGUMENT))
       (CL:IF
        (CL:NOT (CL:EQ WHERECLAUSE NULL))
        (CONS
         (LIST*
          SYM-PROPOSITIONS-WHERE
          (LIST*
           SYM-PROPOSITIONS-AND
           WHERECLAUSE
           (CONS (LIST* SYM-PROPOSITIONS-NOT ALWAYSCLAUSE NIL) NIL))
          NIL)
         NIL)
        (CONS
         (LIST*
          SYM-PROPOSITIONS-WHERE
          (LIST* SYM-PROPOSITIONS-NOT ALWAYSCLAUSE NIL)
          NIL)
         NIL)))))
    (CL:T (CL:RETURN-FROM CANONICALIZE-NEGATION-TREE TREE)))
   (FREE-CONS-LIST TREE)
   (CL:RETURN-FROM
    CANONICALIZE-NEGATION-TREE
    (CANONICALIZE-PROPOSITION-TREE ARGUMENT)))
  :VOID)

;;; (DEFUN (QUANTIFIER-SYMBOL? BOOLEAN) ...)

(CL:DEFUN QUANTIFIER-SYMBOL? (SELF)
  (CL:RETURN-FROM
   QUANTIFIER-SYMBOL?
   (CL:IF
    (CL:OR
     (CL:EQ SELF SYM-PROPOSITIONS-EXISTS)
     (CL:EQ SELF SYM-PROPOSITIONS-FORALL)
     (CL:EQ SELF SYM-PROPOSITIONS-SETOFALL)
     (CL:EQ SELF SYM-PROPOSITIONS-THE-ONLY)
     (CL:EQ SELF SYM-PROPOSITIONS-KAPPA)
     (CL:EQ SELF SYM-PROPOSITIONS-SOME))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (CANONICALIZE-QUANTIFICATION-TREE CONS) ...)

(CL:DEFUN CANONICALIZE-QUANTIFICATION-TREE (TREE)
  (CL:LET*
   ((WHERECLAUSE (EXTRACT-WHERE-CLAUSE TREE))
    (ALWAYSCLAUSE (EXTRACT-ALWAYS-CLAUSE TREE)))
   (CL:WHEN
    (CL:NOT (CL:EQ WHERECLAUSE NULL))
    (CL:SETF
     (CLSYS-SVAL CONS REST (LAST-CONS TREE))
     (CONS
      (LIST*
       SYM-PROPOSITIONS-WHERE
       (CANONICALIZE-PROPOSITION-TREE WHERECLAUSE)
       NIL)
      NIL)))
   (CL:WHEN
    (CL:NOT (CL:EQ ALWAYSCLAUSE NULL))
    (CL:SETF
     (CLSYS-SVAL CONS REST (LAST-CONS TREE))
     (CONS
      (LIST*
       SYM-PROPOSITIONS-ALWAYS
       (CANONICALIZE-PROPOSITION-TREE ALWAYSCLAUSE)
       NIL)
      NIL)))
   (CL:RETURN-FROM CANONICALIZE-QUANTIFICATION-TREE TREE))
  :VOID)

;;; (DEFUN (CONS.CANONICALIZE-PROPOSITION-TREE OBJECT) ...)

(CL:DEFUN CONS.CANONICALIZE-PROPOSITION-TREE (TREE)
  (CL:LET*
   ((OPERATOR (CAST (FIRST TREE) SGT-PROPOSITIONS-SYMBOL)))
   (CL:WHEN
    (CL:EQ (QUANTIFIER-SYMBOL? OPERATOR) 1)
    (CL:RETURN-FROM
     CONS.CANONICALIZE-PROPOSITION-TREE
     (CANONICALIZE-QUANTIFICATION-TREE TREE)))
   (CL:LET*
    ((IT (ALLOCATE-ITERATOR (CLSYS-SVAL CONS REST TREE))))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? IT) 1)
     DO
     (VALUE-SETTER
      IT
      (CANONICALIZE-PROPOSITION-TREE (CLSYS-SVAL CONS-ITERATOR VALUE IT)))))
   (CL:COND
    ((CL:OR
      (CL:EQ OPERATOR SYM-PROPOSITIONS-AND)
      (CL:EQ OPERATOR SYM-PROPOSITIONS-OR))
     (CL:RETURN-FROM
      CONS.CANONICALIZE-PROPOSITION-TREE
      (CANONICALIZE-AND-OR-TREE TREE)))
    ((CL:EQ OPERATOR SYM-PROPOSITIONS-NOT)
     (CL:LET*
      ((ARG (SECOND TREE)))
      (CL:WHEN
       (CL:EQ (CONS? ARG) 1)
       (CL:RETURN-FROM
        CONS.CANONICALIZE-PROPOSITION-TREE
        (CANONICALIZE-NEGATION-TREE TREE)))
      (CL:LET*
       ((TEST-VALUE-001 (CAST ARG SGT-PROPOSITIONS-SURROGATE)))
       (CL:COND
        ((CL:EQ TEST-VALUE-001 SGT-PROPOSITIONS-TRUE)
         (FREE-CONS-TREE TREE)
         (CL:RETURN-FROM
          CONS.CANONICALIZE-PROPOSITION-TREE
          SGT-PROPOSITIONS-FALSE))
        ((CL:EQ TEST-VALUE-001 SGT-PROPOSITIONS-FALSE)
         (FREE-CONS-TREE TREE)
         (CL:RETURN-FROM
          CONS.CANONICALIZE-PROPOSITION-TREE
          SGT-PROPOSITIONS-TRUE))
        (CL:T (CL:RETURN-FROM CONS.CANONICALIZE-PROPOSITION-TREE TREE))))))
    (CL:T NULL))
   (CL:RETURN-FROM CONS.CANONICALIZE-PROPOSITION-TREE TREE))
  :VOID)

;;; (DEFUN (CANONICALIZE-PROPOSITION-TREE OBJECT) ...)

(CL:DEFUN CANONICALIZE-PROPOSITION-TREE (TREE)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:RETURN-FROM
       CANONICALIZE-PROPOSITION-TREE
       (CONS.CANONICALIZE-PROPOSITION-TREE TREE))))
    (CL:T (CL:RETURN-FROM CANONICALIZE-PROPOSITION-TREE TREE))))
  :VOID)

;;; (DEFUN (UPDATE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN UPDATE-PROPOSITION (TREE UPDATEMODE)
  (CL:PROGN
   (CL:LET*
    ((*PENDINGEXCEPTIONHANDLER?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PENDINGEXCEPTIONHANDLER?*))
    (CL:CATCH
     *EXCEPTIONHANDLERADDRESS*
     (CL:PROGN
      (CL:LET*
       ((TREE-001 TREE))
       (CL:COND
        ((CL:EQ (STRING? TREE) 1)
         (CL:LET*
          ((TREE NULL))
          (CL:SETQ TREE TREE-001)
          (CL:RETURN-FROM
           UPDATE-PROPOSITION
           (UPDATE-PROPOSITION
            (UNSTRINGIFY (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE TREE))
            UPDATEMODE))))
        (CL:T
         (CL:LET*
          ((STANDARDIZEDTREE NULL) (PROPOSITION NULL))
          (CL:SETQ STANDARDIZEDTREE (STANDARDIZE-LOGICAL-PARSE-TREE TREE))
          (CL:WHEN
           (CL:EQ (CONS? TREE) 1)
           (CL:LET*
            ((*TRANSIENTOBJECTS?* TRUE))
            (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
            (CL:SETQ STANDARDIZEDTREE (CANONICALIZE-PROPOSITION-TREE TREE))))
          (CL:SETQ
           PROPOSITION
           (HELP-UPDATE-PROPOSITION STANDARDIZEDTREE UPDATEMODE))
          (FREE-CONS-TREE STANDARDIZEDTREE)
          (CL:RETURN-FROM UPDATE-PROPOSITION PROPOSITION)))))
      (CL:SETQ *EXCEPTION* NULL))))
   (CL:WHEN
    (CL:NOT (CL:EQ *EXCEPTION* NULL))
    (CL:COND
     ((CL:EQ
       (SUBTYPE-OF? *EXCEPTION-TYPE* SGT-PROPOSITIONS-LOGIC-EXCEPTION)
       1)
      (CL:LET*
       ((E (CAST *EXCEPTION* SGT-PROPOSITIONS-LOGIC-EXCEPTION)))
       (CL:WHEN
        (CL:AND
         (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
         (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-PROPOSITIONS-EXCEPTIONS) 1))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING "update-proposition: Caught " %%STREAM)
         (PRINT-OBJECT (PRIMARY-TYPE E) %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)))))
     ((CL:EQ (SUBTYPE-OF? *EXCEPTION-TYPE* SGT-PROPOSITIONS-READ-EXCEPTION) 1)
      (CL:WHEN
       (CL:AND
        (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
        (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-PROPOSITIONS-EXCEPTIONS) 1))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING "update-proposition: Caught READ-EXCEPTION" %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))))
     ((CL:EQ TRUE 1)
      (CL:LET*
       ((E *EXCEPTION*))
       (CL:WARN "update-proposition: Caught `~A'~%" (PRIMARY-TYPE E)))))))
  :VOID)

;;; (DEFUN (HELP-UPDATE-PROPOSITION PROPOSITION) ...)

(CL:DEFUN HELP-UPDATE-PROPOSITION (TREE UPDATEMODE)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:LET*
       ((TEST-VALUE-001 (FIRST TREE)))
       (CL:COND
        ((CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-NOT)
         (CL:IF
          (CL:EQ (DESCRIPTIVE-UPDATE? UPDATEMODE) 1)
          (CL:RETURN-FROM
           HELP-UPDATE-PROPOSITION
           (BUILD-TOP-LEVEL-PROPOSITION TREE UPDATEMODE))
          (CL:PROGN
           (CL:COND
            ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
             (HELP-UPDATE-PROPOSITION
              (SECOND TREE)
              KWD-PROPOSITIONS-ASSERT-FALSE))
            ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-FALSE)
             (HELP-UPDATE-PROPOSITION
              (SECOND TREE)
              KWD-PROPOSITIONS-ASSERT-TRUE))
            ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE)
             (HELP-UPDATE-PROPOSITION
              (SECOND TREE)
              KWD-PROPOSITIONS-RETRACT-FALSE))
            ((CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-FALSE)
             (HELP-UPDATE-PROPOSITION
              (SECOND TREE)
              KWD-PROPOSITIONS-RETRACT-TRUE))
            (CL:T (CL:ERROR "`~A' is not a valid case option" UPDATEMODE)))
           (CL:RETURN-FROM HELP-UPDATE-PROPOSITION NULL))))
        ((CL:EQ TEST-VALUE-001 SYM-PROPOSITIONS-AND)
         (CL:COND
          ((CL:OR
            (CL:EQ UPDATEMODE KWD-PROPOSITIONS-ASSERT-TRUE)
            (CL:EQ UPDATEMODE KWD-PROPOSITIONS-RETRACT-TRUE))
           (CL:LET*
            ((SUBTREE NULL) (ITER-001 (CLSYS-SVAL CONS REST TREE)))
            (CL:LOOP
             WHILE
             (CL:NOT (CL:EQ ITER-001 NIL))
             DO
             (CL:PROGN
              (CL:SETQ SUBTREE (CLSYS-SVAL CONS VALUE ITER-001))
              (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
             (HELP-UPDATE-PROPOSITION SUBTREE UPDATEMODE)))
           (CL:RETURN-FROM HELP-UPDATE-PROPOSITION NULL))
          (CL:T
           (CL:RETURN-FROM
            HELP-UPDATE-PROPOSITION
            (BUILD-TOP-LEVEL-PROPOSITION TREE UPDATEMODE)))))
        (CL:T
         (CL:RETURN-FROM
          HELP-UPDATE-PROPOSITION
          (BUILD-TOP-LEVEL-PROPOSITION TREE UPDATEMODE)))))))
    (CL:T
     (CL:RETURN-FROM
      HELP-UPDATE-PROPOSITION
      (BUILD-TOP-LEVEL-PROPOSITION TREE UPDATEMODE)))))
  :VOID)

;;; (DEFUN (SMART-UPDATE-PROPOSITION OBJECT) ...)

(CL:DEFUN SMART-UPDATE-PROPOSITION (TREE UPDATEMODE)
  (CL:LET*
   ((*TOPLEVELPROPOSITIONS* NIL))
   (CL:DECLARE (CL:SPECIAL *TOPLEVELPROPOSITIONS*))
   (CL:LET*
    ((PROPOSITION (UPDATE-PROPOSITION TREE UPDATEMODE)))
    (CL:WHEN
     (CL:NOT (CL:EQ PROPOSITION NULL))
     (FREE-CONS-LIST *TOPLEVELPROPOSITIONS*)
     (CL:RETURN-FROM SMART-UPDATE-PROPOSITION PROPOSITION))
    (CL:CASE
     (LENGTH *TOPLEVELPROPOSITIONS*)
     (0 (CL:RETURN-FROM SMART-UPDATE-PROPOSITION NULL))
     (1
      (CL:SETQ PROPOSITION (FIRST *TOPLEVELPROPOSITIONS*))
      (FREE-CONS-LIST *TOPLEVELPROPOSITIONS*)
      (CL:RETURN-FROM SMART-UPDATE-PROPOSITION PROPOSITION))
     (CL:OTHERWISE
      (CL:RETURN-FROM SMART-UPDATE-PROPOSITION *TOPLEVELPROPOSITIONS*)))))
  :VOID)

;;; (DEFUN (ASSERT OBJECT) ...)

(CL:DEFUN %%ASSERT (PROPOSITION)
  "Assert the truth of `proposition'.  Return the asserted proposition object.
KIF example:  `(assert (happy Fred))' asserts that Fred is indeed happy.
Note, that for this assertion to succeed, the logic constant `Fred' must
already be defined, e.g., as a side-effect of a type assertion such as
`(assert (Person Fred))', and the relation (or slot) `happy' must be defined
on objects of `Fred's type, e.g., on the class `Person'."
  (CL:RETURN-FROM
   %%ASSERT
   (SMART-UPDATE-PROPOSITION PROPOSITION KWD-PROPOSITIONS-ASSERT-TRUE))
  :VOID)

(CL:DEFMACRO ASSERT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Assert the truth of `proposition'.  Return the asserted proposition object.
KIF example:  `(assert (happy Fred))' asserts that Fred is indeed happy.
Note, that for this assertion to succeed, the logic constant `Fred' must
already be defined, e.g., as a side-effect of a type assertion such as
`(assert (Person Fred))', and the relation (or slot) `happy' must be defined
on objects of `Fred's type, e.g., on the class `Person'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/ASSERT)) (CL:MACRO-FUNCTION (CL:QUOTE ASSERT)))

;;; (DEFUN (RETRACT PROPOSITION) ...)

(CL:DEFUN %%RETRACT (PROPOSITION)
  "Retract the truth of `proposition'.  Return the retracted proposition
object.  KIF example:  `(retract (happy Fred))' retracts that Fred is
happy.  Note, that for this to succeed, the logic constant `Fred' and the
relation (or slot) `happy' must already be defined (see `assert')."
  (CL:RETURN-FROM
   %%RETRACT
   (CAST
    (SMART-UPDATE-PROPOSITION PROPOSITION KWD-PROPOSITIONS-RETRACT-TRUE)
    SGT-PROPOSITIONS-PROPOSITION))
  :VOID)

(CL:DEFMACRO RETRACT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Retract the truth of `proposition'.  Return the retracted proposition
object.  KIF example:  `(retract (happy Fred))' retracts that Fred is
happy.  Note, that for this to succeed, the logic constant `Fred' and the
relation (or slot) `happy' must already be defined (see `assert')."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/RETRACT)) (CL:MACRO-FUNCTION (CL:QUOTE RETRACT)))

;;; (DEFUN (DENY PROPOSITION) ...)

(CL:DEFUN %%DENY (PROPOSITION)
  "Assert the falsity of `proposition'.  Return the asserted proposition
object.  KIF example:  `(deny (happy Fred))' asserts that Fred is not happy,
which could have been done equivalently by `(assert (not (happy Fred)))'.
Note, that for this to succeed, the logic constant `Fred' and the
relation (or slot) `happy' must already be defined (see `assert')."
  (CL:RETURN-FROM
   %%DENY
   (CAST
    (SMART-UPDATE-PROPOSITION PROPOSITION KWD-PROPOSITIONS-ASSERT-FALSE)
    SGT-PROPOSITIONS-PROPOSITION))
  :VOID)

(CL:DEFMACRO DENY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Assert the falsity of `proposition'.  Return the asserted proposition
object.  KIF example:  `(deny (happy Fred))' asserts that Fred is not happy,
which could have been done equivalently by `(assert (not (happy Fred)))'.
Note, that for this to succeed, the logic constant `Fred' and the
relation (or slot) `happy' must already be defined (see `assert')."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/DENY)) (CL:MACRO-FUNCTION (CL:QUOTE DENY)))

;;; (DEFUN (CONCEIVE PROPOSITION) ...)

(CL:DEFUN %%CONCEIVE (PROPOSITION)
  "Build `proposition' without asserting its truth value.  Return the
conceived proposition object.  KIF example: `(conceive (happy Fred))' builds
the proposition expressing that Fred is happy without explictly asserting or
denying it.  Note, that for this to succeed, the logic constant `Fred' and
the relation (or slot) `happy' must already be defined (see `assert')."
  (CL:RETURN-FROM
   %%CONCEIVE
   (CAST
    (SMART-UPDATE-PROPOSITION PROPOSITION KWD-PROPOSITIONS-CONCEIVE)
    SGT-PROPOSITIONS-PROPOSITION))
  :VOID)

(CL:DEFMACRO CONCEIVE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Build `proposition' without asserting its truth value.  Return the
conceived proposition object.  KIF example: `(conceive (happy Fred))' builds
the proposition expressing that Fred is happy without explictly asserting or
denying it.  Note, that for this to succeed, the logic constant `Fred' and
the relation (or slot) `happy' must already be defined (see `assert')."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/CONCEIVE)) (CL:MACRO-FUNCTION (CL:QUOTE CONCEIVE)))

;;; (DEFUN UNASSERT ...)

(CL:DEFUN %%UNASSERT (PROPOSITION)
  "Retract the truth or falsity of `proposition'.  This is a more general
version of `retract' that also handles falsity."
  (UNASSERT-FACT (UPDATE-PROPOSITION PROPOSITION KWD-PROPOSITIONS-CONCEIVE))
  :VOID)

(CL:DEFMACRO UNASSERT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Retract the truth or falsity of `proposition'.  This is a more general
version of `retract' that also handles falsity."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/UNASSERT)) (CL:MACRO-FUNCTION (CL:QUOTE UNASSERT)))

;;; (DEFUN UNASSERT-FACT ...)

(CL:DEFUN UNASSERT-FACT (SELF)
  "Retract the truth or falsity of the proposition 'self'"
  (CL:WHEN
   (CL:NOT (CL:EQ SELF NULL))
   (CL:COND
    ((CL:EQ (CLSYS-SVAL PROPOSITION KIND SELF) KWD-PROPOSITIONS-FUNCTION)
     (CL:LET*
      ((OUTPUTSKOLEM (CAST (LAST-ARGUMENT SELF) SGT-PROPOSITIONS-SKOLEM)))
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (ACCESS-IN-CONTEXT
          (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OUTPUTSKOLEM)
          OUTPUTSKOLEM
          FALSE)
         NULL))
       (UNEQUATE-VALUES?
        OUTPUTSKOLEM
        (ACCESS-IN-CONTEXT
         (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OUTPUTSKOLEM)
         OUTPUTSKOLEM
         FALSE)))))
    ((CL:EQ (TRUE? SELF) 1)
     (DEASSIGN-TRUTH-VALUE SELF KWD-PROPOSITIONS-RETRACT-TRUE))
    ((CL:EQ (FALSE? SELF) 1)
     (DEASSIGN-TRUTH-VALUE SELF KWD-PROPOSITIONS-RETRACT-FALSE))))
  :VOID)

;;; (DEFMETHOD (DELETED? BOOLEAN) ...)

(CL:DEFMETHOD DELETED? ((SELF LOGIC-OBJECT))
  (CL:LET*
   ((DELETED?
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-PROPOSITIONS-DELETED-OBJECT?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (DEFINED? DELETED?) 1)
    (CL:RETURN-FROM DELETED? DELETED?)
    (CL:RETURN-FROM DELETED? FALSE)))
  :VOID)

;;; (DEFMETHOD (DELETED?-SETTER BOOLEAN) ...)

(CL:DEFMETHOD DELETED?-SETTER ((SELF LOGIC-OBJECT) VALUE)
  (SET-DYNAMIC-SLOT-VALUE
   SELF
   SYM-PROPOSITIONS-DELETED-OBJECT?
   (WRAP-BOOLEAN VALUE)
   NULL-BOOLEAN-WRAPPER)
  (CL:RETURN-FROM DELETED?-SETTER VALUE)
  :VOID)

;;; (DEFMETHOD (DELETED? BOOLEAN) ...)

(CL:DEFMETHOD DELETED? ((SELF PROPOSITION))
  (CL:RETURN-FROM
   DELETED?
   (EQ? (CLSYS-SVAL PROPOSITION KIND SELF) KWD-PROPOSITIONS-DELETED))
  :VOID)

;;; (DEFMETHOD (DELETED?-SETTER BOOLEAN) ...)

(CL:DEFMETHOD DELETED?-SETTER ((SELF PROPOSITION) VALUE)
  (CL:WHEN
   (CL:EQ VALUE 1)
   (CL:SETF (CLSYS-SVAL PROPOSITION KIND SELF) KWD-PROPOSITIONS-DELETED))
  (CL:RETURN-FROM DELETED?-SETTER VALUE)
  :VOID)

;;; (DEFUN DESTROY-PROPOSITION ...)

(CL:DEFUN DESTROY-PROPOSITION (PROPOSITION)
  "Retract and destroy the proposition 'proposition'.
Recursively destroy all propositions that reference 'proposition'."
  (CL:WHEN
   (CL:EQ (DELETED? PROPOSITION) 1)
   (CL:RETURN-FROM DESTROY-PROPOSITION))
  (DELETED?-SETTER PROPOSITION TRUE)
  (CL:LET*
   ((ARG NULL)
    (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
    (INDEX-001 0)
    (LENGTH-001 (LENGTH VECTOR-001)))
   (CL:LOOP
    WHILE
    (CL:< INDEX-001 LENGTH-001)
    DO
    (CL:PROGN
     (CL:SETQ
      ARG
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
    (CL:WHEN
     (CL:NOT (CL:EQ ARG NULL))
     (REMOVE-DEPENDENT-PROPOSITION-LINK ARG PROPOSITION))))
  (CL:LET*
   ((DEP NULL)
    (ITER-001
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL PROPOSITION DEPENDENT-PROPOSITIONS PROPOSITION))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      DEP
      (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-PROPOSITIONS-PROPOSITION))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (DESTROY-PROPOSITION DEP)))
  "NOT YET IMPLEMENTED"
  :VOID)

;;; (DEFUN DESTROY-INSTANCE ...)

(CL:DEFUN DESTROY-INSTANCE (OBJECT)
  "Destroy all propositions that reference 'object',
and mark it as 'deleted?', thereby making it invisible within class
extensions."
  (CL:WHEN
   (CL:OR (CL:EQ OBJECT NULL) (CL:EQ (DELETED? OBJECT) 1))
   (CL:RETURN-FROM DESTROY-INSTANCE))
  (DELETED?-SETTER OBJECT TRUE)
  (CL:LET*
   ((P NULL)
    (ITER-001
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (COPY
       (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-ATTRIBUTE-PROPOSITIONS OBJECT)))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      P
      (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-PROPOSITIONS-PROPOSITION))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (DESTROY-PROPOSITION P)))
  (CL:LET*
   ((P NULL)
    (ITER-002
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (COPY (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS OBJECT)))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-002 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      P
      (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-PROPOSITIONS-PROPOSITION))
     (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
    (DESTROY-PROPOSITION P)))
  (CL:LET*
   ((EQUIVALENT NULL) (ITER-003 (VARIABLE-VALUE-INVERSE OBJECT)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-003 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      EQUIVALENT
      (CAST (CLSYS-SVAL CONS VALUE ITER-003) SGT-PROPOSITIONS-LOGIC-OBJECT))
     (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
    (CL:LET*
     ((OBJECT-001 EQUIVALENT)
      (VALUE-001 NULL)
      (OLD-VALUE-001 (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OBJECT-001))
      (NEW-VALUE-001
       (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001 OBJECT-001 FALSE)))
     (CL:WHEN
      (CL:EQ (CS-VALUE? OLD-VALUE-001) 0)
      (CL:SETF
       (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OBJECT-001)
       NEW-VALUE-001)))))
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE OBJECT SYM-PROPOSITIONS-SURROGATE-VALUE-INVERSE NULL)
     NULL))
   (CL:SETF
    (CLSYS-SVAL
     SURROGATE
     SURROGATE-VALUE
     (DYNAMIC-SLOT-VALUE
      OBJECT
      SYM-PROPOSITIONS-SURROGATE-VALUE-INVERSE
      NULL))
    NULL))
  :VOID)

;;; (DEFUN DESTROY-TERM ...)

(CL:DEFUN DESTROY-TERM (OBJECT)
  "Destroy all propositions that reference 'object',
and mark it as 'deleted?', thereby making it invisible within class
extensions.  Unlink descriptions from native relations."
  (DESTROY-INSTANCE OBJECT)
  (CL:LET*
   ((OBJECT-001 OBJECT))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? OBJECT SGT-PROPOSITIONS-DESCRIPTION) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:LET*
       ((NATIVERELATION (CLSYS-SVAL DESCRIPTION NATIVE-RELATION OBJECT)))
       (CL:WHEN
        (CL:NOT (CL:EQ NATIVERELATION NULL))
        (SET-DYNAMIC-SLOT-VALUE
         NATIVERELATION
         SYM-PROPOSITIONS-DESCRIPTION
         NULL
         NULL)
        (SET-DYNAMIC-SLOT-VALUE
         NATIVERELATION
         SYM-PROPOSITIONS-DEFINITION
         NULL
         NULL)
        (REMOVE-DELETED-MEMBERS
         (RELATION-ORIGINATED-PROPOSITIONS NATIVERELATION))))))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN CLEAR-LOGIC-MODULE-HOOK ...)

(CL:DEFUN CLEAR-LOGIC-MODULE-HOOK (MODULE)
  (CL:LET*
   ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:LET*
    ((CACHE
      (DYNAMIC-SLOT-VALUE
       MODULE
       SYM-PROPOSITIONS-STRICT-INFERENCE-CACHE
       NULL)))
    (CL:WHEN
     (CL:NOT (CL:EQ CACHE NULL))
     (DESTROY-INFERENCE-CACHE CACHE)
     (SET-DYNAMIC-SLOT-VALUE
      MODULE
      SYM-PROPOSITIONS-STRICT-INFERENCE-CACHE
      NULL
      NULL)))
   (CL:LET*
    ((TERM NULL) (ITER-001 (ALL-TERMS MODULE TRUE)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN
      (CL:SETQ
       TERM
       (CAST
        (CLSYS-SVAL ITERATOR VALUE ITER-001)
        SGT-PROPOSITIONS-LOGIC-OBJECT)))
     (DESTROY-TERM TERM)))
   (CL:LET*
    ((PROPOSITION NULL) (ITER-002 (ALL-PROPOSITIONS MODULE TRUE)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-002) 1)
     DO
     (CL:PROGN
      (CL:SETQ
       PROPOSITION
       (CAST
        (CLSYS-SVAL ITERATOR VALUE ITER-002)
        SGT-PROPOSITIONS-PROPOSITION)))
     (DESTROY-PROPOSITION PROPOSITION)))
   (REMOVE-DELETED-MEMBERS (LOCALLY-CONCEIVED-PROPOSITIONS-GETTER MODULE)))
  :VOID)

;;; (DEFUN CLEAR-INSTANCES ...)

(CL:DEFUN %%CLEAR-INSTANCES (NAME)
  "Destroy all instances belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user."
  (CL:LET*
   ((MODULE (COERCE-TO-MODULE (FIRST NAME) TRUE)))
   (CL:WHEN
    (CL:NOT (CL:EQ MODULE NULL))
    (CL:WHEN
     (CL:OR
      (CL:NOT (CL:EQ NAME NIL))
      (CL:EQ
       (Y-OR-N?
        (CONCATENATE
         "Really clear instances of module "
         (CONCATENATE (CLSYS-SVAL MODULE MODULE-FULL-NAME MODULE) "? ")))
       1))
     (DO-CLEAR-INSTANCES MODULE))))
  :VOID)

(CL:DEFUN CLEAR-INSTANCES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%%CLEAR-INSTANCES ARGUMENTS)
  :VOID)

(CL:DEFMACRO CLEAR-INSTANCES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Destroy all instances belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/CLEAR-INSTANCES)) (CL:MACRO-FUNCTION (CL:QUOTE CLEAR-INSTANCES)))

;;; (DEFUN DO-CLEAR-INSTANCES ...)

(CL:DEFUN DO-CLEAR-INSTANCES (MODULE)
  "Function version of `clear-instances' that evaluates its argument."
  (CL:LET*
   ((CHILD NULL)
    (ITER-001
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL MODULE CHILD-CONTEXTS MODULE))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      CHILD
      (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-PROPOSITIONS-CONTEXT))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:EQ (ISA? CHILD SGT-PROPOSITIONS-MODULE) 1)
     (DO-CLEAR-INSTANCES (CAST CHILD SGT-PROPOSITIONS-MODULE)))))
  (CL:LET*
   ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:LET*
    ((CACHE
      (DYNAMIC-SLOT-VALUE
       MODULE
       SYM-PROPOSITIONS-STRICT-INFERENCE-CACHE
       NULL)))
    (CL:WHEN
     (CL:NOT (CL:EQ CACHE NULL))
     (DESTROY-INFERENCE-CACHE CACHE)
     (SET-DYNAMIC-SLOT-VALUE
      MODULE
      SYM-PROPOSITIONS-STRICT-INFERENCE-CACHE
      NULL
      NULL)))
   (CL:LET*
    ((INSTANCE NULL) (ITER-002 (ALL-INSTANCES MODULE TRUE)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-002) 1)
     DO
     (CL:PROGN
      (CL:SETQ
       INSTANCE
       (CAST
        (CLSYS-SVAL ITERATOR VALUE ITER-002)
        SGT-PROPOSITIONS-LOGIC-OBJECT)))
     (DESTROY-INSTANCE INSTANCE)))
   (REMOVE-DELETED-MEMBERS (LOCALLY-CONCEIVED-PROPOSITIONS-GETTER MODULE)))
  :VOID)

;;; (DEFUN HELP-TRANSFER-PROPOSITION-ARGUMENTS ...)

(CL:DEFUN HELP-TRANSFER-PROPOSITION-ARGUMENTS (PROPOSITION FROMOBJECT TOOBJECT)
  (CL:LET*
   ((I NULL)
    (ARG NULL)
    (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
    (INDEX-001 0)
    (LENGTH-001 (LENGTH VECTOR-001))
    (ITER-001 0))
   (CL:LOOP
    WHILE
    (CL:< INDEX-001 LENGTH-001)
    DO
    (CL:PROGN
     (CL:SETQ
      ARG
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
    (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
    (CL:WHEN
     (CL:EQ ARG FROMOBJECT)
     (CL:SETF
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
       I)
      TOOBJECT))))
  :VOID)

;;; (DEFUN TRANSFER-PROPOSITIONS-TO-LOGIC-OBJECT ...)

(CL:DEFUN TRANSFER-PROPOSITIONS-TO-LOGIC-OBJECT (FROMOBJECT TOOBJECT)
  (CL:LET*
   ((P NULL)
    (ITER-001
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS FROMOBJECT))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      P
      (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-PROPOSITIONS-PROPOSITION))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (HELP-TRANSFER-PROPOSITION-ARGUMENTS P FROMOBJECT TOOBJECT)
    (INSERT-NEW (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS TOOBJECT) P)))
  (CL:LET*
   ((P NULL)
    (ITER-002
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-ATTRIBUTE-PROPOSITIONS FROMOBJECT))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-002 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      P
      (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-PROPOSITIONS-PROPOSITION))
     (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
    (HELP-TRANSFER-PROPOSITION-ARGUMENTS P FROMOBJECT TOOBJECT)
    (INSERT-NEW
     (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-ATTRIBUTE-PROPOSITIONS TOOBJECT)
     P)))
  (CLEAR (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS FROMOBJECT))
  (CLEAR (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-ATTRIBUTE-PROPOSITIONS FROMOBJECT))
  :VOID)

(CL:DEFMETHOD TOTAL? ((SELF SLOT))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-PROPOSITIONS-TOTAL?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM TOTAL? FALSE)
    (CL:RETURN-FROM TOTAL? ANSWER)))
  :VOID)

(CL:DEFMETHOD INDEX-ON-VALUES? ((SELF SLOT))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-PROPOSITIONS-INDEX-ON-VALUES?
       NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM INDEX-ON-VALUES? FALSE)
    (CL:RETURN-FROM INDEX-ON-VALUES? ANSWER)))
  :VOID)

;;; (DEFMETHOD (NUMBER-VALUE FLOAT) ...)

(CL:DEFMETHOD NUMBER-VALUE ((WRAPPEDNUMBER NUMBER-WRAPPER))
  (CL:LET*
   ((RESULT NULL-FLOAT))
   (CL:LET*
    ((WRAPPEDNUMBER-001 WRAPPEDNUMBER))
    (CL:COND
     ((CL:EQ (INTEGER? WRAPPEDNUMBER) 1)
      (CL:LET*
       ((WRAPPEDNUMBER NULL))
       (CL:SETQ WRAPPEDNUMBER WRAPPEDNUMBER-001)
       (CL:SETQ
        RESULT
        (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE WRAPPEDNUMBER))))
     ((CL:EQ (FLOAT? WRAPPEDNUMBER) 1)
      (CL:LET*
       ((WRAPPEDNUMBER NULL))
       (CL:SETQ WRAPPEDNUMBER WRAPPEDNUMBER-001)
       (CL:SETQ
        RESULT
        (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE WRAPPEDNUMBER))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" WRAPPEDNUMBER))))
   (CL:RETURN-FROM NUMBER-VALUE RESULT))
  :VOID)

;;; (DEFMETHOD (GREATER-THAN? BOOLEAN-WRAPPER) ...)

(CL:DEFMETHOD GREATER-THAN? ((X NUMBER-WRAPPER) Y)
  (CL:RETURN-FROM
   GREATER-THAN?
   (WRAP-BOOLEAN (> (NUMBER-VALUE X) (NUMBER-VALUE Y))))
  :VOID)

;;; (DEFMETHOD (GREATER-OR-EQUAL? BOOLEAN-WRAPPER) ...)

(CL:DEFMETHOD GREATER-OR-EQUAL? ((X NUMBER-WRAPPER) Y)
  (CL:RETURN-FROM
   GREATER-OR-EQUAL?
   (WRAP-BOOLEAN (>= (NUMBER-VALUE X) (NUMBER-VALUE Y))))
  :VOID)

;;; (DEFMETHOD (LESS-THAN? BOOLEAN-WRAPPER) ...)

(CL:DEFMETHOD LESS-THAN? ((X NUMBER-WRAPPER) Y)
  (CL:RETURN-FROM
   LESS-THAN?
   (WRAP-BOOLEAN (< (NUMBER-VALUE X) (NUMBER-VALUE Y))))
  :VOID)

;;; (DEFMETHOD (LESS-OR-EQUAL? BOOLEAN-WRAPPER) ...)

(CL:DEFMETHOD LESS-OR-EQUAL? ((X NUMBER-WRAPPER) Y)
  (CL:RETURN-FROM
   LESS-OR-EQUAL?
   (WRAP-BOOLEAN (<= (NUMBER-VALUE X) (NUMBER-VALUE Y))))
  :VOID)

;;; (DEFMETHOD (PLUS NUMBER-WRAPPER) ...)

(CL:DEFMETHOD PLUS ((X NUMBER-WRAPPER) Y)
  (CL:LET*
   ((FLOATRESULT NULL-FLOAT))
   (CL:LET*
    ((X-001 X))
    (CL:COND
     ((CL:EQ (INTEGER? X) 1)
      (CL:LET*
       ((X NULL))
       (CL:SETQ X X-001)
       (CL:LET*
        ((Y-001 Y))
        (CL:COND
         ((CL:EQ (INTEGER? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-001)
           (CL:RETURN-FROM
            PLUS
            (WRAP-LITERAL
             (CL:+
              (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE X)
              (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE Y))))))
         ((CL:EQ (FLOAT? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-001)
           (CL:SETQ
            FLOATRESULT
            (CL:+
             (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE X)
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE Y)))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" Y))))))
     ((CL:EQ (FLOAT? X) 1)
      (CL:LET*
       ((X NULL))
       (CL:SETQ X X-001)
       (CL:LET*
        ((Y-002 Y))
        (CL:COND
         ((CL:EQ (INTEGER? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-002)
           (CL:SETQ
            FLOATRESULT
            (CL:+
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE X)
             (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE Y)))))
         ((CL:EQ (FLOAT? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-002)
           (CL:SETQ
            FLOATRESULT
            (CL:+
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE X)
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE Y)))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" Y))))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" X))))
   (CL:RETURN-FROM PLUS (WRAP-LITERAL FLOATRESULT)))
  :VOID)

;;; (DEFMETHOD (MINUS NUMBER-WRAPPER) ...)

(CL:DEFMETHOD MINUS ((X NUMBER-WRAPPER) Y)
  (CL:LET*
   ((FLOATRESULT NULL-FLOAT))
   (CL:LET*
    ((X-001 X))
    (CL:COND
     ((CL:EQ (INTEGER? X) 1)
      (CL:LET*
       ((X NULL))
       (CL:SETQ X X-001)
       (CL:LET*
        ((Y-001 Y))
        (CL:COND
         ((CL:EQ (INTEGER? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-001)
           (CL:RETURN-FROM
            MINUS
            (WRAP-LITERAL
             (CL:-
              (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE X)
              (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE Y))))))
         ((CL:EQ (FLOAT? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-001)
           (CL:SETQ
            FLOATRESULT
            (CL:-
             (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE X)
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE Y)))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" Y))))))
     ((CL:EQ (FLOAT? X) 1)
      (CL:LET*
       ((X NULL))
       (CL:SETQ X X-001)
       (CL:LET*
        ((Y-002 Y))
        (CL:COND
         ((CL:EQ (INTEGER? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-002)
           (CL:SETQ
            FLOATRESULT
            (CL:-
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE X)
             (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE Y)))))
         ((CL:EQ (FLOAT? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-002)
           (CL:SETQ
            FLOATRESULT
            (CL:-
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE X)
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE Y)))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" Y))))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" X))))
   (CL:RETURN-FROM MINUS (WRAP-LITERAL FLOATRESULT)))
  :VOID)

;;; (DEFMETHOD (TIMES NUMBER-WRAPPER) ...)

(CL:DEFMETHOD TIMES ((X NUMBER-WRAPPER) Y)
  (CL:LET*
   ((FLOATRESULT NULL-FLOAT))
   (CL:LET*
    ((X-001 X))
    (CL:COND
     ((CL:EQ (INTEGER? X) 1)
      (CL:LET*
       ((X NULL))
       (CL:SETQ X X-001)
       (CL:LET*
        ((Y-001 Y))
        (CL:COND
         ((CL:EQ (INTEGER? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-001)
           (CL:RETURN-FROM
            TIMES
            (WRAP-LITERAL
             (CL:*
              (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE X)
              (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE Y))))))
         ((CL:EQ (FLOAT? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-001)
           (CL:SETQ
            FLOATRESULT
            (CL:*
             (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE X)
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE Y)))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" Y))))))
     ((CL:EQ (FLOAT? X) 1)
      (CL:LET*
       ((X NULL))
       (CL:SETQ X X-001)
       (CL:LET*
        ((Y-002 Y))
        (CL:COND
         ((CL:EQ (INTEGER? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-002)
           (CL:SETQ
            FLOATRESULT
            (CL:*
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE X)
             (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE Y)))))
         ((CL:EQ (FLOAT? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-002)
           (CL:SETQ
            FLOATRESULT
            (CL:*
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE X)
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE Y)))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" Y))))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" X))))
   (CL:RETURN-FROM TIMES (WRAP-LITERAL FLOATRESULT)))
  :VOID)

;;; (DEFMETHOD (DIVIDE NUMBER-WRAPPER) ...)

(CL:DEFMETHOD DIVIDE ((X NUMBER-WRAPPER) Y)
  (CL:LET*
   ((FLOATRESULT NULL-FLOAT))
   (CL:LET*
    ((X-001 X))
    (CL:COND
     ((CL:EQ (INTEGER? X) 1)
      (CL:LET*
       ((X NULL))
       (CL:SETQ X X-001)
       (CL:LET*
        ((Y-001 Y))
        (CL:COND
         ((CL:EQ (INTEGER? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-001)
           (CL:IF
            (CL:=
             (MOD
              (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE X)
              (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE Y))
             0)
            (CL:RETURN-FROM
             DIVIDE
             (WRAP-LITERAL
              (CL:/
               (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE X)
               1.0
               (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE Y))))
            (CL:SETQ
             FLOATRESULT
             (CL:*
              (CL:/
               (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE X)
               1.0
               (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE Y))
              1.0)))))
         ((CL:EQ (FLOAT? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-001)
           (CL:SETQ
            FLOATRESULT
            (CL:/
             (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE X)
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE Y)))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" Y))))))
     ((CL:EQ (FLOAT? X) 1)
      (CL:LET*
       ((X NULL))
       (CL:SETQ X X-001)
       (CL:LET*
        ((Y-002 Y))
        (CL:COND
         ((CL:EQ (INTEGER? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-002)
           (CL:SETQ
            FLOATRESULT
            (CL:/
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE X)
             (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE Y)))))
         ((CL:EQ (FLOAT? Y) 1)
          (CL:LET*
           ((Y NULL))
           (CL:SETQ Y Y-002)
           (CL:SETQ
            FLOATRESULT
            (CL:/
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE X)
             (CLSYS-SVAL FLOAT-WRAPPER WRAPPER-VALUE Y)))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" Y))))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" X))))
   (CL:RETURN-FROM DIVIDE (WRAP-LITERAL FLOATRESULT)))
  :VOID)

(CL:DEFUN STARTUP-PROPOSITIONS ()
  (CL:LET*
   ((*MODULE* (GET-MODULE "/LOGIC" TRUE)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SGT-PROPOSITIONS-THIRTY-TWO-BIT-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "THIRTY-TWO-BIT-VECTOR"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-PROPOSITIONS-ALL-ROOT-TYPES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-ROOT-TYPES" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-ALL-SURROGATE-VALUE-INVERSES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-SURROGATE-VALUE-INVERSES" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-ROOT-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-TYPE" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-DEPENDENT-ATTRIBUTE-PROPOSITIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "DEPENDENT-ATTRIBUTE-PROPOSITIONS"
      NULL
      0))
    (CL:SETQ
     SYM-PROPOSITIONS-DEPENDENT-PROPOSITIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPENDENT-PROPOSITIONS" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-VARIABLE-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-VALUE" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-VARIABLE-VALUE-INVERSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-VALUE-INVERSE" NULL 0))
    (CL:SETQ
     SGT-PROPOSITIONS-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-PROPOSITIONS-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-PROPOSITIONS-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-PROPOSITIONS-LOGIC-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
    (CL:SETQ
     SYM-PROPOSITIONS-SKOLEM-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM-TYPE" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-NOT-BOTTOM?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT-BOTTOM?" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-DEFINING-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINING-PROPOSITION" NULL 0))
    (CL:SETQ
     SGT-PROPOSITIONS-BOOLEAN-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "BOOLEAN-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-PROPOSITIONS-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
    (CL:SETQ
     SGT-PROPOSITIONS-SKOLEM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
    (CL:SETQ
     SYM-PROPOSITIONS-BOUND-TO-OFFSET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOUND-TO-OFFSET" NULL 0))
    (CL:SETQ
     SGT-PROPOSITIONS-INTEGER-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "INTEGER-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-PROPOSITIONS-PATTERN-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
    (CL:SETQ
     SYM-PROPOSITIONS-OBJECT-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-VECTOR" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-ARGUMENTS-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS-VECTOR" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-VARIABLES-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLES-VECTOR" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-EXTENSION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "EXTENSION"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-PROPOSITIONS-IOTA?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IOTA?" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-IO-VARIABLES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-INTERNAL-VARIABLES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERNAL-VARIABLES" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-KIND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KIND" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-NATIVE-RELATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-RELATION" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-QUERY-PATTERNS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-PATTERNS" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-REFERENCED-BY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REFERENCED-BY" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-TAXONOMY-NODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "TAXONOMY-NODE"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SGT-PROPOSITIONS-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-PROPOSITIONS-KEYWORD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-PROPOSITIONS-RELATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "RELATION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-PROPOSITIONS-KEY-VALUE-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "KEY-VALUE-LIST"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-PROPOSITIONS-TAXONOMY-NODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "TAXONOMY-NODE"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-PROPOSITIONS-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
    (CL:SETQ
     SGT-PROPOSITIONS-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-PROPOSITIONS-PARTIAL-MATCH-SCORE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL-MATCH-SCORE" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-SET-OF-SUPPORT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-OF-SUPPORT" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-TIME-STAMP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TIME-STAMP" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-POSITIVE-SCORE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITIVE-SCORE" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-NEGATIVE-SCORE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NEGATIVE-SCORE" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-POSITIVE-SET-OF-SUPPORT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITIVE-SET-OF-SUPPORT" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-NEGATIVE-SET-OF-SUPPORT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NEGATIVE-SET-OF-SUPPORT" NULL 0))
    (CL:SETQ
     SGT-PROPOSITIONS-FLOAT-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "FLOAT-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-PROPOSITIONS-TRUTH-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 1))
    (CL:SETQ
     SYM-PROPOSITIONS-VARIABLE-TYPE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE?" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-SUBRELATION-LINK?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBRELATION-LINK?" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-SUBSUMPTION-LINK?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-LINK?" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-SATELLITE-PROPOSITIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SATELLITE-PROPOSITIONS" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-DONT-OPTIMIZE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-OPTIMIZE?" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-FORWARD-ONLY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-ONLY?" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-BACKWARD-ONLY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD-ONLY?" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-TRUTH-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-ARGUMENTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "ARGUMENTS"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-PROPOSITIONS-OPERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "OPERATOR"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-PROPOSITIONS-SLOTREF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTREF" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SGT-PROPOSITIONS-SLOTREF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTREF" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-PROPOSITIONS-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "FUNCTION"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-PROPOSITIONS-PREDICATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "PREDICATE"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-PROPOSITIONS-CONTEXT-ASSUMED-PROPOSITIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-ASSUMED-PROPOSITIONS" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-MONOTONIC?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MONOTONIC?" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-TRUTH-MAINTAINED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-MAINTAINED?" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-UP-TO-DATE-INFERENCES?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TO-DATE-INFERENCES?" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-LOCALLY-CONCEIVED-PROPOSITIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOCALLY-CONCEIVED-PROPOSITIONS" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-LOCALLY-BOUND-PROPOSITIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOCALLY-BOUND-PROPOSITIONS" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-LOCALLY-BOUND-SKOLEMS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOCALLY-BOUND-SKOLEMS" NULL 0))
    (CL:SETQ
     KWD-PROPOSITIONS-UPDATE-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UPDATE-PROPOSITION" NULL 2))
    (CL:SETQ
     KWD-PROPOSITIONS-EXECUTE-QUERY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXECUTE-QUERY" NULL 2))
    (CL:SETQ
     SYM-PROPOSITIONS-BOTTOM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOTTOM" NULL 0))
    (CL:SETQ
     SGT-PROPOSITIONS-LITERAL-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "LITERAL-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-PROPOSITIONS-LITERAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     KWD-PROPOSITIONS-OPEN-WORLD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-WORLD" NULL 2))
    (CL:SETQ
     KWD-PROPOSITIONS-CLOSED-WORLD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED-WORLD" NULL 2))
    (CL:SETQ
     KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIONAL-ASSERTION" NULL 2))
    (CL:SETQ
     SYM-PROPOSITIONS-*EVALUATIONMODE*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*EVALUATIONMODE*" NULL 0))
    (CL:SETQ
     KWD-PROPOSITIONS-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
    (CL:SETQ
     KWD-PROPOSITIONS-QUERY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY" NULL 2))
    (CL:SETQ
     KWD-PROPOSITIONS-CONCEIVE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEIVE" NULL 2))
    (CL:SETQ
     KWD-PROPOSITIONS-IMPLIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
    (CL:SETQ
     KWD-PROPOSITIONS-RETRACT-TRUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-TRUE" NULL 2))
    (CL:SETQ
     SYM-PROPOSITIONS-MASTER-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
    (CL:SETQ
     KWD-PROPOSITIONS-ASSERT-TRUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
    (CL:SETQ
     KWD-PROPOSITIONS-ASSERT-FALSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-FALSE" NULL 2))
    (CL:SETQ
     KWD-PROPOSITIONS-RETRACT-FALSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-FALSE" NULL 2))
    (CL:SETQ
     SYM-PROPOSITIONS-STRICT-INFERENCE-CACHE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRICT-INFERENCE-CACHE" NULL 0))
    (CL:SETQ
     SGT-PROPOSITIONS-CONTEXT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-PROPOSITIONS-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     KWD-PROPOSITIONS-STRICT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRICT" NULL 2))
    (CL:SETQ
     KWD-PROPOSITIONS-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     KWD-PROPOSITIONS-CONSTANT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 2))
    (CL:SETQ
     SGT-PROPOSITIONS-STANDARD-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "STANDARD-OBJECT"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-PROPOSITIONS-STORAGE-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "STORAGE-SLOT"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-PROPOSITIONS-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
    (CL:SETQ
     KWD-PROPOSITIONS-PRIMITIVE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMITIVE" NULL 2))
    (CL:SETQ
     SYM-PROPOSITIONS-COMPLEMENT-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT-DESCRIPTION" NULL 0))
    (CL:SETQ
     SGT-PROPOSITIONS-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ KWD-PROPOSITIONS-IN (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 2))
    (CL:SETQ
     SGT-PROPOSITIONS-UNKNOWN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-PROPOSITIONS-*FREESKOLEMS*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*FREESKOLEMS*" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-SKOLEM-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM-NAME" NULL 0))
    (CL:SETQ
     SGT-PROPOSITIONS-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "COLLECTION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-PROPOSITIONS-SEQUENCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "SEQUENCE"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-PROPOSITIONS-SURROGATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "SURROGATE"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     KWD-PROPOSITIONS-AND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
    (CL:SETQ KWD-PROPOSITIONS-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
    (CL:SETQ
     SGT-PROPOSITIONS-TRUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-PROPOSITIONS-FALSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-PROPOSITIONS-PERMUTATION-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PERMUTATION-TABLE" NULL 0))
    (CL:SETQ
     KWD-PROPOSITIONS-NOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
    (CL:SETQ
     KWD-PROPOSITIONS-EQUIVALENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
    (CL:SETQ
     KWD-PROPOSITIONS-PREDICATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
    (CL:SETQ
     SGT-PROPOSITIONS-TRAP-DOOR-SURROGATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRAP-DOOR-SURROGATE" NULL 1))
    (CL:SETQ
     SYM-PROPOSITIONS-SETOFALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOFALL" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-THE-ONLY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-ONLY" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-KAPPA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-SETOF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOF" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-PROPOSITIONS-LISTOF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LISTOF" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-CREATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CREATE" NULL 0))
    (CL:SETQ
     KWD-PROPOSITIONS-INTENSIONAL-ASSERTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INTENSIONAL-ASSERTION" NULL 2))
    (CL:SETQ SYM-PROPOSITIONS-? (INTERN-RIGID-SYMBOL-WRT-MODULE "?" NULL 0))
    (CL:SETQ
     KWD-PROPOSITIONS-COMMON-LISP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
    (CL:SETQ
     SYM-PROPOSITIONS-EVALUATOR-WRAPPER-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "EVALUATOR-WRAPPER-CODE"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-PROPOSITIONS-NON-DISJOINTNESS-KLUDGE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NON-DISJOINTNESS-KLUDGE?" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-CLASS-EXTENSION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "CLASS-EXTENSION"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-PROPOSITIONS-TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK"
      NULL
      0))
    (CL:SETQ
     SYM-PROPOSITIONS-IMPLIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-RELATION-ORIGINATED-PROPOSITIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "RELATION-ORIGINATED-PROPOSITIONS"
      NULL
      0))
    (CL:SETQ
     SYM-PROPOSITIONS-ISA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-PROPOSITIONS-SURROGATE-VALUE-INVERSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE-INVERSE" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-*PROPOSITIONUNDERCONSTRUCTION*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*PROPOSITIONUNDERCONSTRUCTION*" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-*TOPLEVELPROPOSITIONS*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*TOPLEVELPROPOSITIONS*" NULL 0))
    (CL:SETQ
     SGT-PROPOSITIONS-STRING-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "STRING-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-PROPOSITIONS-LOGIC-EXCEPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-EXCEPTION" NULL 1))
    (CL:SETQ
     KWD-PROPOSITIONS-EXCEPTIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXCEPTIONS" NULL 2))
    (CL:SETQ
     SGT-PROPOSITIONS-READ-EXCEPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "READ-EXCEPTION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-PROPOSITIONS-CONSTANT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-TRUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-PROPOSITIONS-FALSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SGT-PROPOSITIONS-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-PROPOSITIONS-=
     (INTERN-RIGID-SYMBOL-WRT-MODULE "=" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-PROPOSITIONS-AND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-PROPOSITIONS-OR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-PROPOSITIONS-NOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-PROPOSITIONS-IN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-PROPOSITIONS-SUBSET-OF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET-OF" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-EXISTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-PROPOSITIONS-FORALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     KWD-PROPOSITIONS-EXISTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
    (CL:SETQ
     SYM-PROPOSITIONS-EQUIVALENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 0))
    (CL:SETQ
     SGT-PROPOSITIONS-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "FUNCTION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-PROPOSITIONS-SECOND-ORDER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SECOND-ORDER" NULL 0))
    (CL:SETQ
     SGT-PROPOSITIONS-ANY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-PROPOSITIONS-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     KWD-PROPOSITIONS-FORALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
    (CL:SETQ
     SYM-PROPOSITIONS-ALWAYS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALWAYS" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-PROPOSITIONS-WHERE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WHERE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-PROPOSITIONS-SOME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SOME" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-PROPOSITIONS-ASSERT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-RETRACT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-DENY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DENY" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-CONCEIVE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEIVE" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-UNASSERT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNASSERT" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-DELETED-OBJECT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "DELETED-OBJECT?"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     KWD-PROPOSITIONS-DELETED
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DELETED" NULL 2))
    (CL:SETQ
     SYM-PROPOSITIONS-DEFINITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINITION" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-CLEAR-LOGIC-MODULE-HOOK
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEAR-LOGIC-MODULE-HOOK" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-CLEAR-INSTANCES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEAR-INSTANCES" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-TOTAL?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TOTAL?" NULL 0))
    (CL:SETQ
     SYM-PROPOSITIONS-INDEX-ON-VALUES?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INDEX-ON-VALUES?" NULL 0)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:SETQ ZERO-VARIABLES-VECTOR (NEW-VECTOR 0))
    (CL:SETQ *LAST-KB-ACTION* KWD-PROPOSITIONS-UPDATE-PROPOSITION)
    (CL:SETQ BOTTOM (CREATE-SKOLEM NULL SYM-PROPOSITIONS-BOTTOM))
    (CL:SETQ *EVALUATIONMODE* KWD-PROPOSITIONS-EXTENSIONAL-ASSERTION)
    (CL:SETQ TRUE-TRUTH-VALUE (NEW-TRUTH-VALUE))
    (CL:SETQ FALSE-TRUTH-VALUE (NEW-TRUTH-VALUE))
    (CL:LET*
     ((SELF-049 (NEW-PROPOSITION)))
     (CL:SETF
      (CLSYS-SVAL PROPOSITION KIND SELF-049)
      KWD-PROPOSITIONS-CONSTANT)
     (CL:SETF
      (CLSYS-SVAL PROPOSITION OPERATOR SELF-049)
      SGT-PROPOSITIONS-TRUE)
     (CL:SETF (CLSYS-SVAL PROPOSITION ARGUMENTS SELF-049) (NEW-VECTOR 0))
     (CL:LET*
      ((OBJECT-051 SELF-049)
       (VALUE-052 TRUE-TRUTH-VALUE)
       (OLD-VALUE-053 (CLSYS-SVAL PROPOSITION TRUTH-VALUE OBJECT-051))
       (NEW-VALUE-054
        (UPDATE-IN-CONTEXT OLD-VALUE-053 VALUE-052 OBJECT-051 FALSE)))
      (CL:WHEN
       (CL:EQ (CS-VALUE? OLD-VALUE-053) 0)
       (CL:SETF
        (CLSYS-SVAL PROPOSITION TRUTH-VALUE OBJECT-051)
        NEW-VALUE-054)))
     (CL:SETQ TRUE-PROPOSITION SELF-049))
    (CL:LET*
     ((SELF-055 (NEW-PROPOSITION)))
     (CL:SETF
      (CLSYS-SVAL PROPOSITION KIND SELF-055)
      KWD-PROPOSITIONS-CONSTANT)
     (CL:SETF
      (CLSYS-SVAL PROPOSITION OPERATOR SELF-055)
      SGT-PROPOSITIONS-FALSE)
     (CL:SETF (CLSYS-SVAL PROPOSITION ARGUMENTS SELF-055) (NEW-VECTOR 0))
     (CL:LET*
      ((OBJECT-057 SELF-055)
       (VALUE-058 FALSE-TRUTH-VALUE)
       (OLD-VALUE-059 (CLSYS-SVAL PROPOSITION TRUTH-VALUE OBJECT-057))
       (NEW-VALUE-060
        (UPDATE-IN-CONTEXT OLD-VALUE-059 VALUE-058 OBJECT-057 FALSE)))
      (CL:WHEN
       (CL:EQ (CS-VALUE? OLD-VALUE-059) 0)
       (CL:SETF
        (CLSYS-SVAL PROPOSITION TRUTH-VALUE OBJECT-057)
        NEW-VALUE-060)))
     (CL:SETQ FALSE-PROPOSITION SELF-055))
    (CL:SETQ ANONYMOUS-VARIABLE-NAME SYM-PROPOSITIONS-?))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 5) 1)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "LOGIC-OBJECT"
        "(DEFCLASS LOGIC-OBJECT (CONTEXT-SENSITIVE-OBJECT DYNAMIC-SLOTS-MIXIN) :DOCUMENTATION \"Object with propositions, and possibly a variable value.\" :SLOTS ((ROOT-TYPE :TYPE TYPE) (ALL-ROOT-TYPES :TYPE (LIST OF TYPE) :ALLOCATION :DYNAMIC) (DEPENDENT-ATTRIBUTE-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :ALLOCATION :EMBEDDED) (DEPENDENT-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :ALLOCATION :EMBEDDED) (VARIABLE-VALUE :TYPE OBJECT :CONTEXT-SENSITIVE? TRUE) (VARIABLE-VALUE-INVERSE :TYPE (CONS OF LOGIC-OBJECT) :DEFAULT NIL :CONTEXT-SENSITIVE? TRUE) (SURROGATE-VALUE-INVERSE :TYPE SURROGATE :ALLOCATION :DYNAMIC) (ALL-SURROGATE-VALUE-INVERSES :TYPE (LIST OF SURROGATE) :ALLOCATION :DYNAMIC)) :PRINT-FORM (PRINT-TOP-LEVEL-OBJECT SELF STREAM))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-LOGIC-OBJECT))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-LOGIC-OBJECT-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "SKOLEM"
        "(DEFCLASS SKOLEM (LOGIC-OBJECT) :DOCUMENTATION \"Object whose identity and type are not fixed at creation time.
Potentially unifiable with any other object.\" :SLOTS ((SKOLEM-TYPE :RENAMES ROOT-TYPE) (SKOLEM-NAME :TYPE SYMBOL :ALLOCATION :DYNAMIC) (NOT-BOTTOM? :TYPE BOOLEAN :CONTEXT-SENSITIVE? TRUE :DEFAULT FALSE) (DEFINING-PROPOSITION :TYPE PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SKOLEM))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SKOLEM-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "PATTERN-VARIABLE"
        "(DEFCLASS PATTERN-VARIABLE (SKOLEM) :SLOTS ((BOUND-TO-OFFSET :TYPE INTEGER)) :METHODS ((BINDING-TO-CONSTANT ((SELF PATTERN-VARIABLE)) :TYPE OBJECT (RETURN (CHOOSE (NATIVE-VALUE? (VARIABLE-VALUE SELF)) (VARIABLE-VALUE SELF) NULL)))))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-PATTERN-VARIABLE))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-PATTERN-VARIABLE-SLOT-VALUE)))
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE OBJECT-VECTOR (VECTOR OF OBJECT))")
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE ARGUMENTS-VECTOR OBJECT-VECTOR)")
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE VARIABLES-VECTOR (VECTOR OF PATTERN-VARIABLE))")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "DESCRIPTION"
        "(DEFCLASS DESCRIPTION (LOGIC-OBJECT) :SLOTS ((PROPOSITION :TYPE PROPOSITION) (IO-VARIABLES :TYPE VARIABLES-VECTOR) (INTERNAL-VARIABLES :TYPE VARIABLES-VECTOR :INITIALLY ZERO-VARIABLES-VECTOR) (KIND :TYPE KEYWORD) (NATIVE-RELATION :TYPE RELATION) (EXTENSION :TYPE LIST :ALLOCATION :DYNAMIC) (QUERY-PATTERNS :TYPE (KEY-VALUE-LIST OF BOOLEAN-VECTOR DESCRIPTION)) (COMPLEMENT-DESCRIPTION :TYPE DESCRIPTION :ALLOCATION :DYNAMIC) (RELATIVE-COMPLEMENT-DESCRIPTIONS :TYPE (KEY-VALUE-LIST OF TYPE DESCRIPTION) :ALLOCATION :DYNAMIC) (REFERENCED-BY :TYPE (LIST OF DESCRIPTION) :ALLOCATION :EMBEDDED) (TAXONOMY-NODE :TYPE TAXONOMY-NODE) (IOTA? :TYPE BOOLEAN :ALLOCATION :DYNAMIC)) :METHODS ((ARITY ((SELF DESCRIPTION)) :TYPE INTEGER :GLOBALLY-INLINE? TRUE (RETURN (LENGTH (IO-VARIABLES SELF)))) (REPRESENTATIVE ((SELF DESCRIPTION)) :TYPE PATTERN-VARIABLE (RETURN (FIRST (IO-VARIABLES SELF)))) (RELATION? ((SELF DESCRIPTION)) :TYPE BOOLEAN (RETURN (AND (DEFINED? (NATIVE-RELATION SELF)) (ISA? (NATIVE-RELATION SELF) /STELLA/@SLOT) (MEMBER? (QUOTE (/STELLA/@BOOLEAN /STELLA/@BOOLEAN-WRAPPER)) (SLOT-BASE-TYPE (CAST (NATIVE-RELATION SELF) SLOT)))))) (FUNCTION? ((SELF DESCRIPTION)) :TYPE BOOLEAN (RETURN (AND (DEFINED? (NATIVE-RELATION SELF)) (ISA? (NATIVE-RELATION SELF) /STELLA/@SLOT) (NOT (MEMBER? (QUOTE (/STELLA/@BOOLEAN /STELLA/@BOOLEAN-WRAPPER)) (SLOT-BASE-TYPE (CAST (NATIVE-RELATION SELF) SLOT))))))) (DESCRIPTION-SURROGATE ((SELF DESCRIPTION)) :TYPE TYPE (LET ((NATIVERELATION (NATIVE-RELATION SELF))) (WHEN (DEFINED? NATIVERELATION) (TYPECASE NATIVERELATION (CLASS (RETURN (CLASS-TYPE NATIVERELATION))) (SLOT (RETURN (SLOT-SLOTREF NATIVERELATION))) (OTHERWISE NULL))) (RETURN NULL)))))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-DESCRIPTION))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-DESCRIPTION-SLOT-VALUE)))
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE PARTIAL-MATCH-SCORE FLOAT)")
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE SET-OF-SUPPORT LIST)")
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE TIME-STAMP INTEGER)")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRUTH-VALUE"
        "(DEFCLASS TRUTH-VALUE (LOGIC-OBJECT) :SLOTS ((POSITIVE-SCORE :TYPE PARTIAL-MATCH-SCORE :INITIALLY 0.0) (NEGATIVE-SCORE :TYPE PARTIAL-MATCH-SCORE :INITIALLY 0.0) (POSITIVE-SET-OF-SUPPORT :TYPE SET-OF-SUPPORT) (NEGATIVE-SET-OF-SUPPORT :TYPE SET-OF-SUPPORT) (TIME-STAMP :TYPE TIME-STAMP)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRUTH-VALUE))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TRUTH-VALUE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "PROPOSITION"
        "(DEFCLASS PROPOSITION (CONTEXT-SENSITIVE-OBJECT DYNAMIC-SLOTS-MIXIN) :DOCUMENTATION \"\" :SLOTS ((KIND :TYPE KEYWORD) (TRUTH-VALUE :TYPE TRUTH-VALUE :CONTEXT-SENSITIVE? TRUE) (ARGUMENTS :TYPE VECTOR) (OPERATOR :TYPE OBJECT) (SLOTREF :TYPE SLOTREF :RENAMES OPERATOR) (DEPENDENT-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :ALLOCATION :EMBEDDED) (IO-VARIABLES :TYPE VARIABLES-VECTOR :ALLOCATION :DYNAMIC) (VARIABLE-TYPE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (SUBRELATION-LINK? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (SUBSUMPTION-LINK? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (SURROGATE-VALUE-INVERSE :TYPE SURROGATE :ALLOCATION :DYNAMIC) (SATELLITE-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :ALLOCATION :DYNAMIC) (MASTER-PROPOSITION :TYPE PROPOSITION :ALLOCATION :DYNAMIC) (DONT-OPTIMIZE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (FORWARD-ONLY? :TYPE BOOLEAN :ALLOCATION :DYNAMIC) (BACKWARD-ONLY? :TYPE BOOLEAN :ALLOCATION :DYNAMIC)) :PRINT-FORM (PRINT-TOP-LEVEL-OBJECT SELF STREAM))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-PROPOSITION))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-PROPOSITION-SLOT-VALUE))))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-PROPOSITION"
        "SYMBOL"
        "(DEFUN (CREATE-PROPOSITION PROPOSITION) ((KIND SYMBOL) (ARGUMENTCOUNT INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-PROPOSITION)))
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT CONTEXT CONTEXT-ASSUMED-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT MODULE LOCALLY-CONCEIVED-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :READER LOCALLY-CONCEIVED-PROPOSITIONS-GETTER :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT MODULE STRICT-INFERENCE-CACHE :TYPE WORLD :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT MODULE DEFAULT-INFERENCE-CACHE :TYPE WORLD :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT WORLD MONOTONIC? :TYPE BOOLEAN :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT WORLD TRUTH-MAINTAINED? :TYPE BOOLEAN :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT WORLD UP-TO-DATE-INFERENCES? :TYPE BOOLEAN :ALLOCATION :DYNAMIC)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOCALLY-CONCEIVED-PROPOSITIONS-GETTER"
        "MODULE"
        "(DEFMETHOD (LOCALLY-CONCEIVED-PROPOSITIONS-GETTER (LIST OF PROPOSITION)) ((SELF MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOCALLY-CONCEIVED-PROPOSITIONS-GETTER)))
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT WORLD LOCALLY-BOUND-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :READER LOCALLY-BOUND-PROPOSITIONS-GETTER :ALLOCATION :DYNAMIC)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOCALLY-BOUND-PROPOSITIONS-GETTER"
        "WORLD"
        "(DEFMETHOD (LOCALLY-BOUND-PROPOSITIONS-GETTER (LIST OF PROPOSITION)) ((SELF WORLD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOCALLY-BOUND-PROPOSITIONS-GETTER)))
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT WORLD LOCALLY-BOUND-SKOLEMS :TYPE (LIST OF SKOLEM) :READER LOCALLY-BOUND-SKOLEMS-GETTER :ALLOCATION :DYNAMIC)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOCALLY-BOUND-SKOLEMS-GETTER"
        "WORLD"
        "(DEFMETHOD (LOCALLY-BOUND-SKOLEMS-GETTER (LIST OF SKOLEM)) ((SELF WORLD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOCALLY-BOUND-SKOLEMS-GETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INCREMENT-NOW-TIME-STAMP"
        NULL
        "(DEFUN INCREMENT-NOW-TIME-STAMP ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INCREMENT-NOW-TIME-STAMP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-NOW-TIME-STAMP"
        NULL
        "(DEFUN (GET-NOW-TIME-STAMP TIME-STAMP) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-NOW-TIME-STAMP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UPDATE-NOW-TIME-STAMP"
        "KEYWORD"
        "(DEFUN UPDATE-NOW-TIME-STAMP ((KBACTION KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UPDATE-NOW-TIME-STAMP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BOTTOM?"
        "OBJECT"
        "(DEFUN (BOTTOM? BOOLEAN) ((SELF OBJECT)) :DOCUMENTATION \"Return TRUE if 'self' is the undefined individual BOTTOM.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BOTTOM?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MONADIC?"
        "LOGIC-OBJECT"
        "(DEFMETHOD (MONADIC? BOOLEAN) ((SELF LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MONADIC?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MONADIC?"
        "COLLECTION"
        "(DEFMETHOD (MONADIC? BOOLEAN) ((SELF COLLECTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MONADIC?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MONADIC?"
        "DESCRIPTION"
        "(DEFMETHOD (MONADIC? BOOLEAN) ((SELF DESCRIPTION)) :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MONADIC?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOGIC-SLOT?"
        "SLOT"
        "(DEFUN (LOGIC-SLOT? BOOLEAN) ((SLOT SLOT)) :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOGIC-SLOT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TYPE-HAS-BACKLINKS?"
        "TYPE"
        "(DEFUN (TYPE-HAS-BACKLINKS? BOOLEAN) ((TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TYPE-HAS-BACKLINKS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NO-BACKLINKS?"
        "OBJECT"
        "(DEFUN (NO-BACKLINKS? BOOLEAN) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NO-BACKLINKS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOGIC-OBJECT-PERMITS-BACKLINKS?"
        "LOGIC-OBJECT"
        "(DEFUN (LOGIC-OBJECT-PERMITS-BACKLINKS? BOOLEAN) ((OBJECT LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOGIC-OBJECT-PERMITS-BACKLINKS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLOSED?"
        "SLOT"
        "(DEFMETHOD (CLOSED? BOOLEAN) ((SELF SLOT)) :DOCUMENTATION \"Return TRUE if the closed world assumption applies to
a function or relation.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CLOSED?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "OPEN-WORLD?"
        "SLOT"
        "(DEFMETHOD (OPEN-WORLD? BOOLEAN) ((SELF SLOT)) :DOCUMENTATION \"Return TRUE if the closed world assumption does not
apply to a function or relation.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION OPEN-WORLD?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESCRIPTION-MODE?"
        NULL
        "(DEFUN (DESCRIPTION-MODE? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESCRIPTION-MODE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONCEIVING-UPDATE?"
        "KEYWORD"
        "(DEFUN (CONCEIVING-UPDATE? BOOLEAN) ((UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONCEIVING-UPDATE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESCRIPTIVE-UPDATE?"
        "KEYWORD"
        "(DEFUN (DESCRIPTIVE-UPDATE? BOOLEAN) ((UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESCRIPTIVE-UPDATE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PROPAGATE-CONSTRAINTS-INCREMENTALLY?"
        "WORLD"
        "(DEFUN (PROPAGATE-CONSTRAINTS-INCREMENTALLY? BOOLEAN) ((SELF WORLD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PROPAGATE-CONSTRAINTS-INCREMENTALLY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONTEXT-DEPENDENT-SEARCH-MODE?"
        NULL
        "(DEFUN (CONTEXT-DEPENDENT-SEARCH-MODE? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONTEXT-DEPENDENT-SEARCH-MODE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOG-NEWLY-CONCEIVED-PROPOSITION"
        "MODULE"
        "(DEFUN LOG-NEWLY-CONCEIVED-PROPOSITION ((SELF MODULE) (PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOG-NEWLY-CONCEIVED-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOG-NEWLY-BOUND-PROPOSITION"
        "CONTEXT"
        "(DEFMETHOD LOG-NEWLY-BOUND-PROPOSITION ((SELF CONTEXT) (PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOG-NEWLY-BOUND-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOG-NEWLY-BOUND-PROPOSITION"
        "WORLD"
        "(DEFMETHOD LOG-NEWLY-BOUND-PROPOSITION ((SELF WORLD) (PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOG-NEWLY-BOUND-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RUN-GOES-TRUE-DEMONS"
        "PROPOSITION"
        "(DEFUN RUN-GOES-TRUE-DEMONS ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RUN-GOES-TRUE-DEMONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RUN-GOES-FALSE-DEMONS"
        "PROPOSITION"
        "(DEFUN RUN-GOES-FALSE-DEMONS ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RUN-GOES-FALSE-DEMONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RUN-GOES-UNKNOWN-DEMONS"
        "PROPOSITION"
        "(DEFUN RUN-GOES-UNKNOWN-DEMONS ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RUN-GOES-UNKNOWN-DEMONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REACT-TO-PROPOSITION-UPDATE"
        "PROPOSITION"
        "(DEFUN REACT-TO-PROPOSITION-UPDATE ((PROPOSITION PROPOSITION) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REACT-TO-PROPOSITION-UPDATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PROPAGATE-KB-CONSTRAINTS"
        "OBJECT"
        "(DEFMETHOD PROPAGATE-KB-CONSTRAINTS ((SELF OBJECT) (CONTEXT CONTEXT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PROPAGATE-KB-CONSTRAINTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PROPAGATE-KB-CONSTRAINTS"
        "SKOLEM"
        "(DEFMETHOD PROPAGATE-KB-CONSTRAINTS ((SELF SKOLEM) (CONTEXT CONTEXT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PROPAGATE-KB-CONSTRAINTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PROPAGATE-KB-CONSTRAINTS"
        "PROPOSITION"
        "(DEFMETHOD PROPAGATE-KB-CONSTRAINTS ((SELF PROPOSITION) (CONTEXT CONTEXT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PROPAGATE-KB-CONSTRAINTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REACT-TO-KB-UPDATE"
        "CONTEXT"
        "(DEFMETHOD REACT-TO-KB-UPDATE ((SELF CONTEXT) (OBJECT OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REACT-TO-KB-UPDATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REACT-TO-KB-UPDATE"
        "MODULE"
        "(DEFMETHOD REACT-TO-KB-UPDATE ((SELF MODULE) (OBJECT OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REACT-TO-KB-UPDATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REACT-TO-KB-UPDATE"
        "WORLD"
        "(DEFMETHOD REACT-TO-KB-UPDATE ((SELF WORLD) (OBJECT OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION REACT-TO-KB-UPDATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ASSIGN-TRUTH-VALUE"
        "PROPOSITION"
        "(DEFUN ASSIGN-TRUTH-VALUE ((SELF PROPOSITION) (VALUE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ASSIGN-TRUTH-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEASSIGN-TRUTH-VALUE"
        "PROPOSITION"
        "(DEFUN DEASSIGN-TRUTH-VALUE ((SELF PROPOSITION) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEASSIGN-TRUTH-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UPDATE-PROPOSITION-TRUTH-VALUE"
        "PROPOSITION"
        "(DEFUN UPDATE-PROPOSITION-TRUTH-VALUE ((SELF PROPOSITION) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UPDATE-PROPOSITION-TRUTH-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RUN-SLOT-INFERENCE-DEMONS"
        "OBJECT"
        "(DEFUN RUN-SLOT-INFERENCE-DEMONS ((SELF OBJECT) (SLOT STORAGE-SLOT) (OLDVALUE OBJECT) (NEWVALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RUN-SLOT-INFERENCE-DEMONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REACT-TO-ATTRIBUTE-PROPOSITION-UPDATE"
        "SKOLEM"
        "(DEFUN REACT-TO-ATTRIBUTE-PROPOSITION-UPDATE ((SKOLEM SKOLEM) (OLDVALUE OBJECT) (NEWVALUE OBJECT) (TOPLEVELUPDATE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REACT-TO-ATTRIBUTE-PROPOSITION-UPDATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRIMITIVE-SLOT?"
        "SLOT"
        "(DEFUN (PRIMITIVE-SLOT? BOOLEAN) ((SLOT SLOT)) :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRIMITIVE-SLOT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ATTRIBUTE-PROPOSITION?"
        "PROPOSITION"
        "(DEFUN (ATTRIBUTE-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)) :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ATTRIBUTE-PROPOSITION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ADD-DEPENDENT-PROPOSITION-LINK"
        "OBJECT"
        "(DEFUN ADD-DEPENDENT-PROPOSITION-LINK ((SELF OBJECT) (PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ADD-DEPENDENT-PROPOSITION-LINK)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-DEPENDENT-PROPOSITION-LINK"
        "OBJECT"
        "(DEFUN REMOVE-DEPENDENT-PROPOSITION-LINK ((SELF OBJECT) (PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REMOVE-DEPENDENT-PROPOSITION-LINK)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SLOTREF-LESS-OR-EQUAL?"
        "SLOTREF"
        "(DEFUN (SLOTREF-LESS-OR-EQUAL? BOOLEAN) ((SLOT1 SLOTREF) (SLOT2 SLOTREF)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SLOTREF-LESS-OR-EQUAL?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SLOTREF-LESS-THAN?"
        "SLOTREF"
        "(DEFUN (SLOTREF-LESS-THAN? BOOLEAN) ((SLOT1 SLOTREF) (SLOT2 SLOTREF)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SLOTREF-LESS-THAN?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSERT-SORTED-BY-SLOTREF"
        "LIST"
        "(DEFUN INSERT-SORTED-BY-SLOTREF ((SELF (LIST OF PROPOSITION)) (PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INSERT-SORTED-BY-SLOTREF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ADD-DEPENDENT-ATTRIBUTE-LINK"
        "LOGIC-OBJECT"
        "(DEFUN ADD-DEPENDENT-ATTRIBUTE-LINK ((OBJECT LOGIC-OBJECT) (PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ADD-DEPENDENT-ATTRIBUTE-LINK)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-DEPENDENT-ATTRIBUTE-LINK"
        "LOGIC-OBJECT"
        "(DEFUN REMOVE-DEPENDENT-ATTRIBUTE-LINK ((OBJECT LOGIC-OBJECT) (PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REMOVE-DEPENDENT-ATTRIBUTE-LINK)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIGNAL-UNDEFINED-SLOT-VALUE-FAILURE"
        "OBJECT"
        "(DEFUN SIGNAL-UNDEFINED-SLOT-VALUE-FAILURE ((OBJECT OBJECT) (SLOTREF SLOTREF)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIGNAL-UNDEFINED-SLOT-VALUE-FAILURE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ASSIGN-ATTRIBUTE-VALUE"
        "STANDARD-OBJECT"
        "(DEFUN ASSIGN-ATTRIBUTE-VALUE ((SELF STANDARD-OBJECT) (SLOT STORAGE-SLOT) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ASSIGN-ATTRIBUTE-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR-ATTRIBUTE-VALUE"
        "STANDARD-OBJECT"
        "(DEFUN CLEAR-ATTRIBUTE-VALUE ((OBJECT STANDARD-OBJECT) (SLOT STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLEAR-ATTRIBUTE-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DROP-ATTRIBUTE-VALUE"
        "STANDARD-OBJECT"
        "(DEFUN DROP-ATTRIBUTE-VALUE ((SELF STANDARD-OBJECT) (SLOT STORAGE-SLOT) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DROP-ATTRIBUTE-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-SLOTREF-ON-INSTANCE"
        "OBJECT"
        "(DEFUN (LOOKUP-SLOTREF-ON-INSTANCE SLOTREF) ((TERM OBJECT) (SLOTNAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-SLOTREF-ON-INSTANCE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "APPLY-SLOT-TO-NATIVE-ARGUMENTS"
        "SLOT"
        "(DEFMETHOD (APPLY-SLOT-TO-NATIVE-ARGUMENTS OBJECT) ((SLOT SLOT) (ARGUMENTS VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION APPLY-SLOT-TO-NATIVE-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "APPLY-SLOT-TO-NATIVE-ARGUMENTS"
        "STORAGE-SLOT"
        "(DEFMETHOD (APPLY-SLOT-TO-NATIVE-ARGUMENTS OBJECT) ((SLOT STORAGE-SLOT) (ARGUMENTS VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION APPLY-SLOT-TO-NATIVE-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "APPLY-SLOT-TO-NATIVE-ARGUMENTS"
        "METHOD-SLOT"
        "(DEFMETHOD (APPLY-SLOT-TO-NATIVE-ARGUMENTS OBJECT) ((SLOT METHOD-SLOT) (ARGUMENTS VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION APPLY-SLOT-TO-NATIVE-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNBOUND?"
        "SKOLEM"
        "(DEFUN (UNBOUND? BOOLEAN) ((SKOLEM SKOLEM)) :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNBOUND?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VALUE-OF"
        "OBJECT"
        "(DEFMETHOD (VALUE-OF OBJECT) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION VALUE-OF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VALUE-OF"
        "SURROGATE"
        "(DEFMETHOD (VALUE-OF OBJECT) ((SELF SURROGATE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION VALUE-OF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VALUE-OF"
        "SKOLEM"
        "(DEFMETHOD (VALUE-OF OBJECT) ((SELF SKOLEM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION VALUE-OF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VALUE-OF"
        "RELATION"
        "(DEFMETHOD (VALUE-OF OBJECT) ((SELF RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION VALUE-OF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SKOLEM?"
        "OBJECT"
        "(DEFUN (SKOLEM? BOOLEAN) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SKOLEM?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VARIABLE?"
        "OBJECT"
        "(DEFUN (VARIABLE? BOOLEAN) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VARIABLE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NATIVE-VALUE?"
        "OBJECT"
        "(DEFUN (NATIVE-VALUE? BOOLEAN) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NATIVE-VALUE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NATIVE-VALUE-OF"
        "OBJECT"
        "(DEFUN (NATIVE-VALUE-OF OBJECT) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NATIVE-VALUE-OF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EQUIVALENT-OF"
        "LOGIC-OBJECT"
        "(DEFUN (EQUIVALENT-OF LOGIC-OBJECT) ((SELF LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EQUIVALENT-OF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INNERMOST-VARIABLE-OF"
        "PATTERN-VARIABLE"
        "(DEFUN (INNERMOST-VARIABLE-OF PATTERN-VARIABLE) ((SELF PATTERN-VARIABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INNERMOST-VARIABLE-OF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INNERMOST-OF"
        "OBJECT"
        "(DEFUN (INNERMOST-OF OBJECT) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INNERMOST-OF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-FUNCTION-VALUE"
        "PROPOSITION"
        "(DEFUN (COMPUTE-FUNCTION-VALUE OBJECT) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-FUNCTION-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LAST-ARGUMENT"
        "PROPOSITION"
        "(DEFUN (LAST-ARGUMENT OBJECT) ((PROPOSITION PROPOSITION)) :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LAST-ARGUMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FUNCTION-VALUE"
        "PROPOSITION"
        "(DEFUN (FUNCTION-VALUE OBJECT) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FUNCTION-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FUNCTION-REPRESENTATIVE"
        "PROPOSITION"
        "(DEFUN (FUNCTION-REPRESENTATIVE OBJECT) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FUNCTION-REPRESENTATIVE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-PREDICATE-VALUE"
        "PROPOSITION"
        "(DEFUN (COMPUTE-PREDICATE-VALUE BOOLEAN BOOLEAN) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-PREDICATE-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-ANONYMOUS-SKOLEM-NAME"
        "BOOLEAN"
        "(DEFUN (YIELD-ANONYMOUS-SKOLEM-NAME SYMBOL) ((VARIABLE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-ANONYMOUS-SKOLEM-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-CREATE-SKOLEM"
        "SKOLEM"
        "(DEFUN (HELP-CREATE-SKOLEM SKOLEM) ((SELF SKOLEM) (TYPE TYPE) (NAME SYMBOL) (ASSERTIN? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-CREATE-SKOLEM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-SKOLEM"
        "TYPE"
        "(DEFUN (CREATE-SKOLEM SKOLEM) ((TYPE TYPE) (NAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-SKOLEM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-VARIABLE"
        "TYPE"
        "(DEFUN (CREATE-VARIABLE PATTERN-VARIABLE) ((TYPE TYPE) (NAME SYMBOL) (ASSERTIN? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRUE?"
        "PROPOSITION"
        "(DEFUN (TRUE? BOOLEAN) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRUE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FALSE?"
        "PROPOSITION"
        "(DEFUN (FALSE? BOOLEAN) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FALSE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNKNOWN?"
        "PROPOSITION"
        "(DEFUN (UNKNOWN? BOOLEAN) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNKNOWN?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIGNAL-UNIFICATION-CLASH"
        "OBJECT"
        "(DEFUN SIGNAL-UNIFICATION-CLASH ((TERM1 OBJECT) (TERM2 OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIGNAL-UNIFICATION-CLASH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIGNAL-VARIABLE-VALUE-CLASH"
        "SKOLEM"
        "(DEFUN SIGNAL-VARIABLE-VALUE-CLASH ((SKOLEM SKOLEM) (VALUE1 OBJECT) (VALUE2 OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIGNAL-VARIABLE-VALUE-CLASH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIGNAL-TRUTH-VALUE-CLASH"
        "PROPOSITION"
        "(DEFUN SIGNAL-TRUTH-VALUE-CLASH ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIGNAL-TRUTH-VALUE-CLASH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIGNAL-FAIL"
        NULL
        "(DEFUN SIGNAL-FAIL ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIGNAL-FAIL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOGICAL-TYPE"
        "OBJECT"
        "(DEFUN (LOGICAL-TYPE TYPE) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOGICAL-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNIFY-TYPES"
        "SKOLEM"
        "(DEFUN UNIFY-TYPES ((TERM1 SKOLEM) (TERM2 OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNIFY-TYPES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SCAN-FOR-ATTRIBUTES-CLASH"
        "LIST"
        "(DEFUN SCAN-FOR-ATTRIBUTES-CLASH ((ATTRIBUTES1 (LIST OF PROPOSITION)) (ATTRIBUTES2 (LIST OF PROPOSITION))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SCAN-FOR-ATTRIBUTES-CLASH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNIFY-ATTRIBUTE-PROPOSITIONS"
        "LIST"
        "(DEFUN UNIFY-ATTRIBUTE-PROPOSITIONS ((ATTRIBUTES1 (LIST OF PROPOSITION)) (ATTRIBUTES2 (LIST OF PROPOSITION))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNIFY-ATTRIBUTE-PROPOSITIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNIFY-SKOLEM-AND-VALUE"
        "SKOLEM"
        "(DEFUN UNIFY-SKOLEM-AND-VALUE ((SKOLEM SKOLEM) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNIFY-SKOLEM-AND-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BIND-SKOLEM-TO-VALUE"
        "SKOLEM"
        "(DEFUN BIND-SKOLEM-TO-VALUE ((FROMSKOLEM SKOLEM) (TOVALUE OBJECT) (TOPLEVELUPDATE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BIND-SKOLEM-TO-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNBIND-SKOLEM-VALUE"
        "SKOLEM"
        "(DEFUN UNBIND-SKOLEM-VALUE ((SKOLEM SKOLEM) (TOPLEVELUPDATE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNBIND-SKOLEM-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONSTRAIN-AS-SUBSET"
        "SEQUENCE"
        "(DEFUN CONSTRAIN-AS-SUBSET ((SET1 SEQUENCE) (SET2 SEQUENCE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONSTRAIN-AS-SUBSET)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EQUATE-COLLECTIONS"
        "COLLECTION"
        "(DEFUN EQUATE-COLLECTIONS ((COL1 COLLECTION) (COL2 COLLECTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EQUATE-COLLECTIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EQUATE-VALUES"
        "OBJECT"
        "(DEFUN EQUATE-VALUES ((TERM1 OBJECT) (TERM2 OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EQUATE-VALUES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNEQUATE-VALUES?"
        "OBJECT"
        "(DEFUN (UNEQUATE-VALUES? BOOLEAN) ((TERM1 OBJECT) (TERM2 OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNEQUATE-VALUES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESCRIPTION-EQUALS-DESCRIPTION?"
        "OBJECT"
        "(DEFUN (DESCRIPTION-EQUALS-DESCRIPTION? BOOLEAN) ((ARG1 OBJECT) (ARG2 OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESCRIPTION-EQUALS-DESCRIPTION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ARGUMENT-EQUALS-ARGUMENT?"
        "OBJECT"
        "(DEFUN (ARGUMENT-EQUALS-ARGUMENT? BOOLEAN) ((ARG1 OBJECT) (ARG2 OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ARGUMENT-EQUALS-ARGUMENT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PROPOSITION-EQL?"
        "PROPOSITION"
        "(DEFUN (PROPOSITION-EQL? BOOLEAN) ((SELF PROPOSITION) (OTHER PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PROPOSITION-EQL?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMMUTATIVE-PROPOSITION-EQL?"
        "PROPOSITION"
        "(DEFUN (COMMUTATIVE-PROPOSITION-EQL? BOOLEAN) ((SELF PROPOSITION) (OTHER PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMMUTATIVE-PROPOSITION-EQL?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-DEPENDENTS-OF-SOME-ARGUMENT"
        "PROPOSITION"
        "(DEFUN (FIND-DEPENDENTS-OF-SOME-ARGUMENT (LIST OF PROPOSITION)) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-DEPENDENTS-OF-SOME-ARGUMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-DUPLICATE-PROPOSITION"
        "PROPOSITION"
        "(DEFUN (FIND-DUPLICATE-PROPOSITION PROPOSITION) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-DUPLICATE-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-AND-PROPOSITION"
        "PROPOSITION"
        "(DEFUN EVALUATE-AND-PROPOSITION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-AND-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-OR-PROPOSITION"
        "PROPOSITION"
        "(DEFUN EVALUATE-OR-PROPOSITION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-OR-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-NOT-PROPOSITION"
        "PROPOSITION"
        "(DEFUN EVALUATE-NOT-PROPOSITION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-NOT-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-EQUIVALENT-PROPOSITION"
        "PROPOSITION"
        "(DEFUN EVALUATE-EQUIVALENT-PROPOSITION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-EQUIVALENT-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-FUNCTION-PROPOSITION"
        "PROPOSITION"
        "(DEFUN EVALUATE-FUNCTION-PROPOSITION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-FUNCTION-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-SLOT-PERMUTATIONS"
        "SLOT"
        "(DEFMETHOD EVALUATE-SLOT-PERMUTATIONS ((SELF SLOT) (ARGUMENTS (VECTOR OF OBJECT))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION EVALUATE-SLOT-PERMUTATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-SLOT-PERMUTATIONS"
        "METHOD-SLOT"
        "(DEFMETHOD EVALUATE-SLOT-PERMUTATIONS ((SELF METHOD-SLOT) (ORIGINALARGUMENTS (VECTOR OF OBJECT))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION EVALUATE-SLOT-PERMUTATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-PREDICATE-PROPOSITION"
        "PROPOSITION"
        "(DEFUN EVALUATE-PREDICATE-PROPOSITION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-PREDICATE-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-PROPOSITION"
        "PROPOSITION"
        "(DEFUN EVALUATE-PROPOSITION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-TERM"
        "OBJECT"
        "(DEFUN (EVALUATE-TERM OBJECT) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-WRAPPED-LITERAL-TERM"
        "LITERAL-WRAPPER"
        "(DEFUN (EVALUATE-WRAPPED-LITERAL-TERM OBJECT) ((SELF LITERAL-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-WRAPPED-LITERAL-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-SURROGATE-TERM"
        "SURROGATE"
        "(DEFUN (EVALUATE-SURROGATE-TERM OBJECT) ((SELF SURROGATE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-SURROGATE-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ANONYMOUS-VARIABLE?"
        "SKOLEM"
        "(DEFUN (ANONYMOUS-VARIABLE? BOOLEAN) ((SELF SKOLEM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ANONYMOUS-VARIABLE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-SYMBOL-TERM"
        "SYMBOL"
        "(DEFUN (EVALUATE-SYMBOL-TERM OBJECT) ((SELF SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-SYMBOL-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIGNAL-UNDEFINED-TERM"
        "OBJECT"
        "(DEFUN SIGNAL-UNDEFINED-TERM ((TERM OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIGNAL-UNDEFINED-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-SETOF-TERM"
        "CONS"
        "(DEFUN (EVALUATE-SETOF-TERM OBJECT) ((TERM CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-SETOF-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-CREATE-TERM"
        "CONS"
        "(DEFUN (EVALUATE-CREATE-TERM LOGIC-OBJECT) ((TERM CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-CREATE-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE"
        "GENERALIZED-SYMBOL"
        "(DEFUN (CREATE LOGIC-OBJECT) ((TYPE GENERALIZED-SYMBOL) |&REST| (NAME GENERALIZED-SYMBOL)) :DOCUMENTATION \"Create a logic object of logical type `type' and return it.
If `name' is also supplied, convert it into a surrogate and bind it to the 
newly created object.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%CREATE))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-PROPOSITIONS-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION CREATE-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LEFTMOST-CONCRETE-SUPERCLASS"
        "CLASS"
        "(DEFUN (LEFTMOST-CONCRETE-SUPERCLASS CLASS) ((SELF CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LEFTMOST-CONCRETE-SUPERCLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HAS-MULTIPLE-ROOT-CLASSES?"
        "CLASS"
        "(DEFUN (HAS-MULTIPLE-ROOT-CLASSES? BOOLEAN) ((SELF CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HAS-MULTIPLE-ROOT-CLASSES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-COLLECT-ROOT-CLASSES"
        "CLASS"
        "(DEFUN HELP-COLLECT-ROOT-CLASSES ((SELF CLASS) (ALLCLASSESLIST LIST) (BEENTHERE LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-COLLECT-ROOT-CLASSES)))
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT CLASS NON-DISJOINTNESS-KLUDGE? :TYPE BOOLEAN-WRAPPER :DOCUMENTATION \"True if one or more instances multiply inherits
from this root class and at least one other root class.  Used to
derail the current 'disjoint-classes?' test.\" :ALLOCATION :DYNAMIC)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-ROOT-CLASSES"
        "CLASS"
        "(DEFUN (ALL-ROOT-CLASSES (ITERATOR OF CLASS)) ((SELF CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-ROOT-CLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-DESCRIPTION-EXTENSION"
        "CLASS"
        "(DEFUN (GET-DESCRIPTION-EXTENSION (LIST OF LOGIC-OBJECT)) ((ROOTCLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-DESCRIPTION-EXTENSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INDEXED-BY-LOGICAL-EXTENSIONS?"
        "LOGIC-OBJECT"
        "(DEFUN (INDEXED-BY-LOGICAL-EXTENSIONS? BOOLEAN) ((SELF LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INDEXED-BY-LOGICAL-EXTENSIONS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UPDATE-LOGICAL-CLASS-EXTENSION"
        "LOGIC-OBJECT"
        "(DEFMETHOD UPDATE-LOGICAL-CLASS-EXTENSION ((SELF LOGIC-OBJECT) (TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION UPDATE-LOGICAL-CLASS-EXTENSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UPDATE-LOGICAL-CLASS-EXTENSION"
        "PATTERN-VARIABLE"
        "(DEFMETHOD UPDATE-LOGICAL-CLASS-EXTENSION ((SELF PATTERN-VARIABLE) (TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION UPDATE-LOGICAL-CLASS-EXTENSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-UPDATE-ROOT-TYPES"
        "LOGIC-OBJECT"
        "(DEFUN HELP-UPDATE-ROOT-TYPES ((SELF LOGIC-OBJECT) (NEWROOTTYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-UPDATE-ROOT-TYPES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UPDATE-ROOT-TYPES"
        "LOGIC-OBJECT"
        "(DEFUN UPDATE-ROOT-TYPES ((SELF LOGIC-OBJECT) (TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UPDATE-ROOT-TYPES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK"
        "LIST"
        "(DEFUN TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK ((RELATIONSLIST (LIST OF RELATION))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RETRACT-RELATION-AXIOMS"
        "RELATION"
        "(DEFUN RETRACT-RELATION-AXIOMS ((OLDRELATION RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RETRACT-RELATION-AXIOMS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION"
        "DESCRIPTION"
        "(DEFUN (ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION PROPOSITION) ((SUB DESCRIPTION) (SUPER DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS"
        "RELATION"
        "(DEFUN (ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS PROPOSITION) ((SUB RELATION) (SUPER RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ASSERT-IMPLIES-LINK-BETWEEN-RELATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-SUPERRELATION-LINKS"
        "RELATION"
        "(DEFUN FINALIZE-SUPERRELATION-LINKS ((SELF RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINALIZE-SUPERRELATION-LINKS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VERIFY-LOGICAL-AND-NATIVE-TYPES"
        "TYPE"
        "(DEFUN (VERIFY-LOGICAL-AND-NATIVE-TYPES TYPE) ((LOGICALTYPE TYPE) (NATIVETYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VERIFY-LOGICAL-AND-NATIVE-TYPES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UPDATE-ISA-PROPOSITION"
        "LOGIC-OBJECT"
        "(DEFUN (UPDATE-ISA-PROPOSITION PROPOSITION) ((SELF LOGIC-OBJECT) (TYPE TYPE) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UPDATE-ISA-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ASSERT-ISA-PROPOSITION"
        "LOGIC-OBJECT"
        "(DEFUN (ASSERT-ISA-PROPOSITION PROPOSITION) ((SELF LOGIC-OBJECT) (TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ASSERT-ISA-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UPDATE-PROPERTY"
        "LOGIC-OBJECT"
        "(DEFUN UPDATE-PROPERTY ((INSTANCE LOGIC-OBJECT) (PROPERTY SYMBOL) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UPDATE-PROPERTY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ASSERT-PROPERTY"
        "LOGIC-OBJECT"
        "(DEFUN ASSERT-PROPERTY ((INSTANCE LOGIC-OBJECT) (PROPERTY SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ASSERT-PROPERTY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-LOGIC-OBJECT"
        "TYPE"
        "(DEFUN (CREATE-LOGIC-OBJECT LOGIC-OBJECT) ((TYPE TYPE) (NAME SURROGATE) (NATIVEVALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-LOGIC-OBJECT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUILD-TOP-LEVEL-PROPOSITION"
        "OBJECT"
        "(DEFUN (BUILD-TOP-LEVEL-PROPOSITION PROPOSITION) ((TREE OBJECT) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BUILD-TOP-LEVEL-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FASTEN-DOWN-PROPOSITION"
        "PROPOSITION"
        "(DEFUN (FASTEN-DOWN-PROPOSITION PROPOSITION) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FASTEN-DOWN-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUILD-PROPOSITION"
        "OBJECT"
        "(DEFUN (BUILD-PROPOSITION PROPOSITION) ((TREE OBJECT) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BUILD-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SURROGATE.BUILD-PROPOSITION"
        "SURROGATE"
        "(DEFUN (SURROGATE.BUILD-PROPOSITION PROPOSITION) ((SELF SURROGATE) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SURROGATE.BUILD-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SYMBOL.BUILD-PROPOSITION"
        "SYMBOL"
        "(DEFUN (SYMBOL.BUILD-PROPOSITION PROPOSITION) ((SYMBOL SYMBOL) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SYMBOL.BUILD-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONS.BUILD-PROPOSITION"
        "CONS"
        "(DEFUN (CONS.BUILD-PROPOSITION PROPOSITION) ((TREE CONS) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONS.BUILD-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VERIFY-COLLECTION-ARGUMENT"
        "OBJECT"
        "(DEFUN VERIFY-COLLECTION-ARGUMENT ((SELF OBJECT) (ORIGINAL OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VERIFY-COLLECTION-ARGUMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VERIFY-RELATION-ARGUMENT"
        "OBJECT"
        "(DEFUN VERIFY-RELATION-ARGUMENT ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VERIFY-RELATION-ARGUMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS"
        "CONS"
        "(DEFUN VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS ((TREE CONS) (CORRECTNUMBER INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VERIFY-NUMBER-OF-PROPOSITION-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUILD-IN-PROPOSITION"
        "CONS"
        "(DEFUN (BUILD-IN-PROPOSITION PROPOSITION) ((TREE CONS) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BUILD-IN-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS"
        "PROPOSITION"
        "(DEFUN (EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS PROPOSITION) ((EXISTSPROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUILD-AND-OR-NOT-PROPOSITION"
        "CONS"
        "(DEFUN (BUILD-AND-OR-NOT-PROPOSITION PROPOSITION) ((TREE CONS) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BUILD-AND-OR-NOT-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FUNCTIONAL-TERM?"
        "OBJECT"
        "(DEFUN (FUNCTIONAL-TERM? BOOLEAN) ((TERM OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FUNCTIONAL-TERM?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLIP-VALUE?"
        "OBJECT"
        "(DEFUN (CLIP-VALUE? BOOLEAN) ((TERM1 OBJECT) (TERM2 OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLIP-VALUE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINISH-BUILDING-EQUIVALENCE-PROPOSITION"
        "OBJECT"
        "(DEFUN (FINISH-BUILDING-EQUIVALENCE-PROPOSITION PROPOSITION) ((TERM1 OBJECT) (TERM2 OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINISH-BUILDING-EQUIVALENCE-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBSTITUTE-FUNCTION-FOR-EQUIVALENCE"
        "PATTERN-VARIABLE"
        "(DEFUN (SUBSTITUTE-FUNCTION-FOR-EQUIVALENCE PROPOSITION) ((FUNCTIONVARIABLE PATTERN-VARIABLE) (TERM OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SUBSTITUTE-FUNCTION-FOR-EQUIVALENCE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUILD-EQUIVALENCE-PROPOSITION"
        "CONS"
        "(DEFUN (BUILD-EQUIVALENCE-PROPOSITION PROPOSITION) ((TREE CONS) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BUILD-EQUIVALENCE-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS"
        "CONS"
        "(DEFUN (BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS PROPOSITION) ((TREE CONS) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BUILD-CONJUNCTION-OF-EQUALITY-PROPOSITIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VERIFY-SECOND-ORDER-VARIABLE"
        "SKOLEM"
        "(DEFUN (VERIFY-SECOND-ORDER-VARIABLE SKOLEM) ((VARIABLE SKOLEM) (KIND KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VERIFY-SECOND-ORDER-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUILD-PREDICATE-PROPOSITION"
        "CONS"
        "(DEFUN (BUILD-PREDICATE-PROPOSITION PROPOSITION) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BUILD-PREDICATE-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUILD-EXISTS-PROPOSITION"
        "CONS"
        "(DEFUN (BUILD-EXISTS-PROPOSITION PROPOSITION) ((TREE CONS) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BUILD-EXISTS-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TOP-LEVEL-EXISTS-PROPOSITION?"
        "PROPOSITION"
        "(DEFUN (TOP-LEVEL-EXISTS-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TOP-LEVEL-EXISTS-PROPOSITION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECT-SKOLEMIZED-EXISTS-VARIABLES"
        "PROPOSITION"
        "(DEFUN (COLLECT-SKOLEMIZED-EXISTS-VARIABLES (VECTOR OF SKOLEM)) ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECT-SKOLEMIZED-EXISTS-VARIABLES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES?"
        "PROPOSITION"
        "(DEFUN (HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES? BOOLEAN) ((PROPOSITION PROPOSITION) (RESULT (LIST OF SKOLEM))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-COLLECT-SKOLEMIZED-EXISTS-VARIABLES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUILD-FORALL-PROPOSITION"
        "CONS"
        "(DEFUN (BUILD-FORALL-PROPOSITION PROPOSITION) ((TREE CONS) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BUILD-FORALL-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VERIFY-IMPLIES-ARGUMENT"
        "OBJECT"
        "(DEFUN VERIFY-IMPLIES-ARGUMENT ((SELF OBJECT) (OPERATOR SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VERIFY-IMPLIES-ARGUMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUILD-IMPLIES-PROPOSITION"
        "CONS"
        "(DEFUN (BUILD-IMPLIES-PROPOSITION PROPOSITION) ((TREE CONS) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BUILD-IMPLIES-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-DUPLICATE-FUNCTION-PROPOSITION"
        "SLOTREF"
        "(DEFUN (FIND-DUPLICATE-FUNCTION-PROPOSITION PROPOSITION) ((SLOTREF SLOTREF) (ARGUMENTS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-DUPLICATE-FUNCTION-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-FUNCTION-PROPOSITION"
        "SLOTREF"
        "(DEFUN (CREATE-FUNCTION-PROPOSITION PROPOSITION) ((SLOTREF SLOTREF) (INPUTARGUMENTS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-FUNCTION-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-SECOND-ORDER-FUNCTION-PROPOSITION"
        "OBJECT"
        "(DEFUN (CREATE-SECOND-ORDER-FUNCTION-PROPOSITION PROPOSITION) ((VARIABLEFUNCTION OBJECT) (INPUTARGUMENTS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-SECOND-ORDER-FUNCTION-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINISH-EVALUATING-FUNCTION-TERM"
        "SLOTREF"
        "(DEFUN (FINISH-EVALUATING-FUNCTION-TERM OBJECT) ((SLOTREF SLOTREF) (INPUTARGUMENTS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINISH-EVALUATING-FUNCTION-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-FUNCTION-TERM"
        "CONS"
        "(DEFUN (EVALUATE-FUNCTION-TERM OBJECT) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-FUNCTION-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FUNCTION-OUTPUT-VARIABLE?"
        "OBJECT"
        "(DEFUN (FUNCTION-OUTPUT-VARIABLE? BOOLEAN) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FUNCTION-OUTPUT-VARIABLE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FUNCTION-OUTPUT-SKOLEM?"
        "OBJECT"
        "(DEFUN (FUNCTION-OUTPUT-SKOLEM? BOOLEAN) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FUNCTION-OUTPUT-SKOLEM?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-TRUE-AND-FALSE"
        "CONS"
        "(DEFUN (REMOVE-TRUE-AND-FALSE OBJECT BOOLEAN) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REMOVE-TRUE-AND-FALSE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FLATTEN-NESTED-OPERATORS"
        "CONS"
        "(DEFUN (FLATTEN-NESTED-OPERATORS OBJECT BOOLEAN) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FLATTEN-NESTED-OPERATORS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CANONICALIZE-AND-OR-TREE"
        "CONS"
        "(DEFUN (CANONICALIZE-AND-OR-TREE OBJECT) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CANONICALIZE-AND-OR-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CANONICALIZE-NEGATION-TREE"
        "CONS"
        "(DEFUN (CANONICALIZE-NEGATION-TREE OBJECT) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CANONICALIZE-NEGATION-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "QUANTIFIER-SYMBOL?"
        "SYMBOL"
        "(DEFUN (QUANTIFIER-SYMBOL? BOOLEAN) ((SELF SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION QUANTIFIER-SYMBOL?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CANONICALIZE-QUANTIFICATION-TREE"
        "CONS"
        "(DEFUN (CANONICALIZE-QUANTIFICATION-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CANONICALIZE-QUANTIFICATION-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONS.CANONICALIZE-PROPOSITION-TREE"
        "CONS"
        "(DEFUN (CONS.CANONICALIZE-PROPOSITION-TREE OBJECT) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONS.CANONICALIZE-PROPOSITION-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CANONICALIZE-PROPOSITION-TREE"
        "OBJECT"
        "(DEFUN (CANONICALIZE-PROPOSITION-TREE OBJECT) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CANONICALIZE-PROPOSITION-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UPDATE-PROPOSITION"
        "OBJECT"
        "(DEFUN (UPDATE-PROPOSITION PROPOSITION) ((TREE OBJECT) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UPDATE-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-UPDATE-PROPOSITION"
        "OBJECT"
        "(DEFUN (HELP-UPDATE-PROPOSITION PROPOSITION) ((TREE OBJECT) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-UPDATE-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SMART-UPDATE-PROPOSITION"
        "OBJECT"
        "(DEFUN (SMART-UPDATE-PROPOSITION OBJECT) ((TREE OBJECT) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SMART-UPDATE-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ASSERT"
        "OBJECT"
        "(DEFUN (ASSERT OBJECT) ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Assert the truth of `proposition'.  Return the asserted proposition object.
KIF example:  `(assert (happy Fred))' asserts that Fred is indeed happy.
Note, that for this assertion to succeed, the logic constant `Fred' must
already be defined, e.g., as a side-effect of a type assertion such as
`(assert (Person Fred))', and the relation (or slot) `happy' must be defined
on objects of `Fred's type, e.g., on the class `Person'.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%ASSERT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RETRACT"
        "OBJECT"
        "(DEFUN (RETRACT PROPOSITION) ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Retract the truth of `proposition'.  Return the retracted proposition
object.  KIF example:  `(retract (happy Fred))' retracts that Fred is
happy.  Note, that for this to succeed, the logic constant `Fred' and the
relation (or slot) `happy' must already be defined (see `assert').\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%RETRACT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DENY"
        "OBJECT"
        "(DEFUN (DENY PROPOSITION) ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Assert the falsity of `proposition'.  Return the asserted proposition
object.  KIF example:  `(deny (happy Fred))' asserts that Fred is not happy,
which could have been done equivalently by `(assert (not (happy Fred)))'.
Note, that for this to succeed, the logic constant `Fred' and the
relation (or slot) `happy' must already be defined (see `assert').\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%DENY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONCEIVE"
        "OBJECT"
        "(DEFUN (CONCEIVE PROPOSITION) ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Build `proposition' without asserting its truth value.  Return the
conceived proposition object.  KIF example: `(conceive (happy Fred))' builds
the proposition expressing that Fred is happy without explictly asserting or
denying it.  Note, that for this to succeed, the logic constant `Fred' and
the relation (or slot) `happy' must already be defined (see `assert').\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%CONCEIVE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNASSERT"
        "OBJECT"
        "(DEFUN UNASSERT ((PROPOSITION PARSE-TREE)) :DOCUMENTATION \"Retract the truth or falsity of `proposition'.  This is a more general
version of `retract' that also handles falsity.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%UNASSERT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNASSERT-FACT"
        "PROPOSITION"
        "(DEFUN UNASSERT-FACT ((SELF PROPOSITION)) :DOCUMENTATION \"Retract the truth or falsity of the proposition 'self'\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNASSERT-FACT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DELETED?"
        "LOGIC-OBJECT"
        "(DEFMETHOD (DELETED? BOOLEAN) ((SELF LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DELETED?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DELETED?-SETTER"
        "LOGIC-OBJECT"
        "(DEFMETHOD (DELETED?-SETTER BOOLEAN) ((SELF LOGIC-OBJECT) (VALUE BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DELETED?-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DELETED?"
        "PROPOSITION"
        "(DEFMETHOD (DELETED? BOOLEAN) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DELETED?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DELETED?-SETTER"
        "PROPOSITION"
        "(DEFMETHOD (DELETED?-SETTER BOOLEAN) ((SELF PROPOSITION) (VALUE BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DELETED?-SETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-PROPOSITION"
        "PROPOSITION"
        "(DEFUN DESTROY-PROPOSITION ((PROPOSITION PROPOSITION)) :DOCUMENTATION \"Retract and destroy the proposition 'proposition'.
Recursively destroy all propositions that reference 'proposition'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESTROY-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-INSTANCE"
        "LOGIC-OBJECT"
        "(DEFUN DESTROY-INSTANCE ((OBJECT LOGIC-OBJECT)) :DOCUMENTATION \"Destroy all propositions that reference 'object',
and mark it as 'deleted?', thereby making it invisible within class
extensions.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESTROY-INSTANCE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-TERM"
        "LOGIC-OBJECT"
        "(DEFUN DESTROY-TERM ((OBJECT LOGIC-OBJECT)) :DOCUMENTATION \"Destroy all propositions that reference 'object',
and mark it as 'deleted?', thereby making it invisible within class
extensions.  Unlink descriptions from native relations.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESTROY-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR-LOGIC-MODULE-HOOK"
        "MODULE"
        "(DEFUN CLEAR-LOGIC-MODULE-HOOK ((MODULE MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLEAR-LOGIC-MODULE-HOOK)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR-INSTANCES"
        "ARGUMENT-LIST"
        "(DEFUN CLEAR-INSTANCES (|&REST| (NAME NAME)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Destroy all instances belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%CLEAR-INSTANCES))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-PROPOSITIONS-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION CLEAR-INSTANCES-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DO-CLEAR-INSTANCES"
        "MODULE"
        "(DEFUN DO-CLEAR-INSTANCES ((MODULE MODULE)) :DOCUMENTATION \"Function version of `clear-instances' that evaluates its argument.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DO-CLEAR-INSTANCES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-TRANSFER-PROPOSITION-ARGUMENTS"
        "PROPOSITION"
        "(DEFUN HELP-TRANSFER-PROPOSITION-ARGUMENTS ((PROPOSITION PROPOSITION) (FROMOBJECT LOGIC-OBJECT) (TOOBJECT LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-TRANSFER-PROPOSITION-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSFER-PROPOSITIONS-TO-LOGIC-OBJECT"
        "LOGIC-OBJECT"
        "(DEFUN TRANSFER-PROPOSITIONS-TO-LOGIC-OBJECT ((FROMOBJECT LOGIC-OBJECT) (TOOBJECT LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSFER-PROPOSITIONS-TO-LOGIC-OBJECT)))
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT SLOT TOTAL? :TYPE BOOLEAN :OPTION-KEYWORD :TOTAL? :DOCUMENTATION \"Applies to functions, not predicates.  True if the range
of the slot is defined for all combinations of arguments (domain values).\" :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT SLOT INDEX-ON-VALUES? :TYPE BOOLEAN :OPTION-KEYWORD :INDEX-ON-VALUES? :DOCUMENTATION \"Tells PowerLoom to install a hash index on the slot
values, enabling retrieval of the slot argument given its value.\" :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT SLOT PERMUTATION-TABLE :TYPE (KEY-VALUE-LIST OF VECTOR SLOT) :OPTION-KEYWORD :PERMUTATION-TABLE :ALLOCATION :DYNAMIC)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NUMBER-VALUE"
        "NUMBER-WRAPPER"
        "(DEFMETHOD (NUMBER-VALUE FLOAT) ((WRAPPEDNUMBER NUMBER-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NUMBER-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GREATER-THAN?"
        "NUMBER-WRAPPER"
        "(DEFMETHOD (GREATER-THAN? BOOLEAN-WRAPPER) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GREATER-THAN?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GREATER-OR-EQUAL?"
        "NUMBER-WRAPPER"
        "(DEFMETHOD (GREATER-OR-EQUAL? BOOLEAN-WRAPPER) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GREATER-OR-EQUAL?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LESS-THAN?"
        "NUMBER-WRAPPER"
        "(DEFMETHOD (LESS-THAN? BOOLEAN-WRAPPER) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LESS-THAN?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LESS-OR-EQUAL?"
        "NUMBER-WRAPPER"
        "(DEFMETHOD (LESS-OR-EQUAL? BOOLEAN-WRAPPER) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LESS-OR-EQUAL?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PLUS"
        "NUMBER-WRAPPER"
        "(DEFMETHOD (PLUS NUMBER-WRAPPER) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)))")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION PLUS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MINUS"
        "NUMBER-WRAPPER"
        "(DEFMETHOD (MINUS NUMBER-WRAPPER) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION MINUS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TIMES"
        "NUMBER-WRAPPER"
        "(DEFMETHOD (TIMES NUMBER-WRAPPER) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION TIMES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DIVIDE"
        "NUMBER-WRAPPER"
        "(DEFMETHOD (DIVIDE NUMBER-WRAPPER) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DIVIDE)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-PROPOSITIONS"
     NULL
     "(DEFUN STARTUP-PROPOSITIONS ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ZERO-VARIABLES-VECTOR VARIABLES-VECTOR (NEW VARIABLES-VECTOR :ARRAY-SIZE 0) :DOCUMENTATION \"Save space by structure-sharing zero-length variable vectors.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *NOW-TIME-STAMP* TIME-STAMP 0 :DOCUMENTATION \"The NOW time stamp is incremented whenever a series
of one or more updates is followed by a query.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LAST-KB-ACTION* KEYWORD :UPDATE-PROPOSITION :DOCUMENTATION \"Records whether the last KB access was a query or
an update.  Used to determine when to increment the NOW time stamp
counter.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT BOTTOM LOGIC-OBJECT (CREATE-SKOLEM NULL (QUOTE BOTTOM)) :DOCUMENTATION \"The undefined individual.  Denotes the non-existence of
an individual in whatever slot it occupies.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EVALUATIONMODE* KEYWORD :EXTENSIONAL-ASSERTION :DOCUMENTATION \"Indicates the context for evaluating a proposition.  One
of :DESCRIPTION, :QUERY, :INTENSIONAL-ASSERTION, or :EXTENSIONAL-ASSERTION.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-PROPOSITIONS-*EVALUATIONMODE*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*EVALUATIONMODE*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*EVALUATIONMODE*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CLIPPING-ENABLED* BOOLEAN TRUE :DOCUMENTATION \"When enabled, slot-value assertions can be retracted
by later conflicting assertions.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CONTEXT-DEPENDENT-SEARCH-MODE?* BOOLEAN FALSE :DOCUMENTATION \"Signals that we are performing search across multiple
contexts.  Used to disable retraction from collections, since that increases
the overhead of the context mechanism.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SKOLEM-ID-COUNTER* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *FREESKOLEMS* CONS NULL :DOCUMENTATION \"Cons-list of top-level existentially-quantified skolems.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-PROPOSITIONS-*FREESKOLEMS*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*FREESKOLEMS*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*FREESKOLEMS*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT TRUE-TRUTH-VALUE TRUTH-VALUE (NEW TRUTH-VALUE) :DOCUMENTATION \"Value representing TRUE.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT FALSE-TRUTH-VALUE TRUTH-VALUE (NEW TRUTH-VALUE) :DOCUMENTATION \"Value representing FALSE.\")")
    (CL:SETF (CLSYS-SVAL TRUTH-VALUE POSITIVE-SCORE TRUE-TRUTH-VALUE) 1.0)
    (CL:SETF (CLSYS-SVAL TRUTH-VALUE NEGATIVE-SCORE FALSE-TRUTH-VALUE) -1.0)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT TRUE-PROPOSITION PROPOSITION (NEW PROPOSITION :KIND :CONSTANT :OPERATOR /STELLA/@TRUE :ARGUMENTS (NEW ARGUMENTS-VECTOR :ARRAY-SIZE 0) :TRUTH-VALUE TRUE-TRUTH-VALUE))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT FALSE-PROPOSITION PROPOSITION (NEW PROPOSITION :KIND :CONSTANT :OPERATOR /STELLA/@FALSE :ARGUMENTS (NEW ARGUMENTS-VECTOR :ARRAY-SIZE 0) :TRUTH-VALUE FALSE-TRUTH-VALUE))")
    (CL:SETF
     (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-PROPOSITIONS-TRUE)
     TRUE-PROPOSITION)
    (CL:SETF
     (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT-PROPOSITIONS-FALSE)
     FALSE-PROPOSITION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ANONYMOUS-VARIABLE-NAME SYMBOL (QUOTE ?) :DOCUMENTATION \"Variables with name 'ANONYMOUS-VARIABLE-NAME' are considered
anonymous, and are not assumed to be identical to any other variable also named
'ANONYMOUS-VARIABLE-NAME'.\")")
    (REGISTER-NATIVE-NAME
     SYM-PROPOSITIONS-CREATE
     KWD-PROPOSITIONS-COMMON-LISP
     KWD-PROPOSITIONS-FUNCTION)
    (ADD-HOOK
     *REDEFINE-RELATION-HOOKS*
     SYM-PROPOSITIONS-TRANSFER-LOGIC-INFORMATION-FROM-RELATION-HOOK)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *PROPOSITIONUNDERCONSTRUCTION* OBJECT NULL :DOCUMENTATION \"Points to the parse tree which is the input to the
proposition being constructed.\")")
    (CL:LET*
     ((GLOBAL
       (LOOKUP-GLOBAL-VARIABLE
        SYM-PROPOSITIONS-*PROPOSITIONUNDERCONSTRUCTION*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*PROPOSITIONUNDERCONSTRUCTION*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*PROPOSITIONUNDERCONSTRUCTION*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TOPLEVELPROPOSITIONS* (CONS OF PROPOSITION) NULL :DOCUMENTATION \"If non-NULL newly built top-level propositions are
pushed onto this list.\")")
    (CL:LET*
     ((GLOBAL
       (LOOKUP-GLOBAL-VARIABLE SYM-PROPOSITIONS-*TOPLEVELPROPOSITIONS*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*TOPLEVELPROPOSITIONS*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*TOPLEVELPROPOSITIONS*)))
    (REGISTER-NATIVE-NAME
     SYM-PROPOSITIONS-ASSERT
     KWD-PROPOSITIONS-COMMON-LISP
     KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-PROPOSITIONS-RETRACT
     KWD-PROPOSITIONS-COMMON-LISP
     KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-PROPOSITIONS-DENY
     KWD-PROPOSITIONS-COMMON-LISP
     KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-PROPOSITIONS-CONCEIVE
     KWD-PROPOSITIONS-COMMON-LISP
     KWD-PROPOSITIONS-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-PROPOSITIONS-UNASSERT
     KWD-PROPOSITIONS-COMMON-LISP
     KWD-PROPOSITIONS-FUNCTION)
    (ADD-HOOK *CLEAR-MODULE-HOOKS* SYM-PROPOSITIONS-CLEAR-LOGIC-MODULE-HOOK)
    (REGISTER-NATIVE-NAME
     SYM-PROPOSITIONS-CLEAR-INSTANCES
     KWD-PROPOSITIONS-COMMON-LISP
     KWD-PROPOSITIONS-FUNCTION)))
  :VOID)
