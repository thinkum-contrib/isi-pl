<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from manual.texi on 11 December 1997 -->

<TITLE>PowerLoom Manual</TITLE>
</HEAD>
<BODY>
<H1>PowerLoom Manual</H1>
<P>
<P><HR><P>

<P>
PowerLoom Manual
<P>
Powerful knowledge representation and reasoning with
delivery in Common-Lisp, C++, (and, eventually, Java)
<P>
This manual describes
PowerLoom 1.0.alpha or later.
<P>
11 December 1997
<P>
<STRONG>The PowerLoom development team</STRONG>
<br>
<blockquote>
Robert M. MacGregor
<br>
Hans Chalupsky
<br>
Eric R. Melz
<br>
{macgregor,hans,melz}@isi.edu
</blockquote>

</P>
<P>
Copyright (C) 1997
University of Southern California, Information Sciences Institute,
4676 Admiralty Way, Marina Del Rey, CA 90292, USA

</P>
<P>
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

</P>



<H1><A NAME="SEC1" HREF="manual_toc.html#TOC1" target="toc">Introduction</A></H1>

<P>
This document describes the PowerLoom knowledge representation and
reasoning system.  PowerLoom is the successor to the Loom knowledge
representation system. It provides a language and environment for
constructing intelligent applications. PowerLoom uses a fully
expressive, logic-based representation language (a variant of KIF). It
uses a Prolog-technology backward chainer as its deductive
component. The backward chainer is (not yet) a complete theorem prover,
but it can handle Horn rules, negation, and simple equality
reasoning. Contrary to Prolog, it also handles recursive rules without
the risk of infinite recursion. Once the classifier is completed, it
will be able to classify descriptions expressed in full first order
predicate calculus. PowerLoom uses modules as a structuring device for
knowledge bases, and ultra-lightweight worlds to support hypothetical
reasoning.

</P>
<P>
To implement PowerLoom we developed a new programming language called
STELLA, which is a Strongly Typed, Lisp-like LAnguage that can be
translated into Lisp and C++. STELLA tries to preserve those features of
Lisp that facilitate symbolic programming and rapid prototyping, while
still allowing translation into readable as well as efficient C++
code. By writing PowerLoom in STELLA, we are able to deliver it in
Common-Lisp as well as in C++. Once the STELLA-to-Java translator has
been completed, PowerLoom will also become available in Java.

</P>



<H1><A NAME="SEC2" HREF="manual_toc.html#TOC2" target="toc">Content Language</A></H1>

<P>
PowerLoom uses a variant of KIF (the Knowledge Interchange Format) with
object-oriented extensions to express definitional and assertional
content. The sentential component of this variant is closest in flavor
to that of KIF 3.0 . The main differences are that relations in
PowerLoom are (by default) polymorphic, and that variables in quantified
sentences and terms can be typed. Not yet supported are logical terms
generated by <CODE>if</CODE> or <CODE>cond</CODE>, the biconditional <CODE>&#60;=&#62;</CODE>, and
the <CODE>holds</CODE> predicate. PowerLoom does not have sequence variables,
but it allows the definition of functions and relations with a variable
number of arguments. PowerLoom does not support quotation via
<CODE>quote</CODE>, instead, it will support sentences that take propositional
arguments. PowerLoom's definitional language is somewhat more different
from its counterpart in KIF 3.0. It has similarities with parts of
Ontolingua and is described in more detail in the manual. Future
versions of PowerLoom will have translation frontends to support
knowledge bases and ontologies written in vanilla KIF or Ontolingua.

</P>



<H2><A NAME="SEC3" HREF="manual_toc.html#TOC3" target="toc">Typed Variables</A></H2>

<P>
Write me.

</P>



<H1><A NAME="SEC4" HREF="manual_toc.html#TOC4" target="toc">Command Interpreter</A></H1>

<P>
Currently, the primary means for interacting with PowerLoom is its
command interpreter.  The command interpreter can be used either
interactively, or it can be invoked directly from a program to evaluate
individual commands.  Future versions of PowerLoom will include
additional APIs such as the Generic Frame Protocol (GFP).  All PowerLoom
commands (see section <A HREF="manual_body.html#SEC5">Commands</A>) can be evaluated using the command
interpreter.

</P>
<P>
The interactive command interpreter is invoked by calling the function
<CODE>powerloom</CODE> without any arguments.  In the distributed C++ version
of PowerLoom, this is the top-level function called within the
<CODE>main</CODE> routine.  In the Lisp version, <CODE>(STELLA::powerloom)</CODE>
has to be called explicitly.  However, in Lisp it is not really
necessary to use the command interpreter, since all commands can also be
executed directly at the Lisp top level.

</P>
<P>
The interactive command interpreter functions as a simple
read/eval/print loop that prompts for input with a <CODE>|=</CODE> prompt,
reads a user command from standard input, evaluates it, and prints the
result to standard output.  To exit the command interpreter, type
<CODE>quit</CODE> or <CODE>stop</CODE>.

</P>
<P>
To evaluate commands directly from a program, the following evaluator
functions can be used:

</P>
<P>
<DL>
<DT><A NAME="IDX1"></A><U>Function:</U> <B>evaluate</B> <I>((expression OBJECT)) : OBJECT TYPE-SPEC BOOLEAN</I>
<DD>
Evaluate the expression <VAR>expression</VAR> and return the result.
Currently, only the evaluation of (possibly nested) commands and global
variables is supported.  The second return value indicates the actual type 
of the result (which might have been wrapped), and the third return value
indicates whether an error occurred during the evaluation.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX2"></A><U>Function:</U> <B>evaluate-string</B> <I>((expression STRING)) : OBJECT TYPE-SPEC BOOLEAN</I>
<DD>
Evaluate the expression represented by <VAR>expression</VAR> and return the result.
This is equivalent to <CODE>(evaluate (unstringify expression))</CODE>.
</DL>

</P>



<H1><A NAME="SEC5" HREF="manual_toc.html#TOC5" target="toc">Commands</A></H1>

<P>
This chapter lists all available PowerLoom commands alphabetically.
Each command is documented with its name, a (possibly empty) list of
parameters specified as <CODE>(&#60;name&#62; &#60;type&#62;)</CODE> pairs, its return
type, and its command type which can be either <STRONG>Command</STRONG> or
<STRONG>N-Command</STRONG>.  Regular commands do evaluate their arguments (similar
to a Lisp or C++ function), while N-Commands do not (similar to a Lisp
macro).  For example, the command <CODE>in-dialect</CODE> is defined as follows:

</P>

<BLOCKQUOTE>
<P>
<DL>
<DT><A NAME="IDX3"></A><U>N-Command:</U> <B>in-dialect</B> <I>((dialect NAME)) : KEYWORD</I>
<DD>
Change the current logic dialect to <VAR>dialect</VAR>.
Currently supported dialects are <CODE>KIF</CODE>, <CODE>STELLA</CODE>, and <CODE>PREFIX-STELLA</CODE>.
The STELLA dialects are not recommended for the construction of knowledge
bases, they are mainly used internally by PowerLoom.
</DL>
</BLOCKQUOTE>

<P>
This means that it takes one parameter called <VAR>dialect</VAR> of type
<EM>NAME</EM>, returns a STELLA <EM>KEYWORD</EM> as its result,
and, since it is an N-Command, does not evaluate its arguments.

</P>
<P>
Commands can also have <CODE>&#38;rest</CODE> parameters (similar to Lisp
functions).  These are either used to allow a variable number of
arguments, or to handle optional arguments, since STELLA does not
directly support optional arguments.

</P>
<P>
Here is a list of important parameter types used in the
command specifications below:

</P>

<UL>
<LI><EM>GENERALIZED-SYMBOL</EM>: A generalized symbol is either a plain

symbol (similar to a Lisp symbol) such as <CODE>Fred</CODE>, a keyword
(similar to a Lisp keyword) such as <CODE>:KIF</CODE>, or a STELLA surrogate
which is a symbol starting with an at-sign, e.g., <CODE>@CONS</CODE>.  STELLA
surrogates are used as names for objects of arbitrary types.

<LI><EM>NAME</EM>: Names can be either a string, or a

<EM>GENERALIZED-SYMBOL</EM> (i.e., a symbol, a kewyord, or a
surrogate).  If a symbol is supplied, only its symbol-name is used.
Commands that take names as arguments usually need a string, but by
allowing a name they make it a little bit more convenient to supply such
a name in an interactive invocation.

<LI><EM>PARSE-TREE</EM>: A parse tree is similar to a Lisp s-expression,

i.e., it can either be an atom such as a symbol, number, or a string, or
a list of zero or more parse trees.  For example, the expression
<CODE>(happy Fred)</CODE> is a parse tree, and so are its components
<CODE>happy</CODE> and <CODE>Fred</CODE>.
</UL>

<P>
Here is the list of all available PowerLoom commands:

</P>
<P>
<DL>
<DT><A NAME="IDX4"></A><U>N-Command:</U> <B>all-facts-of</B> <I>((name NAME)) : (LIST OF PROPOSITION)</I>
<DD>
Return a list of all definite (TRUE or FALSE) propositions
that reference the logic-object named <VAR>name</VAR>.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX5"></A><U>N-Command:</U> <B>ask</B> <I>((proposition PARSE-TREE)) : BOOLEAN</I>
<DD>
Perform inference to determine whether <VAR>proposition</VAR> is true.
Return TRUE if <VAR>proposition</VAR> was found to be true; return NULL otherwise.
KIF example: <CODE>(ask (happy Fred))</CODE> will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic constant
<CODE>Fred</CODE> and the relation (or slot) <CODE>happy</CODE> must already be defined (see
<CODE>assert</CODE>).  Use <CODE>(set/unset-feature goal-trace)</CODE> to en/disable goal tracing
of the inference engine.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX6"></A><U>N-Command:</U> <B>assert</B> <I>((proposition PARSE-TREE)) : OBJECT</I>
<DD>
Assert the truth of <VAR>proposition</VAR>.  Return the asserted proposition object.
KIF example:  <CODE>(assert (happy Fred))</CODE> asserts that Fred is indeed happy.
Note, that for this assertion to succeed, the logic constant <CODE>Fred</CODE> must
already be defined, e.g., as a side-effect of a type assertion such as
<CODE>(assert (Person Fred))</CODE>, and the relation (or slot) <CODE>happy</CODE> must be defined
on objects of <CODE>Fred</CODE>s type, e.g., on the class <CODE>Person</CODE>.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX7"></A><U>N-Command:</U> <B>cc</B> <I>(&#38;rest (name NAME)) : CONTEXT</I>
<DD>
Change the current context to the one named <VAR>name</VAR>.  Return the
value of the new current context.  If no <VAR>name</VAR> is supplied, return
the value of <CODE>*context*</CODE>.  <CODE>cc</CODE> is a no-op if the context reference
cannot be successfully evaluated.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX8"></A><U>N-Command:</U> <B>clear-instances</B> <I>(&#38;rest (name NAME)) :</I>
<DD>
Destroy all instances belonging to module <VAR>name</VAR> or any of its children.
If no <VAR>name</VAR> is supplied, the current module will be cleared after
confirming with the user.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX9"></A><U>N-Command:</U> <B>clear-module</B> <I>(&#38;rest (name NAME)) :</I>
<DD>
Destroy all objects belonging to module <VAR>name</VAR> or any of its children.
If no <VAR>name</VAR> is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX10"></A><U>N-Command:</U> <B>conceive</B> <I>((proposition PARSE-TREE)) : PROPOSITION</I>
<DD>
Build <VAR>proposition</VAR> without asserting its truth value.  Return the
conceived proposition object.  KIF example: <CODE>(conceive (happy Fred))</CODE> builds
the proposition expressing that Fred is happy without explictly asserting or
denying it.  Note, that for this to succeed, the logic constant <CODE>Fred</CODE> and
the relation (or slot) <CODE>happy</CODE> must already be defined (see <CODE>assert</CODE>).
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX11"></A><U>Command:</U> <B>copyright</B> <I>() :</I>
<DD>
Print detailed PowerLoom copyright information.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX12"></A><U>N-Command:</U> <B>create</B> <I>((type GENERALIZED-SYMBOL) &#38;rest (name GENERALIZED-SYMBOL)) : LOGIC-OBJECT</I>
<DD>
Create a logic object of logical type <VAR>type</VAR> and return it.
If <VAR>name</VAR> is also supplied, convert it into a surrogate and bind it to the 
newly created object.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX13"></A><U>N-Command:</U> <B>defclass</B> <I>(&#38;rest (args PARSE-TREE)) : CLASS</I>
<DD>
Define (or redefine) a class.  The accepted syntax is:

</P>

<PRE>
  (defclass &#60;class-name&#62; (&#60;superclass-name&#62;*)
     [:documentation &#60;docstring&#62;]
     [:self-variable &#60;var&#62;]
     [[{:definition | :is} &#60;relation-expression&#62;] |
      [&#60;=&#62; &#60;sentence-with-argument-variables&#62;]]
     [:axioms {&#60;sentence&#62; | (&#60;sentence&#62;+)}]
     [:constraints {&#60;sentence-with-argument-variables&#62; |
                    (&#60;sentence-with-argument-variables&#62;+)}]
     [:sort? {TRUE | FALSE}]
     [:properties &#60;list-of-properties&#62;]
     [:meta-attributes &#60;list-of-key-value-pairs&#62;]
     [:slots ({(&#60;slot-name&#62; &#60;slot-options&#62;*)}*)]
     [&#60;other-options&#62;*])
</PRE>

<P>
&#60;slot-options&#62; is a list of keyword/value pairs.  The set of legal slot
options is the same as those accepted by <CODE>defrelation</CODE>.  Unless the <CODE>:sort?</CODE>
option specifies otherwise, classes defined with <CODE>defclass</CODE> are assumed
to be sorts, i.e., the extensions of two sibling classes that don't share
a common subclass are assumed to be disjoint.
CAUTION: The semantics of sorts is still somwhat in flux.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX14"></A><U>N-Command:</U> <B>defconcept</B> <I>(&#38;rest (args PARSE-TREE)) : CLASS</I>
<DD>
Define (or redefine) a class that is not a sort.
The accepted syntax is identical to that of <CODE>defclass</CODE>.  The only difference
is that the value of the <CODE>:sort?</CODE> option will always be forced to be FALSE.
This means that unrestricted inference might be used to determine whether
a particular object is an instance of a non-sortal class defined with
<CODE>defconcept</CODE>, since no disjointness assumptions can be made.  For example,
suppose a hierarchy contains the classes <CODE>Human</CODE> and <CODE>Featherless-Biped</CODE>
which share a common superclass, say <CODE>Living-Thing</CODE>.  If the two classes
were defined as sorts, their extensions are assumed to be disjoint.  Thus,
even if we have a rule 

</P>

<PRE>
  (forall (?x Living-Thing)
     (=&#62; (and (Featherless ?x) (Biped ?x))
         (Featherless-Biped ?x)))
</PRE>

<P>
and <CODE>Human</CODE>s are in fact featherless and bipeds, we will not be able to
infer <CODE>Human</CODE>s to be <CODE>Featherless-Biped</CODE>s.  However, if <CODE>Featherless-Biped</CODE>
was defined with <CODE>defconcept</CODE>, the rule will become applicable, since now
<CODE>Human</CODE>s and <CODE>Featherless-Biped</CODE>s are not necessarily disjoint anymore.
CAUTION: The semantics of sorts is still somwhat in flux.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX15"></A><U>N-Command:</U> <B>deffunction</B> <I>(&#38;rest (args PARSE-TREE)) : RELATION</I>
<DD>
Define (or redefine) a logic function.  The accepted syntax is:

</P>

<PRE>
  (deffunction {&#60;function-name&#62; |
                (&#60;function-name&#62; &#60;value-type&#62;)} (&#60;var&#62;+)
     [:documentation &#60;docstring&#62;]
     [:-&#62; &#60;value-variable&#62;]
     [:type &#60;value-type&#62;]
     [[{:definition | :is} &#60;relation-expression&#62;] |
      [&#60;=&#62; &#60;sentence-with-argument-variables&#62;] |
      [:= &#60;term-expression-with-argument-variables&#62;]]
     [:polymorphic? {TRUE | FALSE}]
     [:axioms {&#60;sentence&#62; | (&#60;sentence&#62;+)}]
     [:constraints {&#60;sentence-with-argument-variables&#62; |
                    (&#60;sentence-with-argument-variables&#62;+)}]
     [:properties &#60;list-of-properties&#62;]
     [:meta-attributes &#60;list-of-key-value-pairs&#62;]
     [&#60;other-options&#62;*])
</PRE>

<P>
Function parameters can be typed or untyped.  An untyped first parameter
or a <CODE>:polymorphic? FALSE</CODE> specification defines a non-polymorphic function.
Otherwise, the function will be polymorphic.  If a value variable is
specified, it must be specified before any definition options, otherwise,
the expansions of definitions might be incorrect.  The default KIF value
variable is <CODE>?value</CODE>.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX16"></A><U>N-Command:</U> <B>defmodule</B> <I>((name NAME) &#38;rest (options OBJECT)) :</I>
<DD>
Define (or redefine) a module named <VAR>name</VAR>.
The accepted syntax is:

</P>

<PRE>
  (defmodule &#60;module-name&#62;
     [:documentation &#60;docstring&#62;]
     [:includes {&#60;module-name&#62; | (&#60;module-name&#62;*)}]
     [:uses {&#60;module-name&#62; | (&#60;module-name&#62;*)}]
     [:package &#60;package-name-string&#62;]
     [:case-sensitive? {TRUE | FALSE}]
     [:shadow (&#60;symbol&#62;*)])
     [&#60;other-options&#62;*])
</PRE>

<P>
<VAR>name</VAR> can be a string or a symbol.  The list of modules specified in the
<CODE>:includes</CODE> option plus (if supplied) the parent in the path used for <VAR>name</VAR>
become the new module's parents.  If no <CODE>:uses</CODE> option was supplied, the
new module will use the <CODE>STELLA</CODE> module by default, otherwise, it will use
the set of specified modules.  <CODE>:package</CODE> specifies the name of a native
package or name space in which symbols of the module should be allocated
when they get translated into a native language such as Lisp or C++.
By default, Lisp symbols are allocated in the <CODE>STELLA</CODE> package, and C++ names
are translated without any prefixes.  If <CODE>:case-sensitive?</CODE> is supplied
as TRUE, symbols in the module will be interned case-sensitively, otherwise
(the default), they will be converted to uppercase before they get interned.
Modules can shadow definitions of functions and classes inherited from
parents or used modules.  Shadowing is done automatically, but generates
a warning unless the shadowed type or function name is listed in the
<CODE>:shadow</CODE> option of the module definition.  CAUTION: The implementation of
shadowing is still somewhat fragile.

</P>
<P>
Examples:

</P>

<PRE>
  (defmodule "/PL-USER"
    :uses ("LOGIC" "STELLA")
    :package "PL-USER")

  (defmodule /PL-USER/GENEALOGY)
</PRE>

<P>
Modules include objects from other modules via two separate mechanisms:
(1) they inherit from their parents specified via the <CODE>:includes</CODE> option
and/or a fully qualified module name, and (2) they inherit from used
modules specified via the <CODE>:uses</CODE> option.  The main difference between
the two mechanisms is that inheritance from parents is transitive, while
uses-links are only followed one level deep.  I.e., a module A that uses
B will see all objects of B (and any of B's parents) but not see anything
from modules used by B.  Another difference is that only objects declared
as public can be inherited via uses-links (this is not yet enforced).
Note that - contrary to Lisp - there are separate name spaces for classes,
functions, and variables.  For example, a module could inherit the class
<CODE>CONS</CODE> from the <CODE>STELLA</CODE> module, but shadow the function of the same name.
CAUTION: The implementation of this semantics has not yet been fully
completed.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX17"></A><U>N-Command:</U> <B>defrelation</B> <I>(&#38;rest (args PARSE-TREE)) : RELATION</I>
<DD>
Define (or redefine) a logic relation.  The accepted syntax is:

</P>

<PRE>
  (defrelation {&#60;relation-name&#62; | 
                (&#60;relation-name&#62; BOOLEAN)} (&#60;var&#62;+)
     [:documentation &#60;docstring&#62;]
     [:type BOOLEAN]
     [[{:definition | :is} &#60;relation-expression&#62;] |
      [&#60;=&#62; &#60;sentence-with-argument-variables&#62;]]
     [:polymorphic? {TRUE | FALSE}]
     [:axioms {&#60;sentence&#62; | (&#60;sentence&#62;+)}]
     [:constraints {&#60;sentence-with-argument-variables&#62; |
                    (&#60;sentence-with-argument-variables&#62;+)}]
     [:properties &#60;list-of-properties&#62;]
     [:meta-attributes &#60;list-of-key-value-pairs&#62;]
     [&#60;other-options&#62;*])
</PRE>

<P>
Relation parameters can be typed or untyped.  An untyped first parameter
or a <CODE>:polymorphic? FALSE</CODE> specification defines a non-polymorphic relation.
Otherwise, the relation will be polymorphic.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX18"></A><U>N-Command:</U> <B>defrule</B> <I>((ruleName NAME) (rule PARSE-TREE)) : PROPOSITION</I>
<DD>
Define (or redefine) a rule (any axiom) named <VAR>ruleName</VAR>.
If an axiom with that name already exists, replace it with the new
axiom <VAR>rule</VAR>.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX19"></A><U>N-Command:</U> <B>demo</B> <I>(&#38;rest (fileandpause OBJECT)) :</I>
<DD>
Read logic commands from a file, echo them verbatimly to standard output,
and evaluate them just as if they had been typed in interactively.
When called with no arguments, present a menu of example demos, otherwise,
use the first argument as the name of the file to demo.
Pause for user confirmation after each expression has been read but
before it is evaluated.  Pausing can be turned off by suppling FALSE
as the optional second argument, or by typing <CODE>c</CODE> at the pause prompt.
Typing <CODE>?</CODE> at the pause prompt prints a list of available commands.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX20"></A><U>N-Command:</U> <B>deny</B> <I>((proposition PARSE-TREE)) : PROPOSITION</I>
<DD>
Assert the falsity of <VAR>proposition</VAR>.  Return the asserted proposition
object.  KIF example:  <CODE>(deny (happy Fred))</CODE> asserts that Fred is not happy,
which could have been done equivalently by <CODE>(assert (not (happy Fred)))</CODE>.
Note, that for this to succeed, the logic constant <CODE>Fred</CODE> and the
relation (or slot) <CODE>happy</CODE> must already be defined (see <CODE>assert</CODE>).
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX21"></A><U>N-Command:</U> <B>help</B> <I>(&#38;rest (commands SYMBOL)) :</I>
<DD>
Describe specific commands, or print a list of available commands.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX22"></A><U>N-Command:</U> <B>in-dialect</B> <I>((dialect NAME)) : KEYWORD</I>
<DD>
Change the current logic dialect to <VAR>dialect</VAR>.
Currently supported dialects are <CODE>KIF</CODE>, <CODE>STELLA</CODE>, and <CODE>PREFIX-STELLA</CODE>.
The STELLA dialects are not recommended for the construction of knowledge
bases, they are mainly used internally by PowerLoom.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX23"></A><U>N-Command:</U> <B>in-module</B> <I>((name NAME)) : MODULE</I>
<DD>
Change the current module to the module named <VAR>name</VAR>.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX24"></A><U>Command:</U> <B>load</B> <I>((file STRING)) :</I>
<DD>
Read logic commands from <VAR>file</VAR> and evaluate them.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX25"></A><U>Command:</U> <B>print-features</B> <I>() :</I>
<DD>
Print the currently enabled and available PowerLoom environment features.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX26"></A><U>N-Command:</U> <B>propagate-constraints</B> <I>(&#38;rest (name NAME)) :</I>
<DD>
Trigger constraint propagation over all propositions of module <VAR>name</VAR>.
If no <VAR>name</VAR> is supplied, the current module will be used.  This also
enables incremental constraint propagation for future monotonic updates to
the module.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of a function value, all cached inferences will be discarded
and constraint propagation will be turned off until this function is
called again.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX27"></A><U>Command:</U> <B>reset-features</B> <I>() : (LIST OF KEYWORD)</I>
<DD>
Reset the PowerLoom environment features to their default settings.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX28"></A><U>N-Command:</U> <B>retract</B> <I>((proposition PARSE-TREE)) : PROPOSITION</I>
<DD>
Retract the truth of <VAR>proposition</VAR>.  Return the retracted proposition
object.  KIF example:  <CODE>(retract (happy Fred))</CODE> retracts that Fred is
happy.  Note, that for this to succeed, the logic constant <CODE>Fred</CODE> and the
relation (or slot) <CODE>happy</CODE> must already be defined (see <CODE>assert</CODE>).
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX29"></A><U>N-Command:</U> <B>retract-facts-of</B> <I>((name NAME)) :</I>
<DD>
Retract all definite (TRUE or FALSE) propositions
that reference the logic-object named <VAR>name</VAR>.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX30"></A><U>N-Command:</U> <B>retrieve</B> <I>(&#38;rest (query PARSE-TREE)) : QUERY-ITERATOR</I>
<DD>
Retrieve elements of a relation (tuples) that satisfy a proposition.
The accepted syntax is:

</P>

<PRE>
  (retrieve [&#60;integer&#62; | all]
            [{&#60;variable-spec&#62; | (&#60;variable-spec&#62;+)}
             [&#60;proposition&#62;]])
</PRE>

<P>
The variables and proposition are similar to an <CODE>exists</CODE> sentence or
<CODE>kappa</CODE> term without the quantifier.  &#60;proposition&#62; usually contains
references to the listed variables.  No other free variable references
are allowed.  If &#60;proposition&#62; is omitted, it defaults to TRUE.  

</P>
<P>
A solution is a set of bindings for the listed variables for which
&#60;proposition&#62; is true.  The optional first argument controls how many
solutions should be generated before control is returned.  The keyword
<CODE>all</CODE> indicates that all solutions should be generated.  By default,
<CODE>retrieve</CODE> returns after it has found one new solution or if it cannot
find any more solutions.

</P>
<P>
<CODE>retrieve</CODE> returns an iterator which saves all the necessary state of
a query and stores all generated solutions.  When used interactively,
the returned iterator will print out with the set of solutions collected
so far.  Calling <CODE>retrieve</CODE> without any arguments (or only with the first
argument) will generate one (or more) solutions to the most recently
asked query.

</P>
<P>
KIF examples:

</P>

<PRE>
  (retrieve (?x Person) (happy ?x)) 
</PRE>

<P>
will try to find the next happy person and store it in the returned 
query iterator.

</P>

<PRE>
  (retrieve 10 (?x Person) (happy ?x))
</PRE>

<P>
will try to find 10 happy people.

</P>

<PRE>
  (retrieve 10)
</PRE>

<P>
will try to find the next 10 happy people.

</P>

<PRE>
  (retrieve all (?x Person) (happy ?x))
</PRE>

<P>
will find all happy people.

</P>

<PRE>
  (retrieve all (?x Person))
</PRE>

<P>
will find all people.

</P>

<PRE>
  (retrieve (?x Person) (or (happy ?x) (parent-of Fred ?x)))
</PRE>

<P>
will try to find the next person that is happy or has Fred as a parent.

</P>

<PRE>
  (retrieve ((?x Person) (?y Person)) (parent-of ?x ?y))
</PRE>

<P>
will try to find the next pair of parent/child.

</P>

<PRE>
  (retrieve all (?x Person)
            (exists (?y Person) (parent-of ?x ?y)))
</PRE>

<P>
will generate the set of all parents.  Note, that for these queries to run,
the class <CODE>Person</CODE>, the relations <CODE>happy</CODE> and <CODE>parent-of</CODE>, and the logic
constant <CODE>Fred</CODE> must already be defined (see <CODE>assert</CODE>).

</P>
<P>
Use <CODE>(set/unset-feature goal-trace)</CODE> to en/disable goal tracing of the
inference engine.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX31"></A><U>N-Command:</U> <B>save-module</B> <I>((name NAME) (file STRING)) :</I>
<DD>
Save all definitions and assertions of module <VAR>name</VAR> to <VAR>file</VAR>.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX32"></A><U>N-Command:</U> <B>set-feature</B> <I>(&#38;rest (features NAME)) : (LIST OF KEYWORD)</I>
<DD>
Enable the PowerLoom environment feature(s) named by <VAR>features</VAR>.
Return the list of enabled features.  Calling <CODE>set-feature</CODE> without any
arguments can be used to display the currently enabled features.
The following features are supported:

</P>
<P>
<CODE>closed-world</CODE>: Enables closed-world reasoning.  NOT YET IMPLEMENTED!

</P>
<P>
<CODE>goal-trace</CODE>: Enables the generation of goal trace information during
inference.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX33"></A><U>N-Command:</U> <B>unassert</B> <I>((proposition PARSE-TREE)) :</I>
<DD>
Retract the truth or falsity of <VAR>proposition</VAR>.  This is a more general
version of <CODE>retract</CODE> that also handles falsity.
</DL>

</P>
<P>
<DL>
<DT><A NAME="IDX34"></A><U>N-Command:</U> <B>unset-feature</B> <I>(&#38;rest (features NAME)) : (LIST OF KEYWORD)</I>
<DD>
Disable the PowerLoom environment feature(s) named by <VAR>features</VAR>.
Return the list of enabled features.  Calling <CODE>unset-feature</CODE> without any
arguments can be used to display the currently enabled features.
See <CODE>set-feature</CODE> for a description of supported features.
</DL>

</P>



<H1><A NAME="SEC6" HREF="manual_toc.html#TOC6" target="toc">Function Index</A></H1>

<P>
<H2>a</H2>
<DIR>
<LI><A HREF="manual_body.html#IDX4">all-facts-of</A>
<LI><A HREF="manual_body.html#IDX5">ask</A>
<LI><A HREF="manual_body.html#IDX6">assert</A>
</DIR>
<H2>c</H2>
<DIR>
<LI><A HREF="manual_body.html#IDX7">cc</A>
<LI><A HREF="manual_body.html#IDX8">clear-instances</A>
<LI><A HREF="manual_body.html#IDX9">clear-module</A>
<LI><A HREF="manual_body.html#IDX10">conceive</A>
<LI><A HREF="manual_body.html#IDX11">copyright</A>
<LI><A HREF="manual_body.html#IDX12">create</A>
</DIR>
<H2>d</H2>
<DIR>
<LI><A HREF="manual_body.html#IDX13">defclass</A>
<LI><A HREF="manual_body.html#IDX14">defconcept</A>
<LI><A HREF="manual_body.html#IDX15">deffunction</A>
<LI><A HREF="manual_body.html#IDX16">defmodule</A>
<LI><A HREF="manual_body.html#IDX17">defrelation</A>
<LI><A HREF="manual_body.html#IDX18">defrule</A>
<LI><A HREF="manual_body.html#IDX19">demo</A>
<LI><A HREF="manual_body.html#IDX20">deny</A>
</DIR>
<H2>e</H2>
<DIR>
<LI><A HREF="manual_body.html#IDX1">evaluate</A>
<LI><A HREF="manual_body.html#IDX2">evaluate-string</A>
</DIR>
<H2>h</H2>
<DIR>
<LI><A HREF="manual_body.html#IDX21">help</A>
</DIR>
<H2>i</H2>
<DIR>
<LI><A HREF="manual_body.html#IDX3">in-dialect</A>, <A HREF="manual_body.html#IDX22">in-dialect</A>
<LI><A HREF="manual_body.html#IDX23">in-module</A>
</DIR>
<H2>l</H2>
<DIR>
<LI><A HREF="manual_body.html#IDX24">load</A>
</DIR>
<H2>p</H2>
<DIR>
<LI><A HREF="manual_body.html#IDX25">print-features</A>
<LI><A HREF="manual_body.html#IDX26">propagate-constraints</A>
</DIR>
<H2>r</H2>
<DIR>
<LI><A HREF="manual_body.html#IDX27">reset-features</A>
<LI><A HREF="manual_body.html#IDX28">retract</A>
<LI><A HREF="manual_body.html#IDX29">retract-facts-of</A>
<LI><A HREF="manual_body.html#IDX30">retrieve</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="manual_body.html#IDX31">save-module</A>
<LI><A HREF="manual_body.html#IDX32">set-feature</A>
</DIR>
<H2>u</H2>
<DIR>
<LI><A HREF="manual_body.html#IDX33">unassert</A>
<LI><A HREF="manual_body.html#IDX34">unset-feature</A>
</DIR>

</P>

<P><HR><P>
This document was generated on 11 December 1997 using the
<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
translator version 1.51.</P>
</BODY>
</HTML>
