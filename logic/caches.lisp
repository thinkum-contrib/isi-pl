;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997                   | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-CACHES-STRICT NULL)
(CL:DEFVAR SYM-CACHES-STRICT-INFERENCE-CACHE NULL)
(CL:DEFVAR KWD-CACHES-DEFAULT NULL)
(CL:DEFVAR SYM-CACHES-DEFAULT-INFERENCE-CACHE NULL)
(CL:DEFVAR SYM-CACHES-MONOTONIC? NULL)
(CL:DEFVAR SYM-CACHES-UP-TO-DATE-INFERENCES? NULL)
(CL:DEFVAR SGT-CACHES-MODULE NULL)
(CL:DEFVAR SGT-CACHES-WORLD NULL)
(CL:DEFVAR SGT-CACHES-PROPOSITION NULL)
(CL:DEFVAR SGT-CACHES-CLASH NULL)
(CL:DEFVAR SYM-CACHES-PROPAGATE-CONSTRAINTS NULL)
(CL:DEFVAR KWD-CACHES-COMMON-LISP NULL)
(CL:DEFVAR KWD-CACHES-FUNCTION NULL)
(CL:DEFVAR SYM-CACHES-EVALUATOR-WRAPPER-CODE NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *EXCEPTIONHANDLERADDRESS*
  *EXCEPTION*
  *EXCEPTION-TYPE*
  STANDARD-OUTPUT
  EOL
  *MODULE*
  *CONTEXT*
  NULL-BOOLEAN-WRAPPER))

;;; (DEFUN (LOOKUP-INFERENCE-CACHE WORLD) ...)

(CL:DEFUN LOOKUP-INFERENCE-CACHE (MODULE KIND)
  (CL:COND
   ((CL:EQ KIND KWD-CACHES-STRICT)
    (CL:RETURN-FROM
     LOOKUP-INFERENCE-CACHE
     (DYNAMIC-SLOT-VALUE MODULE SYM-CACHES-STRICT-INFERENCE-CACHE NULL)))
   ((CL:EQ KIND KWD-CACHES-DEFAULT)
    (CL:RETURN-FROM
     LOOKUP-INFERENCE-CACHE
     (DYNAMIC-SLOT-VALUE MODULE SYM-CACHES-DEFAULT-INFERENCE-CACHE NULL)))
   (CL:T (CL:ERROR "`~A' is not a valid case option" KIND)))
  :VOID)

;;; (DEFUN (CREATE-INFERENCE-CACHE WORLD) ...)

(CL:DEFUN CREATE-INFERENCE-CACHE (MODULE KIND)
  (CL:LET*
   ((WORLD NULL))
   (CL:COND
    ((CL:EQ KIND KWD-CACHES-STRICT)
     (CL:SETQ WORLD (CREATE-WORLD MODULE NULL))
     (SET-DYNAMIC-SLOT-VALUE
      WORLD
      SYM-CACHES-MONOTONIC?
      (WRAP-BOOLEAN TRUE)
      NULL-BOOLEAN-WRAPPER)
     (SET-DYNAMIC-SLOT-VALUE
      MODULE
      SYM-CACHES-STRICT-INFERENCE-CACHE
      WORLD
      NULL)
     (SET-DYNAMIC-SLOT-VALUE
      WORLD
      SYM-CACHES-UP-TO-DATE-INFERENCES?
      (WRAP-BOOLEAN
       (CL:IF (CL:EQ (NEXT? (ALL-PROPOSITIONS MODULE TRUE)) 0) TRUE FALSE))
      NULL-BOOLEAN-WRAPPER))
    ((CL:EQ KIND KWD-CACHES-DEFAULT)
     (CL:SETQ
      WORLD
      (CREATE-WORLD (GET-INFERENCE-CACHE MODULE KWD-CACHES-STRICT) NULL))
     (SET-DYNAMIC-SLOT-VALUE
      MODULE
      SYM-CACHES-DEFAULT-INFERENCE-CACHE
      WORLD
      NULL))
    (CL:T (CL:ERROR "`~A' is not a valid case option" KIND)))
   (CL:RETURN-FROM CREATE-INFERENCE-CACHE WORLD))
  :VOID)

;;; (DEFUN (GET-INFERENCE-CACHE WORLD) ...)

(CL:DEFUN GET-INFERENCE-CACHE (MODULE KIND)
  (CL:LET*
   ((WORLD (LOOKUP-INFERENCE-CACHE MODULE KIND)))
   (CL:WHEN
    (CL:NOT (CL:EQ WORLD NULL))
    (CL:RETURN-FROM GET-INFERENCE-CACHE WORLD))
   (CL:SETQ WORLD (CREATE-INFERENCE-CACHE MODULE KIND))
   (CL:LET*
    ((PARENTMODULE NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL MODULE PARENT-MODULES MODULE))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       PARENTMODULE
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-CACHES-MODULE))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (INHERIT-CACHED-INFERENCES
      (LOOKUP-INFERENCE-CACHE PARENTMODULE KIND)
      WORLD)))
   (CL:RETURN-FROM GET-INFERENCE-CACHE WORLD))
  :VOID)

;;; (DEFUN DESTROY-INFERENCE-CACHE ...)

(CL:DEFUN DESTROY-INFERENCE-CACHE (WORLD)
  (DESTROY-WORLD WORLD)
  :VOID)

;;; (DEFUN CHECK-FOR-OUT-OF-DATE-INFERENCE-CACHE ...)

(CL:DEFUN CHECK-FOR-OUT-OF-DATE-INFERENCE-CACHE ()
  (CL:WHEN
   (CL:EQ *MODULE* *CONTEXT*)
   (CL:LET*
    ((CACHE
      (DYNAMIC-SLOT-VALUE *MODULE* SYM-CACHES-STRICT-INFERENCE-CACHE NULL)))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ CACHE NULL)) (CL:EQ (MONOTONIC? CACHE) 1))
     (DESTROY-INFERENCE-CACHE CACHE)
     (SET-DYNAMIC-SLOT-VALUE
      *MODULE*
      SYM-CACHES-STRICT-INFERENCE-CACHE
      NULL
      NULL)))
   (CL:RETURN-FROM CHECK-FOR-OUT-OF-DATE-INFERENCE-CACHE))
  (CL:LET*
   ((WORLD (CAST *CONTEXT* SGT-CACHES-WORLD)))
   (CL:COND
    ((CL:EQ (TRUTH-MAINTAINED? WORLD) 1) NULL)
    ((CL:EQ (MONOTONIC? WORLD) 1)
     (CL:WARN
      "Retraction occurred in world `~A' which is marked monotonic."
      WORLD))
    (CL:T
     (SET-DYNAMIC-SLOT-VALUE
      WORLD
      SYM-CACHES-UP-TO-DATE-INFERENCES?
      (WRAP-BOOLEAN FALSE)
      NULL-BOOLEAN-WRAPPER))))
  :VOID)

;;; (DEFUN (GET-QUERY-CONTEXT CONTEXT) ...)

(CL:DEFUN GET-QUERY-CONTEXT ()
  (CL:WHEN
   (CL:NOT (CL:EQ *MODULE* *CONTEXT*))
   (CL:RETURN-FROM GET-QUERY-CONTEXT *CONTEXT*))
  (CL:LET*
   ((CACHE
     (DYNAMIC-SLOT-VALUE *MODULE* SYM-CACHES-STRICT-INFERENCE-CACHE NULL)))
   (CL:IF
    (CL:NOT (CL:EQ CACHE NULL))
    (CL:RETURN-FROM GET-QUERY-CONTEXT CACHE)
    (CL:RETURN-FROM GET-QUERY-CONTEXT *MODULE*)))
  :VOID)

;;; (DEFUN (GET-TOP-LEVEL-UPDATE-CONTEXT CONTEXT) ...)

(CL:DEFUN GET-TOP-LEVEL-UPDATE-CONTEXT ()
  (CL:IF
   (CL:EQ
    *CONTEXT*
    (DYNAMIC-SLOT-VALUE *MODULE* SYM-CACHES-STRICT-INFERENCE-CACHE NULL))
   (CL:RETURN-FROM GET-TOP-LEVEL-UPDATE-CONTEXT *MODULE*)
   (CL:RETURN-FROM GET-TOP-LEVEL-UPDATE-CONTEXT *CONTEXT*))
  :VOID)

;;; (DEFMETHOD (GET-CONSTRAINT-PROPAGATION-WORLD WORLD) ...)

(CL:DEFMETHOD GET-CONSTRAINT-PROPAGATION-WORLD ((SELF CONTEXT))
  (CL:RETURN-FROM GET-CONSTRAINT-PROPAGATION-WORLD (CAST SELF SGT-CACHES-WORLD))
  :VOID)

;;; (DEFMETHOD (GET-CONSTRAINT-PROPAGATION-WORLD WORLD) ...)

(CL:DEFMETHOD GET-CONSTRAINT-PROPAGATION-WORLD ((SELF MODULE))
  (CL:RETURN-FROM
   GET-CONSTRAINT-PROPAGATION-WORLD
   (GET-INFERENCE-CACHE SELF KWD-CACHES-STRICT))
  :VOID)

;;; (DEFUN INHERIT-CACHED-INFERENCES ...)

(CL:DEFUN INHERIT-CACHED-INFERENCES (FROMWORLD TOWORLD)
  (CL:SETQ TOWORLD TOWORLD)
  (CL:WHEN (CL:EQ FROMWORLD NULL) (CL:RETURN-FROM INHERIT-CACHED-INFERENCES))
  "NOT YET IMPLEMENTED"
  :VOID)

;;; (DEFUN INHERIT-TRUTH-VALUE-UPDATE ...)

(CL:DEFUN INHERIT-TRUTH-VALUE-UPDATE (PROPOSITION TOWORLD)
  "NOT YET IMPLEMENTED"
  :VOID)

;;; (DEFUN INHERIT-VARIABLE-VALUE-UPDATE ...)

(CL:DEFUN INHERIT-VARIABLE-VALUE-UPDATE (SKOLEM TOWORLD)
  "NOT YET IMPLEMENTED"
  :VOID)

;;; (DEFUN DO-PROPAGATE-CONSTRAINTS ...)

(CL:DEFUN DO-PROPAGATE-CONSTRAINTS (CONTEXT)
  "Trigger constraint propagation over all propositions
in the module or world `context'."
  (CL:LET*
   ((WORLD (GET-CONSTRAINT-PROPAGATION-WORLD CONTEXT))
    (MODULE (CLSYS-SVAL CONTEXT BASE-MODULE CONTEXT)))
   (CL:WHEN
    (CL:EQ (UP-TO-DATE-INFERENCES? WORLD) 1)
    (CL:RETURN-FROM DO-PROPAGATE-CONSTRAINTS))
   (CL:PROGN
    (CL:LET*
     ((*PENDINGEXCEPTIONHANDLER?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PENDINGEXCEPTIONHANDLER?*))
     (CL:CATCH
      *EXCEPTIONHANDLERADDRESS*
      (CL:PROGN
       (CL:LET*
        ((P NULL) (ITER-001 (ALL-PROPOSITIONS MODULE TRUE)))
        (CL:LOOP
         WHILE
         (CL:EQ (NEXT? ITER-001) 1)
         DO
         (CL:PROGN
          (CL:SETQ
           P
           (CAST
            (CLSYS-SVAL ITERATOR VALUE ITER-001)
            SGT-CACHES-PROPOSITION)))
         (REACT-TO-KB-UPDATE WORLD P)))
       (CL:SETQ *EXCEPTION* NULL))))
    (CL:WHEN
     (CL:NOT (CL:EQ *EXCEPTION* NULL))
     (CL:COND
      ((CL:EQ (SUBTYPE-OF? *EXCEPTION-TYPE* SGT-CACHES-CLASH) 1)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING
         "One or more facts need to be retracted to eliminate"
         %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING "   the inconsistency." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)))
      (CL:T (RESIGNAL)))))
   (SET-DYNAMIC-SLOT-VALUE
    WORLD
    SYM-CACHES-UP-TO-DATE-INFERENCES?
    (WRAP-BOOLEAN TRUE)
    NULL-BOOLEAN-WRAPPER))
  :VOID)

;;; (DEFUN PROPAGATE-CONSTRAINTS ...)

(CL:DEFUN %%PROPAGATE-CONSTRAINTS (NAME)
  "Trigger constraint propagation over all propositions of module `name'.
If no `name' is supplied, the current module will be used.  This also
enables incremental constraint propagation for future monotonic updates to
the module.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of a function value, all cached inferences will be discarded
and constraint propagation will be turned off until this function is
called again."
  (CL:LET*
   ((MODULE (COERCE-TO-MODULE (FIRST NAME) TRUE)))
   (CL:WHEN (CL:NOT (CL:EQ MODULE NULL)) (DO-PROPAGATE-CONSTRAINTS MODULE)))
  :VOID)

(CL:DEFUN PROPAGATE-CONSTRAINTS-EVALUATOR-WRAPPER (ARGUMENTS)
  (%%PROPAGATE-CONSTRAINTS ARGUMENTS)
  :VOID)

(CL:DEFMACRO PROPAGATE-CONSTRAINTS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Trigger constraint propagation over all propositions of module `name'.
If no `name' is supplied, the current module will be used.  This also
enables incremental constraint propagation for future monotonic updates to
the module.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of a function value, all cached inferences will be discarded
and constraint propagation will be turned off until this function is
called again."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/PROPAGATE-CONSTRAINTS)) (CL:MACRO-FUNCTION (CL:QUOTE PROPAGATE-CONSTRAINTS)))

;;; (DEFUN DO-ENABLE-CONSTRAINT-PROPAGATION ...)

(CL:DEFUN DO-ENABLE-CONSTRAINT-PROPAGATION (SELF)
  "Find or create a strict inference cache for context `self',
which will contain the inferences derived from future updates to `self'."
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-CACHES-MODULE) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (GET-INFERENCE-CACHE SELF KWD-CACHES-STRICT)))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-CACHES-WORLD) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:EQ (PROPAGATE-CONSTRAINTS-INCREMENTALLY? SELF) 0)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING "Can't propagate constraints in world `" %%STREAM)
        (PRINT-OBJECT SELF %%STREAM)
        (CL:WRITE-STRING "' because" %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING
         "   it is neither marked `monotonic?' nor `truth-maintained?'."
         %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" SELF))))
  :VOID)

(CL:DEFUN STARTUP-CACHES ()
  (CL:LET*
   ((*MODULE* (GET-MODULE "/LOGIC" TRUE)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     KWD-CACHES-STRICT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRICT" NULL 2))
    (CL:SETQ
     SYM-CACHES-STRICT-INFERENCE-CACHE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRICT-INFERENCE-CACHE" NULL 0))
    (CL:SETQ
     KWD-CACHES-DEFAULT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULT" NULL 2))
    (CL:SETQ
     SYM-CACHES-DEFAULT-INFERENCE-CACHE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULT-INFERENCE-CACHE" NULL 0))
    (CL:SETQ
     SYM-CACHES-MONOTONIC?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MONOTONIC?" NULL 0))
    (CL:SETQ
     SYM-CACHES-UP-TO-DATE-INFERENCES?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TO-DATE-INFERENCES?" NULL 0))
    (CL:SETQ
     SGT-CACHES-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-CACHES-WORLD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-CACHES-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
    (CL:SETQ SGT-CACHES-CLASH (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASH" NULL 1))
    (CL:SETQ
     SYM-CACHES-PROPAGATE-CONSTRAINTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPAGATE-CONSTRAINTS" NULL 0))
    (CL:SETQ
     KWD-CACHES-COMMON-LISP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
    (CL:SETQ
     KWD-CACHES-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     SYM-CACHES-EVALUATOR-WRAPPER-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "EVALUATOR-WRAPPER-CODE"
      (GET-MODULE "/STELLA" TRUE)
      0)))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-INFERENCE-CACHE"
        "MODULE"
        "(DEFUN (LOOKUP-INFERENCE-CACHE WORLD) ((MODULE MODULE) (KIND KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-INFERENCE-CACHE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-INFERENCE-CACHE"
        "MODULE"
        "(DEFUN (CREATE-INFERENCE-CACHE WORLD) ((MODULE MODULE) (KIND KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-INFERENCE-CACHE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-INFERENCE-CACHE"
        "MODULE"
        "(DEFUN (GET-INFERENCE-CACHE WORLD) ((MODULE MODULE) (KIND KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-INFERENCE-CACHE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESTROY-INFERENCE-CACHE"
        "WORLD"
        "(DEFUN DESTROY-INFERENCE-CACHE ((WORLD WORLD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESTROY-INFERENCE-CACHE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CHECK-FOR-OUT-OF-DATE-INFERENCE-CACHE"
        NULL
        "(DEFUN CHECK-FOR-OUT-OF-DATE-INFERENCE-CACHE ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CHECK-FOR-OUT-OF-DATE-INFERENCE-CACHE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-QUERY-CONTEXT"
        NULL
        "(DEFUN (GET-QUERY-CONTEXT CONTEXT) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-QUERY-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-TOP-LEVEL-UPDATE-CONTEXT"
        NULL
        "(DEFUN (GET-TOP-LEVEL-UPDATE-CONTEXT CONTEXT) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-TOP-LEVEL-UPDATE-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-CONSTRAINT-PROPAGATION-WORLD"
        "CONTEXT"
        "(DEFMETHOD (GET-CONSTRAINT-PROPAGATION-WORLD WORLD) ((SELF CONTEXT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-CONSTRAINT-PROPAGATION-WORLD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-CONSTRAINT-PROPAGATION-WORLD"
        "MODULE"
        "(DEFMETHOD (GET-CONSTRAINT-PROPAGATION-WORLD WORLD) ((SELF MODULE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-CONSTRAINT-PROPAGATION-WORLD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-CACHED-INFERENCES"
        "WORLD"
        "(DEFUN INHERIT-CACHED-INFERENCES ((FROMWORLD WORLD) (TOWORLD WORLD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-CACHED-INFERENCES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-TRUTH-VALUE-UPDATE"
        "PROPOSITION"
        "(DEFUN INHERIT-TRUTH-VALUE-UPDATE ((PROPOSITION PROPOSITION) (TOWORLD WORLD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-TRUTH-VALUE-UPDATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-VARIABLE-VALUE-UPDATE"
        "SKOLEM"
        "(DEFUN INHERIT-VARIABLE-VALUE-UPDATE ((SKOLEM SKOLEM) (TOWORLD WORLD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-VARIABLE-VALUE-UPDATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DO-PROPAGATE-CONSTRAINTS"
        "CONTEXT"
        "(DEFUN DO-PROPAGATE-CONSTRAINTS ((CONTEXT CONTEXT)) :DOCUMENTATION \"Trigger constraint propagation over all propositions
in the module or world `context'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DO-PROPAGATE-CONSTRAINTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PROPAGATE-CONSTRAINTS"
        "ARGUMENT-LIST"
        "(DEFUN PROPAGATE-CONSTRAINTS (|&REST| (NAME NAME)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Trigger constraint propagation over all propositions of module `name'.
If no `name' is supplied, the current module will be used.  This also
enables incremental constraint propagation for future monotonic updates to
the module.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of a function value, all cached inferences will be discarded
and constraint propagation will be turned off until this function is
called again.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%PROPAGATE-CONSTRAINTS))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-CACHES-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE
       (CL:FUNCTION PROPAGATE-CONSTRAINTS-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DO-ENABLE-CONSTRAINT-PROPAGATION"
        "CONTEXT"
        "(DEFUN DO-ENABLE-CONSTRAINT-PROPAGATION ((SELF CONTEXT)) :DOCUMENTATION \"Find or create a strict inference cache for context `self',
which will contain the inferences derived from future updates to `self'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DO-ENABLE-CONSTRAINT-PROPAGATION)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-CACHES"
     NULL
     "(DEFUN STARTUP-CACHES ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (REGISTER-NATIVE-NAME
     SYM-CACHES-PROPAGATE-CONSTRAINTS
     KWD-CACHES-COMMON-LISP
     KWD-CACHES-FUNCTION)))
  :VOID)
