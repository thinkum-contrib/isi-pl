;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997                   | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-LOGIC-IN-GOAL-TRACE NULL)
(CL:DEFVAR KWD-LOGIC-IN-CLOSED-WORLD NULL)
(CL:DEFVAR KWD-LOGIC-IN-GOAL-TREE NULL)
(CL:DEFVAR SGT-LOGIC-IN-LOGIC-EXCEPTION NULL)
(CL:DEFVAR SYM-LOGIC-IN-SET-FEATURE NULL)
(CL:DEFVAR KWD-LOGIC-IN-COMMON-LISP NULL)
(CL:DEFVAR KWD-LOGIC-IN-FUNCTION NULL)
(CL:DEFVAR SYM-LOGIC-IN-EVALUATOR-WRAPPER-CODE NULL)
(CL:DEFVAR SYM-LOGIC-IN-UNSET-FEATURE NULL)
(CL:DEFVAR SGT-LOGIC-IN-KEYWORD NULL)
(CL:DEFVAR KWD-LOGIC-IN-REALISTIC NULL)
(CL:DEFVAR SYM-LOGIC-IN-*CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? NULL)
(CL:DEFVAR KWD-LOGIC-IN-BYE NULL)
(CL:DEFVAR KWD-LOGIC-IN-EXIT NULL)
(CL:DEFVAR KWD-LOGIC-IN-HALT NULL)
(CL:DEFVAR KWD-LOGIC-IN-QUIT NULL)
(CL:DEFVAR KWD-LOGIC-IN-STOP NULL)
(CL:DEFVAR SYM-LOGIC-IN-BYE NULL)
(CL:DEFVAR SYM-LOGIC-IN-EXIT NULL)
(CL:DEFVAR SYM-LOGIC-IN-HALT NULL)
(CL:DEFVAR SYM-LOGIC-IN-QUIT NULL)
(CL:DEFVAR SYM-LOGIC-IN-STOP NULL)
(CL:DEFVAR SGT-LOGIC-IN-READ-EXCEPTION NULL)
(CL:DEFVAR KWD-LOGIC-IN-DEFINE NULL)
(CL:DEFVAR SYM-LOGIC-IN-DEFCLASS NULL)
(CL:DEFVAR SYM-LOGIC-IN-DEFSLOT NULL)
(CL:DEFVAR SYM-LOGIC-IN-DEFUN NULL)
(CL:DEFVAR SYM-LOGIC-IN-DEFMETHOD NULL)
(CL:DEFVAR SYM-LOGIC-IN-DEFMODULE NULL)
(CL:DEFVAR SYM-LOGIC-IN-IN-MODULE NULL)
(CL:DEFVAR SGT-LOGIC-IN-CLASS NULL)
(CL:DEFVAR SGT-LOGIC-IN-STORAGE-SLOT NULL)
(CL:DEFVAR SGT-LOGIC-IN-METHOD-SLOT NULL)
(CL:DEFVAR SGT-LOGIC-IN-STRING-WRAPPER NULL)
(CL:DEFVAR SGT-LOGIC-IN-MODULE NULL)
(CL:DEFVAR SGT-LOGIC-IN-VOID NULL)
(CL:DEFVAR SGT-LOGIC-IN-TRANSLATION-UNIT NULL)
(CL:DEFVAR SGT-LOGIC-IN-CONS NULL)
(CL:DEFVAR KWD-LOGIC-IN-FINALIZE NULL)
(CL:DEFVAR SYM-LOGIC-IN-CLEAR-MODULE NULL)
(CL:DEFVAR SYM-LOGIC-IN-IN-DIALECT NULL)
(CL:DEFVAR SYM-LOGIC-IN-LOAD NULL)
(CL:DEFVAR SYM-LOGIC-IN-*DEMO-LEVEL* NULL)
(CL:DEFVAR SYM-LOGIC-IN-FALSE NULL)
(CL:DEFVAR SGT-LOGIC-IN-INTEGER-WRAPPER NULL)
(CL:DEFVAR SYM-LOGIC-IN-DEMO NULL)
(CL:DEFVAR SGT-LOGIC-IN-STRING NULL)
(CL:DEFVAR SGT-LOGIC-IN-CONTEXT NULL)
(CL:DEFVAR SYM-LOGIC-IN-SORT? NULL)
(CL:DEFVAR SYM-LOGIC-IN-RELATION-PARAMETER-NAMES NULL)
(CL:DEFVAR KWD-LOGIC-IN-KIF NULL)
(CL:DEFVAR SYM-LOGIC-IN-?SELF NULL)
(CL:DEFVAR SYM-LOGIC-IN-SELF NULL)
(CL:DEFVAR SYM-LOGIC-IN-SELF-VARIABLE NULL)
(CL:DEFVAR SYM-LOGIC-IN-?VALUE NULL)
(CL:DEFVAR SYM-LOGIC-IN-VALUE NULL)
(CL:DEFVAR SYM-LOGIC-IN-VALUE-VARIABLE NULL)
(CL:DEFVAR SYM-LOGIC-IN-DEFFUNCTION NULL)
(CL:DEFVAR SGT-LOGIC-IN-SYMBOL NULL)
(CL:DEFVAR SGT-LOGIC-IN-TYPE-SPEC NULL)
(CL:DEFVAR SGT-LOGIC-IN-UNKNOWN NULL)
(CL:DEFVAR KWD-LOGIC-IN-POLYMORPHIC? NULL)
(CL:DEFVAR KWD-LOGIC-IN-TYPE NULL)
(CL:DEFVAR SGT-LOGIC-IN-BOOLEAN NULL)
(CL:DEFVAR SYM-LOGIC-IN-BOOLEAN NULL)
(CL:DEFVAR KWD-LOGIC-IN-ABSTRACT? NULL)
(CL:DEFVAR SYM-LOGIC-IN-TRUE NULL)
(CL:DEFVAR KWD-LOGIC-IN-SELF-VARIABLE NULL)
(CL:DEFVAR SYM-LOGIC-IN-VARIABLE-ARITY? NULL)
(CL:DEFVAR SGT-LOGIC-IN-COMPOUND-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-LOGIC-IN-SLOT-TYPE-SPECIFIER NULL)
(CL:DEFVAR KWD-LOGIC-IN-DOCUMENTATION NULL)
(CL:DEFVAR SYM-LOGIC-IN-DOCUMENTATION NULL)
(CL:DEFVAR KWD-LOGIC-IN-SINGLE-VALUED? NULL)
(CL:DEFVAR KWD-LOGIC-IN-PROPERTIES NULL)
(CL:DEFVAR SGT-LOGIC-IN-LIST NULL)
(CL:DEFVAR SYM-LOGIC-IN-PROPERTIES NULL)
(CL:DEFVAR KWD-LOGIC-IN-META-ATTRIBUTES NULL)
(CL:DEFVAR SGT-LOGIC-IN-KEY-VALUE-LIST NULL)
(CL:DEFVAR SYM-LOGIC-IN-META-ATTRIBUTES NULL)
(CL:DEFVAR SYM-LOGIC-IN-RELATION-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-LOGIC-IN-&REST NULL)
(CL:DEFVAR SYM-LOGIC-IN-ARGUMENT-LIST NULL)
(CL:DEFVAR SYM-LOGIC-IN-OF NULL)
(CL:DEFVAR SGT-LOGIC-IN-SLOT NULL)
(CL:DEFVAR SYM-LOGIC-IN-RELATION-ORIGINATED-PROPOSITIONS NULL)
(CL:DEFVAR SGT-LOGIC-IN-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SYM-LOGIC-IN-DEFINITION-STRING NULL)
(CL:DEFVAR SYM-LOGIC-IN-SLOT-OPTION-KEYWORD NULL)
(CL:DEFVAR SGT-LOGIC-IN-TABLE NULL)
(CL:DEFVAR SYM-LOGIC-IN-UNKNOWN NULL)
(CL:DEFVAR SGT-LOGIC-IN-TYPE NULL)
(CL:DEFVAR SYM-LOGIC-IN-AND NULL)
(CL:DEFVAR SYM-LOGIC-IN-SETOFALL NULL)
(CL:DEFVAR SYM-LOGIC-IN-KAPPA NULL)
(CL:DEFVAR SYM-LOGIC-IN-= NULL)
(CL:DEFVAR SYM-LOGIC-IN-AXIOMS-STRING NULL)
(CL:DEFVAR SYM-LOGIC-IN-FORALL NULL)
(CL:DEFVAR SYM-LOGIC-IN-=> NULL)
(CL:DEFVAR SYM-LOGIC-IN-BAD? NULL)
(CL:DEFVAR KWD-LOGIC-IN-ASSERT-TRUE NULL)
(CL:DEFVAR SYM-LOGIC-IN-DEFINITION NULL)
(CL:DEFVAR SYM-LOGIC-IN-DESCRIPTION NULL)
(CL:DEFVAR KWD-LOGIC-IN-ENUMERATION NULL)
(CL:DEFVAR SGT-LOGIC-IN-PROPOSITION NULL)
(CL:DEFVAR SYM-LOGIC-IN-DEFRELATION NULL)
(CL:DEFVAR SYM-LOGIC-IN-DEFCONCEPT NULL)
(CL:DEFVAR SYM-LOGIC-IN-CC NULL)
(CL:DEFVAR SGT-LOGIC-IN-FUNCTION NULL)
(CL:DEFVAR SYM-LOGIC-IN-HELP NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *TOPLEVELPROPOSITIONS*
  NULL-STRING-WRAPPER
  NIL-LIST
  NULL-BOOLEAN-WRAPPER
  *STELLA-VERSION-STRING*
  *POWERLOOM-VERSION-STRING*
  *INPUTECHOSTREAM*
  *CURRENTFILE*
  *LOGIC-DIALECT*
  *TRANSLATIONUNITS*
  *TRANSLATIONPHASE*
  *MODULE*
  STANDARD-INPUT
  *UNFINALIZED-DEFINED-RELATIONS*
  *EXCEPTIONHANDLERADDRESS*
  *EXCEPTION*
  *EXCEPTION-TYPE*
  STANDARD-OUTPUT
  EOL))

;;; (DEFGLOBAL *AVAILABLE-POWERLOOM-FEATURES* ...)

(CL:DEFVAR *AVAILABLE-POWERLOOM-FEATURES* NULL
  "List of PowerLoom environment features.")

;;; (DEFGLOBAL *CURRENT-POWERLOOM-FEATURES* ...)

(CL:DEFVAR *CURRENT-POWERLOOM-FEATURES* NULL
  "List of currently enabled PowerLoom environment features.")

;;; (DEFGLOBAL *DEFAULT-POWERLOOM-FEATURES* ...)

(CL:DEFVAR *DEFAULT-POWERLOOM-FEATURES* NULL
  "List of PowerLoom environment features enabled upon call to
'reset-features'.")

;;; (DEFUN PRINT-FEATURES ...)

(CL:DEFUN PRINT-FEATURES ()
  "Print the currently enabled and available PowerLoom environment features."
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "Currently enabled PowerLoom features:" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:WRITE-STRING "   " %%STREAM)
   (PRINT-OBJECT *CURRENT-POWERLOOM-FEATURES* %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:WRITE-STRING "Available PowerLoom features:" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:WRITE-STRING "   " %%STREAM)
   (PRINT-OBJECT *AVAILABLE-POWERLOOM-FEATURES* %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  :VOID)

;;; (DEFUN SET-POWERLOOM-FEATURE ...)

(CL:DEFUN SET-POWERLOOM-FEATURE (FEATURE)
  "Enable the PowerLoom environment feature `feature'."
  (CL:WHEN
   (CL:EQ (MEMBER? *CURRENT-POWERLOOM-FEATURES* FEATURE) 0)
   (CL:COND
    ((CL:EQ FEATURE KWD-LOGIC-IN-GOAL-TRACE)
     (%%ADD-TRACE (CONS-LIST KWD-LOGIC-IN-GOAL-TREE)))
    ((CL:EQ FEATURE KWD-LOGIC-IN-CLOSED-WORLD))
    (CL:T
     (CL:WARN "No such PowerLoom environment feature: `~A'" FEATURE)
     (PRINT-FEATURES)
     (CL:RETURN-FROM SET-POWERLOOM-FEATURE)))
   (INSERT *CURRENT-POWERLOOM-FEATURES* FEATURE))
  :VOID)

;;; (DEFUN (SET-FEATURE (LIST OF KEYWORD)) ...)

(CL:DEFUN %%SET-FEATURE (FEATURES)
  "Enable the PowerLoom environment feature(s) named by `features'.
Return the list of enabled features.  Calling `set-feature' without any
arguments can be used to display the currently enabled features.
The following features are supported:

`closed-world': Enables closed-world reasoning.  NOT YET IMPLEMENTED!

`goal-trace': Enables the generation of goal trace information during
inference."
  (CL:PROGN
   (CL:LET*
    ((*PENDINGEXCEPTIONHANDLER?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PENDINGEXCEPTIONHANDLER?*))
    (CL:CATCH
     *EXCEPTIONHANDLERADDRESS*
     (CL:PROGN
      (CL:LET*
       ((FEATURENAME NULL) (ITER-001 FEATURES))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ FEATURENAME (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (SET-POWERLOOM-FEATURE (KEYWORDIFY (COERCE-TO-STRING FEATURENAME)))))
      (CL:SETQ *EXCEPTION* NULL))))
   (CL:WHEN
    (CL:NOT (CL:EQ *EXCEPTION* NULL))
    (CL:COND
     ((CL:EQ (SUBTYPE-OF? *EXCEPTION-TYPE* SGT-LOGIC-IN-LOGIC-EXCEPTION) 1))
     (CL:T (RESIGNAL)))))
  (CL:RETURN-FROM %%SET-FEATURE *CURRENT-POWERLOOM-FEATURES*)
  :VOID)

(CL:DEFUN SET-FEATURE-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM SET-FEATURE-EVALUATOR-WRAPPER (%%SET-FEATURE ARGUMENTS))
  :VOID)

(CL:DEFMACRO SET-FEATURE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Enable the PowerLoom environment feature(s) named by `features'.
Return the list of enabled features.  Calling `set-feature' without any
arguments can be used to display the currently enabled features.
The following features are supported:

`closed-world': Enables closed-world reasoning.  NOT YET IMPLEMENTED!

`goal-trace': Enables the generation of goal trace information during
inference."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/SET-FEATURE)) (CL:MACRO-FUNCTION (CL:QUOTE SET-FEATURE)))

;;; (DEFUN UNSET-POWERLOOM-FEATURE ...)

(CL:DEFUN UNSET-POWERLOOM-FEATURE (FEATURE)
  "Disable the PowerLoom environment feature `feature'."
  (CL:IF
   (CL:EQ (MEMBER? *CURRENT-POWERLOOM-FEATURES* FEATURE) 1)
   (CL:COND
    ((CL:EQ FEATURE KWD-LOGIC-IN-GOAL-TRACE)
     (%%DROP-TRACE (CONS-LIST KWD-LOGIC-IN-GOAL-TREE)))
    ((CL:EQ FEATURE KWD-LOGIC-IN-CLOSED-WORLD))
    (CL:T (CL:ERROR "`~A' is not a valid case option" FEATURE)))
   (CL:WHEN
    (CL:EQ (MEMBER? *AVAILABLE-POWERLOOM-FEATURES* FEATURE) 0)
    (CL:WARN "No such PowerLoom environment feature: `~A'" FEATURE)
    (PRINT-FEATURES)))
  (REMOVE *CURRENT-POWERLOOM-FEATURES* FEATURE)
  :VOID)

;;; (DEFUN (UNSET-FEATURE (LIST OF KEYWORD)) ...)

(CL:DEFUN %%UNSET-FEATURE (FEATURES)
  "Disable the PowerLoom environment feature(s) named by `features'.
Return the list of enabled features.  Calling `unset-feature' without any
arguments can be used to display the currently enabled features.
See `set-feature' for a description of supported features."
  (CL:PROGN
   (CL:LET*
    ((*PENDINGEXCEPTIONHANDLER?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PENDINGEXCEPTIONHANDLER?*))
    (CL:CATCH
     *EXCEPTIONHANDLERADDRESS*
     (CL:PROGN
      (CL:LET*
       ((FEATURENAME NULL) (ITER-001 FEATURES))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ FEATURENAME (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (UNSET-POWERLOOM-FEATURE
         (KEYWORDIFY (COERCE-TO-STRING FEATURENAME)))))
      (CL:SETQ *EXCEPTION* NULL))))
   (CL:WHEN
    (CL:NOT (CL:EQ *EXCEPTION* NULL))
    (CL:COND
     ((CL:EQ (SUBTYPE-OF? *EXCEPTION-TYPE* SGT-LOGIC-IN-LOGIC-EXCEPTION) 1))
     (CL:T (RESIGNAL)))))
  (CL:RETURN-FROM %%UNSET-FEATURE *CURRENT-POWERLOOM-FEATURES*)
  :VOID)

(CL:DEFUN UNSET-FEATURE-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM UNSET-FEATURE-EVALUATOR-WRAPPER (%%UNSET-FEATURE ARGUMENTS))
  :VOID)

(CL:DEFMACRO UNSET-FEATURE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Disable the PowerLoom environment feature(s) named by `features'.
Return the list of enabled features.  Calling `unset-feature' without any
arguments can be used to display the currently enabled features.
See `set-feature' for a description of supported features."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/UNSET-FEATURE)) (CL:MACRO-FUNCTION (CL:QUOTE UNSET-FEATURE)))

;;; (DEFUN (RESET-FEATURES (LIST OF KEYWORD)) ...)

(CL:DEFUN RESET-FEATURES ()
  "Reset the PowerLoom environment features to their default settings."
  (CL:LET*
   ((F NULL)
    (ITER-001
     (CLSYS-SVAL LIST THE-CONS-LIST (COPY *CURRENT-POWERLOOM-FEATURES*))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ F (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-LOGIC-IN-KEYWORD))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:EQ (MEMBER? *DEFAULT-POWERLOOM-FEATURES* F) 0)
     (UNSET-POWERLOOM-FEATURE F))))
  (CL:LET*
   ((F NULL)
    (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST *DEFAULT-POWERLOOM-FEATURES*)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-002 NIL))
    DO
    (CL:PROGN
     (CL:SETQ F (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-LOGIC-IN-KEYWORD))
     (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
    (CL:WHEN
     (CL:EQ (MEMBER? *CURRENT-POWERLOOM-FEATURES* F) 0)
     (SET-POWERLOOM-FEATURE F))))
  (CL:RETURN-FROM RESET-FEATURES *CURRENT-POWERLOOM-FEATURES*)
  :VOID)

;;; (VERBATIM :COMMON-LISP ...)

(CL:UNLESS (CL:FIND-PACKAGE "POWERLOOM-USER") (CL:DEFPACKAGE "POWERLOOM-USER" (:NICKNAMES "PL-USER")))

;;; (DEFGLOBAL *LOGIC-PROMPT* ...)

(CL:DEFVAR *LOGIC-PROMPT* "|= "
  "The prompt used by the PowerLoom listener.")

;;; (DEFUN PRINT-LOGIC-PROMPT ...)

(CL:DEFUN PRINT-LOGIC-PROMPT ()
  (CL:WRITE-STRING
   *LOGIC-PROMPT*
   (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
  :VOID)

;;; (DEFGLOBAL *LOGIC-COMMAND-RESULT-INDENT* ...)

(CL:DEFVAR *LOGIC-COMMAND-RESULT-INDENT* "")

;;; (DEFUN PRINT-LOGIC-COMMAND-RESULT ...)

(CL:DEFUN PRINT-LOGIC-COMMAND-RESULT (RESULT RESULTTYPE)
  (CL:SETQ RESULTTYPE RESULTTYPE)
  (CL:LET*
   ((*PRINTMODE* KWD-LOGIC-IN-REALISTIC) (*PRETTYPRINTLOGICALFORMS?* TRUE))
   (CL:DECLARE (CL:SPECIAL *PRINTMODE* *PRETTYPRINTLOGICALFORMS?*))
   (CL:WHEN
    (CL:NOT (CL:EQ RESULT NULL))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING *LOGIC-COMMAND-RESULT-INDENT* %%STREAM)
     (PRINT-OBJECT RESULT %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))))
  :VOID)

;;; (DEFSPECIAL *CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? ...)

(CL:DEFVAR *CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? FALSE
  "If TRUE exiting from the logic-command loop (or PowerLoom
listener) will be protected by a confirmation dialog.  This is mainly useful
for C++ where exiting the listener will also exit the program.")

(CL:DEFUN READ-*CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? ()
  (CL:RETURN-FROM
   READ-*CAREFUL-LOGIC-COMMAND-LOOP-EXIT*?
   *CAREFUL-LOGIC-COMMAND-LOOP-EXIT*?)
  :VOID)

(CL:DEFUN WRITE-*CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? (VALUE)
  (CL:SETQ *CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? VALUE)
  (CL:RETURN-FROM WRITE-*CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? VALUE)
  :VOID)

;;; (DEFUN (LOGIC-COMMAND-LOOP-EXIT? BOOLEAN BOOLEAN) ...)

(CL:DEFUN LOGIC-COMMAND-LOOP-EXIT? (COMMAND)
  (CL:LET*
   ((EXIT? FALSE))
   (CL:LET*
    ((COMMAND-001 COMMAND))
    (CL:COND
     ((CL:EQ (KEYWORD? COMMAND) 1)
      (CL:LET*
       ((COMMAND NULL))
       (CL:SETQ COMMAND COMMAND-001)
       (CL:COND
        ((CL:OR
          (CL:EQ COMMAND KWD-LOGIC-IN-BYE)
          (CL:EQ COMMAND KWD-LOGIC-IN-EXIT)
          (CL:EQ COMMAND KWD-LOGIC-IN-HALT)
          (CL:EQ COMMAND KWD-LOGIC-IN-QUIT)
          (CL:EQ COMMAND KWD-LOGIC-IN-STOP))
         (CL:SETQ EXIT? TRUE))
        (CL:T NULL))))
     ((CL:EQ (SYMBOL? COMMAND) 1)
      (CL:LET*
       ((COMMAND NULL))
       (CL:SETQ COMMAND COMMAND-001)
       (CL:COND
        ((CL:OR
          (CL:EQ COMMAND SYM-LOGIC-IN-BYE)
          (CL:EQ COMMAND SYM-LOGIC-IN-EXIT)
          (CL:EQ COMMAND SYM-LOGIC-IN-HALT)
          (CL:EQ COMMAND SYM-LOGIC-IN-QUIT)
          (CL:EQ COMMAND SYM-LOGIC-IN-STOP))
         (CL:SETQ EXIT? TRUE))
        (CL:T NULL))))
     (CL:T NULL)))
   (CL:WHEN
    (CL:AND (CL:EQ EXIT? 1) (CL:EQ *CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? 1))
    (CL:SETQ EXIT? (YES-OR-NO? "Really exit? (yes or no) "))
    (CL:WHEN
     (CL:EQ EXIT? 1)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)))
    (CL:RETURN-FROM LOGIC-COMMAND-LOOP-EXIT? (CL:VALUES EXIT? TRUE)))
   (CL:RETURN-FROM LOGIC-COMMAND-LOOP-EXIT? (CL:VALUES EXIT? EXIT?)))
  :VOID)

;;; (DEFUN LOGIC-COMMAND-LOOP ...)

(CL:DEFUN LOGIC-COMMAND-LOOP ()
  (CL:LET*
   ((COMMAND NULL)
    (RESULT NULL)
    (RESULTTYPE NULL)
    (EXIT? FALSE)
    (EXITCOMMAND? FALSE)
    (ERROR? FALSE))
   (CL:LET*
    ((MODULE-001 *MODULE*))
    (CL:LET*
     ((*MODULE* MODULE-001) (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CHANGE-MODULE "/PL-USER")
     (CL:LOOP
      (CL:TAGBODY
       (CL:PROGN
        (CL:LET*
         ((*PENDINGEXCEPTIONHANDLER?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PENDINGEXCEPTIONHANDLER?*))
         (CL:CATCH
          *EXCEPTIONHANDLERADDRESS*
          (CL:PROGN
           (CL:PROGN
            (CL:LET
             ((%%STREAM
               (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM))
            (PRINT-LOGIC-PROMPT)
            (CL:SETQ
             COMMAND
             (READ-STELLA-EXPRESSION
              (CLSYS-SVAL INPUT-STREAM NATIVE-STREAM STANDARD-INPUT)))
            (CL:LET
             ((%%STREAM
               (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
             (CL:TERPRI %%STREAM)
             (CL:FORCE-OUTPUT %%STREAM))
            (CL:MULTIPLE-VALUE-SETQ
             (EXIT? EXITCOMMAND?)
             (LOGIC-COMMAND-LOOP-EXIT? COMMAND))
            (CL:WHEN (CL:EQ EXIT? 1) (CL:RETURN))
            (CL:WHEN (CL:EQ EXITCOMMAND? 1) (CL:GO :CONTINUE))
            (CL:MULTIPLE-VALUE-SETQ
             (RESULT RESULTTYPE ERROR?)
             (EVALUATE-LOGIC-COMMAND COMMAND TRUE))
            (CL:WHEN
             (CL:EQ ERROR? 0)
             (PRINT-LOGIC-COMMAND-RESULT RESULT RESULTTYPE)))
           (CL:SETQ *EXCEPTION* NULL))))
        (CL:WHEN
         (CL:NOT (CL:EQ *EXCEPTION* NULL))
         (CL:COND
          ((CL:EQ
            (SUBTYPE-OF? *EXCEPTION-TYPE* SGT-LOGIC-IN-READ-EXCEPTION)
            1)
           (CL:WHEN
            (CL:EQ (EMPTY? *UNFINALIZED-DEFINED-RELATIONS*) 0)
            (CL:LET* ((BADRELATION (POP *UNFINALIZED-DEFINED-RELATIONS*))))))
          ((CL:EQ TRUE 1)
           (CL:LET*
            ((E *EXCEPTION*))
            (CL:LET
             ((%%STREAM
               (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
             (CL:WRITE-STRING "logic-command-loop: caught " %%STREAM)
             (PRINT-OBJECT (PRIMARY-TYPE E) %%STREAM)))))))
       :CONTINUE)))))
  :VOID)

;;; (DEFUN (EVALUATE-LOGIC-COMMAND OBJECT TYPE-SPEC BOOLEAN) ...)

(CL:DEFUN EVALUATE-LOGIC-COMMAND (COMMAND FINALIZE?)
  (CL:LET*
   ((*TRANSLATIONERRORS* 0)
    (*TRANSLATIONWARNINGS* 0)
    (*IGNORETRANSLATIONERRORS?* FALSE)
    (*TRANSLATIONUNITS* NULL)
    (*TRANSLATIONPHASE* KWD-LOGIC-IN-DEFINE)
    (*EVALUATIONTREE* NULL))
   (CL:DECLARE
    (CL:SPECIAL
     *TRANSLATIONERRORS*
     *TRANSLATIONWARNINGS*
     *IGNORETRANSLATIONERRORS?*
     *TRANSLATIONUNITS*
     *TRANSLATIONPHASE*
     *EVALUATIONTREE*))
   (CL:LET*
    ((OPERATOR NULL) (RESULT NULL) (RESULTTYPE NULL) (ERROR? FALSE))
    (CL:LET*
     ((COMMAND-001 COMMAND))
     (CL:COND
      ((CL:EQ (CONS? COMMAND) 1)
       (CL:LET*
        ((COMMAND NULL))
        (CL:SETQ COMMAND COMMAND-001)
        (CL:SETQ OPERATOR (CLSYS-SVAL CONS VALUE COMMAND))
        (CL:LET*
         ((OPERATOR-001 OPERATOR))
         (CL:COND
          ((CL:EQ (SYMBOL? OPERATOR) 1)
           (CL:LET*
            ((OPERATOR NULL))
            (CL:SETQ OPERATOR OPERATOR-001)
            (CL:COND
             ((CL:EQ OPERATOR SYM-LOGIC-IN-DEFCLASS)
              (CL:SETQ RESULT (DEFINE-CLASS-FROM-PARSE-TREE COMMAND))
              (CL:SETQ RESULTTYPE SGT-LOGIC-IN-CLASS))
             ((CL:EQ OPERATOR SYM-LOGIC-IN-DEFSLOT)
              (CL:SETQ RESULT (DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE COMMAND))
              (CL:SETQ RESULTTYPE SGT-LOGIC-IN-STORAGE-SLOT))
             ((CL:OR
               (CL:EQ OPERATOR SYM-LOGIC-IN-DEFUN)
               (CL:EQ OPERATOR SYM-LOGIC-IN-DEFMETHOD))
              (CL:SETQ RESULT (DEFINE-METHOD-FROM-PARSE-TREE COMMAND))
              (CL:SETQ RESULTTYPE SGT-LOGIC-IN-METHOD-SLOT))
             ((CL:EQ OPERATOR SYM-LOGIC-IN-DEFMODULE)
              (CL:SETQ
               RESULT
               (DEFINE-MODULE
                (CLSYS-SVAL
                 STRING-WRAPPER
                 WRAPPER-VALUE
                 (CAST (SECOND COMMAND) SGT-LOGIC-IN-STRING-WRAPPER))
                (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST COMMAND))))
              (CL:SETQ RESULTTYPE SGT-LOGIC-IN-MODULE))
             ((CL:EQ OPERATOR SYM-LOGIC-IN-IN-MODULE)
              (HANDLE-IN-MODULE-TREE COMMAND FALSE))
             (CL:T
              (CL:COND
               ((CL:EQ (DECLARATION-TREE? COMMAND) 1)
                (CL:SETQ *TRANSLATIONUNITS* (LIST))
                (WALK-TOP-LEVEL-TREE COMMAND FALSE)
                (CL:CASE
                 (LENGTH (REVERSE *TRANSLATIONUNITS*))
                 (0 (CL:SETQ ERROR? TRUE))
                 (1
                  (CL:SETQ
                   RESULT
                   (CLSYS-SVAL
                    TRANSLATION-UNIT
                    THE-OBJECT
                    (FIRST *TRANSLATIONUNITS*)))
                  (CL:SETQ
                   RESULTTYPE
                   (CL:IF
                    (CL:NOT (CL:EQ RESULT NULL))
                    (PRIMARY-TYPE RESULT)
                    SGT-LOGIC-IN-VOID)))
                 (CL:OTHERWISE
                  (CL:LET*
                   ((RESULTS NIL))
                   (CL:LET*
                    ((UNIT NULL)
                     (ITER-001
                      (CLSYS-SVAL LIST THE-CONS-LIST *TRANSLATIONUNITS*))
                     (COLLECT-001 NULL))
                    (CL:LOOP
                     WHILE
                     (CL:NOT (CL:EQ ITER-001 NIL))
                     DO
                     (CL:PROGN
                      (CL:SETQ
                       UNIT
                       (CAST
                        (CLSYS-SVAL CONS VALUE ITER-001)
                        SGT-LOGIC-IN-TRANSLATION-UNIT))
                      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
                     (CL:IF
                      (CL:EQ COLLECT-001 NULL)
                      (CL:PROGN
                       (CL:SETQ
                        COLLECT-001
                        (CONS
                         (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT)
                         NIL))
                       (CL:IF
                        (CL:EQ RESULTS NIL)
                        (CL:SETQ RESULTS COLLECT-001)
                        (ADD-CONS-TO-END-OF-CONS-LIST RESULTS COLLECT-001)))
                      (CL:PROGN
                       (CL:SETF
                        (CLSYS-SVAL CONS REST COLLECT-001)
                        (CONS
                         (CLSYS-SVAL TRANSLATION-UNIT THE-OBJECT UNIT)
                         NIL))
                       (CL:SETQ
                        COLLECT-001
                        (CLSYS-SVAL CONS REST COLLECT-001))))))
                   (CL:SETQ RESULT RESULTS)
                   (CL:SETQ RESULTTYPE SGT-LOGIC-IN-CONS))))
                (CL:LET*
                 ((UNIT NULL)
                  (ITER-002
                   (CLSYS-SVAL LIST THE-CONS-LIST *TRANSLATIONUNITS*)))
                 (CL:LOOP
                  WHILE
                  (CL:NOT (CL:EQ ITER-002 NIL))
                  DO
                  (CL:PROGN
                   (CL:SETQ
                    UNIT
                    (CAST
                     (CLSYS-SVAL CONS VALUE ITER-002)
                     SGT-LOGIC-IN-TRANSLATION-UNIT))
                   (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
                  (FREE UNIT)))
                (FREE *TRANSLATIONUNITS*))
               ((CL:OR
                 (CL:EQ
                  (STRING-EQL?
                   (CLSYS-SVAL SYMBOL SYMBOL-NAME OPERATOR)
                   "IN-PACKAGE")
                  1)
                 (CL:EQ
                  (STRING-EQL?
                   (CLSYS-SVAL SYMBOL SYMBOL-NAME OPERATOR)
                   "in-package")
                  1))
                NULL)
               (CL:T
                (CL:MULTIPLE-VALUE-SETQ
                 (RESULT RESULTTYPE ERROR?)
                 (%%EVALUATE COMMAND))))))))
          (CL:T
           (CL:MULTIPLE-VALUE-SETQ
            (RESULT RESULTTYPE ERROR?)
            (%%EVALUATE COMMAND)))))))
      ((CL:EQ (KEYWORD? COMMAND) 1)
       (CL:LET*
        ((COMMAND NULL))
        (CL:SETQ COMMAND COMMAND-001)
        (CL:SETQ RESULT COMMAND)))
      ((CL:EQ (SURROGATE? COMMAND) 1)
       (CL:LET*
        ((COMMAND NULL))
        (CL:SETQ COMMAND COMMAND-001)
        (CL:SETQ RESULT COMMAND)))
      (CL:T
       (CL:MULTIPLE-VALUE-SETQ
        (RESULT RESULTTYPE ERROR?)
        (%%EVALUATE COMMAND)))))
    (CL:SETQ
     ERROR?
     (CL:IF
      (CL:OR (CL:EQ ERROR? 1) (CL:EQ (TRANSLATION-ERRORS?) 1))
      TRUE
      FALSE))
    (CL:WHEN
     (CL:AND (CL:EQ ERROR? 0) (CL:EQ FINALIZE? 1))
     (CL:SETQ *TRANSLATIONPHASE* KWD-LOGIC-IN-FINALIZE)
     (FINALIZE-RELATIONS))
    (CL:RETURN-FROM
     EVALUATE-LOGIC-COMMAND
     (CL:VALUES RESULT RESULTTYPE ERROR?))))
  :VOID)

;;; (DEFUN LOAD ...)

(CL:DEFUN %%LOAD (FILE)
  "Read logic commands from `file' and evaluate them."
  (CL:WHEN
   (CL:EQ (PROBE-FILE? FILE) 0)
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING ">> ERROR: File '" %%STREAM)
    (CL:WRITE-STRING FILE %%STREAM)
    (CL:WRITE-STRING "' does not exist." %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (CL:RETURN-FROM %%LOAD))
  (CL:LET*
   ((TOPLEVELINVOCATION? (NULL? *CURRENTFILE*))
    (CURRENTDIALECT *LOGIC-DIALECT*)
    (SKIPCOMMAND? FALSE)
    (SEENINMODULE? FALSE)
    (COMMANDS NIL))
   (CL:LET*
    ((*CURRENTFILE* (FILE-BASE-NAME FILE)) (*LOGIC-DIALECT* CURRENTDIALECT))
    (CL:DECLARE (CL:SPECIAL *CURRENTFILE* *LOGIC-DIALECT*))
    (CL:LET*
     ((MODULE-001 *MODULE*))
     (CL:LET*
      ((*MODULE* MODULE-001) (*CONTEXT* *MODULE*))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (CL:LET*
       ((TREE NULL) (ITER-001 (S-EXPRESSIONS (NEW-INPUT-FILE-STREAM FILE))))
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? ITER-001) 1)
        DO
        (CL:PROGN
         (CL:SETQ TREE (CLSYS-SVAL S-EXPRESSION-ITERATOR VALUE ITER-001)))
        (CL:TAGBODY
         (CL:LET*
          ((TREE-001 TREE))
          (CL:COND
           ((CL:EQ (CONS? TREE) 1)
            (CL:LET*
             ((TREE NULL))
             (CL:SETQ TREE TREE-001)
             (CL:MULTIPLE-VALUE-SETQ
              (SKIPCOMMAND? SEENINMODULE?)
              (HANDLE-IN-MODULE-TREE TREE SEENINMODULE?))
             (CL:WHEN (CL:EQ SKIPCOMMAND? 1) (CL:GO :CONTINUE))
             (CL:LET*
              ((OPERATOR (FIRST TREE)))
              (CL:LET*
               ((OPERATOR-001 OPERATOR))
               (CL:COND
                ((CL:EQ (SYMBOL? OPERATOR) 1)
                 (CL:LET*
                  ((OPERATOR NULL))
                  (CL:SETQ OPERATOR OPERATOR-001)
                  (CL:COND
                   ((CL:OR
                     (CL:EQ OPERATOR SYM-LOGIC-IN-DEFCLASS)
                     (CL:EQ OPERATOR SYM-LOGIC-IN-DEFSLOT)
                     (CL:EQ OPERATOR SYM-LOGIC-IN-DEFUN)
                     (CL:EQ OPERATOR SYM-LOGIC-IN-DEFMETHOD)
                     (CL:EQ OPERATOR SYM-LOGIC-IN-DEFMODULE)
                     (CL:EQ OPERATOR SYM-LOGIC-IN-CLEAR-MODULE))
                    (EVALUATE-LOGIC-COMMAND TREE FALSE)
                    (FREE-PARSE-TREE TREE))
                   ((CL:EQ OPERATOR SYM-LOGIC-IN-IN-DIALECT)
                    (EVALUATE-LOGIC-COMMAND TREE FALSE)
                    (CL:SETQ COMMANDS (CONS TREE COMMANDS)))
                   (CL:T
                    (CL:IF
                     (CL:NOT (CL:EQ (LOOKUP-COMMAND OPERATOR) NULL))
                     (CL:SETQ COMMANDS (CONS TREE COMMANDS))
                     (EVALUATE-LOGIC-COMMAND TREE FALSE))))))
                (CL:T (EVALUATE-LOGIC-COMMAND TREE FALSE)))))))
           (CL:T (EVALUATE-LOGIC-COMMAND TREE FALSE))))
         :CONTINUE)))
      (CL:LET*
       ((*TRANSLATIONPHASE* KWD-LOGIC-IN-FINALIZE))
       (CL:DECLARE (CL:SPECIAL *TRANSLATIONPHASE*))
       (FINALIZE-CLASSES-AND-SLOTS))
      (CL:LET*
       ((TREE NULL) (ITER-002 (REVERSE COMMANDS)))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-002 NIL))
        DO
        (CL:PROGN
         (CL:SETQ TREE (CLSYS-SVAL CONS VALUE ITER-002))
         (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
        (EVALUATE-LOGIC-COMMAND TREE FALSE)))
      (CL:LET*
       ((*TRANSLATIONPHASE* KWD-LOGIC-IN-FINALIZE))
       (CL:DECLARE (CL:SPECIAL *TRANSLATIONPHASE*))
       (FINALIZE-RELATIONS))
      (FREE-CONS-LIST COMMANDS)))
    (CL:WHEN (CL:EQ TOPLEVELINVOCATION? 1) (SWEEP-TRANSIENTS))))
  :VOID)

(CL:DEFUN LOAD-EVALUATOR-WRAPPER (ARGUMENTS)
  (%%LOAD
   (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE (CLSYS-SVAL CONS VALUE ARGUMENTS)))
  :VOID)

(CL:DEFMACRO LOAD (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Read logic commands from `file' and evaluate them."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/LOAD)) (CL:MACRO-FUNCTION (CL:QUOTE LOAD)))

;;; (DEFSPECIAL *DEMO-LEVEL* ...)

(CL:DEFVAR *DEMO-LEVEL* 0)

(CL:DEFUN READ-*DEMO-LEVEL* ()
  (CL:RETURN-FROM READ-*DEMO-LEVEL* *DEMO-LEVEL*)
  :VOID)

(CL:DEFUN WRITE-*DEMO-LEVEL* (VALUE)
  (CL:SETQ *DEMO-LEVEL* VALUE)
  (CL:RETURN-FROM WRITE-*DEMO-LEVEL* VALUE)
  :VOID)

;;; (DEFUN PRINT-DEMO-PROMPT ...)

(CL:DEFUN PRINT-DEMO-PROMPT ()
  (CL:WRITE-STRING
   *LOGIC-PROMPT*
   (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
  :VOID)

;;; (DEFUN (DEMO-SKIP-TO-COMMAND BOOLEAN) ...)

(CL:DEFUN DEMO-SKIP-TO-COMMAND (STREAM)
  (CL:LET*
   ((CHAR NULL-CHARACTER)
    (EOF? FALSE)
    (ECHOSTREAM *INPUTECHOSTREAM*)
    (ECHO? FALSE))
   (CL:LET*
    ((*INPUTECHOSTREAM* NULL))
    (CL:DECLARE (CL:SPECIAL *INPUTECHOSTREAM*))
    (CL:LOOP
     (CL:SETQ *INPUTECHOSTREAM* NULL)
     (CL:MULTIPLE-VALUE-SETQ
      (CHAR EOF?)
      (READ-NEXT-CHARACTER (CLSYS-SVAL INPUT-STREAM NATIVE-STREAM STREAM)))
     (CL:WHEN (CL:EQ EOF? 1) (CL:RETURN-FROM DEMO-SKIP-TO-COMMAND TRUE))
     (CL:WHEN (CL:EQ ECHO? 1) (CL:SETQ *INPUTECHOSTREAM* ECHOSTREAM))
     (CL:CASE
      CHAR
      ((#\  #\Tab #\Newline)
       (CL:WHEN (CL:EQ ECHO? 1) (CL:PRINC CHAR ECHOSTREAM)))
      (#\;
       (CL:SETQ ECHO? TRUE)
       (CL:SETQ *INPUTECHOSTREAM* ECHOSTREAM)
       (CL:PRINC CHAR ECHOSTREAM)
       (CL:LOOP
        (CL:MULTIPLE-VALUE-SETQ
         (CHAR EOF?)
         (READ-NEXT-CHARACTER (CLSYS-SVAL INPUT-STREAM NATIVE-STREAM STREAM)))
        (CL:IF
         (CL:EQ EOF? 1)
         (CL:RETURN-FROM DEMO-SKIP-TO-COMMAND TRUE)
         (CL:WHEN (CL:EQL CHAR #\Newline) (CL:RETURN)))))
      (CL:OTHERWISE
       (UNREAD-CHARACTER CHAR (CLSYS-SVAL INPUT-STREAM NATIVE-STREAM STREAM))
       (CL:RETURN-FROM DEMO-SKIP-TO-COMMAND FALSE))))))
  :VOID)

;;; (DEFUN (DEMO-PAUSE? BOOLEAN BOOLEAN) ...)

(CL:DEFUN DEMO-PAUSE? (PAUSE?)
  (CL:LET*
   ((EXIT? FALSE) (INPUT NULL))
   (CL:COND
    ((CL:EQ PAUSE? 1)
     (CL:WRITE-STRING
      "------ pause ------"
      (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
     (CL:SETQ
      INPUT
      (READ-LINE (CLSYS-SVAL INPUT-STREAM NATIVE-STREAM STANDARD-INPUT)))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (CL:WHEN
      (CL:> (LENGTH INPUT) 0)
      (CL:CASE
       (UPCASE-CHARACTER (CL:CHAR INPUT 0))
       (#\C (CL:SETQ PAUSE? FALSE))
       (#\Q
        (CL:WHEN
         (CL:EQ (Y-OR-N? "Really exit demo? (y or n) ") 1)
         (CL:SETQ PAUSE? FALSE)
         (CL:SETQ EXIT? TRUE)))
       ((#\H #\?)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING "Type `c' to continue without pausing," %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING "     `q' to quit from this demo," %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING "     `?' or `h' to get this message," %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING "     or any other key to continue." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))
        (CL:RETURN-FROM DEMO-PAUSE? (DEMO-PAUSE? PAUSE?)))
       (CL:OTHERWISE NULL))))
    (CL:T
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))))
   (CL:RETURN-FROM DEMO-PAUSE? (CL:VALUES PAUSE? EXIT?)))
  :VOID)

;;; (DEFUN DEMO-FILE ...)

(CL:DEFUN DEMO-FILE (FILE PAUSE?)
  (CL:WHEN
   (CL:EQ (PROBE-FILE? FILE) 0)
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING ">> ERROR: File `" %%STREAM)
    (CL:PRINC FILE %%STREAM)
    (CL:WRITE-STRING "' does not exist." %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (CL:RETURN-FROM DEMO-FILE))
  (CL:LET*
   ((CURRENTLEVEL *DEMO-LEVEL*)
    (COMMAND NULL)
    (RESULT NULL)
    (RESULTTYPE NULL)
    (EXIT? FALSE)
    (ERROR? FALSE)
    (INPUTSTREAM (NEW-INPUT-FILE-STREAM FILE)))
   (CL:LET*
    ((*INPUTECHOSTREAM*
      (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
     (*CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? FALSE)
     (*DEMO-LEVEL* (CL:1+ CURRENTLEVEL)))
    (CL:DECLARE
     (CL:SPECIAL
      *INPUTECHOSTREAM*
      *CAREFUL-LOGIC-COMMAND-LOOP-EXIT*?
      *DEMO-LEVEL*))
    (CL:LET*
     ((MODULE-001 *MODULE*))
     (CL:LET*
      ((*MODULE* MODULE-001) (*CONTEXT* *MODULE*))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (CL:WHEN
       (CL:EQ PAUSE? 1)
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING "Now reading from `" %%STREAM)
        (CL:PRINC FILE %%STREAM)
        (CL:WRITE-STRING "'." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:WRITE-STRING
         "Type `?' at the pause prompt for a list of available commands."
         %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)))
      (CL:LOOP
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (CL:SETQ EXIT? (DEMO-SKIP-TO-COMMAND INPUTSTREAM))
       (PRINT-DEMO-PROMPT)
       (CL:WHEN
        (CL:EQ EXIT? 0)
        (CL:MULTIPLE-VALUE-SETQ
         (COMMAND EXIT?)
         (READ-STELLA-EXPRESSION
          (CLSYS-SVAL INPUT-STREAM NATIVE-STREAM INPUTSTREAM))))
       (CL:WHEN
        (CL:OR (CL:EQ EXIT? 1) (CL:EQ (LOGIC-COMMAND-LOOP-EXIT? COMMAND) 1))
        (CL:RETURN))
       (CL:MULTIPLE-VALUE-SETQ (PAUSE? EXIT?) (DEMO-PAUSE? PAUSE?))
       (CL:WHEN (CL:EQ EXIT? 1) (CL:RETURN))
       (CL:MULTIPLE-VALUE-SETQ
        (RESULT RESULTTYPE ERROR?)
        (EVALUATE-LOGIC-COMMAND COMMAND TRUE))
       (CL:WHEN
        (CL:EQ ERROR? 0)
        (PRINT-LOGIC-COMMAND-RESULT RESULT RESULTTYPE)))
      (FREE INPUTSTREAM)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING *LOGIC-COMMAND-RESULT-INDENT* %%STREAM)
       (CL:WRITE-STRING "Finished demo `" %%STREAM)
       (CL:PRINC FILE %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))))
  :VOID)

;;; (DEFGLOBAL *DEMO-FILE-DIRECTORY* ...)

(CL:DEFVAR *DEMO-FILE-DIRECTORY* "PL:sources;logic;demos;")

;;; (DEFGLOBAL *DEMO-FILE-SUFFIX* ...)

(CL:DEFVAR *DEMO-FILE-SUFFIX* ".ste")

;;; (DEFGLOBAL *DEMO-FILES* ...)

(CL:DEFVAR *DEMO-FILES* NULL
  "List of example demo files.
Each entry is a `(<file> <description>)' pair.")

;;; (DEFUN (SELECT-EXAMPLE-DEMO STRING) ...)

(CL:DEFUN SELECT-EXAMPLE-DEMO (INDEX)
  (CL:LET*
   ((ENTRY (NTH *DEMO-FILES* (CL:1- INDEX))))
   (CL:IF
    (CL:NOT (CL:EQ ENTRY NULL))
    (CL:RETURN-FROM
     SELECT-EXAMPLE-DEMO
     (CONCATENATE
      *DEMO-FILE-DIRECTORY*
      (CONCATENATE
       (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE (FIRST ENTRY))
       *DEMO-FILE-SUFFIX*)))
    (CL:RETURN-FROM SELECT-EXAMPLE-DEMO NULL)))
  :VOID)

;;; (DEFUN (SELECT-EXAMPLE-DEMO-FROM-MENU STRING) ...)

(CL:DEFUN SELECT-EXAMPLE-DEMO-FROM-MENU ()
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "Choose a demo:" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  (CL:LET*
   ((I NULL) (ENTRY NULL) (ITER-001 *DEMO-FILES*) (ITER-002 1))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ ENTRY (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-LOGIC-IN-CONS))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "       " %%STREAM)
     (CL:PRINC I %%STREAM)
     (CL:WRITE-STRING ".  " %%STREAM))
    (CL:WHEN
     (CL:< I 10)
     (CL:WRITE-STRING
      " "
      (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING
      (CL:IF
       (CL:NOT (CL:EQ (SECOND ENTRY) NULL))
       (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE (SECOND ENTRY))
       (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE (FIRST ENTRY)))
      %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))))
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "       Q.   Quit demoing" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  (CL:WRITE-STRING
   "Your choice: "
   (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
  (CL:LET*
   ((SELECTION
     (READ-STELLA-EXPRESSION
      (CLSYS-SVAL INPUT-STREAM NATIVE-STREAM STANDARD-INPUT)))
    (FILE NULL))
   (CL:LET*
    ((SELECTION-001 SELECTION))
    (CL:COND
     ((CL:EQ (INTEGER? SELECTION) 1)
      (CL:LET*
       ((SELECTION NULL))
       (CL:SETQ SELECTION SELECTION-001)
       (CL:SETQ
        FILE
        (SELECT-EXAMPLE-DEMO
         (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE SELECTION)))
       (CL:WHEN
        (CL:NOT (CL:EQ FILE NULL))
        (CL:RETURN-FROM SELECT-EXAMPLE-DEMO-FROM-MENU FILE))))
     (CL:T
      (CL:WHEN
       (CL:EQ (STRING-EQL? (STRINGIFY SELECTION) "Q") 1)
       (CL:RETURN-FROM SELECT-EXAMPLE-DEMO-FROM-MENU NULL)))))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING ">> ERROR: Illegal choice `" %%STREAM)
    (PRINT-OBJECT SELECTION %%STREAM)
    (CL:WRITE-STRING "'; enter a number between 1 and " %%STREAM)
    (CL:PRINC (LENGTH *DEMO-FILES*) %%STREAM)
    (CL:WRITE-STRING "!" %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (CL:RETURN-FROM
    SELECT-EXAMPLE-DEMO-FROM-MENU
    (SELECT-EXAMPLE-DEMO-FROM-MENU)))
  :VOID)

;;; (DEFUN DEMO-EXAMPLE-DEMOS ...)

(CL:DEFUN DEMO-EXAMPLE-DEMOS ()
  (CL:LET*
   ((FILE NULL))
   (CL:LOOP
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CL:SETQ FILE (SELECT-EXAMPLE-DEMO-FROM-MENU))
    (CL:WHEN (CL:EQ FILE NULL) (CL:RETURN-FROM DEMO-EXAMPLE-DEMOS))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (DEMO-FILE FILE TRUE)))
  :VOID)

;;; (DEFUN DEMO ...)

(CL:DEFUN %%DEMO (FILEANDPAUSE)
  "Read logic commands from a file, echo them verbatimly to standard output,
and evaluate them just as if they had been typed in interactively.
When called with no arguments, present a menu of example demos, otherwise,
use the first argument as the name of the file to demo.
Pause for user confirmation after each expression has been read but
before it is evaluated.  Pausing can be turned off by suppling FALSE
as the optional second argument, or by typing `c' at the pause prompt.
Typing `?' at the pause prompt prints a list of available commands."
  (CL:LET*
   ((FILESPEC (FIRST FILEANDPAUSE))
    (PAUSE?
     (CL:IF
      (CL:NOT (CL:EQ (SECOND FILEANDPAUSE) SYM-LOGIC-IN-FALSE))
      TRUE
      FALSE))
    (FILE NULL))
   (CL:WHEN
    (CL:EQ (INTEGER? FILESPEC) 1)
    (CL:SETQ
     FILE
     (SELECT-EXAMPLE-DEMO
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST FILESPEC SGT-LOGIC-IN-INTEGER-WRAPPER))))
    (CL:IF
     (CL:NOT (CL:EQ FILE NULL))
     (CL:SETQ FILESPEC (WRAP-LITERAL FILE))
     (CL:SETQ FILESPEC NULL)))
   (CL:IF
    (CL:EQ FILESPEC NULL)
    (DEMO-EXAMPLE-DEMOS)
    (CL:LET*
     ((FILESPEC-001 FILESPEC))
     (CL:COND
      ((CL:EQ (STRING? FILESPEC) 1)
       (CL:LET*
        ((FILESPEC NULL))
        (CL:SETQ FILESPEC FILESPEC-001)
        (DEMO-FILE
         (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE FILESPEC)
         PAUSE?)))
      (CL:T
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING ">> ERROR: Illegal file specification: " %%STREAM)
        (PRINT-OBJECT FILESPEC %%STREAM)))))))
  :VOID)

(CL:DEFUN DEMO-EVALUATOR-WRAPPER (ARGUMENTS)
  (%%DEMO ARGUMENTS)
  :VOID)

(CL:DEFMACRO DEMO (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Read logic commands from a file, echo them verbatimly to standard output,
and evaluate them just as if they had been typed in interactively.
When called with no arguments, present a menu of example demos, otherwise,
use the first argument as the name of the file to demo.
Pause for user confirmation after each expression has been read but
before it is evaluated.  Pausing can be turned off by suppling FALSE
as the optional second argument, or by typing `c' at the pause prompt.
Typing `?' at the pause prompt prints a list of available commands."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/DEMO)) (CL:MACRO-FUNCTION (CL:QUOTE DEMO)))

;;; (DEFUN TEST-LOGIC-FILE ...)

(CL:DEFUN TEST-LOGIC-FILE (FILE)
  (CL:WHEN
   (CL:EQ (PROBE-FILE? FILE) 0)
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING ">> ERROR: File `" %%STREAM)
    (CL:PRINC FILE %%STREAM)
    (CL:WRITE-STRING "' does not exist." %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (CL:RETURN-FROM TEST-LOGIC-FILE))
  (CL:LET*
   ((CURRENTLEVEL *DEMO-LEVEL*)
    (COMMAND NULL)
    (RESULT NULL)
    (RESULTTYPE NULL)
    (EXIT? FALSE)
    (ERROR? FALSE)
    (INPUTSTREAM (NEW-INPUT-FILE-STREAM FILE))
    (FILEBASENAME
     (SUBSEQUENCE FILE (LENGTH *DEMO-FILE-DIRECTORY*) NULL-INTEGER)))
   (CL:LET*
    ((*CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? FALSE)
     (*DEMO-LEVEL* (CL:1+ CURRENTLEVEL))
     (*PRINTREADABLY?* TRUE)
     (*PRINTPRETTY?* FALSE))
    (CL:DECLARE
     (CL:SPECIAL
      *CAREFUL-LOGIC-COMMAND-LOOP-EXIT*?
      *DEMO-LEVEL*
      *PRINTREADABLY?*
      *PRINTPRETTY?*))
    (CL:LET*
     ((MODULE-001 *MODULE*))
     (CL:LET*
      ((*MODULE* MODULE-001) (*CONTEXT* *MODULE*))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING "Now testing file `" %%STREAM)
       (CL:WRITE-STRING FILEBASENAME %%STREAM)
       (CL:WRITE-STRING "':" %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (CL:LOOP
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (PRINT-DEMO-PROMPT)
       (CL:WHEN
        (CL:EQ EXIT? 0)
        (CL:MULTIPLE-VALUE-SETQ
         (COMMAND EXIT?)
         (READ-STELLA-EXPRESSION
          (CLSYS-SVAL INPUT-STREAM NATIVE-STREAM INPUTSTREAM))))
       (CL:WHEN
        (CL:OR (CL:EQ EXIT? 1) (CL:EQ (LOGIC-COMMAND-LOOP-EXIT? COMMAND) 1))
        (CL:RETURN))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (PRINT-OBJECT COMMAND %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (CL:MULTIPLE-VALUE-SETQ
        (RESULT RESULTTYPE ERROR?)
        (EVALUATE-LOGIC-COMMAND COMMAND TRUE))
       (CL:WHEN
        (CL:EQ ERROR? 0)
        (PRINT-LOGIC-COMMAND-RESULT RESULT RESULTTYPE)))
      (FREE INPUTSTREAM)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING *LOGIC-COMMAND-RESULT-INDENT* %%STREAM)
       (CL:WRITE-STRING "Finished testing file `" %%STREAM)
       (CL:WRITE-STRING FILEBASENAME %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))))))
  :VOID)

;;; (DEFUN RUN-POWERLOOM-TESTS ...)

(CL:DEFUN RUN-POWERLOOM-TESTS ()
  "Run the PowerLoom test suite.  Currently this simply runs all demos and
echos commands and their results to standard output.  The output can then
be diffed with previously validated runs to find deviations."
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "RUNNING POWERLOOM TEST SUITE" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:WRITE-STRING "============================" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "STELLA version:    " %%STREAM)
   (CL:WRITE-STRING *STELLA-VERSION-STRING* %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:WRITE-STRING "PowerLoom version: " %%STREAM)
   (CL:WRITE-STRING *POWERLOOM-VERSION-STRING* %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:WRITE-STRING "Current time:      " %%STREAM)
   (CL:WRITE-STRING
    (CL:APPLY
     (CL:FUNCTION CL:FORMAT)
     ()
     "~d/~d/~d ~d:~d:~d"
     (CL:NTHCDR
      3
      (CL:REVERSE
       (CL:MULTIPLE-VALUE-LIST
        (CL:DECODE-UNIVERSAL-TIME (CL:GET-UNIVERSAL-TIME))))))
    %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  (CL:LET*
   ((PLUSER (GET-CONTEXT "/PL-USER" TRUE)))
   (CL:LET*
    ((CHILD NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (COPY (CLSYS-SVAL CONTEXT CHILD-CONTEXTS PLUSER)))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       CHILD
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-LOGIC-IN-CONTEXT))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (DESTROY-CONTEXT CHILD)))
   (CLEAR-CONTEXT PLUSER))
  (CL:LET*
   ((I NULL) (ITER-002 1) (UPPER-BOUND-001 (LENGTH *DEMO-FILES*)))
   (CL:LOOP
    WHILE
    (CL:<= ITER-002 UPPER-BOUND-001)
    DO
    (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
    (TEST-LOGIC-FILE (SELECT-EXAMPLE-DEMO I))))
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:WRITE-STRING "FINISHED RUNNING POWERLOOM TEST SUITE" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:WRITE-STRING "=====================================" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  :VOID)

(CL:DEFMETHOD SORT? ((SELF RELATION))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE SELF SYM-LOGIC-IN-SORT? NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM SORT? FALSE)
    (CL:RETURN-FROM SORT? ANSWER)))
  :VOID)

(CL:DEFMETHOD SORT? ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (CLSYS-SVAL
      BOOLEAN-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE SELF SYM-LOGIC-IN-SORT? NULL-BOOLEAN-WRAPPER))))
   (CL:IF
    (CL:EQ (NULL? ANSWER) 1)
    (CL:RETURN-FROM SORT? TRUE)
    (CL:RETURN-FROM SORT? ANSWER)))
  :VOID)

(CL:DEFMETHOD RELATION-PARAMETER-NAMES ((SELF TABLE))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE SELF SYM-LOGIC-IN-RELATION-PARAMETER-NAMES NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM RELATION-PARAMETER-NAMES NIL-LIST)
    (CL:RETURN-FROM RELATION-PARAMETER-NAMES ANSWER)))
  :VOID)

;;; (DEFMETHOD (LOGIC-DIALECT KEYWORD) ...)

(CL:DEFMETHOD LOGIC-DIALECT ((SELF RELATION))
  (CL:RETURN-FROM LOGIC-DIALECT *LOGIC-DIALECT*)
  :VOID)

;;; (DEFUN (DEFAULT-SELF-VARIABLE SYMBOL) ...)

(CL:DEFUN DEFAULT-SELF-VARIABLE (SELF)
  (CL:LET*
   ((TEST-VALUE-001
     (CL:IF (CL:EQ SELF NULL) *LOGIC-DIALECT* (LOGIC-DIALECT SELF))))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-LOGIC-IN-KIF)
     (CL:RETURN-FROM DEFAULT-SELF-VARIABLE SYM-LOGIC-IN-?SELF))
    (CL:T (CL:RETURN-FROM DEFAULT-SELF-VARIABLE SYM-LOGIC-IN-SELF))))
  :VOID)

;;; (DEFMETHOD (SELF-VARIABLE-GETTER SYMBOL) ...)

(CL:DEFMETHOD SELF-VARIABLE-GETTER ((SELF RELATION))
  (CL:LET*
   ((VARIABLE (DYNAMIC-SLOT-VALUE SELF SYM-LOGIC-IN-SELF-VARIABLE NULL)))
   (CL:IF
    (CL:NOT (CL:EQ VARIABLE NULL))
    (CL:RETURN-FROM SELF-VARIABLE-GETTER VARIABLE)
    (CL:RETURN-FROM SELF-VARIABLE-GETTER (DEFAULT-SELF-VARIABLE SELF))))
  :VOID)

;;; (DEFMETHOD (SELF-VARIABLE-GETTER SYMBOL) ...)

(CL:DEFMETHOD SELF-VARIABLE-GETTER ((SELF TABLE))
  (CL:RETURN-FROM SELF-VARIABLE-GETTER (FIRST (RELATION-PARAMETER-NAMES SELF)))
  :VOID)

;;; (DEFMETHOD (SELF-VARIABLE-GETTER SYMBOL) ...)

(CL:DEFMETHOD SELF-VARIABLE-GETTER ((SELF METHOD-SLOT))
  (CL:RETURN-FROM SELF-VARIABLE-GETTER (FIRST (METHOD-PARAMETER-NAMES SELF)))
  :VOID)

;;; (DEFUN (DEFAULT-VALUE-VARIABLE SYMBOL) ...)

(CL:DEFUN DEFAULT-VALUE-VARIABLE (SELF)
  (CL:LET*
   ((TEST-VALUE-001
     (CL:IF (CL:EQ SELF NULL) *LOGIC-DIALECT* (LOGIC-DIALECT SELF))))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-LOGIC-IN-KIF)
     (CL:RETURN-FROM DEFAULT-VALUE-VARIABLE SYM-LOGIC-IN-?VALUE))
    (CL:T (CL:RETURN-FROM DEFAULT-VALUE-VARIABLE SYM-LOGIC-IN-VALUE))))
  :VOID)

;;; (DEFMETHOD (VALUE-VARIABLE-GETTER SYMBOL) ...)

(CL:DEFMETHOD VALUE-VARIABLE-GETTER ((SELF SLOT))
  (CL:LET*
   ((VARIABLE (DYNAMIC-SLOT-VALUE SELF SYM-LOGIC-IN-VALUE-VARIABLE NULL)))
   (CL:IF
    (CL:NOT (CL:EQ VARIABLE NULL))
    (CL:RETURN-FROM VALUE-VARIABLE-GETTER VARIABLE)
    (CL:RETURN-FROM VALUE-VARIABLE-GETTER (DEFAULT-VALUE-VARIABLE SELF))))
  :VOID)

;;; (DEFUN (HELP-DEFINE-RELATION-FROM-PARSE-TREE RELATION) ...)

(CL:DEFUN HELP-DEFINE-RELATION-FROM-PARSE-TREE (TREE STRINGIFIEDSOURCE)
  (CL:LET*
   ((NAMETREE NULL)
    (NAME NULL)
    (OWNERTYPE NULL)
    (VALUETYPES NULL)
    (VALUETYPE NULL)
    (PARAMETERS NULL)
    (TYPEDPARAMETERS NIL))
   (CL:LET*
    ((SELF-001 (NEW-PROPERTY-LIST)))
    (CL:SETF
     (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF-001)
     (EXTRACT-OPTIONS TREE NULL))
    (CL:LET*
     ((OPTIONS SELF-001)
      (FUNCTION? (EQ? (FIRST TREE) SYM-LOGIC-IN-DEFFUNCTION))
      (POLYMORPHIC? TRUE)
      (UNARY? FALSE)
      (RELATION NULL))
     (CL:MULTIPLE-VALUE-SETQ
      (NAMETREE PARAMETERS TREE)
      (DESTRUCTURE-DEFMETHOD-TREE TREE NULL))
     (CL:MULTIPLE-VALUE-SETQ
      (NAME VALUETYPES)
      (DESTRUCTURE-METHOD-NAME-TREE NAMETREE))
     (CL:IF
      (CL:EQ NAME NULL)
      (CL:RETURN-FROM HELP-DEFINE-RELATION-FROM-PARSE-TREE NULL)
      (CL:SETQ NAME (PERMANENTIFY NAME)))
     (CL:SETQ VALUETYPE (FIRST VALUETYPES))
     (CL:LET*
      ((PARAMETERNAMES NULL) (PARAMETERTYPES NULL) (N-ARY? FALSE))
      (CL:MULTIPLE-VALUE-SETQ
       (PARAMETERNAMES PARAMETERTYPES N-ARY?)
       (PARSE-RELATION-PARAMETERS-TREE PARAMETERS))
      (CL:LET*
       ((TYPE NULL)
        (NAME NULL)
        (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST PARAMETERNAMES))
        (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST PARAMETERTYPES))
        (COLLECT-001 NULL))
       (CL:LOOP
        WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL)))
        DO
        (CL:PROGN
         (CL:SETQ
          NAME
          (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-LOGIC-IN-SYMBOL))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:PROGN
         (CL:SETQ
          TYPE
          (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-LOGIC-IN-TYPE-SPEC))
         (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
        (CL:IF
         (CL:EQ COLLECT-001 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-001 (CONS (CONS NAME (CONS TYPE NIL)) NIL))
          (CL:IF
           (CL:EQ TYPEDPARAMETERS NIL)
           (CL:SETQ TYPEDPARAMETERS COLLECT-001)
           (ADD-CONS-TO-END-OF-CONS-LIST TYPEDPARAMETERS COLLECT-001)))
         (CL:PROGN
          (CL:SETF
           (CLSYS-SVAL CONS REST COLLECT-001)
           (CONS (CONS NAME (CONS TYPE NIL)) NIL))
          (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
      (CL:WHEN
       (CL:EQ (EMPTY? PARAMETERNAMES) 1)
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN
         (CL:EQ (SUPPRESS-WARNINGS?) 0)
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:WRITE-STRING " Empty relation parameter list." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))))
       (CL:RETURN-FROM HELP-DEFINE-RELATION-FROM-PARSE-TREE NULL))
      (CL:SETQ OWNERTYPE (TYPE-SPEC-TO-BASE-TYPE (FIRST PARAMETERTYPES)))
      (CL:SETQ
       UNARY?
       (CL:IF
        (CL:AND (CL:EQ N-ARY? 0) (CL:= (LENGTH PARAMETERNAMES) 1))
        TRUE
        FALSE))
      (CL:SETQ
       POLYMORPHIC?
       (CL:IF
        (CL:NOT
         (CL:OR
          (CL:EQ OWNERTYPE SGT-LOGIC-IN-UNKNOWN)
          (CL:EQ
           (LOOKUP OPTIONS KWD-LOGIC-IN-POLYMORPHIC?)
           SYM-LOGIC-IN-FALSE)))
        TRUE
        FALSE))
      (REMOVE-AT OPTIONS KWD-LOGIC-IN-POLYMORPHIC?)
      (CL:WHEN
       (CL:AND
        (CL:EQ POLYMORPHIC? 1)
        (CL:EQ
         (CAST
          (CLSYS-SVAL SURROGATE SURROGATE-VALUE OWNERTYPE)
          SGT-LOGIC-IN-CLASS)
         NULL))
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN
         (CL:EQ (SUPPRESS-WARNINGS?) 0)
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:WRITE-STRING
           " Can't define polymorphic relation on non-existent class `"
           %%STREAM)
          (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE OWNERTYPE) %%STREAM)
          (CL:WRITE-STRING "'." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))))
       (CL:RETURN-FROM HELP-DEFINE-RELATION-FROM-PARSE-TREE NULL))
      (CL:WHEN
       (CL:EQ VALUETYPE NULL)
       (CL:SETQ VALUETYPE (LOOKUP OPTIONS KWD-LOGIC-IN-TYPE)))
      (REMOVE-AT OPTIONS KWD-LOGIC-IN-TYPE)
      (CL:IF
       (CL:EQ VALUETYPE NULL)
       (CL:SETQ
        VALUETYPE
        (CL:IF (CL:EQ FUNCTION? 1) SGT-LOGIC-IN-UNKNOWN SGT-LOGIC-IN-BOOLEAN))
       (CL:WHEN
        (CL:AND
         (CL:EQ FUNCTION? 0)
         (CL:NOT
          (CL:OR
           (CL:EQ VALUETYPE SGT-LOGIC-IN-BOOLEAN)
           (CL:EQ VALUETYPE SYM-LOGIC-IN-BOOLEAN))))
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN
          (CL:EQ (SUPPRESS-WARNINGS?) 0)
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
          (CL:LET
           ((%%STREAM
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING " Illegal value type for relation: `" %%STREAM)
           (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE VALUETYPE) %%STREAM)
           (CL:WRITE-STRING "'." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM)
           (CL:WRITE-STRING " Changing it to BOOLEAN instead." %%STREAM)
           (CL:TERPRI %%STREAM)
           (CL:FORCE-OUTPUT %%STREAM))))
        (CL:SETQ VALUETYPE SGT-LOGIC-IN-BOOLEAN)))
      (CL:SETQ
       RELATION
       (GET-IDENTICAL-RELATION NAME OWNERTYPE POLYMORPHIC? STRINGIFIEDSOURCE))
      (CL:WHEN
       (CL:NOT (CL:EQ RELATION NULL))
       (CL:RETURN-FROM HELP-DEFINE-RELATION-FROM-PARSE-TREE RELATION))
      (CL:WHEN
       (CL:AND (CL:EQ UNARY? 1) (CL:EQ POLYMORPHIC? 1))
       (INSERT-AT OPTIONS KWD-LOGIC-IN-TYPE VALUETYPE)
       (INSERT-AT OPTIONS KWD-LOGIC-IN-ABSTRACT? SYM-LOGIC-IN-TRUE)
       (CL:WHEN
        (CL:NOT (CL:EQ (DEFAULT-SELF-VARIABLE NULL) (FIRST PARAMETERNAMES)))
        (INSERT-AT OPTIONS KWD-LOGIC-IN-SELF-VARIABLE (FIRST PARAMETERNAMES)))
       (CL:LET*
        ((*TRANSIENTOBJECTS?* TRUE))
        (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
        (CL:SETQ
         TREE
         (LIST*
          SYM-LOGIC-IN-DEFSLOT
          (TYPE-TO-SYMBOL OWNERTYPE)
          (CONS
           NAME
           (CONCATENATE
            (CAST
             (TRANSIENTIFY-FORM (CLSYS-SVAL PROPERTY-LIST THE-PLIST OPTIONS))
             SGT-LOGIC-IN-CONS)
            NIL)))))
       (CLEAR OPTIONS)
       (CL:SETQ RELATION (DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE TREE)))
      (CL:WHEN
       (CL:AND (CL:EQ RELATION NULL) (CL:EQ POLYMORPHIC? 0))
       (CL:COND
        ((CL:AND (CL:EQ UNARY? 1) (CL:EQ FUNCTION? 0))
         (CL:WHEN
          (CL:NOT (CL:EQ (DEFAULT-SELF-VARIABLE NULL) (FIRST PARAMETERNAMES)))
          (INSERT-AT
           OPTIONS
           KWD-LOGIC-IN-SELF-VARIABLE
           (FIRST PARAMETERNAMES)))
         (CL:LET*
          ((*TRANSIENTOBJECTS?* TRUE))
          (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
          (CL:SETQ
           TREE
           (LIST*
            SYM-LOGIC-IN-DEFCLASS
            NAME
            (CONS
             (CL:IF
              (CL:EQ OWNERTYPE SGT-LOGIC-IN-UNKNOWN)
              NIL
              (CONS (TYPE-TO-SYMBOL OWNERTYPE) NIL))
             (CONCATENATE
              (CAST
               (TRANSIENTIFY-FORM
                (CLSYS-SVAL PROPERTY-LIST THE-PLIST OPTIONS))
               SGT-LOGIC-IN-CONS)
              NIL)))))
         (CLEAR OPTIONS)
         (CL:SETQ RELATION (DEFINE-CLASS-FROM-PARSE-TREE TREE)))
        (CL:T
         (INSERT-AT OPTIONS KWD-LOGIC-IN-TYPE VALUETYPE)
         (CL:LET*
          ((*TRANSIENTOBJECTS?* TRUE))
          (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
          (CL:SETQ
           TREE
           (LIST*
            SYM-LOGIC-IN-DEFUN
            NAME
            (CONS
             TYPEDPARAMETERS
             (CONCATENATE
              (CAST
               (TRANSIENTIFY-FORM
                (CLSYS-SVAL PROPERTY-LIST THE-PLIST OPTIONS))
               SGT-LOGIC-IN-CONS)
              NIL)))))
         (CLEAR OPTIONS)
         (CL:SETQ RELATION (DEFINE-METHOD-FROM-PARSE-TREE TREE)))))
      (CL:WHEN
       (CL:EQ RELATION NULL)
       (CL:SETQ VALUETYPE (YIELD-TYPE-SPECIFIER VALUETYPE))
       (CL:LET*
        ((SELF-002 (NEW-TABLE)))
        (CL:SETF (CLSYS-SVAL TABLE SLOT-NAME SELF-002) NAME)
        (CL:SETF (CLSYS-SVAL TABLE SLOT-OWNER SELF-002) OWNERTYPE)
        (CL:SETF
         (CLSYS-SVAL TABLE SLOT-BASE-TYPE SELF-002)
         (TYPE-SPEC-TO-BASE-TYPE (CAST VALUETYPE SGT-LOGIC-IN-TYPE-SPEC)))
        (CL:SETF (CLSYS-SVAL TABLE SLOT-EXTERNAL? SELF-002) TRUE)
        (SET-DYNAMIC-SLOT-VALUE
         SELF-002
         SYM-LOGIC-IN-RELATION-PARAMETER-NAMES
         PARAMETERNAMES
         NULL)
        (CL:SETF (CLSYS-SVAL TABLE TUPLE-DOMAINS SELF-002) PARAMETERTYPES)
        (CL:LET*
         ((TABLE SELF-002))
         (CL:WHEN
          (CL:EQ N-ARY? 1)
          (SET-DYNAMIC-SLOT-VALUE
           TABLE
           SYM-LOGIC-IN-VARIABLE-ARITY?
           (WRAP-BOOLEAN TRUE)
           NULL-BOOLEAN-WRAPPER))
         (CL:WHEN
          (CL:EQ (TYPE? VALUETYPE) 0)
          (SET-DYNAMIC-SLOT-VALUE
           TABLE
           SYM-LOGIC-IN-SLOT-TYPE-SPECIFIER
           (CAST VALUETYPE SGT-LOGIC-IN-COMPOUND-TYPE-SPECIFIER)
           NULL))
         (CL:LET*
          ((VALUE NULL)
           (KEY NULL)
           (ITER-003 (CLSYS-SVAL PROPERTY-LIST THE-PLIST OPTIONS)))
          (CL:LOOP
           WHILE
           (CL:NOT (CL:EQ ITER-003 NIL))
           DO
           (CL:SETQ KEY (CLSYS-SVAL CONS VALUE ITER-003))
           (CL:PROGN
            (CL:SETQ
             VALUE
             (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST ITER-003)))
            (CL:SETQ
             ITER-003
             (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST ITER-003))))
           (CL:LET*
            ((TEST-VALUE-001 (CAST KEY SGT-LOGIC-IN-KEYWORD)))
            (CL:COND
             ((CL:EQ TEST-VALUE-001 KWD-LOGIC-IN-DOCUMENTATION)
              (SET-DYNAMIC-SLOT-VALUE
               TABLE
               SYM-LOGIC-IN-DOCUMENTATION
               (WRAP-STRING
                (CLSYS-SVAL
                 STRING-WRAPPER
                 WRAPPER-VALUE
                 (CAST VALUE SGT-LOGIC-IN-STRING-WRAPPER)))
               NULL-STRING-WRAPPER))
             ((CL:EQ TEST-VALUE-001 KWD-LOGIC-IN-SINGLE-VALUED?) NULL)
             ((CL:EQ TEST-VALUE-001 KWD-LOGIC-IN-PROPERTIES)
              (SET-DYNAMIC-SLOT-VALUE
               TABLE
               SYM-LOGIC-IN-PROPERTIES
               (CAST VALUE SGT-LOGIC-IN-LIST)
               NULL))
             ((CL:EQ TEST-VALUE-001 KWD-LOGIC-IN-META-ATTRIBUTES)
              (SET-DYNAMIC-SLOT-VALUE
               TABLE
               SYM-LOGIC-IN-META-ATTRIBUTES
               (CAST VALUE SGT-LOGIC-IN-KEY-VALUE-LIST)
               NULL))
             (CL:T
              (CL:WHEN
               (CL:EQ
                (RUN-OPTION-HANDLER?
                 TABLE
                 (CAST KEY SGT-LOGIC-IN-KEYWORD)
                 VALUE)
                0)
               (CL:LET*
                ((*PRINTREADABLY?* TRUE))
                (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
                (SIGNAL-TRANSLATION-WARNING)
                (CL:WHEN
                 (CL:EQ (SUPPRESS-WARNINGS?) 0)
                 (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-OUTPUT)
                 (CL:LET
                  ((%%STREAM
                    (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
                  (CL:TERPRI %%STREAM)
                  (CL:FORCE-OUTPUT %%STREAM)
                  (CL:WRITE-STRING " Skipping invalid option `" %%STREAM)
                  (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE KEY) %%STREAM)
                  (CL:WRITE-STRING "'" %%STREAM)
                  (CL:TERPRI %%STREAM)
                  (CL:FORCE-OUTPUT %%STREAM)
                  (CL:WRITE-STRING "in the definition of `" %%STREAM)
                  (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE OWNERTYPE) %%STREAM)
                  (CL:WRITE-STRING "'.`" %%STREAM)
                  (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE NAME) %%STREAM)
                  (CL:WRITE-STRING "'." %%STREAM)
                  (CL:TERPRI %%STREAM)
                  (CL:FORCE-OUTPUT %%STREAM))))))))))
         (ATTACH-SLOT-TO-OWNER TABLE)
         (CL:SETQ RELATION TABLE))))
      (SET-DYNAMIC-SLOT-VALUE
       RELATION
       SYM-LOGIC-IN-RELATION-STRINGIFIED-SOURCE
       (WRAP-STRING STRINGIFIEDSOURCE)
       NULL-STRING-WRAPPER)
      (CL:RETURN-FROM HELP-DEFINE-RELATION-FROM-PARSE-TREE RELATION)))))
  :VOID)

;;; (DEFUN (PARSE-RELATION-PARAMETERS-TREE (LIST OF SYMBOL) (LIST OF TYPE-SPEC) BOOLEAN) ...)

(CL:DEFUN PARSE-RELATION-PARAMETERS-TREE (PARAMETERS)
  (CL:WHEN
   (CL:EQ PARAMETERS NIL)
   (CL:RETURN-FROM
    PARSE-RELATION-PARAMETERS-TREE
    (CL:VALUES NIL-LIST NIL-LIST FALSE)))
  (CL:LET*
   ((NAME NULL)
    (TYPESPEC NULL)
    (NAMES (NEW-LIST))
    (TYPESPECS (NEW-LIST))
    (VARIABLEARGS? FALSE))
   (CL:LET*
    ((P NULL) (ITER-001 PARAMETERS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ P (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:TAGBODY
      (CL:LET*
       ((P-001 P))
       (CL:COND
        ((CL:EQ (CONS? P) 1)
         (CL:LET*
          ((P NULL))
          (CL:SETQ P P-001)
          (CL:WHEN
           (CL:NOT (CL:= (LENGTH P) 2))
           (CL:LET*
            ((*PRINTREADABLY?* TRUE))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-ERROR)
            (CL:WHEN
             (CL:EQ (SUPPRESS-WARNINGS?) 0)
             (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
             (CL:LET
              ((%%STREAM
                (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING " Illegal parameter: `" %%STREAM)
              (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE P) %%STREAM)
              (CL:WRITE-STRING "'." %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM))))
           (CL:GO :CONTINUE))
          (CL:SETQ NAME (CAST (FIRST P) SGT-LOGIC-IN-SYMBOL))
          (CL:SETQ TYPESPEC (CAST (SECOND P) SGT-LOGIC-IN-TYPE-SPEC))))
        ((CL:EQ (SYMBOL? P) 1)
         (CL:LET*
          ((P NULL))
          (CL:SETQ P P-001)
          (CL:WHEN
           (CL:EQ P SYM-LOGIC-IN-&REST)
           (CL:SETQ VARIABLEARGS? TRUE)
           (CL:GO :CONTINUE))
          (CL:SETQ NAME P)
          (CL:SETQ TYPESPEC SGT-LOGIC-IN-UNKNOWN)))
        (CL:T
         (CL:LET*
          ((*PRINTREADABLY?* TRUE))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN
           (CL:EQ (SUPPRESS-WARNINGS?) 0)
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
           (CL:LET
            ((%%STREAM
              (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM)
            (CL:WRITE-STRING " Illegal parameter: `" %%STREAM)
            (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE P) %%STREAM)
            (CL:WRITE-STRING "'." %%STREAM)
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM))))
         (CL:GO :CONTINUE))))
      (CL:WHEN
       (CL:EQ VARIABLEARGS? 1)
       (CL:SETQ
        TYPESPEC
        (LIST* SYM-LOGIC-IN-ARGUMENT-LIST SYM-LOGIC-IN-OF TYPESPEC NIL)))
      (PUSH NAMES NAME)
      (PUSH TYPESPECS (YIELD-TYPE-SPECIFIER TYPESPEC))
      (CL:WHEN (CL:EQ VARIABLEARGS? 1) (CL:RETURN))
      :CONTINUE)))
   (CL:RETURN-FROM
    PARSE-RELATION-PARAMETERS-TREE
    (CL:VALUES (REVERSE NAMES) (REVERSE TYPESPECS) VARIABLEARGS?)))
  :VOID)

;;; (DEFUN (GET-IDENTICAL-RELATION RELATION) ...)

(CL:DEFUN GET-IDENTICAL-RELATION (NAME OWNER POLYMORPHIC? STRINGIFIEDSOURCE)
  (CL:LET*
   ((RELATION NULL))
   (CL:COND
    ((CL:EQ POLYMORPHIC? 1)
     (CL:SETQ
      RELATION
      (SAFE-LOOKUP-SLOT
       (CAST (CLSYS-SVAL SURROGATE SURROGATE-VALUE OWNER) SGT-LOGIC-IN-CLASS)
       NAME))
     (CL:WHEN
      (CL:OR
       (CL:EQ RELATION NULL)
       (CL:NOT
        (CL:EQ
         (CLSYS-SVAL SLOT SLOT-OWNER (CAST RELATION SGT-LOGIC-IN-SLOT))
         OWNER)))
      (CL:SETQ RELATION NULL)))
    (CL:T
     (CL:SETQ RELATION (LOOKUP-CLASS NAME))
     (CL:WHEN
      (CL:EQ RELATION NULL)
      (CL:SETQ RELATION (LOOKUP-FUNCTION NAME)))))
   (CL:IF
    (CL:AND
     (CL:NOT (CL:EQ RELATION NULL))
     (CL:EQ
      (STRING-EQL?
       (CLSYS-SVAL
        STRING-WRAPPER
        WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         RELATION
         SYM-LOGIC-IN-RELATION-STRINGIFIED-SOURCE
         NULL-STRING-WRAPPER))
       STRINGIFIEDSOURCE)
      1))
    (CL:RETURN-FROM GET-IDENTICAL-RELATION RELATION)
    (CL:RETURN-FROM GET-IDENTICAL-RELATION NULL)))
  :VOID)

(CL:DEFMETHOD RELATION-ORIGINATED-PROPOSITIONS ((SELF RELATION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE
      SELF
      SYM-LOGIC-IN-RELATION-ORIGINATED-PROPOSITIONS
      NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM RELATION-ORIGINATED-PROPOSITIONS NIL-LIST)
    (CL:RETURN-FROM RELATION-ORIGINATED-PROPOSITIONS ANSWER)))
  :VOID)

;;; (DEFMETHOD (FUNCTION? BOOLEAN) ...)

(CL:DEFMETHOD FUNCTION? ((SELF RELATION))
  (CL:RETURN-FROM FUNCTION? FALSE)
  :VOID)

;;; (DEFMETHOD (FUNCTION? BOOLEAN) ...)

(CL:DEFMETHOD FUNCTION? ((SELF SLOT))
  (CL:LET*
   ((TEST-VALUE-001 (TYPE SELF)))
   (CL:COND
    ((CL:OR
      (CL:EQ TEST-VALUE-001 SGT-LOGIC-IN-BOOLEAN)
      (CL:EQ TEST-VALUE-001 SGT-LOGIC-IN-BOOLEAN-WRAPPER))
     (CL:RETURN-FROM FUNCTION? FALSE))
    (CL:T (CL:RETURN-FROM FUNCTION? TRUE))))
  :VOID)

;;; (DEFUN RELATION-FULL-DEFINITION-HANDLER ...)

(CL:DEFUN RELATION-FULL-DEFINITION-HANDLER (SELF SLOT DEFINITION)
  (CL:SETQ SLOT SLOT)
  (CL:SETF (CLSYS-SVAL RELATION ABSTRACT? SELF) TRUE)
  (REMEMBER-UNFINALIZED-RELATION SELF)
  (CL:WHEN
   (CL:EQ (CLASS? SELF) 1)
   (SET-DYNAMIC-SLOT-VALUE
    SELF
    SYM-LOGIC-IN-SORT?
    (WRAP-BOOLEAN FALSE)
    NULL-BOOLEAN-WRAPPER))
  (CL:LET*
   ((DEFINITION-001 DEFINITION))
   (CL:COND
    ((CL:EQ (STRING? DEFINITION) 1)
     (CL:LET*
      ((DEFINITION NULL))
      (CL:SETQ DEFINITION DEFINITION-001)
      (SET-DYNAMIC-SLOT-VALUE
       SELF
       SYM-LOGIC-IN-DEFINITION-STRING
       (WRAP-STRING (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE DEFINITION))
       NULL-STRING-WRAPPER)))
    (CL:T
     (SET-DYNAMIC-SLOT-VALUE
      SELF
      SYM-LOGIC-IN-DEFINITION-STRING
      (WRAP-STRING (STRINGIFY DEFINITION))
      NULL-STRING-WRAPPER))))
  :VOID)

;;; (DEFUN RELATION-SENTENCE-DEFINITION-HANDLER ...)

(CL:DEFUN RELATION-SENTENCE-DEFINITION-HANDLER (SELF SLOT DEFINITION)
  (CL:SETQ SLOT SLOT)
  (CL:SETF (CLSYS-SVAL RELATION ABSTRACT? SELF) TRUE)
  (REMEMBER-UNFINALIZED-RELATION SELF)
  (CL:WHEN
   (CL:EQ (CLASS? SELF) 1)
   (SET-DYNAMIC-SLOT-VALUE
    SELF
    SYM-LOGIC-IN-SORT?
    (WRAP-BOOLEAN FALSE)
    NULL-BOOLEAN-WRAPPER))
  (CL:WHEN
   (CL:EQ (STRING? DEFINITION) 1)
   (CL:SETQ
    DEFINITION
    (UNSTRINGIFY
     (CLSYS-SVAL
      STRING-WRAPPER
      WRAPPER-VALUE
      (CAST DEFINITION SGT-LOGIC-IN-STRING-WRAPPER)))))
  (SET-DYNAMIC-SLOT-VALUE
   SELF
   SYM-LOGIC-IN-DEFINITION-STRING
   (WRAP-STRING (STRINGIFY (COMPLETE-SENTENCE-DEFINITION SELF DEFINITION)))
   NULL-STRING-WRAPPER)
  :VOID)

;;; (DEFUN RELATION-TERM-DEFINITION-HANDLER ...)

(CL:DEFUN RELATION-TERM-DEFINITION-HANDLER (SELF SLOT DEFINITION)
  (CL:WHEN
   (CL:EQ (FUNCTION? SELF) 1)
   (CL:SETF (CLSYS-SVAL RELATION ABSTRACT? SELF) TRUE)
   (REMEMBER-UNFINALIZED-RELATION SELF)
   (CL:WHEN
    (CL:EQ (STRING? DEFINITION) 1)
    (CL:SETQ
     DEFINITION
     (UNSTRINGIFY
      (CLSYS-SVAL
       STRING-WRAPPER
       WRAPPER-VALUE
       (CAST DEFINITION SGT-LOGIC-IN-STRING-WRAPPER)))))
   (SET-DYNAMIC-SLOT-VALUE
    SELF
    SYM-LOGIC-IN-DEFINITION-STRING
    (WRAP-STRING
     (STRINGIFY
      (COMPLETE-TERM-DEFINITION (CAST SELF SGT-LOGIC-IN-SLOT) DEFINITION)))
    NULL-STRING-WRAPPER)
   (CL:RETURN-FROM RELATION-TERM-DEFINITION-HANDLER))
  (CL:LET*
   ((*PRINTREADABLY?* TRUE))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (SIGNAL-TRANSLATION-ERROR)
   (CL:WHEN
    (CL:EQ (SUPPRESS-WARNINGS?) 0)
    (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-OUTPUT)
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:WRITE-STRING " Can't define `" %%STREAM)
     (PRINT-OBJECT (DE-UGLIFY-PARSE-TREE SELF) %%STREAM)
     (CL:WRITE-STRING "' with the definition option `" %%STREAM)
     (PRINT-OBJECT
      (DYNAMIC-SLOT-VALUE SLOT SYM-LOGIC-IN-SLOT-OPTION-KEYWORD NULL)
      %%STREAM)
     (CL:WRITE-STRING "'," %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:WRITE-STRING " since it is not a function." %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))))
  :VOID)

;;; (DEFUN (YIELD-RELATION-PARAMETERS-TREE CONS) ...)

(CL:DEFUN YIELD-RELATION-PARAMETERS-TREE (SELF TYPED?)
  (CL:LET*
   ((TEST-VALUE-001 (LOGIC-DIALECT SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-LOGIC-IN-KIF)
     (CL:LET*
      ((PARAMETERS NIL) (PARAMETER NULL))
      (CL:LET*
       ((*TRANSIENTOBJECTS?* TRUE))
       (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
       (CL:LET*
        ((SELF-001 SELF))
        (CL:COND
         ((CL:EQ (CLASS? SELF) 1)
          (CL:LET*
           ((SELF NULL))
           (CL:SETQ SELF SELF-001)
           (CL:SETQ PARAMETER (SELF-VARIABLE-GETTER SELF))
           (CL:WHEN
            (CL:EQ TYPED? 1)
            (CL:SETQ
             PARAMETER
             (CONS PARAMETER (CONS (CLASS-SYMBOL SELF) NIL))))
           (CL:SETQ PARAMETERS (CONS PARAMETER NIL))))
         ((CL:EQ (STORAGE-SLOT? SELF) 1)
          (CL:LET*
           ((SELF NULL))
           (CL:SETQ SELF SELF-001)
           (CL:SETQ PARAMETER (SELF-VARIABLE-GETTER SELF))
           (CL:WHEN
            (CL:EQ TYPED? 1)
            (CL:SETQ
             PARAMETER
             (CONS
              PARAMETER
              (CONS
               (TYPE-TO-SYMBOL (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SELF))
               NIL))))
           (CL:SETQ PARAMETERS (CONS PARAMETER PARAMETERS))))
         ((CL:EQ (METHOD-SLOT? SELF) 1)
          (CL:LET*
           ((SELF NULL))
           (CL:SETQ SELF SELF-001)
           (CL:LET*
            ((PTYPE NULL)
             (PNAME NULL)
             (ITER-001
              (CLSYS-SVAL LIST THE-CONS-LIST (METHOD-PARAMETER-NAMES SELF)))
             (ITER-002
              (CLSYS-SVAL
               LIST
               THE-CONS-LIST
               (METHOD-PARAMETER-TYPE-SPECIFIERS SELF))))
            (CL:LOOP
             WHILE
             (CL:AND
              (CL:NOT (CL:EQ ITER-001 NIL))
              (CL:NOT (CL:EQ ITER-002 NIL)))
             DO
             (CL:PROGN
              (CL:SETQ
               PNAME
               (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-LOGIC-IN-SYMBOL))
              (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
             (CL:PROGN
              (CL:SETQ
               PTYPE
               (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-LOGIC-IN-TYPE-SPEC))
              (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
             (CL:SETQ PARAMETER PNAME)
             (CL:WHEN
              (CL:AND
               (CL:EQ TYPED? 1)
               (CL:NOT (CL:EQ PTYPE SGT-LOGIC-IN-UNKNOWN)))
              (CL:SETQ
               PARAMETER
               (CONS PARAMETER (CONS (YIELD-TYPE-SPEC-TREE PTYPE) NIL))))
             (CL:SETQ PARAMETERS (CONS PARAMETER PARAMETERS))))))
         ((CL:EQ (TAXONOMY-ISA? SELF SGT-LOGIC-IN-TABLE) 1)
          (CL:LET*
           ((SELF NULL))
           (CL:SETQ SELF SELF-001)
           (CL:LET*
            ((PTYPE NULL)
             (PNAME NULL)
             (ITER-003
              (CLSYS-SVAL LIST THE-CONS-LIST (RELATION-PARAMETER-NAMES SELF)))
             (ITER-004
              (CLSYS-SVAL
               LIST
               THE-CONS-LIST
               (CLSYS-SVAL TABLE TUPLE-DOMAINS SELF))))
            (CL:LOOP
             WHILE
             (CL:AND
              (CL:NOT (CL:EQ ITER-003 NIL))
              (CL:NOT (CL:EQ ITER-004 NIL)))
             DO
             (CL:PROGN
              (CL:SETQ
               PNAME
               (CAST (CLSYS-SVAL CONS VALUE ITER-003) SGT-LOGIC-IN-SYMBOL))
              (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
             (CL:PROGN
              (CL:SETQ PTYPE (CLSYS-SVAL CONS VALUE ITER-004))
              (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
             (CL:SETQ PARAMETER PNAME)
             (CL:WHEN
              (CL:AND
               (CL:EQ TYPED? 1)
               (CL:NOT (CL:EQ PTYPE SGT-LOGIC-IN-UNKNOWN)))
              (CL:SETQ
               PARAMETER
               (CONS
                PARAMETER
                (CONS
                 (YIELD-TYPE-SPEC-TREE (CAST PTYPE SGT-LOGIC-IN-TYPE-SPEC))
                 NIL))))
             (CL:SETQ PARAMETERS (CONS PARAMETER PARAMETERS))))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" SELF))))
       (CL:WHEN
        (CL:EQ (FUNCTION? SELF) 1)
        (CL:LET*
         ((SLOT (CAST SELF SGT-LOGIC-IN-SLOT)))
         (CL:SETQ PARAMETER (VALUE-VARIABLE-GETTER SLOT))
         (CL:WHEN
          (CL:AND
           (CL:EQ TYPED? 1)
           (CL:NOT (CL:EQ (TYPE SLOT) NULL))
           (CL:NOT (CL:EQ (TYPE SLOT) SGT-LOGIC-IN-UNKNOWN)))
          (CL:SETQ
           PARAMETER
           (CONS PARAMETER (CONS (TYPE-TO-SYMBOL (TYPE SLOT)) NIL))))
         (CL:SETQ PARAMETERS (CONS PARAMETER PARAMETERS))))
       (CL:RETURN-FROM YIELD-RELATION-PARAMETERS-TREE (REVERSE PARAMETERS)))))
    (CL:T
     (CL:WARN
      "yield-relation-parameters-tree: Not yet implemented for dialect `~A'"
      (LOGIC-DIALECT SELF))
     (CL:RETURN-FROM YIELD-RELATION-PARAMETERS-TREE NULL))))
  :VOID)

;;; (DEFUN (COMPLETE-SENTENCE-DEFINITION OBJECT) ...)

(CL:DEFUN COMPLETE-SENTENCE-DEFINITION (SELF DEFINITION)
  (CL:LET*
   ((TEST-VALUE-001 (LOGIC-DIALECT SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-LOGIC-IN-KIF)
     (CL:LET*
      ((*TRANSIENTOBJECTS?* TRUE))
      (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
      (CL:LET*
       ((PARAMETERS (YIELD-RELATION-PARAMETERS-TREE SELF TRUE)))
       (CL:LET*
        ((SELF-001 SELF))
        (CL:COND
         ((CL:EQ (CLASS? SELF) 1)
          (CL:LET*
           ((SELF NULL))
           (CL:SETQ SELF SELF-001)
           (CL:SETQ PARAMETERS (CAST (FIRST PARAMETERS) SGT-LOGIC-IN-CONS))
           (SECOND-SETTER
            PARAMETERS
            (CL:IF
             (CL:EQ (EMPTY? (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS SELF)) 1)
             SYM-LOGIC-IN-UNKNOWN
             (TYPE-TO-SYMBOL
              (FIRST (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS SELF)))))
           (CL:WHEN
            (CL:NOT
             (CL:EQ (REST (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS SELF)) NIL))
            (CL:LET*
             ((SELFVARIABLE (FIRST PARAMETERS)) (RESTRICTIONS NIL))
             (CL:LET*
              ((OTHERSUPER NULL)
               (ITER-001 (REST (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS SELF)))
               (COLLECT-001 NULL))
              (CL:LOOP
               WHILE
               (CL:NOT (CL:EQ ITER-001 NIL))
               DO
               (CL:PROGN
                (CL:SETQ
                 OTHERSUPER
                 (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-LOGIC-IN-TYPE))
                (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
               (CL:IF
                (CL:EQ COLLECT-001 NULL)
                (CL:PROGN
                 (CL:SETQ
                  COLLECT-001
                  (CONS
                   (CONS (TYPE-TO-SYMBOL OTHERSUPER) (CONS SELFVARIABLE NIL))
                   NIL))
                 (CL:IF
                  (CL:EQ RESTRICTIONS NIL)
                  (CL:SETQ RESTRICTIONS COLLECT-001)
                  (ADD-CONS-TO-END-OF-CONS-LIST RESTRICTIONS COLLECT-001)))
                (CL:PROGN
                 (CL:SETF
                  (CLSYS-SVAL CONS REST COLLECT-001)
                  (CONS
                   (CONS (TYPE-TO-SYMBOL OTHERSUPER) (CONS SELFVARIABLE NIL))
                   NIL))
                 (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
             (CL:SETQ
              DEFINITION
              (CONS
               SYM-LOGIC-IN-AND
               (CONCATENATE RESTRICTIONS (CONS DEFINITION NIL))))))
           (CL:RETURN-FROM
            COMPLETE-SENTENCE-DEFINITION
            (LIST* SYM-LOGIC-IN-SETOFALL PARAMETERS (CONS DEFINITION NIL)))))
         (CL:T
          (CL:RETURN-FROM
           COMPLETE-SENTENCE-DEFINITION
           (LIST* SYM-LOGIC-IN-KAPPA PARAMETERS (CONS DEFINITION NIL)))))))))
    (CL:T
     (CL:WARN
      "complete-sentence-definition: Not yet implemented for dialect `~A'"
      (LOGIC-DIALECT SELF))
     (CL:RETURN-FROM COMPLETE-SENTENCE-DEFINITION NULL))))
  :VOID)

;;; (DEFUN (COMPLETE-TERM-DEFINITION OBJECT) ...)

(CL:DEFUN COMPLETE-TERM-DEFINITION (SELF DEFINITION)
  (CL:LET*
   ((TEST-VALUE-001 (LOGIC-DIALECT SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-LOGIC-IN-KIF)
     (CL:LET*
      ((VALUEVARIABLE (VALUE-VARIABLE-GETTER SELF)))
      (CL:LET*
       ((*TRANSIENTOBJECTS?* TRUE))
       (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
       (CL:SETQ
        DEFINITION
        (LIST*
         SYM-LOGIC-IN-KAPPA
         (YIELD-RELATION-PARAMETERS-TREE SELF TRUE)
         (CONS
          (LIST* SYM-LOGIC-IN-= DEFINITION (CONS VALUEVARIABLE NIL))
          NIL))))
      (CL:RETURN-FROM COMPLETE-TERM-DEFINITION DEFINITION)))
    (CL:T
     (CL:WARN
      "complete-term-definition: Not yet implemented for dialect `~A'"
      (LOGIC-DIALECT SELF))
     (CL:RETURN-FROM COMPLETE-TERM-DEFINITION NULL))))
  :VOID)

;;; (DEFUN RELATION-AXIOMS-HANDLER ...)

(CL:DEFUN RELATION-AXIOMS-HANDLER (SELF SLOT AXIOMS)
  (CL:SETQ SLOT SLOT)
  (CL:LET*
   ((OLDAXIOMS
     (CLSYS-SVAL
      STRING-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-LOGIC-IN-AXIOMS-STRING
       NULL-STRING-WRAPPER)))
    (NEWAXIOMS AXIOMS))
   (REMEMBER-UNFINALIZED-RELATION SELF)
   (CL:WHEN
    (CL:EQ (STRING? AXIOMS) 1)
    (CL:SETQ
     NEWAXIOMS
     (UNSTRINGIFY
      (CLSYS-SVAL
       STRING-WRAPPER
       WRAPPER-VALUE
       (CAST AXIOMS SGT-LOGIC-IN-STRING-WRAPPER)))))
   (SET-DYNAMIC-SLOT-VALUE
    SELF
    SYM-LOGIC-IN-AXIOMS-STRING
    (WRAP-STRING
     (STRINGIFY
      (ADD-RELATION-AXIOMS
       SELF
       (CL:IF (CL:EQ OLDAXIOMS NULL) NULL (UNSTRINGIFY OLDAXIOMS))
       NEWAXIOMS)))
    NULL-STRING-WRAPPER))
  :VOID)

;;; (DEFUN (ADD-RELATION-AXIOMS OBJECT) ...)

(CL:DEFUN ADD-RELATION-AXIOMS (SELF OLDAXIOMS NEWAXIOMS)
  (CL:LET*
   ((TEST-VALUE-001 (LOGIC-DIALECT SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-LOGIC-IN-KIF)
     (CL:LET*
      ((AXIOMS NIL))
      (CL:WHEN
       (CL:NOT (CL:EQ OLDAXIOMS NULL))
       (CL:LET*
        ((OLDAXIOMS-001 OLDAXIOMS))
        (CL:COND
         ((CL:EQ (CONS? OLDAXIOMS) 1)
          (CL:LET*
           ((OLDAXIOMS NULL))
           (CL:SETQ OLDAXIOMS OLDAXIOMS-001)
           (CL:IF
            (CL:EQ (FIRST OLDAXIOMS) SYM-LOGIC-IN-AND)
            (CL:SETQ AXIOMS OLDAXIOMS)
            (CL:SETQ AXIOMS (CONS OLDAXIOMS AXIOMS)))))
         (CL:T (CL:SETQ AXIOMS (CONS OLDAXIOMS AXIOMS))))))
      (CL:WHEN
       (CL:NOT (CL:EQ NEWAXIOMS NULL))
       (CL:LET*
        ((NEWAXIOMS-001 NEWAXIOMS))
        (CL:COND
         ((CL:EQ (CONS? NEWAXIOMS) 1)
          (CL:LET*
           ((NEWAXIOMS NULL))
           (CL:SETQ NEWAXIOMS NEWAXIOMS-001)
           (CL:COND
            ((CL:EQ (CONS? (FIRST NEWAXIOMS)) 1)
             (CL:SETQ
              AXIOMS
              (CONCATENATE AXIOMS (CONCATENATE NEWAXIOMS NIL))))
            ((CL:EQ (FIRST NEWAXIOMS) SYM-LOGIC-IN-AND)
             (CL:IF
              (CL:EQ AXIOMS NIL)
              (CL:SETQ AXIOMS NEWAXIOMS)
              (CL:SETQ
               AXIOMS
               (CONCATENATE
                AXIOMS
                (CONCATENATE (CLSYS-SVAL CONS REST NEWAXIOMS) NIL)))))
            (CL:T
             (CL:SETQ AXIOMS (CONCATENATE AXIOMS (CONS NEWAXIOMS NIL)))))))
         (CL:T (CL:SETQ AXIOMS (CONCATENATE AXIOMS (CONS NEWAXIOMS NIL)))))))
      (CL:CASE
       (LENGTH AXIOMS)
       (1 (CL:RETURN-FROM ADD-RELATION-AXIOMS (FIRST AXIOMS)))
       (CL:OTHERWISE
        (CL:WHEN
         (CL:NOT (CL:EQ (FIRST AXIOMS) SYM-LOGIC-IN-AND))
         (CL:SETQ AXIOMS (CONS SYM-LOGIC-IN-AND AXIOMS)))
        (CL:RETURN-FROM ADD-RELATION-AXIOMS AXIOMS)))))
    (CL:T
     (CL:WARN
      "add-relation-axioms: Not yet implemented for dialect `~A'"
      (LOGIC-DIALECT SELF))
     (CL:RETURN-FROM ADD-RELATION-AXIOMS NULL))))
  :VOID)

;;; (DEFUN RELATION-CONSTRAINTS-HANDLER ...)

(CL:DEFUN RELATION-CONSTRAINTS-HANDLER (SELF SLOT CONSTRAINTS)
  (CL:SETQ SLOT SLOT)
  (CL:LET*
   ((OLDAXIOMS
     (CLSYS-SVAL
      STRING-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-LOGIC-IN-AXIOMS-STRING
       NULL-STRING-WRAPPER)))
    (NEWAXIOMS NULL))
   (REMEMBER-UNFINALIZED-RELATION SELF)
   (CL:WHEN
    (CL:EQ (STRING? CONSTRAINTS) 1)
    (CL:SETQ
     CONSTRAINTS
     (UNSTRINGIFY
      (CLSYS-SVAL
       STRING-WRAPPER
       WRAPPER-VALUE
       (CAST CONSTRAINTS SGT-LOGIC-IN-STRING-WRAPPER)))))
   (CL:LET*
    ((CONSTRAINTS-001 CONSTRAINTS))
    (CL:COND
     ((CL:EQ (CONS? CONSTRAINTS) 1)
      (CL:LET*
       ((CONSTRAINTS NULL))
       (CL:SETQ CONSTRAINTS CONSTRAINTS-001)
       (CL:IF
        (CL:EQ (CONS? (FIRST CONSTRAINTS)) 1)
        (CL:LET*
         ((IT (ALLOCATE-ITERATOR CONSTRAINTS)))
         (CL:LOOP
          WHILE
          (CL:EQ (NEXT? IT) 1)
          DO
          (VALUE-SETTER
           IT
           (COMPLETE-CONSTRAINT-DEFINITION
            SELF
            (CLSYS-SVAL CONS-ITERATOR VALUE IT)))))
        (CL:SETQ
         CONSTRAINTS
         (CAST
          (COMPLETE-CONSTRAINT-DEFINITION SELF CONSTRAINTS)
          SGT-LOGIC-IN-CONS)))
       (CL:SETQ NEWAXIOMS CONSTRAINTS)))
     (CL:T
      (CL:SETQ NEWAXIOMS (COMPLETE-CONSTRAINT-DEFINITION SELF CONSTRAINTS)))))
   (SET-DYNAMIC-SLOT-VALUE
    SELF
    SYM-LOGIC-IN-AXIOMS-STRING
    (WRAP-STRING
     (STRINGIFY
      (ADD-RELATION-AXIOMS
       SELF
       (CL:IF (CL:EQ OLDAXIOMS NULL) NULL (UNSTRINGIFY OLDAXIOMS))
       NEWAXIOMS)))
    NULL-STRING-WRAPPER))
  :VOID)

;;; (DEFUN (COMPLETE-CONSTRAINT-DEFINITION OBJECT) ...)

(CL:DEFUN COMPLETE-CONSTRAINT-DEFINITION (SELF DEFINITION)
  (CL:LET*
   ((TEST-VALUE-001 (LOGIC-DIALECT SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-LOGIC-IN-KIF)
     (CL:LET*
      ((ANTECEDENT (YIELD-RELATION-PARAMETERS-TREE SELF FALSE)))
      (CL:LET*
       ((*TRANSIENTOBJECTS?* TRUE))
       (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
       (CL:LET*
        ((SELF-001 SELF))
        (CL:COND
         ((CL:EQ (CLASS? SELF) 1)
          (CL:LET*
           ((SELF NULL))
           (CL:SETQ SELF SELF-001)
           (CL:SETQ ANTECEDENT (CONS (CLASS-SYMBOL SELF) ANTECEDENT))))
         ((CL:EQ (TAXONOMY-ISA? SELF SGT-LOGIC-IN-SLOT) 1)
          (CL:LET*
           ((SELF NULL))
           (CL:SETQ SELF SELF-001)
           (CL:SETQ
            ANTECEDENT
            (CONS (CLSYS-SVAL SLOT SLOT-NAME SELF) ANTECEDENT))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" SELF))))
       (CL:WHEN
        (CL:EQ (FUNCTION? SELF) 1)
        (CL:SETQ
         ANTECEDENT
         (LIST*
          SYM-LOGIC-IN-=
          (REVERSE (CLSYS-SVAL CONS REST (REVERSE ANTECEDENT)))
          (CONS (VALUE-VARIABLE-GETTER (CAST SELF SGT-LOGIC-IN-SLOT)) NIL))))
       (CL:RETURN-FROM
        COMPLETE-CONSTRAINT-DEFINITION
        (LIST*
         SYM-LOGIC-IN-FORALL
         (YIELD-RELATION-PARAMETERS-TREE SELF TRUE)
         (CONS
          (LIST* SYM-LOGIC-IN-=> ANTECEDENT (CONS DEFINITION NIL))
          NIL))))))
    (CL:T
     (CL:WARN
      "complete-constraint-definition: Not yet implemented for dialect `~A'"
      (LOGIC-DIALECT SELF))
     (CL:RETURN-FROM COMPLETE-CONSTRAINT-DEFINITION NULL))))
  :VOID)

;;; (DEFGLOBAL *UNFINALIZED-DEFINED-RELATIONS* ...)

(CL:DEFVAR *UNFINALIZED-DEFINED-RELATIONS* NULL
  "List of relations whose definitions and/or associated
axioms and constraints are not yet processed.")

;;; (DEFUN REMEMBER-UNFINALIZED-RELATION ...)

(CL:DEFUN REMEMBER-UNFINALIZED-RELATION (SELF)
  (CL:WHEN
   (CL:AND
    (CL:EQ
     (CLSYS-SVAL
      STRING-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-LOGIC-IN-DEFINITION-STRING
       NULL-STRING-WRAPPER))
     NULL)
    (CL:EQ
     (CLSYS-SVAL
      STRING-WRAPPER
      WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE
       SELF
       SYM-LOGIC-IN-AXIOMS-STRING
       NULL-STRING-WRAPPER))
     NULL))
   (PUSH *UNFINALIZED-DEFINED-RELATIONS* SELF))
  :VOID)

;;; (DEFUN FINALIZE-DEFINED-RELATION ...)

(CL:DEFUN FINALIZE-DEFINED-RELATION (SELF)
  (CL:LET*
   ((*TOPLEVELPROPOSITIONS* NIL) (*LOGIC-DIALECT* (LOGIC-DIALECT SELF)))
   (CL:DECLARE (CL:SPECIAL *TOPLEVELPROPOSITIONS* *LOGIC-DIALECT*))
   (CL:LET*
    ((*MODULE* (HOME-MODULE SELF)) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (SET-DYNAMIC-SLOT-VALUE
     SELF
     SYM-LOGIC-IN-BAD?
     (WRAP-BOOLEAN TRUE)
     NULL-BOOLEAN-WRAPPER)
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (CLSYS-SVAL
        STRING-WRAPPER
        WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         SELF
         SYM-LOGIC-IN-DEFINITION-STRING
         NULL-STRING-WRAPPER))
       NULL))
     (CONSTRUCT-RELATION-DEFINITION SELF)
     (GET-DESCRIPTION SELF))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (CLSYS-SVAL
        STRING-WRAPPER
        WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         SELF
         SYM-LOGIC-IN-AXIOMS-STRING
         NULL-STRING-WRAPPER))
       NULL))
     (UPDATE-PROPOSITION
      (UNSTRINGIFY
       (CLSYS-SVAL
        STRING-WRAPPER
        WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         SELF
         SYM-LOGIC-IN-AXIOMS-STRING
         NULL-STRING-WRAPPER)))
      KWD-LOGIC-IN-ASSERT-TRUE)
     (CL:WHEN
      (CL:NOT (CL:EQ *TOPLEVELPROPOSITIONS* NULL))
      (CL:LET*
       ((SELF-001 (NEW-LIST)))
       (CL:SETF
        (CLSYS-SVAL LIST THE-CONS-LIST SELF-001)
        *TOPLEVELPROPOSITIONS*)
       (SET-DYNAMIC-SLOT-VALUE
        SELF
        SYM-LOGIC-IN-RELATION-ORIGINATED-PROPOSITIONS
        SELF-001
        NULL))))
    (SET-DYNAMIC-SLOT-VALUE
     SELF
     SYM-LOGIC-IN-BAD?
     (WRAP-BOOLEAN FALSE)
     NULL-BOOLEAN-WRAPPER)))
  :VOID)

;;; (DEFUN (FINALIZED-RELATION? BOOLEAN) ...)

(CL:DEFUN FINALIZED-RELATION? (SELF)
  (CL:LET*
   ((TEST-VALUE-001 FALSE))
   (CL:SETQ
    TEST-VALUE-001
    (CL:IF
     (CL:OR
      (CL:EQ
       (CLSYS-SVAL
        STRING-WRAPPER
        WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         SELF
         SYM-LOGIC-IN-DEFINITION-STRING
         NULL-STRING-WRAPPER))
       NULL)
      (CL:NOT
       (CL:EQ (DYNAMIC-SLOT-VALUE SELF SYM-LOGIC-IN-DEFINITION NULL) NULL))
      (CL:AND
       (CL:NOT
        (CL:EQ (DYNAMIC-SLOT-VALUE SELF SYM-LOGIC-IN-DESCRIPTION NULL) NULL))
       (CL:EQ
        (CLSYS-SVAL
         DESCRIPTION
         KIND
         (DYNAMIC-SLOT-VALUE SELF SYM-LOGIC-IN-DESCRIPTION NULL))
        KWD-LOGIC-IN-ENUMERATION)))
     TRUE
     FALSE))
   (CL:WHEN
    (CL:EQ TEST-VALUE-001 1)
    (CL:IF
     (CL:EQ
      (CLSYS-SVAL
       STRING-WRAPPER
       WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE
        SELF
        SYM-LOGIC-IN-AXIOMS-STRING
        NULL-STRING-WRAPPER))
      NULL)
     (CL:SETQ TEST-VALUE-001 TRUE)
     (CL:PROGN
      (CL:SETQ
       TEST-VALUE-001
       (DEFINED? (RELATION-ORIGINATED-PROPOSITIONS SELF)))
      (CL:WHEN
       (CL:EQ TEST-VALUE-001 1)
       (CL:LET*
        ((FOUND?-001 FALSE))
        (CL:LET*
         ((P NULL)
          (ITER-001
           (CLSYS-SVAL
            LIST
            THE-CONS-LIST
            (RELATION-ORIGINATED-PROPOSITIONS SELF))))
         (CL:LOOP
          WHILE
          (CL:NOT (CL:EQ ITER-001 NIL))
          DO
          (CL:PROGN
           (CL:SETQ
            P
            (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-LOGIC-IN-PROPOSITION))
           (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
          (CL:WHEN
           (CL:EQ (SUBRELATION-LINK? P) 0)
           (CL:SETQ FOUND?-001 TRUE)
           (CL:RETURN))))
        (CL:SETQ TEST-VALUE-001 FOUND?-001))))))
   (CL:LET*
    ((VALUE-001 TEST-VALUE-001))
    (CL:RETURN-FROM FINALIZED-RELATION? VALUE-001)))
  :VOID)

;;; (DEFUN FINALIZE-RELATIONS ...)

(CL:DEFUN FINALIZE-RELATIONS ()
  "Finalize all currently unfinalized relations."
  (CL:LET*
   ((RELATION NULL))
   (FINALIZE-CLASSES-AND-SLOTS)
   (CL:LOOP
    (CL:WHEN
     (CL:NOT (CL:EQ *UNFINALIZED-DEFINED-RELATIONS* NULL))
     (CL:SETQ RELATION (POP *UNFINALIZED-DEFINED-RELATIONS*)))
    (CL:WHEN (CL:EQ RELATION NULL) (CL:RETURN))
    (CL:WHEN
     (CL:AND
      (CL:EQ (DELETED? RELATION) 0)
      (CL:EQ (FINALIZED-RELATION? RELATION) 0))
     (FINALIZE-DEFINED-RELATION RELATION))))
  :VOID)

;;; (DEFUN (DEFINE-RELATION-FROM-PARSE-TREE RELATION) ...)

(CL:DEFUN DEFINE-RELATION-FROM-PARSE-TREE (TREE)
  (CL:RETURN-FROM
   DEFINE-RELATION-FROM-PARSE-TREE
   (HELP-DEFINE-RELATION-FROM-PARSE-TREE TREE (STRINGIFY TREE)))
  :VOID)

;;; (DEFUN (DEFFUNCTION RELATION) ...)

(CL:DEFUN %%DEFFUNCTION (ARGS)
  "Define (or redefine) a logic function.  The accepted syntax is:
	 
  (deffunction {<function-name> |
                (<function-name> <value-type>)} (<var>+)
     [:documentation <docstring>]
     [:-> <value-variable>]
     [:type <value-type>]
     [[{:definition | :is} <relation-expression>] |
      [<=> <sentence-with-argument-variables>] |
      [:= <term-expression-with-argument-variables>]]
     [:polymorphic? {TRUE | FALSE}]
     [:axioms {<sentence> | (<sentence>+)}]
     [:constraints {<sentence-with-argument-variables> |
                    (<sentence-with-argument-variables>+)}]
     [:properties <list-of-properties>]
     [:meta-attributes <list-of-key-value-pairs>]
     [<other-options>*])
	
Function parameters can be typed or untyped.  An untyped first parameter
or a `:polymorphic? FALSE' specification defines a non-polymorphic function.
Otherwise, the function will be polymorphic.  If a value variable is
specified, it must be specified before any definition options, otherwise,
the expansions of definitions might be incorrect.  The default KIF value
variable is `?value'."
  (CL:RETURN-FROM
   %%DEFFUNCTION
   (DEFINE-RELATION-FROM-PARSE-TREE
    (CONS SYM-LOGIC-IN-DEFFUNCTION (CONCATENATE ARGS NIL))))
  :VOID)

(CL:DEFUN DEFFUNCTION-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM DEFFUNCTION-EVALUATOR-WRAPPER (%%DEFFUNCTION ARGUMENTS))
  :VOID)

(CL:DEFMACRO DEFFUNCTION (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define (or redefine) a logic function.  The accepted syntax is:
	 
  (deffunction {<function-name> |
                (<function-name> <value-type>)} (<var>+)
     [:documentation <docstring>]
     [:-> <value-variable>]
     [:type <value-type>]
     [[{:definition | :is} <relation-expression>] |
      [<=> <sentence-with-argument-variables>] |
      [:= <term-expression-with-argument-variables>]]
     [:polymorphic? {TRUE | FALSE}]
     [:axioms {<sentence> | (<sentence>+)}]
     [:constraints {<sentence-with-argument-variables> |
                    (<sentence-with-argument-variables>+)}]
     [:properties <list-of-properties>]
     [:meta-attributes <list-of-key-value-pairs>]
     [<other-options>*])
	
Function parameters can be typed or untyped.  An untyped first parameter
or a `:polymorphic? FALSE' specification defines a non-polymorphic function.
Otherwise, the function will be polymorphic.  If a value variable is
specified, it must be specified before any definition options, otherwise,
the expansions of definitions might be incorrect.  The default KIF value
variable is `?value'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/DEFFUNCTION)) (CL:MACRO-FUNCTION (CL:QUOTE DEFFUNCTION)))

;;; (DEFUN (DEFRELATION RELATION) ...)

(CL:DEFUN %%DEFRELATION (ARGS)
  "Define (or redefine) a logic relation.  The accepted syntax is:
	 
  (defrelation {<relation-name> | 
                (<relation-name> BOOLEAN)} (<var>+)
     [:documentation <docstring>]
     [:type BOOLEAN]
     [[{:definition | :is} <relation-expression>] |
      [<=> <sentence-with-argument-variables>]]
     [:polymorphic? {TRUE | FALSE}]
     [:axioms {<sentence> | (<sentence>+)}]
     [:constraints {<sentence-with-argument-variables> |
                    (<sentence-with-argument-variables>+)}]
     [:properties <list-of-properties>]
     [:meta-attributes <list-of-key-value-pairs>]
     [<other-options>*])
	
Relation parameters can be typed or untyped.  An untyped first parameter
or a `:polymorphic? FALSE' specification defines a non-polymorphic relation.
Otherwise, the relation will be polymorphic."
  (CL:RETURN-FROM
   %%DEFRELATION
   (DEFINE-RELATION-FROM-PARSE-TREE
    (CONS SYM-LOGIC-IN-DEFRELATION (CONCATENATE ARGS NIL))))
  :VOID)

(CL:DEFUN DEFRELATION-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM DEFRELATION-EVALUATOR-WRAPPER (%%DEFRELATION ARGUMENTS))
  :VOID)

(CL:DEFMACRO DEFRELATION (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define (or redefine) a logic relation.  The accepted syntax is:
	 
  (defrelation {<relation-name> | 
                (<relation-name> BOOLEAN)} (<var>+)
     [:documentation <docstring>]
     [:type BOOLEAN]
     [[{:definition | :is} <relation-expression>] |
      [<=> <sentence-with-argument-variables>]]
     [:polymorphic? {TRUE | FALSE}]
     [:axioms {<sentence> | (<sentence>+)}]
     [:constraints {<sentence-with-argument-variables> |
                    (<sentence-with-argument-variables>+)}]
     [:properties <list-of-properties>]
     [:meta-attributes <list-of-key-value-pairs>]
     [<other-options>*])
	
Relation parameters can be typed or untyped.  An untyped first parameter
or a `:polymorphic? FALSE' specification defines a non-polymorphic relation.
Otherwise, the relation will be polymorphic."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/DEFRELATION)) (CL:MACRO-FUNCTION (CL:QUOTE DEFRELATION)))

;;; (DEFUN (DEFCONCEPT CLASS) ...)

(CL:DEFUN %%DEFCONCEPT (ARGS)
  "Define (or redefine) a class that is not a sort.
The accepted syntax is identical to that of `defclass'.  The only difference
is that the value of the `:sort?' option will always be forced to be FALSE.
This means that unrestricted inference might be used to determine whether
a particular object is an instance of a non-sortal class defined with
`defconcept', since no disjointness assumptions can be made.  For example,
suppose a hierarchy contains the classes `Human' and `Featherless-Biped'
which share a common superclass, say `Living-Thing'.  If the two classes
were defined as sorts, their extensions are assumed to be disjoint.  Thus,
even if we have a rule 
	 
  (forall (?x Living-Thing)
     (=> (and (Featherless ?x) (Biped ?x))
         (Featherless-Biped ?x)))
	
and `Human's are in fact featherless and bipeds, we will not be able to
infer `Human's to be `Featherless-Biped's.  However, if `Featherless-Biped'
was defined with `defconcept', the rule will become applicable, since now
`Human's and `Featherless-Biped's are not necessarily disjoint anymore.
CAUTION: The semantics of sorts is still somwhat in flux."
  (CL:LET*
   ((CLASS
     (DEFINE-CLASS-FROM-PARSE-TREE
      (CONS SYM-LOGIC-IN-DEFCLASS (CONCATENATE ARGS NIL)))))
   (CL:WHEN
    (CL:NOT (CL:EQ CLASS NULL))
    (SET-DYNAMIC-SLOT-VALUE
     CLASS
     SYM-LOGIC-IN-SORT?
     (WRAP-BOOLEAN FALSE)
     NULL-BOOLEAN-WRAPPER))
   (CL:RETURN-FROM %%DEFCONCEPT CLASS))
  :VOID)

(CL:DEFUN DEFCONCEPT-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM DEFCONCEPT-EVALUATOR-WRAPPER (%%DEFCONCEPT ARGUMENTS))
  :VOID)

(CL:DEFMACRO DEFCONCEPT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define (or redefine) a class that is not a sort.
The accepted syntax is identical to that of `defclass'.  The only difference
is that the value of the `:sort?' option will always be forced to be FALSE.
This means that unrestricted inference might be used to determine whether
a particular object is an instance of a non-sortal class defined with
`defconcept', since no disjointness assumptions can be made.  For example,
suppose a hierarchy contains the classes `Human' and `Featherless-Biped'
which share a common superclass, say `Living-Thing'.  If the two classes
were defined as sorts, their extensions are assumed to be disjoint.  Thus,
even if we have a rule 
	 
  (forall (?x Living-Thing)
     (=> (and (Featherless ?x) (Biped ?x))
         (Featherless-Biped ?x)))
	
and `Human's are in fact featherless and bipeds, we will not be able to
infer `Human's to be `Featherless-Biped's.  However, if `Featherless-Biped'
was defined with `defconcept', the rule will become applicable, since now
`Human's and `Featherless-Biped's are not necessarily disjoint anymore.
CAUTION: The semantics of sorts is still somwhat in flux."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/DEFCONCEPT)) (CL:MACRO-FUNCTION (CL:QUOTE DEFCONCEPT)))

;;; (DEFGLOBAL *LOGIC-RELEVANT-STELLA-COMMANDS* ...)

(CL:DEFVAR *LOGIC-RELEVANT-STELLA-COMMANDS* NULL)

;;; (DEFUN (COMMAND< BOOLEAN) ...)

(CL:DEFUN COMMAND< (COMMAND1 COMMAND2)
  (CL:RETURN-FROM
   COMMAND<
   (STRING<
    (VISIBLE-NAME (CLSYS-SVAL METHOD-SLOT SLOT-NAME COMMAND1))
    (VISIBLE-NAME (CLSYS-SVAL METHOD-SLOT SLOT-NAME COMMAND2))))
  :VOID)

;;; (DEFUN (LIST-LOGIC-COMMANDS (LIST OF METHOD-SLOT)) ...)

(CL:DEFUN LIST-LOGIC-COMMANDS ()
  (CL:LET*
   ((COMMANDS (NEW-LIST)))
   (CL:LET*
    ((FUNCTION NULL)
     (ITER-001 (ALL-FUNCTIONS (GET-MODULE "/LOGIC" TRUE) TRUE))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN
      (CL:SETQ
       FUNCTION
       (CAST (CLSYS-SVAL ITERATOR VALUE ITER-001) SGT-LOGIC-IN-FUNCTION)))
     (CL:WHEN
      (CL:EQ (METHOD-COMMAND? FUNCTION) 1)
      (CL:IF
       (CL:EQ COLLECT-001 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-001 (PERMANENT-CONS FUNCTION NIL))
        (CL:IF
         (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST COMMANDS) NIL)
         (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST COMMANDS) COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST
          (CLSYS-SVAL LIST THE-CONS-LIST COMMANDS)
          COLLECT-001)))
       (CL:PROGN
        (CL:SETF
         (CLSYS-SVAL CONS REST COLLECT-001)
         (PERMANENT-CONS FUNCTION NIL))
        (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001)))))))
   (CL:LET*
    ((STELLACOMMAND NULL)
     (ITER-002 *LOGIC-RELEVANT-STELLA-COMMANDS*)
     (COLLECT-002 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       STELLACOMMAND
       (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-LOGIC-IN-SYMBOL))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:IF
      (CL:EQ COLLECT-002 NULL)
      (CL:PROGN
       (CL:SETQ
        COLLECT-002
        (PERMANENT-CONS (LOOKUP-COMMAND STELLACOMMAND) NIL))
       (CL:IF
        (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST COMMANDS) NIL)
        (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST COMMANDS) COLLECT-002)
        (ADD-CONS-TO-END-OF-CONS-LIST
         (CLSYS-SVAL LIST THE-CONS-LIST COMMANDS)
         COLLECT-002)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-002)
        (PERMANENT-CONS (LOOKUP-COMMAND STELLACOMMAND) NIL))
       (CL:SETQ COLLECT-002 (CLSYS-SVAL CONS REST COLLECT-002))))))
   (CL:RETURN-FROM LIST-LOGIC-COMMANDS (SORT COMMANDS (CL:FUNCTION COMMAND<))))
  :VOID)

;;; (DEFUN HELP ...)

(CL:DEFUN %%HELP (COMMANDS)
  "Describe specific commands, or print a list of available commands."
  (CL:COND
   ((CL:EQ COMMANDS NIL)
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING
      "The following commands are available (type `(help <command>+)'"
      %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:WRITE-STRING "to get command-specific documentation):" %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CL:LET*
     ((COMMAND NULL)
      (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST (LIST-LOGIC-COMMANDS))))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ
        COMMAND
        (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-LOGIC-IN-METHOD-SLOT))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (PRINT-DOCUMENTATION COMMAND STANDARD-OUTPUT TRUE))))
   (CL:T
    (CL:LET*
     ((COMMANDNAME NULL) (ITER-002 COMMANDS))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-002 NIL))
      DO
      (CL:PROGN
       (CL:SETQ
        COMMANDNAME
        (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-LOGIC-IN-SYMBOL))
       (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
      (CL:LET*
       ((COMMAND (LOOKUP-COMMAND COMMANDNAME)))
       (CL:IF
        (CL:NOT (CL:EQ COMMAND NULL))
        (PRINT-DOCUMENTATION COMMAND STANDARD-OUTPUT FALSE)
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING "Undefined command: `" %%STREAM)
         (PRINT-OBJECT COMMANDNAME %%STREAM)
         (CL:WRITE-STRING "'" %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))))))))
  :VOID)

(CL:DEFUN HELP-EVALUATOR-WRAPPER (ARGUMENTS)
  (%%HELP ARGUMENTS)
  :VOID)

(CL:DEFMACRO HELP (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Describe specific commands, or print a list of available commands."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/HELP)) (CL:MACRO-FUNCTION (CL:QUOTE HELP)))

(CL:DEFUN STARTUP-LOGIC-IN ()
  (CL:WHEN
   (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 1) 1)
   (DEFINE-MODULE-FROM-STRINGIFIED-SOURCE
    "/PL-USER"
    "(:USES (\"LOGIC\" \"STELLA\"))"))
  (CL:LET*
   ((*MODULE* (GET-MODULE "/LOGIC" TRUE)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     KWD-LOGIC-IN-GOAL-TRACE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-TRACE" NULL 2))
    (CL:SETQ
     KWD-LOGIC-IN-CLOSED-WORLD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED-WORLD" NULL 2))
    (CL:SETQ
     KWD-LOGIC-IN-GOAL-TREE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-TREE" NULL 2))
    (CL:SETQ
     SGT-LOGIC-IN-LOGIC-EXCEPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-EXCEPTION" NULL 1))
    (CL:SETQ
     SYM-LOGIC-IN-SET-FEATURE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-FEATURE" NULL 0))
    (CL:SETQ
     KWD-LOGIC-IN-COMMON-LISP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
    (CL:SETQ
     KWD-LOGIC-IN-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     SYM-LOGIC-IN-EVALUATOR-WRAPPER-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "EVALUATOR-WRAPPER-CODE"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-LOGIC-IN-UNSET-FEATURE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNSET-FEATURE" NULL 0))
    (CL:SETQ
     SGT-LOGIC-IN-KEYWORD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     KWD-LOGIC-IN-REALISTIC
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REALISTIC" NULL 2))
    (CL:SETQ
     SYM-LOGIC-IN-*CAREFUL-LOGIC-COMMAND-LOOP-EXIT*?
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "*CAREFUL-LOGIC-COMMAND-LOOP-EXIT*?"
      NULL
      0))
    (CL:SETQ KWD-LOGIC-IN-BYE (INTERN-RIGID-SYMBOL-WRT-MODULE "BYE" NULL 2))
    (CL:SETQ KWD-LOGIC-IN-EXIT (INTERN-RIGID-SYMBOL-WRT-MODULE "EXIT" NULL 2))
    (CL:SETQ KWD-LOGIC-IN-HALT (INTERN-RIGID-SYMBOL-WRT-MODULE "HALT" NULL 2))
    (CL:SETQ KWD-LOGIC-IN-QUIT (INTERN-RIGID-SYMBOL-WRT-MODULE "QUIT" NULL 2))
    (CL:SETQ KWD-LOGIC-IN-STOP (INTERN-RIGID-SYMBOL-WRT-MODULE "STOP" NULL 2))
    (CL:SETQ SYM-LOGIC-IN-BYE (INTERN-RIGID-SYMBOL-WRT-MODULE "BYE" NULL 0))
    (CL:SETQ SYM-LOGIC-IN-EXIT (INTERN-RIGID-SYMBOL-WRT-MODULE "EXIT" NULL 0))
    (CL:SETQ SYM-LOGIC-IN-HALT (INTERN-RIGID-SYMBOL-WRT-MODULE "HALT" NULL 0))
    (CL:SETQ SYM-LOGIC-IN-QUIT (INTERN-RIGID-SYMBOL-WRT-MODULE "QUIT" NULL 0))
    (CL:SETQ SYM-LOGIC-IN-STOP (INTERN-RIGID-SYMBOL-WRT-MODULE "STOP" NULL 0))
    (CL:SETQ
     SGT-LOGIC-IN-READ-EXCEPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "READ-EXCEPTION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     KWD-LOGIC-IN-DEFINE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE" NULL 2))
    (CL:SETQ
     SYM-LOGIC-IN-DEFCLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "DEFCLASS"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-LOGIC-IN-DEFSLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFSLOT" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-LOGIC-IN-DEFUN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFUN" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-LOGIC-IN-DEFMETHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "DEFMETHOD"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-LOGIC-IN-DEFMODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "DEFMODULE"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-LOGIC-IN-IN-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "IN-MODULE"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SGT-LOGIC-IN-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-LOGIC-IN-STORAGE-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "STORAGE-SLOT"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-LOGIC-IN-METHOD-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "METHOD-SLOT"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-LOGIC-IN-STRING-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "STRING-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-LOGIC-IN-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-LOGIC-IN-VOID
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-LOGIC-IN-TRANSLATION-UNIT
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "TRANSLATION-UNIT"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-LOGIC-IN-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     KWD-LOGIC-IN-FINALIZE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE" NULL 2))
    (CL:SETQ
     SYM-LOGIC-IN-CLEAR-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "CLEAR-MODULE"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-LOGIC-IN-IN-DIALECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IN-DIALECT" NULL 0))
    (CL:SETQ SYM-LOGIC-IN-LOAD (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-*DEMO-LEVEL*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*DEMO-LEVEL*" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-FALSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SGT-LOGIC-IN-INTEGER-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "INTEGER-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ SYM-LOGIC-IN-DEMO (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMO" NULL 0))
    (CL:SETQ
     SGT-LOGIC-IN-STRING
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-LOGIC-IN-CONTEXT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-LOGIC-IN-SORT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SORT?" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-RELATION-PARAMETER-NAMES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-PARAMETER-NAMES" NULL 0))
    (CL:SETQ KWD-LOGIC-IN-KIF (INTERN-RIGID-SYMBOL-WRT-MODULE "KIF" NULL 2))
    (CL:SETQ
     SYM-LOGIC-IN-?SELF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?SELF" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-SELF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SELF" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-LOGIC-IN-SELF-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SELF-VARIABLE" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-?VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?VALUE" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-LOGIC-IN-VALUE-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE-VARIABLE" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-DEFFUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFFUNCTION" NULL 0))
    (CL:SETQ
     SGT-LOGIC-IN-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-LOGIC-IN-TYPE-SPEC
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "TYPE-SPEC"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-LOGIC-IN-UNKNOWN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     KWD-LOGIC-IN-POLYMORPHIC?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "POLYMORPHIC?" NULL 2))
    (CL:SETQ KWD-LOGIC-IN-TYPE (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 2))
    (CL:SETQ
     SGT-LOGIC-IN-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-LOGIC-IN-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     KWD-LOGIC-IN-ABSTRACT?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT?" NULL 2))
    (CL:SETQ
     SYM-LOGIC-IN-TRUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     KWD-LOGIC-IN-SELF-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SELF-VARIABLE" NULL 2))
    (CL:SETQ
     SYM-LOGIC-IN-VARIABLE-ARITY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "VARIABLE-ARITY?"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SGT-LOGIC-IN-COMPOUND-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "COMPOUND-TYPE-SPECIFIER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-LOGIC-IN-SLOT-TYPE-SPECIFIER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "SLOT-TYPE-SPECIFIER"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     KWD-LOGIC-IN-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
    (CL:SETQ
     SYM-LOGIC-IN-DOCUMENTATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "DOCUMENTATION"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     KWD-LOGIC-IN-SINGLE-VALUED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SINGLE-VALUED?" NULL 2))
    (CL:SETQ
     KWD-LOGIC-IN-PROPERTIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTIES" NULL 2))
    (CL:SETQ
     SGT-LOGIC-IN-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-LOGIC-IN-PROPERTIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "PROPERTIES"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     KWD-LOGIC-IN-META-ATTRIBUTES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "META-ATTRIBUTES" NULL 2))
    (CL:SETQ
     SGT-LOGIC-IN-KEY-VALUE-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "KEY-VALUE-LIST"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-LOGIC-IN-META-ATTRIBUTES
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "META-ATTRIBUTES"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-LOGIC-IN-RELATION-STRINGIFIED-SOURCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-STRINGIFIED-SOURCE" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-&REST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "&REST" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-LOGIC-IN-ARGUMENT-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "ARGUMENT-LIST"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-LOGIC-IN-OF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OF" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SGT-LOGIC-IN-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-LOGIC-IN-RELATION-ORIGINATED-PROPOSITIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "RELATION-ORIGINATED-PROPOSITIONS"
      NULL
      0))
    (CL:SETQ
     SGT-LOGIC-IN-BOOLEAN-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "BOOLEAN-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-LOGIC-IN-DEFINITION-STRING
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINITION-STRING" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-SLOT-OPTION-KEYWORD
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "SLOT-OPTION-KEYWORD"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SGT-LOGIC-IN-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TABLE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-LOGIC-IN-UNKNOWN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SGT-LOGIC-IN-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-LOGIC-IN-AND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-LOGIC-IN-SETOFALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOFALL" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-KAPPA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-=
     (INTERN-RIGID-SYMBOL-WRT-MODULE "=" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-LOGIC-IN-AXIOMS-STRING
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AXIOMS-STRING" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-FORALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-LOGIC-IN-=>
     (INTERN-RIGID-SYMBOL-WRT-MODULE "=>" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-LOGIC-IN-BAD?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BAD?" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     KWD-LOGIC-IN-ASSERT-TRUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
    (CL:SETQ
     SYM-LOGIC-IN-DEFINITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINITION" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
    (CL:SETQ
     KWD-LOGIC-IN-ENUMERATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ENUMERATION" NULL 2))
    (CL:SETQ
     SGT-LOGIC-IN-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
    (CL:SETQ
     SYM-LOGIC-IN-DEFRELATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFRELATION" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-DEFCONCEPT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFCONCEPT" NULL 0))
    (CL:SETQ
     SYM-LOGIC-IN-CC
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CC" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SGT-LOGIC-IN-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "FUNCTION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-LOGIC-IN-HELP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "HELP" NULL 0)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:SETQ
     *AVAILABLE-POWERLOOM-FEATURES*
     (LIST KWD-LOGIC-IN-GOAL-TRACE KWD-LOGIC-IN-CLOSED-WORLD))
    (CL:SETQ *CURRENT-POWERLOOM-FEATURES* (LIST))
    (CL:SETQ *DEFAULT-POWERLOOM-FEATURES* (LIST))
    (RESET-FEATURES)
    (CL:SETQ
     *DEMO-FILES*
     (LIST*
      (LIST*
       (WRAP-LITERAL "basics")
       (WRAP-LITERAL "Basic PowerLoom commands")
       NIL)
      (LIST*
       (WRAP-LITERAL "classes")
       (WRAP-LITERAL "Primitive and defined classes")
       NIL)
      (LIST*
       (WRAP-LITERAL "collections")
       (WRAP-LITERAL "Reasoning with collections")
       NIL)
      (LIST*
       (WRAP-LITERAL "append")
       (WRAP-LITERAL "Prolog-style `append'")
       NIL)
      (LIST*
       (WRAP-LITERAL "named-rules")
       (WRAP-LITERAL "Using named rules")
       NIL)
      (LIST*
       (WRAP-LITERAL "recursion")
       (WRAP-LITERAL "Reasoning with recursive rules")
       NIL)
      (LIST*
       (WRAP-LITERAL "negation")
       (WRAP-LITERAL "Reasoning with negation")
       NIL)
      (LIST*
       (WRAP-LITERAL "constraints")
       (WRAP-LITERAL "Constraint propagation")
       NIL)
      (LIST* (WRAP-LITERAL "subsumption") (WRAP-LITERAL "Subsumption") NIL)
      NIL))
    (CL:SETQ *UNFINALIZED-DEFINED-RELATIONS* (LIST))
    (CL:SETQ
     *LOGIC-RELEVANT-STELLA-COMMANDS*
     (LIST*
      SYM-LOGIC-IN-CC
      SYM-LOGIC-IN-CLEAR-MODULE
      SYM-LOGIC-IN-DEFCLASS
      SYM-LOGIC-IN-DEFMODULE
      SYM-LOGIC-IN-IN-MODULE
      NIL)))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-FEATURES"
        NULL
        "(DEFUN PRINT-FEATURES () :COMMAND? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Print the currently enabled and available PowerLoom environment features.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-FEATURES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SET-POWERLOOM-FEATURE"
        "KEYWORD"
        "(DEFUN SET-POWERLOOM-FEATURE ((FEATURE KEYWORD)) :DOCUMENTATION \"Enable the PowerLoom environment feature `feature'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SET-POWERLOOM-FEATURE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SET-FEATURE"
        "ARGUMENT-LIST"
        "(DEFUN (SET-FEATURE (LIST OF KEYWORD)) (|&REST| (FEATURES NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Enable the PowerLoom environment feature(s) named by `features'.
Return the list of enabled features.  Calling `set-feature' without any
arguments can be used to display the currently enabled features.
The following features are supported:

`closed-world': Enables closed-world reasoning.  NOT YET IMPLEMENTED!

`goal-trace': Enables the generation of goal trace information during
inference.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%SET-FEATURE))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-LOGIC-IN-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION SET-FEATURE-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNSET-POWERLOOM-FEATURE"
        "KEYWORD"
        "(DEFUN UNSET-POWERLOOM-FEATURE ((FEATURE KEYWORD)) :DOCUMENTATION \"Disable the PowerLoom environment feature `feature'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNSET-POWERLOOM-FEATURE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNSET-FEATURE"
        "ARGUMENT-LIST"
        "(DEFUN (UNSET-FEATURE (LIST OF KEYWORD)) (|&REST| (FEATURES NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Disable the PowerLoom environment feature(s) named by `features'.
Return the list of enabled features.  Calling `unset-feature' without any
arguments can be used to display the currently enabled features.
See `set-feature' for a description of supported features.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%UNSET-FEATURE))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-LOGIC-IN-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION UNSET-FEATURE-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RESET-FEATURES"
        NULL
        "(DEFUN (RESET-FEATURES (LIST OF KEYWORD)) () :COMMAND? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Reset the PowerLoom environment features to their default settings.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RESET-FEATURES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-LOGIC-PROMPT"
        NULL
        "(DEFUN PRINT-LOGIC-PROMPT ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-LOGIC-PROMPT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-LOGIC-COMMAND-RESULT"
        "OBJECT"
        "(DEFUN PRINT-LOGIC-COMMAND-RESULT ((RESULT OBJECT) (RESULTTYPE TYPE-SPEC)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-LOGIC-COMMAND-RESULT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOGIC-COMMAND-LOOP-EXIT?"
        "OBJECT"
        "(DEFUN (LOGIC-COMMAND-LOOP-EXIT? BOOLEAN BOOLEAN) ((COMMAND OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOGIC-COMMAND-LOOP-EXIT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOGIC-COMMAND-LOOP"
        NULL
        "(DEFUN LOGIC-COMMAND-LOOP ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOGIC-COMMAND-LOOP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-LOGIC-COMMAND"
        "OBJECT"
        "(DEFUN (EVALUATE-LOGIC-COMMAND OBJECT TYPE-SPEC BOOLEAN) ((COMMAND OBJECT) (FINALIZE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-LOGIC-COMMAND)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOAD"
        "STRING"
        "(DEFUN LOAD ((FILE STRING)) :DOCUMENTATION \"Read logic commands from `file' and evaluate them.\" :COMMAND? TRUE :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%LOAD))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-LOGIC-IN-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION LOAD-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-DEMO-PROMPT"
        NULL
        "(DEFUN PRINT-DEMO-PROMPT ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-DEMO-PROMPT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEMO-SKIP-TO-COMMAND"
        "INPUT-STREAM"
        "(DEFUN (DEMO-SKIP-TO-COMMAND BOOLEAN) ((STREAM INPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEMO-SKIP-TO-COMMAND)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEMO-PAUSE?"
        "BOOLEAN"
        "(DEFUN (DEMO-PAUSE? BOOLEAN BOOLEAN) ((PAUSE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEMO-PAUSE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEMO-FILE"
        "FILE-NAME"
        "(DEFUN DEMO-FILE ((FILE FILE-NAME) (PAUSE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEMO-FILE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SELECT-EXAMPLE-DEMO"
        "INTEGER"
        "(DEFUN (SELECT-EXAMPLE-DEMO STRING) ((INDEX INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SELECT-EXAMPLE-DEMO)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SELECT-EXAMPLE-DEMO-FROM-MENU"
        NULL
        "(DEFUN (SELECT-EXAMPLE-DEMO-FROM-MENU STRING) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SELECT-EXAMPLE-DEMO-FROM-MENU)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEMO-EXAMPLE-DEMOS"
        NULL
        "(DEFUN DEMO-EXAMPLE-DEMOS ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEMO-EXAMPLE-DEMOS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEMO"
        "ARGUMENT-LIST"
        "(DEFUN DEMO (|&REST| (FILEANDPAUSE OBJECT)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Read logic commands from a file, echo them verbatimly to standard output,
and evaluate them just as if they had been typed in interactively.
When called with no arguments, present a menu of example demos, otherwise,
use the first argument as the name of the file to demo.
Pause for user confirmation after each expression has been read but
before it is evaluated.  Pausing can be turned off by suppling FALSE
as the optional second argument, or by typing `c' at the pause prompt.
Typing `?' at the pause prompt prints a list of available commands.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%DEMO))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-LOGIC-IN-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION DEMO-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TEST-LOGIC-FILE"
        "FILE-NAME"
        "(DEFUN TEST-LOGIC-FILE ((FILE FILE-NAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TEST-LOGIC-FILE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RUN-POWERLOOM-TESTS"
        NULL
        "(DEFUN RUN-POWERLOOM-TESTS () :COMMAND? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Run the PowerLoom test suite.  Currently this simply runs all demos and
echos commands and their results to standard output.  The output can then
be diffed with previously validated runs to find deviations.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RUN-POWERLOOM-TESTS)))
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT RELATION SORT? :TYPE BOOLEAN :OPTION-KEYWORD :SORT? :DOCUMENTATION \"If TRUE, indicates that the relation is a class 
belonging to a sortal hierarchy that assumes disjointness of sorts
(classes) not having a common subsort.\" :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT CLASS SORT? :TYPE BOOLEAN :DEFAULT TRUE :OPTION-KEYWORD :SORT? :DOCUMENTATION \"If TRUE, indicates that the class is a sort.\" :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT RELATION RELATION-STRINGIFIED-SOURCE :TYPE STRING :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT TABLE RELATION-PARAMETER-NAMES :TYPE (LIST OF SYMBOL) :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT TABLE RELATION-PARAMETER-TYPE-SPECIFIERS :RENAMES TUPLE-DOMAINS)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT RELATION SELF-VARIABLE :TYPE SYMBOL :READER SELF-VARIABLE-GETTER :OPTION-KEYWORD :SELF-VARIABLE :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT SLOT VALUE-VARIABLE :TYPE SYMBOL :READER VALUE-VARIABLE-GETTER :OPTION-KEYWORD :-> :ALLOCATION :DYNAMIC)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOGIC-DIALECT"
        "RELATION"
        "(DEFMETHOD (LOGIC-DIALECT KEYWORD) ((SELF RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LOGIC-DIALECT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFAULT-SELF-VARIABLE"
        "RELATION"
        "(DEFUN (DEFAULT-SELF-VARIABLE SYMBOL) ((SELF RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFAULT-SELF-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SELF-VARIABLE-GETTER"
        "RELATION"
        "(DEFMETHOD (SELF-VARIABLE-GETTER SYMBOL) ((SELF RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SELF-VARIABLE-GETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SELF-VARIABLE-GETTER"
        "TABLE"
        "(DEFMETHOD (SELF-VARIABLE-GETTER SYMBOL) ((SELF TABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SELF-VARIABLE-GETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SELF-VARIABLE-GETTER"
        "METHOD-SLOT"
        "(DEFMETHOD (SELF-VARIABLE-GETTER SYMBOL) ((SELF METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION SELF-VARIABLE-GETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFAULT-VALUE-VARIABLE"
        "RELATION"
        "(DEFUN (DEFAULT-VALUE-VARIABLE SYMBOL) ((SELF RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFAULT-VALUE-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VALUE-VARIABLE-GETTER"
        "SLOT"
        "(DEFMETHOD (VALUE-VARIABLE-GETTER SYMBOL) ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION VALUE-VARIABLE-GETTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-DEFINE-RELATION-FROM-PARSE-TREE"
        "CONS"
        "(DEFUN (HELP-DEFINE-RELATION-FROM-PARSE-TREE RELATION) ((TREE CONS) (STRINGIFIEDSOURCE STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-DEFINE-RELATION-FROM-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PARSE-RELATION-PARAMETERS-TREE"
        "CONS"
        "(DEFUN (PARSE-RELATION-PARAMETERS-TREE (LIST OF SYMBOL) (LIST OF TYPE-SPEC) BOOLEAN) ((PARAMETERS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PARSE-RELATION-PARAMETERS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-IDENTICAL-RELATION"
        "SYMBOL"
        "(DEFUN (GET-IDENTICAL-RELATION RELATION) ((NAME SYMBOL) (OWNER TYPE) (POLYMORPHIC? BOOLEAN) (STRINGIFIEDSOURCE STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-IDENTICAL-RELATION)))
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT RELATION DEFINITION-STRING :TYPE STRING :OPTION-KEYWORD :IS :OPTION-HANDLER RELATION-FULL-DEFINITION-HANDLER :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT RELATION DEFINITION-STRING-ALIAS :RENAMES DEFINITION-STRING :OPTION-KEYWORD :DEFINITION :OPTION-HANDLER RELATION-FULL-DEFINITION-HANDLER)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT RELATION DEFINITION-STRING-ALIAS2 :RENAMES DEFINITION-STRING :OPTION-KEYWORD :<=> :OPTION-HANDLER RELATION-SENTENCE-DEFINITION-HANDLER)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT RELATION DEFINITION-STRING-ALIAS3 :RENAMES DEFINITION-STRING :OPTION-KEYWORD := :OPTION-HANDLER RELATION-TERM-DEFINITION-HANDLER)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT RELATION AXIOMS-STRING :TYPE STRING :OPTION-KEYWORD :AXIOMS :OPTION-HANDLER RELATION-AXIOMS-HANDLER :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT RELATION AXIOMS-STRING-ALIAS :RENAMES AXIOMS-STRING :OPTION-KEYWORD :CONSTRAINTS :OPTION-HANDLER RELATION-CONSTRAINTS-HANDLER)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT RELATION RELATION-ORIGINATED-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :ALLOCATION :DYNAMIC)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FUNCTION?"
        "RELATION"
        "(DEFMETHOD (FUNCTION? BOOLEAN) ((SELF RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FUNCTION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FUNCTION?"
        "SLOT"
        "(DEFMETHOD (FUNCTION? BOOLEAN) ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FUNCTION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RELATION-FULL-DEFINITION-HANDLER"
        "RELATION"
        "(DEFUN RELATION-FULL-DEFINITION-HANDLER ((SELF RELATION) (SLOT STORAGE-SLOT) (DEFINITION OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RELATION-FULL-DEFINITION-HANDLER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RELATION-SENTENCE-DEFINITION-HANDLER"
        "RELATION"
        "(DEFUN RELATION-SENTENCE-DEFINITION-HANDLER ((SELF RELATION) (SLOT STORAGE-SLOT) (DEFINITION OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RELATION-SENTENCE-DEFINITION-HANDLER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RELATION-TERM-DEFINITION-HANDLER"
        "RELATION"
        "(DEFUN RELATION-TERM-DEFINITION-HANDLER ((SELF RELATION) (SLOT STORAGE-SLOT) (DEFINITION OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RELATION-TERM-DEFINITION-HANDLER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-RELATION-PARAMETERS-TREE"
        "RELATION"
        "(DEFUN (YIELD-RELATION-PARAMETERS-TREE CONS) ((SELF RELATION) (TYPED? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-RELATION-PARAMETERS-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPLETE-SENTENCE-DEFINITION"
        "RELATION"
        "(DEFUN (COMPLETE-SENTENCE-DEFINITION OBJECT) ((SELF RELATION) (DEFINITION OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPLETE-SENTENCE-DEFINITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPLETE-TERM-DEFINITION"
        "SLOT"
        "(DEFUN (COMPLETE-TERM-DEFINITION OBJECT) ((SELF SLOT) (DEFINITION OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPLETE-TERM-DEFINITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RELATION-AXIOMS-HANDLER"
        "RELATION"
        "(DEFUN RELATION-AXIOMS-HANDLER ((SELF RELATION) (SLOT STORAGE-SLOT) (AXIOMS OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RELATION-AXIOMS-HANDLER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ADD-RELATION-AXIOMS"
        "RELATION"
        "(DEFUN (ADD-RELATION-AXIOMS OBJECT) ((SELF RELATION) (OLDAXIOMS OBJECT) (NEWAXIOMS OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ADD-RELATION-AXIOMS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RELATION-CONSTRAINTS-HANDLER"
        "RELATION"
        "(DEFUN RELATION-CONSTRAINTS-HANDLER ((SELF RELATION) (SLOT STORAGE-SLOT) (CONSTRAINTS OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RELATION-CONSTRAINTS-HANDLER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPLETE-CONSTRAINT-DEFINITION"
        "RELATION"
        "(DEFUN (COMPLETE-CONSTRAINT-DEFINITION OBJECT) ((SELF RELATION) (DEFINITION OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPLETE-CONSTRAINT-DEFINITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMEMBER-UNFINALIZED-RELATION"
        "RELATION"
        "(DEFUN REMEMBER-UNFINALIZED-RELATION ((SELF RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REMEMBER-UNFINALIZED-RELATION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-DEFINED-RELATION"
        "RELATION"
        "(DEFUN FINALIZE-DEFINED-RELATION ((SELF RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINALIZE-DEFINED-RELATION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZED-RELATION?"
        "RELATION"
        "(DEFUN (FINALIZED-RELATION? BOOLEAN) ((SELF RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINALIZED-RELATION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINALIZE-RELATIONS"
        NULL
        "(DEFUN FINALIZE-RELATIONS () :DOCUMENTATION \"Finalize all currently unfinalized relations.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINALIZE-RELATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFINE-RELATION-FROM-PARSE-TREE"
        "CONS"
        "(DEFUN (DEFINE-RELATION-FROM-PARSE-TREE RELATION) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFINE-RELATION-FROM-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFFUNCTION"
        "ARGUMENT-LIST"
        "(DEFUN (DEFFUNCTION RELATION) (|&REST| (ARGS PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Define (or redefine) a logic function.  The accepted syntax is:
	 
  (deffunction {<function-name> |
                (<function-name> <value-type>)} (<var>+)
     [:documentation <docstring>]
     [:-> <value-variable>]
     [:type <value-type>]
     [[{:definition | :is} <relation-expression>] |
      [<=> <sentence-with-argument-variables>] |
      [:= <term-expression-with-argument-variables>]]
     [:polymorphic? {TRUE | FALSE}]
     [:axioms {<sentence> | (<sentence>+)}]
     [:constraints {<sentence-with-argument-variables> |
                    (<sentence-with-argument-variables>+)}]
     [:properties <list-of-properties>]
     [:meta-attributes <list-of-key-value-pairs>]
     [<other-options>*])
	
Function parameters can be typed or untyped.  An untyped first parameter
or a `:polymorphic? FALSE' specification defines a non-polymorphic function.
Otherwise, the function will be polymorphic.  If a value variable is
specified, it must be specified before any definition options, otherwise,
the expansions of definitions might be incorrect.  The default KIF value
variable is `?value'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%DEFFUNCTION))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-LOGIC-IN-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION DEFFUNCTION-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFRELATION"
        "ARGUMENT-LIST"
        "(DEFUN (DEFRELATION RELATION) (|&REST| (ARGS PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Define (or redefine) a logic relation.  The accepted syntax is:
	 
  (defrelation {<relation-name> | 
                (<relation-name> BOOLEAN)} (<var>+)
     [:documentation <docstring>]
     [:type BOOLEAN]
     [[{:definition | :is} <relation-expression>] |
      [<=> <sentence-with-argument-variables>]]
     [:polymorphic? {TRUE | FALSE}]
     [:axioms {<sentence> | (<sentence>+)}]
     [:constraints {<sentence-with-argument-variables> |
                    (<sentence-with-argument-variables>+)}]
     [:properties <list-of-properties>]
     [:meta-attributes <list-of-key-value-pairs>]
     [<other-options>*])
	
Relation parameters can be typed or untyped.  An untyped first parameter
or a `:polymorphic? FALSE' specification defines a non-polymorphic relation.
Otherwise, the relation will be polymorphic.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%DEFRELATION))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-LOGIC-IN-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION DEFRELATION-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "DEFCLASS"
     "ARGUMENT-LIST"
     "(DEFUN (DEFCLASS CLASS) (|&REST| (ARGS PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :NATIVE? TRUE :DOCUMENTATION \"Define (or redefine) a class.  The accepted syntax is:
	 
  (defclass <class-name> (<superclass-name>*)
     [:documentation <docstring>]
     [:self-variable <var>]
     [[{:definition | :is} <relation-expression>] |
      [<=> <sentence-with-argument-variables>]]
     [:axioms {<sentence> | (<sentence>+)}]
     [:constraints {<sentence-with-argument-variables> |
                    (<sentence-with-argument-variables>+)}]
     [:sort? {TRUE | FALSE}]
     [:properties <list-of-properties>]
     [:meta-attributes <list-of-key-value-pairs>]
     [:slots ({(<slot-name> <slot-options>*)}*)]
     [<other-options>*])
	
<slot-options> is a list of keyword/value pairs.  The set of legal slot
options is the same as those accepted by `defrelation'.  Unless the `:sort?'
option specifies otherwise, classes defined with `defclass' are assumed
to be sorts, i.e., the extensions of two sibling classes that don't share
a common subclass are assumed to be disjoint.
CAUTION: The semantics of sorts is still somwhat in flux.\")")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFCONCEPT"
        "ARGUMENT-LIST"
        "(DEFUN (DEFCONCEPT CLASS) (|&REST| (ARGS PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Define (or redefine) a class that is not a sort.
The accepted syntax is identical to that of `defclass'.  The only difference
is that the value of the `:sort?' option will always be forced to be FALSE.
This means that unrestricted inference might be used to determine whether
a particular object is an instance of a non-sortal class defined with
`defconcept', since no disjointness assumptions can be made.  For example,
suppose a hierarchy contains the classes `Human' and `Featherless-Biped'
which share a common superclass, say `Living-Thing'.  If the two classes
were defined as sorts, their extensions are assumed to be disjoint.  Thus,
even if we have a rule 
	 
  (forall (?x Living-Thing)
     (=> (and (Featherless ?x) (Biped ?x))
         (Featherless-Biped ?x)))
	
and `Human's are in fact featherless and bipeds, we will not be able to
infer `Human's to be `Featherless-Biped's.  However, if `Featherless-Biped'
was defined with `defconcept', the rule will become applicable, since now
`Human's and `Featherless-Biped's are not necessarily disjoint anymore.
CAUTION: The semantics of sorts is still somwhat in flux.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%DEFCONCEPT))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-LOGIC-IN-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION DEFCONCEPT-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMMAND<"
        "METHOD-SLOT"
        "(DEFUN (COMMAND< BOOLEAN) ((COMMAND1 METHOD-SLOT) (COMMAND2 METHOD-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMMAND<)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LIST-LOGIC-COMMANDS"
        NULL
        "(DEFUN (LIST-LOGIC-COMMANDS (LIST OF METHOD-SLOT)) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LIST-LOGIC-COMMANDS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP"
        "ARGUMENT-LIST"
        "(DEFUN HELP (|&REST| (COMMANDS SYMBOL)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Describe specific commands, or print a list of available commands.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%HELP))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-LOGIC-IN-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION HELP-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-LOGIC-IN"
     NULL
     "(DEFUN STARTUP-LOGIC-IN ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *AVAILABLE-POWERLOOM-FEATURES* (LIST OF KEYWORD) (LIST :GOAL-TRACE :CLOSED-WORLD) :DOCUMENTATION \"List of PowerLoom environment features.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CURRENT-POWERLOOM-FEATURES* (LIST OF KEYWORD) (LIST) :DOCUMENTATION \"List of currently enabled PowerLoom environment features.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEFAULT-POWERLOOM-FEATURES* (LIST OF KEYWORD) (LIST) :DOCUMENTATION \"List of PowerLoom environment features enabled upon call to
'reset-features'.\")")
    (REGISTER-NATIVE-NAME
     SYM-LOGIC-IN-SET-FEATURE
     KWD-LOGIC-IN-COMMON-LISP
     KWD-LOGIC-IN-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-LOGIC-IN-UNSET-FEATURE
     KWD-LOGIC-IN-COMMON-LISP
     KWD-LOGIC-IN-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOGIC-PROMPT* STRING \"|= \" :DOCUMENTATION \"The prompt used by the PowerLoom listener.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOGIC-COMMAND-RESULT-INDENT* STRING \"\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CAREFUL-LOGIC-COMMAND-LOOP-EXIT*? BOOLEAN (VERBATIM :COMMON-LISP FALSE :OTHERWISE TRUE) :DOCUMENTATION \"If TRUE exiting from the logic-command loop (or PowerLoom
listener) will be protected by a confirmation dialog.  This is mainly useful
for C++ where exiting the listener will also exit the program.\" :PUBLIC? TRUE)")
    (CL:LET*
     ((GLOBAL
       (LOOKUP-GLOBAL-VARIABLE
        SYM-LOGIC-IN-*CAREFUL-LOGIC-COMMAND-LOOP-EXIT*?)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*CAREFUL-LOGIC-COMMAND-LOOP-EXIT*?))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*CAREFUL-LOGIC-COMMAND-LOOP-EXIT*?)))
    (REGISTER-NATIVE-NAME
     SYM-LOGIC-IN-LOAD
     KWD-LOGIC-IN-COMMON-LISP
     KWD-LOGIC-IN-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DEMO-LEVEL* INTEGER 0)")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-LOGIC-IN-*DEMO-LEVEL*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*DEMO-LEVEL*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*DEMO-LEVEL*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEMO-FILE-DIRECTORY* STRING (VERBATIM :COMMON-LISP \"\\\"PL:sources;logic;demos;\\\"\" :CPP \"DEMO_FILE_PATHNAME\"))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEMO-FILE-SUFFIX* STRING \".ste\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEMO-FILES* (CONS OF (CONS OF STRING-WRAPPER)) (BQUOTE ((\"basics\" \"Basic PowerLoom commands\") (\"classes\" \"Primitive and defined classes\") (\"collections\" \"Reasoning with collections\") (\"append\" \"Prolog-style `append'\") (\"named-rules\" \"Using named rules\") (\"recursion\" \"Reasoning with recursive rules\") (\"negation\" \"Reasoning with negation\") (\"constraints\" \"Constraint propagation\") (\"subsumption\" \"Subsumption\"))) :DOCUMENTATION \"List of example demo files.
Each entry is a `(<file> <description>)' pair.\")")
    (REGISTER-NATIVE-NAME
     SYM-LOGIC-IN-DEMO
     KWD-LOGIC-IN-COMMON-LISP
     KWD-LOGIC-IN-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *UNFINALIZED-DEFINED-RELATIONS* (LIST OF RELATION) (LIST) :DOCUMENTATION \"List of relations whose definitions and/or associated
axioms and constraints are not yet processed.\")")
    (REGISTER-NATIVE-NAME
     SYM-LOGIC-IN-DEFFUNCTION
     KWD-LOGIC-IN-COMMON-LISP
     KWD-LOGIC-IN-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-LOGIC-IN-DEFRELATION
     KWD-LOGIC-IN-COMMON-LISP
     KWD-LOGIC-IN-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-LOGIC-IN-DEFCONCEPT
     KWD-LOGIC-IN-COMMON-LISP
     KWD-LOGIC-IN-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOGIC-RELEVANT-STELLA-COMMANDS* (CONS OF SYMBOL) (BQUOTE (CC CLEAR-MODULE DEFCLASS DEFMODULE IN-MODULE)))")
    (REGISTER-NATIVE-NAME
     SYM-LOGIC-IN-HELP
     KWD-LOGIC-IN-COMMON-LISP
     KWD-LOGIC-IN-FUNCTION)))
  :VOID)
