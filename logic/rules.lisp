;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997                   | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-RULES-OR NULL)
(CL:DEFVAR SGT-RULES-PROPOSITION NULL)
(CL:DEFVAR KWD-RULES-AND NULL)
(CL:DEFVAR KWD-RULES-EXISTS NULL)
(CL:DEFVAR KWD-RULES-IN NULL)
(CL:DEFVAR SGT-RULES-SURROGATE NULL)
(CL:DEFVAR SGT-RULES-TYPE NULL)
(CL:DEFVAR SGT-RULES-SKOLEM NULL)
(CL:DEFVAR KWD-RULES-PREDICATE NULL)
(CL:DEFVAR KWD-RULES-FUNCTION NULL)
(CL:DEFVAR SGT-RULES-SLOTREF NULL)
(CL:DEFVAR KWD-RULES-NOT NULL)
(CL:DEFVAR SGT-RULES-CONS NULL)
(CL:DEFVAR SGT-RULES-DESCRIPTION NULL)
(CL:DEFVAR SYM-RULES-IMPLIES NULL)
(CL:DEFVAR SYM-RULES-SATELLITE-PROPOSITIONS NULL)
(CL:DEFVAR SYM-RULES-MASTER-PROPOSITION NULL)
(CL:DEFVAR SGT-RULES-PATTERN-VARIABLE NULL)
(CL:DEFVAR KWD-RULES-HEAD NULL)
(CL:DEFVAR KWD-RULES-TAIL NULL)
(CL:DEFVAR SYM-RULES-EXISTS NULL)
(CL:DEFVAR SYM-RULES-IO-VARIABLES NULL)
(CL:DEFVAR SGT-RULES-VECTOR NULL)
(CL:DEFVAR KWD-RULES-ASSERT-TRUE NULL)
(CL:DEFVAR SYM-RULES-DESCRIPTION NULL)
(CL:DEFVAR KWD-RULES-IMPLIES NULL)
(CL:DEFVAR SYM-RULES-COMPLEMENT-DESCRIPTION NULL)
(CL:DEFVAR SGT-RULES-SLOT NULL)
(CL:DEFVAR SYM-RULES-SURROGATE-VALUE-INVERSE NULL)
(CL:DEFVAR SYM-RULES-DEFRULE NULL)
(CL:DEFVAR KWD-RULES-COMMON-LISP NULL)
(CL:DEFVAR SGT-RULES-CLASS NULL)
(CL:DEFVAR SYM-RULES-ESTIMATED-CARDINALITY NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *MODULE*
  NULL-INTEGER-WRAPPER
  *EXCEPTIONHANDLERADDRESS*
  *EXCEPTION*
  *PROPOSITIONUNDERCONSTRUCTION*
  *THE-PROPOSITION-ERROR*
  STANDARD-OUTPUT
  NIL-LIST
  EOL))

;;; (DEFUN (FIND-RULE-TAILS (LIST OF CONS) BOOLEAN) ...)

(CL:DEFUN FIND-RULE-TAILS (PROPOSITION VARIABLES)
  (CL:LET*
   ((RESULTLIST (NEW-LIST)) (EQUIVALENT? FALSE))
   (CL:LET*
    ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-RULES-OR)
      (CL:LET*
       ((ARG NULL)
        (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
        (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:LOOP
        WHILE
        (CL:< INDEX-001 LENGTH-001)
        DO
        (CL:PROGN
         (CL:SETQ
          ARG
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
        (COLLECT-MATCHING-RULE-GOAL
         (CAST ARG SGT-RULES-PROPOSITION)
         VARIABLES
         RESULTLIST))))
     (CL:T
      (COLLECT-MATCHING-RULE-GOAL PROPOSITION VARIABLES RESULTLIST)
      (CL:SETQ EQUIVALENT? (EQ? (LENGTH RESULTLIST) 1)))))
   (CL:RETURN-FROM FIND-RULE-TAILS (CL:VALUES RESULTLIST EQUIVALENT?)))
  :VOID)

;;; (DEFUN (FIND-RULE-HEADS LIST BOOLEAN) ...)

(CL:DEFUN FIND-RULE-HEADS (PROPOSITION VARIABLES)
  (CL:LET*
   ((RESULTLIST (NEW-LIST)) (EQUIVALENT? FALSE))
   (CL:LET*
    ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-RULES-AND)
      (CL:LET*
       ((NONVARIABLETYPESCOUNTER 0))
       (CL:LET*
        ((ARG NULL)
         (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
         (INDEX-001 0)
         (LENGTH-001 (LENGTH VECTOR-001)))
        (CL:LOOP
         WHILE
         (CL:< INDEX-001 LENGTH-001)
         DO
         (CL:PROGN
          (CL:SETQ
           ARG
           (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
          (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
         (CL:WHEN
          (CL:EQ (VARIABLE-TYPE? (CAST ARG SGT-RULES-PROPOSITION)) 0)
          (COLLECT-MATCHING-RULE-GOAL
           (CAST ARG SGT-RULES-PROPOSITION)
           VARIABLES
           RESULTLIST)
          (CL:SETQ NONVARIABLETYPESCOUNTER (CL:1+ NONVARIABLETYPESCOUNTER)))))
       (CL:SETQ
        EQUIVALENT?
        (CL:IF
         (CL:AND
          (CL:= NONVARIABLETYPESCOUNTER 1)
          (CL:EQ (EMPTY? RESULTLIST) 0))
         TRUE
         FALSE))))
     ((CL:EQ TEST-VALUE-001 KWD-RULES-EXISTS)
      (FREE RESULTLIST)
      (CL:RETURN-FROM
       FIND-RULE-HEADS
       (FIND-RULE-HEADS
        (CAST
         (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
         SGT-RULES-PROPOSITION)
        VARIABLES)))
     (CL:T
      (COLLECT-MATCHING-RULE-GOAL PROPOSITION VARIABLES RESULTLIST)
      (CL:SETQ EQUIVALENT? (EQ? (LENGTH RESULTLIST) 1)))))
   (CL:RETURN-FROM FIND-RULE-HEADS (CL:VALUES RESULTLIST EQUIVALENT?)))
  :VOID)

;;; (DEFUN COLLECT-MATCHING-RULE-GOAL ...)

(CL:DEFUN COLLECT-MATCHING-RULE-GOAL (GOAL VARIABLES COLLECTION)
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND GOAL)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-RULES-IN)
     (CL:LET*
      ((FIRSTARG (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL)))
       (SECONDARG (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))))
      (CL:COND
       ((CL:AND
         (CL:EQ FIRSTARG (FIRST VARIABLES))
         (CL:EQ (ISA? SECONDARG SGT-RULES-SURROGATE) 1))
        (PUSH
         COLLECTION
         (CONS-LIST
          (GET-DESCRIPTION (CAST SECONDARG SGT-RULES-TYPE))
          VARIABLES)))
       ((CL:AND
         (CL:EQ FALSE 1)
         (CL:EQ FIRSTARG (SECOND VARIABLES))
         (CL:EQ (ISA? SECONDARG SGT-RULES-SKOLEM) 1))
        (CL:LET*
         ((FUNCTIONPROPOSITION
           (CLSYS-SVAL
            SKOLEM
            DEFINING-PROPOSITION
            (CAST SECONDARG SGT-RULES-SKOLEM))))
         (CL:WHEN
          (CL:AND
           (CL:NOT (CL:EQ FUNCTIONPROPOSITION NULL))
           (CL:EQ
            (EQL?
             SECONDARG
             (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS FUNCTIONPROPOSITION)))
            1)
           (CL:EQ
            (FIRST VARIABLES)
            (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS FUNCTIONPROPOSITION)))
           (CL:EQ
            (ISA?
             (CLSYS-SVAL PROPOSITION OPERATOR FUNCTIONPROPOSITION)
             SGT-RULES-SURROGATE)
            1))
          "NOT YET IMPLEMENTED"))))))
    ((CL:OR
      (CL:EQ TEST-VALUE-001 KWD-RULES-PREDICATE)
      (CL:EQ TEST-VALUE-001 KWD-RULES-FUNCTION))
     (CL:LET*
      ((TEST-VALUE-002 FALSE))
      (CL:SETQ
       TEST-VALUE-002
       (ISA? (CLSYS-SVAL PROPOSITION OPERATOR GOAL) SGT-RULES-SURROGATE))
      (CL:WHEN
       (CL:EQ TEST-VALUE-002 1)
       (CL:LET*
        ((ALWAYS?-001 TRUE))
        (CL:LET*
         ((A NULL)
          (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))
          (INDEX-001 0)
          (LENGTH-001 (LENGTH VECTOR-001)))
         (CL:LOOP
          WHILE
          (CL:< INDEX-001 LENGTH-001)
          DO
          (CL:PROGN
           (CL:SETQ
            A
            (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
           (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
          (CL:WHEN
           (CL:EQ (MEMBER? VARIABLES A) 0)
           (CL:SETQ ALWAYS?-001 FALSE)
           (CL:RETURN))))
        (CL:SETQ TEST-VALUE-002 ALWAYS?-001)))
      (CL:WHEN
       (CL:EQ TEST-VALUE-002 1)
       (PUSH
        COLLECTION
        (CONS-LIST
         (GET-DESCRIPTION
          (CAST (CLSYS-SVAL PROPOSITION OPERATOR GOAL) SGT-RULES-SLOTREF))
         (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))))))
    ((CL:EQ TEST-VALUE-001 KWD-RULES-NOT)
     (CL:LET*
      ((COMPLEMENTOFGOAL (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL)))
       (TEMPLIST (NEW-LIST))
       (MATCHINGPAIR NULL))
      (COLLECT-MATCHING-RULE-GOAL
       (CAST COMPLEMENTOFGOAL SGT-RULES-PROPOSITION)
       VARIABLES
       TEMPLIST)
      (CL:SETQ MATCHINGPAIR (CAST (FIRST TEMPLIST) SGT-RULES-CONS))
      (FREE TEMPLIST)
      (CL:WHEN
       (CL:NOT (CL:EQ MATCHINGPAIR NULL))
       (FIRST-SETTER
        MATCHINGPAIR
        (GET-COMPLEMENT-DESCRIPTION
         (CAST (FIRST MATCHINGPAIR) SGT-RULES-DESCRIPTION)))
       (PUSH COLLECTION MATCHINGPAIR))))
    ((CL:EQ TEST-VALUE-001 KWD-RULES-AND)
     (CL:LET*
      ((SINGLEATOMICGOAL NULL))
      (CL:LET*
       ((G NULL)
        (VECTOR-002 (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))
        (INDEX-002 0)
        (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:LOOP
        WHILE
        (CL:< INDEX-002 LENGTH-002)
        DO
        (CL:PROGN
         (CL:SETQ
          G
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
         (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
        (CL:WHEN
         (CL:EQ (VARIABLE-TYPE? (CAST G SGT-RULES-PROPOSITION)) 0)
         (CL:IF
          (CL:EQ SINGLEATOMICGOAL NULL)
          (CL:SETQ SINGLEATOMICGOAL (CAST G SGT-RULES-PROPOSITION))
          (CL:RETURN-FROM COLLECT-MATCHING-RULE-GOAL)))))
      (CL:WHEN
       (CL:NOT (CL:EQ SINGLEATOMICGOAL NULL))
       (COLLECT-MATCHING-RULE-GOAL SINGLEATOMICGOAL VARIABLES COLLECTION))))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN (MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT OBJECT) ...)

(CL:DEFUN MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT (ARG1 ARG2)
  (CL:WHEN
   (CL:OR (CL:EQ (SKOLEM? ARG2) 1) (CL:EQ (DESCRIPTION-MODE?) 1))
   (CL:LET*
    ((ARG1-001 ARG1))
    (CL:COND
     ((CL:EQ (TAXONOMY-ISA? ARG1 SGT-RULES-DESCRIPTION) 1)
      (CL:LET*
       ((ARG1 NULL))
       (CL:SETQ ARG1 ARG1-001)
       (CL:WHEN
        (CL:NOT (CL:EQ (DESCRIPTION-SURROGATE ARG1) NULL))
        (CL:RETURN-FROM
         MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT
         (DESCRIPTION-SURROGATE ARG1)))))
     (CL:T NULL))))
  (CL:RETURN-FROM MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT ARG1)
  :VOID)

;;; (DEFUN (FINISH-BUILDING-IMPLIES-PROPOSITION PROPOSITION) ...)

(CL:DEFUN FINISH-BUILDING-IMPLIES-PROPOSITION (HEAD TAIL FORALLPROP REPLACESFORALL?)
  (CL:LET*
   ((IMPLIESPROP (CREATE-PROPOSITION SYM-RULES-IMPLIES 2)))
   (CL:SETF
    (CL:AREF
     (CLSYS-SVAL
      VECTOR
      THE-ARRAY
      (CLSYS-SVAL PROPOSITION ARGUMENTS IMPLIESPROP))
     0)
    (MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT TAIL HEAD))
   (CL:SETF
    (CL:AREF
     (CLSYS-SVAL
      VECTOR
      THE-ARRAY
      (CLSYS-SVAL PROPOSITION ARGUMENTS IMPLIESPROP))
     1)
    (MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT HEAD TAIL))
   (CL:WHEN
    (CL:EQ REPLACESFORALL? 1)
    (CL:RETURN-FROM FINISH-BUILDING-IMPLIES-PROPOSITION IMPLIESPROP))
   (CL:LET*
    ((DUPLICATE (FASTEN-DOWN-PROPOSITION IMPLIESPROP)))
    (CL:WHEN
     (CL:NOT (CL:EQ DUPLICATE IMPLIESPROP))
     (ASSIGN-TRUTH-VALUE DUPLICATE TRUE)
     (CL:RETURN-FROM FINISH-BUILDING-IMPLIES-PROPOSITION DUPLICATE)))
   (ASSIGN-TRUTH-VALUE IMPLIESPROP TRUE)
   (CL:WHEN
    (CL:EQ (EMPTY? (SATELLITE-PROPOSITIONS FORALLPROP)) 1)
    (SET-DYNAMIC-SLOT-VALUE
     FORALLPROP
     SYM-RULES-SATELLITE-PROPOSITIONS
     (NEW-LIST)
     NULL))
   (INSERT (SATELLITE-PROPOSITIONS FORALLPROP) IMPLIESPROP)
   (SET-DYNAMIC-SLOT-VALUE
    IMPLIESPROP
    SYM-RULES-MASTER-PROPOSITION
    FORALLPROP
    NULL)
   (CL:RETURN-FROM FINISH-BUILDING-IMPLIES-PROPOSITION FORALLPROP))
  :VOID)

;;; (DEFUN (CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION OBJECT) ...)

(CL:DEFUN CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION (FORALLPROP HEADORTAIL VARIABLES DESTRUCTIVE?)
  (CL:LET*
   ((DESCRIPTION (NEW-DESCRIPTION))
    (IOVARIABLES (NEW-VECTOR (LENGTH VARIABLES)))
    (EXISTENTIALVARIABLES NIL))
   (CL:LET*
    ((I NULL)
     (VBL NULL)
     (VECTOR-001 VARIABLES)
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001))
     (ITER-001 0))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       VBL
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETF
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY IOVARIABLES) I)
      (CAST VBL SGT-RULES-PATTERN-VARIABLE))))
   (CL:SETF (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION) IOVARIABLES)
   (CL:LET*
    ((V NULL)
     (VECTOR-002 IOVARIABLES)
     (INDEX-002 0)
     (LENGTH-002 (LENGTH VECTOR-002)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-002 LENGTH-002)
     DO
     (CL:PROGN
      (CL:SETQ
       V
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002)
        SGT-RULES-PATTERN-VARIABLE))
      (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
     (CL:WHEN
      (CL:EQ (MEMBER? VARIABLES V) 0)
      (CL:SETQ EXISTENTIALVARIABLES (CONS V EXISTENTIALVARIABLES)))))
   (CL:COND
    ((CL:EQ HEADORTAIL KWD-RULES-HEAD)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION PROPOSITION DESCRIPTION)
      (CAST
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL PROPOSITION ARGUMENTS FORALLPROP))
        1)
       SGT-RULES-PROPOSITION))
     (CL:WHEN
      (CL:EQ DESTRUCTIVE? 1)
      (CL:SETF
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL PROPOSITION ARGUMENTS FORALLPROP))
        1)
       NULL)))
    ((CL:EQ HEADORTAIL KWD-RULES-TAIL)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION PROPOSITION DESCRIPTION)
      (CAST
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL PROPOSITION ARGUMENTS FORALLPROP))
        0)
       SGT-RULES-PROPOSITION))
     (CL:WHEN
      (CL:EQ DESTRUCTIVE? 1)
      (CL:SETF
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL PROPOSITION ARGUMENTS FORALLPROP))
        0)
       NULL)))
    (CL:T (CL:ERROR "`~A' is not a valid case option" HEADORTAIL)))
   (COMPUTE-INTERNAL-VARIABLES DESCRIPTION)
   (CL:WHEN
    (CL:EQ DESTRUCTIVE? 0)
    (CL:LET*
     ((COPY (COPY-DESCRIPTION DESCRIPTION NULL)))
     (FREE (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION))
     (FREE (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES DESCRIPTION))
     (CL:SETF (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION) NULL)
     (CL:SETF (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES DESCRIPTION) NULL)
     (CL:SETF (CLSYS-SVAL DESCRIPTION PROPOSITION DESCRIPTION) NULL)
     (CL:SETQ DESCRIPTION COPY)))
   (CL:WHEN
    (CL:NOT (CL:EQ EXISTENTIALVARIABLES NIL))
    (CL:LET*
     ((EXISTSPROP (CREATE-PROPOSITION SYM-RULES-EXISTS 1)))
     (CL:SETF (CLSYS-SVAL PROPOSITION KIND EXISTSPROP) KWD-RULES-EXISTS)
     (CL:SETF
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL PROPOSITION ARGUMENTS EXISTSPROP))
       0)
      (CLSYS-SVAL DESCRIPTION PROPOSITION DESCRIPTION))
     (SET-DYNAMIC-SLOT-VALUE
      EXISTSPROP
      SYM-RULES-IO-VARIABLES
      (COPY-CONS-LIST-TO-VARIABLES-VECTOR EXISTENTIALVARIABLES)
      NULL)
     (CL:SETF (CLSYS-SVAL DESCRIPTION PROPOSITION DESCRIPTION) EXISTSPROP)))
   (CL:RETURN-FROM
    CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION
    (FINISH-BUILDING-DESCRIPTION DESCRIPTION TRUE)))
  :VOID)

;;; (DEFUN (DERIVE-ONE-IMPLIES-PROPOSITION PROPOSITION) ...)

(CL:DEFUN DERIVE-ONE-IMPLIES-PROPOSITION (HEADPAIR TAILPAIR FORALLPROP REPLACESFORALL?)
  (CL:LET*
   ((HEAD (CAST (FIRST HEADPAIR) SGT-RULES-DESCRIPTION))
    (HEADARGUMENTS (CAST (SECOND HEADPAIR) SGT-RULES-VECTOR))
    (TAIL (CAST (FIRST TAILPAIR) SGT-RULES-DESCRIPTION))
    (TAILARGUMENTS (CAST (SECOND TAILPAIR) SGT-RULES-VECTOR)))
   (FREE-CONS-LIST HEADPAIR)
   (FREE-CONS-LIST TAILPAIR)
   (CL:LET*
    ((TEST-VALUE-001 FALSE))
    (CL:SETQ TEST-VALUE-001 (DEFINED? HEAD))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:SETQ TEST-VALUE-001 (DEFINED? TAIL))
     (CL:WHEN
      (CL:EQ TEST-VALUE-001 1)
      (CL:IF
       (CL:NOT (CL:= (LENGTH HEADARGUMENTS) (LENGTH TAILARGUMENTS)))
       (CL:SETQ TEST-VALUE-001 TRUE)
       (CL:PROGN
        (CL:LET*
         ((ALWAYS?-001 TRUE))
         (CL:LET*
          ((VT NULL)
           (VH NULL)
           (VECTOR-001 HEADARGUMENTS)
           (INDEX-001 0)
           (LENGTH-001 (LENGTH VECTOR-001))
           (VECTOR-002 TAILARGUMENTS)
           (INDEX-002 0)
           (LENGTH-002 (LENGTH VECTOR-002)))
          (CL:LOOP
           WHILE
           (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:< INDEX-002 LENGTH-002))
           DO
           (CL:PROGN
            (CL:SETQ
             VH
             (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
            (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
           (CL:PROGN
            (CL:SETQ
             VT
             (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
            (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
           (CL:WHEN
            (CL:EQ (EQL? VH VT) 0)
            (CL:SETQ ALWAYS?-001 FALSE)
            (CL:RETURN))))
         (CL:SETQ TEST-VALUE-001 ALWAYS?-001))
        (CL:SETQ
         TEST-VALUE-001
         (CL:IF (CL:EQ TEST-VALUE-001 0) TRUE FALSE))))))
    (CL:WHEN (CL:EQ TEST-VALUE-001 1) (CL:SETQ TAIL NULL)))
   (CL:WHEN
    (CL:EQ HEAD NULL)
    (CL:SETQ
     HEAD
     (CAST
      (CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION
       FORALLPROP
       KWD-RULES-HEAD
       TAILARGUMENTS
       REPLACESFORALL?)
      SGT-RULES-DESCRIPTION)))
   (CL:WHEN
    (CL:EQ TAIL NULL)
    (CL:SETQ
     TAIL
     (CAST
      (CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION
       FORALLPROP
       KWD-RULES-TAIL
       HEADARGUMENTS
       REPLACESFORALL?)
      SGT-RULES-DESCRIPTION)))
   (CL:RETURN-FROM
    DERIVE-ONE-IMPLIES-PROPOSITION
    (FINISH-BUILDING-IMPLIES-PROPOSITION HEAD TAIL FORALLPROP REPLACESFORALL?)))
  :VOID)

;;; (DEFUN (DERIVE-IMPLIES-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN DERIVE-IMPLIES-PROPOSITIONS (FORALLPROP UPDATEMODE)
  (CL:LET*
   ((ANTECEDENTPROP
     (CAST
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL PROPOSITION ARGUMENTS FORALLPROP))
       0)
      SGT-RULES-PROPOSITION))
    (CONSEQUENTPROP
     (CAST
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL PROPOSITION ARGUMENTS FORALLPROP))
       1)
      SGT-RULES-PROPOSITION))
    (HEADS NULL)
    (TAILS NULL)
    (EQUIVALENTHEAD? FALSE)
    (EQUIVALENTTAIL? FALSE)
    (RESULT FORALLPROP))
   (CL:MULTIPLE-VALUE-SETQ
    (HEADS EQUIVALENTHEAD?)
    (FIND-RULE-HEADS
     CONSEQUENTPROP
     (DYNAMIC-SLOT-VALUE FORALLPROP SYM-RULES-IO-VARIABLES NULL)))
   (CL:MULTIPLE-VALUE-SETQ
    (TAILS EQUIVALENTTAIL?)
    (FIND-RULE-TAILS
     ANTECEDENTPROP
     (DYNAMIC-SLOT-VALUE FORALLPROP SYM-RULES-IO-VARIABLES NULL)))
   (CL:COND
    ((CL:EQ EQUIVALENTHEAD? 1)
     (CL:SETQ
      RESULT
      (DERIVE-ONE-IMPLIES-PROPOSITION
       (FIRST HEADS)
       (CL:IF (CL:EQ EQUIVALENTTAIL? 1) (FIRST TAILS) NIL)
       FORALLPROP
       TRUE)))
    ((CL:EQ EQUIVALENTTAIL? 1)
     (CL:SETQ
      RESULT
      (DERIVE-ONE-IMPLIES-PROPOSITION NIL (FIRST TAILS) FORALLPROP TRUE)))
    ((CL:EQ UPDATEMODE KWD-RULES-ASSERT-TRUE)
     (CL:LET*
      ((H NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST HEADS)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ H (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-RULES-CONS))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (DERIVE-ONE-IMPLIES-PROPOSITION H NIL FORALLPROP FALSE)))
     (CL:LET*
      ((T NULL) (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST TAILS)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-002 NIL))
       DO
       (CL:PROGN
        (CL:SETQ T (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-RULES-CONS))
        (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
       (DERIVE-ONE-IMPLIES-PROPOSITION NIL T FORALLPROP FALSE)))))
   (CL:WHEN
    (CL:AND
     (CL:EQ RESULT FORALLPROP)
     (CL:EQ EQUIVALENTHEAD? 0)
     (CL:EQ EQUIVALENTTAIL? 0)
     (CL:< (LENGTH (SATELLITE-PROPOSITIONS FORALLPROP)) 2)
     (CL:EQ UPDATEMODE KWD-RULES-ASSERT-TRUE)
     (CL:EQ (DESCRIPTION-MODE?) 0))
    (CL:WARN
     "PowerLoom can't index the rule:~%   `~A'~%   because neither its head nor its tail matches a primitive relation."
     FORALLPROP))
   (CL:WHEN
    (CL:NOT (CL:EQ RESULT FORALLPROP))
    (DESTROY-PROPOSITION FORALLPROP))
   (CL:RETURN-FROM DERIVE-IMPLIES-PROPOSITIONS RESULT))
  :VOID)

;;; (DEFUN (GET-RULES (LIST OF PROPOSITION)) ...)

(CL:DEFUN GET-RULES (SLOT)
  (CL:WHEN (CL:EQ SLOT NULL) (CL:RETURN-FROM GET-RULES NIL-LIST))
  (CL:LET*
   ((DESCRIPTION (DYNAMIC-SLOT-VALUE SLOT SYM-RULES-DESCRIPTION NULL))
    (RULES (LIST)))
   (CL:WHEN
    (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:LET*
     ((P NULL)
      (ITER-001
       (CLSYS-SVAL
        LIST
        THE-CONS-LIST
        (CLSYS-SVAL DESCRIPTION DEPENDENT-PROPOSITIONS DESCRIPTION))))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ
        P
        (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-RULES-PROPOSITION))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:WHEN
       (CL:EQ (CLSYS-SVAL PROPOSITION KIND P) KWD-RULES-IMPLIES)
       (PUSH RULES P))))
    (CL:SETQ
     DESCRIPTION
     (DYNAMIC-SLOT-VALUE DESCRIPTION SYM-RULES-COMPLEMENT-DESCRIPTION NULL))
    (CL:WHEN
     (CL:NOT (CL:EQ DESCRIPTION NULL))
     (CL:LET*
      ((P NULL)
       (ITER-002
        (CLSYS-SVAL
         LIST
         THE-CONS-LIST
         (CLSYS-SVAL DESCRIPTION DEPENDENT-PROPOSITIONS DESCRIPTION))))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-002 NIL))
       DO
       (CL:PROGN
        (CL:SETQ
         P
         (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-RULES-PROPOSITION))
        (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
       (CL:WHEN
        (CL:EQ (CLSYS-SVAL PROPOSITION KIND P) KWD-RULES-IMPLIES)
        (PUSH RULES P))))))
   (CL:RETURN-FROM GET-RULES RULES))
  :VOID)

;;; (DEFUN (DROP-RULES (LIST OF PROPOSITION)) ...)

(CL:DEFUN DROP-RULES (SLOT)
  (CL:LET*
   ((RULES (GET-RULES SLOT)))
   (CL:LET*
    ((R NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST RULES)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       R
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-RULES-PROPOSITION))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (DESTROY-PROPOSITION R)))
   (CL:RETURN-FROM DROP-RULES RULES))
  :VOID)

;;; (DEFUN PRINT-RULES ...)

(CL:DEFUN PRINT-RULES (SLOTNAME)
  (CL:LET*
   ((SLOT (GET-OBJECT SLOTNAME SGT-RULES-SLOT)))
   (CL:WHEN
    (CL:OR (CL:EQ SLOT NULL) (CL:EQ (ISA? SLOT SGT-RULES-SLOT) 0))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "Can't find a slot named " %%STREAM)
     (CL:WRITE-STRING SLOTNAME %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CL:RETURN-FROM PRINT-RULES))
   (CL:LET*
    ((RULE NULL)
     (ITER-001
      (CLSYS-SVAL LIST THE-CONS-LIST (GET-RULES (CAST SLOT SGT-RULES-SLOT)))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       RULE
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-RULES-PROPOSITION))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (PRINT-OBJECT
      RULE
      (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)))))
  :VOID)

;;; (DEFUN (DEFINE-RULE PROPOSITION) ...)

(CL:DEFUN DEFINE-RULE (NAME RULETREE)
  (CL:LET*
   ((SURROGATE (INTERN-SURROGATE NAME))
    (OLDRULE (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE))
    (NEWRULE NULL))
   (CL:SETQ NEWRULE (UPDATE-PROPOSITION RULETREE KWD-RULES-ASSERT-TRUE))
   (CL:WHEN
    (CL:OR
     (CL:EQ NEWRULE NULL)
     (CL:EQ (ISA? NEWRULE SGT-RULES-PROPOSITION) 0))
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING "Error in logical expression." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING
       "   Oops, bug in defrule prevents rule definition.  Please
        notify your PowerLoom dealer."
       %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING
       "   Error occured while parsing the proposition: "
       %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING "   " %%STREAM)
      (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (SIGNAL *THE-PROPOSITION-ERROR*)))
   (CL:WHEN
    (CL:NOT (CL:EQ OLDRULE NULL))
    (CL:LET*
     ((OLDRULE-001 OLDRULE))
     (CL:COND
      ((CL:EQ (TAXONOMY-ISA? OLDRULE SGT-RULES-PROPOSITION) 1)
       (CL:LET*
        ((OLDRULE NULL))
        (CL:SETQ OLDRULE OLDRULE-001)
        (CL:WHEN (CL:EQ OLDRULE NEWRULE) (CL:RETURN-FROM DEFINE-RULE OLDRULE))
        (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE) NULL)
        (SET-DYNAMIC-SLOT-VALUE
         OLDRULE
         SYM-RULES-SURROGATE-VALUE-INVERSE
         NULL
         NULL)
        (DESTROY-PROPOSITION OLDRULE)))
      (CL:T
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING "Error in logical expression." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING "   Can't define a rule named " %%STREAM)
         (CL:WRITE-STRING NAME %%STREAM)
         (CL:WRITE-STRING " because another object of type" %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING "   " %%STREAM)
         (PRINT-OBJECT (PRIMARY-TYPE OLDRULE) %%STREAM)
         (CL:WRITE-STRING " already has that name." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING
          "   Error occured while parsing the proposition: "
          %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING "   " %%STREAM)
         (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))
        (SIGNAL *THE-PROPOSITION-ERROR*))
       (DESTROY-PROPOSITION NEWRULE)))))
   (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE) NEWRULE)
   (SET-DYNAMIC-SLOT-VALUE
    NEWRULE
    SYM-RULES-SURROGATE-VALUE-INVERSE
    SURROGATE
    NULL)
   (CL:RETURN-FROM DEFINE-RULE NEWRULE))
  :VOID)

;;; (DEFUN (DEFRULE PROPOSITION) ...)

(CL:DEFUN %%DEFRULE (RULENAME RULE)
  "Define (or redefine) a rule (any axiom) named `ruleName'.
If an axiom with that name already exists, replace it with the new
axiom `rule'."
  (CL:PROGN
   (CL:LET*
    ((*PENDINGEXCEPTIONHANDLER?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PENDINGEXCEPTIONHANDLER?*))
    (CL:CATCH
     *EXCEPTIONHANDLERADDRESS*
     (CL:PROGN
      (CL:RETURN-FROM
       %%DEFRULE
       (DEFINE-RULE (COERCE-TO-STRING RULENAME) (COERCE-TO-TREE RULE)))
      (CL:SETQ *EXCEPTION* NULL))))
   (CL:WHEN
    (CL:NOT (CL:EQ *EXCEPTION* NULL))
    (CL:COND
     ((CL:EQ TRUE 1)
      (CL:LET* ((E *EXCEPTION*)) (HANDLE-QUERY-EXCEPTION E "defrule"))))))
  :VOID)

(CL:DEFMACRO DEFRULE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define (or redefine) a rule (any axiom) named `ruleName'.
If an axiom with that name already exists, replace it with the new
axiom `rule'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/DEFRULE)) (CL:MACRO-FUNCTION (CL:QUOTE DEFRULE)))

;;; (DEFUN DELETE-RULE-CACHES-ON-SLOT ...)

(CL:DEFUN DELETE-RULE-CACHES-ON-SLOT (SLOT)
  (CL:LET*
   ((RULE NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST (GET-RULES SLOT))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      RULE
      (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-RULES-PROPOSITION))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:LET*
     ((ARG NULL)
      (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS RULE))
      (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:LOOP
      WHILE
      (CL:< INDEX-001 LENGTH-001)
      DO
      (CL:PROGN
       (CL:SETQ
        ARG
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (CLSYS-SVAL
          DESCRIPTION
          QUERY-PATTERNS
          (CAST ARG SGT-RULES-DESCRIPTION))
         NULL))
       (CL:LET*
        ((IT
          (ALLOCATE-ITERATOR
           (CLSYS-SVAL
            DESCRIPTION
            QUERY-PATTERNS
            (CAST ARG SGT-RULES-DESCRIPTION)))))
        (CL:LOOP WHILE (CL:EQ (NEXT? IT) 1) DO (VALUE-SETTER IT NULL))))))))
  :VOID)

;;; (DEFUN RESET-QUERY-CACHES ...)

(CL:DEFUN RESET-QUERY-CACHES ()
  "Zero out all caches managed by the query optimizer,
so that it will reoptimize subgoal queries upon next invocation."
  (CL:LET*
   ((SLOT NULL) (ITER-001 (ALL-SLOTS NULL TRUE)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITER-001) 1)
    DO
    (CL:PROGN
     (CL:SETQ
      SLOT
      (CAST (CLSYS-SVAL ITERATOR VALUE ITER-001) SGT-RULES-SLOT)))
    (CL:WHEN
     (CL:NOT
      (CL:EQ (DYNAMIC-SLOT-VALUE SLOT SYM-RULES-DESCRIPTION NULL) NULL))
     (DELETE-RULE-CACHES-ON-SLOT SLOT))))
  (CL:LET*
   ((CLASS NULL) (ITER-002 (ALL-CLASSES NULL TRUE)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITER-002) 1)
    DO
    (CL:PROGN
     (CL:SETQ
      CLASS
      (CAST (CLSYS-SVAL ITERATOR VALUE ITER-002) SGT-RULES-CLASS)))
    (CL:WHEN
     (CL:NOT
      (CL:EQ (DYNAMIC-SLOT-VALUE CLASS SYM-RULES-DESCRIPTION NULL) NULL))
     (CL:LET*
      ((DESCRIPTION (DYNAMIC-SLOT-VALUE CLASS SYM-RULES-DESCRIPTION NULL)))
      (CL:WHEN
       (CL:EQ
        (DEFINED?
         (CLSYS-SVAL
          INTEGER-WRAPPER
          WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE
           DESCRIPTION
           SYM-RULES-ESTIMATED-CARDINALITY
           NULL-INTEGER-WRAPPER)))
        1)
       (SET-DYNAMIC-SLOT-VALUE
        DESCRIPTION
        SYM-RULES-ESTIMATED-CARDINALITY
        (WRAP-INTEGER NULL-INTEGER)
        NULL-INTEGER-WRAPPER))
      (CL:WHEN
       (CL:NOT
        (CL:EQ (CLSYS-SVAL DESCRIPTION QUERY-PATTERNS DESCRIPTION) NULL))
       (CL:LET*
        ((IT
          (ALLOCATE-ITERATOR
           (CLSYS-SVAL DESCRIPTION QUERY-PATTERNS DESCRIPTION))))
        (CL:LOOP WHILE (CL:EQ (NEXT? IT) 1) DO (VALUE-SETTER IT NULL))))))))
  :VOID)

(CL:DEFUN STARTUP-RULES ()
  (CL:LET*
   ((*MODULE* (GET-MODULE "/LOGIC" TRUE)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ KWD-RULES-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
    (CL:SETQ
     SGT-RULES-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
    (CL:SETQ KWD-RULES-AND (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
    (CL:SETQ
     KWD-RULES-EXISTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
    (CL:SETQ KWD-RULES-IN (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 2))
    (CL:SETQ
     SGT-RULES-SURROGATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "SURROGATE"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-RULES-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-RULES-SKOLEM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
    (CL:SETQ
     KWD-RULES-PREDICATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
    (CL:SETQ
     KWD-RULES-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     SGT-RULES-SLOTREF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTREF" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ KWD-RULES-NOT (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
    (CL:SETQ
     SGT-RULES-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-RULES-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
    (CL:SETQ
     SYM-RULES-IMPLIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 0))
    (CL:SETQ
     SYM-RULES-SATELLITE-PROPOSITIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SATELLITE-PROPOSITIONS" NULL 0))
    (CL:SETQ
     SYM-RULES-MASTER-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
    (CL:SETQ
     SGT-RULES-PATTERN-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
    (CL:SETQ KWD-RULES-HEAD (INTERN-RIGID-SYMBOL-WRT-MODULE "HEAD" NULL 2))
    (CL:SETQ KWD-RULES-TAIL (INTERN-RIGID-SYMBOL-WRT-MODULE "TAIL" NULL 2))
    (CL:SETQ
     SYM-RULES-EXISTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-RULES-IO-VARIABLES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
    (CL:SETQ
     SGT-RULES-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     KWD-RULES-ASSERT-TRUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
    (CL:SETQ
     SYM-RULES-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
    (CL:SETQ
     KWD-RULES-IMPLIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
    (CL:SETQ
     SYM-RULES-COMPLEMENT-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT-DESCRIPTION" NULL 0))
    (CL:SETQ
     SGT-RULES-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-RULES-SURROGATE-VALUE-INVERSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE-INVERSE" NULL 0))
    (CL:SETQ
     SYM-RULES-DEFRULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFRULE" NULL 0))
    (CL:SETQ
     KWD-RULES-COMMON-LISP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
    (CL:SETQ
     SGT-RULES-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-RULES-ESTIMATED-CARDINALITY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ESTIMATED-CARDINALITY" NULL 0)))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-RULE-TAILS"
        "PROPOSITION"
        "(DEFUN (FIND-RULE-TAILS (LIST OF CONS) BOOLEAN) ((PROPOSITION PROPOSITION) (VARIABLES VARIABLES-VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-RULE-TAILS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-RULE-HEADS"
        "PROPOSITION"
        "(DEFUN (FIND-RULE-HEADS LIST BOOLEAN) ((PROPOSITION PROPOSITION) (VARIABLES VARIABLES-VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-RULE-HEADS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECT-MATCHING-RULE-GOAL"
        "PROPOSITION"
        "(DEFUN COLLECT-MATCHING-RULE-GOAL ((GOAL PROPOSITION) (VARIABLES VARIABLES-VECTOR) (COLLECTION (LIST OF CONS))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECT-MATCHING-RULE-GOAL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT"
        "OBJECT"
        "(DEFUN (MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT OBJECT) ((ARG1 OBJECT) (ARG2 OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MAYBE-SUBSTITUTE-SURROGATE-ARGUMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINISH-BUILDING-IMPLIES-PROPOSITION"
        "OBJECT"
        "(DEFUN (FINISH-BUILDING-IMPLIES-PROPOSITION PROPOSITION) ((HEAD OBJECT) (TAIL OBJECT) (FORALLPROP PROPOSITION) (REPLACESFORALL? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINISH-BUILDING-IMPLIES-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION"
        "PROPOSITION"
        "(DEFUN (CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION OBJECT) ((FORALLPROP PROPOSITION) (HEADORTAIL KEYWORD) (VARIABLES VECTOR) (DESTRUCTIVE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONSTRUCT-DESCRIPTION-FROM-FORALL-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DERIVE-ONE-IMPLIES-PROPOSITION"
        "CONS"
        "(DEFUN (DERIVE-ONE-IMPLIES-PROPOSITION PROPOSITION) ((HEADPAIR CONS) (TAILPAIR CONS) (FORALLPROP PROPOSITION) (REPLACESFORALL? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DERIVE-ONE-IMPLIES-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DERIVE-IMPLIES-PROPOSITIONS"
        "PROPOSITION"
        "(DEFUN (DERIVE-IMPLIES-PROPOSITIONS PROPOSITION) ((FORALLPROP PROPOSITION) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DERIVE-IMPLIES-PROPOSITIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-RULES"
        "SLOT"
        "(DEFUN (GET-RULES (LIST OF PROPOSITION)) ((SLOT SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-RULES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DROP-RULES"
        "SLOT"
        "(DEFUN (DROP-RULES (LIST OF PROPOSITION)) ((SLOT SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DROP-RULES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-RULES"
        "STRING"
        "(DEFUN PRINT-RULES ((SLOTNAME STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-RULES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFINE-RULE"
        "STRING"
        "(DEFUN (DEFINE-RULE PROPOSITION) ((NAME STRING) (RULETREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEFINE-RULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEFRULE"
        "OBJECT"
        "(DEFUN (DEFRULE PROPOSITION) ((RULENAME NAME) (RULE PARSE-TREE)) :DOCUMENTATION \"Define (or redefine) a rule (any axiom) named `ruleName'.
If an axiom with that name already exists, replace it with the new
axiom `rule'.\" :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%DEFRULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DELETE-RULE-CACHES-ON-SLOT"
        "SLOT"
        "(DEFUN DELETE-RULE-CACHES-ON-SLOT ((SLOT SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DELETE-RULE-CACHES-ON-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RESET-QUERY-CACHES"
        NULL
        "(DEFUN RESET-QUERY-CACHES () :DOCUMENTATION \"Zero out all caches managed by the query optimizer,
so that it will reoptimize subgoal queries upon next invocation.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RESET-QUERY-CACHES)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-RULES"
     NULL
     "(DEFUN STARTUP-RULES ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (REGISTER-NATIVE-NAME
     SYM-RULES-DEFRULE
     KWD-RULES-COMMON-LISP
     KWD-RULES-FUNCTION)))
  :VOID)
