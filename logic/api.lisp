;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997                   | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-API-RELATION NULL)
(CL:DEFVAR SYM-API-DEFINITION-STRING NULL)
(CL:DEFVAR SGT-API-SLOT NULL)
(CL:DEFVAR SGT-API-LOGIC-OBJECT NULL)
(CL:DEFVAR SYM-API-SURROGATE-VALUE-INVERSE NULL)
(CL:DEFVAR SGT-API-MODULE NULL)
(CL:DEFVAR SGT-API-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SGT-API-CLASS NULL)
(CL:DEFVAR SGT-API-CONTEXT NULL)
(CL:DEFVAR SGT-API-TYPE NULL)
(CL:DEFVAR SYM-API-DESCRIPTION NULL)
(CL:DEFVAR SGT-API-CONS NULL)
(CL:DEFVAR SGT-API-LITERAL-WRAPPER NULL)
(CL:DEFVAR SGT-API-SYMBOL NULL)
(CL:DEFVAR KWD-API-IN NULL)
(CL:DEFVAR KWD-API-FUNCTION NULL)
(CL:DEFVAR SYM-API-*SELECTED-MODULES* NULL)
(CL:DEFVAR SGT-API-BOOLEAN NULL)
(CL:DEFVAR SGT-API-METHOD-SLOT NULL)
(CL:DEFVAR SGT-API-TABLE NULL)
(CL:DEFVAR SGT-API-TYPE-SPEC NULL)

;;; Forward declarations:

(CL:DECLAIM (CL:SPECIAL *MODULE* *SELECTED-MODULES* NULL-STRING-WRAPPER))

;;; (DEFUN (LOGIC-DEFINITION STRING) ...)

(CL:DEFUN LOGIC-DEFINITION (OBJECT)
  "Return the logic definition of `object'."
  (CL:LET*
   ((OBJECT-001 OBJECT))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? OBJECT SGT-API-RELATION) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:RETURN-FROM
       LOGIC-DEFINITION
       (CLSYS-SVAL
        STRING-WRAPPER
        WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         OBJECT
         SYM-API-DEFINITION-STRING
         NULL-STRING-WRAPPER)))))
    (CL:T (CL:RETURN-FROM LOGIC-DEFINITION NULL))))
  :VOID)

;;; (DEFUN (SOURCE-DEFINITION STRING) ...)

(CL:DEFUN SOURCE-DEFINITION (OBJECT)
  "Return the source definition of `object'."
  (CL:LET*
   ((OBJECT-001 OBJECT))
   (CL:COND
    ((CL:EQ (CLASS? OBJECT) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:RETURN-FROM
       SOURCE-DEFINITION
       (CLSYS-SVAL CLASS CLASS-STRINGIFIED-SOURCE OBJECT))))
    ((CL:EQ (METHOD-SLOT? OBJECT) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:RETURN-FROM
       SOURCE-DEFINITION
       (CLSYS-SVAL METHOD-SLOT METHOD-STRINGIFIED-SOURCE OBJECT))))
    (CL:T (CL:RETURN-FROM SOURCE-DEFINITION NULL))))
  :VOID)

;;; (DEFUN (OBJECT-NAME STRING) ...)

(CL:DEFUN OBJECT-NAME (OBJECT)
  "Return the name of a stella object"
  (CL:LET*
   ((OBJECT-001 OBJECT))
   (CL:COND
    ((CL:EQ (CLASS? OBJECT) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:RETURN-FROM
       OBJECT-NAME
       (CLSYS-SVAL
        SURROGATE
        SYMBOL-NAME
        (CLSYS-SVAL CLASS CLASS-TYPE OBJECT)))))
    ((CL:EQ (TAXONOMY-ISA? OBJECT SGT-API-SLOT) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:RETURN-FROM
       OBJECT-NAME
       (CLSYS-SVAL SYMBOL SYMBOL-NAME (CLSYS-SVAL SLOT SLOT-NAME OBJECT)))))
    ((CL:EQ (TAXONOMY-ISA? OBJECT SGT-API-LOGIC-OBJECT) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:RETURN-FROM
       OBJECT-NAME
       (CLSYS-SVAL
        SURROGATE
        SYMBOL-NAME
        (DYNAMIC-SLOT-VALUE OBJECT SYM-API-SURROGATE-VALUE-INVERSE NULL)))))
    ((CL:EQ (TAXONOMY-ISA? OBJECT SGT-API-MODULE) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:RETURN-FROM OBJECT-NAME (CLSYS-SVAL MODULE MODULE-NAME OBJECT))))
    ((CL:EQ (TAXONOMY-ISA? OBJECT SGT-API-GENERALIZED-SYMBOL) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:RETURN-FROM
       OBJECT-NAME
       (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-NAME OBJECT))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" OBJECT))))
  :VOID)

;;; (DEFUN (FIND-CLASS CLASS) ...)

(CL:DEFUN FIND-CLASS (NAME)
  "Retrieve the class with name `name'"
  (CL:RETURN-FROM
   FIND-CLASS
   (CAST (SEARCH-FOR-OBJECT (WRAP-LITERAL NAME) SGT-API-CLASS) SGT-API-CLASS))
  :VOID)

;;; (DEFUN (FIND-CONTEXT CONTEXT) ...)

(CL:DEFUN FIND-CONTEXT (NAME)
  "Retrieve the context with name `name'"
  (CL:RETURN-FROM
   FIND-CONTEXT
   (CAST
    (SEARCH-FOR-OBJECT (WRAP-LITERAL NAME) SGT-API-CONTEXT)
    SGT-API-CONTEXT))
  :VOID)

;;; (DEFUN (FIND-INSTANCE LOGIC-OBJECT) ...)

(CL:DEFUN FIND-INSTANCE (NAME)
  "Find the instance with name `name'"
  (CL:LET*
   ((SURROGATE (LOOKUP-SURROGATE NAME)))
   (CL:WHEN
    (CL:NOT (CL:EQ SURROGATE NULL))
    (CL:RETURN-FROM
     FIND-INSTANCE
     (CAST
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE)
      SGT-API-LOGIC-OBJECT)))
   (CL:RETURN-FROM FIND-INSTANCE NULL))
  :VOID)

;;; (DEFUN (GET-INSTANCE LOGIC-OBJECT) ...)

(CL:DEFUN GET-INSTANCE (NAME ERROR?)
  "Find the instance with name `name'"
  (CL:LET*
   ((SURROGATE (LOOKUP-SURROGATE NAME)))
   (CL:WHEN
    (CL:NOT (CL:EQ SURROGATE NULL))
    (CL:RETURN-FROM
     GET-INSTANCE
     (CAST
      (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE)
      SGT-API-LOGIC-OBJECT)))
   (CL:IF
    (CL:EQ ERROR? 1)
    (CL:CERROR "Continue anyway? " "Instance `~A' does not exist." NAME)
    (CL:RETURN-FROM GET-INSTANCE NULL)))
  :VOID)

;;; (DEFUN (ALL-SUPERCLASSES (ITERATOR OF CLASS)) ...)

(CL:DEFUN ALL-SUPERCLASSES (CLASS)
  "Get all superclasses (excluding `class') of `class'."
  (CL:LET*
   ((SUPERTYPES (NEW-LIST)))
   (CL:LET*
    ((SUPER NULL)
     (ITER-001 (CLSYS-SVAL CLASS CLASS-ALL-SUPER-CLASSES CLASS))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUPER (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-API-CLASS))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ
        COLLECT-001
        (PERMANENT-CONS (CLSYS-SVAL CLASS CLASS-TYPE SUPER) NIL))
       (CL:IF
        (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST SUPERTYPES) NIL)
        (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST SUPERTYPES) COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST
         (CLSYS-SVAL LIST THE-CONS-LIST SUPERTYPES)
         COLLECT-001)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-001)
        (PERMANENT-CONS (CLSYS-SVAL CLASS CLASS-TYPE SUPER) NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:LET*
    ((SELF-002 (NEW-ALL-PURPOSE-ITERATOR)))
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF-002)
     (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR SUPERTYPES))
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF-002)
     *SELECTED-MODULES*)
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE SELF-002)
     (CL:FUNCTION FILTERED-TYPES-TO-CLASSES-NEXT?))
    (CL:LET*
     ((VALUE-001 SELF-002))
     (CL:RETURN-FROM ALL-SUPERCLASSES VALUE-001))))
  :VOID)

;;; (DEFUN (SUBCLASS? BOOLEAN) ...)

(CL:DEFUN SUBCLASS? (CLASS1 CLASS2)
  (CL:RETURN-FROM SUBCLASS? (SUBCLASS-OF? CLASS1 CLASS2))
  :VOID)

;;; (DEFUN (DIRECT-SUPERCLASSES (ITERATOR OF CLASS)) ...)

(CL:DEFUN DIRECT-SUPERCLASSES (CLASS)
  "Get direct superclasses of `class'."
  (CL:LET*
   ((SELF-001 (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF-001)
    (CLSYS-SVAL
     LIST
     THE-CONS-LIST
     (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF-001)
    *SELECTED-MODULES*)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE SELF-001)
    (CL:FUNCTION FILTERED-TYPES-TO-CLASSES-NEXT?))
   (CL:LET*
    ((VALUE-001 SELF-001))
    (CL:RETURN-FROM DIRECT-SUPERCLASSES VALUE-001)))
  :VOID)

;;; (DEFMETHOD (DIRECT-SUPERRELATIONS (ITERATOR OF RELATION)) ...)

(CL:DEFMETHOD DIRECT-SUPERRELATIONS ((SELF RELATION))
  "Return direct super classes/slots/tables of 'self'."
  (CL:RETURN-FROM DIRECT-SUPERRELATIONS NULL)
  :VOID)

;;; (DEFMETHOD (DIRECT-SUPERRELATIONS (ITERATOR OF SLOT)) ...)

(CL:DEFMETHOD DIRECT-SUPERRELATIONS ((SELF SLOT))
  (CL:RETURN-FROM
   DIRECT-SUPERRELATIONS
   (ALLOCATE-ITERATOR (SLOT-DIRECT-SUPERS SELF)))
  :VOID)

;;; (DEFMETHOD (DIRECT-SUPERRELATIONS (ITERATOR OF CLASS)) ...)

(CL:DEFMETHOD DIRECT-SUPERRELATIONS ((SELF CLASS))
  (CL:RETURN-FROM DIRECT-SUPERRELATIONS (DIRECT-SUPER-CLASSES SELF))
  :VOID)

;;; (DEFUN (TEST1 CONS) ...)

(CL:DEFUN TEST1 (PARENTS)
  (CL:LET* ((MOSTSPECIFICSUPERS NIL)) (CL:RETURN-FROM TEST1 MOSTSPECIFICSUPERS))
  :VOID)

;;; (DEFUN (DIRECT-SUPERTYPES (ITERATOR OF CLASS)) ...)

(CL:DEFUN DIRECT-SUPERTYPES (CLASS)
  "Get direct supertypes of `class'."
  (CL:LET*
   ((PARENTS
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS)))
    (MOSTSPECIFICSUPERS NIL))
   (CL:LET*
    ((SUPERTYPE NULL) (ITER-001 PARENTS))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ SUPERTYPE (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-API-TYPE))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:LET*
      ((TEST-VALUE-001 FALSE))
      (CL:IF
       (CL:EQ
        (CAST (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPERTYPE) SGT-API-CLASS)
        NULL)
       (CL:SETQ TEST-VALUE-001 TRUE)
       (CL:PROGN
        (CL:LET*
         ((FOUND?-001 FALSE))
         (CL:LET*
          ((OTHERSUPERTYPE NULL) (ITER-002 PARENTS))
          (CL:LOOP
           WHILE
           (CL:NOT (CL:EQ ITER-002 NIL))
           DO
           (CL:PROGN
            (CL:SETQ
             OTHERSUPERTYPE
             (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-API-TYPE))
            (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
           (CL:WHEN
            (CL:AND
             (CL:NOT (CL:EQ SUPERTYPE OTHERSUPERTYPE))
             (CL:NOT
              (CL:EQ
               (CAST
                (CLSYS-SVAL SURROGATE SURROGATE-VALUE OTHERSUPERTYPE)
                SGT-API-CLASS)
               NULL))
             (CL:EQ (SUBTYPE-OF? OTHERSUPERTYPE SUPERTYPE) 1))
            (CL:SETQ FOUND?-001 TRUE)
            (CL:RETURN))))
         (CL:SETQ TEST-VALUE-001 FOUND?-001))
        (CL:SETQ TEST-VALUE-001 (CL:IF (CL:EQ TEST-VALUE-001 0) TRUE FALSE))))
      (CL:WHEN
       (CL:EQ TEST-VALUE-001 1)
       (CL:SETQ MOSTSPECIFICSUPERS (CONS SUPERTYPE MOSTSPECIFICSUPERS))))))
   (CL:LET*
    ((SELF-001 (NEW-ALL-PURPOSE-ITERATOR)))
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF-001)
     MOSTSPECIFICSUPERS)
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF-001)
     *SELECTED-MODULES*)
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE SELF-001)
     (CL:FUNCTION FILTERED-TYPES-NEXT?))
    (CL:LET*
     ((VALUE-001 SELF-001))
     (CL:RETURN-FROM DIRECT-SUPERTYPES VALUE-001))))
  :VOID)

;;; (DEFUN (DIRECT-SUBCLASSES (ITERATOR OF CLASS)) ...)

(CL:DEFUN DIRECT-SUBCLASSES (CLASS)
  "Get direct subclasses of `class'."
  (CL:LET*
   ((SELF-001 (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF-001)
    (CLSYS-SVAL
     LIST
     THE-CONS-LIST
     (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS CLASS)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF-001)
    *SELECTED-MODULES*)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE SELF-001)
    (CL:FUNCTION FILTERED-TYPES-TO-CLASSES-NEXT?))
   (CL:LET*
    ((VALUE-001 SELF-001))
    (CL:RETURN-FROM DIRECT-SUBCLASSES VALUE-001)))
  :VOID)

;;; (DEFUN (CLASS-NAMES (ALL-PURPOSE-ITERATOR OF SURROGATE)) ...)

(CL:DEFUN CLASS-NAMES (CLASS)
  "Get all names (including synonyms) of `class'"
  (CL:LET*
   ((SYNONYMSITER (ALLOCATE-ITERATOR (CLASS-SYNONYMS CLASS)))
    (RESULTITER (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR RESULTITER)
    SYNONYMSITER)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT RESULTITER)
    CLASS)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE RESULTITER)
    (CL:FUNCTION CLASS-NAMES-NEXT?))
   (CL:RETURN-FROM CLASS-NAMES RESULTITER))
  :VOID)

;;; (DEFUN (GET-INSTANCES CONS-ITERATOR) ...)

(CL:DEFUN GET-INSTANCES (CLASS)
  "Return all instances asserted to be of type `class'"
  (CL:LET*
   ((INSTANCES NIL))
   (CL:LET*
    ((ALWAYS?-001 TRUE))
    (CL:LET*
     ((SUPER NULL)
      (ITER-001
       (CLSYS-SVAL
        LIST
        THE-CONS-LIST
        (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS CLASS))))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ SUPER (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-API-TYPE))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:WHEN
       (CL:EQ
        (CAST (CLSYS-SVAL SURROGATE SURROGATE-VALUE SUPER) SGT-API-CLASS)
        NULL)
       (CL:SETQ ALWAYS?-001 FALSE)
       (CL:RETURN))))
    (CL:WHEN
     (CL:EQ ALWAYS?-001 0)
     (CL:WARN
      "Get-instances: `~A' isn't finalized, returning empty list."
      CLASS)
     (CL:RETURN-FROM GET-INSTANCES (ALLOCATE-ITERATOR NIL))))
   (CL:LET*
    ((ROOTCLASS NULL) (ITER-002 (ALL-ROOT-CLASSES CLASS)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-002) 1)
     DO
     (CL:PROGN
      (CL:SETQ
       ROOTCLASS
       (CAST (CLSYS-SVAL ITERATOR VALUE ITER-002) SGT-API-CLASS)))
     (CL:WHEN
      (CL:NOT
       (CL:EQ (DYNAMIC-SLOT-VALUE ROOTCLASS SYM-API-DESCRIPTION NULL) NULL))
      (CL:LET*
       ((INSTANCE NULL)
        (ITER-003
         (CLSYS-SVAL
          LIST
          THE-CONS-LIST
          (EXTENSION
           (DYNAMIC-SLOT-VALUE ROOTCLASS SYM-API-DESCRIPTION NULL)))))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-003 NIL))
        DO
        (CL:PROGN
         (CL:SETQ INSTANCE (CLSYS-SVAL CONS VALUE ITER-003))
         (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
        (CL:SETQ INSTANCES (CONS INSTANCE INSTANCES)))))))
   (CL:RETURN-FROM GET-INSTANCES (ALLOCATE-ITERATOR INSTANCES)))
  :VOID)

;;; (DEFUN (GET-SUBCLASSES (ITERATOR OF CLASS)) ...)

(CL:DEFUN GET-SUBCLASSES (CLASS)
  "Get all subclasses of `class', including self."
  (CL:LET*
   ((SUBTYPES (NEW-LIST)))
   (COLLECT-SUBTYPES (CLSYS-SVAL CLASS CLASS-TYPE CLASS) SUBTYPES)
   (CL:LET*
    ((SELF-002 (NEW-ALL-PURPOSE-ITERATOR)))
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF-002)
     (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR SUBTYPES))
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF-002)
     *SELECTED-MODULES*)
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE SELF-002)
     (CL:FUNCTION FILTERED-TYPES-TO-CLASSES-NEXT?))
    (CL:LET* ((VALUE-001 SELF-002)) (CL:RETURN-FROM GET-SUBCLASSES VALUE-001))))
  :VOID)

;;; (DEFUN ADD-SUPERCLASS ...)

(CL:DEFUN ADD-SUPERCLASS (SUPER CLASS)
  "Add the class named 'super' to the list of
superclasses of 'class'."
  (CL:LET*
   ((*MODULE*
     (CAST
      (CLSYS-SVAL SURROGATE HOME-CONTEXT (CLSYS-SVAL CLASS CLASS-TYPE CLASS))
      SGT-API-MODULE)))
   (CL:DECLARE (CL:SPECIAL *MODULE*))
   (CL:SETQ
    SUPER
    (INTERN-DERIVED-SYMBOL
     SUPER
     (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-NAME SUPER)))
   (CL:LET*
    ((SOURCETREE
      (CAST
       (UNSTRINGIFY (CLSYS-SVAL CLASS CLASS-STRINGIFIED-SOURCE CLASS))
       SGT-API-CONS))
     (DIRECTSUPERS (CAST (THIRD SOURCETREE) SGT-API-CONS)))
    (CL:WHEN
     (CL:EQ (MEMBER? DIRECTSUPERS SUPER) 0)
     (CL:LET*
      ((*TRANSIENTOBJECTS?* TRUE))
      (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
      (THIRD-SETTER SOURCETREE (CONCATENATE DIRECTSUPERS (CONS SUPER NIL))))
     (DEFINE-CLASS-FROM-PARSE-TREE SOURCETREE)
     (FINALIZE-CLASSES-AND-SLOTS))
    (FREE-PARSE-TREE SOURCETREE)))
  :VOID)

;;; (DEFUN REMOVE-SUPERCLASS ...)

(CL:DEFUN REMOVE-SUPERCLASS (SUPER CLASS)
  "Remove the class named 'super' from the list of
superclasses of 'class'."
  (CL:LET*
   ((*MODULE*
     (CAST
      (CLSYS-SVAL SURROGATE HOME-CONTEXT (CLSYS-SVAL CLASS CLASS-TYPE CLASS))
      SGT-API-MODULE)))
   (CL:DECLARE (CL:SPECIAL *MODULE*))
   (CL:SETQ
    SUPER
    (INTERN-DERIVED-SYMBOL
     SUPER
     (CLSYS-SVAL GENERALIZED-SYMBOL SYMBOL-NAME SUPER)))
   (CL:LET*
    ((SOURCETREE
      (CAST
       (UNSTRINGIFY (CLSYS-SVAL CLASS CLASS-STRINGIFIED-SOURCE CLASS))
       SGT-API-CONS))
     (DIRECTSUPERS (CAST (THIRD SOURCETREE) SGT-API-CONS)))
    (CL:WHEN
     (CL:EQ (MEMBER? DIRECTSUPERS SUPER) 1)
     (THIRD-SETTER SOURCETREE (REMOVE DIRECTSUPERS SUPER))
     (DEFINE-CLASS-FROM-PARSE-TREE SOURCETREE)
     (FINALIZE-CLASSES-AND-SLOTS))
    (FREE-PARSE-TREE SOURCETREE)))
  :VOID)

;;; (DEFUN (DOMAIN CLASS) ...)

(CL:DEFUN DOMAIN (SLOT)
  "Return the owner of `slot'"
  (CL:RETURN-FROM
   DOMAIN
   (CAST
    (CLSYS-SVAL SURROGATE SURROGATE-VALUE (CLSYS-SVAL SLOT SLOT-OWNER SLOT))
    SGT-API-CLASS))
  :VOID)

;;; (DEFUN (COMPUTED? BOOLEAN) ...)

(CL:DEFUN COMPUTED? (SLOT)
  "Return TRUE if 'slot is computed by a STELLA method or
function."
  (CL:RETURN-FROM COMPUTED? (METHOD-SLOT? SLOT))
  :VOID)

;;; (DEFUN (RANGE CLASS) ...)

(CL:DEFUN RANGE (SLOT)
  "Return the type of `slot'"
  (CL:RETURN-FROM
   RANGE
   (CAST
    (CLSYS-SVAL
     SURROGATE
     SURROGATE-VALUE
     (CLSYS-SVAL SLOT SLOT-BASE-TYPE SLOT))
    SGT-API-CLASS))
  :VOID)

;;; (DEFUN (READ-ONLY? BOOLEAN) ...)

(CL:DEFUN READ-ONLY? (SLOT)
  "Return TRUE if `slot' is readonly"
  (CL:RETURN-FROM READ-ONLY? (CLSYS-SVAL STORAGE-SLOT SLOT-READ-ONLY? SLOT))
  :VOID)

;;; (DEFUN (SLOT? BOOLEAN) ...)

(CL:DEFUN SLOT? (OBJECT)
  "Return TRUE if `object' is a slot"
  (CL:RETURN-FROM SLOT? (ISA? OBJECT SGT-API-SLOT))
  :VOID)

;;; (DEFUN (ASSERTED-INSTANCE-OF-CLASS? BOOLEAN) ...)

(CL:DEFUN ASSERTED-INSTANCE-OF-CLASS? (INSTANCE CLASS)
  "Return TRUE if `instance' has been asserted to be
                  of type `class'"
  (CL:RETURN-FROM
   ASSERTED-INSTANCE-OF-CLASS?
   (MEMBER? (GET-TYPES INSTANCE) CLASS))
  :VOID)

;;; (DEFUN (CONSTANT? BOOLEAN) ...)

(CL:DEFUN CONSTANT? (OBJECT)
  "Return TRUE if `object' is a literal or symbol"
  (CL:RETURN-FROM
   CONSTANT?
   (CL:IF
    (CL:OR
     (CL:EQ (ISA? OBJECT SGT-API-LITERAL-WRAPPER) 1)
     (CL:EQ (ISA? OBJECT SGT-API-SYMBOL) 1))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (GET-TYPES ALL-PURPOSE-ITERATOR) ...)

(CL:DEFUN GET-TYPES (INSTANCE)
  "Return all classes `instance' belongs to"
  (CL:LET*
   ((INPROPITER (ALL-DIRECTLY-DEPENDENT-PROPOSITIONS INSTANCE KWD-API-IN))
    (RESULTITER (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR RESULTITER)
    INPROPITER)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT RESULTITER)
    INSTANCE)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE RESULTITER)
    (CL:FUNCTION GET-TYPES-NEXT?))
   (CL:RETURN-FROM GET-TYPES RESULTITER))
  :VOID)

;;; (DEFUN (GET-VALUE OBJECT) ...)

(CL:DEFUN GET-VALUE (INSTANCE SLOT)
  "Get the value of 'slot' on `instance'"
  (CL:RETURN-FROM
   GET-VALUE
   (GET-ATTRIBUTE-PROPOSITION-VALUE
    INSTANCE
    (CLSYS-SVAL SLOT SLOT-SLOTREF SLOT)))
  :VOID)

;;; (DEFUN (LIST-SLOT-NAMES-AND-VALUES SLOT-VALUE-ITERATOR) ...)

(CL:DEFUN LIST-SLOT-NAMES-AND-VALUES (INSTANCE)
  "Return all slots and associated values asserted for
`instance'"
  (CL:LET*
   ((PROPITER
     (ALL-DEPENDENT-ATTRIBUTE-PROPOSITIONS INSTANCE KWD-API-FUNCTION))
    (RESULTITER (NEW-SLOT-VALUE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL SLOT-VALUE-ITERATOR NESTED-ITERATOR RESULTITER)
    PROPITER)
   (CL:RETURN-FROM LIST-SLOT-NAMES-AND-VALUES RESULTITER))
  :VOID)

;;; (DEFUN (CONTEXT CONTEXT) ...)

(CL:DEFUN CONTEXT (OBJECT)
  "Return context (if any) of `object'"
  (CL:LET*
   ((OBJECT-001 OBJECT))
   (CL:COND
    ((CL:EQ (CLASS? OBJECT) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:RETURN-FROM
       CONTEXT
       (CLSYS-SVAL
        SURROGATE
        HOME-CONTEXT
        (CLSYS-SVAL CLASS CLASS-TYPE OBJECT)))))
    ((CL:EQ (TAXONOMY-ISA? OBJECT SGT-API-SLOT) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:RETURN-FROM
       CONTEXT
       (CLSYS-SVAL
        SURROGATE
        HOME-CONTEXT
        (CLSYS-SVAL SLOT SLOT-OWNER OBJECT)))))
    ((CL:EQ (TAXONOMY-ISA? OBJECT SGT-API-LOGIC-OBJECT) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:RETURN-FROM CONTEXT (CLSYS-SVAL LOGIC-OBJECT HOME-CONTEXT OBJECT))))
    ((CL:EQ (TAXONOMY-ISA? OBJECT SGT-API-GENERALIZED-SYMBOL) 1)
     (CL:LET*
      ((OBJECT NULL))
      (CL:SETQ OBJECT OBJECT-001)
      (CL:RETURN-FROM
       CONTEXT
       (CAST
        (CLSYS-SVAL GENERALIZED-SYMBOL HOME-CONTEXT OBJECT)
        SGT-API-MODULE))))
    (CL:T (CL:RETURN-FROM CONTEXT NULL))))
  :VOID)

;;; (DEFUN (LIST-MODULE ALL-PURPOSE-ITERATOR) ...)

(CL:DEFUN LIST-MODULE (MODULE)
  "Return all classes and instances in `module'"
  (CL:RETURN-FROM
   LIST-MODULE
   (CONCATENATE (ALL-CLASSES MODULE TRUE) (ALL-INSTANCES MODULE TRUE)))
  :VOID)

;;; (DEFUN (CONTEXT-PARENTS ITERATOR) ...)

(CL:DEFUN CONTEXT-PARENTS (MODULE)
  "Return the parent contexts of `module'."
  (CL:RETURN-FROM CONTEXT-PARENTS (PARENT-CONTEXTS MODULE))
  :VOID)

;;; (DEFUN (CONTEXT-CHILDREN ITERATOR) ...)

(CL:DEFUN CONTEXT-CHILDREN (MODULE)
  "Return the child contexts of `module'."
  (CL:RETURN-FROM
   CONTEXT-CHILDREN
   (ALLOCATE-ITERATOR (CLSYS-SVAL MODULE CHILD-CONTEXTS MODULE)))
  :VOID)

;;; (DEFUN (ITERATOR-KEY OBJECT) ...)

(CL:DEFUN ITERATOR-KEY (SELF)
  "Return the current key of `self'"
  (CL:RETURN-FROM ITERATOR-KEY (CLSYS-SVAL DICTIONARY-ITERATOR KEY SELF))
  :VOID)

;;; (DEFUN (ITERATOR-VALUE OBJECT) ...)

(CL:DEFUN ITERATOR-VALUE (SELF)
  "Return the current value of `self'"
  (CL:RETURN-FROM ITERATOR-VALUE (CLSYS-SVAL ITERATOR VALUE SELF))
  :VOID)

;;; (DEFUN (NEXTP LISP-CODE) ...)

(CL:DEFUN NEXTP (ITERATOR)
  "Return corresponding Lisp value of (next? `iterator')"
  (CL:RETURN-FROM NEXTP (TRUE-P (NEXT? ITERATOR)))
  :VOID)

;;; (DEFSPECIAL *SELECTED-MODULES* ...)

(CL:DEFVAR *SELECTED-MODULES* NULL
  "API functions filter out any objects whose home-context is
not mentioned in this list.  If it is NULL or an empty list all modules 
will be considered.")

(CL:DEFUN READ-*SELECTED-MODULES* ()
  (CL:RETURN-FROM READ-*SELECTED-MODULES* *SELECTED-MODULES*)
  :VOID)

(CL:DEFUN WRITE-*SELECTED-MODULES* (VALUE)
  (CL:SETQ *SELECTED-MODULES* VALUE)
  (CL:RETURN-FROM WRITE-*SELECTED-MODULES* VALUE)
  :VOID)

;;; (DEFUN SELECT-MODULE ...)

(CL:DEFUN SELECT-MODULE (MODULE LOCAL?)
  "Add 'module' to the list of selected modules.  
If 'local?' is FALSE also select all modules visible from 'module'."
  (CL:WHEN
   (CL:EQ (NULL-LIST? *SELECTED-MODULES*) 1)
   (CL:SETQ *SELECTED-MODULES* (NEW-LIST)))
  (CL:IF
   (CL:EQ LOCAL? 1)
   (CL:WHEN
    (CL:EQ (MEMBER? *SELECTED-MODULES* MODULE) 0)
    (INSERT-LAST *SELECTED-MODULES* MODULE))
   (CL:LET*
    ((MOD NULL) (ITER-001 (VISIBLE-MODULES MODULE)) (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN
      (CL:SETQ
       MOD
       (CAST (CLSYS-SVAL ITERATOR VALUE ITER-001) SGT-API-MODULE)))
     (CL:WHEN
      (CL:EQ (MEMBER? *SELECTED-MODULES* MOD) 0)
      (CL:IF
       (CL:EQ COLLECT-001 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-001 (PERMANENT-CONS MOD NIL))
        (CL:IF
         (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST *SELECTED-MODULES*) NIL)
         (CL:SETF
          (CLSYS-SVAL LIST THE-CONS-LIST *SELECTED-MODULES*)
          COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST
          (CLSYS-SVAL LIST THE-CONS-LIST *SELECTED-MODULES*)
          COLLECT-001)))
       (CL:PROGN
        (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (PERMANENT-CONS MOD NIL))
        (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))))
  :VOID)

;;; (DEFUN DESELECT-MODULE ...)

(CL:DEFUN DESELECT-MODULE (MODULE LOCAL?)
  "Remove 'module' from the list of selected modules.  
If 'local?' is FALSE also deselect all modules visible from 'module'."
  (CL:WHEN
   (CL:EQ (DEFINED-LIST? *SELECTED-MODULES*) 1)
   (CL:IF
    (CL:EQ LOCAL? 1)
    (REMOVE *SELECTED-MODULES* MODULE)
    (CL:LET*
     ((MOD NULL) (ITER-001 (VISIBLE-MODULES MODULE)))
     (CL:LOOP
      WHILE
      (CL:EQ (NEXT? ITER-001) 1)
      DO
      (CL:PROGN
       (CL:SETQ
        MOD
        (CAST (CLSYS-SVAL ITERATOR VALUE ITER-001) SGT-API-MODULE)))
      (REMOVE *SELECTED-MODULES* MOD)))))
  :VOID)

;;; (DEFUN SELECT-ALL-MODULES ...)

(CL:DEFUN SELECT-ALL-MODULES ()
  "Select all modules."
  (CL:WHEN
   (CL:EQ (DEFINED-LIST? *SELECTED-MODULES*) 1)
   (CLEAR *SELECTED-MODULES*))
  :VOID)

;;; (DEFUN (VISIBLE-OBJECT? BOOLEAN) ...)

(CL:DEFUN VISIBLE-OBJECT? (OBJECT)
  "Return TRUE if 'object' is visible with respect to the
set of currently selected modules."
  (CL:IF
   (CL:OR
    (CL:EQ *SELECTED-MODULES* NULL)
    (CL:EQ (EMPTY? *SELECTED-MODULES*) 1))
   (CL:RETURN-FROM VISIBLE-OBJECT? TRUE)
   (CL:LET*
    ((CT (CONTEXT OBJECT)))
    (CL:LET*
     ((FOUND?-001 FALSE))
     (CL:LET*
      ((MODULE NULL)
       (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST *SELECTED-MODULES*)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ
         MODULE
         (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-API-MODULE))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (CL:WHEN (CL:EQ MODULE CT) (CL:SETQ FOUND?-001 TRUE) (CL:RETURN))))
     (CL:LET*
      ((VALUE-001 FOUND?-001))
      (CL:RETURN-FROM VISIBLE-OBJECT? VALUE-001)))))
  :VOID)

;;; (DEFUN (SLOT-COLUMN-TYPES (ITERATOR OF TYPE)) ...)

(CL:DEFUN SLOT-COLUMN-TYPES (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (STORAGE-SLOT? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((DOMAIN (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SELF))
        (RANGE (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SELF))
        (TYPESLIST
         (CL:IF
          (CL:EQ RANGE SGT-API-BOOLEAN)
          (LIST DOMAIN)
          (LIST DOMAIN RANGE))))
       (CL:RETURN-FROM
        SLOT-COLUMN-TYPES
        (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR TYPESLIST)))))
    ((CL:EQ (METHOD-SLOT? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
       (CL:SETF
        (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE ITERATOR)
        (CL:FUNCTION SLOT-COLUMN-TYPES-NEXT?))
       (CL:SETF
        (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR ITERATOR)
        (ALLOCATE-ITERATOR
         (METHOD-PARAMETER-TYPE-SPECIFIERS (CAST SELF SGT-API-METHOD-SLOT))))
       (CL:SETF
        (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-EMPTY-CODE ITERATOR)
        (CL:FUNCTION SLOT-COLUMN-TYPES-EMPTY?))
       (CL:SETF
        (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT ITERATOR)
        SELF)
       (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER ITERATOR) 1)
       (CL:RETURN-FROM SLOT-COLUMN-TYPES ITERATOR))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-API-TABLE) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((TYPESLIST (NEW-LIST)))
       (CL:LET*
        ((TSPEC NULL)
         (ITER-001
          (CLSYS-SVAL
           LIST
           THE-CONS-LIST
           (CLSYS-SVAL TABLE TUPLE-DOMAINS SELF)))
         (COLLECT-001 NULL))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-001 NIL))
         DO
         (CL:PROGN
          (CL:SETQ TSPEC (CLSYS-SVAL CONS VALUE ITER-001))
          (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
         (CL:IF
          (CL:EQ COLLECT-001 NULL)
          (CL:PROGN
           (CL:SETQ
            COLLECT-001
            (PERMANENT-CONS
             (TYPE-SPEC-TO-BASE-TYPE (CAST TSPEC SGT-API-TYPE-SPEC))
             NIL))
           (CL:IF
            (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST TYPESLIST) NIL)
            (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST TYPESLIST) COLLECT-001)
            (ADD-CONS-TO-END-OF-CONS-LIST
             (CLSYS-SVAL LIST THE-CONS-LIST TYPESLIST)
             COLLECT-001)))
          (CL:PROGN
           (CL:SETF
            (CLSYS-SVAL CONS REST COLLECT-001)
            (PERMANENT-CONS
             (TYPE-SPEC-TO-BASE-TYPE (CAST TSPEC SGT-API-TYPE-SPEC))
             NIL))
           (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
       (CL:RETURN-FROM
        SLOT-COLUMN-TYPES
        (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR TYPESLIST)))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" SELF))))
  :VOID)

;;; (DEFUN (SLOT-COLUMN-TYPES-NEXT? BOOLEAN) ...)

(CL:DEFUN SLOT-COLUMN-TYPES-NEXT? (SELF)
  (CL:ECASE
   (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF)
   (1
    (CL:WHEN
     (CL:EQ
      (NEXT? (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))
      0)
     (CL:SETF
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF)
      (ALLOCATE-ITERATOR
       (METHOD-RETURN-TYPE-SPECIFIERS
        (CAST
         (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF)
         SGT-API-METHOD-SLOT))))
     (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF) 2)
     (CL:IF
      (CL:EQ
       (NEXT? (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))
       1)
      (CL:SETF
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-OBJECT SELF)
       (TYPE-SPEC-TO-BASE-TYPE
        (CAST
         (CLSYS-SVAL
          ITERATOR
          VALUE
          (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))
         SGT-API-TYPE-SPEC)))
      (CL:RETURN-FROM SLOT-COLUMN-TYPES-NEXT? FALSE))
     (CL:RETURN-FROM SLOT-COLUMN-TYPES-NEXT? (SLOT-COLUMN-TYPES-NEXT? SELF)))
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF)
     (TYPE-SPEC-TO-BASE-TYPE
      (CAST
       (CLSYS-SVAL
        ITERATOR
        VALUE
        (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))
       SGT-API-TYPE-SPEC)))
    (CL:RETURN-FROM SLOT-COLUMN-TYPES-NEXT? TRUE))
   (2
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF)
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-OBJECT SELF))
    (CL:COND
     ((CL:EQ
       (NEXT? (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))
       1)
      (CL:SETF
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-OBJECT SELF)
       (TYPE-SPEC-TO-BASE-TYPE
        (CAST
         (CLSYS-SVAL
          ITERATOR
          VALUE
          (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))
         SGT-API-TYPE-SPEC)))
      (CL:RETURN-FROM SLOT-COLUMN-TYPES-NEXT? TRUE))
     ((CL:EQ (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) SGT-API-BOOLEAN)
      (CL:RETURN-FROM SLOT-COLUMN-TYPES-NEXT? FALSE))
     (CL:T
      (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF) 3)
      (CL:RETURN-FROM SLOT-COLUMN-TYPES-NEXT? TRUE))))
   (3 (CL:RETURN-FROM SLOT-COLUMN-TYPES-NEXT? FALSE)))
  :VOID)

;;; (DEFUN (SLOT-COLUMN-TYPES-EMPTY? BOOLEAN) ...)

(CL:DEFUN SLOT-COLUMN-TYPES-EMPTY? (SELF)
  (CL:RETURN-FROM
   SLOT-COLUMN-TYPES-EMPTY?
   (EMPTY? (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF)))
  :VOID)

;;; (DEFUN (INSTANCE-P BOOLEAN) ...)

(CL:DEFUN INSTANCE-P (OBJECT)
  "Return TRUE if `object' is an instance"
  (CL:RETURN-FROM INSTANCE-P (ISA? OBJECT SGT-API-LOGIC-OBJECT))
  :VOID)

(CL:DEFUN STARTUP-API ()
  (CL:LET*
   ((*MODULE* (GET-MODULE "/LOGIC" TRUE)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SGT-API-RELATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "RELATION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-API-DEFINITION-STRING
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINITION-STRING" NULL 0))
    (CL:SETQ
     SGT-API-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-API-LOGIC-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
    (CL:SETQ
     SYM-API-SURROGATE-VALUE-INVERSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE-INVERSE" NULL 0))
    (CL:SETQ
     SGT-API-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-API-GENERALIZED-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "GENERALIZED-SYMBOL"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-API-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-API-CONTEXT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-API-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-API-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
    (CL:SETQ
     SGT-API-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-API-LITERAL-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "LITERAL-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-API-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ KWD-API-IN (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 2))
    (CL:SETQ
     KWD-API-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     SYM-API-*SELECTED-MODULES*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*SELECTED-MODULES*" NULL 0))
    (CL:SETQ
     SGT-API-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-API-METHOD-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "METHOD-SLOT"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-API-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TABLE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-API-TYPE-SPEC
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "TYPE-SPEC"
      (GET-MODULE "/STELLA" TRUE)
      1)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:SETQ *SELECTED-MODULES* (NEW-LIST)))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOGIC-DEFINITION"
        "OBJECT"
        "(DEFUN (LOGIC-DEFINITION STRING) ((OBJECT OBJECT)) :DOCUMENTATION \"Return the logic definition of `object'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOGIC-DEFINITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SOURCE-DEFINITION"
        "OBJECT"
        "(DEFUN (SOURCE-DEFINITION STRING) ((OBJECT OBJECT)) :DOCUMENTATION \"Return the source definition of `object'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SOURCE-DEFINITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "OBJECT-NAME"
        "OBJECT"
        "(DEFUN (OBJECT-NAME STRING) ((OBJECT OBJECT)) :DOCUMENTATION \"Return the name of a stella object\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION OBJECT-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-CLASS"
        "STRING"
        "(DEFUN (FIND-CLASS CLASS) ((NAME STRING)) :DOCUMENTATION \"Retrieve the class with name `name'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-CONTEXT"
        "STRING"
        "(DEFUN (FIND-CONTEXT CONTEXT) ((NAME STRING)) :DOCUMENTATION \"Retrieve the context with name `name'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-INSTANCE"
        "STRING"
        "(DEFUN (FIND-INSTANCE LOGIC-OBJECT) ((NAME STRING)) :DOCUMENTATION \"Find the instance with name `name'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-INSTANCE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-INSTANCE"
        "STRING"
        "(DEFUN (GET-INSTANCE LOGIC-OBJECT) ((NAME STRING) (ERROR? BOOLEAN)) :DOCUMENTATION \"Find the instance with name `name'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-INSTANCE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-SUPERCLASSES"
        "CLASS"
        "(DEFUN (ALL-SUPERCLASSES (ITERATOR OF CLASS)) ((CLASS CLASS)) :DOCUMENTATION \"Get all superclasses (excluding `class') of `class'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-SUPERCLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBCLASS?"
        "CLASS"
        "(DEFUN (SUBCLASS? BOOLEAN) ((CLASS1 CLASS) (CLASS2 CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SUBCLASS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DIRECT-SUPERCLASSES"
        "CLASS"
        "(DEFUN (DIRECT-SUPERCLASSES (ITERATOR OF CLASS)) ((CLASS CLASS)) :DOCUMENTATION \"Get direct superclasses of `class'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DIRECT-SUPERCLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DIRECT-SUPERRELATIONS"
        "RELATION"
        "(DEFMETHOD (DIRECT-SUPERRELATIONS (ITERATOR OF RELATION)) ((SELF RELATION)) :DOCUMENTATION \"Return direct super classes/slots/tables of 'self'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DIRECT-SUPERRELATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DIRECT-SUPERRELATIONS"
        "SLOT"
        "(DEFMETHOD (DIRECT-SUPERRELATIONS (ITERATOR OF SLOT)) ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DIRECT-SUPERRELATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DIRECT-SUPERRELATIONS"
        "CLASS"
        "(DEFMETHOD (DIRECT-SUPERRELATIONS (ITERATOR OF CLASS)) ((SELF CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION DIRECT-SUPERRELATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TEST1"
        "CONS"
        "(DEFUN (TEST1 CONS) ((PARENTS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TEST1)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DIRECT-SUPERTYPES"
        "CLASS"
        "(DEFUN (DIRECT-SUPERTYPES (ITERATOR OF CLASS)) ((CLASS CLASS)) :DOCUMENTATION \"Get direct supertypes of `class'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DIRECT-SUPERTYPES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DIRECT-SUBCLASSES"
        "CLASS"
        "(DEFUN (DIRECT-SUBCLASSES (ITERATOR OF CLASS)) ((CLASS CLASS)) :DOCUMENTATION \"Get direct subclasses of `class'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DIRECT-SUBCLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASS-NAMES"
        "CLASS"
        "(DEFUN (CLASS-NAMES (ALL-PURPOSE-ITERATOR OF SURROGATE)) ((CLASS CLASS)) :DOCUMENTATION \"Get all names (including synonyms) of `class'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASS-NAMES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-INSTANCES"
        "CLASS"
        "(DEFUN (GET-INSTANCES CONS-ITERATOR) ((CLASS CLASS)) :DOCUMENTATION \"Return all instances asserted to be of type `class'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-INSTANCES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-SUBCLASSES"
        "CLASS"
        "(DEFUN (GET-SUBCLASSES (ITERATOR OF CLASS)) ((CLASS CLASS)) :DOCUMENTATION \"Get all subclasses of `class', including self.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-SUBCLASSES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ADD-SUPERCLASS"
        "GENERALIZED-SYMBOL"
        "(DEFUN ADD-SUPERCLASS ((SUPER GENERALIZED-SYMBOL) (CLASS CLASS)) :DOCUMENTATION \"Add the class named 'super' to the list of
superclasses of 'class'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ADD-SUPERCLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-SUPERCLASS"
        "GENERALIZED-SYMBOL"
        "(DEFUN REMOVE-SUPERCLASS ((SUPER GENERALIZED-SYMBOL) (CLASS CLASS)) :DOCUMENTATION \"Remove the class named 'super' from the list of
superclasses of 'class'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REMOVE-SUPERCLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DOMAIN"
        "SLOT"
        "(DEFUN (DOMAIN CLASS) ((SLOT SLOT)) :DOCUMENTATION \"Return the owner of `slot'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DOMAIN)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTED?"
        "SLOT"
        "(DEFUN (COMPUTED? BOOLEAN) ((SLOT SLOT)) :DOCUMENTATION \"Return TRUE if 'slot is computed by a STELLA method or
function.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTED?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RANGE"
        "SLOT"
        "(DEFUN (RANGE CLASS) ((SLOT SLOT)) :DOCUMENTATION \"Return the type of `slot'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RANGE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "READ-ONLY?"
        "STORAGE-SLOT"
        "(DEFUN (READ-ONLY? BOOLEAN) ((SLOT STORAGE-SLOT)) :DOCUMENTATION \"Return TRUE if `slot' is readonly\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION READ-ONLY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SLOT?"
        "OBJECT"
        "(DEFUN (SLOT? BOOLEAN) ((OBJECT OBJECT)) :DOCUMENTATION \"Return TRUE if `object' is a slot\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SLOT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ASSERTED-INSTANCE-OF-CLASS?"
        "LOGIC-OBJECT"
        "(DEFUN (ASSERTED-INSTANCE-OF-CLASS? BOOLEAN) ((INSTANCE LOGIC-OBJECT) (CLASS CLASS)) :DOCUMENTATION \"Return TRUE if `instance' has been asserted to be
                  of type `class'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ASSERTED-INSTANCE-OF-CLASS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONSTANT?"
        "OBJECT"
        "(DEFUN (CONSTANT? BOOLEAN) ((OBJECT OBJECT)) :DOCUMENTATION \"Return TRUE if `object' is a literal or symbol\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONSTANT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-TYPES"
        "LOGIC-OBJECT"
        "(DEFUN (GET-TYPES ALL-PURPOSE-ITERATOR) ((INSTANCE LOGIC-OBJECT)) :DOCUMENTATION \"Return all classes `instance' belongs to\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-TYPES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-VALUE"
        "LOGIC-OBJECT"
        "(DEFUN (GET-VALUE OBJECT) ((INSTANCE LOGIC-OBJECT) (SLOT SLOT)) :DOCUMENTATION \"Get the value of 'slot' on `instance'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LIST-SLOT-NAMES-AND-VALUES"
        "LOGIC-OBJECT"
        "(DEFUN (LIST-SLOT-NAMES-AND-VALUES SLOT-VALUE-ITERATOR) ((INSTANCE LOGIC-OBJECT)) :DOCUMENTATION \"Return all slots and associated values asserted for
`instance'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LIST-SLOT-NAMES-AND-VALUES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONTEXT"
        "OBJECT"
        "(DEFUN (CONTEXT CONTEXT) ((OBJECT OBJECT)) :DOCUMENTATION \"Return context (if any) of `object'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONTEXT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LIST-MODULE"
        "MODULE"
        "(DEFUN (LIST-MODULE ALL-PURPOSE-ITERATOR) ((MODULE MODULE)) :DOCUMENTATION \"Return all classes and instances in `module'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LIST-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONTEXT-PARENTS"
        "MODULE"
        "(DEFUN (CONTEXT-PARENTS ITERATOR) ((MODULE MODULE)) :DOCUMENTATION \"Return the parent contexts of `module'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONTEXT-PARENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONTEXT-CHILDREN"
        "MODULE"
        "(DEFUN (CONTEXT-CHILDREN ITERATOR) ((MODULE MODULE)) :DOCUMENTATION \"Return the child contexts of `module'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONTEXT-CHILDREN)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ITERATOR-KEY"
        "DICTIONARY-ITERATOR"
        "(DEFUN (ITERATOR-KEY OBJECT) ((SELF DICTIONARY-ITERATOR)) :DOCUMENTATION \"Return the current key of `self'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ITERATOR-KEY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ITERATOR-VALUE"
        "ITERATOR"
        "(DEFUN (ITERATOR-VALUE OBJECT) ((SELF ITERATOR)) :DOCUMENTATION \"Return the current value of `self'\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ITERATOR-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXTP"
        "ITERATOR"
        "(DEFUN (NEXTP LISP-CODE) ((ITERATOR ITERATOR)) :DOCUMENTATION \"Return corresponding Lisp value of (next? `iterator')\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NEXTP)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SELECT-MODULE"
        "MODULE"
        "(DEFUN SELECT-MODULE ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Add 'module' to the list of selected modules.  
If 'local?' is FALSE also select all modules visible from 'module'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SELECT-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESELECT-MODULE"
        "MODULE"
        "(DEFUN DESELECT-MODULE ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Remove 'module' from the list of selected modules.  
If 'local?' is FALSE also deselect all modules visible from 'module'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESELECT-MODULE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SELECT-ALL-MODULES"
        NULL
        "(DEFUN SELECT-ALL-MODULES () :DOCUMENTATION \"Select all modules.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SELECT-ALL-MODULES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VISIBLE-OBJECT?"
        "OBJECT"
        "(DEFUN (VISIBLE-OBJECT? BOOLEAN) ((OBJECT OBJECT)) :DOCUMENTATION \"Return TRUE if 'object' is visible with respect to the
set of currently selected modules.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VISIBLE-OBJECT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SLOT-COLUMN-TYPES"
        "SLOT"
        "(DEFUN (SLOT-COLUMN-TYPES (ITERATOR OF TYPE)) ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SLOT-COLUMN-TYPES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SLOT-COLUMN-TYPES-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (SLOT-COLUMN-TYPES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SLOT-COLUMN-TYPES-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SLOT-COLUMN-TYPES-EMPTY?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (SLOT-COLUMN-TYPES-EMPTY? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SLOT-COLUMN-TYPES-EMPTY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSTANCE-P"
        "OBJECT"
        "(DEFUN (INSTANCE-P BOOLEAN) ((OBJECT OBJECT)) :DOCUMENTATION \"Return TRUE if `object' is an instance\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INSTANCE-P)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-API"
     NULL
     "(DEFUN STARTUP-API ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *SELECTED-MODULES* (LIST OF MODULE) (NEW LIST) :DOCUMENTATION \"API functions filter out any objects whose home-context is
not mentioned in this list.  If it is NULL or an empty list all modules 
will be considered.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-API-*SELECTED-MODULES*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*SELECTED-MODULES*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*SELECTED-MODULES*)))))
  :VOID)
