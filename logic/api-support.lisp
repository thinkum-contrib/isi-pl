;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997                   | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-API-SUPPORT-MODULE NULL)
(CL:DEFVAR SGT-API-SUPPORT-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-API-SUPPORT-CLASS NULL)
(CL:DEFVAR SGT-API-SUPPORT-PROPOSITION NULL)
(CL:DEFVAR SGT-API-SUPPORT-TYPE NULL)
(CL:DEFVAR SYM-API-SUPPORT-NESTED-ITERATOR NULL)
(CL:DEFVAR SGT-API-SUPPORT-ITERATOR NULL)
(CL:DEFVAR SGT-API-SUPPORT-SLOT-VALUE-ITERATOR NULL)
(CL:DEFVAR SGT-API-SUPPORT-SLOTREF NULL)
(CL:DEFVAR SGT-API-SUPPORT-SLOT NULL)
(CL:DEFVAR SGT-API-SUPPORT-LIST NULL)
(CL:DEFVAR SGT-API-SUPPORT-DESCRIPTION NULL)
(CL:DEFVAR SYM-API-SUPPORT-SURROGATE-VALUE-INVERSE NULL)
(CL:DEFVAR SGT-API-SUPPORT-SURROGATE NULL)
(CL:DEFVAR SGT-API-SUPPORT-RELATION NULL)
(CL:DEFVAR SYM-API-SUPPORT-DESCRIPTION NULL)
(CL:DEFVAR SYM-API-SUPPORT-DEFINITION NULL)
(CL:DEFVAR SGT-API-SUPPORT-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-API-SUPPORT-SKOLEM NULL)
(CL:DEFVAR SGT-API-SUPPORT-ALL-PURPOSE-ITERATOR NULL)

;;; Forward declarations:

(CL:DECLAIM (CL:SPECIAL *MODULE* *SURROGATE-ARRAY*))

;;; (DEFUN (FILTERED-TYPES-TO-CLASSES-NEXT? BOOLEAN) ...)

(CL:DEFUN FILTERED-TYPES-TO-CLASSES-NEXT? (SELF)
  (CL:LET*
   ((TYPES (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))
    (TYPESITERATOR
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))
    (MODULES (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF))
    (FILTERCLASSES?
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ MODULES NULL)) (CL:EQ (NON-EMPTY? MODULES) 1))
      TRUE
      FALSE))
    (TYPE NULL))
   (CL:LOOP
    (CL:COND
     ((CL:NOT (CL:EQ TYPESITERATOR NULL))
      (CL:WHEN
       (CL:EQ (NEXT? TYPESITERATOR) 0)
       (CL:RETURN-FROM FILTERED-TYPES-TO-CLASSES-NEXT? FALSE))
      (CL:SETQ TYPE (CLSYS-SVAL ITERATOR VALUE TYPESITERATOR)))
     (CL:T
      (CL:WHEN
       (CL:EQ TYPES NIL)
       (CL:RETURN-FROM FILTERED-TYPES-TO-CLASSES-NEXT? FALSE))
      (CL:SETQ TYPE (CLSYS-SVAL CONS VALUE TYPES))
      (CL:SETQ TYPES (CLSYS-SVAL CONS REST TYPES))))
    (CL:LET*
     ((TEST-VALUE-001 FALSE))
     (CL:IF
      (CL:EQ FILTERCLASSES? 0)
      (CL:SETQ TEST-VALUE-001 TRUE)
      (CL:LET*
       ((FOUND?-001 FALSE))
       (CL:LET*
        ((MODULE NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST MODULES)))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-001 NIL))
         DO
         (CL:PROGN
          (CL:SETQ
           MODULE
           (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-API-SUPPORT-MODULE))
          (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
         (CL:WHEN
          (CL:EQ MODULE (CLSYS-SVAL SURROGATE HOME-CONTEXT TYPE))
          (CL:SETQ FOUND?-001 TRUE)
          (CL:RETURN))))
       (CL:SETQ TEST-VALUE-001 FOUND?-001)))
     (CL:WHEN
      (CL:EQ TEST-VALUE-001 1)
      (CL:SETF
       (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF)
       (TYPE-TO-CLASS TYPE))
      (CL:WHEN
       (CL:EQ TYPESITERATOR NULL)
       (CL:SETF
        (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
        TYPES))
      (CL:RETURN-FROM FILTERED-TYPES-TO-CLASSES-NEXT? TRUE)))))
  :VOID)

;;; (DEFUN (FILTERED-TYPES-NEXT? BOOLEAN) ...)

(CL:DEFUN FILTERED-TYPES-NEXT? (SELF)
  (CL:LET*
   ((TYPES (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))
    (TYPESITERATOR
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))
    (MODULES (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF))
    (FILTERCLASSES?
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ MODULES NULL)) (CL:EQ (NON-EMPTY? MODULES) 1))
      TRUE
      FALSE))
    (TYPE NULL))
   (CL:LOOP
    (CL:COND
     ((CL:NOT (CL:EQ TYPESITERATOR NULL))
      (CL:WHEN
       (CL:EQ (NEXT? TYPESITERATOR) 0)
       (CL:RETURN-FROM FILTERED-TYPES-NEXT? FALSE))
      (CL:SETQ TYPE (CLSYS-SVAL ITERATOR VALUE TYPESITERATOR)))
     (CL:T
      (CL:WHEN (CL:EQ TYPES NIL) (CL:RETURN-FROM FILTERED-TYPES-NEXT? FALSE))
      (CL:SETQ TYPE (CLSYS-SVAL CONS VALUE TYPES))
      (CL:SETQ TYPES (CLSYS-SVAL CONS REST TYPES))))
    (CL:LET*
     ((TEST-VALUE-001 FALSE))
     (CL:IF
      (CL:EQ FILTERCLASSES? 0)
      (CL:SETQ TEST-VALUE-001 TRUE)
      (CL:LET*
       ((FOUND?-001 FALSE))
       (CL:LET*
        ((MODULE NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST MODULES)))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-001 NIL))
         DO
         (CL:PROGN
          (CL:SETQ
           MODULE
           (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-API-SUPPORT-MODULE))
          (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
         (CL:WHEN
          (CL:EQ MODULE (CLSYS-SVAL SURROGATE HOME-CONTEXT TYPE))
          (CL:SETQ FOUND?-001 TRUE)
          (CL:RETURN))))
       (CL:SETQ TEST-VALUE-001 FOUND?-001)))
     (CL:WHEN
      (CL:EQ TEST-VALUE-001 1)
      (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) TYPE)
      (CL:WHEN
       (CL:EQ TYPESITERATOR NULL)
       (CL:SETF
        (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
        TYPES))
      (CL:RETURN-FROM FILTERED-TYPES-NEXT? TRUE)))))
  :VOID)

;;; (DEFUN (GET-TYPES-NEXT? BOOLEAN) ...)

(CL:DEFUN GET-TYPES-NEXT? (SELF)
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL ALL-PURPOSE-ITERATOR FIRST-ITERATION? SELF) 1)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR FIRST-ITERATION? SELF) FALSE)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF)
    (CAST
     (CLSYS-SVAL
      SURROGATE
      SURROGATE-VALUE
      (CLSYS-SVAL
       LOGIC-OBJECT
       ROOT-TYPE
       (CAST
        (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF)
        SGT-API-SUPPORT-LOGIC-OBJECT)))
     SGT-API-SUPPORT-CLASS))
   (CL:RETURN-FROM GET-TYPES-NEXT? TRUE))
  (CL:LET*
   ((NEXT?
     (NEXT? (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))))
   (CL:WHEN
    (CL:EQ NEXT? 1)
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF)
     (CAST
      (CLSYS-SVAL
       SURROGATE
       SURROGATE-VALUE
       (CAST
        (CL:AREF
         (CLSYS-SVAL
          VECTOR
          THE-ARRAY
          (CLSYS-SVAL
           PROPOSITION
           ARGUMENTS
           (CAST
            (CLSYS-SVAL
             ITERATOR
             VALUE
             (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))
            SGT-API-SUPPORT-PROPOSITION)))
         1)
        SGT-API-SUPPORT-TYPE))
      SGT-API-SUPPORT-CLASS)))
   (CL:RETURN-FROM GET-TYPES-NEXT? NEXT?))
  :VOID)

;;; (DEFUN (CLASS-NAMES-NEXT? BOOLEAN) ...)

(CL:DEFUN CLASS-NAMES-NEXT? (SELF)
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL ALL-PURPOSE-ITERATOR FIRST-ITERATION? SELF) 1)
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR FIRST-ITERATION? SELF) FALSE)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF)
    (CLSYS-SVAL
     CLASS
     CLASS-TYPE
     (CAST
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF)
      SGT-API-SUPPORT-CLASS)))
   (CL:RETURN-FROM CLASS-NAMES-NEXT? TRUE))
  (CL:LET*
   ((NEXT?
     (NEXT? (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))))
   (CL:WHEN
    (CL:EQ NEXT? 1)
    (CL:SETF
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF)
     (CLSYS-SVAL
      ITERATOR
      VALUE
      (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF))))
   (CL:RETURN-FROM CLASS-NAMES-NEXT? NEXT?))
  :VOID)

;;; (DEFUN COLLECT-SUBTYPES ...)

(CL:DEFUN COLLECT-SUBTYPES (TYPE RESULT)
  (INSERT-NEW RESULT TYPE)
  (CL:LET*
   ((CLASS (TYPE-TO-CLASS TYPE)))
   (CL:WHEN
    (CL:NOT (CL:EQ CLASS NULL))
    (CL:LET*
     ((SUB NULL)
      (ITER-001
       (CLSYS-SVAL
        LIST
        THE-CONS-LIST
        (CLSYS-SVAL CLASS CLASS-DIRECT-SUBS CLASS))))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ
        SUB
        (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-API-SUPPORT-TYPE))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (COLLECT-SUBTYPES SUB RESULT)))))
  :VOID)

;;; (DEFCLASS SLOT-VALUE-ITERATOR ...)

(CL:DEFCLASS SLOT-VALUE-ITERATOR (DICTIONARY-ITERATOR)
  ((NESTED-ITERATOR :ALLOCATION :INSTANCE :ACCESSOR NESTED-ITERATOR...OF)))

(CL:DEFUN NEW-SLOT-VALUE-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SLOT-VALUE-ITERATOR)))
   (CL:SETF (CLSYS-SVAL SLOT-VALUE-ITERATOR FIRST-ITERATION? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL SLOT-VALUE-ITERATOR VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL SLOT-VALUE-ITERATOR KEY SELF) NULL)
   (CL:SETF (CLSYS-SVAL SLOT-VALUE-ITERATOR NESTED-ITERATOR SELF) NULL)
   (CL:RETURN-FROM NEW-SLOT-VALUE-ITERATOR SELF))
  :VOID)

(CL:DEFUN ACCESS-SLOT-VALUE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-API-SUPPORT-NESTED-ITERATOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SLOT-VALUE-ITERATOR NESTED-ITERATOR SELF)
      (CAST VALUE SGT-API-SUPPORT-ITERATOR))
     (CL:RETURN-FROM
      ACCESS-SLOT-VALUE-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL SLOT-VALUE-ITERATOR NESTED-ITERATOR SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-SLOT-VALUE-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SLOT-VALUE-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-API-SUPPORT-SLOT-VALUE-ITERATOR)
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF SLOT-VALUE-ITERATOR))
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL SLOT-VALUE-ITERATOR FIRST-ITERATION? SELF) 1)
   (CL:SETF (CLSYS-SVAL SLOT-VALUE-ITERATOR FIRST-ITERATION? SELF) FALSE))
  (CL:LET*
   ((ITERATOR (CLSYS-SVAL SLOT-VALUE-ITERATOR NESTED-ITERATOR SELF))
    (PROPOSITION NULL))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITERATOR) 1)
    DO
    (CL:SETQ
     PROPOSITION
     (CAST (CLSYS-SVAL ITERATOR VALUE ITERATOR) SGT-API-SUPPORT-PROPOSITION))
    (CL:WHEN
     (CL:EQ (TRUE? PROPOSITION) 1)
     (CL:SETF
      (CLSYS-SVAL SLOT-VALUE-ITERATOR KEY SELF)
      (CAST
       (CLSYS-SVAL
        SURROGATE
        SURROGATE-VALUE
        (CAST
         (CLSYS-SVAL PROPOSITION OPERATOR PROPOSITION)
         SGT-API-SUPPORT-SLOTREF))
       SGT-API-SUPPORT-SLOT))
     (CL:SETF
      (CLSYS-SVAL SLOT-VALUE-ITERATOR VALUE SELF)
      (VALUE-OF
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
        1)))
     (CL:RETURN-FROM NEXT? TRUE)))
   (CL:RETURN-FROM NEXT? FALSE))
  :VOID)

;;; (DEFUN (ALL-PROPOSITIONS-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-PROPOSITIONS-NEXT? (SELF)
  (CL:LET*
   ((PROPOSITIONS (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))
    (PROPOSITION NULL)
    (MODULE NULL))
   (CL:LOOP
    WHILE
    (CL:EQ PROPOSITION NULL)
    DO
    (CL:LOOP
     WHILE
     (CL:EQ PROPOSITIONS NIL)
     DO
     (CL:SETQ
      MODULE
      (CAST
       (POP
        (CAST
         (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF)
         SGT-API-SUPPORT-LIST))
       SGT-API-SUPPORT-MODULE))
     (CL:WHEN
      (CL:EQ MODULE NULL)
      (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) NULL)
      (CL:RETURN-FROM ALL-PROPOSITIONS-NEXT? FALSE))
     (CL:SETQ
      PROPOSITIONS
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (LOCALLY-CONCEIVED-PROPOSITIONS-GETTER MODULE))))
    (CL:LET*
     ((CONS-001 (CLSYS-SVAL CONS VALUE PROPOSITIONS)))
     (CL:SETQ PROPOSITIONS (CLSYS-SVAL CONS REST PROPOSITIONS))
     (CL:SETQ PROPOSITION (CAST CONS-001 SGT-API-SUPPORT-PROPOSITION)))
    (CL:WHEN (CL:EQ (DELETED? PROPOSITION) 1) (CL:SETQ PROPOSITION NULL)))
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) PROPOSITION)
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF)
    PROPOSITIONS)
   (CL:RETURN-FROM ALL-PROPOSITIONS-NEXT? TRUE))
  :VOID)

;;; (DEFUN (ALL-PROPOSITIONS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-PROPOSITIONS (MODULE LOCAL?)
  "Iterate over all conceived propositions visible from `module'.
Only propositions that haven't been deleted will be considered.
If `local?', only return propositions conceived locally in `module'."
  (CL:LET*
   ((SELF-001 (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-OBJECT SELF-001)
    (CL:IF
     (CL:EQ LOCAL? 1)
     (LIST MODULE)
     (REVERSE (LISTIFY (VISIBLE-MODULES MODULE)))))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE SELF-001)
    (CL:FUNCTION ALL-PROPOSITIONS-NEXT?))
   (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF-001) NIL)
   (CL:LET* ((VALUE-001 SELF-001)) (CL:RETURN-FROM ALL-PROPOSITIONS VALUE-001)))
  :VOID)

;;; (DEFUN (VISIBLE-TERM? BOOLEAN) ...)

(CL:DEFUN VISIBLE-TERM? (TERM CONTEXT LOCAL?)
  (CL:RETURN-FROM
   VISIBLE-TERM?
   (CL:IF
    (CL:EQ LOCAL? 1)
    (EQ? (CLSYS-SVAL LOGIC-OBJECT HOME-CONTEXT TERM) CONTEXT)
    (VISIBLE-FROM?
     (CAST (CLSYS-SVAL LOGIC-OBJECT HOME-CONTEXT TERM) SGT-API-SUPPORT-MODULE)
     (CAST CONTEXT SGT-API-SUPPORT-MODULE))))
  :VOID)

;;; (DEFUN (TERM-LINKED-TO-VISIBLE-SURROGATE? BOOLEAN) ...)

(CL:DEFUN TERM-LINKED-TO-VISIBLE-SURROGATE? (TERM CONTEXT LOCAL?)
  (CL:LET*
   ((NAMECONTEXT NULL))
   (CL:LET*
    ((TERM-001 TERM))
    (CL:COND
     ((CL:EQ (TAXONOMY-ISA? TERM SGT-API-SUPPORT-DESCRIPTION) 1)
      (CL:LET*
       ((TERM NULL))
       (CL:SETQ TERM TERM-001)
       (CL:LET*
        ((NATIVERELATION (CLSYS-SVAL DESCRIPTION NATIVE-RELATION TERM)))
        (CL:WHEN
         (CL:NOT (CL:EQ NATIVERELATION NULL))
         (CL:LET*
          ((NATIVERELATION-001 NATIVERELATION))
          (CL:COND
           ((CL:EQ (CLASS? NATIVERELATION) 1)
            (CL:LET*
             ((NATIVERELATION NULL))
             (CL:SETQ NATIVERELATION NATIVERELATION-001)
             (CL:SETQ
              NAMECONTEXT
              (CAST
               (CLSYS-SVAL
                SURROGATE
                HOME-CONTEXT
                (CLSYS-SVAL CLASS CLASS-TYPE NATIVERELATION))
               SGT-API-SUPPORT-MODULE))))
           ((CL:EQ (TAXONOMY-ISA? NATIVERELATION SGT-API-SUPPORT-SLOT) 1)
            (CL:LET*
             ((NATIVERELATION NULL))
             (CL:SETQ NATIVERELATION NATIVERELATION-001)
             (CL:SETQ
              NAMECONTEXT
              (CAST
               (CLSYS-SVAL
                SURROGATE
                HOME-CONTEXT
                (CLSYS-SVAL SLOT SLOT-OWNER NATIVERELATION))
               SGT-API-SUPPORT-MODULE))))
           (CL:T NULL)))))))
     (CL:T
      (CL:LET*
       ((SURROGATE
         (DYNAMIC-SLOT-VALUE
          TERM
          SYM-API-SUPPORT-SURROGATE-VALUE-INVERSE
          NULL)))
       (CL:WHEN
        (CL:NOT (CL:EQ SURROGATE NULL))
        (CL:SETQ
         NAMECONTEXT
         (CAST
          (CLSYS-SVAL SURROGATE HOME-CONTEXT SURROGATE)
          SGT-API-SUPPORT-MODULE)))))))
   (CL:RETURN-FROM
    TERM-LINKED-TO-VISIBLE-SURROGATE?
    (CL:IF
     (CL:AND
      (CL:NOT (CL:EQ NAMECONTEXT NULL))
      (CL:EQ
       (CL:IF
        (CL:EQ LOCAL? 1)
        (EQ? NAMECONTEXT CONTEXT)
        (VISIBLE-FROM?
         (CAST NAMECONTEXT SGT-API-SUPPORT-MODULE)
         (CAST CONTEXT SGT-API-SUPPORT-MODULE)))
       1))
     TRUE
     FALSE)))
  :VOID)

;;; (DEFUN (ALL-UNNAMED-TERMS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-UNNAMED-TERMS (MODULE LOCAL?)
  "Iterate over all unnamed terms visible from `module'.  A term can be
an instance (or individual) as well as a description.  Only terms that
haven't been deleted will be considered.  If `local?', only return
terms created locally in `module'."
  (CL:LET*
   ((TERMS NIL) (TERMSWITHDUPLICATES NIL) (VALUE NULL) (TERM NULL))
   (CL:LET*
    ((SURROGATE NULL) (ITER-001 (ALL-SURROGATES MODULE LOCAL?)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN
      (CL:SETQ
       SURROGATE
       (CAST (CLSYS-SVAL ITERATOR VALUE ITER-001) SGT-API-SUPPORT-SURROGATE)))
     (CL:SETQ VALUE (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE))
     (CL:WHEN
      (CL:NOT (CL:EQ VALUE NULL))
      (CL:LET*
       ((VALUE-001 VALUE))
       (CL:COND
        ((CL:EQ (TAXONOMY-ISA? VALUE SGT-API-SUPPORT-RELATION) 1)
         (CL:LET*
          ((VALUE NULL))
          (CL:SETQ VALUE VALUE-001)
          (CL:SETQ
           TERM
           (DYNAMIC-SLOT-VALUE VALUE SYM-API-SUPPORT-DESCRIPTION NULL))
          (CL:WHEN
           (CL:AND
            (CL:NOT (CL:EQ TERM NULL))
            (CL:EQ (DELETED? TERM) 0)
            (CL:EQ (VISIBLE-TERM? TERM MODULE LOCAL?) 1))
           (CL:SETQ TERMS (CONS TERM TERMS)))
          (CL:SETQ
           TERM
           (DYNAMIC-SLOT-VALUE VALUE SYM-API-SUPPORT-DEFINITION NULL))
          (CL:WHEN
           (CL:AND
            (CL:NOT (CL:EQ TERM NULL))
            (CL:EQ (DELETED? TERM) 0)
            (CL:EQ (VISIBLE-TERM? TERM MODULE LOCAL?) 1))
           (CL:SETQ TERMS (CONS TERM TERMS)))))
        (CL:T NULL))))))
   (CL:LET*
    ((PROPOSITION NULL) (ITER-002 (ALL-PROPOSITIONS MODULE LOCAL?)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-002) 1)
     DO
     (CL:PROGN
      (CL:SETQ
       PROPOSITION
       (CAST
        (CLSYS-SVAL ITERATOR VALUE ITER-002)
        SGT-API-SUPPORT-PROPOSITION)))
     (CL:TAGBODY
      (CL:LET*
       ((ARG NULL)
        (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
        (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:LOOP
        WHILE
        (CL:< INDEX-001 LENGTH-001)
        DO
        (CL:PROGN
         (CL:SETQ
          ARG
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
        (CL:TAGBODY
         (CL:WHEN
          (CL:AND
           (CL:EQ (ISA? ARG SGT-API-SUPPORT-LOGIC-OBJECT) 1)
           (CL:EQ (DELETED? ARG) 0))
          (CL:SETQ TERM (CAST ARG SGT-API-SUPPORT-LOGIC-OBJECT))
          (CL:WHEN
           (CL:OR
            (CL:EQ (VISIBLE-TERM? TERM MODULE LOCAL?) 0)
            (CL:EQ (TERM-LINKED-TO-VISIBLE-SURROGATE? TERM MODULE LOCAL?) 1))
           (CL:GO :CONTINUE))
          (CL:LET*
           ((TERM-001 TERM))
           (CL:COND
            ((CL:EQ (TAXONOMY-ISA? TERM SGT-API-SUPPORT-PATTERN-VARIABLE) 1)
             (CL:LET* ((TERM NULL)) (CL:SETQ TERM TERM-001) NULL))
            ((CL:EQ (TAXONOMY-ISA? TERM SGT-API-SUPPORT-SKOLEM) 1)
             (CL:LET*
              ((TERM NULL))
              (CL:SETQ TERM TERM-001)
              (CL:IF
               (CL:NOT
                (CL:EQ (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION TERM) NULL))
               (CL:WHEN
                (CL:EQ
                 (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION TERM)
                 PROPOSITION)
                (CL:SETQ TERMS (CONS TERM TERMS)))
               (CL:SETQ
                TERMSWITHDUPLICATES
                (CONS TERM TERMSWITHDUPLICATES)))))
            (CL:T
             (CL:SETQ TERMSWITHDUPLICATES (CONS TERM TERMSWITHDUPLICATES))))))
         :CONTINUE)))
      :CONTINUE)))
   (CL:LET*
    ((SELF-001 (NEW-LIST)))
    (CL:SETF
     (CLSYS-SVAL LIST THE-CONS-LIST SELF-001)
     (CONCATENATE (REMOVE-DUPLICATES TERMSWITHDUPLICATES) TERMS))
    (CL:LET*
     ((VALUE-002 (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR SELF-001)))
     (CL:RETURN-FROM ALL-UNNAMED-TERMS VALUE-002))))
  :VOID)

;;; (DEFUN (ALL-NAMED-TERMS-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-NAMED-TERMS-NEXT? (SELF)
  (CL:LET*
   ((CURSOR (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF))
    (MODULES (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-CONS-LIST SELF))
    (SURROGATE NULL)
    (VALUE NULL))
   (CL:LOOP
    WHILE
    (CL:<
     CURSOR
     (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-SECOND-INTEGER SELF))
    DO
    (CL:SETQ
     SURROGATE
     (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY *SURROGATE-ARRAY*) CURSOR))
    (CL:WHEN
     (CL:AND
      (CL:NOT (CL:EQ SURROGATE NULL))
      (CL:EQ
       (MEMBER?
        MODULES
        (CAST
         (CLSYS-SVAL SURROGATE HOME-CONTEXT SURROGATE)
         SGT-API-SUPPORT-MODULE))
       1))
     (CL:SETQ VALUE (CLSYS-SVAL SURROGATE SURROGATE-VALUE SURROGATE))
     (CL:WHEN
      (CL:NOT (CL:EQ VALUE NULL))
      (CL:LET*
       ((VALUE-001 VALUE))
       (CL:COND
        ((CL:EQ (TAXONOMY-ISA? VALUE SGT-API-SUPPORT-LOGIC-OBJECT) 1)
         (CL:LET*
          ((VALUE NULL))
          (CL:SETQ VALUE VALUE-001)
          (CL:WHEN
           (CL:AND
            (CL:EQ (DELETED? VALUE) 0)
            (CL:EQ
             SURROGATE
             (DYNAMIC-SLOT-VALUE
              VALUE
              SYM-API-SUPPORT-SURROGATE-VALUE-INVERSE
              NULL))
            (CL:EQ
             (MEMBER? MODULES (CLSYS-SVAL LOGIC-OBJECT HOME-CONTEXT VALUE))
             1))
           (CL:SETF (CLSYS-SVAL ALL-PURPOSE-ITERATOR VALUE SELF) VALUE)
           (CL:SETF
            (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-INTEGER SELF)
            (CL:1+ CURSOR))
           (CL:RETURN-FROM ALL-NAMED-TERMS-NEXT? TRUE))))
        (CL:T NULL)))))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   (CL:RETURN-FROM ALL-NAMED-TERMS-NEXT? FALSE))
  :VOID)

;;; (DEFUN (ALL-NAMED-TERMS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-NAMED-TERMS (MODULE LOCAL?)
  "Iterate over all named terms visible from `module'.  A term can be an
instance (or individual) as well as a description.  Only terms that
haven't been deleted will be considered.  If `local?', only return 
terms created locally in `module'."
  (CL:RETURN-FROM
   ALL-NAMED-TERMS
   (ALLOCATE-ALL-META-OBJECTS-ITERATOR
    (CL:1+
     (CLSYS-SVAL EXTENSIBLE-SYMBOL-ARRAY TOP-SYMBOL-OFFSET *SURROGATE-ARRAY*))
    (CL:FUNCTION ALL-NAMED-TERMS-NEXT?)
    MODULE
    LOCAL?))
  :VOID)

;;; (DEFUN (ALL-TERMS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-TERMS (MODULE LOCAL?)
  "Iterate over all terms visible from `module'.  A term can be an
instance (or individual) as well as a description.  Only terms that
haven't been deleted will be considered.  If `local?', only return 
terms created locally in `module'."
  (CL:RETURN-FROM
   ALL-TERMS
   (CONCATENATE
    (ALL-NAMED-TERMS MODULE LOCAL?)
    (ALL-UNNAMED-TERMS MODULE LOCAL?)))
  :VOID)

;;; (DEFUN (FILTER-INSTANCE? BOOLEAN) ...)

(CL:DEFUN FILTER-INSTANCE? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM
   FILTER-INSTANCE?
   (CL:IF (CL:EQ (ISA? SELF SGT-API-SUPPORT-DESCRIPTION) 0) TRUE FALSE))
  :VOID)

;;; (DEFUN (ALL-NAMED-INSTANCES (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-NAMED-INSTANCES (MODULE LOCAL?)
  "Iterate over all named instances (or individuals) visible from `module'.
Only instances that haven't been deleted will be considered.  If `local?',
only return instances created locally in `module'."
  (CL:LET*
   ((SELF-001 (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NESTED-ITERATOR SELF-001)
    (ALL-NAMED-TERMS MODULE LOCAL?))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-NEXT-CODE SELF-001)
    (CL:FUNCTION FILTERED-NESTED-ITERATOR-NEXT?))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE SELF-001)
    (CL:FUNCTION FILTER-INSTANCE?))
   (CL:LET*
    ((VALUE-001 SELF-001))
    (CL:RETURN-FROM ALL-NAMED-INSTANCES VALUE-001)))
  :VOID)

;;; (DEFUN (ALL-INSTANCES (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-INSTANCES (MODULE LOCAL?)
  "Iterate over all instances (or individuals) visible from `module'.
Only instances that haven't been deleted will be considered.  If `local?',
only return instances created locally in `module'."
  (CL:LET*
   ((ITERATOR
     (CAST (ALL-TERMS MODULE LOCAL?) SGT-API-SUPPORT-ALL-PURPOSE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL ALL-PURPOSE-ITERATOR ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-INSTANCE?))
   (CL:RETURN-FROM ALL-INSTANCES ITERATOR))
  :VOID)

;;; (DEFUN (STRING-TO-LOGIC-OBJECT LOGIC-OBJECT) ...)

(CL:DEFUN STRING-TO-LOGIC-OBJECT (STRING)
  (CL:LET*
   ((SGT NULL) (ITER-001 (ALL-SURROGATES NULL FALSE)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITER-001) 1)
    DO
    (CL:PROGN
     (CL:SETQ
      SGT
      (CAST (CLSYS-SVAL ITERATOR VALUE ITER-001) SGT-API-SUPPORT-SURROGATE)))
    (CL:WHEN
     (CL:AND
      (CL:EQ (STRING-EQL? (CLSYS-SVAL SURROGATE SYMBOL-NAME SGT) STRING) 1)
      (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT) NULL))
      (CL:EQ
       (ISA?
        (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT)
        SGT-API-SUPPORT-LOGIC-OBJECT)
       1))
     (CL:RETURN-FROM
      STRING-TO-LOGIC-OBJECT
      (CAST
       (CLSYS-SVAL SURROGATE SURROGATE-VALUE SGT)
       SGT-API-SUPPORT-LOGIC-OBJECT)))))
  (CL:RETURN-FROM STRING-TO-LOGIC-OBJECT NULL)
  :VOID)

(CL:DEFUN STARTUP-API-SUPPORT ()
  (CL:LET*
   ((*MODULE* (GET-MODULE "/LOGIC" TRUE)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SGT-API-SUPPORT-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-API-SUPPORT-LOGIC-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
    (CL:SETQ
     SGT-API-SUPPORT-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-API-SUPPORT-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
    (CL:SETQ
     SGT-API-SUPPORT-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-API-SUPPORT-NESTED-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NESTED-ITERATOR" NULL 0))
    (CL:SETQ
     SGT-API-SUPPORT-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "ITERATOR"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-API-SUPPORT-SLOT-VALUE-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-VALUE-ITERATOR" NULL 1))
    (CL:SETQ
     SGT-API-SUPPORT-SLOTREF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTREF" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-API-SUPPORT-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-API-SUPPORT-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-API-SUPPORT-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
    (CL:SETQ
     SYM-API-SUPPORT-SURROGATE-VALUE-INVERSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE-INVERSE" NULL 0))
    (CL:SETQ
     SGT-API-SUPPORT-SURROGATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "SURROGATE"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-API-SUPPORT-RELATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "RELATION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-API-SUPPORT-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
    (CL:SETQ
     SYM-API-SUPPORT-DEFINITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINITION" NULL 0))
    (CL:SETQ
     SGT-API-SUPPORT-PATTERN-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
    (CL:SETQ
     SGT-API-SUPPORT-SKOLEM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
    (CL:SETQ
     SGT-API-SUPPORT-ALL-PURPOSE-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "ALL-PURPOSE-ITERATOR"
      (GET-MODULE "/STELLA" TRUE)
      1)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 5) 1)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "SLOT-VALUE-ITERATOR"
        "(DEFCLASS SLOT-VALUE-ITERATOR (DICTIONARY-ITERATOR) :PARAMETERS ((ANY-VALUE :TYPE OBJECT) (ANY-KEY :TYPE OBJECT)) :SLOTS ((NESTED-ITERATOR :TYPE ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SLOT-VALUE-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SLOT-VALUE-ITERATOR-SLOT-VALUE))))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTERED-TYPES-TO-CLASSES-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (FILTERED-TYPES-TO-CLASSES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTERED-TYPES-TO-CLASSES-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTERED-TYPES-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (FILTERED-TYPES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTERED-TYPES-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-TYPES-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (GET-TYPES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-TYPES-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASS-NAMES-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (CLASS-NAMES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASS-NAMES-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECT-SUBTYPES"
        "TYPE"
        "(DEFUN COLLECT-SUBTYPES ((TYPE TYPE) (RESULT LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECT-SUBTYPES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "SLOT-VALUE-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF SLOT-VALUE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-PROPOSITIONS-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (ALL-PROPOSITIONS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-PROPOSITIONS-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-PROPOSITIONS"
        "MODULE"
        "(DEFUN (ALL-PROPOSITIONS (ITERATOR OF PROPOSITION)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all conceived propositions visible from `module'.
Only propositions that haven't been deleted will be considered.
If `local?', only return propositions conceived locally in `module'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-PROPOSITIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VISIBLE-TERM?"
        "LOGIC-OBJECT"
        "(DEFUN (VISIBLE-TERM? BOOLEAN) ((TERM LOGIC-OBJECT) (CONTEXT CONTEXT) (LOCAL? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VISIBLE-TERM?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TERM-LINKED-TO-VISIBLE-SURROGATE?"
        "LOGIC-OBJECT"
        "(DEFUN (TERM-LINKED-TO-VISIBLE-SURROGATE? BOOLEAN) ((TERM LOGIC-OBJECT) (CONTEXT CONTEXT) (LOCAL? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TERM-LINKED-TO-VISIBLE-SURROGATE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-UNNAMED-TERMS"
        "MODULE"
        "(DEFUN (ALL-UNNAMED-TERMS (ITERATOR OF LOGIC-OBJECT)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all unnamed terms visible from `module'.  A term can be
an instance (or individual) as well as a description.  Only terms that
haven't been deleted will be considered.  If `local?', only return
terms created locally in `module'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-UNNAMED-TERMS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-NAMED-TERMS-NEXT?"
        "ALL-PURPOSE-ITERATOR"
        "(DEFUN (ALL-NAMED-TERMS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-NAMED-TERMS-NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-NAMED-TERMS"
        "MODULE"
        "(DEFUN (ALL-NAMED-TERMS (ITERATOR OF LOGIC-OBJECT)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all named terms visible from `module'.  A term can be an
instance (or individual) as well as a description.  Only terms that
haven't been deleted will be considered.  If `local?', only return 
terms created locally in `module'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-NAMED-TERMS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-TERMS"
        "MODULE"
        "(DEFUN (ALL-TERMS (ITERATOR OF LOGIC-OBJECT)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all terms visible from `module'.  A term can be an
instance (or individual) as well as a description.  Only terms that
haven't been deleted will be considered.  If `local?', only return 
terms created locally in `module'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-TERMS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FILTER-INSTANCE?"
        "LOGIC-OBJECT"
        "(DEFUN (FILTER-INSTANCE? BOOLEAN) ((SELF LOGIC-OBJECT) (ITERATOR ALL-PURPOSE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FILTER-INSTANCE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-NAMED-INSTANCES"
        "MODULE"
        "(DEFUN (ALL-NAMED-INSTANCES (ITERATOR OF LOGIC-OBJECT)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all named instances (or individuals) visible from `module'.
Only instances that haven't been deleted will be considered.  If `local?',
only return instances created locally in `module'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-NAMED-INSTANCES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-INSTANCES"
        "MODULE"
        "(DEFUN (ALL-INSTANCES (ITERATOR OF LOGIC-OBJECT)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all instances (or individuals) visible from `module'.
Only instances that haven't been deleted will be considered.  If `local?',
only return instances created locally in `module'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-INSTANCES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STRING-TO-LOGIC-OBJECT"
        "STRING"
        "(DEFUN (STRING-TO-LOGIC-OBJECT LOGIC-OBJECT) ((STRING STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STRING-TO-LOGIC-OBJECT)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-API-SUPPORT"
     NULL
     "(DEFUN STARTUP-API-SUPPORT ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (INSERT-AT
     *STRING-TO-OBJECT-FUNCTIONS*
     SGT-API-SUPPORT-LOGIC-OBJECT
     (WRAP-LITERAL (CL:FUNCTION STRING-TO-LOGIC-OBJECT)))))
  :VOID)
