;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997                   | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-KIF-IN-PARSE-TREE NULL)
(CL:DEFVAR SGT-KIF-IN-SYMBOL NULL)
(CL:DEFVAR SGT-KIF-IN-CONS NULL)
(CL:DEFVAR SYM-KIF-IN-ISA NULL)
(CL:DEFVAR SGT-KIF-IN-UNKNOWN NULL)
(CL:DEFVAR SYM-KIF-IN-COMMA NULL)
(CL:DEFVAR SYM-KIF-IN-THE-ONLY NULL)
(CL:DEFVAR SYM-KIF-IN-WHERE NULL)
(CL:DEFVAR SYM-KIF-IN-TRUE NULL)
(CL:DEFVAR SYM-KIF-IN-AND NULL)
(CL:DEFVAR SYM-KIF-IN-<= NULL)
(CL:DEFVAR SYM-KIF-IN-IMPLIES NULL)
(CL:DEFVAR SYM-KIF-IN-ALWAYS NULL)
(CL:DEFVAR SYM-KIF-IN-+ NULL)
(CL:DEFVAR SYM-KIF-IN-PLUS NULL)
(CL:DEFVAR SYM-KIF-IN-- NULL)
(CL:DEFVAR SYM-KIF-IN-MINUS NULL)
(CL:DEFVAR SYM-KIF-IN-* NULL)
(CL:DEFVAR SYM-KIF-IN-TIMES NULL)
(CL:DEFVAR SYM-KIF-IN-/ NULL)
(CL:DEFVAR SYM-KIF-IN-DIVIDE NULL)
(CL:DEFVAR SYM-KIF-IN-> NULL)
(CL:DEFVAR SYM-KIF-IN-GREATER-THAN? NULL)
(CL:DEFVAR SYM-KIF-IN->= NULL)
(CL:DEFVAR SYM-KIF-IN-GREATER-OR-EQUAL? NULL)
(CL:DEFVAR SYM-KIF-IN-< NULL)
(CL:DEFVAR SYM-KIF-IN-LESS-THAN? NULL)
(CL:DEFVAR SYM-KIF-IN-=< NULL)
(CL:DEFVAR SYM-KIF-IN-LESS-OR-EQUAL? NULL)
(CL:DEFVAR SYM-KIF-IN-SUBSET NULL)
(CL:DEFVAR SYM-KIF-IN-SUBSET-OF NULL)
(CL:DEFVAR SYM-KIF-IN-MEMBER NULL)
(CL:DEFVAR SYM-KIF-IN-OR NULL)
(CL:DEFVAR SYM-KIF-IN-NOT NULL)
(CL:DEFVAR SYM-KIF-IN-=> NULL)
(CL:DEFVAR SYM-KIF-IN-EXISTS NULL)
(CL:DEFVAR SYM-KIF-IN-FORALL NULL)
(CL:DEFVAR SYM-KIF-IN-IN NULL)
(CL:DEFVAR SYM-KIF-IN-THE NULL)
(CL:DEFVAR SYM-KIF-IN-SETOFALL NULL)
(CL:DEFVAR SYM-KIF-IN-KAPPA NULL)
(CL:DEFVAR SYM-KIF-IN-TOKEN-NAME NULL)
(CL:DEFVAR SYM-KIF-IN-TOKEN-TYPE NULL)
(CL:DEFVAR SGT-KIF-IN-TYPE-SPEC NULL)
(CL:DEFVAR SGT-KIF-IN-VARIABLE-TOKEN NULL)
(CL:DEFVAR SGT-KIF-IN-CLASS NULL)
(CL:DEFVAR SYM-KIF-IN-FALSE NULL)
(CL:DEFVAR SYM-KIF-IN-AS NULL)
(CL:DEFVAR SYM-KIF-IN-*TYPEBECAMENARROWER?* NULL)
(CL:DEFVAR SGT-KIF-IN-TYPE NULL)
(CL:DEFVAR SYM-KIF-IN-= NULL)
(CL:DEFVAR KWD-KIF-IN-KIF NULL)
(CL:DEFVAR SYM-KIF-IN-*LOGIC-DIALECT* NULL)
(CL:DEFVAR KWD-KIF-IN-STELLA NULL)
(CL:DEFVAR KWD-KIF-IN-PREFIX-STELLA NULL)
(CL:DEFVAR KWD-KIF-IN-SQL NULL)
(CL:DEFVAR SYM-KIF-IN-IN-DIALECT NULL)
(CL:DEFVAR KWD-KIF-IN-COMMON-LISP NULL)
(CL:DEFVAR KWD-KIF-IN-FUNCTION NULL)

;;; Forward declarations:

(CL:DECLAIM (CL:SPECIAL *MODULE* STANDARD-OUTPUT EOL *THE-PARSING-ERROR*))

;;; (DEFUN (QUESTION-MARK-SYMBOL? BOOLEAN) ...)

(CL:DEFUN QUESTION-MARK-SYMBOL? (SYMBOL)
  (CL:RETURN-FROM
   QUESTION-MARK-SYMBOL?
   (EQ? (CL:CHAR (CLSYS-SVAL SYMBOL SYMBOL-NAME SYMBOL) 0) #\?))
  :VOID)

;;; (DEFUN (REMOVE-QUESTION-MARK SYMBOL) ...)

(CL:DEFUN REMOVE-QUESTION-MARK (QMSYMBOL)
  (CL:RETURN-FROM
   REMOVE-QUESTION-MARK
   (INTERN-SYMBOL
    (SUBSEQUENCE (CLSYS-SVAL SYMBOL SYMBOL-NAME QMSYMBOL) 1 NULL-INTEGER)))
  :VOID)

;;; (DEFUN (KIF-SYMBOL-TO-STELLA-SYMBOL GENERALIZED-SYMBOL) ...)

(CL:DEFUN KIF-SYMBOL-TO-STELLA-SYMBOL (SYMBOL)
  (CL:IF
   (CL:EQ (QUESTION-MARK-SYMBOL? SYMBOL) 1)
   (CL:RETURN-FROM KIF-SYMBOL-TO-STELLA-SYMBOL SYMBOL)
   (CL:RETURN-FROM KIF-SYMBOL-TO-STELLA-SYMBOL (SURROGATIFY SYMBOL)))
  :VOID)

;;; (DEFUN (KIF-VARIABLE-TO-STELLA-VARIABLE SYMBOL) ...)

(CL:DEFUN KIF-VARIABLE-TO-STELLA-VARIABLE (VARIABLE)
  (CL:LET*
   ((VARIABLE-001 VARIABLE))
   (CL:COND
    ((CL:EQ (SYMBOL? VARIABLE) 1)
     (CL:LET*
      ((VARIABLE NULL))
      (CL:SETQ VARIABLE VARIABLE-001)
      (CL:WHEN
       (CL:EQ (QUESTION-MARK-SYMBOL? VARIABLE) 0)
       (CL:LET*
        ((*PRINTREADABLY?* TRUE))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING
          "PARSING ERROR: Missing question mark on KIF variable: `"
          %%STREAM)
         (PRINT-OBJECT VARIABLE %%STREAM)
         (CL:WRITE-STRING "'." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM))
        (SIGNAL *THE-PARSING-ERROR*))
       (CL:RETURN-FROM KIF-VARIABLE-TO-STELLA-VARIABLE NULL))
      (CL:RETURN-FROM
       KIF-VARIABLE-TO-STELLA-VARIABLE
       (CAST (KIF-SYMBOL-TO-STELLA-SYMBOL VARIABLE) SGT-KIF-IN-SYMBOL))))
    (CL:T
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING
        "PARSING ERROR: Illegal value in KIF expression where symbol expected `"
        %%STREAM)
       (PRINT-OBJECT VARIABLE %%STREAM)
       (CL:WRITE-STRING "'." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (SIGNAL *THE-PARSING-ERROR*))
     (CL:RETURN-FROM KIF-VARIABLE-TO-STELLA-VARIABLE NULL))))
  :VOID)

;;; (DEFUN (KIF-VARIABLE-DECLARATION? BOOLEAN) ...)

(CL:DEFUN KIF-VARIABLE-DECLARATION? (TREE)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:WHEN
       (CL:AND
        (CL:= (LENGTH TREE) 2)
        (CL:EQ (SYMBOL? (FIRST TREE)) 1)
        (CL:EQ
         (QUESTION-MARK-SYMBOL? (CAST (FIRST TREE) SGT-KIF-IN-SYMBOL))
         1)
        (CL:EQ (SYMBOL? (SECOND TREE)) 1)
        (CL:EQ
         (QUESTION-MARK-SYMBOL? (CAST (SECOND TREE) SGT-KIF-IN-SYMBOL))
         0))
       (CL:RETURN-FROM KIF-VARIABLE-DECLARATION? TRUE))))
    ((CL:EQ (SYMBOL? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:WHEN
       (CL:EQ (QUESTION-MARK-SYMBOL? TREE) 1)
       (CL:RETURN-FROM KIF-VARIABLE-DECLARATION? TRUE))))
    (CL:T (CL:RETURN-FROM KIF-VARIABLE-DECLARATION? FALSE))))
  (CL:RETURN-FROM KIF-VARIABLE-DECLARATION? FALSE)
  :VOID)

;;; (DEFUN (LISTIFY-KIF-VARIABLE-DECLARATIONS CONS) ...)

(CL:DEFUN LISTIFY-KIF-VARIABLE-DECLARATIONS (TREE)
  (CL:IF
   (CL:EQ (KIF-VARIABLE-DECLARATION? TREE) 1)
   (CL:RETURN-FROM LISTIFY-KIF-VARIABLE-DECLARATIONS (CONS TREE NIL))
   (CL:RETURN-FROM
    LISTIFY-KIF-VARIABLE-DECLARATIONS
    (CAST TREE SGT-KIF-IN-CONS)))
  :VOID)

;;; (DEFUN (KIF-VARIABLE-DECLARATION-TO-STELLA CONS) ...)

(CL:DEFUN KIF-VARIABLE-DECLARATION-TO-STELLA (TREE)
  (CL:WHEN
   (CL:EQ (KIF-VARIABLE-DECLARATION? TREE) 0)
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING
      "PARSING ERROR: Illegal KIF variable declaration: `"
      %%STREAM)
     (PRINT-OBJECT TREE %%STREAM)
     (CL:WRITE-STRING "'." %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (SIGNAL *THE-PARSING-ERROR*))
   (CL:RETURN-FROM
    KIF-VARIABLE-DECLARATION-TO-STELLA
    (CAST TREE SGT-KIF-IN-CONS)))
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (FIRST-SETTER TREE (KIF-VARIABLE-TO-STELLA-VARIABLE (FIRST TREE)))
      (SECOND-SETTER TREE (TYPIFY (SECOND TREE)))
      (CL:RETURN-FROM
       KIF-VARIABLE-DECLARATION-TO-STELLA
       (CONS SYM-KIF-IN-ISA (CONCATENATE TREE NIL)))))
    (CL:T
     (CL:RETURN-FROM
      KIF-VARIABLE-DECLARATION-TO-STELLA
      (LIST*
       SYM-KIF-IN-ISA
       (KIF-VARIABLE-TO-STELLA-VARIABLE TREE)
       (CONS SGT-KIF-IN-UNKNOWN NIL))))))
  :VOID)

;;; (DEFUN (KIF-VARIABLE-DECLARATIONS-TO-STELLA CONS) ...)

(CL:DEFUN KIF-VARIABLE-DECLARATIONS-TO-STELLA (TREE)
  (CL:LET*
   ((IT (ALLOCATE-ITERATOR TREE)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? IT) 1)
    DO
    (VALUE-SETTER
     IT
     (KIF-VARIABLE-DECLARATION-TO-STELLA (CLSYS-SVAL CONS-ITERATOR VALUE IT)))))
  (CL:CASE
   (LENGTH TREE)
   (0 (CL:RETURN-FROM KIF-VARIABLE-DECLARATIONS-TO-STELLA NIL))
   (1
    (CL:RETURN-FROM
     KIF-VARIABLE-DECLARATIONS-TO-STELLA
     (CAST (FIRST TREE) SGT-KIF-IN-CONS)))
   (CL:OTHERWISE
    (CL:RETURN-FROM
     KIF-VARIABLE-DECLARATIONS-TO-STELLA
     (CONS SYM-KIF-IN-COMMA (CONCATENATE TREE NIL)))))
  :VOID)

;;; (DEFUN (KIF-THE-TO-STELLA-THE-ONLY CONS) ...)

(CL:DEFUN KIF-THE-TO-STELLA-THE-ONLY (TREE)
  (CL:SETQ TREE (KIF-SETOFALL-TO-STELLA-SETOFALL TREE))
  (FIRST-SETTER TREE SYM-KIF-IN-THE-ONLY)
  (CL:RETURN-FROM KIF-THE-TO-STELLA-THE-ONLY TREE)
  :VOID)

;;; (DEFUN (KIF-SETOFALL-TO-STELLA-SETOFALL CONS) ...)

(CL:DEFUN KIF-SETOFALL-TO-STELLA-SETOFALL (TREE)
  (CL:WHEN
   (CL:NOT (CL:OR (CL:= (LENGTH TREE) 3) (CL:= (LENGTH TREE) 2)))
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "PARSING ERROR: Illegal `" %%STREAM)
     (PRINT-OBJECT (FIRST TREE) %%STREAM)
     (CL:WRITE-STRING "' tree: `" %%STREAM)
     (PRINT-OBJECT TREE %%STREAM)
     (CL:WRITE-STRING "'." %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (SIGNAL *THE-PARSING-ERROR*))
   (CL:RETURN-FROM KIF-SETOFALL-TO-STELLA-SETOFALL NIL))
  (SECOND-SETTER
   TREE
   (CL:IF
    (CL:EQ (KIF-VARIABLE-DECLARATION? (SECOND TREE)) 1)
    (KIF-VARIABLE-DECLARATION-TO-STELLA (SECOND TREE))
    (KIF-TERM-TO-UNTYPED-STELLA-TERM (SECOND TREE))))
  (CL:WHEN
   (CL:NOT (CL:EQ (THIRD TREE) NULL))
   (THIRD-SETTER
    TREE
    (LIST*
     SYM-KIF-IN-WHERE
     (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE (THIRD TREE))
     NIL)))
  (CL:RETURN-FROM KIF-SETOFALL-TO-STELLA-SETOFALL TREE)
  :VOID)

;;; (DEFUN (KIF-KAPPA-TO-STELLA-KAPPA CONS) ...)

(CL:DEFUN KIF-KAPPA-TO-STELLA-KAPPA (TREE)
  (CL:WHEN
   (CL:< (LENGTH TREE) 2)
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "PARSING ERROR: Illegal KAPPA tree: `" %%STREAM)
     (PRINT-OBJECT TREE %%STREAM)
     (CL:WRITE-STRING "'." %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (SIGNAL *THE-PARSING-ERROR*))
   (CL:RETURN-FROM KIF-KAPPA-TO-STELLA-KAPPA NIL))
  (CL:LET*
   ((SENTENCES (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))))
   (SECOND-SETTER
    TREE
    (KIF-VARIABLE-DECLARATIONS-TO-STELLA
     (LISTIFY-KIF-VARIABLE-DECLARATIONS (SECOND TREE))))
   (CL:LET*
    ((IT (ALLOCATE-ITERATOR SENTENCES)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? IT) 1)
     DO
     (VALUE-SETTER
      IT
      (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
       (CLSYS-SVAL CONS-ITERATOR VALUE IT)))))
   (CL:CASE
    (LENGTH SENTENCES)
    (0
     (CL:SETF
      (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))
      (CONS (LIST* SYM-KIF-IN-WHERE SYM-KIF-IN-TRUE NIL) NIL)))
    (1 (THIRD-SETTER TREE (LIST* SYM-KIF-IN-WHERE (THIRD TREE) NIL)))
    (CL:OTHERWISE
     (CL:SETF
      (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))
      (CONS
       (LIST*
        SYM-KIF-IN-WHERE
        (CONS SYM-KIF-IN-AND (CONCATENATE SENTENCES NIL))
        NIL)
       NIL))))
   (CL:RETURN-FROM KIF-KAPPA-TO-STELLA-KAPPA TREE))
  :VOID)

;;; (DEFUN (KIF-IMPLIES-TO-STELLA-IMPLIES CONS) ...)

(CL:DEFUN KIF-IMPLIES-TO-STELLA-IMPLIES (TREE)
  (CL:WHEN
   (CL:< (LENGTH TREE) 2)
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "PARSING ERROR: Illegal implication tree: `" %%STREAM)
     (PRINT-OBJECT TREE %%STREAM)
     (CL:WRITE-STRING "'." %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (SIGNAL *THE-PARSING-ERROR*))
   (CL:RETURN-FROM KIF-IMPLIES-TO-STELLA-IMPLIES NIL))
  (CL:WHEN
   (CL:EQ (FIRST TREE) SYM-KIF-IN-<=)
   (CL:SETF (CLSYS-SVAL CONS REST TREE) (REVERSE (CLSYS-SVAL CONS REST TREE))))
  (CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS
   (CLSYS-SVAL CONS REST TREE)
   FALSE)
  (FIRST-SETTER TREE SYM-KIF-IN-IMPLIES)
  (CL:CASE
   (LENGTH TREE)
   (2
    (CL:RETURN-FROM
     KIF-IMPLIES-TO-STELLA-IMPLIES
     (CAST (SECOND TREE) SGT-KIF-IN-CONS)))
   (3 (CL:RETURN-FROM KIF-IMPLIES-TO-STELLA-IMPLIES TREE))
   (CL:OTHERWISE
    (CL:SETF
     (CLSYS-SVAL CONS REST TREE)
     (REVERSE (CLSYS-SVAL CONS REST TREE)))
    (CL:SETF
     (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE))
     (CONS
      (CONS
       SYM-KIF-IN-AND
       (CONCATENATE
        (REVERSE (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
        NIL))
      NIL))
    (CL:SETF
     (CLSYS-SVAL CONS REST TREE)
     (REVERSE (CLSYS-SVAL CONS REST TREE)))
    (CL:RETURN-FROM KIF-IMPLIES-TO-STELLA-IMPLIES TREE)))
  :VOID)

;;; (DEFUN (KIF-EXISTS-TO-STELLA-EXISTS CONS) ...)

(CL:DEFUN KIF-EXISTS-TO-STELLA-EXISTS (TREE)
  (CL:WHEN
   (CL:NOT (CL:= (LENGTH TREE) 3))
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "PARSING ERROR: Illegal EXISTS tree: `" %%STREAM)
     (PRINT-OBJECT TREE %%STREAM)
     (CL:WRITE-STRING "'." %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (SIGNAL *THE-PARSING-ERROR*))
   (CL:RETURN-FROM KIF-EXISTS-TO-STELLA-EXISTS NIL))
  (CL:LET*
   ((SENTENCE (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE (THIRD TREE))))
   (SECOND-SETTER
    TREE
    (KIF-VARIABLE-DECLARATIONS-TO-STELLA
     (LISTIFY-KIF-VARIABLE-DECLARATIONS (SECOND TREE))))
   (THIRD-SETTER TREE (LIST* SYM-KIF-IN-WHERE SENTENCE NIL))
   (CL:RETURN-FROM KIF-EXISTS-TO-STELLA-EXISTS TREE))
  :VOID)

;;; (DEFUN (KIF-FORALL-TO-STELLA-FORALL CONS) ...)

(CL:DEFUN KIF-FORALL-TO-STELLA-FORALL (TREE)
  (CL:WHEN
   (CL:NOT (CL:= (LENGTH TREE) 3))
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "PARSING ERROR: Illegal FORALL tree: `" %%STREAM)
     (PRINT-OBJECT TREE %%STREAM)
     (CL:WRITE-STRING "'." %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (SIGNAL *THE-PARSING-ERROR*))
   (CL:RETURN-FROM KIF-FORALL-TO-STELLA-FORALL NIL))
  (CL:LET*
   ((SENTENCE (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE (THIRD TREE))))
   (SECOND-SETTER
    TREE
    (KIF-VARIABLE-DECLARATIONS-TO-STELLA
     (LISTIFY-KIF-VARIABLE-DECLARATIONS (SECOND TREE))))
   (CL:LET*
    ((SENTENCE-001 SENTENCE))
    (CL:COND
     ((CL:EQ (CONS? SENTENCE) 1)
      (CL:LET*
       ((SENTENCE NULL))
       (CL:SETQ SENTENCE SENTENCE-001)
       (CL:LET*
        ((TEST-VALUE-001 (FIRST SENTENCE)))
        (CL:COND
         ((CL:EQ TEST-VALUE-001 SYM-KIF-IN-IMPLIES)
          (THIRD-SETTER TREE (LIST* SYM-KIF-IN-WHERE (SECOND SENTENCE) NIL))
          (CL:SETF
           (CLSYS-SVAL CONS REST (LAST-CONS TREE))
           (CONS (LIST* SYM-KIF-IN-ALWAYS (THIRD SENTENCE) NIL) NIL))
          (FREE-CONS-LIST SENTENCE)
          (CL:RETURN-FROM KIF-FORALL-TO-STELLA-FORALL TREE))
         (CL:T NULL)))))
     (CL:T NULL)))
   (THIRD-SETTER TREE (LIST* SYM-KIF-IN-ALWAYS SENTENCE NIL))
   (CL:RETURN-FROM KIF-FORALL-TO-STELLA-FORALL TREE))
  :VOID)

;;; (DEFUN (KIF-PREDICATE-TO-STELLA-PREDICATE CONS) ...)

(CL:DEFUN KIF-PREDICATE-TO-STELLA-PREDICATE (TREE)
  (CL:LET*
   ((OPERATOR
     (KIF-OPERATOR-TO-INTERNAL-STELLA (CAST (FIRST TREE) SGT-KIF-IN-SYMBOL)))
    (ARGUMENTS (CLSYS-SVAL CONS REST TREE)))
   (FIRST-SETTER TREE OPERATOR)
   (CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS ARGUMENTS TRUE)
   (CL:WHEN
    (CL:AND
     (CL:= (LENGTH ARGUMENTS) 1)
     (CL:NOT (CL:EQ (GET-CLASS OPERATOR FALSE) NULL)))
    (CL:SETQ TREE (CONCATENATE TREE (CONS (TYPIFY OPERATOR) NIL)))
    (FIRST-SETTER TREE SYM-KIF-IN-ISA))
   (CL:RETURN-FROM KIF-PREDICATE-TO-STELLA-PREDICATE TREE))
  :VOID)

;;; (DEFGLOBAL KIF-OPERATOR-TO-INTERNAL-STELLA-TABLE ...)

(CL:DEFVAR KIF-OPERATOR-TO-INTERNAL-STELLA-TABLE NULL
  "Used to encode/decode KIF operators to the internal
version of Stella operators.")

;;; (DEFUN (KIF-OPERATOR-TO-INTERNAL-STELLA SYMBOL) ...)

(CL:DEFUN KIF-OPERATOR-TO-INTERNAL-STELLA (OPERATOR)
  (CL:LET*
   ((NEWOPERATOR (LOOKUP KIF-OPERATOR-TO-INTERNAL-STELLA-TABLE OPERATOR)))
   (CL:RETURN-FROM
    KIF-OPERATOR-TO-INTERNAL-STELLA
    (CL:IF (CL:NOT (CL:EQ NEWOPERATOR NULL)) NEWOPERATOR OPERATOR)))
  :VOID)

;;; (DEFUN (INTERNAL-STELLA-OPERATOR-TO-KIF SYMBOL) ...)

(CL:DEFUN INTERNAL-STELLA-OPERATOR-TO-KIF (OPERATOR)
  (CL:LET*
   ((VALUE NULL)
    (KEY NULL)
    (ITER-001
     (CLSYS-SVAL
      PROPERTY-LIST
      THE-PLIST
      KIF-OPERATOR-TO-INTERNAL-STELLA-TABLE)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:SETQ KEY (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-KIF-IN-SYMBOL))
    (CL:PROGN
     (CL:SETQ
      VALUE
      (CAST
       (CLSYS-SVAL CONS VALUE (CLSYS-SVAL CONS REST ITER-001))
       SGT-KIF-IN-SYMBOL))
     (CL:SETQ
      ITER-001
      (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST ITER-001))))
    (CL:WHEN
     (CL:EQ VALUE OPERATOR)
     (CL:RETURN-FROM INTERNAL-STELLA-OPERATOR-TO-KIF KEY))))
  (CL:RETURN-FROM INTERNAL-STELLA-OPERATOR-TO-KIF OPERATOR)
  :VOID)

;;; (DEFUN CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS ...)

(CL:DEFUN CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS (EXPRESSIONS TERM?)
  (CL:LET*
   ((TERM (ALLOCATE-ITERATOR EXPRESSIONS)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? TERM) 1)
    DO
    (VALUE-SETTER
     TERM
     (CL:IF
      (CL:EQ TERM? 1)
      (KIF-TERM-TO-UNTYPED-STELLA-TERM (CLSYS-SVAL CONS-ITERATOR VALUE TERM))
      (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
       (CLSYS-SVAL CONS-ITERATOR VALUE TERM))))))
  :VOID)

;;; (DEFUN (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE OBJECT) ...)

(CL:DEFUN KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE (TREE)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:LET*
       ((OPERATOR (FIRST TREE)))
       (CL:WHEN
        (CL:EQ (SYMBOL? OPERATOR) 0)
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:WRITE-STRING
           "PARSING ERROR: Bad first argument in KIF sentence: `"
           %%STREAM)
          (PRINT-OBJECT OPERATOR %%STREAM)
          (CL:WRITE-STRING "'." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))
         (SIGNAL *THE-PARSING-ERROR*))
        (CL:RETURN-FROM KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE NULL))
       (CL:COND
        ((CL:EQ OPERATOR SYM-KIF-IN-MEMBER)
         (FIRST-SETTER TREE SYM-KIF-IN-IN)
         (CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS
          (CLSYS-SVAL CONS REST TREE)
          TRUE)
         (CL:RETURN-FROM KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE TREE))
        ((CL:OR
          (CL:EQ OPERATOR SYM-KIF-IN-AND)
          (CL:EQ OPERATOR SYM-KIF-IN-OR)
          (CL:EQ OPERATOR SYM-KIF-IN-NOT))
         (CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS
          (CLSYS-SVAL CONS REST TREE)
          FALSE)
         (CL:RETURN-FROM KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE TREE))
        ((CL:OR (CL:EQ OPERATOR SYM-KIF-IN-=>) (CL:EQ OPERATOR SYM-KIF-IN-<=))
         (CL:RETURN-FROM
          KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
          (KIF-IMPLIES-TO-STELLA-IMPLIES TREE)))
        ((CL:EQ OPERATOR SYM-KIF-IN-EXISTS)
         (CL:RETURN-FROM
          KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
          (KIF-EXISTS-TO-STELLA-EXISTS TREE)))
        ((CL:EQ OPERATOR SYM-KIF-IN-FORALL)
         (CL:RETURN-FROM
          KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
          (KIF-FORALL-TO-STELLA-FORALL TREE)))
        (CL:T
         (CL:RETURN-FROM
          KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
          (KIF-PREDICATE-TO-STELLA-PREDICATE TREE)))))))
    ((CL:EQ (SYMBOL? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:RETURN-FROM
       KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE
       (KIF-SYMBOL-TO-STELLA-SYMBOL TREE))))
    (CL:T (CL:RETURN-FROM KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE TREE))))
  :VOID)

;;; (DEFUN (KIF-TERM-TO-UNTYPED-STELLA-TERM OBJECT) ...)

(CL:DEFUN KIF-TERM-TO-UNTYPED-STELLA-TERM (TREE)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (SYMBOL? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:RETURN-FROM
       KIF-TERM-TO-UNTYPED-STELLA-TERM
       (KIF-SYMBOL-TO-STELLA-SYMBOL TREE))))
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:LET*
       ((OPERATOR (FIRST TREE)))
       (CL:WHEN
        (CL:EQ (SYMBOL? OPERATOR) 0)
        (CL:LET*
         ((*PRINTREADABLY?* TRUE))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (CL:LET
          ((%%STREAM
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          (CL:WRITE-STRING
           "PARSING ERROR: Bad first argument in KIF term: `"
           %%STREAM)
          (PRINT-OBJECT OPERATOR %%STREAM)
          (CL:WRITE-STRING "'." %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM)
          (CL:TERPRI %%STREAM)
          (CL:FORCE-OUTPUT %%STREAM))
         (SIGNAL *THE-PARSING-ERROR*))
        (CL:RETURN-FROM KIF-TERM-TO-UNTYPED-STELLA-TERM NULL))
       (CL:COND
        ((CL:EQ OPERATOR SYM-KIF-IN-THE)
         (CL:RETURN-FROM
          KIF-TERM-TO-UNTYPED-STELLA-TERM
          (KIF-THE-TO-STELLA-THE-ONLY TREE)))
        ((CL:EQ OPERATOR SYM-KIF-IN-SETOFALL)
         (CL:RETURN-FROM
          KIF-TERM-TO-UNTYPED-STELLA-TERM
          (KIF-SETOFALL-TO-STELLA-SETOFALL TREE)))
        ((CL:EQ OPERATOR SYM-KIF-IN-KAPPA)
         (CL:RETURN-FROM
          KIF-TERM-TO-UNTYPED-STELLA-TERM
          (KIF-KAPPA-TO-STELLA-KAPPA TREE)))
        (CL:T
         (FIRST-SETTER
          TREE
          (KIF-OPERATOR-TO-INTERNAL-STELLA (CAST OPERATOR SGT-KIF-IN-SYMBOL)))
         (CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS
          (CLSYS-SVAL CONS REST TREE)
          TRUE)
         (CL:RETURN-FROM KIF-TERM-TO-UNTYPED-STELLA-TERM TREE))))))
    (CL:T (CL:RETURN-FROM KIF-TERM-TO-UNTYPED-STELLA-TERM TREE))))
  :VOID)

;;; (DEFUN (KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION OBJECT) ...)

(CL:DEFUN KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION (TREE)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:LET*
       ((TEST-VALUE-001 (FIRST TREE)))
       (CL:COND
        ((CL:OR
          (CL:EQ TEST-VALUE-001 SYM-KIF-IN-THE)
          (CL:EQ TEST-VALUE-001 SYM-KIF-IN-SETOFALL)
          (CL:EQ TEST-VALUE-001 SYM-KIF-IN-KAPPA))
         (CL:RETURN-FROM
          KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION
          (KIF-TERM-TO-UNTYPED-STELLA-TERM TREE)))
        (CL:T
         (CL:RETURN-FROM
          KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION
          (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE TREE)))))))
    (CL:T
     (CL:RETURN-FROM
      KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION
      (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE TREE)))))
  :VOID)

;;; (DEFCLASS VARIABLE-TOKEN ...)

(CL:DEFCLASS VARIABLE-TOKEN (OBJECT)
  ((TOKEN-NAME :ALLOCATION :INSTANCE :ACCESSOR TOKEN-NAME...OF)
   (TOKEN-TYPE :ALLOCATION :INSTANCE :ACCESSOR TOKEN-TYPE...OF)))

(CL:DEFUN NEW-VARIABLE-TOKEN ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE VARIABLE-TOKEN)))
   (CL:SETF (CLSYS-SVAL VARIABLE-TOKEN TOKEN-TYPE SELF) NULL)
   (CL:SETF (CLSYS-SVAL VARIABLE-TOKEN TOKEN-NAME SELF) NULL)
   (CL:RETURN-FROM NEW-VARIABLE-TOKEN SELF))
  :VOID)

(CL:DEFUN ACCESS-VARIABLE-TOKEN-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-KIF-IN-TOKEN-NAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL VARIABLE-TOKEN TOKEN-NAME SELF)
      (CAST VALUE SGT-KIF-IN-SYMBOL))
     (CL:RETURN-FROM
      ACCESS-VARIABLE-TOKEN-SLOT-VALUE
      (CLSYS-SVAL VARIABLE-TOKEN TOKEN-NAME SELF))))
   ((CL:EQ SLOTNAME SYM-KIF-IN-TOKEN-TYPE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL VARIABLE-TOKEN TOKEN-TYPE SELF)
      (CAST VALUE SGT-KIF-IN-TYPE-SPEC))
     (CL:RETURN-FROM
      ACCESS-VARIABLE-TOKEN-SLOT-VALUE
      (CLSYS-SVAL VARIABLE-TOKEN TOKEN-TYPE SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-VARIABLE-TOKEN-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF VARIABLE-TOKEN))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-KIF-IN-VARIABLE-TOKEN)
  :VOID)

;;; (DEFUN (TOKEN? BOOLEAN) ...)

(CL:DEFUN TOKEN? (OBJECT)
  (CL:RETURN-FROM TOKEN? (ISA? OBJECT SGT-KIF-IN-VARIABLE-TOKEN))
  :VOID)

;;; (DEFGLOBAL *VARIABLE-TOKENS* ...)

(CL:DEFVAR *VARIABLE-TOKENS* NULL
  "List of all variable tokens.")

;;; (DEFGLOBAL *VARIABLE-TOKEN-STACK* ...)

(CL:DEFVAR *VARIABLE-TOKEN-STACK* NULL
  "Stack of variable tokens visible (during parsing) from the
current scope.")

;;; (DEFUN (INTRODUCE-VARIABLE-TOKEN VARIABLE-TOKEN) ...)

(CL:DEFUN INTRODUCE-VARIABLE-TOKEN (SYMBOL TYPETREE)
  (CL:LET*
   ((TOKEN (NEW-VARIABLE-TOKEN)))
   (CL:SETF (CLSYS-SVAL VARIABLE-TOKEN TOKEN-NAME TOKEN) SYMBOL)
   (CL:SETF
    (CLSYS-SVAL VARIABLE-TOKEN TOKEN-TYPE TOKEN)
    (YIELD-TYPE-SPECIFIER TYPETREE))
   (PUSH *VARIABLE-TOKENS* TOKEN)
   (CL:SETF
    (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST *VARIABLE-TOKEN-STACK*)
    (KV-CONS
     SYMBOL
     TOKEN
     (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST *VARIABLE-TOKEN-STACK*)))
   (CL:RETURN-FROM INTRODUCE-VARIABLE-TOKEN TOKEN))
  :VOID)

;;; (DEFUN (FIND-VARIABLE-TOKEN VARIABLE-TOKEN) ...)

(CL:DEFUN FIND-VARIABLE-TOKEN (SYMBOL)
  (CL:LET*
   ((TOKEN (LOOKUP *VARIABLE-TOKEN-STACK* SYMBOL)))
   (CL:WHEN
    (CL:EQ TOKEN NULL)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING "PARSING ERROR: Undeclared variable `" %%STREAM)
      (PRINT-OBJECT SYMBOL %%STREAM)
      (CL:WRITE-STRING "'." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (SIGNAL *THE-PARSING-ERROR*)))
   (CL:RETURN-FROM FIND-VARIABLE-TOKEN TOKEN))
  :VOID)

;;; (DEFUN CLEAR-TOKEN-TABLES ...)

(CL:DEFUN CLEAR-TOKEN-TABLES ()
  (CL:LET*
   ((TOKEN NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST *VARIABLE-TOKENS*)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      TOKEN
      (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-KIF-IN-VARIABLE-TOKEN))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (FREE TOKEN)))
  (CLEAR *VARIABLE-TOKENS*)
  (CLEAR *VARIABLE-TOKEN-STACK*)
  :VOID)

;;; (DEFUN (COMPUTE-TERM-CLASS CLASS) ...)

(CL:DEFUN COMPUTE-TERM-CLASS (TERM)
  (CL:LET*
   ((TERM-001 TERM))
   (CL:COND
    ((CL:EQ (WRAPPER? TERM) 1)
     (CL:LET*
      ((TERM NULL))
      (CL:SETQ TERM TERM-001)
      (CL:RETURN-FROM
       COMPUTE-TERM-CLASS
       (CAST
        (CLSYS-SVAL SURROGATE SURROGATE-VALUE (WRAPPER-VALUE-TYPE TERM))
        SGT-KIF-IN-CLASS))))
    ((CL:EQ (TAXONOMY-ISA? TERM SGT-KIF-IN-VARIABLE-TOKEN) 1)
     (CL:LET*
      ((TERM NULL))
      (CL:SETQ TERM TERM-001)
      (CL:IF
       (CL:EQ (CLSYS-SVAL VARIABLE-TOKEN TOKEN-TYPE TERM) SGT-KIF-IN-UNKNOWN)
       (CL:RETURN-FROM COMPUTE-TERM-CLASS NULL)
       (CL:RETURN-FROM
        COMPUTE-TERM-CLASS
        (CAST
         (CLSYS-SVAL
          SURROGATE
          SURROGATE-VALUE
          (TYPE-SPEC-TO-BASE-TYPE
           (CLSYS-SVAL VARIABLE-TOKEN TOKEN-TYPE TERM)))
         SGT-KIF-IN-CLASS)))))
    ((CL:EQ (SURROGATE? TERM) 1)
     (CL:LET*
      ((TERM NULL))
      (CL:SETQ TERM TERM-001)
      (CL:IF
       (CL:NOT (CL:EQ (CLSYS-SVAL SURROGATE SURROGATE-VALUE TERM) NULL))
       (CL:RETURN-FROM
        COMPUTE-TERM-CLASS
        (PRIMARY-CLASS (CLSYS-SVAL SURROGATE SURROGATE-VALUE TERM)))
       (CL:RETURN-FROM COMPUTE-TERM-CLASS NULL))))
    (CL:T (CL:RETURN-FROM COMPUTE-TERM-CLASS (PRIMARY-CLASS TERM)))))
  :VOID)

;;; (DEFUN (COMPUTE-TERM-SLOT SLOT) ...)

(CL:DEFUN COMPUTE-TERM-SLOT (TERM)
  (CL:WHEN (CL:EQ (SECOND TERM) NULL) (CL:RETURN-FROM COMPUTE-TERM-SLOT NULL))
  (CL:LET*
   ((CLASS (COMPUTE-TERM-CLASS (SECOND TERM))))
   (CL:IF
    (CL:NOT (CL:EQ CLASS NULL))
    (CL:RETURN-FROM
     COMPUTE-TERM-SLOT
     (SAFE-LOOKUP-SLOT CLASS (CAST (FIRST TERM) SGT-KIF-IN-SYMBOL)))
    (CL:RETURN-FROM COMPUTE-TERM-SLOT NULL)))
  :VOID)

;;; (DEFUN SUBSTITUTE-TOKENS-INTO-TERMS ...)

(CL:DEFUN SUBSTITUTE-TOKENS-INTO-TERMS (TERMLIST)
  (CL:LET*
   ((IT (ALLOCATE-ITERATOR TERMLIST)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? IT) 1)
    DO
    (CL:LET*
     ((TERM (CLSYS-SVAL CONS-ITERATOR VALUE IT)))
     (CL:LET*
      ((TERM-001 TERM))
      (CL:COND
       ((CL:EQ (SYMBOL? TERM) 1)
        (CL:LET*
         ((TERM NULL))
         (CL:SETQ TERM TERM-001)
         (CL:COND
          ((CL:OR (CL:EQ TERM SYM-KIF-IN-TRUE) (CL:EQ TERM SYM-KIF-IN-FALSE))
           NULL)
          (CL:T (VALUE-SETTER IT (FIND-VARIABLE-TOKEN TERM))))))
       ((CL:EQ (CONS? TERM) 1)
        (CL:LET*
         ((TERM NULL))
         (CL:SETQ TERM TERM-001)
         (SUBSTITUTE-IN-VARIABLE-TOKENS TERM)))
       (CL:T NULL))))))
  :VOID)

;;; (DEFUN SUBSTITUTE-TOKENS-INTO-VARIABLE-DECLARATIONS ...)

(CL:DEFUN SUBSTITUTE-TOKENS-INTO-VARIABLE-DECLARATIONS (DECLORDECLS)
  (CL:LET*
   ((TEST-VALUE-001 (FIRST DECLORDECLS)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 SYM-KIF-IN-ISA)
     (SECOND-SETTER
      DECLORDECLS
      (INTRODUCE-VARIABLE-TOKEN
       (CAST (SECOND DECLORDECLS) SGT-KIF-IN-SYMBOL)
       (THIRD DECLORDECLS))))
    ((CL:EQ TEST-VALUE-001 SYM-KIF-IN-IN)
     (CL:LET*
      ((SLOT (COMPUTE-TERM-SLOT (CAST (THIRD DECLORDECLS) SGT-KIF-IN-CONS))))
      (CL:WHEN (CL:NOT (CL:EQ SLOT NULL)))))
    ((CL:OR
      (CL:EQ TEST-VALUE-001 SYM-KIF-IN-COMMA)
      (CL:EQ TEST-VALUE-001 SYM-KIF-IN-AS))
     (CL:LET*
      ((DECL NULL) (ITER-001 (CLSYS-SVAL CONS REST DECLORDECLS)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ DECL (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (SUBSTITUTE-TOKENS-INTO-VARIABLE-DECLARATIONS
        (CAST DECL SGT-KIF-IN-CONS)))))
    (CL:T
     (CL:LET*
      ((*PRINTREADABLY?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "PARSING ERROR: Illegal clause headed by `" %%STREAM)
       (PRINT-OBJECT (FIRST DECLORDECLS) %%STREAM)
       (CL:WRITE-STRING
        "' encountered while parsing variable declarations."
        %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING "." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM))
      (SIGNAL *THE-PARSING-ERROR*)))))
  :VOID)

;;; (DEFUN POP-TOKENS-IN-DECLARATIONS ...)

(CL:DEFUN POP-TOKENS-IN-DECLARATIONS (DECLORDECLS)
  (CL:LET*
   ((TEST-VALUE-001 (FIRST DECLORDECLS)))
   (CL:COND
    ((CL:OR
      (CL:EQ TEST-VALUE-001 SYM-KIF-IN-ISA)
      (CL:EQ TEST-VALUE-001 SYM-KIF-IN-IN))
     (POP *VARIABLE-TOKEN-STACK*))
    ((CL:OR
      (CL:EQ TEST-VALUE-001 SYM-KIF-IN-AS)
      (CL:EQ TEST-VALUE-001 SYM-KIF-IN-COMMA))
     (CL:LET*
      ((DECL NULL) (ITER-001 (CLSYS-SVAL CONS REST DECLORDECLS)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ DECL (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (POP-TOKENS-IN-DECLARATIONS (CAST DECL SGT-KIF-IN-CONS)))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
  :VOID)

;;; (DEFUN SUBSTITUTE-IN-VARIABLE-TOKENS ...)

(CL:DEFUN SUBSTITUTE-IN-VARIABLE-TOKENS (TREE)
  (CL:LET*
   ((OPERATOR (CAST (FIRST TREE) SGT-KIF-IN-SYMBOL)))
   (CL:COND
    ((CL:OR
      (CL:EQ OPERATOR SYM-KIF-IN-EXISTS)
      (CL:EQ OPERATOR SYM-KIF-IN-FORALL)
      (CL:EQ OPERATOR SYM-KIF-IN-THE-ONLY)
      (CL:EQ OPERATOR SYM-KIF-IN-SETOFALL)
      (CL:EQ OPERATOR SYM-KIF-IN-KAPPA))
     (SUBSTITUTE-TOKENS-INTO-VARIABLE-DECLARATIONS
      (CAST (SECOND TREE) SGT-KIF-IN-CONS))
     (SUBSTITUTE-TOKENS-INTO-TERMS
      (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
     (POP-TOKENS-IN-DECLARATIONS (CAST (SECOND TREE) SGT-KIF-IN-CONS)))
    (CL:T (SUBSTITUTE-TOKENS-INTO-TERMS (CLSYS-SVAL CONS REST TREE)))))
  :VOID)

;;; (DEFSPECIAL *TYPEBECAMENARROWER?* ...)

(CL:DEFVAR *TYPEBECAMENARROWER?*)

(CL:DEFUN READ-*TYPEBECAMENARROWER?* ()
  (CL:RETURN-FROM READ-*TYPEBECAMENARROWER?* *TYPEBECAMENARROWER?*)
  :VOID)

(CL:DEFUN WRITE-*TYPEBECAMENARROWER?* (VALUE)
  (CL:SETQ *TYPEBECAMENARROWER?* VALUE)
  (CL:RETURN-FROM WRITE-*TYPEBECAMENARROWER?* VALUE)
  :VOID)

;;; (DEFGLOBAL *VISIBLE-TOKEN-STACK* ...)

(CL:DEFVAR *VISIBLE-TOKEN-STACK* NULL
  "Used by 'infer-variable-types?' to determine which
variables can be narrowed by a current predication.")

;;; (DEFUN PUSH-VISIBLE-TOKENS ...)

(CL:DEFUN PUSH-VISIBLE-TOKENS (DECLORDECLS)
  (CL:LET*
   ((TEST-VALUE-001 (FIRST DECLORDECLS)))
   (CL:COND
    ((CL:OR
      (CL:EQ TEST-VALUE-001 SYM-KIF-IN-ISA)
      (CL:EQ TEST-VALUE-001 SYM-KIF-IN-IN))
     (PUSH
      *VISIBLE-TOKEN-STACK*
      (CAST (SECOND DECLORDECLS) SGT-KIF-IN-VARIABLE-TOKEN)))
    ((CL:OR
      (CL:EQ TEST-VALUE-001 SYM-KIF-IN-AS)
      (CL:EQ TEST-VALUE-001 SYM-KIF-IN-COMMA))
     (CL:LET*
      ((DECL NULL) (ITER-001 (CLSYS-SVAL CONS REST DECLORDECLS)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ DECL (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (PUSH-VISIBLE-TOKENS (CAST DECL SGT-KIF-IN-CONS)))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
  :VOID)

;;; (DEFUN POP-VISIBLE-TOKENS ...)

(CL:DEFUN POP-VISIBLE-TOKENS (DECLORDECLS)
  (CL:LET*
   ((TEST-VALUE-001 (FIRST DECLORDECLS)))
   (CL:COND
    ((CL:OR
      (CL:EQ TEST-VALUE-001 SYM-KIF-IN-ISA)
      (CL:EQ TEST-VALUE-001 SYM-KIF-IN-IN))
     (POP *VISIBLE-TOKEN-STACK*))
    ((CL:OR
      (CL:EQ TEST-VALUE-001 SYM-KIF-IN-AS)
      (CL:EQ TEST-VALUE-001 SYM-KIF-IN-COMMA))
     (CL:LET*
      ((DECL NULL) (ITER-001 (CLSYS-SVAL CONS REST DECLORDECLS)))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ DECL (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (POP-VISIBLE-TOKENS (CAST DECL SGT-KIF-IN-CONS)))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
  :VOID)

;;; (DEFGLOBAL BLOCKING-TOKEN ...)

(CL:DEFVAR BLOCKING-TOKEN NULL)

;;; (DEFUN BLOCK-VISIBLE-TOKENS ...)

(CL:DEFUN BLOCK-VISIBLE-TOKENS ()
  (PUSH *VISIBLE-TOKEN-STACK* BLOCKING-TOKEN)
  :VOID)

;;; (DEFUN UNBLOCK-VISIBLE-TOKENS ...)

(CL:DEFUN UNBLOCK-VISIBLE-TOKENS ()
  (POP *VISIBLE-TOKEN-STACK*)
  :VOID)

;;; (DEFUN (ALL-TOKENS-BLOCKED? BOOLEAN) ...)

(CL:DEFUN ALL-TOKENS-BLOCKED? ()
  (CL:RETURN-FROM
   ALL-TOKENS-BLOCKED?
   (EQ? (FIRST *VISIBLE-TOKEN-STACK*) BLOCKING-TOKEN))
  :VOID)

;;; (DEFUN (TOKEN-IS-VISIBLE? BOOLEAN) ...)

(CL:DEFUN TOKEN-IS-VISIBLE? (TOKEN)
  (CL:LET*
   ((VT NULL)
    (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST *VISIBLE-TOKEN-STACK*)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      VT
      (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-KIF-IN-VARIABLE-TOKEN))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:EQ VT BLOCKING-TOKEN)
     (CL:RETURN-FROM TOKEN-IS-VISIBLE? FALSE))
    (CL:WHEN (CL:EQ VT TOKEN) (CL:RETURN-FROM TOKEN-IS-VISIBLE? TRUE))))
  (CL:RETURN-FROM TOKEN-IS-VISIBLE? FALSE)
  :VOID)

;;; (DEFUN UPDATE-TOKEN-TYPE ...)

(CL:DEFUN UPDATE-TOKEN-TYPE (TOKEN TYPE)
  (CL:LET*
   ((OLDTYPE
     (TYPE-SPEC-TO-BASE-TYPE (CLSYS-SVAL VARIABLE-TOKEN TOKEN-TYPE TOKEN))))
   (CL:WHEN
    (CL:OR
     (CL:EQ OLDTYPE SGT-KIF-IN-UNKNOWN)
     (CL:AND
      (CL:EQ (SUBTYPE-OF? TYPE OLDTYPE) 1)
      (CL:NOT (CL:EQ TYPE OLDTYPE))))
    (CL:SETF (CLSYS-SVAL VARIABLE-TOKEN TOKEN-TYPE TOKEN) TYPE)
    (CL:SETQ *TYPEBECAMENARROWER?* TRUE)))
  :VOID)

;;; (DEFUN INFER-VARIABLE-TYPES-WITHIN-TERMS ...)

(CL:DEFUN INFER-VARIABLE-TYPES-WITHIN-TERMS (TERMLIST)
  (CL:LET*
   ((TERM NULL) (ITER-001 TERMLIST))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ TERM (CLSYS-SVAL CONS VALUE ITER-001))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (HELP-INFER-VARIABLE-TYPES TERM)))
  :VOID)

;;; (DEFUN INFER-TYPES-IN-PREDICATION ...)

(CL:DEFUN INFER-TYPES-IN-PREDICATION (PREDICATION)
  (BLOCK-VISIBLE-TOKENS)
  (INFER-VARIABLE-TYPES-WITHIN-TERMS (CLSYS-SVAL CONS REST PREDICATION))
  (UNBLOCK-VISIBLE-TOKENS)
  (CL:WHEN
   (CL:EQ (TOKEN? (LAST PREDICATION)) 0)
   (CL:RETURN-FROM INFER-TYPES-IN-PREDICATION))
  (CL:LET*
   ((TOKEN (CAST (LAST PREDICATION) SGT-KIF-IN-VARIABLE-TOKEN))
    (RELATIONNAME (CAST (FIRST PREDICATION) SGT-KIF-IN-SYMBOL)))
   (CL:WHEN
    (CL:EQ (TOKEN-IS-VISIBLE? TOKEN) 0)
    (CL:RETURN-FROM INFER-TYPES-IN-PREDICATION))
   (CL:CASE
    (LENGTH PREDICATION)
    ((0 1) NULL)
    (CL:OTHERWISE
     (CL:LET*
      ((SLOT (COMPUTE-TERM-SLOT PREDICATION)))
      (CL:WHEN (CL:NOT (CL:EQ SLOT NULL)))))))
  :VOID)

;;; (DEFUN INFER-TYPES-IN-ISA-TERM ...)

(CL:DEFUN INFER-TYPES-IN-ISA-TERM (ISATERM)
  (CL:WHEN
   (CL:EQ (TOKEN? (SECOND ISATERM)) 1)
   (CL:LET*
    ((TOKEN (CAST (SECOND ISATERM) SGT-KIF-IN-VARIABLE-TOKEN))
     (TYPE (CAST (THIRD ISATERM) SGT-KIF-IN-TYPE)))
    (CL:WHEN
     (CL:EQ (TOKEN-IS-VISIBLE? TOKEN) 0)
     (CL:RETURN-FROM INFER-TYPES-IN-ISA-TERM))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (CAST (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE) SGT-KIF-IN-CLASS)
       NULL))
     (UPDATE-TOKEN-TYPE TOKEN TYPE))))
  :VOID)

;;; (DEFUN INFER-TYPES-IN-IN-TERM ...)

(CL:DEFUN INFER-TYPES-IN-IN-TERM (INTERM)
  (CL:WHEN
   (CL:EQ (TOKEN? (SECOND INTERM)) 1)
   (CL:LET*
    ((TOKEN (CAST (SECOND INTERM) SGT-KIF-IN-VARIABLE-TOKEN)) (SLOT NULL))
    (CL:WHEN
     (CL:EQ (TOKEN-IS-VISIBLE? TOKEN) 0)
     (CL:RETURN-FROM INFER-TYPES-IN-IN-TERM))
    (CL:SETQ SLOT (COMPUTE-TERM-SLOT (CAST (THIRD INTERM) SGT-KIF-IN-CONS)))
    (CL:WHEN (CL:NOT (CL:EQ SLOT NULL)))))
  (BLOCK-VISIBLE-TOKENS)
  (HELP-INFER-VARIABLE-TYPES (THIRD INTERM))
  (UNBLOCK-VISIBLE-TOKENS)
  :VOID)

;;; (DEFUN HELP-INFER-EQUAL-TERMS ...)

(CL:DEFUN HELP-INFER-EQUAL-TERMS (TERM1 TERM2)
  (CL:WHEN
   (CL:AND (CL:EQ (TOKEN? TERM1) 1) (CL:EQ (CONS? TERM2) 1))
   (CL:LET*
    ((SLOT (COMPUTE-TERM-SLOT (CAST TERM2 SGT-KIF-IN-CONS))))
    (CL:WHEN
     (CL:NOT (CL:EQ SLOT NULL))
     (UPDATE-TOKEN-TYPE (CAST TERM1 SGT-KIF-IN-VARIABLE-TOKEN) (TYPE SLOT)))))
  :VOID)

;;; (DEFUN INFER-TYPES-IN-EQUAL-TERM ...)

(CL:DEFUN INFER-TYPES-IN-EQUAL-TERM (EQTERM)
  (HELP-INFER-EQUAL-TERMS (SECOND EQTERM) (THIRD EQTERM))
  (HELP-INFER-EQUAL-TERMS (THIRD EQTERM) (SECOND EQTERM))
  (BLOCK-VISIBLE-TOKENS)
  (INFER-VARIABLE-TYPES-WITHIN-TERMS (CLSYS-SVAL CONS REST EQTERM))
  (UNBLOCK-VISIBLE-TOKENS)
  :VOID)

;;; (DEFUN HELP-INFER-VARIABLE-TYPES ...)

(CL:DEFUN HELP-INFER-VARIABLE-TYPES (TREE)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:LET*
       ((OPERATOR (CAST (FIRST TREE) SGT-KIF-IN-SYMBOL)))
       (CL:COND
        ((CL:OR
          (CL:EQ OPERATOR SYM-KIF-IN-EXISTS)
          (CL:EQ OPERATOR SYM-KIF-IN-THE-ONLY)
          (CL:EQ OPERATOR SYM-KIF-IN-SETOFALL)
          (CL:EQ OPERATOR SYM-KIF-IN-KAPPA))
         (PUSH-VISIBLE-TOKENS (CAST (SECOND TREE) SGT-KIF-IN-CONS))
         (HELP-INFER-VARIABLE-TYPES (THIRD TREE))
         (POP-VISIBLE-TOKENS (CAST (SECOND TREE) SGT-KIF-IN-CONS)))
        ((CL:EQ OPERATOR SYM-KIF-IN-FORALL)
         (BLOCK-VISIBLE-TOKENS)
         (PUSH-VISIBLE-TOKENS (CAST (SECOND TREE) SGT-KIF-IN-CONS))
         (INFER-VARIABLE-TYPES-WITHIN-TERMS
          (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST TREE)))
         (POP-VISIBLE-TOKENS (CAST (SECOND TREE) SGT-KIF-IN-CONS))
         (UNBLOCK-VISIBLE-TOKENS))
        ((CL:OR
          (CL:EQ OPERATOR SYM-KIF-IN-AND)
          (CL:EQ OPERATOR SYM-KIF-IN-WHERE))
         (INFER-VARIABLE-TYPES-WITHIN-TERMS (CLSYS-SVAL CONS REST TREE)))
        ((CL:OR
          (CL:EQ OPERATOR SYM-KIF-IN-OR)
          (CL:EQ OPERATOR SYM-KIF-IN-NOT)
          (CL:EQ OPERATOR SYM-KIF-IN-ALWAYS))
         (BLOCK-VISIBLE-TOKENS)
         (INFER-VARIABLE-TYPES-WITHIN-TERMS (CLSYS-SVAL CONS REST TREE))
         (UNBLOCK-VISIBLE-TOKENS))
        ((CL:EQ OPERATOR SYM-KIF-IN-ISA) (INFER-TYPES-IN-ISA-TERM TREE))
        ((CL:EQ OPERATOR SYM-KIF-IN-IN) (INFER-TYPES-IN-IN-TERM TREE))
        ((CL:EQ OPERATOR SYM-KIF-IN-=) (INFER-TYPES-IN-EQUAL-TERM TREE))
        (CL:T (INFER-TYPES-IN-PREDICATION TREE))))))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN INFER-VARIABLE-TYPES ...)

(CL:DEFUN INFER-VARIABLE-TYPES (TREE)
  (CL:LET*
   ((*TYPEBECAMENARROWER?* FALSE))
   (CL:DECLARE (CL:SPECIAL *TYPEBECAMENARROWER?*))
   (CL:LOOP
    (CLEAR *VISIBLE-TOKEN-STACK*)
    (HELP-INFER-VARIABLE-TYPES TREE)
    (CL:WHEN
     (CL:EQ *TYPEBECAMENARROWER?* 0)
     (CL:RETURN-FROM INFER-VARIABLE-TYPES))
    (CL:SETQ *TYPEBECAMENARROWER?* FALSE)))
  :VOID)

;;; (DEFUN (SUBSTITUTE-OUT-VARIABLE-TOKENS OBJECT) ...)

(CL:DEFUN SUBSTITUTE-OUT-VARIABLE-TOKENS (TREE)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? TREE SGT-KIF-IN-VARIABLE-TOKEN) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:RETURN-FROM
       SUBSTITUTE-OUT-VARIABLE-TOKENS
       (CLSYS-SVAL VARIABLE-TOKEN TOKEN-NAME TREE))))
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:LET*
       ((OPERATOR (CAST (FIRST TREE) SGT-KIF-IN-SYMBOL)) (TOKEN NULL))
       (CL:COND
        ((CL:EQ OPERATOR SYM-KIF-IN-ISA)
         (CL:COND
          ((CL:EQ (TOKEN? (SECOND TREE)) 1)
           (CL:SETQ TOKEN (CAST (SECOND TREE) SGT-KIF-IN-VARIABLE-TOKEN))
           (SECOND-SETTER TREE (CLSYS-SVAL VARIABLE-TOKEN TOKEN-NAME TOKEN))
           (CL:WHEN
            (CL:OR
             (CL:EQ SGT-KIF-IN-UNKNOWN (THIRD TREE))
             (CL:AND
              (CL:NOT
               (CL:EQ
                (CAST
                 (CLSYS-SVAL SURROGATE SURROGATE-VALUE (TYPIFY (THIRD TREE)))
                 SGT-KIF-IN-CLASS)
                NULL))
              (CL:EQ
               (SUB-TYPE-SPEC-OF?
                (CLSYS-SVAL VARIABLE-TOKEN TOKEN-TYPE TOKEN)
                (TYPIFY (THIRD TREE)))
               1)))
            (THIRD-SETTER TREE (CLSYS-SVAL VARIABLE-TOKEN TOKEN-TYPE TOKEN))))
          (CL:T
           (CL:LET*
            ((TEST-VALUE-001 (SECOND TREE)))
            (CL:COND
             ((CL:EQ (CONS? TEST-VALUE-001) 1)
              (CL:LET*
               ((IT (ALLOCATE-ITERATOR (CAST (SECOND TREE) SGT-KIF-IN-CONS))))
               (CL:LOOP
                WHILE
                (CL:EQ (NEXT? IT) 1)
                DO
                (VALUE-SETTER
                 IT
                 (SUBSTITUTE-OUT-VARIABLE-TOKENS
                  (CLSYS-SVAL CONS-ITERATOR VALUE IT))))))
             (CL:T (CL:RETURN-FROM SUBSTITUTE-OUT-VARIABLE-TOKENS TREE)))))))
        (CL:T
         (CL:LET*
          ((IT (ALLOCATE-ITERATOR (CLSYS-SVAL CONS REST TREE))))
          (CL:LOOP
           WHILE
           (CL:EQ (NEXT? IT) 1)
           DO
           (VALUE-SETTER
            IT
            (SUBSTITUTE-OUT-VARIABLE-TOKENS
             (CLSYS-SVAL CONS-ITERATOR VALUE IT)))))))
       (CL:RETURN-FROM SUBSTITUTE-OUT-VARIABLE-TOKENS TREE))))
    (CL:T (CL:RETURN-FROM SUBSTITUTE-OUT-VARIABLE-TOKENS TREE))))
  :VOID)

;;; (DEFUN UNTYPED-STELLA-TREE-TO-TYPED-STELLA ...)

(CL:DEFUN UNTYPED-STELLA-TREE-TO-TYPED-STELLA (TREE)
  (CLEAR-TOKEN-TABLES)
  (SUBSTITUTE-IN-VARIABLE-TOKENS TREE)
  (INFER-VARIABLE-TYPES TREE)
  (SUBSTITUTE-OUT-VARIABLE-TOKENS TREE)
  (CL:LET*
   ((UNTYPEDTOKENS? FALSE))
   (CL:LET*
    ((TOKEN NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST *VARIABLE-TOKENS*)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       TOKEN
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-KIF-IN-VARIABLE-TOKEN))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:EQ (CLSYS-SVAL VARIABLE-TOKEN TOKEN-TYPE TOKEN) SGT-KIF-IN-UNKNOWN)
      (CL:SETQ UNTYPEDTOKENS? TRUE))))
   (CL:WHEN (CL:EQ UNTYPEDTOKENS? 1)))
  (CLEAR-TOKEN-TABLES)
  :VOID)

;;; (DEFUN (CONVERT-TO-PREFIX-PROPOSITION-TREE OBJECT) ...)

(CL:DEFUN CONVERT-TO-PREFIX-PROPOSITION-TREE (TREE)
  (CL:LET*
   ((TREE-001 TREE))
   (CL:COND
    ((CL:EQ (CONS? TREE) 1)
     (CL:LET*
      ((TREE NULL))
      (CL:SETQ TREE TREE-001)
      (CL:LET*
       ((OPERATOR (CAST (FIRST TREE) SGT-KIF-IN-SYMBOL)))
       (CL:IF
        (CL:EQ (QUANTIFIER-SYMBOL? OPERATOR) 1)
        (CL:SETQ TREE (INFIX-TO-PREFIX-QUANTIFICATION-TREE TREE))
        (CL:LET*
         ((IT (ALLOCATE-ITERATOR (CLSYS-SVAL CONS REST TREE))))
         (CL:LOOP
          WHILE
          (CL:EQ (NEXT? IT) 1)
          DO
          (CL:WHEN
           (CL:EQ (CONS? (CLSYS-SVAL CONS-ITERATOR VALUE IT)) 1)
           (VALUE-SETTER
            IT
            (CONVERT-TO-PREFIX-PROPOSITION-TREE
             (CLSYS-SVAL CONS-ITERATOR VALUE IT)))))))
       (CL:RETURN-FROM CONVERT-TO-PREFIX-PROPOSITION-TREE TREE))))
    (CL:T (CL:RETURN-FROM CONVERT-TO-PREFIX-PROPOSITION-TREE TREE))))
  :VOID)

;;; (DEFUN (INFIX-TO-PREFIX-QUANTIFICATION-TREE CONS) ...)

(CL:DEFUN INFIX-TO-PREFIX-QUANTIFICATION-TREE (TREE)
  (CL:LET*
   ((QUANTIFIER (FIRST TREE))
    (GENERATORSCLAUSE NULL)
    (WHERECLAUSE NULL)
    (ALWAYSCLAUSE NULL)
    (RESIDUE (CLSYS-SVAL CONS REST TREE))
    (OTREE NULL))
   (FREE-CONS TREE)
   (CL:MULTIPLE-VALUE-SETQ
    (GENERATORSCLAUSE RESIDUE)
    (EXTRACT-GENERATORS-CLAUSE RESIDUE))
   (CL:WHEN
    (CL:EQ GENERATORSCLAUSE NULL)
    (FREE-CONS-TREE RESIDUE)
    (CL:RETURN-FROM INFIX-TO-PREFIX-QUANTIFICATION-TREE NULL))
   (CL:MULTIPLE-VALUE-SETQ
    (WHERECLAUSE RESIDUE)
    (EXTRACT-OPTION-AND-RESIDUE SYM-KIF-IN-WHERE RESIDUE))
   (CL:MULTIPLE-VALUE-SETQ
    (ALWAYSCLAUSE RESIDUE)
    (EXTRACT-OPTION-AND-RESIDUE SYM-KIF-IN-ALWAYS RESIDUE))
   (CL:SETQ
    OTREE
    (CONS
     QUANTIFIER
     (CONS
      (CONVERT-TO-PREFIX-PROPOSITION-TREE GENERATORSCLAUSE)
      (CONCATENATE
       (CL:IF
        (CL:NOT (CL:EQ WHERECLAUSE NULL))
        (CONS
         (LIST*
          SYM-KIF-IN-WHERE
          (CONVERT-TO-PREFIX-PROPOSITION-TREE WHERECLAUSE)
          NIL)
         NIL)
        NIL)
       (CONCATENATE
        (CL:IF
         (CL:NOT (CL:EQ ALWAYSCLAUSE NULL))
         (CONS
          (LIST*
           SYM-KIF-IN-ALWAYS
           (CONVERT-TO-PREFIX-PROPOSITION-TREE ALWAYSCLAUSE)
           NIL)
          NIL)
         NIL)
        NIL)))))
   (CL:WHEN
    (CL:NOT (CL:EQ RESIDUE NIL))
    (FREE-CONS-TREE RESIDUE)
    (FREE-CONS-TREE OTREE)
    (CL:LET*
     ((*PRINTREADABLY?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING
       "PARSING ERROR: Extra expressions at the end of quantified expression."
       %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (SIGNAL *THE-PARSING-ERROR*)))
   (CL:RETURN-FROM INFIX-TO-PREFIX-QUANTIFICATION-TREE OTREE))
  :VOID)

;;; (DEFUN (ACCESS-PREFIX-QUANTIFICATION-CLAUSE OBJECT) ...)

(CL:DEFUN ACCESS-PREFIX-QUANTIFICATION-CLAUSE (PREFIXQUANTIFICATIONTREE CLAUSENAME EXTRACT?)
  (CL:LET*
   ((CLAUSE NULL)
    (CLAUSES
     (CLSYS-SVAL CONS REST (CLSYS-SVAL CONS REST PREFIXQUANTIFICATIONTREE)))
    (THISCLAUSE NULL))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CLAUSES NIL))
    DO
    (CL:SETQ THISCLAUSE (FIRST CLAUSES))
    (CL:LET*
     ((THISCLAUSE-001 THISCLAUSE))
     (CL:COND
      ((CL:EQ (CONS? THISCLAUSE) 1)
       (CL:LET*
        ((THISCLAUSE NULL))
        (CL:SETQ THISCLAUSE THISCLAUSE-001)
        (CL:WHEN
         (CL:EQ (FIRST THISCLAUSE) CLAUSENAME)
         (CL:SETQ CLAUSE (SECOND THISCLAUSE))
         (CL:WHEN
          (CL:EQ EXTRACT? 1)
          (FREE-CONS-LIST THISCLAUSE)
          (FIRST-SETTER CLAUSES NULL))
         (CL:RETURN))))
      (CL:T NULL)))
    (CL:SETQ CLAUSES (CLSYS-SVAL CONS REST CLAUSES)))
   (CL:WHEN (CL:EQ EXTRACT? 1) (REMOVE PREFIXQUANTIFICATIONTREE NULL))
   (CL:RETURN-FROM ACCESS-PREFIX-QUANTIFICATION-CLAUSE CLAUSE))
  :VOID)

;;; (DEFUN (EXTRACT-WHERE-CLAUSE OBJECT) ...)

(CL:DEFUN EXTRACT-WHERE-CLAUSE (PREFIXQUANTIFICATIONTREE)
  (CL:RETURN-FROM
   EXTRACT-WHERE-CLAUSE
   (ACCESS-PREFIX-QUANTIFICATION-CLAUSE
    PREFIXQUANTIFICATIONTREE
    SYM-KIF-IN-WHERE
    TRUE))
  :VOID)

;;; (DEFUN (EXTRACT-ALWAYS-CLAUSE OBJECT) ...)

(CL:DEFUN EXTRACT-ALWAYS-CLAUSE (PREFIXQUANTIFICATIONTREE)
  (CL:RETURN-FROM
   EXTRACT-ALWAYS-CLAUSE
   (ACCESS-PREFIX-QUANTIFICATION-CLAUSE
    PREFIXQUANTIFICATIONTREE
    SYM-KIF-IN-ALWAYS
    TRUE))
  :VOID)

;;; (DEFUN (LOOKUP-WHERE-CLAUSE OBJECT) ...)

(CL:DEFUN LOOKUP-WHERE-CLAUSE (PREFIXQUANTIFICATIONTREE)
  (CL:RETURN-FROM
   LOOKUP-WHERE-CLAUSE
   (ACCESS-PREFIX-QUANTIFICATION-CLAUSE
    PREFIXQUANTIFICATIONTREE
    SYM-KIF-IN-WHERE
    FALSE))
  :VOID)

;;; (DEFUN (LOOKUP-ALWAYS-CLAUSE OBJECT) ...)

(CL:DEFUN LOOKUP-ALWAYS-CLAUSE (PREFIXQUANTIFICATIONTREE)
  (CL:RETURN-FROM
   LOOKUP-ALWAYS-CLAUSE
   (ACCESS-PREFIX-QUANTIFICATION-CLAUSE
    PREFIXQUANTIFICATIONTREE
    SYM-KIF-IN-ALWAYS
    FALSE))
  :VOID)

;;; (DEFSPECIAL *LOGIC-DIALECT* ...)

(CL:DEFVAR *LOGIC-DIALECT* NULL
  "Indicates the current dialect of logic used to phrase
queries, assertions, and definitions.")

(CL:DEFUN READ-*LOGIC-DIALECT* ()
  (CL:RETURN-FROM READ-*LOGIC-DIALECT* *LOGIC-DIALECT*)
  :VOID)

(CL:DEFUN WRITE-*LOGIC-DIALECT* (VALUE)
  (CL:SETQ *LOGIC-DIALECT* VALUE)
  (CL:RETURN-FROM WRITE-*LOGIC-DIALECT* VALUE)
  :VOID)

;;; (DEFUN (STANDARDIZE-LOGICAL-PARSE-TREE OBJECT) ...)

(CL:DEFUN STANDARDIZE-LOGICAL-PARSE-TREE (TREE)
  (CL:LET*
   ((STANDARDIZEDTREE NULL))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* TRUE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:COND
     ((CL:EQ *LOGIC-DIALECT* KWD-KIF-IN-KIF)
      (CL:SETQ
       STANDARDIZEDTREE
       (KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION TREE))
      (CL:WHEN
       (CL:EQ (CONS? STANDARDIZEDTREE) 1)
       (UNTYPED-STELLA-TREE-TO-TYPED-STELLA
        (CAST STANDARDIZEDTREE SGT-KIF-IN-CONS))))
     ((CL:EQ *LOGIC-DIALECT* KWD-KIF-IN-STELLA)
      (CL:SETQ STANDARDIZEDTREE (CONVERT-TO-PREFIX-PROPOSITION-TREE TREE)))
     ((CL:EQ *LOGIC-DIALECT* KWD-KIF-IN-PREFIX-STELLA)
      (CL:SETQ STANDARDIZEDTREE TREE))
     ((CL:EQ *LOGIC-DIALECT* KWD-KIF-IN-SQL) "NOT YET IMPLEMENTED")
     (CL:T (CL:ERROR "`~A' is not a valid case option" *LOGIC-DIALECT*)))
    (CL:RETURN-FROM STANDARDIZE-LOGICAL-PARSE-TREE STANDARDIZEDTREE)))
  :VOID)

;;; (DEFUN (IN-DIALECT KEYWORD) ...)

(CL:DEFUN %%IN-DIALECT (DIALECT)
  "Change the current logic dialect to `dialect'.
Currently supported dialects are `KIF', `STELLA', and `PREFIX-STELLA'.
The STELLA dialects are not recommended for the construction of knowledge
bases, they are mainly used internally by PowerLoom."
  (CL:LET*
   ((DIALECT-001 DIALECT))
   (CL:COND
    ((CL:EQ (SYMBOL? DIALECT) 1)
     (CL:LET*
      ((DIALECT NULL))
      (CL:SETQ DIALECT DIALECT-001)
      (CL:SETQ *LOGIC-DIALECT* (KEYWORDIFY DIALECT))))
    ((CL:EQ (STRING? DIALECT) 1)
     (CL:LET*
      ((DIALECT NULL))
      (CL:SETQ DIALECT DIALECT-001)
      (CL:SETQ
       *LOGIC-DIALECT*
       (KEYWORDIFY (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE DIALECT)))))
    ((CL:EQ (KEYWORD? DIALECT) 1)
     (CL:LET*
      ((DIALECT NULL))
      (CL:SETQ DIALECT DIALECT-001)
      (CL:SETQ *LOGIC-DIALECT* DIALECT)))
    (CL:T (CL:WARN "IN-DIALECT: Illegal dialect specification: `~A'" DIALECT))))
  (CL:RETURN-FROM %%IN-DIALECT *LOGIC-DIALECT*)
  :VOID)

(CL:DEFMACRO IN-DIALECT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Change the current logic dialect to `dialect'.
Currently supported dialects are `KIF', `STELLA', and `PREFIX-STELLA'.
The STELLA dialects are not recommended for the construction of knowledge
bases, they are mainly used internally by PowerLoom."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/IN-DIALECT)) (CL:MACRO-FUNCTION (CL:QUOTE IN-DIALECT)))

(CL:DEFUN STARTUP-KIF-IN ()
  (CL:LET*
   ((*MODULE* (GET-MODULE "/LOGIC" TRUE)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SYM-KIF-IN-PARSE-TREE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARSE-TREE" NULL 0))
    (CL:SETQ
     SGT-KIF-IN-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-KIF-IN-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-KIF-IN-ISA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SGT-KIF-IN-UNKNOWN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-KIF-IN-COMMA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMA" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-THE-ONLY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-ONLY" NULL 0))
    (CL:SETQ
     SYM-KIF-IN-WHERE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WHERE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-TRUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-AND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-<=
     (INTERN-RIGID-SYMBOL-WRT-MODULE "<=" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-IMPLIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 0))
    (CL:SETQ
     SYM-KIF-IN-ALWAYS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALWAYS" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-+
     (INTERN-RIGID-SYMBOL-WRT-MODULE "+" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ SYM-KIF-IN-PLUS (INTERN-RIGID-SYMBOL-WRT-MODULE "PLUS" NULL 0))
    (CL:SETQ
     SYM-KIF-IN--
     (INTERN-RIGID-SYMBOL-WRT-MODULE "-" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ SYM-KIF-IN-MINUS (INTERN-RIGID-SYMBOL-WRT-MODULE "MINUS" NULL 0))
    (CL:SETQ
     SYM-KIF-IN-*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ SYM-KIF-IN-TIMES (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMES" NULL 0))
    (CL:SETQ
     SYM-KIF-IN-/
     (INTERN-RIGID-SYMBOL-WRT-MODULE "/" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-DIVIDE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DIVIDE" NULL 0))
    (CL:SETQ
     SYM-KIF-IN->
     (INTERN-RIGID-SYMBOL-WRT-MODULE ">" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-GREATER-THAN?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GREATER-THAN?" NULL 0))
    (CL:SETQ
     SYM-KIF-IN->=
     (INTERN-RIGID-SYMBOL-WRT-MODULE ">=" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-GREATER-OR-EQUAL?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GREATER-OR-EQUAL?" NULL 0))
    (CL:SETQ
     SYM-KIF-IN-<
     (INTERN-RIGID-SYMBOL-WRT-MODULE "<" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-LESS-THAN?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LESS-THAN?" NULL 0))
    (CL:SETQ
     SYM-KIF-IN-=<
     (INTERN-RIGID-SYMBOL-WRT-MODULE "=<" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-LESS-OR-EQUAL?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LESS-OR-EQUAL?" NULL 0))
    (CL:SETQ
     SYM-KIF-IN-SUBSET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET" NULL 0))
    (CL:SETQ
     SYM-KIF-IN-SUBSET-OF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET-OF" NULL 0))
    (CL:SETQ
     SYM-KIF-IN-MEMBER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER" NULL 0))
    (CL:SETQ
     SYM-KIF-IN-OR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-NOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-=>
     (INTERN-RIGID-SYMBOL-WRT-MODULE "=>" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-EXISTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-FORALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-IN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ SYM-KIF-IN-THE (INTERN-RIGID-SYMBOL-WRT-MODULE "THE" NULL 0))
    (CL:SETQ
     SYM-KIF-IN-SETOFALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOFALL" NULL 0))
    (CL:SETQ SYM-KIF-IN-KAPPA (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
    (CL:SETQ
     SYM-KIF-IN-TOKEN-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TOKEN-NAME" NULL 0))
    (CL:SETQ
     SYM-KIF-IN-TOKEN-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TOKEN-TYPE" NULL 0))
    (CL:SETQ
     SGT-KIF-IN-TYPE-SPEC
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "TYPE-SPEC"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-KIF-IN-VARIABLE-TOKEN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TOKEN" NULL 1))
    (CL:SETQ
     SGT-KIF-IN-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-KIF-IN-FALSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-AS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AS" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-KIF-IN-*TYPEBECAMENARROWER?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*TYPEBECAMENARROWER?*" NULL 0))
    (CL:SETQ
     SGT-KIF-IN-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-KIF-IN-=
     (INTERN-RIGID-SYMBOL-WRT-MODULE "=" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ KWD-KIF-IN-KIF (INTERN-RIGID-SYMBOL-WRT-MODULE "KIF" NULL 2))
    (CL:SETQ
     SYM-KIF-IN-*LOGIC-DIALECT*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*LOGIC-DIALECT*" NULL 0))
    (CL:SETQ
     KWD-KIF-IN-STELLA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA" NULL 2))
    (CL:SETQ
     KWD-KIF-IN-PREFIX-STELLA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PREFIX-STELLA" NULL 2))
    (CL:SETQ KWD-KIF-IN-SQL (INTERN-RIGID-SYMBOL-WRT-MODULE "SQL" NULL 2))
    (CL:SETQ
     SYM-KIF-IN-IN-DIALECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IN-DIALECT" NULL 0))
    (CL:SETQ
     KWD-KIF-IN-COMMON-LISP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
    (CL:SETQ
     KWD-KIF-IN-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:LET*
     ((SELF-041 (NEW-PROPERTY-LIST)))
     (CL:SETF
      (CLSYS-SVAL PROPERTY-LIST THE-PLIST SELF-041)
      (LIST*
       SYM-KIF-IN-+
       SYM-KIF-IN-PLUS
       SYM-KIF-IN--
       SYM-KIF-IN-MINUS
       SYM-KIF-IN-*
       SYM-KIF-IN-TIMES
       SYM-KIF-IN-/
       SYM-KIF-IN-DIVIDE
       SYM-KIF-IN->
       SYM-KIF-IN-GREATER-THAN?
       SYM-KIF-IN->=
       SYM-KIF-IN-GREATER-OR-EQUAL?
       SYM-KIF-IN-<
       SYM-KIF-IN-LESS-THAN?
       SYM-KIF-IN-=<
       SYM-KIF-IN-LESS-OR-EQUAL?
       SYM-KIF-IN-SUBSET
       SYM-KIF-IN-SUBSET-OF
       NIL))
     (CL:SETQ KIF-OPERATOR-TO-INTERNAL-STELLA-TABLE SELF-041))
    (CL:SETQ *VARIABLE-TOKENS* (NEW-LIST))
    (CL:SETQ *VARIABLE-TOKEN-STACK* (NEW-KEY-VALUE-LIST))
    (CL:SETQ *VISIBLE-TOKEN-STACK* (NEW-LIST))
    (CL:SETQ BLOCKING-TOKEN (NEW-VARIABLE-TOKEN))
    (CL:SETQ *LOGIC-DIALECT* KWD-KIF-IN-KIF))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 5) 1)
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE "(DEFTYPE PARSE-TREE OBJECT)")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "VARIABLE-TOKEN"
        "(DEFCLASS VARIABLE-TOKEN (OBJECT) :SLOTS ((TOKEN-NAME :TYPE SYMBOL) (TOKEN-TYPE :TYPE TYPE-SPEC)) :RECYCLE-METHOD :RECYCLE-LIST)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-VARIABLE-TOKEN))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-VARIABLE-TOKEN-SLOT-VALUE))))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "QUESTION-MARK-SYMBOL?"
        "SYMBOL"
        "(DEFUN (QUESTION-MARK-SYMBOL? BOOLEAN) ((SYMBOL SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION QUESTION-MARK-SYMBOL?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REMOVE-QUESTION-MARK"
        "SYMBOL"
        "(DEFUN (REMOVE-QUESTION-MARK SYMBOL) ((QMSYMBOL SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REMOVE-QUESTION-MARK)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-SYMBOL-TO-STELLA-SYMBOL"
        "SYMBOL"
        "(DEFUN (KIF-SYMBOL-TO-STELLA-SYMBOL GENERALIZED-SYMBOL) ((SYMBOL SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-SYMBOL-TO-STELLA-SYMBOL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-VARIABLE-TO-STELLA-VARIABLE"
        "OBJECT"
        "(DEFUN (KIF-VARIABLE-TO-STELLA-VARIABLE SYMBOL) ((VARIABLE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-VARIABLE-TO-STELLA-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-VARIABLE-DECLARATION?"
        "OBJECT"
        "(DEFUN (KIF-VARIABLE-DECLARATION? BOOLEAN) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-VARIABLE-DECLARATION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LISTIFY-KIF-VARIABLE-DECLARATIONS"
        "OBJECT"
        "(DEFUN (LISTIFY-KIF-VARIABLE-DECLARATIONS CONS) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LISTIFY-KIF-VARIABLE-DECLARATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-VARIABLE-DECLARATION-TO-STELLA"
        "OBJECT"
        "(DEFUN (KIF-VARIABLE-DECLARATION-TO-STELLA CONS) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-VARIABLE-DECLARATION-TO-STELLA)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-VARIABLE-DECLARATIONS-TO-STELLA"
        "CONS"
        "(DEFUN (KIF-VARIABLE-DECLARATIONS-TO-STELLA CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-VARIABLE-DECLARATIONS-TO-STELLA)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-THE-TO-STELLA-THE-ONLY"
        "CONS"
        "(DEFUN (KIF-THE-TO-STELLA-THE-ONLY CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-THE-TO-STELLA-THE-ONLY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-SETOFALL-TO-STELLA-SETOFALL"
        "CONS"
        "(DEFUN (KIF-SETOFALL-TO-STELLA-SETOFALL CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-SETOFALL-TO-STELLA-SETOFALL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-KAPPA-TO-STELLA-KAPPA"
        "CONS"
        "(DEFUN (KIF-KAPPA-TO-STELLA-KAPPA CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-KAPPA-TO-STELLA-KAPPA)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-IMPLIES-TO-STELLA-IMPLIES"
        "CONS"
        "(DEFUN (KIF-IMPLIES-TO-STELLA-IMPLIES CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-IMPLIES-TO-STELLA-IMPLIES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-EXISTS-TO-STELLA-EXISTS"
        "CONS"
        "(DEFUN (KIF-EXISTS-TO-STELLA-EXISTS CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-EXISTS-TO-STELLA-EXISTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-FORALL-TO-STELLA-FORALL"
        "CONS"
        "(DEFUN (KIF-FORALL-TO-STELLA-FORALL CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-FORALL-TO-STELLA-FORALL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-PREDICATE-TO-STELLA-PREDICATE"
        "CONS"
        "(DEFUN (KIF-PREDICATE-TO-STELLA-PREDICATE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-PREDICATE-TO-STELLA-PREDICATE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-OPERATOR-TO-INTERNAL-STELLA"
        "SYMBOL"
        "(DEFUN (KIF-OPERATOR-TO-INTERNAL-STELLA SYMBOL) ((OPERATOR SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-OPERATOR-TO-INTERNAL-STELLA)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INTERNAL-STELLA-OPERATOR-TO-KIF"
        "SYMBOL"
        "(DEFUN (INTERNAL-STELLA-OPERATOR-TO-KIF SYMBOL) ((OPERATOR SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INTERNAL-STELLA-OPERATOR-TO-KIF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS"
        "CONS"
        "(DEFUN CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS ((EXPRESSIONS CONS) (TERM? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CHANGE-KIF-EXPRESSIONS-TO-STELLA-EXPRESSIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE"
        "OBJECT"
        "(DEFUN (KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE OBJECT) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-SENTENCE-TO-UNTYPED-STELLA-SENTENCE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-TERM-TO-UNTYPED-STELLA-TERM"
        "OBJECT"
        "(DEFUN (KIF-TERM-TO-UNTYPED-STELLA-TERM OBJECT) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-TERM-TO-UNTYPED-STELLA-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION"
        "OBJECT"
        "(DEFUN (KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION OBJECT) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION KIF-EXPRESSION-TO-UNTYPED-STELLA-EXPRESSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TOKEN?"
        "OBJECT"
        "(DEFUN (TOKEN? BOOLEAN) ((OBJECT OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TOKEN?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INTRODUCE-VARIABLE-TOKEN"
        "SYMBOL"
        "(DEFUN (INTRODUCE-VARIABLE-TOKEN VARIABLE-TOKEN) ((SYMBOL SYMBOL) (TYPETREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INTRODUCE-VARIABLE-TOKEN)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-VARIABLE-TOKEN"
        "SYMBOL"
        "(DEFUN (FIND-VARIABLE-TOKEN VARIABLE-TOKEN) ((SYMBOL SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-VARIABLE-TOKEN)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR-TOKEN-TABLES"
        NULL
        "(DEFUN CLEAR-TOKEN-TABLES ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLEAR-TOKEN-TABLES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-TERM-CLASS"
        "OBJECT"
        "(DEFUN (COMPUTE-TERM-CLASS CLASS) ((TERM OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-TERM-CLASS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-TERM-SLOT"
        "CONS"
        "(DEFUN (COMPUTE-TERM-SLOT SLOT) ((TERM CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-TERM-SLOT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBSTITUTE-TOKENS-INTO-TERMS"
        "CONS"
        "(DEFUN SUBSTITUTE-TOKENS-INTO-TERMS ((TERMLIST CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SUBSTITUTE-TOKENS-INTO-TERMS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBSTITUTE-TOKENS-INTO-VARIABLE-DECLARATIONS"
        "CONS"
        "(DEFUN SUBSTITUTE-TOKENS-INTO-VARIABLE-DECLARATIONS ((DECLORDECLS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SUBSTITUTE-TOKENS-INTO-VARIABLE-DECLARATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POP-TOKENS-IN-DECLARATIONS"
        "CONS"
        "(DEFUN POP-TOKENS-IN-DECLARATIONS ((DECLORDECLS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION POP-TOKENS-IN-DECLARATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBSTITUTE-IN-VARIABLE-TOKENS"
        "CONS"
        "(DEFUN SUBSTITUTE-IN-VARIABLE-TOKENS ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SUBSTITUTE-IN-VARIABLE-TOKENS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PUSH-VISIBLE-TOKENS"
        "CONS"
        "(DEFUN PUSH-VISIBLE-TOKENS ((DECLORDECLS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PUSH-VISIBLE-TOKENS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POP-VISIBLE-TOKENS"
        "CONS"
        "(DEFUN POP-VISIBLE-TOKENS ((DECLORDECLS CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION POP-VISIBLE-TOKENS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BLOCK-VISIBLE-TOKENS"
        NULL
        "(DEFUN BLOCK-VISIBLE-TOKENS ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BLOCK-VISIBLE-TOKENS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNBLOCK-VISIBLE-TOKENS"
        NULL
        "(DEFUN UNBLOCK-VISIBLE-TOKENS ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNBLOCK-VISIBLE-TOKENS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-TOKENS-BLOCKED?"
        NULL
        "(DEFUN (ALL-TOKENS-BLOCKED? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-TOKENS-BLOCKED?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TOKEN-IS-VISIBLE?"
        "VARIABLE-TOKEN"
        "(DEFUN (TOKEN-IS-VISIBLE? BOOLEAN) ((TOKEN VARIABLE-TOKEN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TOKEN-IS-VISIBLE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UPDATE-TOKEN-TYPE"
        "VARIABLE-TOKEN"
        "(DEFUN UPDATE-TOKEN-TYPE ((TOKEN VARIABLE-TOKEN) (TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UPDATE-TOKEN-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INFER-VARIABLE-TYPES-WITHIN-TERMS"
        "CONS"
        "(DEFUN INFER-VARIABLE-TYPES-WITHIN-TERMS ((TERMLIST CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INFER-VARIABLE-TYPES-WITHIN-TERMS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INFER-TYPES-IN-PREDICATION"
        "CONS"
        "(DEFUN INFER-TYPES-IN-PREDICATION ((PREDICATION CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INFER-TYPES-IN-PREDICATION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INFER-TYPES-IN-ISA-TERM"
        "CONS"
        "(DEFUN INFER-TYPES-IN-ISA-TERM ((ISATERM CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INFER-TYPES-IN-ISA-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INFER-TYPES-IN-IN-TERM"
        "CONS"
        "(DEFUN INFER-TYPES-IN-IN-TERM ((INTERM CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INFER-TYPES-IN-IN-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-INFER-EQUAL-TERMS"
        "OBJECT"
        "(DEFUN HELP-INFER-EQUAL-TERMS ((TERM1 OBJECT) (TERM2 OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-INFER-EQUAL-TERMS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INFER-TYPES-IN-EQUAL-TERM"
        "CONS"
        "(DEFUN INFER-TYPES-IN-EQUAL-TERM ((EQTERM CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INFER-TYPES-IN-EQUAL-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-INFER-VARIABLE-TYPES"
        "OBJECT"
        "(DEFUN HELP-INFER-VARIABLE-TYPES ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-INFER-VARIABLE-TYPES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INFER-VARIABLE-TYPES"
        "CONS"
        "(DEFUN INFER-VARIABLE-TYPES ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INFER-VARIABLE-TYPES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBSTITUTE-OUT-VARIABLE-TOKENS"
        "OBJECT"
        "(DEFUN (SUBSTITUTE-OUT-VARIABLE-TOKENS OBJECT) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SUBSTITUTE-OUT-VARIABLE-TOKENS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNTYPED-STELLA-TREE-TO-TYPED-STELLA"
        "CONS"
        "(DEFUN UNTYPED-STELLA-TREE-TO-TYPED-STELLA ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNTYPED-STELLA-TREE-TO-TYPED-STELLA)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONVERT-TO-PREFIX-PROPOSITION-TREE"
        "OBJECT"
        "(DEFUN (CONVERT-TO-PREFIX-PROPOSITION-TREE OBJECT) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONVERT-TO-PREFIX-PROPOSITION-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INFIX-TO-PREFIX-QUANTIFICATION-TREE"
        "CONS"
        "(DEFUN (INFIX-TO-PREFIX-QUANTIFICATION-TREE CONS) ((TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INFIX-TO-PREFIX-QUANTIFICATION-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ACCESS-PREFIX-QUANTIFICATION-CLAUSE"
        "CONS"
        "(DEFUN (ACCESS-PREFIX-QUANTIFICATION-CLAUSE OBJECT) ((PREFIXQUANTIFICATIONTREE CONS) (CLAUSENAME SYMBOL) (EXTRACT? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ACCESS-PREFIX-QUANTIFICATION-CLAUSE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXTRACT-WHERE-CLAUSE"
        "CONS"
        "(DEFUN (EXTRACT-WHERE-CLAUSE OBJECT) ((PREFIXQUANTIFICATIONTREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXTRACT-WHERE-CLAUSE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXTRACT-ALWAYS-CLAUSE"
        "CONS"
        "(DEFUN (EXTRACT-ALWAYS-CLAUSE OBJECT) ((PREFIXQUANTIFICATIONTREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXTRACT-ALWAYS-CLAUSE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-WHERE-CLAUSE"
        "CONS"
        "(DEFUN (LOOKUP-WHERE-CLAUSE OBJECT) ((PREFIXQUANTIFICATIONTREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-WHERE-CLAUSE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-ALWAYS-CLAUSE"
        "CONS"
        "(DEFUN (LOOKUP-ALWAYS-CLAUSE OBJECT) ((PREFIXQUANTIFICATIONTREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-ALWAYS-CLAUSE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STANDARDIZE-LOGICAL-PARSE-TREE"
        "OBJECT"
        "(DEFUN (STANDARDIZE-LOGICAL-PARSE-TREE OBJECT) ((TREE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STANDARDIZE-LOGICAL-PARSE-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "IN-DIALECT"
        "OBJECT"
        "(DEFUN (IN-DIALECT KEYWORD) ((DIALECT NAME)) :DOCUMENTATION \"Change the current logic dialect to `dialect'.
Currently supported dialects are `KIF', `STELLA', and `PREFIX-STELLA'.
The STELLA dialects are not recommended for the construction of knowledge
bases, they are mainly used internally by PowerLoom.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%IN-DIALECT)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-KIF-IN"
     NULL
     "(DEFUN STARTUP-KIF-IN ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL KIF-OPERATOR-TO-INTERNAL-STELLA-TABLE (PROPERTY-LIST OF SYMBOL SYMBOL) (NEW PROPERTY-LIST :THE-PLIST (BQUOTE (+ PLUS - MINUS * TIMES |/| DIVIDE > GREATER-THAN? >= GREATER-OR-EQUAL? < LESS-THAN? =< LESS-OR-EQUAL? SUBSET SUBSET-OF))) :DOCUMENTATION \"Used to encode/decode KIF operators to the internal
version of Stella operators.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *VARIABLE-TOKENS* (LIST OF VARIABLE-TOKEN) (NEW LIST) :DOCUMENTATION \"List of all variable tokens.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *VARIABLE-TOKEN-STACK* (KEY-VALUE-LIST OF SYMBOL VARIABLE-TOKEN) (NEW KEY-VALUE-LIST) :DOCUMENTATION \"Stack of variable tokens visible (during parsing) from the
current scope.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *TYPEBECAMENARROWER?* BOOLEAN :DOCUMENTATION \"Used by 'infer-variable-types?' to record occurrence of
type narrowing.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-KIF-IN-*TYPEBECAMENARROWER?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*TYPEBECAMENARROWER?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*TYPEBECAMENARROWER?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *VISIBLE-TOKEN-STACK* (LIST OF VARIABLE-TOKEN) (NEW LIST) :DOCUMENTATION \"Used by 'infer-variable-types?' to determine which
variables can be narrowed by a current predication.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL BLOCKING-TOKEN VARIABLE-TOKEN (NEW VARIABLE-TOKEN))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *LOGIC-DIALECT* KEYWORD :KIF :DOCUMENTATION \"Indicates the current dialect of logic used to phrase
queries, assertions, and definitions.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-KIF-IN-*LOGIC-DIALECT*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*LOGIC-DIALECT*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*LOGIC-DIALECT*)))
    (REGISTER-NATIVE-NAME
     SYM-KIF-IN-IN-DIALECT
     KWD-KIF-IN-COMMON-LISP
     KWD-KIF-IN-FUNCTION)))
  :VOID)
