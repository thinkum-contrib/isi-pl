;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997                   | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-SPECIALIZE-PROPOSITION-CURSOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-KIND-OF-PROPOSITION NULL)
(CL:DEFVAR SYM-SPECIALIZE-ATTRIBUTE-PROPOSITIONS? NULL)
(CL:DEFVAR SYM-SPECIALIZE-VARIABLE-VALUE-INVERSE-STACK NULL)
(CL:DEFVAR SGT-SPECIALIZE-CONS NULL)
(CL:DEFVAR SGT-SPECIALIZE-KEYWORD NULL)
(CL:DEFVAR SGT-SPECIALIZE-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SGT-SPECIALIZE-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-SUBSUMPTION-TEST-FILTER? NULL)
(CL:DEFVAR SYM-SPECIALIZE-RETURN-ARGUMENT-INDEX NULL)
(CL:DEFVAR SYM-SPECIALIZE-REFERENCE-PROPOSITION NULL)
(CL:DEFVAR SGT-SPECIALIZE-FUNCTION-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-SPECIALIZE-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-SPECIALIZE-PROPOSITION NULL)
(CL:DEFVAR SGT-SPECIALIZE-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR NULL)
(CL:DEFVAR SGT-SPECIALIZE-SKOLEM NULL)
(CL:DEFVAR KWD-SPECIALIZE-FUNCTION NULL)
(CL:DEFVAR SGT-SPECIALIZE-SLOT NULL)
(CL:DEFVAR SYM-SPECIALIZE-DESCRIPTION NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-SPECIALIZE-SLOTREF NULL)
(CL:DEFVAR KWD-SPECIALIZE-PREDICATE NULL)
(CL:DEFVAR KWD-SPECIALIZE-IN NULL)
(CL:DEFVAR SYM-SPECIALIZE-PREDICATE NULL)
(CL:DEFVAR SYM-SPECIALIZE-IN NULL)
(CL:DEFVAR SYM-SPECIALIZE-ALLOCATE-ADJACENCY-ITERATOR-FUNCTION NULL)
(CL:DEFVAR SYM-SPECIALIZE-FILTER? NULL)
(CL:DEFVAR SYM-SPECIALIZE-ADJACENCY-ITERATOR-STACK NULL)
(CL:DEFVAR SYM-SPECIALIZE-BEEN-THERE-LIST NULL)
(CL:DEFVAR SGT-SPECIALIZE-TRANSITIVE-CLOSURE-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-INVERSE? NULL)
(CL:DEFVAR SYM-SPECIALIZE-REFERENCE-INSTANCE NULL)
(CL:DEFVAR SGT-SPECIALIZE-DIRECT-SUPERCOLLECTIONS-ITERATOR NULL)
(CL:DEFVAR KWD-SPECIALIZE-IMPLIES NULL)
(CL:DEFVAR SGT-SPECIALIZE-CLASS NULL)
(CL:DEFVAR SGT-SPECIALIZE-RELATION NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *MODULE*
  STANDARD-OUTPUT
  EOL
  *QUERYENVIRONMENT*
  *REVERSEPOLARITY?*))

;;; (DEFCLASS ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR ...)

(CL:DEFCLASS ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR (ITERATOR)
  ((PROPOSITION-CURSOR
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    PROPOSITION-CURSOR...OF)
   (KIND-OF-PROPOSITION
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    KIND-OF-PROPOSITION...OF)
   (ATTRIBUTE-PROPOSITIONS?
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    ATTRIBUTE-PROPOSITIONS?...OF)
   (VARIABLE-VALUE-INVERSE-STACK
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    VARIABLE-VALUE-INVERSE-STACK...OF)))

(CL:DEFUN NEW-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ
    SELF
    (CL:MAKE-INSTANCE (CL:QUOTE ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL
     ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
     FIRST-ITERATION?
     SELF)
    TRUE)
   (CL:SETF
    (CLSYS-SVAL ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR VALUE SELF)
    NULL)
   (CL:SETF
    (CLSYS-SVAL
     ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
     VARIABLE-VALUE-INVERSE-STACK
     SELF)
    NIL)
   (CL:SETF
    (CLSYS-SVAL
     ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
     ATTRIBUTE-PROPOSITIONS?
     SELF)
    FALSE)
   (CL:SETF
    (CLSYS-SVAL
     ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
     KIND-OF-PROPOSITION
     SELF)
    NULL)
   (CL:SETF
    (CLSYS-SVAL
     ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
     PROPOSITION-CURSOR
     SELF)
    NIL)
   (CL:RETURN-FROM NEW-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR SELF))
  :VOID)

(CL:DEFUN ACCESS-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-PROPOSITION-CURSOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL
       ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
       PROPOSITION-CURSOR
       SELF)
      (CAST VALUE SGT-SPECIALIZE-CONS))
     (CL:RETURN-FROM
      ACCESS-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL
       ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
       PROPOSITION-CURSOR
       SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-KIND-OF-PROPOSITION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL
       ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
       KIND-OF-PROPOSITION
       SELF)
      (CAST VALUE SGT-SPECIALIZE-KEYWORD))
     (CL:RETURN-FROM
      ACCESS-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL
       ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
       KIND-OF-PROPOSITION
       SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-ATTRIBUTE-PROPOSITIONS?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL
       ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
       ATTRIBUTE-PROPOSITIONS?
       SELF)
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-SPECIALIZE-BOOLEAN-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE
      (WRAP-BOOLEAN
       (CLSYS-SVAL
        ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
        ATTRIBUTE-PROPOSITIONS?
        SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-VARIABLE-VALUE-INVERSE-STACK)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL
       ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
       VARIABLE-VALUE-INVERSE-STACK
       SELF)
      (CAST VALUE SGT-SPECIALIZE-CONS))
     (CL:RETURN-FROM
      ACCESS-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL
       ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
       VARIABLE-VALUE-INVERSE-STACK
       SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM
    ACCESS-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE
    VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR))
  (CL:RETURN-FROM
   PRIMARY-TYPE
   SGT-SPECIALIZE-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR)
  :VOID)

;;; (DEFCLASS DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR ...)

(CL:DEFCLASS DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR (ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR)
  ((SUBSUMPTION-TEST-FILTER?
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SUBSUMPTION-TEST-FILTER?...OF)
   (RETURN-ARGUMENT-INDEX
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    RETURN-ARGUMENT-INDEX...OF)
   (REFERENCE-PROPOSITION
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    REFERENCE-PROPOSITION...OF)))

(CL:DEFUN NEW-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ
    SELF
    (CL:MAKE-INSTANCE (CL:QUOTE DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     FIRST-ITERATION?
     SELF)
    TRUE)
   (CL:SETF
    (CLSYS-SVAL DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR VALUE SELF)
    NULL)
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     VARIABLE-VALUE-INVERSE-STACK
     SELF)
    NIL)
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     ATTRIBUTE-PROPOSITIONS?
     SELF)
    FALSE)
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     KIND-OF-PROPOSITION
     SELF)
    NULL)
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     PROPOSITION-CURSOR
     SELF)
    NIL)
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     REFERENCE-PROPOSITION
     SELF)
    NULL)
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     RETURN-ARGUMENT-INDEX
     SELF)
    NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     SUBSUMPTION-TEST-FILTER?
     SELF)
    NULL)
   (CL:RETURN-FROM NEW-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR SELF))
  :VOID)

(CL:DEFUN ACCESS-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-SUBSUMPTION-TEST-FILTER?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL
       DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
       SUBSUMPTION-TEST-FILTER?
       SELF)
      (CLSYS-SVAL
       FUNCTION-CODE-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-SPECIALIZE-FUNCTION-CODE-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL
        DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
        SUBSUMPTION-TEST-FILTER?
        SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-RETURN-ARGUMENT-INDEX)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL
       DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
       RETURN-ARGUMENT-INDEX
       SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-SPECIALIZE-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL
        DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
        RETURN-ARGUMENT-INDEX
        SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-REFERENCE-PROPOSITION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL
       DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
       REFERENCE-PROPOSITION
       SELF)
      (CAST VALUE SGT-SPECIALIZE-PROPOSITION))
     (CL:RETURN-FROM
      ACCESS-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL
       DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
       REFERENCE-PROPOSITION
       SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM
    ACCESS-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE
    VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR))
  (CL:RETURN-FROM
   PRIMARY-TYPE
   SGT-SPECIALIZE-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR)
  :VOID)

;;; (DEFUN (FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM (CONS OF PROPOSITION)) ...)

(CL:DEFUN FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM (SELF)
  (CL:LET*
   ((TOPSKOLEMSLIST
     (FIRST
      (CLSYS-SVAL
       ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
       VARIABLE-VALUE-INVERSE-STACK
       SELF)))
    (NEXTSKOLEM (CAST (FIRST TOPSKOLEMSLIST) SGT-SPECIALIZE-SKOLEM))
    (CURSOR NULL))
   (FIRST-SETTER
    (CLSYS-SVAL
     ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
     VARIABLE-VALUE-INVERSE-STACK
     SELF)
    (CLSYS-SVAL CONS REST TOPSKOLEMSLIST))
   (CL:SETQ
    CURSOR
    (CL:IF
     (CL:EQ
      (CLSYS-SVAL
       ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
       ATTRIBUTE-PROPOSITIONS?
       SELF)
      1)
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL SKOLEM DEPENDENT-ATTRIBUTE-PROPOSITIONS NEXTSKOLEM))
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL SKOLEM DEPENDENT-PROPOSITIONS NEXTSKOLEM))))
   (CL:WHEN
    (CL:EQ (CLSYS-SVAL CONS REST TOPSKOLEMSLIST) NIL)
    (CL:SETF
     (CLSYS-SVAL
      ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
      VARIABLE-VALUE-INVERSE-STACK
      SELF)
     (CLSYS-SVAL
      CONS
      REST
      (CLSYS-SVAL
       ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
       VARIABLE-VALUE-INVERSE-STACK
       SELF))))
   (CL:WHEN
    (CL:NOT (CL:EQ (VARIABLE-VALUE-INVERSE NEXTSKOLEM) NIL))
    (CL:SETF
     (CLSYS-SVAL
      ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
      VARIABLE-VALUE-INVERSE-STACK
      SELF)
     (CONS
      (VARIABLE-VALUE-INVERSE NEXTSKOLEM)
      (CLSYS-SVAL
       ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
       VARIABLE-VALUE-INVERSE-STACK
       SELF))))
   (CL:RETURN-FROM FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM CURSOR))
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR))
  (CL:LET*
   ((CURSOR NULL) (PROPOSITION NULL))
   (CL:IF
    (CL:EQ
     (CLSYS-SVAL
      DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
      FIRST-ITERATION?
      SELF)
     1)
    (CL:PROGN
     (CL:SETF
      (CLSYS-SVAL
       DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
       FIRST-ITERATION?
       SELF)
      FALSE)
     (CL:SETQ
      CURSOR
      (CLSYS-SVAL
       DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
       PROPOSITION-CURSOR
       SELF)))
    (CL:SETQ
     CURSOR
     (CLSYS-SVAL
      CONS
      REST
      (CLSYS-SVAL
       DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
       PROPOSITION-CURSOR
       SELF))))
   (CL:LOOP
    (CL:LOOP
     WHILE
     (CL:EQ CURSOR NIL)
     DO
     (CL:WHEN
      (CL:EQ
       (CLSYS-SVAL
        DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
        VARIABLE-VALUE-INVERSE-STACK
        SELF)
       NIL)
      (CL:RETURN-FROM NEXT? FALSE))
     (CL:SETQ CURSOR (FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM SELF)))
    (CL:SETQ PROPOSITION (CLSYS-SVAL CONS VALUE CURSOR))
    (CL:WHEN
     (CL:AND
      (CL:EQ
       (CLSYS-SVAL PROPOSITION KIND PROPOSITION)
       (CLSYS-SVAL
        DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
        KIND-OF-PROPOSITION
        SELF))
      (CL:EQ
       (CL:IF
        (CL:EQ *REVERSEPOLARITY?* 1)
        (FALSE? PROPOSITION)
        (CL:IF
         (CL:OR
          (CL:EQ (TRUE? PROPOSITION) 1)
          (CL:EQ
           (CLSYS-SVAL
            DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
            KIND-OF-PROPOSITION
            SELF)
           KWD-SPECIALIZE-FUNCTION))
         TRUE
         FALSE))
       1)
      (CL:OR
       (CL:EQ
        (CLSYS-SVAL
         DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
         SUBSUMPTION-TEST-FILTER?
         SELF)
        NULL)
       (CL:EQ
        (CL:FUNCALL
         (CLSYS-SVAL
          DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
          SUBSUMPTION-TEST-FILTER?
          SELF)
         PROPOSITION
         (CLSYS-SVAL
          DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
          REFERENCE-PROPOSITION
          SELF))
        1)))
     (CL:IF
      (CL:EQ
       (DEFINED?
        (CLSYS-SVAL
         DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
         RETURN-ARGUMENT-INDEX
         SELF))
       1)
      (CL:SETF
       (CLSYS-SVAL DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR VALUE SELF)
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
        (CLSYS-SVAL
         DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
         RETURN-ARGUMENT-INDEX
         SELF)))
      (CL:SETF
       (CLSYS-SVAL DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR VALUE SELF)
       PROPOSITION))
     (CL:SETF
      (CLSYS-SVAL
       DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
       PROPOSITION-CURSOR
       SELF)
      CURSOR)
     (CL:RETURN-FROM NEXT? TRUE))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR))))
  :VOID)

;;; (DEFUN (ALL-DIRECTLY-DEPENDENT-PROPOSITIONS ITERATOR) ...)

(CL:DEFUN ALL-DIRECTLY-DEPENDENT-PROPOSITIONS (SELF KIND)
  (CL:LET*
   ((ITERATOR (NEW-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     PROPOSITION-CURSOR
     ITERATOR)
    (CLSYS-SVAL
     LIST
     THE-CONS-LIST
     (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS SELF)))
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     KIND-OF-PROPOSITION
     ITERATOR)
    KIND)
   (CL:WHEN
    (CL:NOT (CL:EQ (VARIABLE-VALUE-INVERSE SELF) NIL))
    (CL:SETF
     (CLSYS-SVAL
      DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
      VARIABLE-VALUE-INVERSE-STACK
      ITERATOR)
     (CONS-LIST (VARIABLE-VALUE-INVERSE SELF))))
   (CL:RETURN-FROM ALL-DIRECTLY-DEPENDENT-PROPOSITIONS ITERATOR))
  :VOID)

;;; (DEFUN (ALL-DEPENDENT-ATTRIBUTE-PROPOSITIONS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-DEPENDENT-ATTRIBUTE-PROPOSITIONS (SELF KIND)
  (CL:LET*
   ((ITERATOR (NEW-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     PROPOSITION-CURSOR
     ITERATOR)
    (CLSYS-SVAL
     LIST
     THE-CONS-LIST
     (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-ATTRIBUTE-PROPOSITIONS SELF)))
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     KIND-OF-PROPOSITION
     ITERATOR)
    KIND)
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     ATTRIBUTE-PROPOSITIONS?
     ITERATOR)
    TRUE)
   (CL:WHEN
    (CL:NOT (CL:EQ (VARIABLE-VALUE-INVERSE SELF) NIL))
    (CL:SETF
     (CLSYS-SVAL
      DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
      VARIABLE-VALUE-INVERSE-STACK
      ITERATOR)
     (CONS-LIST (VARIABLE-VALUE-INVERSE SELF))))
   (CL:RETURN-FROM ALL-DEPENDENT-ATTRIBUTE-PROPOSITIONS ITERATOR))
  :VOID)

;;; (DEFUN (SLOTREF-SPECIALIZES-SLOTREF? BOOLEAN) ...)

(CL:DEFUN SLOTREF-SPECIALIZES-SLOTREF? (SLOTREF1 SLOTREF2)
  (CL:WHEN
   (CL:EQ SLOTREF1 SLOTREF2)
   (CL:RETURN-FROM SLOTREF-SPECIALIZES-SLOTREF? TRUE))
  (CL:LET*
   ((DESC1
     (DYNAMIC-SLOT-VALUE
      (CAST
       (CLSYS-SVAL SURROGATE SURROGATE-VALUE SLOTREF1)
       SGT-SPECIALIZE-SLOT)
      SYM-SPECIALIZE-DESCRIPTION
      NULL))
    (DESC2
     (DYNAMIC-SLOT-VALUE
      (CAST
       (CLSYS-SVAL SURROGATE SURROGATE-VALUE SLOTREF2)
       SGT-SPECIALIZE-SLOT)
      SYM-SPECIALIZE-DESCRIPTION
      NULL)))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ DESC1 NULL)) (CL:NOT (CL:EQ DESC1 NULL)))
    (CL:RETURN-FROM
     SLOTREF-SPECIALIZES-SLOTREF?
     (MEMBER? (ALL-SUPERCOLLECTIONS DESC1) DESC2))
    (CL:RETURN-FROM SLOTREF-SPECIALIZES-SLOTREF? FALSE)))
  :VOID)

;;; (DEFUN (FIND-LOGIC-OBJECT-BOUND-TO-ARGUMENT LOGIC-OBJECT) ...)

(CL:DEFUN FIND-LOGIC-OBJECT-BOUND-TO-ARGUMENT (PROPOSITION)
  (CL:LET*
   ((VALUE NULL))
   (CL:LET*
    ((ARG NULL)
     (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       ARG
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:SETQ VALUE (ARGUMENT-BOUND-TO ARG))
     (CL:WHEN
      (CL:AND
       (CL:NOT (CL:EQ VALUE NULL))
       (CL:EQ (ISA? VALUE SGT-SPECIALIZE-LOGIC-OBJECT) 1))
      (CL:RETURN-FROM
       FIND-LOGIC-OBJECT-BOUND-TO-ARGUMENT
       (CAST VALUE SGT-SPECIALIZE-LOGIC-OBJECT))))))
  (CL:RETURN-FROM FIND-LOGIC-OBJECT-BOUND-TO-ARGUMENT NULL)
  :VOID)

;;; (DEFUN (SPECIALIZES-PREDICATE-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN SPECIALIZES-PREDICATE-PROPOSITION? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:WHEN
   (CL:EQ
    (SLOTREF-SPECIALIZES-SLOTREF?
     (CAST
      (CLSYS-SVAL PROPOSITION OPERATOR SUBPROPOSITION)
      SGT-SPECIALIZE-SLOTREF)
     (CAST
      (CLSYS-SVAL PROPOSITION OPERATOR REFERENCEPROPOSITION)
      SGT-SPECIALIZE-SLOTREF))
    0)
   (CL:RETURN-FROM SPECIALIZES-PREDICATE-PROPOSITION? FALSE))
  (CL:LET*
   ((UBSTACKOFFSET
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      TOP-UNBINDING-STACK-OFFSET
      *QUERYENVIRONMENT*))
    (SUCCESS? FALSE))
   (CL:LET*
    ((ALWAYS?-001 TRUE))
    (CL:LET*
     ((SUPERARG NULL)
      (SUBARG NULL)
      (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS SUBPROPOSITION))
      (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001))
      (VECTOR-002 (CLSYS-SVAL PROPOSITION ARGUMENTS REFERENCEPROPOSITION))
      (INDEX-002 0)
      (LENGTH-002 (LENGTH VECTOR-002)))
     (CL:LOOP
      WHILE
      (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:< INDEX-002 LENGTH-002))
      DO
      (CL:PROGN
       (CL:SETQ
        SUBARG
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (CL:PROGN
       (CL:SETQ
        SUPERARG
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
       (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
      (CL:WHEN
       (CL:EQ (BIND-ARGUMENT-TO-VALUE? SUPERARG (VALUE-OF SUBARG) FALSE) 0)
       (CL:SETQ ALWAYS?-001 FALSE)
       (CL:RETURN))))
    (CL:SETQ SUCCESS? ALWAYS?-001))
   (CL:WHEN
    (CL:EQ SUCCESS? 0)
    (UNBIND-VARIABLES-BEGINNING-AT (CL:1+ UBSTACKOFFSET)))
   (CL:RETURN-FROM SPECIALIZES-PREDICATE-PROPOSITION? SUCCESS?))
  :VOID)

;;; (DEFUN (SPECIALIZES-IN-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN SPECIALIZES-IN-PROPOSITION? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:RETURN-FROM
   SPECIALIZES-IN-PROPOSITION?
   (COLLECTION-IMPLIES-COLLECTION?
    (VALUE-OF
     (CL:AREF
      (CLSYS-SVAL
       VECTOR
       THE-ARRAY
       (CLSYS-SVAL PROPOSITION ARGUMENTS SUBPROPOSITION))
      1))
    (ARGUMENT-BOUND-TO
     (CL:AREF
      (CLSYS-SVAL
       VECTOR
       THE-ARRAY
       (CLSYS-SVAL PROPOSITION ARGUMENTS REFERENCEPROPOSITION))
      1))))
  :VOID)

;;; (DEFUN (FAILING-SUBSUMPTION-TEST? BOOLEAN) ...)

(CL:DEFUN FAILING-SUBSUMPTION-TEST? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:PROGN
   (CL:SETQ SUBPROPOSITION SUBPROPOSITION)
   (CL:SETQ REFERENCEPROPOSITION REFERENCEPROPOSITION))
  (CL:RETURN-FROM FAILING-SUBSUMPTION-TEST? FALSE)
  :VOID)

;;; (DEFCONSTANT EMPTY-ALL-PROPOSITIONS-ITERATOR ...)

(CL:DEFVAR EMPTY-ALL-PROPOSITIONS-ITERATOR NULL
  "This iterator returns no values whenever its called.")

;;; (DEFUN (ALL-SPECIALIZING-PROPOSITIONS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-SPECIALIZING-PROPOSITIONS (SELF)
  (CL:LET*
   ((LOGICARGUMENT (FIND-LOGIC-OBJECT-BOUND-TO-ARGUMENT SELF))
    (ITERATOR NULL))
   (CL:WHEN
    (CL:EQ LOGICARGUMENT NULL)
    (CL:RETURN-FROM
     ALL-SPECIALIZING-PROPOSITIONS
     EMPTY-ALL-PROPOSITIONS-ITERATOR))
   (CL:IF
    (CL:AND
     (CL:EQ (ATTRIBUTE-PROPOSITION? SELF) 1)
     (CL:EQ
      (ARGUMENT-BOUND? (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)))
      1))
    (CL:SETQ
     ITERATOR
     (CAST
      (ALL-DEPENDENT-ATTRIBUTE-PROPOSITIONS
       LOGICARGUMENT
       (CLSYS-SVAL PROPOSITION KIND SELF))
      SGT-SPECIALIZE-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR))
    (CL:SETQ
     ITERATOR
     (CAST
      (ALL-DIRECTLY-DEPENDENT-PROPOSITIONS
       LOGICARGUMENT
       (CLSYS-SVAL PROPOSITION KIND SELF))
      SGT-SPECIALIZE-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     REFERENCE-PROPOSITION
     ITERATOR)
    SELF)
   (CL:LET*
    ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND SELF)))
    (CL:COND
     ((CL:OR
       (CL:EQ TEST-VALUE-001 KWD-SPECIALIZE-PREDICATE)
       (CL:EQ TEST-VALUE-001 KWD-SPECIALIZE-FUNCTION))
      (CL:SETF
       (CLSYS-SVAL
        DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
        SUBSUMPTION-TEST-FILTER?
        ITERATOR)
       (CL:FUNCTION SPECIALIZES-PREDICATE-PROPOSITION?)))
     ((CL:EQ TEST-VALUE-001 KWD-SPECIALIZE-IN)
      (CL:SETF
       (CLSYS-SVAL
        DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
        SUBSUMPTION-TEST-FILTER?
        ITERATOR)
       (CL:FUNCTION SPECIALIZES-IN-PROPOSITION?)))
     (CL:T
      (CL:SETF
       (CLSYS-SVAL
        DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
        SUBSUMPTION-TEST-FILTER?
        ITERATOR)
       (CL:FUNCTION FAILING-SUBSUMPTION-TEST?)))))
   (CL:RETURN-FROM ALL-SPECIALIZING-PROPOSITIONS ITERATOR))
  :VOID)

;;; (DEFUN (SPECIALIZES-ATTRIBUTE-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN SPECIALIZES-ATTRIBUTE-PROPOSITION? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:LET*
   ((TEST-VALUE-001 FALSE))
   (CL:SETQ
    TEST-VALUE-001
    (SLOTREF-SPECIALIZES-SLOTREF?
     (CAST
      (CLSYS-SVAL PROPOSITION OPERATOR SUBPROPOSITION)
      SGT-SPECIALIZE-SLOTREF)
     (CAST
      (CLSYS-SVAL PROPOSITION OPERATOR REFERENCEPROPOSITION)
      SGT-SPECIALIZE-SLOTREF)))
   (CL:WHEN
    (CL:EQ TEST-VALUE-001 1)
    (CL:LET*
     ((ALWAYS?-001 TRUE))
     (CL:LET*
      ((OTHERARG NULL)
       (ARG NULL)
       (ITER-001 (BUT-LAST (CLSYS-SVAL PROPOSITION ARGUMENTS SUBPROPOSITION)))
       (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS REFERENCEPROPOSITION))
       (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:LOOP
       WHILE
       (CL:AND (CL:EQ (NEXT? ITER-001) 1) (CL:< INDEX-001 LENGTH-001))
       DO
       (CL:PROGN (CL:SETQ ARG (CLSYS-SVAL ITERATOR VALUE ITER-001)))
       (CL:PROGN
        (CL:SETQ
         OTHERARG
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (CL:WHEN
        (CL:EQ (EQL? (VALUE-OF ARG) (ARGUMENT-BOUND-TO OTHERARG)) 0)
        (CL:SETQ ALWAYS?-001 FALSE)
        (CL:RETURN))))
     (CL:SETQ TEST-VALUE-001 ALWAYS?-001)))
   (CL:LET*
    ((VALUE-001 TEST-VALUE-001))
    (CL:RETURN-FROM SPECIALIZES-ATTRIBUTE-PROPOSITION? VALUE-001)))
  :VOID)

;;; (DEFUN (FAST-GET-ATTRIBUTE-PROPOSITION-VALUE OBJECT) ...)

(CL:DEFUN FAST-GET-ATTRIBUTE-PROPOSITION-VALUE (SELF RELATION)
  (CL:LET*
   ((P NULL)
    (ITER-001
     (CLSYS-SVAL
      LIST
      THE-CONS-LIST
      (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-ATTRIBUTE-PROPOSITIONS SELF))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      P
      (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-SPECIALIZE-PROPOSITION))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:AND
      (CL:EQ (CLSYS-SVAL PROPOSITION OPERATOR P) RELATION)
      (CL:OR
       (CL:EQ (TRUE? P) 1)
       (CL:EQ (CLSYS-SVAL PROPOSITION KIND P) KWD-SPECIALIZE-FUNCTION)))
     (CL:RETURN-FROM
      FAST-GET-ATTRIBUTE-PROPOSITION-VALUE
      (VALUE-OF
       (CL:AREF
        (CLSYS-SVAL VECTOR THE-ARRAY (CLSYS-SVAL PROPOSITION ARGUMENTS P))
        1))))))
  (CL:RETURN-FROM FAST-GET-ATTRIBUTE-PROPOSITION-VALUE NULL)
  :VOID)

;;; (DEFUN (GET-ATTRIBUTE-PROPOSITION-VALUE OBJECT) ...)

(CL:DEFUN GET-ATTRIBUTE-PROPOSITION-VALUE (SELF RELATION)
  (CL:LET*
   ((RESULT NULL)
    (ITERATOR
     (CAST
      (ALL-DEPENDENT-ATTRIBUTE-PROPOSITIONS SELF KWD-SPECIALIZE-FUNCTION)
      SGT-SPECIALIZE-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR))
    (PROPOSITION NULL))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITERATOR) 1)
    DO
    (CL:SETQ
     PROPOSITION
     (CAST
      (CLSYS-SVAL DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR VALUE ITERATOR)
      SGT-SPECIALIZE-PROPOSITION))
    (CL:WHEN
     (CL:AND
      (CL:EQ
       (SLOTREF-SPECIALIZES-SLOTREF?
        (CAST
         (CLSYS-SVAL PROPOSITION OPERATOR PROPOSITION)
         SGT-SPECIALIZE-SLOTREF)
        RELATION)
       1)
      (CL:OR
       (CL:EQ (TRUE? PROPOSITION) 1)
       (CL:EQ
        (CLSYS-SVAL PROPOSITION KIND PROPOSITION)
        KWD-SPECIALIZE-FUNCTION)))
     (CL:SETQ
      RESULT
      (VALUE-OF
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
        1)))
     (FREE ITERATOR)
     (CL:RETURN-FROM GET-ATTRIBUTE-PROPOSITION-VALUE RESULT)))
   (FREE ITERATOR)
   (CL:RETURN-FROM GET-ATTRIBUTE-PROPOSITION-VALUE NULL))
  :VOID)

;;; (DEFCONSTANT BLANK-PROPERTY-PROPOSITION ...)

(CL:DEFVAR BLANK-PROPERTY-PROPOSITION NULL
  "Used by 'exists-property-proposition' to construct an
on-the-fly unary predicate proposition.")

;;; (DEFUN (SPECIALIZES-PROPERTY-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN SPECIALIZES-PROPERTY-PROPOSITION? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:RETURN-FROM
   SPECIALIZES-PROPERTY-PROPOSITION?
   (SLOTREF-SPECIALIZES-SLOTREF?
    (CAST
     (CLSYS-SVAL PROPOSITION OPERATOR SUBPROPOSITION)
     SGT-SPECIALIZE-SLOTREF)
    (CAST
     (CLSYS-SVAL PROPOSITION OPERATOR REFERENCEPROPOSITION)
     SGT-SPECIALIZE-SLOTREF)))
  :VOID)

;;; (DEFUN (EXISTS-PROPERTY-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN EXISTS-PROPERTY-PROPOSITION? (SELF RELATION)
  (CL:LET*
   ((ITERATOR
     (CAST
      (ALL-DEPENDENT-ATTRIBUTE-PROPOSITIONS SELF KWD-SPECIALIZE-PREDICATE)
      SGT-SPECIALIZE-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     REFERENCE-PROPOSITION
     ITERATOR)
    BLANK-PROPERTY-PROPOSITION)
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     SUBSUMPTION-TEST-FILTER?
     ITERATOR)
    (CL:FUNCTION SPECIALIZES-PROPERTY-PROPOSITION?))
   (CL:SETF
    (CLSYS-SVAL PROPOSITION OPERATOR BLANK-PROPERTY-PROPOSITION)
    RELATION)
   (CL:WHEN
    (CL:EQ (NEXT? ITERATOR) 1)
    (FREE ITERATOR)
    (CL:RETURN-FROM EXISTS-PROPERTY-PROPOSITION? TRUE))
   (FREE ITERATOR)
   (CL:RETURN-FROM EXISTS-PROPERTY-PROPOSITION? FALSE))
  :VOID)

;;; (DEFCONSTANT BLANK-IN-PROPOSITION ...)

(CL:DEFVAR BLANK-IN-PROPOSITION NULL
  "Used by 'DESCRIPTION-EXTENSION-ITERATOR.next? to quickly
construct an IN proposition to be passed to 'all-specializing-propositions'
during filtering of generated instances.")

;;; (DEFUN (EXISTS-SPECIALIZING-IN-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN EXISTS-SPECIALIZING-IN-PROPOSITION? (MEMBER COLLECTION)
  (CL:LET*
   ((ITERATOR
     (CAST
      (ALL-DIRECTLY-DEPENDENT-PROPOSITIONS MEMBER KWD-SPECIALIZE-IN)
      SGT-SPECIALIZE-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR)))
   (CL:SETF
    (CL:AREF
     (CLSYS-SVAL
      VECTOR
      THE-ARRAY
      (CLSYS-SVAL PROPOSITION ARGUMENTS BLANK-IN-PROPOSITION))
     1)
    COLLECTION)
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     REFERENCE-PROPOSITION
     ITERATOR)
    BLANK-IN-PROPOSITION)
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     SUBSUMPTION-TEST-FILTER?
     ITERATOR)
    (CL:FUNCTION SPECIALIZES-IN-PROPOSITION?))
   (CL:WHEN
    (CL:EQ (NEXT? ITERATOR) 1)
    (FREE ITERATOR)
    (CL:RETURN-FROM EXISTS-SPECIALIZING-IN-PROPOSITION? TRUE))
   (FREE ITERATOR)
   (CL:RETURN-FROM EXISTS-SPECIALIZING-IN-PROPOSITION? FALSE))
  :VOID)

;;; (DEFUN (MATCHES-IN-PROPOSITION-COLLECTION-ARGUMENT? BOOLEAN) ...)

(CL:DEFUN MATCHES-IN-PROPOSITION-COLLECTION-ARGUMENT? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:RETURN-FROM
   MATCHES-IN-PROPOSITION-COLLECTION-ARGUMENT?
   (EQL?
    (CL:AREF
     (CLSYS-SVAL
      VECTOR
      THE-ARRAY
      (CLSYS-SVAL PROPOSITION ARGUMENTS SUBPROPOSITION))
     1)
    (CL:AREF
     (CLSYS-SVAL
      VECTOR
      THE-ARRAY
      (CLSYS-SVAL PROPOSITION ARGUMENTS REFERENCEPROPOSITION))
     1)))
  :VOID)

;;; (DEFUN (ALL-IN-PROPOSITION-MEMBERS DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR) ...)

(CL:DEFUN ALL-IN-PROPOSITION-MEMBERS (COLLECTION)
  (CL:LET*
   ((ITERATOR
     (CAST
      (ALL-DIRECTLY-DEPENDENT-PROPOSITIONS COLLECTION KWD-SPECIALIZE-IN)
      SGT-SPECIALIZE-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR)))
   (CL:SETF
    (CL:AREF
     (CLSYS-SVAL
      VECTOR
      THE-ARRAY
      (CLSYS-SVAL PROPOSITION ARGUMENTS BLANK-IN-PROPOSITION))
     1)
    COLLECTION)
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     REFERENCE-PROPOSITION
     ITERATOR)
    BLANK-IN-PROPOSITION)
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     SUBSUMPTION-TEST-FILTER?
     ITERATOR)
    (CL:FUNCTION MATCHES-IN-PROPOSITION-COLLECTION-ARGUMENT?))
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     RETURN-ARGUMENT-INDEX
     ITERATOR)
    0)
   (CL:RETURN-FROM ALL-IN-PROPOSITION-MEMBERS ITERATOR))
  :VOID)

;;; (DEFCLASS TRANSITIVE-CLOSURE-ITERATOR ...)

(CL:DEFCLASS TRANSITIVE-CLOSURE-ITERATOR (ITERATOR)
  ((ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    ALLOCATE-ADJACENCY-ITERATOR-FUNCTION...OF)
   (FILTER? :ALLOCATION :INSTANCE :ACCESSOR FILTER?...OF)
   (ADJACENCY-ITERATOR-STACK
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    ADJACENCY-ITERATOR-STACK...OF)
   (BEEN-THERE-LIST :ALLOCATION :INSTANCE :ACCESSOR BEEN-THERE-LIST...OF))
  (:DOCUMENTATION
   "Iterator that visits all nodes reachable using an
embedded adjacency function."))

(CL:DEFUN NEW-TRANSITIVE-CLOSURE-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRANSITIVE-CLOSURE-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR FIRST-ITERATION? SELF)
    TRUE)
   (CL:SETF (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR VALUE SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR BEEN-THERE-LIST SELF)
    NULL)
   (CL:SETF
    (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR ADJACENCY-ITERATOR-STACK SELF)
    NIL)
   (CL:SETF (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR FILTER? SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL
     TRANSITIVE-CLOSURE-ITERATOR
     ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
     SELF)
    NULL)
   (CL:RETURN-FROM NEW-TRANSITIVE-CLOSURE-ITERATOR SELF))
  :VOID)

(CL:DEFUN ACCESS-TRANSITIVE-CLOSURE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-ALLOCATE-ADJACENCY-ITERATOR-FUNCTION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL
       TRANSITIVE-CLOSURE-ITERATOR
       ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
       SELF)
      (CLSYS-SVAL
       FUNCTION-CODE-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-SPECIALIZE-FUNCTION-CODE-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-TRANSITIVE-CLOSURE-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL
        TRANSITIVE-CLOSURE-ITERATOR
        ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
        SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-FILTER?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR FILTER? SELF)
      (CLSYS-SVAL
       FUNCTION-CODE-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-SPECIALIZE-FUNCTION-CODE-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-TRANSITIVE-CLOSURE-ITERATOR-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR FILTER? SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-ADJACENCY-ITERATOR-STACK)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR ADJACENCY-ITERATOR-STACK SELF)
      (CAST VALUE SGT-SPECIALIZE-CONS))
     (CL:RETURN-FROM
      ACCESS-TRANSITIVE-CLOSURE-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL
       TRANSITIVE-CLOSURE-ITERATOR
       ADJACENCY-ITERATOR-STACK
       SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-BEEN-THERE-LIST)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR BEEN-THERE-LIST SELF)
      (CAST VALUE SGT-SPECIALIZE-CONS))
     (CL:RETURN-FROM
      ACCESS-TRANSITIVE-CLOSURE-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR BEEN-THERE-LIST SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-TRANSITIVE-CLOSURE-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSITIVE-CLOSURE-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-SPECIALIZE-TRANSITIVE-CLOSURE-ITERATOR)
  :VOID)

;;; (DEFMETHOD FREE ...)

(CL:DEFMETHOD FREE ((SELF TRANSITIVE-CLOSURE-ITERATOR))
  (FREE-CONS-LIST
   (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR ADJACENCY-ITERATOR-STACK SELF))
  (FREE-CONS-LIST (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR BEEN-THERE-LIST SELF))
  (UNMAKE SELF)
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF TRANSITIVE-CLOSURE-ITERATOR))
  (CL:LET*
   ((NODE (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR VALUE SELF))
    (ADJACENCYITERATOR
     (CL:FUNCALL
      (CLSYS-SVAL
       TRANSITIVE-CLOSURE-ITERATOR
       ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
       SELF)
      NODE)))
   (CL:IF
    (CL:NOT (CL:EQ ADJACENCYITERATOR NULL))
    (CL:SETF
     (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR ADJACENCY-ITERATOR-STACK SELF)
     (CONS
      ADJACENCYITERATOR
      (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR ADJACENCY-ITERATOR-STACK SELF)))
    (CL:PROGN
     (CL:SETQ
      ADJACENCYITERATOR
      (FIRST
       (CLSYS-SVAL
        TRANSITIVE-CLOSURE-ITERATOR
        ADJACENCY-ITERATOR-STACK
        SELF)))
     (CL:WHEN (CL:EQ ADJACENCYITERATOR NULL) (CL:RETURN-FROM NEXT? FALSE))))
   (CL:LOOP
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ADJACENCYITERATOR) 0)
     DO
     (CL:SETF
      (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR ADJACENCY-ITERATOR-STACK SELF)
      (CLSYS-SVAL
       CONS
       REST
       (CLSYS-SVAL
        TRANSITIVE-CLOSURE-ITERATOR
        ADJACENCY-ITERATOR-STACK
        SELF)))
     (CL:SETQ
      ADJACENCYITERATOR
      (FIRST
       (CLSYS-SVAL
        TRANSITIVE-CLOSURE-ITERATOR
        ADJACENCY-ITERATOR-STACK
        SELF)))
     (CL:WHEN (CL:EQ ADJACENCYITERATOR NULL) (CL:RETURN-FROM NEXT? FALSE)))
    (CL:SETQ NODE (CLSYS-SVAL ITERATOR VALUE ADJACENCYITERATOR))
    (CL:WHEN
     (CL:AND
      (CL:EQ
       (MEMBER?
        (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR BEEN-THERE-LIST SELF)
        (CLSYS-SVAL ITERATOR VALUE ADJACENCYITERATOR))
       0)
      (CL:OR
       (CL:EQ (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR FILTER? SELF) NULL)
       (CL:EQ
        (CL:FUNCALL
         (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR FILTER? SELF)
         NODE)
        1)))
     (CL:SETF
      (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR BEEN-THERE-LIST SELF)
      (CONS
       NODE
       (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR BEEN-THERE-LIST SELF)))
     (CL:SETF (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR VALUE SELF) NODE)
     (CL:RETURN-FROM NEXT? TRUE))))
  :VOID)

;;; (DEFUN (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR ITERATOR) ...)

(CL:DEFUN ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR (STARTNODE ALLOCATEADJACENCYITERATOR FILTERFUNCTION)
  "Return an iterator that generates the transitive
closure of applying iterators generated by 'allocateAdjacencyIterator'
to 'startNode'.  If 'filterFunction' is non-null, that function is applied
as a filter to each node generated (nodes filtered out still generate
descendants, but they don't get returned)."
  (CL:LET*
   ((ITERATOR (NEW-TRANSITIVE-CLOSURE-ITERATOR)))
   (CL:SETF (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR VALUE ITERATOR) STARTNODE)
   (CL:SETF
    (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR BEEN-THERE-LIST ITERATOR)
    (CONS-LIST STARTNODE))
   (CL:SETF
    (CLSYS-SVAL
     TRANSITIVE-CLOSURE-ITERATOR
     ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
     ITERATOR)
    ALLOCATEADJACENCYITERATOR)
   (CL:SETF
    (CLSYS-SVAL TRANSITIVE-CLOSURE-ITERATOR FILTER? ITERATOR)
    FILTERFUNCTION)
   (CL:RETURN-FROM ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR ITERATOR))
  :VOID)

;;; (DEFCLASS DIRECT-SUPERCOLLECTIONS-ITERATOR ...)

(CL:DEFCLASS DIRECT-SUPERCOLLECTIONS-ITERATOR (ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR)
  ((INVERSE? :ALLOCATION :INSTANCE :ACCESSOR INVERSE?...OF)
   (REFERENCE-INSTANCE :ALLOCATION :INSTANCE :ACCESSOR REFERENCE-INSTANCE...OF)))

(CL:DEFUN NEW-DIRECT-SUPERCOLLECTIONS-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ
    SELF
    (CL:MAKE-INSTANCE (CL:QUOTE DIRECT-SUPERCOLLECTIONS-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR FIRST-ITERATION? SELF)
    TRUE)
   (CL:SETF (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR VALUE SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL
     DIRECT-SUPERCOLLECTIONS-ITERATOR
     VARIABLE-VALUE-INVERSE-STACK
     SELF)
    NIL)
   (CL:SETF
    (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR ATTRIBUTE-PROPOSITIONS? SELF)
    FALSE)
   (CL:SETF
    (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR KIND-OF-PROPOSITION SELF)
    NULL)
   (CL:SETF
    (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR PROPOSITION-CURSOR SELF)
    NIL)
   (CL:SETF
    (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR REFERENCE-INSTANCE SELF)
    NULL)
   (CL:SETF (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR INVERSE? SELF) FALSE)
   (CL:RETURN-FROM NEW-DIRECT-SUPERCOLLECTIONS-ITERATOR SELF))
  :VOID)

(CL:DEFUN ACCESS-DIRECT-SUPERCOLLECTIONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-INVERSE?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR INVERSE? SELF)
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-SPECIALIZE-BOOLEAN-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-DIRECT-SUPERCOLLECTIONS-ITERATOR-SLOT-VALUE
      (WRAP-BOOLEAN
       (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR INVERSE? SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-REFERENCE-INSTANCE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR REFERENCE-INSTANCE SELF)
      (CAST VALUE SGT-SPECIALIZE-LOGIC-OBJECT))
     (CL:RETURN-FROM
      ACCESS-DIRECT-SUPERCOLLECTIONS-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR REFERENCE-INSTANCE SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-DIRECT-SUPERCOLLECTIONS-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DIRECT-SUPERCOLLECTIONS-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-SPECIALIZE-DIRECT-SUPERCOLLECTIONS-ITERATOR)
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF DIRECT-SUPERCOLLECTIONS-ITERATOR))
  (CL:LET*
   ((CURSOR NULL) (PROPOSITION NULL))
   (CL:IF
    (CL:EQ
     (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR FIRST-ITERATION? SELF)
     1)
    (CL:PROGN
     (CL:SETF
      (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR FIRST-ITERATION? SELF)
      FALSE)
     (CL:SETQ
      CURSOR
      (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR PROPOSITION-CURSOR SELF)))
    (CL:SETQ
     CURSOR
     (CLSYS-SVAL
      CONS
      REST
      (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR PROPOSITION-CURSOR SELF))))
   (CL:LOOP
    (CL:LOOP
     WHILE
     (CL:EQ CURSOR NIL)
     DO
     (CL:WHEN
      (CL:EQ
       (CLSYS-SVAL
        DIRECT-SUPERCOLLECTIONS-ITERATOR
        VARIABLE-VALUE-INVERSE-STACK
        SELF)
       NIL)
      (CL:RETURN-FROM NEXT? FALSE))
     (CL:SETQ CURSOR (FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM SELF)))
    (CL:SETQ PROPOSITION (CLSYS-SVAL CONS VALUE CURSOR))
    (CL:WHEN
     (CL:AND
      (CL:EQ
       (CLSYS-SVAL PROPOSITION KIND PROPOSITION)
       (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR KIND-OF-PROPOSITION SELF))
      (CL:EQ (TRUE? PROPOSITION) 1)
      (CL:EQ
       (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR REFERENCE-INSTANCE SELF)
       (VALUE-OF
        (CL:IF
         (CL:EQ (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR INVERSE? SELF) 1)
         (CL:AREF
          (CLSYS-SVAL
           VECTOR
           THE-ARRAY
           (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
          1)
         (CL:AREF
          (CLSYS-SVAL
           VECTOR
           THE-ARRAY
           (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
          0)))))
     (CL:SETF
      (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR VALUE SELF)
      (VALUE-OF
       (CL:IF
        (CL:EQ (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR INVERSE? SELF) 1)
        (CL:AREF
         (CLSYS-SVAL
          VECTOR
          THE-ARRAY
          (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
         0)
        (CL:AREF
         (CLSYS-SVAL
          VECTOR
          THE-ARRAY
          (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
         1))))
     (CL:SETF
      (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR PROPOSITION-CURSOR SELF)
      CURSOR)
     (CL:RETURN-FROM NEXT? TRUE))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR))))
  :VOID)

;;; (DEFUN (ALL-DIRECTLY-LINKED-OBJECTS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECTLY-LINKED-OBJECTS (SELF KIND INVERSE?)
  (CL:LET*
   ((ITERATOR (NEW-DIRECT-SUPERCOLLECTIONS-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR KIND-OF-PROPOSITION ITERATOR)
    KIND)
   (CL:SETF
    (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR INVERSE? ITERATOR)
    INVERSE?)
   (CL:SETF
    (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR REFERENCE-INSTANCE ITERATOR)
    SELF)
   (CL:SETF
    (CLSYS-SVAL DIRECT-SUPERCOLLECTIONS-ITERATOR PROPOSITION-CURSOR ITERATOR)
    (CLSYS-SVAL
     LIST
     THE-CONS-LIST
     (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS SELF)))
   (CL:WHEN
    (CL:NOT (CL:EQ (VARIABLE-VALUE-INVERSE SELF) NIL))
    (CL:SETF
     (CLSYS-SVAL
      DIRECT-SUPERCOLLECTIONS-ITERATOR
      VARIABLE-VALUE-INVERSE-STACK
      ITERATOR)
     (CONS-LIST (VARIABLE-VALUE-INVERSE SELF))))
   (CL:RETURN-FROM ALL-DIRECTLY-LINKED-OBJECTS ITERATOR))
  :VOID)

;;; (DEFUN (ALL-DIRECT-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-SUPERCOLLECTIONS (SELF)
  (CL:RETURN-FROM
   ALL-DIRECT-SUPERCOLLECTIONS
   (ALL-DIRECTLY-LINKED-OBJECTS SELF KWD-SPECIALIZE-IMPLIES *REVERSEPOLARITY?*))
  :VOID)

;;; (DEFUN (ALL-DIRECT-SUBCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-SUBCOLLECTIONS (SELF)
  (CL:RETURN-FROM
   ALL-DIRECT-SUBCOLLECTIONS
   (ALL-DIRECTLY-LINKED-OBJECTS
    SELF
    KWD-SPECIALIZE-IMPLIES
    (CL:IF (CL:EQ *REVERSEPOLARITY?* 0) TRUE FALSE)))
  :VOID)

;;; (DEFUN (ALL-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-SUPERCOLLECTIONS (SELF)
  (CL:RETURN-FROM
   ALL-SUPERCOLLECTIONS
   (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR
    SELF
    (CL:FUNCTION ALL-DIRECT-SUPERCOLLECTIONS)
    NULL))
  :VOID)

;;; (DEFUN (ALL-SUBCOLLECTIONS ITERATOR) ...)

(CL:DEFUN ALL-SUBCOLLECTIONS (SELF)
  (CL:RETURN-FROM
   ALL-SUBCOLLECTIONS
   (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR
    SELF
    (CL:FUNCTION ALL-DIRECT-SUBCOLLECTIONS)
    NULL))
  :VOID)

;;; (DEFUN (CLASHES-WITH-FUNCTION-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN CLASHES-WITH-FUNCTION-PROPOSITION? (NEXTPROPOSITION REFERENCEPROPOSITION)
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (CLSYS-SVAL PROPOSITION OPERATOR NEXTPROPOSITION)
     (CLSYS-SVAL PROPOSITION OPERATOR REFERENCEPROPOSITION)))
   (CL:RETURN-FROM CLASHES-WITH-FUNCTION-PROPOSITION? FALSE))
  (CL:LET*
   ((ALWAYS?-001 TRUE))
   (CL:LET*
    ((SUBARG NULL)
     (SUPERARG NULL)
     (ITER-001
      (BUT-LAST (CLSYS-SVAL PROPOSITION ARGUMENTS REFERENCEPROPOSITION)))
     (ITER-002 (BUT-LAST (CLSYS-SVAL PROPOSITION ARGUMENTS NEXTPROPOSITION))))
    (CL:LOOP
     WHILE
     (CL:AND (CL:EQ (NEXT? ITER-001) 1) (CL:EQ (NEXT? ITER-002) 1))
     DO
     (CL:PROGN (CL:SETQ SUPERARG (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:PROGN (CL:SETQ SUBARG (CLSYS-SVAL ITERATOR VALUE ITER-002)))
     (CL:WHEN
      (CL:EQ (EQL? (ARGUMENT-BOUND-TO SUPERARG) (VALUE-OF SUBARG)) 0)
      (CL:SETQ ALWAYS?-001 FALSE)
      (CL:RETURN))))
   (CL:WHEN
    (CL:EQ ALWAYS?-001 1)
    (CL:LET*
     ((LASTSUPERVALUE
       (ARGUMENT-BOUND-TO
        (LAST (CLSYS-SVAL PROPOSITION ARGUMENTS REFERENCEPROPOSITION))))
      (LASTSUBVALUE
       (VALUE-OF (LAST (CLSYS-SVAL PROPOSITION ARGUMENTS NEXTPROPOSITION)))))
     (CL:WHEN
      (CL:AND
       (CL:NOT (CL:EQ LASTSUPERVALUE NULL))
       (CL:NOT (CL:EQ LASTSUBVALUE NULL))
       (CL:EQ (EQL? LASTSUPERVALUE LASTSUBVALUE) 0))
      (CL:RETURN-FROM CLASHES-WITH-FUNCTION-PROPOSITION? TRUE)))))
  (CL:RETURN-FROM CLASHES-WITH-FUNCTION-PROPOSITION? FALSE)
  :VOID)

;;; (DEFUN (ALL-CLASHING-PROPOSITIONS DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR) ...)

(CL:DEFUN ALL-CLASHING-PROPOSITIONS (SELF)
  (CL:LET*
   ((LOGICARGUMENT (FIND-LOGIC-OBJECT-BOUND-TO-ARGUMENT SELF))
    (ITERATOR NULL))
   (CL:WHEN
    (CL:EQ LOGICARGUMENT NULL)
    (CL:RETURN-FROM
     ALL-CLASHING-PROPOSITIONS
     (CAST
      EMPTY-ALL-PROPOSITIONS-ITERATOR
      SGT-SPECIALIZE-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR)))
   (CL:IF
    (CL:EQ (ATTRIBUTE-PROPOSITION? SELF) 1)
    (CL:SETQ
     ITERATOR
     (CAST
      (ALL-DEPENDENT-ATTRIBUTE-PROPOSITIONS
       LOGICARGUMENT
       (CLSYS-SVAL PROPOSITION KIND SELF))
      SGT-SPECIALIZE-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR))
    (CL:SETQ
     ITERATOR
     (CAST
      (ALL-DIRECTLY-DEPENDENT-PROPOSITIONS
       LOGICARGUMENT
       (CLSYS-SVAL PROPOSITION KIND SELF))
      SGT-SPECIALIZE-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL
     DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     REFERENCE-PROPOSITION
     ITERATOR)
    SELF)
   (CL:LET*
    ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND SELF)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-SPECIALIZE-FUNCTION)
      (CL:SETF
       (CLSYS-SVAL
        DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
        SUBSUMPTION-TEST-FILTER?
        ITERATOR)
       (CL:FUNCTION CLASHES-WITH-FUNCTION-PROPOSITION?)))
     (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
   (CL:RETURN-FROM ALL-CLASHING-PROPOSITIONS ITERATOR))
  :VOID)

;;; (DEFGLOBAL *IMPLICATION-SUBSUMPTION-GRAPH* ...)

(CL:DEFVAR *IMPLICATION-SUBSUMPTION-GRAPH* NULL)

;;; (DEFUN (RELATIONS-WITH-DESCRIPTIONS (LIST OF RELATION)) ...)

(CL:DEFUN RELATIONS-WITH-DESCRIPTIONS ()
  (CL:LET*
   ((RESULT (NEW-LIST)))
   (CL:LET*
    ((CLASS NULL) (ITER-001 (ALL-CLASSES NULL FALSE)) (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN
      (CL:SETQ
       CLASS
       (CAST (CLSYS-SVAL ITERATOR VALUE ITER-001) SGT-SPECIALIZE-CLASS)))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE CLASS SYM-SPECIALIZE-DESCRIPTION NULL)
        NULL))
      (CL:IF
       (CL:EQ COLLECT-001 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-001 (PERMANENT-CONS CLASS NIL))
        (CL:IF
         (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST RESULT) NIL)
         (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST RESULT) COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST
          (CLSYS-SVAL LIST THE-CONS-LIST RESULT)
          COLLECT-001)))
       (CL:PROGN
        (CL:SETF
         (CLSYS-SVAL CONS REST COLLECT-001)
         (PERMANENT-CONS CLASS NIL))
        (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001)))))))
   (CL:LET*
    ((SLOT NULL) (ITER-002 (ALL-SLOTS NULL FALSE)) (COLLECT-002 NULL))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-002) 1)
     DO
     (CL:PROGN
      (CL:SETQ
       SLOT
       (CAST (CLSYS-SVAL ITERATOR VALUE ITER-002) SGT-SPECIALIZE-SLOT)))
     (CL:WHEN
      (CL:NOT
       (CL:EQ (DYNAMIC-SLOT-VALUE SLOT SYM-SPECIALIZE-DESCRIPTION NULL) NULL))
      (CL:IF
       (CL:EQ COLLECT-002 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-002 (PERMANENT-CONS SLOT NIL))
        (CL:IF
         (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST RESULT) NIL)
         (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST RESULT) COLLECT-002)
         (ADD-CONS-TO-END-OF-CONS-LIST
          (CLSYS-SVAL LIST THE-CONS-LIST RESULT)
          COLLECT-002)))
       (CL:PROGN
        (CL:SETF (CLSYS-SVAL CONS REST COLLECT-002) (PERMANENT-CONS SLOT NIL))
        (CL:SETQ COLLECT-002 (CLSYS-SVAL CONS REST COLLECT-002)))))))
   (CL:RETURN-FROM RELATIONS-WITH-DESCRIPTIONS RESULT))
  :VOID)

;;; (DEFUN BUILD-SUBSUMPTION-TAXONOMY-GRAPH ...)

(CL:DEFUN BUILD-SUBSUMPTION-TAXONOMY-GRAPH ()
  (CL:LET*
   ((RELATIONSWITHDESCRIPTIONS (RELATIONS-WITH-DESCRIPTIONS)))
   (CL:LET*
    ((R NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST RELATIONSWITHDESCRIPTIONS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       R
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-SPECIALIZE-RELATION))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
      (DYNAMIC-SLOT-VALUE R SYM-SPECIALIZE-DESCRIPTION NULL)
      NULL)))
   (CL:LET*
    ((R NULL)
     (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST RELATIONSWITHDESCRIPTIONS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       R
       (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-SPECIALIZE-RELATION))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:LET*
      ((SUPER NULL)
       (ITER-003 (DIRECT-SUPERCLASSES (CAST R SGT-SPECIALIZE-CLASS))))
      (CL:LOOP
       WHILE
       (CL:EQ (NEXT? ITER-003) 1)
       DO
       (CL:PROGN
        (CL:SETQ
         SUPER
         (CAST (CLSYS-SVAL ITERATOR VALUE ITER-003) SGT-SPECIALIZE-CLASS)))
       (CL:WHEN
        (CL:EQ (MEMBER? RELATIONSWITHDESCRIPTIONS SUPER) 1)
        (LINK-NODES
         *IMPLICATION-SUBSUMPTION-GRAPH*
         (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
          (DYNAMIC-SLOT-VALUE SUPER SYM-SPECIALIZE-DESCRIPTION NULL))
         (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
          (DYNAMIC-SLOT-VALUE R SYM-SPECIALIZE-DESCRIPTION NULL)))))))))
  :VOID)

;;; (DEFUN CLEAR-IMPLICATION-SUBSUMPTION-GRAPH ...)

(CL:DEFUN CLEAR-IMPLICATION-SUBSUMPTION-GRAPH ()
  (CL:LET*
   ((R NULL)
    (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST (RELATIONS-WITH-DESCRIPTIONS))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      R
      (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-SPECIALIZE-RELATION))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:SETF
     (CLSYS-SVAL
      DESCRIPTION
      TAXONOMY-NODE
      (DYNAMIC-SLOT-VALUE R SYM-SPECIALIZE-DESCRIPTION NULL))
     NULL)))
  :VOID)

;;; (DEFUN INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH ...)

(CL:DEFUN INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH ()
  (CLEAR-IMPLICATION-SUBSUMPTION-GRAPH)
  (CL:SETQ *IMPLICATION-SUBSUMPTION-GRAPH* (NEW-TAXONOMY-GRAPH))
  (CREATE-SPANNING-FOREST *IMPLICATION-SUBSUMPTION-GRAPH*)
  :VOID)

;;; (DEFUN (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ...)

(CL:DEFUN FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE (DESCRIPTION)
  (CL:RETURN-FROM
   FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
   (CLSYS-SVAL DESCRIPTION TAXONOMY-NODE DESCRIPTION))
  :VOID)

;;; (DEFUN (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ...)

(CL:DEFUN CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE (DESCRIPTION PARENTNODE)
  (CL:LET*
   ((NODE
     (CREATE-AND-INTERN-NODE
      *IMPLICATION-SUBSUMPTION-GRAPH*
      PARENTNODE
      DESCRIPTION)))
   (CL:SETF (CLSYS-SVAL DESCRIPTION TAXONOMY-NODE DESCRIPTION) NODE)
   (CL:RETURN-FROM CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE NODE))
  :VOID)

;;; (DEFUN (FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ...)

(CL:DEFUN FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE (DESCRIPTION)
  (CL:LET*
   ((RESULT (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE DESCRIPTION)))
   (CL:WHEN
    (CL:NOT (CL:EQ RESULT NULL))
    (CL:RETURN-FROM
     FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
     RESULT))
   (CL:RETURN-FROM
    FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
    (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE DESCRIPTION NULL)))
  :VOID)

;;; (DEFUN (CREATE-DESCRIPTION-FOR-RELATION-AND-ANCESTORS DESCRIPTION) ...)

(CL:DEFUN CREATE-DESCRIPTION-FOR-RELATION-AND-ANCESTORS (SELF)
  (CL:WHEN
   (CL:EQ SELF NULL)
   (CL:RETURN-FROM CREATE-DESCRIPTION-FOR-RELATION-AND-ANCESTORS NULL))
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION SELF))
    (TAXONOMYNODE
     (FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE DESCRIPTION)))
   (CL:LET*
    ((SUPER NULL) (ITER-001 (DIRECT-SUPERRELATIONS SELF)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN
      (CL:SETQ
       SUPER
       (CAST (CLSYS-SVAL ITERATOR VALUE ITER-001) SGT-SPECIALIZE-RELATION)))
     (CL:LET*
      ((SUPERDESCRIPTION
        (CREATE-DESCRIPTION-FOR-RELATION-AND-ANCESTORS SUPER))
       (SUPERTAXONOMYNODE
        (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE SUPERDESCRIPTION)))
      (LINK-NODES
       *IMPLICATION-SUBSUMPTION-GRAPH*
       SUPERTAXONOMYNODE
       TAXONOMYNODE))))
   (CL:RETURN-FROM CREATE-DESCRIPTION-FOR-RELATION-AND-ANCESTORS DESCRIPTION))
  :VOID)

;;; (DEFUN ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK ...)

(CL:DEFUN ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK (TAILDESCRIPTION HEADDESCRIPTION)
  (CL:RETURN-FROM ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK)
  (CL:LET*
   ((PARENTNODE
     (FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
      HEADDESCRIPTION))
    (CHILDNODE
     (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAILDESCRIPTION)))
   (CL:IF
    (CL:NOT (CL:EQ CHILDNODE NULL))
    (LINK-NODES *IMPLICATION-SUBSUMPTION-GRAPH* PARENTNODE CHILDNODE)
    (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
     TAILDESCRIPTION
     PARENTNODE))
   (CREATE-DESCRIPTION-FOR-RELATION-AND-ANCESTORS
    (CLSYS-SVAL DESCRIPTION NATIVE-RELATION HEADDESCRIPTION))
   (CREATE-DESCRIPTION-FOR-RELATION-AND-ANCESTORS
    (CLSYS-SVAL DESCRIPTION NATIVE-RELATION HEADDESCRIPTION)))
  :VOID)

;;; (DEFUN DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK ...)

(CL:DEFUN DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK (TAILDESCRIPTION HEADDESCRIPTION)
  (CL:PROGN
   (CL:SETQ HEADDESCRIPTION HEADDESCRIPTION)
   (CL:SETQ TAILDESCRIPTION TAILDESCRIPTION))
  (CL:RETURN-FROM DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK)
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING
    "'drop-taxonomy-implies-subsumes-link':  Write me, I am a dummy!"
    %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  :VOID)

;;; (DEFUN (TAXONOMY-IMPLIES-OR-IS-SUBSUMED? BOOLEAN) ...)

(CL:DEFUN TAXONOMY-IMPLIES-OR-IS-SUBSUMED? (PREMISE CONCLUSION)
  (CL:LET*
   ((PREMISEDESCRIPTION
     (DYNAMIC-SLOT-VALUE PREMISE SYM-SPECIALIZE-DESCRIPTION NULL))
    (CONCLUSIONDESCRIPTION NULL))
   (CL:WHEN
    (CL:OR
     (CL:EQ PREMISEDESCRIPTION NULL)
     (CL:EQ
      (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE PREMISEDESCRIPTION)
      NULL))
    (CL:SETQ
     PREMISEDESCRIPTION
     (CREATE-DESCRIPTION-FOR-RELATION-AND-ANCESTORS PREMISE)))
   (CL:SETQ
    CONCLUSIONDESCRIPTION
    (DYNAMIC-SLOT-VALUE CONCLUSION SYM-SPECIALIZE-DESCRIPTION NULL))
   (CL:WHEN
    (CL:EQ CONCLUSIONDESCRIPTION NULL)
    (CL:RETURN-FROM TAXONOMY-IMPLIES-OR-IS-SUBSUMED? FALSE))
   (CL:WHEN
    (CL:EQ
     (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE CONCLUSIONDESCRIPTION)
     NULL)
    (CL:ERROR
     "'taxonomy-implies-or-is-subsumed?' conclusionDescription should have taxonomy-node"))
   (CL:RETURN-FROM
    TAXONOMY-IMPLIES-OR-IS-SUBSUMED?
    (TAXONOMY-NODE-SUBCLASS-OF?
     (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE PREMISEDESCRIPTION)
     (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE CONCLUSIONDESCRIPTION))))
  :VOID)

(CL:DEFUN STARTUP-SPECIALIZE ()
  (CL:LET*
   ((*MODULE* (GET-MODULE "/LOGIC" TRUE)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SYM-SPECIALIZE-PROPOSITION-CURSOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION-CURSOR" NULL 0))
    (CL:SETQ
     SYM-SPECIALIZE-KIND-OF-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KIND-OF-PROPOSITION" NULL 0))
    (CL:SETQ
     SYM-SPECIALIZE-ATTRIBUTE-PROPOSITIONS?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ATTRIBUTE-PROPOSITIONS?" NULL 0))
    (CL:SETQ
     SYM-SPECIALIZE-VARIABLE-VALUE-INVERSE-STACK
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-VALUE-INVERSE-STACK" NULL 0))
    (CL:SETQ
     SGT-SPECIALIZE-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-SPECIALIZE-KEYWORD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-SPECIALIZE-BOOLEAN-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "BOOLEAN-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-SPECIALIZE-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR"
      NULL
      1))
    (CL:SETQ
     SYM-SPECIALIZE-SUBSUMPTION-TEST-FILTER?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-TEST-FILTER?" NULL 0))
    (CL:SETQ
     SYM-SPECIALIZE-RETURN-ARGUMENT-INDEX
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN-ARGUMENT-INDEX" NULL 0))
    (CL:SETQ
     SYM-SPECIALIZE-REFERENCE-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REFERENCE-PROPOSITION" NULL 0))
    (CL:SETQ
     SGT-SPECIALIZE-FUNCTION-CODE-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "FUNCTION-CODE-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-SPECIALIZE-INTEGER-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "INTEGER-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-SPECIALIZE-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
    (CL:SETQ
     SGT-SPECIALIZE-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR"
      NULL
      1))
    (CL:SETQ
     SGT-SPECIALIZE-SKOLEM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
    (CL:SETQ
     KWD-SPECIALIZE-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     SGT-SPECIALIZE-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-SPECIALIZE-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
    (CL:SETQ
     SGT-SPECIALIZE-LOGIC-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
    (CL:SETQ
     SGT-SPECIALIZE-SLOTREF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTREF" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     KWD-SPECIALIZE-PREDICATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
    (CL:SETQ KWD-SPECIALIZE-IN (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 2))
    (CL:SETQ
     SYM-SPECIALIZE-PREDICATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "PREDICATE"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-SPECIALIZE-IN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-SPECIALIZE-ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "ALLOCATE-ADJACENCY-ITERATOR-FUNCTION"
      NULL
      0))
    (CL:SETQ
     SYM-SPECIALIZE-FILTER?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FILTER?" NULL 0))
    (CL:SETQ
     SYM-SPECIALIZE-ADJACENCY-ITERATOR-STACK
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ADJACENCY-ITERATOR-STACK" NULL 0))
    (CL:SETQ
     SYM-SPECIALIZE-BEEN-THERE-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BEEN-THERE-LIST" NULL 0))
    (CL:SETQ
     SGT-SPECIALIZE-TRANSITIVE-CLOSURE-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSITIVE-CLOSURE-ITERATOR" NULL 1))
    (CL:SETQ
     SYM-SPECIALIZE-INVERSE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INVERSE?" NULL 0))
    (CL:SETQ
     SYM-SPECIALIZE-REFERENCE-INSTANCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REFERENCE-INSTANCE" NULL 0))
    (CL:SETQ
     SGT-SPECIALIZE-DIRECT-SUPERCOLLECTIONS-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "DIRECT-SUPERCOLLECTIONS-ITERATOR"
      NULL
      1))
    (CL:SETQ
     KWD-SPECIALIZE-IMPLIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
    (CL:SETQ
     SGT-SPECIALIZE-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-SPECIALIZE-RELATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "RELATION"
      (GET-MODULE "/STELLA" TRUE)
      1)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:SETQ
     EMPTY-ALL-PROPOSITIONS-ITERATOR
     (NEW-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR))
    (CL:SETQ
     BLANK-PROPERTY-PROPOSITION
     (CREATE-PROPOSITION SYM-SPECIALIZE-PREDICATE 1))
    (CL:SETQ BLANK-IN-PROPOSITION (CREATE-PROPOSITION SYM-SPECIALIZE-IN 2)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 5) 1)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR"
        "(DEFCLASS ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR (ITERATOR) :SLOTS ((PROPOSITION-CURSOR :TYPE (CONS OF PROPOSITION) :INITIALLY NIL) (KIND-OF-PROPOSITION :TYPE KEYWORD) (ATTRIBUTE-PROPOSITIONS? :TYPE BOOLEAN) (VARIABLE-VALUE-INVERSE-STACK :TYPE (CONS OF CONS) :INITIALLY NIL)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION
       ACCESS-ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR"
        "(DEFCLASS DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR (ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR) :SLOTS ((SUBSUMPTION-TEST-FILTER? :TYPE FUNCTION-CODE) (RETURN-ARGUMENT-INDEX :TYPE INTEGER) (REFERENCE-PROPOSITION :TYPE PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION
       ACCESS-DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "TRANSITIVE-CLOSURE-ITERATOR"
        "(DEFCLASS TRANSITIVE-CLOSURE-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator that visits all nodes reachable using an
embedded adjacency function.\" :SLOTS ((ALLOCATE-ADJACENCY-ITERATOR-FUNCTION :TYPE FUNCTION-CODE) (FILTER? :TYPE FUNCTION-CODE) (ADJACENCY-ITERATOR-STACK :TYPE (CONS OF ITERATOR) :INITIALLY NIL) (BEEN-THERE-LIST :TYPE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRANSITIVE-CLOSURE-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TRANSITIVE-CLOSURE-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "DIRECT-SUPERCOLLECTIONS-ITERATOR"
        "(DEFCLASS DIRECT-SUPERCOLLECTIONS-ITERATOR (ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((INVERSE? :TYPE BOOLEAN) (REFERENCE-INSTANCE :TYPE LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-DIRECT-SUPERCOLLECTIONS-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-DIRECT-SUPERCOLLECTIONS-ITERATOR-SLOT-VALUE))))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM"
        "ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR"
        "(DEFUN (FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM (CONS OF PROPOSITION)) ((SELF ABSTRACT-DEPENDENT-PROPOSITIONS-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-PROPOSITIONS-ON-NEXT-EQUIVALENT-SKOLEM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-DIRECTLY-DEPENDENT-PROPOSITIONS"
        "LOGIC-OBJECT"
        "(DEFUN (ALL-DIRECTLY-DEPENDENT-PROPOSITIONS ITERATOR) ((SELF LOGIC-OBJECT) (KIND KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-DIRECTLY-DEPENDENT-PROPOSITIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-DEPENDENT-ATTRIBUTE-PROPOSITIONS"
        "LOGIC-OBJECT"
        "(DEFUN (ALL-DEPENDENT-ATTRIBUTE-PROPOSITIONS (ITERATOR OF PROPOSITION)) ((SELF LOGIC-OBJECT) (KIND KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-DEPENDENT-ATTRIBUTE-PROPOSITIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SLOTREF-SPECIALIZES-SLOTREF?"
        "SLOTREF"
        "(DEFUN (SLOTREF-SPECIALIZES-SLOTREF? BOOLEAN) ((SLOTREF1 SLOTREF) (SLOTREF2 SLOTREF)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SLOTREF-SPECIALIZES-SLOTREF?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-LOGIC-OBJECT-BOUND-TO-ARGUMENT"
        "PROPOSITION"
        "(DEFUN (FIND-LOGIC-OBJECT-BOUND-TO-ARGUMENT LOGIC-OBJECT) ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-LOGIC-OBJECT-BOUND-TO-ARGUMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SPECIALIZES-PREDICATE-PROPOSITION?"
        "PROPOSITION"
        "(DEFUN (SPECIALIZES-PREDICATE-PROPOSITION? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SPECIALIZES-PREDICATE-PROPOSITION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SPECIALIZES-IN-PROPOSITION?"
        "PROPOSITION"
        "(DEFUN (SPECIALIZES-IN-PROPOSITION? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SPECIALIZES-IN-PROPOSITION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FAILING-SUBSUMPTION-TEST?"
        "PROPOSITION"
        "(DEFUN (FAILING-SUBSUMPTION-TEST? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FAILING-SUBSUMPTION-TEST?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-SPECIALIZING-PROPOSITIONS"
        "PROPOSITION"
        "(DEFUN (ALL-SPECIALIZING-PROPOSITIONS (ITERATOR OF PROPOSITION)) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-SPECIALIZING-PROPOSITIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SPECIALIZES-ATTRIBUTE-PROPOSITION?"
        "PROPOSITION"
        "(DEFUN (SPECIALIZES-ATTRIBUTE-PROPOSITION? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SPECIALIZES-ATTRIBUTE-PROPOSITION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FAST-GET-ATTRIBUTE-PROPOSITION-VALUE"
        "LOGIC-OBJECT"
        "(DEFUN (FAST-GET-ATTRIBUTE-PROPOSITION-VALUE OBJECT) ((SELF LOGIC-OBJECT) (RELATION SLOTREF)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FAST-GET-ATTRIBUTE-PROPOSITION-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-ATTRIBUTE-PROPOSITION-VALUE"
        "LOGIC-OBJECT"
        "(DEFUN (GET-ATTRIBUTE-PROPOSITION-VALUE OBJECT) ((SELF LOGIC-OBJECT) (RELATION SLOTREF)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-ATTRIBUTE-PROPOSITION-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SPECIALIZES-PROPERTY-PROPOSITION?"
        "PROPOSITION"
        "(DEFUN (SPECIALIZES-PROPERTY-PROPOSITION? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SPECIALIZES-PROPERTY-PROPOSITION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXISTS-PROPERTY-PROPOSITION?"
        "LOGIC-OBJECT"
        "(DEFUN (EXISTS-PROPERTY-PROPOSITION? BOOLEAN) ((SELF LOGIC-OBJECT) (RELATION SLOTREF)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXISTS-PROPERTY-PROPOSITION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXISTS-SPECIALIZING-IN-PROPOSITION?"
        "LOGIC-OBJECT"
        "(DEFUN (EXISTS-SPECIALIZING-IN-PROPOSITION? BOOLEAN) ((MEMBER LOGIC-OBJECT) (COLLECTION OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXISTS-SPECIALIZING-IN-PROPOSITION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MATCHES-IN-PROPOSITION-COLLECTION-ARGUMENT?"
        "PROPOSITION"
        "(DEFUN (MATCHES-IN-PROPOSITION-COLLECTION-ARGUMENT? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MATCHES-IN-PROPOSITION-COLLECTION-ARGUMENT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-IN-PROPOSITION-MEMBERS"
        "LOGIC-OBJECT"
        "(DEFUN (ALL-IN-PROPOSITION-MEMBERS DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR) ((COLLECTION LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-IN-PROPOSITION-MEMBERS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE"
        "TRANSITIVE-CLOSURE-ITERATOR"
        "(DEFMETHOD FREE ((SELF TRANSITIVE-CLOSURE-ITERATOR)))")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION FREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "TRANSITIVE-CLOSURE-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF TRANSITIVE-CLOSURE-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR"
        "OBJECT"
        "(DEFUN (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR ITERATOR) ((STARTNODE OBJECT) (ALLOCATEADJACENCYITERATOR FUNCTION-CODE) (FILTERFUNCTION FUNCTION-CODE)) :DOCUMENTATION \"Return an iterator that generates the transitive
closure of applying iterators generated by 'allocateAdjacencyIterator'
to 'startNode'.  If 'filterFunction' is non-null, that function is applied
as a filter to each node generated (nodes filtered out still generate
descendants, but they don't get returned).\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "DIRECT-SUPERCOLLECTIONS-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF DIRECT-SUPERCOLLECTIONS-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-DIRECTLY-LINKED-OBJECTS"
        "LOGIC-OBJECT"
        "(DEFUN (ALL-DIRECTLY-LINKED-OBJECTS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT) (KIND KEYWORD) (INVERSE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-DIRECTLY-LINKED-OBJECTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-DIRECT-SUPERCOLLECTIONS"
        "LOGIC-OBJECT"
        "(DEFUN (ALL-DIRECT-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-DIRECT-SUPERCOLLECTIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-DIRECT-SUBCOLLECTIONS"
        "LOGIC-OBJECT"
        "(DEFUN (ALL-DIRECT-SUBCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-DIRECT-SUBCOLLECTIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-SUPERCOLLECTIONS"
        "LOGIC-OBJECT"
        "(DEFUN (ALL-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-SUPERCOLLECTIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-SUBCOLLECTIONS"
        "LOGIC-OBJECT"
        "(DEFUN (ALL-SUBCOLLECTIONS ITERATOR) ((SELF LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-SUBCOLLECTIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASHES-WITH-FUNCTION-PROPOSITION?"
        "PROPOSITION"
        "(DEFUN (CLASHES-WITH-FUNCTION-PROPOSITION? BOOLEAN) ((NEXTPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASHES-WITH-FUNCTION-PROPOSITION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-CLASHING-PROPOSITIONS"
        "PROPOSITION"
        "(DEFUN (ALL-CLASHING-PROPOSITIONS DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-CLASHING-PROPOSITIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RELATIONS-WITH-DESCRIPTIONS"
        NULL
        "(DEFUN (RELATIONS-WITH-DESCRIPTIONS (LIST OF RELATION)) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RELATIONS-WITH-DESCRIPTIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUILD-SUBSUMPTION-TAXONOMY-GRAPH"
        NULL
        "(DEFUN BUILD-SUBSUMPTION-TAXONOMY-GRAPH ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BUILD-SUBSUMPTION-TAXONOMY-GRAPH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR-IMPLICATION-SUBSUMPTION-GRAPH"
        NULL
        "(DEFUN CLEAR-IMPLICATION-SUBSUMPTION-GRAPH ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLEAR-IMPLICATION-SUBSUMPTION-GRAPH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH"
        NULL
        "(DEFUN INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE"
        "DESCRIPTION"
        "(DEFUN (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ((DESCRIPTION DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE"
        "DESCRIPTION"
        "(DEFUN (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ((DESCRIPTION DESCRIPTION) (PARENTNODE TAXONOMY-NODE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE"
        "DESCRIPTION"
        "(DEFUN (FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ((DESCRIPTION DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-DESCRIPTION-FOR-RELATION-AND-ANCESTORS"
        "RELATION"
        "(DEFUN (CREATE-DESCRIPTION-FOR-RELATION-AND-ANCESTORS DESCRIPTION) ((SELF RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-DESCRIPTION-FOR-RELATION-AND-ANCESTORS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK"
        "DESCRIPTION"
        "(DEFUN ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK ((TAILDESCRIPTION DESCRIPTION) (HEADDESCRIPTION DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK"
        "DESCRIPTION"
        "(DEFUN DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK ((TAILDESCRIPTION DESCRIPTION) (HEADDESCRIPTION DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TAXONOMY-IMPLIES-OR-IS-SUBSUMED?"
        "RELATION"
        "(DEFUN (TAXONOMY-IMPLIES-OR-IS-SUBSUMED? BOOLEAN) ((PREMISE RELATION) (CONCLUSION RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TAXONOMY-IMPLIES-OR-IS-SUBSUMED?)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-SPECIALIZE"
     NULL
     "(DEFUN STARTUP-SPECIALIZE ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT EMPTY-ALL-PROPOSITIONS-ITERATOR (ITERATOR OF PROPOSITION) (NEW DIRECTLY-DEPENDENT-PROPOSITIONS-ITERATOR) :DOCUMENTATION \"This iterator returns no values whenever its called.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT BLANK-PROPERTY-PROPOSITION PROPOSITION (CREATE-PROPOSITION (QUOTE PREDICATE) 1) :DOCUMENTATION \"Used by 'exists-property-proposition' to construct an
on-the-fly unary predicate proposition.\" :PUBLIC? FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT BLANK-IN-PROPOSITION PROPOSITION (CREATE-PROPOSITION (QUOTE IN) 2) :DOCUMENTATION \"Used by 'DESCRIPTION-EXTENSION-ITERATOR.next? to quickly
construct an IN proposition to be passed to 'all-specializing-propositions'
during filtering of generated instances.\" :PUBLIC? FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *IMPLICATION-SUBSUMPTION-GRAPH* TAXONOMY-GRAPH NULL)")
    (INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH)))
  :VOID)
