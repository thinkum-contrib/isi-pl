;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997                   | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-OPTIMIZE-GENERATOR-GOALS NULL)
(CL:DEFVAR SYM-OPTIMIZE-OTHER-GOALS NULL)
(CL:DEFVAR SGT-OPTIMIZE-LIST NULL)
(CL:DEFVAR SGT-OPTIMIZE-GOAL-RECORD NULL)
(CL:DEFVAR SGT-OPTIMIZE-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-OPTIMIZE-PROPOSITION NULL)
(CL:DEFVAR KWD-OPTIMIZE-OR NULL)
(CL:DEFVAR SGT-OPTIMIZE-SLOTREF NULL)
(CL:DEFVAR SGT-OPTIMIZE-SLOT NULL)
(CL:DEFVAR SYM-OPTIMIZE-PERMUTATION-TABLE NULL)
(CL:DEFVAR SGT-OPTIMIZE-LITERAL NULL)
(CL:DEFVAR SGT-OPTIMIZE-DESCRIPTION NULL)
(CL:DEFVAR SGT-OPTIMIZE-CLASS NULL)
(CL:DEFVAR SYM-OPTIMIZE-*DISTRIBUTEDOPENGOAL?* NULL)
(CL:DEFVAR KWD-OPTIMIZE-FUNCTION NULL)
(CL:DEFVAR KWD-OPTIMIZE-EQUIVALENT NULL)
(CL:DEFVAR KWD-OPTIMIZE-IN NULL)
(CL:DEFVAR KWD-OPTIMIZE-PREDICATE NULL)
(CL:DEFVAR KWD-OPTIMIZE-NOT NULL)
(CL:DEFVAR SYM-OPTIMIZE-UNIQUENESSVECTORS NULL)
(CL:DEFVAR SYM-OPTIMIZE-INDEXING-VECTOR NULL)
(CL:DEFVAR SGT-OPTIMIZE-TYPE NULL)
(CL:DEFVAR SYM-OPTIMIZE-INVERSE NULL)
(CL:DEFVAR SYM-OPTIMIZE-DESCRIPTION NULL)
(CL:DEFVAR SYM-OPTIMIZE-ESTIMATED-CARDINALITY NULL)
(CL:DEFVAR SGT-OPTIMIZE-LITERAL-WRAPPER NULL)
(CL:DEFVAR KWD-OPTIMIZE-OPEN NULL)
(CL:DEFVAR SGT-OPTIMIZE-BOOLEAN-VECTOR NULL)
(CL:DEFVAR SGT-OPTIMIZE-COLLECTION NULL)
(CL:DEFVAR KWD-OPTIMIZE-FORALL NULL)
(CL:DEFVAR KWD-OPTIMIZE-BOUND NULL)
(CL:DEFVAR KWD-OPTIMIZE-AND NULL)
(CL:DEFVAR KWD-OPTIMIZE-IMPLIES NULL)
(CL:DEFVAR KWD-OPTIMIZE-EXISTS NULL)
(CL:DEFVAR SYM-OPTIMIZE-*QUERYOPTIMIZERCONTROLFRAME* NULL)
(CL:DEFVAR KWD-OPTIMIZE-PATTERN NULL)
(CL:DEFVAR SYM-OPTIMIZE-*POSTOPTIMIZATION?* NULL)
(CL:DEFVAR SYM-OPTIMIZE-ENTITY-MAPPING NULL)
(CL:DEFVAR KWD-OPTIMIZE-REALISTIC NULL)
(CL:DEFVAR KWD-OPTIMIZE-FLAT NULL)
(CL:DEFVAR SYM-OPTIMIZE-SKOLEM-NAME NULL)
(CL:DEFVAR SYM-OPTIMIZE-VARIABLE-TYPE? NULL)
(CL:DEFVAR SYM-OPTIMIZE-IO-VARIABLES NULL)
(CL:DEFVAR SGT-OPTIMIZE-SKOLEM NULL)
(CL:DEFVAR SGT-OPTIMIZE-SURROGATE NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *MODULE*
  NULL-BOOLEAN-WRAPPER
  ZERO-VARIABLES-VECTOR
  *PRINTMODE*
  TRUE-PROPOSITION
  *QUERYOPTIMIZERCONTROLFRAME*
  EOL
  TRUE-WRAPPER
  FALSE-WRAPPER
  NULL-INTEGER-WRAPPER
  ONE-WRAPPER
  ZERO-WRAPPER
  NIL-LIST
  *REVERSEPOLARITY?*
  *QUERYENVIRONMENT*))

;;; (DEFCLASS GOAL-RECORD ...)

(CL:DEFCLASS GOAL-RECORD (STANDARD-OBJECT)
  ((GENERATOR-GOALS :ALLOCATION :INSTANCE :ACCESSOR GENERATOR-GOALS...OF)
   (OTHER-GOALS :ALLOCATION :INSTANCE :ACCESSOR OTHER-GOALS...OF)))

(CL:DEFUN NEW-GOAL-RECORD ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE GOAL-RECORD)))
   (CL:SETF (CLSYS-SVAL GOAL-RECORD OTHER-GOALS SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL GOAL-RECORD GENERATOR-GOALS SELF) (NEW-LIST))
   (CL:RETURN-FROM NEW-GOAL-RECORD SELF))
  :VOID)

(CL:DEFUN ACCESS-GOAL-RECORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-OPTIMIZE-GENERATOR-GOALS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GOAL-RECORD GENERATOR-GOALS SELF)
      (CAST VALUE SGT-OPTIMIZE-LIST))
     (CL:RETURN-FROM
      ACCESS-GOAL-RECORD-SLOT-VALUE
      (CLSYS-SVAL GOAL-RECORD GENERATOR-GOALS SELF))))
   ((CL:EQ SLOTNAME SYM-OPTIMIZE-OTHER-GOALS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GOAL-RECORD OTHER-GOALS SELF)
      (CAST VALUE SGT-OPTIMIZE-LIST))
     (CL:RETURN-FROM
      ACCESS-GOAL-RECORD-SLOT-VALUE
      (CLSYS-SVAL GOAL-RECORD OTHER-GOALS SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-GOAL-RECORD-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF GOAL-RECORD))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-OPTIMIZE-GOAL-RECORD)
  :VOID)

;;; (DEFUN (VARIABLE-BOUND? BOOLEAN) ...)

(CL:DEFUN VARIABLE-BOUND? (VARIABLE)
  (CL:RETURN-FROM
   VARIABLE-BOUND?
   (CL:IF
    (CL:OR
     (CL:NOT (CL:EQ (BOUND-TO VARIABLE) NULL))
     (CL:NOT
      (CL:EQ
       (ACCESS-IN-CONTEXT
        (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE VARIABLE)
        VARIABLE
        FALSE)
       NULL)))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (ARGUMENT-BOUND? BOOLEAN) ...)

(CL:DEFUN ARGUMENT-BOUND? (ARGUMENT)
  (CL:LET*
   ((ARGUMENT-001 ARGUMENT))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? ARGUMENT SGT-OPTIMIZE-PATTERN-VARIABLE) 1)
     (CL:LET*
      ((ARGUMENT NULL))
      (CL:SETQ ARGUMENT ARGUMENT-001)
      (CL:RETURN-FROM ARGUMENT-BOUND? (VARIABLE-BOUND? ARGUMENT))))
    ((CL:EQ (TAXONOMY-ISA? ARGUMENT SGT-OPTIMIZE-PROPOSITION) 1)
     (CL:LET*
      ((ARGUMENT NULL))
      (CL:SETQ ARGUMENT ARGUMENT-001)
      (CL:RETURN-FROM ARGUMENT-BOUND? (ALL-ARGUMENTS-BOUND? ARGUMENT))))
    (CL:T (CL:RETURN-FROM ARGUMENT-BOUND? TRUE))))
  :VOID)

;;; (DEFUN (UNBOUND-VARIABLE? BOOLEAN) ...)

(CL:DEFUN UNBOUND-VARIABLE? (ARGUMENT)
  (CL:LET*
   ((ARGUMENT-001 ARGUMENT))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? ARGUMENT SGT-OPTIMIZE-PATTERN-VARIABLE) 1)
     (CL:LET*
      ((ARGUMENT NULL))
      (CL:SETQ ARGUMENT ARGUMENT-001)
      (CL:RETURN-FROM
       UNBOUND-VARIABLE?
       (CL:IF (CL:EQ (VARIABLE-BOUND? ARGUMENT) 0) TRUE FALSE))))
    (CL:T (CL:RETURN-FROM UNBOUND-VARIABLE? FALSE))))
  :VOID)

;;; (DEFUN (HAS-DISJUNCTION? BOOLEAN) ...)

(CL:DEFUN HAS-DISJUNCTION? (GOAL)
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL PROPOSITION KIND GOAL) KWD-OPTIMIZE-OR)
   (CL:RETURN-FROM HAS-DISJUNCTION? TRUE))
  (CL:LET*
   ((FOUND?-001 FALSE))
   (CL:LET*
    ((ARG NULL)
     (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       ARG
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:WHEN
      (CL:AND
       (CL:EQ (ISA? ARG SGT-OPTIMIZE-PROPOSITION) 1)
       (CL:EQ (HAS-DISJUNCTION? (CAST ARG SGT-OPTIMIZE-PROPOSITION)) 1))
      (CL:SETQ FOUND?-001 TRUE)
      (CL:RETURN))))
   (CL:LET*
    ((VALUE-001 FOUND?-001))
    (CL:RETURN-FROM HAS-DISJUNCTION? VALUE-001)))
  :VOID)

;;; (DEFUN (MODAL-GOAL? BOOLEAN) ...)

(CL:DEFUN MODAL-GOAL? (GOAL)
  (CL:LET*
   ((FOUND?-001 FALSE))
   (CL:LET*
    ((ARG NULL)
     (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       ARG
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:WHEN
      (CL:EQ (ISA? ARG SGT-OPTIMIZE-PROPOSITION) 1)
      (CL:SETQ FOUND?-001 TRUE)
      (CL:RETURN))))
   (CL:LET* ((VALUE-001 FOUND?-001)) (CL:RETURN-FROM MODAL-GOAL? VALUE-001)))
  :VOID)

;;; (DEFUN (HAS-INVERSIONS? BOOLEAN) ...)

(CL:DEFUN HAS-INVERSIONS? (GOAL)
  (CL:RETURN-FROM
   HAS-INVERSIONS?
   (DEFINED?
    (DYNAMIC-SLOT-VALUE
     (CAST
      (CLSYS-SVAL
       SURROGATE
       SURROGATE-VALUE
       (CAST (CLSYS-SVAL PROPOSITION OPERATOR GOAL) SGT-OPTIMIZE-SLOTREF))
      SGT-OPTIMIZE-SLOT)
     SYM-OPTIMIZE-PERMUTATION-TABLE
     NULL)))
  :VOID)

;;; (DEFUN (COMPUTED-PREDICATE? BOOLEAN) ...)

(CL:DEFUN COMPUTED-PREDICATE? (PREDICATEPROPOSITION)
  (CL:LET*
   ((SLOT
     (CAST
      (CLSYS-SVAL
       SURROGATE
       SURROGATE-VALUE
       (CAST
        (CLSYS-SVAL PROPOSITION OPERATOR PREDICATEPROPOSITION)
        SGT-OPTIMIZE-SLOTREF))
      SGT-OPTIMIZE-SLOT)))
   (CL:LET*
    ((SLOT-001 SLOT))
    (CL:COND
     ((CL:EQ (METHOD-SLOT? SLOT) 1)
      (CL:LET*
       ((SLOT NULL))
       (CL:SETQ SLOT SLOT-001)
       (CL:RETURN-FROM
        COMPUTED-PREDICATE?
        (CL:IF
         (CL:OR
          (CL:NOT (CL:EQ (CLSYS-SVAL METHOD-SLOT METHOD-CODE SLOT) NULL))
          (CL:NOT (CL:EQ (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE SLOT) NULL)))
         TRUE
         FALSE))))
     (CL:T (CL:RETURN-FROM COMPUTED-PREDICATE? FALSE)))))
  :VOID)

;;; (DEFUN (SIMULATE-CREATE-CHOICE-POINT INTEGER) ...)

(CL:DEFUN SIMULATE-CREATE-CHOICE-POINT ()
  (CL:RETURN-FROM
   SIMULATE-CREATE-CHOICE-POINT
   (CL:1+
    (CLSYS-SVAL
     QUERY-ENVIRONMENT
     TOP-UNBINDING-STACK-OFFSET
     *QUERYENVIRONMENT*)))
  :VOID)

;;; (DEFUN (CLASS-INHERITS-ENUMERATED-EXTENSION? BOOLEAN) ...)

(CL:DEFUN CLASS-INHERITS-ENUMERATED-EXTENSION? (CLASS)
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL CLASS ABSTRACT? CLASS) 1)
   (CL:RETURN-FROM CLASS-INHERITS-ENUMERATED-EXTENSION? FALSE))
  (CL:LET*
   ((ROOTCLASS (LEFTMOST-CONCRETE-SUPERCLASS CLASS)))
   (CL:RETURN-FROM
    CLASS-INHERITS-ENUMERATED-EXTENSION?
    (CL:IF
     (CL:EQ
      (SUBTYPE-OF?
       (CLSYS-SVAL CLASS CLASS-TYPE ROOTCLASS)
       SGT-OPTIMIZE-LITERAL)
      0)
     TRUE
     FALSE)))
  :VOID)

;;; (DEFUN (GENERATOR-COLLECTION? BOOLEAN) ...)

(CL:DEFUN GENERATOR-COLLECTION? (COLLECTION)
  (CL:WHEN
   (CL:AND
    (CL:EQ *REVERSEPOLARITY?* 1)
    (CL:EQ (CLOSED-COLLECTION? COLLECTION) 0))
   (CL:RETURN-FROM GENERATOR-COLLECTION? FALSE))
  (CL:LET*
   ((COLLECTION-001 COLLECTION))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? COLLECTION SGT-OPTIMIZE-DESCRIPTION) 1)
     (CL:LET*
      ((COLLECTION NULL))
      (CL:SETQ COLLECTION COLLECTION-001)
      (CL:RETURN-FROM
       GENERATOR-COLLECTION?
       (CL:IF
        (CL:AND
         (CL:NOT
          (CL:EQ (CLSYS-SVAL DESCRIPTION NATIVE-RELATION COLLECTION) NULL))
         (CL:EQ
          (CLASS-INHERITS-ENUMERATED-EXTENSION?
           (CAST
            (CLSYS-SVAL DESCRIPTION NATIVE-RELATION COLLECTION)
            SGT-OPTIMIZE-CLASS))
          1))
        TRUE
        FALSE))))
    ((CL:EQ (TAXONOMY-ISA? COLLECTION SGT-OPTIMIZE-PATTERN-VARIABLE) 1)
     (CL:LET*
      ((COLLECTION NULL))
      (CL:SETQ COLLECTION COLLECTION-001)
      (CL:LET*
       ((BOUNDTOVALUE (ARGUMENT-BOUND-TO COLLECTION)))
       (CL:COND
        ((CL:NOT (CL:EQ BOUNDTOVALUE NULL))
         (CL:RETURN-FROM
          GENERATOR-COLLECTION?
          (GENERATOR-COLLECTION? BOUNDTOVALUE)))
        ((CL:NOT
          (CL:EQ
           (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION COLLECTION)
           NULL))
         (CL:RETURN-FROM GENERATOR-COLLECTION? TRUE))
        (CL:T (CL:RETURN-FROM GENERATOR-COLLECTION? FALSE))))))
    (CL:T (CL:RETURN-FROM GENERATOR-COLLECTION? TRUE))))
  :VOID)

;;; (DEFUN INITIALIZE-OPTIMIZER-GOAL-RECORDS ...)

(CL:DEFUN INITIALIZE-OPTIMIZER-GOAL-RECORDS (SIZE)
  (CL:LET*
   ((STACK
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      OPTIMIZER-GOAL-RECORDS
      *QUERYENVIRONMENT*)))
   (CL:WHEN
    (CL:EQ STACK NULL)
    (CL:SETQ STACK (NEW-EXTENSIBLE-VECTOR 20))
    (CL:SETF
     (CLSYS-SVAL QUERY-ENVIRONMENT OPTIMIZER-GOAL-RECORDS *QUERYENVIRONMENT*)
     STACK))
   (CL:WHEN
    (CL:> SIZE (LENGTH STACK))
    (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY STACK) SIZE) NULL))
   (CL:LET*
    ((I NULL) (ITER-001 0) (UPPER-BOUND-001 (CL:1- SIZE)))
    (CL:LOOP
     WHILE
     (CL:<= ITER-001 UPPER-BOUND-001)
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:LET*
      ((GOALRECORD (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY STACK) I)))
      (CL:WHEN
       (CL:EQ GOALRECORD NULL)
       (CL:SETQ GOALRECORD (NEW-GOAL-RECORD))
       (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY STACK) I) GOALRECORD))
      (CLEAR (CLSYS-SVAL GOAL-RECORD GENERATOR-GOALS GOALRECORD))
      (CLEAR (CLSYS-SVAL GOAL-RECORD OTHER-GOALS GOALRECORD))))))
  :VOID)

;;; (DEFUN (GOAL-RECORD GOAL-RECORD) ...)

(CL:DEFUN GOAL-RECORD (VARIABLE)
  (CL:RETURN-FROM
   GOAL-RECORD
   (CL:AREF
    (CLSYS-SVAL
     VECTOR
     THE-ARRAY
     (CLSYS-SVAL QUERY-ENVIRONMENT OPTIMIZER-GOAL-RECORDS *QUERYENVIRONMENT*))
    (CLSYS-SVAL PATTERN-VARIABLE BOUND-TO-OFFSET VARIABLE)))
  :VOID)

;;; (DEFSPECIAL *DISTRIBUTEDOPENGOAL?* ...)

(CL:DEFVAR *DISTRIBUTEDOPENGOAL?*)

(CL:DEFUN READ-*DISTRIBUTEDOPENGOAL?* ()
  (CL:RETURN-FROM READ-*DISTRIBUTEDOPENGOAL?* *DISTRIBUTEDOPENGOAL?*)
  :VOID)

(CL:DEFUN WRITE-*DISTRIBUTEDOPENGOAL?* (VALUE)
  (CL:SETQ *DISTRIBUTEDOPENGOAL?* VALUE)
  (CL:RETURN-FROM WRITE-*DISTRIBUTEDOPENGOAL?* VALUE)
  :VOID)

;;; (DEFUN HELP-DISTRIBUTE-GOAL ...)

(CL:DEFUN HELP-DISTRIBUTE-GOAL (ARGUMENT PARENTGOAL GENERATOR?)
  (CL:LET*
   ((ARGUMENT-001 ARGUMENT))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? ARGUMENT SGT-OPTIMIZE-PATTERN-VARIABLE) 1)
     (CL:LET*
      ((ARGUMENT NULL))
      (CL:SETQ ARGUMENT ARGUMENT-001)
      (CL:WHEN
       (CL:EQ (VARIABLE-BOUND? ARGUMENT) 1)
       (CL:RETURN-FROM HELP-DISTRIBUTE-GOAL))
      (CL:LET*
       ((GOALRECORD (GOAL-RECORD ARGUMENT)))
       (CL:WHEN
        (CL:OR
         (CL:EQ
          (MEMBER?
           (CLSYS-SVAL GOAL-RECORD GENERATOR-GOALS GOALRECORD)
           PARENTGOAL)
          1)
         (CL:EQ
          (MEMBER? (CLSYS-SVAL GOAL-RECORD OTHER-GOALS GOALRECORD) PARENTGOAL)
          1))
        (CL:RETURN-FROM HELP-DISTRIBUTE-GOAL))
       (CL:IF
        (CL:EQ GENERATOR? 1)
        (INSERT
         (CLSYS-SVAL GOAL-RECORD GENERATOR-GOALS GOALRECORD)
         PARENTGOAL)
        (INSERT (CLSYS-SVAL GOAL-RECORD OTHER-GOALS GOALRECORD) PARENTGOAL))
       (CL:SETQ *DISTRIBUTEDOPENGOAL?* TRUE))))
    ((CL:EQ (TAXONOMY-ISA? ARGUMENT SGT-OPTIMIZE-PROPOSITION) 1)
     (CL:LET*
      ((ARGUMENT NULL))
      (CL:SETQ ARGUMENT ARGUMENT-001)
      (CL:LET*
       ((ARG NULL)
        (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS ARGUMENT))
        (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:LOOP
        WHILE
        (CL:< INDEX-001 LENGTH-001)
        DO
        (CL:PROGN
         (CL:SETQ
          ARG
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
        (HELP-DISTRIBUTE-GOAL ARG PARENTGOAL GENERATOR?)))))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN DISTRIBUTE-OPEN-GOAL ...)

(CL:DEFUN DISTRIBUTE-OPEN-GOAL (GOAL)
  (CL:LET*
   ((*DISTRIBUTEDOPENGOAL?* FALSE))
   (CL:DECLARE (CL:SPECIAL *DISTRIBUTEDOPENGOAL?*))
   (CL:LET*
    ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND GOAL)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-FUNCTION)
      (CL:LET*
       ((ARG NULL)
        (ITER-001 (BUT-LAST (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))))
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? ITER-001) 1)
        DO
        (CL:PROGN (CL:SETQ ARG (CLSYS-SVAL ITERATOR VALUE ITER-001)))
        (HELP-DISTRIBUTE-GOAL
         ARG
         GOAL
         (CL:IF (CL:EQ (COMPUTED-PREDICATE? GOAL) 0) TRUE FALSE))))
      (HELP-DISTRIBUTE-GOAL (LAST-ARGUMENT GOAL) GOAL FALSE))
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-EQUIVALENT)
      (CL:LET*
       ((ARG NULL)
        (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))
        (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:LOOP
        WHILE
        (CL:< INDEX-001 LENGTH-001)
        DO
        (CL:PROGN
         (CL:SETQ
          ARG
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
        (HELP-DISTRIBUTE-GOAL ARG GOAL FALSE))))
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-IN)
      (HELP-DISTRIBUTE-GOAL
       (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))
       GOAL
       (GENERATOR-COLLECTION?
        (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))))
      (HELP-DISTRIBUTE-GOAL
       (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))
       GOAL
       FALSE))
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-PREDICATE)
      (CL:LET*
       ((ARG NULL)
        (VECTOR-002 (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))
        (INDEX-002 0)
        (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:LOOP
        WHILE
        (CL:< INDEX-002 LENGTH-002)
        DO
        (CL:PROGN
         (CL:SETQ
          ARG
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
         (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
        (HELP-DISTRIBUTE-GOAL
         ARG
         GOAL
         (CL:IF (CL:EQ (COMPUTED-PREDICATE? GOAL) 0) TRUE FALSE)))))
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-NOT)
      (HELP-DISTRIBUTE-GOAL
       (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))
       GOAL
       FALSE))
     (CL:T NULL)))
   (CL:WHEN
    (CL:EQ *DISTRIBUTEDOPENGOAL?* 0)
    (INSERT
     (CLSYS-SVAL QUERY-ENVIRONMENT RESIDUE-GOALS *QUERYENVIRONMENT*)
     GOAL)))
  :VOID)

(CL:DEFMETHOD UNIQUENESSVECTORS ((SELF SLOT))
  (CL:LET*
   ((ANSWER (DYNAMIC-SLOT-VALUE SELF SYM-OPTIMIZE-UNIQUENESSVECTORS NULL)))
   (CL:IF
    (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM UNIQUENESSVECTORS NIL-LIST)
    (CL:RETURN-FROM UNIQUENESSVECTORS ANSWER)))
  :VOID)

;;; (DEFMETHOD (GET-UNIQUENESS-VECTORS (LIST OF BOOLEAN-VECTOR)) ...)

(CL:DEFMETHOD GET-UNIQUENESS-VECTORS ((SELF SLOT))
  (CL:LET*
   ((CACHEDVECTORLIST (UNIQUENESSVECTORS SELF)))
   (CL:IF
    (CL:NOT (CL:EQ CACHEDVECTORLIST NULL))
    (CL:RETURN-FROM GET-UNIQUENESS-VECTORS CACHEDVECTORLIST)
    (CL:RETURN-FROM GET-UNIQUENESS-VECTORS NIL-LIST)))
  :VOID)

;;; (DEFMETHOD (GET-INDEXING-VECTOR BOOLEAN-VECTOR) ...)

(CL:DEFMETHOD GET-INDEXING-VECTOR ((SELF SLOT))
  (CL:LET*
   ((CACHEDVECTOR
     (DYNAMIC-SLOT-VALUE SELF SYM-OPTIMIZE-INDEXING-VECTOR NULL)))
   (CL:WHEN
    (CL:NOT (CL:EQ CACHEDVECTOR NULL))
    (CL:RETURN-FROM GET-INDEXING-VECTOR CACHEDVECTOR))
   (CL:LET*
    ((ZEROONELIST (NEW-LIST)))
    (CL:LET*
     ((TYPE NULL) (ITER-001 (SLOT-COLUMN-TYPES SELF)) (COLLECT-001 NULL))
     (CL:LOOP
      WHILE
      (CL:EQ (NEXT? ITER-001) 1)
      DO
      (CL:PROGN
       (CL:SETQ
        TYPE
        (CAST (CLSYS-SVAL ITERATOR VALUE ITER-001) SGT-OPTIMIZE-TYPE)))
      (CL:IF
       (CL:EQ COLLECT-001 NULL)
       (CL:PROGN
        (CL:SETQ
         COLLECT-001
         (PERMANENT-CONS
          (CL:IF
           (CL:EQ (TYPE-HAS-BACKLINKS? TYPE) 1)
           ONE-WRAPPER
           ZERO-WRAPPER)
          NIL))
        (CL:IF
         (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST ZEROONELIST) NIL)
         (CL:SETF (CLSYS-SVAL LIST THE-CONS-LIST ZEROONELIST) COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST
          (CLSYS-SVAL LIST THE-CONS-LIST ZEROONELIST)
          COLLECT-001)))
       (CL:PROGN
        (CL:SETF
         (CLSYS-SVAL CONS REST COLLECT-001)
         (PERMANENT-CONS
          (CL:IF
           (CL:EQ (TYPE-HAS-BACKLINKS? TYPE) 1)
           ONE-WRAPPER
           ZERO-WRAPPER)
          NIL))
        (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
    (SET-DYNAMIC-SLOT-VALUE
     SELF
     SYM-OPTIMIZE-INDEXING-VECTOR
     (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR ZEROONELIST)
     NULL)
    (FREE ZEROONELIST)
    (CL:RETURN-FROM
     GET-INDEXING-VECTOR
     (DYNAMIC-SLOT-VALUE SELF SYM-OPTIMIZE-INDEXING-VECTOR NULL))))
  :VOID)

;;; (DEFCONSTANT V-0-0 ...)

(CL:DEFVAR V-0-0 NULL)

;;; (DEFCONSTANT V-1-0 ...)

(CL:DEFVAR V-1-0 NULL)

;;; (DEFCONSTANT V-0-1 ...)

(CL:DEFVAR V-0-1 NULL)

;;; (DEFCONSTANT V-1-1 ...)

(CL:DEFVAR V-1-1 NULL)

;;; (DEFCONSTANT V-1-0-AND-V-0-1 ...)

(CL:DEFVAR V-1-0-AND-V-0-1 NULL)

;;; (DEFCONSTANT V-1-0-SINGLETON ...)

(CL:DEFVAR V-1-0-SINGLETON NULL)

;;; (DEFCONSTANT V-0-1-SINGLETON ...)

(CL:DEFVAR V-0-1-SINGLETON NULL)

;;; (DEFMETHOD (GET-UNIQUENESS-VECTORS (LIST OF BOOLEAN-VECTOR)) ...)

(CL:DEFMETHOD GET-UNIQUENESS-VECTORS ((SELF STORAGE-SLOT))
  (CL:LET*
   ((SINGLEVALUEDINVERSE?
     (CL:IF
      (CL:AND
       (CL:NOT
        (CL:EQ (DYNAMIC-SLOT-VALUE SELF SYM-OPTIMIZE-INVERSE NULL) NULL))
       (CL:EQ
        (SINGLE-VALUED? (DYNAMIC-SLOT-VALUE SELF SYM-OPTIMIZE-INVERSE NULL))
        1))
      TRUE
      FALSE)))
   (CL:IF
    (CL:EQ (SINGLE-VALUED? SELF) 1)
    (CL:RETURN-FROM
     GET-UNIQUENESS-VECTORS
     (CL:IF (CL:EQ SINGLEVALUEDINVERSE? 1) V-1-0-AND-V-0-1 V-1-0-SINGLETON))
    (CL:RETURN-FROM
     GET-UNIQUENESS-VECTORS
     (CL:IF (CL:EQ SINGLEVALUEDINVERSE? 1) V-0-1-SINGLETON NIL-LIST))))
  :VOID)

;;; (DEFMETHOD (GET-INDEXING-VECTOR BOOLEAN-VECTOR) ...)

(CL:DEFMETHOD GET-INDEXING-VECTOR ((SELF STORAGE-SLOT))
  (CL:LET*
   ((BITONE?
     (CL:IF
      (CL:OR
       (CL:EQ
        (TYPE-HAS-BACKLINKS? (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SELF))
        1)
       (CL:AND
        (CL:NOT
         (CL:EQ (DYNAMIC-SLOT-VALUE SELF SYM-OPTIMIZE-INVERSE NULL) NULL))
        (CL:EQ
         (INDEX-ON-VALUES?
          (DYNAMIC-SLOT-VALUE SELF SYM-OPTIMIZE-INVERSE NULL))
         1)))
      TRUE
      FALSE))
    (BITTWO?
     (CL:IF
      (CL:OR
       (CL:EQ
        (TYPE-HAS-BACKLINKS? (CLSYS-SVAL STORAGE-SLOT SLOT-BASE-TYPE SELF))
        1)
       (CL:EQ (INDEX-ON-VALUES? SELF) 1))
      TRUE
      FALSE)))
   (CL:IF
    (CL:EQ BITONE? 1)
    (CL:RETURN-FROM GET-INDEXING-VECTOR (CL:IF (CL:EQ BITTWO? 1) V-1-1 V-1-0))
    (CL:RETURN-FROM GET-INDEXING-VECTOR (CL:IF (CL:EQ BITTWO? 1) V-0-1 V-0-0))))
  :VOID)

;;; (DEFCONSTANT ESTIMATED-SLOT-VALUE-COLLECTION-SIZE ...)

(CL:DEFVAR ESTIMATED-SLOT-VALUE-COLLECTION-SIZE 4
  "Estimate of the average size of a collection
representing the fillers of a slot.")

;;; (DEFCONSTANT ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS ...)

(CL:DEFVAR ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS 6
  "Very crude estimate of the number of stored propositions
that will match a predicate at least one of whose arguments are bound.
Chosen to be larger than ESTIMATED-SLOT-VALUE-COLLECTION-SIZE.")

;;; (DEFUN (ESTIMATE-CARDINALITY-OF-CLASS-EXTENSION INTEGER) ...)

(CL:DEFUN ESTIMATE-CARDINALITY-OF-CLASS-EXTENSION (CLASS)
  (CL:WHEN
   (CL:EQ CLASS NULL)
   (CL:RETURN-FROM ESTIMATE-CARDINALITY-OF-CLASS-EXTENSION NULL-INTEGER))
  (CL:LET*
   ((DESCRIPTION (DYNAMIC-SLOT-VALUE CLASS SYM-OPTIMIZE-DESCRIPTION NULL)))
   (CL:COND
    ((CL:AND
      (CL:NOT (CL:EQ DESCRIPTION NULL))
      (CL:EQ
       (DEFINED?
        (CLSYS-SVAL
         INTEGER-WRAPPER
         WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE
          DESCRIPTION
          SYM-OPTIMIZE-ESTIMATED-CARDINALITY
          NULL-INTEGER-WRAPPER)))
       1))
     (CL:RETURN-FROM
      ESTIMATE-CARDINALITY-OF-CLASS-EXTENSION
      (MAX
       (CLSYS-SVAL
        INTEGER-WRAPPER
        WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         DESCRIPTION
         SYM-OPTIMIZE-ESTIMATED-CARDINALITY
         NULL-INTEGER-WRAPPER))
       2)))
    ((CL:OR
      (CL:EQ
       (SUBTYPE-OF?
        (CLSYS-SVAL CLASS CLASS-TYPE CLASS)
        SGT-OPTIMIZE-LITERAL-WRAPPER)
       1)
      (CL:EQ
       (SUBTYPE-OF? (CLSYS-SVAL CLASS CLASS-TYPE CLASS) SGT-OPTIMIZE-LITERAL)
       1))
     (CL:RETURN-FROM ESTIMATE-CARDINALITY-OF-CLASS-EXTENSION NULL-INTEGER))
    ((CL:NOT (CL:EQ DESCRIPTION NULL))
     (CL:LET*
      ((COUNTER 0)
       (MEMBERS (COLLECTION-MEMBERS DESCRIPTION KWD-OPTIMIZE-OPEN)))
      (CL:WHEN
       (CL:NOT (CL:EQ MEMBERS NULL))
       (CL:LET*
        ((M MEMBERS))
        (CL:LOOP
         WHILE
         (CL:EQ (NEXT? M) 1)
         DO
         (CL:WHEN (CL:< COUNTER 20) (CL:SETQ COUNTER (CL:1+ COUNTER)))))
       (SET-DYNAMIC-SLOT-VALUE
        DESCRIPTION
        SYM-OPTIMIZE-ESTIMATED-CARDINALITY
        (WRAP-INTEGER COUNTER)
        NULL-INTEGER-WRAPPER))
      (CL:RETURN-FROM
       ESTIMATE-CARDINALITY-OF-CLASS-EXTENSION
       (MAX COUNTER 2))))
    (CL:T (CL:RETURN-FROM ESTIMATE-CARDINALITY-OF-CLASS-EXTENSION 20))))
  :VOID)

;;; (DEFUN (ESTIMATE-PREDICATE-GOAL-COST INTEGER) ...)

(CL:DEFUN ESTIMATE-PREDICATE-GOAL-COST (GOAL)
  (CL:LET*
   ((SLOT (OPERATOR-BOUND-TO (CLSYS-SVAL PROPOSITION OPERATOR GOAL)))
    (GOALVECTOR
     (ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR
      (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))))
   (CL:WHEN
    (CL:EQ SLOT NULL)
    (CL:RETURN-FROM ESTIMATE-PREDICATE-GOAL-COST NULL-INTEGER))
   (CL:LET*
    ((TEST-VALUE-001 FALSE))
    (CL:LET*
     ((FOUND?-001 FALSE))
     (CL:LET*
      ((IBIT NULL)
       (GBIT NULL)
       (VECTOR-001 GOALVECTOR)
       (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001))
       (VECTOR-002 (GET-INDEXING-VECTOR SLOT))
       (INDEX-002 0)
       (LENGTH-002 (LENGTH VECTOR-002)))
      (CL:LOOP
       WHILE
       (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:< INDEX-002 LENGTH-002))
       DO
       (CL:PROGN
        (CL:SETQ
         GBIT
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (CL:PROGN
        (CL:SETQ
         IBIT
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
       (CL:WHEN
        (CL:AND
         (CL:EQ (EQL? IBIT TRUE-WRAPPER) 1)
         (CL:EQ (EQL? GBIT TRUE-WRAPPER) 1))
        (CL:SETQ FOUND?-001 TRUE)
        (CL:RETURN))))
     (CL:SETQ TEST-VALUE-001 FOUND?-001))
    (CL:SETQ TEST-VALUE-001 (CL:IF (CL:EQ TEST-VALUE-001 0) TRUE FALSE))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:RETURN-FROM ESTIMATE-PREDICATE-GOAL-COST NULL-INTEGER)))
   (CL:LET*
    ((ALLBITSMATCH? FALSE))
    (CL:LET*
     ((UNIQUENESSKEY NULL)
      (ITER-001
       (CLSYS-SVAL LIST THE-CONS-LIST (GET-UNIQUENESS-VECTORS SLOT))))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NIL))
      DO
      (CL:PROGN
       (CL:SETQ
        UNIQUENESSKEY
        (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-OPTIMIZE-BOOLEAN-VECTOR))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:SETQ ALLBITSMATCH? TRUE)
      (CL:LET*
       ((GBIT NULL)
        (UBIT NULL)
        (VECTOR-003 UNIQUENESSKEY)
        (INDEX-003 0)
        (LENGTH-003 (LENGTH VECTOR-003))
        (VECTOR-004 GOALVECTOR)
        (INDEX-004 0)
        (LENGTH-004 (LENGTH VECTOR-004)))
       (CL:LOOP
        WHILE
        (CL:AND (CL:< INDEX-003 LENGTH-003) (CL:< INDEX-004 LENGTH-004))
        DO
        (CL:PROGN
         (CL:SETQ
          UBIT
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-003) INDEX-003))
         (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))
        (CL:PROGN
         (CL:SETQ
          GBIT
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-004) INDEX-004))
         (CL:SETQ INDEX-004 (CL:1+ INDEX-004)))
        (CL:WHEN
         (CL:AND
          (CL:EQ (EQL? UBIT TRUE-WRAPPER) 1)
          (CL:EQ (EQL? GBIT FALSE-WRAPPER) 1))
         (CL:SETQ ALLBITSMATCH? FALSE)
         (CL:RETURN))))
      (CL:WHEN
       (CL:EQ ALLBITSMATCH? 1)
       (CL:RETURN-FROM ESTIMATE-PREDICATE-GOAL-COST 1))))
    (CL:RETURN-FROM
     ESTIMATE-PREDICATE-GOAL-COST
     ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS)))
  :VOID)

;;; (DEFUN (ESTIMATE-GOAL-COST INTEGER) ...)

(CL:DEFUN ESTIMATE-GOAL-COST (GOAL)
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND GOAL)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-IN)
     (CL:LET*
      ((SECONDARG
        (ARGUMENT-BOUND-TO (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL)))))
      (CL:WHEN
       (CL:EQ SECONDARG NULL)
       (CL:RETURN-FROM ESTIMATE-GOAL-COST NULL-INTEGER))
      (CL:LET*
       ((SECONDARG-001 SECONDARG))
       (CL:COND
        ((CL:EQ (TAXONOMY-ISA? SECONDARG SGT-OPTIMIZE-DESCRIPTION) 1)
         (CL:LET*
          ((SECONDARG NULL))
          (CL:SETQ SECONDARG SECONDARG-001)
          (CL:RETURN-FROM
           ESTIMATE-GOAL-COST
           (ESTIMATE-CARDINALITY-OF-CLASS-EXTENSION
            (CAST
             (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SECONDARG)
             SGT-OPTIMIZE-CLASS)))))
        ((CL:EQ (TAXONOMY-ISA? SECONDARG SGT-OPTIMIZE-COLLECTION) 1)
         (CL:LET*
          ((SECONDARG NULL))
          (CL:SETQ SECONDARG SECONDARG-001)
          (CL:RETURN-FROM ESTIMATE-GOAL-COST (LENGTH SECONDARG))))
        (CL:T
         (CL:RETURN-FROM
          ESTIMATE-GOAL-COST
          ESTIMATED-SLOT-VALUE-COLLECTION-SIZE))))))
    ((CL:OR
      (CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-FUNCTION)
      (CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-PREDICATE))
     (CL:RETURN-FROM ESTIMATE-GOAL-COST (ESTIMATE-PREDICATE-GOAL-COST GOAL)))
    (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
  :VOID)

;;; (DEFUN (CHEAPEST-GENERATOR-GOAL PROPOSITION INTEGER) ...)

(CL:DEFUN CHEAPEST-GENERATOR-GOAL (VARIABLE)
  (CL:LET*
   ((BESTGOAL NULL) (BESTCOST NULL-INTEGER) (COST NULL-INTEGER))
   (CL:LET*
    ((GOAL NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL GOAL-RECORD GENERATOR-GOALS (GOAL-RECORD VARIABLE)))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       GOAL
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-OPTIMIZE-PROPOSITION))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:SETQ COST (ESTIMATE-GOAL-COST GOAL))
     (CL:WHEN
      (CL:AND
       (CL:EQ (DEFINED? COST) 1)
       (CL:OR (CL:EQ (NULL? BESTCOST) 1) (CL:< COST BESTCOST)))
      (CL:WHEN
       (CL:= COST 1)
       (CL:RETURN-FROM CHEAPEST-GENERATOR-GOAL (CL:VALUES GOAL 1)))
      (CL:SETQ BESTGOAL GOAL)
      (CL:SETQ BESTCOST COST))))
   (CL:IF
    (CL:EQ (DEFINED? BESTCOST) 1)
    (CL:RETURN-FROM CHEAPEST-GENERATOR-GOAL (CL:VALUES BESTGOAL BESTCOST))
    (CL:RETURN-FROM CHEAPEST-GENERATOR-GOAL (CL:VALUES NULL 0))))
  :VOID)

;;; (DEFUN PROPAGATE-SINGLE-VALUED-CONSTRAINTS ...)

(CL:DEFUN PROPAGATE-SINGLE-VALUED-CONSTRAINTS (GOAL GOALSEQUENCE)
  (CL:LET*
   ((ARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL)))
   (CL:LET*
    ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND GOAL)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-FUNCTION)
      (CL:LET*
       ((TEST-VALUE-002 FALSE))
       (CL:LET*
        ((ALWAYS?-001 TRUE))
        (CL:LET*
         ((ARG NULL) (ITER-001 (BUT-LAST ARGUMENTS)))
         (CL:LOOP
          WHILE
          (CL:EQ (NEXT? ITER-001) 1)
          DO
          (CL:PROGN (CL:SETQ ARG (CLSYS-SVAL ITERATOR VALUE ITER-001)))
          (CL:WHEN
           (CL:EQ (ARGUMENT-BOUND? ARG) 0)
           (CL:SETQ ALWAYS?-001 FALSE)
           (CL:RETURN))))
        (CL:SETQ TEST-VALUE-002 ALWAYS?-001))
       (CL:WHEN
        (CL:EQ TEST-VALUE-002 1)
        (CL:SETQ TEST-VALUE-002 (UNBOUND-VARIABLE? (LAST ARGUMENTS))))
       (CL:IF
        (CL:EQ TEST-VALUE-002 1)
        (CL:PROGN
         (PUSH GOALSEQUENCE GOAL)
         (SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS
          (CAST (LAST ARGUMENTS) SGT-OPTIMIZE-PATTERN-VARIABLE)
          GOALSEQUENCE))
        (CL:PROGN "NOT YET IMPLEMENTED"))))
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-IN) NULL)
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-EQUIVALENT)
      (CL:COND
       ((CL:EQ (UNBOUND-VARIABLE? (FIRST ARGUMENTS)) 1)
        (PUSH GOALSEQUENCE GOAL)
        (SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS
         (CAST (FIRST ARGUMENTS) SGT-OPTIMIZE-PATTERN-VARIABLE)
         GOALSEQUENCE))
       ((CL:EQ (UNBOUND-VARIABLE? (SECOND ARGUMENTS)) 1)
        (PUSH GOALSEQUENCE GOAL)
        (SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS
         (CAST (SECOND ARGUMENTS) SGT-OPTIMIZE-PATTERN-VARIABLE)
         GOALSEQUENCE))))
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-PREDICATE) NULL)
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-NOT) NULL)
     (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001)))))
  :VOID)

;;; (DEFUN COLLECT-CLOSED-GOALS ...)

(CL:DEFUN COLLECT-CLOSED-GOALS (GOALS GOALSEQUENCE)
  (CL:LET*
   ((G NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST GOALS)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NIL))
    DO
    (CL:PROGN
     (CL:SETQ
      G
      (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-OPTIMIZE-PROPOSITION))
     (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
    (CL:WHEN
     (CL:AND
      (CL:EQ (ALL-ARGUMENTS-BOUND? G) 1)
      (CL:EQ (MEMBER? GOALSEQUENCE G) 0))
     (PUSH GOALSEQUENCE G))))
  :VOID)

;;; (DEFUN SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS ...)

(CL:DEFUN SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS (VARIABLE GOALSEQUENCE)
  (CL:LET*
   ((GOALRECORD (GOAL-RECORD VARIABLE)))
   (CL:WHEN
    (CL:EQ (UNBOUND-VARIABLE? VARIABLE) 0)
    (CL:ERROR
     "Safety violation: INTERNAL ERROR: Query optimizer found bound variable where unbound variable was expected."))
   (SIMULATE-BIND-VARIABLE-TO-VALUE VARIABLE)
   (COLLECT-CLOSED-GOALS
    (CLSYS-SVAL GOAL-RECORD GENERATOR-GOALS GOALRECORD)
    GOALSEQUENCE)
   (COLLECT-CLOSED-GOALS
    (CLSYS-SVAL GOAL-RECORD OTHER-GOALS GOALRECORD)
    GOALSEQUENCE)
   (CL:LET*
    ((G NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL GOAL-RECORD GENERATOR-GOALS GOALRECORD))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       G
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-OPTIMIZE-PROPOSITION))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (PROPAGATE-SINGLE-VALUED-CONSTRAINTS G GOALSEQUENCE)))
   (CL:LET*
    ((G NULL)
     (ITER-002
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL GOAL-RECORD OTHER-GOALS GOALRECORD))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       G
       (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-OPTIMIZE-PROPOSITION))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (PROPAGATE-SINGLE-VALUED-CONSTRAINTS G GOALSEQUENCE))))
  :VOID)

;;; (DEFUN BIND-ALL-VARIABLES-IN-GENERATOR-GOAL ...)

(CL:DEFUN BIND-ALL-VARIABLES-IN-GENERATOR-GOAL (GOAL GOALSEQUENCE)
  (CL:LET*
   ((ARG NULL)
    (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))
    (INDEX-001 0)
    (LENGTH-001 (LENGTH VECTOR-001)))
   (CL:LOOP
    WHILE
    (CL:< INDEX-001 LENGTH-001)
    DO
    (CL:PROGN
     (CL:SETQ
      ARG
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
    (CL:WHEN
     (CL:AND
      (CL:EQ (ISA? ARG SGT-OPTIMIZE-PATTERN-VARIABLE) 1)
      (CL:EQ (UNBOUND-VARIABLE? ARG) 1))
     (SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS
      (CAST ARG SGT-OPTIMIZE-PATTERN-VARIABLE)
      GOALSEQUENCE))))
  :VOID)

;;; (DEFUN COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING ...)

(CL:DEFUN COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING (OPTIMIZERVARIABLES NUMBEROFOPENGOALS GOALSEQUENCE COST)
  (CL:LET*
   ((GOALSEQUENCECHECKPOINT NULL)
    (CHOICEPOINTUNBINDINGOFFSET NULL-INTEGER)
    (INCREASEDCOST NULL-INTEGER))
   (CL:WHEN
    (CL:EQ (EMPTY? OPTIMIZERVARIABLES) 1)
    (CL:SETF
     (CLSYS-SVAL QUERY-ENVIRONMENT BEST-GOAL-SEQUENCE *QUERYENVIRONMENT*)
     GOALSEQUENCE)
    (CL:RETURN-FROM COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING))
   (CL:LET*
    ((VBL NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST OPTIMIZERVARIABLES)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       VBL
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-OPTIMIZE-PATTERN-VARIABLE))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:TAGBODY
      (CL:WHEN
       (CL:EQ (VARIABLE-BOUND? VBL) 0)
       (CL:LET*
        ((GENERATORGOAL NULL) (GENERATORCOST NULL-INTEGER))
        (CL:MULTIPLE-VALUE-SETQ
         (GENERATORGOAL GENERATORCOST)
         (CHEAPEST-GENERATOR-GOAL VBL))
        (CL:WHEN (CL:EQ GENERATORGOAL NULL) (CL:GO :CONTINUE))
        (CL:SETQ INCREASEDCOST (CL:* COST GENERATORCOST))
        (CL:WHEN
         (CL:AND
          (CL:EQ
           (DEFINED?
            (CLSYS-SVAL QUERY-ENVIRONMENT BEST-COST *QUERYENVIRONMENT*))
           1)
          (CL:>=
           INCREASEDCOST
           (CLSYS-SVAL QUERY-ENVIRONMENT BEST-COST *QUERYENVIRONMENT*)))
         (CL:GO :CONTINUE))
        (CL:SETQ
         GOALSEQUENCECHECKPOINT
         (CLSYS-SVAL LIST THE-CONS-LIST GOALSEQUENCE))
        (CL:SETQ CHOICEPOINTUNBINDINGOFFSET (SIMULATE-CREATE-CHOICE-POINT))
        (PUSH GOALSEQUENCE GENERATORGOAL)
        (BIND-ALL-VARIABLES-IN-GENERATOR-GOAL GENERATORGOAL GOALSEQUENCE))
       (CL:IF
        (CL:= (LENGTH GOALSEQUENCE) NUMBEROFOPENGOALS)
        (CL:WHEN
         (CL:OR
          (CL:EQ
           (NULL? (CLSYS-SVAL QUERY-ENVIRONMENT BEST-COST *QUERYENVIRONMENT*))
           1)
          (CL:<
           INCREASEDCOST
           (CLSYS-SVAL QUERY-ENVIRONMENT BEST-COST *QUERYENVIRONMENT*)))
         (CL:SETF
          (CLSYS-SVAL QUERY-ENVIRONMENT BEST-COST *QUERYENVIRONMENT*)
          INCREASEDCOST)
         (CL:SETF
          (CLSYS-SVAL QUERY-ENVIRONMENT BEST-GOAL-SEQUENCE *QUERYENVIRONMENT*)
          (COPY GOALSEQUENCE)))
        (COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING
         OPTIMIZERVARIABLES
         NUMBEROFOPENGOALS
         GOALSEQUENCE
         INCREASEDCOST))
       (CL:SETF
        (CLSYS-SVAL LIST THE-CONS-LIST GOALSEQUENCE)
        GOALSEQUENCECHECKPOINT)
       (UNBIND-VARIABLES-BEGINNING-AT CHOICEPOINTUNBINDINGOFFSET))
      :CONTINUE))))
  :VOID)

;;; (DEFUN COLLECT-OPTIMIZER-VARIABLES ...)

(CL:DEFUN COLLECT-OPTIMIZER-VARIABLES (PROPOSITION COLLECTION)
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND PROPOSITION)))
   (CL:COND
    ((CL:OR
      (CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-IN)
      (CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-FUNCTION)
      (CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-PREDICATE)
      (CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-EQUIVALENT))
     (CL:LET*
      ((ARG NULL)
       (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
       (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:LOOP
       WHILE
       (CL:< INDEX-001 LENGTH-001)
       DO
       (CL:PROGN
        (CL:SETQ
         ARG
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (CL:WHEN
        (CL:EQ (UNBOUND-VARIABLE? ARG) 1)
        (CL:LET*
         ((VARIABLE (CAST ARG SGT-OPTIMIZE-PATTERN-VARIABLE)))
         (CL:COND
          ((CL:NOT (CL:EQ VARIABLE (INNERMOST-OF VARIABLE)))
           (SIMULATE-BIND-VARIABLE-TO-VALUE VARIABLE))
          ((CL:AND
            (CL:EQ
             (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION VARIABLE)
             NULL)
            (CL:EQ (ANONYMOUS-VARIABLE? VARIABLE) 0))
           (INSERT-NEW COLLECTION VARIABLE))))))))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN OPTIMIZE-ORDERING-OF-CONJUNCTS ...)

(CL:DEFUN OPTIMIZE-ORDERING-OF-CONJUNCTS (ANDPROPOSITION)
  (CL:LET*
   ((INITIALLYCLOSEDGOALS (NEW-LIST))
    (OPENGOALS (NEW-LIST))
    (OPTIMIZERVARIABLES (NEW-LIST))
    (GOALSEQUENCE (NEW-LIST)))
   (CL:LET*
    ((G NULL)
     (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS ANDPROPOSITION))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ G (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:COND
      ((CL:EQ (ALL-ARGUMENTS-BOUND? (CAST G SGT-OPTIMIZE-PROPOSITION)) 1)
       (INSERT INITIALLYCLOSEDGOALS (CAST G SGT-OPTIMIZE-PROPOSITION)))
      ((CL:OR
        (CL:EQ (HAS-DISJUNCTION? (CAST G SGT-OPTIMIZE-PROPOSITION)) 1)
        (CL:EQ
         (CLSYS-SVAL PROPOSITION KIND (CAST G SGT-OPTIMIZE-PROPOSITION))
         KWD-OPTIMIZE-FORALL))
       (INSERT
        (CLSYS-SVAL QUERY-ENVIRONMENT RESIDUE-GOALS *QUERYENVIRONMENT*)
        (CAST G SGT-OPTIMIZE-PROPOSITION)))
      (CL:T (INSERT OPENGOALS (CAST G SGT-OPTIMIZE-PROPOSITION))))))
   (CL:LET*
    ((GOAL NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST OPENGOALS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       GOAL
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-OPTIMIZE-PROPOSITION))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (DISTRIBUTE-OPEN-GOAL GOAL)))
   (CL:LET*
    ((G NULL) (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST OPENGOALS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       G
       (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-OPTIMIZE-PROPOSITION))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:LET*
      ((FOUND?-001 FALSE))
      (CL:LET*
       ((ARG NULL)
        (VECTOR-002 (CLSYS-SVAL PROPOSITION ARGUMENTS G))
        (INDEX-002 0)
        (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:LOOP
        WHILE
        (CL:< INDEX-002 LENGTH-002)
        DO
        (CL:PROGN
         (CL:SETQ
          ARG
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
         (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
        (CL:WHEN
         (CL:EQ (ARGUMENT-BOUND? ARG) 1)
         (CL:SETQ FOUND?-001 TRUE)
         (CL:RETURN))))
      (CL:WHEN
       (CL:EQ FOUND?-001 1)
       (PROPAGATE-SINGLE-VALUED-CONSTRAINTS G GOALSEQUENCE)))))
   (CL:LET*
    ((GOAL NULL) (ITER-003 (CLSYS-SVAL LIST THE-CONS-LIST OPENGOALS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-003 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       GOAL
       (CAST (CLSYS-SVAL CONS VALUE ITER-003) SGT-OPTIMIZE-PROPOSITION))
      (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
     (COLLECT-OPTIMIZER-VARIABLES GOAL OPTIMIZERVARIABLES)))
   (COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING
    OPTIMIZERVARIABLES
    (LENGTH OPENGOALS)
    GOALSEQUENCE
    1)
   (CL:WHEN
    (CL:EQ
     (EMPTY?
      (CLSYS-SVAL QUERY-ENVIRONMENT BEST-GOAL-SEQUENCE *QUERYENVIRONMENT*))
     1)
    (COMPUTE-BACKUP-OPEN-GOAL-ORDERING (REVERSE OPENGOALS)))
   (REORDER-GOALS
    ANDPROPOSITION
    INITIALLYCLOSEDGOALS
    (REVERSE
     (CLSYS-SVAL QUERY-ENVIRONMENT BEST-GOAL-SEQUENCE *QUERYENVIRONMENT*))
    (CLSYS-SVAL QUERY-ENVIRONMENT RESIDUE-GOALS *QUERYENVIRONMENT*)))
  :VOID)

;;; (DEFUN COMPUTE-BACKUP-OPEN-GOAL-ORDERING ...)

(CL:DEFUN COMPUTE-BACKUP-OPEN-GOAL-ORDERING (GOALSEQUENCE)
  (CL:LET*
   ((LASTGOALS (NEW-LIST)))
   (CL:LET*
    ((G NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST GOALSEQUENCE)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       G
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-OPTIMIZE-PROPOSITION))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:AND
       (CL:EQ (NULL? (ESTIMATE-GOAL-COST G)) 1)
       (CL:EQ (VARIABLE-TYPE? G) 1))
      (PUSH LASTGOALS G)
      (PUSH
       (CLSYS-SVAL QUERY-ENVIRONMENT BEST-GOAL-SEQUENCE *QUERYENVIRONMENT*)
       G))))
   (CL:LET*
    ((G NULL) (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST (REVERSE LASTGOALS))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ G (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (PUSH
      (CLSYS-SVAL QUERY-ENVIRONMENT BEST-GOAL-SEQUENCE *QUERYENVIRONMENT*)
      (CAST G SGT-OPTIMIZE-PROPOSITION)))))
  :VOID)

;;; (DEFUN REORDER-GOALS ...)

(CL:DEFUN REORDER-GOALS (ANDPROPOSITION INITIALLYCLOSEDGOALS GOALSEQUENCE RESIDUEGOALS)
  (CL:LET*
   ((ARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS ANDPROPOSITION)) (INDEX 0))
   (CL:LET*
    ((G NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST INITIALLYCLOSEDGOALS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       G
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-OPTIMIZE-PROPOSITION))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) INDEX) G)
     (CL:SETQ INDEX (CL:1+ INDEX))))
   (CL:LET*
    ((G NULL) (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST GOALSEQUENCE)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-002 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       G
       (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-OPTIMIZE-PROPOSITION))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (REMOVE RESIDUEGOALS G)
     (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) INDEX) G)
     (CL:SETQ INDEX (CL:1+ INDEX))))
   (CL:LET*
    ((G NULL) (ITER-003 (CLSYS-SVAL LIST THE-CONS-LIST RESIDUEGOALS)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-003 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       G
       (CAST (CLSYS-SVAL CONS VALUE ITER-003) SGT-OPTIMIZE-PROPOSITION))
      (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
     (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) INDEX) G)
     (CL:SETQ INDEX (CL:1+ INDEX)))))
  :VOID)

;;; (DEFUN SIMULATE-BIND-VARIABLE-TO-VALUE ...)

(CL:DEFUN SIMULATE-BIND-VARIABLE-TO-VALUE (FORMULA)
  (CL:LET*
   ((FORMULA-001 FORMULA))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? FORMULA SGT-OPTIMIZE-PATTERN-VARIABLE) 1)
     (CL:LET*
      ((FORMULA NULL))
      (CL:SETQ FORMULA FORMULA-001)
      (CL:WHEN
       (CL:EQ (ARGUMENT-BOUND? FORMULA) 0)
       (SET-PATTERN-VARIABLE-BINDING FORMULA KWD-OPTIMIZE-BOUND))))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN WARN-OF-UNBOUND-VARIABLE-ARGUMENT ...)

(CL:DEFUN WARN-OF-UNBOUND-VARIABLE-ARGUMENT (PROPOSITION)
  (CL:RETURN-FROM WARN-OF-UNBOUND-VARIABLE-ARGUMENT)
  (CL:LET*
   ((ARG NULL)
    (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
    (INDEX-001 0)
    (LENGTH-001 (LENGTH VECTOR-001)))
   (CL:LOOP
    WHILE
    (CL:< INDEX-001 LENGTH-001)
    DO
    (CL:PROGN
     (CL:SETQ
      ARG
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
    (CL:WHEN
     (CL:EQ (UNBOUND-VARIABLE? ARG) 1)
     (CL:WARN
      "Query Bug: Unbound variable `~A' encountered within proposition~%   `~A' during query simulation."
      ARG
      PROPOSITION))))
  :VOID)

;;; (DEFUN SIMULATE-GOAL-EVALUATION ...)

(CL:DEFUN SIMULATE-GOAL-EVALUATION (GOAL)
  (CL:LET*
   ((ARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL)) (OK? FALSE))
   (CL:LET*
    ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND GOAL)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-FUNCTION)
      (CL:LET*
       ((CHOOSE-VALUE-001 FALSE))
       (CL:IF
        (CL:EQ (COMPUTED-PREDICATE? GOAL) 1)
        (CL:LET*
         ((ALWAYS?-001 TRUE))
         (CL:LET*
          ((ARG NULL) (ITER-001 (BUT-LAST ARGUMENTS)))
          (CL:LOOP
           WHILE
           (CL:EQ (NEXT? ITER-001) 1)
           DO
           (CL:PROGN (CL:SETQ ARG (CLSYS-SVAL ITERATOR VALUE ITER-001)))
           (CL:WHEN
            (CL:EQ (ARGUMENT-BOUND? ARG) 0)
            (CL:SETQ ALWAYS?-001 FALSE)
            (CL:RETURN))))
         (CL:SETQ CHOOSE-VALUE-001 ALWAYS?-001))
        (CL:LET*
         ((FOUND?-001 FALSE))
         (CL:LET*
          ((ARG NULL)
           (VECTOR-001 ARGUMENTS)
           (INDEX-001 0)
           (LENGTH-001 (LENGTH VECTOR-001)))
          (CL:LOOP
           WHILE
           (CL:< INDEX-001 LENGTH-001)
           DO
           (CL:PROGN
            (CL:SETQ
             ARG
             (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
            (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
           (CL:WHEN
            (CL:AND
             (CL:EQ (ARGUMENT-BOUND? ARG) 1)
             (CL:EQ (TYPE-HAS-BACKLINKS? (LOGICAL-TYPE ARG)) 1))
            (CL:SETQ FOUND?-001 TRUE)
            (CL:RETURN))))
         (CL:SETQ CHOOSE-VALUE-001 FOUND?-001)))
       (CL:SETQ OK? CHOOSE-VALUE-001)))
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-PREDICATE)
      (CL:LET*
       ((CHOOSE-VALUE-002 FALSE))
       (CL:IF
        (CL:EQ (COMPUTED-PREDICATE? GOAL) 1)
        (CL:LET*
         ((ALWAYS?-002 TRUE))
         (CL:LET*
          ((ARG NULL)
           (VECTOR-002 ARGUMENTS)
           (INDEX-002 0)
           (LENGTH-002 (LENGTH VECTOR-002)))
          (CL:LOOP
           WHILE
           (CL:< INDEX-002 LENGTH-002)
           DO
           (CL:PROGN
            (CL:SETQ
             ARG
             (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
            (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
           (CL:WHEN
            (CL:EQ (ARGUMENT-BOUND? ARG) 0)
            (CL:SETQ ALWAYS?-002 FALSE)
            (CL:RETURN))))
         (CL:SETQ CHOOSE-VALUE-002 ALWAYS?-002))
        (CL:LET*
         ((FOUND?-002 FALSE))
         (CL:LET*
          ((ARG NULL)
           (VECTOR-003 ARGUMENTS)
           (INDEX-003 0)
           (LENGTH-003 (LENGTH VECTOR-003)))
          (CL:LOOP
           WHILE
           (CL:< INDEX-003 LENGTH-003)
           DO
           (CL:PROGN
            (CL:SETQ
             ARG
             (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-003) INDEX-003))
            (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))
           (CL:WHEN
            (CL:AND
             (CL:EQ (ARGUMENT-BOUND? ARG) 1)
             (CL:EQ (TYPE-HAS-BACKLINKS? (LOGICAL-TYPE ARG)) 1))
            (CL:SETQ FOUND?-002 TRUE)
            (CL:RETURN))))
         (CL:SETQ CHOOSE-VALUE-002 FOUND?-002)))
       (CL:SETQ OK? CHOOSE-VALUE-002)))
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-IN)
      (CL:SETQ OK? (ARGUMENT-BOUND? (SECOND ARGUMENTS))))
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-EQUIVALENT)
      (CL:SETQ
       OK?
       (CL:IF
        (CL:OR
         (CL:EQ (ARGUMENT-BOUND? (FIRST ARGUMENTS)) 1)
         (CL:EQ (ARGUMENT-BOUND? (SECOND ARGUMENTS)) 1))
        TRUE
        FALSE)))
     (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
   (CL:WHEN (CL:EQ OK? 0) (WARN-OF-UNBOUND-VARIABLE-ARGUMENT GOAL))
   (CL:LET*
    ((ARG NULL)
     (VECTOR-004 ARGUMENTS)
     (INDEX-004 0)
     (LENGTH-004 (LENGTH VECTOR-004)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-004 LENGTH-004)
     DO
     (CL:PROGN
      (CL:SETQ
       ARG
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-004) INDEX-004))
      (CL:SETQ INDEX-004 (CL:1+ INDEX-004)))
     (SIMULATE-BIND-VARIABLE-TO-VALUE ARG))))
  :VOID)

;;; (DEFUN SIMULATE-AND-OPTIMIZE-ARGUMENT ...)

(CL:DEFUN SIMULATE-AND-OPTIMIZE-ARGUMENT (FORMULA)
  (CL:LET*
   ((FORMULA-001 FORMULA))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? FORMULA SGT-OPTIMIZE-PROPOSITION) 1)
     (CL:LET*
      ((FORMULA NULL))
      (CL:SETQ FORMULA FORMULA-001)
      (SIMULATE-AND-OPTIMIZE-QUERY FORMULA)))
    ((CL:EQ (TAXONOMY-ISA? FORMULA SGT-OPTIMIZE-DESCRIPTION) 1)
     (CL:LET*
      ((FORMULA NULL))
      (CL:SETQ FORMULA FORMULA-001)
      (CL:LET*
       ((VECTOROFZEROS
         (ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR
          (CLSYS-SVAL DESCRIPTION IO-VARIABLES FORMULA))))
       (OPTIMIZE-QUERY FORMULA VECTOROFZEROS *QUERYOPTIMIZERCONTROLFRAME*))))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN SIMULATE-AND-OPTIMIZE-QUERY ...)

(CL:DEFUN SIMULATE-AND-OPTIMIZE-QUERY (PROPOSITION)
  (CL:LET*
   ((ARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
    (KIND (CLSYS-SVAL PROPOSITION KIND PROPOSITION)))
   (CL:WHEN
    (CL:EQ *REVERSEPOLARITY?* 1)
    (CL:COND
     ((CL:EQ KIND KWD-OPTIMIZE-AND) (CL:SETQ KIND KWD-OPTIMIZE-OR))
     ((CL:EQ KIND KWD-OPTIMIZE-OR) (CL:SETQ KIND KWD-OPTIMIZE-AND))
     ((CL:EQ KIND KWD-OPTIMIZE-IMPLIES)
      (CL:ERROR
       "REVERSE POLARITY NOT YET IMPLEMENTED FOR :IMPLIES WITHIN QUERY OPTIMIZER"))
     (CL:T NULL)))
   (CL:COND
    ((CL:OR
      (CL:EQ KIND KWD-OPTIMIZE-FUNCTION)
      (CL:EQ KIND KWD-OPTIMIZE-PREDICATE)
      (CL:EQ KIND KWD-OPTIMIZE-IN)
      (CL:EQ KIND KWD-OPTIMIZE-EQUIVALENT))
     (SIMULATE-GOAL-EVALUATION PROPOSITION)
     (CL:LET*
      ((ARG NULL)
       (VECTOR-001 ARGUMENTS)
       (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:LOOP
       WHILE
       (CL:< INDEX-001 LENGTH-001)
       DO
       (CL:PROGN
        (CL:SETQ
         ARG
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (SIMULATE-AND-OPTIMIZE-ARGUMENT ARG))))
    ((CL:EQ KIND KWD-OPTIMIZE-AND)
     (CL:LET*
      ((CHOICEPOINTUNBINDINGOFFSET (SIMULATE-CREATE-CHOICE-POINT)))
      (INITIALIZE-OPTIMIZER-MEMORY -1)
      (OPTIMIZE-ORDERING-OF-CONJUNCTS PROPOSITION)
      (UNBIND-VARIABLES-BEGINNING-AT CHOICEPOINTUNBINDINGOFFSET))
     (CL:LET*
      ((ARG NULL)
       (VECTOR-002 ARGUMENTS)
       (INDEX-002 0)
       (LENGTH-002 (LENGTH VECTOR-002)))
      (CL:LOOP
       WHILE
       (CL:< INDEX-002 LENGTH-002)
       DO
       (CL:PROGN
        (CL:SETQ
         ARG
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
       (SIMULATE-AND-OPTIMIZE-QUERY (CAST ARG SGT-OPTIMIZE-PROPOSITION)))))
    ((CL:EQ KIND KWD-OPTIMIZE-OR)
     (CL:LET*
      ((ARG NULL)
       (VECTOR-003 ARGUMENTS)
       (INDEX-003 0)
       (LENGTH-003 (LENGTH VECTOR-003)))
      (CL:LOOP
       WHILE
       (CL:< INDEX-003 LENGTH-003)
       DO
       (CL:PROGN
        (CL:SETQ
         ARG
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-003) INDEX-003))
        (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))
       (CL:LET*
        ((CHOICEPOINTUNBINDINGOFFSET (SIMULATE-CREATE-CHOICE-POINT)))
        (SIMULATE-AND-OPTIMIZE-QUERY (CAST ARG SGT-OPTIMIZE-PROPOSITION))
        (UNBIND-VARIABLES-BEGINNING-AT CHOICEPOINTUNBINDINGOFFSET)))))
    ((CL:EQ KIND KWD-OPTIMIZE-NOT)
     (CL:LET*
      ((OLDREVERSEPOLARITY? *REVERSEPOLARITY?*))
      (CL:LET*
       ((*REVERSEPOLARITY?* (CL:IF (CL:EQ OLDREVERSEPOLARITY? 0) TRUE FALSE)))
       (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
       (CL:WHEN
        (CL:EQ *REVERSEPOLARITY?* 1)
        (WARN-OF-UNBOUND-VARIABLE-ARGUMENT PROPOSITION))
       (SIMULATE-AND-OPTIMIZE-QUERY
        (CAST (FIRST ARGUMENTS) SGT-OPTIMIZE-PROPOSITION)))))
    ((CL:EQ KIND KWD-OPTIMIZE-IMPLIES)
     (WARN-OF-UNBOUND-VARIABLE-ARGUMENT PROPOSITION)
     (CL:LET*
      ((ARG NULL)
       (VECTOR-004 ARGUMENTS)
       (INDEX-004 0)
       (LENGTH-004 (LENGTH VECTOR-004)))
      (CL:LOOP
       WHILE
       (CL:< INDEX-004 LENGTH-004)
       DO
       (CL:PROGN
        (CL:SETQ
         ARG
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-004) INDEX-004))
        (CL:SETQ INDEX-004 (CL:1+ INDEX-004)))
       (SIMULATE-AND-OPTIMIZE-ARGUMENT ARG))))
    ((CL:EQ KIND KWD-OPTIMIZE-EXISTS)
     (SIMULATE-AND-OPTIMIZE-QUERY
      (CAST (FIRST ARGUMENTS) SGT-OPTIMIZE-PROPOSITION)))
    ((CL:EQ KIND KWD-OPTIMIZE-FORALL)
     (CL:LET*
      ((CHOICEPOINTUNBINDINGOFFSET (SIMULATE-CREATE-CHOICE-POINT)))
      (CL:LET*
       ((ARG NULL)
        (VECTOR-005 ARGUMENTS)
        (INDEX-005 0)
        (LENGTH-005 (LENGTH VECTOR-005)))
       (CL:LOOP
        WHILE
        (CL:< INDEX-005 LENGTH-005)
        DO
        (CL:PROGN
         (CL:SETQ
          ARG
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-005) INDEX-005))
         (CL:SETQ INDEX-005 (CL:1+ INDEX-005)))
        (SIMULATE-AND-OPTIMIZE-ARGUMENT ARG)))
      (UNBIND-VARIABLES-BEGINNING-AT CHOICEPOINTUNBINDINGOFFSET)))
    (CL:T NULL)))
  :VOID)

;;; (DEFUN INITIALIZE-OPTIMIZER-MEMORY ...)

(CL:DEFUN INITIALIZE-OPTIMIZER-MEMORY (STACKSIZE)
  (CL:WHEN
   (CL:AND
    (CL:<= STACKSIZE 0)
    (CL:NOT
     (CL:EQ
      (CLSYS-SVAL QUERY-ENVIRONMENT OPTIMIZER-GOAL-RECORDS *QUERYENVIRONMENT*)
      NULL)))
   (CL:SETQ
    STACKSIZE
    (LENGTH
     (CLSYS-SVAL QUERY-ENVIRONMENT OPTIMIZER-GOAL-RECORDS *QUERYENVIRONMENT*))))
  (INITIALIZE-OPTIMIZER-GOAL-RECORDS STACKSIZE)
  (CLEAR (CLSYS-SVAL QUERY-ENVIRONMENT RESIDUE-GOALS *QUERYENVIRONMENT*))
  (CLEAR (CLSYS-SVAL QUERY-ENVIRONMENT BEST-GOAL-SEQUENCE *QUERYENVIRONMENT*))
  (CL:SETF
   (CLSYS-SVAL QUERY-ENVIRONMENT BEST-COST *QUERYENVIRONMENT*)
   NULL-INTEGER)
  :VOID)

;;; (DEFSPECIAL *QUERYOPTIMIZERCONTROLFRAME* ...)

(CL:DEFVAR *QUERYOPTIMIZERCONTROLFRAME*)

(CL:DEFUN READ-*QUERYOPTIMIZERCONTROLFRAME* ()
  (CL:RETURN-FROM
   READ-*QUERYOPTIMIZERCONTROLFRAME*
   *QUERYOPTIMIZERCONTROLFRAME*)
  :VOID)

(CL:DEFUN WRITE-*QUERYOPTIMIZERCONTROLFRAME* (VALUE)
  (CL:SETQ *QUERYOPTIMIZERCONTROLFRAME* VALUE)
  (CL:RETURN-FROM WRITE-*QUERYOPTIMIZERCONTROLFRAME* VALUE)
  :VOID)

;;; (DEFUN OPTIMIZE-QUERY ...)

(CL:DEFUN OPTIMIZE-QUERY (DESCRIPTION BOOLEANVECTOR PARENTFRAME)
  (CL:LET*
   ((FRAME (CREATE-DOWN-FRAME PARENTFRAME NULL))
    (VARIABLESCOUNT
     (CL:+
      (LENGTH (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION))
      (LENGTH (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES DESCRIPTION)))))
   (INITIALIZE-OPTIMIZER-MEMORY VARIABLESCOUNT)
   (CL:LET*
    ((SUBQUERYFRAME (NEW-TOP-SUBQUERY-FRAME)))
    (CL:SETF (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME) SUBQUERYFRAME)
    (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME CONTROL-FRAME SUBQUERYFRAME) FRAME))
   (ALLOCATE-BLOCK-OF-VARIABLE-FRAMES VARIABLESCOUNT FRAME)
   (CL:LET*
    ((INITIALLYBOUND? NULL)
     (IOVAR NULL)
     (VECTOR-001 (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001))
     (VECTOR-002 BOOLEANVECTOR)
     (INDEX-002 0)
     (LENGTH-002 (LENGTH VECTOR-002)))
    (CL:LOOP
     WHILE
     (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:< INDEX-002 LENGTH-002))
     DO
     (CL:PROGN
      (CL:SETQ
       IOVAR
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
        SGT-OPTIMIZE-PATTERN-VARIABLE))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:PROGN
      (CL:SETQ
       INITIALLYBOUND?
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
      (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
     (CL:WHEN
      (CL:EQ (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE INITIALLYBOUND?) 1)
      (SIMULATE-BIND-VARIABLE-TO-VALUE IOVAR))))
   (CL:LET*
    ((*QUERYOPTIMIZERCONTROLFRAME* FRAME))
    (CL:DECLARE (CL:SPECIAL *QUERYOPTIMIZERCONTROLFRAME*))
    (SIMULATE-AND-OPTIMIZE-QUERY
     (CLSYS-SVAL DESCRIPTION PROPOSITION DESCRIPTION)))
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME STATE FRAME) KWD-OPTIMIZE-PATTERN)
   (UNBIND-PATTERN-VARIABLES FRAME)
   (POP-CONTROL-FRAME *QUERYENVIRONMENT*)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN PARENTFRAME) NULL))
  :VOID)

;;; (DEFUN (SELECT-OPTIMAL-QUERY-PATTERN DESCRIPTION) ...)

(CL:DEFUN SELECT-OPTIMAL-QUERY-PATTERN (DESCRIPTION BOOLEANVECTOR PARENTFRAME)
  (CL:LET*
   ((PATTERN NULL)
    (QUERYPATTERNS (CLSYS-SVAL DESCRIPTION QUERY-PATTERNS DESCRIPTION)))
   (CL:WHEN
    (CL:NOT (CL:EQ QUERYPATTERNS NULL))
    (CL:SETQ PATTERN (LOOKUP QUERYPATTERNS BOOLEANVECTOR)))
   (CL:WHEN
    (CL:NOT (CL:EQ PATTERN NULL))
    (CL:RETURN-FROM SELECT-OPTIMAL-QUERY-PATTERN PATTERN))
   (CL:WHEN
    (CL:EQ QUERYPATTERNS NULL)
    (CL:SETF
     (CLSYS-SVAL DESCRIPTION QUERY-PATTERNS DESCRIPTION)
     (NEW-KEY-VALUE-LIST)))
   (CL:SETQ PATTERN (COPY-DESCRIPTION DESCRIPTION NULL))
   (INSERT-AT
    (CLSYS-SVAL DESCRIPTION QUERY-PATTERNS DESCRIPTION)
    BOOLEANVECTOR
    PATTERN)
   (OPTIMIZE-QUERY PATTERN BOOLEANVECTOR PARENTFRAME)
   (SIMPLIFY-DESCRIPTION PATTERN TRUE)
   (CL:RETURN-FROM SELECT-OPTIMAL-QUERY-PATTERN PATTERN))
  :VOID)

;;; (DEFSPECIAL *POSTOPTIMIZATION?* ...)

(CL:DEFVAR *POSTOPTIMIZATION?* FALSE
  "Used by 'simplify-description' to permit application
of order-dependent optimizations.")

(CL:DEFUN READ-*POSTOPTIMIZATION?* ()
  (CL:RETURN-FROM READ-*POSTOPTIMIZATION?* *POSTOPTIMIZATION?*)
  :VOID)

(CL:DEFUN WRITE-*POSTOPTIMIZATION?* (VALUE)
  (CL:SETQ *POSTOPTIMIZATION?* VALUE)
  (CL:RETURN-FROM WRITE-*POSTOPTIMIZATION?* VALUE)
  :VOID)

;;; (DEFUN SIMPLIFY-DESCRIPTION ...)

(CL:DEFUN SIMPLIFY-DESCRIPTION (DESCRIPTION POSTOPTIMIZATION?)
  (CL:LET*
   ((*POSTOPTIMIZATION?* POSTOPTIMIZATION?))
   (CL:DECLARE (CL:SPECIAL *POSTOPTIMIZATION?*))
   (SIMPLIFY-PROPOSITION (CLSYS-SVAL DESCRIPTION PROPOSITION DESCRIPTION)))
  :VOID)

;;; (DEFUN (COPY-LIST-TO-ARGUMENTS-VECTOR ARGUMENTS-VECTOR) ...)

(CL:DEFUN COPY-LIST-TO-ARGUMENTS-VECTOR (ARGUMENTS)
  (CL:LET*
   ((VECTOR (NEW-VECTOR (LENGTH ARGUMENTS))))
   (CL:LET*
    ((I NULL)
     (ARG NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST ARGUMENTS))
     (ITER-002 0))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ ARG (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
     (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR) I) ARG)))
   (CL:RETURN-FROM COPY-LIST-TO-ARGUMENTS-VECTOR VECTOR))
  :VOID)

;;; (DEFUN (PRIOR-CONJUNCT-CANCELS-IN-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN PRIOR-CONJUNCT-CANCELS-IN-PROPOSITION? (INCONJUNCT PRIORCONJUNCT)
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND PRIORCONJUNCT)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-IN)
     (CL:RETURN-FROM
      PRIOR-CONJUNCT-CANCELS-IN-PROPOSITION?
      (CL:IF
       (CL:AND
        (CL:EQ
         (EQL?
          (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS PRIORCONJUNCT))
          (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS INCONJUNCT)))
         1)
        (CL:EQ
         (CL:IF
          (CL:EQ *POSTOPTIMIZATION?* 1)
          (COLLECTION-IMPLIES-COLLECTION?
           (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS PRIORCONJUNCT))
           (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS INCONJUNCT)))
          (EQL?
           (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS PRIORCONJUNCT))
           (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS INCONJUNCT))))
         1))
       TRUE
       FALSE)))
    ((CL:OR
      (CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-FUNCTION)
      (CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-PREDICATE))
     (CL:LET*
      ((INMEMBER (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS INCONJUNCT)))
       (INTYPE (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS INCONJUNCT))))
      (CL:LET*
       ((TEST-VALUE-002 FALSE))
       (CL:SETQ TEST-VALUE-002 *POSTOPTIMIZATION?*)
       (CL:WHEN
        (CL:EQ TEST-VALUE-002 1)
        (CL:SETQ TEST-VALUE-002 (TYPE? INTYPE))
        (CL:WHEN
         (CL:EQ TEST-VALUE-002 1)
         (CL:SETQ
          TEST-VALUE-002
          (SURROGATE?
           (CAST
            (CLSYS-SVAL PROPOSITION OPERATOR PRIORCONJUNCT)
            SGT-OPTIMIZE-SLOTREF)))
         (CL:WHEN
          (CL:EQ TEST-VALUE-002 1)
          (CL:LET*
           ((FOUND?-001 FALSE))
           (CL:LET*
            ((ARGTYPE NULL)
             (ARG NULL)
             (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS PRIORCONJUNCT))
             (INDEX-001 0)
             (LENGTH-001 (LENGTH VECTOR-001))
             (ITER-001
              (SLOT-COLUMN-TYPES
               (CAST
                (CLSYS-SVAL
                 SURROGATE
                 SURROGATE-VALUE
                 (CAST
                  (CLSYS-SVAL PROPOSITION OPERATOR PRIORCONJUNCT)
                  SGT-OPTIMIZE-SLOTREF))
                SGT-OPTIMIZE-SLOT))))
            (CL:LOOP
             WHILE
             (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:EQ (NEXT? ITER-001) 1))
             DO
             (CL:PROGN
              (CL:SETQ
               ARG
               (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
              (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
             (CL:PROGN
              (CL:SETQ
               ARGTYPE
               (CAST (CLSYS-SVAL ITERATOR VALUE ITER-001) SGT-OPTIMIZE-TYPE)))
             (CL:WHEN
              (CL:AND
               (CL:EQ (EQL? ARG INMEMBER) 1)
               (CL:EQ
                (SUBTYPE-OF? ARGTYPE (CAST INTYPE SGT-OPTIMIZE-TYPE))
                1))
              (CL:SETQ FOUND?-001 TRUE)
              (CL:RETURN))))
           (CL:SETQ TEST-VALUE-002 FOUND?-001)))))
       (CL:LET*
        ((VALUE-001 TEST-VALUE-002))
        (CL:RETURN-FROM PRIOR-CONJUNCT-CANCELS-IN-PROPOSITION? VALUE-001)))))
    (CL:T (CL:RETURN-FROM PRIOR-CONJUNCT-CANCELS-IN-PROPOSITION? FALSE))))
  :VOID)

;;; (DEFUN REPLACE-CONNECTIVE-BY-PROPOSITION ...)

(CL:DEFUN REPLACE-CONNECTIVE-BY-PROPOSITION (CONNECTIVE PROPOSITION)
  (CL:WHEN
   (CL:NOT
    (CL:AND
     (CL:=
      (LENGTH (CLSYS-SVAL PROPOSITION DEPENDENT-PROPOSITIONS PROPOSITION))
      1)
     (CL:EQ
      (FIRST (CLSYS-SVAL PROPOSITION DEPENDENT-PROPOSITIONS PROPOSITION))
      CONNECTIVE)))
   (CL:ERROR
    "Safety violation: INTERNAL ERROR: `replace-connective-by-proposition' encountered unexpected connective/proposition structure."))
  (CL:SETF
   (CLSYS-SVAL PROPOSITION KIND CONNECTIVE)
   (CLSYS-SVAL PROPOSITION KIND PROPOSITION))
  (CL:SETF
   (CLSYS-SVAL PROPOSITION OPERATOR CONNECTIVE)
   (CLSYS-SVAL PROPOSITION OPERATOR PROPOSITION))
  (CL:SETF
   (CLSYS-SVAL PROPOSITION ARGUMENTS CONNECTIVE)
   (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
  :VOID)

;;; (DEFUN SIMPLIFY-CONJUNCTION ...)

(CL:DEFUN SIMPLIFY-CONJUNCTION (ANDPROPOSITION)
  (CL:LET*
   ((CONJUNCTSLIST (NEW-LIST)) (CURSOR NULL))
   (CL:LET*
    ((ARG NULL)
     (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS ANDPROPOSITION))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       ARG
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (PUSH CONJUNCTSLIST (CAST ARG SGT-OPTIMIZE-PROPOSITION))))
   (CL:SETQ CURSOR (CLSYS-SVAL LIST THE-CONS-LIST CONJUNCTSLIST))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:LET*
     ((CONJUNCT (CLSYS-SVAL CONS VALUE CURSOR)))
     (CL:LET*
      ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND CONJUNCT)))
      (CL:COND
       ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-EQUIVALENT)
        (CL:WHEN
         (CL:EQ
          (EQL?
           (VALUE-OF (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS CONJUNCT)))
           (VALUE-OF (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS CONJUNCT))))
          1)
         (CL:LET*
          ((ARG NULL)
           (VECTOR-002 (CLSYS-SVAL PROPOSITION ARGUMENTS CONJUNCT))
           (INDEX-002 0)
           (LENGTH-002 (LENGTH VECTOR-002)))
          (CL:LOOP
           WHILE
           (CL:< INDEX-002 LENGTH-002)
           DO
           (CL:PROGN
            (CL:SETQ
             ARG
             (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
            (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
           (REMOVE-DEPENDENT-PROPOSITION-LINK ARG CONJUNCT)))
         (CL:SETF (CLSYS-SVAL CONS VALUE CURSOR) TRUE-PROPOSITION)))
       ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-IN)
        (CL:LET*
         ((FOUND?-001 FALSE))
         (CL:LET*
          ((PRIORCONJUNCT NULL) (ITER-001 (CLSYS-SVAL CONS REST CURSOR)))
          (CL:LOOP
           WHILE
           (CL:NOT (CL:EQ ITER-001 NIL))
           DO
           (CL:PROGN
            (CL:SETQ
             PRIORCONJUNCT
             (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-OPTIMIZE-PROPOSITION))
            (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
           (CL:WHEN
            (CL:EQ
             (PRIOR-CONJUNCT-CANCELS-IN-PROPOSITION? CONJUNCT PRIORCONJUNCT)
             1)
            (CL:SETQ FOUND?-001 TRUE)
            (CL:RETURN))))
         (CL:WHEN
          (CL:EQ FOUND?-001 1)
          (CL:LET*
           ((ARG NULL)
            (VECTOR-003 (CLSYS-SVAL PROPOSITION ARGUMENTS CONJUNCT))
            (INDEX-003 0)
            (LENGTH-003 (LENGTH VECTOR-003)))
           (CL:LOOP
            WHILE
            (CL:< INDEX-003 LENGTH-003)
            DO
            (CL:PROGN
             (CL:SETQ
              ARG
              (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-003) INDEX-003))
             (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))
            (REMOVE-DEPENDENT-PROPOSITION-LINK ARG CONJUNCT)))
          (CL:SETF (CLSYS-SVAL CONS VALUE CURSOR) TRUE-PROPOSITION))))
       (CL:T NULL))))
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (CL:WHEN
    (CL:EQ (MEMBER? CONJUNCTSLIST TRUE-PROPOSITION) 1)
    (REMOVE CONJUNCTSLIST TRUE-PROPOSITION)
    (REVERSE CONJUNCTSLIST)
    (CL:IF
     (CL:= (LENGTH CONJUNCTSLIST) 1)
     (REPLACE-CONNECTIVE-BY-PROPOSITION ANDPROPOSITION (FIRST CONJUNCTSLIST))
     (CL:PROGN
      (CL:SETF
       (CLSYS-SVAL PROPOSITION ARGUMENTS ANDPROPOSITION)
       (COPY-LIST-TO-ARGUMENTS-VECTOR CONJUNCTSLIST))))
    (FREE CONJUNCTSLIST)))
  :VOID)

;;; (DEFUN SIMPLIFY-PROPOSITION ...)

(CL:DEFUN SIMPLIFY-PROPOSITION (PROPOSITION)
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-AND)
     (SIMPLIFY-CONJUNCTION PROPOSITION))
    (CL:T
     (CL:LET*
      ((ARG NULL)
       (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
       (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:LOOP
       WHILE
       (CL:< INDEX-001 LENGTH-001)
       DO
       (CL:PROGN
        (CL:SETQ
         ARG
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (CL:LET*
        ((ARG-001 ARG))
        (CL:COND
         ((CL:EQ (TAXONOMY-ISA? ARG SGT-OPTIMIZE-PROPOSITION) 1)
          (CL:LET*
           ((ARG NULL))
           (CL:SETQ ARG ARG-001)
           (SIMPLIFY-PROPOSITION ARG)))
         ((CL:EQ (TAXONOMY-ISA? ARG SGT-OPTIMIZE-DESCRIPTION) 1)
          (CL:LET*
           ((ARG NULL))
           (CL:SETQ ARG ARG-001)
           (SIMPLIFY-DESCRIPTION ARG *POSTOPTIMIZATION?*)))
         (CL:T NULL))))))))
  :VOID)

;;; (DEFUN (COPY-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN COPY-DESCRIPTION (SELF PARENTMAPPING)
  (CL:LET*
   ((COPY
     (CREATE-DESCRIPTION NULL-INTEGER (CLSYS-SVAL DESCRIPTION KIND SELF)))
    (MAPPING (NEW-KEY-VALUE-LIST)))
   (CL:WHEN
    (CL:NOT (CL:EQ PARENTMAPPING NULL))
    (CL:LET*
     ((V NULL)
      (K NULL)
      (ITER-001 (CLSYS-SVAL KEY-VALUE-LIST THE-KV-LIST PARENTMAPPING)))
     (CL:LOOP
      WHILE
      (CL:NOT (CL:EQ ITER-001 NULL))
      DO
      (CL:SETQ K (CLSYS-SVAL KV-CONS KEY ITER-001))
      (CL:PROGN
       (CL:SETQ V (CLSYS-SVAL KV-CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL KV-CONS REST ITER-001)))
      (CL:WHEN
       (CL:EQ (ISA? K SGT-OPTIMIZE-PATTERN-VARIABLE) 1)
       (INSERT-AT MAPPING K V)))))
   (CL:SETF
    (CLSYS-SVAL DESCRIPTION IO-VARIABLES COPY)
    (COPY-VARIABLES-VECTOR
     (CLSYS-SVAL DESCRIPTION IO-VARIABLES SELF)
     MAPPING))
   (CL:SETF
    (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES COPY)
    (COPY-VARIABLES-VECTOR
     (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES SELF)
     MAPPING))
   (CL:SETF
    (CLSYS-SVAL DESCRIPTION PROPOSITION COPY)
    (COPY-PROPOSITION (CLSYS-SVAL DESCRIPTION PROPOSITION SELF) MAPPING))
   (FREE MAPPING)
   (CL:RETURN-FROM COPY-DESCRIPTION COPY))
  :VOID)

;;; (DEFUN (COPY-VARIABLE PATTERN-VARIABLE) ...)

(CL:DEFUN COPY-VARIABLE (SELF MAPPING)
  (CL:LET*
   ((COPY (CAST (LOOKUP MAPPING SELF) SGT-OPTIMIZE-PATTERN-VARIABLE)))
   (CL:WHEN (CL:NOT (CL:EQ COPY NULL)) (CL:RETURN-FROM COPY-VARIABLE COPY))
   (CL:SETQ COPY (NEW-PATTERN-VARIABLE))
   (CL:SETF
    (CLSYS-SVAL PATTERN-VARIABLE ROOT-TYPE COPY)
    (CLSYS-SVAL PATTERN-VARIABLE ROOT-TYPE SELF))
   (CL:COND
    ((CL:OR
      (CL:EQ *PRINTMODE* KWD-OPTIMIZE-REALISTIC)
      (CL:EQ *PRINTMODE* KWD-OPTIMIZE-FLAT))
     (SET-DYNAMIC-SLOT-VALUE
      COPY
      SYM-OPTIMIZE-SKOLEM-NAME
      (DYNAMIC-SLOT-VALUE SELF SYM-OPTIMIZE-SKOLEM-NAME NULL)
      NULL))
    (CL:T
     (CL:LET*
      ((COPYNAME
        (CONCATENATE
         "?CP"
         (CLSYS-SVAL
          SYMBOL
          SYMBOL-NAME
          (DYNAMIC-SLOT-VALUE SELF SYM-OPTIMIZE-SKOLEM-NAME NULL)))))
      (CL:SETF (CL:CHAR COPYNAME 3) #\_)
      (SET-DYNAMIC-SLOT-VALUE
       COPY
       SYM-OPTIMIZE-SKOLEM-NAME
       (INTERN-SYMBOL COPYNAME)
       NULL))))
   (CL:LET*
    ((OBJECT-001 COPY)
     (VALUE-001
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (ACCESS-IN-CONTEXT (CLSYS-SVAL SKOLEM NOT-BOTTOM? SELF) SELF FALSE)))
     (OLD-VALUE-002 (CLSYS-SVAL SKOLEM NOT-BOTTOM? OBJECT-001))
     (NEW-VALUE-001
      (UPDATE-IN-CONTEXT
       OLD-VALUE-002
       (WRAP-BOOLEAN VALUE-001)
       OBJECT-001
       FALSE)))
    (CL:WHEN
     (CL:EQ (CS-VALUE? OLD-VALUE-002) 0)
     (CL:SETF (CLSYS-SVAL SKOLEM NOT-BOTTOM? OBJECT-001) NEW-VALUE-001)))
   (CL:LET*
    ((OBJECT-002 COPY)
     (VALUE-002
      (ACCESS-IN-CONTEXT
       (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE SELF)
       SELF
       FALSE))
     (OLD-VALUE-004 (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OBJECT-002))
     (NEW-VALUE-002
      (UPDATE-IN-CONTEXT OLD-VALUE-004 VALUE-002 OBJECT-002 FALSE)))
    (CL:WHEN
     (CL:EQ (CS-VALUE? OLD-VALUE-004) 0)
     (CL:SETF
      (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE OBJECT-002)
      NEW-VALUE-002)))
   (CL:SETF
    (CLSYS-SVAL PATTERN-VARIABLE BOUND-TO-OFFSET COPY)
    (LENGTH MAPPING))
   (INSERT-AT MAPPING SELF COPY)
   (CL:RETURN-FROM COPY-VARIABLE COPY))
  :VOID)

;;; (DEFUN (COPY-VARIABLES-VECTOR VARIABLES-VECTOR) ...)

(CL:DEFUN COPY-VARIABLES-VECTOR (SELF MAPPING)
  (CL:WHEN
   (CL:EQ (EMPTY? SELF) 1)
   (CL:RETURN-FROM COPY-VARIABLES-VECTOR ZERO-VARIABLES-VECTOR))
  (CL:LET*
   ((COPY (NEW-VECTOR (LENGTH SELF))))
   (CL:LET*
    ((I NULL)
     (VBL NULL)
     (VECTOR-001 SELF)
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001))
     (ITER-001 0))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       VBL
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
        SGT-OPTIMIZE-PATTERN-VARIABLE))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETF
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY COPY) I)
      (COPY-VARIABLE VBL MAPPING))))
   (CL:RETURN-FROM COPY-VARIABLES-VECTOR COPY))
  :VOID)

;;; (DEFUN (COPY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN COPY-PROPOSITION (SELF MAPPING)
  (CL:LET*
   ((COPY (CAST (LOOKUP MAPPING SELF) SGT-OPTIMIZE-PROPOSITION)))
   (CL:WHEN (CL:NOT (CL:EQ COPY NULL)) (CL:RETURN-FROM COPY-PROPOSITION COPY))
   (CL:SETQ COPY (NEW-PROPOSITION))
   (CL:SETF
    (CLSYS-SVAL PROPOSITION ARGUMENTS COPY)
    (NEW-VECTOR (LENGTH (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))))
   (CL:SETF
    (CLSYS-SVAL PROPOSITION KIND COPY)
    (CLSYS-SVAL PROPOSITION KIND SELF))
   (CL:SETF
    (CLSYS-SVAL PROPOSITION OPERATOR COPY)
    (COPY-PROPOSITION-ARGUMENT
     (CLSYS-SVAL PROPOSITION OPERATOR SELF)
     MAPPING))
   (CL:LET*
    ((OBJECT-001 COPY)
     (VALUE-001
      (ACCESS-IN-CONTEXT
       (CLSYS-SVAL PROPOSITION TRUTH-VALUE SELF)
       SELF
       FALSE))
     (OLD-VALUE-002 (CLSYS-SVAL PROPOSITION TRUTH-VALUE OBJECT-001))
     (NEW-VALUE-001
      (UPDATE-IN-CONTEXT OLD-VALUE-002 VALUE-001 OBJECT-001 FALSE)))
    (CL:WHEN
     (CL:EQ (CS-VALUE? OLD-VALUE-002) 0)
     (CL:SETF (CLSYS-SVAL PROPOSITION TRUTH-VALUE OBJECT-001) NEW-VALUE-001)))
   (CL:WHEN
    (CL:EQ (VARIABLE-TYPE? SELF) 1)
    (SET-DYNAMIC-SLOT-VALUE
     COPY
     SYM-OPTIMIZE-VARIABLE-TYPE?
     (WRAP-BOOLEAN TRUE)
     NULL-BOOLEAN-WRAPPER))
   (INSERT-AT MAPPING SELF COPY)
   (CL:LET*
    ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND SELF)))
    (CL:COND
     ((CL:OR
       (CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-FORALL)
       (CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-EXISTS))
      (SET-DYNAMIC-SLOT-VALUE
       COPY
       SYM-OPTIMIZE-IO-VARIABLES
       (COPY-VARIABLES-VECTOR
        (DYNAMIC-SLOT-VALUE SELF SYM-OPTIMIZE-IO-VARIABLES NULL)
        MAPPING)
       NULL))
     (CL:T NULL)))
   (CL:LET*
    ((I NULL)
     (ARG NULL)
     (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001))
     (ITER-001 0))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       ARG
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETF
      (CL:AREF
       (CLSYS-SVAL VECTOR THE-ARRAY (CLSYS-SVAL PROPOSITION ARGUMENTS COPY))
       I)
      (COPY-PROPOSITION-ARGUMENT ARG MAPPING))))
   (CL:LET*
    ((ARGCOPY NULL)
     (VECTOR-002 (CLSYS-SVAL PROPOSITION ARGUMENTS COPY))
     (INDEX-002 0)
     (LENGTH-002 (LENGTH VECTOR-002)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-002 LENGTH-002)
     DO
     (CL:PROGN
      (CL:SETQ
       ARGCOPY
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
      (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
     (ADD-DEPENDENT-PROPOSITION-LINK ARGCOPY COPY)))
   (CL:LET*
    ((TEST-VALUE-002 (CLSYS-SVAL PROPOSITION KIND SELF)))
    (CL:COND
     ((CL:EQ TEST-VALUE-002 KWD-OPTIMIZE-FUNCTION)
      (CL:LET*
       ((LASTARG (LAST-ARGUMENT SELF)))
       (CL:LET*
        ((LASTARG-001 LASTARG))
        (CL:COND
         ((CL:EQ (TAXONOMY-ISA? LASTARG SGT-OPTIMIZE-PATTERN-VARIABLE) 1)
          (CL:LET*
           ((LASTARG NULL))
           (CL:SETQ LASTARG LASTARG-001)
           (CL:SETF
            (CLSYS-SVAL
             PATTERN-VARIABLE
             DEFINING-PROPOSITION
             (CAST (LOOKUP MAPPING LASTARG) SGT-OPTIMIZE-PATTERN-VARIABLE))
            COPY)))
         (CL:T NULL)))))
     (CL:T NULL)))
   (CL:RETURN-FROM COPY-PROPOSITION COPY))
  :VOID)

;;; (DEFUN (COPY-PROPOSITION-ARGUMENT OBJECT) ...)

(CL:DEFUN COPY-PROPOSITION-ARGUMENT (SELF MAPPING)
  (CL:LET*
   ((COPY (LOOKUP MAPPING SELF)))
   (CL:WHEN
    (CL:NOT (CL:EQ COPY NULL))
    (CL:RETURN-FROM COPY-PROPOSITION-ARGUMENT COPY))
   (CL:LET*
    ((SELF-001 SELF))
    (CL:COND
     ((CL:EQ (TAXONOMY-ISA? SELF SGT-OPTIMIZE-PROPOSITION) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:RETURN-FROM
        COPY-PROPOSITION-ARGUMENT
        (COPY-PROPOSITION SELF MAPPING))))
     ((CL:EQ (TAXONOMY-ISA? SELF SGT-OPTIMIZE-DESCRIPTION) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:RETURN-FROM
        COPY-PROPOSITION-ARGUMENT
        (COPY-DESCRIPTION SELF MAPPING))))
     ((CL:EQ (TAXONOMY-ISA? SELF SGT-OPTIMIZE-PATTERN-VARIABLE) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:ERROR "OOPS -- BUG IN 'copy-description'")))
     (CL:T (CL:RETURN-FROM COPY-PROPOSITION-ARGUMENT SELF)))))
  :VOID)

;;; (DEFUN (INHERIT-AS-TOP-LEVEL-PROPOSITION (LIST OF PROPOSITION)) ...)

(CL:DEFUN INHERIT-AS-TOP-LEVEL-PROPOSITION (PROPOSITION)
  (CL:LET*
   ((MAPPING (NEW-KEY-VALUE-LIST)) (RESULTLIST (NEW-LIST)))
   (CL:LET*
    ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-OPTIMIZE-AND)
      (CL:LET*
       ((ARG NULL)
        (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
        (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:LOOP
        WHILE
        (CL:< INDEX-001 LENGTH-001)
        DO
        (CL:PROGN
         (CL:SETQ
          ARG
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
        (PUSH
         RESULTLIST
         (INHERIT-PROPOSITION (CAST ARG SGT-OPTIMIZE-PROPOSITION) MAPPING)))))
     (CL:T (PUSH RESULTLIST (INHERIT-PROPOSITION PROPOSITION MAPPING)))))
   (FREE MAPPING)
   (CL:RETURN-FROM INHERIT-AS-TOP-LEVEL-PROPOSITION RESULTLIST))
  :VOID)

;;; (DEFUN (INHERIT-VARIABLE PATTERN-VARIABLE) ...)

(CL:DEFUN INHERIT-VARIABLE (SELF MAPPING)
  (CL:LET*
   ((COPY (CAST (LOOKUP MAPPING SELF) SGT-OPTIMIZE-PATTERN-VARIABLE)))
   (CL:WHEN (CL:NOT (CL:EQ COPY NULL)) (CL:RETURN-FROM INHERIT-VARIABLE COPY))
   (CL:SETQ COPY (CAST (BOUND-TO SELF) SGT-OPTIMIZE-PATTERN-VARIABLE))
   (CL:WHEN
    (CL:EQ COPY NULL)
    (CL:ERROR
     "Safety violation: INTERNAL ERROR: `inherit-variable' encountered NULL binding."))
   (INSERT-AT MAPPING SELF COPY)
   (CL:WHEN
    (CL:NOT
     (CL:EQ (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION SELF) NULL))
    (CL:LET*
     ((COPY-001 COPY))
     (CL:COND
      ((CL:EQ (TAXONOMY-ISA? COPY SGT-OPTIMIZE-SKOLEM) 1)
       (CL:LET*
        ((COPY NULL))
        (CL:SETQ COPY COPY-001)
        (CL:WHEN
         (CL:NOT (CL:EQ (CLSYS-SVAL SKOLEM DEFINING-PROPOSITION COPY) NULL))
         (CL:ERROR
          "Safety violation: INTERNAL ERROR: `inherit-variable' encountered unexpected defining proposition on variable copy."))))
      (CL:T NULL))))
   (CL:RETURN-FROM INHERIT-VARIABLE COPY))
  :VOID)

;;; (DEFUN (INHERIT-VARIABLES-VECTOR VARIABLES-VECTOR) ...)

(CL:DEFUN INHERIT-VARIABLES-VECTOR (SELF MAPPING)
  (CL:WHEN
   (CL:EQ (EMPTY? SELF) 1)
   (CL:RETURN-FROM INHERIT-VARIABLES-VECTOR ZERO-VARIABLES-VECTOR))
  (CL:LET*
   ((COPY (NEW-VECTOR (LENGTH SELF))))
   (CL:LET*
    ((I NULL)
     (VBL NULL)
     (VECTOR-001 SELF)
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001))
     (ITER-001 0))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       VBL
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
        SGT-OPTIMIZE-PATTERN-VARIABLE))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETF
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY COPY) I)
      (INHERIT-VARIABLE VBL MAPPING))))
   (CL:RETURN-FROM INHERIT-VARIABLES-VECTOR COPY))
  :VOID)

;;; (DEFUN (INHERIT-FUNCTION-PROPOSITION PROPOSITION) ...)

(CL:DEFUN INHERIT-FUNCTION-PROPOSITION (SELF MAPPING ASSERT?)
  (CL:LET*
   ((SLOTREF
     (CAST (CLSYS-SVAL PROPOSITION OPERATOR SELF) SGT-OPTIMIZE-SLOTREF))
    (INPUTARGUMENTS NIL)
    (FUNCTIONCOPY NULL))
   (CL:LET*
    ((ARG NULL)
     (ITER-001 (BUT-LAST (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN (CL:SETQ ARG (CLSYS-SVAL ITERATOR VALUE ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (CONS ARG NIL))
       (CL:IF
        (CL:EQ INPUTARGUMENTS NIL)
        (CL:SETQ INPUTARGUMENTS COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST INPUTARGUMENTS COLLECT-001)))
      (CL:PROGN
       (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS ARG NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:SETQ
    FUNCTIONCOPY
    (CAST
     (FINISH-EVALUATING-FUNCTION-TERM SLOTREF INPUTARGUMENTS)
     SGT-OPTIMIZE-PROPOSITION))
   (FREE-CONS-LIST INPUTARGUMENTS)
   (CL:IF
    (CL:EQ ASSERT? 1)
    (CL:PROGN
     (EQUATE-VALUES
      (FUNCTION-REPRESENTATIVE FUNCTIONCOPY)
      (BOUND-TO (CAST (LAST-ARGUMENT SELF) SGT-OPTIMIZE-PATTERN-VARIABLE)))
     (CL:RETURN-FROM INHERIT-FUNCTION-PROPOSITION NULL))
    (CL:LET*
     ((COPY
       (FINISH-BUILDING-EQUIVALENCE-PROPOSITION
        (FUNCTION-REPRESENTATIVE FUNCTIONCOPY)
        (BOUND-TO
         (CAST (LAST-ARGUMENT SELF) SGT-OPTIMIZE-PATTERN-VARIABLE)))))
     (INSERT-AT MAPPING SELF COPY)
     (CL:RETURN-FROM INHERIT-FUNCTION-PROPOSITION COPY))))
  :VOID)

;;; (DEFUN (INHERIT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN INHERIT-PROPOSITION (SELF MAPPING)
  (CL:LET*
   ((COPY (CAST (LOOKUP MAPPING SELF) SGT-OPTIMIZE-PROPOSITION)))
   (CL:COND
    ((CL:NOT (CL:EQ COPY NULL)) (CL:RETURN-FROM INHERIT-PROPOSITION COPY))
    ((CL:EQ (CLSYS-SVAL PROPOSITION KIND SELF) KWD-OPTIMIZE-FUNCTION)
     (CL:RETURN-FROM
      INHERIT-PROPOSITION
      (INHERIT-FUNCTION-PROPOSITION SELF MAPPING FALSE))))
   (CL:SETQ COPY (NEW-PROPOSITION))
   (CL:SETF
    (CLSYS-SVAL PROPOSITION ARGUMENTS COPY)
    (NEW-VECTOR (LENGTH (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))))
   (CL:SETF
    (CLSYS-SVAL PROPOSITION KIND COPY)
    (CLSYS-SVAL PROPOSITION KIND SELF))
   (CL:WHEN
    (CL:EQ (VARIABLE-TYPE? SELF) 1)
    (SET-DYNAMIC-SLOT-VALUE
     COPY
     SYM-OPTIMIZE-VARIABLE-TYPE?
     (WRAP-BOOLEAN TRUE)
     NULL-BOOLEAN-WRAPPER))
   (INSERT-AT MAPPING SELF COPY)
   (CL:SETF
    (CLSYS-SVAL PROPOSITION OPERATOR COPY)
    (CL:IF
     (CL:EQ
      (ISA? (CLSYS-SVAL PROPOSITION OPERATOR SELF) SGT-OPTIMIZE-SURROGATE)
      1)
     (CLSYS-SVAL PROPOSITION OPERATOR SELF)
     (INHERIT-VARIABLE
      (CAST
       (CLSYS-SVAL PROPOSITION OPERATOR SELF)
       SGT-OPTIMIZE-PATTERN-VARIABLE)
      MAPPING)))
   (CL:LET*
    ((I NULL)
     (ARG NULL)
     (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001))
     (ITER-001 0))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       ARG
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETF
      (CL:AREF
       (CLSYS-SVAL VECTOR THE-ARRAY (CLSYS-SVAL PROPOSITION ARGUMENTS COPY))
       I)
      (INHERIT-PROPOSITION-ARGUMENT ARG MAPPING))))
   (CL:LET*
    ((COPYORDUPLICATE (FASTEN-DOWN-PROPOSITION COPY)))
    (CL:WHEN
     (CL:AND
      (CL:EQ (CLSYS-SVAL PROPOSITION KIND SELF) KWD-OPTIMIZE-FUNCTION)
      (CL:EQ COPYORDUPLICATE COPY))
     (CL:LET*
      ((ARGCOPY
        (CAST
         (LOOKUP MAPPING (LAST-ARGUMENT SELF))
         SGT-OPTIMIZE-PATTERN-VARIABLE)))
      (CL:WHEN
       (CL:NOT
        (CL:OR
         (CL:EQ
          (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION ARGCOPY)
          NULL)
         (CL:EQ
          (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION ARGCOPY)
          COPYORDUPLICATE)))
       (CL:ERROR
        "Safety violation: INTERNAL ERROR: `inherit-proposition' needs to point at two defining propositions using a single skolem."))
      (CL:SETF
       (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION ARGCOPY)
       COPYORDUPLICATE)))
    (CL:RETURN-FROM INHERIT-PROPOSITION COPYORDUPLICATE)))
  :VOID)

;;; (DEFUN (INHERIT-PROPOSITION-ARGUMENT OBJECT) ...)

(CL:DEFUN INHERIT-PROPOSITION-ARGUMENT (SELF MAPPING)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-OPTIMIZE-PROPOSITION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       INHERIT-PROPOSITION-ARGUMENT
       (INHERIT-PROPOSITION SELF MAPPING))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-OPTIMIZE-DESCRIPTION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       INHERIT-PROPOSITION-ARGUMENT
       (COPY-DESCRIPTION SELF MAPPING))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-OPTIMIZE-PATTERN-VARIABLE) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       INHERIT-PROPOSITION-ARGUMENT
       (INHERIT-VARIABLE SELF MAPPING))))
    ((CL:EQ (SURROGATE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       INHERIT-PROPOSITION-ARGUMENT
       (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF))))
    (CL:T (CL:RETURN-FROM INHERIT-PROPOSITION-ARGUMENT SELF))))
  :VOID)

(CL:DEFUN STARTUP-OPTIMIZE ()
  (CL:LET*
   ((*MODULE* (GET-MODULE "/LOGIC" TRUE)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SYM-OPTIMIZE-GENERATOR-GOALS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERATOR-GOALS" NULL 0))
    (CL:SETQ
     SYM-OPTIMIZE-OTHER-GOALS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHER-GOALS" NULL 0))
    (CL:SETQ
     SGT-OPTIMIZE-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-OPTIMIZE-GOAL-RECORD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-RECORD" NULL 1))
    (CL:SETQ
     SGT-OPTIMIZE-PATTERN-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
    (CL:SETQ
     SGT-OPTIMIZE-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
    (CL:SETQ KWD-OPTIMIZE-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
    (CL:SETQ
     SGT-OPTIMIZE-SLOTREF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTREF" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-OPTIMIZE-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-OPTIMIZE-PERMUTATION-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PERMUTATION-TABLE" NULL 0))
    (CL:SETQ
     SGT-OPTIMIZE-LITERAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-OPTIMIZE-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
    (CL:SETQ
     SGT-OPTIMIZE-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-OPTIMIZE-*DISTRIBUTEDOPENGOAL?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*DISTRIBUTEDOPENGOAL?*" NULL 0))
    (CL:SETQ
     KWD-OPTIMIZE-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     KWD-OPTIMIZE-EQUIVALENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
    (CL:SETQ KWD-OPTIMIZE-IN (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 2))
    (CL:SETQ
     KWD-OPTIMIZE-PREDICATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
    (CL:SETQ KWD-OPTIMIZE-NOT (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
    (CL:SETQ
     SYM-OPTIMIZE-UNIQUENESSVECTORS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNIQUENESSVECTORS" NULL 0))
    (CL:SETQ
     SYM-OPTIMIZE-INDEXING-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INDEXING-VECTOR" NULL 0))
    (CL:SETQ
     SGT-OPTIMIZE-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-OPTIMIZE-INVERSE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INVERSE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-OPTIMIZE-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
    (CL:SETQ
     SYM-OPTIMIZE-ESTIMATED-CARDINALITY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ESTIMATED-CARDINALITY" NULL 0))
    (CL:SETQ
     SGT-OPTIMIZE-LITERAL-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "LITERAL-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ KWD-OPTIMIZE-OPEN (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN" NULL 2))
    (CL:SETQ
     SGT-OPTIMIZE-BOOLEAN-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "BOOLEAN-VECTOR"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-OPTIMIZE-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "COLLECTION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     KWD-OPTIMIZE-FORALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
    (CL:SETQ
     KWD-OPTIMIZE-BOUND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOUND" NULL 2))
    (CL:SETQ KWD-OPTIMIZE-AND (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
    (CL:SETQ
     KWD-OPTIMIZE-IMPLIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
    (CL:SETQ
     KWD-OPTIMIZE-EXISTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
    (CL:SETQ
     SYM-OPTIMIZE-*QUERYOPTIMIZERCONTROLFRAME*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*QUERYOPTIMIZERCONTROLFRAME*" NULL 0))
    (CL:SETQ
     KWD-OPTIMIZE-PATTERN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN" NULL 2))
    (CL:SETQ
     SYM-OPTIMIZE-*POSTOPTIMIZATION?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*POSTOPTIMIZATION?*" NULL 0))
    (CL:SETQ
     SYM-OPTIMIZE-ENTITY-MAPPING
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ENTITY-MAPPING" NULL 0))
    (CL:SETQ
     KWD-OPTIMIZE-REALISTIC
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REALISTIC" NULL 2))
    (CL:SETQ KWD-OPTIMIZE-FLAT (INTERN-RIGID-SYMBOL-WRT-MODULE "FLAT" NULL 2))
    (CL:SETQ
     SYM-OPTIMIZE-SKOLEM-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM-NAME" NULL 0))
    (CL:SETQ
     SYM-OPTIMIZE-VARIABLE-TYPE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE?" NULL 0))
    (CL:SETQ
     SYM-OPTIMIZE-IO-VARIABLES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
    (CL:SETQ
     SGT-OPTIMIZE-SKOLEM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
    (CL:SETQ
     SGT-OPTIMIZE-SURROGATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "SURROGATE"
      (GET-MODULE "/STELLA" TRUE)
      1)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:SETQ
     V-0-0
     (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR
      (LIST (WRAP-LITERAL 0) (WRAP-LITERAL 0))))
    (CL:SETQ
     V-1-0
     (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR
      (LIST (WRAP-LITERAL 1) (WRAP-LITERAL 0))))
    (CL:SETQ
     V-0-1
     (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR
      (LIST (WRAP-LITERAL 0) (WRAP-LITERAL 1))))
    (CL:SETQ
     V-1-1
     (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR
      (LIST (WRAP-LITERAL 1) (WRAP-LITERAL 1))))
    (CL:SETQ V-1-0-AND-V-0-1 (LIST V-1-0 V-0-1))
    (CL:SETQ V-1-0-SINGLETON (LIST V-1-0))
    (CL:SETQ V-0-1-SINGLETON (LIST V-0-1)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 5) 1)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "GOAL-RECORD"
        "(DEFCLASS GOAL-RECORD (STANDARD-OBJECT) :SLOTS ((GENERATOR-GOALS :TYPE (LIST OF PROPOSITION) :ALLOCATION :EMBEDDED) (OTHER-GOALS :TYPE (LIST OF PROPOSITION) :ALLOCATION :EMBEDDED)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-GOAL-RECORD))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-GOAL-RECORD-SLOT-VALUE)))
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE ENTITY-MAPPING (KEY-VALUE-LIST OF OBJECT OBJECT) :DOCUMENTATION \"Used to keep track of already copied variables
and propositions within a 'copy-description' procedure.\")"))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VARIABLE-BOUND?"
        "PATTERN-VARIABLE"
        "(DEFUN (VARIABLE-BOUND? BOOLEAN) ((VARIABLE PATTERN-VARIABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VARIABLE-BOUND?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ARGUMENT-BOUND?"
        "OBJECT"
        "(DEFUN (ARGUMENT-BOUND? BOOLEAN) ((ARGUMENT OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ARGUMENT-BOUND?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNBOUND-VARIABLE?"
        "OBJECT"
        "(DEFUN (UNBOUND-VARIABLE? BOOLEAN) ((ARGUMENT OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNBOUND-VARIABLE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HAS-DISJUNCTION?"
        "PROPOSITION"
        "(DEFUN (HAS-DISJUNCTION? BOOLEAN) ((GOAL PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HAS-DISJUNCTION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MODAL-GOAL?"
        "PROPOSITION"
        "(DEFUN (MODAL-GOAL? BOOLEAN) ((GOAL PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MODAL-GOAL?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HAS-INVERSIONS?"
        "PROPOSITION"
        "(DEFUN (HAS-INVERSIONS? BOOLEAN) ((GOAL PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HAS-INVERSIONS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTED-PREDICATE?"
        "PROPOSITION"
        "(DEFUN (COMPUTED-PREDICATE? BOOLEAN) ((PREDICATEPROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTED-PREDICATE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIMULATE-CREATE-CHOICE-POINT"
        NULL
        "(DEFUN (SIMULATE-CREATE-CHOICE-POINT INTEGER) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIMULATE-CREATE-CHOICE-POINT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLASS-INHERITS-ENUMERATED-EXTENSION?"
        "CLASS"
        "(DEFUN (CLASS-INHERITS-ENUMERATED-EXTENSION? BOOLEAN) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLASS-INHERITS-ENUMERATED-EXTENSION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GENERATOR-COLLECTION?"
        "OBJECT"
        "(DEFUN (GENERATOR-COLLECTION? BOOLEAN) ((COLLECTION OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GENERATOR-COLLECTION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INITIALIZE-OPTIMIZER-GOAL-RECORDS"
        "INTEGER"
        "(DEFUN INITIALIZE-OPTIMIZER-GOAL-RECORDS ((SIZE INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INITIALIZE-OPTIMIZER-GOAL-RECORDS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GOAL-RECORD"
        "PATTERN-VARIABLE"
        "(DEFUN (GOAL-RECORD GOAL-RECORD) ((VARIABLE PATTERN-VARIABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GOAL-RECORD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-DISTRIBUTE-GOAL"
        "OBJECT"
        "(DEFUN HELP-DISTRIBUTE-GOAL ((ARGUMENT OBJECT) (PARENTGOAL PROPOSITION) (GENERATOR? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-DISTRIBUTE-GOAL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DISTRIBUTE-OPEN-GOAL"
        "PROPOSITION"
        "(DEFUN DISTRIBUTE-OPEN-GOAL ((GOAL PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DISTRIBUTE-OPEN-GOAL)))
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT SLOT UNIQUENESSVECTORS :TYPE (LIST OF BOOLEAN-VECTOR) :DOCUMENTATION \"Caches a list of vectors representing keys
for the slot/relation.\" :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT SLOT INDEXING-VECTOR :TYPE BOOLEAN-VECTOR :DOCUMENTATION \"Caches a vector indicating which arguments
of a slot/relation have backlinks to referencing propositions.\" :ALLOCATION :DYNAMIC)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-UNIQUENESS-VECTORS"
        "SLOT"
        "(DEFMETHOD (GET-UNIQUENESS-VECTORS (LIST OF BOOLEAN-VECTOR)) ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-UNIQUENESS-VECTORS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-INDEXING-VECTOR"
        "SLOT"
        "(DEFMETHOD (GET-INDEXING-VECTOR BOOLEAN-VECTOR) ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-INDEXING-VECTOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-UNIQUENESS-VECTORS"
        "STORAGE-SLOT"
        "(DEFMETHOD (GET-UNIQUENESS-VECTORS (LIST OF BOOLEAN-VECTOR)) ((SELF STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-UNIQUENESS-VECTORS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-INDEXING-VECTOR"
        "STORAGE-SLOT"
        "(DEFMETHOD (GET-INDEXING-VECTOR BOOLEAN-VECTOR) ((SELF STORAGE-SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-INDEXING-VECTOR)))
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT DESCRIPTION ESTIMATED-CARDINALITY :TYPE INTEGER :DOCUMENTATION \"Stores an estimate of the current number of instances
asserted to belong to a class or its subclasses.  The estimate
may be out of date, or may have been truncated by a thresholding
operation.\" :ALLOCATION :DYNAMIC)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ESTIMATE-CARDINALITY-OF-CLASS-EXTENSION"
        "CLASS"
        "(DEFUN (ESTIMATE-CARDINALITY-OF-CLASS-EXTENSION INTEGER) ((CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ESTIMATE-CARDINALITY-OF-CLASS-EXTENSION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ESTIMATE-PREDICATE-GOAL-COST"
        "PROPOSITION"
        "(DEFUN (ESTIMATE-PREDICATE-GOAL-COST INTEGER) ((GOAL PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ESTIMATE-PREDICATE-GOAL-COST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ESTIMATE-GOAL-COST"
        "PROPOSITION"
        "(DEFUN (ESTIMATE-GOAL-COST INTEGER) ((GOAL PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ESTIMATE-GOAL-COST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CHEAPEST-GENERATOR-GOAL"
        "PATTERN-VARIABLE"
        "(DEFUN (CHEAPEST-GENERATOR-GOAL PROPOSITION INTEGER) ((VARIABLE PATTERN-VARIABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CHEAPEST-GENERATOR-GOAL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PROPAGATE-SINGLE-VALUED-CONSTRAINTS"
        "PROPOSITION"
        "(DEFUN PROPAGATE-SINGLE-VALUED-CONSTRAINTS ((GOAL PROPOSITION) (GOALSEQUENCE (LIST OF PROPOSITION))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PROPAGATE-SINGLE-VALUED-CONSTRAINTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECT-CLOSED-GOALS"
        "LIST"
        "(DEFUN COLLECT-CLOSED-GOALS ((GOALS (LIST OF PROPOSITION)) (GOALSEQUENCE (LIST OF PROPOSITION))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECT-CLOSED-GOALS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS"
        "PATTERN-VARIABLE"
        "(DEFUN SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS ((VARIABLE PATTERN-VARIABLE) (GOALSEQUENCE (LIST OF PROPOSITION))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIMULATE-BIND-VARIABLE-AND-PROPAGATE-CONSTRAINTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BIND-ALL-VARIABLES-IN-GENERATOR-GOAL"
        "PROPOSITION"
        "(DEFUN BIND-ALL-VARIABLES-IN-GENERATOR-GOAL ((GOAL PROPOSITION) (GOALSEQUENCE (LIST OF PROPOSITION))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BIND-ALL-VARIABLES-IN-GENERATOR-GOAL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING"
        "LIST"
        "(DEFUN COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING ((OPTIMIZERVARIABLES (LIST OF PATTERN-VARIABLE)) (NUMBEROFOPENGOALS INTEGER) (GOALSEQUENCE (LIST OF PROPOSITION)) (COST INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-OPTIMAL-OPEN-GOAL-ORDERING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECT-OPTIMIZER-VARIABLES"
        "PROPOSITION"
        "(DEFUN COLLECT-OPTIMIZER-VARIABLES ((PROPOSITION PROPOSITION) (COLLECTION LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECT-OPTIMIZER-VARIABLES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "OPTIMIZE-ORDERING-OF-CONJUNCTS"
        "PROPOSITION"
        "(DEFUN OPTIMIZE-ORDERING-OF-CONJUNCTS ((ANDPROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION OPTIMIZE-ORDERING-OF-CONJUNCTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-BACKUP-OPEN-GOAL-ORDERING"
        "LIST"
        "(DEFUN COMPUTE-BACKUP-OPEN-GOAL-ORDERING ((GOALSEQUENCE (LIST OF PROPOSITION))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-BACKUP-OPEN-GOAL-ORDERING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REORDER-GOALS"
        "PROPOSITION"
        "(DEFUN REORDER-GOALS ((ANDPROPOSITION PROPOSITION) (INITIALLYCLOSEDGOALS (LIST OF PROPOSITION)) (GOALSEQUENCE (LIST OF PROPOSITION)) (RESIDUEGOALS (LIST OF PROPOSITION))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REORDER-GOALS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIMULATE-BIND-VARIABLE-TO-VALUE"
        "OBJECT"
        "(DEFUN SIMULATE-BIND-VARIABLE-TO-VALUE ((FORMULA OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIMULATE-BIND-VARIABLE-TO-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "WARN-OF-UNBOUND-VARIABLE-ARGUMENT"
        "PROPOSITION"
        "(DEFUN WARN-OF-UNBOUND-VARIABLE-ARGUMENT ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION WARN-OF-UNBOUND-VARIABLE-ARGUMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIMULATE-GOAL-EVALUATION"
        "PROPOSITION"
        "(DEFUN SIMULATE-GOAL-EVALUATION ((GOAL PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIMULATE-GOAL-EVALUATION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIMULATE-AND-OPTIMIZE-ARGUMENT"
        "OBJECT"
        "(DEFUN SIMULATE-AND-OPTIMIZE-ARGUMENT ((FORMULA OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIMULATE-AND-OPTIMIZE-ARGUMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIMULATE-AND-OPTIMIZE-QUERY"
        "PROPOSITION"
        "(DEFUN SIMULATE-AND-OPTIMIZE-QUERY ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIMULATE-AND-OPTIMIZE-QUERY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INITIALIZE-OPTIMIZER-MEMORY"
        "INTEGER"
        "(DEFUN INITIALIZE-OPTIMIZER-MEMORY ((STACKSIZE INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INITIALIZE-OPTIMIZER-MEMORY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "OPTIMIZE-QUERY"
        "DESCRIPTION"
        "(DEFUN OPTIMIZE-QUERY ((DESCRIPTION DESCRIPTION) (BOOLEANVECTOR BOOLEAN-VECTOR) (PARENTFRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION OPTIMIZE-QUERY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SELECT-OPTIMAL-QUERY-PATTERN"
        "DESCRIPTION"
        "(DEFUN (SELECT-OPTIMAL-QUERY-PATTERN DESCRIPTION) ((DESCRIPTION DESCRIPTION) (BOOLEANVECTOR BOOLEAN-VECTOR) (PARENTFRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SELECT-OPTIMAL-QUERY-PATTERN)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIMPLIFY-DESCRIPTION"
        "DESCRIPTION"
        "(DEFUN SIMPLIFY-DESCRIPTION ((DESCRIPTION DESCRIPTION) (POSTOPTIMIZATION? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIMPLIFY-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY-LIST-TO-ARGUMENTS-VECTOR"
        "LIST"
        "(DEFUN (COPY-LIST-TO-ARGUMENTS-VECTOR ARGUMENTS-VECTOR) ((ARGUMENTS LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COPY-LIST-TO-ARGUMENTS-VECTOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRIOR-CONJUNCT-CANCELS-IN-PROPOSITION?"
        "PROPOSITION"
        "(DEFUN (PRIOR-CONJUNCT-CANCELS-IN-PROPOSITION? BOOLEAN) ((INCONJUNCT PROPOSITION) (PRIORCONJUNCT PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRIOR-CONJUNCT-CANCELS-IN-PROPOSITION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "REPLACE-CONNECTIVE-BY-PROPOSITION"
        "PROPOSITION"
        "(DEFUN REPLACE-CONNECTIVE-BY-PROPOSITION ((CONNECTIVE PROPOSITION) (PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION REPLACE-CONNECTIVE-BY-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIMPLIFY-CONJUNCTION"
        "PROPOSITION"
        "(DEFUN SIMPLIFY-CONJUNCTION ((ANDPROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIMPLIFY-CONJUNCTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SIMPLIFY-PROPOSITION"
        "PROPOSITION"
        "(DEFUN SIMPLIFY-PROPOSITION ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SIMPLIFY-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY-DESCRIPTION"
        "DESCRIPTION"
        "(DEFUN (COPY-DESCRIPTION DESCRIPTION) ((SELF DESCRIPTION) (PARENTMAPPING ENTITY-MAPPING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COPY-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY-VARIABLE"
        "PATTERN-VARIABLE"
        "(DEFUN (COPY-VARIABLE PATTERN-VARIABLE) ((SELF PATTERN-VARIABLE) (MAPPING ENTITY-MAPPING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COPY-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY-VARIABLES-VECTOR"
        "VECTOR"
        "(DEFUN (COPY-VARIABLES-VECTOR VARIABLES-VECTOR) ((SELF VARIABLES-VECTOR) (MAPPING ENTITY-MAPPING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COPY-VARIABLES-VECTOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY-PROPOSITION"
        "PROPOSITION"
        "(DEFUN (COPY-PROPOSITION PROPOSITION) ((SELF PROPOSITION) (MAPPING ENTITY-MAPPING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COPY-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY-PROPOSITION-ARGUMENT"
        "OBJECT"
        "(DEFUN (COPY-PROPOSITION-ARGUMENT OBJECT) ((SELF OBJECT) (MAPPING ENTITY-MAPPING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COPY-PROPOSITION-ARGUMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-AS-TOP-LEVEL-PROPOSITION"
        "PROPOSITION"
        "(DEFUN (INHERIT-AS-TOP-LEVEL-PROPOSITION (LIST OF PROPOSITION)) ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-AS-TOP-LEVEL-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-VARIABLE"
        "PATTERN-VARIABLE"
        "(DEFUN (INHERIT-VARIABLE PATTERN-VARIABLE) ((SELF PATTERN-VARIABLE) (MAPPING ENTITY-MAPPING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-VARIABLE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-VARIABLES-VECTOR"
        "VECTOR"
        "(DEFUN (INHERIT-VARIABLES-VECTOR VARIABLES-VECTOR) ((SELF VARIABLES-VECTOR) (MAPPING ENTITY-MAPPING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-VARIABLES-VECTOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-FUNCTION-PROPOSITION"
        "PROPOSITION"
        "(DEFUN (INHERIT-FUNCTION-PROPOSITION PROPOSITION) ((SELF PROPOSITION) (MAPPING ENTITY-MAPPING) (ASSERT? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-FUNCTION-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-PROPOSITION"
        "PROPOSITION"
        "(DEFUN (INHERIT-PROPOSITION PROPOSITION) ((SELF PROPOSITION) (MAPPING ENTITY-MAPPING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-PROPOSITION-ARGUMENT"
        "OBJECT"
        "(DEFUN (INHERIT-PROPOSITION-ARGUMENT OBJECT) ((SELF OBJECT) (MAPPING ENTITY-MAPPING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-PROPOSITION-ARGUMENT)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-OPTIMIZE"
     NULL
     "(DEFUN STARTUP-OPTIMIZE ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DISTRIBUTEDOPENGOAL?* BOOLEAN :DOCUMENTATION \"Used by 'distribute-open-goal' to signal that
a goal was distributed by 'help-distribute-goal'.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-OPTIMIZE-*DISTRIBUTEDOPENGOAL?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*DISTRIBUTEDOPENGOAL?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*DISTRIBUTEDOPENGOAL?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT V-0-0 BOOLEAN-VECTOR (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR (LIST 0 0)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT V-1-0 BOOLEAN-VECTOR (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR (LIST 1 0)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT V-0-1 BOOLEAN-VECTOR (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR (LIST 0 1)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT V-1-1 BOOLEAN-VECTOR (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR (LIST 1 1)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT V-1-0-AND-V-0-1 (LIST OF BOOLEAN-VECTOR) (LIST V-1-0 V-0-1))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT V-1-0-SINGLETON (LIST OF BOOLEAN-VECTOR) (LIST V-1-0))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT V-0-1-SINGLETON (LIST OF BOOLEAN-VECTOR) (LIST V-0-1))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ESTIMATED-SLOT-VALUE-COLLECTION-SIZE INTEGER 4 :DOCUMENTATION \"Estimate of the average size of a collection
representing the fillers of a slot.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS INTEGER 6 :DOCUMENTATION \"Very crude estimate of the number of stored propositions
that will match a predicate at least one of whose arguments are bound.
Chosen to be larger than ESTIMATED-SLOT-VALUE-COLLECTION-SIZE.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *QUERYOPTIMIZERCONTROLFRAME* CONTROL-FRAME :DOCUMENTATION \"Keeps track of last control frame allocated by
the query optimizer.  Used by recursive invocations of the optimizer.\")")
    (CL:LET*
     ((GLOBAL
       (LOOKUP-GLOBAL-VARIABLE SYM-OPTIMIZE-*QUERYOPTIMIZERCONTROLFRAME*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*QUERYOPTIMIZERCONTROLFRAME*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*QUERYOPTIMIZERCONTROLFRAME*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *POSTOPTIMIZATION?* BOOLEAN FALSE :DOCUMENTATION \"Used by 'simplify-description' to permit application
of order-dependent optimizations.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-OPTIMIZE-*POSTOPTIMIZATION?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*POSTOPTIMIZATION?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*POSTOPTIMIZATION?*)))))
  :VOID)
