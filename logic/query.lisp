;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997                   | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-QUERY-QUERY-ENVIRONMENT NULL)
(CL:DEFVAR SYM-QUERY-EXTERNAL-VARIABLES NULL)
(CL:DEFVAR SYM-QUERY-SOLUTIONS NULL)
(CL:DEFVAR SYM-QUERY-EXHAUSTED? NULL)
(CL:DEFVAR SGT-QUERY-QUERY-ENVIRONMENT NULL)
(CL:DEFVAR SGT-QUERY-VECTOR NULL)
(CL:DEFVAR SGT-QUERY-LIST NULL)
(CL:DEFVAR SGT-QUERY-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SGT-QUERY-QUERY-ITERATOR NULL)
(CL:DEFVAR SYM-QUERY-STATE NULL)
(CL:DEFVAR SYM-QUERY-PHASE NULL)
(CL:DEFVAR SYM-QUERY-PROPOSITION NULL)
(CL:DEFVAR SYM-QUERY-REVERSE-POLARITY? NULL)
(CL:DEFVAR SYM-QUERY-UP NULL)
(CL:DEFVAR SYM-QUERY-DOWN NULL)
(CL:DEFVAR SYM-QUERY-BACK NULL)
(CL:DEFVAR SYM-QUERY-ARGUMENT-CURSOR NULL)
(CL:DEFVAR SYM-QUERY-ITERATOR NULL)
(CL:DEFVAR SYM-QUERY-SUBQUERY-FRAME NULL)
(CL:DEFVAR SYM-QUERY-PARENT-PATTERN-FRAME NULL)
(CL:DEFVAR SYM-QUERY-GOAL-CACHE NULL)
(CL:DEFVAR SYM-QUERY-PARTIAL-MATCH-FRAME NULL)
(CL:DEFVAR SYM-QUERY-DEBUG-FRAME-OFFSET NULL)
(CL:DEFVAR SYM-QUERY-DEBUG-DEPTH NULL)
(CL:DEFVAR SYM-QUERY-CHOICE-POINT-UNBINDING-OFFSET NULL)
(CL:DEFVAR SGT-QUERY-KEYWORD NULL)
(CL:DEFVAR SGT-QUERY-PROPOSITION NULL)
(CL:DEFVAR SGT-QUERY-CONTROL-FRAME NULL)
(CL:DEFVAR SGT-QUERY-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-QUERY-ITERATOR NULL)
(CL:DEFVAR SGT-QUERY-SUBQUERY-FRAME NULL)
(CL:DEFVAR SGT-QUERY-GOAL-CACHE NULL)
(CL:DEFVAR SGT-QUERY-PARTIAL-MATCH-FRAME NULL)
(CL:DEFVAR SYM-QUERY-KIND-OF-GOAL NULL)
(CL:DEFVAR SYM-QUERY-STRATEGY-PRIORITY NULL)
(CL:DEFVAR SYM-QUERY-STRATEGY-PROCEDURE NULL)
(CL:DEFVAR SGT-QUERY-FUNCTION-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-QUERY-GOAL-STRATEGY NULL)
(CL:DEFVAR *RECYCLED-QUERY-ENVIRONMENT-S* NULL)
(CL:DEFVAR SYM-QUERY-CONTROL-FRAME-STACK NULL)
(CL:DEFVAR SYM-QUERY-CONTROL-FRAME-OFFSET-LIMIT NULL)
(CL:DEFVAR SYM-QUERY-TOP-CONTROL-FRAME-OFFSET NULL)
(CL:DEFVAR SYM-QUERY-VARIABLE-FRAME-STACK NULL)
(CL:DEFVAR SYM-QUERY-VARIABLE-FRAME-OFFSET-LIMIT NULL)
(CL:DEFVAR SYM-QUERY-TOP-VARIABLE-FRAME-OFFSET NULL)
(CL:DEFVAR SYM-QUERY-UNBINDING-STACK NULL)
(CL:DEFVAR SYM-QUERY-UNBINDING-STACK-OFFSET-LIMIT NULL)
(CL:DEFVAR SYM-QUERY-TOP-UNBINDING-STACK-OFFSET NULL)
(CL:DEFVAR SYM-QUERY-CURRENT-VARIABLE-FRAME-OFFSET NULL)
(CL:DEFVAR SYM-QUERY-CURRENT-SUBQUERY-FRAME NULL)
(CL:DEFVAR SYM-QUERY-PARTIAL-MATCH-STRATEGY NULL)
(CL:DEFVAR SYM-QUERY-LATEST-POSITIVE-SCORE NULL)
(CL:DEFVAR SYM-QUERY-ITERATIVE-DEEPENING? NULL)
(CL:DEFVAR SYM-QUERY-CURRENT-DEPTH-CUTOFF NULL)
(CL:DEFVAR SYM-QUERY-MAXIMUM-DEPTH NULL)
(CL:DEFVAR SYM-QUERY-AUGMENTED-GOAL-CACHE? NULL)
(CL:DEFVAR SYM-QUERY-ACTIVE-GOAL-CACHES NULL)
(CL:DEFVAR SYM-QUERY-TRIGGERED-DEPTH-CUTOFF? NULL)
(CL:DEFVAR SYM-QUERY-FAILED-TO-FIND-DUPLICATE-SUBGOAL? NULL)
(CL:DEFVAR SYM-QUERY-FOUND-AT-LEAST-ONE-SOLUTION? NULL)
(CL:DEFVAR SYM-QUERY-DEEP-INFERENCE? NULL)
(CL:DEFVAR SYM-QUERY-QUERY-THREAD-OFFSET NULL)
(CL:DEFVAR SYM-QUERY-TIME-STAMP NULL)
(CL:DEFVAR SYM-QUERY-QUERY-ITERATOR NULL)
(CL:DEFVAR SYM-QUERY-SUBSUMPTION-QUERY? NULL)
(CL:DEFVAR SYM-QUERY-SPECIALIZING-DESCRIPTION NULL)
(CL:DEFVAR SYM-QUERY-OPTIMIZER-GOAL-RECORDS NULL)
(CL:DEFVAR SYM-QUERY-RESIDUE-GOALS NULL)
(CL:DEFVAR SYM-QUERY-BEST-GOAL-SEQUENCE NULL)
(CL:DEFVAR SYM-QUERY-BEST-COST NULL)
(CL:DEFVAR SGT-QUERY-INTEGER-VECTOR NULL)
(CL:DEFVAR SGT-QUERY-FLOAT-WRAPPER NULL)
(CL:DEFVAR SGT-QUERY-DESCRIPTION NULL)
(CL:DEFVAR SGT-QUERY-EXTENSIBLE-VECTOR NULL)
(CL:DEFVAR SYM-QUERY-*QUERYENVIRONMENT* NULL)
(CL:DEFVAR *RECYCLED-SUBQUERY-FRAME-S* NULL)
(CL:DEFVAR SYM-QUERY-CONTROL-FRAME NULL)
(CL:DEFVAR SYM-QUERY-DESCRIPTION NULL)
(CL:DEFVAR SYM-QUERY-EXTERNAL-ARGUMENTS NULL)
(CL:DEFVAR SYM-QUERY-BOOLEAN-VECTOR NULL)
(CL:DEFVAR SYM-QUERY-LOCAL-VARIABLE-FRAME-OFFSET NULL)
(CL:DEFVAR SYM-QUERY-OPTIMAL-PATTERN NULL)
(CL:DEFVAR SYM-QUERY-PHASES-FILTER NULL)
(CL:DEFVAR SGT-QUERY-BOOLEAN-VECTOR NULL)
(CL:DEFVAR SYM-QUERY-TRUE-LINK NULL)
(CL:DEFVAR SYM-QUERY-FALSE-LINK NULL)
(CL:DEFVAR SYM-QUERY-VECTOR NULL)
(CL:DEFVAR SGT-QUERY-BOOLEAN-VECTOR-INDEX-NODE NULL)
(CL:DEFVAR SGT-QUERY-PATTERN-VARIABLE NULL)
(CL:DEFVAR KWD-QUERY-QUERY-STACKS NULL)
(CL:DEFVAR KWD-QUERY-PATTERN NULL)
(CL:DEFVAR KWD-QUERY-CONTAINED-BY NULL)
(CL:DEFVAR KWD-QUERY-POPPED NULL)
(CL:DEFVAR KWD-QUERY-LOCAL NULL)
(CL:DEFVAR KWD-QUERY-PARENT NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-QUERY-SLOT NULL)
(CL:DEFVAR KWD-QUERY-SORT NULL)
(CL:DEFVAR KWD-QUERY-NONE NULL)
(CL:DEFVAR KWD-QUERY-IN NULL)
(CL:DEFVAR SGT-QUERY-SURROGATE NULL)
(CL:DEFVAR SGT-QUERY-TYPE NULL)
(CL:DEFVAR SGT-QUERY-CLASS NULL)
(CL:DEFVAR KWD-QUERY-SHALLOW-DISJOINT NULL)
(CL:DEFVAR KWD-QUERY-DISJOINT NULL)
(CL:DEFVAR SGT-QUERY-SLOTREF NULL)
(CL:DEFVAR SYM-QUERY-SKOLEM-NAME NULL)
(CL:DEFVAR KWD-QUERY-DOWN NULL)
(CL:DEFVAR KWD-QUERY-ITERATIVE-FORALL NULL)
(CL:DEFVAR KWD-QUERY-STATE-MACHINE NULL)
(CL:DEFVAR KWD-QUERY-SUBGOALS NULL)
(CL:DEFVAR KWD-QUERY-TERMINATION NULL)
(CL:DEFVAR KWD-QUERY-ANTECEDENTS NULL)
(CL:DEFVAR KWD-QUERY-REALISTIC NULL)
(CL:DEFVAR KWD-QUERY-COMPLEMENT NULL)
(CL:DEFVAR KWD-QUERY-UP-TRUE NULL)
(CL:DEFVAR KWD-QUERY-UP-FAIL NULL)
(CL:DEFVAR KWD-QUERY-AND NULL)
(CL:DEFVAR KWD-QUERY-OR NULL)
(CL:DEFVAR KWD-QUERY-NOT NULL)
(CL:DEFVAR KWD-QUERY-INITIAL NULL)
(CL:DEFVAR KWD-QUERY-GOAL-TREE NULL)
(CL:DEFVAR KWD-QUERY-SELECT-STRATEGY NULL)
(CL:DEFVAR KWD-QUERY-HEAVY-DUTY-DISJUNCTION NULL)
(CL:DEFVAR KWD-QUERY-FUNCTION NULL)
(CL:DEFVAR KWD-QUERY-PREDICATE NULL)
(CL:DEFVAR KWD-QUERY-EQUIVALENT NULL)
(CL:DEFVAR KWD-QUERY-IMPLIES NULL)
(CL:DEFVAR KWD-QUERY-CONSTANT NULL)
(CL:DEFVAR KWD-QUERY-CONTINUING-SUCCESS NULL)
(CL:DEFVAR KWD-QUERY-FINAL-SUCCESS NULL)
(CL:DEFVAR KWD-QUERY-FAILURE NULL)
(CL:DEFVAR KWD-QUERY-OVERLAY NULL)
(CL:DEFVAR KWD-QUERY-SPAWNED-SUBQUERY NULL)
(CL:DEFVAR KWD-QUERY-SUCCESS NULL)
(CL:DEFVAR KWD-QUERY-FAILED-OVERLAY NULL)
(CL:DEFVAR KWD-QUERY-SUBGOAL NULL)
(CL:DEFVAR KWD-QUERY-EXISTS NULL)
(CL:DEFVAR KWD-QUERY-FORALL NULL)
(CL:DEFVAR SYM-QUERY-IO-VARIABLES NULL)
(CL:DEFVAR KWD-QUERY-CACHED-BINDINGS NULL)
(CL:DEFVAR KWD-QUERY-FAIL NULL)
(CL:DEFVAR KWD-QUERY-END-SUBUMPTION-TEST NULL)
(CL:DEFVAR SGT-QUERY-STANDARD-OBJECT NULL)
(CL:DEFVAR SYM-QUERY-*REVERSEPOLARITY?* NULL)
(CL:DEFVAR KWD-QUERY-ALL-SUBGOAL-PHASES NULL)
(CL:DEFVAR KWD-QUERY-SUBGOALS-OVERLAY NULL)
(CL:DEFVAR KWD-QUERY-OPEN NULL)
(CL:DEFVAR KWD-QUERY-SCAN-COLLECTION NULL)
(CL:DEFVAR SYM-QUERY-COMPLEMENT-DESCRIPTION NULL)
(CL:DEFVAR KWD-QUERY-SCAN-SUBCOLLECTIONS NULL)
(CL:DEFVAR KWD-QUERY-SCAN-SUPERCOLLECTIONS NULL)
(CL:DEFVAR KWD-QUERY-DO-CONTAINED-BY NULL)
(CL:DEFVAR KWD-QUERY-SUBSUMPTION-OVERLAY NULL)
(CL:DEFVAR SYM-QUERY-CONTAINED-BY NULL)
(CL:DEFVAR SYM-QUERY-IN NULL)
(CL:DEFVAR KWD-QUERY-SKIP-DEFINITION NULL)
(CL:DEFVAR KWD-QUERY-PRE-ANTECEDENTS NULL)
(CL:DEFVAR KWD-QUERY-DEFINITION NULL)
(CL:DEFVAR KWD-QUERY-FULL-SUBQUERY NULL)
(CL:DEFVAR SYM-QUERY-DEFINITION NULL)
(CL:DEFVAR SGT-QUERY-WORLD NULL)
(CL:DEFVAR SYM-QUERY-MONOTONIC? NULL)
(CL:DEFVAR SYM-QUERY-NON-DISJOINTNESS-KLUDGE? NULL)
(CL:DEFVAR SGT-QUERY-COLLECTION NULL)
(CL:DEFVAR SGT-QUERY-COLLECTION.CLOSED NULL)
(CL:DEFVAR KWD-QUERY-CLOSED NULL)
(CL:DEFVAR KWD-QUERY-PRIMITIVE NULL)
(CL:DEFVAR KWD-QUERY-ENUMERATION NULL)
(CL:DEFVAR SYM-QUERY-CURSOR NULL)
(CL:DEFVAR SYM-QUERY-ROOT-TYPE NULL)
(CL:DEFVAR SYM-QUERY-FILTER-TYPE NULL)
(CL:DEFVAR SYM-QUERY-NATIVE-CLASS-EXTENSION-ITERATOR NULL)
(CL:DEFVAR SGT-QUERY-CONS NULL)
(CL:DEFVAR SGT-QUERY-DESCRIPTION-EXTENSION-ITERATOR NULL)
(CL:DEFVAR SYM-QUERY-GOAL-BINDINGS NULL)
(CL:DEFVAR SYM-QUERY-CACHED-BINDINGS NULL)
(CL:DEFVAR SYM-QUERY-REVERSE-POLARITY-CACHED-BINDINGS NULL)
(CL:DEFVAR SYM-QUERY-UP-FOR-GRABS? NULL)
(CL:DEFVAR SYM-QUERY-CLUSTER NULL)
(CL:DEFVAR SGT-QUERY-GOAL-CACHE-CLUSTER NULL)
(CL:DEFVAR SYM-QUERY-VECTOR-OF-GOAL-CACHE-TABLES NULL)
(CL:DEFVAR KWD-QUERY-GOAL-CACHES NULL)
(CL:DEFVAR SYM-QUERY-GOAL-CACHE-CLUSTER NULL)
(CL:DEFVAR KWD-QUERY-EXECUTE-QUERY NULL)
(CL:DEFVAR KWD-QUERY-QUERY NULL)
(CL:DEFVAR SYM-QUERY-AND NULL)
(CL:DEFVAR SYM-QUERY-KAPPA NULL)
(CL:DEFVAR SYM-QUERY-COMMA NULL)
(CL:DEFVAR SYM-QUERY-WHERE NULL)
(CL:DEFVAR SYM-QUERY-EXISTS NULL)
(CL:DEFVAR KWD-QUERY-KIF NULL)
(CL:DEFVAR SYM-QUERY-TRUE NULL)
(CL:DEFVAR KWD-QUERY-STELLA NULL)
(CL:DEFVAR KWD-QUERY-PREFIX-STELLA NULL)
(CL:DEFVAR SGT-QUERY-LOGIC-EXCEPTION NULL)
(CL:DEFVAR KWD-QUERY-EXCEPTIONS NULL)
(CL:DEFVAR SGT-QUERY-EXCEPTION NULL)
(CL:DEFVAR SYM-QUERY-ASK NULL)
(CL:DEFVAR KWD-QUERY-COMMON-LISP NULL)
(CL:DEFVAR SYM-QUERY-EVALUATOR-WRAPPER-CODE NULL)
(CL:DEFVAR SYM-QUERY-RETRIEVE NULL)
(CL:DEFVAR KWD-QUERY-SUB NULL)
(CL:DEFVAR KWD-QUERY-SUPER NULL)
(CL:DEFVAR SGT-QUERY-RELATION NULL)
(CL:DEFVAR SGT-QUERY-MODULE NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *MODULE*
  *EXCEPTIONHANDLERADDRESS*
  *EXCEPTION*
  *THE-PARSING-ERROR*
  *LOGICVARIABLETABLE*
  *LOGIC-DIALECT*
  *THE-FAIL-EXCEPTION*
  *THE-QUERY-THREAD-LIMIT-VIOLATION*
  *CONTEXT*
  NULL-BOOLEAN-WRAPPER
  FALSE-WRAPPER
  TRUE-WRAPPER
  BOTTOM
  *TRACED-KEYWORDS*
  STANDARD-OUTPUT
  EOL
  ONE-WRAPPER
  *RECYCLED-SUBQUERY-FRAME-S*
  *RECYCLED-QUERY-ENVIRONMENT-S*))

;;; (DEFCLASS QUERY-ITERATOR ...)

(CL:DEFCLASS QUERY-ITERATOR (ITERATOR)
  ((QUERY-ENVIRONMENT :ALLOCATION :INSTANCE :ACCESSOR QUERY-ENVIRONMENT...OF)
   (EXTERNAL-VARIABLES
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    EXTERNAL-VARIABLES...OF)
   (SOLUTIONS :ALLOCATION :INSTANCE :ACCESSOR SOLUTIONS...OF)
   (EXHAUSTED? :ALLOCATION :INSTANCE :ACCESSOR EXHAUSTED?...OF))
  (:DOCUMENTATION
   "A query iterator points to a query environment
representing the initial or intermediate state of a query.  The iterator's
'value' is a vector representing a satisfying set bindings of the query's
output variables.  Each call to the iterator writes a new set of bindings
into the vector."))

(CL:DEFUN NEW-QUERY-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE QUERY-ITERATOR)))
   (CL:SETF (CLSYS-SVAL QUERY-ITERATOR FIRST-ITERATION? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL QUERY-ITERATOR VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL QUERY-ITERATOR EXHAUSTED? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL QUERY-ITERATOR SOLUTIONS SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL QUERY-ITERATOR EXTERNAL-VARIABLES SELF) NULL)
   (CL:SETF (CLSYS-SVAL QUERY-ITERATOR QUERY-ENVIRONMENT SELF) NULL)
   (CL:RETURN-FROM NEW-QUERY-ITERATOR SELF))
  :VOID)

(CL:DEFUN ACCESS-QUERY-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-QUERY-ENVIRONMENT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ITERATOR QUERY-ENVIRONMENT SELF)
      (CAST VALUE SGT-QUERY-QUERY-ENVIRONMENT))
     (CL:RETURN-FROM
      ACCESS-QUERY-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL QUERY-ITERATOR QUERY-ENVIRONMENT SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-EXTERNAL-VARIABLES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ITERATOR EXTERNAL-VARIABLES SELF)
      (CAST VALUE SGT-QUERY-VECTOR))
     (CL:RETURN-FROM
      ACCESS-QUERY-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL QUERY-ITERATOR EXTERNAL-VARIABLES SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-SOLUTIONS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ITERATOR SOLUTIONS SELF)
      (CAST VALUE SGT-QUERY-LIST))
     (CL:RETURN-FROM
      ACCESS-QUERY-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL QUERY-ITERATOR SOLUTIONS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-EXHAUSTED?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ITERATOR EXHAUSTED? SELF)
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-BOOLEAN-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ITERATOR-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL QUERY-ITERATOR EXHAUSTED? SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-QUERY-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF QUERY-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-QUERY-QUERY-ITERATOR)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF QUERY-ITERATOR) STREAM)
  (PRINT-QUERY-ITERATOR SELF STREAM)
  :VOID)

;;; (DEFCLASS CONTROL-FRAME ...)

(CL:DEFCLASS CONTROL-FRAME (STANDARD-OBJECT)
  ((STATE :ALLOCATION :INSTANCE :ACCESSOR STATE...OF)
   (PHASE :ALLOCATION :INSTANCE :ACCESSOR PHASE...OF)
   (PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR PROPOSITION...OF)
   (REVERSE-POLARITY? :ALLOCATION :INSTANCE :ACCESSOR REVERSE-POLARITY?...OF)
   (UP :ALLOCATION :INSTANCE :ACCESSOR UP...OF)
   (DOWN :ALLOCATION :INSTANCE :ACCESSOR DOWN...OF)
   (BACK :ALLOCATION :INSTANCE :ACCESSOR BACK...OF)
   (ARGUMENT-CURSOR :ALLOCATION :INSTANCE :ACCESSOR ARGUMENT-CURSOR...OF)
   (ITERATOR :ALLOCATION :INSTANCE :ACCESSOR ITERATOR...OF)
   (PARENT-PATTERN-FRAME
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    PARENT-PATTERN-FRAME...OF)
   (GOAL-CACHE :ALLOCATION :INSTANCE :ACCESSOR GOAL-CACHE...OF)
   (PARTIAL-MATCH-FRAME
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    PARTIAL-MATCH-FRAME...OF)
   (DEBUG-FRAME-OFFSET
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    DEBUG-FRAME-OFFSET...OF)
   (DEBUG-DEPTH :ALLOCATION :INSTANCE :ACCESSOR DEBUG-DEPTH...OF)
   (CHOICE-POINT-UNBINDING-OFFSET
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CHOICE-POINT-UNBINDING-OFFSET...OF)))

(CL:DEFUN NEW-CONTROL-FRAME ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CONTROL-FRAME)))
   (CL:SETF
    (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET SELF)
    NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH SELF) 0)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-FRAME-OFFSET SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME PARTIAL-MATCH-FRAME SELF) NULL)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME GOAL-CACHE SELF) NULL)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME PARENT-PATTERN-FRAME SELF) NULL)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME ITERATOR SELF) NULL)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR SELF) 0)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME BACK SELF) NULL)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN SELF) NULL)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME UP SELF) NULL)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME PROPOSITION SELF) NULL)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME PHASE SELF) NULL)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME STATE SELF) NULL)
   (CL:RETURN-FROM NEW-CONTROL-FRAME SELF))
  :VOID)

(CL:DEFUN ACCESS-CONTROL-FRAME-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-STATE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME STATE SELF)
      (CAST VALUE SGT-QUERY-KEYWORD))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (CLSYS-SVAL CONTROL-FRAME STATE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-PHASE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME PHASE SELF)
      (CAST VALUE SGT-QUERY-KEYWORD))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (CLSYS-SVAL CONTROL-FRAME PHASE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-PROPOSITION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME PROPOSITION SELF)
      (CAST VALUE SGT-QUERY-PROPOSITION))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (CLSYS-SVAL CONTROL-FRAME PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-REVERSE-POLARITY?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? SELF)
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-BOOLEAN-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-UP)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME UP SELF)
      (CAST VALUE SGT-QUERY-CONTROL-FRAME))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (CLSYS-SVAL CONTROL-FRAME UP SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-DOWN)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME DOWN SELF)
      (CAST VALUE SGT-QUERY-CONTROL-FRAME))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (CLSYS-SVAL CONTROL-FRAME DOWN SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-BACK)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME BACK SELF)
      (CAST VALUE SGT-QUERY-CONTROL-FRAME))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (CLSYS-SVAL CONTROL-FRAME BACK SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-ARGUMENT-CURSOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-ITERATOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME ITERATOR SELF)
      (CAST VALUE SGT-QUERY-ITERATOR))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (CLSYS-SVAL CONTROL-FRAME ITERATOR SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-SUBQUERY-FRAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME ITERATOR SELF)
      (CAST VALUE SGT-QUERY-SUBQUERY-FRAME))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (CAST
       (CLSYS-SVAL CONTROL-FRAME ITERATOR SELF)
       SGT-QUERY-SUBQUERY-FRAME))))
   ((CL:EQ SLOTNAME SYM-QUERY-PARENT-PATTERN-FRAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME PARENT-PATTERN-FRAME SELF)
      (CAST VALUE SGT-QUERY-CONTROL-FRAME))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (CLSYS-SVAL CONTROL-FRAME PARENT-PATTERN-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-GOAL-CACHE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME GOAL-CACHE SELF)
      (CAST VALUE SGT-QUERY-GOAL-CACHE))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (CLSYS-SVAL CONTROL-FRAME GOAL-CACHE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-PARTIAL-MATCH-FRAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME PARTIAL-MATCH-FRAME SELF)
      (CAST VALUE SGT-QUERY-PARTIAL-MATCH-FRAME))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (CLSYS-SVAL CONTROL-FRAME PARTIAL-MATCH-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-DEBUG-FRAME-OFFSET)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME DEBUG-FRAME-OFFSET SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL CONTROL-FRAME DEBUG-FRAME-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-DEBUG-DEPTH)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-CHOICE-POINT-UNBINDING-OFFSET)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-CONTROL-FRAME-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-CONTROL-FRAME-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CONTROL-FRAME))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-QUERY-CONTROL-FRAME)
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF CONTROL-FRAME) STREAM)
  (PRINT-CONTROL-FRAME SELF STREAM)
  :VOID)

;;; (DEFCLASS GOAL-STRATEGY ...)

(CL:DEFCLASS GOAL-STRATEGY (STANDARD-OBJECT)
  ((KIND-OF-GOAL :ALLOCATION :INSTANCE :ACCESSOR KIND-OF-GOAL...OF)
   (STRATEGY-PRIORITY :ALLOCATION :INSTANCE :ACCESSOR STRATEGY-PRIORITY...OF)
   (STRATEGY-PROCEDURE :ALLOCATION :INSTANCE :ACCESSOR STRATEGY-PROCEDURE...OF))
  (:DOCUMENTATION
   "A goal-strategy contains a procedure for proving
one or more kinds of goals."))

(CL:DEFUN NEW-GOAL-STRATEGY ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE GOAL-STRATEGY)))
   (CL:SETF (CLSYS-SVAL GOAL-STRATEGY STRATEGY-PROCEDURE SELF) NULL)
   (CL:SETF (CLSYS-SVAL GOAL-STRATEGY STRATEGY-PRIORITY SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL GOAL-STRATEGY KIND-OF-GOAL SELF) NULL)
   (CL:RETURN-FROM NEW-GOAL-STRATEGY SELF))
  :VOID)

(CL:DEFUN ACCESS-GOAL-STRATEGY-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-KIND-OF-GOAL)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GOAL-STRATEGY KIND-OF-GOAL SELF)
      (CAST VALUE SGT-QUERY-KEYWORD))
     (CL:RETURN-FROM
      ACCESS-GOAL-STRATEGY-SLOT-VALUE
      (CLSYS-SVAL GOAL-STRATEGY KIND-OF-GOAL SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-STRATEGY-PRIORITY)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GOAL-STRATEGY STRATEGY-PRIORITY SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-GOAL-STRATEGY-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL GOAL-STRATEGY STRATEGY-PRIORITY SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-STRATEGY-PROCEDURE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GOAL-STRATEGY STRATEGY-PROCEDURE SELF)
      (CLSYS-SVAL
       FUNCTION-CODE-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-FUNCTION-CODE-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-GOAL-STRATEGY-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL GOAL-STRATEGY STRATEGY-PROCEDURE SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-GOAL-STRATEGY-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF GOAL-STRATEGY))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-QUERY-GOAL-STRATEGY)
  :VOID)

;;; (DEFCLASS QUERY-ENVIRONMENT ...)

(CL:DEFCLASS QUERY-ENVIRONMENT (STANDARD-OBJECT)
  ((CONTROL-FRAME-STACK
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CONTROL-FRAME-STACK...OF)
   (CONTROL-FRAME-OFFSET-LIMIT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CONTROL-FRAME-OFFSET-LIMIT...OF)
   (TOP-CONTROL-FRAME-OFFSET
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    TOP-CONTROL-FRAME-OFFSET...OF)
   (VARIABLE-FRAME-STACK
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    VARIABLE-FRAME-STACK...OF)
   (VARIABLE-FRAME-OFFSET-LIMIT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    VARIABLE-FRAME-OFFSET-LIMIT...OF)
   (TOP-VARIABLE-FRAME-OFFSET
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    TOP-VARIABLE-FRAME-OFFSET...OF)
   (UNBINDING-STACK :ALLOCATION :INSTANCE :ACCESSOR UNBINDING-STACK...OF)
   (UNBINDING-STACK-OFFSET-LIMIT
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    UNBINDING-STACK-OFFSET-LIMIT...OF)
   (TOP-UNBINDING-STACK-OFFSET
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    TOP-UNBINDING-STACK-OFFSET...OF)
   (CURRENT-VARIABLE-FRAME-OFFSET
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CURRENT-VARIABLE-FRAME-OFFSET...OF)
   (CURRENT-SUBQUERY-FRAME
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CURRENT-SUBQUERY-FRAME...OF)
   (PARTIAL-MATCH-STRATEGY
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    PARTIAL-MATCH-STRATEGY...OF)
   (LATEST-POSITIVE-SCORE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    LATEST-POSITIVE-SCORE...OF)
   (ITERATIVE-DEEPENING?
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    ITERATIVE-DEEPENING?...OF)
   (CURRENT-DEPTH-CUTOFF
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    CURRENT-DEPTH-CUTOFF...OF)
   (MAXIMUM-DEPTH :ALLOCATION :INSTANCE :ACCESSOR MAXIMUM-DEPTH...OF)
   (AUGMENTED-GOAL-CACHE?
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    AUGMENTED-GOAL-CACHE?...OF)
   (ACTIVE-GOAL-CACHES
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    ACTIVE-GOAL-CACHES...OF)
   (TRIGGERED-DEPTH-CUTOFF?
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    TRIGGERED-DEPTH-CUTOFF?...OF)
   (FAILED-TO-FIND-DUPLICATE-SUBGOAL?
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    FAILED-TO-FIND-DUPLICATE-SUBGOAL?...OF)
   (FOUND-AT-LEAST-ONE-SOLUTION?
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    FOUND-AT-LEAST-ONE-SOLUTION?...OF)
   (DEEP-INFERENCE? :ALLOCATION :INSTANCE :ACCESSOR DEEP-INFERENCE?...OF)
   (QUERY-THREAD-OFFSET
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    QUERY-THREAD-OFFSET...OF)
   (TIME-STAMP :ALLOCATION :INSTANCE :ACCESSOR TIME-STAMP...OF)
   (QUERY-ITERATOR :ALLOCATION :INSTANCE :ACCESSOR QUERY-ITERATOR...OF)
   (SUBSUMPTION-QUERY?
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SUBSUMPTION-QUERY?...OF)
   (SPECIALIZING-DESCRIPTION
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    SPECIALIZING-DESCRIPTION...OF)
   (OPTIMIZER-GOAL-RECORDS
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    OPTIMIZER-GOAL-RECORDS...OF)
   (RESIDUE-GOALS :ALLOCATION :INSTANCE :ACCESSOR RESIDUE-GOALS...OF)
   (BEST-GOAL-SEQUENCE
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    BEST-GOAL-SEQUENCE...OF)
   (BEST-COST :ALLOCATION :INSTANCE :ACCESSOR BEST-COST...OF)))

(CL:DEFUN NEW-QUERY-ENVIRONMENT ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (POP *RECYCLED-QUERY-ENVIRONMENT-S*))
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL)))
    (CL:T (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE QUERY-ENVIRONMENT)))))
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT BEST-COST SELF) NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT BEST-GOAL-SEQUENCE SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT RESIDUE-GOALS SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT OPTIMIZER-GOAL-RECORDS SELF) NULL)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT SPECIALIZING-DESCRIPTION SELF) NULL)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT SUBSUMPTION-QUERY? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT QUERY-ITERATOR SELF) NULL)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT TIME-STAMP SELF) NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT QUERY-THREAD-OFFSET SELF)
    NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT DEEP-INFERENCE? SELF) FALSE)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT FOUND-AT-LEAST-ONE-SOLUTION? SELF)
    FALSE)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT FAILED-TO-FIND-DUPLICATE-SUBGOAL? SELF)
    FALSE)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT TRIGGERED-DEPTH-CUTOFF? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT ACTIVE-GOAL-CACHES SELF) (NEW-LIST))
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT AUGMENTED-GOAL-CACHE? SELF) FALSE)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT MAXIMUM-DEPTH SELF) NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-DEPTH-CUTOFF SELF)
    NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT ITERATIVE-DEEPENING? SELF) FALSE)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT LATEST-POSITIVE-SCORE SELF)
    NULL-FLOAT)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT PARTIAL-MATCH-STRATEGY SELF) NULL)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-SUBQUERY-FRAME SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-VARIABLE-FRAME-OFFSET SELF)
    NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT TOP-UNBINDING-STACK-OFFSET SELF)
    NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT UNBINDING-STACK-OFFSET-LIMIT SELF)
    NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT UNBINDING-STACK SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT TOP-VARIABLE-FRAME-OFFSET SELF)
    NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT VARIABLE-FRAME-OFFSET-LIMIT SELF)
    NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT VARIABLE-FRAME-STACK SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT TOP-CONTROL-FRAME-OFFSET SELF)
    NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-OFFSET-LIMIT SELF)
    NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK SELF) NULL)
   (INITIALIZE-QUERY-ENVIRONMENT SELF)
   (CL:RETURN-FROM NEW-QUERY-ENVIRONMENT SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF QUERY-ENVIRONMENT))
  (PUSH *RECYCLED-QUERY-ENVIRONMENT-S* SELF)
  :VOID)

(CL:DEFUN ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-CONTROL-FRAME-STACK)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK SELF)
      (CAST VALUE SGT-QUERY-VECTOR))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-CONTROL-FRAME-OFFSET-LIMIT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-OFFSET-LIMIT SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-OFFSET-LIMIT SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-TOP-CONTROL-FRAME-OFFSET)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT TOP-CONTROL-FRAME-OFFSET SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL QUERY-ENVIRONMENT TOP-CONTROL-FRAME-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-VARIABLE-FRAME-STACK)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT VARIABLE-FRAME-STACK SELF)
      (CAST VALUE SGT-QUERY-VECTOR))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (CLSYS-SVAL QUERY-ENVIRONMENT VARIABLE-FRAME-STACK SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-VARIABLE-FRAME-OFFSET-LIMIT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT VARIABLE-FRAME-OFFSET-LIMIT SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL QUERY-ENVIRONMENT VARIABLE-FRAME-OFFSET-LIMIT SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-TOP-VARIABLE-FRAME-OFFSET)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT TOP-VARIABLE-FRAME-OFFSET SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL QUERY-ENVIRONMENT TOP-VARIABLE-FRAME-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-UNBINDING-STACK)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT UNBINDING-STACK SELF)
      (CAST VALUE SGT-QUERY-INTEGER-VECTOR))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (CLSYS-SVAL QUERY-ENVIRONMENT UNBINDING-STACK SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-UNBINDING-STACK-OFFSET-LIMIT)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT UNBINDING-STACK-OFFSET-LIMIT SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL QUERY-ENVIRONMENT UNBINDING-STACK-OFFSET-LIMIT SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-TOP-UNBINDING-STACK-OFFSET)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT TOP-UNBINDING-STACK-OFFSET SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL QUERY-ENVIRONMENT TOP-UNBINDING-STACK-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-CURRENT-VARIABLE-FRAME-OFFSET)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-VARIABLE-FRAME-OFFSET SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-VARIABLE-FRAME-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-CURRENT-SUBQUERY-FRAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-SUBQUERY-FRAME SELF)
      (CAST VALUE SGT-QUERY-SUBQUERY-FRAME))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-SUBQUERY-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-PARTIAL-MATCH-STRATEGY)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT PARTIAL-MATCH-STRATEGY SELF)
      (CAST VALUE SGT-QUERY-PARTIAL-MATCH-FRAME))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (CLSYS-SVAL QUERY-ENVIRONMENT PARTIAL-MATCH-STRATEGY SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LATEST-POSITIVE-SCORE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT LATEST-POSITIVE-SCORE SELF)
      (CLSYS-SVAL
       FLOAT-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-FLOAT-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL QUERY-ENVIRONMENT LATEST-POSITIVE-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-ITERATIVE-DEEPENING?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT ITERATIVE-DEEPENING? SELF)
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-BOOLEAN-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-BOOLEAN
       (CLSYS-SVAL QUERY-ENVIRONMENT ITERATIVE-DEEPENING? SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-CURRENT-DEPTH-CUTOFF)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-DEPTH-CUTOFF SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-DEPTH-CUTOFF SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-MAXIMUM-DEPTH)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT MAXIMUM-DEPTH SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL QUERY-ENVIRONMENT MAXIMUM-DEPTH SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-AUGMENTED-GOAL-CACHE?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT AUGMENTED-GOAL-CACHE? SELF)
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-BOOLEAN-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-BOOLEAN
       (CLSYS-SVAL QUERY-ENVIRONMENT AUGMENTED-GOAL-CACHE? SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-ACTIVE-GOAL-CACHES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT ACTIVE-GOAL-CACHES SELF)
      (CAST VALUE SGT-QUERY-LIST))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (CLSYS-SVAL QUERY-ENVIRONMENT ACTIVE-GOAL-CACHES SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-TRIGGERED-DEPTH-CUTOFF?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT TRIGGERED-DEPTH-CUTOFF? SELF)
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-BOOLEAN-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-BOOLEAN
       (CLSYS-SVAL QUERY-ENVIRONMENT TRIGGERED-DEPTH-CUTOFF? SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-FAILED-TO-FIND-DUPLICATE-SUBGOAL?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT FAILED-TO-FIND-DUPLICATE-SUBGOAL? SELF)
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-BOOLEAN-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-BOOLEAN
       (CLSYS-SVAL
        QUERY-ENVIRONMENT
        FAILED-TO-FIND-DUPLICATE-SUBGOAL?
        SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-FOUND-AT-LEAST-ONE-SOLUTION?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT FOUND-AT-LEAST-ONE-SOLUTION? SELF)
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-BOOLEAN-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-BOOLEAN
       (CLSYS-SVAL QUERY-ENVIRONMENT FOUND-AT-LEAST-ONE-SOLUTION? SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-DEEP-INFERENCE?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT DEEP-INFERENCE? SELF)
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-BOOLEAN-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL QUERY-ENVIRONMENT DEEP-INFERENCE? SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-QUERY-THREAD-OFFSET)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT QUERY-THREAD-OFFSET SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL QUERY-ENVIRONMENT QUERY-THREAD-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-TIME-STAMP)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT TIME-STAMP SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL QUERY-ENVIRONMENT TIME-STAMP SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-QUERY-ITERATOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT QUERY-ITERATOR SELF)
      (CAST VALUE SGT-QUERY-QUERY-ITERATOR))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (CLSYS-SVAL QUERY-ENVIRONMENT QUERY-ITERATOR SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-SUBSUMPTION-QUERY?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT SUBSUMPTION-QUERY? SELF)
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-BOOLEAN-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL QUERY-ENVIRONMENT SUBSUMPTION-QUERY? SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-SPECIALIZING-DESCRIPTION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT SPECIALIZING-DESCRIPTION SELF)
      (CAST VALUE SGT-QUERY-DESCRIPTION))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (CLSYS-SVAL QUERY-ENVIRONMENT SPECIALIZING-DESCRIPTION SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-OPTIMIZER-GOAL-RECORDS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT OPTIMIZER-GOAL-RECORDS SELF)
      (CAST VALUE SGT-QUERY-EXTENSIBLE-VECTOR))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (CLSYS-SVAL QUERY-ENVIRONMENT OPTIMIZER-GOAL-RECORDS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-RESIDUE-GOALS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT RESIDUE-GOALS SELF)
      (CAST VALUE SGT-QUERY-LIST))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (CLSYS-SVAL QUERY-ENVIRONMENT RESIDUE-GOALS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-BEST-GOAL-SEQUENCE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT BEST-GOAL-SEQUENCE SELF)
      (CAST VALUE SGT-QUERY-LIST))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (CLSYS-SVAL QUERY-ENVIRONMENT BEST-GOAL-SEQUENCE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-BEST-COST)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT BEST-COST SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL QUERY-ENVIRONMENT BEST-COST SELF)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF QUERY-ENVIRONMENT))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-QUERY-QUERY-ENVIRONMENT)
  :VOID)

;;; (DEFSPECIAL *QUERYENVIRONMENT* ...)

(CL:DEFVAR *QUERYENVIRONMENT* NULL
  "Points to the query environment used by the currently executing query.")

(CL:DEFUN READ-*QUERYENVIRONMENT* ()
  (CL:RETURN-FROM READ-*QUERYENVIRONMENT* *QUERYENVIRONMENT*)
  :VOID)

(CL:DEFUN WRITE-*QUERYENVIRONMENT* (VALUE)
  (CL:SETQ *QUERYENVIRONMENT* VALUE)
  (CL:RETURN-FROM WRITE-*QUERYENVIRONMENT* VALUE)
  :VOID)

;;; (DEFGLOBAL *DEFAULT-MAXIMUM-DEPTH* ...)

(CL:DEFVAR *DEFAULT-MAXIMUM-DEPTH* 25
  "Possibly a good value for the maximum backtracking depth.
More testing is needed.")

;;; (DEFGLOBAL *MAXIMUM-BACKTRACKING-DEPTH* ...)

(CL:DEFVAR *MAXIMUM-BACKTRACKING-DEPTH* NULL-INTEGER
  "Value for the maximum depth allowable during
backtrack search.")

;;; (DEFGLOBAL *INITIAL-BACKTRACKING-DEPTH* ...)

(CL:DEFVAR *INITIAL-BACKTRACKING-DEPTH* 5
  "Value of the initial depth used during an interative
deepening search.")

;;; (DEFGLOBAL *ITERATIVE-DEEPENING-MODE?* ...)

(CL:DEFVAR *ITERATIVE-DEEPENING-MODE?* FALSE
  "Default setting.  If TRUE, queries are evaluated
using iterative deepening from depth '*initial-backtracking-depth*'
to depth '*maximum-backtracking-depth*'.")

;;; (DEFGLOBAL *DEEP-INFERENCE-MODE?* ...)

(CL:DEFVAR *DEEP-INFERENCE-MODE?* FALSE
  "Default setting.  If TRUE, warrants use of assumption-based
proofs.")

;;; (DEFUN (DEEP-INFERENCE-MODE? BOOLEAN) ...)

(CL:DEFUN DEEP-INFERENCE-MODE? ()
  "Determines whether expensive inferencing is warranted."
  (CL:RETURN-FROM DEEP-INFERENCE-MODE? *DEEP-INFERENCE-MODE?*)
  :VOID)

;;; (DEFUN (SUBSUMPTION-MODE? BOOLEAN) ...)

(CL:DEFUN SUBSUMPTION-MODE? ()
  (CL:RETURN-FROM
   SUBSUMPTION-MODE?
   (CL:IF
    (CL:AND
     (CL:NOT (CL:EQ *QUERYENVIRONMENT* NULL))
     (CL:EQ
      (CLSYS-SVAL QUERY-ENVIRONMENT SUBSUMPTION-QUERY? *QUERYENVIRONMENT*)
      1))
    TRUE
    FALSE))
  :VOID)

;;; (DEFCLASS SUBQUERY-FRAME ...)

(CL:DEFCLASS SUBQUERY-FRAME (ITERATOR)
  ((CONTROL-FRAME :ALLOCATION :INSTANCE :ACCESSOR CONTROL-FRAME...OF)
   (DESCRIPTION :ALLOCATION :INSTANCE :ACCESSOR DESCRIPTION...OF)
   (EXTERNAL-ARGUMENTS
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    EXTERNAL-ARGUMENTS...OF)
   (BOOLEAN-VECTOR :ALLOCATION :INSTANCE :ACCESSOR BOOLEAN-VECTOR...OF)
   (LOCAL-VARIABLE-FRAME-OFFSET
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    LOCAL-VARIABLE-FRAME-OFFSET...OF)
   (OPTIMAL-PATTERN :ALLOCATION :INSTANCE :ACCESSOR OPTIMAL-PATTERN...OF)
   (PHASES-FILTER :ALLOCATION :INSTANCE :ACCESSOR PHASES-FILTER...OF)
   (ITERATOR :ALLOCATION :INSTANCE :ACCESSOR ITERATOR...OF))
  (:DOCUMENTATION
   "A subquery frame records state needed to search
antecedent descriptions, subclasses, and a defining description to produce
its bindings."))

(CL:DEFUN NEW-SUBQUERY-FRAME ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF *RECYCLED-SUBQUERY-FRAME-S*)
   (CL:COND
    ((CL:NOT (CL:EQ SELF NULL))
     (CL:SETQ
      *RECYCLED-SUBQUERY-FRAME-S*
      (CLSYS-SVAL SUBQUERY-FRAME ITERATOR SELF)))
    (CL:T (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SUBQUERY-FRAME)))))
   (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME FIRST-ITERATION? SELF) TRUE)
   (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME VALUE SELF) NULL)
   (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME ITERATOR SELF) NULL)
   (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME PHASES-FILTER SELF) NULL)
   (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME OPTIMAL-PATTERN SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL SUBQUERY-FRAME LOCAL-VARIABLE-FRAME-OFFSET SELF)
    NULL-INTEGER)
   (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME BOOLEAN-VECTOR SELF) NULL)
   (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME EXTERNAL-ARGUMENTS SELF) NULL)
   (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME DESCRIPTION SELF) NULL)
   (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME CONTROL-FRAME SELF) NULL)
   (CL:RETURN-FROM NEW-SUBQUERY-FRAME SELF))
  :VOID)

(CL:DEFMETHOD FREE ((SELF SUBQUERY-FRAME))
  (CL:WHEN (CL:EQ (TERMINATE-SUBQUERY-FRAME? SELF) 0) (CL:RETURN-FROM FREE))
  (CL:SETF
   (CLSYS-SVAL SUBQUERY-FRAME ITERATOR SELF)
   *RECYCLED-SUBQUERY-FRAME-S*)
  (CL:SETQ *RECYCLED-SUBQUERY-FRAME-S* SELF)
  :VOID)

(CL:DEFUN ACCESS-SUBQUERY-FRAME-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-CONTROL-FRAME)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SUBQUERY-FRAME CONTROL-FRAME SELF)
      (CAST VALUE SGT-QUERY-CONTROL-FRAME))
     (CL:RETURN-FROM
      ACCESS-SUBQUERY-FRAME-SLOT-VALUE
      (CLSYS-SVAL SUBQUERY-FRAME CONTROL-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-DESCRIPTION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SUBQUERY-FRAME DESCRIPTION SELF)
      (CAST VALUE SGT-QUERY-DESCRIPTION))
     (CL:RETURN-FROM
      ACCESS-SUBQUERY-FRAME-SLOT-VALUE
      (CLSYS-SVAL SUBQUERY-FRAME DESCRIPTION SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-EXTERNAL-ARGUMENTS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SUBQUERY-FRAME EXTERNAL-ARGUMENTS SELF)
      (CAST VALUE SGT-QUERY-VECTOR))
     (CL:RETURN-FROM
      ACCESS-SUBQUERY-FRAME-SLOT-VALUE
      (CLSYS-SVAL SUBQUERY-FRAME EXTERNAL-ARGUMENTS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-BOOLEAN-VECTOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SUBQUERY-FRAME BOOLEAN-VECTOR SELF)
      (CAST VALUE SGT-QUERY-BOOLEAN-VECTOR))
     (CL:RETURN-FROM
      ACCESS-SUBQUERY-FRAME-SLOT-VALUE
      (CLSYS-SVAL SUBQUERY-FRAME BOOLEAN-VECTOR SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-LOCAL-VARIABLE-FRAME-OFFSET)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SUBQUERY-FRAME LOCAL-VARIABLE-FRAME-OFFSET SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-SUBQUERY-FRAME-SLOT-VALUE
      (WRAP-LITERAL
       (CLSYS-SVAL SUBQUERY-FRAME LOCAL-VARIABLE-FRAME-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-OPTIMAL-PATTERN)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SUBQUERY-FRAME OPTIMAL-PATTERN SELF)
      (CAST VALUE SGT-QUERY-DESCRIPTION))
     (CL:RETURN-FROM
      ACCESS-SUBQUERY-FRAME-SLOT-VALUE
      (CLSYS-SVAL SUBQUERY-FRAME OPTIMAL-PATTERN SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-PHASES-FILTER)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SUBQUERY-FRAME PHASES-FILTER SELF)
      (CAST VALUE SGT-QUERY-KEYWORD))
     (CL:RETURN-FROM
      ACCESS-SUBQUERY-FRAME-SLOT-VALUE
      (CLSYS-SVAL SUBQUERY-FRAME PHASES-FILTER SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-ITERATOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL SUBQUERY-FRAME ITERATOR SELF)
      (CAST VALUE SGT-QUERY-ITERATOR))
     (CL:RETURN-FROM
      ACCESS-SUBQUERY-FRAME-SLOT-VALUE
      (CLSYS-SVAL SUBQUERY-FRAME ITERATOR SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-SUBQUERY-FRAME-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SUBQUERY-FRAME))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-QUERY-SUBQUERY-FRAME)
  :VOID)

;;; (DEFCLASS BOOLEAN-VECTOR-INDEX-NODE ...)

(CL:DEFCLASS BOOLEAN-VECTOR-INDEX-NODE (STANDARD-OBJECT)
  ((TRUE-LINK :ALLOCATION :INSTANCE :ACCESSOR TRUE-LINK...OF)
   (FALSE-LINK :ALLOCATION :INSTANCE :ACCESSOR FALSE-LINK...OF)
   (VECTOR :ALLOCATION :INSTANCE :ACCESSOR VECTOR...OF)))

(CL:DEFUN NEW-BOOLEAN-VECTOR-INDEX-NODE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE BOOLEAN-VECTOR-INDEX-NODE)))
   (CL:SETF (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE VECTOR SELF) NULL)
   (CL:SETF (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE FALSE-LINK SELF) NULL)
   (CL:SETF (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE TRUE-LINK SELF) NULL)
   (CL:RETURN-FROM NEW-BOOLEAN-VECTOR-INDEX-NODE SELF))
  :VOID)

(CL:DEFUN ACCESS-BOOLEAN-VECTOR-INDEX-NODE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-TRUE-LINK)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE TRUE-LINK SELF)
      (CAST VALUE SGT-QUERY-BOOLEAN-VECTOR-INDEX-NODE))
     (CL:RETURN-FROM
      ACCESS-BOOLEAN-VECTOR-INDEX-NODE-SLOT-VALUE
      (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE TRUE-LINK SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-FALSE-LINK)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE FALSE-LINK SELF)
      (CAST VALUE SGT-QUERY-BOOLEAN-VECTOR-INDEX-NODE))
     (CL:RETURN-FROM
      ACCESS-BOOLEAN-VECTOR-INDEX-NODE-SLOT-VALUE
      (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE FALSE-LINK SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-VECTOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE VECTOR SELF)
      (CAST VALUE SGT-QUERY-BOOLEAN-VECTOR))
     (CL:RETURN-FROM
      ACCESS-BOOLEAN-VECTOR-INDEX-NODE-SLOT-VALUE
      (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE VECTOR SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-BOOLEAN-VECTOR-INDEX-NODE-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF BOOLEAN-VECTOR-INDEX-NODE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-QUERY-BOOLEAN-VECTOR-INDEX-NODE)
  :VOID)

;;; (DEFGLOBAL *BOOLEAN-VECTOR-INDEX* ...)

(CL:DEFVAR *BOOLEAN-VECTOR-INDEX* NULL
  "Points to the head of a discrimination tree of containing
all boolean vectors.")

;;; (DEFUN (CREATE-BOOLEAN-VECTOR-INDEX-NODE BOOLEAN-VECTOR-INDEX-NODE) ...)

(CL:DEFUN CREATE-BOOLEAN-VECTOR-INDEX-NODE (PARENTNODE LASTVALUE)
  (CL:LET*
   ((NODE (NEW-BOOLEAN-VECTOR-INDEX-NODE))
    (VECTORLENGTH
     (CL:1+
      (LENGTH (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE VECTOR PARENTNODE))))
    (VECTOR (NEW-BOOLEAN-VECTOR VECTORLENGTH)))
   (CL:SETF (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE VECTOR NODE) VECTOR)
   (CL:LET*
    ((I NULL) (ITER-001 0) (UPPER-BOUND-001 (CL:- VECTORLENGTH 2)))
    (CL:LOOP
     WHILE
     (CL:<= ITER-001 UPPER-BOUND-001)
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETF
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR) I)
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE VECTOR PARENTNODE))
       I))))
   (CL:SETF
    (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR) (CL:1- VECTORLENGTH))
    (WRAP-BOOLEAN LASTVALUE))
   (CL:IF
    (CL:EQ LASTVALUE 1)
    (CL:SETF (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE TRUE-LINK PARENTNODE) NODE)
    (CL:SETF
     (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE FALSE-LINK PARENTNODE)
     NODE))
   (CL:RETURN-FROM CREATE-BOOLEAN-VECTOR-INDEX-NODE NODE))
  :VOID)

;;; (DEFUN (ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR BOOLEAN-VECTOR) ...)

(CL:DEFUN ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR (ARGUMENTSVECTOR)
  (CL:LET*
   ((NODE *BOOLEAN-VECTOR-INDEX*) (NEXTNODE NULL) (BOUND? FALSE))
   (CL:LET*
    ((ARG NULL)
     (VECTOR-001 ARGUMENTSVECTOR)
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       ARG
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:SETQ BOUND? TRUE)
     (CL:LET*
      ((ARG-001 ARG))
      (CL:COND
       ((CL:EQ (TAXONOMY-ISA? ARG SGT-QUERY-PATTERN-VARIABLE) 1)
        (CL:LET*
         ((ARG NULL))
         (CL:SETQ ARG ARG-001)
         (CL:SETQ BOUND? (DEFINED? (BOUND-TO ARG)))))
       (CL:T NULL)))
     (CL:IF
      (CL:EQ BOUND? 1)
      (CL:PROGN
       (CL:SETQ
        NEXTNODE
        (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE TRUE-LINK NODE))
       (CL:WHEN
        (CL:EQ NEXTNODE NULL)
        (CL:SETQ NEXTNODE (CREATE-BOOLEAN-VECTOR-INDEX-NODE NODE TRUE))))
      (CL:PROGN
       (CL:SETQ
        NEXTNODE
        (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE FALSE-LINK NODE))
       (CL:WHEN
        (CL:EQ NEXTNODE NULL)
        (CL:SETQ NEXTNODE (CREATE-BOOLEAN-VECTOR-INDEX-NODE NODE FALSE)))))
     (CL:SETQ NODE NEXTNODE)))
   (CL:RETURN-FROM
    ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR
    (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE VECTOR NODE)))
  :VOID)

;;; (DEFUN (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR BOOLEAN-VECTOR) ...)

(CL:DEFUN ZERO-ONE-LIST-TO-BOOLEAN-VECTOR (ZEROONELIST)
  (CL:LET*
   ((NODE *BOOLEAN-VECTOR-INDEX*) (NEXTNODE NULL))
   (CL:LET*
    ((BIT NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST ZEROONELIST)))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       BIT
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-QUERY-INTEGER-WRAPPER))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:EQ (EQL? BIT ONE-WRAPPER) 1)
      (CL:PROGN
       (CL:SETQ
        NEXTNODE
        (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE TRUE-LINK NODE))
       (CL:WHEN
        (CL:EQ NEXTNODE NULL)
        (CL:SETQ NEXTNODE (CREATE-BOOLEAN-VECTOR-INDEX-NODE NODE TRUE))))
      (CL:PROGN
       (CL:SETQ
        NEXTNODE
        (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE FALSE-LINK NODE))
       (CL:WHEN
        (CL:EQ NEXTNODE NULL)
        (CL:SETQ NEXTNODE (CREATE-BOOLEAN-VECTOR-INDEX-NODE NODE FALSE)))))
     (CL:SETQ NODE NEXTNODE)))
   (CL:RETURN-FROM
    ZERO-ONE-LIST-TO-BOOLEAN-VECTOR
    (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE VECTOR NODE)))
  :VOID)

;;; (DEFCONSTANT *CONTROL-FRAME-STACK-QUANTUM* ...)

(CL:DEFVAR *CONTROL-FRAME-STACK-QUANTUM* 100
  "The size of the query frame stack is a multiple of the
stack quantum.")

;;; (DEFCONSTANT *VARIABLE-FRAME-STACK-QUANTUM* ...)

(CL:DEFVAR *VARIABLE-FRAME-STACK-QUANTUM* 100
  "The size of the variable bindings stack is a multiple of the
stack quantum.")

;;; (DEFCONSTANT *UNBINDING-STACK-QUANTUM* ...)

(CL:DEFVAR *UNBINDING-STACK-QUANTUM* 100
  "The size of the old binding frame stack is a multiple of the
stack quantum.")

;;; (DEFUN INITIALIZE-QUERY-ENVIRONMENT ...)

(CL:DEFUN INITIALIZE-QUERY-ENVIRONMENT (ENVIRONMENT)
  (CL:SETF
   (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK ENVIRONMENT)
   (NEW-VECTOR *CONTROL-FRAME-STACK-QUANTUM*))
  (CL:SETF
   (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-OFFSET-LIMIT ENVIRONMENT)
   (CL:1- *CONTROL-FRAME-STACK-QUANTUM*))
  (CL:SETF
   (CLSYS-SVAL QUERY-ENVIRONMENT TOP-CONTROL-FRAME-OFFSET ENVIRONMENT)
   -1)
  (CL:SETF
   (CLSYS-SVAL QUERY-ENVIRONMENT VARIABLE-FRAME-STACK ENVIRONMENT)
   (NEW-VECTOR *VARIABLE-FRAME-STACK-QUANTUM*))
  (CL:SETF
   (CLSYS-SVAL QUERY-ENVIRONMENT VARIABLE-FRAME-OFFSET-LIMIT ENVIRONMENT)
   (CL:1- *VARIABLE-FRAME-STACK-QUANTUM*))
  (CL:SETF
   (CLSYS-SVAL QUERY-ENVIRONMENT TOP-VARIABLE-FRAME-OFFSET ENVIRONMENT)
   -1)
  (CL:SETF
   (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-VARIABLE-FRAME-OFFSET ENVIRONMENT)
   -1)
  (CL:SETF
   (CLSYS-SVAL QUERY-ENVIRONMENT UNBINDING-STACK ENVIRONMENT)
   (NEW-INTEGER-VECTOR *UNBINDING-STACK-QUANTUM*))
  (CL:SETF
   (CLSYS-SVAL QUERY-ENVIRONMENT UNBINDING-STACK-OFFSET-LIMIT ENVIRONMENT)
   (CL:1- *UNBINDING-STACK-QUANTUM*))
  (CL:SETF
   (CLSYS-SVAL QUERY-ENVIRONMENT TOP-UNBINDING-STACK-OFFSET ENVIRONMENT)
   -1)
  :VOID)

;;; (DEFUN EXPAND-CONTROL-FRAME-STACK ...)

(CL:DEFUN EXPAND-CONTROL-FRAME-STACK (QUERYENVIRONMENT)
  (CL:LET*
   ((NEWSTACKLIMIT
     (CL:+
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       CONTROL-FRAME-OFFSET-LIMIT
       QUERYENVIRONMENT)
      *CONTROL-FRAME-STACK-QUANTUM*))
    (NEWSTACK (NEW-VECTOR (CL:1+ NEWSTACKLIMIT)))
    (OLDSTACK
     (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK QUERYENVIRONMENT)))
   (CL:LET*
    ((I NULL)
     (ITER-001 0)
     (UPPER-BOUND-001
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       TOP-CONTROL-FRAME-OFFSET
       QUERYENVIRONMENT))
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
    (CL:LOOP
     WHILE
     (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETF
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY NEWSTACK) I)
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY OLDSTACK) I))))
   (FREE OLDSTACK)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK QUERYENVIRONMENT)
    NEWSTACK)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-OFFSET-LIMIT QUERYENVIRONMENT)
    NEWSTACKLIMIT))
  :VOID)

;;; (DEFUN (NEW-TOP-CONTROL-FRAME CONTROL-FRAME) ...)

(CL:DEFUN NEW-TOP-CONTROL-FRAME (QUERYENVIRONMENT)
  (CL:LET*
   ((TOPOFFSET
     (CL:1+
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       TOP-CONTROL-FRAME-OFFSET
       QUERYENVIRONMENT)))
    (FRAME
     (CL:AREF
      (CLSYS-SVAL
       VECTOR
       THE-ARRAY
       (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK QUERYENVIRONMENT))
      TOPOFFSET)))
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT TOP-CONTROL-FRAME-OFFSET QUERYENVIRONMENT)
    TOPOFFSET)
   (CL:WHEN
    (CL:NOT (CL:EQ FRAME NULL))
    (CL:RETURN-FROM NEW-TOP-CONTROL-FRAME FRAME))
   (CL:WHEN
    (CL:=
     TOPOFFSET
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      CONTROL-FRAME-OFFSET-LIMIT
      QUERYENVIRONMENT))
    (EXPAND-CONTROL-FRAME-STACK QUERYENVIRONMENT))
   (CL:SETQ FRAME (NEW-CONTROL-FRAME))
   (CL:SETF
    (CL:AREF
     (CLSYS-SVAL
      VECTOR
      THE-ARRAY
      (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK QUERYENVIRONMENT))
     TOPOFFSET)
    FRAME)
   (CL:RETURN-FROM NEW-TOP-CONTROL-FRAME FRAME))
  :VOID)

;;; (DEFUN POP-CONTROL-FRAME ...)

(CL:DEFUN POP-CONTROL-FRAME (QUERYENVIRONMENT)
  (CL:LET*
   ((FRAME
     (CL:AREF
      (CLSYS-SVAL
       VECTOR
       THE-ARRAY
       (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK QUERYENVIRONMENT))
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       TOP-CONTROL-FRAME-OFFSET
       QUERYENVIRONMENT))))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS) 1))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "POP-control-frame:  state= " %%STREAM)
     (PRINT-OBJECT (CLSYS-SVAL CONTROL-FRAME STATE FRAME) %%STREAM)
     (CL:WRITE-STRING " F" %%STREAM)
     (CL:PRINC (COMPUTE-FRAME-OFFSET FRAME) %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)))
   (CL:WHEN
    (CL:OR
     (CL:EQ (CLSYS-SVAL CONTROL-FRAME STATE FRAME) KWD-QUERY-PATTERN)
     (CL:EQ (CLSYS-SVAL CONTROL-FRAME STATE FRAME) KWD-QUERY-CONTAINED-BY))
    (DEALLOCATE-BLOCK-OF-VARIABLE-FRAMES FRAME))
   (CL:WHEN
    (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME) NULL))
    (FREE (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME))
    (CL:SETF (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME) NULL))
   (CL:SETF
    (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET FRAME)
    NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT TOP-CONTROL-FRAME-OFFSET QUERYENVIRONMENT)
    (CL:1-
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      TOP-CONTROL-FRAME-OFFSET
      QUERYENVIRONMENT)))
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME STATE FRAME) KWD-QUERY-POPPED))
  :VOID)

;;; (DEFUN POP-FRAMES-DOWN-TO ...)

(CL:DEFUN POP-FRAMES-DOWN-TO (FRAME)
  (CL:LOOP
   WHILE
   (CL:NOT
    (CL:EQ
     FRAME
     (CL:AREF
      (CLSYS-SVAL
       VECTOR
       THE-ARRAY
       (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK *QUERYENVIRONMENT*))
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       TOP-CONTROL-FRAME-OFFSET
       *QUERYENVIRONMENT*))))
   DO
   (POP-CONTROL-FRAME *QUERYENVIRONMENT*))
  (CL:WHEN
   (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME UP FRAME) NULL))
   (CL:SETF
    (CLSYS-SVAL CONTROL-FRAME DOWN (CLSYS-SVAL CONTROL-FRAME UP FRAME))
    NULL))
  (POP-CONTROL-FRAME *QUERYENVIRONMENT*)
  :VOID)

;;; (DEFUN EXPAND-VARIABLE-FRAME-STACK ...)

(CL:DEFUN EXPAND-VARIABLE-FRAME-STACK (QUERYENVIRONMENT)
  (CL:ERROR "expand-variable-frame-stack: Write me, I am a dummy!")
  (CL:SETQ QUERYENVIRONMENT QUERYENVIRONMENT)
  :VOID)

;;; (DEFUN (ALLOCATE-BLOCK-OF-VARIABLE-FRAMES INTEGER) ...)

(CL:DEFUN ALLOCATE-BLOCK-OF-VARIABLE-FRAMES (VARIABLECOUNT FRAME)
  (CL:WHEN
   (CL:AND
    (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS) 1))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "allocate-block-of-variable-frames: " %%STREAM)
    (CL:PRINC VARIABLECOUNT %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM)))
  (CL:LET*
   ((OLDTOPOFFSET
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      TOP-VARIABLE-FRAME-OFFSET
      *QUERYENVIRONMENT*))
    (VARIABLESBLOCKOFFSET (CL:1+ OLDTOPOFFSET))
    (NEWTOPOFFSET (CL:+ OLDTOPOFFSET VARIABLECOUNT)))
   (CL:LOOP
    WHILE
    (CL:>=
     NEWTOPOFFSET
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      VARIABLE-FRAME-OFFSET-LIMIT
      *QUERYENVIRONMENT*))
    DO
    (EXPAND-VARIABLE-FRAME-STACK *QUERYENVIRONMENT*))
   (CL:SETF
    (CLSYS-SVAL
     QUERY-ENVIRONMENT
     TOP-VARIABLE-FRAME-OFFSET
     *QUERYENVIRONMENT*)
    NEWTOPOFFSET)
   (CL:LET*
    ((I NULL)
     (ITER-001 (CL:1+ OLDTOPOFFSET))
     (UPPER-BOUND-001 NEWTOPOFFSET)
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
    (CL:LOOP
     WHILE
     (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETF
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL
         QUERY-ENVIRONMENT
         VARIABLE-FRAME-STACK
         *QUERYENVIRONMENT*))
       I)
      NULL)))
   (CL:SETF
    (CLSYS-SVAL
     SUBQUERY-FRAME
     LOCAL-VARIABLE-FRAME-OFFSET
     (CAST
      (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
      SGT-QUERY-SUBQUERY-FRAME))
    VARIABLESBLOCKOFFSET)
   (RESET-CURRENT-VARIABLE-FRAME-OFFSET FRAME KWD-QUERY-LOCAL)
   (CL:IF
    (CL:EQ
     (NULL? (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET FRAME))
     1)
    (CREATE-CHOICE-POINT FRAME)
    NULL)
   (CL:RETURN-FROM ALLOCATE-BLOCK-OF-VARIABLE-FRAMES VARIABLESBLOCKOFFSET))
  :VOID)

;;; (DEFUN DEALLOCATE-BLOCK-OF-VARIABLE-FRAMES ...)

(CL:DEFUN DEALLOCATE-BLOCK-OF-VARIABLE-FRAMES (FRAME)
  (CL:WHEN
   (CL:AND
    (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS) 1))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "deallocate-block-of-variable-frames: " %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM)))
  (CL:SETF
   (CLSYS-SVAL QUERY-ENVIRONMENT TOP-VARIABLE-FRAME-OFFSET *QUERYENVIRONMENT*)
   (CL:1-
    (CLSYS-SVAL
     SUBQUERY-FRAME
     LOCAL-VARIABLE-FRAME-OFFSET
     (CAST
      (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
      SGT-QUERY-SUBQUERY-FRAME))))
  (RESET-CURRENT-VARIABLE-FRAME-OFFSET FRAME KWD-QUERY-PARENT)
  :VOID)

;;; (DEFUN RESET-CURRENT-VARIABLE-FRAME-OFFSET ...)

(CL:DEFUN RESET-CURRENT-VARIABLE-FRAME-OFFSET (FRAME LOCALORPARENT)
  (CL:COND
   ((CL:EQ LOCALORPARENT KWD-QUERY-LOCAL)
    (CL:SETF
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      CURRENT-VARIABLE-FRAME-OFFSET
      *QUERYENVIRONMENT*)
     (CLSYS-SVAL
      SUBQUERY-FRAME
      LOCAL-VARIABLE-FRAME-OFFSET
      (CAST
       (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
       SGT-QUERY-SUBQUERY-FRAME))))
   ((CL:EQ LOCALORPARENT KWD-QUERY-PARENT)
    (CL:IF
     (CL:NOT
      (CL:EQ (CLSYS-SVAL CONTROL-FRAME PARENT-PATTERN-FRAME FRAME) NULL))
     (CL:SETF
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       CURRENT-VARIABLE-FRAME-OFFSET
       *QUERYENVIRONMENT*)
      (CLSYS-SVAL
       SUBQUERY-FRAME
       LOCAL-VARIABLE-FRAME-OFFSET
       (CAST
        (CLSYS-SVAL
         CONTROL-FRAME
         ITERATOR
         (CLSYS-SVAL CONTROL-FRAME PARENT-PATTERN-FRAME FRAME))
        SGT-QUERY-SUBQUERY-FRAME)))
     (CL:SETF
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       CURRENT-VARIABLE-FRAME-OFFSET
       *QUERYENVIRONMENT*)
      0)))
   (CL:T (CL:ERROR "`~A' is not a valid case option" LOCALORPARENT)))
  :VOID)

;;; (DEFUN EXPAND-UNBINDING-STACK ...)

(CL:DEFUN EXPAND-UNBINDING-STACK (QUERYENVIRONMENT)
  (CL:ERROR "expand-unbinding-stack: Write me, I am a dummy!")
  (CL:SETQ QUERYENVIRONMENT QUERYENVIRONMENT)
  :VOID)

;;; (DEFUN PRINT-ENVIRONMENT-STACKS ...)

(CL:DEFUN PRINT-ENVIRONMENT-STACKS ()
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "-------------------------" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "top-control-frame-offset " %%STREAM)
   (CL:PRINC
    (CLSYS-SVAL QUERY-ENVIRONMENT TOP-CONTROL-FRAME-OFFSET *QUERYENVIRONMENT*)
    %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "top-variable-frame-offset " %%STREAM)
   (CL:PRINC
    (CLSYS-SVAL
     QUERY-ENVIRONMENT
     TOP-VARIABLE-FRAME-OFFSET
     *QUERYENVIRONMENT*)
    %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  (CL:WRITE-STRING
   "    "
   (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
  (CL:LET*
   ((I NULL) (ITER-001 0) (UPPER-BOUND-001 10))
   (CL:LOOP
    WHILE
    (CL:<= ITER-001 UPPER-BOUND-001)
    DO
    (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
    (CL:IF
     (CL:NOT
      (CL:EQ
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL
          QUERY-ENVIRONMENT
          VARIABLE-FRAME-STACK
          *QUERYENVIRONMENT*))
        I)
       NULL))
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (PRINT-OBJECT
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL
          QUERY-ENVIRONMENT
          VARIABLE-FRAME-STACK
          *QUERYENVIRONMENT*))
        I)
       %%STREAM)
      (CL:WRITE-STRING " " %%STREAM))
     (CL:WRITE-STRING
      "_ "
      (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))))
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "current-variable-frame-offset " %%STREAM)
   (CL:PRINC
    (CLSYS-SVAL
     QUERY-ENVIRONMENT
     CURRENT-VARIABLE-FRAME-OFFSET
     *QUERYENVIRONMENT*)
    %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "top-unbinding-stack-offset " %%STREAM)
   (CL:PRINC
    (CLSYS-SVAL
     QUERY-ENVIRONMENT
     TOP-UNBINDING-STACK-OFFSET
     *QUERYENVIRONMENT*)
    %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "    " %%STREAM)
   (PRINT-OBJECT
    (CLSYS-SVAL QUERY-ENVIRONMENT UNBINDING-STACK *QUERYENVIRONMENT*)
    %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "-------------------------" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  :VOID)

;;; (DEFUN SET-PATTERN-VARIABLE-BINDING ...)

(CL:DEFUN SET-PATTERN-VARIABLE-BINDING (VARIABLE VALUE)
  (CL:WHEN
   (CL:AND
    (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS) 1))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "set-pattern-variable-binding: " %%STREAM)
    (PRINT-OBJECT VARIABLE %%STREAM)
    (CL:WRITE-STRING " " %%STREAM)
    (PRINT-OBJECT VALUE %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM)))
  (CL:LET*
   ((VFSTACKOFFSET
     (CL:+
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       CURRENT-VARIABLE-FRAME-OFFSET
       *QUERYENVIRONMENT*)
      (CLSYS-SVAL PATTERN-VARIABLE BOUND-TO-OFFSET VARIABLE)))
    (UBSTACKOFFSET
     (CL:1+
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       TOP-UNBINDING-STACK-OFFSET
       *QUERYENVIRONMENT*))))
   (CL:SETF
    (CL:AREF
     (CLSYS-SVAL
      VECTOR
      THE-ARRAY
      (CLSYS-SVAL QUERY-ENVIRONMENT VARIABLE-FRAME-STACK *QUERYENVIRONMENT*))
     VFSTACKOFFSET)
    VALUE)
   (CL:WHEN
    (CL:=
     UBSTACKOFFSET
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      UNBINDING-STACK-OFFSET-LIMIT
      *QUERYENVIRONMENT*))
    (EXPAND-UNBINDING-STACK *QUERYENVIRONMENT*))
   (CL:SETF
    (CLSYS-SVAL
     QUERY-ENVIRONMENT
     TOP-UNBINDING-STACK-OFFSET
     *QUERYENVIRONMENT*)
    UBSTACKOFFSET)
   (CL:SETF
    (CL:AREF
     (CLSYS-SVAL
      VECTOR
      THE-ARRAY
      (CLSYS-SVAL QUERY-ENVIRONMENT UNBINDING-STACK *QUERYENVIRONMENT*))
     UBSTACKOFFSET)
    (WRAP-LITERAL VFSTACKOFFSET)))
  :VOID)

;;; (DEFUN UNBIND-VARIABLES-BEGINNING-AT ...)

(CL:DEFUN UNBIND-VARIABLES-BEGINNING-AT (UBSTACKOFFSET)
  (CL:WHEN
   (CL:AND
    (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS) 1))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "unbind-variables-beginning-at: UBS= " %%STREAM)
    (CL:PRINC UBSTACKOFFSET %%STREAM)
    (CL:WRITE-STRING "#bindings= " %%STREAM)
    (CL:PRINC
     (CL:1+
      (CL:-
       (CLSYS-SVAL
        QUERY-ENVIRONMENT
        TOP-UNBINDING-STACK-OFFSET
        *QUERYENVIRONMENT*)
       UBSTACKOFFSET))
     %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM)))
  (CL:LET*
   ((VARIABLEBINDINGSTACK
     (CLSYS-SVAL QUERY-ENVIRONMENT VARIABLE-FRAME-STACK *QUERYENVIRONMENT*))
    (UNBINDINGSTACK
     (CLSYS-SVAL QUERY-ENVIRONMENT UNBINDING-STACK *QUERYENVIRONMENT*)))
   (CL:LET*
    ((I NULL)
     (ITER-001 UBSTACKOFFSET)
     (UPPER-BOUND-001
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       TOP-UNBINDING-STACK-OFFSET
       *QUERYENVIRONMENT*))
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
    (CL:LOOP
     WHILE
     (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETF
      (CL:AREF
       (CLSYS-SVAL VECTOR THE-ARRAY VARIABLEBINDINGSTACK)
       (CLSYS-SVAL
        INTEGER-WRAPPER
        WRAPPER-VALUE
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY UNBINDINGSTACK) I)))
      NULL)
     (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY UNBINDINGSTACK) I) NULL)))
   (CL:SETF
    (CLSYS-SVAL
     QUERY-ENVIRONMENT
     TOP-UNBINDING-STACK-OFFSET
     *QUERYENVIRONMENT*)
    (CL:1- UBSTACKOFFSET)))
  :VOID)

;;; (DEFUN UNBIND-PATTERN-VARIABLES ...)

(CL:DEFUN UNBIND-PATTERN-VARIABLES (FRAME)
  (CL:WHEN
   (CL:EQ
    (DEFINED? (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET FRAME))
    1)
   (UNBIND-VARIABLES-BEGINNING-AT
    (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET FRAME)))
  :VOID)

;;; (DEFUN CREATE-CHOICE-POINT ...)

(CL:DEFUN CREATE-CHOICE-POINT (FRAME)
  (CL:WHEN
   (CL:AND
    (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS) 1))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "create-choice-point: CP= " %%STREAM)
    (CL:PRINC
     (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET FRAME)
     %%STREAM)
    (CL:WRITE-STRING " NEWCP= " %%STREAM)
    (CL:PRINC
     (CL:1+
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       TOP-UNBINDING-STACK-OFFSET
       *QUERYENVIRONMENT*))
     %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM)))
  (CL:IF
   (CL:EQ
    (NULL? (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET FRAME))
    1)
   (CL:SETF
    (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET FRAME)
    (CL:1+
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      TOP-UNBINDING-STACK-OFFSET
      *QUERYENVIRONMENT*)))
   (UNBIND-VARIABLES-BEGINNING-AT
    (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET FRAME)))
  :VOID)

;;; (DEFUN (BOUND-TO OBJECT) ...)

(CL:DEFUN BOUND-TO (SELF)
  (CL:RETURN-FROM
   BOUND-TO
   (CL:AREF
    (CLSYS-SVAL
     VECTOR
     THE-ARRAY
     (CLSYS-SVAL QUERY-ENVIRONMENT VARIABLE-FRAME-STACK *QUERYENVIRONMENT*))
    (CL:+
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      CURRENT-VARIABLE-FRAME-OFFSET
      *QUERYENVIRONMENT*)
     (CLSYS-SVAL PATTERN-VARIABLE BOUND-TO-OFFSET SELF))))
  :VOID)

;;; (DEFUN (ARGUMENT-BOUND-TO OBJECT) ...)

(CL:DEFUN ARGUMENT-BOUND-TO (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-PATTERN-VARIABLE) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((VALUE (BOUND-TO SELF)))
       (CL:WHEN
        (CL:AND
         (CL:EQ VALUE NULL)
         (CL:NOT
          (CL:EQ
           (ACCESS-IN-CONTEXT
            (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE SELF)
            SELF
            FALSE)
           NULL)))
        (CL:SETQ VALUE (VALUE-OF SELF))
        (CL:WHEN
         (CL:EQ (SKOLEM? VALUE) 1)
         (CL:RETURN-FROM ARGUMENT-BOUND-TO NULL))
        (BIND-VARIABLE-TO-VALUE? SELF VALUE TRUE))
       (CL:RETURN-FROM ARGUMENT-BOUND-TO VALUE))))
    ((CL:EQ (SURROGATE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM ARGUMENT-BOUND-TO (VALUE-OF SELF))))
    (CL:T (CL:RETURN-FROM ARGUMENT-BOUND-TO SELF))))
  :VOID)

;;; (DEFUN (NATIVE-ARGUMENT-BOUND-TO OBJECT) ...)

(CL:DEFUN NATIVE-ARGUMENT-BOUND-TO (SELF)
  (CL:LET*
   ((VALUE (ARGUMENT-BOUND-TO SELF)))
   (CL:IF
    (CL:NOT (CL:EQ VALUE NULL))
    (CL:LET*
     ((VALUE-001 VALUE))
     (CL:COND
      ((CL:EQ (TAXONOMY-ISA? VALUE SGT-QUERY-LOGIC-OBJECT) 1)
       (CL:LET*
        ((VALUE NULL))
        (CL:SETQ VALUE VALUE-001)
        (CL:IF
         (CL:NOT
          (CL:EQ
           (ACCESS-IN-CONTEXT
            (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE VALUE)
            VALUE
            FALSE)
           NULL))
         (CL:RETURN-FROM
          NATIVE-ARGUMENT-BOUND-TO
          (ACCESS-IN-CONTEXT
           (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE VALUE)
           VALUE
           FALSE))
         (CL:RETURN-FROM NATIVE-ARGUMENT-BOUND-TO NULL))))
      ((CL:EQ (SURROGATE? VALUE) 1)
       (CL:LET*
        ((VALUE NULL))
        (CL:SETQ VALUE VALUE-001)
        (CL:LET*
         ((SURROGATEVALUE (CLSYS-SVAL SURROGATE SURROGATE-VALUE VALUE)))
         (CL:IF
          (CL:NOT (CL:EQ SURROGATEVALUE NULL))
          (CL:RETURN-FROM
           NATIVE-ARGUMENT-BOUND-TO
           (NATIVE-VALUE-OF SURROGATEVALUE))
          (CL:RETURN-FROM NATIVE-ARGUMENT-BOUND-TO NULL)))))
      (CL:T (CL:RETURN-FROM NATIVE-ARGUMENT-BOUND-TO VALUE))))
    (CL:RETURN-FROM NATIVE-ARGUMENT-BOUND-TO NULL)))
  :VOID)

;;; (DEFUN (OPERATOR-BOUND-TO SLOT) ...)

(CL:DEFUN OPERATOR-BOUND-TO (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (SURROGATE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       OPERATOR-BOUND-TO
       (CAST (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) SGT-QUERY-SLOT))))
    (CL:T
     (CL:RETURN-FROM
      OPERATOR-BOUND-TO
      (CAST (NATIVE-ARGUMENT-BOUND-TO SELF) SGT-QUERY-SLOT)))))
  :VOID)

;;; (DEFUN (HELP-UNIFY-ATTRIBUTES? BOOLEAN) ...)

(CL:DEFUN HELP-UNIFY-ATTRIBUTES? (VALUE1 VALUE2)
  (CL:RETURN-FROM
   HELP-UNIFY-ATTRIBUTES?
   (CL:IF
    (CL:OR
     (CL:EQ (EQL? VALUE1 VALUE2) 1)
     (CL:AND
      (CL:EQ (SKOLEM? VALUE1) 1)
      (CL:EQ
       (HELP-BIND-VARIABLE-TO-VALUE?
        (CAST VALUE1 SGT-QUERY-PATTERN-VARIABLE)
        VALUE2)
       1)))
    TRUE
    FALSE))
  :VOID)

;;; (DEFGLOBAL *TYPE-CHECK-STRATEGY* ...)

(CL:DEFVAR *TYPE-CHECK-STRATEGY* NULL
  "Determines whether there is a slow but thorough type test
when variables are bound, a fast but very shallow one, or none.  Values
are :NONE, :SORT, :DISJOINT  The default is :NONE because disjointness isn't
yet mature.")

;;; (DEFUN (FAILS-TYPE-CHECK? BOOLEAN) ...)

(CL:DEFUN FAILS-TYPE-CHECK? (V1 I2)
  (CL:COND
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-NONE)
    (CL:RETURN-FROM FAILS-TYPE-CHECK? FALSE))
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-SORT)
    (CL:LET*
     ((TYPE1 NULL) (TYPE2 NULL) (CLASS1 NULL) (CLASS2 NULL))
     (CL:LET*
      ((P NULL)
       (ITER-001
        (CLSYS-SVAL
         LIST
         THE-CONS-LIST
         (CLSYS-SVAL PATTERN-VARIABLE DEPENDENT-PROPOSITIONS V1))))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ
         P
         (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-QUERY-PROPOSITION))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (CL:WHEN
        (CL:AND
         (CL:EQ (CLSYS-SVAL PROPOSITION KIND P) KWD-QUERY-IN)
         (CL:EQ
          (ISA?
           (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS P))
           SGT-QUERY-SURROGATE)
          1)
         (CL:EQ (TRUE? P) 1))
        (CL:SETQ
         TYPE1
         (CAST (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS P)) SGT-QUERY-TYPE))
        (CL:SETQ
         CLASS1
         (CAST (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE1) SGT-QUERY-CLASS))
        (CL:RETURN))))
     (CL:WHEN
      (CL:OR (CL:EQ CLASS1 NULL) (CL:EQ (SORT? CLASS1) 0))
      (CL:RETURN-FROM FAILS-TYPE-CHECK? FALSE))
     (CL:LET*
      ((I2-001 I2))
      (CL:COND
       ((CL:EQ (TAXONOMY-ISA? I2 SGT-QUERY-LOGIC-OBJECT) 1)
        (CL:LET*
         ((I2 NULL))
         (CL:SETQ I2 I2-001)
         (CL:LET*
          ((P NULL)
           (ITER-002
            (CLSYS-SVAL
             LIST
             THE-CONS-LIST
             (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS I2))))
          (CL:LOOP
           WHILE
           (CL:NOT (CL:EQ ITER-002 NIL))
           DO
           (CL:PROGN
            (CL:SETQ
             P
             (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-QUERY-PROPOSITION))
            (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
           (CL:WHEN
            (CL:AND
             (CL:EQ (CLSYS-SVAL PROPOSITION KIND P) KWD-QUERY-IN)
             (CL:EQ
              (ISA?
               (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS P))
               SGT-QUERY-SURROGATE)
              1))
            (CL:SETQ
             TYPE2
             (CAST
              (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS P))
              SGT-QUERY-TYPE))
            (CL:SETQ
             CLASS2
             (CAST
              (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE2)
              SGT-QUERY-CLASS))
            (CL:WHEN
             (CL:AND
              (CL:EQ (SORT? CLASS2) 1)
              (CL:EQ (SUBCLASS-OF? CLASS2 CLASS1) 1))
             (CL:RETURN-FROM FAILS-TYPE-CHECK? FALSE)))))))
       (CL:T
        (CL:SETQ TYPE2 (LOGICAL-TYPE I2))
        (CL:SETQ
         CLASS2
         (CAST (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE2) SGT-QUERY-CLASS))
        (CL:WHEN
         (CL:AND
          (CL:EQ (SORT? CLASS2) 1)
          (CL:EQ (SUBCLASS-OF? CLASS2 CLASS1) 1))
         (CL:RETURN-FROM FAILS-TYPE-CHECK? FALSE)))))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ CLASS2 NULL)) (CL:EQ (SORT? CLASS2) 1))
      (CL:RETURN-FROM FAILS-TYPE-CHECK? TRUE))
     (CL:RETURN-FROM FAILS-TYPE-CHECK? FALSE)))
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-SHALLOW-DISJOINT)
    (CL:WHEN
     (CL:AND
      (CL:NOT (CL:EQ (CLSYS-SVAL PATTERN-VARIABLE ROOT-TYPE V1) NULL))
      (CL:EQ
       (DISJOINT-CLASSES?
        (CAST
         (CLSYS-SVAL
          SURROGATE
          SURROGATE-VALUE
          (CLSYS-SVAL PATTERN-VARIABLE ROOT-TYPE V1))
         SGT-QUERY-CLASS)
        (CAST
         (CLSYS-SVAL SURROGATE SURROGATE-VALUE (LOGICAL-TYPE I2))
         SGT-QUERY-CLASS))
       1))
     (CL:RETURN-FROM FAILS-TYPE-CHECK? TRUE))
    (CL:RETURN-FROM FAILS-TYPE-CHECK? FALSE))
   ((CL:EQ *TYPE-CHECK-STRATEGY* KWD-QUERY-DISJOINT)
    (CL:LET*
     ((TYPE1 NULL) (TYPE2 NULL))
     (CL:LET*
      ((P NULL)
       (ITER-003
        (CLSYS-SVAL
         LIST
         THE-CONS-LIST
         (CLSYS-SVAL PATTERN-VARIABLE DEPENDENT-PROPOSITIONS V1))))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-003 NIL))
       DO
       (CL:PROGN
        (CL:SETQ
         P
         (CAST (CLSYS-SVAL CONS VALUE ITER-003) SGT-QUERY-PROPOSITION))
        (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
       (CL:WHEN
        (CL:AND
         (CL:EQ (CLSYS-SVAL PROPOSITION KIND P) KWD-QUERY-IN)
         (CL:EQ
          (ISA?
           (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS P))
           SGT-QUERY-SURROGATE)
          1))
        (CL:SETQ
         TYPE1
         (CAST (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS P)) SGT-QUERY-TYPE))
        (CL:RETURN))))
     (CL:WHEN (CL:EQ TYPE1 NULL) (CL:RETURN-FROM FAILS-TYPE-CHECK? FALSE))
     (CL:LET*
      ((I2-002 I2))
      (CL:COND
       ((CL:EQ (TAXONOMY-ISA? I2 SGT-QUERY-LOGIC-OBJECT) 1)
        (CL:LET*
         ((I2 NULL))
         (CL:SETQ I2 I2-002)
         (CL:LET*
          ((P NULL)
           (ITER-004
            (CLSYS-SVAL
             LIST
             THE-CONS-LIST
             (CLSYS-SVAL LOGIC-OBJECT DEPENDENT-PROPOSITIONS I2))))
          (CL:LOOP
           WHILE
           (CL:NOT (CL:EQ ITER-004 NIL))
           DO
           (CL:PROGN
            (CL:SETQ
             P
             (CAST (CLSYS-SVAL CONS VALUE ITER-004) SGT-QUERY-PROPOSITION))
            (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
           (CL:WHEN
            (CL:AND
             (CL:EQ (CLSYS-SVAL PROPOSITION KIND P) KWD-QUERY-IN)
             (CL:EQ
              (ISA?
               (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS P))
               SGT-QUERY-SURROGATE)
              1))
            (CL:SETQ
             TYPE2
             (CAST
              (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS P))
              SGT-QUERY-TYPE))
            (CL:RETURN))))))
       (CL:T (CL:SETQ TYPE2 (LOGICAL-TYPE I2)))))
     (CL:WHEN (CL:EQ TYPE2 NULL) (CL:RETURN-FROM FAILS-TYPE-CHECK? FALSE))
     (CL:RETURN-FROM
      FAILS-TYPE-CHECK?
      (DISJOINT-CLASSES?
       (CAST (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE1) SGT-QUERY-CLASS)
       (CAST (CLSYS-SVAL SURROGATE SURROGATE-VALUE TYPE2) SGT-QUERY-CLASS)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" *TYPE-CHECK-STRATEGY*)))
  :VOID)

;;; (DEFUN (HELP-BIND-VARIABLE-TO-VALUE? BOOLEAN) ...)

(CL:DEFUN HELP-BIND-VARIABLE-TO-VALUE? (VARIABLE VALUE)
  (CL:WHEN
   (CL:EQ (FAILS-TYPE-CHECK? VARIABLE VALUE) 1)
   (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE? FALSE))
  (CL:LET*
   ((BOUNDTOVALUE (BOUND-TO VARIABLE))
    (VARIABLEVALUE
     (ACCESS-IN-CONTEXT
      (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE VARIABLE)
      VARIABLE
      FALSE)))
   (CL:COND
    ((CL:NOT (CL:EQ VARIABLEVALUE NULL))
     (CL:SETQ VARIABLEVALUE (VALUE-OF VARIABLEVALUE))
     (SET-PATTERN-VARIABLE-BINDING VARIABLE VARIABLEVALUE)
     (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE? (EQL? VARIABLEVALUE VALUE)))
    ((CL:EQ BOUNDTOVALUE NULL) (SET-PATTERN-VARIABLE-BINDING VARIABLE VALUE))
    ((CL:EQ (EQL? BOUNDTOVALUE VALUE) 1)
     (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE? TRUE))
    (CL:T (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE? FALSE)))
   (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE? TRUE)
   (CL:LET*
    ((PROP NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL
        PATTERN-VARIABLE
        DEPENDENT-ATTRIBUTE-PROPOSITIONS
        VARIABLE))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       PROP
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-QUERY-PROPOSITION))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:TAGBODY
      (CL:LET*
       ((SLOTDESCRIPTION
         (DYNAMIC-SLOT-VALUE
          (CAST
           (CLSYS-SVAL
            SURROGATE
            SURROGATE-VALUE
            (CAST (CLSYS-SVAL PROPOSITION OPERATOR PROP) SGT-QUERY-SLOTREF))
           SGT-QUERY-SLOT)
          SYM-QUERY-DESCRIPTION
          NULL)))
       (CL:WHEN
        (CL:AND
         (CL:NOT (CL:EQ SLOTDESCRIPTION NULL))
         (CL:EQ (NEXT? (ALL-DIRECT-SUPERCOLLECTIONS SLOTDESCRIPTION)) 1))
        (CL:GO :CONTINUE)))
      (CL:LET*
       ((SLOTVARIABLE (LAST-ARGUMENT PROP))
        (SLOTVALUE (QUERY-FOR-ASSERTED-FUNCTION-PROPOSITION-VALUE PROP)))
       (CL:WHEN
        (CL:NOT
         (CL:AND
          (CL:NOT (CL:EQ SLOTVALUE NULL))
          (CL:EQ (HELP-UNIFY-ATTRIBUTES? SLOTVARIABLE SLOTVALUE) 1)))
        (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE? FALSE)))
      :CONTINUE)))
   (CL:RETURN-FROM HELP-BIND-VARIABLE-TO-VALUE? TRUE))
  :VOID)

;;; (DEFUN (BIND-VARIABLE-TO-VALUE? BOOLEAN) ...)

(CL:DEFUN BIND-VARIABLE-TO-VALUE? (VARIABLE VALUE AUTOCLEANUP?)
  (CL:IF
   (CL:EQ AUTOCLEANUP? 1)
   (CL:LET*
    ((UBSTACKOFFSET
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       TOP-UNBINDING-STACK-OFFSET
       *QUERYENVIRONMENT*))
     (SUCCESS? FALSE))
    (CL:SETQ SUCCESS? (HELP-BIND-VARIABLE-TO-VALUE? VARIABLE VALUE))
    (CL:WHEN
     (CL:EQ SUCCESS? 0)
     (UNBIND-VARIABLES-BEGINNING-AT (CL:1+ UBSTACKOFFSET)))
    (CL:RETURN-FROM BIND-VARIABLE-TO-VALUE? SUCCESS?))
   (CL:RETURN-FROM
    BIND-VARIABLE-TO-VALUE?
    (HELP-BIND-VARIABLE-TO-VALUE? VARIABLE VALUE)))
  :VOID)

;;; (DEFUN (BIND-ARGUMENT-TO-VALUE? BOOLEAN) ...)

(CL:DEFUN BIND-ARGUMENT-TO-VALUE? (ARGUMENT VALUE AUTOCLEANUP?)
  (CL:LET*
   ((ARGUMENT-001 ARGUMENT))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? ARGUMENT SGT-QUERY-PATTERN-VARIABLE) 1)
     (CL:LET*
      ((ARGUMENT NULL))
      (CL:SETQ ARGUMENT ARGUMENT-001)
      (CL:IF
       (CL:EQ AUTOCLEANUP? 1)
       (CL:LET*
        ((UBSTACKOFFSET
          (CLSYS-SVAL
           QUERY-ENVIRONMENT
           TOP-UNBINDING-STACK-OFFSET
           *QUERYENVIRONMENT*))
         (SUCCESS? FALSE))
        (CL:SETQ SUCCESS? (HELP-BIND-VARIABLE-TO-VALUE? ARGUMENT VALUE))
        (CL:WHEN
         (CL:EQ SUCCESS? 0)
         (UNBIND-VARIABLES-BEGINNING-AT (CL:1+ UBSTACKOFFSET)))
        (CL:RETURN-FROM BIND-ARGUMENT-TO-VALUE? SUCCESS?))
       (CL:RETURN-FROM
        BIND-ARGUMENT-TO-VALUE?
        (HELP-BIND-VARIABLE-TO-VALUE? ARGUMENT VALUE)))))
    ((CL:EQ (SURROGATE? ARGUMENT) 1)
     (CL:LET*
      ((ARGUMENT NULL))
      (CL:SETQ ARGUMENT ARGUMENT-001)
      (CL:RETURN-FROM
       BIND-ARGUMENT-TO-VALUE?
       (EQL? (VALUE-OF ARGUMENT) VALUE))))
    (CL:T (CL:RETURN-FROM BIND-ARGUMENT-TO-VALUE? (EQL? ARGUMENT VALUE)))))
  :VOID)

;;; (DEFUN (BIND-VECTOR-OF-ARGUMENTS-TO-VALUES? BOOLEAN) ...)

(CL:DEFUN BIND-VECTOR-OF-ARGUMENTS-TO-VALUES? (ARGUMENTS VALUES)
  (CL:LET*
   ((UBSTACKOFFSET
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      TOP-UNBINDING-STACK-OFFSET
      *QUERYENVIRONMENT*))
    (SUCCESS? FALSE))
   (CL:LET*
    ((ALWAYS?-001 TRUE))
    (CL:LET*
     ((V NULL)
      (ARG NULL)
      (VECTOR-001 ARGUMENTS)
      (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001))
      (ITER-001 VALUES))
     (CL:LOOP
      WHILE
      (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:NOT (CL:EQ ITER-001 NIL)))
      DO
      (CL:PROGN
       (CL:SETQ
        ARG
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (CL:PROGN
       (CL:SETQ V (CLSYS-SVAL CONS VALUE ITER-001))
       (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
      (CL:WHEN
       (CL:EQ (BIND-ARGUMENT-TO-VALUE? ARG V FALSE) 0)
       (CL:SETQ ALWAYS?-001 FALSE)
       (CL:RETURN))))
    (CL:SETQ SUCCESS? ALWAYS?-001))
   (CL:WHEN
    (CL:EQ SUCCESS? 0)
    (UNBIND-VARIABLES-BEGINNING-AT (CL:1+ UBSTACKOFFSET)))
   (CL:RETURN-FROM BIND-VECTOR-OF-ARGUMENTS-TO-VALUES? SUCCESS?))
  :VOID)

;;; (DEFUN PCS ...)

(CL:DEFUN PCS ()
  (CL:LET*
   ((I NULL)
    (ITER-001 0)
    (UPPER-BOUND-001
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      TOP-CONTROL-FRAME-OFFSET
      *QUERYENVIRONMENT*))
    (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
   (CL:LOOP
    WHILE
    (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
    DO
    (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (PRINT-OBJECT
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK *QUERYENVIRONMENT*))
       I)
      %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))))
  :VOID)

;;; (DEFUN (VARIABLE-FROM-UNBINDING-OFFSET PATTERN-VARIABLE) ...)

(CL:DEFUN VARIABLE-FROM-UNBINDING-OFFSET (DESCRIPTION UBOFFSET)
  (CL:LET*
   ((OFFSET
     (CL:-
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL QUERY-ENVIRONMENT UNBINDING-STACK *QUERYENVIRONMENT*))
        UBOFFSET))
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       CURRENT-VARIABLE-FRAME-OFFSET
       *QUERYENVIRONMENT*))))
   (CL:LET*
    ((VBL NULL)
     (VECTOR-001 (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       VBL
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
        SGT-QUERY-PATTERN-VARIABLE))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:WHEN
      (CL:= (CLSYS-SVAL PATTERN-VARIABLE BOUND-TO-OFFSET VBL) OFFSET)
      (CL:RETURN-FROM VARIABLE-FROM-UNBINDING-OFFSET VBL))))
   (CL:LET*
    ((VBL NULL)
     (VECTOR-002 (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES DESCRIPTION))
     (INDEX-002 0)
     (LENGTH-002 (LENGTH VECTOR-002)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-002 LENGTH-002)
     DO
     (CL:PROGN
      (CL:SETQ
       VBL
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002)
        SGT-QUERY-PATTERN-VARIABLE))
      (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
     (CL:WHEN
      (CL:= (CLSYS-SVAL PATTERN-VARIABLE BOUND-TO-OFFSET VBL) OFFSET)
      (CL:RETURN-FROM VARIABLE-FROM-UNBINDING-OFFSET VBL))))
   (CL:RETURN-FROM VARIABLE-FROM-UNBINDING-OFFSET NULL))
  :VOID)

;;; (DEFUN (COMPUTE-FRAME-OFFSET INTEGER) ...)

(CL:DEFUN COMPUTE-FRAME-OFFSET (FRAME)
  (CL:WHEN
   (CL:EQ (DEFINED? (CLSYS-SVAL CONTROL-FRAME DEBUG-FRAME-OFFSET FRAME)) 1)
   (CL:RETURN-FROM
    COMPUTE-FRAME-OFFSET
    (CLSYS-SVAL CONTROL-FRAME DEBUG-FRAME-OFFSET FRAME)))
  (CL:WHEN
   (CL:EQ *QUERYENVIRONMENT* NULL)
   (CL:RETURN-FROM COMPUTE-FRAME-OFFSET -9))
  (CL:LET*
   ((I NULL) (ITER-001 0) (UPPER-BOUND-001 99))
   (CL:LOOP
    WHILE
    (CL:<= ITER-001 UPPER-BOUND-001)
    DO
    (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
    (CL:WHEN
     (CL:EQ
      FRAME
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK *QUERYENVIRONMENT*))
       I))
     (CL:RETURN-FROM COMPUTE-FRAME-OFFSET I))))
  :VOID)

;;; (DEFUN PRINT-ONE-VARIABLE-BINDING ...)

(CL:DEFUN PRINT-ONE-VARIABLE-BINDING (VARIABLE)
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (PRINT-OBJECT
    (DYNAMIC-SLOT-VALUE VARIABLE SYM-QUERY-SKOLEM-NAME NULL)
    %%STREAM)
   (CL:WRITE-STRING "=" %%STREAM))
  (CL:IF
   (CL:EQ (DEFINED? (CLSYS-SVAL PATTERN-VARIABLE BOUND-TO-OFFSET VARIABLE)) 1)
   (PRINT-UNFORMATTED-LOGICAL-FORM (BOUND-TO VARIABLE) STANDARD-OUTPUT)
   (CL:PRINC NULL (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
  (CL:WRITE-STRING " " (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
  :VOID)

;;; (DEFUN PRINT-VARIABLE-BINDINGS ...)

(CL:DEFUN PRINT-VARIABLE-BINDINGS (FRAME)
  (CL:WHEN
   (CL:AND
    (CL:NOT
     (CL:EQ (CLSYS-SVAL CONTROL-FRAME PARENT-PATTERN-FRAME FRAME) NULL))
    (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME STATE FRAME) KWD-QUERY-PATTERN)))
   (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME PARENT-PATTERN-FRAME FRAME)))
  (CL:LET*
   ((SUQUERYFRAME
     (CAST
      (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
      SGT-QUERY-SUBQUERY-FRAME))
    (DESCRIPTION NULL))
   (CL:WHEN
    (CL:NOT (CL:EQ SUQUERYFRAME NULL))
    (CL:LET*
     ((SUQUERYFRAME-001 SUQUERYFRAME))
     (CL:COND
      ((CL:EQ (TAXONOMY-ISA? SUQUERYFRAME SGT-QUERY-SUBQUERY-FRAME) 1)
       (CL:LET*
        ((SUQUERYFRAME NULL))
        (CL:SETQ SUQUERYFRAME SUQUERYFRAME-001)
        (CL:WHEN
         (CL:EQ (CLSYS-SVAL CONTROL-FRAME STATE FRAME) KWD-QUERY-CONTAINED-BY)
         (CL:LET*
          ((INPROPOSITION
            (CAST
             (CL:AREF
              (CLSYS-SVAL
               VECTOR
               THE-ARRAY
               (CLSYS-SVAL
                PROPOSITION
                ARGUMENTS
                (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME)))
              0)
             SGT-QUERY-PROPOSITION))
           (MEMBER
            (CL:AREF
             (CLSYS-SVAL
              VECTOR
              THE-ARRAY
              (CLSYS-SVAL PROPOSITION ARGUMENTS INPROPOSITION))
             0)))
          (CL:LET*
           ((MEMBER-001 MEMBER))
           (CL:COND
            ((CL:EQ (TAXONOMY-ISA? MEMBER SGT-QUERY-PATTERN-VARIABLE) 1)
             (CL:LET*
              ((MEMBER NULL))
              (CL:SETQ MEMBER MEMBER-001)
              (PRINT-ONE-VARIABLE-BINDING MEMBER)))
            ((CL:EQ (TAXONOMY-ISA? MEMBER SGT-QUERY-LIST) 1)
             (CL:LET*
              ((MEMBER NULL))
              (CL:SETQ MEMBER MEMBER-001)
              (CL:LET*
               ((M NULL) (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST MEMBER)))
               (CL:LOOP
                WHILE
                (CL:NOT (CL:EQ ITER-001 NIL))
                DO
                (CL:PROGN
                 (CL:SETQ M (CLSYS-SVAL CONS VALUE ITER-001))
                 (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
                (PRINT-ONE-VARIABLE-BINDING
                 (CAST M SGT-QUERY-PATTERN-VARIABLE))))))
            (CL:T (CL:ERROR "`~A' is not a valid case option" MEMBER)))))
         (CL:RETURN-FROM PRINT-VARIABLE-BINDINGS))
        (CL:SETQ
         DESCRIPTION
         (CLSYS-SVAL SUBQUERY-FRAME OPTIMAL-PATTERN SUQUERYFRAME))
        (CL:WHEN
         (CL:NOT (CL:EQ DESCRIPTION NULL))
         (CL:LET*
          ((VBL NULL)
           (VECTOR-001 (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION))
           (INDEX-001 0)
           (LENGTH-001 (LENGTH VECTOR-001)))
          (CL:LOOP
           WHILE
           (CL:< INDEX-001 LENGTH-001)
           DO
           (CL:PROGN
            (CL:SETQ
             VBL
             (CAST
              (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
              SGT-QUERY-PATTERN-VARIABLE))
            (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
           (CL:WHEN
            (CL:NOT (CL:EQ (BOUND-TO VBL) NULL))
            (PRINT-ONE-VARIABLE-BINDING VBL))))
         (CL:LET*
          ((VBL NULL)
           (VECTOR-002
            (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES DESCRIPTION))
           (INDEX-002 0)
           (LENGTH-002 (LENGTH VECTOR-002)))
          (CL:LOOP
           WHILE
           (CL:< INDEX-002 LENGTH-002)
           DO
           (CL:PROGN
            (CL:SETQ
             VBL
             (CAST
              (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002)
              SGT-QUERY-PATTERN-VARIABLE))
            (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
           (CL:WHEN
            (CL:NOT (CL:EQ (BOUND-TO VBL) NULL))
            (PRINT-ONE-VARIABLE-BINDING VBL)))))
        (CL:RETURN-FROM PRINT-VARIABLE-BINDINGS)))
      (CL:T NULL)))))
  :VOID)

;;; (DEFUN TRACE-GOAL-TREE ...)

(CL:DEFUN TRACE-GOAL-TREE (FRAME DEPTH LASTMOVE)
  (CL:WHEN
   (CL:AND
    (CL:EQ
     (MEMBER?
      (GET-QUOTED-TREE
       "((:IN :FUNCTION :PREDICATE :EQUIVALENT :IMPLIES :CONSTANT) \"/LOGIC\")"
       "/LOGIC")
      (CLSYS-SVAL CONTROL-FRAME STATE FRAME))
     1)
    (CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:EQ
     (DEFINED? (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET FRAME))
     1))
   (UNBIND-VARIABLES-BEGINNING-AT
    (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET FRAME)))
  (CL:WHEN
   (CL:AND
    (CL:EQ
     (MEMBER?
      (GET-QUOTED-TREE "((:AND :OR) \"/LOGIC\")" "/LOGIC")
      (CLSYS-SVAL CONTROL-FRAME STATE FRAME))
     1)
    (CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
    (CL:EQ
     (MEMBER?
      (GET-QUOTED-TREE
       "((:IN :FUNCTION :PREDICATE :EQUIVALENT :IMPLIES :CONSTANT) \"/LOGIC\")"
       "/LOGIC")
      (CLSYS-SVAL CONTROL-FRAME STATE (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
     1)
    (CL:EQ
     (DEFINED?
      (CLSYS-SVAL
       CONTROL-FRAME
       CHOICE-POINT-UNBINDING-OFFSET
       (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
     1))
   (UNBIND-VARIABLES-BEGINNING-AT
    (CLSYS-SVAL
     CONTROL-FRAME
     CHOICE-POINT-UNBINDING-OFFSET
     (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))))
  (CL:WHEN
   (CL:AND
    (CL:EQ (CLSYS-SVAL CONTROL-FRAME STATE FRAME) KWD-QUERY-ITERATIVE-FORALL)
    (CL:EQ LASTMOVE KWD-QUERY-DOWN))
   (CL:RETURN-FROM TRACE-GOAL-TREE))
  (CL:LET*
   ((INVERT? (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? FRAME)))
   (CL:WHEN
    (CL:EQ (TRACE-KEYWORD? KWD-QUERY-STATE-MACHINE) 1)
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "F" %%STREAM)
     (CL:PRINC (COMPUTE-FRAME-OFFSET FRAME) %%STREAM))
    (CL:IF
     (CL:EQ
      (DEFINED?
       (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET FRAME))
      1)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING "," %%STREAM)
      (CL:PRINC
       (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET FRAME)
       %%STREAM)
      (CL:WRITE-STRING " " %%STREAM))
     (CL:WRITE-STRING
      "   "
      (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))))
   (CL:LET*
    ((I NULL)
     (ITER-001 1)
     (UPPER-BOUND-001 DEPTH)
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
    (CL:LOOP
     WHILE
     (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:WRITE-STRING
      "| "
      (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
     (CL:LET*
      ((TEST-VALUE-001 (CLSYS-SVAL CONTROL-FRAME STATE FRAME)))
      (CL:COND
       ((CL:EQ TEST-VALUE-001 KWD-QUERY-SUBGOALS)
        (CL:WHEN
         (CL:EQ (CLSYS-SVAL CONTROL-FRAME PHASE FRAME) KWD-QUERY-TERMINATION)
         (CL:WRITE-STRING
          "FAIL"
          (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
         (CL:RETURN-FROM TRACE-GOAL-TREE))
        (CL:LET*
         ((DESCRIPTION
           (CLSYS-SVAL
            SUBQUERY-FRAME
            DESCRIPTION
            (CAST
             (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
             SGT-QUERY-SUBQUERY-FRAME))))
         (CL:COND
          ((CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
           (CL:WRITE-STRING
            "SUBGOALING: "
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
          ((CL:AND
            (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
            (CL:EQ
             (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
             KWD-QUERY-ANTECEDENTS))
           (CL:WRITE-STRING
            "RULE: "
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
           (CL:LET*
            ((*PRINTMODE* KWD-QUERY-REALISTIC)
             (*PRINTLOGICALFORMSTREAM* STANDARD-OUTPUT)
             (*INDENTCOUNTER* (CL:+ (CL:* 2 DEPTH) 7)))
            (CL:DECLARE
             (CL:SPECIAL
              *PRINTMODE*
              *PRINTLOGICALFORMSTREAM*
              *INDENTCOUNTER*))
            (PRINT-DESCRIPTIONS-AS-KIF-RULE
             DESCRIPTION
             (CL:IF
              (CL:NOT
               (CL:EQ
                (CLSYS-SVAL
                 SUBQUERY-FRAME
                 OPTIMAL-PATTERN
                 (CAST
                  (CLSYS-SVAL
                   CONTROL-FRAME
                   ITERATOR
                   (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                  SGT-QUERY-SUBQUERY-FRAME))
                NULL))
              (CLSYS-SVAL
               SUBQUERY-FRAME
               OPTIMAL-PATTERN
               (CAST
                (CLSYS-SVAL
                 CONTROL-FRAME
                 ITERATOR
                 (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                SGT-QUERY-SUBQUERY-FRAME))
              (CLSYS-SVAL
               SUBQUERY-FRAME
               DESCRIPTION
               (CAST
                (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
                SGT-QUERY-SUBQUERY-FRAME))))))
          ((CL:AND
            (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME UP FRAME) NULL))
            (CL:EQ
             (CLSYS-SVAL
              CONTROL-FRAME
              PHASE
              (CLSYS-SVAL CONTROL-FRAME UP FRAME))
             KWD-QUERY-COMPLEMENT))
           (CL:WRITE-STRING
            "COMPLEMENT GOAL: "
            (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
           (PRINT-UNFORMATTED-LOGICAL-FORM
            (CLSYS-SVAL DESCRIPTION PROPOSITION DESCRIPTION)
            STANDARD-OUTPUT))
          (CL:T
           (CL:WHEN
            (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME UP FRAME) NULL))
            (CL:WRITE-STRING
             "UNIMPLEMENTED TRACE STATE"
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))))))
       ((CL:EQ TEST-VALUE-001 KWD-QUERY-PATTERN)
        (CL:WRITE-STRING
         "PATTERN: ["
         (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
        (CL:LET*
         ((FIRSTTIME? TRUE))
         (CL:LET*
          ((TV NULL)
           (VECTOR-001
            (CLSYS-SVAL
             SUBQUERY-FRAME
             BOOLEAN-VECTOR
             (CAST
              (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
              SGT-QUERY-SUBQUERY-FRAME)))
           (INDEX-001 0)
           (LENGTH-001 (LENGTH VECTOR-001)))
          (CL:LOOP
           WHILE
           (CL:< INDEX-001 LENGTH-001)
           DO
           (CL:PROGN
            (CL:SETQ
             TV
             (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
            (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
           (CL:IF
            (CL:EQ FIRSTTIME? 1)
            (CL:SETQ FIRSTTIME? FALSE)
            (CL:WRITE-STRING
             ","
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
           (CL:IF
            (CL:EQ (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE TV) 1)
            (CL:WRITE-STRING
             "T"
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
            (CL:WRITE-STRING
             "F"
             (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))))))
        (CL:WRITE-STRING
         "]"
         (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:T
        (CL:WRITE-STRING
         "GOAL: "
         (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
        (CL:WHEN
         (CL:EQ INVERT? 1)
         (CL:WRITE-STRING
          "~"
          (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (PRINT-UNFORMATTED-LOGICAL-FORM
         (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME)
         STANDARD-OUTPUT)))))
    ((CL:OR
      (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
      (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
     (CL:COND
      ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
       (CL:WRITE-STRING
        "| SUCC: "
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
       (CL:LET*
        ((*PRINTINFRAME* FRAME))
        (CL:DECLARE (CL:SPECIAL *PRINTINFRAME*))
        (PRINT-VARIABLE-BINDINGS FRAME)))
      ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
       (CL:WRITE-STRING
        "| FAIL "
        (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE))))
    (CL:T
     (CL:WRITE-STRING
      "????: "
      (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))))
   (CL:WHEN
    (CL:EQ (TRACE-KEYWORD? KWD-QUERY-STATE-MACHINE) 1)
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING " state= " %%STREAM)
     (PRINT-OBJECT (CLSYS-SVAL CONTROL-FRAME STATE FRAME) %%STREAM)
     (CL:WRITE-STRING "  lastMove= " %%STREAM)
     (PRINT-OBJECT LASTMOVE %%STREAM)
     (CL:WRITE-STRING " depth= " %%STREAM)
     (CL:PRINC DEPTH %%STREAM)
     (CL:WRITE-STRING " revPty?= " %%STREAM)
     (CL:PRINC (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? FRAME) %%STREAM)))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM)))
  :VOID)

;;; (DEFUN (INTERPRET-AND-SCORES KEYWORD) ...)

(CL:DEFUN INTERPRET-AND-SCORES (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL CONTROL-FRAME PARTIAL-MATCH-FRAME FRAME) NULL)
     (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME KWD-QUERY-AND)))
   ((CL:OR
     (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
    (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)
    (CL:COND
     ((CL:EQ (COMPUTE-PARTIAL-MATCH-AND-FAILURE? FRAME) 1)
      (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
     ((CL:AND
       (CL:EQ
        (CL:1+ (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME))
        (LENGTH
         (CLSYS-SVAL
          PROPOSITION
          ARGUMENTS
          (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))))
       (CL:EQ (COMPUTE-PARTIAL-MATCH-SCORE? FRAME) 0))
      (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
     (CL:T (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE)))
  (CL:RETURN-FROM INTERPRET-AND-SCORES LASTMOVE)
  :VOID)

;;; (DEFUN (INTERPRET-OR-SCORES KEYWORD) ...)

(CL:DEFUN INTERPRET-OR-SCORES (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL CONTROL-FRAME PARTIAL-MATCH-FRAME FRAME) NULL)
     (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME KWD-QUERY-OR)))
   ((CL:OR
     (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
    (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)
    (CL:COND
     ((CL:EQ (COMPUTE-PARTIAL-MATCH-OR-SUCCESS? FRAME) 1)
      (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))
     ((CL:AND
       (CL:EQ
        (CL:1+ (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME))
        (LENGTH
         (CLSYS-SVAL
          PROPOSITION
          ARGUMENTS
          (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))))
       (CL:EQ (COMPUTE-PARTIAL-MATCH-SCORE? FRAME) 1))
      (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))
     (CL:T (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE)))
  (CL:RETURN-FROM INTERPRET-OR-SCORES LASTMOVE)
  :VOID)

;;; (DEFUN (INTERPRET-FAIL-SCORE KEYWORD) ...)

(CL:DEFUN INTERPRET-FAIL-SCORE (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL CONTROL-FRAME PARTIAL-MATCH-FRAME FRAME) NULL)
     (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME KWD-QUERY-NOT)))
   ((CL:OR
     (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
    (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)
    (CL:IF
     (CL:EQ (COMPUTE-PARTIAL-MATCH-SCORE? FRAME) 1)
     (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
   (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE)))
  (CL:RETURN-FROM INTERPRET-FAIL-SCORE LASTMOVE)
  :VOID)

;;; (DEFUN (INTERPRET-SUBGOALS-SCORES KEYWORD) ...)

(CL:DEFUN INTERPRET-SUBGOALS-SCORES (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL CONTROL-FRAME PARTIAL-MATCH-FRAME FRAME) NULL)
     (CREATE-AND-LINK-PARTIAL-MATCH-FRAME FRAME KWD-QUERY-OR)
     (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)))
   ((CL:OR
     (CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
     (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL))
    (CL:LET*
     ((QUERYENVIRONMENT *QUERYENVIRONMENT*)
      (PARTIALMATCHFRAME (CLSYS-SVAL CONTROL-FRAME PARTIAL-MATCH-FRAME FRAME))
      (MAXSCORE (COMPUTE-OR-SCORE PARTIALMATCHFRAME))
      (LATESTSCORE
       (CLSYS-SVAL QUERY-ENVIRONMENT LATEST-POSITIVE-SCORE QUERYENVIRONMENT)))
     (CL:WHEN
      (CL:EQ (CLSYS-SVAL CONTROL-FRAME PHASE FRAME) KWD-QUERY-ANTECEDENTS)
      (CL:LET*
       ((IMPLIESPROP
         (CLSYS-SVAL
          ITERATOR
          VALUE
          (CLSYS-SVAL
           SUBQUERY-FRAME
           ITERATOR
           (CAST
            (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
            SGT-QUERY-SUBQUERY-FRAME)))))
       (CL:SETQ
        LATESTSCORE
        (COMPUTE-RULE-SCORE
         (CLSYS-SVAL CONTROL-FRAME PARTIAL-MATCH-FRAME FRAME)
         LATESTSCORE
         (ACCESS-IN-CONTEXT
          (CLSYS-SVAL PROPOSITION TRUTH-VALUE IMPLIESPROP)
          IMPLIESPROP
          FALSE)))
       (CL:SETF
        (CLSYS-SVAL QUERY-ENVIRONMENT LATEST-POSITIVE-SCORE QUERYENVIRONMENT)
        LATESTSCORE)))
     (RECORD-LATEST-PARTIAL-MATCH-SCORE FRAME)
     (CL:IF
      (CL:EQ (COMPUTE-PARTIAL-MATCH-SCORE? FRAME) 1)
      (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)
      (CL:PROGN (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE)))
  (CL:RETURN-FROM INTERPRET-SUBGOALS-SCORES LASTMOVE)
  :VOID)

;;; (DEFUN (CREATE-DOWN-FRAME CONTROL-FRAME) ...)

(CL:DEFUN CREATE-DOWN-FRAME (UPFRAME DOWNPROPOSITION)
  (CL:LET*
   ((DOWNFRAME (NEW-TOP-CONTROL-FRAME *QUERYENVIRONMENT*)))
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN UPFRAME) DOWNFRAME)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME UP DOWNFRAME) UPFRAME)
   (CL:SETF
    (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? DOWNFRAME)
    (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? UPFRAME))
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME PROPOSITION DOWNFRAME) DOWNPROPOSITION)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME PHASE DOWNFRAME) KWD-QUERY-INITIAL)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN DOWNFRAME) NULL)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME BACK DOWNFRAME) NULL)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME GOAL-CACHE DOWNFRAME) NULL)
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH DOWNFRAME) 0)
   (CL:WHEN
    (CL:NOT (CL:EQ DOWNPROPOSITION NULL))
    (CL:SETF
     (CLSYS-SVAL CONTROL-FRAME STATE DOWNFRAME)
     (CLSYS-SVAL PROPOSITION KIND DOWNPROPOSITION))
    (CL:WHEN
     (CL:EQ (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? DOWNFRAME) 1)
     (CL:LET*
      ((TEST-VALUE-001 (CLSYS-SVAL CONTROL-FRAME STATE DOWNFRAME)))
      (CL:COND
       ((CL:EQ TEST-VALUE-001 KWD-QUERY-AND)
        (CL:SETF (CLSYS-SVAL CONTROL-FRAME STATE DOWNFRAME) KWD-QUERY-OR))
       ((CL:EQ TEST-VALUE-001 KWD-QUERY-OR)
        (CL:SETF (CLSYS-SVAL CONTROL-FRAME STATE DOWNFRAME) KWD-QUERY-AND))
       (CL:T NULL))))
    (CL:SETF (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR DOWNFRAME) 0))
   (CL:IF
    (CL:EQ (CLSYS-SVAL CONTROL-FRAME STATE UPFRAME) KWD-QUERY-PATTERN)
    (CL:SETF
     (CLSYS-SVAL CONTROL-FRAME PARENT-PATTERN-FRAME DOWNFRAME)
     UPFRAME)
    (CL:SETF
     (CLSYS-SVAL CONTROL-FRAME PARENT-PATTERN-FRAME DOWNFRAME)
     (CLSYS-SVAL CONTROL-FRAME PARENT-PATTERN-FRAME UPFRAME)))
   (CL:SETF
    (CLSYS-SVAL CONTROL-FRAME DEBUG-FRAME-OFFSET DOWNFRAME)
    (COMPUTE-FRAME-OFFSET DOWNFRAME))
   (CL:RETURN-FROM CREATE-DOWN-FRAME DOWNFRAME))
  :VOID)

;;; (DEFUN (EXECUTE-BACKWARD-CHAINING-PROOF? BOOLEAN) ...)

(CL:DEFUN EXECUTE-BACKWARD-CHAINING-PROOF? (QUERYENVIRONMENT)
  (CL:WHEN
   (CL:<
    (CLSYS-SVAL QUERY-ENVIRONMENT TOP-CONTROL-FRAME-OFFSET QUERYENVIRONMENT)
    1)
   (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? FALSE))
  (CL:LET*
   ((*QUERYENVIRONMENT* QUERYENVIRONMENT) (*CONTEXT* (GET-QUERY-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *QUERYENVIRONMENT* *CONTEXT*))
   (CL:LET*
    ((FRAME
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK QUERYENVIRONMENT))
       0))
     (PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
     (DEPTH 0)
     (LASTMOVE KWD-QUERY-DOWN)
     (PARTIALMATCH?
      (DEFINED?
       (CLSYS-SVAL
        QUERY-ENVIRONMENT
        PARTIAL-MATCH-STRATEGY
        QUERYENVIRONMENT))))
    (CL:LOOP
     (CL:WHEN
      (CL:EQ (TRACE-KEYWORD? KWD-QUERY-GOAL-TREE) 1)
      (TRACE-GOAL-TREE FRAME DEPTH LASTMOVE))
     (CL:LET*
      ((TEST-VALUE-001 (CLSYS-SVAL CONTROL-FRAME STATE FRAME)))
      (CL:COND
       ((CL:EQ TEST-VALUE-001 KWD-QUERY-AND)
        (CL:WHEN
         (CL:EQ PARTIALMATCH? 1)
         (CL:SETQ LASTMOVE (INTERPRET-AND-SCORES FRAME LASTMOVE)))
        (CL:COND
         ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
          (CL:PROGN
           (CL:SETQ DEPTH (CL:1+ DEPTH))
           (CL:COND
            ((CL:>
              DEPTH
              (CLSYS-SVAL
               QUERY-ENVIRONMENT
               CURRENT-DEPTH-CUTOFF
               QUERYENVIRONMENT))
             (CL:WHEN
              (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
              (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
             (CL:SETQ DEPTH (CL:1- DEPTH))
             (CL:MULTIPLE-VALUE-SETQ
              (FRAME DEPTH)
              (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
            ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
             (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
            (CL:T
             (CL:LET*
              ((UPFRAME FRAME))
              (CL:SETQ
               PROPOSITION
               (CAST
                (CL:AREF
                 (CLSYS-SVAL
                  VECTOR
                  THE-ARRAY
                  (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                 (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                SGT-QUERY-PROPOSITION))
              (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
              (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
              (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
          (CL:COND
           ((CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
            (CL:SETF
             (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME)
             (CL:1+ (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME)))
            (CL:IF
             (CL:<
              (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME)
              (LENGTH (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION)))
             (CL:PROGN
              (CL:SETQ DEPTH (CL:1+ DEPTH))
              (CL:COND
               ((CL:>
                 DEPTH
                 (CLSYS-SVAL
                  QUERY-ENVIRONMENT
                  CURRENT-DEPTH-CUTOFF
                  QUERYENVIRONMENT))
                (CL:WHEN
                 (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
                 (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
                (CL:SETQ DEPTH (CL:1- DEPTH))
                (CL:MULTIPLE-VALUE-SETQ
                 (FRAME DEPTH)
                 (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
                (CL:SETQ
                 PROPOSITION
                 (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
                (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
               ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
                (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                (CL:SETQ
                 PROPOSITION
                 (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
                (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
               (CL:T
                (CL:LET*
                 ((UPFRAME FRAME))
                 (CL:SETQ
                  PROPOSITION
                  (CAST
                   (CL:AREF
                    (CLSYS-SVAL
                     VECTOR
                     THE-ARRAY
                     (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                    (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                   SGT-QUERY-PROPOSITION))
                 (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
                 (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
                 (CL:SETQ LASTMOVE KWD-QUERY-DOWN)))))
             (CL:IF
              (CL:EQ (CLSYS-SVAL CONTROL-FRAME BACK FRAME) NULL)
              (CL:PROGN
               (UPDATE-GOAL-CACHE FRAME TRUE)
               (CL:SETQ DEPTH (CL:1- DEPTH))
               (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
               (CL:SETQ
                PROPOSITION
                (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
               (POP-CONTROL-FRAME QUERYENVIRONMENT)
               (CL:WHEN
                (CL:NOT
                 (CL:EQ
                  (CLSYS-SVAL
                   CONTROL-FRAME
                   DOWN
                   (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                  NULL))
                (CL:ERROR
                 "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
               (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
               (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))
              (CL:PROGN
               (CL:LET*
                ((FORWARDFRAME FRAME))
                (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME BACK FRAME))
                (CL:SETQ
                 PROPOSITION
                 (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
                (CL:SETF (CLSYS-SVAL CONTROL-FRAME BACK FORWARDFRAME) NULL)
                (CL:SETF
                 (CLSYS-SVAL
                  CONTROL-FRAME
                  DOWN
                  (CLSYS-SVAL CONTROL-FRAME UP FORWARDFRAME))
                 FRAME)
                (POP-CONTROL-FRAME QUERYENVIRONMENT))
               (CL:PROGN
                (UPDATE-GOAL-CACHE FRAME TRUE)
                (CL:SETQ DEPTH (CL:1- DEPTH))
                (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
                (CL:SETQ
                 PROPOSITION
                 (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
                (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))))))
           ((CL:EQ
             (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME)
             (CL:1- (LENGTH (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))))
            (CL:PROGN
             (UPDATE-GOAL-CACHE FRAME TRUE)
             (CL:SETQ DEPTH (CL:1- DEPTH))
             (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))
           (CL:T
            (CL:LET*
             ((BACKFRAME FRAME)
              (UPFRAME (CLSYS-SVAL CONTROL-FRAME UP BACKFRAME)))
             (CL:SETQ
              FRAME
              (CREATE-DOWN-FRAME
               UPFRAME
               (CLSYS-SVAL CONTROL-FRAME PROPOSITION BACKFRAME)))
             (CL:SETF (CLSYS-SVAL CONTROL-FRAME BACK FRAME) BACKFRAME)
             (CL:SETF (CLSYS-SVAL CONTROL-FRAME STATE FRAME) KWD-QUERY-AND)
             (CL:SETF
              (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME)
              (CL:1+ (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR BACKFRAME))))
            (CL:PROGN
             (CL:SETQ DEPTH (CL:1+ DEPTH))
             (CL:COND
              ((CL:>
                DEPTH
                (CLSYS-SVAL
                 QUERY-ENVIRONMENT
                 CURRENT-DEPTH-CUTOFF
                 QUERYENVIRONMENT))
               (CL:WHEN
                (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
                (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
               (CL:SETQ DEPTH (CL:1- DEPTH))
               (CL:MULTIPLE-VALUE-SETQ
                (FRAME DEPTH)
                (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
               (CL:SETQ
                PROPOSITION
                (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
               (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
              ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
               (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               (CL:SETQ
                PROPOSITION
                (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
               (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
              (CL:T
               (CL:LET*
                ((UPFRAME FRAME))
                (CL:SETQ
                 PROPOSITION
                 (CAST
                  (CL:AREF
                   (CLSYS-SVAL
                    VECTOR
                    THE-ARRAY
                    (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                   (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                  SGT-QUERY-PROPOSITION))
                (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
                (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
                (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))))))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
          (CL:IF
           (CL:EQ (CLSYS-SVAL CONTROL-FRAME BACK FRAME) NULL)
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME FALSE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (POP-CONTROL-FRAME QUERYENVIRONMENT)
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CLSYS-SVAL
                CONTROL-FRAME
                DOWN
                (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               NULL))
             (CL:ERROR
              "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
            (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
            (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
           (CL:PROGN
            (CL:LET*
             ((FORWARDFRAME FRAME))
             (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME BACK FRAME))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (CL:SETF (CLSYS-SVAL CONTROL-FRAME BACK FORWARDFRAME) NULL)
             (CL:SETF
              (CLSYS-SVAL
               CONTROL-FRAME
               DOWN
               (CLSYS-SVAL CONTROL-FRAME UP FORWARDFRAME))
              FRAME)
             (POP-CONTROL-FRAME QUERYENVIRONMENT))
            (CL:PROGN
             (CL:SETQ DEPTH (CL:1+ DEPTH))
             (CL:COND
              ((CL:>
                DEPTH
                (CLSYS-SVAL
                 QUERY-ENVIRONMENT
                 CURRENT-DEPTH-CUTOFF
                 QUERYENVIRONMENT))
               (CL:WHEN
                (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
                (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
               (CL:SETQ DEPTH (CL:1- DEPTH))
               (CL:MULTIPLE-VALUE-SETQ
                (FRAME DEPTH)
                (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
               (CL:SETQ
                PROPOSITION
                (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
               (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
              ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
               (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               (CL:SETQ
                PROPOSITION
                (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
               (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
              (CL:T
               (CL:LET*
                ((UPFRAME FRAME))
                (CL:SETQ
                 PROPOSITION
                 (CAST
                  (CL:AREF
                   (CLSYS-SVAL
                    VECTOR
                    THE-ARRAY
                    (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                   (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                  SGT-QUERY-PROPOSITION))
                (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
                (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
                (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE))))
       ((CL:EQ TEST-VALUE-001 KWD-QUERY-OR)
        (CL:WHEN
         (CL:EQ PARTIALMATCH? 1)
         (CL:SETQ LASTMOVE (INTERPRET-OR-SCORES FRAME LASTMOVE)))
        (CL:COND
         ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
          (CL:PROGN
           (CL:SETQ DEPTH (CL:1+ DEPTH))
           (CL:COND
            ((CL:>
              DEPTH
              (CLSYS-SVAL
               QUERY-ENVIRONMENT
               CURRENT-DEPTH-CUTOFF
               QUERYENVIRONMENT))
             (CL:WHEN
              (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
              (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
             (CL:SETQ DEPTH (CL:1- DEPTH))
             (CL:MULTIPLE-VALUE-SETQ
              (FRAME DEPTH)
              (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
            ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
             (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
            (CL:T
             (CL:LET*
              ((UPFRAME FRAME))
              (CL:SETQ
               PROPOSITION
               (CAST
                (CL:AREF
                 (CLSYS-SVAL
                  VECTOR
                  THE-ARRAY
                  (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                 (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                SGT-QUERY-PROPOSITION))
              (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
              (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
              (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
          (CL:WHEN
           (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
           (CL:SETF
            (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME)
            (CL:1+ (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME))))
          (CL:IF
           (CL:<
            (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME)
            (LENGTH (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION)))
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME TRUE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME TRUE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (POP-CONTROL-FRAME QUERYENVIRONMENT)
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CLSYS-SVAL
                CONTROL-FRAME
                DOWN
                (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               NULL))
             (CL:ERROR
              "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
            (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
            (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
          (CL:SETF
           (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME)
           (CL:1+ (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME)))
          (CL:IF
           (CL:<
            (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME)
            (LENGTH (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION)))
           (CL:PROGN
            (CL:SETQ DEPTH (CL:1+ DEPTH))
            (CL:COND
             ((CL:>
               DEPTH
               (CLSYS-SVAL
                QUERY-ENVIRONMENT
                CURRENT-DEPTH-CUTOFF
                QUERYENVIRONMENT))
              (CL:WHEN
               (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
               (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
              (CL:SETQ DEPTH (CL:1- DEPTH))
              (CL:MULTIPLE-VALUE-SETQ
               (FRAME DEPTH)
               (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
              (CL:SETQ
               PROPOSITION
               (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
              (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
             ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
              (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
              (CL:SETQ
               PROPOSITION
               (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
              (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
             (CL:T
              (CL:LET*
               ((UPFRAME FRAME))
               (CL:SETQ
                PROPOSITION
                (CAST
                 (CL:AREF
                  (CLSYS-SVAL
                   VECTOR
                   THE-ARRAY
                   (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                  (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                 SGT-QUERY-PROPOSITION))
               (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
               (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
               (CL:SETQ LASTMOVE KWD-QUERY-DOWN)))))
           (CL:IF
            (CL:EQ
             (CLSYS-SVAL QUERY-ENVIRONMENT DEEP-INFERENCE? *QUERYENVIRONMENT*)
             1)
            (CL:PROGN
             (CL:SETF
              (CLSYS-SVAL CONTROL-FRAME STATE FRAME)
              KWD-QUERY-SELECT-STRATEGY)
             (CL:SETF
              (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
              KWD-QUERY-HEAVY-DUTY-DISJUNCTION)
             (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
            (CL:PROGN
             (UPDATE-GOAL-CACHE FRAME FALSE)
             (CL:SETQ DEPTH (CL:1- DEPTH))
             (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (POP-CONTROL-FRAME QUERYENVIRONMENT)
             (CL:WHEN
              (CL:NOT
               (CL:EQ
                (CLSYS-SVAL
                 CONTROL-FRAME
                 DOWN
                 (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                NULL))
              (CL:ERROR
               "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
             (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
             (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE))))
       ((CL:EQ TEST-VALUE-001 KWD-QUERY-NOT)
        (CL:COND
         ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
          (CL:LET*
           ((OLDREVERSEPOLARITY?
             (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? FRAME)))
           (CL:SETF
            (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? FRAME)
            (CL:IF (CL:EQ OLDREVERSEPOLARITY? 0) TRUE FALSE))
           (CL:PROGN
            (CL:SETQ DEPTH (CL:1+ DEPTH))
            (CL:COND
             ((CL:>
               DEPTH
               (CLSYS-SVAL
                QUERY-ENVIRONMENT
                CURRENT-DEPTH-CUTOFF
                QUERYENVIRONMENT))
              (CL:WHEN
               (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
               (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
              (CL:SETQ DEPTH (CL:1- DEPTH))
              (CL:MULTIPLE-VALUE-SETQ
               (FRAME DEPTH)
               (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
              (CL:SETQ
               PROPOSITION
               (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
              (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
             ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
              (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
              (CL:SETQ
               PROPOSITION
               (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
              (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
             (CL:T
              (CL:LET*
               ((UPFRAME FRAME))
               (CL:SETQ
                PROPOSITION
                (CAST
                 (CL:AREF
                  (CLSYS-SVAL
                   VECTOR
                   THE-ARRAY
                   (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                  (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                 SGT-QUERY-PROPOSITION))
               (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
               (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
               (CL:SETQ LASTMOVE KWD-QUERY-DOWN)))))
           (CL:SETF
            (CLSYS-SVAL
             CONTROL-FRAME
             REVERSE-POLARITY?
             (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            OLDREVERSEPOLARITY?)))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
          (CL:WHEN
           (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
           (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
          (CL:PROGN
           (UPDATE-GOAL-CACHE FRAME TRUE)
           (CL:SETQ DEPTH (CL:1- DEPTH))
           (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
           (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
           (POP-CONTROL-FRAME QUERYENVIRONMENT)
           (CL:WHEN
            (CL:NOT
             (CL:EQ
              (CLSYS-SVAL
               CONTROL-FRAME
               DOWN
               (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
              NULL))
            (CL:ERROR
             "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
           (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
           (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
          (CL:PROGN
           (UPDATE-GOAL-CACHE FRAME FALSE)
           (CL:SETQ DEPTH (CL:1- DEPTH))
           (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
           (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
           (POP-CONTROL-FRAME QUERYENVIRONMENT)
           (CL:WHEN
            (CL:NOT
             (CL:EQ
              (CLSYS-SVAL
               CONTROL-FRAME
               DOWN
               (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
              NULL))
            (CL:ERROR
             "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
           (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
           (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
         (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE))))
       ((CL:OR
         (CL:EQ TEST-VALUE-001 KWD-QUERY-IN)
         (CL:EQ TEST-VALUE-001 KWD-QUERY-FUNCTION)
         (CL:EQ TEST-VALUE-001 KWD-QUERY-PREDICATE)
         (CL:EQ TEST-VALUE-001 KWD-QUERY-EQUIVALENT)
         (CL:EQ TEST-VALUE-001 KWD-QUERY-IMPLIES)
         (CL:EQ TEST-VALUE-001 KWD-QUERY-CONSTANT))
        (CREATE-CHOICE-POINT FRAME)
        (CL:LET*
         ((TEST-VALUE-002 (CONTINUE-ATOMIC-PROPOSITION-PROOF FRAME LASTMOVE)))
         (CL:COND
          ((CL:EQ TEST-VALUE-002 KWD-QUERY-CONTINUING-SUCCESS)
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME TRUE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))
          ((CL:EQ TEST-VALUE-002 KWD-QUERY-FINAL-SUCCESS)
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME TRUE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (POP-CONTROL-FRAME QUERYENVIRONMENT)
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CLSYS-SVAL
                CONTROL-FRAME
                DOWN
                (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               NULL))
             (CL:ERROR
              "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
            (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
            (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))
          ((CL:EQ TEST-VALUE-002 KWD-QUERY-FAILURE)
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME FALSE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (POP-CONTROL-FRAME QUERYENVIRONMENT)
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CLSYS-SVAL
                CONTROL-FRAME
                DOWN
                (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               NULL))
             (CL:ERROR
              "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
            (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
            (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
          ((CL:EQ TEST-VALUE-002 KWD-QUERY-OVERLAY)
           (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
          ((CL:EQ TEST-VALUE-002 KWD-QUERY-SPAWNED-SUBQUERY)
           (CL:PROGN
            (CL:SETQ DEPTH (CL:1+ DEPTH))
            (CL:COND
             ((CL:>
               DEPTH
               (CLSYS-SVAL
                QUERY-ENVIRONMENT
                CURRENT-DEPTH-CUTOFF
                QUERYENVIRONMENT))
              (CL:WHEN
               (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
               (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
              (CL:SETQ DEPTH (CL:1- DEPTH))
              (CL:MULTIPLE-VALUE-SETQ
               (FRAME DEPTH)
               (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
              (CL:SETQ
               PROPOSITION
               (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
              (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
             ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
              (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
              (CL:SETQ
               PROPOSITION
               (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
              (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
             (CL:T
              (CL:LET*
               ((UPFRAME FRAME))
               (CL:SETQ
                PROPOSITION
                (CAST
                 (CL:AREF
                  (CLSYS-SVAL
                   VECTOR
                   THE-ARRAY
                   (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                  (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                 SGT-QUERY-PROPOSITION))
               (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
               (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
               (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))))
          (CL:T
           (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-002)))))
       ((CL:EQ TEST-VALUE-001 KWD-QUERY-SUBGOALS)
        (CL:WHEN
         (CL:EQ PARTIALMATCH? 1)
         (CL:SETQ LASTMOVE (INTERPRET-SUBGOALS-SCORES FRAME LASTMOVE)))
        (CL:COND
         ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
          (CL:IF
           (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
           (CL:PROGN
            (CL:SETQ DEPTH (CL:1+ DEPTH))
            (CL:COND
             ((CL:>
               DEPTH
               (CLSYS-SVAL
                QUERY-ENVIRONMENT
                CURRENT-DEPTH-CUTOFF
                QUERYENVIRONMENT))
              (CL:WHEN
               (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
               (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
              (CL:SETQ DEPTH (CL:1- DEPTH))
              (CL:MULTIPLE-VALUE-SETQ
               (FRAME DEPTH)
               (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
              (CL:SETQ
               PROPOSITION
               (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
              (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
             ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
              (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
              (CL:SETQ
               PROPOSITION
               (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
              (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
             (CL:T
              (CL:LET*
               ((UPFRAME FRAME))
               (CL:SETQ
                PROPOSITION
                (CAST
                 (CL:AREF
                  (CLSYS-SVAL
                   VECTOR
                   THE-ARRAY
                   (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                  (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                 SGT-QUERY-PROPOSITION))
               (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
               (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
               (CL:SETQ LASTMOVE KWD-QUERY-DOWN)))))
           (CL:LET*
            ((TEST-VALUE-003 (CONTINUE-SUBGOALS-PROOF FRAME)))
            (CL:COND
             ((CL:EQ TEST-VALUE-003 KWD-QUERY-SPAWNED-SUBQUERY)
              (CL:PROGN
               (CL:SETQ DEPTH (CL:1+ DEPTH))
               (CL:COND
                ((CL:>
                  DEPTH
                  (CLSYS-SVAL
                   QUERY-ENVIRONMENT
                   CURRENT-DEPTH-CUTOFF
                   QUERYENVIRONMENT))
                 (CL:WHEN
                  (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
                  (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
                 (CL:SETQ DEPTH (CL:1- DEPTH))
                 (CL:MULTIPLE-VALUE-SETQ
                  (FRAME DEPTH)
                  (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
                 (CL:SETQ
                  PROPOSITION
                  (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
                 (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
                ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
                 (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                 (CL:SETQ
                  PROPOSITION
                  (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
                 (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
                (CL:T
                 (CL:LET*
                  ((UPFRAME FRAME))
                  (CL:SETQ
                   PROPOSITION
                   (CAST
                    (CL:AREF
                     (CLSYS-SVAL
                      VECTOR
                      THE-ARRAY
                      (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                     (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                    SGT-QUERY-PROPOSITION))
                  (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
                  (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
                  (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))))
             ((CL:EQ TEST-VALUE-003 KWD-QUERY-SUCCESS)
              (CL:PROGN
               (CL:WHEN
                (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME UP FRAME) NULL))
                (UPDATE-GOAL-CACHE FRAME TRUE))
               (CL:SETQ DEPTH (CL:1- DEPTH))
               (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
               (CL:WHEN
                (CL:EQ FRAME NULL)
                (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? TRUE))
               (POP-CONTROL-FRAME QUERYENVIRONMENT)
               (CL:WHEN
                (CL:NOT (CL:EQ FRAME NULL))
                (CL:WHEN
                 (CL:NOT
                  (CL:EQ
                   (CLSYS-SVAL
                    CONTROL-FRAME
                    DOWN
                    (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                   NULL))
                 (CL:ERROR
                  "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
                (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
               (CL:SETQ
                PROPOSITION
                (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
               (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)
               LASTMOVE))
             ((CL:EQ TEST-VALUE-003 KWD-QUERY-FAILURE)
              (CL:PROGN
               (CL:WHEN
                (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME UP FRAME) NULL))
                (UPDATE-GOAL-CACHE FRAME FALSE))
               (CL:SETQ DEPTH (CL:1- DEPTH))
               (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
               (CL:WHEN
                (CL:EQ FRAME NULL)
                (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? FALSE))
               (POP-CONTROL-FRAME QUERYENVIRONMENT)
               (CL:WHEN
                (CL:NOT (CL:EQ FRAME NULL))
                (CL:WHEN
                 (CL:NOT
                  (CL:EQ
                   (CLSYS-SVAL
                    CONTROL-FRAME
                    DOWN
                    (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                   NULL))
                 (CL:ERROR
                  "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
                (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
               (CL:SETQ
                PROPOSITION
                (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
               (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)
               LASTMOVE))
             ((CL:EQ TEST-VALUE-003 KWD-QUERY-OVERLAY)
              (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
             ((CL:EQ TEST-VALUE-003 KWD-QUERY-FAILED-OVERLAY)
              (CL:WHEN
               (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
               (CL:PROGN
                (CL:SETQ DEPTH (CL:1+ DEPTH))
                (CL:COND
                 ((CL:>
                   DEPTH
                   (CLSYS-SVAL
                    QUERY-ENVIRONMENT
                    CURRENT-DEPTH-CUTOFF
                    QUERYENVIRONMENT))
                  (CL:WHEN
                   (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
                   (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
                  (CL:SETQ DEPTH (CL:1- DEPTH))
                  (CL:MULTIPLE-VALUE-SETQ
                   (FRAME DEPTH)
                   (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
                  (CL:SETQ
                   PROPOSITION
                   (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
                  (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
                 ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
                  (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                  (CL:SETQ
                   PROPOSITION
                   (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
                  (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
                 (CL:T
                  (CL:LET*
                   ((UPFRAME FRAME))
                   (CL:SETQ
                    PROPOSITION
                    (CAST
                     (CL:AREF
                      (CLSYS-SVAL
                       VECTOR
                       THE-ARRAY
                       (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                      (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                     SGT-QUERY-PROPOSITION))
                   (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
                   (CL:SETF
                    (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME)
                    DEPTH)
                   (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))))
              (CL:PROGN
               (UPDATE-GOAL-CACHE FRAME FALSE)
               (CL:SETQ DEPTH (CL:1- DEPTH))
               (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
               (CL:SETQ
                PROPOSITION
                (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
               (POP-CONTROL-FRAME QUERYENVIRONMENT)
               (CL:WHEN
                (CL:NOT
                 (CL:EQ
                  (CLSYS-SVAL
                   CONTROL-FRAME
                   DOWN
                   (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                  NULL))
                (CL:ERROR
                 "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
               (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
               (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
             (CL:T
              (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-003))))))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
          (CL:IF
           (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
           (CL:PROGN
            (CL:WHEN
             (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME UP FRAME) NULL))
             (UPDATE-GOAL-CACHE FRAME TRUE))
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:WHEN
             (CL:EQ FRAME NULL)
             (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? TRUE))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)
            LASTMOVE)
           (CL:PROGN
            (CL:WHEN
             (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME UP FRAME) NULL))
             (UPDATE-GOAL-CACHE FRAME TRUE))
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:WHEN
             (CL:EQ FRAME NULL)
             (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? TRUE))
            (POP-CONTROL-FRAME QUERYENVIRONMENT)
            (CL:WHEN
             (CL:NOT (CL:EQ FRAME NULL))
             (CL:WHEN
              (CL:NOT
               (CL:EQ
                (CLSYS-SVAL
                 CONTROL-FRAME
                 DOWN
                 (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                NULL))
              (CL:ERROR
               "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
             (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)
            LASTMOVE)))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
          (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
         (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE))))
       ((CL:EQ TEST-VALUE-001 KWD-QUERY-PATTERN)
        (CL:COND
         ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
          (RESET-CURRENT-VARIABLE-FRAME-OFFSET FRAME KWD-QUERY-LOCAL)
          (CL:WHEN
           (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
           (CL:ERROR "Safety violation: INTERNAL ERROR: Missing down frame."))
          (CL:PROGN
           (CL:SETQ DEPTH (CL:1+ DEPTH))
           (CL:COND
            ((CL:>
              DEPTH
              (CLSYS-SVAL
               QUERY-ENVIRONMENT
               CURRENT-DEPTH-CUTOFF
               QUERYENVIRONMENT))
             (CL:WHEN
              (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
              (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
             (CL:SETQ DEPTH (CL:1- DEPTH))
             (CL:MULTIPLE-VALUE-SETQ
              (FRAME DEPTH)
              (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
            ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
             (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
            (CL:T
             (CL:LET*
              ((UPFRAME FRAME))
              (CL:SETQ
               PROPOSITION
               (CAST
                (CL:AREF
                 (CLSYS-SVAL
                  VECTOR
                  THE-ARRAY
                  (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                 (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                SGT-QUERY-PROPOSITION))
              (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
              (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
              (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
          (CL:LET*
           ((FUTUREBINDINGS?
             (DEFINED? (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))))
           (CL:COND
            ((CL:EQ
              (TRANSFER-PATTERN-QUERY-BINDINGS? FRAME FUTUREBINDINGS?)
              1)
             (CL:IF
              (CL:EQ FUTUREBINDINGS? 1)
              (CL:PROGN
               (CL:WHEN
                (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME UP FRAME) NULL))
                (UPDATE-GOAL-CACHE FRAME TRUE))
               (CL:SETQ DEPTH (CL:1- DEPTH))
               (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
               (CL:WHEN
                (CL:EQ FRAME NULL)
                (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? TRUE))
               (CL:SETQ
                PROPOSITION
                (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
               (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)
               LASTMOVE)
              (CL:PROGN
               (CL:WHEN
                (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME UP FRAME) NULL))
                (UPDATE-GOAL-CACHE FRAME TRUE))
               (CL:SETQ DEPTH (CL:1- DEPTH))
               (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
               (CL:WHEN
                (CL:EQ FRAME NULL)
                (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? TRUE))
               (POP-CONTROL-FRAME QUERYENVIRONMENT)
               (CL:WHEN
                (CL:NOT (CL:EQ FRAME NULL))
                (CL:WHEN
                 (CL:NOT
                  (CL:EQ
                   (CLSYS-SVAL
                    CONTROL-FRAME
                    DOWN
                    (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                   NULL))
                 (CL:ERROR
                  "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
                (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
               (CL:SETQ
                PROPOSITION
                (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
               (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)
               LASTMOVE)))
            ((CL:EQ FUTUREBINDINGS? 1)
             (CL:PROGN
              (CL:SETQ DEPTH (CL:1+ DEPTH))
              (CL:COND
               ((CL:>
                 DEPTH
                 (CLSYS-SVAL
                  QUERY-ENVIRONMENT
                  CURRENT-DEPTH-CUTOFF
                  QUERYENVIRONMENT))
                (CL:WHEN
                 (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
                 (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
                (CL:SETQ DEPTH (CL:1- DEPTH))
                (CL:MULTIPLE-VALUE-SETQ
                 (FRAME DEPTH)
                 (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
                (CL:SETQ
                 PROPOSITION
                 (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
                (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
               ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
                (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                (CL:SETQ
                 PROPOSITION
                 (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
                (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
               (CL:T
                (CL:LET*
                 ((UPFRAME FRAME))
                 (CL:SETQ
                  PROPOSITION
                  (CAST
                   (CL:AREF
                    (CLSYS-SVAL
                     VECTOR
                     THE-ARRAY
                     (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                    (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                   SGT-QUERY-PROPOSITION))
                 (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
                 (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
                 (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))))
            (CL:T
             (CL:PROGN
              (CL:WHEN
               (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME UP FRAME) NULL))
               (UPDATE-GOAL-CACHE FRAME FALSE))
              (CL:SETQ DEPTH (CL:1- DEPTH))
              (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
              (CL:WHEN
               (CL:EQ FRAME NULL)
               (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? FALSE))
              (POP-CONTROL-FRAME QUERYENVIRONMENT)
              (CL:WHEN
               (CL:NOT (CL:EQ FRAME NULL))
               (CL:WHEN
                (CL:NOT
                 (CL:EQ
                  (CLSYS-SVAL
                   CONTROL-FRAME
                   DOWN
                   (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                  NULL))
                (CL:ERROR
                 "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
               (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
              (CL:SETQ
               PROPOSITION
               (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
              (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)
              LASTMOVE)))))
         ((CL:OR
           (CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
           (CL:EQ LASTMOVE KWD-QUERY-FAILED-OVERLAY))
          (UNBIND-PATTERN-VARIABLES FRAME)
          (CL:PROGN
           (CL:WHEN
            (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME UP FRAME) NULL))
            (UPDATE-GOAL-CACHE FRAME FALSE))
           (CL:SETQ DEPTH (CL:1- DEPTH))
           (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
           (CL:WHEN
            (CL:EQ FRAME NULL)
            (CL:RETURN-FROM EXECUTE-BACKWARD-CHAINING-PROOF? FALSE))
           (POP-CONTROL-FRAME QUERYENVIRONMENT)
           (CL:WHEN
            (CL:NOT (CL:EQ FRAME NULL))
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CLSYS-SVAL
                CONTROL-FRAME
                DOWN
                (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               NULL))
             (CL:ERROR
              "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
            (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
           (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
           (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)
           LASTMOVE))
         (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE))))
       ((CL:OR
         (CL:EQ TEST-VALUE-001 KWD-QUERY-CONTAINED-BY)
         (CL:EQ TEST-VALUE-001 KWD-QUERY-ITERATIVE-FORALL))
        (CL:COND
         ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
          (CL:WHEN
           (CL:EQ
            (CLSYS-SVAL CONTROL-FRAME STATE FRAME)
            KWD-QUERY-CONTAINED-BY)
           (RESET-CURRENT-VARIABLE-FRAME-OFFSET FRAME KWD-QUERY-LOCAL))
          (CL:PROGN
           (CL:SETQ DEPTH (CL:1+ DEPTH))
           (CL:COND
            ((CL:>
              DEPTH
              (CLSYS-SVAL
               QUERY-ENVIRONMENT
               CURRENT-DEPTH-CUTOFF
               QUERYENVIRONMENT))
             (CL:WHEN
              (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
              (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
             (CL:SETQ DEPTH (CL:1- DEPTH))
             (CL:MULTIPLE-VALUE-SETQ
              (FRAME DEPTH)
              (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
            ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
             (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
            (CL:T
             (CL:LET*
              ((UPFRAME FRAME))
              (CL:SETQ
               PROPOSITION
               (CAST
                (CL:AREF
                 (CLSYS-SVAL
                  VECTOR
                  THE-ARRAY
                  (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                 (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                SGT-QUERY-PROPOSITION))
              (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
              (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
              (CL:SETQ LASTMOVE KWD-QUERY-DOWN)))))
          (CL:SETF
           (CLSYS-SVAL CONTROL-FRAME BACK (CLSYS-SVAL CONTROL-FRAME UP FRAME))
           FRAME))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
          (CL:ECASE
           (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME)
           (0
            (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
            (CL:SETF (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME) 1)
            (CL:PROGN
             (CL:SETQ DEPTH (CL:1+ DEPTH))
             (CL:COND
              ((CL:>
                DEPTH
                (CLSYS-SVAL
                 QUERY-ENVIRONMENT
                 CURRENT-DEPTH-CUTOFF
                 QUERYENVIRONMENT))
               (CL:WHEN
                (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
                (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
               (CL:SETQ DEPTH (CL:1- DEPTH))
               (CL:MULTIPLE-VALUE-SETQ
                (FRAME DEPTH)
                (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
               (CL:SETQ
                PROPOSITION
                (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
               (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
              ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
               (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               (CL:SETQ
                PROPOSITION
                (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
               (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
              (CL:T
               (CL:LET*
                ((UPFRAME FRAME))
                (CL:SETQ
                 PROPOSITION
                 (CAST
                  (CL:AREF
                   (CLSYS-SVAL
                    VECTOR
                    THE-ARRAY
                    (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                   (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                  SGT-QUERY-PROPOSITION))
                (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
                (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
                (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))))
           (1
            (CL:WHEN
             (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
             (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
            (CL:IF
             (CL:EQ
              (CLSYS-SVAL
               CONTROL-FRAME
               STATE
               (CLSYS-SVAL CONTROL-FRAME BACK FRAME))
              KWD-QUERY-POPPED)
             (CL:PROGN
              (UPDATE-GOAL-CACHE FRAME TRUE)
              (CL:SETQ DEPTH (CL:1- DEPTH))
              (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
              (CL:SETQ
               PROPOSITION
               (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
              (POP-CONTROL-FRAME QUERYENVIRONMENT)
              (CL:WHEN
               (CL:NOT
                (CL:EQ
                 (CLSYS-SVAL
                  CONTROL-FRAME
                  DOWN
                  (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                 NULL))
               (CL:ERROR
                "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
              (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
              (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))
             (CL:PROGN
              (CL:SETF
               (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)
               (CLSYS-SVAL CONTROL-FRAME BACK FRAME))
              (CL:SETF (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME) 0)
              (CL:PROGN
               (CL:SETQ DEPTH (CL:1+ DEPTH))
               (CL:COND
                ((CL:>
                  DEPTH
                  (CLSYS-SVAL
                   QUERY-ENVIRONMENT
                   CURRENT-DEPTH-CUTOFF
                   QUERYENVIRONMENT))
                 (CL:WHEN
                  (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
                  (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
                 (CL:SETQ DEPTH (CL:1- DEPTH))
                 (CL:MULTIPLE-VALUE-SETQ
                  (FRAME DEPTH)
                  (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
                 (CL:SETQ
                  PROPOSITION
                  (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
                 (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
                ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
                 (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                 (CL:SETQ
                  PROPOSITION
                  (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
                 (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
                (CL:T
                 (CL:LET*
                  ((UPFRAME FRAME))
                  (CL:SETQ
                   PROPOSITION
                   (CAST
                    (CL:AREF
                     (CLSYS-SVAL
                      VECTOR
                      THE-ARRAY
                      (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                     (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                    SGT-QUERY-PROPOSITION))
                  (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
                  (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
                  (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))))))))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
          (CL:ECASE
           (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME)
           (0
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CLSYS-SVAL
                CONTROL-FRAME
                STATE
                (CLSYS-SVAL CONTROL-FRAME BACK FRAME))
               KWD-QUERY-POPPED))
             (CL:ERROR
              "Safety violation: INTERNAL ERROR: Failed to pop antecedent frame."))
            (CL:PROGN
             (UPDATE-GOAL-CACHE FRAME TRUE)
             (CL:SETQ DEPTH (CL:1- DEPTH))
             (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (POP-CONTROL-FRAME QUERYENVIRONMENT)
             (CL:WHEN
              (CL:NOT
               (CL:EQ
                (CLSYS-SVAL
                 CONTROL-FRAME
                 DOWN
                 (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                NULL))
              (CL:ERROR
               "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
             (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
             (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))
           (1
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CLSYS-SVAL
                CONTROL-FRAME
                STATE
                (CLSYS-SVAL CONTROL-FRAME BACK FRAME))
               KWD-QUERY-POPPED))
             (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME BACK FRAME)))
            (CL:PROGN
             (UPDATE-GOAL-CACHE FRAME FALSE)
             (CL:SETQ DEPTH (CL:1- DEPTH))
             (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (POP-CONTROL-FRAME QUERYENVIRONMENT)
             (CL:WHEN
              (CL:NOT
               (CL:EQ
                (CLSYS-SVAL
                 CONTROL-FRAME
                 DOWN
                 (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
                NULL))
              (CL:ERROR
               "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
             (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
             (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE))))
       ((CL:EQ TEST-VALUE-001 KWD-QUERY-SELECT-STRATEGY)
        (CL:LET*
         ((TEST-VALUE-004 (SELECT-NEXT-PROOF-STRATEGY FRAME LASTMOVE)))
         (CL:COND
          ((CL:EQ TEST-VALUE-004 KWD-QUERY-FINAL-SUCCESS)
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME TRUE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (POP-CONTROL-FRAME QUERYENVIRONMENT)
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CLSYS-SVAL
                CONTROL-FRAME
                DOWN
                (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               NULL))
             (CL:ERROR
              "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
            (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
            (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))
          ((CL:EQ TEST-VALUE-004 KWD-QUERY-FAILURE)
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME FALSE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (POP-CONTROL-FRAME QUERYENVIRONMENT)
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CLSYS-SVAL
                CONTROL-FRAME
                DOWN
                (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               NULL))
             (CL:ERROR
              "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
            (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
            (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
          ((CL:EQ TEST-VALUE-004 KWD-QUERY-SUBGOAL)
           (CL:PROGN
            (CL:SETQ DEPTH (CL:1+ DEPTH))
            (CL:COND
             ((CL:>
               DEPTH
               (CLSYS-SVAL
                QUERY-ENVIRONMENT
                CURRENT-DEPTH-CUTOFF
                QUERYENVIRONMENT))
              (CL:WHEN
               (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
               (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
              (CL:SETQ DEPTH (CL:1- DEPTH))
              (CL:MULTIPLE-VALUE-SETQ
               (FRAME DEPTH)
               (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
              (CL:SETQ
               PROPOSITION
               (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
              (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
             ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
              (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
              (CL:SETQ
               PROPOSITION
               (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
              (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
             (CL:T
              (CL:LET*
               ((UPFRAME FRAME))
               (CL:SETQ
                PROPOSITION
                (CAST
                 (CL:AREF
                  (CLSYS-SVAL
                   VECTOR
                   THE-ARRAY
                   (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                  (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                 SGT-QUERY-PROPOSITION))
               (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
               (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
               (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))))
          (CL:T
           (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-004)))))
       ((CL:EQ TEST-VALUE-001 KWD-QUERY-EXISTS)
        (CL:COND
         ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
          (CL:PROGN
           (CL:SETQ DEPTH (CL:1+ DEPTH))
           (CL:COND
            ((CL:>
              DEPTH
              (CLSYS-SVAL
               QUERY-ENVIRONMENT
               CURRENT-DEPTH-CUTOFF
               QUERYENVIRONMENT))
             (CL:WHEN
              (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
              (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
             (CL:SETQ DEPTH (CL:1- DEPTH))
             (CL:MULTIPLE-VALUE-SETQ
              (FRAME DEPTH)
              (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
            ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
             (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
            (CL:T
             (CL:LET*
              ((UPFRAME FRAME))
              (CL:SETQ
               PROPOSITION
               (CAST
                (CL:AREF
                 (CLSYS-SVAL
                  VECTOR
                  THE-ARRAY
                  (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                 (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                SGT-QUERY-PROPOSITION))
              (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
              (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
              (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
          (CL:IF
           (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME TRUE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (POP-CONTROL-FRAME QUERYENVIRONMENT)
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CLSYS-SVAL
                CONTROL-FRAME
                DOWN
                (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               NULL))
             (CL:ERROR
              "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
            (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
            (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME TRUE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE))))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
          (CL:IF
           (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME FALSE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (POP-CONTROL-FRAME QUERYENVIRONMENT)
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CLSYS-SVAL
                CONTROL-FRAME
                DOWN
                (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               NULL))
             (CL:ERROR
              "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
            (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
            (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME FALSE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))))
         (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE))))
       ((CL:EQ TEST-VALUE-001 KWD-QUERY-FORALL)
        (CL:LET*
         ((TEST-VALUE-005 FALSE))
         (CL:IF
          (CL:EQ (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? FRAME) 1)
          (CL:SETQ TEST-VALUE-005 TRUE)
          (CL:LET*
           ((ALWAYS?-001 TRUE))
           (CL:LET*
            ((VAR NULL)
             (VECTOR-001
              (DYNAMIC-SLOT-VALUE PROPOSITION SYM-QUERY-IO-VARIABLES NULL))
             (INDEX-001 0)
             (LENGTH-001 (LENGTH VECTOR-001)))
            (CL:LOOP
             WHILE
             (CL:< INDEX-001 LENGTH-001)
             DO
             (CL:PROGN
              (CL:SETQ
               VAR
               (CAST
                (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
                SGT-QUERY-PATTERN-VARIABLE))
              (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
             (CL:WHEN
              (CL:EQ
               (CLOSED-COLLECTION? (GET-DESCRIPTION (LOGICAL-TYPE VAR)))
               0)
              (CL:SETQ ALWAYS?-001 FALSE)
              (CL:RETURN))))
           (CL:SETQ TEST-VALUE-005 ALWAYS?-001)))
         (CL:IF
          (CL:EQ TEST-VALUE-005 1)
          (CL:PROGN
           (CL:SETF
            (CLSYS-SVAL CONTROL-FRAME STATE FRAME)
            KWD-QUERY-ITERATIVE-FORALL)
           (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
          (CL:PROGN
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME FALSE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (POP-CONTROL-FRAME QUERYENVIRONMENT)
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CLSYS-SVAL
                CONTROL-FRAME
                DOWN
                (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               NULL))
             (CL:ERROR
              "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
            (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
            (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))))))
       ((CL:EQ TEST-VALUE-001 KWD-QUERY-CACHED-BINDINGS)
        (CL:WHEN
         (CL:NOT (CL:EQ LASTMOVE KWD-QUERY-DOWN))
         (CL:ERROR
          "Safety violation: INTERNAL ERROR: Illeal move into :CACHED-BINDINGS state."))
        (CREATE-CHOICE-POINT FRAME)
        (CL:LET*
         ((TEST-VALUE-006 (SCAN-CACHED-BINDINGS FRAME)))
         (CL:COND
          ((CL:EQ TEST-VALUE-006 KWD-QUERY-CONTINUING-SUCCESS)
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME TRUE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))
          ((CL:EQ TEST-VALUE-006 KWD-QUERY-FINAL-SUCCESS)
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME TRUE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (POP-CONTROL-FRAME QUERYENVIRONMENT)
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CLSYS-SVAL
                CONTROL-FRAME
                DOWN
                (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               NULL))
             (CL:ERROR
              "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
            (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
            (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))
          ((CL:EQ TEST-VALUE-006 KWD-QUERY-FAILURE)
           (CL:PROGN
            (UPDATE-GOAL-CACHE FRAME FALSE)
            (CL:SETQ DEPTH (CL:1- DEPTH))
            (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
            (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
            (POP-CONTROL-FRAME QUERYENVIRONMENT)
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CLSYS-SVAL
                CONTROL-FRAME
                DOWN
                (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
               NULL))
             (CL:ERROR
              "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
            (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
            (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
          (CL:T
           (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-006)))))
       ((CL:EQ TEST-VALUE-001 KWD-QUERY-FAIL)
        (CL:WHEN
         (CL:EQ (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? FRAME) 1)
         (CL:ERROR ":FAIL not implemented for negative polarity."))
        (CL:WHEN
         (CL:EQ PARTIALMATCH? 1)
         (CL:SETQ LASTMOVE (INTERPRET-FAIL-SCORE FRAME LASTMOVE)))
        (CL:COND
         ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
          (CREATE-CHOICE-POINT FRAME)
          (CL:PROGN
           (CL:SETQ DEPTH (CL:1+ DEPTH))
           (CL:COND
            ((CL:>
              DEPTH
              (CLSYS-SVAL
               QUERY-ENVIRONMENT
               CURRENT-DEPTH-CUTOFF
               QUERYENVIRONMENT))
             (CL:WHEN
              (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
              (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
             (CL:SETQ DEPTH (CL:1- DEPTH))
             (CL:MULTIPLE-VALUE-SETQ
              (FRAME DEPTH)
              (HANDLE-DEPTH-VIOLATION FRAME DEPTH))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL))
            ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
             (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
             (CL:SETQ
              PROPOSITION
              (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
             (CL:SETQ LASTMOVE KWD-QUERY-DOWN))
            (CL:T
             (CL:LET*
              ((UPFRAME FRAME))
              (CL:SETQ
               PROPOSITION
               (CAST
                (CL:AREF
                 (CLSYS-SVAL
                  VECTOR
                  THE-ARRAY
                  (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
                 (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR UPFRAME))
                SGT-QUERY-PROPOSITION))
              (CL:SETQ FRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION))
              (CL:SETF (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH FRAME) DEPTH)
              (CL:SETQ LASTMOVE KWD-QUERY-DOWN))))))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
          (UNBIND-PATTERN-VARIABLES FRAME)
          (CL:PROGN
           (UPDATE-GOAL-CACHE FRAME FALSE)
           (CL:SETQ DEPTH (CL:1- DEPTH))
           (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
           (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
           (POP-CONTROL-FRAME QUERYENVIRONMENT)
           (CL:WHEN
            (CL:NOT
             (CL:EQ
              (CLSYS-SVAL
               CONTROL-FRAME
               DOWN
               (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
              NULL))
            (CL:ERROR
             "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
           (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
           (CL:SETQ LASTMOVE KWD-QUERY-UP-FAIL)))
         ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
          (UNBIND-PATTERN-VARIABLES FRAME)
          (CL:PROGN
           (UPDATE-GOAL-CACHE FRAME TRUE)
           (CL:SETQ DEPTH (CL:1- DEPTH))
           (CL:SETQ FRAME (CLSYS-SVAL CONTROL-FRAME UP FRAME))
           (CL:SETQ PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
           (POP-CONTROL-FRAME QUERYENVIRONMENT)
           (CL:WHEN
            (CL:NOT
             (CL:EQ
              (CLSYS-SVAL
               CONTROL-FRAME
               DOWN
               (CLSYS-SVAL CONTROL-FRAME DOWN FRAME))
              NULL))
            (CL:ERROR
             "Safety violation: INTERNAL ERROR: Forgot to pop frame below top frame."))
           (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
           (CL:SETQ LASTMOVE KWD-QUERY-UP-TRUE)))
         (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE))))
       (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001)))))))
  :VOID)

;;; (DEFUN (SELECT-NEXT-PROOF-STRATEGY KEYWORD) ...)

(CL:DEFUN SELECT-NEXT-PROOF-STRATEGY (FRAME LASTMOVE)
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-QUERY-END-SUBUMPTION-TEST)
     (CL:COND
      ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
       (CL:WHEN
        (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL))
        (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN FRAME)))
       (CL:RETURN-FROM SELECT-NEXT-PROOF-STRATEGY KWD-QUERY-FINAL-SUCCESS))
      (CL:T (CL:RETURN-FROM SELECT-NEXT-PROOF-STRATEGY KWD-QUERY-FAILURE))))
    ((CL:EQ TEST-VALUE-001 KWD-QUERY-HEAVY-DUTY-DISJUNCTION)
     (CL:RETURN-FROM
      SELECT-NEXT-PROOF-STRATEGY
      (CONTINUE-DISJUNCTION-PROOF FRAME LASTMOVE)))
    (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
  :VOID)

;;; (DEFMETHOD (APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS OBJECT) ...)

(CL:DEFMETHOD APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS ((SLOT SLOT) ARGUMENTS)
  (CL:SETQ ARGUMENTS ARGUMENTS)
  (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS BOTTOM)
  :VOID)

;;; (DEFMETHOD (APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS OBJECT) ...)

(CL:DEFMETHOD APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS ((SLOT STORAGE-SLOT) ARGUMENTS)
  (CL:WHEN
   (CL:EQ (LOGIC-SLOT? SLOT) 1)
   (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS BOTTOM))
  (CL:LET*
   ((FIRSTARG
     (NATIVE-VALUE-OF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0))))
   (CL:IF
    (CL:NOT (CL:EQ FIRSTARG NULL))
    (CL:RETURN-FROM
     APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS
     (READ-SLOT-VALUE (CAST FIRSTARG SGT-QUERY-STANDARD-OBJECT) SLOT))
    (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS BOTTOM)))
  :VOID)

;;; (DEFMETHOD (APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS OBJECT) ...)

(CL:DEFMETHOD APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS ((SLOT METHOD-SLOT) ARGUMENTS)
  (CL:WHEN
   (CL:EQ (LOGIC-SLOT? SLOT) 1)
   (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS BOTTOM))
  (CL:LET*
   ((CODE (CLSYS-SVAL METHOD-SLOT METHOD-CODE SLOT)))
   (CL:WHEN
    (CL:EQ CODE NULL)
    (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS BOTTOM))
   (CL:CASE
    (METHOD-ARGUMENT-COUNT SLOT)
    (1
     (CL:LET*
      ((FIRSTARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0))))
      (CL:IF
       (CL:NOT (CL:EQ FIRSTARG NULL))
       (CL:RETURN-FROM
        APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS
        (CL:FUNCALL CODE FIRSTARG))
       (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS BOTTOM))))
    (2
     (CL:LET*
      ((FIRSTARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0)))
       (SECONDARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 1))))
      (CL:IF
       (CL:AND (CL:NOT (CL:EQ FIRSTARG NULL)) (CL:NOT (CL:EQ SECONDARG NULL)))
       (CL:RETURN-FROM
        APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS
        (CL:FUNCALL CODE FIRSTARG SECONDARG))
       (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS BOTTOM))))
    (3
     (CL:LET*
      ((FIRSTARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0)))
       (SECONDARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 1)))
       (THIRDARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 2))))
      (CL:IF
       (CL:AND
        (CL:NOT (CL:EQ FIRSTARG NULL))
        (CL:NOT (CL:EQ SECONDARG NULL))
        (CL:NOT (CL:EQ THIRDARG NULL)))
       (CL:RETURN-FROM
        APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS
        (CL:FUNCALL CODE FIRSTARG SECONDARG THIRDARG))
       (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS BOTTOM))))
    (4
     (CL:LET*
      ((FIRSTARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0)))
       (SECONDARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 1)))
       (THIRDARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 2)))
       (FOURTHARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 3))))
      (CL:IF
       (CL:AND
        (CL:NOT (CL:EQ FIRSTARG NULL))
        (CL:NOT (CL:EQ SECONDARG NULL))
        (CL:NOT (CL:EQ THIRDARG NULL))
        (CL:NOT (CL:EQ FOURTHARG NULL)))
       (CL:RETURN-FROM
        APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS
        (CL:FUNCALL CODE FIRSTARG SECONDARG THIRDARG FOURTHARG))
       (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS BOTTOM))))
    (5
     (CL:LET*
      ((FIRSTARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0)))
       (SECONDARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 1)))
       (THIRDARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 2)))
       (FOURTHARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 3)))
       (FIFTHARG
        (NATIVE-ARGUMENT-BOUND-TO
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 4))))
      (CL:IF
       (CL:AND
        (CL:NOT (CL:EQ FIRSTARG NULL))
        (CL:NOT (CL:EQ SECONDARG NULL))
        (CL:NOT (CL:EQ THIRDARG NULL))
        (CL:NOT (CL:EQ FOURTHARG NULL))
        (CL:NOT (CL:EQ FIFTHARG NULL)))
       (CL:RETURN-FROM
        APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS
        (CL:FUNCALL CODE FIRSTARG SECONDARG THIRDARG FOURTHARG FIFTHARG))
       (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS BOTTOM))))
    (CL:OTHERWISE
     (CL:WARN "Too many arguments in predication.  Max 5.  Slot is `~A'" SLOT)
     (CL:RETURN-FROM APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS BOTTOM))))
  :VOID)

;;; (DEFSPECIAL *REVERSEPOLARITY?* ...)

(CL:DEFVAR *REVERSEPOLARITY?* FALSE
  "Signals atomic proposition provers that polarity is negative.")

(CL:DEFUN READ-*REVERSEPOLARITY?* ()
  (CL:RETURN-FROM READ-*REVERSEPOLARITY?* *REVERSEPOLARITY?*)
  :VOID)

(CL:DEFUN WRITE-*REVERSEPOLARITY?* (VALUE)
  (CL:SETQ *REVERSEPOLARITY?* VALUE)
  (CL:RETURN-FROM WRITE-*REVERSEPOLARITY?* VALUE)
  :VOID)

;;; (DEFUN (CONTINUE-ATOMIC-PROPOSITION-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-ATOMIC-PROPOSITION-PROOF (FRAME LASTMOVE)
  (CL:LET*
   ((*REVERSEPOLARITY?* (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? FRAME)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (CL:LET*
    ((PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME)) (RESULT NULL))
    (CL:WHEN
     (CL:AND
      (CL:EQ *REVERSEPOLARITY?* 1)
      (CL:EQ (ALL-ARGUMENTS-BOUND? PROPOSITION) 0))
     (CL:RETURN-FROM CONTINUE-ATOMIC-PROPOSITION-PROOF KWD-QUERY-FAILURE))
    (CL:SETQ RESULT (ACCESS-GOAL-CACHE FRAME))
    (CL:WHEN
     (CL:NOT (CL:EQ RESULT NULL))
     (CL:RETURN-FROM CONTINUE-ATOMIC-PROPOSITION-PROOF RESULT))
    (CL:LET*
     ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND PROPOSITION)))
     (CL:COND
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-FUNCTION)
       (CL:SETQ
        RESULT
        (CONTINUE-FUNCTION-PROPOSITION-PROOF PROPOSITION FRAME)))
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-IN)
       (CL:SETQ RESULT (CONTINUE-IN-PROPOSITION-PROOF PROPOSITION FRAME)))
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-PREDICATE)
       (CL:SETQ
        RESULT
        (CONTINUE-PREDICATE-PROPOSITION-PROOF PROPOSITION FRAME)))
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-EQUIVALENT)
       (CL:SETQ
        RESULT
        (CONTINUE-EQUIVALENT-PROPOSITION-PROOF PROPOSITION FRAME)))
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-IMPLIES)
       (CL:SETQ
        RESULT
        (CONTINUE-IMPLIES-PROPOSITION-PROOF PROPOSITION FRAME LASTMOVE)))
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-CONSTANT)
       (CL:SETQ
        RESULT
        (CONTINUE-CONSTANT-PROPOSITION-PROOF PROPOSITION FRAME)))
      (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))
    (CL:IF
     (CL:AND
      (CL:EQ *REVERSEPOLARITY?* 1)
      (CL:EQ RESULT KWD-QUERY-CONTINUING-SUCCESS))
     (CL:RETURN-FROM
      CONTINUE-ATOMIC-PROPOSITION-PROOF
      KWD-QUERY-FINAL-SUCCESS)
     (CL:RETURN-FROM CONTINUE-ATOMIC-PROPOSITION-PROOF RESULT))))
  :VOID)

;;; (DEFUN (ALL-ARGUMENTS-BOUND? BOOLEAN) ...)

(CL:DEFUN ALL-ARGUMENTS-BOUND? (GOAL)
  (CL:LET*
   ((ARG NULL)
    (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))
    (INDEX-001 0)
    (LENGTH-001 (LENGTH VECTOR-001)))
   (CL:LOOP
    WHILE
    (CL:< INDEX-001 LENGTH-001)
    DO
    (CL:PROGN
     (CL:SETQ
      ARG
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
    (CL:LET*
     ((ARG-001 ARG))
     (CL:COND
      ((CL:EQ (TAXONOMY-ISA? ARG SGT-QUERY-PATTERN-VARIABLE) 1)
       (CL:LET*
        ((ARG NULL))
        (CL:SETQ ARG ARG-001)
        (CL:WHEN
         (CL:EQ (BOUND-TO ARG) NULL)
         (CL:RETURN-FROM ALL-ARGUMENTS-BOUND? FALSE))))
      ((CL:EQ (TAXONOMY-ISA? ARG SGT-QUERY-PROPOSITION) 1)
       (CL:LET*
        ((ARG NULL))
        (CL:SETQ ARG ARG-001)
        (CL:WHEN
         (CL:EQ (ALL-ARGUMENTS-BOUND? ARG) 0)
         (CL:RETURN-FROM ALL-ARGUMENTS-BOUND? FALSE))))
      (CL:T NULL)))))
  (CL:RETURN-FROM ALL-ARGUMENTS-BOUND? TRUE)
  :VOID)

;;; (DEFUN (FIND-SPECIALIZING-FUNCTION-PROPOSITION-VALUE OBJECT) ...)

(CL:DEFUN FIND-SPECIALIZING-FUNCTION-PROPOSITION-VALUE (SELF)
  (CL:LET*
   ((LOGICARGUMENT (FIND-LOGIC-OBJECT-BOUND-TO-ARGUMENT SELF)))
   (CL:WHEN
    (CL:NOT (CL:EQ LOGICARGUMENT NULL))
    (CL:IF
     (CL:EQ (ATTRIBUTE-PROPOSITION? SELF) 1)
     (CL:LET*
      ((PROP NULL)
       (ITER-001
        (ALL-DEPENDENT-ATTRIBUTE-PROPOSITIONS
         LOGICARGUMENT
         KWD-QUERY-FUNCTION)))
      (CL:LOOP
       WHILE
       (CL:EQ (NEXT? ITER-001) 1)
       DO
       (CL:PROGN
        (CL:SETQ
         PROP
         (CAST (CLSYS-SVAL ITERATOR VALUE ITER-001) SGT-QUERY-PROPOSITION)))
       (CL:WHEN
        (CL:EQ (SPECIALIZES-ATTRIBUTE-PROPOSITION? PROP SELF) 1)
        (CL:RETURN-FROM
         FIND-SPECIALIZING-FUNCTION-PROPOSITION-VALUE
         (VALUE-OF (LAST-ARGUMENT PROP))))))
     (CL:LET*
      ((PROP NULL)
       (ITER-002
        (ALL-DIRECTLY-DEPENDENT-PROPOSITIONS
         LOGICARGUMENT
         KWD-QUERY-FUNCTION)))
      (CL:LOOP
       WHILE
       (CL:EQ (NEXT? ITER-002) 1)
       DO
       (CL:PROGN (CL:SETQ PROP (CLSYS-SVAL ITERATOR VALUE ITER-002)))
       (CL:WHEN
        (CL:EQ
         (SPECIALIZES-PREDICATE-PROPOSITION?
          (CAST PROP SGT-QUERY-PROPOSITION)
          SELF)
         1)
        (CL:RETURN-FROM
         FIND-SPECIALIZING-FUNCTION-PROPOSITION-VALUE
         (VALUE-OF (LAST-ARGUMENT (CAST PROP SGT-QUERY-PROPOSITION)))))))))
   (CL:RETURN-FROM FIND-SPECIALIZING-FUNCTION-PROPOSITION-VALUE NULL))
  :VOID)

;;; (DEFUN (QUERY-FOR-ASSERTED-FUNCTION-PROPOSITION-VALUE OBJECT) ...)

(CL:DEFUN QUERY-FOR-ASSERTED-FUNCTION-PROPOSITION-VALUE (SELF)
  (CL:LET*
   ((VALUE NULL))
   (CL:SETQ VALUE (FIND-SPECIALIZING-FUNCTION-PROPOSITION-VALUE SELF))
   (CL:WHEN
    (CL:NOT (CL:EQ VALUE NULL))
    (CL:RETURN-FROM QUERY-FOR-ASSERTED-FUNCTION-PROPOSITION-VALUE VALUE))
   (CL:LET*
    ((SLOT (OPERATOR-BOUND-TO (CLSYS-SVAL PROPOSITION OPERATOR SELF))))
    (CL:WHEN
     (CL:EQ SLOT NULL)
     (CL:RETURN-FROM QUERY-FOR-ASSERTED-FUNCTION-PROPOSITION-VALUE NULL))
    (CL:SETQ
     VALUE
     (APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS
      SLOT
      (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))))
   (CL:IF
    (CL:EQ (BOTTOM? VALUE) 1)
    (CL:RETURN-FROM QUERY-FOR-ASSERTED-FUNCTION-PROPOSITION-VALUE NULL)
    (CL:RETURN-FROM QUERY-FOR-ASSERTED-FUNCTION-PROPOSITION-VALUE VALUE)))
  :VOID)

;;; (DEFUN (MANUFACTURE-DEFINING-SKOLEM KEYWORD) ...)

(CL:DEFUN MANUFACTURE-DEFINING-SKOLEM (SLOT GOALPROPOSITION)
  (CL:LET*
   ((ARGUMENTVALUES NIL))
   (CL:LET*
    ((ARG NULL)
     (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS GOALPROPOSITION))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       ARG
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:SETQ ARGUMENTVALUES (CONS (ARGUMENT-BOUND-TO ARG) ARGUMENTVALUES))))
   (CL:LET*
    ((TEST-VALUE-001 FALSE))
    (CL:IF
     (CL:NOT (CL:EQ (FIRST ARGUMENTVALUES) NULL))
     (CL:SETQ TEST-VALUE-001 TRUE)
     (CL:LET*
      ((FOUND?-001 FALSE))
      (CL:LET*
       ((VALUE NULL) (ITER-001 (CLSYS-SVAL CONS REST ARGUMENTVALUES)))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ VALUE (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:WHEN (CL:EQ VALUE NULL) (CL:SETQ FOUND?-001 TRUE) (CL:RETURN))))
      (CL:SETQ TEST-VALUE-001 FOUND?-001)))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:RETURN-FROM MANUFACTURE-DEFINING-SKOLEM KWD-QUERY-FAILURE)))
   (CL:LET*
    ((INPUTVALUES (REVERSE (CLSYS-SVAL CONS REST ARGUMENTVALUES)))
     (DEFININGPROPOSITION
      (CREATE-FUNCTION-PROPOSITION
       (CLSYS-SVAL SLOT SLOT-SLOTREF SLOT)
       INPUTVALUES)))
    (BIND-VARIABLE-TO-VALUE?
     (CAST (LAST-ARGUMENT GOALPROPOSITION) SGT-QUERY-PATTERN-VARIABLE)
     (LAST-ARGUMENT DEFININGPROPOSITION)
     TRUE)
    (CL:RETURN-FROM MANUFACTURE-DEFINING-SKOLEM KWD-QUERY-FINAL-SUCCESS)))
  :VOID)

;;; (DEFUN (CONTINUE-FUNCTION-PROPOSITION-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-FUNCTION-PROPOSITION-PROOF (SELF FRAME)
  (CL:LET*
   ((FIRSTOCCURRENCE? (NULL? (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)))
    (SINGLEVALUEDBINDINGS? FALSE))
   (CL:WHEN
    (CL:EQ FIRSTOCCURRENCE? 1)
    (CL:LET*
     ((SLOT (OPERATOR-BOUND-TO (CLSYS-SVAL PROPOSITION OPERATOR SELF))))
     (CL:WHEN
      (CL:EQ SLOT NULL)
      (CL:RETURN-FROM CONTINUE-FUNCTION-PROPOSITION-PROOF KWD-QUERY-FAILURE))
     (CL:LET*
      ((VALUE
        (APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS
         SLOT
         (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))))
      (CL:WHEN
       (CL:EQ (BOTTOM? VALUE) 0)
       (CL:LET*
        ((SUCCESSFULBINDING?
          (BIND-VARIABLE-TO-VALUE?
           (CAST (LAST-ARGUMENT SELF) SGT-QUERY-PATTERN-VARIABLE)
           VALUE
           TRUE)))
        (CL:IF
         (CL:EQ *REVERSEPOLARITY?* 1)
         (CL:RETURN-FROM
          CONTINUE-FUNCTION-PROPOSITION-PROOF
          (CL:IF
           (CL:EQ SUCCESSFULBINDING? 1)
           KWD-QUERY-FAILURE
           KWD-QUERY-FINAL-SUCCESS))
         (CL:RETURN-FROM
          CONTINUE-FUNCTION-PROPOSITION-PROOF
          (CL:IF
           (CL:EQ SUCCESSFULBINDING? 1)
           KWD-QUERY-FINAL-SUCCESS
           KWD-QUERY-FAILURE)))))))
    (CL:SETF
     (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
     (ALL-SPECIALIZING-PROPOSITIONS SELF))
    (CL:SETQ
     SINGLEVALUEDBINDINGS?
     (ARGUMENT-BOUND? (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)))))
   (CL:WHEN
    (CL:EQ (NEXT? (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)) 1)
    (CL:IF
     (CL:EQ SINGLEVALUEDBINDINGS? 1)
     (CL:RETURN-FROM
      CONTINUE-FUNCTION-PROPOSITION-PROOF
      KWD-QUERY-FINAL-SUCCESS)
     (CL:RETURN-FROM
      CONTINUE-FUNCTION-PROPOSITION-PROOF
      KWD-QUERY-CONTINUING-SUCCESS))))
  (CL:WHEN
   (CL:EQ *REVERSEPOLARITY?* 1)
   (CL:LET*
    ((CLASHITERATOR (ALL-CLASHING-PROPOSITIONS SELF)))
    (CL:LET*
     ((*REVERSEPOLARITY?* FALSE))
     (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
     (CL:WHEN
      (CL:EQ (NEXT? CLASHITERATOR) 1)
      (FREE CLASHITERATOR)
      (CL:RETURN-FROM
       CONTINUE-FUNCTION-PROPOSITION-PROOF
       KWD-QUERY-FINAL-SUCCESS))
     (FREE CLASHITERATOR))))
  (CL:LET*
   ((SLOT (OPERATOR-BOUND-TO (CLSYS-SVAL PROPOSITION OPERATOR SELF)))
    (DESCRIPTION (DYNAMIC-SLOT-VALUE SLOT SYM-QUERY-DESCRIPTION NULL)))
   (CL:WHEN
    (CL:AND (CL:EQ (TOTAL? SLOT) 1) (CL:EQ *REVERSEPOLARITY?* 0))
    (CL:LET*
     ((RESULT (MANUFACTURE-DEFINING-SKOLEM SLOT SELF)))
     (CL:WHEN
      (CL:EQ RESULT KWD-QUERY-FINAL-SUCCESS)
      (CL:RETURN-FROM CONTINUE-FUNCTION-PROPOSITION-PROOF RESULT))))
   (CL:COND
    ((CL:NOT (CL:EQ DESCRIPTION NULL))
     (CL:RETURN-FROM
      CONTINUE-FUNCTION-PROPOSITION-PROOF
      (OVERLAY-WITH-SUBGOALS-FRAME
       FRAME
       DESCRIPTION
       (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)
       FALSE
       KWD-QUERY-ALL-SUBGOAL-PHASES)))
    (CL:T
     (CL:RETURN-FROM CONTINUE-FUNCTION-PROPOSITION-PROOF KWD-QUERY-FAILURE))))
  :VOID)

;;; (DEFUN (CONTINUE-PREDICATE-PROPOSITION-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-PREDICATE-PROPOSITION-PROOF (SELF FRAME)
  (CL:LET*
   ((ALLARGSBOUNDFIRSTTIME? FALSE))
   (CL:WHEN
    (CL:EQ (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME) NULL)
    (CL:LET*
     ((SLOT (OPERATOR-BOUND-TO (CLSYS-SVAL PROPOSITION OPERATOR SELF))))
     (CL:WHEN
      (CL:EQ SLOT NULL)
      (CL:RETURN-FROM CONTINUE-PREDICATE-PROPOSITION-PROOF KWD-QUERY-FAILURE))
     (CL:LET*
      ((VALUE
        (APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS
         SLOT
         (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))))
      (CL:WHEN
       (CL:EQ (BOTTOM? VALUE) 0)
       (CL:IF
        (CL:EQ *REVERSEPOLARITY?* 1)
        (CL:RETURN-FROM
         CONTINUE-PREDICATE-PROPOSITION-PROOF
         (CL:IF
          (CL:EQ (EQL? VALUE FALSE-WRAPPER) 1)
          KWD-QUERY-FINAL-SUCCESS
          KWD-QUERY-FAILURE))
        (CL:RETURN-FROM
         CONTINUE-PREDICATE-PROPOSITION-PROOF
         (CL:IF
          (CL:EQ (EQL? VALUE TRUE-WRAPPER) 1)
          KWD-QUERY-FINAL-SUCCESS
          KWD-QUERY-FAILURE))))))
    (CL:SETF
     (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
     (ALL-SPECIALIZING-PROPOSITIONS SELF))
    (CL:SETQ ALLARGSBOUNDFIRSTTIME? (ALL-ARGUMENTS-BOUND? SELF)))
   (CL:WHEN
    (CL:EQ (NEXT? (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)) 1)
    (CL:IF
     (CL:EQ ALLARGSBOUNDFIRSTTIME? 1)
     (CL:RETURN-FROM
      CONTINUE-PREDICATE-PROPOSITION-PROOF
      KWD-QUERY-FINAL-SUCCESS)
     (CL:RETURN-FROM
      CONTINUE-PREDICATE-PROPOSITION-PROOF
      KWD-QUERY-CONTINUING-SUCCESS)))
   (CL:LET*
    ((DESCRIPTION
      (DYNAMIC-SLOT-VALUE
       (CAST
        (CLSYS-SVAL
         SURROGATE
         SURROGATE-VALUE
         (CAST (CLSYS-SVAL PROPOSITION OPERATOR SELF) SGT-QUERY-SLOTREF))
        SGT-QUERY-SLOT)
       SYM-QUERY-DESCRIPTION
       NULL)))
    (CL:IF
     (CL:NOT (CL:EQ DESCRIPTION NULL))
     (CL:RETURN-FROM
      CONTINUE-PREDICATE-PROPOSITION-PROOF
      (OVERLAY-WITH-SUBGOALS-FRAME
       FRAME
       DESCRIPTION
       (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)
       FALSE
       KWD-QUERY-ALL-SUBGOAL-PHASES))
     (CL:RETURN-FROM CONTINUE-PREDICATE-PROPOSITION-PROOF KWD-QUERY-FAILURE))))
  :VOID)

;;; (DEFUN (CONTINUE-EQUIVALENT-PROPOSITION-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-EQUIVALENT-PROPOSITION-PROOF (SELF FRAME)
  (CL:SETQ FRAME FRAME)
  (CL:LET*
   ((ARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
    (FIRSTARG (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0))
    (FIRSTVALUE (ARGUMENT-BOUND-TO FIRSTARG))
    (SECONDARG (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 1))
    (SECONDVALUE (ARGUMENT-BOUND-TO SECONDARG))
    (SUCCESS? FALSE))
   (CL:WHEN
    (CL:EQ *REVERSEPOLARITY?* 1)
    (CL:RETURN-FROM
     CONTINUE-EQUIVALENT-PROPOSITION-PROOF
     (CL:IF
      (CL:EQ (EQL? FIRSTVALUE SECONDVALUE) 1)
      KWD-QUERY-FAILURE
      KWD-QUERY-FINAL-SUCCESS)))
   (CL:IF
    (CL:NOT (CL:EQ FIRSTVALUE NULL))
    (CL:IF
     (CL:NOT (CL:EQ SECONDVALUE NULL))
     (CL:SETQ SUCCESS? (EQL? FIRSTVALUE SECONDVALUE))
     (CL:SETQ
      SUCCESS?
      (BIND-VARIABLE-TO-VALUE?
       (CAST SECONDARG SGT-QUERY-PATTERN-VARIABLE)
       FIRSTVALUE
       TRUE)))
    (CL:IF
     (CL:NOT (CL:EQ SECONDVALUE NULL))
     (CL:SETQ
      SUCCESS?
      (BIND-VARIABLE-TO-VALUE?
       (CAST FIRSTARG SGT-QUERY-PATTERN-VARIABLE)
       SECONDVALUE
       TRUE))
     (CL:SETQ SUCCESS? FALSE)))
   (CL:RETURN-FROM
    CONTINUE-EQUIVALENT-PROPOSITION-PROOF
    (CL:IF (CL:EQ SUCCESS? 1) KWD-QUERY-FINAL-SUCCESS KWD-QUERY-FAILURE)))
  :VOID)

;;; (DEFUN (CONTINUE-IN-PROPOSITION-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-IN-PROPOSITION-PROOF (SELF FRAME)
  (CL:LET*
   ((ARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
    (MEMBERARG (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0))
    (COLLECTION NULL))
   (CL:LOOP
    (CL:LET*
     ((TEST-VALUE-001 (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)))
     (CL:COND
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-INITIAL)
       (CL:LET*
        ((MEMBER (ARGUMENT-BOUND-TO MEMBERARG)))
        (CL:SETQ
         COLLECTION
         (ARGUMENT-BOUND-TO
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 1)))
        (CL:WHEN
         (CL:EQ COLLECTION NULL)
         (CL:ERROR
          "Safety violation: INTERNAL ERROR: Bug in query optimizer: Unbound collection variable `~A' encountered during query evaluation."
          (CL:AREF
           (CLSYS-SVAL
            VECTOR
            THE-ARRAY
            (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
           1)))
        (CL:IF
         (CL:NOT (CL:EQ MEMBER NULL))
         (CL:LET*
          ((RESULT (COLLECTION-HAS-MEMBER COLLECTION MEMBER)))
          (CL:IF
           (CL:NOT (CL:EQ RESULT NULL))
           (CL:RETURN-FROM CONTINUE-IN-PROPOSITION-PROOF RESULT)
           (CL:SETF
            (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
            KWD-QUERY-SUBGOALS-OVERLAY)))
         (CL:PROGN
          (CL:SETF
           (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
           (COLLECTION-MEMBERS COLLECTION KWD-QUERY-OPEN))
          (CL:IF
           (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME) NULL))
           (CL:SETF
            (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
            KWD-QUERY-SCAN-COLLECTION)
           (CL:SETF
            (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
            KWD-QUERY-SUBGOALS-OVERLAY))))))
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-SCAN-COLLECTION)
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)) 1)
        DO
        (CL:WHEN
         (CL:EQ
          (BIND-VARIABLE-TO-VALUE?
           (CAST MEMBERARG SGT-QUERY-PATTERN-VARIABLE)
           (VALUE-OF
            (CLSYS-SVAL
             ITERATOR
             VALUE
             (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)))
           TRUE)
          1)
         (CL:RETURN-FROM
          CONTINUE-IN-PROPOSITION-PROOF
          KWD-QUERY-CONTINUING-SUCCESS)))
       (FREE (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME))
       (CL:SETF
        (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
        KWD-QUERY-SUBGOALS-OVERLAY))
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-SUBGOALS-OVERLAY)
       (CL:WHEN
        (CL:EQ COLLECTION NULL)
        (CL:SETQ
         COLLECTION
         (ARGUMENT-BOUND-TO
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 1))))
       (CL:IF
        (CL:EQ (INFERRABLE-DESCRIPTION? COLLECTION) 1)
        (CL:RETURN-FROM
         CONTINUE-IN-PROPOSITION-PROOF
         (OVERLAY-WITH-SUBGOALS-FRAME
          FRAME
          (CAST COLLECTION SGT-QUERY-DESCRIPTION)
          ARGUMENTS
          TRUE
          KWD-QUERY-ALL-SUBGOAL-PHASES))
        (CL:RETURN-FROM CONTINUE-IN-PROPOSITION-PROOF KWD-QUERY-FAILURE)))
      (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))))
  :VOID)

;;; (DEFUN (INFERRABLE-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN INFERRABLE-DESCRIPTION? (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-DESCRIPTION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:AND
        (CL:EQ *REVERSEPOLARITY?* 1)
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE SELF SYM-QUERY-COMPLEMENT-DESCRIPTION NULL)
          NULL)))
       (CL:SETQ
        SELF
        (DYNAMIC-SLOT-VALUE SELF SYM-QUERY-COMPLEMENT-DESCRIPTION NULL)))
      (CL:LET*
       ((TEST-VALUE-001 FALSE))
       (CL:IF
        (CL:EQ (PRIMITIVE? SELF) 0)
        (CL:SETQ TEST-VALUE-001 TRUE)
        (CL:LET*
         ((FOUND?-001 FALSE))
         (CL:LET*
          ((P NULL)
           (ITER-001
            (CLSYS-SVAL
             LIST
             THE-CONS-LIST
             (CLSYS-SVAL DESCRIPTION DEPENDENT-PROPOSITIONS SELF))))
          (CL:LOOP
           WHILE
           (CL:NOT (CL:EQ ITER-001 NIL))
           DO
           (CL:PROGN
            (CL:SETQ
             P
             (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-QUERY-PROPOSITION))
            (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
           (CL:WHEN
            (CL:AND
             (CL:EQ (CLSYS-SVAL PROPOSITION KIND P) KWD-QUERY-IMPLIES)
             (CL:EQ
              SELF
              (CL:AREF
               (CLSYS-SVAL
                VECTOR
                THE-ARRAY
                (CLSYS-SVAL PROPOSITION ARGUMENTS P))
               1)))
            (CL:SETQ FOUND?-001 TRUE)
            (CL:RETURN))))
         (CL:SETQ TEST-VALUE-001 FOUND?-001)))
       (CL:LET*
        ((VALUE-001 TEST-VALUE-001))
        (CL:RETURN-FROM INFERRABLE-DESCRIPTION? VALUE-001)))))
    (CL:T (CL:RETURN-FROM INFERRABLE-DESCRIPTION? FALSE))))
  :VOID)

;;; (DEFUN (UNNAMED-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN UNNAMED-DESCRIPTION? (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-DESCRIPTION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       UNNAMED-DESCRIPTION?
       (NULL? (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF)))))
    (CL:T (CL:RETURN-FROM UNNAMED-DESCRIPTION? FALSE))))
  :VOID)

;;; (DEFUN (CONTINUE-IMPLIES-PROPOSITION-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-IMPLIES-PROPOSITION-PROOF (SELF FRAME LASTMOVE)
  (CL:LET*
   ((SUBCOLLECTIONARG (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)))
    (SUPERCOLLECTIONARG (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS SELF)))
    (SUBCOLLECTION NULL)
    (SUPERCOLLECTION NULL))
   (CL:LOOP
    (CL:LET*
     ((TEST-VALUE-001 (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)))
     (CL:COND
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-INITIAL)
       (CL:SETQ SUBCOLLECTION (ARGUMENT-BOUND-TO SUBCOLLECTIONARG))
       (CL:SETQ SUPERCOLLECTION (ARGUMENT-BOUND-TO SUPERCOLLECTIONARG))
       (CL:COND
        ((CL:EQ SUBCOLLECTION NULL)
         (CL:WHEN
          (CL:EQ SUPERCOLLECTION NULL)
          (CL:WHEN
           (CL:NOT
            (CL:AND
             (CL:NOT (CL:EQ SUBCOLLECTION NULL))
             (CL:NOT (CL:EQ SUPERCOLLECTION NULL))))
           (CL:ERROR
            "Safety violation: INTERNAL ERROR: Bug in query optimizer: two unbound :IMPLIES arguments.")))
         (CL:SETF
          (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
          (ALL-SUBCOLLECTIONS (CAST SUPERCOLLECTION SGT-QUERY-LOGIC-OBJECT)))
         (CL:SETF
          (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
          KWD-QUERY-SCAN-SUBCOLLECTIONS))
        ((CL:EQ SUPERCOLLECTION NULL)
         (CL:SETF
          (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
          (ALL-SUPERCOLLECTIONS (CAST SUBCOLLECTION SGT-QUERY-LOGIC-OBJECT)))
         (CL:SETF
          (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
          KWD-QUERY-SCAN-SUPERCOLLECTIONS))
        (CL:T
         (CL:WHEN
          (CL:AND
           (CL:EQ (UNNAMED-DESCRIPTION? SUBCOLLECTION) 0)
           (CL:EQ (UNNAMED-DESCRIPTION? SUPERCOLLECTION) 0)
           (CL:EQ
            (COLLECTION-IMPLIES-COLLECTION? SUBCOLLECTION SUPERCOLLECTION)
            1))
          (CL:RETURN-FROM
           CONTINUE-IMPLIES-PROPOSITION-PROOF
           KWD-QUERY-FINAL-SUCCESS))
         (CL:WHEN
          (CL:AND
           (CL:EQ (INFERRABLE-DESCRIPTION? SUBCOLLECTION) 0)
           (CL:EQ (INFERRABLE-DESCRIPTION? SUPERCOLLECTION) 0))
          (CL:RETURN-FROM
           CONTINUE-IMPLIES-PROPOSITION-PROOF
           (COLLECTION-CONTAINED-IN-COLLECTION
            SUBCOLLECTION
            SUPERCOLLECTION)))
         (CL:IF
          (CL:EQ (CLOSED-COLLECTION? SUBCOLLECTION) 1)
          (CL:SETF
           (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
           KWD-QUERY-DO-CONTAINED-BY)
          (CL:SETF
           (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
           KWD-QUERY-SUBSUMPTION-OVERLAY)))))
      ((CL:OR
        (CL:EQ TEST-VALUE-001 KWD-QUERY-SCAN-SUBCOLLECTIONS)
        (CL:EQ TEST-VALUE-001 KWD-QUERY-SCAN-SUPERCOLLECTIONS))
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)) 1)
        DO
        (CL:WHEN
         (CL:EQ
          (BIND-VARIABLE-TO-VALUE?
           (CAST
            (CL:IF
             (CL:EQ
              (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
              KWD-QUERY-SCAN-SUBCOLLECTIONS)
             SUPERCOLLECTIONARG
             SUBCOLLECTIONARG)
            SGT-QUERY-PATTERN-VARIABLE)
           (VALUE-OF
            (CLSYS-SVAL
             ITERATOR
             VALUE
             (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)))
           TRUE)
          1)
         (CL:RETURN-FROM
          CONTINUE-IMPLIES-PROPOSITION-PROOF
          KWD-QUERY-CONTINUING-SUCCESS)))
       (FREE (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME))
       (CL:RETURN-FROM CONTINUE-IMPLIES-PROPOSITION-PROOF KWD-QUERY-FAILURE))
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-DO-CONTAINED-BY)
       (CL:COND
        ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
         (CL:RETURN-FROM
          CONTINUE-IMPLIES-PROPOSITION-PROOF
          (SPAWN-CONTAINED-BY-SUBQUERY FRAME SUBCOLLECTION SUPERCOLLECTION)))
        ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
         (CL:RETURN-FROM
          CONTINUE-IMPLIES-PROPOSITION-PROOF
          KWD-QUERY-FINAL-SUCCESS))
        ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
         (CL:SETF
          (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
          KWD-QUERY-SUBSUMPTION-OVERLAY))
        (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE))))
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-SUBSUMPTION-OVERLAY)
       (CL:WHEN
        (CL:EQ SUBCOLLECTION NULL)
        (CL:SETQ SUBCOLLECTION (ARGUMENT-BOUND-TO SUBCOLLECTIONARG))
        (CL:SETQ SUPERCOLLECTION (ARGUMENT-BOUND-TO SUPERCOLLECTIONARG)))
       (CL:IF
        (CL:AND
         (CL:EQ (ISA? SUBCOLLECTION SGT-QUERY-DESCRIPTION) 1)
         (CL:EQ (ISA? SUPERCOLLECTION SGT-QUERY-DESCRIPTION) 1)
         (CL:EQ
          (DESCRIPTION-SPECIALIZES-DESCRIPTION?
           (CAST SUBCOLLECTION SGT-QUERY-DESCRIPTION)
           (CAST SUPERCOLLECTION SGT-QUERY-DESCRIPTION))
          1))
        (CL:RETURN-FROM
         CONTINUE-IMPLIES-PROPOSITION-PROOF
         KWD-QUERY-FINAL-SUCCESS)
        (CL:RETURN-FROM
         CONTINUE-IMPLIES-PROPOSITION-PROOF
         KWD-QUERY-FAILURE)))
      (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))))
  :VOID)

;;; (DEFUN (SPAWN-CONTAINED-BY-SUBQUERY KEYWORD) ...)

(CL:DEFUN SPAWN-CONTAINED-BY-SUBQUERY (UPFRAME TAIL HEAD)
  (CL:LET*
   ((PROPOSITION (CREATE-PROPOSITION SYM-QUERY-CONTAINED-BY 2))
    (ARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
    (DESCRIPTION
     (CL:IF
      (CL:EQ (ISA? TAIL SGT-QUERY-DESCRIPTION) 1)
      (CAST TAIL SGT-QUERY-DESCRIPTION)
      (CAST HEAD SGT-QUERY-DESCRIPTION)))
    (ARITY (ARITY DESCRIPTION))
    (BRIDGEARGUMENTS (NEW-LIST))
    (CONTAINEDBYFRAME (CREATE-DOWN-FRAME UPFRAME PROPOSITION)))
   (CL:LET*
    ((VBL NULL)
     (I NULL)
     (ITER-001 0)
     (VECTOR-001 (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:PROGN
      (CL:SETQ
       VBL
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
        SGT-QUERY-PATTERN-VARIABLE))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:LET*
      ((BRIDGEVBL (NEW-PATTERN-VARIABLE)))
      (CL:SETF (CLSYS-SVAL PATTERN-VARIABLE BOUND-TO-OFFSET BRIDGEVBL) I)
      (SET-DYNAMIC-SLOT-VALUE
       BRIDGEVBL
       SYM-QUERY-SKOLEM-NAME
       (DYNAMIC-SLOT-VALUE VBL SYM-QUERY-SKOLEM-NAME NULL)
       NULL)
      (CL:SETF
       (CLSYS-SVAL PATTERN-VARIABLE ROOT-TYPE BRIDGEVBL)
       (CLSYS-SVAL PATTERN-VARIABLE ROOT-TYPE VBL))
      (INSERT-LAST BRIDGEARGUMENTS BRIDGEVBL))))
   (CL:SETF
    (CLSYS-SVAL CONTROL-FRAME STATE CONTAINEDBYFRAME)
    KWD-QUERY-CONTAINED-BY)
   (CL:SETF
    (CLSYS-SVAL CONTROL-FRAME PROPOSITION CONTAINEDBYFRAME)
    PROPOSITION)
   (CL:SETF
    (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0)
    (CREATE-CONTAINED-BY-ARGUMENT TAIL BRIDGEARGUMENTS FALSE))
   (CL:SETF
    (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 1)
    (CREATE-CONTAINED-BY-ARGUMENT HEAD BRIDGEARGUMENTS TRUE))
   (CL:SETF
    (CLSYS-SVAL CONTROL-FRAME ITERATOR CONTAINEDBYFRAME)
    (ALLOCATE-SUBQUERY-FRAME NULL NULL))
   (CL:SETF
    (CLSYS-SVAL
     SUBQUERY-FRAME
     CONTROL-FRAME
     (CAST
      (CLSYS-SVAL CONTROL-FRAME ITERATOR CONTAINEDBYFRAME)
      SGT-QUERY-SUBQUERY-FRAME))
    CONTAINEDBYFRAME)
   (ALLOCATE-BLOCK-OF-VARIABLE-FRAMES ARITY CONTAINEDBYFRAME)
   (CL:RETURN-FROM SPAWN-CONTAINED-BY-SUBQUERY KWD-QUERY-SPAWNED-SUBQUERY))
  :VOID)

;;; (DEFUN (CREATE-CONTAINED-BY-ARGUMENT PROPOSITION) ...)

(CL:DEFUN CREATE-CONTAINED-BY-ARGUMENT (COLLECTION BRIDGEARGS LASTCALL?)
  (CL:LET*
   ((INPROPOSITION (CREATE-PROPOSITION SYM-QUERY-IN 2))
    (ARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS INPROPOSITION)))
   (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 1) COLLECTION)
   (CL:IF
    (CL:AND
     (CL:EQ (ISA? COLLECTION SGT-QUERY-DESCRIPTION) 1)
     (CL:> (ARITY (CAST COLLECTION SGT-QUERY-DESCRIPTION)) 1))
    (CL:SETF (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0) BRIDGEARGS)
    (CL:PROGN
     (CL:SETF
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) 0)
      (FIRST BRIDGEARGS))
     (CL:WHEN (CL:EQ LASTCALL? 1) (FREE BRIDGEARGS))))
   (CL:RETURN-FROM CREATE-CONTAINED-BY-ARGUMENT INPROPOSITION))
  :VOID)

;;; (DEFUN (CONTINUE-CONSTANT-PROPOSITION-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-CONSTANT-PROPOSITION-PROOF (SELF FRAME)
  (CL:SETQ FRAME FRAME)
  (CL:IF
   (CL:EQ *REVERSEPOLARITY?* 1)
   (CL:IF
    (CL:EQ (FALSE? SELF) 1)
    (CL:RETURN-FROM
     CONTINUE-CONSTANT-PROPOSITION-PROOF
     KWD-QUERY-FINAL-SUCCESS)
    (CL:RETURN-FROM CONTINUE-CONSTANT-PROPOSITION-PROOF KWD-QUERY-FAILURE))
   (CL:IF
    (CL:EQ (TRUE? SELF) 1)
    (CL:RETURN-FROM
     CONTINUE-CONSTANT-PROPOSITION-PROOF
     KWD-QUERY-FINAL-SUCCESS)
    (CL:RETURN-FROM CONTINUE-CONSTANT-PROPOSITION-PROOF KWD-QUERY-FAILURE)))
  :VOID)

;;; (DEFUN (OVERLAY-WITH-PATTERN-FRAME KEYWORD) ...)

(CL:DEFUN OVERLAY-WITH-PATTERN-FRAME (FRAME DESCRIPTION)
  (CL:LET*
   ((SUBQUERYFRAME
     (CAST
      (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
      SGT-QUERY-SUBQUERY-FRAME))
    (EXTERNALARGUMENTS
     (CLSYS-SVAL SUBQUERY-FRAME EXTERNAL-ARGUMENTS SUBQUERYFRAME))
    (OPTIMALPATTERN
     (SELECT-OPTIMAL-QUERY-PATTERN
      DESCRIPTION
      (CLSYS-SVAL SUBQUERY-FRAME BOOLEAN-VECTOR SUBQUERYFRAME)
      FRAME))
    (EXTERNALBINDINGS NIL))
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME STATE FRAME) KWD-QUERY-PATTERN)
   (CL:SETF
    (CLSYS-SVAL SUBQUERY-FRAME OPTIMAL-PATTERN SUBQUERYFRAME)
    OPTIMALPATTERN)
   (CL:SETF
    (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME)
    (CLSYS-SVAL DESCRIPTION PROPOSITION OPTIMALPATTERN))
   (CL:LET*
    ((ARG NULL)
     (VECTOR-001 EXTERNALARGUMENTS)
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       ARG
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (CONS (ARGUMENT-BOUND-TO ARG) NIL))
       (CL:IF
        (CL:EQ EXTERNALBINDINGS NIL)
        (CL:SETQ EXTERNALBINDINGS COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST EXTERNALBINDINGS COLLECT-001)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-001)
        (CONS (ARGUMENT-BOUND-TO ARG) NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:LET*
    ((VARIABLESCOUNT
      (CL:+
       (LENGTH (CLSYS-SVAL DESCRIPTION IO-VARIABLES OPTIMALPATTERN))
       (LENGTH (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES OPTIMALPATTERN)))))
    (ALLOCATE-BLOCK-OF-VARIABLE-FRAMES VARIABLESCOUNT FRAME))
   (CL:LET*
    ((EXTBINDING NULL)
     (IOVAR NULL)
     (VECTOR-002 (CLSYS-SVAL DESCRIPTION IO-VARIABLES OPTIMALPATTERN))
     (INDEX-002 0)
     (LENGTH-002 (LENGTH VECTOR-002))
     (ITER-001 EXTERNALBINDINGS))
    (CL:LOOP
     WHILE
     (CL:AND (CL:< INDEX-002 LENGTH-002) (CL:NOT (CL:EQ ITER-001 NIL)))
     DO
     (CL:PROGN
      (CL:SETQ
       IOVAR
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002)
        SGT-QUERY-PATTERN-VARIABLE))
      (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
     (CL:PROGN
      (CL:SETQ EXTBINDING (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:AND
       (CL:NOT (CL:EQ EXTBINDING NULL))
       (CL:EQ (BIND-VARIABLE-TO-VALUE? IOVAR EXTBINDING FALSE) 0))
      (CL:RETURN-FROM OVERLAY-WITH-PATTERN-FRAME KWD-QUERY-FAILED-OVERLAY))))
   (FREE-CONS-LIST EXTERNALBINDINGS)
   (CL:LET*
    ((INTERNALVAR NULL)
     (VECTOR-003 (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES OPTIMALPATTERN))
     (INDEX-003 0)
     (LENGTH-003 (LENGTH VECTOR-003)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-003 LENGTH-003)
     DO
     (CL:PROGN
      (CL:SETQ
       INTERNALVAR
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-003) INDEX-003)
        SGT-QUERY-PATTERN-VARIABLE))
      (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))
     (CL:WHEN
      (CL:EQ FALSE 1)
      (CL:WHEN
       (CL:EQ
        (BIND-VARIABLE-TO-VALUE?
         INTERNALVAR
         (VALUE-OF (BINDING-TO-CONSTANT INTERNALVAR))
         FALSE)
        0)
       (CL:RETURN-FROM OVERLAY-WITH-PATTERN-FRAME KWD-QUERY-FAILURE)))))
   (CL:WHEN
    (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN FRAME) NULL)
    (CREATE-DOWN-FRAME
     FRAME
     (CLSYS-SVAL DESCRIPTION PROPOSITION OPTIMALPATTERN)))
   (CL:RETURN-FROM OVERLAY-WITH-PATTERN-FRAME KWD-QUERY-OVERLAY))
  :VOID)

;;; (DEFUN (TRANSFER-PATTERN-QUERY-BINDINGS? BOOLEAN) ...)

(CL:DEFUN TRANSFER-PATTERN-QUERY-BINDINGS? (FRAME FUTUREBINDINGS?)
  (CL:WHEN
   (CL:AND
    (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS) 1))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "TRANSFER-pattern-query-bindings?: " %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM)))
  (CL:LET*
   ((SUBQUERYFRAME
     (CAST
      (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
      SGT-QUERY-SUBQUERY-FRAME))
    (BOOLEANVECTOR (CLSYS-SVAL SUBQUERY-FRAME BOOLEAN-VECTOR SUBQUERYFRAME))
    (EXTERNALARGUMENTS
     (CLSYS-SVAL SUBQUERY-FRAME EXTERNAL-ARGUMENTS SUBQUERYFRAME))
    (IOVARIABLES
     (CLSYS-SVAL
      DESCRIPTION
      IO-VARIABLES
      (CLSYS-SVAL SUBQUERY-FRAME OPTIMAL-PATTERN SUBQUERYFRAME)))
    (LASTINDEX (CL:1- (LENGTH BOOLEANVECTOR)))
    (IOVARIABLEVALUES NIL)
    (TOPUNBINDINGOFFSET NULL-INTEGER))
   (CL:LET*
    ((I NULL)
     (ITER-001 0)
     (UPPER-BOUND-001 LASTINDEX)
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-001))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ
        COLLECT-001
        (CONS
         (CL:IF
          (CL:EQ
           (CLSYS-SVAL
            BOOLEAN-WRAPPER
            WRAPPER-VALUE
            (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY BOOLEANVECTOR) I))
           0)
          (BOUND-TO (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY IOVARIABLES) I))
          NULL)
         NIL))
       (CL:IF
        (CL:EQ IOVARIABLEVALUES NIL)
        (CL:SETQ IOVARIABLEVALUES COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST IOVARIABLEVALUES COLLECT-001)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-001)
        (CONS
         (CL:IF
          (CL:EQ
           (CLSYS-SVAL
            BOOLEAN-WRAPPER
            WRAPPER-VALUE
            (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY BOOLEANVECTOR) I))
           0)
          (BOUND-TO (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY IOVARIABLES) I))
          NULL)
         NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:WHEN (CL:EQ FUTUREBINDINGS? 0) (UNBIND-PATTERN-VARIABLES FRAME))
   (RESET-CURRENT-VARIABLE-FRAME-OFFSET FRAME KWD-QUERY-PARENT)
   (CL:SETQ
    TOPUNBINDINGOFFSET
    (CLSYS-SVAL
     QUERY-ENVIRONMENT
     TOP-UNBINDING-STACK-OFFSET
     *QUERYENVIRONMENT*))
   (CL:LET*
    ((INITIALLYBOUND? NULL)
     (EXTERNALARG NULL)
     (VALUE NULL)
     (ITER-002 IOVARIABLEVALUES)
     (VECTOR-001 EXTERNALARGUMENTS)
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001))
     (VECTOR-002 BOOLEANVECTOR)
     (INDEX-002 0)
     (LENGTH-002 (LENGTH VECTOR-002)))
    (CL:LOOP
     WHILE
     (CL:AND
      (CL:NOT (CL:EQ ITER-002 NIL))
      (CL:< INDEX-001 LENGTH-001)
      (CL:< INDEX-002 LENGTH-002))
     DO
     (CL:PROGN
      (CL:SETQ VALUE (CLSYS-SVAL CONS VALUE ITER-002))
      (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
     (CL:PROGN
      (CL:SETQ
       EXTERNALARG
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:PROGN
      (CL:SETQ
       INITIALLYBOUND?
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
      (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
     (CL:WHEN
      (CL:EQ (CLSYS-SVAL BOOLEAN-WRAPPER WRAPPER-VALUE INITIALLYBOUND?) 0)
      (CL:WHEN
       (CL:EQ (BIND-ARGUMENT-TO-VALUE? EXTERNALARG VALUE FALSE) 0)
       (CL:WHEN
        (CL:AND
         (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
         (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-QUERY-STACKS) 1))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING "TRANSFER FAILS! " %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)))
       (UNBIND-VARIABLES-BEGINNING-AT (CL:1+ TOPUNBINDINGOFFSET))
       (FREE-CONS-LIST IOVARIABLEVALUES)
       (CL:WHEN
        (CL:EQ FUTUREBINDINGS? 1)
        (RESET-CURRENT-VARIABLE-FRAME-OFFSET FRAME KWD-QUERY-LOCAL))
       (CL:RETURN-FROM TRANSFER-PATTERN-QUERY-BINDINGS? FALSE)))))
   (FREE-CONS-LIST IOVARIABLEVALUES)
   (CL:RETURN-FROM TRANSFER-PATTERN-QUERY-BINDINGS? TRUE))
  :VOID)

;;; (DEFUN (ALLOCATE-ANTECEDENTS-ITERATOR (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALLOCATE-ANTECEDENTS-ITERATOR (SUBQUERYFRAME REVERSEPOLARITY?)
  (CL:LET*
   ((GOALDESCRIPTION (CLSYS-SVAL SUBQUERY-FRAME DESCRIPTION SUBQUERYFRAME))
    (EXTERNALARGUMENTS
     (CLSYS-SVAL SUBQUERY-FRAME EXTERNAL-ARGUMENTS SUBQUERYFRAME))
    (ANTECEDENTS NIL)
    (ANTECEDENTDESCRIPTION NULL)
    (FAILSTYPECHECK? FALSE))
   (CL:WHEN
    (CL:AND
     (CL:NOT
      (CL:EQ (CLSYS-SVAL DESCRIPTION NATIVE-RELATION GOALDESCRIPTION) NULL))
     (CL:EQ
      (SORT? (CLSYS-SVAL DESCRIPTION NATIVE-RELATION GOALDESCRIPTION))
      1))
    (CL:RETURN-FROM ALLOCATE-ANTECEDENTS-ITERATOR NULL))
   (CL:LET*
    ((PROP NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL DESCRIPTION DEPENDENT-PROPOSITIONS GOALDESCRIPTION))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       PROP
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-QUERY-PROPOSITION))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:AND
       (CL:EQ (CLSYS-SVAL PROPOSITION KIND PROP) KWD-QUERY-IMPLIES)
       (CL:EQ
        (CL:IF
         (CL:EQ REVERSEPOLARITY? 1)
         (EQ? (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS PROP)) GOALDESCRIPTION)
         (EQ?
          (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS PROP))
          GOALDESCRIPTION))
        1)
       (CL:EQ (TRUE? PROP) 1))
      (CL:SETQ
       ANTECEDENTDESCRIPTION
       (CAST
        (CL:IF
         (CL:EQ REVERSEPOLARITY? 1)
         (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS PROP))
         (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS PROP)))
        SGT-QUERY-DESCRIPTION))
      (CL:SETQ FAILSTYPECHECK? FALSE)
      (CL:LET*
       ((ARG NULL)
        (V NULL)
        (VECTOR-001
         (CLSYS-SVAL DESCRIPTION IO-VARIABLES ANTECEDENTDESCRIPTION))
        (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001))
        (VECTOR-002 EXTERNALARGUMENTS)
        (INDEX-002 0)
        (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:LOOP
        WHILE
        (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:< INDEX-002 LENGTH-002))
        DO
        (CL:PROGN
         (CL:SETQ
          V
          (CAST
           (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
           SGT-QUERY-PATTERN-VARIABLE))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
        (CL:PROGN
         (CL:SETQ
          ARG
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
         (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
        (CL:LET*
         ((VALUE (ARGUMENT-BOUND-TO ARG)))
         (CL:WHEN
          (CL:AND
           (CL:NOT (CL:EQ VALUE NULL))
           (CL:EQ (FAILS-TYPE-CHECK? V VALUE) 1))
          (CL:SETQ FAILSTYPECHECK? TRUE)
          (CL:RETURN)))))
      (CL:WHEN
       (CL:EQ FAILSTYPECHECK? 0)
       (CL:SETQ ANTECEDENTS (CONS PROP ANTECEDENTS))))))
   (CL:IF
    (CL:EQ ANTECEDENTS NIL)
    (CL:RETURN-FROM ALLOCATE-ANTECEDENTS-ITERATOR NULL)
    (CL:RETURN-FROM
     ALLOCATE-ANTECEDENTS-ITERATOR
     (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR ANTECEDENTS))))
  :VOID)

;;; (DEFUN (CONTINUE-SUBGOALS-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-SUBGOALS-PROOF (FRAME)
  (CL:LET*
   ((SUBQUERYFRAME
     (CAST
      (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
      SGT-QUERY-SUBQUERY-FRAME))
    (DESCRIPTION (CLSYS-SVAL SUBQUERY-FRAME DESCRIPTION SUBQUERYFRAME))
    (REVERSEPOLARITY? (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? FRAME)))
   (CL:LOOP
    (CL:LET*
     ((TEST-VALUE-001 (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)))
     (CL:COND
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-INITIAL)
       (CL:WHEN
        (CL:AND
         (CL:EQ REVERSEPOLARITY? 1)
         (CL:NOT
          (CL:EQ
           (DYNAMIC-SLOT-VALUE
            DESCRIPTION
            SYM-QUERY-COMPLEMENT-DESCRIPTION
            NULL)
           NULL)))
        (CL:LET*
         ((COMPLEMENT
           (DYNAMIC-SLOT-VALUE
            DESCRIPTION
            SYM-QUERY-COMPLEMENT-DESCRIPTION
            NULL)))
         (CL:SETF (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? FRAME) FALSE)
         (CL:SETF (CLSYS-SVAL CONTROL-FRAME PHASE FRAME) KWD-QUERY-COMPLEMENT)
         (CL:RETURN-FROM
          CONTINUE-SUBGOALS-PROOF
          (SPAWN-SUBQUERY
           FRAME
           COMPLEMENT
           (CL:IF
            (CL:EQ (PRIMITIVE? COMPLEMENT) 1)
            KWD-QUERY-SKIP-DEFINITION
            KWD-QUERY-ALL-SUBGOAL-PHASES)
           FALSE))))
       (CL:SETF
        (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
        KWD-QUERY-PRE-ANTECEDENTS))
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-COMPLEMENT)
       (CL:SETF (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? FRAME) TRUE)
       (CL:SETF
        (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
        KWD-QUERY-PRE-ANTECEDENTS))
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-PRE-ANTECEDENTS)
       (CL:LET*
        ((ITERATOR
          (ALLOCATE-ANTECEDENTS-ITERATOR SUBQUERYFRAME REVERSEPOLARITY?)))
        (CL:IF
         (CL:NOT (CL:EQ ITERATOR NULL))
         (CL:PROGN
          (CL:SETF
           (CLSYS-SVAL SUBQUERY-FRAME ITERATOR SUBQUERYFRAME)
           ITERATOR)
          (CL:SETF
           (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
           KWD-QUERY-ANTECEDENTS))
         (CL:LET*
          ((TEST-VALUE-002
            (CLSYS-SVAL SUBQUERY-FRAME PHASES-FILTER SUBQUERYFRAME)))
          (CL:COND
           ((CL:EQ TEST-VALUE-002 KWD-QUERY-ALL-SUBGOAL-PHASES)
            (CL:SETF
             (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
             KWD-QUERY-DEFINITION))
           ((CL:EQ TEST-VALUE-002 KWD-QUERY-SKIP-DEFINITION)
            (CL:RETURN-FROM CONTINUE-SUBGOALS-PROOF KWD-QUERY-FAILURE))
           (CL:T
            (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-002)))))))
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-ANTECEDENTS)
       (CL:LET*
        ((ITERATOR (CLSYS-SVAL SUBQUERY-FRAME ITERATOR SUBQUERYFRAME))
         (IMPLIESPROPOSITION NULL)
         (ANTECEDENTDESCRIPTION NULL))
        (CL:WHEN
         (CL:EQ (NEXT? ITERATOR) 1)
         (CL:SETQ IMPLIESPROPOSITION (CLSYS-SVAL ITERATOR VALUE ITERATOR))
         (CL:SETQ
          ANTECEDENTDESCRIPTION
          (CAST
           (CL:IF
            (CL:EQ REVERSEPOLARITY? 1)
            (SECOND (CLSYS-SVAL PROPOSITION ARGUMENTS IMPLIESPROPOSITION))
            (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS IMPLIESPROPOSITION)))
           SGT-QUERY-DESCRIPTION))
         (CL:RETURN-FROM
          CONTINUE-SUBGOALS-PROOF
          (SPAWN-SUBQUERY
           FRAME
           ANTECEDENTDESCRIPTION
           (CL:IF
            (CL:EQ (SUBRELATION-LINK? IMPLIESPROPOSITION) 1)
            KWD-QUERY-SKIP-DEFINITION
            KWD-QUERY-FULL-SUBQUERY)
           FALSE)))
        (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME ITERATOR SUBQUERYFRAME) NULL)
        (FREE ITERATOR)
        (CL:LET*
         ((TEST-VALUE-003
           (CLSYS-SVAL SUBQUERY-FRAME PHASES-FILTER SUBQUERYFRAME)))
         (CL:COND
          ((CL:EQ TEST-VALUE-003 KWD-QUERY-ALL-SUBGOAL-PHASES)
           (CL:SETF
            (CLSYS-SVAL CONTROL-FRAME PHASE FRAME)
            KWD-QUERY-DEFINITION))
          ((CL:EQ TEST-VALUE-003 KWD-QUERY-SKIP-DEFINITION)
           (CL:RETURN-FROM CONTINUE-SUBGOALS-PROOF KWD-QUERY-FAILURE))
          (CL:T
           (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-003))))))
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-DEFINITION)
       (CL:LET*
        ((RELATION (CLSYS-SVAL DESCRIPTION NATIVE-RELATION DESCRIPTION))
         (DEFINITION
          (CL:IF
           (CL:NOT (CL:EQ RELATION NULL))
           (DYNAMIC-SLOT-VALUE RELATION SYM-QUERY-DEFINITION NULL)
           DESCRIPTION)))
        (CL:IF
         (CL:NOT (CL:EQ DEFINITION NULL))
         (CL:RETURN-FROM
          CONTINUE-SUBGOALS-PROOF
          (SPAWN-SUBQUERY FRAME DEFINITION NULL TRUE))
         (CL:RETURN-FROM CONTINUE-SUBGOALS-PROOF KWD-QUERY-FAILURE))))
      (CL:T (CL:ERROR "`~A' is not a valid case option" TEST-VALUE-001))))))
  :VOID)

;;; (DEFUN (NEW-TOP-SUBQUERY-FRAME SUBQUERY-FRAME) ...)

(CL:DEFUN NEW-TOP-SUBQUERY-FRAME ()
  (CL:RETURN-FROM NEW-TOP-SUBQUERY-FRAME (NEW-SUBQUERY-FRAME))
  :VOID)

;;; (DEFUN (ALLOCATE-SUBQUERY-FRAME SUBQUERY-FRAME) ...)

(CL:DEFUN ALLOCATE-SUBQUERY-FRAME (DESCRIPTION EXTERNALARGUMENTS)
  (CL:LET*
   ((SUBQUERYFRAME (NEW-TOP-SUBQUERY-FRAME)))
   (CL:WHEN
    (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:SETF
     (CLSYS-SVAL SUBQUERY-FRAME DESCRIPTION SUBQUERYFRAME)
     DESCRIPTION)
    (CL:SETF
     (CLSYS-SVAL SUBQUERY-FRAME EXTERNAL-ARGUMENTS SUBQUERYFRAME)
     EXTERNALARGUMENTS)
    (CL:SETF
     (CLSYS-SVAL SUBQUERY-FRAME BOOLEAN-VECTOR SUBQUERYFRAME)
     (ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR EXTERNALARGUMENTS)))
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-SUBQUERY-FRAME *QUERYENVIRONMENT*)
    SUBQUERYFRAME)
   (CL:RETURN-FROM ALLOCATE-SUBQUERY-FRAME SUBQUERYFRAME))
  :VOID)

;;; (DEFUN (TERMINATE-SUBQUERY-FRAME? BOOLEAN) ...)

(CL:DEFUN TERMINATE-SUBQUERY-FRAME? (SELF)
  (CL:WHEN
   (CL:AND
    (CL:EQ
     (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-SUBQUERY-FRAME *QUERYENVIRONMENT*)
     SELF)
    (CL:NOT
     (CL:EQ
      (CLSYS-SVAL
       CONTROL-FRAME
       PARENT-PATTERN-FRAME
       (CLSYS-SVAL SUBQUERY-FRAME CONTROL-FRAME SELF))
      NULL)))
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-SUBQUERY-FRAME *QUERYENVIRONMENT*)
    (CAST
     (CLSYS-SVAL
      CONTROL-FRAME
      ITERATOR
      (CLSYS-SVAL
       CONTROL-FRAME
       PARENT-PATTERN-FRAME
       (CLSYS-SVAL SUBQUERY-FRAME CONTROL-FRAME SELF)))
     SGT-QUERY-SUBQUERY-FRAME)))
  (CL:WHEN
   (CL:NOT (CL:EQ (CLSYS-SVAL SUBQUERY-FRAME EXTERNAL-ARGUMENTS SELF) NULL))
   (FREE (CLSYS-SVAL SUBQUERY-FRAME EXTERNAL-ARGUMENTS SELF)))
  (CL:WHEN
   (CL:NOT (CL:EQ (CLSYS-SVAL SUBQUERY-FRAME ITERATOR SELF) NULL))
   (FREE (CLSYS-SVAL SUBQUERY-FRAME ITERATOR SELF)))
  (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME ITERATOR SELF) NULL)
  (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME OPTIMAL-PATTERN SELF) NULL)
  (CL:RETURN-FROM TERMINATE-SUBQUERY-FRAME? TRUE)
  :VOID)

;;; (DEFUN (COPY-SUBQUERY-ARGUMENTS ARGUMENTS-VECTOR) ...)

(CL:DEFUN COPY-SUBQUERY-ARGUMENTS (ARGUMENTS OMITLASTARGUMENT? DESCRIPTION)
  (CL:IF
   (CL:AND
    (CL:EQ OMITLASTARGUMENT? 1)
    (CL:> (ARITY DESCRIPTION) 1)
    (CL:EQ (ISA? (FIRST ARGUMENTS) SGT-QUERY-LIST) 1))
   (CL:LET*
    ((TUPLE (CAST (FIRST ARGUMENTS) SGT-QUERY-LIST))
     (COPIEDARGUMENTS (NEW-VECTOR (LENGTH TUPLE))))
    (CL:LET*
     ((VALUE NULL)
      (I NULL)
      (ITER-001 0)
      (UPPER-BOUND-001 (CL:1- (LENGTH TUPLE)))
      (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST TUPLE)))
     (CL:LOOP
      WHILE
      (CL:AND (CL:<= ITER-001 UPPER-BOUND-001) (CL:NOT (CL:EQ ITER-002 NIL)))
      DO
      (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
      (CL:PROGN
       (CL:SETQ VALUE (CLSYS-SVAL CONS VALUE ITER-002))
       (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
      (CL:SETF
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY COPIEDARGUMENTS) I)
       VALUE)))
    (CL:RETURN-FROM COPY-SUBQUERY-ARGUMENTS COPIEDARGUMENTS))
   (CL:LET*
    ((ARGUMENTCOUNT
      (CL:IF
       (CL:EQ OMITLASTARGUMENT? 1)
       (CL:1- (LENGTH ARGUMENTS))
       (LENGTH ARGUMENTS)))
     (COPIEDARGUMENTS (NEW-VECTOR ARGUMENTCOUNT)))
    (CL:LET*
     ((I NULL) (ITER-003 0) (UPPER-BOUND-002 (CL:1- ARGUMENTCOUNT)))
     (CL:LOOP
      WHILE
      (CL:<= ITER-003 UPPER-BOUND-002)
      DO
      (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
      (CL:SETF
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY COPIEDARGUMENTS) I)
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY ARGUMENTS) I))))
    (CL:RETURN-FROM COPY-SUBQUERY-ARGUMENTS COPIEDARGUMENTS)))
  :VOID)

;;; (DEFUN (OVERLAY-WITH-SUBGOALS-FRAME KEYWORD) ...)

(CL:DEFUN OVERLAY-WITH-SUBGOALS-FRAME (FRAME DESCRIPTION EXTERNALARGUMENTS OMITLASTARGUMENT? PHASESFILTER)
  (CL:WHEN
   (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME) NULL))
   (FREE (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)))
  (CL:SETF (CLSYS-SVAL CONTROL-FRAME STATE FRAME) KWD-QUERY-SUBGOALS)
  (CL:SETF (CLSYS-SVAL CONTROL-FRAME PHASE FRAME) KWD-QUERY-INITIAL)
  (CL:LET*
   ((SUBQUERYFRAME
     (ALLOCATE-SUBQUERY-FRAME
      DESCRIPTION
      (COPY-SUBQUERY-ARGUMENTS
       EXTERNALARGUMENTS
       OMITLASTARGUMENT?
       DESCRIPTION))))
   (CL:SETF (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME) SUBQUERYFRAME)
   (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME CONTROL-FRAME SUBQUERYFRAME) FRAME)
   (CL:SETF
    (CLSYS-SVAL SUBQUERY-FRAME PHASES-FILTER SUBQUERYFRAME)
    PHASESFILTER)
   (CL:SETF
    (CLSYS-SVAL SUBQUERY-FRAME LOCAL-VARIABLE-FRAME-OFFSET SUBQUERYFRAME)
    (CLSYS-SVAL
     SUBQUERY-FRAME
     LOCAL-VARIABLE-FRAME-OFFSET
     (CAST
      (CLSYS-SVAL
       CONTROL-FRAME
       ITERATOR
       (CLSYS-SVAL CONTROL-FRAME PARENT-PATTERN-FRAME FRAME))
      SGT-QUERY-SUBQUERY-FRAME))))
  (CL:RETURN-FROM OVERLAY-WITH-SUBGOALS-FRAME KWD-QUERY-OVERLAY)
  :VOID)

;;; (DEFUN (SPAWN-SUBQUERY KEYWORD) ...)

(CL:DEFUN SPAWN-SUBQUERY (UPFRAME DESCRIPTION PHASESFILTER OVERLAY?)
  (CL:WHEN
   (CL:EQ OVERLAY? 1)
   (CL:RETURN-FROM
    SPAWN-SUBQUERY
    (OVERLAY-WITH-PATTERN-FRAME UPFRAME DESCRIPTION)))
  (CL:LET*
   ((SUBQUERYFRAME
     (CAST
      (CLSYS-SVAL CONTROL-FRAME ITERATOR UPFRAME)
      SGT-QUERY-SUBQUERY-FRAME))
    (EXTERNALARGUMENTS
     (CLSYS-SVAL SUBQUERY-FRAME EXTERNAL-ARGUMENTS SUBQUERYFRAME))
    (DOWNFRAME (CREATE-DOWN-FRAME UPFRAME NULL)))
   (OVERLAY-WITH-SUBGOALS-FRAME
    DOWNFRAME
    DESCRIPTION
    EXTERNALARGUMENTS
    FALSE
    PHASESFILTER)
   (CL:COND
    ((CL:EQ PHASESFILTER KWD-QUERY-FULL-SUBQUERY)
     (CL:RETURN-FROM
      SPAWN-SUBQUERY
      (OVERLAY-WITH-PATTERN-FRAME DOWNFRAME DESCRIPTION)))
    (CL:T (CL:RETURN-FROM SPAWN-SUBQUERY KWD-QUERY-SPAWNED-SUBQUERY))))
  :VOID)

;;; (DEFUN (CONTINUE-DISJUNCTION-PROOF KEYWORD) ...)

(CL:DEFUN CONTINUE-DISJUNCTION-PROOF (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-QUERY-DOWN)
    (CL:WHEN
     (CL:EQ
      (ALL-ARGUMENTS-BOUND? (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
      0)
     (CL:RETURN-FROM CONTINUE-DISJUNCTION-PROOF KWD-QUERY-FAILURE))
    (PUSH-WORLD)
    (SET-DYNAMIC-SLOT-VALUE
     (CAST *CONTEXT* SGT-QUERY-WORLD)
     SYM-QUERY-MONOTONIC?
     (WRAP-BOOLEAN TRUE)
     NULL-BOOLEAN-WRAPPER)
    (CL:LET*
     ((DISJUNCTIVEPROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
      (FIRSTDISJUNCT? TRUE))
     (CL:LET*
      ((DISJUNCT NULL)
       (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS DISJUNCTIVEPROPOSITION))
       (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:LOOP
       WHILE
       (CL:< INDEX-001 LENGTH-001)
       DO
       (CL:PROGN
        (CL:SETQ
         DISJUNCT
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (CL:IF
        (CL:EQ FIRSTDISJUNCT? 1)
        (CL:SETQ FIRSTDISJUNCT? FALSE)
        (CL:LET*
         ((PROP NULL)
          (ITER-001
           (CLSYS-SVAL
            LIST
            THE-CONS-LIST
            (INHERIT-AS-TOP-LEVEL-PROPOSITION
             (CAST DISJUNCT SGT-QUERY-PROPOSITION)))))
         (CL:LOOP
          WHILE
          (CL:NOT (CL:EQ ITER-001 NIL))
          DO
          (CL:PROGN
           (CL:SETQ
            PROP
            (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-QUERY-PROPOSITION))
           (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
          (CL:WHEN
           (CL:AND
            (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
            (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE) 1))
           (CL:LET
            ((%%STREAM
              (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
            (CL:WRITE-STRING "assume that " %%STREAM)
            (PRINT-OBJECT PROP %%STREAM)
            (CL:WRITE-STRING " is FALSE." %%STREAM)
            (CL:TERPRI %%STREAM)
            (CL:FORCE-OUTPUT %%STREAM)))
          (ASSIGN-TRUTH-VALUE PROP FALSE))))))
     (CL:SETF (CLSYS-SVAL CONTROL-FRAME ARGUMENT-CURSOR FRAME) 0)
     (CL:RETURN-FROM CONTINUE-DISJUNCTION-PROOF KWD-QUERY-SUBGOAL)))
   ((CL:EQ LASTMOVE KWD-QUERY-UP-TRUE)
    (POP-WORLD)
    (CL:RETURN-FROM CONTINUE-DISJUNCTION-PROOF KWD-QUERY-FINAL-SUCCESS))
   ((CL:EQ LASTMOVE KWD-QUERY-UP-FAIL)
    (POP-WORLD)
    (CL:RETURN-FROM CONTINUE-DISJUNCTION-PROOF KWD-QUERY-FAILURE))
   (CL:T (CL:ERROR "`~A' is not a valid case option" LASTMOVE)))
  :VOID)

;;; (DEFUN (DISJOINT-CLASSES? BOOLEAN) ...)

(CL:DEFUN DISJOINT-CLASSES? (CLASS1 CLASS2)
  (CL:RETURN-FROM
   DISJOINT-CLASSES?
   (CL:IF
    (CL:AND
     (CL:NOT (CL:EQ CLASS1 CLASS2))
     (CL:EQ (SUBCLASS-OF? CLASS1 CLASS2) 0)
     (CL:EQ (SUBCLASS-OF? CLASS2 CLASS1) 0)
     (CL:OR
      (CL:EQ
       (DYNAMIC-SLOT-VALUE CLASS1 SYM-QUERY-NON-DISJOINTNESS-KLUDGE? NULL)
       NULL)
      (CL:EQ
       (DYNAMIC-SLOT-VALUE CLASS2 SYM-QUERY-NON-DISJOINTNESS-KLUDGE? NULL)
       NULL)))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (ROOT-TYPE-IMPLIES-MEMBER? BOOLEAN) ...)

(CL:DEFUN ROOT-TYPE-IMPLIES-MEMBER? (SELF MEMBER)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-DESCRIPTION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:EQ (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF) NULL)
       (CL:RETURN-FROM ROOT-TYPE-IMPLIES-MEMBER? FALSE))
      (CL:IF
       (CL:EQ *REVERSEPOLARITY?* 1)
       (CL:LET*
        ((ROOTCLASS
          (LEFTMOST-CONCRETE-SUPERCLASS
           (CAST
            (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF)
            SGT-QUERY-CLASS))))
        (CL:RETURN-FROM
         ROOT-TYPE-IMPLIES-MEMBER?
         (DISJOINT-CLASSES?
          (CAST
           (CLSYS-SVAL SURROGATE SURROGATE-VALUE (LOGICAL-TYPE MEMBER))
           SGT-QUERY-CLASS)
          ROOTCLASS)))
       (CL:RETURN-FROM
        ROOT-TYPE-IMPLIES-MEMBER?
        (SUBCLASS-OF?
         (CAST
          (CLSYS-SVAL SURROGATE SURROGATE-VALUE (LOGICAL-TYPE MEMBER))
          SGT-QUERY-CLASS)
         (CAST
          (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF)
          SGT-QUERY-CLASS))))))
    (CL:T (CL:RETURN-FROM ROOT-TYPE-IMPLIES-MEMBER? FALSE))))
  :VOID)

;;; (DEFUN (COLLECTION-HAS-MEMBER KEYWORD) ...)

(CL:DEFUN COLLECTION-HAS-MEMBER (SELF MEMBER)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-LOGIC-OBJECT) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:OR
        (CL:EQ (ROOT-TYPE-IMPLIES-MEMBER? SELF MEMBER) 1)
        (CL:EQ
         (EXISTS-SPECIALIZING-IN-PROPOSITION?
          (CAST MEMBER SGT-QUERY-LOGIC-OBJECT)
          SELF)
         1))
       (CL:RETURN-FROM COLLECTION-HAS-MEMBER KWD-QUERY-FINAL-SUCCESS))
      (CL:WHEN
       (CL:EQ (CLOSED-COLLECTION? SELF) 1)
       (CL:IF
        (CL:EQ *REVERSEPOLARITY?* 1)
        (CL:LET*
         ((*REVERSEPOLARITY?* FALSE))
         (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
         (CL:RETURN-FROM
          COLLECTION-HAS-MEMBER
          (CL:IF
           (CL:EQ
            (EXISTS-SPECIALIZING-IN-PROPOSITION?
             (CAST MEMBER SGT-QUERY-LOGIC-OBJECT)
             SELF)
            1)
           KWD-QUERY-FAILURE
           KWD-QUERY-FINAL-SUCCESS)))
        (CL:RETURN-FROM COLLECTION-HAS-MEMBER KWD-QUERY-FAILURE)))
      (CL:RETURN-FROM COLLECTION-HAS-MEMBER NULL)))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-COLLECTION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((FOUND?-001 FALSE))
       (CL:LET*
        ((M NULL) (ITER-001 (ALLOCATE-ITERATOR SELF)))
        (CL:LOOP
         WHILE
         (CL:EQ (NEXT? ITER-001) 1)
         DO
         (CL:PROGN (CL:SETQ M (CLSYS-SVAL ITERATOR VALUE ITER-001)))
         (CL:WHEN
          (CL:EQ (EQL? (VALUE-OF M) MEMBER) 1)
          (CL:SETQ FOUND?-001 TRUE)
          (CL:RETURN))))
       (CL:LET*
        ((MEMBER? FOUND?-001))
        (CL:IF
         (CL:EQ *REVERSEPOLARITY?* 1)
         (CL:RETURN-FROM
          COLLECTION-HAS-MEMBER
          (CL:IF (CL:EQ MEMBER? 1) KWD-QUERY-FAILURE KWD-QUERY-FINAL-SUCCESS))
         (CL:RETURN-FROM
          COLLECTION-HAS-MEMBER
          (CL:IF
           (CL:EQ MEMBER? 1)
           KWD-QUERY-FINAL-SUCCESS
           KWD-QUERY-FAILURE)))))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" SELF))))
  :VOID)

;;; (DEFGLOBAL *GLOBALLY-CLOSED-COLLECTIONS?* ...)

(CL:DEFVAR *GLOBALLY-CLOSED-COLLECTIONS?* FALSE
  "If TRUE, all collections are assumed to be closed.")

;;; (DEFUN (CLOSED-COLLECTION? BOOLEAN) ...)

(CL:DEFUN CLOSED-COLLECTION? (SELF)
  (CL:WHEN
   (CL:EQ *GLOBALLY-CLOSED-COLLECTIONS?* 1)
   (CL:RETURN-FROM CLOSED-COLLECTION? TRUE))
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-COLLECTION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM CLOSED-COLLECTION? TRUE)))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-LOGIC-OBJECT) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((*REVERSEPOLARITY?* FALSE))
       (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
       (CL:RETURN-FROM
        CLOSED-COLLECTION?
        (EXISTS-PROPERTY-PROPOSITION? SELF SGT-QUERY-COLLECTION.CLOSED)))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" SELF))))
  :VOID)

;;; (DEFUN (COLLECTION-MEMBERS ITERATOR) ...)

(CL:DEFUN COLLECTION-MEMBERS (SELF OPENORCLOSED)
  (CL:WHEN
   (CL:EQ *REVERSEPOLARITY?* 1)
   (CL:COND
    ((CL:EQ OPENORCLOSED KWD-QUERY-OPEN)
     (CL:SETQ OPENORCLOSED KWD-QUERY-CLOSED))
    ((CL:EQ OPENORCLOSED KWD-QUERY-CLOSED)
     (CL:SETQ OPENORCLOSED KWD-QUERY-OPEN))
    (CL:T (CL:ERROR "`~A' is not a valid case option" OPENORCLOSED))))
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-COLLECTION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM COLLECTION-MEMBERS (ALLOCATE-ITERATOR SELF))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-DESCRIPTION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((TEST-VALUE-001 (CLSYS-SVAL DESCRIPTION KIND SELF)))
       (CL:COND
        ((CL:EQ TEST-VALUE-001 KWD-QUERY-PRIMITIVE)
         (CL:WHEN
          (CL:OR
           (CL:EQ OPENORCLOSED KWD-QUERY-OPEN)
           (CL:EQ (CLOSED-COLLECTION? SELF) 1))
          (CL:RETURN-FROM COLLECTION-MEMBERS (ALLOCATE-ITERATOR SELF))))
        ((CL:EQ TEST-VALUE-001 KWD-QUERY-ENUMERATION)
         (CL:RETURN-FROM COLLECTION-MEMBERS (ALLOCATE-ITERATOR SELF)))
        (CL:T (CL:RETURN-FROM COLLECTION-MEMBERS NULL))))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-LOGIC-OBJECT) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:WHEN
       (CL:OR
        (CL:EQ OPENORCLOSED KWD-QUERY-OPEN)
        (CL:EQ (CLOSED-COLLECTION? SELF) 1))
       (CL:RETURN-FROM
        COLLECTION-MEMBERS
        (ALL-IN-PROPOSITION-MEMBERS SELF)))))
    (CL:T (CL:RETURN-FROM COLLECTION-MEMBERS NULL))))
  (CL:RETURN-FROM COLLECTION-MEMBERS NULL)
  :VOID)

;;; (DEFUN (COLLECTION-CONTAINED-IN-COLLECTION KEYWORD) ...)

(CL:DEFUN COLLECTION-CONTAINED-IN-COLLECTION (SUBCOLLECTION SUPERCOLLECTION)
  (CL:LET*
   ((ITERATOR (COLLECTION-MEMBERS SUBCOLLECTION KWD-QUERY-CLOSED)))
   (CL:LET*
    ((TEST-VALUE-001 FALSE))
    (CL:SETQ TEST-VALUE-001 (DEFINED? ITERATOR))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:LET*
      ((ALWAYS?-001 TRUE))
      (CL:LET*
       ((M NULL) (ITER-001 ITERATOR))
       (CL:LOOP
        WHILE
        (CL:EQ (NEXT? ITER-001) 1)
        DO
        (CL:PROGN (CL:SETQ M (CLSYS-SVAL ITERATOR VALUE ITER-001)))
        (CL:WHEN
         (CL:NOT
          (CL:EQ
           (COLLECTION-HAS-MEMBER SUPERCOLLECTION (VALUE-OF M))
           KWD-QUERY-FINAL-SUCCESS))
         (CL:SETQ ALWAYS?-001 FALSE)
         (CL:RETURN))))
      (CL:SETQ TEST-VALUE-001 ALWAYS?-001)))
    (CL:IF
     (CL:EQ TEST-VALUE-001 1)
     (CL:RETURN-FROM
      COLLECTION-CONTAINED-IN-COLLECTION
      KWD-QUERY-FINAL-SUCCESS)
     (CL:RETURN-FROM COLLECTION-CONTAINED-IN-COLLECTION KWD-QUERY-FAILURE))))
  :VOID)

;;; (DEFUN (COLLECTION-IMPLIES-COLLECTION? BOOLEAN) ...)

(CL:DEFUN COLLECTION-IMPLIES-COLLECTION? (SUBCOLLECTION SUPERCOLLECTION)
  (CL:WHEN
   (CL:EQ (EQL? SUBCOLLECTION SUPERCOLLECTION) 1)
   (CL:RETURN-FROM COLLECTION-IMPLIES-COLLECTION? TRUE))
  (CL:IF
   (CL:AND
    (CL:EQ (ISA? SUBCOLLECTION SGT-QUERY-LOGIC-OBJECT) 1)
    (CL:EQ (ISA? SUPERCOLLECTION SGT-QUERY-LOGIC-OBJECT) 1))
   (CL:RETURN-FROM
    COLLECTION-IMPLIES-COLLECTION?
    (MEMBER?
     (ALL-SUPERCOLLECTIONS (CAST SUBCOLLECTION SGT-QUERY-LOGIC-OBJECT))
     SUPERCOLLECTION))
   (CL:RETURN-FROM COLLECTION-IMPLIES-COLLECTION? FALSE))
  :VOID)

;;; (DEFCLASS DESCRIPTION-EXTENSION-ITERATOR ...)

(CL:DEFCLASS DESCRIPTION-EXTENSION-ITERATOR (ITERATOR)
  ((CURSOR :ALLOCATION :INSTANCE :ACCESSOR CURSOR...OF)
   (ROOT-TYPE :ALLOCATION :INSTANCE :ACCESSOR ROOT-TYPE...OF)
   (FILTER-TYPE :ALLOCATION :INSTANCE :ACCESSOR FILTER-TYPE...OF)
   (NATIVE-CLASS-EXTENSION-ITERATOR
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    NATIVE-CLASS-EXTENSION-ITERATOR...OF))
  (:DOCUMENTATION
   "Iterates over the extension of a top-level description,
filtering out deleted objects.  May create logic instances on-the-fly by
wrapping native objects in the extension of the class attached to the
description."))

(CL:DEFUN NEW-DESCRIPTION-EXTENSION-ITERATOR ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE DESCRIPTION-EXTENSION-ITERATOR)))
   (CL:SETF
    (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR FIRST-ITERATION? SELF)
    TRUE)
   (CL:SETF (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR VALUE SELF) NULL)
   (CL:SETF
    (CLSYS-SVAL
     DESCRIPTION-EXTENSION-ITERATOR
     NATIVE-CLASS-EXTENSION-ITERATOR
     SELF)
    NULL)
   (CL:SETF (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR FILTER-TYPE SELF) NULL)
   (CL:SETF (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR ROOT-TYPE SELF) NULL)
   (CL:SETF (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR CURSOR SELF) NULL)
   (CL:RETURN-FROM NEW-DESCRIPTION-EXTENSION-ITERATOR SELF))
  :VOID)

(CL:DEFUN ACCESS-DESCRIPTION-EXTENSION-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-CURSOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR CURSOR SELF)
      (CAST VALUE SGT-QUERY-CONS))
     (CL:RETURN-FROM
      ACCESS-DESCRIPTION-EXTENSION-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR CURSOR SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-ROOT-TYPE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR ROOT-TYPE SELF)
      (CAST VALUE SGT-QUERY-TYPE))
     (CL:RETURN-FROM
      ACCESS-DESCRIPTION-EXTENSION-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR ROOT-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-FILTER-TYPE)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR FILTER-TYPE SELF)
      (CAST VALUE SGT-QUERY-TYPE))
     (CL:RETURN-FROM
      ACCESS-DESCRIPTION-EXTENSION-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR FILTER-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-NATIVE-CLASS-EXTENSION-ITERATOR)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL
       DESCRIPTION-EXTENSION-ITERATOR
       NATIVE-CLASS-EXTENSION-ITERATOR
       SELF)
      (CAST VALUE SGT-QUERY-ITERATOR))
     (CL:RETURN-FROM
      ACCESS-DESCRIPTION-EXTENSION-ITERATOR-SLOT-VALUE
      (CLSYS-SVAL
       DESCRIPTION-EXTENSION-ITERATOR
       NATIVE-CLASS-EXTENSION-ITERATOR
       SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-DESCRIPTION-EXTENSION-ITERATOR-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DESCRIPTION-EXTENSION-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-QUERY-DESCRIPTION-EXTENSION-ITERATOR)
  :VOID)

;;; (DEFMETHOD (ALLOCATE-ITERATOR DESCRIPTION-EXTENSION-ITERATOR) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF DESCRIPTION))
  (CL:LET*
   ((ITERATOR (NEW-DESCRIPTION-EXTENSION-ITERATOR))
    (NATIVECLASS
     (CAST (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF) SGT-QUERY-CLASS))
    (ROOTCLASS (LEFTMOST-CONCRETE-SUPERCLASS NATIVECLASS)))
   (CL:WHEN
    (CL:NOT
     (CL:AND
      (CL:NOT (CL:EQ NATIVECLASS NULL))
      (CL:NOT
       (CL:EQ (CLSYS-SVAL DESCRIPTION KIND SELF) KWD-QUERY-DEFINITION))))
    (CL:ERROR
     "Safety violation: INTERNAL ERROR: Illegal call to `DESCRIPTION.allocate-iterator'."))
   (CL:IF
    (CL:EQ (SUBSUMPTION-MODE?) 1)
    (CL:LET*
     ((DESCRIPTION
       (CLSYS-SVAL
        QUERY-ENVIRONMENT
        SPECIALIZING-DESCRIPTION
        *QUERYENVIRONMENT*))
      (INTERNALVARIABLES NIL))
     (CL:LET*
      ((V NULL)
       (VECTOR-001 (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES DESCRIPTION))
       (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001))
       (COLLECT-001 NULL))
      (CL:LOOP
       WHILE
       (CL:< INDEX-001 LENGTH-001)
       DO
       (CL:PROGN
        (CL:SETQ
         V
         (CAST
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
          SGT-QUERY-PATTERN-VARIABLE))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (CL:IF
        (CL:EQ COLLECT-001 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-001 (CONS V NIL))
         (CL:IF
          (CL:EQ INTERNALVARIABLES NIL)
          (CL:SETQ INTERNALVARIABLES COLLECT-001)
          (ADD-CONS-TO-END-OF-CONS-LIST INTERNALVARIABLES COLLECT-001)))
        (CL:PROGN
         (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS V NIL))
         (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR CURSOR ITERATOR)
      INTERNALVARIABLES)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR ROOT-TYPE ITERATOR)
      NULL))
    (CL:PROGN
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR CURSOR ITERATOR)
      (CLSYS-SVAL LIST THE-CONS-LIST (GET-DESCRIPTION-EXTENSION ROOTCLASS)))
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR ROOT-TYPE ITERATOR)
      (CLSYS-SVAL CLASS CLASS-TYPE ROOTCLASS))))
   (CL:SETF
    (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR FILTER-TYPE ITERATOR)
    (CLSYS-SVAL CLASS CLASS-TYPE NATIVECLASS))
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR))
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF DESCRIPTION-EXTENSION-ITERATOR))
  (CL:LET*
   ((CURSOR (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR CURSOR SELF))
    (TRAILINGCURSOR NULL)
    (VALUE NULL))
   (CL:IF
    (CL:EQ
     (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR FIRST-ITERATION? SELF)
     1)
    (CL:SETF
     (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR FIRST-ITERATION? SELF)
     FALSE)
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ CURSOR NIL))
    DO
    (CL:SETQ VALUE (CLSYS-SVAL CONS VALUE CURSOR))
    (CL:COND
     ((CL:OR
       (CL:EQ (DELETED? VALUE) 1)
       (CL:EQ (INDEXED-BY-LOGICAL-EXTENSIONS? VALUE) 0))
      (CL:WHEN
       (CL:NOT (CL:EQ TRAILINGCURSOR NULL))
       (CL:SETF
        (CLSYS-SVAL CONS REST TRAILINGCURSOR)
        (CLSYS-SVAL CONS REST CURSOR))
       (CL:SETQ CURSOR TRAILINGCURSOR)))
     ((CL:OR
       (CL:EQ
        (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR ROOT-TYPE SELF)
        (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR FILTER-TYPE SELF))
       (CL:EQ
        (EXISTS-SPECIALIZING-IN-PROPOSITION?
         VALUE
         (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR FILTER-TYPE SELF))
        1))
      (CL:SETF (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR VALUE SELF) VALUE)
      (CL:SETF (CLSYS-SVAL DESCRIPTION-EXTENSION-ITERATOR CURSOR SELF) CURSOR)
      (CL:RETURN-FROM NEXT? TRUE)))
    (CL:SETQ TRAILINGCURSOR CURSOR)
    (CL:SETQ CURSOR (CLSYS-SVAL CONS REST CURSOR)))
   (CL:RETURN-FROM NEXT? FALSE))
  :VOID)

;;; (DEFCONSTANT *QUERY-THREAD-LIMIT* ...)

(CL:DEFVAR *QUERY-THREAD-LIMIT* 8
  "Maximum number of simultaneous query threads.")

;;; (DEFGLOBAL *MAXIMUM-QUERY-THREAD-OFFSET* ...)

(CL:DEFVAR *MAXIMUM-QUERY-THREAD-OFFSET* NULL-INTEGER)

;;; (DEFGLOBAL *FREE-QUERY-THREAD-OFFSETS* ...)

(CL:DEFVAR *FREE-QUERY-THREAD-OFFSETS* NULL
  "List of unused query thread offsets.")

;;; (DEFGLOBAL *QUERY-ENVIRONMENTS-VECTOR* ...)

(CL:DEFVAR *QUERY-ENVIRONMENTS-VECTOR* NULL
  "Records currently active (unreleased) query environments.")

;;; (DEFUN RESERVE-QUERY-THREAD ...)

(CL:DEFUN RESERVE-QUERY-THREAD (QUERYENVIRONMENT)
  "Find a free query thread and assign it to 'queryEnvironment'.
Signal a :QUERY-THREAD-LIMIT-VIOLATION exception if all threads are taken."
  (CL:LET*
   ((OFFSET (POP *FREE-QUERY-THREAD-OFFSETS*)))
   (CL:WHEN
    (CL:EQ OFFSET NULL)
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "Releasing all query threads!" %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CLEAR-QUERY-THREADS)
    (RESERVE-QUERY-THREAD QUERYENVIRONMENT)
    (CL:RETURN-FROM RESERVE-QUERY-THREAD)
    (SIGNAL *THE-QUERY-THREAD-LIMIT-VIOLATION*))
   (CL:SETF
    (CL:AREF
     (CLSYS-SVAL VECTOR THE-ARRAY *QUERY-ENVIRONMENTS-VECTOR*)
     (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE OFFSET))
    QUERYENVIRONMENT)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT QUERY-THREAD-OFFSET QUERYENVIRONMENT)
    (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE OFFSET))
   (CL:RETURN-FROM RESERVE-QUERY-THREAD))
  :VOID)

;;; (DEFUN RELEASE-QUERY-THREAD ...)

(CL:DEFUN RELEASE-QUERY-THREAD (QUERYENVIRONMENT)
  "Release the query thread for 'queryEnvironment'."
  (CL:WHEN (CL:EQ QUERYENVIRONMENT NULL) (CL:RETURN-FROM RELEASE-QUERY-THREAD))
  (CL:LET*
   ((OFFSET
     (CLSYS-SVAL QUERY-ENVIRONMENT QUERY-THREAD-OFFSET QUERYENVIRONMENT)))
   (CL:SETF
    (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY *QUERY-ENVIRONMENTS-VECTOR*) OFFSET)
    NULL)
   (PUSH *FREE-QUERY-THREAD-OFFSETS* (WRAP-LITERAL OFFSET)))
  :VOID)

;;; (DEFUN (RELEASE-ALL-QUERY-THREADS (LIST OF INTEGER-WRAPPER)) ...)

(CL:DEFUN RELEASE-ALL-QUERY-THREADS ()
  "Free up all query threads (buggy queries may have
failed to terminate)."
  (CL:LET*
   ((OFFSET NULL)
    (ITER-001 0)
    (UPPER-BOUND-001 *MAXIMUM-QUERY-THREAD-OFFSET*)
    (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
   (CL:LOOP
    WHILE
    (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
    DO
    (CL:PROGN (CL:SETQ OFFSET ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "off" %%STREAM)
     (CL:PRINC OFFSET %%STREAM)
     (CL:WRITE-STRING " mm " %%STREAM)
     (PRINT-OBJECT
      (CL:AREF
       (CLSYS-SVAL VECTOR THE-ARRAY *QUERY-ENVIRONMENTS-VECTOR*)
       OFFSET)
      %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (CL:AREF
        (CLSYS-SVAL VECTOR THE-ARRAY *QUERY-ENVIRONMENTS-VECTOR*)
        OFFSET)
       NULL))
     (FREE-QUERY-ITERATOR
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       QUERY-ITERATOR
       (CL:AREF
        (CLSYS-SVAL VECTOR THE-ARRAY *QUERY-ENVIRONMENTS-VECTOR*)
        OFFSET))))))
  (CL:RETURN-FROM RELEASE-ALL-QUERY-THREADS *FREE-QUERY-THREAD-OFFSETS*)
  :VOID)

;;; (DEFUN (CLEAR-QUERY-THREADS (LIST OF INTEGER-WRAPPER)) ...)

(CL:DEFUN CLEAR-QUERY-THREADS ()
  (CL:LET*
   ((OFFSET NULL)
    (ITER-001 0)
    (UPPER-BOUND-001 *MAXIMUM-QUERY-THREAD-OFFSET*)
    (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
   (CL:LOOP
    WHILE
    (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
    DO
    (CL:PROGN (CL:SETQ OFFSET ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
    (CL:SETF
     (CL:AREF
      (CLSYS-SVAL VECTOR THE-ARRAY *QUERY-ENVIRONMENTS-VECTOR*)
      OFFSET)
     NULL)
    (INSERT-NEW *FREE-QUERY-THREAD-OFFSETS* (WRAP-LITERAL OFFSET))))
  (CL:RETURN-FROM CLEAR-QUERY-THREADS *FREE-QUERY-THREAD-OFFSETS*)
  :VOID)

;;; (DEFCLASS GOAL-CACHE ...)

(CL:DEFCLASS GOAL-CACHE (STANDARD-OBJECT)
  ((CACHED-BINDINGS :ALLOCATION :INSTANCE :ACCESSOR CACHED-BINDINGS...OF)
   (REVERSE-POLARITY-CACHED-BINDINGS
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    REVERSE-POLARITY-CACHED-BINDINGS...OF)
   (UP-FOR-GRABS? :ALLOCATION :INSTANCE :ACCESSOR UP-FOR-GRABS?...OF)
   (CLUSTER :ALLOCATION :INSTANCE :ACCESSOR CLUSTER...OF))
  (:DOCUMENTATION
   "Cache of output bindings derived for a particular goal
and set of input bindings."))

(CL:DEFUN NEW-GOAL-CACHE ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE GOAL-CACHE)))
   (CL:SETF (CLSYS-SVAL GOAL-CACHE CLUSTER SELF) NULL)
   (CL:SETF (CLSYS-SVAL GOAL-CACHE UP-FOR-GRABS? SELF) FALSE)
   (CL:SETF
    (CLSYS-SVAL GOAL-CACHE REVERSE-POLARITY-CACHED-BINDINGS SELF)
    (NEW-LIST))
   (CL:SETF (CLSYS-SVAL GOAL-CACHE CACHED-BINDINGS SELF) (NEW-LIST))
   (CL:RETURN-FROM NEW-GOAL-CACHE SELF))
  :VOID)

(CL:DEFUN ACCESS-GOAL-CACHE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-CACHED-BINDINGS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GOAL-CACHE CACHED-BINDINGS SELF)
      (CAST VALUE SGT-QUERY-LIST))
     (CL:RETURN-FROM
      ACCESS-GOAL-CACHE-SLOT-VALUE
      (CLSYS-SVAL GOAL-CACHE CACHED-BINDINGS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-REVERSE-POLARITY-CACHED-BINDINGS)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GOAL-CACHE REVERSE-POLARITY-CACHED-BINDINGS SELF)
      (CAST VALUE SGT-QUERY-LIST))
     (CL:RETURN-FROM
      ACCESS-GOAL-CACHE-SLOT-VALUE
      (CLSYS-SVAL GOAL-CACHE REVERSE-POLARITY-CACHED-BINDINGS SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-UP-FOR-GRABS?)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GOAL-CACHE UP-FOR-GRABS? SELF)
      (CLSYS-SVAL
       BOOLEAN-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-BOOLEAN-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-GOAL-CACHE-SLOT-VALUE
      (WRAP-BOOLEAN (CLSYS-SVAL GOAL-CACHE UP-FOR-GRABS? SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-CLUSTER)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GOAL-CACHE CLUSTER SELF)
      (CAST VALUE SGT-QUERY-GOAL-CACHE-CLUSTER))
     (CL:RETURN-FROM
      ACCESS-GOAL-CACHE-SLOT-VALUE
      (CLSYS-SVAL GOAL-CACHE CLUSTER SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-GOAL-CACHE-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF GOAL-CACHE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-QUERY-GOAL-CACHE)
  :VOID)

;;; (DEFUN (GET-CACHED-BINDINGS (LIST OF GOAL-BINDINGS)) ...)

(CL:DEFUN GET-CACHED-BINDINGS (GOALCACHE FRAME)
  (CL:RETURN-FROM
   GET-CACHED-BINDINGS
   (CL:IF
    (CL:EQ (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? FRAME) 1)
    (CLSYS-SVAL GOAL-CACHE REVERSE-POLARITY-CACHED-BINDINGS GOALCACHE)
    (CLSYS-SVAL GOAL-CACHE CACHED-BINDINGS GOALCACHE)))
  :VOID)

;;; (DEFUN PRINT-GOAL-CACHE ...)

(CL:DEFUN PRINT-GOAL-CACHE (SELF)
  (CL:WRITE-STRING
   "<<"
   (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
  (CL:LET*
   ((*QUERYENVIRONMENT* NULL))
   (CL:DECLARE (CL:SPECIAL *QUERYENVIRONMENT*))
   (PRINT-OBJECT
    (CLSYS-SVAL
     GOAL-CACHE-CLUSTER
     PROPOSITION
     (CLSYS-SVAL GOAL-CACHE CLUSTER SELF))
    (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
  (CL:WRITE-STRING
   "  INPUT: "
   (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT))
  (CL:LET*
   ((V NULL)
    (K NULL)
    (ITER-001
     (CLSYS-SVAL
      KEY-VALUE-LIST
      THE-KV-LIST
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL
         GOAL-CACHE-CLUSTER
         VECTOR-OF-GOAL-CACHE-TABLES
         (CLSYS-SVAL GOAL-CACHE CLUSTER SELF)))
       (CLSYS-SVAL
        QUERY-ENVIRONMENT
        QUERY-THREAD-OFFSET
        *QUERYENVIRONMENT*)))))
   (CL:LOOP
    WHILE
    (CL:NOT (CL:EQ ITER-001 NULL))
    DO
    (CL:SETQ K (CAST (CLSYS-SVAL KV-CONS KEY ITER-001) SGT-QUERY-CONS))
    (CL:PROGN
     (CL:SETQ
      V
      (CAST (CLSYS-SVAL KV-CONS VALUE ITER-001) SGT-QUERY-GOAL-CACHE))
     (CL:SETQ ITER-001 (CLSYS-SVAL KV-CONS REST ITER-001)))
    (CL:WHEN
     (CL:EQ V SELF)
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (PRINT-OBJECT K %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (CL:RETURN))))
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING "    BINDINGS: " %%STREAM)
   (PRINT-OBJECT (CLSYS-SVAL GOAL-CACHE CACHED-BINDINGS SELF) %%STREAM))
  (CL:WHEN
   (CL:EQ
    (EMPTY? (CLSYS-SVAL GOAL-CACHE REVERSE-POLARITY-CACHED-BINDINGS SELF))
    0)
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM)
    (CL:WRITE-STRING "    NEGATIVE BINDINGS: " %%STREAM)
    (PRINT-OBJECT
     (CLSYS-SVAL GOAL-CACHE REVERSE-POLARITY-CACHED-BINDINGS SELF)
     %%STREAM)))
  (CL:LET
   ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
   (CL:WRITE-STRING ">>" %%STREAM)
   (CL:TERPRI %%STREAM)
   (CL:FORCE-OUTPUT %%STREAM))
  :VOID)

;;; (DEFCLASS GOAL-CACHE-CLUSTER ...)

(CL:DEFCLASS GOAL-CACHE-CLUSTER (STANDARD-OBJECT)
  ((VECTOR-OF-GOAL-CACHE-TABLES
    :ALLOCATION
    :INSTANCE
    :ACCESSOR
    VECTOR-OF-GOAL-CACHE-TABLES...OF)
   (TIME-STAMP :ALLOCATION :INSTANCE :ACCESSOR TIME-STAMP...OF)
   (PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR PROPOSITION...OF)))

(CL:DEFUN NEW-GOAL-CACHE-CLUSTER ()
  (CL:LET*
   ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE GOAL-CACHE-CLUSTER)))
   (CL:SETF (CLSYS-SVAL GOAL-CACHE-CLUSTER PROPOSITION SELF) NULL)
   (CL:SETF (CLSYS-SVAL GOAL-CACHE-CLUSTER TIME-STAMP SELF) NULL-INTEGER)
   (CL:SETF
    (CLSYS-SVAL GOAL-CACHE-CLUSTER VECTOR-OF-GOAL-CACHE-TABLES SELF)
    NULL)
   (CL:RETURN-FROM NEW-GOAL-CACHE-CLUSTER SELF))
  :VOID)

(CL:DEFUN ACCESS-GOAL-CACHE-CLUSTER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-QUERY-VECTOR-OF-GOAL-CACHE-TABLES)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GOAL-CACHE-CLUSTER VECTOR-OF-GOAL-CACHE-TABLES SELF)
      (CAST VALUE SGT-QUERY-VECTOR))
     (CL:RETURN-FROM
      ACCESS-GOAL-CACHE-CLUSTER-SLOT-VALUE
      (CLSYS-SVAL GOAL-CACHE-CLUSTER VECTOR-OF-GOAL-CACHE-TABLES SELF))))
   ((CL:EQ SLOTNAME SYM-QUERY-TIME-STAMP)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GOAL-CACHE-CLUSTER TIME-STAMP SELF)
      (CLSYS-SVAL
       INTEGER-WRAPPER
       WRAPPER-VALUE
       (CAST VALUE SGT-QUERY-INTEGER-WRAPPER)))
     (CL:RETURN-FROM
      ACCESS-GOAL-CACHE-CLUSTER-SLOT-VALUE
      (WRAP-LITERAL (CLSYS-SVAL GOAL-CACHE-CLUSTER TIME-STAMP SELF)))))
   ((CL:EQ SLOTNAME SYM-QUERY-PROPOSITION)
    (CL:IF
     (CL:EQ SETVALUE? 1)
     (CL:SETF
      (CLSYS-SVAL GOAL-CACHE-CLUSTER PROPOSITION SELF)
      (CAST VALUE SGT-QUERY-PROPOSITION))
     (CL:RETURN-FROM
      ACCESS-GOAL-CACHE-CLUSTER-SLOT-VALUE
      (CLSYS-SVAL GOAL-CACHE-CLUSTER PROPOSITION SELF))))
   (CL:T (CL:ERROR "`~A' is not a valid case option" SLOTNAME)))
  (CL:WHEN
   (CL:EQ SETVALUE? 1)
   (CL:RETURN-FROM ACCESS-GOAL-CACHE-CLUSTER-SLOT-VALUE VALUE))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF GOAL-CACHE-CLUSTER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-QUERY-GOAL-CACHE-CLUSTER)
  :VOID)

;;; (DEFUN (HELP-FIND-DUPLICATED-GOAL CONTROL-FRAME CONTROL-FRAME INTEGER) ...)

(CL:DEFUN HELP-FIND-DUPLICATED-GOAL (GOALFRAME)
  (CL:LET*
   ((ATOMICGOAL (CLSYS-SVAL CONTROL-FRAME PROPOSITION GOALFRAME))
    (BINDINGS (YIELD-GOAL-BINDINGS GOALFRAME))
    (DEPTH 1)
    (FIRSTGOALFRAME NULL)
    (TESTGOAL NULL)
    (TESTFRAME NULL)
    (RESTARTFRAME NULL)
    (RESTARTDEPTH NULL-INTEGER))
   (CL:SETQ
    TESTFRAME
    (CLSYS-SVAL
     CONTROL-FRAME
     DOWN
     (CL:AREF
      (CLSYS-SVAL
       VECTOR
       THE-ARRAY
       (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK *QUERYENVIRONMENT*))
      0)))
   (CL:LOOP
    (CL:SETQ TESTGOAL (CLSYS-SVAL CONTROL-FRAME PROPOSITION TESTFRAME))
    (CL:LET*
     ((TEST-VALUE-001 FALSE))
     (CL:SETQ TEST-VALUE-001 (DEFINED? TESTGOAL))
     (CL:WHEN
      (CL:EQ TEST-VALUE-001 1)
      (CL:SETQ
       TEST-VALUE-001
       (EQL?
        (CLSYS-SVAL PROPOSITION OPERATOR TESTGOAL)
        (CLSYS-SVAL PROPOSITION OPERATOR ATOMICGOAL)))
      (CL:WHEN
       (CL:EQ TEST-VALUE-001 1)
       (CL:SETQ
        TEST-VALUE-001
        (CL:IF
         (CL:OR
          (CL:NOT (CL:EQ (CLSYS-SVAL PROPOSITION KIND TESTGOAL) KWD-QUERY-IN))
          (CL:EQ
           (EQL?
            (CL:AREF
             (CLSYS-SVAL
              VECTOR
              THE-ARRAY
              (CLSYS-SVAL PROPOSITION ARGUMENTS TESTGOAL))
             1)
            (CL:AREF
             (CLSYS-SVAL
              VECTOR
              THE-ARRAY
              (CLSYS-SVAL PROPOSITION ARGUMENTS ATOMICGOAL))
             1))
           1))
         TRUE
         FALSE))
       (CL:WHEN
        (CL:EQ TEST-VALUE-001 1)
        (CL:SETQ
         TEST-VALUE-001
         (EQ?
          (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? TESTFRAME)
          (CLSYS-SVAL CONTROL-FRAME REVERSE-POLARITY? GOALFRAME)))
        (CL:WHEN
         (CL:EQ TEST-VALUE-001 1)
         (CL:LET*
          ((ALWAYS?-001 TRUE))
          (CL:LET*
           ((B2 NULL)
            (B1 NULL)
            (ITER-001 BINDINGS)
            (ITER-002 (YIELD-GOAL-BINDINGS TESTFRAME)))
           (CL:LOOP
            WHILE
            (CL:AND
             (CL:NOT (CL:EQ ITER-001 NIL))
             (CL:NOT (CL:EQ ITER-002 NIL)))
            DO
            (CL:PROGN
             (CL:SETQ B1 (CLSYS-SVAL CONS VALUE ITER-001))
             (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
            (CL:PROGN
             (CL:SETQ B2 (CLSYS-SVAL CONS VALUE ITER-002))
             (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
            (CL:WHEN
             (CL:EQ (EQL? B1 B2) 0)
             (CL:SETQ ALWAYS?-001 FALSE)
             (CL:RETURN))))
          (CL:SETQ TEST-VALUE-001 ALWAYS?-001))))))
     (CL:WHEN
      (CL:EQ TEST-VALUE-001 1)
      (CL:IF
       (CL:EQ FIRSTGOALFRAME NULL)
       (CL:SETQ FIRSTGOALFRAME TESTFRAME)
       (CL:RETURN-FROM
        HELP-FIND-DUPLICATED-GOAL
        (CL:VALUES FIRSTGOALFRAME RESTARTFRAME RESTARTDEPTH)))))
    (CL:SETQ RESTARTFRAME TESTFRAME)
    (CL:SETQ RESTARTDEPTH DEPTH)
    (CL:SETQ TESTFRAME (CLSYS-SVAL CONTROL-FRAME DOWN TESTFRAME))
    (CL:SETQ DEPTH (CL:1+ DEPTH))
    (CL:WHEN
     (CL:EQ TESTFRAME NULL)
     (CL:RETURN-FROM
      HELP-FIND-DUPLICATED-GOAL
      (CL:VALUES NULL NULL NULL-INTEGER)))))
  :VOID)

;;; (DEFUN (FIND-DUPLICATED-GOAL CONTROL-FRAME CONTROL-FRAME INTEGER) ...)

(CL:DEFUN FIND-DUPLICATED-GOAL ()
  (CL:LET*
   ((TRIALFRAME NULL) (TRIALGOAL NULL))
   (CL:LET*
    ((I NULL)
     (ITER-001
      (REVERSE
       (INTERVAL
        2
        (CLSYS-SVAL
         QUERY-ENVIRONMENT
         TOP-CONTROL-FRAME-OFFSET
         *QUERYENVIRONMENT*)))))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN
      (CL:SETQ
       I
       (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR VALUE ITER-001)))
     (CL:SETQ
      TRIALFRAME
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK *QUERYENVIRONMENT*))
       I))
     (CL:SETQ TRIALGOAL (CLSYS-SVAL CONTROL-FRAME PROPOSITION TRIALFRAME))
     (CL:WHEN
      (CL:NOT (CL:EQ TRIALGOAL NULL))
      (CL:LET*
       ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND TRIALGOAL)))
       (CL:COND
        ((CL:OR
          (CL:EQ TEST-VALUE-001 KWD-QUERY-FUNCTION)
          (CL:EQ TEST-VALUE-001 KWD-QUERY-PREDICATE)
          (CL:EQ TEST-VALUE-001 KWD-QUERY-IN))
         (CL:LET*
          ((GOALFRAME NULL) (RESTARTFRAME NULL) (RESTARTDEPTH NULL-INTEGER))
          (CL:MULTIPLE-VALUE-SETQ
           (GOALFRAME RESTARTFRAME RESTARTDEPTH)
           (HELP-FIND-DUPLICATED-GOAL TRIALFRAME))
          (CL:WHEN
           (CL:NOT (CL:EQ GOALFRAME NULL))
           (CL:LET*
            ((*PRINTINFRAME* TRIALFRAME))
            (CL:DECLARE (CL:SPECIAL *PRINTINFRAME*))
            (CL:WHEN
             (CL:AND
              (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
              (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES) 1))
             (CL:LET
              ((%%STREAM
                (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
              (CL:WRITE-STRING "DUPLICATED GOAL: " %%STREAM)
              (PRINT-OBJECT TRIALGOAL %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM)
              (CL:WRITE-STRING "  DEPTH " %%STREAM)
              (CL:PRINC RESTARTDEPTH %%STREAM)
              (CL:TERPRI %%STREAM)
              (CL:FORCE-OUTPUT %%STREAM))))
           (CL:RETURN-FROM
            FIND-DUPLICATED-GOAL
            (CL:VALUES GOALFRAME RESTARTFRAME RESTARTDEPTH)))))
        (CL:T NULL))))))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES) 1))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "FAILED TO FIND DUPLICATE GOAL" %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)))
   (CL:SETF
    (CLSYS-SVAL
     QUERY-ENVIRONMENT
     FAILED-TO-FIND-DUPLICATE-SUBGOAL?
     *QUERYENVIRONMENT*)
    TRUE)
   (CL:RETURN-FROM FIND-DUPLICATED-GOAL (CL:VALUES NULL NULL NULL-INTEGER)))
  :VOID)

;;; (DEFUN (YIELD-GOAL-BINDINGS CONS) ...)

(CL:DEFUN YIELD-GOAL-BINDINGS (FRAME)
  (CL:LET*
   ((GOAL (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
    (RESULT NIL)
    (SAVECURRENTOFFSET
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      CURRENT-VARIABLE-FRAME-OFFSET
      *QUERYENVIRONMENT*)))
   (CL:SETF
    (CLSYS-SVAL
     QUERY-ENVIRONMENT
     CURRENT-VARIABLE-FRAME-OFFSET
     *QUERYENVIRONMENT*)
    (CLSYS-SVAL
     SUBQUERY-FRAME
     LOCAL-VARIABLE-FRAME-OFFSET
     (CAST
      (CLSYS-SVAL
       CONTROL-FRAME
       ITERATOR
       (CLSYS-SVAL CONTROL-FRAME PARENT-PATTERN-FRAME FRAME))
      SGT-QUERY-SUBQUERY-FRAME)))
   (CL:LET*
    ((ARG NULL)
     (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       ARG
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (CONS (ARGUMENT-BOUND-TO ARG) NIL))
       (CL:IF
        (CL:EQ RESULT NIL)
        (CL:SETQ RESULT COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-001)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-001)
        (CONS (ARGUMENT-BOUND-TO ARG) NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:SETF
    (CLSYS-SVAL
     QUERY-ENVIRONMENT
     CURRENT-VARIABLE-FRAME-OFFSET
     *QUERYENVIRONMENT*)
    SAVECURRENTOFFSET)
   (CL:RETURN-FROM YIELD-GOAL-BINDINGS RESULT))
  :VOID)

;;; (DEFUN (LOOKUP-GOAL-CACHE GOAL-CACHE) ...)

(CL:DEFUN LOOKUP-GOAL-CACHE (CLUSTER FRAME)
  (CL:LET*
   ((BINDINGS (YIELD-GOAL-BINDINGS FRAME)))
   (CL:LET*
    ((V NULL)
     (K NULL)
     (ITER-001
      (CLSYS-SVAL
       KEY-VALUE-LIST
       THE-KV-LIST
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL GOAL-CACHE-CLUSTER VECTOR-OF-GOAL-CACHE-TABLES CLUSTER))
        (CLSYS-SVAL
         QUERY-ENVIRONMENT
         QUERY-THREAD-OFFSET
         *QUERYENVIRONMENT*)))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NULL))
     DO
     (CL:SETQ K (CAST (CLSYS-SVAL KV-CONS KEY ITER-001) SGT-QUERY-CONS))
     (CL:PROGN
      (CL:SETQ
       V
       (CAST (CLSYS-SVAL KV-CONS VALUE ITER-001) SGT-QUERY-GOAL-CACHE))
      (CL:SETQ ITER-001 (CLSYS-SVAL KV-CONS REST ITER-001)))
     (CL:LET*
      ((ALWAYS?-001 TRUE))
      (CL:LET*
       ((V2 NULL) (V1 NULL) (ITER-002 BINDINGS) (ITER-003 K))
       (CL:LOOP
        WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-002 NIL)) (CL:NOT (CL:EQ ITER-003 NIL)))
        DO
        (CL:PROGN
         (CL:SETQ V1 (CLSYS-SVAL CONS VALUE ITER-002))
         (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
        (CL:PROGN
         (CL:SETQ V2 (CLSYS-SVAL CONS VALUE ITER-003))
         (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
        (CL:WHEN
         (CL:EQ (EQL? V1 V2) 0)
         (CL:SETQ ALWAYS?-001 FALSE)
         (CL:RETURN))))
      (CL:WHEN
       (CL:EQ ALWAYS?-001 1)
       (FREE-CONS-LIST BINDINGS)
       (CL:RETURN-FROM LOOKUP-GOAL-CACHE V)))))
   (FREE-CONS-LIST BINDINGS)
   (CL:RETURN-FROM LOOKUP-GOAL-CACHE NULL))
  :VOID)

;;; (DEFUN (FIND-GOAL-CACHE-CLUSTER GOAL-CACHE-CLUSTER) ...)

(CL:DEFUN FIND-GOAL-CACHE-CLUSTER (GOAL)
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND GOAL)))
   (CL:COND
    ((CL:OR
      (CL:EQ TEST-VALUE-001 KWD-QUERY-PREDICATE)
      (CL:EQ TEST-VALUE-001 KWD-QUERY-FUNCTION))
     (CL:WHEN
      (CL:EQ
       (PRIMARY-TYPE (CLSYS-SVAL PROPOSITION OPERATOR GOAL))
       SGT-QUERY-SURROGATE)
      (CL:RETURN-FROM
       FIND-GOAL-CACHE-CLUSTER
       (DYNAMIC-SLOT-VALUE
        (CAST
         (CLSYS-SVAL
          SURROGATE
          SURROGATE-VALUE
          (CAST (CLSYS-SVAL PROPOSITION OPERATOR GOAL) SGT-QUERY-SLOTREF))
         SGT-QUERY-SLOT)
        SYM-QUERY-GOAL-CACHE-CLUSTER
        NULL))))
    ((CL:EQ TEST-VALUE-001 KWD-QUERY-IN)
     (CL:LET*
      ((SECONDARG
        (CL:AREF
         (CLSYS-SVAL VECTOR THE-ARRAY (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))
         1)))
      (CL:WHEN
       (CL:EQ (PRIMARY-TYPE SECONDARG) SGT-QUERY-SURROGATE)
       (CL:RETURN-FROM
        FIND-GOAL-CACHE-CLUSTER
        (DYNAMIC-SLOT-VALUE
         (CAST
          (CLSYS-SVAL
           SURROGATE
           SURROGATE-VALUE
           (CAST SECONDARG SGT-QUERY-SURROGATE))
          SGT-QUERY-CLASS)
         SYM-QUERY-GOAL-CACHE-CLUSTER
         NULL)))))
    (CL:T (CL:RETURN-FROM FIND-GOAL-CACHE-CLUSTER NULL))))
  (CL:RETURN-FROM FIND-GOAL-CACHE-CLUSTER NULL)
  :VOID)

;;; (DEFUN (FIND-GOAL-CACHE GOAL-CACHE) ...)

(CL:DEFUN FIND-GOAL-CACHE (FRAME)
  (CL:LET*
   ((GOAL (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
    (CLUSTER (FIND-GOAL-CACHE-CLUSTER GOAL)))
   (CL:COND
    ((CL:EQ CLUSTER NULL) (CL:RETURN-FROM FIND-GOAL-CACHE NULL))
    ((CL:<
      (CLSYS-SVAL GOAL-CACHE-CLUSTER TIME-STAMP CLUSTER)
      (GET-NOW-TIME-STAMP))
     (CLEAR
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL GOAL-CACHE-CLUSTER VECTOR-OF-GOAL-CACHE-TABLES CLUSTER))
       (CLSYS-SVAL QUERY-ENVIRONMENT QUERY-THREAD-OFFSET *QUERYENVIRONMENT*)))
     (CL:RETURN-FROM FIND-GOAL-CACHE NULL))
    (CL:T (CL:RETURN-FROM FIND-GOAL-CACHE (LOOKUP-GOAL-CACHE CLUSTER FRAME)))))
  :VOID)

;;; (DEFUN (CREATE-GOAL-CACHE-CLUSTER GOAL-CACHE-CLUSTER) ...)

(CL:DEFUN CREATE-GOAL-CACHE-CLUSTER (GOAL)
  (CL:LET*
   ((CLUSTER (NEW-GOAL-CACHE-CLUSTER)))
   (CL:SETF
    (CLSYS-SVAL GOAL-CACHE-CLUSTER VECTOR-OF-GOAL-CACHE-TABLES CLUSTER)
    (NEW-VECTOR *QUERY-THREAD-LIMIT*))
   (CL:LET*
    ((I NULL)
     (ITER-001 0)
     (UPPER-BOUND-001 *MAXIMUM-QUERY-THREAD-OFFSET*)
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
    (CL:LOOP
     WHILE
     (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:SETF
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL GOAL-CACHE-CLUSTER VECTOR-OF-GOAL-CACHE-TABLES CLUSTER))
       I)
      (NEW-KEY-VALUE-LIST))))
   (CL:SETF (CLSYS-SVAL GOAL-CACHE-CLUSTER PROPOSITION CLUSTER) GOAL)
   (CL:RETURN-FROM CREATE-GOAL-CACHE-CLUSTER CLUSTER))
  :VOID)

;;; (DEFUN (CREATE-GOAL-CACHE? BOOLEAN) ...)

(CL:DEFUN CREATE-GOAL-CACHE? (FRAME)
  (CL:LET*
   ((GOAL (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
    (CLUSTER (FIND-GOAL-CACHE-CLUSTER GOAL)))
   (CL:WHEN
    (CL:EQ CLUSTER NULL)
    (CL:SETQ CLUSTER (CREATE-GOAL-CACHE-CLUSTER GOAL))
    (CL:LET*
     ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND GOAL)))
     (CL:COND
      ((CL:OR
        (CL:EQ TEST-VALUE-001 KWD-QUERY-PREDICATE)
        (CL:EQ TEST-VALUE-001 KWD-QUERY-FUNCTION))
       (CL:IF
        (CL:EQ
         (PRIMARY-TYPE (CLSYS-SVAL PROPOSITION OPERATOR GOAL))
         SGT-QUERY-SURROGATE)
        (SET-DYNAMIC-SLOT-VALUE
         (CAST
          (CLSYS-SVAL
           SURROGATE
           SURROGATE-VALUE
           (CAST (CLSYS-SVAL PROPOSITION OPERATOR GOAL) SGT-QUERY-SLOTREF))
          SGT-QUERY-SLOT)
         SYM-QUERY-GOAL-CACHE-CLUSTER
         CLUSTER
         NULL)
        (CL:RETURN-FROM CREATE-GOAL-CACHE? FALSE)))
      ((CL:EQ TEST-VALUE-001 KWD-QUERY-IN)
       (CL:LET*
        ((SECONDARG
          (CL:AREF
           (CLSYS-SVAL
            VECTOR
            THE-ARRAY
            (CLSYS-SVAL PROPOSITION ARGUMENTS GOAL))
           1)))
        (CL:IF
         (CL:EQ (PRIMARY-TYPE SECONDARG) SGT-QUERY-SURROGATE)
         (SET-DYNAMIC-SLOT-VALUE
          (CAST
           (CLSYS-SVAL
            SURROGATE
            SURROGATE-VALUE
            (CAST SECONDARG SGT-QUERY-SURROGATE))
           SGT-QUERY-CLASS)
          SYM-QUERY-GOAL-CACHE-CLUSTER
          CLUSTER
          NULL)
         (CL:RETURN-FROM CREATE-GOAL-CACHE? FALSE))))
      (CL:T (CL:RETURN-FROM CREATE-GOAL-CACHE? FALSE)))))
   (CL:SETF
    (CLSYS-SVAL GOAL-CACHE-CLUSTER TIME-STAMP CLUSTER)
    (GET-NOW-TIME-STAMP))
   (CL:LET*
    ((GOALCACHE (LOOKUP-GOAL-CACHE CLUSTER FRAME)))
    (CL:WHEN
     (CL:EQ GOALCACHE NULL)
     (CL:SETQ GOALCACHE (NEW-GOAL-CACHE))
     (CL:SETF (CLSYS-SVAL GOAL-CACHE CLUSTER GOALCACHE) CLUSTER)
     (INSERT-AT
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL GOAL-CACHE-CLUSTER VECTOR-OF-GOAL-CACHE-TABLES CLUSTER))
       (CLSYS-SVAL QUERY-ENVIRONMENT QUERY-THREAD-OFFSET *QUERYENVIRONMENT*))
      (YIELD-GOAL-BINDINGS FRAME)
      GOALCACHE)
     (CL:SETF (CLSYS-SVAL CONTROL-FRAME GOAL-CACHE FRAME) GOALCACHE)
     (CL:SETF (CLSYS-SVAL GOAL-CACHE UP-FOR-GRABS? GOALCACHE) FALSE)
     (INSERT
      (CLSYS-SVAL QUERY-ENVIRONMENT ACTIVE-GOAL-CACHES *QUERYENVIRONMENT*)
      GOALCACHE)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT AUGMENTED-GOAL-CACHE? *QUERYENVIRONMENT*)
      TRUE))
    (CL:RETURN-FROM CREATE-GOAL-CACHE? TRUE)))
  :VOID)

;;; (DEFUN (HANDLE-DEPTH-VIOLATION CONTROL-FRAME INTEGER) ...)

(CL:DEFUN HANDLE-DEPTH-VIOLATION (FRAME DEPTH)
  (CL:WHEN
   (CL:AND
    (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE) 1))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "CUTOFF: depth = " %%STREAM)
    (CL:PRINC DEPTH %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM)))
  (CL:WHEN
   (CL:AND
    (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES) 1))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "CUTOFF: depth = " %%STREAM)
    (CL:PRINC DEPTH %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM)))
  (CL:SETF
   (CLSYS-SVAL QUERY-ENVIRONMENT TRIGGERED-DEPTH-CUTOFF? *QUERYENVIRONMENT*)
   TRUE)
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     FRAME
     (CL:AREF
      (CLSYS-SVAL
       VECTOR
       THE-ARRAY
       (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK *QUERYENVIRONMENT*))
      (CLSYS-SVAL
       QUERY-ENVIRONMENT
       TOP-CONTROL-FRAME-OFFSET
       *QUERYENVIRONMENT*))))
   (CL:ERROR
    "Safety violation: INTERNAL ERROR: Depth violation did not occur at the top of the control stack."))
  (CL:LET*
   ((GOALFRAME NULL) (RESTARTFRAME NULL) (RESTARTDEPTH NULL-INTEGER))
   (CL:MULTIPLE-VALUE-SETQ
    (GOALFRAME RESTARTFRAME RESTARTDEPTH)
    (FIND-DUPLICATED-GOAL))
   (CL:WHEN
    (CL:AND
     (CL:NOT (CL:EQ GOALFRAME NULL))
     (CL:EQ (FIND-GOAL-CACHE GOALFRAME) NULL)
     (CL:EQ (CREATE-GOAL-CACHE? GOALFRAME) 1))
    (CL:WHEN
     (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN RESTARTFRAME) NULL))
     (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN RESTARTFRAME))
     (CL:SETF (CLSYS-SVAL CONTROL-FRAME DOWN RESTARTFRAME) NULL))
    (CL:WHEN
     (CL:NOT
      (CL:OR
       (CL:EQ (ZERO? (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH RESTARTFRAME)) 1)
       (CL:=
        RESTARTDEPTH
        (CLSYS-SVAL CONTROL-FRAME DEBUG-DEPTH RESTARTFRAME))))
     (CL:ERROR
      "Safety violation: INTERNAL ERROR: Incorrect depth value in restart frame."))
    (CL:RETURN-FROM
     HANDLE-DEPTH-VIOLATION
     (CL:VALUES RESTARTFRAME RESTARTDEPTH))))
  (CL:RETURN-FROM HANDLE-DEPTH-VIOLATION (CL:VALUES FRAME DEPTH))
  :VOID)

;;; (DEFUN (ACCESS-GOAL-CACHE KEYWORD) ...)

(CL:DEFUN ACCESS-GOAL-CACHE (FRAME)
  (CL:LET*
   ((PROPOSITION (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
    (GOALCACHE NULL)
    (CACHEDBINDINGS NULL))
   (CL:LET*
    ((TEST-VALUE-001 FALSE))
    (CL:LET*
     ()
     (CL:SETQ GOALCACHE (FIND-GOAL-CACHE FRAME))
     (CL:SETQ TEST-VALUE-001 (DEFINED? GOALCACHE)))
    (CL:SETQ TEST-VALUE-001 (CL:IF (CL:EQ TEST-VALUE-001 0) TRUE FALSE))
    (CL:WHEN
     (CL:EQ TEST-VALUE-001 1)
     (CL:RETURN-FROM ACCESS-GOAL-CACHE NULL)))
   (CL:COND
    ((CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME GOAL-CACHE FRAME) NULL))
     (CL:WHEN
      (CL:NOT (CL:EQ GOALCACHE (CLSYS-SVAL CONTROL-FRAME GOAL-CACHE FRAME)))
      (CL:ERROR
       "Safety violation: INTERNAL ERROR: Found non-matching goal cache."))
     (CL:RETURN-FROM ACCESS-GOAL-CACHE NULL))
    ((CL:EQ (CLSYS-SVAL GOAL-CACHE UP-FOR-GRABS? GOALCACHE) 1)
     (CL:SETF (CLSYS-SVAL CONTROL-FRAME GOAL-CACHE FRAME) GOALCACHE)
     (CL:SETF (CLSYS-SVAL GOAL-CACHE UP-FOR-GRABS? GOALCACHE) FALSE)
     (CL:RETURN-FROM ACCESS-GOAL-CACHE NULL)))
   (CL:SETQ CACHEDBINDINGS (GET-CACHED-BINDINGS GOALCACHE FRAME))
   (CL:CASE
    (LENGTH CACHEDBINDINGS)
    (0
     (CL:WHEN
      (CL:AND
       (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
       (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES) 1))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "EMPTY CACHE: " %%STREAM)
       (PRINT-OBJECT PROPOSITION %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))
     (CL:RETURN-FROM ACCESS-GOAL-CACHE KWD-QUERY-FAILURE))
    (1
     (CL:WHEN
      (CL:AND
       (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
       (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES) 1))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "USED CACHED BINDING: " %%STREAM)
       (PRINT-OBJECT PROPOSITION %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))
     (CL:IF
      (CL:EQ
       (BIND-VECTOR-OF-ARGUMENTS-TO-VALUES?
        (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION)
        (FIRST CACHEDBINDINGS))
       1)
      (CL:RETURN-FROM ACCESS-GOAL-CACHE KWD-QUERY-FINAL-SUCCESS)
      (CL:RETURN-FROM ACCESS-GOAL-CACHE KWD-QUERY-FAILURE)))
    (CL:OTHERWISE
     (CL:WHEN
      (CL:AND
       (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
       (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES) 1))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "USED MANY CACHED BINDINGS: " %%STREAM)
       (PRINT-OBJECT PROPOSITION %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))
     (CL:RETURN-FROM
      ACCESS-GOAL-CACHE
      (OVERLAY-WITH-CACHED-BINDINGS FRAME GOALCACHE)))))
  :VOID)

;;; (DEFUN UPDATE-GOAL-CACHE ...)

(CL:DEFUN UPDATE-GOAL-CACHE (FRAME SUCCESS?)
  (CL:WHEN (CL:EQ SUCCESS? 0) (CL:RETURN-FROM UPDATE-GOAL-CACHE))
  (CL:LET*
   ((GOALCACHE (CLSYS-SVAL CONTROL-FRAME GOAL-CACHE FRAME)))
   (CL:WHEN
    (CL:NOT (CL:EQ GOALCACHE NULL))
    (CL:LET*
     ((CACHEDBINDINGS (GET-CACHED-BINDINGS GOALCACHE FRAME))
      (BINDINGS (YIELD-GOAL-BINDINGS FRAME)))
     (CL:LET*
      ((FOUND?-001 FALSE))
      (CL:LET*
       ((OLDBINDINGS NULL)
        (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST CACHEDBINDINGS)))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ
          OLDBINDINGS
          (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-QUERY-CONS))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:LET*
         ((ALWAYS?-001 TRUE))
         (CL:LET*
          ((V2 NULL) (V1 NULL) (ITER-002 BINDINGS) (ITER-003 OLDBINDINGS))
          (CL:LOOP
           WHILE
           (CL:AND
            (CL:NOT (CL:EQ ITER-002 NIL))
            (CL:NOT (CL:EQ ITER-003 NIL)))
           DO
           (CL:PROGN
            (CL:SETQ V1 (CLSYS-SVAL CONS VALUE ITER-002))
            (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
           (CL:PROGN
            (CL:SETQ V2 (CLSYS-SVAL CONS VALUE ITER-003))
            (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
           (CL:WHEN
            (CL:EQ (EQL? V1 V2) 0)
            (CL:SETQ ALWAYS?-001 FALSE)
            (CL:RETURN))))
         (CL:WHEN
          (CL:EQ ALWAYS?-001 1)
          (CL:SETQ FOUND?-001 TRUE)
          (CL:RETURN)))))
      (CL:WHEN
       (CL:EQ FOUND?-001 1)
       (FREE-CONS-LIST BINDINGS)
       (CL:RETURN-FROM UPDATE-GOAL-CACHE)))
     (CL:WHEN
      (CL:AND
       (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
       (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-GOAL-CACHES) 1))
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "AUGMENT CACHE: " %%STREAM)
       (PRINT-OBJECT BINDINGS %%STREAM)
       (CL:WRITE-STRING "  " %%STREAM)
       (PRINT-OBJECT FRAME %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))
     (PUSH CACHEDBINDINGS BINDINGS)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT AUGMENTED-GOAL-CACHE? *QUERYENVIRONMENT*)
      TRUE))))
  :VOID)

;;; (DEFUN (OVERLAY-WITH-CACHED-BINDINGS KEYWORD) ...)

(CL:DEFUN OVERLAY-WITH-CACHED-BINDINGS (FRAME GOALCACHE)
  (CL:SETF
   (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)
   (ALLOCATE-ITERATOR (GET-CACHED-BINDINGS GOALCACHE FRAME)))
  (CL:SETF (CLSYS-SVAL CONTROL-FRAME STATE FRAME) KWD-QUERY-CACHED-BINDINGS)
  (CL:RETURN-FROM OVERLAY-WITH-CACHED-BINDINGS KWD-QUERY-OVERLAY)
  :VOID)

;;; (DEFUN (SCAN-CACHED-BINDINGS KEYWORD) ...)

(CL:DEFUN SCAN-CACHED-BINDINGS (FRAME)
  (CL:LET*
   ((ITERATOR (CLSYS-SVAL CONTROL-FRAME ITERATOR FRAME)))
   (CL:LOOP
    WHILE
    (CL:EQ (NEXT? ITERATOR) 1)
    DO
    (CL:WHEN
     (CL:EQ
      (BIND-VECTOR-OF-ARGUMENTS-TO-VALUES?
       (CLSYS-SVAL
        PROPOSITION
        ARGUMENTS
        (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME))
       (CAST (CLSYS-SVAL ITERATOR VALUE ITERATOR) SGT-QUERY-CONS))
      1)
     (CL:IF
      (CL:EQ (EMPTY? ITERATOR) 1)
      (CL:RETURN-FROM SCAN-CACHED-BINDINGS KWD-QUERY-FINAL-SUCCESS)
      (CL:RETURN-FROM SCAN-CACHED-BINDINGS KWD-QUERY-CONTINUING-SUCCESS))))
   (CL:RETURN-FROM SCAN-CACHED-BINDINGS KWD-QUERY-FAILURE))
  :VOID)

;;; (DEFUN PRINT-CONTROL-FRAME ...)

(CL:DEFUN PRINT-CONTROL-FRAME (SELF STREAM)
  (CL:PROGN
   (CL:WRITE-STRING "|CF|" STREAM)
   (CL:PRINC (COMPUTE-FRAME-OFFSET SELF) STREAM)
   (CL:WRITE-STRING "[" STREAM))
  (CL:IF
   (CL:EQ
    (DEFINED? (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET SELF))
    1)
   (CL:PRINC
    (CLSYS-SVAL CONTROL-FRAME CHOICE-POINT-UNBINDING-OFFSET SELF)
    STREAM)
   (CL:WRITE-STRING "_" STREAM))
  (CL:IF
   (CL:AND
    (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME ITERATOR SELF) NULL))
    (CL:EQ
     (ISA? (CLSYS-SVAL CONTROL-FRAME ITERATOR SELF) SGT-QUERY-SUBQUERY-FRAME)
     1))
   (CL:PROGN
    (CL:WRITE-STRING " " STREAM)
    (CL:PRINC
     (CLSYS-SVAL
      SUBQUERY-FRAME
      LOCAL-VARIABLE-FRAME-OFFSET
      (CAST
       (CLSYS-SVAL CONTROL-FRAME ITERATOR SELF)
       SGT-QUERY-SUBQUERY-FRAME))
     STREAM))
   (CL:WRITE-STRING " _" STREAM))
  (CL:LET*
   ((*PRINTINFRAME* SELF))
   (CL:DECLARE (CL:SPECIAL *PRINTINFRAME*))
   (CL:PROGN
    (CL:WRITE-STRING " " STREAM)
    (PRINT-OBJECT (CLSYS-SVAL CONTROL-FRAME STATE SELF) STREAM)
    (CL:WRITE-STRING " " STREAM)
    (PRINT-OBJECT (CLSYS-SVAL CONTROL-FRAME PHASE SELF) STREAM)
    (CL:WRITE-STRING "  UP: " STREAM)
    (CL:PRINC
     (CL:IF
      (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME UP SELF) NULL))
      (COMPUTE-FRAME-OFFSET (CLSYS-SVAL CONTROL-FRAME UP SELF))
      NULL-INTEGER)
     STREAM)
    (CL:WRITE-STRING "  DOWN: " STREAM)
    (CL:PRINC
     (CL:IF
      (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN SELF) NULL))
      (COMPUTE-FRAME-OFFSET (CLSYS-SVAL CONTROL-FRAME DOWN SELF))
      NULL-INTEGER)
     STREAM)
    (CL:WRITE-STRING " " STREAM)
    (PRINT-OBJECT (CLSYS-SVAL CONTROL-FRAME PROPOSITION SELF) STREAM)
    (CL:WRITE-STRING "]" STREAM)))
  :VOID)

;;; (DEFUN PRINT-GOAL-STACK ...)

(CL:DEFUN PRINT-GOAL-STACK ()
  "Print stack of goals.  Assumes that query has been interrupted
with a full stack of control frames."
  (CL:LET*
   ((I NULL)
    (ITER-001 0)
    (UPPER-BOUND-001
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      TOP-CONTROL-FRAME-OFFSET
      *QUERYENVIRONMENT*))
    (UNBOUNDED?-001 (NULL? UPPER-BOUND-001)))
   (CL:LOOP
    WHILE
    (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
    DO
    (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
    (CL:LET*
     ((FRAME
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL
          QUERY-ENVIRONMENT
          CONTROL-FRAME-STACK
          *QUERYENVIRONMENT*))
        I)))
     (CL:WHEN
      (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME) NULL))
      (CL:LET*
       ((*PRINTINFRAME* FRAME))
       (CL:DECLARE (CL:SPECIAL *PRINTINFRAME*))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (PRINT-OBJECT (CLSYS-SVAL CONTROL-FRAME PROPOSITION FRAME) %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)))))))
  :VOID)

;;; (DEFUN PGS ...)

(CL:DEFUN PGS ()
  (PRINT-GOAL-STACK)
  :VOID)

;;; (DEFUN PRINT-QUERY-ITERATOR ...)

(CL:DEFUN PRINT-QUERY-ITERATOR (SELF STREAM)
  (CL:LET*
   ((SOLUTIONS (CLSYS-SVAL QUERY-ITERATOR SOLUTIONS SELF))
    (NOFSOLUTIONS (LENGTH SOLUTIONS))
    (EXHAUSTED? (CLSYS-SVAL QUERY-ITERATOR EXHAUSTED? SELF))
    (ARITY
     (CL:IF
      (CL:NOT (CL:EQ (FIRST SOLUTIONS) NULL))
      (LENGTH (FIRST SOLUTIONS))
      NULL-INTEGER)))
   (CL:CASE
    NOFSOLUTIONS
    (0
     (CL:IF
      (CL:EQ EXHAUSTED? 1)
      (CL:WRITE-STRING "No solutions." STREAM)
      (CL:WRITE-STRING "No solutions so far." STREAM))
     (CL:RETURN-FROM PRINT-QUERY-ITERATOR))
    (1 (CL:WRITE-STRING "There is 1 solution" STREAM))
    (CL:OTHERWISE
     (CL:PROGN
      (CL:WRITE-STRING "There are " STREAM)
      (CL:PRINC NOFSOLUTIONS STREAM)
      (CL:WRITE-STRING " solutions" STREAM))))
   (CL:WHEN (CL:EQ EXHAUSTED? 0) (CL:WRITE-STRING " so far" STREAM))
   (CL:PROGN
    (CL:WRITE-STRING ":" STREAM)
    (CL:TERPRI STREAM)
    (CL:FORCE-OUTPUT STREAM))
   (CL:LET*
    ((I NULL)
     (SOLUTION NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST SOLUTIONS))
     (ITER-002 1))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       SOLUTION
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-QUERY-VECTOR))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
     (CL:PROGN
      (CL:WRITE-STRING "  #" STREAM)
      (CL:PRINC I STREAM)
      (CL:WRITE-STRING ": " STREAM))
     (CL:LET*
      ((VI NULL)
       (VALUE NULL)
       (VECTOR-001 SOLUTION)
       (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001))
       (ITER-003 0))
      (CL:LOOP
       WHILE
       (CL:< INDEX-001 LENGTH-001)
       DO
       (CL:PROGN
        (CL:SETQ
         VALUE
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (CL:PROGN (CL:SETQ VI ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
       (CL:PROGN
        (PRINT-OBJECT
         (DYNAMIC-SLOT-VALUE
          (CL:AREF
           (CLSYS-SVAL
            VECTOR
            THE-ARRAY
            (CLSYS-SVAL QUERY-ITERATOR EXTERNAL-VARIABLES SELF))
           VI)
          SYM-QUERY-SKOLEM-NAME
          NULL)
         STREAM)
        (CL:WRITE-STRING "=" STREAM)
        (PRINT-OBJECT VALUE STREAM)
        (CL:WRITE-STRING (CL:IF (CL:< VI (CL:1- ARITY)) ", " "") STREAM))))
     (CL:WHEN
      (CL:< I NOFSOLUTIONS)
      (CL:PROGN (CL:TERPRI STREAM) (CL:FORCE-OUTPUT STREAM))))))
  :VOID)

;;; (DEFUN (ALLOCATE-QUERY-ITERATOR QUERY-ITERATOR) ...)

(CL:DEFUN ALLOCATE-QUERY-ITERATOR ()
  (CL:LET*
   ((QUERYITERATOR (NEW-QUERY-ITERATOR))
    (QUERYENVIRONMENT (NEW-QUERY-ENVIRONMENT)))
   (CL:SETF
    (CLSYS-SVAL QUERY-ITERATOR QUERY-ENVIRONMENT QUERYITERATOR)
    QUERYENVIRONMENT)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT QUERY-ITERATOR QUERYENVIRONMENT)
    QUERYITERATOR)
   (RESERVE-QUERY-THREAD QUERYENVIRONMENT)
   (UPDATE-NOW-TIME-STAMP KWD-QUERY-EXECUTE-QUERY)
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT TIME-STAMP QUERYENVIRONMENT)
    (GET-NOW-TIME-STAMP))
   (CL:RETURN-FROM ALLOCATE-QUERY-ITERATOR QUERYITERATOR))
  :VOID)

;;; (DEFMETHOD FREE ...)

(CL:DEFMETHOD FREE ((SELF QUERY-ITERATOR))
  (FREE-QUERY-ITERATOR SELF)
  :VOID)

;;; (DEFUN FREE-QUERY-ITERATOR ...)

(CL:DEFUN FREE-QUERY-ITERATOR (SELF)
  (CL:WHEN
   (CL:EQ (CLSYS-SVAL QUERY-ITERATOR QUERY-ENVIRONMENT SELF) NULL)
   (CL:RETURN-FROM FREE-QUERY-ITERATOR))
  (FREE (CLSYS-SVAL QUERY-ITERATOR VALUE SELF))
  (FREE (CLSYS-SVAL QUERY-ITERATOR QUERY-ENVIRONMENT SELF))
  (CL:SETF (CLSYS-SVAL QUERY-ITERATOR QUERY-ENVIRONMENT SELF) NULL)
  :VOID)

;;; (DEFUN (CREATE-QUERY-ITERATOR QUERY-ITERATOR) ...)

(CL:DEFUN CREATE-QUERY-ITERATOR (DESCRIPTION OUTSIDEARGUMENTS)
  (CL:LET*
   ((QUERYITERATOR (ALLOCATE-QUERY-ITERATOR))
    (QUERYENVIRONMENT
     (CLSYS-SVAL QUERY-ITERATOR QUERY-ENVIRONMENT QUERYITERATOR))
    (TOPCONTROLFRAME (NEW-TOP-CONTROL-FRAME QUERYENVIRONMENT))
    (VARIABLESCOUNT
     (LENGTH (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION)))
    (EXTERNALVARIABLES (NEW-VECTOR VARIABLESCOUNT)))
   (CL:LET*
    ((*QUERYENVIRONMENT* QUERYENVIRONMENT)
     (*EVALUATIONMODE* KWD-QUERY-QUERY)
     (*TOPLEVELPROPOSITIONS* NULL))
    (CL:DECLARE
     (CL:SPECIAL *QUERYENVIRONMENT* *EVALUATIONMODE* *TOPLEVELPROPOSITIONS*))
    (CL:SETF
     (CLSYS-SVAL CONTROL-FRAME PROPOSITION TOPCONTROLFRAME)
     (CLSYS-SVAL DESCRIPTION PROPOSITION DESCRIPTION))
    (CL:SETF
     (CLSYS-SVAL CONTROL-FRAME PHASE TOPCONTROLFRAME)
     KWD-QUERY-INITIAL)
    (CL:SETF (CLSYS-SVAL CONTROL-FRAME UP TOPCONTROLFRAME) NULL)
    (CL:LET*
     ((I NULL)
      (IOVAR NULL)
      (VECTOR-001 (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION))
      (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001))
      (ITER-001 0))
     (CL:LOOP
      WHILE
      (CL:< INDEX-001 LENGTH-001)
      DO
      (CL:PROGN
       (CL:SETQ
        IOVAR
        (CAST
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
         SGT-QUERY-PATTERN-VARIABLE))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
      (CL:SETF
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY EXTERNALVARIABLES) I)
       (CREATE-VARIABLE
        (CLSYS-SVAL PATTERN-VARIABLE ROOT-TYPE IOVAR)
        (DYNAMIC-SLOT-VALUE IOVAR SYM-QUERY-SKOLEM-NAME NULL)
        TRUE))
      (CL:SETF
       (CLSYS-SVAL
        PATTERN-VARIABLE
        BOUND-TO-OFFSET
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY EXTERNALVARIABLES) I))
       I)))
    (CL:LET*
     ((SUBQUERYFRAME (NEW-TOP-SUBQUERY-FRAME)))
     (CL:SETF
      (CLSYS-SVAL CONTROL-FRAME ITERATOR TOPCONTROLFRAME)
      SUBQUERYFRAME)
     (CL:SETF
      (CLSYS-SVAL SUBQUERY-FRAME CONTROL-FRAME SUBQUERYFRAME)
      TOPCONTROLFRAME)
     (ALLOCATE-BLOCK-OF-VARIABLE-FRAMES VARIABLESCOUNT TOPCONTROLFRAME)
     (BOOTSTRAP-INITIALIZE-SUBQUERY-FRAME
      SUBQUERYFRAME
      DESCRIPTION
      EXTERNALVARIABLES
      OUTSIDEARGUMENTS))
    (OVERLAY-WITH-PATTERN-FRAME TOPCONTROLFRAME DESCRIPTION)
    (CL:SETF
     (CLSYS-SVAL QUERY-ENVIRONMENT MAXIMUM-DEPTH QUERYENVIRONMENT)
     *MAXIMUM-BACKTRACKING-DEPTH*)
    (CL:SETF
     (CLSYS-SVAL QUERY-ENVIRONMENT AUGMENTED-GOAL-CACHE? QUERYENVIRONMENT)
     FALSE)
    (CLEAR (CLSYS-SVAL QUERY-ENVIRONMENT ACTIVE-GOAL-CACHES QUERYENVIRONMENT))
    (CL:SETF
     (CLSYS-SVAL QUERY-ENVIRONMENT ITERATIVE-DEEPENING? QUERYENVIRONMENT)
     *ITERATIVE-DEEPENING-MODE?*)
    (CL:SETF
     (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-DEPTH-CUTOFF QUERYENVIRONMENT)
     (CL:IF
      (CL:EQ
       (CLSYS-SVAL QUERY-ENVIRONMENT ITERATIVE-DEEPENING? QUERYENVIRONMENT)
       1)
      (MIN
       *INITIAL-BACKTRACKING-DEPTH*
       (CLSYS-SVAL QUERY-ENVIRONMENT MAXIMUM-DEPTH QUERYENVIRONMENT))
      (CLSYS-SVAL QUERY-ENVIRONMENT MAXIMUM-DEPTH QUERYENVIRONMENT)))
    (CL:SETF
     (CLSYS-SVAL QUERY-ENVIRONMENT TRIGGERED-DEPTH-CUTOFF? QUERYENVIRONMENT)
     FALSE)
    (CL:SETF
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      FAILED-TO-FIND-DUPLICATE-SUBGOAL?
      QUERYENVIRONMENT)
     FALSE)
    (CL:SETF
     (CLSYS-SVAL
      QUERY-ENVIRONMENT
      FOUND-AT-LEAST-ONE-SOLUTION?
      QUERYENVIRONMENT)
     FALSE)
    (CL:SETF
     (CLSYS-SVAL QUERY-ENVIRONMENT DEEP-INFERENCE? QUERYENVIRONMENT)
     (DEEP-INFERENCE-MODE?))
    (CL:SETF
     (CLSYS-SVAL QUERY-ITERATOR EXTERNAL-VARIABLES QUERYITERATOR)
     EXTERNALVARIABLES)
    (CL:SETF
     (CLSYS-SVAL QUERY-ITERATOR VALUE QUERYITERATOR)
     (NEW-VECTOR VARIABLESCOUNT))
    (CL:RETURN-FROM CREATE-QUERY-ITERATOR QUERYITERATOR)))
  :VOID)

;;; (DEFUN BOOTSTRAP-INITIALIZE-SUBQUERY-FRAME ...)

(CL:DEFUN BOOTSTRAP-INITIALIZE-SUBQUERY-FRAME (SUBQUERYFRAME DESCRIPTION EXTERNALARGUMENTS OUTSIDEARGUMENTS)
  (CL:WHEN
   (CL:NOT (CL:EQ DESCRIPTION NULL))
   (CL:SETF (CLSYS-SVAL SUBQUERY-FRAME DESCRIPTION SUBQUERYFRAME) DESCRIPTION)
   (CL:SETF
    (CLSYS-SVAL SUBQUERY-FRAME EXTERNAL-ARGUMENTS SUBQUERYFRAME)
    EXTERNALARGUMENTS)
   (CL:WHEN
    (CL:NOT (CL:EQ OUTSIDEARGUMENTS NULL))
    (CL:WHEN
     (CL:> (LENGTH OUTSIDEARGUMENTS) (LENGTH EXTERNALARGUMENTS))
     (SIGNAL *THE-FAIL-EXCEPTION*))
    (CL:LET*
     ((VALUE NULL)
      (ARG NULL)
      (VECTOR-001 EXTERNALARGUMENTS)
      (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001))
      (VECTOR-002 OUTSIDEARGUMENTS)
      (INDEX-002 0)
      (LENGTH-002 (LENGTH VECTOR-002)))
     (CL:LOOP
      WHILE
      (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:< INDEX-002 LENGTH-002))
      DO
      (CL:PROGN
       (CL:SETQ
        ARG
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (CL:PROGN
       (CL:SETQ
        VALUE
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
       (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
      (CL:WHEN
       (CL:EQ (BIND-ARGUMENT-TO-VALUE? ARG VALUE FALSE) 0)
       (SIGNAL *THE-FAIL-EXCEPTION*)))))
   (CL:SETF
    (CLSYS-SVAL SUBQUERY-FRAME BOOLEAN-VECTOR SUBQUERYFRAME)
    (ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR EXTERNALARGUMENTS))
   (CL:SETF
    (CLSYS-SVAL SUBQUERY-FRAME PHASES-FILTER SUBQUERYFRAME)
    KWD-QUERY-ALL-SUBGOAL-PHASES))
  (CL:SETF
   (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-SUBQUERY-FRAME *QUERYENVIRONMENT*)
   SUBQUERYFRAME)
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF QUERY-ITERATOR))
  (CL:LET*
   ((QUERYENVIRONMENT (CLSYS-SVAL QUERY-ITERATOR QUERY-ENVIRONMENT SELF))
    (VALUEVECTOR (CLSYS-SVAL QUERY-ITERATOR VALUE SELF)))
   (CL:WHEN
    (CL:EQ (CLSYS-SVAL QUERY-ITERATOR EXHAUSTED? SELF) 1)
    (CL:RETURN-FROM NEXT? FALSE))
   (CL:LOOP
    (CL:TAGBODY
     (CL:LOOP
      WHILE
      (CL:EQ (EXECUTE-BACKWARD-CHAINING-PROOF? QUERYENVIRONMENT) 1)
      DO
      (CL:TAGBODY
       (CL:LET*
        ((I NULL)
         (EV NULL)
         (VECTOR-001 (CLSYS-SVAL QUERY-ITERATOR EXTERNAL-VARIABLES SELF))
         (INDEX-001 0)
         (LENGTH-001 (LENGTH VECTOR-001))
         (ITER-001 0))
        (CL:LOOP
         WHILE
         (CL:< INDEX-001 LENGTH-001)
         DO
         (CL:PROGN
          (CL:SETQ
           EV
           (CAST
            (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
            SGT-QUERY-PATTERN-VARIABLE))
          (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
         (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
         (CL:SETF
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VALUEVECTOR) I)
          (BOUND-TO EV))))
       (CL:SETF
        (CLSYS-SVAL
         QUERY-ENVIRONMENT
         FOUND-AT-LEAST-ONE-SOLUTION?
         QUERYENVIRONMENT)
        TRUE)
       (CL:LET*
        ((FOUND?-001 FALSE))
        (CL:LET*
         ((SOLUTION NULL)
          (ITER-002
           (CLSYS-SVAL
            LIST
            THE-CONS-LIST
            (CLSYS-SVAL QUERY-ITERATOR SOLUTIONS SELF))))
         (CL:LOOP
          WHILE
          (CL:NOT (CL:EQ ITER-002 NIL))
          DO
          (CL:PROGN
           (CL:SETQ
            SOLUTION
            (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-QUERY-VECTOR))
           (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
          (CL:LET*
           ((ALWAYS?-001 TRUE))
           (CL:LET*
            ((NEWBINDING NULL)
             (OLDBINDING NULL)
             (VECTOR-002 SOLUTION)
             (INDEX-002 0)
             (LENGTH-002 (LENGTH VECTOR-002))
             (VECTOR-003 VALUEVECTOR)
             (INDEX-003 0)
             (LENGTH-003 (LENGTH VECTOR-003)))
            (CL:LOOP
             WHILE
             (CL:AND (CL:< INDEX-002 LENGTH-002) (CL:< INDEX-003 LENGTH-003))
             DO
             (CL:PROGN
              (CL:SETQ
               OLDBINDING
               (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
              (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
             (CL:PROGN
              (CL:SETQ
               NEWBINDING
               (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-003) INDEX-003))
              (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))
             (CL:WHEN
              (CL:EQ (EQL? OLDBINDING NEWBINDING) 0)
              (CL:SETQ ALWAYS?-001 FALSE)
              (CL:RETURN))))
           (CL:WHEN
            (CL:EQ ALWAYS?-001 1)
            (CL:SETQ FOUND?-001 TRUE)
            (CL:RETURN)))))
        (CL:WHEN (CL:EQ FOUND?-001 1) (CL:GO :CONTINUE)))
       (INSERT-LAST
        (CLSYS-SVAL QUERY-ITERATOR SOLUTIONS SELF)
        (COPY VALUEVECTOR))
       (CL:RETURN-FROM NEXT? TRUE)
       :CONTINUE))
     (CL:COND
      ((CL:EQ
        (CLSYS-SVAL QUERY-ENVIRONMENT AUGMENTED-GOAL-CACHE? QUERYENVIRONMENT)
        1)
       (RESET SELF))
      ((CL:AND
        (CL:EQ
         (CLSYS-SVAL QUERY-ENVIRONMENT ITERATIVE-DEEPENING? QUERYENVIRONMENT)
         1)
        (CL:EQ
         (CLSYS-SVAL
          QUERY-ENVIRONMENT
          TRIGGERED-DEPTH-CUTOFF?
          QUERYENVIRONMENT)
         1)
        (CL:<
         (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-DEPTH-CUTOFF QUERYENVIRONMENT)
         (CLSYS-SVAL QUERY-ENVIRONMENT MAXIMUM-DEPTH QUERYENVIRONMENT)))
       (CL:SETF
        (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-DEPTH-CUTOFF QUERYENVIRONMENT)
        (CL:1+
         (CLSYS-SVAL
          QUERY-ENVIRONMENT
          CURRENT-DEPTH-CUTOFF
          QUERYENVIRONMENT)))
       (RESET SELF))
      (CL:T
       (CL:WHEN
        (CL:AND
         (CL:EQ
          (CLSYS-SVAL
           QUERY-ENVIRONMENT
           FAILED-TO-FIND-DUPLICATE-SUBGOAL?
           QUERYENVIRONMENT)
          1)
         (CL:EQ
          (CLSYS-SVAL
           QUERY-ENVIRONMENT
           FOUND-AT-LEAST-ONE-SOLUTION?
           QUERYENVIRONMENT)
          0))
        (CL:LET
         ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
         (CL:WRITE-STRING
          "Failed to find a duplicate subgoal on one or more occurrences when"
          %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING "   the depth cutoff " %%STREAM)
         (CL:PRINC
          (CLSYS-SVAL QUERY-ENVIRONMENT CURRENT-DEPTH-CUTOFF QUERYENVIRONMENT)
          %%STREAM)
         (CL:WRITE-STRING
          " was exceeded.  Consider increasing the cutoff"
          %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)
         (CL:WRITE-STRING "   and trying again." %%STREAM)
         (CL:TERPRI %%STREAM)
         (CL:FORCE-OUTPUT %%STREAM)))
       (RELEASE-QUERY-THREAD QUERYENVIRONMENT)
       (CL:SETF
        (CLSYS-SVAL QUERY-ENVIRONMENT QUERY-THREAD-OFFSET QUERYENVIRONMENT)
        NULL-INTEGER)
       (CL:SETF (CLSYS-SVAL QUERY-ITERATOR EXHAUSTED? SELF) TRUE)
       (CL:RETURN-FROM NEXT? FALSE)))
     :CONTINUE)))
  :VOID)

;;; (DEFMETHOD RESET ...)

(CL:DEFMETHOD RESET ((SELF QUERY-ITERATOR))
  (CL:LET*
   ((QUERYENVIRONMENT (CLSYS-SVAL QUERY-ITERATOR QUERY-ENVIRONMENT SELF))
    (INITIALFRAME
     (CL:AREF
      (CLSYS-SVAL
       VECTOR
       THE-ARRAY
       (CLSYS-SVAL QUERY-ENVIRONMENT CONTROL-FRAME-STACK QUERYENVIRONMENT))
      0)))
   (CL:WHEN
    (CL:NOT (CL:EQ (CLSYS-SVAL CONTROL-FRAME DOWN INITIALFRAME) NULL))
    (POP-FRAMES-DOWN-TO (CLSYS-SVAL CONTROL-FRAME DOWN INITIALFRAME)))
   (OVERLAY-WITH-PATTERN-FRAME
    INITIALFRAME
    (CLSYS-SVAL
     SUBQUERY-FRAME
     DESCRIPTION
     (CAST
      (CLSYS-SVAL CONTROL-FRAME ITERATOR INITIALFRAME)
      SGT-QUERY-SUBQUERY-FRAME)))
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT AUGMENTED-GOAL-CACHE? QUERYENVIRONMENT)
    FALSE)
   (CL:LET*
    ((GOALCACHE NULL)
     (ITER-001
      (CLSYS-SVAL
       LIST
       THE-CONS-LIST
       (CLSYS-SVAL QUERY-ENVIRONMENT ACTIVE-GOAL-CACHES QUERYENVIRONMENT))))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       GOALCACHE
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-QUERY-GOAL-CACHE))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:SETF (CLSYS-SVAL GOAL-CACHE UP-FOR-GRABS? GOALCACHE) TRUE)))
   (CL:SETF
    (CLSYS-SVAL QUERY-ENVIRONMENT TRIGGERED-DEPTH-CUTOFF? QUERYENVIRONMENT)
    FALSE))
  :VOID)

;;; (DEFUN (COPY-VECTOR-TO-CONS-LIST CONS) ...)

(CL:DEFUN COPY-VECTOR-TO-CONS-LIST (VECTOR)
  (CL:LET*
   ((RESULT NIL))
   (CL:LET*
    ((ELEMENT NULL)
     (VECTOR-001 VECTOR)
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       ELEMENT
       (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (CONS ELEMENT NIL))
       (CL:IF
        (CL:EQ RESULT NIL)
        (CL:SETQ RESULT COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-001)))
      (CL:PROGN
       (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS ELEMENT NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:RETURN-FROM COPY-VECTOR-TO-CONS-LIST RESULT))
  :VOID)

;;; (DEFMETHOD (LISTIFY LIST) ...)

(CL:DEFMETHOD LISTIFY ((SELF QUERY-ITERATOR))
  "Return the list of tuples generated by 'self'.
Tuples of arity=1 are represented directly by the first element,
tuples of arity>1 are represented by a CONS list."
  (CL:LET*
   ((SOLUTIONS (CLSYS-SVAL QUERY-ITERATOR SOLUTIONS SELF))
    (LISTIFIEDSOLUTIONS (NEW-LIST))
    (ARITY 0))
   (CL:LOOP WHILE (CL:EQ (NEXT? SELF) 1))
   (CL:WHEN
    (CL:EQ (NON-EMPTY? SOLUTIONS) 1)
    (CL:SETQ ARITY (LENGTH (FIRST SOLUTIONS))))
   (CL:LET*
    ((SOLUTION NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST SOLUTIONS))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       SOLUTION
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-QUERY-VECTOR))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:IF
      (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ
        COLLECT-001
        (PERMANENT-CONS
         (CL:IF
          (CL:= ARITY 1)
          (FIRST SOLUTION)
          (COPY-VECTOR-TO-CONS-LIST SOLUTION))
         NIL))
       (CL:IF
        (CL:EQ (CLSYS-SVAL LIST THE-CONS-LIST LISTIFIEDSOLUTIONS) NIL)
        (CL:SETF
         (CLSYS-SVAL LIST THE-CONS-LIST LISTIFIEDSOLUTIONS)
         COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST
         (CLSYS-SVAL LIST THE-CONS-LIST LISTIFIEDSOLUTIONS)
         COLLECT-001)))
      (CL:PROGN
       (CL:SETF
        (CLSYS-SVAL CONS REST COLLECT-001)
        (PERMANENT-CONS
         (CL:IF
          (CL:= ARITY 1)
          (FIRST SOLUTION)
          (COPY-VECTOR-TO-CONS-LIST SOLUTION))
         NIL))
       (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
   (CL:RETURN-FROM LISTIFY LISTIFIEDSOLUTIONS))
  :VOID)

;;; (DEFUN (STANDARDIZE-QUERY-TREE CONS) ...)

(CL:DEFUN STANDARDIZE-QUERY-TREE (QUERYTREE TRUEFALSE?)
  (CL:WHEN
   (CL:EQ (CONS? QUERYTREE) 0)
   (CL:SETQ QUERYTREE (LIST* SYM-QUERY-AND QUERYTREE NIL)))
  (CL:RETURN-FROM
   STANDARDIZE-QUERY-TREE
   (CONS.STANDARDIZE-QUERY-TREE (CAST QUERYTREE SGT-QUERY-CONS) TRUEFALSE?))
  :VOID)

;;; (DEFUN (CONS.STANDARDIZE-QUERY-TREE CONS) ...)

(CL:DEFUN CONS.STANDARDIZE-QUERY-TREE (QUERYTREE TRUEFALSE?)
  (CL:LET*
   ((STANDARDIZEDTREE NULL))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* TRUE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:COND
     ((CL:EQ TRUEFALSE? 1)
      (CL:SETQ
       STANDARDIZEDTREE
       (LIST*
        SYM-QUERY-KAPPA
        (CONS SYM-QUERY-COMMA NIL)
        (LIST*
         SYM-QUERY-WHERE
         (CANONICALIZE-PROPOSITION-TREE
          (STANDARDIZE-LOGICAL-PARSE-TREE QUERYTREE))
         NIL)
        NIL)))
     (CL:T
      (CL:SETQ QUERYTREE (CONS SYM-QUERY-EXISTS (CONCATENATE QUERYTREE NIL)))
      (CL:COND
       ((CL:EQ *LOGIC-DIALECT* KWD-QUERY-KIF)
        (CL:WHEN
         (CL:< (LENGTH QUERYTREE) 3)
         (CL:SETQ
          QUERYTREE
          (CONCATENATE QUERYTREE (CONS SYM-QUERY-TRUE NIL)))))
       ((CL:EQ *LOGIC-DIALECT* KWD-QUERY-STELLA)
        (CL:WHEN
         (CL:EQ (MEMBER? QUERYTREE SYM-QUERY-WHERE) 0)
         (CL:SETQ
          QUERYTREE
          (CONCATENATE
           QUERYTREE
           (LIST* SYM-QUERY-WHERE SYM-QUERY-TRUE NIL)))))
       ((CL:EQ *LOGIC-DIALECT* KWD-QUERY-PREFIX-STELLA)
        (CL:WHEN
         (CL:EQ (LOOKUP-WHERE-CLAUSE QUERYTREE) NULL)
         (CL:SETQ
          QUERYTREE
          (CONCATENATE
           QUERYTREE
           (CONS (LIST* SYM-QUERY-WHERE SYM-QUERY-TRUE NIL) NIL)))))
       (CL:T NULL))
      (CL:SETQ
       STANDARDIZEDTREE
       (CANONICALIZE-QUANTIFICATION-TREE
        (CAST (STANDARDIZE-LOGICAL-PARSE-TREE QUERYTREE) SGT-QUERY-CONS)))
      (FIRST-SETTER STANDARDIZEDTREE SYM-QUERY-KAPPA))))
   (CL:RETURN-FROM CONS.STANDARDIZE-QUERY-TREE STANDARDIZEDTREE))
  :VOID)

;;; (DEFUN HANDLE-QUERY-EXCEPTION ...)

(CL:DEFUN HANDLE-QUERY-EXCEPTION (EXCEPTION COMMAND)
  (CL:LET*
   ((EXCEPTION-001 EXCEPTION))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? EXCEPTION SGT-QUERY-LOGIC-EXCEPTION) 1)
     (CL:LET*
      ((EXCEPTION NULL))
      (CL:SETQ EXCEPTION EXCEPTION-001)
      (CL:WHEN
       (CL:AND
        (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
        (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-EXCEPTIONS) 1))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING COMMAND %%STREAM)
        (CL:WRITE-STRING ": Caught " %%STREAM)
        (PRINT-OBJECT (PRIMARY-TYPE EXCEPTION) %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM)))))
    ((CL:EQ (TAXONOMY-ISA? EXCEPTION SGT-QUERY-EXCEPTION) 1)
     (CL:LET*
      ((EXCEPTION NULL))
      (CL:SETQ EXCEPTION EXCEPTION-001)
      (CL:WARN "`~A': Caught `~A'~%" COMMAND (PRIMARY-TYPE EXCEPTION))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" EXCEPTION))))
  :VOID)

;;; (DEFUN (MAKE-QUERY QUERY-ITERATOR) ...)

(CL:DEFUN MAKE-QUERY (QUERYTREE YESNO?)
  (CL:LET*
   ((PREFIXQUERYTREE (STANDARDIZE-QUERY-TREE QUERYTREE YESNO?)))
   (CL:LET*
    ((*EVALUATIONMODE* KWD-QUERY-QUERY)
     (*LOGICVARIABLETABLE* NIL)
     (*PROPOSITIONUNDERCONSTRUCTION* PREFIXQUERYTREE))
    (CL:DECLARE
     (CL:SPECIAL
      *EVALUATIONMODE*
      *LOGICVARIABLETABLE*
      *PROPOSITIONUNDERCONSTRUCTION*))
    (CL:LET*
     ((QUERYITERATOR
       (CREATE-QUERY-ITERATOR
        (EVALUATE-DESCRIPTION-TERM PREFIXQUERYTREE FALSE)
        NULL)))
     (FREE-CONS-TREE PREFIXQUERYTREE)
     (FREE-CONS-LIST *LOGICVARIABLETABLE*)
     (CL:RETURN-FROM MAKE-QUERY QUERYITERATOR))))
  :VOID)

;;; (DEFUN (RUN-YES-OR-NO-QUERY? BOOLEAN) ...)

(CL:DEFUN RUN-YES-OR-NO-QUERY? (QUERYITERATOR)
  (CL:LET*
   ((QUERYENVIRONMENT
     (CLSYS-SVAL QUERY-ITERATOR QUERY-ENVIRONMENT QUERYITERATOR)))
   (CL:LET*
    ((*QUERYENVIRONMENT* QUERYENVIRONMENT))
    (CL:DECLARE (CL:SPECIAL *QUERYENVIRONMENT*))
    (CL:WHEN
     (CL:EQ (NEXT? QUERYITERATOR) 1)
     (RELEASE-QUERY-THREAD QUERYENVIRONMENT)
     (CL:SETF
      (CLSYS-SVAL QUERY-ENVIRONMENT QUERY-THREAD-OFFSET QUERYENVIRONMENT)
      NULL-INTEGER)
     (CL:RETURN-FROM RUN-YES-OR-NO-QUERY? TRUE)))
   (CL:RETURN-FROM RUN-YES-OR-NO-QUERY? NULL-BOOLEAN))
  :VOID)

;;; (DEFUN (COERCE-TO-TREE OBJECT) ...)

(CL:DEFUN COERCE-TO-TREE (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (STRING? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       COERCE-TO-TREE
       (UNSTRINGIFY (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE SELF)))))
    (CL:T (CL:RETURN-FROM COERCE-TO-TREE SELF))))
  :VOID)

;;; (DEFUN (COERCE-TO-STRING STRING) ...)

(CL:DEFUN COERCE-TO-STRING (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (STRING? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       COERCE-TO-STRING
       (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE SELF))))
    ((CL:EQ (SYMBOL? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM COERCE-TO-STRING (CLSYS-SVAL SYMBOL SYMBOL-NAME SELF))))
    ((CL:EQ (KEYWORD? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       COERCE-TO-STRING
       (CLSYS-SVAL KEYWORD SYMBOL-NAME SELF))))
    ((CL:EQ (SURROGATE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       COERCE-TO-STRING
       (CLSYS-SVAL SURROGATE SYMBOL-NAME SELF))))
    (CL:T
     (CL:LET
      ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
      (CL:WRITE-STRING "Can't convert " %%STREAM)
      (PRINT-OBJECT SELF %%STREAM)
      (CL:WRITE-STRING " into a string." %%STREAM)
      (CL:TERPRI %%STREAM)
      (CL:FORCE-OUTPUT %%STREAM))
     (SIGNAL *THE-PARSING-ERROR*))))
  :VOID)

;;; (DEFUN (ASK BOOLEAN) ...)

(CL:DEFUN %%ASK (PROPOSITION)
  "Perform inference to determine whether `proposition' is true.
Return TRUE if `proposition' was found to be true; return NULL otherwise.
KIF example: `(ask (happy Fred))' will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic constant
`Fred' and the relation (or slot) `happy' must already be defined (see
`assert').  Use `(set/unset-feature goal-trace)' to en/disable goal tracing
of the inference engine."
  (CL:PROGN
   (CL:LET*
    ((*PENDINGEXCEPTIONHANDLER?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PENDINGEXCEPTIONHANDLER?*))
    (CL:CATCH
     *EXCEPTIONHANDLERADDRESS*
     (CL:PROGN
      (CL:LET*
       ((TREE (COERCE-TO-TREE PROPOSITION)))
       (FINALIZE-RELATIONS)
       (CL:IF
        (CL:NOT (CL:EQ TREE NULL))
        (CL:RETURN-FROM %%ASK (RUN-YES-OR-NO-QUERY? (MAKE-QUERY TREE TRUE)))
        (CL:RETURN-FROM %%ASK NULL-BOOLEAN)))
      (CL:SETQ *EXCEPTION* NULL))))
   (CL:WHEN
    (CL:NOT (CL:EQ *EXCEPTION* NULL))
    (CL:COND
     ((CL:EQ TRUE 1)
      (CL:LET*
       ((E *EXCEPTION*))
       (HANDLE-QUERY-EXCEPTION E "ask")
       (CL:RETURN-FROM %%ASK NULL-BOOLEAN))))))
  :VOID)

(CL:DEFUN ASK-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT (%%ASK (CLSYS-SVAL CONS VALUE ARGUMENTS))))
   (CL:IF
    (CL:EQ (DEFINED? RESULT) 1)
    (CL:RETURN-FROM ASK-EVALUATOR-WRAPPER (WRAP-BOOLEAN RESULT))
    (CL:RETURN-FROM ASK-EVALUATOR-WRAPPER NULL)))
  :VOID)

(CL:DEFMACRO ASK (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Perform inference to determine whether `proposition' is true.
Return TRUE if `proposition' was found to be true; return NULL otherwise.
KIF example: `(ask (happy Fred))' will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic constant
`Fred' and the relation (or slot) `happy' must already be defined (see
`assert').  Use `(set/unset-feature goal-trace)' to en/disable goal tracing
of the inference engine."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/ASK)) (CL:MACRO-FUNCTION (CL:QUOTE ASK)))

;;; (DEFMETHOD (RETRIEVE-BINDINGS QUERY-ITERATOR) ...)

(CL:DEFMETHOD RETRIEVE-BINDINGS ((QUERY QUERY-ITERATOR) NOFBINDINGS)
  (FINALIZE-RELATIONS)
  (CL:LET*
   ((*QUERYENVIRONMENT* (CLSYS-SVAL QUERY-ITERATOR QUERY-ENVIRONMENT QUERY)))
   (CL:DECLARE (CL:SPECIAL *QUERYENVIRONMENT*))
   (CL:LET*
    ((SOLUTION NULL)
     (I NULL)
     (ITER-001 1)
     (UPPER-BOUND-001 NOFBINDINGS)
     (UNBOUNDED?-001 (NULL? UPPER-BOUND-001))
     (ITER-002 QUERY))
    (CL:LOOP
     WHILE
     (CL:AND
      (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-001 UPPER-BOUND-001))
      (CL:EQ (NEXT? ITER-002) 1))
     DO
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:PROGN (CL:SETQ SOLUTION (CLSYS-SVAL QUERY-ITERATOR VALUE ITER-002)))
     (CL:PROGN (CL:SETQ SOLUTION SOLUTION) (CL:SETQ I I))))
   (CL:RETURN-FROM RETRIEVE-BINDINGS QUERY))
  :VOID)

;;; (DEFMETHOD (RETRIEVE-BINDINGS QUERY-ITERATOR) ...)

(CL:DEFMETHOD RETRIEVE-BINDINGS ((QUERY CONS) NOFBINDINGS)
  (FINALIZE-RELATIONS)
  (CL:WHEN
   (CL:AND (CL:= (LENGTH QUERY) 1) (CL:EQ (STRING? (FIRST QUERY)) 1))
   (CL:SETQ QUERY (CAST (COERCE-TO-TREE (FIRST QUERY)) SGT-QUERY-CONS)))
  (CL:RETURN-FROM
   RETRIEVE-BINDINGS
   (RETRIEVE-BINDINGS (MAKE-QUERY QUERY FALSE) NOFBINDINGS))
  :VOID)

;;; (DEFGLOBAL *MOST-RECENT-QUERY* ...)

(CL:DEFVAR *MOST-RECENT-QUERY* NULL)

;;; (DEFUN (RETRIEVE QUERY-ITERATOR) ...)

(CL:DEFUN %%RETRIEVE (QUERY)
  "Retrieve elements of a relation (tuples) that satisfy a proposition.
The accepted syntax is:
	 
  (retrieve [<integer> | all]
            [{<variable-spec> | (<variable-spec>+)}
             [<proposition>]])
	
The variables and proposition are similar to an `exists' sentence or
`kappa' term without the quantifier.  <proposition> usually contains
references to the listed variables.  No other free variable references
are allowed.  If <proposition> is omitted, it defaults to TRUE.  

A solution is a set of bindings for the listed variables for which
<proposition> is true.  The optional first argument controls how many
solutions should be generated before control is returned.  The keyword
`all' indicates that all solutions should be generated.  By default,
`retrieve' returns after it has found one new solution or if it cannot
find any more solutions.

`retrieve' returns an iterator which saves all the necessary state of
a query and stores all generated solutions.  When used interactively,
the returned iterator will print out with the set of solutions collected
so far.  Calling `retrieve' without any arguments (or only with the first
argument) will generate one (or more) solutions to the most recently
asked query.

KIF examples:
	 
  (retrieve (?x Person) (happy ?x)) 
	
will try to find the next happy person and store it in the returned 
query iterator.
	 
  (retrieve 10 (?x Person) (happy ?x))
	
will try to find 10 happy people.
	 
  (retrieve 10)
	
will try to find the next 10 happy people.
	 
  (retrieve all (?x Person) (happy ?x))
	
will find all happy people.
	 
  (retrieve all (?x Person))
	
will find all people.
	 
  (retrieve (?x Person) (or (happy ?x) (parent-of Fred ?x)))
	
will try to find the next person that is happy or has Fred as a parent.
	 
  (retrieve ((?x Person) (?y Person)) (parent-of ?x ?y))
	
will try to find the next pair of parent/child.
	 
  (retrieve all (?x Person)
            (exists (?y Person) (parent-of ?x ?y)))
	
will generate the set of all parents.  Note, that for these queries to run,
the class `Person', the relations `happy' and `parent-of', and the logic
constant `Fred' must already be defined (see `assert').

Use `(set/unset-feature goal-trace)' to en/disable goal tracing of the
inference engine."
  (CL:LET*
   ((FIRSTARG (FIRST QUERY)) (NOFBINDINGS 1))
   (CL:WHEN
    (CL:NOT (CL:EQ FIRSTARG NULL))
    (CL:LET*
     ((FIRSTARG-001 FIRSTARG))
     (CL:COND
      ((CL:EQ (INTEGER? FIRSTARG) 1)
       (CL:LET*
        ((FIRSTARG NULL))
        (CL:SETQ FIRSTARG FIRSTARG-001)
        (CL:SETQ
         NOFBINDINGS
         (CLSYS-SVAL INTEGER-WRAPPER WRAPPER-VALUE FIRSTARG))
        (CL:SETQ QUERY (CLSYS-SVAL CONS REST QUERY))))
      ((CL:EQ (SYMBOL? FIRSTARG) 1)
       (CL:LET*
        ((FIRSTARG NULL))
        (CL:SETQ FIRSTARG FIRSTARG-001)
        (CL:WHEN
         (CL:EQ
          (STRING-EQL? (CLSYS-SVAL SYMBOL SYMBOL-NAME FIRSTARG) "ALL")
          1)
         (CL:SETQ NOFBINDINGS NULL-INTEGER)
         (CL:SETQ QUERY (CLSYS-SVAL CONS REST QUERY)))))
      ((CL:EQ (KEYWORD? FIRSTARG) 1)
       (CL:LET*
        ((FIRSTARG NULL))
        (CL:SETQ FIRSTARG FIRSTARG-001)
        (CL:WHEN
         (CL:EQ
          (STRING-EQL? (CLSYS-SVAL KEYWORD SYMBOL-NAME FIRSTARG) "ALL")
          1)
         (CL:SETQ NOFBINDINGS NULL-INTEGER)
         (CL:SETQ QUERY (CLSYS-SVAL CONS REST QUERY)))))
      (CL:T NULL))))
   (CL:PROGN
    (CL:LET*
     ((*PENDINGEXCEPTIONHANDLER?* TRUE))
     (CL:DECLARE (CL:SPECIAL *PENDINGEXCEPTIONHANDLER?*))
     (CL:CATCH
      *EXCEPTIONHANDLERADDRESS*
      (CL:PROGN
       (CL:IF
        (CL:AND (CL:EQ QUERY NIL) (CL:NOT (CL:EQ *MOST-RECENT-QUERY* NULL)))
        (CL:RETURN-FROM
         %%RETRIEVE
         (RETRIEVE-BINDINGS *MOST-RECENT-QUERY* NOFBINDINGS))
        (CL:RETURN-FROM
         %%RETRIEVE
         (CL:SETQ *MOST-RECENT-QUERY* (RETRIEVE-BINDINGS QUERY NOFBINDINGS))))
       (CL:SETQ *EXCEPTION* NULL))))
    (CL:WHEN
     (CL:NOT (CL:EQ *EXCEPTION* NULL))
     (CL:COND
      ((CL:EQ TRUE 1)
       (CL:LET*
        ((E *EXCEPTION*))
        (HANDLE-QUERY-EXCEPTION E "retrieve")
        (CL:RETURN-FROM %%RETRIEVE NULL)))))))
  :VOID)

(CL:DEFUN RETRIEVE-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM RETRIEVE-EVALUATOR-WRAPPER (%%RETRIEVE ARGUMENTS))
  :VOID)

(CL:DEFMACRO RETRIEVE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Retrieve elements of a relation (tuples) that satisfy a proposition.
The accepted syntax is:
	 
  (retrieve [<integer> | all]
            [{<variable-spec> | (<variable-spec>+)}
             [<proposition>]])
	
The variables and proposition are similar to an `exists' sentence or
`kappa' term without the quantifier.  <proposition> usually contains
references to the listed variables.  No other free variable references
are allowed.  If <proposition> is omitted, it defaults to TRUE.  

A solution is a set of bindings for the listed variables for which
<proposition> is true.  The optional first argument controls how many
solutions should be generated before control is returned.  The keyword
`all' indicates that all solutions should be generated.  By default,
`retrieve' returns after it has found one new solution or if it cannot
find any more solutions.

`retrieve' returns an iterator which saves all the necessary state of
a query and stores all generated solutions.  When used interactively,
the returned iterator will print out with the set of solutions collected
so far.  Calling `retrieve' without any arguments (or only with the first
argument) will generate one (or more) solutions to the most recently
asked query.

KIF examples:
	 
  (retrieve (?x Person) (happy ?x)) 
	
will try to find the next happy person and store it in the returned 
query iterator.
	 
  (retrieve 10 (?x Person) (happy ?x))
	
will try to find 10 happy people.
	 
  (retrieve 10)
	
will try to find the next 10 happy people.
	 
  (retrieve all (?x Person) (happy ?x))
	
will find all happy people.
	 
  (retrieve all (?x Person))
	
will find all people.
	 
  (retrieve (?x Person) (or (happy ?x) (parent-of Fred ?x)))
	
will try to find the next person that is happy or has Fred as a parent.
	 
  (retrieve ((?x Person) (?y Person)) (parent-of ?x ?y))
	
will try to find the next pair of parent/child.
	 
  (retrieve all (?x Person)
            (exists (?y Person) (parent-of ?x ?y)))
	
will generate the set of all parents.  Note, that for these queries to run,
the class `Person', the relations `happy' and `parent-of', and the logic
constant `Fred' must already be defined (see `assert').

Use `(set/unset-feature goal-trace)' to en/disable goal tracing of the
inference engine."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET
   ((*IGNORETRANSLATIONERRORS?* FALSE))
   (INCREMENTALLY-TRANSLATE EXPRESSION FALSE)))

(SETF (CL:MACRO-FUNCTION (CL:QUOTE /LOGIC/RETRIEVE)) (CL:MACRO-FUNCTION (CL:QUOTE RETRIEVE)))

;;; (DEFUN (GET-SUBSUMPTION-DEFINITION DESCRIPTION) ...)

(CL:DEFUN GET-SUBSUMPTION-DEFINITION (SELF SUBORSUPER)
  (CL:SETQ SUBORSUPER SUBORSUPER)
  (CL:RETURN-FROM
   GET-SUBSUMPTION-DEFINITION
   (CL:IF
    (CL:AND
     (CL:NOT (CL:EQ (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF) NULL))
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE
        (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF)
        SYM-QUERY-DEFINITION
        NULL)
       NULL)))
    (DYNAMIC-SLOT-VALUE
     (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF)
     SYM-QUERY-DEFINITION
     NULL)
    SELF))
  :VOID)

;;; (DEFUN (DESCRIPTION-SPECIALIZES-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN DESCRIPTION-SPECIALIZES-DESCRIPTION? (SUB SUPER)
  (CL:WHEN
   (CL:EQ (COLLECTION-IMPLIES-COLLECTION? SUB SUPER) 1)
   (CL:RETURN-FROM DESCRIPTION-SPECIALIZES-DESCRIPTION? TRUE))
  (CL:WHEN
   (CL:AND
    (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (CL:EQ (MEMBER? *TRACED-KEYWORDS* KWD-QUERY-GOAL-TREE) 1))
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "Subsumption Test:" %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM)))
  (CL:PROGN
   (CL:LET*
    ((*PENDINGEXCEPTIONHANDLER?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PENDINGEXCEPTIONHANDLER?*))
    (CL:CATCH
     *EXCEPTIONHANDLERADDRESS*
     (CL:PROGN
      (CL:LET*
       ((SUBDESCRIPTION (GET-SUBSUMPTION-DEFINITION SUB KWD-QUERY-SUB))
        (SUPERDESCRIPTION (GET-SUBSUMPTION-DEFINITION SUPER KWD-QUERY-SUPER))
        (QUERYITERATOR
         (CREATE-QUERY-ITERATOR
          SUPERDESCRIPTION
          (CLSYS-SVAL DESCRIPTION IO-VARIABLES SUBDESCRIPTION)))
        (QUERYENVIRONMENT
         (CLSYS-SVAL QUERY-ITERATOR QUERY-ENVIRONMENT QUERYITERATOR))
        (PUSHEDWORLD? FALSE)
        (RESULT? FALSE))
       (CL:SETF
        (CLSYS-SVAL QUERY-ENVIRONMENT SUBSUMPTION-QUERY? QUERYENVIRONMENT)
        TRUE)
       (CL:SETF
        (CLSYS-SVAL
         QUERY-ENVIRONMENT
         SPECIALIZING-DESCRIPTION
         QUERYENVIRONMENT)
        SUBDESCRIPTION)
       (CL:WHEN
        (CL:EQ
         (UNKNOWN? (CLSYS-SVAL DESCRIPTION PROPOSITION SUBDESCRIPTION))
         1)
        (PUSH-WORLD)
        (SET-DYNAMIC-SLOT-VALUE
         (CAST *CONTEXT* SGT-QUERY-WORLD)
         SYM-QUERY-MONOTONIC?
         (WRAP-BOOLEAN TRUE)
         NULL-BOOLEAN-WRAPPER)
        (CL:SETQ PUSHEDWORLD? TRUE)
        (ASSIGN-TRUTH-VALUE
         (CLSYS-SVAL DESCRIPTION PROPOSITION SUBDESCRIPTION)
         TRUE))
       (CL:SETQ RESULT? (DEFINED? (RUN-YES-OR-NO-QUERY? QUERYITERATOR)))
       (CL:WHEN (CL:EQ PUSHEDWORLD? 1) (POP-WORLD))
       (CL:RETURN-FROM DESCRIPTION-SPECIALIZES-DESCRIPTION? RESULT?))
      (CL:SETQ *EXCEPTION* NULL))))
   (CL:WHEN
    (CL:NOT (CL:EQ *EXCEPTION* NULL))
    (CL:COND
     ((CL:EQ TRUE 1)
      (CL:LET*
       ((E *EXCEPTION*))
       (HANDLE-QUERY-EXCEPTION E "specializes?")
       (CL:RETURN-FROM DESCRIPTION-SPECIALIZES-DESCRIPTION? FALSE))))))
  :VOID)

;;; (DEFUN (VECTOR-SATISFIES-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN VECTOR-SATISFIES-DESCRIPTION? (VECTOR DESCRIPTION)
  (CL:PROGN
   (CL:LET*
    ((*PENDINGEXCEPTIONHANDLER?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PENDINGEXCEPTIONHANDLER?*))
    (CL:CATCH
     *EXCEPTIONHANDLERADDRESS*
     (CL:PROGN
      (CL:LET*
       ((TEST-VALUE-001 FALSE))
       (CL:SETQ TEST-VALUE-001 (EQ? (LENGTH VECTOR) (ARITY DESCRIPTION)))
       (CL:WHEN
        (CL:EQ TEST-VALUE-001 1)
        (CL:LET*
         ((ALWAYS?-001 TRUE))
         (CL:LET*
          ((VALUE NULL)
           (VECTOR-001 VECTOR)
           (INDEX-001 0)
           (LENGTH-001 (LENGTH VECTOR-001)))
          (CL:LOOP
           WHILE
           (CL:< INDEX-001 LENGTH-001)
           DO
           (CL:PROGN
            (CL:SETQ
             VALUE
             (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
            (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
           (CL:WHEN
            (CL:EQ VALUE NULL)
            (CL:SETQ ALWAYS?-001 FALSE)
            (CL:RETURN))))
         (CL:SETQ TEST-VALUE-001 ALWAYS?-001))
        (CL:WHEN
         (CL:EQ TEST-VALUE-001 1)
         (CL:SETQ
          TEST-VALUE-001
          (DEFINED?
           (RUN-YES-OR-NO-QUERY?
            (CREATE-QUERY-ITERATOR DESCRIPTION VECTOR))))))
       (CL:LET*
        ((VALUE-001 TEST-VALUE-001))
        (CL:RETURN-FROM VECTOR-SATISFIES-DESCRIPTION? VALUE-001)))
      (CL:SETQ *EXCEPTION* NULL))))
   (CL:WHEN
    (CL:NOT (CL:EQ *EXCEPTION* NULL))
    (CL:COND
     ((CL:EQ TRUE 1)
      (CL:LET*
       ((E *EXCEPTION*))
       (HANDLE-QUERY-EXCEPTION E "satisfies?")
       (CL:RETURN-FROM VECTOR-SATISFIES-DESCRIPTION? FALSE))))))
  :VOID)

;;; (DEFGLOBAL REUSABLE-SINGLETON-VECTOR ...)

(CL:DEFVAR REUSABLE-SINGLETON-VECTOR NULL
  "Used by 'instance-satisfies-description?'.")

;;; (DEFUN (INSTANCE-SATISFIES-DESCRIPTION? BOOLEAN) ...)

(CL:DEFUN INSTANCE-SATISFIES-DESCRIPTION? (INSTANCE DESCRIPTION)
  (CL:SETF
   (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY REUSABLE-SINGLETON-VECTOR) 0)
   INSTANCE)
  (CL:RETURN-FROM
   INSTANCE-SATISFIES-DESCRIPTION?
   (VECTOR-SATISFIES-DESCRIPTION? REUSABLE-SINGLETON-VECTOR DESCRIPTION))
  :VOID)

;;; (DEFUN (COERCE-TO-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN COERCE-TO-DESCRIPTION (SELF ORIGINAL)
  (CL:WHEN (CL:EQ ORIGINAL NULL) (CL:SETQ ORIGINAL SELF))
  (CL:WHEN
   (CL:EQ SELF NULL)
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "Can't find a description for the object `" %%STREAM)
    (PRINT-OBJECT ORIGINAL %%STREAM)
    (CL:WRITE-STRING "'." %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (CL:RETURN-FROM COERCE-TO-DESCRIPTION NULL))
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-DESCRIPTION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM COERCE-TO-DESCRIPTION SELF)))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-RELATION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM COERCE-TO-DESCRIPTION (GET-DESCRIPTION SELF))))
    ((CL:EQ (SURROGATE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       COERCE-TO-DESCRIPTION
       (COERCE-TO-DESCRIPTION
        (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)
        ORIGINAL))))
    ((CL:EQ (SYMBOL? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       COERCE-TO-DESCRIPTION
       (COERCE-TO-DESCRIPTION
        (LOOKUP-SURROGATE-IN-MODULE
         (CLSYS-SVAL SYMBOL SYMBOL-NAME SELF)
         (CAST (CLSYS-SVAL SYMBOL HOME-CONTEXT SELF) SGT-QUERY-MODULE)
         FALSE)
        ORIGINAL))))
    ((CL:EQ (KEYWORD? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       COERCE-TO-DESCRIPTION
       (COERCE-TO-DESCRIPTION
        (LOOKUP-SURROGATE (CLSYS-SVAL KEYWORD SYMBOL-NAME SELF))
        ORIGINAL))))
    ((CL:EQ (STRING? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       COERCE-TO-DESCRIPTION
       (COERCE-TO-DESCRIPTION
        (LOOKUP-SURROGATE (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE SELF))
        ORIGINAL))))
    (CL:T
     (CL:RETURN-FROM
      COERCE-TO-DESCRIPTION
      (COERCE-TO-DESCRIPTION NULL ORIGINAL)))))
  :VOID)

;;; (DEFUN (SPECIALIZES? BOOLEAN) ...)

(CL:DEFUN SPECIALIZES? (SUBOBJECT SUPEROBJECT)
  "Return TRUE if the description associated with `subObject'
specializes the description for `superObject'.  Return FALSE if we could
not prove that `subObject' specializes `superObject'."
  (CL:LET*
   ((SUBDESCRIPTION (COERCE-TO-DESCRIPTION SUBOBJECT NULL))
    (SUPERDESCRIPTION (COERCE-TO-DESCRIPTION SUPEROBJECT NULL)))
   (FINALIZE-RELATIONS)
   (CL:LET*
    ((*CONTEXT* (GET-CONSTRAINT-PROPAGATION-WORLD *CONTEXT*)))
    (CL:DECLARE (CL:SPECIAL *CONTEXT*))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (CLSYS-SVAL WORLD BASE-MODULE (CAST *CONTEXT* SGT-QUERY-WORLD))
       *MODULE*))
     (CL:ERROR
      "Safety violation: within-world: world `~A' does not have a base module"
      *CONTEXT*))
    (CL:RETURN-FROM
     SPECIALIZES?
     (CL:IF
      (CL:AND
       (CL:NOT (CL:EQ SUBDESCRIPTION NULL))
       (CL:NOT (CL:EQ SUPERDESCRIPTION NULL))
       (CL:EQ
        (DESCRIPTION-SPECIALIZES-DESCRIPTION? SUBDESCRIPTION SUPERDESCRIPTION)
        1))
      TRUE
      FALSE))))
  :VOID)

;;; (DEFUN (COERCE-TO-INSTANCE LOGIC-OBJECT) ...)

(CL:DEFUN COERCE-TO-INSTANCE (SELF ORIGINAL)
  (CL:WHEN (CL:EQ ORIGINAL NULL) (CL:SETQ ORIGINAL SELF))
  (CL:WHEN
   (CL:EQ SELF NULL)
   (CL:LET
    ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
    (CL:WRITE-STRING "Can't find a logic object `" %%STREAM)
    (PRINT-OBJECT ORIGINAL %%STREAM)
    (CL:WRITE-STRING "'." %%STREAM)
    (CL:TERPRI %%STREAM)
    (CL:FORCE-OUTPUT %%STREAM))
   (CL:RETURN-FROM COERCE-TO-INSTANCE NULL))
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-LOGIC-OBJECT) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM COERCE-TO-INSTANCE SELF)))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-RELATION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM COERCE-TO-INSTANCE (GET-DESCRIPTION SELF))))
    ((CL:EQ (SURROGATE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       COERCE-TO-INSTANCE
       (COERCE-TO-INSTANCE
        (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)
        ORIGINAL))))
    ((CL:EQ (SYMBOL? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       COERCE-TO-INSTANCE
       (COERCE-TO-INSTANCE
        (LOOKUP-SURROGATE-IN-MODULE
         (CLSYS-SVAL SYMBOL SYMBOL-NAME SELF)
         (CAST (CLSYS-SVAL SYMBOL HOME-CONTEXT SELF) SGT-QUERY-MODULE)
         FALSE)
        ORIGINAL))))
    ((CL:EQ (KEYWORD? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       COERCE-TO-INSTANCE
       (COERCE-TO-INSTANCE
        (LOOKUP-SURROGATE (CLSYS-SVAL KEYWORD SYMBOL-NAME SELF))
        ORIGINAL))))
    ((CL:EQ (STRING? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       COERCE-TO-INSTANCE
       (COERCE-TO-INSTANCE
        (LOOKUP-SURROGATE (CLSYS-SVAL STRING-WRAPPER WRAPPER-VALUE SELF))
        ORIGINAL))))
    (CL:T
     (CL:RETURN-FROM COERCE-TO-INSTANCE (COERCE-TO-INSTANCE NULL ORIGINAL)))))
  :VOID)

;;; (DEFUN (COERCE-TO-VECTOR VECTOR) ...)

(CL:DEFUN COERCE-TO-VECTOR (SELF)
  (CL:LET*
   ((VECTOR NULL))
   (CL:LET*
    ((SELF-001 SELF))
    (CL:COND
     ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-VECTOR) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:SETQ VECTOR SELF)
       (CL:LET*
        ((I NULL)
         (M NULL)
         (VECTOR-001 SELF)
         (INDEX-001 0)
         (LENGTH-001 (LENGTH VECTOR-001))
         (ITER-001 0))
        (CL:LOOP
         WHILE
         (CL:< INDEX-001 LENGTH-001)
         DO
         (CL:PROGN
          (CL:SETQ
           M
           (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
          (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
         (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
         (CL:SETF
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR) I)
          (COERCE-TO-INSTANCE M NULL))))))
     ((CL:EQ (TAXONOMY-ISA? SELF SGT-QUERY-LIST) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:SETQ VECTOR (NEW-VECTOR (LENGTH SELF)))
       (CL:LET*
        ((I NULL)
         (M NULL)
         (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST SELF))
         (ITER-003 0))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-002 NIL))
         DO
         (CL:PROGN
          (CL:SETQ M (CLSYS-SVAL CONS VALUE ITER-002))
          (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
         (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
         (CL:SETF
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR) I)
          (COERCE-TO-INSTANCE M NULL))))))
     ((CL:EQ (CONS? SELF) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:SETQ VECTOR (NEW-VECTOR (LENGTH SELF)))
       (CL:LET*
        ((I NULL) (M NULL) (ITER-004 SELF) (ITER-005 0))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-004 NIL))
         DO
         (CL:PROGN
          (CL:SETQ M (CLSYS-SVAL CONS VALUE ITER-004))
          (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
         (CL:PROGN (CL:SETQ I ITER-005) (CL:SETQ ITER-005 (CL:1+ ITER-005)))
         (CL:SETF
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR) I)
          (COERCE-TO-INSTANCE M NULL))))))
     (CL:T
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "Don't know how to coerce `" %%STREAM)
       (PRINT-OBJECT SELF %%STREAM)
       (CL:WRITE-STRING "' of type `" %%STREAM)
       (PRINT-OBJECT (PRIMARY-TYPE SELF) %%STREAM)
       (CL:WRITE-STRING "'" %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)
       (CL:WRITE-STRING "   into a vector." %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))))
   (CL:RETURN-FROM COERCE-TO-VECTOR VECTOR))
  :VOID)

;;; (DEFUN (SATISFIES? BOOLEAN) ...)

(CL:DEFUN SATISFIES? (INSTANCEORTUPLE RELATIONREF)
  "Return TRUE if `instanceOrTuple' satisfies the
definition of the relation `relationRef'.  `instanceOrTuple' can be a single
object, the name or surrogate of an object, or a collection (a list or vector)
of objects. `relationRef' can be a relation, description, surrogate or relation
name.  Return FALSE if we could not prove that `instanceOrTuple' satisfies
`relationRef'."
  (CL:LET*
   ((DESCRIPTION (COERCE-TO-DESCRIPTION RELATIONREF NULL)))
   (CL:WHEN
    (CL:NOT (CL:EQ DESCRIPTION NULL))
    (FINALIZE-RELATIONS)
    (CL:LET*
     ((*CONTEXT* (GET-CONSTRAINT-PROPAGATION-WORLD *CONTEXT*)))
     (CL:DECLARE (CL:SPECIAL *CONTEXT*))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (CLSYS-SVAL WORLD BASE-MODULE (CAST *CONTEXT* SGT-QUERY-WORLD))
        *MODULE*))
      (CL:ERROR
       "Safety violation: within-world: world `~A' does not have a base module"
       *CONTEXT*))
     (CL:IF
      (CL:OR
       (CL:EQ (ISA? INSTANCEORTUPLE SGT-QUERY-COLLECTION) 1)
       (CL:EQ (CONS? INSTANCEORTUPLE) 1))
      (CL:LET*
       ((VECTOR (COERCE-TO-VECTOR INSTANCEORTUPLE)))
       (CL:RETURN-FROM
        SATISFIES?
        (CL:IF
         (CL:AND
          (CL:NOT (CL:EQ VECTOR NULL))
          (CL:EQ (VECTOR-SATISFIES-DESCRIPTION? VECTOR DESCRIPTION) 1))
         TRUE
         FALSE)))
      (CL:LET*
       ((INSTANCE (COERCE-TO-INSTANCE INSTANCEORTUPLE NULL)))
       (CL:RETURN-FROM
        SATISFIES?
        (CL:IF
         (CL:AND
          (CL:NOT (CL:EQ INSTANCE NULL))
          (CL:EQ (INSTANCE-SATISFIES-DESCRIPTION? INSTANCE DESCRIPTION) 1))
         TRUE
         FALSE))))))
   (CL:RETURN-FROM SATISFIES? FALSE))
  :VOID)

(CL:DEFUN STARTUP-QUERY ()
  (CL:WHEN
   (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 0) 1)
   (CL:SETQ *RECYCLED-QUERY-ENVIRONMENT-S* (MAKE-NON-RECYCLED-LIST)))
  (CL:LET*
   ((*MODULE* (GET-MODULE "/LOGIC" TRUE)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SYM-QUERY-QUERY-ENVIRONMENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-ENVIRONMENT" NULL 0))
    (CL:SETQ
     SYM-QUERY-EXTERNAL-VARIABLES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTERNAL-VARIABLES" NULL 0))
    (CL:SETQ
     SYM-QUERY-SOLUTIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SOLUTIONS" NULL 0))
    (CL:SETQ
     SYM-QUERY-EXHAUSTED?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXHAUSTED?" NULL 0))
    (CL:SETQ
     SGT-QUERY-QUERY-ENVIRONMENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-ENVIRONMENT" NULL 1))
    (CL:SETQ
     SGT-QUERY-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-QUERY-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-QUERY-BOOLEAN-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "BOOLEAN-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-QUERY-QUERY-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-ITERATOR" NULL 1))
    (CL:SETQ
     SYM-QUERY-STATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STATE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-QUERY-PHASE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PHASE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-QUERY-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 0))
    (CL:SETQ
     SYM-QUERY-REVERSE-POLARITY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REVERSE-POLARITY?" NULL 0))
    (CL:SETQ SYM-QUERY-UP (INTERN-RIGID-SYMBOL-WRT-MODULE "UP" NULL 0))
    (CL:SETQ SYM-QUERY-DOWN (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWN" NULL 0))
    (CL:SETQ SYM-QUERY-BACK (INTERN-RIGID-SYMBOL-WRT-MODULE "BACK" NULL 0))
    (CL:SETQ
     SYM-QUERY-ARGUMENT-CURSOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-CURSOR" NULL 0))
    (CL:SETQ
     SYM-QUERY-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "ITERATOR"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-QUERY-SUBQUERY-FRAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBQUERY-FRAME" NULL 0))
    (CL:SETQ
     SYM-QUERY-PARENT-PATTERN-FRAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT-PATTERN-FRAME" NULL 0))
    (CL:SETQ
     SYM-QUERY-GOAL-CACHE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-CACHE" NULL 0))
    (CL:SETQ
     SYM-QUERY-PARTIAL-MATCH-FRAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL-MATCH-FRAME" NULL 0))
    (CL:SETQ
     SYM-QUERY-DEBUG-FRAME-OFFSET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEBUG-FRAME-OFFSET" NULL 0))
    (CL:SETQ
     SYM-QUERY-DEBUG-DEPTH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEBUG-DEPTH" NULL 0))
    (CL:SETQ
     SYM-QUERY-CHOICE-POINT-UNBINDING-OFFSET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CHOICE-POINT-UNBINDING-OFFSET" NULL 0))
    (CL:SETQ
     SGT-QUERY-KEYWORD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-QUERY-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
    (CL:SETQ
     SGT-QUERY-CONTROL-FRAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTROL-FRAME" NULL 1))
    (CL:SETQ
     SGT-QUERY-INTEGER-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "INTEGER-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-QUERY-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "ITERATOR"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-QUERY-SUBQUERY-FRAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBQUERY-FRAME" NULL 1))
    (CL:SETQ
     SGT-QUERY-GOAL-CACHE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-CACHE" NULL 1))
    (CL:SETQ
     SGT-QUERY-PARTIAL-MATCH-FRAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL-MATCH-FRAME" NULL 1))
    (CL:SETQ
     SYM-QUERY-KIND-OF-GOAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KIND-OF-GOAL" NULL 0))
    (CL:SETQ
     SYM-QUERY-STRATEGY-PRIORITY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRATEGY-PRIORITY" NULL 0))
    (CL:SETQ
     SYM-QUERY-STRATEGY-PROCEDURE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STRATEGY-PROCEDURE" NULL 0))
    (CL:SETQ
     SGT-QUERY-FUNCTION-CODE-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "FUNCTION-CODE-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-QUERY-GOAL-STRATEGY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-STRATEGY" NULL 1))
    (CL:SETQ
     SYM-QUERY-CONTROL-FRAME-STACK
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTROL-FRAME-STACK" NULL 0))
    (CL:SETQ
     SYM-QUERY-CONTROL-FRAME-OFFSET-LIMIT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTROL-FRAME-OFFSET-LIMIT" NULL 0))
    (CL:SETQ
     SYM-QUERY-TOP-CONTROL-FRAME-OFFSET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TOP-CONTROL-FRAME-OFFSET" NULL 0))
    (CL:SETQ
     SYM-QUERY-VARIABLE-FRAME-STACK
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-FRAME-STACK" NULL 0))
    (CL:SETQ
     SYM-QUERY-VARIABLE-FRAME-OFFSET-LIMIT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-FRAME-OFFSET-LIMIT" NULL 0))
    (CL:SETQ
     SYM-QUERY-TOP-VARIABLE-FRAME-OFFSET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TOP-VARIABLE-FRAME-OFFSET" NULL 0))
    (CL:SETQ
     SYM-QUERY-UNBINDING-STACK
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBINDING-STACK" NULL 0))
    (CL:SETQ
     SYM-QUERY-UNBINDING-STACK-OFFSET-LIMIT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBINDING-STACK-OFFSET-LIMIT" NULL 0))
    (CL:SETQ
     SYM-QUERY-TOP-UNBINDING-STACK-OFFSET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TOP-UNBINDING-STACK-OFFSET" NULL 0))
    (CL:SETQ
     SYM-QUERY-CURRENT-VARIABLE-FRAME-OFFSET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-VARIABLE-FRAME-OFFSET" NULL 0))
    (CL:SETQ
     SYM-QUERY-CURRENT-SUBQUERY-FRAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-SUBQUERY-FRAME" NULL 0))
    (CL:SETQ
     SYM-QUERY-PARTIAL-MATCH-STRATEGY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL-MATCH-STRATEGY" NULL 0))
    (CL:SETQ
     SYM-QUERY-LATEST-POSITIVE-SCORE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LATEST-POSITIVE-SCORE" NULL 0))
    (CL:SETQ
     SYM-QUERY-ITERATIVE-DEEPENING?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATIVE-DEEPENING?" NULL 0))
    (CL:SETQ
     SYM-QUERY-CURRENT-DEPTH-CUTOFF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-DEPTH-CUTOFF" NULL 0))
    (CL:SETQ
     SYM-QUERY-MAXIMUM-DEPTH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MAXIMUM-DEPTH" NULL 0))
    (CL:SETQ
     SYM-QUERY-AUGMENTED-GOAL-CACHE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AUGMENTED-GOAL-CACHE?" NULL 0))
    (CL:SETQ
     SYM-QUERY-ACTIVE-GOAL-CACHES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-GOAL-CACHES" NULL 0))
    (CL:SETQ
     SYM-QUERY-TRIGGERED-DEPTH-CUTOFF?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRIGGERED-DEPTH-CUTOFF?" NULL 0))
    (CL:SETQ
     SYM-QUERY-FAILED-TO-FIND-DUPLICATE-SUBGOAL?
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "FAILED-TO-FIND-DUPLICATE-SUBGOAL?"
      NULL
      0))
    (CL:SETQ
     SYM-QUERY-FOUND-AT-LEAST-ONE-SOLUTION?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FOUND-AT-LEAST-ONE-SOLUTION?" NULL 0))
    (CL:SETQ
     SYM-QUERY-DEEP-INFERENCE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEEP-INFERENCE?" NULL 0))
    (CL:SETQ
     SYM-QUERY-QUERY-THREAD-OFFSET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-THREAD-OFFSET" NULL 0))
    (CL:SETQ
     SYM-QUERY-TIME-STAMP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TIME-STAMP" NULL 0))
    (CL:SETQ
     SYM-QUERY-QUERY-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-ITERATOR" NULL 0))
    (CL:SETQ
     SYM-QUERY-SUBSUMPTION-QUERY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-QUERY?" NULL 0))
    (CL:SETQ
     SYM-QUERY-SPECIALIZING-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIALIZING-DESCRIPTION" NULL 0))
    (CL:SETQ
     SYM-QUERY-OPTIMIZER-GOAL-RECORDS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTIMIZER-GOAL-RECORDS" NULL 0))
    (CL:SETQ
     SYM-QUERY-RESIDUE-GOALS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RESIDUE-GOALS" NULL 0))
    (CL:SETQ
     SYM-QUERY-BEST-GOAL-SEQUENCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BEST-GOAL-SEQUENCE" NULL 0))
    (CL:SETQ
     SYM-QUERY-BEST-COST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BEST-COST" NULL 0))
    (CL:SETQ
     SGT-QUERY-INTEGER-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "INTEGER-VECTOR"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-QUERY-FLOAT-WRAPPER
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "FLOAT-WRAPPER"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-QUERY-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
    (CL:SETQ
     SGT-QUERY-EXTENSIBLE-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "EXTENSIBLE-VECTOR"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-QUERY-*QUERYENVIRONMENT*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*QUERYENVIRONMENT*" NULL 0))
    (CL:SETQ
     SYM-QUERY-CONTROL-FRAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTROL-FRAME" NULL 0))
    (CL:SETQ
     SYM-QUERY-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
    (CL:SETQ
     SYM-QUERY-EXTERNAL-ARGUMENTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTERNAL-ARGUMENTS" NULL 0))
    (CL:SETQ
     SYM-QUERY-BOOLEAN-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "BOOLEAN-VECTOR"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-QUERY-LOCAL-VARIABLE-FRAME-OFFSET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOCAL-VARIABLE-FRAME-OFFSET" NULL 0))
    (CL:SETQ
     SYM-QUERY-OPTIMAL-PATTERN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTIMAL-PATTERN" NULL 0))
    (CL:SETQ
     SYM-QUERY-PHASES-FILTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PHASES-FILTER" NULL 0))
    (CL:SETQ
     SGT-QUERY-BOOLEAN-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "BOOLEAN-VECTOR"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-QUERY-TRUE-LINK
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE-LINK" NULL 0))
    (CL:SETQ
     SYM-QUERY-FALSE-LINK
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE-LINK" NULL 0))
    (CL:SETQ
     SYM-QUERY-VECTOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SGT-QUERY-BOOLEAN-VECTOR-INDEX-NODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-VECTOR-INDEX-NODE" NULL 1))
    (CL:SETQ
     SGT-QUERY-PATTERN-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
    (CL:SETQ
     KWD-QUERY-QUERY-STACKS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-STACKS" NULL 2))
    (CL:SETQ
     KWD-QUERY-PATTERN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN" NULL 2))
    (CL:SETQ
     KWD-QUERY-CONTAINED-BY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTAINED-BY" NULL 2))
    (CL:SETQ
     KWD-QUERY-POPPED
     (INTERN-RIGID-SYMBOL-WRT-MODULE "POPPED" NULL 2))
    (CL:SETQ KWD-QUERY-LOCAL (INTERN-RIGID-SYMBOL-WRT-MODULE "LOCAL" NULL 2))
    (CL:SETQ
     KWD-QUERY-PARENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT" NULL 2))
    (CL:SETQ
     SGT-QUERY-LOGIC-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
    (CL:SETQ
     SGT-QUERY-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ KWD-QUERY-SORT (INTERN-RIGID-SYMBOL-WRT-MODULE "SORT" NULL 2))
    (CL:SETQ KWD-QUERY-NONE (INTERN-RIGID-SYMBOL-WRT-MODULE "NONE" NULL 2))
    (CL:SETQ KWD-QUERY-IN (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 2))
    (CL:SETQ
     SGT-QUERY-SURROGATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "SURROGATE"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-QUERY-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-QUERY-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     KWD-QUERY-SHALLOW-DISJOINT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SHALLOW-DISJOINT" NULL 2))
    (CL:SETQ
     KWD-QUERY-DISJOINT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DISJOINT" NULL 2))
    (CL:SETQ
     SGT-QUERY-SLOTREF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTREF" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-QUERY-SKOLEM-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM-NAME" NULL 0))
    (CL:SETQ KWD-QUERY-DOWN (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWN" NULL 2))
    (CL:SETQ
     KWD-QUERY-ITERATIVE-FORALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATIVE-FORALL" NULL 2))
    (CL:SETQ
     KWD-QUERY-STATE-MACHINE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STATE-MACHINE" NULL 2))
    (CL:SETQ
     KWD-QUERY-SUBGOALS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBGOALS" NULL 2))
    (CL:SETQ
     KWD-QUERY-TERMINATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TERMINATION" NULL 2))
    (CL:SETQ
     KWD-QUERY-ANTECEDENTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS" NULL 2))
    (CL:SETQ
     KWD-QUERY-REALISTIC
     (INTERN-RIGID-SYMBOL-WRT-MODULE "REALISTIC" NULL 2))
    (CL:SETQ
     KWD-QUERY-COMPLEMENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT" NULL 2))
    (CL:SETQ
     KWD-QUERY-UP-TRUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TRUE" NULL 2))
    (CL:SETQ
     KWD-QUERY-UP-FAIL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-FAIL" NULL 2))
    (CL:SETQ KWD-QUERY-AND (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
    (CL:SETQ KWD-QUERY-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
    (CL:SETQ KWD-QUERY-NOT (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
    (CL:SETQ
     KWD-QUERY-INITIAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIAL" NULL 2))
    (CL:SETQ
     KWD-QUERY-GOAL-TREE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-TREE" NULL 2))
    (CL:SETQ
     KWD-QUERY-SELECT-STRATEGY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SELECT-STRATEGY" NULL 2))
    (CL:SETQ
     KWD-QUERY-HEAVY-DUTY-DISJUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "HEAVY-DUTY-DISJUNCTION" NULL 2))
    (CL:SETQ
     KWD-QUERY-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     KWD-QUERY-PREDICATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
    (CL:SETQ
     KWD-QUERY-EQUIVALENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
    (CL:SETQ
     KWD-QUERY-IMPLIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
    (CL:SETQ
     KWD-QUERY-CONSTANT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 2))
    (CL:SETQ
     KWD-QUERY-CONTINUING-SUCCESS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUING-SUCCESS" NULL 2))
    (CL:SETQ
     KWD-QUERY-FINAL-SUCCESS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FINAL-SUCCESS" NULL 2))
    (CL:SETQ
     KWD-QUERY-FAILURE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILURE" NULL 2))
    (CL:SETQ
     KWD-QUERY-OVERLAY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OVERLAY" NULL 2))
    (CL:SETQ
     KWD-QUERY-SPAWNED-SUBQUERY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SPAWNED-SUBQUERY" NULL 2))
    (CL:SETQ
     KWD-QUERY-SUCCESS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUCCESS" NULL 2))
    (CL:SETQ
     KWD-QUERY-FAILED-OVERLAY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILED-OVERLAY" NULL 2))
    (CL:SETQ
     KWD-QUERY-SUBGOAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBGOAL" NULL 2))
    (CL:SETQ
     KWD-QUERY-EXISTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
    (CL:SETQ
     KWD-QUERY-FORALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
    (CL:SETQ
     SYM-QUERY-IO-VARIABLES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
    (CL:SETQ
     KWD-QUERY-CACHED-BINDINGS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHED-BINDINGS" NULL 2))
    (CL:SETQ KWD-QUERY-FAIL (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
    (CL:SETQ
     KWD-QUERY-END-SUBUMPTION-TEST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "END-SUBUMPTION-TEST" NULL 2))
    (CL:SETQ
     SGT-QUERY-STANDARD-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "STANDARD-OBJECT"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-QUERY-*REVERSEPOLARITY?*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*REVERSEPOLARITY?*" NULL 0))
    (CL:SETQ
     KWD-QUERY-ALL-SUBGOAL-PHASES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-SUBGOAL-PHASES" NULL 2))
    (CL:SETQ
     KWD-QUERY-SUBGOALS-OVERLAY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBGOALS-OVERLAY" NULL 2))
    (CL:SETQ KWD-QUERY-OPEN (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN" NULL 2))
    (CL:SETQ
     KWD-QUERY-SCAN-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-COLLECTION" NULL 2))
    (CL:SETQ
     SYM-QUERY-COMPLEMENT-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT-DESCRIPTION" NULL 0))
    (CL:SETQ
     KWD-QUERY-SCAN-SUBCOLLECTIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-SUBCOLLECTIONS" NULL 2))
    (CL:SETQ
     KWD-QUERY-SCAN-SUPERCOLLECTIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-SUPERCOLLECTIONS" NULL 2))
    (CL:SETQ
     KWD-QUERY-DO-CONTAINED-BY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DO-CONTAINED-BY" NULL 2))
    (CL:SETQ
     KWD-QUERY-SUBSUMPTION-OVERLAY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-OVERLAY" NULL 2))
    (CL:SETQ
     SYM-QUERY-CONTAINED-BY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTAINED-BY" NULL 0))
    (CL:SETQ
     SYM-QUERY-IN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     KWD-QUERY-SKIP-DEFINITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SKIP-DEFINITION" NULL 2))
    (CL:SETQ
     KWD-QUERY-PRE-ANTECEDENTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRE-ANTECEDENTS" NULL 2))
    (CL:SETQ
     KWD-QUERY-DEFINITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINITION" NULL 2))
    (CL:SETQ
     KWD-QUERY-FULL-SUBQUERY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FULL-SUBQUERY" NULL 2))
    (CL:SETQ
     SYM-QUERY-DEFINITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINITION" NULL 0))
    (CL:SETQ
     SGT-QUERY-WORLD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-QUERY-MONOTONIC?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MONOTONIC?" NULL 0))
    (CL:SETQ
     SYM-QUERY-NON-DISJOINTNESS-KLUDGE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NON-DISJOINTNESS-KLUDGE?" NULL 0))
    (CL:SETQ
     SGT-QUERY-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "COLLECTION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-QUERY-COLLECTION.CLOSED
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "COLLECTION.CLOSED"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     KWD-QUERY-CLOSED
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED" NULL 2))
    (CL:SETQ
     KWD-QUERY-PRIMITIVE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMITIVE" NULL 2))
    (CL:SETQ
     KWD-QUERY-ENUMERATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ENUMERATION" NULL 2))
    (CL:SETQ
     SYM-QUERY-CURSOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CURSOR" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-QUERY-ROOT-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-TYPE" NULL 0))
    (CL:SETQ
     SYM-QUERY-FILTER-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FILTER-TYPE" NULL 0))
    (CL:SETQ
     SYM-QUERY-NATIVE-CLASS-EXTENSION-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "NATIVE-CLASS-EXTENSION-ITERATOR"
      NULL
      0))
    (CL:SETQ
     SGT-QUERY-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-QUERY-DESCRIPTION-EXTENSION-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION-EXTENSION-ITERATOR" NULL 1))
    (CL:SETQ
     SYM-QUERY-GOAL-BINDINGS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-BINDINGS" NULL 0))
    (CL:SETQ
     SYM-QUERY-CACHED-BINDINGS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHED-BINDINGS" NULL 0))
    (CL:SETQ
     SYM-QUERY-REVERSE-POLARITY-CACHED-BINDINGS
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "REVERSE-POLARITY-CACHED-BINDINGS"
      NULL
      0))
    (CL:SETQ
     SYM-QUERY-UP-FOR-GRABS?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-FOR-GRABS?" NULL 0))
    (CL:SETQ
     SYM-QUERY-CLUSTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLUSTER" NULL 0))
    (CL:SETQ
     SGT-QUERY-GOAL-CACHE-CLUSTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-CACHE-CLUSTER" NULL 1))
    (CL:SETQ
     SYM-QUERY-VECTOR-OF-GOAL-CACHE-TABLES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR-OF-GOAL-CACHE-TABLES" NULL 0))
    (CL:SETQ
     KWD-QUERY-GOAL-CACHES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-CACHES" NULL 2))
    (CL:SETQ
     SYM-QUERY-GOAL-CACHE-CLUSTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-CACHE-CLUSTER" NULL 0))
    (CL:SETQ
     KWD-QUERY-EXECUTE-QUERY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXECUTE-QUERY" NULL 2))
    (CL:SETQ KWD-QUERY-QUERY (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY" NULL 2))
    (CL:SETQ
     SYM-QUERY-AND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ SYM-QUERY-KAPPA (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
    (CL:SETQ
     SYM-QUERY-COMMA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMA" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-QUERY-WHERE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WHERE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-QUERY-EXISTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ KWD-QUERY-KIF (INTERN-RIGID-SYMBOL-WRT-MODULE "KIF" NULL 2))
    (CL:SETQ
     SYM-QUERY-TRUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     KWD-QUERY-STELLA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA" NULL 2))
    (CL:SETQ
     KWD-QUERY-PREFIX-STELLA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PREFIX-STELLA" NULL 2))
    (CL:SETQ
     SGT-QUERY-LOGIC-EXCEPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-EXCEPTION" NULL 1))
    (CL:SETQ
     KWD-QUERY-EXCEPTIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXCEPTIONS" NULL 2))
    (CL:SETQ
     SGT-QUERY-EXCEPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "EXCEPTION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ SYM-QUERY-ASK (INTERN-RIGID-SYMBOL-WRT-MODULE "ASK" NULL 0))
    (CL:SETQ
     KWD-QUERY-COMMON-LISP
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
    (CL:SETQ
     SYM-QUERY-EVALUATOR-WRAPPER-CODE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "EVALUATOR-WRAPPER-CODE"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-QUERY-RETRIEVE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRIEVE" NULL 0))
    (CL:SETQ KWD-QUERY-SUB (INTERN-RIGID-SYMBOL-WRT-MODULE "SUB" NULL 2))
    (CL:SETQ KWD-QUERY-SUPER (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPER" NULL 2))
    (CL:SETQ
     SGT-QUERY-RELATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "RELATION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-QUERY-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" (GET-MODULE "/STELLA" TRUE) 1)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:SETQ *MAXIMUM-BACKTRACKING-DEPTH* *DEFAULT-MAXIMUM-DEPTH*)
    (CL:LET*
     ((SELF-062 (NEW-BOOLEAN-VECTOR-INDEX-NODE)))
     (CL:SETF
      (CLSYS-SVAL BOOLEAN-VECTOR-INDEX-NODE VECTOR SELF-062)
      (NEW-BOOLEAN-VECTOR 0))
     (CL:SETQ *BOOLEAN-VECTOR-INDEX* SELF-062))
    (CL:SETQ *TYPE-CHECK-STRATEGY* KWD-QUERY-SORT)
    (CL:SETQ *MAXIMUM-QUERY-THREAD-OFFSET* (CL:1- *QUERY-THREAD-LIMIT*))
    (CL:SETQ *FREE-QUERY-THREAD-OFFSETS* (LIST))
    (CL:SETQ *QUERY-ENVIRONMENTS-VECTOR* (NEW-VECTOR *QUERY-THREAD-LIMIT*))
    (CL:SETQ REUSABLE-SINGLETON-VECTOR (NEW-VECTOR 1)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 5) 1)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "QUERY-ITERATOR"
        "(DEFCLASS QUERY-ITERATOR (ITERATOR) :DOCUMENTATION \"A query iterator points to a query environment
representing the initial or intermediate state of a query.  The iterator's
'value' is a vector representing a satisfying set bindings of the query's
output variables.  Each call to the iterator writes a new set of bindings
into the vector.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT-VECTOR)) :SLOTS ((QUERY-ENVIRONMENT :TYPE QUERY-ENVIRONMENT) (EXTERNAL-VARIABLES :TYPE VARIABLES-VECTOR) (SOLUTIONS :TYPE (LIST OF ARGUMENTS-VECTOR) :INITIALLY (NEW LIST)) (EXHAUSTED? :TYPE BOOLEAN)) :PRINT-FORM (PRINT-QUERY-ITERATOR SELF STREAM))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-QUERY-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-QUERY-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "CONTROL-FRAME"
        "(DEFCLASS CONTROL-FRAME (STANDARD-OBJECT) :SLOTS ((STATE :TYPE KEYWORD) (PHASE :TYPE KEYWORD) (PROPOSITION :TYPE PROPOSITION) (REVERSE-POLARITY? :TYPE BOOLEAN) (UP :TYPE CONTROL-FRAME) (DOWN :TYPE CONTROL-FRAME) (BACK :TYPE CONTROL-FRAME) (ARGUMENT-CURSOR :TYPE INTEGER :INITIALLY 0) (ITERATOR :TYPE ITERATOR) (SUBQUERY-FRAME :TYPE SUBQUERY-FRAME :RENAMES ITERATOR) (PARENT-PATTERN-FRAME :TYPE CONTROL-FRAME) (GOAL-CACHE :TYPE GOAL-CACHE) (PARTIAL-MATCH-FRAME :TYPE PARTIAL-MATCH-FRAME) (DEBUG-FRAME-OFFSET :TYPE INTEGER) (DEBUG-DEPTH :TYPE INTEGER :INITIALLY 0) (CHOICE-POINT-UNBINDING-OFFSET :TYPE INTEGER)) :PRINT-FORM (PRINT-CONTROL-FRAME SELF STREAM))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CONTROL-FRAME))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CONTROL-FRAME-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "GOAL-STRATEGY"
        "(DEFCLASS GOAL-STRATEGY (STANDARD-OBJECT) :DOCUMENTATION \"A goal-strategy contains a procedure for proving
one or more kinds of goals.\" :SLOTS ((KIND-OF-GOAL :TYPE KEYWORD) (STRATEGY-PRIORITY :TYPE INTEGER) (STRATEGY-PROCEDURE :TYPE FUNCTION-CODE)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-GOAL-STRATEGY))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-GOAL-STRATEGY-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "QUERY-ENVIRONMENT"
        "(DEFCLASS QUERY-ENVIRONMENT (STANDARD-OBJECT) :SLOTS ((CONTROL-FRAME-STACK :TYPE (VECTOR OF CONTROL-FRAME)) (CONTROL-FRAME-OFFSET-LIMIT :TYPE INTEGER) (TOP-CONTROL-FRAME-OFFSET :TYPE INTEGER) (VARIABLE-FRAME-STACK :TYPE (VECTOR OF OBJECT)) (VARIABLE-FRAME-OFFSET-LIMIT :TYPE INTEGER) (TOP-VARIABLE-FRAME-OFFSET :TYPE INTEGER) (UNBINDING-STACK :TYPE INTEGER-VECTOR) (UNBINDING-STACK-OFFSET-LIMIT :TYPE INTEGER) (TOP-UNBINDING-STACK-OFFSET :TYPE INTEGER) (CURRENT-VARIABLE-FRAME-OFFSET :TYPE INTEGER) (CURRENT-SUBQUERY-FRAME :TYPE SUBQUERY-FRAME) (PARTIAL-MATCH-STRATEGY :TYPE PARTIAL-MATCH-FRAME) (LATEST-POSITIVE-SCORE :TYPE PARTIAL-MATCH-SCORE) (ITERATIVE-DEEPENING? :TYPE BOOLEAN) (CURRENT-DEPTH-CUTOFF :TYPE INTEGER) (MAXIMUM-DEPTH :TYPE INTEGER) (AUGMENTED-GOAL-CACHE? :TYPE BOOLEAN) (ACTIVE-GOAL-CACHES :TYPE (LIST OF GOAL-CACHE) :ALLOCATION :EMBEDDED) (TRIGGERED-DEPTH-CUTOFF? :TYPE BOOLEAN) (FAILED-TO-FIND-DUPLICATE-SUBGOAL? :TYPE BOOLEAN) (FOUND-AT-LEAST-ONE-SOLUTION? :TYPE BOOLEAN) (DEEP-INFERENCE? :TYPE BOOLEAN) (QUERY-THREAD-OFFSET :TYPE INTEGER) (TIME-STAMP :TYPE TIME-STAMP) (QUERY-ITERATOR :TYPE QUERY-ITERATOR) (SUBSUMPTION-QUERY? :TYPE BOOLEAN) (SPECIALIZING-DESCRIPTION :TYPE DESCRIPTION) (OPTIMIZER-GOAL-RECORDS :TYPE (EXTENSIBLE-VECTOR OF GOAL-RECORD)) (RESIDUE-GOALS :TYPE (LIST OF PROPOSITION) :ALLOCATION :EMBEDDED) (BEST-GOAL-SEQUENCE :TYPE (LIST OF PROPOSITION) :ALLOCATION :EMBEDDED) (BEST-COST :TYPE INTEGER)) :INITIALIZER INITIALIZE-QUERY-ENVIRONMENT :RECYCLE-METHOD :FREE-LIST)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-QUERY-ENVIRONMENT))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-QUERY-ENVIRONMENT-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "SUBQUERY-FRAME"
        "(DEFCLASS SUBQUERY-FRAME (ITERATOR) :DOCUMENTATION \"A subquery frame records state needed to search
antecedent descriptions, subclasses, and a defining description to produce
its bindings.\" :SLOTS ((CONTROL-FRAME :TYPE CONTROL-FRAME) (DESCRIPTION :TYPE DESCRIPTION) (EXTERNAL-ARGUMENTS :TYPE ARGUMENTS-VECTOR) (BOOLEAN-VECTOR :TYPE BOOLEAN-VECTOR) (LOCAL-VARIABLE-FRAME-OFFSET :TYPE INTEGER) (OPTIMAL-PATTERN :TYPE DESCRIPTION) (PHASES-FILTER :TYPE KEYWORD) (ITERATOR :TYPE (ITERATOR OF PROPOSITION))) :RECYCLE-METHOD :FREE-LIST :TERMINATOR TERMINATE-SUBQUERY-FRAME?)")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SUBQUERY-FRAME))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SUBQUERY-FRAME-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "BOOLEAN-VECTOR-INDEX-NODE"
        "(DEFCLASS BOOLEAN-VECTOR-INDEX-NODE (STANDARD-OBJECT) :SLOTS ((TRUE-LINK :TYPE BOOLEAN-VECTOR-INDEX-NODE) (FALSE-LINK :TYPE BOOLEAN-VECTOR-INDEX-NODE) (VECTOR :TYPE BOOLEAN-VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-BOOLEAN-VECTOR-INDEX-NODE))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-BOOLEAN-VECTOR-INDEX-NODE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "DESCRIPTION-EXTENSION-ITERATOR"
        "(DEFCLASS DESCRIPTION-EXTENSION-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterates over the extension of a top-level description,
filtering out deleted objects.  May create logic instances on-the-fly by
wrapping native objects in the extension of the class attached to the
description.\" :PARAMETERS ((ANY-VALUE :TYPE LOGIC-OBJECT)) :SLOTS ((CURSOR :TYPE (CONS OF LOGIC-OBJECT)) (ROOT-TYPE :TYPE TYPE) (FILTER-TYPE :TYPE TYPE) (NATIVE-CLASS-EXTENSION-ITERATOR :TYPE ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-DESCRIPTION-EXTENSION-ITERATOR))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-DESCRIPTION-EXTENSION-ITERATOR-SLOT-VALUE)))
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE GOAL-BINDINGS (CONS OF OBJECT))")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "GOAL-CACHE"
        "(DEFCLASS GOAL-CACHE (STANDARD-OBJECT) :DOCUMENTATION \"Cache of output bindings derived for a particular goal
and set of input bindings.\" :SLOTS ((CACHED-BINDINGS :TYPE (LIST OF GOAL-BINDINGS) :ALLOCATION :EMBEDDED) (REVERSE-POLARITY-CACHED-BINDINGS :TYPE (LIST OF GOAL-BINDINGS) :ALLOCATION :EMBEDDED) (UP-FOR-GRABS? :TYPE BOOLEAN) (CLUSTER :TYPE GOAL-CACHE-CLUSTER)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-GOAL-CACHE))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-GOAL-CACHE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "GOAL-CACHE-CLUSTER"
        "(DEFCLASS GOAL-CACHE-CLUSTER (STANDARD-OBJECT) :SLOTS ((VECTOR-OF-GOAL-CACHE-TABLES :TYPE (VECTOR SIZE 8 OF (KEY-VALUE-LIST OF GOAL-BINDINGS GOAL-CACHE))) (TIME-STAMP :TYPE TIME-STAMP) (PROPOSITION :TYPE PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-GOAL-CACHE-CLUSTER))
     (CL:SETF
      (CLSYS-SVAL CLASS CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-GOAL-CACHE-CLUSTER-SLOT-VALUE))))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEEP-INFERENCE-MODE?"
        NULL
        "(DEFUN (DEEP-INFERENCE-MODE? BOOLEAN) () :DOCUMENTATION \"Determines whether expensive inferencing is warranted.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEEP-INFERENCE-MODE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SUBSUMPTION-MODE?"
        NULL
        "(DEFUN (SUBSUMPTION-MODE? BOOLEAN) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SUBSUMPTION-MODE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-BOOLEAN-VECTOR-INDEX-NODE"
        "BOOLEAN-VECTOR-INDEX-NODE"
        "(DEFUN (CREATE-BOOLEAN-VECTOR-INDEX-NODE BOOLEAN-VECTOR-INDEX-NODE) ((PARENTNODE BOOLEAN-VECTOR-INDEX-NODE) (LASTVALUE BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-BOOLEAN-VECTOR-INDEX-NODE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR"
        "VECTOR"
        "(DEFUN (ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR BOOLEAN-VECTOR) ((ARGUMENTSVECTOR ARGUMENTS-VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ARGUMENTS-VECTOR-TO-BOOLEAN-VECTOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ZERO-ONE-LIST-TO-BOOLEAN-VECTOR"
        "LIST"
        "(DEFUN (ZERO-ONE-LIST-TO-BOOLEAN-VECTOR BOOLEAN-VECTOR) ((ZEROONELIST (LIST OF INTEGER-WRAPPER))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ZERO-ONE-LIST-TO-BOOLEAN-VECTOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INITIALIZE-QUERY-ENVIRONMENT"
        "QUERY-ENVIRONMENT"
        "(DEFUN INITIALIZE-QUERY-ENVIRONMENT ((ENVIRONMENT QUERY-ENVIRONMENT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INITIALIZE-QUERY-ENVIRONMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXPAND-CONTROL-FRAME-STACK"
        "QUERY-ENVIRONMENT"
        "(DEFUN EXPAND-CONTROL-FRAME-STACK ((QUERYENVIRONMENT QUERY-ENVIRONMENT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXPAND-CONTROL-FRAME-STACK)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEW-TOP-CONTROL-FRAME"
        "QUERY-ENVIRONMENT"
        "(DEFUN (NEW-TOP-CONTROL-FRAME CONTROL-FRAME) ((QUERYENVIRONMENT QUERY-ENVIRONMENT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NEW-TOP-CONTROL-FRAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POP-CONTROL-FRAME"
        "QUERY-ENVIRONMENT"
        "(DEFUN POP-CONTROL-FRAME ((QUERYENVIRONMENT QUERY-ENVIRONMENT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION POP-CONTROL-FRAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POP-FRAMES-DOWN-TO"
        "CONTROL-FRAME"
        "(DEFUN POP-FRAMES-DOWN-TO ((FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION POP-FRAMES-DOWN-TO)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXPAND-VARIABLE-FRAME-STACK"
        "QUERY-ENVIRONMENT"
        "(DEFUN EXPAND-VARIABLE-FRAME-STACK ((QUERYENVIRONMENT QUERY-ENVIRONMENT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXPAND-VARIABLE-FRAME-STACK)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-BLOCK-OF-VARIABLE-FRAMES"
        "INTEGER"
        "(DEFUN (ALLOCATE-BLOCK-OF-VARIABLE-FRAMES INTEGER) ((VARIABLECOUNT INTEGER) (FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALLOCATE-BLOCK-OF-VARIABLE-FRAMES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DEALLOCATE-BLOCK-OF-VARIABLE-FRAMES"
        "CONTROL-FRAME"
        "(DEFUN DEALLOCATE-BLOCK-OF-VARIABLE-FRAMES ((FRAME CONTROL-FRAME)) :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DEALLOCATE-BLOCK-OF-VARIABLE-FRAMES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RESET-CURRENT-VARIABLE-FRAME-OFFSET"
        "CONTROL-FRAME"
        "(DEFUN RESET-CURRENT-VARIABLE-FRAME-OFFSET ((FRAME CONTROL-FRAME) (LOCALORPARENT KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RESET-CURRENT-VARIABLE-FRAME-OFFSET)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXPAND-UNBINDING-STACK"
        "QUERY-ENVIRONMENT"
        "(DEFUN EXPAND-UNBINDING-STACK ((QUERYENVIRONMENT QUERY-ENVIRONMENT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXPAND-UNBINDING-STACK)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-ENVIRONMENT-STACKS"
        NULL
        "(DEFUN PRINT-ENVIRONMENT-STACKS ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-ENVIRONMENT-STACKS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SET-PATTERN-VARIABLE-BINDING"
        "PATTERN-VARIABLE"
        "(DEFUN SET-PATTERN-VARIABLE-BINDING ((VARIABLE PATTERN-VARIABLE) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SET-PATTERN-VARIABLE-BINDING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNBIND-VARIABLES-BEGINNING-AT"
        "INTEGER"
        "(DEFUN UNBIND-VARIABLES-BEGINNING-AT ((UBSTACKOFFSET INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNBIND-VARIABLES-BEGINNING-AT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNBIND-PATTERN-VARIABLES"
        "CONTROL-FRAME"
        "(DEFUN UNBIND-PATTERN-VARIABLES ((FRAME CONTROL-FRAME)) :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNBIND-PATTERN-VARIABLES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-CHOICE-POINT"
        "CONTROL-FRAME"
        "(DEFUN CREATE-CHOICE-POINT ((FRAME CONTROL-FRAME)) :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-CHOICE-POINT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BOUND-TO"
        "PATTERN-VARIABLE"
        "(DEFUN (BOUND-TO OBJECT) ((SELF PATTERN-VARIABLE)) :GLOBALLY-INLINE? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BOUND-TO)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ARGUMENT-BOUND-TO"
        "OBJECT"
        "(DEFUN (ARGUMENT-BOUND-TO OBJECT) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ARGUMENT-BOUND-TO)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NATIVE-ARGUMENT-BOUND-TO"
        "OBJECT"
        "(DEFUN (NATIVE-ARGUMENT-BOUND-TO OBJECT) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NATIVE-ARGUMENT-BOUND-TO)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "OPERATOR-BOUND-TO"
        "OBJECT"
        "(DEFUN (OPERATOR-BOUND-TO SLOT) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION OPERATOR-BOUND-TO)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-UNIFY-ATTRIBUTES?"
        "OBJECT"
        "(DEFUN (HELP-UNIFY-ATTRIBUTES? BOOLEAN) ((VALUE1 OBJECT) (VALUE2 OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-UNIFY-ATTRIBUTES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FAILS-TYPE-CHECK?"
        "PATTERN-VARIABLE"
        "(DEFUN (FAILS-TYPE-CHECK? BOOLEAN) ((V1 PATTERN-VARIABLE) (I2 OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FAILS-TYPE-CHECK?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-BIND-VARIABLE-TO-VALUE?"
        "PATTERN-VARIABLE"
        "(DEFUN (HELP-BIND-VARIABLE-TO-VALUE? BOOLEAN) ((VARIABLE PATTERN-VARIABLE) (VALUE OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-BIND-VARIABLE-TO-VALUE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BIND-VARIABLE-TO-VALUE?"
        "PATTERN-VARIABLE"
        "(DEFUN (BIND-VARIABLE-TO-VALUE? BOOLEAN) ((VARIABLE PATTERN-VARIABLE) (VALUE OBJECT) (AUTOCLEANUP? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BIND-VARIABLE-TO-VALUE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BIND-ARGUMENT-TO-VALUE?"
        "OBJECT"
        "(DEFUN (BIND-ARGUMENT-TO-VALUE? BOOLEAN) ((ARGUMENT OBJECT) (VALUE OBJECT) (AUTOCLEANUP? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BIND-ARGUMENT-TO-VALUE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BIND-VECTOR-OF-ARGUMENTS-TO-VALUES?"
        "VECTOR"
        "(DEFUN (BIND-VECTOR-OF-ARGUMENTS-TO-VALUES? BOOLEAN) ((ARGUMENTS ARGUMENTS-VECTOR) (VALUES CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BIND-VECTOR-OF-ARGUMENTS-TO-VALUES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE "PCS" NULL "(DEFUN PCS ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PCS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VARIABLE-FROM-UNBINDING-OFFSET"
        "DESCRIPTION"
        "(DEFUN (VARIABLE-FROM-UNBINDING-OFFSET PATTERN-VARIABLE) ((DESCRIPTION DESCRIPTION) (UBOFFSET INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VARIABLE-FROM-UNBINDING-OFFSET)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-FRAME-OFFSET"
        "CONTROL-FRAME"
        "(DEFUN (COMPUTE-FRAME-OFFSET INTEGER) ((FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-FRAME-OFFSET)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-ONE-VARIABLE-BINDING"
        "PATTERN-VARIABLE"
        "(DEFUN PRINT-ONE-VARIABLE-BINDING ((VARIABLE PATTERN-VARIABLE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-ONE-VARIABLE-BINDING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-VARIABLE-BINDINGS"
        "CONTROL-FRAME"
        "(DEFUN PRINT-VARIABLE-BINDINGS ((FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-VARIABLE-BINDINGS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRACE-GOAL-TREE"
        "CONTROL-FRAME"
        "(DEFUN TRACE-GOAL-TREE ((FRAME CONTROL-FRAME) (DEPTH INTEGER) (LASTMOVE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRACE-GOAL-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INTERPRET-AND-SCORES"
        "CONTROL-FRAME"
        "(DEFUN (INTERPRET-AND-SCORES KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INTERPRET-AND-SCORES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INTERPRET-OR-SCORES"
        "CONTROL-FRAME"
        "(DEFUN (INTERPRET-OR-SCORES KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INTERPRET-OR-SCORES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INTERPRET-FAIL-SCORE"
        "CONTROL-FRAME"
        "(DEFUN (INTERPRET-FAIL-SCORE KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INTERPRET-FAIL-SCORE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INTERPRET-SUBGOALS-SCORES"
        "CONTROL-FRAME"
        "(DEFUN (INTERPRET-SUBGOALS-SCORES KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INTERPRET-SUBGOALS-SCORES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-DOWN-FRAME"
        "CONTROL-FRAME"
        "(DEFUN (CREATE-DOWN-FRAME CONTROL-FRAME) ((UPFRAME CONTROL-FRAME) (DOWNPROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-DOWN-FRAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXECUTE-BACKWARD-CHAINING-PROOF?"
        "QUERY-ENVIRONMENT"
        "(DEFUN (EXECUTE-BACKWARD-CHAINING-PROOF? BOOLEAN) ((QUERYENVIRONMENT QUERY-ENVIRONMENT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXECUTE-BACKWARD-CHAINING-PROOF?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SELECT-NEXT-PROOF-STRATEGY"
        "CONTROL-FRAME"
        "(DEFUN (SELECT-NEXT-PROOF-STRATEGY KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SELECT-NEXT-PROOF-STRATEGY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS"
        "SLOT"
        "(DEFMETHOD (APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS OBJECT) ((SLOT SLOT) (ARGUMENTS VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS"
        "STORAGE-SLOT"
        "(DEFMETHOD (APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS OBJECT) ((SLOT STORAGE-SLOT) (ARGUMENTS VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS"
        "METHOD-SLOT"
        "(DEFMETHOD (APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS OBJECT) ((SLOT METHOD-SLOT) (ARGUMENTS VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION APPLY-SLOT-TO-NATIVE-QUERY-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONTINUE-ATOMIC-PROPOSITION-PROOF"
        "CONTROL-FRAME"
        "(DEFUN (CONTINUE-ATOMIC-PROPOSITION-PROOF KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONTINUE-ATOMIC-PROPOSITION-PROOF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALL-ARGUMENTS-BOUND?"
        "PROPOSITION"
        "(DEFUN (ALL-ARGUMENTS-BOUND? BOOLEAN) ((GOAL PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALL-ARGUMENTS-BOUND?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-SPECIALIZING-FUNCTION-PROPOSITION-VALUE"
        "PROPOSITION"
        "(DEFUN (FIND-SPECIALIZING-FUNCTION-PROPOSITION-VALUE OBJECT) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-SPECIALIZING-FUNCTION-PROPOSITION-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "QUERY-FOR-ASSERTED-FUNCTION-PROPOSITION-VALUE"
        "PROPOSITION"
        "(DEFUN (QUERY-FOR-ASSERTED-FUNCTION-PROPOSITION-VALUE OBJECT) ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION QUERY-FOR-ASSERTED-FUNCTION-PROPOSITION-VALUE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MANUFACTURE-DEFINING-SKOLEM"
        "SLOT"
        "(DEFUN (MANUFACTURE-DEFINING-SKOLEM KEYWORD) ((SLOT SLOT) (GOALPROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MANUFACTURE-DEFINING-SKOLEM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONTINUE-FUNCTION-PROPOSITION-PROOF"
        "PROPOSITION"
        "(DEFUN (CONTINUE-FUNCTION-PROPOSITION-PROOF KEYWORD) ((SELF PROPOSITION) (FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONTINUE-FUNCTION-PROPOSITION-PROOF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONTINUE-PREDICATE-PROPOSITION-PROOF"
        "PROPOSITION"
        "(DEFUN (CONTINUE-PREDICATE-PROPOSITION-PROOF KEYWORD) ((SELF PROPOSITION) (FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONTINUE-PREDICATE-PROPOSITION-PROOF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONTINUE-EQUIVALENT-PROPOSITION-PROOF"
        "PROPOSITION"
        "(DEFUN (CONTINUE-EQUIVALENT-PROPOSITION-PROOF KEYWORD) ((SELF PROPOSITION) (FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONTINUE-EQUIVALENT-PROPOSITION-PROOF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONTINUE-IN-PROPOSITION-PROOF"
        "PROPOSITION"
        "(DEFUN (CONTINUE-IN-PROPOSITION-PROOF KEYWORD) ((SELF PROPOSITION) (FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONTINUE-IN-PROPOSITION-PROOF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INFERRABLE-DESCRIPTION?"
        "OBJECT"
        "(DEFUN (INFERRABLE-DESCRIPTION? BOOLEAN) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INFERRABLE-DESCRIPTION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UNNAMED-DESCRIPTION?"
        "OBJECT"
        "(DEFUN (UNNAMED-DESCRIPTION? BOOLEAN) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UNNAMED-DESCRIPTION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONTINUE-IMPLIES-PROPOSITION-PROOF"
        "PROPOSITION"
        "(DEFUN (CONTINUE-IMPLIES-PROPOSITION-PROOF KEYWORD) ((SELF PROPOSITION) (FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONTINUE-IMPLIES-PROPOSITION-PROOF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SPAWN-CONTAINED-BY-SUBQUERY"
        "CONTROL-FRAME"
        "(DEFUN (SPAWN-CONTAINED-BY-SUBQUERY KEYWORD) ((UPFRAME CONTROL-FRAME) (TAIL OBJECT) (HEAD OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SPAWN-CONTAINED-BY-SUBQUERY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-CONTAINED-BY-ARGUMENT"
        "OBJECT"
        "(DEFUN (CREATE-CONTAINED-BY-ARGUMENT PROPOSITION) ((COLLECTION OBJECT) (BRIDGEARGS LIST) (LASTCALL? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-CONTAINED-BY-ARGUMENT)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONTINUE-CONSTANT-PROPOSITION-PROOF"
        "PROPOSITION"
        "(DEFUN (CONTINUE-CONSTANT-PROPOSITION-PROOF KEYWORD) ((SELF PROPOSITION) (FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONTINUE-CONSTANT-PROPOSITION-PROOF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "OVERLAY-WITH-PATTERN-FRAME"
        "CONTROL-FRAME"
        "(DEFUN (OVERLAY-WITH-PATTERN-FRAME KEYWORD) ((FRAME CONTROL-FRAME) (DESCRIPTION DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION OVERLAY-WITH-PATTERN-FRAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TRANSFER-PATTERN-QUERY-BINDINGS?"
        "CONTROL-FRAME"
        "(DEFUN (TRANSFER-PATTERN-QUERY-BINDINGS? BOOLEAN) ((FRAME CONTROL-FRAME) (FUTUREBINDINGS? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TRANSFER-PATTERN-QUERY-BINDINGS?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-ANTECEDENTS-ITERATOR"
        "SUBQUERY-FRAME"
        "(DEFUN (ALLOCATE-ANTECEDENTS-ITERATOR (ITERATOR OF PROPOSITION)) ((SUBQUERYFRAME SUBQUERY-FRAME) (REVERSEPOLARITY? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALLOCATE-ANTECEDENTS-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONTINUE-SUBGOALS-PROOF"
        "CONTROL-FRAME"
        "(DEFUN (CONTINUE-SUBGOALS-PROOF KEYWORD) ((FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONTINUE-SUBGOALS-PROOF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEW-TOP-SUBQUERY-FRAME"
        NULL
        "(DEFUN (NEW-TOP-SUBQUERY-FRAME SUBQUERY-FRAME) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION NEW-TOP-SUBQUERY-FRAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-SUBQUERY-FRAME"
        "DESCRIPTION"
        "(DEFUN (ALLOCATE-SUBQUERY-FRAME SUBQUERY-FRAME) ((DESCRIPTION DESCRIPTION) (EXTERNALARGUMENTS ARGUMENTS-VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALLOCATE-SUBQUERY-FRAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TERMINATE-SUBQUERY-FRAME?"
        "SUBQUERY-FRAME"
        "(DEFUN (TERMINATE-SUBQUERY-FRAME? BOOLEAN) ((SELF SUBQUERY-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TERMINATE-SUBQUERY-FRAME?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY-SUBQUERY-ARGUMENTS"
        "VECTOR"
        "(DEFUN (COPY-SUBQUERY-ARGUMENTS ARGUMENTS-VECTOR) ((ARGUMENTS OBJECT-VECTOR) (OMITLASTARGUMENT? BOOLEAN) (DESCRIPTION DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COPY-SUBQUERY-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "OVERLAY-WITH-SUBGOALS-FRAME"
        "CONTROL-FRAME"
        "(DEFUN (OVERLAY-WITH-SUBGOALS-FRAME KEYWORD) ((FRAME CONTROL-FRAME) (DESCRIPTION DESCRIPTION) (EXTERNALARGUMENTS ARGUMENTS-VECTOR) (OMITLASTARGUMENT? BOOLEAN) (PHASESFILTER KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION OVERLAY-WITH-SUBGOALS-FRAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SPAWN-SUBQUERY"
        "CONTROL-FRAME"
        "(DEFUN (SPAWN-SUBQUERY KEYWORD) ((UPFRAME CONTROL-FRAME) (DESCRIPTION DESCRIPTION) (PHASESFILTER KEYWORD) (OVERLAY? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SPAWN-SUBQUERY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONTINUE-DISJUNCTION-PROOF"
        "CONTROL-FRAME"
        "(DEFUN (CONTINUE-DISJUNCTION-PROOF KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONTINUE-DISJUNCTION-PROOF)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DISJOINT-CLASSES?"
        "CLASS"
        "(DEFUN (DISJOINT-CLASSES? BOOLEAN) ((CLASS1 CLASS) (CLASS2 CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DISJOINT-CLASSES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ROOT-TYPE-IMPLIES-MEMBER?"
        "OBJECT"
        "(DEFUN (ROOT-TYPE-IMPLIES-MEMBER? BOOLEAN) ((SELF OBJECT) (MEMBER OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ROOT-TYPE-IMPLIES-MEMBER?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECTION-HAS-MEMBER"
        "OBJECT"
        "(DEFUN (COLLECTION-HAS-MEMBER KEYWORD) ((SELF OBJECT) (MEMBER OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECTION-HAS-MEMBER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLOSED-COLLECTION?"
        "OBJECT"
        "(DEFUN (CLOSED-COLLECTION? BOOLEAN) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLOSED-COLLECTION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECTION-MEMBERS"
        "OBJECT"
        "(DEFUN (COLLECTION-MEMBERS ITERATOR) ((SELF OBJECT) (OPENORCLOSED KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECTION-MEMBERS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECTION-CONTAINED-IN-COLLECTION"
        "OBJECT"
        "(DEFUN (COLLECTION-CONTAINED-IN-COLLECTION KEYWORD) ((SUBCOLLECTION OBJECT) (SUPERCOLLECTION OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECTION-CONTAINED-IN-COLLECTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECTION-IMPLIES-COLLECTION?"
        "OBJECT"
        "(DEFUN (COLLECTION-IMPLIES-COLLECTION? BOOLEAN) ((SUBCOLLECTION OBJECT) (SUPERCOLLECTION OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECTION-IMPLIES-COLLECTION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-ITERATOR"
        "DESCRIPTION"
        "(DEFMETHOD (ALLOCATE-ITERATOR DESCRIPTION-EXTENSION-ITERATOR) ((SELF DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION ALLOCATE-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "DESCRIPTION-EXTENSION-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF DESCRIPTION-EXTENSION-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RESERVE-QUERY-THREAD"
        "QUERY-ENVIRONMENT"
        "(DEFUN RESERVE-QUERY-THREAD ((QUERYENVIRONMENT QUERY-ENVIRONMENT)) :DOCUMENTATION \"Find a free query thread and assign it to 'queryEnvironment'.
Signal a :QUERY-THREAD-LIMIT-VIOLATION exception if all threads are taken.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RESERVE-QUERY-THREAD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RELEASE-QUERY-THREAD"
        "QUERY-ENVIRONMENT"
        "(DEFUN RELEASE-QUERY-THREAD ((QUERYENVIRONMENT QUERY-ENVIRONMENT)) :DOCUMENTATION \"Release the query thread for 'queryEnvironment'.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RELEASE-QUERY-THREAD)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RELEASE-ALL-QUERY-THREADS"
        NULL
        "(DEFUN (RELEASE-ALL-QUERY-THREADS (LIST OF INTEGER-WRAPPER)) () :DOCUMENTATION \"Free up all query threads (buggy queries may have
failed to terminate).\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RELEASE-ALL-QUERY-THREADS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CLEAR-QUERY-THREADS"
        NULL
        "(DEFUN (CLEAR-QUERY-THREADS (LIST OF INTEGER-WRAPPER)) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CLEAR-QUERY-THREADS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-CACHED-BINDINGS"
        "GOAL-CACHE"
        "(DEFUN (GET-CACHED-BINDINGS (LIST OF GOAL-BINDINGS)) ((GOALCACHE GOAL-CACHE) (FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-CACHED-BINDINGS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-GOAL-CACHE"
        "GOAL-CACHE"
        "(DEFUN PRINT-GOAL-CACHE ((SELF GOAL-CACHE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-GOAL-CACHE)))
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT SLOT GOAL-CACHE-CLUSTER :TYPE GOAL-CACHE-CLUSTER :DOCUMENTATION \"Allow attachment of goal caches to slots.\" :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT CLASS GOAL-CACHE-CLUSTER :TYPE GOAL-CACHE-CLUSTER :DOCUMENTATION \"Allow attachment of goal caches to classes.\" :ALLOCATION :DYNAMIC)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-FIND-DUPLICATED-GOAL"
        "CONTROL-FRAME"
        "(DEFUN (HELP-FIND-DUPLICATED-GOAL CONTROL-FRAME CONTROL-FRAME INTEGER) ((GOALFRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-FIND-DUPLICATED-GOAL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-DUPLICATED-GOAL"
        NULL
        "(DEFUN (FIND-DUPLICATED-GOAL CONTROL-FRAME CONTROL-FRAME INTEGER) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-DUPLICATED-GOAL)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-GOAL-BINDINGS"
        "CONTROL-FRAME"
        "(DEFUN (YIELD-GOAL-BINDINGS CONS) ((FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-GOAL-BINDINGS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-GOAL-CACHE"
        "GOAL-CACHE-CLUSTER"
        "(DEFUN (LOOKUP-GOAL-CACHE GOAL-CACHE) ((CLUSTER GOAL-CACHE-CLUSTER) (FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-GOAL-CACHE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-GOAL-CACHE-CLUSTER"
        "PROPOSITION"
        "(DEFUN (FIND-GOAL-CACHE-CLUSTER GOAL-CACHE-CLUSTER) ((GOAL PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-GOAL-CACHE-CLUSTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-GOAL-CACHE"
        "CONTROL-FRAME"
        "(DEFUN (FIND-GOAL-CACHE GOAL-CACHE) ((FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FIND-GOAL-CACHE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-GOAL-CACHE-CLUSTER"
        "PROPOSITION"
        "(DEFUN (CREATE-GOAL-CACHE-CLUSTER GOAL-CACHE-CLUSTER) ((GOAL PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-GOAL-CACHE-CLUSTER)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-GOAL-CACHE?"
        "CONTROL-FRAME"
        "(DEFUN (CREATE-GOAL-CACHE? BOOLEAN) ((FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-GOAL-CACHE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HANDLE-DEPTH-VIOLATION"
        "CONTROL-FRAME"
        "(DEFUN (HANDLE-DEPTH-VIOLATION CONTROL-FRAME INTEGER) ((FRAME CONTROL-FRAME) (DEPTH INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HANDLE-DEPTH-VIOLATION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ACCESS-GOAL-CACHE"
        "CONTROL-FRAME"
        "(DEFUN (ACCESS-GOAL-CACHE KEYWORD) ((FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ACCESS-GOAL-CACHE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "UPDATE-GOAL-CACHE"
        "CONTROL-FRAME"
        "(DEFUN UPDATE-GOAL-CACHE ((FRAME CONTROL-FRAME) (SUCCESS? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION UPDATE-GOAL-CACHE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "OVERLAY-WITH-CACHED-BINDINGS"
        "CONTROL-FRAME"
        "(DEFUN (OVERLAY-WITH-CACHED-BINDINGS KEYWORD) ((FRAME CONTROL-FRAME) (GOALCACHE GOAL-CACHE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION OVERLAY-WITH-CACHED-BINDINGS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SCAN-CACHED-BINDINGS"
        "CONTROL-FRAME"
        "(DEFUN (SCAN-CACHED-BINDINGS KEYWORD) ((FRAME CONTROL-FRAME)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SCAN-CACHED-BINDINGS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-CONTROL-FRAME"
        "CONTROL-FRAME"
        "(DEFUN PRINT-CONTROL-FRAME ((SELF CONTROL-FRAME) (STREAM NATIVE-OUTPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-CONTROL-FRAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-GOAL-STACK"
        NULL
        "(DEFUN PRINT-GOAL-STACK () :DOCUMENTATION \"Print stack of goals.  Assumes that query has been interrupted
with a full stack of control frames.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-GOAL-STACK)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE "PGS" NULL "(DEFUN PGS ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PGS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRINT-QUERY-ITERATOR"
        "QUERY-ITERATOR"
        "(DEFUN PRINT-QUERY-ITERATOR ((SELF QUERY-ITERATOR) (STREAM NATIVE-OUTPUT-STREAM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRINT-QUERY-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ALLOCATE-QUERY-ITERATOR"
        NULL
        "(DEFUN (ALLOCATE-QUERY-ITERATOR QUERY-ITERATOR) ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION ALLOCATE-QUERY-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE"
        "QUERY-ITERATOR"
        "(DEFMETHOD FREE ((SELF QUERY-ITERATOR)))")))
     (CL:SETF (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD) (CL:FUNCTION FREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FREE-QUERY-ITERATOR"
        "QUERY-ITERATOR"
        "(DEFUN FREE-QUERY-ITERATOR ((SELF QUERY-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FREE-QUERY-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-QUERY-ITERATOR"
        "DESCRIPTION"
        "(DEFUN (CREATE-QUERY-ITERATOR QUERY-ITERATOR) ((DESCRIPTION DESCRIPTION) (OUTSIDEARGUMENTS VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-QUERY-ITERATOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BOOTSTRAP-INITIALIZE-SUBQUERY-FRAME"
        "SUBQUERY-FRAME"
        "(DEFUN BOOTSTRAP-INITIALIZE-SUBQUERY-FRAME ((SUBQUERYFRAME SUBQUERY-FRAME) (DESCRIPTION DESCRIPTION) (EXTERNALARGUMENTS ARGUMENTS-VECTOR) (OUTSIDEARGUMENTS VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BOOTSTRAP-INITIALIZE-SUBQUERY-FRAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "NEXT?"
        "QUERY-ITERATOR"
        "(DEFMETHOD (NEXT? BOOLEAN) ((SELF QUERY-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION NEXT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RESET"
        "QUERY-ITERATOR"
        "(DEFMETHOD RESET ((SELF QUERY-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION RESET)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY-VECTOR-TO-CONS-LIST"
        "VECTOR"
        "(DEFUN (COPY-VECTOR-TO-CONS-LIST CONS) ((VECTOR VECTOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COPY-VECTOR-TO-CONS-LIST)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LISTIFY"
        "QUERY-ITERATOR"
        "(DEFMETHOD (LISTIFY LIST) ((SELF QUERY-ITERATOR)) :DOCUMENTATION \"Return the list of tuples generated by 'self'.
Tuples of arity=1 are represented directly by the first element,
tuples of arity>1 are represented by a CONS list.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION LISTIFY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "STANDARDIZE-QUERY-TREE"
        "OBJECT"
        "(DEFUN (STANDARDIZE-QUERY-TREE CONS) ((QUERYTREE OBJECT) (TRUEFALSE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION STANDARDIZE-QUERY-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONS.STANDARDIZE-QUERY-TREE"
        "CONS"
        "(DEFUN (CONS.STANDARDIZE-QUERY-TREE CONS) ((QUERYTREE CONS) (TRUEFALSE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONS.STANDARDIZE-QUERY-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HANDLE-QUERY-EXCEPTION"
        "EXCEPTION"
        "(DEFUN HANDLE-QUERY-EXCEPTION ((EXCEPTION EXCEPTION) (COMMAND STRING)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HANDLE-QUERY-EXCEPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MAKE-QUERY"
        "OBJECT"
        "(DEFUN (MAKE-QUERY QUERY-ITERATOR) ((QUERYTREE OBJECT) (YESNO? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MAKE-QUERY)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RUN-YES-OR-NO-QUERY?"
        "QUERY-ITERATOR"
        "(DEFUN (RUN-YES-OR-NO-QUERY? BOOLEAN) ((QUERYITERATOR QUERY-ITERATOR)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION RUN-YES-OR-NO-QUERY?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COERCE-TO-TREE"
        "OBJECT"
        "(DEFUN (COERCE-TO-TREE OBJECT) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COERCE-TO-TREE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COERCE-TO-STRING"
        "OBJECT"
        "(DEFUN (COERCE-TO-STRING STRING) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COERCE-TO-STRING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "ASK"
        "OBJECT"
        "(DEFUN (ASK BOOLEAN) ((PROPOSITION PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Perform inference to determine whether `proposition' is true.
Return TRUE if `proposition' was found to be true; return NULL otherwise.
KIF example: `(ask (happy Fred))' will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic constant
`Fred' and the relation (or slot) `happy' must already be defined (see
`assert').  Use `(set/unset-feature goal-trace)' to en/disable goal tracing
of the inference engine.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%ASK))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-QUERY-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION ASK-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RETRIEVE-BINDINGS"
        "QUERY-ITERATOR"
        "(DEFMETHOD (RETRIEVE-BINDINGS QUERY-ITERATOR) ((QUERY QUERY-ITERATOR) (NOFBINDINGS INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION RETRIEVE-BINDINGS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RETRIEVE-BINDINGS"
        "CONS"
        "(DEFMETHOD (RETRIEVE-BINDINGS QUERY-ITERATOR) ((QUERY CONS) (NOFBINDINGS INTEGER)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION RETRIEVE-BINDINGS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "RETRIEVE"
        "ARGUMENT-LIST"
        "(DEFUN (RETRIEVE QUERY-ITERATOR) (|&REST| (QUERY PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Retrieve elements of a relation (tuples) that satisfy a proposition.
The accepted syntax is:
	 
  (retrieve [<integer> | all]
            [{<variable-spec> | (<variable-spec>+)}
             [<proposition>]])
	
The variables and proposition are similar to an `exists' sentence or
`kappa' term without the quantifier.  <proposition> usually contains
references to the listed variables.  No other free variable references
are allowed.  If <proposition> is omitted, it defaults to TRUE.  

A solution is a set of bindings for the listed variables for which
<proposition> is true.  The optional first argument controls how many
solutions should be generated before control is returned.  The keyword
`all' indicates that all solutions should be generated.  By default,
`retrieve' returns after it has found one new solution or if it cannot
find any more solutions.

`retrieve' returns an iterator which saves all the necessary state of
a query and stores all generated solutions.  When used interactively,
the returned iterator will print out with the set of solutions collected
so far.  Calling `retrieve' without any arguments (or only with the first
argument) will generate one (or more) solutions to the most recently
asked query.

KIF examples:
	 
  (retrieve (?x Person) (happy ?x)) 
	
will try to find the next happy person and store it in the returned 
query iterator.
	 
  (retrieve 10 (?x Person) (happy ?x))
	
will try to find 10 happy people.
	 
  (retrieve 10)
	
will try to find the next 10 happy people.
	 
  (retrieve all (?x Person) (happy ?x))
	
will find all happy people.
	 
  (retrieve all (?x Person))
	
will find all people.
	 
  (retrieve (?x Person) (or (happy ?x) (parent-of Fred ?x)))
	
will try to find the next person that is happy or has Fred as a parent.
	 
  (retrieve ((?x Person) (?y Person)) (parent-of ?x ?y))
	
will try to find the next pair of parent/child.
	 
  (retrieve all (?x Person)
            (exists (?y Person) (parent-of ?x ?y)))
	
will generate the set of all parents.  Note, that for these queries to run,
the class `Person', the relations `happy' and `parent-of', and the logic
constant `Fred' must already be defined (see `assert').

Use `(set/unset-feature goal-trace)' to en/disable goal tracing of the
inference engine.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION %%RETRIEVE))
     (SET-DYNAMIC-SLOT-VALUE
      METHOD
      SYM-QUERY-EVALUATOR-WRAPPER-CODE
      (WRAP-FUNCTION-CODE (CL:FUNCTION RETRIEVE-EVALUATOR-WRAPPER))
      NULL-FUNCTION-CODE-WRAPPER))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-SUBSUMPTION-DEFINITION"
        "DESCRIPTION"
        "(DEFUN (GET-SUBSUMPTION-DEFINITION DESCRIPTION) ((SELF DESCRIPTION) (SUBORSUPER KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-SUBSUMPTION-DEFINITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESCRIPTION-SPECIALIZES-DESCRIPTION?"
        "DESCRIPTION"
        "(DEFUN (DESCRIPTION-SPECIALIZES-DESCRIPTION? BOOLEAN) ((SUB DESCRIPTION) (SUPER DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESCRIPTION-SPECIALIZES-DESCRIPTION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "VECTOR-SATISFIES-DESCRIPTION?"
        "VECTOR"
        "(DEFUN (VECTOR-SATISFIES-DESCRIPTION? BOOLEAN) ((VECTOR VECTOR) (DESCRIPTION DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION VECTOR-SATISFIES-DESCRIPTION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INSTANCE-SATISFIES-DESCRIPTION?"
        "OBJECT"
        "(DEFUN (INSTANCE-SATISFIES-DESCRIPTION? BOOLEAN) ((INSTANCE OBJECT) (DESCRIPTION DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INSTANCE-SATISFIES-DESCRIPTION?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COERCE-TO-DESCRIPTION"
        "OBJECT"
        "(DEFUN (COERCE-TO-DESCRIPTION DESCRIPTION) ((SELF OBJECT) (ORIGINAL OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COERCE-TO-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SPECIALIZES?"
        "OBJECT"
        "(DEFUN (SPECIALIZES? BOOLEAN) ((SUBOBJECT OBJECT) (SUPEROBJECT OBJECT)) :DOCUMENTATION \"Return TRUE if the description associated with `subObject'
specializes the description for `superObject'.  Return FALSE if we could
not prove that `subObject' specializes `superObject'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SPECIALIZES?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COERCE-TO-INSTANCE"
        "OBJECT"
        "(DEFUN (COERCE-TO-INSTANCE LOGIC-OBJECT) ((SELF OBJECT) (ORIGINAL OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COERCE-TO-INSTANCE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COERCE-TO-VECTOR"
        "OBJECT"
        "(DEFUN (COERCE-TO-VECTOR VECTOR) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COERCE-TO-VECTOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "SATISFIES?"
        "OBJECT"
        "(DEFUN (SATISFIES? BOOLEAN) ((INSTANCEORTUPLE OBJECT) (RELATIONREF OBJECT)) :DOCUMENTATION \"Return TRUE if `instanceOrTuple' satisfies the
definition of the relation `relationRef'.  `instanceOrTuple' can be a single
object, the name or surrogate of an object, or a collection (a list or vector)
of objects. `relationRef' can be a relation, description, surrogate or relation
name.  Return FALSE if we could not prove that `instanceOrTuple' satisfies
`relationRef'.\" :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION SATISFIES?)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-QUERY"
     NULL
     "(DEFUN STARTUP-QUERY ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *QUERYENVIRONMENT* QUERY-ENVIRONMENT NULL :DOCUMENTATION \"Points to the query environment used by the currently executing query.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-QUERY-*QUERYENVIRONMENT*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*QUERYENVIRONMENT*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*QUERYENVIRONMENT*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEFAULT-MAXIMUM-DEPTH* INTEGER 25 :DOCUMENTATION \"Possibly a good value for the maximum backtracking depth.
More testing is needed.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAXIMUM-BACKTRACKING-DEPTH* INTEGER *DEFAULT-MAXIMUM-DEPTH* :DOCUMENTATION \"Value for the maximum depth allowable during
backtrack search.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *INITIAL-BACKTRACKING-DEPTH* INTEGER 5 :DOCUMENTATION \"Value of the initial depth used during an interative
deepening search.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ITERATIVE-DEEPENING-MODE?* BOOLEAN FALSE :DOCUMENTATION \"Default setting.  If TRUE, queries are evaluated
using iterative deepening from depth '*initial-backtracking-depth*'
to depth '*maximum-backtracking-depth*'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEEP-INFERENCE-MODE?* BOOLEAN FALSE :DOCUMENTATION \"Default setting.  If TRUE, warrants use of assumption-based
proofs.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *BOOLEAN-VECTOR-INDEX* BOOLEAN-VECTOR-INDEX-NODE (NEW BOOLEAN-VECTOR-INDEX-NODE :VECTOR (NEW BOOLEAN-VECTOR :ARRAY-SIZE 0)) :DOCUMENTATION \"Points to the head of a discrimination tree of containing
all boolean vectors.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT *CONTROL-FRAME-STACK-QUANTUM* INTEGER 100 :DOCUMENTATION \"The size of the query frame stack is a multiple of the
stack quantum.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT *VARIABLE-FRAME-STACK-QUANTUM* INTEGER 100 :DOCUMENTATION \"The size of the variable bindings stack is a multiple of the
stack quantum.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT *UNBINDING-STACK-QUANTUM* INTEGER 100 :DOCUMENTATION \"The size of the old binding frame stack is a multiple of the
stack quantum.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TYPE-CHECK-STRATEGY* KEYWORD :SORT :DOCUMENTATION \"Determines whether there is a slow but thorough type test
when variables are bound, a fast but very shallow one, or none.  Values
are :NONE, :SORT, :DISJOINT  The default is :NONE because disjointness isn't
yet mature.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *REVERSEPOLARITY?* BOOLEAN FALSE :DOCUMENTATION \"Signals atomic proposition provers that polarity is negative.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-QUERY-*REVERSEPOLARITY?*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*REVERSEPOLARITY?*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*REVERSEPOLARITY?*)))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *GLOBALLY-CLOSED-COLLECTIONS?* BOOLEAN FALSE :DOCUMENTATION \"If TRUE, all collections are assumed to be closed.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT *QUERY-THREAD-LIMIT* INTEGER 8 :DOCUMENTATION \"Maximum number of simultaneous query threads.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAXIMUM-QUERY-THREAD-OFFSET* INTEGER (1- *QUERY-THREAD-LIMIT*))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *FREE-QUERY-THREAD-OFFSETS* (LIST OF INTEGER-WRAPPER) (LIST) :DOCUMENTATION \"List of unused query thread offsets.\")")
    (CL:LET*
     ((I NULL)
      (ITER-064 (REVERSE (INTERVAL 0 *MAXIMUM-QUERY-THREAD-OFFSET*))))
     (CL:LOOP
      WHILE
      (CL:EQ (NEXT? ITER-064) 1)
      DO
      (CL:PROGN
       (CL:SETQ
        I
        (CLSYS-SVAL REVERSE-INTEGER-INTERVAL-ITERATOR VALUE ITER-064)))
      (PUSH *FREE-QUERY-THREAD-OFFSETS* (WRAP-LITERAL I))))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *QUERY-ENVIRONMENTS-VECTOR* (VECTOR OF QUERY-ENVIRONMENT) (NEW VECTOR :ARRAY-SIZE *QUERY-THREAD-LIMIT*) :DOCUMENTATION \"Records currently active (unreleased) query environments.\")")
    (REGISTER-NATIVE-NAME
     SYM-QUERY-ASK
     KWD-QUERY-COMMON-LISP
     KWD-QUERY-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MOST-RECENT-QUERY* QUERY-ITERATOR NULL)")
    (REGISTER-NATIVE-NAME
     SYM-QUERY-RETRIEVE
     KWD-QUERY-COMMON-LISP
     KWD-QUERY-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL REUSABLE-SINGLETON-VECTOR VECTOR (NEW VECTOR :ARRAY-SIZE 1) :DOCUMENTATION \"Used by 'instance-satisfies-description?'.\")")))
  :VOID)
