;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

#|--------------------------------------------------------------------------+
 |                                                                          |
 |  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1997                   | 
 |  University of Southern California, Information Sciences Institute       |
 |  4676 Admiralty Way                                                      |
 |  Marina Del Rey, California 90292                                        |
 |                                                                          |
 |  This software was developed under the terms and conditions of Contract  |
 |  No. N00014-94-C-0245 between the Defense Advanced Research Projects     |
 |  Agency and the University of Southern California, Information Sciences  | 
 |  Institute.  Use and distribution of this software is further subject    |
 |  to the provisions of that contract and any other agreements developed   |
 |  between the user of the software and the University of Southern         |
 |  California, Information Sciences Institute.  It is supplied "AS IS",    |
 |  without any warranties of any kind.  It is furnished only on the basis  |
 |  that any party who receives it indemnifies and holds harmless the       |
 |  parties who furnish and originate it against any claims, demands, or    |
 |  liabilities connected with using it, furnishing it to others or         |
 |  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    |
 |  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  |
 |  BE ATTACHED TO EVERY PART.                                              |
 |                                                                          |
 +--------------------------------------------------------------------------|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-DESCRIPTIONS-?X1 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X2 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X3 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X4 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X5 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X6 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X7 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X8 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X9 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X10 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X11 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X12 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X13 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X14 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X15 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X16 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X17 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X18 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X19 NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X20 NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-MODULE NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-SETOFALL NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-ISA NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-?X NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-SLOT NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-BOOLEAN NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-TYPE-SPEC NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-TABLE NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-SYMBOL NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-CONS NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-KAPPA NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-COMMA NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-WHERE NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-COLLECTION NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-IN NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-= NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-PREFIX-STELLA NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-PRIMITIVE NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-DESCRIPTION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-DESCRIPTION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-RELATION NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-DEFINITION-STRING NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-DEFINITION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-CLASS NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-ANY-VALUE NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-ITERATOR NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-*LOGICVARIABLETABLE* NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-SKOLEM NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-SKOLEM-NAME NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-VARIABLE-TYPE? NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PATTERN-VARIABLE NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-CONCEIVE NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-FUNCTION NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-PREDICATE NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-IN NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-EQUIVALENT NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-EXISTS NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-AND NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PROPOSITION NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-IO-VARIABLES NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-EQUIVALENCE NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-AND NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-EXISTS NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-DEFINITION NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-QUERY NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-THE-ONLY NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-IOTA? NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-DESCRIPTION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-PROPOSITION-ERROR NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-ASSERT-TRUE NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-ENUMERATION NULL)
(CL:DEFVAR KWD-DESCRIPTIONS-RETRACT-TRUE NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-UNKNOWN NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-EXTENSION NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-CLOSED NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-LISTOF NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-SETOF NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-ORDERED NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-DUPLICATE-FREE NULL)
(CL:DEFVAR SYM-DESCRIPTIONS-COMPLEMENT-DESCRIPTION NULL)
(CL:DEFVAR SGT-DESCRIPTIONS-TYPE NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL
  *FREESKOLEMS*
  *EXCEPTIONHANDLERADDRESS*
  *EXCEPTION*
  *EXCEPTION-TYPE*
  *EVALUATIONMODE*
  TRUE-PROPOSITION
  *TOPLEVELPROPOSITIONS*
  ZERO-VARIABLES-VECTOR
  NULL-BOOLEAN-WRAPPER
  STANDARD-OUTPUT
  *PROPOSITIONUNDERCONSTRUCTION*
  *THE-PROPOSITION-ERROR*
  NULL-STRING-WRAPPER
  EOL
  *MODULE*))

;;; (DEFCONSTANT FAKE-IO-VARIABLES ...)

(CL:DEFVAR FAKE-IO-VARIABLES NULL
  "Installed in a description with undetermined arity.")

;;; (DEFUN (CREATE-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN CREATE-DESCRIPTION (ARITY KIND)
  (CL:LET*
   ((DESCRIPTION (NEW-DESCRIPTION)))
   (CL:SETF
    (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION)
    (CL:IF (CL:EQ (DEFINED? ARITY) 1) (NEW-VECTOR ARITY) FAKE-IO-VARIABLES))
   (CL:SETF (CLSYS-SVAL DESCRIPTION KIND DESCRIPTION) KIND)
   (CL:RETURN-FROM CREATE-DESCRIPTION DESCRIPTION))
  :VOID)

;;; (DEFCONSTANT SYSTEM-DEFINED-ARGUMENT-NAMES ...)

(CL:DEFVAR SYSTEM-DEFINED-ARGUMENT-NAMES NULL)

;;; (DEFUN (CREATE-DESCRIPTION-FOR-RELATION DESCRIPTION) ...)

(CL:DEFUN CREATE-DESCRIPTION-FOR-RELATION (SELF)
  (CL:LET*
   ((DESCRIPTION NULL) (EXPRESSION NULL) (NATIVEMODULE NULL))
   (CL:LET*
    ((*TRANSIENTOBJECTS?* TRUE))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:LET*
     ((SELF-001 SELF))
     (CL:COND
      ((CL:EQ (CLASS? SELF) 1)
       (CL:LET*
        ((SELF NULL))
        (CL:SETQ SELF SELF-001)
        (CL:SETQ
         NATIVEMODULE
         (CAST
          (CLSYS-SVAL
           SURROGATE
           HOME-CONTEXT
           (CLSYS-SVAL CLASS CLASS-TYPE SELF))
          SGT-DESCRIPTIONS-MODULE))
        (CL:SETQ
         EXPRESSION
         (LIST*
          SYM-DESCRIPTIONS-SETOFALL
          (LIST*
           SYM-DESCRIPTIONS-ISA
           SYM-DESCRIPTIONS-?X
           (CLSYS-SVAL CLASS CLASS-TYPE SELF)
           NIL)
          NIL))))
      ((CL:EQ (TAXONOMY-ISA? SELF SGT-DESCRIPTIONS-SLOT) 1)
       (CL:LET*
        ((SELF NULL))
        (CL:SETQ SELF SELF-001)
        (CL:SETQ
         NATIVEMODULE
         (CAST
          (CLSYS-SVAL
           SURROGATE
           HOME-CONTEXT
           (CLSYS-SVAL SLOT SLOT-OWNER SELF))
          SGT-DESCRIPTIONS-MODULE))
        (CL:LET*
         ((ARITY (CL:1+ (METHOD-ARGUMENT-COUNT SELF)))
          (SLOTNAME (CLSYS-SVAL SLOT SLOT-NAME SELF))
          (SLOTTYPE
           (WRAPPED-TYPE-TO-TYPE (CLSYS-SVAL SLOT SLOT-BASE-TYPE SELF)))
          (PREDICATE? (EQ? SLOTTYPE SGT-DESCRIPTIONS-BOOLEAN))
          (TYPELIST NIL)
          (TYPEDVARIABLES NIL)
          (ARGUMENTS NIL))
         (CL:WHEN
          (CL:> ARITY (LENGTH SYSTEM-DEFINED-ARGUMENT-NAMES))
          (CL:ERROR
           "PowerLoom can't handle relations with arity > `~A'~%"
           (LENGTH SYSTEM-DEFINED-ARGUMENT-NAMES)))
         (CL:LET*
          ((SELF-002 SELF))
          (CL:COND
           ((CL:EQ (STORAGE-SLOT? SELF) 1)
            (CL:LET*
             ((SELF NULL))
             (CL:SETQ SELF SELF-002)
             (CL:IF
              (CL:EQ PREDICATE? 1)
              (CL:SETQ
               TYPELIST
               (CONS (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SELF) NIL))
              (CL:SETQ
               TYPELIST
               (CONS
                (CLSYS-SVAL STORAGE-SLOT SLOT-OWNER SELF)
                (CONS SLOTTYPE NIL))))))
           ((CL:EQ (METHOD-SLOT? SELF) 1)
            (CL:LET*
             ((SELF NULL))
             (CL:SETQ SELF SELF-002)
             (CL:LET*
              ((TS NULL)
               (ITER-001
                (CLSYS-SVAL
                 LIST
                 THE-CONS-LIST
                 (METHOD-PARAMETER-TYPE-SPECIFIERS SELF)))
               (COLLECT-001 NULL))
              (CL:LOOP
               WHILE
               (CL:NOT (CL:EQ ITER-001 NIL))
               DO
               (CL:PROGN
                (CL:SETQ
                 TS
                 (CAST
                  (CLSYS-SVAL CONS VALUE ITER-001)
                  SGT-DESCRIPTIONS-TYPE-SPEC))
                (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
               (CL:IF
                (CL:EQ COLLECT-001 NULL)
                (CL:PROGN
                 (CL:SETQ
                  COLLECT-001
                  (CONS
                   (WRAPPED-TYPE-TO-TYPE (TYPE-SPEC-TO-BASE-TYPE TS))
                   NIL))
                 (CL:IF
                  (CL:EQ TYPELIST NIL)
                  (CL:SETQ TYPELIST COLLECT-001)
                  (ADD-CONS-TO-END-OF-CONS-LIST TYPELIST COLLECT-001)))
                (CL:PROGN
                 (CL:SETF
                  (CLSYS-SVAL CONS REST COLLECT-001)
                  (CONS
                   (WRAPPED-TYPE-TO-TYPE (TYPE-SPEC-TO-BASE-TYPE TS))
                   NIL))
                 (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001))))))
             (CL:WHEN
              (CL:EQ PREDICATE? 0)
              (CL:SETQ TYPELIST (CONCATENATE TYPELIST (CONS SLOTTYPE NIL))))))
           ((CL:EQ (TAXONOMY-ISA? SELF SGT-DESCRIPTIONS-TABLE) 1)
            (CL:LET*
             ((SELF NULL))
             (CL:SETQ SELF SELF-002)
             (CL:LET*
              ((T NULL)
               (ITER-002
                (CLSYS-SVAL
                 LIST
                 THE-CONS-LIST
                 (CLSYS-SVAL TABLE TUPLE-DOMAINS SELF)))
               (COLLECT-002 NULL))
              (CL:LOOP
               WHILE
               (CL:NOT (CL:EQ ITER-002 NIL))
               DO
               (CL:PROGN
                (CL:SETQ
                 T
                 (CAST
                  (CLSYS-SVAL CONS VALUE ITER-002)
                  SGT-DESCRIPTIONS-TYPE-SPEC))
                (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
               (CL:IF
                (CL:EQ COLLECT-002 NULL)
                (CL:PROGN
                 (CL:SETQ COLLECT-002 (CONS T NIL))
                 (CL:IF
                  (CL:EQ TYPELIST NIL)
                  (CL:SETQ TYPELIST COLLECT-002)
                  (ADD-CONS-TO-END-OF-CONS-LIST TYPELIST COLLECT-002)))
                (CL:PROGN
                 (CL:SETF (CLSYS-SVAL CONS REST COLLECT-002) (CONS T NIL))
                 (CL:SETQ COLLECT-002 (CLSYS-SVAL CONS REST COLLECT-002))))))
             (CL:WHEN
              (CL:EQ PREDICATE? 0)
              (CL:SETQ TYPELIST (CONCATENATE TYPELIST (CONS SLOTTYPE NIL))))))
           (CL:T (CL:ERROR "`~A' is not a valid case option" SELF))))
         (CL:LET*
          ((VBLTYPE NULL)
           (NAME NULL)
           (I NULL)
           (ITER-003 1)
           (UPPER-BOUND-001 ARITY)
           (UNBOUNDED?-001 (NULL? UPPER-BOUND-001))
           (ITER-004 SYSTEM-DEFINED-ARGUMENT-NAMES)
           (ITER-005 TYPELIST)
           (COLLECT-003 NULL))
          (CL:LOOP
           WHILE
           (CL:AND
            (CL:OR (CL:EQ UNBOUNDED?-001 1) (CL:<= ITER-003 UPPER-BOUND-001))
            (CL:NOT (CL:EQ ITER-004 NIL))
            (CL:NOT (CL:EQ ITER-005 NIL)))
           DO
           (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
           (CL:PROGN
            (CL:SETQ
             NAME
             (CAST (CLSYS-SVAL CONS VALUE ITER-004) SGT-DESCRIPTIONS-SYMBOL))
            (CL:SETQ ITER-004 (CLSYS-SVAL CONS REST ITER-004)))
           (CL:PROGN
            (CL:SETQ VBLTYPE (CLSYS-SVAL CONS VALUE ITER-005))
            (CL:SETQ ITER-005 (CLSYS-SVAL CONS REST ITER-005)))
           (CL:IF
            (CL:EQ COLLECT-003 NULL)
            (CL:PROGN
             (CL:SETQ
              COLLECT-003
              (CONS (LIST* SYM-DESCRIPTIONS-ISA NAME (CONS VBLTYPE NIL)) NIL))
             (CL:IF
              (CL:EQ TYPEDVARIABLES NIL)
              (CL:SETQ TYPEDVARIABLES COLLECT-003)
              (ADD-CONS-TO-END-OF-CONS-LIST TYPEDVARIABLES COLLECT-003)))
            (CL:PROGN
             (CL:SETF
              (CLSYS-SVAL CONS REST COLLECT-003)
              (CONS (LIST* SYM-DESCRIPTIONS-ISA NAME (CONS VBLTYPE NIL)) NIL))
             (CL:SETQ COLLECT-003 (CLSYS-SVAL CONS REST COLLECT-003))))))
         (CL:IF
          (CL:EQ PREDICATE? 1)
          (CL:PROGN
           (CL:LET*
            ((VBLFORM NULL) (ITER-006 TYPEDVARIABLES) (COLLECT-004 NULL))
            (CL:LOOP
             WHILE
             (CL:NOT (CL:EQ ITER-006 NIL))
             DO
             (CL:PROGN
              (CL:SETQ
               VBLFORM
               (CAST (CLSYS-SVAL CONS VALUE ITER-006) SGT-DESCRIPTIONS-CONS))
              (CL:SETQ ITER-006 (CLSYS-SVAL CONS REST ITER-006)))
             (CL:IF
              (CL:EQ COLLECT-004 NULL)
              (CL:PROGN
               (CL:SETQ COLLECT-004 (CONS (SECOND VBLFORM) NIL))
               (CL:IF
                (CL:EQ ARGUMENTS NIL)
                (CL:SETQ ARGUMENTS COLLECT-004)
                (ADD-CONS-TO-END-OF-CONS-LIST ARGUMENTS COLLECT-004)))
              (CL:PROGN
               (CL:SETF
                (CLSYS-SVAL CONS REST COLLECT-004)
                (CONS (SECOND VBLFORM) NIL))
               (CL:SETQ COLLECT-004 (CLSYS-SVAL CONS REST COLLECT-004))))))
           (CL:SETQ
            EXPRESSION
            (LIST*
             SYM-DESCRIPTIONS-KAPPA
             (CONS SYM-DESCRIPTIONS-COMMA (CONCATENATE TYPEDVARIABLES NIL))
             (LIST*
              SYM-DESCRIPTIONS-WHERE
              (CONS SLOTNAME (CONCATENATE ARGUMENTS NIL))
              NIL)
             NIL)))
          (CL:LET*
           ((OUTPUTARG (SECOND (LAST TYPEDVARIABLES))))
           (CL:LET*
            ((VBLFORM NULL)
             (ITER-007 (BUT-LAST TYPEDVARIABLES))
             (COLLECT-005 NULL))
            (CL:LOOP
             WHILE
             (CL:EQ (NEXT? ITER-007) 1)
             DO
             (CL:PROGN
              (CL:SETQ
               VBLFORM
               (CAST
                (CLSYS-SVAL ITERATOR VALUE ITER-007)
                SGT-DESCRIPTIONS-CONS)))
             (CL:IF
              (CL:EQ COLLECT-005 NULL)
              (CL:PROGN
               (CL:SETQ COLLECT-005 (CONS (SECOND VBLFORM) NIL))
               (CL:IF
                (CL:EQ ARGUMENTS NIL)
                (CL:SETQ ARGUMENTS COLLECT-005)
                (ADD-CONS-TO-END-OF-CONS-LIST ARGUMENTS COLLECT-005)))
              (CL:PROGN
               (CL:SETF
                (CLSYS-SVAL CONS REST COLLECT-005)
                (CONS (SECOND VBLFORM) NIL))
               (CL:SETQ COLLECT-005 (CLSYS-SVAL CONS REST COLLECT-005))))))
           (CL:IF
            (CL:EQ (ISA? SLOTTYPE SGT-DESCRIPTIONS-COLLECTION) 1)
            (CL:SETQ
             EXPRESSION
             (LIST*
              SYM-DESCRIPTIONS-KAPPA
              (CONS SYM-DESCRIPTIONS-COMMA (CONCATENATE TYPEDVARIABLES NIL))
              (LIST*
               SYM-DESCRIPTIONS-WHERE
               (LIST*
                SYM-DESCRIPTIONS-IN
                OUTPUTARG
                (CONS (CONS SLOTNAME (CONCATENATE ARGUMENTS NIL)) NIL))
               NIL)
              NIL))
            (CL:SETQ
             EXPRESSION
             (LIST*
              SYM-DESCRIPTIONS-KAPPA
              (CONS SYM-DESCRIPTIONS-COMMA (CONCATENATE TYPEDVARIABLES NIL))
              (LIST*
               SYM-DESCRIPTIONS-WHERE
               (LIST*
                SYM-DESCRIPTIONS-=
                OUTPUTARG
                (CONS (CONS SLOTNAME (CONCATENATE ARGUMENTS NIL)) NIL))
               NIL)
              NIL))))))))
      (CL:T (CL:ERROR "`~A' is not a valid case option" SELF)))))
   (CL:LET*
    ((*LOGIC-DIALECT* KWD-DESCRIPTIONS-PREFIX-STELLA))
    (CL:DECLARE (CL:SPECIAL *LOGIC-DIALECT*))
    (CL:LET*
     ((*MODULE* NATIVEMODULE) (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CL:SETQ
      DESCRIPTION
      (CREATE-TOP-LEVEL-DESCRIPTION
       EXPRESSION
       KWD-DESCRIPTIONS-PRIMITIVE
       SELF))))
   (SET-DYNAMIC-SLOT-VALUE SELF SYM-DESCRIPTIONS-DESCRIPTION DESCRIPTION NULL)
   (CL:SETF (CLSYS-SVAL DESCRIPTION NATIVE-RELATION DESCRIPTION) SELF)
   (CL:RETURN-FROM CREATE-DESCRIPTION-FOR-RELATION DESCRIPTION))
  :VOID)

;;; (DEFMETHOD (GET-DESCRIPTION DESCRIPTION) ...)

(CL:DEFMETHOD GET-DESCRIPTION ((SELF SURROGATE))
  (CL:LET*
   ((VALUE (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF)) (DESCRIPTION NULL))
   (CL:WHEN
    (CL:NOT (CL:EQ VALUE NULL))
    (CL:LET*
     ((VALUE-001 VALUE))
     (CL:COND
      ((CL:EQ (TAXONOMY-ISA? VALUE SGT-DESCRIPTIONS-DESCRIPTION) 1)
       (CL:LET*
        ((VALUE NULL))
        (CL:SETQ VALUE VALUE-001)
        (CL:RETURN-FROM GET-DESCRIPTION VALUE)))
      ((CL:EQ (TAXONOMY-ISA? VALUE SGT-DESCRIPTIONS-RELATION) 1)
       (CL:LET*
        ((VALUE NULL))
        (CL:SETQ VALUE VALUE-001)
        (CL:IF
         (CL:NOT
          (CL:EQ
           (DYNAMIC-SLOT-VALUE VALUE SYM-DESCRIPTIONS-DESCRIPTION NULL)
           NULL))
         (CL:RETURN-FROM
          GET-DESCRIPTION
          (DYNAMIC-SLOT-VALUE VALUE SYM-DESCRIPTIONS-DESCRIPTION NULL))
         (CL:LET*
          ((DESCRIPTION (CREATE-DESCRIPTION-FOR-RELATION VALUE)))
          (FINALIZE-SUPERRELATION-LINKS VALUE)
          (CL:RETURN-FROM GET-DESCRIPTION DESCRIPTION)))))
      (CL:T (CL:RETURN-FROM GET-DESCRIPTION NULL)))))
   (CL:SETQ
    DESCRIPTION
    (CREATE-DESCRIPTION NULL-INTEGER KWD-DESCRIPTIONS-PRIMITIVE))
   (CL:SETF (CLSYS-SVAL SURROGATE SURROGATE-VALUE SELF) DESCRIPTION)
   (CL:RETURN-FROM GET-DESCRIPTION DESCRIPTION))
  :VOID)

;;; (DEFMETHOD (GET-DESCRIPTION DESCRIPTION) ...)

(CL:DEFMETHOD GET-DESCRIPTION ((SELF SYMBOL))
  (CL:RETURN-FROM
   GET-DESCRIPTION
   (GET-DESCRIPTION (CLSYS-SVAL SYMBOL SYMBOL-NAME SELF)))
  :VOID)

;;; (DEFMETHOD (GET-DESCRIPTION DESCRIPTION) ...)

(CL:DEFMETHOD GET-DESCRIPTION ((SELF GENERALIZED-SYMBOL))
  (CL:RETURN-FROM GET-DESCRIPTION NULL)
  :VOID)

;;; (DEFMETHOD (GET-DESCRIPTION DESCRIPTION) ...)

(CL:DEFMETHOD GET-DESCRIPTION ((SELF CL:STRING))
  (CL:LET*
   ((SURROGATE (LOOKUP-SURROGATE SELF)))
   (CL:IF
    (CL:NOT (CL:EQ SURROGATE NULL))
    (CL:RETURN-FROM GET-DESCRIPTION (GET-DESCRIPTION SURROGATE))
    (CL:RETURN-FROM GET-DESCRIPTION NULL)))
  :VOID)

;;; (DEFMETHOD (GET-DESCRIPTION DESCRIPTION) ...)

(CL:DEFMETHOD GET-DESCRIPTION ((SELF RELATION))
  (CL:RETURN-FROM GET-DESCRIPTION NULL)
  :VOID)

;;; (DEFMETHOD (GET-DESCRIPTION DESCRIPTION) ...)

(CL:DEFMETHOD GET-DESCRIPTION ((SELF CLASS))
  (CL:IF
   (CL:NOT
    (CL:EQ (DYNAMIC-SLOT-VALUE SELF SYM-DESCRIPTIONS-DESCRIPTION NULL) NULL))
   (CL:RETURN-FROM
    GET-DESCRIPTION
    (DYNAMIC-SLOT-VALUE SELF SYM-DESCRIPTIONS-DESCRIPTION NULL))
   (CL:RETURN-FROM
    GET-DESCRIPTION
    (GET-DESCRIPTION (CLSYS-SVAL CLASS CLASS-TYPE SELF))))
  :VOID)

;;; (DEFMETHOD (GET-DESCRIPTION DESCRIPTION) ...)

(CL:DEFMETHOD GET-DESCRIPTION ((SELF SLOT))
  (CL:COND
   ((CL:NOT
     (CL:EQ (DYNAMIC-SLOT-VALUE SELF SYM-DESCRIPTIONS-DESCRIPTION NULL) NULL))
    (CL:RETURN-FROM
     GET-DESCRIPTION
     (DYNAMIC-SLOT-VALUE SELF SYM-DESCRIPTIONS-DESCRIPTION NULL)))
   ((CL:NOT (CL:EQ (CLSYS-SVAL SLOT SLOT-SLOTREF SELF) NULL))
    (CL:RETURN-FROM
     GET-DESCRIPTION
     (GET-DESCRIPTION (CLSYS-SVAL SLOT SLOT-SLOTREF SELF))))
   (CL:T
    (CL:RETURN-FROM
     GET-DESCRIPTION
     (GET-DESCRIPTION
      (LOOKUP-SLOTREF
       (CLSYS-SVAL SLOT SLOT-OWNER SELF)
       (CLSYS-SVAL SLOT SLOT-NAME SELF))))))
  :VOID)

;;; (DEFMETHOD (PRIMITIVE? BOOLEAN) ...)

(CL:DEFMETHOD PRIMITIVE? ((SELF CLASS))
  "Return TRUE if 'self' is not a defined class."
  (CL:RETURN-FROM
   PRIMITIVE?
   (NULL?
    (CLSYS-SVAL
     STRING-WRAPPER
     WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE
      SELF
      SYM-DESCRIPTIONS-DEFINITION-STRING
      NULL-STRING-WRAPPER))))
  :VOID)

;;; (DEFMETHOD (PRIMITIVE? BOOLEAN) ...)

(CL:DEFMETHOD PRIMITIVE? ((SELF SLOT))
  "Return TRUE if 'self' is not a defined slot."
  (CL:RETURN-FROM
   PRIMITIVE?
   (NULL?
    (CLSYS-SVAL
     STRING-WRAPPER
     WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE
      SELF
      SYM-DESCRIPTIONS-DEFINITION-STRING
      NULL-STRING-WRAPPER))))
  :VOID)

;;; (DEFMETHOD (PRIMITIVE? BOOLEAN) ...)

(CL:DEFMETHOD PRIMITIVE? ((SELF DESCRIPTION))
  "Return TRUE if 'self' attached to a primitive
relation.  Definitions that enumerate their members are considered
primitive."
  (CL:RETURN-FROM
   PRIMITIVE?
   (CL:IF
    (CL:AND
     (CL:NOT (CL:EQ (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF) NULL))
     (CL:EQ
      (DYNAMIC-SLOT-VALUE
       (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF)
       SYM-DESCRIPTIONS-DEFINITION
       NULL)
      NULL))
    TRUE
    FALSE))
  :VOID)

;;; (DEFUN (DESCRIPTION-OWNER-TYPE TYPE) ...)

(CL:DEFUN DESCRIPTION-OWNER-TYPE (DESCRIPTION)
  (CL:LET*
   ((OWNER (CLSYS-SVAL DESCRIPTION NATIVE-RELATION DESCRIPTION)))
   (CL:WHEN
    (CL:NOT (CL:EQ OWNER NULL))
    (CL:LET*
     ((OWNER-001 OWNER))
     (CL:COND
      ((CL:EQ (CLASS? OWNER) 1)
       (CL:LET*
        ((OWNER NULL))
        (CL:SETQ OWNER OWNER-001)
        (CL:RETURN-FROM
         DESCRIPTION-OWNER-TYPE
         (CLSYS-SVAL CLASS CLASS-TYPE OWNER))))
      (CL:T NULL))))
   (CL:RETURN-FROM DESCRIPTION-OWNER-TYPE NULL))
  :VOID)

;;; (DEFUN (LOGIC-OBJECT.MEMBER-TYPE-FROM-COLLECTION TYPE) ...)

(CL:DEFUN LOGIC-OBJECT.MEMBER-TYPE-FROM-COLLECTION (SELF)
  (CL:LET*
   ((TYPE NULL))
   (CL:LET*
    ((SUPERSET NULL) (ITER-001 (ALL-SUPERCOLLECTIONS SELF)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-001) 1)
     DO
     (CL:PROGN
      (CL:SETQ
       SUPERSET
       (CAST
        (CLSYS-SVAL ITERATOR VALUE ITER-001)
        SGT-DESCRIPTIONS-LOGIC-OBJECT)))
     (CL:LET*
      ()
      (CL:SETQ TYPE (MEMBER-TYPE-FROM-COLLECTION SUPERSET))
      (CL:WHEN
       (CL:NOT (CL:EQ TYPE NULL))
       (CL:RETURN-FROM LOGIC-OBJECT.MEMBER-TYPE-FROM-COLLECTION TYPE)))))
   (CL:RETURN-FROM
    LOGIC-OBJECT.MEMBER-TYPE-FROM-COLLECTION
    (MEMBER-TYPE-FROM-COLLECTION (LOGICAL-TYPE SELF))))
  :VOID)

;;; (DEFUN (DESCRIPTION.MEMBER-TYPE-FROM-COLLECTION TYPE) ...)

(CL:DEFUN DESCRIPTION.MEMBER-TYPE-FROM-COLLECTION (SELF)
  (CL:LET*
   ((OWNERTYPE (DESCRIPTION-OWNER-TYPE SELF)))
   (CL:COND
    ((CL:NOT (CL:EQ OWNERTYPE NULL))
     (CL:RETURN-FROM DESCRIPTION.MEMBER-TYPE-FROM-COLLECTION OWNERTYPE))
    ((CL:NOT (CL:EQ (REPRESENTATIVE SELF) NULL))
     (CL:RETURN-FROM
      DESCRIPTION.MEMBER-TYPE-FROM-COLLECTION
      (CLSYS-SVAL PATTERN-VARIABLE ROOT-TYPE (REPRESENTATIVE SELF))))
    (CL:T (CL:RETURN-FROM DESCRIPTION.MEMBER-TYPE-FROM-COLLECTION NULL))))
  :VOID)

;;; (DEFUN (MEMBER-TYPE-FROM-COLLECTION TYPE) ...)

(CL:DEFUN MEMBER-TYPE-FROM-COLLECTION (SELF)
  (CL:LET*
   ((SELF-001 SELF))
   (CL:COND
    ((CL:EQ (SURROGATE? SELF) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM MEMBER-TYPE-FROM-COLLECTION SELF)))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-DESCRIPTIONS-DESCRIPTION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       MEMBER-TYPE-FROM-COLLECTION
       (DESCRIPTION.MEMBER-TYPE-FROM-COLLECTION SELF))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-DESCRIPTIONS-LOGIC-OBJECT) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:RETURN-FROM
       MEMBER-TYPE-FROM-COLLECTION
       (LOGIC-OBJECT.MEMBER-TYPE-FROM-COLLECTION SELF))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-DESCRIPTIONS-COLLECTION) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((COLLECTIONTYPE (PRIMARY-TYPE SELF))
        (SLOT
         (LOOKUP-SLOT
          (CAST
           (CLSYS-SVAL SURROGATE SURROGATE-VALUE COLLECTIONTYPE)
           SGT-DESCRIPTIONS-CLASS)
          SYM-DESCRIPTIONS-ANY-VALUE)))
       (CL:RETURN-FROM
        MEMBER-TYPE-FROM-COLLECTION
        (CL:IF (CL:NOT (CL:EQ SLOT NULL)) (TYPE SLOT) NULL)))))
    ((CL:EQ (TAXONOMY-ISA? SELF SGT-DESCRIPTIONS-ITERATOR) 1)
     (CL:LET*
      ((SELF NULL))
      (CL:SETQ SELF SELF-001)
      (CL:LET*
       ((COLLECTIONTYPE (PRIMARY-TYPE SELF))
        (SLOT
         (LOOKUP-SLOT
          (CAST
           (CLSYS-SVAL SURROGATE SURROGATE-VALUE COLLECTIONTYPE)
           SGT-DESCRIPTIONS-CLASS)
          SYM-DESCRIPTIONS-ANY-VALUE)))
       (CL:RETURN-FROM
        MEMBER-TYPE-FROM-COLLECTION
        (CL:IF (CL:NOT (CL:EQ SLOT NULL)) (TYPE SLOT) NULL)))))
    (CL:T (CL:ERROR "`~A' is not a valid case option" SELF))))
  :VOID)

;;; (DEFUN (DESCRIPTION-NAME SYMBOL) ...)

(CL:DEFUN DESCRIPTION-NAME (SELF)
  (CL:LET*
   ((RELATION (CLSYS-SVAL DESCRIPTION NATIVE-RELATION SELF)))
   (CL:WHEN (CL:EQ RELATION NULL) (CL:RETURN-FROM DESCRIPTION-NAME NULL))
   (CL:LET*
    ((RELATION-001 RELATION))
    (CL:COND
     ((CL:EQ (CLASS? RELATION) 1)
      (CL:LET*
       ((RELATION NULL))
       (CL:SETQ RELATION RELATION-001)
       (CL:RETURN-FROM
        DESCRIPTION-NAME
        (INTERN-SYMBOL (CLASS-NAME RELATION)))))
     ((CL:EQ (TAXONOMY-ISA? RELATION SGT-DESCRIPTIONS-SLOT) 1)
      (CL:LET*
       ((RELATION NULL))
       (CL:SETQ RELATION RELATION-001)
       (CL:RETURN-FROM
        DESCRIPTION-NAME
        (CLSYS-SVAL SLOT SLOT-NAME RELATION))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" RELATION)))))
  :VOID)

;;; (DEFSPECIAL *LOGICVARIABLETABLE* ...)

(CL:DEFVAR *LOGICVARIABLETABLE* NULL
  "Table mapping logic variable names to variables or skolems.
Used during construction of a proposition or description.")

(CL:DEFUN READ-*LOGICVARIABLETABLE* ()
  (CL:RETURN-FROM READ-*LOGICVARIABLETABLE* *LOGICVARIABLETABLE*)
  :VOID)

(CL:DEFUN WRITE-*LOGICVARIABLETABLE* (VALUE)
  (CL:SETQ *LOGICVARIABLETABLE* VALUE)
  (CL:RETURN-FROM WRITE-*LOGICVARIABLETABLE* VALUE)
  :VOID)

;;; (DEFUN PUSH-LOGIC-VARIABLE-BINDING ...)

(CL:DEFUN PUSH-LOGIC-VARIABLE-BINDING (VARIABLE)
  (CL:WHEN
   (CL:EQ (ANONYMOUS-VARIABLE? VARIABLE) 1)
   (CL:LET*
    ((*PRINTREADABLY?* TRUE))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "Error in logical expression." %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING
      "   Illegal nameless variable '?' found in list of
quantified variables."
      %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM)
     (CL:WRITE-STRING "   Quantified variables must have names." %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING
      "   Error occured while parsing the proposition: "
      %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (CL:LET
     ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
     (CL:WRITE-STRING "   " %%STREAM)
     (PRINT-OBJECT *PROPOSITIONUNDERCONSTRUCTION* %%STREAM)
     (CL:TERPRI %%STREAM)
     (CL:FORCE-OUTPUT %%STREAM))
    (SIGNAL *THE-PROPOSITION-ERROR*)))
  (CL:SETQ *LOGICVARIABLETABLE* (CONS VARIABLE *LOGICVARIABLETABLE*))
  :VOID)

;;; (DEFUN POP-LOGIC-VARIABLE-BINDING ...)

(CL:DEFUN POP-LOGIC-VARIABLE-BINDING ()
  (CL:LET*
   ((HEADCONS *LOGICVARIABLETABLE*))
   (CL:SETQ *LOGICVARIABLETABLE* (CLSYS-SVAL CONS REST HEADCONS))
   (FREE HEADCONS))
  :VOID)

;;; (DEFUN POP-LOGIC-VARIABLE-BINDINGS ...)

(CL:DEFUN POP-LOGIC-VARIABLE-BINDINGS (VARIABLES)
  (CL:LET*
   ((I NULL) (ITER-001 1) (UPPER-BOUND-001 (LENGTH VARIABLES)))
   (CL:LOOP
    WHILE
    (CL:<= ITER-001 UPPER-BOUND-001)
    DO
    (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
    (CL:SETQ I I)
    (POP-LOGIC-VARIABLE-BINDING)))
  :VOID)

;;; (DEFUN (LOOKUP-LOGIC-VARIABLE-BINDING OBJECT) ...)

(CL:DEFUN LOOKUP-LOGIC-VARIABLE-BINDING (VARIABLENAME)
  (CL:WHEN
   (CL:NOT (CL:EQ *LOGICVARIABLETABLE* NULL))
   (CL:LET*
    ((VBL NULL) (ITER-001 *LOGICVARIABLETABLE*))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       VBL
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-DESCRIPTIONS-SKOLEM))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:WHEN
      (CL:EQ
       (DYNAMIC-SLOT-VALUE VBL SYM-DESCRIPTIONS-SKOLEM-NAME NULL)
       VARIABLENAME)
      (CL:RETURN-FROM LOOKUP-LOGIC-VARIABLE-BINDING VBL)))))
  (CL:RETURN-FROM LOOKUP-LOGIC-VARIABLE-BINDING NULL)
  :VOID)

;;; (DEFUN (PARSE-LOGIC-VARIABLE-DECLARATIONS (CONS OF SKOLEM)) ...)

(CL:DEFUN PARSE-LOGIC-VARIABLE-DECLARATIONS (TREE UPDATEMODE VARIABLE?)
  (CL:LET*
   ((OPERATOR (CAST (FIRST TREE) SGT-DESCRIPTIONS-SYMBOL)))
   (CL:COND
    ((CL:OR
      (CL:EQ OPERATOR SYM-DESCRIPTIONS-ISA)
      (CL:EQ OPERATOR SYM-DESCRIPTIONS-IN))
     (CL:LET*
      ((VARIABLE
        (CL:IF
         (CL:EQ VARIABLE? 1)
         (CREATE-VARIABLE
          NULL
          (CAST (SECOND TREE) SGT-DESCRIPTIONS-SYMBOL)
          TRUE)
         (CREATE-SKOLEM NULL (CAST (SECOND TREE) SGT-DESCRIPTIONS-SYMBOL))))
       (PROPOSITION NULL))
      (PUSH-LOGIC-VARIABLE-BINDING VARIABLE)
      (CL:SETQ PROPOSITION (BUILD-TOP-LEVEL-PROPOSITION TREE UPDATEMODE))
      (SET-DYNAMIC-SLOT-VALUE
       PROPOSITION
       SYM-DESCRIPTIONS-VARIABLE-TYPE?
       (WRAP-BOOLEAN TRUE)
       NULL-BOOLEAN-WRAPPER)
      (CL:RETURN-FROM
       PARSE-LOGIC-VARIABLE-DECLARATIONS
       (CONS-LIST VARIABLE))))
    ((CL:EQ OPERATOR SYM-DESCRIPTIONS-COMMA)
     (CL:LET*
      ((CONSLIST NIL))
      (CL:LET*
       ((TERM NULL) (ITER-001 (CLSYS-SVAL CONS REST TREE)))
       (CL:LOOP
        WHILE
        (CL:NOT (CL:EQ ITER-001 NIL))
        DO
        (CL:PROGN
         (CL:SETQ TERM (CLSYS-SVAL CONS VALUE ITER-001))
         (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
        (CL:SETQ
         CONSLIST
         (CONCATENATE
          CONSLIST
          (PARSE-LOGIC-VARIABLE-DECLARATIONS
           (CAST TERM SGT-DESCRIPTIONS-CONS)
           UPDATEMODE
           VARIABLE?)))))
      (CL:RETURN-FROM PARSE-LOGIC-VARIABLE-DECLARATIONS CONSLIST)))
    (CL:T (CL:ERROR "`~A' is not a valid case option" OPERATOR))))
  :VOID)

;;; (DEFUN (COPY-CONS-LIST-TO-VARIABLES-VECTOR VARIABLES-VECTOR) ...)

(CL:DEFUN COPY-CONS-LIST-TO-VARIABLES-VECTOR (CONSLIST)
  (CL:WHEN
   (CL:EQ CONSLIST NIL)
   (CL:RETURN-FROM COPY-CONS-LIST-TO-VARIABLES-VECTOR ZERO-VARIABLES-VECTOR))
  (CL:LET*
   ((VECTOR (NEW-VECTOR (LENGTH CONSLIST))))
   (CL:LET*
    ((I NULL) (T NULL) (ITER-001 CONSLIST) (ITER-002 0))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ T (CLSYS-SVAL CONS VALUE ITER-001))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
     (CL:SETF
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR) I)
      (CAST T SGT-DESCRIPTIONS-PATTERN-VARIABLE))))
   (CL:RETURN-FROM COPY-CONS-LIST-TO-VARIABLES-VECTOR VECTOR))
  :VOID)

;;; (DEFUN (BUILD-QUANTIFIED-PROPOSITION (CONS OF SKOLEM) PROPOSITION PROPOSITION) ...)

(CL:DEFUN BUILD-QUANTIFIED-PROPOSITION (TREE UPDATEMODE)
  (CL:LET*
   ((*TOPLEVELPROPOSITIONS* NIL))
   (CL:DECLARE (CL:SPECIAL *TOPLEVELPROPOSITIONS*))
   (CL:LET*
    ((DESCRIPTIVE? (EQ? UPDATEMODE KWD-DESCRIPTIONS-CONCEIVE))
     (VARIABLES
      (PARSE-LOGIC-VARIABLE-DECLARATIONS
       (CAST (SECOND TREE) SGT-DESCRIPTIONS-CONS)
       UPDATEMODE
       DESCRIPTIVE?))
     (WHERECLAUSE (EXTRACT-WHERE-CLAUSE TREE))
     (ALWAYSCLAUSE (EXTRACT-ALWAYS-CLAUSE TREE))
     (WHEREPROPOSITION NULL)
     (ALWAYSPROPOSITION NULL))
    (CL:WHEN
     (CL:NOT (CL:EQ WHERECLAUSE NULL))
     (HELP-UPDATE-PROPOSITION WHERECLAUSE UPDATEMODE))
    (CL:WHEN
     (CL:NOT (CL:EQ ALWAYSCLAUSE NULL))
     (CL:SETQ ALWAYSPROPOSITION (BUILD-PROPOSITION ALWAYSCLAUSE NULL)))
    (POP-LOGIC-VARIABLE-BINDINGS VARIABLES)
    (CL:WHEN
     (CL:AND
      (CL:NOT (CL:EQ *TOPLEVELPROPOSITIONS* NIL))
      (CL:EQ DESCRIPTIVE? 1))
     (CL:SETQ
      *TOPLEVELPROPOSITIONS*
      (REMOVE-DUPLICATES (REVERSE *TOPLEVELPROPOSITIONS*)))
     (CL:SETQ WHEREPROPOSITION (CONJOIN-PROPOSITIONS *TOPLEVELPROPOSITIONS*)))
    (FREE-CONS-LIST *TOPLEVELPROPOSITIONS*)
    (CL:RETURN-FROM
     BUILD-QUANTIFIED-PROPOSITION
     (CL:VALUES VARIABLES WHEREPROPOSITION ALWAYSPROPOSITION))))
  :VOID)

;;; (DEFMETHOD (FIND-DUPLICATE-DESCRIPTION LOGIC-OBJECT) ...)

(CL:DEFMETHOD FIND-DUPLICATE-DESCRIPTION ((SELF DESCRIPTION))
  (CL:RETURN-FROM FIND-DUPLICATE-DESCRIPTION NULL)
  :VOID)

;;; (DEFUN (CONTAINS-NESTED-ARGUMENT? BOOLEAN) ...)

(CL:DEFUN CONTAINS-NESTED-ARGUMENT? (ATOMICPROPOSITION)
  (CL:LET*
   ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND ATOMICPROPOSITION)))
   (CL:COND
    ((CL:OR
      (CL:EQ TEST-VALUE-001 KWD-DESCRIPTIONS-FUNCTION)
      (CL:EQ TEST-VALUE-001 KWD-DESCRIPTIONS-PREDICATE)
      (CL:EQ TEST-VALUE-001 KWD-DESCRIPTIONS-IN)
      (CL:EQ TEST-VALUE-001 KWD-DESCRIPTIONS-EQUIVALENT))
     (CL:LET*
      ((TERM NULL)
       (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS ATOMICPROPOSITION))
       (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:LOOP
       WHILE
       (CL:< INDEX-001 LENGTH-001)
       DO
       (CL:PROGN
        (CL:SETQ
         TERM
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
       (CL:LET*
        ((TERM-001 TERM))
        (CL:COND
         ((CL:EQ (TAXONOMY-ISA? TERM SGT-DESCRIPTIONS-PATTERN-VARIABLE) 1)
          (CL:LET*
           ((TERM NULL))
           (CL:SETQ TERM TERM-001)
           (CL:WHEN
            (CL:NOT
             (CL:EQ
              (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION TERM)
              NULL))
            (CL:RETURN-FROM CONTAINS-NESTED-ARGUMENT? TRUE))))
         (CL:T NULL))))))
    (CL:T NULL)))
  (CL:RETURN-FROM CONTAINS-NESTED-ARGUMENT? FALSE)
  :VOID)

;;; (DEFUN HELP-COLLECT-FLATTENED-ARGUMENTS ...)

(CL:DEFUN HELP-COLLECT-FLATTENED-ARGUMENTS (SELF FLATTENEDARGUMENTS BEENTHERE)
  (CL:LET*
   ((TERM NULL)
    (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
    (INDEX-001 0)
    (LENGTH-001 (LENGTH VECTOR-001)))
   (CL:LOOP
    WHILE
    (CL:< INDEX-001 LENGTH-001)
    DO
    (CL:PROGN
     (CL:SETQ
      TERM
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
    (CL:LET*
     ((TERM-001 TERM))
     (CL:COND
      ((CL:EQ (TAXONOMY-ISA? TERM SGT-DESCRIPTIONS-PATTERN-VARIABLE) 1)
       (CL:LET*
        ((TERM NULL))
        (CL:SETQ TERM TERM-001)
        (CL:LET*
         ((FUNCTIONARG
           (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION TERM)))
         (CL:WHEN
          (CL:AND
           (CL:NOT (CL:EQ FUNCTIONARG NULL))
           (CL:EQ (MEMBER? BEENTHERE FUNCTIONARG) 0))
          (PUSH BEENTHERE FUNCTIONARG)
          (HELP-COLLECT-FLATTENED-ARGUMENTS
           FUNCTIONARG
           FLATTENEDARGUMENTS
           BEENTHERE)
          (PUSH FLATTENEDARGUMENTS FUNCTIONARG)))))
      (CL:T NULL)))))
  :VOID)

;;; (DEFUN (YIELD-FLATTENED-ARGUMENTS (LIST OF PROPOSITION)) ...)

(CL:DEFUN YIELD-FLATTENED-ARGUMENTS (PROPOSITION)
  (CL:LET*
   ((BEENTHERE (LIST PROPOSITION)) (FLATTENEDARGUMENTS (NEW-LIST)))
   (HELP-COLLECT-FLATTENED-ARGUMENTS PROPOSITION FLATTENEDARGUMENTS BEENTHERE)
   (FREE BEENTHERE)
   (PUSH FLATTENEDARGUMENTS PROPOSITION)
   (CL:RETURN-FROM YIELD-FLATTENED-ARGUMENTS (REVERSE FLATTENEDARGUMENTS)))
  :VOID)

;;; (DEFUN (FLATTEN-NESTED-FUNCTION-ARGUMENTS PROPOSITION) ...)

(CL:DEFUN FLATTEN-NESTED-FUNCTION-ARGUMENTS (PROPOSITION)
  (CL:LET*
   ((EXISTSPROPOSITION (CREATE-PROPOSITION SYM-DESCRIPTIONS-EXISTS 1))
    (FLATTENEDPROPOSITIONS (YIELD-FLATTENED-ARGUMENTS PROPOSITION))
    (ANDPROPOSITION
     (CREATE-PROPOSITION SYM-DESCRIPTIONS-AND (LENGTH FLATTENEDPROPOSITIONS)))
    (VARIABLES NIL))
   (CL:LET*
    ((I NULL)
     (PROP NULL)
     (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST FLATTENEDPROPOSITIONS))
     (ITER-002 0))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-001 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       PROP
       (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-DESCRIPTIONS-PROPOSITION))
      (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
     (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
     (CL:SETF
      (CL:AREF
       (CLSYS-SVAL
        VECTOR
        THE-ARRAY
        (CLSYS-SVAL PROPOSITION ARGUMENTS ANDPROPOSITION))
       I)
      PROP)
     (ADD-DEPENDENT-PROPOSITION-LINK PROP ANDPROPOSITION)))
   (CL:LET*
    ((PROP NULL)
     (ITER-003 (CLSYS-SVAL LIST THE-CONS-LIST FLATTENEDPROPOSITIONS))
     (COLLECT-001 NULL))
    (CL:LOOP
     WHILE
     (CL:NOT (CL:EQ ITER-003 NIL))
     DO
     (CL:PROGN
      (CL:SETQ
       PROP
       (CAST (CLSYS-SVAL CONS VALUE ITER-003) SGT-DESCRIPTIONS-PROPOSITION))
      (CL:SETQ ITER-003 (CLSYS-SVAL CONS REST ITER-003)))
     (CL:WHEN
      (CL:AND
       (CL:EQ (CLSYS-SVAL PROPOSITION KIND PROP) KWD-DESCRIPTIONS-FUNCTION)
       (CL:EQ
        (ISA? (LAST-ARGUMENT PROP) SGT-DESCRIPTIONS-PATTERN-VARIABLE)
        1))
      (CL:IF
       (CL:EQ COLLECT-001 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-001 (CONS (LAST-ARGUMENT PROP) NIL))
        (CL:IF
         (CL:EQ VARIABLES NIL)
         (CL:SETQ VARIABLES COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST VARIABLES COLLECT-001)))
       (CL:PROGN
        (CL:SETF
         (CLSYS-SVAL CONS REST COLLECT-001)
         (CONS (LAST-ARGUMENT PROP) NIL))
        (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001)))))))
   (SET-DYNAMIC-SLOT-VALUE
    EXISTSPROPOSITION
    SYM-DESCRIPTIONS-IO-VARIABLES
    (COPY-CONS-LIST-TO-VARIABLES-VECTOR VARIABLES)
    NULL)
   (FREE-CONS-LIST VARIABLES)
   (CL:SETF
    (CL:AREF
     (CLSYS-SVAL
      VECTOR
      THE-ARRAY
      (CLSYS-SVAL PROPOSITION ARGUMENTS EXISTSPROPOSITION))
     0)
    ANDPROPOSITION)
   (ADD-DEPENDENT-PROPOSITION-LINK ANDPROPOSITION EXISTSPROPOSITION)
   (CL:RETURN-FROM FLATTEN-NESTED-FUNCTION-ARGUMENTS EXISTSPROPOSITION))
  :VOID)

;;; (DEFUN COLLAPSE-VALUE-OF-CHAINS ...)

(CL:DEFUN COLLAPSE-VALUE-OF-CHAINS (DESCRIPTION)
  (TIGHTEN-ARGUMENT-BINDINGS (CLSYS-SVAL DESCRIPTION PROPOSITION DESCRIPTION))
  (CL:LET*
   ((TIGHTESTSKOLEM NULL))
   (CL:LET*
    ((I NULL)
     (VBL NULL)
     (VECTOR-001 (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001))
     (ITER-001 0))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       VBL
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
        SGT-DESCRIPTIONS-PATTERN-VARIABLE))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
     (CL:WHEN
      (CL:NOT (CL:EQ VBL (INNERMOST-VARIABLE-OF VBL)))
      (CL:SETQ TIGHTESTSKOLEM (INNERMOST-VARIABLE-OF VBL))
      (CL:SETF
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION))
        I)
       (CAST TIGHTESTSKOLEM SGT-DESCRIPTIONS-PATTERN-VARIABLE))
      (SET-DYNAMIC-SLOT-VALUE
       TIGHTESTSKOLEM
       SYM-DESCRIPTIONS-SKOLEM-NAME
       (DYNAMIC-SLOT-VALUE VBL SYM-DESCRIPTIONS-SKOLEM-NAME NULL)
       NULL)
      (CL:LET*
       ((OBJECT-001 TIGHTESTSKOLEM)
        (VALUE-001 NIL)
        (OLD-VALUE-001
         (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE-INVERSE OBJECT-001))
        (NEW-VALUE-001
         (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-001 OBJECT-001 FALSE)))
       (CL:WHEN
        (CL:EQ (CS-VALUE? OLD-VALUE-001) 0)
        (CL:SETF
         (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE-INVERSE OBJECT-001)
         NEW-VALUE-001)))
      (FREE VBL)))))
  (CL:LET*
   ((VALUE NULL))
   (CL:LET*
    ((I NULL)
     (VBL NULL)
     (VECTOR-002 (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES DESCRIPTION))
     (INDEX-002 0)
     (LENGTH-002 (LENGTH VECTOR-002))
     (ITER-002 0))
    (CL:LOOP
     WHILE
     (CL:< INDEX-002 LENGTH-002)
     DO
     (CL:PROGN
      (CL:SETQ
       VBL
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002)
        SGT-DESCRIPTIONS-PATTERN-VARIABLE))
      (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
     (CL:PROGN (CL:SETQ I ITER-002) (CL:SETQ ITER-002 (CL:1+ ITER-002)))
     (CL:WHEN
      (CL:AND
       (CL:NOT
        (CL:EQ
         (ACCESS-IN-CONTEXT
          (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE VBL)
          VBL
          FALSE)
         NULL))
       (CL:EQ
        (ISA?
         (ACCESS-IN-CONTEXT
          (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE VBL)
          VBL
          FALSE)
         SGT-DESCRIPTIONS-SKOLEM)
        1))
      (CL:SETQ
       VALUE
       (ACCESS-IN-CONTEXT
        (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE VBL)
        VBL
        FALSE))
      (CL:SETF
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES DESCRIPTION))
        I)
       NULL)
      (CL:LET*
       ((VALUE-002 VALUE))
       (CL:COND
        ((CL:EQ (TAXONOMY-ISA? VALUE SGT-DESCRIPTIONS-LOGIC-OBJECT) 1)
         (CL:LET*
          ((VALUE NULL))
          (CL:SETQ VALUE VALUE-002)
          (CL:WHEN
           (CL:EQ
            (MEMBER?
             (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION)
             (VARIABLE-VALUE-INVERSE VALUE))
            0)
           (CL:LET*
            ((OBJECT-002 VALUE)
             (VALUE-003 NULL)
             (OLD-VALUE-005
              (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE-INVERSE OBJECT-002))
             (NEW-VALUE-002
              (UPDATE-IN-CONTEXT OLD-VALUE-005 VALUE-003 OBJECT-002 FALSE)))
            (CL:WHEN
             (CL:EQ (CS-VALUE? OLD-VALUE-005) 0)
             (CL:SETF
              (CLSYS-SVAL LOGIC-OBJECT VARIABLE-VALUE-INVERSE OBJECT-002)
              NEW-VALUE-002))))))
        (CL:T NULL)))
      (FREE VBL))))
   (CL:LET*
    ((I NULL)
     (VBL NULL)
     (VECTOR-003 (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES DESCRIPTION))
     (INDEX-003 0)
     (LENGTH-003 (LENGTH VECTOR-003))
     (ITER-003 0))
    (CL:LOOP
     WHILE
     (CL:< INDEX-003 LENGTH-003)
     DO
     (CL:PROGN
      (CL:SETQ
       VBL
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-003) INDEX-003)
        SGT-DESCRIPTIONS-PATTERN-VARIABLE))
      (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))
     (CL:PROGN (CL:SETQ I ITER-003) (CL:SETQ ITER-003 (CL:1+ ITER-003)))
     (CL:WHEN
      (CL:EQ
       (MEMBER? (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION) VBL)
       1)
      (CL:SETQ VALUE VBL)
      (CL:SETF
       (CL:AREF
        (CLSYS-SVAL
         VECTOR
         THE-ARRAY
         (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES DESCRIPTION))
        I)
       NULL))))
   (CL:WHEN
    (CL:NOT (CL:EQ VALUE NULL))
    (CL:LET*
     ((NEWVBLLIST NIL))
     (CL:LET*
      ((VBL NULL)
       (VECTOR-004 (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES DESCRIPTION))
       (INDEX-004 0)
       (LENGTH-004 (LENGTH VECTOR-004))
       (COLLECT-001 NULL))
      (CL:LOOP
       WHILE
       (CL:< INDEX-004 LENGTH-004)
       DO
       (CL:PROGN
        (CL:SETQ
         VBL
         (CAST
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-004) INDEX-004)
          SGT-DESCRIPTIONS-PATTERN-VARIABLE))
        (CL:SETQ INDEX-004 (CL:1+ INDEX-004)))
       (CL:WHEN
        (CL:NOT (CL:EQ VBL NULL))
        (CL:IF
         (CL:EQ COLLECT-001 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-001 (CONS VBL NIL))
          (CL:IF
           (CL:EQ NEWVBLLIST NIL)
           (CL:SETQ NEWVBLLIST COLLECT-001)
           (ADD-CONS-TO-END-OF-CONS-LIST NEWVBLLIST COLLECT-001)))
         (CL:PROGN
          (CL:SETF (CLSYS-SVAL CONS REST COLLECT-001) (CONS VBL NIL))
          (CL:SETQ COLLECT-001 (CLSYS-SVAL CONS REST COLLECT-001)))))))
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES DESCRIPTION)
      (COPY-CONS-LIST-TO-VARIABLES-VECTOR NEWVBLLIST))
     (FREE-CONS-LIST NEWVBLLIST))))
  :VOID)

;;; (DEFUN TIGHTEN-ARGUMENT-BINDINGS ...)

(CL:DEFUN TIGHTEN-ARGUMENT-BINDINGS (PROPOSITION)
  (CL:LET*
   ((I NULL)
    (ARG NULL)
    (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
    (INDEX-001 0)
    (LENGTH-001 (LENGTH VECTOR-001))
    (ITER-001 0))
   (CL:LOOP
    WHILE
    (CL:< INDEX-001 LENGTH-001)
    DO
    (CL:PROGN
     (CL:SETQ
      ARG
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
    (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
    (CL:LET*
     ((ARG-001 ARG))
     (CL:COND
      ((CL:EQ (TAXONOMY-ISA? ARG SGT-DESCRIPTIONS-PATTERN-VARIABLE) 1)
       (CL:LET*
        ((ARG NULL))
        (CL:SETQ ARG ARG-001)
        (CL:LET*
         ((TIGHTESTVARIABLE (INNERMOST-VARIABLE-OF ARG)))
         (CL:WHEN
          (CL:NOT (CL:EQ TIGHTESTVARIABLE ARG))
          (CL:SETF
           (CL:AREF
            (CLSYS-SVAL
             VECTOR
             THE-ARRAY
             (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
            I)
           TIGHTESTVARIABLE)
          (REMOVE-DEPENDENT-PROPOSITION-LINK ARG PROPOSITION)
          (ADD-DEPENDENT-PROPOSITION-LINK TIGHTESTVARIABLE PROPOSITION)
          (CL:WHEN
           (CL:NOT
            (CL:EQ
             (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION ARG)
             NULL))
           (CL:WHEN
            (CL:NOT
             (CL:OR
              (CL:EQ
               (CLSYS-SVAL
                PATTERN-VARIABLE
                DEFINING-PROPOSITION
                TIGHTESTVARIABLE)
               NULL)
              (CL:EQ
               (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION ARG)
               (CLSYS-SVAL
                PATTERN-VARIABLE
                DEFINING-PROPOSITION
                TIGHTESTVARIABLE))))
            (CL:ERROR
             "Safety violation: INTERNAL ERROR: Collapsed two skolems, each having a defining proposition, onto one."))
           (CL:SETF
            (CLSYS-SVAL
             PATTERN-VARIABLE
             DEFINING-PROPOSITION
             TIGHTESTVARIABLE)
            (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION ARG)))
          (CL:WHEN
           (CL:AND
            (CL:NOT
             (CL:EQ
              (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION ARG)
              NULL))
            (CL:NOT
             (CL:EQ
              (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION ARG)
              PROPOSITION)))
           (TIGHTEN-ARGUMENT-BINDINGS
            (CLSYS-SVAL PATTERN-VARIABLE DEFINING-PROPOSITION ARG)))))))
      ((CL:EQ (TAXONOMY-ISA? ARG SGT-DESCRIPTIONS-PROPOSITION) 1)
       (CL:LET*
        ((ARG NULL))
        (CL:SETQ ARG ARG-001)
        (TIGHTEN-ARGUMENT-BINDINGS ARG)))
      (CL:T NULL)))))
  :VOID)

;;; (DEFUN COLLECT-ALL-VARIABLES ...)

(CL:DEFUN COLLECT-ALL-VARIABLES (SELF COLLECTION BEENTHERE)
  (INSERT BEENTHERE SELF)
  (CL:LET*
   ((ARG NULL)
    (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
    (INDEX-001 0)
    (LENGTH-001 (LENGTH VECTOR-001)))
   (CL:LOOP
    WHILE
    (CL:< INDEX-001 LENGTH-001)
    DO
    (CL:PROGN
     (CL:SETQ
      ARG
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
    (CL:LET*
     ((ARG-001 ARG))
     (CL:COND
      ((CL:EQ (TAXONOMY-ISA? ARG SGT-DESCRIPTIONS-PATTERN-VARIABLE) 1)
       (CL:LET*
        ((ARG NULL))
        (CL:SETQ ARG ARG-001)
        (INSERT-NEW COLLECTION ARG)))
      ((CL:EQ (TAXONOMY-ISA? ARG SGT-DESCRIPTIONS-PROPOSITION) 1)
       (CL:LET*
        ((ARG NULL))
        (CL:SETQ ARG ARG-001)
        (CL:WHEN
         (CL:EQ (MEMBER? BEENTHERE ARG) 0)
         (COLLECT-ALL-VARIABLES ARG COLLECTION BEENTHERE))))
      (CL:T NULL)))))
  :VOID)

;;; (DEFUN COMPUTE-INTERNAL-VARIABLES ...)

(CL:DEFUN COMPUTE-INTERNAL-VARIABLES (SELF)
  (CL:LET*
   ((COLLECTION (NEW-LIST)) (BEENTHERE (NEW-LIST)))
   (COLLECT-ALL-VARIABLES
    (CLSYS-SVAL DESCRIPTION PROPOSITION SELF)
    COLLECTION
    BEENTHERE)
   (CL:LET*
    ((VBL NULL)
     (VECTOR-001 (CLSYS-SVAL DESCRIPTION IO-VARIABLES SELF))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       VBL
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
        SGT-DESCRIPTIONS-PATTERN-VARIABLE))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (REMOVE COLLECTION VBL)))
   (CL:SETF
    (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES SELF)
    (COPY-CONS-LIST-TO-VARIABLES-VECTOR
     (CLSYS-SVAL LIST THE-CONS-LIST COLLECTION)))
   (FREE COLLECTION)
   (FREE BEENTHERE))
  :VOID)

;;; (DEFUN EQUATE-TOP-LEVEL-EQUIVALENCES ...)

(CL:DEFUN EQUATE-TOP-LEVEL-EQUIVALENCES (PROPOSITION)
  (CL:LET*
   ((ARGUMENTS (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION)))
   (CL:LET*
    ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-DESCRIPTIONS-EQUIVALENCE)
      (EQUATE-VALUES (FIRST ARGUMENTS) (SECOND ARGUMENTS)))
     ((CL:EQ TEST-VALUE-001 KWD-DESCRIPTIONS-AND)
      (CL:LET*
       ((ARG NULL)
        (VECTOR-001 ARGUMENTS)
        (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:LOOP
        WHILE
        (CL:< INDEX-001 LENGTH-001)
        DO
        (CL:PROGN
         (CL:SETQ
          ARG
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
        (EQUATE-TOP-LEVEL-EQUIVALENCES
         (CAST ARG SGT-DESCRIPTIONS-PROPOSITION)))))
     ((CL:EQ TEST-VALUE-001 KWD-DESCRIPTIONS-EXISTS)
      (EQUATE-TOP-LEVEL-EQUIVALENCES
       (CAST (FIRST ARGUMENTS) SGT-DESCRIPTIONS-PROPOSITION)))
     ((CL:EQ TEST-VALUE-001 KWD-DESCRIPTIONS-FUNCTION)
      (EVALUATE-FUNCTION-PROPOSITION PROPOSITION))
     (CL:T NULL))))
  :VOID)

;;; (DEFUN (FINISH-BUILDING-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN FINISH-BUILDING-DESCRIPTION (DESCRIPTION CHECKFORDUPLICATE?)
  (CL:LET*
   ((PROPOSITION (CLSYS-SVAL DESCRIPTION PROPOSITION DESCRIPTION)))
   (NORMALIZE-PROPOSITION PROPOSITION)
   (CL:WHEN
    (CL:EQ (CLSYS-SVAL PROPOSITION KIND PROPOSITION) KWD-DESCRIPTIONS-EXISTS)
    (CL:SETQ
     PROPOSITION
     (CAST
      (FIRST (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
      SGT-DESCRIPTIONS-PROPOSITION))
    (CL:SETF (CLSYS-SVAL DESCRIPTION PROPOSITION DESCRIPTION) PROPOSITION))
   (EQUATE-TOP-LEVEL-EQUIVALENCES PROPOSITION))
  (COLLAPSE-VALUE-OF-CHAINS DESCRIPTION)
  (SIMPLIFY-DESCRIPTION DESCRIPTION FALSE)
  (COMPUTE-INTERNAL-VARIABLES DESCRIPTION)
  (CL:WHEN
   (CL:EQ CHECKFORDUPLICATE? 1)
   (CL:LET*
    ((DUPLICATEDESCRIPTION (FIND-DUPLICATE-DESCRIPTION DESCRIPTION)))
    (CL:WHEN
     (CL:NOT (CL:EQ DUPLICATEDESCRIPTION NULL))
     (FREE DESCRIPTION)
     (CL:RETURN-FROM
      FINISH-BUILDING-DESCRIPTION
      (CAST DUPLICATEDESCRIPTION SGT-DESCRIPTIONS-DESCRIPTION)))))
  (CL:RETURN-FROM FINISH-BUILDING-DESCRIPTION DESCRIPTION)
  :VOID)

;;; (DEFUN (EVALUATE-DESCRIPTION-TERM DESCRIPTION) ...)

(CL:DEFUN EVALUATE-DESCRIPTION-TERM (TERM CHECKFORDUPLICATE?)
  (CL:LET*
   ((DESCRIPTION
     (CREATE-DESCRIPTION NULL-INTEGER KWD-DESCRIPTIONS-DEFINITION))
    (QUERY? (EQ? *EVALUATIONMODE* KWD-DESCRIPTIONS-QUERY)))
   (CL:LET*
    ((TEST-VALUE-001 (FIRST TERM)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 SYM-DESCRIPTIONS-THE-ONLY)
      (SET-DYNAMIC-SLOT-VALUE
       DESCRIPTION
       SYM-DESCRIPTIONS-IOTA?
       (WRAP-BOOLEAN TRUE)
       NULL-BOOLEAN-WRAPPER))
     (CL:T NULL)))
   (CL:LET*
    ((*EVALUATIONMODE*
      (CL:IF
       (CL:EQ QUERY? 1)
       KWD-DESCRIPTIONS-QUERY
       KWD-DESCRIPTIONS-DESCRIPTION)))
    (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
    (CL:LET*
     ((IOVARS NULL) (PROPOSITION NULL) (UNUSED NULL))
     (CL:MULTIPLE-VALUE-SETQ
      (IOVARS PROPOSITION UNUSED)
      (BUILD-QUANTIFIED-PROPOSITION TERM KWD-DESCRIPTIONS-CONCEIVE))
     (CL:PROGN UNUSED)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION)
      (COPY-CONS-LIST-TO-VARIABLES-VECTOR IOVARS))
     (FREE-CONS-LIST IOVARS)
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION PROPOSITION DESCRIPTION)
      (CL:IF (CL:NOT (CL:EQ PROPOSITION NULL)) PROPOSITION TRUE-PROPOSITION)))
    (CL:RETURN-FROM
     EVALUATE-DESCRIPTION-TERM
     (FINISH-BUILDING-DESCRIPTION DESCRIPTION CHECKFORDUPLICATE?))))
  :VOID)

;;; (DEFUN (CREATE-TOP-LEVEL-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN CREATE-TOP-LEVEL-DESCRIPTION (TREE KIND RELATION)
  (CL:SETQ
   TREE
   (CAST (STANDARDIZE-LOGICAL-PARSE-TREE TREE) SGT-DESCRIPTIONS-CONS))
  (CL:LET*
   ((DESCRIPTION NULL))
   (CL:LET*
    ((*LOGICVARIABLETABLE* NIL) (*PROPOSITIONUNDERCONSTRUCTION* TREE))
    (CL:DECLARE
     (CL:SPECIAL *LOGICVARIABLETABLE* *PROPOSITIONUNDERCONSTRUCTION*))
    (CL:PROGN
     (CL:LET*
      ((*PENDINGEXCEPTIONHANDLER?* TRUE))
      (CL:DECLARE (CL:SPECIAL *PENDINGEXCEPTIONHANDLER?*))
      (CL:CATCH
       *EXCEPTIONHANDLERADDRESS*
       (CL:PROGN
        (CL:IF
         (CL:EQ
          (MEMBER?
           (GET-QUOTED-TREE "((SETOF LISTOF) \"/LOGIC\")" "/LOGIC")
           (FIRST TREE))
          1)
         (CL:SETQ
          DESCRIPTION
          (CREATE-TOP-LEVEL-COLLECTION
           TREE
           (CAST RELATION SGT-DESCRIPTIONS-CLASS)))
         (CL:SETQ DESCRIPTION (EVALUATE-DESCRIPTION-TERM TREE FALSE)))
        (CL:SETQ *EXCEPTION* NULL))))
     (CL:WHEN
      (CL:NOT (CL:EQ *EXCEPTION* NULL))
      (CL:COND
       ((CL:EQ
         (SUBTYPE-OF? *EXCEPTION-TYPE* SGT-DESCRIPTIONS-PROPOSITION-ERROR)
         1))
       (CL:T (RESIGNAL)))))
    (FREE-CONS-LIST *LOGICVARIABLETABLE*))
   (CL:WHEN
    (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:SETF (CLSYS-SVAL DESCRIPTION KIND DESCRIPTION) KIND))
   (FREE-PARSE-TREE TREE)
   (CL:RETURN-FROM CREATE-TOP-LEVEL-DESCRIPTION DESCRIPTION))
  :VOID)

;;; (DEFUN AUGMENT-TOP-LEVEL-DESCRIPTION ...)

(CL:DEFUN AUGMENT-TOP-LEVEL-DESCRIPTION (SELF TREE)
  (CL:LET*
   ((PROPOSITION NULL) (INTERNALSKOLEMS NULL))
   (CL:LET*
    ((*LOGICVARIABLETABLE* NIL) (*PROPOSITIONUNDERCONSTRUCTION* TREE))
    (CL:DECLARE
     (CL:SPECIAL *LOGICVARIABLETABLE* *PROPOSITIONUNDERCONSTRUCTION*))
    (CL:LET*
     ((V NULL)
      (VECTOR-001 (CLSYS-SVAL DESCRIPTION IO-VARIABLES SELF))
      (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:LOOP
      WHILE
      (CL:< INDEX-001 LENGTH-001)
      DO
      (CL:PROGN
       (CL:SETQ
        V
        (CAST
         (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
         SGT-DESCRIPTIONS-PATTERN-VARIABLE))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
      (PUSH-LOGIC-VARIABLE-BINDING V)))
    (CL:LET*
     ((*EVALUATIONMODE* KWD-DESCRIPTIONS-DESCRIPTION) (*FREESKOLEMS* NIL))
     (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE* *FREESKOLEMS*))
     (CL:SETQ
      PROPOSITION
      (BUILD-PROPOSITION TREE KWD-DESCRIPTIONS-ASSERT-TRUE))
     (CL:SETQ INTERNALSKOLEMS *FREESKOLEMS*))
    (POP-LOGIC-VARIABLE-BINDINGS *LOGICVARIABLETABLE*)
    (CL:WHEN
     (CL:AND
      (CL:NOT (CL:EQ PROPOSITION NULL))
      (CL:EQ
       (CLSYS-SVAL PROPOSITION DEPENDENT-PROPOSITIONS PROPOSITION)
       NULL))
     (CL:IF
      (CL:EQ (CLSYS-SVAL DESCRIPTION PROPOSITION SELF) NULL)
      (CL:PROGN
       (CL:SETF (CLSYS-SVAL DESCRIPTION PROPOSITION SELF) PROPOSITION))
      (CL:LET*
       ((FOUND?-001 FALSE))
       (CL:LET*
        ((ARG NULL)
         (VECTOR-002
          (CLSYS-SVAL
           PROPOSITION
           ARGUMENTS
           (CLSYS-SVAL DESCRIPTION PROPOSITION SELF)))
         (INDEX-002 0)
         (LENGTH-002 (LENGTH VECTOR-002)))
        (CL:LOOP
         WHILE
         (CL:< INDEX-002 LENGTH-002)
         DO
         (CL:PROGN
          (CL:SETQ
           ARG
           (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-002) INDEX-002))
          (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))
         (CL:WHEN
          (CL:EQ ARG PROPOSITION)
          (CL:SETQ FOUND?-001 TRUE)
          (CL:RETURN))))
       (CL:IF
        (CL:EQ FOUND?-001 1)
        (CL:PROGN (CL:RETURN-FROM AUGMENT-TOP-LEVEL-DESCRIPTION))
        (CL:PROGN
         (CL:SETF
          (CLSYS-SVAL DESCRIPTION PROPOSITION SELF)
          (CONJOIN-TWO-PROPOSITIONS
           PROPOSITION
           (CLSYS-SVAL DESCRIPTION PROPOSITION SELF))))))))
    (CL:WHEN
     (CL:NOT (CL:EQ INTERNALSKOLEMS NIL))
     (CL:LET*
      ((SK NULL)
       (VECTOR-003 (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES SELF))
       (INDEX-003 0)
       (LENGTH-003 (LENGTH VECTOR-003)))
      (CL:LOOP
       WHILE
       (CL:< INDEX-003 LENGTH-003)
       DO
       (CL:PROGN
        (CL:SETQ
         SK
         (CAST
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-003) INDEX-003)
          SGT-DESCRIPTIONS-PATTERN-VARIABLE))
        (CL:SETQ INDEX-003 (CL:1+ INDEX-003)))
       (CL:SETQ INTERNALSKOLEMS (CONS SK INTERNALSKOLEMS))))
     (FREE (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES SELF))
     (CL:SETF
      (CLSYS-SVAL DESCRIPTION INTERNAL-VARIABLES SELF)
      (COPY-CONS-LIST-TO-VARIABLES-VECTOR INTERNALSKOLEMS))
     (FREE-CONS-LIST INTERNALSKOLEMS))))
  :VOID)

;;; (DEFUN (CREATE-TOP-LEVEL-COLLECTION DESCRIPTION) ...)

(CL:DEFUN CREATE-TOP-LEVEL-COLLECTION (TREE CLASS)
  (CL:LET*
   ((DESCRIPTION (DYNAMIC-SLOT-VALUE CLASS SYM-DESCRIPTIONS-DESCRIPTION NULL))
    (COLLECTION (CAST (EVALUATE-TERM TREE) SGT-DESCRIPTIONS-COLLECTION))
    (OPERATOR (CAST (FIRST TREE) SGT-DESCRIPTIONS-SYMBOL)))
   (CL:WHEN
    (CL:EQ DESCRIPTION NULL)
    (CL:SETQ DESCRIPTION (CREATE-DESCRIPTION-FOR-RELATION CLASS)))
   (CL:SETF
    (CLSYS-SVAL DESCRIPTION KIND DESCRIPTION)
    KWD-DESCRIPTIONS-ENUMERATION)
   (CL:IF
    (CL:EQ (NON-EMPTY? (EXTENSION DESCRIPTION)) 1)
    (CL:LET*
     ((TOBEDELETED NIL) (TYPE (CLSYS-SVAL CLASS CLASS-TYPE CLASS)))
     (CL:LET*
      ((OLDM NULL)
       (ITER-001 (CLSYS-SVAL LIST THE-CONS-LIST (EXTENSION DESCRIPTION))))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-001 NIL))
       DO
       (CL:PROGN
        (CL:SETQ OLDM (CLSYS-SVAL CONS VALUE ITER-001))
        (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
       (CL:WHEN
        (CL:EQ
         (MEMBER? COLLECTION (CAST OLDM SGT-DESCRIPTIONS-LOGIC-OBJECT))
         0)
        (CL:SETQ TOBEDELETED (CONS OLDM TOBEDELETED)))))
     (CL:LET*
      ((OLDM NULL) (ITER-002 TOBEDELETED))
      (CL:LOOP
       WHILE
       (CL:NOT (CL:EQ ITER-002 NIL))
       DO
       (CL:PROGN
        (CL:SETQ
         OLDM
         (CAST
          (CLSYS-SVAL CONS VALUE ITER-002)
          SGT-DESCRIPTIONS-LOGIC-OBJECT))
        (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
       (CL:LET
        ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
        (CL:WRITE-STRING "Removing " %%STREAM)
        (PRINT-OBJECT OLDM %%STREAM)
        (CL:WRITE-STRING " from the extension of " %%STREAM)
        (CL:WRITE-STRING (CLASS-NAME CLASS) %%STREAM)
        (CL:WRITE-STRING "." %%STREAM)
        (CL:TERPRI %%STREAM)
        (CL:FORCE-OUTPUT %%STREAM))
       (UPDATE-ISA-PROPOSITION OLDM TYPE KWD-DESCRIPTIONS-RETRACT-TRUE)
       (CL:IF
        (CL:EQ (CLSYS-SVAL LOGIC-OBJECT ROOT-TYPE OLDM) TYPE)
        (CL:SETF
         (CLSYS-SVAL LOGIC-OBJECT ROOT-TYPE OLDM)
         SGT-DESCRIPTIONS-UNKNOWN)
        (REMOVE (ALL-ROOT-TYPES OLDM) TYPE))
       (REMOVE (EXTENSION DESCRIPTION) OLDM)))
     (FREE-CONS-LIST TOBEDELETED))
    (SET-DYNAMIC-SLOT-VALUE
     DESCRIPTION
     SYM-DESCRIPTIONS-EXTENSION
     (NEW-LIST)
     NULL))
   (CL:LET*
    ((M NULL) (ITER-003 (ALLOCATE-ITERATOR COLLECTION)))
    (CL:LOOP
     WHILE
     (CL:EQ (NEXT? ITER-003) 1)
     DO
     (CL:PROGN
      (CL:SETQ
       M
       (CAST
        (CLSYS-SVAL ITERATOR VALUE ITER-003)
        SGT-DESCRIPTIONS-LOGIC-OBJECT)))
     (ASSERT-ISA-PROPOSITION M (CLSYS-SVAL CLASS CLASS-TYPE CLASS))))
   (FREE COLLECTION)
   (REVERSE (EXTENSION DESCRIPTION))
   (ASSERT-PROPERTY DESCRIPTION SYM-DESCRIPTIONS-CLOSED)
   (CL:COND
    ((CL:EQ OPERATOR SYM-DESCRIPTIONS-LISTOF)
     (ASSERT-PROPERTY DESCRIPTION SYM-DESCRIPTIONS-ORDERED))
    ((CL:EQ OPERATOR SYM-DESCRIPTIONS-SETOF)
     (ASSERT-PROPERTY DESCRIPTION SYM-DESCRIPTIONS-DUPLICATE-FREE))
    (CL:T (CL:ERROR "`~A' is not a valid case option" OPERATOR)))
   (CL:RETURN-FROM CREATE-TOP-LEVEL-COLLECTION NULL))
  :VOID)

;;; (DEFUN (EXTRACT-VARIABLE-TYPE-PROPOSITIONS (CONS OF PROPOSITION)) ...)

(CL:DEFUN EXTRACT-VARIABLE-TYPE-PROPOSITIONS (PROPOSITION)
  (CL:LET*
   ((TYPEDECLARATIONS NIL))
   (CL:LET*
    ((TEST-VALUE-001 (CLSYS-SVAL PROPOSITION KIND PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-DESCRIPTIONS-AND)
      (CL:LET*
       ((I NULL)
        (ARG NULL)
        (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
        (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001))
        (ITER-001 0))
       (CL:LOOP
        WHILE
        (CL:< INDEX-001 LENGTH-001)
        DO
        (CL:PROGN
         (CL:SETQ
          ARG
          (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
        (CL:PROGN (CL:SETQ I ITER-001) (CL:SETQ ITER-001 (CL:1+ ITER-001)))
        (CL:WHEN
         (CL:EQ (VARIABLE-TYPE? (CAST ARG SGT-DESCRIPTIONS-PROPOSITION)) 1)
         (CL:SETQ TYPEDECLARATIONS (CONS ARG TYPEDECLARATIONS))
         (REMOVE-DEPENDENT-PROPOSITION-LINK ARG PROPOSITION)
         (CL:SETF
          (CL:AREF
           (CLSYS-SVAL
            VECTOR
            THE-ARRAY
            (CLSYS-SVAL PROPOSITION ARGUMENTS PROPOSITION))
           I)
          TRUE-PROPOSITION)))))
     ((CL:EQ TEST-VALUE-001 KWD-DESCRIPTIONS-EXISTS)
      (CL:LET
       ((%%STREAM (CLSYS-SVAL OUTPUT-STREAM NATIVE-STREAM STANDARD-OUTPUT)))
       (CL:WRITE-STRING "COMPLEMENT OF :EXISTS NOT YET IMPLEMENTED" %%STREAM)
       (CL:TERPRI %%STREAM)
       (CL:FORCE-OUTPUT %%STREAM)))
     (CL:T NULL)))
   (CL:RETURN-FROM EXTRACT-VARIABLE-TYPE-PROPOSITIONS TYPEDECLARATIONS))
  :VOID)

;;; (DEFUN (GET-COMPLEMENT-DESCRIPTION DESCRIPTION) ...)

(CL:DEFUN GET-COMPLEMENT-DESCRIPTION (SELF)
  (CL:LET*
   ((COMPLEMENT
     (DYNAMIC-SLOT-VALUE SELF SYM-DESCRIPTIONS-COMPLEMENT-DESCRIPTION NULL)))
   (CL:WHEN
    (CL:NOT (CL:EQ COMPLEMENT NULL))
    (CL:RETURN-FROM GET-COMPLEMENT-DESCRIPTION COMPLEMENT))
   (CL:SETQ COMPLEMENT (COPY-DESCRIPTION SELF NULL))
   (CL:LET*
    ((PROPOSITION (CLSYS-SVAL DESCRIPTION PROPOSITION COMPLEMENT))
     (TOPLEVELCONJUNCTS (EXTRACT-VARIABLE-TYPE-PROPOSITIONS PROPOSITION)))
    (INVERT-ATOMIC-PROPOSITION PROPOSITION)
    (CL:SETQ TOPLEVELCONJUNCTS (CONS PROPOSITION TOPLEVELCONJUNCTS))
    (CL:SETQ PROPOSITION (CONJOIN-PROPOSITIONS (REVERSE TOPLEVELCONJUNCTS)))
    (NORMALIZE-PROPOSITION PROPOSITION)
    (REASSIGN-TRUTH-VALUES PROPOSITION)
    (CL:SETF (CLSYS-SVAL DESCRIPTION PROPOSITION COMPLEMENT) PROPOSITION))
   (SET-DYNAMIC-SLOT-VALUE
    SELF
    SYM-DESCRIPTIONS-COMPLEMENT-DESCRIPTION
    COMPLEMENT
    NULL)
   (SET-DYNAMIC-SLOT-VALUE
    COMPLEMENT
    SYM-DESCRIPTIONS-COMPLEMENT-DESCRIPTION
    SELF
    NULL)
   (CL:RETURN-FROM GET-COMPLEMENT-DESCRIPTION COMPLEMENT))
  :VOID)

;;; (DEFUN (PARSE-LOGICAL-DEFINITION DESCRIPTION) ...)

(CL:DEFUN PARSE-LOGICAL-DEFINITION (DEFINITION RELATION)
  (CL:LET*
   ((PARSETREE (UNSTRINGIFY DEFINITION)))
   (CL:RETURN-FROM
    PARSE-LOGICAL-DEFINITION
    (CREATE-TOP-LEVEL-DESCRIPTION
     (CAST PARSETREE SGT-DESCRIPTIONS-CONS)
     KWD-DESCRIPTIONS-DEFINITION
     RELATION)))
  :VOID)

;;; (DEFUN INHERIT-TYPE-ONTO-DESCRIPTION ...)

(CL:DEFUN INHERIT-TYPE-ONTO-DESCRIPTION (DESCRIPTION TYPE)
  (AUGMENT-TOP-LEVEL-DESCRIPTION
   DESCRIPTION
   (LIST*
    SYM-DESCRIPTIONS-ISA
    (DYNAMIC-SLOT-VALUE
     (REPRESENTATIVE DESCRIPTION)
     SYM-DESCRIPTIONS-SKOLEM-NAME
     NULL)
    (CONS TYPE NIL)))
  :VOID)

;;; (DEFUN INHERIT-SLOT-ONTO-DESCRIPTION ...)

(CL:DEFUN INHERIT-SLOT-ONTO-DESCRIPTION (DESCRIPTION SLOT)
  (CL:LET*
   ((ARGUMENTNAMES NIL) (LASTARGNAME NULL))
   (CL:LET*
    ((ARG NULL)
     (VECTOR-001 (CLSYS-SVAL DESCRIPTION IO-VARIABLES DESCRIPTION))
     (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:LOOP
     WHILE
     (CL:< INDEX-001 LENGTH-001)
     DO
     (CL:PROGN
      (CL:SETQ
       ARG
       (CAST
        (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001)
        SGT-DESCRIPTIONS-PATTERN-VARIABLE))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
     (CL:SETQ
      ARGUMENTNAMES
      (CONS
       (DYNAMIC-SLOT-VALUE ARG SYM-DESCRIPTIONS-SKOLEM-NAME NULL)
       ARGUMENTNAMES))))
   (CL:IF
    (CL:EQ (ISA? (TYPE SLOT) SGT-DESCRIPTIONS-BOOLEAN) 1)
    (AUGMENT-TOP-LEVEL-DESCRIPTION
     DESCRIPTION
     (CONS
      (WRAP-LITERAL (NAME SLOT))
      (CONCATENATE (REVERSE ARGUMENTNAMES) NIL)))
    (CL:PROGN
     (CL:SETQ
      LASTARGNAME
      (CAST (FIRST ARGUMENTNAMES) SGT-DESCRIPTIONS-SYMBOL))
     (CL:SETQ ARGUMENTNAMES (CLSYS-SVAL CONS REST ARGUMENTNAMES))
     (AUGMENT-TOP-LEVEL-DESCRIPTION
      DESCRIPTION
      (CONS
       (CL:IF
        (CL:EQ (SINGLE-VALUED? SLOT) 1)
        SYM-DESCRIPTIONS-=
        SYM-DESCRIPTIONS-IN)
       (CONS
        LASTARGNAME
        (CONS
         (CONS
          (WRAP-LITERAL (NAME SLOT))
          (CONCATENATE (REVERSE ARGUMENTNAMES) NIL))
         NIL))))))
   (FREE-CONS-LIST ARGUMENTNAMES))
  :VOID)

;;; (DEFMETHOD CONSTRUCT-RELATION-DEFINITION ...)

(CL:DEFMETHOD CONSTRUCT-RELATION-DEFINITION ((SELF RELATION))
  (CL:LET*
   ((DEFINITION
     (PARSE-LOGICAL-DEFINITION
      (CLSYS-SVAL
       STRING-WRAPPER
       WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE
        SELF
        SYM-DESCRIPTIONS-DEFINITION-STRING
        NULL-STRING-WRAPPER))
      SELF)))
   (CL:WHEN
    (CL:EQ DEFINITION NULL)
    (CL:RETURN-FROM CONSTRUCT-RELATION-DEFINITION))
   (CL:LET*
    ((SELF-001 SELF))
    (CL:COND
     ((CL:EQ (CLASS? SELF) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:LET*
        ((SUPERTYPE NULL)
         (ITER-001
          (CLSYS-SVAL
           LIST
           THE-CONS-LIST
           (CLSYS-SVAL CLASS CLASS-DIRECT-SUPERS SELF))))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-001 NIL))
         DO
         (CL:PROGN
          (CL:SETQ
           SUPERTYPE
           (CAST (CLSYS-SVAL CONS VALUE ITER-001) SGT-DESCRIPTIONS-TYPE))
          (CL:SETQ ITER-001 (CLSYS-SVAL CONS REST ITER-001)))
         (CL:WHEN
          (CL:EQ
           (SUBTYPE-OF? (LOGICAL-TYPE (REPRESENTATIVE DEFINITION)) SUPERTYPE)
           0)
          (INHERIT-TYPE-ONTO-DESCRIPTION DEFINITION SUPERTYPE))))))
     ((CL:EQ (TAXONOMY-ISA? SELF SGT-DESCRIPTIONS-SLOT) 1)
      (CL:LET*
       ((SELF NULL))
       (CL:SETQ SELF SELF-001)
       (CL:LET*
        ((SUPERSLOT NULL)
         (ITER-002 (CLSYS-SVAL LIST THE-CONS-LIST (SLOT-DIRECT-SUPERS SELF))))
        (CL:LOOP
         WHILE
         (CL:NOT (CL:EQ ITER-002 NIL))
         DO
         (CL:PROGN
          (CL:SETQ
           SUPERSLOT
           (CAST (CLSYS-SVAL CONS VALUE ITER-002) SGT-DESCRIPTIONS-SLOT))
          (CL:SETQ ITER-002 (CLSYS-SVAL CONS REST ITER-002)))
         (INHERIT-SLOT-ONTO-DESCRIPTION DEFINITION SUPERSLOT)))))
     (CL:T (CL:ERROR "`~A' is not a valid case option" SELF))))
   (CL:SETF (CLSYS-SVAL DESCRIPTION NATIVE-RELATION DEFINITION) SELF)
   (SET-DYNAMIC-SLOT-VALUE SELF SYM-DESCRIPTIONS-DEFINITION DEFINITION NULL))
  :VOID)

;;; (DEFUN PRECLASSIFY-DESCRIPTION ...)

(CL:DEFUN PRECLASSIFY-DESCRIPTION (DESCRIPTION)
  (CL:SETQ DESCRIPTION DESCRIPTION)
  NULL
  :VOID)

;;; (DEFUN (CONJOIN-TWO-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN CONJOIN-TWO-PROPOSITIONS (PROP1 PROP2)
  (CL:COND
   ((CL:EQ PROP1 NULL) (CL:RETURN-FROM CONJOIN-TWO-PROPOSITIONS PROP2))
   ((CL:EQ PROP2 NULL) (CL:RETURN-FROM CONJOIN-TWO-PROPOSITIONS PROP1))
   (CL:T
    (CL:RETURN-FROM
     CONJOIN-TWO-PROPOSITIONS
     (CONJOIN-PROPOSITIONS (CONS-LIST PROP1 PROP2)))))
  :VOID)

;;; (DEFUN DELETE-PROPOSITION ...)

(CL:DEFUN DELETE-PROPOSITION (SELF)
  (CL:LET*
   ((ARG NULL)
    (VECTOR-001 (CLSYS-SVAL PROPOSITION ARGUMENTS SELF))
    (INDEX-001 0)
    (LENGTH-001 (LENGTH VECTOR-001)))
   (CL:LOOP
    WHILE
    (CL:< INDEX-001 LENGTH-001)
    DO
    (CL:PROGN
     (CL:SETQ
      ARG
      (CL:AREF (CLSYS-SVAL VECTOR THE-ARRAY VECTOR-001) INDEX-001))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))
    (CL:LET*
     ((ARG-001 ARG))
     (CL:COND
      ((CL:EQ (TAXONOMY-ISA? ARG SGT-DESCRIPTIONS-PROPOSITION) 1)
       (CL:LET*
        ((ARG NULL))
        (CL:SETQ ARG ARG-001)
        (REMOVE (CLSYS-SVAL PROPOSITION DEPENDENT-PROPOSITIONS ARG) SELF)))
      (CL:T NULL)))))
  (FREE SELF)
  :VOID)

(CL:DEFUN STARTUP-DESCRIPTIONS ()
  (CL:LET*
   ((*MODULE* (GET-MODULE "/LOGIC" TRUE)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 2) 1)
    (CL:SETQ
     SYM-DESCRIPTIONS-?X1
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X1" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X2
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X2" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X3
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X3" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X4
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X4" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X5
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X5" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X6
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X6" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X7
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X7" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X8
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X8" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X9
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X9" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X10
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X10" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X11
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X11" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X12
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X12" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X13
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X13" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X14
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X14" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X15
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X15" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X16
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X16" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X17
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X17" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X18
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X18" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X19
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X19" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-?X20
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X20" NULL 0))
    (CL:SETQ
     SGT-DESCRIPTIONS-MODULE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-DESCRIPTIONS-SETOFALL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOFALL" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-ISA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ SYM-DESCRIPTIONS-?X (INTERN-RIGID-SYMBOL-WRT-MODULE "?X" NULL 0))
    (CL:SETQ
     SGT-DESCRIPTIONS-SLOT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-DESCRIPTIONS-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-DESCRIPTIONS-TYPE-SPEC
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "TYPE-SPEC"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SGT-DESCRIPTIONS-TABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TABLE" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-DESCRIPTIONS-SYMBOL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SGT-DESCRIPTIONS-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-DESCRIPTIONS-KAPPA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-COMMA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMA" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-WHERE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WHERE" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SGT-DESCRIPTIONS-COLLECTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "COLLECTION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-DESCRIPTIONS-IN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-=
     (INTERN-RIGID-SYMBOL-WRT-MODULE "=" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     KWD-DESCRIPTIONS-PREFIX-STELLA
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PREFIX-STELLA" NULL 2))
    (CL:SETQ
     KWD-DESCRIPTIONS-PRIMITIVE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMITIVE" NULL 2))
    (CL:SETQ
     SYM-DESCRIPTIONS-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
    (CL:SETQ
     SGT-DESCRIPTIONS-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
    (CL:SETQ
     SGT-DESCRIPTIONS-RELATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "RELATION"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-DESCRIPTIONS-DEFINITION-STRING
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINITION-STRING" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-DEFINITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINITION" NULL 0))
    (CL:SETQ
     SGT-DESCRIPTIONS-LOGIC-OBJECT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
    (CL:SETQ
     SGT-DESCRIPTIONS-CLASS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-DESCRIPTIONS-ANY-VALUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "ANY-VALUE"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SGT-DESCRIPTIONS-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "ITERATOR"
      (GET-MODULE "/STELLA" TRUE)
      1))
    (CL:SETQ
     SYM-DESCRIPTIONS-*LOGICVARIABLETABLE*
     (INTERN-RIGID-SYMBOL-WRT-MODULE "*LOGICVARIABLETABLE*" NULL 0))
    (CL:SETQ
     SGT-DESCRIPTIONS-SKOLEM
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
    (CL:SETQ
     SYM-DESCRIPTIONS-SKOLEM-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM-NAME" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-VARIABLE-TYPE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE?" NULL 0))
    (CL:SETQ
     SGT-DESCRIPTIONS-PATTERN-VARIABLE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
    (CL:SETQ
     KWD-DESCRIPTIONS-CONCEIVE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEIVE" NULL 2))
    (CL:SETQ
     KWD-DESCRIPTIONS-FUNCTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
    (CL:SETQ
     KWD-DESCRIPTIONS-PREDICATE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
    (CL:SETQ KWD-DESCRIPTIONS-IN (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 2))
    (CL:SETQ
     KWD-DESCRIPTIONS-EQUIVALENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
    (CL:SETQ
     SYM-DESCRIPTIONS-EXISTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-AND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SGT-DESCRIPTIONS-PROPOSITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
    (CL:SETQ
     SYM-DESCRIPTIONS-IO-VARIABLES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
    (CL:SETQ
     KWD-DESCRIPTIONS-EQUIVALENCE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENCE" NULL 2))
    (CL:SETQ
     KWD-DESCRIPTIONS-AND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
    (CL:SETQ
     KWD-DESCRIPTIONS-EXISTS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
    (CL:SETQ
     KWD-DESCRIPTIONS-DEFINITION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINITION" NULL 2))
    (CL:SETQ
     KWD-DESCRIPTIONS-QUERY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY" NULL 2))
    (CL:SETQ
     SYM-DESCRIPTIONS-THE-ONLY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-ONLY" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-IOTA?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IOTA?" NULL 0))
    (CL:SETQ
     KWD-DESCRIPTIONS-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
    (CL:SETQ
     SGT-DESCRIPTIONS-PROPOSITION-ERROR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION-ERROR" NULL 1))
    (CL:SETQ
     KWD-DESCRIPTIONS-ASSERT-TRUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
    (CL:SETQ
     KWD-DESCRIPTIONS-ENUMERATION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ENUMERATION" NULL 2))
    (CL:SETQ
     KWD-DESCRIPTIONS-RETRACT-TRUE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-TRUE" NULL 2))
    (CL:SETQ
     SGT-DESCRIPTIONS-UNKNOWN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" (GET-MODULE "/STELLA" TRUE) 1))
    (CL:SETQ
     SYM-DESCRIPTIONS-EXTENSION
     (INTERN-RIGID-SYMBOL-WRT-MODULE
      "EXTENSION"
      (GET-MODULE "/STELLA" TRUE)
      0))
    (CL:SETQ
     SYM-DESCRIPTIONS-CLOSED
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-LISTOF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LISTOF" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-SETOF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOF" (GET-MODULE "/STELLA" TRUE) 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-ORDERED
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ORDERED" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-DUPLICATE-FREE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DUPLICATE-FREE" NULL 0))
    (CL:SETQ
     SYM-DESCRIPTIONS-COMPLEMENT-DESCRIPTION
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT-DESCRIPTION" NULL 0))
    (CL:SETQ
     SGT-DESCRIPTIONS-TYPE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" (GET-MODULE "/STELLA" TRUE) 1)))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 4) 1)
    (CL:SETQ FAKE-IO-VARIABLES (NEW-VECTOR 0))
    (CL:SETQ
     SYSTEM-DEFINED-ARGUMENT-NAMES
     (LIST*
      SYM-DESCRIPTIONS-?X1
      SYM-DESCRIPTIONS-?X2
      SYM-DESCRIPTIONS-?X3
      SYM-DESCRIPTIONS-?X4
      SYM-DESCRIPTIONS-?X5
      SYM-DESCRIPTIONS-?X6
      SYM-DESCRIPTIONS-?X7
      SYM-DESCRIPTIONS-?X8
      SYM-DESCRIPTIONS-?X9
      SYM-DESCRIPTIONS-?X10
      SYM-DESCRIPTIONS-?X11
      SYM-DESCRIPTIONS-?X12
      SYM-DESCRIPTIONS-?X13
      SYM-DESCRIPTIONS-?X14
      SYM-DESCRIPTIONS-?X15
      SYM-DESCRIPTIONS-?X16
      SYM-DESCRIPTIONS-?X17
      SYM-DESCRIPTIONS-?X18
      SYM-DESCRIPTIONS-?X19
      SYM-DESCRIPTIONS-?X20
      NIL)))
   (CL:WHEN (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 6) 1) (FINALIZE-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 7) 1)
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT RELATION DESCRIPTION :TYPE DESCRIPTION :DOCUMENTATION \"Maps a relation (class or slot or table) to a
primitive description.\" :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT RELATION DEFINITION :TYPE DESCRIPTION :DOCUMENTATION \"Maps a relation to a defining description.\" :ALLOCATION :DYNAMIC)")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-DESCRIPTION"
        "INTEGER"
        "(DEFUN (CREATE-DESCRIPTION DESCRIPTION) ((ARITY INTEGER) (KIND KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-DESCRIPTION-FOR-RELATION"
        "RELATION"
        "(DEFUN (CREATE-DESCRIPTION-FOR-RELATION DESCRIPTION) ((SELF RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-DESCRIPTION-FOR-RELATION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-DESCRIPTION"
        "SURROGATE"
        "(DEFMETHOD (GET-DESCRIPTION DESCRIPTION) ((SELF SURROGATE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-DESCRIPTION"
        "SYMBOL"
        "(DEFMETHOD (GET-DESCRIPTION DESCRIPTION) ((SELF SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-DESCRIPTION"
        "GENERALIZED-SYMBOL"
        "(DEFMETHOD (GET-DESCRIPTION DESCRIPTION) ((SELF GENERALIZED-SYMBOL)) :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-DESCRIPTION"
        "STRING"
        "(DEFMETHOD (GET-DESCRIPTION DESCRIPTION) ((SELF STRING)) :PUBLIC? TRUE)")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-DESCRIPTION"
        "RELATION"
        "(DEFMETHOD (GET-DESCRIPTION DESCRIPTION) ((SELF RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-DESCRIPTION"
        "CLASS"
        "(DEFMETHOD (GET-DESCRIPTION DESCRIPTION) ((SELF CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-DESCRIPTION"
        "SLOT"
        "(DEFMETHOD (GET-DESCRIPTION DESCRIPTION) ((SELF SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION GET-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRIMITIVE?"
        "CLASS"
        "(DEFMETHOD (PRIMITIVE? BOOLEAN) ((SELF CLASS)) :DOCUMENTATION \"Return TRUE if 'self' is not a defined class.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PRIMITIVE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRIMITIVE?"
        "SLOT"
        "(DEFMETHOD (PRIMITIVE? BOOLEAN) ((SELF SLOT)) :DOCUMENTATION \"Return TRUE if 'self' is not a defined slot.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PRIMITIVE?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRIMITIVE?"
        "DESCRIPTION"
        "(DEFMETHOD (PRIMITIVE? BOOLEAN) ((SELF DESCRIPTION)) :DOCUMENTATION \"Return TRUE if 'self' attached to a primitive
relation.  Definitions that enumerate their members are considered
primitive.\")")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION PRIMITIVE?)))
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT COLLECTION CLOSED :TYPE BOOLEAN :PUBLIC? TRUE :ABSTRACT? TRUE :DOCUMENTATION \"Holds for collection if all of its members
are known to the system.\")")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT COLLECTION DUPLICATE-FREE :TYPE BOOLEAN :PUBLIC? TRUE :ABSTRACT? TRUE :DOCUMENTATION \"Holds for collection if no two members
denote the same object.\")")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT COLLECTION ORDERED :TYPE BOOLEAN :PUBLIC? TRUE :ABSTRACT? TRUE :DOCUMENTATION \"Holds for collection ?c the ordering of its
members is significant.\")")
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESCRIPTION-OWNER-TYPE"
        "DESCRIPTION"
        "(DEFUN (DESCRIPTION-OWNER-TYPE TYPE) ((DESCRIPTION DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESCRIPTION-OWNER-TYPE)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOGIC-OBJECT.MEMBER-TYPE-FROM-COLLECTION"
        "LOGIC-OBJECT"
        "(DEFUN (LOGIC-OBJECT.MEMBER-TYPE-FROM-COLLECTION TYPE) ((SELF LOGIC-OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOGIC-OBJECT.MEMBER-TYPE-FROM-COLLECTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESCRIPTION.MEMBER-TYPE-FROM-COLLECTION"
        "DESCRIPTION"
        "(DEFUN (DESCRIPTION.MEMBER-TYPE-FROM-COLLECTION TYPE) ((SELF DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESCRIPTION.MEMBER-TYPE-FROM-COLLECTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "MEMBER-TYPE-FROM-COLLECTION"
        "OBJECT"
        "(DEFUN (MEMBER-TYPE-FROM-COLLECTION TYPE) ((SELF OBJECT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION MEMBER-TYPE-FROM-COLLECTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DESCRIPTION-NAME"
        "DESCRIPTION"
        "(DEFUN (DESCRIPTION-NAME SYMBOL) ((SELF DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DESCRIPTION-NAME)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PUSH-LOGIC-VARIABLE-BINDING"
        "SKOLEM"
        "(DEFUN PUSH-LOGIC-VARIABLE-BINDING ((VARIABLE SKOLEM)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PUSH-LOGIC-VARIABLE-BINDING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POP-LOGIC-VARIABLE-BINDING"
        NULL
        "(DEFUN POP-LOGIC-VARIABLE-BINDING ())")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION POP-LOGIC-VARIABLE-BINDING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "POP-LOGIC-VARIABLE-BINDINGS"
        "CONS"
        "(DEFUN POP-LOGIC-VARIABLE-BINDINGS ((VARIABLES (CONS OF SKOLEM))))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION POP-LOGIC-VARIABLE-BINDINGS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "LOOKUP-LOGIC-VARIABLE-BINDING"
        "SYMBOL"
        "(DEFUN (LOOKUP-LOGIC-VARIABLE-BINDING OBJECT) ((VARIABLENAME SYMBOL)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION LOOKUP-LOGIC-VARIABLE-BINDING)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PARSE-LOGIC-VARIABLE-DECLARATIONS"
        "CONS"
        "(DEFUN (PARSE-LOGIC-VARIABLE-DECLARATIONS (CONS OF SKOLEM)) ((TREE CONS) (UPDATEMODE KEYWORD) (VARIABLE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PARSE-LOGIC-VARIABLE-DECLARATIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COPY-CONS-LIST-TO-VARIABLES-VECTOR"
        "CONS"
        "(DEFUN (COPY-CONS-LIST-TO-VARIABLES-VECTOR VARIABLES-VECTOR) ((CONSLIST CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COPY-CONS-LIST-TO-VARIABLES-VECTOR)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "BUILD-QUANTIFIED-PROPOSITION"
        "CONS"
        "(DEFUN (BUILD-QUANTIFIED-PROPOSITION (CONS OF SKOLEM) PROPOSITION PROPOSITION) ((TREE CONS) (UPDATEMODE KEYWORD)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION BUILD-QUANTIFIED-PROPOSITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FIND-DUPLICATE-DESCRIPTION"
        "DESCRIPTION"
        "(DEFMETHOD (FIND-DUPLICATE-DESCRIPTION LOGIC-OBJECT) ((SELF DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION FIND-DUPLICATE-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONTAINS-NESTED-ARGUMENT?"
        "PROPOSITION"
        "(DEFUN (CONTAINS-NESTED-ARGUMENT? BOOLEAN) ((ATOMICPROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONTAINS-NESTED-ARGUMENT?)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "HELP-COLLECT-FLATTENED-ARGUMENTS"
        "PROPOSITION"
        "(DEFUN HELP-COLLECT-FLATTENED-ARGUMENTS ((SELF PROPOSITION) (FLATTENEDARGUMENTS (LIST OF PROPOSITION)) (BEENTHERE LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION HELP-COLLECT-FLATTENED-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "YIELD-FLATTENED-ARGUMENTS"
        "PROPOSITION"
        "(DEFUN (YIELD-FLATTENED-ARGUMENTS (LIST OF PROPOSITION)) ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION YIELD-FLATTENED-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FLATTEN-NESTED-FUNCTION-ARGUMENTS"
        "PROPOSITION"
        "(DEFUN (FLATTEN-NESTED-FUNCTION-ARGUMENTS PROPOSITION) ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FLATTEN-NESTED-FUNCTION-ARGUMENTS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLAPSE-VALUE-OF-CHAINS"
        "DESCRIPTION"
        "(DEFUN COLLAPSE-VALUE-OF-CHAINS ((DESCRIPTION DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLAPSE-VALUE-OF-CHAINS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "TIGHTEN-ARGUMENT-BINDINGS"
        "PROPOSITION"
        "(DEFUN TIGHTEN-ARGUMENT-BINDINGS ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION TIGHTEN-ARGUMENT-BINDINGS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COLLECT-ALL-VARIABLES"
        "PROPOSITION"
        "(DEFUN COLLECT-ALL-VARIABLES ((SELF PROPOSITION) (COLLECTION (LIST OF PATTERN-VARIABLE)) (BEENTHERE LIST)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COLLECT-ALL-VARIABLES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "COMPUTE-INTERNAL-VARIABLES"
        "DESCRIPTION"
        "(DEFUN COMPUTE-INTERNAL-VARIABLES ((SELF DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION COMPUTE-INTERNAL-VARIABLES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EQUATE-TOP-LEVEL-EQUIVALENCES"
        "PROPOSITION"
        "(DEFUN EQUATE-TOP-LEVEL-EQUIVALENCES ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EQUATE-TOP-LEVEL-EQUIVALENCES)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "FINISH-BUILDING-DESCRIPTION"
        "DESCRIPTION"
        "(DEFUN (FINISH-BUILDING-DESCRIPTION DESCRIPTION) ((DESCRIPTION DESCRIPTION) (CHECKFORDUPLICATE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION FINISH-BUILDING-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EVALUATE-DESCRIPTION-TERM"
        "CONS"
        "(DEFUN (EVALUATE-DESCRIPTION-TERM DESCRIPTION) ((TERM CONS) (CHECKFORDUPLICATE? BOOLEAN)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EVALUATE-DESCRIPTION-TERM)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-TOP-LEVEL-DESCRIPTION"
        "CONS"
        "(DEFUN (CREATE-TOP-LEVEL-DESCRIPTION DESCRIPTION) ((TREE CONS) (KIND KEYWORD) (RELATION RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-TOP-LEVEL-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "AUGMENT-TOP-LEVEL-DESCRIPTION"
        "DESCRIPTION"
        "(DEFUN AUGMENT-TOP-LEVEL-DESCRIPTION ((SELF DESCRIPTION) (TREE CONS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION AUGMENT-TOP-LEVEL-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CREATE-TOP-LEVEL-COLLECTION"
        "CONS"
        "(DEFUN (CREATE-TOP-LEVEL-COLLECTION DESCRIPTION) ((TREE CONS) (CLASS CLASS)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CREATE-TOP-LEVEL-COLLECTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "EXTRACT-VARIABLE-TYPE-PROPOSITIONS"
        "PROPOSITION"
        "(DEFUN (EXTRACT-VARIABLE-TYPE-PROPOSITIONS (CONS OF PROPOSITION)) ((PROPOSITION PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION EXTRACT-VARIABLE-TYPE-PROPOSITIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "GET-COMPLEMENT-DESCRIPTION"
        "DESCRIPTION"
        "(DEFUN (GET-COMPLEMENT-DESCRIPTION DESCRIPTION) ((SELF DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION GET-COMPLEMENT-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PARSE-LOGICAL-DEFINITION"
        "STRING"
        "(DEFUN (PARSE-LOGICAL-DEFINITION DESCRIPTION) ((DEFINITION STRING) (RELATION RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PARSE-LOGICAL-DEFINITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-TYPE-ONTO-DESCRIPTION"
        "DESCRIPTION"
        "(DEFUN INHERIT-TYPE-ONTO-DESCRIPTION ((DESCRIPTION DESCRIPTION) (TYPE TYPE)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-TYPE-ONTO-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "INHERIT-SLOT-ONTO-DESCRIPTION"
        "DESCRIPTION"
        "(DEFUN INHERIT-SLOT-ONTO-DESCRIPTION ((DESCRIPTION DESCRIPTION) (SLOT SLOT)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION INHERIT-SLOT-ONTO-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONSTRUCT-RELATION-DEFINITION"
        "RELATION"
        "(DEFMETHOD CONSTRUCT-RELATION-DEFINITION ((SELF RELATION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT METHOD-CODE METHOD)
      (CL:FUNCTION CONSTRUCT-RELATION-DEFINITION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "PRECLASSIFY-DESCRIPTION"
        "DESCRIPTION"
        "(DEFUN PRECLASSIFY-DESCRIPTION ((DESCRIPTION DESCRIPTION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION PRECLASSIFY-DESCRIPTION)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "CONJOIN-TWO-PROPOSITIONS"
        "PROPOSITION"
        "(DEFUN (CONJOIN-TWO-PROPOSITIONS PROPOSITION) ((PROP1 PROPOSITION) (PROP2 PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION CONJOIN-TWO-PROPOSITIONS)))
    (CL:LET*
     ((METHOD
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        "DELETE-PROPOSITION"
        "PROPOSITION"
        "(DEFUN DELETE-PROPOSITION ((SELF PROPOSITION)))")))
     (CL:SETF
      (CLSYS-SVAL METHOD-SLOT FUNCTION-CODE METHOD)
      (CL:FUNCTION DELETE-PROPOSITION)))
    (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
     "STARTUP-DESCRIPTIONS"
     NULL
     "(DEFUN STARTUP-DESCRIPTIONS ())"))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 8) 1)
    (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN
    (CL:EQ (CURRENT-STARTUP-TIME-PHASE? 9) 1)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT FAKE-IO-VARIABLES VARIABLES-VECTOR (NEW VARIABLES-VECTOR :ARRAY-SIZE 0) :DOCUMENTATION \"Installed in a description with undetermined arity.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT SYSTEM-DEFINED-ARGUMENT-NAMES (CONS OF SYMBOL) (BQUOTE (?X1 ?X2 ?X3 ?X4 ?X5 ?X6 ?X7 ?X8 ?X9 ?X10 ?X11 ?X12 ?X13 ?X14 ?X15 ?X16 ?X17 ?X18 ?X19 ?X20)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *LOGICVARIABLETABLE* (CONS OF SKOLEM) NULL :DOCUMENTATION \"Table mapping logic variable names to variables or skolems.
Used during construction of a proposition or description.\")")
    (CL:LET*
     ((GLOBAL (LOOKUP-GLOBAL-VARIABLE SYM-DESCRIPTIONS-*LOGICVARIABLETABLE*)))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-GET-VALUE-CODE GLOBAL)
      (CL:FUNCTION READ-*LOGICVARIABLETABLE*))
     (CL:SETF
      (CLSYS-SVAL GLOBAL-VARIABLE VARIABLE-SET-VALUE-CODE GLOBAL)
      (CL:FUNCTION WRITE-*LOGICVARIABLETABLE*)))))
  :VOID)
