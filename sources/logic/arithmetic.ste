;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                          ;
;  COPYRIGHT (C) UNIVERSITY OF SOUTHERN CALIFORNIA, 1998                   ; 
;  University of Southern California, Information Sciences Institute       ;
;  4676 Admiralty Way                                                      ;
;  Marina Del Rey, California 90292                                        ;
;                                                                          ;
;  This software was developed under the terms and conditions of Contract  ;
;  No. N00014-94-C-0245 between the Defense Advanced Research Projects     ;
;  Agency and the University of Southern California, Information Sciences  ; 
;  Institute.  Use and distribution of this software is further subject    ;
;  to the provisions of that contract and any other agreements developed   ;
;  between the user of the software and the University of Southern         ;
;  California, Information Sciences Institute.  It is supplied "AS IS",    ;
;  without any warranties of any kind.  It is furnished only on the basis  ;
;  that any party who receives it indemnifies and holds harmless the       ;
;  parties who furnish and originate it against any claims, demands, or    ;
;  liabilities connected with using it, furnishing it to others or         ;
;  providing it to a third party.  THIS NOTICE MUST NOT BE REMOVED FROM    ;
;  THE SOFTWARE, AND IN THE EVENT THAT THE SOFTWARE IS DIVIDED, IT SHOULD  ;
;  BE ATTACHED TO EVERY PART.                                              ;
;                                                                          ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Version: $Id: arithmetic.ste,v 1.14 2001/03/06 02:52:09 tar Exp $

;;; Evaluators perform computations (e.g., '+', '>') during constraint
;;;    propagation, and may side-effect, cause addition propagations.

(in-package "STELLA")

(in-module "PL-KERNEL")


  ;;
;;;;;; Arithmetic computation on (native) numbers
  ;;

(define-arithmetic-test-on-wrappers arithmetic-equal-test eql?)
(define-arithmetic-test-on-wrappers arithmetic-less-test <)
(define-arithmetic-test-on-wrappers arithmetic-greater-test >)


(define-arithmetic-operation-on-wrappers plus-computation  +)
(define-arithmetic-operation-on-wrappers minus-computation -)
(define-arithmetic-operation-on-wrappers times-computation *)

;; (define-arithmetic-operation-on-wrappers divide-computation /)
;; This needs a separate computation so that it will do the correct
;;   coercion of integers to floating point:
(defun (divide-computation NUMBER-WRAPPER) ((x NUMBER-WRAPPER) (y NUMBER-WRAPPER))
  :public? TRUE
  (let ((floatResult FLOAT NULL))
    (typecase x
      (INTEGER-WRAPPER
       (typecase y
         (INTEGER-WRAPPER
          (if (eql? (mod (wrapper-value x) (wrapper-value y)) 0)
              (return
                (wrap-literal
                 (safe-cast (/ (wrapper-value x) (wrapper-value y)) INTEGER)))
            (setq floatResult
              ;; Avoid CL ratios and C or Java truncating integer division:
              (/ (cast (wrapper-value x) FLOAT)
		 (cast (wrapper-value y) FLOAT)))))
         (FLOAT-WRAPPER
          (setq floatResult (/ (wrapper-value x) (wrapper-value y))))))
      (FLOAT-WRAPPER
       (typecase y
         ((INTEGER-WRAPPER FLOAT-WRAPPER)
          (setq floatResult (/ (wrapper-value x) (wrapper-value y)))))))
    (return (wrap-literal floatResult))))

(defun (sqrt-computation NUMBER-WRAPPER) ((x NUMBER-WRAPPER))
  :public? TRUE
  (let ((floatResult FLOAT NULL)
	(integerResult INTEGER NULL))
    (typecase x
      (INTEGER-WRAPPER
       (setq floatResult (sqrt (wrapper-value x)))
       (setq integerResult floatResult)
       (if (= floatResult (cast integerResult FLOAT))
	   (return (wrap-literal integerResult))
	 (return (wrap-literal floatResult))))
      (FLOAT-WRAPPER
       (setq floatResult (sqrt (wrapper-value x)))))
    (return (wrap-literal floatResult))))

(define-computed-constraint plus-constraint ((x1 NUMBER-WRAPPER)
					     (x2 NUMBER-WRAPPER)
					     (x3 NUMBER-WRAPPER))
  (setq value
    (arithmetic-equal-test (plus-computation x1 x2) x3))
  (setq value (minus-computation x3 x2))
  (setq value (minus-computation x3 x1))
  (setq value (plus-computation x1 x2)))

(define-computed-constraint minus-constraint ((x1 NUMBER-WRAPPER)
					      (x2 NUMBER-WRAPPER)
					      (x3 NUMBER-WRAPPER))
    (setq value
      (arithmetic-equal-test (minus-computation x1 x2) x3))
  (setq value (plus-computation x2 x3))
  (setq value (minus-computation x1 x3))
  (setq value (minus-computation x1 x2)))

(define-computed-constraint times-constraint ((x1 NUMBER-WRAPPER)
					      (x2 NUMBER-WRAPPER)
					      (x3 NUMBER-WRAPPER))
    (setq value
      (arithmetic-equal-test (times-computation x1 x2) x3))
  (setq value (divide-computation x3 x2))
  (setq value (divide-computation x3 x1))
  (setq value (times-computation x1 x2)))

(define-computed-constraint divide-constraint ((x1 NUMBER-WRAPPER)
					       (x2 NUMBER-WRAPPER)
					       (x3 NUMBER-WRAPPER))
    (setq value
      (arithmetic-equal-test (times-computation x2 x3) x1))
  (setq value (times-computation x2 x3))
  (setq value (divide-computation x1 x3))
  (setq value (divide-computation x1 x2)))

;; Returns only the positive square root.
;;   Negative square roots come from square-root instead!
(define-computed-constraint sqrt-constraint ((x1 NUMBER-WRAPPER)
					     (x2 NUMBER-WRAPPER))
  (setq value
    ;; To allow negative roots to be tested:
    (arithmetic-equal-test (times-computation x2 x2) x1)
    ;; For only positive roots:
    ; (arithmetic-equal-test (sqrt-computation x1) x2)
    )
  
  ;; Computes from both positive and negative.
  (setq value (times-computation x2 x2))
  ;; For positive only:
  ;(if (arithmetic-less-test x2 0)
  ;    (setq value NULL)
  ;  (setq value (times-computation x2 x2)))

  ;; 
  (if (arithmetic-less-test x1 0)
      (setq value NULL)
    (setq value (sqrt-computation x1))))

  ;;
;;;;;; Arithmetic Relations and Functions
  ;;

(deffunction PLUS ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
  :documentation "Function that adds two numbers."
  :axioms (and (computed PLUS)
               (relation-constraint PLUS PLUS-constraint)
               (relation-specialist PLUS constraint-specialist)))

(deffunction MINUS ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
  :documentation "Function that adds two numbers."
  :axioms (and (computed MINUS)
               (relation-constraint MINUS MINUS-constraint)
               (relation-specialist MINUS constraint-specialist)))

(deffunction TIMES ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
  :documentation "Function that adds two numbers."
  :axioms (and (computed TIMES)
               (relation-constraint TIMES TIMES-constraint)
               (relation-specialist TIMES constraint-specialist)))

(deffunction DIVIDE ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
  :documentation "Function that adds two numbers."
  :axioms (and (computed DIVIDE)
               (relation-constraint DIVIDE DIVIDE-constraint)
               (relation-specialist DIVIDE constraint-specialist)))

#|
(deffunction SQRT ((?x NUMBER)) :-> (?y NUMBER)
  :documentation "Function that returns the positive square root:
?y = sqrt(?x).  For positive and negative roots see relation SQUARE-ROOT"
  :axioms (and (computed SQRT)
	       (relation-constraint SQRT SQRT-constraint)
               (relation-specialist SQRT constraint-specialist)))
|#

(defrelation SQUARE-ROOT ((?x NUMBER) (?y NUMBER))
  :documentation "Relation that returns the positive and negative square roots:
?y = sqrt(?x)."  ; Additional doc:   For positive roots only see function SQRT
  :axioms (and (computed SQUARE-ROOT)
               (relation-specialist SQUARE-ROOT square-root-specialist)))

;;; Introduce 'LESS-specialist':
(assert (and (handles-reverse-polarity LESS-specialist)
             (handles-reverse-polarity GREATER-specialist)))

(defrelation INEQUALITY ((?x NUMBER) (?y NUMBER))
  :documentation "Abstract superrelation of inequality relations."
  :<<= (LESS-OR-EQUAL ?x ?y)
  :<<= (GREATER-OR-EQUAL ?x ?y)
  :axioms (abstract INEQUALITY))

(defrelation LESS-THAN ((?x NUMBER) (?y NUMBER))
  :documentation "True if ?x < ?y."
  :<<= (exists ?z (and (less-than ?x ?z) (less-or-equal ?z ?y)))
  :<<= (exists ?z (and (less-or-equal ?x ?z) (less-than ?z ?y)))
  :axioms (and (computed LESS-THAN)
               (relation-specialist LESS-THAN LESS-specialist)
               (relation-evaluator LESS-THAN INEQUALITY-evaluator)))

(defrelation LESS-OR-EQUAL ((?x NUMBER) (?y NUMBER))
  :documentation "True if ?x <= ?y."
  :<<= (exists ?z (and (less-or-equal ?x ?z) (less-or-equal ?z ?y)))
  :<<= (less-than ?x ?y)
  :axioms (and (computed LESS-OR-EQUAL)
               (relation-specialist LESS-OR-EQUAL LESS-specialist)
               (relation-evaluator LESS-OR-EQUAL INEQUALITY-evaluator)))

;;; Tricky:  The inequality specialist only handles LESS-THAN and
;;;    LESS-OR-EQUAL.  It is assumed that the '<=>' rules for
;;;    GREATER-THAN and GREATER-OR-EQUAL will enable those predicates
;;;    to be 'converted' into one of former two.

(defrelation GREATER-THAN ((?x NUMBER) (?y NUMBER))
  :documentation "True if ?x > ?y."
  :<<=>> (less-than ?y ?x)
  :axioms (and (computed GREATER-THAN)
               (relation-specialist GREATER-THAN GREATER-specialist)))

(defrelation GREATER-OR-EQUAL ((?x NUMBER) (?y NUMBER))
  :documentation "True if ?x >= ?y."
  :<<=>> (less-or-equal ?y ?x)
  :<<= (greater-than ?x ?y)
  :axioms (and (computed GREATER-OR-EQUAL)
               (relation-specialist GREATER-OR-EQUAL GREATER-specialist)))

(assert (synonym PLUS +))
(assert (synonym MINUS =))
(assert (synonym TIMES *))
(assert (synonym LESS-THAN <))
(assert (synonym LESS-OR-EQUAL =<))
(assert (synonym GREATER-THAN >))
(assert (synonym GREATER-OR-EQUAL >=))


  ;;
;;;;;; Interval evaluator
  ;;

;(defconstant MOST-NEGATIVE-INTEGER INTEGER -99999)
;(defconstant MOST-POSITIVE-INTEGER INTEGER 99999)

;;; Tricky: Each interval cache is locked to a particular context.
;;; This prevents its cached values from 'leaking' into other contexts,
;;;    where they might not be valid (due to the fact that the
;;;    caches are not truth-maintained under retraction).
(defclass INTERVAL-CACHE (THING)
  :public? TRUE
  :public-slots
  ((home-context :type CONTEXT)
   (interval-member :type LOGIC-OBJECT)
   ))

(defclass INTEGER-INTERVAL-CACHE (INTERVAL-CACHE)
  :public? TRUE
  :public-slots
  ((lower-bound :type INTEGER)
   (upper-bound :type INTEGER))
  :print-form
  (print-native-stream
   stream "|IIcache-of: " (interval-member self)
   " [" (choose (defined? (lower-bound self))
                (integer-to-string (lower-bound self))
                "?")
   "," (choose (defined? (upper-bound self))
               (integer-to-string (upper-bound self))
               "?")
   "]|"))

(defclass FLOAT-INTERVAL-CACHE (INTERVAL-CACHE)
  :public? TRUE
  :public-slots
  ((lower-bound :type FLOAT)
   (upper-bound :type FLOAT)
   (strict-lower-bound? :type BOOLEAN)
   (strict-upper-bound? :type BOOLEAN))
  :print-form
  (print-native-stream
   stream "|FIcache-of: " (interval-member self) " "
   (choose (strict-lower-bound? self) "(" "[")
   (choose (defined? (lower-bound self))
           (float-to-string (lower-bound self))
           "?")
   "," (choose (defined? (upper-bound self)) 
               (float-to-string (upper-bound self))
               "?")
   (choose (strict-upper-bound? self) ")" "]")
   "|"))

(deffunction interval-cache-of ((?x NUMBER)) :-> (?b INTERVAL-CACHE)
  :documentation "Binds an instance ?x of type NUMBER to a structure that
records its tightest lower and upper bounds."
  :axioms (hidden-relation INTERVAL-CACHE-OF))

(defun (create-interval-cache INTERVAL-CACHE)
       ((intervalMember LOGIC-OBJECT) (integer? BOOLEAN))
  :public? TRUE
  ;; Create an INTERVAL-CACHE, and point it at 'intervalMember'.
  (let ((intervalCache (choose integer? 
                          (new INTEGER-INTERVAL-CACHE)
                          (new FLOAT-INTERVAL-CACHE))))
    (setf (interval-member intervalCache) intervalMember)
    (setf (home-context intervalCache) *context*)
    (assert-binary-value @INTERVAL-CACHE-OF intervalMember intervalCache)
    (return intervalCache) ))

(defun (get-interval-cache INTERVAL-CACHE) ((self LOGIC-OBJECT))
  :public? TRUE
  ;; If 'self' has more than one dependent, return
  ;;    an INTERVAL-CACHE attached to it.
  (let ((intervalCache OBJECT
                       (access-binary-value self @INTERVAL-CACHE-OF)))
    (if (and (defined? intervalCache)
             (not (skolem? intervalCache))
             (eql? (home-context (cast intervalCache INTERVAL-CACHE)) *context*))
      (return intervalCache)
      (return (create-interval-cache
               self
               ;; NEED BETTER TEST:
               (test-isa? self @INTEGER)))) ))

(defun (coerce-interval-bound-to-integer INTEGER)
       ((self NUMBER-WRAPPER) (operator SURROGATE))
  :public? TRUE
  ;; Return an integer representing the closest integer to 'self' obeying
  ;;    the inequality 'operator'.
  (typecase self
    (INTEGER (return (INTEGER.coerce-interval-bound-to-integer self operator)))
    (FLOAT (return (FLOAT.coerce-interval-bound-to-integer self operator)))) )

(defun (INTEGER.coerce-interval-bound-to-integer INTEGER)
       ((self INTEGER-WRAPPER) (operator SURROGATE))
  ;; Return an integer representing the closest integer to 'self' obeying
  ;;    the inequality 'operator'.
  (when (null? (wrapper-value self))
    (return NULL))
  (case operator
    (@GREATER-THAN (return (1+ (wrapper-value self))))
    (@GREATER-OR-EQUAL (return (wrapper-value self)))
    (@LESS-THAN (return (1- (wrapper-value self))))
    (@LESS-OR-EQUAL (return (wrapper-value self)))) )

(defun (FLOAT.coerce-interval-bound-to-integer INTEGER)
       ((self FLOAT-WRAPPER) (operator SURROGATE))
  ;; Return an integer representing the closest integer to 'self' obeying
  ;;    the inequality 'operator'.
  (when (null? (wrapper-value self))
    (return NULL))
  (case operator
    (@GREATER-THAN (return (1+ (floor (wrapper-value self)))))
    (@GREATER-OR-EQUAL (return (ceiling (wrapper-value self))))
    (@LESS-THAN (return (1- (ceiling (wrapper-value self)))))
    (@LESS-OR-EQUAL (return (floor (wrapper-value self)))) ))

(defun signal-interval-clash ((interval INTERVAL-CACHE))
  ;; Signal a clash.
  ;; Print an indication of the type of clash.
  ;; TO DO: FIGURE OUT HOW TO SUPPRESS PRINTING.
  (mark-as-incoherent (interval-member interval))
  (signal CLASH  "Clash in interval values " interval EOL) )

(defun evaluate-adjacent-inequalities ((self LOGIC-OBJECT))
  ;; The interval bounds on 'self' have become tigher.
  ;; Evaluate all neighboring inequalities to propagate this
  ;;    new constraint.
  ;; Note: We only evaluate inequalities where the argument
  ;;    not equal to 'self' is a skolem, or that aren't 
  ;;    asserted to be true.
  (foreach dep in (all-specializing-dependent-propositions
                   self PL-KERNEL/@INEQUALITY)
           where (forall arg in (arguments dep)
                         always (or (isa? (value-of arg) @LOGIC-OBJECT)
                                    (not (true? dep))))
           do (post-for-evaluation dep)) )

(defmethod evaluate-tighter-interval ((interval INTERVAL-CACHE))
  ;; Dummy method.
  NULL )

(defmethod evaluate-tighter-interval ((interval INTEGER-INTERVAL-CACHE))
  ;; Situation: A bound on 'interval' has become stricter.
  ;; Test for equality of lower and upper bounds, binding the interval
  ;;    member to the that value if equality occurs.
  ;; Test for a clash.
  ;; Call 'evaluate-proposition' on all inequalities attached to
  ;;    the interval member.
  (trace-if :PROPAGATE "TIGHTER BOUNDS ON: " (interval-member interval) EOL
            "   LB: " (lower-bound interval) "   UB: " (upper-bound interval) EOL)
  (evaluate-adjacent-inequalities (interval-member interval))
  (when (or (null? (lower-bound interval))
            (null? (upper-bound interval)))
    (return))
  ;; both bounds are defined.  See if they interact:
  (cond
   ((eql? (lower-bound interval)
          (upper-bound interval))
    (equate-values (interval-member interval) 
                   (lower-bound interval)))
   ((> (lower-bound interval)
       (upper-bound interval))
    (signal-interval-clash interval))) )

(defmethod evaluate-tighter-interval ((interval FLOAT-INTERVAL-CACHE))
  ;; Situation: A bound on 'interval' has become stricter.
  ;; Test for equality of lower and upper bounds, binding the interval
  ;;    member to the that value if equality occurs.
  ;; Test for a clash.
  ;; Call 'evaluate-proposition' on all inequalities attached to
  ;;    the interval member.
  (when (and (defined? (lower-bound interval))
             (defined? (upper-bound interval)))
    (cond
     ((eql? (lower-bound interval) (upper-bound interval))
      (if (or (strict-lower-bound? interval)
              (strict-upper-bound? interval))
        (signal-interval-clash interval)
        (equate-values (interval-member interval) (lower-bound interval))))
     ((> (lower-bound interval) (upper-bound interval))
      (signal-interval-clash interval))))
  (evaluate-adjacent-inequalities (interval-member interval)) )
   
(defmethod propagate-inequality-to-interval-cache
           ((self INTERVAL-CACHE) (value NUMBER-WRAPPER)
            (operator SURROGATE))
  ;; Dummy
  (ignore operator value)
  NULL )

(defmethod propagate-inequality-to-interval-cache           
           ((self INTEGER-INTERVAL-CACHE) (value NUMBER-WRAPPER)            
            (operator SURROGATE)) 
  ;; Apply the constraint that the member of 'self' is related to 
  ;;    'value' by the inequality 'operator'.
  (let ((integerValue (coerce-interval-bound-to-integer value operator)))
    (when (null? integerValue)
      (return))
    (case operator    
      ((@GREATER-THAN @GREATER-OR-EQUAL)
       (when (or (null? (lower-bound self))
                 (> integerValue (lower-bound self)))
         (setf (lower-bound self) integerValue)
         (evaluate-tighter-interval self)))
      ((@LESS-THAN @LESS-OR-EQUAL)
       (when (or (null? (upper-bound self))
                 (< integerValue (upper-bound self)))
         (setf (upper-bound self) integerValue)
         (evaluate-tighter-interval self))))) )

(defmethod propagate-inequality-to-interval-cache           
           ((self FLOAT-INTERVAL-CACHE) (value NUMBER-WRAPPER)            
            (operator SURROGATE)) 
  ;; Apply the constraint that the member of 'self' is related to 
  ;;    'value' by the inequality 'operator'.  
  (let ((floatValue FLOAT value)
        (tighterInterval? FALSE))
    (when (null? floatValue)
      (return))
    (case operator    
      (@GREATER-THAN
       (when (or (null? (lower-bound self))
                 (> floatValue (lower-bound self)))
         (setf (lower-bound self) floatValue)
         (setf (strict-lower-bound? self) TRUE)
         (setq tighterInterval? TRUE)))
      (@GREATER-OR-EQUAL
       (when (or (null? (lower-bound self))
                 (> floatValue (lower-bound self)))
         (setf (lower-bound self) floatValue)
         (setf (strict-lower-bound? self) FALSE)
         (setq tighterInterval? TRUE)))
      (@LESS-THAN
       (when (or (null? (upper-bound self))
                 (< floatValue (upper-bound self)))
         (setf (upper-bound self) floatValue)
         (setf (strict-upper-bound? self) TRUE)
         (setq tighterInterval? TRUE)))
      (@LESS-OR-EQUAL
       (when (or (null? (upper-bound self))
                 (< floatValue (upper-bound self)))
         (setf (upper-bound self) floatValue)
         (setf (strict-upper-bound? self) FALSE)
         (setq tighterInterval? TRUE))))
    (when tighterInterval?
      (evaluate-tighter-interval self)) ))

(defun (inverse-inequality-operator SURROGATE) ((operator SURROGATE))
  ;; Return a surrogate representing the relational inverse of the
  ;;    inequality operator 'operator'.
  (case operator
    (@GREATER-THAN (return @LESS-THAN))
    (@LESS-THAN (return @GREATER-THAN))
    (@GREATER-OR-EQUAL (return @LESS-OR-EQUAL))
    (@LESS-OR-EQUAL (return @GREATER-OR-EQUAL))) )

(defun unify-interval-caches
    ((cache1 INTERVAL-CACHE) (cache2 INTERVAL-CACHE) (operator SURROGATE))
  ;; The interval member of 'cache1' is related to the interval member
  ;;    of 'cache2' by the operator 'operator'.
  (case operator
    ((@GREATER-THAN @GREATER-OR-EQUAL)
     (propagate-inequality-to-interval-cache
      cache1
      (access-interval-cache-bounds cache2 :LOWER-BOUND)
      operator)
     (propagate-inequality-to-interval-cache
      cache2
      (access-interval-cache-bounds cache1 :UPPER-BOUND)
      (inverse-inequality-operator operator)))
    ((@LESS-THAN @LESS-OR-EQUAL)
     (propagate-inequality-to-interval-cache
      cache1
      (access-interval-cache-bounds cache2 :UPPER-BOUND)
      operator)
     (propagate-inequality-to-interval-cache
      cache2
      (access-interval-cache-bounds cache1 :LOWER-BOUND)
      (inverse-inequality-operator operator)))) )

(defun (access-interval-bounds NUMBER-WRAPPER BOOLEAN) 
       ((x OBJECT) (lowerOrUpper KEYWORD))
  ;; Helping function for 'LESS-specialist'.
  ;; 'x' is a NUMBER-WRAPPER or an object that might be attached to
  ;;    an interval cache.
  ;; Return a lower or upper bound on 'x', or the
  ;;    appropriate NULL-WRAPPER if there is none.
  ;; A TRUE second return value indicates a strict (open) bound.
  (typecase x
    (NUMBER-WRAPPER
     (return x FALSE))
    (otherwise
     (return
       (access-interval-cache-bounds
        (access-binary-value x @INTERVAL-CACHE-OF)
        lowerOrUpper)))))

(defun (access-interval-cache-bounds NUMBER-WRAPPER BOOLEAN) 
    ((intervalCache INTERVAL-CACHE) (lowerOrUpper KEYWORD))
  ;; Return the lower or upper bound of `intervalCache', or the
  ;;    appropriate NULL-WRAPPER if there is none.
  ;; A TRUE second return value indicates a strict (open) bound.
  (when (null? intervalCache)
    (return NULL NULL))
  (typecase intervalCache
    (INTEGER-INTERVAL-CACHE
     (case lowerOrUpper
       (:LOWER-BOUND (return (lower-bound intervalCache) FALSE))
       (:UPPER-BOUND (return (upper-bound intervalCache) FALSE))))
    (FLOAT-INTERVAL-CACHE
     (case lowerOrUpper
       (:LOWER-BOUND
        (return (lower-bound intervalCache)
                (strict-lower-bound? intervalCache)))
       (:UPPER-BOUND
        (return (upper-bound intervalCache)
                (strict-upper-bound? intervalCache)))))))

(defun (compare-interval-bounds? BOOLEAN)
       ((relation SURROGATE) (x NUMBER-WRAPPER) (y NUMBER-WRAPPER))
  ;; Helping function for 'LESS-specialist'.
  ;; Convert 'x' and 'y' to floats, and compare them.
  (when (or (null-number? x)
            (null-number? y))
    (return FALSE))
  (case relation
    (@LESS-OR-EQUAL
     (return (<= (number-wrapper-to-float x) (number-wrapper-to-float y))))
    (@LESS-THAN
     (return (< (number-wrapper-to-float x) (number-wrapper-to-float y))))
    (otherwise (error "Shouldn't get here!"))) )

(defun (null-number? BOOLEAN) ((self NUMBER-WRAPPER))
  :public? TRUE
  ;; Return TRUE if 'self' is null.
  (when (null? self)
    (return TRUE))
  (typecase self
    ((INTEGER-WRAPPER FLOAT-WRAPPER) (return (null? (wrapper-value self))))) )

(defun (LESS-specialist KEYWORD) ((frame CONTROL-FRAME) (lastMove KEYWORD))
  ;; The current goal is either a LESS-THAN or LESS-OR-EQUAL comparison.
  ;; First see if a quick result can be found using interval caches,
  ;;    and otherwise return FAILURE so that the backtracker can have
  ;;    a shot at it.
  (let ((proposition (proposition frame))
        (relation (relationRef proposition))
        (xArg (first (arguments proposition)))
        (yArg (second (arguments proposition)))
        (x (argument-bound-to xArg))
        (y (argument-bound-to yArg))
        (xUB NUMBER-WRAPPER NULL)
        (strictX? BOOLEAN NULL)
        (yLB NUMBER-WRAPPER NULL)
        (strictY? BOOLEAN NULL))
    (ignore lastMove)
    (let ((success? FALSE))
      (when (null? y)
        (when (null? x)
          (return :TERMINAL-FAILURE))
        ;; x bound, y unbound:
        (mv-setq (xUB strictX?) (access-interval-bounds x :UPPER-BOUND))
        (case relation
          (@LESS-THAN 
           
           (when (and (not (null-number? xUB))
                      (isa? xUB @INTEGER-WRAPPER))
             ;; convert >= to >:
             (setq xUB (1+ (cast xUB INTEGER-WRAPPER)))))
          (otherwise NULL))
        (when (not (null-number? xUB))
          (setq success? (bind-variable-to-value? yArg xUB TRUE)))
        (return (select-proof-result success? FALSE FALSE)))
      (when (null? x)
        ;; y bound, x unbound:
        (mv-setq (yLB strictY?) (access-interval-bounds y :LOWER-BOUND))
        (case relation
          (@LESS-THAN 
           (when (and (not (null-number? yLB))
                      (isa? yLB @INTEGER-WRAPPER))
             ;; convert =< to <:
             (setq yLB (1- (cast yLB INTEGER-WRAPPER)))))
          (otherwise NULL))
        (when (not (null-number? yLB))
          (setq success? (bind-variable-to-value? xArg yLB TRUE)))
        (return (select-proof-result success? FALSE FALSE))))
    ;; both x and y are bound:
    (when *reversePolarity?*
      (let ((tempNumber OBJECT x))
        (setq x y)
        (setq y tempNumber))
      (case relation
        (@LESS-THAN (setq relation @LESS-OR-EQUAL))
        (@LESS-OR-EQUAL (setq relation @LESS-THAN))))
    (let ((success? BOOLEAN NULL))
      (mv-setq (xUB strictX?) (access-interval-bounds x :UPPER-BOUND))
      (mv-setq (yLB strictY?) (access-interval-bounds y :LOWER-BOUND))
      (case relation
        (@LESS-THAN
         (setq success?
               (or (and (or strictX? strictY?)
                        (compare-interval-bounds? @LESS-OR-EQUAL xUB yLB))
                   (compare-interval-bounds? @LESS-THAN xUB yLB))))
        (@LESS-OR-EQUAL
         (setq success? (compare-interval-bounds? relation xUB yLB))))
      (when success?
        (return :FINAL-SUCCESS)))
    (if (and (skolem? x)
             (skolem? y))
      ;; fail, assuming backtracker will take over:
      (return :FAILURE)
      ;; one or both of 'x' and 'y' is a (constant) number.
      ;; if 'compare-interval-bounds?' didn't do it, then it can't be done:
      (return :TERMINAL-FAILURE)) ))

(defun (GREATER-specialist KEYWORD)
       ((frame CONTROL-FRAME) (lastMove KEYWORD))
  ;; The current goal is either a GREATER-THAN or GREATER-OR-EQUAL comparison.
  ;; Convert to a LESS-xxx goal and reevaluate.
  (let ((proposition (proposition frame))
        (relation (relationRef proposition))
        (arguments (arguments proposition)))
    (case relation
      (@GREATER-THAN
       (setf (relationRef proposition) @LESS-THAN))
      (@GREATER-OR-EQUAL
       (setf (relationRef proposition) @LESS-OR-EQUAL)))
    ;; swap arguments:
    (let ((temp (nth arguments 0)))
      (setf (nth arguments 0) (nth arguments 1))
      (setf (nth arguments 1) temp))
    (return (LESS-specialist frame lastMove)) ))

(defun INEQUALITY-evaluator ((self PROPOSITION))
  ;; Find or create INTERVAL-CACHES for each non-literal
  ;;    argument to 'self'.
  ;; Propagate the inequality 'self' into the corresponding
  ;;    INTERVAL-CACHE(s).
; (print "INEQ-eval: " self EOL)
  (let ((value1 (value-of (nth (arguments self) 0)))
        (value2 (value-of (nth (arguments self) 1)))
        (skolem1? (isa? value1 @LOGIC-OBJECT))
        (skolem2? (isa? value2 @LOGIC-OBJECT))
        (operator (relationRef self)))
    (if skolem1?
      (if skolem2?
        (unify-interval-caches
         (get-interval-cache value1) (get-interval-cache value2) operator)
        (propagate-inequality-to-interval-cache
         (get-interval-cache value1) value2 operator))
      (if skolem2?
        (propagate-inequality-to-interval-cache
         (get-interval-cache value2) value1
         (inverse-inequality-operator operator))
        ;; both arguments are bound:
        (evaluate-PREDICATE-proposition self))) ))


#|

(cl:progn
  (clear-module "PL-USER")
  (cc pl-user)
  (defconcept person (?p))
  (deffunction age (?p) :-> (?a INTEGER))
  (assert (< (age Paul) (age Jill)))
  (assert (< (age Jill) 5))
  (ask (< (age Paul) 5))
  (propagate-constraints)
  )

(trace PL-KERNEL/evaluate-tighter-interval)
(trace PL-KERNEL/INEQUALITY-evaluator)
(trace PL-KERNEL/propagate-inequality-to-interval-cache)

|#

#|

(ask (integer 23))
(ask (not (integer "ABC")))
(ask (string "ABC"))
(ask (float 2.3))
(ask (member-of 23 INTEGER))
(ask (number 3))

|#

  ;;
;;;;;; Other Literal Computations
  ;;

(deffunction LENGTH ((?x THING)) :-> (?z INTEGER)
  :documentation "Function that returns the length of a string
or a logical list."
  :axioms (and (computed LENGTH)
               (relation-computation LENGTH LENGTH-computation)
               (relation-specialist LENGTH computation-specialist)))

(defun (LENGTH-computation INTEGER-WRAPPER) ((x OBJECT))
  (typecase x
    (STRING-WRAPPER
     ;; LENGTH is a PL-KERNEL-KB deffunction:
     (return (/stella/length (wrapper-value x))))
    (otherwise
     (print "Length computation not yet implemented for Lists")
     (return NULL-INTEGER))) )
