This is manual.info, produced by makeinfo version 4.13 from manual.texi.

This file documents the STELLA programming language.

   Copyright (C) 2006 University of Southern California, Information
Sciences Institute 4676 Admiralty Way Marina Del Rey, CA 90292

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.


File: manual.info,  Node: Miscellaneous,  Prev: XML Support,  Up: Library Functions

7.19 Miscellaneous
==================

This is a catch-all section for functions and methods that haven't been
categorized yet into any of the previous sections.  They are in random
order and many of them will never be part of the official STELLA
interface.  So beware!

 -- Function: operating-system () : KEYWORD
     Not documented.

 -- Method on DIMENSIONAL-ARRAY-MIXIN: 1d-aref (self (i INTEGER)) :
          (LIKE (ANY-VALUE SELF))
     Return the element of SELF at position `[i]'.

 -- Method on DIMENSIONAL-ARRAY-MIXIN: 1d-aref-address (self
          (i INTEGER)) : INTEGER
     Return the 1D address of the element at position `[i]'.  This is
     useful for fast element-wise iteration that doesn't need
     arithmetic.

 -- Method on DIMENSIONAL-ARRAY-MIXIN: 1d-aref-setter (self
          (value (LIKE (ANY-VALUE SELF))) (i INTEGER)) : (LIKE
          (ANY-VALUE SELF))
     Set the element of SELF at position `[i]' to VALUE and return the
     result.

 -- Method on 2-DIMENSIONAL-ARRAY-MIXIN: 2d-aref (self (i INTEGER)
          (j INTEGER)) : (LIKE (ANY-VALUE SELF))
     Return the element of SELF at position `[i, j]'.

 -- Method on 2-DIMENSIONAL-ARRAY-MIXIN: 2d-aref-address (self
          (i INTEGER) (j INTEGER)) : INTEGER
     Return the 1D address of the element at position `[i, j]'.  This
     is useful for fast element-wise iteration that doesn't need
     arithmetic.

 -- Method on 2-DIMENSIONAL-ARRAY-MIXIN: 2d-aref-setter (self
          (value (LIKE (ANY-VALUE SELF))) (i INTEGER) (j INTEGER)) :
          (LIKE (ANY-VALUE SELF))
     Set the element of SELF at position `[i, j]' to VALUE and return
     the result.

 -- Method on LONG-INTEGER: abs (x) : LONG-INTEGER
     Return the absolute value of X.

 -- Function: activate-demon ((demon DEMON)) :
     Install DEMON in the location(s) specified by its internal
     structure.

 -- Method on POLYMORPHIC-RELATION: active? (self) : BOOLEAN
     True if SELF or a superslot of SELF is marked active.

 -- Function: add-configuration-property ((property STRING)
          (value OBJECT) (configuration CONFIGURATION-TABLE)) : OBJECT
     Add VALUE to PROPERTY in CONFIGURATION and return it.  If a
     previous value exists add VALUE to the end (listify the old value
     if it is not yet a list).  Otherwise, create a new list containing
     VALUE.  Use the global system configuration table if CONFIGURATION
     is NULL.

 -- Function: add-current-date-substitution
          ((substitution-list (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER)))
          :
     Fill in SUBSTITUTION-LIST with date information for the current
     date and time.  See `add-date-substitution' for details.

 -- Function: add-date-substitution ((date CALENDAR-DATE)
          (substitution-list (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER)))
          :
     Fill in SUBSTITUTION-LIST with template variable substitions for
     the names YEAR, MONTH, MON, DAY, HOUR, MINUTE, SECOND, TIMEZONE,
     DAY-OF-WEEK, DOW with their values for DATE.  Also, pre-formatted
     DATE, TIME and ISO8601 variables are set.

     TIMEZONE is in the format "{+|-}hhmm".  MONTH is the full English
     month name and MON is the numeric month.  DAY-OF-WEEK is an English
     string and DOW is the first three letters.  Minutes and seconds are
     zero-padded.

     These substitutions can be used with
     `substitute-template-variables-in-string'

 -- Function: add-hook ((hookList HOOK-LIST) (hookFunction SYMBOL)) :
     Insert the function named HOOKFUNCTION into HOOKLIST.

 -- Command: add-load-path ((path STRING)) : (CONS OF STRING-WRAPPER)
     Append the directories listed in the |-separated PATH to the end
     of the STELLA load path.  Return the resulting load path.

 -- Command: add-property-value ((property NAME) (value OBJECT)) :
     Add VALUE to the end of PROPERTYs (a string or symbol) value list
     in the configuration table.  Coerces the current value to a list
     or initializes the list if it is as yet undefined.  Allows
     incremental addition of values to list-valued propertys.  Note
     that PROPERTY is evaluated and will need to be quoted if supplied
     as a symbol.  Symbols will also be upcased if this command is run
     in a non-case-sensitive module.

 -- N-Command: add-trace (&rest (keywords GENERALIZED-SYMBOL)) : LIST
     Enable trace messages identified by any of the listed KEYWORDS.
     After calling (`add-trace' <keyword>) code guarded by (`trace-if'
     <keyword> ...)  will be executed when it is encountered.

 -- Function: advance-past-whitespace ((source STRING) (start INTEGER))
          : INTEGER
     Returns the first index into SOURCE, starting from START, of the
     first character that is not white space.

 -- Function: all-classes ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF CLASS)
     Iterate over all classes visible from MODULE.  If LOCAL?, return
     only classes interned in MODULE.  If MODULE is null, return all
     classes interned everywhere.

 -- Function: all-contexts () : (ITERATOR OF CONTEXT)
     Return an iterator that generates all contexts.

 -- Macro: all-defined? (&body (forms CONS)) : OBJECT
     Evaluate each of the forms in FORMS, and return TRUE if none of
     them are NULL.

 -- Function: all-functions ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF FUNCTION)
     Iterate over all functions visible from MODULE.  If LOCAL?, return
     only functions bound to symbols interned in MODULE.  If MODULE is
     null, return all functions defined everywhere.

 -- Function: all-included-modules ((self MODULE)) : (ITERATOR OF
          MODULE)
     Generate a sequence of all modules included by SELF, inclusive,
     starting from the highest ancestor and working down to SELF (which
     is last).

 -- Function: all-methods ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF METHOD-SLOT)
     Iterate over all methods visible from MODULE.  If LOCAL?, return
     only methods interned in MODULE.  If MODULE is null, return all
     methods interned everywhere.

 -- Function: all-modules () : (ITERATOR OF MODULE)
     Return an iterator that generates all modules.

 -- Function: all-public-functions ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF FUNCTION)
     Iterate over all functions visible from MODULE.  If LOCAL?, return
     only functions bound to symbols interned in MODULE.  If MODULE is
     null, return all functions defined everywhere.

 -- Function: all-public-methods ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF METHOD-SLOT)
     Iterate over all public methods visible from MODULE.  If LOCAL?,
     return only methods interned in MODULE.  If MODULE is null, return
     all methods interned everywhere.

 -- Function: all-required-systems ((system-name STRING)) : (CONS OF
          STRING-WRAPPER)
     Returns a CONS of all of the systems required by SYSTEM-NAME

 -- Function: all-slots ((module MODULE) (local? BOOLEAN)) : (ITERATOR
          OF SLOT)
     Iterate over all slots visible from MODULE.  If LOCAL?, return
     only methods interned in MODULE.  If MODULE is null, return all
     methods interned everywhere.

 -- Function: all-subcontexts ((context CONTEXT) (traversal KEYWORD)) :
          (ALL-PURPOSE-ITERATOR OF CONTEXT)
     Return an iterator that generates all subcontexts of `self' (not
     including `self') in the order specified by TRAVERSAL (one of
     :preorder, :inorder, :postorder or :topdown).

 -- Function: all-surrogates ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF SURROGATE)
     Iterate over all surrogates visible from MODULE.  If LOCAL?,
     return only surrogates interned in MODULE.  If MODULE is null,
     return all surrogates interned everywhere.

 -- Function: all-symbols ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF SYMBOL)
     Iterate over all symbols visible from MODULE.  If LOCAL?, return
     only symbols interned in MODULE.  If MODULE is null, return all
     symbols interned everywhere.

 -- Function: all-variables ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF GLOBAL-VARIABLE)
     Iterate over all variables visible from MODULE.  If LOCAL?, return
     only variables bound to symbols interned in MODULE.  If MODULE is
     null, return all variables defined everywhere.

 -- Method on ABSTRACT-ITERATOR: allocate-iterator (self) : (LIKE SELF)
     Iterator objects return themselves when asked for an iterator
     (they occupy the same position as a collection within a `foreach'
     statement).

 -- Method on MEMOIZABLE-ITERATOR: allocate-iterator (self) : (ITERATOR
          OF (LIKE (ANY-VALUE SELF)))
     Alias for `clone-memoized-iterator'.

 -- Method on STORAGE-SLOT: allocation (self) : KEYWORD
     Return the most specific :allocation facet, or :instance if all
     inherited values are NULL.

 -- Function: apply ((code FUNCTION-CODE) (arguments (CONS OF OBJECT)))
          : OBJECT
     Apply CODE to ARGUMENTS, returning a value of type OBJECT.
     Currently limited to at most 10 ARGUMENTS.

 -- Function: apply-boolean-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : BOOLEAN
     Apply CODE to ARGUMENTS, returning a value of type BOOLEAN.

 -- Function: apply-float-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : FLOAT
     Apply CODE to ARGUMENTS, returning a value of type FLOAT.

 -- Function: apply-integer-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : INTEGER
     Apply CODE to ARGUMENTS, returning a value of type INTEGER.

 -- Function: apply-long-integer-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : LONG-INTEGER
     Apply CODE to ARGUMENTS, returning a value of type LONG-INTEGER.

 -- Function: apply-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : OBJECT
     Apply CODE to ARGUMENTS, returning a value of type OBJECT.

 -- Function: apply-string-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : STRING
     Apply CODE to ARGUMENTS, returning a value of type STRING.

 -- Function: autoload ((qualifiedName STRING) (systemName STRING)
          (cache SURROGATE) (error? BOOLEAN)) : FUNCTION-CODE
     Autoload function QUALIFIEDNAME from system SYSTEMNAME.  If it is
     already present in the system, simply return its code.  If CACHE
     is defined, return its value if defined, otherwise, set its value
     to the function found.  If the function failed to be defined by
     loading SYSTEMNAME and ERROR? is true, raise an error.  Otherwise,
     simply return NULL.

 -- Function: base60-to-float ((l (CONS OF NUMBER-WRAPPER))) : FLOAT
     Converts (x y z) into a float.  The return value is x + y/60 +
     z/3600.  This can be used to convert from Degree-Minute-Second to
     decimal degrees or from Hour-Minute-Second format to decimal hours.

 -- Function: blank-string? ((string STRING)) : BOOLEAN
     Return true if STRING is either NULL, empty, or only contains
     white space characters.

 -- Function: break-program ((message STRING)) :
     Interrupt the program and print MESSAGE.  Continue after
     confirmation with the user.

 -- Command: bump-log-indent () :
     Increase the indentation level for subsequent log messages.

 -- Function: byte-array-read-sequence ((buffer TOKENIZER-BYTE-ARRAY)
          (stream INPUT-STREAM) (start INTEGER) (end INTEGER)) : INTEGER
     Read from STREAM filling BUFFER between START and END (depending
     on how many characters are available).  Return the actual end
     pointer to the input read into BUFFER.  EOF is indicated by the
     return value being equal to start.

 -- Function: byte-array-write-sequence ((buffer TOKENIZER-BYTE-ARRAY)
          (stream NATIVE-OUTPUT-STREAM) (start INTEGER) (end INTEGER)) :
     Write from BUFFER to STREAM, using data in the buffer starting at
     position START stopping just before END.

 -- Method on CALENDAR-DATE: calendar-date-to-date-string (date
          (timezone FLOAT) (numeric-month? BOOLEAN)) : STRING
     Returns the date part of the string representation of DATE
     adjusted for TIMEZONE.  Format is YYYY-MMM-DD, where MMM is a
     three letter English abbreviation of the month if NUMERIC-MONTH?
     is `false' and a two digit numeric value if NUMERIC-MONTH? is
     `true'.  The value `false' is recommended.

 -- Method on CALENDAR-DATE: calendar-date-to-iso8601-string (date
          (timezone FLOAT) (include-timezone? BOOLEAN)) : STRING
     Returns an ISO-8601 string representation of DATE adjusted for
     TIMEZONE.  The Format is YYYY-MM-DDThh:mm:ss z:zz.  The timezone
     as an offset hh:mm is included if INCLUDE-TIMEZONE? is `true'.

     Recommended values for the flag is `true'.

 -- Method on CALENDAR-DATE: calendar-date-to-string (date
          (timezone FLOAT) (numeric-month? BOOLEAN)
          (include-timezone? BOOLEAN)) : STRING
     Returns a string representation of DATE adjusted for TIMEZONE.
     The Format is YYYY-MMM-DD hh:mm:ss z.z, where MMM is a three letter
     English abbreviation of the month if NUMERIC-MONTH? is `false' and
     a two digit numeric value if NUMERIC-MONTH? is `true'.  The
     timezone as a float offset z.z is included if INCLUDE-TIMEZONE? is
     `true'.

     Recommended values for the flags are `false' and `true'
     respectively.

 -- Method on CALENDAR-DATE: calendar-date-to-time-string (date
          (timezone FLOAT) (include-timezone? BOOLEAN)
          (include-millis? BOOLEAN) (pad-hours? BOOLEAN)) : STRING
     Returns the time part of the string representation of DATE
     adjusted for TIMEZONE.  The timezone is included in the string if
     INCLUDE-TIMEZONE? is `true'.  The value `true' is recommended.
     Milliseconds will be included if INCLUDE-MILLIS? is `true'.  Hours
     will be zero-padded to length 2 if PAD-HOURS? is `true'.


 -- Command: call-clear-module (&rest (name NAME)) :
     Destroy all objects belonging to module NAME or any of its
     children.  If no NAME is supplied, the current module will be
     cleared after confirming with the user.  Important modules such as
     STELLA are protected against accidental clearing.

 -- Function: cast ((value OBJECT) (type TYPE)) : OBJECT
     Perform a run-time type check, and then return VALUE.

 -- N-Command: ccc (&rest (name NAME)) : CONTEXT
     Change the current context to the one named NAME.  Return the
     value of the new current context.  If no NAME is supplied, return
     the pre-existing value of the current context.  `cc' is a no-op if
     the context reference cannot be successfully evaluated.  In
     CommonLisp, if the new context is case sensitive, then change the
     readtable case to the value of
     CL-USER::*STELLA-CASE-SENSITIVE-READ-MODE* [default = :INVERT],
     otherwise to :UPCASE.

 -- Function: cl-slot-value ((object OBJECT) (slotName STRING)
          (dontConvert? BOOLEAN)) : LISP-CODE
     Lookup slot SLOTNAME on OBJECT and return the lispified slot value
     (see `lispify').  If DONTCONVERT? is TRUE, the returned slot value
     will not be lispified.  Generate a warning if no such slot exists
     on OBJECT.  In a call directly from Lisp SLOTNAME can also be
     supplied as a Lisp symbol.

 -- Function: cl-slot-value-setter ((object OBJECT) (slotName STRING)
          (value LISP-CODE) (dontConvert? BOOLEAN)) : LISP-CODE
     Lookup slot SLOTNAME on OBJECT and set its value to the stellafied
     VALUE (see `stellafy').  If DONTCONVERT? is TRUE, VALUE will not
     be stellafied before it gets assigned.  Generate a warning if no
     such slot exists on OBJECT, or if VALUE has the wrong type.  In a
     call directly from Lisp SLOTNAME can also be supplied as a Lisp
     symbol.

 -- Function: cl-translate-file ((file FILE-NAME) (relative? BOOLEAN)) :
     Translate a Stella FILE to Common-Lisp.  If RELATIVE?, concatenate
     root directory to FILE.

 -- Function: cl-translate-system ((system-name STRING)) :
     Translate a Stella system named SYSTEM-NAME to Common Lisp.

 -- Function: cleanup-unfinalized-classes () :
     Remove all finalized classes from `*UNFINALIZED-CLASSES*', and set
     `*NEWLY-UNFINALIZED-CLASSES?*' to `false'.

 -- Method on VECTOR-SEQUENCE: clear (self) :
     Clear SELF by setting its active length to zero.

 -- Method on HEAP: clear (self) :
     Clear SELF by setting its active length to zero.

 -- Function: clear-configuration-property ((property STRING)
          (configuration CONFIGURATION-TABLE)) : OBJECT
     Remove PROPERTY in CONFIGURATION and return the previous value.
     Use the global system configuration table if CONFIGURATION is NULL.

 -- Function: clear-recycle-list ((list RECYCLE-LIST)) :
     Reset LIST to its empty state.

 -- Function: clear-recycle-lists () :
     Reset all currently active recycle lists to their empty state.

 -- Function: clear-system ((name STRING)) :
     Clears out the system definition named NAME.  If NAME is `null',
     then clear out all system definitions.  This function is useful
     when changes have been made to the system definition, and one
     wants to have it reloaded from the standard location in the file
     system.

 -- Command: clear-trace () :
     Disable all tracing previously enabled with `add-trace'.

 -- Function: clone-memoized-iterator ((self MEMOIZABLE-ITERATOR)) :
          (ITERATOR OF (LIKE (ANY-VALUE SELF)))
     Clone the memoized iterator SELF so it can be used to iterate over
     the collection represented by SELF, while allowing to iterate over
     it multiple times via multiple clones.

 -- Macro: clv ((code OBJECT)) : OBJECT
     Convenience macro to splice Lisp expressions into STELLA
     expressions without upsetting the translator during interactive
     sessions.  If CODE is a currently bound Lisp variable, this tries
     to infer the type of the resulting expression from the object CODE
     is bound to and generates an appropriate cast.  `clv' stands for
     Common-Lisp Value or Verbatim.

 -- Macro: coerce-&rest-to-cons ((restVariable SYMBOL)) : OBJECT
     Coerce the argument list variable RESTVARIABLE into a CONS list
     containing all its elements (uses argument list iteration to do
     so).  If RESTVARIABLE already is a CONS due to argument
     listification, this is a no-op.

 -- Function: coerce-option-value ((value OBJECT) (type TYPE)) : OBJECT
     Coerce VALUE to TYPE.  Return NULL if not possible.

 -- Function: coerce-to-boolean ((object OBJECT)) : BOOLEAN-WRAPPER
     Return the boolean object represented by OBJECT.  Return NULL if
     coercion is not possible.

 -- Function: coerce-to-float ((object OBJECT)) : FLOAT
     Coerce `number' to a float value or NULL if not possible.

 -- Function: coerce-to-hash-set ((self OBJECT) (equalTest? BOOLEAN)) :
          HASH-SET
     Coerce the collection SELF into a HASH-SET.  Use an equal test if
     EQUALTEST? is TRUE (EQUALTEST? will be ignored if SELF already is
     a HASH-SET).

 -- Function: coerce-to-string ((object OBJECT)) : STRING
     Coerce OBJECT into a string.  If no standard coercion is possible,
     simply stringify OBJECT.

 -- Function: coerce-to-symbol ((name NAME)) : GENERALIZED-SYMBOL
     Return the (generalized) symbol represented by NAME.  Return
     `null' if NAME is undefined or does not represent a string.

 -- Function: coerce-value-to-boolean ((value OBJECT) (error? BOOLEAN))
          : BOOLEAN-WRAPPER
     Return the boolean object represented by VALUE.  Return NULL if
     coercion is not possible or raise an error if ERROR? is TRUE.

 -- Function: coerce-value-to-float ((value OBJECT) (error? BOOLEAN)) :
          FLOAT
     Coerce VALUE to a float value if possible, return NULL otherwise
     or raise an error if ERROR? is true.

 -- Function: coerce-value-to-string ((value OBJECT) (error? BOOLEAN))
          : STRING
     Coerce VALUE into a string if possible, return NULL otherwise or
     raise an error if ERROR? is true.

 -- Function: coerce-value-to-type ((value OBJECT) (type TYPE)
          (error? BOOLEAN)) : OBJECT
     Coerce VALUE to TYPE.  Return NULL if not possible or raise an
     error if ERROR? is TRUE.

 -- Macro: collect (&body (body CONS)) : OBJECT
     Use a VRLET to collect values.  Input can have one of the
     following forms:

            (collect <var> in <expression> [where <test> <var>])
            (collect <collect-expression>
                     foreach <var> in <expression>
                     {as ...}*
                     [where <test> <var>]
                     [do ...])

     The second form really accepts an arbitrary `foreach' expression
     following the `foreach' keyword.

 -- Method on SLOT: collection-valued? (self) : BOOLEAN
     True if slot values are collections.

 -- Function: command? ((method METHOD-SLOT)) : BOOLEAN
     Return `true' if METHOD is an evaluable command.

 -- Method on STORAGE-SLOT: component? (self) : BOOLEAN
     True if fillers of this slot are components of the owner slot, and
     therefore should be deleted if the owner is deleted.

 -- Function: compose-namestring
          ((name-components (CONS OF STRING-WRAPPER))
          &rest (options OBJECT)) : STRING
     NAME-COMPONENTS is a cons to be processed into a namestring.
     `:prefix' and `:suffix' are strings that will NOT be
     case-converted.  `:case' is one of :UPCASE :TitleCase :titleCaseX
     :downcase :Capitalize         default is :TitleCase `:separator'
     is a string that should separate word elements.  It does not
     separate the prefix or suffix.  Default is "" `:translation-table'
     should be a STRING-HASH-TABLE hash table that strings into their
         desired printed representation as a string.  In general the
     argument        will be strings, but that is not strictly
     necessary.


 -- Function: compose-namestring-full
          ((strings (CONS OF STRING-WRAPPER)) (prefix STRING)
          (suffix STRING) (outputcase KEYWORD) (outputseparator STRING)
          (translationtable STRING-HASH-TABLE)
          (useacronymheuristics? BOOLEAN)) : STRING
     Non-keyword version of `compose-namestring', which will probably be
     easier to use when called from non-Lisp languages.

 -- Function: compute-module-and-bare-name ((name STRING)) : MODULE
          STRING
     Compute the module indicated by the STELLA name NAME and return
     it.  Return the bare symbol name as the second value.  NAME does
     not necessarily have to be qualified in which case the current
     module is returned.  NAME is assumed to be the printed
     representation of a STELLA symbol, surrogate or keyword.

 -- Function: config-file-option-handler ((option CMD-LINE-OPTION)
          (value OBJECT)) :
     Load the configuration file VALUE.  This will modify currently set
     system properties defined in VALUE with new values but leave all
     other currently set properties as they are.

 -- Function: configure-stella ((file FILE-NAME)) :
     Perform STELLA run-time configuration.  If supplied, load the
     configuration file FILE first which should be supplied with a
     physical pathname.

 -- Method on OBJECT: consify (self) : CONS
     If `object' is a CONS, return it.  Otherwise, return a singleton
     cons list containing it.

 -- Function: consify-command-line-arguments ((count INTEGER)
          (arguments (ARRAY () OF STRING))) : (CONS OF STRING-WRAPPER)
     Convert COUNT command line ARGUMENTS into a CONS list.

 -- Macro: continuable-error (&body (body CONS)) : OBJECT
     Signal error message, placing non-string arguments in quotes.

 -- Method on VECTOR-SEQUENCE: copy (self) : (VECTOR-SEQUENCE OF (LIKE
          (ANY-VALUE SELF)))
     Return a copy of the vector sequence SELF.

 -- Method on CUSTOM-VECTOR-SEQUENCE: copy (self) :
          (CUSTOM-VECTOR-SEQUENCE OF (LIKE (ANY-VALUE SELF)))
     Return a copy of the vector sequence SELF.

 -- Function: copy-stream-to-stream ((in INPUT-STREAM)
          (out OUTPUT-STREAM)) :
     Copy IN verbatimely to OUT.  Does the right thing for binary data.

 -- Function: cpp-translate-system ((systemName STRING)) :
     Translate the system SYSTEMNAME to C++.

 -- N-Command: cpptrans ((statement OBJECT)) :
     Translate STATEMENT to C++ and print the result.

 -- Function: create-derived-list ((self LIST)) : LIST
     Create a new list object with the same type as SELF.

 -- Function: create-object ((type TYPE)
          &rest (initial-value-pairs OBJECT)) : OBJECT
     Funcallable version of the `new' operator.  Return an instance of
     the class named by TYPE.  If INITIAL-VALUE-PAIRS is supplied, it
     has to be a key/value list similar to what's accepted by `new' and
     the named slots will be initialized with the supplied values.
     Similar to `new', all required arguments for TYPE must be
     included.  Since all the slot initialization, etc. is handled
     dynamically at run time, `create-object' is much slower than
     `new'; therefore, it should only be used if TYPE cannot be known
     at translation time.

 -- Function: deactivate-demon ((demon DEMON)) :
     Detach DEMON from the location(s) specified by its internal
     structure.

 -- Method on DECODED-DATE-TIME: decoded-date-time-to-iso8601-string
          (date) : STRING
     Returns an ISO-8601 string representation of DATE The Format is
     YYYY-MM-DDThh:mm:ss+zz:zz, with the string stopping at when a null
     value is first encountered.  The time zone will only be included
     (if present) if a time value is given.

 -- Function: decompose-namestring ((namestring STRING)
          &rest (options OBJECT)) : (CONS OF STRING-WRAPPER)
     Keyword options:   :break-on-cap    one of  :YES :NO :CLEVER
      default is :CLEVER   :break-on-number one of  :YES :NO :CLEVER
         default is :CLEVER   :break-on-separators string
            default is "-_ "

     DECOMPOSE-NAMESTRING returns a cons of STRING-WRAPPERS that are
     the decomposition of the input STRING.  The arguments are used as
     follows:   NAMESTRING       is the input string.    :break-on-cap
      is a keyword controlling whether changes in capitalization is used
                       to indicate word boundaries.  If :YES, then all
     capitalization                    changes delineate words.  If
     :CLEVER, then unbroken runs of                    capitalized
     letters are treated as acronyms and remain grouped.
         If :NO or NULL, there is no breaking of words based on
     capitalization.    :break-on-number is a flag controlling whether
     encountering a number indicates                    a word
     boundary.  If :YES, then each run of numbers is treated as
       a word separate from surrounding words.  If :CLEVER, then an
       attempt is made to recognize ordinal numbers (ie, 101st) and
       treat them as separate words.  If :NO or NULL, there is no
     breaking                    of words when numbers are encountered.
      :break-on-separators   A string of characters which constitute
     word delimiters in                          the input word.  This
     is used to determine how to break                    the name into
     individual words.  Defaults are space, `-' and `_'.

 -- Function: decompose-namestring-full ((namestring STRING)
          (break-on-cap KEYWORD) (break-on-number KEYWORD)
          (break-on-separators STRING)) : (CONS OF STRING-WRAPPER)
     Non-keyword version of `decompose-namestring', which will probably
     be easier to use when called from non-Lisp languages.

 -- Function: default-cmd-line-option-handler ((option CMD-LINE-OPTION)
          (value OBJECT)) :
     Default handler that tries to set a system property based on
     OPTION and VALUE.

 -- Method on STORAGE-SLOT: default-form (self) : OBJECT
     Returns the current value of default expression when the slot has
     not been assigned a value.

 -- Macro: defdemon ((name STRING-WRAPPER) (parameterstree CONS)
          &body (optionsandbody CONS)) : OBJECT
     Define a demon NAME and attach it to a class or slot.

 -- Function: define-demon ((name STRING) &rest (options OBJECT)) :
          DEMON
     Define a class or slot demon.  Options are :create, :destroy,
     :class, :slot, :guard?, :code, :method, :inherit?, and
     :documentation.

 -- Function: define-logical-host-property ((host STRING)
          (property KEYWORD) (value OBJECT)) :
     Define PROPERTY with VALUE for the logical host HOST.  As a
     side-effect, this also defines HOST as a logical host (both
     PROPERTY and VALUE can be supplied as NULL).  If :ROOT-DIRECTORY
     is specified, all pathnames with HOST are assumed to be relative to
     that directory (even if they are absolute) and will be rerooted
     upon translation.  :ROOT-DIRECTORY can be a logical or physical
     pathname.  If :LISP-TRANSLATIONS is specified, those will be used
     verbatimely as the value of `(CL:logical-pathname-translations
     host)' if we are running in Lisp, which allows us to depend on the
     native `CL:translate-logical-pathname' for more complex
     translation operations.

 -- Function: define-module ((name STRING) (options CONS)) : MODULE
     Define or redefine a module named NAME having the options OPTIONS.
     Return the new module.

 -- Function: define-stella-class ((name TYPE) (supers (LIST OF TYPE))
          (slots (LIST OF SLOT)) (options KEYWORD-KEY-VALUE-LIST)) :
          CLASS
     Return a Stella class with name NAME.  Caution:  If the class
     already exists, the Stella class object gets redefined, but the
     native C++ class is not redefined.

 -- Function: define-stella-method-slot ((inputname SYMBOL)
          (returntypes CONS) (function? BOOLEAN) (inputParameters CONS)
          (options KEYWORD-KEY-VALUE-LIST)) : METHOD-SLOT
     Define a new Stella method object (a slot), and attach it to the
     class identified by the first parameter in INPUTPARAMETERS.

 -- Method on LONG-INTEGER: defined? (x) : BOOLEAN
     Return true if X is defined (handled specially by all translators).

 -- Method on ARRAY: defined? (x) : BOOLEAN
     Return true if X is defined (handled specially by all translators).

 -- Macro: defmain ((varList CONS) &body (body CONS)) : OBJECT
     Defines a function called MAIN which will have the appropriate
     signature for the target translation language.  The signature will
     be:   C++:   public static int main (int v1, char** v2) {<body>}
     Java:  public static void main (String [] v2) {<body>}   Lisp:
     (defun main (&rest args) <body>) The argument VARLIST must have
     two symbols, which will be the names for the INTEGER argument
     count and an array of STRINGs with the argument values.  It can
     also be empty to indicate that no command line arguments will be
     handled.  The startup function for the containing system will
     automatically be called before BODY is executed unless the option
     :STARTUP-SYSTEM? was supplied as FALSE.  There can only be one
     DEFMAIN per module.

 -- N-Command: defsystem ((name SYMBOL) &rest (options OBJECT)) :
          SYSTEM-DEFINITION
     Define a system of files that collectively define a Stella
     application.     Required options are:    :directory - the
     relative path from the respective source/native/binary root
     directory                  to the directory containing the system
     files.  Can be a string or a list                  of strings (do
     not include directory separators).     :files - a list of files in
     the system, containing strings and lists              of strings;
     the latter defines exploded paths to files              in
     subdirectories.     Optional options are:    :data-files       - a
     list of files like the :files keyword, which contain
              data or other content that should not be processed, but
                          instead copied verbatim to the native
     directory    :required-systems - a list of systems (strings) that
     should be loaded                         prior to loading this
     system.     :cardinal-module - the name (a string) of the
     principal module for this                        system.
     :copyright-header - string with a header for inclusion into all
     translated                         files produced by Stella.
     :lisp-only-files  - Like the :files keyword, but these are only
     included    :cpp-only-files      in the translation for the
     specific language, namely    :java-only-files     Common Lisp, C++
     or Java

 -- Method on OBJECT: deleted? (self) : BOOLEAN
     Default `deleted?' method which always returns FALSE.  Objects
     that inherit DYNAMIC-SLOTS-MIXIN also inherit the
     dynamically-allocated slot `deleted-object?' which is
     read/writable with specializations of this method.

 -- N-Command: describe ((name OBJECT) &rest (mode OBJECT)) :
     Print a description of an object in :verbose, :terse, or :source
     modes.

 -- Method on OBJECT: describe-object (self (stream OUTPUT-STREAM)
          (mode KEYWORD)) :
     Prints a description of SELF to stream STREAM.  MODE can be
     :terse, :verbose, or :source.  The :terse mode is often equivalent
     to the standard print function.

 -- Method on CLASS: destroy-class (self) :
     Destroy the Stella class SELF.  Unfinalize its subclasses (if it
     has any).

 -- Function: destroy-class-and-subclasses ((self CLASS)) :
     Destroy the Stella class SELF and all its subclasses.

 -- Function: destructure-defmethod-tree ((method-tree CONS)
          (options-table KEY-VALUE-LIST)) : OBJECT CONS CONS
     Return three parse trees representing the name, parameters, and
     code body of the parse tree METHOD-TREE.  Fill OPTIONS-TABLE with
     a dictionary of method options.  Storage note:  Options are
     treated specially because the other return values are subtrees of
     METHOD-TREE, while OPTIONS-TABLE is a newly-created cons tree.
     Note also, the parameter and body trees are destructively removed
     from METHOD-TREE.

 -- Function: dictionary ((collectionType TYPE)
          &rest (alternatingkeysandvalues OBJECT)) :
          (ABSTRACT-DICTIONARY OF OBJECT OBJECT)
     Return a dictionary of COLLECTIONTYPE containing `values', in
     order.  Currently supported COLLECTIONTYPEs are @HASH-TABLE,
     @STELLA-HASH-TABLE, @KEY-VALUE-LIST, @KEY-VALUE-MAP and
     @PROPERTY-LIST.

 -- Method on CLASS: direct-super-classes (self) : (ITERATOR OF CLASS)
     Returns an iterator that generates all direct super classes of
     SELF.

 -- Command: disable-memoization () :
     Enable memoization and use of memoized expression results.

 -- Function: disabled-stella-feature? ((feature KEYWORD)) : BOOLEAN
     Return true if the STELLA FEATURE is currently disabled.

 -- Method on INTEGER: div (x (y INTEGER)) : INTEGER
     Return the integer quotient from dividing X by Y.

 -- Method on LONG-INTEGER: div (x (y LONG-INTEGER)) : LONG-INTEGER
     Return the integer quotient from dividing X by Y.

 -- Function: drop-hook ((hookList HOOK-LIST) (hookFunction SYMBOL)) :
     Remove the function named HOOKFUNCTION from HOOKLIST.

 -- Command: drop-load-path ((path STRING)) : (CONS OF STRING-WRAPPER)
     Remove the directories listed in the |-separated PATH from the
     PowerLoom load path.

 -- N-Command: drop-trace (&rest (keywords GENERALIZED-SYMBOL)) : LIST
     Disable trace messages identified by any of the listed KEYWORDS.
     After calling (`drop-trace' <keyword>) code guarded by (`trace-if'
     <keyword> ...)  will not be executed when it is encountered.

 -- Macro: either ((value1 OBJECT) (value2 OBJECT)) : OBJECT
     If VALUE1 is defined, return that, else return VALUE2.

 -- Method on STRING-WRAPPER: empty? (x) : BOOLEAN
     Return true if X is the wrapped empty string ""

 -- Method on VECTOR-SEQUENCE: empty? (self) : BOOLEAN
     Return `true' if SELF has length 0.

 -- Method on HEAP: empty? (self) : BOOLEAN
     Return TRUE if SELF is empty.

 -- Command: enable-memoization () :
     Enable memoization and use of memoized expression results.

 -- Function: enabled-stella-feature? ((feature KEYWORD)) : BOOLEAN
     Return true if the STELLA FEATURE is currently enabled.

 -- Function: ends-with? ((string STRING) (suffix STRING)
          (end INTEGER)) : BOOLEAN
     Return TRUE if the substring of STRING ending at END ends with
     SUFFIX.  If END is NULL it defaults to the length of STRING.

 -- Function: ensure-file-does-not-exist ((filename STRING)
          (context STRING)) :
     Ensures that FILENAME does not exist.  If it does, an exception of
     type `FILE-ALREADY-EXISTS-EXCEPTION' is thrown with CONTEXT
     supplying context for the error message.

 -- Function: ensure-file-exists ((filename STRING) (context STRING)) :
     Ensures that FILENAME exists.  If not, an exception of type
     `NO-SUCH-FILE-EXCEPTION' is thrown with CONTEXT supplying context
     for the error message.

 -- Function: eql-except-in-whitespace? ((s1 STRING) (s2 STRING)) :
          BOOLEAN
     Return `true' if the strings S1 and S2 are the same except for the
     amounts of whitespace separating words.  Leading or trailing
     whitespace is also not considered.

 -- Macro: error (&body (body CONS)) : OBJECT
     Signal error message, placing non-string arguments in quotes.

 -- Function: eval-in-module-option-handler ((option CMD-LINE-OPTION)
          (value OBJECT)) :
     Interpret an -eval-in-module option.  VALUE is expected to be of
     the form `(<module-name> <s-expression>)'.

 -- Function: eval-option-handler ((option CMD-LINE-OPTION)
          (value OBJECT)) :
     Interpret an -eval option by evaluating VALUE.

 -- Command: evaluate ((expression OBJECT)) : OBJECT
     Evaluate the expression EXPRESSION and return the result.
     Currently, only the evaluation of (possibly nested) commands and
     global variables is supported.  The second return value indicates
     the actual type of the result (which might have been wrapped), and
     the third return value indicates whether an error occurred during
     the evaluation.  Expressions are simple to program in Common Lisp,
     since they are built into the language, and relatively awkward in
     Java and C++.  Users of either of those languages are more likely
     to want to call `evaluate-string'.

 -- Function: evaluate-string ((expression STRING)) : OBJECT
     Evaluate the expression represented by EXPRESSION and return the
     result.  This is equivalent to `(evaluate (unstringify
     expression))'.

 -- Method on INTEGER: even? (x) : BOOLEAN
     Return true if X is an even number.

 -- Method on LONG-INTEGER: even? (x) : BOOLEAN
     Return true if X is an even number.

 -- Function: exception-message ((e NATIVE-EXCEPTION)) : STRING
     Accesses the error message of the exception E.

 -- Method on CLASS: extension (self) : CLASS-EXTENSION
     Return the nearest class extension that records instances of the
     class SELF.

 -- Function: external-id-head? ((attribute OBJECT)) : BOOLEAN
     Checks to see if this ATTRIBUTE is the literal marking either a
     PUBLIC or SYSTEM literal for an XML Elternal ID.  (See 4.2.2)

 -- Method on HEAP: fast-heap-root (self) : (LIKE (ANY-VALUE SELF))
     Return the root of SELF which is assumed to be non-empty.

 -- Function: fill-in-date-substitution
          ((substitution-list (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER)))
          :
     Fill in SUBSTITUTION-LIST with template variable substitions for
     the names YEAR and DATE which correspond to the current year and
     date.  These substitutions can then be used with
     `substitute-template-variables-in-string' DEPRECATED.  Use
     `add-date-subsitution' or `add-current-date-substitution' instead.

 -- Function: finalize-classes () :
     Finalize all currently unfinalized classes.

 -- Function: finalize-classes-and-slots () :
     Finalize all currently unfinalized classes and slots.

 -- Function: finalize-slots () :
     Finalize all currently unfinalized slots.

 -- Function: find-file-in-load-path ((file STRING)
          (extensions (CONS OF STRING-WRAPPER))) : STRING
     Try to find FILE in the current load path and, if found, return
     its full name.  If FILE can't be found literally, try to find it
     with any of the listed EXTENSIONS added.  If EXTENSIONS is NULL it
     defaults to `*stella-file-extensions*', therefore, to not default
     to any extensions the value has to be supplied as NIL.

 -- Function: find-matching-prefix-length ((string1 STRING)
          (start1 INTEGER) (end1 INTEGER) (string2 STRING)
          (start2 INTEGER) (end2 INTEGER)) : INTEGER
     Finds the length of the matching prefix strings of STRING1 and
     STRING2, starting at position START1 and START2 respectively.  The
     search will end when END1 or END2 is reached.  If either END1 or
     END2 is null, then they will be set to the length of their
     respective strings.

 -- Function: find-mismatch ((string1 STRING) (start1 INTEGER)
          (end1 INTEGER) (string2 STRING) (start2 INTEGER)
          (end2 INTEGER)) : INTEGER INTEGER
     Finds the first position in each of STRING1 and STRING2 where they
     mismatch, starting at position START1 and START2 respectively.
     The search will end when END1 or END2 is reached.  If either END1
     or END2 is null, then they will be set to the length of their
     respective strings.  If there is no mismatch, then `null' values
     are returned.

 -- Macro: first-defined (&body (forms CONS)) : OBJECT
     Return the result of the first form in FORMS whose value is defined
     or NULL otherwise.

 -- Function: float-to-base60 ((x FLOAT) (all-integers? BOOLEAN)) :
          (CONS OF NUMBER-WRAPPER)
     Returns a cons of X in a base-60 form.  That means the first value
     will be the integer part of X, the next value the iteger value of
     the fraction part of X times 60 and the third value the fraction
     part of X time 3600.  If ALL-INTEGERS?  is `true', then the last
     value will be rounded to an integer.  This can be used to convert
     from decimal degree values to Degree-Minute-Second or from decimal
     hours to Hour-Minute-Second format.

 -- Function: fmod ((x FLOAT) (modulus FLOAT)) : FLOAT
     True modulus for floats.  Return the result of X mod `modulo'.
     Note: In C++ and Java, `mod' has more overhead than the similar
     function `rem'.  The  answers returned by `mod' and `rem' are only
     different when the signs of X and `modulo' are different.

 -- Function: format-with-padding ((input STRING) (length INTEGER)
          (padchar CHARACTER) (align KEYWORD) (truncate? BOOLEAN)) :
          STRING
     Formats INPUT to be (at least) LENGTH long, using PADCHAR to fill
     if necessary.  ALIGN must be one of :LEFT, :RIGHT, :CENTER and
     will control how INPUT will be justified in the resulting string.
     If TRUNCATE? is true, then then an overlength string will be
     truncated, using the opposite of ALIGN to pick the truncation
     direction.

 -- Method on ACTIVE-OBJECT: free (self) :
     Remove all pointers between SELF and other objects, and then
     deallocate the storage for self.

 -- Method on OBJECT: free (self) :
     Default method.  Deallocate storage for SELF.

 -- Method on ABSTRACT-HASH-TABLE: free-hash-table-values (self) :
     Call free on each value in the hash table SELF.

 -- Function: frem ((x FLOAT) (y FLOAT)) : FLOAT
     Return the floating point remainder from dividing X by Y.  The
     sign of the result is always the same as the sign of X.  This has
     slightly different behavior than the `mod' function, and has less
     overhead in C++ and Java, which don't have direct support for a
     true modulus function.

 -- Function: generate-random-uuid () : STRING
     Generates a random UUID (Type 4), according to the guidelines of
     IETF RFC 4122 (see http://www.ietf.org/rfc/rfc4122.txt )

     Take 16 random bytes (octets), put them all behind each other, for
     the description the numbering starts with byte 1 (most
     significant, first) to byte 16    (least significant, last). Then
     put in the version and variant.  To put in the version, take the
     7th byte and perform an and operation using 0x0f,    followed by
     an or operation with 0x40.  To put in the variant, take the 9th
     byte and perform an and operation using 0x3f,    followed by an or
     operation with 0x80.  To make the string representation, take the
     hexadecimal presentation of bytes 1-4    (without 0x in front of
     it) let them follow by a -, then take bytes 5 and 6, - bytes 7 and
     8, - bytes 9 and 10, - then followed by bytes 11-16.

 -- Function: generate-uuid ((uuid-type KEYWORD)) : STRING
     Generates a UUID of the specified type.  Legal types are a subset
     of the IETF RFC 4122 (see http://www.ietf.org/rfc/rfc4122.txt )
     UUID types.  Currently supported are:     :TYPE-4  :RANDOM       A
     type-4 (random) UUID.  These are synonyms.

 -- Method on CALENDAR-DATE: get-calendar-date (date (timezone FLOAT))
          : INTEGER INTEGER INTEGER KEYWORD
     Returns multiple values of year, month, day and day of week for
     DATE in TIMEZONE.  TIMEZONE is the number of hours added to UTC to
     get local time.  It is in the range -12.0 to +14.0 where UTC is
     zone 0.0

 -- Function: get-global-value ((self SURROGATE)) : OBJECT
     Return the (possibly-wrapped) value of the global variable for the
     surrogate SELF.

 -- Command: get-load-path () : (CONS OF STRING-WRAPPER)
     Return the current STELLA load path.

 -- Function: get-local-standard-time-zone () : FLOAT
     Returns the standard time zone offset from UTC as a float, without
     considering the effects of daylight savings time.

 -- Function: get-local-time-zone-for-date ((year INTEGER)
          (month INTEGER) (day INTEGER) (hour INTEGER) (minute INTEGER)
          (second INTEGER)) : FLOAT
     Returns the time zone offset from UTC (as a float) that is
     applicable to the given date.  Assumes that the date is one that
     is valid for the underlying programming language.  If not, then
     returns 0.0

 -- Function: get-log-stream ((module STRING)) : OUTPUT-STREAM
     Return a valid log stream for MODULE.

 -- Command: get-property ((property NAME) &rest (defaultValue OBJECT))
          : OBJECT
     Lookup PROPERTY (a string or symbol) in the configuration table
     and return its value.  If it is undefined, return the optional
     DEFAULTVALUE.  Note that PROPERTY is evaluated and will need to be
     quoted if supplied as a symbol.  Symbols will also be upcased if
     this command is run in a non-case- sensitive module.

 -- Function: get-quoted-tree ((tree-name STRING) (modulename STRING))
          : CONS
     Return the quoted tree with name TREE-NAME.

 -- Function: get-slot ((self STANDARD-OBJECT) (slot-name SYMBOL)) :
          SLOT
     Return the slot named SLOT-NAME on the class representing the type
     of SELF.

 -- Method on SURROGATE: get-stella-class (class-name (error? BOOLEAN))
          : CLASS
     Return a class with name CLASS-NAME.  If none exists, break if
     ERROR?, else return `null'.

 -- Method on SYMBOL: get-stella-class (class-name (error? BOOLEAN)) :
          CLASS
     Return a class with name CLASS-NAME.  If non exists, break if
     ERROR?, else return `null'.

 -- Method on STRING: get-stella-class (class-name (error? BOOLEAN)) :
          CLASS
     Return a class with name CLASS-NAME.  If none exists, break if
     ERROR?, else return `null'.

 -- Method on CALENDAR-DATE: get-time (date (timezone FLOAT)) : INTEGER
          INTEGER INTEGER INTEGER
     Returns multiple values of hours, minutes, seconds, milliseconds
     for the calendar date DATE in TIMEZONE.  TIMEZONE is the number of
     hours added to UTC to get local time.  It is in the range -12.0 to
     +14.0 where UTC is zone 0.0

 -- Macro: get-token-float () : OBJECT
     User-level macro to access the most recently parsed token as a
     float.  This assumes correct signed float syntax and only checks
     for overflows.  The main benefit for this is that it doesn't
     generate strings and wrappers.  Float parsing and conversion is
     generally hairy and we are probably not covering all special cases
     here; but we are fast :-)

 -- Macro: get-token-integer () : OBJECT
     User-level macro to access the most recently parsed token as an
     integer.  This assumes correct signed integer syntax and only
     checks for overflows.

 -- Macro: get-token-long-integer () : OBJECT
     User-level macro to access the most recently parsed token as a
     long integer.  This assumes correct signed long-integer syntax and
     only checks for overflows.

 -- Function: get-xml-base-attribute-value ((expression CONS)) : STRING
     Return the last base url attribute in the attribute list of this
     element if it exists.  Otherwise NULL.

 -- Function: global-variable-type-spec ((global GLOBAL-VARIABLE)) :
          TYPE-SPEC
     Return the type spec for the global variable GLOBAL.

 -- Function: hash-string ((string STRING) (seedCode INTEGER)) : INTEGER
     Generate a hash-code for STRING and return it.  Two strings that
     are equal but not eq will generate the same code.  The hash-code
     is based on SEEDCODE which usually will be 0.  However, SEEDCODE
     can also be used to supply the result of a previous hash operation
     to achieve hashing on sequences of strings without actually having
     to concatenate them.

 -- Method on HEAP: heap-root (self) : (LIKE (ANY-VALUE SELF))
     Return the root of SELF (NULL if SELF is empty).

 -- Method on HEAP: heapify (self) :
     Restore the heap property of SELF according to its `predicate'.
     Normally, this is not needed, since insert operations preserve the
     heap property.  However, this can be useful after bulk insertion
     of values or if `predicate' has been changed.

 -- Function: help-advance-past-whitespace ((source STRING)
          (start INTEGER) (end INTEGER)) : INTEGER
     Helper for `advance-past-whitespace' that requires END to be
     properly set.

 -- Function: help-find-matching-prefix-length ((string1 STRING)
          (start1 INTEGER) (end1 INTEGER) (string2 STRING)
          (start2 INTEGER) (end2 INTEGER)) : INTEGER
     Helping function for `find-matching-prefix' that requires END1 and
     END2 to be properly set up.

 -- Function: help-get-stella-module ((pathName STRING)
          (error? BOOLEAN)) : MODULE
     Return the module located at PATHNAME, or `null' if no such module
     exists.  The search looks at ancestors and top-most  (cardinal)
     modules.  If ERROR? is `true', throw an exception if no  module is
     found.

 -- Function: help-option-handler ((option CMD-LINE-OPTION)
          (value OBJECT)) :
     Print documentation about all currently registered option handlers.

 -- Method on CLASS: help-print-outline (top (stream OUTPUT-STREAM)
          (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :
     Helper method for `print-outline'

 -- Method on MODULE: help-print-outline (top (stream OUTPUT-STREAM)
          (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :
     Helper method for `print-outline'

 -- Method on OBJECT: help-print-outline (top (stream OUTPUT-STREAM)
          (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :
     Helper method for `print-outline'

 -- Method on SLOT: help-print-outline (top (stream OUTPUT-STREAM)
          (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :
     Helper method for `print-outline'

 -- Method on CONTEXT: help-print-outline (top (stream OUTPUT-STREAM)
          (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :
     Helper method for `print-outline'

 -- Method on OBJECT: home-module (self) : MODULE
     Return the home module of SELF.

 -- Macro: if-output-language ((language KEYWORD) (thenForm OBJECT)
          (elseForm OBJECT)) : OBJECT
     Expand to THENFORM if the current translator output language
     equals LANGUAGE.  Otherwise, expand to ELSEFORM.  This can be used
     to conditionally translate Stella code.

 -- Macro: if-stella-feature ((feature KEYWORD) (thenForm OBJECT)
          (elseForm OBJECT)) : OBJECT
     Expand to THENFORM if FEATURE is a currently enabled STELLA
     environment feature.  Otherwise, expand to ELSEFORM.  This can be
     used to conditionally translate Stella code.

 -- Macro: ignore (&body (variables CONS)) : OBJECT
     Ignore unused VARIABLES with NoOp `setq' statements.

 -- Function: incrementally-translate ((tree OBJECT)) : OBJECT
     Translate a single Stella expression TREE and return the result.
     For C++ and Java print the translation to standard output and
     return NIL instead.

 -- Function: indent-outline ((current-depth INTEGER)
          (stream OUTPUT-STREAM)) :
     Helper function that indents outline printings for level
     CURRENT-DEPTH on STREAM using the value of the global variable
     `*OUTLINE-INDENT-STRING*'

 -- Macro: inform (&body (body CONS)) : OBJECT
     Print informative message, placing non-string arguments in quotes,
     and terminating with a newline.

 -- Method on CLASS: initial-value (self) : OBJECT
     Return an initial value for the class SELF.

 -- Method on STORAGE-SLOT: initial-value (self) : OBJECT
     Return an initial value for SELF, or `null'.  The initial value
     can be defined by the slot itself, inherited from an equivalent
     slot, or inherit from the :initial-value option for the class
     representing the type of SELF.

 -- Method on DIMENSIONAL-ARRAY-MIXIN: initialize-array (self
          (initialValue (LIKE (ANY-VALUE SELF)))) :
     Initialize the elements of SELF with INITIALVALUE.

 -- Method on STELLA-HASH-TABLE: initialize-hash-table (self) :
     Initialize the STELLA hash table SELF.  This is a no-op and
     primarily exists to shadow the standard initializer inherited from
     ABSTRACT-HASH-TABLE.  STELLA hash tables are initialized at the
     first insertion operation.

 -- Method on STORAGE-SLOT: initially (self) : OBJECT
     Defines the value of a slot before it has been assigned a value.

 -- Method on CUSTOM-VECTOR-SEQUENCE: insert (self
          (value (LIKE (ANY-VALUE SELF)))) :
     Append VALUE to the END of the sequence SELF.  Resize the array if
     necessary.

 -- Method on HEAP: insert (self (value (LIKE (ANY-VALUE SELF)))) :
     Insert VALUE into SELF and restore the heap property.  Signal an
     error if there is no more room in SELF.  Maintains SELF as a
     Min-heap if SELFs `predicate' has `<' semantics; otherwise as a
     Max-heap.

 -- Method on HEAP: insert-if-better (self
          (value (LIKE (ANY-VALUE SELF)))) :
     Insert VALUE into SELF and restore the heap property.  If SELF has
     available room, simply insert VALUE.  If the heap is full, only
     insert VALUE if it is better than the current root (i.e., the
     minimum of SELF if SELFs `predicate' has `<' semantics).  In that
     case, replace the root of SELF and restore the heap property.
     This is useful to build and maintain a heap with some top-N
     elements (relative to `predicate') where the root (or minimum) of
     SELF is the currently weakest element at the end of the list.

 -- Function: integer-length ((x LONG-INTEGER)) : INTEGER
     Return the 1-based position of the left-most bit in X.  If X is
     negative, we only count the value bits, not the sign.

 -- Function: integer-to-hex-string ((i LONG-INTEGER)) : STRING
     Convert I to a string representation in hexadecimal notation and
     return the result.

 -- Function: integer-to-string-in-base ((i LONG-INTEGER)
          (base INTEGER)) : STRING
     Convert I to a string representation in BASE and return the
     result.  BASE must be positive and not more than 36.

     Note that in the C++ version, only 8, 10 and 16 will work as BASE
     arguments, since that is all the underlying implementation
     supports.  Other argument values will be treated as `10'.

 -- Function: integer-valued? ((x FLOAT)) : BOOLEAN
     Returns `true' if X is the floating point representation of an
     integer.

 -- Function: intern-stella-name ((name STRING)) : GENERALIZED-SYMBOL
     Parse NAME which is assumed to be the printed representation of a
     STELLA symbol, surrogate or keyword, intern it into the current or
     specified module and return the result.  This is identical to
     calling `unstringify' on NAME but 10-15 times faster.

 -- Function: interpret-command-line-arguments ((count INTEGER)
          (arguments (ARRAY () OF STRING))) :
     Old name for `process-command-line-arguments' (which see).

 -- Function: isa? ((object OBJECT) (type TYPE)) : BOOLEAN
     Return `true' iff OBJECT is an instance of the class named TYPE.

 -- Function: java-translate-system ((systemName STRING)) :
     Translate the system SYSTEMNAME to Java.

 -- N-Command: jptrans ((statement OBJECT)) :
     Translate STATEMENT to C++ and print the result.

 -- Function: keyword-name? ((name STRING)) : BOOLEAN
     Return TRUE if name is prefixed by `:'.

 -- Function: kvlist-to-plist ((self KEY-VALUE-LIST)) : (PROPERTY-LIST
          OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))
     Convert SELF into a property list with identical and identically
     ordered keys and values.

 -- Method on VECTOR-SEQUENCE: last (self) : (LIKE (ANY-VALUE SELF))
     Return the last item in the vector SELF.

 -- Method on CONS-ITERATOR: length (self) : INTEGER
     Iterate over SELF, and count how many items there are.

 -- Method on HEAP: length (self) : INTEGER
     Return the length of the currently filled portion of SELF.

 -- Method on DIMENSIONAL-ARRAY-MIXIN: length (self) : INTEGER
     Return the total number of elements in SELF.

 -- Method on 2-DIMENSIONAL-ARRAY-MIXIN: length (self) : INTEGER
     Return the total number of elements in SELF.

 -- Function: lispify ((thing UNKNOWN)) : LISP-CODE
     Convert a Stella THING as much as possible into a Common-Lisp
     analogue.  The currently supported THING types are CONS, LIST,
     KEY-VALUE-LIST, ITERATOR, SYMBOL, KEYWORD, and all wrapped and
     unwrapped literal types.  BOOLEANs are translated into Lisp's CL:T
     and CL:NIL logic.  Unsupported types are left unchanged.

 -- Function: lispify-boolean ((thing UNKNOWN)) : LISP-CODE
     Lispify THING which is assumed to be a (possibly wrapped) Stella
     boolean.

 -- Command: list-directory-files ((directory STRING)) : (CONS OF
          STRING-WRAPPER)
     Return all the files and sub-directories in DIRECTORY sorted by
     name.  Each returned file is a bare file name without a DIRECTORY
     component.  If a file is a directory, it will look just like a
     plain file.  This means consumers might have to explicitly test
     whether a file is a directory depending on what they do. Excludes
     . and ..  directories.  Handles logical pathnames but resulting
     files will always use physical pathname syntax.  This is mostly
     consistent across native languages, but some differences still
     exist - e.g., Lisp will convert . or .. into absolute pathnames.

 -- Command: list-modules ((kb-only? BOOLEAN)) : (CONS OF MODULE)
     Returns a cons of all modules defined in PowerLoom.  If KB-ONLY?
     is `true', then any modules which are code only or just namespaces
     are not returned.

 -- Method on CONS: listify (self) : (LIST OF (LIKE (ANY-VALUE SELF)))
     Return a list of elements in SELF.

 -- Method on LIST: listify (self) : (LIST OF (LIKE (ANY-VALUE SELF)))
     Return SELF.

 -- Method on KEY-VALUE-LIST: listify (self) : (LIST OF (LIKE
          (ANY-VALUE SELF)))
     Return a list of key-value pairs in SELF.

 -- Method on VECTOR: listify (self) : (LIST OF (LIKE (ANY-VALUE SELF)))
     Return a list of elements in SELF.

 -- Method on ITERATOR: listify (self) : (LIST OF (LIKE (ANY-VALUE
          SELF)))
     Return a list of elements generated by SELF.

 -- Command: load-configuration-file ((file FILE-NAME)) :
          CONFIGURATION-TABLE
     Read a configuration FILE and return its content as a
     configuration table.  Also enter each property read into the
     global system configuration table.  Assumes Java-style property
     file syntax.  Each property name is represented as a wrapped
     string and each value as a wrapped string/integer/float or boolean.

 -- Command: load-file ((file STRING)) :
     Read STELLA commands from FILE and evaluate them.  The file should
     begin with an `in-module' declaration that specifies the module
     within which all remaining commands are to be evaluated The
     remaining commands are evaluated one-by-one, applying the function
     `evaluate' to each of them.

 -- Function: load-file-option-handler ((option CMD-LINE-OPTION)
          (value OBJECT)) :
     Load the file VALUE using the STELLA `load-file' command.

 -- Function: load-path-option-handler ((option CMD-LINE-OPTION)
          (value OBJECT)) :
     Modify the current file load path according to OPTION and VALUE.

 -- Command: load-system ((systemName STRING)
          &rest (language&options OBJECT)) : BOOLEAN
     Natively `language'-compile out-of-date translated files of system
     SYSTEMNAME (only supported for Lisp at the moment) and then load
     them into the running system.  Return true if at least one file
     was compiled.  The following keyword/value `options' are
     recognized:

     `:language': can be used as an alternative to the optional
     language argument.  If not specified, the language of the running
     implementation is assumed.

     `:force-recompilation?' (default false): if true, files will be
     compiled whether or not their compilations are up-to-date.

     `:startup?' (default true): if true, the system startup function
     will be called once all files have been loaded.

 -- Function: log-level<= ((level OBJECT) (module STRING)) : BOOLEAN
     Return TRUE if LEVEL is lower than or equal to the current log
     level of MODULE.  Return FALSE if any of them are undefined.

 -- Function: log-message ((module STRING) (logLevel OBJECT)
          (message CONS)) :
     Log all elements of MESSAGE to MODULEs log stream if LOGLEVEL is
     the same or lower than the MODULEs log level.  Interprets `EOL' or
     :EOL to print a line terminator.

 -- Function: logmsg ((module STRING) (logLevel OBJECT)
          &rest (message OBJECT)) :
     Log all elements of MESSAGE to MODULEs log stream if LOGLEVEL is
     the same or lower than the MODULEs log level.  Interprets `EOL' or
     :EOL to print a line terminator.

 -- Method on SYMBOL: lookup-class (name) : CLASS
     Return a class with name NAME.  Scan all visible surrogates
     looking for one that has a class defined for it.

 -- Method on STRING: lookup-class (name) : CLASS
     Return a class with name NAME.  Scan all visible surrogates
     looking for one that has a class defined for it.

 -- Function: lookup-command ((name SYMBOL)) : METHOD-SLOT
     If NAME names an evaluable command return its associated command
     object;  otherwise, return `null'.  Currently, commands are not
     polymorphic, i.e., they can only be implemented by functions.

 -- Function: lookup-configuration-property ((property STRING)
          (defaultValue WRAPPER) (configuration CONFIGURATION-TABLE)) :
          OBJECT
     Lookup PROPERTY in CONFIGURATION and return its value.  Use the
     global system configuration table if CONFIGURATION is NULL.  Return
     DEFAULTVALUE if PROPERTY is not defined.

 -- Function: lookup-configuration-property-values ((property STRING)
          (defaultValue OBJECT) (configuration CONFIGURATION-TABLE)) :
          CONS
     Lookup PROPERTY in CONFIGURATION, assume it is a multi-valued
     property and return its value(s) as a list.  Use the global system
     configuration table if CONFIGURATION is NULL.  Return DEFAULTVALUE
     if PROPERTY is not defined or NIL is no default value is specified.

 -- Function: lookup-demon ((name STRING)) : DEMON
     Return the demon named NAME.

 -- Function: lookup-function ((functionSymbol SYMBOL)) : FUNCTION
     Return the function defined for FUNCTIONSYMBOL, if it exists.

 -- Function: lookup-function-by-name ((name STRING)) : FUNCTION
     Return a function with name NAME visible from the current module.
     Scan all visible symbols looking for one that has a function
     defined for it.

 -- Method on SURROGATE: lookup-global-variable (self) : GLOBAL-VARIABLE
     Return a global variable with name SELF.

 -- Method on GENERALIZED-SYMBOL: lookup-global-variable (self) :
          GLOBAL-VARIABLE
     Return a global variable with name SELF.

 -- Method on STRING: lookup-global-variable (self) : GLOBAL-VARIABLE
     Return a global variable with name SELF.

 -- Function: lookup-local-slot ((class CLASS) (slot-name SYMBOL)) :
          SLOT
     Lookup a local slot with SLOT-NAME on CLASS.

 -- Function: lookup-logging-parameter ((module STRING)
          (parameter KEYWORD) (default OBJECT)) : OBJECT
     Lookup logging PARAMETER for MODULE.  Use DEFAULT if no value is
     defined.

 -- Function: lookup-macro ((name SYMBOL)) : METHOD-SLOT
     If NAME has a macro definition, return the method object holding
     its expander function.

 -- Function: lookup-slot ((class CLASS) (slot-name SYMBOL)) : SLOT
     Return a slot owned by the class CLASS with name SLOT-NAME.
     Multiply inherited slots are disambiguated by a left-to-right class
     precedence order for classes with multiple parents (similar to
     CLOS).

 -- Method on PROPERTY-LIST: lookup-with-default (self
          (key (LIKE (ANY-KEY SELF)))
          (default (LIKE (ANY-VALUE SELF)))) : (LIKE (ANY-VALUE SELF))
     Lookup KEY in SELF and return the result.  Return DEFAULT if no
     value was found.

 -- Method on KEY-VALUE-LIST: lookup-with-default (self
          (key (LIKE (ANY-KEY SELF)))
          (default (LIKE (ANY-VALUE SELF)))) : (LIKE (ANY-VALUE SELF))
     Lookup KEY in SELF and return the result.  Return DEFAULT if no
     value was found.

 -- N-Command: lptrans ((statement OBJECT)) :
     Translate STATEMENT to Common-Lisp and print the result.

 -- Function: make-matching-name ((original STRING)
          &rest (options OBJECT)) : STRING
     Keyword options:   :break-on-cap    one of  :YES :NO :CLEVER
      default is :CLEVER   :break-on-number one of  :YES :NO :CLEVER
         default is :CLEVER   :break-on-separators string
            default is "-_ "   :remove-prefix   string   :remove-suffix
      string

     :case            one of  :UPCASE :TitleCase :titleCaseX :downcase
     :Capitalize :preserve
            default is :TitleCase   :separator       string
                   default is ""   :add-prefix      string
     :add-suffix      string

     MAKE-MATCHING-NAME returns a matching name (a string) for the
     input name (a string).  A matching name is constructed by breaking
     the input into `words' and then applying appropriate transforms.
     The arguments are used as follows:   ORIGINAL         is the input
     name.  It is a string.    :break-on-cap    is a keyword
     controlling whether changes in capitalization is used
          to indicate word boundaries.  If :YES, then all capitalization
                       changes delineate words.  If :CLEVER, then
     unbroken runs of                    capitalized letters are
     treated as acronyms and remain grouped.                     If :NO
     or NULL, there is no breaking of words based on capitalization.
     :break-on-number is a flag controlling whether encountering a
     number indicates                    a word boundary.  If :YES,
     then each run of numbers is treated as 		   a word
     separate from surrounding words.  If :CLEVER, then an
       attempt is made to recognize ordinal numbers (ie, 101st) and
       treat them as separate words.  If :NO or NULL, there is no
     breaking                    of words when numbers are encountered.
      :break-on-separators   A string of characters which constitute
     word delimiters in                          the input word.  This
     is used to determine how to break                    the name into
     individual words.  Defaults are space, `-' and `_'.
     :remove-prefix   Specifies a prefix or suffix that is stripped
     from the input   :remove-suffix   name before any other
     processing.  This allows the removal of                    any
     naming convention dictated prefixes or suffixes.    :add-prefix
      Specifies a prefix or suffix that is added to the output name
     :add-suffix      after all other processing.  This allows the
     addition of any                    naming convention dictated
     prefixes or suffixes.    :case            The case of the
     resulting name.  This is applied to the name
     before adding prefixes or suffixes.  The two title case options
                    differ only in how the first word of the name is
     treated.                     :TitleCase capitalizes the first
     letter of the first word and                        also the first
     letter of all other words.                     :TitleCaseX does
     not capitalizes the first letter of the first
     word but capitalizes the first letter of all subsequent words.
       :preserve results in no change in case.    :separator       This
     is a string specifying the word separator to use in the
            returned name.  An empty string (the default) means that the
                       resulting words are concatenated without any
     separation.  This                    normally only makes sense
     when using one of the title case values                    for the
     case keyword.

 -- Function: make-matching-name-full ((originalname STRING)
          (breakoncap KEYWORD) (breakonnumber KEYWORD)
          (breakonseparators STRING) (removeprefix STRING)
          (removesuffix STRING) (addprefix STRING) (addsuffix STRING)
          (outputcase KEYWORD) (outputseparator STRING)) : STRING
     Non-keyword version of `make-matching-name', which will probably be
     easier to use when called from non-Lisp languages.

 -- Command: make-system ((systemName STRING)
          &rest (language&options OBJECT)) : BOOLEAN
     Translate all out-of-date files of system SYSTEMNAME into
     `language' (the first optional argument of LANGUAGE&OPTIONS) and
     then compile and load them (the latter is only possible for Lisp
     right now).  The following keyword/value `options' are recognized:

     `:language': can be used as an alternative to the optional
     language argument.  If not specified, the language of the running
     implementation is assumed.

     `:two-pass?': if true, all files will be scanned twice, once to
     load the signatures of objects defined in them, and once to
     actually translate the definitions.  Otherwise, the translator
     will make one pass in the case that the system is already loaded
     (and is being remade), and two passes otherwise.

     `:development-settings?' (default false): if true translation will
     favor safe, readable and debuggable code over efficiency
     (according to the value of `:development-settings' on the system
     definition).  If false, efficiency will be favored instead
     (according to the value of `:production-settings' on the system
     definition).

     `:production-settings?' (default true): inverse to
     `:development-settings?'.

     `:force-translation?' (default false): if true, files will be
     translated whether or not their translations are up-to-date.

     `:force-recompilation?' (default false): if true, translated files
     will be recompiled whether or not their compilations are
     up-to-date (only supported in Lisp right now).

     `:load-system?' (default true): if true, compiled files will be
     loaded into the current STELLA image (only supported in Lisp and
     Java right now).

     `:startup?' (default true): if true, the system startup function
     will be called once all files have been loaded.

 -- Method on INTEGER: max (x (y INTEGER)) : INTEGER
     Return the maximum of X and Y.  If either is NULL, return the
     other.

 -- Method on LONG-INTEGER: max (x (y LONG-INTEGER)) : LONG-INTEGER
     Return the maximum of X and Y.  If either is NULL, return the
     other.

 -- Method on FLOAT: max (x (y FLOAT)) : FLOAT
     Return the maximum of X and Y.  If either is NULL, return the
     other.

 -- Method on NUMBER-WRAPPER: max (x (y NUMBER-WRAPPER)) :
          NUMBER-WRAPPER
     Return the maximum of X and Y.  If Y is NULL, return X.

 -- Method on CONS-ITERATOR: member? (self (value OBJECT)) : BOOLEAN
     Iterate over values of SELF and return TRUE if one of them is
     `eql?' to 'value.

 -- Method on COLLECTION: member? (self (object OBJECT)) : BOOLEAN
     Return true iff OBJECT is a member of the collection SELF.

 -- Method on SEQUENCE: member? (self (value OBJECT)) : BOOLEAN
     Return TRUE if VALUE is a member of the sequence SELF.

 -- Macro: memoize ((inputArgs CONS) &body (body CONS)) : OBJECT
     Compute the value of an expression and memoize it relative to
     the values of INPUTARGS.  INPUTARGS should characterize the
     complete set of values upon which    the computation of the result
     depended.  Calls to `memoize' should be of the form

     (memoize (<arg>+) {:<option> <value>}* <expression>)

     and have the status of an expression.     The following options
     are supported:

     :timestamps   A single or list of keywords specifying the names of
                        timestamps which when bumped should invalidate
     all                     entries currently memoized in this table.
          :name         Names the memoization table so it can be shared
     by other                     memoization sites.  By default, a
     gensymed name is used.                      CAUTION: IT IS ASSUMED
     THAT ALL ENTRIES IN A MEMOZATION                     TABLE DEPEND
     ON THE SAME NUMBER OF ARGUMENTS!!        :max-values   The maximum
     number of values to be memoized.  Only the
     `:max-values' most recently used values will be kept
          in the memoization table, older values will be discarded
                   and recomputed if needed.  Without a `:max-values'
                      specification, the memoization table will grow
                     indefinitely.

     PERFORMANCE NOTES: For most efficient lookup, input arguments that
     vary the most should be listed first.  Also, arguments of type
     STANDARD-OBJECT (and all its subtypes) can be memoized more
     efficiently than arguments of type OBJECT or wrapped literals
     (with the exception of BOOLEANs).

 -- Function: merge-file-names ((baseFile FILE-NAME)
          (defaults FILE-NAME)) : FILE-NAME
     Parse BASEFILE, supply any missing components from DEFAULTS if
     supplied and return the result.

 -- Method on DECODED-DATE-TIME: merge-null-fields (self
          (default DECODED-DATE-TIME)) :
     Replace any null valued fields in SELF with values from DEFAULT.
     The day of the week will be set consistently, if possible.

 -- Method on DECODED-DATE-TIME: merge-superior-null-fields (self
          (default DECODED-DATE-TIME)) :
     Replace only null valued fields in SELF that represent larger time
     units than the smallest non-null in SELF with values from DEFAULT.
     The day of the week will be set consistently, if possible.
     Example: if SELF just has the month being non-null, then only the
     year will be filled in from DEFAULT.  If the day and minute were
     non-null, then hour, month and year will be filled.

     This can be useful when one doesn't want to extend the precision
     of the answer.

 -- Method on INTEGER: min (x (y INTEGER)) : INTEGER
     Return the minimum of X and Y.  If either is NULL, return the
     other.

 -- Method on LONG-INTEGER: min (x (y LONG-INTEGER)) : LONG-INTEGER
     Return the minimum of X and Y.  If either is NULL, return the
     other.

 -- Method on FLOAT: min (x (y FLOAT)) : FLOAT
     Return the minimum of X and Y.  If either is NULL, return the
     other.

 -- Method on NUMBER-WRAPPER: min (x (y NUMBER-WRAPPER)) :
          NUMBER-WRAPPER
     Return the minimum of X and Y.  If Y is NULL, return X.

 -- Method on INTEGER: mod (x (modulus INTEGER)) : INTEGER
     True modulus.  Return the result of X mod `modulo'.  Note: In C++
     and Java, `mod' has more overhead than the similar function `rem'.
     The  answers returned by `mod' and `rem' are only different when
     the signs of X and `modulo' are different.

 -- Method on LONG-INTEGER: mod (x (modulus LONG-INTEGER)) :
          LONG-INTEGER
     True modulus.  Return the result of X mod `modulo'.  Note: In C++
     and Java, `mod' has more overhead than the similar function `rem'.
     The  answers returned by `mod' and `rem' are only different when
     the signs of X and `modulo' are different.

 -- Method on CLASS: multiple-parents? (class) : BOOLEAN
     Return `true' if CLASS has more than one direct superclass.

 -- Method on MODULE: multiple-parents? (module) : BOOLEAN
     Return TRUE if MODULE has more than one parent.

 -- Method on WORLD: multiple-parents? (world) : BOOLEAN
     Return FALSE always, since worlds never have more than one parent.

 -- Function: name-to-string ((name OBJECT)) : STRING
     Return the string represented by NAME.  Return `null' if NAME is
     undefined or does not represent a string.

 -- Function: native-delete-file ((fileName FILE-NAME)) :
     Delete the file FILENAME.  This does not handle any necessary
     pathname translations or error conditions.

 -- Function: native-file-length ((fileName FILE-NAME)) : LONG-INTEGER
     Return the length of file FILENAME in bytes or NULL if that cannot
     be determined.  This does not handle any necessary pathname
     translations or error conditions.

 -- Function: native-file-write-date ((fileName FILE-NAME)) :
          CALENDAR-DATE
     Return the time at which file FILENAME was last modified or NULL
     if that cannot be determined.  This does not handle any necessary
     pathname translations or error conditions.

 -- Function: native-probe-file? ((fileName FILE-NAME)) : BOOLEAN
     Return true if file FILENAME exists.  Note that this does not
     necessarily mean that the file can also be read.  This does not
     handle any necessary pathname translations or error conditions.

 -- Function: native-read-line ((inputStream INPUT-STREAM)) : STRING
     Read one line from INPUTSTREAM using the native language readline
     algorithm and return the result.  On EOF return `null'

 -- Function: native-rename-file ((fromFile FILE-NAME)
          (toFile FILE-NAME)) :
     Rename the file FROMFILE to TOFILE.  This does not handle any
     necessary pathname translations or error conditions.

 -- Method on MEMOIZABLE-ITERATOR: next? (self) : BOOLEAN
     Generate the next value of the memoized iterator SELF (or one of
     its clones) by either using one of the values generated so far or
     by generating and saving the next value of the `base-iterator'.

 -- Method on COLLECTION: no-duplicates? (self) : BOOLEAN
     Return `true' if the collection SELF forbids duplicate values.

 -- Method on STRING-WRAPPER: non-empty? (x) : BOOLEAN
     Return true if X is not the wrapped empty string ""

 -- Method on VECTOR-SEQUENCE: non-empty? (self) : BOOLEAN
     Return `true' if SELF has length > 0.

 -- Function: non-matching-position ((source STRING) (start INTEGER)
          (match STRING)) : INTEGER
     Returns the index into SOURCE, starting from START, of the first
     character that is not included in MATCH.

 -- Function: non-matching-position-helper ((source STRING)
          (start INTEGER) (end INTEGER) (match STRING)) : INTEGER
     Helper for `non-matching-position' that requires END to not be
     `null'.

 -- Method on NATIVE-VECTOR: nth (self (position INTEGER)) : (LIKE
          (ANY-VALUE SELF))
     Return the element in SELF at POSITION.

 -- Method on LONG-INTEGER: null? (x) : BOOLEAN
     Return true if X is undefined (handled specially by all
     translators).

 -- Method on ARRAY: null? (x) : BOOLEAN
     Return true if X is undefined (handled specially by all
     translators).

 -- Function: number-less-than? ((x NUMBER-WRAPPER) (y NUMBER-WRAPPER))
          : BOOLEAN
     Generic number comparison that works with integers, longs and
     floats.

 -- Method on VECTOR-SEQUENCE: object-equal? (x (y OBJECT)) : BOOLEAN
     Return TRUE iff the sequences X and Y are structurally equivalent.
     Uses `equal?' to test equality of elements.

 -- Method on INTEGER: odd? (x) : BOOLEAN
     Return true if X is an odd number.

 -- Method on LONG-INTEGER: odd? (x) : BOOLEAN
     Return true if X is an odd number.

 -- Macro: only-if ((test OBJECT) (expression OBJECT)) : OBJECT
     If TEST is TRUE, return the result of evaluating EXPRESSION.

 -- Function: open-network-stream ((host STRING) (port INTEGER)) :
          INPUT-STREAM OUTPUT-STREAM
     Open a TCP/IP network stream to HOST at PORT and return the result
     as an input/output stream pair.

 -- Method on COLLECTION: ordered? (self) : BOOLEAN
     Return `true' if the collection SELF is ordered.

 -- Function: outline-depth-exceeded? ((current-depth INTEGER)
          (depth-limit INTEGER)) : BOOLEAN
     Helper function that returns `true' if CURRENT-DEPTH exceeds
     DEPTH-LIMIT.  This functions uses the convention that a `null' or
     negative value of DEPTH-LIMIT means the depth is unlimited.  In
     those cases it always returns false.

 -- Method on CLASS: parameters (self) : (LIST OF SYMBOL)
     Returns the list of parameters names of SELF.

 -- Function: parse-date-time-in-time-zone ((date-time-string STRING)
          (time-zone FLOAT) (start INTEGER) (end INTEGER)
          (error-on-mismatch? BOOLEAN)) : DECODED-DATE-TIME
     Tries very hard to make sense out of the argument DATE-TIME-STRING
     and returns a time structure if successful.  If not, it returns
     `null'.  If ERROR-ON-MISMATCH? is true, parse-date-time will
     signal an error instead of returning `null'.  Default values are
     00:00:00 in the given timezone on the current date.  If the given
     TIME-ZONE value is `null', then the local time zone for the given
     date and time will be used as determined by the operating system.

 -- Function: parse-date-time-relative-to-base
          ((date-time-string STRING) (base-date-time DECODED-DATE-TIME)
          (start INTEGER) (end INTEGER) (error-on-mismatch? BOOLEAN)
          (merge-null-fields? BOOLEAN)) : DECODED-DATE-TIME
     Tries very hard to make sense out of the argument DATE-TIME-STRING
     and returns a time structure if successful.  If not, it returns
     `null'.  If ERROR-ON-MISMATCH? is true, parse-date-time will
     signal an error instead of returning `null'.  Default values are
     passed in via BASE-DATE-TIME.  If the timezone field that is
     passed in is NULL, then the local time zone for the parsed
     date/time will be used.  If MERGE-NULL-FIELDS? is `true', then
     default values from `base-time-date' will be merged into missing
     components.  If `false', then they won't be merged in for null
     components but can still be used as a basis for interpreatation of
     relative time strings like "now" or "yesterday"

 -- Function: parse-options ((options OBJECT) (legalOptions&Types CONS)
          (coercionError? BOOLEAN) (allowOtherKeys? BOOLEAN)) :
          PROPERTY-LIST
     Parse OPTIONS, check their validity according to
     LEGALOPTIONS&TYPES and return the result as a PROPERTY-LIST.
     LEGALOPTIONS&TYPES has to either be NULL or a flat list of legal
     <keyword> <coercionType> pairs.  A type specifcation of @IDENTITY
     means don't perform any coercion.  If COERCIONERROR? is TRUE,
     raise an error if a coercion failed.  If ALLOWOTHERKEYS? is TRUE
     options other than those specified in LEGALOPTIONS&TYPES are
     allowed but won't be coerced since we don't know their type.

 -- Function: parse-stella-name ((name STRING)
          (enableCaseConversion? BOOLEAN)) : STRING STRING KEYWORD
     Parse the printed representation NAME of a STELLA symbol,
     surrogate or keyword and return its symbol name, module name and
     type (which is either :SYMBOL, :SURROGATE or :KEYWORD).  NAME can
     be qualified and must use the exact same syntax and escape
     characters that would be used if it were to be read by
     `read-s-expression-from-string' (or `unstringify').  If
     ENABLECASECONVERSION? is TRUE, the returned symbol name will be
     upcased if the current module is case-insensitive; otherwise, it
     will be returned as is.  Raises a read exception if NAME does not
     represent a symbol.  This function is available primarily for
     efficiency, since it is about 10-15 times faster than
     `unstringify'.

 -- Function: pick-hash-table-size-prime ((minSize INTEGER)) : INTEGER
     Return a hash table prime of at least MINSIZE.

 -- Function: plist-to-kvlist ((self PROPERTY-LIST)) : (KEY-VALUE-LIST
          OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))
     Convert SELF into a key-value list with identical and identically
     ordered keys and values.

 -- Method on INTEGER: plus? (x) : BOOLEAN
     Return true if X is greater than 0.

 -- Method on LONG-INTEGER: plus? (x) : BOOLEAN
     Return true if X is greater than 0.

 -- Command: pop-load-path () : STRING
     Remove the first element from the STELLA load path and return the
     removed element.

 -- Method on OBJECT: primary-type (self) : TYPE
     Returns the primary type of SELF.  Gets defined automatically for
     every non-abstract subclass of OBJECT.

 -- Method on RELATION: primitive? (self) : BOOLEAN
     Return `true' if SELF is not a defined relation.

 -- Macro: print (&body (body CONS)) : OBJECT
     Print arguments to the standard output stream.

 -- Function: print-configuration-properties
          ((configuration CONFIGURATION-TABLE) (stream OUTPUT-STREAM)) :
     Print all properties defined in CONFIGURATION to STREAM.

 -- Function: print-exception-context ((e NATIVE-EXCEPTION)
          (stream OUTPUT-STREAM)) :
     Prints a system dependent information about the context of the
     specified exception.  For example, in Java it prints a stack
     trace.  In Lisp, it is vendor dependent.

 -- Command: print-outline ((thing OBJECT) (stream OUTPUT-STREAM)
          (depth INTEGER) (named? BOOLEAN)) :
     Print an outline of THING and its subparts on STREAM.  If DEPTH is
     non-negative, only DEPTH levels will be printed.  If NAMED? is
     `TRUE', then only named entities will be printed.

     This function is intended to be used on things like modules,
     contexts, concepts, etc. that have hierarchical structure.  If
     THING doesn't have a hierarchical structure, it will just be
     printed.

 -- Command: print-properties () :
     Print all current configuration property information to standard
     output.

 -- Function: print-recycle-lists () :
     Print the current state of all recycle lists.

 -- Macro: print-spaces (&body (body CONS)) : OBJECT
     (print-spaces [stream] N) prints N spaces onto stream.  If no
     stream form is provided, then STANDARD-OUTPUT will be used.

 -- Command: print-stella-features () :
     Print the list of enabled and disabled STELLA features.

 -- N-Command: print-unbound-surrogates (&rest (args OBJECT)) :
     Print all unbound surrogates visible from the module named by the
     first argument (a symbol or string).  Look at all modules if no
     module name or `null' was supplied.  If the second argument is
     `true', only consider surrogates interned in the specified module.

 -- Function: print-undefined-methods ((module MODULE)
          (local? BOOLEAN)) :
     Print all declared but not yet defined functions and methods in
     MODULE.  If LOCAL? is true, do not consider any parent modules of
     MODULE.  If MODULE is NULL, look at all modules in the system.
     This is handy to pinpoint forward declarations that haven't been
     followed up by actual definitions.

 -- N-Command: print-undefined-super-classes ((class NAME)) :
     Print all undefined or bad (indirect) super classes of CLASS.

 -- Function: private-class-methods ((class CLASS)) : (ITERATOR OF
          METHOD-SLOT)
     Iterate over all private methods attached to CLASS.

 -- Function: private-class-storage-slots ((class CLASS)) : (ITERATOR
          OF STORAGE-SLOT)
     Iterate over all private storage-slots attached to CLASS.

 -- Method on RELATION: private? (self) : BOOLEAN
     Return `true' if SELF is not public.

 -- Function: process-command-line-arguments ((count INTEGER)
          (arguments (ARRAY () OF STRING))
          (unhandledOptionAction KEYWORD)) :
     Interpret any command line ARGUMENTS for which handlers have been
     registered.  Leave any remaining unprocessed arguments in
     `*unprocessed-command-line-arguments*'.  If any unprocessed
     arguments use option syntax (that is they start with a `-'),
     proceed according to UNHANDLEDOPTIONACTION which can be one of
     :ignore, :warn or :error.  This ensures that at any point in the
     option processing, `*unprocessed-command-line-arguments*'
     accurately reflects the arguments which have been either skipped
     or not handled yet.

 -- Function: process-doctype ((doctype-declaration CONS)) : XML-DOCTYPE
     Takes an S-Expression representing a doctype and processes into a
     DOCTYPE object.

 -- N-Command: ptrans ((statement OBJECT)) :
     Translate STATEMENT to Common-Lisp and print the result.

 -- Function: public-class-methods ((class CLASS)) : (ITERATOR OF
          METHOD-SLOT)
     Iterate over all private methods attached to CLASS.

 -- Function: public-class-storage-slots ((class CLASS)) : (ITERATOR OF
          STORAGE-SLOT)
     Iterate over all public storage-slots attached to CLASS.

 -- Method on CLASS: public-slots (self) : (ITERATOR OF SLOT)
     Return an iterator over public slots of SELF.

 -- Method on OBJECT: public-slots (self) : (ITERATOR OF SLOT)
     Return an iterator over public slots of SELF.

 -- Method on SLOT: public? (self) : BOOLEAN
     True if SELF or one it its ancestors is marked public.

 -- Command: push-load-path ((path STRING)) : (CONS OF STRING-WRAPPER)
     Add the directories listed in the |-separated PATH to the front of
     the STELLA load path.  Return the resulting load path.

 -- Macro: pushf ((place CONS) (value OBJECT)) : OBJECT
     Push VALUE onto the cons list PLACE.

 -- Function: qualified-stella-name? ((name STRING)) : BOOLEAN
     Return TRUE if NAME is a symbol or surrogate qualified with a
     module pathname or a module pathname ending with a `/'.  Assumes
     that NAME is the printed representation of a STELLA symbol
     (potentially containing escape characters).

 -- Function: read-line2 ((stream INPUT-STREAM)) : STRING KEYWORD
     Read one line from STREAM and return the result and a keyword that
     indicates the terminator for that line ending: `:CR' `:LF' `:CRLF'
     or `:EOF'.   This is not platform-dependent and differs from
     `read-line' by returning a second value.  It may hang when used on
     interactive streams such as terminal or network streams with only
     CR line endings.  It should only be used on file or string input
     streams.

 -- Function: read-xml-expressions ((filename STRING)) : CONS
     Read all of the top-level XML expressions from FILENAME and return
     them in a list.

 -- Method on STORAGE-SLOT: reader (self) : SYMBOL
     Name of a method called to read the value of the slot SELF.

 -- Function: register-cmd-line-option (&rest (options OBJECT)) :
     Register a command line option.  :key identifies the name of the
     option which will usually start with a dash such as `-e' or
     `--eval'.  :key2 and :key3 can be used to supply additional
     options (e.g., long option formats).  To supply even more keys, a
     list can be supplied with the :keys option.  If a :property is
     supplied, this option simply sets or adds to the values of the
     specified system configuration property.  If a :handler name is
     specified, its function will be used to interpret the values of
     the option.  :documentation can be used to supply a documentation
     string which will be printed by the `help-option-handler' (usually
     bound to `-?').  :value-type describes what type an option value
     should be coerced to before assigning it to the specified
     configuration :property.  :n-arguments describes how many
     arguments this option takes.  This will be 0 for simple switches
     and can be 1 or greater than one for option handlers that need one
     or more arguments.  :default-value defines the value to use for
     zero-argument :property options.  If :multi-valued? is true,
     values of multiple occurrences of the option will be added to the
     specified configuration :property.  :error-action can be one of
     :ignore, :warn or :error to specify what to do in case an error is
     encountered during option processing.

 -- Function: regular-integer-valued? ((x LONG-INTEGER)) : BOOLEAN
     Return `true' if X can be represented by a regular integer.

 -- Method on INTEGER: rem (x (y INTEGER)) : INTEGER
     Return the remainder from dividing X by Y.  The sign of the result
     is always the same as the sign of X.  This has slightly different
     behavior than the `mod' function, and has less overhead in C++ and
     Java, which don't have direct support for a true modulus function.

 -- Method on LONG-INTEGER: rem (x (y LONG-INTEGER)) : LONG-INTEGER
     Return the remainder from dividing X by Y.  The sign of the result
     is always the same as the sign of X.  This has slightly different
     behavior than the `mod' function, and has less overhead in C++ and
     Java, which don't have direct support for a true modulus function.

 -- Function: remove-configuration-property ((property STRING)
          (value OBJECT) (configuration CONFIGURATION-TABLE)) : OBJECT
     Remove VALUE from PROPERTY in CONFIGURATION and return it.  Use
     the global system configuration table if CONFIGURATION is NULL.

 -- Method on COLLECTION: remove-duplicates (self) : (LIKE SELF)
     Return SELF with duplicates removed.  Preserves the original order
     of the remaining members.

 -- Method on CONS: remove-duplicates-equal (self) : (LIKE SELF)
     `remove-duplicates' (which see) using an `equal?' test.

 -- Method on LIST: remove-duplicates-equal (self) : (LIKE SELF)
     `remove-duplicates' (which see) using an `equal?' test.

 -- Method on HEAP: replace-heap-root (self
          (value (LIKE (ANY-VALUE SELF)))) :
     Replace the current root of SELF with VALUE and restore the heap
     property.  Signal an error if SELF is empty.  Maintains SELF as a
     Min-heap if SELFs `predicate' has `<' semantics; otherwise as a
     Max-heap.

 -- Method on CLASS: required-slots (self) : (LIST OF SYMBOL)
     Returns a list of names of required slots for SELF.

 -- Method on STORAGE-SLOT: required? (self) : BOOLEAN
     True if a value must be assigned to this slot at creation time.

 -- Command: reset-stella-features () :
     Reset STELLA features to their default settings.

 -- Method on VECTOR-SEQUENCE: reverse (self) : (LIKE SELF)
     Reverse the order of elements in the active portion of SELF.

 -- Function: reverse-interval ((lowerbound INTEGER)
          (upperbound INTEGER)) : REVERSE-INTEGER-INTERVAL-ITERATOR
     Create a reverse interval object.

 -- Function: run-hooks ((hooklist HOOK-LIST) (argument OBJECT)) :
     Run all hook functions in HOOKLIST, applying each one to ARGUMENT.

 -- Function: running-as-lisp? () : BOOLEAN
     Return true if the executable code is a Common Lisp application.

 -- Function: running-in-language () : KEYWORD
     Returns the keyword for the language the current implementation is
     running in.

 -- Function: running-system-information () : STRING
     Returns an information string about the current running system
     environment.

 -- Function: safe-equal-hash-code ((self OBJECT)) : INTEGER
     Return a hash code for SELF.  Just like `equal-hash-code' - which
     see, but also works for NULL.  `equal-hash-code' methods that
     expect to handle NULL components should use this function for
     recursive calls.

 -- Function: safe-hash-code ((self OBJECT)) : INTEGER
     Return a hash code for SELF.  Just like `hash-code' - which see,
     but also works for NULL.

 -- Function: safe-lookup-slot ((class CLASS) (slot-name SYMBOL)) : SLOT
     Alias for `lookup-slot'.  Kept for backwards compatibility.

 -- Macro: safety ((level INTEGER-WRAPPER) (test OBJECT)
          &body (body CONS)) : OBJECT
     Signal warning message, placing non-string arguments in quotes.

 -- Function: save-configuration-file ((table CONFIGURATION-TABLE)
          (file FILE-NAME) (title STRING)) :
     Save TABLE as a configuration file.  Uses a Java-style property
     file syntax.

 -- Function: save-configuration-value ((stream OUTPUT-STREAM)
          (value OBJECT)) :
     Save VALUE to STREAM as a properly formatted configuration value.

 -- Function: search-cons-tree-with-filter? ((tree OBJECT)
          (value OBJECT) (filter CONS)) : BOOLEAN
     Return `true' iff the value VALUE is embedded within the cons tree
     TREE.  Uses an `eql?' test.  Does not descend into any cons whose
     first element matches an element of FILTER.

 -- Function: search-for-object ((self OBJECT) (typeref OBJECT)) :
          OBJECT
     If SELF is a string or a symbol, search for an object named SELF
     of type `type'.  Otherwise, if SELF is an object, return it.

 -- Function: seed-random-number-generator () :
     Seeds the random number generator with the current time.

 -- Function: sequence ((collectiontype TYPE) &rest (values OBJECT)) :
          (SEQUENCE OF OBJECT)
     Return a sequence containing VALUES, in order.

 -- Command: set-call-log-break-point ((count INTEGER)) :
     Set a call log break point to COUNT.  Execution will be
     interrupted right at the entry of the COUNTth logged function call.

 -- Function: set-configuration-property ((property STRING)
          (value OBJECT) (configuration CONFIGURATION-TABLE)) : OBJECT
     Set PROPERTY in CONFIGURATION to VALUE and return it.  Use the
     global system configuration table if CONFIGURATION is NULL.

 -- Method on DECODED-DATE-TIME: set-current-date (values-structure) :
     Sets the current date into VALUES-STRUCTURE

 -- Method on DECODED-DATE-TIME: set-current-date-time
          (values-structure) :
     Sets the current date and time into VALUES-STRUCTURE

 -- Method on DECODED-DATE-TIME: set-current-time (values-structure) :
     Sets the current time into VALUES-STRUCTURE

 -- Function: set-global-value ((self SURROGATE) (value OBJECT)) :
          OBJECT
     Set the value of the global variable for the surrogate SELF to
     VALUE.

 -- Command: set-load-path ((path STRING)) : (CONS OF STRING-WRAPPER)
     Set the STELLA load path to the |-separated directories listed in
     PATH.  Return the resulting load path.

 -- Command: set-log-level ((module STRING) (level OBJECT)) :
     Set the log-level for MODULE to LEVEL.  This is a convenience
     function for this common operation.

 -- Command: set-logging-parameters ((module STRING)
          &rest (params&values OBJECT)) :
     Set logging parameters for MODULE.  The supported parameters are:
     :LOG-LEVELS - a cons list of legal levels in ascending log level
     order;                 for example, (:NONE :LOW :MEDIUM :HIGH) or
     (0 1 2 3).    :LEVEL      - the current log level for MODULE
     :STREAM     - the stream or file to log to (defaults to
     STANDARD-OUTPUT)   :PREFIX     - the prefix to use to identify the
     module (defaults to MODULE)   :MAX-WIDTH  - logging output lines
     will be kept to approximately this width                 (defaults
     to 10000, minimum width of about 30 is used to
     print line header information).

 -- Function: set-optimization-levels ((safety INTEGER) (debug INTEGER)
          (speed INTEGER) (space INTEGER)) :
     Set optimization levels for the qualities SAFETY, DEBUG, SPEED,
     and SPACE.

 -- Command: set-property ((property NAME) (value OBJECT)) :
     Set PROPERTY (a string or symbol) in the configuration table to
     VALUE.  Note that PROPERTY is evaluated and will need to be quoted
     if supplied as a symbol.  Symbols will also be upcased if this
     command is run in a non-case-sensitive module.

 -- Command: set-stella-feature (&rest (features KEYWORD)) :
     Enable all listed STELLA FEATURES.

 -- Command: set-translator-output-language ((new-language KEYWORD)) :
          KEYWORD
     Set output language to NEW-LANGUAGE.  Return previous language.

 -- Macro: setq? ((variable SYMBOL) (expression CONS)) : OBJECT
     Assign VARIABLE the result of evaluating EXPRESSION, and return
     TRUE if EXPRESSION is not NULL else return FALSE.

 -- Function: shadowed-symbol? ((symbol GENERALIZED-SYMBOL)) : BOOLEAN
     Return `true' if SYMBOL is shadowed in its home module.

 -- Method on INTEGER: shift-right (arg (count INTEGER)) : INTEGER
     Shift ARG to the right by COUNT positions and 0-extend from the
     left if ARG is positive or 1-extend if it is negative.  This is an
     arithmetic shift that preserve the sign of ARG and is equivalent
     to dividing ARG by 2** COUNT.

 -- Method on LONG-INTEGER: shift-right (arg (count INTEGER)) :
          LONG-INTEGER
     Shift ARG to the right by COUNT positions and 0-extend from the
     left if ARG is positive or 1-extend if it is negative.  This is an
     arithmetic shift that preserve the sign of ARG and is equivalent
     to dividing ARG by 2** COUNT.

 -- Macro: signal ((type SYMBOL) &body (body CONS)) : OBJECT
     Signal error message, placing non-string arguments in quotes.

 -- Macro: signal-read-error (&body (body CONS)) : OBJECT
     Specialized version of `signal' that throws a READ-EXCEPTION.

 -- Method on VECTOR: sort (self (predicate FUNCTION-CODE)) : (VECTOR
          OF (LIKE (ANY-VALUE SELF)))
     Perform a destructive sort of SELF according to PREDICATE, and
     return the result.  If PREDICATE has a `<' semantics, the result
     will be in ascending order.  If PREDICATE is `null', a suitable
     `<' predicate is chosen depending on the first element of SELF,
     and it is assumed that all elements of SELF have the same type
     (supported element types are GENERALIZED-SYMBOL, STRING, INTEGER,
     and FLOAT).

 -- Method on HEAP: sort (self (predicate FUNCTION-CODE)) : (HEAP OF
          (LIKE (ANY-VALUE SELF)))
     Sort the heap SELF according to PREDICATE (in ascending order if
     PREDICATE has `<' semantics).  If PREDICATE is NULL simply use
     SELFs internal predicate (the normal case).  If it is different
     from SELFs internal predicate, heapify SELF first according to the
     new predicate, store the new predicate in SELF and then sort the
     heap.  Note that a sorted array automatically satisfies the heap
     property.  This is slightly different than a regular heap sort due
     to the way HEAP's are maintained; however, the complexity is the
     same.

 -- Function: split-string ((input STRING) (separator CHARACTER)) :
          (CONS OF STRING-WRAPPER)
     Split INPUT into separate strings based on the SEPARATOR character.

 -- Command: start-function-call-logging ((fileName STRING)) :
     Start function call logging to FILENAME.

 -- Function: starts-with? ((string STRING) (prefix STRING)
          (start INTEGER)) : BOOLEAN
     Return TRUE if STRING starts with PREFIX starting from START
     (which defaults to 0 if it is supplied as NULL).

 -- Function: stella-collection? ((self OBJECT)) : BOOLEAN
     Return `true' if SELF is a native collection.

 -- Command: stella-information () : STRING
     Returns information about the current Stella implementation.
     Useful when reporting problems.

 -- Function: stella-object? ((self OBJECT)) : BOOLEAN
     Return true if SELF is a member of the STELLA class `OBJECT'.

 -- Function: stella-version-string () : STRING
     Return a string identifying the current version of STELLA.

 -- Function: stellafy ((thing LISP-CODE) (targetType TYPE)) : OBJECT
     Partial inverse to `lispify'.  Convert the Lisp object THING into
     a Stella analogue of type TARGETTYPE.  Note: See also `stellify'.
     it is similar, but guesses TARGETTYPE on its own, and makes
     somewhat different translations.

 -- Function: stellify ((self OBJECT)) : OBJECT
     Convert a Lisp object into a STELLA object.

 -- Command: stop-function-call-logging () :
     Stop function call logging and close the current log file.

 -- Method on OUTPUT-FILE-STREAM: stream-position (self) : LONG-INTEGER
     Return the current position of the file input cursor in SELF.

 -- Method on INPUT-FILE-STREAM: stream-position (self) : LONG-INTEGER
     Return the current position of the file input cursor in SELF.

 -- Method on OUTPUT-FILE-STREAM: stream-position-setter (self
          (newpos LONG-INTEGER)) : LONG-INTEGER
     Set the current position of the file input cursor in SELF to
     NEWPOS.

 -- Method on INPUT-FILE-STREAM: stream-position-setter (self
          (newpos LONG-INTEGER)) : LONG-INTEGER
     Set the current position of the file input cursor in SELF to
     NEWPOS.  If SELF has any tokenizer state associated with it, this
     will also reset to the start state of the tokenizer table;
     otherwise, behavior would be unpredictable unless the character
     class of the new position is exactly the same as the one following
     the most recent token.

 -- Method on INPUT-STREAM: stream-to-string (from) : STRING
     Read all of the input from `stream' and return it as a string.

 -- Function: string-search-ignore-case ((string STRING)
          (substring STRING) (start INTEGER)) : INTEGER
     Return start position of the left-most occurrence of SUBSTRING in
     STRING, beginning from START.  Return NULL if it is not a
     substring.  The comparison ignores differences in letter case.

 -- Function: string-to-calendar-date-with-default ((input-date STRING)
          (default-date DECODED-DATE-TIME)) : CALENDAR-DATE
     Returns a calendar date object representing the date and time
     parsed from the INPUT-DATE string.  Default values for missing
     fields and the interpretation of relative references come from
     DEFAULT-DATE.  If the DEFAULT-DATE is `null', the current date
     will be used.  If a null set of defaults is desired, use
     `*NULL-DECODED-DATE-TIME*'.  If no valid parse is found, `null' is
     returned.

 -- Function: string-to-decoded-date-time ((input STRING)) :
          DECODED-DATE-TIME
     Returns a decoded date-time object representing the date and time
     parsed from the INPUT string.  If no valid parse is found, `null'
     is returned.

 -- Function: string-to-surrogate ((self STRING)) : SURROGATE
     Return a surrogate with the name SELF visible in the current
     module.  Very tricky: The logic is designed to avoid returning an
     inherited surrogate that has no value.  In that case, a new local
     surrogate is created that shadows the inherited surrogate.

 -- Function: string-to-time-duration ((duration STRING)) :
          TIME-DURATION
     Parses and returns an time-duration object corresponding to
     DURATION.  The syntax for time duration strings is "{plus|minus} N
     days[; M ms]" where N and M are integer values for days and
     milliseconds.  If no valid parse is found, `null' is returned.

 -- Function: string-trim ((string STRING)) : STRING
     Remove any leading and trailing white space from STRING and return
     a copy of the trimmed substring (which might be empty if we had
     all white space).  If no white space was removed, STRING is
     returned unmodified and uncopied.

 -- Function: subclass-of? ((subClass CLASS) (superClass CLASS)) :
          BOOLEAN
     Return `true' if SUBCLASS is a subclass of SUPERCLASS.

 -- Method on MUTABLE-STRING: subsequence (string (start INTEGER)
          (end INTEGER)) : STRING
     Return a substring of STRING beginning at position START and
     ending up to but not including position END, counting from zero.
     An END value of NULL stands for the rest of the string.

 -- Method on STRING: substitute-characters (self (new-chars STRING)
          (old-chars STRING)) : STRING
     Substitute all occurences of of a member of OLD-CHARS with the
     corresponding member of NEW-CHARS in the string SELF.  Returns a
     new string.

 -- Method on MUTABLE-STRING: substitute-characters (self
          (new-chars STRING) (old-chars STRING)) : MUTABLE-STRING
     Substitute all occurences of of a member of OLD-CHARS with the
     corresponding member of NEW-CHARS in the string SELF.  IMPORTANT:
     The return value should be used instead of relying on destructive
     substitution, since the substitution will not be destructive in
     all translated languages.

 -- Function: subtype-of? ((sub-type TYPE) (super-type TYPE)) : BOOLEAN
     Return `true' iff the class named SUB-TYPE is a subclass of the
     class named SUPER-TYPE.

 -- Method on CLASS: super-classes (self) : (ITERATOR OF CLASS)
     Returns an iterator that generates all super classes of SELF.
     Non-reflexive.

 -- Function: surrogate-name? ((name STRING)) : BOOLEAN
     Return TRUE if name is prefixed by `SURROGATE-PREFIX-CHARACTER'.

 -- Method on SURROGATE: surrogatify (self) : SURROGATE
     Converts SELF into a surrogate.

 -- Method on SYMBOL: surrogatify (self) : SURROGATE
     Converts SELF into a surrogate (same semantics as
     `symbol-to-surrogate' which see).

 -- Method on STRING: surrogatify (self) : SURROGATE
     Converts SELF into a surrogate.

 -- Method on OBJECT: sweep (self) :
     Default method.  Sweep up all SELF-type objects.

 -- Function: symbol-to-surrogate ((self SYMBOL)) : SURROGATE
     Return a surrogate with the same name as SELF.  Very tricky: The
     logic is designed to avoid returning an inherited surrogate that
     has no value.  In that case, a new local surrogate is created that
     shadows the inherited surrogate.  Unlike `string-to-surrogate',
     the search starts first from the home context of SELF, and if that
     fails, then it restarts in *module*.

 -- Function: symbol-to-type ((self SYMBOL)) : SURROGATE
     Convert SELF into a surrogate with the same name and module.

 -- Method on STORAGE-SLOT: system-default-value (self) : OBJECT
     Return a default value expression, or if SELF has dynamic storage,
     an initial value expression.

 -- Method on SLOT: system-default-value (self) : OBJECT
     Return a default value expression, or if SELF has dynamic storage,
     an initial value expression.

 -- Function: system-loaded-or-started-up? ((name STRING)) : BOOLEAN
     Return `true' if system NAME has either been loaded or initialized
     with its startup function.

 -- Function: system-loaded? ((name STRING)) : BOOLEAN
     Return `true' if system NAME has been loaded.

 -- Function: terminate-program () :
     Terminate and exit the program with normal exit code.

 -- Method on TIME-DURATION: time-duration-to-string (date) : STRING
     Returns a string representation of DATE

 -- Function: time-zone-format60 ((timezone FLOAT)
          (include-colon? BOOLEAN)) : STRING
     Format `zone' as an hh:mm or hhmm string depending on
     INCLUDE-COLON?

 -- Function: toggle-output-language () : KEYWORD
     Switch between Common Lisp and C++ as output languages.

 -- Function: tokenize-string ((string STRING)
          (punctuationchars STRING) (quotechars STRING)
          (escapechars STRING)) : (CONS OF CONS)
     Simple tokenizer that is somewhere between Java's StringTokenizer
     and StreamTokenizer in functionality.  It doens't specially
     support number tokens nor comment strings/sequences even though
     this could be added at the expense of some extra complexity.
     Returns a list of (<token-string> <token-type>) pairs, where the
     token type is one of :TEXT, :PUNCTUATION or :QUOTE, i.e., all
     white space is ignored and escape characters are handled and
     removed.  For example:

            (tokenize-string "for(i='fo^'o'; i>0; i++)" "()=<>+-;" "'" "^")
            =>
            (("for" :TEXT) ("(" :PUNCTUATION) ("i" :TEXT)
             ("=" :PUNCTUATION) ("'" :QUOTE) ("fo'o" :TEXT)
             ("'" :QUOTE) (";" :PUNCTUATION) ("i" :TEXT)
             (">" :PUNCTUATION) ("0" :TEXT) (";" :PUNCTUATION)
             ("i" :TEXT) ("++)" :PUNCTUATION))

     NOTE: this aggregates multiple punctuation characters that
     immediately follow each other into a single token which is
     (generally) useful to pickup multi-character operators such as ++,
     >=, etc.  It's still easy to pick them apart in a post-processing
     step if necessary (e.g., for the `++)' case above), so we leave
     this for now as a feature.

 -- Macro: trace-if ((keyword OBJECT) &body (body CONS)) : OBJECT
     If KEYWORD is a trace keyword that has been enabled with
     `add-trace' print all the elements in BODY to standard output.
     Otherwise, do nothing.  KEYWORD can also be a list of keywords in
     which case printing is done if one or more of them are trace
     enabled.

 -- Command: translate-system ((systemName STRING)
          &rest (language&options OBJECT)) : BOOLEAN
     Translate all of the STELLA source files in system SYSTEMNAME into
     `language' (the optional first argument).  The following
     keyword/value `options' are recognized:

     `:language': can be used as an alternative to the optional
     language argument.  If not specified, the language of the running
     implementation is assumed.

     `:two-pass?' (default false): if true, all files will be scanned
     twice, once to load the signatures of objects defined in them, and
     once to actually translate the definitions.

     `:force-translation?' (default false): if true, files will be
     translated whether or not their translations are up-to-date.

     `:development-settings?' (default false): if true translation will
     favor safe, readable and debuggable code over efficiency
     (according to the value of `:development-settings' on the system
     definition).  If false, efficiency will be favored instead
     (according to the value of `:production-settings' on the system
     definition).

     `:production-settings?' (default true): inverse to
     `:development-settings?'.

 -- Function: translate-to-common-lisp? () : BOOLEAN
     Return `true' if current output language is Common-Lisp.

 -- Function: translate-to-cpp? () : BOOLEAN
     Return `true' if current output language is C++

 -- Function: translate-to-java? () : BOOLEAN
     Return `true' if current output language is Java

 -- Function: truncate ((n NUMBER)) : INTEGER
     Truncate N toward zero and return the result.

 -- Function: try-to-evaluate ((tree OBJECT)) : OBJECT
     Variant of `evaluate' that only evaluates TREE if it represents an
     evaluable expression.  If it does not, TREE is returned
     unmodified.  This can be used to implement commands with mixed
     argument evaluation strategies.

 -- Function: two-argument-least-common-superclass ((class1 CLASS)
          (class2 CLASS)) : CLASS
     Return the most specific class that is a superclass of both CLASS1
     and CLASS2.  If there is more than one, arbitrarily pick one.  If
     there is none, return `null'.

 -- Function: two-argument-least-common-supertype ((type1 TYPE-SPEC)
          (type2 TYPE-SPEC)) : TYPE-SPEC
     Return the most specific type that is a supertype of both TYPE1
     and TYPE2.  If there is more than one, arbitrarily pick one.  If
     there is none, return @VOID.  If one or both types are parametric,
     also try to generalize parameter types if necessary.

 -- Method on SLOT: type (self) : TYPE
     The type of a storage slot is its base type.

 -- Method on SLOT: type-specifier (self) : TYPE-SPEC
     If SELF has a complex type return its type specifier, otherwise,
     return `type' of SELF.

 -- Function: type-to-symbol ((type TYPE)) : SYMBOL
     Convert TYPE into a symbol with the same name and module.

 -- Method on SURROGATE: type-to-wrapped-type (self) : TYPE
     Return the wrapped type for the type SELF, or SELF if it is not a
     bare literal type.

 -- Function: unbound-surrogates ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF SURROGATE)
     Iterate over all unbound surrogates visible from MODULE.  Look at
     all modules if MODULE is `null'.  If LOCAL?, only consider
     surrogates interned in MODULE.

 -- Command: unbump-log-indent () :
     Decrease the indentation level for subsequent log messages.

 -- Function: unescape-html-string ((input STRING)) : STRING
     Replaces HTML escape sequences such as &amp; with their associated
     characters.

 -- Function: unescape-url-string ((input STRING)) : STRING
     Takes a string and replaces %-format URL escape sequences with
     their real character equivalent according to RFC 2396.

 -- Command: unprocessed-command-line-arguments () : (CONS OF
          STRING-WRAPPER)
     Return all command line arguments which have not yet been processed
     by (or been ignored by) `process-command-line-arguments'.  If
     arguments have not yet been processed, this will return NULL.

 -- Function: unregister-all-cmd-line-options () :
     Unregister all currently registered command line options.

 -- Function: unregister-cmd-line-option ((key STRING)) :
     Unregister the command line option identified by KEY under all its
     keys.

 -- Command: unset-stella-feature (&rest (features KEYWORD)) :
     Disable all listed STELLA FEATURES.

 -- Method on INTEGER: unsigned-shift-right-by-1 (arg) : INTEGER
     Shift ARG to the right by 1 position and 0-extend from the left.
     This does not preserve the sign of ARG and shifts the sign-bit
     just like a regular bit.  In Common-Lisp we can't do that directly
     and need to do some extra masking.

 -- Method on LONG-INTEGER: unsigned-shift-right-by-1 (arg) :
          LONG-INTEGER
     Shift ARG to the right by 1 position and 0-extend from the left.
     This does not preserve the sign of ARG and shifts the sign-bit
     just like a regular bit.  In Common-Lisp we can't do that directly
     and need to do some extra masking.

 -- Function: unstringify-stella-source ((source STRING)
          (module MODULE)) : OBJECT
     Unstringify a STELLA SOURCE string relative to MODULE, or
     `*MODULE*' if no module is specified.  This function allocates
     transient objects as opposed to `unstringify-in-module' or the
     regular `unstringify'.

 -- Function: unwrap-boolean ((wrapper BOOLEAN-WRAPPER)) : BOOLEAN
     Unwrap WRAPPER and return its values as a regular BOOLEAN.  Map
     NULL onto FALSE.

 -- Function: unwrap-function-code ((wrapper FUNCTION-CODE-WRAPPER)) :
          FUNCTION-CODE
     Unwrap WRAPPER and return the result.  Return NULL if WRAPPER is
     NULL.

 -- Function: unwrap-long-integer ((wrapper LONG-INTEGER-WRAPPER)) :
          LONG-INTEGER
     Unwrap WRAPPER and return the result.  Return NULL if WRAPPER is
     NULL.

 -- Function: unwrap-method-code ((wrapper METHOD-CODE-WRAPPER)) :
          METHOD-CODE
     Unwrap WRAPPER and return the result.  Return NULL if WRAPPER is
     NULL.

 -- Method on ABSTRACT-DICTIONARY-ITERATOR: value-setter (self
          (value (LIKE (ANY-VALUE SELF)))) : (LIKE (ANY-VALUE SELF))
     Abstract method needed to allow application of this method on
     abstract iterator classes that do not implement it.  By having
     this here all `next?' methods of dictionary iterators MUST use the
     `slot-value' paradigm to set the iterator value.

 -- Macro: warn (&body (body CONS)) : OBJECT
     Signal warning message, placing non-string arguments in quotes.

 -- Macro: with-network-stream ((binding CONS) &body (body CONS)) :
          OBJECT
     Sets up an unwind-protected form which opens a network socket
     stream to a host and port for input and output and closes it
     afterwards.  Separate variables as provided in the call are bound
     to the input and output streams. Syntax is (WITH-NETWORK-STREAM
     (varIn varOut hostname port) body+)

 -- Macro: with-permanent-objects (&body (body CONS)) : OBJECT
     Allocate `permanent' (as opposed to `transient') objects within
     the scope of this declaration.

 -- Macro: with-system-definition ((systemnameexpression OBJECT)
          &body (body CONS)) : OBJECT
     Set *currentSystemDefinition* to the system definition named
     `system'.  Set *currentSystemDefinitionSubdirectory* to match.
     Execute BODY within that scope.

 -- Macro: with-transient-objects (&body (body CONS)) : OBJECT
     Allocate `transient' (as opposed to `permanent') objects within
     the scope of this declaration.  CAUTION: The default assumption is
     the allocation of permanent objects.  The scope of
     `with-transient-objects' should be as small as possible, and the
     user has to make sure that code that wasn't explicitly written to
     account for transient objects will continue to work correctly.

 -- Function: wrap-boolean ((value BOOLEAN)) : BOOLEAN-WRAPPER
     Return a literal object whose value is the BOOLEAN VALUE.

 -- Function: wrap-function-code ((value FUNCTION-CODE)) :
          FUNCTION-CODE-WRAPPER
     Return a literal object whose value is the FUNCTION-CODE VALUE.

 -- Function: wrap-integer-value ((value LONG-INTEGER)) : NUMBER-WRAPPER
     Return a literal object whose value is VALUE.  Choose a regular
     integer wrapper unless VALUE is too large and needs to be stored
     in a long wrapper.

 -- Function: wrap-long-integer ((value LONG-INTEGER)) :
          LONG-INTEGER-WRAPPER
     Return a literal object whose value is the LONG-INTEGER VALUE.

 -- Function: wrap-method-code ((value METHOD-CODE)) :
          METHOD-CODE-WRAPPER
     Return a literal object whose value is the METHOD-CODE VALUE.

 -- Function: wrapped-type-to-type ((self TYPE)) : TYPE
     Return the unwrapped type for the wrapped type SELF, or SELF if it
     is not a wrapped type.

 -- Function: wrapper-value-type ((self WRAPPER)) : TYPE
     Return the type of the value stored in the wrapper SELF.

 -- Function: write-html-escaping-url-special-characters
          ((stream NATIVE-OUTPUT-STREAM) (input STRING)) :
     Writes a string and replaces unallowed URL characters according to
     RFC 2396 with %-format URL escape sequences.

 -- Method on STORAGE-SLOT: writer (self) : SYMBOL
     Name of a method called to write the value of the slot SELF.

 -- Function: xml-base-attribute? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML attribute object

 -- Function: xml-declaration-form? ((form OBJECT)) : BOOLEAN
     Return `true' if FORM is a CONS headed by an XML DECLARATION tag

 -- Function: xml-doctype-form? ((form OBJECT)) : BOOLEAN
     Return `true' if FORM is a CONS headed by a DOCTYPE tag

 -- Function: xml-element-form? ((form OBJECT)) : BOOLEAN
     Return `true' if FORM is a CONS headed by an XML ELEMENT tag

 -- Function: xml-global-attribute? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML attribute object

 -- Function: xml-local-attribute? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML attribute object

 -- Function: xml-processing-instruction-form? ((form OBJECT)) : BOOLEAN
     Return `true' if FORM is a CONS headed by an XML PROCESSING
     INSTRUCTION tag

 -- Function: xml-processing-instruction? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML processing instruction object

 -- Function: xml-token-list-to-s-expression
          ((tokenList TOKENIZER-TOKEN) (doctype XML-DOCTYPE)
          (doctype-definition? BOOLEAN)) : OBJECT
     Convert the XML TOKENLIST (using DOCTYPE for guidance) into a
     representative s-expression and return the result.    The DOCTYPE
     argument is currently only used for expansion of entity
     references.  It can be `null'.  The flag DOCTYPE-DEFINITION?
     should be true only when processing the DTD definition of a
     DOCTYPE tag, since it enables substitution of parameter entity
     values.

     Every XML tag is represented as a cons-list starting with the tag
     as its header, followed by a possibly empty list of keyword value
     pairs representing tag attributes, followed by a possibly empty
     list of content expressions which might themselves be XML
     expressions.  For example, the expression

     <a a1=v1 a2='v2'> foo <b a3=v3/> bar </a>

     becomes

     (<a> (<a1> "v1" <a2> "v2") "foo" (<b> (<a3> "v3")) "bar")

     when represented as an s-expression.  The tag names are subtypes
     of XML-OBJECT such as XML-ELEMENT, XML-LOCAL-ATTRIBUTE,
     XML-GLOBAL-ATTRIBUTE, etc.  ?, ! and [ prefixed tags are encoded
     as their own subtypes of XML-OBJECT, namely
     XML-PROCESSING-INSTRUCTION, XML-DECLARATION, XML-SPECIAL,
     XML-COMMENT, etc.  CDATA is an XML-SPECIAL tag with a name of
     CDATA.

     The name is available using class accessors.

 -- Function: yield-define-stella-class ((class CLASS)) : CONS
     Return a cons tree that (when evaluated) constructs a Stella class
     object.

 -- Function: zero-pad-integer ((value INTEGER) (size INTEGER)) : STRING
     Returns a string representing VALUE of at least length SIZE,
     padded if necessary with 0 characters.

 -- Method on INTEGER: zero? (x) : BOOLEAN
     Return true if X is 0.

 -- Method on LONG-INTEGER: zero? (x) : BOOLEAN
     Return true if X is 0.


File: manual.info,  Node: Function Index,  Next: Variable Index,  Prev: Library Functions,  Up: Top

Function Index
**************

 [index ]
* Menu:

* *:                                     Numbers.            (line   17)
* +:                                     Numbers.            (line   10)
* ++:                                    Numbers.            (line   30)
* -:                                     Numbers.            (line   13)
* --:                                    Numbers.            (line   35)
* /:                                     Numbers.            (line   20)
* 1+:                                    Numbers.            (line   24)
* 1-:                                    Numbers.            (line   27)
* 1d-aref on DIMENSIONAL-ARRAY-MIXIN:    Miscellaneous.      (line   16)
* 1d-aref-address on DIMENSIONAL-ARRAY-MIXIN: Miscellaneous. (line   20)
* 1d-aref-setter on DIMENSIONAL-ARRAY-MIXIN: Miscellaneous.  (line   27)
* 2d-aref on 2-DIMENSIONAL-ARRAY-MIXIN:  Miscellaneous.      (line   32)
* 2d-aref-address on 2-DIMENSIONAL-ARRAY-MIXIN: Miscellaneous.
                                                             (line   36)
* 2d-aref-setter on 2-DIMENSIONAL-ARRAY-MIXIN: Miscellaneous.
                                                             (line   43)
* <:                                     Numbers.            (line   43)
* <=:                                    Numbers.            (line   46)
* =:                                     Numbers.            (line   40)
* >:                                     Numbers.            (line   52)
* >=:                                    Numbers.            (line   49)
* abs on FLOAT:                          Numbers.            (line   91)
* abs on INTEGER:                        Numbers.            (line   88)
* abs on LONG-INTEGER:                   Miscellaneous.      (line   47)
* absolute-pathname?:                    Files.              (line  130)
* acos:                                  Numbers.            (line  127)
* activate-demon:                        Miscellaneous.      (line   50)
* active? on POLYMORPHIC-RELATION:       Miscellaneous.      (line   54)
* add-configuration-property:            Miscellaneous.      (line   58)
* add-current-date-substitution:         Miscellaneous.      (line   67)
* add-date-substitution:                 Miscellaneous.      (line   73)
* add-hook:                              Miscellaneous.      (line   87)
* add-load-path:                         Miscellaneous.      (line   90)
* add-property-value:                    Miscellaneous.      (line   94)
* add-trace:                             Miscellaneous.      (line  103)
* advance on ITERATOR:                   Iterators.          (line   24)
* advance-past-whitespace:               Miscellaneous.      (line  109)
* all-classes:                           Miscellaneous.      (line  114)
* all-contexts:                          Miscellaneous.      (line  119)
* all-defined?:                          Miscellaneous.      (line  122)
* all-functions:                         Miscellaneous.      (line  127)
* all-included-modules:                  Miscellaneous.      (line  133)
* all-lower-case-string?:                Strings.            (line   55)
* all-methods:                           Miscellaneous.      (line  139)
* all-modules:                           Miscellaneous.      (line  144)
* all-public-functions:                  Miscellaneous.      (line  148)
* all-public-methods:                    Miscellaneous.      (line  154)
* all-required-systems:                  Miscellaneous.      (line  160)
* all-slots:                             Miscellaneous.      (line  164)
* all-subcontexts:                       Miscellaneous.      (line  170)
* all-surrogates:                        Miscellaneous.      (line  176)
* all-symbols:                           Miscellaneous.      (line  182)
* all-upper-case-string?:                Strings.            (line   52)
* all-variables:                         Miscellaneous.      (line  188)
* allocate-iterator on ABSTRACT-ITERATOR: Miscellaneous.     (line  193)
* allocate-iterator on CONS:             CONS Lists and Trees.
                                                             (line  243)
* allocate-iterator on KEY-VALUE-LIST:   Property and Key-Value Lists.
                                                             (line  178)
* allocate-iterator on KEY-VALUE-MAP:    Key Value Maps.     (line   75)
* allocate-iterator on LIST:             Lists.              (line  163)
* allocate-iterator on MEMOIZABLE-ITERATOR: Miscellaneous.   (line  199)
* allocate-iterator on PROPERTY-LIST:    Property and Key-Value Lists.
                                                             (line   59)
* allocate-iterator on STELLA-HASH-TABLE: Hash Tables.       (line  174)
* allocation on STORAGE-SLOT:            Miscellaneous.      (line  202)
* append:                                CONS Lists and Trees.
                                                             (line  148)
* apply:                                 Miscellaneous.      (line  207)
* apply-boolean-method:                  Miscellaneous.      (line  212)
* apply-float-method:                    Miscellaneous.      (line  216)
* apply-integer-method:                  Miscellaneous.      (line  220)
* apply-long-integer-method:             Miscellaneous.      (line  224)
* apply-method:                          Miscellaneous.      (line  228)
* apply-string-method:                   Miscellaneous.      (line  232)
* asin:                                  Numbers.            (line  124)
* atan:                                  Numbers.            (line  130)
* atan2:                                 Numbers.            (line  133)
* autoload:                              Miscellaneous.      (line  236)
* base60-to-float:                       Miscellaneous.      (line  244)
* blank-string?:                         Miscellaneous.      (line  249)
* break-program:                         Miscellaneous.      (line  253)
* bump-log-indent:                       Miscellaneous.      (line  257)
* but-last on CONS:                      CONS Lists and Trees.
                                                             (line   79)
* but-last on LIST:                      Lists.              (line   68)
* but-last on VECTOR:                    Vectors.            (line   62)
* byte-array-read-sequence:              Miscellaneous.      (line  261)
* byte-array-write-sequence:             Miscellaneous.      (line  268)
* calendar-date-to-date-string on CALENDAR-DATE: Miscellaneous.
                                                             (line  273)
* calendar-date-to-iso8601-string on CALENDAR-DATE: Miscellaneous.
                                                             (line  281)
* calendar-date-to-string:               Dates and Times.    (line   50)
* calendar-date-to-string on CALENDAR-DATE: Miscellaneous.   (line  290)
* calendar-date-to-time-string on CALENDAR-DATE: Miscellaneous.
                                                             (line  303)
* call-clear-module:                     Miscellaneous.      (line  311)
* case:                                  Conditionals.       (line   68)
* cast:                                  Miscellaneous.      (line  317)
* cc:                                    Contexts and Modules.
                                                             (line   33)
* ccc:                                   Miscellaneous.      (line  320)
* ceiling:                               Numbers.            (line   79)
* change-context on CONTEXT:             Contexts and Modules.
                                                             (line   27)
* change-context on STRING:              Contexts and Modules.
                                                             (line   30)
* change-module on MODULE:               Contexts and Modules.
                                                             (line  173)
* change-module on STRING:               Contexts and Modules.
                                                             (line  176)
* character-capitalize:                  Characters.         (line   38)
* character-code:                        Characters.         (line    7)
* character-downcase:                    Characters.         (line   28)
* character-to-string <1>:               Strings.            (line  240)
* character-to-string:                   Characters.         (line   44)
* character-upcase:                      Characters.         (line   32)
* choose:                                Conditionals.       (line   58)
* cl-slot-value:                         Miscellaneous.      (line  331)
* cl-slot-value-setter:                  Miscellaneous.      (line  339)
* cl-translate-file:                     Miscellaneous.      (line  347)
* cl-translate-system:                   Miscellaneous.      (line  351)
* cleanup-unfinalized-classes:           Miscellaneous.      (line  354)
* clear on HEAP:                         Miscellaneous.      (line  361)
* clear on KEY-VALUE-LIST:               Property and Key-Value Lists.
                                                             (line  169)
* clear on KEY-VALUE-MAP:                Key Value Maps.     (line   70)
* clear on LIST:                         Lists.              (line  156)
* clear on PROPERTY-LIST:                Property and Key-Value Lists.
                                                             (line   54)
* clear on STELLA-HASH-TABLE:            Hash Tables.        (line  157)
* clear on VECTOR:                       Vectors.            (line   94)
* clear on VECTOR-SEQUENCE:              Miscellaneous.      (line  358)
* clear-configuration-property:          Miscellaneous.      (line  365)
* clear-context:                         Contexts and Modules.
                                                             (line   13)
* clear-module:                          Contexts and Modules.
                                                             (line  144)
* clear-recycle-list:                    Miscellaneous.      (line  369)
* clear-recycle-lists:                   Miscellaneous.      (line  372)
* clear-system:                          Miscellaneous.      (line  375)
* clear-trace:                           Miscellaneous.      (line  382)
* clone-memoized-iterator:               Miscellaneous.      (line  386)
* close-all-files:                       Files.              (line   40)
* close-stream:                          Files.              (line   37)
* clv:                                   Miscellaneous.      (line  391)
* code-character:                        Characters.         (line   10)
* coerce-&rest-to-cons:                  Miscellaneous.      (line  399)
* coerce-option-value:                   Miscellaneous.      (line  405)
* coerce-to-boolean:                     Miscellaneous.      (line  408)
* coerce-to-float:                       Miscellaneous.      (line  412)
* coerce-to-hash-set:                    Miscellaneous.      (line  416)
* coerce-to-string:                      Miscellaneous.      (line  421)
* coerce-to-symbol:                      Miscellaneous.      (line  425)
* coerce-value-to-boolean:               Miscellaneous.      (line  430)
* coerce-value-to-float:                 Miscellaneous.      (line  435)
* coerce-value-to-string:                Miscellaneous.      (line  440)
* coerce-value-to-type:                  Miscellaneous.      (line  445)
* collect:                               Miscellaneous.      (line  449)
* collection-valued? on SLOT:            Miscellaneous.      (line  463)
* command?:                              Miscellaneous.      (line  466)
* component? on STORAGE-SLOT:            Miscellaneous.      (line  469)
* compose-namestring:                    Miscellaneous.      (line  475)
* compose-namestring-full:               Miscellaneous.      (line  492)
* compute-calendar-date:                 Dates and Times.    (line   62)
* compute-day-of-week:                   Dates and Times.    (line   67)
* compute-day-of-week-julian:            Dates and Times.    (line   71)
* compute-julian-day:                    Dates and Times.    (line   75)
* compute-module-and-bare-name:          Miscellaneous.      (line  497)
* compute-next-moon-phase:               Dates and Times.    (line   81)
* concatenate on CONS:                   CONS Lists and Trees.
                                                             (line  140)
* concatenate on ITERATOR:               Iterators.          (line   29)
* concatenate on LIST:                   Lists.              (line  141)
* concatenate on SET:                    Lists as Sets.      (line   71)
* concatenate on STRING:                 Strings.            (line  151)
* cond:                                  Conditionals.       (line   40)
* config-file-option-handler:            Miscellaneous.      (line  505)
* configure-stella:                      Miscellaneous.      (line  510)
* cons:                                  CONS Lists and Trees.
                                                             (line   44)
* cons-list:                             CONS Lists and Trees.
                                                             (line  169)
* cons-tree-match?:                      CONS Lists and Trees.
                                                             (line  236)
* cons-tree-nth:                         CONS Lists and Trees.
                                                             (line  198)
* cons-tree-nth-rest:                    CONS Lists and Trees.
                                                             (line  208)
* consify on CONS:                       CONS Lists and Trees.
                                                             (line  239)
* consify on HASH-SET:                   Hash Sets.          (line   71)
* consify on ITERATOR:                   Iterators.          (line   36)
* consify on KEY-VALUE-LIST:             Property and Key-Value Lists.
                                                             (line  173)
* consify on KEY-VALUE-MAP:              Key Value Maps.     (line   81)
* consify on LIST:                       Lists.              (line  159)
* consify on OBJECT:                     Miscellaneous.      (line  515)
* consify on STELLA-HASH-TABLE:          Hash Tables.        (line  161)
* consify on VECTOR:                     Vectors.            (line  103)
* consify-command-line-arguments:        Miscellaneous.      (line  520)
* continuable-error:                     Miscellaneous.      (line  523)
* copy on CUSTOM-VECTOR-SEQUENCE:        Miscellaneous.      (line  531)
* copy on HASH-SET:                      Hash Sets.          (line   65)
* copy on KEY-VALUE-LIST:                Property and Key-Value Lists.
                                                             (line  165)
* copy on KEY-VALUE-MAP:                 Key Value Maps.     (line   65)
* copy on LIST:                          Lists.              (line  152)
* copy on PROPERTY-LIST:                 Property and Key-Value Lists.
                                                             (line   50)
* copy on STELLA-HASH-TABLE:             Hash Tables.        (line  151)
* copy on STRING:                        Strings.            (line  138)
* copy on VECTOR:                        Vectors.            (line   91)
* copy on VECTOR-SEQUENCE:               Miscellaneous.      (line  527)
* copy-cons-list:                        CONS Lists and Trees.
                                                             (line  177)
* copy-cons-tree:                        CONS Lists and Trees.
                                                             (line  180)
* copy-file:                             Files.              (line   70)
* copy-kv-cons-list:                     Property and Key-Value Lists.
                                                             (line   87)
* copy-stream-to-stream:                 Miscellaneous.      (line  535)
* cos:                                   Numbers.            (line  118)
* cpp-translate-system:                  Miscellaneous.      (line  538)
* cpptrans:                              Miscellaneous.      (line  541)
* create-derived-list:                   Miscellaneous.      (line  544)
* create-object:                         Miscellaneous.      (line  548)
* create-world:                          Contexts and Modules.
                                                             (line  180)
* deactivate-demon:                      Miscellaneous.      (line  559)
* decode-calendar-date on CALENDAR-DATE: Dates and Times.    (line   41)
* decode-time-in-millis:                 Dates and Times.    (line   87)
* decoded-date-time-to-iso8601-string on DECODED-DATE-TIME: Miscellaneous.
                                                             (line  564)
* decompose-namestring:                  Miscellaneous.      (line  571)
* decompose-namestring-full:             Miscellaneous.      (line  600)
* default-cmd-line-option-handler:       Miscellaneous.      (line  605)
* default-form on STORAGE-SLOT:          Miscellaneous.      (line  609)
* defdemon:                              Miscellaneous.      (line  614)
* define-demon:                          Miscellaneous.      (line  618)
* define-logical-host-property:          Miscellaneous.      (line  624)
* define-module:                         Miscellaneous.      (line  637)
* define-stella-class:                   Miscellaneous.      (line  643)
* define-stella-method-slot:             Miscellaneous.      (line  650)
* defined-list?:                         Lists.              (line   19)
* defined? on ARRAY:                     Miscellaneous.      (line  657)
* defined? on CHARACTER:                 Basic Constants and Predicates.
                                                             (line   64)
* defined? on CODE:                      Basic Constants and Predicates.
                                                             (line   67)
* defined? on FLOAT:                     Basic Constants and Predicates.
                                                             (line   73)
* defined? on INTEGER:                   Basic Constants and Predicates.
                                                             (line   70)
* defined? on LONG-INTEGER:              Miscellaneous.      (line  654)
* defined? on MUTABLE-STRING:            Basic Constants and Predicates.
                                                             (line   61)
* defined? on NATIVE-VECTOR:             Basic Constants and Predicates.
                                                             (line   55)
* defined? on OBJECT:                    Basic Constants and Predicates.
                                                             (line   49)
* defined? on SECOND-CLASS-OBJECT:       Basic Constants and Predicates.
                                                             (line   52)
* defined? on STRING:                    Basic Constants and Predicates.
                                                             (line   58)
* defmain:                               Miscellaneous.      (line  660)
* defmodule:                             Contexts and Modules.
                                                             (line   39)
* defsystem:                             Miscellaneous.      (line  675)
* delete-file:                           Files.              (line   74)
* deleted? on OBJECT:                    Miscellaneous.      (line  699)
* describe:                              Miscellaneous.      (line  705)
* describe-object on OBJECT:             Miscellaneous.      (line  710)
* destroy-class on CLASS:                Miscellaneous.      (line  715)
* destroy-class-and-subclasses:          Miscellaneous.      (line  719)
* destroy-context on CONTEXT:            Contexts and Modules.
                                                             (line   20)
* destroy-context on MODULE:             Contexts and Modules.
                                                             (line  154)
* destroy-context on STRING:             Contexts and Modules.
                                                             (line   23)
* destroy-context on WORLD:              Contexts and Modules.
                                                             (line  193)
* destroy-module:                        Contexts and Modules.
                                                             (line  150)
* destructure-defmethod-tree:            Miscellaneous.      (line  723)
* dictionary:                            Miscellaneous.      (line  734)
* difference on CONS:                    CONS Lists as Sets. (line   29)
* difference on HASH-SET:                Hash Sets.          (line   96)
* difference on LIST:                    Lists as Sets.      (line   34)
* digit-character?:                      Characters.         (line   13)
* direct-super-classes on CLASS:         Miscellaneous.      (line  740)
* directory-file-name:                   Files.              (line   92)
* directory-parent-directory:            Files.              (line   97)
* directory-separator:                   Files.              (line  142)
* directory-separator-string:            Files.              (line  145)
* disable-memoization:                   Miscellaneous.      (line  744)
* disabled-stella-feature?:              Miscellaneous.      (line  747)
* div:                                   Numbers.            (line   67)
* div on INTEGER:                        Miscellaneous.      (line  750)
* div on LONG-INTEGER:                   Miscellaneous.      (line  753)
* drop-hook:                             Miscellaneous.      (line  756)
* drop-load-path:                        Miscellaneous.      (line  759)
* drop-trace:                            Miscellaneous.      (line  763)
* either:                                Miscellaneous.      (line  768)
* empty? on CONS:                        CONS Lists and Trees.
                                                             (line   22)
* empty? on HEAP:                        Miscellaneous.      (line  777)
* empty? on ITERATOR:                    Iterators.          (line    7)
* empty? on KEY-VALUE-LIST:              Property and Key-Value Lists.
                                                             (line  102)
* empty? on KEY-VALUE-MAP:               Key Value Maps.     (line   59)
* empty? on LIST:                        Lists.              (line   25)
* empty? on PROPERTY-LIST:               Property and Key-Value Lists.
                                                             (line   19)
* empty? on STELLA-HASH-TABLE:           Hash Tables.        (line  145)
* empty? on STRING:                      Strings.            (line   16)
* empty? on STRING-WRAPPER:              Miscellaneous.      (line  771)
* empty? on VECTOR:                      Vectors.            (line   23)
* empty? on VECTOR-SEQUENCE:             Miscellaneous.      (line  774)
* enable-memoization:                    Miscellaneous.      (line  780)
* enabled-stella-feature?:               Miscellaneous.      (line  783)
* encode-calendar-date on DECODED-DATE-TIME: Dates and Times.
                                                             (line   47)
* ends-with?:                            Miscellaneous.      (line  787)
* ensure-file-does-not-exist:            Miscellaneous.      (line  792)
* ensure-file-exists:                    Miscellaneous.      (line  797)
* eq?:                                   Basic Constants and Predicates.
                                                             (line   76)
* eql-except-in-whitespace?:             Miscellaneous.      (line  803)
* eql?:                                  Basic Constants and Predicates.
                                                             (line   80)
* equal-cons-trees?:                     CONS Lists and Trees.
                                                             (line   32)
* equal-hash-code on CONS:               CONS Lists and Trees.
                                                             (line   40)
* equal-hash-code on HASH-SET:           Hash Sets.          (line  114)
* equal-hash-code on KEY-VALUE-LIST:     Property and Key-Value Lists.
                                                             (line  111)
* equal-hash-code on KEY-VALUE-MAP:      Key Value Maps.     (line   88)
* equal-hash-code on LIST:               Lists.              (line   35)
* equal-hash-code on OBJECT:             Hash Tables.        (line  228)
* equal-hash-code on PROPERTY-LIST:      Property and Key-Value Lists.
                                                             (line   28)
* equal-hash-code on SET:                Lists as Sets.      (line   83)
* equal-hash-code on STELLA-HASH-TABLE:  Hash Tables.        (line  168)
* equal-hash-code on VECTOR:             Vectors.            (line   33)
* equal?:                                Basic Constants and Predicates.
                                                             (line   90)
* equivalent-sets? on CONS:              CONS Lists as Sets. (line   13)
* equivalent-sets? on HASH-SET:          Hash Sets.          (line   80)
* equivalent-sets? on LIST:              Lists as Sets.      (line   18)
* error:                                 Miscellaneous.      (line  808)
* eval-in-module-option-handler:         Miscellaneous.      (line  812)
* eval-option-handler:                   Miscellaneous.      (line  817)
* evaluate:                              Miscellaneous.      (line  820)
* evaluate-string:                       Miscellaneous.      (line  831)
* even?:                                 Numbers.            (line   61)
* even? on INTEGER:                      Miscellaneous.      (line  836)
* even? on LONG-INTEGER:                 Miscellaneous.      (line  839)
* exception-message:                     Miscellaneous.      (line  842)
* exp:                                   Numbers.            (line  103)
* expt:                                  Numbers.            (line  106)
* extension on CLASS:                    Miscellaneous.      (line  845)
* external-id-head?:                     Miscellaneous.      (line  849)
* false:                                 Basic Constants and Predicates.
                                                             (line   10)
* fast-heap-root on HEAP:                Miscellaneous.      (line  853)
* fifth on CONS:                         CONS Lists and Trees.
                                                             (line   63)
* fifth on LIST:                         Lists.              (line   54)
* fifth on MUTABLE-STRING:               Strings.            (line   95)
* fifth on STRING:                       Strings.            (line   92)
* fifth on VECTOR:                       Vectors.            (line   51)
* file-base-name:                        Files.              (line  126)
* file-extension:                        Files.              (line  122)
* file-length:                           Files.              (line   66)
* file-name-as-directory:                Files.              (line  102)
* file-name-directory:                   Files.              (line  108)
* file-name-without-directory:           Files.              (line  114)
* file-name-without-extension:           Files.              (line  118)
* file-write-date:                       Files.              (line   62)
* fill-in-date-substitution:             Miscellaneous.      (line  858)
* finalize-classes:                      Miscellaneous.      (line  865)
* finalize-classes-and-slots:            Miscellaneous.      (line  868)
* finalize-slots:                        Miscellaneous.      (line  871)
* find-file-in-load-path:                Miscellaneous.      (line  875)
* find-matching-prefix-length:           Miscellaneous.      (line  884)
* find-mismatch:                         Miscellaneous.      (line  893)
* find-or-create-module:                 Contexts and Modules.
                                                             (line  140)
* first on CONS:                         CONS Lists and Trees.
                                                             (line   47)
* first on LIST:                         Lists.              (line   42)
* first on MUTABLE-STRING:               Strings.            (line   71)
* first on STRING:                       Strings.            (line   68)
* first on VECTOR:                       Vectors.            (line   39)
* first-defined:                         Miscellaneous.      (line  901)
* float-to-base60:                       Miscellaneous.      (line  906)
* float-to-string <1>:                   Strings.            (line  229)
* float-to-string:                       Numbers.            (line  146)
* floor:                                 Numbers.            (line   82)
* flush-output:                          Input and Output.   (line   45)
* fmod:                                  Miscellaneous.      (line  915)
* format-float <1>:                      Strings.            (line  236)
* format-float:                          Numbers.            (line  153)
* format-with-padding:                   Miscellaneous.      (line  923)
* fourth on CONS:                        CONS Lists and Trees.
                                                             (line   59)
* fourth on LIST:                        Lists.              (line   51)
* fourth on MUTABLE-STRING:              Strings.            (line   89)
* fourth on STRING:                      Strings.            (line   86)
* fourth on VECTOR:                      Vectors.            (line   48)
* free on ACTIVE-OBJECT:                 Miscellaneous.      (line  931)
* free on OBJECT:                        Miscellaneous.      (line  935)
* free-hash-table-values on ABSTRACT-HASH-TABLE: Miscellaneous.
                                                             (line  938)
* frem:                                  Miscellaneous.      (line  941)
* gcd:                                   Numbers.            (line   76)
* generate-random-uuid:                  Miscellaneous.      (line  948)
* generate-uuid:                         Miscellaneous.      (line  964)
* gensym:                                Symbols.            (line  122)
* get-calendar-date on CALENDAR-DATE:    Miscellaneous.      (line  971)
* get-current-date-time:                 Dates and Times.    (line    8)
* get-global-value:                      Miscellaneous.      (line  977)
* get-load-path:                         Miscellaneous.      (line  981)
* get-local-standard-time-zone:          Miscellaneous.      (line  984)
* get-local-time-zone:                   Dates and Times.    (line   14)
* get-local-time-zone-for-date:          Miscellaneous.      (line  990)
* get-log-stream:                        Miscellaneous.      (line  996)
* get-property:                          Miscellaneous.      (line 1000)
* get-quoted-tree:                       Miscellaneous.      (line 1008)
* get-slot:                              Miscellaneous.      (line 1012)
* get-stella-class on STRING:            Miscellaneous.      (line 1027)
* get-stella-class on SURROGATE:         Miscellaneous.      (line 1017)
* get-stella-class on SYMBOL:            Miscellaneous.      (line 1022)
* get-stella-context:                    Contexts and Modules.
                                                             (line    8)
* get-stella-module:                     Contexts and Modules.
                                                             (line  134)
* get-ticktock:                          Dates and Times.    (line  126)
* get-time on CALENDAR-DATE:             Miscellaneous.      (line 1032)
* get-token-float:                       Miscellaneous.      (line 1038)
* get-token-integer:                     Miscellaneous.      (line 1046)
* get-token-long-integer:                Miscellaneous.      (line 1051)
* get-xml-attributes:                    XML Support.        (line   27)
* get-xml-base-attribute-value:          Miscellaneous.      (line 1056)
* get-xml-cdata-content:                 XML Support.        (line   34)
* get-xml-content:                       XML Support.        (line   30)
* get-xml-tag:                           XML Support.        (line   24)
* global-variable-type-spec:             Miscellaneous.      (line 1061)
* hash-code on BOOLEAN-WRAPPER:          Hash Tables.        (line  213)
* hash-code on CHARACTER:                Hash Tables.        (line  225)
* hash-code on CHARACTER-WRAPPER:        Hash Tables.        (line  210)
* hash-code on FLOAT:                    Hash Tables.        (line  222)
* hash-code on FLOAT-WRAPPER:            Hash Tables.        (line  207)
* hash-code on INTEGER:                  Hash Tables.        (line  219)
* hash-code on INTEGER-WRAPPER:          Hash Tables.        (line  204)
* hash-code on OBJECT:                   Hash Tables.        (line  192)
* hash-code on STANDARD-OBJECT:          Hash Tables.        (line  198)
* hash-code on STRING:                   Hash Tables.        (line  216)
* hash-code on STRING-WRAPPER:           Hash Tables.        (line  201)
* hash-set:                              Hash Sets.          (line   26)
* hash-string:                           Miscellaneous.      (line 1064)
* hashmod:                               Hash Tables.        (line  240)
* heap-root on HEAP:                     Miscellaneous.      (line 1072)
* heapify on HEAP:                       Miscellaneous.      (line 1075)
* help-advance-past-whitespace:          Miscellaneous.      (line 1082)
* help-find-matching-prefix-length:      Miscellaneous.      (line 1088)
* help-get-stella-module:                Miscellaneous.      (line 1093)
* help-option-handler:                   Miscellaneous.      (line 1100)
* help-print-outline on CLASS:           Miscellaneous.      (line 1104)
* help-print-outline on CONTEXT:         Miscellaneous.      (line 1120)
* help-print-outline on MODULE:          Miscellaneous.      (line 1108)
* help-print-outline on OBJECT:          Miscellaneous.      (line 1112)
* help-print-outline on SLOT:            Miscellaneous.      (line 1116)
* home-module on OBJECT:                 Miscellaneous.      (line 1123)
* if:                                    Conditionals.       (line   13)
* if-output-language:                    Miscellaneous.      (line 1127)
* if-stella-feature:                     Miscellaneous.      (line 1133)
* ignore:                                Miscellaneous.      (line 1138)
* import-surrogate:                      Symbols.            (line  101)
* import-symbol:                         Symbols.            (line   46)
* in-module:                             Contexts and Modules.
                                                             (line  170)
* incrementally-translate:               Miscellaneous.      (line 1141)
* indent-outline:                        Miscellaneous.      (line 1147)
* inform:                                Miscellaneous.      (line 1152)
* initial-value on CLASS:                Miscellaneous.      (line 1156)
* initial-value on STORAGE-SLOT:         Miscellaneous.      (line 1159)
* initialize-array on DIMENSIONAL-ARRAY-MIXIN: Miscellaneous.
                                                             (line 1166)
* initialize-hash-table on STELLA-HASH-TABLE: Miscellaneous. (line 1169)
* initially on STORAGE-SLOT:             Miscellaneous.      (line 1175)
* insert on CUSTOM-VECTOR-SEQUENCE:      Miscellaneous.      (line 1179)
* insert on HASH-SET:                    Hash Sets.          (line   34)
* insert on HEAP:                        Miscellaneous.      (line 1183)
* insert on LIST:                        Lists.              (line   99)
* insert on SET:                         Lists as Sets.      (line   56)
* insert on VECTOR-SEQUENCE:             Vectors.            (line  111)
* insert-at on EXTENSIBLE-VECTOR:        Vectors.            (line  107)
* insert-at on FLOAT-HASH-TABLE:         Hash Tables.        (line   91)
* insert-at on HASH-TABLE:               Hash Tables.        (line   57)
* insert-at on INTEGER-HASH-TABLE:       Hash Tables.        (line   87)
* insert-at on KEY-VALUE-LIST:           Property and Key-Value Lists.
                                                             (line  126)
* insert-at on KEY-VALUE-MAP:            Key Value Maps.     (line   46)
* insert-at on PROPERTY-LIST:            Property and Key-Value Lists.
                                                             (line   40)
* insert-at on STELLA-HASH-TABLE:        Hash Tables.        (line  132)
* insert-at on STRING-HASH-TABLE:        Hash Tables.        (line   68)
* insert-at on STRING-TO-INTEGER-HASH-TABLE: Hash Tables.    (line   79)
* insert-at on VECTOR:                   Vectors.            (line   88)
* insert-entry on KEY-VALUE-LIST:        Property and Key-Value Lists.
                                                             (line  137)
* insert-if-better on HEAP:              Miscellaneous.      (line 1190)
* insert-last on LIST:                   Lists.              (line  109)
* insert-last on SET:                    Lists as Sets.      (line   62)
* insert-new on LIST:                    Lists.              (line  105)
* insert-string:                         Strings.            (line  189)
* instantiate-string-template:           Strings.            (line  181)
* integer-length:                        Miscellaneous.      (line 1200)
* integer-to-hex-string:                 Miscellaneous.      (line 1204)
* integer-to-string <1>:                 Strings.            (line  222)
* integer-to-string:                     Numbers.            (line  139)
* integer-to-string-in-base:             Miscellaneous.      (line 1209)
* integer-valued?:                       Miscellaneous.      (line 1217)
* intern-derived-surrogate:              Symbols.            (line   83)
* intern-derived-symbol:                 Symbols.            (line   29)
* intern-keyword:                        Symbols.            (line  118)
* intern-stella-name:                    Miscellaneous.      (line 1221)
* intern-surrogate:                      Symbols.            (line   64)
* intern-surrogate-in-module:            Symbols.            (line   77)
* intern-symbol:                         Symbols.            (line   10)
* intern-symbol-in-module:               Symbols.            (line   23)
* interpret-command-line-arguments:      Miscellaneous.      (line 1228)
* intersection on CONS:                  CONS Lists as Sets. (line   24)
* intersection on HASH-SET:              Hash Sets.          (line   86)
* intersection on LIST:                  Lists as Sets.      (line   29)
* isa?:                                  Miscellaneous.      (line 1231)
* java-translate-system:                 Miscellaneous.      (line 1234)
* jptrans:                               Miscellaneous.      (line 1237)
* julian-day-to-modified-julian-day:     Dates and Times.    (line   92)
* keyword-name?:                         Miscellaneous.      (line 1240)
* kv-cons:                               Property and Key-Value Lists.
                                                             (line   84)
* kv-push on KEY-VALUE-LIST:             Property and Key-Value Lists.
                                                             (line  154)
* kvlist-to-plist:                       Miscellaneous.      (line 1244)
* last on CONS:                          CONS Lists and Trees.
                                                             (line   75)
* last on LIST:                          Lists.              (line   64)
* last on VECTOR:                        Vectors.            (line   58)
* last on VECTOR-SEQUENCE:               Miscellaneous.      (line 1248)
* last-cons:                             CONS Lists and Trees.
                                                             (line   83)
* last-position on CONS:                 CONS Lists and Trees.
                                                             (line  106)
* last-position on LIST:                 Lists.              (line   92)
* last-position on STRING:               Strings.            (line  125)
* last-position on VECTOR:               Vectors.            (line   80)
* length on 2-DIMENSIONAL-ARRAY-MIXIN:   Miscellaneous.      (line 1260)
* length on ABSTRACT-ITERATOR:           Iterators.          (line   15)
* length on CONS:                        CONS Lists and Trees.
                                                             (line   86)
* length on CONS-ITERATOR:               Miscellaneous.      (line 1251)
* length on DIMENSIONAL-ARRAY-MIXIN:     Miscellaneous.      (line 1257)
* length on HEAP:                        Miscellaneous.      (line 1254)
* length on KEY-VALUE-LIST:              Property and Key-Value Lists.
                                                             (line  115)
* length on KEY-VALUE-MAP:               Key Value Maps.     (line   56)
* length on LIST:                        Lists.              (line   71)
* length on MUTABLE-STRING:              Strings.            (line  110)
* length on PROPERTY-LIST:               Property and Key-Value Lists.
                                                             (line   32)
* length on STELLA-HASH-TABLE:           Hash Tables.        (line  142)
* length on STRING:                      Strings.            (line  107)
* length on VECTOR:                      Vectors.            (line   65)
* length on VECTOR-SEQUENCE:             Vectors.            (line  120)
* letter-character?:                     Characters.         (line   16)
* lispify:                               Miscellaneous.      (line 1263)
* lispify-boolean:                       Miscellaneous.      (line 1270)
* list:                                  Lists.              (line   39)
* list*:                                 CONS Lists and Trees.
                                                             (line  172)
* list-directory-files:                  Miscellaneous.      (line 1275)
* list-modules:                          Miscellaneous.      (line 1286)
* listify on CONS:                       Miscellaneous.      (line 1291)
* listify on ITERATOR:                   Miscellaneous.      (line 1305)
* listify on KEY-VALUE-LIST:             Miscellaneous.      (line 1298)
* listify on LIST:                       Miscellaneous.      (line 1294)
* listify on VECTOR:                     Miscellaneous.      (line 1301)
* load-configuration-file:               Miscellaneous.      (line 1309)
* load-file:                             Miscellaneous.      (line 1316)
* load-file-option-handler:              Miscellaneous.      (line 1324)
* load-path-option-handler:              Miscellaneous.      (line 1328)
* load-system:                           Miscellaneous.      (line 1332)
* local-gensym:                          Symbols.            (line  126)
* log:                                   Numbers.            (line  109)
* log-level<=:                           Miscellaneous.      (line 1349)
* log-message:                           Miscellaneous.      (line 1354)
* log10:                                 Numbers.            (line  112)
* logical-host?:                         Files.              (line  133)
* logical-pathname?:                     Files.              (line  136)
* logmsg:                                Miscellaneous.      (line 1360)
* lookup on HASH-TABLE:                  Hash Tables.        (line   53)
* lookup on INTEGER-HASH-TABLE:          Hash Tables.        (line   83)
* lookup on KEY-VALUE-LIST:              Property and Key-Value Lists.
                                                             (line  119)
* lookup on KEY-VALUE-MAP:               Key Value Maps.     (line   40)
* lookup on PROPERTY-LIST:               Property and Key-Value Lists.
                                                             (line   36)
* lookup on STELLA-HASH-TABLE:           Hash Tables.        (line  126)
* lookup on STRING-HASH-TABLE:           Hash Tables.        (line   64)
* lookup on STRING-TO-INTEGER-HASH-TABLE: Hash Tables.       (line   75)
* lookup-class on STRING:                Miscellaneous.      (line 1369)
* lookup-class on SYMBOL:                Miscellaneous.      (line 1365)
* lookup-command:                        Miscellaneous.      (line 1373)
* lookup-configuration-property:         Miscellaneous.      (line 1380)
* lookup-configuration-property-values:  Miscellaneous.      (line 1387)
* lookup-demon:                          Miscellaneous.      (line 1393)
* lookup-function:                       Miscellaneous.      (line 1396)
* lookup-function-by-name:               Miscellaneous.      (line 1399)
* lookup-global-variable on GENERALIZED-SYMBOL: Miscellaneous.
                                                             (line 1408)
* lookup-global-variable on STRING:      Miscellaneous.      (line 1411)
* lookup-global-variable on SURROGATE:   Miscellaneous.      (line 1404)
* lookup-keyword:                        Symbols.            (line  115)
* lookup-local-slot:                     Miscellaneous.      (line 1415)
* lookup-logging-parameter:              Miscellaneous.      (line 1419)
* lookup-macro:                          Miscellaneous.      (line 1423)
* lookup-slot:                           Miscellaneous.      (line 1427)
* lookup-surrogate:                      Symbols.            (line   60)
* lookup-surrogate-in-module:            Symbols.            (line   71)
* lookup-symbol:                         Symbols.            (line    7)
* lookup-symbol-in-module:               Symbols.            (line   17)
* lookup-visible-surrogates-in-module:   Symbols.            (line   92)
* lookup-visible-symbols-in-module:      Symbols.            (line   38)
* lookup-with-default on KEY-VALUE-LIST: Miscellaneous.      (line 1441)
* lookup-with-default on PROPERTY-LIST:  Miscellaneous.      (line 1435)
* lower-case-character?:                 Characters.         (line   22)
* lptrans:                               Miscellaneous.      (line 1445)
* make-current-date-time:                Dates and Times.    (line   18)
* make-date-time:                        Dates and Times.    (line   24)
* make-matching-name:                    Miscellaneous.      (line 1449)
* make-matching-name-full:               Miscellaneous.      (line 1512)
* make-mutable-string:                   Strings.            (line   62)
* make-raw-mutable-string:               Strings.            (line   65)
* make-string:                           Strings.            (line   58)
* make-system:                           Miscellaneous.      (line 1517)
* make-temporary-file-name:              Files.              (line   81)
* make-xml-element:                      XML Support.        (line    8)
* make-xml-global-attribute:             XML Support.        (line   16)
* make-xml-local-attribute:              XML Support.        (line   21)
* map-null-to-nil:                       CONS Lists and Trees.
                                                             (line  265)
* map-null-to-nil-list:                  Lists.              (line  179)
* match-cons-tree:                       CONS Lists and Trees.
                                                             (line  219)
* max:                                   Numbers.            (line   97)
* max on FLOAT:                          Miscellaneous.      (line 1565)
* max on INTEGER:                        Miscellaneous.      (line 1557)
* max on LONG-INTEGER:                   Miscellaneous.      (line 1561)
* max on NUMBER-WRAPPER:                 Miscellaneous.      (line 1570)
* memb? on CONS:                         CONS Lists and Trees.
                                                             (line   93)
* memb? on LIST:                         Lists.              (line   79)
* member? on COLLECTION:                 Miscellaneous.      (line 1577)
* member? on CONS:                       CONS Lists and Trees.
                                                             (line   89)
* member? on CONS-ITERATOR:              Miscellaneous.      (line 1573)
* member? on HASH-SET:                   Hash Sets.          (line   29)
* member? on ITERATOR:                   Iterators.          (line   11)
* member? on LIST:                       Lists.              (line   74)
* member? on SEQUENCE:                   Miscellaneous.      (line 1580)
* member? on STRING:                     Strings.            (line  113)
* member? on VECTOR:                     Vectors.            (line   68)
* memoize:                               Miscellaneous.      (line 1583)
* merge-file-names:                      Miscellaneous.      (line 1616)
* merge-null-fields on DECODED-DATE-TIME: Miscellaneous.     (line 1621)
* merge-superior-null-fields on DECODED-DATE-TIME: Miscellaneous.
                                                             (line 1626)
* min:                                   Numbers.            (line   94)
* min on FLOAT:                          Miscellaneous.      (line 1645)
* min on INTEGER:                        Miscellaneous.      (line 1637)
* min on LONG-INTEGER:                   Miscellaneous.      (line 1641)
* min on NUMBER-WRAPPER:                 Miscellaneous.      (line 1650)
* mod:                                   Numbers.            (line   73)
* mod on INTEGER:                        Miscellaneous.      (line 1653)
* mod on LONG-INTEGER:                   Miscellaneous.      (line 1660)
* modified-julian-day-to-julian-day:     Dates and Times.    (line   97)
* multiple-parents? on CLASS:            Miscellaneous.      (line 1666)
* multiple-parents? on MODULE:           Miscellaneous.      (line 1669)
* multiple-parents? on WORLD:            Miscellaneous.      (line 1672)
* mutable-string-to-string:              Strings.            (line  218)
* name-to-string:                        Miscellaneous.      (line 1675)
* native-delete-file:                    Miscellaneous.      (line 1679)
* native-file-length:                    Miscellaneous.      (line 1683)
* native-file-write-date:                Miscellaneous.      (line 1689)
* native-probe-file?:                    Miscellaneous.      (line 1694)
* native-read-line:                      Miscellaneous.      (line 1699)
* native-rename-file:                    Miscellaneous.      (line 1704)
* next? on ALL-PURPOSE-ITERATOR:         Iterators.          (line   39)
* next? on CONS-ITERATOR:                CONS Lists and Trees.
                                                             (line  246)
* next? on KV-LIST-ITERATOR:             Property and Key-Value Lists.
                                                             (line  181)
* next? on LIST-ITERATOR:                Lists.              (line  166)
* next? on MEMOIZABLE-ITERATOR:          Miscellaneous.      (line 1708)
* next? on PROPERTY-LIST-ITERATOR:       Property and Key-Value Lists.
                                                             (line   62)
* nil?:                                  CONS Lists and Trees.
                                                             (line   28)
* no-duplicates? on COLLECTION:          Miscellaneous.      (line 1713)
* non-empty? on CONS:                    CONS Lists and Trees.
                                                             (line   25)
* non-empty? on KEY-VALUE-LIST:          Property and Key-Value Lists.
                                                             (line  105)
* non-empty? on KEY-VALUE-MAP:           Key Value Maps.     (line   62)
* non-empty? on LIST:                    Lists.              (line   28)
* non-empty? on PROPERTY-LIST:           Property and Key-Value Lists.
                                                             (line   22)
* non-empty? on STELLA-HASH-TABLE:       Hash Tables.        (line  148)
* non-empty? on STRING:                  Strings.            (line   19)
* non-empty? on STRING-WRAPPER:          Miscellaneous.      (line 1716)
* non-empty? on VECTOR:                  Vectors.            (line   26)
* non-empty? on VECTOR-SEQUENCE:         Miscellaneous.      (line 1719)
* non-matching-position:                 Miscellaneous.      (line 1723)
* non-matching-position-helper:          Miscellaneous.      (line 1728)
* nth on CONS:                           CONS Lists and Trees.
                                                             (line   68)
* nth on LIST:                           Lists.              (line   58)
* nth on MUTABLE-STRING:                 Strings.            (line  101)
* nth on NATIVE-VECTOR:                  Miscellaneous.      (line 1733)
* nth on STRING:                         Strings.            (line   98)
* nth on VECTOR:                         Vectors.            (line   55)
* nth-rest on CONS:                      CONS Lists and Trees.
                                                             (line   72)
* null-list?:                            Lists.              (line   22)
* null? on ARRAY:                        Miscellaneous.      (line 1740)
* null? on CHARACTER:                    Basic Constants and Predicates.
                                                             (line   33)
* null? on CODE:                         Basic Constants and Predicates.
                                                             (line   37)
* null? on FLOAT:                        Basic Constants and Predicates.
                                                             (line   45)
* null? on INTEGER:                      Basic Constants and Predicates.
                                                             (line   41)
* null? on LONG-INTEGER:                 Miscellaneous.      (line 1736)
* null? on MUTABLE-STRING:               Basic Constants and Predicates.
                                                             (line   29)
* null? on NATIVE-VECTOR:                Basic Constants and Predicates.
                                                             (line   21)
* null? on OBJECT:                       Basic Constants and Predicates.
                                                             (line   13)
* null? on SECOND-CLASS-OBJECT:          Basic Constants and Predicates.
                                                             (line   17)
* null? on STRING:                       Basic Constants and Predicates.
                                                             (line   25)
* number-less-than?:                     Miscellaneous.      (line 1745)
* object-equal? on CONS:                 CONS Lists and Trees.
                                                             (line   36)
* object-equal? on HASH-SET:             Hash Sets.          (line  108)
* object-equal? on KEY-VALUE-LIST:       Property and Key-Value Lists.
                                                             (line  108)
* object-equal? on KEY-VALUE-MAP:        Key Value Maps.     (line   85)
* object-equal? on LIST:                 Lists.              (line   31)
* object-equal? on OBJECT:               Basic Constants and Predicates.
                                                             (line   97)
* object-equal? on PROPERTY-LIST:        Property and Key-Value Lists.
                                                             (line   25)
* object-equal? on SET:                  Lists as Sets.      (line   78)
* object-equal? on STELLA-HASH-TABLE:    Hash Tables.        (line  165)
* object-equal? on VECTOR:               Vectors.            (line   29)
* object-equal? on VECTOR-SEQUENCE:      Miscellaneous.      (line 1749)
* object-equal? on WRAPPER:              Basic Constants and Predicates.
                                                             (line  100)
* object-hash-code:                      Hash Tables.        (line  185)
* odd?:                                  Numbers.            (line   64)
* odd? on INTEGER:                       Miscellaneous.      (line 1753)
* odd? on LONG-INTEGER:                  Miscellaneous.      (line 1756)
* only-if:                               Miscellaneous.      (line 1759)
* open-input-file:                       Files.              (line    8)
* open-network-stream:                   Miscellaneous.      (line 1763)
* open-output-file:                      Files.              (line   18)
* operating-system:                      Miscellaneous.      (line   12)
* ordered? on COLLECTION:                Miscellaneous.      (line 1767)
* outline-depth-exceeded?:               Miscellaneous.      (line 1771)
* parameters on CLASS:                   Miscellaneous.      (line 1777)
* parse-date-time:                       Dates and Times.    (line   33)
* parse-date-time-in-time-zone:          Miscellaneous.      (line 1782)
* parse-date-time-relative-to-base:      Miscellaneous.      (line 1794)
* parse-options:                         Miscellaneous.      (line 1809)
* parse-stella-name:                     Miscellaneous.      (line 1820)
* pick-hash-table-size-prime:            Miscellaneous.      (line 1834)
* plist-to-kvlist:                       Miscellaneous.      (line 1838)
* plus?:                                 Numbers.            (line   58)
* plus? on INTEGER:                      Miscellaneous.      (line 1842)
* plus? on LONG-INTEGER:                 Miscellaneous.      (line 1845)
* pop on HASH-SET:                       Hash Sets.          (line   51)
* pop on ITERATOR:                       Iterators.          (line   20)
* pop on KEY-VALUE-LIST:                 Property and Key-Value Lists.
                                                             (line  160)
* pop on LIST:                           Lists.              (line  131)
* pop-load-path:                         Miscellaneous.      (line 1848)
* pop-world:                             Contexts and Modules.
                                                             (line  188)
* popq:                                  CONS Lists and Trees.
                                                             (line  166)
* position on CONS:                      CONS Lists and Trees.
                                                             (line   98)
* position on LIST:                      Lists.              (line   84)
* position on STRING:                    Strings.            (line  117)
* position on VECTOR:                    Vectors.            (line   72)
* prepend on CONS:                       CONS Lists and Trees.
                                                             (line  152)
* prepend on LIST:                       Lists.              (line  148)
* primary-type on OBJECT:                Miscellaneous.      (line 1852)
* primitive? on RELATION:                Miscellaneous.      (line 1856)
* print:                                 Miscellaneous.      (line 1859)
* print-configuration-properties:        Miscellaneous.      (line 1863)
* print-exception-context:               Miscellaneous.      (line 1867)
* print-outline:                         Miscellaneous.      (line 1873)
* print-properties:                      Miscellaneous.      (line 1883)
* print-recycle-lists:                   Miscellaneous.      (line 1887)
* print-spaces:                          Miscellaneous.      (line 1890)
* print-stella-features:                 Miscellaneous.      (line 1894)
* print-unbound-surrogates:              Miscellaneous.      (line 1897)
* print-undefined-methods:               Miscellaneous.      (line 1904)
* print-undefined-super-classes:         Miscellaneous.      (line 1911)
* print-xml-expression:                  XML Support.        (line  137)
* private-class-methods:                 Miscellaneous.      (line 1915)
* private-class-storage-slots:           Miscellaneous.      (line 1919)
* private? on RELATION:                  Miscellaneous.      (line 1922)
* probe-file?:                           Files.              (line   58)
* process-command-line-arguments:        Miscellaneous.      (line 1927)
* process-doctype:                       Miscellaneous.      (line 1938)
* ptrans:                                Miscellaneous.      (line 1942)
* public-class-methods:                  Miscellaneous.      (line 1946)
* public-class-storage-slots:            Miscellaneous.      (line 1950)
* public-slots on CLASS:                 Miscellaneous.      (line 1953)
* public-slots on OBJECT:                Miscellaneous.      (line 1956)
* public? on SLOT:                       Miscellaneous.      (line 1959)
* push on KEY-VALUE-LIST:                Property and Key-Value Lists.
                                                             (line  146)
* push on LIST:                          Lists.              (line  102)
* push on SET:                           Lists as Sets.      (line   59)
* push-load-path:                        Miscellaneous.      (line 1962)
* push-world:                            Contexts and Modules.
                                                             (line  184)
* pushf:                                 Miscellaneous.      (line 1966)
* pushq:                                 CONS Lists and Trees.
                                                             (line  159)
* pushq-new:                             CONS Lists and Trees.
                                                             (line  162)
* qualified-stella-name?:                Miscellaneous.      (line 1969)
* random:                                Numbers.            (line  136)
* read-character:                        Input and Output.   (line   22)
* read-line:                             Input and Output.   (line   14)
* read-line2:                            Miscellaneous.      (line 1975)
* read-s-expression:                     Input and Output.   (line    7)
* read-s-expression-from-string:         Input and Output.   (line   11)
* read-xml-expression:                   XML Support.        (line  109)
* read-xml-expressions:                  Miscellaneous.      (line 1984)
* reader on STORAGE-SLOT:                Miscellaneous.      (line 1988)
* register-cmd-line-option:              Miscellaneous.      (line 1991)
* regular-integer-valued?:               Miscellaneous.      (line 2014)
* relative-date-to-string:               Dates and Times.    (line   58)
* rem:                                   Numbers.            (line   70)
* rem on INTEGER:                        Miscellaneous.      (line 2017)
* rem on LONG-INTEGER:                   Miscellaneous.      (line 2023)
* remove on CONS:                        CONS Lists and Trees.
                                                             (line  116)
* remove on HASH-SET:                    Hash Sets.          (line   40)
* remove on LIST:                        Lists.              (line  116)
* remove on STRING:                      Strings.            (line  163)
* remove on VECTOR-SEQUENCE:             Vectors.            (line  116)
* remove-at on HASH-TABLE:               Hash Tables.        (line   60)
* remove-at on KEY-VALUE-LIST:           Property and Key-Value Lists.
                                                             (line  131)
* remove-at on KEY-VALUE-MAP:            Key Value Maps.     (line   52)
* remove-at on PROPERTY-LIST:            Property and Key-Value Lists.
                                                             (line   45)
* remove-at on STELLA-HASH-TABLE:        Hash Tables.        (line  138)
* remove-at on STRING-HASH-TABLE:        Hash Tables.        (line   71)
* remove-configuration-property:         Miscellaneous.      (line 2030)
* remove-deleted-members on LIST:        Lists.              (line  123)
* remove-duplicates on COLLECTION:       Miscellaneous.      (line 2034)
* remove-duplicates on CONS:             CONS Lists and Trees.
                                                             (line  121)
* remove-duplicates on LIST:             Lists.              (line  119)
* remove-duplicates-equal on CONS:       Miscellaneous.      (line 2038)
* remove-duplicates-equal on LIST:       Miscellaneous.      (line 2041)
* remove-entry on KEY-VALUE-LIST:        Property and Key-Value Lists.
                                                             (line  142)
* remove-if on CONS:                     CONS Lists and Trees.
                                                             (line  127)
* remove-if on HASH-SET:                 Hash Sets.          (line   46)
* remove-if on LIST:                     Lists.              (line  126)
* rename-file:                           Files.              (line   77)
* replace-heap-root on HEAP:             Miscellaneous.      (line 2045)
* replace-substrings:                    Strings.            (line  177)
* required-slots on CLASS:               Miscellaneous.      (line 2051)
* required? on STORAGE-SLOT:             Miscellaneous.      (line 2054)
* reset-stella-features:                 Miscellaneous.      (line 2057)
* reset-xml-hash-tables:                 XML Support.        (line  151)
* resize-vector:                         Vectors.            (line   97)
* rest on LIST:                          Lists.              (line   61)
* rest on STRING:                        Strings.            (line  104)
* reverse on CONS:                       CONS Lists and Trees.
                                                             (line  113)
* reverse on KEY-VALUE-LIST:             Property and Key-Value Lists.
                                                             (line  122)
* reverse on LIST:                       Lists.              (line  112)
* reverse on VECTOR-SEQUENCE:            Miscellaneous.      (line 2060)
* reverse-interval:                      Miscellaneous.      (line 2064)
* rotate-hash-code:                      Hash Tables.        (line  249)
* round:                                 Numbers.            (line   85)
* run-hooks:                             Miscellaneous.      (line 2067)
* running-as-lisp?:                      Miscellaneous.      (line 2070)
* running-in-language:                   Miscellaneous.      (line 2073)
* running-system-information:            Miscellaneous.      (line 2077)
* safe-equal-hash-code:                  Miscellaneous.      (line 2081)
* safe-hash-code:                        Miscellaneous.      (line 2087)
* safe-import-surrogate:                 Symbols.            (line  109)
* safe-import-symbol:                    Symbols.            (line   54)
* safe-lookup-slot:                      Miscellaneous.      (line 2091)
* safe-tree-size:                        CONS Lists and Trees.
                                                             (line  195)
* safety:                                Miscellaneous.      (line 2095)
* save-configuration-file:               Miscellaneous.      (line 2099)
* save-configuration-value:              Miscellaneous.      (line 2104)
* search-cons-tree-with-filter?:         Miscellaneous.      (line 2108)
* search-cons-tree?:                     CONS Lists and Trees.
                                                             (line  188)
* search-for-object:                     Miscellaneous.      (line 2114)
* second on CONS:                        CONS Lists and Trees.
                                                             (line   51)
* second on LIST:                        Lists.              (line   45)
* second on MUTABLE-STRING:              Strings.            (line   77)
* second on STRING:                      Strings.            (line   74)
* second on VECTOR:                      Vectors.            (line   42)
* seed-random-number-generator:          Miscellaneous.      (line 2118)
* sequence:                              Miscellaneous.      (line 2122)
* set:                                   Lists as Sets.      (line   87)
* set-call-log-break-point:              Miscellaneous.      (line 2125)
* set-configuration-property:            Miscellaneous.      (line 2130)
* set-current-date on DECODED-DATE-TIME: Miscellaneous.      (line 2134)
* set-current-date-time on DECODED-DATE-TIME: Miscellaneous. (line 2138)
* set-current-time on DECODED-DATE-TIME: Miscellaneous.      (line 2141)
* set-global-value:                      Miscellaneous.      (line 2145)
* set-load-path:                         Miscellaneous.      (line 2149)
* set-log-level:                         Miscellaneous.      (line 2153)
* set-logging-parameters:                Miscellaneous.      (line 2158)
* set-optimization-levels:               Miscellaneous.      (line 2171)
* set-property:                          Miscellaneous.      (line 2175)
* set-stella-feature:                    Miscellaneous.      (line 2181)
* set-translator-output-language:        Miscellaneous.      (line 2185)
* setq?:                                 Miscellaneous.      (line 2188)
* shadowed-symbol?:                      Miscellaneous.      (line 2192)
* shift-right on INTEGER:                Miscellaneous.      (line 2195)
* shift-right on LONG-INTEGER:           Miscellaneous.      (line 2202)
* signal:                                Miscellaneous.      (line 2208)
* signal-read-error:                     Miscellaneous.      (line 2211)
* sin:                                   Numbers.            (line  115)
* sleep:                                 Dates and Times.    (line  146)
* sort on CONS:                          CONS Lists and Trees.
                                                             (line  250)
* sort on HEAP:                          Miscellaneous.      (line 2225)
* sort on LIST:                          Lists.              (line  170)
* sort on VECTOR:                        Miscellaneous.      (line 2215)
* sort-tuples on CONS:                   CONS Lists and Trees.
                                                             (line  261)
* split-string:                          Miscellaneous.      (line 2237)
* sqrt:                                  Numbers.            (line  100)
* start-function-call-logging:           Miscellaneous.      (line 2240)
* starts-with?:                          Miscellaneous.      (line 2244)
* stella-collection?:                    Miscellaneous.      (line 2248)
* stella-information:                    Miscellaneous.      (line 2251)
* stella-object?:                        Miscellaneous.      (line 2255)
* stella-version-string:                 Miscellaneous.      (line 2258)
* stellafy:                              Miscellaneous.      (line 2261)
* stellify:                              Miscellaneous.      (line 2267)
* stop-function-call-logging:            Miscellaneous.      (line 2270)
* stream-position on INPUT-FILE-STREAM:  Miscellaneous.      (line 2276)
* stream-position on OUTPUT-FILE-STREAM: Miscellaneous.      (line 2273)
* stream-position-setter on INPUT-FILE-STREAM: Miscellaneous.
                                                             (line 2285)
* stream-position-setter on OUTPUT-FILE-STREAM: Miscellaneous.
                                                             (line 2280)
* stream-to-string on INPUT-STREAM:      Miscellaneous.      (line 2293)
* string-capitalize:                     Strings.            (line  147)
* string-compare:                        Strings.            (line   23)
* string-downcase:                       Strings.            (line  144)
* string-eql?:                           Strings.            (line    7)
* string-equal?:                         Strings.            (line   12)
* string-greater-equal?:                 Strings.            (line   46)
* string-greater?:                       Strings.            (line   49)
* string-less-equal?:                    Strings.            (line   43)
* string-less?:                          Strings.            (line   40)
* string-search:                         Strings.            (line  133)
* string-search-ignore-case:             Miscellaneous.      (line 2297)
* string-to-calendar-date:               Dates and Times.    (line   53)
* string-to-calendar-date-with-default:  Miscellaneous.      (line 2303)
* string-to-decoded-date-time:           Miscellaneous.      (line 2313)
* string-to-float <1>:                   Strings.            (line  233)
* string-to-float:                       Numbers.            (line  150)
* string-to-integer <1>:                 Strings.            (line  226)
* string-to-integer:                     Numbers.            (line  143)
* string-to-mutable-string:              Strings.            (line  214)
* string-to-surrogate:                   Miscellaneous.      (line 2318)
* string-to-time-duration:               Miscellaneous.      (line 2325)
* string-trim:                           Miscellaneous.      (line 2331)
* string-upcase:                         Strings.            (line  141)
* string<:                               Strings.            (line   28)
* string<=:                              Strings.            (line   31)
* string>:                               Strings.            (line   37)
* string>=:                              Strings.            (line   34)
* stringify:                             Strings.            (line  243)
* stringify-in-module:                   Strings.            (line  249)
* subclass-of?:                          Miscellaneous.      (line 2338)
* subsequence on MUTABLE-STRING:         Miscellaneous.      (line 2342)
* subsequence on STRING:                 Strings.            (line  158)
* subset? on CONS:                       CONS Lists as Sets. (line    7)
* subset? on HASH-SET:                   Hash Sets.          (line   74)
* subset? on LIST:                       Lists as Sets.      (line   12)
* substitute on CONS:                    CONS Lists and Trees.
                                                             (line  135)
* substitute on HASH-SET:                Hash Sets.          (line   60)
* substitute on LIST:                    Lists.              (line  136)
* substitute on MUTABLE-STRING:          Strings.            (line  172)
* substitute on SET:                     Lists as Sets.      (line   66)
* substitute on STRING:                  Strings.            (line  167)
* substitute-characters on MUTABLE-STRING: Miscellaneous.    (line 2354)
* substitute-characters on STRING:       Miscellaneous.      (line 2348)
* substitute-cons-tree:                  CONS Lists and Trees.
                                                             (line  184)
* subtract on CONS:                      CONS Lists as Sets. (line   35)
* subtract on HASH-SET:                  Hash Sets.          (line  102)
* subtract on LIST:                      Lists as Sets.      (line   40)
* subtype-of?:                           Miscellaneous.      (line 2361)
* super-classes on CLASS:                Miscellaneous.      (line 2365)
* surrogate-name?:                       Miscellaneous.      (line 2369)
* surrogatify on STRING:                 Miscellaneous.      (line 2379)
* surrogatify on SURROGATE:              Miscellaneous.      (line 2372)
* surrogatify on SYMBOL:                 Miscellaneous.      (line 2375)
* sweep on OBJECT:                       Miscellaneous.      (line 2382)
* symbol-plist:                          Symbols.            (line  129)
* symbol-property:                       Symbols.            (line  136)
* symbol-to-surrogate:                   Miscellaneous.      (line 2385)
* symbol-to-type:                        Miscellaneous.      (line 2393)
* symbol-value:                          Symbols.            (line  140)
* symbolize:                             Symbols.            (line  147)
* system-default-value on SLOT:          Miscellaneous.      (line 2400)
* system-default-value on STORAGE-SLOT:  Miscellaneous.      (line 2396)
* system-loaded-or-started-up?:          Miscellaneous.      (line 2404)
* system-loaded?:                        Miscellaneous.      (line 2408)
* tan:                                   Numbers.            (line  121)
* terminate-program:                     Miscellaneous.      (line 2411)
* third on CONS:                         CONS Lists and Trees.
                                                             (line   55)
* third on LIST:                         Lists.              (line   48)
* third on MUTABLE-STRING:               Strings.            (line   83)
* third on STRING:                       Strings.            (line   80)
* third on VECTOR:                       Vectors.            (line   45)
* ticktock-difference:                   Dates and Times.    (line  134)
* ticktock-resolution:                   Dates and Times.    (line  139)
* time-add:                              Dates and Times.    (line  102)
* time-divide:                           Dates and Times.    (line  108)
* time-duration-to-string on TIME-DURATION: Miscellaneous.   (line 2414)
* time-multiply:                         Dates and Times.    (line  114)
* time-subtract:                         Dates and Times.    (line  119)
* time-zone-format60:                    Miscellaneous.      (line 2418)
* toggle-output-language:                Miscellaneous.      (line 2422)
* tokenize-string:                       Miscellaneous.      (line 2427)
* trace-if:                              Miscellaneous.      (line 2452)
* translate-logical-pathname:            Files.              (line  139)
* translate-system:                      Miscellaneous.      (line 2460)
* translate-to-common-lisp?:             Miscellaneous.      (line 2486)
* translate-to-cpp?:                     Miscellaneous.      (line 2489)
* translate-to-java?:                    Miscellaneous.      (line 2492)
* tree-size:                             CONS Lists and Trees.
                                                             (line  192)
* true:                                  Basic Constants and Predicates.
                                                             (line    7)
* truncate:                              Miscellaneous.      (line 2495)
* try-to-evaluate:                       Miscellaneous.      (line 2498)
* two-argument-least-common-superclass:  Miscellaneous.      (line 2505)
* two-argument-least-common-supertype:   Miscellaneous.      (line 2511)
* type on SLOT:                          Miscellaneous.      (line 2517)
* type-specifier on SLOT:                Miscellaneous.      (line 2520)
* type-to-symbol:                        Miscellaneous.      (line 2524)
* type-to-wrapped-type on SURROGATE:     Miscellaneous.      (line 2527)
* typecase:                              Conditionals.       (line   96)
* unbound-surrogates:                    Miscellaneous.      (line 2532)
* unbump-log-indent:                     Miscellaneous.      (line 2537)
* unescape-html-string:                  Miscellaneous.      (line 2540)
* unescape-url-string:                   Miscellaneous.      (line 2544)
* unintern-surrogate:                    Symbols.            (line   67)
* unintern-symbol:                       Symbols.            (line   13)
* union on CONS:                         CONS Lists as Sets. (line   19)
* union on HASH-SET:                     Hash Sets.          (line   91)
* union on LIST:                         Lists as Sets.      (line   24)
* unless:                                Conditionals.       (line   31)
* unprocessed-command-line-arguments:    Miscellaneous.      (line 2549)
* unread-character:                      Input and Output.   (line   27)
* unregister-all-cmd-line-options:       Miscellaneous.      (line 2554)
* unregister-cmd-line-option:            Miscellaneous.      (line 2557)
* unset-stella-feature:                  Miscellaneous.      (line 2561)
* unsigned-shift-right-by-1 on INTEGER:  Miscellaneous.      (line 2564)
* unsigned-shift-right-by-1 on LONG-INTEGER: Miscellaneous.  (line 2571)
* unstringify:                           Strings.            (line  253)
* unstringify-in-module:                 Strings.            (line  258)
* unstringify-stella-source:             Miscellaneous.      (line 2578)
* unwrap-boolean:                        Miscellaneous.      (line 2584)
* unwrap-character:                      Characters.         (line   50)
* unwrap-float:                          Numbers.            (line  167)
* unwrap-function-code:                  Miscellaneous.      (line 2589)
* unwrap-integer:                        Numbers.            (line  160)
* unwrap-long-integer:                   Miscellaneous.      (line 2594)
* unwrap-method-code:                    Miscellaneous.      (line 2599)
* unwrap-mutable-string:                 Strings.            (line  210)
* unwrap-string:                         Strings.            (line  205)
* upper-case-character?:                 Characters.         (line   19)
* value-setter on ABSTRACT-DICTIONARY-ITERATOR: Miscellaneous.
                                                             (line 2604)
* vector:                                Vectors.            (line   36)
* visible-modules:                       Contexts and Modules.
                                                             (line  158)
* visible-surrogate?:                    Symbols.            (line   87)
* visible-symbol?:                       Symbols.            (line   33)
* warn:                                  Miscellaneous.      (line 2610)
* when:                                  Conditionals.       (line   23)
* white-space-character?:                Characters.         (line   25)
* with-input-file:                       Files.              (line   44)
* with-network-stream:                   Miscellaneous.      (line 2614)
* with-output-file:                      Files.              (line   51)
* with-permanent-objects:                Miscellaneous.      (line 2621)
* with-system-definition:                Miscellaneous.      (line 2626)
* with-transient-objects:                Miscellaneous.      (line 2631)
* within-context:                        Contexts and Modules.
                                                             (line   17)
* within-module:                         Contexts and Modules.
                                                             (line  164)
* within-world:                          Contexts and Modules.
                                                             (line  197)
* wrap-boolean:                          Miscellaneous.      (line 2639)
* wrap-character:                        Characters.         (line   47)
* wrap-float:                            Numbers.            (line  164)
* wrap-function-code:                    Miscellaneous.      (line 2643)
* wrap-integer:                          Numbers.            (line  157)
* wrap-integer-value:                    Miscellaneous.      (line 2646)
* wrap-long-integer:                     Miscellaneous.      (line 2652)
* wrap-method-code:                      Miscellaneous.      (line 2656)
* wrap-mutable-string:                   Strings.            (line  202)
* wrap-string:                           Strings.            (line  198)
* wrapped-type-to-type:                  Miscellaneous.      (line 2659)
* wrapper-value-type:                    Miscellaneous.      (line 2663)
* write-html-escaping-url-special-characters: Miscellaneous. (line 2667)
* writer on STORAGE-SLOT:                Miscellaneous.      (line 2671)
* xml-attribute-match? on XML-ATTRIBUTE: XML Support.        (line   62)
* xml-attribute-match? on XML-GLOBAL-ATTRIBUTE: XML Support. (line   69)
* xml-attribute-match? on XML-LOCAL-ATTRIBUTE: XML Support.  (line   76)
* xml-attribute?:                        XML Support.        (line   45)
* xml-base-attribute?:                   Miscellaneous.      (line 2674)
* xml-cdata-form?:                       XML Support.        (line   51)
* xml-cdata?:                            XML Support.        (line   48)
* xml-declaration-form?:                 Miscellaneous.      (line 2677)
* xml-declaration?:                      XML Support.        (line   39)
* xml-doctype-form?:                     Miscellaneous.      (line 2680)
* xml-element-form?:                     Miscellaneous.      (line 2683)
* xml-element-match? on XML-ELEMENT:     XML Support.        (line   55)
* xml-element?:                          XML Support.        (line   42)
* xml-expressions:                       XML Support.        (line  128)
* xml-global-attribute?:                 Miscellaneous.      (line 2686)
* xml-local-attribute-match?:            XML Support.        (line   84)
* xml-local-attribute?:                  Miscellaneous.      (line 2689)
* xml-lookup-attribute:                  XML Support.        (line   89)
* xml-processing-instruction-form?:      Miscellaneous.      (line 2692)
* xml-processing-instruction?:           Miscellaneous.      (line 2696)
* xml-tag-case:                          XML Support.        (line   95)
* xml-token-list-to-s-expression:        Miscellaneous.      (line 2701)
* y-or-n?:                               Input and Output.   (line   31)
* yes-or-no?:                            Input and Output.   (line   38)
* yield-define-stella-class:             Miscellaneous.      (line 2732)
* zero-pad-integer:                      Miscellaneous.      (line 2736)
* zero?:                                 Numbers.            (line   55)
* zero? on INTEGER:                      Miscellaneous.      (line 2740)
* zero? on LONG-INTEGER:                 Miscellaneous.      (line 2743)


File: manual.info,  Node: Variable Index,  Next: Concept Index,  Prev: Function Index,  Up: Top

Variable Index
**************

 [index ]
* Menu:

* *printpretty?*:                        CONS Lists and Trees.
                                                              (line 268)
* *printprettycode?*:                    CONS Lists and Trees.
                                                              (line 274)
* *printreadably?*:                      CONS Lists and Trees.
                                                              (line 271)
* any-key <1>:                           Hash Tables.         (line  10)
* any-key:                               Property and Key-Value Lists.
                                                              (line  10)
* any-value <1>:                         Hash Tables.         (line  13)
* any-value <2>:                         Vectors.             (line  10)
* any-value <3>:                         Property and Key-Value Lists.
                                                              (line  13)
* any-value <4>:                         Lists as Sets.       (line  53)
* any-value <5>:                         Lists.               (line  10)
* any-value:                             CONS Lists and Trees.
                                                              (line  10)
* array-size:                            Vectors.             (line  13)
* crossover-point:                       Key Value Maps.      (line  36)
* equal-test? <1>:                       Key Value Maps.      (line  27)
* equal-test?:                           Hash Tables.         (line 120)
* free-elements:                         Hash Tables.         (line 117)
* initial-size <1>:                      Key Value Maps.      (line  32)
* initial-size:                          Hash Tables.         (line 113)
* key:                                   Property and Key-Value Lists.
                                                              (line  74)
* nil:                                   CONS Lists and Trees.
                                                              (line  19)
* nil-list:                              Lists.               (line  16)
* pi:                                    Numbers.             (line   7)
* rest <1>:                              Property and Key-Value Lists.
                                                              (line  80)
* rest:                                  CONS Lists and Trees.
                                                              (line  16)
* size:                                  Hash Tables.         (line 110)
* the-array:                             Vectors.             (line  17)
* the-cons-list:                         Lists.               (line  13)
* the-kv-list:                           Property and Key-Value Lists.
                                                              (line  99)
* the-map:                               Key Value Maps.      (line  24)
* the-plist:                             Property and Key-Value Lists.
                                                              (line  16)
* the-table:                             Hash Tables.         (line 107)
* value <1>:                             Property and Key-Value Lists.
                                                              (line  77)
* value:                                 CONS Lists and Trees.
                                                              (line  13)


File: manual.info,  Node: Concept Index,  Prev: Variable Index,  Up: Top

Concept Index
*************

 [index ]
* Menu:

